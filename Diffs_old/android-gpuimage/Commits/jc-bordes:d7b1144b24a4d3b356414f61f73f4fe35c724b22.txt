diff --git a/library/src/jp/co/cyberagent/android/gpuimage/GPUImage.java b/library/src/jp/co/cyberagent/android/gpuimage/GPUImage.java
index 06b65d4b..71fcb1a3 100644
--- a/library/src/jp/co/cyberagent/android/gpuimage/GPUImage.java
+++ b/library/src/jp/co/cyberagent/android/gpuimage/GPUImage.java
@@ -19,6 +19,7 @@
 import android.annotation.TargetApi;
 import android.app.ActivityManager;
 import android.content.Context;
+import android.content.SharedPreferences;
 import android.content.pm.ConfigurationInfo;
 import android.database.Cursor;
 import android.graphics.Bitmap;
@@ -71,6 +72,22 @@ public GPUImage(final Context context) {
         mRenderer = new GPUImageRenderer(mFilter);
     }
 
+    public void saveState(SharedPreferences prefs)
+	{
+		mRenderer.saveState(prefs);
+	}
+
+	public void restoreState(SharedPreferences prefs)
+	{
+		mRenderer.restoreState(prefs);
+	}
+    
+	public void translate(int dx,int dy)
+    {
+    	mRenderer.translate(dx,dy);
+        requestRender();
+    }
+	
     /**
      * Checks if OpenGL ES 2.0 is supported on the current device.
      * 
diff --git a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageFilterGroup.java b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageFilterGroup.java
index 0be65639..59b225b7 100644
--- a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageFilterGroup.java
+++ b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageFilterGroup.java
@@ -16,6 +16,7 @@
 
 package jp.co.cyberagent.android.gpuimage;
 
+import android.annotation.SuppressLint;
 import android.opengl.GLES20;
 import jp.co.cyberagent.android.gpuimage.util.TextureRotationUtil;
 
@@ -147,26 +148,43 @@ public void onOutputSizeChanged(final int width, final int height) {
      * @see jp.co.cyberagent.android.gpuimage.GPUImageFilter#onDraw(int,
      * java.nio.FloatBuffer, java.nio.FloatBuffer)
      */
+
+    @SuppressLint("WrongCall")    
     @Override
     public void onDraw(final int textureId, final FloatBuffer cubeBuffer,
-            final FloatBuffer textureBuffer) {
-        runPendingOnDrawTasks();
-        if (!isInitialized() || mFrameBuffers == null || mFrameBufferTextures == null) {
-            return;
-        }
-        int previousTexture = textureId;
-        for (int i = 0; i < mFilters.size() - 1; i++) {
-            GPUImageFilter filter = mFilters.get(i);
-            GLES20.glBindFramebuffer(GLES20.GL_FRAMEBUFFER, mFrameBuffers[i]);
-            GLES20.glClearColor(0, 0, 0, 1);
-            filter.onDraw(previousTexture, mGLCubeBuffer,
-                    (i == 0 && mFilters.size() % 2 == 0) ? mGLTextureFlipBuffer : mGLTextureBuffer);
-            GLES20.glBindFramebuffer(GLES20.GL_FRAMEBUFFER, 0);
-            previousTexture = mFrameBufferTextures[i];
-        }
-        mFilters.get(mFilters.size() - 1).onDraw(previousTexture, cubeBuffer, textureBuffer);
-    }
-
+             final FloatBuffer textureBuffer) 
+    {
+         runPendingOnDrawTasks();
+         if (!isInitialized() || mFrameBuffers == null || mFrameBufferTextures == null) {
+             return;
+         }
+         int size=mFilters.size() ;
+         int previousTexture = textureId;
+         for (int i=0;i<size; i++) {
+             GPUImageFilter filter = mFilters.get(i);
+             if(i<size-1)
+             {
+             	GLES20.glBindFramebuffer(GLES20.GL_FRAMEBUFFER, mFrameBuffers[i]);
+             	GLES20.glClearColor(0, 0, 0, 0);
+             }
+
+             if(i==0)
+             	filter.onDraw(previousTexture, cubeBuffer, textureBuffer);
+             else
+             {
+                 if(i==size-1)
+                 	filter.onDraw(previousTexture,mGLCubeBuffer,(size%2==0)?mGLTextureFlipBuffer:mGLTextureBuffer);
+                 else
+                 	filter.onDraw(previousTexture,mGLCubeBuffer,mGLTextureBuffer);
+             }
+
+             if(i<size-1)
+             {
+             	GLES20.glBindFramebuffer(GLES20.GL_FRAMEBUFFER, 0);
+             	previousTexture = mFrameBufferTextures[i];
+             }
+         }
+     }
     /**
      * Gets the filters.
      *
diff --git a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageRenderer.java b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageRenderer.java
index ac2e7c97..423f37b7 100644
--- a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageRenderer.java
+++ b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageRenderer.java
@@ -16,7 +16,10 @@
 
 package jp.co.cyberagent.android.gpuimage;
 
+import android.annotation.SuppressLint;
 import android.annotation.TargetApi;
+import android.content.SharedPreferences;
+import android.content.SharedPreferences.Editor;
 import android.graphics.Bitmap;
 import android.graphics.Canvas;
 import android.graphics.SurfaceTexture;
@@ -25,6 +28,7 @@
 import android.hardware.Camera.Size;
 import android.opengl.GLES20;
 import android.opengl.GLSurfaceView.Renderer;
+import jp.co.cyberagent.android.gpuimage.GPUImage.ScaleType;
 import jp.co.cyberagent.android.gpuimage.util.TextureRotationUtil;
 
 import javax.microedition.khronos.egl.EGLConfig;
@@ -65,6 +69,9 @@
     private int mImageHeight;
     private int mAddedPadding;
 
+    private float mDeltaX=0f;
+    private float mDeltaY=0f;
+    
     private final Queue<Runnable> mRunOnDraw;
     private Rotation mRotation;
     private boolean mFlipHorizontal;
@@ -85,27 +92,63 @@ public GPUImageRenderer(final GPUImageFilter filter) {
                 .asFloatBuffer();
         setRotation(Rotation.NORMAL, false, false);
     }
+    
+	public void saveState(SharedPreferences prefs)
+	{
+		if(prefs==null)
+			return;
+		
+		Editor ed=prefs.edit();
+		if(ed==null)
+			return;
+
+		ed.putFloat("EffectsManager.imageDeltaX",mDeltaX);
+		ed.putFloat("EffectsManager.imageDeltaY",mDeltaY);
+		
+		ed.commit();
+	}
+
+	public void restoreState(SharedPreferences prefs)
+	{
+		if(prefs==null)
+			return;
+
+		mDeltaX=prefs.getFloat("EffectsManager.imageDeltaX",0);
+		mDeltaY=prefs.getFloat("EffectsManager.imageDeltaY",0);
+	}
+
+	public void translate(int dx,int dy)
+    {
+    	mDeltaX+=dx;
+    	mDeltaY+=dy;
+    	adjustImageScaling();
+    }
 
     @Override
     public void onSurfaceCreated(final GL10 unused, final EGLConfig config) {
-        GLES20.glClearColor(0, 0, 0, 1);
+        GLES20.glClearColor(0, 0, 0, 0);
         GLES20.glDisable(GLES20.GL_DEPTH_TEST);
+        GLES20.glEnable(GLES20.GL_BLEND);
+        GLES20.glBlendFunc(GLES20.GL_SRC_ALPHA,GLES20.GL_ZERO);
         mFilter.init();
     }
 
     @Override
     public void onSurfaceChanged(final GL10 gl, final int width, final int height) {
-        mOutputWidth = width;
-        mOutputHeight = height;
-        GLES20.glViewport(0, 0, width, height);
+        mOutputWidth=width;
+        mOutputHeight=height;
+        
+        GLES20.glViewport(0,0,width,height);
         GLES20.glUseProgram(mFilter.getProgram());
-        mFilter.onOutputSizeChanged(width, height);
+        mFilter.onOutputSizeChanged(width,height);
+        adjustImageScaling();
         synchronized (mSurfaceChangedWaiter) {
             mSurfaceChangedWaiter.notifyAll();
         }
     }
-
-    @Override
+    
+    @SuppressLint("WrongCall")
+	@Override
     public void onDrawFrame(final GL10 gl) {
         GLES20.glClear(GLES20.GL_COLOR_BUFFER_BIT | GLES20.GL_DEPTH_BUFFER_BIT);
         synchronized (mRunOnDraw) {
@@ -240,8 +283,17 @@ protected int getFrameWidth() {
     protected int getFrameHeight() {
         return mOutputHeight;
     }
-
-    private void adjustImageScaling() {
+    
+    private void adjustImageScaling()
+    {
+    	if(mScaleType==ScaleType.CENTER_INSIDE)
+    		adjustImageScalingFitCenter();
+    	else
+    		adjustImageScalingCrop();
+    }
+    
+    private void adjustImageScalingFitCenter() 
+    {
         float outputWidth = mOutputWidth;
         float outputHeight = mOutputHeight;
         if (mRotation == Rotation.ROTATION_270 || mRotation == Rotation.ROTATION_90) {
@@ -265,30 +317,85 @@ private void adjustImageScaling() {
 
         float[] cube = CUBE;
         float[] textureCords = TextureRotationUtil.getRotation(mRotation, mFlipHorizontal, mFlipVertical);
-        if (mScaleType == GPUImage.ScaleType.CENTER_CROP) {
-            float distHorizontal = (1 / ratioWidth - 1) / 2;
-            float distVertical = (1 / ratioHeight - 1) / 2;
-            textureCords = new float[]{
-                    addDistance(textureCords[0], distVertical), addDistance(textureCords[1], distHorizontal),
-                    addDistance(textureCords[2], distVertical), addDistance(textureCords[3], distHorizontal),
-                    addDistance(textureCords[4], distVertical), addDistance(textureCords[5], distHorizontal),
-                    addDistance(textureCords[6], distVertical), addDistance(textureCords[7], distHorizontal),
-            };
-        } else {
-            cube = new float[]{
-                    CUBE[0] * ratioWidth, CUBE[1] * ratioHeight,
-                    CUBE[2] * ratioWidth, CUBE[3] * ratioHeight,
-                    CUBE[4] * ratioWidth, CUBE[5] * ratioHeight,
-                    CUBE[6] * ratioWidth, CUBE[7] * ratioHeight,
-            };
-        }
-
+        cube = new float[]{
+            CUBE[0] * ratioWidth, CUBE[1] * ratioHeight,
+            CUBE[2] * ratioWidth, CUBE[3] * ratioHeight,
+            CUBE[4] * ratioWidth, CUBE[5] * ratioHeight,
+            CUBE[6] * ratioWidth, CUBE[7] * ratioHeight,
+        };
+    
         mGLCubeBuffer.clear();
         mGLCubeBuffer.put(cube).position(0);
         mGLTextureBuffer.clear();
         mGLTextureBuffer.put(textureCords).position(0);
     }
 
+    private void adjustImageScalingCrop() 
+    {
+    	if(mOutputWidth==0||mOutputHeight==0||mImageWidth==0||mImageHeight==0)
+    		return;
+    	
+    	float imageRatio=(float)mImageWidth/(float)mImageHeight;
+    	
+    	float rx=1f;
+    	float ry=1f;
+    	float scale=1f;
+    	
+    	if(imageRatio<1f)
+    	{
+    		scale=(float)mImageWidth/(float)Math.min(mOutputWidth,mOutputHeight);
+    		ry=imageRatio;
+    	}
+    	else
+    	{
+    		scale=(float)mImageHeight/(float)Math.min(mOutputWidth,mOutputHeight);
+    		rx=1/imageRatio;
+    	}
+    	
+    	float dx=mDeltaX;
+    	float dy=mDeltaY;
+		float max;
+    	
+    	if(dx>0)
+    		dx=0;
+    	else
+    	{
+    		max=((float)mImageWidth/scale)-(float)Math.min(mOutputWidth,mOutputHeight);
+    		if(max<0)
+    			max=0;
+    		if(Math.abs(dx)>Math.abs(max))
+    			dx=max*-1;
+    	}
+
+    	if(dy>0)
+    		dy=0;
+    	else
+    	{
+    		max=((float)mImageHeight/scale)-(float)Math.min(mOutputWidth,mOutputHeight);
+    		if(max<0)
+    			max=0;
+    		if(Math.abs(dy)>Math.abs(max))
+    			dy=max*-1;
+    	}
+    	
+    	mDeltaX=dx;
+    	mDeltaY=dy;
+    	
+    	dx=rx*(dx/(float)Math.min(mOutputWidth,mOutputHeight));
+    	dy=ry*(dy/(float)Math.min(mOutputWidth,mOutputHeight));
+    	
+        float[] textureCords = new float[]{
+        		-dx,ry-dy,
+        		rx-dx,ry-dy,
+        		-dx,-dy,
+        		rx-dx,-dy};
+
+        mGLCubeBuffer.clear();
+        mGLCubeBuffer.put(CUBE).position(0);
+        mGLTextureBuffer.clear();
+        mGLTextureBuffer.put(textureCords).position(0);
+    }
+
     private float addDistance(float coordinate, float distance) {
         return coordinate == 0.0f ? distance : 1 - distance;
     }
diff --git a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageTwoInputFilter.java b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageTwoInputFilter.java
index 90645b40..bccf6ef6 100644
--- a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageTwoInputFilter.java
+++ b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageTwoInputFilter.java
@@ -66,6 +66,11 @@ public void onInit() {
             setBitmap(mBitmap);
         }
     }
+    
+    public Bitmap getBitmap()
+    {
+    	return mBitmap;
+    }
 
     public void setBitmap(final Bitmap bitmap) {
         mBitmap = bitmap;
diff --git a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageView.java b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageView.java
index 9194d895..2ebf6f50 100644
--- a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageView.java
+++ b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageView.java
@@ -17,6 +17,7 @@
 package jp.co.cyberagent.android.gpuimage;
 
 import android.content.Context;
+import android.content.SharedPreferences;
 import android.graphics.Bitmap;
 import android.net.Uri;
 import android.opengl.GLSurfaceView;
@@ -28,7 +29,7 @@
 
     private GPUImage mGPUImage;
     private GPUImageFilter mFilter;
-    private float mRatio = 0.0f;
+    private float mRatio = 1.0f;
 
     public GPUImageView(Context context) {
         super(context);
@@ -39,7 +40,22 @@ public GPUImageView(Context context, AttributeSet attrs) {
         super(context, attrs);
         init();
     }
-
+    
+    public void saveState(SharedPreferences prefs)
+	{
+    	mGPUImage.saveState(prefs);
+	}
+
+	public void restoreState(SharedPreferences prefs)
+	{
+		mGPUImage.restoreState(prefs);
+	}
+
+	public void deleteImage()
+    {
+    	mGPUImage.deleteImage();
+    }
+    
     private void init() {
         mGPUImage = new GPUImage(getContext());
         mGPUImage.setGLSurfaceView(this);
@@ -76,6 +92,21 @@ public void setRatio(float ratio) {
         mGPUImage.deleteImage();
     }
 
+    public void translate(int dx,int dy)
+    {
+    	mGPUImage.translate(dx,dy);
+        requestRender();
+    }    
+    
+    /**
+     * Set the scale type of GPUImage.
+     *
+     * @param scaleType the new ScaleType
+     */
+    public void setScaleType(GPUImage.ScaleType scaleType) {
+        mGPUImage.setScaleType(scaleType);
+    }
+    
     /**
      * Set the filter to be applied on the image.
      *
diff --git a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageVignetteFilter.java b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageVignetteFilter.java
index 439e8bd0..3d2887ef 100644
--- a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageVignetteFilter.java
+++ b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageVignetteFilter.java
@@ -59,7 +59,7 @@
     private float mVignetteEnd;
     
     public GPUImageVignetteFilter() {
-        this(new PointF(), new float[] {0.0f, 0.0f, 0.0f}, 0.3f, 0.75f);
+    	this(new PointF(0.5f,0.5f), new float[] {0.0f, 0.0f, 0.0f}, 0.3f, 0.75f);    
     }
     
     public GPUImageVignetteFilter(final PointF vignetteCenter, final float[] vignetteColor, final float vignetteStart, final float vignetteEnd) {
@@ -68,7 +68,6 @@ public GPUImageVignetteFilter(final PointF vignetteCenter, final float[] vignett
         mVignetteColor = vignetteColor;
         mVignetteStart = vignetteStart;
         mVignetteEnd = vignetteEnd;
-        
     }
 
     @Override
