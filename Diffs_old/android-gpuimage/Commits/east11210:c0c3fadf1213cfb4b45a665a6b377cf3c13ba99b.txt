diff --git a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageFilterGroup.java b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageFilterGroup.java
index 7ab7c3dc..3db582ab 100644
--- a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageFilterGroup.java
+++ b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageFilterGroup.java
@@ -97,9 +97,7 @@ public void onInit() {
                 .asFloatBuffer();
         mGLTextureFlipBuffer.put(flipTexture).position(0);
 
-        for (GPUImageFilter filter : mFilters) {
-            filter.init();
-        }
+        initFilters();
     }
 
     /*
@@ -109,10 +107,21 @@ public void onInit() {
     @Override
     public void onDestroy() {
         destroyFramebuffers();
+        destroyFilters();
+        super.onDestroy();
+    }
+
+    protected void initFilters() {
+        for (GPUImageFilter filter : mFilters) {
+            filter.init();
+        }
+    }
+
+    protected void destroyFilters() {
         for (GPUImageFilter filter : mFilters) {
             filter.destroy();
         }
-        super.onDestroy();
+        mFilters.clear();
     }
 
     private void destroyFramebuffers() {
diff --git a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageGaussianBlurFilter.java b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageGaussianBlurFilter.java
index 3625a486..a5502feb 100644
--- a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageGaussianBlurFilter.java
+++ b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageGaussianBlurFilter.java
@@ -16,138 +16,106 @@
 
 package jp.co.cyberagent.android.gpuimage;
 
-import android.graphics.PointF;
 import android.opengl.GLES20;
 
 public class GPUImageGaussianBlurFilter extends GPUImageTwoPassTextureSamplingFilter {
 
-    private static String vertexShaderForStandardBlurOfRadius(final int radius, final float sigma) {
-        if (1 > radius) {
-            return NO_FILTER_VERTEX_SHADER;
-        }
-        int samples = radius * 2 + 1;
-        String shaderString =
+    public static final String CONTRAST_FRAGMENT_SHADER =
                 "attribute vec4 position;\n" +
                 "attribute vec4 inputTextureCoordinate;\n" +
                 "\n" +
-                "const int SAMPLES = " + samples + ";\n" +
                 "uniform float texelWidthOffset;\n" +
                 "uniform float texelHeightOffset;\n" +
                 "\n" +
-                "varying vec2 blurCoordinates[SAMPLES];\n" +
+                "varying vec2 blurCoordinate;\n" +
+                "varying vec2 blurOffset;\n" +
                 "\n" +
                 "void main()\n" +
                 "{\n" +
-                "	gl_Position = position;\n" +
-                "	\n" +
-//            "	// Calculate the positions for the blur\n" +
-                "	int multiplier = 0;\n" +
-                "   vec2 blurStep;\n" +
-                "   vec2 singleStepOffset = vec2(texelHeightOffset, texelWidthOffset);\n" +
-                "    \n" +
-                "	for (int i = 0; i < SAMPLES; i++)\n" +
-                "   {\n" +
-                "		multiplier = (i - ((SAMPLES - 1) / 2));\n" +
-//            "       // Blur in x (horizontal)\n" +
-                "       blurStep = float(multiplier) * singleStepOffset;\n" +
-                "		blurCoordinates[i] = inputTextureCoordinate.xy + blurStep;\n" +
-                "	}\n" +
+                "    gl_Position = position;\n" +
+                "    blurCoordinate = inputTextureCoordinate.xy;\n" +
+                "    blurOffset = vec2(texelHeightOffset, texelWidthOffset);\n" +
                 "}\n";
-        return shaderString;
-    }
 
-    private static String fragmentShaderForStandardBlurOfRadius(final int radius, final float sigma) {
+    private static String fragmentShader(final int radius) {
         if (1 > radius) {
             return NO_FILTER_FRAGMENT_SHADER;
         }
-        // First, generate the normal Gaussian weights for a given sigma
-        final int samples = radius * 2+ 1;
-        String shaderString =
-                "uniform sampler2D inputImageTexture;\n" +
+        final int samples = radius * 2 + 1;
+        final String shaderString =
                 "const int SAMPLES = " + samples + ";\n" +
-                "varying vec2 blurCoordinates[SAMPLES];\n" +
-                "uniform float blurWeights[" + (samples) +  "];\n" +
+                "uniform sampler2D inputImageTexture;\n" +
+                "uniform float blurSteps[SAMPLES];\n" +
+                "uniform float blurWeights[SAMPLES];\n" +
+                "varying vec2 blurCoordinate;\n" +
+                "varying vec2 blurOffset;\n" +
                 "void main() {\n" +
                 "    lowp vec4 sum = vec4(0.0);\n" +
                 "    for (int i = 0; i < SAMPLES; ++i) {\n" +
-                "        sum += texture2D(inputImageTexture, blurCoordinates[i]) * blurWeights[i];\n" +
+                "        lowp vec2 coordinate = blurCoordinate + blurOffset * blurSteps[i];\n" +
+                "        sum += texture2D(inputImageTexture, coordinate) * blurWeights[i];\n" +
                 "    }\n" +
                 "    gl_FragColor = sum;\n" +
                 "}\n";
-//        for (i = 0; i < samples; ++i) {
-//            int offsetFromCenter = i - radius;
-//            shaderString += "    sum += texture2D(inputImageTexture, blurCoordinates[" + i + "]) * ";
-//            if (0 > offsetFromCenter) {
-//                shaderString += standardGaussianWeights[-offsetFromCenter];
-//            } else {
-//                shaderString += standardGaussianWeights[ offsetFromCenter];
-//            }
-//            shaderString += ";\n";
-//        }
-//        shaderString +=
-//                "    gl_FragColor = sum;\n" +
-//                "}\n";
         return shaderString;
     }
 
-    private static float[] fragmentWeightsForStandardBlurOfRadius(final int radius, final float sigma) {
+    private void prepareArrays(final int radius, final float sigma) {
         int i;
-        final int samples = radius * 2+ 1;
+        final int samples = radius * 2 + 1;
         final int weights = radius + 1;
         float sumOfWeights = 0.0f;
-        float standardGaussianWeights[] = new float[weights];
+        mWeights = new float[samples];
         for (i = 0; i < weights; ++i) {
-            standardGaussianWeights[i] = (float) ((1.0 / Math.sqrt(2.0 * Math.PI * Math.pow(sigma, 2.0))) * Math.exp(-Math.pow(i, 2.0) / (2.0 * Math.pow(sigma, 2.0))));
+            final float weight = (float) ((1.0 / Math.sqrt(2.0 * Math.PI * Math.pow(sigma, 2.0))) * Math.exp(-Math.pow(i, 2.0) / (2.0 * Math.pow(sigma, 2.0))));
             if (0 == i) {
-                sumOfWeights += standardGaussianWeights[i];
+                sumOfWeights += weight;
             } else {
-                sumOfWeights += 2.0 * standardGaussianWeights[i];
+                sumOfWeights += 2.0 * weight;
             }
+            mWeights[weights -1 -i] = weight;
         }
         for (i = 0; i < weights; ++i) {
-            standardGaussianWeights[i] = standardGaussianWeights[i] / sumOfWeights;
+            mWeights[i] = mWeights[i] / sumOfWeights;
+        }
+        for (i = 0; i < radius; ++i) {
+            mWeights[samples - i - 1] = mWeights[i];
         }
-        float result[] = new float[samples];
+
+        mOffsets = new float[samples];
+        int offset = -radius;
         for (i = 0; i < samples; ++i) {
-            int id = i - radius;
-            result[i] = standardGaussianWeights[0 > id ? -id : id];
+            mOffsets[i] = offset;
+            ++offset;
         }
-        return result;
     }
 
     protected float mBlurSize = 1f;
     protected int mRadiusInPixel = 2;
     private float mWeights[];
-    private int mWeightsLocation0;
-    private int mWeightsLocation1;
+    private float mOffsets[];
 
     public GPUImageGaussianBlurFilter() {
-        this(1.0f, 2);
+        this(1.0f, 2, getRadius(2));
     }
 
-    public GPUImageGaussianBlurFilter(float blurSize, int radiusInPixel) {
-        super(vertexShaderForStandardBlurOfRadius(4, 2.0f),
-            fragmentShaderForStandardBlurOfRadius(4, 2.0f),
-            vertexShaderForStandardBlurOfRadius(4, 2.0f),
-            fragmentShaderForStandardBlurOfRadius(4, 2.0f));
+    public GPUImageGaussianBlurFilter(float blurSize, int radiusInPixel, int radius) {
+        super(CONTRAST_FRAGMENT_SHADER, fragmentShader(radius),
+                CONTRAST_FRAGMENT_SHADER, fragmentShader(radius));
         mBlurSize = blurSize;
         mRadiusInPixel = radiusInPixel;
-        mWeights = fragmentWeightsForStandardBlurOfRadius(4, 2.0f);
+        prepareArrays(radius, radiusInPixel);
     }
 
-    @Override
-    public void onInit() {
-        super.onInit();
-        GPUImageFilter filter = mFilters.get(0);
-        mWeightsLocation0 = GLES20.glGetUniformLocation(filter.getProgram(), "blurWeights");
-        filter = mFilters.get(1);
-        mWeightsLocation1 = GLES20.glGetUniformLocation(filter.getProgram(), "blurWeights");
-    }
+//    @Override
+//    public void onInit() {
+//        super.onInit();
+//    }
 
     @Override
     public void onInitialized() {
         super.onInitialized();
-        setWeights(mWeights);
+        setArrays();
     }
 
     @Override
@@ -175,28 +143,26 @@ public void run() {
         });
     }
 
-    public void setWeights(final float weights[]) {
-        mWeights = weights;
+    public void setArrays() {
         GPUImageFilter filter = mFilters.get(0);
-        filter.setFloatArray(mWeightsLocation0, mWeights);
+        int location = GLES20.glGetUniformLocation(filter.getProgram(), "blurSteps");
+        filter.setFloatArray(location, mOffsets);
+        location = GLES20.glGetUniformLocation(filter.getProgram(), "blurWeights");
+        filter.setFloatArray(location, mWeights);
         filter = mFilters.get(1);
-        filter.setFloatArray(mWeightsLocation1, mWeights);
+        location = GLES20.glGetUniformLocation(filter.getProgram(), "blurSteps");
+        filter.setFloatArray(location, mOffsets);
+        location = GLES20.glGetUniformLocation(filter.getProgram(), "blurWeights");
+        filter.setFloatArray(location, mWeights);
     }
 
-//    public void setAspectRatio(final float aspectRatio) {
-//        mAspectRatio = aspectRatio;
-//        setFloat(mAspectRatioLocation, mAspectRatio);
-//    }
-//
-//    public void setCenter(final PointF center) {
-//        mCenter = center;
-//        setPoint(mCenterLocation, mCenter);
-//    }
-//
-//    public void setRadius(final float radius) {
-//        mRadius = radius;
-//        setFloat(mRadiusLocation, mRadius);
-//    }
+    private static int getRadius(final int radiusInPixel) {
+        final float minimumWeightToFindEdgeOfSamplingArea = 1.0f/256.0f;
+        return (int) Math.floor(Math.sqrt(
+                -2.0 * Math.pow(radiusInPixel, 2.0)
+                        * Math.log(minimumWeightToFindEdgeOfSamplingArea * Math.sqrt(2.0 * Math.PI * Math.pow(radiusInPixel, 2.0)))
+        ));
+    }
 
     public void setRadiusInPixel(final int radiusInPixel) {
         if (mRadiusInPixel == radiusInPixel
@@ -208,33 +174,15 @@ public void setRadiusInPixel(final int radiusInPixel) {
         runOnDraw(new Runnable() {
             @Override
             public void run() {
-//                destroy();
-                for (GPUImageFilter filter : mFilters) {
-                    filter.destroy();
-                }
-                mFilters.clear();
-                final float minimumWeightToFindEdgeOfSamplingArea = 1.0f/256.0f;
-                int sampleRadius = (int) Math.floor(Math.sqrt(
-                        -2.0 * Math.pow(mRadiusInPixel, 2.0)
-                                * Math.log(minimumWeightToFindEdgeOfSamplingArea * Math.sqrt(2.0 * Math.PI * Math.pow(mRadiusInPixel, 2.0)))
-                ));
-                String vertexShader = vertexShaderForStandardBlurOfRadius(sampleRadius, radiusInPixel);
-                String fragmentShader = fragmentShaderForStandardBlurOfRadius(sampleRadius, radiusInPixel);
-                addFilter(new GPUImageFilter(vertexShader, fragmentShader));
-                addFilter(new GPUImageFilter(vertexShader, fragmentShader));
-                for (GPUImageFilter filter : mFilters) {
-                    filter.init();
-                }
-                updateMergedFilters();
+                destroyFilters();
+                int sampleRadius = getRadius(mRadiusInPixel);
+                String fragmentShader = fragmentShader(sampleRadius);
+                addFilter(new GPUImageFilter(CONTRAST_FRAGMENT_SHADER, fragmentShader));
+                addFilter(new GPUImageFilter(CONTRAST_FRAGMENT_SHADER, fragmentShader));
+                initFilters();
                 initTexelOffsets();
-                GPUImageFilter filter = mFilters.get(0);
-                mWeightsLocation0 = GLES20.glGetUniformLocation(filter.getProgram(), "blurWeights");
-                filter = mFilters.get(1);
-                mWeightsLocation1 = GLES20.glGetUniformLocation(filter.getProgram(), "blurWeights");
-                setWeights(fragmentWeightsForStandardBlurOfRadius(sampleRadius, radiusInPixel));
-//                init();
-//                GLES20.glUseProgram(getProgram());
-
+                prepareArrays(sampleRadius, radiusInPixel);
+                setArrays();
             }
         });
     }
diff --git a/sample/src/jp/co/cyberagent/android/gpuimage/sample/GPUImageFilterTools.java b/sample/src/jp/co/cyberagent/android/gpuimage/sample/GPUImageFilterTools.java
index 2ebe8ad7..be6331cd 100644
--- a/sample/src/jp/co/cyberagent/android/gpuimage/sample/GPUImageFilterTools.java
+++ b/sample/src/jp/co/cyberagent/android/gpuimage/sample/GPUImageFilterTools.java
@@ -693,7 +693,7 @@ public void adjust(final int percentage) {
             public void adjust(final int percentage) {
 //                getFilter().setBlurSize(range(percentage, 0.0f, 1.0f));
 //                getFilter().setRadius(range(percentage, 0.0f, 1.0f));
-                getFilter().setRadiusInPixel(range(percentage, 1, 8));
+                getFilter().setRadiusInPixel(range(percentage, 1, 20));
             }
         }
 
