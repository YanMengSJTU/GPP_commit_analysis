diff --git a/.github/ISSUE_TEMPLATE.md b/.github/ISSUE_TEMPLATE.md
new file mode 100644
index 00000000..9ddc9123
--- /dev/null
+++ b/.github/ISSUE_TEMPLATE.md
@@ -0,0 +1,28 @@
+# Future Task
+
+## What is the motivation?
+
+## What kind of solution can be considered?
+
+## What do you want to discuss?
+
+*Please add relevant labels*
+
+-----
+
+# Bug Reporting
+
+## Steps to Reproduce
+
+## Actual Results (include screenshots)
+
+## Expected Results (include screenshots)
+
+## URL
+
+## OS details
+
+- Device:
+- OS:
+
+*Please add relevant labels*
diff --git a/.github/PULL_REQUEST_TEMPLATE.md b/.github/PULL_REQUEST_TEMPLATE.md
new file mode 100644
index 00000000..9a972544
--- /dev/null
+++ b/.github/PULL_REQUEST_TEMPLATE.md
@@ -0,0 +1,6 @@
+## What does this change?
+
+## What is the value of this and can you measure success?
+
+## Screenshots
+
diff --git a/.gitignore b/.gitignore
index f99652d1..57d535c8 100644
--- a/.gitignore
+++ b/.gitignore
@@ -1,19 +1,23 @@
-.DS_Store
-Thumbs.db
+# Mac OS
+.DS_store
 
-# gradle files
-.gradle
+# Built application files
+*.apk
+*.ap_
 
-# Intellij project files
-.idea
-*.iml
+# Files for the ART/Dalvik VM
+*.dex
+
+# Java class files
+*.class
 
-# generated files
+# Generated files
 bin/
 gen/
-obj/
-apk/
-target/
+out/
+
+# Gradle files
+.gradle/
 build/
 
 # Local configuration file (sdk path, etc)
@@ -21,3 +25,41 @@ local.properties
 
 # Proguard folder generated by Eclipse
 proguard/
+
+# Log Files
+*.log
+
+# Android Studio Navigation editor temp files
+.navigation/
+
+# Android Studio captures folder
+captures/
+
+# IntelliJ
+*.iml
+.idea/
+projectFilesBackup/
+
+# Keystore files
+# Uncomment the following line if you do not want to check your keystore files in.
+#*.jks
+
+# External native build folder generated in Android Studio 2.2 and later
+.externalNativeBuild
+
+# Google Services (e.g. APIs or Firebase)
+google-services.json
+
+# Freeline
+fastlane/README.md
+fastlane/report.xml
+
+# fastlane
+fastlane/report.xml
+fastlane/Preview.html
+fastlane/screenshots
+fastlane/test_output
+fastlane/readme.md
+
+# NDK
+.externalNativeBuild
diff --git a/CHANGELOG.md b/CHANGELOG.md
index 7c89ae59..a75b19a0 100644
--- a/CHANGELOG.md
+++ b/CHANGELOG.md
@@ -1,11 +1,37 @@
 Change Log
 ==========
 
-Version 1.4.1 *(2016-03-15)*
+Version 2.0.2 *(2018-11-01)*
+----------------------------
+
+* Add GPUImageSolarizeFilter (by @kettsun0123)
+
+* Change attr/names
+  `show_loading` to `gpuimage_show_loading`
+  `surface_type` to `gpuimage_surface_type`
+
+* Fix a bug about filter init [#420](https://github.com/cats-oss/android-gpuimage/pull/420)
+
+Version 2.0.1 *(2018-10-24)*
 ----------------------------
 
-Using Bintray's JCenter.
+* Add GPUImageLuminanceFilter (by @takasfz)
+* Add GPUImageLuminanceThresholdFilter (by @takasfz)
 
+Version 2.0.0 *(2018-10-23)*
+----------------------------
+
+* Change the minSdkVersion 9 to 14
+* Change the targetSdkVersion 23 to 28
+* Update project settings
+* Support TextureView via GLTexureView
+* Support Camera2 API
+* Fix some bugs
+
+
+Version 1.4.1 *(2016-03-15)*
+----------------------------
+ Using Bintray's JCenter.
 
 Version 1.4.0 *(2016-02-28)*
 ----------------------------
@@ -18,10 +44,10 @@ Version 1.4.0 *(2016-02-28)*
 Version 1.3.0 *(2015-09-04)*
 ----------------------------
 
- * added GPUImageBilateralFilter (by @wysaid)
- * added flip options to `GPUImage#setRotation`
+* added GPUImageBilateralFilter (by @wysaid)
+* added flip options to `GPUImage#setRotation`
 
 Version 1.2.3-SNAPSHOT *(2014-12-15)*
 ----------------------------
 
- * added GPUImageLevelsFilter (by @vashisthg)
+* added GPUImageLevelsFilter (by @vashisthg)
diff --git a/CONTRIBUTING.md b/CONTRIBUTING.md
new file mode 100644
index 00000000..c4e67647
--- /dev/null
+++ b/CONTRIBUTING.md
@@ -0,0 +1,27 @@
+# How to Contribute
+
+We'd love to accept your patches and contributions to this project. There are
+just a few small guidelines you need to follow.
+
+## Contributor License Agreement
+
+Contributions to this project must be accompanied by a Contributor License
+Agreement. You (or your employer) retain the copyright to your contribution,
+this simply gives us permission to use and redistribute your contributions as
+part of the project. Head over to <https://cla-assistant.io/cats-oss/android-gpuimage> to see
+your current agreements on file or to sign a new one.
+
+You generally only need to submit a CLA once, so if you've already submitted one
+(even if it was for a different project), you probably don't need to do it
+again.
+
+## Code reviews
+
+All submissions, including submissions by project members, require review. We
+use GitHub pull requests for this purpose. Consult
+[GitHub Help](https://help.github.com/articles/about-pull-requests/) for more
+information on using pull requests.
+
+## Community Guidelines
+
+This project follows [Google's Open Source Community Guidelines](https://opensource.google.com/conduct/).
\ No newline at end of file
diff --git a/README.md b/README.md
index 0ac61327..b7fef099 100644
--- a/README.md
+++ b/README.md
@@ -1,8 +1,9 @@
 # GPUImage for Android
 [![License](https://img.shields.io/badge/license-Apache%202-blue.svg)](https://www.apache.org/licenses/LICENSE-2.0)
-[![Download](https://api.bintray.com/packages/cyberagent/maven/gpuimage-library/images/download.svg) ](https://bintray.com/cyberagent/maven/gpuimage-library/_latestVersion)
+[![Download](https://api.bintray.com/packages/cats-oss/maven/gpuimage/images/download.svg) ](https://bintray.com/cats-oss/maven/gpuimage/_latestVersion)
+[![Build Status](https://app.bitrise.io/app/d8d8090a71066e7c/status.svg?token=sJNbvX8CkecWcUA5Z898lQ&branch=master)](https://app.bitrise.io/app/d8d8090a71066e7c)
 
-Idea from: [iOS GPUImage framework](https://github.com/BradLarson/GPUImage)
+Idea from: [iOS GPUImage framework](https://github.com/BradLarson/GPUImage2)
 
 Goal is to have something as similar to GPUImage as possible. Vertex and fragment shaders are exactly the same. That way it makes it easier to port filters from GPUImage iOS to Android.
 
@@ -19,13 +20,14 @@ repositories {
 }
 
 dependencies {
-    compile 'jp.co.cyberagent.android.gpuimage:gpuimage-library:1.4.1'
+    implementation 'jp.co.cyberagent.android:gpuimage:2.x.x'
 }
 ```
 
 ### Sample Code
-With preview:
+#### With preview:
 
+Java:
 ```java
 @Override
 public void onCreate(final Bundle savedInstanceState) {
@@ -33,26 +35,222 @@ public void onCreate(final Bundle savedInstanceState) {
     setContentView(R.layout.activity);
 
     Uri imageUri = ...;
-    mGPUImage = new GPUImage(this);
-    mGPUImage.setGLSurfaceView((GLSurfaceView) findViewById(R.id.surfaceView));
-    mGPUImage.setImage(imageUri); // this loads image on the current thread, should be run in a thread
-    mGPUImage.setFilter(new GPUImageSepiaFilter());
+    gpuImage = new GPUImage(this);
+    gpuImage.setGLSurfaceView((GLSurfaceView) findViewById(R.id.surfaceView));
+    gpuImage.setImage(imageUri); // this loads image on the current thread, should be run in a thread
+    gpuImage.setFilter(new GPUImageSepiaFilter());
 
     // Later when image should be saved saved:
-    mGPUImage.saveToPictures("GPUImage", "ImageWithFilter.jpg", null);
+    gpuImage.saveToPictures("GPUImage", "ImageWithFilter.jpg", null);
 }
 ```
 
-Without preview:
+Kotlin:
+```kotlin
+public override fun onCreate(savedInstanceState: Bundle?) {
+    super.onCreate(savedInstanceState)
+    setContentView(R.layout.activity_gallery)
 
+    val imageUri: Uri = ...
+    gpuImage = GPUImage(this)
+    gpuImage.setGLSurfaceView(findViewById<GLSurfaceView>(R.id.surfaceView))
+    gpuImage.setImage(imageUri) // this loads image on the current thread, should be run in a thread
+    gpuImage.setFilter(GPUImageSepiaFilter())
+
+    // Later when image should be saved saved:
+    gpuImage.saveToPictures("GPUImage", "ImageWithFilter.jpg", null)
+}
+```
+
+#### Using GPUImageView
+```xml
+<jp.co.cyberagent.android.gpuimage.GPUImageView
+    android:id="@+id/gpuimageview"
+    android:layout_width="match_parent"
+    android:layout_height="match_parent"
+    app:gpuimage_show_loading="false"
+    app:gpuimage_surface_type="texture_view" /> <!-- surface_view or texture_view -->
+```
+
+Java:
+```java
+@Override
+public void onCreate(final Bundle savedInstanceState) {
+    super.onCreate(savedInstanceState);
+    setContentView(R.layout.activity);
+
+    Uri imageUri = ...;
+    gpuImageView = findViewById(R.id.gpuimageview);
+    gpuImageView.setImage(imageUri); // this loads image on the current thread, should be run in a thread
+    gpuImageView.setFilter(new GPUImageSepiaFilter());
+
+    // Later when image should be saved saved:
+    gpuImageView.saveToPictures("GPUImage", "ImageWithFilter.jpg", null);
+}
+```
+
+Kotlin:
+```kotlin
+public override fun onCreate(savedInstanceState: Bundle?) {
+    super.onCreate(savedInstanceState)
+    setContentView(R.layout.activity_gallery)
+
+    val imageUri: Uri = ...
+    gpuImageView = findViewById<GPUImageView>(R.id.gpuimageview)
+    gpuImageView.setImage(imageUri) // this loads image on the current thread, should be run in a thread
+    gpuImageView.setFilter(GPUImageSepiaFilter())
+
+    // Later when image should be saved saved:
+    gpuImageView.saveToPictures("GPUImage", "ImageWithFilter.jpg", null)
+}
+```
+
+#### Without preview:
+
+Java:
 ```java
-Uri imageUri = ...;
-mGPUImage = new GPUImage(context);
-mGPUImage.setFilter(new GPUImageSobelEdgeDetection());
-mGPUImage.setImage(imageUri);
-mGPUImage.saveToPictures("GPUImage", "ImageWithFilter.jpg", null);
+public void onCreate(final Bundle savedInstanceState) {
+    public void onCreate(final Bundle savedInstanceState) {
+    Uri imageUri = ...;
+    gpuImage = new GPUImage(context);
+    gpuImage.setFilter(new GPUImageSobelEdgeDetection());
+    gpuImage.setImage(imageUri);
+    gpuImage.saveToPictures("GPUImage", "ImageWithFilter.jpg", null);
+}
+```
+
+Kotlin:
+```kotlin
+public override fun onCreate(savedInstanceState: Bundle?) {
+    super.onCreate(savedInstanceState)
+    setContentView(R.layout.activity_gallery)
+    val imageUri: Uri = ...
+    gpuImage = GPUImage(this)
+    gpuImage.setFilter(GPUImageSepiaFilter())
+    gpuImage.setImage(imageUri)
+    gpuImage.saveToPictures("GPUImage", "ImageWithFilter.jpg", null)
+}
 ```
 
+### Support status of [GPUImage for iOS](https://github.com/BradLarson/GPUImage2) shaders
+- [x] Saturation
+- [x] Contrast
+- [x] Brightness
+- [x] Levels
+- [x] Exposure
+- [x] RGB
+- [x] RGB Diation
+- [x] Hue
+- [x] White Balance
+- [x] Monochrome
+- [x] False Color
+- [x] Sharpen
+- [ ] Unsharp Mask
+- [x] Transform Operation
+- [ ] Crop
+- [x] Gamma
+- [ ] Highlights and Shadows
+- [x] Haze
+- [x] Sepia Tone
+- [ ] Amatorka
+- [ ] Miss Etikate
+- [ ] Soft Elegance
+- [x] Color Inversion
+- [x] Solarize
+- [ ] Vibrance
+- [x] Highlight and Shadow Tint
+- [x] Luminance
+- [x] Luminance Threshold
+- [ ] Average Color
+- [ ] Average Luminance
+- [ ] Average Luminance Threshold
+- [ ] Adaptive Threshold
+- [ ] Polar Pixellate
+- [x] Pixellate
+- [ ] Polka Dot
+- [x] Halftone
+- [x] Crosshatch
+- [x] Sobel Edge Detection
+- [ ] Prewitt Edge Detection
+- [ ] Canny Edge Detection
+- [x] Threshold Sobel EdgeDetection
+- [ ] Harris Corner Detector
+- [ ] Noble Corner Detector
+- [ ] Shi Tomasi Feature Detector
+- [ ] Colour FAST Feature Detector
+- [ ] Low Pass Filter
+- [ ] High Pass Filter
+- [x] Sketch Filter
+- [ ] Threshold Sketch Filter
+- [x] Toon Filter
+- [x] SmoothToon Filter
+- [ ] Tilt Shift
+- [x] CGA Colorspace Filter
+- [x] Posterize
+- [x] Convolution 3x3
+- [x] Emboss Filter
+- [x] Laplacian
+- [x] Chroma Keying
+- [x] Kuwahara Filter
+- [ ] Kuwahara Radius3 Filter
+- [x] Vignette
+- [x] Gaussian Blur
+- [x] Box Blur
+- [x] Bilateral Blur
+- [ ] Motion Blur
+- [ ] Zoom Blur
+- [ ] iOS Blur
+- [ ] Median Filter
+- [x] Swirl Distortion
+- [x] Bulge Distortion
+- [ ] Pinch Distortion
+- [x] Sphere Refraction
+- [x] Glass Sphere Refraction
+- [ ] Stretch Distortion
+- [x] Dilation
+- [ ] Erosion
+- [ ] Opening Filter
+- [ ] Closing Filter
+- [ ] Local Binary Pattern
+- [ ] Color Local Binary Pattern
+- [x] Dissolve Blend
+- [ ] Chroma Key Blend
+- [x] Add Blend
+- [x] Divide Blend
+- [x] Multiply Blend
+- [x] Overlay Blend
+- [x] Lighten Blend
+- [x] Darken Blend
+- [x] Color Burn Blend
+- [x] Color Dodge Blend
+- [x] Linear Burn Blend
+- [x] Screen Blend
+- [x] Difference Blend
+- [x] Subtract Blend
+- [x] Exclusion Blend
+- [x] HardLight Blend
+- [x] SoftLight Blend
+- [x] Color Blend
+- [ ] Hue Blend
+- [x] Saturation Blend
+- [x] Luminosity Blend
+- [x] Normal Blend
+- [x] Source Over Blend
+- [x] Alpha Blend
+- [x] Non Maximum Suppression
+- [ ] Thresholded Non Maximum Suppression
+- [ ] Directional Non Maximum Suppression
+- [x] Opacity
+- [x] Weak Pixel Inclusion Filter
+- [x] Color Matrix
+- [x] Directional Sobel Edge Detection
+- [x] Lookup
+- [x] Tone Curve (*.acv files) 
+
+## Others
+- [x] Texture 3x3
+- [x] Gray Scale
+
 ### Gradle
 Make sure that you run the clean target when using maven.
 
@@ -61,7 +259,7 @@ gradle clean assemble
 ```
 
 ## License
-    Copyright 2012 CyberAgent, Inc.
+    Copyright 2018 CyberAgent, Inc.
 
     Licensed under the Apache License, Version 2.0 (the "License");
     you may not use this file except in compliance with the License.
diff --git a/build.gradle b/build.gradle
index 8a29e6b0..1e3515e0 100644
--- a/build.gradle
+++ b/build.gradle
@@ -1,21 +1,26 @@
 // Top-level build file where you can add configuration options common to all sub-projects/modules.
 
 buildscript {
+    ext.kotlin_version = '1.2.71'
     repositories {
+        google()
         jcenter()
     }
     dependencies {
-        classpath 'com.android.tools.build:gradle:2.0.0-beta6'
-        classpath 'com.novoda:bintray-release:0.3.4'
+        classpath 'com.android.tools.build:gradle:3.4.0-alpha02'
+        classpath 'com.jfrog.bintray.gradle:gradle-bintray-plugin:1.8.4'
+        classpath 'com.github.dcendents:android-maven-gradle-plugin:2.1'
+        classpath "org.jetbrains.kotlin:kotlin-gradle-plugin:$kotlin_version"
     }
 }
 
 allprojects {
     repositories {
+        google()
         jcenter()
-        maven { url("https://oss.sonatype.org/content/repositories/snapshots/") }
-    }
-    tasks.withType(JavaCompile) {
-        options.encoding = 'UTF-8'
     }
 }
+
+task clean(type: Delete) {
+    delete rootProject.buildDir
+}
\ No newline at end of file
diff --git a/gradle.properties b/gradle.properties
index 40c44d7f..794c82ed 100644
--- a/gradle.properties
+++ b/gradle.properties
@@ -1,22 +1,27 @@
-VERSION_NAME=1.4.1
-GROUP=jp.co.cyberagent.android.gpuimage
-ARTIFACT_ID=gpuimage-library
+# IDE (e.g. Android Studio) users:
+# Gradle settings configured through the IDE *will override*
+# any settings specified in this file.
+# For more details on how to configure your build environment visit
+# http://www.gradle.org/docs/current/userguide/build_environment.html
+# Specifies the JVM arguments used for the daemon process.
+# The setting is particularly useful for tweaking memory settings.
+org.gradle.jvmargs=-Xmx2048m -XX:MaxPermSize=1024m -XX:+HeapDumpOnOutOfMemoryError -Dfile.encoding=UTF-8
+# When configured, Gradle will run in incubating parallel mode.
+# This option should only be used with decoupled projects. More details, visit
+# http://www.gradle.org/docs/current/userguide/multi_project_builds.html#sec:decoupled_projects
+org.gradle.parallel=true
+org.gradle.daemon=true
+org.gradle.configureondemand=true
+org.gradle.caching=true
+android.enableBuildCache=true
+android.enableR8=false
 
-COMPILE_SDK_VERSION=23
-BUILD_TOOLS_VERSION=23.0.2
-TARGET_SDK_VERSION=23
-MIN_SDK_VERSION=8
+VERSION_NAME=2.0.2
+VERSION_CODE=11
 
-POM_DESCRIPTION=Image filters for Android with OpenGL (based on GPUImage for iOS)
-POM_URL=https://github.com/cyberagent/android-gpuimage
-POM_SCM_URL=scm:git@github.com:CyberAgent/android-gpuimage.git
-POM_SCM_CONNECTION=scm:git@github.com:CyberAgent/android-gpuimage.git
-POM_SCM_DEV_CONNECTION=scm:git@github.com:CyberAgent/android-gpuimage.git
-POM_LICENCE_NAME=The Apache Software License, Version 2.0
-POM_LICENCE_URL=http://www.apache.org/licenses/LICENSE-2.0.txt
-POM_LICENCE_DIST=repo
-POM_DEVELOPER_ID=cyberagent
-POM_DEVELOPER_NAME=CyberAgent, Inc.
-ISSUE_URL=https://github.com/CyberAgent/android-gpuimage/issues
+COMPILE_SDK_VERSION=28
+TARGET_SDK_VERSION=28
+MIN_SDK_VERSION=14
 
-android.useDeprecatedNdk=true
+android.useAndroidX=true
+android.enableJetifier=true
diff --git a/gradle/wrapper/gradle-wrapper.jar b/gradle/wrapper/gradle-wrapper.jar
index 8c0fb64a..13536770 100644
Binary files a/gradle/wrapper/gradle-wrapper.jar and b/gradle/wrapper/gradle-wrapper.jar differ
diff --git a/gradle/wrapper/gradle-wrapper.properties b/gradle/wrapper/gradle-wrapper.properties
index 6c0732ab..5c1b6c95 100644
--- a/gradle/wrapper/gradle-wrapper.properties
+++ b/gradle/wrapper/gradle-wrapper.properties
@@ -1,6 +1,5 @@
-#Sat Dec 06 18:27:05 JST 2014
 distributionBase=GRADLE_USER_HOME
 distributionPath=wrapper/dists
+distributionUrl=https\://services.gradle.org/distributions/gradle-4.10.1-bin.zip
 zipStoreBase=GRADLE_USER_HOME
 zipStorePath=wrapper/dists
-distributionUrl=https\://services.gradle.org/distributions/gradle-2.11-all.zip
diff --git a/gradlew b/gradlew
index 91a7e269..cccdd3d5 100755
--- a/gradlew
+++ b/gradlew
@@ -1,4 +1,4 @@
-#!/usr/bin/env bash
+#!/usr/bin/env sh
 
 ##############################################################################
 ##
@@ -6,20 +6,38 @@
 ##
 ##############################################################################
 
-# Add default JVM options here. You can also use JAVA_OPTS and GRADLE_OPTS to pass JVM options to this script.
-DEFAULT_JVM_OPTS=""
+# Attempt to set APP_HOME
+# Resolve links: $0 may be a link
+PRG="$0"
+# Need this for relative symlinks.
+while [ -h "$PRG" ] ; do
+    ls=`ls -ld "$PRG"`
+    link=`expr "$ls" : '.*-> \(.*\)$'`
+    if expr "$link" : '/.*' > /dev/null; then
+        PRG="$link"
+    else
+        PRG=`dirname "$PRG"`"/$link"
+    fi
+done
+SAVED="`pwd`"
+cd "`dirname \"$PRG\"`/" >/dev/null
+APP_HOME="`pwd -P`"
+cd "$SAVED" >/dev/null
 
 APP_NAME="Gradle"
 APP_BASE_NAME=`basename "$0"`
 
+# Add default JVM options here. You can also use JAVA_OPTS and GRADLE_OPTS to pass JVM options to this script.
+DEFAULT_JVM_OPTS=""
+
 # Use the maximum available, or set MAX_FD != -1 to use that value.
 MAX_FD="maximum"
 
-warn ( ) {
+warn () {
     echo "$*"
 }
 
-die ( ) {
+die () {
     echo
     echo "$*"
     echo
@@ -30,6 +48,7 @@ die ( ) {
 cygwin=false
 msys=false
 darwin=false
+nonstop=false
 case "`uname`" in
   CYGWIN* )
     cygwin=true
@@ -40,31 +59,11 @@ case "`uname`" in
   MINGW* )
     msys=true
     ;;
+  NONSTOP* )
+    nonstop=true
+    ;;
 esac
 
-# For Cygwin, ensure paths are in UNIX format before anything is touched.
-if $cygwin ; then
-    [ -n "$JAVA_HOME" ] && JAVA_HOME=`cygpath --unix "$JAVA_HOME"`
-fi
-
-# Attempt to set APP_HOME
-# Resolve links: $0 may be a link
-PRG="$0"
-# Need this for relative symlinks.
-while [ -h "$PRG" ] ; do
-    ls=`ls -ld "$PRG"`
-    link=`expr "$ls" : '.*-> \(.*\)$'`
-    if expr "$link" : '/.*' > /dev/null; then
-        PRG="$link"
-    else
-        PRG=`dirname "$PRG"`"/$link"
-    fi
-done
-SAVED="`pwd`"
-cd "`dirname \"$PRG\"`/" >&-
-APP_HOME="`pwd -P`"
-cd "$SAVED" >&-
-
 CLASSPATH=$APP_HOME/gradle/wrapper/gradle-wrapper.jar
 
 # Determine the Java command to use to start the JVM.
@@ -90,7 +89,7 @@ location of your Java installation."
 fi
 
 # Increase the maximum file descriptors if we can.
-if [ "$cygwin" = "false" -a "$darwin" = "false" ] ; then
+if [ "$cygwin" = "false" -a "$darwin" = "false" -a "$nonstop" = "false" ] ; then
     MAX_FD_LIMIT=`ulimit -H -n`
     if [ $? -eq 0 ] ; then
         if [ "$MAX_FD" = "maximum" -o "$MAX_FD" = "max" ] ; then
@@ -114,6 +113,7 @@ fi
 if $cygwin ; then
     APP_HOME=`cygpath --path --mixed "$APP_HOME"`
     CLASSPATH=`cygpath --path --mixed "$CLASSPATH"`
+    JAVACMD=`cygpath --unix "$JAVACMD"`
 
     # We build the pattern for arguments to be converted via cygpath
     ROOTDIRSRAW=`find -L / -maxdepth 1 -mindepth 1 -type d 2>/dev/null`
@@ -154,11 +154,19 @@ if $cygwin ; then
     esac
 fi
 
-# Split up the JVM_OPTS And GRADLE_OPTS values into an array, following the shell quoting and substitution rules
-function splitJvmOpts() {
-    JVM_OPTS=("$@")
+# Escape application args
+save () {
+    for i do printf %s\\n "$i" | sed "s/'/'\\\\''/g;1s/^/'/;\$s/\$/' \\\\/" ; done
+    echo " "
 }
-eval splitJvmOpts $DEFAULT_JVM_OPTS $JAVA_OPTS $GRADLE_OPTS
-JVM_OPTS[${#JVM_OPTS[*]}]="-Dorg.gradle.appname=$APP_BASE_NAME"
+APP_ARGS=$(save "$@")
+
+# Collect all arguments for the java command, following the shell quoting and substitution rules
+eval set -- $DEFAULT_JVM_OPTS $JAVA_OPTS $GRADLE_OPTS "\"-Dorg.gradle.appname=$APP_BASE_NAME\"" -classpath "\"$CLASSPATH\"" org.gradle.wrapper.GradleWrapperMain "$APP_ARGS"
+
+# by default we should be in the correct project dir, but when run from Finder on Mac, the cwd is wrong
+if [ "$(uname)" = "Darwin" ] && [ "$HOME" = "$PWD" ]; then
+  cd "$(dirname "$0")"
+fi
 
-exec "$JAVACMD" "${JVM_OPTS[@]}" -classpath "$CLASSPATH" org.gradle.wrapper.GradleWrapperMain "$@"
+exec "$JAVACMD" "$@"
diff --git a/gradlew.bat b/gradlew.bat
index aec99730..e95643d6 100644
--- a/gradlew.bat
+++ b/gradlew.bat
@@ -8,14 +8,14 @@
 @rem Set local scope for the variables with windows NT shell
 if "%OS%"=="Windows_NT" setlocal
 
-@rem Add default JVM options here. You can also use JAVA_OPTS and GRADLE_OPTS to pass JVM options to this script.
-set DEFAULT_JVM_OPTS=
-
 set DIRNAME=%~dp0
 if "%DIRNAME%" == "" set DIRNAME=.
 set APP_BASE_NAME=%~n0
 set APP_HOME=%DIRNAME%
 
+@rem Add default JVM options here. You can also use JAVA_OPTS and GRADLE_OPTS to pass JVM options to this script.
+set DEFAULT_JVM_OPTS=
+
 @rem Find java.exe
 if defined JAVA_HOME goto findJavaFromJavaHome
 
@@ -46,10 +46,9 @@ echo location of your Java installation.
 goto fail
 
 :init
-@rem Get command-line arguments, handling Windowz variants
+@rem Get command-line arguments, handling Windows variants
 
 if not "%OS%" == "Windows_NT" goto win9xME_args
-if "%@eval[2+2]" == "4" goto 4NT_args
 
 :win9xME_args
 @rem Slurp the command line arguments.
@@ -60,11 +59,6 @@ set _SKIP=2
 if "x%~1" == "x" goto execute
 
 set CMD_LINE_ARGS=%*
-goto execute
-
-:4NT_args
-@rem Get arguments from the 4NT Shell from JP Software
-set CMD_LINE_ARGS=%$
 
 :execute
 @rem Setup the command line
diff --git a/library/AndroidManifest.xml b/library/AndroidManifest.xml
deleted file mode 100644
index ee0e7758..00000000
--- a/library/AndroidManifest.xml
+++ /dev/null
@@ -1,4 +0,0 @@
-<?xml version="1.0" encoding="utf-8"?>
-<manifest
-    package="jp.co.cyberagent.android.gpuimage">
-</manifest>
\ No newline at end of file
diff --git a/library/build.gradle b/library/build.gradle
index 4e0ded68..128a909e 100644
--- a/library/build.gradle
+++ b/library/build.gradle
@@ -1,72 +1,52 @@
 apply plugin: 'com.android.library'
-apply plugin: 'com.novoda.bintray-release'
 
 android {
     compileSdkVersion COMPILE_SDK_VERSION as int
-    buildToolsVersion BUILD_TOOLS_VERSION
 
     defaultConfig {
         minSdkVersion MIN_SDK_VERSION as int
         targetSdkVersion TARGET_SDK_VERSION as int
 
-        versionCode "git rev-list origin/master --count".execute().text.toInteger()
-        versionName VERSION_NAME
-
-        consumerProguardFiles 'proguard-rules.txt'
-
-        ndk {
-            moduleName "gpuimage-library"
-            stl "gnustl_shared"
-            abiFilters "all"
-            ldLibs "log"
+        versionCode = VERSION_CODE as int
+        versionName = VERSION_NAME
+        externalNativeBuild {
+            cmake { cppFlags "" }
         }
     }
-
-    sourceSets {
-        main {
-            manifest.srcFile 'AndroidManifest.xml'
-            java.srcDirs = ['src']
-            resources.srcDirs = ['src']
-            aidl.srcDirs = ['src']
-            renderscript.srcDirs = ['src']
-            res.srcDirs = ['res']
-            assets.srcDirs = ['assets']
-            jni.srcDirs = ['jni']
-        }
-
-        instrumentTest.setRoot('tests')
+    externalNativeBuild {
+        cmake { path "src/main/cpp/CMakeLists.txt" }
     }
 
-    lintOptions {
-        abortOnError false
+    buildTypes {
+        debug {
+            debuggable true
+        }
+        release {
+            debuggable false
+            proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro'
+        }
     }
 }
 
-task androidJavadocs(type: Javadoc) {
-    source = android.sourceSets.main.java.srcDirs
-    classpath += project.files(android.getBootClasspath().join(File.pathSeparator))
+ext {
+    bintrayRepo = 'maven'
+    bintrayName = 'gpuimage'
+    bintrayUserOrg = 'cats-oss'
+    publishedGroupId = 'jp.co.cyberagent.android'
+    libraryName = 'gpuimage'
+    artifact = 'gpuimage'
+    libraryDescription = 'Image filters for Android with OpenGL (based on GPUImage for iOS)'
+    siteUrl = 'https://github.com/cats-oss/android-gpuimage'
+    gitUrl = 'https://github.com/cats-oss/android-gpuimage.git'
+    issueUrl = 'https://github.com/cats-oss/android-gpuimage/issues'
+    libraryVersion = VERSION_NAME
+    developerId = 'cats'
+    developerName = 'CATS'
+    developerEmail = 'dadadada.chop@gmail.com'
+    licenseName = 'The Apache Software License, Version 2.0'
+    licenseUrl = 'http://www.apache.org/licenses/LICENSE-2.0.txt'
+    allLicenses = ["Apache-2.0"]
 }
 
-task androidJavadocsJar(type: Jar, dependsOn: androidJavadocs) {
-    classifier = 'javadoc'
-    from androidJavadocs.destinationDir
-}
-
-task androidSourcesJar(type: Jar) {
-    classifier = 'sources'
-    from android.sourceSets.main.java.srcDirs
-}
-
-artifacts {
-    archives androidSourcesJar
-    archives androidJavadocsJar
-}
-
-publish {
-    userOrg = POM_DEVELOPER_ID
-    groupId = GROUP
-    artifactId = ARTIFACT_ID
-    publishVersion = VERSION_NAME
-    desc = POM_DESCRIPTION
-    website = POM_URL
-}
+apply from: 'https://gist.githubusercontent.com/wasabeef/cf14805bee509baf7461974582f17d26/raw/bintray-v1.gradle'
+apply from: 'https://gist.githubusercontent.com/wasabeef/cf14805bee509baf7461974582f17d26/raw/install-v1.gradle'
\ No newline at end of file
diff --git a/library/jni/yuv-decoder.c b/library/jni/yuv-decoder.c
deleted file mode 100644
index fed6281e..00000000
--- a/library/jni/yuv-decoder.c
+++ /dev/null
@@ -1,115 +0,0 @@
-#include <jni.h>
-#include <android/log.h>
-
-
-JNIEXPORT void JNICALL Java_jp_co_cyberagent_android_gpuimage_GPUImageNativeLibrary_YUVtoRBGA(JNIEnv * env, jobject obj, jbyteArray yuv420sp, jint width, jint height, jintArray rgbOut)
-{
-    int             sz;
-    int             i;
-    int             j;
-    int             Y;
-    int             Cr = 0;
-    int             Cb = 0;
-    int             pixPtr = 0;
-    int             jDiv2 = 0;
-    int             R = 0;
-    int             G = 0;
-    int             B = 0;
-    int             cOff;
-    int w = width;
-    int h = height;
-    sz = w * h;
-
-    jint *rgbData = (jint*) ((*env)->GetPrimitiveArrayCritical(env, rgbOut, 0));
-    jbyte* yuv = (jbyte*) (*env)->GetPrimitiveArrayCritical(env, yuv420sp, 0);
-
-    for(j = 0; j < h; j++) {
-             pixPtr = j * w;
-             jDiv2 = j >> 1;
-             for(i = 0; i < w; i++) {
-                     Y = yuv[pixPtr];
-                     if(Y < 0) Y += 255;
-                     if((i & 0x1) != 1) {
-                             cOff = sz + jDiv2 * w + (i >> 1) * 2;
-                             Cb = yuv[cOff];
-                             if(Cb < 0) Cb += 127; else Cb -= 128;
-                             Cr = yuv[cOff + 1];
-                             if(Cr < 0) Cr += 127; else Cr -= 128;
-                     }
-                     
-                     //ITU-R BT.601 conversion
-                     //
-                     //R = 1.164*(Y-16) + 2.018*(Cr-128);
-                     //G = 1.164*(Y-16) - 0.813*(Cb-128) - 0.391*(Cr-128);
-                     //B = 1.164*(Y-16) + 1.596*(Cb-128);
-                     //
-                     Y = Y + (Y >> 3) + (Y >> 5) + (Y >> 7);
-                     R = Y + (Cr << 1) + (Cr >> 6);
-                     if(R < 0) R = 0; else if(R > 255) R = 255;
-                     G = Y - Cb + (Cb >> 3) + (Cb >> 4) - (Cr >> 1) + (Cr >> 3);
-                     if(G < 0) G = 0; else if(G > 255) G = 255;
-                     B = Y + Cb + (Cb >> 1) + (Cb >> 4) + (Cb >> 5);
-                     if(B < 0) B = 0; else if(B > 255) B = 255;
-                     rgbData[pixPtr++] = 0xff000000 + (R << 16) + (G << 8) + B;
-             }
-    }
-
-    (*env)->ReleasePrimitiveArrayCritical(env, rgbOut, rgbData, 0);
-    (*env)->ReleasePrimitiveArrayCritical(env, yuv420sp, yuv, 0);
-}
-
-JNIEXPORT void JNICALL Java_jp_co_cyberagent_android_gpuimage_GPUImageNativeLibrary_YUVtoARBG(JNIEnv * env, jobject obj, jbyteArray yuv420sp, jint width, jint height, jintArray rgbOut)
-{
-    int             sz;
-    int             i;
-    int             j;
-    int             Y;
-    int             Cr = 0;
-    int             Cb = 0;
-    int             pixPtr = 0;
-    int             jDiv2 = 0;
-    int             R = 0;
-    int             G = 0;
-    int             B = 0;
-    int             cOff;
-    int w = width;
-    int h = height;
-    sz = w * h;
-
-    jint *rgbData = (jint*) ((*env)->GetPrimitiveArrayCritical(env, rgbOut, 0));
-    jbyte* yuv = (jbyte*) (*env)->GetPrimitiveArrayCritical(env, yuv420sp, 0);
-
-    for(j = 0; j < h; j++) {
-             pixPtr = j * w;
-             jDiv2 = j >> 1;
-             for(i = 0; i < w; i++) {
-                     Y = yuv[pixPtr];
-                     if(Y < 0) Y += 255;
-                     if((i & 0x1) != 1) {
-                             cOff = sz + jDiv2 * w + (i >> 1) * 2;
-                             Cb = yuv[cOff];
-                             if(Cb < 0) Cb += 127; else Cb -= 128;
-                             Cr = yuv[cOff + 1];
-                             if(Cr < 0) Cr += 127; else Cr -= 128;
-                     }
-                     
-                     //ITU-R BT.601 conversion
-                     //
-                     //R = 1.164*(Y-16) + 2.018*(Cr-128);
-                     //G = 1.164*(Y-16) - 0.813*(Cb-128) - 0.391*(Cr-128);
-                     //B = 1.164*(Y-16) + 1.596*(Cb-128);
-                     //
-                     Y = Y + (Y >> 3) + (Y >> 5) + (Y >> 7);
-                     R = Y + (Cr << 1) + (Cr >> 6);
-                     if(R < 0) R = 0; else if(R > 255) R = 255;
-                     G = Y - Cb + (Cb >> 3) + (Cb >> 4) - (Cr >> 1) + (Cr >> 3);
-                     if(G < 0) G = 0; else if(G > 255) G = 255;
-                     B = Y + Cb + (Cb >> 1) + (Cb >> 4) + (Cb >> 5);
-                     if(B < 0) B = 0; else if(B > 255) B = 255;
-                     rgbData[pixPtr++] = 0xff000000 + (B << 16) + (G << 8) + R;
-             }
-    }
-
-    (*env)->ReleasePrimitiveArrayCritical(env, rgbOut, rgbData, 0);
-    (*env)->ReleasePrimitiveArrayCritical(env, yuv420sp, yuv, 0);
-}
\ No newline at end of file
diff --git a/library/project.properties b/library/project.properties
deleted file mode 100644
index 93c8c3c0..00000000
--- a/library/project.properties
+++ /dev/null
@@ -1,15 +0,0 @@
-# This file is automatically generated by Android Tools.
-# Do not modify this file -- YOUR CHANGES WILL BE ERASED!
-#
-# This file must be checked in Version Control Systems.
-#
-# To customize properties used by the Ant build system edit
-# "ant.properties", and override values to adapt the script to your
-# project structure.
-#
-# To enable ProGuard to shrink and obfuscate your code, uncomment this (available properties: sdk.dir, user.home):
-#proguard.config=${sdk.dir}/tools/proguard/proguard-android.txt:proguard-project.txt
-
-# Project target.
-target=android-21
-android.library=true
diff --git a/library/src/jp/co/cyberagent/android/gpuimage/GPUImage3x3TextureSamplingFilter.java b/library/src/jp/co/cyberagent/android/gpuimage/GPUImage3x3TextureSamplingFilter.java
deleted file mode 100644
index 2e6820a3..00000000
--- a/library/src/jp/co/cyberagent/android/gpuimage/GPUImage3x3TextureSamplingFilter.java
+++ /dev/null
@@ -1,120 +0,0 @@
-/*
- * Copyright (C) 2012 CyberAgent
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package jp.co.cyberagent.android.gpuimage;
-
-import android.opengl.GLES20;
-
-public class GPUImage3x3TextureSamplingFilter extends GPUImageFilter {
-    public static final String THREE_X_THREE_TEXTURE_SAMPLING_VERTEX_SHADER = "" +
-            "attribute vec4 position;\n" + 
-            "attribute vec4 inputTextureCoordinate;\n" + 
-            "\n" + 
-            "uniform highp float texelWidth; \n" + 
-            "uniform highp float texelHeight; \n" + 
-            "\n" + 
-            "varying vec2 textureCoordinate;\n" + 
-            "varying vec2 leftTextureCoordinate;\n" + 
-            "varying vec2 rightTextureCoordinate;\n" + 
-            "\n" + 
-            "varying vec2 topTextureCoordinate;\n" + 
-            "varying vec2 topLeftTextureCoordinate;\n" + 
-            "varying vec2 topRightTextureCoordinate;\n" + 
-            "\n" + 
-            "varying vec2 bottomTextureCoordinate;\n" + 
-            "varying vec2 bottomLeftTextureCoordinate;\n" + 
-            "varying vec2 bottomRightTextureCoordinate;\n" + 
-            "\n" + 
-            "void main()\n" + 
-            "{\n" + 
-            "    gl_Position = position;\n" + 
-            "\n" + 
-            "    vec2 widthStep = vec2(texelWidth, 0.0);\n" + 
-            "    vec2 heightStep = vec2(0.0, texelHeight);\n" + 
-            "    vec2 widthHeightStep = vec2(texelWidth, texelHeight);\n" + 
-            "    vec2 widthNegativeHeightStep = vec2(texelWidth, -texelHeight);\n" + 
-            "\n" + 
-            "    textureCoordinate = inputTextureCoordinate.xy;\n" + 
-            "    leftTextureCoordinate = inputTextureCoordinate.xy - widthStep;\n" + 
-            "    rightTextureCoordinate = inputTextureCoordinate.xy + widthStep;\n" + 
-            "\n" + 
-            "    topTextureCoordinate = inputTextureCoordinate.xy - heightStep;\n" + 
-            "    topLeftTextureCoordinate = inputTextureCoordinate.xy - widthHeightStep;\n" + 
-            "    topRightTextureCoordinate = inputTextureCoordinate.xy + widthNegativeHeightStep;\n" + 
-            "\n" + 
-            "    bottomTextureCoordinate = inputTextureCoordinate.xy + heightStep;\n" + 
-            "    bottomLeftTextureCoordinate = inputTextureCoordinate.xy - widthNegativeHeightStep;\n" + 
-            "    bottomRightTextureCoordinate = inputTextureCoordinate.xy + widthHeightStep;\n" + 
-            "}";
-
-    private int mUniformTexelWidthLocation;
-    private int mUniformTexelHeightLocation;
-
-    private boolean mHasOverriddenImageSizeFactor = false;
-    private float mTexelWidth; 
-    private float mTexelHeight;
-    private float mLineSize = 1.0f;
-
-    public GPUImage3x3TextureSamplingFilter() {
-        this(NO_FILTER_VERTEX_SHADER);
-    }
-
-    public GPUImage3x3TextureSamplingFilter(final String fragmentShader) {
-        super(THREE_X_THREE_TEXTURE_SAMPLING_VERTEX_SHADER, fragmentShader);
-    }
-
-    @Override
-    public void onInit() {
-        super.onInit();
-        mUniformTexelWidthLocation = GLES20.glGetUniformLocation(getProgram(), "texelWidth");
-        mUniformTexelHeightLocation = GLES20.glGetUniformLocation(getProgram(), "texelHeight");
-        if (mTexelWidth != 0) {
-            updateTexelValues();
-        }
-    }
-
-    @Override
-    public void onOutputSizeChanged(final int width, final int height) {
-        super.onOutputSizeChanged(width, height);
-        if (!mHasOverriddenImageSizeFactor) {
-            setLineSize(mLineSize);
-        }
-    }
-
-    public void setTexelWidth(final float texelWidth) {
-        mHasOverriddenImageSizeFactor = true;
-        mTexelWidth = texelWidth;
-        setFloat(mUniformTexelWidthLocation, texelWidth);
-    }
-
-    public void setTexelHeight(final float texelHeight) {
-        mHasOverriddenImageSizeFactor = true;
-        mTexelHeight = texelHeight;
-        setFloat(mUniformTexelHeightLocation, texelHeight);
-    }
-
-    public void setLineSize(final float size) {
-        mLineSize = size;
-        mTexelWidth = size / getOutputWidth();
-        mTexelHeight = size / getOutputHeight();
-        updateTexelValues();
-    }
-
-    private void updateTexelValues() {
-        setFloat(mUniformTexelWidthLocation, mTexelWidth);
-        setFloat(mUniformTexelHeightLocation, mTexelHeight);
-    }
-}
diff --git a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageBilateralFilter.java b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageBilateralFilter.java
deleted file mode 100644
index 275253ab..00000000
--- a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageBilateralFilter.java
+++ /dev/null
@@ -1,155 +0,0 @@
-/**
- * @author wysaid
- * @mail admin@wysaid.org
- *
-*/
-
-package jp.co.cyberagent.android.gpuimage;
-
-import android.opengl.GLES20;
-
-
-public class GPUImageBilateralFilter extends GPUImageFilter {
-	public static final String BILATERAL_VERTEX_SHADER = "" +
-			"attribute vec4 position;\n" + 
-			"attribute vec4 inputTextureCoordinate;\n" + 
-	 
-			"const int GAUSSIAN_SAMPLES = 9;\n" + 
-	 
-			"uniform vec2 singleStepOffset;\n" +  
-	 
-			"varying vec2 textureCoordinate;\n" + 
-			"varying vec2 blurCoordinates[GAUSSIAN_SAMPLES];\n" + 
-	 
-			"void main()\n" + 
-			"{\n" + 
-	     	"	gl_Position = position;\n" + 
-			"	textureCoordinate = inputTextureCoordinate.xy;\n" + 
-	     
-			"	int multiplier = 0;\n" + 
-			"	vec2 blurStep;\n" +  
-	     
-			"	for (int i = 0; i < GAUSSIAN_SAMPLES; i++)\n" + 
-	     	"	{\n" + 
-	        "		multiplier = (i - ((GAUSSIAN_SAMPLES - 1) / 2));\n" + 
-	        
-	        "		blurStep = float(multiplier) * singleStepOffset;\n" + 
-	        "		blurCoordinates[i] = inputTextureCoordinate.xy + blurStep;\n" + 
-	     	"	}\n" + 
-	 		"}";
-
-	public static final String BILATERAL_FRAGMENT_SHADER = "" + 
-			"uniform sampler2D inputImageTexture;\n" +
-
-			" const lowp int GAUSSIAN_SAMPLES = 9;\n" +
-
-			" varying highp vec2 textureCoordinate;\n" +
-			" varying highp vec2 blurCoordinates[GAUSSIAN_SAMPLES];\n" +
-
-			" uniform mediump float distanceNormalizationFactor;\n" +
-
-			" void main()\n" +
-			" {\n" +
-			"     lowp vec4 centralColor;\n" +
-			"     lowp float gaussianWeightTotal;\n" +
-			"     lowp vec4 sum;\n" +
-			"     lowp vec4 sampleColor;\n" +
-			"     lowp float distanceFromCentralColor;\n" +
-			"     lowp float gaussianWeight;\n" +
-			"     \n" +
-			"     centralColor = texture2D(inputImageTexture, blurCoordinates[4]);\n" +
-			"     gaussianWeightTotal = 0.18;\n" +
-			"     sum = centralColor * 0.18;\n" +
-			"     \n" +
-			"     sampleColor = texture2D(inputImageTexture, blurCoordinates[0]);\n" +
-			"     distanceFromCentralColor = min(distance(centralColor, sampleColor) * distanceNormalizationFactor, 1.0);\n" +
-			"     gaussianWeight = 0.05 * (1.0 - distanceFromCentralColor);\n" +
-			"     gaussianWeightTotal += gaussianWeight;\n" +
-			"     sum += sampleColor * gaussianWeight;\n" +
-
-			"     sampleColor = texture2D(inputImageTexture, blurCoordinates[1]);\n" +
-			"     distanceFromCentralColor = min(distance(centralColor, sampleColor) * distanceNormalizationFactor, 1.0);\n" +
-			"     gaussianWeight = 0.09 * (1.0 - distanceFromCentralColor);\n" +
-			"     gaussianWeightTotal += gaussianWeight;\n" +
-			"     sum += sampleColor * gaussianWeight;\n" +
-
-			"     sampleColor = texture2D(inputImageTexture, blurCoordinates[2]);\n" +
-			"     distanceFromCentralColor = min(distance(centralColor, sampleColor) * distanceNormalizationFactor, 1.0);\n" +
-			"     gaussianWeight = 0.12 * (1.0 - distanceFromCentralColor);\n" +
-			"     gaussianWeightTotal += gaussianWeight;\n" +
-			"     sum += sampleColor * gaussianWeight;\n" +
-
-			"     sampleColor = texture2D(inputImageTexture, blurCoordinates[3]);\n" +
-			"     distanceFromCentralColor = min(distance(centralColor, sampleColor) * distanceNormalizationFactor, 1.0);\n" +
-			"     gaussianWeight = 0.15 * (1.0 - distanceFromCentralColor);\n" +
-			"     gaussianWeightTotal += gaussianWeight;\n" +
-			"     sum += sampleColor * gaussianWeight;\n" +
-
-			"     sampleColor = texture2D(inputImageTexture, blurCoordinates[5]);\n" +
-			"     distanceFromCentralColor = min(distance(centralColor, sampleColor) * distanceNormalizationFactor, 1.0);\n" +
-			"     gaussianWeight = 0.15 * (1.0 - distanceFromCentralColor);\n" +
-			"     gaussianWeightTotal += gaussianWeight;\n" +
-			"     sum += sampleColor * gaussianWeight;\n" +
-
-			"     sampleColor = texture2D(inputImageTexture, blurCoordinates[6]);\n" +
-			"     distanceFromCentralColor = min(distance(centralColor, sampleColor) * distanceNormalizationFactor, 1.0);\n" +
-			"     gaussianWeight = 0.12 * (1.0 - distanceFromCentralColor);\n" +
-			"     gaussianWeightTotal += gaussianWeight;\n" +
-			"     sum += sampleColor * gaussianWeight;\n" +
-
-			"     sampleColor = texture2D(inputImageTexture, blurCoordinates[7]);\n" +
-			"     distanceFromCentralColor = min(distance(centralColor, sampleColor) * distanceNormalizationFactor, 1.0);\n" +
-			"     gaussianWeight = 0.09 * (1.0 - distanceFromCentralColor);\n" +
-			"     gaussianWeightTotal += gaussianWeight;\n" +
-			"     sum += sampleColor * gaussianWeight;\n" +
-
-			"     sampleColor = texture2D(inputImageTexture, blurCoordinates[8]);\n" +
-			"     distanceFromCentralColor = min(distance(centralColor, sampleColor) * distanceNormalizationFactor, 1.0);\n" +
-			"     gaussianWeight = 0.05 * (1.0 - distanceFromCentralColor);\n" +
-			"     gaussianWeightTotal += gaussianWeight;\n" +
-			"     sum += sampleColor * gaussianWeight;\n" +
-			"     gl_FragColor = sum / gaussianWeightTotal;\n" +
-//			" gl_FragColor.r = distanceNormalizationFactor / 20.0;" + 
-			" }";
-
-	private float mDistanceNormalizationFactor;
-	private int mDisFactorLocation;
-	private int mSingleStepOffsetLocation;
-	
-	public GPUImageBilateralFilter() {
-		this(8.0f);
-	}
-	
-	public GPUImageBilateralFilter(final float distanceNormalizationFactor) {
-		super(BILATERAL_VERTEX_SHADER, BILATERAL_FRAGMENT_SHADER);
-		mDistanceNormalizationFactor = distanceNormalizationFactor;
-	}
-	
-	@Override
-	public void onInit() {
-		super.onInit();
-		mDisFactorLocation = GLES20.glGetUniformLocation(getProgram(), "distanceNormalizationFactor");
-		mSingleStepOffsetLocation = GLES20.glGetUniformLocation(getProgram(), "singleStepOffset");
-	}
-	
-	@Override
-	public void onInitialized() {
-		super.onInitialized();
-		setDistanceNormalizationFactor(mDistanceNormalizationFactor);
-	}
-	
-	public void setDistanceNormalizationFactor(final float newValue) {
-		mDistanceNormalizationFactor = newValue;
-		setFloat(mDisFactorLocation, newValue);
-	}
-	
-	private void setTexelSize(final float w, final float h) {
-		setFloatVec2(mSingleStepOffsetLocation, new float[] {1.0f / w, 1.0f / h});
-	}
-	
-	@Override
-    public void onOutputSizeChanged(final int width, final int height) {
-        super.onOutputSizeChanged(width, height);
-        setTexelSize(width, height);
-    }
-}
diff --git a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageColorBalanceFilter.java b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageColorBalanceFilter.java
deleted file mode 100644
index 68c078a6..00000000
--- a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageColorBalanceFilter.java
+++ /dev/null
@@ -1,197 +0,0 @@
-package jp.co.cyberagent.android.gpuimage;
-
-import android.opengl.GLES20;
-
-/**
- * Created by edward_chiang on 13/10/16.
- */
-public class GPUImageColorBalanceFilter extends GPUImageFilter {
-
-    public static final String GPU_IMAGE_COLOR_BALANCE_FRAGMENT_SHADER = "" +
-            "varying highp vec2 textureCoordinate;\n"   +
-            "uniform sampler2D inputImageTexture;\n"    +
-            "uniform lowp vec3 shadowsShift;\n" +
-            "uniform lowp vec3 midtonesShift;\n"    +
-            "uniform lowp vec3 highlightsShift;\n"  +
-            "uniform int preserveLuminosity;\n" +
-            "lowp vec3 RGBToHSL(lowp vec3 color)\n" +
-
-            "{\n"   +
-            "lowp vec3 hsl; // init to 0 to avoid warnings ? (and reverse if + remove first part)\n"    +
-
-            "lowp float fmin = min(min(color.r, color.g), color.b);    //Min. value of RGB\n"   +
-            "lowp float fmax = max(max(color.r, color.g), color.b);    //Max. value of RGB\n"   +
-            "lowp float delta = fmax - fmin;             //Delta RGB value\n"   +
-
-            "hsl.z = (fmax + fmin) / 2.0; // Luminance\n"   +
-
-            "if (delta == 0.0)		//This is a gray, no chroma...\n"   +
-            "{\n"   +
-            "    hsl.x = 0.0;	// Hue\n"   +
-            "    hsl.y = 0.0;	// Saturation\n"    +
-            "}\n"   +
-            "else                                    //Chromatic data...\n" +
-            "{\n"   +
-            "    if (hsl.z < 0.5)\n"    +
-            "        hsl.y = delta / (fmax + fmin); // Saturation\n"    +
-            "    else\n"+
-            "        hsl.y = delta / (2.0 - fmax - fmin); // Saturation\n"  +
-            "\n" +
-            "    lowp float deltaR = (((fmax - color.r) / 6.0) + (delta / 2.0)) / delta;\n" +
-            "    lowp float deltaG = (((fmax - color.g) / 6.0) + (delta / 2.0)) / delta;\n" +
-            "    lowp float deltaB = (((fmax - color.b) / 6.0) + (delta / 2.0)) / delta;\n" +
-            "\n" +
-            "    if (color.r == fmax )\n"   +
-            "        hsl.x = deltaB - deltaG; // Hue\n" +
-            "    else if (color.g == fmax)\n"   +
-            "        hsl.x = (1.0 / 3.0) + deltaR - deltaB; // Hue\n"   +
-            "    else if (color.b == fmax)\n"   +
-            "        hsl.x = (2.0 / 3.0) + deltaG - deltaR; // Hue\n"   +
-
-            "    if (hsl.x < 0.0)\n"    +
-            "        hsl.x += 1.0; // Hue\n"    +
-            "    else if (hsl.x > 1.0)\n"   +
-            "        hsl.x -= 1.0; // Hue\n"    +
-            "}\n"   +
-            "\n" +
-            "return hsl;\n" +
-            "}\n"   +
-
-            "lowp float HueToRGB(lowp float f1, lowp float f2, lowp float hue)\n"   +
-            "{\n"+
-            "    if (hue < 0.0)\n"+
-            "        hue += 1.0;\n"+
-            "    else if (hue > 1.0)\n"+
-            "        hue -= 1.0;\n"+
-            "    lowp float res;\n"+
-            "    if ((6.0 * hue) < 1.0)\n"+
-            "        res = f1 + (f2 - f1) * 6.0 * hue;\n"+
-            "    else if ((2.0 * hue) < 1.0)\n"+
-            "        res = f2;\n"+
-            "    else if ((3.0 * hue) < 2.0)\n"+
-            "        res = f1 + (f2 - f1) * ((2.0 / 3.0) - hue) * 6.0;\n"+
-            "    else\n"+
-            "        res = f1;\n"+
-            "    return res;\n"+
-            "}\n"+
-
-            "lowp vec3 HSLToRGB(lowp vec3 hsl)\n"+
-            "{\n"   +
-            "    lowp vec3 rgb;\n"  +
-
-            "    if (hsl.y == 0.0)\n"   +
-            "        rgb = vec3(hsl.z); // Luminance\n" +
-            "    else\n"    +
-            "    {\n"   +
-            "        lowp float f2;\n"  +
-
-            "        if (hsl.z < 0.5)\n"    +
-            "            f2 = hsl.z * (1.0 + hsl.y);\n" +
-            "        else\n"    +
-            "            f2 = (hsl.z + hsl.y) - (hsl.y * hsl.z);\n" +
-
-            "        lowp float f1 = 2.0 * hsl.z - f2;\n"   +
-
-            "        rgb.r = HueToRGB(f1, f2, hsl.x + (1.0/3.0));\n"    +
-            "        rgb.g = HueToRGB(f1, f2, hsl.x);\n"    +
-            "        rgb.b= HueToRGB(f1, f2, hsl.x - (1.0/3.0));\n" +
-            "    }\n"   +
-
-            "    return rgb;\n  "+
-            "}\n" +
-
-            "lowp float RGBToL(lowp vec3 color)\n"  +
-            "{\n"   +
-            "    lowp float fmin = min(min(color.r, color.g), color.b);    //Min. value of RGB\n"   +
-            "    lowp float fmax = max(max(color.r, color.g), color.b);    //Max. value of RGB\n"   +
-
-            "    return (fmax + fmin) / 2.0; // Luminance\n"    +
-            "}\n"   +
-
-            "void main()\n"+
-            "{\n"+
-            "    lowp vec4 textureColor = texture2D(inputImageTexture, textureCoordinate);\n"   +
-
-            "    // Alternative way:\n" +
-            "    //lowp vec3 lightness = RGBToL(textureColor.rgb);\n"   +
-            "    lowp vec3 lightness = textureColor.rgb;\n" +
-
-            "    const lowp float a = 0.25;\n"  +
-            "    const lowp float b = 0.333;\n" +
-            "    const lowp float scale = 0.7;\n"   +
-
-            "    lowp vec3 shadows = shadowsShift * (clamp((lightness - b) / -a + 0.5, 0.0, 1.0) * scale);\n"   +
-            "    lowp vec3 midtones = midtonesShift * (clamp((lightness - b) / a + 0.5, 0.0, 1.0) *\n"  +
-            "        clamp((lightness + b - 1.0) / -a + 0.5, 0.0, 1.0) * scale);\n" +
-            "    lowp vec3 highlights = highlightsShift * (clamp((lightness + b - 1.0) / a + 0.5, 0.0, 1.0) * scale);\n"    +
-
-            "    mediump vec3 newColor = textureColor.rgb + shadows + midtones + highlights;\n"+
-            "    newColor = clamp(newColor, 0.0, 1.0);\n    "+
-
-            "    if (preserveLuminosity != 0) {\n   "+
-            "        lowp vec3 newHSL = RGBToHSL(newColor);\n"  +
-            "        lowp float oldLum = RGBToL(textureColor.rgb);\n"   +
-            "        textureColor.rgb = HSLToRGB(vec3(newHSL.x, newHSL.y, oldLum));\n"  +
-            "        gl_FragColor = textureColor;\n"    +
-            "    } else {\n"    +
-            "        gl_FragColor = vec4(newColor.rgb, textureColor.w);\n"  +
-            "    }\n" +
-            "}\n";
-
-    private int mShadowsLocation;
-    private int mMidtonesLocation;
-    private int mHighlightsLocation;
-    private int mPreserveLuminosityLocation;
-
-    private float[] showdows;
-    private float[] midtones;
-    private float[] highlights;
-    private boolean preserveLuminosity;
-
-
-    public GPUImageColorBalanceFilter() {
-        super(NO_FILTER_VERTEX_SHADER, GPU_IMAGE_COLOR_BALANCE_FRAGMENT_SHADER);
-        this.showdows = new float[]{0.0f, 0.0f, 0.0f};
-        this.midtones = new float[]{0.0f, 0.0f, 0.0f};
-        this.highlights = new float[]{0.0f, 0.0f, 0.0f};
-        this.preserveLuminosity = true;
-    }
-
-    @Override
-    public void onInit() {
-        super.onInit();
-        mShadowsLocation = GLES20.glGetUniformLocation(getProgram(), "shadowsShift");
-        mMidtonesLocation = GLES20.glGetUniformLocation(getProgram(), "midtonesShift");
-        mHighlightsLocation = GLES20.glGetUniformLocation(getProgram(), "highlightsShift");
-        mPreserveLuminosityLocation = GLES20.glGetUniformLocation(getProgram(), "preserveLuminosity");
-    }
-
-    @Override
-    public void onInitialized() {
-        super.onInitialized();
-        setMidtones(this.midtones);
-        setShowdows(this.showdows);
-        setHighlights(this.highlights);
-        setPreserveLuminosity(this.preserveLuminosity);
-    }
-
-    public void setShowdows(float[] showdows) {
-        this.showdows = showdows;
-        setFloatVec3(mShadowsLocation, showdows);
-    }
-
-    public void setMidtones(float[] midtones) {
-        this.midtones = midtones;
-        setFloatVec3(mMidtonesLocation, midtones);
-    }
-
-    public void setHighlights(float[] highlights) {
-        this.highlights = highlights;
-        setFloatVec3(mHighlightsLocation, highlights);
-    }
-
-    public void setPreserveLuminosity(boolean preserveLuminosity) {
-        this.preserveLuminosity = preserveLuminosity;
-        setInteger(mPreserveLuminosityLocation, preserveLuminosity ? 1: 0);
-    }
-}
diff --git a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageHueFilter.java b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageHueFilter.java
deleted file mode 100644
index 9fcf7939..00000000
--- a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageHueFilter.java
+++ /dev/null
@@ -1,96 +0,0 @@
-/*
- * Copyright (C) 2012 CyberAgent
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package jp.co.cyberagent.android.gpuimage;
-
-import android.opengl.GLES20;
-
-public class GPUImageHueFilter extends GPUImageFilter {
-    public static final String HUE_FRAGMENT_SHADER = "" +
-      "precision highp float;\n" +
-      "varying highp vec2 textureCoordinate;\n" +
-      "\n" +
-      "uniform sampler2D inputImageTexture;\n" +
-      "uniform mediump float hueAdjust;\n" +
-      "const highp vec4 kRGBToYPrime = vec4 (0.299, 0.587, 0.114, 0.0);\n" +
-      "const highp vec4 kRGBToI = vec4 (0.595716, -0.274453, -0.321263, 0.0);\n" +
-      "const highp vec4 kRGBToQ = vec4 (0.211456, -0.522591, 0.31135, 0.0);\n" +
-      "\n" +
-      "const highp vec4 kYIQToR = vec4 (1.0, 0.9563, 0.6210, 0.0);\n" +
-      "const highp vec4 kYIQToG = vec4 (1.0, -0.2721, -0.6474, 0.0);\n" +
-      "const highp vec4 kYIQToB = vec4 (1.0, -1.1070, 1.7046, 0.0);\n" +
-      "\n" +
-      "void main ()\n" +
-      "{\n" +
-      "    // Sample the input pixel\n" +
-      "    highp vec4 color = texture2D(inputImageTexture, textureCoordinate);\n" +
-      "\n" +
-      "    // Convert to YIQ\n" +
-      "    highp float YPrime = dot (color, kRGBToYPrime);\n" +
-      "    highp float I = dot (color, kRGBToI);\n" +
-      "    highp float Q = dot (color, kRGBToQ);\n" +
-      "\n" +
-      "    // Calculate the hue and chroma\n" +
-      "    highp float hue = atan (Q, I);\n" +
-      "    highp float chroma = sqrt (I * I + Q * Q);\n" +
-      "\n" +
-      "    // Make the user's adjustments\n" +
-      "    hue += (-hueAdjust); //why negative rotation?\n" +
-      "\n" +
-      "    // Convert back to YIQ\n" +
-      "    Q = chroma * sin (hue);\n" +
-      "    I = chroma * cos (hue);\n" +
-      "\n" +
-      "    // Convert back to RGB\n" +
-      "    highp vec4 yIQ = vec4 (YPrime, I, Q, 0.0);\n" +
-      "    color.r = dot (yIQ, kYIQToR);\n" +
-      "    color.g = dot (yIQ, kYIQToG);\n" +
-      "    color.b = dot (yIQ, kYIQToB);\n" +
-      "\n" +
-      "    // Save the result\n" +
-      "    gl_FragColor = color;\n" +
-      "}\n";
-
-    private float mHue;
-    private int mHueLocation;
-
-    public GPUImageHueFilter() {
-        this(90.0f);
-    }
-
-    public GPUImageHueFilter(final float hue) {
-        super(NO_FILTER_VERTEX_SHADER, HUE_FRAGMENT_SHADER);
-        mHue = hue;
-    }
-
-    @Override
-    public void onInit() {
-        super.onInit();
-        mHueLocation = GLES20.glGetUniformLocation(getProgram(), "hueAdjust");
-    }
-
-    @Override
-    public void onInitialized() {
-        super.onInitialized();
-        setHue(mHue);
-    }
-
-    public void setHue(final float hue) {
-        mHue = hue;
-        float hueAdjust = (mHue % 360.0f) * (float) Math.PI / 180.0f;
-        setFloat(mHueLocation, hueAdjust);
-    }
-}
diff --git a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageLevelsFilter.java b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageLevelsFilter.java
deleted file mode 100644
index d7fbcfdf..00000000
--- a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageLevelsFilter.java
+++ /dev/null
@@ -1,130 +0,0 @@
-package jp.co.cyberagent.android.gpuimage;
-
-import android.opengl.GLES20;
-import android.util.Log;
-
-/**
- * Created by vashisthg 30/05/14.
- */
-public class GPUImageLevelsFilter extends GPUImageFilter{
-
-    private static final String LOGTAG = GPUImageLevelsFilter.class.getSimpleName();
-
-    public static final String LEVELS_FRAGMET_SHADER =
-
-            " varying highp vec2 textureCoordinate;\n" +
-            " \n" +
-            " uniform sampler2D inputImageTexture;\n" +
-            " uniform mediump vec3 levelMinimum;\n" +
-            " uniform mediump vec3 levelMiddle;\n" +
-            " uniform mediump vec3 levelMaximum;\n" +
-            " uniform mediump vec3 minOutput;\n" +
-            " uniform mediump vec3 maxOutput;\n" +
-            " \n" +
-            " void main()\n" +
-            " {\n" +
-            "     mediump vec4 textureColor = texture2D(inputImageTexture, textureCoordinate);\n" +
-            "     \n" +
-            "     gl_FragColor = vec4( mix(minOutput, maxOutput, pow(min(max(textureColor.rgb -levelMinimum, vec3(0.0)) / (levelMaximum - levelMinimum  ), vec3(1.0)), 1.0 /levelMiddle)) , textureColor.a);\n" +
-            " }\n";
-
-    private int mMinLocation;
-    private float[] mMin;
-    private int mMidLocation;
-    private float[] mMid;
-    private int mMaxLocation;
-    private float[] mMax;
-    private int mMinOutputLocation;
-    private float[] mMinOutput;
-    private int mMaxOutputLocation;
-    private float[] mMaxOutput;
-
-    public GPUImageLevelsFilter() {
-        this(new float[] {0.0f,0.0f,0.0f}, new float[] {1.0f, 1.0f, 1.0f }, new float[] {1.0f, 1.0f ,1.0f}, new float[] {0.0f, 0.0f, 0.0f}, new float[] {1.0f,1.0f,1.0f});
-    }
-
-    private GPUImageLevelsFilter(final float[] min, final float[] mid, final float[] max, final float[] minOUt, final float[] maxOut) {
-        super(NO_FILTER_VERTEX_SHADER, LEVELS_FRAGMET_SHADER);
-
-        mMin = min;
-        mMid = mid;
-        mMax = max;
-        mMinOutput = minOUt;
-        mMaxOutput = maxOut;
-        setMin(0.0f, 1.0f, 1.0f, 0.0f, 1.0f);
-    }
-
-    @Override
-    public void onInit() {
-        super.onInit();
-        mMinLocation = GLES20.glGetUniformLocation(getProgram(), "levelMinimum");
-        mMidLocation = GLES20.glGetUniformLocation(getProgram(), "levelMiddle");
-        mMaxLocation = GLES20.glGetUniformLocation(getProgram(), "levelMaximum");
-        mMinOutputLocation = GLES20.glGetUniformLocation(getProgram(), "minOutput");
-        mMaxOutputLocation = GLES20.glGetUniformLocation(getProgram(), "maxOutput");
-    }
-
-    @Override
-    public void onInitialized() {
-        super.onInitialized();
-        updateUniforms();
-    }
-
-
-    public void updateUniforms () {
-        setFloatVec3(mMinLocation, mMin);
-        setFloatVec3(mMidLocation, mMid);
-        setFloatVec3(mMaxLocation, mMax);
-        setFloatVec3(mMinOutputLocation, mMinOutput);
-        setFloatVec3(mMaxOutputLocation, mMaxOutput);
-    }
-
-    public void setMin(float min, float mid , float max ,float minOut , float maxOut) {
-        setRedMin(min, mid, max, minOut, maxOut);
-        setGreenMin(min, mid, max, minOut, maxOut);
-        setBlueMin(min, mid, max, minOut, maxOut);
-    }
-
-    public void setMin(float min, float mid , float max ) {
-        setMin(min, mid, max, 0.0f, 1.0f);
-    }
-
-    public void setRedMin(float min, float mid , float max ,float minOut , float maxOut) {
-        mMin[0] = min;
-        mMid[0] = mid;
-        mMax[0] = max;
-        mMinOutput[0] = minOut;
-        mMaxOutput[0] = maxOut;
-        updateUniforms();
-    }
-
-    public void setRedMin(float min, float mid , float max ){
-        setRedMin(min, mid, max, 0, 1);
-    }
-
-    public void setGreenMin(float min, float mid , float max ,float minOut , float maxOut) {
-        mMin[1] = min;
-        mMid[1] = mid;
-        mMax[1] = max;
-        mMinOutput[1] = minOut;
-        mMaxOutput[1] = maxOut;
-        updateUniforms();
-    }
-
-    public void setGreenMin(float min, float mid , float max ){
-        setGreenMin(min, mid, max, 0, 1);
-    }
-
-    public void setBlueMin(float min, float mid , float max ,float minOut , float maxOut) {
-        mMin[2] = min;
-        mMid[2] = mid;
-        mMax[2] = max;
-        mMinOutput[2] = minOut;
-        mMaxOutput[2] = maxOut;
-        updateUniforms();
-    }
-
-    public void setBlueMin(float min, float mid , float max ){
-        setBlueMin(min, mid, max, 0, 1);
-    }
-}
diff --git a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageRGBFilter.java b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageRGBFilter.java
deleted file mode 100644
index f0af18cb..00000000
--- a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageRGBFilter.java
+++ /dev/null
@@ -1,94 +0,0 @@
-/*
- * Copyright (C) 2012 CyberAgent
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package jp.co.cyberagent.android.gpuimage;
-
-import android.opengl.GLES20;
-
-/**
- * Adjusts the individual RGB channels of an image
- * red: Normalized values by which each color channel is multiplied. The range is from 0.0 up, with 1.0 as the default.
- * green:
- * blue:
- */
-public class GPUImageRGBFilter extends GPUImageFilter {
-    public static final String RGB_FRAGMENT_SHADER = "" +
-    		"  varying highp vec2 textureCoordinate;\n" +
-    		"  \n" +
-    		"  uniform sampler2D inputImageTexture;\n" +
-    		"  uniform highp float red;\n" +
-    		"  uniform highp float green;\n" +
-    		"  uniform highp float blue;\n" +
-    		"  \n" +
-    		"  void main()\n" +
-    		"  {\n" +
-    		"      highp vec4 textureColor = texture2D(inputImageTexture, textureCoordinate);\n" +
-    		"      \n" +
-    		"      gl_FragColor = vec4(textureColor.r * red, textureColor.g * green, textureColor.b * blue, 1.0);\n" +
-    		"  }\n";
-
-    private int mRedLocation;
-    private float mRed;
-    private int mGreenLocation;
-    private float mGreen;
-    private int mBlueLocation;
-    private float mBlue;
-    private boolean mIsInitialized = false;
-
-    public GPUImageRGBFilter() {
-        this(1.0f, 1.0f, 1.0f);
-    }
-
-    public GPUImageRGBFilter(final float red, final float green, final float blue) {
-        super(NO_FILTER_VERTEX_SHADER, RGB_FRAGMENT_SHADER);
-        mRed = red;
-        mGreen = green;
-        mBlue = blue;
-    }
-
-    @Override
-    public void onInit() {
-        super.onInit();
-        mRedLocation = GLES20.glGetUniformLocation(getProgram(), "red");
-        mGreenLocation = GLES20.glGetUniformLocation(getProgram(), "green");
-        mBlueLocation = GLES20.glGetUniformLocation(getProgram(), "blue");
-        mIsInitialized = true;
-        setRed(mRed);
-        setGreen(mGreen);
-        setBlue(mBlue);
-    }
-
-    public void setRed(final float red) {
-        mRed = red;
-        if (mIsInitialized) {
-            setFloat(mRedLocation, mRed);
-        }
-    }
-    
-    public void setGreen(final float green) {
-        mGreen = green;
-        if (mIsInitialized) {
-            setFloat(mGreenLocation, mGreen);
-        }
-    }
-    
-    public void setBlue(final float blue) {
-        mBlue = blue;
-        if (mIsInitialized) {
-            setFloat(mBlueLocation, mBlue);
-        }
-    }
-}
diff --git a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageSobelThresholdFilter.java b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageSobelThresholdFilter.java
deleted file mode 100644
index f1dcf64e..00000000
--- a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageSobelThresholdFilter.java
+++ /dev/null
@@ -1,74 +0,0 @@
-package jp.co.cyberagent.android.gpuimage;
-
-import android.opengl.GLES20;
-
-public class GPUImageSobelThresholdFilter extends
-		GPUImage3x3TextureSamplingFilter {
-    public static final String SOBEL_THRESHOLD_EDGE_DETECTION = "" +
-    		"precision mediump float;\n" +
-    		"\n" +
-    		"varying vec2 textureCoordinate;\n" +
-    		"varying vec2 leftTextureCoordinate;\n" +
-    		"varying vec2 rightTextureCoordinate;\n" +
-    		"\n" +
-    		"varying vec2 topTextureCoordinate;\n" +
-    		"varying vec2 topLeftTextureCoordinate;\n" +
-    		"varying vec2 topRightTextureCoordinate;\n" +
-    		"\n" +
-    		"varying vec2 bottomTextureCoordinate;\n" +
-    		"varying vec2 bottomLeftTextureCoordinate;\n" +
-    		"varying vec2 bottomRightTextureCoordinate;\n" +
-    		"\n" +
-    		"uniform sampler2D inputImageTexture;\n" +
-    		"uniform lowp float threshold;\n" +
-    		"\n" +
-    		"const highp vec3 W = vec3(0.2125, 0.7154, 0.0721);\n" +
-    		"\n" +
-    		"void main()\n" +
-    		"{\n" +
-    		"    float bottomLeftIntensity = texture2D(inputImageTexture, bottomLeftTextureCoordinate).r;\n" +
-    		"    float topRightIntensity = texture2D(inputImageTexture, topRightTextureCoordinate).r;\n" +
-    		"    float topLeftIntensity = texture2D(inputImageTexture, topLeftTextureCoordinate).r;\n" +
-    		"    float bottomRightIntensity = texture2D(inputImageTexture, bottomRightTextureCoordinate).r;\n" +
-    		"    float leftIntensity = texture2D(inputImageTexture, leftTextureCoordinate).r;\n" +
-    		"    float rightIntensity = texture2D(inputImageTexture, rightTextureCoordinate).r;\n" +
-    		"    float bottomIntensity = texture2D(inputImageTexture, bottomTextureCoordinate).r;\n" +
-    		"    float topIntensity = texture2D(inputImageTexture, topTextureCoordinate).r;\n" +
-    		"    float h = -topLeftIntensity - 2.0 * topIntensity - topRightIntensity + bottomLeftIntensity + 2.0 * bottomIntensity + bottomRightIntensity;\n" +
-    		"    float v = -bottomLeftIntensity - 2.0 * leftIntensity - topLeftIntensity + bottomRightIntensity + 2.0 * rightIntensity + topRightIntensity;\n" +
-    		"\n" +
-    		"    float mag = 1.0 - length(vec2(h, v));\n" +
-    		"    mag = step(threshold, mag);\n" +
-    		"\n" +
-    		"    gl_FragColor = vec4(vec3(mag), 1.0);\n" +
-    		"}\n";
-
-    private int mUniformThresholdLocation;
-    private float mThreshold = 0.9f;
-    
-    public GPUImageSobelThresholdFilter() {
-    	this(0.9f);
-    }
-    
-    public GPUImageSobelThresholdFilter(float threshold) {
-    	super(SOBEL_THRESHOLD_EDGE_DETECTION);
-    	mThreshold = threshold;
-    }
-    
-    @Override
-    public void onInit() {
-    	super.onInit();
-    	mUniformThresholdLocation = GLES20.glGetUniformLocation(getProgram(), "threshold");
-    }
-    
-    @Override
-    public void onInitialized() {
-    	super.onInitialized();
-    	setThreshold(mThreshold);
-    }
-    
-    public void setThreshold(final float threshold) {
-    	mThreshold = threshold;
-    	setFloat(mUniformThresholdLocation, threshold);
-    }
-}
diff --git a/library/src/main/AndroidManifest.xml b/library/src/main/AndroidManifest.xml
new file mode 100644
index 00000000..5193400f
--- /dev/null
+++ b/library/src/main/AndroidManifest.xml
@@ -0,0 +1,2 @@
+<?xml version="1.0" encoding="utf-8"?>
+<manifest package="jp.co.cyberagent.android.gpuimage" />
\ No newline at end of file
diff --git a/library/src/main/cpp/CMakeLists.txt b/library/src/main/cpp/CMakeLists.txt
new file mode 100644
index 00000000..af48ac01
--- /dev/null
+++ b/library/src/main/cpp/CMakeLists.txt
@@ -0,0 +1,46 @@
+# For more information about using CMake with Android Studio, read the
+# documentation: https://d.android.com/studio/projects/add-native-code.html
+
+# Sets the minimum version of CMake required to build the native library.
+
+cmake_minimum_required(VERSION 3.4.1)
+
+# Creates and names a library, sets it as either STATIC
+# or SHARED, and provides the relative paths to its source code.
+# You can define multiple libraries, and CMake builds them for you.
+# Gradle automatically packages shared libraries with your APK.
+
+add_library( # Sets the name of the library.
+        yuv-decoder
+
+        # Sets the library as a shared library.
+        SHARED
+
+        # Provides a relative path to your source file(s).
+        yuv-decoder.c)
+
+# Searches for a specified prebuilt library and stores the path as a
+# variable. Because CMake includes system libraries in the search path by
+# default, you only need to specify the name of the public NDK library
+# you want to add. CMake verifies that the library exists before
+# completing its build.
+
+find_library( # Sets the name of the path variable.
+        log-lib
+
+        # Specifies the name of the NDK library that
+        # you want CMake to locate.
+        log)
+
+# Specifies libraries CMake should link to your target library. You
+# can link multiple libraries, such as libraries you define in this
+# build script, prebuilt third-party libraries, or system libraries.
+
+target_link_libraries( # Specifies the target library.
+        yuv-decoder
+
+        # Links the target library to the log library
+        # included in the NDK.
+        ${log-lib}
+        GLESv2
+        jnigraphics)
\ No newline at end of file
diff --git a/library/src/main/cpp/yuv-decoder.c b/library/src/main/cpp/yuv-decoder.c
new file mode 100644
index 00000000..b9596f85
--- /dev/null
+++ b/library/src/main/cpp/yuv-decoder.c
@@ -0,0 +1,158 @@
+#include <jni.h>
+
+#include <android/bitmap.h>
+#include <GLES2/gl2.h>
+
+
+JNIEXPORT void JNICALL
+Java_jp_co_cyberagent_android_gpuimage_GPUImageNativeLibrary_YUVtoRBGA(JNIEnv *env, jobject obj,
+                                                                       jbyteArray yuv420sp,
+                                                                       jint width, jint height,
+                                                                       jintArray rgbOut) {
+    int sz;
+    int i;
+    int j;
+    int Y;
+    int Cr = 0;
+    int Cb = 0;
+    int pixPtr = 0;
+    int jDiv2 = 0;
+    int R = 0;
+    int G = 0;
+    int B = 0;
+    int cOff;
+    int w = width;
+    int h = height;
+    sz = w * h;
+
+    jint *rgbData = (jint *) ((*env)->GetPrimitiveArrayCritical(env, rgbOut, 0));
+    jbyte *yuv = (jbyte *) (*env)->GetPrimitiveArrayCritical(env, yuv420sp, 0);
+
+    for (j = 0; j < h; j++) {
+        pixPtr = j * w;
+        jDiv2 = j >> 1;
+        for (i = 0; i < w; i++) {
+            Y = yuv[pixPtr];
+            if (Y < 0) Y += 255;
+            if ((i & 0x1) != 1) {
+                cOff = sz + jDiv2 * w + (i >> 1) * 2;
+                Cb = yuv[cOff];
+                if (Cb < 0) Cb += 127; else Cb -= 128;
+                Cr = yuv[cOff + 1];
+                if (Cr < 0) Cr += 127; else Cr -= 128;
+            }
+
+            //ITU-R BT.601 conversion
+            //
+            //R = 1.164*(Y-16) + 2.018*(Cr-128);
+            //G = 1.164*(Y-16) - 0.813*(Cb-128) - 0.391*(Cr-128);
+            //B = 1.164*(Y-16) + 1.596*(Cb-128);
+            //
+            Y = Y + (Y >> 3) + (Y >> 5) + (Y >> 7);
+            R = Y + (Cr << 1) + (Cr >> 6);
+            if (R < 0) R = 0; else if (R > 255) R = 255;
+            G = Y - Cb + (Cb >> 3) + (Cb >> 4) - (Cr >> 1) + (Cr >> 3);
+            if (G < 0) G = 0; else if (G > 255) G = 255;
+            B = Y + Cb + (Cb >> 1) + (Cb >> 4) + (Cb >> 5);
+            if (B < 0) B = 0; else if (B > 255) B = 255;
+            rgbData[pixPtr++] = 0xff000000 + (R << 16) + (G << 8) + B;
+        }
+    }
+
+    (*env)->ReleasePrimitiveArrayCritical(env, rgbOut, rgbData, 0);
+    (*env)->ReleasePrimitiveArrayCritical(env, yuv420sp, yuv, 0);
+}
+
+JNIEXPORT void JNICALL
+Java_jp_co_cyberagent_android_gpuimage_GPUImageNativeLibrary_YUVtoARBG(JNIEnv *env, jobject obj,
+                                                                       jbyteArray yuv420sp,
+                                                                       jint width, jint height,
+                                                                       jintArray rgbOut) {
+    int sz;
+    int i;
+    int j;
+    int Y;
+    int Cr = 0;
+    int Cb = 0;
+    int pixPtr = 0;
+    int jDiv2 = 0;
+    int R = 0;
+    int G = 0;
+    int B = 0;
+    int cOff;
+    int w = width;
+    int h = height;
+    sz = w * h;
+
+    jint *rgbData = (jint *) ((*env)->GetPrimitiveArrayCritical(env, rgbOut, 0));
+    jbyte *yuv = (jbyte *) (*env)->GetPrimitiveArrayCritical(env, yuv420sp, 0);
+
+    for (j = 0; j < h; j++) {
+        pixPtr = j * w;
+        jDiv2 = j >> 1;
+        for (i = 0; i < w; i++) {
+            Y = yuv[pixPtr];
+            if (Y < 0) Y += 255;
+            if ((i & 0x1) != 1) {
+                cOff = sz + jDiv2 * w + (i >> 1) * 2;
+                Cb = yuv[cOff];
+                if (Cb < 0) Cb += 127; else Cb -= 128;
+                Cr = yuv[cOff + 1];
+                if (Cr < 0) Cr += 127; else Cr -= 128;
+            }
+
+            //ITU-R BT.601 conversion
+            //
+            //R = 1.164*(Y-16) + 2.018*(Cr-128);
+            //G = 1.164*(Y-16) - 0.813*(Cb-128) - 0.391*(Cr-128);
+            //B = 1.164*(Y-16) + 1.596*(Cb-128);
+            //
+            Y = Y + (Y >> 3) + (Y >> 5) + (Y >> 7);
+            R = Y + (Cr << 1) + (Cr >> 6);
+            if (R < 0) R = 0; else if (R > 255) R = 255;
+            G = Y - Cb + (Cb >> 3) + (Cb >> 4) - (Cr >> 1) + (Cr >> 3);
+            if (G < 0) G = 0; else if (G > 255) G = 255;
+            B = Y + Cb + (Cb >> 1) + (Cb >> 4) + (Cb >> 5);
+            if (B < 0) B = 0; else if (B > 255) B = 255;
+            rgbData[pixPtr++] = 0xff000000 + (B << 16) + (G << 8) + R;
+        }
+    }
+
+    (*env)->ReleasePrimitiveArrayCritical(env, rgbOut, rgbData, 0);
+    (*env)->ReleasePrimitiveArrayCritical(env, yuv420sp, yuv, 0);
+}
+
+
+JNIEXPORT void JNICALL
+Java_jp_co_cyberagent_android_gpuimage_GPUImageNativeLibrary_adjustBitmap(JNIEnv *jenv, jclass thiz,
+                                                                       jobject src) {
+    unsigned char *srcByteBuffer;
+    int result = 0;
+    int i, j;
+    AndroidBitmapInfo srcInfo;
+
+    result = AndroidBitmap_getInfo(jenv, src, &srcInfo);
+    if (result != ANDROID_BITMAP_RESULT_SUCCESS) {
+        return;
+    }
+
+    result = AndroidBitmap_lockPixels(jenv, src, (void **) &srcByteBuffer);
+    if (result != ANDROID_BITMAP_RESULT_SUCCESS) {
+        return;
+    }
+
+    int width = srcInfo.width;
+    int height = srcInfo.height;
+    glReadPixels(0, 0, srcInfo.width, srcInfo.height, GL_RGBA, GL_UNSIGNED_BYTE, srcByteBuffer);
+
+    int *pIntBuffer = (int *) srcByteBuffer;
+
+    for (i = 0; i < height / 2; i++) {
+        for (j = 0; j < width; j++) {
+            int temp = pIntBuffer[(height - i - 1) * width + j];
+            pIntBuffer[(height - i - 1) * width + j] = pIntBuffer[i * width + j];
+            pIntBuffer[i * width + j] = temp;
+        }
+    }
+    AndroidBitmap_unlockPixels(jenv, src);
+}
\ No newline at end of file
diff --git a/library/src/main/java/jp/co/cyberagent/android/gpuimage/GLTextureView.java b/library/src/main/java/jp/co/cyberagent/android/gpuimage/GLTextureView.java
new file mode 100644
index 00000000..d6cfc078
--- /dev/null
+++ b/library/src/main/java/jp/co/cyberagent/android/gpuimage/GLTextureView.java
@@ -0,0 +1,1809 @@
+package jp.co.cyberagent.android.gpuimage;
+
+import android.content.Context;
+import android.graphics.SurfaceTexture;
+import android.opengl.GLDebugHelper;
+import android.util.AttributeSet;
+import android.util.Log;
+import android.view.TextureView;
+import android.view.View;
+
+import java.io.Writer;
+import java.lang.ref.WeakReference;
+import java.util.ArrayList;
+import java.util.List;
+
+import javax.microedition.khronos.egl.EGL10;
+import javax.microedition.khronos.egl.EGL11;
+import javax.microedition.khronos.egl.EGLConfig;
+import javax.microedition.khronos.egl.EGLContext;
+import javax.microedition.khronos.egl.EGLDisplay;
+import javax.microedition.khronos.egl.EGLSurface;
+import javax.microedition.khronos.opengles.GL;
+import javax.microedition.khronos.opengles.GL10;
+
+/*
+ * Copyright (C) 2018 Wasabeef
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+public class GLTextureView extends TextureView
+        implements TextureView.SurfaceTextureListener, View.OnLayoutChangeListener {
+
+    private final static String TAG = GLTextureView.class.getSimpleName();
+
+    private final static boolean LOG_ATTACH_DETACH = false;
+    private final static boolean LOG_THREADS = false;
+    private final static boolean LOG_PAUSE_RESUME = false;
+    private final static boolean LOG_SURFACE = false;
+    private final static boolean LOG_RENDERER = false;
+    private final static boolean LOG_RENDERER_DRAW_FRAME = false;
+    private final static boolean LOG_EGL = false;
+
+    /**
+     * The renderer only renders
+     * when the surface is created, or when {@link #requestRender} is called.
+     *
+     * @see #getRenderMode()
+     * @see #setRenderMode(int)
+     * @see #requestRender()
+     */
+    public final static int RENDERMODE_WHEN_DIRTY = 0;
+    /**
+     * The renderer is called
+     * continuously to re-render the scene.
+     *
+     * @see #getRenderMode()
+     * @see #setRenderMode(int)
+     */
+    public final static int RENDERMODE_CONTINUOUSLY = 1;
+
+    /**
+     * Check glError() after every GL call and throw an exception if glError indicates
+     * that an error has occurred. This can be used to help track down which OpenGL ES call
+     * is causing an error.
+     *
+     * @see #getDebugFlags
+     * @see #setDebugFlags
+     */
+    public final static int DEBUG_CHECK_GL_ERROR = 1;
+
+    /**
+     * Log GL calls to the system log at "verbose" level with tag "GLTextureView".
+     *
+     * @see #getDebugFlags
+     * @see #setDebugFlags
+     */
+    public final static int DEBUG_LOG_GL_CALLS = 2;
+
+    /**
+     * Standard View constructor. In order to render something, you
+     * must call {@link #setRenderer} to register a renderer.
+     */
+    public GLTextureView(Context context) {
+        super(context);
+        init();
+    }
+
+    /**
+     * Standard View constructor. In order to render something, you
+     * must call {@link #setRenderer} to register a renderer.
+     */
+    public GLTextureView(Context context, AttributeSet attrs) {
+        super(context, attrs);
+        init();
+    }
+
+    @Override
+    protected void finalize() throws Throwable {
+        try {
+            if (glThread != null) {
+                // GLThread may still be running if this view was never
+                // attached to a window.
+                glThread.requestExitAndWait();
+            }
+        } finally {
+            super.finalize();
+        }
+    }
+
+    private void init() {
+        setSurfaceTextureListener(this);
+    }
+
+    /**
+     * Set the glWrapper. If the glWrapper is not null, its
+     * {@link GLWrapper#wrap(javax.microedition.khronos.opengles.GL)} method is called
+     * whenever a surface is created. A GLWrapper can be used to wrap
+     * the GL object that's passed to the renderer. Wrapping a GL
+     * object enables examining and modifying the behavior of the
+     * GL calls made by the renderer.
+     * <p>
+     * Wrapping is typically used for debugging purposes.
+     * <p>
+     * The default value is null.
+     *
+     * @param glWrapper the new GLWrapper
+     */
+    public void setGLWrapper(GLWrapper glWrapper) {
+        this.glWrapper = glWrapper;
+    }
+
+    /**
+     * Set the debug flags to a new value. The value is
+     * constructed by OR-together zero or more
+     * of the DEBUG_CHECK_* constants. The debug flags take effect
+     * whenever a surface is created. The default value is zero.
+     *
+     * @param debugFlags the new debug flags
+     * @see #DEBUG_CHECK_GL_ERROR
+     * @see #DEBUG_LOG_GL_CALLS
+     */
+    public void setDebugFlags(int debugFlags) {
+        this.debugFlags = debugFlags;
+    }
+
+    /**
+     * Get the current value of the debug flags.
+     *
+     * @return the current value of the debug flags.
+     */
+    public int getDebugFlags() {
+        return debugFlags;
+    }
+
+    /**
+     * Control whether the EGL context is preserved when the GLTextureView is paused and
+     * resumed.
+     * <p>
+     * If set to true, then the EGL context may be preserved when the GLTextureView is paused.
+     * Whether the EGL context is actually preserved or not depends upon whether the
+     * Android device that the program is running on can support an arbitrary number of EGL
+     * contexts or not. Devices that can only support a limited number of EGL contexts must
+     * release the  EGL context in order to allow multiple applications to share the GPU.
+     * <p>
+     * If set to false, the EGL context will be released when the GLTextureView is paused,
+     * and recreated when the GLTextureView is resumed.
+     * <p>
+     * <p>
+     * The default is false.
+     *
+     * @param preserveOnPause preserve the EGL context when paused
+     */
+    public void setPreserveEGLContextOnPause(boolean preserveOnPause) {
+        preserveEGLContextOnPause = preserveOnPause;
+    }
+
+    /**
+     * @return true if the EGL context will be preserved when paused
+     */
+    public boolean getPreserveEGLContextOnPause() {
+        return preserveEGLContextOnPause;
+    }
+
+    /**
+     * Set the renderer associated with this view. Also starts the thread that
+     * will call the renderer, which in turn causes the rendering to start.
+     * <p>This method should be called once and only once in the life-cycle of
+     * a GLTextureView.
+     * <p>The following GLTextureView methods can only be called <em>before</em>
+     * setRenderer is called:
+     * <ul>
+     * <li>{@link #setEGLConfigChooser(boolean)}
+     * <li>{@link #setEGLConfigChooser(EGLConfigChooser)}
+     * <li>{@link #setEGLConfigChooser(int, int, int, int, int, int)}
+     * </ul>
+     * <p>
+     * The following GLTextureView methods can only be called <em>after</em>
+     * setRenderer is called:
+     * <ul>
+     * <li>{@link #getRenderMode()}
+     * <li>{@link #onPause()}
+     * <li>{@link #onResume()}
+     * <li>{@link #queueEvent(Runnable)}
+     * <li>{@link #requestRender()}
+     * <li>{@link #setRenderMode(int)}
+     * </ul>
+     *
+     * @param renderer the renderer to use to perform OpenGL drawing.
+     */
+    public void setRenderer(Renderer renderer) {
+        checkRenderThreadState();
+        if (eglConfigChooser == null) {
+            eglConfigChooser = new SimpleEGLConfigChooser(true);
+        }
+        if (eglContextFactory == null) {
+            eglContextFactory = new DefaultContextFactory();
+        }
+        if (eglWindowSurfaceFactory == null) {
+            eglWindowSurfaceFactory = new DefaultWindowSurfaceFactory();
+        }
+        this.renderer = renderer;
+        glThread = new GLThread(mThisWeakRef);
+        glThread.start();
+    }
+
+    /**
+     * Install a custom EGLContextFactory.
+     * <p>If this method is
+     * called, it must be called before {@link #setRenderer(Renderer)}
+     * is called.
+     * <p>
+     * If this method is not called, then by default
+     * a context will be created with no shared context and
+     * with a null attribute list.
+     */
+    public void setEGLContextFactory(EGLContextFactory factory) {
+        checkRenderThreadState();
+        eglContextFactory = factory;
+    }
+
+    /**
+     * Install a custom EGLWindowSurfaceFactory.
+     * <p>If this method is
+     * called, it must be called before {@link #setRenderer(Renderer)}
+     * is called.
+     * <p>
+     * If this method is not called, then by default
+     * a window surface will be created with a null attribute list.
+     */
+    public void setEGLWindowSurfaceFactory(EGLWindowSurfaceFactory factory) {
+        checkRenderThreadState();
+        eglWindowSurfaceFactory = factory;
+    }
+
+    /**
+     * Install a custom EGLConfigChooser.
+     * <p>If this method is
+     * called, it must be called before {@link #setRenderer(Renderer)}
+     * is called.
+     * <p>
+     * If no setEGLConfigChooser method is called, then by default the
+     * view will choose an EGLConfig that is compatible with the current
+     * android.view.Surface, with a depth buffer depth of
+     * at least 16 bits.
+     */
+    public void setEGLConfigChooser(EGLConfigChooser configChooser) {
+        checkRenderThreadState();
+        eglConfigChooser = configChooser;
+    }
+
+    /**
+     * Install a config chooser which will choose a config
+     * as close to 16-bit RGB as possible, with or without an optional depth
+     * buffer as close to 16-bits as possible.
+     * <p>If this method is
+     * called, it must be called before {@link #setRenderer(Renderer)}
+     * is called.
+     * <p>
+     * If no setEGLConfigChooser method is called, then by default the
+     * view will choose an RGB_888 surface with a depth buffer depth of
+     * at least 16 bits.
+     */
+    public void setEGLConfigChooser(boolean needDepth) {
+        setEGLConfigChooser(new SimpleEGLConfigChooser(needDepth));
+    }
+
+    /**
+     * Install a config chooser which will choose a config
+     * with at least the specified depthSize and stencilSize,
+     * and exactly the specified redSize, greenSize, blueSize and alphaSize.
+     * <p>If this method is
+     * called, it must be called before {@link #setRenderer(Renderer)}
+     * is called.
+     * <p>
+     * If no setEGLConfigChooser method is called, then by default the
+     * view will choose an RGB_888 surface with a depth buffer depth of
+     * at least 16 bits.
+     */
+    public void setEGLConfigChooser(int redSize, int greenSize, int blueSize, int alphaSize,
+                                    int depthSize, int stencilSize) {
+        setEGLConfigChooser(
+                new ComponentSizeChooser(redSize, greenSize, blueSize, alphaSize, depthSize, stencilSize));
+    }
+
+    /**
+     * Inform the default EGLContextFactory and default EGLConfigChooser
+     * which EGLContext client version to pick.
+     * <p>Use this method to create an OpenGL ES 2.0-compatible context.
+     * Example:
+     * <pre class="prettyprint">
+     * public MyView(Context context) {
+     * super(context);
+     * setEGLContextClientVersion(2); // Pick an OpenGL ES 2.0 context.
+     * setRenderer(new MyRenderer());
+     * }
+     * </pre>
+     * <p>Note: Activities which require OpenGL ES 2.0 should indicate this by
+     * setting @lt;uses-feature android:glEsVersion="0x00020000" /> in the activity's
+     * AndroidManifest.xml file.
+     * <p>If this method is called, it must be called before {@link #setRenderer(Renderer)}
+     * is called.
+     * <p>This method only affects the behavior of the default EGLContexFactory and the
+     * default EGLConfigChooser. If
+     * {@link #setEGLContextFactory(EGLContextFactory)} has been called, then the supplied
+     * EGLContextFactory is responsible for creating an OpenGL ES 2.0-compatible context.
+     * If
+     * {@link #setEGLConfigChooser(EGLConfigChooser)} has been called, then the supplied
+     * EGLConfigChooser is responsible for choosing an OpenGL ES 2.0-compatible config.
+     *
+     * @param version The EGLContext client version to choose. Use 2 for OpenGL ES 2.0
+     */
+    public void setEGLContextClientVersion(int version) {
+        checkRenderThreadState();
+        eglContextClientVersion = version;
+    }
+
+    /**
+     * Set the rendering mode. When renderMode is
+     * RENDERMODE_CONTINUOUSLY, the renderer is called
+     * repeatedly to re-render the scene. When renderMode
+     * is RENDERMODE_WHEN_DIRTY, the renderer only rendered when the surface
+     * is created, or when {@link #requestRender} is called. Defaults to RENDERMODE_CONTINUOUSLY.
+     * <p>
+     * Using RENDERMODE_WHEN_DIRTY can improve battery life and overall system performance
+     * by allowing the GPU and CPU to idle when the view does not need to be updated.
+     * <p>
+     * This method can only be called after {@link #setRenderer(Renderer)}
+     *
+     * @param renderMode one of the RENDERMODE_X constants
+     * @see #RENDERMODE_CONTINUOUSLY
+     * @see #RENDERMODE_WHEN_DIRTY
+     */
+    public void setRenderMode(int renderMode) {
+        glThread.setRenderMode(renderMode);
+    }
+
+    /**
+     * Get the current rendering mode. May be called
+     * from any thread. Must not be called before a renderer has been set.
+     *
+     * @return the current rendering mode.
+     * @see #RENDERMODE_CONTINUOUSLY
+     * @see #RENDERMODE_WHEN_DIRTY
+     */
+    public int getRenderMode() {
+        return glThread.getRenderMode();
+    }
+
+    /**
+     * Request that the renderer render a frame.
+     * This method is typically used when the render mode has been set to
+     * {@link #RENDERMODE_WHEN_DIRTY}, so that frames are only rendered on demand.
+     * May be called
+     * from any thread. Must not be called before a renderer has been set.
+     */
+    public void requestRender() {
+        glThread.requestRender();
+    }
+
+    /**
+     * This method is part of the SurfaceHolder.Callback interface, and is
+     * not normally called or subclassed by clients of GLTextureView.
+     */
+    public void surfaceCreated(SurfaceTexture texture) {
+        glThread.surfaceCreated();
+    }
+
+    /**
+     * This method is part of the SurfaceHolder.Callback interface, and is
+     * not normally called or subclassed by clients of GLTextureView.
+     */
+    public void surfaceDestroyed(SurfaceTexture texture) {
+        // Surface will be destroyed when we return
+        glThread.surfaceDestroyed();
+    }
+
+    /**
+     * This method is part of the SurfaceHolder.Callback interface, and is
+     * not normally called or subclassed by clients of GLTextureView.
+     */
+    public void surfaceChanged(SurfaceTexture texture, int format, int w, int h) {
+        glThread.onWindowResize(w, h);
+    }
+
+    /**
+     * Inform the view that the activity is paused. The owner of this view must
+     * call this method when the activity is paused. Calling this method will
+     * pause the rendering thread.
+     * Must not be called before a renderer has been set.
+     */
+    public void onPause() {
+        glThread.onPause();
+    }
+
+    /**
+     * Inform the view that the activity is resumed. The owner of this view must
+     * call this method when the activity is resumed. Calling this method will
+     * recreate the OpenGL display and resume the rendering
+     * thread.
+     * Must not be called before a renderer has been set.
+     */
+    public void onResume() {
+        glThread.onResume();
+    }
+
+    /**
+     * Queue a runnable to be run on the GL rendering thread. This can be used
+     * to communicate with the Renderer on the rendering thread.
+     * Must not be called before a renderer has been set.
+     *
+     * @param r the runnable to be run on the GL rendering thread.
+     */
+    public void queueEvent(Runnable r) {
+        glThread.queueEvent(r);
+    }
+
+    /**
+     * This method is used as part of the View class and is not normally
+     * called or subclassed by clients of GLTextureView.
+     */
+    @Override
+    protected void onAttachedToWindow() {
+        super.onAttachedToWindow();
+        if (LOG_ATTACH_DETACH) {
+            Log.d(TAG, "onAttachedToWindow reattach =" + detached);
+        }
+        if (detached && (renderer != null)) {
+            int renderMode = RENDERMODE_CONTINUOUSLY;
+            if (glThread != null) {
+                renderMode = glThread.getRenderMode();
+            }
+            glThread = new GLThread(mThisWeakRef);
+            if (renderMode != RENDERMODE_CONTINUOUSLY) {
+                glThread.setRenderMode(renderMode);
+            }
+            glThread.start();
+        }
+        detached = false;
+    }
+
+    /**
+     * This method is used as part of the View class and is not normally
+     * called or subclassed by clients of GLTextureView.
+     * Must not be called before a renderer has been set.
+     */
+    @Override
+    protected void onDetachedFromWindow() {
+        if (LOG_ATTACH_DETACH) {
+            Log.d(TAG, "onDetachedFromWindow");
+        }
+        if (glThread != null) {
+            glThread.requestExitAndWait();
+        }
+        detached = true;
+        super.onDetachedFromWindow();
+    }
+
+    public void onLayoutChange(View v, int left, int top, int right, int bottom, int oldLeft,
+                               int oldTop, int oldRight, int oldBottom) {
+        surfaceChanged(getSurfaceTexture(), 0, right - left, bottom - top);
+    }
+
+    public void addSurfaceTextureListener(SurfaceTextureListener listener) {
+        surfaceTextureListeners.add(listener);
+    }
+
+    public void onSurfaceTextureAvailable(SurfaceTexture surface, int width, int height) {
+        surfaceCreated(surface);
+        surfaceChanged(surface, 0, width, height);
+
+        for (SurfaceTextureListener l : surfaceTextureListeners) {
+            l.onSurfaceTextureAvailable(surface, width, height);
+        }
+    }
+
+    public void onSurfaceTextureSizeChanged(SurfaceTexture surface, int width, int height) {
+        surfaceChanged(surface, 0, width, height);
+
+        for (SurfaceTextureListener l : surfaceTextureListeners) {
+            l.onSurfaceTextureSizeChanged(surface, width, height);
+        }
+    }
+
+    public boolean onSurfaceTextureDestroyed(SurfaceTexture surface) {
+        surfaceDestroyed(surface);
+
+        for (SurfaceTextureListener l : surfaceTextureListeners) {
+            l.onSurfaceTextureDestroyed(surface);
+        }
+
+        return true;
+    }
+
+    public void onSurfaceTextureUpdated(SurfaceTexture surface) {
+        requestRender();
+
+        for (SurfaceTextureListener l : surfaceTextureListeners) {
+            l.onSurfaceTextureUpdated(surface);
+        }
+    }
+
+    // ----------------------------------------------------------------------
+
+    /**
+     * An interface used to wrap a GL interface.
+     * <p>Typically
+     * used for implementing debugging and tracing on top of the default
+     * GL interface. You would typically use this by creating your own class
+     * that implemented all the GL methods by delegating to another GL instance.
+     * Then you could add your own behavior before or after calling the
+     * delegate. All the GLWrapper would do was instantiate and return the
+     * wrapper GL instance:
+     * <pre class="prettyprint">
+     * class MyGLWrapper implements GLWrapper {
+     * GL wrap(GL gl) {
+     * return new MyGLImplementation(gl);
+     * }
+     * static class MyGLImplementation implements GL,GL10,GL11,... {
+     * ...
+     * }
+     * }
+     * </pre>
+     *
+     * @see #setGLWrapper(GLWrapper)
+     */
+    public interface GLWrapper {
+        /**
+         * Wraps a gl interface in another gl interface.
+         *
+         * @param gl a GL interface that is to be wrapped.
+         * @return either the input argument or another GL object that wraps the input argument.
+         */
+        GL wrap(GL gl);
+    }
+
+    /**
+     * A generic renderer interface.
+     * <p>
+     * The renderer is responsible for making OpenGL calls to render a frame.
+     * <p>
+     * GLTextureView clients typically create their own classes that implement
+     * this interface, and then call {@link GLTextureView#setRenderer} to
+     * register the renderer with the GLTextureView.
+     * <p>
+     *
+     * <div class="special reference">
+     * <h3>Developer Guides</h3>
+     * <p>For more information about how to use OpenGL, read the
+     * <a href="{@docRoot}guide/topics/graphics/opengl.html">OpenGL</a> developer guide.</p>
+     * </div>
+     *
+     * <h3>Threading</h3>
+     * The renderer will be called on a separate thread, so that rendering
+     * performance is decoupled from the UI thread. Clients typically need to
+     * communicate with the renderer from the UI thread, because that's where
+     * input events are received. Clients can communicate using any of the
+     * standard Java techniques for cross-thread communication, or they can
+     * use the {@link GLTextureView#queueEvent(Runnable)} convenience method.
+     * <p>
+     * <h3>EGL Context Lost</h3>
+     * There are situations where the EGL rendering context will be lost. This
+     * typically happens when device wakes up after going to sleep. When
+     * the EGL context is lost, all OpenGL resources (such as textures) that are
+     * associated with that context will be automatically deleted. In order to
+     * keep rendering correctly, a renderer must recreate any lost resources
+     * that it still needs. The {@link #onSurfaceCreated(javax.microedition.khronos.opengles.GL10,
+     * javax.microedition.khronos.egl.EGLConfig)} method
+     * is a convenient place to do this.
+     *
+     * @see #setRenderer(Renderer)
+     */
+    public interface Renderer {
+        /**
+         * Called when the surface is created or recreated.
+         * <p>
+         * Called when the rendering thread
+         * starts and whenever the EGL context is lost. The EGL context will typically
+         * be lost when the Android device awakes after going to sleep.
+         * <p>
+         * Since this method is called at the beginning of rendering, as well as
+         * every time the EGL context is lost, this method is a convenient place to put
+         * code to create resources that need to be created when the rendering
+         * starts, and that need to be recreated when the EGL context is lost.
+         * Textures are an example of a resource that you might want to create
+         * here.
+         * <p>
+         * Note that when the EGL context is lost, all OpenGL resources associated
+         * with that context will be automatically deleted. You do not need to call
+         * the corresponding "glDelete" methods such as glDeleteTextures to
+         * manually delete these lost resources.
+         * <p>
+         *
+         * @param gl     the GL interface. Use <code>instanceof</code> to
+         *               test if the interface supports GL11 or higher interfaces.
+         * @param config the EGLConfig of the created surface. Can be used
+         *               to create matching pbuffers.
+         */
+        void onSurfaceCreated(GL10 gl, EGLConfig config);
+
+        /**
+         * Called when the surface changed size.
+         * <p>
+         * Called after the surface is created and whenever
+         * the OpenGL ES surface size changes.
+         * <p>
+         * Typically you will set your viewport here. If your camera
+         * is fixed then you could also set your projection matrix here:
+         * <pre class="prettyprint">
+         * void onSurfaceChanged(GL10 gl, int width, int height) {
+         * gl.glViewport(0, 0, width, height);
+         * // for a fixed camera, set the projection too
+         * float ratio = (float) width / height;
+         * gl.glMatrixMode(GL10.GL_PROJECTION);
+         * gl.glLoadIdentity();
+         * gl.glFrustumf(-ratio, ratio, -1, 1, 1, 10);
+         * }
+         * </pre>
+         *
+         * @param gl the GL interface. Use <code>instanceof</code> to
+         *           test if the interface supports GL11 or higher interfaces.
+         */
+        void onSurfaceChanged(GL10 gl, int width, int height);
+
+        /**
+         * Called to draw the current frame.
+         * <p>
+         * This method is responsible for drawing the current frame.
+         * <p>
+         * The implementation of this method typically looks like this:
+         * <pre class="prettyprint">
+         * void onDrawFrame(GL10 gl) {
+         * gl.glClear(GL10.GL_COLOR_BUFFER_BIT | GL10.GL_DEPTH_BUFFER_BIT);
+         * //... other gl calls to render the scene ...
+         * }
+         * </pre>
+         *
+         * @param gl the GL interface. Use <code>instanceof</code> to
+         *           test if the interface supports GL11 or higher interfaces.
+         */
+        void onDrawFrame(GL10 gl);
+    }
+
+    /**
+     * An interface for customizing the eglCreateContext and eglDestroyContext calls.
+     * <p>
+     * This interface must be implemented by clients wishing to call
+     * {@link GLTextureView#setEGLContextFactory(EGLContextFactory)}
+     */
+    public interface EGLContextFactory {
+        EGLContext createContext(EGL10 egl, EGLDisplay display, EGLConfig eglConfig);
+
+        void destroyContext(EGL10 egl, EGLDisplay display, EGLContext context);
+    }
+
+    private class DefaultContextFactory implements EGLContextFactory {
+        private int EGL_CONTEXT_CLIENT_VERSION = 0x3098;
+
+        public EGLContext createContext(EGL10 egl, EGLDisplay display, EGLConfig config) {
+            int[] attrib_list = {
+                    EGL_CONTEXT_CLIENT_VERSION, eglContextClientVersion, EGL10.EGL_NONE
+            };
+
+            return egl.eglCreateContext(display, config, EGL10.EGL_NO_CONTEXT,
+                    eglContextClientVersion != 0 ? attrib_list : null);
+        }
+
+        public void destroyContext(EGL10 egl, EGLDisplay display, EGLContext context) {
+            if (!egl.eglDestroyContext(display, context)) {
+                Log.e("DefaultContextFactory", "display:" + display + " context: " + context);
+                if (LOG_THREADS) {
+                    Log.i("DefaultContextFactory", "tid=" + Thread.currentThread().getId());
+                }
+                EglHelper.throwEglException("eglDestroyContex", egl.eglGetError());
+            }
+        }
+    }
+
+    /**
+     * An interface for customizing the eglCreateWindowSurface and eglDestroySurface calls.
+     * <p>
+     * This interface must be implemented by clients wishing to call
+     * {@link GLTextureView#setEGLWindowSurfaceFactory(EGLWindowSurfaceFactory)}
+     */
+    public interface EGLWindowSurfaceFactory {
+        /**
+         * @return null if the surface cannot be constructed.
+         */
+        EGLSurface createWindowSurface(EGL10 egl, EGLDisplay display, EGLConfig config,
+                                       Object nativeWindow);
+
+        void destroySurface(EGL10 egl, EGLDisplay display, EGLSurface surface);
+    }
+
+    private static class DefaultWindowSurfaceFactory implements EGLWindowSurfaceFactory {
+
+        public EGLSurface createWindowSurface(EGL10 egl, EGLDisplay display, EGLConfig config,
+                                              Object nativeWindow) {
+            EGLSurface result = null;
+            try {
+                result = egl.eglCreateWindowSurface(display, config, nativeWindow, null);
+            } catch (IllegalArgumentException e) {
+                // This exception indicates that the surface flinger surface
+                // is not valid. This can happen if the surface flinger surface has
+                // been torn down, but the application has not yet been
+                // notified via SurfaceHolder.Callback.surfaceDestroyed.
+                // In theory the application should be notified first,
+                // but in practice sometimes it is not. See b/4588890
+                Log.e(TAG, "eglCreateWindowSurface", e);
+            }
+            return result;
+        }
+
+        public void destroySurface(EGL10 egl, EGLDisplay display, EGLSurface surface) {
+            egl.eglDestroySurface(display, surface);
+        }
+    }
+
+    /**
+     * An interface for choosing an EGLConfig configuration from a list of
+     * potential configurations.
+     * <p>
+     * This interface must be implemented by clients wishing to call
+     * {@link GLTextureView#setEGLConfigChooser(EGLConfigChooser)}
+     */
+    public interface EGLConfigChooser {
+        /**
+         * Choose a configuration from the list. Implementors typically
+         * implement this method by calling
+         * {@link EGL10#eglChooseConfig} and iterating through the results. Please consult the
+         * EGL specification available from The Khronos Group to learn how to call eglChooseConfig.
+         *
+         * @param egl     the EGL10 for the current display.
+         * @param display the current display.
+         * @return the chosen configuration.
+         */
+        EGLConfig chooseConfig(EGL10 egl, EGLDisplay display);
+    }
+
+    private abstract class BaseConfigChooser implements EGLConfigChooser {
+        public BaseConfigChooser(int[] configSpec) {
+            mConfigSpec = filterConfigSpec(configSpec);
+        }
+
+        public EGLConfig chooseConfig(EGL10 egl, EGLDisplay display) {
+            int[] num_config = new int[1];
+            if (!egl.eglChooseConfig(display, mConfigSpec, null, 0, num_config)) {
+                throw new IllegalArgumentException("eglChooseConfig failed");
+            }
+
+            int numConfigs = num_config[0];
+
+            if (numConfigs <= 0) {
+                throw new IllegalArgumentException("No configs match configSpec");
+            }
+
+            EGLConfig[] configs = new EGLConfig[numConfigs];
+            if (!egl.eglChooseConfig(display, mConfigSpec, configs, numConfigs, num_config)) {
+                throw new IllegalArgumentException("eglChooseConfig#2 failed");
+            }
+            EGLConfig config = chooseConfig(egl, display, configs);
+            if (config == null) {
+                throw new IllegalArgumentException("No config chosen");
+            }
+            return config;
+        }
+
+        abstract EGLConfig chooseConfig(EGL10 egl, EGLDisplay display, EGLConfig[] configs);
+
+        protected int[] mConfigSpec;
+
+        private int[] filterConfigSpec(int[] configSpec) {
+            if (eglContextClientVersion != 2) {
+                return configSpec;
+            }
+            /* We know none of the subclasses define EGL_RENDERABLE_TYPE.
+             * And we know the configSpec is well formed.
+             */
+            int len = configSpec.length;
+            int[] newConfigSpec = new int[len + 2];
+            System.arraycopy(configSpec, 0, newConfigSpec, 0, len - 1);
+            newConfigSpec[len - 1] = EGL10.EGL_RENDERABLE_TYPE;
+            newConfigSpec[len] = 0x0004; /* EGL_OPENGL_ES2_BIT */
+            newConfigSpec[len + 1] = EGL10.EGL_NONE;
+            return newConfigSpec;
+        }
+    }
+
+    /**
+     * Choose a configuration with exactly the specified r,g,b,a sizes,
+     * and at least the specified depth and stencil sizes.
+     */
+    private class ComponentSizeChooser extends BaseConfigChooser {
+        public ComponentSizeChooser(int redSize, int greenSize, int blueSize, int alphaSize,
+                                    int depthSize, int stencilSize) {
+            super(new int[]{
+                    EGL10.EGL_RED_SIZE, redSize, EGL10.EGL_GREEN_SIZE, greenSize, EGL10.EGL_BLUE_SIZE,
+                    blueSize, EGL10.EGL_ALPHA_SIZE, alphaSize, EGL10.EGL_DEPTH_SIZE, depthSize,
+                    EGL10.EGL_STENCIL_SIZE, stencilSize, EGL10.EGL_NONE
+            });
+            value = new int[1];
+            this.redSize = redSize;
+            this.greenSize = greenSize;
+            this.blueSize = blueSize;
+            this.alphaSize = alphaSize;
+            this.depthSize = depthSize;
+            this.stencilSize = stencilSize;
+        }
+
+        @Override
+        public EGLConfig chooseConfig(EGL10 egl, EGLDisplay display, EGLConfig[] configs) {
+            for (EGLConfig config : configs) {
+                int d = findConfigAttrib(egl, display, config, EGL10.EGL_DEPTH_SIZE, 0);
+                int s = findConfigAttrib(egl, display, config, EGL10.EGL_STENCIL_SIZE, 0);
+                if ((d >= depthSize) && (s >= stencilSize)) {
+                    int r = findConfigAttrib(egl, display, config, EGL10.EGL_RED_SIZE, 0);
+                    int g = findConfigAttrib(egl, display, config, EGL10.EGL_GREEN_SIZE, 0);
+                    int b = findConfigAttrib(egl, display, config, EGL10.EGL_BLUE_SIZE, 0);
+                    int a = findConfigAttrib(egl, display, config, EGL10.EGL_ALPHA_SIZE, 0);
+                    if ((r == redSize) && (g == greenSize) && (b == blueSize) && (a == alphaSize)) {
+                        return config;
+                    }
+                }
+            }
+            return null;
+        }
+
+        private int findConfigAttrib(EGL10 egl, EGLDisplay display, EGLConfig config, int attribute,
+                                     int defaultValue) {
+
+            if (egl.eglGetConfigAttrib(display, config, attribute, value)) {
+                return value[0];
+            }
+            return defaultValue;
+        }
+
+        private int[] value;
+        // Subclasses can adjust these values:
+        protected int redSize;
+        protected int greenSize;
+        protected int blueSize;
+        protected int alphaSize;
+        protected int depthSize;
+        protected int stencilSize;
+    }
+
+    /**
+     * This class will choose a RGB_888 surface with
+     * or without a depth buffer.
+     */
+    private class SimpleEGLConfigChooser extends ComponentSizeChooser {
+        public SimpleEGLConfigChooser(boolean withDepthBuffer) {
+            super(8, 8, 8, 0, withDepthBuffer ? 16 : 0, 0);
+        }
+    }
+
+    /**
+     * An EGL helper class.
+     */
+
+    private static class EglHelper {
+        public EglHelper(WeakReference<GLTextureView> glTextureViewWeakReference) {
+            this.glTextureViewWeakRef = glTextureViewWeakReference;
+        }
+
+        /**
+         * Initialize EGL for a given configuration spec.
+         */
+        public void start() {
+            if (LOG_EGL) {
+                Log.w("EglHelper", "start() tid=" + Thread.currentThread().getId());
+            }
+            /*
+             * Get an EGL instance
+             */
+            egl = (EGL10) EGLContext.getEGL();
+
+            /*
+             * Get to the default display.
+             */
+            eglDisplay = egl.eglGetDisplay(EGL10.EGL_DEFAULT_DISPLAY);
+
+            if (eglDisplay == EGL10.EGL_NO_DISPLAY) {
+                throw new RuntimeException("eglGetDisplay failed");
+            }
+
+            /*
+             * We can now initialize EGL for that display
+             */
+            int[] version = new int[2];
+            if (!egl.eglInitialize(eglDisplay, version)) {
+                throw new RuntimeException("eglInitialize failed");
+            }
+            GLTextureView view = glTextureViewWeakRef.get();
+            if (view == null) {
+                eglConfig = null;
+                eglContext = null;
+            } else {
+                eglConfig = view.eglConfigChooser.chooseConfig(egl, eglDisplay);
+
+                /*
+                 * Create an EGL context. We want to do this as rarely as we can, because an
+                 * EGL context is a somewhat heavy object.
+                 */
+                eglContext = view.eglContextFactory.createContext(egl, eglDisplay, eglConfig);
+            }
+            if (eglContext == null || eglContext == EGL10.EGL_NO_CONTEXT) {
+                eglContext = null;
+                throwEglException("createContext");
+            }
+            if (LOG_EGL) {
+                Log.w("EglHelper",
+                        "createContext " + eglContext + " tid=" + Thread.currentThread().getId());
+            }
+
+            eglSurface = null;
+        }
+
+        /**
+         * Create an egl surface for the current SurfaceHolder surface. If a surface
+         * already exists, destroy it before creating the new surface.
+         *
+         * @return true if the surface was created successfully.
+         */
+        public boolean createSurface() {
+            if (LOG_EGL) {
+                Log.w("EglHelper", "createSurface()  tid=" + Thread.currentThread().getId());
+            }
+            /*
+             * Check preconditions.
+             */
+            if (egl == null) {
+                throw new RuntimeException("egl not initialized");
+            }
+            if (eglDisplay == null) {
+                throw new RuntimeException("eglDisplay not initialized");
+            }
+            if (eglConfig == null) {
+                throw new RuntimeException("eglConfig not initialized");
+            }
+
+            /*
+             *  The window size has changed, so we need to create a new
+             *  surface.
+             */
+            destroySurfaceImp();
+
+            /*
+             * Create an EGL surface we can render into.
+             */
+            GLTextureView view = glTextureViewWeakRef.get();
+            if (view != null) {
+                eglSurface = view.eglWindowSurfaceFactory.createWindowSurface(egl, eglDisplay, eglConfig,
+                        view.getSurfaceTexture());
+            } else {
+                eglSurface = null;
+            }
+
+            if (eglSurface == null || eglSurface == EGL10.EGL_NO_SURFACE) {
+                int error = egl.eglGetError();
+                if (error == EGL10.EGL_BAD_NATIVE_WINDOW) {
+                    Log.e("EglHelper", "createWindowSurface returned EGL_BAD_NATIVE_WINDOW.");
+                }
+                return false;
+            }
+
+            /*
+             * Before we can issue GL commands, we need to make sure
+             * the context is current and bound to a surface.
+             */
+            if (!egl.eglMakeCurrent(eglDisplay, eglSurface, eglSurface, eglContext)) {
+                /*
+                 * Could not make the context current, probably because the underlying
+                 * TextureView surface has been destroyed.
+                 */
+                logEglErrorAsWarning("EGLHelper", "eglMakeCurrent", egl.eglGetError());
+                return false;
+            }
+
+            return true;
+        }
+
+        /**
+         * Create a GL object for the current EGL context.
+         */
+        GL createGL() {
+
+            GL gl = eglContext.getGL();
+            GLTextureView view = glTextureViewWeakRef.get();
+            if (view != null) {
+                if (view.glWrapper != null) {
+                    gl = view.glWrapper.wrap(gl);
+                }
+
+                if ((view.debugFlags & (DEBUG_CHECK_GL_ERROR | DEBUG_LOG_GL_CALLS)) != 0) {
+                    int configFlags = 0;
+                    Writer log = null;
+                    if ((view.debugFlags & DEBUG_CHECK_GL_ERROR) != 0) {
+                        configFlags |= GLDebugHelper.CONFIG_CHECK_GL_ERROR;
+                    }
+                    if ((view.debugFlags & DEBUG_LOG_GL_CALLS) != 0) {
+                        log = new LogWriter();
+                    }
+                    gl = GLDebugHelper.wrap(gl, configFlags, log);
+                }
+            }
+            return gl;
+        }
+
+        /**
+         * Display the current render surface.
+         *
+         * @return the EGL error code from eglSwapBuffers.
+         */
+        public int swap() {
+            if (!egl.eglSwapBuffers(eglDisplay, eglSurface)) {
+                return egl.eglGetError();
+            }
+            return EGL10.EGL_SUCCESS;
+        }
+
+        public void destroySurface() {
+            if (LOG_EGL) {
+                Log.w("EglHelper", "destroySurface()  tid=" + Thread.currentThread().getId());
+            }
+            destroySurfaceImp();
+        }
+
+        private void destroySurfaceImp() {
+            if (eglSurface != null && eglSurface != EGL10.EGL_NO_SURFACE) {
+                egl.eglMakeCurrent(eglDisplay, EGL10.EGL_NO_SURFACE, EGL10.EGL_NO_SURFACE,
+                        EGL10.EGL_NO_CONTEXT);
+                GLTextureView view = glTextureViewWeakRef.get();
+                if (view != null) {
+                    view.eglWindowSurfaceFactory.destroySurface(egl, eglDisplay, eglSurface);
+                }
+                eglSurface = null;
+            }
+        }
+
+        public void finish() {
+            if (LOG_EGL) {
+                Log.w("EglHelper", "finish() tid=" + Thread.currentThread().getId());
+            }
+            if (eglContext != null) {
+                GLTextureView view = glTextureViewWeakRef.get();
+                if (view != null) {
+                    view.eglContextFactory.destroyContext(egl, eglDisplay, eglContext);
+                }
+                eglContext = null;
+            }
+            if (eglDisplay != null) {
+                egl.eglTerminate(eglDisplay);
+                eglDisplay = null;
+            }
+        }
+
+        private void throwEglException(String function) {
+            throwEglException(function, egl.eglGetError());
+        }
+
+        public static void throwEglException(String function, int error) {
+            String message = formatEglError(function, error);
+            if (LOG_THREADS) {
+                Log.e("EglHelper",
+                        "throwEglException tid=" + Thread.currentThread().getId() + " " + message);
+            }
+            throw new RuntimeException(message);
+        }
+
+        public static void logEglErrorAsWarning(String tag, String function, int error) {
+            Log.w(tag, formatEglError(function, error));
+        }
+
+        public static String formatEglError(String function, int error) {
+            return function + " failed: " + error;
+        }
+
+        private WeakReference<GLTextureView> glTextureViewWeakRef;
+        EGL10 egl;
+        EGLDisplay eglDisplay;
+        EGLSurface eglSurface;
+        EGLConfig eglConfig;
+        EGLContext eglContext;
+    }
+
+    /**
+     * A generic GL Thread. Takes care of initializing EGL and GL. Delegates
+     * to a Renderer instance to do the actual drawing. Can be configured to
+     * render continuously or on request.
+     * <p>
+     * All potentially blocking synchronization is done through the
+     * glThreadManager object. This avoids multiple-lock ordering issues.
+     */
+    static class GLThread extends Thread {
+        GLThread(WeakReference<GLTextureView> glTextureViewWeakRef) {
+            super();
+            width = 0;
+            height = 0;
+            requestRender = true;
+            renderMode = RENDERMODE_CONTINUOUSLY;
+            this.glTextureViewWeakRef = glTextureViewWeakRef;
+        }
+
+        @Override
+        public void run() {
+            setName("GLThread " + getId());
+            if (LOG_THREADS) {
+                Log.i("GLThread", "starting tid=" + getId());
+            }
+
+            try {
+                guardedRun();
+            } catch (InterruptedException e) {
+                // fall thru and exit normally
+            } finally {
+                glThreadManager.threadExiting(this);
+            }
+        }
+
+        /*
+         * This private method should only be called inside a
+         * synchronized(glThreadManager) block.
+         */
+        private void stopEglSurfaceLocked() {
+            if (haveEglSurface) {
+                haveEglSurface = false;
+                eglHelper.destroySurface();
+            }
+        }
+
+        /*
+         * This private method should only be called inside a
+         * synchronized(glThreadManager) block.
+         */
+        private void stopEglContextLocked() {
+            if (haveEglContext) {
+                eglHelper.finish();
+                haveEglContext = false;
+                glThreadManager.releaseEglContextLocked(this);
+            }
+        }
+
+        private void guardedRun() throws InterruptedException {
+            eglHelper = new EglHelper(glTextureViewWeakRef);
+            haveEglContext = false;
+            haveEglSurface = false;
+            try {
+                GL10 gl = null;
+                boolean createEglContext = false;
+                boolean createEglSurface = false;
+                boolean createGlInterface = false;
+                boolean lostEglContext = false;
+                boolean sizeChanged = false;
+                boolean wantRenderNotification = false;
+                boolean doRenderNotification = false;
+                boolean askedToReleaseEglContext = false;
+                int w = 0;
+                int h = 0;
+                Runnable event = null;
+
+                while (true) {
+                    synchronized (glThreadManager) {
+                        while (true) {
+                            if (shouldExit) {
+                                return;
+                            }
+
+                            if (!eventQueue.isEmpty()) {
+                                event = eventQueue.remove(0);
+                                break;
+                            }
+
+                            // Update the pause state.
+                            boolean pausing = false;
+                            if (paused != requestPaused) {
+                                pausing = requestPaused;
+                                paused = requestPaused;
+                                glThreadManager.notifyAll();
+                                if (LOG_PAUSE_RESUME) {
+                                    Log.i("GLThread", "paused is now " + paused + " tid=" + getId());
+                                }
+                            }
+
+                            // Do we need to give up the EGL context?
+                            if (shouldReleaseEglContext) {
+                                if (LOG_SURFACE) {
+                                    Log.i("GLThread", "releasing EGL context because asked to tid=" + getId());
+                                }
+                                stopEglSurfaceLocked();
+                                stopEglContextLocked();
+                                shouldReleaseEglContext = false;
+                                askedToReleaseEglContext = true;
+                            }
+
+                            // Have we lost the EGL context?
+                            if (lostEglContext) {
+                                stopEglSurfaceLocked();
+                                stopEglContextLocked();
+                                lostEglContext = false;
+                            }
+
+                            // When pausing, release the EGL surface:
+                            if (pausing && haveEglSurface) {
+                                if (LOG_SURFACE) {
+                                    Log.i("GLThread", "releasing EGL surface because paused tid=" + getId());
+                                }
+                                stopEglSurfaceLocked();
+                            }
+
+                            // When pausing, optionally release the EGL Context:
+                            if (pausing && haveEglContext) {
+                                GLTextureView view = glTextureViewWeakRef.get();
+                                boolean preserveEglContextOnPause =
+                                        view == null ? false : view.preserveEGLContextOnPause;
+                                if (!preserveEglContextOnPause
+                                        || glThreadManager.shouldReleaseEGLContextWhenPausing()) {
+                                    stopEglContextLocked();
+                                    if (LOG_SURFACE) {
+                                        Log.i("GLThread", "releasing EGL context because paused tid=" + getId());
+                                    }
+                                }
+                            }
+
+                            // When pausing, optionally terminate EGL:
+                            if (pausing) {
+                                if (glThreadManager.shouldTerminateEGLWhenPausing()) {
+                                    eglHelper.finish();
+                                    if (LOG_SURFACE) {
+                                        Log.i("GLThread", "terminating EGL because paused tid=" + getId());
+                                    }
+                                }
+                            }
+
+                            // Have we lost the TextureView surface?
+                            if ((!hasSurface) && (!waitingForSurface)) {
+                                if (LOG_SURFACE) {
+                                    Log.i("GLThread", "noticed textureView surface lost tid=" + getId());
+                                }
+                                if (haveEglSurface) {
+                                    stopEglSurfaceLocked();
+                                }
+                                waitingForSurface = true;
+                                surfaceIsBad = false;
+                                glThreadManager.notifyAll();
+                            }
+
+                            // Have we acquired the surface view surface?
+                            if (hasSurface && waitingForSurface) {
+                                if (LOG_SURFACE) {
+                                    Log.i("GLThread", "noticed textureView surface acquired tid=" + getId());
+                                }
+                                waitingForSurface = false;
+                                glThreadManager.notifyAll();
+                            }
+
+                            if (doRenderNotification) {
+                                if (LOG_SURFACE) {
+                                    Log.i("GLThread", "sending render notification tid=" + getId());
+                                }
+                                wantRenderNotification = false;
+                                doRenderNotification = false;
+                                renderComplete = true;
+                                glThreadManager.notifyAll();
+                            }
+
+                            // Ready to draw?
+                            if (readyToDraw()) {
+
+                                // If we don't have an EGL context, try to acquire one.
+                                if (!haveEglContext) {
+                                    if (askedToReleaseEglContext) {
+                                        askedToReleaseEglContext = false;
+                                    } else if (glThreadManager.tryAcquireEglContextLocked(this)) {
+                                        try {
+                                            eglHelper.start();
+                                        } catch (RuntimeException t) {
+                                            glThreadManager.releaseEglContextLocked(this);
+                                            throw t;
+                                        }
+                                        haveEglContext = true;
+                                        createEglContext = true;
+
+                                        glThreadManager.notifyAll();
+                                    }
+                                }
+
+                                if (haveEglContext && !haveEglSurface) {
+                                    haveEglSurface = true;
+                                    createEglSurface = true;
+                                    createGlInterface = true;
+                                    sizeChanged = true;
+                                }
+
+                                if (haveEglSurface) {
+                                    if (this.sizeChanged) {
+                                        sizeChanged = true;
+                                        w = width;
+                                        h = height;
+                                        wantRenderNotification = true;
+                                        if (LOG_SURFACE) {
+                                            Log.i("GLThread", "noticing that we want render notification tid=" + getId());
+                                        }
+
+                                        // Destroy and recreate the EGL surface.
+                                        createEglSurface = true;
+
+                                        this.sizeChanged = false;
+                                    }
+                                    requestRender = false;
+                                    glThreadManager.notifyAll();
+                                    break;
+                                }
+                            }
+
+                            // By design, this is the only place in a GLThread thread where we wait().
+                            if (LOG_THREADS) {
+                                Log.i("GLThread", "waiting tid=" + getId() + " haveEglContext: " + haveEglContext
+                                        + " haveEglSurface: " + haveEglSurface + " paused: " + paused + " hasSurface: "
+                                        + hasSurface + " surfaceIsBad: " + surfaceIsBad + " waitingForSurface: "
+                                        + waitingForSurface + " width: " + width + " height: " + height
+                                        + " requestRender: " + requestRender + " renderMode: " + renderMode);
+                            }
+                            glThreadManager.wait();
+                        }
+                    } // end of synchronized(glThreadManager)
+
+                    if (event != null) {
+                        event.run();
+                        event = null;
+                        continue;
+                    }
+
+                    if (createEglSurface) {
+                        if (LOG_SURFACE) {
+                            Log.w("GLThread", "egl createSurface");
+                        }
+                        if (!eglHelper.createSurface()) {
+                            synchronized (glThreadManager) {
+                                surfaceIsBad = true;
+                                glThreadManager.notifyAll();
+                            }
+                            continue;
+                        }
+                        createEglSurface = false;
+                    }
+
+                    if (createGlInterface) {
+                        gl = (GL10) eglHelper.createGL();
+
+                        glThreadManager.checkGLDriver(gl);
+                        createGlInterface = false;
+                    }
+
+                    if (createEglContext) {
+                        if (LOG_RENDERER) {
+                            Log.w("GLThread", "onSurfaceCreated");
+                        }
+                        GLTextureView view = glTextureViewWeakRef.get();
+                        if (view != null) {
+                            view.renderer.onSurfaceCreated(gl, eglHelper.eglConfig);
+                        }
+                        createEglContext = false;
+                    }
+
+                    if (sizeChanged) {
+                        if (LOG_RENDERER) {
+                            Log.w("GLThread", "onSurfaceChanged(" + w + ", " + h + ")");
+                        }
+                        GLTextureView view = glTextureViewWeakRef.get();
+                        if (view != null) {
+                            view.renderer.onSurfaceChanged(gl, w, h);
+                        }
+                        sizeChanged = false;
+                    }
+
+                    if (LOG_RENDERER_DRAW_FRAME) {
+                        Log.w("GLThread", "onDrawFrame tid=" + getId());
+                    }
+                    {
+                        GLTextureView view = glTextureViewWeakRef.get();
+                        if (view != null) {
+                            view.renderer.onDrawFrame(gl);
+                        }
+                    }
+                    int swapError = eglHelper.swap();
+                    switch (swapError) {
+                        case EGL10.EGL_SUCCESS:
+                            break;
+                        case EGL11.EGL_CONTEXT_LOST:
+                            if (LOG_SURFACE) {
+                                Log.i("GLThread", "egl context lost tid=" + getId());
+                            }
+                            lostEglContext = true;
+                            break;
+                        default:
+                            // Other errors typically mean that the current surface is bad,
+                            // probably because the TextureView surface has been destroyed,
+                            // but we haven't been notified yet.
+                            // Log the error to help developers understand why rendering stopped.
+                            EglHelper.logEglErrorAsWarning("GLThread", "eglSwapBuffers", swapError);
+
+                            synchronized (glThreadManager) {
+                                surfaceIsBad = true;
+                                glThreadManager.notifyAll();
+                            }
+                            break;
+                    }
+
+                    if (wantRenderNotification) {
+                        doRenderNotification = true;
+                    }
+                }
+            } finally {
+                /*
+                 * clean-up everything...
+                 */
+                synchronized (glThreadManager) {
+                    stopEglSurfaceLocked();
+                    stopEglContextLocked();
+                }
+            }
+        }
+
+        public boolean ableToDraw() {
+            return haveEglContext && haveEglSurface && readyToDraw();
+        }
+
+        private boolean readyToDraw() {
+            return (!paused) && hasSurface && (!surfaceIsBad) && (width > 0) && (height > 0) && (
+                    requestRender || (renderMode == RENDERMODE_CONTINUOUSLY));
+        }
+
+        public void setRenderMode(int renderMode) {
+            if (!((RENDERMODE_WHEN_DIRTY <= renderMode) && (renderMode <= RENDERMODE_CONTINUOUSLY))) {
+                throw new IllegalArgumentException("renderMode");
+            }
+            synchronized (glThreadManager) {
+                this.renderMode = renderMode;
+                glThreadManager.notifyAll();
+            }
+        }
+
+        public int getRenderMode() {
+            synchronized (glThreadManager) {
+                return renderMode;
+            }
+        }
+
+        public void requestRender() {
+            synchronized (glThreadManager) {
+                requestRender = true;
+                glThreadManager.notifyAll();
+            }
+        }
+
+        public void surfaceCreated() {
+            synchronized (glThreadManager) {
+                if (LOG_THREADS) {
+                    Log.i("GLThread", "surfaceCreated tid=" + getId());
+                }
+                hasSurface = true;
+                glThreadManager.notifyAll();
+                while ((waitingForSurface) && (!exited)) {
+                    try {
+                        glThreadManager.wait();
+                    } catch (InterruptedException e) {
+                        Thread.currentThread().interrupt();
+                    }
+                }
+            }
+        }
+
+        public void surfaceDestroyed() {
+            synchronized (glThreadManager) {
+                if (LOG_THREADS) {
+                    Log.i("GLThread", "surfaceDestroyed tid=" + getId());
+                }
+                hasSurface = false;
+                glThreadManager.notifyAll();
+                while ((!waitingForSurface) && (!exited)) {
+                    try {
+                        glThreadManager.wait();
+                    } catch (InterruptedException e) {
+                        Thread.currentThread().interrupt();
+                    }
+                }
+            }
+        }
+
+        public void onPause() {
+            synchronized (glThreadManager) {
+                if (LOG_PAUSE_RESUME) {
+                    Log.i("GLThread", "onPause tid=" + getId());
+                }
+                requestPaused = true;
+                glThreadManager.notifyAll();
+                while ((!exited) && (!paused)) {
+                    if (LOG_PAUSE_RESUME) {
+                        Log.i("Main thread", "onPause waiting for paused.");
+                    }
+                    try {
+                        glThreadManager.wait();
+                    } catch (InterruptedException ex) {
+                        Thread.currentThread().interrupt();
+                    }
+                }
+            }
+        }
+
+        public void onResume() {
+            synchronized (glThreadManager) {
+                if (LOG_PAUSE_RESUME) {
+                    Log.i("GLThread", "onResume tid=" + getId());
+                }
+                requestPaused = false;
+                requestRender = true;
+                renderComplete = false;
+                glThreadManager.notifyAll();
+                while ((!exited) && paused && (!renderComplete)) {
+                    if (LOG_PAUSE_RESUME) {
+                        Log.i("Main thread", "onResume waiting for !paused.");
+                    }
+                    try {
+                        glThreadManager.wait();
+                    } catch (InterruptedException ex) {
+                        Thread.currentThread().interrupt();
+                    }
+                }
+            }
+        }
+
+        public void onWindowResize(int w, int h) {
+            synchronized (glThreadManager) {
+                width = w;
+                height = h;
+                sizeChanged = true;
+                requestRender = true;
+                renderComplete = false;
+                glThreadManager.notifyAll();
+
+                // Wait for thread to react to resize and render a frame
+                while (!exited && !paused && !renderComplete && ableToDraw()) {
+                    if (LOG_SURFACE) {
+                        Log.i("Main thread", "onWindowResize waiting for render complete from tid=" + getId());
+                    }
+                    try {
+                        glThreadManager.wait();
+                    } catch (InterruptedException ex) {
+                        Thread.currentThread().interrupt();
+                    }
+                }
+            }
+        }
+
+        public void requestExitAndWait() {
+            // don't call this from GLThread thread or it is a guaranteed
+            // deadlock!
+            synchronized (glThreadManager) {
+                shouldExit = true;
+                glThreadManager.notifyAll();
+                while (!exited) {
+                    try {
+                        glThreadManager.wait();
+                    } catch (InterruptedException ex) {
+                        Thread.currentThread().interrupt();
+                    }
+                }
+            }
+        }
+
+        public void requestReleaseEglContextLocked() {
+            shouldReleaseEglContext = true;
+            glThreadManager.notifyAll();
+        }
+
+        /**
+         * Queue an "event" to be run on the GL rendering thread.
+         *
+         * @param r the runnable to be run on the GL rendering thread.
+         */
+        public void queueEvent(Runnable r) {
+            if (r == null) {
+                throw new IllegalArgumentException("r must not be null");
+            }
+            synchronized (glThreadManager) {
+                eventQueue.add(r);
+                glThreadManager.notifyAll();
+            }
+        }
+
+        // Once the thread is started, all accesses to the following member
+        // variables are protected by the glThreadManager monitor
+        private boolean shouldExit;
+        private boolean exited;
+        private boolean requestPaused;
+        private boolean paused;
+        private boolean hasSurface;
+        private boolean surfaceIsBad;
+        private boolean waitingForSurface;
+        private boolean haveEglContext;
+        private boolean haveEglSurface;
+        private boolean shouldReleaseEglContext;
+        private int width;
+        private int height;
+        private int renderMode;
+        private boolean requestRender;
+        private boolean renderComplete;
+        private ArrayList<Runnable> eventQueue = new ArrayList<>();
+        private boolean sizeChanged = true;
+
+        // End of member variables protected by the glThreadManager monitor.
+
+        private EglHelper eglHelper;
+
+        /**
+         * Set once at thread construction time, nulled out when the parent view is garbage
+         * called. This weak reference allows the GLTextureView to be garbage collected while
+         * the GLThread is still alive.
+         */
+        private WeakReference<GLTextureView> glTextureViewWeakRef;
+    }
+
+    static class LogWriter extends Writer {
+
+        @Override
+        public void close() {
+            flushBuilder();
+        }
+
+        @Override
+        public void flush() {
+            flushBuilder();
+        }
+
+        @Override
+        public void write(char[] buf, int offset, int count) {
+            for (int i = 0; i < count; i++) {
+                char c = buf[offset + i];
+                if (c == '\n') {
+                    flushBuilder();
+                } else {
+                    builder.append(c);
+                }
+            }
+        }
+
+        private void flushBuilder() {
+            if (builder.length() > 0) {
+                Log.v("GLTextureView", builder.toString());
+                builder.delete(0, builder.length());
+            }
+        }
+
+        private StringBuilder builder = new StringBuilder();
+    }
+
+    private void checkRenderThreadState() {
+        if (glThread != null) {
+            throw new IllegalStateException("setRenderer has already been called for this instance.");
+        }
+    }
+
+    private static class GLThreadManager {
+        private static String TAG = "GLThreadManager";
+
+        public synchronized void threadExiting(GLThread thread) {
+            if (LOG_THREADS) {
+                Log.i("GLThread", "exiting tid=" + thread.getId());
+            }
+            thread.exited = true;
+            if (eglOwner == thread) {
+                eglOwner = null;
+            }
+            notifyAll();
+        }
+
+        /*
+         * Tries once to acquire the right to use an EGL
+         * context. Does not block. Requires that we are already
+         * in the glThreadManager monitor when this is called.
+         *
+         * @return true if the right to use an EGL context was acquired.
+         */
+        public boolean tryAcquireEglContextLocked(GLThread thread) {
+            if (eglOwner == thread || eglOwner == null) {
+                eglOwner = thread;
+                notifyAll();
+                return true;
+            }
+            checkGLESVersion();
+            if (multipleGLESContextsAllowed) {
+                return true;
+            }
+            // Notify the owning thread that it should release the context.
+            // TODO: implement a fairness policy. Currently
+            // if the owning thread is drawing continuously it will just
+            // reacquire the EGL context.
+            if (eglOwner != null) {
+                eglOwner.requestReleaseEglContextLocked();
+            }
+            return false;
+        }
+
+        /*
+         * Releases the EGL context. Requires that we are already in the
+         * glThreadManager monitor when this is called.
+         */
+        public void releaseEglContextLocked(GLThread thread) {
+            if (eglOwner == thread) {
+                eglOwner = null;
+            }
+            notifyAll();
+        }
+
+        public synchronized boolean shouldReleaseEGLContextWhenPausing() {
+            // Release the EGL context when pausing even if
+            // the hardware supports multiple EGL contexts.
+            // Otherwise the device could run out of EGL contexts.
+            return limitedGLESContexts;
+        }
+
+        public synchronized boolean shouldTerminateEGLWhenPausing() {
+            checkGLESVersion();
+            return !multipleGLESContextsAllowed;
+        }
+
+        public synchronized void checkGLDriver(GL10 gl) {
+            if (!glesDriverCheckComplete) {
+                checkGLESVersion();
+                String renderer = gl.glGetString(GL10.GL_RENDERER);
+                if (glesVersion < kGLES_20) {
+                    multipleGLESContextsAllowed = !renderer.startsWith(kMSM7K_RENDERER_PREFIX);
+                    notifyAll();
+                }
+                limitedGLESContexts = !multipleGLESContextsAllowed;
+                if (LOG_SURFACE) {
+                    Log.w(TAG, "checkGLDriver renderer = \"" + renderer + "\" multipleContextsAllowed = "
+                            + multipleGLESContextsAllowed + " limitedGLESContexts = " + limitedGLESContexts);
+                }
+                glesDriverCheckComplete = true;
+            }
+        }
+
+        private void checkGLESVersion() {
+            if (!glesVersionCheckComplete) {
+                glesVersionCheckComplete = true;
+            }
+        }
+
+        /**
+         * This check was required for some pre-Android-3.0 hardware. Android 3.0 provides
+         * support for hardware-accelerated views, therefore multiple EGL contexts are
+         * supported on all Android 3.0+ EGL drivers.
+         */
+        private boolean glesVersionCheckComplete;
+        private int glesVersion;
+        private boolean glesDriverCheckComplete;
+        private boolean multipleGLESContextsAllowed;
+        private boolean limitedGLESContexts;
+        private static final int kGLES_20 = 0x20000;
+        private static final String kMSM7K_RENDERER_PREFIX = "Q3Dimension MSM7500 ";
+        private GLThread eglOwner;
+    }
+
+    private static final GLThreadManager glThreadManager = new GLThreadManager();
+
+    private final WeakReference<GLTextureView> mThisWeakRef = new WeakReference<>(this);
+    private GLThread glThread;
+    private Renderer renderer;
+    private boolean detached;
+    private EGLConfigChooser eglConfigChooser;
+    private EGLContextFactory eglContextFactory;
+    private EGLWindowSurfaceFactory eglWindowSurfaceFactory;
+    private GLWrapper glWrapper;
+    private int debugFlags;
+    private int eglContextClientVersion;
+    private boolean preserveEGLContextOnPause;
+    private List<SurfaceTextureListener> surfaceTextureListeners = new ArrayList<>();
+}
diff --git a/library/src/jp/co/cyberagent/android/gpuimage/GPUImage.java b/library/src/main/java/jp/co/cyberagent/android/gpuimage/GPUImage.java
similarity index 63%
rename from library/src/jp/co/cyberagent/android/gpuimage/GPUImage.java
rename to library/src/main/java/jp/co/cyberagent/android/gpuimage/GPUImage.java
index 8392a5a9..962451d3 100644
--- a/library/src/jp/co/cyberagent/android/gpuimage/GPUImage.java
+++ b/library/src/main/java/jp/co/cyberagent/android/gpuimage/GPUImage.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2012 CyberAgent
+ * Copyright (C) 2018 CyberAgent, Inc.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -16,7 +16,6 @@
 
 package jp.co.cyberagent.android.gpuimage;
 
-import android.annotation.TargetApi;
 import android.app.ActivityManager;
 import android.content.Context;
 import android.content.pm.ConfigurationInfo;
@@ -32,29 +31,42 @@
 import android.net.Uri;
 import android.opengl.GLSurfaceView;
 import android.os.AsyncTask;
-import android.os.Build;
 import android.os.Environment;
 import android.os.Handler;
 import android.provider.MediaStore;
 import android.view.Display;
 import android.view.WindowManager;
 
-import java.io.*;
+import java.io.File;
+import java.io.FileNotFoundException;
+import java.io.FileOutputStream;
+import java.io.IOException;
+import java.io.InputStream;
 import java.net.URL;
 import java.util.List;
-import java.util.concurrent.Semaphore;
+
+import jp.co.cyberagent.android.gpuimage.filter.GPUImageFilter;
+import jp.co.cyberagent.android.gpuimage.util.Rotation;
 
 /**
  * The main accessor for GPUImage functionality. This class helps to do common
  * tasks through a simple interface.
  */
 public class GPUImage {
-    private final Context mContext;
-    private final GPUImageRenderer mRenderer;
-    private GLSurfaceView mGlSurfaceView;
-    private GPUImageFilter mFilter;
-    private Bitmap mCurrentBitmap;
-    private ScaleType mScaleType = ScaleType.CENTER_CROP;
+
+    public enum ScaleType {CENTER_INSIDE, CENTER_CROP}
+
+    static final int SURFACE_TYPE_SURFACE_VIEW = 0;
+    static final int SURFACE_TYPE_TEXTURE_VIEW = 1;
+
+    private final Context context;
+    private final GPUImageRenderer renderer;
+    private int surfaceType = SURFACE_TYPE_SURFACE_VIEW;
+    private GLSurfaceView glSurfaceView;
+    private GLTextureView glTextureView;
+    private GPUImageFilter filter;
+    private Bitmap currentBitmap;
+    private ScaleType scaleType = ScaleType.CENTER_CROP;
 
     /**
      * Instantiates a new GPUImage object.
@@ -66,9 +78,9 @@ public GPUImage(final Context context) {
             throw new IllegalStateException("OpenGL ES 2.0 is not supported on this phone.");
         }
 
-        mContext = context;
-        mFilter = new GPUImageFilter();
-        mRenderer = new GPUImageRenderer(mFilter);
+        this.context = context;
+        filter = new GPUImageFilter();
+        renderer = new GPUImageRenderer(filter);
     }
 
     /**
@@ -91,61 +103,91 @@ private boolean supportsOpenGLES2(final Context context) {
      * @param view the GLSurfaceView
      */
     public void setGLSurfaceView(final GLSurfaceView view) {
-        mGlSurfaceView = view;
-        mGlSurfaceView.setEGLContextClientVersion(2);
-        mGlSurfaceView.setEGLConfigChooser(8, 8, 8, 8, 16, 0);
-        mGlSurfaceView.getHolder().setFormat(PixelFormat.RGBA_8888);
-        mGlSurfaceView.setRenderer(mRenderer);
-        mGlSurfaceView.setRenderMode(GLSurfaceView.RENDERMODE_WHEN_DIRTY);
-        mGlSurfaceView.requestRender();
+        surfaceType = SURFACE_TYPE_SURFACE_VIEW;
+        glSurfaceView = view;
+        glSurfaceView.setEGLContextClientVersion(2);
+        glSurfaceView.setEGLConfigChooser(8, 8, 8, 8, 16, 0);
+        glSurfaceView.getHolder().setFormat(PixelFormat.RGBA_8888);
+        glSurfaceView.setRenderer(renderer);
+        glSurfaceView.setRenderMode(GLSurfaceView.RENDERMODE_WHEN_DIRTY);
+        glSurfaceView.requestRender();
+    }
+
+    /**
+     * Sets the GLTextureView which will display the preview.
+     *
+     * @param view the GLTextureView
+     */
+    public void setGLTextureView(final GLTextureView view) {
+        surfaceType = SURFACE_TYPE_TEXTURE_VIEW;
+        glTextureView = view;
+        glTextureView.setEGLContextClientVersion(2);
+        glTextureView.setEGLConfigChooser(8, 8, 8, 8, 16, 0);
+        glTextureView.setOpaque(false);
+        glTextureView.setRenderer(renderer);
+        glTextureView.setRenderMode(GLSurfaceView.RENDERMODE_WHEN_DIRTY);
+        glTextureView.requestRender();
     }
 
     /**
      * Sets the background color
      *
-     * @param red red color value
+     * @param red   red color value
      * @param green green color value
-     * @param blue red color value
+     * @param blue  red color value
      */
     public void setBackgroundColor(float red, float green, float blue) {
-        mRenderer.setBackgroundColor(red, green, blue);
+        renderer.setBackgroundColor(red, green, blue);
     }
 
     /**
      * Request the preview to be rendered again.
      */
     public void requestRender() {
-        if (mGlSurfaceView != null) {
-            mGlSurfaceView.requestRender();
+        if (surfaceType == SURFACE_TYPE_SURFACE_VIEW) {
+            if (glSurfaceView != null) {
+                glSurfaceView.requestRender();
+            }
+        } else if (surfaceType == SURFACE_TYPE_TEXTURE_VIEW) {
+            if (glTextureView != null) {
+                glTextureView.requestRender();
+            }
         }
     }
 
     /**
+     * Deprecated: Please call
+     * {@link GPUImage#updatePreviewFrame(byte[], int, int)} frame by frame
+     * <p>
      * Sets the up camera to be connected to GPUImage to get a filtered preview.
      *
      * @param camera the camera
      */
+    @Deprecated
     public void setUpCamera(final Camera camera) {
         setUpCamera(camera, 0, false, false);
     }
 
     /**
+     * Deprecated: Please call
+     * {@link GPUImage#updatePreviewFrame(byte[], int, int)} frame by frame
+     * <p>
      * Sets the up camera to be connected to GPUImage to get a filtered preview.
      *
-     * @param camera the camera
-     * @param degrees by how many degrees the image should be rotated
+     * @param camera         the camera
+     * @param degrees        by how many degrees the image should be rotated
      * @param flipHorizontal if the image should be flipped horizontally
-     * @param flipVertical if the image should be flipped vertically
+     * @param flipVertical   if the image should be flipped vertically
      */
+    @Deprecated
     public void setUpCamera(final Camera camera, final int degrees, final boolean flipHorizontal,
-            final boolean flipVertical) {
-        mGlSurfaceView.setRenderMode(GLSurfaceView.RENDERMODE_CONTINUOUSLY);
-        if (Build.VERSION.SDK_INT > Build.VERSION_CODES.GINGERBREAD_MR1) {
-            setUpCameraGingerbread(camera);
-        } else {
-            camera.setPreviewCallback(mRenderer);
-            camera.startPreview();
+                            final boolean flipVertical) {
+        if (surfaceType == SURFACE_TYPE_SURFACE_VIEW) {
+            glSurfaceView.setRenderMode(GLSurfaceView.RENDERMODE_CONTINUOUSLY);
+        } else if (surfaceType == SURFACE_TYPE_TEXTURE_VIEW) {
+            glTextureView.setRenderMode(GLSurfaceView.RENDERMODE_CONTINUOUSLY);
         }
+        renderer.setUpSurfaceTexture(camera);
         Rotation rotation = Rotation.NORMAL;
         switch (degrees) {
             case 90:
@@ -158,12 +200,7 @@ public void setUpCamera(final Camera camera, final int degrees, final boolean fl
                 rotation = Rotation.ROTATION_270;
                 break;
         }
-        mRenderer.setRotationCamera(rotation, flipHorizontal, flipVertical);
-    }
-
-    @TargetApi(11)
-    private void setUpCameraGingerbread(final Camera camera) {
-        mRenderer.setUpSurfaceTexture(camera);
+        renderer.setRotationCamera(rotation, flipHorizontal, flipVertical);
     }
 
     /**
@@ -173,8 +210,8 @@ private void setUpCameraGingerbread(final Camera camera) {
      * @param filter the new filter
      */
     public void setFilter(final GPUImageFilter filter) {
-        mFilter = filter;
-        mRenderer.setFilter(mFilter);
+        this.filter = filter;
+        renderer.setFilter(this.filter);
         requestRender();
     }
 
@@ -184,11 +221,22 @@ public void setFilter(final GPUImageFilter filter) {
      * @param bitmap the new image
      */
     public void setImage(final Bitmap bitmap) {
-        mCurrentBitmap = bitmap;
-        mRenderer.setImageBitmap(bitmap, false);
+        currentBitmap = bitmap;
+        renderer.setImageBitmap(bitmap, false);
         requestRender();
     }
 
+    /**
+     * Update camera preview frame with YUV format data.
+     *
+     * @param data   Camera preview YUV data for frame.
+     * @param width  width of camera preview
+     * @param height height of camera preview
+     */
+    public void updatePreviewFrame(final byte[] data, final int width, final int height) {
+        renderer.onPreviewFrame(data, width, height);
+    }
+
     /**
      * This sets the scale type of GPUImage. This has to be run before setting the image.
      * If image is set and scale type changed, image needs to be reset.
@@ -196,10 +244,10 @@ public void setImage(final Bitmap bitmap) {
      * @param scaleType The new ScaleType
      */
     public void setScaleType(ScaleType scaleType) {
-        mScaleType = scaleType;
-        mRenderer.setScaleType(scaleType);
-        mRenderer.deleteImage();
-        mCurrentBitmap = null;
+        this.scaleType = scaleType;
+        renderer.setScaleType(scaleType);
+        renderer.deleteImage();
+        currentBitmap = null;
         requestRender();
     }
 
@@ -209,7 +257,7 @@ public void setScaleType(ScaleType scaleType) {
      * @param rotation new rotation
      */
     public void setRotation(Rotation rotation) {
-        mRenderer.setRotation(rotation);
+        renderer.setRotation(rotation);
     }
 
     /**
@@ -218,15 +266,15 @@ public void setRotation(Rotation rotation) {
      * @param rotation new rotation
      */
     public void setRotation(Rotation rotation, boolean flipHorizontal, boolean flipVertical) {
-        mRenderer.setRotation(rotation, flipHorizontal, flipVertical);
+        renderer.setRotation(rotation, flipHorizontal, flipVertical);
     }
 
     /**
      * Deletes the current image.
      */
     public void deleteImage() {
-        mRenderer.deleteImage();
-        mCurrentBitmap = null;
+        renderer.deleteImage();
+        currentBitmap = null;
         requestRender();
     }
 
@@ -252,11 +300,14 @@ private String getPath(final Uri uri) {
         String[] projection = {
                 MediaStore.Images.Media.DATA,
         };
-        Cursor cursor = mContext.getContentResolver()
+        Cursor cursor = context.getContentResolver()
                 .query(uri, projection, null, null, null);
-        int pathIndex = cursor.getColumnIndexOrThrow(MediaStore.Images.Media.DATA);
         String path = null;
+        if (cursor == null) {
+            return null;
+        }
         if (cursor.moveToFirst()) {
+            int pathIndex = cursor.getColumnIndexOrThrow(MediaStore.Images.Media.DATA);
             path = cursor.getString(pathIndex);
         }
         cursor.close();
@@ -269,7 +320,7 @@ private String getPath(final Uri uri) {
      * @return the current image with filter applied
      */
     public Bitmap getBitmapWithFilterApplied() {
-        return getBitmapWithFilterApplied(mCurrentBitmap);
+        return getBitmapWithFilterApplied(currentBitmap);
     }
 
     /**
@@ -279,43 +330,54 @@ public Bitmap getBitmapWithFilterApplied() {
      * @return the bitmap with filter applied
      */
     public Bitmap getBitmapWithFilterApplied(final Bitmap bitmap) {
-        if (mGlSurfaceView != null) {
-            mRenderer.deleteImage();
-            mRenderer.runOnDraw(new Runnable() {
+        return getBitmapWithFilterApplied(bitmap, false);
+    }
+
+    /**
+     * Gets the given bitmap with current filter applied as a Bitmap.
+     *
+     * @param bitmap  the bitmap on which the current filter should be applied
+     * @param recycle recycle the bitmap or not.
+     * @return the bitmap with filter applied
+     */
+    public Bitmap getBitmapWithFilterApplied(final Bitmap bitmap, boolean recycle) {
+        if (glSurfaceView != null || glTextureView != null) {
+            renderer.deleteImage();
+            renderer.runOnDraw(new Runnable() {
 
                 @Override
                 public void run() {
-                    synchronized(mFilter) {
-                        mFilter.destroy();
-                        mFilter.notify();
+                    synchronized (filter) {
+                        filter.destroy();
+                        filter.notify();
                     }
                 }
             });
-            synchronized(mFilter) {
+            synchronized (filter) {
                 requestRender();
                 try {
-                    mFilter.wait();
+                    filter.wait();
                 } catch (InterruptedException e) {
                     e.printStackTrace();
                 }
             }
         }
 
-        GPUImageRenderer renderer = new GPUImageRenderer(mFilter);
+        GPUImageRenderer renderer = new GPUImageRenderer(filter);
         renderer.setRotation(Rotation.NORMAL,
-                mRenderer.isFlippedHorizontally(), mRenderer.isFlippedVertically());
-        renderer.setScaleType(mScaleType);
+                this.renderer.isFlippedHorizontally(), this.renderer.isFlippedVertically());
+        renderer.setScaleType(scaleType);
         PixelBuffer buffer = new PixelBuffer(bitmap.getWidth(), bitmap.getHeight());
         buffer.setRenderer(renderer);
-        renderer.setImageBitmap(bitmap, false);
+        renderer.setImageBitmap(bitmap, recycle);
         Bitmap result = buffer.getBitmap();
-        mFilter.destroy();
+        filter.destroy();
         renderer.deleteImage();
         buffer.destroy();
 
-        mRenderer.setFilter(mFilter);
-        if (mCurrentBitmap != null) {
-            mRenderer.setImageBitmap(mCurrentBitmap, false);
+        this.renderer.setFilter(filter);
+        if (currentBitmap != null) {
+            this.renderer.setImageBitmap(currentBitmap, false);
         }
         requestRender();
 
@@ -329,12 +391,12 @@ public void run() {
      * bitmap. The order of the calls to the listener will be the same as the
      * filter order.
      *
-     * @param bitmap the bitmap on which the filters will be applied
-     * @param filters the filters which will be applied on the bitmap
+     * @param bitmap   the bitmap on which the filters will be applied
+     * @param filters  the filters which will be applied on the bitmap
      * @param listener the listener on which the results will be notified
      */
     public static void getBitmapForMultipleFilters(final Bitmap bitmap,
-            final List<GPUImageFilter> filters, final ResponseListener<Bitmap> listener) {
+                                                   final List<GPUImageFilter> filters, final ResponseListener<Bitmap> listener) {
         if (filters.isEmpty()) {
             return;
         }
@@ -353,9 +415,6 @@ public static void getBitmapForMultipleFilters(final Bitmap bitmap,
     }
 
     /**
-     * Deprecated: Please use
-     * {@link GPUImageView#saveToPictures(String, String, jp.co.cyberagent.android.gpuimage.GPUImageView.OnPictureSavedListener)}
-     *
      * Save current image with applied filter to Pictures. It will be stored on
      * the default Picture folder on the phone below the given folderName and
      * fileName. <br>
@@ -363,33 +422,28 @@ public static void getBitmapForMultipleFilters(final Bitmap bitmap,
      * listener.
      *
      * @param folderName the folder name
-     * @param fileName the file name
-     * @param listener the listener
+     * @param fileName   the file name
+     * @param listener   the listener
      */
-    @Deprecated
     public void saveToPictures(final String folderName, final String fileName,
-            final OnPictureSavedListener listener) {
-        saveToPictures(mCurrentBitmap, folderName, fileName, listener);
+                               final OnPictureSavedListener listener) {
+        saveToPictures(currentBitmap, folderName, fileName, listener);
     }
 
     /**
-     * Deprecated: Please use
-     * {@link GPUImageView#saveToPictures(String, String, jp.co.cyberagent.android.gpuimage.GPUImageView.OnPictureSavedListener)}
-     *
      * Apply and save the given bitmap with applied filter to Pictures. It will
      * be stored on the default Picture folder on the phone below the given
      * folerName and fileName. <br>
      * This method is async and will notify when the image was saved through the
      * listener.
      *
-     * @param bitmap the bitmap
+     * @param bitmap     the bitmap
      * @param folderName the folder name
-     * @param fileName the file name
-     * @param listener the listener
+     * @param fileName   the file name
+     * @param listener   the listener
      */
-    @Deprecated
     public void saveToPictures(final Bitmap bitmap, final String folderName, final String fileName,
-            final OnPictureSavedListener listener) {
+                               final OnPictureSavedListener listener) {
         new SaveTask(bitmap, folderName, fileName, listener).execute();
     }
 
@@ -399,30 +453,30 @@ public void saveToPictures(final Bitmap bitmap, final String folderName, final S
      * @param runnable The runnable to be run on the OpenGL thread.
      */
     void runOnGLThread(Runnable runnable) {
-        mRenderer.runOnDrawEnd(runnable);
+        renderer.runOnDrawEnd(runnable);
     }
 
     private int getOutputWidth() {
-        if (mRenderer != null && mRenderer.getFrameWidth() != 0) {
-            return mRenderer.getFrameWidth();
-        } else if (mCurrentBitmap != null) {
-            return mCurrentBitmap.getWidth();
+        if (renderer != null && renderer.getFrameWidth() != 0) {
+            return renderer.getFrameWidth();
+        } else if (currentBitmap != null) {
+            return currentBitmap.getWidth();
         } else {
             WindowManager windowManager =
-                    (WindowManager) mContext.getSystemService(Context.WINDOW_SERVICE);
+                    (WindowManager) context.getSystemService(Context.WINDOW_SERVICE);
             Display display = windowManager.getDefaultDisplay();
             return display.getWidth();
         }
     }
 
     private int getOutputHeight() {
-        if (mRenderer != null && mRenderer.getFrameHeight() != 0) {
-            return mRenderer.getFrameHeight();
-        } else if (mCurrentBitmap != null) {
-            return mCurrentBitmap.getHeight();
+        if (renderer != null && renderer.getFrameHeight() != 0) {
+            return renderer.getFrameHeight();
+        } else if (currentBitmap != null) {
+            return currentBitmap.getHeight();
         } else {
             WindowManager windowManager =
-                    (WindowManager) mContext.getSystemService(Context.WINDOW_SERVICE);
+                    (WindowManager) context.getSystemService(Context.WINDOW_SERVICE);
             Display display = windowManager.getDefaultDisplay();
             return display.getHeight();
         }
@@ -431,48 +485,47 @@ private int getOutputHeight() {
     @Deprecated
     private class SaveTask extends AsyncTask<Void, Void, Void> {
 
-        private final Bitmap mBitmap;
-        private final String mFolderName;
-        private final String mFileName;
-        private final OnPictureSavedListener mListener;
-        private final Handler mHandler;
+        private final Bitmap bitmap;
+        private final String folderName;
+        private final String fileName;
+        private final OnPictureSavedListener listener;
+        private final Handler handler;
 
         public SaveTask(final Bitmap bitmap, final String folderName, final String fileName,
-                final OnPictureSavedListener listener) {
-            mBitmap = bitmap;
-            mFolderName = folderName;
-            mFileName = fileName;
-            mListener = listener;
-            mHandler = new Handler();
+                        final OnPictureSavedListener listener) {
+            this.bitmap = bitmap;
+            this.folderName = folderName;
+            this.fileName = fileName;
+            this.listener = listener;
+            handler = new Handler();
         }
 
         @Override
         protected Void doInBackground(final Void... params) {
-            Bitmap result = getBitmapWithFilterApplied(mBitmap);
-            saveImage(mFolderName, mFileName, result);
+            Bitmap result = getBitmapWithFilterApplied(bitmap);
+            saveImage(folderName, fileName, result);
             return null;
         }
 
         private void saveImage(final String folderName, final String fileName, final Bitmap image) {
-            File path = Environment
-                    .getExternalStoragePublicDirectory(Environment.DIRECTORY_PICTURES);
+            File path = Environment.getExternalStoragePublicDirectory(Environment.DIRECTORY_PICTURES);
             File file = new File(path, folderName + "/" + fileName);
             try {
                 file.getParentFile().mkdirs();
                 image.compress(CompressFormat.JPEG, 80, new FileOutputStream(file));
-                MediaScannerConnection.scanFile(mContext,
-                        new String[] {
-                            file.toString()
+                MediaScannerConnection.scanFile(context,
+                        new String[]{
+                                file.toString()
                         }, null,
                         new MediaScannerConnection.OnScanCompletedListener() {
                             @Override
                             public void onScanCompleted(final String path, final Uri uri) {
-                                if (mListener != null) {
-                                    mHandler.post(new Runnable() {
+                                if (listener != null) {
+                                    handler.post(new Runnable() {
 
                                         @Override
                                         public void run() {
-                                            mListener.onPictureSaved(uri);
+                                            listener.onPictureSaved(uri);
                                         }
                                     });
                                 }
@@ -490,21 +543,23 @@ public void run() {
 
     private class LoadImageUriTask extends LoadImageTask {
 
-        private final Uri mUri;
+        private final Uri uri;
 
         public LoadImageUriTask(GPUImage gpuImage, Uri uri) {
             super(gpuImage);
-            mUri = uri;
+            this.uri = uri;
         }
 
         @Override
         protected Bitmap decode(BitmapFactory.Options options) {
             try {
                 InputStream inputStream;
-                if (mUri.getScheme().startsWith("http") || mUri.getScheme().startsWith("https")) {
-                    inputStream = new URL(mUri.toString()).openStream();
+                if (uri.getScheme().startsWith("http") || uri.getScheme().startsWith("https")) {
+                    inputStream = new URL(uri.toString()).openStream();
+                } else if (uri.getPath().startsWith("/android_asset/")) {
+                    inputStream = context.getAssets().open(uri.getPath().substring(("/android_asset/").length()));
                 } else {
-                    inputStream = mContext.getContentResolver().openInputStream(mUri);
+                    inputStream = context.getContentResolver().openInputStream(uri);
                 }
                 return BitmapFactory.decodeStream(inputStream, null, options);
             } catch (Exception e) {
@@ -515,8 +570,8 @@ protected Bitmap decode(BitmapFactory.Options options) {
 
         @Override
         protected int getImageOrientation() throws IOException {
-            Cursor cursor = mContext.getContentResolver().query(mUri,
-                    new String[] { MediaStore.Images.ImageColumns.ORIENTATION }, null, null, null);
+            Cursor cursor = context.getContentResolver().query(uri,
+                    new String[]{MediaStore.Images.ImageColumns.ORIENTATION}, null, null, null);
 
             if (cursor == null || cursor.getCount() != 1) {
                 return 0;
@@ -531,21 +586,21 @@ protected int getImageOrientation() throws IOException {
 
     private class LoadImageFileTask extends LoadImageTask {
 
-        private final File mImageFile;
+        private final File imageFile;
 
         public LoadImageFileTask(GPUImage gpuImage, File file) {
             super(gpuImage);
-            mImageFile = file;
+            imageFile = file;
         }
 
         @Override
         protected Bitmap decode(BitmapFactory.Options options) {
-            return BitmapFactory.decodeFile(mImageFile.getAbsolutePath(), options);
+            return BitmapFactory.decodeFile(imageFile.getAbsolutePath(), options);
         }
 
         @Override
         protected int getImageOrientation() throws IOException {
-            ExifInterface exif = new ExifInterface(mImageFile.getAbsolutePath());
+            ExifInterface exif = new ExifInterface(imageFile.getAbsolutePath());
             int orientation = exif.getAttributeInt(ExifInterface.TAG_ORIENTATION, 1);
             switch (orientation) {
                 case ExifInterface.ORIENTATION_NORMAL:
@@ -564,36 +619,35 @@ protected int getImageOrientation() throws IOException {
 
     private abstract class LoadImageTask extends AsyncTask<Void, Void, Bitmap> {
 
-        private final GPUImage mGPUImage;
-        private int mOutputWidth;
-        private int mOutputHeight;
+        private final GPUImage gpuImage;
+        private int outputWidth;
+        private int outputHeight;
 
-        @SuppressWarnings("deprecation")
         public LoadImageTask(final GPUImage gpuImage) {
-            mGPUImage = gpuImage;
+            this.gpuImage = gpuImage;
         }
 
         @Override
         protected Bitmap doInBackground(Void... params) {
-            if (mRenderer != null && mRenderer.getFrameWidth() == 0) {
+            if (renderer != null && renderer.getFrameWidth() == 0) {
                 try {
-                    synchronized (mRenderer.mSurfaceChangedWaiter) {
-                        mRenderer.mSurfaceChangedWaiter.wait(3000);
+                    synchronized (renderer.surfaceChangedWaiter) {
+                        renderer.surfaceChangedWaiter.wait(3000);
                     }
                 } catch (InterruptedException e) {
                     e.printStackTrace();
                 }
             }
-            mOutputWidth = getOutputWidth();
-            mOutputHeight = getOutputHeight();
+            outputWidth = getOutputWidth();
+            outputHeight = getOutputHeight();
             return loadResizedImage();
         }
 
         @Override
         protected void onPostExecute(Bitmap bitmap) {
             super.onPostExecute(bitmap);
-            mGPUImage.deleteImage();
-            mGPUImage.setImage(bitmap);
+            gpuImage.deleteImage();
+            gpuImage.setImage(bitmap);
         }
 
         protected abstract Bitmap decode(BitmapFactory.Options options);
@@ -603,7 +657,7 @@ private Bitmap loadResizedImage() {
             options.inJustDecodeBounds = true;
             decode(options);
             int scale = 1;
-            while (checkSize(options.outWidth / scale > mOutputWidth, options.outHeight / scale > mOutputHeight)) {
+            while (checkSize(options.outWidth / scale > outputWidth, options.outHeight / scale > outputHeight)) {
                 scale++;
             }
 
@@ -637,10 +691,10 @@ private Bitmap scaleBitmap(Bitmap bitmap) {
                 System.gc();
             }
 
-            if (mScaleType == ScaleType.CENTER_CROP) {
+            if (scaleType == ScaleType.CENTER_CROP) {
                 // Crop it
-                int diffWidth = newSize[0] - mOutputWidth;
-                int diffHeight = newSize[1] - mOutputHeight;
+                int diffWidth = newSize[0] - outputWidth;
+                int diffHeight = newSize[1] - outputHeight;
                 workBitmap = Bitmap.createBitmap(bitmap, diffWidth / 2, diffHeight / 2,
                         newSize[0] - diffWidth, newSize[1] - diffHeight);
                 if (workBitmap != bitmap) {
@@ -662,24 +716,24 @@ private Bitmap scaleBitmap(Bitmap bitmap) {
             float newWidth;
             float newHeight;
 
-            float withRatio = (float) width / mOutputWidth;
-            float heightRatio = (float) height / mOutputHeight;
+            float withRatio = (float) width / outputWidth;
+            float heightRatio = (float) height / outputHeight;
 
-            boolean adjustWidth = mScaleType == ScaleType.CENTER_CROP
+            boolean adjustWidth = scaleType == ScaleType.CENTER_CROP
                     ? withRatio > heightRatio : withRatio < heightRatio;
 
             if (adjustWidth) {
-                newHeight = mOutputHeight;
+                newHeight = outputHeight;
                 newWidth = (newHeight / height) * width;
             } else {
-                newWidth = mOutputWidth;
+                newWidth = outputWidth;
                 newHeight = (newWidth / width) * height;
             }
             return new int[]{Math.round(newWidth), Math.round(newHeight)};
         }
 
         private boolean checkSize(boolean widthBigger, boolean heightBigger) {
-            if (mScaleType == ScaleType.CENTER_CROP) {
+            if (scaleType == ScaleType.CENTER_CROP) {
                 return widthBigger && heightBigger;
             } else {
                 return widthBigger || heightBigger;
@@ -712,6 +766,4 @@ private Bitmap rotateImage(final Bitmap bitmap) {
     public interface ResponseListener<T> {
         void response(T item);
     }
-
-    public enum ScaleType { CENTER_INSIDE, CENTER_CROP }
 }
diff --git a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageNativeLibrary.java b/library/src/main/java/jp/co/cyberagent/android/gpuimage/GPUImageNativeLibrary.java
similarity index 82%
rename from library/src/jp/co/cyberagent/android/gpuimage/GPUImageNativeLibrary.java
rename to library/src/main/java/jp/co/cyberagent/android/gpuimage/GPUImageNativeLibrary.java
index ce8c31b8..0a171c7d 100644
--- a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageNativeLibrary.java
+++ b/library/src/main/java/jp/co/cyberagent/android/gpuimage/GPUImageNativeLibrary.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2012 CyberAgent
+ * Copyright (C) 2018 CyberAgent, Inc.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -16,12 +16,16 @@
 
 package jp.co.cyberagent.android.gpuimage;
 
+import android.graphics.Bitmap;
+
 public class GPUImageNativeLibrary {
     static {
-        System.loadLibrary("gpuimage-library");
+        System.loadLibrary("yuv-decoder");
     }
 
     public static native void YUVtoRBGA(byte[] yuv, int width, int height, int[] out);
 
     public static native void YUVtoARBG(byte[] yuv, int width, int height, int[] out);
+
+    public static native void adjustBitmap(Bitmap srcBitmap);
 }
diff --git a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageRenderer.java b/library/src/main/java/jp/co/cyberagent/android/gpuimage/GPUImageRenderer.java
similarity index 58%
rename from library/src/jp/co/cyberagent/android/gpuimage/GPUImageRenderer.java
rename to library/src/main/java/jp/co/cyberagent/android/gpuimage/GPUImageRenderer.java
index 691550bd..e8cd690b 100644
--- a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageRenderer.java
+++ b/library/src/main/java/jp/co/cyberagent/android/gpuimage/GPUImageRenderer.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2012 CyberAgent
+ * Copyright (C) 2018 CyberAgent, Inc.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -16,7 +16,6 @@
 
 package jp.co.cyberagent.android.gpuimage;
 
-import android.annotation.TargetApi;
 import android.graphics.Bitmap;
 import android.graphics.Canvas;
 import android.graphics.SurfaceTexture;
@@ -24,12 +23,8 @@
 import android.hardware.Camera.PreviewCallback;
 import android.hardware.Camera.Size;
 import android.opengl.GLES20;
-import android.opengl.GLSurfaceView.Renderer;
+import android.opengl.GLSurfaceView;
 
-import jp.co.cyberagent.android.gpuimage.util.TextureRotationUtil;
-
-import javax.microedition.khronos.egl.EGLConfig;
-import javax.microedition.khronos.opengles.GL10;
 import java.io.IOException;
 import java.nio.ByteBuffer;
 import java.nio.ByteOrder;
@@ -38,56 +33,63 @@
 import java.util.LinkedList;
 import java.util.Queue;
 
+import javax.microedition.khronos.egl.EGLConfig;
+import javax.microedition.khronos.opengles.GL10;
+
+import jp.co.cyberagent.android.gpuimage.filter.GPUImageFilter;
+import jp.co.cyberagent.android.gpuimage.util.OpenGlUtils;
+import jp.co.cyberagent.android.gpuimage.util.Rotation;
+import jp.co.cyberagent.android.gpuimage.util.TextureRotationUtil;
+
 import static jp.co.cyberagent.android.gpuimage.util.TextureRotationUtil.TEXTURE_NO_ROTATION;
 
-@TargetApi(11)
-public class GPUImageRenderer implements Renderer, PreviewCallback {
-    public static final int NO_IMAGE = -1;
-    static final float CUBE[] = {
+public class GPUImageRenderer implements GLSurfaceView.Renderer, GLTextureView.Renderer, PreviewCallback {
+    private static final int NO_IMAGE = -1;
+    public static final float CUBE[] = {
             -1.0f, -1.0f,
             1.0f, -1.0f,
             -1.0f, 1.0f,
             1.0f, 1.0f,
     };
 
-    private GPUImageFilter mFilter;
+    private GPUImageFilter filter;
 
-    public final Object mSurfaceChangedWaiter = new Object();
+    public final Object surfaceChangedWaiter = new Object();
 
-    private int mGLTextureId = NO_IMAGE;
-    private SurfaceTexture mSurfaceTexture = null;
-    private final FloatBuffer mGLCubeBuffer;
-    private final FloatBuffer mGLTextureBuffer;
-    private IntBuffer mGLRgbBuffer;
+    private int glTextureId = NO_IMAGE;
+    private SurfaceTexture surfaceTexture = null;
+    private final FloatBuffer glCubeBuffer;
+    private final FloatBuffer glTextureBuffer;
+    private IntBuffer glRgbBuffer;
 
-    private int mOutputWidth;
-    private int mOutputHeight;
-    private int mImageWidth;
-    private int mImageHeight;
-    private int mAddedPadding;
+    private int outputWidth;
+    private int outputHeight;
+    private int imageWidth;
+    private int imageHeight;
+    private int addedPadding;
 
-    private final Queue<Runnable> mRunOnDraw;
-    private final Queue<Runnable> mRunOnDrawEnd;
-    private Rotation mRotation;
-    private boolean mFlipHorizontal;
-    private boolean mFlipVertical;
-    private GPUImage.ScaleType mScaleType = GPUImage.ScaleType.CENTER_CROP;
+    private final Queue<Runnable> runOnDraw;
+    private final Queue<Runnable> runOnDrawEnd;
+    private Rotation rotation;
+    private boolean flipHorizontal;
+    private boolean flipVertical;
+    private GPUImage.ScaleType scaleType = GPUImage.ScaleType.CENTER_CROP;
 
-    private float mBackgroundRed = 0;
-    private float mBackgroundGreen = 0;
-    private float mBackgroundBlue = 0;
+    private float backgroundRed = 0;
+    private float backgroundGreen = 0;
+    private float backgroundBlue = 0;
 
     public GPUImageRenderer(final GPUImageFilter filter) {
-        mFilter = filter;
-        mRunOnDraw = new LinkedList<Runnable>();
-        mRunOnDrawEnd = new LinkedList<Runnable>();
+        this.filter = filter;
+        runOnDraw = new LinkedList<>();
+        runOnDrawEnd = new LinkedList<>();
 
-        mGLCubeBuffer = ByteBuffer.allocateDirect(CUBE.length * 4)
+        glCubeBuffer = ByteBuffer.allocateDirect(CUBE.length * 4)
                 .order(ByteOrder.nativeOrder())
                 .asFloatBuffer();
-        mGLCubeBuffer.put(CUBE).position(0);
+        glCubeBuffer.put(CUBE).position(0);
 
-        mGLTextureBuffer = ByteBuffer.allocateDirect(TEXTURE_NO_ROTATION.length * 4)
+        glTextureBuffer = ByteBuffer.allocateDirect(TEXTURE_NO_ROTATION.length * 4)
                 .order(ByteOrder.nativeOrder())
                 .asFloatBuffer();
         setRotation(Rotation.NORMAL, false, false);
@@ -95,46 +97,46 @@ public GPUImageRenderer(final GPUImageFilter filter) {
 
     @Override
     public void onSurfaceCreated(final GL10 unused, final EGLConfig config) {
-        GLES20.glClearColor(mBackgroundRed, mBackgroundGreen, mBackgroundBlue, 1);
+        GLES20.glClearColor(backgroundRed, backgroundGreen, backgroundBlue, 1);
         GLES20.glDisable(GLES20.GL_DEPTH_TEST);
-        mFilter.init();
+        filter.ifNeedInit();
     }
 
     @Override
     public void onSurfaceChanged(final GL10 gl, final int width, final int height) {
-        mOutputWidth = width;
-        mOutputHeight = height;
+        outputWidth = width;
+        outputHeight = height;
         GLES20.glViewport(0, 0, width, height);
-        GLES20.glUseProgram(mFilter.getProgram());
-        mFilter.onOutputSizeChanged(width, height);
+        GLES20.glUseProgram(filter.getProgram());
+        filter.onOutputSizeChanged(width, height);
         adjustImageScaling();
-        synchronized (mSurfaceChangedWaiter) {
-            mSurfaceChangedWaiter.notifyAll();
+        synchronized (surfaceChangedWaiter) {
+            surfaceChangedWaiter.notifyAll();
         }
     }
 
     @Override
     public void onDrawFrame(final GL10 gl) {
         GLES20.glClear(GLES20.GL_COLOR_BUFFER_BIT | GLES20.GL_DEPTH_BUFFER_BIT);
-        runAll(mRunOnDraw);
-        mFilter.onDraw(mGLTextureId, mGLCubeBuffer, mGLTextureBuffer);
-        runAll(mRunOnDrawEnd);
-        if (mSurfaceTexture != null) {
-            mSurfaceTexture.updateTexImage();
+        runAll(runOnDraw);
+        filter.onDraw(glTextureId, glCubeBuffer, glTextureBuffer);
+        runAll(runOnDrawEnd);
+        if (surfaceTexture != null) {
+            surfaceTexture.updateTexImage();
         }
     }
 
     /**
      * Sets the background color
      *
-     * @param red red color value
+     * @param red   red color value
      * @param green green color value
-     * @param blue red color value
+     * @param blue  red color value
      */
     public void setBackgroundColor(float red, float green, float blue) {
-        mBackgroundRed = red;
-        mBackgroundGreen = green;
-        mBackgroundBlue = blue;
+        backgroundRed = red;
+        backgroundGreen = green;
+        backgroundBlue = blue;
     }
 
     private void runAll(Queue<Runnable> queue) {
@@ -148,21 +150,23 @@ private void runAll(Queue<Runnable> queue) {
     @Override
     public void onPreviewFrame(final byte[] data, final Camera camera) {
         final Size previewSize = camera.getParameters().getPreviewSize();
-        if (mGLRgbBuffer == null) {
-            mGLRgbBuffer = IntBuffer.allocate(previewSize.width * previewSize.height);
+        onPreviewFrame(data, previewSize.width, previewSize.height);
+    }
+
+    public void onPreviewFrame(final byte[] data, final int width, final int height) {
+        if (glRgbBuffer == null) {
+            glRgbBuffer = IntBuffer.allocate(width * height);
         }
-        if (mRunOnDraw.isEmpty()) {
+        if (runOnDraw.isEmpty()) {
             runOnDraw(new Runnable() {
                 @Override
                 public void run() {
-                    GPUImageNativeLibrary.YUVtoRBGA(data, previewSize.width, previewSize.height,
-                            mGLRgbBuffer.array());
-                    mGLTextureId = OpenGlUtils.loadTexture(mGLRgbBuffer, previewSize, mGLTextureId);
-                    camera.addCallbackBuffer(data);
-
-                    if (mImageWidth != previewSize.width) {
-                        mImageWidth = previewSize.width;
-                        mImageHeight = previewSize.height;
+                    GPUImageNativeLibrary.YUVtoRBGA(data, width, height, glRgbBuffer.array());
+                    glTextureId = OpenGlUtils.loadTexture(glRgbBuffer, width, height, glTextureId);
+
+                    if (imageWidth != width) {
+                        imageWidth = width;
+                        imageHeight = height;
                         adjustImageScaling();
                     }
                 }
@@ -176,9 +180,9 @@ public void setUpSurfaceTexture(final Camera camera) {
             public void run() {
                 int[] textures = new int[1];
                 GLES20.glGenTextures(1, textures, 0);
-                mSurfaceTexture = new SurfaceTexture(textures[0]);
+                surfaceTexture = new SurfaceTexture(textures[0]);
                 try {
-                    camera.setPreviewTexture(mSurfaceTexture);
+                    camera.setPreviewTexture(surfaceTexture);
                     camera.setPreviewCallback(GPUImageRenderer.this);
                     camera.startPreview();
                 } catch (IOException e) {
@@ -193,14 +197,14 @@ public void setFilter(final GPUImageFilter filter) {
 
             @Override
             public void run() {
-                final GPUImageFilter oldFilter = mFilter;
-                mFilter = filter;
+                final GPUImageFilter oldFilter = GPUImageRenderer.this.filter;
+                GPUImageRenderer.this.filter = filter;
                 if (oldFilter != null) {
                     oldFilter.destroy();
                 }
-                mFilter.init();
-                GLES20.glUseProgram(mFilter.getProgram());
-                mFilter.onOutputSizeChanged(mOutputWidth, mOutputHeight);
+                GPUImageRenderer.this.filter.ifNeedInit();
+                GLES20.glUseProgram(GPUImageRenderer.this.filter.getProgram());
+                GPUImageRenderer.this.filter.onOutputSizeChanged(outputWidth, outputHeight);
             }
         });
     }
@@ -211,9 +215,9 @@ public void deleteImage() {
             @Override
             public void run() {
                 GLES20.glDeleteTextures(1, new int[]{
-                        mGLTextureId
+                        glTextureId
                 }, 0);
-                mGLTextureId = NO_IMAGE;
+                glTextureId = NO_IMAGE;
             }
         });
     }
@@ -238,55 +242,55 @@ public void run() {
                     Canvas can = new Canvas(resizedBitmap);
                     can.drawARGB(0x00, 0x00, 0x00, 0x00);
                     can.drawBitmap(bitmap, 0, 0, null);
-                    mAddedPadding = 1;
+                    addedPadding = 1;
                 } else {
-                    mAddedPadding = 0;
+                    addedPadding = 0;
                 }
 
-                mGLTextureId = OpenGlUtils.loadTexture(
-                        resizedBitmap != null ? resizedBitmap : bitmap, mGLTextureId, recycle);
+                glTextureId = OpenGlUtils.loadTexture(
+                        resizedBitmap != null ? resizedBitmap : bitmap, glTextureId, recycle);
                 if (resizedBitmap != null) {
                     resizedBitmap.recycle();
                 }
-                mImageWidth = bitmap.getWidth();
-                mImageHeight = bitmap.getHeight();
+                imageWidth = bitmap.getWidth();
+                imageHeight = bitmap.getHeight();
                 adjustImageScaling();
             }
         });
     }
 
     public void setScaleType(GPUImage.ScaleType scaleType) {
-        mScaleType = scaleType;
+        this.scaleType = scaleType;
     }
 
     protected int getFrameWidth() {
-        return mOutputWidth;
+        return outputWidth;
     }
 
     protected int getFrameHeight() {
-        return mOutputHeight;
+        return outputHeight;
     }
 
     private void adjustImageScaling() {
-        float outputWidth = mOutputWidth;
-        float outputHeight = mOutputHeight;
-        if (mRotation == Rotation.ROTATION_270 || mRotation == Rotation.ROTATION_90) {
-            outputWidth = mOutputHeight;
-            outputHeight = mOutputWidth;
+        float outputWidth = this.outputWidth;
+        float outputHeight = this.outputHeight;
+        if (rotation == Rotation.ROTATION_270 || rotation == Rotation.ROTATION_90) {
+            outputWidth = this.outputHeight;
+            outputHeight = this.outputWidth;
         }
 
-        float ratio1 = outputWidth / mImageWidth;
-        float ratio2 = outputHeight / mImageHeight;
+        float ratio1 = outputWidth / imageWidth;
+        float ratio2 = outputHeight / imageHeight;
         float ratioMax = Math.max(ratio1, ratio2);
-        int imageWidthNew = Math.round(mImageWidth * ratioMax);
-        int imageHeightNew = Math.round(mImageHeight * ratioMax);
+        int imageWidthNew = Math.round(imageWidth * ratioMax);
+        int imageHeightNew = Math.round(imageHeight * ratioMax);
 
         float ratioWidth = imageWidthNew / outputWidth;
         float ratioHeight = imageHeightNew / outputHeight;
 
         float[] cube = CUBE;
-        float[] textureCords = TextureRotationUtil.getRotation(mRotation, mFlipHorizontal, mFlipVertical);
-        if (mScaleType == GPUImage.ScaleType.CENTER_CROP) {
+        float[] textureCords = TextureRotationUtil.getRotation(rotation, flipHorizontal, flipVertical);
+        if (scaleType == GPUImage.ScaleType.CENTER_CROP) {
             float distHorizontal = (1 - 1 / ratioWidth) / 2;
             float distVertical = (1 - 1 / ratioHeight) / 2;
             textureCords = new float[]{
@@ -304,10 +308,10 @@ private void adjustImageScaling() {
             };
         }
 
-        mGLCubeBuffer.clear();
-        mGLCubeBuffer.put(cube).position(0);
-        mGLTextureBuffer.clear();
-        mGLTextureBuffer.put(textureCords).position(0);
+        glCubeBuffer.clear();
+        glCubeBuffer.put(cube).position(0);
+        glTextureBuffer.clear();
+        glTextureBuffer.put(textureCords).position(0);
     }
 
     private float addDistance(float coordinate, float distance) {
@@ -315,43 +319,43 @@ private float addDistance(float coordinate, float distance) {
     }
 
     public void setRotationCamera(final Rotation rotation, final boolean flipHorizontal,
-            final boolean flipVertical) {
+                                  final boolean flipVertical) {
         setRotation(rotation, flipVertical, flipHorizontal);
     }
 
     public void setRotation(final Rotation rotation) {
-        mRotation = rotation;
+        this.rotation = rotation;
         adjustImageScaling();
     }
 
     public void setRotation(final Rotation rotation,
                             final boolean flipHorizontal, final boolean flipVertical) {
-        mFlipHorizontal = flipHorizontal;
-        mFlipVertical = flipVertical;
+        this.flipHorizontal = flipHorizontal;
+        this.flipVertical = flipVertical;
         setRotation(rotation);
     }
 
     public Rotation getRotation() {
-        return mRotation;
+        return rotation;
     }
 
     public boolean isFlippedHorizontally() {
-        return mFlipHorizontal;
+        return flipHorizontal;
     }
 
     public boolean isFlippedVertically() {
-        return mFlipVertical;
+        return flipVertical;
     }
 
     protected void runOnDraw(final Runnable runnable) {
-        synchronized (mRunOnDraw) {
-            mRunOnDraw.add(runnable);
+        synchronized (runOnDraw) {
+            runOnDraw.add(runnable);
         }
     }
 
     protected void runOnDrawEnd(final Runnable runnable) {
-        synchronized (mRunOnDrawEnd) {
-            mRunOnDrawEnd.add(runnable);
+        synchronized (runOnDrawEnd) {
+            runOnDrawEnd.add(runnable);
         }
     }
 }
diff --git a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageView.java b/library/src/main/java/jp/co/cyberagent/android/gpuimage/GPUImageView.java
similarity index 55%
rename from library/src/jp/co/cyberagent/android/gpuimage/GPUImageView.java
rename to library/src/main/java/jp/co/cyberagent/android/gpuimage/GPUImageView.java
index cc6a0247..e8eafcb3 100644
--- a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageView.java
+++ b/library/src/main/java/jp/co/cyberagent/android/gpuimage/GPUImageView.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2012 CyberAgent
+ * Copyright (C) 2018 CyberAgent, Inc.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -17,17 +17,21 @@
 package jp.co.cyberagent.android.gpuimage;
 
 import android.content.Context;
+import android.content.res.TypedArray;
 import android.graphics.Bitmap;
 import android.graphics.Color;
-import android.graphics.drawable.ColorDrawable;
-import android.graphics.drawable.Drawable;
+import android.hardware.Camera;
 import android.media.MediaScannerConnection;
 import android.net.Uri;
-import android.opengl.GLES20;
 import android.opengl.GLSurfaceView;
-import android.os.*;
+import android.os.AsyncTask;
+import android.os.Build;
+import android.os.Environment;
+import android.os.Handler;
+import android.os.Looper;
 import android.util.AttributeSet;
 import android.view.Gravity;
+import android.view.View;
 import android.view.ViewTreeObserver;
 import android.widget.FrameLayout;
 import android.widget.ProgressBar;
@@ -35,16 +39,26 @@
 import java.io.File;
 import java.io.FileNotFoundException;
 import java.io.FileOutputStream;
-import java.nio.IntBuffer;
 import java.util.concurrent.Semaphore;
 
+import jp.co.cyberagent.android.gpuimage.filter.GPUImageFilter;
+import jp.co.cyberagent.android.gpuimage.util.Rotation;
+
+import static jp.co.cyberagent.android.gpuimage.GPUImage.SURFACE_TYPE_SURFACE_VIEW;
+import static jp.co.cyberagent.android.gpuimage.GPUImage.SURFACE_TYPE_TEXTURE_VIEW;
+
 public class GPUImageView extends FrameLayout {
 
-    private GLSurfaceView mGLSurfaceView;
-    private GPUImage mGPUImage;
-    private GPUImageFilter mFilter;
-    public Size mForceSize = null;
-    private float mRatio = 0.0f;
+    private int surfaceType = SURFACE_TYPE_SURFACE_VIEW;
+    private View surfaceView;
+    private GPUImage gpuImage;
+    private boolean isShowLoading = true;
+    private GPUImageFilter filter;
+    public Size forceSize = null;
+    private float ratio = 0.0f;
+
+    public final static int RENDERMODE_WHEN_DIRTY = 0;
+    public final static int RENDERMODE_CONTINUOUSLY = 1;
 
     public GPUImageView(Context context) {
         super(context);
@@ -57,26 +71,40 @@ public GPUImageView(Context context, AttributeSet attrs) {
     }
 
     private void init(Context context, AttributeSet attrs) {
-        mGLSurfaceView = new GPUImageGLSurfaceView(context, attrs);
-        addView(mGLSurfaceView);
-        mGPUImage = new GPUImage(getContext());
-        mGPUImage.setGLSurfaceView(mGLSurfaceView);
+        if (attrs != null) {
+            TypedArray a = context.getTheme().obtainStyledAttributes(attrs, R.styleable.GPUImageView, 0, 0);
+            try {
+                surfaceType = a.getInt(R.styleable.GPUImageView_gpuimage_surface_type, surfaceType);
+                isShowLoading = a.getBoolean(R.styleable.GPUImageView_gpuimage_show_loading, isShowLoading);
+            } finally {
+                a.recycle();
+            }
+        }
+        gpuImage = new GPUImage(context);
+        if (surfaceType == SURFACE_TYPE_TEXTURE_VIEW) {
+            surfaceView = new GPUImageGLTextureView(context, attrs);
+            gpuImage.setGLTextureView((GLTextureView) surfaceView);
+        } else {
+            surfaceView = new GPUImageGLSurfaceView(context, attrs);
+            gpuImage.setGLSurfaceView((GLSurfaceView) surfaceView);
+        }
+        addView(surfaceView);
     }
 
     @Override
     protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
-        if (mRatio != 0.0f) {
+        if (ratio != 0.0f) {
             int width = MeasureSpec.getSize(widthMeasureSpec);
             int height = MeasureSpec.getSize(heightMeasureSpec);
 
             int newHeight;
             int newWidth;
-            if (width / mRatio < height) {
+            if (width / ratio < height) {
                 newWidth = width;
-                newHeight = Math.round(width / mRatio);
+                newHeight = Math.round(width / ratio);
             } else {
                 newHeight = height;
-                newWidth = Math.round(height * mRatio);
+                newWidth = Math.round(height * ratio);
             }
 
             int newWidthSpec = MeasureSpec.makeMeasureSpec(newWidth, MeasureSpec.EXACTLY);
@@ -93,25 +121,87 @@ protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
      * @return used GPUImage instance
      */
     public GPUImage getGPUImage() {
-        return mGPUImage;
+        return gpuImage;
+    }
+
+    /**
+     * Deprecated: Please call
+     * {@link GPUImageView#updatePreviewFrame(byte[], int, int)} frame by frame
+     * <p>
+     * Sets the up camera to be connected to GPUImage to get a filtered preview.
+     *
+     * @param camera the camera
+     */
+    @Deprecated
+    public void setUpCamera(final Camera camera) {
+        gpuImage.setUpCamera(camera);
+    }
+
+    /**
+     * Deprecated: Please call
+     * {@link GPUImageView#updatePreviewFrame(byte[], int, int)} frame by frame
+     * <p>
+     * Sets the up camera to be connected to GPUImage to get a filtered preview.
+     *
+     * @param camera         the camera
+     * @param degrees        by how many degrees the image should be rotated
+     * @param flipHorizontal if the image should be flipped horizontally
+     * @param flipVertical   if the image should be flipped vertically
+     */
+    @Deprecated
+    public void setUpCamera(final Camera camera, final int degrees, final boolean flipHorizontal,
+                            final boolean flipVertical) {
+        gpuImage.setUpCamera(camera, degrees, flipHorizontal, flipVertical);
+    }
+
+    /**
+     * Update camera preview frame with YUV format data.
+     *
+     * @param data   Camera preview YUV data for frame.
+     * @param width  width of camera preview
+     * @param height height of camera preview
+     */
+    public void updatePreviewFrame(byte[] data, int width, int height) {
+        gpuImage.updatePreviewFrame(data, width, height);
     }
 
     /**
      * Sets the background color
      *
-     * @param red red color value
+     * @param red   red color value
      * @param green green color value
-     * @param blue red color value
+     * @param blue  red color value
      */
     public void setBackgroundColor(float red, float green, float blue) {
-        mGPUImage.setBackgroundColor(red, green, blue);
+        gpuImage.setBackgroundColor(red, green, blue);
+    }
+
+    /**
+     * Set the rendering mode. When renderMode is
+     * RENDERMODE_CONTINUOUSLY, the renderer is called
+     * repeatedly to re-render the scene. When renderMode
+     * is RENDERMODE_WHEN_DIRTY, the renderer only rendered when the surface
+     * is created, or when {@link #requestRender} is called. Defaults to RENDERMODE_CONTINUOUSLY.
+     *
+     * @param renderMode one of the RENDERMODE_X constants
+     * @see #RENDERMODE_CONTINUOUSLY
+     * @see #RENDERMODE_WHEN_DIRTY
+     * @see GLSurfaceView#setRenderMode(int)
+     * @see GLTextureView#setRenderMode(int)
+     */
+    public void setRenderMode(int renderMode) {
+        if (surfaceView instanceof GLSurfaceView) {
+            ((GLSurfaceView) surfaceView).setRenderMode(renderMode);
+        } else if (surfaceView instanceof GLTextureView) {
+            ((GLTextureView) surfaceView).setRenderMode(renderMode);
+        }
     }
 
     // TODO Should be an xml attribute. But then GPUImage can not be distributed as .jar anymore.
     public void setRatio(float ratio) {
-        mRatio = ratio;
-        mGLSurfaceView.requestLayout();
-        mGPUImage.deleteImage();
+        this.ratio = ratio;
+        surfaceView.requestLayout();
+        gpuImage.deleteImage();
     }
 
     /**
@@ -120,7 +210,7 @@ public void setRatio(float ratio) {
      * @param scaleType the new ScaleType
      */
     public void setScaleType(GPUImage.ScaleType scaleType) {
-        mGPUImage.setScaleType(scaleType);
+        gpuImage.setScaleType(scaleType);
     }
 
     /**
@@ -129,7 +219,7 @@ public void setScaleType(GPUImage.ScaleType scaleType) {
      * @param rotation new rotation
      */
     public void setRotation(Rotation rotation) {
-        mGPUImage.setRotation(rotation);
+        gpuImage.setRotation(rotation);
         requestRender();
     }
 
@@ -139,8 +229,8 @@ public void setRotation(Rotation rotation) {
      * @param filter Filter that should be applied on the image.
      */
     public void setFilter(GPUImageFilter filter) {
-        mFilter = filter;
-        mGPUImage.setFilter(filter);
+        this.filter = filter;
+        gpuImage.setFilter(filter);
         requestRender();
     }
 
@@ -150,7 +240,7 @@ public void setFilter(GPUImageFilter filter) {
      * @return the current filter
      */
     public GPUImageFilter getFilter() {
-        return mFilter;
+        return filter;
     }
 
     /**
@@ -159,7 +249,7 @@ public GPUImageFilter getFilter() {
      * @param bitmap the new image
      */
     public void setImage(final Bitmap bitmap) {
-        mGPUImage.setImage(bitmap);
+        gpuImage.setImage(bitmap);
     }
 
     /**
@@ -168,7 +258,7 @@ public void setImage(final Bitmap bitmap) {
      * @param uri the uri of the new image
      */
     public void setImage(final Uri uri) {
-        mGPUImage.setImage(uri);
+        gpuImage.setImage(uri);
     }
 
     /**
@@ -177,11 +267,15 @@ public void setImage(final Uri uri) {
      * @param file the file of the new image
      */
     public void setImage(final File file) {
-        mGPUImage.setImage(file);
+        gpuImage.setImage(file);
     }
 
     public void requestRender() {
-        mGLSurfaceView.requestRender();
+        if (surfaceView instanceof GLSurfaceView) {
+            ((GLSurfaceView) surfaceView).requestRender();
+        } else if (surfaceView instanceof GLTextureView) {
+            ((GLTextureView) surfaceView).requestRender();
+        }
     }
 
     /**
@@ -192,12 +286,12 @@ public void requestRender() {
      * listener.
      *
      * @param folderName the folder name
-     * @param fileName the file name
-     * @param listener the listener
+     * @param fileName   the file name
+     * @param listener   the listener
      */
     public void saveToPictures(final String folderName, final String fileName,
                                final OnPictureSavedListener listener) {
-        new SaveTask(folderName, fileName, listener).execute();
+        new SaveTask(folderName, fileName, listener).executeOnExecutor(AsyncTask.THREAD_POOL_EXECUTOR);
     }
 
     /**
@@ -216,7 +310,7 @@ public void saveToPictures(final String folderName, final String fileName,
     public void saveToPictures(final String folderName, final String fileName,
                                int width, int height,
                                final OnPictureSavedListener listener) {
-        new SaveTask(folderName, fileName, width, height, listener).execute();
+        new SaveTask(folderName, fileName, width, height, listener).executeOnExecutor(AsyncTask.THREAD_POOL_EXECUTOR);
     }
 
     /**
@@ -233,7 +327,7 @@ public Bitmap capture(final int width, final int height) throws InterruptedExcep
             throw new IllegalStateException("Do not call this method from the UI thread!");
         }
 
-        mForceSize = new Size(width, height);
+        forceSize = new Size(width, height);
 
         final Semaphore waiter = new Semaphore(0);
 
@@ -249,19 +343,22 @@ public void onGlobalLayout() {
                 waiter.release();
             }
         });
-        post(new Runnable() {
-            @Override
-            public void run() {
-                // Show loading
-                addView(new LoadingView(getContext()));
 
-                mGLSurfaceView.requestLayout();
-            }
-        });
+        if (isShowLoading) {
+            post(new Runnable() {
+                @Override
+                public void run() {
+                    // Show loading
+                    addView(new LoadingView(getContext()));
+                    surfaceView.requestLayout();
+                }
+            });
+        }
+
         waiter.acquire();
 
         // Run one render pass
-        mGPUImage.runOnGLThread(new Runnable() {
+        gpuImage.runOnGLThread(new Runnable() {
             @Override
             public void run() {
                 waiter.release();
@@ -272,75 +369,75 @@ public void run() {
         Bitmap bitmap = capture();
 
 
-        mForceSize = null;
+        forceSize = null;
         post(new Runnable() {
             @Override
             public void run() {
-                mGLSurfaceView.requestLayout();
+                surfaceView.requestLayout();
             }
         });
         requestRender();
 
-        postDelayed(new Runnable() {
-            @Override
-            public void run() {
-                // Remove loading view
-                removeViewAt(1);
-            }
-        }, 300);
+        if (isShowLoading) {
+            postDelayed(new Runnable() {
+                @Override
+                public void run() {
+                    // Remove loading view
+                    removeViewAt(1);
+                }
+            }, 300);
+        }
 
         return bitmap;
     }
 
     /**
      * Capture the current image with the size as it is displayed and retrieve it as Bitmap.
+     *
      * @return current output as Bitmap
      * @throws InterruptedException
      */
     public Bitmap capture() throws InterruptedException {
         final Semaphore waiter = new Semaphore(0);
 
-        final int width = mGLSurfaceView.getMeasuredWidth();
-        final int height = mGLSurfaceView.getMeasuredHeight();
+        final int width = surfaceView.getMeasuredWidth();
+        final int height = surfaceView.getMeasuredHeight();
 
         // Take picture on OpenGL thread
-        final int[] pixelMirroredArray = new int[width * height];
-        mGPUImage.runOnGLThread(new Runnable() {
+        final Bitmap resultBitmap = Bitmap.createBitmap(width, height, Bitmap.Config.ARGB_8888);
+        gpuImage.runOnGLThread(new Runnable() {
             @Override
             public void run() {
-                final IntBuffer pixelBuffer = IntBuffer.allocate(width * height);
-                GLES20.glReadPixels(0, 0, width, height, GLES20.GL_RGBA, GLES20.GL_UNSIGNED_BYTE, pixelBuffer);
-                int[] pixelArray = pixelBuffer.array();
-
-                // Convert upside down mirror-reversed image to right-side up normal image.
-                for (int i = 0; i < height; i++) {
-                    for (int j = 0; j < width; j++) {
-                        pixelMirroredArray[(height - i - 1) * width + j] = pixelArray[i * width + j];
-                    }
-                }
+                GPUImageNativeLibrary.adjustBitmap(resultBitmap);
                 waiter.release();
             }
         });
         requestRender();
         waiter.acquire();
 
-        Bitmap bitmap = Bitmap.createBitmap(width, height, Bitmap.Config.ARGB_8888);
-        bitmap.copyPixelsFromBuffer(IntBuffer.wrap(pixelMirroredArray));
-        return bitmap;
+        return resultBitmap;
     }
 
     /**
-     * Pauses the GLSurfaceView.
+     * Pauses the Surface.
      */
     public void onPause() {
-        mGLSurfaceView.onPause();
+        if (surfaceView instanceof GLSurfaceView) {
+            ((GLSurfaceView) surfaceView).onPause();
+        } else if (surfaceView instanceof GLTextureView) {
+            ((GLTextureView) surfaceView).onPause();
+        }
     }
 
     /**
-     * Resumes the GLSurfaceView.
+     * Resumes the Surface.
      */
     public void onResume() {
-        mGLSurfaceView.onResume();
+        if (surfaceView instanceof GLSurfaceView) {
+            ((GLSurfaceView) surfaceView).onResume();
+        } else if (surfaceView instanceof GLTextureView) {
+            ((GLTextureView) surfaceView).onResume();
+        }
     }
 
     public static class Size {
@@ -364,9 +461,29 @@ public GPUImageGLSurfaceView(Context context, AttributeSet attrs) {
 
         @Override
         protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
-            if (mForceSize != null) {
-                super.onMeasure(MeasureSpec.makeMeasureSpec(mForceSize.width, MeasureSpec.EXACTLY),
-                        MeasureSpec.makeMeasureSpec(mForceSize.height, MeasureSpec.EXACTLY));
+            if (forceSize != null) {
+                super.onMeasure(MeasureSpec.makeMeasureSpec(forceSize.width, MeasureSpec.EXACTLY),
+                        MeasureSpec.makeMeasureSpec(forceSize.height, MeasureSpec.EXACTLY));
+            } else {
+                super.onMeasure(widthMeasureSpec, heightMeasureSpec);
+            }
+        }
+    }
+
+    private class GPUImageGLTextureView extends GLTextureView {
+        public GPUImageGLTextureView(Context context) {
+            super(context);
+        }
+
+        public GPUImageGLTextureView(Context context, AttributeSet attrs) {
+            super(context, attrs);
+        }
+
+        @Override
+        protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
+            if (forceSize != null) {
+                super.onMeasure(MeasureSpec.makeMeasureSpec(forceSize.width, MeasureSpec.EXACTLY),
+                        MeasureSpec.makeMeasureSpec(forceSize.height, MeasureSpec.EXACTLY));
             } else {
                 super.onMeasure(widthMeasureSpec, heightMeasureSpec);
             }
@@ -399,12 +516,12 @@ private void init() {
     }
 
     private class SaveTask extends AsyncTask<Void, Void, Void> {
-        private final String mFolderName;
-        private final String mFileName;
-        private final int mWidth;
-        private final int mHeight;
-        private final OnPictureSavedListener mListener;
-        private final Handler mHandler;
+        private final String folderName;
+        private final String fileName;
+        private final int width;
+        private final int height;
+        private final OnPictureSavedListener listener;
+        private final Handler handler;
 
         public SaveTask(final String folderName, final String fileName,
                         final OnPictureSavedListener listener) {
@@ -413,19 +530,19 @@ public SaveTask(final String folderName, final String fileName,
 
         public SaveTask(final String folderName, final String fileName, int width, int height,
                         final OnPictureSavedListener listener) {
-            mFolderName = folderName;
-            mFileName = fileName;
-            mWidth = width;
-            mHeight = height;
-            mListener = listener;
-            mHandler = new Handler();
+            this.folderName = folderName;
+            this.fileName = fileName;
+            this.width = width;
+            this.height = height;
+            this.listener = listener;
+            handler = new Handler();
         }
 
         @Override
         protected Void doInBackground(final Void... params) {
             try {
-                Bitmap result = mWidth != 0 ? capture(mWidth, mHeight) : capture();
-                saveImage(mFolderName, mFileName, result);
+                Bitmap result = width != 0 ? capture(width, height) : capture();
+                saveImage(folderName, fileName, result);
             } catch (InterruptedException e) {
                 e.printStackTrace();
             }
@@ -433,8 +550,7 @@ protected Void doInBackground(final Void... params) {
         }
 
         private void saveImage(final String folderName, final String fileName, final Bitmap image) {
-            File path = Environment
-                    .getExternalStoragePublicDirectory(Environment.DIRECTORY_PICTURES);
+            File path = Environment.getExternalStoragePublicDirectory(Environment.DIRECTORY_PICTURES);
             File file = new File(path, folderName + "/" + fileName);
             try {
                 file.getParentFile().mkdirs();
@@ -446,12 +562,12 @@ private void saveImage(final String folderName, final String fileName, final Bit
                         new MediaScannerConnection.OnScanCompletedListener() {
                             @Override
                             public void onScanCompleted(final String path, final Uri uri) {
-                                if (mListener != null) {
-                                    mHandler.post(new Runnable() {
+                                if (listener != null) {
+                                    handler.post(new Runnable() {
 
                                         @Override
                                         public void run() {
-                                            mListener.onPictureSaved(uri);
+                                            listener.onPictureSaved(uri);
                                         }
                                     });
                                 }
diff --git a/library/src/jp/co/cyberagent/android/gpuimage/PixelBuffer.java b/library/src/main/java/jp/co/cyberagent/android/gpuimage/PixelBuffer.java
similarity index 58%
rename from library/src/jp/co/cyberagent/android/gpuimage/PixelBuffer.java
rename to library/src/main/java/jp/co/cyberagent/android/gpuimage/PixelBuffer.java
index ac23f599..193ce1e1 100644
--- a/library/src/jp/co/cyberagent/android/gpuimage/PixelBuffer.java
+++ b/library/src/main/java/jp/co/cyberagent/android/gpuimage/PixelBuffer.java
@@ -1,13 +1,24 @@
 /*
- * Copyright (C) 2012 CyberAgent
- * Copyright (C) 2010 jsemler 
- * 
+ * Copyright (C) 2018 CyberAgent, Inc.
+ * Copyright (C) 2010 jsemler
+ *
  * Original publication without License
  * http://www.anddev.org/android-2d-3d-graphics-opengl-tutorials-f2/possible-to-do-opengl-off-screen-rendering-in-android-t13232.html#p41662
  */
 
 package jp.co.cyberagent.android.gpuimage;
 
+import android.graphics.Bitmap;
+import android.opengl.GLSurfaceView;
+import android.util.Log;
+
+import javax.microedition.khronos.egl.EGL10;
+import javax.microedition.khronos.egl.EGLConfig;
+import javax.microedition.khronos.egl.EGLContext;
+import javax.microedition.khronos.egl.EGLDisplay;
+import javax.microedition.khronos.egl.EGLSurface;
+import javax.microedition.khronos.opengles.GL10;
+
 import static javax.microedition.khronos.egl.EGL10.EGL_ALPHA_SIZE;
 import static javax.microedition.khronos.egl.EGL10.EGL_BLUE_SIZE;
 import static javax.microedition.khronos.egl.EGL10.EGL_DEFAULT_DISPLAY;
@@ -19,78 +30,63 @@
 import static javax.microedition.khronos.egl.EGL10.EGL_RED_SIZE;
 import static javax.microedition.khronos.egl.EGL10.EGL_STENCIL_SIZE;
 import static javax.microedition.khronos.egl.EGL10.EGL_WIDTH;
-import static javax.microedition.khronos.opengles.GL10.GL_RGBA;
-import static javax.microedition.khronos.opengles.GL10.GL_UNSIGNED_BYTE;
-
-import java.nio.IntBuffer;
-
-import javax.microedition.khronos.egl.EGL10;
-import javax.microedition.khronos.egl.EGLConfig;
-import javax.microedition.khronos.egl.EGLContext;
-import javax.microedition.khronos.egl.EGLDisplay;
-import javax.microedition.khronos.egl.EGLSurface;
-import javax.microedition.khronos.opengles.GL10;
-
-import android.graphics.Bitmap;
-import android.opengl.GLSurfaceView;
-import android.util.Log;
 
 public class PixelBuffer {
-    final static String TAG = "PixelBuffer";
-    final static boolean LIST_CONFIGS = false;
+    private final static String TAG = "PixelBuffer";
+    private final static boolean LIST_CONFIGS = false;
 
-    GLSurfaceView.Renderer mRenderer; // borrow this interface
-    int mWidth, mHeight;
-    Bitmap mBitmap;
+    private GLSurfaceView.Renderer renderer; // borrow this interface
+    private int width, height;
+    private Bitmap bitmap;
 
-    EGL10 mEGL;
-    EGLDisplay mEGLDisplay;
-    EGLConfig[] mEGLConfigs;
-    EGLConfig mEGLConfig;
-    EGLContext mEGLContext;
-    EGLSurface mEGLSurface;
-    GL10 mGL;
+    private EGL10 egl10;
+    private EGLDisplay eglDisplay;
+    private EGLConfig[] eglConfigs;
+    private EGLConfig eglConfig;
+    private EGLContext eglContext;
+    private EGLSurface eglSurface;
+    private GL10 gl10;
 
-    String mThreadOwner;
+    private String mThreadOwner;
 
     public PixelBuffer(final int width, final int height) {
-        mWidth = width;
-        mHeight = height;
+        this.width = width;
+        this.height = height;
 
         int[] version = new int[2];
-        int[] attribList = new int[] {
-                EGL_WIDTH, mWidth,
-                EGL_HEIGHT, mHeight,
+        int[] attribList = new int[]{
+                EGL_WIDTH, this.width,
+                EGL_HEIGHT, this.height,
                 EGL_NONE
         };
 
         // No error checking performed, minimum required code to elucidate logic
-        mEGL = (EGL10) EGLContext.getEGL();
-        mEGLDisplay = mEGL.eglGetDisplay(EGL_DEFAULT_DISPLAY);
-        mEGL.eglInitialize(mEGLDisplay, version);
-        mEGLConfig = chooseConfig(); // Choosing a config is a little more
-                                     // complicated
+        egl10 = (EGL10) EGLContext.getEGL();
+        eglDisplay = egl10.eglGetDisplay(EGL_DEFAULT_DISPLAY);
+        egl10.eglInitialize(eglDisplay, version);
+        eglConfig = chooseConfig(); // Choosing a config is a little more
+        // complicated
 
-        // mEGLContext = mEGL.eglCreateContext(mEGLDisplay, mEGLConfig,
+        // eglContext = egl10.eglCreateContext(eglDisplay, eglConfig,
         // EGL_NO_CONTEXT, null);
         int EGL_CONTEXT_CLIENT_VERSION = 0x3098;
         int[] attrib_list = {
                 EGL_CONTEXT_CLIENT_VERSION, 2,
                 EGL10.EGL_NONE
         };
-        mEGLContext = mEGL.eglCreateContext(mEGLDisplay, mEGLConfig, EGL_NO_CONTEXT, attrib_list);
+        eglContext = egl10.eglCreateContext(eglDisplay, eglConfig, EGL_NO_CONTEXT, attrib_list);
 
-        mEGLSurface = mEGL.eglCreatePbufferSurface(mEGLDisplay, mEGLConfig, attribList);
-        mEGL.eglMakeCurrent(mEGLDisplay, mEGLSurface, mEGLSurface, mEGLContext);
+        eglSurface = egl10.eglCreatePbufferSurface(eglDisplay, eglConfig, attribList);
+        egl10.eglMakeCurrent(eglDisplay, eglSurface, eglSurface, eglContext);
 
-        mGL = (GL10) mEGLContext.getGL();
+        gl10 = (GL10) eglContext.getGL();
 
         // Record thread owner of OpenGL context
         mThreadOwner = Thread.currentThread().getName();
     }
 
     public void setRenderer(final GLSurfaceView.Renderer renderer) {
-        mRenderer = renderer;
+        this.renderer = renderer;
 
         // Does this thread own the OpenGL context?
         if (!Thread.currentThread().getName().equals(mThreadOwner)) {
@@ -99,13 +95,13 @@ public void setRenderer(final GLSurfaceView.Renderer renderer) {
         }
 
         // Call the renderer initialization routines
-        mRenderer.onSurfaceCreated(mGL, mEGLConfig);
-        mRenderer.onSurfaceChanged(mGL, mWidth, mHeight);
+        this.renderer.onSurfaceCreated(gl10, eglConfig);
+        this.renderer.onSurfaceChanged(gl10, width, height);
     }
 
     public Bitmap getBitmap() {
         // Do we have a renderer?
-        if (mRenderer == null) {
+        if (renderer == null) {
             Log.e(TAG, "getBitmap: Renderer was not set.");
             return null;
         }
@@ -118,25 +114,25 @@ public Bitmap getBitmap() {
 
         // Call the renderer draw routine (it seems that some filters do not
         // work if this is only called once)
-        mRenderer.onDrawFrame(mGL);
-        mRenderer.onDrawFrame(mGL);
+        renderer.onDrawFrame(gl10);
+        renderer.onDrawFrame(gl10);
         convertToBitmap();
-        return mBitmap;
+        return bitmap;
     }
 
     public void destroy() {
-        mRenderer.onDrawFrame(mGL);
-        mRenderer.onDrawFrame(mGL);
-        mEGL.eglMakeCurrent(mEGLDisplay, EGL10.EGL_NO_SURFACE,
+        renderer.onDrawFrame(gl10);
+        renderer.onDrawFrame(gl10);
+        egl10.eglMakeCurrent(eglDisplay, EGL10.EGL_NO_SURFACE,
                 EGL10.EGL_NO_SURFACE, EGL10.EGL_NO_CONTEXT);
 
-        mEGL.eglDestroySurface(mEGLDisplay, mEGLSurface);
-        mEGL.eglDestroyContext(mEGLDisplay, mEGLContext);
-        mEGL.eglTerminate(mEGLDisplay);
+        egl10.eglDestroySurface(eglDisplay, eglSurface);
+        egl10.eglDestroyContext(eglDisplay, eglContext);
+        egl10.eglTerminate(eglDisplay);
     }
 
     private EGLConfig chooseConfig() {
-        int[] attribList = new int[] {
+        int[] attribList = new int[]{
                 EGL_DEPTH_SIZE, 0,
                 EGL_STENCIL_SIZE, 0,
                 EGL_RED_SIZE, 8,
@@ -150,22 +146,22 @@ private EGLConfig chooseConfig() {
         // No error checking performed, minimum required code to elucidate logic
         // Expand on this logic to be more selective in choosing a configuration
         int[] numConfig = new int[1];
-        mEGL.eglChooseConfig(mEGLDisplay, attribList, null, 0, numConfig);
+        egl10.eglChooseConfig(eglDisplay, attribList, null, 0, numConfig);
         int configSize = numConfig[0];
-        mEGLConfigs = new EGLConfig[configSize];
-        mEGL.eglChooseConfig(mEGLDisplay, attribList, mEGLConfigs, configSize, numConfig);
+        eglConfigs = new EGLConfig[configSize];
+        egl10.eglChooseConfig(eglDisplay, attribList, eglConfigs, configSize, numConfig);
 
         if (LIST_CONFIGS) {
             listConfig();
         }
 
-        return mEGLConfigs[0]; // Best match is probably the first configuration
+        return eglConfigs[0]; // Best match is probably the first configuration
     }
 
     private void listConfig() {
         Log.i(TAG, "Config List {");
 
-        for (EGLConfig config : mEGLConfigs) {
+        for (EGLConfig config : eglConfigs) {
             int d, s, r, g, b, a;
 
             // Expand on this logic to dump other attributes
@@ -184,27 +180,12 @@ private void listConfig() {
 
     private int getConfigAttrib(final EGLConfig config, final int attribute) {
         int[] value = new int[1];
-        return mEGL.eglGetConfigAttrib(mEGLDisplay, config,
+        return egl10.eglGetConfigAttrib(eglDisplay, config,
                 attribute, value) ? value[0] : 0;
     }
 
     private void convertToBitmap() {
-        int[] iat = new int[mWidth * mHeight];
-        IntBuffer ib = IntBuffer.allocate(mWidth * mHeight);
-        mGL.glReadPixels(0, 0, mWidth, mHeight, GL_RGBA, GL_UNSIGNED_BYTE, ib);
-        int[] ia = ib.array();
-
-        //Stupid !
-        // Convert upside down mirror-reversed image to right-side up normal
-        // image.
-        for (int i = 0; i < mHeight; i++) {
-            for (int j = 0; j < mWidth; j++) {
-                iat[(mHeight - i - 1) * mWidth + j] = ia[i * mWidth + j];
-            }
-        }
-        
-
-        mBitmap = Bitmap.createBitmap(mWidth, mHeight, Bitmap.Config.ARGB_8888);
-        mBitmap.copyPixelsFromBuffer(IntBuffer.wrap(iat));
+        bitmap = Bitmap.createBitmap(width, height, Bitmap.Config.ARGB_8888);
+        GPUImageNativeLibrary.adjustBitmap(bitmap);
     }
 }
diff --git a/library/src/jp/co/cyberagent/android/gpuimage/GPUImage3x3ConvolutionFilter.java b/library/src/main/java/jp/co/cyberagent/android/gpuimage/filter/GPUImage3x3ConvolutionFilter.java
similarity index 56%
rename from library/src/jp/co/cyberagent/android/gpuimage/GPUImage3x3ConvolutionFilter.java
rename to library/src/main/java/jp/co/cyberagent/android/gpuimage/filter/GPUImage3x3ConvolutionFilter.java
index 0c5e5a03..e6485e96 100644
--- a/library/src/jp/co/cyberagent/android/gpuimage/GPUImage3x3ConvolutionFilter.java
+++ b/library/src/main/java/jp/co/cyberagent/android/gpuimage/filter/GPUImage3x3ConvolutionFilter.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2012 CyberAgent
+ * Copyright (C) 2018 CyberAgent, Inc.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -14,7 +14,7 @@
  * limitations under the License.
  */
 
-package jp.co.cyberagent.android.gpuimage;
+package jp.co.cyberagent.android.gpuimage.filter;
 
 import android.opengl.GLES20;
 
@@ -23,58 +23,58 @@
  */
 public class GPUImage3x3ConvolutionFilter extends GPUImage3x3TextureSamplingFilter {
     public static final String THREE_X_THREE_TEXTURE_SAMPLING_FRAGMENT_SHADER = "" +
-            "precision highp float;\n" + 
-            "\n" + 
-            "uniform sampler2D inputImageTexture;\n" + 
-            "\n" + 
-            "uniform mediump mat3 convolutionMatrix;\n" + 
-            "\n" + 
-            "varying vec2 textureCoordinate;\n" + 
-            "varying vec2 leftTextureCoordinate;\n" + 
-            "varying vec2 rightTextureCoordinate;\n" + 
-            "\n" + 
-            "varying vec2 topTextureCoordinate;\n" + 
-            "varying vec2 topLeftTextureCoordinate;\n" + 
-            "varying vec2 topRightTextureCoordinate;\n" + 
-            "\n" + 
-            "varying vec2 bottomTextureCoordinate;\n" + 
-            "varying vec2 bottomLeftTextureCoordinate;\n" + 
-            "varying vec2 bottomRightTextureCoordinate;\n" + 
-            "\n" + 
-            "void main()\n" + 
-            "{\n" + 
-            "    mediump vec4 bottomColor = texture2D(inputImageTexture, bottomTextureCoordinate);\n" + 
-            "    mediump vec4 bottomLeftColor = texture2D(inputImageTexture, bottomLeftTextureCoordinate);\n" + 
-            "    mediump vec4 bottomRightColor = texture2D(inputImageTexture, bottomRightTextureCoordinate);\n" + 
-            "    mediump vec4 centerColor = texture2D(inputImageTexture, textureCoordinate);\n" + 
-            "    mediump vec4 leftColor = texture2D(inputImageTexture, leftTextureCoordinate);\n" + 
-            "    mediump vec4 rightColor = texture2D(inputImageTexture, rightTextureCoordinate);\n" + 
-            "    mediump vec4 topColor = texture2D(inputImageTexture, topTextureCoordinate);\n" + 
-            "    mediump vec4 topRightColor = texture2D(inputImageTexture, topRightTextureCoordinate);\n" + 
-            "    mediump vec4 topLeftColor = texture2D(inputImageTexture, topLeftTextureCoordinate);\n" + 
-            "\n" + 
-            "    mediump vec4 resultColor = topLeftColor * convolutionMatrix[0][0] + topColor * convolutionMatrix[0][1] + topRightColor * convolutionMatrix[0][2];\n" + 
-            "    resultColor += leftColor * convolutionMatrix[1][0] + centerColor * convolutionMatrix[1][1] + rightColor * convolutionMatrix[1][2];\n" + 
-            "    resultColor += bottomLeftColor * convolutionMatrix[2][0] + bottomColor * convolutionMatrix[2][1] + bottomRightColor * convolutionMatrix[2][2];\n" + 
-            "\n" + 
-            "    gl_FragColor = resultColor;\n" + 
-            "}"; 
- 
-    private float[] mConvolutionKernel;
-    private int mUniformConvolutionMatrix;
+            "precision highp float;\n" +
+            "\n" +
+            "uniform sampler2D inputImageTexture;\n" +
+            "\n" +
+            "uniform mediump mat3 convolutionMatrix;\n" +
+            "\n" +
+            "varying vec2 textureCoordinate;\n" +
+            "varying vec2 leftTextureCoordinate;\n" +
+            "varying vec2 rightTextureCoordinate;\n" +
+            "\n" +
+            "varying vec2 topTextureCoordinate;\n" +
+            "varying vec2 topLeftTextureCoordinate;\n" +
+            "varying vec2 topRightTextureCoordinate;\n" +
+            "\n" +
+            "varying vec2 bottomTextureCoordinate;\n" +
+            "varying vec2 bottomLeftTextureCoordinate;\n" +
+            "varying vec2 bottomRightTextureCoordinate;\n" +
+            "\n" +
+            "void main()\n" +
+            "{\n" +
+            "    mediump vec4 bottomColor = texture2D(inputImageTexture, bottomTextureCoordinate);\n" +
+            "    mediump vec4 bottomLeftColor = texture2D(inputImageTexture, bottomLeftTextureCoordinate);\n" +
+            "    mediump vec4 bottomRightColor = texture2D(inputImageTexture, bottomRightTextureCoordinate);\n" +
+            "    mediump vec4 centerColor = texture2D(inputImageTexture, textureCoordinate);\n" +
+            "    mediump vec4 leftColor = texture2D(inputImageTexture, leftTextureCoordinate);\n" +
+            "    mediump vec4 rightColor = texture2D(inputImageTexture, rightTextureCoordinate);\n" +
+            "    mediump vec4 topColor = texture2D(inputImageTexture, topTextureCoordinate);\n" +
+            "    mediump vec4 topRightColor = texture2D(inputImageTexture, topRightTextureCoordinate);\n" +
+            "    mediump vec4 topLeftColor = texture2D(inputImageTexture, topLeftTextureCoordinate);\n" +
+            "\n" +
+            "    mediump vec4 resultColor = topLeftColor * convolutionMatrix[0][0] + topColor * convolutionMatrix[0][1] + topRightColor * convolutionMatrix[0][2];\n" +
+            "    resultColor += leftColor * convolutionMatrix[1][0] + centerColor * convolutionMatrix[1][1] + rightColor * convolutionMatrix[1][2];\n" +
+            "    resultColor += bottomLeftColor * convolutionMatrix[2][0] + bottomColor * convolutionMatrix[2][1] + bottomRightColor * convolutionMatrix[2][2];\n" +
+            "\n" +
+            "    gl_FragColor = resultColor;\n" +
+            "}";
+
+    private float[] convolutionKernel;
+    private int uniformConvolutionMatrix;
 
     /**
      * Instantiates a new GPUimage3x3ConvolutionFilter with default values, that
-     * will look like the original image. 
+     * will look like the original image.
      */
     public GPUImage3x3ConvolutionFilter() {
-        this(new float[] {
+        this(new float[]{
                 0.0f, 0.0f, 0.0f,
                 0.0f, 1.0f, 0.0f,
                 0.0f, 0.0f, 0.0f
         });
     }
-    
+
     /**
      * Instantiates a new GPUimage3x3ConvolutionFilter with given convolution kernel.
      *
@@ -82,14 +82,19 @@ public GPUImage3x3ConvolutionFilter() {
      */
     public GPUImage3x3ConvolutionFilter(final float[] convolutionKernel) {
         super(THREE_X_THREE_TEXTURE_SAMPLING_FRAGMENT_SHADER);
-        mConvolutionKernel = convolutionKernel;
+        this.convolutionKernel = convolutionKernel;
     }
 
     @Override
     public void onInit() {
         super.onInit();
-        mUniformConvolutionMatrix = GLES20.glGetUniformLocation(getProgram(), "convolutionMatrix");
-        setConvolutionKernel(mConvolutionKernel);
+        uniformConvolutionMatrix = GLES20.glGetUniformLocation(getProgram(), "convolutionMatrix");
+    }
+
+    @Override
+    public void onInitialized() {
+        super.onInitialized();
+        setConvolutionKernel(convolutionKernel);
     }
 
     /**
@@ -98,7 +103,7 @@ public void onInit() {
      * @param convolutionKernel the new convolution kernel
      */
     public void setConvolutionKernel(final float[] convolutionKernel) {
-        mConvolutionKernel = convolutionKernel;
-        setUniformMatrix3f(mUniformConvolutionMatrix, mConvolutionKernel);
+        this.convolutionKernel = convolutionKernel;
+        setUniformMatrix3f(uniformConvolutionMatrix, this.convolutionKernel);
     }
 }
diff --git a/library/src/main/java/jp/co/cyberagent/android/gpuimage/filter/GPUImage3x3TextureSamplingFilter.java b/library/src/main/java/jp/co/cyberagent/android/gpuimage/filter/GPUImage3x3TextureSamplingFilter.java
new file mode 100644
index 00000000..ac679890
--- /dev/null
+++ b/library/src/main/java/jp/co/cyberagent/android/gpuimage/filter/GPUImage3x3TextureSamplingFilter.java
@@ -0,0 +1,125 @@
+/*
+ * Copyright (C) 2018 CyberAgent, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package jp.co.cyberagent.android.gpuimage.filter;
+
+import android.opengl.GLES20;
+
+public class GPUImage3x3TextureSamplingFilter extends GPUImageFilter {
+    public static final String THREE_X_THREE_TEXTURE_SAMPLING_VERTEX_SHADER = "" +
+            "attribute vec4 position;\n" +
+            "attribute vec4 inputTextureCoordinate;\n" +
+            "\n" +
+            "uniform highp float texelWidth; \n" +
+            "uniform highp float texelHeight; \n" +
+            "\n" +
+            "varying vec2 textureCoordinate;\n" +
+            "varying vec2 leftTextureCoordinate;\n" +
+            "varying vec2 rightTextureCoordinate;\n" +
+            "\n" +
+            "varying vec2 topTextureCoordinate;\n" +
+            "varying vec2 topLeftTextureCoordinate;\n" +
+            "varying vec2 topRightTextureCoordinate;\n" +
+            "\n" +
+            "varying vec2 bottomTextureCoordinate;\n" +
+            "varying vec2 bottomLeftTextureCoordinate;\n" +
+            "varying vec2 bottomRightTextureCoordinate;\n" +
+            "\n" +
+            "void main()\n" +
+            "{\n" +
+            "    gl_Position = position;\n" +
+            "\n" +
+            "    vec2 widthStep = vec2(texelWidth, 0.0);\n" +
+            "    vec2 heightStep = vec2(0.0, texelHeight);\n" +
+            "    vec2 widthHeightStep = vec2(texelWidth, texelHeight);\n" +
+            "    vec2 widthNegativeHeightStep = vec2(texelWidth, -texelHeight);\n" +
+            "\n" +
+            "    textureCoordinate = inputTextureCoordinate.xy;\n" +
+            "    leftTextureCoordinate = inputTextureCoordinate.xy - widthStep;\n" +
+            "    rightTextureCoordinate = inputTextureCoordinate.xy + widthStep;\n" +
+            "\n" +
+            "    topTextureCoordinate = inputTextureCoordinate.xy - heightStep;\n" +
+            "    topLeftTextureCoordinate = inputTextureCoordinate.xy - widthHeightStep;\n" +
+            "    topRightTextureCoordinate = inputTextureCoordinate.xy + widthNegativeHeightStep;\n" +
+            "\n" +
+            "    bottomTextureCoordinate = inputTextureCoordinate.xy + heightStep;\n" +
+            "    bottomLeftTextureCoordinate = inputTextureCoordinate.xy - widthNegativeHeightStep;\n" +
+            "    bottomRightTextureCoordinate = inputTextureCoordinate.xy + widthHeightStep;\n" +
+            "}";
+
+    private int uniformTexelWidthLocation;
+    private int uniformTexelHeightLocation;
+
+    private boolean hasOverriddenImageSizeFactor = false;
+    private float texelWidth;
+    private float texelHeight;
+    private float lineSize = 1.0f;
+
+    public GPUImage3x3TextureSamplingFilter() {
+        this(NO_FILTER_VERTEX_SHADER);
+    }
+
+    public GPUImage3x3TextureSamplingFilter(final String fragmentShader) {
+        super(THREE_X_THREE_TEXTURE_SAMPLING_VERTEX_SHADER, fragmentShader);
+    }
+
+    @Override
+    public void onInit() {
+        super.onInit();
+        uniformTexelWidthLocation = GLES20.glGetUniformLocation(getProgram(), "texelWidth");
+        uniformTexelHeightLocation = GLES20.glGetUniformLocation(getProgram(), "texelHeight");
+    }
+
+    @Override
+    public void onInitialized() {
+        super.onInitialized();
+        if (texelWidth != 0) {
+            updateTexelValues();
+        }
+    }
+
+    @Override
+    public void onOutputSizeChanged(final int width, final int height) {
+        super.onOutputSizeChanged(width, height);
+        if (!hasOverriddenImageSizeFactor) {
+            setLineSize(lineSize);
+        }
+    }
+
+    public void setTexelWidth(final float texelWidth) {
+        hasOverriddenImageSizeFactor = true;
+        this.texelWidth = texelWidth;
+        setFloat(uniformTexelWidthLocation, texelWidth);
+    }
+
+    public void setTexelHeight(final float texelHeight) {
+        hasOverriddenImageSizeFactor = true;
+        this.texelHeight = texelHeight;
+        setFloat(uniformTexelHeightLocation, texelHeight);
+    }
+
+    public void setLineSize(final float size) {
+        lineSize = size;
+        texelWidth = size / getOutputWidth();
+        texelHeight = size / getOutputHeight();
+        updateTexelValues();
+    }
+
+    private void updateTexelValues() {
+        setFloat(uniformTexelWidthLocation, texelWidth);
+        setFloat(uniformTexelHeightLocation, texelHeight);
+    }
+}
diff --git a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageAddBlendFilter.java b/library/src/main/java/jp/co/cyberagent/android/gpuimage/filter/GPUImageAddBlendFilter.java
similarity index 96%
rename from library/src/jp/co/cyberagent/android/gpuimage/GPUImageAddBlendFilter.java
rename to library/src/main/java/jp/co/cyberagent/android/gpuimage/filter/GPUImageAddBlendFilter.java
index 59dcb343..750daf91 100644
--- a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageAddBlendFilter.java
+++ b/library/src/main/java/jp/co/cyberagent/android/gpuimage/filter/GPUImageAddBlendFilter.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2012 CyberAgent
+ * Copyright (C) 2018 CyberAgent, Inc.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -14,7 +14,7 @@
  * limitations under the License.
  */
 
-package jp.co.cyberagent.android.gpuimage;
+package jp.co.cyberagent.android.gpuimage.filter;
 
 public class GPUImageAddBlendFilter extends GPUImageTwoInputFilter {
     public static final String ADD_BLEND_FRAGMENT_SHADER = "varying highp vec2 textureCoordinate;\n" +
diff --git a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageAlphaBlendFilter.java b/library/src/main/java/jp/co/cyberagent/android/gpuimage/filter/GPUImageAlphaBlendFilter.java
similarity index 94%
rename from library/src/jp/co/cyberagent/android/gpuimage/GPUImageAlphaBlendFilter.java
rename to library/src/main/java/jp/co/cyberagent/android/gpuimage/filter/GPUImageAlphaBlendFilter.java
index 753c24d6..c5977692 100644
--- a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageAlphaBlendFilter.java
+++ b/library/src/main/java/jp/co/cyberagent/android/gpuimage/filter/GPUImageAlphaBlendFilter.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2012 CyberAgent
+ * Copyright (C) 2018 CyberAgent, Inc.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -14,12 +14,12 @@
  * limitations under the License.
  */
 
-package jp.co.cyberagent.android.gpuimage;
+package jp.co.cyberagent.android.gpuimage.filter;
 
 /**
  * Mix ranges from 0.0 (only image 1) to 1.0 (only image 2), with 0.5 (half of either) as the normal level
  */
-public class GPUImageAlphaBlendFilter extends GPUImageMixBlendFilter{
+public class GPUImageAlphaBlendFilter extends GPUImageMixBlendFilter {
     public static final String ALPHA_BLEND_FRAGMENT_SHADER = "varying highp vec2 textureCoordinate;\n" +
             " varying highp vec2 textureCoordinate2;\n" +
             "\n" +
diff --git a/library/src/main/java/jp/co/cyberagent/android/gpuimage/filter/GPUImageBilateralBlurFilter.java b/library/src/main/java/jp/co/cyberagent/android/gpuimage/filter/GPUImageBilateralBlurFilter.java
new file mode 100644
index 00000000..38015e3d
--- /dev/null
+++ b/library/src/main/java/jp/co/cyberagent/android/gpuimage/filter/GPUImageBilateralBlurFilter.java
@@ -0,0 +1,153 @@
+/**
+ * @author wysaid
+ * @mail admin@wysaid.org
+ */
+
+package jp.co.cyberagent.android.gpuimage.filter;
+
+import android.opengl.GLES20;
+
+
+public class GPUImageBilateralBlurFilter extends GPUImageFilter {
+    public static final String BILATERAL_VERTEX_SHADER = "" +
+            "attribute vec4 position;\n" +
+            "attribute vec4 inputTextureCoordinate;\n" +
+
+            "const int GAUSSIAN_SAMPLES = 9;\n" +
+
+            "uniform vec2 singleStepOffset;\n" +
+
+            "varying vec2 textureCoordinate;\n" +
+            "varying vec2 blurCoordinates[GAUSSIAN_SAMPLES];\n" +
+
+            "void main()\n" +
+            "{\n" +
+            "	gl_Position = position;\n" +
+            "	textureCoordinate = inputTextureCoordinate.xy;\n" +
+
+            "	int multiplier = 0;\n" +
+            "	vec2 blurStep;\n" +
+
+            "	for (int i = 0; i < GAUSSIAN_SAMPLES; i++)\n" +
+            "	{\n" +
+            "		multiplier = (i - ((GAUSSIAN_SAMPLES - 1) / 2));\n" +
+
+            "		blurStep = float(multiplier) * singleStepOffset;\n" +
+            "		blurCoordinates[i] = inputTextureCoordinate.xy + blurStep;\n" +
+            "	}\n" +
+            "}";
+
+    public static final String BILATERAL_FRAGMENT_SHADER = "" +
+            "uniform sampler2D inputImageTexture;\n" +
+
+            " const lowp int GAUSSIAN_SAMPLES = 9;\n" +
+
+            " varying highp vec2 textureCoordinate;\n" +
+            " varying highp vec2 blurCoordinates[GAUSSIAN_SAMPLES];\n" +
+
+            " uniform mediump float distanceNormalizationFactor;\n" +
+
+            " void main()\n" +
+            " {\n" +
+            "     lowp vec4 centralColor;\n" +
+            "     lowp float gaussianWeightTotal;\n" +
+            "     lowp vec4 sum;\n" +
+            "     lowp vec4 sampleColor;\n" +
+            "     lowp float distanceFromCentralColor;\n" +
+            "     lowp float gaussianWeight;\n" +
+            "     \n" +
+            "     centralColor = texture2D(inputImageTexture, blurCoordinates[4]);\n" +
+            "     gaussianWeightTotal = 0.18;\n" +
+            "     sum = centralColor * 0.18;\n" +
+            "     \n" +
+            "     sampleColor = texture2D(inputImageTexture, blurCoordinates[0]);\n" +
+            "     distanceFromCentralColor = min(distance(centralColor, sampleColor) * distanceNormalizationFactor, 1.0);\n" +
+            "     gaussianWeight = 0.05 * (1.0 - distanceFromCentralColor);\n" +
+            "     gaussianWeightTotal += gaussianWeight;\n" +
+            "     sum += sampleColor * gaussianWeight;\n" +
+
+            "     sampleColor = texture2D(inputImageTexture, blurCoordinates[1]);\n" +
+            "     distanceFromCentralColor = min(distance(centralColor, sampleColor) * distanceNormalizationFactor, 1.0);\n" +
+            "     gaussianWeight = 0.09 * (1.0 - distanceFromCentralColor);\n" +
+            "     gaussianWeightTotal += gaussianWeight;\n" +
+            "     sum += sampleColor * gaussianWeight;\n" +
+
+            "     sampleColor = texture2D(inputImageTexture, blurCoordinates[2]);\n" +
+            "     distanceFromCentralColor = min(distance(centralColor, sampleColor) * distanceNormalizationFactor, 1.0);\n" +
+            "     gaussianWeight = 0.12 * (1.0 - distanceFromCentralColor);\n" +
+            "     gaussianWeightTotal += gaussianWeight;\n" +
+            "     sum += sampleColor * gaussianWeight;\n" +
+
+            "     sampleColor = texture2D(inputImageTexture, blurCoordinates[3]);\n" +
+            "     distanceFromCentralColor = min(distance(centralColor, sampleColor) * distanceNormalizationFactor, 1.0);\n" +
+            "     gaussianWeight = 0.15 * (1.0 - distanceFromCentralColor);\n" +
+            "     gaussianWeightTotal += gaussianWeight;\n" +
+            "     sum += sampleColor * gaussianWeight;\n" +
+
+            "     sampleColor = texture2D(inputImageTexture, blurCoordinates[5]);\n" +
+            "     distanceFromCentralColor = min(distance(centralColor, sampleColor) * distanceNormalizationFactor, 1.0);\n" +
+            "     gaussianWeight = 0.15 * (1.0 - distanceFromCentralColor);\n" +
+            "     gaussianWeightTotal += gaussianWeight;\n" +
+            "     sum += sampleColor * gaussianWeight;\n" +
+
+            "     sampleColor = texture2D(inputImageTexture, blurCoordinates[6]);\n" +
+            "     distanceFromCentralColor = min(distance(centralColor, sampleColor) * distanceNormalizationFactor, 1.0);\n" +
+            "     gaussianWeight = 0.12 * (1.0 - distanceFromCentralColor);\n" +
+            "     gaussianWeightTotal += gaussianWeight;\n" +
+            "     sum += sampleColor * gaussianWeight;\n" +
+
+            "     sampleColor = texture2D(inputImageTexture, blurCoordinates[7]);\n" +
+            "     distanceFromCentralColor = min(distance(centralColor, sampleColor) * distanceNormalizationFactor, 1.0);\n" +
+            "     gaussianWeight = 0.09 * (1.0 - distanceFromCentralColor);\n" +
+            "     gaussianWeightTotal += gaussianWeight;\n" +
+            "     sum += sampleColor * gaussianWeight;\n" +
+
+            "     sampleColor = texture2D(inputImageTexture, blurCoordinates[8]);\n" +
+            "     distanceFromCentralColor = min(distance(centralColor, sampleColor) * distanceNormalizationFactor, 1.0);\n" +
+            "     gaussianWeight = 0.05 * (1.0 - distanceFromCentralColor);\n" +
+            "     gaussianWeightTotal += gaussianWeight;\n" +
+            "     sum += sampleColor * gaussianWeight;\n" +
+            "     gl_FragColor = sum / gaussianWeightTotal;\n" +
+            " }";
+
+    private float distanceNormalizationFactor;
+    private int disFactorLocation;
+    private int singleStepOffsetLocation;
+
+    public GPUImageBilateralBlurFilter() {
+        this(8.0f);
+    }
+
+    public GPUImageBilateralBlurFilter(final float distanceNormalizationFactor) {
+        super(BILATERAL_VERTEX_SHADER, BILATERAL_FRAGMENT_SHADER);
+        this.distanceNormalizationFactor = distanceNormalizationFactor;
+    }
+
+    @Override
+    public void onInit() {
+        super.onInit();
+        disFactorLocation = GLES20.glGetUniformLocation(getProgram(), "distanceNormalizationFactor");
+        singleStepOffsetLocation = GLES20.glGetUniformLocation(getProgram(), "singleStepOffset");
+    }
+
+    @Override
+    public void onInitialized() {
+        super.onInitialized();
+        setDistanceNormalizationFactor(distanceNormalizationFactor);
+    }
+
+    public void setDistanceNormalizationFactor(final float newValue) {
+        distanceNormalizationFactor = newValue;
+        setFloat(disFactorLocation, newValue);
+    }
+
+    private void setTexelSize(final float w, final float h) {
+        setFloatVec2(singleStepOffsetLocation, new float[]{1.0f / w, 1.0f / h});
+    }
+
+    @Override
+    public void onOutputSizeChanged(final int width, final int height) {
+        super.onOutputSizeChanged(width, height);
+        setTexelSize(width, height);
+    }
+}
diff --git a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageBoxBlurFilter.java b/library/src/main/java/jp/co/cyberagent/android/gpuimage/filter/GPUImageBoxBlurFilter.java
similarity index 94%
rename from library/src/jp/co/cyberagent/android/gpuimage/GPUImageBoxBlurFilter.java
rename to library/src/main/java/jp/co/cyberagent/android/gpuimage/filter/GPUImageBoxBlurFilter.java
index 4e681b3c..2c400292 100644
--- a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageBoxBlurFilter.java
+++ b/library/src/main/java/jp/co/cyberagent/android/gpuimage/filter/GPUImageBoxBlurFilter.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2012 CyberAgent
+ * Copyright (C) 2018 CyberAgent, Inc.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -14,11 +14,11 @@
  * limitations under the License.
  */
 
-package jp.co.cyberagent.android.gpuimage;
+package jp.co.cyberagent.android.gpuimage.filter;
 
 /**
  * A hardware-accelerated 9-hit box blur of an image
- *
+ * <p>
  * scaling: for the size of the applied blur, default of 1.0
  */
 public class GPUImageBoxBlurFilter extends GPUImageTwoPassTextureSamplingFilter {
@@ -71,7 +71,7 @@
                     "gl_FragColor = fragmentColor;\n" +
                     "}\n";
 
-    private float blurSize = 1f;
+    private float blurSize;
 
     /**
      * Construct new BoxBlurFilter with default blur size of 1.0.
@@ -86,6 +86,12 @@ public GPUImageBoxBlurFilter(float blurSize) {
         this.blurSize = blurSize;
     }
 
+    @Override
+    public void onInitialized() {
+        super.onInitialized();
+        setBlurSize(blurSize);
+    }
+
     /**
      * A scaling for the size of the applied blur, default of 1.0
      *
diff --git a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageBrightnessFilter.java b/library/src/main/java/jp/co/cyberagent/android/gpuimage/filter/GPUImageBrightnessFilter.java
similarity index 80%
rename from library/src/jp/co/cyberagent/android/gpuimage/GPUImageBrightnessFilter.java
rename to library/src/main/java/jp/co/cyberagent/android/gpuimage/filter/GPUImageBrightnessFilter.java
index e528ee87..fe8f1028 100644
--- a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageBrightnessFilter.java
+++ b/library/src/main/java/jp/co/cyberagent/android/gpuimage/filter/GPUImageBrightnessFilter.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2012 CyberAgent
+ * Copyright (C) 2018 CyberAgent, Inc.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -14,7 +14,7 @@
  * limitations under the License.
  */
 
-package jp.co.cyberagent.android.gpuimage;
+package jp.co.cyberagent.android.gpuimage.filter;
 
 import android.opengl.GLES20;
 
@@ -35,8 +35,8 @@
             "     gl_FragColor = vec4((textureColor.rgb + vec3(brightness)), textureColor.w);\n" +
             " }";
 
-    private int mBrightnessLocation;
-    private float mBrightness;
+    private int brightnessLocation;
+    private float brightness;
 
     public GPUImageBrightnessFilter() {
         this(0.0f);
@@ -44,23 +44,23 @@ public GPUImageBrightnessFilter() {
 
     public GPUImageBrightnessFilter(final float brightness) {
         super(NO_FILTER_VERTEX_SHADER, BRIGHTNESS_FRAGMENT_SHADER);
-        mBrightness = brightness;
+        this.brightness = brightness;
     }
 
     @Override
     public void onInit() {
         super.onInit();
-        mBrightnessLocation = GLES20.glGetUniformLocation(getProgram(), "brightness");
+        brightnessLocation = GLES20.glGetUniformLocation(getProgram(), "brightness");
     }
 
     @Override
     public void onInitialized() {
         super.onInitialized();
-        setBrightness(mBrightness);
+        setBrightness(brightness);
     }
 
     public void setBrightness(final float brightness) {
-        mBrightness = brightness;
-        setFloat(mBrightnessLocation, mBrightness);
+        this.brightness = brightness;
+        setFloat(brightnessLocation, this.brightness);
     }
 }
diff --git a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageBulgeDistortionFilter.java b/library/src/main/java/jp/co/cyberagent/android/gpuimage/filter/GPUImageBulgeDistortionFilter.java
similarity index 72%
rename from library/src/jp/co/cyberagent/android/gpuimage/GPUImageBulgeDistortionFilter.java
rename to library/src/main/java/jp/co/cyberagent/android/gpuimage/filter/GPUImageBulgeDistortionFilter.java
index af49bedd..fe70c1fe 100644
--- a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageBulgeDistortionFilter.java
+++ b/library/src/main/java/jp/co/cyberagent/android/gpuimage/filter/GPUImageBulgeDistortionFilter.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2012 CyberAgent
+ * Copyright (C) 2018 CyberAgent, Inc.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -14,7 +14,7 @@
  * limitations under the License.
  */
 
-package jp.co.cyberagent.android.gpuimage;
+package jp.co.cyberagent.android.gpuimage.filter;
 
 import android.graphics.PointF;
 import android.opengl.GLES20;
@@ -49,14 +49,14 @@
             "gl_FragColor = texture2D(inputImageTexture, textureCoordinateToUse );    \n" +
             "}\n";
 
-    private float mScale;
-    private int mScaleLocation;
-    private float mRadius;
-    private int mRadiusLocation;
-    private PointF mCenter;
-    private int mCenterLocation;
-    private float mAspectRatio;
-    private int mAspectRatioLocation;
+    private float scale;
+    private int scaleLocation;
+    private float radius;
+    private int radiusLocation;
+    private PointF center;
+    private int centerLocation;
+    private float aspectRatio;
+    private int aspectRatioLocation;
 
     public GPUImageBulgeDistortionFilter() {
         this(0.25f, 0.5f, new PointF(0.5f, 0.5f));
@@ -64,38 +64,39 @@ public GPUImageBulgeDistortionFilter() {
 
     public GPUImageBulgeDistortionFilter(float radius, float scale, PointF center) {
         super(NO_FILTER_VERTEX_SHADER, BULGE_FRAGMENT_SHADER);
-        mRadius = radius;
-        mScale = scale;
-        mCenter = center;
+        this.radius = radius;
+        this.scale = scale;
+        this.center = center;
     }
 
     @Override
     public void onInit() {
         super.onInit();
-        mScaleLocation = GLES20.glGetUniformLocation(getProgram(), "scale");
-        mRadiusLocation = GLES20.glGetUniformLocation(getProgram(), "radius");
-        mCenterLocation = GLES20.glGetUniformLocation(getProgram(), "center");
-        mAspectRatioLocation = GLES20.glGetUniformLocation(getProgram(), "aspectRatio");
+        scaleLocation = GLES20.glGetUniformLocation(getProgram(), "scale");
+        radiusLocation = GLES20.glGetUniformLocation(getProgram(), "radius");
+        centerLocation = GLES20.glGetUniformLocation(getProgram(), "center");
+        aspectRatioLocation = GLES20.glGetUniformLocation(getProgram(), "aspectRatio");
     }
 
     @Override
     public void onInitialized() {
         super.onInitialized();
-        setRadius(mRadius);
-        setScale(mScale);
-        setCenter(mCenter);
+        setAspectRatio(aspectRatio);
+        setRadius(radius);
+        setScale(scale);
+        setCenter(center);
     }
 
     @Override
     public void onOutputSizeChanged(int width, int height) {
-        mAspectRatio = (float) height / width;
-        setAspectRatio(mAspectRatio);
+        aspectRatio = (float) height / width;
+        setAspectRatio(aspectRatio);
         super.onOutputSizeChanged(width, height);
     }
 
     private void setAspectRatio(float aspectRatio) {
-        mAspectRatio = aspectRatio;
-        setFloat(mAspectRatioLocation, aspectRatio);
+        this.aspectRatio = aspectRatio;
+        setFloat(aspectRatioLocation, aspectRatio);
     }
 
     /**
@@ -104,8 +105,8 @@ private void setAspectRatio(float aspectRatio) {
      * @param radius from 0.0 to 1.0, default 0.25
      */
     public void setRadius(float radius) {
-        mRadius = radius;
-        setFloat(mRadiusLocation, radius);
+        this.radius = radius;
+        setFloat(radiusLocation, radius);
     }
 
     /**
@@ -114,8 +115,8 @@ public void setRadius(float radius) {
      * @param scale from -1.0 to 1.0, default 0.5
      */
     public void setScale(float scale) {
-        mScale = scale;
-        setFloat(mScaleLocation, scale);
+        this.scale = scale;
+        setFloat(scaleLocation, scale);
     }
 
     /**
@@ -124,7 +125,7 @@ public void setScale(float scale) {
      * @param center default (0.5, 0.5)
      */
     public void setCenter(PointF center) {
-        mCenter = center;
-        setPoint(mCenterLocation, center);
+        this.center = center;
+        setPoint(centerLocation, center);
     }
 }
diff --git a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageCGAColorspaceFilter.java b/library/src/main/java/jp/co/cyberagent/android/gpuimage/filter/GPUImageCGAColorspaceFilter.java
similarity index 97%
rename from library/src/jp/co/cyberagent/android/gpuimage/GPUImageCGAColorspaceFilter.java
rename to library/src/main/java/jp/co/cyberagent/android/gpuimage/filter/GPUImageCGAColorspaceFilter.java
index 52585956..7ab1a7d8 100644
--- a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageCGAColorspaceFilter.java
+++ b/library/src/main/java/jp/co/cyberagent/android/gpuimage/filter/GPUImageCGAColorspaceFilter.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2012 CyberAgent
+ * Copyright (C) 2018 CyberAgent, Inc.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -14,7 +14,7 @@
  * limitations under the License.
  */
 
-package jp.co.cyberagent.android.gpuimage;
+package jp.co.cyberagent.android.gpuimage.filter;
 
 public class GPUImageCGAColorspaceFilter extends GPUImageFilter {
     public static final String CGACOLORSPACE_FRAGMENT_SHADER = "" +
diff --git a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageChromaKeyBlendFilter.java b/library/src/main/java/jp/co/cyberagent/android/gpuimage/filter/GPUImageChromaKeyBlendFilter.java
similarity index 69%
rename from library/src/jp/co/cyberagent/android/gpuimage/GPUImageChromaKeyBlendFilter.java
rename to library/src/main/java/jp/co/cyberagent/android/gpuimage/filter/GPUImageChromaKeyBlendFilter.java
index 7957b05a..18c78436 100644
--- a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageChromaKeyBlendFilter.java
+++ b/library/src/main/java/jp/co/cyberagent/android/gpuimage/filter/GPUImageChromaKeyBlendFilter.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2012 CyberAgent
+ * Copyright (C) 2018 CyberAgent, Inc.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -14,7 +14,7 @@
  * limitations under the License.
  */
 
-package jp.co.cyberagent.android.gpuimage;
+package jp.co.cyberagent.android.gpuimage.filter;
 
 import android.opengl.GLES20;
 
@@ -50,12 +50,12 @@
             "     gl_FragColor = mix(textureColor, textureColor2, blendValue);\n" +
             " }";
 
-    private int mThresholdSensitivityLocation;
-    private int mSmoothingLocation;
-    private int mColorToReplaceLocation;
-    private float mSmoothing = 0.1f;
-    private float mThresholdSensitivity = 0.3f;
-    private float[] mColorToReplace = new float[]{0.0f, 1.0f, 0.0f};
+    private int thresholdSensitivityLocation;
+    private int smoothingLocation;
+    private int colorToReplaceLocation;
+    private float thresholdSensitivity = 0.4f;
+    private float smoothing = 0.1f;
+    private float[] colorToReplace = new float[]{0.0f, 1.0f, 0.0f};
 
     public GPUImageChromaKeyBlendFilter() {
         super(CHROMA_KEY_BLEND_FRAGMENT_SHADER);
@@ -65,17 +65,17 @@ public GPUImageChromaKeyBlendFilter() {
     @Override
     public void onInit() {
         super.onInit();
-        mThresholdSensitivityLocation = GLES20.glGetUniformLocation(getProgram(), "thresholdSensitivity");
-        mSmoothingLocation = GLES20.glGetUniformLocation(getProgram(), "smoothing");
-        mColorToReplaceLocation = GLES20.glGetUniformLocation(getProgram(), "colorToReplace");
+        thresholdSensitivityLocation = GLES20.glGetUniformLocation(getProgram(), "thresholdSensitivity");
+        smoothingLocation = GLES20.glGetUniformLocation(getProgram(), "smoothing");
+        colorToReplaceLocation = GLES20.glGetUniformLocation(getProgram(), "colorToReplace");
     }
 
     @Override
     public void onInitialized() {
         super.onInitialized();
-        setSmoothing(mSmoothing);
-        setThresholdSensitivity(mThresholdSensitivity);
-        setColorToReplace(mColorToReplace[0], mColorToReplace[1], mColorToReplace[2]);
+        setSmoothing(smoothing);
+        setThresholdSensitivity(thresholdSensitivity);
+        setColorToReplace(colorToReplace[0], colorToReplace[1], colorToReplace[2]);
     }
 
     /**
@@ -83,8 +83,8 @@ public void onInitialized() {
      * The default value is 0.1
      */
     public void setSmoothing(final float smoothing) {
-        mSmoothing = smoothing;
-        setFloat(mSmoothingLocation, mSmoothing);
+        this.smoothing = smoothing;
+        setFloat(smoothingLocation, this.smoothing);
     }
 
     /**
@@ -92,19 +92,20 @@ public void setSmoothing(final float smoothing) {
      * The default value is 0.3
      */
     public void setThresholdSensitivity(final float thresholdSensitivity) {
-        mThresholdSensitivity = thresholdSensitivity;
-        setFloat(mThresholdSensitivityLocation, mThresholdSensitivity);
+        this.thresholdSensitivity = thresholdSensitivity;
+        setFloat(thresholdSensitivityLocation, this.thresholdSensitivity);
     }
 
-    /** The color to be replaced is specified using individual red, green, and blue components (normalized to 1.0).
+    /**
+     * The color to be replaced is specified using individual red, green, and blue components (normalized to 1.0).
      * The default is green: (0.0, 1.0, 0.0).
      *
-     * @param redComponent Red component of color to be replaced
+     * @param redComponent   Red component of color to be replaced
      * @param greenComponent Green component of color to be replaced
-     * @param blueComponent Blue component of color to be replaced
+     * @param blueComponent  Blue component of color to be replaced
      */
     public void setColorToReplace(float redComponent, float greenComponent, float blueComponent) {
-        mColorToReplace = new float[]{redComponent, greenComponent, blueComponent};
-        setFloatVec3(mColorToReplaceLocation, mColorToReplace);
+        colorToReplace = new float[]{redComponent, greenComponent, blueComponent};
+        setFloatVec3(colorToReplaceLocation, colorToReplace);
     }
 }
diff --git a/library/src/main/java/jp/co/cyberagent/android/gpuimage/filter/GPUImageColorBalanceFilter.java b/library/src/main/java/jp/co/cyberagent/android/gpuimage/filter/GPUImageColorBalanceFilter.java
new file mode 100644
index 00000000..ef9337dc
--- /dev/null
+++ b/library/src/main/java/jp/co/cyberagent/android/gpuimage/filter/GPUImageColorBalanceFilter.java
@@ -0,0 +1,197 @@
+package jp.co.cyberagent.android.gpuimage.filter;
+
+import android.opengl.GLES20;
+
+/**
+ * Created by edward_chiang on 13/10/16.
+ */
+public class GPUImageColorBalanceFilter extends GPUImageFilter {
+
+    public static final String GPU_IMAGE_COLOR_BALANCE_FRAGMENT_SHADER = "" +
+            "varying highp vec2 textureCoordinate;\n" +
+            "uniform sampler2D inputImageTexture;\n" +
+            "uniform lowp vec3 shadowsShift;\n" +
+            "uniform lowp vec3 midtonesShift;\n" +
+            "uniform lowp vec3 highlightsShift;\n" +
+            "uniform int preserveLuminosity;\n" +
+            "lowp vec3 RGBToHSL(lowp vec3 color)\n" +
+
+            "{\n" +
+            "lowp vec3 hsl; // init to 0 to avoid warnings ? (and reverse if + remove first part)\n" +
+
+            "lowp float fmin = min(min(color.r, color.g), color.b);    //Min. value of RGB\n" +
+            "lowp float fmax = max(max(color.r, color.g), color.b);    //Max. value of RGB\n" +
+            "lowp float delta = fmax - fmin;             //Delta RGB value\n" +
+
+            "hsl.z = (fmax + fmin) / 2.0; // Luminance\n" +
+
+            "if (delta == 0.0)		//This is a gray, no chroma...\n" +
+            "{\n" +
+            "    hsl.x = 0.0;	// Hue\n" +
+            "    hsl.y = 0.0;	// Saturation\n" +
+            "}\n" +
+            "else                                    //Chromatic data...\n" +
+            "{\n" +
+            "    if (hsl.z < 0.5)\n" +
+            "        hsl.y = delta / (fmax + fmin); // Saturation\n" +
+            "    else\n" +
+            "        hsl.y = delta / (2.0 - fmax - fmin); // Saturation\n" +
+            "\n" +
+            "    lowp float deltaR = (((fmax - color.r) / 6.0) + (delta / 2.0)) / delta;\n" +
+            "    lowp float deltaG = (((fmax - color.g) / 6.0) + (delta / 2.0)) / delta;\n" +
+            "    lowp float deltaB = (((fmax - color.b) / 6.0) + (delta / 2.0)) / delta;\n" +
+            "\n" +
+            "    if (color.r == fmax )\n" +
+            "        hsl.x = deltaB - deltaG; // Hue\n" +
+            "    else if (color.g == fmax)\n" +
+            "        hsl.x = (1.0 / 3.0) + deltaR - deltaB; // Hue\n" +
+            "    else if (color.b == fmax)\n" +
+            "        hsl.x = (2.0 / 3.0) + deltaG - deltaR; // Hue\n" +
+
+            "    if (hsl.x < 0.0)\n" +
+            "        hsl.x += 1.0; // Hue\n" +
+            "    else if (hsl.x > 1.0)\n" +
+            "        hsl.x -= 1.0; // Hue\n" +
+            "}\n" +
+            "\n" +
+            "return hsl;\n" +
+            "}\n" +
+
+            "lowp float HueToRGB(lowp float f1, lowp float f2, lowp float hue)\n" +
+            "{\n" +
+            "    if (hue < 0.0)\n" +
+            "        hue += 1.0;\n" +
+            "    else if (hue > 1.0)\n" +
+            "        hue -= 1.0;\n" +
+            "    lowp float res;\n" +
+            "    if ((6.0 * hue) < 1.0)\n" +
+            "        res = f1 + (f2 - f1) * 6.0 * hue;\n" +
+            "    else if ((2.0 * hue) < 1.0)\n" +
+            "        res = f2;\n" +
+            "    else if ((3.0 * hue) < 2.0)\n" +
+            "        res = f1 + (f2 - f1) * ((2.0 / 3.0) - hue) * 6.0;\n" +
+            "    else\n" +
+            "        res = f1;\n" +
+            "    return res;\n" +
+            "}\n" +
+
+            "lowp vec3 HSLToRGB(lowp vec3 hsl)\n" +
+            "{\n" +
+            "    lowp vec3 rgb;\n" +
+
+            "    if (hsl.y == 0.0)\n" +
+            "        rgb = vec3(hsl.z); // Luminance\n" +
+            "    else\n" +
+            "    {\n" +
+            "        lowp float f2;\n" +
+
+            "        if (hsl.z < 0.5)\n" +
+            "            f2 = hsl.z * (1.0 + hsl.y);\n" +
+            "        else\n" +
+            "            f2 = (hsl.z + hsl.y) - (hsl.y * hsl.z);\n" +
+
+            "        lowp float f1 = 2.0 * hsl.z - f2;\n" +
+
+            "        rgb.r = HueToRGB(f1, f2, hsl.x + (1.0/3.0));\n" +
+            "        rgb.g = HueToRGB(f1, f2, hsl.x);\n" +
+            "        rgb.b= HueToRGB(f1, f2, hsl.x - (1.0/3.0));\n" +
+            "    }\n" +
+
+            "    return rgb;\n  " +
+            "}\n" +
+
+            "lowp float RGBToL(lowp vec3 color)\n" +
+            "{\n" +
+            "    lowp float fmin = min(min(color.r, color.g), color.b);    //Min. value of RGB\n" +
+            "    lowp float fmax = max(max(color.r, color.g), color.b);    //Max. value of RGB\n" +
+
+            "    return (fmax + fmin) / 2.0; // Luminance\n" +
+            "}\n" +
+
+            "void main()\n" +
+            "{\n" +
+            "    lowp vec4 textureColor = texture2D(inputImageTexture, textureCoordinate);\n" +
+
+            "    // Alternative way:\n" +
+            "    //lowp vec3 lightness = RGBToL(textureColor.rgb);\n" +
+            "    lowp vec3 lightness = textureColor.rgb;\n" +
+
+            "    const lowp float a = 0.25;\n" +
+            "    const lowp float b = 0.333;\n" +
+            "    const lowp float scale = 0.7;\n" +
+
+            "    lowp vec3 shadows = shadowsShift * (clamp((lightness - b) / -a + 0.5, 0.0, 1.0) * scale);\n" +
+            "    lowp vec3 midtones = midtonesShift * (clamp((lightness - b) / a + 0.5, 0.0, 1.0) *\n" +
+            "        clamp((lightness + b - 1.0) / -a + 0.5, 0.0, 1.0) * scale);\n" +
+            "    lowp vec3 highlights = highlightsShift * (clamp((lightness + b - 1.0) / a + 0.5, 0.0, 1.0) * scale);\n" +
+
+            "    mediump vec3 newColor = textureColor.rgb + shadows + midtones + highlights;\n" +
+            "    newColor = clamp(newColor, 0.0, 1.0);\n    " +
+
+            "    if (preserveLuminosity != 0) {\n   " +
+            "        lowp vec3 newHSL = RGBToHSL(newColor);\n" +
+            "        lowp float oldLum = RGBToL(textureColor.rgb);\n" +
+            "        textureColor.rgb = HSLToRGB(vec3(newHSL.x, newHSL.y, oldLum));\n" +
+            "        gl_FragColor = textureColor;\n" +
+            "    } else {\n" +
+            "        gl_FragColor = vec4(newColor.rgb, textureColor.w);\n" +
+            "    }\n" +
+            "}\n";
+
+    private int shadowsLocation;
+    private int midtonesLocation;
+    private int highlightsLocation;
+    private int preserveLuminosityLocation;
+
+    private float[] showdows;
+    private float[] midtones;
+    private float[] highlights;
+    private boolean preserveLuminosity;
+
+
+    public GPUImageColorBalanceFilter() {
+        super(NO_FILTER_VERTEX_SHADER, GPU_IMAGE_COLOR_BALANCE_FRAGMENT_SHADER);
+        this.showdows = new float[]{0.0f, 0.0f, 0.0f};
+        this.midtones = new float[]{0.0f, 0.0f, 0.0f};
+        this.highlights = new float[]{0.0f, 0.0f, 0.0f};
+        this.preserveLuminosity = true;
+    }
+
+    @Override
+    public void onInit() {
+        super.onInit();
+        shadowsLocation = GLES20.glGetUniformLocation(getProgram(), "shadowsShift");
+        midtonesLocation = GLES20.glGetUniformLocation(getProgram(), "midtonesShift");
+        highlightsLocation = GLES20.glGetUniformLocation(getProgram(), "highlightsShift");
+        preserveLuminosityLocation = GLES20.glGetUniformLocation(getProgram(), "preserveLuminosity");
+    }
+
+    @Override
+    public void onInitialized() {
+        super.onInitialized();
+        setMidtones(midtones);
+        setShowdows(showdows);
+        setHighlights(highlights);
+        setPreserveLuminosity(preserveLuminosity);
+    }
+
+    public void setShowdows(float[] showdows) {
+        this.showdows = showdows;
+        setFloatVec3(shadowsLocation, showdows);
+    }
+
+    public void setMidtones(float[] midtones) {
+        this.midtones = midtones;
+        setFloatVec3(midtonesLocation, midtones);
+    }
+
+    public void setHighlights(float[] highlights) {
+        this.highlights = highlights;
+        setFloatVec3(highlightsLocation, highlights);
+    }
+
+    public void setPreserveLuminosity(boolean preserveLuminosity) {
+        this.preserveLuminosity = preserveLuminosity;
+        setInteger(preserveLuminosityLocation, preserveLuminosity ? 1 : 0);
+    }
+}
diff --git a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageColorBlendFilter.java b/library/src/main/java/jp/co/cyberagent/android/gpuimage/filter/GPUImageColorBlendFilter.java
similarity index 96%
rename from library/src/jp/co/cyberagent/android/gpuimage/GPUImageColorBlendFilter.java
rename to library/src/main/java/jp/co/cyberagent/android/gpuimage/filter/GPUImageColorBlendFilter.java
index 0f5de140..e29b7381 100644
--- a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageColorBlendFilter.java
+++ b/library/src/main/java/jp/co/cyberagent/android/gpuimage/filter/GPUImageColorBlendFilter.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2012 CyberAgent
+ * Copyright (C) 2018 CyberAgent, Inc.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -14,7 +14,7 @@
  * limitations under the License.
  */
 
-package jp.co.cyberagent.android.gpuimage;
+package jp.co.cyberagent.android.gpuimage.filter;
 
 public class GPUImageColorBlendFilter extends GPUImageTwoInputFilter {
     public static final String COLOR_BLEND_FRAGMENT_SHADER = "varying highp vec2 textureCoordinate;\n" +
diff --git a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageColorBurnBlendFilter.java b/library/src/main/java/jp/co/cyberagent/android/gpuimage/filter/GPUImageColorBurnBlendFilter.java
similarity index 94%
rename from library/src/jp/co/cyberagent/android/gpuimage/GPUImageColorBurnBlendFilter.java
rename to library/src/main/java/jp/co/cyberagent/android/gpuimage/filter/GPUImageColorBurnBlendFilter.java
index e3b5c42a..a3ff750a 100644
--- a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageColorBurnBlendFilter.java
+++ b/library/src/main/java/jp/co/cyberagent/android/gpuimage/filter/GPUImageColorBurnBlendFilter.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2012 CyberAgent
+ * Copyright (C) 2018 CyberAgent, Inc.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -14,7 +14,7 @@
  * limitations under the License.
  */
 
-package jp.co.cyberagent.android.gpuimage;
+package jp.co.cyberagent.android.gpuimage.filter;
 
 public class GPUImageColorBurnBlendFilter extends GPUImageTwoInputFilter {
     public static final String COLOR_BURN_BLEND_FRAGMENT_SHADER = "varying highp vec2 textureCoordinate;\n" +
diff --git a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageColorDodgeBlendFilter.java b/library/src/main/java/jp/co/cyberagent/android/gpuimage/filter/GPUImageColorDodgeBlendFilter.java
similarity index 96%
rename from library/src/jp/co/cyberagent/android/gpuimage/GPUImageColorDodgeBlendFilter.java
rename to library/src/main/java/jp/co/cyberagent/android/gpuimage/filter/GPUImageColorDodgeBlendFilter.java
index 702a3a98..4609c6cb 100644
--- a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageColorDodgeBlendFilter.java
+++ b/library/src/main/java/jp/co/cyberagent/android/gpuimage/filter/GPUImageColorDodgeBlendFilter.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2012 CyberAgent
+ * Copyright (C) 2018 CyberAgent, Inc.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -14,7 +14,7 @@
  * limitations under the License.
  */
 
-package jp.co.cyberagent.android.gpuimage;
+package jp.co.cyberagent.android.gpuimage.filter;
 
 public class GPUImageColorDodgeBlendFilter extends GPUImageTwoInputFilter {
     public static final String COLOR_DODGE_BLEND_FRAGMENT_SHADER = "precision mediump float;\n" +
diff --git a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageColorInvertFilter.java b/library/src/main/java/jp/co/cyberagent/android/gpuimage/filter/GPUImageColorInvertFilter.java
similarity index 93%
rename from library/src/jp/co/cyberagent/android/gpuimage/GPUImageColorInvertFilter.java
rename to library/src/main/java/jp/co/cyberagent/android/gpuimage/filter/GPUImageColorInvertFilter.java
index 2d8df9b9..7154ca69 100644
--- a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageColorInvertFilter.java
+++ b/library/src/main/java/jp/co/cyberagent/android/gpuimage/filter/GPUImageColorInvertFilter.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2012 CyberAgent
+ * Copyright (C) 2018 CyberAgent, Inc.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -14,7 +14,7 @@
  * limitations under the License.
  */
 
-package jp.co.cyberagent.android.gpuimage;
+package jp.co.cyberagent.android.gpuimage.filter;
 
 /**
  * Invert all the colors in the image.
diff --git a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageColorMatrixFilter.java b/library/src/main/java/jp/co/cyberagent/android/gpuimage/filter/GPUImageColorMatrixFilter.java
similarity index 73%
rename from library/src/jp/co/cyberagent/android/gpuimage/GPUImageColorMatrixFilter.java
rename to library/src/main/java/jp/co/cyberagent/android/gpuimage/filter/GPUImageColorMatrixFilter.java
index 59203c4d..a3e8ddd4 100644
--- a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageColorMatrixFilter.java
+++ b/library/src/main/java/jp/co/cyberagent/android/gpuimage/filter/GPUImageColorMatrixFilter.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2012 CyberAgent
+ * Copyright (C) 2018 CyberAgent, Inc.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -14,7 +14,7 @@
  * limitations under the License.
  */
 
-package jp.co.cyberagent.android.gpuimage;
+package jp.co.cyberagent.android.gpuimage.filter;
 
 import android.opengl.GLES20;
 
@@ -38,13 +38,13 @@
             "    gl_FragColor = (intensity * outputColor) + ((1.0 - intensity) * textureColor);\n" +
             "}";
 
-    private float mIntensity;
-    private float[] mColorMatrix;
-    private int mColorMatrixLocation;
-    private int mIntensityLocation;
+    private float intensity;
+    private float[] colorMatrix;
+    private int colorMatrixLocation;
+    private int intensityLocation;
 
     public GPUImageColorMatrixFilter() {
-        this(1.0f, new float[] {
+        this(1.0f, new float[]{
                 1.0f, 0.0f, 0.0f, 0.0f,
                 0.0f, 1.0f, 0.0f, 0.0f,
                 0.0f, 0.0f, 1.0f, 0.0f,
@@ -54,31 +54,31 @@ public GPUImageColorMatrixFilter() {
 
     public GPUImageColorMatrixFilter(final float intensity, final float[] colorMatrix) {
         super(NO_FILTER_VERTEX_SHADER, COLOR_MATRIX_FRAGMENT_SHADER);
-        mIntensity = intensity;
-        mColorMatrix = colorMatrix;
+        this.intensity = intensity;
+        this.colorMatrix = colorMatrix;
     }
 
     @Override
     public void onInit() {
         super.onInit();
-        mColorMatrixLocation = GLES20.glGetUniformLocation(getProgram(), "colorMatrix");
-        mIntensityLocation = GLES20.glGetUniformLocation(getProgram(), "intensity");
+        colorMatrixLocation = GLES20.glGetUniformLocation(getProgram(), "colorMatrix");
+        intensityLocation = GLES20.glGetUniformLocation(getProgram(), "intensity");
     }
 
     @Override
     public void onInitialized() {
         super.onInitialized();
-        setIntensity(mIntensity);
-        setColorMatrix(mColorMatrix);
+        setIntensity(intensity);
+        setColorMatrix(colorMatrix);
     }
 
     public void setIntensity(final float intensity) {
-        mIntensity = intensity;
-        setFloat(mIntensityLocation, intensity);
+        this.intensity = intensity;
+        setFloat(intensityLocation, intensity);
     }
 
     public void setColorMatrix(final float[] colorMatrix) {
-        mColorMatrix = colorMatrix;
-        setUniformMatrix4f(mColorMatrixLocation, colorMatrix);
+        this.colorMatrix = colorMatrix;
+        setUniformMatrix4f(colorMatrixLocation, colorMatrix);
     }
 }
diff --git a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageContrastFilter.java b/library/src/main/java/jp/co/cyberagent/android/gpuimage/filter/GPUImageContrastFilter.java
similarity index 65%
rename from library/src/jp/co/cyberagent/android/gpuimage/GPUImageContrastFilter.java
rename to library/src/main/java/jp/co/cyberagent/android/gpuimage/filter/GPUImageContrastFilter.java
index 1d2b9107..bd890f73 100644
--- a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageContrastFilter.java
+++ b/library/src/main/java/jp/co/cyberagent/android/gpuimage/filter/GPUImageContrastFilter.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2012 CyberAgent
+ * Copyright (C) 2018 CyberAgent, Inc.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -14,7 +14,7 @@
  * limitations under the License.
  */
 
-package jp.co.cyberagent.android.gpuimage;
+package jp.co.cyberagent.android.gpuimage.filter;
 
 import android.opengl.GLES20;
 
@@ -25,44 +25,44 @@
  */
 public class GPUImageContrastFilter extends GPUImageFilter {
     public static final String CONTRAST_FRAGMENT_SHADER = "" +
-            "varying highp vec2 textureCoordinate;\n" + 
-            " \n" + 
-            " uniform sampler2D inputImageTexture;\n" + 
-            " uniform lowp float contrast;\n" + 
-            " \n" + 
-            " void main()\n" + 
-            " {\n" + 
-            "     lowp vec4 textureColor = texture2D(inputImageTexture, textureCoordinate);\n" + 
-            "     \n" + 
-            "     gl_FragColor = vec4(((textureColor.rgb - vec3(0.5)) * contrast + vec3(0.5)), textureColor.w);\n" + 
+            "varying highp vec2 textureCoordinate;\n" +
+            " \n" +
+            " uniform sampler2D inputImageTexture;\n" +
+            " uniform lowp float contrast;\n" +
+            " \n" +
+            " void main()\n" +
+            " {\n" +
+            "     lowp vec4 textureColor = texture2D(inputImageTexture, textureCoordinate);\n" +
+            "     \n" +
+            "     gl_FragColor = vec4(((textureColor.rgb - vec3(0.5)) * contrast + vec3(0.5)), textureColor.w);\n" +
             " }";
 
-    private int mContrastLocation;
-    private float mContrast;
+    private int contrastLocation;
+    private float contrast;
 
     public GPUImageContrastFilter() {
         this(1.2f);
     }
-    
+
     public GPUImageContrastFilter(float contrast) {
         super(NO_FILTER_VERTEX_SHADER, CONTRAST_FRAGMENT_SHADER);
-        mContrast = contrast;
+        this.contrast = contrast;
     }
 
     @Override
     public void onInit() {
         super.onInit();
-        mContrastLocation = GLES20.glGetUniformLocation(getProgram(), "contrast");
+        contrastLocation = GLES20.glGetUniformLocation(getProgram(), "contrast");
     }
 
     @Override
     public void onInitialized() {
         super.onInitialized();
-        setContrast(mContrast);
+        setContrast(contrast);
     }
 
     public void setContrast(final float contrast) {
-        mContrast = contrast;
-        setFloat(mContrastLocation, mContrast);
+        this.contrast = contrast;
+        setFloat(contrastLocation, this.contrast);
     }
 }
diff --git a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageCrosshatchFilter.java b/library/src/main/java/jp/co/cyberagent/android/gpuimage/filter/GPUImageCrosshatchFilter.java
similarity index 82%
rename from library/src/jp/co/cyberagent/android/gpuimage/GPUImageCrosshatchFilter.java
rename to library/src/main/java/jp/co/cyberagent/android/gpuimage/filter/GPUImageCrosshatchFilter.java
index 04a3d4c7..4fceb328 100644
--- a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageCrosshatchFilter.java
+++ b/library/src/main/java/jp/co/cyberagent/android/gpuimage/filter/GPUImageCrosshatchFilter.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2012 CyberAgent
+ * Copyright (C) 2018 CyberAgent, Inc.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -14,7 +14,7 @@
  * limitations under the License.
  */
 
-package jp.co.cyberagent.android.gpuimage;
+package jp.co.cyberagent.android.gpuimage.filter;
 
 import android.opengl.GLES20;
 
@@ -64,10 +64,10 @@
             "gl_FragColor = colorToDisplay;\n" +
             "}\n";
 
-    private float mCrossHatchSpacing;
-    private int mCrossHatchSpacingLocation;
-    private float mLineWidth;
-    private int mLineWidthLocation;
+    private float crossHatchSpacing;
+    private int crossHatchSpacingLocation;
+    private float lineWidth;
+    private int lineWidthLocation;
 
     /**
      * Using default values of crossHatchSpacing: 0.03f and lineWidth: 0.003f.
@@ -78,22 +78,22 @@ public GPUImageCrosshatchFilter() {
 
     public GPUImageCrosshatchFilter(float crossHatchSpacing, float lineWidth) {
         super(NO_FILTER_VERTEX_SHADER, CROSSHATCH_FRAGMENT_SHADER);
-        mCrossHatchSpacing = crossHatchSpacing;
-        mLineWidth = lineWidth;
+        this.crossHatchSpacing = crossHatchSpacing;
+        this.lineWidth = lineWidth;
     }
 
     @Override
     public void onInit() {
         super.onInit();
-        mCrossHatchSpacingLocation = GLES20.glGetUniformLocation(getProgram(), "crossHatchSpacing");
-        mLineWidthLocation = GLES20.glGetUniformLocation(getProgram(), "lineWidth");
+        crossHatchSpacingLocation = GLES20.glGetUniformLocation(getProgram(), "crossHatchSpacing");
+        lineWidthLocation = GLES20.glGetUniformLocation(getProgram(), "lineWidth");
     }
 
     @Override
     public void onInitialized() {
         super.onInitialized();
-        setCrossHatchSpacing(mCrossHatchSpacing);
-        setLineWidth(mLineWidth);
+        setCrossHatchSpacing(crossHatchSpacing);
+        setLineWidth(lineWidth);
     }
 
     /**
@@ -110,12 +110,12 @@ public void setCrossHatchSpacing(final float crossHatchSpacing) {
         }
 
         if (crossHatchSpacing < singlePixelSpacing) {
-            mCrossHatchSpacing = singlePixelSpacing;
+            this.crossHatchSpacing = singlePixelSpacing;
         } else {
-            mCrossHatchSpacing = crossHatchSpacing;
+            this.crossHatchSpacing = crossHatchSpacing;
         }
 
-        setFloat(mCrossHatchSpacingLocation, mCrossHatchSpacing);
+        setFloat(crossHatchSpacingLocation, this.crossHatchSpacing);
     }
 
     /**
@@ -124,7 +124,7 @@ public void setCrossHatchSpacing(final float crossHatchSpacing) {
      * @param lineWidth default 0.003
      */
     public void setLineWidth(final float lineWidth) {
-        mLineWidth = lineWidth;
-        setFloat(mLineWidthLocation, mLineWidth);
+        this.lineWidth = lineWidth;
+        setFloat(lineWidthLocation, this.lineWidth);
     }
 }
diff --git a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageDarkenBlendFilter.java b/library/src/main/java/jp/co/cyberagent/android/gpuimage/filter/GPUImageDarkenBlendFilter.java
similarity index 94%
rename from library/src/jp/co/cyberagent/android/gpuimage/GPUImageDarkenBlendFilter.java
rename to library/src/main/java/jp/co/cyberagent/android/gpuimage/filter/GPUImageDarkenBlendFilter.java
index 385e8e3a..599eaf70 100644
--- a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageDarkenBlendFilter.java
+++ b/library/src/main/java/jp/co/cyberagent/android/gpuimage/filter/GPUImageDarkenBlendFilter.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2012 CyberAgent
+ * Copyright (C) 2018 CyberAgent, Inc.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -14,7 +14,7 @@
  * limitations under the License.
  */
 
-package jp.co.cyberagent.android.gpuimage;
+package jp.co.cyberagent.android.gpuimage.filter;
 
 public class GPUImageDarkenBlendFilter extends GPUImageTwoInputFilter {
     public static final String DARKEN_BLEND_FRAGMENT_SHADER = "varying highp vec2 textureCoordinate;\n" +
diff --git a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageDifferenceBlendFilter.java b/library/src/main/java/jp/co/cyberagent/android/gpuimage/filter/GPUImageDifferenceBlendFilter.java
similarity index 94%
rename from library/src/jp/co/cyberagent/android/gpuimage/GPUImageDifferenceBlendFilter.java
rename to library/src/main/java/jp/co/cyberagent/android/gpuimage/filter/GPUImageDifferenceBlendFilter.java
index 1a32cd0c..6ceabe1b 100644
--- a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageDifferenceBlendFilter.java
+++ b/library/src/main/java/jp/co/cyberagent/android/gpuimage/filter/GPUImageDifferenceBlendFilter.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2012 CyberAgent
+ * Copyright (C) 2018 CyberAgent, Inc.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -14,7 +14,7 @@
  * limitations under the License.
  */
 
-package jp.co.cyberagent.android.gpuimage;
+package jp.co.cyberagent.android.gpuimage.filter;
 
 public class GPUImageDifferenceBlendFilter extends GPUImageTwoInputFilter {
     public static final String DIFFERENCE_BLEND_FRAGMENT_SHADER = "varying highp vec2 textureCoordinate;\n" +
diff --git a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageDilationFilter.java b/library/src/main/java/jp/co/cyberagent/android/gpuimage/filter/GPUImageDilationFilter.java
similarity index 99%
rename from library/src/jp/co/cyberagent/android/gpuimage/GPUImageDilationFilter.java
rename to library/src/main/java/jp/co/cyberagent/android/gpuimage/filter/GPUImageDilationFilter.java
index f6ce4e2f..06101a08 100644
--- a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageDilationFilter.java
+++ b/library/src/main/java/jp/co/cyberagent/android/gpuimage/filter/GPUImageDilationFilter.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2012 CyberAgent
+ * Copyright (C) 2018 CyberAgent, Inc.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -14,7 +14,7 @@
  * limitations under the License.
  */
 
-package jp.co.cyberagent.android.gpuimage;
+package jp.co.cyberagent.android.gpuimage.filter;
 
 /**
  * For each pixel, this sets it to the maximum value of the red channel in a rectangular neighborhood extending
diff --git a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageDirectionalSobelEdgeDetectionFilter.java b/library/src/main/java/jp/co/cyberagent/android/gpuimage/filter/GPUImageDirectionalSobelEdgeDetectionFilter.java
similarity index 58%
rename from library/src/jp/co/cyberagent/android/gpuimage/GPUImageDirectionalSobelEdgeDetectionFilter.java
rename to library/src/main/java/jp/co/cyberagent/android/gpuimage/filter/GPUImageDirectionalSobelEdgeDetectionFilter.java
index a5884a12..eb71c7f1 100644
--- a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageDirectionalSobelEdgeDetectionFilter.java
+++ b/library/src/main/java/jp/co/cyberagent/android/gpuimage/filter/GPUImageDirectionalSobelEdgeDetectionFilter.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2012 CyberAgent
+ * Copyright (C) 2018 CyberAgent, Inc.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -14,48 +14,48 @@
  * limitations under the License.
  */
 
-package jp.co.cyberagent.android.gpuimage;
+package jp.co.cyberagent.android.gpuimage.filter;
 
 
 public class GPUImageDirectionalSobelEdgeDetectionFilter extends GPUImage3x3TextureSamplingFilter {
     public static final String DIRECTIONAL_SOBEL_EDGE_DETECTION_FRAGMENT_SHADER = "" +
-            "precision mediump float;\n" + 
+            "precision mediump float;\n" +
             "\n" +
-            "varying vec2 textureCoordinate;\n" + 
-            "varying vec2 leftTextureCoordinate;\n" + 
-            "varying vec2 rightTextureCoordinate;\n" + 
+            "varying vec2 textureCoordinate;\n" +
+            "varying vec2 leftTextureCoordinate;\n" +
+            "varying vec2 rightTextureCoordinate;\n" +
             "\n" +
-            "varying vec2 topTextureCoordinate;\n" + 
-            "varying vec2 topLeftTextureCoordinate;\n" + 
-            "varying vec2 topRightTextureCoordinate;\n" + 
-            "\n" + 
-            "varying vec2 bottomTextureCoordinate;\n" + 
-            "varying vec2 bottomLeftTextureCoordinate;\n" + 
-            "varying vec2 bottomRightTextureCoordinate;\n" + 
-            "\n" + 
-            "uniform sampler2D inputImageTexture;\n" + 
-            "\n" + 
-            "void main()\n" + 
-            "{\n" + 
-            "    float bottomLeftIntensity = texture2D(inputImageTexture, bottomLeftTextureCoordinate).r;\n" + 
-            "    float topRightIntensity = texture2D(inputImageTexture, topRightTextureCoordinate).r;\n" + 
-            "    float topLeftIntensity = texture2D(inputImageTexture, topLeftTextureCoordinate).r;\n" + 
-            "    float bottomRightIntensity = texture2D(inputImageTexture, bottomRightTextureCoordinate).r;\n" + 
-            "    float leftIntensity = texture2D(inputImageTexture, leftTextureCoordinate).r;\n" + 
-            "    float rightIntensity = texture2D(inputImageTexture, rightTextureCoordinate).r;\n" + 
-            "    float bottomIntensity = texture2D(inputImageTexture, bottomTextureCoordinate).r;\n" + 
-            "    float topIntensity = texture2D(inputImageTexture, topTextureCoordinate).r;\n" + 
-            "\n" + 
-            "    vec2 gradientDirection;\n" + 
-            "    gradientDirection.x = -bottomLeftIntensity - 2.0 * leftIntensity - topLeftIntensity + bottomRightIntensity + 2.0 * rightIntensity + topRightIntensity;\n" + 
-            "    gradientDirection.y = -topLeftIntensity - 2.0 * topIntensity - topRightIntensity + bottomLeftIntensity + 2.0 * bottomIntensity + bottomRightIntensity;\n" + 
-            "\n" + 
-            "    float gradientMagnitude = length(gradientDirection);\n" + 
-            "    vec2 normalizedDirection = normalize(gradientDirection);\n" + 
-            "    normalizedDirection = sign(normalizedDirection) * floor(abs(normalizedDirection) + 0.617316); // Offset by 1-sin(pi/8) to set to 0 if near axis, 1 if away\n" + 
-            "    normalizedDirection = (normalizedDirection + 1.0) * 0.5; // Place -1.0 - 1.0 within 0 - 1.0\n" + 
-            "\n" + 
-            "    gl_FragColor = vec4(gradientMagnitude, normalizedDirection.x, normalizedDirection.y, 1.0);\n" + 
+            "varying vec2 topTextureCoordinate;\n" +
+            "varying vec2 topLeftTextureCoordinate;\n" +
+            "varying vec2 topRightTextureCoordinate;\n" +
+            "\n" +
+            "varying vec2 bottomTextureCoordinate;\n" +
+            "varying vec2 bottomLeftTextureCoordinate;\n" +
+            "varying vec2 bottomRightTextureCoordinate;\n" +
+            "\n" +
+            "uniform sampler2D inputImageTexture;\n" +
+            "\n" +
+            "void main()\n" +
+            "{\n" +
+            "    float bottomLeftIntensity = texture2D(inputImageTexture, bottomLeftTextureCoordinate).r;\n" +
+            "    float topRightIntensity = texture2D(inputImageTexture, topRightTextureCoordinate).r;\n" +
+            "    float topLeftIntensity = texture2D(inputImageTexture, topLeftTextureCoordinate).r;\n" +
+            "    float bottomRightIntensity = texture2D(inputImageTexture, bottomRightTextureCoordinate).r;\n" +
+            "    float leftIntensity = texture2D(inputImageTexture, leftTextureCoordinate).r;\n" +
+            "    float rightIntensity = texture2D(inputImageTexture, rightTextureCoordinate).r;\n" +
+            "    float bottomIntensity = texture2D(inputImageTexture, bottomTextureCoordinate).r;\n" +
+            "    float topIntensity = texture2D(inputImageTexture, topTextureCoordinate).r;\n" +
+            "\n" +
+            "    vec2 gradientDirection;\n" +
+            "    gradientDirection.x = -bottomLeftIntensity - 2.0 * leftIntensity - topLeftIntensity + bottomRightIntensity + 2.0 * rightIntensity + topRightIntensity;\n" +
+            "    gradientDirection.y = -topLeftIntensity - 2.0 * topIntensity - topRightIntensity + bottomLeftIntensity + 2.0 * bottomIntensity + bottomRightIntensity;\n" +
+            "\n" +
+            "    float gradientMagnitude = length(gradientDirection);\n" +
+            "    vec2 normalizedDirection = normalize(gradientDirection);\n" +
+            "    normalizedDirection = sign(normalizedDirection) * floor(abs(normalizedDirection) + 0.617316); // Offset by 1-sin(pi/8) to set to 0 if near axis, 1 if away\n" +
+            "    normalizedDirection = (normalizedDirection + 1.0) * 0.5; // Place -1.0 - 1.0 within 0 - 1.0\n" +
+            "\n" +
+            "    gl_FragColor = vec4(gradientMagnitude, normalizedDirection.x, normalizedDirection.y, 1.0);\n" +
             "}";
 
     public GPUImageDirectionalSobelEdgeDetectionFilter() {
diff --git a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageDissolveBlendFilter.java b/library/src/main/java/jp/co/cyberagent/android/gpuimage/filter/GPUImageDissolveBlendFilter.java
similarity index 93%
rename from library/src/jp/co/cyberagent/android/gpuimage/GPUImageDissolveBlendFilter.java
rename to library/src/main/java/jp/co/cyberagent/android/gpuimage/filter/GPUImageDissolveBlendFilter.java
index cd2880a6..7ae8dee3 100644
--- a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageDissolveBlendFilter.java
+++ b/library/src/main/java/jp/co/cyberagent/android/gpuimage/filter/GPUImageDissolveBlendFilter.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2012 CyberAgent
+ * Copyright (C) 2018 CyberAgent, Inc.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -14,14 +14,12 @@
  * limitations under the License.
  */
 
-package jp.co.cyberagent.android.gpuimage;
-
-import android.opengl.GLES20;
+package jp.co.cyberagent.android.gpuimage.filter;
 
 /**
  * Mix ranges from 0.0 (only image 1) to 1.0 (only image 2), with 0.5 (half of either) as the normal level
  */
-public class GPUImageDissolveBlendFilter extends GPUImageMixBlendFilter{
+public class GPUImageDissolveBlendFilter extends GPUImageMixBlendFilter {
     public static final String DISSOLVE_BLEND_FRAGMENT_SHADER = "varying highp vec2 textureCoordinate;\n" +
             " varying highp vec2 textureCoordinate2;\n" +
             "\n" +
diff --git a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageDivideBlendFilter.java b/library/src/main/java/jp/co/cyberagent/android/gpuimage/filter/GPUImageDivideBlendFilter.java
similarity index 96%
rename from library/src/jp/co/cyberagent/android/gpuimage/GPUImageDivideBlendFilter.java
rename to library/src/main/java/jp/co/cyberagent/android/gpuimage/filter/GPUImageDivideBlendFilter.java
index 179cd4ee..e0b48dba 100644
--- a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageDivideBlendFilter.java
+++ b/library/src/main/java/jp/co/cyberagent/android/gpuimage/filter/GPUImageDivideBlendFilter.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2012 CyberAgent
+ * Copyright (C) 2018 CyberAgent, Inc.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -14,7 +14,7 @@
  * limitations under the License.
  */
 
-package jp.co.cyberagent.android.gpuimage;
+package jp.co.cyberagent.android.gpuimage.filter;
 
 public class GPUImageDivideBlendFilter extends GPUImageTwoInputFilter {
     public static final String DIVIDE_BLEND_FRAGMENT_SHADER = "varying highp vec2 textureCoordinate;\n" +
diff --git a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageEmbossFilter.java b/library/src/main/java/jp/co/cyberagent/android/gpuimage/filter/GPUImageEmbossFilter.java
similarity index 76%
rename from library/src/jp/co/cyberagent/android/gpuimage/GPUImageEmbossFilter.java
rename to library/src/main/java/jp/co/cyberagent/android/gpuimage/filter/GPUImageEmbossFilter.java
index f4cbdef7..5af70fc2 100644
--- a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageEmbossFilter.java
+++ b/library/src/main/java/jp/co/cyberagent/android/gpuimage/filter/GPUImageEmbossFilter.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2012 CyberAgent
+ * Copyright (C) 2018 CyberAgent, Inc.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -14,7 +14,7 @@
  * limitations under the License.
  */
 
-package jp.co.cyberagent.android.gpuimage;
+package jp.co.cyberagent.android.gpuimage.filter;
 
 /**
  * Applies an emboss effect to the image.<br>
@@ -22,7 +22,7 @@
  * Intensity ranges from 0.0 to 4.0, with 1.0 as the normal level
  */
 public class GPUImageEmbossFilter extends GPUImage3x3ConvolutionFilter {
-    private float mIntensity;
+    private float intensity;
 
     public GPUImageEmbossFilter() {
         this(1.0f);
@@ -30,18 +30,23 @@ public GPUImageEmbossFilter() {
 
     public GPUImageEmbossFilter(final float intensity) {
         super();
-        mIntensity = intensity;
+        this.intensity = intensity;
     }
 
     @Override
     public void onInit() {
         super.onInit();
-        setIntensity(mIntensity);
+    }
+
+    @Override
+    public void onInitialized() {
+        super.onInitialized();
+        setIntensity(intensity);
     }
 
     public void setIntensity(final float intensity) {
-        mIntensity = intensity;
-        setConvolutionKernel(new float[] {
+        this.intensity = intensity;
+        setConvolutionKernel(new float[]{
                 intensity * (-2.0f), -intensity, 0.0f,
                 -intensity, 1.0f, intensity,
                 0.0f, intensity, intensity * 2.0f,
@@ -49,6 +54,6 @@ public void setIntensity(final float intensity) {
     }
 
     public float getIntensity() {
-        return mIntensity;
+        return intensity;
     }
 }
diff --git a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageExclusionBlendFilter.java b/library/src/main/java/jp/co/cyberagent/android/gpuimage/filter/GPUImageExclusionBlendFilter.java
similarity index 94%
rename from library/src/jp/co/cyberagent/android/gpuimage/GPUImageExclusionBlendFilter.java
rename to library/src/main/java/jp/co/cyberagent/android/gpuimage/filter/GPUImageExclusionBlendFilter.java
index dcfc9346..20bb2a05 100644
--- a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageExclusionBlendFilter.java
+++ b/library/src/main/java/jp/co/cyberagent/android/gpuimage/filter/GPUImageExclusionBlendFilter.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2012 CyberAgent
+ * Copyright (C) 2018 CyberAgent, Inc.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -14,7 +14,7 @@
  * limitations under the License.
  */
 
-package jp.co.cyberagent.android.gpuimage;
+package jp.co.cyberagent.android.gpuimage.filter;
 
 public class GPUImageExclusionBlendFilter extends GPUImageTwoInputFilter {
     public static final String EXCLUSION_BLEND_FRAGMENT_SHADER = "varying highp vec2 textureCoordinate;\n" +
diff --git a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageExposureFilter.java b/library/src/main/java/jp/co/cyberagent/android/gpuimage/filter/GPUImageExposureFilter.java
similarity index 81%
rename from library/src/jp/co/cyberagent/android/gpuimage/GPUImageExposureFilter.java
rename to library/src/main/java/jp/co/cyberagent/android/gpuimage/filter/GPUImageExposureFilter.java
index de5de414..753e6864 100644
--- a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageExposureFilter.java
+++ b/library/src/main/java/jp/co/cyberagent/android/gpuimage/filter/GPUImageExposureFilter.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2012 CyberAgent
+ * Copyright (C) 2018 CyberAgent, Inc.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -14,7 +14,7 @@
  * limitations under the License.
  */
 
-package jp.co.cyberagent.android.gpuimage;
+package jp.co.cyberagent.android.gpuimage.filter;
 
 import android.opengl.GLES20;
 
@@ -35,8 +35,8 @@
             "     gl_FragColor = vec4(textureColor.rgb * pow(2.0, exposure), textureColor.w);\n" +
             " } ";
 
-    private int mExposureLocation;
-    private float mExposure;
+    private int exposureLocation;
+    private float exposure;
 
     public GPUImageExposureFilter() {
         this(1.0f);
@@ -44,23 +44,23 @@ public GPUImageExposureFilter() {
 
     public GPUImageExposureFilter(final float exposure) {
         super(NO_FILTER_VERTEX_SHADER, EXPOSURE_FRAGMENT_SHADER);
-        mExposure = exposure;
+        this.exposure = exposure;
     }
 
     @Override
     public void onInit() {
         super.onInit();
-        mExposureLocation = GLES20.glGetUniformLocation(getProgram(), "exposure");
+        exposureLocation = GLES20.glGetUniformLocation(getProgram(), "exposure");
     }
 
     @Override
     public void onInitialized() {
         super.onInitialized();
-        setExposure(mExposure);
+        setExposure(exposure);
     }
 
     public void setExposure(final float exposure) {
-        mExposure = exposure;
-        setFloat(mExposureLocation, mExposure);
+        this.exposure = exposure;
+        setFloat(exposureLocation, this.exposure);
     }
 }
diff --git a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageFalseColorFilter.java b/library/src/main/java/jp/co/cyberagent/android/gpuimage/filter/GPUImageFalseColorFilter.java
similarity index 75%
rename from library/src/jp/co/cyberagent/android/gpuimage/GPUImageFalseColorFilter.java
rename to library/src/main/java/jp/co/cyberagent/android/gpuimage/filter/GPUImageFalseColorFilter.java
index c815ad0f..b19772db 100644
--- a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageFalseColorFilter.java
+++ b/library/src/main/java/jp/co/cyberagent/android/gpuimage/filter/GPUImageFalseColorFilter.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2012 CyberAgent
+ * Copyright (C) 2018 CyberAgent, Inc.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -14,7 +14,7 @@
  * limitations under the License.
  */
 
-package jp.co.cyberagent.android.gpuimage;
+package jp.co.cyberagent.android.gpuimage.filter;
 
 import android.opengl.GLES20;
 
@@ -39,10 +39,10 @@
             "gl_FragColor = vec4( mix(firstColor.rgb, secondColor.rgb, luminance), textureColor.a);\n" +
             "}\n";
 
-    private float[] mFirstColor;
-    private int mFirstColorLocation;
-    private float[] mSecondColor;
-    private int mSecondColorLocation;
+    private float[] firstColor;
+    private int firstColorLocation;
+    private float[] secondColor;
+    private int secondColorLocation;
 
     public GPUImageFalseColorFilter() {
         this(0f, 0f, 0.5f, 1f, 0f, 0f);
@@ -54,31 +54,31 @@ public GPUImageFalseColorFilter(float firstRed, float firstGreen, float firstBlu
 
     public GPUImageFalseColorFilter(float[] firstColor, float[] secondColor) {
         super(NO_FILTER_VERTEX_SHADER, FALSECOLOR_FRAGMENT_SHADER);
-        mFirstColor = firstColor;
-        mSecondColor = secondColor;
+        this.firstColor = firstColor;
+        this.secondColor = secondColor;
     }
 
     @Override
     public void onInit() {
         super.onInit();
-        mFirstColorLocation = GLES20.glGetUniformLocation(getProgram(), "firstColor");
-        mSecondColorLocation = GLES20.glGetUniformLocation(getProgram(), "secondColor");
+        firstColorLocation = GLES20.glGetUniformLocation(getProgram(), "firstColor");
+        secondColorLocation = GLES20.glGetUniformLocation(getProgram(), "secondColor");
     }
 
     @Override
     public void onInitialized() {
         super.onInitialized();
-        setFirstColor(mFirstColor);
-        setSecondColor(mSecondColor);
+        setFirstColor(firstColor);
+        setSecondColor(secondColor);
     }
 
     public void setFirstColor(final float[] firstColor) {
-        mFirstColor = firstColor;
-        setFloatVec3(mFirstColorLocation, firstColor);
+        this.firstColor = firstColor;
+        setFloatVec3(firstColorLocation, firstColor);
     }
 
     public void setSecondColor(final float[] secondColor) {
-        mSecondColor = secondColor;
-        setFloatVec3(mSecondColorLocation, secondColor);
+        this.secondColor = secondColor;
+        setFloatVec3(secondColorLocation, secondColor);
     }
 }
diff --git a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageFilter.java b/library/src/main/java/jp/co/cyberagent/android/gpuimage/filter/GPUImageFilter.java
similarity index 71%
rename from library/src/jp/co/cyberagent/android/gpuimage/GPUImageFilter.java
rename to library/src/main/java/jp/co/cyberagent/android/gpuimage/filter/GPUImageFilter.java
index 7a8641aa..6a2afa06 100644
--- a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageFilter.java
+++ b/library/src/main/java/jp/co/cyberagent/android/gpuimage/filter/GPUImageFilter.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2012 CyberAgent
+ * Copyright (C) 2018 CyberAgent, Inc.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -14,7 +14,7 @@
  * limitations under the License.
  */
 
-package jp.co.cyberagent.android.gpuimage;
+package jp.co.cyberagent.android.gpuimage.filter;
 
 import android.content.Context;
 import android.content.res.AssetManager;
@@ -25,6 +25,8 @@
 import java.nio.FloatBuffer;
 import java.util.LinkedList;
 
+import jp.co.cyberagent.android.gpuimage.util.OpenGlUtils;
+
 public class GPUImageFilter {
     public static final String NO_FILTER_VERTEX_SHADER = "" +
             "attribute vec4 position;\n" +
@@ -47,48 +49,50 @@
             "     gl_FragColor = texture2D(inputImageTexture, textureCoordinate);\n" +
             "}";
 
-    private final LinkedList<Runnable> mRunOnDraw;
-    private final String mVertexShader;
-    private final String mFragmentShader;
-    protected int mGLProgId;
-    protected int mGLAttribPosition;
-    protected int mGLUniformTexture;
-    protected int mGLAttribTextureCoordinate;
-    protected int mOutputWidth;
-    protected int mOutputHeight;
-    private boolean mIsInitialized;
+    private final LinkedList<Runnable> runOnDraw;
+    private final String vertexShader;
+    private final String fragmentShader;
+    private int glProgId;
+    private int glAttribPosition;
+    private int glUniformTexture;
+    private int glAttribTextureCoordinate;
+    private int outputWidth;
+    private int outputHeight;
+    private boolean isInitialized;
 
     public GPUImageFilter() {
         this(NO_FILTER_VERTEX_SHADER, NO_FILTER_FRAGMENT_SHADER);
     }
 
     public GPUImageFilter(final String vertexShader, final String fragmentShader) {
-        mRunOnDraw = new LinkedList<Runnable>();
-        mVertexShader = vertexShader;
-        mFragmentShader = fragmentShader;
+        runOnDraw = new LinkedList<>();
+        this.vertexShader = vertexShader;
+        this.fragmentShader = fragmentShader;
     }
 
-    public final void init() {
+    private final void init() {
         onInit();
-        mIsInitialized = true;
         onInitialized();
     }
 
     public void onInit() {
-        mGLProgId = OpenGlUtils.loadProgram(mVertexShader, mFragmentShader);
-        mGLAttribPosition = GLES20.glGetAttribLocation(mGLProgId, "position");
-        mGLUniformTexture = GLES20.glGetUniformLocation(mGLProgId, "inputImageTexture");
-        mGLAttribTextureCoordinate = GLES20.glGetAttribLocation(mGLProgId,
-                "inputTextureCoordinate");
-        mIsInitialized = true;
+        glProgId = OpenGlUtils.loadProgram(vertexShader, fragmentShader);
+        glAttribPosition = GLES20.glGetAttribLocation(glProgId, "position");
+        glUniformTexture = GLES20.glGetUniformLocation(glProgId, "inputImageTexture");
+        glAttribTextureCoordinate = GLES20.glGetAttribLocation(glProgId, "inputTextureCoordinate");
+        isInitialized = true;
     }
 
     public void onInitialized() {
     }
 
+    public void ifNeedInit() {
+        if (!isInitialized) init();
+    }
+
     public final void destroy() {
-        mIsInitialized = false;
-        GLES20.glDeleteProgram(mGLProgId);
+        isInitialized = false;
+        GLES20.glDeleteProgram(glProgId);
         onDestroy();
     }
 
@@ -96,77 +100,79 @@ public void onDestroy() {
     }
 
     public void onOutputSizeChanged(final int width, final int height) {
-        mOutputWidth = width;
-        mOutputHeight = height;
+        outputWidth = width;
+        outputHeight = height;
     }
 
     public void onDraw(final int textureId, final FloatBuffer cubeBuffer,
                        final FloatBuffer textureBuffer) {
-        GLES20.glUseProgram(mGLProgId);
+        GLES20.glUseProgram(glProgId);
         runPendingOnDrawTasks();
-        if (!mIsInitialized) {
+        if (!isInitialized) {
             return;
         }
 
         cubeBuffer.position(0);
-        GLES20.glVertexAttribPointer(mGLAttribPosition, 2, GLES20.GL_FLOAT, false, 0, cubeBuffer);
-        GLES20.glEnableVertexAttribArray(mGLAttribPosition);
+        GLES20.glVertexAttribPointer(glAttribPosition, 2, GLES20.GL_FLOAT, false, 0, cubeBuffer);
+        GLES20.glEnableVertexAttribArray(glAttribPosition);
         textureBuffer.position(0);
-        GLES20.glVertexAttribPointer(mGLAttribTextureCoordinate, 2, GLES20.GL_FLOAT, false, 0,
+        GLES20.glVertexAttribPointer(glAttribTextureCoordinate, 2, GLES20.GL_FLOAT, false, 0,
                 textureBuffer);
-        GLES20.glEnableVertexAttribArray(mGLAttribTextureCoordinate);
+        GLES20.glEnableVertexAttribArray(glAttribTextureCoordinate);
         if (textureId != OpenGlUtils.NO_TEXTURE) {
             GLES20.glActiveTexture(GLES20.GL_TEXTURE0);
             GLES20.glBindTexture(GLES20.GL_TEXTURE_2D, textureId);
-            GLES20.glUniform1i(mGLUniformTexture, 0);
+            GLES20.glUniform1i(glUniformTexture, 0);
         }
         onDrawArraysPre();
         GLES20.glDrawArrays(GLES20.GL_TRIANGLE_STRIP, 0, 4);
-        GLES20.glDisableVertexAttribArray(mGLAttribPosition);
-        GLES20.glDisableVertexAttribArray(mGLAttribTextureCoordinate);
+        GLES20.glDisableVertexAttribArray(glAttribPosition);
+        GLES20.glDisableVertexAttribArray(glAttribTextureCoordinate);
         GLES20.glBindTexture(GLES20.GL_TEXTURE_2D, 0);
     }
 
-    protected void onDrawArraysPre() {}
+    protected void onDrawArraysPre() {
+    }
 
     protected void runPendingOnDrawTasks() {
-        while (!mRunOnDraw.isEmpty()) {
-            mRunOnDraw.removeFirst().run();
+        while (!runOnDraw.isEmpty()) {
+            runOnDraw.removeFirst().run();
         }
     }
 
     public boolean isInitialized() {
-        return mIsInitialized;
+        return isInitialized;
     }
 
     public int getOutputWidth() {
-        return mOutputWidth;
+        return outputWidth;
     }
 
     public int getOutputHeight() {
-        return mOutputHeight;
+        return outputHeight;
     }
 
     public int getProgram() {
-        return mGLProgId;
+        return glProgId;
     }
 
     public int getAttribPosition() {
-        return mGLAttribPosition;
+        return glAttribPosition;
     }
 
     public int getAttribTextureCoordinate() {
-        return mGLAttribTextureCoordinate;
+        return glAttribTextureCoordinate;
     }
 
     public int getUniformTexture() {
-        return mGLUniformTexture;
+        return glUniformTexture;
     }
 
     protected void setInteger(final int location, final int intValue) {
         runOnDraw(new Runnable() {
             @Override
             public void run() {
+                ifNeedInit();
                 GLES20.glUniform1i(location, intValue);
             }
         });
@@ -176,6 +182,7 @@ protected void setFloat(final int location, final float floatValue) {
         runOnDraw(new Runnable() {
             @Override
             public void run() {
+                ifNeedInit();
                 GLES20.glUniform1f(location, floatValue);
             }
         });
@@ -185,6 +192,7 @@ protected void setFloatVec2(final int location, final float[] arrayValue) {
         runOnDraw(new Runnable() {
             @Override
             public void run() {
+                ifNeedInit();
                 GLES20.glUniform2fv(location, 1, FloatBuffer.wrap(arrayValue));
             }
         });
@@ -194,6 +202,7 @@ protected void setFloatVec3(final int location, final float[] arrayValue) {
         runOnDraw(new Runnable() {
             @Override
             public void run() {
+                ifNeedInit();
                 GLES20.glUniform3fv(location, 1, FloatBuffer.wrap(arrayValue));
             }
         });
@@ -203,6 +212,7 @@ protected void setFloatVec4(final int location, final float[] arrayValue) {
         runOnDraw(new Runnable() {
             @Override
             public void run() {
+                ifNeedInit();
                 GLES20.glUniform4fv(location, 1, FloatBuffer.wrap(arrayValue));
             }
         });
@@ -212,6 +222,7 @@ protected void setFloatArray(final int location, final float[] arrayValue) {
         runOnDraw(new Runnable() {
             @Override
             public void run() {
+                ifNeedInit();
                 GLES20.glUniform1fv(location, arrayValue.length, FloatBuffer.wrap(arrayValue));
             }
         });
@@ -219,9 +230,9 @@ public void run() {
 
     protected void setPoint(final int location, final PointF point) {
         runOnDraw(new Runnable() {
-
             @Override
             public void run() {
+                ifNeedInit();
                 float[] vec2 = new float[2];
                 vec2[0] = point.x;
                 vec2[1] = point.y;
@@ -235,6 +246,7 @@ protected void setUniformMatrix3f(final int location, final float[] matrix) {
 
             @Override
             public void run() {
+                ifNeedInit();
                 GLES20.glUniformMatrix3fv(location, 1, false, matrix, 0);
             }
         });
@@ -245,14 +257,15 @@ protected void setUniformMatrix4f(final int location, final float[] matrix) {
 
             @Override
             public void run() {
+                ifNeedInit();
                 GLES20.glUniformMatrix4fv(location, 1, false, matrix, 0);
             }
         });
     }
 
     protected void runOnDraw(final Runnable runnable) {
-        synchronized (mRunOnDraw) {
-            mRunOnDraw.addLast(runnable);
+        synchronized (runOnDraw) {
+            runOnDraw.addLast(runnable);
         }
     }
 
diff --git a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageFilterGroup.java b/library/src/main/java/jp/co/cyberagent/android/gpuimage/filter/GPUImageFilterGroup.java
similarity index 62%
rename from library/src/jp/co/cyberagent/android/gpuimage/GPUImageFilterGroup.java
rename to library/src/main/java/jp/co/cyberagent/android/gpuimage/filter/GPUImageFilterGroup.java
index 10ea41ca..8735dbcd 100644
--- a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageFilterGroup.java
+++ b/library/src/main/java/jp/co/cyberagent/android/gpuimage/filter/GPUImageFilterGroup.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2012 CyberAgent
+ * Copyright (C) 2018 CyberAgent, Inc.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -14,11 +14,10 @@
  * limitations under the License.
  */
 
-package jp.co.cyberagent.android.gpuimage;
+package jp.co.cyberagent.android.gpuimage.filter;
 
 import android.annotation.SuppressLint;
 import android.opengl.GLES20;
-import jp.co.cyberagent.android.gpuimage.util.TextureRotationUtil;
 
 import java.nio.ByteBuffer;
 import java.nio.ByteOrder;
@@ -26,6 +25,9 @@
 import java.util.ArrayList;
 import java.util.List;
 
+import jp.co.cyberagent.android.gpuimage.util.Rotation;
+import jp.co.cyberagent.android.gpuimage.util.TextureRotationUtil;
+
 import static jp.co.cyberagent.android.gpuimage.GPUImageRenderer.CUBE;
 import static jp.co.cyberagent.android.gpuimage.util.TextureRotationUtil.TEXTURE_NO_ROTATION;
 
@@ -35,14 +37,14 @@
  */
 public class GPUImageFilterGroup extends GPUImageFilter {
 
-    protected List<GPUImageFilter> mFilters;
-    protected List<GPUImageFilter> mMergedFilters;
-    private int[] mFrameBuffers;
-    private int[] mFrameBufferTextures;
+    private List<GPUImageFilter> filters;
+    private List<GPUImageFilter> mergedFilters;
+    private int[] frameBuffers;
+    private int[] frameBufferTextures;
 
-    private final FloatBuffer mGLCubeBuffer;
-    private final FloatBuffer mGLTextureBuffer;
-    private final FloatBuffer mGLTextureFlipBuffer;
+    private final FloatBuffer glCubeBuffer;
+    private final FloatBuffer glTextureBuffer;
+    private final FloatBuffer glTextureFlipBuffer;
 
     /**
      * Instantiates a new GPUImageFilterGroup with no filters.
@@ -57,101 +59,101 @@ public GPUImageFilterGroup() {
      * @param filters the filters which represent this filter
      */
     public GPUImageFilterGroup(List<GPUImageFilter> filters) {
-        mFilters = filters;
-        if (mFilters == null) {
-            mFilters = new ArrayList<GPUImageFilter>();
+        this.filters = filters;
+        if (this.filters == null) {
+            this.filters = new ArrayList<>();
         } else {
             updateMergedFilters();
         }
 
-        mGLCubeBuffer = ByteBuffer.allocateDirect(CUBE.length * 4)
+        glCubeBuffer = ByteBuffer.allocateDirect(CUBE.length * 4)
                 .order(ByteOrder.nativeOrder())
                 .asFloatBuffer();
-        mGLCubeBuffer.put(CUBE).position(0);
+        glCubeBuffer.put(CUBE).position(0);
 
-        mGLTextureBuffer = ByteBuffer.allocateDirect(TEXTURE_NO_ROTATION.length * 4)
+        glTextureBuffer = ByteBuffer.allocateDirect(TEXTURE_NO_ROTATION.length * 4)
                 .order(ByteOrder.nativeOrder())
                 .asFloatBuffer();
-        mGLTextureBuffer.put(TEXTURE_NO_ROTATION).position(0);
+        glTextureBuffer.put(TEXTURE_NO_ROTATION).position(0);
 
         float[] flipTexture = TextureRotationUtil.getRotation(Rotation.NORMAL, false, true);
-        mGLTextureFlipBuffer = ByteBuffer.allocateDirect(flipTexture.length * 4)
+        glTextureFlipBuffer = ByteBuffer.allocateDirect(flipTexture.length * 4)
                 .order(ByteOrder.nativeOrder())
                 .asFloatBuffer();
-        mGLTextureFlipBuffer.put(flipTexture).position(0);
+        glTextureFlipBuffer.put(flipTexture).position(0);
     }
 
     public void addFilter(GPUImageFilter aFilter) {
         if (aFilter == null) {
             return;
         }
-        mFilters.add(aFilter);
+        filters.add(aFilter);
         updateMergedFilters();
     }
 
     /*
      * (non-Javadoc)
-     * @see jp.co.cyberagent.android.gpuimage.GPUImageFilter#onInit()
+     * @see jp.co.cyberagent.android.gpuimage.filter.GPUImageFilter#onInit()
      */
     @Override
     public void onInit() {
         super.onInit();
-        for (GPUImageFilter filter : mFilters) {
-            filter.init();
+        for (GPUImageFilter filter : filters) {
+            filter.ifNeedInit();
         }
     }
 
     /*
      * (non-Javadoc)
-     * @see jp.co.cyberagent.android.gpuimage.GPUImageFilter#onDestroy()
+     * @see jp.co.cyberagent.android.gpuimage.filter.GPUImageFilter#onDestroy()
      */
     @Override
     public void onDestroy() {
         destroyFramebuffers();
-        for (GPUImageFilter filter : mFilters) {
+        for (GPUImageFilter filter : filters) {
             filter.destroy();
         }
         super.onDestroy();
     }
 
     private void destroyFramebuffers() {
-        if (mFrameBufferTextures != null) {
-            GLES20.glDeleteTextures(mFrameBufferTextures.length, mFrameBufferTextures, 0);
-            mFrameBufferTextures = null;
+        if (frameBufferTextures != null) {
+            GLES20.glDeleteTextures(frameBufferTextures.length, frameBufferTextures, 0);
+            frameBufferTextures = null;
         }
-        if (mFrameBuffers != null) {
-            GLES20.glDeleteFramebuffers(mFrameBuffers.length, mFrameBuffers, 0);
-            mFrameBuffers = null;
+        if (frameBuffers != null) {
+            GLES20.glDeleteFramebuffers(frameBuffers.length, frameBuffers, 0);
+            frameBuffers = null;
         }
     }
 
     /*
      * (non-Javadoc)
      * @see
-     * jp.co.cyberagent.android.gpuimage.GPUImageFilter#onOutputSizeChanged(int,
+     * jp.co.cyberagent.android.gpuimage.filter.GPUImageFilter#onOutputSizeChanged(int,
      * int)
      */
     @Override
     public void onOutputSizeChanged(final int width, final int height) {
         super.onOutputSizeChanged(width, height);
-        if (mFrameBuffers != null) {
+        if (frameBuffers != null) {
             destroyFramebuffers();
         }
 
-        int size = mFilters.size();
+        int size = filters.size();
         for (int i = 0; i < size; i++) {
-            mFilters.get(i).onOutputSizeChanged(width, height);
+            filters.get(i).onOutputSizeChanged(width, height);
         }
 
-        if (mMergedFilters != null && mMergedFilters.size() > 0) {
-            size = mMergedFilters.size();
-            mFrameBuffers = new int[size - 1];
-            mFrameBufferTextures = new int[size - 1];
+        if (mergedFilters != null && mergedFilters.size() > 0) {
+            size = mergedFilters.size();
+            frameBuffers = new int[size - 1];
+            frameBufferTextures = new int[size - 1];
 
             for (int i = 0; i < size - 1; i++) {
-                GLES20.glGenFramebuffers(1, mFrameBuffers, i);
-                GLES20.glGenTextures(1, mFrameBufferTextures, i);
-                GLES20.glBindTexture(GLES20.GL_TEXTURE_2D, mFrameBufferTextures[i]);
+                GLES20.glGenFramebuffers(1, frameBuffers, i);
+                GLES20.glGenTextures(1, frameBufferTextures, i);
+                GLES20.glBindTexture(GLES20.GL_TEXTURE_2D, frameBufferTextures[i]);
                 GLES20.glTexImage2D(GLES20.GL_TEXTURE_2D, 0, GLES20.GL_RGBA, width, height, 0,
                         GLES20.GL_RGBA, GLES20.GL_UNSIGNED_BYTE, null);
                 GLES20.glTexParameterf(GLES20.GL_TEXTURE_2D,
@@ -163,9 +165,9 @@ public void onOutputSizeChanged(final int width, final int height) {
                 GLES20.glTexParameterf(GLES20.GL_TEXTURE_2D,
                         GLES20.GL_TEXTURE_WRAP_T, GLES20.GL_CLAMP_TO_EDGE);
 
-                GLES20.glBindFramebuffer(GLES20.GL_FRAMEBUFFER, mFrameBuffers[i]);
+                GLES20.glBindFramebuffer(GLES20.GL_FRAMEBUFFER, frameBuffers[i]);
                 GLES20.glFramebufferTexture2D(GLES20.GL_FRAMEBUFFER, GLES20.GL_COLOR_ATTACHMENT0,
-                        GLES20.GL_TEXTURE_2D, mFrameBufferTextures[i], 0);
+                        GLES20.GL_TEXTURE_2D, frameBufferTextures[i], 0);
 
                 GLES20.glBindTexture(GLES20.GL_TEXTURE_2D, 0);
                 GLES20.glBindFramebuffer(GLES20.GL_FRAMEBUFFER, 0);
@@ -175,43 +177,43 @@ public void onOutputSizeChanged(final int width, final int height) {
 
     /*
      * (non-Javadoc)
-     * @see jp.co.cyberagent.android.gpuimage.GPUImageFilter#onDraw(int,
+     * @see jp.co.cyberagent.android.gpuimage.filter.GPUImageFilter#onDraw(int,
      * java.nio.FloatBuffer, java.nio.FloatBuffer)
      */
-    @SuppressLint("WrongCall")    
+    @SuppressLint("WrongCall")
     @Override
     public void onDraw(final int textureId, final FloatBuffer cubeBuffer,
                        final FloatBuffer textureBuffer) {
         runPendingOnDrawTasks();
-        if (!isInitialized() || mFrameBuffers == null || mFrameBufferTextures == null) {
+        if (!isInitialized() || frameBuffers == null || frameBufferTextures == null) {
             return;
         }
-        if (mMergedFilters != null) {
-            int size = mMergedFilters.size();
+        if (mergedFilters != null) {
+            int size = mergedFilters.size();
             int previousTexture = textureId;
             for (int i = 0; i < size; i++) {
-                GPUImageFilter filter = mMergedFilters.get(i);
+                GPUImageFilter filter = mergedFilters.get(i);
                 boolean isNotLast = i < size - 1;
                 if (isNotLast) {
-                    GLES20.glBindFramebuffer(GLES20.GL_FRAMEBUFFER, mFrameBuffers[i]);
+                    GLES20.glBindFramebuffer(GLES20.GL_FRAMEBUFFER, frameBuffers[i]);
                     GLES20.glClearColor(0, 0, 0, 0);
                 }
 
                 if (i == 0) {
                     filter.onDraw(previousTexture, cubeBuffer, textureBuffer);
                 } else if (i == size - 1) {
-                    filter.onDraw(previousTexture, mGLCubeBuffer, (size % 2 == 0) ? mGLTextureFlipBuffer : mGLTextureBuffer);
+                    filter.onDraw(previousTexture, glCubeBuffer, (size % 2 == 0) ? glTextureFlipBuffer : glTextureBuffer);
                 } else {
-                    filter.onDraw(previousTexture, mGLCubeBuffer, mGLTextureBuffer);
+                    filter.onDraw(previousTexture, glCubeBuffer, glTextureBuffer);
                 }
 
                 if (isNotLast) {
                     GLES20.glBindFramebuffer(GLES20.GL_FRAMEBUFFER, 0);
-                    previousTexture = mFrameBufferTextures[i];
+                    previousTexture = frameBufferTextures[i];
                 }
             }
         }
-     }
+    }
 
     /**
      * Gets the filters.
@@ -219,35 +221,35 @@ public void onDraw(final int textureId, final FloatBuffer cubeBuffer,
      * @return the filters
      */
     public List<GPUImageFilter> getFilters() {
-        return mFilters;
+        return filters;
     }
 
     public List<GPUImageFilter> getMergedFilters() {
-        return mMergedFilters;
+        return mergedFilters;
     }
 
     public void updateMergedFilters() {
-        if (mFilters == null) {
+        if (filters == null) {
             return;
         }
 
-        if (mMergedFilters == null) {
-            mMergedFilters = new ArrayList<GPUImageFilter>();
+        if (mergedFilters == null) {
+            mergedFilters = new ArrayList<>();
         } else {
-            mMergedFilters.clear();
+            mergedFilters.clear();
         }
 
         List<GPUImageFilter> filters;
-        for (GPUImageFilter filter : mFilters) {
+        for (GPUImageFilter filter : this.filters) {
             if (filter instanceof GPUImageFilterGroup) {
                 ((GPUImageFilterGroup) filter).updateMergedFilters();
                 filters = ((GPUImageFilterGroup) filter).getMergedFilters();
                 if (filters == null || filters.isEmpty())
                     continue;
-                mMergedFilters.addAll(filters);
+                mergedFilters.addAll(filters);
                 continue;
             }
-            mMergedFilters.add(filter);
+            mergedFilters.add(filter);
         }
     }
 }
diff --git a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageGammaFilter.java b/library/src/main/java/jp/co/cyberagent/android/gpuimage/filter/GPUImageGammaFilter.java
similarity index 82%
rename from library/src/jp/co/cyberagent/android/gpuimage/GPUImageGammaFilter.java
rename to library/src/main/java/jp/co/cyberagent/android/gpuimage/filter/GPUImageGammaFilter.java
index 1f902d0f..94e5296a 100644
--- a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageGammaFilter.java
+++ b/library/src/main/java/jp/co/cyberagent/android/gpuimage/filter/GPUImageGammaFilter.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2012 CyberAgent
+ * Copyright (C) 2018 CyberAgent, Inc.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -14,7 +14,7 @@
  * limitations under the License.
  */
 
-package jp.co.cyberagent.android.gpuimage;
+package jp.co.cyberagent.android.gpuimage.filter;
 
 import android.opengl.GLES20;
 
@@ -35,8 +35,8 @@
             "     gl_FragColor = vec4(pow(textureColor.rgb, vec3(gamma)), textureColor.w);\n" +
             " }";
 
-    private int mGammaLocation;
-    private float mGamma;
+    private int gammaLocation;
+    private float gamma;
 
     public GPUImageGammaFilter() {
         this(1.2f);
@@ -44,23 +44,23 @@ public GPUImageGammaFilter() {
 
     public GPUImageGammaFilter(final float gamma) {
         super(NO_FILTER_VERTEX_SHADER, GAMMA_FRAGMENT_SHADER);
-        mGamma = gamma;
+        this.gamma = gamma;
     }
 
     @Override
     public void onInit() {
         super.onInit();
-        mGammaLocation = GLES20.glGetUniformLocation(getProgram(), "gamma");
+        gammaLocation = GLES20.glGetUniformLocation(getProgram(), "gamma");
     }
 
     @Override
     public void onInitialized() {
         super.onInitialized();
-        setGamma(mGamma);
+        setGamma(gamma);
     }
 
     public void setGamma(final float gamma) {
-        mGamma = gamma;
-        setFloat(mGammaLocation, mGamma);
+        this.gamma = gamma;
+        setFloat(gammaLocation, this.gamma);
     }
 }
diff --git a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageGaussianBlurFilter.java b/library/src/main/java/jp/co/cyberagent/android/gpuimage/filter/GPUImageGaussianBlurFilter.java
similarity index 92%
rename from library/src/jp/co/cyberagent/android/gpuimage/GPUImageGaussianBlurFilter.java
rename to library/src/main/java/jp/co/cyberagent/android/gpuimage/filter/GPUImageGaussianBlurFilter.java
index c912f73e..c945a07e 100644
--- a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageGaussianBlurFilter.java
+++ b/library/src/main/java/jp/co/cyberagent/android/gpuimage/filter/GPUImageGaussianBlurFilter.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2012 CyberAgent
+ * Copyright (C) 2018 CyberAgent, Inc.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -14,7 +14,7 @@
  * limitations under the License.
  */
 
-package jp.co.cyberagent.android.gpuimage;
+package jp.co.cyberagent.android.gpuimage.filter;
 
 /**
  * A more generalized 9x9 Gaussian blur filter
@@ -78,7 +78,7 @@
                     "	gl_FragColor = vec4(sum,fragColor.a);\n" +
                     "}";
 
-    protected float mBlurSize = 1f;
+    protected float blurSize;
 
     public GPUImageGaussianBlurFilter() {
         this(1f);
@@ -86,17 +86,23 @@ public GPUImageGaussianBlurFilter() {
 
     public GPUImageGaussianBlurFilter(float blurSize) {
         super(VERTEX_SHADER, FRAGMENT_SHADER, VERTEX_SHADER, FRAGMENT_SHADER);
-        mBlurSize = blurSize;
+        this.blurSize = blurSize;
+    }
+
+    @Override
+    public void onInitialized() {
+        super.onInitialized();
+        setBlurSize(blurSize);
     }
 
     @Override
     public float getVerticalTexelOffsetRatio() {
-        return mBlurSize;
+        return blurSize;
     }
 
     @Override
     public float getHorizontalTexelOffsetRatio() {
-        return mBlurSize;
+        return blurSize;
     }
 
     /**
@@ -105,7 +111,7 @@ public float getHorizontalTexelOffsetRatio() {
      * @param blurSize from 0.0 on up, default 1.0
      */
     public void setBlurSize(float blurSize) {
-        mBlurSize = blurSize;
+        this.blurSize = blurSize;
         runOnDraw(new Runnable() {
             @Override
             public void run() {
diff --git a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageGlassSphereFilter.java b/library/src/main/java/jp/co/cyberagent/android/gpuimage/filter/GPUImageGlassSphereFilter.java
similarity index 73%
rename from library/src/jp/co/cyberagent/android/gpuimage/GPUImageGlassSphereFilter.java
rename to library/src/main/java/jp/co/cyberagent/android/gpuimage/filter/GPUImageGlassSphereFilter.java
index 460019cc..e43b348a 100644
--- a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageGlassSphereFilter.java
+++ b/library/src/main/java/jp/co/cyberagent/android/gpuimage/filter/GPUImageGlassSphereFilter.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2012 CyberAgent
+ * Copyright (C) 2018 CyberAgent, Inc.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -14,7 +14,7 @@
  * limitations under the License.
  */
 
-package jp.co.cyberagent.android.gpuimage;
+package jp.co.cyberagent.android.gpuimage.filter;
 
 import android.graphics.PointF;
 import android.opengl.GLES20;
@@ -61,14 +61,14 @@
             "gl_FragColor = vec4(finalSphereColor, 1.0) * checkForPresenceWithinSphere;\n" +
             "}\n";
 
-    private PointF mCenter;
-    private int mCenterLocation;
-    private float mRadius;
-    private int mRadiusLocation;
-    private float mAspectRatio;
-    private int mAspectRatioLocation;
-    private float mRefractiveIndex;
-    private int mRefractiveIndexLocation;
+    private PointF center;
+    private int centerLocation;
+    private float radius;
+    private int radiusLocation;
+    private float aspectRatio;
+    private int aspectRatioLocation;
+    private float refractiveIndex;
+    private int refractiveIndexLocation;
 
     public GPUImageGlassSphereFilter() {
         this(new PointF(0.5f, 0.5f), 0.25f, 0.71f);
@@ -76,52 +76,53 @@ public GPUImageGlassSphereFilter() {
 
     public GPUImageGlassSphereFilter(PointF center, float radius, float refractiveIndex) {
         super(NO_FILTER_VERTEX_SHADER, SPHERE_FRAGMENT_SHADER);
-        mCenter = center;
-        mRadius = radius;
-        mRefractiveIndex = refractiveIndex;
+        this.center = center;
+        this.radius = radius;
+        this.refractiveIndex = refractiveIndex;
     }
 
     @Override
     public void onInit() {
         super.onInit();
-        mCenterLocation = GLES20.glGetUniformLocation(getProgram(), "center");
-        mRadiusLocation = GLES20.glGetUniformLocation(getProgram(), "radius");
-        mAspectRatioLocation = GLES20.glGetUniformLocation(getProgram(), "aspectRatio");
-        mRefractiveIndexLocation = GLES20.glGetUniformLocation(getProgram(), "refractiveIndex");
+        centerLocation = GLES20.glGetUniformLocation(getProgram(), "center");
+        radiusLocation = GLES20.glGetUniformLocation(getProgram(), "radius");
+        aspectRatioLocation = GLES20.glGetUniformLocation(getProgram(), "aspectRatio");
+        refractiveIndexLocation = GLES20.glGetUniformLocation(getProgram(), "refractiveIndex");
     }
 
     @Override
     public void onInitialized() {
         super.onInitialized();
-        setRadius(mRadius);
-        setCenter(mCenter);
-        setRefractiveIndex(mRefractiveIndex);
+        setAspectRatio(aspectRatio);
+        setRadius(radius);
+        setCenter(center);
+        setRefractiveIndex(refractiveIndex);
     }
 
     @Override
     public void onOutputSizeChanged(int width, int height) {
-        mAspectRatio = (float) height / width;
-        setAspectRatio(mAspectRatio);
+        aspectRatio = (float) height / width;
+        setAspectRatio(aspectRatio);
         super.onOutputSizeChanged(width, height);
     }
 
     private void setAspectRatio(float aspectRatio) {
-        mAspectRatio = aspectRatio;
-        setFloat(mAspectRatioLocation, aspectRatio);
+        this.aspectRatio = aspectRatio;
+        setFloat(aspectRatioLocation, aspectRatio);
     }
 
     public void setRefractiveIndex(float refractiveIndex) {
-        mRefractiveIndex = refractiveIndex;
-        setFloat(mRefractiveIndexLocation, refractiveIndex);
+        this.refractiveIndex = refractiveIndex;
+        setFloat(refractiveIndexLocation, refractiveIndex);
     }
 
     public void setCenter(PointF center) {
-        mCenter = center;
-        setPoint(mCenterLocation, center);
+        this.center = center;
+        setPoint(centerLocation, center);
     }
 
     public void setRadius(float radius) {
-        mRadius = radius;
-        setFloat(mRadiusLocation, radius);
+        this.radius = radius;
+        setFloat(radiusLocation, radius);
     }
 }
diff --git a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageGrayscaleFilter.java b/library/src/main/java/jp/co/cyberagent/android/gpuimage/filter/GPUImageGrayscaleFilter.java
similarity index 94%
rename from library/src/jp/co/cyberagent/android/gpuimage/GPUImageGrayscaleFilter.java
rename to library/src/main/java/jp/co/cyberagent/android/gpuimage/filter/GPUImageGrayscaleFilter.java
index b0a67f9e..3f658646 100644
--- a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageGrayscaleFilter.java
+++ b/library/src/main/java/jp/co/cyberagent/android/gpuimage/filter/GPUImageGrayscaleFilter.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2012 CyberAgent
+ * Copyright (C) 2018 CyberAgent, Inc.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -14,7 +14,7 @@
  * limitations under the License.
  */
 
-package jp.co.cyberagent.android.gpuimage;
+package jp.co.cyberagent.android.gpuimage.filter;
 
 /**
  * Applies a grayscale effect to the image.
diff --git a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageHalftoneFilter.java b/library/src/main/java/jp/co/cyberagent/android/gpuimage/filter/GPUImageHalftoneFilter.java
similarity index 68%
rename from library/src/jp/co/cyberagent/android/gpuimage/GPUImageHalftoneFilter.java
rename to library/src/main/java/jp/co/cyberagent/android/gpuimage/filter/GPUImageHalftoneFilter.java
index 52e27d04..1bde2b9a 100644
--- a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageHalftoneFilter.java
+++ b/library/src/main/java/jp/co/cyberagent/android/gpuimage/filter/GPUImageHalftoneFilter.java
@@ -1,4 +1,4 @@
-package jp.co.cyberagent.android.gpuimage;
+package jp.co.cyberagent.android.gpuimage.filter;
 
 import android.opengl.GLES20;
 
@@ -26,11 +26,11 @@
             "  gl_FragColor = vec4(vec3(checkForPresenceWithinDot), 1.0);\n" +
             "}";
 
-    private int mFractionalWidthOfPixelLocation;
-    private int mAspectRatioLocation;
+    private int fractionalWidthOfPixelLocation;
+    private int aspectRatioLocation;
 
-    private float mFractionalWidthOfAPixel;
-    private float mAspectRatio;
+    private float fractionalWidthOfAPixel;
+    private float aspectRatio;
 
     public GPUImageHalftoneFilter() {
         this(0.01f);
@@ -38,30 +38,36 @@ public GPUImageHalftoneFilter() {
 
     public GPUImageHalftoneFilter(float fractionalWidthOfAPixel) {
         super(NO_FILTER_VERTEX_SHADER, HALFTONE_FRAGMENT_SHADER);
-        mFractionalWidthOfAPixel = fractionalWidthOfAPixel;
+        this.fractionalWidthOfAPixel = fractionalWidthOfAPixel;
     }
 
     @Override
     public void onInit() {
         super.onInit();
-        mFractionalWidthOfPixelLocation = GLES20.glGetUniformLocation(getProgram(), "fractionalWidthOfPixel");
-        mAspectRatioLocation = GLES20.glGetUniformLocation(getProgram(), "aspectRatio");
-        setFractionalWidthOfAPixel(mFractionalWidthOfAPixel);
+        fractionalWidthOfPixelLocation = GLES20.glGetUniformLocation(getProgram(), "fractionalWidthOfPixel");
+        aspectRatioLocation = GLES20.glGetUniformLocation(getProgram(), "aspectRatio");
+    }
+
+    @Override
+    public void onInitialized() {
+        super.onInitialized();
+        setFractionalWidthOfAPixel(fractionalWidthOfAPixel);
+        setAspectRatio(aspectRatio);
     }
 
     @Override
     public void onOutputSizeChanged(final int width, final int height) {
         super.onOutputSizeChanged(width, height);
-        setAspectRatio((float)height / (float) width);
+        setAspectRatio((float) height / (float) width);
     }
 
     public void setFractionalWidthOfAPixel(final float fractionalWidthOfAPixel) {
-        mFractionalWidthOfAPixel = fractionalWidthOfAPixel;
-        setFloat(mFractionalWidthOfPixelLocation, mFractionalWidthOfAPixel);
+        this.fractionalWidthOfAPixel = fractionalWidthOfAPixel;
+        setFloat(fractionalWidthOfPixelLocation, this.fractionalWidthOfAPixel);
     }
 
     public void setAspectRatio(final float aspectRatio) {
-        mAspectRatio = aspectRatio;
-        setFloat(mAspectRatioLocation, mAspectRatio);
+        this.aspectRatio = aspectRatio;
+        setFloat(aspectRatioLocation, this.aspectRatio);
     }
 }
diff --git a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageHardLightBlendFilter.java b/library/src/main/java/jp/co/cyberagent/android/gpuimage/filter/GPUImageHardLightBlendFilter.java
similarity index 96%
rename from library/src/jp/co/cyberagent/android/gpuimage/GPUImageHardLightBlendFilter.java
rename to library/src/main/java/jp/co/cyberagent/android/gpuimage/filter/GPUImageHardLightBlendFilter.java
index 5bcb9c90..57cc142b 100644
--- a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageHardLightBlendFilter.java
+++ b/library/src/main/java/jp/co/cyberagent/android/gpuimage/filter/GPUImageHardLightBlendFilter.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2012 CyberAgent
+ * Copyright (C) 2018 CyberAgent, Inc.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -14,7 +14,7 @@
  * limitations under the License.
  */
 
-package jp.co.cyberagent.android.gpuimage;
+package jp.co.cyberagent.android.gpuimage.filter;
 
 public class GPUImageHardLightBlendFilter extends GPUImageTwoInputFilter {
     public static final String HARD_LIGHT_BLEND_FRAGMENT_SHADER = "varying highp vec2 textureCoordinate;\n" +
diff --git a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageHazeFilter.java b/library/src/main/java/jp/co/cyberagent/android/gpuimage/filter/GPUImageHazeFilter.java
similarity index 79%
rename from library/src/jp/co/cyberagent/android/gpuimage/GPUImageHazeFilter.java
rename to library/src/main/java/jp/co/cyberagent/android/gpuimage/filter/GPUImageHazeFilter.java
index bb230abc..11da6f3d 100644
--- a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageHazeFilter.java
+++ b/library/src/main/java/jp/co/cyberagent/android/gpuimage/filter/GPUImageHazeFilter.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2012 CyberAgent
+ * Copyright (C) 2018 CyberAgent, Inc.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -14,13 +14,13 @@
  * limitations under the License.
  */
 
-package jp.co.cyberagent.android.gpuimage;
+package jp.co.cyberagent.android.gpuimage.filter;
 
 import android.opengl.GLES20;
 
 /**
  * The haze filter can be used to add or remove haze.
- *
+ * <p>
  * This is similar to a UV filter.
  */
 public class GPUImageHazeFilter extends GPUImageFilter {
@@ -46,10 +46,10 @@
             "	 gl_FragColor = c; //consider using premultiply(c);\n" +
             "}\n";
 
-    private float mDistance;
-    private int mDistanceLocation;
-    private float mSlope;
-    private int mSlopeLocation;
+    private float distance;
+    private int distanceLocation;
+    private float slope;
+    private int slopeLocation;
 
     public GPUImageHazeFilter() {
         this(0.2f, 0.0f);
@@ -57,22 +57,22 @@ public GPUImageHazeFilter() {
 
     public GPUImageHazeFilter(float distance, float slope) {
         super(NO_FILTER_VERTEX_SHADER, HAZE_FRAGMENT_SHADER);
-        mDistance = distance;
-        mSlope = slope;
+        this.distance = distance;
+        this.slope = slope;
     }
 
     @Override
     public void onInit() {
         super.onInit();
-        mDistanceLocation = GLES20.glGetUniformLocation(getProgram(), "distance");
-        mSlopeLocation = GLES20.glGetUniformLocation(getProgram(), "slope");
+        distanceLocation = GLES20.glGetUniformLocation(getProgram(), "distance");
+        slopeLocation = GLES20.glGetUniformLocation(getProgram(), "slope");
     }
 
     @Override
     public void onInitialized() {
         super.onInitialized();
-        setDistance(mDistance);
-        setSlope(mSlope);
+        setDistance(distance);
+        setSlope(slope);
     }
 
     /**
@@ -81,8 +81,8 @@ public void onInitialized() {
      * @param distance -0.3 to 0.3 are best, default 0
      */
     public void setDistance(float distance) {
-        mDistance = distance;
-        setFloat(mDistanceLocation, distance);
+        this.distance = distance;
+        setFloat(distanceLocation, distance);
     }
 
     /**
@@ -91,7 +91,7 @@ public void setDistance(float distance) {
      * @param slope -0.3 to 0.3 are best, default 0
      */
     public void setSlope(float slope) {
-        mSlope = slope;
-        setFloat(mSlopeLocation, slope);
+        this.slope = slope;
+        setFloat(slopeLocation, slope);
     }
 }
diff --git a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageHighlightShadowFilter.java b/library/src/main/java/jp/co/cyberagent/android/gpuimage/filter/GPUImageHighlightShadowFilter.java
similarity index 79%
rename from library/src/jp/co/cyberagent/android/gpuimage/GPUImageHighlightShadowFilter.java
rename to library/src/main/java/jp/co/cyberagent/android/gpuimage/filter/GPUImageHighlightShadowFilter.java
index 878c508a..37eabb96 100644
--- a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageHighlightShadowFilter.java
+++ b/library/src/main/java/jp/co/cyberagent/android/gpuimage/filter/GPUImageHighlightShadowFilter.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2012 CyberAgent
+ * Copyright (C) 2018 CyberAgent, Inc.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -14,7 +14,7 @@
  * limitations under the License.
  */
 
-package jp.co.cyberagent.android.gpuimage;
+package jp.co.cyberagent.android.gpuimage.filter;
 
 import android.opengl.GLES20;
 
@@ -45,10 +45,10 @@
             " 	gl_FragColor = vec4(result.rgb, source.a);\n" +
             " }";
 
-    private int mShadowsLocation;
-    private float mShadows;
-    private int mHighlightsLocation;
-    private float mHighlights;
+    private int shadowsLocation;
+    private float shadows;
+    private int highlightsLocation;
+    private float highlights;
 
     public GPUImageHighlightShadowFilter() {
         this(0.0f, 1.0f);
@@ -56,31 +56,31 @@ public GPUImageHighlightShadowFilter() {
 
     public GPUImageHighlightShadowFilter(final float shadows, final float highlights) {
         super(NO_FILTER_VERTEX_SHADER, HIGHLIGHT_SHADOW_FRAGMENT_SHADER);
-        mHighlights = highlights;
-        mShadows = shadows;
+        this.highlights = highlights;
+        this.shadows = shadows;
     }
 
     @Override
     public void onInit() {
         super.onInit();
-        mHighlightsLocation = GLES20.glGetUniformLocation(getProgram(), "highlights");
-        mShadowsLocation = GLES20.glGetUniformLocation(getProgram(), "shadows");
+        highlightsLocation = GLES20.glGetUniformLocation(getProgram(), "highlights");
+        shadowsLocation = GLES20.glGetUniformLocation(getProgram(), "shadows");
     }
 
     @Override
     public void onInitialized() {
         super.onInitialized();
-        setHighlights(mHighlights);
-        setShadows(mShadows);
+        setHighlights(highlights);
+        setShadows(shadows);
     }
 
     public void setHighlights(final float highlights) {
-        mHighlights = highlights;
-        setFloat(mHighlightsLocation, mHighlights);
+        this.highlights = highlights;
+        setFloat(highlightsLocation, this.highlights);
     }
-    
+
     public void setShadows(final float shadows) {
-        mShadows = shadows;
-        setFloat(mShadowsLocation, mShadows);
+        this.shadows = shadows;
+        setFloat(shadowsLocation, this.shadows);
     }
 }
diff --git a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageHueBlendFilter.java b/library/src/main/java/jp/co/cyberagent/android/gpuimage/filter/GPUImageHueBlendFilter.java
similarity index 98%
rename from library/src/jp/co/cyberagent/android/gpuimage/GPUImageHueBlendFilter.java
rename to library/src/main/java/jp/co/cyberagent/android/gpuimage/filter/GPUImageHueBlendFilter.java
index 3950901c..143e3fc7 100644
--- a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageHueBlendFilter.java
+++ b/library/src/main/java/jp/co/cyberagent/android/gpuimage/filter/GPUImageHueBlendFilter.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2012 CyberAgent
+ * Copyright (C) 2018 CyberAgent, Inc.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -14,7 +14,7 @@
  * limitations under the License.
  */
 
-package jp.co.cyberagent.android.gpuimage;
+package jp.co.cyberagent.android.gpuimage.filter;
 
 public class GPUImageHueBlendFilter extends GPUImageTwoInputFilter {
     public static final String HUE_BLEND_FRAGMENT_SHADER = "varying highp vec2 textureCoordinate;\n" +
diff --git a/library/src/main/java/jp/co/cyberagent/android/gpuimage/filter/GPUImageHueFilter.java b/library/src/main/java/jp/co/cyberagent/android/gpuimage/filter/GPUImageHueFilter.java
new file mode 100644
index 00000000..ce930305
--- /dev/null
+++ b/library/src/main/java/jp/co/cyberagent/android/gpuimage/filter/GPUImageHueFilter.java
@@ -0,0 +1,96 @@
+/*
+ * Copyright (C) 2018 CyberAgent, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package jp.co.cyberagent.android.gpuimage.filter;
+
+import android.opengl.GLES20;
+
+public class GPUImageHueFilter extends GPUImageFilter {
+    public static final String HUE_FRAGMENT_SHADER = "" +
+            "precision highp float;\n" +
+            "varying highp vec2 textureCoordinate;\n" +
+            "\n" +
+            "uniform sampler2D inputImageTexture;\n" +
+            "uniform mediump float hueAdjust;\n" +
+            "const highp vec4 kRGBToYPrime = vec4 (0.299, 0.587, 0.114, 0.0);\n" +
+            "const highp vec4 kRGBToI = vec4 (0.595716, -0.274453, -0.321263, 0.0);\n" +
+            "const highp vec4 kRGBToQ = vec4 (0.211456, -0.522591, 0.31135, 0.0);\n" +
+            "\n" +
+            "const highp vec4 kYIQToR = vec4 (1.0, 0.9563, 0.6210, 0.0);\n" +
+            "const highp vec4 kYIQToG = vec4 (1.0, -0.2721, -0.6474, 0.0);\n" +
+            "const highp vec4 kYIQToB = vec4 (1.0, -1.1070, 1.7046, 0.0);\n" +
+            "\n" +
+            "void main ()\n" +
+            "{\n" +
+            "    // Sample the input pixel\n" +
+            "    highp vec4 color = texture2D(inputImageTexture, textureCoordinate);\n" +
+            "\n" +
+            "    // Convert to YIQ\n" +
+            "    highp float YPrime = dot (color, kRGBToYPrime);\n" +
+            "    highp float I = dot (color, kRGBToI);\n" +
+            "    highp float Q = dot (color, kRGBToQ);\n" +
+            "\n" +
+            "    // Calculate the hue and chroma\n" +
+            "    highp float hue = atan (Q, I);\n" +
+            "    highp float chroma = sqrt (I * I + Q * Q);\n" +
+            "\n" +
+            "    // Make the user's adjustments\n" +
+            "    hue += (-hueAdjust); //why negative rotation?\n" +
+            "\n" +
+            "    // Convert back to YIQ\n" +
+            "    Q = chroma * sin (hue);\n" +
+            "    I = chroma * cos (hue);\n" +
+            "\n" +
+            "    // Convert back to RGB\n" +
+            "    highp vec4 yIQ = vec4 (YPrime, I, Q, 0.0);\n" +
+            "    color.r = dot (yIQ, kYIQToR);\n" +
+            "    color.g = dot (yIQ, kYIQToG);\n" +
+            "    color.b = dot (yIQ, kYIQToB);\n" +
+            "\n" +
+            "    // Save the result\n" +
+            "    gl_FragColor = color;\n" +
+            "}\n";
+
+    private float hue;
+    private int hueLocation;
+
+    public GPUImageHueFilter() {
+        this(90.0f);
+    }
+
+    public GPUImageHueFilter(final float hue) {
+        super(NO_FILTER_VERTEX_SHADER, HUE_FRAGMENT_SHADER);
+        this.hue = hue;
+    }
+
+    @Override
+    public void onInit() {
+        super.onInit();
+        hueLocation = GLES20.glGetUniformLocation(getProgram(), "hueAdjust");
+    }
+
+    @Override
+    public void onInitialized() {
+        super.onInitialized();
+        setHue(hue);
+    }
+
+    public void setHue(final float hue) {
+        this.hue = hue;
+        float hueAdjust = (this.hue % 360.0f) * (float) Math.PI / 180.0f;
+        setFloat(hueLocation, hueAdjust);
+    }
+}
diff --git a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageKuwaharaFilter.java b/library/src/main/java/jp/co/cyberagent/android/gpuimage/filter/GPUImageKuwaharaFilter.java
similarity index 93%
rename from library/src/jp/co/cyberagent/android/gpuimage/GPUImageKuwaharaFilter.java
rename to library/src/main/java/jp/co/cyberagent/android/gpuimage/filter/GPUImageKuwaharaFilter.java
index 6fc7f32b..f047e61a 100644
--- a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageKuwaharaFilter.java
+++ b/library/src/main/java/jp/co/cyberagent/android/gpuimage/filter/GPUImageKuwaharaFilter.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2012 CyberAgent
+ * Copyright (C) 2018 CyberAgent, Inc.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -14,7 +14,7 @@
  * limitations under the License.
  */
 
-package jp.co.cyberagent.android.gpuimage;
+package jp.co.cyberagent.android.gpuimage.filter;
 
 import android.opengl.GLES20;
 
@@ -114,8 +114,8 @@
             "}\n" +
             "}\n";
 
-    private int mRadius;
-    private int mRadiusLocation;
+    private int radius;
+    private int radiusLocation;
 
     public GPUImageKuwaharaFilter() {
         this(3);
@@ -123,19 +123,19 @@ public GPUImageKuwaharaFilter() {
 
     public GPUImageKuwaharaFilter(int radius) {
         super(NO_FILTER_VERTEX_SHADER, KUWAHARA_FRAGMENT_SHADER);
-        mRadius = radius;
+        this.radius = radius;
     }
 
     @Override
     public void onInit() {
         super.onInit();
-        mRadiusLocation = GLES20.glGetUniformLocation(getProgram(), "radius");
+        radiusLocation = GLES20.glGetUniformLocation(getProgram(), "radius");
     }
 
     @Override
     public void onInitialized() {
         super.onInitialized();
-        setRadius(mRadius);
+        setRadius(radius);
     }
 
     /**
@@ -145,7 +145,7 @@ public void onInitialized() {
      * @param radius default 3
      */
     public void setRadius(final int radius) {
-        mRadius = radius;
-        setInteger(mRadiusLocation, radius);
+        this.radius = radius;
+        setInteger(radiusLocation, radius);
     }
 }
diff --git a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageLaplacianFilter.java b/library/src/main/java/jp/co/cyberagent/android/gpuimage/filter/GPUImageLaplacianFilter.java
similarity index 86%
rename from library/src/jp/co/cyberagent/android/gpuimage/GPUImageLaplacianFilter.java
rename to library/src/main/java/jp/co/cyberagent/android/gpuimage/filter/GPUImageLaplacianFilter.java
index d320f64d..566927a4 100644
--- a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageLaplacianFilter.java
+++ b/library/src/main/java/jp/co/cyberagent/android/gpuimage/filter/GPUImageLaplacianFilter.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2012 CyberAgent
+ * Copyright (C) 2018 CyberAgent, Inc.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -14,7 +14,7 @@
  * limitations under the License.
  */
 
-package jp.co.cyberagent.android.gpuimage;
+package jp.co.cyberagent.android.gpuimage.filter;
 
 import android.opengl.GLES20;
 
@@ -60,8 +60,8 @@
             "gl_FragColor = vec4(resultColor, centerColor.a);\n" +
             "}\n";
 
-    private float[] mConvolutionKernel;
-    private int mUniformConvolutionMatrix;
+    private float[] convolutionKernel;
+    private int uniformConvolutionMatrix;
 
     public GPUImageLaplacianFilter() {
         this(new float[]{
@@ -73,18 +73,23 @@ public GPUImageLaplacianFilter() {
 
     private GPUImageLaplacianFilter(final float[] convolutionKernel) {
         super(LAPLACIAN_FRAGMENT_SHADER);
-        mConvolutionKernel = convolutionKernel;
+        this.convolutionKernel = convolutionKernel;
     }
 
     @Override
     public void onInit() {
         super.onInit();
-        mUniformConvolutionMatrix = GLES20.glGetUniformLocation(getProgram(), "convolutionMatrix");
-        setConvolutionKernel(mConvolutionKernel);
+        uniformConvolutionMatrix = GLES20.glGetUniformLocation(getProgram(), "convolutionMatrix");
+    }
+
+    @Override
+    public void onInitialized() {
+        super.onInitialized();
+        setConvolutionKernel(convolutionKernel);
     }
 
     private void setConvolutionKernel(final float[] convolutionKernel) {
-        mConvolutionKernel = convolutionKernel;
-        setUniformMatrix3f(mUniformConvolutionMatrix, mConvolutionKernel);
+        this.convolutionKernel = convolutionKernel;
+        setUniformMatrix3f(uniformConvolutionMatrix, this.convolutionKernel);
     }
 }
diff --git a/library/src/main/java/jp/co/cyberagent/android/gpuimage/filter/GPUImageLevelsFilter.java b/library/src/main/java/jp/co/cyberagent/android/gpuimage/filter/GPUImageLevelsFilter.java
new file mode 100644
index 00000000..3ceaca5b
--- /dev/null
+++ b/library/src/main/java/jp/co/cyberagent/android/gpuimage/filter/GPUImageLevelsFilter.java
@@ -0,0 +1,129 @@
+package jp.co.cyberagent.android.gpuimage.filter;
+
+import android.opengl.GLES20;
+
+/**
+ * Created by vashisthg 30/05/14.
+ */
+public class GPUImageLevelsFilter extends GPUImageFilter {
+
+    private static final String LOGTAG = GPUImageLevelsFilter.class.getSimpleName();
+
+    public static final String LEVELS_FRAGMET_SHADER =
+
+            " varying highp vec2 textureCoordinate;\n" +
+                    " \n" +
+                    " uniform sampler2D inputImageTexture;\n" +
+                    " uniform mediump vec3 levelMinimum;\n" +
+                    " uniform mediump vec3 levelMiddle;\n" +
+                    " uniform mediump vec3 levelMaximum;\n" +
+                    " uniform mediump vec3 minOutput;\n" +
+                    " uniform mediump vec3 maxOutput;\n" +
+                    " \n" +
+                    " void main()\n" +
+                    " {\n" +
+                    "     mediump vec4 textureColor = texture2D(inputImageTexture, textureCoordinate);\n" +
+                    "     \n" +
+                    "     gl_FragColor = vec4( mix(minOutput, maxOutput, pow(min(max(textureColor.rgb -levelMinimum, vec3(0.0)) / (levelMaximum - levelMinimum  ), vec3(1.0)), 1.0 /levelMiddle)) , textureColor.a);\n" +
+                    " }\n";
+
+    private int minLocation;
+    private float[] min;
+    private int midLocation;
+    private float[] mid;
+    private int maxLocation;
+    private float[] max;
+    private int minOutputLocation;
+    private float[] minOutput;
+    private int maxOutputLocation;
+    private float[] maxOutput;
+
+    public GPUImageLevelsFilter() {
+        this(new float[]{0.0f, 0.0f, 0.0f}, new float[]{1.0f, 1.0f, 1.0f}, new float[]{1.0f, 1.0f, 1.0f}, new float[]{0.0f, 0.0f, 0.0f}, new float[]{1.0f, 1.0f, 1.0f});
+    }
+
+    private GPUImageLevelsFilter(final float[] min, final float[] mid, final float[] max, final float[] minOUt, final float[] maxOut) {
+        super(NO_FILTER_VERTEX_SHADER, LEVELS_FRAGMET_SHADER);
+
+        this.min = min;
+        this.mid = mid;
+        this.max = max;
+        minOutput = minOUt;
+        maxOutput = maxOut;
+    }
+
+    @Override
+    public void onInit() {
+        super.onInit();
+        minLocation = GLES20.glGetUniformLocation(getProgram(), "levelMinimum");
+        midLocation = GLES20.glGetUniformLocation(getProgram(), "levelMiddle");
+        maxLocation = GLES20.glGetUniformLocation(getProgram(), "levelMaximum");
+        minOutputLocation = GLES20.glGetUniformLocation(getProgram(), "minOutput");
+        maxOutputLocation = GLES20.glGetUniformLocation(getProgram(), "maxOutput");
+    }
+
+    @Override
+    public void onInitialized() {
+        super.onInitialized();
+        setMin(0.0f, 1.0f, 1.0f, 0.0f, 1.0f);
+        updateUniforms();
+    }
+
+
+    public void updateUniforms() {
+        setFloatVec3(minLocation, min);
+        setFloatVec3(midLocation, mid);
+        setFloatVec3(maxLocation, max);
+        setFloatVec3(minOutputLocation, minOutput);
+        setFloatVec3(maxOutputLocation, maxOutput);
+    }
+
+    public void setMin(float min, float mid, float max, float minOut, float maxOut) {
+        setRedMin(min, mid, max, minOut, maxOut);
+        setGreenMin(min, mid, max, minOut, maxOut);
+        setBlueMin(min, mid, max, minOut, maxOut);
+    }
+
+    public void setMin(float min, float mid, float max) {
+        setMin(min, mid, max, 0.0f, 1.0f);
+    }
+
+    public void setRedMin(float min, float mid, float max, float minOut, float maxOut) {
+        this.min[0] = min;
+        this.mid[0] = mid;
+        this.max[0] = max;
+        minOutput[0] = minOut;
+        maxOutput[0] = maxOut;
+        updateUniforms();
+    }
+
+    public void setRedMin(float min, float mid, float max) {
+        setRedMin(min, mid, max, 0, 1);
+    }
+
+    public void setGreenMin(float min, float mid, float max, float minOut, float maxOut) {
+        this.min[1] = min;
+        this.mid[1] = mid;
+        this.max[1] = max;
+        minOutput[1] = minOut;
+        maxOutput[1] = maxOut;
+        updateUniforms();
+    }
+
+    public void setGreenMin(float min, float mid, float max) {
+        setGreenMin(min, mid, max, 0, 1);
+    }
+
+    public void setBlueMin(float min, float mid, float max, float minOut, float maxOut) {
+        this.min[2] = min;
+        this.mid[2] = mid;
+        this.max[2] = max;
+        minOutput[2] = minOut;
+        maxOutput[2] = maxOut;
+        updateUniforms();
+    }
+
+    public void setBlueMin(float min, float mid, float max) {
+        setBlueMin(min, mid, max, 0, 1);
+    }
+}
diff --git a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageLightenBlendFilter.java b/library/src/main/java/jp/co/cyberagent/android/gpuimage/filter/GPUImageLightenBlendFilter.java
similarity index 94%
rename from library/src/jp/co/cyberagent/android/gpuimage/GPUImageLightenBlendFilter.java
rename to library/src/main/java/jp/co/cyberagent/android/gpuimage/filter/GPUImageLightenBlendFilter.java
index 77399cb1..6a6e0723 100644
--- a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageLightenBlendFilter.java
+++ b/library/src/main/java/jp/co/cyberagent/android/gpuimage/filter/GPUImageLightenBlendFilter.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2012 CyberAgent
+ * Copyright (C) 2018 CyberAgent, Inc.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -14,7 +14,7 @@
  * limitations under the License.
  */
 
-package jp.co.cyberagent.android.gpuimage;
+package jp.co.cyberagent.android.gpuimage.filter;
 
 public class GPUImageLightenBlendFilter extends GPUImageTwoInputFilter {
     public static final String LIGHTEN_BLEND_FRAGMENT_SHADER = "varying highp vec2 textureCoordinate;\n" +
diff --git a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageLinearBurnBlendFilter.java b/library/src/main/java/jp/co/cyberagent/android/gpuimage/filter/GPUImageLinearBurnBlendFilter.java
similarity index 94%
rename from library/src/jp/co/cyberagent/android/gpuimage/GPUImageLinearBurnBlendFilter.java
rename to library/src/main/java/jp/co/cyberagent/android/gpuimage/filter/GPUImageLinearBurnBlendFilter.java
index 2623b528..dba21552 100644
--- a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageLinearBurnBlendFilter.java
+++ b/library/src/main/java/jp/co/cyberagent/android/gpuimage/filter/GPUImageLinearBurnBlendFilter.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2012 CyberAgent
+ * Copyright (C) 2018 CyberAgent, Inc.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -14,7 +14,7 @@
  * limitations under the License.
  */
 
-package jp.co.cyberagent.android.gpuimage;
+package jp.co.cyberagent.android.gpuimage.filter;
 
 public class GPUImageLinearBurnBlendFilter extends GPUImageTwoInputFilter {
     public static final String LINEAR_BURN_BLEND_FRAGMENT_SHADER = "varying highp vec2 textureCoordinate;\n" +
diff --git a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageLookupFilter.java b/library/src/main/java/jp/co/cyberagent/android/gpuimage/filter/GPUImageLookupFilter.java
similarity index 88%
rename from library/src/jp/co/cyberagent/android/gpuimage/GPUImageLookupFilter.java
rename to library/src/main/java/jp/co/cyberagent/android/gpuimage/filter/GPUImageLookupFilter.java
index 42c9ebdc..df56675d 100644
--- a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageLookupFilter.java
+++ b/library/src/main/java/jp/co/cyberagent/android/gpuimage/filter/GPUImageLookupFilter.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2012 CyberAgent
+ * Copyright (C) 2018 CyberAgent, Inc.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -14,7 +14,7 @@
  * limitations under the License.
  */
 
-package jp.co.cyberagent.android.gpuimage;
+package jp.co.cyberagent.android.gpuimage.filter;
 
 import android.opengl.GLES20;
 
@@ -57,8 +57,8 @@
             "     gl_FragColor = mix(textureColor, vec4(newColor.rgb, textureColor.w), intensity);\n" +
             " }";
 
-    private int mIntensityLocation;
-    private float mIntensity;
+    private int intensityLocation;
+    private float intensity;
 
     public GPUImageLookupFilter() {
         this(1.0f);
@@ -66,23 +66,23 @@ public GPUImageLookupFilter() {
 
     public GPUImageLookupFilter(final float intensity) {
         super(LOOKUP_FRAGMENT_SHADER);
-        mIntensity = intensity;
+        this.intensity = intensity;
     }
 
     @Override
     public void onInit() {
         super.onInit();
-        mIntensityLocation = GLES20.glGetUniformLocation(getProgram(), "intensity");
+        intensityLocation = GLES20.glGetUniformLocation(getProgram(), "intensity");
     }
 
     @Override
     public void onInitialized() {
         super.onInitialized();
-        setIntensity(mIntensity);
+        setIntensity(intensity);
     }
 
     public void setIntensity(final float intensity) {
-        mIntensity = intensity;
-        setFloat(mIntensityLocation, mIntensity);
+        this.intensity = intensity;
+        setFloat(intensityLocation, this.intensity);
     }
 }
diff --git a/library/src/main/java/jp/co/cyberagent/android/gpuimage/filter/GPUImageLuminanceFilter.java b/library/src/main/java/jp/co/cyberagent/android/gpuimage/filter/GPUImageLuminanceFilter.java
new file mode 100644
index 00000000..4a4e7707
--- /dev/null
+++ b/library/src/main/java/jp/co/cyberagent/android/gpuimage/filter/GPUImageLuminanceFilter.java
@@ -0,0 +1,42 @@
+/*
+ * Copyright (C) 2018 CyberAgent, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package jp.co.cyberagent.android.gpuimage.filter;
+
+public class GPUImageLuminanceFilter extends GPUImageFilter {
+
+    public static final String LUMINANCE_FRAGMENT_SHADER = "" +
+            "precision highp float;\n" +
+            "\n" +
+            "varying vec2 textureCoordinate;\n" +
+            "\n" +
+            "uniform sampler2D inputImageTexture;\n" +
+            "\n" +
+            "// Values from \"Graphics Shaders: Theory and Practice\" by Bailey and Cunningham\n" +
+            "const highp vec3 W = vec3(0.2125, 0.7154, 0.0721);\n" +
+            "\n" +
+            "void main()\n" +
+            "{\n" +
+            "    lowp vec4 textureColor = texture2D(inputImageTexture, textureCoordinate);\n" +
+            "    float luminance = dot(textureColor.rgb, W);\n" +
+            "    \n" +
+            "    gl_FragColor = vec4(vec3(luminance), textureColor.a);\n" +
+            "}";
+
+    public GPUImageLuminanceFilter() {
+        super(NO_FILTER_VERTEX_SHADER, LUMINANCE_FRAGMENT_SHADER);
+    }
+}
diff --git a/library/src/main/java/jp/co/cyberagent/android/gpuimage/filter/GPUImageLuminanceThresholdFilter.java b/library/src/main/java/jp/co/cyberagent/android/gpuimage/filter/GPUImageLuminanceThresholdFilter.java
new file mode 100644
index 00000000..415ef5a1
--- /dev/null
+++ b/library/src/main/java/jp/co/cyberagent/android/gpuimage/filter/GPUImageLuminanceThresholdFilter.java
@@ -0,0 +1,68 @@
+/*
+ * Copyright (C) 2018 CyberAgent, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package jp.co.cyberagent.android.gpuimage.filter;
+
+import android.opengl.GLES20;
+
+public class GPUImageLuminanceThresholdFilter extends GPUImageFilter {
+
+    public static final String LUMINANCE_THRESHOLD_FRAGMENT_SHADER = "" +
+            "varying highp vec2 textureCoordinate;\n" +
+            "\n" +
+            "uniform sampler2D inputImageTexture;\n" +
+            "uniform highp float threshold;\n" +
+            "\n" +
+            "const highp vec3 W = vec3(0.2125, 0.7154, 0.0721);\n" +
+            "\n" +
+            "void main()\n" +
+            "{\n" +
+            "    highp vec4 textureColor = texture2D(inputImageTexture, textureCoordinate);\n" +
+            "    highp float luminance = dot(textureColor.rgb, W);\n" +
+            "    highp float thresholdResult = step(threshold, luminance);\n" +
+            "    \n" +
+            "    gl_FragColor = vec4(vec3(thresholdResult), textureColor.w);\n" +
+            "}";
+
+    private int uniformThresholdLocation;
+    private float threshold;
+
+    public GPUImageLuminanceThresholdFilter() {
+        this(0.5f);
+    }
+
+    public GPUImageLuminanceThresholdFilter(float threshold) {
+        super(NO_FILTER_VERTEX_SHADER, LUMINANCE_THRESHOLD_FRAGMENT_SHADER);
+        this.threshold = threshold;
+    }
+
+    @Override
+    public void onInit() {
+        super.onInit();
+        uniformThresholdLocation = GLES20.glGetUniformLocation(getProgram(), "threshold");
+    }
+
+    @Override
+    public void onInitialized() {
+        super.onInitialized();
+        setThreshold(threshold);
+    }
+
+    public void setThreshold(final float threshold) {
+        this.threshold = threshold;
+        setFloat(uniformThresholdLocation, threshold);
+    }
+}
diff --git a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageLuminosityBlendFilter.java b/library/src/main/java/jp/co/cyberagent/android/gpuimage/filter/GPUImageLuminosityBlendFilter.java
similarity index 96%
rename from library/src/jp/co/cyberagent/android/gpuimage/GPUImageLuminosityBlendFilter.java
rename to library/src/main/java/jp/co/cyberagent/android/gpuimage/filter/GPUImageLuminosityBlendFilter.java
index 85e7bfda..022f6645 100644
--- a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageLuminosityBlendFilter.java
+++ b/library/src/main/java/jp/co/cyberagent/android/gpuimage/filter/GPUImageLuminosityBlendFilter.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2012 CyberAgent
+ * Copyright (C) 2018 CyberAgent, Inc.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -14,7 +14,7 @@
  * limitations under the License.
  */
 
-package jp.co.cyberagent.android.gpuimage;
+package jp.co.cyberagent.android.gpuimage.filter;
 
 public class GPUImageLuminosityBlendFilter extends GPUImageTwoInputFilter {
     public static final String LUMINOSITY_BLEND_FRAGMENT_SHADER = "varying highp vec2 textureCoordinate;\n" +
diff --git a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageMixBlendFilter.java b/library/src/main/java/jp/co/cyberagent/android/gpuimage/filter/GPUImageMixBlendFilter.java
similarity index 78%
rename from library/src/jp/co/cyberagent/android/gpuimage/GPUImageMixBlendFilter.java
rename to library/src/main/java/jp/co/cyberagent/android/gpuimage/filter/GPUImageMixBlendFilter.java
index 7bf68859..d04177f0 100644
--- a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageMixBlendFilter.java
+++ b/library/src/main/java/jp/co/cyberagent/android/gpuimage/filter/GPUImageMixBlendFilter.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2012 CyberAgent
+ * Copyright (C) 2018 CyberAgent, Inc.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -14,14 +14,14 @@
  * limitations under the License.
  */
 
-package jp.co.cyberagent.android.gpuimage;
+package jp.co.cyberagent.android.gpuimage.filter;
 
 import android.opengl.GLES20;
 
 public class GPUImageMixBlendFilter extends GPUImageTwoInputFilter {
 
-    private int mMixLocation;
-    private float mMix;
+    private int mixLocation;
+    private float mix;
 
     public GPUImageMixBlendFilter(String fragmentShader) {
         this(fragmentShader, 0.5f);
@@ -29,26 +29,26 @@ public GPUImageMixBlendFilter(String fragmentShader) {
 
     public GPUImageMixBlendFilter(String fragmentShader, float mix) {
         super(fragmentShader);
-        mMix = mix;
+        this.mix = mix;
     }
 
     @Override
     public void onInit() {
         super.onInit();
-        mMixLocation = GLES20.glGetUniformLocation(getProgram(), "mixturePercent");
+        mixLocation = GLES20.glGetUniformLocation(getProgram(), "mixturePercent");
     }
 
     @Override
     public void onInitialized() {
         super.onInitialized();
-        setMix(mMix);
+        setMix(mix);
     }
 
     /**
      * @param mix ranges from 0.0 (only image 1) to 1.0 (only image 2), with 0.5 (half of either) as the normal level
      */
     public void setMix(final float mix) {
-        mMix = mix;
-        setFloat(mMixLocation, mMix);
+        this.mix = mix;
+        setFloat(mixLocation, this.mix);
     }
 }
diff --git a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageMonochromeFilter.java b/library/src/main/java/jp/co/cyberagent/android/gpuimage/filter/GPUImageMonochromeFilter.java
similarity index 78%
rename from library/src/jp/co/cyberagent/android/gpuimage/GPUImageMonochromeFilter.java
rename to library/src/main/java/jp/co/cyberagent/android/gpuimage/filter/GPUImageMonochromeFilter.java
index e426a340..30525b3f 100644
--- a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageMonochromeFilter.java
+++ b/library/src/main/java/jp/co/cyberagent/android/gpuimage/filter/GPUImageMonochromeFilter.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2012 CyberAgent
+ * Copyright (C) 2018 CyberAgent, Inc.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -14,7 +14,7 @@
  * limitations under the License.
  */
 
-package jp.co.cyberagent.android.gpuimage;
+package jp.co.cyberagent.android.gpuimage.filter;
 
 import android.opengl.GLES20;
 
@@ -55,47 +55,47 @@
             " 	gl_FragColor = vec4( mix(textureColor.rgb, outputColor.rgb, intensity), textureColor.a);\n" +
             "  }";
 
-    private int mIntensityLocation;
-    private float mIntensity;
-    private int mFilterColorLocation;
-    private float[] mColor;
+    private int intensityLocation;
+    private float intensity;
+    private int filterColorLocation;
+    private float[] color;
 
     public GPUImageMonochromeFilter() {
-        this(1.0f, new float[] {0.6f, 0.45f, 0.3f, 1.0f});
+        this(1.0f, new float[]{0.6f, 0.45f, 0.3f, 1.0f});
     }
 
     public GPUImageMonochromeFilter(final float intensity, final float[] color) {
         super(NO_FILTER_VERTEX_SHADER, MONOCHROME_FRAGMENT_SHADER);
-        mIntensity = intensity;
-        mColor = color;
+        this.intensity = intensity;
+        this.color = color;
     }
 
     @Override
     public void onInit() {
         super.onInit();
-        mIntensityLocation = GLES20.glGetUniformLocation(getProgram(), "intensity");
-        mFilterColorLocation = GLES20.glGetUniformLocation(getProgram(), "filterColor");
+        intensityLocation = GLES20.glGetUniformLocation(getProgram(), "intensity");
+        filterColorLocation = GLES20.glGetUniformLocation(getProgram(), "filterColor");
     }
 
     @Override
     public void onInitialized() {
         super.onInitialized();
         setIntensity(1.0f);
-        setColor(new float[]{ 0.6f, 0.45f, 0.3f, 1.f });
+        setColor(new float[]{0.6f, 0.45f, 0.3f, 1.f});
     }
 
     public void setIntensity(final float intensity) {
-        mIntensity = intensity;
-        setFloat(mIntensityLocation, mIntensity);
+        this.intensity = intensity;
+        setFloat(intensityLocation, this.intensity);
     }
-    
+
     public void setColor(final float[] color) {
-        mColor = color;
-        setColorRed(mColor[0], mColor[1], mColor[2]);
-        
+        this.color = color;
+        setColor(this.color[0], this.color[1], this.color[2]);
+
     }
-    
-    public void setColorRed(final float red, final float green, final float blue) {
-        setFloatVec3(mFilterColorLocation, new float[]{ red, green, blue });
+
+    public void setColor(final float red, final float green, final float blue) {
+        setFloatVec3(filterColorLocation, new float[]{red, green, blue});
     }
 }
diff --git a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageMultiplyBlendFilter.java b/library/src/main/java/jp/co/cyberagent/android/gpuimage/filter/GPUImageMultiplyBlendFilter.java
similarity index 94%
rename from library/src/jp/co/cyberagent/android/gpuimage/GPUImageMultiplyBlendFilter.java
rename to library/src/main/java/jp/co/cyberagent/android/gpuimage/filter/GPUImageMultiplyBlendFilter.java
index 1e002e36..c5ea9ae8 100644
--- a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageMultiplyBlendFilter.java
+++ b/library/src/main/java/jp/co/cyberagent/android/gpuimage/filter/GPUImageMultiplyBlendFilter.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2012 CyberAgent
+ * Copyright (C) 2018 CyberAgent, Inc.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -14,7 +14,7 @@
  * limitations under the License.
  */
 
-package jp.co.cyberagent.android.gpuimage;
+package jp.co.cyberagent.android.gpuimage.filter;
 
 public class GPUImageMultiplyBlendFilter extends GPUImageTwoInputFilter {
     public static final String MULTIPLY_BLEND_FRAGMENT_SHADER = "varying highp vec2 textureCoordinate;\n" +
diff --git a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageNonMaximumSuppressionFilter.java b/library/src/main/java/jp/co/cyberagent/android/gpuimage/filter/GPUImageNonMaximumSuppressionFilter.java
similarity index 97%
rename from library/src/jp/co/cyberagent/android/gpuimage/GPUImageNonMaximumSuppressionFilter.java
rename to library/src/main/java/jp/co/cyberagent/android/gpuimage/filter/GPUImageNonMaximumSuppressionFilter.java
index a6f5af48..239ba935 100644
--- a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageNonMaximumSuppressionFilter.java
+++ b/library/src/main/java/jp/co/cyberagent/android/gpuimage/filter/GPUImageNonMaximumSuppressionFilter.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2012 CyberAgent
+ * Copyright (C) 2018 CyberAgent, Inc.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -14,7 +14,7 @@
  * limitations under the License.
  */
 
-package jp.co.cyberagent.android.gpuimage;
+package jp.co.cyberagent.android.gpuimage.filter;
 
 public class GPUImageNonMaximumSuppressionFilter extends GPUImage3x3TextureSamplingFilter {
     public static final String NMS_FRAGMENT_SHADER = "" +
diff --git a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageNormalBlendFilter.java b/library/src/main/java/jp/co/cyberagent/android/gpuimage/filter/GPUImageNormalBlendFilter.java
similarity index 95%
rename from library/src/jp/co/cyberagent/android/gpuimage/GPUImageNormalBlendFilter.java
rename to library/src/main/java/jp/co/cyberagent/android/gpuimage/filter/GPUImageNormalBlendFilter.java
index a886bd40..ced5d1a0 100644
--- a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageNormalBlendFilter.java
+++ b/library/src/main/java/jp/co/cyberagent/android/gpuimage/filter/GPUImageNormalBlendFilter.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2012 CyberAgent
+ * Copyright (C) 2018 CyberAgent, Inc.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -14,19 +14,19 @@
  * limitations under the License.
  */
 
-package jp.co.cyberagent.android.gpuimage;
+package jp.co.cyberagent.android.gpuimage.filter;
 
 /**
  * This equation is a simplification of the general blending equation. It assumes the destination color is opaque, and therefore drops the destination color's alpha term.
- *
+ * <p>
  * D = C1 * C1a + C2 * C2a * (1 - C1a)
  * where D is the resultant color, C1 is the color of the first element, C1a is the alpha of the first element, C2 is the second element color, C2a is the alpha of the second element. The destination alpha is calculated with:
- *
+ * <p>
  * Da = C1a + C2a * (1 - C1a)
  * The resultant color is premultiplied with the alpha. To restore the color to the unmultiplied values, just divide by Da, the resultant alpha.
- *
+ * <p>
  * http://stackoverflow.com/questions/1724946/blend-mode-on-a-transparent-and-semi-transparent-background
- *
+ * <p>
  * For some reason Photoshop behaves
  * D = C1 + C2 * C2a * (1 - C1a)
  */
diff --git a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageOpacityFilter.java b/library/src/main/java/jp/co/cyberagent/android/gpuimage/filter/GPUImageOpacityFilter.java
similarity index 82%
rename from library/src/jp/co/cyberagent/android/gpuimage/GPUImageOpacityFilter.java
rename to library/src/main/java/jp/co/cyberagent/android/gpuimage/filter/GPUImageOpacityFilter.java
index 55f198d1..4eb1cf79 100644
--- a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageOpacityFilter.java
+++ b/library/src/main/java/jp/co/cyberagent/android/gpuimage/filter/GPUImageOpacityFilter.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2012 CyberAgent
+ * Copyright (C) 2018 CyberAgent, Inc.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -14,14 +14,14 @@
  * limitations under the License.
  */
 
-package jp.co.cyberagent.android.gpuimage;
+package jp.co.cyberagent.android.gpuimage.filter;
 
 import android.opengl.GLES20;
 
 /**
  * Adjusts the alpha channel of the incoming image
  * opacity: The value to multiply the incoming alpha channel for each pixel by (0.0 - 1.0, with 1.0 as the default)
-*/
+ */
 public class GPUImageOpacityFilter extends GPUImageFilter {
     public static final String OPACITY_FRAGMENT_SHADER = "" +
             "  varying highp vec2 textureCoordinate;\n" +
@@ -36,8 +36,8 @@
             "      gl_FragColor = vec4(textureColor.rgb, textureColor.a * opacity);\n" +
             "  }\n";
 
-    private int mOpacityLocation;
-    private float mOpacity;
+    private int opacityLocation;
+    private float opacity;
 
     public GPUImageOpacityFilter() {
         this(1.0f);
@@ -45,23 +45,23 @@ public GPUImageOpacityFilter() {
 
     public GPUImageOpacityFilter(final float opacity) {
         super(NO_FILTER_VERTEX_SHADER, OPACITY_FRAGMENT_SHADER);
-        mOpacity = opacity;
+        this.opacity = opacity;
     }
 
     @Override
     public void onInit() {
         super.onInit();
-        mOpacityLocation = GLES20.glGetUniformLocation(getProgram(), "opacity");
+        opacityLocation = GLES20.glGetUniformLocation(getProgram(), "opacity");
     }
 
     @Override
     public void onInitialized() {
         super.onInitialized();
-        setOpacity(mOpacity);
+        setOpacity(opacity);
     }
 
     public void setOpacity(final float opacity) {
-        mOpacity = opacity;
-        setFloat(mOpacityLocation, mOpacity);
+        this.opacity = opacity;
+        setFloat(opacityLocation, this.opacity);
     }
 }
diff --git a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageOverlayBlendFilter.java b/library/src/main/java/jp/co/cyberagent/android/gpuimage/filter/GPUImageOverlayBlendFilter.java
similarity index 96%
rename from library/src/jp/co/cyberagent/android/gpuimage/GPUImageOverlayBlendFilter.java
rename to library/src/main/java/jp/co/cyberagent/android/gpuimage/filter/GPUImageOverlayBlendFilter.java
index 4dba4200..3d36b187 100644
--- a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageOverlayBlendFilter.java
+++ b/library/src/main/java/jp/co/cyberagent/android/gpuimage/filter/GPUImageOverlayBlendFilter.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2012 CyberAgent
+ * Copyright (C) 2018 CyberAgent, Inc.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -14,7 +14,7 @@
  * limitations under the License.
  */
 
-package jp.co.cyberagent.android.gpuimage;
+package jp.co.cyberagent.android.gpuimage.filter;
 
 public class GPUImageOverlayBlendFilter extends GPUImageTwoInputFilter {
     public static final String OVERLAY_BLEND_FRAGMENT_SHADER = "varying highp vec2 textureCoordinate;\n" +
diff --git a/library/src/jp/co/cyberagent/android/gpuimage/GPUImagePixelationFilter.java b/library/src/main/java/jp/co/cyberagent/android/gpuimage/filter/GPUImagePixelationFilter.java
similarity index 69%
rename from library/src/jp/co/cyberagent/android/gpuimage/GPUImagePixelationFilter.java
rename to library/src/main/java/jp/co/cyberagent/android/gpuimage/filter/GPUImagePixelationFilter.java
index c0ec15d1..0e061bfd 100644
--- a/library/src/jp/co/cyberagent/android/gpuimage/GPUImagePixelationFilter.java
+++ b/library/src/main/java/jp/co/cyberagent/android/gpuimage/filter/GPUImagePixelationFilter.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2012 CyberAgent
+ * Copyright (C) 2018 CyberAgent, Inc.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -14,9 +14,10 @@
  * limitations under the License.
  */
 
-package jp.co.cyberagent.android.gpuimage;
+package jp.co.cyberagent.android.gpuimage.filter;
 
 import android.opengl.GLES20;
+
 /**
  * Applies a grayscale effect to the image.
  */
@@ -41,34 +42,39 @@
             "  gl_FragColor = vec4(tc, 1.0);\n" +
             "}";
 
-    private int mImageWidthFactorLocation;
-    private int mImageHeightFactorLocation;
-    private float mPixel;
-    private int mPixelLocation;
-    
+    private int imageWidthFactorLocation;
+    private int imageHeightFactorLocation;
+    private float pixel;
+    private int pixelLocation;
+
     public GPUImagePixelationFilter() {
         super(NO_FILTER_VERTEX_SHADER, PIXELATION_FRAGMENT_SHADER);
-        mPixel = 1.0f;
+        pixel = 1.0f;
     }
 
     @Override
     public void onInit() {
         super.onInit();
-        mImageWidthFactorLocation = GLES20.glGetUniformLocation(getProgram(), "imageWidthFactor");
-        mImageHeightFactorLocation = GLES20.glGetUniformLocation(getProgram(), "imageHeightFactor");
-        mPixelLocation = GLES20.glGetUniformLocation(getProgram(), "pixel");
-        setPixel(mPixel);
+        imageWidthFactorLocation = GLES20.glGetUniformLocation(getProgram(), "imageWidthFactor");
+        imageHeightFactorLocation = GLES20.glGetUniformLocation(getProgram(), "imageHeightFactor");
+        pixelLocation = GLES20.glGetUniformLocation(getProgram(), "pixel");
+    }
+
+    @Override
+    public void onInitialized() {
+        super.onInitialized();
+        setPixel(pixel);
     }
 
     @Override
     public void onOutputSizeChanged(final int width, final int height) {
         super.onOutputSizeChanged(width, height);
-        setFloat(mImageWidthFactorLocation, 1.0f / width);
-        setFloat(mImageHeightFactorLocation, 1.0f / height);
+        setFloat(imageWidthFactorLocation, 1.0f / width);
+        setFloat(imageHeightFactorLocation, 1.0f / height);
     }
 
     public void setPixel(final float pixel) {
-      mPixel = pixel;
-      setFloat(mPixelLocation, mPixel);
+        this.pixel = pixel;
+        setFloat(pixelLocation, this.pixel);
     }
 }
diff --git a/library/src/jp/co/cyberagent/android/gpuimage/GPUImagePosterizeFilter.java b/library/src/main/java/jp/co/cyberagent/android/gpuimage/filter/GPUImagePosterizeFilter.java
similarity index 76%
rename from library/src/jp/co/cyberagent/android/gpuimage/GPUImagePosterizeFilter.java
rename to library/src/main/java/jp/co/cyberagent/android/gpuimage/filter/GPUImagePosterizeFilter.java
index 3b7c8ff7..885b4e7d 100644
--- a/library/src/jp/co/cyberagent/android/gpuimage/GPUImagePosterizeFilter.java
+++ b/library/src/main/java/jp/co/cyberagent/android/gpuimage/filter/GPUImagePosterizeFilter.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2012 CyberAgent
+ * Copyright (C) 2018 CyberAgent, Inc.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -14,7 +14,7 @@
  * limitations under the License.
  */
 
-package jp.co.cyberagent.android.gpuimage;
+package jp.co.cyberagent.android.gpuimage.filter;
 
 import android.opengl.GLES20;
 
@@ -37,8 +37,8 @@
             "   gl_FragColor = floor((textureColor * colorLevels) + vec4(0.5)) / colorLevels;\n" +
             "}";
 
-    private int mGLUniformColorLevels;
-    private int mColorLevels;
+    private int glUniformColorLevels;
+    private int colorLevels;
 
     public GPUImagePosterizeFilter() {
         this(10);
@@ -46,18 +46,23 @@ public GPUImagePosterizeFilter() {
 
     public GPUImagePosterizeFilter(final int colorLevels) {
         super(GPUImageFilter.NO_FILTER_VERTEX_SHADER, POSTERIZE_FRAGMENT_SHADER);
-        mColorLevels = colorLevels;
+        this.colorLevels = colorLevels;
     }
 
     @Override
     public void onInit() {
         super.onInit();
-        mGLUniformColorLevels = GLES20.glGetUniformLocation(getProgram(), "colorLevels");
-        setColorLevels(mColorLevels);
+        glUniformColorLevels = GLES20.glGetUniformLocation(getProgram(), "colorLevels");
+    }
+
+    @Override
+    public void onInitialized() {
+        super.onInitialized();
+        setColorLevels(colorLevels);
     }
 
     public void setColorLevels(final int colorLevels) {
-        mColorLevels = colorLevels;
-        setFloat(mGLUniformColorLevels, colorLevels);
+        this.colorLevels = colorLevels;
+        setFloat(glUniformColorLevels, colorLevels);
     }
 }
diff --git a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageRGBDilationFilter.java b/library/src/main/java/jp/co/cyberagent/android/gpuimage/filter/GPUImageRGBDilationFilter.java
similarity index 99%
rename from library/src/jp/co/cyberagent/android/gpuimage/GPUImageRGBDilationFilter.java
rename to library/src/main/java/jp/co/cyberagent/android/gpuimage/filter/GPUImageRGBDilationFilter.java
index 2d5e28c7..cb777767 100644
--- a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageRGBDilationFilter.java
+++ b/library/src/main/java/jp/co/cyberagent/android/gpuimage/filter/GPUImageRGBDilationFilter.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2012 CyberAgent
+ * Copyright (C) 2018 CyberAgent, Inc.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -14,7 +14,7 @@
  * limitations under the License.
  */
 
-package jp.co.cyberagent.android.gpuimage;
+package jp.co.cyberagent.android.gpuimage.filter;
 
 /**
  * For each pixel, this sets it to the maximum value of each color channel in a rectangular neighborhood extending
diff --git a/library/src/main/java/jp/co/cyberagent/android/gpuimage/filter/GPUImageRGBFilter.java b/library/src/main/java/jp/co/cyberagent/android/gpuimage/filter/GPUImageRGBFilter.java
new file mode 100644
index 00000000..25889f37
--- /dev/null
+++ b/library/src/main/java/jp/co/cyberagent/android/gpuimage/filter/GPUImageRGBFilter.java
@@ -0,0 +1,91 @@
+/*
+ * Copyright (C) 2018 CyberAgent, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package jp.co.cyberagent.android.gpuimage.filter;
+
+import android.opengl.GLES20;
+
+/**
+ * Adjusts the individual RGB channels of an image
+ * red: Normalized values by which each color channel is multiplied. The range is from 0.0 up, with 1.0 as the default.
+ * green:
+ * blue:
+ */
+public class GPUImageRGBFilter extends GPUImageFilter {
+    public static final String RGB_FRAGMENT_SHADER = "" +
+            "  varying highp vec2 textureCoordinate;\n" +
+            "  \n" +
+            "  uniform sampler2D inputImageTexture;\n" +
+            "  uniform highp float red;\n" +
+            "  uniform highp float green;\n" +
+            "  uniform highp float blue;\n" +
+            "  \n" +
+            "  void main()\n" +
+            "  {\n" +
+            "      highp vec4 textureColor = texture2D(inputImageTexture, textureCoordinate);\n" +
+            "      \n" +
+            "      gl_FragColor = vec4(textureColor.r * red, textureColor.g * green, textureColor.b * blue, 1.0);\n" +
+            "  }\n";
+
+    private int redLocation;
+    private float red;
+    private int greenLocation;
+    private float green;
+    private int blueLocation;
+    private float blue;
+
+    public GPUImageRGBFilter() {
+        this(1.0f, 1.0f, 1.0f);
+    }
+
+    public GPUImageRGBFilter(final float red, final float green, final float blue) {
+        super(NO_FILTER_VERTEX_SHADER, RGB_FRAGMENT_SHADER);
+        this.red = red;
+        this.green = green;
+        this.blue = blue;
+    }
+
+    @Override
+    public void onInit() {
+        super.onInit();
+        redLocation = GLES20.glGetUniformLocation(getProgram(), "red");
+        greenLocation = GLES20.glGetUniformLocation(getProgram(), "green");
+        blueLocation = GLES20.glGetUniformLocation(getProgram(), "blue");
+    }
+
+    @Override
+    public void onInitialized() {
+        super.onInitialized();
+        setRed(red);
+        setGreen(green);
+        setBlue(blue);
+    }
+
+    public void setRed(final float red) {
+        this.red = red;
+        setFloat(redLocation, this.red);
+    }
+
+    public void setGreen(final float green) {
+        this.green = green;
+        setFloat(greenLocation, this.green);
+    }
+
+    public void setBlue(final float blue) {
+        this.blue = blue;
+        setFloat(blueLocation, this.blue);
+    }
+}
diff --git a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageSaturationBlendFilter.java b/library/src/main/java/jp/co/cyberagent/android/gpuimage/filter/GPUImageSaturationBlendFilter.java
similarity index 98%
rename from library/src/jp/co/cyberagent/android/gpuimage/GPUImageSaturationBlendFilter.java
rename to library/src/main/java/jp/co/cyberagent/android/gpuimage/filter/GPUImageSaturationBlendFilter.java
index 1c0f90d6..eacb809e 100644
--- a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageSaturationBlendFilter.java
+++ b/library/src/main/java/jp/co/cyberagent/android/gpuimage/filter/GPUImageSaturationBlendFilter.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2012 CyberAgent
+ * Copyright (C) 2018 CyberAgent, Inc.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -14,7 +14,7 @@
  * limitations under the License.
  */
 
-package jp.co.cyberagent.android.gpuimage;
+package jp.co.cyberagent.android.gpuimage.filter;
 
 public class GPUImageSaturationBlendFilter extends GPUImageTwoInputFilter {
     public static final String SATURATION_BLEND_FRAGMENT_SHADER = "varying highp vec2 textureCoordinate;\n" +
diff --git a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageSaturationFilter.java b/library/src/main/java/jp/co/cyberagent/android/gpuimage/filter/GPUImageSaturationFilter.java
similarity index 84%
rename from library/src/jp/co/cyberagent/android/gpuimage/GPUImageSaturationFilter.java
rename to library/src/main/java/jp/co/cyberagent/android/gpuimage/filter/GPUImageSaturationFilter.java
index 0725953d..dd1f59ce 100644
--- a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageSaturationFilter.java
+++ b/library/src/main/java/jp/co/cyberagent/android/gpuimage/filter/GPUImageSaturationFilter.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2012 CyberAgent
+ * Copyright (C) 2018 CyberAgent, Inc.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -14,7 +14,7 @@
  * limitations under the License.
  */
 
-package jp.co.cyberagent.android.gpuimage;
+package jp.co.cyberagent.android.gpuimage.filter;
 
 import android.opengl.GLES20;
 
@@ -41,8 +41,8 @@
             "     \n" +
             " }";
 
-    private int mSaturationLocation;
-    private float mSaturation;
+    private int saturationLocation;
+    private float saturation;
 
     public GPUImageSaturationFilter() {
         this(1.0f);
@@ -50,23 +50,23 @@ public GPUImageSaturationFilter() {
 
     public GPUImageSaturationFilter(final float saturation) {
         super(NO_FILTER_VERTEX_SHADER, SATURATION_FRAGMENT_SHADER);
-        mSaturation = saturation;
+        this.saturation = saturation;
     }
 
     @Override
     public void onInit() {
         super.onInit();
-        mSaturationLocation = GLES20.glGetUniformLocation(getProgram(), "saturation");
+        saturationLocation = GLES20.glGetUniformLocation(getProgram(), "saturation");
     }
 
     @Override
     public void onInitialized() {
         super.onInitialized();
-        setSaturation(mSaturation);
+        setSaturation(saturation);
     }
 
     public void setSaturation(final float saturation) {
-        mSaturation = saturation;
-        setFloat(mSaturationLocation, mSaturation);
+        this.saturation = saturation;
+        setFloat(saturationLocation, this.saturation);
     }
 }
diff --git a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageScreenBlendFilter.java b/library/src/main/java/jp/co/cyberagent/android/gpuimage/filter/GPUImageScreenBlendFilter.java
similarity index 94%
rename from library/src/jp/co/cyberagent/android/gpuimage/GPUImageScreenBlendFilter.java
rename to library/src/main/java/jp/co/cyberagent/android/gpuimage/filter/GPUImageScreenBlendFilter.java
index 2c63a699..56ba3db1 100644
--- a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageScreenBlendFilter.java
+++ b/library/src/main/java/jp/co/cyberagent/android/gpuimage/filter/GPUImageScreenBlendFilter.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2012 CyberAgent
+ * Copyright (C) 2018 CyberAgent, Inc.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -14,7 +14,7 @@
  * limitations under the License.
  */
 
-package jp.co.cyberagent.android.gpuimage;
+package jp.co.cyberagent.android.gpuimage.filter;
 
 public class GPUImageScreenBlendFilter extends GPUImageTwoInputFilter {
     public static final String SCREEN_BLEND_FRAGMENT_SHADER = "varying highp vec2 textureCoordinate;\n" +
diff --git a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageSepiaFilter.java b/library/src/main/java/jp/co/cyberagent/android/gpuimage/filter/GPUImageSepiaToneFilter.java
similarity index 73%
rename from library/src/jp/co/cyberagent/android/gpuimage/GPUImageSepiaFilter.java
rename to library/src/main/java/jp/co/cyberagent/android/gpuimage/filter/GPUImageSepiaToneFilter.java
index cbcf3534..cbad3d2e 100644
--- a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageSepiaFilter.java
+++ b/library/src/main/java/jp/co/cyberagent/android/gpuimage/filter/GPUImageSepiaToneFilter.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2012 CyberAgent
+ * Copyright (C) 2018 CyberAgent, Inc.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -14,19 +14,19 @@
  * limitations under the License.
  */
 
-package jp.co.cyberagent.android.gpuimage;
+package jp.co.cyberagent.android.gpuimage.filter;
 
 /**
  * Applies a simple sepia effect.
  */
-public class GPUImageSepiaFilter extends GPUImageColorMatrixFilter {
+public class GPUImageSepiaToneFilter extends GPUImageColorMatrixFilter {
 
-    public GPUImageSepiaFilter() {
+    public GPUImageSepiaToneFilter() {
         this(1.0f);
     }
 
-    public GPUImageSepiaFilter(final float intensity) {
-        super(intensity, new float[] {
+    public GPUImageSepiaToneFilter(final float intensity) {
+        super(intensity, new float[]{
                 0.3588f, 0.7044f, 0.1368f, 0.0f,
                 0.2990f, 0.5870f, 0.1140f, 0.0f,
                 0.2392f, 0.4696f, 0.0912f, 0.0f,
diff --git a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageSharpenFilter.java b/library/src/main/java/jp/co/cyberagent/android/gpuimage/filter/GPUImageSharpenFilter.java
similarity index 66%
rename from library/src/jp/co/cyberagent/android/gpuimage/GPUImageSharpenFilter.java
rename to library/src/main/java/jp/co/cyberagent/android/gpuimage/filter/GPUImageSharpenFilter.java
index 4317b66c..c0cf6820 100644
--- a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageSharpenFilter.java
+++ b/library/src/main/java/jp/co/cyberagent/android/gpuimage/filter/GPUImageSharpenFilter.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2012 CyberAgent
+ * Copyright (C) 2018 CyberAgent, Inc.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -14,7 +14,7 @@
  * limitations under the License.
  */
 
-package jp.co.cyberagent.android.gpuimage;
+package jp.co.cyberagent.android.gpuimage.filter;
 
 import android.opengl.GLES20;
 
@@ -59,62 +59,67 @@
             "}";
 
     public static final String SHARPEN_FRAGMENT_SHADER = "" +
-            "precision highp float;\n" + 
-            "\n" + 
-            "varying highp vec2 textureCoordinate;\n" + 
-            "varying highp vec2 leftTextureCoordinate;\n" + 
-            "varying highp vec2 rightTextureCoordinate; \n" + 
-            "varying highp vec2 topTextureCoordinate;\n" + 
-            "varying highp vec2 bottomTextureCoordinate;\n" + 
-            "\n" + 
-            "varying highp float centerMultiplier;\n" + 
-            "varying highp float edgeMultiplier;\n" + 
-            "\n" + 
-            "uniform sampler2D inputImageTexture;\n" + 
-            "\n" + 
-            "void main()\n" + 
-            "{\n" + 
-            "    mediump vec3 textureColor = texture2D(inputImageTexture, textureCoordinate).rgb;\n" + 
-            "    mediump vec3 leftTextureColor = texture2D(inputImageTexture, leftTextureCoordinate).rgb;\n" + 
-            "    mediump vec3 rightTextureColor = texture2D(inputImageTexture, rightTextureCoordinate).rgb;\n" + 
-            "    mediump vec3 topTextureColor = texture2D(inputImageTexture, topTextureCoordinate).rgb;\n" + 
-            "    mediump vec3 bottomTextureColor = texture2D(inputImageTexture, bottomTextureCoordinate).rgb;\n" + 
-            "\n" + 
-            "    gl_FragColor = vec4((textureColor * centerMultiplier - (leftTextureColor * edgeMultiplier + rightTextureColor * edgeMultiplier + topTextureColor * edgeMultiplier + bottomTextureColor * edgeMultiplier)), texture2D(inputImageTexture, bottomTextureCoordinate).w);\n" + 
+            "precision highp float;\n" +
+            "\n" +
+            "varying highp vec2 textureCoordinate;\n" +
+            "varying highp vec2 leftTextureCoordinate;\n" +
+            "varying highp vec2 rightTextureCoordinate; \n" +
+            "varying highp vec2 topTextureCoordinate;\n" +
+            "varying highp vec2 bottomTextureCoordinate;\n" +
+            "\n" +
+            "varying highp float centerMultiplier;\n" +
+            "varying highp float edgeMultiplier;\n" +
+            "\n" +
+            "uniform sampler2D inputImageTexture;\n" +
+            "\n" +
+            "void main()\n" +
+            "{\n" +
+            "    mediump vec3 textureColor = texture2D(inputImageTexture, textureCoordinate).rgb;\n" +
+            "    mediump vec3 leftTextureColor = texture2D(inputImageTexture, leftTextureCoordinate).rgb;\n" +
+            "    mediump vec3 rightTextureColor = texture2D(inputImageTexture, rightTextureCoordinate).rgb;\n" +
+            "    mediump vec3 topTextureColor = texture2D(inputImageTexture, topTextureCoordinate).rgb;\n" +
+            "    mediump vec3 bottomTextureColor = texture2D(inputImageTexture, bottomTextureCoordinate).rgb;\n" +
+            "\n" +
+            "    gl_FragColor = vec4((textureColor * centerMultiplier - (leftTextureColor * edgeMultiplier + rightTextureColor * edgeMultiplier + topTextureColor * edgeMultiplier + bottomTextureColor * edgeMultiplier)), texture2D(inputImageTexture, bottomTextureCoordinate).w);\n" +
             "}";
 
-    private int mSharpnessLocation;
-    private float mSharpness;
-    private int mImageWidthFactorLocation;
-    private int mImageHeightFactorLocation;
+    private int sharpnessLocation;
+    private float sharpness;
+    private int imageWidthFactorLocation;
+    private int imageHeightFactorLocation;
 
     public GPUImageSharpenFilter() {
         this(0.0f);
     }
-    
+
     public GPUImageSharpenFilter(final float sharpness) {
         super(SHARPEN_VERTEX_SHADER, SHARPEN_FRAGMENT_SHADER);
-        mSharpness = sharpness;
+        this.sharpness = sharpness;
     }
 
     @Override
     public void onInit() {
         super.onInit();
-        mSharpnessLocation = GLES20.glGetUniformLocation(getProgram(), "sharpness");
-        mImageWidthFactorLocation = GLES20.glGetUniformLocation(getProgram(), "imageWidthFactor");
-        mImageHeightFactorLocation = GLES20.glGetUniformLocation(getProgram(), "imageHeightFactor");
-        setSharpness(mSharpness);
+        sharpnessLocation = GLES20.glGetUniformLocation(getProgram(), "sharpness");
+        imageWidthFactorLocation = GLES20.glGetUniformLocation(getProgram(), "imageWidthFactor");
+        imageHeightFactorLocation = GLES20.glGetUniformLocation(getProgram(), "imageHeightFactor");
+    }
+
+    @Override
+    public void onInitialized() {
+        super.onInitialized();
+        setSharpness(sharpness);
     }
 
     @Override
     public void onOutputSizeChanged(final int width, final int height) {
         super.onOutputSizeChanged(width, height);
-        setFloat(mImageWidthFactorLocation, 1.0f / width);
-        setFloat(mImageHeightFactorLocation, 1.0f / height);
+        setFloat(imageWidthFactorLocation, 1.0f / width);
+        setFloat(imageHeightFactorLocation, 1.0f / height);
     }
 
     public void setSharpness(final float sharpness) {
-        mSharpness = sharpness;
-        setFloat(mSharpnessLocation, mSharpness);
+        this.sharpness = sharpness;
+        setFloat(sharpnessLocation, this.sharpness);
     }
 }
diff --git a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageSketchFilter.java b/library/src/main/java/jp/co/cyberagent/android/gpuimage/filter/GPUImageSketchFilter.java
similarity index 95%
rename from library/src/jp/co/cyberagent/android/gpuimage/GPUImageSketchFilter.java
rename to library/src/main/java/jp/co/cyberagent/android/gpuimage/filter/GPUImageSketchFilter.java
index dd78e708..905d20d9 100644
--- a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageSketchFilter.java
+++ b/library/src/main/java/jp/co/cyberagent/android/gpuimage/filter/GPUImageSketchFilter.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2012 CyberAgent
+ * Copyright (C) 2018 CyberAgent, Inc.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -14,10 +14,7 @@
  * limitations under the License.
  */
 
-package jp.co.cyberagent.android.gpuimage;
-
-import java.util.ArrayList;
-import java.util.List;
+package jp.co.cyberagent.android.gpuimage.filter;
 
 /**
  * Converts video to look like a sketch.
diff --git a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageSmoothToonFilter.java b/library/src/main/java/jp/co/cyberagent/android/gpuimage/filter/GPUImageSmoothToonFilter.java
similarity index 80%
rename from library/src/jp/co/cyberagent/android/gpuimage/GPUImageSmoothToonFilter.java
rename to library/src/main/java/jp/co/cyberagent/android/gpuimage/filter/GPUImageSmoothToonFilter.java
index a569ce97..079034d4 100644
--- a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageSmoothToonFilter.java
+++ b/library/src/main/java/jp/co/cyberagent/android/gpuimage/filter/GPUImageSmoothToonFilter.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2012 CyberAgent
+ * Copyright (C) 2018 CyberAgent, Inc.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -14,17 +14,16 @@
  * limitations under the License.
  */
 
-package jp.co.cyberagent.android.gpuimage;
-
-import android.opengl.GLES20;
+package jp.co.cyberagent.android.gpuimage.filter;
 
 /**
- *  This uses a similar process as the GPUImageToonFilter, only it precedes the toon effect
- *  with a Gaussian blur to smooth out noise.
+ * This uses a similar process as the GPUImageToonFilter, only it precedes the toon effect
+ * with a Gaussian blur to smooth out noise.
  */
 public class GPUImageSmoothToonFilter extends GPUImageFilterGroup {
-    GPUImageGaussianBlurFilter blurFilter;
-    GPUImageToonFilter toonFilter;
+
+    private GPUImageGaussianBlurFilter blurFilter;
+    private GPUImageToonFilter toonFilter;
 
     /**
      * Setup and Tear down
@@ -39,7 +38,11 @@ public GPUImageSmoothToonFilter() {
         addFilter(toonFilter);
 
         getFilters().add(blurFilter);
+    }
 
+    @Override
+    public void onInitialized() {
+        super.onInitialized();
         setBlurSize(0.5f);
         setThreshold(0.2f);
         setQuantizationLevels(10.0f);
diff --git a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageSobelEdgeDetection.java b/library/src/main/java/jp/co/cyberagent/android/gpuimage/filter/GPUImageSobelEdgeDetectionFilter.java
similarity index 52%
rename from library/src/jp/co/cyberagent/android/gpuimage/GPUImageSobelEdgeDetection.java
rename to library/src/main/java/jp/co/cyberagent/android/gpuimage/filter/GPUImageSobelEdgeDetectionFilter.java
index 2a775d48..b7482486 100644
--- a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageSobelEdgeDetection.java
+++ b/library/src/main/java/jp/co/cyberagent/android/gpuimage/filter/GPUImageSobelEdgeDetectionFilter.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2012 CyberAgent
+ * Copyright (C) 2018 CyberAgent, Inc.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -14,51 +14,48 @@
  * limitations under the License.
  */
 
-package jp.co.cyberagent.android.gpuimage;
-
-import java.util.ArrayList;
-import java.util.List;
+package jp.co.cyberagent.android.gpuimage.filter;
 
 /**
  * Applies sobel edge detection on the image.
  */
-public class GPUImageSobelEdgeDetection extends GPUImageFilterGroup {
+public class GPUImageSobelEdgeDetectionFilter extends GPUImageFilterGroup {
     public static final String SOBEL_EDGE_DETECTION = "" +
-            "precision mediump float;\n" + 
-            "\n" + 
-            "varying vec2 textureCoordinate;\n" + 
-            "varying vec2 leftTextureCoordinate;\n" + 
-            "varying vec2 rightTextureCoordinate;\n" + 
-            "\n" + 
-            "varying vec2 topTextureCoordinate;\n" + 
-            "varying vec2 topLeftTextureCoordinate;\n" + 
-            "varying vec2 topRightTextureCoordinate;\n" + 
-            "\n" + 
-            "varying vec2 bottomTextureCoordinate;\n" + 
-            "varying vec2 bottomLeftTextureCoordinate;\n" + 
-            "varying vec2 bottomRightTextureCoordinate;\n" + 
-            "\n" + 
-            "uniform sampler2D inputImageTexture;\n" + 
-            "\n" + 
-            "void main()\n" + 
-            "{\n" + 
-            "    float bottomLeftIntensity = texture2D(inputImageTexture, bottomLeftTextureCoordinate).r;\n" + 
-            "    float topRightIntensity = texture2D(inputImageTexture, topRightTextureCoordinate).r;\n" + 
-            "    float topLeftIntensity = texture2D(inputImageTexture, topLeftTextureCoordinate).r;\n" + 
-            "    float bottomRightIntensity = texture2D(inputImageTexture, bottomRightTextureCoordinate).r;\n" + 
-            "    float leftIntensity = texture2D(inputImageTexture, leftTextureCoordinate).r;\n" + 
-            "    float rightIntensity = texture2D(inputImageTexture, rightTextureCoordinate).r;\n" + 
-            "    float bottomIntensity = texture2D(inputImageTexture, bottomTextureCoordinate).r;\n" + 
-            "    float topIntensity = texture2D(inputImageTexture, topTextureCoordinate).r;\n" + 
-            "    float h = -topLeftIntensity - 2.0 * topIntensity - topRightIntensity + bottomLeftIntensity + 2.0 * bottomIntensity + bottomRightIntensity;\n" + 
-            "    float v = -bottomLeftIntensity - 2.0 * leftIntensity - topLeftIntensity + bottomRightIntensity + 2.0 * rightIntensity + topRightIntensity;\n" + 
-            "\n" + 
-            "    float mag = length(vec2(h, v));\n" + 
-            "\n" + 
-            "    gl_FragColor = vec4(vec3(mag), 1.0);\n" + 
+            "precision mediump float;\n" +
+            "\n" +
+            "varying vec2 textureCoordinate;\n" +
+            "varying vec2 leftTextureCoordinate;\n" +
+            "varying vec2 rightTextureCoordinate;\n" +
+            "\n" +
+            "varying vec2 topTextureCoordinate;\n" +
+            "varying vec2 topLeftTextureCoordinate;\n" +
+            "varying vec2 topRightTextureCoordinate;\n" +
+            "\n" +
+            "varying vec2 bottomTextureCoordinate;\n" +
+            "varying vec2 bottomLeftTextureCoordinate;\n" +
+            "varying vec2 bottomRightTextureCoordinate;\n" +
+            "\n" +
+            "uniform sampler2D inputImageTexture;\n" +
+            "\n" +
+            "void main()\n" +
+            "{\n" +
+            "    float bottomLeftIntensity = texture2D(inputImageTexture, bottomLeftTextureCoordinate).r;\n" +
+            "    float topRightIntensity = texture2D(inputImageTexture, topRightTextureCoordinate).r;\n" +
+            "    float topLeftIntensity = texture2D(inputImageTexture, topLeftTextureCoordinate).r;\n" +
+            "    float bottomRightIntensity = texture2D(inputImageTexture, bottomRightTextureCoordinate).r;\n" +
+            "    float leftIntensity = texture2D(inputImageTexture, leftTextureCoordinate).r;\n" +
+            "    float rightIntensity = texture2D(inputImageTexture, rightTextureCoordinate).r;\n" +
+            "    float bottomIntensity = texture2D(inputImageTexture, bottomTextureCoordinate).r;\n" +
+            "    float topIntensity = texture2D(inputImageTexture, topTextureCoordinate).r;\n" +
+            "    float h = -topLeftIntensity - 2.0 * topIntensity - topRightIntensity + bottomLeftIntensity + 2.0 * bottomIntensity + bottomRightIntensity;\n" +
+            "    float v = -bottomLeftIntensity - 2.0 * leftIntensity - topLeftIntensity + bottomRightIntensity + 2.0 * rightIntensity + topRightIntensity;\n" +
+            "\n" +
+            "    float mag = length(vec2(h, v));\n" +
+            "\n" +
+            "    gl_FragColor = vec4(vec3(mag), 1.0);\n" +
             "}";
 
-    public GPUImageSobelEdgeDetection() {
+    public GPUImageSobelEdgeDetectionFilter() {
         super();
         addFilter(new GPUImageGrayscaleFilter());
         addFilter(new GPUImage3x3TextureSamplingFilter(SOBEL_EDGE_DETECTION));
diff --git a/library/src/main/java/jp/co/cyberagent/android/gpuimage/filter/GPUImageSobelThresholdFilter.java b/library/src/main/java/jp/co/cyberagent/android/gpuimage/filter/GPUImageSobelThresholdFilter.java
new file mode 100644
index 00000000..beff588c
--- /dev/null
+++ b/library/src/main/java/jp/co/cyberagent/android/gpuimage/filter/GPUImageSobelThresholdFilter.java
@@ -0,0 +1,74 @@
+package jp.co.cyberagent.android.gpuimage.filter;
+
+import android.opengl.GLES20;
+
+public class GPUImageSobelThresholdFilter extends
+        GPUImage3x3TextureSamplingFilter {
+    public static final String SOBEL_THRESHOLD_EDGE_DETECTION = "" +
+            "precision mediump float;\n" +
+            "\n" +
+            "varying vec2 textureCoordinate;\n" +
+            "varying vec2 leftTextureCoordinate;\n" +
+            "varying vec2 rightTextureCoordinate;\n" +
+            "\n" +
+            "varying vec2 topTextureCoordinate;\n" +
+            "varying vec2 topLeftTextureCoordinate;\n" +
+            "varying vec2 topRightTextureCoordinate;\n" +
+            "\n" +
+            "varying vec2 bottomTextureCoordinate;\n" +
+            "varying vec2 bottomLeftTextureCoordinate;\n" +
+            "varying vec2 bottomRightTextureCoordinate;\n" +
+            "\n" +
+            "uniform sampler2D inputImageTexture;\n" +
+            "uniform lowp float threshold;\n" +
+            "\n" +
+            "const highp vec3 W = vec3(0.2125, 0.7154, 0.0721);\n" +
+            "\n" +
+            "void main()\n" +
+            "{\n" +
+            "    float bottomLeftIntensity = texture2D(inputImageTexture, bottomLeftTextureCoordinate).r;\n" +
+            "    float topRightIntensity = texture2D(inputImageTexture, topRightTextureCoordinate).r;\n" +
+            "    float topLeftIntensity = texture2D(inputImageTexture, topLeftTextureCoordinate).r;\n" +
+            "    float bottomRightIntensity = texture2D(inputImageTexture, bottomRightTextureCoordinate).r;\n" +
+            "    float leftIntensity = texture2D(inputImageTexture, leftTextureCoordinate).r;\n" +
+            "    float rightIntensity = texture2D(inputImageTexture, rightTextureCoordinate).r;\n" +
+            "    float bottomIntensity = texture2D(inputImageTexture, bottomTextureCoordinate).r;\n" +
+            "    float topIntensity = texture2D(inputImageTexture, topTextureCoordinate).r;\n" +
+            "    float h = -topLeftIntensity - 2.0 * topIntensity - topRightIntensity + bottomLeftIntensity + 2.0 * bottomIntensity + bottomRightIntensity;\n" +
+            "    float v = -bottomLeftIntensity - 2.0 * leftIntensity - topLeftIntensity + bottomRightIntensity + 2.0 * rightIntensity + topRightIntensity;\n" +
+            "\n" +
+            "    float mag = 1.0 - length(vec2(h, v));\n" +
+            "    mag = step(threshold, mag);\n" +
+            "\n" +
+            "    gl_FragColor = vec4(vec3(mag), 1.0);\n" +
+            "}\n";
+
+    private int uniformThresholdLocation;
+    private float threshold;
+
+    public GPUImageSobelThresholdFilter() {
+        this(0.9f);
+    }
+
+    public GPUImageSobelThresholdFilter(float threshold) {
+        super(SOBEL_THRESHOLD_EDGE_DETECTION);
+        this.threshold = threshold;
+    }
+
+    @Override
+    public void onInit() {
+        super.onInit();
+        uniformThresholdLocation = GLES20.glGetUniformLocation(getProgram(), "threshold");
+    }
+
+    @Override
+    public void onInitialized() {
+        super.onInitialized();
+        setThreshold(threshold);
+    }
+
+    public void setThreshold(final float threshold) {
+        this.threshold = threshold;
+        setFloat(uniformThresholdLocation, threshold);
+    }
+}
diff --git a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageSoftLightBlendFilter.java b/library/src/main/java/jp/co/cyberagent/android/gpuimage/filter/GPUImageSoftLightBlendFilter.java
similarity index 94%
rename from library/src/jp/co/cyberagent/android/gpuimage/GPUImageSoftLightBlendFilter.java
rename to library/src/main/java/jp/co/cyberagent/android/gpuimage/filter/GPUImageSoftLightBlendFilter.java
index 0e1b742e..1310f3fb 100644
--- a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageSoftLightBlendFilter.java
+++ b/library/src/main/java/jp/co/cyberagent/android/gpuimage/filter/GPUImageSoftLightBlendFilter.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2012 CyberAgent
+ * Copyright (C) 2018 CyberAgent, Inc.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -14,7 +14,7 @@
  * limitations under the License.
  */
 
-package jp.co.cyberagent.android.gpuimage;
+package jp.co.cyberagent.android.gpuimage.filter;
 
 public class GPUImageSoftLightBlendFilter extends GPUImageTwoInputFilter {
     public static final String SOFT_LIGHT_BLEND_FRAGMENT_SHADER = "varying highp vec2 textureCoordinate;\n" +
diff --git a/library/src/main/java/jp/co/cyberagent/android/gpuimage/filter/GPUImageSolarizeFilter.java b/library/src/main/java/jp/co/cyberagent/android/gpuimage/filter/GPUImageSolarizeFilter.java
new file mode 100644
index 00000000..ee63cdd8
--- /dev/null
+++ b/library/src/main/java/jp/co/cyberagent/android/gpuimage/filter/GPUImageSolarizeFilter.java
@@ -0,0 +1,52 @@
+package jp.co.cyberagent.android.gpuimage.filter;
+
+import android.opengl.GLES20;
+
+public class GPUImageSolarizeFilter extends GPUImageFilter {
+    public static final String SOLATIZE_FRAGMENT_SHADER = "" +
+            "varying highp vec2 textureCoordinate;\n" +
+            "\n" +
+            "uniform sampler2D inputImageTexture;\n" +
+            "uniform highp float threshold;\n" +
+            "\n" +
+            "const highp vec3 W = vec3(0.2125, 0.7154, 0.0721);\n" +
+            "\n" +
+            "void main()\n" +
+            "{\n" +
+            "    highp vec4 textureColor = texture2D(inputImageTexture, textureCoordinate);\n" +
+            "    highp float luminance = dot(textureColor.rgb, W);\n" +
+            "    highp float thresholdResult = step(luminance, threshold);\n" +
+            "    highp vec3 finalColor = abs(thresholdResult - textureColor.rgb);\n" +
+            "    \n" +
+            "    gl_FragColor = vec4(finalColor, textureColor.w);\n" +
+            "}";
+
+    private int uniformThresholdLocation;
+    private float threshold;
+
+    public GPUImageSolarizeFilter() {
+        this(0.5f);
+    }
+
+    public GPUImageSolarizeFilter(float threshold) {
+        super(NO_FILTER_VERTEX_SHADER, SOLATIZE_FRAGMENT_SHADER);
+        this.threshold = threshold;
+    }
+
+    @Override
+    public void onInit() {
+        super.onInit();
+        uniformThresholdLocation = GLES20.glGetUniformLocation(getProgram(), "threshold");
+    }
+
+    @Override
+    public void onInitialized() {
+        super.onInitialized();
+        setThreshold(threshold);
+    }
+
+    public void setThreshold(final float threshold) {
+        this.threshold = threshold;
+        setFloat(uniformThresholdLocation, threshold);
+    }
+}
diff --git a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageSourceOverBlendFilter.java b/library/src/main/java/jp/co/cyberagent/android/gpuimage/filter/GPUImageSourceOverBlendFilter.java
similarity index 94%
rename from library/src/jp/co/cyberagent/android/gpuimage/GPUImageSourceOverBlendFilter.java
rename to library/src/main/java/jp/co/cyberagent/android/gpuimage/filter/GPUImageSourceOverBlendFilter.java
index fd6a7b98..aa175b60 100644
--- a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageSourceOverBlendFilter.java
+++ b/library/src/main/java/jp/co/cyberagent/android/gpuimage/filter/GPUImageSourceOverBlendFilter.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2012 CyberAgent
+ * Copyright (C) 2018 CyberAgent, Inc.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -14,7 +14,7 @@
  * limitations under the License.
  */
 
-package jp.co.cyberagent.android.gpuimage;
+package jp.co.cyberagent.android.gpuimage.filter;
 
 public class GPUImageSourceOverBlendFilter extends GPUImageTwoInputFilter {
     public static final String SOURCE_OVER_BLEND_FRAGMENT_SHADER = "varying highp vec2 textureCoordinate;\n" +
diff --git a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageSphereRefractionFilter.java b/library/src/main/java/jp/co/cyberagent/android/gpuimage/filter/GPUImageSphereRefractionFilter.java
similarity index 71%
rename from library/src/jp/co/cyberagent/android/gpuimage/GPUImageSphereRefractionFilter.java
rename to library/src/main/java/jp/co/cyberagent/android/gpuimage/filter/GPUImageSphereRefractionFilter.java
index 6314cf19..f0ffeccc 100644
--- a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageSphereRefractionFilter.java
+++ b/library/src/main/java/jp/co/cyberagent/android/gpuimage/filter/GPUImageSphereRefractionFilter.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2012 CyberAgent
+ * Copyright (C) 2018 CyberAgent, Inc.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -14,7 +14,7 @@
  * limitations under the License.
  */
 
-package jp.co.cyberagent.android.gpuimage;
+package jp.co.cyberagent.android.gpuimage.filter;
 
 import android.graphics.PointF;
 import android.opengl.GLES20;
@@ -46,14 +46,14 @@
             "gl_FragColor = texture2D(inputImageTexture, (refractedVector.xy + 1.0) * 0.5) * checkForPresenceWithinSphere;     \n" +
             "}\n";
 
-    private PointF mCenter;
-    private int mCenterLocation;
-    private float mRadius;
-    private int mRadiusLocation;
-    private float mAspectRatio;
-    private int mAspectRatioLocation;
-    private float mRefractiveIndex;
-    private int mRefractiveIndexLocation;
+    private PointF center;
+    private int centerLocation;
+    private float radius;
+    private int radiusLocation;
+    private float aspectRatio;
+    private int aspectRatioLocation;
+    private float refractiveIndex;
+    private int refractiveIndexLocation;
 
     public GPUImageSphereRefractionFilter() {
         this(new PointF(0.5f, 0.5f), 0.25f, 0.71f);
@@ -61,38 +61,39 @@ public GPUImageSphereRefractionFilter() {
 
     public GPUImageSphereRefractionFilter(PointF center, float radius, float refractiveIndex) {
         super(NO_FILTER_VERTEX_SHADER, SPHERE_FRAGMENT_SHADER);
-        mCenter = center;
-        mRadius = radius;
-        mRefractiveIndex = refractiveIndex;
+        this.center = center;
+        this.radius = radius;
+        this.refractiveIndex = refractiveIndex;
     }
 
     @Override
     public void onInit() {
         super.onInit();
-        mCenterLocation = GLES20.glGetUniformLocation(getProgram(), "center");
-        mRadiusLocation = GLES20.glGetUniformLocation(getProgram(), "radius");
-        mAspectRatioLocation = GLES20.glGetUniformLocation(getProgram(), "aspectRatio");
-        mRefractiveIndexLocation = GLES20.glGetUniformLocation(getProgram(), "refractiveIndex");
+        centerLocation = GLES20.glGetUniformLocation(getProgram(), "center");
+        radiusLocation = GLES20.glGetUniformLocation(getProgram(), "radius");
+        aspectRatioLocation = GLES20.glGetUniformLocation(getProgram(), "aspectRatio");
+        refractiveIndexLocation = GLES20.glGetUniformLocation(getProgram(), "refractiveIndex");
     }
 
     @Override
     public void onInitialized() {
         super.onInitialized();
-        setRadius(mRadius);
-        setCenter(mCenter);
-        setRefractiveIndex(mRefractiveIndex);
+        setAspectRatio(aspectRatio);
+        setRadius(radius);
+        setCenter(center);
+        setRefractiveIndex(refractiveIndex);
     }
 
     @Override
     public void onOutputSizeChanged(int width, int height) {
-        mAspectRatio = (float) height / width;
-        setAspectRatio(mAspectRatio);
+        aspectRatio = (float) height / width;
+        setAspectRatio(aspectRatio);
         super.onOutputSizeChanged(width, height);
     }
 
     private void setAspectRatio(float aspectRatio) {
-        mAspectRatio = aspectRatio;
-        setFloat(mAspectRatioLocation, aspectRatio);
+        this.aspectRatio = aspectRatio;
+        setFloat(aspectRatioLocation, aspectRatio);
     }
 
     /**
@@ -101,8 +102,8 @@ private void setAspectRatio(float aspectRatio) {
      * @param refractiveIndex default 0.71
      */
     public void setRefractiveIndex(float refractiveIndex) {
-        mRefractiveIndex = refractiveIndex;
-        setFloat(mRefractiveIndexLocation, refractiveIndex);
+        this.refractiveIndex = refractiveIndex;
+        setFloat(refractiveIndexLocation, refractiveIndex);
     }
 
     /**
@@ -111,8 +112,8 @@ public void setRefractiveIndex(float refractiveIndex) {
      * @param center default (0.5, 0.5)
      */
     public void setCenter(PointF center) {
-        mCenter = center;
-        setPoint(mCenterLocation, center);
+        this.center = center;
+        setPoint(centerLocation, center);
     }
 
     /**
@@ -121,7 +122,7 @@ public void setCenter(PointF center) {
      * @param radius from 0.0 to 1.0, default 0.25
      */
     public void setRadius(float radius) {
-        mRadius = radius;
-        setFloat(mRadiusLocation, radius);
+        this.radius = radius;
+        setFloat(radiusLocation, radius);
     }
 }
diff --git a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageSubtractBlendFilter.java b/library/src/main/java/jp/co/cyberagent/android/gpuimage/filter/GPUImageSubtractBlendFilter.java
similarity index 94%
rename from library/src/jp/co/cyberagent/android/gpuimage/GPUImageSubtractBlendFilter.java
rename to library/src/main/java/jp/co/cyberagent/android/gpuimage/filter/GPUImageSubtractBlendFilter.java
index 52b54ecc..0aec1891 100644
--- a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageSubtractBlendFilter.java
+++ b/library/src/main/java/jp/co/cyberagent/android/gpuimage/filter/GPUImageSubtractBlendFilter.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2012 CyberAgent
+ * Copyright (C) 2018 CyberAgent, Inc.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -14,7 +14,7 @@
  * limitations under the License.
  */
 
-package jp.co.cyberagent.android.gpuimage;
+package jp.co.cyberagent.android.gpuimage.filter;
 
 public class GPUImageSubtractBlendFilter extends GPUImageTwoInputFilter {
     public static final String SUBTRACT_BLEND_FRAGMENT_SHADER = "varying highp vec2 textureCoordinate;\n" +
diff --git a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageSwirlFilter.java b/library/src/main/java/jp/co/cyberagent/android/gpuimage/filter/GPUImageSwirlFilter.java
similarity index 77%
rename from library/src/jp/co/cyberagent/android/gpuimage/GPUImageSwirlFilter.java
rename to library/src/main/java/jp/co/cyberagent/android/gpuimage/filter/GPUImageSwirlFilter.java
index d4947b9a..e35698ca 100644
--- a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageSwirlFilter.java
+++ b/library/src/main/java/jp/co/cyberagent/android/gpuimage/filter/GPUImageSwirlFilter.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2012 CyberAgent
+ * Copyright (C) 2018 CyberAgent, Inc.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -14,7 +14,7 @@
  * limitations under the License.
  */
 
-package jp.co.cyberagent.android.gpuimage;
+package jp.co.cyberagent.android.gpuimage.filter;
 
 import android.graphics.PointF;
 import android.opengl.GLES20;
@@ -51,12 +51,12 @@
             "\n" +
             "}\n";
 
-    private float mAngle;
-    private int mAngleLocation;
-    private float mRadius;
-    private int mRadiusLocation;
-    private PointF mCenter;
-    private int mCenterLocation;
+    private float angle;
+    private int angleLocation;
+    private float radius;
+    private int radiusLocation;
+    private PointF center;
+    private int centerLocation;
 
     public GPUImageSwirlFilter() {
         this(0.5f, 1.0f, new PointF(0.5f, 0.5f));
@@ -64,25 +64,25 @@ public GPUImageSwirlFilter() {
 
     public GPUImageSwirlFilter(float radius, float angle, PointF center) {
         super(NO_FILTER_VERTEX_SHADER, SWIRL_FRAGMENT_SHADER);
-        mRadius = radius;
-        mAngle = angle;
-        mCenter = center;
+        this.radius = radius;
+        this.angle = angle;
+        this.center = center;
     }
 
     @Override
     public void onInit() {
         super.onInit();
-        mAngleLocation = GLES20.glGetUniformLocation(getProgram(), "angle");
-        mRadiusLocation = GLES20.glGetUniformLocation(getProgram(), "radius");
-        mCenterLocation = GLES20.glGetUniformLocation(getProgram(), "center");
+        angleLocation = GLES20.glGetUniformLocation(getProgram(), "angle");
+        radiusLocation = GLES20.glGetUniformLocation(getProgram(), "radius");
+        centerLocation = GLES20.glGetUniformLocation(getProgram(), "center");
     }
 
     @Override
     public void onInitialized() {
         super.onInitialized();
-        setRadius(mRadius);
-        setAngle(mAngle);
-        setCenter(mCenter);
+        setRadius(radius);
+        setAngle(angle);
+        setCenter(center);
     }
 
     /**
@@ -91,8 +91,8 @@ public void onInitialized() {
      * @param radius from 0.0 to 1.0, default 0.5
      */
     public void setRadius(float radius) {
-        mRadius = radius;
-        setFloat(mRadiusLocation, radius);
+        this.radius = radius;
+        setFloat(radiusLocation, radius);
     }
 
     /**
@@ -101,8 +101,8 @@ public void setRadius(float radius) {
      * @param angle minimum 0.0, default 1.0
      */
     public void setAngle(float angle) {
-        mAngle = angle;
-        setFloat(mAngleLocation, angle);
+        this.angle = angle;
+        setFloat(angleLocation, angle);
     }
 
     /**
@@ -111,7 +111,7 @@ public void setAngle(float angle) {
      * @param center default (0.5, 0.5)
      */
     public void setCenter(PointF center) {
-        mCenter = center;
-        setPoint(mCenterLocation, center);
+        this.center = center;
+        setPoint(centerLocation, center);
     }
 }
diff --git a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageThresholdEdgeDetection.java b/library/src/main/java/jp/co/cyberagent/android/gpuimage/filter/GPUImageThresholdEdgeDetectionFilter.java
similarity index 72%
rename from library/src/jp/co/cyberagent/android/gpuimage/GPUImageThresholdEdgeDetection.java
rename to library/src/main/java/jp/co/cyberagent/android/gpuimage/filter/GPUImageThresholdEdgeDetectionFilter.java
index c136155a..3416e91d 100644
--- a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageThresholdEdgeDetection.java
+++ b/library/src/main/java/jp/co/cyberagent/android/gpuimage/filter/GPUImageThresholdEdgeDetectionFilter.java
@@ -1,10 +1,10 @@
-package jp.co.cyberagent.android.gpuimage;
+package jp.co.cyberagent.android.gpuimage.filter;
 
 /**
  * Applies sobel edge detection on the image.
  */
-public class GPUImageThresholdEdgeDetection extends GPUImageFilterGroup {
-    public GPUImageThresholdEdgeDetection() {
+public class GPUImageThresholdEdgeDetectionFilter extends GPUImageFilterGroup {
+    public GPUImageThresholdEdgeDetectionFilter() {
         super();
         addFilter(new GPUImageGrayscaleFilter());
         addFilter(new GPUImageSobelThresholdFilter());
diff --git a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageToneCurveFilter.java b/library/src/main/java/jp/co/cyberagent/android/gpuimage/filter/GPUImageToneCurveFilter.java
similarity index 78%
rename from library/src/jp/co/cyberagent/android/gpuimage/GPUImageToneCurveFilter.java
rename to library/src/main/java/jp/co/cyberagent/android/gpuimage/filter/GPUImageToneCurveFilter.java
index 0f6e1d08..9c5a4f5a 100644
--- a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageToneCurveFilter.java
+++ b/library/src/main/java/jp/co/cyberagent/android/gpuimage/filter/GPUImageToneCurveFilter.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2012 CyberAgent
+ * Copyright (C) 2018 CyberAgent, Inc.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -14,18 +14,21 @@
  * limitations under the License.
  */
 
-package jp.co.cyberagent.android.gpuimage;
+package jp.co.cyberagent.android.gpuimage.filter;
 
 import android.graphics.Point;
 import android.graphics.PointF;
 import android.opengl.GLES20;
 
-import java.io.*;
+import java.io.IOException;
+import java.io.InputStream;
 import java.nio.ByteBuffer;
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.Comparator;
 
+import jp.co.cyberagent.android.gpuimage.util.OpenGlUtils;
+
 public class GPUImageToneCurveFilter extends GPUImageFilter {
     public static final String TONE_CURVE_FRAGMENT_SHADER = "" +
             " varying highp vec2 textureCoordinate;\n" +
@@ -42,37 +45,37 @@
             "     gl_FragColor = vec4(redCurveValue, greenCurveValue, blueCurveValue, textureColor.a);\n" +
             " }";
 
-    private int[] mToneCurveTexture = new int[]{OpenGlUtils.NO_TEXTURE};
-    private int mToneCurveTextureUniformLocation;
+    private int[] toneCurveTexture = new int[]{OpenGlUtils.NO_TEXTURE};
+    private int toneCurveTextureUniformLocation;
 
-    private PointF[] mRgbCompositeControlPoints;
-    private PointF[] mRedControlPoints;
-    private PointF[] mGreenControlPoints;
-    private PointF[] mBlueControlPoints;
+    private PointF[] rgbCompositeControlPoints;
+    private PointF[] redControlPoints;
+    private PointF[] greenControlPoints;
+    private PointF[] blueControlPoints;
 
-    private ArrayList<Float> mRgbCompositeCurve;
-    private ArrayList<Float> mRedCurve;
-    private ArrayList<Float> mGreenCurve;
-    private ArrayList<Float> mBlueCurve;
+    private ArrayList<Float> rgbCompositeCurve;
+    private ArrayList<Float> redCurve;
+    private ArrayList<Float> greenCurve;
+    private ArrayList<Float> blueCurve;
 
 
     public GPUImageToneCurveFilter() {
         super(NO_FILTER_VERTEX_SHADER, TONE_CURVE_FRAGMENT_SHADER);
 
         PointF[] defaultCurvePoints = new PointF[]{new PointF(0.0f, 0.0f), new PointF(0.5f, 0.5f), new PointF(1.0f, 1.0f)};
-        mRgbCompositeControlPoints = defaultCurvePoints;
-        mRedControlPoints = defaultCurvePoints;
-        mGreenControlPoints = defaultCurvePoints;
-        mBlueControlPoints = defaultCurvePoints;
+        rgbCompositeControlPoints = defaultCurvePoints;
+        redControlPoints = defaultCurvePoints;
+        greenControlPoints = defaultCurvePoints;
+        blueControlPoints = defaultCurvePoints;
     }
 
     @Override
     public void onInit() {
         super.onInit();
-        mToneCurveTextureUniformLocation = GLES20.glGetUniformLocation(getProgram(), "toneCurveTexture");
+        toneCurveTextureUniformLocation = GLES20.glGetUniformLocation(getProgram(), "toneCurveTexture");
         GLES20.glActiveTexture(GLES20.GL_TEXTURE3);
-        GLES20.glGenTextures(1, mToneCurveTexture, 0);
-        GLES20.glBindTexture(GLES20.GL_TEXTURE_2D, mToneCurveTexture[0]);
+        GLES20.glGenTextures(1, toneCurveTexture, 0);
+        GLES20.glBindTexture(GLES20.GL_TEXTURE_2D, toneCurveTexture[0]);
         GLES20.glTexParameteri(GLES20.GL_TEXTURE_2D, GLES20.GL_TEXTURE_MIN_FILTER, GLES20.GL_LINEAR);
         GLES20.glTexParameteri(GLES20.GL_TEXTURE_2D, GLES20.GL_TEXTURE_MAG_FILTER, GLES20.GL_LINEAR);
         GLES20.glTexParameteri(GLES20.GL_TEXTURE_2D, GLES20.GL_TEXTURE_WRAP_S, GLES20.GL_CLAMP_TO_EDGE);
@@ -82,18 +85,18 @@ public void onInit() {
     @Override
     public void onInitialized() {
         super.onInitialized();
-        setRgbCompositeControlPoints(mRgbCompositeControlPoints);
-        setRedControlPoints(mRedControlPoints);
-        setGreenControlPoints(mGreenControlPoints);
-        setBlueControlPoints(mBlueControlPoints);
+        setRgbCompositeControlPoints(rgbCompositeControlPoints);
+        setRedControlPoints(redControlPoints);
+        setGreenControlPoints(greenControlPoints);
+        setBlueControlPoints(blueControlPoints);
     }
 
     @Override
     protected void onDrawArraysPre() {
-        if (mToneCurveTexture[0] != OpenGlUtils.NO_TEXTURE) {
+        if (toneCurveTexture[0] != OpenGlUtils.NO_TEXTURE) {
             GLES20.glActiveTexture(GLES20.GL_TEXTURE3);
-            GLES20.glBindTexture(GLES20.GL_TEXTURE_2D, mToneCurveTexture[0]);
-            GLES20.glUniform1i(mToneCurveTextureUniformLocation, 3);
+            GLES20.glBindTexture(GLES20.GL_TEXTURE_2D, toneCurveTexture[0]);
+            GLES20.glUniform1i(toneCurveTextureUniformLocation, 3);
         }
     }
 
@@ -102,7 +105,7 @@ public void setFromCurveFileInputStream(InputStream input) {
             int version = readShort(input);
             int totalCurves = readShort(input);
 
-            ArrayList<PointF[]> curves = new ArrayList<PointF[]>(totalCurves);
+            ArrayList<PointF[]> curves = new ArrayList<>(totalCurves);
             float pointRate = 1.0f / 255;
 
             for (int i = 0; i < totalCurves; i++) {
@@ -126,10 +129,10 @@ public void setFromCurveFileInputStream(InputStream input) {
             }
             input.close();
 
-            mRgbCompositeControlPoints = curves.get(0);
-            mRedControlPoints = curves.get(1);
-            mGreenControlPoints = curves.get(2);
-            mBlueControlPoints = curves.get(3);
+            rgbCompositeControlPoints = curves.get(0);
+            redControlPoints = curves.get(1);
+            greenControlPoints = curves.get(2);
+            blueControlPoints = curves.get(3);
         } catch (IOException e) {
             e.printStackTrace();
         }
@@ -140,26 +143,26 @@ private short readShort(InputStream input) throws IOException {
     }
 
     public void setRgbCompositeControlPoints(PointF[] points) {
-        mRgbCompositeControlPoints = points;
-        mRgbCompositeCurve = createSplineCurve(mRgbCompositeControlPoints);
+        rgbCompositeControlPoints = points;
+        rgbCompositeCurve = createSplineCurve(rgbCompositeControlPoints);
         updateToneCurveTexture();
     }
 
     public void setRedControlPoints(PointF[] points) {
-        mRedControlPoints = points;
-        mRedCurve = createSplineCurve(mRedControlPoints);
+        redControlPoints = points;
+        redCurve = createSplineCurve(redControlPoints);
         updateToneCurveTexture();
     }
 
     public void setGreenControlPoints(PointF[] points) {
-        mGreenControlPoints = points;
-        mGreenCurve = createSplineCurve(mGreenControlPoints);
+        greenControlPoints = points;
+        greenCurve = createSplineCurve(greenControlPoints);
         updateToneCurveTexture();
     }
 
     public void setBlueControlPoints(PointF[] points) {
-        mBlueControlPoints = points;
-        mBlueCurve = createSplineCurve(mBlueControlPoints);
+        blueControlPoints = points;
+        blueCurve = createSplineCurve(blueControlPoints);
         updateToneCurveTexture();
     }
 
@@ -168,16 +171,16 @@ private void updateToneCurveTexture() {
             @Override
             public void run() {
                 GLES20.glActiveTexture(GLES20.GL_TEXTURE3);
-                GLES20.glBindTexture(GLES20.GL_TEXTURE_2D, mToneCurveTexture[0]);
+                GLES20.glBindTexture(GLES20.GL_TEXTURE_2D, toneCurveTexture[0]);
 
-                if ((mRedCurve.size() >= 256) && (mGreenCurve.size() >= 256) && (mBlueCurve.size() >= 256) && (mRgbCompositeCurve.size() >= 256)) {
+                if ((redCurve.size() >= 256) && (greenCurve.size() >= 256) && (blueCurve.size() >= 256) && (rgbCompositeCurve.size() >= 256)) {
                     byte[] toneCurveByteArray = new byte[256 * 4];
                     for (int currentCurveIndex = 0; currentCurveIndex < 256; currentCurveIndex++) {
                         // BGRA for upload to texture
-                        toneCurveByteArray[currentCurveIndex * 4 + 2] = (byte) ((int) Math.min(Math.max(currentCurveIndex + mBlueCurve.get(currentCurveIndex) + mRgbCompositeCurve.get(currentCurveIndex), 0), 255) & 0xff);
-                        toneCurveByteArray[currentCurveIndex * 4 + 1] = (byte) ((int) Math.min(Math.max(currentCurveIndex + mGreenCurve.get(currentCurveIndex) + mRgbCompositeCurve.get(currentCurveIndex), 0), 255) & 0xff);
-                        toneCurveByteArray[currentCurveIndex * 4] = (byte) ((int) Math.min(Math.max(currentCurveIndex + mRedCurve.get(currentCurveIndex) + mRgbCompositeCurve.get(currentCurveIndex), 0), 255) & 0xff);
-                        toneCurveByteArray[currentCurveIndex * 4 + 3] = (byte) (255 & 0xff);
+                        toneCurveByteArray[currentCurveIndex * 4 + 2] = (byte) ((int) Math.min(Math.max(currentCurveIndex + blueCurve.get(currentCurveIndex) + rgbCompositeCurve.get(currentCurveIndex), 0), 255) & 0xff);
+                        toneCurveByteArray[currentCurveIndex * 4 + 1] = (byte) ((int) Math.min(Math.max(currentCurveIndex + greenCurve.get(currentCurveIndex) + rgbCompositeCurve.get(currentCurveIndex), 0), 255) & 0xff);
+                        toneCurveByteArray[currentCurveIndex * 4] = (byte) ((int) Math.min(Math.max(currentCurveIndex + redCurve.get(currentCurveIndex) + rgbCompositeCurve.get(currentCurveIndex), 0), 255) & 0xff);
+                        toneCurveByteArray[currentCurveIndex * 4 + 3] = (byte) (0xff);
                     }
 
                     GLES20.glTexImage2D(GLES20.GL_TEXTURE_2D, 0, GLES20.GL_RGBA, 256 /*width*/, 1 /*height*/, 0, GLES20.GL_RGBA, GLES20.GL_UNSIGNED_BYTE, ByteBuffer.wrap(toneCurveByteArray));
@@ -243,7 +246,7 @@ public int compare(PointF point1, PointF point2) {
         }
 
         // Prepare the spline points.
-        ArrayList<Float> preparedSplinePoints = new ArrayList<Float>(splinePoints.size());
+        ArrayList<Float> preparedSplinePoints = new ArrayList<>(splinePoints.size());
         for (Point newPoint : splinePoints) {
             Point origPoint = new Point(newPoint.x, newPoint.x);
 
@@ -276,7 +279,7 @@ public int compare(PointF point1, PointF point2) {
         }
 
 
-        ArrayList<Point> output = new ArrayList<Point>(n + 1);
+        ArrayList<Point> output = new ArrayList<>(n + 1);
 
         for (int i = 0; i < n - 1; i++) {
             Point cur = points[i];
@@ -356,7 +359,7 @@ public int compare(PointF point1, PointF point2) {
             result[i] -= k * result[i + 1];
         }
 
-        ArrayList<Double> output = new ArrayList<Double>(n);
+        ArrayList<Double> output = new ArrayList<>(n);
         for (int i = 0; i < n; i++) output.add(result[i] / matrix[i][1]);
 
         return output;
diff --git a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageToonFilter.java b/library/src/main/java/jp/co/cyberagent/android/gpuimage/filter/GPUImageToonFilter.java
similarity index 84%
rename from library/src/jp/co/cyberagent/android/gpuimage/GPUImageToonFilter.java
rename to library/src/main/java/jp/co/cyberagent/android/gpuimage/filter/GPUImageToonFilter.java
index 5148d1d0..7a9e274a 100644
--- a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageToonFilter.java
+++ b/library/src/main/java/jp/co/cyberagent/android/gpuimage/filter/GPUImageToonFilter.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2012 CyberAgent
+ * Copyright (C) 2018 CyberAgent, Inc.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -14,7 +14,7 @@
  * limitations under the License.
  */
 
-package jp.co.cyberagent.android.gpuimage;
+package jp.co.cyberagent.android.gpuimage.filter;
 
 import android.opengl.GLES20;
 
@@ -70,10 +70,10 @@
             "gl_FragColor = vec4(posterizedImageColor * thresholdTest, textureColor.a);\n" +
             "}\n";
 
-    float mThreshold;
-    int mThresholdLocation;
-    float mQuantizationLevels;
-    int mQuantizationLevelsLocation;
+    private float threshold;
+    private int thresholdLocation;
+    private float quantizationLevels;
+    private int quantizationLevelsLocation;
 
     public GPUImageToonFilter() {
         this(0.2f, 10.0f);
@@ -81,22 +81,22 @@ public GPUImageToonFilter() {
 
     public GPUImageToonFilter(float threshold, float quantizationLevels) {
         super(TOON_FRAGMENT_SHADER);
-        mThreshold = threshold;
-        mQuantizationLevels = quantizationLevels;
+        this.threshold = threshold;
+        this.quantizationLevels = quantizationLevels;
     }
 
     @Override
     public void onInit() {
         super.onInit();
-        mThresholdLocation = GLES20.glGetUniformLocation(getProgram(), "threshold");
-        mQuantizationLevelsLocation = GLES20.glGetUniformLocation(getProgram(), "quantizationLevels");
+        thresholdLocation = GLES20.glGetUniformLocation(getProgram(), "threshold");
+        quantizationLevelsLocation = GLES20.glGetUniformLocation(getProgram(), "quantizationLevels");
     }
 
     @Override
     public void onInitialized() {
         super.onInitialized();
-        setThreshold(mThreshold);
-        setQuantizationLevels(mQuantizationLevels);
+        setThreshold(threshold);
+        setQuantizationLevels(quantizationLevels);
     }
 
     /**
@@ -105,8 +105,8 @@ public void onInitialized() {
      * @param threshold default 0.2
      */
     public void setThreshold(final float threshold) {
-        mThreshold = threshold;
-        setFloat(mThresholdLocation, threshold);
+        this.threshold = threshold;
+        setFloat(thresholdLocation, threshold);
     }
 
     /**
@@ -115,7 +115,7 @@ public void setThreshold(final float threshold) {
      * @param quantizationLevels default 10.0
      */
     public void setQuantizationLevels(final float quantizationLevels) {
-        mQuantizationLevels = quantizationLevels;
-        setFloat(mQuantizationLevelsLocation, quantizationLevels);
+        this.quantizationLevels = quantizationLevels;
+        setFloat(quantizationLevelsLocation, quantizationLevels);
     }
 }
diff --git a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageTransformFilter.java b/library/src/main/java/jp/co/cyberagent/android/gpuimage/filter/GPUImageTransformFilter.java
similarity index 87%
rename from library/src/jp/co/cyberagent/android/gpuimage/GPUImageTransformFilter.java
rename to library/src/main/java/jp/co/cyberagent/android/gpuimage/filter/GPUImageTransformFilter.java
index 0a962cc5..96317da0 100644
--- a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageTransformFilter.java
+++ b/library/src/main/java/jp/co/cyberagent/android/gpuimage/filter/GPUImageTransformFilter.java
@@ -1,4 +1,20 @@
-package jp.co.cyberagent.android.gpuimage;
+/*
+ * Copyright (C) 2018 CyberAgent, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package jp.co.cyberagent.android.gpuimage.filter;
 
 import android.opengl.GLES20;
 import android.opengl.Matrix;
@@ -50,14 +66,13 @@ public void onInit() {
         super.onInit();
         transformMatrixUniform = GLES20.glGetUniformLocation(getProgram(), "transformMatrix");
         orthographicMatrixUniform = GLES20.glGetUniformLocation(getProgram(), "orthographicMatrix");
-
-        setUniformMatrix4f(transformMatrixUniform, transform3D);
-        setUniformMatrix4f(orthographicMatrixUniform, orthographicMatrix);
     }
 
     @Override
     public void onInitialized() {
         super.onInitialized();
+        setUniformMatrix4f(transformMatrixUniform, transform3D);
+        setUniformMatrix4f(orthographicMatrixUniform, orthographicMatrix);
     }
 
     @Override
diff --git a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageTwoInputFilter.java b/library/src/main/java/jp/co/cyberagent/android/gpuimage/filter/GPUImageTwoInputFilter.java
similarity index 61%
rename from library/src/jp/co/cyberagent/android/gpuimage/GPUImageTwoInputFilter.java
rename to library/src/main/java/jp/co/cyberagent/android/gpuimage/filter/GPUImageTwoInputFilter.java
index afc3b864..64c8d5db 100644
--- a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageTwoInputFilter.java
+++ b/library/src/main/java/jp/co/cyberagent/android/gpuimage/filter/GPUImageTwoInputFilter.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2012 CyberAgent
+ * Copyright (C) 2018 CyberAgent, Inc.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -14,15 +14,18 @@
  * limitations under the License.
  */
 
-package jp.co.cyberagent.android.gpuimage;
+package jp.co.cyberagent.android.gpuimage.filter;
+
+import android.graphics.Bitmap;
+import android.opengl.GLES20;
 
 import java.nio.ByteBuffer;
 import java.nio.ByteOrder;
 import java.nio.FloatBuffer;
 
+import jp.co.cyberagent.android.gpuimage.util.OpenGlUtils;
+import jp.co.cyberagent.android.gpuimage.util.Rotation;
 import jp.co.cyberagent.android.gpuimage.util.TextureRotationUtil;
-import android.graphics.Bitmap;
-import android.opengl.GLES20;
 
 public class GPUImageTwoInputFilter extends GPUImageFilter {
     private static final String VERTEX_SHADER = "attribute vec4 position;\n" +
@@ -39,11 +42,11 @@
             "    textureCoordinate2 = inputTextureCoordinate2.xy;\n" +
             "}";
 
-    public int mFilterSecondTextureCoordinateAttribute;
-    public int mFilterInputTextureUniform2;
-    public int mFilterSourceTexture2 = OpenGlUtils.NO_TEXTURE;
-    private ByteBuffer mTexture2CoordinatesBuffer;
-    private Bitmap mBitmap;
+    private int filterSecondTextureCoordinateAttribute;
+    private int filterInputTextureUniform2;
+    private int filterSourceTexture2 = OpenGlUtils.NO_TEXTURE;
+    private ByteBuffer texture2CoordinatesBuffer;
+    private Bitmap bitmap;
 
     public GPUImageTwoInputFilter(String fragmentShader) {
         this(VERTEX_SHADER, fragmentShader);
@@ -58,64 +61,68 @@ public GPUImageTwoInputFilter(String vertexShader, String fragmentShader) {
     public void onInit() {
         super.onInit();
 
-        mFilterSecondTextureCoordinateAttribute = GLES20.glGetAttribLocation(getProgram(), "inputTextureCoordinate2");
-        mFilterInputTextureUniform2 = GLES20.glGetUniformLocation(getProgram(), "inputImageTexture2"); // This does assume a name of "inputImageTexture2" for second input texture in the fragment shader
-        GLES20.glEnableVertexAttribArray(mFilterSecondTextureCoordinateAttribute);
+        filterSecondTextureCoordinateAttribute = GLES20.glGetAttribLocation(getProgram(), "inputTextureCoordinate2");
+        filterInputTextureUniform2 = GLES20.glGetUniformLocation(getProgram(), "inputImageTexture2"); // This does assume a name of "inputImageTexture2" for second input texture in the fragment shader
+        GLES20.glEnableVertexAttribArray(filterSecondTextureCoordinateAttribute);
+    }
 
-        if (mBitmap != null&&!mBitmap.isRecycled()) {
-            setBitmap(mBitmap);
+    @Override
+    public void onInitialized() {
+        super.onInitialized();
+        if (bitmap != null && !bitmap.isRecycled()) {
+            setBitmap(bitmap);
         }
     }
-    
+
     public void setBitmap(final Bitmap bitmap) {
         if (bitmap != null && bitmap.isRecycled()) {
             return;
         }
-        mBitmap = bitmap;
-        if (mBitmap == null) {
+        this.bitmap = bitmap;
+        if (this.bitmap == null) {
             return;
         }
         runOnDraw(new Runnable() {
             public void run() {
-                if (mFilterSourceTexture2 == OpenGlUtils.NO_TEXTURE) {
+                if (filterSourceTexture2 == OpenGlUtils.NO_TEXTURE) {
                     if (bitmap == null || bitmap.isRecycled()) {
                         return;
                     }
                     GLES20.glActiveTexture(GLES20.GL_TEXTURE3);
-                    mFilterSourceTexture2 = OpenGlUtils.loadTexture(bitmap, OpenGlUtils.NO_TEXTURE, false);
+                    filterSourceTexture2 = OpenGlUtils.loadTexture(bitmap, OpenGlUtils.NO_TEXTURE, false);
                 }
             }
         });
     }
 
     public Bitmap getBitmap() {
-        return mBitmap;
+        return bitmap;
     }
 
     public void recycleBitmap() {
-        if (mBitmap != null && !mBitmap.isRecycled()) {
-            mBitmap.recycle();
-            mBitmap = null;
+        if (bitmap != null && !bitmap.isRecycled()) {
+            bitmap.recycle();
+            bitmap = null;
         }
     }
 
     public void onDestroy() {
         super.onDestroy();
         GLES20.glDeleteTextures(1, new int[]{
-                mFilterSourceTexture2
+                filterSourceTexture2
         }, 0);
-        mFilterSourceTexture2 = OpenGlUtils.NO_TEXTURE;
+        filterSourceTexture2 = OpenGlUtils.NO_TEXTURE;
     }
 
     @Override
     protected void onDrawArraysPre() {
-        GLES20.glEnableVertexAttribArray(mFilterSecondTextureCoordinateAttribute);
+        GLES20.glEnableVertexAttribArray(filterSecondTextureCoordinateAttribute);
         GLES20.glActiveTexture(GLES20.GL_TEXTURE3);
-        GLES20.glBindTexture(GLES20.GL_TEXTURE_2D, mFilterSourceTexture2);
-        GLES20.glUniform1i(mFilterInputTextureUniform2, 3);
+        GLES20.glBindTexture(GLES20.GL_TEXTURE_2D, filterSourceTexture2);
+        GLES20.glUniform1i(filterInputTextureUniform2, 3);
 
-        mTexture2CoordinatesBuffer.position(0);
-        GLES20.glVertexAttribPointer(mFilterSecondTextureCoordinateAttribute, 2, GLES20.GL_FLOAT, false, 0, mTexture2CoordinatesBuffer);
+        texture2CoordinatesBuffer.position(0);
+        GLES20.glVertexAttribPointer(filterSecondTextureCoordinateAttribute, 2, GLES20.GL_FLOAT, false, 0, texture2CoordinatesBuffer);
     }
 
     public void setRotation(final Rotation rotation, final boolean flipHorizontal, final boolean flipVertical) {
@@ -126,6 +133,6 @@ public void setRotation(final Rotation rotation, final boolean flipHorizontal, f
         fBuffer.put(buffer);
         fBuffer.flip();
 
-        mTexture2CoordinatesBuffer = bBuffer;
+        texture2CoordinatesBuffer = bBuffer;
     }
 }
diff --git a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageTwoPassFilter.java b/library/src/main/java/jp/co/cyberagent/android/gpuimage/filter/GPUImageTwoPassFilter.java
similarity index 91%
rename from library/src/jp/co/cyberagent/android/gpuimage/GPUImageTwoPassFilter.java
rename to library/src/main/java/jp/co/cyberagent/android/gpuimage/filter/GPUImageTwoPassFilter.java
index bf3fbf17..8e492570 100644
--- a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageTwoPassFilter.java
+++ b/library/src/main/java/jp/co/cyberagent/android/gpuimage/filter/GPUImageTwoPassFilter.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2012 CyberAgent
+ * Copyright (C) 2018 CyberAgent, Inc.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -14,7 +14,7 @@
  * limitations under the License.
  */
 
-package jp.co.cyberagent.android.gpuimage;
+package jp.co.cyberagent.android.gpuimage.filter;
 
 public class GPUImageTwoPassFilter extends GPUImageFilterGroup {
     public GPUImageTwoPassFilter(String firstVertexShader, String firstFragmentShader,
diff --git a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageTwoPassTextureSamplingFilter.java b/library/src/main/java/jp/co/cyberagent/android/gpuimage/filter/GPUImageTwoPassTextureSamplingFilter.java
similarity index 86%
rename from library/src/jp/co/cyberagent/android/gpuimage/GPUImageTwoPassTextureSamplingFilter.java
rename to library/src/main/java/jp/co/cyberagent/android/gpuimage/filter/GPUImageTwoPassTextureSamplingFilter.java
index 19c0365b..219a7b1a 100644
--- a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageTwoPassTextureSamplingFilter.java
+++ b/library/src/main/java/jp/co/cyberagent/android/gpuimage/filter/GPUImageTwoPassTextureSamplingFilter.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2012 CyberAgent
+ * Copyright (C) 2018 CyberAgent, Inc.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -14,7 +14,7 @@
  * limitations under the License.
  */
 
-package jp.co.cyberagent.android.gpuimage;
+package jp.co.cyberagent.android.gpuimage.filter;
 
 import android.opengl.GLES20;
 
@@ -33,18 +33,18 @@ public void onInit() {
 
     protected void initTexelOffsets() {
         float ratio = getHorizontalTexelOffsetRatio();
-        GPUImageFilter filter = mFilters.get(0);
+        GPUImageFilter filter = getFilters().get(0);
         int texelWidthOffsetLocation = GLES20.glGetUniformLocation(filter.getProgram(), "texelWidthOffset");
         int texelHeightOffsetLocation = GLES20.glGetUniformLocation(filter.getProgram(), "texelHeightOffset");
-        filter.setFloat(texelWidthOffsetLocation, ratio / mOutputWidth);
+        filter.setFloat(texelWidthOffsetLocation, ratio / getOutputWidth());
         filter.setFloat(texelHeightOffsetLocation, 0);
 
         ratio = getVerticalTexelOffsetRatio();
-        filter = mFilters.get(1);
+        filter = getFilters().get(1);
         texelWidthOffsetLocation = GLES20.glGetUniformLocation(filter.getProgram(), "texelWidthOffset");
         texelHeightOffsetLocation = GLES20.glGetUniformLocation(filter.getProgram(), "texelHeightOffset");
         filter.setFloat(texelWidthOffsetLocation, 0);
-        filter.setFloat(texelHeightOffsetLocation, ratio / mOutputHeight);
+        filter.setFloat(texelHeightOffsetLocation, ratio / getOutputHeight());
     }
 
     @Override
diff --git a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageVignetteFilter.java b/library/src/main/java/jp/co/cyberagent/android/gpuimage/filter/GPUImageVignetteFilter.java
similarity index 62%
rename from library/src/jp/co/cyberagent/android/gpuimage/GPUImageVignetteFilter.java
rename to library/src/main/java/jp/co/cyberagent/android/gpuimage/filter/GPUImageVignetteFilter.java
index 439e8bd0..81b44b11 100644
--- a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageVignetteFilter.java
+++ b/library/src/main/java/jp/co/cyberagent/android/gpuimage/filter/GPUImageVignetteFilter.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2012 CyberAgent
+ * Copyright (C) 2018 CyberAgent, Inc.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -14,7 +14,7 @@
  * limitations under the License.
  */
 
-package jp.co.cyberagent.android.gpuimage;
+package jp.co.cyberagent.android.gpuimage.filter;
 
 import android.graphics.PointF;
 import android.opengl.GLES20;
@@ -49,60 +49,63 @@
             "     gl_FragColor = vec4(mix(rgb.x, vignetteColor.x, percent), mix(rgb.y, vignetteColor.y, percent), mix(rgb.z, vignetteColor.z, percent), 1.0);\n" +
             " }";
 
-    private int mVignetteCenterLocation;
-    private PointF mVignetteCenter;
-    private int mVignetteColorLocation;
-    private float[] mVignetteColor;
-    private int mVignetteStartLocation;
-    private float mVignetteStart;
-    private int mVignetteEndLocation;
-    private float mVignetteEnd;
-    
+    private int vignetteCenterLocation;
+    private PointF vignetteCenter;
+    private int vignetteColorLocation;
+    private float[] vignetteColor;
+    private int vignetteStartLocation;
+    private float vignetteStart;
+    private int vignetteEndLocation;
+    private float vignetteEnd;
+
     public GPUImageVignetteFilter() {
-        this(new PointF(), new float[] {0.0f, 0.0f, 0.0f}, 0.3f, 0.75f);
+        this(new PointF(), new float[]{0.0f, 0.0f, 0.0f}, 0.3f, 0.75f);
     }
-    
+
     public GPUImageVignetteFilter(final PointF vignetteCenter, final float[] vignetteColor, final float vignetteStart, final float vignetteEnd) {
         super(NO_FILTER_VERTEX_SHADER, VIGNETTING_FRAGMENT_SHADER);
-        mVignetteCenter = vignetteCenter;
-        mVignetteColor = vignetteColor;
-        mVignetteStart = vignetteStart;
-        mVignetteEnd = vignetteEnd;
-        
+        this.vignetteCenter = vignetteCenter;
+        this.vignetteColor = vignetteColor;
+        this.vignetteStart = vignetteStart;
+        this.vignetteEnd = vignetteEnd;
+
     }
 
     @Override
     public void onInit() {
         super.onInit();
-        mVignetteCenterLocation = GLES20.glGetUniformLocation(getProgram(), "vignetteCenter");
-        mVignetteColorLocation = GLES20.glGetUniformLocation(getProgram(), "vignetteColor");
-        mVignetteStartLocation = GLES20.glGetUniformLocation(getProgram(), "vignetteStart");
-        mVignetteEndLocation = GLES20.glGetUniformLocation(getProgram(), "vignetteEnd");
-        
-        setVignetteCenter(mVignetteCenter);
-        setVignetteColor(mVignetteColor);
-        setVignetteStart(mVignetteStart);
-        setVignetteEnd(mVignetteEnd);
+        vignetteCenterLocation = GLES20.glGetUniformLocation(getProgram(), "vignetteCenter");
+        vignetteColorLocation = GLES20.glGetUniformLocation(getProgram(), "vignetteColor");
+        vignetteStartLocation = GLES20.glGetUniformLocation(getProgram(), "vignetteStart");
+        vignetteEndLocation = GLES20.glGetUniformLocation(getProgram(), "vignetteEnd");
     }
 
+    @Override
+    public void onInitialized() {
+        super.onInitialized();
+        setVignetteCenter(vignetteCenter);
+        setVignetteColor(vignetteColor);
+        setVignetteStart(vignetteStart);
+        setVignetteEnd(vignetteEnd);
+    }
 
     public void setVignetteCenter(final PointF vignetteCenter) {
-        mVignetteCenter = vignetteCenter;
-        setPoint(mVignetteCenterLocation, mVignetteCenter);
+        this.vignetteCenter = vignetteCenter;
+        setPoint(vignetteCenterLocation, this.vignetteCenter);
     }
 
     public void setVignetteColor(final float[] vignetteColor) {
-        mVignetteColor = vignetteColor;
-        setFloatVec3(mVignetteColorLocation, mVignetteColor);
+        this.vignetteColor = vignetteColor;
+        setFloatVec3(vignetteColorLocation, this.vignetteColor);
     }
-    
+
     public void setVignetteStart(final float vignetteStart) {
-        mVignetteStart = vignetteStart;
-        setFloat(mVignetteStartLocation, mVignetteStart);
+        this.vignetteStart = vignetteStart;
+        setFloat(vignetteStartLocation, this.vignetteStart);
     }
-    
+
     public void setVignetteEnd(final float vignetteEnd) {
-        mVignetteEnd = vignetteEnd;
-        setFloat(mVignetteEndLocation, mVignetteEnd);
+        this.vignetteEnd = vignetteEnd;
+        setFloat(vignetteEndLocation, this.vignetteEnd);
     }
 }
diff --git a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageWeakPixelInclusionFilter.java b/library/src/main/java/jp/co/cyberagent/android/gpuimage/filter/GPUImageWeakPixelInclusionFilter.java
similarity index 97%
rename from library/src/jp/co/cyberagent/android/gpuimage/GPUImageWeakPixelInclusionFilter.java
rename to library/src/main/java/jp/co/cyberagent/android/gpuimage/filter/GPUImageWeakPixelInclusionFilter.java
index 3e1b8f01..3dbcc999 100644
--- a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageWeakPixelInclusionFilter.java
+++ b/library/src/main/java/jp/co/cyberagent/android/gpuimage/filter/GPUImageWeakPixelInclusionFilter.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2012 CyberAgent
+ * Copyright (C) 2018 CyberAgent, Inc.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -14,7 +14,7 @@
  * limitations under the License.
  */
 
-package jp.co.cyberagent.android.gpuimage;
+package jp.co.cyberagent.android.gpuimage.filter;
 
 public class GPUImageWeakPixelInclusionFilter extends GPUImage3x3TextureSamplingFilter {
     public static final String WEAKPIXEL_FRAGMENT_SHADER = "" +
diff --git a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageWhiteBalanceFilter.java b/library/src/main/java/jp/co/cyberagent/android/gpuimage/filter/GPUImageWhiteBalanceFilter.java
similarity index 75%
rename from library/src/jp/co/cyberagent/android/gpuimage/GPUImageWhiteBalanceFilter.java
rename to library/src/main/java/jp/co/cyberagent/android/gpuimage/filter/GPUImageWhiteBalanceFilter.java
index 1818da99..8bb20252 100644
--- a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageWhiteBalanceFilter.java
+++ b/library/src/main/java/jp/co/cyberagent/android/gpuimage/filter/GPUImageWhiteBalanceFilter.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2012 CyberAgent
+ * Copyright (C) 2018 CyberAgent, Inc.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -14,14 +14,14 @@
  * limitations under the License.
  */
 
-package jp.co.cyberagent.android.gpuimage;
+package jp.co.cyberagent.android.gpuimage.filter;
 
 import android.opengl.GLES20;
 
 /**
  * Adjusts the white balance of incoming image. <br>
  * <br>
- * temperature: 
+ * temperature:
  * tint:
  */
 public class GPUImageWhiteBalanceFilter extends GPUImageFilter {
@@ -53,39 +53,42 @@
             "	gl_FragColor = vec4(mix(rgb, processed, temperature), source.a);\n" +
             "}";
 
-    private int mTemperatureLocation;
-    private float mTemperature;
-    private int mTintLocation;
-    private float mTint;
+    private int temperatureLocation;
+    private float temperature;
+    private int tintLocation;
+    private float tint;
 
     public GPUImageWhiteBalanceFilter() {
         this(5000.0f, 0.0f);
     }
-    
+
     public GPUImageWhiteBalanceFilter(final float temperature, final float tint) {
         super(NO_FILTER_VERTEX_SHADER, WHITE_BALANCE_FRAGMENT_SHADER);
-        mTemperature = temperature;
-        mTint = tint;
+        this.temperature = temperature;
+        this.tint = tint;
     }
 
     @Override
     public void onInit() {
         super.onInit();
-        mTemperatureLocation = GLES20.glGetUniformLocation(getProgram(), "temperature");
-        mTintLocation = GLES20.glGetUniformLocation(getProgram(), "tint");
-
-        setTemperature(mTemperature);
-        setTint(mTint);
+        temperatureLocation = GLES20.glGetUniformLocation(getProgram(), "temperature");
+        tintLocation = GLES20.glGetUniformLocation(getProgram(), "tint");
     }
 
+    @Override
+    public void onInitialized() {
+        super.onInitialized();
+        setTemperature(temperature);
+        setTint(tint);
+    }
 
     public void setTemperature(final float temperature) {
-        mTemperature = temperature;
-        setFloat(mTemperatureLocation, mTemperature < 5000 ? (float)(0.0004 * (mTemperature-5000.0)) : (float)(0.00006 * (mTemperature-5000.0)));
+        this.temperature = temperature;
+        setFloat(temperatureLocation, this.temperature < 5000 ? (float) (0.0004 * (this.temperature - 5000.0)) : (float) (0.00006 * (this.temperature - 5000.0)));
     }
-    
+
     public void setTint(final float tint) {
-        mTint = tint;
-        setFloat(mTintLocation, (float)(mTint/100.0));
+        this.tint = tint;
+        setFloat(tintLocation, (float) (this.tint / 100.0));
     }
 }
diff --git a/library/src/jp/co/cyberagent/android/gpuimage/OpenGlUtils.java b/library/src/main/java/jp/co/cyberagent/android/gpuimage/util/OpenGlUtils.java
similarity index 94%
rename from library/src/jp/co/cyberagent/android/gpuimage/OpenGlUtils.java
rename to library/src/main/java/jp/co/cyberagent/android/gpuimage/util/OpenGlUtils.java
index e8589704..efb810a8 100644
--- a/library/src/jp/co/cyberagent/android/gpuimage/OpenGlUtils.java
+++ b/library/src/main/java/jp/co/cyberagent/android/gpuimage/util/OpenGlUtils.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2012 CyberAgent
+ * Copyright (C) 2018 CyberAgent, Inc.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -14,9 +14,7 @@
  * limitations under the License.
  */
 
-package jp.co.cyberagent.android.gpuimage;
-
-import java.nio.IntBuffer;
+package jp.co.cyberagent.android.gpuimage.util;
 
 import android.graphics.Bitmap;
 import android.graphics.Bitmap.Config;
@@ -25,6 +23,8 @@
 import android.opengl.GLUtils;
 import android.util.Log;
 
+import java.nio.IntBuffer;
+
 public class OpenGlUtils {
     public static final int NO_TEXTURE = -1;
 
@@ -58,7 +58,7 @@ public static int loadTexture(final Bitmap img, final int usedTexId, final boole
         return textures[0];
     }
 
-    public static int loadTexture(final IntBuffer data, final Size size, final int usedTexId) {
+    public static int loadTexture(final IntBuffer data, final int width, final int height, final int usedTexId) {
         int textures[] = new int[1];
         if (usedTexId == NO_TEXTURE) {
             GLES20.glGenTextures(1, textures, 0);
@@ -71,12 +71,12 @@ public static int loadTexture(final IntBuffer data, final Size size, final int u
                     GLES20.GL_TEXTURE_WRAP_S, GLES20.GL_CLAMP_TO_EDGE);
             GLES20.glTexParameterf(GLES20.GL_TEXTURE_2D,
                     GLES20.GL_TEXTURE_WRAP_T, GLES20.GL_CLAMP_TO_EDGE);
-            GLES20.glTexImage2D(GLES20.GL_TEXTURE_2D, 0, GLES20.GL_RGBA, size.width, size.height,
+            GLES20.glTexImage2D(GLES20.GL_TEXTURE_2D, 0, GLES20.GL_RGBA, width, height,
                     0, GLES20.GL_RGBA, GLES20.GL_UNSIGNED_BYTE, data);
         } else {
             GLES20.glBindTexture(GLES20.GL_TEXTURE_2D, usedTexId);
-            GLES20.glTexSubImage2D(GLES20.GL_TEXTURE_2D, 0, 0, 0, size.width,
-                    size.height, GLES20.GL_RGBA, GLES20.GL_UNSIGNED_BYTE, data);
+            GLES20.glTexSubImage2D(GLES20.GL_TEXTURE_2D, 0, 0, 0, width,
+                    height, GLES20.GL_RGBA, GLES20.GL_UNSIGNED_BYTE, data);
             textures[0] = usedTexId;
         }
         return textures[0];
diff --git a/library/src/jp/co/cyberagent/android/gpuimage/Rotation.java b/library/src/main/java/jp/co/cyberagent/android/gpuimage/util/Rotation.java
similarity index 56%
rename from library/src/jp/co/cyberagent/android/gpuimage/Rotation.java
rename to library/src/main/java/jp/co/cyberagent/android/gpuimage/util/Rotation.java
index bd2e840e..bfc6d900 100644
--- a/library/src/jp/co/cyberagent/android/gpuimage/Rotation.java
+++ b/library/src/main/java/jp/co/cyberagent/android/gpuimage/util/Rotation.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2012 CyberAgent
+ * Copyright (C) 2018 CyberAgent, Inc.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -14,7 +14,7 @@
  * limitations under the License.
  */
 
-package jp.co.cyberagent.android.gpuimage;
+package jp.co.cyberagent.android.gpuimage.util;
 
 public enum Rotation {
     NORMAL, ROTATION_90, ROTATION_180, ROTATION_270;
@@ -26,11 +26,16 @@
      */
     public int asInt() {
         switch (this) {
-            case NORMAL: return 0;
-            case ROTATION_90: return 90;
-            case ROTATION_180: return 180;
-            case ROTATION_270: return 270;
-            default: throw new IllegalStateException("Unknown Rotation!");
+            case NORMAL:
+                return 0;
+            case ROTATION_90:
+                return 90;
+            case ROTATION_180:
+                return 180;
+            case ROTATION_270:
+                return 270;
+            default:
+                throw new IllegalStateException("Unknown Rotation!");
         }
     }
 
@@ -42,13 +47,19 @@ public int asInt() {
      */
     public static Rotation fromInt(int rotation) {
         switch (rotation) {
-            case 0: return NORMAL;
-            case 90: return ROTATION_90;
-            case 180: return ROTATION_180;
-            case 270: return ROTATION_270;
-            case 360: return NORMAL;
-            default: throw new IllegalStateException(
-                    rotation + " is an unknown rotation. Needs to be either 0, 90, 180 or 270!");
+            case 0:
+                return NORMAL;
+            case 90:
+                return ROTATION_90;
+            case 180:
+                return ROTATION_180;
+            case 270:
+                return ROTATION_270;
+            case 360:
+                return NORMAL;
+            default:
+                throw new IllegalStateException(
+                        rotation + " is an unknown rotation. Needs to be either 0, 90, 180 or 270!");
         }
     }
 }
diff --git a/library/src/jp/co/cyberagent/android/gpuimage/util/TextureRotationUtil.java b/library/src/main/java/jp/co/cyberagent/android/gpuimage/util/TextureRotationUtil.java
similarity index 94%
rename from library/src/jp/co/cyberagent/android/gpuimage/util/TextureRotationUtil.java
rename to library/src/main/java/jp/co/cyberagent/android/gpuimage/util/TextureRotationUtil.java
index c439d914..53c42e75 100644
--- a/library/src/jp/co/cyberagent/android/gpuimage/util/TextureRotationUtil.java
+++ b/library/src/main/java/jp/co/cyberagent/android/gpuimage/util/TextureRotationUtil.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2012 CyberAgent
+ * Copyright (C) 2018 CyberAgent, Inc.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -16,8 +16,6 @@
 
 package jp.co.cyberagent.android.gpuimage.util;
 
-import jp.co.cyberagent.android.gpuimage.Rotation;
-
 public class TextureRotationUtil {
 
     public static final float TEXTURE_NO_ROTATION[] = {
@@ -50,7 +48,7 @@ private TextureRotationUtil() {
     }
 
     public static float[] getRotation(final Rotation rotation, final boolean flipHorizontal,
-                                                         final boolean flipVertical) {
+                                      final boolean flipVertical) {
         float[] rotatedTex;
         switch (rotation) {
             case ROTATION_90:
diff --git a/library/src/main/res/values/attrs.xml b/library/src/main/res/values/attrs.xml
new file mode 100644
index 00000000..f8cf91d1
--- /dev/null
+++ b/library/src/main/res/values/attrs.xml
@@ -0,0 +1,10 @@
+<?xml version="1.0" encoding="utf-8"?>
+<resources>
+    <declare-styleable name="GPUImageView">
+        <attr name="gpuimage_surface_type" format="enum">
+            <enum name="surface_view" value="0" />
+            <enum name="texture_view" value="1" />
+        </attr>
+        <attr name="gpuimage_show_loading" format="boolean"/>
+    </declare-styleable>
+</resources>
\ No newline at end of file
diff --git a/sample/build.gradle b/sample/build.gradle
index f64f4a42..eaa6c3a7 100644
--- a/sample/build.gradle
+++ b/sample/build.gradle
@@ -1,39 +1,36 @@
 apply plugin: 'com.android.application'
+apply plugin: 'kotlin-android-extensions'
+apply plugin: 'kotlin-android'
 
 android {
     compileSdkVersion COMPILE_SDK_VERSION as int
-    buildToolsVersion BUILD_TOOLS_VERSION
 
     defaultConfig {
         minSdkVersion MIN_SDK_VERSION as int
         targetSdkVersion TARGET_SDK_VERSION as int
     }
 
-    sourceSets {
-        main {
-            manifest.srcFile 'AndroidManifest.xml'
-            java.srcDirs = ['src']
-            resources.srcDirs = ['src']
-            aidl.srcDirs = ['src']
-            renderscript.srcDirs = ['src']
-            res.srcDirs = ['res']
-            assets.srcDirs = ['assets']
+    buildTypes {
+        debug {
+            debuggable true
+        }
+        release {
+            debuggable false
+            zipAlignEnabled true
+            minifyEnabled true
+            shrinkResources true
+            proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro'
         }
-
-        instrumentTest.setRoot('tests')
-    }
-
-    lintOptions {
-        abortOnError true
     }
 }
 repositories {
+    google()
     jcenter()
-    maven { url "https://oss.sonatype.org/content/repositories/snapshots/" }
+//    maven { url  "https://dl.bintray.com/cats-oss/maven" }
 }
 
 dependencies {
-    compile project(':library')
-//    compile 'jp.co.cyberagent.android.gpuimage:gpuimage-library:1.4.1'
-    compile 'com.android.support:support-v4:23.1.1'
+    implementation project(':library')
+    implementation 'androidx.appcompat:appcompat:1.0.0'
+    implementation "org.jetbrains.kotlin:kotlin-stdlib-jdk7:$kotlin_version"
 }
\ No newline at end of file
diff --git a/sample/ic_launcher-web.png b/sample/ic_launcher-web.png
deleted file mode 100644
index 817b96c1..00000000
Binary files a/sample/ic_launcher-web.png and /dev/null differ
diff --git a/sample/project.properties b/sample/project.properties
deleted file mode 100644
index 24e0cbf3..00000000
--- a/sample/project.properties
+++ /dev/null
@@ -1,16 +0,0 @@
-# This file is automatically generated by Android Tools.
-# Do not modify this file -- YOUR CHANGES WILL BE ERASED!
-#
-# This file must be checked in Version Control Systems.
-#
-# To customize properties used by the Ant build system edit
-# "ant.properties", and override values to adapt the script to your
-# project structure.
-#
-# To enable ProGuard to shrink and obfuscate your code, uncomment this (available properties: sdk.dir, user.home):
-#proguard.config=${sdk.dir}/tools/proguard/proguard-android.txt:proguard-project.txt
-
-# Project target.
-target=android-16
-proguard.config=${sdk.dir}/tools/proguard/proguard-android.txt:proguard-project.txt
-android.library.reference.1=../library
\ No newline at end of file
diff --git a/sample/res/drawable-hdpi/ic_launcher.png b/sample/res/drawable-hdpi/ic_launcher.png
deleted file mode 100644
index 301100c3..00000000
Binary files a/sample/res/drawable-hdpi/ic_launcher.png and /dev/null differ
diff --git a/sample/res/drawable-ldpi/ic_launcher.png b/sample/res/drawable-ldpi/ic_launcher.png
deleted file mode 100644
index 6e1bfd53..00000000
Binary files a/sample/res/drawable-ldpi/ic_launcher.png and /dev/null differ
diff --git a/sample/res/drawable-mdpi/ic_launcher.png b/sample/res/drawable-mdpi/ic_launcher.png
deleted file mode 100644
index 372e87fb..00000000
Binary files a/sample/res/drawable-mdpi/ic_launcher.png and /dev/null differ
diff --git a/sample/res/drawable-xhdpi/ic_launcher.png b/sample/res/drawable-xhdpi/ic_launcher.png
deleted file mode 100644
index d9de8e01..00000000
Binary files a/sample/res/drawable-xhdpi/ic_launcher.png and /dev/null differ
diff --git a/sample/res/values-v11/styles.xml b/sample/res/values-v11/styles.xml
deleted file mode 100644
index d408cbc3..00000000
--- a/sample/res/values-v11/styles.xml
+++ /dev/null
@@ -1,5 +0,0 @@
-<resources>
-
-    <style name="AppTheme" parent="android:Theme.Holo.Light" />
-
-</resources>
\ No newline at end of file
diff --git a/sample/res/values-v14/styles.xml b/sample/res/values-v14/styles.xml
deleted file mode 100644
index b76ce151..00000000
--- a/sample/res/values-v14/styles.xml
+++ /dev/null
@@ -1,6 +0,0 @@
-<resources>
-
-    <style name="AppTheme" parent="android:Theme.Holo.Light.DarkActionBar" />
-    <style name="AppTheme.Fullscreen" parent="android:Theme.Holo.Light.NoActionBar.Fullscreen" />
-
-</resources>
\ No newline at end of file
diff --git a/sample/res/values/styles.xml b/sample/res/values/styles.xml
deleted file mode 100644
index 85b0de23..00000000
--- a/sample/res/values/styles.xml
+++ /dev/null
@@ -1,6 +0,0 @@
-<resources>
-
-    <style name="AppTheme" parent="android:Theme.Light" />
-    <style name="AppTheme.NoActionBar" parent="android:Theme.Light.NoTitleBar.Fullscreen" />
-
-</resources>
\ No newline at end of file
diff --git a/sample/src/jp/co/cyberagent/android/gpuimage/sample/GPUImageFilterTools.java b/sample/src/jp/co/cyberagent/android/gpuimage/sample/GPUImageFilterTools.java
deleted file mode 100644
index 6f2f6dd4..00000000
--- a/sample/src/jp/co/cyberagent/android/gpuimage/sample/GPUImageFilterTools.java
+++ /dev/null
@@ -1,686 +0,0 @@
-/*
- * Copyright (C) 2012 CyberAgent
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package jp.co.cyberagent.android.gpuimage.sample;
-
-import android.app.AlertDialog;
-import android.content.Context;
-import android.content.DialogInterface;
-import android.graphics.BitmapFactory;
-import android.graphics.PointF;
-import android.opengl.Matrix;
-
-import jp.co.cyberagent.android.gpuimage.*;
-
-import java.util.LinkedList;
-import java.util.List;
-
-public class GPUImageFilterTools {
-    public static void showDialog(final Context context,
-            final OnGpuImageFilterChosenListener listener) {
-        final FilterList filters = new FilterList();
-        filters.addFilter("Contrast", FilterType.CONTRAST);
-        filters.addFilter("Invert", FilterType.INVERT);
-        filters.addFilter("Pixelation", FilterType.PIXELATION);
-        filters.addFilter("Hue", FilterType.HUE);
-        filters.addFilter("Gamma", FilterType.GAMMA);
-        filters.addFilter("Brightness", FilterType.BRIGHTNESS);
-        filters.addFilter("Sepia", FilterType.SEPIA);
-        filters.addFilter("Grayscale", FilterType.GRAYSCALE);
-        filters.addFilter("Sharpness", FilterType.SHARPEN);
-        filters.addFilter("Sobel Edge Detection", FilterType.SOBEL_EDGE_DETECTION);
-        filters.addFilter("3x3 Convolution", FilterType.THREE_X_THREE_CONVOLUTION);
-        filters.addFilter("Emboss", FilterType.EMBOSS);
-        filters.addFilter("Posterize", FilterType.POSTERIZE);
-        filters.addFilter("Grouped filters", FilterType.FILTER_GROUP);
-        filters.addFilter("Saturation", FilterType.SATURATION);
-        filters.addFilter("Exposure", FilterType.EXPOSURE);
-        filters.addFilter("Highlight Shadow", FilterType.HIGHLIGHT_SHADOW);
-        filters.addFilter("Monochrome", FilterType.MONOCHROME);
-        filters.addFilter("Opacity", FilterType.OPACITY);
-        filters.addFilter("RGB", FilterType.RGB);
-        filters.addFilter("White Balance", FilterType.WHITE_BALANCE);
-        filters.addFilter("Vignette", FilterType.VIGNETTE);
-        filters.addFilter("ToneCurve", FilterType.TONE_CURVE);
-
-        filters.addFilter("Blend (Difference)", FilterType.BLEND_DIFFERENCE);
-        filters.addFilter("Blend (Source Over)", FilterType.BLEND_SOURCE_OVER);
-        filters.addFilter("Blend (Color Burn)", FilterType.BLEND_COLOR_BURN);
-        filters.addFilter("Blend (Color Dodge)", FilterType.BLEND_COLOR_DODGE);
-        filters.addFilter("Blend (Darken)", FilterType.BLEND_DARKEN);
-        filters.addFilter("Blend (Dissolve)", FilterType.BLEND_DISSOLVE);
-        filters.addFilter("Blend (Exclusion)", FilterType.BLEND_EXCLUSION);
-        filters.addFilter("Blend (Hard Light)", FilterType.BLEND_HARD_LIGHT);
-        filters.addFilter("Blend (Lighten)", FilterType.BLEND_LIGHTEN);
-        filters.addFilter("Blend (Add)", FilterType.BLEND_ADD);
-        filters.addFilter("Blend (Divide)", FilterType.BLEND_DIVIDE);
-        filters.addFilter("Blend (Multiply)", FilterType.BLEND_MULTIPLY);
-        filters.addFilter("Blend (Overlay)", FilterType.BLEND_OVERLAY);
-        filters.addFilter("Blend (Screen)", FilterType.BLEND_SCREEN);
-        filters.addFilter("Blend (Alpha)", FilterType.BLEND_ALPHA);
-        filters.addFilter("Blend (Color)", FilterType.BLEND_COLOR);
-        filters.addFilter("Blend (Hue)", FilterType.BLEND_HUE);
-        filters.addFilter("Blend (Saturation)", FilterType.BLEND_SATURATION);
-        filters.addFilter("Blend (Luminosity)", FilterType.BLEND_LUMINOSITY);
-        filters.addFilter("Blend (Linear Burn)", FilterType.BLEND_LINEAR_BURN);
-        filters.addFilter("Blend (Soft Light)", FilterType.BLEND_SOFT_LIGHT);
-        filters.addFilter("Blend (Subtract)", FilterType.BLEND_SUBTRACT);
-        filters.addFilter("Blend (Chroma Key)", FilterType.BLEND_CHROMA_KEY);
-        filters.addFilter("Blend (Normal)", FilterType.BLEND_NORMAL);
-
-        filters.addFilter("Lookup (Amatorka)", FilterType.LOOKUP_AMATORKA);
-        filters.addFilter("Gaussian Blur", FilterType.GAUSSIAN_BLUR);
-        filters.addFilter("Crosshatch", FilterType.CROSSHATCH);
-
-        filters.addFilter("Box Blur", FilterType.BOX_BLUR);
-        filters.addFilter("CGA Color Space", FilterType.CGA_COLORSPACE);
-        filters.addFilter("Dilation", FilterType.DILATION);
-        filters.addFilter("Kuwahara", FilterType.KUWAHARA);
-        filters.addFilter("RGB Dilation", FilterType.RGB_DILATION);
-        filters.addFilter("Sketch", FilterType.SKETCH);
-        filters.addFilter("Toon", FilterType.TOON);
-        filters.addFilter("Smooth Toon", FilterType.SMOOTH_TOON);
-        filters.addFilter("Halftone", FilterType.HALFTONE);
-
-        filters.addFilter("Bulge Distortion", FilterType.BULGE_DISTORTION);
-        filters.addFilter("Glass Sphere", FilterType.GLASS_SPHERE);
-        filters.addFilter("Haze", FilterType.HAZE);
-        filters.addFilter("Laplacian", FilterType.LAPLACIAN);
-        filters.addFilter("Non Maximum Suppression", FilterType.NON_MAXIMUM_SUPPRESSION);
-        filters.addFilter("Sphere Refraction", FilterType.SPHERE_REFRACTION);
-        filters.addFilter("Swirl", FilterType.SWIRL);
-        filters.addFilter("Weak Pixel Inclusion", FilterType.WEAK_PIXEL_INCLUSION);
-        filters.addFilter("False Color", FilterType.FALSE_COLOR);
-
-        filters.addFilter("Color Balance", FilterType.COLOR_BALANCE);
-
-        filters.addFilter("Levels Min (Mid Adjust)", FilterType.LEVELS_FILTER_MIN);
-
-        filters. addFilter("Bilateral Blur", FilterType.BILATERAL_BLUR);
-
-        filters.addFilter("Transform (2-D)", FilterType.TRANSFORM2D);
-
-
-        AlertDialog.Builder builder = new AlertDialog.Builder(context);
-        builder.setTitle("Choose a filter");
-        builder.setItems(filters.names.toArray(new String[filters.names.size()]),
-                new DialogInterface.OnClickListener() {
-                    @Override
-                    public void onClick(final DialogInterface dialog, final int item) {
-                        listener.onGpuImageFilterChosenListener(
-                                createFilterForType(context, filters.filters.get(item)));
-                    }
-                });
-        builder.create().show();
-    }
-
-    private static GPUImageFilter createFilterForType(final Context context, final FilterType type) {
-        switch (type) {
-            case CONTRAST:
-                return new GPUImageContrastFilter(2.0f);
-            case GAMMA:
-                return new GPUImageGammaFilter(2.0f);
-            case INVERT:
-                return new GPUImageColorInvertFilter();
-            case PIXELATION:
-                return new GPUImagePixelationFilter();
-            case HUE:
-                return new GPUImageHueFilter(90.0f);
-            case BRIGHTNESS:
-                return new GPUImageBrightnessFilter(1.5f);
-            case GRAYSCALE:
-                return new GPUImageGrayscaleFilter();
-            case SEPIA:
-                return new GPUImageSepiaFilter();
-            case SHARPEN:
-                GPUImageSharpenFilter sharpness = new GPUImageSharpenFilter();
-                sharpness.setSharpness(2.0f);
-                return sharpness;
-            case SOBEL_EDGE_DETECTION:
-                return new GPUImageSobelEdgeDetection();
-            case THREE_X_THREE_CONVOLUTION:
-                GPUImage3x3ConvolutionFilter convolution = new GPUImage3x3ConvolutionFilter();
-                convolution.setConvolutionKernel(new float[] {
-                        -1.0f, 0.0f, 1.0f,
-                        -2.0f, 0.0f, 2.0f,
-                        -1.0f, 0.0f, 1.0f
-                });
-                return convolution;
-            case EMBOSS:
-                return new GPUImageEmbossFilter();
-            case POSTERIZE:
-                return new GPUImagePosterizeFilter();
-            case FILTER_GROUP:
-                List<GPUImageFilter> filters = new LinkedList<GPUImageFilter>();
-                filters.add(new GPUImageContrastFilter());
-                filters.add(new GPUImageDirectionalSobelEdgeDetectionFilter());
-                filters.add(new GPUImageGrayscaleFilter());
-                return new GPUImageFilterGroup(filters);
-            case SATURATION:
-                return new GPUImageSaturationFilter(1.0f);
-            case EXPOSURE:
-                return new GPUImageExposureFilter(0.0f);
-            case HIGHLIGHT_SHADOW:
-            	return new GPUImageHighlightShadowFilter(0.0f, 1.0f);
-            case MONOCHROME:
-            	return new GPUImageMonochromeFilter(1.0f, new float[]{0.6f, 0.45f, 0.3f, 1.0f});
-            case OPACITY:
-                return new GPUImageOpacityFilter(1.0f);
-            case RGB:
-                return new GPUImageRGBFilter(1.0f, 1.0f, 1.0f);
-            case WHITE_BALANCE:
-                return new GPUImageWhiteBalanceFilter(5000.0f, 0.0f);
-            case VIGNETTE:
-                PointF centerPoint = new PointF();
-                centerPoint.x = 0.5f;
-                centerPoint.y = 0.5f;
-                return new GPUImageVignetteFilter(centerPoint, new float[] {0.0f, 0.0f, 0.0f}, 0.3f, 0.75f);
-            case TONE_CURVE:
-                GPUImageToneCurveFilter toneCurveFilter = new GPUImageToneCurveFilter();
-                toneCurveFilter.setFromCurveFileInputStream(
-                        context.getResources().openRawResource(R.raw.tone_cuver_sample));
-                return toneCurveFilter;
-            case BLEND_DIFFERENCE:
-                return createBlendFilter(context, GPUImageDifferenceBlendFilter.class);
-            case BLEND_SOURCE_OVER:
-                return createBlendFilter(context, GPUImageSourceOverBlendFilter.class);
-            case BLEND_COLOR_BURN:
-                return createBlendFilter(context, GPUImageColorBurnBlendFilter.class);
-            case BLEND_COLOR_DODGE:
-                return createBlendFilter(context, GPUImageColorDodgeBlendFilter.class);
-            case BLEND_DARKEN:
-                return createBlendFilter(context, GPUImageDarkenBlendFilter.class);
-            case BLEND_DISSOLVE:
-                return createBlendFilter(context, GPUImageDissolveBlendFilter.class);
-            case BLEND_EXCLUSION:
-                return createBlendFilter(context, GPUImageExclusionBlendFilter.class);
-
-
-            case BLEND_HARD_LIGHT:
-                return createBlendFilter(context, GPUImageHardLightBlendFilter.class);
-            case BLEND_LIGHTEN:
-                return createBlendFilter(context, GPUImageLightenBlendFilter.class);
-            case BLEND_ADD:
-                return createBlendFilter(context, GPUImageAddBlendFilter.class);
-            case BLEND_DIVIDE:
-                return createBlendFilter(context, GPUImageDivideBlendFilter.class);
-            case BLEND_MULTIPLY:
-                return createBlendFilter(context, GPUImageMultiplyBlendFilter.class);
-            case BLEND_OVERLAY:
-                return createBlendFilter(context, GPUImageOverlayBlendFilter.class);
-            case BLEND_SCREEN:
-                return createBlendFilter(context, GPUImageScreenBlendFilter.class);
-            case BLEND_ALPHA:
-                return createBlendFilter(context, GPUImageAlphaBlendFilter.class);
-            case BLEND_COLOR:
-                return createBlendFilter(context, GPUImageColorBlendFilter.class);
-            case BLEND_HUE:
-                return createBlendFilter(context, GPUImageHueBlendFilter.class);
-            case BLEND_SATURATION:
-                return createBlendFilter(context, GPUImageSaturationBlendFilter.class);
-            case BLEND_LUMINOSITY:
-                return createBlendFilter(context, GPUImageLuminosityBlendFilter.class);
-            case BLEND_LINEAR_BURN:
-                return createBlendFilter(context, GPUImageLinearBurnBlendFilter.class);
-            case BLEND_SOFT_LIGHT:
-                return createBlendFilter(context, GPUImageSoftLightBlendFilter.class);
-            case BLEND_SUBTRACT:
-                return createBlendFilter(context, GPUImageSubtractBlendFilter.class);
-            case BLEND_CHROMA_KEY:
-                return createBlendFilter(context, GPUImageChromaKeyBlendFilter.class);
-            case BLEND_NORMAL:
-                return createBlendFilter(context, GPUImageNormalBlendFilter.class);
-
-            case LOOKUP_AMATORKA:
-                GPUImageLookupFilter amatorka = new GPUImageLookupFilter();
-                amatorka.setBitmap(BitmapFactory.decodeResource(context.getResources(), R.drawable.lookup_amatorka));
-                return amatorka;
-            case GAUSSIAN_BLUR:
-                return new GPUImageGaussianBlurFilter();
-            case CROSSHATCH:
-                return new GPUImageCrosshatchFilter();
-
-            case BOX_BLUR:
-                return new GPUImageBoxBlurFilter();
-            case CGA_COLORSPACE:
-                return new GPUImageCGAColorspaceFilter();
-            case DILATION:
-                return new GPUImageDilationFilter();
-            case KUWAHARA:
-                return new GPUImageKuwaharaFilter();
-            case RGB_DILATION:
-                return new GPUImageRGBDilationFilter();
-            case SKETCH:
-                return new GPUImageSketchFilter();
-            case TOON:
-                return new GPUImageToonFilter();
-            case SMOOTH_TOON:
-                return new GPUImageSmoothToonFilter();
-
-            case BULGE_DISTORTION:
-                return new GPUImageBulgeDistortionFilter();
-            case GLASS_SPHERE:
-                return new GPUImageGlassSphereFilter();
-            case HAZE:
-                return new GPUImageHazeFilter();
-            case LAPLACIAN:
-                return new GPUImageLaplacianFilter();
-            case NON_MAXIMUM_SUPPRESSION:
-                return new GPUImageNonMaximumSuppressionFilter();
-            case SPHERE_REFRACTION:
-                return new GPUImageSphereRefractionFilter();
-            case SWIRL:
-                return new GPUImageSwirlFilter();
-            case WEAK_PIXEL_INCLUSION:
-                return new GPUImageWeakPixelInclusionFilter();
-            case FALSE_COLOR:
-                return new GPUImageFalseColorFilter();
-            case COLOR_BALANCE:
-                return new GPUImageColorBalanceFilter();
-            case LEVELS_FILTER_MIN:
-                GPUImageLevelsFilter levelsFilter = new GPUImageLevelsFilter();
-                levelsFilter.setMin(0.0f, 3.0f, 1.0f);
-                return levelsFilter;
-            case HALFTONE:
-                return new GPUImageHalftoneFilter();
-
-            case BILATERAL_BLUR:
-                return new GPUImageBilateralFilter();
-
-            case TRANSFORM2D:
-                return new GPUImageTransformFilter();
-
-            default:
-                throw new IllegalStateException("No filter of that type!");
-        }
-
-    }
-
-    private static GPUImageFilter createBlendFilter(Context context, Class<? extends GPUImageTwoInputFilter> filterClass) {
-        try {
-            GPUImageTwoInputFilter filter = filterClass.newInstance();
-            filter.setBitmap(BitmapFactory.decodeResource(context.getResources(), R.drawable.ic_launcher));
-            return filter;
-        } catch (Exception e) {
-            e.printStackTrace();
-            return null;
-        }
-    }
-
-    public interface OnGpuImageFilterChosenListener {
-        void onGpuImageFilterChosenListener(GPUImageFilter filter);
-    }
-
-    private enum FilterType {
-        CONTRAST, GRAYSCALE, SHARPEN, SEPIA, SOBEL_EDGE_DETECTION, THREE_X_THREE_CONVOLUTION, FILTER_GROUP, EMBOSS, POSTERIZE, GAMMA, BRIGHTNESS, INVERT, HUE, PIXELATION,
-        SATURATION, EXPOSURE, HIGHLIGHT_SHADOW, MONOCHROME, OPACITY, RGB, WHITE_BALANCE, VIGNETTE, TONE_CURVE, BLEND_COLOR_BURN, BLEND_COLOR_DODGE, BLEND_DARKEN, BLEND_DIFFERENCE,
-        BLEND_DISSOLVE, BLEND_EXCLUSION, BLEND_SOURCE_OVER, BLEND_HARD_LIGHT, BLEND_LIGHTEN, BLEND_ADD, BLEND_DIVIDE, BLEND_MULTIPLY, BLEND_OVERLAY, BLEND_SCREEN, BLEND_ALPHA,
-        BLEND_COLOR, BLEND_HUE, BLEND_SATURATION, BLEND_LUMINOSITY, BLEND_LINEAR_BURN, BLEND_SOFT_LIGHT, BLEND_SUBTRACT, BLEND_CHROMA_KEY, BLEND_NORMAL, LOOKUP_AMATORKA,
-        GAUSSIAN_BLUR, CROSSHATCH, BOX_BLUR, CGA_COLORSPACE, DILATION, KUWAHARA, RGB_DILATION, SKETCH, TOON, SMOOTH_TOON, BULGE_DISTORTION, GLASS_SPHERE, HAZE, LAPLACIAN, NON_MAXIMUM_SUPPRESSION,
-        SPHERE_REFRACTION, SWIRL, WEAK_PIXEL_INCLUSION, FALSE_COLOR, COLOR_BALANCE, LEVELS_FILTER_MIN, BILATERAL_BLUR, HALFTONE, TRANSFORM2D
-    }
-
-    private static class FilterList {
-        public List<String> names = new LinkedList<String>();
-        public List<FilterType> filters = new LinkedList<FilterType>();
-
-        public void addFilter(final String name, final FilterType filter) {
-            names.add(name);
-            filters.add(filter);
-        }
-    }
-
-    public static class FilterAdjuster {
-        private final Adjuster<? extends GPUImageFilter> adjuster;
-
-        public FilterAdjuster(final GPUImageFilter filter) {
-            if (filter instanceof GPUImageSharpenFilter) {
-                adjuster = new SharpnessAdjuster().filter(filter);
-            } else if (filter instanceof GPUImageSepiaFilter) {
-                adjuster = new SepiaAdjuster().filter(filter);
-            } else if (filter instanceof GPUImageContrastFilter) {
-                adjuster = new ContrastAdjuster().filter(filter);
-            } else if (filter instanceof GPUImageGammaFilter) {
-                adjuster = new GammaAdjuster().filter(filter);
-            } else if (filter instanceof GPUImageBrightnessFilter) {
-                adjuster = new BrightnessAdjuster().filter(filter);
-            } else if (filter instanceof GPUImageSobelEdgeDetection) {
-                adjuster = new SobelAdjuster().filter(filter);
-            } else if (filter instanceof GPUImageEmbossFilter) {
-                adjuster = new EmbossAdjuster().filter(filter);
-            } else if (filter instanceof GPUImage3x3TextureSamplingFilter) {
-                adjuster = new GPU3x3TextureAdjuster().filter(filter);
-            } else if (filter instanceof GPUImageHueFilter) {
-                adjuster = new HueAdjuster().filter(filter);
-            } else if (filter instanceof GPUImagePosterizeFilter) {
-                adjuster = new PosterizeAdjuster().filter(filter);
-            } else if (filter instanceof GPUImagePixelationFilter) {
-                adjuster = new PixelationAdjuster().filter(filter);
-            } else if (filter instanceof GPUImageSaturationFilter) {
-                adjuster = new SaturationAdjuster().filter(filter);
-            } else if (filter instanceof GPUImageExposureFilter) {
-                adjuster = new ExposureAdjuster().filter(filter);
-            } else if (filter instanceof GPUImageHighlightShadowFilter) {
-                adjuster = new HighlightShadowAdjuster().filter(filter);
-            } else if (filter instanceof GPUImageMonochromeFilter) {
-                adjuster = new MonochromeAdjuster().filter(filter);
-            } else if (filter instanceof GPUImageOpacityFilter) {
-                adjuster = new OpacityAdjuster().filter(filter);
-            } else if (filter instanceof GPUImageRGBFilter) {
-                adjuster = new RGBAdjuster().filter(filter);
-            } else if (filter instanceof GPUImageWhiteBalanceFilter) {
-                adjuster = new WhiteBalanceAdjuster().filter(filter);
-            } else if (filter instanceof GPUImageVignetteFilter) {
-                adjuster = new VignetteAdjuster().filter(filter);
-            } else if (filter instanceof GPUImageDissolveBlendFilter) {
-                adjuster = new DissolveBlendAdjuster().filter(filter);
-            } else if (filter instanceof GPUImageGaussianBlurFilter) {
-                adjuster = new GaussianBlurAdjuster().filter(filter);
-            } else if (filter instanceof GPUImageCrosshatchFilter) {
-                adjuster = new CrosshatchBlurAdjuster().filter(filter);
-            } else if (filter instanceof GPUImageBulgeDistortionFilter) {
-                adjuster = new BulgeDistortionAdjuster().filter(filter);
-            } else if (filter instanceof GPUImageGlassSphereFilter) {
-                adjuster = new GlassSphereAdjuster().filter(filter);
-            } else if (filter instanceof GPUImageHazeFilter) {
-                adjuster = new HazeAdjuster().filter(filter);
-            } else if (filter instanceof GPUImageSphereRefractionFilter) {
-                adjuster = new SphereRefractionAdjuster().filter(filter);
-            } else if (filter instanceof GPUImageSwirlFilter) {
-                adjuster = new SwirlAdjuster().filter(filter);
-            } else if (filter instanceof GPUImageColorBalanceFilter) {
-                adjuster = new ColorBalanceAdjuster().filter(filter);
-            } else if (filter instanceof GPUImageLevelsFilter) {
-                adjuster = new LevelsMinMidAdjuster().filter(filter);
-            } else if (filter instanceof GPUImageBilateralFilter) {
-                adjuster = new BilateralAdjuster().filter(filter);
-            } else if (filter instanceof GPUImageTransformFilter) {
-                adjuster = new RotateAdjuster().filter(filter);
-            }
-            else {
-
-                adjuster = null;
-            }
-        }
-
-        public boolean canAdjust() {
-            return adjuster != null;
-        }
-
-        public void adjust(final int percentage) {
-            if (adjuster != null) {
-                adjuster.adjust(percentage);
-            }
-        }
-
-        private abstract class Adjuster<T extends GPUImageFilter> {
-            private T filter;
-
-            @SuppressWarnings("unchecked")
-            public Adjuster<T> filter(final GPUImageFilter filter) {
-                this.filter = (T) filter;
-                return this;
-            }
-
-            public T getFilter() {
-                return filter;
-            }
-
-            public abstract void adjust(int percentage);
-
-            protected float range(final int percentage, final float start, final float end) {
-                return (end - start) * percentage / 100.0f + start;
-            }
-
-            protected int range(final int percentage, final int start, final int end) {
-                return (end - start) * percentage / 100 + start;
-            }
-        }
-
-        private class SharpnessAdjuster extends Adjuster<GPUImageSharpenFilter> {
-            @Override
-            public void adjust(final int percentage) {
-                getFilter().setSharpness(range(percentage, -4.0f, 4.0f));
-            }
-        }
-
-        private class PixelationAdjuster extends Adjuster<GPUImagePixelationFilter> {
-          @Override
-          public void adjust(final int percentage) {
-              getFilter().setPixel(range(percentage, 1.0f, 100.0f));
-          }
-        }
-
-        private class HueAdjuster extends Adjuster<GPUImageHueFilter> {
-          @Override
-          public void adjust(final int percentage) {
-            getFilter().setHue(range(percentage, 0.0f, 360.0f));
-          }
-        }
-
-        private class ContrastAdjuster extends Adjuster<GPUImageContrastFilter> {
-            @Override
-            public void adjust(final int percentage) {
-                getFilter().setContrast(range(percentage, 0.0f, 2.0f));
-            }
-        }
-
-        private class GammaAdjuster extends Adjuster<GPUImageGammaFilter> {
-            @Override
-            public void adjust(final int percentage) {
-                getFilter().setGamma(range(percentage, 0.0f, 3.0f));
-            }
-        }
-
-        private class BrightnessAdjuster extends Adjuster<GPUImageBrightnessFilter> {
-            @Override
-            public void adjust(final int percentage) {
-                getFilter().setBrightness(range(percentage, -1.0f, 1.0f));
-            }
-        }
-
-        private class SepiaAdjuster extends Adjuster<GPUImageSepiaFilter> {
-            @Override
-            public void adjust(final int percentage) {
-                getFilter().setIntensity(range(percentage, 0.0f, 2.0f));
-            }
-        }
-
-        private class SobelAdjuster extends Adjuster<GPUImageSobelEdgeDetection> {
-            @Override
-            public void adjust(final int percentage) {
-                getFilter().setLineSize(range(percentage, 0.0f, 5.0f));
-            }
-        }
-
-        private class EmbossAdjuster extends Adjuster<GPUImageEmbossFilter> {
-            @Override
-            public void adjust(final int percentage) {
-                getFilter().setIntensity(range(percentage, 0.0f, 4.0f));
-            }
-        }
-
-        private class PosterizeAdjuster extends Adjuster<GPUImagePosterizeFilter> {
-            @Override
-            public void adjust(final int percentage) {
-                // In theorie to 256, but only first 50 are interesting
-                getFilter().setColorLevels(range(percentage, 1, 50));
-            }
-        }
-
-        private class GPU3x3TextureAdjuster extends Adjuster<GPUImage3x3TextureSamplingFilter> {
-            @Override
-            public void adjust(final int percentage) {
-                getFilter().setLineSize(range(percentage, 0.0f, 5.0f));
-            }
-        }
-
-        private class SaturationAdjuster extends Adjuster<GPUImageSaturationFilter> {
-            @Override
-            public void adjust(final int percentage) {
-                getFilter().setSaturation(range(percentage, 0.0f, 2.0f));
-            }
-        }
-
-        private class ExposureAdjuster extends Adjuster<GPUImageExposureFilter> {
-            @Override
-            public void adjust(final int percentage) {
-                getFilter().setExposure(range(percentage, -10.0f, 10.0f));
-            }
-        }
-
-        private class HighlightShadowAdjuster extends Adjuster<GPUImageHighlightShadowFilter> {
-            @Override
-            public void adjust(final int percentage) {
-                getFilter().setShadows(range(percentage, 0.0f, 1.0f));
-                getFilter().setHighlights(range(percentage, 0.0f, 1.0f));
-            }
-        }
-
-        private class MonochromeAdjuster extends Adjuster<GPUImageMonochromeFilter> {
-            @Override
-            public void adjust(final int percentage) {
-                getFilter().setIntensity(range(percentage, 0.0f, 1.0f));
-                //getFilter().setColor(new float[]{0.6f, 0.45f, 0.3f, 1.0f});
-            }
-        }
-
-        private class OpacityAdjuster extends Adjuster<GPUImageOpacityFilter> {
-            @Override
-            public void adjust(final int percentage) {
-                getFilter().setOpacity(range(percentage, 0.0f, 1.0f));
-            }
-        }
-
-        private class RGBAdjuster extends Adjuster<GPUImageRGBFilter> {
-            @Override
-            public void adjust(final int percentage) {
-                getFilter().setRed(range(percentage, 0.0f, 1.0f));
-                //getFilter().setGreen(range(percentage, 0.0f, 1.0f));
-                //getFilter().setBlue(range(percentage, 0.0f, 1.0f));
-            }
-        }
-
-        private class WhiteBalanceAdjuster extends Adjuster<GPUImageWhiteBalanceFilter> {
-            @Override
-            public void adjust(final int percentage) {
-                getFilter().setTemperature(range(percentage, 2000.0f, 8000.0f));
-                //getFilter().setTint(range(percentage, -100.0f, 100.0f));
-            }
-        }
-
-        private class VignetteAdjuster extends Adjuster<GPUImageVignetteFilter> {
-            @Override
-            public void adjust(final int percentage) {
-                getFilter().setVignetteStart(range(percentage, 0.0f, 1.0f));
-            }
-        }
-
-        private class DissolveBlendAdjuster extends Adjuster<GPUImageDissolveBlendFilter> {
-            @Override
-            public void adjust(final int percentage) {
-                getFilter().setMix(range(percentage, 0.0f, 1.0f));
-            }
-        }
-
-        private class GaussianBlurAdjuster extends Adjuster<GPUImageGaussianBlurFilter> {
-            @Override
-            public void adjust(final int percentage) {
-                getFilter().setBlurSize(range(percentage, 0.0f, 1.0f));
-            }
-        }
-
-        private class CrosshatchBlurAdjuster extends Adjuster<GPUImageCrosshatchFilter> {
-            @Override
-            public void adjust(final int percentage) {
-                getFilter().setCrossHatchSpacing(range(percentage, 0.0f, 0.06f));
-                getFilter().setLineWidth(range(percentage, 0.0f, 0.006f));
-            }
-        }
-
-        private class BulgeDistortionAdjuster extends Adjuster<GPUImageBulgeDistortionFilter> {
-            @Override
-            public void adjust(final int percentage) {
-                getFilter().setRadius(range(percentage, 0.0f, 1.0f));
-                getFilter().setScale(range(percentage, -1.0f, 1.0f));
-            }
-        }
-
-        private class GlassSphereAdjuster extends Adjuster<GPUImageGlassSphereFilter> {
-            @Override
-            public void adjust(final int percentage) {
-                getFilter().setRadius(range(percentage, 0.0f, 1.0f));
-            }
-        }
-
-        private class HazeAdjuster extends Adjuster<GPUImageHazeFilter> {
-            @Override
-            public void adjust(final int percentage) {
-                getFilter().setDistance(range(percentage, -0.3f, 0.3f));
-                getFilter().setSlope(range(percentage, -0.3f, 0.3f));
-            }
-        }
-
-        private class SphereRefractionAdjuster extends Adjuster<GPUImageSphereRefractionFilter> {
-            @Override
-            public void adjust(final int percentage) {
-                getFilter().setRadius(range(percentage, 0.0f, 1.0f));
-            }
-        }
-
-        private class SwirlAdjuster extends Adjuster<GPUImageSwirlFilter> {
-            @Override
-            public void adjust(final int percentage) {
-                getFilter().setAngle(range(percentage, 0.0f, 2.0f));
-            }
-        }
-
-        private class ColorBalanceAdjuster extends Adjuster<GPUImageColorBalanceFilter> {
-
-            @Override
-            public void adjust(int percentage) {
-                getFilter().setMidtones(new float[]{
-                        range(percentage, 0.0f, 1.0f),
-                        range(percentage / 2, 0.0f, 1.0f),
-                        range(percentage / 3, 0.0f, 1.0f)});
-            }
-        }
-
-        private class LevelsMinMidAdjuster extends Adjuster<GPUImageLevelsFilter> {
-            @Override
-            public void adjust(int percentage) {
-                getFilter().setMin(0.0f, range(percentage, 0.0f, 1.0f), 1.0f);
-            }
-        }
-
-        private class BilateralAdjuster extends Adjuster<GPUImageBilateralFilter> {
-            @Override
-            public void adjust(final int percentage) {
-                getFilter().setDistanceNormalizationFactor(range(percentage, 0.0f, 15.0f));
-            }
-        }
-
-        private class RotateAdjuster extends Adjuster<GPUImageTransformFilter> {
-            @Override
-            public void adjust(final int percentage) {
-                float[] transform = new float[16];
-                Matrix.setRotateM(transform, 0, 360 * percentage / 100, 0, 0, 1.0f);
-                getFilter().setTransform3D(transform);
-            }
-        }
-
-    }
-}
diff --git a/sample/src/jp/co/cyberagent/android/gpuimage/sample/activity/ActivityCamera.java b/sample/src/jp/co/cyberagent/android/gpuimage/sample/activity/ActivityCamera.java
deleted file mode 100644
index ba832284..00000000
--- a/sample/src/jp/co/cyberagent/android/gpuimage/sample/activity/ActivityCamera.java
+++ /dev/null
@@ -1,295 +0,0 @@
-/*
- * Copyright (C) 2012 CyberAgent
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package jp.co.cyberagent.android.gpuimage.sample.activity;
-
-import android.app.Activity;
-import android.graphics.Bitmap;
-import android.graphics.BitmapFactory;
-import android.hardware.Camera;
-import android.hardware.Camera.CameraInfo;
-import android.hardware.Camera.Parameters;
-import android.net.Uri;
-import android.opengl.GLSurfaceView;
-import android.os.Bundle;
-import android.os.Environment;
-import android.util.Log;
-import android.view.View;
-import android.view.View.OnClickListener;
-import android.widget.SeekBar;
-import android.widget.SeekBar.OnSeekBarChangeListener;
-
-import java.io.File;
-import java.io.FileNotFoundException;
-import java.io.FileOutputStream;
-import java.io.IOException;
-import java.text.SimpleDateFormat;
-import java.util.Date;
-
-import jp.co.cyberagent.android.gpuimage.GPUImage;
-import jp.co.cyberagent.android.gpuimage.GPUImage.OnPictureSavedListener;
-import jp.co.cyberagent.android.gpuimage.GPUImageFilter;
-import jp.co.cyberagent.android.gpuimage.sample.GPUImageFilterTools;
-import jp.co.cyberagent.android.gpuimage.sample.GPUImageFilterTools.FilterAdjuster;
-import jp.co.cyberagent.android.gpuimage.sample.GPUImageFilterTools.OnGpuImageFilterChosenListener;
-import jp.co.cyberagent.android.gpuimage.sample.R;
-import jp.co.cyberagent.android.gpuimage.sample.utils.CameraHelper;
-import jp.co.cyberagent.android.gpuimage.sample.utils.CameraHelper.CameraInfo2;
-
-public class ActivityCamera extends Activity implements OnSeekBarChangeListener, OnClickListener {
-
-    private GPUImage mGPUImage;
-    private CameraHelper mCameraHelper;
-    private CameraLoader mCamera;
-    private GPUImageFilter mFilter;
-    private FilterAdjuster mFilterAdjuster;
-
-    @Override
-    public void onCreate(final Bundle savedInstanceState) {
-        super.onCreate(savedInstanceState);
-        setContentView(R.layout.activity_camera);
-        ((SeekBar) findViewById(R.id.seekBar)).setOnSeekBarChangeListener(this);
-        findViewById(R.id.button_choose_filter).setOnClickListener(this);
-        findViewById(R.id.button_capture).setOnClickListener(this);
-
-        mGPUImage = new GPUImage(this);
-        mGPUImage.setGLSurfaceView((GLSurfaceView) findViewById(R.id.surfaceView));
-
-        mCameraHelper = new CameraHelper(this);
-        mCamera = new CameraLoader();
-
-        View cameraSwitchView = findViewById(R.id.img_switch_camera);
-        cameraSwitchView.setOnClickListener(this);
-        if (!mCameraHelper.hasFrontCamera() || !mCameraHelper.hasBackCamera()) {
-            cameraSwitchView.setVisibility(View.GONE);
-        }
-    }
-
-    @Override
-    protected void onResume() {
-        super.onResume();
-        mCamera.onResume();
-    }
-
-    @Override
-    protected void onPause() {
-        mCamera.onPause();
-        super.onPause();
-    }
-
-    @Override
-    public void onClick(final View v) {
-        switch (v.getId()) {
-            case R.id.button_choose_filter:
-                GPUImageFilterTools.showDialog(this, new OnGpuImageFilterChosenListener() {
-
-                    @Override
-                    public void onGpuImageFilterChosenListener(final GPUImageFilter filter) {
-                        switchFilterTo(filter);
-                    }
-                });
-                break;
-
-            case R.id.button_capture:
-                if (mCamera.mCameraInstance.getParameters().getFocusMode().equals(
-                        Parameters.FOCUS_MODE_CONTINUOUS_PICTURE)) {
-                    takePicture();
-                } else {
-                    mCamera.mCameraInstance.autoFocus(new Camera.AutoFocusCallback() {
-
-                        @Override
-                        public void onAutoFocus(final boolean success, final Camera camera) {
-                            takePicture();
-                        }
-                    });
-                }
-                break;
-
-            case R.id.img_switch_camera:
-                mCamera.switchCamera();
-                break;
-        }
-    }
-
-    private void takePicture() {
-        // TODO get a size that is about the size of the screen
-        Camera.Parameters params = mCamera.mCameraInstance.getParameters();
-        params.setRotation(90);
-        mCamera.mCameraInstance.setParameters(params);
-        for (Camera.Size size : params.getSupportedPictureSizes()) {
-            Log.i("ASDF", "Supported: " + size.width + "x" + size.height);
-        }
-        mCamera.mCameraInstance.takePicture(null, null,
-                new Camera.PictureCallback() {
-
-                    @Override
-                    public void onPictureTaken(byte[] data, final Camera camera) {
-
-                        final File pictureFile = getOutputMediaFile(MEDIA_TYPE_IMAGE);
-                        if (pictureFile == null) {
-                            Log.d("ASDF",
-                                    "Error creating media file, check storage permissions");
-                            return;
-                        }
-
-                        try {
-                            FileOutputStream fos = new FileOutputStream(pictureFile);
-                            fos.write(data);
-                            fos.close();
-                        } catch (FileNotFoundException e) {
-                            Log.d("ASDF", "File not found: " + e.getMessage());
-                        } catch (IOException e) {
-                            Log.d("ASDF", "Error accessing file: " + e.getMessage());
-                        }
-
-                        data = null;
-                        Bitmap bitmap = BitmapFactory.decodeFile(pictureFile.getAbsolutePath());
-                        // mGPUImage.setImage(bitmap);
-                        final GLSurfaceView view = (GLSurfaceView) findViewById(R.id.surfaceView);
-                        view.setRenderMode(GLSurfaceView.RENDERMODE_WHEN_DIRTY);
-                        mGPUImage.saveToPictures(bitmap, "GPUImage",
-                                System.currentTimeMillis() + ".jpg",
-                                new OnPictureSavedListener() {
-
-                                    @Override
-                                    public void onPictureSaved(final Uri
-                                            uri) {
-                                        pictureFile.delete();
-                                        camera.startPreview();
-                                        view.setRenderMode(GLSurfaceView.RENDERMODE_CONTINUOUSLY);
-                                    }
-                                });
-                    }
-                });
-    }
-
-    public static final int MEDIA_TYPE_IMAGE = 1;
-    public static final int MEDIA_TYPE_VIDEO = 2;
-
-    private static File getOutputMediaFile(final int type) {
-        // To be safe, you should check that the SDCard is mounted
-        // using Environment.getExternalStorageState() before doing this.
-
-        File mediaStorageDir = new File(Environment.getExternalStoragePublicDirectory(
-                Environment.DIRECTORY_PICTURES), "MyCameraApp");
-        // This location works best if you want the created images to be shared
-        // between applications and persist after your app has been uninstalled.
-
-        // Create the storage directory if it does not exist
-        if (!mediaStorageDir.exists()) {
-            if (!mediaStorageDir.mkdirs()) {
-                Log.d("MyCameraApp", "failed to create directory");
-                return null;
-            }
-        }
-
-        // Create a media file name
-        String timeStamp = new SimpleDateFormat("yyyyMMdd_HHmmss").format(new Date());
-        File mediaFile;
-        if (type == MEDIA_TYPE_IMAGE) {
-            mediaFile = new File(mediaStorageDir.getPath() + File.separator +
-                    "IMG_" + timeStamp + ".jpg");
-        } else if (type == MEDIA_TYPE_VIDEO) {
-            mediaFile = new File(mediaStorageDir.getPath() + File.separator +
-                    "VID_" + timeStamp + ".mp4");
-        } else {
-            return null;
-        }
-
-        return mediaFile;
-    }
-
-    private void switchFilterTo(final GPUImageFilter filter) {
-        if (mFilter == null
-                || (filter != null && !mFilter.getClass().equals(filter.getClass()))) {
-            mFilter = filter;
-            mGPUImage.setFilter(mFilter);
-            mFilterAdjuster = new FilterAdjuster(mFilter);
-        }
-    }
-
-    @Override
-    public void onProgressChanged(final SeekBar seekBar, final int progress,
-            final boolean fromUser) {
-        if (mFilterAdjuster != null) {
-            mFilterAdjuster.adjust(progress);
-        }
-    }
-
-    @Override
-    public void onStartTrackingTouch(final SeekBar seekBar) {
-    }
-
-    @Override
-    public void onStopTrackingTouch(final SeekBar seekBar) {
-    }
-
-    private class CameraLoader {
-
-        private int mCurrentCameraId = 0;
-        private Camera mCameraInstance;
-
-        public void onResume() {
-            setUpCamera(mCurrentCameraId);
-        }
-
-        public void onPause() {
-            releaseCamera();
-        }
-
-        public void switchCamera() {
-            releaseCamera();
-            mCurrentCameraId = (mCurrentCameraId + 1) % mCameraHelper.getNumberOfCameras();
-            setUpCamera(mCurrentCameraId);
-        }
-
-        private void setUpCamera(final int id) {
-            mCameraInstance = getCameraInstance(id);
-            Parameters parameters = mCameraInstance.getParameters();
-            // TODO adjust by getting supportedPreviewSizes and then choosing
-            // the best one for screen size (best fill screen)
-            if (parameters.getSupportedFocusModes().contains(
-                    Camera.Parameters.FOCUS_MODE_CONTINUOUS_PICTURE)) {
-                parameters.setFocusMode(Parameters.FOCUS_MODE_CONTINUOUS_PICTURE);
-            }
-            mCameraInstance.setParameters(parameters);
-
-            int orientation = mCameraHelper.getCameraDisplayOrientation(
-                    ActivityCamera.this, mCurrentCameraId);
-            CameraInfo2 cameraInfo = new CameraInfo2();
-            mCameraHelper.getCameraInfo(mCurrentCameraId, cameraInfo);
-            boolean flipHorizontal = cameraInfo.facing == CameraInfo.CAMERA_FACING_FRONT;
-            mGPUImage.setUpCamera(mCameraInstance, orientation, flipHorizontal, false);
-        }
-
-        /** A safe way to get an instance of the Camera object. */
-        private Camera getCameraInstance(final int id) {
-            Camera c = null;
-            try {
-                c = mCameraHelper.openCamera(id);
-            } catch (Exception e) {
-                e.printStackTrace();
-            }
-            return c;
-        }
-
-        private void releaseCamera() {
-            mCameraInstance.setPreviewCallback(null);
-            mCameraInstance.release();
-            mCameraInstance = null;
-        }
-    }
-}
diff --git a/sample/src/jp/co/cyberagent/android/gpuimage/sample/activity/ActivityGallery.java b/sample/src/jp/co/cyberagent/android/gpuimage/sample/activity/ActivityGallery.java
deleted file mode 100644
index ad734823..00000000
--- a/sample/src/jp/co/cyberagent/android/gpuimage/sample/activity/ActivityGallery.java
+++ /dev/null
@@ -1,142 +0,0 @@
-/*
- * Copyright (C) 2012 CyberAgent
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package jp.co.cyberagent.android.gpuimage.sample.activity;
-
-import jp.co.cyberagent.android.gpuimage.GPUImageFilter;
-import jp.co.cyberagent.android.gpuimage.GPUImageView;
-import jp.co.cyberagent.android.gpuimage.GPUImageView.OnPictureSavedListener;
-import jp.co.cyberagent.android.gpuimage.sample.GPUImageFilterTools;
-import jp.co.cyberagent.android.gpuimage.sample.GPUImageFilterTools.FilterAdjuster;
-import jp.co.cyberagent.android.gpuimage.sample.GPUImageFilterTools.OnGpuImageFilterChosenListener;
-import jp.co.cyberagent.android.gpuimage.sample.R;
-import android.app.Activity;
-import android.content.Intent;
-import android.net.Uri;
-import android.os.Bundle;
-import android.view.View;
-import android.view.View.OnClickListener;
-import android.widget.SeekBar;
-import android.widget.SeekBar.OnSeekBarChangeListener;
-import android.widget.Toast;
-
-public class ActivityGallery extends Activity implements OnSeekBarChangeListener,
-        OnClickListener, OnPictureSavedListener {
-
-    private static final int REQUEST_PICK_IMAGE = 1;
-    private GPUImageFilter mFilter;
-    private FilterAdjuster mFilterAdjuster;
-    private GPUImageView mGPUImageView;
-
-    @Override
-    public void onCreate(final Bundle savedInstanceState) {
-        super.onCreate(savedInstanceState);
-        setContentView(R.layout.activity_gallery);
-        ((SeekBar) findViewById(R.id.seekBar)).setOnSeekBarChangeListener(this);
-        findViewById(R.id.button_choose_filter).setOnClickListener(this);
-        findViewById(R.id.button_save).setOnClickListener(this);
-
-        mGPUImageView = (GPUImageView) findViewById(R.id.gpuimage);
-
-        Intent photoPickerIntent = new Intent(Intent.ACTION_PICK);
-        photoPickerIntent.setType("image/*");
-        startActivityForResult(photoPickerIntent, REQUEST_PICK_IMAGE);
-    }
-
-    @Override
-    protected void onActivityResult(final int requestCode, final int resultCode, final Intent data) {
-        switch (requestCode) {
-            case REQUEST_PICK_IMAGE:
-                if (resultCode == RESULT_OK) {
-                    handleImage(data.getData());
-                } else {
-                    finish();
-                }
-                break;
-
-            default:
-                super.onActivityResult(requestCode, resultCode, data);
-                break;
-        }
-    }
-
-    @Override
-    public void onClick(final View v) {
-        switch (v.getId()) {
-            case R.id.button_choose_filter:
-                GPUImageFilterTools.showDialog(this, new OnGpuImageFilterChosenListener() {
-
-                    @Override
-                    public void onGpuImageFilterChosenListener(final GPUImageFilter filter) {
-                        switchFilterTo(filter);
-                        mGPUImageView.requestRender();
-                    }
-
-                });
-                break;
-            case R.id.button_save:
-                saveImage();
-                break;
-
-            default:
-                break;
-        }
-
-    }
-
-    @Override
-    public void onPictureSaved(final Uri uri) {
-        Toast.makeText(this, "Saved: " + uri.toString(), Toast.LENGTH_SHORT).show();
-    }
-
-    private void saveImage() {
-        String fileName = System.currentTimeMillis() + ".jpg";
-        mGPUImageView.saveToPictures("GPUImage", fileName, this);
-//        mGPUImageView.saveToPictures("GPUImage", fileName, 1600, 1600, this);
-    }
-
-    private void switchFilterTo(final GPUImageFilter filter) {
-        if (mFilter == null
-                || (filter != null && !mFilter.getClass().equals(filter.getClass()))) {
-            mFilter = filter;
-            mGPUImageView.setFilter(mFilter);
-            mFilterAdjuster = new FilterAdjuster(mFilter);
-
-            findViewById(R.id.seekBar).setVisibility(
-                    mFilterAdjuster.canAdjust() ? View.VISIBLE : View.GONE);
-        }
-    }
-
-    @Override
-    public void onProgressChanged(final SeekBar seekBar, final int progress, final boolean fromUser) {
-        if (mFilterAdjuster != null) {
-            mFilterAdjuster.adjust(progress);
-        }
-        mGPUImageView.requestRender();
-    }
-
-    @Override
-    public void onStartTrackingTouch(final SeekBar seekBar) {
-    }
-
-    @Override
-    public void onStopTrackingTouch(final SeekBar seekBar) {
-    }
-
-    private void handleImage(final Uri selectedImage) {
-        mGPUImageView.setImage(selectedImage);
-    }
-}
diff --git a/sample/src/jp/co/cyberagent/android/gpuimage/sample/activity/ActivityMain.java b/sample/src/jp/co/cyberagent/android/gpuimage/sample/activity/ActivityMain.java
deleted file mode 100644
index 80600ee6..00000000
--- a/sample/src/jp/co/cyberagent/android/gpuimage/sample/activity/ActivityMain.java
+++ /dev/null
@@ -1,71 +0,0 @@
-/*
- * Copyright (C) 2012 CyberAgent
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package jp.co.cyberagent.android.gpuimage.sample.activity;
-
-import android.Manifest;
-import android.app.Activity;
-import android.content.Intent;
-import android.content.pm.PackageManager;
-import android.os.Bundle;
-import android.support.v4.app.ActivityCompat;
-import android.support.v4.content.PermissionChecker;
-import android.view.View;
-import android.view.View.OnClickListener;
-import jp.co.cyberagent.android.gpuimage.sample.R;
-
-public class ActivityMain extends Activity implements OnClickListener {
-
-    @Override public void onCreate(final Bundle savedInstanceState) {
-        super.onCreate(savedInstanceState);
-        setContentView(R.layout.activity_main);
-        findViewById(R.id.button_gallery).setOnClickListener(this);
-        findViewById(R.id.button_camera).setOnClickListener(this);
-    }
-
-    @Override public void onClick(final View v) {
-        if (PermissionChecker.checkSelfPermission(this, Manifest.permission.CAMERA)
-            == PackageManager.PERMISSION_DENIED) {
-            ActivityCompat.requestPermissions(this, new String[] { Manifest.permission.CAMERA },
-                v.getId());
-        } else {
-            startActivity(v.getId());
-        }
-    }
-
-    @Override public void onRequestPermissionsResult(int requestCode, String[] permissions,
-        int[] grantResults) {
-        if (grantResults.length != 1 || grantResults[0] == PackageManager.PERMISSION_GRANTED) {
-            startActivity(requestCode);
-        } else {
-            super.onRequestPermissionsResult(requestCode, permissions, grantResults);
-        }
-    }
-
-    private void startActivity(int id) {
-        switch (id) {
-            case R.id.button_gallery:
-                startActivity(new Intent(this, ActivityGallery.class));
-                break;
-            case R.id.button_camera:
-                startActivity(new Intent(this, ActivityCamera.class));
-                break;
-
-            default:
-                break;
-        }
-    }
-}
diff --git a/sample/src/jp/co/cyberagent/android/gpuimage/sample/utils/CameraHelper.java b/sample/src/jp/co/cyberagent/android/gpuimage/sample/utils/CameraHelper.java
deleted file mode 100644
index 9fafc891..00000000
--- a/sample/src/jp/co/cyberagent/android/gpuimage/sample/utils/CameraHelper.java
+++ /dev/null
@@ -1,124 +0,0 @@
-/*
- * Copyright (C) 2012 CyberAgent
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package jp.co.cyberagent.android.gpuimage.sample.utils;
-
-import static android.os.Build.VERSION.SDK_INT;
-import static android.os.Build.VERSION_CODES.GINGERBREAD;
-import android.app.Activity;
-import android.content.Context;
-import android.hardware.Camera;
-import android.hardware.Camera.CameraInfo;
-import android.view.Surface;
-
-public class CameraHelper {
-    private final CameraHelperImpl mImpl;
-
-    public CameraHelper(final Context context) {
-        if (SDK_INT >= GINGERBREAD) {
-            mImpl = new CameraHelperGB();
-        } else {
-            mImpl = new CameraHelperBase(context);
-        }
-    }
-
-    public interface CameraHelperImpl {
-        int getNumberOfCameras();
-
-        Camera openCamera(int id);
-
-        Camera openDefaultCamera();
-
-        Camera openCameraFacing(int facing);
-
-        boolean hasCamera(int cameraFacingFront);
-
-        void getCameraInfo(int cameraId, CameraInfo2 cameraInfo);
-    }
-
-    public int getNumberOfCameras() {
-        return mImpl.getNumberOfCameras();
-    }
-
-    public Camera openCamera(final int id) {
-        return mImpl.openCamera(id);
-    }
-
-    public Camera openDefaultCamera() {
-        return mImpl.openDefaultCamera();
-    }
-
-    public Camera openFrontCamera() {
-        return mImpl.openCameraFacing(CameraInfo.CAMERA_FACING_FRONT);
-    }
-
-    public Camera openBackCamera() {
-        return mImpl.openCameraFacing(CameraInfo.CAMERA_FACING_BACK);
-    }
-
-    public boolean hasFrontCamera() {
-        return mImpl.hasCamera(CameraInfo.CAMERA_FACING_FRONT);
-    }
-
-    public boolean hasBackCamera() {
-        return mImpl.hasCamera(CameraInfo.CAMERA_FACING_BACK);
-    }
-
-    public void getCameraInfo(final int cameraId, final CameraInfo2 cameraInfo) {
-        mImpl.getCameraInfo(cameraId, cameraInfo);
-    }
-
-    public void setCameraDisplayOrientation(final Activity activity,
-            final int cameraId, final Camera camera) {
-        int result = getCameraDisplayOrientation(activity, cameraId);
-        camera.setDisplayOrientation(result);
-    }
-
-    public int getCameraDisplayOrientation(final Activity activity, final int cameraId) {
-        int rotation = activity.getWindowManager().getDefaultDisplay()
-                .getRotation();
-        int degrees = 0;
-        switch (rotation) {
-            case Surface.ROTATION_0:
-                degrees = 0;
-                break;
-            case Surface.ROTATION_90:
-                degrees = 90;
-                break;
-            case Surface.ROTATION_180:
-                degrees = 180;
-                break;
-            case Surface.ROTATION_270:
-                degrees = 270;
-                break;
-        }
-
-        int result;
-        CameraInfo2 info = new CameraInfo2();
-        getCameraInfo(cameraId, info);
-        if (info.facing == Camera.CameraInfo.CAMERA_FACING_FRONT) {
-            result = (info.orientation + degrees) % 360;
-        } else { // back-facing
-            result = (info.orientation - degrees + 360) % 360;
-        }
-        return result;
-    }
-
-    public static class CameraInfo2 {
-        public int facing;
-        public int orientation;
-    }
-}
diff --git a/sample/src/jp/co/cyberagent/android/gpuimage/sample/utils/CameraHelperBase.java b/sample/src/jp/co/cyberagent/android/gpuimage/sample/utils/CameraHelperBase.java
deleted file mode 100644
index daceb838..00000000
--- a/sample/src/jp/co/cyberagent/android/gpuimage/sample/utils/CameraHelperBase.java
+++ /dev/null
@@ -1,74 +0,0 @@
-/*
- * Copyright (C) 2012 CyberAgent
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package jp.co.cyberagent.android.gpuimage.sample.utils;
-
-import jp.co.cyberagent.android.gpuimage.sample.utils.CameraHelper.CameraHelperImpl;
-import jp.co.cyberagent.android.gpuimage.sample.utils.CameraHelper.CameraInfo2;
-import android.content.Context;
-import android.content.pm.PackageManager;
-import android.hardware.Camera;
-import android.hardware.Camera.CameraInfo;
-
-public class CameraHelperBase implements CameraHelperImpl {
-
-    private final Context mContext;
-
-    public CameraHelperBase(final Context context) {
-        mContext = context;
-    }
-
-    @Override
-    public int getNumberOfCameras() {
-        return hasCameraSupport() ? 1 : 0;
-    }
-
-    @Override
-    public Camera openCamera(final int id) {
-        return Camera.open();
-    }
-
-    @Override
-    public Camera openDefaultCamera() {
-        return Camera.open();
-    }
-
-    @Override
-    public boolean hasCamera(final int facing) {
-        if (facing == CameraInfo.CAMERA_FACING_BACK) {
-            return hasCameraSupport();
-        }
-        return false;
-    }
-
-    @Override
-    public Camera openCameraFacing(final int facing) {
-        if (facing == CameraInfo.CAMERA_FACING_BACK) {
-            return Camera.open();
-        }
-        return null;
-    }
-
-    @Override
-    public void getCameraInfo(final int cameraId, final CameraInfo2 cameraInfo) {
-        cameraInfo.facing = Camera.CameraInfo.CAMERA_FACING_BACK;
-        cameraInfo.orientation = 90;
-    }
-
-    private boolean hasCameraSupport() {
-        return mContext.getPackageManager().hasSystemFeature(PackageManager.FEATURE_CAMERA);
-    }
-}
diff --git a/sample/src/jp/co/cyberagent/android/gpuimage/sample/utils/CameraHelperGB.java b/sample/src/jp/co/cyberagent/android/gpuimage/sample/utils/CameraHelperGB.java
deleted file mode 100644
index ec1ad63d..00000000
--- a/sample/src/jp/co/cyberagent/android/gpuimage/sample/utils/CameraHelperGB.java
+++ /dev/null
@@ -1,72 +0,0 @@
-/*
- * Copyright (C) 2012 CyberAgent
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package jp.co.cyberagent.android.gpuimage.sample.utils;
-
-import jp.co.cyberagent.android.gpuimage.sample.utils.CameraHelper.CameraHelperImpl;
-import jp.co.cyberagent.android.gpuimage.sample.utils.CameraHelper.CameraInfo2;
-import android.annotation.TargetApi;
-import android.hardware.Camera;
-import android.hardware.Camera.CameraInfo;
-
-@TargetApi(9)
-public class CameraHelperGB implements CameraHelperImpl {
-
-    @Override
-    public int getNumberOfCameras() {
-        return Camera.getNumberOfCameras();
-    }
-
-    @Override
-    public Camera openCamera(final int id) {
-        return Camera.open(id);
-    }
-
-    @Override
-    public Camera openDefaultCamera() {
-        return Camera.open(0);
-    }
-
-    @Override
-    public boolean hasCamera(final int facing) {
-        return getCameraId(facing) != -1;
-    }
-
-    @Override
-    public Camera openCameraFacing(final int facing) {
-        return Camera.open(getCameraId(facing));
-    }
-
-    @Override
-    public void getCameraInfo(final int cameraId, final CameraInfo2 cameraInfo) {
-        CameraInfo info = new CameraInfo();
-        Camera.getCameraInfo(cameraId, info);
-        cameraInfo.facing = info.facing;
-        cameraInfo.orientation = info.orientation;
-    }
-
-    private int getCameraId(final int facing) {
-        int numberOfCameras = Camera.getNumberOfCameras();
-        CameraInfo info = new CameraInfo();
-        for (int id = 0; id < numberOfCameras; id++) {
-            Camera.getCameraInfo(id, info);
-            if (info.facing == facing) {
-                return id;
-            }
-        }
-        return -1;
-    }
-}
diff --git a/sample/AndroidManifest.xml b/sample/src/main/AndroidManifest.xml
similarity index 65%
rename from sample/AndroidManifest.xml
rename to sample/src/main/AndroidManifest.xml
index 855b72c5..a45d39b0 100644
--- a/sample/AndroidManifest.xml
+++ b/sample/src/main/AndroidManifest.xml
@@ -1,4 +1,5 @@
 <manifest xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:tools="http://schemas.android.com/tools"
     package="jp.co.cyberagent.android.gpuimage.sample">
 
     <uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE" />
@@ -7,25 +8,31 @@
     <!-- For images from picasa -->
     <uses-permission android:name="android.permission.INTERNET" />
 
+    <uses-feature android:name="android.hardware.camera" />
+    <uses-feature
+        android:name="android.hardware.camera.autofocus"
+        android:required="false" />
+
     <application
-        android:allowBackup="true"
+        android:allowBackup="false"
         android:hardwareAccelerated="true"
         android:icon="@drawable/ic_launcher"
-        android:largeHeap="true"
         android:label="@string/app_name"
-        android:theme="@style/AppTheme" >
+        android:largeHeap="true"
+        android:theme="@style/AppTheme"
+        tools:ignore="GoogleAppIndexingWarning">
         <activity
-            android:name=".activity.ActivityMain"
-            android:label="@string/title_activity_activity_main" >
+            android:name=".activity.MainActivity"
+            android:label="@string/title_activity_activity_main">
             <intent-filter>
                 <action android:name="android.intent.action.MAIN" />
 
                 <category android:name="android.intent.category.LAUNCHER" />
             </intent-filter>
         </activity>
-        <activity android:name=".activity.ActivityGallery" />
+        <activity android:name=".activity.GalleryActivity" />
         <activity
-            android:name="jp.co.cyberagent.android.gpuimage.sample.activity.ActivityCamera"
+            android:name=".activity.CameraActivity"
             android:screenOrientation="portrait"
             android:theme="@style/AppTheme.NoActionBar" />
     </application>
diff --git a/sample/src/main/java/jp/co/cyberagent/android/gpuimage/sample/GPUImageFilterTools.kt b/sample/src/main/java/jp/co/cyberagent/android/gpuimage/sample/GPUImageFilterTools.kt
new file mode 100644
index 00000000..a9ba9b4c
--- /dev/null
+++ b/sample/src/main/java/jp/co/cyberagent/android/gpuimage/sample/GPUImageFilterTools.kt
@@ -0,0 +1,667 @@
+/*
+ * Copyright (C) 2018 CyberAgent, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package jp.co.cyberagent.android.gpuimage.sample
+
+import android.app.AlertDialog
+import android.content.Context
+import android.graphics.BitmapFactory
+import android.graphics.PointF
+import android.opengl.Matrix
+import jp.co.cyberagent.android.gpuimage.filter.*
+import java.util.*
+
+object GPUImageFilterTools {
+    fun showDialog(
+        context: Context,
+        listener: (filter: GPUImageFilter) -> Unit
+    ) {
+        val filters = FilterList().apply {
+            addFilter("Contrast", FilterType.CONTRAST)
+            addFilter("Invert", FilterType.INVERT)
+            addFilter("Pixelation", FilterType.PIXELATION)
+            addFilter("Hue", FilterType.HUE)
+            addFilter("Gamma", FilterType.GAMMA)
+            addFilter("Brightness", FilterType.BRIGHTNESS)
+            addFilter("Sepia", FilterType.SEPIA)
+            addFilter("Grayscale", FilterType.GRAYSCALE)
+            addFilter("Sharpness", FilterType.SHARPEN)
+            addFilter("Sobel Edge Detection", FilterType.SOBEL_EDGE_DETECTION)
+            addFilter("Threshold Edge Detection", FilterType.THRESHOLD_EDGE_DETECTION)
+            addFilter("3x3 Convolution", FilterType.THREE_X_THREE_CONVOLUTION)
+            addFilter("Emboss", FilterType.EMBOSS)
+            addFilter("Posterize", FilterType.POSTERIZE)
+            addFilter("Grouped filters", FilterType.FILTER_GROUP)
+            addFilter("Saturation", FilterType.SATURATION)
+            addFilter("Exposure", FilterType.EXPOSURE)
+            addFilter("Highlight Shadow", FilterType.HIGHLIGHT_SHADOW)
+            addFilter("Monochrome", FilterType.MONOCHROME)
+            addFilter("Opacity", FilterType.OPACITY)
+            addFilter("RGB", FilterType.RGB)
+            addFilter("White Balance", FilterType.WHITE_BALANCE)
+            addFilter("Vignette", FilterType.VIGNETTE)
+            addFilter("ToneCurve", FilterType.TONE_CURVE)
+
+            addFilter("Luminance", FilterType.LUMINANCE)
+            addFilter("Luminance Threshold", FilterType.LUMINANCE_THRESHSOLD)
+
+            addFilter("Blend (Difference)", FilterType.BLEND_DIFFERENCE)
+            addFilter("Blend (Source Over)", FilterType.BLEND_SOURCE_OVER)
+            addFilter("Blend (Color Burn)", FilterType.BLEND_COLOR_BURN)
+            addFilter("Blend (Color Dodge)", FilterType.BLEND_COLOR_DODGE)
+            addFilter("Blend (Darken)", FilterType.BLEND_DARKEN)
+            addFilter("Blend (Dissolve)", FilterType.BLEND_DISSOLVE)
+            addFilter("Blend (Exclusion)", FilterType.BLEND_EXCLUSION)
+            addFilter("Blend (Hard Light)", FilterType.BLEND_HARD_LIGHT)
+            addFilter("Blend (Lighten)", FilterType.BLEND_LIGHTEN)
+            addFilter("Blend (Add)", FilterType.BLEND_ADD)
+            addFilter("Blend (Divide)", FilterType.BLEND_DIVIDE)
+            addFilter("Blend (Multiply)", FilterType.BLEND_MULTIPLY)
+            addFilter("Blend (Overlay)", FilterType.BLEND_OVERLAY)
+            addFilter("Blend (Screen)", FilterType.BLEND_SCREEN)
+            addFilter("Blend (Alpha)", FilterType.BLEND_ALPHA)
+            addFilter("Blend (Color)", FilterType.BLEND_COLOR)
+            addFilter("Blend (Hue)", FilterType.BLEND_HUE)
+            addFilter("Blend (Saturation)", FilterType.BLEND_SATURATION)
+            addFilter("Blend (Luminosity)", FilterType.BLEND_LUMINOSITY)
+            addFilter("Blend (Linear Burn)", FilterType.BLEND_LINEAR_BURN)
+            addFilter("Blend (Soft Light)", FilterType.BLEND_SOFT_LIGHT)
+            addFilter("Blend (Subtract)", FilterType.BLEND_SUBTRACT)
+            addFilter("Blend (Chroma Key)", FilterType.BLEND_CHROMA_KEY)
+            addFilter("Blend (Normal)", FilterType.BLEND_NORMAL)
+
+            addFilter("Lookup (Amatorka)", FilterType.LOOKUP_AMATORKA)
+            addFilter("Gaussian Blur", FilterType.GAUSSIAN_BLUR)
+            addFilter("Crosshatch", FilterType.CROSSHATCH)
+
+            addFilter("Box Blur", FilterType.BOX_BLUR)
+            addFilter("CGA Color Space", FilterType.CGA_COLORSPACE)
+            addFilter("Dilation", FilterType.DILATION)
+            addFilter("Kuwahara", FilterType.KUWAHARA)
+            addFilter("RGB Dilation", FilterType.RGB_DILATION)
+            addFilter("Sketch", FilterType.SKETCH)
+            addFilter("Toon", FilterType.TOON)
+            addFilter("Smooth Toon", FilterType.SMOOTH_TOON)
+            addFilter("Halftone", FilterType.HALFTONE)
+
+            addFilter("Bulge Distortion", FilterType.BULGE_DISTORTION)
+            addFilter("Glass Sphere", FilterType.GLASS_SPHERE)
+            addFilter("Haze", FilterType.HAZE)
+            addFilter("Laplacian", FilterType.LAPLACIAN)
+            addFilter("Non Maximum Suppression", FilterType.NON_MAXIMUM_SUPPRESSION)
+            addFilter("Sphere Refraction", FilterType.SPHERE_REFRACTION)
+            addFilter("Swirl", FilterType.SWIRL)
+            addFilter("Weak Pixel Inclusion", FilterType.WEAK_PIXEL_INCLUSION)
+            addFilter("False Color", FilterType.FALSE_COLOR)
+
+            addFilter("Color Balance", FilterType.COLOR_BALANCE)
+
+            addFilter("Levels Min (Mid Adjust)", FilterType.LEVELS_FILTER_MIN)
+
+            addFilter("Bilateral Blur", FilterType.BILATERAL_BLUR)
+
+            addFilter("Transform (2-D)", FilterType.TRANSFORM2D)
+
+            addFilter("Solarize", FilterType.SOLARIZE)
+        }
+
+        val builder = AlertDialog.Builder(context)
+        builder.setTitle("Choose a filter")
+        builder.setItems(filters.names.toTypedArray()) { _, item ->
+            listener(createFilterForType(context, filters.filters[item]))
+        }
+        builder.create().show()
+    }
+
+    private fun createFilterForType(context: Context, type: FilterType): GPUImageFilter {
+        return when (type) {
+            FilterType.CONTRAST -> GPUImageContrastFilter(2.0f)
+            FilterType.GAMMA -> GPUImageGammaFilter(2.0f)
+            FilterType.INVERT -> GPUImageColorInvertFilter()
+            FilterType.PIXELATION -> GPUImagePixelationFilter()
+            FilterType.HUE -> GPUImageHueFilter(90.0f)
+            FilterType.BRIGHTNESS -> GPUImageBrightnessFilter(1.5f)
+            FilterType.GRAYSCALE -> GPUImageGrayscaleFilter()
+            FilterType.SEPIA -> GPUImageSepiaToneFilter()
+            FilterType.SHARPEN -> GPUImageSharpenFilter()
+            FilterType.SOBEL_EDGE_DETECTION -> GPUImageSobelEdgeDetectionFilter()
+            FilterType.THRESHOLD_EDGE_DETECTION -> GPUImageThresholdEdgeDetectionFilter()
+            FilterType.THREE_X_THREE_CONVOLUTION -> GPUImage3x3ConvolutionFilter()
+            FilterType.EMBOSS -> GPUImageEmbossFilter()
+            FilterType.POSTERIZE -> GPUImagePosterizeFilter()
+            FilterType.FILTER_GROUP -> GPUImageFilterGroup(
+                listOf(
+                    GPUImageContrastFilter(),
+                    GPUImageDirectionalSobelEdgeDetectionFilter(),
+                    GPUImageGrayscaleFilter()
+                )
+            )
+            FilterType.SATURATION -> GPUImageSaturationFilter(1.0f)
+            FilterType.EXPOSURE -> GPUImageExposureFilter(0.0f)
+            FilterType.HIGHLIGHT_SHADOW -> GPUImageHighlightShadowFilter(
+                0.0f,
+                1.0f
+            )
+            FilterType.MONOCHROME -> GPUImageMonochromeFilter(
+                1.0f, floatArrayOf(0.6f, 0.45f, 0.3f, 1.0f)
+            )
+            FilterType.OPACITY -> GPUImageOpacityFilter(1.0f)
+            FilterType.RGB -> GPUImageRGBFilter(1.0f, 1.0f, 1.0f)
+            FilterType.WHITE_BALANCE -> GPUImageWhiteBalanceFilter(
+                5000.0f,
+                0.0f
+            )
+            FilterType.VIGNETTE -> GPUImageVignetteFilter(
+                PointF(0.5f, 0.5f),
+                floatArrayOf(0.0f, 0.0f, 0.0f),
+                0.3f,
+                0.75f
+            )
+            FilterType.TONE_CURVE -> GPUImageToneCurveFilter().apply {
+                setFromCurveFileInputStream(context.resources.openRawResource(R.raw.tone_cuver_sample))
+            }
+            FilterType.LUMINANCE -> GPUImageLuminanceFilter()
+            FilterType.LUMINANCE_THRESHSOLD -> GPUImageLuminanceThresholdFilter(0.5f)
+            FilterType.BLEND_DIFFERENCE -> createBlendFilter(
+                context,
+                GPUImageDifferenceBlendFilter::class.java
+            )
+            FilterType.BLEND_SOURCE_OVER -> createBlendFilter(
+                context,
+                GPUImageSourceOverBlendFilter::class.java
+            )
+            FilterType.BLEND_COLOR_BURN -> createBlendFilter(
+                context,
+                GPUImageColorBurnBlendFilter::class.java
+            )
+            FilterType.BLEND_COLOR_DODGE -> createBlendFilter(
+                context,
+                GPUImageColorDodgeBlendFilter::class.java
+            )
+            FilterType.BLEND_DARKEN -> createBlendFilter(
+                context,
+                GPUImageDarkenBlendFilter::class.java
+            )
+            FilterType.BLEND_DISSOLVE -> createBlendFilter(
+                context,
+                GPUImageDissolveBlendFilter::class.java
+            )
+            FilterType.BLEND_EXCLUSION -> createBlendFilter(
+                context,
+                GPUImageExclusionBlendFilter::class.java
+            )
+
+            FilterType.BLEND_HARD_LIGHT -> createBlendFilter(
+                context,
+                GPUImageHardLightBlendFilter::class.java
+            )
+            FilterType.BLEND_LIGHTEN -> createBlendFilter(
+                context,
+                GPUImageLightenBlendFilter::class.java
+            )
+            FilterType.BLEND_ADD -> createBlendFilter(
+                context,
+                GPUImageAddBlendFilter::class.java
+            )
+            FilterType.BLEND_DIVIDE -> createBlendFilter(
+                context,
+                GPUImageDivideBlendFilter::class.java
+            )
+            FilterType.BLEND_MULTIPLY -> createBlendFilter(
+                context,
+                GPUImageMultiplyBlendFilter::class.java
+            )
+            FilterType.BLEND_OVERLAY -> createBlendFilter(
+                context,
+                GPUImageOverlayBlendFilter::class.java
+            )
+            FilterType.BLEND_SCREEN -> createBlendFilter(
+                context,
+                GPUImageScreenBlendFilter::class.java
+            )
+            FilterType.BLEND_ALPHA -> createBlendFilter(
+                context,
+                GPUImageAlphaBlendFilter::class.java
+            )
+            FilterType.BLEND_COLOR -> createBlendFilter(
+                context,
+                GPUImageColorBlendFilter::class.java
+            )
+            FilterType.BLEND_HUE -> createBlendFilter(
+                context,
+                GPUImageHueBlendFilter::class.java
+            )
+            FilterType.BLEND_SATURATION -> createBlendFilter(
+                context,
+                GPUImageSaturationBlendFilter::class.java
+            )
+            FilterType.BLEND_LUMINOSITY -> createBlendFilter(
+                context,
+                GPUImageLuminosityBlendFilter::class.java
+            )
+            FilterType.BLEND_LINEAR_BURN -> createBlendFilter(
+                context,
+                GPUImageLinearBurnBlendFilter::class.java
+            )
+            FilterType.BLEND_SOFT_LIGHT -> createBlendFilter(
+                context,
+                GPUImageSoftLightBlendFilter::class.java
+            )
+            FilterType.BLEND_SUBTRACT -> createBlendFilter(
+                context,
+                GPUImageSubtractBlendFilter::class.java
+            )
+            FilterType.BLEND_CHROMA_KEY -> createBlendFilter(
+                context,
+                GPUImageChromaKeyBlendFilter::class.java
+            )
+            FilterType.BLEND_NORMAL -> createBlendFilter(
+                context,
+                GPUImageNormalBlendFilter::class.java
+            )
+
+            FilterType.LOOKUP_AMATORKA -> GPUImageLookupFilter().apply {
+                bitmap = BitmapFactory.decodeResource(context.resources, R.drawable.lookup_amatorka)
+            }
+            FilterType.GAUSSIAN_BLUR -> GPUImageGaussianBlurFilter()
+            FilterType.CROSSHATCH -> GPUImageCrosshatchFilter()
+            FilterType.BOX_BLUR -> GPUImageBoxBlurFilter()
+            FilterType.CGA_COLORSPACE -> GPUImageCGAColorspaceFilter()
+            FilterType.DILATION -> GPUImageDilationFilter()
+            FilterType.KUWAHARA -> GPUImageKuwaharaFilter()
+            FilterType.RGB_DILATION -> GPUImageRGBDilationFilter()
+            FilterType.SKETCH -> GPUImageSketchFilter()
+            FilterType.TOON -> GPUImageToonFilter()
+            FilterType.SMOOTH_TOON -> GPUImageSmoothToonFilter()
+            FilterType.BULGE_DISTORTION -> GPUImageBulgeDistortionFilter()
+            FilterType.GLASS_SPHERE -> GPUImageGlassSphereFilter()
+            FilterType.HAZE -> GPUImageHazeFilter()
+            FilterType.LAPLACIAN -> GPUImageLaplacianFilter()
+            FilterType.NON_MAXIMUM_SUPPRESSION -> GPUImageNonMaximumSuppressionFilter()
+            FilterType.SPHERE_REFRACTION -> GPUImageSphereRefractionFilter()
+            FilterType.SWIRL -> GPUImageSwirlFilter()
+            FilterType.WEAK_PIXEL_INCLUSION -> GPUImageWeakPixelInclusionFilter()
+            FilterType.FALSE_COLOR -> GPUImageFalseColorFilter()
+            FilterType.COLOR_BALANCE -> GPUImageColorBalanceFilter()
+            FilterType.LEVELS_FILTER_MIN -> GPUImageLevelsFilter()
+            FilterType.HALFTONE -> GPUImageHalftoneFilter()
+            FilterType.BILATERAL_BLUR -> GPUImageBilateralBlurFilter()
+            FilterType.TRANSFORM2D -> GPUImageTransformFilter()
+            FilterType.SOLARIZE -> GPUImageSolarizeFilter()
+        }
+    }
+
+    private fun createBlendFilter(
+        context: Context,
+        filterClass: Class<out GPUImageTwoInputFilter>
+    ): GPUImageFilter {
+        return try {
+            filterClass.newInstance().apply {
+                bitmap = BitmapFactory.decodeResource(context.resources, R.drawable.ic_launcher)
+            }
+        } catch (e: Exception) {
+            e.printStackTrace()
+            GPUImageFilter()
+        }
+    }
+
+    private enum class FilterType {
+        CONTRAST, GRAYSCALE, SHARPEN, SEPIA, SOBEL_EDGE_DETECTION, THRESHOLD_EDGE_DETECTION, THREE_X_THREE_CONVOLUTION, FILTER_GROUP, EMBOSS, POSTERIZE, GAMMA, BRIGHTNESS, INVERT, HUE, PIXELATION,
+        SATURATION, EXPOSURE, HIGHLIGHT_SHADOW, MONOCHROME, OPACITY, RGB, WHITE_BALANCE, VIGNETTE, TONE_CURVE, LUMINANCE, LUMINANCE_THRESHSOLD, BLEND_COLOR_BURN, BLEND_COLOR_DODGE, BLEND_DARKEN,
+        BLEND_DIFFERENCE, BLEND_DISSOLVE, BLEND_EXCLUSION, BLEND_SOURCE_OVER, BLEND_HARD_LIGHT, BLEND_LIGHTEN, BLEND_ADD, BLEND_DIVIDE, BLEND_MULTIPLY, BLEND_OVERLAY, BLEND_SCREEN, BLEND_ALPHA,
+        BLEND_COLOR, BLEND_HUE, BLEND_SATURATION, BLEND_LUMINOSITY, BLEND_LINEAR_BURN, BLEND_SOFT_LIGHT, BLEND_SUBTRACT, BLEND_CHROMA_KEY, BLEND_NORMAL, LOOKUP_AMATORKA,
+        GAUSSIAN_BLUR, CROSSHATCH, BOX_BLUR, CGA_COLORSPACE, DILATION, KUWAHARA, RGB_DILATION, SKETCH, TOON, SMOOTH_TOON, BULGE_DISTORTION, GLASS_SPHERE, HAZE, LAPLACIAN, NON_MAXIMUM_SUPPRESSION,
+        SPHERE_REFRACTION, SWIRL, WEAK_PIXEL_INCLUSION, FALSE_COLOR, COLOR_BALANCE, LEVELS_FILTER_MIN, BILATERAL_BLUR, HALFTONE, TRANSFORM2D, SOLARIZE
+    }
+
+    private class FilterList {
+        val names: MutableList<String> = LinkedList()
+        val filters: MutableList<FilterType> = LinkedList()
+
+        fun addFilter(name: String, filter: FilterType) {
+            names.add(name)
+            filters.add(filter)
+        }
+    }
+
+    class FilterAdjuster(filter: GPUImageFilter) {
+        private val adjuster: Adjuster<out GPUImageFilter>?
+
+        init {
+            adjuster = when (filter) {
+                is GPUImageSharpenFilter -> SharpnessAdjuster(filter)
+                is GPUImageSepiaToneFilter -> SepiaAdjuster(filter)
+                is GPUImageContrastFilter -> ContrastAdjuster(filter)
+                is GPUImageGammaFilter -> GammaAdjuster(filter)
+                is GPUImageBrightnessFilter -> BrightnessAdjuster(filter)
+                is GPUImageSobelEdgeDetectionFilter -> SobelAdjuster(filter)
+                is GPUImageThresholdEdgeDetectionFilter -> ThresholdAdjuster(filter)
+                is GPUImage3x3ConvolutionFilter -> ThreeXThreeConvolutionAjuster(filter)
+                is GPUImageEmbossFilter -> EmbossAdjuster(filter)
+                is GPUImage3x3TextureSamplingFilter -> GPU3x3TextureAdjuster(filter)
+                is GPUImageHueFilter -> HueAdjuster(filter)
+                is GPUImagePosterizeFilter -> PosterizeAdjuster(filter)
+                is GPUImagePixelationFilter -> PixelationAdjuster(filter)
+                is GPUImageSaturationFilter -> SaturationAdjuster(filter)
+                is GPUImageExposureFilter -> ExposureAdjuster(filter)
+                is GPUImageHighlightShadowFilter -> HighlightShadowAdjuster(filter)
+                is GPUImageMonochromeFilter -> MonochromeAdjuster(filter)
+                is GPUImageOpacityFilter -> OpacityAdjuster(filter)
+                is GPUImageRGBFilter -> RGBAdjuster(filter)
+                is GPUImageWhiteBalanceFilter -> WhiteBalanceAdjuster(filter)
+                is GPUImageVignetteFilter -> VignetteAdjuster(filter)
+                is GPUImageLuminanceThresholdFilter -> LuminanceThresholdAdjuster(filter)
+                is GPUImageDissolveBlendFilter -> DissolveBlendAdjuster(filter)
+                is GPUImageGaussianBlurFilter -> GaussianBlurAdjuster(filter)
+                is GPUImageCrosshatchFilter -> CrosshatchBlurAdjuster(filter)
+                is GPUImageBulgeDistortionFilter -> BulgeDistortionAdjuster(filter)
+                is GPUImageGlassSphereFilter -> GlassSphereAdjuster(filter)
+                is GPUImageHazeFilter -> HazeAdjuster(filter)
+                is GPUImageSphereRefractionFilter -> SphereRefractionAdjuster(filter)
+                is GPUImageSwirlFilter -> SwirlAdjuster(filter)
+                is GPUImageColorBalanceFilter -> ColorBalanceAdjuster(filter)
+                is GPUImageLevelsFilter -> LevelsMinMidAdjuster(filter)
+                is GPUImageBilateralBlurFilter -> BilateralAdjuster(filter)
+                is GPUImageTransformFilter -> RotateAdjuster(filter)
+                is GPUImageSolarizeFilter -> SolarizeAdjuster(filter)
+                else -> null
+            }
+        }
+
+        fun canAdjust(): Boolean {
+            return adjuster != null
+        }
+
+        fun adjust(percentage: Int) {
+            adjuster?.adjust(percentage)
+        }
+
+        private abstract inner class Adjuster<T : GPUImageFilter>(protected val filter: T) {
+
+            abstract fun adjust(percentage: Int)
+
+            protected fun range(percentage: Int, start: Float, end: Float): Float {
+                return (end - start) * percentage / 100.0f + start
+            }
+
+            protected fun range(percentage: Int, start: Int, end: Int): Int {
+                return (end - start) * percentage / 100 + start
+            }
+        }
+
+        private inner class SharpnessAdjuster(filter: GPUImageSharpenFilter) :
+            Adjuster<GPUImageSharpenFilter>(filter) {
+            override fun adjust(percentage: Int) {
+                filter.setSharpness(range(percentage, -4.0f, 4.0f))
+            }
+        }
+
+        private inner class PixelationAdjuster(filter: GPUImagePixelationFilter) :
+            Adjuster<GPUImagePixelationFilter>(filter) {
+            override fun adjust(percentage: Int) {
+                filter.setPixel(range(percentage, 1.0f, 100.0f))
+            }
+        }
+
+        private inner class HueAdjuster(filter: GPUImageHueFilter) :
+            Adjuster<GPUImageHueFilter>(filter) {
+            override fun adjust(percentage: Int) {
+                filter.setHue(range(percentage, 0.0f, 360.0f))
+            }
+        }
+
+        private inner class ContrastAdjuster(filter: GPUImageContrastFilter) :
+            Adjuster<GPUImageContrastFilter>(filter) {
+            override fun adjust(percentage: Int) {
+                filter.setContrast(range(percentage, 0.0f, 2.0f))
+            }
+        }
+
+        private inner class GammaAdjuster(filter: GPUImageGammaFilter) :
+            Adjuster<GPUImageGammaFilter>(filter) {
+            override fun adjust(percentage: Int) {
+                filter.setGamma(range(percentage, 0.0f, 3.0f))
+            }
+        }
+
+        private inner class BrightnessAdjuster(filter: GPUImageBrightnessFilter) :
+            Adjuster<GPUImageBrightnessFilter>(filter) {
+            override fun adjust(percentage: Int) {
+                filter.setBrightness(range(percentage, -1.0f, 1.0f))
+            }
+        }
+
+        private inner class SepiaAdjuster(filter: GPUImageSepiaToneFilter) :
+            Adjuster<GPUImageSepiaToneFilter>(filter) {
+            override fun adjust(percentage: Int) {
+                filter.setIntensity(range(percentage, 0.0f, 2.0f))
+            }
+        }
+
+        private inner class SobelAdjuster(filter: GPUImageSobelEdgeDetectionFilter) :
+            Adjuster<GPUImageSobelEdgeDetectionFilter>(filter) {
+            override fun adjust(percentage: Int) {
+                filter.setLineSize(range(percentage, 0.0f, 5.0f))
+            }
+        }
+
+        private inner class ThresholdAdjuster(filter: GPUImageThresholdEdgeDetectionFilter) :
+            Adjuster<GPUImageThresholdEdgeDetectionFilter>(filter) {
+            override fun adjust(percentage: Int) {
+                filter.setLineSize(range(percentage, 0.0f, 5.0f))
+                filter.setThreshold(0.9f)
+            }
+        }
+
+        private inner class ThreeXThreeConvolutionAjuster(filter: GPUImage3x3ConvolutionFilter) :
+            Adjuster<GPUImage3x3ConvolutionFilter>(filter) {
+            override fun adjust(percentage: Int) {
+                filter.setConvolutionKernel(
+                        floatArrayOf(-1.0f, 0.0f, 1.0f, -2.0f, 0.0f, 2.0f, -1.0f, 0.0f, 1.0f)
+                    )
+            }
+        }
+
+        private inner class EmbossAdjuster(filter: GPUImageEmbossFilter) :
+            Adjuster<GPUImageEmbossFilter>(filter) {
+            override fun adjust(percentage: Int) {
+                filter.intensity = range(percentage, 0.0f, 4.0f)
+            }
+        }
+
+        private inner class PosterizeAdjuster(filter: GPUImagePosterizeFilter) :
+            Adjuster<GPUImagePosterizeFilter>(filter) {
+            override fun adjust(percentage: Int) {
+                // In theorie to 256, but only first 50 are interesting
+                filter.setColorLevels(range(percentage, 1, 50))
+            }
+        }
+
+        private inner class GPU3x3TextureAdjuster(filter: GPUImage3x3TextureSamplingFilter) :
+            Adjuster<GPUImage3x3TextureSamplingFilter>(filter) {
+            override fun adjust(percentage: Int) {
+                filter.setLineSize(range(percentage, 0.0f, 5.0f))
+            }
+        }
+
+        private inner class SaturationAdjuster(filter: GPUImageSaturationFilter) :
+            Adjuster<GPUImageSaturationFilter>(filter) {
+            override fun adjust(percentage: Int) {
+                filter.setSaturation(range(percentage, 0.0f, 2.0f))
+            }
+        }
+
+        private inner class ExposureAdjuster(filter: GPUImageExposureFilter) :
+            Adjuster<GPUImageExposureFilter>(filter) {
+            override fun adjust(percentage: Int) {
+                filter.setExposure(range(percentage, -10.0f, 10.0f))
+            }
+        }
+
+        private inner class HighlightShadowAdjuster(filter: GPUImageHighlightShadowFilter) :
+            Adjuster<GPUImageHighlightShadowFilter>(filter) {
+            override fun adjust(percentage: Int) {
+                filter.setShadows(range(percentage, 0.0f, 1.0f))
+                filter.setHighlights(range(percentage, 0.0f, 1.0f))
+            }
+        }
+
+        private inner class MonochromeAdjuster(filter: GPUImageMonochromeFilter) :
+            Adjuster<GPUImageMonochromeFilter>(filter) {
+            override fun adjust(percentage: Int) {
+                filter.setIntensity(range(percentage, 0.0f, 1.0f))
+            }
+        }
+
+        private inner class OpacityAdjuster(filter: GPUImageOpacityFilter) :
+            Adjuster<GPUImageOpacityFilter>(filter) {
+            override fun adjust(percentage: Int) {
+                filter.setOpacity(range(percentage, 0.0f, 1.0f))
+            }
+        }
+
+        private inner class RGBAdjuster(filter: GPUImageRGBFilter) :
+            Adjuster<GPUImageRGBFilter>(filter) {
+            override fun adjust(percentage: Int) {
+                filter.setRed(range(percentage, 0.0f, 1.0f))
+            }
+        }
+
+        private inner class WhiteBalanceAdjuster(filter: GPUImageWhiteBalanceFilter) :
+            Adjuster<GPUImageWhiteBalanceFilter>(filter) {
+            override fun adjust(percentage: Int) {
+                filter.setTemperature(range(percentage, 2000.0f, 8000.0f))
+            }
+        }
+
+        private inner class VignetteAdjuster(filter: GPUImageVignetteFilter) :
+            Adjuster<GPUImageVignetteFilter>(filter) {
+            override fun adjust(percentage: Int) {
+                filter.setVignetteStart(range(percentage, 0.0f, 1.0f))
+            }
+        }
+
+        private inner class LuminanceThresholdAdjuster(filter: GPUImageLuminanceThresholdFilter) :
+            Adjuster<GPUImageLuminanceThresholdFilter>(filter) {
+            override fun adjust(percentage: Int) {
+                filter.setThreshold(range(percentage, 0.0f, 1.0f))
+            }
+        }
+
+        private inner class DissolveBlendAdjuster(filter: GPUImageDissolveBlendFilter) :
+            Adjuster<GPUImageDissolveBlendFilter>(filter) {
+            override fun adjust(percentage: Int) {
+                filter.setMix(range(percentage, 0.0f, 1.0f))
+            }
+        }
+
+        private inner class GaussianBlurAdjuster(filter: GPUImageGaussianBlurFilter) :
+            Adjuster<GPUImageGaussianBlurFilter>(filter) {
+            override fun adjust(percentage: Int) {
+                filter.setBlurSize(range(percentage, 0.0f, 1.0f))
+            }
+        }
+
+        private inner class CrosshatchBlurAdjuster(filter: GPUImageCrosshatchFilter) :
+            Adjuster<GPUImageCrosshatchFilter>(filter) {
+            override fun adjust(percentage: Int) {
+                filter.setCrossHatchSpacing(range(percentage, 0.0f, 0.06f))
+                filter.setLineWidth(range(percentage, 0.0f, 0.006f))
+            }
+        }
+
+        private inner class BulgeDistortionAdjuster(filter: GPUImageBulgeDistortionFilter) :
+            Adjuster<GPUImageBulgeDistortionFilter>(filter) {
+            override fun adjust(percentage: Int) {
+                filter.setRadius(range(percentage, 0.0f, 1.0f))
+                filter.setScale(range(percentage, -1.0f, 1.0f))
+            }
+        }
+
+        private inner class GlassSphereAdjuster(filter: GPUImageGlassSphereFilter) :
+            Adjuster<GPUImageGlassSphereFilter>(filter) {
+            override fun adjust(percentage: Int) {
+                filter.setRadius(range(percentage, 0.0f, 1.0f))
+            }
+        }
+
+        private inner class HazeAdjuster(filter: GPUImageHazeFilter) :
+            Adjuster<GPUImageHazeFilter>(filter) {
+            override fun adjust(percentage: Int) {
+                filter.setDistance(range(percentage, -0.3f, 0.3f))
+                filter.setSlope(range(percentage, -0.3f, 0.3f))
+            }
+        }
+
+        private inner class SphereRefractionAdjuster(filter: GPUImageSphereRefractionFilter) :
+            Adjuster<GPUImageSphereRefractionFilter>(filter) {
+            override fun adjust(percentage: Int) {
+                filter.setRadius(range(percentage, 0.0f, 1.0f))
+            }
+        }
+
+        private inner class SwirlAdjuster(filter: GPUImageSwirlFilter) :
+            Adjuster<GPUImageSwirlFilter>(filter) {
+            override fun adjust(percentage: Int) {
+                filter.setAngle(range(percentage, 0.0f, 2.0f))
+            }
+        }
+
+        private inner class ColorBalanceAdjuster(filter: GPUImageColorBalanceFilter) :
+            Adjuster<GPUImageColorBalanceFilter>(filter) {
+            override fun adjust(percentage: Int) {
+                filter.setMidtones(
+                    floatArrayOf(
+                        range(percentage, 0.0f, 1.0f),
+                        range(percentage / 2, 0.0f, 1.0f),
+                        range(percentage / 3, 0.0f, 1.0f)
+                    )
+                )
+            }
+        }
+
+        private inner class LevelsMinMidAdjuster(filter: GPUImageLevelsFilter) :
+            Adjuster<GPUImageLevelsFilter>(filter) {
+            override fun adjust(percentage: Int) {
+                filter.setMin(0.0f, range(percentage, 0.0f, 1.0f), 1.0f)
+            }
+        }
+
+        private inner class BilateralAdjuster(filter: GPUImageBilateralBlurFilter) :
+            Adjuster<GPUImageBilateralBlurFilter>(filter) {
+            override fun adjust(percentage: Int) {
+                filter.setDistanceNormalizationFactor(range(percentage, 0.0f, 15.0f))
+            }
+        }
+
+        private inner class RotateAdjuster(filter: GPUImageTransformFilter) :
+            Adjuster<GPUImageTransformFilter>(filter) {
+            override fun adjust(percentage: Int) {
+                val transform = FloatArray(16)
+                Matrix.setRotateM(transform, 0, (360 * percentage / 100).toFloat(), 0f, 0f, 1.0f)
+                filter.transform3D = transform
+            }
+        }
+
+        private inner class SolarizeAdjuster(filter: GPUImageSolarizeFilter) :
+            Adjuster<GPUImageSolarizeFilter>(filter) {
+            override fun adjust(percentage: Int) {
+                filter.setThreshold(range(percentage, 0.0f, 1.0f))
+            }
+        }
+
+    }
+}
diff --git a/sample/src/main/java/jp/co/cyberagent/android/gpuimage/sample/activity/CameraActivity.kt b/sample/src/main/java/jp/co/cyberagent/android/gpuimage/sample/activity/CameraActivity.kt
new file mode 100644
index 00000000..b40cd350
--- /dev/null
+++ b/sample/src/main/java/jp/co/cyberagent/android/gpuimage/sample/activity/CameraActivity.kt
@@ -0,0 +1,120 @@
+/*
+ * Copyright (C) 2018 CyberAgent, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package jp.co.cyberagent.android.gpuimage.sample.activity
+
+import android.os.Build
+import android.os.Bundle
+import android.view.View
+import android.widget.SeekBar
+import android.widget.SeekBar.OnSeekBarChangeListener
+import android.widget.Toast
+import androidx.appcompat.app.AppCompatActivity
+import jp.co.cyberagent.android.gpuimage.GPUImageView
+import jp.co.cyberagent.android.gpuimage.filter.GPUImageFilter
+import jp.co.cyberagent.android.gpuimage.sample.GPUImageFilterTools
+import jp.co.cyberagent.android.gpuimage.sample.GPUImageFilterTools.FilterAdjuster
+import jp.co.cyberagent.android.gpuimage.sample.R
+import jp.co.cyberagent.android.gpuimage.sample.utils.Camera1Loader
+import jp.co.cyberagent.android.gpuimage.sample.utils.Camera2Loader
+import jp.co.cyberagent.android.gpuimage.sample.utils.CameraLoader
+import jp.co.cyberagent.android.gpuimage.sample.utils.doOnLayout
+import jp.co.cyberagent.android.gpuimage.util.Rotation
+
+class CameraActivity : AppCompatActivity() {
+
+    private val gpuImageView: GPUImageView by lazy { findViewById<GPUImageView>(R.id.surfaceView) }
+    private val seekBar: SeekBar by lazy { findViewById<SeekBar>(R.id.seekBar) }
+    private val cameraLoader: CameraLoader by lazy {
+        if (Build.VERSION.SDK_INT < 21) {
+            Camera1Loader(this)
+        } else {
+            Camera2Loader(this)
+        }
+    }
+    private var filterAdjuster: FilterAdjuster? = null
+
+    public override fun onCreate(savedInstanceState: Bundle?) {
+        super.onCreate(savedInstanceState)
+        setContentView(R.layout.activity_camera)
+
+        seekBar.setOnSeekBarChangeListener(object : OnSeekBarChangeListener {
+            override fun onProgressChanged(seekBar: SeekBar, progress: Int, fromUser: Boolean) {
+                filterAdjuster?.adjust(progress)
+            }
+
+            override fun onStartTrackingTouch(seekBar: SeekBar) {}
+            override fun onStopTrackingTouch(seekBar: SeekBar) {}
+        })
+        findViewById<View>(R.id.button_choose_filter).setOnClickListener {
+            GPUImageFilterTools.showDialog(this) { filter -> switchFilterTo(filter) }
+        }
+        findViewById<View>(R.id.button_capture).setOnClickListener {
+            saveSnapshot()
+        }
+        findViewById<View>(R.id.img_switch_camera).run {
+            if (!cameraLoader.hasMultipleCamera()) {
+                visibility = View.GONE
+            }
+            setOnClickListener {
+                cameraLoader.switchCamera()
+                gpuImageView.setRotation(getRotation(cameraLoader.getCameraOrientation()))
+            }
+        }
+        cameraLoader.setOnPreviewFrameListener { data, width, height ->
+            gpuImageView.updatePreviewFrame(data, width, height)
+        }
+        gpuImageView.setRotation(getRotation(cameraLoader.getCameraOrientation()))
+        gpuImageView.setRenderMode(GPUImageView.RENDERMODE_CONTINUOUSLY)
+    }
+
+    override fun onResume() {
+        super.onResume()
+        gpuImageView.doOnLayout {
+            cameraLoader.onResume(it.width, it.height)
+        }
+    }
+
+    override fun onPause() {
+        cameraLoader.onPause()
+        super.onPause()
+    }
+
+    private fun saveSnapshot() {
+        val folderName = "GPUImage"
+        val fileName = System.currentTimeMillis().toString() + ".jpg"
+        gpuImageView.saveToPictures(folderName, fileName) {
+            Toast.makeText(this, "$folderName/$fileName saved", Toast.LENGTH_SHORT).show()
+        }
+    }
+
+    private fun getRotation(orientation: Int): Rotation {
+        return when (orientation) {
+            90 -> Rotation.ROTATION_90
+            180 -> Rotation.ROTATION_180
+            270 -> Rotation.ROTATION_270
+            else -> Rotation.NORMAL
+        }
+    }
+
+    private fun switchFilterTo(filter: GPUImageFilter) {
+        if (gpuImageView.filter == null || gpuImageView.filter!!.javaClass != filter.javaClass) {
+            gpuImageView.filter = filter
+            filterAdjuster = FilterAdjuster(filter)
+            filterAdjuster?.adjust(seekBar.progress)
+        }
+    }
+}
diff --git a/sample/src/main/java/jp/co/cyberagent/android/gpuimage/sample/activity/GalleryActivity.kt b/sample/src/main/java/jp/co/cyberagent/android/gpuimage/sample/activity/GalleryActivity.kt
new file mode 100644
index 00000000..ab45d25b
--- /dev/null
+++ b/sample/src/main/java/jp/co/cyberagent/android/gpuimage/sample/activity/GalleryActivity.kt
@@ -0,0 +1,104 @@
+/*
+ * Copyright (C) 2018 CyberAgent, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package jp.co.cyberagent.android.gpuimage.sample.activity
+
+import android.content.Intent
+import android.os.Bundle
+import android.view.View
+import android.widget.SeekBar
+import android.widget.SeekBar.OnSeekBarChangeListener
+import android.widget.Toast
+import androidx.appcompat.app.AppCompatActivity
+import jp.co.cyberagent.android.gpuimage.GPUImageView
+import jp.co.cyberagent.android.gpuimage.filter.GPUImageFilter
+import jp.co.cyberagent.android.gpuimage.sample.GPUImageFilterTools
+import jp.co.cyberagent.android.gpuimage.sample.GPUImageFilterTools.FilterAdjuster
+import jp.co.cyberagent.android.gpuimage.sample.R
+
+class GalleryActivity : AppCompatActivity() {
+
+    private var filterAdjuster: FilterAdjuster? = null
+    private val gpuImageView: GPUImageView by lazy { findViewById<GPUImageView>(R.id.gpuimage) }
+    private val seekBar: SeekBar by lazy { findViewById<SeekBar>(R.id.seekBar) }
+
+    public override fun onCreate(savedInstanceState: Bundle?) {
+        super.onCreate(savedInstanceState)
+        setContentView(R.layout.activity_gallery)
+
+        seekBar.setOnSeekBarChangeListener(object : OnSeekBarChangeListener {
+            override fun onProgressChanged(seekBar: SeekBar?, progress: Int, fromUser: Boolean) {
+                filterAdjuster?.adjust(progress)
+                gpuImageView.requestRender()
+            }
+
+            override fun onStartTrackingTouch(seekBar: SeekBar?) {}
+            override fun onStopTrackingTouch(seekBar: SeekBar?) {}
+        })
+
+        findViewById<View>(R.id.button_choose_filter).setOnClickListener {
+            GPUImageFilterTools.showDialog(this) { filter ->
+                switchFilterTo(filter)
+                gpuImageView.requestRender()
+            }
+        }
+        findViewById<View>(R.id.button_save).setOnClickListener { saveImage() }
+
+        startPhotoPicker()
+    }
+
+    override fun onActivityResult(requestCode: Int, resultCode: Int, data: Intent?) {
+        when (requestCode) {
+            REQUEST_PICK_IMAGE -> if (resultCode == RESULT_OK) {
+                gpuImageView.setImage(data!!.data)
+            } else {
+                finish()
+            }
+
+            else -> super.onActivityResult(requestCode, resultCode, data)
+        }
+    }
+
+    private fun startPhotoPicker() {
+        val photoPickerIntent = Intent(Intent.ACTION_PICK)
+        photoPickerIntent.type = "image/*"
+        startActivityForResult(photoPickerIntent, REQUEST_PICK_IMAGE)
+    }
+
+    private fun saveImage() {
+        val fileName = System.currentTimeMillis().toString() + ".jpg"
+        gpuImageView.saveToPictures("GPUImage", fileName) { uri ->
+            Toast.makeText(this, "Saved: " + uri.toString(), Toast.LENGTH_SHORT).show()
+        }
+    }
+
+    private fun switchFilterTo(filter: GPUImageFilter) {
+        if (gpuImageView.filter == null || gpuImageView.filter.javaClass != filter.javaClass) {
+            gpuImageView.filter = filter
+            filterAdjuster = FilterAdjuster(filter)
+            if (filterAdjuster!!.canAdjust()) {
+                seekBar.visibility = View.VISIBLE
+                filterAdjuster!!.adjust(seekBar.progress)
+            } else {
+                seekBar.visibility = View.GONE
+            }
+        }
+    }
+
+    companion object {
+        private const val REQUEST_PICK_IMAGE = 1
+    }
+}
diff --git a/sample/src/main/java/jp/co/cyberagent/android/gpuimage/sample/activity/MainActivity.kt b/sample/src/main/java/jp/co/cyberagent/android/gpuimage/sample/activity/MainActivity.kt
new file mode 100644
index 00000000..61957ff3
--- /dev/null
+++ b/sample/src/main/java/jp/co/cyberagent/android/gpuimage/sample/activity/MainActivity.kt
@@ -0,0 +1,83 @@
+/*
+ * Copyright (C) 2018 CyberAgent, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package jp.co.cyberagent.android.gpuimage.sample.activity
+
+import android.Manifest
+import android.content.Intent
+import android.content.pm.PackageManager
+import android.os.Bundle
+import android.view.View
+import androidx.appcompat.app.AppCompatActivity
+import androidx.core.app.ActivityCompat
+import androidx.core.content.ContextCompat
+import jp.co.cyberagent.android.gpuimage.sample.R
+
+class MainActivity : AppCompatActivity() {
+
+    public override fun onCreate(savedInstanceState: Bundle?) {
+        super.onCreate(savedInstanceState)
+        setContentView(R.layout.activity_main)
+
+        findViewById<View>(R.id.button_gallery).setOnClickListener {
+            startActivity(Intent(this, GalleryActivity::class.java))
+        }
+        findViewById<View>(R.id.button_camera).setOnClickListener {
+            if (!hasCameraPermission() || !hasStoragePermission()) {
+                ActivityCompat.requestPermissions(
+                    this,
+                    arrayOf(Manifest.permission.CAMERA, Manifest.permission.WRITE_EXTERNAL_STORAGE),
+                    REQUEST_CAMERA
+                )
+            } else {
+                startActivity(Intent(this, CameraActivity::class.java))
+            }
+        }
+    }
+
+    override fun onRequestPermissionsResult(
+        requestCode: Int,
+        permissions: Array<String>,
+        grantResults: IntArray
+    ) {
+        if (requestCode == REQUEST_CAMERA && grantResults.size == 2
+            && grantResults[0] == PackageManager.PERMISSION_GRANTED
+            && grantResults[1] == PackageManager.PERMISSION_GRANTED
+        ) {
+            startActivity(Intent(this, CameraActivity::class.java))
+        } else {
+            super.onRequestPermissionsResult(requestCode, permissions, grantResults)
+        }
+    }
+
+    private fun hasCameraPermission(): Boolean {
+        return ContextCompat.checkSelfPermission(
+            this,
+            Manifest.permission.CAMERA
+        ) == PackageManager.PERMISSION_GRANTED
+    }
+
+    private fun hasStoragePermission(): Boolean {
+        return ContextCompat.checkSelfPermission(
+            this,
+            Manifest.permission.WRITE_EXTERNAL_STORAGE
+        ) == PackageManager.PERMISSION_GRANTED
+    }
+
+    companion object {
+        private const val REQUEST_CAMERA = 1
+    }
+}
diff --git a/sample/src/main/java/jp/co/cyberagent/android/gpuimage/sample/utils/Camera1Loader.kt b/sample/src/main/java/jp/co/cyberagent/android/gpuimage/sample/utils/Camera1Loader.kt
new file mode 100644
index 00000000..c97efa80
--- /dev/null
+++ b/sample/src/main/java/jp/co/cyberagent/android/gpuimage/sample/utils/Camera1Loader.kt
@@ -0,0 +1,105 @@
+@file:Suppress("DEPRECATION")
+
+package jp.co.cyberagent.android.gpuimage.sample.utils
+
+import android.app.Activity
+import android.hardware.Camera
+import android.util.Log
+import android.view.Surface
+
+class Camera1Loader(private val activity: Activity) : CameraLoader() {
+
+    private var cameraInstance: Camera? = null
+    private var cameraFacing: Int = Camera.CameraInfo.CAMERA_FACING_BACK
+
+    override fun onResume(width: Int, height: Int) {
+        setUpCamera()
+    }
+
+    override fun onPause() {
+        releaseCamera()
+    }
+
+    override fun switchCamera() {
+        cameraFacing = when (cameraFacing) {
+            Camera.CameraInfo.CAMERA_FACING_FRONT -> Camera.CameraInfo.CAMERA_FACING_BACK
+            Camera.CameraInfo.CAMERA_FACING_BACK -> Camera.CameraInfo.CAMERA_FACING_FRONT
+            else -> return
+        }
+        releaseCamera()
+        setUpCamera()
+    }
+
+    override fun getCameraOrientation(): Int {
+        val degrees = when (activity.windowManager.defaultDisplay.rotation) {
+            Surface.ROTATION_0 -> 0
+            Surface.ROTATION_90 -> 90
+            Surface.ROTATION_180 -> 180
+            Surface.ROTATION_270 -> 270
+            else -> 0
+        }
+        return if (cameraFacing == Camera.CameraInfo.CAMERA_FACING_FRONT) {
+            (90 + degrees) % 360
+        } else { // back-facing
+            (90 - degrees) % 360
+        }
+    }
+
+    override fun hasMultipleCamera(): Boolean {
+        return Camera.getNumberOfCameras() > 1
+    }
+
+    private fun setUpCamera() {
+        val id = getCurrentCameraId()
+        try {
+            cameraInstance = getCameraInstance(id)
+        } catch (e: IllegalAccessError) {
+            Log.e(TAG, "Camera not found")
+            return
+        }
+        val parameters = cameraInstance!!.parameters
+
+        if (parameters.supportedFocusModes.contains(Camera.Parameters.FOCUS_MODE_CONTINUOUS_PICTURE)) {
+            parameters.focusMode = Camera.Parameters.FOCUS_MODE_CONTINUOUS_PICTURE
+        }
+        cameraInstance!!.parameters = parameters
+
+        cameraInstance!!.setPreviewCallback { data, camera ->
+            if (data == null || camera == null) {
+                return@setPreviewCallback
+            }
+            val size = camera.parameters.previewSize
+            onPreviewFrame?.invoke(data, size.width, size.height)
+        }
+        cameraInstance!!.startPreview()
+    }
+
+    private fun getCurrentCameraId(): Int {
+        val cameraInfo = Camera.CameraInfo()
+        for (id in 0 until Camera.getNumberOfCameras()) {
+            Camera.getCameraInfo(id, cameraInfo)
+            if (cameraInfo.facing == cameraFacing) {
+                return id
+            }
+        }
+        return 0
+    }
+
+    private fun getCameraInstance(id: Int): Camera {
+        return try {
+            Camera.open(id)
+        } catch (e: Exception) {
+            throw IllegalAccessError("Camera not found")
+        }
+    }
+
+    private fun releaseCamera() {
+        cameraInstance!!.setPreviewCallback(null)
+        cameraInstance!!.release()
+        cameraInstance = null
+    }
+
+    companion object {
+        private const val TAG = "Camera1Loader"
+    }
+}
\ No newline at end of file
diff --git a/sample/src/main/java/jp/co/cyberagent/android/gpuimage/sample/utils/Camera2Loader.kt b/sample/src/main/java/jp/co/cyberagent/android/gpuimage/sample/utils/Camera2Loader.kt
new file mode 100644
index 00000000..950f4a55
--- /dev/null
+++ b/sample/src/main/java/jp/co/cyberagent/android/gpuimage/sample/utils/Camera2Loader.kt
@@ -0,0 +1,192 @@
+package jp.co.cyberagent.android.gpuimage.sample.utils
+
+import android.annotation.SuppressLint
+import android.app.Activity
+import android.content.Context
+import android.graphics.ImageFormat
+import android.hardware.camera2.*
+import android.media.Image
+import android.media.ImageReader
+import android.os.Build
+import android.util.Log
+import android.util.Size
+import android.view.Surface
+import androidx.annotation.RequiresApi
+
+@RequiresApi(Build.VERSION_CODES.LOLLIPOP)
+class Camera2Loader(private val activity: Activity) : CameraLoader() {
+
+    private var cameraInstance: CameraDevice? = null
+    private var captureSession: CameraCaptureSession? = null
+    private var imageReader: ImageReader? = null
+    private var cameraFacing: Int = CameraCharacteristics.LENS_FACING_BACK
+    private var viewWidth: Int = 0
+    private var viewHeight: Int = 0
+
+    private val cameraManager: CameraManager by lazy {
+        activity.getSystemService(Context.CAMERA_SERVICE) as CameraManager
+    }
+
+    override fun onResume(width: Int, height: Int) {
+        viewWidth = width
+        viewHeight = height
+        setUpCamera()
+    }
+
+    override fun onPause() {
+        releaseCamera()
+    }
+
+    override fun switchCamera() {
+        cameraFacing = when (cameraFacing) {
+            CameraCharacteristics.LENS_FACING_BACK -> CameraCharacteristics.LENS_FACING_FRONT
+            CameraCharacteristics.LENS_FACING_FRONT -> CameraCharacteristics.LENS_FACING_BACK
+            else -> return
+        }
+        releaseCamera()
+        setUpCamera()
+    }
+
+    override fun getCameraOrientation(): Int {
+        val degrees = when (activity.windowManager.defaultDisplay.rotation) {
+            Surface.ROTATION_0 -> 0
+            Surface.ROTATION_90 -> 90
+            Surface.ROTATION_180 -> 180
+            Surface.ROTATION_270 -> 270
+            else -> 0
+        }
+        val cameraId = getCameraId(cameraFacing) ?: return 0
+        val characteristics = cameraManager.getCameraCharacteristics(cameraId)
+        val orientation = characteristics.get(CameraCharacteristics.SENSOR_ORIENTATION) ?: return 0
+        return if (cameraFacing == CameraCharacteristics.LENS_FACING_FRONT) {
+            (orientation + degrees) % 360
+        } else { // back-facing
+            (orientation - degrees) % 360
+        }
+    }
+
+    override fun hasMultipleCamera(): Boolean {
+        return cameraManager.cameraIdList.size > 1
+    }
+
+    @SuppressLint("MissingPermission")
+    private fun setUpCamera() {
+        val cameraId = getCameraId(cameraFacing) ?: return
+        try {
+            cameraManager.openCamera(cameraId, CameraDeviceCallback(), null)
+        } catch (e: CameraAccessException) {
+            Log.e(TAG, "Opening camera (ID: $cameraId) failed.")
+        }
+    }
+
+    private fun releaseCamera() {
+        imageReader?.close()
+        cameraInstance?.close()
+        captureSession?.close()
+        imageReader = null
+        cameraInstance = null
+        captureSession = null
+    }
+
+    private fun getCameraId(facing: Int): String? {
+        return cameraManager.cameraIdList.find { id ->
+            cameraManager.getCameraCharacteristics(id).get(CameraCharacteristics.LENS_FACING) == facing
+        }
+    }
+
+    private fun startCaptureSession() {
+        val size = chooseOptimalSize()
+        imageReader =
+                ImageReader.newInstance(size.width, size.height, ImageFormat.YUV_420_888, 2).apply {
+                    setOnImageAvailableListener({ reader ->
+                        val image = reader?.acquireNextImage() ?: return@setOnImageAvailableListener
+                        onPreviewFrame?.invoke(generateNV21Data(image), image.width, image.height)
+                        image.close()
+                    }, null)
+                }
+
+        try {
+            cameraInstance?.createCaptureSession(
+                listOf(imageReader!!.surface),
+                CaptureStateCallback(),
+                null
+            )
+        } catch (e: CameraAccessException) {
+            Log.e(TAG, "Failed to start camera session")
+        }
+    }
+
+    private fun chooseOptimalSize(): Size {
+        if (viewWidth == 0 || viewHeight == 0) {
+            return Size(0, 0)
+        }
+        val cameraId = getCameraId(cameraFacing) ?: return Size(0, 0)
+        val outputSizes = cameraManager.getCameraCharacteristics(cameraId)
+            .get(CameraCharacteristics.SCALER_STREAM_CONFIGURATION_MAP)
+            ?.getOutputSizes(ImageFormat.YUV_420_888)
+
+        return outputSizes?.filter {
+            it.width < viewWidth / 2 && it.height < viewHeight / 2
+        }?.maxBy {
+            it.width * it.height
+        } ?: Size(PREVIEW_WIDTH, PREVIEW_HEIGHT)
+    }
+
+    private fun generateNV21Data(image: Image): ByteArray {
+        val bufferY = image.planes[0].buffer
+        val bufferV = image.planes[1].buffer
+        val bufferU = image.planes[2].buffer
+        val bufferYSize = bufferY.remaining()
+        val bufferUSize = bufferU.remaining()
+        val bufferVSize = bufferV.remaining()
+        val bytes = ByteArray(bufferYSize + bufferUSize + bufferVSize)
+        bufferY.get(bytes, 0, bufferYSize)
+        bufferU.get(bytes, bufferYSize, bufferUSize)
+        bufferV.get(bytes, bufferYSize + bufferUSize, bufferVSize)
+        return bytes
+    }
+
+    private inner class CameraDeviceCallback : CameraDevice.StateCallback() {
+        override fun onOpened(camera: CameraDevice) {
+            cameraInstance = camera
+            startCaptureSession()
+        }
+
+        override fun onDisconnected(camera: CameraDevice) {
+            camera.close()
+            cameraInstance = null
+        }
+
+        override fun onError(camera: CameraDevice, error: Int) {
+            camera.close()
+            cameraInstance = null
+        }
+    }
+
+    private inner class CaptureStateCallback : CameraCaptureSession.StateCallback() {
+        override fun onConfigureFailed(session: CameraCaptureSession) {
+            Log.e(TAG, "Failed to configure capture session.")
+        }
+
+        override fun onConfigured(session: CameraCaptureSession) {
+            cameraInstance ?: return
+            captureSession = session
+            val builder = cameraInstance!!.createCaptureRequest(CameraDevice.TEMPLATE_PREVIEW)
+            builder.addTarget(imageReader!!.surface)
+            try {
+                session.setRepeatingRequest(builder.build(), null, null)
+            } catch (e: CameraAccessException) {
+                Log.e(TAG, "Failed to start camera preview because it couldn't access camera", e)
+            } catch (e: IllegalStateException) {
+                Log.e(TAG, "Failed to start camera preview.", e)
+            }
+        }
+    }
+
+    companion object {
+        private const val TAG = "Camera2Loader"
+
+        private const val PREVIEW_WIDTH = 480
+        private const val PREVIEW_HEIGHT = 640
+    }
+}
\ No newline at end of file
diff --git a/sample/src/main/java/jp/co/cyberagent/android/gpuimage/sample/utils/CameraLoader.kt b/sample/src/main/java/jp/co/cyberagent/android/gpuimage/sample/utils/CameraLoader.kt
new file mode 100644
index 00000000..c29eb481
--- /dev/null
+++ b/sample/src/main/java/jp/co/cyberagent/android/gpuimage/sample/utils/CameraLoader.kt
@@ -0,0 +1,21 @@
+package jp.co.cyberagent.android.gpuimage.sample.utils
+
+
+abstract class CameraLoader {
+
+    protected var onPreviewFrame: ((data: ByteArray, width: Int, height: Int) -> Unit)? = null
+
+    abstract fun onResume(width: Int, height: Int)
+
+    abstract fun onPause()
+
+    abstract fun switchCamera()
+
+    abstract fun getCameraOrientation(): Int
+
+    abstract fun hasMultipleCamera(): Boolean
+
+    fun setOnPreviewFrameListener(onPreviewFrame: (data: ByteArray, width: Int, height: Int) -> Unit) {
+        this.onPreviewFrame = onPreviewFrame
+    }
+}
\ No newline at end of file
diff --git a/sample/src/main/java/jp/co/cyberagent/android/gpuimage/sample/utils/ViewExt.kt b/sample/src/main/java/jp/co/cyberagent/android/gpuimage/sample/utils/ViewExt.kt
new file mode 100644
index 00000000..d87ce3ee
--- /dev/null
+++ b/sample/src/main/java/jp/co/cyberagent/android/gpuimage/sample/utils/ViewExt.kt
@@ -0,0 +1,31 @@
+package jp.co.cyberagent.android.gpuimage.sample.utils
+
+import android.view.View
+import androidx.core.view.ViewCompat
+
+inline fun View.doOnLayout(crossinline action: (view: View) -> Unit) {
+    if (ViewCompat.isLaidOut(this) && !isLayoutRequested) {
+        action(this)
+    } else {
+        doOnNextLayout { action(it) }
+    }
+}
+
+inline fun View.doOnNextLayout(crossinline action: (view: View) -> Unit) {
+    addOnLayoutChangeListener(object : View.OnLayoutChangeListener {
+        override fun onLayoutChange(
+            view: View,
+            left: Int,
+            top: Int,
+            right: Int,
+            bottom: Int,
+            oldLeft: Int,
+            oldTop: Int,
+            oldRight: Int,
+            oldBottom: Int
+        ) {
+            view.removeOnLayoutChangeListener(this)
+            action(view)
+        }
+    })
+}
diff --git a/sample/res/drawable-hdpi/ic_action_search.png b/sample/src/main/res/drawable-hdpi/ic_action_search.png
similarity index 100%
rename from sample/res/drawable-hdpi/ic_action_search.png
rename to sample/src/main/res/drawable-hdpi/ic_action_search.png
diff --git a/sample/src/main/res/drawable-hdpi/ic_launcher.png b/sample/src/main/res/drawable-hdpi/ic_launcher.png
new file mode 100755
index 00000000..c47a14c7
Binary files /dev/null and b/sample/src/main/res/drawable-hdpi/ic_launcher.png differ
diff --git a/sample/res/drawable-hdpi/ic_switch_camera.png b/sample/src/main/res/drawable-hdpi/ic_switch_camera.png
similarity index 100%
rename from sample/res/drawable-hdpi/ic_switch_camera.png
rename to sample/src/main/res/drawable-hdpi/ic_switch_camera.png
diff --git a/sample/res/drawable-mdpi/ic_action_search.png b/sample/src/main/res/drawable-mdpi/ic_action_search.png
similarity index 100%
rename from sample/res/drawable-mdpi/ic_action_search.png
rename to sample/src/main/res/drawable-mdpi/ic_action_search.png
diff --git a/sample/src/main/res/drawable-mdpi/ic_launcher.png b/sample/src/main/res/drawable-mdpi/ic_launcher.png
new file mode 100755
index 00000000..42c6bf71
Binary files /dev/null and b/sample/src/main/res/drawable-mdpi/ic_launcher.png differ
diff --git a/sample/res/drawable-nodpi/lookup_amatorka.png b/sample/src/main/res/drawable-nodpi/lookup_amatorka.png
similarity index 100%
rename from sample/res/drawable-nodpi/lookup_amatorka.png
rename to sample/src/main/res/drawable-nodpi/lookup_amatorka.png
diff --git a/sample/res/drawable-xhdpi/ic_action_search.png b/sample/src/main/res/drawable-xhdpi/ic_action_search.png
similarity index 100%
rename from sample/res/drawable-xhdpi/ic_action_search.png
rename to sample/src/main/res/drawable-xhdpi/ic_action_search.png
diff --git a/sample/src/main/res/drawable-xhdpi/ic_launcher.png b/sample/src/main/res/drawable-xhdpi/ic_launcher.png
new file mode 100755
index 00000000..65a75f94
Binary files /dev/null and b/sample/src/main/res/drawable-xhdpi/ic_launcher.png differ
diff --git a/sample/src/main/res/drawable-xxhdpi/ic_launcher.png b/sample/src/main/res/drawable-xxhdpi/ic_launcher.png
new file mode 100755
index 00000000..c0b4a034
Binary files /dev/null and b/sample/src/main/res/drawable-xxhdpi/ic_launcher.png differ
diff --git a/sample/src/main/res/drawable-xxxhdpi/ic_launcher.png b/sample/src/main/res/drawable-xxxhdpi/ic_launcher.png
new file mode 100755
index 00000000..1e9b5fa8
Binary files /dev/null and b/sample/src/main/res/drawable-xxxhdpi/ic_launcher.png differ
diff --git a/sample/res/layout/activity_camera.xml b/sample/src/main/res/layout/activity_camera.xml
similarity index 55%
rename from sample/res/layout/activity_camera.xml
rename to sample/src/main/res/layout/activity_camera.xml
index 16a64d0d..7e4c9fd3 100644
--- a/sample/res/layout/activity_camera.xml
+++ b/sample/src/main/res/layout/activity_camera.xml
@@ -1,21 +1,38 @@
 <RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:app="http://schemas.android.com/apk/res-auto"
+    xmlns:tools="http://schemas.android.com/tools"
     android:layout_width="match_parent"
     android:layout_height="match_parent"
-    android:orientation="vertical" >
+    android:orientation="vertical">
 
-    <android.opengl.GLSurfaceView
+    <!--<android.opengl.GLSurfaceView-->
+    <!--android:id="@+id/surfaceView"-->
+    <!--android:layout_width="match_parent"-->
+    <!--android:layout_height="match_parent"-->
+    <!--android:layout_above="@+id/bar" />-->
+
+    <!--<jp.co.cyberagent.android.gpuimage.GLTextureView-->
+    <!--android:id="@+id/surfaceView"-->
+    <!--android:layout_width="match_parent"-->
+    <!--android:layout_height="match_parent"-->
+    <!--android:layout_above="@+id/bar" />-->
+
+    <jp.co.cyberagent.android.gpuimage.GPUImageView
         android:id="@+id/surfaceView"
         android:layout_width="match_parent"
         android:layout_height="match_parent"
-        android:layout_above="@+id/bar" />
+        app:gpuimage_show_loading="false"
+        app:gpuimage_surface_type="texture_view" /> <!-- surface_view or texture_view -->
 
     <ImageView
         android:id="@+id/img_switch_camera"
         android:layout_width="wrap_content"
         android:layout_height="wrap_content"
         android:layout_alignParentRight="true"
+        android:contentDescription="@null"
         android:padding="10dp"
-        android:src="@drawable/ic_switch_camera" />
+        android:src="@drawable/ic_switch_camera"
+        tools:ignore="HardcodedText,RtlHardcoded" />
 
     <LinearLayout
         android:id="@+id/bar"
@@ -24,7 +41,7 @@
         android:layout_alignParentBottom="true"
         android:background="#000000"
         android:gravity="center_vertical"
-        android:orientation="horizontal" >
+        android:orientation="horizontal">
 
         <SeekBar
             android:id="@+id/seekBar"
@@ -37,12 +54,14 @@
             android:id="@+id/button_choose_filter"
             android:layout_width="wrap_content"
             android:layout_height="wrap_content"
-            android:text="Choose Filter" />
+            android:text="Choose Filter"
+            tools:ignore="HardcodedText" />
 
         <ImageButton
             android:id="@+id/button_capture"
             android:layout_width="wrap_content"
             android:layout_height="wrap_content"
+            android:contentDescription="@null"
             android:src="@android:drawable/ic_menu_camera" />
     </LinearLayout>
 
diff --git a/sample/res/layout/activity_gallery.xml b/sample/src/main/res/layout/activity_gallery.xml
similarity index 76%
rename from sample/res/layout/activity_gallery.xml
rename to sample/src/main/res/layout/activity_gallery.xml
index c2575162..d58d643e 100644
--- a/sample/res/layout/activity_gallery.xml
+++ b/sample/src/main/res/layout/activity_gallery.xml
@@ -1,7 +1,8 @@
 <LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:tools="http://schemas.android.com/tools"
     android:layout_width="match_parent"
     android:layout_height="match_parent"
-    android:background="#000000"
+    android:background="@android:color/black"
     android:orientation="vertical">
 
     <FrameLayout
@@ -11,9 +12,9 @@
 
         <jp.co.cyberagent.android.gpuimage.GPUImageView
             android:id="@+id/gpuimage"
-            android:layout_gravity="center"
             android:layout_width="wrap_content"
-            android:layout_height="wrap_content" />
+            android:layout_height="wrap_content"
+            android:layout_gravity="center" />
 
         <SeekBar
             android:id="@+id/seekBar"
@@ -32,13 +33,15 @@
             android:id="@+id/button_choose_filter"
             android:layout_width="wrap_content"
             android:layout_height="wrap_content"
-            android:text="Choose filter" />
+            android:text="Choose filter"
+            tools:ignore="HardcodedText" />
 
         <Button
             android:id="@+id/button_save"
             android:layout_width="wrap_content"
             android:layout_height="wrap_content"
-            android:text="Save" />
+            android:text="Save"
+            tools:ignore="HardcodedText" />
     </LinearLayout>
 
 </LinearLayout>
\ No newline at end of file
diff --git a/sample/res/layout/activity_main.xml b/sample/src/main/res/layout/activity_main.xml
similarity index 77%
rename from sample/res/layout/activity_main.xml
rename to sample/src/main/res/layout/activity_main.xml
index 6c13bf2f..b0ae0fbb 100644
--- a/sample/res/layout/activity_main.xml
+++ b/sample/src/main/res/layout/activity_main.xml
@@ -1,14 +1,14 @@
 <FrameLayout xmlns:android="http://schemas.android.com/apk/res/android"
     xmlns:tools="http://schemas.android.com/tools"
     android:layout_width="match_parent"
-    android:layout_height="match_parent" >
+    android:layout_height="match_parent">
 
     <LinearLayout
         android:layout_width="wrap_content"
         android:layout_height="wrap_content"
         android:layout_gravity="center"
         android:gravity="center"
-        android:orientation="vertical" >
+        android:orientation="vertical">
 
         <Button
             android:id="@+id/button_gallery"
@@ -16,14 +16,16 @@
             android:layout_height="wrap_content"
             android:layout_marginBottom="10dp"
             android:drawableTop="@android:drawable/ic_menu_gallery"
-            android:text="Gallery" />
+            android:text="Gallery"
+            tools:ignore="HardcodedText" />
 
         <Button
             android:id="@+id/button_camera"
             android:layout_width="wrap_content"
             android:layout_height="wrap_content"
             android:drawableTop="@android:drawable/ic_menu_camera"
-            android:text="Camera" />
+            android:text="Camera"
+            tools:ignore="HardcodedText" />
     </LinearLayout>
 
 </FrameLayout>
\ No newline at end of file
diff --git a/sample/res/raw/tone_cuver_sample.acv b/sample/src/main/res/raw/tone_cuver_sample.acv
similarity index 100%
rename from sample/res/raw/tone_cuver_sample.acv
rename to sample/src/main/res/raw/tone_cuver_sample.acv
diff --git a/sample/res/values/strings.xml b/sample/src/main/res/values/strings.xml
similarity index 55%
rename from sample/res/values/strings.xml
rename to sample/src/main/res/values/strings.xml
index 48ea9ea7..15ddb087 100644
--- a/sample/res/values/strings.xml
+++ b/sample/src/main/res/values/strings.xml
@@ -1,6 +1,6 @@
 <resources>
 
-    <string name="app_name">GPUImage Sample</string>
+    <string name="app_name">GPUImage for Android</string>
     <string name="title_activity_activity_main">GPUImage Sample</string>
 
 </resources>
\ No newline at end of file
diff --git a/sample/src/main/res/values/styles.xml b/sample/src/main/res/values/styles.xml
new file mode 100644
index 00000000..a75347be
--- /dev/null
+++ b/sample/src/main/res/values/styles.xml
@@ -0,0 +1,7 @@
+<resources>
+
+    <style name="AppTheme" parent="Theme.AppCompat.Light" />
+
+    <style name="AppTheme.NoActionBar" parent="Theme.AppCompat.Light.NoActionBar" />
+
+</resources>
\ No newline at end of file
