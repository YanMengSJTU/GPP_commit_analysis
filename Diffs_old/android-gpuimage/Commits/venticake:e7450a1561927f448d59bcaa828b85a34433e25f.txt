diff --git a/library/src/jp/co/cyberagent/android/gpuimage/GLTextureView.java b/library/src/jp/co/cyberagent/android/gpuimage/GLTextureView.java
index 6b617181..cf9ce070 100644
--- a/library/src/jp/co/cyberagent/android/gpuimage/GLTextureView.java
+++ b/library/src/jp/co/cyberagent/android/gpuimage/GLTextureView.java
@@ -517,8 +517,6 @@ public void onSurfaceTextureUpdated(SurfaceTexture surface) {
          *           GL11 or higher interfaces.
          */
         void onDrawFrame(GL10 gl);
-
-        void onSurfaceDestroyed(GL10 gl);
     }
 
     /**
@@ -751,8 +749,8 @@ public SimpleEGLConfigChooser(boolean withDepthBuffer) {
      */
 
     private static class EglHelper {
-        public EglHelper(WeakReference<GLTextureView> glSurfaceViewWeakRef) {
-            mGLSurfaceViewWeakRef = glSurfaceViewWeakRef;
+        public EglHelper(WeakReference<GLTextureView> glTextureViewWeakRef) {
+            mGLTextureViewWeakRef = glTextureViewWeakRef;
         }
 
         /**
@@ -783,7 +781,7 @@ public void start() {
             if (!mEgl.eglInitialize(mEglDisplay, version)) {
                 throw new RuntimeException("eglInitialize failed");
             }
-            GLTextureView view = mGLSurfaceViewWeakRef.get();
+            GLTextureView view = mGLTextureViewWeakRef.get();
             if (view == null) {
                 mEglConfig = null;
                 mEglContext = null;
@@ -839,7 +837,7 @@ public boolean createSurface() {
             /*
              * Create an EGL surface we can render into.
              */
-            GLTextureView view = mGLSurfaceViewWeakRef.get();
+            GLTextureView view = mGLTextureViewWeakRef.get();
             if (view != null) {
                 mEglSurface = view.mEGLWindowSurfaceFactory.createWindowSurface(mEgl,
                         mEglDisplay, mEglConfig, view.getSurfaceTexture());
@@ -877,7 +875,7 @@ public boolean createSurface() {
         GL createGL() {
 
             GL gl = mEglContext.getGL();
-            GLTextureView view = mGLSurfaceViewWeakRef.get();
+            GLTextureView view = mGLTextureViewWeakRef.get();
             if (view != null) {
                 if (view.mGLWrapper != null) {
                     gl = view.mGLWrapper.wrap(gl);
@@ -922,7 +920,7 @@ private void destroySurfaceImp() {
                 mEgl.eglMakeCurrent(mEglDisplay, EGL10.EGL_NO_SURFACE,
                         EGL10.EGL_NO_SURFACE,
                         EGL10.EGL_NO_CONTEXT);
-                GLTextureView view = mGLSurfaceViewWeakRef.get();
+                GLTextureView view = mGLTextureViewWeakRef.get();
                 if (view != null) {
                     view.mEGLWindowSurfaceFactory.destroySurface(mEgl, mEglDisplay, mEglSurface);
                 }
@@ -935,7 +933,7 @@ public void finish() {
                 Log.w("EglHelper", "finish() tid=" + Thread.currentThread().getId());
             }
             if (mEglContext != null) {
-                GLTextureView view = mGLSurfaceViewWeakRef.get();
+                GLTextureView view = mGLTextureViewWeakRef.get();
                 if (view != null) {
                     view.mEGLContextFactory.destroyContext(mEgl, mEglDisplay, mEglContext);
                 }
@@ -968,7 +966,7 @@ public static String formatEglError(String function, int error) {
             return function + " failed: " + error;
         }
 
-        private WeakReference<GLTextureView> mGLSurfaceViewWeakRef;
+        private WeakReference<GLTextureView> mGLTextureViewWeakRef;
         EGL10 mEgl;
         EGLDisplay mEglDisplay;
         EGLSurface mEglSurface;
@@ -985,13 +983,13 @@ public static String formatEglError(String function, int error) {
      * avoids multiple-lock ordering issues.
      */
     static class GLThread extends Thread {
-        GLThread(WeakReference<GLTextureView> glSurfaceViewWeakRef) {
+        GLThread(WeakReference<GLTextureView> glTextureViewWeakRef) {
             super();
             mWidth = 0;
             mHeight = 0;
             mRequestRender = true;
             mRenderMode = RENDERMODE_CONTINUOUSLY;
-            mGLSurfaceViewWeakRef = glSurfaceViewWeakRef;
+            mGLTextureViewWeakRef = glTextureViewWeakRef;
         }
 
         @Override
@@ -1034,7 +1032,7 @@ private void stopEglContextLocked() {
         }
 
         private void guardedRun() throws InterruptedException {
-            mEglHelper = new EglHelper(mGLSurfaceViewWeakRef);
+            mEglHelper = new EglHelper(mGLTextureViewWeakRef);
             mHaveEglContext = false;
             mHaveEglSurface = false;
             try {
@@ -1102,7 +1100,7 @@ private void guardedRun() throws InterruptedException {
 
                             // When pausing, optionally release the EGL Context:
                             if (pausing && mHaveEglContext) {
-                                GLTextureView view = mGLSurfaceViewWeakRef.get();
+                                GLTextureView view = mGLTextureViewWeakRef.get();
                                 boolean preserveEglContextOnPause = view == null ?
                                         false : view.mPreserveEGLContextOnPause;
                                 if (!preserveEglContextOnPause || sGLThreadManager.shouldReleaseEGLContextWhenPausing()) {
@@ -1255,7 +1253,7 @@ private void guardedRun() throws InterruptedException {
                         if (LOG_RENDERER) {
                             Log.w("GLThread", "onSurfaceCreated");
                         }
-                        GLTextureView view = mGLSurfaceViewWeakRef.get();
+                        GLTextureView view = mGLTextureViewWeakRef.get();
                         if (view != null) {
                             view.mRenderer.onSurfaceCreated(gl, mEglHelper.mEglConfig);
                         }
@@ -1266,7 +1264,7 @@ private void guardedRun() throws InterruptedException {
                         if (LOG_RENDERER) {
                             Log.w("GLThread", "onSurfaceChanged(" + w + ", " + h + ")");
                         }
-                        GLTextureView view = mGLSurfaceViewWeakRef.get();
+                        GLTextureView view = mGLTextureViewWeakRef.get();
                         if (view != null) {
                             view.mRenderer.onSurfaceChanged(gl, w, h);
                         }
@@ -1277,7 +1275,7 @@ private void guardedRun() throws InterruptedException {
                         Log.w("GLThread", "onDrawFrame tid=" + getId());
                     }
                     {
-                        GLTextureView view = mGLSurfaceViewWeakRef.get();
+                        GLTextureView view = mGLTextureViewWeakRef.get();
                         if (view != null) {
                             view.mRenderer.onDrawFrame(gl);
                         }
@@ -1520,7 +1518,7 @@ public void queueEvent(Runnable r) {
          * This weak reference allows the GLTextureView to be garbage collected while the GLThread
          * is still alive.
          */
-        private WeakReference<GLTextureView> mGLSurfaceViewWeakRef;
+        private WeakReference<GLTextureView> mGLTextureViewWeakRef;
 
     }
 
diff --git a/library/src/jp/co/cyberagent/android/gpuimage/GPUImage.java b/library/src/jp/co/cyberagent/android/gpuimage/GPUImage.java
index 8392a5a9..4cba60d5 100644
--- a/library/src/jp/co/cyberagent/android/gpuimage/GPUImage.java
+++ b/library/src/jp/co/cyberagent/android/gpuimage/GPUImage.java
@@ -42,7 +42,6 @@
 import java.io.*;
 import java.net.URL;
 import java.util.List;
-import java.util.concurrent.Semaphore;
 
 /**
  * The main accessor for GPUImage functionality. This class helps to do common
@@ -52,6 +51,7 @@
     private final Context mContext;
     private final GPUImageRenderer mRenderer;
     private GLSurfaceView mGlSurfaceView;
+    private GLTextureView mGLTextureView;
     private GPUImageFilter mFilter;
     private Bitmap mCurrentBitmap;
     private ScaleType mScaleType = ScaleType.CENTER_CROP;
@@ -100,6 +100,21 @@ public void setGLSurfaceView(final GLSurfaceView view) {
         mGlSurfaceView.requestRender();
     }
 
+    /**
+     * Sets the GLTextureView which will display the preview.
+     *
+     * @param view the GLTextureView
+     */
+    public void setGLTextureView(final GLTextureView view) {
+        mGLTextureView = view;
+        mGLTextureView.setEGLContextClientVersion(2);
+        mGLTextureView.setEGLConfigChooser(8, 8, 8, 8, 16, 0);
+        mGLTextureView.setOpaque(false);
+        mGLTextureView.setRenderer(mRenderer);
+        mGLTextureView.setRenderMode(GLTextureView.RENDERMODE_WHEN_DIRTY);
+        mGLTextureView.requestRender();
+    }
+
     /**
      * Sets the background color
      *
@@ -118,6 +133,9 @@ public void requestRender() {
         if (mGlSurfaceView != null) {
             mGlSurfaceView.requestRender();
         }
+        if (mGLTextureView != null) {
+            mGLTextureView.requestRender();
+        }
     }
 
     /**
@@ -139,7 +157,13 @@ public void setUpCamera(final Camera camera) {
      */
     public void setUpCamera(final Camera camera, final int degrees, final boolean flipHorizontal,
             final boolean flipVertical) {
-        mGlSurfaceView.setRenderMode(GLSurfaceView.RENDERMODE_CONTINUOUSLY);
+        if (mGlSurfaceView!= null) {
+            mGlSurfaceView.setRenderMode(GLSurfaceView.RENDERMODE_CONTINUOUSLY);
+        }
+        if (mGLTextureView != null) {
+            mGLTextureView.setRenderMode(GLTextureView.RENDERMODE_CONTINUOUSLY);
+        }
+
         if (Build.VERSION.SDK_INT > Build.VERSION_CODES.GINGERBREAD_MR1) {
             setUpCameraGingerbread(camera);
         } else {
@@ -279,7 +303,7 @@ public Bitmap getBitmapWithFilterApplied() {
      * @return the bitmap with filter applied
      */
     public Bitmap getBitmapWithFilterApplied(final Bitmap bitmap) {
-        if (mGlSurfaceView != null) {
+        if (mGlSurfaceView != null || mGLTextureView != null) {
             mRenderer.deleteImage();
             mRenderer.runOnDraw(new Runnable() {
 
diff --git a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageRenderer.java b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageRenderer.java
index 691550bd..d3e82b9f 100644
--- a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageRenderer.java
+++ b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageRenderer.java
@@ -16,7 +16,6 @@
 
 package jp.co.cyberagent.android.gpuimage;
 
-import android.annotation.TargetApi;
 import android.graphics.Bitmap;
 import android.graphics.Canvas;
 import android.graphics.SurfaceTexture;
@@ -24,7 +23,7 @@
 import android.hardware.Camera.PreviewCallback;
 import android.hardware.Camera.Size;
 import android.opengl.GLES20;
-import android.opengl.GLSurfaceView.Renderer;
+import android.opengl.GLSurfaceView;
 
 import jp.co.cyberagent.android.gpuimage.util.TextureRotationUtil;
 
@@ -40,8 +39,7 @@
 
 import static jp.co.cyberagent.android.gpuimage.util.TextureRotationUtil.TEXTURE_NO_ROTATION;
 
-@TargetApi(11)
-public class GPUImageRenderer implements Renderer, PreviewCallback {
+public class GPUImageRenderer implements GLSurfaceView.Renderer, GLTextureView.Renderer, PreviewCallback {
     public static final int NO_IMAGE = -1;
     static final float CUBE[] = {
             -1.0f, -1.0f,
diff --git a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageView.java b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageView.java
index cc6a0247..5e26f825 100644
--- a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageView.java
+++ b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageView.java
@@ -41,6 +41,7 @@
 public class GPUImageView extends FrameLayout {
 
     private GLSurfaceView mGLSurfaceView;
+    private GLTextureView mGLTextureView;
     private GPUImage mGPUImage;
     private GPUImageFilter mFilter;
     public Size mForceSize = null;
@@ -57,10 +58,21 @@ public GPUImageView(Context context, AttributeSet attrs) {
     }
 
     private void init(Context context, AttributeSet attrs) {
-        mGLSurfaceView = new GPUImageGLSurfaceView(context, attrs);
-        addView(mGLSurfaceView);
+        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.N
+                || Build.VERSION.SDK_INT < Build.VERSION_CODES.ICE_CREAM_SANDWICH) {
+            mGLSurfaceView = new GPUImageGLSurfaceView(context, attrs);
+            addView(mGLSurfaceView);
+        } else {
+            mGLTextureView = new GPUImageTextureView(context, attrs);
+            addView(mGLTextureView);
+        }
         mGPUImage = new GPUImage(getContext());
-        mGPUImage.setGLSurfaceView(mGLSurfaceView);
+        if (mGLSurfaceView != null) {
+            mGPUImage.setGLSurfaceView(mGLSurfaceView);
+        }
+        if (mGLTextureView != null) {
+            mGPUImage.setGLTextureView(mGLTextureView);
+        }
     }
 
     @Override
@@ -110,7 +122,7 @@ public void setBackgroundColor(float red, float green, float blue) {
     // TODO Should be an xml attribute. But then GPUImage can not be distributed as .jar anymore.
     public void setRatio(float ratio) {
         mRatio = ratio;
-        mGLSurfaceView.requestLayout();
+        glViewRequestLayout();
         mGPUImage.deleteImage();
     }
 
@@ -181,7 +193,21 @@ public void setImage(final File file) {
     }
 
     public void requestRender() {
-        mGLSurfaceView.requestRender();
+        if (mGLSurfaceView != null) {
+            mGLSurfaceView.requestRender();
+        }
+        if (mGLTextureView != null) {
+            mGLTextureView.requestRender();
+        }
+    }
+
+    public void glViewRequestLayout() {
+        if (mGLSurfaceView != null) {
+            mGLSurfaceView.requestLayout();
+        }
+        if (mGLTextureView != null) {
+            mGLTextureView.requestLayout();
+        }
     }
 
     /**
@@ -255,7 +281,7 @@ public void run() {
                 // Show loading
                 addView(new LoadingView(getContext()));
 
-                mGLSurfaceView.requestLayout();
+                glViewRequestLayout();
             }
         });
         waiter.acquire();
@@ -276,7 +302,7 @@ public void run() {
         post(new Runnable() {
             @Override
             public void run() {
-                mGLSurfaceView.requestLayout();
+                glViewRequestLayout();
             }
         });
         requestRender();
@@ -292,6 +318,26 @@ public void run() {
         return bitmap;
     }
 
+    private int getGLViewMeasuredWidth() {
+        if (mGLSurfaceView != null) {
+            return mGLSurfaceView.getMeasuredWidth();
+        }
+        if (mGLTextureView != null) {
+            return mGLTextureView.getMeasuredWidth();
+        }
+        return 0;
+    }
+
+    private int getGLViewMeasuredHeight() {
+        if (mGLSurfaceView != null) {
+            return mGLSurfaceView.getMeasuredHeight();
+        }
+        if (mGLTextureView != null) {
+            return mGLTextureView.getMeasuredHeight();
+        }
+        return 0;
+    }
+
     /**
      * Capture the current image with the size as it is displayed and retrieve it as Bitmap.
      * @return current output as Bitmap
@@ -300,8 +346,8 @@ public void run() {
     public Bitmap capture() throws InterruptedException {
         final Semaphore waiter = new Semaphore(0);
 
-        final int width = mGLSurfaceView.getMeasuredWidth();
-        final int height = mGLSurfaceView.getMeasuredHeight();
+        final int width = getGLViewMeasuredWidth();
+        final int height = getGLViewMeasuredHeight();
 
         // Take picture on OpenGL thread
         final int[] pixelMirroredArray = new int[width * height];
@@ -330,17 +376,27 @@ public void run() {
     }
 
     /**
-     * Pauses the GLSurfaceView.
+     * Pauses the GLSurfaceView or GLTextureView.
      */
     public void onPause() {
-        mGLSurfaceView.onPause();
+        if (mGLSurfaceView != null) {
+            mGLSurfaceView.onPause();
+        }
+        if (mGLTextureView != null) {
+            mGLTextureView.onPause();
+        }
     }
 
     /**
-     * Resumes the GLSurfaceView.
+     * Resumes the GLSurfaceView or GLTextureView.
      */
     public void onResume() {
-        mGLSurfaceView.onResume();
+        if (mGLSurfaceView != null) {
+            mGLSurfaceView.onResume();
+        }
+        if (mGLTextureView != null) {
+            mGLTextureView.onResume();
+        }
     }
 
     public static class Size {
@@ -373,6 +429,26 @@ protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
         }
     }
 
+    private class GPUImageTextureView extends GLTextureView {
+        public GPUImageTextureView(Context context) {
+            super(context);
+        }
+
+        public GPUImageTextureView(Context context, AttributeSet attrs) {
+            super(context, attrs);
+        }
+
+        @Override
+        protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
+            if (mForceSize != null) {
+                super.onMeasure(MeasureSpec.makeMeasureSpec(mForceSize.width, MeasureSpec.EXACTLY),
+                        MeasureSpec.makeMeasureSpec(mForceSize.height, MeasureSpec.EXACTLY));
+            } else {
+                super.onMeasure(widthMeasureSpec, heightMeasureSpec);
+            }
+        }
+    }
+
     private class LoadingView extends FrameLayout {
         public LoadingView(Context context) {
             super(context);
diff --git a/library/src/jp/co/cyberagent/android/gpuimage/PixelBuffer.java b/library/src/jp/co/cyberagent/android/gpuimage/PixelBuffer.java
index ac23f599..9ab27495 100644
--- a/library/src/jp/co/cyberagent/android/gpuimage/PixelBuffer.java
+++ b/library/src/jp/co/cyberagent/android/gpuimage/PixelBuffer.java
@@ -32,14 +32,13 @@
 import javax.microedition.khronos.opengles.GL10;
 
 import android.graphics.Bitmap;
-import android.opengl.GLSurfaceView;
 import android.util.Log;
 
 public class PixelBuffer {
     final static String TAG = "PixelBuffer";
     final static boolean LIST_CONFIGS = false;
 
-    GLSurfaceView.Renderer mRenderer; // borrow this interface
+    GPUImageRenderer mRenderer; // borrow this interface
     int mWidth, mHeight;
     Bitmap mBitmap;
 
@@ -89,7 +88,7 @@ public PixelBuffer(final int width, final int height) {
         mThreadOwner = Thread.currentThread().getName();
     }
 
-    public void setRenderer(final GLSurfaceView.Renderer renderer) {
+    public void setRenderer(final GPUImageRenderer renderer) {
         mRenderer = renderer;
 
         // Does this thread own the OpenGL context?
diff --git a/sample/AndroidManifest.xml b/sample/AndroidManifest.xml
index 855b72c5..c64f72b7 100644
--- a/sample/AndroidManifest.xml
+++ b/sample/AndroidManifest.xml
@@ -28,6 +28,10 @@
             android:name="jp.co.cyberagent.android.gpuimage.sample.activity.ActivityCamera"
             android:screenOrientation="portrait"
             android:theme="@style/AppTheme.NoActionBar" />
+        <activity
+            android:name="jp.co.cyberagent.android.gpuimage.sample.activity.ActivityCameraTexture"
+            android:screenOrientation="portrait"
+            android:theme="@style/AppTheme.NoActionBar" />
     </application>
 
 </manifest>
\ No newline at end of file
diff --git a/sample/res/layout/activity_camera_texture.xml b/sample/res/layout/activity_camera_texture.xml
new file mode 100644
index 00000000..27830936
--- /dev/null
+++ b/sample/res/layout/activity_camera_texture.xml
@@ -0,0 +1,49 @@
+<RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android"
+    android:layout_width="match_parent"
+    android:layout_height="match_parent"
+    android:orientation="vertical" >
+
+    <jp.co.cyberagent.android.gpuimage.GLTextureView
+        android:id="@+id/textureView"
+        android:layout_width="match_parent"
+        android:layout_height="match_parent"
+        android:layout_above="@+id/bar" />
+
+    <ImageView
+        android:id="@+id/img_switch_camera"
+        android:layout_width="wrap_content"
+        android:layout_height="wrap_content"
+        android:layout_alignParentRight="true"
+        android:padding="10dp"
+        android:src="@drawable/ic_switch_camera" />
+
+    <LinearLayout
+        android:id="@+id/bar"
+        android:layout_width="match_parent"
+        android:layout_height="wrap_content"
+        android:layout_alignParentBottom="true"
+        android:background="#000000"
+        android:gravity="center_vertical"
+        android:orientation="horizontal" >
+
+        <SeekBar
+            android:id="@+id/seekBar"
+            android:layout_width="0dp"
+            android:layout_height="wrap_content"
+            android:layout_weight="1"
+            android:max="100" />
+
+        <Button
+            android:id="@+id/button_choose_filter"
+            android:layout_width="wrap_content"
+            android:layout_height="wrap_content"
+            android:text="Choose Filter" />
+
+        <ImageButton
+            android:id="@+id/button_capture"
+            android:layout_width="wrap_content"
+            android:layout_height="wrap_content"
+            android:src="@android:drawable/ic_menu_camera" />
+    </LinearLayout>
+
+</RelativeLayout>
\ No newline at end of file
diff --git a/sample/res/layout/activity_main.xml b/sample/res/layout/activity_main.xml
index 6c13bf2f..e6d788c2 100644
--- a/sample/res/layout/activity_main.xml
+++ b/sample/res/layout/activity_main.xml
@@ -24,6 +24,13 @@
             android:layout_height="wrap_content"
             android:drawableTop="@android:drawable/ic_menu_camera"
             android:text="Camera" />
+
+        <Button
+            android:id="@+id/button_camera_texture"
+            android:layout_width="wrap_content"
+            android:layout_height="wrap_content"
+            android:drawableTop="@android:drawable/ic_menu_camera"
+            android:text="Camera Texture" />
     </LinearLayout>
 
 </FrameLayout>
\ No newline at end of file
diff --git a/sample/src/jp/co/cyberagent/android/gpuimage/sample/activity/ActivityCameraTexture.java b/sample/src/jp/co/cyberagent/android/gpuimage/sample/activity/ActivityCameraTexture.java
new file mode 100644
index 00000000..ab0001fb
--- /dev/null
+++ b/sample/src/jp/co/cyberagent/android/gpuimage/sample/activity/ActivityCameraTexture.java
@@ -0,0 +1,295 @@
+/*
+ * Copyright (C) 2012 CyberAgent
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package jp.co.cyberagent.android.gpuimage.sample.activity;
+
+import android.app.Activity;
+import android.graphics.Bitmap;
+import android.graphics.BitmapFactory;
+import android.hardware.Camera;
+import android.hardware.Camera.CameraInfo;
+import android.hardware.Camera.Parameters;
+import android.net.Uri;
+import android.os.Bundle;
+import android.os.Environment;
+import android.util.Log;
+import android.view.View;
+import android.view.View.OnClickListener;
+import android.widget.SeekBar;
+import android.widget.SeekBar.OnSeekBarChangeListener;
+
+import jp.co.cyberagent.android.gpuimage.GLTextureView;
+import jp.co.cyberagent.android.gpuimage.GPUImage;
+import jp.co.cyberagent.android.gpuimage.GPUImage.OnPictureSavedListener;
+import jp.co.cyberagent.android.gpuimage.GPUImageFilter;
+import jp.co.cyberagent.android.gpuimage.sample.GPUImageFilterTools;
+import jp.co.cyberagent.android.gpuimage.sample.GPUImageFilterTools.FilterAdjuster;
+import jp.co.cyberagent.android.gpuimage.sample.GPUImageFilterTools.OnGpuImageFilterChosenListener;
+import jp.co.cyberagent.android.gpuimage.sample.R;
+import jp.co.cyberagent.android.gpuimage.sample.utils.CameraHelper;
+import jp.co.cyberagent.android.gpuimage.sample.utils.CameraHelper.CameraInfo2;
+
+import java.io.File;
+import java.io.FileNotFoundException;
+import java.io.FileOutputStream;
+import java.io.IOException;
+import java.text.SimpleDateFormat;
+import java.util.Date;
+
+public class ActivityCameraTexture extends Activity implements OnSeekBarChangeListener, OnClickListener {
+
+    private GPUImage mGPUImage;
+    private CameraHelper mCameraHelper;
+    private CameraLoader mCamera;
+    private GPUImageFilter mFilter;
+    private FilterAdjuster mFilterAdjuster;
+
+    @Override
+    public void onCreate(final Bundle savedInstanceState) {
+        super.onCreate(savedInstanceState);
+        setContentView(R.layout.activity_camera_texture);
+        ((SeekBar) findViewById(R.id.seekBar)).setOnSeekBarChangeListener(this);
+        findViewById(R.id.button_choose_filter).setOnClickListener(this);
+        findViewById(R.id.button_capture).setOnClickListener(this);
+
+        mGPUImage = new GPUImage(this);
+        mGPUImage.setGLTextureView((GLTextureView) findViewById(R.id.textureView));
+
+        mCameraHelper = new CameraHelper(this);
+        mCamera = new CameraLoader();
+
+        View cameraSwitchView = findViewById(R.id.img_switch_camera);
+        cameraSwitchView.setOnClickListener(this);
+        if (!mCameraHelper.hasFrontCamera() || !mCameraHelper.hasBackCamera()) {
+            cameraSwitchView.setVisibility(View.GONE);
+        }
+    }
+
+    @Override
+    protected void onResume() {
+        super.onResume();
+        mCamera.onResume();
+    }
+
+    @Override
+    protected void onPause() {
+        mCamera.onPause();
+        super.onPause();
+    }
+
+    @Override
+    public void onClick(final View v) {
+        switch (v.getId()) {
+            case R.id.button_choose_filter:
+                GPUImageFilterTools.showDialog(this, new OnGpuImageFilterChosenListener() {
+
+                    @Override
+                    public void onGpuImageFilterChosenListener(final GPUImageFilter filter) {
+                        switchFilterTo(filter);
+                    }
+                });
+                break;
+
+            case R.id.button_capture:
+                if (mCamera.mCameraInstance.getParameters().getFocusMode().equals(
+                        Parameters.FOCUS_MODE_CONTINUOUS_PICTURE)) {
+                    takePicture();
+                } else {
+                    mCamera.mCameraInstance.autoFocus(new Camera.AutoFocusCallback() {
+
+                        @Override
+                        public void onAutoFocus(final boolean success, final Camera camera) {
+                            takePicture();
+                        }
+                    });
+                }
+                break;
+
+            case R.id.img_switch_camera:
+                mCamera.switchCamera();
+                break;
+        }
+    }
+
+    private void takePicture() {
+        // TODO get a size that is about the size of the screen
+        Parameters params = mCamera.mCameraInstance.getParameters();
+        params.setRotation(90);
+        mCamera.mCameraInstance.setParameters(params);
+        for (Camera.Size size : params.getSupportedPictureSizes()) {
+            Log.i("ASDF", "Supported: " + size.width + "x" + size.height);
+        }
+        mCamera.mCameraInstance.takePicture(null, null,
+                new Camera.PictureCallback() {
+
+                    @Override
+                    public void onPictureTaken(byte[] data, final Camera camera) {
+
+                        final File pictureFile = getOutputMediaFile(MEDIA_TYPE_IMAGE);
+                        if (pictureFile == null) {
+                            Log.d("ASDF",
+                                    "Error creating media file, check storage permissions");
+                            return;
+                        }
+
+                        try {
+                            FileOutputStream fos = new FileOutputStream(pictureFile);
+                            fos.write(data);
+                            fos.close();
+                        } catch (FileNotFoundException e) {
+                            Log.d("ASDF", "File not found: " + e.getMessage());
+                        } catch (IOException e) {
+                            Log.d("ASDF", "Error accessing file: " + e.getMessage());
+                        }
+
+                        data = null;
+                        Bitmap bitmap = BitmapFactory.decodeFile(pictureFile.getAbsolutePath());
+                        // mGPUImage.setImage(bitmap);
+                        final GLTextureView view = (GLTextureView) findViewById(R.id.textureView);
+                        view.setRenderMode(GLTextureView.RENDERMODE_WHEN_DIRTY);
+                        mGPUImage.saveToPictures(bitmap, "GPUImage",
+                                System.currentTimeMillis() + ".jpg",
+                                new OnPictureSavedListener() {
+
+                                    @Override
+                                    public void onPictureSaved(final Uri
+                                            uri) {
+                                        pictureFile.delete();
+                                        camera.startPreview();
+                                        view.setRenderMode(GLTextureView.RENDERMODE_CONTINUOUSLY);
+                                    }
+                                });
+                    }
+                });
+    }
+
+    public static final int MEDIA_TYPE_IMAGE = 1;
+    public static final int MEDIA_TYPE_VIDEO = 2;
+
+    private static File getOutputMediaFile(final int type) {
+        // To be safe, you should check that the SDCard is mounted
+        // using Environment.getExternalStorageState() before doing this.
+
+        File mediaStorageDir = new File(Environment.getExternalStoragePublicDirectory(
+                Environment.DIRECTORY_PICTURES), "MyCameraApp");
+        // This location works best if you want the created images to be shared
+        // between applications and persist after your app has been uninstalled.
+
+        // Create the storage directory if it does not exist
+        if (!mediaStorageDir.exists()) {
+            if (!mediaStorageDir.mkdirs()) {
+                Log.d("MyCameraApp", "failed to create directory");
+                return null;
+            }
+        }
+
+        // Create a media file name
+        String timeStamp = new SimpleDateFormat("yyyyMMdd_HHmmss").format(new Date());
+        File mediaFile;
+        if (type == MEDIA_TYPE_IMAGE) {
+            mediaFile = new File(mediaStorageDir.getPath() + File.separator +
+                    "IMG_" + timeStamp + ".jpg");
+        } else if (type == MEDIA_TYPE_VIDEO) {
+            mediaFile = new File(mediaStorageDir.getPath() + File.separator +
+                    "VID_" + timeStamp + ".mp4");
+        } else {
+            return null;
+        }
+
+        return mediaFile;
+    }
+
+    private void switchFilterTo(final GPUImageFilter filter) {
+        if (mFilter == null
+                || (filter != null && !mFilter.getClass().equals(filter.getClass()))) {
+            mFilter = filter;
+            mGPUImage.setFilter(mFilter);
+            mFilterAdjuster = new FilterAdjuster(mFilter);
+        }
+    }
+
+    @Override
+    public void onProgressChanged(final SeekBar seekBar, final int progress,
+            final boolean fromUser) {
+        if (mFilterAdjuster != null) {
+            mFilterAdjuster.adjust(progress);
+        }
+    }
+
+    @Override
+    public void onStartTrackingTouch(final SeekBar seekBar) {
+    }
+
+    @Override
+    public void onStopTrackingTouch(final SeekBar seekBar) {
+    }
+
+    private class CameraLoader {
+
+        private int mCurrentCameraId = 0;
+        private Camera mCameraInstance;
+
+        public void onResume() {
+            setUpCamera(mCurrentCameraId);
+        }
+
+        public void onPause() {
+            releaseCamera();
+        }
+
+        public void switchCamera() {
+            releaseCamera();
+            mCurrentCameraId = (mCurrentCameraId + 1) % mCameraHelper.getNumberOfCameras();
+            setUpCamera(mCurrentCameraId);
+        }
+
+        private void setUpCamera(final int id) {
+            mCameraInstance = getCameraInstance(id);
+            Parameters parameters = mCameraInstance.getParameters();
+            // TODO adjust by getting supportedPreviewSizes and then choosing
+            // the best one for screen size (best fill screen)
+            if (parameters.getSupportedFocusModes().contains(
+                    Parameters.FOCUS_MODE_CONTINUOUS_PICTURE)) {
+                parameters.setFocusMode(Parameters.FOCUS_MODE_CONTINUOUS_PICTURE);
+            }
+            mCameraInstance.setParameters(parameters);
+
+            int orientation = mCameraHelper.getCameraDisplayOrientation(
+                    ActivityCameraTexture.this, mCurrentCameraId);
+            CameraInfo2 cameraInfo = new CameraInfo2();
+            mCameraHelper.getCameraInfo(mCurrentCameraId, cameraInfo);
+            boolean flipHorizontal = cameraInfo.facing == CameraInfo.CAMERA_FACING_FRONT;
+            mGPUImage.setUpCamera(mCameraInstance, orientation, flipHorizontal, false);
+        }
+
+        /** A safe way to get an instance of the Camera object. */
+        private Camera getCameraInstance(final int id) {
+            Camera c = null;
+            try {
+                c = mCameraHelper.openCamera(id);
+            } catch (Exception e) {
+                e.printStackTrace();
+            }
+            return c;
+        }
+
+        private void releaseCamera() {
+            mCameraInstance.setPreviewCallback(null);
+            mCameraInstance.release();
+            mCameraInstance = null;
+        }
+    }
+}
diff --git a/sample/src/jp/co/cyberagent/android/gpuimage/sample/activity/ActivityMain.java b/sample/src/jp/co/cyberagent/android/gpuimage/sample/activity/ActivityMain.java
index 80600ee6..2c6a4f3e 100644
--- a/sample/src/jp/co/cyberagent/android/gpuimage/sample/activity/ActivityMain.java
+++ b/sample/src/jp/co/cyberagent/android/gpuimage/sample/activity/ActivityMain.java
@@ -34,6 +34,7 @@
         setContentView(R.layout.activity_main);
         findViewById(R.id.button_gallery).setOnClickListener(this);
         findViewById(R.id.button_camera).setOnClickListener(this);
+        findViewById(R.id.button_camera_texture).setOnClickListener(this);
     }
 
     @Override public void onClick(final View v) {
@@ -63,7 +64,9 @@ private void startActivity(int id) {
             case R.id.button_camera:
                 startActivity(new Intent(this, ActivityCamera.class));
                 break;
-
+            case R.id.button_camera_texture:
+                startActivity(new Intent(this, ActivityCameraTexture.class));
+                break;
             default:
                 break;
         }
