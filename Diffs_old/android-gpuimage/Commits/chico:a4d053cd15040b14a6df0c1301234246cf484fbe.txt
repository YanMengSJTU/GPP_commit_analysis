diff --git a/.gitignore b/.gitignore
index a026429f..bf1f6e7f 100644
--- a/.gitignore
+++ b/.gitignore
@@ -9,3 +9,6 @@ target/
 build/
 .gradle/
 local.properties
+
+.floo
+.flooignore
diff --git a/library/build.gradle b/library/build.gradle
index 3cd5e8c4..548d8508 100644
--- a/library/build.gradle
+++ b/library/build.gradle
@@ -15,7 +15,7 @@ android {
             moduleName "gpuimage-library"
             stl "gnustl_shared"
             abiFilters "all"
-            ldLibs "log"
+            ldLibs "GLESv2","log"
         }
     }
 
diff --git a/library/jni/gles3PBOreadPixelsFix.c b/library/jni/gles3PBOreadPixelsFix.c
new file mode 100644
index 00000000..a034e51c
--- /dev/null
+++ b/library/jni/gles3PBOreadPixelsFix.c
@@ -0,0 +1,15 @@
+#include <jni.h>
+
+#include <GLES3/gl3.h>
+
+
+#ifdef __cplusplus
+extern "C" {
+    JNIEXPORT void JNICALL Java_com_android_gl2jni_GLES3PBOReadPixelsFix_glReadPixelsPBO(JNIEnv * env, jobject obj, jint x, jint y, jint width, jint height, jint format, jint type, jint offsetPBO);
+};
+#endif
+
+JNIEXPORT void JNICALL Java_com_android_gl2jni_GLES3PBOReadPixelsFix_glReadPixelsPBO(JNIEnv * env, jobject obj, jint x, jint y, jint width, jint height, jint format, jint type, jint offsetPBO)
+{
+    glReadPixels(x, y, width, height, format, type, offsetPBO);
+}
\ No newline at end of file
diff --git a/library/src/com/android/gl2jni/GL2JNIActivity.java b/library/src/com/android/gl2jni/GL2JNIActivity.java
new file mode 100644
index 00000000..2b200776
--- /dev/null
+++ b/library/src/com/android/gl2jni/GL2JNIActivity.java
@@ -0,0 +1,47 @@
+/*
+ * Copyright (C) 2007 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.gl2jni;
+
+import android.app.Activity;
+import android.os.Bundle;
+
+
+public class GL2JNIActivity
+        extends Activity {
+
+    GL2JNIView mView;
+
+    @Override
+    protected void onCreate(Bundle icicle) {
+        super.onCreate(icicle);
+        mView = new GL2JNIView(getApplication());
+        setContentView(mView);
+    }
+
+    @Override
+    protected void onPause() {
+        super.onPause();
+        mView.onPause();
+    }
+
+    @Override
+    protected void onResume() {
+        super.onResume();
+        mView.onResume();
+    }
+
+}
diff --git a/library/src/com/android/gl2jni/GL2JNILib.java b/library/src/com/android/gl2jni/GL2JNILib.java
new file mode 100644
index 00000000..8a32e51b
--- /dev/null
+++ b/library/src/com/android/gl2jni/GL2JNILib.java
@@ -0,0 +1,36 @@
+/*
+ * Copyright (C) 2007 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.gl2jni;
+
+// Wrapper for native library
+
+public class GL2JNILib {
+
+    static {
+        System.loadLibrary("gpuimage-library");
+    }
+
+    /**
+     @param width
+     the current view width
+     @param height
+     the current view height
+     */
+    public static native void init(int width, int height);
+
+    public static native void step();
+}
diff --git a/library/src/com/android/gl2jni/GL2JNIView.java b/library/src/com/android/gl2jni/GL2JNIView.java
new file mode 100644
index 00000000..903881f9
--- /dev/null
+++ b/library/src/com/android/gl2jni/GL2JNIView.java
@@ -0,0 +1,336 @@
+/*
+ * Copyright (C) 2009 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.gl2jni;
+/*
+ * Copyright (C) 2008 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+
+import android.content.Context;
+import android.graphics.PixelFormat;
+import android.opengl.GLSurfaceView;
+import android.util.Log;
+
+import javax.microedition.khronos.egl.EGL10;
+import javax.microedition.khronos.egl.EGLConfig;
+import javax.microedition.khronos.egl.EGLContext;
+import javax.microedition.khronos.egl.EGLDisplay;
+import javax.microedition.khronos.opengles.GL10;
+
+/**
+ * A simple GLSurfaceView sub-class that demonstrate how to perform
+ * OpenGL ES 2.0 rendering into a GL Surface. Note the following important
+ * details:
+ *
+ * - The class must use a custom context factory to enable 2.0 rendering.
+ *   See ContextFactory class definition below.
+ *
+ * - The class must use a custom EGLConfigChooser to be able to select
+ *   an EGLConfig that supports 2.0. This is done by providing a config
+ *   specification to eglChooseConfig() that has the attribute
+ *   EGL10.ELG_RENDERABLE_TYPE containing the EGL_OPENGL_ES2_BIT flag
+ *   set. See ConfigChooser class definition below.
+ *
+ * - The class must select the surface's format, then choose an EGLConfig
+ *   that matches it exactly (with regards to red/green/blue/alpha channels
+ *   bit depths). Failure to do so would result in an EGL_BAD_MATCH error.
+ */
+class GL2JNIView extends GLSurfaceView {
+    private static String TAG = "GL2JNIView";
+    private static final boolean DEBUG = false;
+
+    public GL2JNIView(Context context) {
+        super(context);
+        init(false, 0, 0);
+    }
+
+    public GL2JNIView(Context context, boolean translucent, int depth, int stencil) {
+        super(context);
+        init(translucent, depth, stencil);
+    }
+
+    private void init(boolean translucent, int depth, int stencil) {
+
+        /* By default, GLSurfaceView() creates a RGB_565 opaque surface.
+         * If we want a translucent one, we should change the surface's
+         * format here, using PixelFormat.TRANSLUCENT for GL Surfaces
+         * is interpreted as any 32-bit surface with alpha by SurfaceFlinger.
+         */
+        if (translucent) {
+            this.getHolder().setFormat(PixelFormat.TRANSLUCENT);
+        }
+
+        /* Setup the context factory for 2.0 rendering.
+         * See ContextFactory class definition below
+         */
+        setEGLContextFactory(new ContextFactory());
+
+        /* We need to choose an EGLConfig that matches the format of
+         * our surface exactly. This is going to be done in our
+         * custom config chooser. See ConfigChooser class definition
+         * below.
+         */
+        setEGLConfigChooser( translucent ?
+                             new ConfigChooser(8, 8, 8, 8, depth, stencil) :
+                             new ConfigChooser(5, 6, 5, 0, depth, stencil) );
+
+        /* Set the renderer responsible for frame rendering */
+        setRenderer(new Renderer());
+    }
+
+    private static class ContextFactory implements EGLContextFactory {
+        private static int EGL_CONTEXT_CLIENT_VERSION = 0x3098;
+        public EGLContext createContext(EGL10 egl, EGLDisplay display, EGLConfig eglConfig) {
+            Log.w(TAG, "creating OpenGL ES 2.0 context");
+            checkEglError("Before eglCreateContext", egl);
+            int[] attrib_list = {EGL_CONTEXT_CLIENT_VERSION, 2, EGL10.EGL_NONE };
+            EGLContext context = egl.eglCreateContext(display, eglConfig, EGL10.EGL_NO_CONTEXT, attrib_list);
+            checkEglError("After eglCreateContext", egl);
+            return context;
+        }
+
+        public void destroyContext(EGL10 egl, EGLDisplay display, EGLContext context) {
+            egl.eglDestroyContext(display, context);
+        }
+    }
+
+    private static void checkEglError(String prompt, EGL10 egl) {
+        int error;
+        while ((error = egl.eglGetError()) != EGL10.EGL_SUCCESS) {
+            Log.e(TAG, String.format("%s: EGL error: 0x%x", prompt, error));
+        }
+    }
+
+    private static class ConfigChooser implements EGLConfigChooser {
+
+        public ConfigChooser(int r, int g, int b, int a, int depth, int stencil) {
+            mRedSize = r;
+            mGreenSize = g;
+            mBlueSize = b;
+            mAlphaSize = a;
+            mDepthSize = depth;
+            mStencilSize = stencil;
+        }
+
+        /* This EGL config specification is used to specify 2.0 rendering.
+         * We use a minimum size of 4 bits for red/green/blue, but will
+         * perform actual matching in chooseConfig() below.
+         */
+        private static int EGL_OPENGL_ES2_BIT = 4;
+        private static int[] s_configAttribs2 =
+        {
+            EGL10.EGL_RED_SIZE, 4,
+            EGL10.EGL_GREEN_SIZE, 4,
+            EGL10.EGL_BLUE_SIZE, 4,
+            EGL10.EGL_RENDERABLE_TYPE, EGL_OPENGL_ES2_BIT,
+            EGL10.EGL_NONE
+        };
+
+        public EGLConfig chooseConfig(EGL10 egl, EGLDisplay display) {
+
+            /* Get the number of minimally matching EGL configurations
+             */
+            int[] num_config = new int[1];
+            egl.eglChooseConfig(display, s_configAttribs2, null, 0, num_config);
+
+            int numConfigs = num_config[0];
+
+            if (numConfigs <= 0) {
+                throw new IllegalArgumentException("No configs match configSpec");
+            }
+
+            /* Allocate then read the array of minimally matching EGL configs
+             */
+            EGLConfig[] configs = new EGLConfig[numConfigs];
+            egl.eglChooseConfig(display, s_configAttribs2, configs, numConfigs, num_config);
+
+            if (DEBUG) {
+                 printConfigs(egl, display, configs);
+            }
+            /* Now return the "best" one
+             */
+            return chooseConfig(egl, display, configs);
+        }
+
+        public EGLConfig chooseConfig(EGL10 egl, EGLDisplay display,
+                EGLConfig[] configs) {
+            for(EGLConfig config : configs) {
+                int d = findConfigAttrib(egl, display, config,
+                        EGL10.EGL_DEPTH_SIZE, 0);
+                int s = findConfigAttrib(egl, display, config,
+                        EGL10.EGL_STENCIL_SIZE, 0);
+
+                // We need at least mDepthSize and mStencilSize bits
+                if (d < mDepthSize || s < mStencilSize)
+                    continue;
+
+                // We want an *exact* match for red/green/blue/alpha
+                int r = findConfigAttrib(egl, display, config,
+                        EGL10.EGL_RED_SIZE, 0);
+                int g = findConfigAttrib(egl, display, config,
+                            EGL10.EGL_GREEN_SIZE, 0);
+                int b = findConfigAttrib(egl, display, config,
+                            EGL10.EGL_BLUE_SIZE, 0);
+                int a = findConfigAttrib(egl, display, config,
+                        EGL10.EGL_ALPHA_SIZE, 0);
+
+                if (r == mRedSize && g == mGreenSize && b == mBlueSize && a == mAlphaSize)
+                    return config;
+            }
+            return null;
+        }
+
+        private int findConfigAttrib(EGL10 egl, EGLDisplay display,
+                EGLConfig config, int attribute, int defaultValue) {
+
+            if (egl.eglGetConfigAttrib(display, config, attribute, mValue)) {
+                return mValue[0];
+            }
+            return defaultValue;
+        }
+
+        private void printConfigs(EGL10 egl, EGLDisplay display,
+            EGLConfig[] configs) {
+            int numConfigs = configs.length;
+            Log.w(TAG, String.format("%d configurations", numConfigs));
+            for (int i = 0; i < numConfigs; i++) {
+                Log.w(TAG, String.format("Configuration %d:\n", i));
+                printConfig(egl, display, configs[i]);
+            }
+        }
+
+        private void printConfig(EGL10 egl, EGLDisplay display,
+                EGLConfig config) {
+            int[] attributes = {
+                    EGL10.EGL_BUFFER_SIZE,
+                    EGL10.EGL_ALPHA_SIZE,
+                    EGL10.EGL_BLUE_SIZE,
+                    EGL10.EGL_GREEN_SIZE,
+                    EGL10.EGL_RED_SIZE,
+                    EGL10.EGL_DEPTH_SIZE,
+                    EGL10.EGL_STENCIL_SIZE,
+                    EGL10.EGL_CONFIG_CAVEAT,
+                    EGL10.EGL_CONFIG_ID,
+                    EGL10.EGL_LEVEL,
+                    EGL10.EGL_MAX_PBUFFER_HEIGHT,
+                    EGL10.EGL_MAX_PBUFFER_PIXELS,
+                    EGL10.EGL_MAX_PBUFFER_WIDTH,
+                    EGL10.EGL_NATIVE_RENDERABLE,
+                    EGL10.EGL_NATIVE_VISUAL_ID,
+                    EGL10.EGL_NATIVE_VISUAL_TYPE,
+                    0x3030, // EGL10.EGL_PRESERVED_RESOURCES,
+                    EGL10.EGL_SAMPLES,
+                    EGL10.EGL_SAMPLE_BUFFERS,
+                    EGL10.EGL_SURFACE_TYPE,
+                    EGL10.EGL_TRANSPARENT_TYPE,
+                    EGL10.EGL_TRANSPARENT_RED_VALUE,
+                    EGL10.EGL_TRANSPARENT_GREEN_VALUE,
+                    EGL10.EGL_TRANSPARENT_BLUE_VALUE,
+                    0x3039, // EGL10.EGL_BIND_TO_TEXTURE_RGB,
+                    0x303A, // EGL10.EGL_BIND_TO_TEXTURE_RGBA,
+                    0x303B, // EGL10.EGL_MIN_SWAP_INTERVAL,
+                    0x303C, // EGL10.EGL_MAX_SWAP_INTERVAL,
+                    EGL10.EGL_LUMINANCE_SIZE,
+                    EGL10.EGL_ALPHA_MASK_SIZE,
+                    EGL10.EGL_COLOR_BUFFER_TYPE,
+                    EGL10.EGL_RENDERABLE_TYPE,
+                    0x3042 // EGL10.EGL_CONFORMANT
+            };
+            String[] names = {
+                    "EGL_BUFFER_SIZE",
+                    "EGL_ALPHA_SIZE",
+                    "EGL_BLUE_SIZE",
+                    "EGL_GREEN_SIZE",
+                    "EGL_RED_SIZE",
+                    "EGL_DEPTH_SIZE",
+                    "EGL_STENCIL_SIZE",
+                    "EGL_CONFIG_CAVEAT",
+                    "EGL_CONFIG_ID",
+                    "EGL_LEVEL",
+                    "EGL_MAX_PBUFFER_HEIGHT",
+                    "EGL_MAX_PBUFFER_PIXELS",
+                    "EGL_MAX_PBUFFER_WIDTH",
+                    "EGL_NATIVE_RENDERABLE",
+                    "EGL_NATIVE_VISUAL_ID",
+                    "EGL_NATIVE_VISUAL_TYPE",
+                    "EGL_PRESERVED_RESOURCES",
+                    "EGL_SAMPLES",
+                    "EGL_SAMPLE_BUFFERS",
+                    "EGL_SURFACE_TYPE",
+                    "EGL_TRANSPARENT_TYPE",
+                    "EGL_TRANSPARENT_RED_VALUE",
+                    "EGL_TRANSPARENT_GREEN_VALUE",
+                    "EGL_TRANSPARENT_BLUE_VALUE",
+                    "EGL_BIND_TO_TEXTURE_RGB",
+                    "EGL_BIND_TO_TEXTURE_RGBA",
+                    "EGL_MIN_SWAP_INTERVAL",
+                    "EGL_MAX_SWAP_INTERVAL",
+                    "EGL_LUMINANCE_SIZE",
+                    "EGL_ALPHA_MASK_SIZE",
+                    "EGL_COLOR_BUFFER_TYPE",
+                    "EGL_RENDERABLE_TYPE",
+                    "EGL_CONFORMANT"
+            };
+            int[] value = new int[1];
+            for (int i = 0; i < attributes.length; i++) {
+                int attribute = attributes[i];
+                String name = names[i];
+                if ( egl.eglGetConfigAttrib(display, config, attribute, value)) {
+                    Log.w(TAG, String.format("  %s: %d\n", name, value[0]));
+                } else {
+                    // Log.w(TAG, String.format("  %s: failed\n", name));
+                    while (egl.eglGetError() != EGL10.EGL_SUCCESS);
+                }
+            }
+        }
+
+        // Subclasses can adjust these values:
+        protected int mRedSize;
+        protected int mGreenSize;
+        protected int mBlueSize;
+        protected int mAlphaSize;
+        protected int mDepthSize;
+        protected int mStencilSize;
+        private int[] mValue = new int[1];
+    }
+
+    private static class Renderer implements GLSurfaceView.Renderer {
+        public void onDrawFrame(GL10 gl) {
+            GL2JNILib.step();
+        }
+
+        public void onSurfaceChanged(GL10 gl, int width, int height) {
+            GL2JNILib.init(width, height);
+        }
+
+        public void onSurfaceCreated(GL10 gl, EGLConfig config) {
+            // Do nothing.
+        }
+    }
+}
diff --git a/library/src/com/android/gl2jni/GLES3PBOReadPixelsFix.java b/library/src/com/android/gl2jni/GLES3PBOReadPixelsFix.java
new file mode 100644
index 00000000..d3b6de85
--- /dev/null
+++ b/library/src/com/android/gl2jni/GLES3PBOReadPixelsFix.java
@@ -0,0 +1,14 @@
+package com.android.gl2jni;
+
+public class GLES3PBOReadPixelsFix {
+
+    static {
+        System.loadLibrary("gpuimage-library");
+    }
+
+    // PBO version of glReadPixels()
+    // C function void glReadPixels ( GLint x, GLint y, GLsizei width, GLsizei height, GLenum format, GLenum type, GLvoid *pixels )
+
+    public static native void glReadPixelsPBO(int x, int y, int width, int height, int format, int type, int offsetPBO);
+
+}
diff --git a/library/src/jp/co/cyberagent/android/gpuimage/GPUImage.java b/library/src/jp/co/cyberagent/android/gpuimage/GPUImage.java
index 54aac5a5..49a046b1 100644
--- a/library/src/jp/co/cyberagent/android/gpuimage/GPUImage.java
+++ b/library/src/jp/co/cyberagent/android/gpuimage/GPUImage.java
@@ -36,6 +36,7 @@
 import android.os.Environment;
 import android.os.Handler;
 import android.provider.MediaStore;
+import android.util.Log;
 import android.view.Display;
 import android.view.WindowManager;
 
@@ -52,6 +53,10 @@
  */
 public class GPUImage {
 
+    private static final String LOG_TAG = GPUImage.class.getSimpleName();
+
+    public static int sGLESVersion;
+
     private final Context          mContext;
     private final GPUImageRenderer mRenderer;
     private       GLSurfaceView    mGlSurfaceView;
@@ -66,9 +71,16 @@
      the context
      */
     public GPUImage(final Context context) {
-        if (!supportsOpenGLES2(context)) {
-            throw new IllegalStateException("OpenGL ES 2.0 is not supported on this phone.");
+
+        //        sGLESVersion = 3;
+        if (supportsOpenGLES3(context)) {
+            sGLESVersion = 3;
+        } else if (supportsOpenGLES2(context)) {
+            sGLESVersion = 2;
+        } else {
+            throw new IllegalStateException("OpenGL ES 2.0 is not supported on this device. Buy newer one \\(^o^)/");
         }
+        Log.d(LOG_TAG, "OpenGL ES version: " + sGLESVersion);
 
         mContext = context;
         mFilter = new GPUImageFilter();
@@ -89,6 +101,20 @@ private boolean supportsOpenGLES2(final Context context) {
         return configurationInfo.reqGlEsVersion >= 0x20000;
     }
 
+    /**
+     Checks if OpenGL ES 3.0 is supported on the current device.
+
+     @param context
+     the context
+
+     @return true, if successful
+     */
+    private boolean supportsOpenGLES3(final Context context) {
+        final ActivityManager activityManager = (ActivityManager) context.getSystemService(Context.ACTIVITY_SERVICE);
+        final ConfigurationInfo configurationInfo = activityManager.getDeviceConfigurationInfo();
+        return configurationInfo.reqGlEsVersion >= 0x30000;
+    }
+
     /**
      Sets the GLSurfaceView which will display the preview.
 
@@ -97,7 +123,7 @@ private boolean supportsOpenGLES2(final Context context) {
      */
     public void setGLSurfaceView(final GLSurfaceView view) {
         mGlSurfaceView = view;
-        mGlSurfaceView.setEGLContextClientVersion(2);
+        mGlSurfaceView.setEGLContextClientVersion(sGLESVersion);
         mGlSurfaceView.setEGLConfigChooser(8, 8, 8, 8, 16, 0);
         mGlSurfaceView.getHolder()
                       .setFormat(PixelFormat.RGBA_8888);
@@ -456,7 +482,9 @@ public RenderTask(final Bitmap bitmap, final String folderName, final String fil
 
         @Override
         protected Bitmap doInBackground(final Void... params) {
-            return getBitmapWithFilterApplied(mBitmap);
+            final Bitmap result = getBitmapWithFilterApplied(mBitmap);
+            //            mBitmap.recycle();
+            return result;
         }
 
         @Override
@@ -479,12 +507,24 @@ protected void onPostExecute(final Bitmap result) {
     private class WriteToSDTask
             extends AsyncTask<Void, Void, Void> {
 
+        private static final int SAVE_IMAGE_COMPRESS_QUALITY = 100;
+
         private final Bitmap                 mBitmap;
         private final String                 mFolderName;
         private final String                 mFileName;
         private final OnPictureSavedListener mPictureSavedListener;
         private final Handler                mHandler;
 
+        /**
+         @param bitmap
+         Bitmap that contains image to write to SD
+         @param folderName
+         Folder name inside 'Pictures' to write to
+         @param fileName
+         File name
+         @param pPictureSavedListener
+         Listener triggered when task is completed
+         */
         public WriteToSDTask(final Bitmap bitmap, final String folderName, final String fileName,
                              final OnPictureSavedListener pPictureSavedListener) {
             mBitmap = bitmap;
@@ -506,7 +546,8 @@ private void saveImage(final String folderName, final String fileName, final Bit
             try {
                 file.getParentFile()
                     .mkdirs();
-                image.compress(CompressFormat.JPEG, 100, new FileOutputStream(file));
+                image.compress(CompressFormat.JPEG, SAVE_IMAGE_COMPRESS_QUALITY, new FileOutputStream(file));
+                image.recycle();
                 MediaScannerConnection.scanFile(mContext, new String[]{file.toString()}, null,
                                                 new MediaScannerConnection.OnScanCompletedListener() {
 
diff --git a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageRenderer.java b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageRenderer.java
index 9565b71c..adddfba9 100644
--- a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageRenderer.java
+++ b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageRenderer.java
@@ -26,10 +26,6 @@
 import android.opengl.GLES20;
 import android.opengl.GLSurfaceView.Renderer;
 
-import jp.co.cyberagent.android.gpuimage.util.TextureRotationUtil;
-
-import javax.microedition.khronos.egl.EGLConfig;
-import javax.microedition.khronos.opengles.GL10;
 import java.io.IOException;
 import java.nio.ByteBuffer;
 import java.nio.ByteOrder;
@@ -38,27 +34,28 @@
 import java.util.LinkedList;
 import java.util.Queue;
 
+import javax.microedition.khronos.egl.EGLConfig;
+import javax.microedition.khronos.opengles.GL10;
+
+import jp.co.cyberagent.android.gpuimage.util.TextureRotationUtil;
+
 import static jp.co.cyberagent.android.gpuimage.util.TextureRotationUtil.TEXTURE_NO_ROTATION;
 
 @TargetApi(11)
 public class GPUImageRenderer implements Renderer, PreviewCallback {
-    public static final int NO_IMAGE = -1;
-    static final float CUBE[] = {
-            -1.0f, -1.0f,
-            1.0f, -1.0f,
-            -1.0f, 1.0f,
-            1.0f, 1.0f,
-    };
+
+    public static final int   NO_IMAGE = -1;
+    static final        float CUBE[]   = {-1.0f, -1.0f, 1.0f, -1.0f, -1.0f, 1.0f, 1.0f, 1.0f,};
 
     private GPUImageFilter mFilter;
 
     public final Object mSurfaceChangedWaiter = new Object();
 
-    private int mGLTextureId = NO_IMAGE;
+    private int            mGLTextureId    = NO_IMAGE;
     private SurfaceTexture mSurfaceTexture = null;
     private final FloatBuffer mGLCubeBuffer;
     private final FloatBuffer mGLTextureBuffer;
-    private IntBuffer mGLRgbBuffer;
+    private       IntBuffer   mGLRgbBuffer;
 
     private int mOutputWidth;
     private int mOutputHeight;
@@ -68,9 +65,9 @@
 
     private final Queue<Runnable> mRunOnDraw;
     private final Queue<Runnable> mRunOnDrawEnd;
-    private Rotation mRotation;
-    private boolean mFlipHorizontal;
-    private boolean mFlipVertical;
+    private       Rotation        mRotation;
+    private       boolean         mFlipHorizontal;
+    private       boolean         mFlipVertical;
     private GPUImage.ScaleType mScaleType = GPUImage.ScaleType.CENTER_CROP;
 
     public GPUImageRenderer(final GPUImageFilter filter) {
@@ -79,13 +76,14 @@ public GPUImageRenderer(final GPUImageFilter filter) {
         mRunOnDrawEnd = new LinkedList<Runnable>();
 
         mGLCubeBuffer = ByteBuffer.allocateDirect(CUBE.length * 4)
-                .order(ByteOrder.nativeOrder())
-                .asFloatBuffer();
-        mGLCubeBuffer.put(CUBE).position(0);
+                                  .order(ByteOrder.nativeOrder())
+                                  .asFloatBuffer();
+        mGLCubeBuffer.put(CUBE)
+                     .position(0);
 
         mGLTextureBuffer = ByteBuffer.allocateDirect(TEXTURE_NO_ROTATION.length * 4)
-                .order(ByteOrder.nativeOrder())
-                .asFloatBuffer();
+                                     .order(ByteOrder.nativeOrder())
+                                     .asFloatBuffer();
         setRotation(Rotation.NORMAL, false, false);
     }
 
@@ -138,8 +136,7 @@ public void onPreviewFrame(final byte[] data, final Camera camera) {
             runOnDraw(new Runnable() {
                 @Override
                 public void run() {
-                    GPUImageNativeLibrary.YUVtoRBGA(data, previewSize.width, previewSize.height,
-                            mGLRgbBuffer.array());
+                    GPUImageNativeLibrary.YUVtoRBGA(data, previewSize.width, previewSize.height, mGLRgbBuffer.array());
                     mGLTextureId = OpenGlUtils.loadTexture(mGLRgbBuffer, previewSize, mGLTextureId);
                     camera.addCallbackBuffer(data);
 
@@ -160,6 +157,7 @@ public void run() {
                 int[] textures = new int[1];
                 GLES20.glGenTextures(1, textures, 0);
                 mSurfaceTexture = new SurfaceTexture(textures[0]);
+                // FIXME when camera is released shouldn't call setPreviewTexture
                 try {
                     camera.setPreviewTexture(mSurfaceTexture);
                     camera.setPreviewCallback(GPUImageRenderer.this);
@@ -226,8 +224,8 @@ public void run() {
                     mAddedPadding = 0;
                 }
 
-                mGLTextureId = OpenGlUtils.loadTexture(
-                        resizedBitmap != null ? resizedBitmap : bitmap, mGLTextureId, recycle);
+                mGLTextureId = OpenGlUtils.loadTexture(resizedBitmap != null ? resizedBitmap : bitmap, mGLTextureId,
+                                                       recycle);
                 if (resizedBitmap != null) {
                     resizedBitmap.recycle();
                 }
diff --git a/library/src/jp/co/cyberagent/android/gpuimage/PixelBuffer.java b/library/src/jp/co/cyberagent/android/gpuimage/PixelBuffer.java
index 45317a13..fe516063 100644
--- a/library/src/jp/co/cyberagent/android/gpuimage/PixelBuffer.java
+++ b/library/src/jp/co/cyberagent/android/gpuimage/PixelBuffer.java
@@ -8,6 +8,30 @@
 
 package jp.co.cyberagent.android.gpuimage;
 
+import android.annotation.TargetApi;
+import android.graphics.Bitmap;
+import android.opengl.GLES11Ext;
+import android.opengl.GLES20;
+import android.opengl.GLES30;
+import android.opengl.GLSurfaceView;
+import android.os.Build;
+import android.util.Log;
+
+import com.android.gl2jni.GLES3PBOReadPixelsFix;
+
+import java.nio.ByteBuffer;
+import java.nio.ByteOrder;
+import java.nio.IntBuffer;
+
+import javax.microedition.khronos.egl.EGL10;
+import javax.microedition.khronos.egl.EGLConfig;
+import javax.microedition.khronos.egl.EGLContext;
+import javax.microedition.khronos.egl.EGLDisplay;
+import javax.microedition.khronos.egl.EGLSurface;
+import javax.microedition.khronos.opengles.GL10;
+
+import jp.co.cyberagent.android.gpuimage.util.UtilsGL;
+
 import static javax.microedition.khronos.egl.EGL10.EGL_ALPHA_SIZE;
 import static javax.microedition.khronos.egl.EGL10.EGL_BLUE_SIZE;
 import static javax.microedition.khronos.egl.EGL10.EGL_DEFAULT_DISPLAY;
@@ -19,65 +43,47 @@
 import static javax.microedition.khronos.egl.EGL10.EGL_RED_SIZE;
 import static javax.microedition.khronos.egl.EGL10.EGL_STENCIL_SIZE;
 import static javax.microedition.khronos.egl.EGL10.EGL_WIDTH;
-import static javax.microedition.khronos.opengles.GL10.GL_RGBA;
 import static javax.microedition.khronos.opengles.GL10.GL_UNSIGNED_BYTE;
 
-import java.nio.IntBuffer;
-
-import javax.microedition.khronos.egl.EGL10;
-import javax.microedition.khronos.egl.EGLConfig;
-import javax.microedition.khronos.egl.EGLContext;
-import javax.microedition.khronos.egl.EGLDisplay;
-import javax.microedition.khronos.egl.EGLSurface;
-import javax.microedition.khronos.opengles.GL10;
+public class PixelBuffer {
 
-import android.graphics.Bitmap;
-import android.opengl.GLSurfaceView;
-import android.util.Log;
+    private static final String LOG_TAG = PixelBuffer.class.getSimpleName();
 
-public class PixelBuffer {
-    final static String TAG = "PixelBuffer";
     final static boolean LIST_CONFIGS = false;
 
     GLSurfaceView.Renderer mRenderer; // borrow this interface
-    int mWidth, mHeight;
+    int                    mWidth, mHeight;
     Bitmap mBitmap;
 
-    EGL10 mEGL;
-    EGLDisplay mEGLDisplay;
+    EGL10       mEGL;
+    EGLDisplay  mEGLDisplay;
     EGLConfig[] mEGLConfigs;
-    EGLConfig mEGLConfig;
-    EGLContext mEGLContext;
-    EGLSurface mEGLSurface;
-    GL10 mGL;
+    EGLConfig   mEGLConfig;
+    EGLContext  mEGLContext;
+    EGLSurface  mEGLSurface;
+    GL10        mGL;
 
     String mThreadOwner;
+    private int[] mPboHandleContainer;
 
     public PixelBuffer(final int width, final int height) {
         mWidth = width;
         mHeight = height;
 
         int[] version = new int[2];
-        int[] attribList = new int[] {
-                EGL_WIDTH, mWidth,
-                EGL_HEIGHT, mHeight,
-                EGL_NONE
-        };
+        int[] attribList = new int[]{EGL_WIDTH, mWidth, EGL_HEIGHT, mHeight, EGL_NONE};
 
         // No error checking performed, minimum required code to elucidate logic
         mEGL = (EGL10) EGLContext.getEGL();
         mEGLDisplay = mEGL.eglGetDisplay(EGL_DEFAULT_DISPLAY);
         mEGL.eglInitialize(mEGLDisplay, version);
         mEGLConfig = chooseConfig(); // Choosing a config is a little more
-                                     // complicated
+        // complicated
 
         // mEGLContext = mEGL.eglCreateContext(mEGLDisplay, mEGLConfig,
         // EGL_NO_CONTEXT, null);
         int EGL_CONTEXT_CLIENT_VERSION = 0x3098;
-        int[] attrib_list = {
-                EGL_CONTEXT_CLIENT_VERSION, 2,
-                EGL10.EGL_NONE
-        };
+        int[] attrib_list = {EGL_CONTEXT_CLIENT_VERSION, 2, EGL10.EGL_NONE};
         mEGLContext = mEGL.eglCreateContext(mEGLDisplay, mEGLConfig, EGL_NO_CONTEXT, attrib_list);
 
         mEGLSurface = mEGL.eglCreatePbufferSurface(mEGLDisplay, mEGLConfig, attribList);
@@ -86,15 +92,40 @@ public PixelBuffer(final int width, final int height) {
         mGL = (GL10) mEGLContext.getGL();
 
         // Record thread owner of OpenGL context
-        mThreadOwner = Thread.currentThread().getName();
+        mThreadOwner = Thread.currentThread()
+                             .getName();
+
+        if (GPUImage.sGLESVersion == 3) {
+            this.setupPBO();
+        }
+
+    }
+
+    @TargetApi(Build.VERSION_CODES.JELLY_BEAN_MR2)
+    private void setupPBO() {
+
+        // Create PBO
+        mPboHandleContainer = new int[1];
+        GLES30.glGenBuffers(1, mPboHandleContainer, 0);
+
+        UtilsGL.logErrorGL("glGenBuffers x1");
+        GLES30.glBindBuffer(GLES30.GL_PIXEL_PACK_BUFFER, mPboHandleContainer[0]);
+        UtilsGL.logErrorGL("glBindBuffer pix pbo create");
+        GLES30.glBufferData(GLES30.GL_PIXEL_PACK_BUFFER, mWidth * mHeight * 4, null, GLES30.GL_STATIC_DRAW);
+        UtilsGL.logErrorGL("glBufferData pix pbo");
+        GLES30.glBindBuffer(GLES30.GL_PIXEL_PACK_BUFFER, 0);
+        UtilsGL.logErrorGL("glBindBuffer pix 0 create end");
+
     }
 
     public void setRenderer(final GLSurfaceView.Renderer renderer) {
         mRenderer = renderer;
 
         // Does this thread own the OpenGL context?
-        if (!Thread.currentThread().getName().equals(mThreadOwner)) {
-            Log.e(TAG, "setRenderer: This thread does not own the OpenGL context.");
+        if (!Thread.currentThread()
+                   .getName()
+                   .equals(mThreadOwner)) {
+            Log.e(LOG_TAG, "setRenderer: This thread does not own the OpenGL context.");
             return;
         }
 
@@ -106,13 +137,15 @@ public void setRenderer(final GLSurfaceView.Renderer renderer) {
     public Bitmap getBitmap() {
         // Do we have a renderer?
         if (mRenderer == null) {
-            Log.e(TAG, "getBitmap: Renderer was not set.");
+            Log.e(LOG_TAG, "getBitmap: Renderer was not set.");
             return null;
         }
 
         // Does this thread own the OpenGL context?
-        if (!Thread.currentThread().getName().equals(mThreadOwner)) {
-            Log.e(TAG, "getBitmap: This thread does not own the OpenGL context.");
+        if (!Thread.currentThread()
+                   .getName()
+                   .equals(mThreadOwner)) {
+            Log.e(LOG_TAG, "getBitmap: This thread does not own the OpenGL context.");
             return null;
         }
 
@@ -127,8 +160,7 @@ public Bitmap getBitmap() {
     public void destroy() {
         mRenderer.onDrawFrame(mGL);
         mRenderer.onDrawFrame(mGL);
-        mEGL.eglMakeCurrent(mEGLDisplay, EGL10.EGL_NO_SURFACE,
-                EGL10.EGL_NO_SURFACE, EGL10.EGL_NO_CONTEXT);
+        mEGL.eglMakeCurrent(mEGLDisplay, EGL10.EGL_NO_SURFACE, EGL10.EGL_NO_SURFACE, EGL10.EGL_NO_CONTEXT);
 
         mEGL.eglDestroySurface(mEGLDisplay, mEGLSurface);
         mEGL.eglDestroyContext(mEGLDisplay, mEGLContext);
@@ -136,16 +168,9 @@ public void destroy() {
     }
 
     private EGLConfig chooseConfig() {
-        int[] attribList = new int[] {
-                EGL_DEPTH_SIZE, 0,
-                EGL_STENCIL_SIZE, 0,
-                EGL_RED_SIZE, 8,
-                EGL_GREEN_SIZE, 8,
-                EGL_BLUE_SIZE, 8,
-                EGL_ALPHA_SIZE, 8,
-                EGL10.EGL_RENDERABLE_TYPE, 4,
-                EGL_NONE
-        };
+        int[] attribList =
+                new int[]{EGL_DEPTH_SIZE, 0, EGL_STENCIL_SIZE, 0, EGL_RED_SIZE, 8, EGL_GREEN_SIZE, 8, EGL_BLUE_SIZE, 8,
+                          EGL_ALPHA_SIZE, 8, EGL10.EGL_RENDERABLE_TYPE, 4, EGL_NONE};
 
         // No error checking performed, minimum required code to elucidate logic
         // Expand on this logic to be more selective in choosing a configuration
@@ -163,7 +188,7 @@ private EGLConfig chooseConfig() {
     }
 
     private void listConfig() {
-        Log.i(TAG, "Config List {");
+        Log.i(LOG_TAG, "Config List {");
 
         for (EGLConfig config : mEGLConfigs) {
             int d, s, r, g, b, a;
@@ -175,35 +200,135 @@ private void listConfig() {
             g = getConfigAttrib(config, EGL_GREEN_SIZE);
             b = getConfigAttrib(config, EGL_BLUE_SIZE);
             a = getConfigAttrib(config, EGL_ALPHA_SIZE);
-            Log.i(TAG, "    <d,s,r,g,b,a> = <" + d + "," + s + "," +
-                    r + "," + g + "," + b + "," + a + ">");
+            Log.i(LOG_TAG, "    <d,s,r,g,b,a> = <" + d + "," + s + "," +
+                           r + "," + g + "," + b + "," + a + ">");
         }
 
-        Log.i(TAG, "}");
+        Log.i(LOG_TAG, "}");
     }
 
     private int getConfigAttrib(final EGLConfig config, final int attribute) {
         int[] value = new int[1];
-        return mEGL.eglGetConfigAttrib(mEGLDisplay, config,
-                attribute, value) ? value[0] : 0;
+        return mEGL.eglGetConfigAttrib(mEGLDisplay, config, attribute, value) ? value[0] : 0;
     }
 
     private void convertToBitmap() {
         int[] iat = new int[mWidth * mHeight];
-        IntBuffer ib = IntBuffer.allocate(mWidth * mHeight);
-        mGL.glReadPixels(0, 0, mWidth, mHeight, GL_RGBA, GL_UNSIGNED_BYTE, ib);
-        int[] ia = ib.array();
+        int[] ia;
+
+        ia = this.readPixelsGLES2();
+
+        //        Log.i(LOG_TAG, "GPUImage GLES version = " + GPUImage.sGLESVersion);
+        //        if (GPUImage.sGLESVersion == 3) {
+        //            ia = this.readPixelsGLES3();
+        //        } else {
+        //            ia = this.readPixelsGLES2();
+        //        }
 
         // Convert upside down mirror-reversed image to right-side up normal
         // image.
         for (int i = 0; i < mHeight; i++) {
-            for (int j = 0; j < mWidth; j++) {
-                iat[(mHeight - i - 1) * mWidth + j] = ia[i * mWidth + j];
-            }
+            ia[i] = ia[i];
+        }
+        for (int i = 0; i < mHeight; i++) {
+
+            System.arraycopy(ia, i * mWidth, iat, (mHeight - i - 1) * mWidth, mWidth);
         }
-        
 
+        if (mBitmap != null) {
+            mBitmap.recycle();
+        }
         mBitmap = Bitmap.createBitmap(mWidth, mHeight, Bitmap.Config.ARGB_8888);
         mBitmap.copyPixelsFromBuffer(IntBuffer.wrap(iat));
     }
-}
+
+    @TargetApi(Build.VERSION_CODES.JELLY_BEAN_MR2)
+    private int[] readPixelsGLES3() {
+
+        long time = System.currentTimeMillis();
+
+        //set framebuffer to read from
+        GLES30.glReadBuffer(GLES30.GL_BACK);
+        UtilsGL.logErrorGL("glReadBuffer back");
+
+        Log.d(LOG_TAG, "1. glReadBuffer: " + (System.currentTimeMillis() - time));
+        time = System.currentTimeMillis();
+
+        // bind pbo
+        GLES30.glBindBuffer(GLES30.GL_PIXEL_PACK_BUFFER, mPboHandleContainer[0]);
+        UtilsGL.logErrorGL("glBindBuffer pix pbo write");
+
+        Log.d(LOG_TAG, "2. glBindBuffer: " + (System.currentTimeMillis() - time));
+        time = System.currentTimeMillis();
+
+
+        // read pixels(should be instant)
+        GLES3PBOReadPixelsFix.glReadPixelsPBO(0, 0, mWidth, mHeight, GLES30.GL_RGBA, GLES30.GL_UNSIGNED_BYTE, 0);
+        UtilsGL.logErrorGL("glReadPixels");
+
+        Log.d(LOG_TAG, "3. glReadPixels: " + (System.currentTimeMillis() - time));
+        time = System.currentTimeMillis();
+
+        // map pbo to bb
+        ByteBuffer byteBuffer =
+                ((ByteBuffer) GLES30.glMapBufferRange(GLES30.GL_PIXEL_PACK_BUFFER, 0, 4 * mWidth * mHeight,
+                                                      GLES30.GL_MAP_READ_BIT)).order(ByteOrder.nativeOrder());
+        UtilsGL.logErrorGL("glMapBufferRange");
+
+        Log.d(LOG_TAG, "4. glMapBufferRange: " + (System.currentTimeMillis() - time));
+        time = System.currentTimeMillis();
+
+
+        IntBuffer result = byteBuffer.asIntBuffer();
+
+        int[] pixels;
+        result.position(0);
+        if (!result.hasArray()) {
+
+            pixels = new int[result.capacity()];
+            result.get(pixels);
+
+        } else {
+            pixels = result.array();
+        }
+
+        Log.d(LOG_TAG, "5. pixels IntBuffer -> int[]: " + (System.currentTimeMillis() - time));
+        time = System.currentTimeMillis();
+
+
+        // unmap pbo
+        GLES30.glUnmapBuffer(GLES30.GL_PIXEL_PACK_BUFFER);
+        UtilsGL.logErrorGL("glUnmapBuffer pix");
+
+        Log.d(LOG_TAG, "6. glUnmapBuffer pix: " + (System.currentTimeMillis() - time));
+        time = System.currentTimeMillis();
+
+
+        // unbind pbo
+        GLES30.glBindBuffer(GLES30.GL_PIXEL_PACK_BUFFER, 0);
+        UtilsGL.logErrorGL("glBindBuffer pix 0 end");
+
+        Log.d(LOG_TAG, "7. glBindBuffer pix 0: " + (System.currentTimeMillis() - time));
+
+        return pixels;
+    }
+
+    private int[] readPixelsGLES2() {
+
+        String GLESExtensions = mGL.glGetString(GL10.GL_EXTENSIONS);
+
+        final IntBuffer ib = IntBuffer.allocate(mWidth * mHeight);
+
+        boolean hasBGRA = GLESExtensions.contains("GL_EXT_texture_format_BGRA8888");
+
+
+        if(hasBGRA){
+            GLES20.glPixelStorei(GLES20.GL_PACK_ALIGNMENT, 1);
+            GLES20.glPixelStorei(GLES20.GL_UNPACK_ALIGNMENT, 1);// maybe don't need that
+        }
+        GLES20.glReadPixels(0, 0, mWidth, mHeight, hasBGRA ? GLES11Ext.GL_BGRA : GLES20.GL_RGB, GL_UNSIGNED_BYTE, ib);
+
+        return ib.array();
+    }
+
+}
\ No newline at end of file
diff --git a/library/src/jp/co/cyberagent/android/gpuimage/util/UtilsGL.java b/library/src/jp/co/cyberagent/android/gpuimage/util/UtilsGL.java
new file mode 100644
index 00000000..e13875bc
--- /dev/null
+++ b/library/src/jp/co/cyberagent/android/gpuimage/util/UtilsGL.java
@@ -0,0 +1,52 @@
+package jp.co.cyberagent.android.gpuimage.util;
+
+import android.opengl.GLES20;
+import android.opengl.GLU;
+import android.util.Log;
+
+/**
+ <p> Utility class for OpenGL </p>
+ */
+public class UtilsGL {
+
+    private static final String LOG_TAG = UtilsGL.class.getSimpleName();
+
+    /**
+     <p> Checks given integer for being power of two </p>
+
+     @param pNumber
+     integer to check for being power of two
+
+     @return true if supplied integer is power of two, false otherwise
+     */
+    public static boolean isPowerOfTwo(final int pNumber) {
+        return (pNumber & -pNumber) == pNumber;
+    }
+
+    /**
+     <p> 4-byte allocation needed for float type </p>
+     */
+    public static final int BYTES_PER_FLOAT = 4;
+
+    /**
+     <p> 2-byte allocation needed for short type </p>
+     */
+    public static final int BYTES_PER_SHORT = 2;
+
+    /**
+     <p> Queries OpenGL for errors and if there have been some - shows all found information in logs </p>
+
+     @param pMessage
+     additional message to show in logs if error found
+     */
+    public static void logErrorGL(final String pMessage) {
+
+        final int error = GLES20.glGetError();
+        if (error != GLES20.GL_NO_ERROR) {
+            Log.e(UtilsGL.LOG_TAG, (pMessage == null ? "" : pMessage + " >>> ") + "Opengl error " + error + ": " +
+                                   GLU.gluErrorString(error));
+        }
+
+    }
+
+}
\ No newline at end of file
diff --git a/sample/src/jp/co/cyberagent/android/gpuimage/sample/activity/ActivityCamera.java b/sample/src/jp/co/cyberagent/android/gpuimage/sample/activity/ActivityCamera.java
index 5f6e5fba..0028e683 100644
--- a/sample/src/jp/co/cyberagent/android/gpuimage/sample/activity/ActivityCamera.java
+++ b/sample/src/jp/co/cyberagent/android/gpuimage/sample/activity/ActivityCamera.java
@@ -135,14 +135,15 @@ private void takePicture() {
         // Setting best quality of photo taken by camera(highest resolution & 100% jpeg quality)
         int resolutionMultiplied = 0;
         for (Camera.Size size : params.getSupportedPictureSizes()) {
-            Log.i("ASDF", "Supported: " + size.width + "x" + size.height);
+//            Log.i("ASDF", "Supported: " + size.width + "x" + size.height);
             final int newResMult = size.width * size.height;
             if (newResMult > resolutionMultiplied) {
                 resolutionMultiplied = newResMult;
                 params.setPictureSize(size.width, size.height);
             }
         }
-        params.setJpegQuality(100);
+        Log.i("ASDF", "picture size: " + params.getPictureSize().width + "x" + params.getPictureSize().height);
+        params.setJpegQuality(90);
 
         mCamera.mCameraInstance.setParameters(params);
 
