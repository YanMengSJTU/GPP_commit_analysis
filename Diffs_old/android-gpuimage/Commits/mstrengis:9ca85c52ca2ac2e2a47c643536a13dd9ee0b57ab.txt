diff --git a/library/src/jp/co/cyberagent/android/gpuimage/GPUImage.java b/library/src/jp/co/cyberagent/android/gpuimage/GPUImage.java
index 6eed85de..bd6ba7f3 100644
--- a/library/src/jp/co/cyberagent/android/gpuimage/GPUImage.java
+++ b/library/src/jp/co/cyberagent/android/gpuimage/GPUImage.java
@@ -16,14 +16,6 @@
 
 package jp.co.cyberagent.android.gpuimage;
 
-import java.io.File;
-import java.io.FileNotFoundException;
-import java.io.FileOutputStream;
-import java.io.IOException;
-import java.util.List;
-import java.util.concurrent.Semaphore;
-
-import jp.co.cyberagent.android.gpuimage.GPUImageRenderer.Rotation;
 import android.annotation.TargetApi;
 import android.app.ActivityManager;
 import android.content.Context;
@@ -45,29 +37,37 @@
 import android.provider.MediaStore;
 import android.view.Display;
 import android.view.WindowManager;
+import jp.co.cyberagent.android.gpuimage.GPUImageRenderer.Rotation;
+
+import java.io.File;
+import java.io.FileNotFoundException;
+import java.io.FileOutputStream;
+import java.io.IOException;
+import java.util.List;
+import java.util.concurrent.Semaphore;
 
 /**
  * The main accessor for GPUImage functionality. This class helps to do common
  * tasks through a simple interface.
  */
-public class GPUImage {
+public class GPUImage {  
     private final Context mContext;
     private final GPUImageRenderer mRenderer;
     private GLSurfaceView mGlSurfaceView;
     private GPUImageFilter mFilter;
     private Bitmap mCurrentBitmap;
 
-    /**
-     * Instantiates a new GPUImage object.
+    /**    
+     * Instantiates a new GPUImage object.   
      * 
      * @param context the context
      */
-    public GPUImage(final Context context) {
+    public GPUImage(final Context context) {  
         if (!supportsOpenGLES2(context)) {
             throw new IllegalStateException("OpenGL ES 2.0 is not supported on this phone.");
         }
-
-        mContext = context;
+ 
+        mContext = context; 
         mFilter = new GPUImageFilter();
         mRenderer = new GPUImageRenderer(mFilter);
     }
@@ -239,7 +239,7 @@ public Bitmap getBitmapWithFilterApplied(final Bitmap bitmap) {
 
                 @Override
                 public void run() {
-                    mFilter.onDestroy();
+                    mFilter.destroy();
                     lock.release();
                 }
             });
@@ -259,7 +259,7 @@ public void run() {
         buffer.setRenderer(renderer);
         renderer.setImageBitmap(bitmap, false);
         Bitmap result = buffer.getBitmap();
-        mFilter.onDestroy();
+        mFilter.destroy();
         renderer.deleteImage();
         buffer.destroy();
 
@@ -296,7 +296,7 @@ public static void getBitmapForMultipleFilters(final Bitmap bitmap,
         for (GPUImageFilter filter : filters) {
             renderer.setFilter(filter);
             listener.response(buffer.getBitmap());
-            filter.onDestroy();
+            filter.destroy();
         }
         renderer.deleteImage();
         buffer.destroy();
diff --git a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageBlendFilter.java b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageBlendFilter.java
new file mode 100644
index 00000000..062b847d
--- /dev/null
+++ b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageBlendFilter.java
@@ -0,0 +1,848 @@
+package jp.co.cyberagent.android.gpuimage;
+
+import java.nio.ByteBuffer;
+import java.nio.FloatBuffer;
+
+import android.content.Context;
+import android.opengl.GLES20;
+
+public class GPUImageBlendFilter extends GPUImageTwoInputFilter{
+	
+	private int mixUniform = -1; //for alpha blending
+	private float alpha = 0.5f; //for alpha blending
+	private boolean needSetAlpha = false; //for alpha blending
+	
+	
+	private String mCurrentBlendMode = null;
+	
+	public GPUImageBlendFilter( String blendMode, Context context ){
+		super(context, blendMode );
+		mCurrentBlendMode = blendMode;
+	}
+	
+	@Override
+	public void onInit(){
+		super.onInit();
+		mixUniform = GLES20.glGetUniformLocation(mGLProgId, "mixturePercent");
+	}
+	
+	@Override
+	public void onDraw(int textureId, FloatBuffer cubeBuffer, FloatBuffer textureBuffer){
+		super.onDraw(textureId, cubeBuffer, textureBuffer);
+		if(needSetAlpha){
+			needSetAlpha = false;
+			setAlphaBlendOpacity( alpha );
+		}
+	}
+	
+	public void setAlphaBlendOpacity(float mix){
+		if(mCurrentBlendMode != BLEND_MODE_ALPHA){
+			return;
+		}
+		alpha = mix;
+		if(mixUniform == -1){
+			needSetAlpha = true;
+		}else{
+			this.setFloat(mixUniform, mix);
+		}
+	}
+	
+	public void setColor(final int r, final int g, final int b, final int alpha){
+		runOnDraw(new Runnable(){
+			public void run(){
+				int[] textureId = new int[1];
+		        byte[] pixels = {  
+		            (byte)r,  (byte) g,  (byte) b,  (byte) alpha 
+		        };
+		        
+		        ByteBuffer pixelBuffer = ByteBuffer.allocateDirect(1*4);
+		        pixelBuffer.put(pixels).position(0);
+
+		        GLES20.glPixelStorei ( GLES20.GL_UNPACK_ALIGNMENT, 1 );
+		        textureId[0] = filterSourceTexture2;
+		        GLES20.glActiveTexture( GLES20.GL_TEXTURE3 );
+		        GLES20.glGenTextures ( 1, textureId, 0 );
+		        GLES20.glBindTexture ( GLES20.GL_TEXTURE_2D, textureId[0] );
+		        GLES20.glTexImage2D ( GLES20.GL_TEXTURE_2D, 0, GLES20.GL_RGBA, 1, 1, 0, GLES20.GL_RGBA, GLES20.GL_UNSIGNED_BYTE, pixelBuffer );
+		        GLES20.glTexParameteri ( GLES20.GL_TEXTURE_2D, GLES20.GL_TEXTURE_MIN_FILTER, GLES20.GL_NEAREST );
+		        GLES20.glTexParameteri ( GLES20.GL_TEXTURE_2D, GLES20.GL_TEXTURE_MAG_FILTER, GLES20.GL_NEAREST );
+		        filterSourceTexture2 = textureId[0];
+			}
+		});
+	}
+	
+	
+	public static final String BLEND_MODE_SOURCE_OVER = "varying highp vec2 textureCoordinate;\n" + 
+			" varying highp vec2 textureCoordinate2;\n" + 
+			" \n" + 
+			" uniform sampler2D inputImageTexture;\n" + 
+			" uniform sampler2D inputImageTexture2;\n" + 
+			" \n" + 
+			" highp float lum(lowp vec3 c) {\n" + 
+			"     return dot(c, vec3(0.3, 0.59, 0.11));\n" + 
+			" }\n" + 
+			" \n" + 
+			" lowp vec3 clipcolor(lowp vec3 c) {\n" + 
+			"     highp float l = lum(c);\n" + 
+			"     lowp float n = min(min(c.r, c.g), c.b);\n" + 
+			"     lowp float x = max(max(c.r, c.g), c.b);\n" + 
+			"     \n" + 
+			"     if (n < 0.0) {\n" + 
+			"         c.r = l + ((c.r - l) * l) / (l - n);\n" + 
+			"         c.g = l + ((c.g - l) * l) / (l - n);\n" + 
+			"         c.b = l + ((c.b - l) * l) / (l - n);\n" + 
+			"     }\n" + 
+			"     if (x > 1.0) {\n" + 
+			"         c.r = l + ((c.r - l) * (1.0 - l)) / (x - l);\n" + 
+			"         c.g = l + ((c.g - l) * (1.0 - l)) / (x - l);\n" + 
+			"         c.b = l + ((c.b - l) * (1.0 - l)) / (x - l);\n" + 
+			"     }\n" + 
+			"     \n" + 
+			"     return c;\n" + 
+			" }\n" + 
+			" \n" + 
+			" lowp vec3 setlum(lowp vec3 c, highp float l) {\n" + 
+			"     highp float d = l - lum(c);\n" + 
+			"     c = c + vec3(d);\n" + 
+			"     return clipcolor(c);\n" + 
+			" }\n" + 
+			" \n" + 
+			" void main()\n" + 
+			" {\n" + 
+			"	 highp vec4 baseColor = texture2D(inputImageTexture, textureCoordinate);\n" + 
+			"	 highp vec4 overlayColor = texture2D(inputImageTexture2, textureCoordinate2);\n" + 
+			"     \n" + 
+			"     gl_FragColor = vec4(baseColor.rgb * (1.0 - overlayColor.a) + setlum(baseColor.rgb, lum(overlayColor.rgb)) * overlayColor.a, baseColor.a);\n" + 
+			" }";
+	public static final String BLEND_MODE_COLOR_BURN = "varying highp vec2 textureCoordinate;\n" + 
+			" varying highp vec2 textureCoordinate2;\n" + 
+			"\n" + 
+			" uniform sampler2D inputImageTexture;\n" + 
+			" uniform sampler2D inputImageTexture2;\n" + 
+			" \n" + 
+			" void main()\n" + 
+			" {\n" + 
+			"    mediump vec4 textureColor = texture2D(inputImageTexture, textureCoordinate);\n" + 
+			"    mediump vec4 textureColor2 = texture2D(inputImageTexture2, textureCoordinate2);\n" + 
+			"    mediump vec4 whiteColor = vec4(1.0);\n" + 
+			"    gl_FragColor = whiteColor - (whiteColor - textureColor) / textureColor2;\n" + 
+			" }";
+	public static final String BLEND_MODE_COLOR_DODGE = "precision mediump float;\n" + 
+			" \n" + 
+			" varying highp vec2 textureCoordinate;\n" + 
+			" varying highp vec2 textureCoordinate2;\n" + 
+			" \n" + 
+			" uniform sampler2D inputImageTexture;\n" + 
+			" uniform sampler2D inputImageTexture2;\n" + 
+			" \n" + 
+			" void main()\n" + 
+			" {\n" + 
+			"     vec4 base = texture2D(inputImageTexture, textureCoordinate);\n" + 
+			"     vec4 overlay = texture2D(inputImageTexture2, textureCoordinate2);\n" + 
+			"     \n" + 
+			"     vec3 baseOverlayAlphaProduct = vec3(overlay.a * base.a);\n" + 
+			"     vec3 rightHandProduct = overlay.rgb * (1.0 - base.a) + base.rgb * (1.0 - overlay.a);\n" + 
+			"     \n" + 
+			"     vec3 firstBlendColor = baseOverlayAlphaProduct + rightHandProduct;\n" + 
+			"     vec3 overlayRGB = clamp((overlay.rgb / clamp(overlay.a, 0.01, 1.0)) * step(0.0, overlay.a), 0.0, 0.99);\n" + 
+			"     \n" + 
+			"     vec3 secondBlendColor = (base.rgb * overlay.a) / (1.0 - overlayRGB) + rightHandProduct;\n" + 
+			"     \n" + 
+			"     vec3 colorChoice = step((overlay.rgb * base.a + base.rgb * overlay.a), baseOverlayAlphaProduct);\n" + 
+			"     \n" + 
+			"     gl_FragColor = vec4(mix(firstBlendColor, secondBlendColor, colorChoice), 1.0);\n" + 
+			" }";
+	public static final String BLEND_MODE_DARKEN = "varying highp vec2 textureCoordinate;\n" + 
+			" varying highp vec2 textureCoordinate2;\n" + 
+			"\n" + 
+			" uniform sampler2D inputImageTexture;\n" + 
+			" uniform sampler2D inputImageTexture2;\n" + 
+			" \n" + 
+			" void main()\n" + 
+			" {\n" + 
+			"    lowp vec4 base = texture2D(inputImageTexture, textureCoordinate);\n" + 
+			"    lowp vec4 overlayer = texture2D(inputImageTexture2, textureCoordinate2);\n" + 
+			"    \n" + 
+			"    gl_FragColor = vec4(min(overlayer.rgb * base.a, base.rgb * overlayer.a) + overlayer.rgb * (1.0 - base.a) + base.rgb * (1.0 - overlayer.a), 1.0);\n" + 
+			" }";
+	public static final String BLEND_MODE_DIFFERENCE = "varying highp vec2 textureCoordinate;\n" + 
+			" varying highp vec2 textureCoordinate2;\n" + 
+			"\n" + 
+			" uniform sampler2D inputImageTexture;\n" + 
+			" uniform sampler2D inputImageTexture2;\n" + 
+			" \n" + 
+			" void main()\n" + 
+			" {\n" + 
+			"     mediump vec4 textureColor = texture2D(inputImageTexture, textureCoordinate);\n" + 
+			"     mediump vec4 textureColor2 = texture2D(inputImageTexture2, textureCoordinate2);\n" + 
+			"     gl_FragColor = vec4(abs(textureColor2.rgb - textureColor.rgb), textureColor.a);\n" + 
+			" }";
+	public static final String BLEND_MODE_DISSOLVE = "varying highp vec2 textureCoordinate;\n" + 
+			" varying highp vec2 textureCoordinate2;\n" + 
+			"\n" + 
+			" uniform sampler2D inputImageTexture;\n" + 
+			" uniform sampler2D inputImageTexture2;\n" + 
+			" uniform lowp float mixturePercent;\n" + 
+			" \n" + 
+			" void main()\n" + 
+			" {\n" + 
+			"    lowp vec4 textureColor = texture2D(inputImageTexture, textureCoordinate);\n" + 
+			"    lowp vec4 textureColor2 = texture2D(inputImageTexture2, textureCoordinate2);\n" + 
+			"    \n" + 
+			"    gl_FragColor = mix(textureColor, textureColor2, mixturePercent);\n" + 
+			" }";
+	public static final String BLEND_MODE_EXCLUSION = "varying highp vec2 textureCoordinate;\n" + 
+			" varying highp vec2 textureCoordinate2;\n" + 
+			"\n" + 
+			" uniform sampler2D inputImageTexture;\n" + 
+			" uniform sampler2D inputImageTexture2;\n" + 
+			" \n" + 
+			" void main()\n" + 
+			" {\n" + 
+			"     mediump vec4 base = texture2D(inputImageTexture, textureCoordinate);\n" + 
+			"     mediump vec4 overlay = texture2D(inputImageTexture2, textureCoordinate2);\n" + 
+			"     \n" + 
+			"     //     Dca = (Sca.Da + Dca.Sa - 2.Sca.Dca) + Sca.(1 - Da) + Dca.(1 - Sa)\n" + 
+			"     \n" + 
+			"     gl_FragColor = vec4((overlay.rgb * base.a + base.rgb * overlay.a - 2.0 * overlay.rgb * base.rgb) + overlay.rgb * (1.0 - base.a) + base.rgb * (1.0 - overlay.a), base.a);\n" + 
+			" }";
+	public static final String BLEND_MODE_HARD_LIGHT = "varying highp vec2 textureCoordinate;\n" + 
+			" varying highp vec2 textureCoordinate2;\n" + 
+			"\n" + 
+			" uniform sampler2D inputImageTexture;\n" + 
+			" uniform sampler2D inputImageTexture2;\n" + 
+			"\n" + 
+			" const highp vec3 W = vec3(0.2125, 0.7154, 0.0721);\n" + 
+			"\n" + 
+			" void main()\n" + 
+			" {\n" + 
+			"     mediump vec4 base = texture2D(inputImageTexture, textureCoordinate);\n" + 
+			"     mediump vec4 overlay = texture2D(inputImageTexture2, textureCoordinate2);\n" + 
+			"\n" + 
+			"     highp float ra;\n" + 
+			"     if (2.0 * overlay.r < overlay.a) {\n" + 
+			"         ra = 2.0 * overlay.r * base.r + overlay.r * (1.0 - base.a) + base.r * (1.0 - overlay.a);\n" + 
+			"     } else {\n" + 
+			"         ra = overlay.a * base.a - 2.0 * (base.a - base.r) * (overlay.a - overlay.r) + overlay.r * (1.0 - base.a) + base.r * (1.0 - overlay.a);\n" + 
+			"     }\n" + 
+			"     \n" + 
+			"     highp float ga;\n" + 
+			"     if (2.0 * overlay.g < overlay.a) {\n" + 
+			"         ga = 2.0 * overlay.g * base.g + overlay.g * (1.0 - base.a) + base.g * (1.0 - overlay.a);\n" + 
+			"     } else {\n" + 
+			"         ga = overlay.a * base.a - 2.0 * (base.a - base.g) * (overlay.a - overlay.g) + overlay.g * (1.0 - base.a) + base.g * (1.0 - overlay.a);\n" + 
+			"     }\n" + 
+			"     \n" + 
+			"     highp float ba;\n" + 
+			"     if (2.0 * overlay.b < overlay.a) {\n" + 
+			"         ba = 2.0 * overlay.b * base.b + overlay.b * (1.0 - base.a) + base.b * (1.0 - overlay.a);\n" + 
+			"     } else {\n" + 
+			"         ba = overlay.a * base.a - 2.0 * (base.a - base.b) * (overlay.a - overlay.b) + overlay.b * (1.0 - base.a) + base.b * (1.0 - overlay.a);\n" + 
+			"     }\n" + 
+			"     \n" + 
+			"     gl_FragColor = vec4(ra, ga, ba, 1.0);\n" + 
+			" }\n" + 
+			"";
+	public static final String BLEND_MODE_LIGHTEN = "varying highp vec2 textureCoordinate;\n" + 
+			" varying highp vec2 textureCoordinate2;\n" + 
+			"\n" + 
+			" uniform sampler2D inputImageTexture;\n" + 
+			" uniform sampler2D inputImageTexture2;\n" + 
+			" \n" + 
+			" void main()\n" + 
+			" {\n" + 
+			"    lowp vec4 textureColor = texture2D(inputImageTexture, textureCoordinate);\n" + 
+			"    lowp vec4 textureColor2 = texture2D(inputImageTexture2, textureCoordinate2);\n" + 
+			"    \n" + 
+			"    gl_FragColor = max(textureColor, textureColor2);\n" + 
+			" }";
+	public static final String BLEND_MODE_ADD = "varying highp vec2 textureCoordinate;\n" + 
+			" varying highp vec2 textureCoordinate2;\n" + 
+			"\n" + 
+			" uniform sampler2D inputImageTexture;\n" + 
+			" uniform sampler2D inputImageTexture2;\n" + 
+			" \n" + 
+			" void main()\n" + 
+			" {\n" + 
+			"	 lowp vec4 base = texture2D(inputImageTexture, textureCoordinate);\n" + 
+			"	 lowp vec4 overlay = texture2D(inputImageTexture2, textureCoordinate2);\n" + 
+			"	 \n" + 
+			"   mediump float r;\n" + 
+			"   if (overlay.r * base.a + base.r * overlay.a >= overlay.a * base.a) {\n" + 
+			"     r = overlay.a * base.a + overlay.r * (1.0 - base.a) + base.r * (1.0 - overlay.a);\n" + 
+			"   } else {\n" + 
+			"     r = overlay.r + base.r;\n" + 
+			"   }\n" + 
+			"\n" + 
+			"   mediump float g;\n" + 
+			"   if (overlay.g * base.a + base.g * overlay.a >= overlay.a * base.a) {\n" + 
+			"     g = overlay.a * base.a + overlay.g * (1.0 - base.a) + base.g * (1.0 - overlay.a);\n" + 
+			"   } else {\n" + 
+			"     g = overlay.g + base.g;\n" + 
+			"   }\n" + 
+			"\n" + 
+			"   mediump float b;\n" + 
+			"   if (overlay.b * base.a + base.b * overlay.a >= overlay.a * base.a) {\n" + 
+			"     b = overlay.a * base.a + overlay.b * (1.0 - base.a) + base.b * (1.0 - overlay.a);\n" + 
+			"   } else {\n" + 
+			"     b = overlay.b + base.b;\n" + 
+			"   }\n" + 
+			"\n" + 
+			"   mediump float a = overlay.a + base.a - overlay.a * base.a;\n" + 
+			"   \n" + 
+			"	 gl_FragColor = vec4(r, g, b, a);\n" + 
+			" }\n" + 
+			"";
+	public static final String BLEND_MODE_DIVIDE = "varying highp vec2 textureCoordinate;\n" + 
+			" varying highp vec2 textureCoordinate2;\n" + 
+			"\n" + 
+			" uniform sampler2D inputImageTexture;\n" + 
+			" uniform sampler2D inputImageTexture2;\n" + 
+			" \n" + 
+			" void main()\n" + 
+			" {\n" + 
+			"	 mediump vec4 base = texture2D(inputImageTexture, textureCoordinate);\n" + 
+			"	 mediump vec4 overlay = texture2D(inputImageTexture2, textureCoordinate2);\n" + 
+			"   \n" + 
+			"   mediump float ra;\n" + 
+			"   if (overlay.a == 0.0 || ((base.r / overlay.r) > (base.a / overlay.a)))\n" + 
+			"     ra = overlay.a * base.a + overlay.r * (1.0 - base.a) + base.r * (1.0 - overlay.a);\n" + 
+			"   else\n" + 
+			"     ra = (base.r * overlay.a * overlay.a) / overlay.r + overlay.r * (1.0 - base.a) + base.r * (1.0 - overlay.a);\n" + 
+			"   \n" + 
+			"\n" + 
+			"   mediump float ga;\n" + 
+			"   if (overlay.a == 0.0 || ((base.g / overlay.g) > (base.a / overlay.a)))\n" + 
+			"     ga = overlay.a * base.a + overlay.g * (1.0 - base.a) + base.g * (1.0 - overlay.a);\n" + 
+			"   else\n" + 
+			"     ga = (base.g * overlay.a * overlay.a) / overlay.g + overlay.g * (1.0 - base.a) + base.g * (1.0 - overlay.a);\n" + 
+			"\n" + 
+			"   \n" + 
+			"   mediump float ba;\n" + 
+			"   if (overlay.a == 0.0 || ((base.b / overlay.b) > (base.a / overlay.a)))\n" + 
+			"     ba = overlay.a * base.a + overlay.b * (1.0 - base.a) + base.b * (1.0 - overlay.a);\n" + 
+			"   else\n" + 
+			"     ba = (base.b * overlay.a * overlay.a) / overlay.b + overlay.b * (1.0 - base.a) + base.b * (1.0 - overlay.a);\n" + 
+			"\n" + 
+			"   mediump float a = overlay.a + base.a - overlay.a * base.a;\n" + 
+			"   \n" + 
+			"	 gl_FragColor = vec4(ra, ga, ba, a);\n" + 
+			" }";
+	public static final String BLEND_MODE_MULTIPLY = "varying highp vec2 textureCoordinate;\n" + 
+			" varying highp vec2 textureCoordinate2;\n" + 
+			" \n" + 
+			" uniform sampler2D inputImageTexture;\n" + 
+			" uniform sampler2D inputImageTexture2;\n" + 
+			" \n" + 
+			" highp float lum(lowp vec3 c) {\n" + 
+			"     return dot(c, vec3(0.3, 0.59, 0.11));\n" + 
+			" }\n" + 
+			" \n" + 
+			" lowp vec3 clipcolor(lowp vec3 c) {\n" + 
+			"     highp float l = lum(c);\n" + 
+			"     lowp float n = min(min(c.r, c.g), c.b);\n" + 
+			"     lowp float x = max(max(c.r, c.g), c.b);\n" + 
+			"     \n" + 
+			"     if (n < 0.0) {\n" + 
+			"         c.r = l + ((c.r - l) * l) / (l - n);\n" + 
+			"         c.g = l + ((c.g - l) * l) / (l - n);\n" + 
+			"         c.b = l + ((c.b - l) * l) / (l - n);\n" + 
+			"     }\n" + 
+			"     if (x > 1.0) {\n" + 
+			"         c.r = l + ((c.r - l) * (1.0 - l)) / (x - l);\n" + 
+			"         c.g = l + ((c.g - l) * (1.0 - l)) / (x - l);\n" + 
+			"         c.b = l + ((c.b - l) * (1.0 - l)) / (x - l);\n" + 
+			"     }\n" + 
+			"     \n" + 
+			"     return c;\n" + 
+			" }\n" + 
+			" \n" + 
+			" lowp vec3 setlum(lowp vec3 c, highp float l) {\n" + 
+			"     highp float d = l - lum(c);\n" + 
+			"     c = c + vec3(d);\n" + 
+			"     return clipcolor(c);\n" + 
+			" }\n" + 
+			" \n" + 
+			" void main()\n" + 
+			" {\n" + 
+			"	 highp vec4 baseColor = texture2D(inputImageTexture, textureCoordinate);\n" + 
+			"	 highp vec4 overlayColor = texture2D(inputImageTexture2, textureCoordinate2);\n" + 
+			"     \n" + 
+			"     gl_FragColor = vec4(baseColor.rgb * (1.0 - overlayColor.a) + setlum(baseColor.rgb, lum(overlayColor.rgb)) * overlayColor.a, baseColor.a);\n" + 
+			" }";
+	public static final String BLEND_MODE_OVERLAY = "varying highp vec2 textureCoordinate;\n" + 
+			" varying highp vec2 textureCoordinate2;\n" + 
+			"\n" + 
+			" uniform sampler2D inputImageTexture;\n" + 
+			" uniform sampler2D inputImageTexture2;\n" + 
+			" \n" + 
+			" void main()\n" + 
+			" {\n" + 
+			"     mediump vec4 base = texture2D(inputImageTexture, textureCoordinate);\n" + 
+			"     mediump vec4 overlay = texture2D(inputImageTexture2, textureCoordinate2);\n" + 
+			"     \n" + 
+			"     mediump float ra;\n" + 
+			"     if (2.0 * base.r < base.a) {\n" + 
+			"         ra = 2.0 * overlay.r * base.r + overlay.r * (1.0 - base.a) + base.r * (1.0 - overlay.a);\n" + 
+			"     } else {\n" + 
+			"         ra = overlay.a * base.a - 2.0 * (base.a - base.r) * (overlay.a - overlay.r) + overlay.r * (1.0 - base.a) + base.r * (1.0 - overlay.a);\n" + 
+			"     }\n" + 
+			"     \n" + 
+			"     mediump float ga;\n" + 
+			"     if (2.0 * base.g < base.a) {\n" + 
+			"         ga = 2.0 * overlay.g * base.g + overlay.g * (1.0 - base.a) + base.g * (1.0 - overlay.a);\n" + 
+			"     } else {\n" + 
+			"         ga = overlay.a * base.a - 2.0 * (base.a - base.g) * (overlay.a - overlay.g) + overlay.g * (1.0 - base.a) + base.g * (1.0 - overlay.a);\n" + 
+			"     }\n" + 
+			"     \n" + 
+			"     mediump float ba;\n" + 
+			"     if (2.0 * base.b < base.a) {\n" + 
+			"         ba = 2.0 * overlay.b * base.b + overlay.b * (1.0 - base.a) + base.b * (1.0 - overlay.a);\n" + 
+			"     } else {\n" + 
+			"         ba = overlay.a * base.a - 2.0 * (base.a - base.b) * (overlay.a - overlay.b) + overlay.b * (1.0 - base.a) + base.b * (1.0 - overlay.a);\n" + 
+			"     }\n" + 
+			"     \n" + 
+			"     gl_FragColor = vec4(ra, ga, ba, 1.0);\n" + 
+			" }\n" + 
+			"";
+	public static final String BLEND_MODE_SCREEN = "varying highp vec2 textureCoordinate;\n" + 
+			" varying highp vec2 textureCoordinate2;\n" + 
+			"\n" + 
+			" uniform sampler2D inputImageTexture;\n" + 
+			" uniform sampler2D inputImageTexture2;\n" + 
+			" \n" + 
+			" void main()\n" + 
+			" {\n" + 
+			"     mediump vec4 textureColor = texture2D(inputImageTexture, textureCoordinate);\n" + 
+			"     mediump vec4 textureColor2 = texture2D(inputImageTexture2, textureCoordinate2);\n" + 
+			"     mediump vec4 whiteColor = vec4(1.0);\n" + 
+			"     gl_FragColor = whiteColor - ((whiteColor - textureColor2) * (whiteColor - textureColor));\n" + 
+			" }";
+	
+	public static final String BLEND_MODE_ALPHA = "varying highp vec2 textureCoordinate;\n" + 
+			" varying highp vec2 textureCoordinate2;\n" + 
+			"\n" + 
+			" uniform sampler2D inputImageTexture;\n" + 
+			" uniform sampler2D inputImageTexture2;\n" + 
+			" \n" + 
+			" uniform lowp float mixturePercent;\n" + 
+			"\n" + 
+			" void main()\n" + 
+			" {\n" + 
+			"	 lowp vec4 textureColor = texture2D(inputImageTexture, textureCoordinate);\n" + 
+			"	 lowp vec4 textureColor2 = texture2D(inputImageTexture2, textureCoordinate2);\n" + 
+			"	 \n" + 
+			"	 gl_FragColor = vec4(mix(textureColor.rgb, textureColor2.rgb, textureColor2.a * mixturePercent), textureColor.a);\n" + 
+			" }";
+	
+	
+	public static final String BLEND_MODE_COLOR = "varying highp vec2 textureCoordinate;\n" + 
+			" varying highp vec2 textureCoordinate2;\n" + 
+			" \n" + 
+			" uniform sampler2D inputImageTexture;\n" + 
+			" uniform sampler2D inputImageTexture2;\n" + 
+			" \n" + 
+			" highp float lum(lowp vec3 c) {\n" + 
+			"     return dot(c, vec3(0.3, 0.59, 0.11));\n" + 
+			" }\n" + 
+			" \n" + 
+			" lowp vec3 clipcolor(lowp vec3 c) {\n" + 
+			"     highp float l = lum(c);\n" + 
+			"     lowp float n = min(min(c.r, c.g), c.b);\n" + 
+			"     lowp float x = max(max(c.r, c.g), c.b);\n" + 
+			"     \n" + 
+			"     if (n < 0.0) {\n" + 
+			"         c.r = l + ((c.r - l) * l) / (l - n);\n" + 
+			"         c.g = l + ((c.g - l) * l) / (l - n);\n" + 
+			"         c.b = l + ((c.b - l) * l) / (l - n);\n" + 
+			"     }\n" + 
+			"     if (x > 1.0) {\n" + 
+			"         c.r = l + ((c.r - l) * (1.0 - l)) / (x - l);\n" + 
+			"         c.g = l + ((c.g - l) * (1.0 - l)) / (x - l);\n" + 
+			"         c.b = l + ((c.b - l) * (1.0 - l)) / (x - l);\n" + 
+			"     }\n" + 
+			"     \n" + 
+			"     return c;\n" + 
+			" }\n" + 
+			"\n" + 
+			" lowp vec3 setlum(lowp vec3 c, highp float l) {\n" + 
+			"     highp float d = l - lum(c);\n" + 
+			"     c = c + vec3(d);\n" + 
+			"     return clipcolor(c);\n" + 
+			" }\n" + 
+			" \n" + 
+			" void main()\n" + 
+			" {\n" + 
+			"	 highp vec4 baseColor = texture2D(inputImageTexture, textureCoordinate);\n" + 
+			"	 highp vec4 overlayColor = texture2D(inputImageTexture2, textureCoordinate2);\n" + 
+			"\n" + 
+			"     gl_FragColor = vec4(baseColor.rgb * (1.0 - overlayColor.a) + setlum(overlayColor.rgb, lum(baseColor.rgb)) * overlayColor.a, baseColor.a);\n" + 
+			" }\n" + 
+			"";
+	public static final String BLEND_MODE_HUE = "varying highp vec2 textureCoordinate;\n" + 
+			" varying highp vec2 textureCoordinate2;\n" + 
+			" \n" + 
+			" uniform sampler2D inputImageTexture;\n" + 
+			" uniform sampler2D inputImageTexture2;\n" + 
+			" \n" + 
+			" highp float lum(lowp vec3 c) {\n" + 
+			"     return dot(c, vec3(0.3, 0.59, 0.11));\n" + 
+			" }\n" + 
+			" \n" + 
+			" lowp vec3 clipcolor(lowp vec3 c) {\n" + 
+			"     highp float l = lum(c);\n" + 
+			"     lowp float n = min(min(c.r, c.g), c.b);\n" + 
+			"     lowp float x = max(max(c.r, c.g), c.b);\n" + 
+			"     \n" + 
+			"     if (n < 0.0) {\n" + 
+			"         c.r = l + ((c.r - l) * l) / (l - n);\n" + 
+			"         c.g = l + ((c.g - l) * l) / (l - n);\n" + 
+			"         c.b = l + ((c.b - l) * l) / (l - n);\n" + 
+			"     }\n" + 
+			"     if (x > 1.0) {\n" + 
+			"         c.r = l + ((c.r - l) * (1.0 - l)) / (x - l);\n" + 
+			"         c.g = l + ((c.g - l) * (1.0 - l)) / (x - l);\n" + 
+			"         c.b = l + ((c.b - l) * (1.0 - l)) / (x - l);\n" + 
+			"     }\n" + 
+			"     \n" + 
+			"     return c;\n" + 
+			" }\n" + 
+			" \n" + 
+			" lowp vec3 setlum(lowp vec3 c, highp float l) {\n" + 
+			"     highp float d = l - lum(c);\n" + 
+			"     c = c + vec3(d);\n" + 
+			"     return clipcolor(c);\n" + 
+			" }\n" + 
+			" \n" + 
+			" highp float sat(lowp vec3 c) {\n" + 
+			"     lowp float n = min(min(c.r, c.g), c.b);\n" + 
+			"     lowp float x = max(max(c.r, c.g), c.b);\n" + 
+			"     return x - n;\n" + 
+			" }\n" + 
+			" \n" + 
+			" lowp float mid(lowp float cmin, lowp float cmid, lowp float cmax, highp float s) {\n" + 
+			"     return ((cmid - cmin) * s) / (cmax - cmin);\n" + 
+			" }\n" + 
+			" \n" + 
+			" lowp vec3 setsat(lowp vec3 c, highp float s) {\n" + 
+			"     if (c.r > c.g) {\n" + 
+			"         if (c.r > c.b) {\n" + 
+			"             if (c.g > c.b) {\n" + 
+			"                 /* g is mid, b is min */\n" + 
+			"                 c.g = mid(c.b, c.g, c.r, s);\n" + 
+			"                 c.b = 0.0;\n" + 
+			"             } else {\n" + 
+			"                 /* b is mid, g is min */\n" + 
+			"                 c.b = mid(c.g, c.b, c.r, s);\n" + 
+			"                 c.g = 0.0;\n" + 
+			"             }\n" + 
+			"             c.r = s;\n" + 
+			"         } else {\n" + 
+			"             /* b is max, r is mid, g is min */\n" + 
+			"             c.r = mid(c.g, c.r, c.b, s);\n" + 
+			"             c.b = s;\n" + 
+			"             c.r = 0.0;\n" + 
+			"         }\n" + 
+			"     } else if (c.r > c.b) {\n" + 
+			"         /* g is max, r is mid, b is min */\n" + 
+			"         c.r = mid(c.b, c.r, c.g, s);\n" + 
+			"         c.g = s;\n" + 
+			"         c.b = 0.0;\n" + 
+			"     } else if (c.g > c.b) {\n" + 
+			"         /* g is max, b is mid, r is min */\n" + 
+			"         c.b = mid(c.r, c.b, c.g, s);\n" + 
+			"         c.g = s;\n" + 
+			"         c.r = 0.0;\n" + 
+			"     } else if (c.b > c.g) {\n" + 
+			"         /* b is max, g is mid, r is min */\n" + 
+			"         c.g = mid(c.r, c.g, c.b, s);\n" + 
+			"         c.b = s;\n" + 
+			"         c.r = 0.0;\n" + 
+			"     } else {\n" + 
+			"         c = vec3(0.0);\n" + 
+			"     }\n" + 
+			"     return c;\n" + 
+			" }\n" + 
+			" \n" + 
+			" void main()\n" + 
+			" {\n" + 
+			"	 highp vec4 baseColor = texture2D(inputImageTexture, textureCoordinate);\n" + 
+			"	 highp vec4 overlayColor = texture2D(inputImageTexture2, textureCoordinate2);\n" + 
+			"     \n" + 
+			"     gl_FragColor = vec4(baseColor.rgb * (1.0 - overlayColor.a) + setlum(setsat(overlayColor.rgb, sat(baseColor.rgb)), lum(baseColor.rgb)) * overlayColor.a, baseColor.a);\n" + 
+			" }";
+	public static final String BLEND_MODE_SATURATION = "varying highp vec2 textureCoordinate;\n" + 
+			" varying highp vec2 textureCoordinate2;\n" + 
+			" \n" + 
+			" uniform sampler2D inputImageTexture;\n" + 
+			" uniform sampler2D inputImageTexture2;\n" + 
+			" \n" + 
+			" highp float lum(lowp vec3 c) {\n" + 
+			"     return dot(c, vec3(0.3, 0.59, 0.11));\n" + 
+			" }\n" + 
+			" \n" + 
+			" lowp vec3 clipcolor(lowp vec3 c) {\n" + 
+			"     highp float l = lum(c);\n" + 
+			"     lowp float n = min(min(c.r, c.g), c.b);\n" + 
+			"     lowp float x = max(max(c.r, c.g), c.b);\n" + 
+			"     \n" + 
+			"     if (n < 0.0) {\n" + 
+			"         c.r = l + ((c.r - l) * l) / (l - n);\n" + 
+			"         c.g = l + ((c.g - l) * l) / (l - n);\n" + 
+			"         c.b = l + ((c.b - l) * l) / (l - n);\n" + 
+			"     }\n" + 
+			"     if (x > 1.0) {\n" + 
+			"         c.r = l + ((c.r - l) * (1.0 - l)) / (x - l);\n" + 
+			"         c.g = l + ((c.g - l) * (1.0 - l)) / (x - l);\n" + 
+			"         c.b = l + ((c.b - l) * (1.0 - l)) / (x - l);\n" + 
+			"     }\n" + 
+			"     \n" + 
+			"     return c;\n" + 
+			" }\n" + 
+			" \n" + 
+			" lowp vec3 setlum(lowp vec3 c, highp float l) {\n" + 
+			"     highp float d = l - lum(c);\n" + 
+			"     c = c + vec3(d);\n" + 
+			"     return clipcolor(c);\n" + 
+			" }\n" + 
+			" \n" + 
+			" highp float sat(lowp vec3 c) {\n" + 
+			"     lowp float n = min(min(c.r, c.g), c.b);\n" + 
+			"     lowp float x = max(max(c.r, c.g), c.b);\n" + 
+			"     return x - n;\n" + 
+			" }\n" + 
+			" \n" + 
+			" lowp float mid(lowp float cmin, lowp float cmid, lowp float cmax, highp float s) {\n" + 
+			"     return ((cmid - cmin) * s) / (cmax - cmin);\n" + 
+			" }\n" + 
+			" \n" + 
+			" lowp vec3 setsat(lowp vec3 c, highp float s) {\n" + 
+			"     if (c.r > c.g) {\n" + 
+			"         if (c.r > c.b) {\n" + 
+			"             if (c.g > c.b) {\n" + 
+			"                 /* g is mid, b is min */\n" + 
+			"                 c.g = mid(c.b, c.g, c.r, s);\n" + 
+			"                 c.b = 0.0;\n" + 
+			"             } else {\n" + 
+			"                 /* b is mid, g is min */\n" + 
+			"                 c.b = mid(c.g, c.b, c.r, s);\n" + 
+			"                 c.g = 0.0;\n" + 
+			"             }\n" + 
+			"             c.r = s;\n" + 
+			"         } else {\n" + 
+			"             /* b is max, r is mid, g is min */\n" + 
+			"             c.r = mid(c.g, c.r, c.b, s);\n" + 
+			"             c.b = s;\n" + 
+			"             c.r = 0.0;\n" + 
+			"         }\n" + 
+			"     } else if (c.r > c.b) {\n" + 
+			"         /* g is max, r is mid, b is min */\n" + 
+			"         c.r = mid(c.b, c.r, c.g, s);\n" + 
+			"         c.g = s;\n" + 
+			"         c.b = 0.0;\n" + 
+			"     } else if (c.g > c.b) {\n" + 
+			"         /* g is max, b is mid, r is min */\n" + 
+			"         c.b = mid(c.r, c.b, c.g, s);\n" + 
+			"         c.g = s;\n" + 
+			"         c.r = 0.0;\n" + 
+			"     } else if (c.b > c.g) {\n" + 
+			"         /* b is max, g is mid, r is min */\n" + 
+			"         c.g = mid(c.r, c.g, c.b, s);\n" + 
+			"         c.b = s;\n" + 
+			"         c.r = 0.0;\n" + 
+			"     } else {\n" + 
+			"         c = vec3(0.0);\n" + 
+			"     }\n" + 
+			"     return c;\n" + 
+			" }\n" + 
+			" \n" + 
+			" void main()\n" + 
+			" {\n" + 
+			"	 highp vec4 baseColor = texture2D(inputImageTexture, textureCoordinate);\n" + 
+			"	 highp vec4 overlayColor = texture2D(inputImageTexture2, textureCoordinate2);\n" + 
+			"     \n" + 
+			"     gl_FragColor = vec4(baseColor.rgb * (1.0 - overlayColor.a) + setlum(setsat(baseColor.rgb, sat(overlayColor.rgb)), lum(baseColor.rgb)) * overlayColor.a, baseColor.a);\n" + 
+			" }";
+	public static final String BLEND_MODE_LUMINOSITY = "varying highp vec2 textureCoordinate;\n" + 
+			" varying highp vec2 textureCoordinate2;\n" + 
+			" \n" + 
+			" uniform sampler2D inputImageTexture;\n" + 
+			" uniform sampler2D inputImageTexture2;\n" + 
+			" \n" + 
+			" highp float lum(lowp vec3 c) {\n" + 
+			"     return dot(c, vec3(0.3, 0.59, 0.11));\n" + 
+			" }\n" + 
+			" \n" + 
+			" lowp vec3 clipcolor(lowp vec3 c) {\n" + 
+			"     highp float l = lum(c);\n" + 
+			"     lowp float n = min(min(c.r, c.g), c.b);\n" + 
+			"     lowp float x = max(max(c.r, c.g), c.b);\n" + 
+			"     \n" + 
+			"     if (n < 0.0) {\n" + 
+			"         c.r = l + ((c.r - l) * l) / (l - n);\n" + 
+			"         c.g = l + ((c.g - l) * l) / (l - n);\n" + 
+			"         c.b = l + ((c.b - l) * l) / (l - n);\n" + 
+			"     }\n" + 
+			"     if (x > 1.0) {\n" + 
+			"         c.r = l + ((c.r - l) * (1.0 - l)) / (x - l);\n" + 
+			"         c.g = l + ((c.g - l) * (1.0 - l)) / (x - l);\n" + 
+			"         c.b = l + ((c.b - l) * (1.0 - l)) / (x - l);\n" + 
+			"     }\n" + 
+			"     \n" + 
+			"     return c;\n" + 
+			" }\n" + 
+			" \n" + 
+			" lowp vec3 setlum(lowp vec3 c, highp float l) {\n" + 
+			"     highp float d = l - lum(c);\n" + 
+			"     c = c + vec3(d);\n" + 
+			"     return clipcolor(c);\n" + 
+			" }\n" + 
+			" \n" + 
+			" void main()\n" + 
+			" {\n" + 
+			"	 highp vec4 baseColor = texture2D(inputImageTexture, textureCoordinate);\n" + 
+			"	 highp vec4 overlayColor = texture2D(inputImageTexture2, textureCoordinate2);\n" + 
+			"     \n" + 
+			"     gl_FragColor = vec4(baseColor.rgb * (1.0 - overlayColor.a) + setlum(baseColor.rgb, lum(overlayColor.rgb)) * overlayColor.a, baseColor.a);\n" + 
+			" }";
+	public static final String BLEND_MODE_LINEAR_BURN = "varying highp vec2 textureCoordinate;\n" + 
+			" varying highp vec2 textureCoordinate2;\n" + 
+			" \n" + 
+			" uniform sampler2D inputImageTexture;\n" + 
+			" uniform sampler2D inputImageTexture2;\n" + 
+			" \n" + 
+			" void main()\n" + 
+			" {\n" + 
+			"     mediump vec4 textureColor = texture2D(inputImageTexture, textureCoordinate);\n" + 
+			"     mediump vec4 textureColor2 = texture2D(inputImageTexture2, textureCoordinate2);\n" + 
+			"     \n" + 
+			"     gl_FragColor = vec4(clamp(textureColor.rgb + textureColor2.rgb - vec3(1.0), vec3(0.0), vec3(1.0)), textureColor.a);\n" + 
+			" }";
+	
+	public static final String BLEND_MODE_SOFT_LIGHT = "varying highp vec2 textureCoordinate;\n" + 
+			" varying highp vec2 textureCoordinate2;\n" + 
+			"\n" + 
+			" uniform sampler2D inputImageTexture;\n" + 
+			" uniform sampler2D inputImageTexture2;\n" + 
+			" \n" + 
+			" void main()\n" + 
+			" {\n" + 
+			"     mediump vec4 base = texture2D(inputImageTexture, textureCoordinate);\n" + 
+			"     mediump vec4 overlay = texture2D(inputImageTexture2, textureCoordinate2);\n" + 
+			"     \n" + 
+			"     gl_FragColor = base * (overlay.a * (base / base.a) + (2.0 * overlay * (1.0 - (base / base.a)))) + overlay * (1.0 - base.a) + base * (1.0 - overlay.a);\n" + 
+			" }";
+	public static final String BLEND_MODE_SUBSTRACT = "varying highp vec2 textureCoordinate;\n" + 
+			" varying highp vec2 textureCoordinate2;\n" + 
+			"\n" + 
+			" uniform sampler2D inputImageTexture;\n" + 
+			" uniform sampler2D inputImageTexture2;\n" + 
+			" \n" + 
+			" void main()\n" + 
+			" {\n" + 
+			"	 lowp vec4 textureColor = texture2D(inputImageTexture, textureCoordinate);\n" + 
+			"	 lowp vec4 textureColor2 = texture2D(inputImageTexture2, textureCoordinate2);\n" + 
+			"	 \n" + 
+			"	 gl_FragColor = vec4(textureColor.rgb - textureColor2.rgb, textureColor.a);\n" + 
+			" }";
+	public static final String BLEND_MODE_CHROMAKEY = "precision highp float;\n" + 
+			" \n" + 
+			" varying highp vec2 textureCoordinate;\n" + 
+			" varying highp vec2 textureCoordinate2;\n" + 
+			"\n" + 
+			" uniform float thresholdSensitivity;\n" + 
+			" uniform float smoothing;\n" + 
+			" uniform vec3 colorToReplace;\n" + 
+			" uniform sampler2D inputImageTexture;\n" + 
+			" uniform sampler2D inputImageTexture2;\n" + 
+			" \n" + 
+			" void main()\n" + 
+			" {\n" + 
+			"     vec4 textureColor = texture2D(inputImageTexture, textureCoordinate);\n" + 
+			"     vec4 textureColor2 = texture2D(inputImageTexture2, textureCoordinate2);\n" + 
+			"     \n" + 
+			"     float maskY = 0.2989 * colorToReplace.r + 0.5866 * colorToReplace.g + 0.1145 * colorToReplace.b;\n" + 
+			"     float maskCr = 0.7132 * (colorToReplace.r - maskY);\n" + 
+			"     float maskCb = 0.5647 * (colorToReplace.b - maskY);\n" + 
+			"     \n" + 
+			"     float Y = 0.2989 * textureColor.r + 0.5866 * textureColor.g + 0.1145 * textureColor.b;\n" + 
+			"     float Cr = 0.7132 * (textureColor.r - Y);\n" + 
+			"     float Cb = 0.5647 * (textureColor.b - Y);\n" + 
+			"     \n" + 
+			"//     float blendValue = 1.0 - smoothstep(thresholdSensitivity - smoothing, thresholdSensitivity , abs(Cr - maskCr) + abs(Cb - maskCb));\n" + 
+			"     float blendValue = 1.0 - smoothstep(thresholdSensitivity, thresholdSensitivity + smoothing, distance(vec2(Cr, Cb), vec2(maskCr, maskCb)));\n" + 
+			"     gl_FragColor = mix(textureColor, textureColor2, blendValue);\n" + 
+			" }\n" + 
+			"";
+	
+	public static final String BLEND_MODE_NORMAL = "varying highp vec2 textureCoordinate;\n" + 
+			" varying highp vec2 textureCoordinate2;\n" + 
+			" \n" + 
+			" uniform sampler2D inputImageTexture;\n" + 
+			" uniform sampler2D inputImageTexture2;\n" + 
+			" \n" + 
+			" void main()\n" + 
+			" {\n" + 
+			"     lowp vec4 c2 = texture2D(inputImageTexture, textureCoordinate);\n" + 
+			"	 lowp vec4 c1 = texture2D(inputImageTexture2, textureCoordinate2);\n" + 
+			"     \n" + 
+			"     lowp vec4 outputColor;\n" + 
+			"     \n" + 
+			"     outputColor.r = c1.r + c2.r * c2.a * (1.0 - c1.a);\n" + 
+			"\n" + 
+			"     outputColor.g = c1.g + c2.g * c2.a * (1.0 - c1.a);\n" + 
+			"     \n" + 
+			"     outputColor.b = c1.b + c2.b * c2.a * (1.0 - c1.a);\n" + 
+			"     \n" + 
+			"     outputColor.a = c1.a + c2.a * (1.0 - c1.a);\n" + 
+			"     \n" + 
+			"     gl_FragColor = outputColor;\n" + 
+			" }";
+	
+	
+	
+	public static final String BLEND_MODE_POISSON = "precision mediump float;\n" + 
+			" \n" + 
+			" varying vec2 textureCoordinate;\n" + 
+			" varying vec2 leftTextureCoordinate;\n" + 
+			" varying vec2 rightTextureCoordinate;\n" + 
+			" varying vec2 topTextureCoordinate;\n" + 
+			" varying vec2 bottomTextureCoordinate;\n" + 
+			" \n" + 
+			" varying vec2 textureCoordinate2;\n" + 
+			" varying vec2 leftTextureCoordinate2;\n" + 
+			" varying vec2 rightTextureCoordinate2;\n" + 
+			" varying vec2 topTextureCoordinate2;\n" + 
+			" varying vec2 bottomTextureCoordinate2;\n" + 
+			" \n" + 
+			" uniform sampler2D inputImageTexture;\n" + 
+			" uniform sampler2D inputImageTexture2;\n" + 
+			" \n" + 
+			" uniform lowp float mixturePercent;\n" + 
+			"\n" + 
+			" void main()\n" + 
+			" {\n" + 
+			"     vec4 centerColor = texture2D(inputImageTexture, textureCoordinate);\n" + 
+			"     vec3 bottomColor = texture2D(inputImageTexture, bottomTextureCoordinate).rgb;\n" + 
+			"     vec3 leftColor = texture2D(inputImageTexture, leftTextureCoordinate).rgb;\n" + 
+			"     vec3 rightColor = texture2D(inputImageTexture, rightTextureCoordinate).rgb;\n" + 
+			"     vec3 topColor = texture2D(inputImageTexture, topTextureCoordinate).rgb;\n" + 
+			"\n" + 
+			"     vec4 centerColor2 = texture2D(inputImageTexture2, textureCoordinate2);\n" + 
+			"     vec3 bottomColor2 = texture2D(inputImageTexture2, bottomTextureCoordinate2).rgb;\n" + 
+			"     vec3 leftColor2 = texture2D(inputImageTexture2, leftTextureCoordinate2).rgb;\n" + 
+			"     vec3 rightColor2 = texture2D(inputImageTexture2, rightTextureCoordinate2).rgb;\n" + 
+			"     vec3 topColor2 = texture2D(inputImageTexture2, topTextureCoordinate2).rgb;\n" + 
+			"\n" + 
+			"     vec3 meanColor = (bottomColor + leftColor + rightColor + topColor) / 4.0;\n" + 
+			"     vec3 diffColor = centerColor.rgb - meanColor;\n" + 
+			"\n" + 
+			"     vec3 meanColor2 = (bottomColor2 + leftColor2 + rightColor2 + topColor2) / 4.0;\n" + 
+			"     vec3 diffColor2 = centerColor2.rgb - meanColor2;\n" + 
+			"     \n" + 
+			"     vec3 gradColor = (meanColor + diffColor2);\n" + 
+			"     \n" + 
+			"	 gl_FragColor = vec4(mix(centerColor.rgb, gradColor, centerColor2.a * mixturePercent), centerColor.a);\n" + 
+			" }"; //TODO implement methods and uniforms
+	
+}
diff --git a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageFilter.java b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageFilter.java
index c8f7958a..62e65070 100644
--- a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageFilter.java
+++ b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageFilter.java
@@ -16,11 +16,15 @@
 
 package jp.co.cyberagent.android.gpuimage;
 
+import android.content.Context;
+import android.content.res.AssetManager;
+import android.graphics.PointF;
+import android.opengl.GLES20;
+
+import java.io.InputStream;
 import java.nio.FloatBuffer;
 import java.util.LinkedList;
 
-import android.opengl.GLES20;
-
 public class GPUImageFilter {
     public static final String NO_FILTER_VERTEX_SHADER = "" +
             "attribute vec4 position;\n" +
@@ -46,10 +50,10 @@
     private final LinkedList<Runnable> mRunOnDraw;
     private final String mVertexShader;
     private final String mFragmentShader;
-    private int mGLProgId;
-    private int mGLAttribPosition;
-    private int mGLUniformTexture;
-    private int mGLAttribTextureCoordinate;
+    protected int mGLProgId;
+    protected int mGLAttribPosition;
+    protected int mGLUniformTexture;
+    protected int mGLAttribTextureCoordinate;
     private int mOutputWidth;
     private int mOutputHeight;
     private boolean mIsInitialized;
@@ -64,6 +68,12 @@ public GPUImageFilter(final String vertexShader, final String fragmentShader) {
         mFragmentShader = fragmentShader;
     }
 
+    public final void init() {
+        onInit();
+        mIsInitialized = true;
+        onInitialized();
+    }
+
     public void onInit() {
         mGLProgId = OpenGlUtils.loadProgram(mVertexShader, mFragmentShader);
         mGLAttribPosition = GLES20.glGetAttribLocation(mGLProgId, "position");
@@ -73,6 +83,14 @@ public void onInit() {
         mIsInitialized = true;
     }
 
+    public void onInitialized() {
+    }
+
+    public final void destroy() {
+        mIsInitialized = false;
+        onDestroy();
+    }
+
     public void onDestroy() {
         GLES20.glDeleteProgram(mGLProgId);
         mIsInitialized = false;
@@ -84,7 +102,7 @@ public void onOutputSizeChanged(final int width, final int height) {
     }
 
     public void onDraw(final int textureId, final FloatBuffer cubeBuffer,
-            final FloatBuffer textureBuffer) {
+                       final FloatBuffer textureBuffer) {
         GLES20.glUseProgram(mGLProgId);
         runPendingOnDrawTasks();
         if (!mIsInitialized) {
@@ -103,12 +121,15 @@ public void onDraw(final int textureId, final FloatBuffer cubeBuffer,
             GLES20.glBindTexture(GLES20.GL_TEXTURE_2D, textureId);
             GLES20.glUniform1i(mGLUniformTexture, 0);
         }
+        onDrawArraysPre();
         GLES20.glDrawArrays(GLES20.GL_TRIANGLE_STRIP, 0, 4);
         GLES20.glDisableVertexAttribArray(mGLAttribPosition);
         GLES20.glDisableVertexAttribArray(mGLAttribTextureCoordinate);
         GLES20.glBindTexture(GLES20.GL_TEXTURE_2D, 0);
     }
 
+    protected void onDrawArraysPre() { }
+
     protected void runPendingOnDrawTasks() {
         while (!mRunOnDraw.isEmpty()) {
             mRunOnDraw.removeFirst().run();
@@ -143,9 +164,17 @@ public int getUniformTexture() {
         return mGLUniformTexture;
     }
 
-    protected void setFloat(final int location, final float floatValue) {
+    protected void setInteger(final int location, final int intValue) {
         runOnDraw(new Runnable() {
+            @Override
+            public void run() {
+                GLES20.glUniform1i(location, intValue);
+            }
+        });
+    }
 
+    protected void setFloat(final int location, final float floatValue) {
+        runOnDraw(new Runnable() {
             @Override
             public void run() {
                 GLES20.glUniform1f(location, floatValue);
@@ -153,6 +182,55 @@ public void run() {
         });
     }
 
+    protected void setFloatVec2(final int location, final float[] arrayValue) {
+        runOnDraw(new Runnable() {
+            @Override
+            public void run() {
+                GLES20.glUniform2fv(location, 1, FloatBuffer.wrap(arrayValue));
+            }
+        });
+    }
+
+    protected void setFloatVec3(final int location, final float[] arrayValue) {
+        runOnDraw(new Runnable() {
+            @Override
+            public void run() {
+                GLES20.glUniform3fv(location, 1, FloatBuffer.wrap(arrayValue));
+            }
+        });
+    }
+
+    protected void setFloatVec4(final int location, final float[] arrayValue) {
+        runOnDraw(new Runnable() {
+            @Override
+            public void run() {
+                GLES20.glUniform4fv(location, 1, FloatBuffer.wrap(arrayValue));
+            }
+        });
+    }
+
+    protected void setFloatArray(final int location, final float[] arrayValue) {
+        runOnDraw(new Runnable() {
+            @Override
+            public void run() {
+                GLES20.glUniform1fv(location, arrayValue.length, FloatBuffer.wrap(arrayValue));
+            }
+        });
+    }
+    
+    protected void setPoint(final int location, final PointF point) {
+        runOnDraw(new Runnable() {
+
+            @Override
+            public void run() {
+            	float[] vec2 = new float[2];
+            	vec2[0] = point.x;
+            	vec2[1] = point.y;
+                GLES20.glUniform2fv(location, 1, vec2, 0);
+            }
+        });
+    }
+
     protected void setUniformMatrix3f(final int location, final float[] matrix) {
         runOnDraw(new Runnable() {
 
@@ -178,4 +256,24 @@ protected void runOnDraw(final Runnable runnable) {
             mRunOnDraw.addLast(runnable);
         }
     }
+    
+    public static String loadShader(String file, Context context){
+    	try{
+	        AssetManager assetManager = context.getAssets();
+	        InputStream ims = assetManager.open( file );
+	        
+	        String re = convertStreamToString( ims );
+	        ims.close();
+	        return re;
+        }catch(Exception e){
+        	e.printStackTrace();
+        }
+    	
+    	return "";
+    }
+    
+    public static String convertStreamToString(java.io.InputStream is) {
+        java.util.Scanner s = new java.util.Scanner(is).useDelimiter("\\A");
+        return s.hasNext() ? s.next() : "";
+    }
 }
diff --git a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageTwoInputFilter.java b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageTwoInputFilter.java
new file mode 100644
index 00000000..dd8e648a
--- /dev/null
+++ b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageTwoInputFilter.java
@@ -0,0 +1,194 @@
+package jp.co.cyberagent.android.gpuimage;
+
+import java.nio.ByteBuffer;
+import java.nio.ByteOrder;
+import java.nio.FloatBuffer;
+
+import android.content.Context;
+import android.graphics.Bitmap;
+import android.graphics.BitmapFactory;
+import android.opengl.GLES20;
+import android.util.Log;
+
+public class GPUImageTwoInputFilter extends GPUImageFilter{
+	private static final String VERTEX_SHADER = "attribute vec4 position;\n" + 
+			"attribute vec4 inputTextureCoordinate;\n" + 
+			"attribute vec4 inputTextureCoordinate2;\n" + 
+			" \n" + 
+			"varying vec2 textureCoordinate;\n" + 
+			"varying vec2 textureCoordinate2;\n" + 
+			" \n" + 
+			"void main()\n" + 
+			"{\n" + 
+			"    gl_Position = position;\n" + 
+			"    textureCoordinate = inputTextureCoordinate.xy;\n" + 
+			"    textureCoordinate2 = inputTextureCoordinate2.xy;\n" + 
+			"}";
+	
+	
+	public int filterSecondTextureCoordinateAttribute;
+	public int filterInputTextureUniform2;
+	public int inputRotation2;
+	public int filterSourceTexture2 = OpenGlUtils.NO_TEXTURE;
+	public boolean mIsInitialized = false;
+	private Bitmap mBitmap = null;
+	
+	private Context mContext;
+	
+	public GPUImageTwoInputFilter( Context context , String vertexShader, String fragmentShader ){
+		super(vertexShader, fragmentShader );
+	}
+	
+	public GPUImageTwoInputFilter(Context context, String fragmentShader ){
+		super(VERTEX_SHADER, fragmentShader );
+	}
+	
+	@Override
+	public void onInit(){
+		super.onInit();
+		
+		filterSecondTextureCoordinateAttribute = GLES20.glGetAttribLocation(mGLProgId, "inputTextureCoordinate2");
+        filterInputTextureUniform2 = GLES20.glGetUniformLocation(mGLProgId, "inputImageTexture2"); // This does assume a name of "inputImageTexture2" for second input texture in the fragment shader
+        GLES20.glEnableVertexAttribArray(filterSecondTextureCoordinateAttribute);
+		
+		mIsInitialized = true;
+		
+	}
+	
+	public void setBitmap(final Bitmap bm){ 
+		runOnDraw( new Runnable(){
+			public void run(){
+				if(filterSourceTexture2 == OpenGlUtils.NO_TEXTURE){
+					GLES20.glActiveTexture( GLES20.GL_TEXTURE3 );
+					filterSourceTexture2 = OpenGlUtils.loadTexture(bm, OpenGlUtils.NO_TEXTURE);
+				}
+			}
+		} );
+	}
+	
+	public void onDestroy() {
+        GLES20.glDeleteProgram(mGLProgId);
+        mIsInitialized = false;
+    }
+	
+	
+	@Override
+	public void onDraw(final int textureId, final FloatBuffer cubeBuffer, final FloatBuffer textureBuffer) {
+		GLES20.glUseProgram(mGLProgId);
+        runPendingOnDrawTasks();
+        if (!mIsInitialized) {
+            return;
+        }
+        
+        if(mBitmap != null && !mBitmap.isRecycled()){
+        	setBitmap(mBitmap);
+        }
+
+        cubeBuffer.position(0);
+        GLES20.glVertexAttribPointer(mGLAttribPosition, 2, GLES20.GL_FLOAT, false, 0, cubeBuffer);
+        GLES20.glEnableVertexAttribArray(mGLAttribPosition);
+        textureBuffer.position(0);
+        GLES20.glVertexAttribPointer(mGLAttribTextureCoordinate, 2, GLES20.GL_FLOAT, false, 0,
+                textureBuffer);
+        GLES20.glEnableVertexAttribArray(mGLAttribTextureCoordinate);
+        if (textureId != OpenGlUtils.NO_TEXTURE) {
+            GLES20.glActiveTexture(GLES20.GL_TEXTURE0);
+            GLES20.glBindTexture(GLES20.GL_TEXTURE_2D, textureId);
+            GLES20.glUniform1i(mGLUniformTexture, 0);
+        }
+        
+        GLES20.glEnableVertexAttribArray(filterSecondTextureCoordinateAttribute);
+        GLES20.glActiveTexture(GLES20.GL_TEXTURE3);
+        GLES20.glBindTexture(GLES20.GL_TEXTURE_2D, filterSourceTexture2);                
+        GLES20.glUniform1i(filterInputTextureUniform2, 3);
+        
+        GLES20.glVertexAttribPointer(filterSecondTextureCoordinateAttribute, 2, GLES20.GL_FLOAT, false, 0, textureCoordinatesForRotation( kGPUImageNoRotation ) );
+        
+        GLES20.glDrawArrays(GLES20.GL_TRIANGLE_STRIP, 0, 4);
+        GLES20.glDisableVertexAttribArray(mGLAttribPosition);
+        GLES20.glDisableVertexAttribArray(mGLAttribTextureCoordinate);
+        GLES20.glBindTexture(GLES20.GL_TEXTURE_2D, 0);
+	}
+	
+	public static float[] noRotationTextureCoordinates = {
+        0.0f, 0.0f,
+        1.0f, 0.0f,
+        0.0f, 1.0f,
+        1.0f, 1.0f,
+    };
+	
+	static float[] rotateLeftTextureCoordinates = {
+        1.0f, 0.0f,
+        1.0f, 1.0f,
+        0.0f, 0.0f,
+        0.0f, 1.0f,
+    };
+    
+	static float[] rotateRightTextureCoordinates = {
+        0.0f, 1.0f,
+        0.0f, 0.0f,
+        1.0f, 1.0f,
+        1.0f, 0.0f,
+    };
+    
+	static float[] verticalFlipTextureCoordinates = {
+        0.0f, 1.0f,
+        1.0f, 1.0f,
+        0.0f,  0.0f,
+        1.0f,  0.0f,
+    };
+    
+	static float[] horizontalFlipTextureCoordinates = {
+        1.0f, 0.0f,
+        0.0f, 0.0f,
+        1.0f,  1.0f,
+        0.0f,  1.0f,
+    };
+    
+	static float[] rotateRightVerticalFlipTextureCoordinates = {
+        0.0f, 0.0f,
+        0.0f, 1.0f,
+        1.0f, 0.0f,
+        1.0f, 1.0f,
+    };
+    
+	static float[] rotate180TextureCoordinates = {
+        1.0f, 1.0f,
+        0.0f, 1.0f,
+        1.0f, 0.0f,
+        0.0f, 0.0f,
+    };
+	
+	private static final int kGPUImageNoRotation = 1;
+	private static final int kGPUImageRotateLeft = 2;
+	private static final int kGPUImageRotateRight = 3;
+	private static final int kGPUImageFlipVertical = 4;
+	private static final int kGPUImageFlipHorizonal = 5;
+	private static final int kGPUImageRotateRightFlipVertical = 6;
+	private static final int kGPUImageRotate180 = 7;
+	
+	
+	public ByteBuffer textureCoordinatesForRotation( int rotationMode ){
+		float[] buffer = null;
+		switch(rotationMode)
+	    {
+	        case kGPUImageNoRotation: buffer = noRotationTextureCoordinates;
+	        case kGPUImageRotateLeft: buffer = rotateLeftTextureCoordinates;
+	        case kGPUImageRotateRight: buffer = rotateRightTextureCoordinates;
+	        case kGPUImageFlipVertical: buffer = verticalFlipTextureCoordinates;
+	        case kGPUImageFlipHorizonal: buffer = horizontalFlipTextureCoordinates;
+	        case kGPUImageRotateRightFlipVertical: buffer = rotateRightVerticalFlipTextureCoordinates;
+	        case kGPUImageRotate180: buffer = rotate180TextureCoordinates;
+	    }
+		
+		buffer = noRotationTextureCoordinates;
+		ByteBuffer bBuffer = ByteBuffer.allocateDirect( 32 ).order( ByteOrder.nativeOrder() );
+		FloatBuffer fBuffer = bBuffer.asFloatBuffer();
+		fBuffer.put( buffer );
+		fBuffer.flip();
+		
+		
+		return bBuffer;
+		
+	}
+}
diff --git a/sample/res/drawable-nodpi/lookup_amatorka.png b/sample/res/drawable-nodpi/lookup_amatorka.png
new file mode 100644
index 00000000..4a2cc8ac
Binary files /dev/null and b/sample/res/drawable-nodpi/lookup_amatorka.png differ
diff --git a/sample/src/jp/co/cyberagent/android/gpuimage/sample/GPUImageFilterTools.java b/sample/src/jp/co/cyberagent/android/gpuimage/sample/GPUImageFilterTools.java
index ba0d4568..dc232cae 100644
--- a/sample/src/jp/co/cyberagent/android/gpuimage/sample/GPUImageFilterTools.java
+++ b/sample/src/jp/co/cyberagent/android/gpuimage/sample/GPUImageFilterTools.java
@@ -19,29 +19,22 @@
 import java.util.LinkedList;
 import java.util.List;
 
-import jp.co.cyberagent.android.gpuimage.GPUImage3x3ConvolutionFilter;
-import jp.co.cyberagent.android.gpuimage.GPUImage3x3TextureSamplingFilter;
-import jp.co.cyberagent.android.gpuimage.GPUImageBrightnessFilter;
-import jp.co.cyberagent.android.gpuimage.GPUImageContrastFilter;
-import jp.co.cyberagent.android.gpuimage.GPUImageDirectionalSobelEdgeDetectionFilter;
-import jp.co.cyberagent.android.gpuimage.GPUImageEmbossFilter;
-import jp.co.cyberagent.android.gpuimage.GPUImageFilter;
-import jp.co.cyberagent.android.gpuimage.GPUImageFilterGroup;
-import jp.co.cyberagent.android.gpuimage.GPUImageGammaFilter;
-import jp.co.cyberagent.android.gpuimage.GPUImageGrayscaleFilter;
-import jp.co.cyberagent.android.gpuimage.GPUImagePosterizeFilter;
-import jp.co.cyberagent.android.gpuimage.GPUImageSepiaFilter;
-import jp.co.cyberagent.android.gpuimage.GPUImageSharpenFilter;
-import jp.co.cyberagent.android.gpuimage.GPUImageSobelEdgeDetection;
+import jp.co.cyberagent.android.gpuimage.*;
 import android.app.AlertDialog;
 import android.content.Context;
 import android.content.DialogInterface;
+import android.graphics.Bitmap;
+import android.graphics.BitmapFactory;
+import android.graphics.PointF;
 
-public class GPUImageFilterTools {
+public class GPUImageFilterTools {  
     public static void showDialog(final Context context,
             final OnGpuImageFilterChosenListener listener) {
         final FilterList filters = new FilterList();
         filters.addFilter("Contrast", FilterType.CONTRAST);
+        filters.addFilter("Invert", FilterType.INVERT);
+        filters.addFilter("Pixelation", FilterType.PIXELATION);
+        filters.addFilter("Hue", FilterType.HUE);
         filters.addFilter("Gamma", FilterType.GAMMA);
         filters.addFilter("Brightness", FilterType.BRIGHTNESS);
         filters.addFilter("Sepia", FilterType.SEPIA);
@@ -52,7 +45,18 @@ public static void showDialog(final Context context,
         filters.addFilter("Emboss", FilterType.EMBOSS);
         filters.addFilter("Posterize", FilterType.POSTERIZE);
         filters.addFilter("Grouped filters", FilterType.FILTER_GROUP);
-
+        filters.addFilter("Saturation", FilterType.SATURATION);
+        filters.addFilter("Exposure", FilterType.EXPOSURE);
+        filters.addFilter("Highlight Shadow", FilterType.HIGHLIGHT_SHADOW);
+        filters.addFilter("Monochrome", FilterType.MONOCHROME);
+        filters.addFilter("Opacity", FilterType.OPACITY);
+        filters.addFilter("RGB", FilterType.RGB);
+        filters.addFilter("White Balance", FilterType.WHITE_BALANCE);   
+        filters.addFilter("Vignette", FilterType.VIGNETTE);
+        filters.addFilter("ToneCurve", FilterType.TONE_CURVE);
+        filters.addFilter("Blend", FilterType.BLEND);
+        filters.addFilter("Lookup (Amatorka)", FilterType.LOOKUP_AMATORKA);
+          
         AlertDialog.Builder builder = new AlertDialog.Builder(context);
         builder.setTitle("Choose a filter");
         builder.setItems(filters.names.toArray(new String[filters.names.size()]),
@@ -72,6 +76,12 @@ private static GPUImageFilter createFilterForType(final Context context, final F
                 return new GPUImageContrastFilter(2.0f);
             case GAMMA:
                 return new GPUImageGammaFilter(2.0f);
+            case INVERT:
+                return new GPUImageColorInvertFilter();
+            case PIXELATION:
+                return new GPUImagePixelationFilter();
+            case HUE:
+                return new GPUImageHueFilter(90.0f);
             case BRIGHTNESS:
                 return new GPUImageBrightnessFilter(1.5f);
             case GRAYSCALE:
@@ -102,6 +112,38 @@ private static GPUImageFilter createFilterForType(final Context context, final F
                 filters.add(new GPUImageDirectionalSobelEdgeDetectionFilter());
                 filters.add(new GPUImageGrayscaleFilter());
                 return new GPUImageFilterGroup(filters);
+            case SATURATION:
+                return new GPUImageSaturationFilter(1.0f); 
+            case EXPOSURE:
+                return new GPUImageExposureFilter(0.0f);
+            case HIGHLIGHT_SHADOW:
+            	return new GPUImageHighlightShadowFilter(0.0f, 1.0f);
+            case MONOCHROME:
+            	return new GPUImageMonochromeFilter(1.0f, new float[]{0.6f, 0.45f, 0.3f, 1.0f});
+            case OPACITY:
+                return new GPUImageOpacityFilter(1.0f);  
+            case RGB:
+                return new GPUImageRGBFilter(1.0f, 1.0f, 1.0f);  
+            case WHITE_BALANCE:
+                return new GPUImageWhiteBalanceFilter(5000.0f, 0.0f);    
+            case VIGNETTE:
+            	PointF centerPoint = new PointF();
+            	centerPoint.x = 0.5f;
+            	centerPoint.y = 0.5f;
+                return new GPUImageVignetteFilter(centerPoint, new float[] {0.0f, 0.0f, 0.0f}, 0.3f, 0.75f);
+            case TONE_CURVE:
+                GPUImageToneCurveFilter toneCurveFilter = new GPUImageToneCurveFilter();
+                toneCurveFilter.setFromCurveFileInputStream(
+                        context.getResources().openRawResource(R.raw.tone_cuver_sample));
+                return toneCurveFilter;
+            case BLEND:
+            	GPUImageBlendFilter blendFilter = new GPUImageBlendFilter( GPUImageBlendFilter.BLEND_MODE_DIFFERENCE, context );
+            	blendFilter.setBitmap( BitmapFactory.decodeResource(context.getResources(), R.drawable.ic_launcher) );
+            	return blendFilter;
+            case LOOKUP_AMATORKA:
+            	GPUImageLookupFilter amatorka = new GPUImageLookupFilter( context );
+            	amatorka.setBitmap( BitmapFactory.decodeResource(context.getResources(), R.drawable.lookup_amatorka) );
+            	return amatorka;
             default:
                 throw new IllegalStateException("No filter of that type!");
         }
@@ -113,7 +155,8 @@ private static GPUImageFilter createFilterForType(final Context context, final F
     }
 
     private enum FilterType {
-        CONTRAST, GRAYSCALE, SHARPEN, SEPIA, SOBEL_EDGE_DETECTION, THREE_X_THREE_CONVOLUTION, FILTER_GROUP, EMBOSS, POSTERIZE, GAMMA, BRIGHTNESS,
+        CONTRAST, GRAYSCALE, SHARPEN, SEPIA, SOBEL_EDGE_DETECTION, THREE_X_THREE_CONVOLUTION, FILTER_GROUP, EMBOSS, POSTERIZE, GAMMA, BRIGHTNESS, INVERT, HUE, PIXELATION,
+        SATURATION, EXPOSURE, HIGHLIGHT_SHADOW, MONOCHROME, OPACITY, RGB, WHITE_BALANCE, VIGNETTE, TONE_CURVE, BLEND, LOOKUP_AMATORKA
     }
 
     private static class FilterList {
@@ -146,8 +189,28 @@ public FilterAdjuster(final GPUImageFilter filter) {
                 adjuster = new GPU3x3TextureAdjuster().filter(filter);
             } else if (filter instanceof GPUImageEmbossFilter) {
                 adjuster = new EmbossAdjuster().filter(filter);
+            } else if (filter instanceof GPUImageHueFilter) {
+                adjuster = new HueAdjuster().filter(filter);
             } else if (filter instanceof GPUImagePosterizeFilter) {
                 adjuster = new PosterizeAdjuster().filter(filter);
+            } else if (filter instanceof GPUImagePixelationFilter) {
+                adjuster = new PixelationAdjuster().filter(filter);
+            } else if (filter instanceof GPUImageSaturationFilter) {
+                adjuster = new SaturationAdjuster().filter(filter);
+            } else if (filter instanceof GPUImageExposureFilter) {
+                adjuster = new ExposureAdjuster().filter(filter);
+            } else if (filter instanceof GPUImageHighlightShadowFilter) {
+                adjuster = new HighlightShadowAdjuster().filter(filter);
+            } else if (filter instanceof GPUImageMonochromeFilter) {
+                adjuster = new MonochromeAdjuster().filter(filter);
+            } else if (filter instanceof GPUImageOpacityFilter) {
+                adjuster = new OpacityAdjuster().filter(filter);
+            } else if (filter instanceof GPUImageRGBFilter) {
+                adjuster = new RGBAdjuster().filter(filter);
+            } else if (filter instanceof GPUImageWhiteBalanceFilter) {
+                adjuster = new WhiteBalanceAdjuster().filter(filter);
+            } else if (filter instanceof GPUImageVignetteFilter) {
+                adjuster = new VignetteAdjuster().filter(filter);
             } else {
                 adjuster = null;
             }
@@ -190,6 +253,20 @@ public void adjust(final int percentage) {
             }
         }
 
+        private class PixelationAdjuster extends Adjuster<GPUImagePixelationFilter> {
+          @Override
+          public void adjust(final int percentage) {
+              getFilter().setPixel(range(percentage, 1.0f, 100.0f));
+          }
+        }
+
+        private class HueAdjuster extends Adjuster<GPUImageHueFilter> {
+          @Override
+          public void adjust(final int percentage) {
+            getFilter().setHue(range(percentage, 0.0f, 360.0f));
+          }
+        }
+
         private class ContrastAdjuster extends Adjuster<GPUImageContrastFilter> {
             @Override
             public void adjust(final int percentage) {
@@ -246,5 +323,66 @@ public void adjust(final int percentage) {
                 getFilter().setLineSize(range(percentage, 0.0f, 5.0f));
             }
         }
+
+        private class SaturationAdjuster extends Adjuster<GPUImageSaturationFilter> {
+            @Override
+            public void adjust(final int percentage) {
+                getFilter().setSaturation(range(percentage, 0.0f, 2.0f));
+            }
+        }
+        
+        private class ExposureAdjuster extends Adjuster<GPUImageExposureFilter> {
+            @Override
+            public void adjust(final int percentage) {
+                getFilter().setExposure(range(percentage, -10.0f, 10.0f));
+            }
+        }   
+        
+        private class HighlightShadowAdjuster extends Adjuster<GPUImageHighlightShadowFilter> {
+            @Override
+            public void adjust(final int percentage) {
+                getFilter().setShadows(range(percentage, 0.0f, 1.0f));
+                getFilter().setHighlights(range(percentage, 0.0f, 1.0f));
+            }
+        }
+        
+        private class MonochromeAdjuster extends Adjuster<GPUImageMonochromeFilter> {
+            @Override
+            public void adjust(final int percentage) {
+                getFilter().setIntensity(range(percentage, 0.0f, 1.0f));
+                //getFilter().setColor(new float[]{0.6f, 0.45f, 0.3f, 1.0f});
+            }
+        }
+        
+        private class OpacityAdjuster extends Adjuster<GPUImageOpacityFilter> {
+            @Override
+            public void adjust(final int percentage) {
+                getFilter().setOpacity(range(percentage, 0.0f, 1.0f));
+            }
+        }   
+        
+        private class RGBAdjuster extends Adjuster<GPUImageRGBFilter> {
+            @Override
+            public void adjust(final int percentage) {
+                getFilter().setRed(range(percentage, 0.0f, 1.0f));
+                //getFilter().setGreen(range(percentage, 0.0f, 1.0f));
+                //getFilter().setBlue(range(percentage, 0.0f, 1.0f));
+            }
+        }   
+        
+        private class WhiteBalanceAdjuster extends Adjuster<GPUImageWhiteBalanceFilter> {
+            @Override
+            public void adjust(final int percentage) {
+                getFilter().setTemperature(range(percentage, 2000.0f, 8000.0f));
+                //getFilter().setTint(range(percentage, -100.0f, 100.0f));
+            }
+        }   
+        
+        private class VignetteAdjuster extends Adjuster<GPUImageVignetteFilter> {
+            @Override
+            public void adjust(final int percentage) {
+                getFilter().setVignetteStart(range(percentage, 0.0f, 1.0f));
+            }
+        }   
     }
 }
