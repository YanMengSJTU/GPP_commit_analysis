diff --git a/build.gradle b/build.gradle
index 8a29e6b0..23978521 100644
--- a/build.gradle
+++ b/build.gradle
@@ -5,7 +5,7 @@ buildscript {
         jcenter()
     }
     dependencies {
-        classpath 'com.android.tools.build:gradle:2.0.0-beta6'
+        classpath 'com.android.tools.build:gradle:2.1.3'
         classpath 'com.novoda:bintray-release:0.3.4'
     }
 }
diff --git a/gradle.properties b/gradle.properties
index 40c44d7f..ec9ea28e 100644
--- a/gradle.properties
+++ b/gradle.properties
@@ -1,22 +1,37 @@
-VERSION_NAME=1.4.1
-GROUP=jp.co.cyberagent.android.gpuimage
-ARTIFACT_ID=gpuimage-library
-
-COMPILE_SDK_VERSION=23
-BUILD_TOOLS_VERSION=23.0.2
-TARGET_SDK_VERSION=23
+## Project-wide Gradle settings.
+#
+# For more details on how to configure your build environment visit
+# http://www.gradle.org/docs/current/userguide/build_environment.html
+#
+# Specifies the JVM arguments used for the daemon process.
+# The setting is particularly useful for tweaking memory settings.
+# Default value: -Xmx10248m -XX:MaxPermSize=256m
+# org.gradle.jvmargs=-Xmx2048m -XX:MaxPermSize=512m -XX:+HeapDumpOnOutOfMemoryError -Dfile.encoding=UTF-8
+#
+# When configured, Gradle will run in incubating parallel mode.
+# This option should only be used with decoupled projects. More details, visit
+# http://www.gradle.org/docs/current/userguide/multi_project_builds.html#sec:decoupled_projects
+# org.gradle.parallel=true
+#Sat Aug 13 14:19:40 CST 2016
+POM_SCM_URL=scm\:git@github.com\:CyberAgent/android-gpuimage.git
+POM_DEVELOPER_ID=cyberagent
+POM_LICENCE_DIST=repo
+systemProp.http.proxyHost=127.0.0.1
 MIN_SDK_VERSION=8
-
+POM_DEVELOPER_NAME=CyberAgent, Inc.
+POM_LICENCE_URL=http\://www.apache.org/licenses/LICENSE-2.0.txt
 POM_DESCRIPTION=Image filters for Android with OpenGL (based on GPUImage for iOS)
-POM_URL=https://github.com/cyberagent/android-gpuimage
-POM_SCM_URL=scm:git@github.com:CyberAgent/android-gpuimage.git
-POM_SCM_CONNECTION=scm:git@github.com:CyberAgent/android-gpuimage.git
-POM_SCM_DEV_CONNECTION=scm:git@github.com:CyberAgent/android-gpuimage.git
 POM_LICENCE_NAME=The Apache Software License, Version 2.0
-POM_LICENCE_URL=http://www.apache.org/licenses/LICENSE-2.0.txt
-POM_LICENCE_DIST=repo
-POM_DEVELOPER_ID=cyberagent
-POM_DEVELOPER_NAME=CyberAgent, Inc.
-ISSUE_URL=https://github.com/CyberAgent/android-gpuimage/issues
-
 android.useDeprecatedNdk=true
+BUILD_TOOLS_VERSION=23.0.3
+ISSUE_URL=https\://github.com/CyberAgent/android-gpuimage/issues
+VERSION_NAME=1.4.1
+POM_SCM_DEV_CONNECTION=scm\:git@github.com\:CyberAgent/android-gpuimage.git
+TARGET_SDK_VERSION=23
+POM_URL=https\://github.com/cyberagent/android-gpuimage
+COMPILE_SDK_VERSION=23
+ARTIFACT_ID=gpuimage-library
+POM_SCM_CONNECTION=scm\:git@github.com\:CyberAgent/android-gpuimage.git
+GROUP=jp.co.cyberagent.android.gpuimage
+systemProp.http.proxyPort=1080
+org.gradle.jvmargs=-Xmx2048M
\ No newline at end of file
diff --git a/gradle/wrapper/gradle-wrapper.properties b/gradle/wrapper/gradle-wrapper.properties
index 6c0732ab..f0d58d29 100644
--- a/gradle/wrapper/gradle-wrapper.properties
+++ b/gradle/wrapper/gradle-wrapper.properties
@@ -1,6 +1,6 @@
-#Sat Dec 06 18:27:05 JST 2014
+#Sun Aug 21 20:32:45 CST 2016
 distributionBase=GRADLE_USER_HOME
 distributionPath=wrapper/dists
 zipStoreBase=GRADLE_USER_HOME
 zipStorePath=wrapper/dists
-distributionUrl=https\://services.gradle.org/distributions/gradle-2.11-all.zip
+distributionUrl=https\://services.gradle.org/distributions/gradle-2.14.1-all.zip
diff --git a/library/project.properties b/library/project.properties
index 93c8c3c0..b2ef7dcc 100644
--- a/library/project.properties
+++ b/library/project.properties
@@ -11,5 +11,5 @@
 #proguard.config=${sdk.dir}/tools/proguard/proguard-android.txt:proguard-project.txt
 
 # Project target.
-target=android-21
+target=android-23
 android.library=true
diff --git a/library/res/drawable-nodpi/texture_amaro_map.png b/library/res/drawable-nodpi/texture_amaro_map.png
new file mode 100644
index 00000000..4a5353c1
Binary files /dev/null and b/library/res/drawable-nodpi/texture_amaro_map.png differ
diff --git a/library/res/drawable-nodpi/texture_blackboard.png b/library/res/drawable-nodpi/texture_blackboard.png
new file mode 100644
index 00000000..0c914dc4
Binary files /dev/null and b/library/res/drawable-nodpi/texture_blackboard.png differ
diff --git a/library/res/drawable-nodpi/texture_brannan_blowout.png b/library/res/drawable-nodpi/texture_brannan_blowout.png
new file mode 100644
index 00000000..4eabfa5c
Binary files /dev/null and b/library/res/drawable-nodpi/texture_brannan_blowout.png differ
diff --git a/library/res/drawable-nodpi/texture_brannan_contrast.png b/library/res/drawable-nodpi/texture_brannan_contrast.png
new file mode 100644
index 00000000..2bcb1d3f
Binary files /dev/null and b/library/res/drawable-nodpi/texture_brannan_contrast.png differ
diff --git a/library/res/drawable-nodpi/texture_brannan_luma.png b/library/res/drawable-nodpi/texture_brannan_luma.png
new file mode 100644
index 00000000..3dc01a64
Binary files /dev/null and b/library/res/drawable-nodpi/texture_brannan_luma.png differ
diff --git a/library/res/drawable-nodpi/texture_brannan_process.png b/library/res/drawable-nodpi/texture_brannan_process.png
new file mode 100644
index 00000000..5986f1b5
Binary files /dev/null and b/library/res/drawable-nodpi/texture_brannan_process.png differ
diff --git a/library/res/drawable-nodpi/texture_brannan_screen.png b/library/res/drawable-nodpi/texture_brannan_screen.png
new file mode 100644
index 00000000..0b264610
Binary files /dev/null and b/library/res/drawable-nodpi/texture_brannan_screen.png differ
diff --git a/library/res/drawable-nodpi/texture_earlybird_blowout.png b/library/res/drawable-nodpi/texture_earlybird_blowout.png
new file mode 100644
index 00000000..4ecc68a2
Binary files /dev/null and b/library/res/drawable-nodpi/texture_earlybird_blowout.png differ
diff --git a/library/res/drawable-nodpi/texture_earlybird_curves.png b/library/res/drawable-nodpi/texture_earlybird_curves.png
new file mode 100644
index 00000000..e067ac75
Binary files /dev/null and b/library/res/drawable-nodpi/texture_earlybird_curves.png differ
diff --git a/library/res/drawable-nodpi/texture_earlybird_map.png b/library/res/drawable-nodpi/texture_earlybird_map.png
new file mode 100644
index 00000000..a2677a5d
Binary files /dev/null and b/library/res/drawable-nodpi/texture_earlybird_map.png differ
diff --git a/library/res/drawable-nodpi/texture_earlybird_overlay_map.png b/library/res/drawable-nodpi/texture_earlybird_overlay_map.png
new file mode 100644
index 00000000..7354055f
Binary files /dev/null and b/library/res/drawable-nodpi/texture_earlybird_overlay_map.png differ
diff --git a/library/res/drawable-nodpi/texture_edge_burn.png b/library/res/drawable-nodpi/texture_edge_burn.png
new file mode 100644
index 00000000..04f831b9
Binary files /dev/null and b/library/res/drawable-nodpi/texture_edge_burn.png differ
diff --git a/library/res/drawable-nodpi/texture_hefe_gradient_map.png b/library/res/drawable-nodpi/texture_hefe_gradient_map.png
new file mode 100644
index 00000000..8014346e
Binary files /dev/null and b/library/res/drawable-nodpi/texture_hefe_gradient_map.png differ
diff --git a/library/res/drawable-nodpi/texture_hefe_map.png b/library/res/drawable-nodpi/texture_hefe_map.png
new file mode 100644
index 00000000..1b7fcad0
Binary files /dev/null and b/library/res/drawable-nodpi/texture_hefe_map.png differ
diff --git a/library/res/drawable-nodpi/texture_hefe_metal.png b/library/res/drawable-nodpi/texture_hefe_metal.png
new file mode 100644
index 00000000..3c137c67
Binary files /dev/null and b/library/res/drawable-nodpi/texture_hefe_metal.png differ
diff --git a/library/res/drawable-nodpi/texture_hefe_soft_light.png b/library/res/drawable-nodpi/texture_hefe_soft_light.png
new file mode 100644
index 00000000..47c3b9dd
Binary files /dev/null and b/library/res/drawable-nodpi/texture_hefe_soft_light.png differ
diff --git a/library/res/drawable-nodpi/texture_hudson_background.png b/library/res/drawable-nodpi/texture_hudson_background.png
new file mode 100644
index 00000000..ff722c22
Binary files /dev/null and b/library/res/drawable-nodpi/texture_hudson_background.png differ
diff --git a/library/res/drawable-nodpi/texture_hudson_map.png b/library/res/drawable-nodpi/texture_hudson_map.png
new file mode 100644
index 00000000..00cb1dbf
Binary files /dev/null and b/library/res/drawable-nodpi/texture_hudson_map.png differ
diff --git a/library/res/drawable-nodpi/texture_inkwell_map.png b/library/res/drawable-nodpi/texture_inkwell_map.png
new file mode 100644
index 00000000..e9541f18
Binary files /dev/null and b/library/res/drawable-nodpi/texture_inkwell_map.png differ
diff --git a/library/res/drawable-nodpi/texture_kelvin_map.png b/library/res/drawable-nodpi/texture_kelvin_map.png
new file mode 100644
index 00000000..e5eb5af6
Binary files /dev/null and b/library/res/drawable-nodpi/texture_kelvin_map.png differ
diff --git a/library/res/drawable-nodpi/texture_lomo_map.png b/library/res/drawable-nodpi/texture_lomo_map.png
new file mode 100644
index 00000000..fcd10aa3
Binary files /dev/null and b/library/res/drawable-nodpi/texture_lomo_map.png differ
diff --git a/library/res/drawable-nodpi/texture_nashville_map.png b/library/res/drawable-nodpi/texture_nashville_map.png
new file mode 100644
index 00000000..490feceb
Binary files /dev/null and b/library/res/drawable-nodpi/texture_nashville_map.png differ
diff --git a/library/res/drawable-nodpi/texture_nblowout.png b/library/res/drawable-nodpi/texture_nblowout.png
new file mode 100644
index 00000000..f97b39c2
Binary files /dev/null and b/library/res/drawable-nodpi/texture_nblowout.png differ
diff --git a/library/res/drawable-nodpi/texture_nmap.png b/library/res/drawable-nodpi/texture_nmap.png
new file mode 100644
index 00000000..1c4cc633
Binary files /dev/null and b/library/res/drawable-nodpi/texture_nmap.png differ
diff --git a/library/res/drawable-nodpi/texture_overlay_map.png b/library/res/drawable-nodpi/texture_overlay_map.png
new file mode 100644
index 00000000..ea92b16c
Binary files /dev/null and b/library/res/drawable-nodpi/texture_overlay_map.png differ
diff --git a/library/res/drawable-nodpi/texture_rise_map.png b/library/res/drawable-nodpi/texture_rise_map.png
new file mode 100644
index 00000000..4903c9f8
Binary files /dev/null and b/library/res/drawable-nodpi/texture_rise_map.png differ
diff --git a/library/res/drawable-nodpi/texture_sierra_map.png b/library/res/drawable-nodpi/texture_sierra_map.png
new file mode 100644
index 00000000..8efe2a08
Binary files /dev/null and b/library/res/drawable-nodpi/texture_sierra_map.png differ
diff --git a/library/res/drawable-nodpi/texture_sierra_vignette.png b/library/res/drawable-nodpi/texture_sierra_vignette.png
new file mode 100644
index 00000000..4f6d24b7
Binary files /dev/null and b/library/res/drawable-nodpi/texture_sierra_vignette.png differ
diff --git a/library/res/drawable-nodpi/texture_soft_light.png b/library/res/drawable-nodpi/texture_soft_light.png
new file mode 100644
index 00000000..352dbb7d
Binary files /dev/null and b/library/res/drawable-nodpi/texture_soft_light.png differ
diff --git a/library/res/drawable-nodpi/texture_sutro_curves.png b/library/res/drawable-nodpi/texture_sutro_curves.png
new file mode 100644
index 00000000..c3bf9495
Binary files /dev/null and b/library/res/drawable-nodpi/texture_sutro_curves.png differ
diff --git a/library/res/drawable-nodpi/texture_sutro_edge_burn.png b/library/res/drawable-nodpi/texture_sutro_edge_burn.png
new file mode 100644
index 00000000..fa40b611
Binary files /dev/null and b/library/res/drawable-nodpi/texture_sutro_edge_burn.png differ
diff --git a/library/res/drawable-nodpi/texture_sutro_metal.png b/library/res/drawable-nodpi/texture_sutro_metal.png
new file mode 100644
index 00000000..1b05d5bf
Binary files /dev/null and b/library/res/drawable-nodpi/texture_sutro_metal.png differ
diff --git a/library/res/drawable-nodpi/texture_toaster_color_shift.png b/library/res/drawable-nodpi/texture_toaster_color_shift.png
new file mode 100644
index 00000000..c006889f
Binary files /dev/null and b/library/res/drawable-nodpi/texture_toaster_color_shift.png differ
diff --git a/library/res/drawable-nodpi/texture_toaster_curves.png b/library/res/drawable-nodpi/texture_toaster_curves.png
new file mode 100644
index 00000000..dcf8808f
Binary files /dev/null and b/library/res/drawable-nodpi/texture_toaster_curves.png differ
diff --git a/library/res/drawable-nodpi/texture_toaster_metal.png b/library/res/drawable-nodpi/texture_toaster_metal.png
new file mode 100644
index 00000000..76e69dcb
Binary files /dev/null and b/library/res/drawable-nodpi/texture_toaster_metal.png differ
diff --git a/library/res/drawable-nodpi/texture_toaster_overlay_map_warm.png b/library/res/drawable-nodpi/texture_toaster_overlay_map_warm.png
new file mode 100644
index 00000000..32c5f4d9
Binary files /dev/null and b/library/res/drawable-nodpi/texture_toaster_overlay_map_warm.png differ
diff --git a/library/res/drawable-nodpi/texture_toaster_soft_light.png b/library/res/drawable-nodpi/texture_toaster_soft_light.png
new file mode 100644
index 00000000..0801e206
Binary files /dev/null and b/library/res/drawable-nodpi/texture_toaster_soft_light.png differ
diff --git a/library/res/drawable-nodpi/texture_valencia_gradient_map.png b/library/res/drawable-nodpi/texture_valencia_gradient_map.png
new file mode 100644
index 00000000..d7a4cd34
Binary files /dev/null and b/library/res/drawable-nodpi/texture_valencia_gradient_map.png differ
diff --git a/library/res/drawable-nodpi/texture_valencia_map.png b/library/res/drawable-nodpi/texture_valencia_map.png
new file mode 100644
index 00000000..5cc13317
Binary files /dev/null and b/library/res/drawable-nodpi/texture_valencia_map.png differ
diff --git a/library/res/drawable-nodpi/texture_vignette_map.png b/library/res/drawable-nodpi/texture_vignette_map.png
new file mode 100644
index 00000000..548201b0
Binary files /dev/null and b/library/res/drawable-nodpi/texture_vignette_map.png differ
diff --git a/library/res/drawable-nodpi/texture_walden_map.png b/library/res/drawable-nodpi/texture_walden_map.png
new file mode 100644
index 00000000..19a283c2
Binary files /dev/null and b/library/res/drawable-nodpi/texture_walden_map.png differ
diff --git a/library/res/drawable-nodpi/texture_xpro_map.png b/library/res/drawable-nodpi/texture_xpro_map.png
new file mode 100644
index 00000000..893fb622
Binary files /dev/null and b/library/res/drawable-nodpi/texture_xpro_map.png differ
diff --git a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageFilterGroup.java b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageFilterGroup.java
index 10ea41ca..7ab7c3dc 100644
--- a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageFilterGroup.java
+++ b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageFilterGroup.java
@@ -40,9 +40,9 @@
     private int[] mFrameBuffers;
     private int[] mFrameBufferTextures;
 
-    private final FloatBuffer mGLCubeBuffer;
-    private final FloatBuffer mGLTextureBuffer;
-    private final FloatBuffer mGLTextureFlipBuffer;
+    private FloatBuffer mGLCubeBuffer;
+    private FloatBuffer mGLTextureBuffer;
+    private FloatBuffer mGLTextureFlipBuffer;
 
     /**
      * Instantiates a new GPUImageFilterGroup with no filters.
@@ -59,26 +59,10 @@ public GPUImageFilterGroup() {
     public GPUImageFilterGroup(List<GPUImageFilter> filters) {
         mFilters = filters;
         if (mFilters == null) {
-            mFilters = new ArrayList<GPUImageFilter>();
+            mFilters = new ArrayList<>();
         } else {
             updateMergedFilters();
         }
-
-        mGLCubeBuffer = ByteBuffer.allocateDirect(CUBE.length * 4)
-                .order(ByteOrder.nativeOrder())
-                .asFloatBuffer();
-        mGLCubeBuffer.put(CUBE).position(0);
-
-        mGLTextureBuffer = ByteBuffer.allocateDirect(TEXTURE_NO_ROTATION.length * 4)
-                .order(ByteOrder.nativeOrder())
-                .asFloatBuffer();
-        mGLTextureBuffer.put(TEXTURE_NO_ROTATION).position(0);
-
-        float[] flipTexture = TextureRotationUtil.getRotation(Rotation.NORMAL, false, true);
-        mGLTextureFlipBuffer = ByteBuffer.allocateDirect(flipTexture.length * 4)
-                .order(ByteOrder.nativeOrder())
-                .asFloatBuffer();
-        mGLTextureFlipBuffer.put(flipTexture).position(0);
     }
 
     public void addFilter(GPUImageFilter aFilter) {
@@ -96,6 +80,23 @@ public void addFilter(GPUImageFilter aFilter) {
     @Override
     public void onInit() {
         super.onInit();
+
+        mGLCubeBuffer = ByteBuffer.allocateDirect(CUBE.length * 4)
+                .order(ByteOrder.nativeOrder())
+                .asFloatBuffer();
+        mGLCubeBuffer.put(CUBE).position(0);
+
+        mGLTextureBuffer = ByteBuffer.allocateDirect(TEXTURE_NO_ROTATION.length * 4)
+                .order(ByteOrder.nativeOrder())
+                .asFloatBuffer();
+        mGLTextureBuffer.put(TEXTURE_NO_ROTATION).position(0);
+
+        float[] flipTexture = TextureRotationUtil.getRotation(Rotation.NORMAL, false, true);
+        mGLTextureFlipBuffer = ByteBuffer.allocateDirect(flipTexture.length * 4)
+                .order(ByteOrder.nativeOrder())
+                .asFloatBuffer();
+        mGLTextureFlipBuffer.put(flipTexture).position(0);
+
         for (GPUImageFilter filter : mFilters) {
             filter.init();
         }
@@ -232,7 +233,7 @@ public void updateMergedFilters() {
         }
 
         if (mMergedFilters == null) {
-            mMergedFilters = new ArrayList<GPUImageFilter>();
+            mMergedFilters = new ArrayList<>();
         } else {
             mMergedFilters.clear();
         }
diff --git a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageGaussianBlurFilter.java b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageGaussianBlurFilter.java
index c912f73e..bf5b92ad 100644
--- a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageGaussianBlurFilter.java
+++ b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageGaussianBlurFilter.java
@@ -16,79 +16,120 @@
 
 package jp.co.cyberagent.android.gpuimage;
 
-/**
- * A more generalized 9x9 Gaussian blur filter
- * blurSize value ranging from 0.0 on up, with a default of 1.0
- */
+import android.graphics.PointF;
+import android.opengl.GLES20;
+
 public class GPUImageGaussianBlurFilter extends GPUImageTwoPassTextureSamplingFilter {
-    public static final String VERTEX_SHADER =
-            "attribute vec4 position;\n" +
-                    "attribute vec4 inputTextureCoordinate;\n" +
-                    "\n" +
-                    "const int GAUSSIAN_SAMPLES = 9;\n" +
-                    "\n" +
-                    "uniform float texelWidthOffset;\n" +
-                    "uniform float texelHeightOffset;\n" +
-                    "\n" +
-                    "varying vec2 textureCoordinate;\n" +
-                    "varying vec2 blurCoordinates[GAUSSIAN_SAMPLES];\n" +
-                    "\n" +
-                    "void main()\n" +
-                    "{\n" +
-                    "	gl_Position = position;\n" +
-                    "	textureCoordinate = inputTextureCoordinate.xy;\n" +
-                    "	\n" +
-                    "	// Calculate the positions for the blur\n" +
-                    "	int multiplier = 0;\n" +
-                    "	vec2 blurStep;\n" +
-                    "   vec2 singleStepOffset = vec2(texelHeightOffset, texelWidthOffset);\n" +
-                    "    \n" +
-                    "	for (int i = 0; i < GAUSSIAN_SAMPLES; i++)\n" +
-                    "   {\n" +
-                    "		multiplier = (i - ((GAUSSIAN_SAMPLES - 1) / 2));\n" +
-                    "       // Blur in x (horizontal)\n" +
-                    "       blurStep = float(multiplier) * singleStepOffset;\n" +
-                    "		blurCoordinates[i] = inputTextureCoordinate.xy + blurStep;\n" +
-                    "	}\n" +
-                    "}\n";
-
-    public static final String FRAGMENT_SHADER =
-            "uniform sampler2D inputImageTexture;\n" +
-                    "\n" +
-                    "const lowp int GAUSSIAN_SAMPLES = 9;\n" +
-                    "\n" +
-                    "varying highp vec2 textureCoordinate;\n" +
-                    "varying highp vec2 blurCoordinates[GAUSSIAN_SAMPLES];\n" +
-                    "\n" +
-                    "void main()\n" +
-                    "{\n" +
-                    "	lowp vec3 sum = vec3(0.0);\n" +
-                    "   lowp vec4 fragColor=texture2D(inputImageTexture,textureCoordinate);\n" +
-                    "	\n" +
-                    "    sum += texture2D(inputImageTexture, blurCoordinates[0]).rgb * 0.05;\n" +
-                    "    sum += texture2D(inputImageTexture, blurCoordinates[1]).rgb * 0.09;\n" +
-                    "    sum += texture2D(inputImageTexture, blurCoordinates[2]).rgb * 0.12;\n" +
-                    "    sum += texture2D(inputImageTexture, blurCoordinates[3]).rgb * 0.15;\n" +
-                    "    sum += texture2D(inputImageTexture, blurCoordinates[4]).rgb * 0.18;\n" +
-                    "    sum += texture2D(inputImageTexture, blurCoordinates[5]).rgb * 0.15;\n" +
-                    "    sum += texture2D(inputImageTexture, blurCoordinates[6]).rgb * 0.12;\n" +
-                    "    sum += texture2D(inputImageTexture, blurCoordinates[7]).rgb * 0.09;\n" +
-                    "    sum += texture2D(inputImageTexture, blurCoordinates[8]).rgb * 0.05;\n" +
-                    "\n" +
-                    "	gl_FragColor = vec4(sum,fragColor.a);\n" +
-                    "}";
+
+    private static String vertexShaderForStandardBlurOfRadius(final int radius, final float sigma) {
+        if (1 > radius) {
+            return NO_FILTER_VERTEX_SHADER;
+        }
+        int samples = radius * 2 + 1;
+        String shaderString =
+                "attribute vec4 position;\n" +
+                "attribute vec4 inputTextureCoordinate;\n" +
+                "\n" +
+                "const int SAMPLES = " + samples + ";\n" +
+                "uniform float texelWidthOffset;\n" +
+                "uniform float texelHeightOffset;\n" +
+                "\n" +
+                "varying vec2 blurCoordinates[SAMPLES];\n" +
+                "\n" +
+                "void main()\n" +
+                "{\n" +
+                "    gl_Position = position;\n" +
+                "    \n" +
+                "    vec2 singleStepOffset = vec2(texelWidthOffset, texelHeightOffset);\n";
+        for (int i = 0; i < samples; ++i) {
+            int offsetFromCenter = i - radius;
+            shaderString += "    blurCoordinates[" + i + "] = inputTextureCoordinate.xy";
+            if (0 > offsetFromCenter) {
+                shaderString += " - singleStepOffset * " + (float) -offsetFromCenter;
+            } else if (0 < offsetFromCenter) {
+                shaderString += " + singleStepOffset * " + (float) offsetFromCenter;
+            }
+            shaderString += ";\n";
+        }
+        shaderString += "}\n";
+        return shaderString;
+    }
+
+    private static String fragmentShaderForStandardBlurOfRadius(final int radius, final float sigma) {
+        if (1 > radius) {
+            return NO_FILTER_FRAGMENT_SHADER;
+        }
+        // First, generate the normal Gaussian weights for a given sigma
+        int i;
+        final int weights = radius + 1;
+        final int samples = radius * 2+ 1;
+        float sumOfWeights = 0.0f;
+        float standardGaussianWeights[] = new float[weights];
+        for (i = 0; i < weights; ++i) {
+            standardGaussianWeights[i] = (float) ((1.0 / Math.sqrt(2.0 * Math.PI * Math.pow(sigma, 2.0))) * Math.exp(-Math.pow(i, 2.0) / (2.0 * Math.pow(sigma, 2.0))));
+            if (0 == i) {
+                sumOfWeights += standardGaussianWeights[i];
+            } else {
+                sumOfWeights += 2.0 * standardGaussianWeights[i];
+            }
+        }
+        for (i = 0; i < weights; ++i) {
+            standardGaussianWeights[i] = standardGaussianWeights[i] / sumOfWeights;
+        }
+        String shaderString =
+                "uniform sampler2D inputImageTexture;\n" +
+                "varying highp vec2 blurCoordinates[" + samples + "];\n" +
+                "void main() {\n" +
+                "    lowp vec4 sum = vec4(0.0);\n";
+        for (i = 0; i < samples; ++i) {
+            int offsetFromCenter = i - radius;
+            shaderString += "    sum += texture2D(inputImageTexture, blurCoordinates[" + i + "]) * ";
+            if (0 > offsetFromCenter) {
+                shaderString += standardGaussianWeights[-offsetFromCenter];
+            } else {
+                shaderString += standardGaussianWeights[ offsetFromCenter];
+            }
+            shaderString += ";\n";
+        }
+        shaderString +=
+                "    gl_FragColor = sum;\n" +
+                "}\n";
+        return shaderString;
+    }
 
     protected float mBlurSize = 1f;
+    protected int mRadiusInPixel = 2;
 
     public GPUImageGaussianBlurFilter() {
-        this(1f);
+        this(1.0f, 2);
     }
 
-    public GPUImageGaussianBlurFilter(float blurSize) {
-        super(VERTEX_SHADER, FRAGMENT_SHADER, VERTEX_SHADER, FRAGMENT_SHADER);
+    public GPUImageGaussianBlurFilter(float blurSize, int radiusInPixel) {
+        super(vertexShaderForStandardBlurOfRadius(4, 2.0f),
+            fragmentShaderForStandardBlurOfRadius(4, 2.0f),
+            vertexShaderForStandardBlurOfRadius(4, 2.0f),
+            fragmentShaderForStandardBlurOfRadius(4, 2.0f));
         mBlurSize = blurSize;
+        mRadiusInPixel = radiusInPixel;
     }
 
+//    @Override
+//    public void onInit() {
+//        super.onInit();
+//        GPUImageFilter filter = mFilters.get(1);
+//        mAspectRatioLocation = GLES20.glGetUniformLocation(filter.getProgram(), "aspectRatio");
+//        mCenterLocation = GLES20.glGetUniformLocation(filter.getProgram(), "blurCenter");
+//        mRadiusLocation = GLES20.glGetUniformLocation(filter.getProgram(), "blurRadius");
+//    }
+//
+//    @Override
+//    public void onInitialized() {
+//        super.onInitialized();
+//        setCenter(mCenter);
+//        setRadius(mRadius);
+//        setAspectRatio(1.0f);
+//    }
+
     @Override
     public float getVerticalTexelOffsetRatio() {
         return mBlurSize;
@@ -113,4 +154,55 @@ public void run() {
             }
         });
     }
+
+//    public void setAspectRatio(final float aspectRatio) {
+//        mAspectRatio = aspectRatio;
+//        setFloat(mAspectRatioLocation, mAspectRatio);
+//    }
+//
+//    public void setCenter(final PointF center) {
+//        mCenter = center;
+//        setPoint(mCenterLocation, mCenter);
+//    }
+//
+//    public void setRadius(final float radius) {
+//        mRadius = radius;
+//        setFloat(mRadiusLocation, mRadius);
+//    }
+
+    public void setRadiusInPixel(final int radiusInPixel) {
+        if (mRadiusInPixel == radiusInPixel
+                || 1 > radiusInPixel) {
+            return;
+        }
+        mRadiusInPixel = radiusInPixel;
+
+        runOnDraw(new Runnable() {
+            @Override
+            public void run() {
+//                destroy();
+                for (GPUImageFilter filter : mFilters) {
+                    filter.destroy();
+                }
+                mFilters.clear();
+                final float minimumWeightToFindEdgeOfSamplingArea = 1.0f/256.0f;
+                int sampleRadius = (int) Math.floor(Math.sqrt(
+                        -2.0 * Math.pow(mRadiusInPixel, 2.0)
+                                * Math.log(minimumWeightToFindEdgeOfSamplingArea * Math.sqrt(2.0 * Math.PI * Math.pow(mRadiusInPixel, 2.0)))
+                ));
+                String vertexShader = vertexShaderForStandardBlurOfRadius(sampleRadius, radiusInPixel);
+                String fragmentShader = fragmentShaderForStandardBlurOfRadius(sampleRadius, radiusInPixel);
+                addFilter(new GPUImageFilter(vertexShader, fragmentShader));
+                addFilter(new GPUImageFilter(vertexShader, fragmentShader));
+                for (GPUImageFilter filter : mFilters) {
+                    filter.init();
+                }
+                updateMergedFilters();
+                initTexelOffsets();
+//                init();
+//                GLES20.glUseProgram(getProgram());
+
+            }
+        });
+    }
 }
diff --git a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageGaussianBlurPositionFilter.java b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageGaussianBlurPositionFilter.java
new file mode 100644
index 00000000..086fb931
--- /dev/null
+++ b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageGaussianBlurPositionFilter.java
@@ -0,0 +1,168 @@
+/*
+ * Copyright (C) 2012 CyberAgent
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package jp.co.cyberagent.android.gpuimage;
+
+import android.graphics.PointF;
+import android.opengl.GLES20;
+
+/**
+ * A more generalized 9x9 Gaussian blur filter
+ * blurSize value ranging from 0.0 on up, with a default of 1.0
+ */
+public class GPUImageGaussianBlurPositionFilter extends GPUImageTwoPassTextureSamplingFilter {
+    public static final String VERTEX_SHADER =
+            "attribute vec4 position;\n" +
+            "attribute vec4 inputTextureCoordinate;\n" +
+            "\n" +
+            "const int GAUSSIAN_SAMPLES = 9;\n" +
+            "\n" +
+            "uniform float texelWidthOffset;\n" +
+            "uniform float texelHeightOffset;\n" +
+            "\n" +
+            "varying vec2 textureCoordinate;\n" +
+            "varying vec2 blurCoordinates[GAUSSIAN_SAMPLES];\n" +
+            "\n" +
+            "void main()\n" +
+            "{\n" +
+            "	gl_Position = position;\n" +
+            "	textureCoordinate = inputTextureCoordinate.xy;\n" +
+            "	\n" +
+//            "	// Calculate the positions for the blur\n" +
+            "	int multiplier = 0;\n" +
+            "	vec2 blurStep;\n" +
+            "   vec2 singleStepOffset = vec2(texelHeightOffset, texelWidthOffset);\n" +
+            "    \n" +
+            "	for (int i = 0; i < GAUSSIAN_SAMPLES; i++)\n" +
+            "   {\n" +
+            "		multiplier = (i - ((GAUSSIAN_SAMPLES - 1) / 2));\n" +
+//            "       // Blur in x (horizontal)\n" +
+            "       blurStep = float(multiplier) * singleStepOffset;\n" +
+            "		blurCoordinates[i] = inputTextureCoordinate.xy + blurStep;\n" +
+            "	}\n" +
+            "}\n";
+
+    public static final String FRAGMENT_SHADER =
+            "uniform sampler2D inputImageTexture;\n" +
+            "\n" +
+            "const lowp int GAUSSIAN_SAMPLES = 9;\n" +
+            "\n" +
+            "varying highp vec2 textureCoordinate;\n" +
+            "varying highp vec2 blurCoordinates[GAUSSIAN_SAMPLES];\n" +
+            "\n" +
+            "uniform float aspectRatio;\n" +
+            "uniform float blurRadius;\n" +
+            "uniform vec2 blurCenter;\n" +
+            "\n" +
+            "void main()\n" +
+            "{\n" +
+            "    vec2 textureCoordinateToUse = vec2(textureCoordinate.x, (textureCoordinate.y * aspectRatio + 0.5 - 0.5 * aspectRatio));\n" +
+            "    float dist = distance(blurCenter, textureCoordinateToUse);\n" +
+            "\n" +
+            "    if (dist < blurRadius) {\n" +
+            "        vec4 sum = vec4(0.0);\n" +
+            "        sum += texture2D(inputImageTexture, blurCoordinates[0]) * 0.05;\n" +
+            "        sum += texture2D(inputImageTexture, blurCoordinates[1]) * 0.09;\n" +
+            "        sum += texture2D(inputImageTexture, blurCoordinates[2]) * 0.12;\n" +
+            "        sum += texture2D(inputImageTexture, blurCoordinates[3]) * 0.15;\n" +
+            "        sum += texture2D(inputImageTexture, blurCoordinates[4]) * 0.18;\n" +
+            "        sum += texture2D(inputImageTexture, blurCoordinates[5]) * 0.15;\n" +
+            "        sum += texture2D(inputImageTexture, blurCoordinates[6]) * 0.12;\n" +
+            "        sum += texture2D(inputImageTexture, blurCoordinates[7]) * 0.09;\n" +
+            "        sum += texture2D(inputImageTexture, blurCoordinates[8]) * 0.05;\n" +
+            "	     gl_FragColor = sum;\n" +
+            "	 } else {\n" +
+            "	     gl_FragColor = texture2D(inputImageTexture, textureCoordinate);\n" +
+            "	 }\n" +
+            "}";
+
+    protected float mBlurSize = 1f;
+    protected float mAspectRatio = 1.0f;
+    protected float mRadius = 1.0f;
+    private PointF mCenter;
+
+    private int mAspectRatioLocation;
+    private int mCenterLocation;
+    private int mRadiusLocation;
+
+    public GPUImageGaussianBlurPositionFilter() {
+        this(1.5f, 0.5f, new PointF(0.5f, 0.5f));
+    }
+
+    public GPUImageGaussianBlurPositionFilter(float blurSize, float radius, PointF center) {
+        super(VERTEX_SHADER, FRAGMENT_SHADER, VERTEX_SHADER, FRAGMENT_SHADER);
+        mBlurSize = blurSize;
+        mRadius = radius;
+        mCenter = center;
+    }
+
+    @Override
+    public void onInit() {
+        super.onInit();
+        GPUImageFilter filter = mFilters.get(1);
+        mAspectRatioLocation = GLES20.glGetUniformLocation(filter.getProgram(), "aspectRatio");
+        mCenterLocation = GLES20.glGetUniformLocation(filter.getProgram(), "blurCenter");
+        mRadiusLocation = GLES20.glGetUniformLocation(filter.getProgram(), "blurRadius");
+    }
+
+    @Override
+    public void onInitialized() {
+        super.onInitialized();
+        setCenter(mCenter);
+        setRadius(mRadius);
+        setAspectRatio(1.0f);
+    }
+
+    @Override
+    public float getVerticalTexelOffsetRatio() {
+        return mBlurSize;
+    }
+
+    @Override
+    public float getHorizontalTexelOffsetRatio() {
+        return mBlurSize;
+    }
+
+    /**
+     * A multiplier for the blur size, ranging from 0.0 on up, with a default of 1.0
+     *
+     * @param blurSize from 0.0 on up, default 1.0
+     */
+    public void setBlurSize(float blurSize) {
+        mBlurSize = blurSize;
+        runOnDraw(new Runnable() {
+            @Override
+            public void run() {
+                initTexelOffsets();
+            }
+        });
+    }
+
+    public void setAspectRatio(final float aspectRatio) {
+        mAspectRatio = aspectRatio;
+        setFloat(mAspectRatioLocation, mAspectRatio);
+    }
+
+    public void setCenter(final PointF center) {
+        mCenter = center;
+        setPoint(mCenterLocation, mCenter);
+    }
+
+    public void setRadius(final float radius) {
+        mRadius = radius;
+        setFloat(mRadiusLocation, mRadius);
+    }
+}
diff --git a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageSmoothToonFilter.java b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageSmoothToonFilter.java
index a569ce97..e86abde8 100644
--- a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageSmoothToonFilter.java
+++ b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageSmoothToonFilter.java
@@ -16,14 +16,12 @@
 
 package jp.co.cyberagent.android.gpuimage;
 
-import android.opengl.GLES20;
-
 /**
  *  This uses a similar process as the GPUImageToonFilter, only it precedes the toon effect
  *  with a Gaussian blur to smooth out noise.
  */
 public class GPUImageSmoothToonFilter extends GPUImageFilterGroup {
-    GPUImageGaussianBlurFilter blurFilter;
+    GPUImageGaussianBlurPositionFilter blurFilter;
     GPUImageToonFilter toonFilter;
 
     /**
@@ -31,7 +29,7 @@
      */
     public GPUImageSmoothToonFilter() {
         // First pass: apply a variable Gaussian blur
-        blurFilter = new GPUImageGaussianBlurFilter();
+        blurFilter = new GPUImageGaussianBlurPositionFilter();
         addFilter(blurFilter);
 
         // Second pass: run the Sobel edge detection on this blurred image, along with a posterization effect
diff --git a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageZoomBlurFilter.java b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageZoomBlurFilter.java
new file mode 100644
index 00000000..55fbce90
--- /dev/null
+++ b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageZoomBlurFilter.java
@@ -0,0 +1,90 @@
+/*
+ * Copyright (C) 2012 CyberAgent
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package jp.co.cyberagent.android.gpuimage;
+
+import android.graphics.PointF;
+import android.opengl.GLES20;
+
+/**
+ * Changes the contrast of the image.<br>
+ * <br>
+ * blurSize A multiplier for the blur size, ranging from 0.0 on up, with a default of 1.0
+ * blurCenter The normalized center of the blur. (0.5, 0.5) by default
+ */
+public class GPUImageZoomBlurFilter extends GPUImageFilter {
+    public static final String CONTRAST_FRAGMENT_SHADER = "" +
+            "varying highp vec2 textureCoordinate;\n" +
+            " \n" +
+            " uniform sampler2D inputImageTexture;\n" +
+            " uniform highp vec2 blurCenter;\n" +
+            " uniform highp float blurSize;\n" +
+            " \n" +
+            " void main()\n" +
+            " {\n" +
+            "     highp vec2 samplingOffset = 1.0/100.0 * (blurCenter - textureCoordinate) * blurSize;\n" +
+            "     lowp vec4 fragmentColor = texture2D(inputImageTexture, textureCoordinate) * 0.18;\n" +
+            "     fragmentColor += texture2D(inputImageTexture, textureCoordinate + samplingOffset) * 0.15;\n" +
+            "     fragmentColor += texture2D(inputImageTexture, textureCoordinate + (2.0 * samplingOffset)) *  0.12;\n" +
+            "     fragmentColor += texture2D(inputImageTexture, textureCoordinate + (3.0 * samplingOffset)) * 0.09;\n" +
+            "     fragmentColor += texture2D(inputImageTexture, textureCoordinate + (4.0 * samplingOffset)) * 0.05;\n" +
+            "     fragmentColor += texture2D(inputImageTexture, textureCoordinate - samplingOffset) * 0.15;\n" +
+            "     fragmentColor += texture2D(inputImageTexture, textureCoordinate - (2.0 * samplingOffset)) *  0.12;\n" +
+            "     fragmentColor += texture2D(inputImageTexture, textureCoordinate - (3.0 * samplingOffset)) * 0.09;\n" +
+            "     fragmentColor += texture2D(inputImageTexture, textureCoordinate - (4.0 * samplingOffset)) * 0.05;\n" +
+            "\n" +
+            "     gl_FragColor = fragmentColor;\n" +
+            " }";
+
+    private PointF mCenter;
+    private int mCenterLocation;
+    private float mSize;
+    private int mSizeLocation;
+
+    public GPUImageZoomBlurFilter() {
+        this(new PointF(0.5f, 0.5f), 1.0f);
+    }
+
+    public GPUImageZoomBlurFilter(PointF center, float size) {
+        super(NO_FILTER_VERTEX_SHADER, CONTRAST_FRAGMENT_SHADER);
+        mCenter = center;
+        mSize = size;
+    }
+
+    @Override
+    public void onInit() {
+        super.onInit();
+        mCenterLocation = GLES20.glGetUniformLocation(getProgram(), "blurCenter");
+        mSizeLocation = GLES20.glGetUniformLocation(getProgram(), "blurSize");
+    }
+
+    @Override
+    public void onInitialized() {
+        super.onInitialized();
+        setCenter(mCenter);
+        setSize(mSize);
+    }
+
+    public void setCenter(final PointF center) {
+        mCenter = center;
+        setPoint(mCenterLocation, mCenter);
+    }
+
+    public void setSize(final float size) {
+        mSize = size;
+        setFloat(mSizeLocation, mSize);
+    }
+}
diff --git a/library/src/jp/co/cyberagent/android/gpuimage/filter/IF1977Filter.java b/library/src/jp/co/cyberagent/android/gpuimage/filter/IF1977Filter.java
new file mode 100644
index 00000000..1724a297
--- /dev/null
+++ b/library/src/jp/co/cyberagent/android/gpuimage/filter/IF1977Filter.java
@@ -0,0 +1,41 @@
+package jp.co.cyberagent.android.gpuimage.filter;
+
+import android.content.Context;
+
+import jp.co.cyberagent.android.gpuimage.R;
+
+
+/**
+ * Created by sam on 14-8-9.
+ */
+public class IF1977Filter extends IFImageFilter {
+    private static final String SHADER = "precision lowp float;\n" +
+            " \n" +
+            " varying highp vec2 textureCoordinate;\n" +
+            " \n" +
+            " uniform sampler2D inputImageTexture;\n" +
+            " uniform sampler2D inputImageTexture2;\n" +
+            " \n" +
+            " void main()\n" +
+            " {\n" +
+            "     \n" +
+            "     vec3 texel = texture2D(inputImageTexture, textureCoordinate).rgb;\n" +
+            "     \n" +
+            "     texel = vec3(\n" +
+            "                  texture2D(inputImageTexture2, vec2(texel.r, .16666)).r,\n" +
+            "                  texture2D(inputImageTexture2, vec2(texel.g, .5)).g,\n" +
+            "                  texture2D(inputImageTexture2, vec2(texel.b, .83333)).b);\n" +
+            "     \n" +
+            "     gl_FragColor = vec4(texel, 1.0);\n" +
+            " }\n";
+
+    public IF1977Filter(Context paramContext) {
+        super(paramContext, SHADER);
+        setRes();
+    }
+
+    private void setRes() {
+        addInputTexture(R.drawable.texture_nmap);
+        addInputTexture(R.drawable.texture_nblowout);
+    }
+}
diff --git a/library/src/jp/co/cyberagent/android/gpuimage/filter/IFAmaroFilter.java b/library/src/jp/co/cyberagent/android/gpuimage/filter/IFAmaroFilter.java
new file mode 100644
index 00000000..328b911c
--- /dev/null
+++ b/library/src/jp/co/cyberagent/android/gpuimage/filter/IFAmaroFilter.java
@@ -0,0 +1,40 @@
+package jp.co.cyberagent.android.gpuimage.filter;
+
+import android.content.Context;
+
+import jp.co.cyberagent.android.gpuimage.R;
+
+/**
+ * Created by sam on 14-8-9.
+ */
+public class IFAmaroFilter extends IFImageFilter {
+    private static final String SHADER = "\n precision lowp float;\n\n " +
+            "varying highp vec2 textureCoordinate;\n\n " +
+            "uniform sampler2D inputImageTexture;\n " +
+            "uniform sampler2D inputImageTexture2;\n " +
+            "uniform sampler2D inputImageTexture3;\n " +
+            "uniform sampler2D inputImageTexture4;\n\n " +
+            "void main()\n  " +
+            "{\n\n  " +
+            "vec4 texel = texture2D(inputImageTexture, textureCoordinate);\n   " +
+            "vec3 bbTexel = texture2D(inputImageTexture2, textureCoordinate).rgb;\n\n   " +
+            "texel.r = texture2D(inputImageTexture3, vec2(bbTexel.r, texel.r)).r;\n   " +
+            "texel.g = texture2D(inputImageTexture3, vec2(bbTexel.g, texel.g)).g;\n   " +
+            "texel.b = texture2D(inputImageTexture3, vec2(bbTexel.b, texel.b)).b;\n\n   " +
+            "vec4 mapped;\n   mapped.r = texture2D(inputImageTexture4, vec2(texel.r, .16666)).r;\n   " +
+            "mapped.g = texture2D(inputImageTexture4, vec2(texel.g, .5)).g;\n   " +
+            "mapped.b = texture2D(inputImageTexture4, vec2(texel.b, .83333)).b;\n   " +
+            "mapped.a = 1.0;\n\n   " +
+            "gl_FragColor = mapped;\n }";
+
+    public IFAmaroFilter(Context context) {
+        super(context, SHADER);
+        setRes();
+    }
+
+    private void setRes() {
+        addInputTexture(R.drawable.texture_blackboard);
+        addInputTexture(R.drawable.texture_overlay_map);
+        addInputTexture(R.drawable.texture_amaro_map);
+    }
+}
diff --git a/library/src/jp/co/cyberagent/android/gpuimage/filter/IFBrannanFilter.java b/library/src/jp/co/cyberagent/android/gpuimage/filter/IFBrannanFilter.java
new file mode 100644
index 00000000..3e71ade4
--- /dev/null
+++ b/library/src/jp/co/cyberagent/android/gpuimage/filter/IFBrannanFilter.java
@@ -0,0 +1,99 @@
+package jp.co.cyberagent.android.gpuimage.filter;
+
+import android.content.Context;
+
+import jp.co.cyberagent.android.gpuimage.R;
+
+/**
+ * Created by sam on 14-8-9.
+ */
+public class IFBrannanFilter extends IFImageFilter {
+    private static final String SHADER = "\n" +
+            " precision lowp float;\n" +
+            " \n" +
+            " varying highp vec2 textureCoordinate;\n" +
+            " \n" +
+            " uniform sampler2D inputImageTexture;\n" +
+            " uniform sampler2D inputImageTexture2;  //process\n" +
+            " uniform sampler2D inputImageTexture3;  //blowout\n" +
+            " uniform sampler2D inputImageTexture4;  //contrast\n" +
+            " uniform sampler2D inputImageTexture5;  //luma\n" +
+            " uniform sampler2D inputImageTexture6;  //screen\n" +
+            " \n" +
+            " mat3 saturateMatrix = mat3(\n" +
+            "                            1.105150,\n" +
+            "                            -0.044850,\n" +
+            "                            -0.046000,\n" +
+            "                            -0.088050,\n" +
+            "                            1.061950,\n" +
+            "                            -0.089200,\n" +
+            "                            -0.017100,\n" +
+            "                            -0.017100,\n" +
+            "                            1.132900);\n" +
+            " \n" +
+            " vec3 luma = vec3(.3, .59, .11);\n" +
+            " \n" +
+            " void main()\n" +
+            " {\n" +
+            "     \n" +
+            "     vec3 texel = texture2D(inputImageTexture, textureCoordinate).rgb;\n" +
+            "     \n" +
+            "     vec2 lookup;\n" +
+            "     lookup.y = 0.5;\n" +
+            "     lookup.x = texel.r;\n" +
+            "     texel.r = texture2D(inputImageTexture2, lookup).r;\n" +
+            "     lookup.x = texel.g;\n" +
+            "     texel.g = texture2D(inputImageTexture2, lookup).g;\n" +
+            "     lookup.x = texel.b;\n" +
+            "     texel.b = texture2D(inputImageTexture2, lookup).b;\n" +
+            "     \n" +
+            "     texel = saturateMatrix * texel;\n" +
+            "     \n" +
+            "     \n" +
+            "     vec2 tc = (2.0 * textureCoordinate) - 1.0;\n" +
+            "     float d = dot(tc, tc);\n" +
+            "     vec3 sampled;\n" +
+            "     lookup.y = 0.5;\n" +
+            "     lookup.x = texel.r;\n" +
+            "     sampled.r = texture2D(inputImageTexture3, lookup).r;\n" +
+            "     lookup.x = texel.g;\n" +
+            "     sampled.g = texture2D(inputImageTexture3, lookup).g;\n" +
+            "     lookup.x = texel.b;\n" +
+            "     sampled.b = texture2D(inputImageTexture3, lookup).b;\n" +
+            "     float value = smoothstep(0.0, 1.0, d);\n" +
+            "     texel = mix(sampled, texel, value);\n" +
+            "     \n" +
+            "     lookup.x = texel.r;\n" +
+            "     texel.r = texture2D(inputImageTexture4, lookup).r;\n" +
+            "     lookup.x = texel.g;\n" +
+            "     texel.g = texture2D(inputImageTexture4, lookup).g;\n" +
+            "     lookup.x = texel.b;\n" +
+            "     texel.b = texture2D(inputImageTexture4, lookup).b;\n" +
+            "     \n" +
+            "     \n" +
+            "     lookup.x = dot(texel, luma);\n" +
+            "     texel = mix(texture2D(inputImageTexture5, lookup).rgb, texel, .5);\n" +
+            "\n" +
+            "     lookup.x = texel.r;\n" +
+            "     texel.r = texture2D(inputImageTexture6, lookup).r;\n" +
+            "     lookup.x = texel.g;\n" +
+            "     texel.g = texture2D(inputImageTexture6, lookup).g;\n" +
+            "     lookup.x = texel.b;\n" +
+            "     texel.b = texture2D(inputImageTexture6, lookup).b;\n" +
+            "     \n" +
+            "     gl_FragColor = vec4(texel, 1.0);\n" +
+            " }\n";
+
+    public IFBrannanFilter(Context context) {
+        super(context, SHADER);
+        setRes();
+    }
+
+    private void setRes() {
+        addInputTexture(R.drawable.texture_brannan_process);
+        addInputTexture(R.drawable.texture_brannan_blowout);
+        addInputTexture(R.drawable.texture_brannan_contrast);
+        addInputTexture(R.drawable.texture_brannan_luma);
+        addInputTexture(R.drawable.texture_brannan_screen);
+    }
+}
diff --git a/library/src/jp/co/cyberagent/android/gpuimage/filter/IFEarlybirdFilter.java b/library/src/jp/co/cyberagent/android/gpuimage/filter/IFEarlybirdFilter.java
new file mode 100644
index 00000000..a05eb93c
--- /dev/null
+++ b/library/src/jp/co/cyberagent/android/gpuimage/filter/IFEarlybirdFilter.java
@@ -0,0 +1,131 @@
+package jp.co.cyberagent.android.gpuimage.filter;
+
+import android.content.Context;
+
+import jp.co.cyberagent.android.gpuimage.R;
+
+/**
+ * Created by sam on 14-8-9.
+ */
+public class IFEarlybirdFilter extends IFImageFilter {
+    private static final String SHADER = "\n" +
+            " precision lowp float;\n" +
+            " \n" +
+            " varying highp vec2 textureCoordinate;\n" +
+            " \n" +
+            " uniform sampler2D inputImageTexture;\n" +
+            " uniform sampler2D inputImageTexture2; //earlyBirdCurves\n" +
+            " uniform sampler2D inputImageTexture3; //earlyBirdOverlay\n" +
+            " uniform sampler2D inputImageTexture4; //vig\n" +
+            " uniform sampler2D inputImageTexture5; //earlyBirdBlowout\n" +
+            " uniform sampler2D inputImageTexture6; //earlyBirdMap\n" +
+            " \n" +
+            " const mat3 saturate = mat3(\n" +
+            "                            1.210300,\n" +
+            "                            -0.089700,\n" +
+            "                            -0.091000,\n" +
+            "                            -0.176100,\n" +
+            "                            1.123900,\n" +
+            "                            -0.177400,\n" +
+            "                            -0.034200,\n" +
+            "                            -0.034200,\n" +
+            "                            1.265800);\n" +
+            " const vec3 rgbPrime = vec3(0.25098, 0.14640522, 0.0); \n" +
+            " const vec3 desaturate = vec3(.3, .59, .11);\n" +
+            " \n" +
+            " void main()\n" +
+            " {\n" +
+            "     \n" +
+            "     vec3 texel = texture2D(inputImageTexture, textureCoordinate).rgb;\n" +
+            "     \n" +
+            "     \n" +
+            "     vec2 lookup;    \n" +
+            "     lookup.y = 0.5;\n" +
+            "     \n" +
+            "     lookup.x = texel.r;\n" +
+            "     texel.r = texture2D(inputImageTexture2, lookup).r;\n" +
+            "     \n" +
+            "     lookup.x = texel.g;\n" +
+            "     texel.g = texture2D(inputImageTexture2, lookup).g;\n" +
+            "     \n" +
+            "     lookup.x = texel.b;\n" +
+            "     texel.b = texture2D(inputImageTexture2, lookup).b;\n" +
+            "     \n" +
+            "     float desaturatedColor;\n" +
+            "     vec3 result;\n" +
+            "     desaturatedColor = dot(desaturate, texel);\n" +
+            "     \n" +
+            "     \n" +
+            "     lookup.x = desaturatedColor;\n" +
+            "     result.r = texture2D(inputImageTexture3, lookup).r;\n" +
+            "     lookup.x = desaturatedColor;\n" +
+            "     result.g = texture2D(inputImageTexture3, lookup).g;\n" +
+            "     lookup.x = desaturatedColor;\n" +
+            "     result.b = texture2D(inputImageTexture3, lookup).b;\n" +
+            "     \n" +
+            "     texel = saturate * mix(texel, result, .5);\n" +
+            "     \n" +
+            "     vec2 tc = (2.0 * textureCoordinate) - 1.0;\n" +
+            "     float d = dot(tc, tc);\n" +
+            "     \n" +
+            "     vec3 sampled;\n" +
+            "     lookup.y = .5;\n" +
+            "     \n" +
+            "     /*\n" +
+            "      lookup.x = texel.r;\n" +
+            "      sampled.r = texture2D(inputImageTexture4, lookup).r;\n" +
+            "      \n" +
+            "      lookup.x = texel.g;\n" +
+            "      sampled.g = texture2D(inputImageTexture4, lookup).g;\n" +
+            "      \n" +
+            "      lookup.x = texel.b;\n" +
+            "      sampled.b = texture2D(inputImageTexture4, lookup).b;\n" +
+            "      \n" +
+            "      float value = smoothstep(0.0, 1.25, pow(d, 1.35)/1.65);\n" +
+            "      texel = mix(texel, sampled, value);\n" +
+            "      */\n" +
+            "     \n" +
+            "     //---\n" +
+            "     \n" +
+            "     lookup = vec2(d, texel.r);\n" +
+            "     texel.r = texture2D(inputImageTexture4, lookup).r;\n" +
+            "     lookup.y = texel.g;\n" +
+            "     texel.g = texture2D(inputImageTexture4, lookup).g;\n" +
+            "     lookup.y = texel.b;\n" +
+            "     texel.b\t= texture2D(inputImageTexture4, lookup).b;\n" +
+            "     float value = smoothstep(0.0, 1.25, pow(d, 1.35)/1.65);\n" +
+            "     \n" +
+            "     //---\n" +
+            "     \n" +
+            "     lookup.x = texel.r;\n" +
+            "     sampled.r = texture2D(inputImageTexture5, lookup).r;\n" +
+            "     lookup.x = texel.g;\n" +
+            "     sampled.g = texture2D(inputImageTexture5, lookup).g;\n" +
+            "     lookup.x = texel.b;\n" +
+            "     sampled.b = texture2D(inputImageTexture5, lookup).b;\n" +
+            "     texel = mix(sampled, texel, value);\n" +
+            "     \n" +
+            "     \n" +
+            "     lookup.x = texel.r;\n" +
+            "     texel.r = texture2D(inputImageTexture6, lookup).r;\n" +
+            "     lookup.x = texel.g;\n" +
+            "     texel.g = texture2D(inputImageTexture6, lookup).g;\n" +
+            "     lookup.x = texel.b;\n" +
+            "     texel.b = texture2D(inputImageTexture6, lookup).b;\n" +
+            "     \n" +
+            "     gl_FragColor = vec4(texel, 1.0);\n" +
+            " }\n";
+
+    public IFEarlybirdFilter(Context paramContext) {
+        super(paramContext, SHADER);
+        setRes();
+    }
+
+    private void setRes() {
+        addInputTexture(R.drawable.texture_earlybird_curves);
+        addInputTexture(R.drawable.texture_earlybird_overlay_map);
+        addInputTexture(R.drawable.texture_vignette_map);
+        addInputTexture(R.drawable.texture_earlybird_blowout);
+        addInputTexture(R.drawable.texture_earlybird_map);
+    }
+}
diff --git a/library/src/jp/co/cyberagent/android/gpuimage/filter/IFHefeFilter.java b/library/src/jp/co/cyberagent/android/gpuimage/filter/IFHefeFilter.java
new file mode 100644
index 00000000..caff1b13
--- /dev/null
+++ b/library/src/jp/co/cyberagent/android/gpuimage/filter/IFHefeFilter.java
@@ -0,0 +1,63 @@
+package jp.co.cyberagent.android.gpuimage.filter;
+
+import android.content.Context;
+
+import jp.co.cyberagent.android.gpuimage.R;
+
+/**
+ * Created by sam on 14-8-9.
+ */
+public class IFHefeFilter extends IFImageFilter {
+    private static final String SHADER = "precision lowp float;\n" +
+            " \n" +
+            " varying highp vec2 textureCoordinate;\n" +
+            " \n" +
+            " uniform sampler2D inputImageTexture;\n" +
+            " uniform sampler2D inputImageTexture2;  //edgeBurn\n" +
+            " uniform sampler2D inputImageTexture3;  //hefeMap\n" +
+            " uniform sampler2D inputImageTexture4;  //hefeGradientMap\n" +
+            " uniform sampler2D inputImageTexture5;  //hefeSoftLight\n" +
+            " uniform sampler2D inputImageTexture6;  //hefeMetal\n" +
+            " \n" +
+            " void main()\n" +
+            "{\t\n" +
+            "\tvec3 texel = texture2D(inputImageTexture, textureCoordinate).rgb;\n" +
+            "\tvec3 edge = texture2D(inputImageTexture2, textureCoordinate).rgb;\n" +
+            "\ttexel = texel * edge;\n" +
+            "\t\n" +
+            "\ttexel = vec3(\n" +
+            "                 texture2D(inputImageTexture3, vec2(texel.r, .16666)).r,\n" +
+            "                 texture2D(inputImageTexture3, vec2(texel.g, .5)).g,\n" +
+            "                 texture2D(inputImageTexture3, vec2(texel.b, .83333)).b);\n" +
+            "\t\n" +
+            "\tvec3 luma = vec3(.30, .59, .11);\n" +
+            "\tvec3 gradSample = texture2D(inputImageTexture4, vec2(dot(luma, texel), .5)).rgb;\n" +
+            "\tvec3 final = vec3(\n" +
+            "                      texture2D(inputImageTexture5, vec2(gradSample.r, texel.r)).r,\n" +
+            "                      texture2D(inputImageTexture5, vec2(gradSample.g, texel.g)).g,\n" +
+            "                      texture2D(inputImageTexture5, vec2(gradSample.b, texel.b)).b\n" +
+            "                      );\n" +
+            "    \n" +
+            "    vec3 metal = texture2D(inputImageTexture6, textureCoordinate).rgb;\n" +
+            "    vec3 metaled = vec3(\n" +
+            "                        texture2D(inputImageTexture5, vec2(metal.r, texel.r)).r,\n" +
+            "                        texture2D(inputImageTexture5, vec2(metal.g, texel.g)).g,\n" +
+            "                        texture2D(inputImageTexture5, vec2(metal.b, texel.b)).b\n" +
+            "                        );\n" +
+            "\t\n" +
+            "\tgl_FragColor = vec4(metaled, 1.0);\n" +
+            "}\n";
+
+    public IFHefeFilter(Context paramContext) {
+        super(paramContext, SHADER);
+        setRes();
+    }
+
+    private void setRes() {
+        addInputTexture(R.drawable.texture_edge_burn);
+        addInputTexture(R.drawable.texture_hefe_map);
+        addInputTexture(R.drawable.texture_hefe_gradient_map);
+        addInputTexture(R.drawable.texture_hefe_soft_light);
+        addInputTexture(R.drawable.texture_hefe_metal);
+    }
+}
diff --git a/library/src/jp/co/cyberagent/android/gpuimage/filter/IFHudsonFilter.java b/library/src/jp/co/cyberagent/android/gpuimage/filter/IFHudsonFilter.java
new file mode 100644
index 00000000..dddaaf62
--- /dev/null
+++ b/library/src/jp/co/cyberagent/android/gpuimage/filter/IFHudsonFilter.java
@@ -0,0 +1,49 @@
+package jp.co.cyberagent.android.gpuimage.filter;
+
+import android.content.Context;
+
+import jp.co.cyberagent.android.gpuimage.R;
+
+/**
+ * Created by sam on 14-8-9.
+ */
+public class IFHudsonFilter extends IFImageFilter {
+    private static final String SHADER = "precision lowp float;\n" +
+            " \n" +
+            " varying highp vec2 textureCoordinate;\n" +
+            " \n" +
+            " uniform sampler2D inputImageTexture;\n" +
+            " uniform sampler2D inputImageTexture2; //blowout;\n" +
+            " uniform sampler2D inputImageTexture3; //overlay;\n" +
+            " uniform sampler2D inputImageTexture4; //map\n" +
+            " \n" +
+            " void main()\n" +
+            " {\n" +
+            "     \n" +
+            "     vec4 texel = texture2D(inputImageTexture, textureCoordinate);\n" +
+            "     \n" +
+            "     vec3 bbTexel = texture2D(inputImageTexture2, textureCoordinate).rgb;\n" +
+            "     \n" +
+            "     texel.r = texture2D(inputImageTexture3, vec2(bbTexel.r, texel.r)).r;\n" +
+            "     texel.g = texture2D(inputImageTexture3, vec2(bbTexel.g, texel.g)).g;\n" +
+            "     texel.b = texture2D(inputImageTexture3, vec2(bbTexel.b, texel.b)).b;\n" +
+            "     \n" +
+            "     vec4 mapped;\n" +
+            "     mapped.r = texture2D(inputImageTexture4, vec2(texel.r, .16666)).r;\n" +
+            "     mapped.g = texture2D(inputImageTexture4, vec2(texel.g, .5)).g;\n" +
+            "     mapped.b = texture2D(inputImageTexture4, vec2(texel.b, .83333)).b;\n" +
+            "     mapped.a = 1.0;\n" +
+            "     gl_FragColor = mapped;\n" +
+            " }\n";
+
+    public IFHudsonFilter(Context paramContext) {
+        super(paramContext, SHADER);
+        setRes();
+    }
+
+    private void setRes() {
+        addInputTexture(R.drawable.texture_hudson_background);
+        addInputTexture(R.drawable.texture_overlay_map);
+        addInputTexture(R.drawable.texture_hudson_map);
+    }
+}
diff --git a/library/src/jp/co/cyberagent/android/gpuimage/filter/IFImageFilter.java b/library/src/jp/co/cyberagent/android/gpuimage/filter/IFImageFilter.java
new file mode 100644
index 00000000..028ae716
--- /dev/null
+++ b/library/src/jp/co/cyberagent/android/gpuimage/filter/IFImageFilter.java
@@ -0,0 +1,186 @@
+package jp.co.cyberagent.android.gpuimage.filter;
+
+import android.content.Context;
+import android.graphics.Bitmap;
+import android.graphics.BitmapFactory;
+import android.opengl.GLES20;
+import jp.co.cyberagent.android.gpuimage.GPUImageFilter;
+import jp.co.cyberagent.android.gpuimage.OpenGlUtils;
+
+import java.util.ArrayList;
+import java.util.List;
+
+/**
+ * Created by sam on 14-8-9.
+ */
+public class IFImageFilter extends GPUImageFilter {
+    private int filterInputTextureUniform2;
+    private int filterInputTextureUniform3;
+    private int filterInputTextureUniform4;
+    private int filterInputTextureUniform5;
+    private int filterInputTextureUniform6;
+    public int filterSourceTexture2 = OpenGlUtils.NO_TEXTURE;
+    public int filterSourceTexture3 = OpenGlUtils.NO_TEXTURE;
+    public int filterSourceTexture4 = OpenGlUtils.NO_TEXTURE;
+    public int filterSourceTexture5 = OpenGlUtils.NO_TEXTURE;
+    public int filterSourceTexture6 = OpenGlUtils.NO_TEXTURE;
+    private List<Integer> mResIds;
+    private Context mContext;
+
+
+    public IFImageFilter(Context context, String fragmentShaderString) {
+        super(NO_FILTER_VERTEX_SHADER, fragmentShaderString);
+        mContext = context;
+    }
+
+    public void onInit() {
+        super.onInit();
+        filterInputTextureUniform2 = GLES20.glGetUniformLocation(getProgram(), "inputImageTexture2");
+        filterInputTextureUniform3 = GLES20.glGetUniformLocation(getProgram(), "inputImageTexture3");
+        filterInputTextureUniform4 = GLES20.glGetUniformLocation(getProgram(), "inputImageTexture4");
+        filterInputTextureUniform5 = GLES20.glGetUniformLocation(getProgram(), "inputImageTexture5");
+        filterInputTextureUniform6 = GLES20.glGetUniformLocation(getProgram(), "inputImageTexture6");
+
+        initInputTexture();
+    }
+
+    public void onDestroy() {
+        super.onDestroy();
+
+        if (filterSourceTexture2 != OpenGlUtils.NO_TEXTURE) {
+            int[] arrayOfInt1 = new int[1];
+            arrayOfInt1[0] = this.filterSourceTexture2;
+            GLES20.glDeleteTextures(1, arrayOfInt1, 0);
+            this.filterSourceTexture2 = OpenGlUtils.NO_TEXTURE;
+        }
+
+        if (filterSourceTexture3 != OpenGlUtils.NO_TEXTURE) {
+            int[] arrayOfInt2 = new int[1];
+            arrayOfInt2[0] = this.filterSourceTexture3;
+            GLES20.glDeleteTextures(1, arrayOfInt2, 0);
+            this.filterSourceTexture3 = OpenGlUtils.NO_TEXTURE;
+        }
+
+        if (filterSourceTexture4 != OpenGlUtils.NO_TEXTURE) {
+            int[] arrayOfInt3 = new int[1];
+            arrayOfInt3[0] = this.filterSourceTexture4;
+            GLES20.glDeleteTextures(1, arrayOfInt3, 0);
+            this.filterSourceTexture4 = OpenGlUtils.NO_TEXTURE;
+        }
+
+        if (filterSourceTexture5 != OpenGlUtils.NO_TEXTURE) {
+            int[] arrayOfInt4 = new int[1];
+            arrayOfInt4[0] = this.filterSourceTexture5;
+            GLES20.glDeleteTextures(1, arrayOfInt4, 0);
+            this.filterSourceTexture5 = OpenGlUtils.NO_TEXTURE;
+        }
+
+        if (filterSourceTexture6 != OpenGlUtils.NO_TEXTURE) {
+            int[] arrayOfInt5 = new int[1];
+            arrayOfInt5[0] = this.filterSourceTexture6;
+            GLES20.glDeleteTextures(1, arrayOfInt5, 0);
+            this.filterSourceTexture6 = OpenGlUtils.NO_TEXTURE;
+        }
+
+    }
+
+    @Override
+    protected void onDrawArraysPre() {
+        super.onDrawArraysPre();
+
+        if (filterSourceTexture2 != OpenGlUtils.NO_TEXTURE) {
+            GLES20.glActiveTexture(GLES20.GL_TEXTURE3);
+            GLES20.glBindTexture(GLES20.GL_TEXTURE_2D, filterSourceTexture2);
+            GLES20.glUniform1i(filterInputTextureUniform2, 3);
+        }
+
+        if (filterSourceTexture3 != OpenGlUtils.NO_TEXTURE) {
+            GLES20.glActiveTexture(GLES20.GL_TEXTURE4);
+            GLES20.glBindTexture(GLES20.GL_TEXTURE_2D, filterSourceTexture3);
+            GLES20.glUniform1i(filterInputTextureUniform3, 4);
+        }
+
+        if (filterSourceTexture4 != OpenGlUtils.NO_TEXTURE) {
+            GLES20.glActiveTexture(GLES20.GL_TEXTURE5);
+            GLES20.glBindTexture(GLES20.GL_TEXTURE_2D, filterSourceTexture4);
+            GLES20.glUniform1i(filterInputTextureUniform4, 5);
+        }
+
+        if (filterSourceTexture5 != OpenGlUtils.NO_TEXTURE) {
+            GLES20.glActiveTexture(GLES20.GL_TEXTURE6);
+            GLES20.glBindTexture(GLES20.GL_TEXTURE_2D, filterSourceTexture5);
+            GLES20.glUniform1i(filterInputTextureUniform5, 6);
+        }
+
+        if (filterSourceTexture6 != OpenGlUtils.NO_TEXTURE) {
+            GLES20.glActiveTexture(GLES20.GL_TEXTURE7);
+            GLES20.glBindTexture(GLES20.GL_TEXTURE_2D, filterSourceTexture6);
+            GLES20.glUniform1i(filterInputTextureUniform6, 7);
+        }
+
+    }
+
+    public void addInputTexture(int resId) {
+        if (mResIds == null) {
+            mResIds = new ArrayList<Integer>();
+        }
+        mResIds.add(resId);
+    }
+
+    public void initInputTexture() {
+        if (mResIds == null) {
+            return;
+        }
+        if (mResIds.size() > 0) {
+            runOnDraw(new Runnable() {
+                @Override
+                public void run() {
+                    Bitmap b = BitmapFactory.decodeResource(mContext.getResources(), mResIds.get(0));
+                    filterSourceTexture2 = OpenGlUtils.loadTexture(b, OpenGlUtils.NO_TEXTURE, true);
+                }
+            });
+        }
+
+        if (mResIds.size() > 1) {
+            runOnDraw(new Runnable() {
+                @Override
+                public void run() {
+                    Bitmap b = BitmapFactory.decodeResource(mContext.getResources(), mResIds.get(1));
+                    filterSourceTexture3 = OpenGlUtils.loadTexture(b, OpenGlUtils.NO_TEXTURE, true);
+                }
+            });
+        }
+
+        if (mResIds.size() > 2) {
+            runOnDraw(new Runnable() {
+                @Override
+                public void run() {
+                    Bitmap b = BitmapFactory.decodeResource(mContext.getResources(), mResIds.get(2));
+                    filterSourceTexture4 = OpenGlUtils.loadTexture(b, OpenGlUtils.NO_TEXTURE, true);
+                }
+            });
+        }
+
+        if (mResIds.size() > 3) {
+            runOnDraw(new Runnable() {
+                @Override
+                public void run() {
+                    Bitmap b = BitmapFactory.decodeResource(mContext.getResources(), mResIds.get(3));
+                    filterSourceTexture5 = OpenGlUtils.loadTexture(b, OpenGlUtils.NO_TEXTURE, true);
+                }
+            });
+        }
+
+        if (mResIds.size() > 4) {
+            runOnDraw(new Runnable() {
+                @Override
+                public void run() {
+                    Bitmap b = BitmapFactory.decodeResource(mContext.getResources(), mResIds.get(4));
+                    filterSourceTexture6 = OpenGlUtils.loadTexture(b, OpenGlUtils.NO_TEXTURE, true);
+                }
+            });
+        }
+    }
+
+
+}
diff --git a/library/src/jp/co/cyberagent/android/gpuimage/filter/IFInkwellFilter.java b/library/src/jp/co/cyberagent/android/gpuimage/filter/IFInkwellFilter.java
new file mode 100644
index 00000000..e2cf1482
--- /dev/null
+++ b/library/src/jp/co/cyberagent/android/gpuimage/filter/IFInkwellFilter.java
@@ -0,0 +1,34 @@
+package jp.co.cyberagent.android.gpuimage.filter;
+
+import android.content.Context;
+
+import jp.co.cyberagent.android.gpuimage.R;
+
+/**
+ * Created by sam on 14-8-9.
+ */
+public class IFInkwellFilter extends IFImageFilter {
+    private static final String SHADER = "precision lowp float;\n" +
+            " \n" +
+            " varying highp vec2 textureCoordinate;\n" +
+            " \n" +
+            " uniform sampler2D inputImageTexture;\n" +
+            " uniform sampler2D inputImageTexture2;\n" +
+            " \n" +
+            " void main()\n" +
+            " {\n" +
+            "     vec3 texel = texture2D(inputImageTexture, textureCoordinate).rgb;\n" +
+            "     texel = vec3(dot(vec3(0.3, 0.6, 0.1), texel));\n" +
+            "     texel = vec3(texture2D(inputImageTexture2, vec2(texel.r, .16666)).r);\n" +
+            "     gl_FragColor = vec4(texel, 1.0);\n" +
+            " }\n";
+
+    public IFInkwellFilter(Context paramContext) {
+        super(paramContext, SHADER);
+        setRes();
+    }
+
+    private void setRes() {
+        addInputTexture(R.drawable.texture_inkwell_map);
+    }
+}
diff --git a/library/src/jp/co/cyberagent/android/gpuimage/filter/IFLomoFilter.java b/library/src/jp/co/cyberagent/android/gpuimage/filter/IFLomoFilter.java
new file mode 100644
index 00000000..c06052b8
--- /dev/null
+++ b/library/src/jp/co/cyberagent/android/gpuimage/filter/IFLomoFilter.java
@@ -0,0 +1,54 @@
+package jp.co.cyberagent.android.gpuimage.filter;
+
+import android.content.Context;
+
+import jp.co.cyberagent.android.gpuimage.R;
+
+/**
+ * Created by sam on 14-8-9.
+ */
+public class IFLomoFilter extends IFImageFilter {
+    private static final String SHADER = "precision lowp float;\n" +
+            " \n" +
+            " varying highp vec2 textureCoordinate;\n" +
+            " \n" +
+            " uniform sampler2D inputImageTexture;\n" +
+            " uniform sampler2D inputImageTexture2;\n" +
+            " uniform sampler2D inputImageTexture3;\n" +
+            " \n" +
+            " void main()\n" +
+            " {\n" +
+            "     \n" +
+            "     vec3 texel = texture2D(inputImageTexture, textureCoordinate).rgb;\n" +
+            "     \n" +
+            "     vec2 red = vec2(texel.r, 0.16666);\n" +
+            "     vec2 green = vec2(texel.g, 0.5);\n" +
+            "     vec2 blue = vec2(texel.b, 0.83333);\n" +
+            "     \n" +
+            "     texel.rgb = vec3(\n" +
+            "                      texture2D(inputImageTexture2, red).r,\n" +
+            "                      texture2D(inputImageTexture2, green).g,\n" +
+            "                      texture2D(inputImageTexture2, blue).b);\n" +
+            "     \n" +
+            "     vec2 tc = (2.0 * textureCoordinate) - 1.0;\n" +
+            "     float d = dot(tc, tc);\n" +
+            "     vec2 lookup = vec2(d, texel.r);\n" +
+            "     texel.r = texture2D(inputImageTexture3, lookup).r;\n" +
+            "     lookup.y = texel.g;\n" +
+            "     texel.g = texture2D(inputImageTexture3, lookup).g;\n" +
+            "     lookup.y = texel.b;\n" +
+            "     texel.b\t= texture2D(inputImageTexture3, lookup).b;\n" +
+            "     \n" +
+            "     gl_FragColor = vec4(texel,1.0);\n" +
+            " }\n";
+
+    public IFLomoFilter(Context paramContext) {
+        super(paramContext, SHADER);
+        setRes();
+    }
+
+    private void setRes() {
+        addInputTexture(R.drawable.texture_lomo_map);
+        addInputTexture(R.drawable.texture_vignette_map);
+    }
+}
diff --git a/library/src/jp/co/cyberagent/android/gpuimage/filter/IFLordKelvinFilter.java b/library/src/jp/co/cyberagent/android/gpuimage/filter/IFLordKelvinFilter.java
new file mode 100644
index 00000000..820aa9b1
--- /dev/null
+++ b/library/src/jp/co/cyberagent/android/gpuimage/filter/IFLordKelvinFilter.java
@@ -0,0 +1,45 @@
+package jp.co.cyberagent.android.gpuimage.filter;
+
+import android.content.Context;
+
+import jp.co.cyberagent.android.gpuimage.R;
+
+/**
+ * Created by sam on 14-8-9.
+ */
+public class IFLordKelvinFilter extends IFImageFilter {
+    private static final String SHADER = "precision lowp float;\n" +
+            " \n" +
+            " varying highp vec2 textureCoordinate;\n" +
+            " \n" +
+            " uniform sampler2D inputImageTexture;\n" +
+            " uniform sampler2D inputImageTexture2;\n" +
+            " \n" +
+            " void main()\n" +
+            " {\n" +
+            "     vec3 texel = texture2D(inputImageTexture, textureCoordinate).rgb;\n" +
+            "     \n" +
+            "     vec2 lookup;\n" +
+            "     lookup.y = .5;\n" +
+            "     \n" +
+            "     lookup.x = texel.r;\n" +
+            "     texel.r = texture2D(inputImageTexture2, lookup).r;\n" +
+            "     \n" +
+            "     lookup.x = texel.g;\n" +
+            "     texel.g = texture2D(inputImageTexture2, lookup).g;\n" +
+            "     \n" +
+            "     lookup.x = texel.b;\n" +
+            "     texel.b = texture2D(inputImageTexture2, lookup).b;\n" +
+            "     \n" +
+            "     gl_FragColor = vec4(texel, 1.0);\n" +
+            " }\n";
+
+    public IFLordKelvinFilter(Context paramContext) {
+        super(paramContext, SHADER);
+        setRes();
+    }
+
+    private void setRes() {
+        addInputTexture(R.drawable.texture_kelvin_map);
+    }
+}
diff --git a/library/src/jp/co/cyberagent/android/gpuimage/filter/IFNashvilleFilter.java b/library/src/jp/co/cyberagent/android/gpuimage/filter/IFNashvilleFilter.java
new file mode 100644
index 00000000..eaa7c57e
--- /dev/null
+++ b/library/src/jp/co/cyberagent/android/gpuimage/filter/IFNashvilleFilter.java
@@ -0,0 +1,36 @@
+package jp.co.cyberagent.android.gpuimage.filter;
+
+import android.content.Context;
+
+import jp.co.cyberagent.android.gpuimage.R;
+
+/**
+ * Created by sam on 14-8-9.
+ */
+public class IFNashvilleFilter extends IFImageFilter {
+    private static final String SHADER = "precision lowp float;\n" +
+            " \n" +
+            " varying highp vec2 textureCoordinate;\n" +
+            " \n" +
+            " uniform sampler2D inputImageTexture;\n" +
+            " uniform sampler2D inputImageTexture2;\n" +
+            " \n" +
+            " void main()\n" +
+            " {\n" +
+            "     vec3 texel = texture2D(inputImageTexture, textureCoordinate).rgb;\n" +
+            "     texel = vec3(\n" +
+            "                  texture2D(inputImageTexture2, vec2(texel.r, .16666)).r,\n" +
+            "                  texture2D(inputImageTexture2, vec2(texel.g, .5)).g,\n" +
+            "                  texture2D(inputImageTexture2, vec2(texel.b, .83333)).b);\n" +
+            "     gl_FragColor = vec4(texel, 1.0);\n" +
+            " }\n";
+
+    public IFNashvilleFilter(Context paramContext) {
+        super(paramContext, SHADER);
+        setRes();
+    }
+
+    private void setRes() {
+        addInputTexture(R.drawable.texture_nashville_map);
+    }
+}
diff --git a/library/src/jp/co/cyberagent/android/gpuimage/filter/IFRiseFilter.java b/library/src/jp/co/cyberagent/android/gpuimage/filter/IFRiseFilter.java
new file mode 100644
index 00000000..609eb4f6
--- /dev/null
+++ b/library/src/jp/co/cyberagent/android/gpuimage/filter/IFRiseFilter.java
@@ -0,0 +1,40 @@
+package jp.co.cyberagent.android.gpuimage.filter;
+
+import android.content.Context;
+
+import jp.co.cyberagent.android.gpuimage.R;
+
+/**
+ * Created by sam on 14-8-9.
+ */
+public class IFRiseFilter extends IFImageFilter {
+    private static final String SHADER = "\n precision lowp float;\n\n " +
+            "varying highp vec2 textureCoordinate;\n\n " +
+            "uniform sampler2D inputImageTexture;\n " +
+            "uniform sampler2D inputImageTexture2;\n " +
+            "uniform sampler2D inputImageTexture3;\n " +
+            "uniform sampler2D inputImageTexture4;\n\n " +
+            "void main()\n  " +
+            "{\n\n  " +
+            "vec4 texel = texture2D(inputImageTexture, textureCoordinate);\n   " +
+            "vec3 bbTexel = texture2D(inputImageTexture2, textureCoordinate).rgb;\n\n   " +
+            "texel.r = texture2D(inputImageTexture3, vec2(bbTexel.r, texel.r)).r;\n   " +
+            "texel.g = texture2D(inputImageTexture3, vec2(bbTexel.g, texel.g)).g;\n   " +
+            "texel.b = texture2D(inputImageTexture3, vec2(bbTexel.b, texel.b)).b;\n\n   " +
+            "vec4 mapped;\n   mapped.r = texture2D(inputImageTexture4, vec2(texel.r, .16666)).r;\n   " +
+            "mapped.g = texture2D(inputImageTexture4, vec2(texel.g, .5)).g;\n   " +
+            "mapped.b = texture2D(inputImageTexture4, vec2(texel.b, .83333)).b;\n   " +
+            "mapped.a = 1.0;\n\n   " +
+            "gl_FragColor = mapped;\n }";
+
+    public IFRiseFilter(Context paramContext) {
+        super(paramContext, SHADER);
+        setRes();
+    }
+
+    private void setRes() {
+        addInputTexture(R.drawable.texture_blackboard);
+        addInputTexture(R.drawable.texture_overlay_map);
+        addInputTexture(R.drawable.texture_rise_map);
+    }
+}
diff --git a/library/src/jp/co/cyberagent/android/gpuimage/filter/IFSierraFilter.java b/library/src/jp/co/cyberagent/android/gpuimage/filter/IFSierraFilter.java
new file mode 100644
index 00000000..87e5ab28
--- /dev/null
+++ b/library/src/jp/co/cyberagent/android/gpuimage/filter/IFSierraFilter.java
@@ -0,0 +1,49 @@
+package jp.co.cyberagent.android.gpuimage.filter;
+
+import android.content.Context;
+
+import jp.co.cyberagent.android.gpuimage.R;
+
+/**
+ * Created by sam on 14-8-9.
+ */
+public class IFSierraFilter extends IFImageFilter {
+    private static final String SHADER = "precision lowp float;\n" +
+            " \n" +
+            " varying highp vec2 textureCoordinate;\n" +
+            " \n" +
+            " uniform sampler2D inputImageTexture;\n" +
+            " uniform sampler2D inputImageTexture2; //blowout;\n" +
+            " uniform sampler2D inputImageTexture3; //overlay;\n" +
+            " uniform sampler2D inputImageTexture4; //map\n" +
+            " \n" +
+            " void main()\n" +
+            " {\n" +
+            "     \n" +
+            "     vec4 texel = texture2D(inputImageTexture, textureCoordinate);\n" +
+            "     vec3 bbTexel = texture2D(inputImageTexture2, textureCoordinate).rgb;\n" +
+            "     \n" +
+            "     texel.r = texture2D(inputImageTexture3, vec2(bbTexel.r, texel.r)).r;\n" +
+            "     texel.g = texture2D(inputImageTexture3, vec2(bbTexel.g, texel.g)).g;\n" +
+            "     texel.b = texture2D(inputImageTexture3, vec2(bbTexel.b, texel.b)).b;\n" +
+            "     \n" +
+            "     vec4 mapped;\n" +
+            "     mapped.r = texture2D(inputImageTexture4, vec2(texel.r, .16666)).r;\n" +
+            "     mapped.g = texture2D(inputImageTexture4, vec2(texel.g, .5)).g;\n" +
+            "     mapped.b = texture2D(inputImageTexture4, vec2(texel.b, .83333)).b;\n" +
+            "     mapped.a = 1.0;\n" +
+            "     \n" +
+            "     gl_FragColor = mapped;\n" +
+            " }\n";
+
+    public IFSierraFilter(Context paramContext) {
+        super(paramContext, SHADER);
+        setRes();
+    }
+
+    private void setRes() {
+        addInputTexture(R.drawable.texture_sierra_vignette);
+        addInputTexture(R.drawable.texture_overlay_map);
+        addInputTexture(R.drawable.texture_sierra_map);
+    }
+}
diff --git a/library/src/jp/co/cyberagent/android/gpuimage/filter/IFSutroFilter.java b/library/src/jp/co/cyberagent/android/gpuimage/filter/IFSutroFilter.java
new file mode 100644
index 00000000..6001d0a4
--- /dev/null
+++ b/library/src/jp/co/cyberagent/android/gpuimage/filter/IFSutroFilter.java
@@ -0,0 +1,67 @@
+package jp.co.cyberagent.android.gpuimage.filter;
+
+import android.content.Context;
+
+import jp.co.cyberagent.android.gpuimage.R;
+
+/**
+ * Created by sam on 14-8-9.
+ */
+public class IFSutroFilter extends IFImageFilter {
+    private static final String SHADER = "precision lowp float;\n" +
+            " \n" +
+            " varying highp vec2 textureCoordinate;\n" +
+            " \n" +
+            " uniform sampler2D inputImageTexture;\n" +
+            " uniform sampler2D inputImageTexture2; //sutroMap;\n" +
+            " uniform sampler2D inputImageTexture3; //sutroMetal;\n" +
+            " uniform sampler2D inputImageTexture4; //softLight\n" +
+            " uniform sampler2D inputImageTexture5; //sutroEdgeburn\n" +
+            " uniform sampler2D inputImageTexture6; //sutroCurves\n" +
+            " \n" +
+            " void main()\n" +
+            " {\n" +
+            "     \n" +
+            "     vec3 texel = texture2D(inputImageTexture, textureCoordinate).rgb;\n" +
+            "     \n" +
+            "     vec2 tc = (2.0 * textureCoordinate) - 1.0;\n" +
+            "     float d = dot(tc, tc);\n" +
+            "     vec2 lookup = vec2(d, texel.r);\n" +
+            "     texel.r = texture2D(inputImageTexture2, lookup).r;\n" +
+            "     lookup.y = texel.g;\n" +
+            "     texel.g = texture2D(inputImageTexture2, lookup).g;\n" +
+            "     lookup.y = texel.b;\n" +
+            "     texel.b\t= texture2D(inputImageTexture2, lookup).b;\n" +
+            "     \n" +
+            "     vec3 rgbPrime = vec3(0.1019, 0.0, 0.0); \n" +
+            "     float m = dot(vec3(.3, .59, .11), texel.rgb) - 0.03058;\n" +
+            "     texel = mix(texel, rgbPrime + m, 0.32);\n" +
+            "     \n" +
+            "     vec3 metal = texture2D(inputImageTexture3, textureCoordinate).rgb;\n" +
+            "     texel.r = texture2D(inputImageTexture4, vec2(metal.r, texel.r)).r;\n" +
+            "     texel.g = texture2D(inputImageTexture4, vec2(metal.g, texel.g)).g;\n" +
+            "     texel.b = texture2D(inputImageTexture4, vec2(metal.b, texel.b)).b;\n" +
+            "     \n" +
+            "     texel = texel * texture2D(inputImageTexture5, textureCoordinate).rgb;\n" +
+            "     \n" +
+            "     texel.r = texture2D(inputImageTexture6, vec2(texel.r, .16666)).r;\n" +
+            "     texel.g = texture2D(inputImageTexture6, vec2(texel.g, .5)).g;\n" +
+            "     texel.b = texture2D(inputImageTexture6, vec2(texel.b, .83333)).b;\n" +
+            "     \n" +
+            "     \n" +
+            "     gl_FragColor = vec4(texel, 1.0);\n" +
+            " }\n";
+
+    public IFSutroFilter(Context paramContext) {
+        super(paramContext, SHADER);
+        setRes();
+    }
+
+    private void setRes() {
+        addInputTexture(R.drawable.texture_vignette_map);
+        addInputTexture(R.drawable.texture_sutro_metal);
+        addInputTexture(R.drawable.texture_soft_light);
+        addInputTexture(R.drawable.texture_sutro_edge_burn);
+        addInputTexture(R.drawable.texture_sutro_curves);
+    }
+}
diff --git a/library/src/jp/co/cyberagent/android/gpuimage/filter/IFToasterFilter.java b/library/src/jp/co/cyberagent/android/gpuimage/filter/IFToasterFilter.java
new file mode 100644
index 00000000..a6682ba9
--- /dev/null
+++ b/library/src/jp/co/cyberagent/android/gpuimage/filter/IFToasterFilter.java
@@ -0,0 +1,90 @@
+package jp.co.cyberagent.android.gpuimage.filter;
+
+import android.content.Context;
+
+import jp.co.cyberagent.android.gpuimage.R;
+
+/**
+ * Created by sam on 14-8-9.
+ */
+public class IFToasterFilter extends IFImageFilter {
+    private static final String SHADER = "precision lowp float;\n" +
+            " \n" +
+            " varying highp vec2 textureCoordinate;\n" +
+            " \n" +
+            " uniform sampler2D inputImageTexture;\n" +
+            " uniform sampler2D inputImageTexture2; //toasterMetal\n" +
+            " uniform sampler2D inputImageTexture3; //toasterSoftlight\n" +
+            " uniform sampler2D inputImageTexture4; //toasterCurves\n" +
+            " uniform sampler2D inputImageTexture5; //toasterOverlayMapWarm\n" +
+            " uniform sampler2D inputImageTexture6; //toasterColorshift\n" +
+            " \n" +
+            " void main()\n" +
+            " {\n" +
+            "     lowp vec3 texel;\n" +
+            "     mediump vec2 lookup;\n" +
+            "     vec2 blue;\n" +
+            "     vec2 green;\n" +
+            "     vec2 red;\n" +
+            "     lowp vec4 tmpvar_1;\n" +
+            "     tmpvar_1 = texture2D (inputImageTexture, textureCoordinate);\n" +
+            "     texel = tmpvar_1.xyz;\n" +
+            "     lowp vec4 tmpvar_2;\n" +
+            "     tmpvar_2 = texture2D (inputImageTexture2, textureCoordinate);\n" +
+            "     lowp vec2 tmpvar_3;\n" +
+            "     tmpvar_3.x = tmpvar_2.x;\n" +
+            "     tmpvar_3.y = tmpvar_1.x;\n" +
+            "     texel.x = texture2D (inputImageTexture3, tmpvar_3).x;\n" +
+            "     lowp vec2 tmpvar_4;\n" +
+            "     tmpvar_4.x = tmpvar_2.y;\n" +
+            "     tmpvar_4.y = tmpvar_1.y;\n" +
+            "     texel.y = texture2D (inputImageTexture3, tmpvar_4).y;\n" +
+            "     lowp vec2 tmpvar_5;\n" +
+            "     tmpvar_5.x = tmpvar_2.z;\n" +
+            "     tmpvar_5.y = tmpvar_1.z;\n" +
+            "     texel.z = texture2D (inputImageTexture3, tmpvar_5).z;\n" +
+            "     red.x = texel.x;\n" +
+            "     red.y = 0.16666;\n" +
+            "     green.x = texel.y;\n" +
+            "     green.y = 0.5;\n" +
+            "     blue.x = texel.z;\n" +
+            "     blue.y = 0.833333;\n" +
+            "     texel.x = texture2D (inputImageTexture4, red).x;\n" +
+            "     texel.y = texture2D (inputImageTexture4, green).y;\n" +
+            "     texel.z = texture2D (inputImageTexture4, blue).z;\n" +
+            "     mediump vec2 tmpvar_6;\n" +
+            "     tmpvar_6 = ((2.0 * textureCoordinate) - 1.0);\n" +
+            "     mediump vec2 tmpvar_7;\n" +
+            "     tmpvar_7.x = dot (tmpvar_6, tmpvar_6);\n" +
+            "     tmpvar_7.y = texel.x;\n" +
+            "     lookup = tmpvar_7;\n" +
+            "     texel.x = texture2D (inputImageTexture5, tmpvar_7).x;\n" +
+            "     lookup.y = texel.y;\n" +
+            "     texel.y = texture2D (inputImageTexture5, lookup).y;\n" +
+            "     lookup.y = texel.z;\n" +
+            "     texel.z = texture2D (inputImageTexture5, lookup).z;\n" +
+            "     red.x = texel.x;\n" +
+            "     green.x = texel.y;\n" +
+            "     blue.x = texel.z;\n" +
+            "     texel.x = texture2D (inputImageTexture6, red).x;\n" +
+            "     texel.y = texture2D (inputImageTexture6, green).y;\n" +
+            "     texel.z = texture2D (inputImageTexture6, blue).z;\n" +
+            "     lowp vec4 tmpvar_8;\n" +
+            "     tmpvar_8.w = 1.0;\n" +
+            "     tmpvar_8.xyz = texel;\n" +
+            "     gl_FragColor = tmpvar_8;\n" +
+            " }";
+
+    public IFToasterFilter(Context paramContext) {
+        super(paramContext, SHADER);
+        setRes();
+    }
+
+    private void setRes() {
+        addInputTexture(R.drawable.texture_toaster_metal);
+        addInputTexture(R.drawable.texture_toaster_soft_light);
+        addInputTexture(R.drawable.texture_toaster_curves);
+        addInputTexture(R.drawable.texture_toaster_overlay_map_warm);
+        addInputTexture(R.drawable.texture_toaster_color_shift);
+    }
+}
diff --git a/library/src/jp/co/cyberagent/android/gpuimage/filter/IFValenciaFilter.java b/library/src/jp/co/cyberagent/android/gpuimage/filter/IFValenciaFilter.java
new file mode 100644
index 00000000..088739f0
--- /dev/null
+++ b/library/src/jp/co/cyberagent/android/gpuimage/filter/IFValenciaFilter.java
@@ -0,0 +1,61 @@
+package jp.co.cyberagent.android.gpuimage.filter;
+
+import android.content.Context;
+
+import jp.co.cyberagent.android.gpuimage.R;
+
+/**
+ * Created by sam on 14-8-9.
+ */
+public class IFValenciaFilter extends IFImageFilter {
+    private static final String SHADER = "precision lowp float;\n" +
+            " \n" +
+            " varying highp vec2 textureCoordinate;\n" +
+            " \n" +
+            " uniform sampler2D inputImageTexture;\n" +
+            " uniform sampler2D inputImageTexture2; //map\n" +
+            " uniform sampler2D inputImageTexture3; //gradMap\n" +
+            " \n" +
+            " mat3 saturateMatrix = mat3(\n" +
+            "                            1.1402,\n" +
+            "                            -0.0598,\n" +
+            "                            -0.061,\n" +
+            "                            -0.1174,\n" +
+            "                            1.0826,\n" +
+            "                            -0.1186,\n" +
+            "                            -0.0228,\n" +
+            "                            -0.0228,\n" +
+            "                            1.1772);\n" +
+            " \n" +
+            " vec3 lumaCoeffs = vec3(.3, .59, .11);\n" +
+            " \n" +
+            " void main()\n" +
+            " {\n" +
+            "     vec3 texel = texture2D(inputImageTexture, textureCoordinate).rgb;\n" +
+            "     \n" +
+            "     texel = vec3(\n" +
+            "                  texture2D(inputImageTexture2, vec2(texel.r, .1666666)).r,\n" +
+            "                  texture2D(inputImageTexture2, vec2(texel.g, .5)).g,\n" +
+            "                  texture2D(inputImageTexture2, vec2(texel.b, .8333333)).b\n" +
+            "                  );\n" +
+            "     \n" +
+            "     texel = saturateMatrix * texel;\n" +
+            "     float luma = dot(lumaCoeffs, texel);\n" +
+            "     texel = vec3(\n" +
+            "                  texture2D(inputImageTexture3, vec2(luma, texel.r)).r,\n" +
+            "                  texture2D(inputImageTexture3, vec2(luma, texel.g)).g,\n" +
+            "                  texture2D(inputImageTexture3, vec2(luma, texel.b)).b);\n" +
+            "     \n" +
+            "     gl_FragColor = vec4(texel, 1.0);\n" +
+            " }\n";
+
+    public IFValenciaFilter(Context paramContext) {
+        super(paramContext, SHADER);
+        setRes();
+    }
+
+    private void setRes() {
+        addInputTexture(R.drawable.texture_valencia_map);
+        addInputTexture(R.drawable.texture_valencia_gradient_map);
+    }
+}
diff --git a/library/src/jp/co/cyberagent/android/gpuimage/filter/IFWaldenFilter.java b/library/src/jp/co/cyberagent/android/gpuimage/filter/IFWaldenFilter.java
new file mode 100644
index 00000000..39427a79
--- /dev/null
+++ b/library/src/jp/co/cyberagent/android/gpuimage/filter/IFWaldenFilter.java
@@ -0,0 +1,50 @@
+package jp.co.cyberagent.android.gpuimage.filter;
+
+import android.content.Context;
+
+import jp.co.cyberagent.android.gpuimage.R;
+
+/**
+ * Created by sam on 14-8-9.
+ */
+public class IFWaldenFilter extends IFImageFilter {
+    private static final String SHADER = "precision lowp float;\n" +
+            " \n" +
+            " varying highp vec2 textureCoordinate;\n" +
+            " \n" +
+            " uniform sampler2D inputImageTexture;\n" +
+            " uniform sampler2D inputImageTexture2; //map\n" +
+            " uniform sampler2D inputImageTexture3; //vigMap\n" +
+            " \n" +
+            " void main()\n" +
+            " {\n" +
+            "     \n" +
+            "     vec3 texel = texture2D(inputImageTexture, textureCoordinate).rgb;\n" +
+            "     \n" +
+            "     texel = vec3(\n" +
+            "                  texture2D(inputImageTexture2, vec2(texel.r, .16666)).r,\n" +
+            "                  texture2D(inputImageTexture2, vec2(texel.g, .5)).g,\n" +
+            "                  texture2D(inputImageTexture2, vec2(texel.b, .83333)).b);\n" +
+            "     \n" +
+            "     vec2 tc = (2.0 * textureCoordinate) - 1.0;\n" +
+            "     float d = dot(tc, tc);\n" +
+            "     vec2 lookup = vec2(d, texel.r);\n" +
+            "     texel.r = texture2D(inputImageTexture3, lookup).r;\n" +
+            "     lookup.y = texel.g;\n" +
+            "     texel.g = texture2D(inputImageTexture3, lookup).g;\n" +
+            "     lookup.y = texel.b;\n" +
+            "     texel.b\t= texture2D(inputImageTexture3, lookup).b;\n" +
+            "     \n" +
+            "     gl_FragColor = vec4(texel, 1.0);\n" +
+            " }\n";
+
+    public IFWaldenFilter(Context paramContext) {
+        super(paramContext, SHADER);
+        setRes();
+    }
+
+    private void setRes() {
+        addInputTexture(R.drawable.texture_walden_map);
+        addInputTexture(R.drawable.texture_vignette_map);
+    }
+}
diff --git a/library/src/jp/co/cyberagent/android/gpuimage/filter/IFXprollFilter.java b/library/src/jp/co/cyberagent/android/gpuimage/filter/IFXprollFilter.java
new file mode 100644
index 00000000..3ebf883f
--- /dev/null
+++ b/library/src/jp/co/cyberagent/android/gpuimage/filter/IFXprollFilter.java
@@ -0,0 +1,53 @@
+package jp.co.cyberagent.android.gpuimage.filter;
+
+import android.content.Context;
+
+import jp.co.cyberagent.android.gpuimage.R;
+
+/**
+ * Created by sam on 14-8-9.
+ */
+public class IFXprollFilter extends IFImageFilter {
+    private static final String SHADER = "precision lowp float;\n" +
+            " \n" +
+            " varying highp vec2 textureCoordinate;\n" +
+            " \n" +
+            " uniform sampler2D inputImageTexture;\n" +
+            " uniform sampler2D inputImageTexture2; //map\n" +
+            " uniform sampler2D inputImageTexture3; //vigMap\n" +
+            " \n" +
+            " void main()\n" +
+            " {\n" +
+            "     \n" +
+            "     vec3 texel = texture2D(inputImageTexture, textureCoordinate).rgb;\n" +
+            "     \n" +
+            "     vec2 tc = (2.0 * textureCoordinate) - 1.0;\n" +
+            "     float d = dot(tc, tc);\n" +
+            "     vec2 lookup = vec2(d, texel.r);\n" +
+            "     texel.r = texture2D(inputImageTexture3, lookup).r;\n" +
+            "     lookup.y = texel.g;\n" +
+            "     texel.g = texture2D(inputImageTexture3, lookup).g;\n" +
+            "     lookup.y = texel.b;\n" +
+            "     texel.b\t= texture2D(inputImageTexture3, lookup).b;\n" +
+            "     \n" +
+            "     vec2 red = vec2(texel.r, 0.16666);\n" +
+            "     vec2 green = vec2(texel.g, 0.5);\n" +
+            "     vec2 blue = vec2(texel.b, .83333);\n" +
+            "     texel.r = texture2D(inputImageTexture2, red).r;\n" +
+            "     texel.g = texture2D(inputImageTexture2, green).g;\n" +
+            "     texel.b = texture2D(inputImageTexture2, blue).b;\n" +
+            "     \n" +
+            "     gl_FragColor = vec4(texel, 1.0);\n" +
+            "     \n" +
+            " }\n";
+
+    public IFXprollFilter(Context paramContext) {
+        super(paramContext, SHADER);
+        setRes();
+    }
+
+    private void setRes() {
+        addInputTexture(R.drawable.texture_xpro_map);
+        addInputTexture(R.drawable.texture_vignette_map);
+    }
+}
diff --git a/sample/src/jp/co/cyberagent/android/gpuimage/sample/GPUImageFilterTools.java b/sample/src/jp/co/cyberagent/android/gpuimage/sample/GPUImageFilterTools.java
index 6f2f6dd4..2ebe8ad7 100644
--- a/sample/src/jp/co/cyberagent/android/gpuimage/sample/GPUImageFilterTools.java
+++ b/sample/src/jp/co/cyberagent/android/gpuimage/sample/GPUImageFilterTools.java
@@ -24,6 +24,23 @@
 import android.opengl.Matrix;
 
 import jp.co.cyberagent.android.gpuimage.*;
+import jp.co.cyberagent.android.gpuimage.filter.IF1977Filter;
+import jp.co.cyberagent.android.gpuimage.filter.IFAmaroFilter;
+import jp.co.cyberagent.android.gpuimage.filter.IFBrannanFilter;
+import jp.co.cyberagent.android.gpuimage.filter.IFEarlybirdFilter;
+import jp.co.cyberagent.android.gpuimage.filter.IFHefeFilter;
+import jp.co.cyberagent.android.gpuimage.filter.IFHudsonFilter;
+import jp.co.cyberagent.android.gpuimage.filter.IFInkwellFilter;
+import jp.co.cyberagent.android.gpuimage.filter.IFLomoFilter;
+import jp.co.cyberagent.android.gpuimage.filter.IFLordKelvinFilter;
+import jp.co.cyberagent.android.gpuimage.filter.IFNashvilleFilter;
+import jp.co.cyberagent.android.gpuimage.filter.IFRiseFilter;
+import jp.co.cyberagent.android.gpuimage.filter.IFSierraFilter;
+import jp.co.cyberagent.android.gpuimage.filter.IFSutroFilter;
+import jp.co.cyberagent.android.gpuimage.filter.IFToasterFilter;
+import jp.co.cyberagent.android.gpuimage.filter.IFValenciaFilter;
+import jp.co.cyberagent.android.gpuimage.filter.IFWaldenFilter;
+import jp.co.cyberagent.android.gpuimage.filter.IFXprollFilter;
 
 import java.util.LinkedList;
 import java.util.List;
@@ -32,6 +49,28 @@
     public static void showDialog(final Context context,
             final OnGpuImageFilterChosenListener listener) {
         final FilterList filters = new FilterList();
+        filters.addFilter("Gaussian Blur", FilterType.GAUSSIAN_BLUR);
+        filters.addFilter("ZoomBlur", FilterType.ZOOM_BLUR);
+        filters.addFilter("Halftone", FilterType.HALFTONE);
+        filters.addFilter("Rise", FilterType.EXTRA_RISE);
+        filters.addFilter("Hudson", FilterType.EXTRA_HUDSON);
+        filters.addFilter("Xproll", FilterType.EXTRA_XPROLL);
+        filters.addFilter("Sierra", FilterType.EXTRA_SIERRA);
+        filters.addFilter("Lomo", FilterType.EXTRA_LOMO);
+        filters.addFilter("Earlybird", FilterType.EXTRA_EARLYBIRD);
+        filters.addFilter("Sutro", FilterType.EXTRA_SUTRO);
+        filters.addFilter("Toaster", FilterType.EXTRA_TOASTER);
+        filters.addFilter("Brannan", FilterType.EXTRA_BRANNAN);
+        filters.addFilter("Inkwell", FilterType.EXTRA_INKWELL);
+        filters.addFilter("Walden", FilterType.EXTRA_WALDEN);
+        filters.addFilter("Hefe", FilterType.EXTRA_HEFE);
+        filters.addFilter("Valencia", FilterType.EXTRA_VALENCIA);
+        filters.addFilter("Nashville", FilterType.EXTRA_NASHVILLE);
+        filters.addFilter("1977", FilterType.EXTRA_1977);
+        filters.addFilter("Kelvin", FilterType.EXTRA_KELVIN);
+        filters.addFilter("Amaro", FilterType.EXTRA_AMARO);
+
+
         filters.addFilter("Contrast", FilterType.CONTRAST);
         filters.addFilter("Invert", FilterType.INVERT);
         filters.addFilter("Pixelation", FilterType.PIXELATION);
@@ -82,7 +121,7 @@ public static void showDialog(final Context context,
         filters.addFilter("Blend (Normal)", FilterType.BLEND_NORMAL);
 
         filters.addFilter("Lookup (Amatorka)", FilterType.LOOKUP_AMATORKA);
-        filters.addFilter("Gaussian Blur", FilterType.GAUSSIAN_BLUR);
+        filters.addFilter("Gaussian Blur Position", FilterType.GAUSSIAN_BLUR_POSITION);
         filters.addFilter("Crosshatch", FilterType.CROSSHATCH);
 
         filters.addFilter("Box Blur", FilterType.BOX_BLUR);
@@ -93,7 +132,6 @@ public static void showDialog(final Context context,
         filters.addFilter("Sketch", FilterType.SKETCH);
         filters.addFilter("Toon", FilterType.TOON);
         filters.addFilter("Smooth Toon", FilterType.SMOOTH_TOON);
-        filters.addFilter("Halftone", FilterType.HALFTONE);
 
         filters.addFilter("Bulge Distortion", FilterType.BULGE_DISTORTION);
         filters.addFilter("Glass Sphere", FilterType.GLASS_SPHERE);
@@ -129,6 +167,44 @@ public void onClick(final DialogInterface dialog, final int item) {
 
     private static GPUImageFilter createFilterForType(final Context context, final FilterType type) {
         switch (type) {
+            case ZOOM_BLUR:
+                return new GPUImageZoomBlurFilter();
+            case EXTRA_RISE:
+                return new IFRiseFilter(context);
+            case EXTRA_HUDSON:
+                return new IFHudsonFilter(context);
+            case EXTRA_XPROLL:
+                return new IFXprollFilter(context);
+            case EXTRA_SIERRA:
+                return new IFSierraFilter(context);
+            case EXTRA_LOMO:
+                return new IFLomoFilter(context);
+            case EXTRA_EARLYBIRD:
+                return new IFEarlybirdFilter(context);
+            case EXTRA_SUTRO:
+                return new IFSutroFilter(context);
+            case EXTRA_TOASTER:
+                return new IFToasterFilter(context);
+            case EXTRA_BRANNAN:
+                return new IFBrannanFilter(context);
+            case EXTRA_INKWELL:
+                return new IFInkwellFilter(context);
+            case EXTRA_WALDEN:
+                return new IFWaldenFilter(context);
+            case EXTRA_HEFE:
+                return new IFHefeFilter(context);
+            case EXTRA_VALENCIA:
+                return new IFValenciaFilter(context);
+            case EXTRA_NASHVILLE:
+                return new IFNashvilleFilter(context);
+            case EXTRA_1977:
+                return new IF1977Filter(context);
+            case EXTRA_KELVIN:
+                return new IFLordKelvinFilter(context);
+            case EXTRA_AMARO:
+                return new IFAmaroFilter(context);
+
+
             case CONTRAST:
                 return new GPUImageContrastFilter(2.0f);
             case GAMMA:
@@ -164,7 +240,7 @@ private static GPUImageFilter createFilterForType(final Context context, final F
             case POSTERIZE:
                 return new GPUImagePosterizeFilter();
             case FILTER_GROUP:
-                List<GPUImageFilter> filters = new LinkedList<GPUImageFilter>();
+                List<GPUImageFilter> filters = new LinkedList<>();
                 filters.add(new GPUImageContrastFilter());
                 filters.add(new GPUImageDirectionalSobelEdgeDetectionFilter());
                 filters.add(new GPUImageGrayscaleFilter());
@@ -250,6 +326,8 @@ private static GPUImageFilter createFilterForType(final Context context, final F
                 return amatorka;
             case GAUSSIAN_BLUR:
                 return new GPUImageGaussianBlurFilter();
+            case GAUSSIAN_BLUR_POSITION:
+                return new GPUImageGaussianBlurPositionFilter();
             case CROSSHATCH:
                 return new GPUImageCrosshatchFilter();
 
@@ -325,17 +403,21 @@ private static GPUImageFilter createBlendFilter(Context context, Class<? extends
     }
 
     private enum FilterType {
+        ZOOM_BLUR, HALFTONE,
+
+        EXTRA_RISE, EXTRA_HUDSON, EXTRA_XPROLL, EXTRA_SIERRA, EXTRA_LOMO, EXTRA_EARLYBIRD, EXTRA_SUTRO, EXTRA_TOASTER, EXTRA_BRANNAN, EXTRA_INKWELL, EXTRA_WALDEN, EXTRA_HEFE, EXTRA_VALENCIA, EXTRA_NASHVILLE, EXTRA_1977, EXTRA_KELVIN, EXTRA_AMARO,
+
         CONTRAST, GRAYSCALE, SHARPEN, SEPIA, SOBEL_EDGE_DETECTION, THREE_X_THREE_CONVOLUTION, FILTER_GROUP, EMBOSS, POSTERIZE, GAMMA, BRIGHTNESS, INVERT, HUE, PIXELATION,
         SATURATION, EXPOSURE, HIGHLIGHT_SHADOW, MONOCHROME, OPACITY, RGB, WHITE_BALANCE, VIGNETTE, TONE_CURVE, BLEND_COLOR_BURN, BLEND_COLOR_DODGE, BLEND_DARKEN, BLEND_DIFFERENCE,
         BLEND_DISSOLVE, BLEND_EXCLUSION, BLEND_SOURCE_OVER, BLEND_HARD_LIGHT, BLEND_LIGHTEN, BLEND_ADD, BLEND_DIVIDE, BLEND_MULTIPLY, BLEND_OVERLAY, BLEND_SCREEN, BLEND_ALPHA,
         BLEND_COLOR, BLEND_HUE, BLEND_SATURATION, BLEND_LUMINOSITY, BLEND_LINEAR_BURN, BLEND_SOFT_LIGHT, BLEND_SUBTRACT, BLEND_CHROMA_KEY, BLEND_NORMAL, LOOKUP_AMATORKA,
-        GAUSSIAN_BLUR, CROSSHATCH, BOX_BLUR, CGA_COLORSPACE, DILATION, KUWAHARA, RGB_DILATION, SKETCH, TOON, SMOOTH_TOON, BULGE_DISTORTION, GLASS_SPHERE, HAZE, LAPLACIAN, NON_MAXIMUM_SUPPRESSION,
-        SPHERE_REFRACTION, SWIRL, WEAK_PIXEL_INCLUSION, FALSE_COLOR, COLOR_BALANCE, LEVELS_FILTER_MIN, BILATERAL_BLUR, HALFTONE, TRANSFORM2D
+        GAUSSIAN_BLUR, GAUSSIAN_BLUR_POSITION, CROSSHATCH, BOX_BLUR, CGA_COLORSPACE, DILATION, KUWAHARA, RGB_DILATION, SKETCH, TOON, SMOOTH_TOON, BULGE_DISTORTION, GLASS_SPHERE, HAZE, LAPLACIAN, NON_MAXIMUM_SUPPRESSION,
+        SPHERE_REFRACTION, SWIRL, WEAK_PIXEL_INCLUSION, FALSE_COLOR, COLOR_BALANCE, LEVELS_FILTER_MIN, BILATERAL_BLUR, TRANSFORM2D,
     }
 
     private static class FilterList {
-        public List<String> names = new LinkedList<String>();
-        public List<FilterType> filters = new LinkedList<FilterType>();
+        public List<String> names = new LinkedList<>();
+        public List<FilterType> filters = new LinkedList<>();
 
         public void addFilter(final String name, final FilterType filter) {
             names.add(name);
@@ -347,7 +429,9 @@ public void addFilter(final String name, final FilterType filter) {
         private final Adjuster<? extends GPUImageFilter> adjuster;
 
         public FilterAdjuster(final GPUImageFilter filter) {
-            if (filter instanceof GPUImageSharpenFilter) {
+            if (filter instanceof GPUImageZoomBlurFilter) {
+                adjuster = new ZoomBlurAdjuster().filter(filter);
+            } else if (filter instanceof GPUImageSharpenFilter) {
                 adjuster = new SharpnessAdjuster().filter(filter);
             } else if (filter instanceof GPUImageSepiaFilter) {
                 adjuster = new SepiaAdjuster().filter(filter);
@@ -389,6 +473,8 @@ public FilterAdjuster(final GPUImageFilter filter) {
                 adjuster = new DissolveBlendAdjuster().filter(filter);
             } else if (filter instanceof GPUImageGaussianBlurFilter) {
                 adjuster = new GaussianBlurAdjuster().filter(filter);
+            } else if (filter instanceof GPUImageGaussianBlurPositionFilter) {
+                adjuster = new GaussianBlurPositionAdjuster().filter(filter);
             } else if (filter instanceof GPUImageCrosshatchFilter) {
                 adjuster = new CrosshatchBlurAdjuster().filter(filter);
             } else if (filter instanceof GPUImageBulgeDistortionFilter) {
@@ -411,7 +497,6 @@ public FilterAdjuster(final GPUImageFilter filter) {
                 adjuster = new RotateAdjuster().filter(filter);
             }
             else {
-
                 adjuster = null;
             }
         }
@@ -450,6 +535,13 @@ protected int range(final int percentage, final int start, final int end) {
             }
         }
 
+        private class ZoomBlurAdjuster extends Adjuster<GPUImageZoomBlurFilter> {
+            @Override
+            public void adjust(final int size) {
+                getFilter().setSize(range(size, 1.0f, 20.0f));
+            }
+        }
+
         private class SharpnessAdjuster extends Adjuster<GPUImageSharpenFilter> {
             @Override
             public void adjust(final int percentage) {
@@ -599,7 +691,16 @@ public void adjust(final int percentage) {
         private class GaussianBlurAdjuster extends Adjuster<GPUImageGaussianBlurFilter> {
             @Override
             public void adjust(final int percentage) {
-                getFilter().setBlurSize(range(percentage, 0.0f, 1.0f));
+//                getFilter().setBlurSize(range(percentage, 0.0f, 1.0f));
+//                getFilter().setRadius(range(percentage, 0.0f, 1.0f));
+                getFilter().setRadiusInPixel(range(percentage, 1, 8));
+            }
+        }
+
+        private class GaussianBlurPositionAdjuster extends Adjuster<GPUImageGaussianBlurPositionFilter> {
+            @Override
+            public void adjust(final int percentage) {
+                getFilter().setRadius(range(percentage, 0.0f, 1.0f));
             }
         }
 
