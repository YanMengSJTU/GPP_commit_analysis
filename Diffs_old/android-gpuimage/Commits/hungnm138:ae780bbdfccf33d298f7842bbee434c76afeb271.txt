diff --git a/README.md b/README.md
index 7336ce66..5aabb21d 100644
--- a/README.md
+++ b/README.md
@@ -20,7 +20,7 @@ allprojects {
 **Step 2.** Add the dependency
 ```gradle
 dependencies {
-   compile 'com.github.proghjy:android-gpuimage-videorecording:v1.4.2'
+   compile 'com.github.hungnm138:android-gpuimage-videorecording:v1.4.4'
 }
 ```
 
diff --git a/library/src/jp/co/cyberagent/android/gpuimage/GPUImage.java b/library/src/jp/co/cyberagent/android/gpuimage/GPUImage.java
index 9893e799..a7f9e3b8 100644
--- a/library/src/jp/co/cyberagent/android/gpuimage/GPUImage.java
+++ b/library/src/jp/co/cyberagent/android/gpuimage/GPUImage.java
@@ -51,7 +51,7 @@
     private GLTextureView mGLTextureView;
     private GPUImageFilter mFilter;
     private Bitmap mCurrentBitmap;
-    private ScaleType mScaleType = ScaleType.CENTER_CROP;
+    private ScaleType mScaleType = ScaleType.CENTER_INSIDE;
 
     /**
      * Instantiates a new GPUImage object.
@@ -75,10 +75,8 @@ public GPUImage(final Context context) {
      * @return true, if successful
      */
     private boolean supportsOpenGLES2(final Context context) {
-        final ActivityManager activityManager = (ActivityManager)
-                context.getSystemService(Context.ACTIVITY_SERVICE);
-        final ConfigurationInfo configurationInfo =
-                activityManager.getDeviceConfigurationInfo();
+        final ActivityManager activityManager = (ActivityManager) context.getSystemService(Context.ACTIVITY_SERVICE);
+        final ConfigurationInfo configurationInfo = activityManager.getDeviceConfigurationInfo();
         return configurationInfo.reqGlEsVersion >= 0x20000;
     }
 
@@ -145,15 +143,15 @@ public void setUpCamera(final Camera camera, final int degrees, final boolean fl
         }
         Rotation rotation = Rotation.NORMAL;
         switch (degrees) {
-            case 90:
-                rotation = Rotation.ROTATION_90;
-                break;
-            case 180:
-                rotation = Rotation.ROTATION_180;
-                break;
-            case 270:
-                rotation = Rotation.ROTATION_270;
-                break;
+        case 90:
+            rotation = Rotation.ROTATION_90;
+            break;
+        case 180:
+            rotation = Rotation.ROTATION_180;
+            break;
+        case 270:
+            rotation = Rotation.ROTATION_270;
+            break;
         }
         mRenderer.setRotationCamera(rotation, flipHorizontal, flipVertical);
     }
@@ -246,11 +244,8 @@ public void setImage(final File file) {
     }
 
     private String getPath(final Uri uri) {
-        String[] projection = {
-                MediaStore.Images.Media.DATA,
-        };
-        Cursor cursor = mContext.getContentResolver()
-                .query(uri, projection, null, null, null);
+        String[] projection = { MediaStore.Images.Media.DATA, };
+        Cursor cursor = mContext.getContentResolver().query(uri, projection, null, null, null);
         int pathIndex = cursor.getColumnIndexOrThrow(MediaStore.Images.Media.DATA);
         String path = null;
         if (cursor.moveToFirst()) {
@@ -282,13 +277,13 @@ public Bitmap getBitmapWithFilterApplied(final Bitmap bitmap) {
 
                 @Override
                 public void run() {
-                    synchronized(mFilter) {
+                    synchronized (mFilter) {
                         mFilter.destroy();
                         mFilter.notify();
                     }
                 }
             });
-            synchronized(mFilter) {
+            synchronized (mFilter) {
                 requestRender();
                 try {
                     mFilter.wait();
@@ -299,8 +294,7 @@ public void run() {
         }
 
         GPUImageRenderer renderer = new GPUImageRenderer(mFilter);
-        renderer.setRotation(Rotation.NORMAL,
-                mRenderer.isFlippedHorizontally(), mRenderer.isFlippedVertically());
+        renderer.setRotation(Rotation.NORMAL, mRenderer.isFlippedHorizontally(), mRenderer.isFlippedVertically());
         renderer.setScaleType(mScaleType);
         PixelBuffer buffer = new PixelBuffer(bitmap.getWidth(), bitmap.getHeight());
         buffer.setRenderer(renderer);
@@ -330,8 +324,8 @@ public void run() {
      * @param filters the filters which will be applied on the bitmap
      * @param listener the listener on which the results will be notified
      */
-    public static void getBitmapForMultipleFilters(final Bitmap bitmap,
-            final List<GPUImageFilter> filters, final ResponseListener<Bitmap> listener) {
+    public static void getBitmapForMultipleFilters(final Bitmap bitmap, final List<GPUImageFilter> filters,
+            final ResponseListener<Bitmap> listener) {
         if (filters.isEmpty()) {
             return;
         }
@@ -364,8 +358,7 @@ public static void getBitmapForMultipleFilters(final Bitmap bitmap,
      * @param listener the listener
      */
     @Deprecated
-    public void saveToPictures(final String folderName, final String fileName,
-            final OnPictureSavedListener listener) {
+    public void saveToPictures(final String folderName, final String fileName, final OnPictureSavedListener listener) {
         saveToPictures(mCurrentBitmap, folderName, fileName, listener);
     }
 
@@ -405,8 +398,7 @@ private int getOutputWidth() {
         } else if (mCurrentBitmap != null) {
             return mCurrentBitmap.getWidth();
         } else {
-            WindowManager windowManager =
-                    (WindowManager) mContext.getSystemService(Context.WINDOW_SERVICE);
+            WindowManager windowManager = (WindowManager) mContext.getSystemService(Context.WINDOW_SERVICE);
             Display display = windowManager.getDefaultDisplay();
             return display.getWidth();
         }
@@ -418,8 +410,7 @@ private int getOutputHeight() {
         } else if (mCurrentBitmap != null) {
             return mCurrentBitmap.getHeight();
         } else {
-            WindowManager windowManager =
-                    (WindowManager) mContext.getSystemService(Context.WINDOW_SERVICE);
+            WindowManager windowManager = (WindowManager) mContext.getSystemService(Context.WINDOW_SERVICE);
             Display display = windowManager.getDefaultDisplay();
             return display.getHeight();
         }
@@ -451,16 +442,12 @@ protected Void doInBackground(final Void... params) {
         }
 
         private void saveImage(final String folderName, final String fileName, final Bitmap image) {
-            File path = Environment
-                    .getExternalStoragePublicDirectory(Environment.DIRECTORY_PICTURES);
+            File path = Environment.getExternalStoragePublicDirectory(Environment.DIRECTORY_PICTURES);
             File file = new File(path, folderName + "/" + fileName);
             try {
                 file.getParentFile().mkdirs();
                 image.compress(CompressFormat.JPEG, 80, new FileOutputStream(file));
-                MediaScannerConnection.scanFile(mContext,
-                        new String[] {
-                            file.toString()
-                        }, null,
+                MediaScannerConnection.scanFile(mContext, new String[] { file.toString() }, null,
                         new MediaScannerConnection.OnScanCompletedListener() {
                             @Override
                             public void onScanCompleted(final String path, final Uri uri) {
@@ -545,16 +532,16 @@ protected int getImageOrientation() throws IOException {
             ExifInterface exif = new ExifInterface(mImageFile.getAbsolutePath());
             int orientation = exif.getAttributeInt(ExifInterface.TAG_ORIENTATION, 1);
             switch (orientation) {
-                case ExifInterface.ORIENTATION_NORMAL:
-                    return 0;
-                case ExifInterface.ORIENTATION_ROTATE_90:
-                    return 90;
-                case ExifInterface.ORIENTATION_ROTATE_180:
-                    return 180;
-                case ExifInterface.ORIENTATION_ROTATE_270:
-                    return 270;
-                default:
-                    return 0;
+            case ExifInterface.ORIENTATION_NORMAL:
+                return 0;
+            case ExifInterface.ORIENTATION_ROTATE_90:
+                return 90;
+            case ExifInterface.ORIENTATION_ROTATE_180:
+                return 180;
+            case ExifInterface.ORIENTATION_ROTATE_270:
+                return 270;
+            default:
+                return 0;
             }
         }
     }
@@ -638,8 +625,8 @@ private Bitmap scaleBitmap(Bitmap bitmap) {
                 // Crop it
                 int diffWidth = newSize[0] - mOutputWidth;
                 int diffHeight = newSize[1] - mOutputHeight;
-                workBitmap = Bitmap.createBitmap(bitmap, diffWidth / 2, diffHeight / 2,
-                        newSize[0] - diffWidth, newSize[1] - diffHeight);
+                workBitmap = Bitmap.createBitmap(bitmap, diffWidth / 2, diffHeight / 2, newSize[0] - diffWidth,
+                        newSize[1] - diffHeight);
                 if (workBitmap != bitmap) {
                     bitmap.recycle();
                     bitmap = workBitmap;
@@ -662,8 +649,8 @@ private Bitmap scaleBitmap(Bitmap bitmap) {
             float withRatio = (float) width / mOutputWidth;
             float heightRatio = (float) height / mOutputHeight;
 
-            boolean adjustWidth = mScaleType == ScaleType.CENTER_CROP
-                    ? withRatio > heightRatio : withRatio < heightRatio;
+            boolean adjustWidth = mScaleType == ScaleType.CENTER_CROP ? withRatio > heightRatio
+                    : withRatio < heightRatio;
 
             if (adjustWidth) {
                 newHeight = mOutputHeight;
@@ -672,7 +659,7 @@ private Bitmap scaleBitmap(Bitmap bitmap) {
                 newWidth = mOutputWidth;
                 newHeight = (newWidth / width) * height;
             }
-            return new int[]{Math.round(newWidth), Math.round(newHeight)};
+            return new int[] { Math.round(newWidth), Math.round(newHeight) };
         }
 
         private boolean checkSize(boolean widthBigger, boolean heightBigger) {
@@ -693,8 +680,8 @@ private Bitmap rotateImage(final Bitmap bitmap) {
                 if (orientation != 0) {
                     Matrix matrix = new Matrix();
                     matrix.postRotate(orientation);
-                    rotatedBitmap = Bitmap.createBitmap(bitmap, 0, 0, bitmap.getWidth(),
-                            bitmap.getHeight(), matrix, true);
+                    rotatedBitmap = Bitmap.createBitmap(bitmap, 0, 0, bitmap.getWidth(), bitmap.getHeight(), matrix,
+                            true);
                     bitmap.recycle();
                 }
             } catch (IOException e) {
@@ -710,5 +697,16 @@ private Bitmap rotateImage(final Bitmap bitmap) {
         void response(T item);
     }
 
-    public enum ScaleType { CENTER_INSIDE, CENTER_CROP }
+    public Bitmap getImage() {
+        return mRenderer.image;
+    }
+
+    public GPUImage setCallback(GPUImageCallback listener) {
+        mRenderer.setCallbackGPUImageListener(listener);
+        return this;
+    }
+
+    public enum ScaleType {
+        CENTER_INSIDE, CENTER_CROP
+    }
 }
diff --git a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageCallback.java b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageCallback.java
new file mode 100644
index 00000000..45c03a00
--- /dev/null
+++ b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageCallback.java
@@ -0,0 +1,7 @@
+package jp.co.cyberagent.android.gpuimage;
+
+import android.graphics.Bitmap;
+
+public interface GPUImageCallback {
+    void callback(Bitmap image);
+}
\ No newline at end of file
diff --git a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageRenderer.java b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageRenderer.java
index a7af3f00..343f8926 100644
--- a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageRenderer.java
+++ b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageRenderer.java
@@ -42,12 +42,7 @@
 @TargetApi(11)
 public class GPUImageRenderer implements GLTextureView.Renderer, PreviewCallback {
     public static final int NO_IMAGE = -1;
-    static final float CUBE[] = {
-            -1.0f, -1.0f,
-            1.0f, -1.0f,
-            -1.0f, 1.0f,
-            1.0f, 1.0f,
-    };
+    static final float CUBE[] = { -1.0f, -1.0f, 1.0f, -1.0f, -1.0f, 1.0f, 1.0f, 1.0f, };
 
     private GPUImageFilter mFilter;
 
@@ -81,13 +76,10 @@ public GPUImageRenderer(final GPUImageFilter filter) {
         mRunOnDraw = new LinkedList<Runnable>();
         mRunOnDrawEnd = new LinkedList<Runnable>();
 
-        mGLCubeBuffer = ByteBuffer.allocateDirect(CUBE.length * 4)
-                .order(ByteOrder.nativeOrder())
-                .asFloatBuffer();
+        mGLCubeBuffer = ByteBuffer.allocateDirect(CUBE.length * 4).order(ByteOrder.nativeOrder()).asFloatBuffer();
         mGLCubeBuffer.put(CUBE).position(0);
 
-        mGLTextureBuffer = ByteBuffer.allocateDirect(TEXTURE_NO_ROTATION.length * 4)
-                .order(ByteOrder.nativeOrder())
+        mGLTextureBuffer = ByteBuffer.allocateDirect(TEXTURE_NO_ROTATION.length * 4).order(ByteOrder.nativeOrder())
                 .asFloatBuffer();
         setRotation(Rotation.NORMAL, false, false);
     }
@@ -120,12 +112,25 @@ public void onSurfaceDestroyed(GL10 gl) {
     @Override
     public void onDrawFrame(final GL10 gl) {
         GLES20.glClear(GLES20.GL_COLOR_BUFFER_BIT | GLES20.GL_DEPTH_BUFFER_BIT);
-        runAll(mRunOnDraw);
+        synchronized (mRunOnDraw) {
+            while (!mRunOnDraw.isEmpty()) {
+                mRunOnDraw.poll().run();
+            }
+        }
         mFilter.onDraw(mGLTextureId, mGLCubeBuffer, mGLTextureBuffer);
-        runAll(mRunOnDrawEnd);
         if (mSurfaceTexture != null) {
             mSurfaceTexture.updateTexImage();
         }
+        try {
+            if (image == null)
+                image = createBitmapFromGLSurface((mOutputWidth - mImageWidth) / 2, (mOutputHeight - mImageHeight) / 2,
+                        mImageWidth, mImageHeight, gl);
+            if (image != null)
+                if (callback != null)
+                    callback.callback(image);
+        } catch (Exception ex) {
+            image = null;
+        }
     }
 
     /**
@@ -159,8 +164,7 @@ public void onPreviewFrame(final byte[] data, final Camera camera) {
             runOnDraw(new Runnable() {
                 @Override
                 public void run() {
-                    GPUImageNativeLibrary.YUVtoRBGA(data, previewSize.width, previewSize.height,
-                            mGLRgbBuffer.array());
+                    GPUImageNativeLibrary.YUVtoRBGA(data, previewSize.width, previewSize.height, mGLRgbBuffer.array());
                     mGLTextureId = OpenGlUtils.loadTexture(mGLRgbBuffer, previewSize, mGLTextureId);
                     camera.addCallbackBuffer(data);
 
@@ -214,9 +218,7 @@ public void deleteImage() {
 
             @Override
             public void run() {
-                GLES20.glDeleteTextures(1, new int[]{
-                        mGLTextureId
-                }, 0);
+                GLES20.glDeleteTextures(1, new int[] { mGLTextureId }, 0);
                 mGLTextureId = NO_IMAGE;
             }
         });
@@ -247,8 +249,8 @@ public void run() {
                     mAddedPadding = 0;
                 }
 
-                mGLTextureId = OpenGlUtils.loadTexture(
-                        resizedBitmap != null ? resizedBitmap : bitmap, mGLTextureId, recycle);
+                mGLTextureId = OpenGlUtils.loadTexture(resizedBitmap != null ? resizedBitmap : bitmap, mGLTextureId,
+                        recycle);
                 if (resizedBitmap != null) {
                     resizedBitmap.recycle();
                 }
@@ -293,19 +295,15 @@ private void adjustImageScaling() {
         if (mScaleType == GPUImage.ScaleType.CENTER_CROP) {
             float distHorizontal = (1 - 1 / ratioWidth) / 2;
             float distVertical = (1 - 1 / ratioHeight) / 2;
-            textureCords = new float[]{
-                    addDistance(textureCords[0], distHorizontal), addDistance(textureCords[1], distVertical),
-                    addDistance(textureCords[2], distHorizontal), addDistance(textureCords[3], distVertical),
-                    addDistance(textureCords[4], distHorizontal), addDistance(textureCords[5], distVertical),
-                    addDistance(textureCords[6], distHorizontal), addDistance(textureCords[7], distVertical),
-            };
+            textureCords = new float[] { addDistance(textureCords[0], distHorizontal),
+                    addDistance(textureCords[1], distVertical), addDistance(textureCords[2], distHorizontal),
+                    addDistance(textureCords[3], distVertical), addDistance(textureCords[4], distHorizontal),
+                    addDistance(textureCords[5], distVertical), addDistance(textureCords[6], distHorizontal),
+                    addDistance(textureCords[7], distVertical), };
         } else {
-            cube = new float[]{
-                    CUBE[0] / ratioHeight, CUBE[1] / ratioWidth,
-                    CUBE[2] / ratioHeight, CUBE[3] / ratioWidth,
-                    CUBE[4] / ratioHeight, CUBE[5] / ratioWidth,
-                    CUBE[6] / ratioHeight, CUBE[7] / ratioWidth,
-            };
+            cube = new float[] { CUBE[0] / ratioHeight, CUBE[1] / ratioWidth, CUBE[2] / ratioHeight,
+                    CUBE[3] / ratioWidth, CUBE[4] / ratioHeight, CUBE[5] / ratioWidth, CUBE[6] / ratioHeight,
+                    CUBE[7] / ratioWidth, };
         }
 
         mGLCubeBuffer.clear();
@@ -318,8 +316,7 @@ private float addDistance(float coordinate, float distance) {
         return coordinate == 0.0f ? distance : 1 - distance;
     }
 
-    public void setRotationCamera(final Rotation rotation, final boolean flipHorizontal,
-            final boolean flipVertical) {
+    public void setRotationCamera(final Rotation rotation, final boolean flipHorizontal, final boolean flipVertical) {
         setRotation(rotation, flipVertical, flipHorizontal);
     }
 
@@ -328,8 +325,7 @@ public void setRotation(final Rotation rotation) {
         adjustImageScaling();
     }
 
-    public void setRotation(final Rotation rotation,
-                            final boolean flipHorizontal, final boolean flipVertical) {
+    public void setRotation(final Rotation rotation, final boolean flipHorizontal, final boolean flipVertical) {
         mFlipHorizontal = flipHorizontal;
         mFlipVertical = flipVertical;
         setRotation(rotation);
@@ -358,4 +354,34 @@ protected void runOnDrawEnd(final Runnable runnable) {
             mRunOnDrawEnd.add(runnable);
         }
     }
+
+    protected Bitmap image;
+
+    public Bitmap createBitmapFromGLSurface(int x, int y, int w, int h, GL10 gl) throws OutOfMemoryError {
+
+        int bitmapBuffer[] = new int[w * h];
+        int bitmapSource[] = new int[w * h];
+        IntBuffer intBuffer = IntBuffer.wrap(bitmapBuffer);
+        intBuffer.position(0);
+
+        try {
+            gl.glReadPixels(x, y, w, h, GL10.GL_RGBA, GL10.GL_UNSIGNED_BYTE, intBuffer);
+            int offset1, offset2;
+            for (int i = 0; i < h; i++) {
+                offset1 = i * w;
+                offset2 = (h - i - 1) * w;
+                for (int j = 0; j < w; j++) {
+                    int texturePixel = bitmapBuffer[offset1 + j];
+                    int blue = (texturePixel >> 16) & 0xff;
+                    int red = (texturePixel << 16) & 0x00ff0000;
+                    int pixel = (texturePixel & 0xff00ff00) | red | blue;
+                    bitmapSource[offset2 + j] = pixel;
+                }
+            }
+        } catch (GLException e) {
+            return null;
+        }
+
+        return Bitmap.createBitmap(bitmapSource, w, h, Bitmap.Config.ARGB_8888);
+    }
 }
