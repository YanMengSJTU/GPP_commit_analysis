diff --git a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageFilterGroup.java b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageFilterGroup.java
index 10ea41ca..71f434c9 100644
--- a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageFilterGroup.java
+++ b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageFilterGroup.java
@@ -24,19 +24,38 @@
 import java.nio.ByteOrder;
 import java.nio.FloatBuffer;
 import java.util.ArrayList;
+import java.util.Collections;
+import java.util.Iterator;
 import java.util.List;
+import java.util.concurrent.atomic.AtomicBoolean;
 
 import static jp.co.cyberagent.android.gpuimage.GPUImageRenderer.CUBE;
 import static jp.co.cyberagent.android.gpuimage.util.TextureRotationUtil.TEXTURE_NO_ROTATION;
 
 /**
- * Resembles a filter that consists of multiple filters applied after each
- * other.
+ * Resembles a filter that consists of multiple filters applied after each other.
+ *
+ * Thread-safe via synchronization on {@link @mFilters}, this class's source of truth.
  */
 public class GPUImageFilterGroup extends GPUImageFilter {
 
+    /**
+     * Ordered collection of {@link GPUImageFilter} instances managed by this instance
+     */
     protected List<GPUImageFilter> mFilters;
+
+    /**
+     * Ordered collection of all root {@link GPUImageFilter} instances managed by this instance
+     * (i.e. including root nodes from nested {@link GPUImageFilterGroup} instances)
+     */
     protected List<GPUImageFilter> mMergedFilters;
+
+    /**
+     * Internal flag to indicate we need to rebuild mFrameBuffers and mFrameBufferTextures
+     * on the next draw (e.g. because mFilters membership changed).
+     */
+    private AtomicBoolean mFrameNeedsRefresh = new AtomicBoolean(false);
+
     private int[] mFrameBuffers;
     private int[] mFrameBufferTextures;
 
@@ -59,7 +78,7 @@ public GPUImageFilterGroup() {
     public GPUImageFilterGroup(List<GPUImageFilter> filters) {
         mFilters = filters;
         if (mFilters == null) {
-            mFilters = new ArrayList<GPUImageFilter>();
+            mFilters = new ArrayList<>();
         } else {
             updateMergedFilters();
         }
@@ -85,8 +104,10 @@ public void addFilter(GPUImageFilter aFilter) {
         if (aFilter == null) {
             return;
         }
-        mFilters.add(aFilter);
-        updateMergedFilters();
+        synchronized (mFilters) {
+            mFilters.add(aFilter);
+            updateMergedFilters();
+        }
     }
 
     /*
@@ -96,8 +117,10 @@ public void addFilter(GPUImageFilter aFilter) {
     @Override
     public void onInit() {
         super.onInit();
-        for (GPUImageFilter filter : mFilters) {
-            filter.init();
+        synchronized (mFilters) {
+            for (GPUImageFilter filter : mFilters) {
+                filter.init();
+            }
         }
     }
 
@@ -107,21 +130,25 @@ public void onInit() {
      */
     @Override
     public void onDestroy() {
-        destroyFramebuffers();
-        for (GPUImageFilter filter : mFilters) {
-            filter.destroy();
+        synchronized (mFilters) {
+            destroyFramebuffers();
+            for (GPUImageFilter filter : mFilters) {
+                filter.destroy();
+            }
         }
         super.onDestroy();
     }
 
     private void destroyFramebuffers() {
-        if (mFrameBufferTextures != null) {
-            GLES20.glDeleteTextures(mFrameBufferTextures.length, mFrameBufferTextures, 0);
-            mFrameBufferTextures = null;
-        }
-        if (mFrameBuffers != null) {
-            GLES20.glDeleteFramebuffers(mFrameBuffers.length, mFrameBuffers, 0);
-            mFrameBuffers = null;
+        synchronized (mFilters) {
+            if (mFrameBufferTextures != null) {
+                GLES20.glDeleteTextures(mFrameBufferTextures.length, mFrameBufferTextures, 0);
+                mFrameBufferTextures = null;
+            }
+            if (mFrameBuffers != null) {
+                GLES20.glDeleteFramebuffers(mFrameBuffers.length, mFrameBuffers, 0);
+                mFrameBuffers = null;
+            }
         }
     }
 
@@ -134,42 +161,12 @@ private void destroyFramebuffers() {
     @Override
     public void onOutputSizeChanged(final int width, final int height) {
         super.onOutputSizeChanged(width, height);
-        if (mFrameBuffers != null) {
-            destroyFramebuffers();
-        }
-
-        int size = mFilters.size();
-        for (int i = 0; i < size; i++) {
-            mFilters.get(i).onOutputSizeChanged(width, height);
-        }
-
-        if (mMergedFilters != null && mMergedFilters.size() > 0) {
-            size = mMergedFilters.size();
-            mFrameBuffers = new int[size - 1];
-            mFrameBufferTextures = new int[size - 1];
-
-            for (int i = 0; i < size - 1; i++) {
-                GLES20.glGenFramebuffers(1, mFrameBuffers, i);
-                GLES20.glGenTextures(1, mFrameBufferTextures, i);
-                GLES20.glBindTexture(GLES20.GL_TEXTURE_2D, mFrameBufferTextures[i]);
-                GLES20.glTexImage2D(GLES20.GL_TEXTURE_2D, 0, GLES20.GL_RGBA, width, height, 0,
-                        GLES20.GL_RGBA, GLES20.GL_UNSIGNED_BYTE, null);
-                GLES20.glTexParameterf(GLES20.GL_TEXTURE_2D,
-                        GLES20.GL_TEXTURE_MAG_FILTER, GLES20.GL_LINEAR);
-                GLES20.glTexParameterf(GLES20.GL_TEXTURE_2D,
-                        GLES20.GL_TEXTURE_MIN_FILTER, GLES20.GL_LINEAR);
-                GLES20.glTexParameterf(GLES20.GL_TEXTURE_2D,
-                        GLES20.GL_TEXTURE_WRAP_S, GLES20.GL_CLAMP_TO_EDGE);
-                GLES20.glTexParameterf(GLES20.GL_TEXTURE_2D,
-                        GLES20.GL_TEXTURE_WRAP_T, GLES20.GL_CLAMP_TO_EDGE);
-
-                GLES20.glBindFramebuffer(GLES20.GL_FRAMEBUFFER, mFrameBuffers[i]);
-                GLES20.glFramebufferTexture2D(GLES20.GL_FRAMEBUFFER, GLES20.GL_COLOR_ATTACHMENT0,
-                        GLES20.GL_TEXTURE_2D, mFrameBufferTextures[i], 0);
-
-                GLES20.glBindTexture(GLES20.GL_TEXTURE_2D, 0);
-                GLES20.glBindFramebuffer(GLES20.GL_FRAMEBUFFER, 0);
+        synchronized (mFilters) {
+            for (int i = 0; i < mFilters.size(); i++) {
+                mFilters.get(i).onOutputSizeChanged(width, height);
             }
+            // Trigger texture updates on the next draw to guarantee thread owns the OpenGL context
+            mFrameNeedsRefresh.getAndSet(true);
         }
     }
 
@@ -182,72 +179,133 @@ public void onOutputSizeChanged(final int width, final int height) {
     @Override
     public void onDraw(final int textureId, final FloatBuffer cubeBuffer,
                        final FloatBuffer textureBuffer) {
-        runPendingOnDrawTasks();
-        if (!isInitialized() || mFrameBuffers == null || mFrameBufferTextures == null) {
+        if (!isInitialized()){
             return;
         }
-        if (mMergedFilters != null) {
-            int size = mMergedFilters.size();
-            int previousTexture = textureId;
-            for (int i = 0; i < size; i++) {
-                GPUImageFilter filter = mMergedFilters.get(i);
-                boolean isNotLast = i < size - 1;
-                if (isNotLast) {
-                    GLES20.glBindFramebuffer(GLES20.GL_FRAMEBUFFER, mFrameBuffers[i]);
-                    GLES20.glClearColor(0, 0, 0, 0);
+        runPendingOnDrawTasks();
+        synchronized (mFilters) {
+            if (mFrameNeedsRefresh.getAndSet(false)) {
+                if (mFrameBuffers != null) {
+                    destroyFramebuffers();
                 }
+                if (mMergedFilters != null && mMergedFilters.size() > 0) {
+                    int size = mMergedFilters.size();
+                    mFrameBuffers = new int[size - 1];
+                    mFrameBufferTextures = new int[size - 1];
+                    for (GPUImageFilter gpuImageFilter : mMergedFilters) {
+                        for (int i = 0; i < size - 1; i++) {
+                            GLES20.glGenFramebuffers(1, mFrameBuffers, i);
+                            GLES20.glGenTextures(1, mFrameBufferTextures, i);
+                            GLES20.glBindTexture(GLES20.GL_TEXTURE_2D, mFrameBufferTextures[i]);
+                            GLES20.glTexImage2D(GLES20.GL_TEXTURE_2D, 0, GLES20.GL_RGBA,
+                                    gpuImageFilter.getOutputWidth(),
+                                    gpuImageFilter.getOutputHeight(),
+                                    0, GLES20.GL_RGBA, GLES20.GL_UNSIGNED_BYTE, null);
+                            GLES20.glTexParameterf(GLES20.GL_TEXTURE_2D,
+                                    GLES20.GL_TEXTURE_MAG_FILTER, GLES20.GL_LINEAR);
+                            GLES20.glTexParameterf(GLES20.GL_TEXTURE_2D,
+                                    GLES20.GL_TEXTURE_MIN_FILTER, GLES20.GL_LINEAR);
+                            GLES20.glTexParameterf(GLES20.GL_TEXTURE_2D,
+                                    GLES20.GL_TEXTURE_WRAP_S, GLES20.GL_CLAMP_TO_EDGE);
+                            GLES20.glTexParameterf(GLES20.GL_TEXTURE_2D,
+                                    GLES20.GL_TEXTURE_WRAP_T, GLES20.GL_CLAMP_TO_EDGE);
+
+                            GLES20.glBindFramebuffer(GLES20.GL_FRAMEBUFFER, mFrameBuffers[i]);
+                            GLES20.glFramebufferTexture2D(GLES20.GL_FRAMEBUFFER, GLES20.GL_COLOR_ATTACHMENT0,
+                                    GLES20.GL_TEXTURE_2D, mFrameBufferTextures[i], 0);
 
-                if (i == 0) {
-                    filter.onDraw(previousTexture, cubeBuffer, textureBuffer);
-                } else if (i == size - 1) {
-                    filter.onDraw(previousTexture, mGLCubeBuffer, (size % 2 == 0) ? mGLTextureFlipBuffer : mGLTextureBuffer);
-                } else {
-                    filter.onDraw(previousTexture, mGLCubeBuffer, mGLTextureBuffer);
+                            GLES20.glBindTexture(GLES20.GL_TEXTURE_2D, 0);
+                            GLES20.glBindFramebuffer(GLES20.GL_FRAMEBUFFER, 0);
+                        }
+                    }
                 }
+            }
+            if (mFrameBuffers == null || mFrameBufferTextures == null) {
+                // No textures to draw
+                return;
+            }
+            // Draw the texture for each filter
+            if (mMergedFilters != null) {
+                Iterator<GPUImageFilter> filterIterator = mMergedFilters.iterator();
+                boolean first = true;
+                boolean last;
+                int previousTexture = textureId;
+                int size = mMergedFilters.size();
+                int i = 0;
+                while (filterIterator.hasNext()) {
+                    GPUImageFilter filter = filterIterator.next();
+                    last = filterIterator.hasNext() == false;
+                    if (!last) {
+                        GLES20.glBindFramebuffer(GLES20.GL_FRAMEBUFFER, mFrameBuffers[i]);
+                        GLES20.glClearColor(0, 0, 0, 0);
+                    }
+
+                    if (first) {
+                        filter.onDraw(previousTexture, cubeBuffer, textureBuffer);
+                        first = false;
+                    } else if (last) {
+                        filter.onDraw(previousTexture, mGLCubeBuffer, (size % 2 == 0) ? mGLTextureFlipBuffer : mGLTextureBuffer);
+                    } else {
+                        filter.onDraw(previousTexture, mGLCubeBuffer, mGLTextureBuffer);
+                    }
 
-                if (isNotLast) {
-                    GLES20.glBindFramebuffer(GLES20.GL_FRAMEBUFFER, 0);
-                    previousTexture = mFrameBufferTextures[i];
+                    if (!last) {
+                        GLES20.glBindFramebuffer(GLES20.GL_FRAMEBUFFER, 0);
+                        previousTexture = mFrameBufferTextures[i];
+                    }
+                    i++;
                 }
             }
         }
      }
 
     /**
-     * Gets the filters.
+     * Safely get the filter at index.
      *
-     * @return the filters
+     * @return null if index is out of bounds
      */
-    public List<GPUImageFilter> getFilters() {
-        return mFilters;
+    protected GPUImageFilter getFilter(int index) {
+        synchronized (mFilters) {
+            if (mFilters == null || index < 0 || index >= mFilters.size()) {
+                return null;
+            }
+            return mFilters.get(index);
+        }
     }
 
-    public List<GPUImageFilter> getMergedFilters() {
-        return mMergedFilters;
+    /**
+     * @return an unmodifiable copy of mMergedFilters (unmodifiable to preserve thread safety)
+     */
+    protected List<GPUImageFilter> getMergedFilters() {
+        return Collections.unmodifiableList(mMergedFilters);
     }
 
-    public void updateMergedFilters() {
-        if (mFilters == null) {
-            return;
-        }
+    private void updateMergedFilters() {
+        synchronized (mFilters) {
+            if (mFilters == null) {
+                return;
+            }
 
-        if (mMergedFilters == null) {
-            mMergedFilters = new ArrayList<GPUImageFilter>();
-        } else {
-            mMergedFilters.clear();
-        }
+            if (mMergedFilters == null) {
+                mMergedFilters = new ArrayList<GPUImageFilter>();
+            } else {
+                mMergedFilters.clear();
+            }
 
-        List<GPUImageFilter> filters;
-        for (GPUImageFilter filter : mFilters) {
-            if (filter instanceof GPUImageFilterGroup) {
-                ((GPUImageFilterGroup) filter).updateMergedFilters();
-                filters = ((GPUImageFilterGroup) filter).getMergedFilters();
-                if (filters == null || filters.isEmpty())
+            List<GPUImageFilter> filters;
+            for (GPUImageFilter filter : mFilters) {
+                if (filter instanceof GPUImageFilterGroup) {
+                    ((GPUImageFilterGroup) filter).updateMergedFilters();
+                    filters = ((GPUImageFilterGroup) filter).getMergedFilters();
+                    if (filters == null || filters.isEmpty())
+                        continue;
+                    mMergedFilters.addAll(filters);
                     continue;
-                mMergedFilters.addAll(filters);
-                continue;
+                }
+                mMergedFilters.add(filter);
             }
-            mMergedFilters.add(filter);
+            // Trigger texture updates on the next draw to guarantee thread owns the OpenGL context
+            mFrameNeedsRefresh.getAndSet(true);
         }
     }
 }
diff --git a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageSmoothToonFilter.java b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageSmoothToonFilter.java
index a569ce97..f7f3265f 100644
--- a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageSmoothToonFilter.java
+++ b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageSmoothToonFilter.java
@@ -38,7 +38,7 @@ public GPUImageSmoothToonFilter() {
         toonFilter = new GPUImageToonFilter();
         addFilter(toonFilter);
 
-        getFilters().add(blurFilter);
+        addFilter(blurFilter);
 
         setBlurSize(0.5f);
         setThreshold(0.2f);
diff --git a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageSobelEdgeDetection.java b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageSobelEdgeDetection.java
index 2a775d48..0651d742 100644
--- a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageSobelEdgeDetection.java
+++ b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageSobelEdgeDetection.java
@@ -65,6 +65,6 @@ public GPUImageSobelEdgeDetection() {
     }
 
     public void setLineSize(final float size) {
-        ((GPUImage3x3TextureSamplingFilter) getFilters().get(1)).setLineSize(size);
+        ((GPUImage3x3TextureSamplingFilter) getFilter(1)).setLineSize(size);
     }
 }
diff --git a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageThresholdEdgeDetection.java b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageThresholdEdgeDetection.java
index c136155a..57e265ef 100644
--- a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageThresholdEdgeDetection.java
+++ b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageThresholdEdgeDetection.java
@@ -11,10 +11,10 @@ public GPUImageThresholdEdgeDetection() {
     }
 
     public void setLineSize(final float size) {
-        ((GPUImage3x3TextureSamplingFilter) getFilters().get(1)).setLineSize(size);
+        ((GPUImage3x3TextureSamplingFilter) getFilter(1)).setLineSize(size);
     }
 
     public void setThreshold(final float threshold) {
-        ((GPUImageSobelThresholdFilter) getFilters().get(1)).setThreshold(threshold);
+        ((GPUImageSobelThresholdFilter) getFilter(1)).setThreshold(threshold);
     }
 }
