diff --git a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageGaussianBlurFilter.java b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageGaussianBlurFilter.java
index bf5b92ad..3625a486 100644
--- a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageGaussianBlurFilter.java
+++ b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageGaussianBlurFilter.java
@@ -38,20 +38,21 @@ private static String vertexShaderForStandardBlurOfRadius(final int radius, fina
                 "\n" +
                 "void main()\n" +
                 "{\n" +
-                "    gl_Position = position;\n" +
+                "	gl_Position = position;\n" +
+                "	\n" +
+//            "	// Calculate the positions for the blur\n" +
+                "	int multiplier = 0;\n" +
+                "   vec2 blurStep;\n" +
+                "   vec2 singleStepOffset = vec2(texelHeightOffset, texelWidthOffset);\n" +
                 "    \n" +
-                "    vec2 singleStepOffset = vec2(texelWidthOffset, texelHeightOffset);\n";
-        for (int i = 0; i < samples; ++i) {
-            int offsetFromCenter = i - radius;
-            shaderString += "    blurCoordinates[" + i + "] = inputTextureCoordinate.xy";
-            if (0 > offsetFromCenter) {
-                shaderString += " - singleStepOffset * " + (float) -offsetFromCenter;
-            } else if (0 < offsetFromCenter) {
-                shaderString += " + singleStepOffset * " + (float) offsetFromCenter;
-            }
-            shaderString += ";\n";
-        }
-        shaderString += "}\n";
+                "	for (int i = 0; i < SAMPLES; i++)\n" +
+                "   {\n" +
+                "		multiplier = (i - ((SAMPLES - 1) / 2));\n" +
+//            "       // Blur in x (horizontal)\n" +
+                "       blurStep = float(multiplier) * singleStepOffset;\n" +
+                "		blurCoordinates[i] = inputTextureCoordinate.xy + blurStep;\n" +
+                "	}\n" +
+                "}\n";
         return shaderString;
     }
 
@@ -60,9 +61,39 @@ private static String fragmentShaderForStandardBlurOfRadius(final int radius, fi
             return NO_FILTER_FRAGMENT_SHADER;
         }
         // First, generate the normal Gaussian weights for a given sigma
+        final int samples = radius * 2+ 1;
+        String shaderString =
+                "uniform sampler2D inputImageTexture;\n" +
+                "const int SAMPLES = " + samples + ";\n" +
+                "varying vec2 blurCoordinates[SAMPLES];\n" +
+                "uniform float blurWeights[" + (samples) +  "];\n" +
+                "void main() {\n" +
+                "    lowp vec4 sum = vec4(0.0);\n" +
+                "    for (int i = 0; i < SAMPLES; ++i) {\n" +
+                "        sum += texture2D(inputImageTexture, blurCoordinates[i]) * blurWeights[i];\n" +
+                "    }\n" +
+                "    gl_FragColor = sum;\n" +
+                "}\n";
+//        for (i = 0; i < samples; ++i) {
+//            int offsetFromCenter = i - radius;
+//            shaderString += "    sum += texture2D(inputImageTexture, blurCoordinates[" + i + "]) * ";
+//            if (0 > offsetFromCenter) {
+//                shaderString += standardGaussianWeights[-offsetFromCenter];
+//            } else {
+//                shaderString += standardGaussianWeights[ offsetFromCenter];
+//            }
+//            shaderString += ";\n";
+//        }
+//        shaderString +=
+//                "    gl_FragColor = sum;\n" +
+//                "}\n";
+        return shaderString;
+    }
+
+    private static float[] fragmentWeightsForStandardBlurOfRadius(final int radius, final float sigma) {
         int i;
-        final int weights = radius + 1;
         final int samples = radius * 2+ 1;
+        final int weights = radius + 1;
         float sumOfWeights = 0.0f;
         float standardGaussianWeights[] = new float[weights];
         for (i = 0; i < weights; ++i) {
@@ -76,29 +107,19 @@ private static String fragmentShaderForStandardBlurOfRadius(final int radius, fi
         for (i = 0; i < weights; ++i) {
             standardGaussianWeights[i] = standardGaussianWeights[i] / sumOfWeights;
         }
-        String shaderString =
-                "uniform sampler2D inputImageTexture;\n" +
-                "varying highp vec2 blurCoordinates[" + samples + "];\n" +
-                "void main() {\n" +
-                "    lowp vec4 sum = vec4(0.0);\n";
+        float result[] = new float[samples];
         for (i = 0; i < samples; ++i) {
-            int offsetFromCenter = i - radius;
-            shaderString += "    sum += texture2D(inputImageTexture, blurCoordinates[" + i + "]) * ";
-            if (0 > offsetFromCenter) {
-                shaderString += standardGaussianWeights[-offsetFromCenter];
-            } else {
-                shaderString += standardGaussianWeights[ offsetFromCenter];
-            }
-            shaderString += ";\n";
+            int id = i - radius;
+            result[i] = standardGaussianWeights[0 > id ? -id : id];
         }
-        shaderString +=
-                "    gl_FragColor = sum;\n" +
-                "}\n";
-        return shaderString;
+        return result;
     }
 
     protected float mBlurSize = 1f;
     protected int mRadiusInPixel = 2;
+    private float mWeights[];
+    private int mWeightsLocation0;
+    private int mWeightsLocation1;
 
     public GPUImageGaussianBlurFilter() {
         this(1.0f, 2);
@@ -111,24 +132,23 @@ public GPUImageGaussianBlurFilter(float blurSize, int radiusInPixel) {
             fragmentShaderForStandardBlurOfRadius(4, 2.0f));
         mBlurSize = blurSize;
         mRadiusInPixel = radiusInPixel;
+        mWeights = fragmentWeightsForStandardBlurOfRadius(4, 2.0f);
     }
 
-//    @Override
-//    public void onInit() {
-//        super.onInit();
-//        GPUImageFilter filter = mFilters.get(1);
-//        mAspectRatioLocation = GLES20.glGetUniformLocation(filter.getProgram(), "aspectRatio");
-//        mCenterLocation = GLES20.glGetUniformLocation(filter.getProgram(), "blurCenter");
-//        mRadiusLocation = GLES20.glGetUniformLocation(filter.getProgram(), "blurRadius");
-//    }
-//
-//    @Override
-//    public void onInitialized() {
-//        super.onInitialized();
-//        setCenter(mCenter);
-//        setRadius(mRadius);
-//        setAspectRatio(1.0f);
-//    }
+    @Override
+    public void onInit() {
+        super.onInit();
+        GPUImageFilter filter = mFilters.get(0);
+        mWeightsLocation0 = GLES20.glGetUniformLocation(filter.getProgram(), "blurWeights");
+        filter = mFilters.get(1);
+        mWeightsLocation1 = GLES20.glGetUniformLocation(filter.getProgram(), "blurWeights");
+    }
+
+    @Override
+    public void onInitialized() {
+        super.onInitialized();
+        setWeights(mWeights);
+    }
 
     @Override
     public float getVerticalTexelOffsetRatio() {
@@ -155,6 +175,14 @@ public void run() {
         });
     }
 
+    public void setWeights(final float weights[]) {
+        mWeights = weights;
+        GPUImageFilter filter = mFilters.get(0);
+        filter.setFloatArray(mWeightsLocation0, mWeights);
+        filter = mFilters.get(1);
+        filter.setFloatArray(mWeightsLocation1, mWeights);
+    }
+
 //    public void setAspectRatio(final float aspectRatio) {
 //        mAspectRatio = aspectRatio;
 //        setFloat(mAspectRatioLocation, mAspectRatio);
@@ -199,6 +227,11 @@ public void run() {
                 }
                 updateMergedFilters();
                 initTexelOffsets();
+                GPUImageFilter filter = mFilters.get(0);
+                mWeightsLocation0 = GLES20.glGetUniformLocation(filter.getProgram(), "blurWeights");
+                filter = mFilters.get(1);
+                mWeightsLocation1 = GLES20.glGetUniformLocation(filter.getProgram(), "blurWeights");
+                setWeights(fragmentWeightsForStandardBlurOfRadius(sampleRadius, radiusInPixel));
 //                init();
 //                GLES20.glUseProgram(getProgram());
 
