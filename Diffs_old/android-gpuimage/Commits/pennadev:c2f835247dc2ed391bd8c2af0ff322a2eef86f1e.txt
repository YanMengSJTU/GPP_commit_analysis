diff --git a/library/.classpath b/library/.classpath
index a4763d1e..6245d2cd 100644
--- a/library/.classpath
+++ b/library/.classpath
@@ -1,8 +1,11 @@
 <?xml version="1.0" encoding="UTF-8"?>
 <classpath>
+	<classpathentry kind="con" path="com.android.ide.eclipse.adt.ANDROID_FRAMEWORK"/>
+	<classpathentry exported="true" kind="con" path="com.android.ide.eclipse.adt.LIBRARIES"/>
 	<classpathentry kind="src" path="src"/>
 	<classpathentry kind="src" path="gen"/>
-	<classpathentry kind="con" path="com.android.ide.eclipse.adt.ANDROID_FRAMEWORK"/>
-	<classpathentry kind="con" path="com.android.ide.eclipse.adt.LIBRARIES"/>
+	<classpathentry exported="true" kind="con" path="com.android.ide.eclipse.adt.DEPENDENCIES"/>
+	<classpathentry kind="lib" path="libs/javacv.jar"/>
+	<classpathentry kind="lib" path="libs/javacpp.jar"/>
 	<classpathentry kind="output" path="bin/classes"/>
 </classpath>
diff --git a/library/libs/armeabi/libavcodec.so b/library/libs/armeabi/libavcodec.so
new file mode 100644
index 00000000..3892861a
Binary files /dev/null and b/library/libs/armeabi/libavcodec.so differ
diff --git a/library/libs/armeabi/libavdevice.so b/library/libs/armeabi/libavdevice.so
new file mode 100644
index 00000000..d00033a8
Binary files /dev/null and b/library/libs/armeabi/libavdevice.so differ
diff --git a/library/libs/armeabi/libavfilter.so b/library/libs/armeabi/libavfilter.so
new file mode 100644
index 00000000..b1ed5b81
Binary files /dev/null and b/library/libs/armeabi/libavfilter.so differ
diff --git a/library/libs/armeabi/libavformat.so b/library/libs/armeabi/libavformat.so
new file mode 100644
index 00000000..9ac8fd7b
Binary files /dev/null and b/library/libs/armeabi/libavformat.so differ
diff --git a/library/libs/armeabi/libavutil.so b/library/libs/armeabi/libavutil.so
new file mode 100644
index 00000000..75f690c8
Binary files /dev/null and b/library/libs/armeabi/libavutil.so differ
diff --git a/library/libs/armeabi/libjniARToolKitPlus.so b/library/libs/armeabi/libjniARToolKitPlus.so
new file mode 100644
index 00000000..0ecf208a
Binary files /dev/null and b/library/libs/armeabi/libjniARToolKitPlus.so differ
diff --git a/library/libs/armeabi/libjniavcodec.so b/library/libs/armeabi/libjniavcodec.so
new file mode 100644
index 00000000..cde6c078
Binary files /dev/null and b/library/libs/armeabi/libjniavcodec.so differ
diff --git a/library/libs/armeabi/libjniavdevice.so b/library/libs/armeabi/libjniavdevice.so
new file mode 100644
index 00000000..2821e43a
Binary files /dev/null and b/library/libs/armeabi/libjniavdevice.so differ
diff --git a/library/libs/armeabi/libjniavfilter.so b/library/libs/armeabi/libjniavfilter.so
new file mode 100644
index 00000000..7441084a
Binary files /dev/null and b/library/libs/armeabi/libjniavfilter.so differ
diff --git a/library/libs/armeabi/libjniavformat.so b/library/libs/armeabi/libjniavformat.so
new file mode 100644
index 00000000..dccc94a5
Binary files /dev/null and b/library/libs/armeabi/libjniavformat.so differ
diff --git a/library/libs/armeabi/libjniavutil.so b/library/libs/armeabi/libjniavutil.so
new file mode 100644
index 00000000..7f29a489
Binary files /dev/null and b/library/libs/armeabi/libjniavutil.so differ
diff --git a/library/libs/armeabi/libjnicvkernels.so b/library/libs/armeabi/libjnicvkernels.so
new file mode 100644
index 00000000..494a6ade
Binary files /dev/null and b/library/libs/armeabi/libjnicvkernels.so differ
diff --git a/library/libs/armeabi/libjniopencv_calib3d.so b/library/libs/armeabi/libjniopencv_calib3d.so
new file mode 100644
index 00000000..4f697ecb
Binary files /dev/null and b/library/libs/armeabi/libjniopencv_calib3d.so differ
diff --git a/library/libs/armeabi/libjniopencv_contrib.so b/library/libs/armeabi/libjniopencv_contrib.so
new file mode 100644
index 00000000..5078489c
Binary files /dev/null and b/library/libs/armeabi/libjniopencv_contrib.so differ
diff --git a/library/libs/armeabi/libjniopencv_core.so b/library/libs/armeabi/libjniopencv_core.so
new file mode 100644
index 00000000..ef32d3a0
Binary files /dev/null and b/library/libs/armeabi/libjniopencv_core.so differ
diff --git a/library/libs/armeabi/libjniopencv_features2d.so b/library/libs/armeabi/libjniopencv_features2d.so
new file mode 100644
index 00000000..e1ca2ca0
Binary files /dev/null and b/library/libs/armeabi/libjniopencv_features2d.so differ
diff --git a/library/libs/armeabi/libjniopencv_flann.so b/library/libs/armeabi/libjniopencv_flann.so
new file mode 100644
index 00000000..2411695c
Binary files /dev/null and b/library/libs/armeabi/libjniopencv_flann.so differ
diff --git a/library/libs/armeabi/libjniopencv_highgui.so b/library/libs/armeabi/libjniopencv_highgui.so
new file mode 100644
index 00000000..5fd85b47
Binary files /dev/null and b/library/libs/armeabi/libjniopencv_highgui.so differ
diff --git a/library/libs/armeabi/libjniopencv_imgproc.so b/library/libs/armeabi/libjniopencv_imgproc.so
new file mode 100644
index 00000000..41c54159
Binary files /dev/null and b/library/libs/armeabi/libjniopencv_imgproc.so differ
diff --git a/library/libs/armeabi/libjniopencv_legacy.so b/library/libs/armeabi/libjniopencv_legacy.so
new file mode 100644
index 00000000..1caa317b
Binary files /dev/null and b/library/libs/armeabi/libjniopencv_legacy.so differ
diff --git a/library/libs/armeabi/libjniopencv_ml.so b/library/libs/armeabi/libjniopencv_ml.so
new file mode 100644
index 00000000..6e63a81b
Binary files /dev/null and b/library/libs/armeabi/libjniopencv_ml.so differ
diff --git a/library/libs/armeabi/libjniopencv_nonfree.so b/library/libs/armeabi/libjniopencv_nonfree.so
new file mode 100644
index 00000000..3ff80544
Binary files /dev/null and b/library/libs/armeabi/libjniopencv_nonfree.so differ
diff --git a/library/libs/armeabi/libjniopencv_objdetect.so b/library/libs/armeabi/libjniopencv_objdetect.so
new file mode 100644
index 00000000..bd9b8460
Binary files /dev/null and b/library/libs/armeabi/libjniopencv_objdetect.so differ
diff --git a/library/libs/armeabi/libjniopencv_photo.so b/library/libs/armeabi/libjniopencv_photo.so
new file mode 100644
index 00000000..61b08bd7
Binary files /dev/null and b/library/libs/armeabi/libjniopencv_photo.so differ
diff --git a/library/libs/armeabi/libjniopencv_stitching.so b/library/libs/armeabi/libjniopencv_stitching.so
new file mode 100644
index 00000000..1e5fcb13
Binary files /dev/null and b/library/libs/armeabi/libjniopencv_stitching.so differ
diff --git a/library/libs/armeabi/libjniopencv_video.so b/library/libs/armeabi/libjniopencv_video.so
new file mode 100644
index 00000000..cdba9227
Binary files /dev/null and b/library/libs/armeabi/libjniopencv_video.so differ
diff --git a/library/libs/armeabi/libjniopencv_videostab.so b/library/libs/armeabi/libjniopencv_videostab.so
new file mode 100644
index 00000000..ae08acb1
Binary files /dev/null and b/library/libs/armeabi/libjniopencv_videostab.so differ
diff --git a/library/libs/armeabi/libjnipostproc.so b/library/libs/armeabi/libjnipostproc.so
new file mode 100644
index 00000000..7b07ba8a
Binary files /dev/null and b/library/libs/armeabi/libjnipostproc.so differ
diff --git a/library/libs/armeabi/libjniswresample.so b/library/libs/armeabi/libjniswresample.so
new file mode 100644
index 00000000..216941b9
Binary files /dev/null and b/library/libs/armeabi/libjniswresample.so differ
diff --git a/library/libs/armeabi/libjniswscale.so b/library/libs/armeabi/libjniswscale.so
new file mode 100644
index 00000000..4c64b0c5
Binary files /dev/null and b/library/libs/armeabi/libjniswscale.so differ
diff --git a/library/libs/armeabi/libopencv_calib3d.so b/library/libs/armeabi/libopencv_calib3d.so
new file mode 100644
index 00000000..8a2a27f6
Binary files /dev/null and b/library/libs/armeabi/libopencv_calib3d.so differ
diff --git a/library/libs/armeabi/libopencv_contrib.so b/library/libs/armeabi/libopencv_contrib.so
new file mode 100644
index 00000000..bb60c9d1
Binary files /dev/null and b/library/libs/armeabi/libopencv_contrib.so differ
diff --git a/library/libs/armeabi/libopencv_core.so b/library/libs/armeabi/libopencv_core.so
new file mode 100644
index 00000000..ab54cfc5
Binary files /dev/null and b/library/libs/armeabi/libopencv_core.so differ
diff --git a/library/libs/armeabi/libopencv_features2d.so b/library/libs/armeabi/libopencv_features2d.so
new file mode 100644
index 00000000..7d7e9d06
Binary files /dev/null and b/library/libs/armeabi/libopencv_features2d.so differ
diff --git a/library/libs/armeabi/libopencv_flann.so b/library/libs/armeabi/libopencv_flann.so
new file mode 100644
index 00000000..eb6d1224
Binary files /dev/null and b/library/libs/armeabi/libopencv_flann.so differ
diff --git a/library/libs/armeabi/libopencv_gpu.so b/library/libs/armeabi/libopencv_gpu.so
new file mode 100644
index 00000000..23be5e16
Binary files /dev/null and b/library/libs/armeabi/libopencv_gpu.so differ
diff --git a/library/libs/armeabi/libopencv_highgui.so b/library/libs/armeabi/libopencv_highgui.so
new file mode 100644
index 00000000..0a5d60dc
Binary files /dev/null and b/library/libs/armeabi/libopencv_highgui.so differ
diff --git a/library/libs/armeabi/libopencv_imgproc.so b/library/libs/armeabi/libopencv_imgproc.so
new file mode 100644
index 00000000..fe43bbde
Binary files /dev/null and b/library/libs/armeabi/libopencv_imgproc.so differ
diff --git a/library/libs/armeabi/libopencv_info.so b/library/libs/armeabi/libopencv_info.so
new file mode 100644
index 00000000..bbe29ec1
Binary files /dev/null and b/library/libs/armeabi/libopencv_info.so differ
diff --git a/library/libs/armeabi/libopencv_legacy.so b/library/libs/armeabi/libopencv_legacy.so
new file mode 100644
index 00000000..ee4927ef
Binary files /dev/null and b/library/libs/armeabi/libopencv_legacy.so differ
diff --git a/library/libs/armeabi/libopencv_ml.so b/library/libs/armeabi/libopencv_ml.so
new file mode 100644
index 00000000..ca57fdd5
Binary files /dev/null and b/library/libs/armeabi/libopencv_ml.so differ
diff --git a/library/libs/armeabi/libopencv_nonfree.so b/library/libs/armeabi/libopencv_nonfree.so
new file mode 100644
index 00000000..6a7e2361
Binary files /dev/null and b/library/libs/armeabi/libopencv_nonfree.so differ
diff --git a/library/libs/armeabi/libopencv_objdetect.so b/library/libs/armeabi/libopencv_objdetect.so
new file mode 100644
index 00000000..af39157e
Binary files /dev/null and b/library/libs/armeabi/libopencv_objdetect.so differ
diff --git a/library/libs/armeabi/libopencv_photo.so b/library/libs/armeabi/libopencv_photo.so
new file mode 100644
index 00000000..9277c4e2
Binary files /dev/null and b/library/libs/armeabi/libopencv_photo.so differ
diff --git a/library/libs/armeabi/libopencv_stitching.so b/library/libs/armeabi/libopencv_stitching.so
new file mode 100644
index 00000000..9f56e67b
Binary files /dev/null and b/library/libs/armeabi/libopencv_stitching.so differ
diff --git a/library/libs/armeabi/libopencv_video.so b/library/libs/armeabi/libopencv_video.so
new file mode 100644
index 00000000..9e30d72a
Binary files /dev/null and b/library/libs/armeabi/libopencv_video.so differ
diff --git a/library/libs/armeabi/libopencv_videostab.so b/library/libs/armeabi/libopencv_videostab.so
new file mode 100644
index 00000000..036ef3c4
Binary files /dev/null and b/library/libs/armeabi/libopencv_videostab.so differ
diff --git a/library/libs/armeabi/libpostproc.so b/library/libs/armeabi/libpostproc.so
new file mode 100644
index 00000000..b34d4ca6
Binary files /dev/null and b/library/libs/armeabi/libpostproc.so differ
diff --git a/library/libs/armeabi/libswresample.so b/library/libs/armeabi/libswresample.so
new file mode 100644
index 00000000..b0a8f1d1
Binary files /dev/null and b/library/libs/armeabi/libswresample.so differ
diff --git a/library/libs/armeabi/libswscale.so b/library/libs/armeabi/libswscale.so
new file mode 100644
index 00000000..893d8bd5
Binary files /dev/null and b/library/libs/armeabi/libswscale.so differ
diff --git a/library/libs/armeabi/libtbb.so b/library/libs/armeabi/libtbb.so
new file mode 100644
index 00000000..e0566af4
Binary files /dev/null and b/library/libs/armeabi/libtbb.so differ
diff --git a/library/libs/javacpp.jar b/library/libs/javacpp.jar
new file mode 100644
index 00000000..c15fa566
Binary files /dev/null and b/library/libs/javacpp.jar differ
diff --git a/library/libs/javacv.jar b/library/libs/javacv.jar
new file mode 100644
index 00000000..119ef143
Binary files /dev/null and b/library/libs/javacv.jar differ
diff --git a/library/lint.xml b/library/lint.xml
new file mode 100644
index 00000000..bbe34965
--- /dev/null
+++ b/library/lint.xml
@@ -0,0 +1,4 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<lint>
+    <issue id="WrongCall" severity="ignore" />
+</lint>
\ No newline at end of file
diff --git a/library/project.properties b/library/project.properties
index dfa4dd09..484dab07 100644
--- a/library/project.properties
+++ b/library/project.properties
@@ -11,5 +11,5 @@
 #proguard.config=${sdk.dir}/tools/proguard/proguard-android.txt:proguard-project.txt
 
 # Project target.
-target=android-16
+target=android-17
 android.library=true
diff --git a/library/src/com/hypersense/gpuimage/VideoEffect.java b/library/src/com/hypersense/gpuimage/VideoEffect.java
new file mode 100644
index 00000000..fd80a77d
--- /dev/null
+++ b/library/src/com/hypersense/gpuimage/VideoEffect.java
@@ -0,0 +1,198 @@
+package com.hypersense.gpuimage;
+
+import static com.googlecode.javacv.cpp.opencv_core.IPL_DEPTH_8U;
+
+import java.io.File;
+import java.nio.ByteBuffer;
+import java.util.ArrayList;
+
+import jp.co.cyberagent.android.gpuimage.GPUImage;
+
+import android.graphics.Bitmap;
+import android.graphics.BitmapFactory;
+
+import com.googlecode.javacv.FFmpegFrameGrabber;
+import com.googlecode.javacv.FFmpegFrameRecorder;
+import com.googlecode.javacv.Frame;
+import com.googlecode.javacv.FrameGrabber.Exception;
+import com.googlecode.javacv.cpp.avcodec.AVCodec;
+import com.googlecode.javacv.cpp.avcodec.AVCodecContext;
+import com.googlecode.javacv.cpp.opencv_core.IplImage;
+import com.googlecode.javacv.cpp.avcodec;
+import com.googlecode.javacv.cpp.avformat;
+import com.googlecode.javacv.cpp.opencv_core;
+import com.googlecode.javacv.cpp.opencv_imgproc;
+
+/**
+ * Applies video effects, handles frame extraction, GPU rendering via
+ * BitmapEffectManager and and re-encoding <br>
+ * -Must be created in the same thread as the BitmapEffectManager<br>
+ * -Has native ffmpeg handles, it requires one instance per video file<br>
+ * -After processVideo finishes object must be manually released via stop()<br>
+ */
+public class VideoEffect {
+
+	public ArrayList<Frame> frames = new ArrayList<Frame>();
+	FFmpegFrameGrabber frameGrabber;
+
+	public int width, height;
+	public int audioChannels;
+	public String outputFileName;
+	private FFmpegFrameRecorder recorder;
+	private boolean started = false;
+
+	/**
+	 * 
+	 * @param sourceFilePath
+	 *            source video file path
+	 * @param outputFilePath
+	 *            output video file path
+	 */
+	public VideoEffect(String sourceFilePath, String outputFilePath) {
+		frameGrabber = new FFmpegFrameGrabber(sourceFilePath);
+		this.outputFileName = outputFilePath;
+	}
+
+	/**
+	 * Lazy init function, sets up ffmpeg codec backends
+	 */
+	public void start() {
+		try {
+			frameGrabber.setFormat("mp4");
+			frameGrabber.start();
+			height = frameGrabber.getImageHeight();
+			width = frameGrabber.getImageWidth();
+			audioChannels = frameGrabber.getAudioChannels();
+			recorder = new FFmpegFrameRecorder(outputFileName, width, height);
+			recorder.setAudioChannels(audioChannels);
+			recorder.start();
+			started = true;
+		} catch (Exception e) {
+			e.printStackTrace();
+		} catch (com.googlecode.javacv.FrameRecorder.Exception e) {
+			e.printStackTrace();
+		}
+	}
+
+	/**
+	 * Extracts frames, applies effects via the BitmapEffectManager, and
+	 * re-encodes the video to outputFileName
+	 * 
+	 * @param bfm
+	 *            the effect manager, this must have an active effect and MUST
+	 *            be called on the same thread as the BitmapEffectManager
+	 * @return true if the process completed, false otherwise
+	 */
+	public boolean processVideo(GPUImage bfm) {
+		if (!started) {
+			start();
+		}
+
+		while (true) {
+			Frame frame = getNextFrame();
+			//
+			if (frame == null) {
+				try {
+					recorder.stop();
+					recorder.release();
+				} catch (com.googlecode.javacv.FrameRecorder.Exception e) {
+					// TODO Auto-generated catch block
+					e.printStackTrace();
+					return false;
+				}
+				return true;
+			}
+
+			if (frame.image != null) {
+				Bitmap bitmap = Bitmap.createBitmap(width, height,
+						Bitmap.Config.ARGB_8888);
+
+				frame.image.getByteBuffer();
+				bitmap.copyPixelsFromBuffer(frame.image.getByteBuffer());
+				bfm.setImage(bitmap);
+				
+				
+				bitmap = bfm.getBitmapWithFilterApplied();
+
+				IplImage image = IplImage.create(bitmap.getWidth(),
+						bitmap.getHeight(), opencv_core.IPL_DEPTH_8U, 4);
+				bitmap.copyPixelsToBuffer(image.getByteBuffer());
+				try {
+					recorder.record(image);
+				} catch (com.googlecode.javacv.FrameRecorder.Exception e) {
+					e.printStackTrace();
+					return false;
+				} finally {
+					bitmap.recycle();
+				}
+
+			}
+			if (frame.samples != null) {
+				try {
+					recorder.record(frame.samples);
+				} catch (com.googlecode.javacv.FrameRecorder.Exception e) {
+					e.printStackTrace();
+					return false;
+				}
+			}
+		}
+	}
+
+	/**
+	 * Extracts and converts frame image to RGBA8888
+	 * 
+	 * @return extracted frame with correct pixel format
+	 */
+	public Frame getNextFrame() {
+		Frame frame = null;
+		try {
+			frame = frameGrabber.grabFrame();
+			if (frame == null) {
+				return null;
+			}
+			if (frame.image != null) {
+				System.out.println("Channels: "
+						+ frame.image.asCvMat().channels());
+				System.out.println("Depth: " + frame.image.asCvMat().depth());
+
+				/**
+				 * Convert to reasonable pixel format
+				 */
+				opencv_imgproc.cvCvtColor(frame.image, frame.image,
+						opencv_imgproc.CV_BGR2RGB);
+
+				IplImage rgbaImage = IplImage.create(width, height,
+						IPL_DEPTH_8U, 4);
+
+				opencv_imgproc.cvCvtColor(frame.image, rgbaImage,
+						opencv_imgproc.CV_RGB2RGBA);
+
+				frame.image = rgbaImage;
+				return frame;
+			} else {
+				return frame;
+			}
+		} catch (Exception e) {
+			e.printStackTrace();
+			try {
+				frameGrabber.stop();
+			} catch (Exception e1) {
+				e1.printStackTrace();
+			}
+			return null;
+		}
+	}
+
+	public void stop() throws com.googlecode.javacv.FrameRecorder.Exception {
+		try {
+			frameGrabber.stop();
+			recorder.stop();
+			recorder.release();
+			frameGrabber.release();
+		} catch (Exception e) {
+			// TODO Auto-generated catch block
+			e.printStackTrace();
+		}
+	}
+
+}
\ No newline at end of file
diff --git a/library/src/jp/co/cyberagent/android/gpuimage/GPUImage.java b/library/src/jp/co/cyberagent/android/gpuimage/GPUImage.java
index 06b65d4b..f48d0d32 100644
--- a/library/src/jp/co/cyberagent/android/gpuimage/GPUImage.java
+++ b/library/src/jp/co/cyberagent/android/gpuimage/GPUImage.java
@@ -654,7 +654,11 @@ private Bitmap rotateImage(final Bitmap bitmap) {
 
         protected abstract int getImageOrientation() throws IOException;
     }
-
+    
+    public GPUImageRenderer getRenderer() {
+    	return mRenderer;
+    }
+    
     public interface ResponseListener<T> {
         void response(T item);
     }
diff --git a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageRenderer.java b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageRenderer.java
index ac2e7c97..de93cb1e 100644
--- a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageRenderer.java
+++ b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageRenderer.java
@@ -41,286 +41,302 @@
 
 @TargetApi(11)
 public class GPUImageRenderer implements Renderer, PreviewCallback {
-    public static final int NO_IMAGE = -1;
-    static final float CUBE[] = {
-            -1.0f, -1.0f,
-            1.0f, -1.0f,
-            -1.0f, 1.0f,
-            1.0f, 1.0f,
-    };
-
-    private GPUImageFilter mFilter;
-
-    public final Object mSurfaceChangedWaiter = new Object();
-
-    private int mGLTextureId = NO_IMAGE;
-    private SurfaceTexture mSurfaceTexture = null;
-    private final FloatBuffer mGLCubeBuffer;
-    private final FloatBuffer mGLTextureBuffer;
-    private IntBuffer mGLRgbBuffer;
-
-    private int mOutputWidth;
-    private int mOutputHeight;
-    private int mImageWidth;
-    private int mImageHeight;
-    private int mAddedPadding;
-
-    private final Queue<Runnable> mRunOnDraw;
-    private Rotation mRotation;
-    private boolean mFlipHorizontal;
-    private boolean mFlipVertical;
-    private GPUImage.ScaleType mScaleType = GPUImage.ScaleType.CENTER_CROP;
-
-    public GPUImageRenderer(final GPUImageFilter filter) {
-        mFilter = filter;
-        mRunOnDraw = new LinkedList<Runnable>();
-
-        mGLCubeBuffer = ByteBuffer.allocateDirect(CUBE.length * 4)
-                .order(ByteOrder.nativeOrder())
-                .asFloatBuffer();
-        mGLCubeBuffer.put(CUBE).position(0);
-
-        mGLTextureBuffer = ByteBuffer.allocateDirect(TEXTURE_NO_ROTATION.length * 4)
-                .order(ByteOrder.nativeOrder())
-                .asFloatBuffer();
-        setRotation(Rotation.NORMAL, false, false);
-    }
-
-    @Override
-    public void onSurfaceCreated(final GL10 unused, final EGLConfig config) {
-        GLES20.glClearColor(0, 0, 0, 1);
-        GLES20.glDisable(GLES20.GL_DEPTH_TEST);
-        mFilter.init();
-    }
-
-    @Override
-    public void onSurfaceChanged(final GL10 gl, final int width, final int height) {
-        mOutputWidth = width;
-        mOutputHeight = height;
-        GLES20.glViewport(0, 0, width, height);
-        GLES20.glUseProgram(mFilter.getProgram());
-        mFilter.onOutputSizeChanged(width, height);
-        synchronized (mSurfaceChangedWaiter) {
-            mSurfaceChangedWaiter.notifyAll();
-        }
-    }
-
-    @Override
-    public void onDrawFrame(final GL10 gl) {
-        GLES20.glClear(GLES20.GL_COLOR_BUFFER_BIT | GLES20.GL_DEPTH_BUFFER_BIT);
-        synchronized (mRunOnDraw) {
-            while (!mRunOnDraw.isEmpty()) {
-                mRunOnDraw.poll().run();
-            }
-        }
-        mFilter.onDraw(mGLTextureId, mGLCubeBuffer, mGLTextureBuffer);
-        if (mSurfaceTexture != null) {
-            mSurfaceTexture.updateTexImage();
-        }
-    }
-
-    @Override
-    public void onPreviewFrame(final byte[] data, final Camera camera) {
-        final Size previewSize = camera.getParameters().getPreviewSize();
-        if (mGLRgbBuffer == null) {
-            mGLRgbBuffer = IntBuffer.allocate(previewSize.width * previewSize.height);
-        }
-        if (mRunOnDraw.isEmpty()) {
-            runOnDraw(new Runnable() {
-                @Override
-                public void run() {
-                    GPUImageNativeLibrary.YUVtoRBGA(data, previewSize.width, previewSize.height,
-                            mGLRgbBuffer.array());
-                    mGLTextureId = OpenGlUtils.loadTexture(mGLRgbBuffer, previewSize, mGLTextureId);
-                    camera.addCallbackBuffer(data);
-
-                    if (mImageWidth != previewSize.width) {
-                        mImageWidth = previewSize.width;
-                        mImageHeight = previewSize.height;
-                        adjustImageScaling();
-                    }
-                }
-            });
-        }
-    }
-
-    public void setUpSurfaceTexture(final Camera camera) {
-        runOnDraw(new Runnable() {
-            @Override
-            public void run() {
-                int[] textures = new int[1];
-                GLES20.glGenTextures(1, textures, 0);
-                mSurfaceTexture = new SurfaceTexture(textures[0]);
-                try {
-                    camera.setPreviewTexture(mSurfaceTexture);
-                    camera.setPreviewCallback(GPUImageRenderer.this);
-                    camera.startPreview();
-                } catch (IOException e) {
-                    e.printStackTrace();
-                }
-            }
-        });
-    }
-
-    public void setFilter(final GPUImageFilter filter) {
-        runOnDraw(new Runnable() {
-
-            @Override
-            public void run() {
-                final GPUImageFilter oldFilter = mFilter;
-                mFilter = filter;
-                if (oldFilter != null) {
-                    oldFilter.destroy();
-                }
-                mFilter.init();
-                GLES20.glUseProgram(mFilter.getProgram());
-                mFilter.onOutputSizeChanged(mOutputWidth, mOutputHeight);
-            }
-        });
-    }
-
-    public void deleteImage() {
-        runOnDraw(new Runnable() {
-
-            @Override
-            public void run() {
-                GLES20.glDeleteTextures(1, new int[]{
-                        mGLTextureId
-                }, 0);
-                mGLTextureId = NO_IMAGE;
-            }
-        });
-    }
-
-    public void setImageBitmap(final Bitmap bitmap) {
-        setImageBitmap(bitmap, true);
-    }
-
-    public void setImageBitmap(final Bitmap bitmap, final boolean recycle) {
-        if (bitmap == null) {
-            return;
-        }
-
-        runOnDraw(new Runnable() {
-
-            @Override
-            public void run() {
-                Bitmap resizedBitmap = null;
-                if (bitmap.getWidth() % 2 == 1) {
-                    resizedBitmap = Bitmap.createBitmap(bitmap.getWidth() + 1, bitmap.getHeight(),
-                            Bitmap.Config.ARGB_8888);
-                    Canvas can = new Canvas(resizedBitmap);
-                    can.drawARGB(0x00, 0x00, 0x00, 0x00);
-                    can.drawBitmap(bitmap, 0, 0, null);
-                    mAddedPadding = 1;
-                } else {
-                    mAddedPadding = 0;
-                }
-
-                mGLTextureId = OpenGlUtils.loadTexture(
-                        resizedBitmap != null ? resizedBitmap : bitmap, mGLTextureId, recycle);
-                if (resizedBitmap != null) {
-                    resizedBitmap.recycle();
-                }
-                mImageWidth = bitmap.getWidth();
-                mImageHeight = bitmap.getHeight();
-                adjustImageScaling();
-            }
-        });
-    }
-
-    public void setScaleType(GPUImage.ScaleType scaleType) {
-        mScaleType = scaleType;
-    }
-
-    protected int getFrameWidth() {
-        return mOutputWidth;
-    }
-
-    protected int getFrameHeight() {
-        return mOutputHeight;
-    }
-
-    private void adjustImageScaling() {
-        float outputWidth = mOutputWidth;
-        float outputHeight = mOutputHeight;
-        if (mRotation == Rotation.ROTATION_270 || mRotation == Rotation.ROTATION_90) {
-            outputWidth = mOutputHeight;
-            outputHeight = mOutputWidth;
-        }
-
-        float ratio1 = outputWidth / mImageWidth;
-        float ratio2 = outputHeight / mImageHeight;
-        float ratioMin = Math.min(ratio1, ratio2);
-        mImageWidth = Math.round(mImageWidth * ratioMin);
-        mImageHeight = Math.round(mImageHeight * ratioMin);
-
-        float ratioWidth = 1.0f;
-        float ratioHeight = 1.0f;
-        if (mImageWidth != outputWidth) {
-            ratioWidth = mImageWidth / outputWidth;
-        } else if (mImageHeight != outputHeight) {
-            ratioHeight = mImageHeight / outputHeight;
-        }
-
-        float[] cube = CUBE;
-        float[] textureCords = TextureRotationUtil.getRotation(mRotation, mFlipHorizontal, mFlipVertical);
-        if (mScaleType == GPUImage.ScaleType.CENTER_CROP) {
-            float distHorizontal = (1 / ratioWidth - 1) / 2;
-            float distVertical = (1 / ratioHeight - 1) / 2;
-            textureCords = new float[]{
-                    addDistance(textureCords[0], distVertical), addDistance(textureCords[1], distHorizontal),
-                    addDistance(textureCords[2], distVertical), addDistance(textureCords[3], distHorizontal),
-                    addDistance(textureCords[4], distVertical), addDistance(textureCords[5], distHorizontal),
-                    addDistance(textureCords[6], distVertical), addDistance(textureCords[7], distHorizontal),
-            };
-        } else {
-            cube = new float[]{
-                    CUBE[0] * ratioWidth, CUBE[1] * ratioHeight,
-                    CUBE[2] * ratioWidth, CUBE[3] * ratioHeight,
-                    CUBE[4] * ratioWidth, CUBE[5] * ratioHeight,
-                    CUBE[6] * ratioWidth, CUBE[7] * ratioHeight,
-            };
-        }
-
-        mGLCubeBuffer.clear();
-        mGLCubeBuffer.put(cube).position(0);
-        mGLTextureBuffer.clear();
-        mGLTextureBuffer.put(textureCords).position(0);
-    }
-
-    private float addDistance(float coordinate, float distance) {
-        return coordinate == 0.0f ? distance : 1 - distance;
-    }
-
-    public void setRotationCamera(final Rotation rotation, final boolean flipHorizontal,
-            final boolean flipVertical) {
-        setRotation(rotation, flipVertical, flipHorizontal);
-    }
-
-    public void setRotation(final Rotation rotation, final boolean flipHorizontal,
-            final boolean flipVertical) {
-        mRotation = rotation;
-        mFlipHorizontal = flipHorizontal;
-        mFlipVertical = flipVertical;
-        adjustImageScaling();
-    }
-
-    public Rotation getRotation() {
-        return mRotation;
-    }
-
-    public boolean isFlippedHorizontally() {
-        return mFlipHorizontal;
-    }
-
-    public boolean isFlippedVertically() {
-        return mFlipVertical;
-    }
-
-    protected void runOnDraw(final Runnable runnable) {
-        synchronized (mRunOnDraw) {
-            mRunOnDraw.add(runnable);
-        }
-    }
+	public static final int NO_IMAGE = -1;
+	static final float CUBE[] = { -1.0f, -1.0f, 1.0f, -1.0f, -1.0f, 1.0f, 1.0f,
+			1.0f, };
+
+	private GPUImageFilter mFilter;
+
+	public final Object mSurfaceChangedWaiter = new Object();
+
+	private int mGLTextureId = NO_IMAGE;
+	private SurfaceTexture mSurfaceTexture = null;
+	private final FloatBuffer mGLCubeBuffer;
+	private final FloatBuffer mGLTextureBuffer;
+	private IntBuffer mGLRgbBuffer;
+
+	private int mOutputWidth;
+	private int mOutputHeight;
+	private int mImageWidth;
+	private int mImageHeight;
+	private int mAddedPadding;
+
+	private final Queue<Runnable> mRunOnDraw;
+	private Rotation mRotation;
+	private boolean mFlipHorizontal;
+	private boolean mFlipVertical;
+	private GPUImage.ScaleType mScaleType = GPUImage.ScaleType.CENTER_CROP;
+
+	public GPUImageRenderer(final GPUImageFilter filter) {
+		mFilter = filter;
+		mRunOnDraw = new LinkedList<Runnable>();
+
+		mGLCubeBuffer = ByteBuffer.allocateDirect(CUBE.length * 4)
+				.order(ByteOrder.nativeOrder()).asFloatBuffer();
+		mGLCubeBuffer.put(CUBE).position(0);
+
+		mGLTextureBuffer = ByteBuffer
+				.allocateDirect(TEXTURE_NO_ROTATION.length * 4)
+				.order(ByteOrder.nativeOrder()).asFloatBuffer();
+		setRotation(Rotation.NORMAL, false, false);
+	}
+
+	@Override
+	public void onSurfaceCreated(final GL10 unused, final EGLConfig config) {
+		GLES20.glClearColor(0, 0, 0, 1);
+		GLES20.glDisable(GLES20.GL_DEPTH_TEST);
+		mFilter.init();
+	}
+
+	@Override
+	public void onSurfaceChanged(final GL10 gl, final int width,
+			final int height) {
+		mOutputWidth = width;
+		mOutputHeight = height;
+		GLES20.glViewport(0, 0, width, height);
+		GLES20.glUseProgram(mFilter.getProgram());
+		mFilter.onOutputSizeChanged(width, height);
+		synchronized (mSurfaceChangedWaiter) {
+			mSurfaceChangedWaiter.notifyAll();
+		}
+	}
+
+	@Override
+	public void onDrawFrame(final GL10 gl) {
+		GLES20.glClear(GLES20.GL_COLOR_BUFFER_BIT | GLES20.GL_DEPTH_BUFFER_BIT);
+		synchronized (mRunOnDraw) {
+			while (!mRunOnDraw.isEmpty()) {
+				mRunOnDraw.poll().run();
+			}
+		}
+		mFilter.onDraw(mGLTextureId, mGLCubeBuffer, mGLTextureBuffer);
+		if (mSurfaceTexture != null) {
+			mSurfaceTexture.updateTexImage();
+		}
+	}
+
+	@Override
+	public void onPreviewFrame(final byte[] data, final Camera camera) {
+		final Size previewSize = camera.getParameters().getPreviewSize();
+		if (mGLRgbBuffer == null) {
+			mGLRgbBuffer = IntBuffer.allocate(previewSize.width
+					* previewSize.height);
+		}
+		if (mRunOnDraw.isEmpty()) {
+			runOnDraw(new Runnable() {
+				@Override
+				public void run() {
+					GPUImageNativeLibrary.YUVtoRBGA(data, previewSize.width,
+							previewSize.height, mGLRgbBuffer.array());
+					mGLTextureId = OpenGlUtils.loadTexture(mGLRgbBuffer,
+							previewSize, mGLTextureId);
+					camera.addCallbackBuffer(data);
+
+					if (mImageWidth != previewSize.width) {
+						mImageWidth = previewSize.width;
+						mImageHeight = previewSize.height;
+						adjustImageScaling();
+					}
+				}
+			});
+		}
+	}
+
+	public void setUpSurfaceTexture(final Camera camera) {
+		runOnDraw(new Runnable() {
+			@Override
+			public void run() {
+				int[] textures = new int[1];
+				GLES20.glGenTextures(1, textures, 0);
+				mSurfaceTexture = new SurfaceTexture(textures[0]);
+				try {
+					camera.setPreviewTexture(mSurfaceTexture);
+					camera.setPreviewCallback(GPUImageRenderer.this);
+					camera.startPreview();
+				} catch (IOException e) {
+					e.printStackTrace();
+				}
+			}
+		});
+	}
+
+	public void setFilter(final GPUImageFilter filter) {
+		runOnDraw(new Runnable() {
+
+			@Override
+			public void run() {
+				final GPUImageFilter oldFilter = mFilter;
+				mFilter = filter;
+				if (oldFilter != null) {
+					oldFilter.destroy();
+				}
+				mFilter.init();
+				GLES20.glUseProgram(mFilter.getProgram());
+				mFilter.onOutputSizeChanged(mOutputWidth, mOutputHeight);
+			}
+		});
+	}
+
+	public void deleteImage() {
+		runOnDraw(new Runnable() {
+
+			@Override
+			public void run() {
+				GLES20.glDeleteTextures(1, new int[] { mGLTextureId }, 0);
+				mGLTextureId = NO_IMAGE;
+			}
+		});
+	}
+
+	public void setImageBitmap(final Bitmap bitmap) {
+		setImageBitmap(bitmap, true);
+	}
+
+	public void setImageTexture(final ByteBuffer buffer, final int width,
+			final int height) {
+		runOnDraw(new Runnable() {
+
+			@Override
+			public void run() {
+				mImageWidth = width;
+				mImageHeight = height;
+				mGLTextureId = OpenGlUtils.loadTexture(buffer.asIntBuffer(),
+						width, height, mGLTextureId);
+
+				adjustImageScaling();
+			}
+		});
+	}
+
+	public void setImageBitmap(final Bitmap bitmap, final boolean recycle) {
+		if (bitmap == null) {
+			return;
+		}
+
+		runOnDraw(new Runnable() {
+
+			@Override
+			public void run() {
+				Bitmap resizedBitmap = null;
+				if (bitmap.getWidth() % 2 == 1) {
+					resizedBitmap = Bitmap.createBitmap(bitmap.getWidth() + 1,
+							bitmap.getHeight(), Bitmap.Config.ARGB_8888);
+					Canvas can = new Canvas(resizedBitmap);
+					can.drawARGB(0x00, 0x00, 0x00, 0x00);
+					can.drawBitmap(bitmap, 0, 0, null);
+					mAddedPadding = 1;
+				} else {
+					mAddedPadding = 0;
+				}
+
+				mGLTextureId = OpenGlUtils.loadTexture(
+						resizedBitmap != null ? resizedBitmap : bitmap,
+						mGLTextureId, recycle);
+				if (resizedBitmap != null) {
+					resizedBitmap.recycle();
+				}
+				mImageWidth = bitmap.getWidth();
+				mImageHeight = bitmap.getHeight();
+				adjustImageScaling();
+			}
+		});
+	}
+
+	public void setScaleType(GPUImage.ScaleType scaleType) {
+		mScaleType = scaleType;
+	}
+
+	protected int getFrameWidth() {
+		return mOutputWidth;
+	}
+
+	protected int getFrameHeight() {
+		return mOutputHeight;
+	}
+
+	private void adjustImageScaling() {
+		float outputWidth = mOutputWidth;
+		float outputHeight = mOutputHeight;
+		if (mRotation == Rotation.ROTATION_270
+				|| mRotation == Rotation.ROTATION_90) {
+			outputWidth = mOutputHeight;
+			outputHeight = mOutputWidth;
+		}
+
+		float ratio1 = outputWidth / mImageWidth;
+		float ratio2 = outputHeight / mImageHeight;
+		float ratioMin = Math.min(ratio1, ratio2);
+		mImageWidth = Math.round(mImageWidth * ratioMin);
+		mImageHeight = Math.round(mImageHeight * ratioMin);
+
+		float ratioWidth = 1.0f;
+		float ratioHeight = 1.0f;
+		if (mImageWidth != outputWidth) {
+			ratioWidth = mImageWidth / outputWidth;
+		} else if (mImageHeight != outputHeight) {
+			ratioHeight = mImageHeight / outputHeight;
+		}
+
+		float[] cube = CUBE;
+		float[] textureCords = TextureRotationUtil.getRotation(mRotation,
+				mFlipHorizontal, mFlipVertical);
+		if (mScaleType == GPUImage.ScaleType.CENTER_CROP) {
+			float distHorizontal = (1 / ratioWidth - 1) / 2;
+			float distVertical = (1 / ratioHeight - 1) / 2;
+			textureCords = new float[] {
+					addDistance(textureCords[0], distVertical),
+					addDistance(textureCords[1], distHorizontal),
+					addDistance(textureCords[2], distVertical),
+					addDistance(textureCords[3], distHorizontal),
+					addDistance(textureCords[4], distVertical),
+					addDistance(textureCords[5], distHorizontal),
+					addDistance(textureCords[6], distVertical),
+					addDistance(textureCords[7], distHorizontal), };
+		} else {
+			cube = new float[] { CUBE[0] * ratioWidth, CUBE[1] * ratioHeight,
+					CUBE[2] * ratioWidth, CUBE[3] * ratioHeight,
+					CUBE[4] * ratioWidth, CUBE[5] * ratioHeight,
+					CUBE[6] * ratioWidth, CUBE[7] * ratioHeight, };
+		}
+
+		mGLCubeBuffer.clear();
+		mGLCubeBuffer.put(cube).position(0);
+		mGLTextureBuffer.clear();
+		mGLTextureBuffer.put(textureCords).position(0);
+	}
+
+	private float addDistance(float coordinate, float distance) {
+		return coordinate == 0.0f ? distance : 1 - distance;
+	}
+
+	public void setRotationCamera(final Rotation rotation,
+			final boolean flipHorizontal, final boolean flipVertical) {
+		setRotation(rotation, flipVertical, flipHorizontal);
+	}
+
+	public void setRotation(final Rotation rotation,
+			final boolean flipHorizontal, final boolean flipVertical) {
+		mRotation = rotation;
+		mFlipHorizontal = flipHorizontal;
+		mFlipVertical = flipVertical;
+		adjustImageScaling();
+	}
+
+	public Rotation getRotation() {
+		return mRotation;
+	}
+
+	public boolean isFlippedHorizontally() {
+		return mFlipHorizontal;
+	}
+
+	public boolean isFlippedVertically() {
+		return mFlipVertical;
+	}
+
+	public void runOnDraw(final Runnable runnable) {
+		synchronized (mRunOnDraw) {
+			mRunOnDraw.add(runnable);
+		}
+	}
 }
diff --git a/library/src/jp/co/cyberagent/android/gpuimage/OpenGlUtils.java b/library/src/jp/co/cyberagent/android/gpuimage/OpenGlUtils.java
index e8589704..0b62e568 100644
--- a/library/src/jp/co/cyberagent/android/gpuimage/OpenGlUtils.java
+++ b/library/src/jp/co/cyberagent/android/gpuimage/OpenGlUtils.java
@@ -81,6 +81,30 @@ public static int loadTexture(final IntBuffer data, final Size size, final int u
         }
         return textures[0];
     }
+    
+    public static int loadTexture(final IntBuffer data, final int width,final int height, final int usedTexId) {
+        int textures[] = new int[1];
+        if (usedTexId == NO_TEXTURE) {
+            GLES20.glGenTextures(1, textures, 0);
+            GLES20.glBindTexture(GLES20.GL_TEXTURE_2D, textures[0]);
+            GLES20.glTexParameterf(GLES20.GL_TEXTURE_2D,
+                    GLES20.GL_TEXTURE_MAG_FILTER, GLES20.GL_LINEAR);
+            GLES20.glTexParameterf(GLES20.GL_TEXTURE_2D,
+                    GLES20.GL_TEXTURE_MIN_FILTER, GLES20.GL_LINEAR);
+            GLES20.glTexParameterf(GLES20.GL_TEXTURE_2D,
+                    GLES20.GL_TEXTURE_WRAP_S, GLES20.GL_CLAMP_TO_EDGE);
+            GLES20.glTexParameterf(GLES20.GL_TEXTURE_2D,
+                    GLES20.GL_TEXTURE_WRAP_T, GLES20.GL_CLAMP_TO_EDGE);
+            GLES20.glTexImage2D(GLES20.GL_TEXTURE_2D, 0, GLES20.GL_RGBA, width, height,
+                    0, GLES20.GL_RGBA, GLES20.GL_UNSIGNED_BYTE, data);
+        } else {
+            GLES20.glBindTexture(GLES20.GL_TEXTURE_2D, usedTexId);
+            GLES20.glTexSubImage2D(GLES20.GL_TEXTURE_2D, 0, 0, 0, width,
+            		height, GLES20.GL_RGBA, GLES20.GL_UNSIGNED_BYTE, data);
+            textures[0] = usedTexId;
+        }
+        return textures[0];
+    }
 
     public static int loadTextureAsBitmap(final IntBuffer data, final Size size, final int usedTexId) {
         Bitmap bitmap = Bitmap
diff --git a/sample/.classpath b/sample/.classpath
index a4763d1e..850931bd 100644
--- a/sample/.classpath
+++ b/sample/.classpath
@@ -1,8 +1,10 @@
 <?xml version="1.0" encoding="UTF-8"?>
 <classpath>
+	<classpathentry kind="con" path="com.android.ide.eclipse.adt.ANDROID_FRAMEWORK"/>
+	<classpathentry exported="true" kind="con" path="com.android.ide.eclipse.adt.LIBRARIES"/>
 	<classpathentry kind="src" path="src"/>
 	<classpathentry kind="src" path="gen"/>
-	<classpathentry kind="con" path="com.android.ide.eclipse.adt.ANDROID_FRAMEWORK"/>
-	<classpathentry kind="con" path="com.android.ide.eclipse.adt.LIBRARIES"/>
+	<classpathentry exported="true" kind="con" path="com.android.ide.eclipse.adt.DEPENDENCIES"/>
+	<classpathentry kind="src" path="/gpuimage"/>
 	<classpathentry kind="output" path="bin/classes"/>
 </classpath>
diff --git a/sample/AndroidManifest.xml b/sample/AndroidManifest.xml
index dfd98f0e..1ae39de4 100644
--- a/sample/AndroidManifest.xml
+++ b/sample/AndroidManifest.xml
@@ -17,6 +17,7 @@
         android:hardwareAccelerated="true"
         android:icon="@drawable/ic_launcher"
         android:label="@string/app_name"
+        android:largeHeap="true"
         android:theme="@style/AppTheme" >
         <activity
             android:name=".activity.ActivityMain"
diff --git a/sample/project.properties b/sample/project.properties
index 24e0cbf3..1561d7a9 100644
--- a/sample/project.properties
+++ b/sample/project.properties
@@ -11,6 +11,5 @@
 #proguard.config=${sdk.dir}/tools/proguard/proguard-android.txt:proguard-project.txt
 
 # Project target.
-target=android-16
-proguard.config=${sdk.dir}/tools/proguard/proguard-android.txt:proguard-project.txt
-android.library.reference.1=../library
\ No newline at end of file
+target=android-17
+android.library.reference.1=../library
diff --git a/sample/res/layout/activity_camera.xml b/sample/res/layout/activity_camera.xml
index 16a64d0d..e31329de 100644
--- a/sample/res/layout/activity_camera.xml
+++ b/sample/res/layout/activity_camera.xml
@@ -3,11 +3,11 @@
     android:layout_height="match_parent"
     android:orientation="vertical" >
 
-    <android.opengl.GLSurfaceView
+<!--     <android.opengl.GLSurfaceView
         android:id="@+id/surfaceView"
         android:layout_width="match_parent"
         android:layout_height="match_parent"
-        android:layout_above="@+id/bar" />
+        android:layout_above="@+id/bar" /> -->
 
     <ImageView
         android:id="@+id/img_switch_camera"
diff --git a/sample/src/jp/co/cyberagent/android/gpuimage/sample/GPUImageFilterTools.java b/sample/src/jp/co/cyberagent/android/gpuimage/sample/GPUImageFilterTools.java
index be9bb178..9addd41c 100644
--- a/sample/src/jp/co/cyberagent/android/gpuimage/sample/GPUImageFilterTools.java
+++ b/sample/src/jp/co/cyberagent/android/gpuimage/sample/GPUImageFilterTools.java
@@ -144,7 +144,7 @@ private static GPUImageFilter createFilterForType(final Context context, final F
             	return new GPUImageHighlightShadowFilter(0.0f, 1.0f);
             case MONOCHROME:
             	return new GPUImageMonochromeFilter(1.0f, new float[]{0.6f, 0.45f, 0.3f, 1.0f});
-            case OPACITY:
+            case OPACITY: 
                 return new GPUImageOpacityFilter(1.0f);  
             case RGB:
                 return new GPUImageRGBFilter(1.0f, 1.0f, 1.0f);  
diff --git a/sample/src/jp/co/cyberagent/android/gpuimage/sample/activity/ActivityCamera.java b/sample/src/jp/co/cyberagent/android/gpuimage/sample/activity/ActivityCamera.java
index 9b99e7bc..d9499100 100644
--- a/sample/src/jp/co/cyberagent/android/gpuimage/sample/activity/ActivityCamera.java
+++ b/sample/src/jp/co/cyberagent/android/gpuimage/sample/activity/ActivityCamera.java
@@ -23,7 +23,11 @@
 import java.text.SimpleDateFormat;
 import java.util.Date;
 
+import com.hypersense.gpuimage.VideoEffect;
+
 import jp.co.cyberagent.android.gpuimage.GPUImage;
+import jp.co.cyberagent.android.gpuimage.GPUImageLookupFilter;
+import jp.co.cyberagent.android.gpuimage.GPUImageSobelEdgeDetection;
 import jp.co.cyberagent.android.gpuimage.GPUImage.OnPictureSavedListener;
 import jp.co.cyberagent.android.gpuimage.GPUImageFilter;
 import jp.co.cyberagent.android.gpuimage.sample.GPUImageFilterTools;
@@ -48,251 +52,285 @@
 import android.widget.SeekBar;
 import android.widget.SeekBar.OnSeekBarChangeListener;
 
-public class ActivityCamera extends Activity implements OnSeekBarChangeListener,
-        OnClickListener {
-
-    private GPUImage mGPUImage;
-    private CameraHelper mCameraHelper;
-    private CameraLoader mCamera;
-    private GPUImageFilter mFilter;
-    private FilterAdjuster mFilterAdjuster;
-
-    @Override
-    public void onCreate(final Bundle savedInstanceState) {
-        super.onCreate(savedInstanceState);
-        setContentView(R.layout.activity_camera);
-        ((SeekBar) findViewById(R.id.seekBar)).setOnSeekBarChangeListener(this);
-        findViewById(R.id.button_choose_filter).setOnClickListener(this);
-        findViewById(R.id.button_capture).setOnClickListener(this);
-
-        mGPUImage = new GPUImage(this);
-        mGPUImage.setGLSurfaceView((GLSurfaceView) findViewById(R.id.surfaceView));
-
-        mCameraHelper = new CameraHelper(this);
-        mCamera = new CameraLoader();
-
-        View cameraSwitchView = findViewById(R.id.img_switch_camera);
-        cameraSwitchView.setOnClickListener(this);
-        if (!mCameraHelper.hasFrontCamera() || !mCameraHelper.hasBackCamera()) {
-            cameraSwitchView.setVisibility(View.GONE);
-        }
-    }
-
-    @Override
-    protected void onResume() {
-        super.onResume();
-        mCamera.onResume();
-    }
-
-    @Override
-    protected void onPause() {
-        mCamera.onPause();
-        super.onPause();
-    }
-
-    @Override
-    public void onClick(final View v) {
-        switch (v.getId()) {
-            case R.id.button_choose_filter:
-                GPUImageFilterTools.showDialog(this, new OnGpuImageFilterChosenListener() {
-
-                    @Override
-                    public void onGpuImageFilterChosenListener(final GPUImageFilter filter) {
-                        switchFilterTo(filter);
-                    }
-                });
-                break;
-
-            case R.id.button_capture:
-                if (mCamera.mCameraInstance.getParameters().getFocusMode().equals(
-                        Camera.Parameters.FOCUS_MODE_CONTINUOUS_PICTURE)) {
-                    takePicture();
-                } else {
-                    mCamera.mCameraInstance.autoFocus(new Camera.AutoFocusCallback() {
-
-                        @Override
-                        public void onAutoFocus(final boolean success, final Camera camera) {
-                            takePicture();
-                        }
-                    });
-                }
-                break;
-
-            case R.id.img_switch_camera:
-                mCamera.switchCamera();
-                break;
-        }
-    }
-
-    private void takePicture() {
-        // TODO get a size that is about the size of the screen
-        Camera.Parameters params = mCamera.mCameraInstance.getParameters();
-        params.setPictureSize(1280, 960);
-        params.setRotation(90);
-        mCamera.mCameraInstance.setParameters(params);
-        for (Camera.Size size2 : mCamera.mCameraInstance.getParameters()
-                .getSupportedPictureSizes()) {
-            Log.i("ASDF", "Supported: " + size2.width + "x" + size2.height);
-        }
-        mCamera.mCameraInstance.takePicture(null, null,
-                new Camera.PictureCallback() {
-
-                    @Override
-                    public void onPictureTaken(byte[] data, final Camera camera) {
-
-                        final File pictureFile = getOutputMediaFile(MEDIA_TYPE_IMAGE);
-                        if (pictureFile == null) {
-                            Log.d("ASDF",
-                                    "Error creating media file, check storage permissions");
-                            return;
-                        }
-
-                        try {
-                            FileOutputStream fos = new FileOutputStream(pictureFile);
-                            fos.write(data);
-                            fos.close();
-                        } catch (FileNotFoundException e) {
-                            Log.d("ASDF", "File not found: " + e.getMessage());
-                        } catch (IOException e) {
-                            Log.d("ASDF", "Error accessing file: " + e.getMessage());
-                        }
-
-                        data = null;
-                        Bitmap bitmap = BitmapFactory.decodeFile(pictureFile
-                                .getAbsolutePath());
-                        // mGPUImage.setImage(bitmap);
-                        final GLSurfaceView view = (GLSurfaceView) findViewById(R.id.surfaceView);
-                        view.setRenderMode(GLSurfaceView.RENDERMODE_WHEN_DIRTY);
-                        mGPUImage.saveToPictures(bitmap, "GPUImage",
-                                System.currentTimeMillis() + ".jpg",
-                                new OnPictureSavedListener() {
-
-                                    @Override
-                                    public void onPictureSaved(final Uri
-                                            uri) {
-                                        pictureFile.delete();
-                                        camera.startPreview();
-                                        view.setRenderMode(GLSurfaceView.RENDERMODE_CONTINUOUSLY);
-                                    }
-                                });
-                    }
-                });
-    }
-
-    public static final int MEDIA_TYPE_IMAGE = 1;
-    public static final int MEDIA_TYPE_VIDEO = 2;
-
-    private static File getOutputMediaFile(final int type) {
-        // To be safe, you should check that the SDCard is mounted
-        // using Environment.getExternalStorageState() before doing this.
-
-        File mediaStorageDir = new File(Environment.getExternalStoragePublicDirectory(
-                Environment.DIRECTORY_PICTURES), "MyCameraApp");
-        // This location works best if you want the created images to be shared
-        // between applications and persist after your app has been uninstalled.
-
-        // Create the storage directory if it does not exist
-        if (!mediaStorageDir.exists()) {
-            if (!mediaStorageDir.mkdirs()) {
-                Log.d("MyCameraApp", "failed to create directory");
-                return null;
-            }
-        }
-
-        // Create a media file name
-        String timeStamp = new SimpleDateFormat("yyyyMMdd_HHmmss").format(new Date());
-        File mediaFile;
-        if (type == MEDIA_TYPE_IMAGE) {
-            mediaFile = new File(mediaStorageDir.getPath() + File.separator +
-                    "IMG_" + timeStamp + ".jpg");
-        } else if (type == MEDIA_TYPE_VIDEO) {
-            mediaFile = new File(mediaStorageDir.getPath() + File.separator +
-                    "VID_" + timeStamp + ".mp4");
-        } else {
-            return null;
-        }
-
-        return mediaFile;
-    }
-
-    private void switchFilterTo(final GPUImageFilter filter) {
-        if (mFilter == null
-                || (filter != null && !mFilter.getClass().equals(filter.getClass()))) {
-            mFilter = filter;
-            mGPUImage.setFilter(mFilter);
-            mFilterAdjuster = new FilterAdjuster(mFilter);
-        }
-    }
-
-    @Override
-    public void onProgressChanged(final SeekBar seekBar, final int progress, final boolean fromUser) {
-        if (mFilterAdjuster != null) {
-            mFilterAdjuster.adjust(progress);
-        }
-    }
-
-    @Override
-    public void onStartTrackingTouch(final SeekBar seekBar) {
-    }
-
-    @Override
-    public void onStopTrackingTouch(final SeekBar seekBar) {
-    }
-
-    private class CameraLoader {
-        private int mCurrentCameraId = 0;
-        private Camera mCameraInstance;
-
-        public void onResume() {
-            setUpCamera(mCurrentCameraId);
-        }
-
-        public void onPause() {
-            releaseCamera();
-        }
-
-        public void switchCamera() {
-            releaseCamera();
-            mCurrentCameraId = (mCurrentCameraId + 1) % mCameraHelper.getNumberOfCameras();
-            setUpCamera(mCurrentCameraId);
-        }
-
-        private void setUpCamera(final int id) {
-            mCameraInstance = getCameraInstance(id);
-            Parameters parameters = mCameraInstance.getParameters();
-            // TODO adjust by getting supportedPreviewSizes and then choosing
-            // the best one for screen size (best fill screen)
-            parameters.setPreviewSize(720, 480);
-            if (parameters.getSupportedFocusModes().contains(
-                    Camera.Parameters.FOCUS_MODE_CONTINUOUS_PICTURE)) {
-                parameters.setFocusMode(Camera.Parameters.FOCUS_MODE_CONTINUOUS_PICTURE);
-            }
-            mCameraInstance.setParameters(parameters);
-
-            int orientation = mCameraHelper.getCameraDisplayOrientation(
-                    ActivityCamera.this, mCurrentCameraId);
-            CameraInfo2 cameraInfo = new CameraInfo2();
-            mCameraHelper.getCameraInfo(mCurrentCameraId, cameraInfo);
-            boolean flipHorizontal = cameraInfo.facing == CameraInfo.CAMERA_FACING_FRONT
-                    ? true : false;
-            mGPUImage.setUpCamera(mCameraInstance, orientation, flipHorizontal, false);
-        }
-
-        /** A safe way to get an instance of the Camera object. */
-        private Camera getCameraInstance(final int id) {
-            Camera c = null;
-            try {
-                c = mCameraHelper.openCamera(id);
-            } catch (Exception e) {
-                e.printStackTrace();
-            }
-            return c;
-        }
-
-        private void releaseCamera() {
-            mCameraInstance.setPreviewCallback(null);
-            mCameraInstance.release();
-            mCameraInstance = null;
-        }
-    }
+public class ActivityCamera extends Activity implements
+		OnSeekBarChangeListener {
+
+	private GPUImage mGPUImage;
+	private CameraHelper mCameraHelper;
+	private CameraLoader mCamera;
+	private GPUImageFilter mFilter;
+	private FilterAdjuster mFilterAdjuster;
+
+	@Override
+	public void onCreate(final Bundle savedInstanceState) {
+		super.onCreate(savedInstanceState);
+		setContentView(R.layout.activity_camera);
+//		((SeekBar) findViewById(R.id.seekBar)).setOnSeekBarChangeListener(this);
+//		findViewById(R.id.button_choose_filter).setOnClickListener(this);
+//		findViewById(R.id.button_capture).setOnClickListener(this);
+//
+		mGPUImage = new GPUImage(this);
+		
+
+		// mGPUImage.setGLSurfaceView((GLSurfaceView)
+		// findViewById(R.id.surfaceView));
+
+		// mCameraHelper = new CameraHelper(this);
+		// mCamera = new CameraLoader();
+		//
+		// View cameraSwitchView = findViewById(R.id.img_switch_camera);
+		// cameraSwitchView.setOnClickListener(this);
+		// if (!mCameraHelper.hasFrontCamera() ||
+		// !mCameraHelper.hasBackCamera()) {
+		// cameraSwitchView.setVisibility(View.GONE);
+		// }
+
+		String f = Environment.getExternalStorageDirectory().getAbsolutePath()
+				+ "/vid/viddd.mp4";
+		String newVideo = Environment.getExternalStorageDirectory()
+				.getAbsolutePath() + "/vid/viddddnew.mp4";
+
+        GPUImageLookupFilter amatorka = new GPUImageLookupFilter();
+        amatorka.setBitmap(BitmapFactory.decodeResource(getResources(), R.drawable.lookup_amatorka));
+
+
+		
+		VideoEffect videoEffect = new VideoEffect(f, newVideo);
+		videoEffect.start();
+		
+		mGPUImage.setFilter(amatorka);
+		videoEffect.processVideo(mGPUImage);
+
+	}
+
+	@Override
+	protected void onResume() {
+		super.onResume();
+		// mCamera.onResume();
+	}
+
+	@Override
+	protected void onPause() {
+		// mCamera.onPause();
+		super.onPause();
+	}
+//
+//	@Override
+//	public void onClick(final View v) {
+//		switch (v.getId()) {
+//		case R.id.button_choose_filter:
+//			GPUImageFilterTools.showDialog(this,
+//					new OnGpuImageFilterChosenListener() {
+//
+//						@Override
+//						public void onGpuImageFilterChosenListener(
+//								final GPUImageFilter filter) {
+//							switchFilterTo(filter);
+//						}
+//					});
+//			break;
+//
+//		case R.id.button_capture:
+//			if (mCamera.mCameraInstance.getParameters().getFocusMode()
+//					.equals(Camera.Parameters.FOCUS_MODE_CONTINUOUS_PICTURE)) {
+//				takePicture();
+//			} else {
+//				mCamera.mCameraInstance
+//						.autoFocus(new Camera.AutoFocusCallback() {
+//
+//							@Override
+//							public void onAutoFocus(final boolean success,
+//									final Camera camera) {
+//								takePicture();
+//							}
+//						});
+//			}
+//			break;
+//
+//		case R.id.img_switch_camera:
+//			mCamera.switchCamera();
+//			break;
+//		}
+////	}
+////
+//	private void takePicture() {
+//		// TODO get a size that is about the size of the screen
+//		Camera.Parameters params = mCamera.mCameraInstance.getParameters();
+//		params.setPictureSize(1280, 960);
+//		params.setRotation(90);
+//		mCamera.mCameraInstance.setParameters(params);
+//		for (Camera.Size size2 : mCamera.mCameraInstance.getParameters()
+//				.getSupportedPictureSizes()) {
+//			Log.i("ASDF", "Supported: " + size2.width + "x" + size2.height);
+//		}
+//		mCamera.mCameraInstance.takePicture(null, null,
+//				new Camera.PictureCallback() {
+//
+//					@Override
+//					public void onPictureTaken(byte[] data, final Camera camera) {
+//
+//						final File pictureFile = getOutputMediaFile(MEDIA_TYPE_IMAGE);
+//						if (pictureFile == null) {
+//							Log.d("ASDF",
+//									"Error creating media file, check storage permissions");
+//							return;
+//						}
+//
+//						try {
+//							FileOutputStream fos = new FileOutputStream(
+//									pictureFile);
+//							fos.write(data);
+//							fos.close();
+//						} catch (FileNotFoundException e) {
+//							Log.d("ASDF", "File not found: " + e.getMessage());
+//						} catch (IOException e) {
+//							Log.d("ASDF",
+//									"Error accessing file: " + e.getMessage());
+//						}
+//
+//						data = null;
+//						Bitmap bitmap = BitmapFactory.decodeFile(pictureFile
+//								.getAbsolutePath());
+//						// mGPUImage.setImage(bitmap);
+//						final GLSurfaceView view = (GLSurfaceView) findViewById(R.id.surfaceView);
+//						view.setRenderMode(GLSurfaceView.RENDERMODE_WHEN_DIRTY);
+//						mGPUImage.saveToPictures(bitmap, "GPUImage",
+//								System.currentTimeMillis() + ".jpg",
+//								new OnPictureSavedListener() {
+//
+//									@Override
+//									public void onPictureSaved(final Uri uri) {
+//										pictureFile.delete();
+//										camera.startPreview();
+//										view.setRenderMode(GLSurfaceView.RENDERMODE_CONTINUOUSLY);
+//									}
+//								});
+//					}
+//				});
+//	}
+//
+	public static final int MEDIA_TYPE_IMAGE = 1;
+	public static final int MEDIA_TYPE_VIDEO = 2;
+
+	private static File getOutputMediaFile(final int type) {
+		// To be safe, you should check that the SDCard is mounted
+		// using Environment.getExternalStorageState() before doing this.
+
+		File mediaStorageDir = new File(
+				Environment
+						.getExternalStoragePublicDirectory(Environment.DIRECTORY_PICTURES),
+				"MyCameraApp");
+		// This location works best if you want the created images to be shared
+		// between applications and persist after your app has been uninstalled.
+
+		// Create the storage directory if it does not exist
+		if (!mediaStorageDir.exists()) {
+			if (!mediaStorageDir.mkdirs()) {
+				Log.d("MyCameraApp", "failed to create directory");
+				return null;
+			}
+		}
+
+		// Create a media file name
+		String timeStamp = new SimpleDateFormat("yyyyMMdd_HHmmss")
+				.format(new Date());
+		File mediaFile;
+		if (type == MEDIA_TYPE_IMAGE) {
+			mediaFile = new File(mediaStorageDir.getPath() + File.separator
+					+ "IMG_" + timeStamp + ".jpg");
+		} else if (type == MEDIA_TYPE_VIDEO) {
+			mediaFile = new File(mediaStorageDir.getPath() + File.separator
+					+ "VID_" + timeStamp + ".mp4");
+		} else {
+			return null;
+		}
+
+		return mediaFile;
+	}
+
+	private void switchFilterTo(final GPUImageFilter filter) {
+		if (mFilter == null
+				|| (filter != null && !mFilter.getClass().equals(
+						filter.getClass()))) {
+			mFilter = filter;
+			mGPUImage.setFilter(mFilter);
+			mFilterAdjuster = new FilterAdjuster(mFilter);
+		}
+	}
+
+	@Override
+	public void onProgressChanged(final SeekBar seekBar, final int progress,
+			final boolean fromUser) {
+		if (mFilterAdjuster != null) {
+			mFilterAdjuster.adjust(progress);
+		}
+	}
+
+	@Override
+	public void onStartTrackingTouch(final SeekBar seekBar) {
+	}
+
+	@Override
+	public void onStopTrackingTouch(final SeekBar seekBar) {
+	}
+
+	private class CameraLoader {
+		private int mCurrentCameraId = 0;
+		private Camera mCameraInstance;
+
+		public void onResume() {
+			setUpCamera(mCurrentCameraId);
+		}
+
+		public void onPause() {
+			releaseCamera();
+		}
+
+		public void switchCamera() {
+			releaseCamera();
+			mCurrentCameraId = (mCurrentCameraId + 1)
+					% mCameraHelper.getNumberOfCameras();
+			setUpCamera(mCurrentCameraId);
+		}
+
+		private void setUpCamera(final int id) {
+			mCameraInstance = getCameraInstance(id);
+			Parameters parameters = mCameraInstance.getParameters();
+			// TODO adjust by getting supportedPreviewSizes and then choosing
+			// the best one for screen size (best fill screen)
+			parameters.setPreviewSize(720, 480);
+			if (parameters.getSupportedFocusModes().contains(
+					Camera.Parameters.FOCUS_MODE_CONTINUOUS_PICTURE)) {
+				parameters
+						.setFocusMode(Camera.Parameters.FOCUS_MODE_CONTINUOUS_PICTURE);
+			}
+			mCameraInstance.setParameters(parameters);
+
+			int orientation = mCameraHelper.getCameraDisplayOrientation(
+					ActivityCamera.this, mCurrentCameraId);
+			CameraInfo2 cameraInfo = new CameraInfo2();
+			mCameraHelper.getCameraInfo(mCurrentCameraId, cameraInfo);
+			boolean flipHorizontal = cameraInfo.facing == CameraInfo.CAMERA_FACING_FRONT ? true
+					: false;
+			mGPUImage.setUpCamera(mCameraInstance, orientation, flipHorizontal,
+					false);
+		}
+
+		/** A safe way to get an instance of the Camera object. */
+		private Camera getCameraInstance(final int id) {
+			Camera c = null;
+			try {
+				c = mCameraHelper.openCamera(id);
+			} catch (Exception e) {
+				e.printStackTrace();
+			}
+			return c;
+		}
+
+		private void releaseCamera() {
+			mCameraInstance.setPreviewCallback(null);
+			mCameraInstance.release();
+			mCameraInstance = null;
+		}
+	}
 }
