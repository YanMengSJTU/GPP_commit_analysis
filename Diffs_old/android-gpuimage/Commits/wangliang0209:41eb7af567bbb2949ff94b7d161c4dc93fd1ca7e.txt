diff --git a/.gitignore b/.gitignore
index a026429f..f99652d1 100644
--- a/.gitignore
+++ b/.gitignore
@@ -1,11 +1,23 @@
-#OSX
 .DS_Store
-target/
+Thumbs.db
+
+# gradle files
+.gradle
 
-.idea/
+# Intellij project files
+.idea
 *.iml
 
-#Gradle
+# generated files
+bin/
+gen/
+obj/
+apk/
+target/
 build/
-.gradle/
+
+# Local configuration file (sdk path, etc)
 local.properties
+
+# Proguard folder generated by Eclipse
+proguard/
diff --git a/.travis.yml b/.travis.yml
deleted file mode 100644
index ef0cc3a9..00000000
--- a/.travis.yml
+++ /dev/null
@@ -1,40 +0,0 @@
-language:
-  - android
-jdk:
-  - oraclejdk8
-
-android:
-  components:
-    - build-tools-21.0.2
-    - android-21
-    - extra-google-m2repository
-    - extra-android-m2repository
-
-  licenses:
-    - 'android-sdk-license-.+'
-
-notifications:
-  email: false
-
-before_script:
-  - sudo service postgresql stop || true
-  - sudo service mysql stop || true
-  - sudo service memcached stop || true
-  - sudo service bootlogd stop || true
-  - sudo service elasticsearch stop || true
-  - sudo service mongodb stop || true
-  - sudo service neo4j stop || true
-  - sudo service cassandra stop || true
-  - sudo service riak stop || true
-  - sudo service rsync stop || true
-  - sudo service x11-common stop || true
-
-before_install:
-  - wget http://dl.google.com/android/ndk/android-ndk-r10c-linux-x86_64.bin
-  - chmod +x android-ndk-r10c-linux-x86_64.bin
-  - ./android-ndk-r10c-linux-x86_64.bin | egrep -v ^Extracting
-  - export ANDROID_NDK_HOME=`pwd`/android-ndk-r10c
-  - export PATH=${PATH}:${ANDROID_NDK_HOME}
-
-script:
-  - ./gradlew assemble --info
\ No newline at end of file
diff --git a/CHANGELOG.md b/CHANGELOG.md
index ddcb7d47..7c89ae59 100644
--- a/CHANGELOG.md
+++ b/CHANGELOG.md
@@ -1,6 +1,26 @@
 Change Log
 ==========
 
+Version 1.4.1 *(2016-03-15)*
+----------------------------
+
+Using Bintray's JCenter.
+
+
+Version 1.4.0 *(2016-02-28)*
+----------------------------
+
+* added GPUImageHalftoneFilter (by @ryohey)
+* added GPUImageTransformFilter (by @jonan)
+* fixed GPUImageChromaKeyBlendFilter (by @badjano)
+* fixed GPUImageLookupFilter (by @jonan)
+
+Version 1.3.0 *(2015-09-04)*
+----------------------------
+
+ * added GPUImageBilateralFilter (by @wysaid)
+ * added flip options to `GPUImage#setRotation`
+
 Version 1.2.3-SNAPSHOT *(2014-12-15)*
 ----------------------------
 
diff --git a/README.md b/README.md
index e229a29f..0ac61327 100644
--- a/README.md
+++ b/README.md
@@ -1,5 +1,6 @@
 # GPUImage for Android
-[![Build Status](https://api.travis-ci.org/CyberAgent/android-gpuimage.png?branch=master,develop)](https://travis-ci.org/CyberAgent/android-gpuimage)
+[![License](https://img.shields.io/badge/license-Apache%202-blue.svg)](https://www.apache.org/licenses/LICENSE-2.0)
+[![Download](https://api.bintray.com/packages/cyberagent/maven/gpuimage-library/images/download.svg) ](https://bintray.com/cyberagent/maven/gpuimage-library/_latestVersion)
 
 Idea from: [iOS GPUImage framework](https://github.com/BradLarson/GPUImage)
 
@@ -14,12 +15,11 @@ Goal is to have something as similar to GPUImage as possible. Vertex and fragmen
 
 ```groovy
 repositories {
-    mavenCentral()
-    maven { url "https://oss.sonatype.org/content/repositories/snapshots/" }
+    jcenter()
 }
 
 dependencies {
-    compile 'jp.co.cyberagent.android.gpuimage:gpuimage-library:1.2.3-SNAPSHOT@aar'
+    compile 'jp.co.cyberagent.android.gpuimage:gpuimage-library:1.4.1'
 }
 ```
 
@@ -73,4 +73,4 @@ gradle clean assemble
     distributed under the License is distributed on an "AS IS" BASIS,
     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     See the License for the specific language governing permissions and
-    limitations under the License.
\ No newline at end of file
+    limitations under the License.
diff --git a/build.gradle b/build.gradle
index 94df0e4f..8a29e6b0 100644
--- a/build.gradle
+++ b/build.gradle
@@ -5,7 +5,8 @@ buildscript {
         jcenter()
     }
     dependencies {
-        classpath 'com.android.tools.build:gradle:1.0.0'
+        classpath 'com.android.tools.build:gradle:2.0.0-beta6'
+        classpath 'com.novoda:bintray-release:0.3.4'
     }
 }
 
diff --git a/gradle.properties b/gradle.properties
index 10e806eb..40c44d7f 100644
--- a/gradle.properties
+++ b/gradle.properties
@@ -1,10 +1,10 @@
-VERSION_NAME=1.2.3-SNAPSHOT
-VERSION_CODE=7
+VERSION_NAME=1.4.1
 GROUP=jp.co.cyberagent.android.gpuimage
+ARTIFACT_ID=gpuimage-library
 
-COMPILE_SDK_VERSION=21
-BUILD_TOOLS_VERSION=21.0.2
-TARGET_SDK_VERSION=21
+COMPILE_SDK_VERSION=23
+BUILD_TOOLS_VERSION=23.0.2
+TARGET_SDK_VERSION=23
 MIN_SDK_VERSION=8
 
 POM_DESCRIPTION=Image filters for Android with OpenGL (based on GPUImage for iOS)
@@ -15,5 +15,8 @@ POM_SCM_DEV_CONNECTION=scm:git@github.com:CyberAgent/android-gpuimage.git
 POM_LICENCE_NAME=The Apache Software License, Version 2.0
 POM_LICENCE_URL=http://www.apache.org/licenses/LICENSE-2.0.txt
 POM_LICENCE_DIST=repo
-POM_DEVELOPER_ID=pboos
-POM_DEVELOPER_NAME=Patrick Boos
+POM_DEVELOPER_ID=cyberagent
+POM_DEVELOPER_NAME=CyberAgent, Inc.
+ISSUE_URL=https://github.com/CyberAgent/android-gpuimage/issues
+
+android.useDeprecatedNdk=true
diff --git a/gradle/wrapper/gradle-wrapper.properties b/gradle/wrapper/gradle-wrapper.properties
index 2cd9fedd..6c0732ab 100644
--- a/gradle/wrapper/gradle-wrapper.properties
+++ b/gradle/wrapper/gradle-wrapper.properties
@@ -3,4 +3,4 @@ distributionBase=GRADLE_USER_HOME
 distributionPath=wrapper/dists
 zipStoreBase=GRADLE_USER_HOME
 zipStorePath=wrapper/dists
-distributionUrl=https\://services.gradle.org/distributions/gradle-2.2.1-all.zip
+distributionUrl=https\://services.gradle.org/distributions/gradle-2.11-all.zip
diff --git a/library/.gitignore b/library/.gitignore
deleted file mode 100644
index 85e23b43..00000000
--- a/library/.gitignore
+++ /dev/null
@@ -1,32 +0,0 @@
-#Android generated
-bin
-gen
-obj
-
-#Eclipse
-#.project
-#.classpath
-.settings
-
-#IntelliJ IDEA
-.idea
-*.iml
-*.ipr
-*.iws
-out
-
-#Checkstyle
-.checkstyle
-
-#Maven
-target
-release.properties
-pom.xml.*
-
-#Ant
-build.xml
-local.properties
-proguard.cfg
-
-#OSX
-.DS_Store
diff --git a/library/build.gradle b/library/build.gradle
index 59b1a081..4e0ded68 100644
--- a/library/build.gradle
+++ b/library/build.gradle
@@ -1,5 +1,5 @@
 apply plugin: 'com.android.library'
-apply from: 'https://raw.github.com/chrisbanes/gradle-mvn-push/master/gradle-mvn-push.gradle'
+apply plugin: 'com.novoda.bintray-release'
 
 android {
     compileSdkVersion COMPILE_SDK_VERSION as int
@@ -9,8 +9,10 @@ android {
         minSdkVersion MIN_SDK_VERSION as int
         targetSdkVersion TARGET_SDK_VERSION as int
 
-        versionCode = VERSION_CODE
-        versionName = VERSION_NAME
+        versionCode "git rev-list origin/master --count".execute().text.toInteger()
+        versionName VERSION_NAME
+
+        consumerProguardFiles 'proguard-rules.txt'
 
         ndk {
             moduleName "gpuimage-library"
@@ -38,4 +40,33 @@ android {
     lintOptions {
         abortOnError false
     }
-}
\ No newline at end of file
+}
+
+task androidJavadocs(type: Javadoc) {
+    source = android.sourceSets.main.java.srcDirs
+    classpath += project.files(android.getBootClasspath().join(File.pathSeparator))
+}
+
+task androidJavadocsJar(type: Jar, dependsOn: androidJavadocs) {
+    classifier = 'javadoc'
+    from androidJavadocs.destinationDir
+}
+
+task androidSourcesJar(type: Jar) {
+    classifier = 'sources'
+    from android.sourceSets.main.java.srcDirs
+}
+
+artifacts {
+    archives androidSourcesJar
+    archives androidJavadocsJar
+}
+
+publish {
+    userOrg = POM_DEVELOPER_ID
+    groupId = GROUP
+    artifactId = ARTIFACT_ID
+    publishVersion = VERSION_NAME
+    desc = POM_DESCRIPTION
+    website = POM_URL
+}
diff --git a/library/jni/yuv-decoder.c b/library/jni/yuv-decoder.c
index 0ed5cce2..fed6281e 100644
--- a/library/jni/yuv-decoder.c
+++ b/library/jni/yuv-decoder.c
@@ -36,11 +36,19 @@ JNIEXPORT void JNICALL Java_jp_co_cyberagent_android_gpuimage_GPUImageNativeLibr
                              Cr = yuv[cOff + 1];
                              if(Cr < 0) Cr += 127; else Cr -= 128;
                      }
-                     R = Y + Cr + (Cr >> 3) + (Cr >> 6);
+                     
+                     //ITU-R BT.601 conversion
+                     //
+                     //R = 1.164*(Y-16) + 2.018*(Cr-128);
+                     //G = 1.164*(Y-16) - 0.813*(Cb-128) - 0.391*(Cr-128);
+                     //B = 1.164*(Y-16) + 1.596*(Cb-128);
+                     //
+                     Y = Y + (Y >> 3) + (Y >> 5) + (Y >> 7);
+                     R = Y + (Cr << 1) + (Cr >> 6);
                      if(R < 0) R = 0; else if(R > 255) R = 255;
-                     G = Y - (Cb >> 1) + (Cb >> 4) + (Cb >> 5) - Cr + (Cr >> 2) + (Cr >> 3) + (Cr >> 5) + + (Cr >> 6);
+                     G = Y - Cb + (Cb >> 3) + (Cb >> 4) - (Cr >> 1) + (Cr >> 3);
                      if(G < 0) G = 0; else if(G > 255) G = 255;
-                     B = Y + (Cb << 1) + (Cb >> 5);
+                     B = Y + Cb + (Cb >> 1) + (Cb >> 4) + (Cb >> 5);
                      if(B < 0) B = 0; else if(B > 255) B = 255;
                      rgbData[pixPtr++] = 0xff000000 + (R << 16) + (G << 8) + B;
              }
@@ -84,11 +92,19 @@ JNIEXPORT void JNICALL Java_jp_co_cyberagent_android_gpuimage_GPUImageNativeLibr
                              Cr = yuv[cOff + 1];
                              if(Cr < 0) Cr += 127; else Cr -= 128;
                      }
-                     R = Y + Cr + (Cr >> 3) + (Cr >> 6);
+                     
+                     //ITU-R BT.601 conversion
+                     //
+                     //R = 1.164*(Y-16) + 2.018*(Cr-128);
+                     //G = 1.164*(Y-16) - 0.813*(Cb-128) - 0.391*(Cr-128);
+                     //B = 1.164*(Y-16) + 1.596*(Cb-128);
+                     //
+                     Y = Y + (Y >> 3) + (Y >> 5) + (Y >> 7);
+                     R = Y + (Cr << 1) + (Cr >> 6);
                      if(R < 0) R = 0; else if(R > 255) R = 255;
-                     G = Y - (Cb >> 1) + (Cb >> 4) + (Cb >> 5) - Cr + (Cr >> 2) + (Cr >> 3) + (Cr >> 5) + + (Cr >> 6);
+                     G = Y - Cb + (Cb >> 3) + (Cb >> 4) - (Cr >> 1) + (Cr >> 3);
                      if(G < 0) G = 0; else if(G > 255) G = 255;
-                     B = Y + (Cb << 1) + (Cb >> 5);
+                     B = Y + Cb + (Cb >> 1) + (Cb >> 4) + (Cb >> 5);
                      if(B < 0) B = 0; else if(B > 255) B = 255;
                      rgbData[pixPtr++] = 0xff000000 + (B << 16) + (G << 8) + R;
              }
diff --git a/library/proguard-project.txt b/library/proguard-project.txt
deleted file mode 100644
index f2fe1559..00000000
--- a/library/proguard-project.txt
+++ /dev/null
@@ -1,20 +0,0 @@
-# To enable ProGuard in your project, edit project.properties
-# to define the proguard.config property as described in that file.
-#
-# Add project specific ProGuard rules here.
-# By default, the flags in this file are appended to flags specified
-# in ${sdk.dir}/tools/proguard/proguard-android.txt
-# You can edit the include path and order by changing the ProGuard
-# include property in project.properties.
-#
-# For more details, see
-#   http://developer.android.com/guide/developing/tools/proguard.html
-
-# Add any project specific keep options here:
-
-# If your project uses WebView with JS, uncomment the following
-# and specify the fully qualified class name to the JavaScript interface
-# class:
-#-keepclassmembers class fqcn.of.javascript.interface.for.webview {
-#   public *;
-#}
diff --git a/library/proguard-rules.txt b/library/proguard-rules.txt
new file mode 100644
index 00000000..32ba2033
--- /dev/null
+++ b/library/proguard-rules.txt
@@ -0,0 +1 @@
+-dontwarn jp.co.cyberagent.android.gpuimage.**
\ No newline at end of file
diff --git a/library/src/jp/co/cyberagent/android/gpuimage/GPUImage.java b/library/src/jp/co/cyberagent/android/gpuimage/GPUImage.java
index e083917c..8392a5a9 100644
--- a/library/src/jp/co/cyberagent/android/gpuimage/GPUImage.java
+++ b/library/src/jp/co/cyberagent/android/gpuimage/GPUImage.java
@@ -100,6 +100,17 @@ public void setGLSurfaceView(final GLSurfaceView view) {
         mGlSurfaceView.requestRender();
     }
 
+    /**
+     * Sets the background color
+     *
+     * @param red red color value
+     * @param green green color value
+     * @param blue red color value
+     */
+    public void setBackgroundColor(float red, float green, float blue) {
+        mRenderer.setBackgroundColor(red, green, blue);
+    }
+
     /**
      * Request the preview to be rendered again.
      */
@@ -201,6 +212,15 @@ public void setRotation(Rotation rotation) {
         mRenderer.setRotation(rotation);
     }
 
+    /**
+     * Sets the rotation of the displayed image with flip options.
+     *
+     * @param rotation new rotation
+     */
+    public void setRotation(Rotation rotation, boolean flipHorizontal, boolean flipVertical) {
+        mRenderer.setRotation(rotation, flipHorizontal, flipVertical);
+    }
+
     /**
      * Deletes the current image.
      */
diff --git a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageBilateralFilter.java b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageBilateralFilter.java
new file mode 100644
index 00000000..275253ab
--- /dev/null
+++ b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageBilateralFilter.java
@@ -0,0 +1,155 @@
+/**
+ * @author wysaid
+ * @mail admin@wysaid.org
+ *
+*/
+
+package jp.co.cyberagent.android.gpuimage;
+
+import android.opengl.GLES20;
+
+
+public class GPUImageBilateralFilter extends GPUImageFilter {
+	public static final String BILATERAL_VERTEX_SHADER = "" +
+			"attribute vec4 position;\n" + 
+			"attribute vec4 inputTextureCoordinate;\n" + 
+	 
+			"const int GAUSSIAN_SAMPLES = 9;\n" + 
+	 
+			"uniform vec2 singleStepOffset;\n" +  
+	 
+			"varying vec2 textureCoordinate;\n" + 
+			"varying vec2 blurCoordinates[GAUSSIAN_SAMPLES];\n" + 
+	 
+			"void main()\n" + 
+			"{\n" + 
+	     	"	gl_Position = position;\n" + 
+			"	textureCoordinate = inputTextureCoordinate.xy;\n" + 
+	     
+			"	int multiplier = 0;\n" + 
+			"	vec2 blurStep;\n" +  
+	     
+			"	for (int i = 0; i < GAUSSIAN_SAMPLES; i++)\n" + 
+	     	"	{\n" + 
+	        "		multiplier = (i - ((GAUSSIAN_SAMPLES - 1) / 2));\n" + 
+	        
+	        "		blurStep = float(multiplier) * singleStepOffset;\n" + 
+	        "		blurCoordinates[i] = inputTextureCoordinate.xy + blurStep;\n" + 
+	     	"	}\n" + 
+	 		"}";
+
+	public static final String BILATERAL_FRAGMENT_SHADER = "" + 
+			"uniform sampler2D inputImageTexture;\n" +
+
+			" const lowp int GAUSSIAN_SAMPLES = 9;\n" +
+
+			" varying highp vec2 textureCoordinate;\n" +
+			" varying highp vec2 blurCoordinates[GAUSSIAN_SAMPLES];\n" +
+
+			" uniform mediump float distanceNormalizationFactor;\n" +
+
+			" void main()\n" +
+			" {\n" +
+			"     lowp vec4 centralColor;\n" +
+			"     lowp float gaussianWeightTotal;\n" +
+			"     lowp vec4 sum;\n" +
+			"     lowp vec4 sampleColor;\n" +
+			"     lowp float distanceFromCentralColor;\n" +
+			"     lowp float gaussianWeight;\n" +
+			"     \n" +
+			"     centralColor = texture2D(inputImageTexture, blurCoordinates[4]);\n" +
+			"     gaussianWeightTotal = 0.18;\n" +
+			"     sum = centralColor * 0.18;\n" +
+			"     \n" +
+			"     sampleColor = texture2D(inputImageTexture, blurCoordinates[0]);\n" +
+			"     distanceFromCentralColor = min(distance(centralColor, sampleColor) * distanceNormalizationFactor, 1.0);\n" +
+			"     gaussianWeight = 0.05 * (1.0 - distanceFromCentralColor);\n" +
+			"     gaussianWeightTotal += gaussianWeight;\n" +
+			"     sum += sampleColor * gaussianWeight;\n" +
+
+			"     sampleColor = texture2D(inputImageTexture, blurCoordinates[1]);\n" +
+			"     distanceFromCentralColor = min(distance(centralColor, sampleColor) * distanceNormalizationFactor, 1.0);\n" +
+			"     gaussianWeight = 0.09 * (1.0 - distanceFromCentralColor);\n" +
+			"     gaussianWeightTotal += gaussianWeight;\n" +
+			"     sum += sampleColor * gaussianWeight;\n" +
+
+			"     sampleColor = texture2D(inputImageTexture, blurCoordinates[2]);\n" +
+			"     distanceFromCentralColor = min(distance(centralColor, sampleColor) * distanceNormalizationFactor, 1.0);\n" +
+			"     gaussianWeight = 0.12 * (1.0 - distanceFromCentralColor);\n" +
+			"     gaussianWeightTotal += gaussianWeight;\n" +
+			"     sum += sampleColor * gaussianWeight;\n" +
+
+			"     sampleColor = texture2D(inputImageTexture, blurCoordinates[3]);\n" +
+			"     distanceFromCentralColor = min(distance(centralColor, sampleColor) * distanceNormalizationFactor, 1.0);\n" +
+			"     gaussianWeight = 0.15 * (1.0 - distanceFromCentralColor);\n" +
+			"     gaussianWeightTotal += gaussianWeight;\n" +
+			"     sum += sampleColor * gaussianWeight;\n" +
+
+			"     sampleColor = texture2D(inputImageTexture, blurCoordinates[5]);\n" +
+			"     distanceFromCentralColor = min(distance(centralColor, sampleColor) * distanceNormalizationFactor, 1.0);\n" +
+			"     gaussianWeight = 0.15 * (1.0 - distanceFromCentralColor);\n" +
+			"     gaussianWeightTotal += gaussianWeight;\n" +
+			"     sum += sampleColor * gaussianWeight;\n" +
+
+			"     sampleColor = texture2D(inputImageTexture, blurCoordinates[6]);\n" +
+			"     distanceFromCentralColor = min(distance(centralColor, sampleColor) * distanceNormalizationFactor, 1.0);\n" +
+			"     gaussianWeight = 0.12 * (1.0 - distanceFromCentralColor);\n" +
+			"     gaussianWeightTotal += gaussianWeight;\n" +
+			"     sum += sampleColor * gaussianWeight;\n" +
+
+			"     sampleColor = texture2D(inputImageTexture, blurCoordinates[7]);\n" +
+			"     distanceFromCentralColor = min(distance(centralColor, sampleColor) * distanceNormalizationFactor, 1.0);\n" +
+			"     gaussianWeight = 0.09 * (1.0 - distanceFromCentralColor);\n" +
+			"     gaussianWeightTotal += gaussianWeight;\n" +
+			"     sum += sampleColor * gaussianWeight;\n" +
+
+			"     sampleColor = texture2D(inputImageTexture, blurCoordinates[8]);\n" +
+			"     distanceFromCentralColor = min(distance(centralColor, sampleColor) * distanceNormalizationFactor, 1.0);\n" +
+			"     gaussianWeight = 0.05 * (1.0 - distanceFromCentralColor);\n" +
+			"     gaussianWeightTotal += gaussianWeight;\n" +
+			"     sum += sampleColor * gaussianWeight;\n" +
+			"     gl_FragColor = sum / gaussianWeightTotal;\n" +
+//			" gl_FragColor.r = distanceNormalizationFactor / 20.0;" + 
+			" }";
+
+	private float mDistanceNormalizationFactor;
+	private int mDisFactorLocation;
+	private int mSingleStepOffsetLocation;
+	
+	public GPUImageBilateralFilter() {
+		this(8.0f);
+	}
+	
+	public GPUImageBilateralFilter(final float distanceNormalizationFactor) {
+		super(BILATERAL_VERTEX_SHADER, BILATERAL_FRAGMENT_SHADER);
+		mDistanceNormalizationFactor = distanceNormalizationFactor;
+	}
+	
+	@Override
+	public void onInit() {
+		super.onInit();
+		mDisFactorLocation = GLES20.glGetUniformLocation(getProgram(), "distanceNormalizationFactor");
+		mSingleStepOffsetLocation = GLES20.glGetUniformLocation(getProgram(), "singleStepOffset");
+	}
+	
+	@Override
+	public void onInitialized() {
+		super.onInitialized();
+		setDistanceNormalizationFactor(mDistanceNormalizationFactor);
+	}
+	
+	public void setDistanceNormalizationFactor(final float newValue) {
+		mDistanceNormalizationFactor = newValue;
+		setFloat(mDisFactorLocation, newValue);
+	}
+	
+	private void setTexelSize(final float w, final float h) {
+		setFloatVec2(mSingleStepOffsetLocation, new float[] {1.0f / w, 1.0f / h});
+	}
+	
+	@Override
+    public void onOutputSizeChanged(final int width, final int height) {
+        super.onOutputSizeChanged(width, height);
+        setTexelSize(width, height);
+    }
+}
diff --git a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageChromaKeyBlendFilter.java b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageChromaKeyBlendFilter.java
index c5adf8f4..7957b05a 100644
--- a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageChromaKeyBlendFilter.java
+++ b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageChromaKeyBlendFilter.java
@@ -22,47 +22,32 @@
  * Selectively replaces a color in the first image with the second image
  */
 public class GPUImageChromaKeyBlendFilter extends GPUImageTwoInputFilter {
-    public static final String CHROMA_KEY_BLEND_FRAGMENT_SHADER = "varying highp vec2 textureCoordinate;\n" +
-            " varying highp vec2 textureCoordinate2;\n" +
+    public static final String CHROMA_KEY_BLEND_FRAGMENT_SHADER = " precision highp float;\n" +
             " \n" +
+            " varying highp vec2 textureCoordinate;\n" +
+            " varying highp vec2 textureCoordinate2;\n" +
+            "\n" +
+            " uniform float thresholdSensitivity;\n" +
+            " uniform float smoothing;\n" +
+            " uniform vec3 colorToReplace;\n" +
             " uniform sampler2D inputImageTexture;\n" +
             " uniform sampler2D inputImageTexture2;\n" +
             " \n" +
-            " highp float lum(lowp vec3 c) {\n" +
-            "     return dot(c, vec3(0.3, 0.59, 0.11));\n" +
-            " }\n" +
-            " \n" +
-            " lowp vec3 clipcolor(lowp vec3 c) {\n" +
-            "     highp float l = lum(c);\n" +
-            "     lowp float n = min(min(c.r, c.g), c.b);\n" +
-            "     lowp float x = max(max(c.r, c.g), c.b);\n" +
-            "     \n" +
-            "     if (n < 0.0) {\n" +
-            "         c.r = l + ((c.r - l) * l) / (l - n);\n" +
-            "         c.g = l + ((c.g - l) * l) / (l - n);\n" +
-            "         c.b = l + ((c.b - l) * l) / (l - n);\n" +
-            "     }\n" +
-            "     if (x > 1.0) {\n" +
-            "         c.r = l + ((c.r - l) * (1.0 - l)) / (x - l);\n" +
-            "         c.g = l + ((c.g - l) * (1.0 - l)) / (x - l);\n" +
-            "         c.b = l + ((c.b - l) * (1.0 - l)) / (x - l);\n" +
-            "     }\n" +
-            "     \n" +
-            "     return c;\n" +
-            " }\n" +
-            "\n" +
-            " lowp vec3 setlum(lowp vec3 c, highp float l) {\n" +
-            "     highp float d = l - lum(c);\n" +
-            "     c = c + vec3(d);\n" +
-            "     return clipcolor(c);\n" +
-            " }\n" +
-            " \n" +
             " void main()\n" +
             " {\n" +
-            "   highp vec4 baseColor = texture2D(inputImageTexture, textureCoordinate);\n" +
-            "   highp vec4 overlayColor = texture2D(inputImageTexture2, textureCoordinate2);\n" +
-            "\n" +
-            "     gl_FragColor = vec4(baseColor.rgb * (1.0 - overlayColor.a) + setlum(overlayColor.rgb, lum(baseColor.rgb)) * overlayColor.a, baseColor.a);\n" +
+            "     vec4 textureColor = texture2D(inputImageTexture, textureCoordinate);\n" +
+            "     vec4 textureColor2 = texture2D(inputImageTexture2, textureCoordinate2);\n" +
+            "     \n" +
+            "     float maskY = 0.2989 * colorToReplace.r + 0.5866 * colorToReplace.g + 0.1145 * colorToReplace.b;\n" +
+            "     float maskCr = 0.7132 * (colorToReplace.r - maskY);\n" +
+            "     float maskCb = 0.5647 * (colorToReplace.b - maskY);\n" +
+            "     \n" +
+            "     float Y = 0.2989 * textureColor.r + 0.5866 * textureColor.g + 0.1145 * textureColor.b;\n" +
+            "     float Cr = 0.7132 * (textureColor.r - Y);\n" +
+            "     float Cb = 0.5647 * (textureColor.b - Y);\n" +
+            "     \n" +
+            "     float blendValue = 1.0 - smoothstep(thresholdSensitivity, thresholdSensitivity + smoothing, distance(vec2(Cr, Cb), vec2(maskCr, maskCb)));\n" +
+            "     gl_FragColor = mix(textureColor, textureColor2, blendValue);\n" +
             " }";
 
     private int mThresholdSensitivityLocation;
diff --git a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageHalftoneFilter.java b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageHalftoneFilter.java
new file mode 100644
index 00000000..52e27d04
--- /dev/null
+++ b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageHalftoneFilter.java
@@ -0,0 +1,67 @@
+package jp.co.cyberagent.android.gpuimage;
+
+import android.opengl.GLES20;
+
+public class GPUImageHalftoneFilter extends GPUImageFilter {
+    public static final String HALFTONE_FRAGMENT_SHADER = "" +
+            "varying highp vec2 textureCoordinate;\n" +
+
+            "uniform sampler2D inputImageTexture;\n" +
+
+            "uniform highp float fractionalWidthOfPixel;\n" +
+            "uniform highp float aspectRatio;\n" +
+
+            "const highp vec3 W = vec3(0.2125, 0.7154, 0.0721);\n" +
+
+            "void main()\n" +
+            "{\n" +
+            "  highp vec2 sampleDivisor = vec2(fractionalWidthOfPixel, fractionalWidthOfPixel / aspectRatio);\n" +
+            "  highp vec2 samplePos = textureCoordinate - mod(textureCoordinate, sampleDivisor) + 0.5 * sampleDivisor;\n" +
+            "  highp vec2 textureCoordinateToUse = vec2(textureCoordinate.x, (textureCoordinate.y * aspectRatio + 0.5 - 0.5 * aspectRatio));\n" +
+            "  highp vec2 adjustedSamplePos = vec2(samplePos.x, (samplePos.y * aspectRatio + 0.5 - 0.5 * aspectRatio));\n" +
+            "  highp float distanceFromSamplePoint = distance(adjustedSamplePos, textureCoordinateToUse);\n" +
+            "  lowp vec3 sampledColor = texture2D(inputImageTexture, samplePos).rgb;\n" +
+            "  highp float dotScaling = 1.0 - dot(sampledColor, W);\n" +
+            "  lowp float checkForPresenceWithinDot = 1.0 - step(distanceFromSamplePoint, (fractionalWidthOfPixel * 0.5) * dotScaling);\n" +
+            "  gl_FragColor = vec4(vec3(checkForPresenceWithinDot), 1.0);\n" +
+            "}";
+
+    private int mFractionalWidthOfPixelLocation;
+    private int mAspectRatioLocation;
+
+    private float mFractionalWidthOfAPixel;
+    private float mAspectRatio;
+
+    public GPUImageHalftoneFilter() {
+        this(0.01f);
+    }
+
+    public GPUImageHalftoneFilter(float fractionalWidthOfAPixel) {
+        super(NO_FILTER_VERTEX_SHADER, HALFTONE_FRAGMENT_SHADER);
+        mFractionalWidthOfAPixel = fractionalWidthOfAPixel;
+    }
+
+    @Override
+    public void onInit() {
+        super.onInit();
+        mFractionalWidthOfPixelLocation = GLES20.glGetUniformLocation(getProgram(), "fractionalWidthOfPixel");
+        mAspectRatioLocation = GLES20.glGetUniformLocation(getProgram(), "aspectRatio");
+        setFractionalWidthOfAPixel(mFractionalWidthOfAPixel);
+    }
+
+    @Override
+    public void onOutputSizeChanged(final int width, final int height) {
+        super.onOutputSizeChanged(width, height);
+        setAspectRatio((float)height / (float) width);
+    }
+
+    public void setFractionalWidthOfAPixel(final float fractionalWidthOfAPixel) {
+        mFractionalWidthOfAPixel = fractionalWidthOfAPixel;
+        setFloat(mFractionalWidthOfPixelLocation, mFractionalWidthOfAPixel);
+    }
+
+    public void setAspectRatio(final float aspectRatio) {
+        mAspectRatio = aspectRatio;
+        setFloat(mAspectRatioLocation, mAspectRatio);
+    }
+}
diff --git a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageLookupFilter.java b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageLookupFilter.java
index b9cfa2be..42c9ebdc 100644
--- a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageLookupFilter.java
+++ b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageLookupFilter.java
@@ -16,6 +16,8 @@
 
 package jp.co.cyberagent.android.gpuimage;
 
+import android.opengl.GLES20;
+
 public class GPUImageLookupFilter extends GPUImageTwoInputFilter {
 
     public static final String LOOKUP_FRAGMENT_SHADER = "varying highp vec2 textureCoordinate;\n" +
@@ -24,17 +26,19 @@
             " uniform sampler2D inputImageTexture;\n" +
             " uniform sampler2D inputImageTexture2; // lookup texture\n" +
             " \n" +
+            " uniform lowp float intensity;\n" +
+            " \n" +
             " void main()\n" +
             " {\n" +
-            "     lowp vec4 textureColor = texture2D(inputImageTexture, textureCoordinate);\n" +
+            "     highp vec4 textureColor = texture2D(inputImageTexture, textureCoordinate);\n" +
             "     \n" +
-            "     mediump float blueColor = textureColor.b * 63.0;\n" +
+            "     highp float blueColor = textureColor.b * 63.0;\n" +
             "     \n" +
-            "     mediump vec2 quad1;\n" +
+            "     highp vec2 quad1;\n" +
             "     quad1.y = floor(floor(blueColor) / 8.0);\n" +
             "     quad1.x = floor(blueColor) - (quad1.y * 8.0);\n" +
             "     \n" +
-            "     mediump vec2 quad2;\n" +
+            "     highp vec2 quad2;\n" +
             "     quad2.y = floor(ceil(blueColor) / 8.0);\n" +
             "     quad2.x = ceil(blueColor) - (quad2.y * 8.0);\n" +
             "     \n" +
@@ -50,11 +54,35 @@
             "     lowp vec4 newColor2 = texture2D(inputImageTexture2, texPos2);\n" +
             "     \n" +
             "     lowp vec4 newColor = mix(newColor1, newColor2, fract(blueColor));\n" +
-            "     gl_FragColor = vec4(newColor.rgb, textureColor.w);\n" +
+            "     gl_FragColor = mix(textureColor, vec4(newColor.rgb, textureColor.w), intensity);\n" +
             " }";
 
+    private int mIntensityLocation;
+    private float mIntensity;
 
     public GPUImageLookupFilter() {
+        this(1.0f);
+    }
+
+    public GPUImageLookupFilter(final float intensity) {
         super(LOOKUP_FRAGMENT_SHADER);
+        mIntensity = intensity;
+    }
+
+    @Override
+    public void onInit() {
+        super.onInit();
+        mIntensityLocation = GLES20.glGetUniformLocation(getProgram(), "intensity");
+    }
+
+    @Override
+    public void onInitialized() {
+        super.onInitialized();
+        setIntensity(mIntensity);
+    }
+
+    public void setIntensity(final float intensity) {
+        mIntensity = intensity;
+        setFloat(mIntensityLocation, mIntensity);
     }
 }
diff --git a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageRenderer.java b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageRenderer.java
index 9565b71c..691550bd 100644
--- a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageRenderer.java
+++ b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageRenderer.java
@@ -73,6 +73,10 @@
     private boolean mFlipVertical;
     private GPUImage.ScaleType mScaleType = GPUImage.ScaleType.CENTER_CROP;
 
+    private float mBackgroundRed = 0;
+    private float mBackgroundGreen = 0;
+    private float mBackgroundBlue = 0;
+
     public GPUImageRenderer(final GPUImageFilter filter) {
         mFilter = filter;
         mRunOnDraw = new LinkedList<Runnable>();
@@ -91,7 +95,7 @@ public GPUImageRenderer(final GPUImageFilter filter) {
 
     @Override
     public void onSurfaceCreated(final GL10 unused, final EGLConfig config) {
-        GLES20.glClearColor(0, 0, 0, 1);
+        GLES20.glClearColor(mBackgroundRed, mBackgroundGreen, mBackgroundBlue, 1);
         GLES20.glDisable(GLES20.GL_DEPTH_TEST);
         mFilter.init();
     }
@@ -120,6 +124,19 @@ public void onDrawFrame(final GL10 gl) {
         }
     }
 
+    /**
+     * Sets the background color
+     *
+     * @param red red color value
+     * @param green green color value
+     * @param blue red color value
+     */
+    public void setBackgroundColor(float red, float green, float blue) {
+        mBackgroundRed = red;
+        mBackgroundGreen = green;
+        mBackgroundBlue = blue;
+    }
+
     private void runAll(Queue<Runnable> queue) {
         synchronized (queue) {
             while (!queue.isEmpty()) {
diff --git a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageTransformFilter.java b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageTransformFilter.java
new file mode 100644
index 00000000..0a962cc5
--- /dev/null
+++ b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageTransformFilter.java
@@ -0,0 +1,134 @@
+package jp.co.cyberagent.android.gpuimage;
+
+import android.opengl.GLES20;
+import android.opengl.Matrix;
+
+import java.nio.ByteBuffer;
+import java.nio.ByteOrder;
+import java.nio.FloatBuffer;
+
+public class GPUImageTransformFilter extends GPUImageFilter {
+    public static final String TRANSFORM_VERTEX_SHADER = "" +
+            "attribute vec4 position;\n" +
+            " attribute vec4 inputTextureCoordinate;\n" +
+            " \n" +
+            " uniform mat4 transformMatrix;\n" +
+            " uniform mat4 orthographicMatrix;\n" +
+            " \n" +
+            " varying vec2 textureCoordinate;\n" +
+            " \n" +
+            " void main()\n" +
+            " {\n" +
+            "     gl_Position = transformMatrix * vec4(position.xyz, 1.0) * orthographicMatrix;\n" +
+            "     textureCoordinate = inputTextureCoordinate.xy;\n" +
+            " }";
+
+    private int transformMatrixUniform;
+    private int orthographicMatrixUniform;
+    private float[] orthographicMatrix;
+
+    private float[] transform3D;
+
+    // This applies the transform to the raw frame data if set to YES, the default of NO takes the aspect ratio of the image input into account when rotating
+    private boolean ignoreAspectRatio;
+
+    // sets the anchor point to top left corner
+    private boolean anchorTopLeft;
+
+    public GPUImageTransformFilter() {
+        super(TRANSFORM_VERTEX_SHADER, NO_FILTER_FRAGMENT_SHADER);
+
+        orthographicMatrix = new float[16];
+        Matrix.orthoM(orthographicMatrix, 0, -1.0f, 1.0f, -1.0f, 1.0f, -1.0f, 1.0f);
+
+        transform3D = new float[16];
+        Matrix.setIdentityM(transform3D, 0);
+    }
+
+    @Override
+    public void onInit() {
+        super.onInit();
+        transformMatrixUniform = GLES20.glGetUniformLocation(getProgram(), "transformMatrix");
+        orthographicMatrixUniform = GLES20.glGetUniformLocation(getProgram(), "orthographicMatrix");
+
+        setUniformMatrix4f(transformMatrixUniform, transform3D);
+        setUniformMatrix4f(orthographicMatrixUniform, orthographicMatrix);
+    }
+
+    @Override
+    public void onInitialized() {
+        super.onInitialized();
+    }
+
+    @Override
+    public void onOutputSizeChanged(final int width, final int height) {
+        super.onOutputSizeChanged(width, height);
+
+        if (!ignoreAspectRatio) {
+            Matrix.orthoM(orthographicMatrix, 0, -1.0f, 1.0f, -1.0f * (float) height / (float) width, 1.0f * (float) height / (float) width, -1.0f, 1.0f);
+            setUniformMatrix4f(orthographicMatrixUniform, orthographicMatrix);
+        }
+    }
+
+    @Override
+    public void onDraw(final int textureId, final FloatBuffer cubeBuffer,
+                       final FloatBuffer textureBuffer) {
+
+        FloatBuffer vertBuffer = cubeBuffer;
+
+        if (!ignoreAspectRatio) {
+
+            float[] adjustedVertices = new float[8];
+
+            cubeBuffer.position(0);
+            cubeBuffer.get(adjustedVertices);
+
+            float normalizedHeight = (float) getOutputHeight() / (float) getOutputWidth();
+            adjustedVertices[1] *= normalizedHeight;
+            adjustedVertices[3] *= normalizedHeight;
+            adjustedVertices[5] *= normalizedHeight;
+            adjustedVertices[7] *= normalizedHeight;
+
+            vertBuffer = ByteBuffer.allocateDirect(adjustedVertices.length * 4)
+                    .order(ByteOrder.nativeOrder())
+                    .asFloatBuffer();
+
+            vertBuffer.put(adjustedVertices).position(0);
+        }
+
+        super.onDraw(textureId, vertBuffer, textureBuffer);
+    }
+
+    public void setTransform3D(float[] transform3D) {
+        this.transform3D = transform3D;
+        setUniformMatrix4f(transformMatrixUniform, transform3D);
+    }
+
+    public float[] getTransform3D() {
+        return transform3D;
+    }
+
+    public void setIgnoreAspectRatio(boolean ignoreAspectRatio) {
+        this.ignoreAspectRatio = ignoreAspectRatio;
+
+        if (ignoreAspectRatio) {
+            Matrix.orthoM(orthographicMatrix, 0, -1.0f, 1.0f, -1.0f, 1.0f, -1.0f, 1.0f);
+            setUniformMatrix4f(orthographicMatrixUniform, orthographicMatrix);
+        } else {
+            onOutputSizeChanged(getOutputWidth(), getOutputHeight());
+        }
+    }
+
+    public boolean ignoreAspectRatio() {
+        return ignoreAspectRatio;
+    }
+
+    public void setAnchorTopLeft(boolean anchorTopLeft) {
+        this.anchorTopLeft = anchorTopLeft;
+        setIgnoreAspectRatio(ignoreAspectRatio);
+    }
+
+    public boolean anchorTopLeft() {
+        return anchorTopLeft;
+    }
+}
diff --git a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageView.java b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageView.java
index ff32e5db..cc6a0247 100644
--- a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageView.java
+++ b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageView.java
@@ -19,6 +19,8 @@
 import android.content.Context;
 import android.graphics.Bitmap;
 import android.graphics.Color;
+import android.graphics.drawable.ColorDrawable;
+import android.graphics.drawable.Drawable;
 import android.media.MediaScannerConnection;
 import android.net.Uri;
 import android.opengl.GLES20;
@@ -94,6 +96,17 @@ public GPUImage getGPUImage() {
         return mGPUImage;
     }
 
+    /**
+     * Sets the background color
+     *
+     * @param red red color value
+     * @param green green color value
+     * @param blue red color value
+     */
+    public void setBackgroundColor(float red, float green, float blue) {
+        mGPUImage.setBackgroundColor(red, green, blue);
+    }
+
     // TODO Should be an xml attribute. But then GPUImage can not be distributed as .jar anymore.
     public void setRatio(float ratio) {
         mRatio = ratio;
diff --git a/library/src/jp/co/cyberagent/android/gpuimage/PixelBuffer.java b/library/src/jp/co/cyberagent/android/gpuimage/PixelBuffer.java
index 45317a13..ac23f599 100644
--- a/library/src/jp/co/cyberagent/android/gpuimage/PixelBuffer.java
+++ b/library/src/jp/co/cyberagent/android/gpuimage/PixelBuffer.java
@@ -194,6 +194,7 @@ private void convertToBitmap() {
         mGL.glReadPixels(0, 0, mWidth, mHeight, GL_RGBA, GL_UNSIGNED_BYTE, ib);
         int[] ia = ib.array();
 
+        //Stupid !
         // Convert upside down mirror-reversed image to right-side up normal
         // image.
         for (int i = 0; i < mHeight; i++) {
diff --git a/sample/.gitignore b/sample/.gitignore
deleted file mode 100644
index 85e23b43..00000000
--- a/sample/.gitignore
+++ /dev/null
@@ -1,32 +0,0 @@
-#Android generated
-bin
-gen
-obj
-
-#Eclipse
-#.project
-#.classpath
-.settings
-
-#IntelliJ IDEA
-.idea
-*.iml
-*.ipr
-*.iws
-out
-
-#Checkstyle
-.checkstyle
-
-#Maven
-target
-release.properties
-pom.xml.*
-
-#Ant
-build.xml
-local.properties
-proguard.cfg
-
-#OSX
-.DS_Store
diff --git a/sample/AndroidManifest.xml b/sample/AndroidManifest.xml
index 0987d489..855b72c5 100644
--- a/sample/AndroidManifest.xml
+++ b/sample/AndroidManifest.xml
@@ -11,6 +11,7 @@
         android:allowBackup="true"
         android:hardwareAccelerated="true"
         android:icon="@drawable/ic_launcher"
+        android:largeHeap="true"
         android:label="@string/app_name"
         android:theme="@style/AppTheme" >
         <activity
diff --git a/sample/build.gradle b/sample/build.gradle
index 5057072e..f64f4a42 100644
--- a/sample/build.gradle
+++ b/sample/build.gradle
@@ -34,6 +34,6 @@ repositories {
 
 dependencies {
     compile project(':library')
-//    compile 'jp.co.cyberagent.android.gpuimage:gpuimage-library:+@aar'
-    compile 'com.android.support:support-v4:21.+'
+//    compile 'jp.co.cyberagent.android.gpuimage:gpuimage-library:1.4.1'
+    compile 'com.android.support:support-v4:23.1.1'
 }
\ No newline at end of file
diff --git a/sample/src/jp/co/cyberagent/android/gpuimage/sample/GPUImageFilterTools.java b/sample/src/jp/co/cyberagent/android/gpuimage/sample/GPUImageFilterTools.java
index e344fd23..6f2f6dd4 100644
--- a/sample/src/jp/co/cyberagent/android/gpuimage/sample/GPUImageFilterTools.java
+++ b/sample/src/jp/co/cyberagent/android/gpuimage/sample/GPUImageFilterTools.java
@@ -21,12 +21,14 @@
 import android.content.DialogInterface;
 import android.graphics.BitmapFactory;
 import android.graphics.PointF;
+import android.opengl.Matrix;
+
 import jp.co.cyberagent.android.gpuimage.*;
 
 import java.util.LinkedList;
 import java.util.List;
 
-public class GPUImageFilterTools {  
+public class GPUImageFilterTools {
     public static void showDialog(final Context context,
             final OnGpuImageFilterChosenListener listener) {
         final FilterList filters = new FilterList();
@@ -91,6 +93,7 @@ public static void showDialog(final Context context,
         filters.addFilter("Sketch", FilterType.SKETCH);
         filters.addFilter("Toon", FilterType.TOON);
         filters.addFilter("Smooth Toon", FilterType.SMOOTH_TOON);
+        filters.addFilter("Halftone", FilterType.HALFTONE);
 
         filters.addFilter("Bulge Distortion", FilterType.BULGE_DISTORTION);
         filters.addFilter("Glass Sphere", FilterType.GLASS_SPHERE);
@@ -106,6 +109,11 @@ public static void showDialog(final Context context,
 
         filters.addFilter("Levels Min (Mid Adjust)", FilterType.LEVELS_FILTER_MIN);
 
+        filters. addFilter("Bilateral Blur", FilterType.BILATERAL_BLUR);
+
+        filters.addFilter("Transform (2-D)", FilterType.TRANSFORM2D);
+
+
         AlertDialog.Builder builder = new AlertDialog.Builder(context);
         builder.setTitle("Choose a filter");
         builder.setItems(filters.names.toArray(new String[filters.names.size()]),
@@ -170,11 +178,11 @@ private static GPUImageFilter createFilterForType(final Context context, final F
             case MONOCHROME:
             	return new GPUImageMonochromeFilter(1.0f, new float[]{0.6f, 0.45f, 0.3f, 1.0f});
             case OPACITY:
-                return new GPUImageOpacityFilter(1.0f);  
+                return new GPUImageOpacityFilter(1.0f);
             case RGB:
-                return new GPUImageRGBFilter(1.0f, 1.0f, 1.0f);  
+                return new GPUImageRGBFilter(1.0f, 1.0f, 1.0f);
             case WHITE_BALANCE:
-                return new GPUImageWhiteBalanceFilter(5000.0f, 0.0f);    
+                return new GPUImageWhiteBalanceFilter(5000.0f, 0.0f);
             case VIGNETTE:
                 PointF centerPoint = new PointF();
                 centerPoint.x = 0.5f;
@@ -286,6 +294,14 @@ private static GPUImageFilter createFilterForType(final Context context, final F
                 GPUImageLevelsFilter levelsFilter = new GPUImageLevelsFilter();
                 levelsFilter.setMin(0.0f, 3.0f, 1.0f);
                 return levelsFilter;
+            case HALFTONE:
+                return new GPUImageHalftoneFilter();
+
+            case BILATERAL_BLUR:
+                return new GPUImageBilateralFilter();
+
+            case TRANSFORM2D:
+                return new GPUImageTransformFilter();
 
             default:
                 throw new IllegalStateException("No filter of that type!");
@@ -314,7 +330,7 @@ private static GPUImageFilter createBlendFilter(Context context, Class<? extends
         BLEND_DISSOLVE, BLEND_EXCLUSION, BLEND_SOURCE_OVER, BLEND_HARD_LIGHT, BLEND_LIGHTEN, BLEND_ADD, BLEND_DIVIDE, BLEND_MULTIPLY, BLEND_OVERLAY, BLEND_SCREEN, BLEND_ALPHA,
         BLEND_COLOR, BLEND_HUE, BLEND_SATURATION, BLEND_LUMINOSITY, BLEND_LINEAR_BURN, BLEND_SOFT_LIGHT, BLEND_SUBTRACT, BLEND_CHROMA_KEY, BLEND_NORMAL, LOOKUP_AMATORKA,
         GAUSSIAN_BLUR, CROSSHATCH, BOX_BLUR, CGA_COLORSPACE, DILATION, KUWAHARA, RGB_DILATION, SKETCH, TOON, SMOOTH_TOON, BULGE_DISTORTION, GLASS_SPHERE, HAZE, LAPLACIAN, NON_MAXIMUM_SUPPRESSION,
-        SPHERE_REFRACTION, SWIRL, WEAK_PIXEL_INCLUSION, FALSE_COLOR, COLOR_BALANCE, LEVELS_FILTER_MIN
+        SPHERE_REFRACTION, SWIRL, WEAK_PIXEL_INCLUSION, FALSE_COLOR, COLOR_BALANCE, LEVELS_FILTER_MIN, BILATERAL_BLUR, HALFTONE, TRANSFORM2D
     }
 
     private static class FilterList {
@@ -389,7 +405,13 @@ public FilterAdjuster(final GPUImageFilter filter) {
                 adjuster = new ColorBalanceAdjuster().filter(filter);
             } else if (filter instanceof GPUImageLevelsFilter) {
                 adjuster = new LevelsMinMidAdjuster().filter(filter);
-            } else {
+            } else if (filter instanceof GPUImageBilateralFilter) {
+                adjuster = new BilateralAdjuster().filter(filter);
+            } else if (filter instanceof GPUImageTransformFilter) {
+                adjuster = new RotateAdjuster().filter(filter);
+            }
+            else {
+
                 adjuster = null;
             }
         }
@@ -512,14 +534,14 @@ public void adjust(final int percentage) {
                 getFilter().setSaturation(range(percentage, 0.0f, 2.0f));
             }
         }
-        
+
         private class ExposureAdjuster extends Adjuster<GPUImageExposureFilter> {
             @Override
             public void adjust(final int percentage) {
                 getFilter().setExposure(range(percentage, -10.0f, 10.0f));
             }
-        }   
-        
+        }
+
         private class HighlightShadowAdjuster extends Adjuster<GPUImageHighlightShadowFilter> {
             @Override
             public void adjust(final int percentage) {
@@ -527,7 +549,7 @@ public void adjust(final int percentage) {
                 getFilter().setHighlights(range(percentage, 0.0f, 1.0f));
             }
         }
-        
+
         private class MonochromeAdjuster extends Adjuster<GPUImageMonochromeFilter> {
             @Override
             public void adjust(final int percentage) {
@@ -535,14 +557,14 @@ public void adjust(final int percentage) {
                 //getFilter().setColor(new float[]{0.6f, 0.45f, 0.3f, 1.0f});
             }
         }
-        
+
         private class OpacityAdjuster extends Adjuster<GPUImageOpacityFilter> {
             @Override
             public void adjust(final int percentage) {
                 getFilter().setOpacity(range(percentage, 0.0f, 1.0f));
             }
-        }   
-        
+        }
+
         private class RGBAdjuster extends Adjuster<GPUImageRGBFilter> {
             @Override
             public void adjust(final int percentage) {
@@ -550,8 +572,8 @@ public void adjust(final int percentage) {
                 //getFilter().setGreen(range(percentage, 0.0f, 1.0f));
                 //getFilter().setBlue(range(percentage, 0.0f, 1.0f));
             }
-        }   
-        
+        }
+
         private class WhiteBalanceAdjuster extends Adjuster<GPUImageWhiteBalanceFilter> {
             @Override
             public void adjust(final int percentage) {
@@ -640,8 +662,25 @@ public void adjust(int percentage) {
         private class LevelsMinMidAdjuster extends Adjuster<GPUImageLevelsFilter> {
             @Override
             public void adjust(int percentage) {
-                getFilter().setMin(0.0f, range(percentage, 0.0f, 1.0f) , 1.0f);
+                getFilter().setMin(0.0f, range(percentage, 0.0f, 1.0f), 1.0f);
+            }
+        }
+
+        private class BilateralAdjuster extends Adjuster<GPUImageBilateralFilter> {
+            @Override
+            public void adjust(final int percentage) {
+                getFilter().setDistanceNormalizationFactor(range(percentage, 0.0f, 15.0f));
             }
         }
+
+        private class RotateAdjuster extends Adjuster<GPUImageTransformFilter> {
+            @Override
+            public void adjust(final int percentage) {
+                float[] transform = new float[16];
+                Matrix.setRotateM(transform, 0, 360 * percentage / 100, 0, 0, 1.0f);
+                getFilter().setTransform3D(transform);
+            }
+        }
+
     }
 }
diff --git a/sample/src/jp/co/cyberagent/android/gpuimage/sample/activity/ActivityMain.java b/sample/src/jp/co/cyberagent/android/gpuimage/sample/activity/ActivityMain.java
index 0a1d7802..80600ee6 100644
--- a/sample/src/jp/co/cyberagent/android/gpuimage/sample/activity/ActivityMain.java
+++ b/sample/src/jp/co/cyberagent/android/gpuimage/sample/activity/ActivityMain.java
@@ -16,39 +16,56 @@
 
 package jp.co.cyberagent.android.gpuimage.sample.activity;
 
-import jp.co.cyberagent.android.gpuimage.sample.R;
+import android.Manifest;
 import android.app.Activity;
 import android.content.Intent;
+import android.content.pm.PackageManager;
 import android.os.Bundle;
+import android.support.v4.app.ActivityCompat;
+import android.support.v4.content.PermissionChecker;
 import android.view.View;
 import android.view.View.OnClickListener;
+import jp.co.cyberagent.android.gpuimage.sample.R;
 
 public class ActivityMain extends Activity implements OnClickListener {
 
-    @Override
-    public void onCreate(final Bundle savedInstanceState) {
+    @Override public void onCreate(final Bundle savedInstanceState) {
         super.onCreate(savedInstanceState);
         setContentView(R.layout.activity_main);
         findViewById(R.id.button_gallery).setOnClickListener(this);
         findViewById(R.id.button_camera).setOnClickListener(this);
     }
 
-    @Override
-    public void onClick(final View v) {
-        switch (v.getId()) {
+    @Override public void onClick(final View v) {
+        if (PermissionChecker.checkSelfPermission(this, Manifest.permission.CAMERA)
+            == PackageManager.PERMISSION_DENIED) {
+            ActivityCompat.requestPermissions(this, new String[] { Manifest.permission.CAMERA },
+                v.getId());
+        } else {
+            startActivity(v.getId());
+        }
+    }
+
+    @Override public void onRequestPermissionsResult(int requestCode, String[] permissions,
+        int[] grantResults) {
+        if (grantResults.length != 1 || grantResults[0] == PackageManager.PERMISSION_GRANTED) {
+            startActivity(requestCode);
+        } else {
+            super.onRequestPermissionsResult(requestCode, permissions, grantResults);
+        }
+    }
+
+    private void startActivity(int id) {
+        switch (id) {
             case R.id.button_gallery:
-                startActivity(ActivityGallery.class);
+                startActivity(new Intent(this, ActivityGallery.class));
                 break;
             case R.id.button_camera:
-                startActivity(ActivityCamera.class);
+                startActivity(new Intent(this, ActivityCamera.class));
                 break;
 
             default:
                 break;
         }
     }
-
-    private void startActivity(final Class<?> activityClass) {
-        startActivity(new Intent(this, activityClass));
-    }
 }
