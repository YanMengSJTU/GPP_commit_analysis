diff --git a/library/res/raw/droste.glsl b/library/res/raw/droste.glsl
new file mode 100644
index 00000000..53caca2c
--- /dev/null
+++ b/library/res/raw/droste.glsl
@@ -0,0 +1,65 @@
+// This implementation uses GLSL code by ArKano22:
+//uniform float globalTime;
+//uniform sampler2D inputImageTexture; // iChannel0 in Shadertoy
+//uniform vec2 sketchSize; // iResolution in Shadertoy
+
+const highp float globalTime = 150587.0;
+uniform sampler2D inputImageTexture; // iChannel0 in Shadertoy
+const highp vec2 sketchSize = vec2(400.0,400.0); // iResolution in Shadertoy
+
+const highp float TWO_PI = 3.141592*2.0;
+//ADJUSTABLE PARAMETERS:
+const highp float Branches = 1.0;
+const highp float scale = 0.5;
+//Complex Math:
+highp vec2 complexExp(in highp vec2 z){
+	return vec2(exp(z.x)*cos(z.y),exp(z.x)*sin(z.y));
+}
+highp vec2 complexLog(in highp vec2 z){
+	return vec2(log(length(z)), atan(z.y, z.x));
+}
+highp vec2 complexMult(in highp vec2 a,in highp vec2 b){
+	return vec2(a.x*b.x - a.y*b.y, a.x*b.y + a.y*b.x);
+}
+highp float complexMag(in highp vec2 z){
+	return float(pow(length(z), 2.0));
+}
+highp vec2 complexReciprocal(in highp vec2 z){
+	return vec2(z.x / complexMag(z), -z.y / complexMag(z));
+}
+highp vec2 complexDiv(in highp vec2 a,in highp vec2 b){
+	return complexMult(a, complexReciprocal(b));
+}
+highp vec2 complexPower(in highp vec2 a, in highp vec2 b){
+	return complexExp( complexMult(b,complexLog(a)));
+}
+//Misc Functions:
+highp float nearestPower(in highp float a, in highp float base){
+	return pow(base,  ceil(  log(abs(a))/log(base)  )-1.0 );
+}
+highp float map(highp float value, highp float istart, highp float istop, highp float ostart,highp  float ostop) {
+	   return ostart + (ostop - ostart) * ((value - istart) / (istop - istart));
+}
+
+void main( void ){
+
+	//SHIFT AND SCALE COORDINATES TO <-1,1>
+	highp vec2 uv=gl_FragCoord.xy/sketchSize.xy-.5;
+	uv.y*=sketchSize.y/sketchSize.x;
+
+	//ESCHER GRID TRANSFORM:
+	highp float factor = pow(1.0/scale,Branches);
+	uv= complexPower(uv, complexDiv(vec2( log(factor) ,TWO_PI), vec2(0.0,TWO_PI) ) );
+
+	//RECTANGULAR DROSTE EFFECT:
+	highp float FT = fract(globalTime);
+	FT = log(FT+1.)/log(2.);
+	uv *= 1.0+FT*(scale-1.0);
+
+    highp float npower = max(nearestPower(uv.x,scale),nearestPower(uv.y,scale));
+	uv.x = map(uv.x,-npower,npower,-1.0,1.0);
+	uv.y = map(uv.y,-npower,npower,-1.0,1.0);
+
+	//UNDO SHIFT AND SCALE:
+	gl_FragColor =  texture2D(inputImageTexture,-uv*0.5+vec2(0.5));
+}
diff --git a/library/res/raw/fire.glsl b/library/res/raw/fire.glsl
new file mode 100644
index 00000000..8fe2b2ab
--- /dev/null
+++ b/library/res/raw/fire.glsl
@@ -0,0 +1,137 @@
+uniform highp vec3      iResolution;           // viewport resolution (in pixels)
+uniform  highp float     iTime;                 // shader playback time (in seconds)
+//uniform float     iTimeDelta;            // render time (in seconds)
+//uniform highp  int       iFrame;                // shader playback frame
+//uniform  highp float     iChannelTime[4];       // channel playback time (in seconds)
+//uniform highp  vec3      iChannelResolution[4]; // channel resolution (in pixels)
+//uniform  highp vec4      iMouse;                // mouse pixel coords. xy: current (if MLB down), zw: click
+//uniform mediump sampler2D iChannel0;          // input channel. XX = 2D/Cube
+
+uniform sampler2D inputImageTexture;
+varying highp vec2 textureCoordinate;
+
+#define N(h) fract(sin(vec4(6,9,1,0)*h) * 9e2)
+
+//highp vec2 randomFloat(int i){
+//    return fract(sin(vec4(6,9,1,0)*i) * 9e2);
+//}
+
+void main(){
+//    gl_FragColor-=gl_FragColor;//重置像素颜色，不知道起什么作用
+    highp vec4 bg = texture2D(inputImageTexture, textureCoordinate);//先着个色
+    gl_FragColor += bg * .3;//变暗点
+    highp vec2 mCoor = textureCoordinate;//copy一份像素坐标
+//    mCoor /= iResolution.y;//做些骚操作，暂且保持不变
+    highp float e;
+    highp float d;//里层下标
+    highp float i=-2.;//外层下标，爆炸次数
+
+    for(highp vec4 p; i<9.; i++){// p 作为颜色向量
+        d = floor(e = i*9.1+iTime);//起个随机数的作用？
+        p = fract(sin(vec4(6,9,1,0)*d) * 9e2)+.3;//随机生成一个颜色向量
+        e -= d;
+        for(d = 0.;d < 20.;d++){//控制粒子数量求不卡（依然卡穿）
+            highp vec4 mFract1 = fract(sin(vec4(6,9,1,0)*d*i) * 9e2);
+//            这里用 += ，使像素在原色 + p 基础上进行亮度放大，实现效果
+//            有一个大基数 p ，使粒子颜色接近爆炸颜色
+            gl_FragColor += p*(1.-e) / 1e3 / length(mCoor-(p-e*(mFract1-.5)).xy);
+        }
+    }
+
+ }
+
+
+ /*
+ EXPLANATION OF HOW THIS WORKS
+
+
+ // turns 1 float into a pseudo random vec4 in the 0-1 range
+ #define N(h) fract(sin(vec4(6,9,1,0)*h) * 9e2)
+
+ void mainImage(out vec4 o,vec2 u )
+ {
+     //initialize o to 0,0,0,0 in the shortest way possible
+     // o is what will hold the final pixel color
+     o-=o;
+
+     // divide the uv pixel coordinates by the height to get aspect corrected 0-1 coords
+     u /= iResolution.y;
+
+     // loop iterator defined here because it saves characters
+     // starts at -2 so it goes through 0, which gives the occasional rocket
+     float e, d, i=-2.;
+
+     // outer loop, defines number of simultaneous explosions
+     // other var assignments inside of the for statement which
+     // saves chars on brackets around the for loop
+     // i++<9 which saves the i++; that usually goes at the end of the for
+     for(vec4 p; i++<9.;
+         // e = the time since the shader started + an offset per explosion
+         // d = the floored version of that, which stays the same for a second, then jumps
+         d = floor(e = i*9.1+iTime),
+         // the position of the explosion, as well as the color
+         // which is a pseudo random number made by throwing a large number into a sine function
+         // +.3 so the explosions are centered horizontally (because aspect ratio of screen)
+         p = N(d)+.3,
+         // turn e into the fractional component of time e.g. 10.546 -> 0.546
+         e -= d)
+         // inner loop, renders the particles in the explosion
+         for(d=0.; d++<50.;)
+             // add to final pixel col
+             // p = the color, 1.-e is a number that starts at 1 and goes to 0
+             // over the duration of the explosion, essentially fading the particle
+             o += p*(1.-e)
+             // divide by 1000, otherwise the pixel colors will get too bright
+             / 1e3
+             // divide by the distance to the particle, the farther away, the darker
+             // note that this never gets to 0, each tiny particle has an effect over the
+             // entire screen
+             // dist to particle is the length of the vector from the current uv coordinate (u)
+             // to the particle pos (p-e*(N(d*i)-.5)).xy
+             // particle pos starts at p, when e is 0
+             // N(d*i) gives a pseudo random vec4 in 0-1 range
+             // d*i to give different vec4 for each particle
+             // *i is not really necessary but when i=0 it gives 0 for the whole vec4
+             // which makes the appearance of the occasional rocket
+             // N(d*i)-.5 to go from 0-1 range to -.5 .5 range
+             / length(u-(p-e*(N(d*i)-.5)).xy);
+
+    // draw skyline
+    // uv.x goes from 0 to 1.6  *i to make it larger i=9. (save a char cuz 9. is 2 chars)
+    // +d+e   d+e = iTime  -> this will make the skyline scroll
+    // ceil to go in steps (stay at one height, then jump to the next)
+    // N(..) to make a value 0, 1, 2, 3.. etc into random numbers in 0-1 range
+    // .x*4   N returns a vec4, but we only need a float, *.4 so buildings are lower
+    // o -= o*u.y   o-=o would make the buildings pitch black, *u.y to fade them towards the
+    // bottom, creating a bit of a fog effect
+    if(u.y<N(ceil(u.x*i+d+e)).x*.4) o-=o*u.y;
+ }
+
+ */
+
+//void mainImage(out vec4 gl_FragColor,vec2 textureCoordinate )
+//{
+//    gl_FragColor-=gl_FragColor;
+//
+//    textureCoordinate /= iResolution.y;
+//
+//    float e, d, i=-2.;
+//
+//
+//    for(vec4 p; i<9.; i++){
+//        d = floor(e = i*9.1+iTime);
+//        p = mFract(d)+.3, e -= d;
+//        for(d = 0.;d < 50.;d++){
+//            gl_FragColor += p*(1.-e) / 1e3 / length(textureCoordinate-(p-e*(mFract(d*i)-.5)).xy);
+//        }
+//    }
+//
+//    if(textureCoordinate.y<mFract(ceil(textureCoordinate.x*i+d+e)).x*.4) gl_FragColor-=gl_FragColor*textureCoordinate.y;
+//
+////    for(vec4 p; i++<9.; d = floor(e = i*9.1+iTime),p = N(d)+.3, e -= d)
+////        for(d=0.; d++<50.;)
+////            o += p*(1.-e) / 1e3 / length(u-(p-e*(N(d*i)-.5)).xy);
+////
+////    if(u.y<N(ceil(u.x*i+d+e)).x*.4) o-=o*u.y;
+//}
+
diff --git a/library/res/values/test.xml b/library/res/values/test.xml
new file mode 100644
index 00000000..6aa4b305
--- /dev/null
+++ b/library/res/values/test.xml
@@ -0,0 +1,4 @@
+<?xml version="1.0" encoding="utf-8"?>
+<resources>
+    <color name="test">#ffffff</color>
+</resources>
\ No newline at end of file
diff --git a/library/src/jp/co/cyberagent/android/gpuimage/core/GLToolbox.java b/library/src/jp/co/cyberagent/android/gpuimage/core/GLToolbox.java
new file mode 100644
index 00000000..82e73c0d
--- /dev/null
+++ b/library/src/jp/co/cyberagent/android/gpuimage/core/GLToolbox.java
@@ -0,0 +1,85 @@
+/*
+ * Copyright (C) 2014 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package jp.co.cyberagent.android.gpuimage.core;
+
+import android.opengl.GLES20;
+
+public class GLToolbox {
+
+    public static int loadShader(int shaderType, String source) {
+        int shader = GLES20.glCreateShader(shaderType);
+        if (shader != 0) {
+            GLES20.glShaderSource(shader, source);
+            GLES20.glCompileShader(shader);
+            int[] compiled = new int[1];
+            GLES20.glGetShaderiv(shader, GLES20.GL_COMPILE_STATUS, compiled, 0);
+            if (compiled[0] == 0) {
+                String info = GLES20.glGetShaderInfoLog(shader);
+                GLES20.glDeleteShader(shader);
+                throw new RuntimeException("Could not compile shader " + shaderType + ":" + info);
+            }
+        }
+        return shader;
+    }
+
+    public static int createProgram(String vertexSource, String fragmentSource) {
+        int vertexShader = loadShader(GLES20.GL_VERTEX_SHADER, vertexSource);
+        if (vertexShader == 0) {
+            return 0;
+        }
+        int pixelShader = loadShader(GLES20.GL_FRAGMENT_SHADER, fragmentSource);
+        if (pixelShader == 0) {
+            return 0;
+        }
+
+        int program = GLES20.glCreateProgram();
+        if (program != 0) {
+            GLES20.glAttachShader(program, vertexShader);
+            checkGlError("glAttachShader");
+            GLES20.glAttachShader(program, pixelShader);
+            checkGlError("glAttachShader");
+            GLES20.glLinkProgram(program);
+            int[] linkStatus = new int[1];
+            GLES20.glGetProgramiv(program, GLES20.GL_LINK_STATUS, linkStatus,
+                    0);
+            if (linkStatus[0] != GLES20.GL_TRUE) {
+                String info = GLES20.glGetProgramInfoLog(program);
+                GLES20.glDeleteProgram(program);
+                throw new RuntimeException("Could not link program: " + info);
+            }
+        }
+        return program;
+    }
+
+    public static void checkGlError() {
+        checkGlError("GpuImage");
+    }
+    public static void checkGlError(String op) {
+        int error = GLES20.glGetError();
+        if (error != GLES20.GL_NO_ERROR) {
+            throw new RuntimeException(op + ": glError " + error);
+        }
+    }
+
+    public static void initTexParams() {
+        GLES20.glTexParameteri(GLES20.GL_TEXTURE_2D, GLES20.GL_TEXTURE_MAG_FILTER, GLES20.GL_NEAREST );//纹理过滤方式取最近像素节省计算
+        GLES20.glTexParameteri(GLES20.GL_TEXTURE_2D, GLES20.GL_TEXTURE_MIN_FILTER, GLES20.GL_NEAREST );
+        GLES20.glTexParameteri(GLES20.GL_TEXTURE_2D, GLES20.GL_TEXTURE_WRAP_S, GLES20.GL_REPEAT );//填充取重复
+        GLES20.glTexParameteri(GLES20.GL_TEXTURE_2D, GLES20.GL_TEXTURE_WRAP_T, GLES20.GL_REPEAT);
+    }
+
+}
diff --git a/library/src/jp/co/cyberagent/android/gpuimage/core/GPUImageFilter.java b/library/src/jp/co/cyberagent/android/gpuimage/core/GPUImageFilter.java
index a86a5aae..cbfb9d66 100644
--- a/library/src/jp/co/cyberagent/android/gpuimage/core/GPUImageFilter.java
+++ b/library/src/jp/co/cyberagent/android/gpuimage/core/GPUImageFilter.java
@@ -27,6 +27,8 @@
 
 import jp.co.cyberagent.android.gpuimage.util.GlUtils;
 
+import static jp.co.cyberagent.android.gpuimage.core.GLToolbox.checkGlError;
+
 // TODO: 2017/9/12 滤镜基类
 public class GPUImageFilter {
     public static final String NO_FILTER_VERTEX_SHADER = "" +
@@ -80,9 +82,13 @@ public final void init() {
 
     public void onInit() {// TODO: 2017/9/12 初始化主体方法，GLSL配置、传参，子类定制化配置
         mGLProgId = GlUtils.loadProgram(mVertexShader, mFragmentShader);
+        checkGlError("loadProgram");
         mGLAttribPosition = GLES20.glGetAttribLocation(mGLProgId, "position");
+        checkGlError("vertex attribute setup");
         mGLUniformTexture = GLES20.glGetUniformLocation(mGLProgId, "inputImageTexture");
+        checkGlError("glActiveTexture");
         mGLAttribTextureCoordinate = GLES20.glGetAttribLocation(mGLProgId,"inputTextureCoordinate");
+        checkGlError("glActiveTexture");
         mIsInitialized = true;
     }
 
@@ -115,6 +121,7 @@ public void onDraw(final int textureId, final FloatBuffer cubeBuffer,
         cubeBuffer.position(0);
         GLES20.glVertexAttribPointer(mGLAttribPosition, 2, GLES20.GL_FLOAT, false, 0, cubeBuffer);
         GLES20.glEnableVertexAttribArray(mGLAttribPosition);
+        checkGlError("vertex attribute setup");
         // TODO: 2017/9/12 处理纹理顶点
         textureBuffer.position(0);
         GLES20.glVertexAttribPointer(mGLAttribTextureCoordinate, 2, GLES20.GL_FLOAT, false, 0,textureBuffer);
@@ -125,11 +132,13 @@ public void onDraw(final int textureId, final FloatBuffer cubeBuffer,
             GLES20.glBindTexture(GLES20.GL_TEXTURE_2D, textureId);
             GLES20.glUniform1i(mGLUniformTexture, 0);
         }
+        checkGlError("glActiveTexture");
         onDrawArraysPre();
         GLES20.glDrawArrays(GLES20.GL_TRIANGLE_STRIP, 0, 4);
         GLES20.glDisableVertexAttribArray(mGLAttribPosition);
         GLES20.glDisableVertexAttribArray(mGLAttribTextureCoordinate);
         GLES20.glBindTexture(GLES20.GL_TEXTURE_2D, 0);
+        checkGlError("glActiveTexture");
     }
 
     protected void onDrawArraysPre() {}
diff --git a/library/src/jp/co/cyberagent/android/gpuimage/core/OpenGlUtils.java b/library/src/jp/co/cyberagent/android/gpuimage/core/OpenGlUtils.java
new file mode 100644
index 00000000..1687a8e3
--- /dev/null
+++ b/library/src/jp/co/cyberagent/android/gpuimage/core/OpenGlUtils.java
@@ -0,0 +1,246 @@
+package jp.co.cyberagent.android.gpuimage.core;
+
+import android.content.Context;
+import android.content.res.AssetManager;
+import android.graphics.Bitmap;
+import android.graphics.BitmapFactory;
+import android.opengl.GLES11Ext;
+import android.opengl.GLES20;
+import android.opengl.GLUtils;
+import android.util.Log;
+
+import java.io.BufferedReader;
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.InputStreamReader;
+import java.nio.Buffer;
+
+import javax.microedition.khronos.opengles.GL10;
+
+public class OpenGlUtils {
+	public static final int NO_TEXTURE = -1;
+	public static final int NOT_INIT = -1;	
+	public static final int ON_DRAWN = 1;
+	
+	public static int loadTexture(final Bitmap img, final int usedTexId) {
+		return loadTexture(img, usedTexId, false);
+    }
+	
+	public static int loadTexture(final Bitmap img, final int usedTexId, boolean recyled) {
+		if(img == null)
+			return NO_TEXTURE; 
+        int textures[] = new int[1];
+        if (usedTexId == NO_TEXTURE) {
+            GLES20.glGenTextures(1, textures, 0);
+            GLES20.glBindTexture(GLES20.GL_TEXTURE_2D, textures[0]);
+            GLES20.glTexParameterf(GLES20.GL_TEXTURE_2D,
+                    GLES20.GL_TEXTURE_MAG_FILTER, GLES20.GL_LINEAR);
+            GLES20.glTexParameterf(GLES20.GL_TEXTURE_2D,
+                    GLES20.GL_TEXTURE_MIN_FILTER, GLES20.GL_LINEAR);
+            GLES20.glTexParameterf(GLES20.GL_TEXTURE_2D,
+                    GLES20.GL_TEXTURE_WRAP_S, GLES20.GL_CLAMP_TO_EDGE);
+            GLES20.glTexParameterf(GLES20.GL_TEXTURE_2D,
+                    GLES20.GL_TEXTURE_WRAP_T, GLES20.GL_CLAMP_TO_EDGE);
+
+            GLUtils.texImage2D(GLES20.GL_TEXTURE_2D, 0, img, 0);
+        } else {
+            GLES20.glBindTexture(GLES20.GL_TEXTURE_2D, usedTexId);
+            GLUtils.texSubImage2D(GLES20.GL_TEXTURE_2D, 0, 0, 0, img);
+            textures[0] = usedTexId;
+        }
+        if(recyled)
+        	img.recycle();
+        return textures[0];
+    }
+	
+	public static int loadTexture(final Buffer data, final int width, final int height, final int usedTexId) {
+		if(data == null)
+			return NO_TEXTURE;
+	    int textures[] = new int[1];
+	    if (usedTexId == NO_TEXTURE) {
+	        GLES20.glGenTextures(1, textures, 0);
+	        GLES20.glBindTexture(GLES20.GL_TEXTURE_2D, textures[0]);
+	        GLES20.glTexParameterf(GLES20.GL_TEXTURE_2D,
+	                GLES20.GL_TEXTURE_MAG_FILTER, GLES20.GL_LINEAR);
+	        GLES20.glTexParameterf(GLES20.GL_TEXTURE_2D,
+	                GLES20.GL_TEXTURE_MIN_FILTER, GLES20.GL_LINEAR);
+	        GLES20.glTexParameterf(GLES20.GL_TEXTURE_2D,
+	                GLES20.GL_TEXTURE_WRAP_S, GLES20.GL_CLAMP_TO_EDGE);
+	        GLES20.glTexParameterf(GLES20.GL_TEXTURE_2D,
+	                GLES20.GL_TEXTURE_WRAP_T, GLES20.GL_CLAMP_TO_EDGE);
+	        GLES20.glTexImage2D(GLES20.GL_TEXTURE_2D, 0, GLES20.GL_RGBA, width, height,
+	                0, GLES20.GL_RGBA, GLES20.GL_UNSIGNED_BYTE, data);
+	    } else {
+	        GLES20.glBindTexture(GLES20.GL_TEXTURE_2D, usedTexId);
+	        GLES20.glTexSubImage2D(GLES20.GL_TEXTURE_2D, 0, 0, 0, width,
+	                height, GLES20.GL_RGBA, GLES20.GL_UNSIGNED_BYTE, data);
+	        textures[0] = usedTexId;
+	    }
+	    return textures[0];
+    }
+    
+	public static int loadTexture(final Buffer data, final int width, final int height, final int usedTexId, final int type) {
+		if(data == null)
+			return NO_TEXTURE;
+	    int textures[] = new int[1];
+	    if (usedTexId == NO_TEXTURE) {
+	        GLES20.glGenTextures(1, textures, 0);
+	        GLES20.glBindTexture(GLES20.GL_TEXTURE_2D, textures[0]);
+	        GLES20.glTexParameterf(GLES20.GL_TEXTURE_2D,
+	                GLES20.GL_TEXTURE_MAG_FILTER, GLES20.GL_LINEAR);
+	        GLES20.glTexParameterf(GLES20.GL_TEXTURE_2D,
+	                GLES20.GL_TEXTURE_MIN_FILTER, GLES20.GL_LINEAR);
+	        GLES20.glTexParameterf(GLES20.GL_TEXTURE_2D,
+	                GLES20.GL_TEXTURE_WRAP_S, GLES20.GL_CLAMP_TO_EDGE);
+	        GLES20.glTexParameterf(GLES20.GL_TEXTURE_2D,
+	                GLES20.GL_TEXTURE_WRAP_T, GLES20.GL_CLAMP_TO_EDGE);
+	        GLES20.glTexImage2D(GLES20.GL_TEXTURE_2D, 0, GLES20.GL_RGBA, width, height,
+	                0, GLES20.GL_RGBA, type, data);
+	    } else {
+	        GLES20.glBindTexture(GLES20.GL_TEXTURE_2D, usedTexId);
+	        GLES20.glTexSubImage2D(GLES20.GL_TEXTURE_2D, 0, 0, 0, width,
+	                height, GLES20.GL_RGBA, type, data);
+	        textures[0] = usedTexId;
+	    }
+	    return textures[0];
+    }
+    
+    public static int loadTexture(final Context context, final String name){
+		final int[] textureHandle = new int[1];
+		
+		GLES20.glGenTextures(1, textureHandle, 0);
+		
+		if (textureHandle[0] != 0){
+
+			// Read in the resource
+			final Bitmap bitmap = getImageFromAssetsFile(context,name);
+						
+			// Bind to the texture in OpenGL
+			GLES20.glBindTexture(GLES20.GL_TEXTURE_2D, textureHandle[0]);
+			
+			// Set filtering
+			GLES20.glTexParameteri(GLES20.GL_TEXTURE_2D, GLES20.GL_TEXTURE_MAG_FILTER, GLES20.GL_LINEAR);
+			GLES20.glTexParameteri(GLES20.GL_TEXTURE_2D, GLES20.GL_TEXTURE_MIN_FILTER, GLES20.GL_LINEAR);
+			GLES20.glTexParameteri(GLES20.GL_TEXTURE_2D, GLES20.GL_TEXTURE_WRAP_S, GLES20.GL_CLAMP_TO_EDGE);
+			GLES20.glTexParameteri(GLES20.GL_TEXTURE_2D, GLES20.GL_TEXTURE_WRAP_T, GLES20.GL_CLAMP_TO_EDGE);
+			// Load the bitmap into the bound texture.
+			GLUtils.texImage2D(GLES20.GL_TEXTURE_2D, 0, bitmap, 0);
+			
+			// Recycle the bitmap, since its data has been loaded into OpenGL.
+			bitmap.recycle();						
+		}
+		
+		if (textureHandle[0] == 0){
+			throw new RuntimeException("Error loading texture.");
+		}
+		
+		return textureHandle[0];
+	}
+	
+	private static Bitmap getImageFromAssetsFile(Context context, String fileName){
+		Bitmap image = null;
+	    AssetManager am = context.getResources().getAssets();
+	    try{  
+			InputStream is = am.open(fileName);
+			image = BitmapFactory.decodeStream(is);
+			is.close();
+          	}catch (IOException e){
+	          e.printStackTrace();  
+	      }  	  
+	      return image;  	  
+	}  
+    
+	public static int loadProgram(final String strVSource, final String strFSource) {
+        int iVShader;
+        int iFShader;
+        int iProgId;
+        int[] link = new int[1];
+        iVShader = loadShader(strVSource, GLES20.GL_VERTEX_SHADER);
+        if (iVShader == 0) {
+            Log.d("Load Program", "Vertex Shader Failed");
+            return 0;
+        }
+        iFShader = loadShader(strFSource, GLES20.GL_FRAGMENT_SHADER);
+        if (iFShader == 0) {
+            Log.d("Load Program", "Fragment Shader Failed");
+            return 0;
+        }
+
+        iProgId = GLES20.glCreateProgram();
+        GLES20.glAttachShader(iProgId, iVShader);
+        GLES20.glAttachShader(iProgId, iFShader);
+        GLES20.glLinkProgram(iProgId);
+        GLES20.glGetProgramiv(iProgId, GLES20.GL_LINK_STATUS, link, 0);
+        if (link[0] <= 0) {
+            Log.d("Load Program", "Linking Failed");
+            return 0;
+        }
+        GLES20.glDeleteShader(iVShader);
+        GLES20.glDeleteShader(iFShader);
+        return iProgId;
+    }
+	
+	private static int loadShader(final String strSource, final int iType) {
+        int[] compiled = new int[1];
+        int iShader = GLES20.glCreateShader(iType);
+        GLES20.glShaderSource(iShader, strSource);
+        GLES20.glCompileShader(iShader);
+        GLES20.glGetShaderiv(iShader, GLES20.GL_COMPILE_STATUS, compiled, 0);
+        if (compiled[0] == 0) {
+            Log.e("Load Shader Failed", "Compilation\n" + GLES20.glGetShaderInfoLog(iShader));
+            return 0;
+        }
+        return iShader;
+    }
+	
+	public static int getExternalOESTextureID(){		
+		int[] texture = new int[1];
+		GLES20.glGenTextures(1, texture, 0);
+		GLES20.glBindTexture(GLES11Ext.GL_TEXTURE_EXTERNAL_OES, texture[0]);
+		GLES20.glTexParameterf(GLES11Ext.GL_TEXTURE_EXTERNAL_OES,
+				GL10.GL_TEXTURE_MIN_FILTER, GL10.GL_LINEAR);
+		GLES20.glTexParameterf(GLES11Ext.GL_TEXTURE_EXTERNAL_OES,
+                GL10.GL_TEXTURE_MAG_FILTER, GL10.GL_LINEAR);
+		GLES20.glTexParameteri(GLES11Ext.GL_TEXTURE_EXTERNAL_OES,
+                GL10.GL_TEXTURE_WRAP_S, GL10.GL_CLAMP_TO_EDGE);
+		GLES20.glTexParameteri(GLES11Ext.GL_TEXTURE_EXTERNAL_OES,
+                GL10.GL_TEXTURE_WRAP_T, GL10.GL_CLAMP_TO_EDGE);
+		return texture[0];
+	}
+	public static String readShaderFromRawResource(Context context, final int resourceId){
+		final InputStream inputStream = context.getResources().openRawResource(
+				resourceId);
+		final InputStreamReader inputStreamReader = new InputStreamReader(
+				inputStream);
+		final BufferedReader bufferedReader = new BufferedReader(
+				inputStreamReader);
+
+		String nextLine;
+		final StringBuilder body = new StringBuilder();
+
+		try{
+			while ((nextLine = bufferedReader.readLine()) != null){
+				body.append(nextLine);
+				body.append('\n');
+			}
+		}
+		catch (IOException e){
+			return null;
+		}
+		return body.toString();
+	}
+
+
+
+	/**
+	 * Checks to see if a GLES error has been raised.
+	 */
+	public static void checkGlError(String op) {
+		int error = GLES20.glGetError();
+		if (error != GLES20.GL_NO_ERROR) {
+			String msg = op + ": glError 0x" + Integer.toHexString(error);
+			Log.e("OpenGlUtils", msg);
+			throw new RuntimeException(msg);
+		}
+	}
+}
diff --git a/library/src/jp/co/cyberagent/android/gpuimage/filter/GPUImageSwirlFilter.java b/library/src/jp/co/cyberagent/android/gpuimage/filter/GPUImageSwirlFilter.java
index a4682358..17f7bc3f 100644
--- a/library/src/jp/co/cyberagent/android/gpuimage/filter/GPUImageSwirlFilter.java
+++ b/library/src/jp/co/cyberagent/android/gpuimage/filter/GPUImageSwirlFilter.java
@@ -30,18 +30,18 @@
             "\n" +
             "uniform sampler2D inputImageTexture;\n" +
             "\n" +
-            "uniform highp vec2 center;\n" +
-            "uniform highp float radius;\n" +
-            "uniform highp float angle;\n" +
+            "uniform highp vec2 center;\n" +// TODO: 2017/9/19 传入中心点
+            "uniform highp float radius;\n" +// TODO: 2017/9/19 传入半径
+            "uniform highp float angle;\n" +// TODO: 2017/9/19 传入角度
             "\n" +
             "void main()\n" +
             "{\n" +
             "highp vec2 textureCoordinateToUse = textureCoordinate;\n" +
-            "highp float dist = distance(center, textureCoordinate);\n" +
-            "if (dist < radius)\n" +
+            "highp float dist = distance(center, textureCoordinate);\n" + // TODO: 2017/9/19 当前点和中心的距离
+            "if (dist < radius)\n" + // TODO: 2017/9/19 如果小于半径，做操作
             "{\n" +
-            "textureCoordinateToUse -= center;\n" +
-            "highp float percent = (radius - dist) / radius;\n" +
+            "textureCoordinateToUse -= center;\n" + // TODO: 2017/9/19 减去中心
+            "highp float percent = (radius - dist) / radius;\n" + // TODO: 2017/9/20 求个比值
             "highp float theta = percent * percent * angle * 8.0;\n" +
             "highp float s = sin(theta);\n" +
             "highp float c = cos(theta);\n" +
diff --git a/library/src/jp/co/cyberagent/android/gpuimage/filter/custom/DrosteFilter.java b/library/src/jp/co/cyberagent/android/gpuimage/filter/custom/DrosteFilter.java
new file mode 100644
index 00000000..3d7ad22f
--- /dev/null
+++ b/library/src/jp/co/cyberagent/android/gpuimage/filter/custom/DrosteFilter.java
@@ -0,0 +1,20 @@
+package jp.co.cyberagent.android.gpuimage.filter.custom;
+
+import android.content.Context;
+
+import jp.co.cyberagent.android.gpuimage.R;
+import jp.co.cyberagent.android.gpuimage.core.GPUImageFilter;
+
+import static jp.co.cyberagent.android.gpuimage.core.OpenGlUtils.readShaderFromRawResource;
+
+/**
+ * Created by fanjie on 2017/9/20.
+ */
+
+public class DrosteFilter extends GPUImageFilter {
+
+    public DrosteFilter(Context context) {
+        super(GPUImageFilter.NO_FILTER_VERTEX_SHADER, readShaderFromRawResource(context, R.raw.droste));
+    }
+
+}
diff --git a/library/src/jp/co/cyberagent/android/gpuimage/filter/custom/FakeAIFilter.java b/library/src/jp/co/cyberagent/android/gpuimage/filter/custom/FakeAIFilter.java
new file mode 100644
index 00000000..f70c2655
--- /dev/null
+++ b/library/src/jp/co/cyberagent/android/gpuimage/filter/custom/FakeAIFilter.java
@@ -0,0 +1,49 @@
+package jp.co.cyberagent.android.gpuimage.filter.custom;
+
+import jp.co.cyberagent.android.gpuimage.filter.GPUImageTwoInputFilter;
+
+/**
+ * Created by fanjie on 2017/9/12. 来一个屌炸天的双纹理滤镜
+ */
+
+public class FakeAIFilter extends GPUImageTwoInputFilter {
+    private static final String VERTEX_SHADER =
+            "attribute vec4 position;\n" +
+                    "attribute vec4 inputTextureCoordinate;\n" +
+                    "attribute vec4 inputTextureCoordinate2;\n" +
+                    " \n" +
+                    "varying vec4 v_position;\n" +
+                    "varying vec2 textureCoordinate;\n" +
+                    "varying vec2 textureCoordinate2;\n" +
+                    " \n" +
+                    "void main()\n" +
+                    "{\n" +
+                    "    gl_Position = position;\n" +
+                    "    v_position = position;\n" +
+                    "    textureCoordinate = inputTextureCoordinate.xy;\n" +
+                    "    textureCoordinate2 = inputTextureCoordinate2.xy;\n" +
+                    "}";
+    public static final String FRAGMENT_SHADER_H =
+                    "precision mediump float;\n" +
+                    "varying vec4 v_position;\n" +
+                    "varying highp vec2 textureCoordinate;\n" +
+                    "varying highp vec2 textureCoordinate2;\n" +
+                    "\n" +
+                    "uniform sampler2D inputImageTexture;\n" +
+                    "uniform sampler2D inputImageTexture2;\n" +
+                    "\n" +
+                    "void main()\n" +
+                    "{\n" +
+                    "  highp vec4 a = texture2D(inputImageTexture, textureCoordinate);\n" +
+                    "  highp vec4 b = texture2D(inputImageTexture2, textureCoordinate2);\n" +
+                    "  highp vec4 c = mix(a,b,0.5);\n" +
+//                    "  highp vec4 c = vec4( min(a.r,b.r), min(a.g,b.g), min(a.b,b.b), 1.0);\n" +
+//                    "  highp vec4 c = vec4( max(a.r,b.r), max(a.g,b.g), max(a.b,b.b), 1.0);\n" +
+//                    "  highp vec4 c = vec4( a.r, b.g, a.b, 1.0);\n" +
+                    "  gl_FragColor = c;\n" +
+                    "}";
+
+    public FakeAIFilter() {
+        super(VERTEX_SHADER, FRAGMENT_SHADER_H);
+    }
+}
diff --git a/library/src/jp/co/cyberagent/android/gpuimage/filter/custom/FireFilter.java b/library/src/jp/co/cyberagent/android/gpuimage/filter/custom/FireFilter.java
new file mode 100644
index 00000000..7388cb4c
--- /dev/null
+++ b/library/src/jp/co/cyberagent/android/gpuimage/filter/custom/FireFilter.java
@@ -0,0 +1,73 @@
+package jp.co.cyberagent.android.gpuimage.filter.custom;
+
+import android.content.Context;
+import android.opengl.GLES20;
+
+import java.nio.FloatBuffer;
+
+import jp.co.cyberagent.android.gpuimage.R;
+import jp.co.cyberagent.android.gpuimage.core.GPUImageFilter;
+import jp.co.cyberagent.android.gpuimage.util.GlUtils;
+
+import static jp.co.cyberagent.android.gpuimage.core.GLToolbox.checkGlError;
+import static jp.co.cyberagent.android.gpuimage.core.OpenGlUtils.readShaderFromRawResource;
+
+/**
+ * Created by fanjie on 2017/9/20.
+ */
+
+public class FireFilter extends GPUImageFilter {
+
+    public FireFilter(Context context) {
+        super(GPUImageFilter.NO_FILTER_VERTEX_SHADER, readShaderFromRawResource(context, R.raw.fire));
+    }
+
+    private int timeLocation;
+
+    @Override
+    public void onInit() {
+        super.onInit();
+        timeLocation = GLES20.glGetUniformLocation(getProgram(), "iTime");
+    }
+
+    @Override
+    public void onDraw(int textureId, FloatBuffer cubeBuffer, FloatBuffer textureBuffer) {
+        GLES20.glUseProgram(mGLProgId);// TODO: 2017/9/12 使用通道
+        runPendingOnDrawTasks();// TODO: 2017/9/12 先处理全家桶
+        if (!mIsInitialized) {
+            return;
+        }
+        // TODO: 2017/9/12 处理顶点
+        cubeBuffer.position(0);
+        GLES20.glVertexAttribPointer(mGLAttribPosition, 2, GLES20.GL_FLOAT, false, 0, cubeBuffer);
+        GLES20.glEnableVertexAttribArray(mGLAttribPosition);
+        checkGlError("vertex attribute setup");
+        // TODO: 2017/9/12 处理纹理顶点
+        textureBuffer.position(0);
+        GLES20.glVertexAttribPointer(mGLAttribTextureCoordinate, 2, GLES20.GL_FLOAT, false, 0, textureBuffer);
+        GLES20.glEnableVertexAttribArray(mGLAttribTextureCoordinate);
+
+        setTime();// TODO: 2017/9/21 模拟时间
+
+        if (textureId != GlUtils.NO_TEXTURE) {
+            // TODO: 2017/9/12 应用纹理
+            GLES20.glActiveTexture(GLES20.GL_TEXTURE0);
+            GLES20.glBindTexture(GLES20.GL_TEXTURE_2D, textureId);
+            GLES20.glUniform1i(mGLUniformTexture, 0);
+        }
+        checkGlError("glActiveTexture");
+        onDrawArraysPre();
+        GLES20.glDrawArrays(GLES20.GL_TRIANGLE_STRIP, 0, 4);
+        GLES20.glDisableVertexAttribArray(mGLAttribPosition);
+        GLES20.glDisableVertexAttribArray(mGLAttribTextureCoordinate);
+        GLES20.glBindTexture(GLES20.GL_TEXTURE_2D, 0);
+        checkGlError("glActiveTexture");
+    }
+
+    private float time;
+
+    private void setTime() {
+        setFloat(timeLocation, time);
+        time += 0.05;
+    }
+}
diff --git a/library/src/jp/co/cyberagent/android/gpuimage/util/GlUtils.java b/library/src/jp/co/cyberagent/android/gpuimage/util/GlUtils.java
index 2b94698b..f4cd2c0e 100644
--- a/library/src/jp/co/cyberagent/android/gpuimage/util/GlUtils.java
+++ b/library/src/jp/co/cyberagent/android/gpuimage/util/GlUtils.java
@@ -25,6 +25,8 @@
 
 import java.nio.IntBuffer;
 
+import static jp.co.cyberagent.android.gpuimage.core.GLToolbox.checkGlError;
+
 public class GlUtils {
     public static final int NO_TEXTURE = -1;
 
@@ -88,6 +90,7 @@ public static int loadShader(final String strSource, final int iType) {
         GLES20.glShaderSource(iShader, strSource);
         GLES20.glCompileShader(iShader);
         GLES20.glGetShaderiv(iShader, GLES20.GL_COMPILE_STATUS, compiled, 0);
+        checkGlError("loadShader");
         if (compiled[0] == 0) {
             Log.d("Load Shader Failed", "Compilation\n" + GLES20.glGetShaderInfoLog(iShader));
             return 0;
@@ -112,19 +115,22 @@ public static int loadProgram(final String strVSource, final String strFSource)
         }
 
         iProgId = GLES20.glCreateProgram();
-
         GLES20.glAttachShader(iProgId, iVShader);
+        checkGlError("glAttachShader");
         GLES20.glAttachShader(iProgId, iFShader);
-
+        checkGlError("glAttachShader");
         GLES20.glLinkProgram(iProgId);
-
+        checkGlError("glAttachShader");
         GLES20.glGetProgramiv(iProgId, GLES20.GL_LINK_STATUS, link, 0);
+        checkGlError("glAttachShader");
         if (link[0] <= 0) {
             Log.d("Load Program", "Linking Failed");
             return 0;
         }
         GLES20.glDeleteShader(iVShader);
+        checkGlError("glAttachShader");
         GLES20.glDeleteShader(iFShader);
+        checkGlError("glAttachShader");
         return iProgId;
     }
 
diff --git a/sample/res/drawable-nodpi/pic02.jpg b/sample/res/drawable-nodpi/pic02.jpg
new file mode 100644
index 00000000..fc822edd
Binary files /dev/null and b/sample/res/drawable-nodpi/pic02.jpg differ
diff --git a/sample/res/drawable-nodpi/pic03.jpg b/sample/res/drawable-nodpi/pic03.jpg
new file mode 100644
index 00000000..351ce3dc
Binary files /dev/null and b/sample/res/drawable-nodpi/pic03.jpg differ
diff --git a/sample/res/layout/activity_gallery.xml b/sample/res/layout/activity_gallery.xml
index edd9d867..3548f406 100644
--- a/sample/res/layout/activity_gallery.xml
+++ b/sample/res/layout/activity_gallery.xml
@@ -11,6 +11,7 @@
 
         <jp.co.cyberagent.android.gpuimage.core.GPUImageView
             android:id="@+id/gpuimage"
+            android:onClick="onSurfaceViewClick"
             android:layout_gravity="center"
             android:layout_width="wrap_content"
             android:layout_height="wrap_content" />
diff --git a/sample/src/jp/co/cyberagent/android/gpuimage/sample/GPUImageFilterTools.java b/sample/src/jp/co/cyberagent/android/gpuimage/sample/GPUImageFilterTools.java
index 150897da..9a8bb7e1 100644
--- a/sample/src/jp/co/cyberagent/android/gpuimage/sample/GPUImageFilterTools.java
+++ b/sample/src/jp/co/cyberagent/android/gpuimage/sample/GPUImageFilterTools.java
@@ -103,6 +103,9 @@
 import jp.co.cyberagent.android.gpuimage.filter.GPUImageWeakPixelInclusionFilter;
 import jp.co.cyberagent.android.gpuimage.filter.GPUImageWhiteBalanceFilter;
 import jp.co.cyberagent.android.gpuimage.filter.custom.DoubleFilter;
+import jp.co.cyberagent.android.gpuimage.filter.custom.DrosteFilter;
+import jp.co.cyberagent.android.gpuimage.filter.custom.FakeAIFilter;
+import jp.co.cyberagent.android.gpuimage.filter.custom.FireFilter;
 import jp.co.cyberagent.android.gpuimage.filter.custom.TransitionFilter;
 import jp.co.cyberagent.android.gpuimage.util.GPUImageSobelEdgeDetection;
 
@@ -110,7 +113,11 @@
     public static void showDialog(final Context context,
                                   final OnGpuImageFilterChosenListener listener) {
         final FilterList filters = new FilterList();
-        filters.addFilter("Me!Me!Me!", FilterType.TEST);
+        filters.addFilter("TEST", FilterType.TEST);
+        filters.addFilter("TEST2", FilterType.TEST2);
+        filters.addFilter("TEST3", FilterType.TEST3);
+        filters.addFilter("TEST4", FilterType.TEST4);
+        filters.addFilter("TEST5", FilterType.TEST5);
         filters.addFilter("Contrast", FilterType.CONTRAST);
         filters.addFilter("Invert", FilterType.INVERT);
         filters.addFilter("Grouped", FilterType.FILTER_GROUP);
@@ -216,6 +223,18 @@ private static GPUImageFilter createFilterForType(final Context context, final F
         switch (type) {
             case TEST:
                 return new TransitionFilter();
+            case TEST2:
+                FakeAIFilter fakeAIFilter = new FakeAIFilter();
+                fakeAIFilter.setBitmap(BitmapFactory.decodeResource(context.getResources(), R.drawable.pic03));
+                return fakeAIFilter;
+            case TEST3:
+                DoubleFilter doubleFilter = new DoubleFilter();
+                doubleFilter.setBitmap(BitmapFactory.decodeResource(context.getResources(), R.drawable.pic02));
+                return doubleFilter;
+            case TEST4:
+                return new DrosteFilter(context);
+            case TEST5:
+                return new FireFilter(context);
             case FILTER_GROUP:
                 List<GPUImageFilter> filters = new LinkedList<GPUImageFilter>();
                 filters.add(new GPUImageContrastFilter());
@@ -415,7 +434,7 @@ private static GPUImageFilter createBlendFilter(Context context, Class<? extends
     }
 
     private enum FilterType {
-        TEST, CONTRAST, GRAYSCALE, SHARPEN, SEPIA, SOBEL_EDGE_DETECTION, THREE_X_THREE_CONVOLUTION, FILTER_GROUP, FILTER_GROUP2, EMBOSS, POSTERIZE, GAMMA, BRIGHTNESS, INVERT, HUE, PIXELATION,
+        TEST,TEST2,TEST3, TEST4,TEST5, CONTRAST, GRAYSCALE, SHARPEN, SEPIA, SOBEL_EDGE_DETECTION, THREE_X_THREE_CONVOLUTION, FILTER_GROUP, FILTER_GROUP2, EMBOSS, POSTERIZE, GAMMA, BRIGHTNESS, INVERT, HUE, PIXELATION,
         SATURATION, EXPOSURE, HIGHLIGHT_SHADOW, MONOCHROME, OPACITY, RGB, WHITE_BALANCE, VIGNETTE, TONE_CURVE, BLEND_COLOR_BURN, BLEND_COLOR_DODGE, BLEND_DARKEN, BLEND_DIFFERENCE,
         BLEND_DISSOLVE, BLEND_EXCLUSION, BLEND_SOURCE_OVER, BLEND_HARD_LIGHT, BLEND_LIGHTEN, BLEND_ADD, BLEND_DIVIDE, BLEND_MULTIPLY, BLEND_OVERLAY, BLEND_SCREEN, BLEND_ALPHA,
         BLEND_COLOR, BLEND_HUE, BLEND_SATURATION, BLEND_LUMINOSITY, BLEND_LINEAR_BURN, BLEND_SOFT_LIGHT, BLEND_SUBTRACT, BLEND_CHROMA_KEY, BLEND_NORMAL, LOOKUP_AMATORKA,
diff --git a/sample/src/jp/co/cyberagent/android/gpuimage/sample/activity/ActivityGallery.java b/sample/src/jp/co/cyberagent/android/gpuimage/sample/activity/ActivityGallery.java
index 6b386390..63baad37 100644
--- a/sample/src/jp/co/cyberagent/android/gpuimage/sample/activity/ActivityGallery.java
+++ b/sample/src/jp/co/cyberagent/android/gpuimage/sample/activity/ActivityGallery.java
@@ -16,13 +16,6 @@
 
 package jp.co.cyberagent.android.gpuimage.sample.activity;
 
-import jp.co.cyberagent.android.gpuimage.core.GPUImageFilter;
-import jp.co.cyberagent.android.gpuimage.core.GPUImageView;
-import jp.co.cyberagent.android.gpuimage.core.GPUImageView.OnPictureSavedListener;
-import jp.co.cyberagent.android.gpuimage.sample.GPUImageFilterTools;
-import jp.co.cyberagent.android.gpuimage.sample.GPUImageFilterTools.FilterAdjuster;
-import jp.co.cyberagent.android.gpuimage.sample.GPUImageFilterTools.OnGpuImageFilterChosenListener;
-import jp.co.cyberagent.android.gpuimage.sample.R;
 import android.app.Activity;
 import android.content.Intent;
 import android.net.Uri;
@@ -33,6 +26,14 @@
 import android.widget.SeekBar.OnSeekBarChangeListener;
 import android.widget.Toast;
 
+import jp.co.cyberagent.android.gpuimage.core.GPUImageFilter;
+import jp.co.cyberagent.android.gpuimage.core.GPUImageView;
+import jp.co.cyberagent.android.gpuimage.core.GPUImageView.OnPictureSavedListener;
+import jp.co.cyberagent.android.gpuimage.sample.GPUImageFilterTools;
+import jp.co.cyberagent.android.gpuimage.sample.GPUImageFilterTools.FilterAdjuster;
+import jp.co.cyberagent.android.gpuimage.sample.GPUImageFilterTools.OnGpuImageFilterChosenListener;
+import jp.co.cyberagent.android.gpuimage.sample.R;
+
 public class ActivityGallery extends Activity implements OnSeekBarChangeListener,
         OnClickListener, OnPictureSavedListener {
 
@@ -139,4 +140,8 @@ public void onStopTrackingTouch(final SeekBar seekBar) {
     private void handleImage(final Uri selectedImage) {
         mGPUImageView.setImage(selectedImage);
     }
+
+    public void onSurfaceViewClick(View view) {
+        mGPUImageView.requestRender();
+    }
 }
