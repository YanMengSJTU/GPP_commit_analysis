diff --git a/library/src/jp/co/cyberagent/android/gpuimage/core/GPUImageFilter.java b/library/src/jp/co/cyberagent/android/gpuimage/core/GPUImageFilter.java
index e99e3de6..a86a5aae 100644
--- a/library/src/jp/co/cyberagent/android/gpuimage/core/GPUImageFilter.java
+++ b/library/src/jp/co/cyberagent/android/gpuimage/core/GPUImageFilter.java
@@ -59,7 +59,7 @@
     protected int mGLAttribTextureCoordinate;// TODO: 2017/9/12 纹理坐标变量句柄
     protected int mOutputWidth;
     protected int mOutputHeight;
-    private boolean mIsInitialized;// TODO: 2017/9/12 可绘制开关
+    protected boolean mIsInitialized;// TODO: 2017/9/12 可绘制开关
 
     public GPUImageFilter() {
         this(NO_FILTER_VERTEX_SHADER, NO_FILTER_FRAGMENT_SHADER);
diff --git a/library/src/jp/co/cyberagent/android/gpuimage/core/GPUImageFilterGroup.java b/library/src/jp/co/cyberagent/android/gpuimage/core/GPUImageFilterGroup.java
index cdcfc8ec..bbbf3c53 100644
--- a/library/src/jp/co/cyberagent/android/gpuimage/core/GPUImageFilterGroup.java
+++ b/library/src/jp/co/cyberagent/android/gpuimage/core/GPUImageFilterGroup.java
@@ -151,7 +151,7 @@ public void onOutputSizeChanged(final int width, final int height) {
     // TODO: 2017/9/13 复写onDraw实现多滤镜
     public void onDraw(final int textureId, final FloatBuffer cubeBuffer,
                        final FloatBuffer textureBuffer) {
-        runPendingOnDrawTasks();
+        runPendingOnDrawTasks();// TODO: 2017/9/13 先处理全家桶
         if (!isInitialized() || mFrameBuffers == null || mFrameBufferTextures == null) {
             return;
         }
@@ -186,11 +186,9 @@ public void onDraw(final int textureId, final FloatBuffer cubeBuffer,
     public List<GPUImageFilter> getFilters() {
         return mFilters;
     }
-
     public List<GPUImageFilter> getMergedFilters() {
         return mMergedFilters;
     }
-
     @Override
     public void onInit() {
         super.onInit();
@@ -204,9 +202,12 @@ public void onDestroy() {
         for (GPUImageFilter filter : mFilters) {
             filter.destroy();
         }
+        // FIXME: 2017/9/13 试试
+        for (GPUImageFilter filter : mMergedFilters){
+            filter.destroy();
+        }
         super.onDestroy();
     }
-
     private void destroyFramebuffers() {
         if (mFrameBufferTextures != null) {
             GLES20.glDeleteTextures(mFrameBufferTextures.length, mFrameBufferTextures, 0);
@@ -217,7 +218,6 @@ private void destroyFramebuffers() {
             mFrameBuffers = null;
         }
     }
-
     public void addFilter(GPUImageFilter aFilter) {
         if (aFilter == null) {
             return;
diff --git a/library/src/jp/co/cyberagent/android/gpuimage/filter/GPUImageColorBlendFilter.java b/library/src/jp/co/cyberagent/android/gpuimage/filter/GPUImageColorBlendFilter.java
index 93cbf4b8..1d1d30e1 100644
--- a/library/src/jp/co/cyberagent/android/gpuimage/filter/GPUImageColorBlendFilter.java
+++ b/library/src/jp/co/cyberagent/android/gpuimage/filter/GPUImageColorBlendFilter.java
@@ -17,7 +17,8 @@
 package jp.co.cyberagent.android.gpuimage.filter;
 
 public class GPUImageColorBlendFilter extends GPUImageTwoInputFilter {
-    public static final String COLOR_BLEND_FRAGMENT_SHADER = "varying highp vec2 textureCoordinate;\n" +
+    public static final String COLOR_BLEND_FRAGMENT_SHADER =
+            "varying highp vec2 textureCoordinate;\n" +
             " varying highp vec2 textureCoordinate2;\n" +
             " \n" +
             " uniform sampler2D inputImageTexture;\n" +
diff --git a/library/src/jp/co/cyberagent/android/gpuimage/filter/custom/DoubleFilter.java b/library/src/jp/co/cyberagent/android/gpuimage/filter/custom/DoubleFilter.java
index 00d33530..3f558397 100644
--- a/library/src/jp/co/cyberagent/android/gpuimage/filter/custom/DoubleFilter.java
+++ b/library/src/jp/co/cyberagent/android/gpuimage/filter/custom/DoubleFilter.java
@@ -1,35 +1,71 @@
 package jp.co.cyberagent.android.gpuimage.filter.custom;
 
-import jp.co.cyberagent.android.gpuimage.core.GPUImageFilter;
+import jp.co.cyberagent.android.gpuimage.filter.GPUImageTwoInputFilter;
 
 /**
  * Created by fanjie on 2017/9/12. 来一个屌炸天的双纹理滤镜
  */
 
-public class DoubleFilter extends GPUImageFilter {
-
-    public static final String VERTEX_SHADER = "" +
+public class DoubleFilter extends GPUImageTwoInputFilter {
+    private static final String VERTEX_SHADER =
             "attribute vec4 position;\n" +
-            "attribute vec4 inputTextureCoordinate;\n" +
-            " \n" +
-            "varying vec2 textureCoordinate;\n" +
-            " \n" +
-            "void main()\n" +
-            "{\n" +
-            "    gl_Position = position;\n" +
-            "    textureCoordinate = inputTextureCoordinate.xy;\n" +
-            "}";
-    public static final String FRAGMENT_SHADER = "" +
-            "varying highp vec2 textureCoordinate;\n" +
-            " \n" +
-            "uniform sampler2D inputImageTexture;\n" +
-            " \n" +
-            "void main()\n" +
-            "{\n" +
-            "     gl_FragColor = texture2D(inputImageTexture, textureCoordinate * vec2(2.0,1.0));\n" +
-            "}";
+                    "attribute vec4 inputTextureCoordinate;\n" +
+                    "attribute vec4 inputTextureCoordinate2;\n" +
+                    " \n" +
+                    "varying vec4 v_position;\n" +
+                    "varying vec2 textureCoordinate;\n" +
+                    "varying vec2 textureCoordinate2;\n" +
+                    " \n" +
+                    "void main()\n" +
+                    "{\n" +
+                    "    gl_Position = position;\n" +
+                    "    v_position = position;\n" +
+                    "    textureCoordinate = inputTextureCoordinate.xy;\n" +
+                    "    textureCoordinate2 = inputTextureCoordinate2.xy;\n" +
+                    "}";
+
+
+
+    public static final String FRAGMENT_SHADER_V =
+                    "precision mediump float;\n" +
+                    "varying vec4 v_position;\n" +
+                    "varying highp vec2 textureCoordinate;\n" +
+                    "varying highp vec2 textureCoordinate2;\n" +
+                    "\n" +
+                    "uniform sampler2D inputImageTexture;\n" +
+                    "uniform sampler2D inputImageTexture2;\n" +
+                    "\n" +
+                    "void main()\n" +
+                    "{\n" +
+                    "  highp vec4 a = texture2D(inputImageTexture, textureCoordinate * vec2(2.0,1.0));\n" +
+                    "  highp vec4 b = texture2D(inputImageTexture2, textureCoordinate2 * vec2(1.0,2.0) );\n" +
+                    "  if(v_position.y < 0.0){\n" +
+                    "      gl_FragColor = a;\n" +
+                    "  }else{\n" +
+                    "      gl_FragColor = b;\n" +
+                    "  };\n" +
+                    "}";
+    public static final String FRAGMENT_SHADER_H =
+                    "precision mediump float;\n" +
+                    "varying vec4 v_position;\n" +
+                    "varying highp vec2 textureCoordinate;\n" +
+                    "varying highp vec2 textureCoordinate2;\n" +
+                    "\n" +
+                    "uniform sampler2D inputImageTexture;\n" +
+                    "uniform sampler2D inputImageTexture2;\n" +
+                    "\n" +
+                    "void main()\n" +
+                    "{\n" +
+                    "  highp vec4 a = texture2D(inputImageTexture, textureCoordinate * vec2(1.0,2.0));\n" +
+                    "  highp vec4 b = texture2D(inputImageTexture2, textureCoordinate2 * vec2(2.0,1.0) );\n" +
+                    "  if(v_position.x < 0.0){\n" +
+                    "      gl_FragColor = a;\n" +
+                    "  }else{\n" +
+                    "      gl_FragColor = b;\n" +
+                    "  };\n" +
+                    "}";
 
     public DoubleFilter() {
-        super(VERTEX_SHADER, FRAGMENT_SHADER);
+        super(VERTEX_SHADER, FRAGMENT_SHADER_H);
     }
 }
diff --git a/library/src/jp/co/cyberagent/android/gpuimage/filter/custom/TransitionFilter.java b/library/src/jp/co/cyberagent/android/gpuimage/filter/custom/TransitionFilter.java
new file mode 100644
index 00000000..3e8425e5
--- /dev/null
+++ b/library/src/jp/co/cyberagent/android/gpuimage/filter/custom/TransitionFilter.java
@@ -0,0 +1,172 @@
+package jp.co.cyberagent.android.gpuimage.filter.custom;
+
+import android.opengl.GLES20;
+import android.util.Log;
+
+import java.nio.FloatBuffer;
+import java.util.ArrayList;
+import java.util.List;
+
+import jp.co.cyberagent.android.gpuimage.core.GPUImageFilter;
+import jp.co.cyberagent.android.gpuimage.util.GlUtils;
+
+/**
+ * Created by fanjie on 2017/9/19. 渐变滤镜
+ */
+
+public class TransitionFilter extends GPUImageFilter {
+
+    private static final String TAG = "TransitionFilter";
+
+    public static final String VERTEX_SHADER = "" +
+            "attribute vec4 position;\n" +
+            "attribute vec4 inputTextureCoordinate;\n" +
+            " \n" +
+            "varying vec2 textureCoordinate;\n" +
+            " \n" +
+            "void main()\n" +
+            "{\n" +
+            "    gl_Position = position;\n" +
+            "    textureCoordinate = inputTextureCoordinate.xy;\n" +
+            "}";
+    public static final String FRAGMENT_SHADER = "" +
+            "varying highp vec2 textureCoordinate;\n" +
+            " \n" +
+            "uniform sampler2D inputImageTexture;\n" +
+            // TODO: 2017/9/19  外部传值实现渐变
+            "uniform highp float mR;\n" +
+            "uniform highp float mG;\n" +
+            "uniform highp float mB;\n" +
+            " \n" +
+            "void main()\n" +
+            "{\n" +
+            "     highp vec4 a = texture2D(inputImageTexture, textureCoordinate);\n" +
+            "     gl_FragColor = vec4(a.r * mR, a.g * mG, a.b * mB, 1.0);\n" +// TODO: 2017/9/19 操作纹理rgb
+            "}";
+
+    private int rLocation;
+    private int gLocation;
+    private int bLocation;
+
+    private List<RGB> rgbs;
+
+    public TransitionFilter() {
+        super(VERTEX_SHADER, FRAGMENT_SHADER);
+        rgbs = new ArrayList<>();
+        rgbs.add(new RGB(.1f, .1f, .2f));
+        rgbs.add(new RGB(.9f, .3f, .2f));
+        rgbs.add(new RGB(.4f, .5f, .7f));
+        rgbs.add(new RGB(1f, 1f, 1f));
+        rgbs.add(new RGB(.4f, .5f, .7f));
+        rgbs.add(new RGB(.9f, .3f, .2f));
+        rgbs.add(new RGB(.1f, .1f, .2f));
+    }
+
+    public TransitionFilter(List<RGB> rgbList) {
+        super(VERTEX_SHADER, FRAGMENT_SHADER);
+        this.rgbs = rgbList;
+    }
+
+    @Override
+    public void onInit() {
+        super.onInit();
+        rLocation = GLES20.glGetUniformLocation(getProgram(), "mR");
+        gLocation = GLES20.glGetUniformLocation(getProgram(), "mG");
+        bLocation = GLES20.glGetUniformLocation(getProgram(), "mB");
+    }
+
+    @Override
+    public void onDraw(int textureId, FloatBuffer cubeBuffer, FloatBuffer textureBuffer) {
+        GLES20.glUseProgram(mGLProgId);// TODO: 2017/9/12 使用通道
+        runPendingOnDrawTasks();// TODO: 2017/9/12 先处理全家桶
+        if (!mIsInitialized) {
+            return;
+        }
+        // TODO: 2017/9/12 处理顶点
+        cubeBuffer.position(0);
+        GLES20.glVertexAttribPointer(mGLAttribPosition, 2, GLES20.GL_FLOAT, false, 0, cubeBuffer);
+        GLES20.glEnableVertexAttribArray(mGLAttribPosition);
+        // TODO: 2017/9/12 处理纹理顶点
+        textureBuffer.position(0);
+        GLES20.glVertexAttribPointer(mGLAttribTextureCoordinate, 2, GLES20.GL_FLOAT, false, 0, textureBuffer);
+        GLES20.glEnableVertexAttribArray(mGLAttribTextureCoordinate);
+
+        setRGBTransition();// TODO: 2017/9/19 加入渐变
+
+        if (textureId != GlUtils.NO_TEXTURE) {
+            // TODO: 2017/9/12 应用纹理
+            GLES20.glActiveTexture(GLES20.GL_TEXTURE0);
+            GLES20.glBindTexture(GLES20.GL_TEXTURE_2D, textureId);
+            GLES20.glUniform1i(mGLUniformTexture, 0);
+        }
+        onDrawArraysPre();
+        GLES20.glDrawArrays(GLES20.GL_TRIANGLE_STRIP, 0, 4);
+        GLES20.glDisableVertexAttribArray(mGLAttribPosition);
+        GLES20.glDisableVertexAttribArray(mGLAttribTextureCoordinate);
+        GLES20.glBindTexture(GLES20.GL_TEXTURE_2D, 0);
+    }
+
+
+    /**
+     * 用来记录渐变进行的下标，暂时根据屏幕每次渲染递增
+     */
+    private float index;
+
+    /**
+     * 根据递增的下标判断渐变进行程度
+     */
+    private void setRGBTransition() {
+        int size = rgbs.size();
+        for (int i = 0; i < size - 1; i++) {
+            //遍历传入的rgbList结合下标判断递进的颜色区间
+            if (index > i && index < i + 1) {
+                //取个颜色区间
+                RGB start = rgbs.get(i);
+                RGB stop = rgbs.get(i + 1);
+                //在对应的颜色区间内渐变
+                setRGB(
+                        transition(index - i, start.r, stop.r),
+                        transition(index - i, start.g, stop.g),
+                        transition(index - i, start.b, stop.b)
+                );
+            }
+        }
+        if (index > size) {
+            index = 0f;
+        }
+        index += 0.01f;//每次递增
+    }
+
+    /**
+     * @param index 渐变递增的标记，限制0-1
+     * @param start 起始数值
+     * @param stop  终止数值
+     * @return 返回运算后的值
+     */
+    private float transition(float index, float start, float stop) {
+        if (index > 1 || index < 0) {
+            throw new RuntimeException("渐变递增的标记，限制1");
+        }
+        return start + (stop - start) * (index);//直线渐变
+    }
+
+    private void setRGB(float r, float g, float b) {
+        Log.d(TAG, "setRGB: " + "r = [" + r + "], g = [" + g + "], b = [" + b + "]");
+        setFloat(rLocation, r);
+        setFloat(gLocation, g);
+        setFloat(bLocation, b);
+    }
+
+    public static class RGB {
+        public float r;
+        public float g;
+        public float b;
+
+        public RGB(float r, float g, float b) {
+            this.r = r;
+            this.g = g;
+            this.b = b;
+        }
+    }
+
+}
diff --git a/sample/src/jp/co/cyberagent/android/gpuimage/sample/GPUImageFilterTools.java b/sample/src/jp/co/cyberagent/android/gpuimage/sample/GPUImageFilterTools.java
index 4726894b..150897da 100644
--- a/sample/src/jp/co/cyberagent/android/gpuimage/sample/GPUImageFilterTools.java
+++ b/sample/src/jp/co/cyberagent/android/gpuimage/sample/GPUImageFilterTools.java
@@ -23,6 +23,7 @@
 import android.graphics.PointF;
 import android.opengl.Matrix;
 
+import java.util.ArrayList;
 import java.util.LinkedList;
 import java.util.List;
 
@@ -102,15 +103,19 @@
 import jp.co.cyberagent.android.gpuimage.filter.GPUImageWeakPixelInclusionFilter;
 import jp.co.cyberagent.android.gpuimage.filter.GPUImageWhiteBalanceFilter;
 import jp.co.cyberagent.android.gpuimage.filter.custom.DoubleFilter;
+import jp.co.cyberagent.android.gpuimage.filter.custom.TransitionFilter;
 import jp.co.cyberagent.android.gpuimage.util.GPUImageSobelEdgeDetection;
 
 public class GPUImageFilterTools {
     public static void showDialog(final Context context,
-            final OnGpuImageFilterChosenListener listener) {
+                                  final OnGpuImageFilterChosenListener listener) {
         final FilterList filters = new FilterList();
-//        filters.addFilter("Me!Me!Me!", FilterType.DOUBLE);
+        filters.addFilter("Me!Me!Me!", FilterType.TEST);
         filters.addFilter("Contrast", FilterType.CONTRAST);
         filters.addFilter("Invert", FilterType.INVERT);
+        filters.addFilter("Grouped", FilterType.FILTER_GROUP);
+        filters.addFilter("Grouped2", FilterType.FILTER_GROUP2);
+
         filters.addFilter("Pixelation", FilterType.PIXELATION);
         filters.addFilter("Hue", FilterType.HUE);
         filters.addFilter("Gamma", FilterType.GAMMA);
@@ -122,7 +127,6 @@ public static void showDialog(final Context context,
         filters.addFilter("3x3 Convolution", FilterType.THREE_X_THREE_CONVOLUTION);
         filters.addFilter("Emboss", FilterType.EMBOSS);
         filters.addFilter("Posterize", FilterType.POSTERIZE);
-        filters.addFilter("Grouped filters", FilterType.FILTER_GROUP);
         filters.addFilter("Saturation", FilterType.SATURATION);
         filters.addFilter("Exposure", FilterType.EXPOSURE);
         filters.addFilter("Highlight Shadow", FilterType.HIGHLIGHT_SHADOW);
@@ -181,16 +185,10 @@ public static void showDialog(final Context context,
         filters.addFilter("Swirl", FilterType.SWIRL);
         filters.addFilter("Weak Pixel Inclusion", FilterType.WEAK_PIXEL_INCLUSION);
         filters.addFilter("False Color", FilterType.FALSE_COLOR);
-
         filters.addFilter("Color Balance", FilterType.COLOR_BALANCE);
-
         filters.addFilter("Levels Min (Mid Adjust)", FilterType.LEVELS_FILTER_MIN);
-
-        filters. addFilter("Bilateral Blur", FilterType.BILATERAL_BLUR);
-
+        filters.addFilter("Bilateral Blur", FilterType.BILATERAL_BLUR);
         filters.addFilter("Transform (2-D)", FilterType.TRANSFORM2D);
-
-
         AlertDialog.Builder builder = new AlertDialog.Builder(context);
         builder.setTitle("Choose a filter");
         builder.setItems(filters.names.toArray(new String[filters.names.size()]),
@@ -198,25 +196,39 @@ public static void showDialog(final Context context,
                     @Override
                     public void onClick(final DialogInterface dialog, final int item) {
                         listener.onGpuImageFilterChosenListener(
-//                                createFilterForType(context, filters.filters.get(item))
-                                doubleFilter(context, filters.filters.get(item))
+                                createFilterForType(context, filters.filters.get(item))
+//                                doubleFilter(context, filters.filters.get(item))
                         );
                     }
                 });
         builder.create().show();
     }
 
-    private static GPUImageFilter doubleFilter(final Context context, final FilterType type){
-        List<GPUImageFilter> filters = new LinkedList<GPUImageFilter>();
-        filters.add(new DoubleFilter());
-        filters.add(createFilterForType(context,type));
+    private static GPUImageFilter doubleFilter(final Context context, final FilterType type) {
+        List<GPUImageFilter> filters = new ArrayList<>();
+        filters.add(createBlendFilter(context,DoubleFilter.class));
+        filters.add(createFilterForType(context, type));
+        filters.add(new GPUImageFilter());
         return new GPUImageFilterGroup(filters);
     }
 
     private static GPUImageFilter createFilterForType(final Context context, final FilterType type) {
         switch (type) {
-            case DOUBLE:
-                return new DoubleFilter();
+            case TEST:
+                return new TransitionFilter();
+            case FILTER_GROUP:
+                List<GPUImageFilter> filters = new LinkedList<GPUImageFilter>();
+                filters.add(new GPUImageContrastFilter());
+                filters.add(new GPUImageDirectionalSobelEdgeDetectionFilter());
+                filters.add(new GPUImageGrayscaleFilter());
+                return new GPUImageFilterGroup(filters);
+            case FILTER_GROUP2:
+                List<GPUImageFilter> filters2 = new LinkedList<GPUImageFilter>();
+                filters2.add(new GPUImageContrastFilter());
+                filters2.add(new GPUImageHueFilter());
+                filters2.add(new GPUImageGrayscaleFilter());
+                return new GPUImageFilterGroup(filters2);
+
             case CONTRAST:
                 return new GPUImageContrastFilter(2.0f);
             case GAMMA:
@@ -241,7 +253,7 @@ private static GPUImageFilter createFilterForType(final Context context, final F
                 return new GPUImageSobelEdgeDetection();
             case THREE_X_THREE_CONVOLUTION:
                 GPUImage3x3ConvolutionFilter convolution = new GPUImage3x3ConvolutionFilter();
-                convolution.setConvolutionKernel(new float[] {
+                convolution.setConvolutionKernel(new float[]{
                         -1.0f, 0.0f, 1.0f,
                         -2.0f, 0.0f, 2.0f,
                         -1.0f, 0.0f, 1.0f
@@ -251,20 +263,15 @@ private static GPUImageFilter createFilterForType(final Context context, final F
                 return new GPUImageEmbossFilter();
             case POSTERIZE:
                 return new GPUImagePosterizeFilter();
-            case FILTER_GROUP:
-                List<GPUImageFilter> filters = new LinkedList<GPUImageFilter>();
-                filters.add(new GPUImageContrastFilter());
-                filters.add(new GPUImageDirectionalSobelEdgeDetectionFilter());
-                filters.add(new GPUImageGrayscaleFilter());
-                return new GPUImageFilterGroup(filters);
+
             case SATURATION:
                 return new GPUImageSaturationFilter(1.0f);
             case EXPOSURE:
                 return new GPUImageExposureFilter(0.0f);
             case HIGHLIGHT_SHADOW:
-            	return new GPUImageHighlightShadowFilter(0.0f, 1.0f);
+                return new GPUImageHighlightShadowFilter(0.0f, 1.0f);
             case MONOCHROME:
-            	return new GPUImageMonochromeFilter(1.0f, new float[]{0.6f, 0.45f, 0.3f, 1.0f});
+                return new GPUImageMonochromeFilter(1.0f, new float[]{0.6f, 0.45f, 0.3f, 1.0f});
             case OPACITY:
                 return new GPUImageOpacityFilter(1.0f);
             case RGB:
@@ -275,7 +282,7 @@ private static GPUImageFilter createFilterForType(final Context context, final F
                 PointF centerPoint = new PointF();
                 centerPoint.x = 0.5f;
                 centerPoint.y = 0.5f;
-                return new GPUImageVignetteFilter(centerPoint, new float[] {0.0f, 0.0f, 0.0f}, 0.3f, 0.75f);
+                return new GPUImageVignetteFilter(centerPoint, new float[]{0.0f, 0.0f, 0.0f}, 0.3f, 0.75f);
             case TONE_CURVE:
                 GPUImageToneCurveFilter toneCurveFilter = new GPUImageToneCurveFilter();
                 toneCurveFilter.setFromCurveFileInputStream(
@@ -295,8 +302,6 @@ private static GPUImageFilter createFilterForType(final Context context, final F
                 return createBlendFilter(context, GPUImageDissolveBlendFilter.class);
             case BLEND_EXCLUSION:
                 return createBlendFilter(context, GPUImageExclusionBlendFilter.class);
-
-
             case BLEND_HARD_LIGHT:
                 return createBlendFilter(context, GPUImageHardLightBlendFilter.class);
             case BLEND_LIGHTEN:
@@ -331,7 +336,6 @@ private static GPUImageFilter createFilterForType(final Context context, final F
                 return createBlendFilter(context, GPUImageChromaKeyBlendFilter.class);
             case BLEND_NORMAL:
                 return createBlendFilter(context, GPUImageNormalBlendFilter.class);
-
             case LOOKUP_AMATORKA:
                 GPUImageLookupFilter amatorka = new GPUImageLookupFilter();
                 amatorka.setBitmap(BitmapFactory.decodeResource(context.getResources(), R.drawable.lookup_amatorka));
@@ -356,7 +360,6 @@ private static GPUImageFilter createFilterForType(final Context context, final F
                 return new GPUImageToonFilter();
             case SMOOTH_TOON:
                 return new GPUImageSmoothToonFilter();
-
             case BULGE_DISTORTION:
                 return new GPUImageBulgeDistortionFilter();
             case GLASS_SPHERE:
@@ -412,7 +415,7 @@ private static GPUImageFilter createBlendFilter(Context context, Class<? extends
     }
 
     private enum FilterType {
-        DOUBLE,CONTRAST, GRAYSCALE, SHARPEN, SEPIA, SOBEL_EDGE_DETECTION, THREE_X_THREE_CONVOLUTION, FILTER_GROUP, EMBOSS, POSTERIZE, GAMMA, BRIGHTNESS, INVERT, HUE, PIXELATION,
+        TEST, CONTRAST, GRAYSCALE, SHARPEN, SEPIA, SOBEL_EDGE_DETECTION, THREE_X_THREE_CONVOLUTION, FILTER_GROUP, FILTER_GROUP2, EMBOSS, POSTERIZE, GAMMA, BRIGHTNESS, INVERT, HUE, PIXELATION,
         SATURATION, EXPOSURE, HIGHLIGHT_SHADOW, MONOCHROME, OPACITY, RGB, WHITE_BALANCE, VIGNETTE, TONE_CURVE, BLEND_COLOR_BURN, BLEND_COLOR_DODGE, BLEND_DARKEN, BLEND_DIFFERENCE,
         BLEND_DISSOLVE, BLEND_EXCLUSION, BLEND_SOURCE_OVER, BLEND_HARD_LIGHT, BLEND_LIGHTEN, BLEND_ADD, BLEND_DIVIDE, BLEND_MULTIPLY, BLEND_OVERLAY, BLEND_SCREEN, BLEND_ALPHA,
         BLEND_COLOR, BLEND_HUE, BLEND_SATURATION, BLEND_LUMINOSITY, BLEND_LINEAR_BURN, BLEND_SOFT_LIGHT, BLEND_SUBTRACT, BLEND_CHROMA_KEY, BLEND_NORMAL, LOOKUP_AMATORKA,
@@ -496,8 +499,7 @@ public FilterAdjuster(final GPUImageFilter filter) {
                 adjuster = new BilateralAdjuster().filter(filter);
             } else if (filter instanceof GPUImageTransformFilter) {
                 adjuster = new RotateAdjuster().filter(filter);
-            }
-            else {
+            } else {
 
                 adjuster = null;
             }
@@ -545,17 +547,17 @@ public void adjust(final int percentage) {
         }
 
         private class PixelationAdjuster extends Adjuster<GPUImagePixelationFilter> {
-          @Override
-          public void adjust(final int percentage) {
-              getFilter().setPixel(range(percentage, 1.0f, 100.0f));
-          }
+            @Override
+            public void adjust(final int percentage) {
+                getFilter().setPixel(range(percentage, 1.0f, 100.0f));
+            }
         }
 
         private class HueAdjuster extends Adjuster<GPUImageHueFilter> {
-          @Override
-          public void adjust(final int percentage) {
-            getFilter().setHue(range(percentage, 0.0f, 360.0f));
-          }
+            @Override
+            public void adjust(final int percentage) {
+                getFilter().setHue(range(percentage, 0.0f, 360.0f));
+            }
         }
 
         private class ContrastAdjuster extends Adjuster<GPUImageContrastFilter> {
diff --git a/sample/src/jp/co/cyberagent/android/gpuimage/sample/activity/ActivityCamera.java b/sample/src/jp/co/cyberagent/android/gpuimage/sample/activity/ActivityCamera.java
index 0c252e0a..e1dc99b6 100644
--- a/sample/src/jp/co/cyberagent/android/gpuimage/sample/activity/ActivityCamera.java
+++ b/sample/src/jp/co/cyberagent/android/gpuimage/sample/activity/ActivityCamera.java
@@ -213,12 +213,12 @@ private static File getOutputMediaFile(final int type) {
     }
 
     private void switchFilterTo(final GPUImageFilter filter) {
-        if (mFilter == null
-                || (filter != null && !mFilter.getClass().equals(filter.getClass()))) {
+        // TODO: 2017/9/13 大大滴bug，滤镜组类名一样导致不能切换
+//        if (mFilter == null || (filter != null && !mFilter.getClass().equals(filter.getClass()))) {
             mFilter = filter;
             mGPUImage.setFilter(mFilter);
             mFilterAdjuster = new FilterAdjuster(mFilter);
-        }
+//        }
     }
 
     @Override
