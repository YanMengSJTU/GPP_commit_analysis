diff --git a/build.gradle b/build.gradle
index ecc0a83e..fddeb7bb 100644
--- a/build.gradle
+++ b/build.gradle
@@ -5,7 +5,7 @@ buildscript {
         jcenter()
     }
     dependencies {
-        classpath 'com.android.tools.build:gradle:2.0.0-beta6'
+        classpath 'com.android.tools.build:gradle:2.3.3'
     }
 }
 
diff --git a/gradle/wrapper/gradle-wrapper.properties b/gradle/wrapper/gradle-wrapper.properties
index 6c0732ab..e3e7e2f5 100644
--- a/gradle/wrapper/gradle-wrapper.properties
+++ b/gradle/wrapper/gradle-wrapper.properties
@@ -1,6 +1,6 @@
-#Sat Dec 06 18:27:05 JST 2014
+#Thu Aug 30 15:45:03 CST 2018
 distributionBase=GRADLE_USER_HOME
 distributionPath=wrapper/dists
 zipStoreBase=GRADLE_USER_HOME
 zipStorePath=wrapper/dists
-distributionUrl=https\://services.gradle.org/distributions/gradle-2.11-all.zip
+distributionUrl=https\://services.gradle.org/distributions/gradle-3.3-all.zip
diff --git a/library/build.gradle b/library/build.gradle
index 3cd5e8c4..af16ebf3 100644
--- a/library/build.gradle
+++ b/library/build.gradle
@@ -55,6 +55,7 @@ android {
             from tasks["javadoc${variant.name.capitalize()}"]
         }
     }
+    buildToolsVersion '25.0.0'
 }
 
 apply from: 'android-artifacts.gradle'
diff --git a/library/jni/yuv-decoder.c b/library/jni/yuv-decoder.c
index fed6281e..bddd8ff5 100644
--- a/library/jni/yuv-decoder.c
+++ b/library/jni/yuv-decoder.c
@@ -1,7 +1,6 @@
 #include <jni.h>
 #include <android/log.h>
 
-
 JNIEXPORT void JNICALL Java_jp_co_cyberagent_android_gpuimage_GPUImageNativeLibrary_YUVtoRBGA(JNIEnv * env, jobject obj, jbyteArray yuv420sp, jint width, jint height, jintArray rgbOut)
 {
     int             sz;
diff --git a/library/src/jp/co/cyberagent/android/gpuimage/GPUImage.java b/library/src/jp/co/cyberagent/android/gpuimage/GPUImage.java
index 8392a5a9..15019b88 100644
--- a/library/src/jp/co/cyberagent/android/gpuimage/GPUImage.java
+++ b/library/src/jp/co/cyberagent/android/gpuimage/GPUImage.java
@@ -49,6 +49,7 @@
  * tasks through a simple interface.
  */
 public class GPUImage {
+
     private final Context mContext;
     private final GPUImageRenderer mRenderer;
     private GLSurfaceView mGlSurfaceView;
@@ -138,7 +139,7 @@ public void setUpCamera(final Camera camera) {
      * @param flipVertical if the image should be flipped vertically
      */
     public void setUpCamera(final Camera camera, final int degrees, final boolean flipHorizontal,
-            final boolean flipVertical) {
+                            final boolean flipVertical) {
         mGlSurfaceView.setRenderMode(GLSurfaceView.RENDERMODE_CONTINUOUSLY);
         if (Build.VERSION.SDK_INT > Build.VERSION_CODES.GINGERBREAD_MR1) {
             setUpCameraGingerbread(camera);
@@ -285,13 +286,13 @@ public Bitmap getBitmapWithFilterApplied(final Bitmap bitmap) {
 
                 @Override
                 public void run() {
-                    synchronized(mFilter) {
+                    synchronized (mFilter) {
                         mFilter.destroy();
                         mFilter.notify();
                     }
                 }
             });
-            synchronized(mFilter) {
+            synchronized (mFilter) {
                 requestRender();
                 try {
                     mFilter.wait();
@@ -334,7 +335,8 @@ public void run() {
      * @param listener the listener on which the results will be notified
      */
     public static void getBitmapForMultipleFilters(final Bitmap bitmap,
-            final List<GPUImageFilter> filters, final ResponseListener<Bitmap> listener) {
+                                                   final List<GPUImageFilter> filters,
+                                                   final ResponseListener<Bitmap> listener) {
         if (filters.isEmpty()) {
             return;
         }
@@ -353,14 +355,12 @@ public static void getBitmapForMultipleFilters(final Bitmap bitmap,
     }
 
     /**
-     * Deprecated: Please use
-     * {@link GPUImageView#saveToPictures(String, String, jp.co.cyberagent.android.gpuimage.GPUImageView.OnPictureSavedListener)}
+     * Deprecated: Please use {@link GPUImageView#saveToPictures(String, String,
+     * jp.co.cyberagent.android.gpuimage.GPUImageView.OnPictureSavedListener)}
      *
-     * Save current image with applied filter to Pictures. It will be stored on
-     * the default Picture folder on the phone below the given folderName and
-     * fileName. <br>
-     * This method is async and will notify when the image was saved through the
-     * listener.
+     * Save current image with applied filter to Pictures. It will be stored on the default Picture
+     * folder on the phone below the given folderName and fileName. <br> This method is async and
+     * will notify when the image was saved through the listener.
      *
      * @param folderName the folder name
      * @param fileName the file name
@@ -368,19 +368,17 @@ public static void getBitmapForMultipleFilters(final Bitmap bitmap,
      */
     @Deprecated
     public void saveToPictures(final String folderName, final String fileName,
-            final OnPictureSavedListener listener) {
+                               final OnPictureSavedListener listener) {
         saveToPictures(mCurrentBitmap, folderName, fileName, listener);
     }
 
     /**
-     * Deprecated: Please use
-     * {@link GPUImageView#saveToPictures(String, String, jp.co.cyberagent.android.gpuimage.GPUImageView.OnPictureSavedListener)}
+     * Deprecated: Please use {@link GPUImageView#saveToPictures(String, String,
+     * jp.co.cyberagent.android.gpuimage.GPUImageView.OnPictureSavedListener)}
      *
-     * Apply and save the given bitmap with applied filter to Pictures. It will
-     * be stored on the default Picture folder on the phone below the given
-     * folerName and fileName. <br>
-     * This method is async and will notify when the image was saved through the
-     * listener.
+     * Apply and save the given bitmap with applied filter to Pictures. It will be stored on the
+     * default Picture folder on the phone below the given folerName and fileName. <br> This method
+     * is async and will notify when the image was saved through the listener.
      *
      * @param bitmap the bitmap
      * @param folderName the folder name
@@ -389,7 +387,7 @@ public void saveToPictures(final String folderName, final String fileName,
      */
     @Deprecated
     public void saveToPictures(final Bitmap bitmap, final String folderName, final String fileName,
-            final OnPictureSavedListener listener) {
+                               final OnPictureSavedListener listener) {
         new SaveTask(bitmap, folderName, fileName, listener).execute();
     }
 
@@ -438,7 +436,7 @@ private int getOutputHeight() {
         private final Handler mHandler;
 
         public SaveTask(final Bitmap bitmap, final String folderName, final String fileName,
-                final OnPictureSavedListener listener) {
+                        final OnPictureSavedListener listener) {
             mBitmap = bitmap;
             mFolderName = folderName;
             mFileName = fileName;
@@ -461,10 +459,11 @@ private void saveImage(final String folderName, final String fileName, final Bit
                 file.getParentFile().mkdirs();
                 image.compress(CompressFormat.JPEG, 80, new FileOutputStream(file));
                 MediaScannerConnection.scanFile(mContext,
-                        new String[] {
-                            file.toString()
+                        new String[]{
+                                file.toString()
                         }, null,
                         new MediaScannerConnection.OnScanCompletedListener() {
+
                             @Override
                             public void onScanCompleted(final String path, final Uri uri) {
                                 if (mListener != null) {
@@ -485,6 +484,7 @@ public void run() {
     }
 
     public interface OnPictureSavedListener {
+
         void onPictureSaved(Uri uri);
     }
 
@@ -516,7 +516,7 @@ protected Bitmap decode(BitmapFactory.Options options) {
         @Override
         protected int getImageOrientation() throws IOException {
             Cursor cursor = mContext.getContentResolver().query(mUri,
-                    new String[] { MediaStore.Images.ImageColumns.ORIENTATION }, null, null, null);
+                    new String[]{MediaStore.Images.ImageColumns.ORIENTATION}, null, null, null);
 
             if (cursor == null || cursor.getCount() != 1) {
                 return 0;
@@ -603,7 +603,8 @@ private Bitmap loadResizedImage() {
             options.inJustDecodeBounds = true;
             decode(options);
             int scale = 1;
-            while (checkSize(options.outWidth / scale > mOutputWidth, options.outHeight / scale > mOutputHeight)) {
+            while (checkSize(options.outWidth / scale > mOutputWidth,
+                    options.outHeight / scale > mOutputHeight)) {
                 scale++;
             }
 
@@ -710,8 +711,9 @@ private Bitmap rotateImage(final Bitmap bitmap) {
     }
 
     public interface ResponseListener<T> {
+
         void response(T item);
     }
 
-    public enum ScaleType { CENTER_INSIDE, CENTER_CROP }
+    public enum ScaleType {CENTER_INSIDE, CENTER_CROP}
 }
diff --git a/library/src/jp/co/cyberagent/android/gpuimage/GPUImage3x3ConvolutionFilter.java b/library/src/jp/co/cyberagent/android/gpuimage/GPUImage3x3ConvolutionFilter.java
index 0c5e5a03..33219f0b 100644
--- a/library/src/jp/co/cyberagent/android/gpuimage/GPUImage3x3ConvolutionFilter.java
+++ b/library/src/jp/co/cyberagent/android/gpuimage/GPUImage3x3ConvolutionFilter.java
@@ -22,59 +22,69 @@
  * Runs a 3x3 convolution kernel against the image
  */
 public class GPUImage3x3ConvolutionFilter extends GPUImage3x3TextureSamplingFilter {
+
     public static final String THREE_X_THREE_TEXTURE_SAMPLING_FRAGMENT_SHADER = "" +
-            "precision highp float;\n" + 
-            "\n" + 
-            "uniform sampler2D inputImageTexture;\n" + 
-            "\n" + 
-            "uniform mediump mat3 convolutionMatrix;\n" + 
-            "\n" + 
-            "varying vec2 textureCoordinate;\n" + 
-            "varying vec2 leftTextureCoordinate;\n" + 
-            "varying vec2 rightTextureCoordinate;\n" + 
-            "\n" + 
-            "varying vec2 topTextureCoordinate;\n" + 
-            "varying vec2 topLeftTextureCoordinate;\n" + 
-            "varying vec2 topRightTextureCoordinate;\n" + 
-            "\n" + 
-            "varying vec2 bottomTextureCoordinate;\n" + 
-            "varying vec2 bottomLeftTextureCoordinate;\n" + 
-            "varying vec2 bottomRightTextureCoordinate;\n" + 
-            "\n" + 
-            "void main()\n" + 
-            "{\n" + 
-            "    mediump vec4 bottomColor = texture2D(inputImageTexture, bottomTextureCoordinate);\n" + 
-            "    mediump vec4 bottomLeftColor = texture2D(inputImageTexture, bottomLeftTextureCoordinate);\n" + 
-            "    mediump vec4 bottomRightColor = texture2D(inputImageTexture, bottomRightTextureCoordinate);\n" + 
-            "    mediump vec4 centerColor = texture2D(inputImageTexture, textureCoordinate);\n" + 
-            "    mediump vec4 leftColor = texture2D(inputImageTexture, leftTextureCoordinate);\n" + 
-            "    mediump vec4 rightColor = texture2D(inputImageTexture, rightTextureCoordinate);\n" + 
-            "    mediump vec4 topColor = texture2D(inputImageTexture, topTextureCoordinate);\n" + 
-            "    mediump vec4 topRightColor = texture2D(inputImageTexture, topRightTextureCoordinate);\n" + 
-            "    mediump vec4 topLeftColor = texture2D(inputImageTexture, topLeftTextureCoordinate);\n" + 
-            "\n" + 
-            "    mediump vec4 resultColor = topLeftColor * convolutionMatrix[0][0] + topColor * convolutionMatrix[0][1] + topRightColor * convolutionMatrix[0][2];\n" + 
-            "    resultColor += leftColor * convolutionMatrix[1][0] + centerColor * convolutionMatrix[1][1] + rightColor * convolutionMatrix[1][2];\n" + 
-            "    resultColor += bottomLeftColor * convolutionMatrix[2][0] + bottomColor * convolutionMatrix[2][1] + bottomRightColor * convolutionMatrix[2][2];\n" + 
-            "\n" + 
-            "    gl_FragColor = resultColor;\n" + 
-            "}"; 
- 
+            "precision highp float;\n" +
+            "\n" +
+            "uniform sampler2D inputImageTexture;\n" +
+            "\n" +
+            "uniform mediump mat3 convolutionMatrix;\n" +
+            "\n" +
+            "varying vec2 textureCoordinate;\n" +
+            "varying vec2 leftTextureCoordinate;\n" +
+            "varying vec2 rightTextureCoordinate;\n" +
+            "\n" +
+            "varying vec2 topTextureCoordinate;\n" +
+            "varying vec2 topLeftTextureCoordinate;\n" +
+            "varying vec2 topRightTextureCoordinate;\n" +
+            "\n" +
+            "varying vec2 bottomTextureCoordinate;\n" +
+            "varying vec2 bottomLeftTextureCoordinate;\n" +
+            "varying vec2 bottomRightTextureCoordinate;\n" +
+            "\n" +
+            "void main()\n" +
+            "{\n" +
+            "    mediump vec4 bottomColor = texture2D(inputImageTexture, bottomTextureCoordinate);\n"
+            +
+            "    mediump vec4 bottomLeftColor = texture2D(inputImageTexture, bottomLeftTextureCoordinate);\n"
+            +
+            "    mediump vec4 bottomRightColor = texture2D(inputImageTexture, bottomRightTextureCoordinate);\n"
+            +
+            "    mediump vec4 centerColor = texture2D(inputImageTexture, textureCoordinate);\n" +
+            "    mediump vec4 leftColor = texture2D(inputImageTexture, leftTextureCoordinate);\n" +
+            "    mediump vec4 rightColor = texture2D(inputImageTexture, rightTextureCoordinate);\n"
+            +
+            "    mediump vec4 topColor = texture2D(inputImageTexture, topTextureCoordinate);\n" +
+            "    mediump vec4 topRightColor = texture2D(inputImageTexture, topRightTextureCoordinate);\n"
+            +
+            "    mediump vec4 topLeftColor = texture2D(inputImageTexture, topLeftTextureCoordinate);\n"
+            +
+            "\n" +
+            "    mediump vec4 resultColor = topLeftColor * convolutionMatrix[0][0] + topColor * convolutionMatrix[0][1] + topRightColor * convolutionMatrix[0][2];\n"
+            +
+            "    resultColor += leftColor * convolutionMatrix[1][0] + centerColor * convolutionMatrix[1][1] + rightColor * convolutionMatrix[1][2];\n"
+            +
+            "    resultColor += bottomLeftColor * convolutionMatrix[2][0] + bottomColor * convolutionMatrix[2][1] + bottomRightColor * convolutionMatrix[2][2];\n"
+            +
+            "\n" +
+            "    gl_FragColor = resultColor;\n" +
+            "}";
+
     private float[] mConvolutionKernel;
     private int mUniformConvolutionMatrix;
 
     /**
      * Instantiates a new GPUimage3x3ConvolutionFilter with default values, that
-     * will look like the original image. 
+     * will look like the original image.
      */
     public GPUImage3x3ConvolutionFilter() {
-        this(new float[] {
+        this(new float[]{
                 0.0f, 0.0f, 0.0f,
                 0.0f, 1.0f, 0.0f,
                 0.0f, 0.0f, 0.0f
         });
     }
-    
+
     /**
      * Instantiates a new GPUimage3x3ConvolutionFilter with given convolution kernel.
      *
diff --git a/library/src/jp/co/cyberagent/android/gpuimage/GPUImage3x3TextureSamplingFilter.java b/library/src/jp/co/cyberagent/android/gpuimage/GPUImage3x3TextureSamplingFilter.java
index 2e6820a3..725d9390 100644
--- a/library/src/jp/co/cyberagent/android/gpuimage/GPUImage3x3TextureSamplingFilter.java
+++ b/library/src/jp/co/cyberagent/android/gpuimage/GPUImage3x3TextureSamplingFilter.java
@@ -19,52 +19,55 @@
 import android.opengl.GLES20;
 
 public class GPUImage3x3TextureSamplingFilter extends GPUImageFilter {
+
     public static final String THREE_X_THREE_TEXTURE_SAMPLING_VERTEX_SHADER = "" +
-            "attribute vec4 position;\n" + 
-            "attribute vec4 inputTextureCoordinate;\n" + 
-            "\n" + 
-            "uniform highp float texelWidth; \n" + 
-            "uniform highp float texelHeight; \n" + 
-            "\n" + 
-            "varying vec2 textureCoordinate;\n" + 
-            "varying vec2 leftTextureCoordinate;\n" + 
-            "varying vec2 rightTextureCoordinate;\n" + 
-            "\n" + 
-            "varying vec2 topTextureCoordinate;\n" + 
-            "varying vec2 topLeftTextureCoordinate;\n" + 
-            "varying vec2 topRightTextureCoordinate;\n" + 
-            "\n" + 
-            "varying vec2 bottomTextureCoordinate;\n" + 
-            "varying vec2 bottomLeftTextureCoordinate;\n" + 
-            "varying vec2 bottomRightTextureCoordinate;\n" + 
-            "\n" + 
-            "void main()\n" + 
-            "{\n" + 
-            "    gl_Position = position;\n" + 
-            "\n" + 
-            "    vec2 widthStep = vec2(texelWidth, 0.0);\n" + 
-            "    vec2 heightStep = vec2(0.0, texelHeight);\n" + 
-            "    vec2 widthHeightStep = vec2(texelWidth, texelHeight);\n" + 
-            "    vec2 widthNegativeHeightStep = vec2(texelWidth, -texelHeight);\n" + 
-            "\n" + 
-            "    textureCoordinate = inputTextureCoordinate.xy;\n" + 
-            "    leftTextureCoordinate = inputTextureCoordinate.xy - widthStep;\n" + 
-            "    rightTextureCoordinate = inputTextureCoordinate.xy + widthStep;\n" + 
-            "\n" + 
-            "    topTextureCoordinate = inputTextureCoordinate.xy - heightStep;\n" + 
-            "    topLeftTextureCoordinate = inputTextureCoordinate.xy - widthHeightStep;\n" + 
-            "    topRightTextureCoordinate = inputTextureCoordinate.xy + widthNegativeHeightStep;\n" + 
-            "\n" + 
-            "    bottomTextureCoordinate = inputTextureCoordinate.xy + heightStep;\n" + 
-            "    bottomLeftTextureCoordinate = inputTextureCoordinate.xy - widthNegativeHeightStep;\n" + 
-            "    bottomRightTextureCoordinate = inputTextureCoordinate.xy + widthHeightStep;\n" + 
+            "attribute vec4 position;\n" +
+            "attribute vec4 inputTextureCoordinate;\n" +
+            "\n" +
+            "uniform highp float texelWidth; \n" +
+            "uniform highp float texelHeight; \n" +
+            "\n" +
+            "varying vec2 textureCoordinate;\n" +
+            "varying vec2 leftTextureCoordinate;\n" +
+            "varying vec2 rightTextureCoordinate;\n" +
+            "\n" +
+            "varying vec2 topTextureCoordinate;\n" +
+            "varying vec2 topLeftTextureCoordinate;\n" +
+            "varying vec2 topRightTextureCoordinate;\n" +
+            "\n" +
+            "varying vec2 bottomTextureCoordinate;\n" +
+            "varying vec2 bottomLeftTextureCoordinate;\n" +
+            "varying vec2 bottomRightTextureCoordinate;\n" +
+            "\n" +
+            "void main()\n" +
+            "{\n" +
+            "    gl_Position = position;\n" +
+            "\n" +
+            "    vec2 widthStep = vec2(texelWidth, 0.0);\n" +
+            "    vec2 heightStep = vec2(0.0, texelHeight);\n" +
+            "    vec2 widthHeightStep = vec2(texelWidth, texelHeight);\n" +
+            "    vec2 widthNegativeHeightStep = vec2(texelWidth, -texelHeight);\n" +
+            "\n" +
+            "    textureCoordinate = inputTextureCoordinate.xy;\n" +
+            "    leftTextureCoordinate = inputTextureCoordinate.xy - widthStep;\n" +
+            "    rightTextureCoordinate = inputTextureCoordinate.xy + widthStep;\n" +
+            "\n" +
+            "    topTextureCoordinate = inputTextureCoordinate.xy - heightStep;\n" +
+            "    topLeftTextureCoordinate = inputTextureCoordinate.xy - widthHeightStep;\n" +
+            "    topRightTextureCoordinate = inputTextureCoordinate.xy + widthNegativeHeightStep;\n"
+            +
+            "\n" +
+            "    bottomTextureCoordinate = inputTextureCoordinate.xy + heightStep;\n" +
+            "    bottomLeftTextureCoordinate = inputTextureCoordinate.xy - widthNegativeHeightStep;\n"
+            +
+            "    bottomRightTextureCoordinate = inputTextureCoordinate.xy + widthHeightStep;\n" +
             "}";
 
     private int mUniformTexelWidthLocation;
     private int mUniformTexelHeightLocation;
 
     private boolean mHasOverriddenImageSizeFactor = false;
-    private float mTexelWidth; 
+    private float mTexelWidth;
     private float mTexelHeight;
     private float mLineSize = 1.0f;
 
diff --git a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageAddBlendFilter.java b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageAddBlendFilter.java
index 59dcb343..95cce1ec 100644
--- a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageAddBlendFilter.java
+++ b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageAddBlendFilter.java
@@ -17,42 +17,47 @@
 package jp.co.cyberagent.android.gpuimage;
 
 public class GPUImageAddBlendFilter extends GPUImageTwoInputFilter {
-    public static final String ADD_BLEND_FRAGMENT_SHADER = "varying highp vec2 textureCoordinate;\n" +
-            " varying highp vec2 textureCoordinate2;\n" +
-            "\n" +
-            " uniform sampler2D inputImageTexture;\n" +
-            " uniform sampler2D inputImageTexture2;\n" +
-            " \n" +
-            " void main()\n" +
-            " {\n" +
-            "   lowp vec4 base = texture2D(inputImageTexture, textureCoordinate);\n" +
-            "   lowp vec4 overlay = texture2D(inputImageTexture2, textureCoordinate2);\n" +
-            "\n" +
-            "   mediump float r;\n" +
-            "   if (overlay.r * base.a + base.r * overlay.a >= overlay.a * base.a) {\n" +
-            "     r = overlay.a * base.a + overlay.r * (1.0 - base.a) + base.r * (1.0 - overlay.a);\n" +
-            "   } else {\n" +
-            "     r = overlay.r + base.r;\n" +
-            "   }\n" +
-            "\n" +
-            "   mediump float g;\n" +
-            "   if (overlay.g * base.a + base.g * overlay.a >= overlay.a * base.a) {\n" +
-            "     g = overlay.a * base.a + overlay.g * (1.0 - base.a) + base.g * (1.0 - overlay.a);\n" +
-            "   } else {\n" +
-            "     g = overlay.g + base.g;\n" +
-            "   }\n" +
-            "\n" +
-            "   mediump float b;\n" +
-            "   if (overlay.b * base.a + base.b * overlay.a >= overlay.a * base.a) {\n" +
-            "     b = overlay.a * base.a + overlay.b * (1.0 - base.a) + base.b * (1.0 - overlay.a);\n" +
-            "   } else {\n" +
-            "     b = overlay.b + base.b;\n" +
-            "   }\n" +
-            "\n" +
-            "   mediump float a = overlay.a + base.a - overlay.a * base.a;\n" +
-            "   \n" +
-            "   gl_FragColor = vec4(r, g, b, a);\n" +
-            " }";
+
+    public static final String ADD_BLEND_FRAGMENT_SHADER =
+            "varying highp vec2 textureCoordinate;\n" +
+                    " varying highp vec2 textureCoordinate2;\n" +
+                    "\n" +
+                    " uniform sampler2D inputImageTexture;\n" +
+                    " uniform sampler2D inputImageTexture2;\n" +
+                    " \n" +
+                    " void main()\n" +
+                    " {\n" +
+                    "   lowp vec4 base = texture2D(inputImageTexture, textureCoordinate);\n" +
+                    "   lowp vec4 overlay = texture2D(inputImageTexture2, textureCoordinate2);\n" +
+                    "\n" +
+                    "   mediump float r;\n" +
+                    "   if (overlay.r * base.a + base.r * overlay.a >= overlay.a * base.a) {\n" +
+                    "     r = overlay.a * base.a + overlay.r * (1.0 - base.a) + base.r * (1.0 - overlay.a);\n"
+                    +
+                    "   } else {\n" +
+                    "     r = overlay.r + base.r;\n" +
+                    "   }\n" +
+                    "\n" +
+                    "   mediump float g;\n" +
+                    "   if (overlay.g * base.a + base.g * overlay.a >= overlay.a * base.a) {\n" +
+                    "     g = overlay.a * base.a + overlay.g * (1.0 - base.a) + base.g * (1.0 - overlay.a);\n"
+                    +
+                    "   } else {\n" +
+                    "     g = overlay.g + base.g;\n" +
+                    "   }\n" +
+                    "\n" +
+                    "   mediump float b;\n" +
+                    "   if (overlay.b * base.a + base.b * overlay.a >= overlay.a * base.a) {\n" +
+                    "     b = overlay.a * base.a + overlay.b * (1.0 - base.a) + base.b * (1.0 - overlay.a);\n"
+                    +
+                    "   } else {\n" +
+                    "     b = overlay.b + base.b;\n" +
+                    "   }\n" +
+                    "\n" +
+                    "   mediump float a = overlay.a + base.a - overlay.a * base.a;\n" +
+                    "   \n" +
+                    "   gl_FragColor = vec4(r, g, b, a);\n" +
+                    " }";
 
     public GPUImageAddBlendFilter() {
         super(ADD_BLEND_FRAGMENT_SHADER);
diff --git a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageAlphaBlendFilter.java b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageAlphaBlendFilter.java
index 753c24d6..efa45ab2 100644
--- a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageAlphaBlendFilter.java
+++ b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageAlphaBlendFilter.java
@@ -17,24 +17,30 @@
 package jp.co.cyberagent.android.gpuimage;
 
 /**
- * Mix ranges from 0.0 (only image 1) to 1.0 (only image 2), with 0.5 (half of either) as the normal level
+ * Mix ranges from 0.0 (only image 1) to 1.0 (only image 2), with 0.5 (half of either) as the normal
+ * level
  */
-public class GPUImageAlphaBlendFilter extends GPUImageMixBlendFilter{
-    public static final String ALPHA_BLEND_FRAGMENT_SHADER = "varying highp vec2 textureCoordinate;\n" +
-            " varying highp vec2 textureCoordinate2;\n" +
-            "\n" +
-            " uniform sampler2D inputImageTexture;\n" +
-            " uniform sampler2D inputImageTexture2;\n" +
-            " \n" +
-            " uniform lowp float mixturePercent;\n" +
-            "\n" +
-            " void main()\n" +
-            " {\n" +
-            "   lowp vec4 textureColor = texture2D(inputImageTexture, textureCoordinate);\n" +
-            "   lowp vec4 textureColor2 = texture2D(inputImageTexture2, textureCoordinate2);\n" +
-            "\n" +
-            "   gl_FragColor = vec4(mix(textureColor.rgb, textureColor2.rgb, textureColor2.a * mixturePercent), textureColor.a);\n" +
-            " }";
+public class GPUImageAlphaBlendFilter extends GPUImageMixBlendFilter {
+
+    public static final String ALPHA_BLEND_FRAGMENT_SHADER =
+            "varying highp vec2 textureCoordinate;\n" +
+                    " varying highp vec2 textureCoordinate2;\n" +
+                    "\n" +
+                    " uniform sampler2D inputImageTexture;\n" +
+                    " uniform sampler2D inputImageTexture2;\n" +
+                    " \n" +
+                    " uniform lowp float mixturePercent;\n" +
+                    "\n" +
+                    " void main()\n" +
+                    " {\n" +
+                    "   lowp vec4 textureColor = texture2D(inputImageTexture, textureCoordinate);\n"
+                    +
+                    "   lowp vec4 textureColor2 = texture2D(inputImageTexture2, textureCoordinate2);\n"
+                    +
+                    "\n" +
+                    "   gl_FragColor = vec4(mix(textureColor.rgb, textureColor2.rgb, textureColor2.a * mixturePercent), textureColor.a);\n"
+                    +
+                    " }";
 
     public GPUImageAlphaBlendFilter() {
         super(ALPHA_BLEND_FRAGMENT_SHADER);
diff --git a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageBilateralFilter.java b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageBilateralFilter.java
index 275253ab..5231ca37 100644
--- a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageBilateralFilter.java
+++ b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageBilateralFilter.java
@@ -1,153 +1,161 @@
 /**
  * @author wysaid
  * @mail admin@wysaid.org
- *
-*/
+ */
 
 package jp.co.cyberagent.android.gpuimage;
 
 import android.opengl.GLES20;
 
-
 public class GPUImageBilateralFilter extends GPUImageFilter {
-	public static final String BILATERAL_VERTEX_SHADER = "" +
-			"attribute vec4 position;\n" + 
-			"attribute vec4 inputTextureCoordinate;\n" + 
-	 
-			"const int GAUSSIAN_SAMPLES = 9;\n" + 
-	 
-			"uniform vec2 singleStepOffset;\n" +  
-	 
-			"varying vec2 textureCoordinate;\n" + 
-			"varying vec2 blurCoordinates[GAUSSIAN_SAMPLES];\n" + 
-	 
-			"void main()\n" + 
-			"{\n" + 
-	     	"	gl_Position = position;\n" + 
-			"	textureCoordinate = inputTextureCoordinate.xy;\n" + 
-	     
-			"	int multiplier = 0;\n" + 
-			"	vec2 blurStep;\n" +  
-	     
-			"	for (int i = 0; i < GAUSSIAN_SAMPLES; i++)\n" + 
-	     	"	{\n" + 
-	        "		multiplier = (i - ((GAUSSIAN_SAMPLES - 1) / 2));\n" + 
-	        
-	        "		blurStep = float(multiplier) * singleStepOffset;\n" + 
-	        "		blurCoordinates[i] = inputTextureCoordinate.xy + blurStep;\n" + 
-	     	"	}\n" + 
-	 		"}";
-
-	public static final String BILATERAL_FRAGMENT_SHADER = "" + 
-			"uniform sampler2D inputImageTexture;\n" +
-
-			" const lowp int GAUSSIAN_SAMPLES = 9;\n" +
-
-			" varying highp vec2 textureCoordinate;\n" +
-			" varying highp vec2 blurCoordinates[GAUSSIAN_SAMPLES];\n" +
-
-			" uniform mediump float distanceNormalizationFactor;\n" +
-
-			" void main()\n" +
-			" {\n" +
-			"     lowp vec4 centralColor;\n" +
-			"     lowp float gaussianWeightTotal;\n" +
-			"     lowp vec4 sum;\n" +
-			"     lowp vec4 sampleColor;\n" +
-			"     lowp float distanceFromCentralColor;\n" +
-			"     lowp float gaussianWeight;\n" +
-			"     \n" +
-			"     centralColor = texture2D(inputImageTexture, blurCoordinates[4]);\n" +
-			"     gaussianWeightTotal = 0.18;\n" +
-			"     sum = centralColor * 0.18;\n" +
-			"     \n" +
-			"     sampleColor = texture2D(inputImageTexture, blurCoordinates[0]);\n" +
-			"     distanceFromCentralColor = min(distance(centralColor, sampleColor) * distanceNormalizationFactor, 1.0);\n" +
-			"     gaussianWeight = 0.05 * (1.0 - distanceFromCentralColor);\n" +
-			"     gaussianWeightTotal += gaussianWeight;\n" +
-			"     sum += sampleColor * gaussianWeight;\n" +
-
-			"     sampleColor = texture2D(inputImageTexture, blurCoordinates[1]);\n" +
-			"     distanceFromCentralColor = min(distance(centralColor, sampleColor) * distanceNormalizationFactor, 1.0);\n" +
-			"     gaussianWeight = 0.09 * (1.0 - distanceFromCentralColor);\n" +
-			"     gaussianWeightTotal += gaussianWeight;\n" +
-			"     sum += sampleColor * gaussianWeight;\n" +
-
-			"     sampleColor = texture2D(inputImageTexture, blurCoordinates[2]);\n" +
-			"     distanceFromCentralColor = min(distance(centralColor, sampleColor) * distanceNormalizationFactor, 1.0);\n" +
-			"     gaussianWeight = 0.12 * (1.0 - distanceFromCentralColor);\n" +
-			"     gaussianWeightTotal += gaussianWeight;\n" +
-			"     sum += sampleColor * gaussianWeight;\n" +
-
-			"     sampleColor = texture2D(inputImageTexture, blurCoordinates[3]);\n" +
-			"     distanceFromCentralColor = min(distance(centralColor, sampleColor) * distanceNormalizationFactor, 1.0);\n" +
-			"     gaussianWeight = 0.15 * (1.0 - distanceFromCentralColor);\n" +
-			"     gaussianWeightTotal += gaussianWeight;\n" +
-			"     sum += sampleColor * gaussianWeight;\n" +
-
-			"     sampleColor = texture2D(inputImageTexture, blurCoordinates[5]);\n" +
-			"     distanceFromCentralColor = min(distance(centralColor, sampleColor) * distanceNormalizationFactor, 1.0);\n" +
-			"     gaussianWeight = 0.15 * (1.0 - distanceFromCentralColor);\n" +
-			"     gaussianWeightTotal += gaussianWeight;\n" +
-			"     sum += sampleColor * gaussianWeight;\n" +
-
-			"     sampleColor = texture2D(inputImageTexture, blurCoordinates[6]);\n" +
-			"     distanceFromCentralColor = min(distance(centralColor, sampleColor) * distanceNormalizationFactor, 1.0);\n" +
-			"     gaussianWeight = 0.12 * (1.0 - distanceFromCentralColor);\n" +
-			"     gaussianWeightTotal += gaussianWeight;\n" +
-			"     sum += sampleColor * gaussianWeight;\n" +
-
-			"     sampleColor = texture2D(inputImageTexture, blurCoordinates[7]);\n" +
-			"     distanceFromCentralColor = min(distance(centralColor, sampleColor) * distanceNormalizationFactor, 1.0);\n" +
-			"     gaussianWeight = 0.09 * (1.0 - distanceFromCentralColor);\n" +
-			"     gaussianWeightTotal += gaussianWeight;\n" +
-			"     sum += sampleColor * gaussianWeight;\n" +
-
-			"     sampleColor = texture2D(inputImageTexture, blurCoordinates[8]);\n" +
-			"     distanceFromCentralColor = min(distance(centralColor, sampleColor) * distanceNormalizationFactor, 1.0);\n" +
-			"     gaussianWeight = 0.05 * (1.0 - distanceFromCentralColor);\n" +
-			"     gaussianWeightTotal += gaussianWeight;\n" +
-			"     sum += sampleColor * gaussianWeight;\n" +
-			"     gl_FragColor = sum / gaussianWeightTotal;\n" +
+
+    public static final String BILATERAL_VERTEX_SHADER = "" +
+            "attribute vec4 position;\n" +
+            "attribute vec4 inputTextureCoordinate;\n" +
+
+            "const int GAUSSIAN_SAMPLES = 9;\n" +
+
+            "uniform vec2 singleStepOffset;\n" +
+
+            "varying vec2 textureCoordinate;\n" +
+            "varying vec2 blurCoordinates[GAUSSIAN_SAMPLES];\n" +
+
+            "void main()\n" +
+            "{\n" +
+            "	gl_Position = position;\n" +
+            "	textureCoordinate = inputTextureCoordinate.xy;\n" +
+
+            "	int multiplier = 0;\n" +
+            "	vec2 blurStep;\n" +
+
+            "	for (int i = 0; i < GAUSSIAN_SAMPLES; i++)\n" +
+            "	{\n" +
+            "		multiplier = (i - ((GAUSSIAN_SAMPLES - 1) / 2));\n" +
+
+            "		blurStep = float(multiplier) * singleStepOffset;\n" +
+            "		blurCoordinates[i] = inputTextureCoordinate.xy + blurStep;\n" +
+            "	}\n" +
+            "}";
+
+    public static final String BILATERAL_FRAGMENT_SHADER = "" +
+            "uniform sampler2D inputImageTexture;\n" +
+
+            " const lowp int GAUSSIAN_SAMPLES = 9;\n" +
+
+            " varying highp vec2 textureCoordinate;\n" +
+            " varying highp vec2 blurCoordinates[GAUSSIAN_SAMPLES];\n" +
+
+            " uniform mediump float distanceNormalizationFactor;\n" +
+
+            " void main()\n" +
+            " {\n" +
+            "     lowp vec4 centralColor;\n" +
+            "     lowp float gaussianWeightTotal;\n" +
+            "     lowp vec4 sum;\n" +
+            "     lowp vec4 sampleColor;\n" +
+            "     lowp float distanceFromCentralColor;\n" +
+            "     lowp float gaussianWeight;\n" +
+            "     \n" +
+            "     centralColor = texture2D(inputImageTexture, blurCoordinates[4]);\n" +
+            "     gaussianWeightTotal = 0.18;\n" +
+            "     sum = centralColor * 0.18;\n" +
+            "     \n" +
+            "     sampleColor = texture2D(inputImageTexture, blurCoordinates[0]);\n" +
+            "     distanceFromCentralColor = min(distance(centralColor, sampleColor) * distanceNormalizationFactor, 1.0);\n"
+            +
+            "     gaussianWeight = 0.05 * (1.0 - distanceFromCentralColor);\n" +
+            "     gaussianWeightTotal += gaussianWeight;\n" +
+            "     sum += sampleColor * gaussianWeight;\n" +
+
+            "     sampleColor = texture2D(inputImageTexture, blurCoordinates[1]);\n" +
+            "     distanceFromCentralColor = min(distance(centralColor, sampleColor) * distanceNormalizationFactor, 1.0);\n"
+            +
+            "     gaussianWeight = 0.09 * (1.0 - distanceFromCentralColor);\n" +
+            "     gaussianWeightTotal += gaussianWeight;\n" +
+            "     sum += sampleColor * gaussianWeight;\n" +
+
+            "     sampleColor = texture2D(inputImageTexture, blurCoordinates[2]);\n" +
+            "     distanceFromCentralColor = min(distance(centralColor, sampleColor) * distanceNormalizationFactor, 1.0);\n"
+            +
+            "     gaussianWeight = 0.12 * (1.0 - distanceFromCentralColor);\n" +
+            "     gaussianWeightTotal += gaussianWeight;\n" +
+            "     sum += sampleColor * gaussianWeight;\n" +
+
+            "     sampleColor = texture2D(inputImageTexture, blurCoordinates[3]);\n" +
+            "     distanceFromCentralColor = min(distance(centralColor, sampleColor) * distanceNormalizationFactor, 1.0);\n"
+            +
+            "     gaussianWeight = 0.15 * (1.0 - distanceFromCentralColor);\n" +
+            "     gaussianWeightTotal += gaussianWeight;\n" +
+            "     sum += sampleColor * gaussianWeight;\n" +
+
+            "     sampleColor = texture2D(inputImageTexture, blurCoordinates[5]);\n" +
+            "     distanceFromCentralColor = min(distance(centralColor, sampleColor) * distanceNormalizationFactor, 1.0);\n"
+            +
+            "     gaussianWeight = 0.15 * (1.0 - distanceFromCentralColor);\n" +
+            "     gaussianWeightTotal += gaussianWeight;\n" +
+            "     sum += sampleColor * gaussianWeight;\n" +
+
+            "     sampleColor = texture2D(inputImageTexture, blurCoordinates[6]);\n" +
+            "     distanceFromCentralColor = min(distance(centralColor, sampleColor) * distanceNormalizationFactor, 1.0);\n"
+            +
+            "     gaussianWeight = 0.12 * (1.0 - distanceFromCentralColor);\n" +
+            "     gaussianWeightTotal += gaussianWeight;\n" +
+            "     sum += sampleColor * gaussianWeight;\n" +
+
+            "     sampleColor = texture2D(inputImageTexture, blurCoordinates[7]);\n" +
+            "     distanceFromCentralColor = min(distance(centralColor, sampleColor) * distanceNormalizationFactor, 1.0);\n"
+            +
+            "     gaussianWeight = 0.09 * (1.0 - distanceFromCentralColor);\n" +
+            "     gaussianWeightTotal += gaussianWeight;\n" +
+            "     sum += sampleColor * gaussianWeight;\n" +
+
+            "     sampleColor = texture2D(inputImageTexture, blurCoordinates[8]);\n" +
+            "     distanceFromCentralColor = min(distance(centralColor, sampleColor) * distanceNormalizationFactor, 1.0);\n"
+            +
+            "     gaussianWeight = 0.05 * (1.0 - distanceFromCentralColor);\n" +
+            "     gaussianWeightTotal += gaussianWeight;\n" +
+            "     sum += sampleColor * gaussianWeight;\n" +
+            "     gl_FragColor = sum / gaussianWeightTotal;\n" +
 //			" gl_FragColor.r = distanceNormalizationFactor / 20.0;" + 
-			" }";
-
-	private float mDistanceNormalizationFactor;
-	private int mDisFactorLocation;
-	private int mSingleStepOffsetLocation;
-	
-	public GPUImageBilateralFilter() {
-		this(8.0f);
-	}
-	
-	public GPUImageBilateralFilter(final float distanceNormalizationFactor) {
-		super(BILATERAL_VERTEX_SHADER, BILATERAL_FRAGMENT_SHADER);
-		mDistanceNormalizationFactor = distanceNormalizationFactor;
-	}
-	
-	@Override
-	public void onInit() {
-		super.onInit();
-		mDisFactorLocation = GLES20.glGetUniformLocation(getProgram(), "distanceNormalizationFactor");
-		mSingleStepOffsetLocation = GLES20.glGetUniformLocation(getProgram(), "singleStepOffset");
-	}
-	
-	@Override
-	public void onInitialized() {
-		super.onInitialized();
-		setDistanceNormalizationFactor(mDistanceNormalizationFactor);
-	}
-	
-	public void setDistanceNormalizationFactor(final float newValue) {
-		mDistanceNormalizationFactor = newValue;
-		setFloat(mDisFactorLocation, newValue);
-	}
-	
-	private void setTexelSize(final float w, final float h) {
-		setFloatVec2(mSingleStepOffsetLocation, new float[] {1.0f / w, 1.0f / h});
-	}
-	
-	@Override
+            " }";
+
+    private float mDistanceNormalizationFactor;
+    private int mDisFactorLocation;
+    private int mSingleStepOffsetLocation;
+
+    public GPUImageBilateralFilter() {
+        this(8.0f);
+    }
+
+    public GPUImageBilateralFilter(final float distanceNormalizationFactor) {
+        super(BILATERAL_VERTEX_SHADER, BILATERAL_FRAGMENT_SHADER);
+        mDistanceNormalizationFactor = distanceNormalizationFactor;
+    }
+
+    @Override
+    public void onInit() {
+        super.onInit();
+        mDisFactorLocation = GLES20
+                .glGetUniformLocation(getProgram(), "distanceNormalizationFactor");
+        mSingleStepOffsetLocation = GLES20.glGetUniformLocation(getProgram(), "singleStepOffset");
+    }
+
+    @Override
+    public void onInitialized() {
+        super.onInitialized();
+        setDistanceNormalizationFactor(mDistanceNormalizationFactor);
+    }
+
+    public void setDistanceNormalizationFactor(final float newValue) {
+        mDistanceNormalizationFactor = newValue;
+        setFloat(mDisFactorLocation, newValue);
+    }
+
+    private void setTexelSize(final float w, final float h) {
+        setFloatVec2(mSingleStepOffsetLocation, new float[]{1.0f / w, 1.0f / h});
+    }
+
+    @Override
     public void onOutputSizeChanged(final int width, final int height) {
         super.onOutputSizeChanged(width, height);
         setTexelSize(width, height);
diff --git a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageBoxBlurFilter.java b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageBoxBlurFilter.java
index 4e681b3c..4c051373 100644
--- a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageBoxBlurFilter.java
+++ b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageBoxBlurFilter.java
@@ -22,6 +22,7 @@
  * scaling: for the size of the applied blur, default of 1.0
  */
 public class GPUImageBoxBlurFilter extends GPUImageTwoPassTextureSamplingFilter {
+
     public static final String VERTEX_SHADER =
             "attribute vec4 position;\n" +
                     "attribute vec2 inputTextureCoordinate;\n" +
@@ -62,11 +63,16 @@
                     "\n" +
                     "void main()\n" +
                     "{\n" +
-                    "lowp vec4 fragmentColor = texture2D(inputImageTexture, centerTextureCoordinate) * 0.2;\n" +
-                    "fragmentColor += texture2D(inputImageTexture, oneStepLeftTextureCoordinate) * 0.2;\n" +
-                    "fragmentColor += texture2D(inputImageTexture, oneStepRightTextureCoordinate) * 0.2;\n" +
-                    "fragmentColor += texture2D(inputImageTexture, twoStepsLeftTextureCoordinate) * 0.2;\n" +
-                    "fragmentColor += texture2D(inputImageTexture, twoStepsRightTextureCoordinate) * 0.2;\n" +
+                    "lowp vec4 fragmentColor = texture2D(inputImageTexture, centerTextureCoordinate) * 0.2;\n"
+                    +
+                    "fragmentColor += texture2D(inputImageTexture, oneStepLeftTextureCoordinate) * 0.2;\n"
+                    +
+                    "fragmentColor += texture2D(inputImageTexture, oneStepRightTextureCoordinate) * 0.2;\n"
+                    +
+                    "fragmentColor += texture2D(inputImageTexture, twoStepsLeftTextureCoordinate) * 0.2;\n"
+                    +
+                    "fragmentColor += texture2D(inputImageTexture, twoStepsRightTextureCoordinate) * 0.2;\n"
+                    +
                     "\n" +
                     "gl_FragColor = fragmentColor;\n" +
                     "}\n";
@@ -80,7 +86,6 @@ public GPUImageBoxBlurFilter() {
         this(1f);
     }
 
-
     public GPUImageBoxBlurFilter(float blurSize) {
         super(VERTEX_SHADER, FRAGMENT_SHADER, VERTEX_SHADER, FRAGMENT_SHADER);
         this.blurSize = blurSize;
@@ -88,12 +93,11 @@ public GPUImageBoxBlurFilter(float blurSize) {
 
     /**
      * A scaling for the size of the applied blur, default of 1.0
-     *
-     * @param blurSize
      */
     public void setBlurSize(float blurSize) {
         this.blurSize = blurSize;
         runOnDraw(new Runnable() {
+
             @Override
             public void run() {
                 initTexelOffsets();
diff --git a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageBrightnessFilter.java b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageBrightnessFilter.java
index e528ee87..0c5906c6 100644
--- a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageBrightnessFilter.java
+++ b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageBrightnessFilter.java
@@ -22,6 +22,7 @@
  * brightness value ranges from -1.0 to 1.0, with 0.0 as the normal level
  */
 public class GPUImageBrightnessFilter extends GPUImageFilter {
+
     public static final String BRIGHTNESS_FRAGMENT_SHADER = "" +
             "varying highp vec2 textureCoordinate;\n" +
             " \n" +
diff --git a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageBulgeDistortionFilter.java b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageBulgeDistortionFilter.java
index af49bedd..9b0416ed 100644
--- a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageBulgeDistortionFilter.java
+++ b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageBulgeDistortionFilter.java
@@ -20,6 +20,7 @@
 import android.opengl.GLES20;
 
 public class GPUImageBulgeDistortionFilter extends GPUImageFilter {
+
     public static final String BULGE_FRAGMENT_SHADER = "" +
             "varying highp vec2 textureCoordinate;\n" +
             "\n" +
@@ -32,7 +33,8 @@
             "\n" +
             "void main()\n" +
             "{\n" +
-            "highp vec2 textureCoordinateToUse = vec2(textureCoordinate.x, (textureCoordinate.y * aspectRatio + 0.5 - 0.5 * aspectRatio));\n" +
+            "highp vec2 textureCoordinateToUse = vec2(textureCoordinate.x, (textureCoordinate.y * aspectRatio + 0.5 - 0.5 * aspectRatio));\n"
+            +
             "highp float dist = distance(center, textureCoordinateToUse);\n" +
             "textureCoordinateToUse = textureCoordinate;\n" +
             "\n" +
diff --git a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageCGAColorspaceFilter.java b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageCGAColorspaceFilter.java
index 52585956..2f73d08a 100644
--- a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageCGAColorspaceFilter.java
+++ b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageCGAColorspaceFilter.java
@@ -17,6 +17,7 @@
 package jp.co.cyberagent.android.gpuimage;
 
 public class GPUImageCGAColorspaceFilter extends GPUImageFilter {
+
     public static final String CGACOLORSPACE_FRAGMENT_SHADER = "" +
             "varying highp vec2 textureCoordinate;\n" +
             "\n" +
diff --git a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageChromaKeyBlendFilter.java b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageChromaKeyBlendFilter.java
index 7957b05a..12c18094 100644
--- a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageChromaKeyBlendFilter.java
+++ b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageChromaKeyBlendFilter.java
@@ -22,6 +22,7 @@
  * Selectively replaces a color in the first image with the second image
  */
 public class GPUImageChromaKeyBlendFilter extends GPUImageTwoInputFilter {
+
     public static final String CHROMA_KEY_BLEND_FRAGMENT_SHADER = " precision highp float;\n" +
             " \n" +
             " varying highp vec2 textureCoordinate;\n" +
@@ -38,15 +39,18 @@
             "     vec4 textureColor = texture2D(inputImageTexture, textureCoordinate);\n" +
             "     vec4 textureColor2 = texture2D(inputImageTexture2, textureCoordinate2);\n" +
             "     \n" +
-            "     float maskY = 0.2989 * colorToReplace.r + 0.5866 * colorToReplace.g + 0.1145 * colorToReplace.b;\n" +
+            "     float maskY = 0.2989 * colorToReplace.r + 0.5866 * colorToReplace.g + 0.1145 * colorToReplace.b;\n"
+            +
             "     float maskCr = 0.7132 * (colorToReplace.r - maskY);\n" +
             "     float maskCb = 0.5647 * (colorToReplace.b - maskY);\n" +
             "     \n" +
-            "     float Y = 0.2989 * textureColor.r + 0.5866 * textureColor.g + 0.1145 * textureColor.b;\n" +
+            "     float Y = 0.2989 * textureColor.r + 0.5866 * textureColor.g + 0.1145 * textureColor.b;\n"
+            +
             "     float Cr = 0.7132 * (textureColor.r - Y);\n" +
             "     float Cb = 0.5647 * (textureColor.b - Y);\n" +
             "     \n" +
-            "     float blendValue = 1.0 - smoothstep(thresholdSensitivity, thresholdSensitivity + smoothing, distance(vec2(Cr, Cb), vec2(maskCr, maskCb)));\n" +
+            "     float blendValue = 1.0 - smoothstep(thresholdSensitivity, thresholdSensitivity + smoothing, distance(vec2(Cr, Cb), vec2(maskCr, maskCb)));\n"
+            +
             "     gl_FragColor = mix(textureColor, textureColor2, blendValue);\n" +
             " }";
 
@@ -59,13 +63,13 @@
 
     public GPUImageChromaKeyBlendFilter() {
         super(CHROMA_KEY_BLEND_FRAGMENT_SHADER);
-
     }
 
     @Override
     public void onInit() {
         super.onInit();
-        mThresholdSensitivityLocation = GLES20.glGetUniformLocation(getProgram(), "thresholdSensitivity");
+        mThresholdSensitivityLocation = GLES20
+                .glGetUniformLocation(getProgram(), "thresholdSensitivity");
         mSmoothingLocation = GLES20.glGetUniformLocation(getProgram(), "smoothing");
         mColorToReplaceLocation = GLES20.glGetUniformLocation(getProgram(), "colorToReplace");
     }
@@ -96,8 +100,9 @@ public void setThresholdSensitivity(final float thresholdSensitivity) {
         setFloat(mThresholdSensitivityLocation, mThresholdSensitivity);
     }
 
-    /** The color to be replaced is specified using individual red, green, and blue components (normalized to 1.0).
-     * The default is green: (0.0, 1.0, 0.0).
+    /**
+     * The color to be replaced is specified using individual red, green, and blue components
+     * (normalized to 1.0). The default is green: (0.0, 1.0, 0.0).
      *
      * @param redComponent Red component of color to be replaced
      * @param greenComponent Green component of color to be replaced
diff --git a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageColorBalanceFilter.java b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageColorBalanceFilter.java
index 68c078a6..22ae9264 100644
--- a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageColorBalanceFilter.java
+++ b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageColorBalanceFilter.java
@@ -8,133 +8,137 @@
 public class GPUImageColorBalanceFilter extends GPUImageFilter {
 
     public static final String GPU_IMAGE_COLOR_BALANCE_FRAGMENT_SHADER = "" +
-            "varying highp vec2 textureCoordinate;\n"   +
-            "uniform sampler2D inputImageTexture;\n"    +
+            "varying highp vec2 textureCoordinate;\n" +
+            "uniform sampler2D inputImageTexture;\n" +
             "uniform lowp vec3 shadowsShift;\n" +
-            "uniform lowp vec3 midtonesShift;\n"    +
-            "uniform lowp vec3 highlightsShift;\n"  +
+            "uniform lowp vec3 midtonesShift;\n" +
+            "uniform lowp vec3 highlightsShift;\n" +
             "uniform int preserveLuminosity;\n" +
             "lowp vec3 RGBToHSL(lowp vec3 color)\n" +
 
-            "{\n"   +
-            "lowp vec3 hsl; // init to 0 to avoid warnings ? (and reverse if + remove first part)\n"    +
+            "{\n" +
+            "lowp vec3 hsl; // init to 0 to avoid warnings ? (and reverse if + remove first part)\n"
+            +
 
-            "lowp float fmin = min(min(color.r, color.g), color.b);    //Min. value of RGB\n"   +
-            "lowp float fmax = max(max(color.r, color.g), color.b);    //Max. value of RGB\n"   +
-            "lowp float delta = fmax - fmin;             //Delta RGB value\n"   +
+            "lowp float fmin = min(min(color.r, color.g), color.b);    //Min. value of RGB\n" +
+            "lowp float fmax = max(max(color.r, color.g), color.b);    //Max. value of RGB\n" +
+            "lowp float delta = fmax - fmin;             //Delta RGB value\n" +
 
-            "hsl.z = (fmax + fmin) / 2.0; // Luminance\n"   +
+            "hsl.z = (fmax + fmin) / 2.0; // Luminance\n" +
 
-            "if (delta == 0.0)		//This is a gray, no chroma...\n"   +
-            "{\n"   +
-            "    hsl.x = 0.0;	// Hue\n"   +
-            "    hsl.y = 0.0;	// Saturation\n"    +
-            "}\n"   +
+            "if (delta == 0.0)		//This is a gray, no chroma...\n" +
+            "{\n" +
+            "    hsl.x = 0.0;	// Hue\n" +
+            "    hsl.y = 0.0;	// Saturation\n" +
+            "}\n" +
             "else                                    //Chromatic data...\n" +
-            "{\n"   +
-            "    if (hsl.z < 0.5)\n"    +
-            "        hsl.y = delta / (fmax + fmin); // Saturation\n"    +
-            "    else\n"+
-            "        hsl.y = delta / (2.0 - fmax - fmin); // Saturation\n"  +
+            "{\n" +
+            "    if (hsl.z < 0.5)\n" +
+            "        hsl.y = delta / (fmax + fmin); // Saturation\n" +
+            "    else\n" +
+            "        hsl.y = delta / (2.0 - fmax - fmin); // Saturation\n" +
             "\n" +
             "    lowp float deltaR = (((fmax - color.r) / 6.0) + (delta / 2.0)) / delta;\n" +
             "    lowp float deltaG = (((fmax - color.g) / 6.0) + (delta / 2.0)) / delta;\n" +
             "    lowp float deltaB = (((fmax - color.b) / 6.0) + (delta / 2.0)) / delta;\n" +
             "\n" +
-            "    if (color.r == fmax )\n"   +
+            "    if (color.r == fmax )\n" +
             "        hsl.x = deltaB - deltaG; // Hue\n" +
-            "    else if (color.g == fmax)\n"   +
-            "        hsl.x = (1.0 / 3.0) + deltaR - deltaB; // Hue\n"   +
-            "    else if (color.b == fmax)\n"   +
-            "        hsl.x = (2.0 / 3.0) + deltaG - deltaR; // Hue\n"   +
-
-            "    if (hsl.x < 0.0)\n"    +
-            "        hsl.x += 1.0; // Hue\n"    +
-            "    else if (hsl.x > 1.0)\n"   +
-            "        hsl.x -= 1.0; // Hue\n"    +
-            "}\n"   +
+            "    else if (color.g == fmax)\n" +
+            "        hsl.x = (1.0 / 3.0) + deltaR - deltaB; // Hue\n" +
+            "    else if (color.b == fmax)\n" +
+            "        hsl.x = (2.0 / 3.0) + deltaG - deltaR; // Hue\n" +
+
+            "    if (hsl.x < 0.0)\n" +
+            "        hsl.x += 1.0; // Hue\n" +
+            "    else if (hsl.x > 1.0)\n" +
+            "        hsl.x -= 1.0; // Hue\n" +
+            "}\n" +
             "\n" +
             "return hsl;\n" +
-            "}\n"   +
-
-            "lowp float HueToRGB(lowp float f1, lowp float f2, lowp float hue)\n"   +
-            "{\n"+
-            "    if (hue < 0.0)\n"+
-            "        hue += 1.0;\n"+
-            "    else if (hue > 1.0)\n"+
-            "        hue -= 1.0;\n"+
-            "    lowp float res;\n"+
-            "    if ((6.0 * hue) < 1.0)\n"+
-            "        res = f1 + (f2 - f1) * 6.0 * hue;\n"+
-            "    else if ((2.0 * hue) < 1.0)\n"+
-            "        res = f2;\n"+
-            "    else if ((3.0 * hue) < 2.0)\n"+
-            "        res = f1 + (f2 - f1) * ((2.0 / 3.0) - hue) * 6.0;\n"+
-            "    else\n"+
-            "        res = f1;\n"+
-            "    return res;\n"+
-            "}\n"+
-
-            "lowp vec3 HSLToRGB(lowp vec3 hsl)\n"+
-            "{\n"   +
-            "    lowp vec3 rgb;\n"  +
-
-            "    if (hsl.y == 0.0)\n"   +
+            "}\n" +
+
+            "lowp float HueToRGB(lowp float f1, lowp float f2, lowp float hue)\n" +
+            "{\n" +
+            "    if (hue < 0.0)\n" +
+            "        hue += 1.0;\n" +
+            "    else if (hue > 1.0)\n" +
+            "        hue -= 1.0;\n" +
+            "    lowp float res;\n" +
+            "    if ((6.0 * hue) < 1.0)\n" +
+            "        res = f1 + (f2 - f1) * 6.0 * hue;\n" +
+            "    else if ((2.0 * hue) < 1.0)\n" +
+            "        res = f2;\n" +
+            "    else if ((3.0 * hue) < 2.0)\n" +
+            "        res = f1 + (f2 - f1) * ((2.0 / 3.0) - hue) * 6.0;\n" +
+            "    else\n" +
+            "        res = f1;\n" +
+            "    return res;\n" +
+            "}\n" +
+
+            "lowp vec3 HSLToRGB(lowp vec3 hsl)\n" +
+            "{\n" +
+            "    lowp vec3 rgb;\n" +
+
+            "    if (hsl.y == 0.0)\n" +
             "        rgb = vec3(hsl.z); // Luminance\n" +
-            "    else\n"    +
-            "    {\n"   +
-            "        lowp float f2;\n"  +
+            "    else\n" +
+            "    {\n" +
+            "        lowp float f2;\n" +
 
-            "        if (hsl.z < 0.5)\n"    +
+            "        if (hsl.z < 0.5)\n" +
             "            f2 = hsl.z * (1.0 + hsl.y);\n" +
-            "        else\n"    +
+            "        else\n" +
             "            f2 = (hsl.z + hsl.y) - (hsl.y * hsl.z);\n" +
 
-            "        lowp float f1 = 2.0 * hsl.z - f2;\n"   +
+            "        lowp float f1 = 2.0 * hsl.z - f2;\n" +
 
-            "        rgb.r = HueToRGB(f1, f2, hsl.x + (1.0/3.0));\n"    +
-            "        rgb.g = HueToRGB(f1, f2, hsl.x);\n"    +
+            "        rgb.r = HueToRGB(f1, f2, hsl.x + (1.0/3.0));\n" +
+            "        rgb.g = HueToRGB(f1, f2, hsl.x);\n" +
             "        rgb.b= HueToRGB(f1, f2, hsl.x - (1.0/3.0));\n" +
-            "    }\n"   +
+            "    }\n" +
 
-            "    return rgb;\n  "+
+            "    return rgb;\n  " +
             "}\n" +
 
-            "lowp float RGBToL(lowp vec3 color)\n"  +
-            "{\n"   +
-            "    lowp float fmin = min(min(color.r, color.g), color.b);    //Min. value of RGB\n"   +
-            "    lowp float fmax = max(max(color.r, color.g), color.b);    //Max. value of RGB\n"   +
+            "lowp float RGBToL(lowp vec3 color)\n" +
+            "{\n" +
+            "    lowp float fmin = min(min(color.r, color.g), color.b);    //Min. value of RGB\n" +
+            "    lowp float fmax = max(max(color.r, color.g), color.b);    //Max. value of RGB\n" +
 
-            "    return (fmax + fmin) / 2.0; // Luminance\n"    +
-            "}\n"   +
+            "    return (fmax + fmin) / 2.0; // Luminance\n" +
+            "}\n" +
 
-            "void main()\n"+
-            "{\n"+
-            "    lowp vec4 textureColor = texture2D(inputImageTexture, textureCoordinate);\n"   +
+            "void main()\n" +
+            "{\n" +
+            "    lowp vec4 textureColor = texture2D(inputImageTexture, textureCoordinate);\n" +
 
             "    // Alternative way:\n" +
-            "    //lowp vec3 lightness = RGBToL(textureColor.rgb);\n"   +
+            "    //lowp vec3 lightness = RGBToL(textureColor.rgb);\n" +
             "    lowp vec3 lightness = textureColor.rgb;\n" +
 
-            "    const lowp float a = 0.25;\n"  +
+            "    const lowp float a = 0.25;\n" +
             "    const lowp float b = 0.333;\n" +
-            "    const lowp float scale = 0.7;\n"   +
+            "    const lowp float scale = 0.7;\n" +
 
-            "    lowp vec3 shadows = shadowsShift * (clamp((lightness - b) / -a + 0.5, 0.0, 1.0) * scale);\n"   +
-            "    lowp vec3 midtones = midtonesShift * (clamp((lightness - b) / a + 0.5, 0.0, 1.0) *\n"  +
+            "    lowp vec3 shadows = shadowsShift * (clamp((lightness - b) / -a + 0.5, 0.0, 1.0) * scale);\n"
+            +
+            "    lowp vec3 midtones = midtonesShift * (clamp((lightness - b) / a + 0.5, 0.0, 1.0) *\n"
+            +
             "        clamp((lightness + b - 1.0) / -a + 0.5, 0.0, 1.0) * scale);\n" +
-            "    lowp vec3 highlights = highlightsShift * (clamp((lightness + b - 1.0) / a + 0.5, 0.0, 1.0) * scale);\n"    +
-
-            "    mediump vec3 newColor = textureColor.rgb + shadows + midtones + highlights;\n"+
-            "    newColor = clamp(newColor, 0.0, 1.0);\n    "+
-
-            "    if (preserveLuminosity != 0) {\n   "+
-            "        lowp vec3 newHSL = RGBToHSL(newColor);\n"  +
-            "        lowp float oldLum = RGBToL(textureColor.rgb);\n"   +
-            "        textureColor.rgb = HSLToRGB(vec3(newHSL.x, newHSL.y, oldLum));\n"  +
-            "        gl_FragColor = textureColor;\n"    +
-            "    } else {\n"    +
-            "        gl_FragColor = vec4(newColor.rgb, textureColor.w);\n"  +
+            "    lowp vec3 highlights = highlightsShift * (clamp((lightness + b - 1.0) / a + 0.5, 0.0, 1.0) * scale);\n"
+            +
+
+            "    mediump vec3 newColor = textureColor.rgb + shadows + midtones + highlights;\n" +
+            "    newColor = clamp(newColor, 0.0, 1.0);\n    " +
+
+            "    if (preserveLuminosity != 0) {\n   " +
+            "        lowp vec3 newHSL = RGBToHSL(newColor);\n" +
+            "        lowp float oldLum = RGBToL(textureColor.rgb);\n" +
+            "        textureColor.rgb = HSLToRGB(vec3(newHSL.x, newHSL.y, oldLum));\n" +
+            "        gl_FragColor = textureColor;\n" +
+            "    } else {\n" +
+            "        gl_FragColor = vec4(newColor.rgb, textureColor.w);\n" +
             "    }\n" +
             "}\n";
 
@@ -148,7 +152,6 @@
     private float[] highlights;
     private boolean preserveLuminosity;
 
-
     public GPUImageColorBalanceFilter() {
         super(NO_FILTER_VERTEX_SHADER, GPU_IMAGE_COLOR_BALANCE_FRAGMENT_SHADER);
         this.showdows = new float[]{0.0f, 0.0f, 0.0f};
@@ -163,7 +166,8 @@ public void onInit() {
         mShadowsLocation = GLES20.glGetUniformLocation(getProgram(), "shadowsShift");
         mMidtonesLocation = GLES20.glGetUniformLocation(getProgram(), "midtonesShift");
         mHighlightsLocation = GLES20.glGetUniformLocation(getProgram(), "highlightsShift");
-        mPreserveLuminosityLocation = GLES20.glGetUniformLocation(getProgram(), "preserveLuminosity");
+        mPreserveLuminosityLocation = GLES20
+                .glGetUniformLocation(getProgram(), "preserveLuminosity");
     }
 
     @Override
@@ -192,6 +196,6 @@ public void setHighlights(float[] highlights) {
 
     public void setPreserveLuminosity(boolean preserveLuminosity) {
         this.preserveLuminosity = preserveLuminosity;
-        setInteger(mPreserveLuminosityLocation, preserveLuminosity ? 1: 0);
+        setInteger(mPreserveLuminosityLocation, preserveLuminosity ? 1 : 0);
     }
 }
diff --git a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageColorBlendFilter.java b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageColorBlendFilter.java
index 0f5de140..1c86e19d 100644
--- a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageColorBlendFilter.java
+++ b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageColorBlendFilter.java
@@ -17,48 +17,52 @@
 package jp.co.cyberagent.android.gpuimage;
 
 public class GPUImageColorBlendFilter extends GPUImageTwoInputFilter {
-    public static final String COLOR_BLEND_FRAGMENT_SHADER = "varying highp vec2 textureCoordinate;\n" +
-            " varying highp vec2 textureCoordinate2;\n" +
-            " \n" +
-            " uniform sampler2D inputImageTexture;\n" +
-            " uniform sampler2D inputImageTexture2;\n" +
-            " \n" +
-            " highp float lum(lowp vec3 c) {\n" +
-            "     return dot(c, vec3(0.3, 0.59, 0.11));\n" +
-            " }\n" +
-            " \n" +
-            " lowp vec3 clipcolor(lowp vec3 c) {\n" +
-            "     highp float l = lum(c);\n" +
-            "     lowp float n = min(min(c.r, c.g), c.b);\n" +
-            "     lowp float x = max(max(c.r, c.g), c.b);\n" +
-            "     \n" +
-            "     if (n < 0.0) {\n" +
-            "         c.r = l + ((c.r - l) * l) / (l - n);\n" +
-            "         c.g = l + ((c.g - l) * l) / (l - n);\n" +
-            "         c.b = l + ((c.b - l) * l) / (l - n);\n" +
-            "     }\n" +
-            "     if (x > 1.0) {\n" +
-            "         c.r = l + ((c.r - l) * (1.0 - l)) / (x - l);\n" +
-            "         c.g = l + ((c.g - l) * (1.0 - l)) / (x - l);\n" +
-            "         c.b = l + ((c.b - l) * (1.0 - l)) / (x - l);\n" +
-            "     }\n" +
-            "     \n" +
-            "     return c;\n" +
-            " }\n" +
-            "\n" +
-            " lowp vec3 setlum(lowp vec3 c, highp float l) {\n" +
-            "     highp float d = l - lum(c);\n" +
-            "     c = c + vec3(d);\n" +
-            "     return clipcolor(c);\n" +
-            " }\n" +
-            " \n" +
-            " void main()\n" +
-            " {\n" +
-            "   highp vec4 baseColor = texture2D(inputImageTexture, textureCoordinate);\n" +
-            "   highp vec4 overlayColor = texture2D(inputImageTexture2, textureCoordinate2);\n" +
-            "\n" +
-            "     gl_FragColor = vec4(baseColor.rgb * (1.0 - overlayColor.a) + setlum(overlayColor.rgb, lum(baseColor.rgb)) * overlayColor.a, baseColor.a);\n" +
-            " }";
+
+    public static final String COLOR_BLEND_FRAGMENT_SHADER =
+            "varying highp vec2 textureCoordinate;\n" +
+                    " varying highp vec2 textureCoordinate2;\n" +
+                    " \n" +
+                    " uniform sampler2D inputImageTexture;\n" +
+                    " uniform sampler2D inputImageTexture2;\n" +
+                    " \n" +
+                    " highp float lum(lowp vec3 c) {\n" +
+                    "     return dot(c, vec3(0.3, 0.59, 0.11));\n" +
+                    " }\n" +
+                    " \n" +
+                    " lowp vec3 clipcolor(lowp vec3 c) {\n" +
+                    "     highp float l = lum(c);\n" +
+                    "     lowp float n = min(min(c.r, c.g), c.b);\n" +
+                    "     lowp float x = max(max(c.r, c.g), c.b);\n" +
+                    "     \n" +
+                    "     if (n < 0.0) {\n" +
+                    "         c.r = l + ((c.r - l) * l) / (l - n);\n" +
+                    "         c.g = l + ((c.g - l) * l) / (l - n);\n" +
+                    "         c.b = l + ((c.b - l) * l) / (l - n);\n" +
+                    "     }\n" +
+                    "     if (x > 1.0) {\n" +
+                    "         c.r = l + ((c.r - l) * (1.0 - l)) / (x - l);\n" +
+                    "         c.g = l + ((c.g - l) * (1.0 - l)) / (x - l);\n" +
+                    "         c.b = l + ((c.b - l) * (1.0 - l)) / (x - l);\n" +
+                    "     }\n" +
+                    "     \n" +
+                    "     return c;\n" +
+                    " }\n" +
+                    "\n" +
+                    " lowp vec3 setlum(lowp vec3 c, highp float l) {\n" +
+                    "     highp float d = l - lum(c);\n" +
+                    "     c = c + vec3(d);\n" +
+                    "     return clipcolor(c);\n" +
+                    " }\n" +
+                    " \n" +
+                    " void main()\n" +
+                    " {\n" +
+                    "   highp vec4 baseColor = texture2D(inputImageTexture, textureCoordinate);\n" +
+                    "   highp vec4 overlayColor = texture2D(inputImageTexture2, textureCoordinate2);\n"
+                    +
+                    "\n" +
+                    "     gl_FragColor = vec4(baseColor.rgb * (1.0 - overlayColor.a) + setlum(overlayColor.rgb, lum(baseColor.rgb)) * overlayColor.a, baseColor.a);\n"
+                    +
+                    " }";
 
     public GPUImageColorBlendFilter() {
         super(COLOR_BLEND_FRAGMENT_SHADER);
diff --git a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageColorBurnBlendFilter.java b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageColorBurnBlendFilter.java
index e3b5c42a..a2e42f88 100644
--- a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageColorBurnBlendFilter.java
+++ b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageColorBurnBlendFilter.java
@@ -17,19 +17,24 @@
 package jp.co.cyberagent.android.gpuimage;
 
 public class GPUImageColorBurnBlendFilter extends GPUImageTwoInputFilter {
-    public static final String COLOR_BURN_BLEND_FRAGMENT_SHADER = "varying highp vec2 textureCoordinate;\n" +
-            " varying highp vec2 textureCoordinate2;\n" +
-            "\n" +
-            " uniform sampler2D inputImageTexture;\n" +
-            " uniform sampler2D inputImageTexture2;\n" +
-            " \n" +
-            " void main()\n" +
-            " {\n" +
-            "    mediump vec4 textureColor = texture2D(inputImageTexture, textureCoordinate);\n" +
-            "    mediump vec4 textureColor2 = texture2D(inputImageTexture2, textureCoordinate2);\n" +
-            "    mediump vec4 whiteColor = vec4(1.0);\n" +
-            "    gl_FragColor = whiteColor - (whiteColor - textureColor) / textureColor2;\n" +
-            " }";
+
+    public static final String COLOR_BURN_BLEND_FRAGMENT_SHADER =
+            "varying highp vec2 textureCoordinate;\n" +
+                    " varying highp vec2 textureCoordinate2;\n" +
+                    "\n" +
+                    " uniform sampler2D inputImageTexture;\n" +
+                    " uniform sampler2D inputImageTexture2;\n" +
+                    " \n" +
+                    " void main()\n" +
+                    " {\n" +
+                    "    mediump vec4 textureColor = texture2D(inputImageTexture, textureCoordinate);\n"
+                    +
+                    "    mediump vec4 textureColor2 = texture2D(inputImageTexture2, textureCoordinate2);\n"
+                    +
+                    "    mediump vec4 whiteColor = vec4(1.0);\n" +
+                    "    gl_FragColor = whiteColor - (whiteColor - textureColor) / textureColor2;\n"
+                    +
+                    " }";
 
     public GPUImageColorBurnBlendFilter() {
         super(COLOR_BURN_BLEND_FRAGMENT_SHADER);
diff --git a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageColorDodgeBlendFilter.java b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageColorDodgeBlendFilter.java
index 702a3a98..a88f1e89 100644
--- a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageColorDodgeBlendFilter.java
+++ b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageColorDodgeBlendFilter.java
@@ -17,6 +17,7 @@
 package jp.co.cyberagent.android.gpuimage;
 
 public class GPUImageColorDodgeBlendFilter extends GPUImageTwoInputFilter {
+
     public static final String COLOR_DODGE_BLEND_FRAGMENT_SHADER = "precision mediump float;\n" +
             " \n" +
             " varying highp vec2 textureCoordinate;\n" +
@@ -31,16 +32,21 @@
             "     vec4 overlay = texture2D(inputImageTexture2, textureCoordinate2);\n" +
             "     \n" +
             "     vec3 baseOverlayAlphaProduct = vec3(overlay.a * base.a);\n" +
-            "     vec3 rightHandProduct = overlay.rgb * (1.0 - base.a) + base.rgb * (1.0 - overlay.a);\n" +
+            "     vec3 rightHandProduct = overlay.rgb * (1.0 - base.a) + base.rgb * (1.0 - overlay.a);\n"
+            +
             "     \n" +
             "     vec3 firstBlendColor = baseOverlayAlphaProduct + rightHandProduct;\n" +
-            "     vec3 overlayRGB = clamp((overlay.rgb / clamp(overlay.a, 0.01, 1.0)) * step(0.0, overlay.a), 0.0, 0.99);\n" +
+            "     vec3 overlayRGB = clamp((overlay.rgb / clamp(overlay.a, 0.01, 1.0)) * step(0.0, overlay.a), 0.0, 0.99);\n"
+            +
             "     \n" +
-            "     vec3 secondBlendColor = (base.rgb * overlay.a) / (1.0 - overlayRGB) + rightHandProduct;\n" +
+            "     vec3 secondBlendColor = (base.rgb * overlay.a) / (1.0 - overlayRGB) + rightHandProduct;\n"
+            +
             "     \n" +
-            "     vec3 colorChoice = step((overlay.rgb * base.a + base.rgb * overlay.a), baseOverlayAlphaProduct);\n" +
+            "     vec3 colorChoice = step((overlay.rgb * base.a + base.rgb * overlay.a), baseOverlayAlphaProduct);\n"
+            +
             "     \n" +
-            "     gl_FragColor = vec4(mix(firstBlendColor, secondBlendColor, colorChoice), 1.0);\n" +
+            "     gl_FragColor = vec4(mix(firstBlendColor, secondBlendColor, colorChoice), 1.0);\n"
+            +
             " }";
 
     public GPUImageColorDodgeBlendFilter() {
diff --git a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageColorInvertFilter.java b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageColorInvertFilter.java
index 2d8df9b9..52d01fb7 100644
--- a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageColorInvertFilter.java
+++ b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageColorInvertFilter.java
@@ -20,6 +20,7 @@
  * Invert all the colors in the image.
  */
 public class GPUImageColorInvertFilter extends GPUImageFilter {
+
     public static final String COLOR_INVERT_FRAGMENT_SHADER = "" +
             "varying highp vec2 textureCoordinate;\n" +
             "\n" +
diff --git a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageColorMatrixFilter.java b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageColorMatrixFilter.java
index 59203c4d..8fced24e 100644
--- a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageColorMatrixFilter.java
+++ b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageColorMatrixFilter.java
@@ -22,6 +22,7 @@
  * Applies a ColorMatrix to the image.
  */
 public class GPUImageColorMatrixFilter extends GPUImageFilter {
+
     public static final String COLOR_MATRIX_FRAGMENT_SHADER = "" +
             "varying highp vec2 textureCoordinate;\n" +
             "\n" +
@@ -44,7 +45,7 @@
     private int mIntensityLocation;
 
     public GPUImageColorMatrixFilter() {
-        this(1.0f, new float[] {
+        this(1.0f, new float[]{
                 1.0f, 0.0f, 0.0f, 0.0f,
                 0.0f, 1.0f, 0.0f, 0.0f,
                 0.0f, 0.0f, 1.0f, 0.0f,
diff --git a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageContrastFilter.java b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageContrastFilter.java
index 1d2b9107..fb14d511 100644
--- a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageContrastFilter.java
+++ b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageContrastFilter.java
@@ -24,17 +24,19 @@
  * contrast value ranges from 0.0 to 4.0, with 1.0 as the normal level
  */
 public class GPUImageContrastFilter extends GPUImageFilter {
+
     public static final String CONTRAST_FRAGMENT_SHADER = "" +
-            "varying highp vec2 textureCoordinate;\n" + 
-            " \n" + 
-            " uniform sampler2D inputImageTexture;\n" + 
-            " uniform lowp float contrast;\n" + 
-            " \n" + 
-            " void main()\n" + 
-            " {\n" + 
-            "     lowp vec4 textureColor = texture2D(inputImageTexture, textureCoordinate);\n" + 
-            "     \n" + 
-            "     gl_FragColor = vec4(((textureColor.rgb - vec3(0.5)) * contrast + vec3(0.5)), textureColor.w);\n" + 
+            "varying highp vec2 textureCoordinate;\n" +
+            " \n" +
+            " uniform sampler2D inputImageTexture;\n" +
+            " uniform lowp float contrast;\n" +
+            " \n" +
+            " void main()\n" +
+            " {\n" +
+            "     lowp vec4 textureColor = texture2D(inputImageTexture, textureCoordinate);\n" +
+            "     \n" +
+            "     gl_FragColor = vec4(((textureColor.rgb - vec3(0.5)) * contrast + vec3(0.5)), textureColor.w);\n"
+            +
             " }";
 
     private int mContrastLocation;
@@ -43,7 +45,7 @@
     public GPUImageContrastFilter() {
         this(1.2f);
     }
-    
+
     public GPUImageContrastFilter(float contrast) {
         super(NO_FILTER_VERTEX_SHADER, CONTRAST_FRAGMENT_SHADER);
         mContrast = contrast;
diff --git a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageCrosshatchFilter.java b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageCrosshatchFilter.java
index 04a3d4c7..48c3f829 100644
--- a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageCrosshatchFilter.java
+++ b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageCrosshatchFilter.java
@@ -19,10 +19,11 @@
 import android.opengl.GLES20;
 
 /**
- * crossHatchSpacing: The fractional width of the image to use as the spacing for the crosshatch. The default is 0.03.
- * lineWidth: A relative width for the crosshatch lines. The default is 0.003.
+ * crossHatchSpacing: The fractional width of the image to use as the spacing for the crosshatch.
+ * The default is 0.03. lineWidth: A relative width for the crosshatch lines. The default is 0.003.
  */
 public class GPUImageCrosshatchFilter extends GPUImageFilter {
+
     public static final String CROSSHATCH_FRAGMENT_SHADER = "" +
             "varying highp vec2 textureCoordinate;\n" +
             "uniform sampler2D inputImageTexture;\n" +
@@ -31,32 +32,37 @@
             "const highp vec3 W = vec3(0.2125, 0.7154, 0.0721);\n" +
             "void main()\n" +
             "{\n" +
-            "highp float luminance = dot(texture2D(inputImageTexture, textureCoordinate).rgb, W);\n" +
+            "highp float luminance = dot(texture2D(inputImageTexture, textureCoordinate).rgb, W);\n"
+            +
             "lowp vec4 colorToDisplay = vec4(1.0, 1.0, 1.0, 1.0);\n" +
             "if (luminance < 1.00)\n" +
             "{\n" +
-            "if (mod(textureCoordinate.x + textureCoordinate.y, crossHatchSpacing) <= lineWidth)\n" +
+            "if (mod(textureCoordinate.x + textureCoordinate.y, crossHatchSpacing) <= lineWidth)\n"
+            +
             "{\n" +
             "colorToDisplay = vec4(0.0, 0.0, 0.0, 1.0);\n" +
             "}\n" +
             "}\n" +
             "if (luminance < 0.75)\n" +
             "{\n" +
-            "if (mod(textureCoordinate.x - textureCoordinate.y, crossHatchSpacing) <= lineWidth)\n" +
+            "if (mod(textureCoordinate.x - textureCoordinate.y, crossHatchSpacing) <= lineWidth)\n"
+            +
             "{\n" +
             "colorToDisplay = vec4(0.0, 0.0, 0.0, 1.0);\n" +
             "}\n" +
             "}\n" +
             "if (luminance < 0.50)\n" +
             "{\n" +
-            "if (mod(textureCoordinate.x + textureCoordinate.y - (crossHatchSpacing / 2.0), crossHatchSpacing) <= lineWidth)\n" +
+            "if (mod(textureCoordinate.x + textureCoordinate.y - (crossHatchSpacing / 2.0), crossHatchSpacing) <= lineWidth)\n"
+            +
             "{\n" +
             "colorToDisplay = vec4(0.0, 0.0, 0.0, 1.0);\n" +
             "}\n" +
             "}\n" +
             "if (luminance < 0.3)\n" +
             "{\n" +
-            "if (mod(textureCoordinate.x - textureCoordinate.y - (crossHatchSpacing / 2.0), crossHatchSpacing) <= lineWidth)\n" +
+            "if (mod(textureCoordinate.x - textureCoordinate.y - (crossHatchSpacing / 2.0), crossHatchSpacing) <= lineWidth)\n"
+            +
             "{\n" +
             "colorToDisplay = vec4(0.0, 0.0, 0.0, 1.0);\n" +
             "}\n" +
@@ -97,7 +103,8 @@ public void onInitialized() {
     }
 
     /**
-     * The fractional width of the image to use as the spacing for the crosshatch. The default is 0.03.
+     * The fractional width of the image to use as the spacing for the crosshatch. The default is
+     * 0.03.
      *
      * @param crossHatchSpacing default 0.03
      */
diff --git a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageDarkenBlendFilter.java b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageDarkenBlendFilter.java
index 385e8e3a..876017f6 100644
--- a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageDarkenBlendFilter.java
+++ b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageDarkenBlendFilter.java
@@ -17,19 +17,23 @@
 package jp.co.cyberagent.android.gpuimage;
 
 public class GPUImageDarkenBlendFilter extends GPUImageTwoInputFilter {
-    public static final String DARKEN_BLEND_FRAGMENT_SHADER = "varying highp vec2 textureCoordinate;\n" +
-            " varying highp vec2 textureCoordinate2;\n" +
-            "\n" +
-            " uniform sampler2D inputImageTexture;\n" +
-            " uniform sampler2D inputImageTexture2;\n" +
-            " \n" +
-            " void main()\n" +
-            " {\n" +
-            "    lowp vec4 base = texture2D(inputImageTexture, textureCoordinate);\n" +
-            "    lowp vec4 overlayer = texture2D(inputImageTexture2, textureCoordinate2);\n" +
-            "    \n" +
-            "    gl_FragColor = vec4(min(overlayer.rgb * base.a, base.rgb * overlayer.a) + overlayer.rgb * (1.0 - base.a) + base.rgb * (1.0 - overlayer.a), 1.0);\n" +
-            " }";
+
+    public static final String DARKEN_BLEND_FRAGMENT_SHADER =
+            "varying highp vec2 textureCoordinate;\n" +
+                    " varying highp vec2 textureCoordinate2;\n" +
+                    "\n" +
+                    " uniform sampler2D inputImageTexture;\n" +
+                    " uniform sampler2D inputImageTexture2;\n" +
+                    " \n" +
+                    " void main()\n" +
+                    " {\n" +
+                    "    lowp vec4 base = texture2D(inputImageTexture, textureCoordinate);\n" +
+                    "    lowp vec4 overlayer = texture2D(inputImageTexture2, textureCoordinate2);\n"
+                    +
+                    "    \n" +
+                    "    gl_FragColor = vec4(min(overlayer.rgb * base.a, base.rgb * overlayer.a) + overlayer.rgb * (1.0 - base.a) + base.rgb * (1.0 - overlayer.a), 1.0);\n"
+                    +
+                    " }";
 
     public GPUImageDarkenBlendFilter() {
         super(DARKEN_BLEND_FRAGMENT_SHADER);
diff --git a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageDifferenceBlendFilter.java b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageDifferenceBlendFilter.java
index 1a32cd0c..7f631fd9 100644
--- a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageDifferenceBlendFilter.java
+++ b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageDifferenceBlendFilter.java
@@ -17,18 +17,23 @@
 package jp.co.cyberagent.android.gpuimage;
 
 public class GPUImageDifferenceBlendFilter extends GPUImageTwoInputFilter {
-    public static final String DIFFERENCE_BLEND_FRAGMENT_SHADER = "varying highp vec2 textureCoordinate;\n" +
-            " varying highp vec2 textureCoordinate2;\n" +
-            "\n" +
-            " uniform sampler2D inputImageTexture;\n" +
-            " uniform sampler2D inputImageTexture2;\n" +
-            " \n" +
-            " void main()\n" +
-            " {\n" +
-            "     mediump vec4 textureColor = texture2D(inputImageTexture, textureCoordinate);\n" +
-            "     mediump vec4 textureColor2 = texture2D(inputImageTexture2, textureCoordinate2);\n" +
-            "     gl_FragColor = vec4(abs(textureColor2.rgb - textureColor.rgb), textureColor.a);\n" +
-            " }";
+
+    public static final String DIFFERENCE_BLEND_FRAGMENT_SHADER =
+            "varying highp vec2 textureCoordinate;\n" +
+                    " varying highp vec2 textureCoordinate2;\n" +
+                    "\n" +
+                    " uniform sampler2D inputImageTexture;\n" +
+                    " uniform sampler2D inputImageTexture2;\n" +
+                    " \n" +
+                    " void main()\n" +
+                    " {\n" +
+                    "     mediump vec4 textureColor = texture2D(inputImageTexture, textureCoordinate);\n"
+                    +
+                    "     mediump vec4 textureColor2 = texture2D(inputImageTexture2, textureCoordinate2);\n"
+                    +
+                    "     gl_FragColor = vec4(abs(textureColor2.rgb - textureColor.rgb), textureColor.a);\n"
+                    +
+                    " }";
 
     public GPUImageDifferenceBlendFilter() {
         super(DIFFERENCE_BLEND_FRAGMENT_SHADER);
diff --git a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageDilationFilter.java b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageDilationFilter.java
index f6ce4e2f..b571e3ad 100644
--- a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageDilationFilter.java
+++ b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageDilationFilter.java
@@ -17,11 +17,12 @@
 package jp.co.cyberagent.android.gpuimage;
 
 /**
- * For each pixel, this sets it to the maximum value of the red channel in a rectangular neighborhood extending
- * out dilationRadius pixels from the center.
- * This extends out bright features, and is most commonly used with black-and-white thresholded images.
+ * For each pixel, this sets it to the maximum value of the red channel in a rectangular
+ * neighborhood extending out dilationRadius pixels from the center. This extends out bright
+ * features, and is most commonly used with black-and-white thresholded images.
  */
 public class GPUImageDilationFilter extends GPUImageTwoPassTextureSamplingFilter {
+
     public static final String VERTEX_SHADER_1 =
             "attribute vec4 position;\n" +
                     "attribute vec2 inputTextureCoordinate;\n" +
@@ -66,8 +67,10 @@
                     "centerTextureCoordinate = inputTextureCoordinate;\n" +
                     "oneStepNegativeTextureCoordinate = inputTextureCoordinate - offset;\n" +
                     "oneStepPositiveTextureCoordinate = inputTextureCoordinate + offset;\n" +
-                    "twoStepsNegativeTextureCoordinate = inputTextureCoordinate - (offset * 2.0);\n" +
-                    "twoStepsPositiveTextureCoordinate = inputTextureCoordinate + (offset * 2.0);\n" +
+                    "twoStepsNegativeTextureCoordinate = inputTextureCoordinate - (offset * 2.0);\n"
+                    +
+                    "twoStepsPositiveTextureCoordinate = inputTextureCoordinate + (offset * 2.0);\n"
+                    +
                     "}\n";
 
     public static final String VERTEX_SHADER_3 =
@@ -94,10 +97,14 @@
                     "centerTextureCoordinate = inputTextureCoordinate;\n" +
                     "oneStepNegativeTextureCoordinate = inputTextureCoordinate - offset;\n" +
                     "oneStepPositiveTextureCoordinate = inputTextureCoordinate + offset;\n" +
-                    "twoStepsNegativeTextureCoordinate = inputTextureCoordinate - (offset * 2.0);\n" +
-                    "twoStepsPositiveTextureCoordinate = inputTextureCoordinate + (offset * 2.0);\n" +
-                    "threeStepsNegativeTextureCoordinate = inputTextureCoordinate - (offset * 3.0);\n" +
-                    "threeStepsPositiveTextureCoordinate = inputTextureCoordinate + (offset * 3.0);\n" +
+                    "twoStepsNegativeTextureCoordinate = inputTextureCoordinate - (offset * 2.0);\n"
+                    +
+                    "twoStepsPositiveTextureCoordinate = inputTextureCoordinate + (offset * 2.0);\n"
+                    +
+                    "threeStepsNegativeTextureCoordinate = inputTextureCoordinate - (offset * 3.0);\n"
+                    +
+                    "threeStepsPositiveTextureCoordinate = inputTextureCoordinate + (offset * 3.0);\n"
+                    +
                     "}\n";
 
     public static final String VERTEX_SHADER_4 =
@@ -127,15 +134,20 @@
                     "centerTextureCoordinate = inputTextureCoordinate;\n" +
                     "oneStepNegativeTextureCoordinate = inputTextureCoordinate - offset;\n" +
                     "oneStepPositiveTextureCoordinate = inputTextureCoordinate + offset;\n" +
-                    "twoStepsNegativeTextureCoordinate = inputTextureCoordinate - (offset * 2.0);\n" +
-                    "twoStepsPositiveTextureCoordinate = inputTextureCoordinate + (offset * 2.0);\n" +
-                    "threeStepsNegativeTextureCoordinate = inputTextureCoordinate - (offset * 3.0);\n" +
-                    "threeStepsPositiveTextureCoordinate = inputTextureCoordinate + (offset * 3.0);\n" +
-                    "fourStepsNegativeTextureCoordinate = inputTextureCoordinate - (offset * 4.0);\n" +
-                    "fourStepsPositiveTextureCoordinate = inputTextureCoordinate + (offset * 4.0);\n" +
+                    "twoStepsNegativeTextureCoordinate = inputTextureCoordinate - (offset * 2.0);\n"
+                    +
+                    "twoStepsPositiveTextureCoordinate = inputTextureCoordinate + (offset * 2.0);\n"
+                    +
+                    "threeStepsNegativeTextureCoordinate = inputTextureCoordinate - (offset * 3.0);\n"
+                    +
+                    "threeStepsPositiveTextureCoordinate = inputTextureCoordinate + (offset * 3.0);\n"
+                    +
+                    "fourStepsNegativeTextureCoordinate = inputTextureCoordinate - (offset * 4.0);\n"
+                    +
+                    "fourStepsPositiveTextureCoordinate = inputTextureCoordinate + (offset * 4.0);\n"
+                    +
                     "}\n";
 
-
     public static final String FRAGMENT_SHADER_1 =
             "precision lowp float;\n" +
                     "\n" +
@@ -147,9 +159,12 @@
                     "\n" +
                     "void main()\n" +
                     "{\n" +
-                    "float centerIntensity = texture2D(inputImageTexture, centerTextureCoordinate).r;\n" +
-                    "float oneStepPositiveIntensity = texture2D(inputImageTexture, oneStepPositiveTextureCoordinate).r;\n" +
-                    "float oneStepNegativeIntensity = texture2D(inputImageTexture, oneStepNegativeTextureCoordinate).r;\n" +
+                    "float centerIntensity = texture2D(inputImageTexture, centerTextureCoordinate).r;\n"
+                    +
+                    "float oneStepPositiveIntensity = texture2D(inputImageTexture, oneStepPositiveTextureCoordinate).r;\n"
+                    +
+                    "float oneStepNegativeIntensity = texture2D(inputImageTexture, oneStepNegativeTextureCoordinate).r;\n"
+                    +
                     "\n" +
                     "lowp float maxValue = max(centerIntensity, oneStepPositiveIntensity);\n" +
                     "maxValue = max(maxValue, oneStepNegativeIntensity);\n" +
@@ -170,11 +185,16 @@
                     "\n" +
                     "void main()\n" +
                     "{\n" +
-                    "float centerIntensity = texture2D(inputImageTexture, centerTextureCoordinate).r;\n" +
-                    "float oneStepPositiveIntensity = texture2D(inputImageTexture, oneStepPositiveTextureCoordinate).r;\n" +
-                    "float oneStepNegativeIntensity = texture2D(inputImageTexture, oneStepNegativeTextureCoordinate).r;\n" +
-                    "float twoStepsPositiveIntensity = texture2D(inputImageTexture, twoStepsPositiveTextureCoordinate).r;\n" +
-                    "float twoStepsNegativeIntensity = texture2D(inputImageTexture, twoStepsNegativeTextureCoordinate).r;\n" +
+                    "float centerIntensity = texture2D(inputImageTexture, centerTextureCoordinate).r;\n"
+                    +
+                    "float oneStepPositiveIntensity = texture2D(inputImageTexture, oneStepPositiveTextureCoordinate).r;\n"
+                    +
+                    "float oneStepNegativeIntensity = texture2D(inputImageTexture, oneStepNegativeTextureCoordinate).r;\n"
+                    +
+                    "float twoStepsPositiveIntensity = texture2D(inputImageTexture, twoStepsPositiveTextureCoordinate).r;\n"
+                    +
+                    "float twoStepsNegativeIntensity = texture2D(inputImageTexture, twoStepsNegativeTextureCoordinate).r;\n"
+                    +
                     "\n" +
                     "lowp float maxValue = max(centerIntensity, oneStepPositiveIntensity);\n" +
                     "maxValue = max(maxValue, oneStepNegativeIntensity);\n" +
@@ -199,13 +219,20 @@
                     "\n" +
                     "void main()\n" +
                     "{\n" +
-                    "float centerIntensity = texture2D(inputImageTexture, centerTextureCoordinate).r;\n" +
-                    "float oneStepPositiveIntensity = texture2D(inputImageTexture, oneStepPositiveTextureCoordinate).r;\n" +
-                    "float oneStepNegativeIntensity = texture2D(inputImageTexture, oneStepNegativeTextureCoordinate).r;\n" +
-                    "float twoStepsPositiveIntensity = texture2D(inputImageTexture, twoStepsPositiveTextureCoordinate).r;\n" +
-                    "float twoStepsNegativeIntensity = texture2D(inputImageTexture, twoStepsNegativeTextureCoordinate).r;\n" +
-                    "float threeStepsPositiveIntensity = texture2D(inputImageTexture, threeStepsPositiveTextureCoordinate).r;\n" +
-                    "float threeStepsNegativeIntensity = texture2D(inputImageTexture, threeStepsNegativeTextureCoordinate).r;\n" +
+                    "float centerIntensity = texture2D(inputImageTexture, centerTextureCoordinate).r;\n"
+                    +
+                    "float oneStepPositiveIntensity = texture2D(inputImageTexture, oneStepPositiveTextureCoordinate).r;\n"
+                    +
+                    "float oneStepNegativeIntensity = texture2D(inputImageTexture, oneStepNegativeTextureCoordinate).r;\n"
+                    +
+                    "float twoStepsPositiveIntensity = texture2D(inputImageTexture, twoStepsPositiveTextureCoordinate).r;\n"
+                    +
+                    "float twoStepsNegativeIntensity = texture2D(inputImageTexture, twoStepsNegativeTextureCoordinate).r;\n"
+                    +
+                    "float threeStepsPositiveIntensity = texture2D(inputImageTexture, threeStepsPositiveTextureCoordinate).r;\n"
+                    +
+                    "float threeStepsNegativeIntensity = texture2D(inputImageTexture, threeStepsNegativeTextureCoordinate).r;\n"
+                    +
                     "\n" +
                     "lowp float maxValue = max(centerIntensity, oneStepPositiveIntensity);\n" +
                     "maxValue = max(maxValue, oneStepNegativeIntensity);\n" +
@@ -234,15 +261,24 @@
                     "\n" +
                     "void main()\n" +
                     "{\n" +
-                    "float centerIntensity = texture2D(inputImageTexture, centerTextureCoordinate).r;\n" +
-                    "float oneStepPositiveIntensity = texture2D(inputImageTexture, oneStepPositiveTextureCoordinate).r;\n" +
-                    "float oneStepNegativeIntensity = texture2D(inputImageTexture, oneStepNegativeTextureCoordinate).r;\n" +
-                    "float twoStepsPositiveIntensity = texture2D(inputImageTexture, twoStepsPositiveTextureCoordinate).r;\n" +
-                    "float twoStepsNegativeIntensity = texture2D(inputImageTexture, twoStepsNegativeTextureCoordinate).r;\n" +
-                    "float threeStepsPositiveIntensity = texture2D(inputImageTexture, threeStepsPositiveTextureCoordinate).r;\n" +
-                    "float threeStepsNegativeIntensity = texture2D(inputImageTexture, threeStepsNegativeTextureCoordinate).r;\n" +
-                    "float fourStepsPositiveIntensity = texture2D(inputImageTexture, fourStepsPositiveTextureCoordinate).r;\n" +
-                    "float fourStepsNegativeIntensity = texture2D(inputImageTexture, fourStepsNegativeTextureCoordinate).r;\n" +
+                    "float centerIntensity = texture2D(inputImageTexture, centerTextureCoordinate).r;\n"
+                    +
+                    "float oneStepPositiveIntensity = texture2D(inputImageTexture, oneStepPositiveTextureCoordinate).r;\n"
+                    +
+                    "float oneStepNegativeIntensity = texture2D(inputImageTexture, oneStepNegativeTextureCoordinate).r;\n"
+                    +
+                    "float twoStepsPositiveIntensity = texture2D(inputImageTexture, twoStepsPositiveTextureCoordinate).r;\n"
+                    +
+                    "float twoStepsNegativeIntensity = texture2D(inputImageTexture, twoStepsNegativeTextureCoordinate).r;\n"
+                    +
+                    "float threeStepsPositiveIntensity = texture2D(inputImageTexture, threeStepsPositiveTextureCoordinate).r;\n"
+                    +
+                    "float threeStepsNegativeIntensity = texture2D(inputImageTexture, threeStepsNegativeTextureCoordinate).r;\n"
+                    +
+                    "float fourStepsPositiveIntensity = texture2D(inputImageTexture, fourStepsPositiveTextureCoordinate).r;\n"
+                    +
+                    "float fourStepsNegativeIntensity = texture2D(inputImageTexture, fourStepsNegativeTextureCoordinate).r;\n"
+                    +
                     "\n" +
                     "lowp float maxValue = max(centerIntensity, oneStepPositiveIntensity);\n" +
                     "maxValue = max(maxValue, oneStepNegativeIntensity);\n" +
@@ -256,14 +292,13 @@
                     "gl_FragColor = vec4(vec3(maxValue), 1.0);\n" +
                     "}\n";
 
-
     public GPUImageDilationFilter() {
         this(1);
     }
 
     /**
-     * Acceptable values for dilationRadius, which sets the distance in pixels to sample out from the center,
-     * are 1, 2, 3, and 4.
+     * Acceptable values for dilationRadius, which sets the distance in pixels to sample out from
+     * the center, are 1, 2, 3, and 4.
      *
      * @param radius 1, 2, 3 or 4
      */
diff --git a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageDirectionalSobelEdgeDetectionFilter.java b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageDirectionalSobelEdgeDetectionFilter.java
index a5884a12..0533b8bd 100644
--- a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageDirectionalSobelEdgeDetectionFilter.java
+++ b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageDirectionalSobelEdgeDetectionFilter.java
@@ -16,46 +16,56 @@
 
 package jp.co.cyberagent.android.gpuimage;
 
-
 public class GPUImageDirectionalSobelEdgeDetectionFilter extends GPUImage3x3TextureSamplingFilter {
+
     public static final String DIRECTIONAL_SOBEL_EDGE_DETECTION_FRAGMENT_SHADER = "" +
-            "precision mediump float;\n" + 
+            "precision mediump float;\n" +
+            "\n" +
+            "varying vec2 textureCoordinate;\n" +
+            "varying vec2 leftTextureCoordinate;\n" +
+            "varying vec2 rightTextureCoordinate;\n" +
+            "\n" +
+            "varying vec2 topTextureCoordinate;\n" +
+            "varying vec2 topLeftTextureCoordinate;\n" +
+            "varying vec2 topRightTextureCoordinate;\n" +
+            "\n" +
+            "varying vec2 bottomTextureCoordinate;\n" +
+            "varying vec2 bottomLeftTextureCoordinate;\n" +
+            "varying vec2 bottomRightTextureCoordinate;\n" +
+            "\n" +
+            "uniform sampler2D inputImageTexture;\n" +
+            "\n" +
+            "void main()\n" +
+            "{\n" +
+            "    float bottomLeftIntensity = texture2D(inputImageTexture, bottomLeftTextureCoordinate).r;\n"
+            +
+            "    float topRightIntensity = texture2D(inputImageTexture, topRightTextureCoordinate).r;\n"
+            +
+            "    float topLeftIntensity = texture2D(inputImageTexture, topLeftTextureCoordinate).r;\n"
+            +
+            "    float bottomRightIntensity = texture2D(inputImageTexture, bottomRightTextureCoordinate).r;\n"
+            +
+            "    float leftIntensity = texture2D(inputImageTexture, leftTextureCoordinate).r;\n" +
+            "    float rightIntensity = texture2D(inputImageTexture, rightTextureCoordinate).r;\n" +
+            "    float bottomIntensity = texture2D(inputImageTexture, bottomTextureCoordinate).r;\n"
+            +
+            "    float topIntensity = texture2D(inputImageTexture, topTextureCoordinate).r;\n" +
+            "\n" +
+            "    vec2 gradientDirection;\n" +
+            "    gradientDirection.x = -bottomLeftIntensity - 2.0 * leftIntensity - topLeftIntensity + bottomRightIntensity + 2.0 * rightIntensity + topRightIntensity;\n"
+            +
+            "    gradientDirection.y = -topLeftIntensity - 2.0 * topIntensity - topRightIntensity + bottomLeftIntensity + 2.0 * bottomIntensity + bottomRightIntensity;\n"
+            +
             "\n" +
-            "varying vec2 textureCoordinate;\n" + 
-            "varying vec2 leftTextureCoordinate;\n" + 
-            "varying vec2 rightTextureCoordinate;\n" + 
+            "    float gradientMagnitude = length(gradientDirection);\n" +
+            "    vec2 normalizedDirection = normalize(gradientDirection);\n" +
+            "    normalizedDirection = sign(normalizedDirection) * floor(abs(normalizedDirection) + 0.617316); // Offset by 1-sin(pi/8) to set to 0 if near axis, 1 if away\n"
+            +
+            "    normalizedDirection = (normalizedDirection + 1.0) * 0.5; // Place -1.0 - 1.0 within 0 - 1.0\n"
+            +
             "\n" +
-            "varying vec2 topTextureCoordinate;\n" + 
-            "varying vec2 topLeftTextureCoordinate;\n" + 
-            "varying vec2 topRightTextureCoordinate;\n" + 
-            "\n" + 
-            "varying vec2 bottomTextureCoordinate;\n" + 
-            "varying vec2 bottomLeftTextureCoordinate;\n" + 
-            "varying vec2 bottomRightTextureCoordinate;\n" + 
-            "\n" + 
-            "uniform sampler2D inputImageTexture;\n" + 
-            "\n" + 
-            "void main()\n" + 
-            "{\n" + 
-            "    float bottomLeftIntensity = texture2D(inputImageTexture, bottomLeftTextureCoordinate).r;\n" + 
-            "    float topRightIntensity = texture2D(inputImageTexture, topRightTextureCoordinate).r;\n" + 
-            "    float topLeftIntensity = texture2D(inputImageTexture, topLeftTextureCoordinate).r;\n" + 
-            "    float bottomRightIntensity = texture2D(inputImageTexture, bottomRightTextureCoordinate).r;\n" + 
-            "    float leftIntensity = texture2D(inputImageTexture, leftTextureCoordinate).r;\n" + 
-            "    float rightIntensity = texture2D(inputImageTexture, rightTextureCoordinate).r;\n" + 
-            "    float bottomIntensity = texture2D(inputImageTexture, bottomTextureCoordinate).r;\n" + 
-            "    float topIntensity = texture2D(inputImageTexture, topTextureCoordinate).r;\n" + 
-            "\n" + 
-            "    vec2 gradientDirection;\n" + 
-            "    gradientDirection.x = -bottomLeftIntensity - 2.0 * leftIntensity - topLeftIntensity + bottomRightIntensity + 2.0 * rightIntensity + topRightIntensity;\n" + 
-            "    gradientDirection.y = -topLeftIntensity - 2.0 * topIntensity - topRightIntensity + bottomLeftIntensity + 2.0 * bottomIntensity + bottomRightIntensity;\n" + 
-            "\n" + 
-            "    float gradientMagnitude = length(gradientDirection);\n" + 
-            "    vec2 normalizedDirection = normalize(gradientDirection);\n" + 
-            "    normalizedDirection = sign(normalizedDirection) * floor(abs(normalizedDirection) + 0.617316); // Offset by 1-sin(pi/8) to set to 0 if near axis, 1 if away\n" + 
-            "    normalizedDirection = (normalizedDirection + 1.0) * 0.5; // Place -1.0 - 1.0 within 0 - 1.0\n" + 
-            "\n" + 
-            "    gl_FragColor = vec4(gradientMagnitude, normalizedDirection.x, normalizedDirection.y, 1.0);\n" + 
+            "    gl_FragColor = vec4(gradientMagnitude, normalizedDirection.x, normalizedDirection.y, 1.0);\n"
+            +
             "}";
 
     public GPUImageDirectionalSobelEdgeDetectionFilter() {
diff --git a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageDissolveBlendFilter.java b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageDissolveBlendFilter.java
index cd2880a6..48eb80fe 100644
--- a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageDissolveBlendFilter.java
+++ b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageDissolveBlendFilter.java
@@ -19,23 +19,28 @@
 import android.opengl.GLES20;
 
 /**
- * Mix ranges from 0.0 (only image 1) to 1.0 (only image 2), with 0.5 (half of either) as the normal level
+ * Mix ranges from 0.0 (only image 1) to 1.0 (only image 2), with 0.5 (half of either) as the normal
+ * level
  */
-public class GPUImageDissolveBlendFilter extends GPUImageMixBlendFilter{
-    public static final String DISSOLVE_BLEND_FRAGMENT_SHADER = "varying highp vec2 textureCoordinate;\n" +
-            " varying highp vec2 textureCoordinate2;\n" +
-            "\n" +
-            " uniform sampler2D inputImageTexture;\n" +
-            " uniform sampler2D inputImageTexture2;\n" +
-            " uniform lowp float mixturePercent;\n" +
-            " \n" +
-            " void main()\n" +
-            " {\n" +
-            "    lowp vec4 textureColor = texture2D(inputImageTexture, textureCoordinate);\n" +
-            "    lowp vec4 textureColor2 = texture2D(inputImageTexture2, textureCoordinate2);\n" +
-            "    \n" +
-            "    gl_FragColor = mix(textureColor, textureColor2, mixturePercent);\n" +
-            " }";
+public class GPUImageDissolveBlendFilter extends GPUImageMixBlendFilter {
+
+    public static final String DISSOLVE_BLEND_FRAGMENT_SHADER =
+            "varying highp vec2 textureCoordinate;\n" +
+                    " varying highp vec2 textureCoordinate2;\n" +
+                    "\n" +
+                    " uniform sampler2D inputImageTexture;\n" +
+                    " uniform sampler2D inputImageTexture2;\n" +
+                    " uniform lowp float mixturePercent;\n" +
+                    " \n" +
+                    " void main()\n" +
+                    " {\n" +
+                    "    lowp vec4 textureColor = texture2D(inputImageTexture, textureCoordinate);\n"
+                    +
+                    "    lowp vec4 textureColor2 = texture2D(inputImageTexture2, textureCoordinate2);\n"
+                    +
+                    "    \n" +
+                    "    gl_FragColor = mix(textureColor, textureColor2, mixturePercent);\n" +
+                    " }";
 
     public GPUImageDissolveBlendFilter() {
         super(DISSOLVE_BLEND_FRAGMENT_SHADER);
diff --git a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageDivideBlendFilter.java b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageDivideBlendFilter.java
index 179cd4ee..f88fa2af 100644
--- a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageDivideBlendFilter.java
+++ b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageDivideBlendFilter.java
@@ -17,41 +17,50 @@
 package jp.co.cyberagent.android.gpuimage;
 
 public class GPUImageDivideBlendFilter extends GPUImageTwoInputFilter {
-    public static final String DIVIDE_BLEND_FRAGMENT_SHADER = "varying highp vec2 textureCoordinate;\n" +
-            " varying highp vec2 textureCoordinate2;\n" +
-            "\n" +
-            " uniform sampler2D inputImageTexture;\n" +
-            " uniform sampler2D inputImageTexture2;\n" +
-            " \n" +
-            " void main()\n" +
-            " {\n" +
-            "   mediump vec4 base = texture2D(inputImageTexture, textureCoordinate);\n" +
-            "   mediump vec4 overlay = texture2D(inputImageTexture2, textureCoordinate2);\n" +
-            "   \n" +
-            "   mediump float ra;\n" +
-            "   if (overlay.a == 0.0 || ((base.r / overlay.r) > (base.a / overlay.a)))\n" +
-            "     ra = overlay.a * base.a + overlay.r * (1.0 - base.a) + base.r * (1.0 - overlay.a);\n" +
-            "   else\n" +
-            "     ra = (base.r * overlay.a * overlay.a) / overlay.r + overlay.r * (1.0 - base.a) + base.r * (1.0 - overlay.a);\n" +
-            "   \n" +
-            "\n" +
-            "   mediump float ga;\n" +
-            "   if (overlay.a == 0.0 || ((base.g / overlay.g) > (base.a / overlay.a)))\n" +
-            "     ga = overlay.a * base.a + overlay.g * (1.0 - base.a) + base.g * (1.0 - overlay.a);\n" +
-            "   else\n" +
-            "     ga = (base.g * overlay.a * overlay.a) / overlay.g + overlay.g * (1.0 - base.a) + base.g * (1.0 - overlay.a);\n" +
-            "\n" +
-            "   \n" +
-            "   mediump float ba;\n" +
-            "   if (overlay.a == 0.0 || ((base.b / overlay.b) > (base.a / overlay.a)))\n" +
-            "     ba = overlay.a * base.a + overlay.b * (1.0 - base.a) + base.b * (1.0 - overlay.a);\n" +
-            "   else\n" +
-            "     ba = (base.b * overlay.a * overlay.a) / overlay.b + overlay.b * (1.0 - base.a) + base.b * (1.0 - overlay.a);\n" +
-            "\n" +
-            "   mediump float a = overlay.a + base.a - overlay.a * base.a;\n" +
-            "   \n" +
-            "   gl_FragColor = vec4(ra, ga, ba, a);\n" +
-            " }";
+
+    public static final String DIVIDE_BLEND_FRAGMENT_SHADER =
+            "varying highp vec2 textureCoordinate;\n" +
+                    " varying highp vec2 textureCoordinate2;\n" +
+                    "\n" +
+                    " uniform sampler2D inputImageTexture;\n" +
+                    " uniform sampler2D inputImageTexture2;\n" +
+                    " \n" +
+                    " void main()\n" +
+                    " {\n" +
+                    "   mediump vec4 base = texture2D(inputImageTexture, textureCoordinate);\n" +
+                    "   mediump vec4 overlay = texture2D(inputImageTexture2, textureCoordinate2);\n"
+                    +
+                    "   \n" +
+                    "   mediump float ra;\n" +
+                    "   if (overlay.a == 0.0 || ((base.r / overlay.r) > (base.a / overlay.a)))\n" +
+                    "     ra = overlay.a * base.a + overlay.r * (1.0 - base.a) + base.r * (1.0 - overlay.a);\n"
+                    +
+                    "   else\n" +
+                    "     ra = (base.r * overlay.a * overlay.a) / overlay.r + overlay.r * (1.0 - base.a) + base.r * (1.0 - overlay.a);\n"
+                    +
+                    "   \n" +
+                    "\n" +
+                    "   mediump float ga;\n" +
+                    "   if (overlay.a == 0.0 || ((base.g / overlay.g) > (base.a / overlay.a)))\n" +
+                    "     ga = overlay.a * base.a + overlay.g * (1.0 - base.a) + base.g * (1.0 - overlay.a);\n"
+                    +
+                    "   else\n" +
+                    "     ga = (base.g * overlay.a * overlay.a) / overlay.g + overlay.g * (1.0 - base.a) + base.g * (1.0 - overlay.a);\n"
+                    +
+                    "\n" +
+                    "   \n" +
+                    "   mediump float ba;\n" +
+                    "   if (overlay.a == 0.0 || ((base.b / overlay.b) > (base.a / overlay.a)))\n" +
+                    "     ba = overlay.a * base.a + overlay.b * (1.0 - base.a) + base.b * (1.0 - overlay.a);\n"
+                    +
+                    "   else\n" +
+                    "     ba = (base.b * overlay.a * overlay.a) / overlay.b + overlay.b * (1.0 - base.a) + base.b * (1.0 - overlay.a);\n"
+                    +
+                    "\n" +
+                    "   mediump float a = overlay.a + base.a - overlay.a * base.a;\n" +
+                    "   \n" +
+                    "   gl_FragColor = vec4(ra, ga, ba, a);\n" +
+                    " }";
 
     public GPUImageDivideBlendFilter() {
         super(DIVIDE_BLEND_FRAGMENT_SHADER);
diff --git a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageEmbossFilter.java b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageEmbossFilter.java
index f4cbdef7..64581b26 100644
--- a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageEmbossFilter.java
+++ b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageEmbossFilter.java
@@ -22,6 +22,7 @@
  * Intensity ranges from 0.0 to 4.0, with 1.0 as the normal level
  */
 public class GPUImageEmbossFilter extends GPUImage3x3ConvolutionFilter {
+
     private float mIntensity;
 
     public GPUImageEmbossFilter() {
@@ -41,7 +42,7 @@ public void onInit() {
 
     public void setIntensity(final float intensity) {
         mIntensity = intensity;
-        setConvolutionKernel(new float[] {
+        setConvolutionKernel(new float[]{
                 intensity * (-2.0f), -intensity, 0.0f,
                 -intensity, 1.0f, intensity,
                 0.0f, intensity, intensity * 2.0f,
diff --git a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageExclusionBlendFilter.java b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageExclusionBlendFilter.java
index dcfc9346..5937ba71 100644
--- a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageExclusionBlendFilter.java
+++ b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageExclusionBlendFilter.java
@@ -17,21 +17,26 @@
 package jp.co.cyberagent.android.gpuimage;
 
 public class GPUImageExclusionBlendFilter extends GPUImageTwoInputFilter {
-    public static final String EXCLUSION_BLEND_FRAGMENT_SHADER = "varying highp vec2 textureCoordinate;\n" +
-            " varying highp vec2 textureCoordinate2;\n" +
-            "\n" +
-            " uniform sampler2D inputImageTexture;\n" +
-            " uniform sampler2D inputImageTexture2;\n" +
-            " \n" +
-            " void main()\n" +
-            " {\n" +
-            "     mediump vec4 base = texture2D(inputImageTexture, textureCoordinate);\n" +
-            "     mediump vec4 overlay = texture2D(inputImageTexture2, textureCoordinate2);\n" +
-            "     \n" +
-            "     //     Dca = (Sca.Da + Dca.Sa - 2.Sca.Dca) + Sca.(1 - Da) + Dca.(1 - Sa)\n" +
-            "     \n" +
-            "     gl_FragColor = vec4((overlay.rgb * base.a + base.rgb * overlay.a - 2.0 * overlay.rgb * base.rgb) + overlay.rgb * (1.0 - base.a) + base.rgb * (1.0 - overlay.a), base.a);\n" +
-            " }";
+
+    public static final String EXCLUSION_BLEND_FRAGMENT_SHADER =
+            "varying highp vec2 textureCoordinate;\n" +
+                    " varying highp vec2 textureCoordinate2;\n" +
+                    "\n" +
+                    " uniform sampler2D inputImageTexture;\n" +
+                    " uniform sampler2D inputImageTexture2;\n" +
+                    " \n" +
+                    " void main()\n" +
+                    " {\n" +
+                    "     mediump vec4 base = texture2D(inputImageTexture, textureCoordinate);\n" +
+                    "     mediump vec4 overlay = texture2D(inputImageTexture2, textureCoordinate2);\n"
+                    +
+                    "     \n" +
+                    "     //     Dca = (Sca.Da + Dca.Sa - 2.Sca.Dca) + Sca.(1 - Da) + Dca.(1 - Sa)\n"
+                    +
+                    "     \n" +
+                    "     gl_FragColor = vec4((overlay.rgb * base.a + base.rgb * overlay.a - 2.0 * overlay.rgb * base.rgb) + overlay.rgb * (1.0 - base.a) + base.rgb * (1.0 - overlay.a), base.a);\n"
+                    +
+                    " }";
 
     public GPUImageExclusionBlendFilter() {
         super(EXCLUSION_BLEND_FRAGMENT_SHADER);
diff --git a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageExposureFilter.java b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageExposureFilter.java
index de5de414..6c605505 100644
--- a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageExposureFilter.java
+++ b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageExposureFilter.java
@@ -22,6 +22,7 @@
  * exposure: The adjusted exposure (-10.0 - 10.0, with 0.0 as the default)
  */
 public class GPUImageExposureFilter extends GPUImageFilter {
+
     public static final String EXPOSURE_FRAGMENT_SHADER = "" +
             " varying highp vec2 textureCoordinate;\n" +
             " \n" +
diff --git a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageFalseColorFilter.java b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageFalseColorFilter.java
index c815ad0f..0b6caea6 100644
--- a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageFalseColorFilter.java
+++ b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageFalseColorFilter.java
@@ -19,6 +19,7 @@
 import android.opengl.GLES20;
 
 public class GPUImageFalseColorFilter extends GPUImageFilter {
+
     public static final String FALSECOLOR_FRAGMENT_SHADER = "" +
             "precision lowp float;\n" +
             "\n" +
@@ -36,7 +37,8 @@
             "lowp vec4 textureColor = texture2D(inputImageTexture, textureCoordinate);\n" +
             "float luminance = dot(textureColor.rgb, luminanceWeighting);\n" +
             "\n" +
-            "gl_FragColor = vec4( mix(firstColor.rgb, secondColor.rgb, luminance), textureColor.a);\n" +
+            "gl_FragColor = vec4( mix(firstColor.rgb, secondColor.rgb, luminance), textureColor.a);\n"
+            +
             "}\n";
 
     private float[] mFirstColor;
@@ -48,8 +50,10 @@ public GPUImageFalseColorFilter() {
         this(0f, 0f, 0.5f, 1f, 0f, 0f);
     }
 
-    public GPUImageFalseColorFilter(float firstRed, float firstGreen, float firstBlue, float secondRed, float secondGreen, float secondBlue) {
-        this(new float[]{firstRed, firstGreen, firstBlue}, new float[]{secondRed, secondGreen, secondBlue});
+    public GPUImageFalseColorFilter(float firstRed, float firstGreen, float firstBlue,
+                                    float secondRed, float secondGreen, float secondBlue) {
+        this(new float[]{firstRed, firstGreen, firstBlue},
+                new float[]{secondRed, secondGreen, secondBlue});
     }
 
     public GPUImageFalseColorFilter(float[] firstColor, float[] secondColor) {
diff --git a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageFilter.java b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageFilter.java
index 7a8641aa..0a343323 100644
--- a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageFilter.java
+++ b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageFilter.java
@@ -26,6 +26,7 @@
 import java.util.LinkedList;
 
 public class GPUImageFilter {
+
     public static final String NO_FILTER_VERTEX_SHADER = "" +
             "attribute vec4 position;\n" +
             "attribute vec4 inputTextureCoordinate;\n" +
@@ -127,7 +128,8 @@ public void onDraw(final int textureId, final FloatBuffer cubeBuffer,
         GLES20.glBindTexture(GLES20.GL_TEXTURE_2D, 0);
     }
 
-    protected void onDrawArraysPre() {}
+    protected void onDrawArraysPre() {
+    }
 
     protected void runPendingOnDrawTasks() {
         while (!mRunOnDraw.isEmpty()) {
@@ -165,6 +167,7 @@ public int getUniformTexture() {
 
     protected void setInteger(final int location, final int intValue) {
         runOnDraw(new Runnable() {
+
             @Override
             public void run() {
                 GLES20.glUniform1i(location, intValue);
@@ -174,6 +177,7 @@ public void run() {
 
     protected void setFloat(final int location, final float floatValue) {
         runOnDraw(new Runnable() {
+
             @Override
             public void run() {
                 GLES20.glUniform1f(location, floatValue);
@@ -183,6 +187,7 @@ public void run() {
 
     protected void setFloatVec2(final int location, final float[] arrayValue) {
         runOnDraw(new Runnable() {
+
             @Override
             public void run() {
                 GLES20.glUniform2fv(location, 1, FloatBuffer.wrap(arrayValue));
@@ -192,6 +197,7 @@ public void run() {
 
     protected void setFloatVec3(final int location, final float[] arrayValue) {
         runOnDraw(new Runnable() {
+
             @Override
             public void run() {
                 GLES20.glUniform3fv(location, 1, FloatBuffer.wrap(arrayValue));
@@ -201,6 +207,7 @@ public void run() {
 
     protected void setFloatVec4(final int location, final float[] arrayValue) {
         runOnDraw(new Runnable() {
+
             @Override
             public void run() {
                 GLES20.glUniform4fv(location, 1, FloatBuffer.wrap(arrayValue));
@@ -210,6 +217,7 @@ public void run() {
 
     protected void setFloatArray(final int location, final float[] arrayValue) {
         runOnDraw(new Runnable() {
+
             @Override
             public void run() {
                 GLES20.glUniform1fv(location, arrayValue.length, FloatBuffer.wrap(arrayValue));
diff --git a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageFilterGroup.java b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageFilterGroup.java
index 10ea41ca..8180d0f8 100644
--- a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageFilterGroup.java
+++ b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageFilterGroup.java
@@ -18,6 +18,7 @@
 
 import android.annotation.SuppressLint;
 import android.opengl.GLES20;
+
 import jp.co.cyberagent.android.gpuimage.util.TextureRotationUtil;
 
 import java.nio.ByteBuffer;
@@ -178,7 +179,7 @@ public void onOutputSizeChanged(final int width, final int height) {
      * @see jp.co.cyberagent.android.gpuimage.GPUImageFilter#onDraw(int,
      * java.nio.FloatBuffer, java.nio.FloatBuffer)
      */
-    @SuppressLint("WrongCall")    
+    @SuppressLint("WrongCall")
     @Override
     public void onDraw(final int textureId, final FloatBuffer cubeBuffer,
                        final FloatBuffer textureBuffer) {
@@ -200,7 +201,8 @@ public void onDraw(final int textureId, final FloatBuffer cubeBuffer,
                 if (i == 0) {
                     filter.onDraw(previousTexture, cubeBuffer, textureBuffer);
                 } else if (i == size - 1) {
-                    filter.onDraw(previousTexture, mGLCubeBuffer, (size % 2 == 0) ? mGLTextureFlipBuffer : mGLTextureBuffer);
+                    filter.onDraw(previousTexture, mGLCubeBuffer,
+                            (size % 2 == 0) ? mGLTextureFlipBuffer : mGLTextureBuffer);
                 } else {
                     filter.onDraw(previousTexture, mGLCubeBuffer, mGLTextureBuffer);
                 }
@@ -211,7 +213,7 @@ public void onDraw(final int textureId, final FloatBuffer cubeBuffer,
                 }
             }
         }
-     }
+    }
 
     /**
      * Gets the filters.
@@ -242,8 +244,9 @@ public void updateMergedFilters() {
             if (filter instanceof GPUImageFilterGroup) {
                 ((GPUImageFilterGroup) filter).updateMergedFilters();
                 filters = ((GPUImageFilterGroup) filter).getMergedFilters();
-                if (filters == null || filters.isEmpty())
+                if (filters == null || filters.isEmpty()) {
                     continue;
+                }
                 mMergedFilters.addAll(filters);
                 continue;
             }
diff --git a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageGammaFilter.java b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageGammaFilter.java
index 1f902d0f..9a948ef2 100644
--- a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageGammaFilter.java
+++ b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageGammaFilter.java
@@ -22,6 +22,7 @@
  * gamma value ranges from 0.0 to 3.0, with 1.0 as the normal level
  */
 public class GPUImageGammaFilter extends GPUImageFilter {
+
     public static final String GAMMA_FRAGMENT_SHADER = "" +
             "varying highp vec2 textureCoordinate;\n" +
             " \n" +
diff --git a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageGaussianBlurFilter.java b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageGaussianBlurFilter.java
index c912f73e..209f7f7d 100644
--- a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageGaussianBlurFilter.java
+++ b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageGaussianBlurFilter.java
@@ -21,6 +21,7 @@
  * blurSize value ranging from 0.0 on up, with a default of 1.0
  */
 public class GPUImageGaussianBlurFilter extends GPUImageTwoPassTextureSamplingFilter {
+
     public static final String VERTEX_SHADER =
             "attribute vec4 position;\n" +
                     "attribute vec4 inputTextureCoordinate;\n" +
@@ -107,6 +108,7 @@ public float getHorizontalTexelOffsetRatio() {
     public void setBlurSize(float blurSize) {
         mBlurSize = blurSize;
         runOnDraw(new Runnable() {
+
             @Override
             public void run() {
                 initTexelOffsets();
diff --git a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageGlassSphereFilter.java b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageGlassSphereFilter.java
index 460019cc..2bf6ef2a 100644
--- a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageGlassSphereFilter.java
+++ b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageGlassSphereFilter.java
@@ -20,6 +20,7 @@
 import android.opengl.GLES20;
 
 public class GPUImageGlassSphereFilter extends GPUImageFilter {
+
     public static final String SPHERE_FRAGMENT_SHADER = "" +
             "varying highp vec2 textureCoordinate;\n" +
             "\n" +
@@ -35,22 +36,28 @@
             "\n" +
             "void main()\n" +
             "{\n" +
-            "highp vec2 textureCoordinateToUse = vec2(textureCoordinate.x, (textureCoordinate.y * aspectRatio + 0.5 - 0.5 * aspectRatio));\n" +
+            "highp vec2 textureCoordinateToUse = vec2(textureCoordinate.x, (textureCoordinate.y * aspectRatio + 0.5 - 0.5 * aspectRatio));\n"
+            +
             "highp float distanceFromCenter = distance(center, textureCoordinateToUse);\n" +
             "lowp float checkForPresenceWithinSphere = step(distanceFromCenter, radius);\n" +
             "\n" +
             "distanceFromCenter = distanceFromCenter / radius;\n" +
             "\n" +
-            "highp float normalizedDepth = radius * sqrt(1.0 - distanceFromCenter * distanceFromCenter);\n" +
-            "highp vec3 sphereNormal = normalize(vec3(textureCoordinateToUse - center, normalizedDepth));\n" +
+            "highp float normalizedDepth = radius * sqrt(1.0 - distanceFromCenter * distanceFromCenter);\n"
+            +
+            "highp vec3 sphereNormal = normalize(vec3(textureCoordinateToUse - center, normalizedDepth));\n"
+            +
             "\n" +
-            "highp vec3 refractedVector = 2.0 * refract(vec3(0.0, 0.0, -1.0), sphereNormal, refractiveIndex);\n" +
+            "highp vec3 refractedVector = 2.0 * refract(vec3(0.0, 0.0, -1.0), sphereNormal, refractiveIndex);\n"
+            +
             "refractedVector.xy = -refractedVector.xy;\n" +
             "\n" +
-            "highp vec3 finalSphereColor = texture2D(inputImageTexture, (refractedVector.xy + 1.0) * 0.5).rgb;\n" +
+            "highp vec3 finalSphereColor = texture2D(inputImageTexture, (refractedVector.xy + 1.0) * 0.5).rgb;\n"
+            +
             "\n" +
             "// Grazing angle lighting\n" +
-            "highp float lightingIntensity = 2.5 * (1.0 - pow(clamp(dot(ambientLightPosition, sphereNormal), 0.0, 1.0), 0.25));\n" +
+            "highp float lightingIntensity = 2.5 * (1.0 - pow(clamp(dot(ambientLightPosition, sphereNormal), 0.0, 1.0), 0.25));\n"
+            +
             "finalSphereColor += lightingIntensity;\n" +
             "\n" +
             "// Specular lighting\n" +
diff --git a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageGrayscaleFilter.java b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageGrayscaleFilter.java
index b0a67f9e..893e7e78 100644
--- a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageGrayscaleFilter.java
+++ b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageGrayscaleFilter.java
@@ -20,6 +20,7 @@
  * Applies a grayscale effect to the image.
  */
 public class GPUImageGrayscaleFilter extends GPUImageFilter {
+
     public static final String GRAYSCALE_FRAGMENT_SHADER = "" +
             "precision highp float;\n" +
             "\n" +
diff --git a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageHalftoneFilter.java b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageHalftoneFilter.java
index 52e27d04..a3d90eb1 100644
--- a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageHalftoneFilter.java
+++ b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageHalftoneFilter.java
@@ -3,6 +3,7 @@
 import android.opengl.GLES20;
 
 public class GPUImageHalftoneFilter extends GPUImageFilter {
+
     public static final String HALFTONE_FRAGMENT_SHADER = "" +
             "varying highp vec2 textureCoordinate;\n" +
 
@@ -15,14 +16,20 @@
 
             "void main()\n" +
             "{\n" +
-            "  highp vec2 sampleDivisor = vec2(fractionalWidthOfPixel, fractionalWidthOfPixel / aspectRatio);\n" +
-            "  highp vec2 samplePos = textureCoordinate - mod(textureCoordinate, sampleDivisor) + 0.5 * sampleDivisor;\n" +
-            "  highp vec2 textureCoordinateToUse = vec2(textureCoordinate.x, (textureCoordinate.y * aspectRatio + 0.5 - 0.5 * aspectRatio));\n" +
-            "  highp vec2 adjustedSamplePos = vec2(samplePos.x, (samplePos.y * aspectRatio + 0.5 - 0.5 * aspectRatio));\n" +
-            "  highp float distanceFromSamplePoint = distance(adjustedSamplePos, textureCoordinateToUse);\n" +
+            "  highp vec2 sampleDivisor = vec2(fractionalWidthOfPixel, fractionalWidthOfPixel / aspectRatio);\n"
+            +
+            "  highp vec2 samplePos = textureCoordinate - mod(textureCoordinate, sampleDivisor) + 0.5 * sampleDivisor;\n"
+            +
+            "  highp vec2 textureCoordinateToUse = vec2(textureCoordinate.x, (textureCoordinate.y * aspectRatio + 0.5 - 0.5 * aspectRatio));\n"
+            +
+            "  highp vec2 adjustedSamplePos = vec2(samplePos.x, (samplePos.y * aspectRatio + 0.5 - 0.5 * aspectRatio));\n"
+            +
+            "  highp float distanceFromSamplePoint = distance(adjustedSamplePos, textureCoordinateToUse);\n"
+            +
             "  lowp vec3 sampledColor = texture2D(inputImageTexture, samplePos).rgb;\n" +
             "  highp float dotScaling = 1.0 - dot(sampledColor, W);\n" +
-            "  lowp float checkForPresenceWithinDot = 1.0 - step(distanceFromSamplePoint, (fractionalWidthOfPixel * 0.5) * dotScaling);\n" +
+            "  lowp float checkForPresenceWithinDot = 1.0 - step(distanceFromSamplePoint, (fractionalWidthOfPixel * 0.5) * dotScaling);\n"
+            +
             "  gl_FragColor = vec4(vec3(checkForPresenceWithinDot), 1.0);\n" +
             "}";
 
@@ -44,7 +51,8 @@ public GPUImageHalftoneFilter(float fractionalWidthOfAPixel) {
     @Override
     public void onInit() {
         super.onInit();
-        mFractionalWidthOfPixelLocation = GLES20.glGetUniformLocation(getProgram(), "fractionalWidthOfPixel");
+        mFractionalWidthOfPixelLocation = GLES20
+                .glGetUniformLocation(getProgram(), "fractionalWidthOfPixel");
         mAspectRatioLocation = GLES20.glGetUniformLocation(getProgram(), "aspectRatio");
         setFractionalWidthOfAPixel(mFractionalWidthOfAPixel);
     }
@@ -52,7 +60,7 @@ public void onInit() {
     @Override
     public void onOutputSizeChanged(final int width, final int height) {
         super.onOutputSizeChanged(width, height);
-        setAspectRatio((float)height / (float) width);
+        setAspectRatio((float) height / (float) width);
     }
 
     public void setFractionalWidthOfAPixel(final float fractionalWidthOfAPixel) {
diff --git a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageHardLightBlendFilter.java b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageHardLightBlendFilter.java
index 5bcb9c90..fd4bcb4c 100644
--- a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageHardLightBlendFilter.java
+++ b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageHardLightBlendFilter.java
@@ -17,42 +17,51 @@
 package jp.co.cyberagent.android.gpuimage;
 
 public class GPUImageHardLightBlendFilter extends GPUImageTwoInputFilter {
-    public static final String HARD_LIGHT_BLEND_FRAGMENT_SHADER = "varying highp vec2 textureCoordinate;\n" +
-            " varying highp vec2 textureCoordinate2;\n" +
-            "\n" +
-            " uniform sampler2D inputImageTexture;\n" +
-            " uniform sampler2D inputImageTexture2;\n" +
-            "\n" +
-            " const highp vec3 W = vec3(0.2125, 0.7154, 0.0721);\n" +
-            "\n" +
-            " void main()\n" +
-            " {\n" +
-            "     mediump vec4 base = texture2D(inputImageTexture, textureCoordinate);\n" +
-            "     mediump vec4 overlay = texture2D(inputImageTexture2, textureCoordinate2);\n" +
-            "\n" +
-            "     highp float ra;\n" +
-            "     if (2.0 * overlay.r < overlay.a) {\n" +
-            "         ra = 2.0 * overlay.r * base.r + overlay.r * (1.0 - base.a) + base.r * (1.0 - overlay.a);\n" +
-            "     } else {\n" +
-            "         ra = overlay.a * base.a - 2.0 * (base.a - base.r) * (overlay.a - overlay.r) + overlay.r * (1.0 - base.a) + base.r * (1.0 - overlay.a);\n" +
-            "     }\n" +
-            "     \n" +
-            "     highp float ga;\n" +
-            "     if (2.0 * overlay.g < overlay.a) {\n" +
-            "         ga = 2.0 * overlay.g * base.g + overlay.g * (1.0 - base.a) + base.g * (1.0 - overlay.a);\n" +
-            "     } else {\n" +
-            "         ga = overlay.a * base.a - 2.0 * (base.a - base.g) * (overlay.a - overlay.g) + overlay.g * (1.0 - base.a) + base.g * (1.0 - overlay.a);\n" +
-            "     }\n" +
-            "     \n" +
-            "     highp float ba;\n" +
-            "     if (2.0 * overlay.b < overlay.a) {\n" +
-            "         ba = 2.0 * overlay.b * base.b + overlay.b * (1.0 - base.a) + base.b * (1.0 - overlay.a);\n" +
-            "     } else {\n" +
-            "         ba = overlay.a * base.a - 2.0 * (base.a - base.b) * (overlay.a - overlay.b) + overlay.b * (1.0 - base.a) + base.b * (1.0 - overlay.a);\n" +
-            "     }\n" +
-            "     \n" +
-            "     gl_FragColor = vec4(ra, ga, ba, 1.0);\n" +
-            " }";
+
+    public static final String HARD_LIGHT_BLEND_FRAGMENT_SHADER =
+            "varying highp vec2 textureCoordinate;\n" +
+                    " varying highp vec2 textureCoordinate2;\n" +
+                    "\n" +
+                    " uniform sampler2D inputImageTexture;\n" +
+                    " uniform sampler2D inputImageTexture2;\n" +
+                    "\n" +
+                    " const highp vec3 W = vec3(0.2125, 0.7154, 0.0721);\n" +
+                    "\n" +
+                    " void main()\n" +
+                    " {\n" +
+                    "     mediump vec4 base = texture2D(inputImageTexture, textureCoordinate);\n" +
+                    "     mediump vec4 overlay = texture2D(inputImageTexture2, textureCoordinate2);\n"
+                    +
+                    "\n" +
+                    "     highp float ra;\n" +
+                    "     if (2.0 * overlay.r < overlay.a) {\n" +
+                    "         ra = 2.0 * overlay.r * base.r + overlay.r * (1.0 - base.a) + base.r * (1.0 - overlay.a);\n"
+                    +
+                    "     } else {\n" +
+                    "         ra = overlay.a * base.a - 2.0 * (base.a - base.r) * (overlay.a - overlay.r) + overlay.r * (1.0 - base.a) + base.r * (1.0 - overlay.a);\n"
+                    +
+                    "     }\n" +
+                    "     \n" +
+                    "     highp float ga;\n" +
+                    "     if (2.0 * overlay.g < overlay.a) {\n" +
+                    "         ga = 2.0 * overlay.g * base.g + overlay.g * (1.0 - base.a) + base.g * (1.0 - overlay.a);\n"
+                    +
+                    "     } else {\n" +
+                    "         ga = overlay.a * base.a - 2.0 * (base.a - base.g) * (overlay.a - overlay.g) + overlay.g * (1.0 - base.a) + base.g * (1.0 - overlay.a);\n"
+                    +
+                    "     }\n" +
+                    "     \n" +
+                    "     highp float ba;\n" +
+                    "     if (2.0 * overlay.b < overlay.a) {\n" +
+                    "         ba = 2.0 * overlay.b * base.b + overlay.b * (1.0 - base.a) + base.b * (1.0 - overlay.a);\n"
+                    +
+                    "     } else {\n" +
+                    "         ba = overlay.a * base.a - 2.0 * (base.a - base.b) * (overlay.a - overlay.b) + overlay.b * (1.0 - base.a) + base.b * (1.0 - overlay.a);\n"
+                    +
+                    "     }\n" +
+                    "     \n" +
+                    "     gl_FragColor = vec4(ra, ga, ba, 1.0);\n" +
+                    " }";
 
     public GPUImageHardLightBlendFilter() {
         super(HARD_LIGHT_BLEND_FRAGMENT_SHADER);
diff --git a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageHazeFilter.java b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageHazeFilter.java
index bb230abc..bd10cd54 100644
--- a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageHazeFilter.java
+++ b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageHazeFilter.java
@@ -24,6 +24,7 @@
  * This is similar to a UV filter.
  */
 public class GPUImageHazeFilter extends GPUImageFilter {
+
     public static final String HAZE_FRAGMENT_SHADER = "" +
             "varying highp vec2 textureCoordinate;\n" +
             "\n" +
@@ -39,7 +40,8 @@
             "\n" +
             "	 highp float  d = textureCoordinate.y * slope  +  distance; \n" +
             "\n" +
-            "	 highp vec4 c = texture2D(inputImageTexture, textureCoordinate) ; // consider using unpremultiply\n" +
+            "	 highp vec4 c = texture2D(inputImageTexture, textureCoordinate) ; // consider using unpremultiply\n"
+            +
             "\n" +
             "	 c = (c - d * color) / (1.0 -d);\n" +
             "\n" +
diff --git a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageHighlightShadowFilter.java b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageHighlightShadowFilter.java
index 878c508a..1032e335 100644
--- a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageHighlightShadowFilter.java
+++ b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageHighlightShadowFilter.java
@@ -24,6 +24,7 @@
  * highlights: Decrease to darken highlights, from 0.0 to 1.0, with 1.0 as the default.
  */
 public class GPUImageHighlightShadowFilter extends GPUImageFilter {
+
     public static final String HIGHLIGHT_SHADOW_FRAGMENT_SHADER = "" +
             " uniform sampler2D inputImageTexture;\n" +
             " varying highp vec2 textureCoordinate;\n" +
@@ -38,9 +39,12 @@
             " 	lowp vec4 source = texture2D(inputImageTexture, textureCoordinate);\n" +
             " 	mediump float luminance = dot(source.rgb, luminanceWeighting);\n" +
             " \n" +
-            " 	mediump float shadow = clamp((pow(luminance, 1.0/(shadows+1.0)) + (-0.76)*pow(luminance, 2.0/(shadows+1.0))) - luminance, 0.0, 1.0);\n" +
-            " 	mediump float highlight = clamp((1.0 - (pow(1.0-luminance, 1.0/(2.0-highlights)) + (-0.8)*pow(1.0-luminance, 2.0/(2.0-highlights)))) - luminance, -1.0, 0.0);\n" +
-            " 	lowp vec3 result = vec3(0.0, 0.0, 0.0) + ((luminance + shadow + highlight) - 0.0) * ((source.rgb - vec3(0.0, 0.0, 0.0))/(luminance - 0.0));\n" +
+            " 	mediump float shadow = clamp((pow(luminance, 1.0/(shadows+1.0)) + (-0.76)*pow(luminance, 2.0/(shadows+1.0))) - luminance, 0.0, 1.0);\n"
+            +
+            " 	mediump float highlight = clamp((1.0 - (pow(1.0-luminance, 1.0/(2.0-highlights)) + (-0.8)*pow(1.0-luminance, 2.0/(2.0-highlights)))) - luminance, -1.0, 0.0);\n"
+            +
+            " 	lowp vec3 result = vec3(0.0, 0.0, 0.0) + ((luminance + shadow + highlight) - 0.0) * ((source.rgb - vec3(0.0, 0.0, 0.0))/(luminance - 0.0));\n"
+            +
             " \n" +
             " 	gl_FragColor = vec4(result.rgb, source.a);\n" +
             " }";
@@ -78,7 +82,7 @@ public void setHighlights(final float highlights) {
         mHighlights = highlights;
         setFloat(mHighlightsLocation, mHighlights);
     }
-    
+
     public void setShadows(final float shadows) {
         mShadows = shadows;
         setFloat(mShadowsLocation, mShadows);
diff --git a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageHueBlendFilter.java b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageHueBlendFilter.java
index 3950901c..c64e6d76 100644
--- a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageHueBlendFilter.java
+++ b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageHueBlendFilter.java
@@ -17,98 +17,103 @@
 package jp.co.cyberagent.android.gpuimage;
 
 public class GPUImageHueBlendFilter extends GPUImageTwoInputFilter {
-    public static final String HUE_BLEND_FRAGMENT_SHADER = "varying highp vec2 textureCoordinate;\n" +
-            " varying highp vec2 textureCoordinate2;\n" +
-            " \n" +
-            " uniform sampler2D inputImageTexture;\n" +
-            " uniform sampler2D inputImageTexture2;\n" +
-            " \n" +
-            " highp float lum(lowp vec3 c) {\n" +
-            "     return dot(c, vec3(0.3, 0.59, 0.11));\n" +
-            " }\n" +
-            " \n" +
-            " lowp vec3 clipcolor(lowp vec3 c) {\n" +
-            "     highp float l = lum(c);\n" +
-            "     lowp float n = min(min(c.r, c.g), c.b);\n" +
-            "     lowp float x = max(max(c.r, c.g), c.b);\n" +
-            "     \n" +
-            "     if (n < 0.0) {\n" +
-            "         c.r = l + ((c.r - l) * l) / (l - n);\n" +
-            "         c.g = l + ((c.g - l) * l) / (l - n);\n" +
-            "         c.b = l + ((c.b - l) * l) / (l - n);\n" +
-            "     }\n" +
-            "     if (x > 1.0) {\n" +
-            "         c.r = l + ((c.r - l) * (1.0 - l)) / (x - l);\n" +
-            "         c.g = l + ((c.g - l) * (1.0 - l)) / (x - l);\n" +
-            "         c.b = l + ((c.b - l) * (1.0 - l)) / (x - l);\n" +
-            "     }\n" +
-            "     \n" +
-            "     return c;\n" +
-            " }\n" +
-            " \n" +
-            " lowp vec3 setlum(lowp vec3 c, highp float l) {\n" +
-            "     highp float d = l - lum(c);\n" +
-            "     c = c + vec3(d);\n" +
-            "     return clipcolor(c);\n" +
-            " }\n" +
-            " \n" +
-            " highp float sat(lowp vec3 c) {\n" +
-            "     lowp float n = min(min(c.r, c.g), c.b);\n" +
-            "     lowp float x = max(max(c.r, c.g), c.b);\n" +
-            "     return x - n;\n" +
-            " }\n" +
-            " \n" +
-            " lowp float mid(lowp float cmin, lowp float cmid, lowp float cmax, highp float s) {\n" +
-            "     return ((cmid - cmin) * s) / (cmax - cmin);\n" +
-            " }\n" +
-            " \n" +
-            " lowp vec3 setsat(lowp vec3 c, highp float s) {\n" +
-            "     if (c.r > c.g) {\n" +
-            "         if (c.r > c.b) {\n" +
-            "             if (c.g > c.b) {\n" +
-            "                 /* g is mid, b is min */\n" +
-            "                 c.g = mid(c.b, c.g, c.r, s);\n" +
-            "                 c.b = 0.0;\n" +
-            "             } else {\n" +
-            "                 /* b is mid, g is min */\n" +
-            "                 c.b = mid(c.g, c.b, c.r, s);\n" +
-            "                 c.g = 0.0;\n" +
-            "             }\n" +
-            "             c.r = s;\n" +
-            "         } else {\n" +
-            "             /* b is max, r is mid, g is min */\n" +
-            "             c.r = mid(c.g, c.r, c.b, s);\n" +
-            "             c.b = s;\n" +
-            "             c.r = 0.0;\n" +
-            "         }\n" +
-            "     } else if (c.r > c.b) {\n" +
-            "         /* g is max, r is mid, b is min */\n" +
-            "         c.r = mid(c.b, c.r, c.g, s);\n" +
-            "         c.g = s;\n" +
-            "         c.b = 0.0;\n" +
-            "     } else if (c.g > c.b) {\n" +
-            "         /* g is max, b is mid, r is min */\n" +
-            "         c.b = mid(c.r, c.b, c.g, s);\n" +
-            "         c.g = s;\n" +
-            "         c.r = 0.0;\n" +
-            "     } else if (c.b > c.g) {\n" +
-            "         /* b is max, g is mid, r is min */\n" +
-            "         c.g = mid(c.r, c.g, c.b, s);\n" +
-            "         c.b = s;\n" +
-            "         c.r = 0.0;\n" +
-            "     } else {\n" +
-            "         c = vec3(0.0);\n" +
-            "     }\n" +
-            "     return c;\n" +
-            " }\n" +
-            " \n" +
-            " void main()\n" +
-            " {\n" +
-            "   highp vec4 baseColor = texture2D(inputImageTexture, textureCoordinate);\n" +
-            "   highp vec4 overlayColor = texture2D(inputImageTexture2, textureCoordinate2);\n" +
-            "     \n" +
-            "     gl_FragColor = vec4(baseColor.rgb * (1.0 - overlayColor.a) + setlum(setsat(overlayColor.rgb, sat(baseColor.rgb)), lum(baseColor.rgb)) * overlayColor.a, baseColor.a);\n" +
-            " }";
+
+    public static final String HUE_BLEND_FRAGMENT_SHADER =
+            "varying highp vec2 textureCoordinate;\n" +
+                    " varying highp vec2 textureCoordinate2;\n" +
+                    " \n" +
+                    " uniform sampler2D inputImageTexture;\n" +
+                    " uniform sampler2D inputImageTexture2;\n" +
+                    " \n" +
+                    " highp float lum(lowp vec3 c) {\n" +
+                    "     return dot(c, vec3(0.3, 0.59, 0.11));\n" +
+                    " }\n" +
+                    " \n" +
+                    " lowp vec3 clipcolor(lowp vec3 c) {\n" +
+                    "     highp float l = lum(c);\n" +
+                    "     lowp float n = min(min(c.r, c.g), c.b);\n" +
+                    "     lowp float x = max(max(c.r, c.g), c.b);\n" +
+                    "     \n" +
+                    "     if (n < 0.0) {\n" +
+                    "         c.r = l + ((c.r - l) * l) / (l - n);\n" +
+                    "         c.g = l + ((c.g - l) * l) / (l - n);\n" +
+                    "         c.b = l + ((c.b - l) * l) / (l - n);\n" +
+                    "     }\n" +
+                    "     if (x > 1.0) {\n" +
+                    "         c.r = l + ((c.r - l) * (1.0 - l)) / (x - l);\n" +
+                    "         c.g = l + ((c.g - l) * (1.0 - l)) / (x - l);\n" +
+                    "         c.b = l + ((c.b - l) * (1.0 - l)) / (x - l);\n" +
+                    "     }\n" +
+                    "     \n" +
+                    "     return c;\n" +
+                    " }\n" +
+                    " \n" +
+                    " lowp vec3 setlum(lowp vec3 c, highp float l) {\n" +
+                    "     highp float d = l - lum(c);\n" +
+                    "     c = c + vec3(d);\n" +
+                    "     return clipcolor(c);\n" +
+                    " }\n" +
+                    " \n" +
+                    " highp float sat(lowp vec3 c) {\n" +
+                    "     lowp float n = min(min(c.r, c.g), c.b);\n" +
+                    "     lowp float x = max(max(c.r, c.g), c.b);\n" +
+                    "     return x - n;\n" +
+                    " }\n" +
+                    " \n" +
+                    " lowp float mid(lowp float cmin, lowp float cmid, lowp float cmax, highp float s) {\n"
+                    +
+                    "     return ((cmid - cmin) * s) / (cmax - cmin);\n" +
+                    " }\n" +
+                    " \n" +
+                    " lowp vec3 setsat(lowp vec3 c, highp float s) {\n" +
+                    "     if (c.r > c.g) {\n" +
+                    "         if (c.r > c.b) {\n" +
+                    "             if (c.g > c.b) {\n" +
+                    "                 /* g is mid, b is min */\n" +
+                    "                 c.g = mid(c.b, c.g, c.r, s);\n" +
+                    "                 c.b = 0.0;\n" +
+                    "             } else {\n" +
+                    "                 /* b is mid, g is min */\n" +
+                    "                 c.b = mid(c.g, c.b, c.r, s);\n" +
+                    "                 c.g = 0.0;\n" +
+                    "             }\n" +
+                    "             c.r = s;\n" +
+                    "         } else {\n" +
+                    "             /* b is max, r is mid, g is min */\n" +
+                    "             c.r = mid(c.g, c.r, c.b, s);\n" +
+                    "             c.b = s;\n" +
+                    "             c.r = 0.0;\n" +
+                    "         }\n" +
+                    "     } else if (c.r > c.b) {\n" +
+                    "         /* g is max, r is mid, b is min */\n" +
+                    "         c.r = mid(c.b, c.r, c.g, s);\n" +
+                    "         c.g = s;\n" +
+                    "         c.b = 0.0;\n" +
+                    "     } else if (c.g > c.b) {\n" +
+                    "         /* g is max, b is mid, r is min */\n" +
+                    "         c.b = mid(c.r, c.b, c.g, s);\n" +
+                    "         c.g = s;\n" +
+                    "         c.r = 0.0;\n" +
+                    "     } else if (c.b > c.g) {\n" +
+                    "         /* b is max, g is mid, r is min */\n" +
+                    "         c.g = mid(c.r, c.g, c.b, s);\n" +
+                    "         c.b = s;\n" +
+                    "         c.r = 0.0;\n" +
+                    "     } else {\n" +
+                    "         c = vec3(0.0);\n" +
+                    "     }\n" +
+                    "     return c;\n" +
+                    " }\n" +
+                    " \n" +
+                    " void main()\n" +
+                    " {\n" +
+                    "   highp vec4 baseColor = texture2D(inputImageTexture, textureCoordinate);\n" +
+                    "   highp vec4 overlayColor = texture2D(inputImageTexture2, textureCoordinate2);\n"
+                    +
+                    "     \n" +
+                    "     gl_FragColor = vec4(baseColor.rgb * (1.0 - overlayColor.a) + setlum(setsat(overlayColor.rgb, sat(baseColor.rgb)), lum(baseColor.rgb)) * overlayColor.a, baseColor.a);\n"
+                    +
+                    " }";
 
     public GPUImageHueBlendFilter() {
         super(HUE_BLEND_FRAGMENT_SHADER);
diff --git a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageHueFilter.java b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageHueFilter.java
index 9fcf7939..e348cbbb 100644
--- a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageHueFilter.java
+++ b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageHueFilter.java
@@ -19,50 +19,51 @@
 import android.opengl.GLES20;
 
 public class GPUImageHueFilter extends GPUImageFilter {
+
     public static final String HUE_FRAGMENT_SHADER = "" +
-      "precision highp float;\n" +
-      "varying highp vec2 textureCoordinate;\n" +
-      "\n" +
-      "uniform sampler2D inputImageTexture;\n" +
-      "uniform mediump float hueAdjust;\n" +
-      "const highp vec4 kRGBToYPrime = vec4 (0.299, 0.587, 0.114, 0.0);\n" +
-      "const highp vec4 kRGBToI = vec4 (0.595716, -0.274453, -0.321263, 0.0);\n" +
-      "const highp vec4 kRGBToQ = vec4 (0.211456, -0.522591, 0.31135, 0.0);\n" +
-      "\n" +
-      "const highp vec4 kYIQToR = vec4 (1.0, 0.9563, 0.6210, 0.0);\n" +
-      "const highp vec4 kYIQToG = vec4 (1.0, -0.2721, -0.6474, 0.0);\n" +
-      "const highp vec4 kYIQToB = vec4 (1.0, -1.1070, 1.7046, 0.0);\n" +
-      "\n" +
-      "void main ()\n" +
-      "{\n" +
-      "    // Sample the input pixel\n" +
-      "    highp vec4 color = texture2D(inputImageTexture, textureCoordinate);\n" +
-      "\n" +
-      "    // Convert to YIQ\n" +
-      "    highp float YPrime = dot (color, kRGBToYPrime);\n" +
-      "    highp float I = dot (color, kRGBToI);\n" +
-      "    highp float Q = dot (color, kRGBToQ);\n" +
-      "\n" +
-      "    // Calculate the hue and chroma\n" +
-      "    highp float hue = atan (Q, I);\n" +
-      "    highp float chroma = sqrt (I * I + Q * Q);\n" +
-      "\n" +
-      "    // Make the user's adjustments\n" +
-      "    hue += (-hueAdjust); //why negative rotation?\n" +
-      "\n" +
-      "    // Convert back to YIQ\n" +
-      "    Q = chroma * sin (hue);\n" +
-      "    I = chroma * cos (hue);\n" +
-      "\n" +
-      "    // Convert back to RGB\n" +
-      "    highp vec4 yIQ = vec4 (YPrime, I, Q, 0.0);\n" +
-      "    color.r = dot (yIQ, kYIQToR);\n" +
-      "    color.g = dot (yIQ, kYIQToG);\n" +
-      "    color.b = dot (yIQ, kYIQToB);\n" +
-      "\n" +
-      "    // Save the result\n" +
-      "    gl_FragColor = color;\n" +
-      "}\n";
+            "precision highp float;\n" +
+            "varying highp vec2 textureCoordinate;\n" +
+            "\n" +
+            "uniform sampler2D inputImageTexture;\n" +
+            "uniform mediump float hueAdjust;\n" +
+            "const highp vec4 kRGBToYPrime = vec4 (0.299, 0.587, 0.114, 0.0);\n" +
+            "const highp vec4 kRGBToI = vec4 (0.595716, -0.274453, -0.321263, 0.0);\n" +
+            "const highp vec4 kRGBToQ = vec4 (0.211456, -0.522591, 0.31135, 0.0);\n" +
+            "\n" +
+            "const highp vec4 kYIQToR = vec4 (1.0, 0.9563, 0.6210, 0.0);\n" +
+            "const highp vec4 kYIQToG = vec4 (1.0, -0.2721, -0.6474, 0.0);\n" +
+            "const highp vec4 kYIQToB = vec4 (1.0, -1.1070, 1.7046, 0.0);\n" +
+            "\n" +
+            "void main ()\n" +
+            "{\n" +
+            "    // Sample the input pixel\n" +
+            "    highp vec4 color = texture2D(inputImageTexture, textureCoordinate);\n" +
+            "\n" +
+            "    // Convert to YIQ\n" +
+            "    highp float YPrime = dot (color, kRGBToYPrime);\n" +
+            "    highp float I = dot (color, kRGBToI);\n" +
+            "    highp float Q = dot (color, kRGBToQ);\n" +
+            "\n" +
+            "    // Calculate the hue and chroma\n" +
+            "    highp float hue = atan (Q, I);\n" +
+            "    highp float chroma = sqrt (I * I + Q * Q);\n" +
+            "\n" +
+            "    // Make the user's adjustments\n" +
+            "    hue += (-hueAdjust); //why negative rotation?\n" +
+            "\n" +
+            "    // Convert back to YIQ\n" +
+            "    Q = chroma * sin (hue);\n" +
+            "    I = chroma * cos (hue);\n" +
+            "\n" +
+            "    // Convert back to RGB\n" +
+            "    highp vec4 yIQ = vec4 (YPrime, I, Q, 0.0);\n" +
+            "    color.r = dot (yIQ, kYIQToR);\n" +
+            "    color.g = dot (yIQ, kYIQToG);\n" +
+            "    color.b = dot (yIQ, kYIQToB);\n" +
+            "\n" +
+            "    // Save the result\n" +
+            "    gl_FragColor = color;\n" +
+            "}\n";
 
     private float mHue;
     private int mHueLocation;
diff --git a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageKuwaharaFilter.java b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageKuwaharaFilter.java
index 6fc7f32b..44f4ef42 100644
--- a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageKuwaharaFilter.java
+++ b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageKuwaharaFilter.java
@@ -20,11 +20,12 @@
 
 /**
  * Kuwahara image abstraction, drawn from the work of Kyprianidis, et. al. in their publication
- * "Anisotropic Kuwahara Filtering on the GPU" within the GPU Pro collection. This produces an oil-painting-like
- * image, but it is extremely computationally expensive, so it can take seconds to render a frame on an iPad 2.
- * This might be best used for still images.
+ * "Anisotropic Kuwahara Filtering on the GPU" within the GPU Pro collection. This produces an
+ * oil-painting-like image, but it is extremely computationally expensive, so it can take seconds to
+ * render a frame on an iPad 2. This might be best used for still images.
  */
 public class GPUImageKuwaharaFilter extends GPUImageFilter {
+
     public static final String KUWAHARA_FRAGMENT_SHADER = "" +
             "varying highp vec2 textureCoordinate;\n" +
             "uniform sampler2D inputImageTexture;\n" +
@@ -39,8 +40,10 @@
             "vec2 uv = textureCoordinate;\n" +
             "float n = float((radius + 1) * (radius + 1));\n" +
             "int i; int j;\n" +
-            "vec3 m0 = vec3(0.0); vec3 m1 = vec3(0.0); vec3 m2 = vec3(0.0); vec3 m3 = vec3(0.0);\n" +
-            "vec3 s0 = vec3(0.0); vec3 s1 = vec3(0.0); vec3 s2 = vec3(0.0); vec3 s3 = vec3(0.0);\n" +
+            "vec3 m0 = vec3(0.0); vec3 m1 = vec3(0.0); vec3 m2 = vec3(0.0); vec3 m3 = vec3(0.0);\n"
+            +
+            "vec3 s0 = vec3(0.0); vec3 s1 = vec3(0.0); vec3 s2 = vec3(0.0); vec3 s3 = vec3(0.0);\n"
+            +
             "vec3 c;\n" +
             "\n" +
             "for (j = -radius; j <= 0; ++j)  {\n" +
diff --git a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageLaplacianFilter.java b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageLaplacianFilter.java
index d320f64d..a6150a89 100644
--- a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageLaplacianFilter.java
+++ b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageLaplacianFilter.java
@@ -19,6 +19,7 @@
 import android.opengl.GLES20;
 
 public class GPUImageLaplacianFilter extends GPUImage3x3TextureSamplingFilter {
+
     public static final String LAPLACIAN_FRAGMENT_SHADER = "" +
             "precision highp float;\n" +
             "\n" +
@@ -40,19 +41,28 @@
             "\n" +
             "void main()\n" +
             "{\n" +
-            "mediump vec3 bottomColor = texture2D(inputImageTexture, bottomTextureCoordinate).rgb;\n" +
-            "mediump vec3 bottomLeftColor = texture2D(inputImageTexture, bottomLeftTextureCoordinate).rgb;\n" +
-            "mediump vec3 bottomRightColor = texture2D(inputImageTexture, bottomRightTextureCoordinate).rgb;\n" +
+            "mediump vec3 bottomColor = texture2D(inputImageTexture, bottomTextureCoordinate).rgb;\n"
+            +
+            "mediump vec3 bottomLeftColor = texture2D(inputImageTexture, bottomLeftTextureCoordinate).rgb;\n"
+            +
+            "mediump vec3 bottomRightColor = texture2D(inputImageTexture, bottomRightTextureCoordinate).rgb;\n"
+            +
             "mediump vec4 centerColor = texture2D(inputImageTexture, textureCoordinate);\n" +
             "mediump vec3 leftColor = texture2D(inputImageTexture, leftTextureCoordinate).rgb;\n" +
-            "mediump vec3 rightColor = texture2D(inputImageTexture, rightTextureCoordinate).rgb;\n" +
+            "mediump vec3 rightColor = texture2D(inputImageTexture, rightTextureCoordinate).rgb;\n"
+            +
             "mediump vec3 topColor = texture2D(inputImageTexture, topTextureCoordinate).rgb;\n" +
-            "mediump vec3 topRightColor = texture2D(inputImageTexture, topRightTextureCoordinate).rgb;\n" +
-            "mediump vec3 topLeftColor = texture2D(inputImageTexture, topLeftTextureCoordinate).rgb;\n" +
+            "mediump vec3 topRightColor = texture2D(inputImageTexture, topRightTextureCoordinate).rgb;\n"
+            +
+            "mediump vec3 topLeftColor = texture2D(inputImageTexture, topLeftTextureCoordinate).rgb;\n"
+            +
             "\n" +
-            "mediump vec3 resultColor = topLeftColor * convolutionMatrix[0][0] + topColor * convolutionMatrix[0][1] + topRightColor * convolutionMatrix[0][2];\n" +
-            "resultColor += leftColor * convolutionMatrix[1][0] + centerColor.rgb * convolutionMatrix[1][1] + rightColor * convolutionMatrix[1][2];\n" +
-            "resultColor += bottomLeftColor * convolutionMatrix[2][0] + bottomColor * convolutionMatrix[2][1] + bottomRightColor * convolutionMatrix[2][2];\n" +
+            "mediump vec3 resultColor = topLeftColor * convolutionMatrix[0][0] + topColor * convolutionMatrix[0][1] + topRightColor * convolutionMatrix[0][2];\n"
+            +
+            "resultColor += leftColor * convolutionMatrix[1][0] + centerColor.rgb * convolutionMatrix[1][1] + rightColor * convolutionMatrix[1][2];\n"
+            +
+            "resultColor += bottomLeftColor * convolutionMatrix[2][0] + bottomColor * convolutionMatrix[2][1] + bottomRightColor * convolutionMatrix[2][2];\n"
+            +
             "\n" +
             "// Normalize the results to allow for negative gradients in the 0.0-1.0 colorspace\n" +
             "resultColor = resultColor + 0.5;\n" +
diff --git a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageLevelsFilter.java b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageLevelsFilter.java
index d7fbcfdf..eef708f1 100644
--- a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageLevelsFilter.java
+++ b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageLevelsFilter.java
@@ -6,27 +6,29 @@
 /**
  * Created by vashisthg 30/05/14.
  */
-public class GPUImageLevelsFilter extends GPUImageFilter{
+public class GPUImageLevelsFilter extends GPUImageFilter {
 
     private static final String LOGTAG = GPUImageLevelsFilter.class.getSimpleName();
 
     public static final String LEVELS_FRAGMET_SHADER =
 
             " varying highp vec2 textureCoordinate;\n" +
-            " \n" +
-            " uniform sampler2D inputImageTexture;\n" +
-            " uniform mediump vec3 levelMinimum;\n" +
-            " uniform mediump vec3 levelMiddle;\n" +
-            " uniform mediump vec3 levelMaximum;\n" +
-            " uniform mediump vec3 minOutput;\n" +
-            " uniform mediump vec3 maxOutput;\n" +
-            " \n" +
-            " void main()\n" +
-            " {\n" +
-            "     mediump vec4 textureColor = texture2D(inputImageTexture, textureCoordinate);\n" +
-            "     \n" +
-            "     gl_FragColor = vec4( mix(minOutput, maxOutput, pow(min(max(textureColor.rgb -levelMinimum, vec3(0.0)) / (levelMaximum - levelMinimum  ), vec3(1.0)), 1.0 /levelMiddle)) , textureColor.a);\n" +
-            " }\n";
+                    " \n" +
+                    " uniform sampler2D inputImageTexture;\n" +
+                    " uniform mediump vec3 levelMinimum;\n" +
+                    " uniform mediump vec3 levelMiddle;\n" +
+                    " uniform mediump vec3 levelMaximum;\n" +
+                    " uniform mediump vec3 minOutput;\n" +
+                    " uniform mediump vec3 maxOutput;\n" +
+                    " \n" +
+                    " void main()\n" +
+                    " {\n" +
+                    "     mediump vec4 textureColor = texture2D(inputImageTexture, textureCoordinate);\n"
+                    +
+                    "     \n" +
+                    "     gl_FragColor = vec4( mix(minOutput, maxOutput, pow(min(max(textureColor.rgb -levelMinimum, vec3(0.0)) / (levelMaximum - levelMinimum  ), vec3(1.0)), 1.0 /levelMiddle)) , textureColor.a);\n"
+                    +
+                    " }\n";
 
     private int mMinLocation;
     private float[] mMin;
@@ -40,10 +42,13 @@
     private float[] mMaxOutput;
 
     public GPUImageLevelsFilter() {
-        this(new float[] {0.0f,0.0f,0.0f}, new float[] {1.0f, 1.0f, 1.0f }, new float[] {1.0f, 1.0f ,1.0f}, new float[] {0.0f, 0.0f, 0.0f}, new float[] {1.0f,1.0f,1.0f});
+        this(new float[]{0.0f, 0.0f, 0.0f}, new float[]{1.0f, 1.0f, 1.0f},
+                new float[]{1.0f, 1.0f, 1.0f}, new float[]{0.0f, 0.0f, 0.0f},
+                new float[]{1.0f, 1.0f, 1.0f});
     }
 
-    private GPUImageLevelsFilter(final float[] min, final float[] mid, final float[] max, final float[] minOUt, final float[] maxOut) {
+    private GPUImageLevelsFilter(final float[] min, final float[] mid, final float[] max,
+                                 final float[] minOUt, final float[] maxOut) {
         super(NO_FILTER_VERTEX_SHADER, LEVELS_FRAGMET_SHADER);
 
         mMin = min;
@@ -70,8 +75,7 @@ public void onInitialized() {
         updateUniforms();
     }
 
-
-    public void updateUniforms () {
+    public void updateUniforms() {
         setFloatVec3(mMinLocation, mMin);
         setFloatVec3(mMidLocation, mMid);
         setFloatVec3(mMaxLocation, mMax);
@@ -79,17 +83,17 @@ public void updateUniforms () {
         setFloatVec3(mMaxOutputLocation, mMaxOutput);
     }
 
-    public void setMin(float min, float mid , float max ,float minOut , float maxOut) {
+    public void setMin(float min, float mid, float max, float minOut, float maxOut) {
         setRedMin(min, mid, max, minOut, maxOut);
         setGreenMin(min, mid, max, minOut, maxOut);
         setBlueMin(min, mid, max, minOut, maxOut);
     }
 
-    public void setMin(float min, float mid , float max ) {
+    public void setMin(float min, float mid, float max) {
         setMin(min, mid, max, 0.0f, 1.0f);
     }
 
-    public void setRedMin(float min, float mid , float max ,float minOut , float maxOut) {
+    public void setRedMin(float min, float mid, float max, float minOut, float maxOut) {
         mMin[0] = min;
         mMid[0] = mid;
         mMax[0] = max;
@@ -98,11 +102,11 @@ public void setRedMin(float min, float mid , float max ,float minOut , float max
         updateUniforms();
     }
 
-    public void setRedMin(float min, float mid , float max ){
+    public void setRedMin(float min, float mid, float max) {
         setRedMin(min, mid, max, 0, 1);
     }
 
-    public void setGreenMin(float min, float mid , float max ,float minOut , float maxOut) {
+    public void setGreenMin(float min, float mid, float max, float minOut, float maxOut) {
         mMin[1] = min;
         mMid[1] = mid;
         mMax[1] = max;
@@ -111,11 +115,11 @@ public void setGreenMin(float min, float mid , float max ,float minOut , float m
         updateUniforms();
     }
 
-    public void setGreenMin(float min, float mid , float max ){
+    public void setGreenMin(float min, float mid, float max) {
         setGreenMin(min, mid, max, 0, 1);
     }
 
-    public void setBlueMin(float min, float mid , float max ,float minOut , float maxOut) {
+    public void setBlueMin(float min, float mid, float max, float minOut, float maxOut) {
         mMin[2] = min;
         mMid[2] = mid;
         mMax[2] = max;
@@ -124,7 +128,7 @@ public void setBlueMin(float min, float mid , float max ,float minOut , float ma
         updateUniforms();
     }
 
-    public void setBlueMin(float min, float mid , float max ){
+    public void setBlueMin(float min, float mid, float max) {
         setBlueMin(min, mid, max, 0, 1);
     }
 }
diff --git a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageLightenBlendFilter.java b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageLightenBlendFilter.java
index 77399cb1..2c2fc37b 100644
--- a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageLightenBlendFilter.java
+++ b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageLightenBlendFilter.java
@@ -17,19 +17,23 @@
 package jp.co.cyberagent.android.gpuimage;
 
 public class GPUImageLightenBlendFilter extends GPUImageTwoInputFilter {
-    public static final String LIGHTEN_BLEND_FRAGMENT_SHADER = "varying highp vec2 textureCoordinate;\n" +
-            " varying highp vec2 textureCoordinate2;\n" +
-            "\n" +
-            " uniform sampler2D inputImageTexture;\n" +
-            " uniform sampler2D inputImageTexture2;\n" +
-            " \n" +
-            " void main()\n" +
-            " {\n" +
-            "    lowp vec4 textureColor = texture2D(inputImageTexture, textureCoordinate);\n" +
-            "    lowp vec4 textureColor2 = texture2D(inputImageTexture2, textureCoordinate2);\n" +
-            "    \n" +
-            "    gl_FragColor = max(textureColor, textureColor2);\n" +
-            " }";
+
+    public static final String LIGHTEN_BLEND_FRAGMENT_SHADER =
+            "varying highp vec2 textureCoordinate;\n" +
+                    " varying highp vec2 textureCoordinate2;\n" +
+                    "\n" +
+                    " uniform sampler2D inputImageTexture;\n" +
+                    " uniform sampler2D inputImageTexture2;\n" +
+                    " \n" +
+                    " void main()\n" +
+                    " {\n" +
+                    "    lowp vec4 textureColor = texture2D(inputImageTexture, textureCoordinate);\n"
+                    +
+                    "    lowp vec4 textureColor2 = texture2D(inputImageTexture2, textureCoordinate2);\n"
+                    +
+                    "    \n" +
+                    "    gl_FragColor = max(textureColor, textureColor2);\n" +
+                    " }";
 
     public GPUImageLightenBlendFilter() {
         super(LIGHTEN_BLEND_FRAGMENT_SHADER);
diff --git a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageLinearBurnBlendFilter.java b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageLinearBurnBlendFilter.java
index 2623b528..e13de934 100644
--- a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageLinearBurnBlendFilter.java
+++ b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageLinearBurnBlendFilter.java
@@ -17,19 +17,24 @@
 package jp.co.cyberagent.android.gpuimage;
 
 public class GPUImageLinearBurnBlendFilter extends GPUImageTwoInputFilter {
-    public static final String LINEAR_BURN_BLEND_FRAGMENT_SHADER = "varying highp vec2 textureCoordinate;\n" +
-            " varying highp vec2 textureCoordinate2;\n" +
-            " \n" +
-            " uniform sampler2D inputImageTexture;\n" +
-            " uniform sampler2D inputImageTexture2;\n" +
-            " \n" +
-            " void main()\n" +
-            " {\n" +
-            "     mediump vec4 textureColor = texture2D(inputImageTexture, textureCoordinate);\n" +
-            "     mediump vec4 textureColor2 = texture2D(inputImageTexture2, textureCoordinate2);\n" +
-            "     \n" +
-            "     gl_FragColor = vec4(clamp(textureColor.rgb + textureColor2.rgb - vec3(1.0), vec3(0.0), vec3(1.0)), textureColor.a);\n" +
-            " }";
+
+    public static final String LINEAR_BURN_BLEND_FRAGMENT_SHADER =
+            "varying highp vec2 textureCoordinate;\n" +
+                    " varying highp vec2 textureCoordinate2;\n" +
+                    " \n" +
+                    " uniform sampler2D inputImageTexture;\n" +
+                    " uniform sampler2D inputImageTexture2;\n" +
+                    " \n" +
+                    " void main()\n" +
+                    " {\n" +
+                    "     mediump vec4 textureColor = texture2D(inputImageTexture, textureCoordinate);\n"
+                    +
+                    "     mediump vec4 textureColor2 = texture2D(inputImageTexture2, textureCoordinate2);\n"
+                    +
+                    "     \n" +
+                    "     gl_FragColor = vec4(clamp(textureColor.rgb + textureColor2.rgb - vec3(1.0), vec3(0.0), vec3(1.0)), textureColor.a);\n"
+                    +
+                    " }";
 
     public GPUImageLinearBurnBlendFilter() {
         super(LINEAR_BURN_BLEND_FRAGMENT_SHADER);
diff --git a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageLookupFilter.java b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageLookupFilter.java
index 42c9ebdc..fda82de5 100644
--- a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageLookupFilter.java
+++ b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageLookupFilter.java
@@ -43,18 +43,23 @@
             "     quad2.x = ceil(blueColor) - (quad2.y * 8.0);\n" +
             "     \n" +
             "     highp vec2 texPos1;\n" +
-            "     texPos1.x = (quad1.x * 0.125) + 0.5/512.0 + ((0.125 - 1.0/512.0) * textureColor.r);\n" +
-            "     texPos1.y = (quad1.y * 0.125) + 0.5/512.0 + ((0.125 - 1.0/512.0) * textureColor.g);\n" +
+            "     texPos1.x = (quad1.x * 0.125) + 0.5/512.0 + ((0.125 - 1.0/512.0) * textureColor.r);\n"
+            +
+            "     texPos1.y = (quad1.y * 0.125) + 0.5/512.0 + ((0.125 - 1.0/512.0) * textureColor.g);\n"
+            +
             "     \n" +
             "     highp vec2 texPos2;\n" +
-            "     texPos2.x = (quad2.x * 0.125) + 0.5/512.0 + ((0.125 - 1.0/512.0) * textureColor.r);\n" +
-            "     texPos2.y = (quad2.y * 0.125) + 0.5/512.0 + ((0.125 - 1.0/512.0) * textureColor.g);\n" +
+            "     texPos2.x = (quad2.x * 0.125) + 0.5/512.0 + ((0.125 - 1.0/512.0) * textureColor.r);\n"
+            +
+            "     texPos2.y = (quad2.y * 0.125) + 0.5/512.0 + ((0.125 - 1.0/512.0) * textureColor.g);\n"
+            +
             "     \n" +
             "     lowp vec4 newColor1 = texture2D(inputImageTexture2, texPos1);\n" +
             "     lowp vec4 newColor2 = texture2D(inputImageTexture2, texPos2);\n" +
             "     \n" +
             "     lowp vec4 newColor = mix(newColor1, newColor2, fract(blueColor));\n" +
-            "     gl_FragColor = mix(textureColor, vec4(newColor.rgb, textureColor.w), intensity);\n" +
+            "     gl_FragColor = mix(textureColor, vec4(newColor.rgb, textureColor.w), intensity);\n"
+            +
             " }";
 
     private int mIntensityLocation;
diff --git a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageLuminosityBlendFilter.java b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageLuminosityBlendFilter.java
index 85e7bfda..dc4f3910 100644
--- a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageLuminosityBlendFilter.java
+++ b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageLuminosityBlendFilter.java
@@ -17,48 +17,52 @@
 package jp.co.cyberagent.android.gpuimage;
 
 public class GPUImageLuminosityBlendFilter extends GPUImageTwoInputFilter {
-    public static final String LUMINOSITY_BLEND_FRAGMENT_SHADER = "varying highp vec2 textureCoordinate;\n" +
-            " varying highp vec2 textureCoordinate2;\n" +
-            " \n" +
-            " uniform sampler2D inputImageTexture;\n" +
-            " uniform sampler2D inputImageTexture2;\n" +
-            " \n" +
-            " highp float lum(lowp vec3 c) {\n" +
-            "     return dot(c, vec3(0.3, 0.59, 0.11));\n" +
-            " }\n" +
-            " \n" +
-            " lowp vec3 clipcolor(lowp vec3 c) {\n" +
-            "     highp float l = lum(c);\n" +
-            "     lowp float n = min(min(c.r, c.g), c.b);\n" +
-            "     lowp float x = max(max(c.r, c.g), c.b);\n" +
-            "     \n" +
-            "     if (n < 0.0) {\n" +
-            "         c.r = l + ((c.r - l) * l) / (l - n);\n" +
-            "         c.g = l + ((c.g - l) * l) / (l - n);\n" +
-            "         c.b = l + ((c.b - l) * l) / (l - n);\n" +
-            "     }\n" +
-            "     if (x > 1.0) {\n" +
-            "         c.r = l + ((c.r - l) * (1.0 - l)) / (x - l);\n" +
-            "         c.g = l + ((c.g - l) * (1.0 - l)) / (x - l);\n" +
-            "         c.b = l + ((c.b - l) * (1.0 - l)) / (x - l);\n" +
-            "     }\n" +
-            "     \n" +
-            "     return c;\n" +
-            " }\n" +
-            " \n" +
-            " lowp vec3 setlum(lowp vec3 c, highp float l) {\n" +
-            "     highp float d = l - lum(c);\n" +
-            "     c = c + vec3(d);\n" +
-            "     return clipcolor(c);\n" +
-            " }\n" +
-            " \n" +
-            " void main()\n" +
-            " {\n" +
-            "   highp vec4 baseColor = texture2D(inputImageTexture, textureCoordinate);\n" +
-            "   highp vec4 overlayColor = texture2D(inputImageTexture2, textureCoordinate2);\n" +
-            "     \n" +
-            "     gl_FragColor = vec4(baseColor.rgb * (1.0 - overlayColor.a) + setlum(baseColor.rgb, lum(overlayColor.rgb)) * overlayColor.a, baseColor.a);\n" +
-            " }";
+
+    public static final String LUMINOSITY_BLEND_FRAGMENT_SHADER =
+            "varying highp vec2 textureCoordinate;\n" +
+                    " varying highp vec2 textureCoordinate2;\n" +
+                    " \n" +
+                    " uniform sampler2D inputImageTexture;\n" +
+                    " uniform sampler2D inputImageTexture2;\n" +
+                    " \n" +
+                    " highp float lum(lowp vec3 c) {\n" +
+                    "     return dot(c, vec3(0.3, 0.59, 0.11));\n" +
+                    " }\n" +
+                    " \n" +
+                    " lowp vec3 clipcolor(lowp vec3 c) {\n" +
+                    "     highp float l = lum(c);\n" +
+                    "     lowp float n = min(min(c.r, c.g), c.b);\n" +
+                    "     lowp float x = max(max(c.r, c.g), c.b);\n" +
+                    "     \n" +
+                    "     if (n < 0.0) {\n" +
+                    "         c.r = l + ((c.r - l) * l) / (l - n);\n" +
+                    "         c.g = l + ((c.g - l) * l) / (l - n);\n" +
+                    "         c.b = l + ((c.b - l) * l) / (l - n);\n" +
+                    "     }\n" +
+                    "     if (x > 1.0) {\n" +
+                    "         c.r = l + ((c.r - l) * (1.0 - l)) / (x - l);\n" +
+                    "         c.g = l + ((c.g - l) * (1.0 - l)) / (x - l);\n" +
+                    "         c.b = l + ((c.b - l) * (1.0 - l)) / (x - l);\n" +
+                    "     }\n" +
+                    "     \n" +
+                    "     return c;\n" +
+                    " }\n" +
+                    " \n" +
+                    " lowp vec3 setlum(lowp vec3 c, highp float l) {\n" +
+                    "     highp float d = l - lum(c);\n" +
+                    "     c = c + vec3(d);\n" +
+                    "     return clipcolor(c);\n" +
+                    " }\n" +
+                    " \n" +
+                    " void main()\n" +
+                    " {\n" +
+                    "   highp vec4 baseColor = texture2D(inputImageTexture, textureCoordinate);\n" +
+                    "   highp vec4 overlayColor = texture2D(inputImageTexture2, textureCoordinate2);\n"
+                    +
+                    "     \n" +
+                    "     gl_FragColor = vec4(baseColor.rgb * (1.0 - overlayColor.a) + setlum(baseColor.rgb, lum(overlayColor.rgb)) * overlayColor.a, baseColor.a);\n"
+                    +
+                    " }";
 
     public GPUImageLuminosityBlendFilter() {
         super(LUMINOSITY_BLEND_FRAGMENT_SHADER);
diff --git a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageMixBlendFilter.java b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageMixBlendFilter.java
index 7bf68859..b574ad58 100644
--- a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageMixBlendFilter.java
+++ b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageMixBlendFilter.java
@@ -45,7 +45,8 @@ public void onInitialized() {
     }
 
     /**
-     * @param mix ranges from 0.0 (only image 1) to 1.0 (only image 2), with 0.5 (half of either) as the normal level
+     * @param mix ranges from 0.0 (only image 1) to 1.0 (only image 2), with 0.5 (half of either) as
+     * the normal level
      */
     public void setMix(final float mix) {
         mMix = mix;
diff --git a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageMonochromeFilter.java b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageMonochromeFilter.java
index e426a340..ea32a11b 100644
--- a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageMonochromeFilter.java
+++ b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageMonochromeFilter.java
@@ -19,11 +19,13 @@
 import android.opengl.GLES20;
 
 /**
- * Converts the image to a single-color version, based on the luminance of each pixel
- * intensity: The degree to which the specific color replaces the normal image color (0.0 - 1.0, with 1.0 as the default)
- * color: The color to use as the basis for the effect, with (0.6, 0.45, 0.3, 1.0) as the default.
+ * Converts the image to a single-color version, based on the luminance of each pixel intensity: The
+ * degree to which the specific color replaces the normal image color (0.0 - 1.0, with 1.0 as the
+ * default) color: The color to use as the basis for the effect, with (0.6, 0.45, 0.3, 1.0) as the
+ * default.
  */
 public class GPUImageMonochromeFilter extends GPUImageFilter {
+
     public static final String MONOCHROME_FRAGMENT_SHADER = "" +
             " precision lowp float;\n" +
             "  \n" +
@@ -45,14 +47,18 @@
             " 	\n" +
             " 	//overlay\n" +
             " 	lowp vec4 outputColor = vec4(\n" +
-            "                                  (desat.r < 0.5 ? (2.0 * desat.r * filterColor.r) : (1.0 - 2.0 * (1.0 - desat.r) * (1.0 - filterColor.r))),\n" +
-            "                                  (desat.g < 0.5 ? (2.0 * desat.g * filterColor.g) : (1.0 - 2.0 * (1.0 - desat.g) * (1.0 - filterColor.g))),\n" +
-            "                                  (desat.b < 0.5 ? (2.0 * desat.b * filterColor.b) : (1.0 - 2.0 * (1.0 - desat.b) * (1.0 - filterColor.b))),\n" +
+            "                                  (desat.r < 0.5 ? (2.0 * desat.r * filterColor.r) : (1.0 - 2.0 * (1.0 - desat.r) * (1.0 - filterColor.r))),\n"
+            +
+            "                                  (desat.g < 0.5 ? (2.0 * desat.g * filterColor.g) : (1.0 - 2.0 * (1.0 - desat.g) * (1.0 - filterColor.g))),\n"
+            +
+            "                                  (desat.b < 0.5 ? (2.0 * desat.b * filterColor.b) : (1.0 - 2.0 * (1.0 - desat.b) * (1.0 - filterColor.b))),\n"
+            +
             "                                  1.0\n" +
             "                                  );\n" +
             " 	\n" +
             " 	//which is better, or are they equal?\n" +
-            " 	gl_FragColor = vec4( mix(textureColor.rgb, outputColor.rgb, intensity), textureColor.a);\n" +
+            " 	gl_FragColor = vec4( mix(textureColor.rgb, outputColor.rgb, intensity), textureColor.a);\n"
+            +
             "  }";
 
     private int mIntensityLocation;
@@ -61,7 +67,7 @@
     private float[] mColor;
 
     public GPUImageMonochromeFilter() {
-        this(1.0f, new float[] {0.6f, 0.45f, 0.3f, 1.0f});
+        this(1.0f, new float[]{0.6f, 0.45f, 0.3f, 1.0f});
     }
 
     public GPUImageMonochromeFilter(final float intensity, final float[] color) {
@@ -81,21 +87,20 @@ public void onInit() {
     public void onInitialized() {
         super.onInitialized();
         setIntensity(1.0f);
-        setColor(new float[]{ 0.6f, 0.45f, 0.3f, 1.f });
+        setColor(new float[]{0.6f, 0.45f, 0.3f, 1.f});
     }
 
     public void setIntensity(final float intensity) {
         mIntensity = intensity;
         setFloat(mIntensityLocation, mIntensity);
     }
-    
+
     public void setColor(final float[] color) {
         mColor = color;
         setColorRed(mColor[0], mColor[1], mColor[2]);
-        
     }
-    
+
     public void setColorRed(final float red, final float green, final float blue) {
-        setFloatVec3(mFilterColorLocation, new float[]{ red, green, blue });
+        setFloatVec3(mFilterColorLocation, new float[]{red, green, blue});
     }
 }
diff --git a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageMultiplyBlendFilter.java b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageMultiplyBlendFilter.java
index 1e002e36..42f81e8c 100644
--- a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageMultiplyBlendFilter.java
+++ b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageMultiplyBlendFilter.java
@@ -17,19 +17,23 @@
 package jp.co.cyberagent.android.gpuimage;
 
 public class GPUImageMultiplyBlendFilter extends GPUImageTwoInputFilter {
-    public static final String MULTIPLY_BLEND_FRAGMENT_SHADER = "varying highp vec2 textureCoordinate;\n" +
-            " varying highp vec2 textureCoordinate2;\n" +
-            "\n" +
-            " uniform sampler2D inputImageTexture;\n" +
-            " uniform sampler2D inputImageTexture2;\n" +
-            " \n" +
-            " void main()\n" +
-            " {\n" +
-            "     lowp vec4 base = texture2D(inputImageTexture, textureCoordinate);\n" +
-            "     lowp vec4 overlayer = texture2D(inputImageTexture2, textureCoordinate2);\n" +
-            "          \n" +
-            "     gl_FragColor = overlayer * base + overlayer * (1.0 - base.a) + base * (1.0 - overlayer.a);\n" +
-            " }";
+
+    public static final String MULTIPLY_BLEND_FRAGMENT_SHADER =
+            "varying highp vec2 textureCoordinate;\n" +
+                    " varying highp vec2 textureCoordinate2;\n" +
+                    "\n" +
+                    " uniform sampler2D inputImageTexture;\n" +
+                    " uniform sampler2D inputImageTexture2;\n" +
+                    " \n" +
+                    " void main()\n" +
+                    " {\n" +
+                    "     lowp vec4 base = texture2D(inputImageTexture, textureCoordinate);\n" +
+                    "     lowp vec4 overlayer = texture2D(inputImageTexture2, textureCoordinate2);\n"
+                    +
+                    "          \n" +
+                    "     gl_FragColor = overlayer * base + overlayer * (1.0 - base.a) + base * (1.0 - overlayer.a);\n"
+                    +
+                    " }";
 
     public GPUImageMultiplyBlendFilter() {
         super(MULTIPLY_BLEND_FRAGMENT_SHADER);
diff --git a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageNativeLibrary.java b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageNativeLibrary.java
index ce8c31b8..d9501c07 100644
--- a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageNativeLibrary.java
+++ b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageNativeLibrary.java
@@ -17,6 +17,7 @@
 package jp.co.cyberagent.android.gpuimage;
 
 public class GPUImageNativeLibrary {
+
     static {
         System.loadLibrary("gpuimage-library");
     }
diff --git a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageNonMaximumSuppressionFilter.java b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageNonMaximumSuppressionFilter.java
index a6f5af48..0d79e619 100644
--- a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageNonMaximumSuppressionFilter.java
+++ b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageNonMaximumSuppressionFilter.java
@@ -17,6 +17,7 @@
 package jp.co.cyberagent.android.gpuimage;
 
 public class GPUImageNonMaximumSuppressionFilter extends GPUImage3x3TextureSamplingFilter {
+
     public static final String NMS_FRAGMENT_SHADER = "" +
             "uniform sampler2D inputImageTexture;\n" +
             "\n" +
@@ -35,14 +36,18 @@
             "void main()\n" +
             "{\n" +
             "lowp float bottomColor = texture2D(inputImageTexture, bottomTextureCoordinate).r;\n" +
-            "lowp float bottomLeftColor = texture2D(inputImageTexture, bottomLeftTextureCoordinate).r;\n" +
-            "lowp float bottomRightColor = texture2D(inputImageTexture, bottomRightTextureCoordinate).r;\n" +
+            "lowp float bottomLeftColor = texture2D(inputImageTexture, bottomLeftTextureCoordinate).r;\n"
+            +
+            "lowp float bottomRightColor = texture2D(inputImageTexture, bottomRightTextureCoordinate).r;\n"
+            +
             "lowp vec4 centerColor = texture2D(inputImageTexture, textureCoordinate);\n" +
             "lowp float leftColor = texture2D(inputImageTexture, leftTextureCoordinate).r;\n" +
             "lowp float rightColor = texture2D(inputImageTexture, rightTextureCoordinate).r;\n" +
             "lowp float topColor = texture2D(inputImageTexture, topTextureCoordinate).r;\n" +
-            "lowp float topRightColor = texture2D(inputImageTexture, topRightTextureCoordinate).r;\n" +
-            "lowp float topLeftColor = texture2D(inputImageTexture, topLeftTextureCoordinate).r;\n" +
+            "lowp float topRightColor = texture2D(inputImageTexture, topRightTextureCoordinate).r;\n"
+            +
+            "lowp float topLeftColor = texture2D(inputImageTexture, topLeftTextureCoordinate).r;\n"
+            +
             "\n" +
             "// Use a tiebreaker for pixels to the left and immediately above this one\n" +
             "lowp float multiplier = 1.0 - step(centerColor.r, topColor);\n" +
@@ -55,7 +60,8 @@
             "maxValue = max(maxValue, rightColor);\n" +
             "maxValue = max(maxValue, topRightColor);\n" +
             "\n" +
-            "gl_FragColor = vec4((centerColor.rgb * step(maxValue, centerColor.r) * multiplier), 1.0);\n" +
+            "gl_FragColor = vec4((centerColor.rgb * step(maxValue, centerColor.r) * multiplier), 1.0);\n"
+            +
             "}\n";
 
     public GPUImageNonMaximumSuppressionFilter() {
diff --git a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageNormalBlendFilter.java b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageNormalBlendFilter.java
index a886bd40..78133900 100644
--- a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageNormalBlendFilter.java
+++ b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageNormalBlendFilter.java
@@ -17,43 +17,46 @@
 package jp.co.cyberagent.android.gpuimage;
 
 /**
- * This equation is a simplification of the general blending equation. It assumes the destination color is opaque, and therefore drops the destination color's alpha term.
+ * This equation is a simplification of the general blending equation. It assumes the destination
+ * color is opaque, and therefore drops the destination color's alpha term.
  *
- * D = C1 * C1a + C2 * C2a * (1 - C1a)
- * where D is the resultant color, C1 is the color of the first element, C1a is the alpha of the first element, C2 is the second element color, C2a is the alpha of the second element. The destination alpha is calculated with:
+ * D = C1 * C1a + C2 * C2a * (1 - C1a) where D is the resultant color, C1 is the color of the first
+ * element, C1a is the alpha of the first element, C2 is the second element color, C2a is the alpha
+ * of the second element. The destination alpha is calculated with:
  *
- * Da = C1a + C2a * (1 - C1a)
- * The resultant color is premultiplied with the alpha. To restore the color to the unmultiplied values, just divide by Da, the resultant alpha.
+ * Da = C1a + C2a * (1 - C1a) The resultant color is premultiplied with the alpha. To restore the
+ * color to the unmultiplied values, just divide by Da, the resultant alpha.
  *
  * http://stackoverflow.com/questions/1724946/blend-mode-on-a-transparent-and-semi-transparent-background
  *
- * For some reason Photoshop behaves
- * D = C1 + C2 * C2a * (1 - C1a)
+ * For some reason Photoshop behaves D = C1 + C2 * C2a * (1 - C1a)
  */
 public class GPUImageNormalBlendFilter extends GPUImageTwoInputFilter {
-    public static final String NORMAL_BLEND_FRAGMENT_SHADER = "varying highp vec2 textureCoordinate;\n" +
-            " varying highp vec2 textureCoordinate2;\n" +
-            " \n" +
-            " uniform sampler2D inputImageTexture;\n" +
-            " uniform sampler2D inputImageTexture2;\n" +
-            " \n" +
-            " void main()\n" +
-            " {\n" +
-            "     lowp vec4 c2 = texture2D(inputImageTexture, textureCoordinate);\n" +
-            "\t lowp vec4 c1 = texture2D(inputImageTexture2, textureCoordinate2);\n" +
-            "     \n" +
-            "     lowp vec4 outputColor;\n" +
-            "     \n" +
-            "     outputColor.r = c1.r + c2.r * c2.a * (1.0 - c1.a);\n" +
-            "\n" +
-            "     outputColor.g = c1.g + c2.g * c2.a * (1.0 - c1.a);\n" +
-            "     \n" +
-            "     outputColor.b = c1.b + c2.b * c2.a * (1.0 - c1.a);\n" +
-            "     \n" +
-            "     outputColor.a = c1.a + c2.a * (1.0 - c1.a);\n" +
-            "     \n" +
-            "     gl_FragColor = outputColor;\n" +
-            " }";
+
+    public static final String NORMAL_BLEND_FRAGMENT_SHADER =
+            "varying highp vec2 textureCoordinate;\n" +
+                    " varying highp vec2 textureCoordinate2;\n" +
+                    " \n" +
+                    " uniform sampler2D inputImageTexture;\n" +
+                    " uniform sampler2D inputImageTexture2;\n" +
+                    " \n" +
+                    " void main()\n" +
+                    " {\n" +
+                    "     lowp vec4 c2 = texture2D(inputImageTexture, textureCoordinate);\n" +
+                    "\t lowp vec4 c1 = texture2D(inputImageTexture2, textureCoordinate2);\n" +
+                    "     \n" +
+                    "     lowp vec4 outputColor;\n" +
+                    "     \n" +
+                    "     outputColor.r = c1.r + c2.r * c2.a * (1.0 - c1.a);\n" +
+                    "\n" +
+                    "     outputColor.g = c1.g + c2.g * c2.a * (1.0 - c1.a);\n" +
+                    "     \n" +
+                    "     outputColor.b = c1.b + c2.b * c2.a * (1.0 - c1.a);\n" +
+                    "     \n" +
+                    "     outputColor.a = c1.a + c2.a * (1.0 - c1.a);\n" +
+                    "     \n" +
+                    "     gl_FragColor = outputColor;\n" +
+                    " }";
 
     public GPUImageNormalBlendFilter() {
         super(NORMAL_BLEND_FRAGMENT_SHADER);
diff --git a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageOpacityFilter.java b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageOpacityFilter.java
index 55f198d1..2f93fb4e 100644
--- a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageOpacityFilter.java
+++ b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageOpacityFilter.java
@@ -19,10 +19,11 @@
 import android.opengl.GLES20;
 
 /**
- * Adjusts the alpha channel of the incoming image
- * opacity: The value to multiply the incoming alpha channel for each pixel by (0.0 - 1.0, with 1.0 as the default)
-*/
+ * Adjusts the alpha channel of the incoming image opacity: The value to multiply the incoming alpha
+ * channel for each pixel by (0.0 - 1.0, with 1.0 as the default)
+ */
 public class GPUImageOpacityFilter extends GPUImageFilter {
+
     public static final String OPACITY_FRAGMENT_SHADER = "" +
             "  varying highp vec2 textureCoordinate;\n" +
             "  \n" +
diff --git a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageOverlayBlendFilter.java b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageOverlayBlendFilter.java
index 4dba4200..924cb6cf 100644
--- a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageOverlayBlendFilter.java
+++ b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageOverlayBlendFilter.java
@@ -17,40 +17,49 @@
 package jp.co.cyberagent.android.gpuimage;
 
 public class GPUImageOverlayBlendFilter extends GPUImageTwoInputFilter {
-    public static final String OVERLAY_BLEND_FRAGMENT_SHADER = "varying highp vec2 textureCoordinate;\n" +
-            " varying highp vec2 textureCoordinate2;\n" +
-            "\n" +
-            " uniform sampler2D inputImageTexture;\n" +
-            " uniform sampler2D inputImageTexture2;\n" +
-            " \n" +
-            " void main()\n" +
-            " {\n" +
-            "     mediump vec4 base = texture2D(inputImageTexture, textureCoordinate);\n" +
-            "     mediump vec4 overlay = texture2D(inputImageTexture2, textureCoordinate2);\n" +
-            "     \n" +
-            "     mediump float ra;\n" +
-            "     if (2.0 * base.r < base.a) {\n" +
-            "         ra = 2.0 * overlay.r * base.r + overlay.r * (1.0 - base.a) + base.r * (1.0 - overlay.a);\n" +
-            "     } else {\n" +
-            "         ra = overlay.a * base.a - 2.0 * (base.a - base.r) * (overlay.a - overlay.r) + overlay.r * (1.0 - base.a) + base.r * (1.0 - overlay.a);\n" +
-            "     }\n" +
-            "     \n" +
-            "     mediump float ga;\n" +
-            "     if (2.0 * base.g < base.a) {\n" +
-            "         ga = 2.0 * overlay.g * base.g + overlay.g * (1.0 - base.a) + base.g * (1.0 - overlay.a);\n" +
-            "     } else {\n" +
-            "         ga = overlay.a * base.a - 2.0 * (base.a - base.g) * (overlay.a - overlay.g) + overlay.g * (1.0 - base.a) + base.g * (1.0 - overlay.a);\n" +
-            "     }\n" +
-            "     \n" +
-            "     mediump float ba;\n" +
-            "     if (2.0 * base.b < base.a) {\n" +
-            "         ba = 2.0 * overlay.b * base.b + overlay.b * (1.0 - base.a) + base.b * (1.0 - overlay.a);\n" +
-            "     } else {\n" +
-            "         ba = overlay.a * base.a - 2.0 * (base.a - base.b) * (overlay.a - overlay.b) + overlay.b * (1.0 - base.a) + base.b * (1.0 - overlay.a);\n" +
-            "     }\n" +
-            "     \n" +
-            "     gl_FragColor = vec4(ra, ga, ba, 1.0);\n" +
-            " }";
+
+    public static final String OVERLAY_BLEND_FRAGMENT_SHADER =
+            "varying highp vec2 textureCoordinate;\n" +
+                    " varying highp vec2 textureCoordinate2;\n" +
+                    "\n" +
+                    " uniform sampler2D inputImageTexture;\n" +
+                    " uniform sampler2D inputImageTexture2;\n" +
+                    " \n" +
+                    " void main()\n" +
+                    " {\n" +
+                    "     mediump vec4 base = texture2D(inputImageTexture, textureCoordinate);\n" +
+                    "     mediump vec4 overlay = texture2D(inputImageTexture2, textureCoordinate2);\n"
+                    +
+                    "     \n" +
+                    "     mediump float ra;\n" +
+                    "     if (2.0 * base.r < base.a) {\n" +
+                    "         ra = 2.0 * overlay.r * base.r + overlay.r * (1.0 - base.a) + base.r * (1.0 - overlay.a);\n"
+                    +
+                    "     } else {\n" +
+                    "         ra = overlay.a * base.a - 2.0 * (base.a - base.r) * (overlay.a - overlay.r) + overlay.r * (1.0 - base.a) + base.r * (1.0 - overlay.a);\n"
+                    +
+                    "     }\n" +
+                    "     \n" +
+                    "     mediump float ga;\n" +
+                    "     if (2.0 * base.g < base.a) {\n" +
+                    "         ga = 2.0 * overlay.g * base.g + overlay.g * (1.0 - base.a) + base.g * (1.0 - overlay.a);\n"
+                    +
+                    "     } else {\n" +
+                    "         ga = overlay.a * base.a - 2.0 * (base.a - base.g) * (overlay.a - overlay.g) + overlay.g * (1.0 - base.a) + base.g * (1.0 - overlay.a);\n"
+                    +
+                    "     }\n" +
+                    "     \n" +
+                    "     mediump float ba;\n" +
+                    "     if (2.0 * base.b < base.a) {\n" +
+                    "         ba = 2.0 * overlay.b * base.b + overlay.b * (1.0 - base.a) + base.b * (1.0 - overlay.a);\n"
+                    +
+                    "     } else {\n" +
+                    "         ba = overlay.a * base.a - 2.0 * (base.a - base.b) * (overlay.a - overlay.b) + overlay.b * (1.0 - base.a) + base.b * (1.0 - overlay.a);\n"
+                    +
+                    "     }\n" +
+                    "     \n" +
+                    "     gl_FragColor = vec4(ra, ga, ba, 1.0);\n" +
+                    " }";
 
     public GPUImageOverlayBlendFilter() {
         super(OVERLAY_BLEND_FRAGMENT_SHADER);
diff --git a/library/src/jp/co/cyberagent/android/gpuimage/GPUImagePixelationFilter.java b/library/src/jp/co/cyberagent/android/gpuimage/GPUImagePixelationFilter.java
index c0ec15d1..2267831d 100644
--- a/library/src/jp/co/cyberagent/android/gpuimage/GPUImagePixelationFilter.java
+++ b/library/src/jp/co/cyberagent/android/gpuimage/GPUImagePixelationFilter.java
@@ -17,10 +17,12 @@
 package jp.co.cyberagent.android.gpuimage;
 
 import android.opengl.GLES20;
+
 /**
  * Applies a grayscale effect to the image.
  */
 public class GPUImagePixelationFilter extends GPUImageFilter {
+
     public static final String PIXELATION_FRAGMENT_SHADER = "" +
             "precision highp float;\n" +
 
@@ -45,7 +47,7 @@
     private int mImageHeightFactorLocation;
     private float mPixel;
     private int mPixelLocation;
-    
+
     public GPUImagePixelationFilter() {
         super(NO_FILTER_VERTEX_SHADER, PIXELATION_FRAGMENT_SHADER);
         mPixel = 1.0f;
@@ -68,7 +70,7 @@ public void onOutputSizeChanged(final int width, final int height) {
     }
 
     public void setPixel(final float pixel) {
-      mPixel = pixel;
-      setFloat(mPixelLocation, mPixel);
+        mPixel = pixel;
+        setFloat(mPixelLocation, mPixel);
     }
 }
diff --git a/library/src/jp/co/cyberagent/android/gpuimage/GPUImagePosterizeFilter.java b/library/src/jp/co/cyberagent/android/gpuimage/GPUImagePosterizeFilter.java
index 3b7c8ff7..90d31a98 100644
--- a/library/src/jp/co/cyberagent/android/gpuimage/GPUImagePosterizeFilter.java
+++ b/library/src/jp/co/cyberagent/android/gpuimage/GPUImagePosterizeFilter.java
@@ -24,6 +24,7 @@
  * colorLevels: ranges from 1 to 256, with a default of 10
  */
 public class GPUImagePosterizeFilter extends GPUImageFilter {
+
     public static final String POSTERIZE_FRAGMENT_SHADER = "" +
             "varying highp vec2 textureCoordinate;\n" +
             "\n" +
diff --git a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageRGBDilationFilter.java b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageRGBDilationFilter.java
index 2d5e28c7..fd47307c 100644
--- a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageRGBDilationFilter.java
+++ b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageRGBDilationFilter.java
@@ -17,11 +17,12 @@
 package jp.co.cyberagent.android.gpuimage;
 
 /**
- * For each pixel, this sets it to the maximum value of each color channel in a rectangular neighborhood extending
- * out dilationRadius pixels from the center.
- * This extends out brighter colors, and can be used for abstraction of color images.
+ * For each pixel, this sets it to the maximum value of each color channel in a rectangular
+ * neighborhood extending out dilationRadius pixels from the center. This extends out brighter
+ * colors, and can be used for abstraction of color images.
  */
 public class GPUImageRGBDilationFilter extends GPUImageTwoPassTextureSamplingFilter {
+
     public static final String VERTEX_SHADER_1 =
             "attribute vec4 position;\n" +
                     "attribute vec2 inputTextureCoordinate;\n" +
@@ -66,8 +67,10 @@
                     "centerTextureCoordinate = inputTextureCoordinate;\n" +
                     "oneStepNegativeTextureCoordinate = inputTextureCoordinate - offset;\n" +
                     "oneStepPositiveTextureCoordinate = inputTextureCoordinate + offset;\n" +
-                    "twoStepsNegativeTextureCoordinate = inputTextureCoordinate - (offset * 2.0);\n" +
-                    "twoStepsPositiveTextureCoordinate = inputTextureCoordinate + (offset * 2.0);\n" +
+                    "twoStepsNegativeTextureCoordinate = inputTextureCoordinate - (offset * 2.0);\n"
+                    +
+                    "twoStepsPositiveTextureCoordinate = inputTextureCoordinate + (offset * 2.0);\n"
+                    +
                     "}\n";
 
     public static final String VERTEX_SHADER_3 =
@@ -94,10 +97,14 @@
                     "centerTextureCoordinate = inputTextureCoordinate;\n" +
                     "oneStepNegativeTextureCoordinate = inputTextureCoordinate - offset;\n" +
                     "oneStepPositiveTextureCoordinate = inputTextureCoordinate + offset;\n" +
-                    "twoStepsNegativeTextureCoordinate = inputTextureCoordinate - (offset * 2.0);\n" +
-                    "twoStepsPositiveTextureCoordinate = inputTextureCoordinate + (offset * 2.0);\n" +
-                    "threeStepsNegativeTextureCoordinate = inputTextureCoordinate - (offset * 3.0);\n" +
-                    "threeStepsPositiveTextureCoordinate = inputTextureCoordinate + (offset * 3.0);\n" +
+                    "twoStepsNegativeTextureCoordinate = inputTextureCoordinate - (offset * 2.0);\n"
+                    +
+                    "twoStepsPositiveTextureCoordinate = inputTextureCoordinate + (offset * 2.0);\n"
+                    +
+                    "threeStepsNegativeTextureCoordinate = inputTextureCoordinate - (offset * 3.0);\n"
+                    +
+                    "threeStepsPositiveTextureCoordinate = inputTextureCoordinate + (offset * 3.0);\n"
+                    +
                     "}\n";
 
     public static final String VERTEX_SHADER_4 =
@@ -126,15 +133,20 @@
                     "centerTextureCoordinate = inputTextureCoordinate;\n" +
                     "oneStepNegativeTextureCoordinate = inputTextureCoordinate - offset;\n" +
                     "oneStepPositiveTextureCoordinate = inputTextureCoordinate + offset;\n" +
-                    "twoStepsNegativeTextureCoordinate = inputTextureCoordinate - (offset * 2.0);\n" +
-                    "twoStepsPositiveTextureCoordinate = inputTextureCoordinate + (offset * 2.0);\n" +
-                    "threeStepsNegativeTextureCoordinate = inputTextureCoordinate - (offset * 3.0);\n" +
-                    "threeStepsPositiveTextureCoordinate = inputTextureCoordinate + (offset * 3.0);\n" +
-                    "fourStepsNegativeTextureCoordinate = inputTextureCoordinate - (offset * 4.0);\n" +
-                    "fourStepsPositiveTextureCoordinate = inputTextureCoordinate + (offset * 4.0);\n" +
+                    "twoStepsNegativeTextureCoordinate = inputTextureCoordinate - (offset * 2.0);\n"
+                    +
+                    "twoStepsPositiveTextureCoordinate = inputTextureCoordinate + (offset * 2.0);\n"
+                    +
+                    "threeStepsNegativeTextureCoordinate = inputTextureCoordinate - (offset * 3.0);\n"
+                    +
+                    "threeStepsPositiveTextureCoordinate = inputTextureCoordinate + (offset * 3.0);\n"
+                    +
+                    "fourStepsNegativeTextureCoordinate = inputTextureCoordinate - (offset * 4.0);\n"
+                    +
+                    "fourStepsPositiveTextureCoordinate = inputTextureCoordinate + (offset * 4.0);\n"
+                    +
                     "}\n";
 
-
     public static final String FRAGMENT_SHADER_1 =
             "precision highp float;\n" +
                     "\n" +
@@ -146,9 +158,12 @@
                     "\n" +
                     "void main()\n" +
                     "{\n" +
-                    "lowp vec4 centerIntensity = texture2D(inputImageTexture, centerTextureCoordinate);\n" +
-                    "lowp vec4 oneStepPositiveIntensity = texture2D(inputImageTexture, oneStepPositiveTextureCoordinate);\n" +
-                    "lowp vec4 oneStepNegativeIntensity = texture2D(inputImageTexture, oneStepNegativeTextureCoordinate);\n" +
+                    "lowp vec4 centerIntensity = texture2D(inputImageTexture, centerTextureCoordinate);\n"
+                    +
+                    "lowp vec4 oneStepPositiveIntensity = texture2D(inputImageTexture, oneStepPositiveTextureCoordinate);\n"
+                    +
+                    "lowp vec4 oneStepNegativeIntensity = texture2D(inputImageTexture, oneStepNegativeTextureCoordinate);\n"
+                    +
                     "\n" +
                     "lowp vec4 maxValue = max(centerIntensity, oneStepPositiveIntensity);\n" +
                     "\n" +
@@ -168,11 +183,16 @@
                     "\n" +
                     "void main()\n" +
                     "{\n" +
-                    "lowp vec4 centerIntensity = texture2D(inputImageTexture, centerTextureCoordinate);\n" +
-                    "lowp vec4 oneStepPositiveIntensity = texture2D(inputImageTexture, oneStepPositiveTextureCoordinate);\n" +
-                    "lowp vec4 oneStepNegativeIntensity = texture2D(inputImageTexture, oneStepNegativeTextureCoordinate);\n" +
-                    "lowp vec4 twoStepsPositiveIntensity = texture2D(inputImageTexture, twoStepsPositiveTextureCoordinate);\n" +
-                    "lowp vec4 twoStepsNegativeIntensity = texture2D(inputImageTexture, twoStepsNegativeTextureCoordinate);\n" +
+                    "lowp vec4 centerIntensity = texture2D(inputImageTexture, centerTextureCoordinate);\n"
+                    +
+                    "lowp vec4 oneStepPositiveIntensity = texture2D(inputImageTexture, oneStepPositiveTextureCoordinate);\n"
+                    +
+                    "lowp vec4 oneStepNegativeIntensity = texture2D(inputImageTexture, oneStepNegativeTextureCoordinate);\n"
+                    +
+                    "lowp vec4 twoStepsPositiveIntensity = texture2D(inputImageTexture, twoStepsPositiveTextureCoordinate);\n"
+                    +
+                    "lowp vec4 twoStepsNegativeIntensity = texture2D(inputImageTexture, twoStepsNegativeTextureCoordinate);\n"
+                    +
                     "\n" +
                     "lowp vec4 maxValue = max(centerIntensity, oneStepPositiveIntensity);\n" +
                     "maxValue = max(maxValue, oneStepNegativeIntensity);\n" +
@@ -197,13 +217,20 @@
                     "\n" +
                     "void main()\n" +
                     "{\n" +
-                    "lowp vec4 centerIntensity = texture2D(inputImageTexture, centerTextureCoordinate);\n" +
-                    "lowp vec4 oneStepPositiveIntensity = texture2D(inputImageTexture, oneStepPositiveTextureCoordinate);\n" +
-                    "lowp vec4 oneStepNegativeIntensity = texture2D(inputImageTexture, oneStepNegativeTextureCoordinate);\n" +
-                    "lowp vec4 twoStepsPositiveIntensity = texture2D(inputImageTexture, twoStepsPositiveTextureCoordinate);\n" +
-                    "lowp vec4 twoStepsNegativeIntensity = texture2D(inputImageTexture, twoStepsNegativeTextureCoordinate);\n" +
-                    "lowp vec4 threeStepsPositiveIntensity = texture2D(inputImageTexture, threeStepsPositiveTextureCoordinate);\n" +
-                    "lowp vec4 threeStepsNegativeIntensity = texture2D(inputImageTexture, threeStepsNegativeTextureCoordinate);\n" +
+                    "lowp vec4 centerIntensity = texture2D(inputImageTexture, centerTextureCoordinate);\n"
+                    +
+                    "lowp vec4 oneStepPositiveIntensity = texture2D(inputImageTexture, oneStepPositiveTextureCoordinate);\n"
+                    +
+                    "lowp vec4 oneStepNegativeIntensity = texture2D(inputImageTexture, oneStepNegativeTextureCoordinate);\n"
+                    +
+                    "lowp vec4 twoStepsPositiveIntensity = texture2D(inputImageTexture, twoStepsPositiveTextureCoordinate);\n"
+                    +
+                    "lowp vec4 twoStepsNegativeIntensity = texture2D(inputImageTexture, twoStepsNegativeTextureCoordinate);\n"
+                    +
+                    "lowp vec4 threeStepsPositiveIntensity = texture2D(inputImageTexture, threeStepsPositiveTextureCoordinate);\n"
+                    +
+                    "lowp vec4 threeStepsNegativeIntensity = texture2D(inputImageTexture, threeStepsNegativeTextureCoordinate);\n"
+                    +
                     "\n" +
                     "lowp vec4 maxValue = max(centerIntensity, oneStepPositiveIntensity);\n" +
                     "maxValue = max(maxValue, oneStepNegativeIntensity);\n" +
@@ -231,15 +258,24 @@
                     "\n" +
                     "void main()\n" +
                     "{\n" +
-                    "lowp vec4 centerIntensity = texture2D(inputImageTexture, centerTextureCoordinate);\n" +
-                    "lowp vec4 oneStepPositiveIntensity = texture2D(inputImageTexture, oneStepPositiveTextureCoordinate);\n" +
-                    "lowp vec4 oneStepNegativeIntensity = texture2D(inputImageTexture, oneStepNegativeTextureCoordinate);\n" +
-                    "lowp vec4 twoStepsPositiveIntensity = texture2D(inputImageTexture, twoStepsPositiveTextureCoordinate);\n" +
-                    "lowp vec4 twoStepsNegativeIntensity = texture2D(inputImageTexture, twoStepsNegativeTextureCoordinate);\n" +
-                    "lowp vec4 threeStepsPositiveIntensity = texture2D(inputImageTexture, threeStepsPositiveTextureCoordinate);\n" +
-                    "lowp vec4 threeStepsNegativeIntensity = texture2D(inputImageTexture, threeStepsNegativeTextureCoordinate);\n" +
-                    "lowp vec4 fourStepsPositiveIntensity = texture2D(inputImageTexture, fourStepsPositiveTextureCoordinate);\n" +
-                    "lowp vec4 fourStepsNegativeIntensity = texture2D(inputImageTexture, fourStepsNegativeTextureCoordinate);\n" +
+                    "lowp vec4 centerIntensity = texture2D(inputImageTexture, centerTextureCoordinate);\n"
+                    +
+                    "lowp vec4 oneStepPositiveIntensity = texture2D(inputImageTexture, oneStepPositiveTextureCoordinate);\n"
+                    +
+                    "lowp vec4 oneStepNegativeIntensity = texture2D(inputImageTexture, oneStepNegativeTextureCoordinate);\n"
+                    +
+                    "lowp vec4 twoStepsPositiveIntensity = texture2D(inputImageTexture, twoStepsPositiveTextureCoordinate);\n"
+                    +
+                    "lowp vec4 twoStepsNegativeIntensity = texture2D(inputImageTexture, twoStepsNegativeTextureCoordinate);\n"
+                    +
+                    "lowp vec4 threeStepsPositiveIntensity = texture2D(inputImageTexture, threeStepsPositiveTextureCoordinate);\n"
+                    +
+                    "lowp vec4 threeStepsNegativeIntensity = texture2D(inputImageTexture, threeStepsNegativeTextureCoordinate);\n"
+                    +
+                    "lowp vec4 fourStepsPositiveIntensity = texture2D(inputImageTexture, fourStepsPositiveTextureCoordinate);\n"
+                    +
+                    "lowp vec4 fourStepsNegativeIntensity = texture2D(inputImageTexture, fourStepsNegativeTextureCoordinate);\n"
+                    +
                     "\n" +
                     "lowp vec4 maxValue = max(centerIntensity, oneStepPositiveIntensity);\n" +
                     "maxValue = max(maxValue, oneStepNegativeIntensity);\n" +
@@ -252,7 +288,6 @@
                     "gl_FragColor = max(maxValue, fourStepsNegativeIntensity);\n" +
                     "}\n";
 
-
     public GPUImageRGBDilationFilter() {
         this(1);
     }
diff --git a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageRGBFilter.java b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageRGBFilter.java
index f0af18cb..b7489067 100644
--- a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageRGBFilter.java
+++ b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageRGBFilter.java
@@ -19,26 +19,26 @@
 import android.opengl.GLES20;
 
 /**
- * Adjusts the individual RGB channels of an image
- * red: Normalized values by which each color channel is multiplied. The range is from 0.0 up, with 1.0 as the default.
- * green:
- * blue:
+ * Adjusts the individual RGB channels of an image red: Normalized values by which each color
+ * channel is multiplied. The range is from 0.0 up, with 1.0 as the default. green: blue:
  */
 public class GPUImageRGBFilter extends GPUImageFilter {
+
     public static final String RGB_FRAGMENT_SHADER = "" +
-    		"  varying highp vec2 textureCoordinate;\n" +
-    		"  \n" +
-    		"  uniform sampler2D inputImageTexture;\n" +
-    		"  uniform highp float red;\n" +
-    		"  uniform highp float green;\n" +
-    		"  uniform highp float blue;\n" +
-    		"  \n" +
-    		"  void main()\n" +
-    		"  {\n" +
-    		"      highp vec4 textureColor = texture2D(inputImageTexture, textureCoordinate);\n" +
-    		"      \n" +
-    		"      gl_FragColor = vec4(textureColor.r * red, textureColor.g * green, textureColor.b * blue, 1.0);\n" +
-    		"  }\n";
+            "  varying highp vec2 textureCoordinate;\n" +
+            "  \n" +
+            "  uniform sampler2D inputImageTexture;\n" +
+            "  uniform highp float red;\n" +
+            "  uniform highp float green;\n" +
+            "  uniform highp float blue;\n" +
+            "  \n" +
+            "  void main()\n" +
+            "  {\n" +
+            "      highp vec4 textureColor = texture2D(inputImageTexture, textureCoordinate);\n" +
+            "      \n" +
+            "      gl_FragColor = vec4(textureColor.r * red, textureColor.g * green, textureColor.b * blue, 1.0);\n"
+            +
+            "  }\n";
 
     private int mRedLocation;
     private float mRed;
@@ -77,14 +77,14 @@ public void setRed(final float red) {
             setFloat(mRedLocation, mRed);
         }
     }
-    
+
     public void setGreen(final float green) {
         mGreen = green;
         if (mIsInitialized) {
             setFloat(mGreenLocation, mGreen);
         }
     }
-    
+
     public void setBlue(final float blue) {
         mBlue = blue;
         if (mIsInitialized) {
diff --git a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageRenderer.java b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageRenderer.java
index 691550bd..2468a404 100644
--- a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageRenderer.java
+++ b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageRenderer.java
@@ -30,6 +30,7 @@
 
 import javax.microedition.khronos.egl.EGLConfig;
 import javax.microedition.khronos.opengles.GL10;
+
 import java.io.IOException;
 import java.nio.ByteBuffer;
 import java.nio.ByteOrder;
@@ -42,6 +43,7 @@
 
 @TargetApi(11)
 public class GPUImageRenderer implements Renderer, PreviewCallback {
+
     public static final int NO_IMAGE = -1;
     static final float CUBE[] = {
             -1.0f, -1.0f,
@@ -153,6 +155,7 @@ public void onPreviewFrame(final byte[] data, final Camera camera) {
         }
         if (mRunOnDraw.isEmpty()) {
             runOnDraw(new Runnable() {
+
                 @Override
                 public void run() {
                     GPUImageNativeLibrary.YUVtoRBGA(data, previewSize.width, previewSize.height,
@@ -172,6 +175,7 @@ public void run() {
 
     public void setUpSurfaceTexture(final Camera camera) {
         runOnDraw(new Runnable() {
+
             @Override
             public void run() {
                 int[] textures = new int[1];
@@ -285,15 +289,20 @@ private void adjustImageScaling() {
         float ratioHeight = imageHeightNew / outputHeight;
 
         float[] cube = CUBE;
-        float[] textureCords = TextureRotationUtil.getRotation(mRotation, mFlipHorizontal, mFlipVertical);
+        float[] textureCords = TextureRotationUtil
+                .getRotation(mRotation, mFlipHorizontal, mFlipVertical);
         if (mScaleType == GPUImage.ScaleType.CENTER_CROP) {
             float distHorizontal = (1 - 1 / ratioWidth) / 2;
             float distVertical = (1 - 1 / ratioHeight) / 2;
             textureCords = new float[]{
-                    addDistance(textureCords[0], distHorizontal), addDistance(textureCords[1], distVertical),
-                    addDistance(textureCords[2], distHorizontal), addDistance(textureCords[3], distVertical),
-                    addDistance(textureCords[4], distHorizontal), addDistance(textureCords[5], distVertical),
-                    addDistance(textureCords[6], distHorizontal), addDistance(textureCords[7], distVertical),
+                    addDistance(textureCords[0], distHorizontal),
+                    addDistance(textureCords[1], distVertical),
+                    addDistance(textureCords[2], distHorizontal),
+                    addDistance(textureCords[3], distVertical),
+                    addDistance(textureCords[4], distHorizontal),
+                    addDistance(textureCords[5], distVertical),
+                    addDistance(textureCords[6], distHorizontal),
+                    addDistance(textureCords[7], distVertical),
             };
         } else {
             cube = new float[]{
@@ -315,7 +324,7 @@ private float addDistance(float coordinate, float distance) {
     }
 
     public void setRotationCamera(final Rotation rotation, final boolean flipHorizontal,
-            final boolean flipVertical) {
+                                  final boolean flipVertical) {
         setRotation(rotation, flipVertical, flipHorizontal);
     }
 
diff --git a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageSaturationBlendFilter.java b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageSaturationBlendFilter.java
index 1c0f90d6..ccd74299 100644
--- a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageSaturationBlendFilter.java
+++ b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageSaturationBlendFilter.java
@@ -17,98 +17,103 @@
 package jp.co.cyberagent.android.gpuimage;
 
 public class GPUImageSaturationBlendFilter extends GPUImageTwoInputFilter {
-    public static final String SATURATION_BLEND_FRAGMENT_SHADER = "varying highp vec2 textureCoordinate;\n" +
-            " varying highp vec2 textureCoordinate2;\n" +
-            " \n" +
-            " uniform sampler2D inputImageTexture;\n" +
-            " uniform sampler2D inputImageTexture2;\n" +
-            " \n" +
-            " highp float lum(lowp vec3 c) {\n" +
-            "     return dot(c, vec3(0.3, 0.59, 0.11));\n" +
-            " }\n" +
-            " \n" +
-            " lowp vec3 clipcolor(lowp vec3 c) {\n" +
-            "     highp float l = lum(c);\n" +
-            "     lowp float n = min(min(c.r, c.g), c.b);\n" +
-            "     lowp float x = max(max(c.r, c.g), c.b);\n" +
-            "     \n" +
-            "     if (n < 0.0) {\n" +
-            "         c.r = l + ((c.r - l) * l) / (l - n);\n" +
-            "         c.g = l + ((c.g - l) * l) / (l - n);\n" +
-            "         c.b = l + ((c.b - l) * l) / (l - n);\n" +
-            "     }\n" +
-            "     if (x > 1.0) {\n" +
-            "         c.r = l + ((c.r - l) * (1.0 - l)) / (x - l);\n" +
-            "         c.g = l + ((c.g - l) * (1.0 - l)) / (x - l);\n" +
-            "         c.b = l + ((c.b - l) * (1.0 - l)) / (x - l);\n" +
-            "     }\n" +
-            "     \n" +
-            "     return c;\n" +
-            " }\n" +
-            " \n" +
-            " lowp vec3 setlum(lowp vec3 c, highp float l) {\n" +
-            "     highp float d = l - lum(c);\n" +
-            "     c = c + vec3(d);\n" +
-            "     return clipcolor(c);\n" +
-            " }\n" +
-            " \n" +
-            " highp float sat(lowp vec3 c) {\n" +
-            "     lowp float n = min(min(c.r, c.g), c.b);\n" +
-            "     lowp float x = max(max(c.r, c.g), c.b);\n" +
-            "     return x - n;\n" +
-            " }\n" +
-            " \n" +
-            " lowp float mid(lowp float cmin, lowp float cmid, lowp float cmax, highp float s) {\n" +
-            "     return ((cmid - cmin) * s) / (cmax - cmin);\n" +
-            " }\n" +
-            " \n" +
-            " lowp vec3 setsat(lowp vec3 c, highp float s) {\n" +
-            "     if (c.r > c.g) {\n" +
-            "         if (c.r > c.b) {\n" +
-            "             if (c.g > c.b) {\n" +
-            "                 /* g is mid, b is min */\n" +
-            "                 c.g = mid(c.b, c.g, c.r, s);\n" +
-            "                 c.b = 0.0;\n" +
-            "             } else {\n" +
-            "                 /* b is mid, g is min */\n" +
-            "                 c.b = mid(c.g, c.b, c.r, s);\n" +
-            "                 c.g = 0.0;\n" +
-            "             }\n" +
-            "             c.r = s;\n" +
-            "         } else {\n" +
-            "             /* b is max, r is mid, g is min */\n" +
-            "             c.r = mid(c.g, c.r, c.b, s);\n" +
-            "             c.b = s;\n" +
-            "             c.r = 0.0;\n" +
-            "         }\n" +
-            "     } else if (c.r > c.b) {\n" +
-            "         /* g is max, r is mid, b is min */\n" +
-            "         c.r = mid(c.b, c.r, c.g, s);\n" +
-            "         c.g = s;\n" +
-            "         c.b = 0.0;\n" +
-            "     } else if (c.g > c.b) {\n" +
-            "         /* g is max, b is mid, r is min */\n" +
-            "         c.b = mid(c.r, c.b, c.g, s);\n" +
-            "         c.g = s;\n" +
-            "         c.r = 0.0;\n" +
-            "     } else if (c.b > c.g) {\n" +
-            "         /* b is max, g is mid, r is min */\n" +
-            "         c.g = mid(c.r, c.g, c.b, s);\n" +
-            "         c.b = s;\n" +
-            "         c.r = 0.0;\n" +
-            "     } else {\n" +
-            "         c = vec3(0.0);\n" +
-            "     }\n" +
-            "     return c;\n" +
-            " }\n" +
-            " \n" +
-            " void main()\n" +
-            " {\n" +
-            "   highp vec4 baseColor = texture2D(inputImageTexture, textureCoordinate);\n" +
-            "   highp vec4 overlayColor = texture2D(inputImageTexture2, textureCoordinate2);\n" +
-            "     \n" +
-            "     gl_FragColor = vec4(baseColor.rgb * (1.0 - overlayColor.a) + setlum(setsat(baseColor.rgb, sat(overlayColor.rgb)), lum(baseColor.rgb)) * overlayColor.a, baseColor.a);\n" +
-            " }";
+
+    public static final String SATURATION_BLEND_FRAGMENT_SHADER =
+            "varying highp vec2 textureCoordinate;\n" +
+                    " varying highp vec2 textureCoordinate2;\n" +
+                    " \n" +
+                    " uniform sampler2D inputImageTexture;\n" +
+                    " uniform sampler2D inputImageTexture2;\n" +
+                    " \n" +
+                    " highp float lum(lowp vec3 c) {\n" +
+                    "     return dot(c, vec3(0.3, 0.59, 0.11));\n" +
+                    " }\n" +
+                    " \n" +
+                    " lowp vec3 clipcolor(lowp vec3 c) {\n" +
+                    "     highp float l = lum(c);\n" +
+                    "     lowp float n = min(min(c.r, c.g), c.b);\n" +
+                    "     lowp float x = max(max(c.r, c.g), c.b);\n" +
+                    "     \n" +
+                    "     if (n < 0.0) {\n" +
+                    "         c.r = l + ((c.r - l) * l) / (l - n);\n" +
+                    "         c.g = l + ((c.g - l) * l) / (l - n);\n" +
+                    "         c.b = l + ((c.b - l) * l) / (l - n);\n" +
+                    "     }\n" +
+                    "     if (x > 1.0) {\n" +
+                    "         c.r = l + ((c.r - l) * (1.0 - l)) / (x - l);\n" +
+                    "         c.g = l + ((c.g - l) * (1.0 - l)) / (x - l);\n" +
+                    "         c.b = l + ((c.b - l) * (1.0 - l)) / (x - l);\n" +
+                    "     }\n" +
+                    "     \n" +
+                    "     return c;\n" +
+                    " }\n" +
+                    " \n" +
+                    " lowp vec3 setlum(lowp vec3 c, highp float l) {\n" +
+                    "     highp float d = l - lum(c);\n" +
+                    "     c = c + vec3(d);\n" +
+                    "     return clipcolor(c);\n" +
+                    " }\n" +
+                    " \n" +
+                    " highp float sat(lowp vec3 c) {\n" +
+                    "     lowp float n = min(min(c.r, c.g), c.b);\n" +
+                    "     lowp float x = max(max(c.r, c.g), c.b);\n" +
+                    "     return x - n;\n" +
+                    " }\n" +
+                    " \n" +
+                    " lowp float mid(lowp float cmin, lowp float cmid, lowp float cmax, highp float s) {\n"
+                    +
+                    "     return ((cmid - cmin) * s) / (cmax - cmin);\n" +
+                    " }\n" +
+                    " \n" +
+                    " lowp vec3 setsat(lowp vec3 c, highp float s) {\n" +
+                    "     if (c.r > c.g) {\n" +
+                    "         if (c.r > c.b) {\n" +
+                    "             if (c.g > c.b) {\n" +
+                    "                 /* g is mid, b is min */\n" +
+                    "                 c.g = mid(c.b, c.g, c.r, s);\n" +
+                    "                 c.b = 0.0;\n" +
+                    "             } else {\n" +
+                    "                 /* b is mid, g is min */\n" +
+                    "                 c.b = mid(c.g, c.b, c.r, s);\n" +
+                    "                 c.g = 0.0;\n" +
+                    "             }\n" +
+                    "             c.r = s;\n" +
+                    "         } else {\n" +
+                    "             /* b is max, r is mid, g is min */\n" +
+                    "             c.r = mid(c.g, c.r, c.b, s);\n" +
+                    "             c.b = s;\n" +
+                    "             c.r = 0.0;\n" +
+                    "         }\n" +
+                    "     } else if (c.r > c.b) {\n" +
+                    "         /* g is max, r is mid, b is min */\n" +
+                    "         c.r = mid(c.b, c.r, c.g, s);\n" +
+                    "         c.g = s;\n" +
+                    "         c.b = 0.0;\n" +
+                    "     } else if (c.g > c.b) {\n" +
+                    "         /* g is max, b is mid, r is min */\n" +
+                    "         c.b = mid(c.r, c.b, c.g, s);\n" +
+                    "         c.g = s;\n" +
+                    "         c.r = 0.0;\n" +
+                    "     } else if (c.b > c.g) {\n" +
+                    "         /* b is max, g is mid, r is min */\n" +
+                    "         c.g = mid(c.r, c.g, c.b, s);\n" +
+                    "         c.b = s;\n" +
+                    "         c.r = 0.0;\n" +
+                    "     } else {\n" +
+                    "         c = vec3(0.0);\n" +
+                    "     }\n" +
+                    "     return c;\n" +
+                    " }\n" +
+                    " \n" +
+                    " void main()\n" +
+                    " {\n" +
+                    "   highp vec4 baseColor = texture2D(inputImageTexture, textureCoordinate);\n" +
+                    "   highp vec4 overlayColor = texture2D(inputImageTexture2, textureCoordinate2);\n"
+                    +
+                    "     \n" +
+                    "     gl_FragColor = vec4(baseColor.rgb * (1.0 - overlayColor.a) + setlum(setsat(baseColor.rgb, sat(overlayColor.rgb)), lum(baseColor.rgb)) * overlayColor.a, baseColor.a);\n"
+                    +
+                    " }";
 
     public GPUImageSaturationBlendFilter() {
         super(SATURATION_BLEND_FRAGMENT_SHADER);
diff --git a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageSaturationFilter.java b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageSaturationFilter.java
index 0725953d..08277354 100644
--- a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageSaturationFilter.java
+++ b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageSaturationFilter.java
@@ -19,9 +19,11 @@
 import android.opengl.GLES20;
 
 /**
- * saturation: The degree of saturation or desaturation to apply to the image (0.0 - 2.0, with 1.0 as the default)
+ * saturation: The degree of saturation or desaturation to apply to the image (0.0 - 2.0, with 1.0
+ * as the default)
  */
 public class GPUImageSaturationFilter extends GPUImageFilter {
+
     public static final String SATURATION_FRAGMENT_SHADER = "" +
             " varying highp vec2 textureCoordinate;\n" +
             " \n" +
@@ -37,7 +39,8 @@
             "    lowp float luminance = dot(textureColor.rgb, luminanceWeighting);\n" +
             "    lowp vec3 greyScaleColor = vec3(luminance);\n" +
             "    \n" +
-            "    gl_FragColor = vec4(mix(greyScaleColor, textureColor.rgb, saturation), textureColor.w);\n" +
+            "    gl_FragColor = vec4(mix(greyScaleColor, textureColor.rgb, saturation), textureColor.w);\n"
+            +
             "     \n" +
             " }";
 
diff --git a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageScreenBlendFilter.java b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageScreenBlendFilter.java
index 2c63a699..264db244 100644
--- a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageScreenBlendFilter.java
+++ b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageScreenBlendFilter.java
@@ -17,19 +17,24 @@
 package jp.co.cyberagent.android.gpuimage;
 
 public class GPUImageScreenBlendFilter extends GPUImageTwoInputFilter {
-    public static final String SCREEN_BLEND_FRAGMENT_SHADER = "varying highp vec2 textureCoordinate;\n" +
-            " varying highp vec2 textureCoordinate2;\n" +
-            "\n" +
-            " uniform sampler2D inputImageTexture;\n" +
-            " uniform sampler2D inputImageTexture2;\n" +
-            " \n" +
-            " void main()\n" +
-            " {\n" +
-            "     mediump vec4 textureColor = texture2D(inputImageTexture, textureCoordinate);\n" +
-            "     mediump vec4 textureColor2 = texture2D(inputImageTexture2, textureCoordinate2);\n" +
-            "     mediump vec4 whiteColor = vec4(1.0);\n" +
-            "     gl_FragColor = whiteColor - ((whiteColor - textureColor2) * (whiteColor - textureColor));\n" +
-            " }";
+
+    public static final String SCREEN_BLEND_FRAGMENT_SHADER =
+            "varying highp vec2 textureCoordinate;\n" +
+                    " varying highp vec2 textureCoordinate2;\n" +
+                    "\n" +
+                    " uniform sampler2D inputImageTexture;\n" +
+                    " uniform sampler2D inputImageTexture2;\n" +
+                    " \n" +
+                    " void main()\n" +
+                    " {\n" +
+                    "     mediump vec4 textureColor = texture2D(inputImageTexture, textureCoordinate);\n"
+                    +
+                    "     mediump vec4 textureColor2 = texture2D(inputImageTexture2, textureCoordinate2);\n"
+                    +
+                    "     mediump vec4 whiteColor = vec4(1.0);\n" +
+                    "     gl_FragColor = whiteColor - ((whiteColor - textureColor2) * (whiteColor - textureColor));\n"
+                    +
+                    " }";
 
     public GPUImageScreenBlendFilter() {
         super(SCREEN_BLEND_FRAGMENT_SHADER);
diff --git a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageSepiaFilter.java b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageSepiaFilter.java
index cbcf3534..ea3451dd 100644
--- a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageSepiaFilter.java
+++ b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageSepiaFilter.java
@@ -26,7 +26,7 @@ public GPUImageSepiaFilter() {
     }
 
     public GPUImageSepiaFilter(final float intensity) {
-        super(intensity, new float[] {
+        super(intensity, new float[]{
                 0.3588f, 0.7044f, 0.1368f, 0.0f,
                 0.2990f, 0.5870f, 0.1140f, 0.0f,
                 0.2392f, 0.4696f, 0.0912f, 0.0f,
diff --git a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageSharpenFilter.java b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageSharpenFilter.java
index 4317b66c..dd1d592c 100644
--- a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageSharpenFilter.java
+++ b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageSharpenFilter.java
@@ -24,6 +24,7 @@
  * sharpness: from -4.0 to 4.0, with 0.0 as the normal level
  */
 public class GPUImageSharpenFilter extends GPUImageFilter {
+
     public static final String SHARPEN_VERTEX_SHADER = "" +
             "attribute vec4 position;\n" +
             "attribute vec4 inputTextureCoordinate;\n" +
@@ -59,28 +60,34 @@
             "}";
 
     public static final String SHARPEN_FRAGMENT_SHADER = "" +
-            "precision highp float;\n" + 
-            "\n" + 
-            "varying highp vec2 textureCoordinate;\n" + 
-            "varying highp vec2 leftTextureCoordinate;\n" + 
-            "varying highp vec2 rightTextureCoordinate; \n" + 
-            "varying highp vec2 topTextureCoordinate;\n" + 
-            "varying highp vec2 bottomTextureCoordinate;\n" + 
-            "\n" + 
-            "varying highp float centerMultiplier;\n" + 
-            "varying highp float edgeMultiplier;\n" + 
-            "\n" + 
-            "uniform sampler2D inputImageTexture;\n" + 
-            "\n" + 
-            "void main()\n" + 
-            "{\n" + 
-            "    mediump vec3 textureColor = texture2D(inputImageTexture, textureCoordinate).rgb;\n" + 
-            "    mediump vec3 leftTextureColor = texture2D(inputImageTexture, leftTextureCoordinate).rgb;\n" + 
-            "    mediump vec3 rightTextureColor = texture2D(inputImageTexture, rightTextureCoordinate).rgb;\n" + 
-            "    mediump vec3 topTextureColor = texture2D(inputImageTexture, topTextureCoordinate).rgb;\n" + 
-            "    mediump vec3 bottomTextureColor = texture2D(inputImageTexture, bottomTextureCoordinate).rgb;\n" + 
-            "\n" + 
-            "    gl_FragColor = vec4((textureColor * centerMultiplier - (leftTextureColor * edgeMultiplier + rightTextureColor * edgeMultiplier + topTextureColor * edgeMultiplier + bottomTextureColor * edgeMultiplier)), texture2D(inputImageTexture, bottomTextureCoordinate).w);\n" + 
+            "precision highp float;\n" +
+            "\n" +
+            "varying highp vec2 textureCoordinate;\n" +
+            "varying highp vec2 leftTextureCoordinate;\n" +
+            "varying highp vec2 rightTextureCoordinate; \n" +
+            "varying highp vec2 topTextureCoordinate;\n" +
+            "varying highp vec2 bottomTextureCoordinate;\n" +
+            "\n" +
+            "varying highp float centerMultiplier;\n" +
+            "varying highp float edgeMultiplier;\n" +
+            "\n" +
+            "uniform sampler2D inputImageTexture;\n" +
+            "\n" +
+            "void main()\n" +
+            "{\n" +
+            "    mediump vec3 textureColor = texture2D(inputImageTexture, textureCoordinate).rgb;\n"
+            +
+            "    mediump vec3 leftTextureColor = texture2D(inputImageTexture, leftTextureCoordinate).rgb;\n"
+            +
+            "    mediump vec3 rightTextureColor = texture2D(inputImageTexture, rightTextureCoordinate).rgb;\n"
+            +
+            "    mediump vec3 topTextureColor = texture2D(inputImageTexture, topTextureCoordinate).rgb;\n"
+            +
+            "    mediump vec3 bottomTextureColor = texture2D(inputImageTexture, bottomTextureCoordinate).rgb;\n"
+            +
+            "\n" +
+            "    gl_FragColor = vec4((textureColor * centerMultiplier - (leftTextureColor * edgeMultiplier + rightTextureColor * edgeMultiplier + topTextureColor * edgeMultiplier + bottomTextureColor * edgeMultiplier)), texture2D(inputImageTexture, bottomTextureCoordinate).w);\n"
+            +
             "}";
 
     private int mSharpnessLocation;
@@ -91,7 +98,7 @@
     public GPUImageSharpenFilter() {
         this(0.0f);
     }
-    
+
     public GPUImageSharpenFilter(final float sharpness) {
         super(SHARPEN_VERTEX_SHADER, SHARPEN_FRAGMENT_SHADER);
         mSharpness = sharpness;
diff --git a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageSketchFilter.java b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageSketchFilter.java
index dd78e708..8df951bc 100644
--- a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageSketchFilter.java
+++ b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageSketchFilter.java
@@ -24,6 +24,7 @@
  * This is just the Sobel edge detection filter with the colors inverted.
  */
 public class GPUImageSketchFilter extends GPUImageFilterGroup {
+
     public static final String SKETCH_FRAGMENT_SHADER = "" +
             "precision mediump float;\n" +
             "\n" +
@@ -43,16 +44,21 @@
             "\n" +
             "void main()\n" +
             "{\n" +
-            "float bottomLeftIntensity = texture2D(inputImageTexture, bottomLeftTextureCoordinate).r;\n" +
-            "float topRightIntensity = texture2D(inputImageTexture, topRightTextureCoordinate).r;\n" +
+            "float bottomLeftIntensity = texture2D(inputImageTexture, bottomLeftTextureCoordinate).r;\n"
+            +
+            "float topRightIntensity = texture2D(inputImageTexture, topRightTextureCoordinate).r;\n"
+            +
             "float topLeftIntensity = texture2D(inputImageTexture, topLeftTextureCoordinate).r;\n" +
-            "float bottomRightIntensity = texture2D(inputImageTexture, bottomRightTextureCoordinate).r;\n" +
+            "float bottomRightIntensity = texture2D(inputImageTexture, bottomRightTextureCoordinate).r;\n"
+            +
             "float leftIntensity = texture2D(inputImageTexture, leftTextureCoordinate).r;\n" +
             "float rightIntensity = texture2D(inputImageTexture, rightTextureCoordinate).r;\n" +
             "float bottomIntensity = texture2D(inputImageTexture, bottomTextureCoordinate).r;\n" +
             "float topIntensity = texture2D(inputImageTexture, topTextureCoordinate).r;\n" +
-            "float h = -topLeftIntensity - 2.0 * topIntensity - topRightIntensity + bottomLeftIntensity + 2.0 * bottomIntensity + bottomRightIntensity;\n" +
-            "float v = -bottomLeftIntensity - 2.0 * leftIntensity - topLeftIntensity + bottomRightIntensity + 2.0 * rightIntensity + topRightIntensity;\n" +
+            "float h = -topLeftIntensity - 2.0 * topIntensity - topRightIntensity + bottomLeftIntensity + 2.0 * bottomIntensity + bottomRightIntensity;\n"
+            +
+            "float v = -bottomLeftIntensity - 2.0 * leftIntensity - topLeftIntensity + bottomRightIntensity + 2.0 * rightIntensity + topRightIntensity;\n"
+            +
             "\n" +
             "float mag = 1.0 - length(vec2(h, v));\n" +
             "\n" +
diff --git a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageSmoothToonFilter.java b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageSmoothToonFilter.java
index a569ce97..1bf3f0a6 100644
--- a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageSmoothToonFilter.java
+++ b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageSmoothToonFilter.java
@@ -19,10 +19,11 @@
 import android.opengl.GLES20;
 
 /**
- *  This uses a similar process as the GPUImageToonFilter, only it precedes the toon effect
- *  with a Gaussian blur to smooth out noise.
+ * This uses a similar process as the GPUImageToonFilter, only it precedes the toon effect
+ * with a Gaussian blur to smooth out noise.
  */
 public class GPUImageSmoothToonFilter extends GPUImageFilterGroup {
+
     GPUImageGaussianBlurFilter blurFilter;
     GPUImageToonFilter toonFilter;
 
@@ -67,5 +68,4 @@ public void setThreshold(float value) {
     public void setQuantizationLevels(float value) {
         toonFilter.setQuantizationLevels(value);
     }
-
 }
diff --git a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageSobelEdgeDetection.java b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageSobelEdgeDetection.java
index 2a775d48..dd07ef35 100644
--- a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageSobelEdgeDetection.java
+++ b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageSobelEdgeDetection.java
@@ -23,39 +23,47 @@
  * Applies sobel edge detection on the image.
  */
 public class GPUImageSobelEdgeDetection extends GPUImageFilterGroup {
+
     public static final String SOBEL_EDGE_DETECTION = "" +
-            "precision mediump float;\n" + 
-            "\n" + 
-            "varying vec2 textureCoordinate;\n" + 
-            "varying vec2 leftTextureCoordinate;\n" + 
-            "varying vec2 rightTextureCoordinate;\n" + 
-            "\n" + 
-            "varying vec2 topTextureCoordinate;\n" + 
-            "varying vec2 topLeftTextureCoordinate;\n" + 
-            "varying vec2 topRightTextureCoordinate;\n" + 
-            "\n" + 
-            "varying vec2 bottomTextureCoordinate;\n" + 
-            "varying vec2 bottomLeftTextureCoordinate;\n" + 
-            "varying vec2 bottomRightTextureCoordinate;\n" + 
-            "\n" + 
-            "uniform sampler2D inputImageTexture;\n" + 
-            "\n" + 
-            "void main()\n" + 
-            "{\n" + 
-            "    float bottomLeftIntensity = texture2D(inputImageTexture, bottomLeftTextureCoordinate).r;\n" + 
-            "    float topRightIntensity = texture2D(inputImageTexture, topRightTextureCoordinate).r;\n" + 
-            "    float topLeftIntensity = texture2D(inputImageTexture, topLeftTextureCoordinate).r;\n" + 
-            "    float bottomRightIntensity = texture2D(inputImageTexture, bottomRightTextureCoordinate).r;\n" + 
-            "    float leftIntensity = texture2D(inputImageTexture, leftTextureCoordinate).r;\n" + 
-            "    float rightIntensity = texture2D(inputImageTexture, rightTextureCoordinate).r;\n" + 
-            "    float bottomIntensity = texture2D(inputImageTexture, bottomTextureCoordinate).r;\n" + 
-            "    float topIntensity = texture2D(inputImageTexture, topTextureCoordinate).r;\n" + 
-            "    float h = -topLeftIntensity - 2.0 * topIntensity - topRightIntensity + bottomLeftIntensity + 2.0 * bottomIntensity + bottomRightIntensity;\n" + 
-            "    float v = -bottomLeftIntensity - 2.0 * leftIntensity - topLeftIntensity + bottomRightIntensity + 2.0 * rightIntensity + topRightIntensity;\n" + 
-            "\n" + 
-            "    float mag = length(vec2(h, v));\n" + 
-            "\n" + 
-            "    gl_FragColor = vec4(vec3(mag), 1.0);\n" + 
+            "precision mediump float;\n" +
+            "\n" +
+            "varying vec2 textureCoordinate;\n" +
+            "varying vec2 leftTextureCoordinate;\n" +
+            "varying vec2 rightTextureCoordinate;\n" +
+            "\n" +
+            "varying vec2 topTextureCoordinate;\n" +
+            "varying vec2 topLeftTextureCoordinate;\n" +
+            "varying vec2 topRightTextureCoordinate;\n" +
+            "\n" +
+            "varying vec2 bottomTextureCoordinate;\n" +
+            "varying vec2 bottomLeftTextureCoordinate;\n" +
+            "varying vec2 bottomRightTextureCoordinate;\n" +
+            "\n" +
+            "uniform sampler2D inputImageTexture;\n" +
+            "\n" +
+            "void main()\n" +
+            "{\n" +
+            "    float bottomLeftIntensity = texture2D(inputImageTexture, bottomLeftTextureCoordinate).r;\n"
+            +
+            "    float topRightIntensity = texture2D(inputImageTexture, topRightTextureCoordinate).r;\n"
+            +
+            "    float topLeftIntensity = texture2D(inputImageTexture, topLeftTextureCoordinate).r;\n"
+            +
+            "    float bottomRightIntensity = texture2D(inputImageTexture, bottomRightTextureCoordinate).r;\n"
+            +
+            "    float leftIntensity = texture2D(inputImageTexture, leftTextureCoordinate).r;\n" +
+            "    float rightIntensity = texture2D(inputImageTexture, rightTextureCoordinate).r;\n" +
+            "    float bottomIntensity = texture2D(inputImageTexture, bottomTextureCoordinate).r;\n"
+            +
+            "    float topIntensity = texture2D(inputImageTexture, topTextureCoordinate).r;\n" +
+            "    float h = -topLeftIntensity - 2.0 * topIntensity - topRightIntensity + bottomLeftIntensity + 2.0 * bottomIntensity + bottomRightIntensity;\n"
+            +
+            "    float v = -bottomLeftIntensity - 2.0 * leftIntensity - topLeftIntensity + bottomRightIntensity + 2.0 * rightIntensity + topRightIntensity;\n"
+            +
+            "\n" +
+            "    float mag = length(vec2(h, v));\n" +
+            "\n" +
+            "    gl_FragColor = vec4(vec3(mag), 1.0);\n" +
             "}";
 
     public GPUImageSobelEdgeDetection() {
diff --git a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageSobelThresholdFilter.java b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageSobelThresholdFilter.java
index f1dcf64e..a376f005 100644
--- a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageSobelThresholdFilter.java
+++ b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageSobelThresholdFilter.java
@@ -3,72 +3,80 @@
 import android.opengl.GLES20;
 
 public class GPUImageSobelThresholdFilter extends
-		GPUImage3x3TextureSamplingFilter {
+        GPUImage3x3TextureSamplingFilter {
+
     public static final String SOBEL_THRESHOLD_EDGE_DETECTION = "" +
-    		"precision mediump float;\n" +
-    		"\n" +
-    		"varying vec2 textureCoordinate;\n" +
-    		"varying vec2 leftTextureCoordinate;\n" +
-    		"varying vec2 rightTextureCoordinate;\n" +
-    		"\n" +
-    		"varying vec2 topTextureCoordinate;\n" +
-    		"varying vec2 topLeftTextureCoordinate;\n" +
-    		"varying vec2 topRightTextureCoordinate;\n" +
-    		"\n" +
-    		"varying vec2 bottomTextureCoordinate;\n" +
-    		"varying vec2 bottomLeftTextureCoordinate;\n" +
-    		"varying vec2 bottomRightTextureCoordinate;\n" +
-    		"\n" +
-    		"uniform sampler2D inputImageTexture;\n" +
-    		"uniform lowp float threshold;\n" +
-    		"\n" +
-    		"const highp vec3 W = vec3(0.2125, 0.7154, 0.0721);\n" +
-    		"\n" +
-    		"void main()\n" +
-    		"{\n" +
-    		"    float bottomLeftIntensity = texture2D(inputImageTexture, bottomLeftTextureCoordinate).r;\n" +
-    		"    float topRightIntensity = texture2D(inputImageTexture, topRightTextureCoordinate).r;\n" +
-    		"    float topLeftIntensity = texture2D(inputImageTexture, topLeftTextureCoordinate).r;\n" +
-    		"    float bottomRightIntensity = texture2D(inputImageTexture, bottomRightTextureCoordinate).r;\n" +
-    		"    float leftIntensity = texture2D(inputImageTexture, leftTextureCoordinate).r;\n" +
-    		"    float rightIntensity = texture2D(inputImageTexture, rightTextureCoordinate).r;\n" +
-    		"    float bottomIntensity = texture2D(inputImageTexture, bottomTextureCoordinate).r;\n" +
-    		"    float topIntensity = texture2D(inputImageTexture, topTextureCoordinate).r;\n" +
-    		"    float h = -topLeftIntensity - 2.0 * topIntensity - topRightIntensity + bottomLeftIntensity + 2.0 * bottomIntensity + bottomRightIntensity;\n" +
-    		"    float v = -bottomLeftIntensity - 2.0 * leftIntensity - topLeftIntensity + bottomRightIntensity + 2.0 * rightIntensity + topRightIntensity;\n" +
-    		"\n" +
-    		"    float mag = 1.0 - length(vec2(h, v));\n" +
-    		"    mag = step(threshold, mag);\n" +
-    		"\n" +
-    		"    gl_FragColor = vec4(vec3(mag), 1.0);\n" +
-    		"}\n";
+            "precision mediump float;\n" +
+            "\n" +
+            "varying vec2 textureCoordinate;\n" +
+            "varying vec2 leftTextureCoordinate;\n" +
+            "varying vec2 rightTextureCoordinate;\n" +
+            "\n" +
+            "varying vec2 topTextureCoordinate;\n" +
+            "varying vec2 topLeftTextureCoordinate;\n" +
+            "varying vec2 topRightTextureCoordinate;\n" +
+            "\n" +
+            "varying vec2 bottomTextureCoordinate;\n" +
+            "varying vec2 bottomLeftTextureCoordinate;\n" +
+            "varying vec2 bottomRightTextureCoordinate;\n" +
+            "\n" +
+            "uniform sampler2D inputImageTexture;\n" +
+            "uniform lowp float threshold;\n" +
+            "\n" +
+            "const highp vec3 W = vec3(0.2125, 0.7154, 0.0721);\n" +
+            "\n" +
+            "void main()\n" +
+            "{\n" +
+            "    float bottomLeftIntensity = texture2D(inputImageTexture, bottomLeftTextureCoordinate).r;\n"
+            +
+            "    float topRightIntensity = texture2D(inputImageTexture, topRightTextureCoordinate).r;\n"
+            +
+            "    float topLeftIntensity = texture2D(inputImageTexture, topLeftTextureCoordinate).r;\n"
+            +
+            "    float bottomRightIntensity = texture2D(inputImageTexture, bottomRightTextureCoordinate).r;\n"
+            +
+            "    float leftIntensity = texture2D(inputImageTexture, leftTextureCoordinate).r;\n" +
+            "    float rightIntensity = texture2D(inputImageTexture, rightTextureCoordinate).r;\n" +
+            "    float bottomIntensity = texture2D(inputImageTexture, bottomTextureCoordinate).r;\n"
+            +
+            "    float topIntensity = texture2D(inputImageTexture, topTextureCoordinate).r;\n" +
+            "    float h = -topLeftIntensity - 2.0 * topIntensity - topRightIntensity + bottomLeftIntensity + 2.0 * bottomIntensity + bottomRightIntensity;\n"
+            +
+            "    float v = -bottomLeftIntensity - 2.0 * leftIntensity - topLeftIntensity + bottomRightIntensity + 2.0 * rightIntensity + topRightIntensity;\n"
+            +
+            "\n" +
+            "    float mag = 1.0 - length(vec2(h, v));\n" +
+            "    mag = step(threshold, mag);\n" +
+            "\n" +
+            "    gl_FragColor = vec4(vec3(mag), 1.0);\n" +
+            "}\n";
 
     private int mUniformThresholdLocation;
     private float mThreshold = 0.9f;
-    
+
     public GPUImageSobelThresholdFilter() {
-    	this(0.9f);
+        this(0.9f);
     }
-    
+
     public GPUImageSobelThresholdFilter(float threshold) {
-    	super(SOBEL_THRESHOLD_EDGE_DETECTION);
-    	mThreshold = threshold;
+        super(SOBEL_THRESHOLD_EDGE_DETECTION);
+        mThreshold = threshold;
     }
-    
+
     @Override
     public void onInit() {
-    	super.onInit();
-    	mUniformThresholdLocation = GLES20.glGetUniformLocation(getProgram(), "threshold");
+        super.onInit();
+        mUniformThresholdLocation = GLES20.glGetUniformLocation(getProgram(), "threshold");
     }
-    
+
     @Override
     public void onInitialized() {
-    	super.onInitialized();
-    	setThreshold(mThreshold);
+        super.onInitialized();
+        setThreshold(mThreshold);
     }
-    
+
     public void setThreshold(final float threshold) {
-    	mThreshold = threshold;
-    	setFloat(mUniformThresholdLocation, threshold);
+        mThreshold = threshold;
+        setFloat(mUniformThresholdLocation, threshold);
     }
 }
diff --git a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageSoftLightBlendFilter.java b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageSoftLightBlendFilter.java
index 0e1b742e..d9539ebb 100644
--- a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageSoftLightBlendFilter.java
+++ b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageSoftLightBlendFilter.java
@@ -17,19 +17,23 @@
 package jp.co.cyberagent.android.gpuimage;
 
 public class GPUImageSoftLightBlendFilter extends GPUImageTwoInputFilter {
-    public static final String SOFT_LIGHT_BLEND_FRAGMENT_SHADER = "varying highp vec2 textureCoordinate;\n" +
-            " varying highp vec2 textureCoordinate2;\n" +
-            "\n" +
-            " uniform sampler2D inputImageTexture;\n" +
-            " uniform sampler2D inputImageTexture2;\n" +
-            " \n" +
-            " void main()\n" +
-            " {\n" +
-            "     mediump vec4 base = texture2D(inputImageTexture, textureCoordinate);\n" +
-            "     mediump vec4 overlay = texture2D(inputImageTexture2, textureCoordinate2);\n" +
-            "     \n" +
-            "     gl_FragColor = base * (overlay.a * (base / base.a) + (2.0 * overlay * (1.0 - (base / base.a)))) + overlay * (1.0 - base.a) + base * (1.0 - overlay.a);\n" +
-            " }";
+
+    public static final String SOFT_LIGHT_BLEND_FRAGMENT_SHADER =
+            "varying highp vec2 textureCoordinate;\n" +
+                    " varying highp vec2 textureCoordinate2;\n" +
+                    "\n" +
+                    " uniform sampler2D inputImageTexture;\n" +
+                    " uniform sampler2D inputImageTexture2;\n" +
+                    " \n" +
+                    " void main()\n" +
+                    " {\n" +
+                    "     mediump vec4 base = texture2D(inputImageTexture, textureCoordinate);\n" +
+                    "     mediump vec4 overlay = texture2D(inputImageTexture2, textureCoordinate2);\n"
+                    +
+                    "     \n" +
+                    "     gl_FragColor = base * (overlay.a * (base / base.a) + (2.0 * overlay * (1.0 - (base / base.a)))) + overlay * (1.0 - base.a) + base * (1.0 - overlay.a);\n"
+                    +
+                    " }";
 
     public GPUImageSoftLightBlendFilter() {
         super(SOFT_LIGHT_BLEND_FRAGMENT_SHADER);
diff --git a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageSourceOverBlendFilter.java b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageSourceOverBlendFilter.java
index fd6a7b98..8d64f4d4 100644
--- a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageSourceOverBlendFilter.java
+++ b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageSourceOverBlendFilter.java
@@ -17,19 +17,23 @@
 package jp.co.cyberagent.android.gpuimage;
 
 public class GPUImageSourceOverBlendFilter extends GPUImageTwoInputFilter {
-    public static final String SOURCE_OVER_BLEND_FRAGMENT_SHADER = "varying highp vec2 textureCoordinate;\n" +
-            " varying highp vec2 textureCoordinate2;\n" +
-            " \n" +
-            " uniform sampler2D inputImageTexture;\n" +
-            " uniform sampler2D inputImageTexture2;\n" +
-            " \n" +
-            " void main()\n" +
-            " {\n" +
-            "   lowp vec4 textureColor = texture2D(inputImageTexture, textureCoordinate);\n" +
-            "   lowp vec4 textureColor2 = texture2D(inputImageTexture2, textureCoordinate2);\n" +
-            "   \n" +
-            "   gl_FragColor = mix(textureColor, textureColor2, textureColor2.a);\n" +
-            " }";
+
+    public static final String SOURCE_OVER_BLEND_FRAGMENT_SHADER =
+            "varying highp vec2 textureCoordinate;\n" +
+                    " varying highp vec2 textureCoordinate2;\n" +
+                    " \n" +
+                    " uniform sampler2D inputImageTexture;\n" +
+                    " uniform sampler2D inputImageTexture2;\n" +
+                    " \n" +
+                    " void main()\n" +
+                    " {\n" +
+                    "   lowp vec4 textureColor = texture2D(inputImageTexture, textureCoordinate);\n"
+                    +
+                    "   lowp vec4 textureColor2 = texture2D(inputImageTexture2, textureCoordinate2);\n"
+                    +
+                    "   \n" +
+                    "   gl_FragColor = mix(textureColor, textureColor2, textureColor2.a);\n" +
+                    " }";
 
     public GPUImageSourceOverBlendFilter() {
         super(SOURCE_OVER_BLEND_FRAGMENT_SHADER);
diff --git a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageSphereRefractionFilter.java b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageSphereRefractionFilter.java
index 6314cf19..2527b0da 100644
--- a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageSphereRefractionFilter.java
+++ b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageSphereRefractionFilter.java
@@ -20,6 +20,7 @@
 import android.opengl.GLES20;
 
 public class GPUImageSphereRefractionFilter extends GPUImageFilter {
+
     public static final String SPHERE_FRAGMENT_SHADER = "" +
             "varying highp vec2 textureCoordinate;\n" +
             "\n" +
@@ -32,18 +33,23 @@
             "\n" +
             "void main()\n" +
             "{\n" +
-            "highp vec2 textureCoordinateToUse = vec2(textureCoordinate.x, (textureCoordinate.y * aspectRatio + 0.5 - 0.5 * aspectRatio));\n" +
+            "highp vec2 textureCoordinateToUse = vec2(textureCoordinate.x, (textureCoordinate.y * aspectRatio + 0.5 - 0.5 * aspectRatio));\n"
+            +
             "highp float distanceFromCenter = distance(center, textureCoordinateToUse);\n" +
             "lowp float checkForPresenceWithinSphere = step(distanceFromCenter, radius);\n" +
             "\n" +
             "distanceFromCenter = distanceFromCenter / radius;\n" +
             "\n" +
-            "highp float normalizedDepth = radius * sqrt(1.0 - distanceFromCenter * distanceFromCenter);\n" +
-            "highp vec3 sphereNormal = normalize(vec3(textureCoordinateToUse - center, normalizedDepth));\n" +
+            "highp float normalizedDepth = radius * sqrt(1.0 - distanceFromCenter * distanceFromCenter);\n"
+            +
+            "highp vec3 sphereNormal = normalize(vec3(textureCoordinateToUse - center, normalizedDepth));\n"
+            +
             "\n" +
-            "highp vec3 refractedVector = refract(vec3(0.0, 0.0, -1.0), sphereNormal, refractiveIndex);\n" +
+            "highp vec3 refractedVector = refract(vec3(0.0, 0.0, -1.0), sphereNormal, refractiveIndex);\n"
+            +
             "\n" +
-            "gl_FragColor = texture2D(inputImageTexture, (refractedVector.xy + 1.0) * 0.5) * checkForPresenceWithinSphere;     \n" +
+            "gl_FragColor = texture2D(inputImageTexture, (refractedVector.xy + 1.0) * 0.5) * checkForPresenceWithinSphere;     \n"
+            +
             "}\n";
 
     private PointF mCenter;
diff --git a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageSubtractBlendFilter.java b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageSubtractBlendFilter.java
index 52b54ecc..f09b8055 100644
--- a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageSubtractBlendFilter.java
+++ b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageSubtractBlendFilter.java
@@ -17,19 +17,24 @@
 package jp.co.cyberagent.android.gpuimage;
 
 public class GPUImageSubtractBlendFilter extends GPUImageTwoInputFilter {
-    public static final String SUBTRACT_BLEND_FRAGMENT_SHADER = "varying highp vec2 textureCoordinate;\n" +
-            " varying highp vec2 textureCoordinate2;\n" +
-            "\n" +
-            " uniform sampler2D inputImageTexture;\n" +
-            " uniform sampler2D inputImageTexture2;\n" +
-            " \n" +
-            " void main()\n" +
-            " {\n" +
-            "   lowp vec4 textureColor = texture2D(inputImageTexture, textureCoordinate);\n" +
-            "   lowp vec4 textureColor2 = texture2D(inputImageTexture2, textureCoordinate2);\n" +
-            "\n" +
-            "   gl_FragColor = vec4(textureColor.rgb - textureColor2.rgb, textureColor.a);\n" +
-            " }";
+
+    public static final String SUBTRACT_BLEND_FRAGMENT_SHADER =
+            "varying highp vec2 textureCoordinate;\n" +
+                    " varying highp vec2 textureCoordinate2;\n" +
+                    "\n" +
+                    " uniform sampler2D inputImageTexture;\n" +
+                    " uniform sampler2D inputImageTexture2;\n" +
+                    " \n" +
+                    " void main()\n" +
+                    " {\n" +
+                    "   lowp vec4 textureColor = texture2D(inputImageTexture, textureCoordinate);\n"
+                    +
+                    "   lowp vec4 textureColor2 = texture2D(inputImageTexture2, textureCoordinate2);\n"
+                    +
+                    "\n" +
+                    "   gl_FragColor = vec4(textureColor.rgb - textureColor2.rgb, textureColor.a);\n"
+                    +
+                    " }";
 
     public GPUImageSubtractBlendFilter() {
         super(SUBTRACT_BLEND_FRAGMENT_SHADER);
diff --git a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageSwirlFilter.java b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageSwirlFilter.java
index d4947b9a..974f9aef 100644
--- a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageSwirlFilter.java
+++ b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageSwirlFilter.java
@@ -23,6 +23,7 @@
  * Creates a swirl distortion on the image.
  */
 public class GPUImageSwirlFilter extends GPUImageFilter {
+
     public static final String SWIRL_FRAGMENT_SHADER = "" +
             "varying highp vec2 textureCoordinate;\n" +
             "\n" +
@@ -43,7 +44,8 @@
             "highp float theta = percent * percent * angle * 8.0;\n" +
             "highp float s = sin(theta);\n" +
             "highp float c = cos(theta);\n" +
-            "textureCoordinateToUse = vec2(dot(textureCoordinateToUse, vec2(c, -s)), dot(textureCoordinateToUse, vec2(s, c)));\n" +
+            "textureCoordinateToUse = vec2(dot(textureCoordinateToUse, vec2(c, -s)), dot(textureCoordinateToUse, vec2(s, c)));\n"
+            +
             "textureCoordinateToUse += center;\n" +
             "}\n" +
             "\n" +
diff --git a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageThresholdEdgeDetection.java b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageThresholdEdgeDetection.java
index c136155a..3a2983c4 100644
--- a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageThresholdEdgeDetection.java
+++ b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageThresholdEdgeDetection.java
@@ -4,6 +4,7 @@
  * Applies sobel edge detection on the image.
  */
 public class GPUImageThresholdEdgeDetection extends GPUImageFilterGroup {
+
     public GPUImageThresholdEdgeDetection() {
         super();
         addFilter(new GPUImageGrayscaleFilter());
diff --git a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageToneCurveFilter.java b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageToneCurveFilter.java
index 0f6e1d08..4a3ef42b 100644
--- a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageToneCurveFilter.java
+++ b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageToneCurveFilter.java
@@ -27,6 +27,7 @@
 import java.util.Comparator;
 
 public class GPUImageToneCurveFilter extends GPUImageFilter {
+
     public static final String TONE_CURVE_FRAGMENT_SHADER = "" +
             " varying highp vec2 textureCoordinate;\n" +
             " uniform sampler2D inputImageTexture;\n" +
@@ -35,11 +36,15 @@
             " void main()\n" +
             " {\n" +
             "     lowp vec4 textureColor = texture2D(inputImageTexture, textureCoordinate);\n" +
-            "     lowp float redCurveValue = texture2D(toneCurveTexture, vec2(textureColor.r, 0.0)).r;\n" +
-            "     lowp float greenCurveValue = texture2D(toneCurveTexture, vec2(textureColor.g, 0.0)).g;\n" +
-            "     lowp float blueCurveValue = texture2D(toneCurveTexture, vec2(textureColor.b, 0.0)).b;\n" +
+            "     lowp float redCurveValue = texture2D(toneCurveTexture, vec2(textureColor.r, 0.0)).r;\n"
+            +
+            "     lowp float greenCurveValue = texture2D(toneCurveTexture, vec2(textureColor.g, 0.0)).g;\n"
+            +
+            "     lowp float blueCurveValue = texture2D(toneCurveTexture, vec2(textureColor.b, 0.0)).b;\n"
+            +
             "\n" +
-            "     gl_FragColor = vec4(redCurveValue, greenCurveValue, blueCurveValue, textureColor.a);\n" +
+            "     gl_FragColor = vec4(redCurveValue, greenCurveValue, blueCurveValue, textureColor.a);\n"
+            +
             " }";
 
     private int[] mToneCurveTexture = new int[]{OpenGlUtils.NO_TEXTURE};
@@ -55,11 +60,11 @@
     private ArrayList<Float> mGreenCurve;
     private ArrayList<Float> mBlueCurve;
 
-
     public GPUImageToneCurveFilter() {
         super(NO_FILTER_VERTEX_SHADER, TONE_CURVE_FRAGMENT_SHADER);
 
-        PointF[] defaultCurvePoints = new PointF[]{new PointF(0.0f, 0.0f), new PointF(0.5f, 0.5f), new PointF(1.0f, 1.0f)};
+        PointF[] defaultCurvePoints = new PointF[]{new PointF(0.0f, 0.0f), new PointF(0.5f, 0.5f),
+                new PointF(1.0f, 1.0f)};
         mRgbCompositeControlPoints = defaultCurvePoints;
         mRedControlPoints = defaultCurvePoints;
         mGreenControlPoints = defaultCurvePoints;
@@ -69,14 +74,19 @@ public GPUImageToneCurveFilter() {
     @Override
     public void onInit() {
         super.onInit();
-        mToneCurveTextureUniformLocation = GLES20.glGetUniformLocation(getProgram(), "toneCurveTexture");
+        mToneCurveTextureUniformLocation = GLES20
+                .glGetUniformLocation(getProgram(), "toneCurveTexture");
         GLES20.glActiveTexture(GLES20.GL_TEXTURE3);
         GLES20.glGenTextures(1, mToneCurveTexture, 0);
         GLES20.glBindTexture(GLES20.GL_TEXTURE_2D, mToneCurveTexture[0]);
-        GLES20.glTexParameteri(GLES20.GL_TEXTURE_2D, GLES20.GL_TEXTURE_MIN_FILTER, GLES20.GL_LINEAR);
-        GLES20.glTexParameteri(GLES20.GL_TEXTURE_2D, GLES20.GL_TEXTURE_MAG_FILTER, GLES20.GL_LINEAR);
-        GLES20.glTexParameteri(GLES20.GL_TEXTURE_2D, GLES20.GL_TEXTURE_WRAP_S, GLES20.GL_CLAMP_TO_EDGE);
-        GLES20.glTexParameteri(GLES20.GL_TEXTURE_2D, GLES20.GL_TEXTURE_WRAP_T, GLES20.GL_CLAMP_TO_EDGE);
+        GLES20.glTexParameteri(GLES20.GL_TEXTURE_2D, GLES20.GL_TEXTURE_MIN_FILTER,
+                GLES20.GL_LINEAR);
+        GLES20.glTexParameteri(GLES20.GL_TEXTURE_2D, GLES20.GL_TEXTURE_MAG_FILTER,
+                GLES20.GL_LINEAR);
+        GLES20.glTexParameteri(GLES20.GL_TEXTURE_2D, GLES20.GL_TEXTURE_WRAP_S,
+                GLES20.GL_CLAMP_TO_EDGE);
+        GLES20.glTexParameteri(GLES20.GL_TEXTURE_2D, GLES20.GL_TEXTURE_WRAP_T,
+                GLES20.GL_CLAMP_TO_EDGE);
     }
 
     @Override
@@ -165,22 +175,35 @@ public void setBlueControlPoints(PointF[] points) {
 
     private void updateToneCurveTexture() {
         runOnDraw(new Runnable() {
+
             @Override
             public void run() {
                 GLES20.glActiveTexture(GLES20.GL_TEXTURE3);
                 GLES20.glBindTexture(GLES20.GL_TEXTURE_2D, mToneCurveTexture[0]);
 
-                if ((mRedCurve.size() >= 256) && (mGreenCurve.size() >= 256) && (mBlueCurve.size() >= 256) && (mRgbCompositeCurve.size() >= 256)) {
+                if ((mRedCurve.size() >= 256) && (mGreenCurve.size() >= 256) && (mBlueCurve.size()
+                        >= 256) && (mRgbCompositeCurve.size() >= 256)) {
                     byte[] toneCurveByteArray = new byte[256 * 4];
                     for (int currentCurveIndex = 0; currentCurveIndex < 256; currentCurveIndex++) {
                         // BGRA for upload to texture
-                        toneCurveByteArray[currentCurveIndex * 4 + 2] = (byte) ((int) Math.min(Math.max(currentCurveIndex + mBlueCurve.get(currentCurveIndex) + mRgbCompositeCurve.get(currentCurveIndex), 0), 255) & 0xff);
-                        toneCurveByteArray[currentCurveIndex * 4 + 1] = (byte) ((int) Math.min(Math.max(currentCurveIndex + mGreenCurve.get(currentCurveIndex) + mRgbCompositeCurve.get(currentCurveIndex), 0), 255) & 0xff);
-                        toneCurveByteArray[currentCurveIndex * 4] = (byte) ((int) Math.min(Math.max(currentCurveIndex + mRedCurve.get(currentCurveIndex) + mRgbCompositeCurve.get(currentCurveIndex), 0), 255) & 0xff);
+                        toneCurveByteArray[currentCurveIndex * 4 + 2] = (byte) ((int) Math.min(Math
+                                .max(currentCurveIndex + mBlueCurve.get(currentCurveIndex)
+                                        + mRgbCompositeCurve.get(currentCurveIndex), 0), 255)
+                                & 0xff);
+                        toneCurveByteArray[currentCurveIndex * 4 + 1] = (byte) ((int) Math.min(Math
+                                .max(currentCurveIndex + mGreenCurve.get(currentCurveIndex)
+                                        + mRgbCompositeCurve.get(currentCurveIndex), 0), 255)
+                                & 0xff);
+                        toneCurveByteArray[currentCurveIndex * 4] = (byte) ((int) Math.min(Math
+                                .max(currentCurveIndex + mRedCurve.get(currentCurveIndex)
+                                        + mRgbCompositeCurve.get(currentCurveIndex), 0), 255)
+                                & 0xff);
                         toneCurveByteArray[currentCurveIndex * 4 + 3] = (byte) (255 & 0xff);
                     }
 
-                    GLES20.glTexImage2D(GLES20.GL_TEXTURE_2D, 0, GLES20.GL_RGBA, 256 /*width*/, 1 /*height*/, 0, GLES20.GL_RGBA, GLES20.GL_UNSIGNED_BYTE, ByteBuffer.wrap(toneCurveByteArray));
+                    GLES20.glTexImage2D(GLES20.GL_TEXTURE_2D, 0, GLES20.GL_RGBA, 256 /*width*/, 1 /*height*/,
+                            0, GLES20.GL_RGBA, GLES20.GL_UNSIGNED_BYTE,
+                            ByteBuffer.wrap(toneCurveByteArray));
                 }
 //        Buffer pixels!
 //        GLES20.glTexImage2D(int target,
@@ -204,6 +227,7 @@ public void run() {
         // Sort the array
         PointF[] pointsSorted = points.clone();
         Arrays.sort(pointsSorted, new Comparator<PointF>() {
+
             @Override
             public int compare(PointF point1, PointF point2) {
                 if (point1.x < point2.x) {
@@ -247,7 +271,8 @@ public int compare(PointF point1, PointF point2) {
         for (Point newPoint : splinePoints) {
             Point origPoint = new Point(newPoint.x, newPoint.x);
 
-            float distance = (float) Math.sqrt(Math.pow((origPoint.x - newPoint.x), 2.0) + Math.pow((origPoint.y - newPoint.y), 2.0));
+            float distance = (float) Math.sqrt(Math.pow((origPoint.x - newPoint.x), 2.0) + Math
+                    .pow((origPoint.y - newPoint.y), 2.0));
 
             if (origPoint.y > newPoint.y) {
                 distance = -distance;
@@ -275,7 +300,6 @@ public int compare(PointF point1, PointF point2) {
             sd[i] = sdA.get(i);
         }
 
-
         ArrayList<Point> output = new ArrayList<Point>(n + 1);
 
         for (int i = 0; i < n - 1; i++) {
@@ -289,7 +313,8 @@ public int compare(PointF point1, PointF point2) {
                 double b = t;
                 double h = next.x - cur.x;
 
-                double y = a * cur.y + b * next.y + (h * h / 6) * ((a * a * a - a) * sd[i] + (b * b * b - b) * sd[i + 1]);
+                double y = a * cur.y + b * next.y + (h * h / 6) * ((a * a * a - a) * sd[i]
+                        + (b * b * b - b) * sd[i + 1]);
 
                 if (y > 255.0) {
                     y = 255.0;
@@ -329,7 +354,8 @@ public int compare(PointF point1, PointF point2) {
             matrix[i][0] = (double) (P2.x - P1.x) / 6;
             matrix[i][1] = (double) (P3.x - P1.x) / 3;
             matrix[i][2] = (double) (P3.x - P2.x) / 6;
-            result[i] = (double) (P3.y - P2.y) / (P3.x - P2.x) - (double) (P2.y - P1.y) / (P2.x - P1.x);
+            result[i] =
+                    (double) (P3.y - P2.y) / (P3.x - P2.x) - (double) (P2.y - P1.y) / (P2.x - P1.x);
         }
 
         // What about result[0] and result[n-1]? Assuming 0 for now (Brad L.)
@@ -357,7 +383,9 @@ public int compare(PointF point1, PointF point2) {
         }
 
         ArrayList<Double> output = new ArrayList<Double>(n);
-        for (int i = 0; i < n; i++) output.add(result[i] / matrix[i][1]);
+        for (int i = 0; i < n; i++) {
+            output.add(result[i] / matrix[i][1]);
+        }
 
         return output;
     }
diff --git a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageToonFilter.java b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageToonFilter.java
index 5148d1d0..8f968170 100644
--- a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageToonFilter.java
+++ b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageToonFilter.java
@@ -19,10 +19,11 @@
 import android.opengl.GLES20;
 
 /**
- * This uses Sobel edge detection to place a black border around objects,
- * and then it quantizes the colors present in the image to give a cartoon-like quality to the image.
+ * This uses Sobel edge detection to place a black border around objects, and then it quantizes the
+ * colors present in the image to give a cartoon-like quality to the image.
  */
 public class GPUImageToonFilter extends GPUImage3x3TextureSamplingFilter {
+
     public static final String TOON_FRAGMENT_SHADER = "" +
             "precision highp float;\n" +
             "\n" +
@@ -50,20 +51,26 @@
             "{\n" +
             "vec4 textureColor = texture2D(inputImageTexture, textureCoordinate);\n" +
             "\n" +
-            "float bottomLeftIntensity = texture2D(inputImageTexture, bottomLeftTextureCoordinate).r;\n" +
-            "float topRightIntensity = texture2D(inputImageTexture, topRightTextureCoordinate).r;\n" +
+            "float bottomLeftIntensity = texture2D(inputImageTexture, bottomLeftTextureCoordinate).r;\n"
+            +
+            "float topRightIntensity = texture2D(inputImageTexture, topRightTextureCoordinate).r;\n"
+            +
             "float topLeftIntensity = texture2D(inputImageTexture, topLeftTextureCoordinate).r;\n" +
-            "float bottomRightIntensity = texture2D(inputImageTexture, bottomRightTextureCoordinate).r;\n" +
+            "float bottomRightIntensity = texture2D(inputImageTexture, bottomRightTextureCoordinate).r;\n"
+            +
             "float leftIntensity = texture2D(inputImageTexture, leftTextureCoordinate).r;\n" +
             "float rightIntensity = texture2D(inputImageTexture, rightTextureCoordinate).r;\n" +
             "float bottomIntensity = texture2D(inputImageTexture, bottomTextureCoordinate).r;\n" +
             "float topIntensity = texture2D(inputImageTexture, topTextureCoordinate).r;\n" +
-            "float h = -topLeftIntensity - 2.0 * topIntensity - topRightIntensity + bottomLeftIntensity + 2.0 * bottomIntensity + bottomRightIntensity;\n" +
-            "float v = -bottomLeftIntensity - 2.0 * leftIntensity - topLeftIntensity + bottomRightIntensity + 2.0 * rightIntensity + topRightIntensity;\n" +
+            "float h = -topLeftIntensity - 2.0 * topIntensity - topRightIntensity + bottomLeftIntensity + 2.0 * bottomIntensity + bottomRightIntensity;\n"
+            +
+            "float v = -bottomLeftIntensity - 2.0 * leftIntensity - topLeftIntensity + bottomRightIntensity + 2.0 * rightIntensity + topRightIntensity;\n"
+            +
             "\n" +
             "float mag = length(vec2(h, v));\n" +
             "\n" +
-            "vec3 posterizedImageColor = floor((textureColor.rgb * quantizationLevels) + 0.5) / quantizationLevels;\n" +
+            "vec3 posterizedImageColor = floor((textureColor.rgb * quantizationLevels) + 0.5) / quantizationLevels;\n"
+            +
             "\n" +
             "float thresholdTest = 1.0 - step(threshold, mag);\n" +
             "\n" +
@@ -89,7 +96,8 @@ public GPUImageToonFilter(float threshold, float quantizationLevels) {
     public void onInit() {
         super.onInit();
         mThresholdLocation = GLES20.glGetUniformLocation(getProgram(), "threshold");
-        mQuantizationLevelsLocation = GLES20.glGetUniformLocation(getProgram(), "quantizationLevels");
+        mQuantizationLevelsLocation = GLES20
+                .glGetUniformLocation(getProgram(), "quantizationLevels");
     }
 
     @Override
@@ -110,7 +118,8 @@ public void setThreshold(final float threshold) {
     }
 
     /**
-     * The levels of quantization for the posterization of colors within the scene, with a default of 10.0.
+     * The levels of quantization for the posterization of colors within the scene, with a default
+     * of 10.0.
      *
      * @param quantizationLevels default 10.0
      */
diff --git a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageTransformFilter.java b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageTransformFilter.java
index 0a962cc5..00f5eaf8 100644
--- a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageTransformFilter.java
+++ b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageTransformFilter.java
@@ -8,6 +8,7 @@
 import java.nio.FloatBuffer;
 
 public class GPUImageTransformFilter extends GPUImageFilter {
+
     public static final String TRANSFORM_VERTEX_SHADER = "" +
             "attribute vec4 position;\n" +
             " attribute vec4 inputTextureCoordinate;\n" +
@@ -65,7 +66,9 @@ public void onOutputSizeChanged(final int width, final int height) {
         super.onOutputSizeChanged(width, height);
 
         if (!ignoreAspectRatio) {
-            Matrix.orthoM(orthographicMatrix, 0, -1.0f, 1.0f, -1.0f * (float) height / (float) width, 1.0f * (float) height / (float) width, -1.0f, 1.0f);
+            Matrix.orthoM(orthographicMatrix, 0, -1.0f, 1.0f,
+                    -1.0f * (float) height / (float) width, 1.0f * (float) height / (float) width,
+                    -1.0f, 1.0f);
             setUniformMatrix4f(orthographicMatrixUniform, orthographicMatrix);
         }
     }
diff --git a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageTwoInputFilter.java b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageTwoInputFilter.java
index afc3b864..ec029eb7 100644
--- a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageTwoInputFilter.java
+++ b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageTwoInputFilter.java
@@ -21,10 +21,12 @@
 import java.nio.FloatBuffer;
 
 import jp.co.cyberagent.android.gpuimage.util.TextureRotationUtil;
+
 import android.graphics.Bitmap;
 import android.opengl.GLES20;
 
 public class GPUImageTwoInputFilter extends GPUImageFilter {
+
     private static final String VERTEX_SHADER = "attribute vec4 position;\n" +
             "attribute vec4 inputTextureCoordinate;\n" +
             "attribute vec4 inputTextureCoordinate2;\n" +
@@ -58,15 +60,17 @@ public GPUImageTwoInputFilter(String vertexShader, String fragmentShader) {
     public void onInit() {
         super.onInit();
 
-        mFilterSecondTextureCoordinateAttribute = GLES20.glGetAttribLocation(getProgram(), "inputTextureCoordinate2");
-        mFilterInputTextureUniform2 = GLES20.glGetUniformLocation(getProgram(), "inputImageTexture2"); // This does assume a name of "inputImageTexture2" for second input texture in the fragment shader
+        mFilterSecondTextureCoordinateAttribute = GLES20
+                .glGetAttribLocation(getProgram(), "inputTextureCoordinate2");
+        mFilterInputTextureUniform2 = GLES20.glGetUniformLocation(getProgram(),
+                "inputImageTexture2"); // This does assume a name of "inputImageTexture2" for second input texture in the fragment shader
         GLES20.glEnableVertexAttribArray(mFilterSecondTextureCoordinateAttribute);
 
-        if (mBitmap != null&&!mBitmap.isRecycled()) {
+        if (mBitmap != null && !mBitmap.isRecycled()) {
             setBitmap(mBitmap);
         }
     }
-    
+
     public void setBitmap(final Bitmap bitmap) {
         if (bitmap != null && bitmap.isRecycled()) {
             return;
@@ -76,13 +80,15 @@ public void setBitmap(final Bitmap bitmap) {
             return;
         }
         runOnDraw(new Runnable() {
+
             public void run() {
                 if (mFilterSourceTexture2 == OpenGlUtils.NO_TEXTURE) {
                     if (bitmap == null || bitmap.isRecycled()) {
                         return;
                     }
                     GLES20.glActiveTexture(GLES20.GL_TEXTURE3);
-                    mFilterSourceTexture2 = OpenGlUtils.loadTexture(bitmap, OpenGlUtils.NO_TEXTURE, false);
+                    mFilterSourceTexture2 = OpenGlUtils
+                            .loadTexture(bitmap, OpenGlUtils.NO_TEXTURE, false);
                 }
             }
         });
@@ -115,10 +121,12 @@ protected void onDrawArraysPre() {
         GLES20.glUniform1i(mFilterInputTextureUniform2, 3);
 
         mTexture2CoordinatesBuffer.position(0);
-        GLES20.glVertexAttribPointer(mFilterSecondTextureCoordinateAttribute, 2, GLES20.GL_FLOAT, false, 0, mTexture2CoordinatesBuffer);
+        GLES20.glVertexAttribPointer(mFilterSecondTextureCoordinateAttribute, 2, GLES20.GL_FLOAT,
+                false, 0, mTexture2CoordinatesBuffer);
     }
 
-    public void setRotation(final Rotation rotation, final boolean flipHorizontal, final boolean flipVertical) {
+    public void setRotation(final Rotation rotation, final boolean flipHorizontal,
+                            final boolean flipVertical) {
         float[] buffer = TextureRotationUtil.getRotation(rotation, flipHorizontal, flipVertical);
 
         ByteBuffer bBuffer = ByteBuffer.allocateDirect(32).order(ByteOrder.nativeOrder());
diff --git a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageTwoPassFilter.java b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageTwoPassFilter.java
index bf3fbf17..e391e48a 100644
--- a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageTwoPassFilter.java
+++ b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageTwoPassFilter.java
@@ -17,6 +17,7 @@
 package jp.co.cyberagent.android.gpuimage;
 
 public class GPUImageTwoPassFilter extends GPUImageFilterGroup {
+
     public GPUImageTwoPassFilter(String firstVertexShader, String firstFragmentShader,
                                  String secondVertexShader, String secondFragmentShader) {
         super(null);
diff --git a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageTwoPassTextureSamplingFilter.java b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageTwoPassTextureSamplingFilter.java
index 19c0365b..9a0b2fb2 100644
--- a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageTwoPassTextureSamplingFilter.java
+++ b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageTwoPassTextureSamplingFilter.java
@@ -19,8 +19,11 @@
 import android.opengl.GLES20;
 
 public class GPUImageTwoPassTextureSamplingFilter extends GPUImageTwoPassFilter {
-    public GPUImageTwoPassTextureSamplingFilter(String firstVertexShader, String firstFragmentShader,
-                                                String secondVertexShader, String secondFragmentShader) {
+
+    public GPUImageTwoPassTextureSamplingFilter(String firstVertexShader,
+                                                String firstFragmentShader,
+                                                String secondVertexShader,
+                                                String secondFragmentShader) {
         super(firstVertexShader, firstFragmentShader,
                 secondVertexShader, secondFragmentShader);
     }
@@ -34,15 +37,19 @@ public void onInit() {
     protected void initTexelOffsets() {
         float ratio = getHorizontalTexelOffsetRatio();
         GPUImageFilter filter = mFilters.get(0);
-        int texelWidthOffsetLocation = GLES20.glGetUniformLocation(filter.getProgram(), "texelWidthOffset");
-        int texelHeightOffsetLocation = GLES20.glGetUniformLocation(filter.getProgram(), "texelHeightOffset");
+        int texelWidthOffsetLocation = GLES20
+                .glGetUniformLocation(filter.getProgram(), "texelWidthOffset");
+        int texelHeightOffsetLocation = GLES20
+                .glGetUniformLocation(filter.getProgram(), "texelHeightOffset");
         filter.setFloat(texelWidthOffsetLocation, ratio / mOutputWidth);
         filter.setFloat(texelHeightOffsetLocation, 0);
 
         ratio = getVerticalTexelOffsetRatio();
         filter = mFilters.get(1);
-        texelWidthOffsetLocation = GLES20.glGetUniformLocation(filter.getProgram(), "texelWidthOffset");
-        texelHeightOffsetLocation = GLES20.glGetUniformLocation(filter.getProgram(), "texelHeightOffset");
+        texelWidthOffsetLocation = GLES20
+                .glGetUniformLocation(filter.getProgram(), "texelWidthOffset");
+        texelHeightOffsetLocation = GLES20
+                .glGetUniformLocation(filter.getProgram(), "texelHeightOffset");
         filter.setFloat(texelWidthOffsetLocation, 0);
         filter.setFloat(texelHeightOffsetLocation, ratio / mOutputHeight);
     }
diff --git a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageView.java b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageView.java
index cc6a0247..bf381c61 100644
--- a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageView.java
+++ b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageView.java
@@ -208,10 +208,10 @@ public void saveToPictures(final String folderName, final String fileName,
      * listener.
      *
      * @param folderName the folder name
-     * @param fileName   the file name
-     * @param width      requested output width
-     * @param height     requested output height
-     * @param listener   the listener
+     * @param fileName the file name
+     * @param width requested output width
+     * @param height requested output height
+     * @param listener the listener
      */
     public void saveToPictures(final String folderName, final String fileName,
                                int width, int height,
@@ -222,10 +222,9 @@ public void saveToPictures(final String folderName, final String fileName,
     /**
      * Retrieve current image with filter applied and given size as Bitmap.
      *
-     * @param width  requested Bitmap width
+     * @param width requested Bitmap width
      * @param height requested Bitmap height
      * @return Bitmap of picture with given size
-     * @throws InterruptedException
      */
     public Bitmap capture(final int width, final int height) throws InterruptedException {
         // This method needs to run on a background thread because it will take a longer time
@@ -238,18 +237,21 @@ public Bitmap capture(final int width, final int height) throws InterruptedExcep
         final Semaphore waiter = new Semaphore(0);
 
         // Layout with new size
-        getViewTreeObserver().addOnGlobalLayoutListener(new ViewTreeObserver.OnGlobalLayoutListener() {
-            @Override
-            public void onGlobalLayout() {
-                if (Build.VERSION.SDK_INT < Build.VERSION_CODES.JELLY_BEAN) {
-                    getViewTreeObserver().removeGlobalOnLayoutListener(this);
-                } else {
-                    getViewTreeObserver().removeOnGlobalLayoutListener(this);
-                }
-                waiter.release();
-            }
-        });
+        getViewTreeObserver()
+                .addOnGlobalLayoutListener(new ViewTreeObserver.OnGlobalLayoutListener() {
+
+                    @Override
+                    public void onGlobalLayout() {
+                        if (Build.VERSION.SDK_INT < Build.VERSION_CODES.JELLY_BEAN) {
+                            getViewTreeObserver().removeGlobalOnLayoutListener(this);
+                        } else {
+                            getViewTreeObserver().removeOnGlobalLayoutListener(this);
+                        }
+                        waiter.release();
+                    }
+                });
         post(new Runnable() {
+
             @Override
             public void run() {
                 // Show loading
@@ -262,6 +264,7 @@ public void run() {
 
         // Run one render pass
         mGPUImage.runOnGLThread(new Runnable() {
+
             @Override
             public void run() {
                 waiter.release();
@@ -271,9 +274,9 @@ public void run() {
         waiter.acquire();
         Bitmap bitmap = capture();
 
-
         mForceSize = null;
         post(new Runnable() {
+
             @Override
             public void run() {
                 mGLSurfaceView.requestLayout();
@@ -282,6 +285,7 @@ public void run() {
         requestRender();
 
         postDelayed(new Runnable() {
+
             @Override
             public void run() {
                 // Remove loading view
@@ -294,8 +298,8 @@ public void run() {
 
     /**
      * Capture the current image with the size as it is displayed and retrieve it as Bitmap.
+     *
      * @return current output as Bitmap
-     * @throws InterruptedException
      */
     public Bitmap capture() throws InterruptedException {
         final Semaphore waiter = new Semaphore(0);
@@ -306,16 +310,19 @@ public Bitmap capture() throws InterruptedException {
         // Take picture on OpenGL thread
         final int[] pixelMirroredArray = new int[width * height];
         mGPUImage.runOnGLThread(new Runnable() {
+
             @Override
             public void run() {
                 final IntBuffer pixelBuffer = IntBuffer.allocate(width * height);
-                GLES20.glReadPixels(0, 0, width, height, GLES20.GL_RGBA, GLES20.GL_UNSIGNED_BYTE, pixelBuffer);
+                GLES20.glReadPixels(0, 0, width, height, GLES20.GL_RGBA, GLES20.GL_UNSIGNED_BYTE,
+                        pixelBuffer);
                 int[] pixelArray = pixelBuffer.array();
 
                 // Convert upside down mirror-reversed image to right-side up normal image.
                 for (int i = 0; i < height; i++) {
                     for (int j = 0; j < width; j++) {
-                        pixelMirroredArray[(height - i - 1) * width + j] = pixelArray[i * width + j];
+                        pixelMirroredArray[(height - i - 1) * width + j] = pixelArray[i * width
+                                + j];
                     }
                 }
                 waiter.release();
@@ -344,6 +351,7 @@ public void onResume() {
     }
 
     public static class Size {
+
         int width;
         int height;
 
@@ -354,6 +362,7 @@ public Size(int width, int height) {
     }
 
     private class GPUImageGLSurfaceView extends GLSurfaceView {
+
         public GPUImageGLSurfaceView(Context context) {
             super(context);
         }
@@ -374,6 +383,7 @@ protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
     }
 
     private class LoadingView extends FrameLayout {
+
         public LoadingView(Context context) {
             super(context);
             init();
@@ -392,13 +402,15 @@ public LoadingView(Context context, AttributeSet attrs, int defStyle) {
         private void init() {
             ProgressBar view = new ProgressBar(getContext());
             view.setLayoutParams(
-                    new LayoutParams(LayoutParams.WRAP_CONTENT, LayoutParams.WRAP_CONTENT, Gravity.CENTER));
+                    new LayoutParams(LayoutParams.WRAP_CONTENT, LayoutParams.WRAP_CONTENT,
+                            Gravity.CENTER));
             addView(view);
             setBackgroundColor(Color.BLACK);
         }
     }
 
     private class SaveTask extends AsyncTask<Void, Void, Void> {
+
         private final String mFolderName;
         private final String mFileName;
         private final int mWidth;
@@ -444,6 +456,7 @@ private void saveImage(final String folderName, final String fileName, final Bit
                                 file.toString()
                         }, null,
                         new MediaScannerConnection.OnScanCompletedListener() {
+
                             @Override
                             public void onScanCompleted(final String path, final Uri uri) {
                                 if (mListener != null) {
@@ -464,6 +477,7 @@ public void run() {
     }
 
     public interface OnPictureSavedListener {
+
         void onPictureSaved(Uri uri);
     }
 }
diff --git a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageVignetteFilter.java b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageVignetteFilter.java
index 439e8bd0..797f4011 100644
--- a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageVignetteFilter.java
+++ b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageVignetteFilter.java
@@ -25,6 +25,7 @@
  * y: The directional intensity of the vignetting, with a default of x = 0.75, y = 0.5
  */
 public class GPUImageVignetteFilter extends GPUImageFilter {
+
     public static final String VIGNETTING_FRAGMENT_SHADER = "" +
             " uniform sampler2D inputImageTexture;\n" +
             " varying highp vec2 textureCoordinate;\n" +
@@ -44,9 +45,11 @@
             "      */\n" +
             "     \n" +
             "     lowp vec3 rgb = texture2D(inputImageTexture, textureCoordinate).rgb;\n" +
-            "     lowp float d = distance(textureCoordinate, vec2(vignetteCenter.x, vignetteCenter.y));\n" +
+            "     lowp float d = distance(textureCoordinate, vec2(vignetteCenter.x, vignetteCenter.y));\n"
+            +
             "     lowp float percent = smoothstep(vignetteStart, vignetteEnd, d);\n" +
-            "     gl_FragColor = vec4(mix(rgb.x, vignetteColor.x, percent), mix(rgb.y, vignetteColor.y, percent), mix(rgb.z, vignetteColor.z, percent), 1.0);\n" +
+            "     gl_FragColor = vec4(mix(rgb.x, vignetteColor.x, percent), mix(rgb.y, vignetteColor.y, percent), mix(rgb.z, vignetteColor.z, percent), 1.0);\n"
+            +
             " }";
 
     private int mVignetteCenterLocation;
@@ -57,18 +60,18 @@
     private float mVignetteStart;
     private int mVignetteEndLocation;
     private float mVignetteEnd;
-    
+
     public GPUImageVignetteFilter() {
-        this(new PointF(), new float[] {0.0f, 0.0f, 0.0f}, 0.3f, 0.75f);
+        this(new PointF(), new float[]{0.0f, 0.0f, 0.0f}, 0.3f, 0.75f);
     }
-    
-    public GPUImageVignetteFilter(final PointF vignetteCenter, final float[] vignetteColor, final float vignetteStart, final float vignetteEnd) {
+
+    public GPUImageVignetteFilter(final PointF vignetteCenter, final float[] vignetteColor,
+                                  final float vignetteStart, final float vignetteEnd) {
         super(NO_FILTER_VERTEX_SHADER, VIGNETTING_FRAGMENT_SHADER);
         mVignetteCenter = vignetteCenter;
         mVignetteColor = vignetteColor;
         mVignetteStart = vignetteStart;
         mVignetteEnd = vignetteEnd;
-        
     }
 
     @Override
@@ -78,14 +81,13 @@ public void onInit() {
         mVignetteColorLocation = GLES20.glGetUniformLocation(getProgram(), "vignetteColor");
         mVignetteStartLocation = GLES20.glGetUniformLocation(getProgram(), "vignetteStart");
         mVignetteEndLocation = GLES20.glGetUniformLocation(getProgram(), "vignetteEnd");
-        
+
         setVignetteCenter(mVignetteCenter);
         setVignetteColor(mVignetteColor);
         setVignetteStart(mVignetteStart);
         setVignetteEnd(mVignetteEnd);
     }
 
-
     public void setVignetteCenter(final PointF vignetteCenter) {
         mVignetteCenter = vignetteCenter;
         setPoint(mVignetteCenterLocation, mVignetteCenter);
@@ -95,12 +97,12 @@ public void setVignetteColor(final float[] vignetteColor) {
         mVignetteColor = vignetteColor;
         setFloatVec3(mVignetteColorLocation, mVignetteColor);
     }
-    
+
     public void setVignetteStart(final float vignetteStart) {
         mVignetteStart = vignetteStart;
         setFloat(mVignetteStartLocation, mVignetteStart);
     }
-    
+
     public void setVignetteEnd(final float vignetteEnd) {
         mVignetteEnd = vignetteEnd;
         setFloat(mVignetteEndLocation, mVignetteEnd);
diff --git a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageWeakPixelInclusionFilter.java b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageWeakPixelInclusionFilter.java
index 3e1b8f01..3f4cd75f 100644
--- a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageWeakPixelInclusionFilter.java
+++ b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageWeakPixelInclusionFilter.java
@@ -17,6 +17,7 @@
 package jp.co.cyberagent.android.gpuimage;
 
 public class GPUImageWeakPixelInclusionFilter extends GPUImage3x3TextureSamplingFilter {
+
     public static final String WEAKPIXEL_FRAGMENT_SHADER = "" +
             "precision lowp float;\n" +
             "\n" +
@@ -36,17 +37,21 @@
             "\n" +
             "void main()\n" +
             "{\n" +
-            "float bottomLeftIntensity = texture2D(inputImageTexture, bottomLeftTextureCoordinate).r;\n" +
-            "float topRightIntensity = texture2D(inputImageTexture, topRightTextureCoordinate).r;\n" +
+            "float bottomLeftIntensity = texture2D(inputImageTexture, bottomLeftTextureCoordinate).r;\n"
+            +
+            "float topRightIntensity = texture2D(inputImageTexture, topRightTextureCoordinate).r;\n"
+            +
             "float topLeftIntensity = texture2D(inputImageTexture, topLeftTextureCoordinate).r;\n" +
-            "float bottomRightIntensity = texture2D(inputImageTexture, bottomRightTextureCoordinate).r;\n" +
+            "float bottomRightIntensity = texture2D(inputImageTexture, bottomRightTextureCoordinate).r;\n"
+            +
             "float leftIntensity = texture2D(inputImageTexture, leftTextureCoordinate).r;\n" +
             "float rightIntensity = texture2D(inputImageTexture, rightTextureCoordinate).r;\n" +
             "float bottomIntensity = texture2D(inputImageTexture, bottomTextureCoordinate).r;\n" +
             "float topIntensity = texture2D(inputImageTexture, topTextureCoordinate).r;\n" +
             "float centerIntensity = texture2D(inputImageTexture, textureCoordinate).r;\n" +
             "\n" +
-            "float pixelIntensitySum = bottomLeftIntensity + topRightIntensity + topLeftIntensity + bottomRightIntensity + leftIntensity + rightIntensity + bottomIntensity + topIntensity + centerIntensity;\n" +
+            "float pixelIntensitySum = bottomLeftIntensity + topRightIntensity + topLeftIntensity + bottomRightIntensity + leftIntensity + rightIntensity + bottomIntensity + topIntensity + centerIntensity;\n"
+            +
             "float sumTest = step(1.5, pixelIntensitySum);\n" +
             "float pixelTest = step(0.01, centerIntensity);\n" +
             "\n" +
diff --git a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageWhiteBalanceFilter.java b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageWhiteBalanceFilter.java
index 1818da99..8d5b1d4b 100644
--- a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageWhiteBalanceFilter.java
+++ b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageWhiteBalanceFilter.java
@@ -21,10 +21,11 @@
 /**
  * Adjusts the white balance of incoming image. <br>
  * <br>
- * temperature: 
+ * temperature:
  * tint:
  */
 public class GPUImageWhiteBalanceFilter extends GPUImageFilter {
+
     public static final String WHITE_BALANCE_FRAGMENT_SHADER = "" +
             "uniform sampler2D inputImageTexture;\n" +
             "varying highp vec2 textureCoordinate;\n" +
@@ -34,8 +35,10 @@
             "\n" +
             "const lowp vec3 warmFilter = vec3(0.93, 0.54, 0.0);\n" +
             "\n" +
-            "const mediump mat3 RGBtoYIQ = mat3(0.299, 0.587, 0.114, 0.596, -0.274, -0.322, 0.212, -0.523, 0.311);\n" +
-            "const mediump mat3 YIQtoRGB = mat3(1.0, 0.956, 0.621, 1.0, -0.272, -0.647, 1.0, -1.105, 1.702);\n" +
+            "const mediump mat3 RGBtoYIQ = mat3(0.299, 0.587, 0.114, 0.596, -0.274, -0.322, 0.212, -0.523, 0.311);\n"
+            +
+            "const mediump mat3 YIQtoRGB = mat3(1.0, 0.956, 0.621, 1.0, -0.272, -0.647, 1.0, -1.105, 1.702);\n"
+            +
             "\n" +
             "void main()\n" +
             "{\n" +
@@ -46,9 +49,12 @@
             "	lowp vec3 rgb = YIQtoRGB * yiq;\n" +
             "\n" +
             "	lowp vec3 processed = vec3(\n" +
-            "		(rgb.r < 0.5 ? (2.0 * rgb.r * warmFilter.r) : (1.0 - 2.0 * (1.0 - rgb.r) * (1.0 - warmFilter.r))), //adjusting temperature\n" +
-            "		(rgb.g < 0.5 ? (2.0 * rgb.g * warmFilter.g) : (1.0 - 2.0 * (1.0 - rgb.g) * (1.0 - warmFilter.g))), \n" +
-            "		(rgb.b < 0.5 ? (2.0 * rgb.b * warmFilter.b) : (1.0 - 2.0 * (1.0 - rgb.b) * (1.0 - warmFilter.b))));\n" +
+            "		(rgb.r < 0.5 ? (2.0 * rgb.r * warmFilter.r) : (1.0 - 2.0 * (1.0 - rgb.r) * (1.0 - warmFilter.r))), //adjusting temperature\n"
+            +
+            "		(rgb.g < 0.5 ? (2.0 * rgb.g * warmFilter.g) : (1.0 - 2.0 * (1.0 - rgb.g) * (1.0 - warmFilter.g))), \n"
+            +
+            "		(rgb.b < 0.5 ? (2.0 * rgb.b * warmFilter.b) : (1.0 - 2.0 * (1.0 - rgb.b) * (1.0 - warmFilter.b))));\n"
+            +
             "\n" +
             "	gl_FragColor = vec4(mix(rgb, processed, temperature), source.a);\n" +
             "}";
@@ -61,7 +67,7 @@
     public GPUImageWhiteBalanceFilter() {
         this(5000.0f, 0.0f);
     }
-    
+
     public GPUImageWhiteBalanceFilter(final float temperature, final float tint) {
         super(NO_FILTER_VERTEX_SHADER, WHITE_BALANCE_FRAGMENT_SHADER);
         mTemperature = temperature;
@@ -78,14 +84,15 @@ public void onInit() {
         setTint(mTint);
     }
 
-
     public void setTemperature(final float temperature) {
         mTemperature = temperature;
-        setFloat(mTemperatureLocation, mTemperature < 5000 ? (float)(0.0004 * (mTemperature-5000.0)) : (float)(0.00006 * (mTemperature-5000.0)));
+        setFloat(mTemperatureLocation,
+                mTemperature < 5000 ? (float) (0.0004 * (mTemperature - 5000.0))
+                        : (float) (0.00006 * (mTemperature - 5000.0)));
     }
-    
+
     public void setTint(final float tint) {
         mTint = tint;
-        setFloat(mTintLocation, (float)(mTint/100.0));
+        setFloat(mTintLocation, (float) (mTint / 100.0));
     }
 }
diff --git a/library/src/jp/co/cyberagent/android/gpuimage/OpenGlUtils.java b/library/src/jp/co/cyberagent/android/gpuimage/OpenGlUtils.java
index e8589704..e6ececdc 100644
--- a/library/src/jp/co/cyberagent/android/gpuimage/OpenGlUtils.java
+++ b/library/src/jp/co/cyberagent/android/gpuimage/OpenGlUtils.java
@@ -26,6 +26,7 @@
 import android.util.Log;
 
 public class OpenGlUtils {
+
     public static final int NO_TEXTURE = -1;
 
     public static int loadTexture(final Bitmap img, final int usedTexId) {
@@ -82,7 +83,8 @@ public static int loadTexture(final IntBuffer data, final Size size, final int u
         return textures[0];
     }
 
-    public static int loadTextureAsBitmap(final IntBuffer data, final Size size, final int usedTexId) {
+    public static int loadTextureAsBitmap(final IntBuffer data, final Size size,
+                                          final int usedTexId) {
         Bitmap bitmap = Bitmap
                 .createBitmap(data.array(), size.width, size.height, Config.ARGB_8888);
         return loadTexture(bitmap, usedTexId);
diff --git a/library/src/jp/co/cyberagent/android/gpuimage/PixelBuffer.java b/library/src/jp/co/cyberagent/android/gpuimage/PixelBuffer.java
index ac23f599..73bddfab 100644
--- a/library/src/jp/co/cyberagent/android/gpuimage/PixelBuffer.java
+++ b/library/src/jp/co/cyberagent/android/gpuimage/PixelBuffer.java
@@ -36,6 +36,7 @@
 import android.util.Log;
 
 public class PixelBuffer {
+
     final static String TAG = "PixelBuffer";
     final static boolean LIST_CONFIGS = false;
 
@@ -58,7 +59,7 @@ public PixelBuffer(final int width, final int height) {
         mHeight = height;
 
         int[] version = new int[2];
-        int[] attribList = new int[] {
+        int[] attribList = new int[]{
                 EGL_WIDTH, mWidth,
                 EGL_HEIGHT, mHeight,
                 EGL_NONE
@@ -69,7 +70,7 @@ public PixelBuffer(final int width, final int height) {
         mEGLDisplay = mEGL.eglGetDisplay(EGL_DEFAULT_DISPLAY);
         mEGL.eglInitialize(mEGLDisplay, version);
         mEGLConfig = chooseConfig(); // Choosing a config is a little more
-                                     // complicated
+        // complicated
 
         // mEGLContext = mEGL.eglCreateContext(mEGLDisplay, mEGLConfig,
         // EGL_NO_CONTEXT, null);
@@ -136,7 +137,7 @@ public void destroy() {
     }
 
     private EGLConfig chooseConfig() {
-        int[] attribList = new int[] {
+        int[] attribList = new int[]{
                 EGL_DEPTH_SIZE, 0,
                 EGL_STENCIL_SIZE, 0,
                 EGL_RED_SIZE, 8,
@@ -202,7 +203,6 @@ private void convertToBitmap() {
                 iat[(mHeight - i - 1) * mWidth + j] = ia[i * mWidth + j];
             }
         }
-        
 
         mBitmap = Bitmap.createBitmap(mWidth, mHeight, Bitmap.Config.ARGB_8888);
         mBitmap.copyPixelsFromBuffer(IntBuffer.wrap(iat));
diff --git a/library/src/jp/co/cyberagent/android/gpuimage/Rotation.java b/library/src/jp/co/cyberagent/android/gpuimage/Rotation.java
index bd2e840e..525f8654 100644
--- a/library/src/jp/co/cyberagent/android/gpuimage/Rotation.java
+++ b/library/src/jp/co/cyberagent/android/gpuimage/Rotation.java
@@ -26,11 +26,16 @@
      */
     public int asInt() {
         switch (this) {
-            case NORMAL: return 0;
-            case ROTATION_90: return 90;
-            case ROTATION_180: return 180;
-            case ROTATION_270: return 270;
-            default: throw new IllegalStateException("Unknown Rotation!");
+            case NORMAL:
+                return 0;
+            case ROTATION_90:
+                return 90;
+            case ROTATION_180:
+                return 180;
+            case ROTATION_270:
+                return 270;
+            default:
+                throw new IllegalStateException("Unknown Rotation!");
         }
     }
 
@@ -42,13 +47,20 @@ public int asInt() {
      */
     public static Rotation fromInt(int rotation) {
         switch (rotation) {
-            case 0: return NORMAL;
-            case 90: return ROTATION_90;
-            case 180: return ROTATION_180;
-            case 270: return ROTATION_270;
-            case 360: return NORMAL;
-            default: throw new IllegalStateException(
-                    rotation + " is an unknown rotation. Needs to be either 0, 90, 180 or 270!");
+            case 0:
+                return NORMAL;
+            case 90:
+                return ROTATION_90;
+            case 180:
+                return ROTATION_180;
+            case 270:
+                return ROTATION_270;
+            case 360:
+                return NORMAL;
+            default:
+                throw new IllegalStateException(
+                        rotation
+                                + " is an unknown rotation. Needs to be either 0, 90, 180 or 270!");
         }
     }
 }
diff --git a/library/src/jp/co/cyberagent/android/gpuimage/util/TextureRotationUtil.java b/library/src/jp/co/cyberagent/android/gpuimage/util/TextureRotationUtil.java
index c439d914..c76dbba7 100644
--- a/library/src/jp/co/cyberagent/android/gpuimage/util/TextureRotationUtil.java
+++ b/library/src/jp/co/cyberagent/android/gpuimage/util/TextureRotationUtil.java
@@ -50,7 +50,7 @@ private TextureRotationUtil() {
     }
 
     public static float[] getRotation(final Rotation rotation, final boolean flipHorizontal,
-                                                         final boolean flipVertical) {
+                                      final boolean flipVertical) {
         float[] rotatedTex;
         switch (rotation) {
             case ROTATION_90:
@@ -86,7 +86,6 @@ private TextureRotationUtil() {
         return rotatedTex;
     }
 
-
     private static float flip(final float i) {
         if (i == 0.0f) {
             return 1.0f;
diff --git a/sample/AndroidManifest.xml b/sample/AndroidManifest.xml
index 855b72c5..6072412c 100644
--- a/sample/AndroidManifest.xml
+++ b/sample/AndroidManifest.xml
@@ -11,12 +11,12 @@
         android:allowBackup="true"
         android:hardwareAccelerated="true"
         android:icon="@drawable/ic_launcher"
-        android:largeHeap="true"
         android:label="@string/app_name"
-        android:theme="@style/AppTheme" >
+        android:largeHeap="true"
+        android:theme="@style/AppTheme">
         <activity
-            android:name=".activity.ActivityMain"
-            android:label="@string/title_activity_activity_main" >
+            android:label="@string/title_activity_activity_main"
+            android:name=".activity.ActivityMain">
             <intent-filter>
                 <action android:name="android.intent.action.MAIN" />
 
diff --git a/sample/build.gradle b/sample/build.gradle
index 878f820f..dfeb70ef 100644
--- a/sample/build.gradle
+++ b/sample/build.gradle
@@ -26,6 +26,7 @@ android {
     lintOptions {
         abortOnError true
     }
+    buildToolsVersion '25.0.0'
 }
 repositories {
     jcenter()
diff --git a/sample/res/layout/activity_camera.xml b/sample/res/layout/activity_camera.xml
index 16a64d0d..1f321aea 100644
--- a/sample/res/layout/activity_camera.xml
+++ b/sample/res/layout/activity_camera.xml
@@ -1,7 +1,7 @@
 <RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android"
     android:layout_width="match_parent"
     android:layout_height="match_parent"
-    android:orientation="vertical" >
+    android:orientation="vertical">
 
     <android.opengl.GLSurfaceView
         android:id="@+id/surfaceView"
@@ -24,7 +24,7 @@
         android:layout_alignParentBottom="true"
         android:background="#000000"
         android:gravity="center_vertical"
-        android:orientation="horizontal" >
+        android:orientation="horizontal">
 
         <SeekBar
             android:id="@+id/seekBar"
diff --git a/sample/res/layout/activity_main.xml b/sample/res/layout/activity_main.xml
index 6c13bf2f..99f62052 100644
--- a/sample/res/layout/activity_main.xml
+++ b/sample/res/layout/activity_main.xml
@@ -1,14 +1,14 @@
 <FrameLayout xmlns:android="http://schemas.android.com/apk/res/android"
     xmlns:tools="http://schemas.android.com/tools"
     android:layout_width="match_parent"
-    android:layout_height="match_parent" >
+    android:layout_height="match_parent">
 
     <LinearLayout
         android:layout_width="wrap_content"
         android:layout_height="wrap_content"
         android:layout_gravity="center"
         android:gravity="center"
-        android:orientation="vertical" >
+        android:orientation="vertical">
 
         <Button
             android:id="@+id/button_gallery"
diff --git a/sample/src/jp/co/cyberagent/android/gpuimage/sample/GPUImageFilterTools.java b/sample/src/jp/co/cyberagent/android/gpuimage/sample/GPUImageFilterTools.java
index 6f2f6dd4..460d7510 100644
--- a/sample/src/jp/co/cyberagent/android/gpuimage/sample/GPUImageFilterTools.java
+++ b/sample/src/jp/co/cyberagent/android/gpuimage/sample/GPUImageFilterTools.java
@@ -29,8 +29,9 @@
 import java.util.List;
 
 public class GPUImageFilterTools {
+
     public static void showDialog(final Context context,
-            final OnGpuImageFilterChosenListener listener) {
+                                  final OnGpuImageFilterChosenListener listener) {
         final FilterList filters = new FilterList();
         filters.addFilter("Contrast", FilterType.CONTRAST);
         filters.addFilter("Invert", FilterType.INVERT);
@@ -109,15 +110,15 @@ public static void showDialog(final Context context,
 
         filters.addFilter("Levels Min (Mid Adjust)", FilterType.LEVELS_FILTER_MIN);
 
-        filters. addFilter("Bilateral Blur", FilterType.BILATERAL_BLUR);
+        filters.addFilter("Bilateral Blur", FilterType.BILATERAL_BLUR);
 
         filters.addFilter("Transform (2-D)", FilterType.TRANSFORM2D);
 
-
         AlertDialog.Builder builder = new AlertDialog.Builder(context);
         builder.setTitle("Choose a filter");
         builder.setItems(filters.names.toArray(new String[filters.names.size()]),
                 new DialogInterface.OnClickListener() {
+
                     @Override
                     public void onClick(final DialogInterface dialog, final int item) {
                         listener.onGpuImageFilterChosenListener(
@@ -127,7 +128,8 @@ public void onClick(final DialogInterface dialog, final int item) {
         builder.create().show();
     }
 
-    private static GPUImageFilter createFilterForType(final Context context, final FilterType type) {
+    private static GPUImageFilter createFilterForType(final Context context,
+                                                      final FilterType type) {
         switch (type) {
             case CONTRAST:
                 return new GPUImageContrastFilter(2.0f);
@@ -153,7 +155,7 @@ private static GPUImageFilter createFilterForType(final Context context, final F
                 return new GPUImageSobelEdgeDetection();
             case THREE_X_THREE_CONVOLUTION:
                 GPUImage3x3ConvolutionFilter convolution = new GPUImage3x3ConvolutionFilter();
-                convolution.setConvolutionKernel(new float[] {
+                convolution.setConvolutionKernel(new float[]{
                         -1.0f, 0.0f, 1.0f,
                         -2.0f, 0.0f, 2.0f,
                         -1.0f, 0.0f, 1.0f
@@ -174,9 +176,9 @@ private static GPUImageFilter createFilterForType(final Context context, final F
             case EXPOSURE:
                 return new GPUImageExposureFilter(0.0f);
             case HIGHLIGHT_SHADOW:
-            	return new GPUImageHighlightShadowFilter(0.0f, 1.0f);
+                return new GPUImageHighlightShadowFilter(0.0f, 1.0f);
             case MONOCHROME:
-            	return new GPUImageMonochromeFilter(1.0f, new float[]{0.6f, 0.45f, 0.3f, 1.0f});
+                return new GPUImageMonochromeFilter(1.0f, new float[]{0.6f, 0.45f, 0.3f, 1.0f});
             case OPACITY:
                 return new GPUImageOpacityFilter(1.0f);
             case RGB:
@@ -187,7 +189,8 @@ private static GPUImageFilter createFilterForType(final Context context, final F
                 PointF centerPoint = new PointF();
                 centerPoint.x = 0.5f;
                 centerPoint.y = 0.5f;
-                return new GPUImageVignetteFilter(centerPoint, new float[] {0.0f, 0.0f, 0.0f}, 0.3f, 0.75f);
+                return new GPUImageVignetteFilter(centerPoint, new float[]{0.0f, 0.0f, 0.0f}, 0.3f,
+                        0.75f);
             case TONE_CURVE:
                 GPUImageToneCurveFilter toneCurveFilter = new GPUImageToneCurveFilter();
                 toneCurveFilter.setFromCurveFileInputStream(
@@ -208,7 +211,6 @@ private static GPUImageFilter createFilterForType(final Context context, final F
             case BLEND_EXCLUSION:
                 return createBlendFilter(context, GPUImageExclusionBlendFilter.class);
 
-
             case BLEND_HARD_LIGHT:
                 return createBlendFilter(context, GPUImageHardLightBlendFilter.class);
             case BLEND_LIGHTEN:
@@ -246,7 +248,8 @@ private static GPUImageFilter createFilterForType(final Context context, final F
 
             case LOOKUP_AMATORKA:
                 GPUImageLookupFilter amatorka = new GPUImageLookupFilter();
-                amatorka.setBitmap(BitmapFactory.decodeResource(context.getResources(), R.drawable.lookup_amatorka));
+                amatorka.setBitmap(BitmapFactory
+                        .decodeResource(context.getResources(), R.drawable.lookup_amatorka));
                 return amatorka;
             case GAUSSIAN_BLUR:
                 return new GPUImageGaussianBlurFilter();
@@ -306,13 +309,14 @@ private static GPUImageFilter createFilterForType(final Context context, final F
             default:
                 throw new IllegalStateException("No filter of that type!");
         }
-
     }
 
-    private static GPUImageFilter createBlendFilter(Context context, Class<? extends GPUImageTwoInputFilter> filterClass) {
+    private static GPUImageFilter createBlendFilter(Context context,
+                                                    Class<? extends GPUImageTwoInputFilter> filterClass) {
         try {
             GPUImageTwoInputFilter filter = filterClass.newInstance();
-            filter.setBitmap(BitmapFactory.decodeResource(context.getResources(), R.drawable.ic_launcher));
+            filter.setBitmap(
+                    BitmapFactory.decodeResource(context.getResources(), R.drawable.ic_launcher));
             return filter;
         } catch (Exception e) {
             e.printStackTrace();
@@ -321,6 +325,7 @@ private static GPUImageFilter createBlendFilter(Context context, Class<? extends
     }
 
     public interface OnGpuImageFilterChosenListener {
+
         void onGpuImageFilterChosenListener(GPUImageFilter filter);
     }
 
@@ -334,6 +339,7 @@ private static GPUImageFilter createBlendFilter(Context context, Class<? extends
     }
 
     private static class FilterList {
+
         public List<String> names = new LinkedList<String>();
         public List<FilterType> filters = new LinkedList<FilterType>();
 
@@ -344,6 +350,7 @@ public void addFilter(final String name, final FilterType filter) {
     }
 
     public static class FilterAdjuster {
+
         private final Adjuster<? extends GPUImageFilter> adjuster;
 
         public FilterAdjuster(final GPUImageFilter filter) {
@@ -409,8 +416,7 @@ public FilterAdjuster(final GPUImageFilter filter) {
                 adjuster = new BilateralAdjuster().filter(filter);
             } else if (filter instanceof GPUImageTransformFilter) {
                 adjuster = new RotateAdjuster().filter(filter);
-            }
-            else {
+            } else {
 
                 adjuster = null;
             }
@@ -427,6 +433,7 @@ public void adjust(final int percentage) {
         }
 
         private abstract class Adjuster<T extends GPUImageFilter> {
+
             private T filter;
 
             @SuppressWarnings("unchecked")
@@ -451,6 +458,7 @@ protected int range(final int percentage, final int start, final int end) {
         }
 
         private class SharpnessAdjuster extends Adjuster<GPUImageSharpenFilter> {
+
             @Override
             public void adjust(final int percentage) {
                 getFilter().setSharpness(range(percentage, -4.0f, 4.0f));
@@ -458,20 +466,23 @@ public void adjust(final int percentage) {
         }
 
         private class PixelationAdjuster extends Adjuster<GPUImagePixelationFilter> {
-          @Override
-          public void adjust(final int percentage) {
-              getFilter().setPixel(range(percentage, 1.0f, 100.0f));
-          }
+
+            @Override
+            public void adjust(final int percentage) {
+                getFilter().setPixel(range(percentage, 1.0f, 100.0f));
+            }
         }
 
         private class HueAdjuster extends Adjuster<GPUImageHueFilter> {
-          @Override
-          public void adjust(final int percentage) {
-            getFilter().setHue(range(percentage, 0.0f, 360.0f));
-          }
+
+            @Override
+            public void adjust(final int percentage) {
+                getFilter().setHue(range(percentage, 0.0f, 360.0f));
+            }
         }
 
         private class ContrastAdjuster extends Adjuster<GPUImageContrastFilter> {
+
             @Override
             public void adjust(final int percentage) {
                 getFilter().setContrast(range(percentage, 0.0f, 2.0f));
@@ -479,6 +490,7 @@ public void adjust(final int percentage) {
         }
 
         private class GammaAdjuster extends Adjuster<GPUImageGammaFilter> {
+
             @Override
             public void adjust(final int percentage) {
                 getFilter().setGamma(range(percentage, 0.0f, 3.0f));
@@ -486,6 +498,7 @@ public void adjust(final int percentage) {
         }
 
         private class BrightnessAdjuster extends Adjuster<GPUImageBrightnessFilter> {
+
             @Override
             public void adjust(final int percentage) {
                 getFilter().setBrightness(range(percentage, -1.0f, 1.0f));
@@ -493,6 +506,7 @@ public void adjust(final int percentage) {
         }
 
         private class SepiaAdjuster extends Adjuster<GPUImageSepiaFilter> {
+
             @Override
             public void adjust(final int percentage) {
                 getFilter().setIntensity(range(percentage, 0.0f, 2.0f));
@@ -500,6 +514,7 @@ public void adjust(final int percentage) {
         }
 
         private class SobelAdjuster extends Adjuster<GPUImageSobelEdgeDetection> {
+
             @Override
             public void adjust(final int percentage) {
                 getFilter().setLineSize(range(percentage, 0.0f, 5.0f));
@@ -507,6 +522,7 @@ public void adjust(final int percentage) {
         }
 
         private class EmbossAdjuster extends Adjuster<GPUImageEmbossFilter> {
+
             @Override
             public void adjust(final int percentage) {
                 getFilter().setIntensity(range(percentage, 0.0f, 4.0f));
@@ -514,6 +530,7 @@ public void adjust(final int percentage) {
         }
 
         private class PosterizeAdjuster extends Adjuster<GPUImagePosterizeFilter> {
+
             @Override
             public void adjust(final int percentage) {
                 // In theorie to 256, but only first 50 are interesting
@@ -522,6 +539,7 @@ public void adjust(final int percentage) {
         }
 
         private class GPU3x3TextureAdjuster extends Adjuster<GPUImage3x3TextureSamplingFilter> {
+
             @Override
             public void adjust(final int percentage) {
                 getFilter().setLineSize(range(percentage, 0.0f, 5.0f));
@@ -529,6 +547,7 @@ public void adjust(final int percentage) {
         }
 
         private class SaturationAdjuster extends Adjuster<GPUImageSaturationFilter> {
+
             @Override
             public void adjust(final int percentage) {
                 getFilter().setSaturation(range(percentage, 0.0f, 2.0f));
@@ -536,6 +555,7 @@ public void adjust(final int percentage) {
         }
 
         private class ExposureAdjuster extends Adjuster<GPUImageExposureFilter> {
+
             @Override
             public void adjust(final int percentage) {
                 getFilter().setExposure(range(percentage, -10.0f, 10.0f));
@@ -543,6 +563,7 @@ public void adjust(final int percentage) {
         }
 
         private class HighlightShadowAdjuster extends Adjuster<GPUImageHighlightShadowFilter> {
+
             @Override
             public void adjust(final int percentage) {
                 getFilter().setShadows(range(percentage, 0.0f, 1.0f));
@@ -551,6 +572,7 @@ public void adjust(final int percentage) {
         }
 
         private class MonochromeAdjuster extends Adjuster<GPUImageMonochromeFilter> {
+
             @Override
             public void adjust(final int percentage) {
                 getFilter().setIntensity(range(percentage, 0.0f, 1.0f));
@@ -559,6 +581,7 @@ public void adjust(final int percentage) {
         }
 
         private class OpacityAdjuster extends Adjuster<GPUImageOpacityFilter> {
+
             @Override
             public void adjust(final int percentage) {
                 getFilter().setOpacity(range(percentage, 0.0f, 1.0f));
@@ -566,6 +589,7 @@ public void adjust(final int percentage) {
         }
 
         private class RGBAdjuster extends Adjuster<GPUImageRGBFilter> {
+
             @Override
             public void adjust(final int percentage) {
                 getFilter().setRed(range(percentage, 0.0f, 1.0f));
@@ -575,6 +599,7 @@ public void adjust(final int percentage) {
         }
 
         private class WhiteBalanceAdjuster extends Adjuster<GPUImageWhiteBalanceFilter> {
+
             @Override
             public void adjust(final int percentage) {
                 getFilter().setTemperature(range(percentage, 2000.0f, 8000.0f));
@@ -583,6 +608,7 @@ public void adjust(final int percentage) {
         }
 
         private class VignetteAdjuster extends Adjuster<GPUImageVignetteFilter> {
+
             @Override
             public void adjust(final int percentage) {
                 getFilter().setVignetteStart(range(percentage, 0.0f, 1.0f));
@@ -590,6 +616,7 @@ public void adjust(final int percentage) {
         }
 
         private class DissolveBlendAdjuster extends Adjuster<GPUImageDissolveBlendFilter> {
+
             @Override
             public void adjust(final int percentage) {
                 getFilter().setMix(range(percentage, 0.0f, 1.0f));
@@ -597,6 +624,7 @@ public void adjust(final int percentage) {
         }
 
         private class GaussianBlurAdjuster extends Adjuster<GPUImageGaussianBlurFilter> {
+
             @Override
             public void adjust(final int percentage) {
                 getFilter().setBlurSize(range(percentage, 0.0f, 1.0f));
@@ -604,6 +632,7 @@ public void adjust(final int percentage) {
         }
 
         private class CrosshatchBlurAdjuster extends Adjuster<GPUImageCrosshatchFilter> {
+
             @Override
             public void adjust(final int percentage) {
                 getFilter().setCrossHatchSpacing(range(percentage, 0.0f, 0.06f));
@@ -612,6 +641,7 @@ public void adjust(final int percentage) {
         }
 
         private class BulgeDistortionAdjuster extends Adjuster<GPUImageBulgeDistortionFilter> {
+
             @Override
             public void adjust(final int percentage) {
                 getFilter().setRadius(range(percentage, 0.0f, 1.0f));
@@ -620,6 +650,7 @@ public void adjust(final int percentage) {
         }
 
         private class GlassSphereAdjuster extends Adjuster<GPUImageGlassSphereFilter> {
+
             @Override
             public void adjust(final int percentage) {
                 getFilter().setRadius(range(percentage, 0.0f, 1.0f));
@@ -627,6 +658,7 @@ public void adjust(final int percentage) {
         }
 
         private class HazeAdjuster extends Adjuster<GPUImageHazeFilter> {
+
             @Override
             public void adjust(final int percentage) {
                 getFilter().setDistance(range(percentage, -0.3f, 0.3f));
@@ -635,6 +667,7 @@ public void adjust(final int percentage) {
         }
 
         private class SphereRefractionAdjuster extends Adjuster<GPUImageSphereRefractionFilter> {
+
             @Override
             public void adjust(final int percentage) {
                 getFilter().setRadius(range(percentage, 0.0f, 1.0f));
@@ -642,6 +675,7 @@ public void adjust(final int percentage) {
         }
 
         private class SwirlAdjuster extends Adjuster<GPUImageSwirlFilter> {
+
             @Override
             public void adjust(final int percentage) {
                 getFilter().setAngle(range(percentage, 0.0f, 2.0f));
@@ -660,6 +694,7 @@ public void adjust(int percentage) {
         }
 
         private class LevelsMinMidAdjuster extends Adjuster<GPUImageLevelsFilter> {
+
             @Override
             public void adjust(int percentage) {
                 getFilter().setMin(0.0f, range(percentage, 0.0f, 1.0f), 1.0f);
@@ -667,6 +702,7 @@ public void adjust(int percentage) {
         }
 
         private class BilateralAdjuster extends Adjuster<GPUImageBilateralFilter> {
+
             @Override
             public void adjust(final int percentage) {
                 getFilter().setDistanceNormalizationFactor(range(percentage, 0.0f, 15.0f));
@@ -674,6 +710,7 @@ public void adjust(final int percentage) {
         }
 
         private class RotateAdjuster extends Adjuster<GPUImageTransformFilter> {
+
             @Override
             public void adjust(final int percentage) {
                 float[] transform = new float[16];
@@ -681,6 +718,5 @@ public void adjust(final int percentage) {
                 getFilter().setTransform3D(transform);
             }
         }
-
     }
 }
diff --git a/sample/src/jp/co/cyberagent/android/gpuimage/sample/activity/ActivityCamera.java b/sample/src/jp/co/cyberagent/android/gpuimage/sample/activity/ActivityCamera.java
index ba832284..fd8429b9 100644
--- a/sample/src/jp/co/cyberagent/android/gpuimage/sample/activity/ActivityCamera.java
+++ b/sample/src/jp/co/cyberagent/android/gpuimage/sample/activity/ActivityCamera.java
@@ -166,7 +166,7 @@ public void onPictureTaken(byte[] data, final Camera camera) {
 
                                     @Override
                                     public void onPictureSaved(final Uri
-                                            uri) {
+                                                                       uri) {
                                         pictureFile.delete();
                                         camera.startPreview();
                                         view.setRenderMode(GLSurfaceView.RENDERMODE_CONTINUOUSLY);
@@ -223,7 +223,7 @@ private void switchFilterTo(final GPUImageFilter filter) {
 
     @Override
     public void onProgressChanged(final SeekBar seekBar, final int progress,
-            final boolean fromUser) {
+                                  final boolean fromUser) {
         if (mFilterAdjuster != null) {
             mFilterAdjuster.adjust(progress);
         }
diff --git a/sample/src/jp/co/cyberagent/android/gpuimage/sample/activity/ActivityGallery.java b/sample/src/jp/co/cyberagent/android/gpuimage/sample/activity/ActivityGallery.java
index ad734823..99d8c48d 100644
--- a/sample/src/jp/co/cyberagent/android/gpuimage/sample/activity/ActivityGallery.java
+++ b/sample/src/jp/co/cyberagent/android/gpuimage/sample/activity/ActivityGallery.java
@@ -23,6 +23,7 @@
 import jp.co.cyberagent.android.gpuimage.sample.GPUImageFilterTools.FilterAdjuster;
 import jp.co.cyberagent.android.gpuimage.sample.GPUImageFilterTools.OnGpuImageFilterChosenListener;
 import jp.co.cyberagent.android.gpuimage.sample.R;
+
 import android.app.Activity;
 import android.content.Intent;
 import android.net.Uri;
@@ -57,7 +58,8 @@ public void onCreate(final Bundle savedInstanceState) {
     }
 
     @Override
-    protected void onActivityResult(final int requestCode, final int resultCode, final Intent data) {
+    protected void onActivityResult(final int requestCode, final int resultCode,
+                                    final Intent data) {
         switch (requestCode) {
             case REQUEST_PICK_IMAGE:
                 if (resultCode == RESULT_OK) {
@@ -84,7 +86,6 @@ public void onGpuImageFilterChosenListener(final GPUImageFilter filter) {
                         switchFilterTo(filter);
                         mGPUImageView.requestRender();
                     }
-
                 });
                 break;
             case R.id.button_save:
@@ -94,7 +95,6 @@ public void onGpuImageFilterChosenListener(final GPUImageFilter filter) {
             default:
                 break;
         }
-
     }
 
     @Override
@@ -121,7 +121,8 @@ private void switchFilterTo(final GPUImageFilter filter) {
     }
 
     @Override
-    public void onProgressChanged(final SeekBar seekBar, final int progress, final boolean fromUser) {
+    public void onProgressChanged(final SeekBar seekBar, final int progress,
+                                  final boolean fromUser) {
         if (mFilterAdjuster != null) {
             mFilterAdjuster.adjust(progress);
         }
diff --git a/sample/src/jp/co/cyberagent/android/gpuimage/sample/activity/ActivityMain.java b/sample/src/jp/co/cyberagent/android/gpuimage/sample/activity/ActivityMain.java
index 80600ee6..31fcfb16 100644
--- a/sample/src/jp/co/cyberagent/android/gpuimage/sample/activity/ActivityMain.java
+++ b/sample/src/jp/co/cyberagent/android/gpuimage/sample/activity/ActivityMain.java
@@ -25,29 +25,33 @@
 import android.support.v4.content.PermissionChecker;
 import android.view.View;
 import android.view.View.OnClickListener;
+
 import jp.co.cyberagent.android.gpuimage.sample.R;
 
 public class ActivityMain extends Activity implements OnClickListener {
 
-    @Override public void onCreate(final Bundle savedInstanceState) {
+    @Override
+    public void onCreate(final Bundle savedInstanceState) {
         super.onCreate(savedInstanceState);
         setContentView(R.layout.activity_main);
         findViewById(R.id.button_gallery).setOnClickListener(this);
         findViewById(R.id.button_camera).setOnClickListener(this);
     }
 
-    @Override public void onClick(final View v) {
+    @Override
+    public void onClick(final View v) {
         if (PermissionChecker.checkSelfPermission(this, Manifest.permission.CAMERA)
-            == PackageManager.PERMISSION_DENIED) {
-            ActivityCompat.requestPermissions(this, new String[] { Manifest.permission.CAMERA },
-                v.getId());
+                == PackageManager.PERMISSION_DENIED) {
+            ActivityCompat.requestPermissions(this, new String[]{Manifest.permission.CAMERA},
+                    v.getId());
         } else {
             startActivity(v.getId());
         }
     }
 
-    @Override public void onRequestPermissionsResult(int requestCode, String[] permissions,
-        int[] grantResults) {
+    @Override
+    public void onRequestPermissionsResult(int requestCode, String[] permissions,
+                                           int[] grantResults) {
         if (grantResults.length != 1 || grantResults[0] == PackageManager.PERMISSION_GRANTED) {
             startActivity(requestCode);
         } else {
diff --git a/sample/src/jp/co/cyberagent/android/gpuimage/sample/utils/CameraHelper.java b/sample/src/jp/co/cyberagent/android/gpuimage/sample/utils/CameraHelper.java
index 9fafc891..b1fe7936 100644
--- a/sample/src/jp/co/cyberagent/android/gpuimage/sample/utils/CameraHelper.java
+++ b/sample/src/jp/co/cyberagent/android/gpuimage/sample/utils/CameraHelper.java
@@ -18,6 +18,7 @@
 
 import static android.os.Build.VERSION.SDK_INT;
 import static android.os.Build.VERSION_CODES.GINGERBREAD;
+
 import android.app.Activity;
 import android.content.Context;
 import android.hardware.Camera;
@@ -25,6 +26,7 @@
 import android.view.Surface;
 
 public class CameraHelper {
+
     private final CameraHelperImpl mImpl;
 
     public CameraHelper(final Context context) {
@@ -36,6 +38,7 @@ public CameraHelper(final Context context) {
     }
 
     public interface CameraHelperImpl {
+
         int getNumberOfCameras();
 
         Camera openCamera(int id);
@@ -82,7 +85,7 @@ public void getCameraInfo(final int cameraId, final CameraInfo2 cameraInfo) {
     }
 
     public void setCameraDisplayOrientation(final Activity activity,
-            final int cameraId, final Camera camera) {
+                                            final int cameraId, final Camera camera) {
         int result = getCameraDisplayOrientation(activity, cameraId);
         camera.setDisplayOrientation(result);
     }
@@ -118,6 +121,7 @@ public int getCameraDisplayOrientation(final Activity activity, final int camera
     }
 
     public static class CameraInfo2 {
+
         public int facing;
         public int orientation;
     }
diff --git a/sample/src/jp/co/cyberagent/android/gpuimage/sample/utils/CameraHelperBase.java b/sample/src/jp/co/cyberagent/android/gpuimage/sample/utils/CameraHelperBase.java
index daceb838..acea65ba 100644
--- a/sample/src/jp/co/cyberagent/android/gpuimage/sample/utils/CameraHelperBase.java
+++ b/sample/src/jp/co/cyberagent/android/gpuimage/sample/utils/CameraHelperBase.java
@@ -18,6 +18,7 @@
 
 import jp.co.cyberagent.android.gpuimage.sample.utils.CameraHelper.CameraHelperImpl;
 import jp.co.cyberagent.android.gpuimage.sample.utils.CameraHelper.CameraInfo2;
+
 import android.content.Context;
 import android.content.pm.PackageManager;
 import android.hardware.Camera;
diff --git a/sample/src/jp/co/cyberagent/android/gpuimage/sample/utils/CameraHelperGB.java b/sample/src/jp/co/cyberagent/android/gpuimage/sample/utils/CameraHelperGB.java
index ec1ad63d..4bfcff19 100644
--- a/sample/src/jp/co/cyberagent/android/gpuimage/sample/utils/CameraHelperGB.java
+++ b/sample/src/jp/co/cyberagent/android/gpuimage/sample/utils/CameraHelperGB.java
@@ -18,6 +18,7 @@
 
 import jp.co.cyberagent.android.gpuimage.sample.utils.CameraHelper.CameraHelperImpl;
 import jp.co.cyberagent.android.gpuimage.sample.utils.CameraHelper.CameraInfo2;
+
 import android.annotation.TargetApi;
 import android.hardware.Camera;
 import android.hardware.Camera.CameraInfo;
