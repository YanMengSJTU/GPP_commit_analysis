diff --git a/library/src/main/java/jp/co/cyberagent/android/gpuimage/GPUImageTransformFilter.java b/library/src/main/java/jp/co/cyberagent/android/gpuimage/GPUImageTransformFilter.java
new file mode 100644
index 00000000..0a962cc5
--- /dev/null
+++ b/library/src/main/java/jp/co/cyberagent/android/gpuimage/GPUImageTransformFilter.java
@@ -0,0 +1,134 @@
+package jp.co.cyberagent.android.gpuimage;
+
+import android.opengl.GLES20;
+import android.opengl.Matrix;
+
+import java.nio.ByteBuffer;
+import java.nio.ByteOrder;
+import java.nio.FloatBuffer;
+
+public class GPUImageTransformFilter extends GPUImageFilter {
+    public static final String TRANSFORM_VERTEX_SHADER = "" +
+            "attribute vec4 position;\n" +
+            " attribute vec4 inputTextureCoordinate;\n" +
+            " \n" +
+            " uniform mat4 transformMatrix;\n" +
+            " uniform mat4 orthographicMatrix;\n" +
+            " \n" +
+            " varying vec2 textureCoordinate;\n" +
+            " \n" +
+            " void main()\n" +
+            " {\n" +
+            "     gl_Position = transformMatrix * vec4(position.xyz, 1.0) * orthographicMatrix;\n" +
+            "     textureCoordinate = inputTextureCoordinate.xy;\n" +
+            " }";
+
+    private int transformMatrixUniform;
+    private int orthographicMatrixUniform;
+    private float[] orthographicMatrix;
+
+    private float[] transform3D;
+
+    // This applies the transform to the raw frame data if set to YES, the default of NO takes the aspect ratio of the image input into account when rotating
+    private boolean ignoreAspectRatio;
+
+    // sets the anchor point to top left corner
+    private boolean anchorTopLeft;
+
+    public GPUImageTransformFilter() {
+        super(TRANSFORM_VERTEX_SHADER, NO_FILTER_FRAGMENT_SHADER);
+
+        orthographicMatrix = new float[16];
+        Matrix.orthoM(orthographicMatrix, 0, -1.0f, 1.0f, -1.0f, 1.0f, -1.0f, 1.0f);
+
+        transform3D = new float[16];
+        Matrix.setIdentityM(transform3D, 0);
+    }
+
+    @Override
+    public void onInit() {
+        super.onInit();
+        transformMatrixUniform = GLES20.glGetUniformLocation(getProgram(), "transformMatrix");
+        orthographicMatrixUniform = GLES20.glGetUniformLocation(getProgram(), "orthographicMatrix");
+
+        setUniformMatrix4f(transformMatrixUniform, transform3D);
+        setUniformMatrix4f(orthographicMatrixUniform, orthographicMatrix);
+    }
+
+    @Override
+    public void onInitialized() {
+        super.onInitialized();
+    }
+
+    @Override
+    public void onOutputSizeChanged(final int width, final int height) {
+        super.onOutputSizeChanged(width, height);
+
+        if (!ignoreAspectRatio) {
+            Matrix.orthoM(orthographicMatrix, 0, -1.0f, 1.0f, -1.0f * (float) height / (float) width, 1.0f * (float) height / (float) width, -1.0f, 1.0f);
+            setUniformMatrix4f(orthographicMatrixUniform, orthographicMatrix);
+        }
+    }
+
+    @Override
+    public void onDraw(final int textureId, final FloatBuffer cubeBuffer,
+                       final FloatBuffer textureBuffer) {
+
+        FloatBuffer vertBuffer = cubeBuffer;
+
+        if (!ignoreAspectRatio) {
+
+            float[] adjustedVertices = new float[8];
+
+            cubeBuffer.position(0);
+            cubeBuffer.get(adjustedVertices);
+
+            float normalizedHeight = (float) getOutputHeight() / (float) getOutputWidth();
+            adjustedVertices[1] *= normalizedHeight;
+            adjustedVertices[3] *= normalizedHeight;
+            adjustedVertices[5] *= normalizedHeight;
+            adjustedVertices[7] *= normalizedHeight;
+
+            vertBuffer = ByteBuffer.allocateDirect(adjustedVertices.length * 4)
+                    .order(ByteOrder.nativeOrder())
+                    .asFloatBuffer();
+
+            vertBuffer.put(adjustedVertices).position(0);
+        }
+
+        super.onDraw(textureId, vertBuffer, textureBuffer);
+    }
+
+    public void setTransform3D(float[] transform3D) {
+        this.transform3D = transform3D;
+        setUniformMatrix4f(transformMatrixUniform, transform3D);
+    }
+
+    public float[] getTransform3D() {
+        return transform3D;
+    }
+
+    public void setIgnoreAspectRatio(boolean ignoreAspectRatio) {
+        this.ignoreAspectRatio = ignoreAspectRatio;
+
+        if (ignoreAspectRatio) {
+            Matrix.orthoM(orthographicMatrix, 0, -1.0f, 1.0f, -1.0f, 1.0f, -1.0f, 1.0f);
+            setUniformMatrix4f(orthographicMatrixUniform, orthographicMatrix);
+        } else {
+            onOutputSizeChanged(getOutputWidth(), getOutputHeight());
+        }
+    }
+
+    public boolean ignoreAspectRatio() {
+        return ignoreAspectRatio;
+    }
+
+    public void setAnchorTopLeft(boolean anchorTopLeft) {
+        this.anchorTopLeft = anchorTopLeft;
+        setIgnoreAspectRatio(ignoreAspectRatio);
+    }
+
+    public boolean anchorTopLeft() {
+        return anchorTopLeft;
+    }
+}
diff --git a/sample/src/main/java/jp/co/cyberagent/android/gpuimage/sample/GPUImageFilterTools.java b/sample/src/main/java/jp/co/cyberagent/android/gpuimage/sample/GPUImageFilterTools.java
index be9bb178..fa29b14d 100644
--- a/sample/src/main/java/jp/co/cyberagent/android/gpuimage/sample/GPUImageFilterTools.java
+++ b/sample/src/main/java/jp/co/cyberagent/android/gpuimage/sample/GPUImageFilterTools.java
@@ -25,6 +25,7 @@
 import android.content.DialogInterface;
 import android.graphics.BitmapFactory;
 import android.graphics.PointF;
+import android.opengl.Matrix;
 
 public class GPUImageFilterTools {  
     public static void showDialog(final Context context,
@@ -81,6 +82,8 @@ public static void showDialog(final Context context,
 
         filters.addFilter("Lookup (Amatorka)", FilterType.LOOKUP_AMATORKA);
 
+        filters.addFilter("Transform (2-D)", FilterType.TRANSFORM2D);
+
         AlertDialog.Builder builder = new AlertDialog.Builder(context);
         builder.setTitle("Choose a filter");
         builder.setItems(filters.names.toArray(new String[filters.names.size()]),
@@ -215,6 +218,9 @@ private static GPUImageFilter createFilterForType(final Context context, final F
                 GPUImageLookupFilter amatorka = new GPUImageLookupFilter();
                 amatorka.setBitmap(BitmapFactory.decodeResource(context.getResources(), R.drawable.lookup_amatorka));
                 return amatorka;
+
+            case TRANSFORM2D:
+                return new GPUImageTransformFilter();
             default:
                 throw new IllegalStateException("No filter of that type!");
         }
@@ -240,7 +246,7 @@ private static GPUImageFilter createBlendFilter(Context context, Class<? extends
         CONTRAST, GRAYSCALE, SHARPEN, SEPIA, SOBEL_EDGE_DETECTION, THREE_X_THREE_CONVOLUTION, FILTER_GROUP, EMBOSS, POSTERIZE, GAMMA, BRIGHTNESS, INVERT, HUE, PIXELATION,
         SATURATION, EXPOSURE, HIGHLIGHT_SHADOW, MONOCHROME, OPACITY, RGB, WHITE_BALANCE, VIGNETTE, TONE_CURVE, BLEND_COLOR_BURN, BLEND_COLOR_DODGE, BLEND_DARKEN, BLEND_DIFFERENCE,
         BLEND_DISSOLVE, BLEND_EXCLUSION, BLEND_SOURCE_OVER, BLEND_HARD_LIGHT, BLEND_LIGHTEN, BLEND_ADD, BLEND_DIVIDE, BLEND_MULTIPLY, BLEND_OVERLAY, BLEND_SCREEN, BLEND_ALPHA,
-        BLEND_COLOR, BLEND_HUE, BLEND_SATURATION, BLEND_LUMINOSITY, BLEND_LINEAR_BURN, BLEND_SOFT_LIGHT, BLEND_SUBTRACT, BLEND_CHROMA_KEY, BLEND_NORMAL, LOOKUP_AMATORKA
+        BLEND_COLOR, BLEND_HUE, BLEND_SATURATION, BLEND_LUMINOSITY, BLEND_LINEAR_BURN, BLEND_SOFT_LIGHT, BLEND_SUBTRACT, BLEND_CHROMA_KEY, BLEND_NORMAL, LOOKUP_AMATORKA, TRANSFORM2D
     }
 
     private static class FilterList {
@@ -297,6 +303,8 @@ public FilterAdjuster(final GPUImageFilter filter) {
                 adjuster = new VignetteAdjuster().filter(filter);
             } else if (filter instanceof GPUImageDissolveBlendFilter) {
                 adjuster = new DissolveBlendAdjuster().filter(filter);
+            } else if (filter instanceof GPUImageTransformFilter) {
+                adjuster = new RotateAdjuster().filter(filter);
             } else {
                 adjuster = null;
             }
@@ -477,5 +485,14 @@ public void adjust(final int percentage) {
                 getFilter().setMix(range(percentage, 0.0f, 1.0f));
             }
         }
+
+        private class RotateAdjuster extends Adjuster<GPUImageTransformFilter> {
+            @Override
+            public void adjust(final int percentage) {
+                float[] transform = new float[16];
+                Matrix.setRotateM(transform, 0, 360 * percentage / 100, 0, 0, 1.0f);
+                getFilter().setTransform3D(transform);
+            }
+        }
     }
 }
