diff --git a/build.gradle b/build.gradle
index 23978521..d6c9e8b0 100644
--- a/build.gradle
+++ b/build.gradle
@@ -17,5 +17,8 @@ allprojects {
     }
     tasks.withType(JavaCompile) {
         options.encoding = 'UTF-8'
+        options.fork = true
+        options.forkOptions.jvmArgs += ["-Duser.language=en"]
+        options.compilerArgs += '-Xlint:unchecked'
     }
 }
diff --git a/library/build.gradle b/library/build.gradle
index 013802de..4a9c74cf 100644
--- a/library/build.gradle
+++ b/library/build.gradle
@@ -18,7 +18,7 @@ android {
             moduleName "gpuimage-library"
             stl "gnustl_shared"
             abiFilters "all"
-            ldLibs "log"
+            ldLibs "jnigraphics", "GLESv2", "log"
         }
     }
 
diff --git a/library/jni/copy-to-bitmap.c b/library/jni/copy-to-bitmap.c
new file mode 100644
index 00000000..7efe2a8b
--- /dev/null
+++ b/library/jni/copy-to-bitmap.c
@@ -0,0 +1,42 @@
+#include <jni.h>
+#include <android/log.h>
+#include <android/bitmap.h>
+#include <GLES/GL.h>
+
+#define LOGV(...) __android_log_print(ANDROID_LOG_VERBOSE, "libgpuimage", __VA_ARGS__)
+#define LOGD(...) __android_log_print(ANDROID_LOG_DEBUG  , "libgpuimage", __VA_ARGS__)
+#define LOGI(...) __android_log_print(ANDROID_LOG_INFO   , "libgpuimage", __VA_ARGS__)
+#define LOGW(...) __android_log_print(ANDROID_LOG_WARN   , "libgpuimage", __VA_ARGS__)
+#define LOGE(...) __android_log_print(ANDROID_LOG_ERROR  , "libgpuimage", __VA_ARGS__)
+
+// Image in Bitmap object will be upside down
+
+JNIEXPORT jboolean JNICALL Java_jp_co_cyberagent_android_gpuimage_GPUImageNativeLibrary_CopyToBitmap(JNIEnv * env, jclass clazz, jobject bitmap)
+{
+    AndroidBitmapInfo   BitmapInfo;
+    void *              pPixels;
+    int                 ret;
+
+    if ((ret = AndroidBitmap_getInfo(env, bitmap, &BitmapInfo)) < 0)
+    {
+        LOGE("Error - AndroidBitmap_getInfo() Failed! error: %d", ret);
+        return JNI_FALSE;
+    }
+
+    if (BitmapInfo.format != ANDROID_BITMAP_FORMAT_RGBA_8888)
+    {
+        LOGE("Error - Bitmap format is not RGBA_8888!");
+        return JNI_FALSE;
+    }
+
+    if ((ret = AndroidBitmap_lockPixels(env, bitmap, &pPixels)) < 0)
+    {
+        LOGE("Error - AndroidBitmap_lockPixels() Failed! error: %d", ret);
+        return JNI_FALSE;
+    }
+
+    glReadPixels(0, 0, BitmapInfo.width, BitmapInfo.height, GL_RGBA, GL_UNSIGNED_BYTE, pPixels);
+
+    AndroidBitmap_unlockPixels(env, bitmap);
+    return JNI_TRUE;
+}
diff --git a/library/src/jp/co/cyberagent/android/gpuimage/GPUImage.java b/library/src/jp/co/cyberagent/android/gpuimage/GPUImage.java
index 8392a5a9..0bc0d5f4 100644
--- a/library/src/jp/co/cyberagent/android/gpuimage/GPUImage.java
+++ b/library/src/jp/co/cyberagent/android/gpuimage/GPUImage.java
@@ -54,7 +54,7 @@
     private GLSurfaceView mGlSurfaceView;
     private GPUImageFilter mFilter;
     private Bitmap mCurrentBitmap;
-    private ScaleType mScaleType = ScaleType.CENTER_CROP;
+    private GPUImageScaleType mScaleType = GPUImageScaleType.CENTER_CROP;
 
     /**
      * Instantiates a new GPUImage object.
@@ -195,7 +195,7 @@ public void setImage(final Bitmap bitmap) {
      *
      * @param scaleType The new ScaleType
      */
-    public void setScaleType(ScaleType scaleType) {
+    public void setScaleType(GPUImageScaleType scaleType) {
         mScaleType = scaleType;
         mRenderer.setScaleType(scaleType);
         mRenderer.deleteImage();
@@ -637,7 +637,7 @@ private Bitmap scaleBitmap(Bitmap bitmap) {
                 System.gc();
             }
 
-            if (mScaleType == ScaleType.CENTER_CROP) {
+            if (mScaleType == GPUImageScaleType.CENTER_CROP) {
                 // Crop it
                 int diffWidth = newSize[0] - mOutputWidth;
                 int diffHeight = newSize[1] - mOutputHeight;
@@ -665,7 +665,7 @@ private Bitmap scaleBitmap(Bitmap bitmap) {
             float withRatio = (float) width / mOutputWidth;
             float heightRatio = (float) height / mOutputHeight;
 
-            boolean adjustWidth = mScaleType == ScaleType.CENTER_CROP
+            boolean adjustWidth = mScaleType == GPUImageScaleType.CENTER_CROP
                     ? withRatio > heightRatio : withRatio < heightRatio;
 
             if (adjustWidth) {
@@ -679,7 +679,7 @@ private Bitmap scaleBitmap(Bitmap bitmap) {
         }
 
         private boolean checkSize(boolean widthBigger, boolean heightBigger) {
-            if (mScaleType == ScaleType.CENTER_CROP) {
+            if (mScaleType == GPUImageScaleType.CENTER_CROP) {
                 return widthBigger && heightBigger;
             } else {
                 return widthBigger || heightBigger;
@@ -712,6 +712,4 @@ private Bitmap rotateImage(final Bitmap bitmap) {
     public interface ResponseListener<T> {
         void response(T item);
     }
-
-    public enum ScaleType { CENTER_INSIDE, CENTER_CROP }
 }
diff --git a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageGaussianBlurFilter.java b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageGaussianBlurFilter.java
index a5502feb..7a8e3891 100644
--- a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageGaussianBlurFilter.java
+++ b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageGaussianBlurFilter.java
@@ -37,21 +37,22 @@
                 "    blurOffset = vec2(texelHeightOffset, texelWidthOffset);\n" +
                 "}\n";
 
-    private static String fragmentShader(final int radius) {
-        if (1 > radius) {
+    private static String fragmentShader(final int maxRadius) {
+        if (1 > maxRadius) {
             return NO_FILTER_FRAGMENT_SHADER;
         }
-        final int samples = radius * 2 + 1;
+        final int maxSamples = maxRadius * 2 + 1;
         final String shaderString =
-                "const int SAMPLES = " + samples + ";\n" +
+                "const int SAMPLES = " + maxSamples + ";\n" +
                 "uniform sampler2D inputImageTexture;\n" +
+                "uniform int blurSample;\n" +
                 "uniform float blurSteps[SAMPLES];\n" +
                 "uniform float blurWeights[SAMPLES];\n" +
                 "varying vec2 blurCoordinate;\n" +
                 "varying vec2 blurOffset;\n" +
                 "void main() {\n" +
                 "    lowp vec4 sum = vec4(0.0);\n" +
-                "    for (int i = 0; i < SAMPLES; ++i) {\n" +
+                "    for (int i = 0; i < blurSample; ++i) {\n" +
                 "        lowp vec2 coordinate = blurCoordinate + blurOffset * blurSteps[i];\n" +
                 "        sum += texture2D(inputImageTexture, coordinate) * blurWeights[i];\n" +
                 "    }\n" +
@@ -65,7 +66,7 @@ private void prepareArrays(final int radius, final float sigma) {
         final int samples = radius * 2 + 1;
         final int weights = radius + 1;
         float sumOfWeights = 0.0f;
-        mWeights = new float[samples];
+//        mWeights = new float[samples];
         for (i = 0; i < weights; ++i) {
             final float weight = (float) ((1.0 / Math.sqrt(2.0 * Math.PI * Math.pow(sigma, 2.0))) * Math.exp(-Math.pow(i, 2.0) / (2.0 * Math.pow(sigma, 2.0))));
             if (0 == i) {
@@ -82,29 +83,51 @@ private void prepareArrays(final int radius, final float sigma) {
             mWeights[samples - i - 1] = mWeights[i];
         }
 
-        mOffsets = new float[samples];
+//        mOffsets = new float[samples];
         int offset = -radius;
         for (i = 0; i < samples; ++i) {
             mOffsets[i] = offset;
             ++offset;
         }
+        for (; i < mMaxSamples; ++i) {
+            mWeights[i] = 0;
+        }
     }
 
     protected float mBlurSize = 1f;
-    protected int mRadiusInPixel = 2;
+    private int mMaxSamples;
+    private int mMaxRadiusInPixel;
+    private int mRadiusInPixel; // sigma
+    private int mRadius;
     private float mWeights[];
     private float mOffsets[];
+    private int mWeightsLocation[];
+    private int mOffsetsLocation[];
+    private int mSampleLocation[];
 
     public GPUImageGaussianBlurFilter() {
-        this(1.0f, 2, getRadius(2));
+        this(getRadius(12), 2);
+    }
+
+    public GPUImageGaussianBlurFilter(final int maxRadiusInPiexel, final int radiusInPixel) {
+        this(1.0f, radiusInPixel, maxRadiusInPiexel, getRadius(maxRadiusInPiexel));
     }
 
-    public GPUImageGaussianBlurFilter(float blurSize, int radiusInPixel, int radius) {
-        super(CONTRAST_FRAGMENT_SHADER, fragmentShader(radius),
-                CONTRAST_FRAGMENT_SHADER, fragmentShader(radius));
+    public GPUImageGaussianBlurFilter(float blurSize, int radiusInPixel,
+                                      int maxRadiusInPiexel, int maxRadius) {
+        super(CONTRAST_FRAGMENT_SHADER, fragmentShader(maxRadius),
+                CONTRAST_FRAGMENT_SHADER, fragmentShader(maxRadius));
         mBlurSize = blurSize;
+        mMaxSamples = maxRadius * 2 + 1;
+        mMaxRadiusInPixel = maxRadiusInPiexel;
         mRadiusInPixel = radiusInPixel;
-        prepareArrays(radius, radiusInPixel);
+        mRadius = getRadius(radiusInPixel);
+        mOffsets = new float[mMaxSamples];
+        mWeights = new float[mMaxSamples];
+        mWeightsLocation = new int[2];
+        mOffsetsLocation = new int[2];
+        mSampleLocation = new int[2];
+        prepareArrays(mRadius, mRadiusInPixel);
     }
 
 //    @Override
@@ -115,7 +138,10 @@ public GPUImageGaussianBlurFilter(float blurSize, int radiusInPixel, int radius)
     @Override
     public void onInitialized() {
         super.onInitialized();
-        setArrays();
+        initLocaltion(0);
+        initLocaltion(1);
+        setUniforms(0);
+        setUniforms(1);
     }
 
     @Override
@@ -143,17 +169,18 @@ public void run() {
         });
     }
 
-    public void setArrays() {
-        GPUImageFilter filter = mFilters.get(0);
-        int location = GLES20.glGetUniformLocation(filter.getProgram(), "blurSteps");
-        filter.setFloatArray(location, mOffsets);
-        location = GLES20.glGetUniformLocation(filter.getProgram(), "blurWeights");
-        filter.setFloatArray(location, mWeights);
-        filter = mFilters.get(1);
-        location = GLES20.glGetUniformLocation(filter.getProgram(), "blurSteps");
-        filter.setFloatArray(location, mOffsets);
-        location = GLES20.glGetUniformLocation(filter.getProgram(), "blurWeights");
-        filter.setFloatArray(location, mWeights);
+    private void initLocaltion(int index) {
+        GPUImageFilter filter = mFilters.get(index);
+        mOffsetsLocation[index] = GLES20.glGetUniformLocation(filter.getProgram(), "blurSteps");
+        mWeightsLocation[index] = GLES20.glGetUniformLocation(filter.getProgram(), "blurWeights");
+        mSampleLocation[index] = GLES20.glGetUniformLocation(filter.getProgram(), "blurSample");
+    }
+
+    public void setUniforms(int index) {
+        GPUImageFilter filter = mFilters.get(index);
+        filter.setFloatArray(mOffsetsLocation[index], mOffsets);
+        filter.setFloatArray(mWeightsLocation[index], mWeights);
+        filter.setInteger(mSampleLocation[index], mRadius * 2 + 1);
     }
 
     private static int getRadius(final int radiusInPixel) {
@@ -166,23 +193,19 @@ private static int getRadius(final int radiusInPixel) {
 
     public void setRadiusInPixel(final int radiusInPixel) {
         if (mRadiusInPixel == radiusInPixel
-                || 1 > radiusInPixel) {
+                || 1 > radiusInPixel
+                || mMaxRadiusInPixel < radiusInPixel) {
             return;
         }
         mRadiusInPixel = radiusInPixel;
+        mRadius = getRadius(mRadiusInPixel);
+        prepareArrays(mRadius, mRadiusInPixel);
 
         runOnDraw(new Runnable() {
             @Override
             public void run() {
-                destroyFilters();
-                int sampleRadius = getRadius(mRadiusInPixel);
-                String fragmentShader = fragmentShader(sampleRadius);
-                addFilter(new GPUImageFilter(CONTRAST_FRAGMENT_SHADER, fragmentShader));
-                addFilter(new GPUImageFilter(CONTRAST_FRAGMENT_SHADER, fragmentShader));
-                initFilters();
-                initTexelOffsets();
-                prepareArrays(sampleRadius, radiusInPixel);
-                setArrays();
+                setUniforms(0);
+                setUniforms(1);
             }
         });
     }
diff --git a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageLite.java b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageLite.java
new file mode 100644
index 00000000..14e50a32
--- /dev/null
+++ b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageLite.java
@@ -0,0 +1,182 @@
+package jp.co.cyberagent.android.gpuimage;
+
+import android.app.ActivityManager;
+import android.content.Context;
+import android.content.pm.ConfigurationInfo;
+import android.graphics.Bitmap;
+import android.opengl.GLSurfaceView;
+
+/**
+ * Created by Administrator on 2016/9/16.
+ */
+public class GPUImageLite {
+    private final Context mContext;
+    private final GPUImageRenderer mRenderer;
+    private GPUImageFilter mFilter;
+    private Bitmap mCurrentBitmap;
+    private GPUImageScaleType mScaleType = GPUImageScaleType.CENTER_CROP;
+    private PixelBuffer mPixelBuffer;
+
+    public GPUImageLite(final Context context) {
+        if (!supportsOpenGLES2(context)) {
+            throw new IllegalStateException("OpenGL ES 2.0 is not supported on this phone.");
+        }
+
+        mContext = context;
+        mFilter = new GPUImageFilter();
+        mRenderer = new GPUImageRenderer(mFilter);
+    }
+
+    /**
+     * Checks if OpenGL ES 2.0 is supported on the current device.
+     *
+     * @param context the context
+     * @return true, if successful
+     */
+    private boolean supportsOpenGLES2(final Context context) {
+        final ActivityManager activityManager = (ActivityManager)
+                context.getSystemService(Context.ACTIVITY_SERVICE);
+        final ConfigurationInfo configurationInfo =
+                activityManager.getDeviceConfigurationInfo();
+        return configurationInfo.reqGlEsVersion >= 0x20000;
+    }
+
+    /**
+     * Sets the background color
+     *
+     * @param red red color value
+     * @param green green color value
+     * @param blue red color value
+     */
+    public void setBackgroundColor(float red, float green, float blue) {
+        mRenderer.setBackgroundColor(red, green, blue);
+    }
+
+    /**
+     * Request the preview to be rendered again.
+     */
+    public void requestRender() {
+    }
+
+    /**
+     * Sets the filter which should be applied to the image which was (or will
+     * be) set by setImage(...).
+     *
+     * @param filter the new filter
+     */
+    public void setFilter(final GPUImageFilter filter) {
+        if (mFilter == filter) {
+            return;
+        }
+        if (null != mFilter) {
+            mFilter.destroy();
+        }
+        mFilter = filter;
+        mRenderer.setFilter(mFilter);
+        requestRender();
+    }
+
+    /**
+     * Sets the image on which the filter should be applied.
+     *
+     * @param bitmap the new image
+     */
+    public void setImage(final Bitmap bitmap) {
+        mCurrentBitmap = bitmap;
+        mPixelBuffer = new PixelBuffer(mCurrentBitmap.getWidth(), mCurrentBitmap.getHeight());
+        mPixelBuffer.setRenderer(mRenderer);
+        mRenderer.setImageBitmap(bitmap, false);
+        requestRender();
+    }
+
+    /**
+     * This sets the scale type of GPUImage. This has to be run before setting the image.
+     * If image is set and scale type changed, image needs to be reset.
+     *
+     * @param scaleType The new ScaleType
+     */
+    public void setScaleType(GPUImageScaleType scaleType) {
+        mScaleType = scaleType;
+        mRenderer.setScaleType(scaleType);
+        mRenderer.deleteImage();
+        mCurrentBitmap = null;
+        requestRender();
+    }
+
+    /**
+     * Sets the rotation of the displayed image.
+     *
+     * @param rotation new rotation
+     */
+    public void setRotation(Rotation rotation) {
+        mRenderer.setRotation(rotation);
+    }
+
+    /**
+     * Sets the rotation of the displayed image with flip options.
+     *
+     * @param rotation new rotation
+     */
+    public void setRotation(Rotation rotation, boolean flipHorizontal, boolean flipVertical) {
+        mRenderer.setRotation(rotation, flipHorizontal, flipVertical);
+    }
+
+    /**
+     * Deletes the current image.
+     */
+    public void deleteImage() {
+        mRenderer.deleteImage();
+        if (null != mCurrentBitmap) {
+            mCurrentBitmap.recycle();
+            mCurrentBitmap = null;
+        }
+        requestRender();
+    }
+
+    public void fillBitmapWithFilterApplied(Bitmap bitmap) {
+        if (null != mPixelBuffer) {
+            mPixelBuffer.getBitmap(bitmap);
+        }
+    }
+
+    /**
+     * Gets the current displayed image with applied filter as a Bitmap.
+     *
+     * @return the current image with filter applied
+     */
+    public Bitmap getBitmapWithFilterApplied() {
+        if (null != mPixelBuffer) {
+            return mPixelBuffer.getBitmap();
+        }
+        return null;
+    }
+
+    /**
+     * Gets the given bitmap with current filter applied as a Bitmap.
+     *
+     * @param bitmap the bitmap on which the current filter should be applied
+     * @return the bitmap with filter applied
+     */
+    public Bitmap getBitmapWithFilterApplied(final Bitmap bitmap) {
+
+        GPUImageRenderer renderer = new GPUImageRenderer(mFilter);
+        renderer.setRotation(Rotation.NORMAL,
+                mRenderer.isFlippedHorizontally(), mRenderer.isFlippedVertically());
+        renderer.setScaleType(mScaleType);
+        PixelBuffer buffer = new PixelBuffer(bitmap.getWidth(), bitmap.getHeight());
+        buffer.setRenderer(renderer);
+        renderer.setImageBitmap(bitmap, false);
+        Bitmap result = buffer.getBitmap();
+        mFilter.destroy();
+        renderer.deleteImage();
+        buffer.destroy();
+
+        mRenderer.setFilter(mFilter);
+        if (mCurrentBitmap != null) {
+            mRenderer.setImageBitmap(mCurrentBitmap, false);
+        }
+        requestRender();
+
+        return result;
+    }
+}
diff --git a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageNativeLibrary.java b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageNativeLibrary.java
index ce8c31b8..7868e7d2 100644
--- a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageNativeLibrary.java
+++ b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageNativeLibrary.java
@@ -16,6 +16,8 @@
 
 package jp.co.cyberagent.android.gpuimage;
 
+import android.graphics.Bitmap;
+
 public class GPUImageNativeLibrary {
     static {
         System.loadLibrary("gpuimage-library");
@@ -24,4 +26,6 @@
     public static native void YUVtoRBGA(byte[] yuv, int width, int height, int[] out);
 
     public static native void YUVtoARBG(byte[] yuv, int width, int height, int[] out);
+
+    public static native boolean CopyToBitmap(Bitmap bitmap);
 }
diff --git a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageRenderer.java b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageRenderer.java
index 691550bd..742eb59f 100644
--- a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageRenderer.java
+++ b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageRenderer.java
@@ -71,7 +71,7 @@
     private Rotation mRotation;
     private boolean mFlipHorizontal;
     private boolean mFlipVertical;
-    private GPUImage.ScaleType mScaleType = GPUImage.ScaleType.CENTER_CROP;
+    private GPUImageScaleType mScaleType = GPUImageScaleType.CENTER_CROP;
 
     private float mBackgroundRed = 0;
     private float mBackgroundGreen = 0;
@@ -255,7 +255,7 @@ public void run() {
         });
     }
 
-    public void setScaleType(GPUImage.ScaleType scaleType) {
+    public void setScaleType(GPUImageScaleType scaleType) {
         mScaleType = scaleType;
     }
 
@@ -286,7 +286,7 @@ private void adjustImageScaling() {
 
         float[] cube = CUBE;
         float[] textureCords = TextureRotationUtil.getRotation(mRotation, mFlipHorizontal, mFlipVertical);
-        if (mScaleType == GPUImage.ScaleType.CENTER_CROP) {
+        if (mScaleType == GPUImageScaleType.CENTER_CROP) {
             float distHorizontal = (1 - 1 / ratioWidth) / 2;
             float distVertical = (1 - 1 / ratioHeight) / 2;
             textureCords = new float[]{
diff --git a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageScaleType.java b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageScaleType.java
new file mode 100644
index 00000000..6e0ffec8
--- /dev/null
+++ b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageScaleType.java
@@ -0,0 +1,8 @@
+package jp.co.cyberagent.android.gpuimage;
+
+/**
+ * Created by Administrator on 2016/9/16.
+ */
+public enum GPUImageScaleType {
+    CENTER_INSIDE, CENTER_CROP
+}
diff --git a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageView.java b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageView.java
index cc6a0247..999eeaac 100644
--- a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageView.java
+++ b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageView.java
@@ -119,7 +119,7 @@ public void setRatio(float ratio) {
      *
      * @param scaleType the new ScaleType
      */
-    public void setScaleType(GPUImage.ScaleType scaleType) {
+    public void setScaleType(GPUImageScaleType scaleType) {
         mGPUImage.setScaleType(scaleType);
     }
 
diff --git a/library/src/jp/co/cyberagent/android/gpuimage/PixelBuffer.java b/library/src/jp/co/cyberagent/android/gpuimage/PixelBuffer.java
index ac23f599..8d800e61 100644
--- a/library/src/jp/co/cyberagent/android/gpuimage/PixelBuffer.java
+++ b/library/src/jp/co/cyberagent/android/gpuimage/PixelBuffer.java
@@ -118,15 +118,39 @@ public Bitmap getBitmap() {
 
         // Call the renderer draw routine (it seems that some filters do not
         // work if this is only called once)
+//        mRenderer.onDrawFrame(mGL);
         mRenderer.onDrawFrame(mGL);
-        mRenderer.onDrawFrame(mGL);
+        // TODO: Verify solution: use flush to replace draw twice
+        mGL.glFlush();
         convertToBitmap();
         return mBitmap;
     }
 
-    public void destroy() {
-        mRenderer.onDrawFrame(mGL);
+    public void getBitmap(Bitmap bitmap) {
+        // Do we have a renderer?
+        if (mRenderer == null) {
+            Log.e(TAG, "getBitmap: Renderer was not set.");
+            return;
+        }
+
+        // Does this thread own the OpenGL context?
+        if (!Thread.currentThread().getName().equals(mThreadOwner)) {
+            Log.e(TAG, "getBitmap: This thread does not own the OpenGL context.");
+            return;
+        }
+
+        // Call the renderer draw routine (it seems that some filters do not
+        // work if this is only called once)
+//        mRenderer.onDrawFrame(mGL);
         mRenderer.onDrawFrame(mGL);
+        // TODO: Verify solution: use flush to replace draw twice
+        mGL.glFlush();
+        GPUImageNativeLibrary.CopyToBitmap(bitmap);
+    }
+
+    public void destroy() {
+//        mRenderer.onDrawFrame(mGL);
+//        mRenderer.onDrawFrame(mGL);
         mEGL.eglMakeCurrent(mEGLDisplay, EGL10.EGL_NO_SURFACE,
                 EGL10.EGL_NO_SURFACE, EGL10.EGL_NO_CONTEXT);
 
@@ -189,22 +213,23 @@ private int getConfigAttrib(final EGLConfig config, final int attribute) {
     }
 
     private void convertToBitmap() {
-        int[] iat = new int[mWidth * mHeight];
-        IntBuffer ib = IntBuffer.allocate(mWidth * mHeight);
-        mGL.glReadPixels(0, 0, mWidth, mHeight, GL_RGBA, GL_UNSIGNED_BYTE, ib);
-        int[] ia = ib.array();
-
-        //Stupid !
-        // Convert upside down mirror-reversed image to right-side up normal
-        // image.
-        for (int i = 0; i < mHeight; i++) {
-            for (int j = 0; j < mWidth; j++) {
-                iat[(mHeight - i - 1) * mWidth + j] = ia[i * mWidth + j];
-            }
-        }
-        
-
+//        int[] iat = new int[mWidth * mHeight];
+//        IntBuffer ib = IntBuffer.allocate(mWidth * mHeight);
+//        mGL.glReadPixels(0, 0, mWidth, mHeight, GL_RGBA, GL_UNSIGNED_BYTE, ib);
+//        int[] ia = ib.array();
+//
+//        //Stupid !
+//        // Convert upside down mirror-reversed image to right-side up normal
+//        // image.
+//        for (int i = 0; i < mHeight; i++) {
+//            for (int j = 0; j < mWidth; j++) {
+//                iat[(mHeight - i - 1) * mWidth + j] = ia[i * mWidth + j];
+//            }
+//        }
+//
+//        mBitmap = Bitmap.createBitmap(mWidth, mHeight, Bitmap.Config.ARGB_8888);
+//        mBitmap.copyPixelsFromBuffer(IntBuffer.wrap(iat));
         mBitmap = Bitmap.createBitmap(mWidth, mHeight, Bitmap.Config.ARGB_8888);
-        mBitmap.copyPixelsFromBuffer(IntBuffer.wrap(iat));
+        GPUImageNativeLibrary.CopyToBitmap(mBitmap);
     }
 }
diff --git a/sample/src/jp/co/cyberagent/android/gpuimage/sample/activity/ActivityGallery.java b/sample/src/jp/co/cyberagent/android/gpuimage/sample/activity/ActivityGallery.java
index a5908479..c5a447c3 100644
--- a/sample/src/jp/co/cyberagent/android/gpuimage/sample/activity/ActivityGallery.java
+++ b/sample/src/jp/co/cyberagent/android/gpuimage/sample/activity/ActivityGallery.java
@@ -124,7 +124,9 @@ private void switchFilterTo(final GPUImageFilter filter, final FilterAdjuster ad
             mGPUImageView.setFilter(mFilter);
             mFilterAdjuster = adjuster;
             findViewById(R.id.seekBar).setVisibility(
-                    mFilterAdjuster == null ? View.VISIBLE : View.GONE);
+                    mFilterAdjuster != null ? View.VISIBLE : View.GONE);
+        } else {
+            findViewById(R.id.seekBar).setVisibility(View.GONE);
         }
     }
 
