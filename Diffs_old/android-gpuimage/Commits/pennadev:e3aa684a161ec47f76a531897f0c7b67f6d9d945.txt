diff --git a/library/libs/armeabi/libjniARToolKitPlus.so b/library/libs/armeabi/libjniARToolKitPlus.so
deleted file mode 100644
index 0ecf208a..00000000
Binary files a/library/libs/armeabi/libjniARToolKitPlus.so and /dev/null differ
diff --git a/library/libs/armeabi/libjnicvkernels.so b/library/libs/armeabi/libjnicvkernels.so
deleted file mode 100644
index 494a6ade..00000000
Binary files a/library/libs/armeabi/libjnicvkernels.so and /dev/null differ
diff --git a/library/libs/armeabi/libjniopencv_calib3d.so b/library/libs/armeabi/libjniopencv_calib3d.so
deleted file mode 100644
index 4f697ecb..00000000
Binary files a/library/libs/armeabi/libjniopencv_calib3d.so and /dev/null differ
diff --git a/library/libs/armeabi/libjniopencv_contrib.so b/library/libs/armeabi/libjniopencv_contrib.so
deleted file mode 100644
index 5078489c..00000000
Binary files a/library/libs/armeabi/libjniopencv_contrib.so and /dev/null differ
diff --git a/library/libs/armeabi/libjniopencv_features2d.so b/library/libs/armeabi/libjniopencv_features2d.so
deleted file mode 100644
index e1ca2ca0..00000000
Binary files a/library/libs/armeabi/libjniopencv_features2d.so and /dev/null differ
diff --git a/library/libs/armeabi/libjniopencv_flann.so b/library/libs/armeabi/libjniopencv_flann.so
deleted file mode 100644
index 2411695c..00000000
Binary files a/library/libs/armeabi/libjniopencv_flann.so and /dev/null differ
diff --git a/library/libs/armeabi/libjniopencv_highgui.so b/library/libs/armeabi/libjniopencv_highgui.so
deleted file mode 100644
index 5fd85b47..00000000
Binary files a/library/libs/armeabi/libjniopencv_highgui.so and /dev/null differ
diff --git a/library/libs/armeabi/libjniopencv_legacy.so b/library/libs/armeabi/libjniopencv_legacy.so
deleted file mode 100644
index 1caa317b..00000000
Binary files a/library/libs/armeabi/libjniopencv_legacy.so and /dev/null differ
diff --git a/library/libs/armeabi/libjniopencv_ml.so b/library/libs/armeabi/libjniopencv_ml.so
deleted file mode 100644
index 6e63a81b..00000000
Binary files a/library/libs/armeabi/libjniopencv_ml.so and /dev/null differ
diff --git a/library/libs/armeabi/libjniopencv_nonfree.so b/library/libs/armeabi/libjniopencv_nonfree.so
deleted file mode 100644
index 3ff80544..00000000
Binary files a/library/libs/armeabi/libjniopencv_nonfree.so and /dev/null differ
diff --git a/library/libs/armeabi/libjniopencv_objdetect.so b/library/libs/armeabi/libjniopencv_objdetect.so
deleted file mode 100644
index bd9b8460..00000000
Binary files a/library/libs/armeabi/libjniopencv_objdetect.so and /dev/null differ
diff --git a/library/libs/armeabi/libjniopencv_photo.so b/library/libs/armeabi/libjniopencv_photo.so
deleted file mode 100644
index 61b08bd7..00000000
Binary files a/library/libs/armeabi/libjniopencv_photo.so and /dev/null differ
diff --git a/library/libs/armeabi/libjniopencv_stitching.so b/library/libs/armeabi/libjniopencv_stitching.so
deleted file mode 100644
index 1e5fcb13..00000000
Binary files a/library/libs/armeabi/libjniopencv_stitching.so and /dev/null differ
diff --git a/library/libs/armeabi/libjniopencv_video.so b/library/libs/armeabi/libjniopencv_video.so
deleted file mode 100644
index cdba9227..00000000
Binary files a/library/libs/armeabi/libjniopencv_video.so and /dev/null differ
diff --git a/library/libs/armeabi/libjniopencv_videostab.so b/library/libs/armeabi/libjniopencv_videostab.so
deleted file mode 100644
index ae08acb1..00000000
Binary files a/library/libs/armeabi/libjniopencv_videostab.so and /dev/null differ
diff --git a/library/libs/armeabi/libopencv_calib3d.so b/library/libs/armeabi/libopencv_calib3d.so
deleted file mode 100644
index 8a2a27f6..00000000
Binary files a/library/libs/armeabi/libopencv_calib3d.so and /dev/null differ
diff --git a/library/libs/armeabi/libopencv_contrib.so b/library/libs/armeabi/libopencv_contrib.so
deleted file mode 100644
index bb60c9d1..00000000
Binary files a/library/libs/armeabi/libopencv_contrib.so and /dev/null differ
diff --git a/library/libs/armeabi/libopencv_features2d.so b/library/libs/armeabi/libopencv_features2d.so
deleted file mode 100644
index 7d7e9d06..00000000
Binary files a/library/libs/armeabi/libopencv_features2d.so and /dev/null differ
diff --git a/library/libs/armeabi/libopencv_flann.so b/library/libs/armeabi/libopencv_flann.so
deleted file mode 100644
index eb6d1224..00000000
Binary files a/library/libs/armeabi/libopencv_flann.so and /dev/null differ
diff --git a/library/libs/armeabi/libopencv_gpu.so b/library/libs/armeabi/libopencv_gpu.so
deleted file mode 100644
index 23be5e16..00000000
Binary files a/library/libs/armeabi/libopencv_gpu.so and /dev/null differ
diff --git a/library/libs/armeabi/libopencv_highgui.so b/library/libs/armeabi/libopencv_highgui.so
deleted file mode 100644
index 0a5d60dc..00000000
Binary files a/library/libs/armeabi/libopencv_highgui.so and /dev/null differ
diff --git a/library/libs/armeabi/libopencv_info.so b/library/libs/armeabi/libopencv_info.so
deleted file mode 100644
index bbe29ec1..00000000
Binary files a/library/libs/armeabi/libopencv_info.so and /dev/null differ
diff --git a/library/libs/armeabi/libopencv_legacy.so b/library/libs/armeabi/libopencv_legacy.so
deleted file mode 100644
index ee4927ef..00000000
Binary files a/library/libs/armeabi/libopencv_legacy.so and /dev/null differ
diff --git a/library/libs/armeabi/libopencv_ml.so b/library/libs/armeabi/libopencv_ml.so
deleted file mode 100644
index ca57fdd5..00000000
Binary files a/library/libs/armeabi/libopencv_ml.so and /dev/null differ
diff --git a/library/libs/armeabi/libopencv_nonfree.so b/library/libs/armeabi/libopencv_nonfree.so
deleted file mode 100644
index 6a7e2361..00000000
Binary files a/library/libs/armeabi/libopencv_nonfree.so and /dev/null differ
diff --git a/library/libs/armeabi/libopencv_objdetect.so b/library/libs/armeabi/libopencv_objdetect.so
deleted file mode 100644
index af39157e..00000000
Binary files a/library/libs/armeabi/libopencv_objdetect.so and /dev/null differ
diff --git a/library/libs/armeabi/libopencv_photo.so b/library/libs/armeabi/libopencv_photo.so
deleted file mode 100644
index 9277c4e2..00000000
Binary files a/library/libs/armeabi/libopencv_photo.so and /dev/null differ
diff --git a/library/libs/armeabi/libopencv_stitching.so b/library/libs/armeabi/libopencv_stitching.so
deleted file mode 100644
index 9f56e67b..00000000
Binary files a/library/libs/armeabi/libopencv_stitching.so and /dev/null differ
diff --git a/library/libs/armeabi/libopencv_video.so b/library/libs/armeabi/libopencv_video.so
deleted file mode 100644
index 9e30d72a..00000000
Binary files a/library/libs/armeabi/libopencv_video.so and /dev/null differ
diff --git a/library/libs/armeabi/libopencv_videostab.so b/library/libs/armeabi/libopencv_videostab.so
deleted file mode 100644
index 036ef3c4..00000000
Binary files a/library/libs/armeabi/libopencv_videostab.so and /dev/null differ
diff --git a/library/src/com/hypersense/gpuimage/VideoEffect.java b/library/src/com/hypersense/gpuimage/VideoEffect.java
index fd80a77d..2ba5949f 100644
--- a/library/src/com/hypersense/gpuimage/VideoEffect.java
+++ b/library/src/com/hypersense/gpuimage/VideoEffect.java
@@ -111,7 +111,6 @@ public boolean processVideo(GPUImage bfm) {
 				bitmap.copyPixelsFromBuffer(frame.image.getByteBuffer());
 				bfm.setImage(bitmap);
 				
-				
 				bitmap = bfm.getBitmapWithFilterApplied();
 
 				IplImage image = IplImage.create(bitmap.getWidth(),
diff --git a/sample/res/layout/activity_camera.xml b/sample/res/layout/activity_camera.xml
index e31329de..16a64d0d 100644
--- a/sample/res/layout/activity_camera.xml
+++ b/sample/res/layout/activity_camera.xml
@@ -3,11 +3,11 @@
     android:layout_height="match_parent"
     android:orientation="vertical" >
 
-<!--     <android.opengl.GLSurfaceView
+    <android.opengl.GLSurfaceView
         android:id="@+id/surfaceView"
         android:layout_width="match_parent"
         android:layout_height="match_parent"
-        android:layout_above="@+id/bar" /> -->
+        android:layout_above="@+id/bar" />
 
     <ImageView
         android:id="@+id/img_switch_camera"
diff --git a/sample/src/jp/co/cyberagent/android/gpuimage/sample/activity/ActivityCamera.java b/sample/src/jp/co/cyberagent/android/gpuimage/sample/activity/ActivityCamera.java
index d9499100..9b99e7bc 100644
--- a/sample/src/jp/co/cyberagent/android/gpuimage/sample/activity/ActivityCamera.java
+++ b/sample/src/jp/co/cyberagent/android/gpuimage/sample/activity/ActivityCamera.java
@@ -23,11 +23,7 @@
 import java.text.SimpleDateFormat;
 import java.util.Date;
 
-import com.hypersense.gpuimage.VideoEffect;
-
 import jp.co.cyberagent.android.gpuimage.GPUImage;
-import jp.co.cyberagent.android.gpuimage.GPUImageLookupFilter;
-import jp.co.cyberagent.android.gpuimage.GPUImageSobelEdgeDetection;
 import jp.co.cyberagent.android.gpuimage.GPUImage.OnPictureSavedListener;
 import jp.co.cyberagent.android.gpuimage.GPUImageFilter;
 import jp.co.cyberagent.android.gpuimage.sample.GPUImageFilterTools;
@@ -52,285 +48,251 @@
 import android.widget.SeekBar;
 import android.widget.SeekBar.OnSeekBarChangeListener;
 
-public class ActivityCamera extends Activity implements
-		OnSeekBarChangeListener {
-
-	private GPUImage mGPUImage;
-	private CameraHelper mCameraHelper;
-	private CameraLoader mCamera;
-	private GPUImageFilter mFilter;
-	private FilterAdjuster mFilterAdjuster;
-
-	@Override
-	public void onCreate(final Bundle savedInstanceState) {
-		super.onCreate(savedInstanceState);
-		setContentView(R.layout.activity_camera);
-//		((SeekBar) findViewById(R.id.seekBar)).setOnSeekBarChangeListener(this);
-//		findViewById(R.id.button_choose_filter).setOnClickListener(this);
-//		findViewById(R.id.button_capture).setOnClickListener(this);
-//
-		mGPUImage = new GPUImage(this);
-		
-
-		// mGPUImage.setGLSurfaceView((GLSurfaceView)
-		// findViewById(R.id.surfaceView));
-
-		// mCameraHelper = new CameraHelper(this);
-		// mCamera = new CameraLoader();
-		//
-		// View cameraSwitchView = findViewById(R.id.img_switch_camera);
-		// cameraSwitchView.setOnClickListener(this);
-		// if (!mCameraHelper.hasFrontCamera() ||
-		// !mCameraHelper.hasBackCamera()) {
-		// cameraSwitchView.setVisibility(View.GONE);
-		// }
-
-		String f = Environment.getExternalStorageDirectory().getAbsolutePath()
-				+ "/vid/viddd.mp4";
-		String newVideo = Environment.getExternalStorageDirectory()
-				.getAbsolutePath() + "/vid/viddddnew.mp4";
-
-        GPUImageLookupFilter amatorka = new GPUImageLookupFilter();
-        amatorka.setBitmap(BitmapFactory.decodeResource(getResources(), R.drawable.lookup_amatorka));
-
-
-		
-		VideoEffect videoEffect = new VideoEffect(f, newVideo);
-		videoEffect.start();
-		
-		mGPUImage.setFilter(amatorka);
-		videoEffect.processVideo(mGPUImage);
-
-	}
-
-	@Override
-	protected void onResume() {
-		super.onResume();
-		// mCamera.onResume();
-	}
-
-	@Override
-	protected void onPause() {
-		// mCamera.onPause();
-		super.onPause();
-	}
-//
-//	@Override
-//	public void onClick(final View v) {
-//		switch (v.getId()) {
-//		case R.id.button_choose_filter:
-//			GPUImageFilterTools.showDialog(this,
-//					new OnGpuImageFilterChosenListener() {
-//
-//						@Override
-//						public void onGpuImageFilterChosenListener(
-//								final GPUImageFilter filter) {
-//							switchFilterTo(filter);
-//						}
-//					});
-//			break;
-//
-//		case R.id.button_capture:
-//			if (mCamera.mCameraInstance.getParameters().getFocusMode()
-//					.equals(Camera.Parameters.FOCUS_MODE_CONTINUOUS_PICTURE)) {
-//				takePicture();
-//			} else {
-//				mCamera.mCameraInstance
-//						.autoFocus(new Camera.AutoFocusCallback() {
-//
-//							@Override
-//							public void onAutoFocus(final boolean success,
-//									final Camera camera) {
-//								takePicture();
-//							}
-//						});
-//			}
-//			break;
-//
-//		case R.id.img_switch_camera:
-//			mCamera.switchCamera();
-//			break;
-//		}
-////	}
-////
-//	private void takePicture() {
-//		// TODO get a size that is about the size of the screen
-//		Camera.Parameters params = mCamera.mCameraInstance.getParameters();
-//		params.setPictureSize(1280, 960);
-//		params.setRotation(90);
-//		mCamera.mCameraInstance.setParameters(params);
-//		for (Camera.Size size2 : mCamera.mCameraInstance.getParameters()
-//				.getSupportedPictureSizes()) {
-//			Log.i("ASDF", "Supported: " + size2.width + "x" + size2.height);
-//		}
-//		mCamera.mCameraInstance.takePicture(null, null,
-//				new Camera.PictureCallback() {
-//
-//					@Override
-//					public void onPictureTaken(byte[] data, final Camera camera) {
-//
-//						final File pictureFile = getOutputMediaFile(MEDIA_TYPE_IMAGE);
-//						if (pictureFile == null) {
-//							Log.d("ASDF",
-//									"Error creating media file, check storage permissions");
-//							return;
-//						}
-//
-//						try {
-//							FileOutputStream fos = new FileOutputStream(
-//									pictureFile);
-//							fos.write(data);
-//							fos.close();
-//						} catch (FileNotFoundException e) {
-//							Log.d("ASDF", "File not found: " + e.getMessage());
-//						} catch (IOException e) {
-//							Log.d("ASDF",
-//									"Error accessing file: " + e.getMessage());
-//						}
-//
-//						data = null;
-//						Bitmap bitmap = BitmapFactory.decodeFile(pictureFile
-//								.getAbsolutePath());
-//						// mGPUImage.setImage(bitmap);
-//						final GLSurfaceView view = (GLSurfaceView) findViewById(R.id.surfaceView);
-//						view.setRenderMode(GLSurfaceView.RENDERMODE_WHEN_DIRTY);
-//						mGPUImage.saveToPictures(bitmap, "GPUImage",
-//								System.currentTimeMillis() + ".jpg",
-//								new OnPictureSavedListener() {
-//
-//									@Override
-//									public void onPictureSaved(final Uri uri) {
-//										pictureFile.delete();
-//										camera.startPreview();
-//										view.setRenderMode(GLSurfaceView.RENDERMODE_CONTINUOUSLY);
-//									}
-//								});
-//					}
-//				});
-//	}
-//
-	public static final int MEDIA_TYPE_IMAGE = 1;
-	public static final int MEDIA_TYPE_VIDEO = 2;
-
-	private static File getOutputMediaFile(final int type) {
-		// To be safe, you should check that the SDCard is mounted
-		// using Environment.getExternalStorageState() before doing this.
-
-		File mediaStorageDir = new File(
-				Environment
-						.getExternalStoragePublicDirectory(Environment.DIRECTORY_PICTURES),
-				"MyCameraApp");
-		// This location works best if you want the created images to be shared
-		// between applications and persist after your app has been uninstalled.
-
-		// Create the storage directory if it does not exist
-		if (!mediaStorageDir.exists()) {
-			if (!mediaStorageDir.mkdirs()) {
-				Log.d("MyCameraApp", "failed to create directory");
-				return null;
-			}
-		}
-
-		// Create a media file name
-		String timeStamp = new SimpleDateFormat("yyyyMMdd_HHmmss")
-				.format(new Date());
-		File mediaFile;
-		if (type == MEDIA_TYPE_IMAGE) {
-			mediaFile = new File(mediaStorageDir.getPath() + File.separator
-					+ "IMG_" + timeStamp + ".jpg");
-		} else if (type == MEDIA_TYPE_VIDEO) {
-			mediaFile = new File(mediaStorageDir.getPath() + File.separator
-					+ "VID_" + timeStamp + ".mp4");
-		} else {
-			return null;
-		}
-
-		return mediaFile;
-	}
-
-	private void switchFilterTo(final GPUImageFilter filter) {
-		if (mFilter == null
-				|| (filter != null && !mFilter.getClass().equals(
-						filter.getClass()))) {
-			mFilter = filter;
-			mGPUImage.setFilter(mFilter);
-			mFilterAdjuster = new FilterAdjuster(mFilter);
-		}
-	}
-
-	@Override
-	public void onProgressChanged(final SeekBar seekBar, final int progress,
-			final boolean fromUser) {
-		if (mFilterAdjuster != null) {
-			mFilterAdjuster.adjust(progress);
-		}
-	}
-
-	@Override
-	public void onStartTrackingTouch(final SeekBar seekBar) {
-	}
-
-	@Override
-	public void onStopTrackingTouch(final SeekBar seekBar) {
-	}
-
-	private class CameraLoader {
-		private int mCurrentCameraId = 0;
-		private Camera mCameraInstance;
-
-		public void onResume() {
-			setUpCamera(mCurrentCameraId);
-		}
-
-		public void onPause() {
-			releaseCamera();
-		}
-
-		public void switchCamera() {
-			releaseCamera();
-			mCurrentCameraId = (mCurrentCameraId + 1)
-					% mCameraHelper.getNumberOfCameras();
-			setUpCamera(mCurrentCameraId);
-		}
-
-		private void setUpCamera(final int id) {
-			mCameraInstance = getCameraInstance(id);
-			Parameters parameters = mCameraInstance.getParameters();
-			// TODO adjust by getting supportedPreviewSizes and then choosing
-			// the best one for screen size (best fill screen)
-			parameters.setPreviewSize(720, 480);
-			if (parameters.getSupportedFocusModes().contains(
-					Camera.Parameters.FOCUS_MODE_CONTINUOUS_PICTURE)) {
-				parameters
-						.setFocusMode(Camera.Parameters.FOCUS_MODE_CONTINUOUS_PICTURE);
-			}
-			mCameraInstance.setParameters(parameters);
-
-			int orientation = mCameraHelper.getCameraDisplayOrientation(
-					ActivityCamera.this, mCurrentCameraId);
-			CameraInfo2 cameraInfo = new CameraInfo2();
-			mCameraHelper.getCameraInfo(mCurrentCameraId, cameraInfo);
-			boolean flipHorizontal = cameraInfo.facing == CameraInfo.CAMERA_FACING_FRONT ? true
-					: false;
-			mGPUImage.setUpCamera(mCameraInstance, orientation, flipHorizontal,
-					false);
-		}
-
-		/** A safe way to get an instance of the Camera object. */
-		private Camera getCameraInstance(final int id) {
-			Camera c = null;
-			try {
-				c = mCameraHelper.openCamera(id);
-			} catch (Exception e) {
-				e.printStackTrace();
-			}
-			return c;
-		}
-
-		private void releaseCamera() {
-			mCameraInstance.setPreviewCallback(null);
-			mCameraInstance.release();
-			mCameraInstance = null;
-		}
-	}
+public class ActivityCamera extends Activity implements OnSeekBarChangeListener,
+        OnClickListener {
+
+    private GPUImage mGPUImage;
+    private CameraHelper mCameraHelper;
+    private CameraLoader mCamera;
+    private GPUImageFilter mFilter;
+    private FilterAdjuster mFilterAdjuster;
+
+    @Override
+    public void onCreate(final Bundle savedInstanceState) {
+        super.onCreate(savedInstanceState);
+        setContentView(R.layout.activity_camera);
+        ((SeekBar) findViewById(R.id.seekBar)).setOnSeekBarChangeListener(this);
+        findViewById(R.id.button_choose_filter).setOnClickListener(this);
+        findViewById(R.id.button_capture).setOnClickListener(this);
+
+        mGPUImage = new GPUImage(this);
+        mGPUImage.setGLSurfaceView((GLSurfaceView) findViewById(R.id.surfaceView));
+
+        mCameraHelper = new CameraHelper(this);
+        mCamera = new CameraLoader();
+
+        View cameraSwitchView = findViewById(R.id.img_switch_camera);
+        cameraSwitchView.setOnClickListener(this);
+        if (!mCameraHelper.hasFrontCamera() || !mCameraHelper.hasBackCamera()) {
+            cameraSwitchView.setVisibility(View.GONE);
+        }
+    }
+
+    @Override
+    protected void onResume() {
+        super.onResume();
+        mCamera.onResume();
+    }
+
+    @Override
+    protected void onPause() {
+        mCamera.onPause();
+        super.onPause();
+    }
+
+    @Override
+    public void onClick(final View v) {
+        switch (v.getId()) {
+            case R.id.button_choose_filter:
+                GPUImageFilterTools.showDialog(this, new OnGpuImageFilterChosenListener() {
+
+                    @Override
+                    public void onGpuImageFilterChosenListener(final GPUImageFilter filter) {
+                        switchFilterTo(filter);
+                    }
+                });
+                break;
+
+            case R.id.button_capture:
+                if (mCamera.mCameraInstance.getParameters().getFocusMode().equals(
+                        Camera.Parameters.FOCUS_MODE_CONTINUOUS_PICTURE)) {
+                    takePicture();
+                } else {
+                    mCamera.mCameraInstance.autoFocus(new Camera.AutoFocusCallback() {
+
+                        @Override
+                        public void onAutoFocus(final boolean success, final Camera camera) {
+                            takePicture();
+                        }
+                    });
+                }
+                break;
+
+            case R.id.img_switch_camera:
+                mCamera.switchCamera();
+                break;
+        }
+    }
+
+    private void takePicture() {
+        // TODO get a size that is about the size of the screen
+        Camera.Parameters params = mCamera.mCameraInstance.getParameters();
+        params.setPictureSize(1280, 960);
+        params.setRotation(90);
+        mCamera.mCameraInstance.setParameters(params);
+        for (Camera.Size size2 : mCamera.mCameraInstance.getParameters()
+                .getSupportedPictureSizes()) {
+            Log.i("ASDF", "Supported: " + size2.width + "x" + size2.height);
+        }
+        mCamera.mCameraInstance.takePicture(null, null,
+                new Camera.PictureCallback() {
+
+                    @Override
+                    public void onPictureTaken(byte[] data, final Camera camera) {
+
+                        final File pictureFile = getOutputMediaFile(MEDIA_TYPE_IMAGE);
+                        if (pictureFile == null) {
+                            Log.d("ASDF",
+                                    "Error creating media file, check storage permissions");
+                            return;
+                        }
+
+                        try {
+                            FileOutputStream fos = new FileOutputStream(pictureFile);
+                            fos.write(data);
+                            fos.close();
+                        } catch (FileNotFoundException e) {
+                            Log.d("ASDF", "File not found: " + e.getMessage());
+                        } catch (IOException e) {
+                            Log.d("ASDF", "Error accessing file: " + e.getMessage());
+                        }
+
+                        data = null;
+                        Bitmap bitmap = BitmapFactory.decodeFile(pictureFile
+                                .getAbsolutePath());
+                        // mGPUImage.setImage(bitmap);
+                        final GLSurfaceView view = (GLSurfaceView) findViewById(R.id.surfaceView);
+                        view.setRenderMode(GLSurfaceView.RENDERMODE_WHEN_DIRTY);
+                        mGPUImage.saveToPictures(bitmap, "GPUImage",
+                                System.currentTimeMillis() + ".jpg",
+                                new OnPictureSavedListener() {
+
+                                    @Override
+                                    public void onPictureSaved(final Uri
+                                            uri) {
+                                        pictureFile.delete();
+                                        camera.startPreview();
+                                        view.setRenderMode(GLSurfaceView.RENDERMODE_CONTINUOUSLY);
+                                    }
+                                });
+                    }
+                });
+    }
+
+    public static final int MEDIA_TYPE_IMAGE = 1;
+    public static final int MEDIA_TYPE_VIDEO = 2;
+
+    private static File getOutputMediaFile(final int type) {
+        // To be safe, you should check that the SDCard is mounted
+        // using Environment.getExternalStorageState() before doing this.
+
+        File mediaStorageDir = new File(Environment.getExternalStoragePublicDirectory(
+                Environment.DIRECTORY_PICTURES), "MyCameraApp");
+        // This location works best if you want the created images to be shared
+        // between applications and persist after your app has been uninstalled.
+
+        // Create the storage directory if it does not exist
+        if (!mediaStorageDir.exists()) {
+            if (!mediaStorageDir.mkdirs()) {
+                Log.d("MyCameraApp", "failed to create directory");
+                return null;
+            }
+        }
+
+        // Create a media file name
+        String timeStamp = new SimpleDateFormat("yyyyMMdd_HHmmss").format(new Date());
+        File mediaFile;
+        if (type == MEDIA_TYPE_IMAGE) {
+            mediaFile = new File(mediaStorageDir.getPath() + File.separator +
+                    "IMG_" + timeStamp + ".jpg");
+        } else if (type == MEDIA_TYPE_VIDEO) {
+            mediaFile = new File(mediaStorageDir.getPath() + File.separator +
+                    "VID_" + timeStamp + ".mp4");
+        } else {
+            return null;
+        }
+
+        return mediaFile;
+    }
+
+    private void switchFilterTo(final GPUImageFilter filter) {
+        if (mFilter == null
+                || (filter != null && !mFilter.getClass().equals(filter.getClass()))) {
+            mFilter = filter;
+            mGPUImage.setFilter(mFilter);
+            mFilterAdjuster = new FilterAdjuster(mFilter);
+        }
+    }
+
+    @Override
+    public void onProgressChanged(final SeekBar seekBar, final int progress, final boolean fromUser) {
+        if (mFilterAdjuster != null) {
+            mFilterAdjuster.adjust(progress);
+        }
+    }
+
+    @Override
+    public void onStartTrackingTouch(final SeekBar seekBar) {
+    }
+
+    @Override
+    public void onStopTrackingTouch(final SeekBar seekBar) {
+    }
+
+    private class CameraLoader {
+        private int mCurrentCameraId = 0;
+        private Camera mCameraInstance;
+
+        public void onResume() {
+            setUpCamera(mCurrentCameraId);
+        }
+
+        public void onPause() {
+            releaseCamera();
+        }
+
+        public void switchCamera() {
+            releaseCamera();
+            mCurrentCameraId = (mCurrentCameraId + 1) % mCameraHelper.getNumberOfCameras();
+            setUpCamera(mCurrentCameraId);
+        }
+
+        private void setUpCamera(final int id) {
+            mCameraInstance = getCameraInstance(id);
+            Parameters parameters = mCameraInstance.getParameters();
+            // TODO adjust by getting supportedPreviewSizes and then choosing
+            // the best one for screen size (best fill screen)
+            parameters.setPreviewSize(720, 480);
+            if (parameters.getSupportedFocusModes().contains(
+                    Camera.Parameters.FOCUS_MODE_CONTINUOUS_PICTURE)) {
+                parameters.setFocusMode(Camera.Parameters.FOCUS_MODE_CONTINUOUS_PICTURE);
+            }
+            mCameraInstance.setParameters(parameters);
+
+            int orientation = mCameraHelper.getCameraDisplayOrientation(
+                    ActivityCamera.this, mCurrentCameraId);
+            CameraInfo2 cameraInfo = new CameraInfo2();
+            mCameraHelper.getCameraInfo(mCurrentCameraId, cameraInfo);
+            boolean flipHorizontal = cameraInfo.facing == CameraInfo.CAMERA_FACING_FRONT
+                    ? true : false;
+            mGPUImage.setUpCamera(mCameraInstance, orientation, flipHorizontal, false);
+        }
+
+        /** A safe way to get an instance of the Camera object. */
+        private Camera getCameraInstance(final int id) {
+            Camera c = null;
+            try {
+                c = mCameraHelper.openCamera(id);
+            } catch (Exception e) {
+                e.printStackTrace();
+            }
+            return c;
+        }
+
+        private void releaseCamera() {
+            mCameraInstance.setPreviewCallback(null);
+            mCameraInstance.release();
+            mCameraInstance = null;
+        }
+    }
 }
