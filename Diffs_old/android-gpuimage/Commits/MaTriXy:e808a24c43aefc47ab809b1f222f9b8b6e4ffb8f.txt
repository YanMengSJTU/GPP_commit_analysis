diff --git a/.gitignore b/.gitignore
index 0e5ae486..f99652d1 100644
--- a/.gitignore
+++ b/.gitignore
@@ -1,6 +1,23 @@
-#OSX
 .DS_Store
-target/
+Thumbs.db
+
+# gradle files
+.gradle
 
-.idea/
+# Intellij project files
+.idea
 *.iml
+
+# generated files
+bin/
+gen/
+obj/
+apk/
+target/
+build/
+
+# Local configuration file (sdk path, etc)
+local.properties
+
+# Proguard folder generated by Eclipse
+proguard/
diff --git a/CHANGELOG.md b/CHANGELOG.md
new file mode 100644
index 00000000..7c89ae59
--- /dev/null
+++ b/CHANGELOG.md
@@ -0,0 +1,27 @@
+Change Log
+==========
+
+Version 1.4.1 *(2016-03-15)*
+----------------------------
+
+Using Bintray's JCenter.
+
+
+Version 1.4.0 *(2016-02-28)*
+----------------------------
+
+* added GPUImageHalftoneFilter (by @ryohey)
+* added GPUImageTransformFilter (by @jonan)
+* fixed GPUImageChromaKeyBlendFilter (by @badjano)
+* fixed GPUImageLookupFilter (by @jonan)
+
+Version 1.3.0 *(2015-09-04)*
+----------------------------
+
+ * added GPUImageBilateralFilter (by @wysaid)
+ * added flip options to `GPUImage#setRotation`
+
+Version 1.2.3-SNAPSHOT *(2014-12-15)*
+----------------------------
+
+ * added GPUImageLevelsFilter (by @vashisthg)
diff --git a/README.md b/README.md
index 99ed7c21..0ac61327 100644
--- a/README.md
+++ b/README.md
@@ -1,4 +1,6 @@
 # GPUImage for Android
+[![License](https://img.shields.io/badge/license-Apache%202-blue.svg)](https://www.apache.org/licenses/LICENSE-2.0)
+[![Download](https://api.bintray.com/packages/cyberagent/maven/gpuimage-library/images/download.svg) ](https://bintray.com/cyberagent/maven/gpuimage-library/_latestVersion)
 
 Idea from: [iOS GPUImage framework](https://github.com/BradLarson/GPUImage)
 
@@ -9,71 +11,57 @@ Goal is to have something as similar to GPUImage as possible. Vertex and fragmen
 
 ## Usage
 
-### Include in own project
-GPUImage can be used as a library project or by copying the following files/folders to your libs folder.
+### Gradle dependency
 
-* library/libs/armeabi (only needed for camera live preview)
-* library/bin/gpuimage.jar
-
-### Maven dependency
-
-    <dependency>
-      <groupId>jp.co.cyberagent.android.gpuimage</groupId>
-      <artifactId>gpuimage-library</artifactId>
-      <type>apklib</type>
-      <version>(use current version here)</version>
-    </dependency>
-
-If you want to use it with live camera preview, than you will need to add the following as well:
-
-    <dependency>
-      <groupId>jp.co.cyberagent.android.gpuimage</groupId>
-      <artifactId>gpuimage-library</artifactId>
-      <classifier>armeabi</classifier>
-      <type>so</type>
-      <version>(use current version here)</version>
-    </dependency>
+```groovy
+repositories {
+    jcenter()
+}
 
+dependencies {
+    compile 'jp.co.cyberagent.android.gpuimage:gpuimage-library:1.4.1'
+}
+```
 
 ### Sample Code
 With preview:
 
-    @Override
-    public void onCreate(final Bundle savedInstanceState) {
-        super.onCreate(savedInstanceState);
-        setContentView(R.layout.activity);
-
-        Uri imageUri = ...;
-        mGPUImage = new GPUImage(this);
-        mGPUImage.setGLSurfaceView((GLSurfaceView) findViewById(R.id.surfaceView));
-        mGPUImage.setImage(imageUri); // this loads image on the current thread, should be run in a thread
-        mGPUImage.setFilter(new GPUImageSepiaFilter());
-
-        // Later when image should be saved saved:
-        mGPUImage.saveToPictures("GPUImage", "ImageWithFilter.jpg", null);
-    }
-
-Without preview:
+```java
+@Override
+public void onCreate(final Bundle savedInstanceState) {
+    super.onCreate(savedInstanceState);
+    setContentView(R.layout.activity);
 
     Uri imageUri = ...;
-    mGPUImage = new GPUImage(context);
-    mGPUImage.setFilter(new GPUImageSobelEdgeDetection());
-    mGPUImage.setImage(imageUri);
+    mGPUImage = new GPUImage(this);
+    mGPUImage.setGLSurfaceView((GLSurfaceView) findViewById(R.id.surfaceView));
+    mGPUImage.setImage(imageUri); // this loads image on the current thread, should be run in a thread
+    mGPUImage.setFilter(new GPUImageSepiaFilter());
+
+    // Later when image should be saved saved:
     mGPUImage.saveToPictures("GPUImage", "ImageWithFilter.jpg", null);
+}
+```
 
-## Create libs/armeabi
-Run the following command in the library folder. Make sure you have android-ndk in your PATH.
+Without preview:
 
-    cd library
-    ndk-build
+```java
+Uri imageUri = ...;
+mGPUImage = new GPUImage(context);
+mGPUImage.setFilter(new GPUImageSobelEdgeDetection());
+mGPUImage.setImage(imageUri);
+mGPUImage.saveToPictures("GPUImage", "ImageWithFilter.jpg", null);
+```
 
-### Maven
+### Gradle
 Make sure that you run the clean target when using maven.
 
-    mvn clean install
+```groovy
+gradle clean assemble
+```
 
 ## License
-    Copyright 2012 CyberAgent
+    Copyright 2012 CyberAgent, Inc.
 
     Licensed under the Apache License, Version 2.0 (the "License");
     you may not use this file except in compliance with the License.
@@ -85,4 +73,4 @@ Make sure that you run the clean target when using maven.
     distributed under the License is distributed on an "AS IS" BASIS,
     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     See the License for the specific language governing permissions and
-    limitations under the License.
\ No newline at end of file
+    limitations under the License.
diff --git a/VERSION b/VERSION
deleted file mode 100644
index 21e8796a..00000000
--- a/VERSION
+++ /dev/null
@@ -1 +0,0 @@
-1.0.3
diff --git a/build.gradle b/build.gradle
new file mode 100644
index 00000000..8a29e6b0
--- /dev/null
+++ b/build.gradle
@@ -0,0 +1,21 @@
+// Top-level build file where you can add configuration options common to all sub-projects/modules.
+
+buildscript {
+    repositories {
+        jcenter()
+    }
+    dependencies {
+        classpath 'com.android.tools.build:gradle:2.0.0-beta6'
+        classpath 'com.novoda:bintray-release:0.3.4'
+    }
+}
+
+allprojects {
+    repositories {
+        jcenter()
+        maven { url("https://oss.sonatype.org/content/repositories/snapshots/") }
+    }
+    tasks.withType(JavaCompile) {
+        options.encoding = 'UTF-8'
+    }
+}
diff --git a/gradle.properties b/gradle.properties
new file mode 100644
index 00000000..40c44d7f
--- /dev/null
+++ b/gradle.properties
@@ -0,0 +1,22 @@
+VERSION_NAME=1.4.1
+GROUP=jp.co.cyberagent.android.gpuimage
+ARTIFACT_ID=gpuimage-library
+
+COMPILE_SDK_VERSION=23
+BUILD_TOOLS_VERSION=23.0.2
+TARGET_SDK_VERSION=23
+MIN_SDK_VERSION=8
+
+POM_DESCRIPTION=Image filters for Android with OpenGL (based on GPUImage for iOS)
+POM_URL=https://github.com/cyberagent/android-gpuimage
+POM_SCM_URL=scm:git@github.com:CyberAgent/android-gpuimage.git
+POM_SCM_CONNECTION=scm:git@github.com:CyberAgent/android-gpuimage.git
+POM_SCM_DEV_CONNECTION=scm:git@github.com:CyberAgent/android-gpuimage.git
+POM_LICENCE_NAME=The Apache Software License, Version 2.0
+POM_LICENCE_URL=http://www.apache.org/licenses/LICENSE-2.0.txt
+POM_LICENCE_DIST=repo
+POM_DEVELOPER_ID=cyberagent
+POM_DEVELOPER_NAME=CyberAgent, Inc.
+ISSUE_URL=https://github.com/CyberAgent/android-gpuimage/issues
+
+android.useDeprecatedNdk=true
diff --git a/gradle/wrapper/gradle-wrapper.jar b/gradle/wrapper/gradle-wrapper.jar
new file mode 100644
index 00000000..8c0fb64a
Binary files /dev/null and b/gradle/wrapper/gradle-wrapper.jar differ
diff --git a/gradle/wrapper/gradle-wrapper.properties b/gradle/wrapper/gradle-wrapper.properties
new file mode 100644
index 00000000..6c0732ab
--- /dev/null
+++ b/gradle/wrapper/gradle-wrapper.properties
@@ -0,0 +1,6 @@
+#Sat Dec 06 18:27:05 JST 2014
+distributionBase=GRADLE_USER_HOME
+distributionPath=wrapper/dists
+zipStoreBase=GRADLE_USER_HOME
+zipStorePath=wrapper/dists
+distributionUrl=https\://services.gradle.org/distributions/gradle-2.11-all.zip
diff --git a/gradlew b/gradlew
new file mode 100755
index 00000000..91a7e269
--- /dev/null
+++ b/gradlew
@@ -0,0 +1,164 @@
+#!/usr/bin/env bash
+
+##############################################################################
+##
+##  Gradle start up script for UN*X
+##
+##############################################################################
+
+# Add default JVM options here. You can also use JAVA_OPTS and GRADLE_OPTS to pass JVM options to this script.
+DEFAULT_JVM_OPTS=""
+
+APP_NAME="Gradle"
+APP_BASE_NAME=`basename "$0"`
+
+# Use the maximum available, or set MAX_FD != -1 to use that value.
+MAX_FD="maximum"
+
+warn ( ) {
+    echo "$*"
+}
+
+die ( ) {
+    echo
+    echo "$*"
+    echo
+    exit 1
+}
+
+# OS specific support (must be 'true' or 'false').
+cygwin=false
+msys=false
+darwin=false
+case "`uname`" in
+  CYGWIN* )
+    cygwin=true
+    ;;
+  Darwin* )
+    darwin=true
+    ;;
+  MINGW* )
+    msys=true
+    ;;
+esac
+
+# For Cygwin, ensure paths are in UNIX format before anything is touched.
+if $cygwin ; then
+    [ -n "$JAVA_HOME" ] && JAVA_HOME=`cygpath --unix "$JAVA_HOME"`
+fi
+
+# Attempt to set APP_HOME
+# Resolve links: $0 may be a link
+PRG="$0"
+# Need this for relative symlinks.
+while [ -h "$PRG" ] ; do
+    ls=`ls -ld "$PRG"`
+    link=`expr "$ls" : '.*-> \(.*\)$'`
+    if expr "$link" : '/.*' > /dev/null; then
+        PRG="$link"
+    else
+        PRG=`dirname "$PRG"`"/$link"
+    fi
+done
+SAVED="`pwd`"
+cd "`dirname \"$PRG\"`/" >&-
+APP_HOME="`pwd -P`"
+cd "$SAVED" >&-
+
+CLASSPATH=$APP_HOME/gradle/wrapper/gradle-wrapper.jar
+
+# Determine the Java command to use to start the JVM.
+if [ -n "$JAVA_HOME" ] ; then
+    if [ -x "$JAVA_HOME/jre/sh/java" ] ; then
+        # IBM's JDK on AIX uses strange locations for the executables
+        JAVACMD="$JAVA_HOME/jre/sh/java"
+    else
+        JAVACMD="$JAVA_HOME/bin/java"
+    fi
+    if [ ! -x "$JAVACMD" ] ; then
+        die "ERROR: JAVA_HOME is set to an invalid directory: $JAVA_HOME
+
+Please set the JAVA_HOME variable in your environment to match the
+location of your Java installation."
+    fi
+else
+    JAVACMD="java"
+    which java >/dev/null 2>&1 || die "ERROR: JAVA_HOME is not set and no 'java' command could be found in your PATH.
+
+Please set the JAVA_HOME variable in your environment to match the
+location of your Java installation."
+fi
+
+# Increase the maximum file descriptors if we can.
+if [ "$cygwin" = "false" -a "$darwin" = "false" ] ; then
+    MAX_FD_LIMIT=`ulimit -H -n`
+    if [ $? -eq 0 ] ; then
+        if [ "$MAX_FD" = "maximum" -o "$MAX_FD" = "max" ] ; then
+            MAX_FD="$MAX_FD_LIMIT"
+        fi
+        ulimit -n $MAX_FD
+        if [ $? -ne 0 ] ; then
+            warn "Could not set maximum file descriptor limit: $MAX_FD"
+        fi
+    else
+        warn "Could not query maximum file descriptor limit: $MAX_FD_LIMIT"
+    fi
+fi
+
+# For Darwin, add options to specify how the application appears in the dock
+if $darwin; then
+    GRADLE_OPTS="$GRADLE_OPTS \"-Xdock:name=$APP_NAME\" \"-Xdock:icon=$APP_HOME/media/gradle.icns\""
+fi
+
+# For Cygwin, switch paths to Windows format before running java
+if $cygwin ; then
+    APP_HOME=`cygpath --path --mixed "$APP_HOME"`
+    CLASSPATH=`cygpath --path --mixed "$CLASSPATH"`
+
+    # We build the pattern for arguments to be converted via cygpath
+    ROOTDIRSRAW=`find -L / -maxdepth 1 -mindepth 1 -type d 2>/dev/null`
+    SEP=""
+    for dir in $ROOTDIRSRAW ; do
+        ROOTDIRS="$ROOTDIRS$SEP$dir"
+        SEP="|"
+    done
+    OURCYGPATTERN="(^($ROOTDIRS))"
+    # Add a user-defined pattern to the cygpath arguments
+    if [ "$GRADLE_CYGPATTERN" != "" ] ; then
+        OURCYGPATTERN="$OURCYGPATTERN|($GRADLE_CYGPATTERN)"
+    fi
+    # Now convert the arguments - kludge to limit ourselves to /bin/sh
+    i=0
+    for arg in "$@" ; do
+        CHECK=`echo "$arg"|egrep -c "$OURCYGPATTERN" -`
+        CHECK2=`echo "$arg"|egrep -c "^-"`                                 ### Determine if an option
+
+        if [ $CHECK -ne 0 ] && [ $CHECK2 -eq 0 ] ; then                    ### Added a condition
+            eval `echo args$i`=`cygpath --path --ignore --mixed "$arg"`
+        else
+            eval `echo args$i`="\"$arg\""
+        fi
+        i=$((i+1))
+    done
+    case $i in
+        (0) set -- ;;
+        (1) set -- "$args0" ;;
+        (2) set -- "$args0" "$args1" ;;
+        (3) set -- "$args0" "$args1" "$args2" ;;
+        (4) set -- "$args0" "$args1" "$args2" "$args3" ;;
+        (5) set -- "$args0" "$args1" "$args2" "$args3" "$args4" ;;
+        (6) set -- "$args0" "$args1" "$args2" "$args3" "$args4" "$args5" ;;
+        (7) set -- "$args0" "$args1" "$args2" "$args3" "$args4" "$args5" "$args6" ;;
+        (8) set -- "$args0" "$args1" "$args2" "$args3" "$args4" "$args5" "$args6" "$args7" ;;
+        (9) set -- "$args0" "$args1" "$args2" "$args3" "$args4" "$args5" "$args6" "$args7" "$args8" ;;
+    esac
+fi
+
+# Split up the JVM_OPTS And GRADLE_OPTS values into an array, following the shell quoting and substitution rules
+function splitJvmOpts() {
+    JVM_OPTS=("$@")
+}
+eval splitJvmOpts $DEFAULT_JVM_OPTS $JAVA_OPTS $GRADLE_OPTS
+JVM_OPTS[${#JVM_OPTS[*]}]="-Dorg.gradle.appname=$APP_BASE_NAME"
+
+exec "$JAVACMD" "${JVM_OPTS[@]}" -classpath "$CLASSPATH" org.gradle.wrapper.GradleWrapperMain "$@"
diff --git a/gradlew.bat b/gradlew.bat
new file mode 100644
index 00000000..aec99730
--- /dev/null
+++ b/gradlew.bat
@@ -0,0 +1,90 @@
+@if "%DEBUG%" == "" @echo off
+@rem ##########################################################################
+@rem
+@rem  Gradle startup script for Windows
+@rem
+@rem ##########################################################################
+
+@rem Set local scope for the variables with windows NT shell
+if "%OS%"=="Windows_NT" setlocal
+
+@rem Add default JVM options here. You can also use JAVA_OPTS and GRADLE_OPTS to pass JVM options to this script.
+set DEFAULT_JVM_OPTS=
+
+set DIRNAME=%~dp0
+if "%DIRNAME%" == "" set DIRNAME=.
+set APP_BASE_NAME=%~n0
+set APP_HOME=%DIRNAME%
+
+@rem Find java.exe
+if defined JAVA_HOME goto findJavaFromJavaHome
+
+set JAVA_EXE=java.exe
+%JAVA_EXE% -version >NUL 2>&1
+if "%ERRORLEVEL%" == "0" goto init
+
+echo.
+echo ERROR: JAVA_HOME is not set and no 'java' command could be found in your PATH.
+echo.
+echo Please set the JAVA_HOME variable in your environment to match the
+echo location of your Java installation.
+
+goto fail
+
+:findJavaFromJavaHome
+set JAVA_HOME=%JAVA_HOME:"=%
+set JAVA_EXE=%JAVA_HOME%/bin/java.exe
+
+if exist "%JAVA_EXE%" goto init
+
+echo.
+echo ERROR: JAVA_HOME is set to an invalid directory: %JAVA_HOME%
+echo.
+echo Please set the JAVA_HOME variable in your environment to match the
+echo location of your Java installation.
+
+goto fail
+
+:init
+@rem Get command-line arguments, handling Windowz variants
+
+if not "%OS%" == "Windows_NT" goto win9xME_args
+if "%@eval[2+2]" == "4" goto 4NT_args
+
+:win9xME_args
+@rem Slurp the command line arguments.
+set CMD_LINE_ARGS=
+set _SKIP=2
+
+:win9xME_args_slurp
+if "x%~1" == "x" goto execute
+
+set CMD_LINE_ARGS=%*
+goto execute
+
+:4NT_args
+@rem Get arguments from the 4NT Shell from JP Software
+set CMD_LINE_ARGS=%$
+
+:execute
+@rem Setup the command line
+
+set CLASSPATH=%APP_HOME%\gradle\wrapper\gradle-wrapper.jar
+
+@rem Execute Gradle
+"%JAVA_EXE%" %DEFAULT_JVM_OPTS% %JAVA_OPTS% %GRADLE_OPTS% "-Dorg.gradle.appname=%APP_BASE_NAME%" -classpath "%CLASSPATH%" org.gradle.wrapper.GradleWrapperMain %CMD_LINE_ARGS%
+
+:end
+@rem End local scope for the variables with windows NT shell
+if "%ERRORLEVEL%"=="0" goto mainEnd
+
+:fail
+rem Set variable GRADLE_EXIT_CONSOLE if you need the _script_ return code instead of
+rem the _cmd.exe /c_ return code!
+if  not "" == "%GRADLE_EXIT_CONSOLE%" exit 1
+exit /b 1
+
+:mainEnd
+if "%OS%"=="Windows_NT" endlocal
+
+:omega
diff --git a/library/.classpath b/library/.classpath
deleted file mode 100644
index a4763d1e..00000000
--- a/library/.classpath
+++ /dev/null
@@ -1,8 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<classpath>
-	<classpathentry kind="src" path="src"/>
-	<classpathentry kind="src" path="gen"/>
-	<classpathentry kind="con" path="com.android.ide.eclipse.adt.ANDROID_FRAMEWORK"/>
-	<classpathentry kind="con" path="com.android.ide.eclipse.adt.LIBRARIES"/>
-	<classpathentry kind="output" path="bin/classes"/>
-</classpath>
diff --git a/library/.gitignore b/library/.gitignore
deleted file mode 100644
index 85e23b43..00000000
--- a/library/.gitignore
+++ /dev/null
@@ -1,32 +0,0 @@
-#Android generated
-bin
-gen
-obj
-
-#Eclipse
-#.project
-#.classpath
-.settings
-
-#IntelliJ IDEA
-.idea
-*.iml
-*.ipr
-*.iws
-out
-
-#Checkstyle
-.checkstyle
-
-#Maven
-target
-release.properties
-pom.xml.*
-
-#Ant
-build.xml
-local.properties
-proguard.cfg
-
-#OSX
-.DS_Store
diff --git a/library/.project b/library/.project
deleted file mode 100644
index df8768a7..00000000
--- a/library/.project
+++ /dev/null
@@ -1,33 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<projectDescription>
-	<name>gpuimage</name>
-	<comment></comment>
-	<projects>
-	</projects>
-	<buildSpec>
-		<buildCommand>
-			<name>com.android.ide.eclipse.adt.ResourceManagerBuilder</name>
-			<arguments>
-			</arguments>
-		</buildCommand>
-		<buildCommand>
-			<name>com.android.ide.eclipse.adt.PreCompilerBuilder</name>
-			<arguments>
-			</arguments>
-		</buildCommand>
-		<buildCommand>
-			<name>org.eclipse.jdt.core.javabuilder</name>
-			<arguments>
-			</arguments>
-		</buildCommand>
-		<buildCommand>
-			<name>com.android.ide.eclipse.adt.ApkBuilder</name>
-			<arguments>
-			</arguments>
-		</buildCommand>
-	</buildSpec>
-	<natures>
-		<nature>com.android.ide.eclipse.adt.AndroidNature</nature>
-		<nature>org.eclipse.jdt.core.javanature</nature>
-	</natures>
-</projectDescription>
diff --git a/library/AndroidManifest.xml b/library/AndroidManifest.xml
index 86ac10f3..ee0e7758 100644
--- a/library/AndroidManifest.xml
+++ b/library/AndroidManifest.xml
@@ -1,12 +1,4 @@
-<manifest xmlns:android="http://schemas.android.com/apk/res/android"
-    package="jp.co.cyberagent.android.gpuimage"
-    android:versionCode="4"
-    android:versionName="1.0.3" >
-
-    <uses-sdk
-        android:minSdkVersion="8"
-        android:targetSdkVersion="15" />
-
-    <application />
-
+<?xml version="1.0" encoding="utf-8"?>
+<manifest
+    package="jp.co.cyberagent.android.gpuimage">
 </manifest>
\ No newline at end of file
diff --git a/library/build.gradle b/library/build.gradle
new file mode 100644
index 00000000..4e0ded68
--- /dev/null
+++ b/library/build.gradle
@@ -0,0 +1,72 @@
+apply plugin: 'com.android.library'
+apply plugin: 'com.novoda.bintray-release'
+
+android {
+    compileSdkVersion COMPILE_SDK_VERSION as int
+    buildToolsVersion BUILD_TOOLS_VERSION
+
+    defaultConfig {
+        minSdkVersion MIN_SDK_VERSION as int
+        targetSdkVersion TARGET_SDK_VERSION as int
+
+        versionCode "git rev-list origin/master --count".execute().text.toInteger()
+        versionName VERSION_NAME
+
+        consumerProguardFiles 'proguard-rules.txt'
+
+        ndk {
+            moduleName "gpuimage-library"
+            stl "gnustl_shared"
+            abiFilters "all"
+            ldLibs "log"
+        }
+    }
+
+    sourceSets {
+        main {
+            manifest.srcFile 'AndroidManifest.xml'
+            java.srcDirs = ['src']
+            resources.srcDirs = ['src']
+            aidl.srcDirs = ['src']
+            renderscript.srcDirs = ['src']
+            res.srcDirs = ['res']
+            assets.srcDirs = ['assets']
+            jni.srcDirs = ['jni']
+        }
+
+        instrumentTest.setRoot('tests')
+    }
+
+    lintOptions {
+        abortOnError false
+    }
+}
+
+task androidJavadocs(type: Javadoc) {
+    source = android.sourceSets.main.java.srcDirs
+    classpath += project.files(android.getBootClasspath().join(File.pathSeparator))
+}
+
+task androidJavadocsJar(type: Jar, dependsOn: androidJavadocs) {
+    classifier = 'javadoc'
+    from androidJavadocs.destinationDir
+}
+
+task androidSourcesJar(type: Jar) {
+    classifier = 'sources'
+    from android.sourceSets.main.java.srcDirs
+}
+
+artifacts {
+    archives androidSourcesJar
+    archives androidJavadocsJar
+}
+
+publish {
+    userOrg = POM_DEVELOPER_ID
+    groupId = GROUP
+    artifactId = ARTIFACT_ID
+    publishVersion = VERSION_NAME
+    desc = POM_DESCRIPTION
+    website = POM_URL
+}
diff --git a/library/gradle.properties b/library/gradle.properties
new file mode 100644
index 00000000..9e162231
--- /dev/null
+++ b/library/gradle.properties
@@ -0,0 +1,3 @@
+POM_NAME=GPUImage for Android Library
+POM_ARTIFACT_ID=gpuimage-library
+POM_PACKAGING=aar
\ No newline at end of file
diff --git a/library/jni/Android.mk b/library/jni/Android.mk
deleted file mode 100644
index 8f8aaca2..00000000
--- a/library/jni/Android.mk
+++ /dev/null
@@ -1,23 +0,0 @@
-# Copyright (C) 2009 The Android Open Source Project
-#
-# Licensed under the Apache License, Version 2.0 (the "License");
-# you may not use this file except in compliance with the License.
-# You may obtain a copy of the License at
-#
-#      http://www.apache.org/licenses/LICENSE-2.0
-#
-# Unless required by applicable law or agreed to in writing, software
-# distributed under the License is distributed on an "AS IS" BASIS,
-# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-# See the License for the specific language governing permissions and
-# limitations under the License.
-#
-LOCAL_PATH := $(call my-dir)
-
-include $(CLEAR_VARS)
-
-LOCAL_MODULE    := gpuimage-library
-LOCAL_SRC_FILES := yuv-decoder.c
-LOCAL_LDLIBS := -llog
-
-include $(BUILD_SHARED_LIBRARY)
diff --git a/library/jni/Application.mk b/library/jni/Application.mk
deleted file mode 100644
index ad1cdfc3..00000000
--- a/library/jni/Application.mk
+++ /dev/null
@@ -1,2 +0,0 @@
-# Build both ARMv5TE and ARMv7-A machine code.
-APP_ABI := armeabi x86
diff --git a/library/jni/yuv-decoder.c b/library/jni/yuv-decoder.c
index 6d9ef62e..fed6281e 100644
--- a/library/jni/yuv-decoder.c
+++ b/library/jni/yuv-decoder.c
@@ -36,11 +36,19 @@ JNIEXPORT void JNICALL Java_jp_co_cyberagent_android_gpuimage_GPUImageNativeLibr
                              Cr = yuv[cOff + 1];
                              if(Cr < 0) Cr += 127; else Cr -= 128;
                      }
-                     R = Y + Cr + (Cr >> 2) + (Cr >> 3) + (Cr >> 5);
+                     
+                     //ITU-R BT.601 conversion
+                     //
+                     //R = 1.164*(Y-16) + 2.018*(Cr-128);
+                     //G = 1.164*(Y-16) - 0.813*(Cb-128) - 0.391*(Cr-128);
+                     //B = 1.164*(Y-16) + 1.596*(Cb-128);
+                     //
+                     Y = Y + (Y >> 3) + (Y >> 5) + (Y >> 7);
+                     R = Y + (Cr << 1) + (Cr >> 6);
                      if(R < 0) R = 0; else if(R > 255) R = 255;
-                     G = Y - (Cb >> 2) + (Cb >> 4) + (Cb >> 5) - (Cr >> 1) + (Cr >> 3) + (Cr >> 4) + (Cr >> 5);
+                     G = Y - Cb + (Cb >> 3) + (Cb >> 4) - (Cr >> 1) + (Cr >> 3);
                      if(G < 0) G = 0; else if(G > 255) G = 255;
-                     B = Y + Cb + (Cb >> 1) + (Cb >> 2) + (Cb >> 6);
+                     B = Y + Cb + (Cb >> 1) + (Cb >> 4) + (Cb >> 5);
                      if(B < 0) B = 0; else if(B > 255) B = 255;
                      rgbData[pixPtr++] = 0xff000000 + (R << 16) + (G << 8) + B;
              }
@@ -84,11 +92,19 @@ JNIEXPORT void JNICALL Java_jp_co_cyberagent_android_gpuimage_GPUImageNativeLibr
                              Cr = yuv[cOff + 1];
                              if(Cr < 0) Cr += 127; else Cr -= 128;
                      }
-                     R = Y + Cr + (Cr >> 2) + (Cr >> 3) + (Cr >> 5);
+                     
+                     //ITU-R BT.601 conversion
+                     //
+                     //R = 1.164*(Y-16) + 2.018*(Cr-128);
+                     //G = 1.164*(Y-16) - 0.813*(Cb-128) - 0.391*(Cr-128);
+                     //B = 1.164*(Y-16) + 1.596*(Cb-128);
+                     //
+                     Y = Y + (Y >> 3) + (Y >> 5) + (Y >> 7);
+                     R = Y + (Cr << 1) + (Cr >> 6);
                      if(R < 0) R = 0; else if(R > 255) R = 255;
-                     G = Y - (Cb >> 2) + (Cb >> 4) + (Cb >> 5) - (Cr >> 1) + (Cr >> 3) + (Cr >> 4) + (Cr >> 5);
+                     G = Y - Cb + (Cb >> 3) + (Cb >> 4) - (Cr >> 1) + (Cr >> 3);
                      if(G < 0) G = 0; else if(G > 255) G = 255;
-                     B = Y + Cb + (Cb >> 1) + (Cb >> 2) + (Cb >> 6);
+                     B = Y + Cb + (Cb >> 1) + (Cb >> 4) + (Cb >> 5);
                      if(B < 0) B = 0; else if(B > 255) B = 255;
                      rgbData[pixPtr++] = 0xff000000 + (B << 16) + (G << 8) + R;
              }
diff --git a/library/libs/armeabi/libgpuimage-library.so b/library/libs/armeabi/libgpuimage-library.so
deleted file mode 100755
index ed495b75..00000000
Binary files a/library/libs/armeabi/libgpuimage-library.so and /dev/null differ
diff --git a/library/libs/x86/libgpuimage-library.so b/library/libs/x86/libgpuimage-library.so
deleted file mode 100755
index 7bdd9e55..00000000
Binary files a/library/libs/x86/libgpuimage-library.so and /dev/null differ
diff --git a/library/pom.xml b/library/pom.xml
deleted file mode 100644
index 66cb995e..00000000
--- a/library/pom.xml
+++ /dev/null
@@ -1,56 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
-    <modelVersion>4.0.0</modelVersion>
-    <groupId>jp.co.cyberagent.android.gpuimage</groupId>
-    <artifactId>gpuimage-library</artifactId>
-    <name>GPUImage for Android Library</name>
-    <packaging>apklib</packaging>
-
-    <parent>
-        <groupId>jp.co.cyberagent.android.gpuimage</groupId>
-        <artifactId>gpuimage-parent</artifactId>
-        <version>1.1.1</version>
-    </parent>
-
-    <dependencies>
-        <dependency>
-            <groupId>com.google.android</groupId>
-            <artifactId>android</artifactId>
-            <version>${android.version}</version>
-            <scope>provided</scope>
-        </dependency>
-    </dependencies>
-
-    <build>
-        <plugins>
-            <plugin>
-                <groupId>com.jayway.maven.plugins.android.generation2</groupId>
-                <artifactId>android-maven-plugin</artifactId>
-                <executions>
-                    <!--
-                    Add the execution of the ndk-build goal - this will compile the native code in addition
-                    to building the Java & APK
-                    -->
-                    <execution>
-                        <goals>
-                            <goal>ndk-build</goal>
-                        </goals>
-                        <configuration>
-                            <clearNativeArtifacts>false</clearNativeArtifacts>
-                            <attachNativeArtifacts>true</attachNativeArtifacts>
-                            <target>all</target>
-                        </configuration>
-                    </execution>
-                </executions>
-                <extensions>true</extensions>
-
-            </plugin>
-            <plugin>
-                <groupId>com.jayway.maven.plugins.android.generation2</groupId>
-                <artifactId>android-maven-plugin</artifactId>
-                <extensions>true</extensions>
-            </plugin>
-        </plugins>
-    </build>
-
-</project>
diff --git a/library/proguard-project.txt b/library/proguard-project.txt
deleted file mode 100644
index f2fe1559..00000000
--- a/library/proguard-project.txt
+++ /dev/null
@@ -1,20 +0,0 @@
-# To enable ProGuard in your project, edit project.properties
-# to define the proguard.config property as described in that file.
-#
-# Add project specific ProGuard rules here.
-# By default, the flags in this file are appended to flags specified
-# in ${sdk.dir}/tools/proguard/proguard-android.txt
-# You can edit the include path and order by changing the ProGuard
-# include property in project.properties.
-#
-# For more details, see
-#   http://developer.android.com/guide/developing/tools/proguard.html
-
-# Add any project specific keep options here:
-
-# If your project uses WebView with JS, uncomment the following
-# and specify the fully qualified class name to the JavaScript interface
-# class:
-#-keepclassmembers class fqcn.of.javascript.interface.for.webview {
-#   public *;
-#}
diff --git a/library/proguard-rules.txt b/library/proguard-rules.txt
new file mode 100644
index 00000000..32ba2033
--- /dev/null
+++ b/library/proguard-rules.txt
@@ -0,0 +1 @@
+-dontwarn jp.co.cyberagent.android.gpuimage.**
\ No newline at end of file
diff --git a/library/project.properties b/library/project.properties
index dfa4dd09..93c8c3c0 100644
--- a/library/project.properties
+++ b/library/project.properties
@@ -11,5 +11,5 @@
 #proguard.config=${sdk.dir}/tools/proguard/proguard-android.txt:proguard-project.txt
 
 # Project target.
-target=android-16
+target=android-21
 android.library=true
diff --git a/library/res/values/strings.xml b/library/res/values/strings.xml
deleted file mode 100644
index 55344e51..00000000
--- a/library/res/values/strings.xml
+++ /dev/null
@@ -1,3 +0,0 @@
-<?xml version="1.0" encoding="utf-8"?>
-<resources>
-</resources>
\ No newline at end of file
diff --git a/library/src/jp/co/cyberagent/android/gpuimage/GPUImage.java b/library/src/jp/co/cyberagent/android/gpuimage/GPUImage.java
index 06b65d4b..8392a5a9 100644
--- a/library/src/jp/co/cyberagent/android/gpuimage/GPUImage.java
+++ b/library/src/jp/co/cyberagent/android/gpuimage/GPUImage.java
@@ -25,6 +25,7 @@
 import android.graphics.Bitmap.CompressFormat;
 import android.graphics.BitmapFactory;
 import android.graphics.Matrix;
+import android.graphics.PixelFormat;
 import android.hardware.Camera;
 import android.media.ExifInterface;
 import android.media.MediaScannerConnection;
@@ -39,7 +40,6 @@
 import android.view.WindowManager;
 
 import java.io.*;
-import java.net.MalformedURLException;
 import java.net.URL;
 import java.util.List;
 import java.util.concurrent.Semaphore;
@@ -48,7 +48,7 @@
  * The main accessor for GPUImage functionality. This class helps to do common
  * tasks through a simple interface.
  */
-public class GPUImage {  
+public class GPUImage {
     private final Context mContext;
     private final GPUImageRenderer mRenderer;
     private GLSurfaceView mGlSurfaceView;
@@ -56,24 +56,24 @@
     private Bitmap mCurrentBitmap;
     private ScaleType mScaleType = ScaleType.CENTER_CROP;
 
-    /**    
-     * Instantiates a new GPUImage object.   
-     * 
+    /**
+     * Instantiates a new GPUImage object.
+     *
      * @param context the context
      */
-    public GPUImage(final Context context) {  
+    public GPUImage(final Context context) {
         if (!supportsOpenGLES2(context)) {
             throw new IllegalStateException("OpenGL ES 2.0 is not supported on this phone.");
         }
- 
-        mContext = context; 
+
+        mContext = context;
         mFilter = new GPUImageFilter();
         mRenderer = new GPUImageRenderer(mFilter);
     }
 
     /**
      * Checks if OpenGL ES 2.0 is supported on the current device.
-     * 
+     *
      * @param context the context
      * @return true, if successful
      */
@@ -87,17 +87,30 @@ private boolean supportsOpenGLES2(final Context context) {
 
     /**
      * Sets the GLSurfaceView which will display the preview.
-     * 
+     *
      * @param view the GLSurfaceView
      */
     public void setGLSurfaceView(final GLSurfaceView view) {
         mGlSurfaceView = view;
         mGlSurfaceView.setEGLContextClientVersion(2);
+        mGlSurfaceView.setEGLConfigChooser(8, 8, 8, 8, 16, 0);
+        mGlSurfaceView.getHolder().setFormat(PixelFormat.RGBA_8888);
         mGlSurfaceView.setRenderer(mRenderer);
         mGlSurfaceView.setRenderMode(GLSurfaceView.RENDERMODE_WHEN_DIRTY);
         mGlSurfaceView.requestRender();
     }
 
+    /**
+     * Sets the background color
+     *
+     * @param red red color value
+     * @param green green color value
+     * @param blue red color value
+     */
+    public void setBackgroundColor(float red, float green, float blue) {
+        mRenderer.setBackgroundColor(red, green, blue);
+    }
+
     /**
      * Request the preview to be rendered again.
      */
@@ -109,7 +122,7 @@ public void requestRender() {
 
     /**
      * Sets the up camera to be connected to GPUImage to get a filtered preview.
-     * 
+     *
      * @param camera the camera
      */
     public void setUpCamera(final Camera camera) {
@@ -118,7 +131,7 @@ public void setUpCamera(final Camera camera) {
 
     /**
      * Sets the up camera to be connected to GPUImage to get a filtered preview.
-     * 
+     *
      * @param camera the camera
      * @param degrees by how many degrees the image should be rotated
      * @param flipHorizontal if the image should be flipped horizontally
@@ -156,7 +169,7 @@ private void setUpCameraGingerbread(final Camera camera) {
     /**
      * Sets the filter which should be applied to the image which was (or will
      * be) set by setImage(...).
-     * 
+     *
      * @param filter the new filter
      */
     public void setFilter(final GPUImageFilter filter) {
@@ -167,16 +180,12 @@ public void setFilter(final GPUImageFilter filter) {
 
     /**
      * Sets the image on which the filter should be applied.
-     * 
+     *
      * @param bitmap the new image
      */
     public void setImage(final Bitmap bitmap) {
-        setImage(bitmap, false);
         mCurrentBitmap = bitmap;
-    }
-
-    private void setImage(final Bitmap bitmap, final boolean recycle) {
-        mRenderer.setImageBitmap(bitmap, recycle);
+        mRenderer.setImageBitmap(bitmap, false);
         requestRender();
     }
 
@@ -194,6 +203,24 @@ public void setScaleType(ScaleType scaleType) {
         requestRender();
     }
 
+    /**
+     * Sets the rotation of the displayed image.
+     *
+     * @param rotation new rotation
+     */
+    public void setRotation(Rotation rotation) {
+        mRenderer.setRotation(rotation);
+    }
+
+    /**
+     * Sets the rotation of the displayed image with flip options.
+     *
+     * @param rotation new rotation
+     */
+    public void setRotation(Rotation rotation, boolean flipHorizontal, boolean flipVertical) {
+        mRenderer.setRotation(rotation, flipHorizontal, flipVertical);
+    }
+
     /**
      * Deletes the current image.
      */
@@ -205,7 +232,7 @@ public void deleteImage() {
 
     /**
      * Sets the image on which the filter should be applied from a Uri.
-     * 
+     *
      * @param uri the uri of the new image
      */
     public void setImage(final Uri uri) {
@@ -214,7 +241,7 @@ public void setImage(final Uri uri) {
 
     /**
      * Sets the image on which the filter should be applied from a File.
-     * 
+     *
      * @param file the file of the new image
      */
     public void setImage(final File file) {
@@ -238,7 +265,7 @@ private String getPath(final Uri uri) {
 
     /**
      * Gets the current displayed image with applied filter as a Bitmap.
-     * 
+     *
      * @return the current image with filter applied
      */
     public Bitmap getBitmapWithFilterApplied() {
@@ -247,28 +274,30 @@ public Bitmap getBitmapWithFilterApplied() {
 
     /**
      * Gets the given bitmap with current filter applied as a Bitmap.
-     * 
+     *
      * @param bitmap the bitmap on which the current filter should be applied
      * @return the bitmap with filter applied
      */
     public Bitmap getBitmapWithFilterApplied(final Bitmap bitmap) {
         if (mGlSurfaceView != null) {
             mRenderer.deleteImage();
-            final Semaphore lock = new Semaphore(0);
             mRenderer.runOnDraw(new Runnable() {
 
                 @Override
                 public void run() {
-                    mFilter.destroy();
-                    lock.release();
+                    synchronized(mFilter) {
+                        mFilter.destroy();
+                        mFilter.notify();
+                    }
                 }
             });
-            requestRender();
-
-            try {
-                lock.acquire();
-            } catch (InterruptedException e) {
-                e.printStackTrace();
+            synchronized(mFilter) {
+                requestRender();
+                try {
+                    mFilter.wait();
+                } catch (InterruptedException e) {
+                    e.printStackTrace();
+                }
             }
         }
 
@@ -295,11 +324,11 @@ public void run() {
 
     /**
      * Gets the images for multiple filters on a image. This can be used to
-     * quickly get thumbnail images for filters. <br />
+     * quickly get thumbnail images for filters. <br>
      * Whenever a new Bitmap is ready, the listener will be called with the
      * bitmap. The order of the calls to the listener will be the same as the
      * filter order.
-     * 
+     *
      * @param bitmap the bitmap on which the filters will be applied
      * @param filters the filters which will be applied on the bitmap
      * @param listener the listener on which the results will be notified
@@ -324,38 +353,55 @@ public static void getBitmapForMultipleFilters(final Bitmap bitmap,
     }
 
     /**
+     * Deprecated: Please use
+     * {@link GPUImageView#saveToPictures(String, String, jp.co.cyberagent.android.gpuimage.GPUImageView.OnPictureSavedListener)}
+     *
      * Save current image with applied filter to Pictures. It will be stored on
-     * the default Picture folder on the phone below the given folerName and
-     * fileName. <br />
+     * the default Picture folder on the phone below the given folderName and
+     * fileName. <br>
      * This method is async and will notify when the image was saved through the
      * listener.
-     * 
+     *
      * @param folderName the folder name
      * @param fileName the file name
      * @param listener the listener
      */
+    @Deprecated
     public void saveToPictures(final String folderName, final String fileName,
             final OnPictureSavedListener listener) {
         saveToPictures(mCurrentBitmap, folderName, fileName, listener);
     }
 
     /**
+     * Deprecated: Please use
+     * {@link GPUImageView#saveToPictures(String, String, jp.co.cyberagent.android.gpuimage.GPUImageView.OnPictureSavedListener)}
+     *
      * Apply and save the given bitmap with applied filter to Pictures. It will
      * be stored on the default Picture folder on the phone below the given
-     * folerName and fileName. <br />
+     * folerName and fileName. <br>
      * This method is async and will notify when the image was saved through the
      * listener.
-     * 
+     *
      * @param bitmap the bitmap
      * @param folderName the folder name
      * @param fileName the file name
      * @param listener the listener
      */
+    @Deprecated
     public void saveToPictures(final Bitmap bitmap, final String folderName, final String fileName,
             final OnPictureSavedListener listener) {
         new SaveTask(bitmap, folderName, fileName, listener).execute();
     }
 
+    /**
+     * Runs the given Runnable on the OpenGL thread.
+     *
+     * @param runnable The runnable to be run on the OpenGL thread.
+     */
+    void runOnGLThread(Runnable runnable) {
+        mRenderer.runOnDrawEnd(runnable);
+    }
+
     private int getOutputWidth() {
         if (mRenderer != null && mRenderer.getFrameWidth() != 0) {
             return mRenderer.getFrameWidth();
@@ -382,6 +428,7 @@ private int getOutputHeight() {
         }
     }
 
+    @Deprecated
     private class SaveTask extends AsyncTask<Void, Void, Void> {
 
         private final Bitmap mBitmap;
@@ -476,7 +523,9 @@ protected int getImageOrientation() throws IOException {
             }
 
             cursor.moveToFirst();
-            return cursor.getInt(0);
+            int orientation = cursor.getInt(0);
+            cursor.close();
+            return orientation;
         }
     }
 
@@ -543,6 +592,7 @@ protected Bitmap doInBackground(Void... params) {
         @Override
         protected void onPostExecute(Bitmap bitmap) {
             super.onPostExecute(bitmap);
+            mGPUImage.deleteImage();
             mGPUImage.setImage(bitmap);
         }
 
@@ -581,9 +631,11 @@ private Bitmap scaleBitmap(Bitmap bitmap) {
             int height = bitmap.getHeight();
             int[] newSize = getScaleSize(width, height);
             Bitmap workBitmap = Bitmap.createScaledBitmap(bitmap, newSize[0], newSize[1], true);
-            bitmap.recycle();
-            bitmap = workBitmap;
-            System.gc();
+            if (workBitmap != bitmap) {
+                bitmap.recycle();
+                bitmap = workBitmap;
+                System.gc();
+            }
 
             if (mScaleType == ScaleType.CENTER_CROP) {
                 // Crop it
@@ -591,17 +643,19 @@ private Bitmap scaleBitmap(Bitmap bitmap) {
                 int diffHeight = newSize[1] - mOutputHeight;
                 workBitmap = Bitmap.createBitmap(bitmap, diffWidth / 2, diffHeight / 2,
                         newSize[0] - diffWidth, newSize[1] - diffHeight);
-                bitmap.recycle();
-                bitmap = workBitmap;
+                if (workBitmap != bitmap) {
+                    bitmap.recycle();
+                    bitmap = workBitmap;
+                }
             }
 
             return bitmap;
         }
 
         /**
-         * Retrieve the scaling size for the image dependent on the ScaleType.<br />
-         * <br/>
-         * If CROP: sides are same size or bigger than output's sides<br />
+         * Retrieve the scaling size for the image dependent on the ScaleType.<br>
+         * <br>
+         * If CROP: sides are same size or bigger than output's sides<br>
          * Else   : sides are same size or smaller than output's sides
          */
         private int[] getScaleSize(int width, int height) {
diff --git a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageBilateralFilter.java b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageBilateralFilter.java
new file mode 100644
index 00000000..275253ab
--- /dev/null
+++ b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageBilateralFilter.java
@@ -0,0 +1,155 @@
+/**
+ * @author wysaid
+ * @mail admin@wysaid.org
+ *
+*/
+
+package jp.co.cyberagent.android.gpuimage;
+
+import android.opengl.GLES20;
+
+
+public class GPUImageBilateralFilter extends GPUImageFilter {
+	public static final String BILATERAL_VERTEX_SHADER = "" +
+			"attribute vec4 position;\n" + 
+			"attribute vec4 inputTextureCoordinate;\n" + 
+	 
+			"const int GAUSSIAN_SAMPLES = 9;\n" + 
+	 
+			"uniform vec2 singleStepOffset;\n" +  
+	 
+			"varying vec2 textureCoordinate;\n" + 
+			"varying vec2 blurCoordinates[GAUSSIAN_SAMPLES];\n" + 
+	 
+			"void main()\n" + 
+			"{\n" + 
+	     	"	gl_Position = position;\n" + 
+			"	textureCoordinate = inputTextureCoordinate.xy;\n" + 
+	     
+			"	int multiplier = 0;\n" + 
+			"	vec2 blurStep;\n" +  
+	     
+			"	for (int i = 0; i < GAUSSIAN_SAMPLES; i++)\n" + 
+	     	"	{\n" + 
+	        "		multiplier = (i - ((GAUSSIAN_SAMPLES - 1) / 2));\n" + 
+	        
+	        "		blurStep = float(multiplier) * singleStepOffset;\n" + 
+	        "		blurCoordinates[i] = inputTextureCoordinate.xy + blurStep;\n" + 
+	     	"	}\n" + 
+	 		"}";
+
+	public static final String BILATERAL_FRAGMENT_SHADER = "" + 
+			"uniform sampler2D inputImageTexture;\n" +
+
+			" const lowp int GAUSSIAN_SAMPLES = 9;\n" +
+
+			" varying highp vec2 textureCoordinate;\n" +
+			" varying highp vec2 blurCoordinates[GAUSSIAN_SAMPLES];\n" +
+
+			" uniform mediump float distanceNormalizationFactor;\n" +
+
+			" void main()\n" +
+			" {\n" +
+			"     lowp vec4 centralColor;\n" +
+			"     lowp float gaussianWeightTotal;\n" +
+			"     lowp vec4 sum;\n" +
+			"     lowp vec4 sampleColor;\n" +
+			"     lowp float distanceFromCentralColor;\n" +
+			"     lowp float gaussianWeight;\n" +
+			"     \n" +
+			"     centralColor = texture2D(inputImageTexture, blurCoordinates[4]);\n" +
+			"     gaussianWeightTotal = 0.18;\n" +
+			"     sum = centralColor * 0.18;\n" +
+			"     \n" +
+			"     sampleColor = texture2D(inputImageTexture, blurCoordinates[0]);\n" +
+			"     distanceFromCentralColor = min(distance(centralColor, sampleColor) * distanceNormalizationFactor, 1.0);\n" +
+			"     gaussianWeight = 0.05 * (1.0 - distanceFromCentralColor);\n" +
+			"     gaussianWeightTotal += gaussianWeight;\n" +
+			"     sum += sampleColor * gaussianWeight;\n" +
+
+			"     sampleColor = texture2D(inputImageTexture, blurCoordinates[1]);\n" +
+			"     distanceFromCentralColor = min(distance(centralColor, sampleColor) * distanceNormalizationFactor, 1.0);\n" +
+			"     gaussianWeight = 0.09 * (1.0 - distanceFromCentralColor);\n" +
+			"     gaussianWeightTotal += gaussianWeight;\n" +
+			"     sum += sampleColor * gaussianWeight;\n" +
+
+			"     sampleColor = texture2D(inputImageTexture, blurCoordinates[2]);\n" +
+			"     distanceFromCentralColor = min(distance(centralColor, sampleColor) * distanceNormalizationFactor, 1.0);\n" +
+			"     gaussianWeight = 0.12 * (1.0 - distanceFromCentralColor);\n" +
+			"     gaussianWeightTotal += gaussianWeight;\n" +
+			"     sum += sampleColor * gaussianWeight;\n" +
+
+			"     sampleColor = texture2D(inputImageTexture, blurCoordinates[3]);\n" +
+			"     distanceFromCentralColor = min(distance(centralColor, sampleColor) * distanceNormalizationFactor, 1.0);\n" +
+			"     gaussianWeight = 0.15 * (1.0 - distanceFromCentralColor);\n" +
+			"     gaussianWeightTotal += gaussianWeight;\n" +
+			"     sum += sampleColor * gaussianWeight;\n" +
+
+			"     sampleColor = texture2D(inputImageTexture, blurCoordinates[5]);\n" +
+			"     distanceFromCentralColor = min(distance(centralColor, sampleColor) * distanceNormalizationFactor, 1.0);\n" +
+			"     gaussianWeight = 0.15 * (1.0 - distanceFromCentralColor);\n" +
+			"     gaussianWeightTotal += gaussianWeight;\n" +
+			"     sum += sampleColor * gaussianWeight;\n" +
+
+			"     sampleColor = texture2D(inputImageTexture, blurCoordinates[6]);\n" +
+			"     distanceFromCentralColor = min(distance(centralColor, sampleColor) * distanceNormalizationFactor, 1.0);\n" +
+			"     gaussianWeight = 0.12 * (1.0 - distanceFromCentralColor);\n" +
+			"     gaussianWeightTotal += gaussianWeight;\n" +
+			"     sum += sampleColor * gaussianWeight;\n" +
+
+			"     sampleColor = texture2D(inputImageTexture, blurCoordinates[7]);\n" +
+			"     distanceFromCentralColor = min(distance(centralColor, sampleColor) * distanceNormalizationFactor, 1.0);\n" +
+			"     gaussianWeight = 0.09 * (1.0 - distanceFromCentralColor);\n" +
+			"     gaussianWeightTotal += gaussianWeight;\n" +
+			"     sum += sampleColor * gaussianWeight;\n" +
+
+			"     sampleColor = texture2D(inputImageTexture, blurCoordinates[8]);\n" +
+			"     distanceFromCentralColor = min(distance(centralColor, sampleColor) * distanceNormalizationFactor, 1.0);\n" +
+			"     gaussianWeight = 0.05 * (1.0 - distanceFromCentralColor);\n" +
+			"     gaussianWeightTotal += gaussianWeight;\n" +
+			"     sum += sampleColor * gaussianWeight;\n" +
+			"     gl_FragColor = sum / gaussianWeightTotal;\n" +
+//			" gl_FragColor.r = distanceNormalizationFactor / 20.0;" + 
+			" }";
+
+	private float mDistanceNormalizationFactor;
+	private int mDisFactorLocation;
+	private int mSingleStepOffsetLocation;
+	
+	public GPUImageBilateralFilter() {
+		this(8.0f);
+	}
+	
+	public GPUImageBilateralFilter(final float distanceNormalizationFactor) {
+		super(BILATERAL_VERTEX_SHADER, BILATERAL_FRAGMENT_SHADER);
+		mDistanceNormalizationFactor = distanceNormalizationFactor;
+	}
+	
+	@Override
+	public void onInit() {
+		super.onInit();
+		mDisFactorLocation = GLES20.glGetUniformLocation(getProgram(), "distanceNormalizationFactor");
+		mSingleStepOffsetLocation = GLES20.glGetUniformLocation(getProgram(), "singleStepOffset");
+	}
+	
+	@Override
+	public void onInitialized() {
+		super.onInitialized();
+		setDistanceNormalizationFactor(mDistanceNormalizationFactor);
+	}
+	
+	public void setDistanceNormalizationFactor(final float newValue) {
+		mDistanceNormalizationFactor = newValue;
+		setFloat(mDisFactorLocation, newValue);
+	}
+	
+	private void setTexelSize(final float w, final float h) {
+		setFloatVec2(mSingleStepOffsetLocation, new float[] {1.0f / w, 1.0f / h});
+	}
+	
+	@Override
+    public void onOutputSizeChanged(final int width, final int height) {
+        super.onOutputSizeChanged(width, height);
+        setTexelSize(width, height);
+    }
+}
diff --git a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageBoxBlurFilter.java b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageBoxBlurFilter.java
new file mode 100644
index 00000000..4e681b3c
--- /dev/null
+++ b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageBoxBlurFilter.java
@@ -0,0 +1,113 @@
+/*
+ * Copyright (C) 2012 CyberAgent
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package jp.co.cyberagent.android.gpuimage;
+
+/**
+ * A hardware-accelerated 9-hit box blur of an image
+ *
+ * scaling: for the size of the applied blur, default of 1.0
+ */
+public class GPUImageBoxBlurFilter extends GPUImageTwoPassTextureSamplingFilter {
+    public static final String VERTEX_SHADER =
+            "attribute vec4 position;\n" +
+                    "attribute vec2 inputTextureCoordinate;\n" +
+                    "\n" +
+                    "uniform float texelWidthOffset; \n" +
+                    "uniform float texelHeightOffset; \n" +
+                    "\n" +
+                    "varying vec2 centerTextureCoordinate;\n" +
+                    "varying vec2 oneStepLeftTextureCoordinate;\n" +
+                    "varying vec2 twoStepsLeftTextureCoordinate;\n" +
+                    "varying vec2 oneStepRightTextureCoordinate;\n" +
+                    "varying vec2 twoStepsRightTextureCoordinate;\n" +
+                    "\n" +
+                    "void main()\n" +
+                    "{\n" +
+                    "gl_Position = position;\n" +
+                    "\n" +
+                    "vec2 firstOffset = vec2(1.5 * texelWidthOffset, 1.5 * texelHeightOffset);\n" +
+                    "vec2 secondOffset = vec2(3.5 * texelWidthOffset, 3.5 * texelHeightOffset);\n" +
+                    "\n" +
+                    "centerTextureCoordinate = inputTextureCoordinate;\n" +
+                    "oneStepLeftTextureCoordinate = inputTextureCoordinate - firstOffset;\n" +
+                    "twoStepsLeftTextureCoordinate = inputTextureCoordinate - secondOffset;\n" +
+                    "oneStepRightTextureCoordinate = inputTextureCoordinate + firstOffset;\n" +
+                    "twoStepsRightTextureCoordinate = inputTextureCoordinate + secondOffset;\n" +
+                    "}\n";
+
+    public static final String FRAGMENT_SHADER =
+            "precision highp float;\n" +
+                    "\n" +
+                    "uniform sampler2D inputImageTexture;\n" +
+                    "\n" +
+                    "varying vec2 centerTextureCoordinate;\n" +
+                    "varying vec2 oneStepLeftTextureCoordinate;\n" +
+                    "varying vec2 twoStepsLeftTextureCoordinate;\n" +
+                    "varying vec2 oneStepRightTextureCoordinate;\n" +
+                    "varying vec2 twoStepsRightTextureCoordinate;\n" +
+                    "\n" +
+                    "void main()\n" +
+                    "{\n" +
+                    "lowp vec4 fragmentColor = texture2D(inputImageTexture, centerTextureCoordinate) * 0.2;\n" +
+                    "fragmentColor += texture2D(inputImageTexture, oneStepLeftTextureCoordinate) * 0.2;\n" +
+                    "fragmentColor += texture2D(inputImageTexture, oneStepRightTextureCoordinate) * 0.2;\n" +
+                    "fragmentColor += texture2D(inputImageTexture, twoStepsLeftTextureCoordinate) * 0.2;\n" +
+                    "fragmentColor += texture2D(inputImageTexture, twoStepsRightTextureCoordinate) * 0.2;\n" +
+                    "\n" +
+                    "gl_FragColor = fragmentColor;\n" +
+                    "}\n";
+
+    private float blurSize = 1f;
+
+    /**
+     * Construct new BoxBlurFilter with default blur size of 1.0.
+     */
+    public GPUImageBoxBlurFilter() {
+        this(1f);
+    }
+
+
+    public GPUImageBoxBlurFilter(float blurSize) {
+        super(VERTEX_SHADER, FRAGMENT_SHADER, VERTEX_SHADER, FRAGMENT_SHADER);
+        this.blurSize = blurSize;
+    }
+
+    /**
+     * A scaling for the size of the applied blur, default of 1.0
+     *
+     * @param blurSize
+     */
+    public void setBlurSize(float blurSize) {
+        this.blurSize = blurSize;
+        runOnDraw(new Runnable() {
+            @Override
+            public void run() {
+                initTexelOffsets();
+            }
+        });
+    }
+
+    @Override
+    public float getVerticalTexelOffsetRatio() {
+        return blurSize;
+    }
+
+    @Override
+    public float getHorizontalTexelOffsetRatio() {
+        return blurSize;
+    }
+}
diff --git a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageBulgeDistortionFilter.java b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageBulgeDistortionFilter.java
new file mode 100644
index 00000000..af49bedd
--- /dev/null
+++ b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageBulgeDistortionFilter.java
@@ -0,0 +1,130 @@
+/*
+ * Copyright (C) 2012 CyberAgent
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package jp.co.cyberagent.android.gpuimage;
+
+import android.graphics.PointF;
+import android.opengl.GLES20;
+
+public class GPUImageBulgeDistortionFilter extends GPUImageFilter {
+    public static final String BULGE_FRAGMENT_SHADER = "" +
+            "varying highp vec2 textureCoordinate;\n" +
+            "\n" +
+            "uniform sampler2D inputImageTexture;\n" +
+            "\n" +
+            "uniform highp float aspectRatio;\n" +
+            "uniform highp vec2 center;\n" +
+            "uniform highp float radius;\n" +
+            "uniform highp float scale;\n" +
+            "\n" +
+            "void main()\n" +
+            "{\n" +
+            "highp vec2 textureCoordinateToUse = vec2(textureCoordinate.x, (textureCoordinate.y * aspectRatio + 0.5 - 0.5 * aspectRatio));\n" +
+            "highp float dist = distance(center, textureCoordinateToUse);\n" +
+            "textureCoordinateToUse = textureCoordinate;\n" +
+            "\n" +
+            "if (dist < radius)\n" +
+            "{\n" +
+            "textureCoordinateToUse -= center;\n" +
+            "highp float percent = 1.0 - ((radius - dist) / radius) * scale;\n" +
+            "percent = percent * percent;\n" +
+            "\n" +
+            "textureCoordinateToUse = textureCoordinateToUse * percent;\n" +
+            "textureCoordinateToUse += center;\n" +
+            "}\n" +
+            "\n" +
+            "gl_FragColor = texture2D(inputImageTexture, textureCoordinateToUse );    \n" +
+            "}\n";
+
+    private float mScale;
+    private int mScaleLocation;
+    private float mRadius;
+    private int mRadiusLocation;
+    private PointF mCenter;
+    private int mCenterLocation;
+    private float mAspectRatio;
+    private int mAspectRatioLocation;
+
+    public GPUImageBulgeDistortionFilter() {
+        this(0.25f, 0.5f, new PointF(0.5f, 0.5f));
+    }
+
+    public GPUImageBulgeDistortionFilter(float radius, float scale, PointF center) {
+        super(NO_FILTER_VERTEX_SHADER, BULGE_FRAGMENT_SHADER);
+        mRadius = radius;
+        mScale = scale;
+        mCenter = center;
+    }
+
+    @Override
+    public void onInit() {
+        super.onInit();
+        mScaleLocation = GLES20.glGetUniformLocation(getProgram(), "scale");
+        mRadiusLocation = GLES20.glGetUniformLocation(getProgram(), "radius");
+        mCenterLocation = GLES20.glGetUniformLocation(getProgram(), "center");
+        mAspectRatioLocation = GLES20.glGetUniformLocation(getProgram(), "aspectRatio");
+    }
+
+    @Override
+    public void onInitialized() {
+        super.onInitialized();
+        setRadius(mRadius);
+        setScale(mScale);
+        setCenter(mCenter);
+    }
+
+    @Override
+    public void onOutputSizeChanged(int width, int height) {
+        mAspectRatio = (float) height / width;
+        setAspectRatio(mAspectRatio);
+        super.onOutputSizeChanged(width, height);
+    }
+
+    private void setAspectRatio(float aspectRatio) {
+        mAspectRatio = aspectRatio;
+        setFloat(mAspectRatioLocation, aspectRatio);
+    }
+
+    /**
+     * The radius of the distortion, ranging from 0.0 to 1.0, with a default of 0.25
+     *
+     * @param radius from 0.0 to 1.0, default 0.25
+     */
+    public void setRadius(float radius) {
+        mRadius = radius;
+        setFloat(mRadiusLocation, radius);
+    }
+
+    /**
+     * The amount of distortion to apply, from -1.0 to 1.0, with a default of 0.5
+     *
+     * @param scale from -1.0 to 1.0, default 0.5
+     */
+    public void setScale(float scale) {
+        mScale = scale;
+        setFloat(mScaleLocation, scale);
+    }
+
+    /**
+     * The center about which to apply the distortion, with a default of (0.5, 0.5)
+     *
+     * @param center default (0.5, 0.5)
+     */
+    public void setCenter(PointF center) {
+        mCenter = center;
+        setPoint(mCenterLocation, center);
+    }
+}
diff --git a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageCGAColorspaceFilter.java b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageCGAColorspaceFilter.java
new file mode 100644
index 00000000..52585956
--- /dev/null
+++ b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageCGAColorspaceFilter.java
@@ -0,0 +1,67 @@
+/*
+ * Copyright (C) 2012 CyberAgent
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package jp.co.cyberagent.android.gpuimage;
+
+public class GPUImageCGAColorspaceFilter extends GPUImageFilter {
+    public static final String CGACOLORSPACE_FRAGMENT_SHADER = "" +
+            "varying highp vec2 textureCoordinate;\n" +
+            "\n" +
+            "uniform sampler2D inputImageTexture;\n" +
+            "\n" +
+            "void main()\n" +
+            "{\n" +
+            "highp vec2 sampleDivisor = vec2(1.0 / 200.0, 1.0 / 320.0);\n" +
+            "//highp vec4 colorDivisor = vec4(colorDepth);\n" +
+            "\n" +
+            "highp vec2 samplePos = textureCoordinate - mod(textureCoordinate, sampleDivisor);\n" +
+            "highp vec4 color = texture2D(inputImageTexture, samplePos );\n" +
+            "\n" +
+            "//gl_FragColor = texture2D(inputImageTexture, samplePos );\n" +
+            "mediump vec4 colorCyan = vec4(85.0 / 255.0, 1.0, 1.0, 1.0);\n" +
+            "mediump vec4 colorMagenta = vec4(1.0, 85.0 / 255.0, 1.0, 1.0);\n" +
+            "mediump vec4 colorWhite = vec4(1.0, 1.0, 1.0, 1.0);\n" +
+            "mediump vec4 colorBlack = vec4(0.0, 0.0, 0.0, 1.0);\n" +
+            "\n" +
+            "mediump vec4 endColor;\n" +
+            "highp float blackDistance = distance(color, colorBlack);\n" +
+            "highp float whiteDistance = distance(color, colorWhite);\n" +
+            "highp float magentaDistance = distance(color, colorMagenta);\n" +
+            "highp float cyanDistance = distance(color, colorCyan);\n" +
+            "\n" +
+            "mediump vec4 finalColor;\n" +
+            "\n" +
+            "highp float colorDistance = min(magentaDistance, cyanDistance);\n" +
+            "colorDistance = min(colorDistance, whiteDistance);\n" +
+            "colorDistance = min(colorDistance, blackDistance); \n" +
+            "\n" +
+            "if (colorDistance == blackDistance) {\n" +
+            "finalColor = colorBlack;\n" +
+            "} else if (colorDistance == whiteDistance) {\n" +
+            "finalColor = colorWhite;\n" +
+            "} else if (colorDistance == cyanDistance) {\n" +
+            "finalColor = colorCyan;\n" +
+            "} else {\n" +
+            "finalColor = colorMagenta;\n" +
+            "}\n" +
+            "\n" +
+            "gl_FragColor = finalColor;\n" +
+            "}\n";
+
+    public GPUImageCGAColorspaceFilter() {
+        super(NO_FILTER_VERTEX_SHADER, CGACOLORSPACE_FRAGMENT_SHADER);
+    }
+}
diff --git a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageChromaKeyBlendFilter.java b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageChromaKeyBlendFilter.java
index c5adf8f4..7957b05a 100644
--- a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageChromaKeyBlendFilter.java
+++ b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageChromaKeyBlendFilter.java
@@ -22,47 +22,32 @@
  * Selectively replaces a color in the first image with the second image
  */
 public class GPUImageChromaKeyBlendFilter extends GPUImageTwoInputFilter {
-    public static final String CHROMA_KEY_BLEND_FRAGMENT_SHADER = "varying highp vec2 textureCoordinate;\n" +
-            " varying highp vec2 textureCoordinate2;\n" +
+    public static final String CHROMA_KEY_BLEND_FRAGMENT_SHADER = " precision highp float;\n" +
             " \n" +
+            " varying highp vec2 textureCoordinate;\n" +
+            " varying highp vec2 textureCoordinate2;\n" +
+            "\n" +
+            " uniform float thresholdSensitivity;\n" +
+            " uniform float smoothing;\n" +
+            " uniform vec3 colorToReplace;\n" +
             " uniform sampler2D inputImageTexture;\n" +
             " uniform sampler2D inputImageTexture2;\n" +
             " \n" +
-            " highp float lum(lowp vec3 c) {\n" +
-            "     return dot(c, vec3(0.3, 0.59, 0.11));\n" +
-            " }\n" +
-            " \n" +
-            " lowp vec3 clipcolor(lowp vec3 c) {\n" +
-            "     highp float l = lum(c);\n" +
-            "     lowp float n = min(min(c.r, c.g), c.b);\n" +
-            "     lowp float x = max(max(c.r, c.g), c.b);\n" +
-            "     \n" +
-            "     if (n < 0.0) {\n" +
-            "         c.r = l + ((c.r - l) * l) / (l - n);\n" +
-            "         c.g = l + ((c.g - l) * l) / (l - n);\n" +
-            "         c.b = l + ((c.b - l) * l) / (l - n);\n" +
-            "     }\n" +
-            "     if (x > 1.0) {\n" +
-            "         c.r = l + ((c.r - l) * (1.0 - l)) / (x - l);\n" +
-            "         c.g = l + ((c.g - l) * (1.0 - l)) / (x - l);\n" +
-            "         c.b = l + ((c.b - l) * (1.0 - l)) / (x - l);\n" +
-            "     }\n" +
-            "     \n" +
-            "     return c;\n" +
-            " }\n" +
-            "\n" +
-            " lowp vec3 setlum(lowp vec3 c, highp float l) {\n" +
-            "     highp float d = l - lum(c);\n" +
-            "     c = c + vec3(d);\n" +
-            "     return clipcolor(c);\n" +
-            " }\n" +
-            " \n" +
             " void main()\n" +
             " {\n" +
-            "   highp vec4 baseColor = texture2D(inputImageTexture, textureCoordinate);\n" +
-            "   highp vec4 overlayColor = texture2D(inputImageTexture2, textureCoordinate2);\n" +
-            "\n" +
-            "     gl_FragColor = vec4(baseColor.rgb * (1.0 - overlayColor.a) + setlum(overlayColor.rgb, lum(baseColor.rgb)) * overlayColor.a, baseColor.a);\n" +
+            "     vec4 textureColor = texture2D(inputImageTexture, textureCoordinate);\n" +
+            "     vec4 textureColor2 = texture2D(inputImageTexture2, textureCoordinate2);\n" +
+            "     \n" +
+            "     float maskY = 0.2989 * colorToReplace.r + 0.5866 * colorToReplace.g + 0.1145 * colorToReplace.b;\n" +
+            "     float maskCr = 0.7132 * (colorToReplace.r - maskY);\n" +
+            "     float maskCb = 0.5647 * (colorToReplace.b - maskY);\n" +
+            "     \n" +
+            "     float Y = 0.2989 * textureColor.r + 0.5866 * textureColor.g + 0.1145 * textureColor.b;\n" +
+            "     float Cr = 0.7132 * (textureColor.r - Y);\n" +
+            "     float Cb = 0.5647 * (textureColor.b - Y);\n" +
+            "     \n" +
+            "     float blendValue = 1.0 - smoothstep(thresholdSensitivity, thresholdSensitivity + smoothing, distance(vec2(Cr, Cb), vec2(maskCr, maskCb)));\n" +
+            "     gl_FragColor = mix(textureColor, textureColor2, blendValue);\n" +
             " }";
 
     private int mThresholdSensitivityLocation;
diff --git a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageColorBalanceFilter.java b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageColorBalanceFilter.java
new file mode 100644
index 00000000..68c078a6
--- /dev/null
+++ b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageColorBalanceFilter.java
@@ -0,0 +1,197 @@
+package jp.co.cyberagent.android.gpuimage;
+
+import android.opengl.GLES20;
+
+/**
+ * Created by edward_chiang on 13/10/16.
+ */
+public class GPUImageColorBalanceFilter extends GPUImageFilter {
+
+    public static final String GPU_IMAGE_COLOR_BALANCE_FRAGMENT_SHADER = "" +
+            "varying highp vec2 textureCoordinate;\n"   +
+            "uniform sampler2D inputImageTexture;\n"    +
+            "uniform lowp vec3 shadowsShift;\n" +
+            "uniform lowp vec3 midtonesShift;\n"    +
+            "uniform lowp vec3 highlightsShift;\n"  +
+            "uniform int preserveLuminosity;\n" +
+            "lowp vec3 RGBToHSL(lowp vec3 color)\n" +
+
+            "{\n"   +
+            "lowp vec3 hsl; // init to 0 to avoid warnings ? (and reverse if + remove first part)\n"    +
+
+            "lowp float fmin = min(min(color.r, color.g), color.b);    //Min. value of RGB\n"   +
+            "lowp float fmax = max(max(color.r, color.g), color.b);    //Max. value of RGB\n"   +
+            "lowp float delta = fmax - fmin;             //Delta RGB value\n"   +
+
+            "hsl.z = (fmax + fmin) / 2.0; // Luminance\n"   +
+
+            "if (delta == 0.0)		//This is a gray, no chroma...\n"   +
+            "{\n"   +
+            "    hsl.x = 0.0;	// Hue\n"   +
+            "    hsl.y = 0.0;	// Saturation\n"    +
+            "}\n"   +
+            "else                                    //Chromatic data...\n" +
+            "{\n"   +
+            "    if (hsl.z < 0.5)\n"    +
+            "        hsl.y = delta / (fmax + fmin); // Saturation\n"    +
+            "    else\n"+
+            "        hsl.y = delta / (2.0 - fmax - fmin); // Saturation\n"  +
+            "\n" +
+            "    lowp float deltaR = (((fmax - color.r) / 6.0) + (delta / 2.0)) / delta;\n" +
+            "    lowp float deltaG = (((fmax - color.g) / 6.0) + (delta / 2.0)) / delta;\n" +
+            "    lowp float deltaB = (((fmax - color.b) / 6.0) + (delta / 2.0)) / delta;\n" +
+            "\n" +
+            "    if (color.r == fmax )\n"   +
+            "        hsl.x = deltaB - deltaG; // Hue\n" +
+            "    else if (color.g == fmax)\n"   +
+            "        hsl.x = (1.0 / 3.0) + deltaR - deltaB; // Hue\n"   +
+            "    else if (color.b == fmax)\n"   +
+            "        hsl.x = (2.0 / 3.0) + deltaG - deltaR; // Hue\n"   +
+
+            "    if (hsl.x < 0.0)\n"    +
+            "        hsl.x += 1.0; // Hue\n"    +
+            "    else if (hsl.x > 1.0)\n"   +
+            "        hsl.x -= 1.0; // Hue\n"    +
+            "}\n"   +
+            "\n" +
+            "return hsl;\n" +
+            "}\n"   +
+
+            "lowp float HueToRGB(lowp float f1, lowp float f2, lowp float hue)\n"   +
+            "{\n"+
+            "    if (hue < 0.0)\n"+
+            "        hue += 1.0;\n"+
+            "    else if (hue > 1.0)\n"+
+            "        hue -= 1.0;\n"+
+            "    lowp float res;\n"+
+            "    if ((6.0 * hue) < 1.0)\n"+
+            "        res = f1 + (f2 - f1) * 6.0 * hue;\n"+
+            "    else if ((2.0 * hue) < 1.0)\n"+
+            "        res = f2;\n"+
+            "    else if ((3.0 * hue) < 2.0)\n"+
+            "        res = f1 + (f2 - f1) * ((2.0 / 3.0) - hue) * 6.0;\n"+
+            "    else\n"+
+            "        res = f1;\n"+
+            "    return res;\n"+
+            "}\n"+
+
+            "lowp vec3 HSLToRGB(lowp vec3 hsl)\n"+
+            "{\n"   +
+            "    lowp vec3 rgb;\n"  +
+
+            "    if (hsl.y == 0.0)\n"   +
+            "        rgb = vec3(hsl.z); // Luminance\n" +
+            "    else\n"    +
+            "    {\n"   +
+            "        lowp float f2;\n"  +
+
+            "        if (hsl.z < 0.5)\n"    +
+            "            f2 = hsl.z * (1.0 + hsl.y);\n" +
+            "        else\n"    +
+            "            f2 = (hsl.z + hsl.y) - (hsl.y * hsl.z);\n" +
+
+            "        lowp float f1 = 2.0 * hsl.z - f2;\n"   +
+
+            "        rgb.r = HueToRGB(f1, f2, hsl.x + (1.0/3.0));\n"    +
+            "        rgb.g = HueToRGB(f1, f2, hsl.x);\n"    +
+            "        rgb.b= HueToRGB(f1, f2, hsl.x - (1.0/3.0));\n" +
+            "    }\n"   +
+
+            "    return rgb;\n  "+
+            "}\n" +
+
+            "lowp float RGBToL(lowp vec3 color)\n"  +
+            "{\n"   +
+            "    lowp float fmin = min(min(color.r, color.g), color.b);    //Min. value of RGB\n"   +
+            "    lowp float fmax = max(max(color.r, color.g), color.b);    //Max. value of RGB\n"   +
+
+            "    return (fmax + fmin) / 2.0; // Luminance\n"    +
+            "}\n"   +
+
+            "void main()\n"+
+            "{\n"+
+            "    lowp vec4 textureColor = texture2D(inputImageTexture, textureCoordinate);\n"   +
+
+            "    // Alternative way:\n" +
+            "    //lowp vec3 lightness = RGBToL(textureColor.rgb);\n"   +
+            "    lowp vec3 lightness = textureColor.rgb;\n" +
+
+            "    const lowp float a = 0.25;\n"  +
+            "    const lowp float b = 0.333;\n" +
+            "    const lowp float scale = 0.7;\n"   +
+
+            "    lowp vec3 shadows = shadowsShift * (clamp((lightness - b) / -a + 0.5, 0.0, 1.0) * scale);\n"   +
+            "    lowp vec3 midtones = midtonesShift * (clamp((lightness - b) / a + 0.5, 0.0, 1.0) *\n"  +
+            "        clamp((lightness + b - 1.0) / -a + 0.5, 0.0, 1.0) * scale);\n" +
+            "    lowp vec3 highlights = highlightsShift * (clamp((lightness + b - 1.0) / a + 0.5, 0.0, 1.0) * scale);\n"    +
+
+            "    mediump vec3 newColor = textureColor.rgb + shadows + midtones + highlights;\n"+
+            "    newColor = clamp(newColor, 0.0, 1.0);\n    "+
+
+            "    if (preserveLuminosity != 0) {\n   "+
+            "        lowp vec3 newHSL = RGBToHSL(newColor);\n"  +
+            "        lowp float oldLum = RGBToL(textureColor.rgb);\n"   +
+            "        textureColor.rgb = HSLToRGB(vec3(newHSL.x, newHSL.y, oldLum));\n"  +
+            "        gl_FragColor = textureColor;\n"    +
+            "    } else {\n"    +
+            "        gl_FragColor = vec4(newColor.rgb, textureColor.w);\n"  +
+            "    }\n" +
+            "}\n";
+
+    private int mShadowsLocation;
+    private int mMidtonesLocation;
+    private int mHighlightsLocation;
+    private int mPreserveLuminosityLocation;
+
+    private float[] showdows;
+    private float[] midtones;
+    private float[] highlights;
+    private boolean preserveLuminosity;
+
+
+    public GPUImageColorBalanceFilter() {
+        super(NO_FILTER_VERTEX_SHADER, GPU_IMAGE_COLOR_BALANCE_FRAGMENT_SHADER);
+        this.showdows = new float[]{0.0f, 0.0f, 0.0f};
+        this.midtones = new float[]{0.0f, 0.0f, 0.0f};
+        this.highlights = new float[]{0.0f, 0.0f, 0.0f};
+        this.preserveLuminosity = true;
+    }
+
+    @Override
+    public void onInit() {
+        super.onInit();
+        mShadowsLocation = GLES20.glGetUniformLocation(getProgram(), "shadowsShift");
+        mMidtonesLocation = GLES20.glGetUniformLocation(getProgram(), "midtonesShift");
+        mHighlightsLocation = GLES20.glGetUniformLocation(getProgram(), "highlightsShift");
+        mPreserveLuminosityLocation = GLES20.glGetUniformLocation(getProgram(), "preserveLuminosity");
+    }
+
+    @Override
+    public void onInitialized() {
+        super.onInitialized();
+        setMidtones(this.midtones);
+        setShowdows(this.showdows);
+        setHighlights(this.highlights);
+        setPreserveLuminosity(this.preserveLuminosity);
+    }
+
+    public void setShowdows(float[] showdows) {
+        this.showdows = showdows;
+        setFloatVec3(mShadowsLocation, showdows);
+    }
+
+    public void setMidtones(float[] midtones) {
+        this.midtones = midtones;
+        setFloatVec3(mMidtonesLocation, midtones);
+    }
+
+    public void setHighlights(float[] highlights) {
+        this.highlights = highlights;
+        setFloatVec3(mHighlightsLocation, highlights);
+    }
+
+    public void setPreserveLuminosity(boolean preserveLuminosity) {
+        this.preserveLuminosity = preserveLuminosity;
+        setInteger(mPreserveLuminosityLocation, preserveLuminosity ? 1: 0);
+    }
+}
diff --git a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageContrastFilter.java b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageContrastFilter.java
index 76f4aa8e..1d2b9107 100644
--- a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageContrastFilter.java
+++ b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageContrastFilter.java
@@ -19,8 +19,8 @@
 import android.opengl.GLES20;
 
 /**
- * Changes the contrast of the image.<br />
- * <br />
+ * Changes the contrast of the image.<br>
+ * <br>
  * contrast value ranges from 0.0 to 4.0, with 1.0 as the normal level
  */
 public class GPUImageContrastFilter extends GPUImageFilter {
diff --git a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageCrosshatchFilter.java b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageCrosshatchFilter.java
new file mode 100644
index 00000000..04a3d4c7
--- /dev/null
+++ b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageCrosshatchFilter.java
@@ -0,0 +1,130 @@
+/*
+ * Copyright (C) 2012 CyberAgent
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package jp.co.cyberagent.android.gpuimage;
+
+import android.opengl.GLES20;
+
+/**
+ * crossHatchSpacing: The fractional width of the image to use as the spacing for the crosshatch. The default is 0.03.
+ * lineWidth: A relative width for the crosshatch lines. The default is 0.003.
+ */
+public class GPUImageCrosshatchFilter extends GPUImageFilter {
+    public static final String CROSSHATCH_FRAGMENT_SHADER = "" +
+            "varying highp vec2 textureCoordinate;\n" +
+            "uniform sampler2D inputImageTexture;\n" +
+            "uniform highp float crossHatchSpacing;\n" +
+            "uniform highp float lineWidth;\n" +
+            "const highp vec3 W = vec3(0.2125, 0.7154, 0.0721);\n" +
+            "void main()\n" +
+            "{\n" +
+            "highp float luminance = dot(texture2D(inputImageTexture, textureCoordinate).rgb, W);\n" +
+            "lowp vec4 colorToDisplay = vec4(1.0, 1.0, 1.0, 1.0);\n" +
+            "if (luminance < 1.00)\n" +
+            "{\n" +
+            "if (mod(textureCoordinate.x + textureCoordinate.y, crossHatchSpacing) <= lineWidth)\n" +
+            "{\n" +
+            "colorToDisplay = vec4(0.0, 0.0, 0.0, 1.0);\n" +
+            "}\n" +
+            "}\n" +
+            "if (luminance < 0.75)\n" +
+            "{\n" +
+            "if (mod(textureCoordinate.x - textureCoordinate.y, crossHatchSpacing) <= lineWidth)\n" +
+            "{\n" +
+            "colorToDisplay = vec4(0.0, 0.0, 0.0, 1.0);\n" +
+            "}\n" +
+            "}\n" +
+            "if (luminance < 0.50)\n" +
+            "{\n" +
+            "if (mod(textureCoordinate.x + textureCoordinate.y - (crossHatchSpacing / 2.0), crossHatchSpacing) <= lineWidth)\n" +
+            "{\n" +
+            "colorToDisplay = vec4(0.0, 0.0, 0.0, 1.0);\n" +
+            "}\n" +
+            "}\n" +
+            "if (luminance < 0.3)\n" +
+            "{\n" +
+            "if (mod(textureCoordinate.x - textureCoordinate.y - (crossHatchSpacing / 2.0), crossHatchSpacing) <= lineWidth)\n" +
+            "{\n" +
+            "colorToDisplay = vec4(0.0, 0.0, 0.0, 1.0);\n" +
+            "}\n" +
+            "}\n" +
+            "gl_FragColor = colorToDisplay;\n" +
+            "}\n";
+
+    private float mCrossHatchSpacing;
+    private int mCrossHatchSpacingLocation;
+    private float mLineWidth;
+    private int mLineWidthLocation;
+
+    /**
+     * Using default values of crossHatchSpacing: 0.03f and lineWidth: 0.003f.
+     */
+    public GPUImageCrosshatchFilter() {
+        this(0.03f, 0.003f);
+    }
+
+    public GPUImageCrosshatchFilter(float crossHatchSpacing, float lineWidth) {
+        super(NO_FILTER_VERTEX_SHADER, CROSSHATCH_FRAGMENT_SHADER);
+        mCrossHatchSpacing = crossHatchSpacing;
+        mLineWidth = lineWidth;
+    }
+
+    @Override
+    public void onInit() {
+        super.onInit();
+        mCrossHatchSpacingLocation = GLES20.glGetUniformLocation(getProgram(), "crossHatchSpacing");
+        mLineWidthLocation = GLES20.glGetUniformLocation(getProgram(), "lineWidth");
+    }
+
+    @Override
+    public void onInitialized() {
+        super.onInitialized();
+        setCrossHatchSpacing(mCrossHatchSpacing);
+        setLineWidth(mLineWidth);
+    }
+
+    /**
+     * The fractional width of the image to use as the spacing for the crosshatch. The default is 0.03.
+     *
+     * @param crossHatchSpacing default 0.03
+     */
+    public void setCrossHatchSpacing(final float crossHatchSpacing) {
+        float singlePixelSpacing;
+        if (getOutputWidth() != 0) {
+            singlePixelSpacing = 1.0f / (float) getOutputWidth();
+        } else {
+            singlePixelSpacing = 1.0f / 2048.0f;
+        }
+
+        if (crossHatchSpacing < singlePixelSpacing) {
+            mCrossHatchSpacing = singlePixelSpacing;
+        } else {
+            mCrossHatchSpacing = crossHatchSpacing;
+        }
+
+        setFloat(mCrossHatchSpacingLocation, mCrossHatchSpacing);
+    }
+
+    /**
+     * A relative width for the crosshatch lines. The default is 0.003.
+     *
+     * @param lineWidth default 0.003
+     */
+    public void setLineWidth(final float lineWidth) {
+        mLineWidth = lineWidth;
+        setFloat(mLineWidthLocation, mLineWidth);
+    }
+}
diff --git a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageDilationFilter.java b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageDilationFilter.java
new file mode 100644
index 00000000..f6ce4e2f
--- /dev/null
+++ b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageDilationFilter.java
@@ -0,0 +1,305 @@
+/*
+ * Copyright (C) 2012 CyberAgent
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package jp.co.cyberagent.android.gpuimage;
+
+/**
+ * For each pixel, this sets it to the maximum value of the red channel in a rectangular neighborhood extending
+ * out dilationRadius pixels from the center.
+ * This extends out bright features, and is most commonly used with black-and-white thresholded images.
+ */
+public class GPUImageDilationFilter extends GPUImageTwoPassTextureSamplingFilter {
+    public static final String VERTEX_SHADER_1 =
+            "attribute vec4 position;\n" +
+                    "attribute vec2 inputTextureCoordinate;\n" +
+                    "\n" +
+                    "uniform float texelWidthOffset; \n" +
+                    "uniform float texelHeightOffset; \n" +
+                    "\n" +
+                    "varying vec2 centerTextureCoordinate;\n" +
+                    "varying vec2 oneStepPositiveTextureCoordinate;\n" +
+                    "varying vec2 oneStepNegativeTextureCoordinate;\n" +
+                    "\n" +
+                    "void main()\n" +
+                    "{\n" +
+                    "gl_Position = position;\n" +
+                    "\n" +
+                    "vec2 offset = vec2(texelWidthOffset, texelHeightOffset);\n" +
+                    "\n" +
+                    "centerTextureCoordinate = inputTextureCoordinate;\n" +
+                    "oneStepNegativeTextureCoordinate = inputTextureCoordinate - offset;\n" +
+                    "oneStepPositiveTextureCoordinate = inputTextureCoordinate + offset;\n" +
+                    "}\n";
+
+    public static final String VERTEX_SHADER_2 =
+            "attribute vec4 position;\n" +
+                    "attribute vec2 inputTextureCoordinate;\n" +
+                    "\n" +
+                    "uniform float texelWidthOffset;\n" +
+                    "uniform float texelHeightOffset;\n" +
+                    "\n" +
+                    "varying vec2 centerTextureCoordinate;\n" +
+                    "varying vec2 oneStepPositiveTextureCoordinate;\n" +
+                    "varying vec2 oneStepNegativeTextureCoordinate;\n" +
+                    "varying vec2 twoStepsPositiveTextureCoordinate;\n" +
+                    "varying vec2 twoStepsNegativeTextureCoordinate;\n" +
+                    "\n" +
+                    "void main()\n" +
+                    "{\n" +
+                    "gl_Position = position;\n" +
+                    "\n" +
+                    "vec2 offset = vec2(texelWidthOffset, texelHeightOffset);\n" +
+                    "\n" +
+                    "centerTextureCoordinate = inputTextureCoordinate;\n" +
+                    "oneStepNegativeTextureCoordinate = inputTextureCoordinate - offset;\n" +
+                    "oneStepPositiveTextureCoordinate = inputTextureCoordinate + offset;\n" +
+                    "twoStepsNegativeTextureCoordinate = inputTextureCoordinate - (offset * 2.0);\n" +
+                    "twoStepsPositiveTextureCoordinate = inputTextureCoordinate + (offset * 2.0);\n" +
+                    "}\n";
+
+    public static final String VERTEX_SHADER_3 =
+            "attribute vec4 position;\n" +
+                    "attribute vec2 inputTextureCoordinate;\n" +
+                    "\n" +
+                    "uniform float texelWidthOffset;\n" +
+                    "uniform float texelHeightOffset;\n" +
+                    "\n" +
+                    "varying vec2 centerTextureCoordinate;\n" +
+                    "varying vec2 oneStepPositiveTextureCoordinate;\n" +
+                    "varying vec2 oneStepNegativeTextureCoordinate;\n" +
+                    "varying vec2 twoStepsPositiveTextureCoordinate;\n" +
+                    "varying vec2 twoStepsNegativeTextureCoordinate;\n" +
+                    "varying vec2 threeStepsPositiveTextureCoordinate;\n" +
+                    "varying vec2 threeStepsNegativeTextureCoordinate;\n" +
+                    "\n" +
+                    "void main()\n" +
+                    "{\n" +
+                    "gl_Position = position;\n" +
+                    "\n" +
+                    "vec2 offset = vec2(texelWidthOffset, texelHeightOffset);\n" +
+                    "\n" +
+                    "centerTextureCoordinate = inputTextureCoordinate;\n" +
+                    "oneStepNegativeTextureCoordinate = inputTextureCoordinate - offset;\n" +
+                    "oneStepPositiveTextureCoordinate = inputTextureCoordinate + offset;\n" +
+                    "twoStepsNegativeTextureCoordinate = inputTextureCoordinate - (offset * 2.0);\n" +
+                    "twoStepsPositiveTextureCoordinate = inputTextureCoordinate + (offset * 2.0);\n" +
+                    "threeStepsNegativeTextureCoordinate = inputTextureCoordinate - (offset * 3.0);\n" +
+                    "threeStepsPositiveTextureCoordinate = inputTextureCoordinate + (offset * 3.0);\n" +
+                    "}\n";
+
+    public static final String VERTEX_SHADER_4 =
+
+            "attribute vec4 position;\n" +
+                    "attribute vec2 inputTextureCoordinate;\n" +
+                    "\n" +
+                    "uniform float texelWidthOffset;\n" +
+                    "uniform float texelHeightOffset;\n" +
+                    "\n" +
+                    "varying vec2 centerTextureCoordinate;\n" +
+                    "varying vec2 oneStepPositiveTextureCoordinate;\n" +
+                    "varying vec2 oneStepNegativeTextureCoordinate;\n" +
+                    "varying vec2 twoStepsPositiveTextureCoordinate;\n" +
+                    "varying vec2 twoStepsNegativeTextureCoordinate;\n" +
+                    "varying vec2 threeStepsPositiveTextureCoordinate;\n" +
+                    "varying vec2 threeStepsNegativeTextureCoordinate;\n" +
+                    "varying vec2 fourStepsPositiveTextureCoordinate;\n" +
+                    "varying vec2 fourStepsNegativeTextureCoordinate;\n" +
+                    "\n" +
+                    "void main()\n" +
+                    "{\n" +
+                    "gl_Position = position;\n" +
+                    "\n" +
+                    "vec2 offset = vec2(texelWidthOffset, texelHeightOffset);\n" +
+                    "\n" +
+                    "centerTextureCoordinate = inputTextureCoordinate;\n" +
+                    "oneStepNegativeTextureCoordinate = inputTextureCoordinate - offset;\n" +
+                    "oneStepPositiveTextureCoordinate = inputTextureCoordinate + offset;\n" +
+                    "twoStepsNegativeTextureCoordinate = inputTextureCoordinate - (offset * 2.0);\n" +
+                    "twoStepsPositiveTextureCoordinate = inputTextureCoordinate + (offset * 2.0);\n" +
+                    "threeStepsNegativeTextureCoordinate = inputTextureCoordinate - (offset * 3.0);\n" +
+                    "threeStepsPositiveTextureCoordinate = inputTextureCoordinate + (offset * 3.0);\n" +
+                    "fourStepsNegativeTextureCoordinate = inputTextureCoordinate - (offset * 4.0);\n" +
+                    "fourStepsPositiveTextureCoordinate = inputTextureCoordinate + (offset * 4.0);\n" +
+                    "}\n";
+
+
+    public static final String FRAGMENT_SHADER_1 =
+            "precision lowp float;\n" +
+                    "\n" +
+                    "varying vec2 centerTextureCoordinate;\n" +
+                    "varying vec2 oneStepPositiveTextureCoordinate;\n" +
+                    "varying vec2 oneStepNegativeTextureCoordinate;\n" +
+                    "\n" +
+                    "uniform sampler2D inputImageTexture;\n" +
+                    "\n" +
+                    "void main()\n" +
+                    "{\n" +
+                    "float centerIntensity = texture2D(inputImageTexture, centerTextureCoordinate).r;\n" +
+                    "float oneStepPositiveIntensity = texture2D(inputImageTexture, oneStepPositiveTextureCoordinate).r;\n" +
+                    "float oneStepNegativeIntensity = texture2D(inputImageTexture, oneStepNegativeTextureCoordinate).r;\n" +
+                    "\n" +
+                    "lowp float maxValue = max(centerIntensity, oneStepPositiveIntensity);\n" +
+                    "maxValue = max(maxValue, oneStepNegativeIntensity);\n" +
+                    "\n" +
+                    "gl_FragColor = vec4(vec3(maxValue), 1.0);\n" +
+                    "}\n";
+
+    public static final String FRAGMENT_SHADER_2 =
+            "precision lowp float;\n" +
+                    "\n" +
+                    "varying vec2 centerTextureCoordinate;\n" +
+                    "varying vec2 oneStepPositiveTextureCoordinate;\n" +
+                    "varying vec2 oneStepNegativeTextureCoordinate;\n" +
+                    "varying vec2 twoStepsPositiveTextureCoordinate;\n" +
+                    "varying vec2 twoStepsNegativeTextureCoordinate;\n" +
+                    "\n" +
+                    "uniform sampler2D inputImageTexture;\n" +
+                    "\n" +
+                    "void main()\n" +
+                    "{\n" +
+                    "float centerIntensity = texture2D(inputImageTexture, centerTextureCoordinate).r;\n" +
+                    "float oneStepPositiveIntensity = texture2D(inputImageTexture, oneStepPositiveTextureCoordinate).r;\n" +
+                    "float oneStepNegativeIntensity = texture2D(inputImageTexture, oneStepNegativeTextureCoordinate).r;\n" +
+                    "float twoStepsPositiveIntensity = texture2D(inputImageTexture, twoStepsPositiveTextureCoordinate).r;\n" +
+                    "float twoStepsNegativeIntensity = texture2D(inputImageTexture, twoStepsNegativeTextureCoordinate).r;\n" +
+                    "\n" +
+                    "lowp float maxValue = max(centerIntensity, oneStepPositiveIntensity);\n" +
+                    "maxValue = max(maxValue, oneStepNegativeIntensity);\n" +
+                    "maxValue = max(maxValue, twoStepsPositiveIntensity);\n" +
+                    "maxValue = max(maxValue, twoStepsNegativeIntensity);\n" +
+                    "\n" +
+                    "gl_FragColor = vec4(vec3(maxValue), 1.0);\n" +
+                    "}\n";
+
+    public static final String FRAGMENT_SHADER_3 =
+            "precision lowp float;\n" +
+                    "\n" +
+                    "varying vec2 centerTextureCoordinate;\n" +
+                    "varying vec2 oneStepPositiveTextureCoordinate;\n" +
+                    "varying vec2 oneStepNegativeTextureCoordinate;\n" +
+                    "varying vec2 twoStepsPositiveTextureCoordinate;\n" +
+                    "varying vec2 twoStepsNegativeTextureCoordinate;\n" +
+                    "varying vec2 threeStepsPositiveTextureCoordinate;\n" +
+                    "varying vec2 threeStepsNegativeTextureCoordinate;\n" +
+                    "\n" +
+                    "uniform sampler2D inputImageTexture;\n" +
+                    "\n" +
+                    "void main()\n" +
+                    "{\n" +
+                    "float centerIntensity = texture2D(inputImageTexture, centerTextureCoordinate).r;\n" +
+                    "float oneStepPositiveIntensity = texture2D(inputImageTexture, oneStepPositiveTextureCoordinate).r;\n" +
+                    "float oneStepNegativeIntensity = texture2D(inputImageTexture, oneStepNegativeTextureCoordinate).r;\n" +
+                    "float twoStepsPositiveIntensity = texture2D(inputImageTexture, twoStepsPositiveTextureCoordinate).r;\n" +
+                    "float twoStepsNegativeIntensity = texture2D(inputImageTexture, twoStepsNegativeTextureCoordinate).r;\n" +
+                    "float threeStepsPositiveIntensity = texture2D(inputImageTexture, threeStepsPositiveTextureCoordinate).r;\n" +
+                    "float threeStepsNegativeIntensity = texture2D(inputImageTexture, threeStepsNegativeTextureCoordinate).r;\n" +
+                    "\n" +
+                    "lowp float maxValue = max(centerIntensity, oneStepPositiveIntensity);\n" +
+                    "maxValue = max(maxValue, oneStepNegativeIntensity);\n" +
+                    "maxValue = max(maxValue, twoStepsPositiveIntensity);\n" +
+                    "maxValue = max(maxValue, twoStepsNegativeIntensity);\n" +
+                    "maxValue = max(maxValue, threeStepsPositiveIntensity);\n" +
+                    "maxValue = max(maxValue, threeStepsNegativeIntensity);\n" +
+                    "\n" +
+                    "gl_FragColor = vec4(vec3(maxValue), 1.0);\n" +
+                    "}\n";
+
+    public static final String FRAGMENT_SHADER_4 =
+            "precision lowp float;\n" +
+                    "\n" +
+                    "varying vec2 centerTextureCoordinate;\n" +
+                    "varying vec2 oneStepPositiveTextureCoordinate;\n" +
+                    "varying vec2 oneStepNegativeTextureCoordinate;\n" +
+                    "varying vec2 twoStepsPositiveTextureCoordinate;\n" +
+                    "varying vec2 twoStepsNegativeTextureCoordinate;\n" +
+                    "varying vec2 threeStepsPositiveTextureCoordinate;\n" +
+                    "varying vec2 threeStepsNegativeTextureCoordinate;\n" +
+                    "varying vec2 fourStepsPositiveTextureCoordinate;\n" +
+                    "varying vec2 fourStepsNegativeTextureCoordinate;\n" +
+                    "\n" +
+                    "uniform sampler2D inputImageTexture;\n" +
+                    "\n" +
+                    "void main()\n" +
+                    "{\n" +
+                    "float centerIntensity = texture2D(inputImageTexture, centerTextureCoordinate).r;\n" +
+                    "float oneStepPositiveIntensity = texture2D(inputImageTexture, oneStepPositiveTextureCoordinate).r;\n" +
+                    "float oneStepNegativeIntensity = texture2D(inputImageTexture, oneStepNegativeTextureCoordinate).r;\n" +
+                    "float twoStepsPositiveIntensity = texture2D(inputImageTexture, twoStepsPositiveTextureCoordinate).r;\n" +
+                    "float twoStepsNegativeIntensity = texture2D(inputImageTexture, twoStepsNegativeTextureCoordinate).r;\n" +
+                    "float threeStepsPositiveIntensity = texture2D(inputImageTexture, threeStepsPositiveTextureCoordinate).r;\n" +
+                    "float threeStepsNegativeIntensity = texture2D(inputImageTexture, threeStepsNegativeTextureCoordinate).r;\n" +
+                    "float fourStepsPositiveIntensity = texture2D(inputImageTexture, fourStepsPositiveTextureCoordinate).r;\n" +
+                    "float fourStepsNegativeIntensity = texture2D(inputImageTexture, fourStepsNegativeTextureCoordinate).r;\n" +
+                    "\n" +
+                    "lowp float maxValue = max(centerIntensity, oneStepPositiveIntensity);\n" +
+                    "maxValue = max(maxValue, oneStepNegativeIntensity);\n" +
+                    "maxValue = max(maxValue, twoStepsPositiveIntensity);\n" +
+                    "maxValue = max(maxValue, twoStepsNegativeIntensity);\n" +
+                    "maxValue = max(maxValue, threeStepsPositiveIntensity);\n" +
+                    "maxValue = max(maxValue, threeStepsNegativeIntensity);\n" +
+                    "maxValue = max(maxValue, fourStepsPositiveIntensity);\n" +
+                    "maxValue = max(maxValue, fourStepsNegativeIntensity);\n" +
+                    "\n" +
+                    "gl_FragColor = vec4(vec3(maxValue), 1.0);\n" +
+                    "}\n";
+
+
+    public GPUImageDilationFilter() {
+        this(1);
+    }
+
+    /**
+     * Acceptable values for dilationRadius, which sets the distance in pixels to sample out from the center,
+     * are 1, 2, 3, and 4.
+     *
+     * @param radius 1, 2, 3 or 4
+     */
+    public GPUImageDilationFilter(int radius) {
+        this(getVertexShader(radius), getFragmentShader(radius));
+    }
+
+    private GPUImageDilationFilter(String vertexShader, String fragmentShader) {
+        super(vertexShader, fragmentShader, vertexShader, fragmentShader);
+    }
+
+    private static String getVertexShader(int radius) {
+        switch (radius) {
+            case 0:
+            case 1:
+                return VERTEX_SHADER_1;
+            case 2:
+                return VERTEX_SHADER_2;
+            case 3:
+                return VERTEX_SHADER_3;
+            default:
+                return VERTEX_SHADER_4;
+        }
+    }
+
+    private static String getFragmentShader(int radius) {
+        switch (radius) {
+            case 0:
+            case 1:
+                return FRAGMENT_SHADER_1;
+            case 2:
+                return FRAGMENT_SHADER_2;
+            case 3:
+                return FRAGMENT_SHADER_3;
+            default:
+                return FRAGMENT_SHADER_4;
+        }
+    }
+}
diff --git a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageEmbossFilter.java b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageEmbossFilter.java
index e363bfab..f4cbdef7 100644
--- a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageEmbossFilter.java
+++ b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageEmbossFilter.java
@@ -17,8 +17,8 @@
 package jp.co.cyberagent.android.gpuimage;
 
 /**
- * Applies an emboss effect to the image.<br />
- * <br />
+ * Applies an emboss effect to the image.<br>
+ * <br>
  * Intensity ranges from 0.0 to 4.0, with 1.0 as the normal level
  */
 public class GPUImageEmbossFilter extends GPUImage3x3ConvolutionFilter {
diff --git a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageFalseColorFilter.java b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageFalseColorFilter.java
new file mode 100644
index 00000000..c815ad0f
--- /dev/null
+++ b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageFalseColorFilter.java
@@ -0,0 +1,84 @@
+/*
+ * Copyright (C) 2012 CyberAgent
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package jp.co.cyberagent.android.gpuimage;
+
+import android.opengl.GLES20;
+
+public class GPUImageFalseColorFilter extends GPUImageFilter {
+    public static final String FALSECOLOR_FRAGMENT_SHADER = "" +
+            "precision lowp float;\n" +
+            "\n" +
+            "varying highp vec2 textureCoordinate;\n" +
+            "\n" +
+            "uniform sampler2D inputImageTexture;\n" +
+            "uniform float intensity;\n" +
+            "uniform vec3 firstColor;\n" +
+            "uniform vec3 secondColor;\n" +
+            "\n" +
+            "const mediump vec3 luminanceWeighting = vec3(0.2125, 0.7154, 0.0721);\n" +
+            "\n" +
+            "void main()\n" +
+            "{\n" +
+            "lowp vec4 textureColor = texture2D(inputImageTexture, textureCoordinate);\n" +
+            "float luminance = dot(textureColor.rgb, luminanceWeighting);\n" +
+            "\n" +
+            "gl_FragColor = vec4( mix(firstColor.rgb, secondColor.rgb, luminance), textureColor.a);\n" +
+            "}\n";
+
+    private float[] mFirstColor;
+    private int mFirstColorLocation;
+    private float[] mSecondColor;
+    private int mSecondColorLocation;
+
+    public GPUImageFalseColorFilter() {
+        this(0f, 0f, 0.5f, 1f, 0f, 0f);
+    }
+
+    public GPUImageFalseColorFilter(float firstRed, float firstGreen, float firstBlue, float secondRed, float secondGreen, float secondBlue) {
+        this(new float[]{firstRed, firstGreen, firstBlue}, new float[]{secondRed, secondGreen, secondBlue});
+    }
+
+    public GPUImageFalseColorFilter(float[] firstColor, float[] secondColor) {
+        super(NO_FILTER_VERTEX_SHADER, FALSECOLOR_FRAGMENT_SHADER);
+        mFirstColor = firstColor;
+        mSecondColor = secondColor;
+    }
+
+    @Override
+    public void onInit() {
+        super.onInit();
+        mFirstColorLocation = GLES20.glGetUniformLocation(getProgram(), "firstColor");
+        mSecondColorLocation = GLES20.glGetUniformLocation(getProgram(), "secondColor");
+    }
+
+    @Override
+    public void onInitialized() {
+        super.onInitialized();
+        setFirstColor(mFirstColor);
+        setSecondColor(mSecondColor);
+    }
+
+    public void setFirstColor(final float[] firstColor) {
+        mFirstColor = firstColor;
+        setFloatVec3(mFirstColorLocation, firstColor);
+    }
+
+    public void setSecondColor(final float[] secondColor) {
+        mSecondColor = secondColor;
+        setFloatVec3(mSecondColorLocation, secondColor);
+    }
+}
diff --git a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageFilter.java b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageFilter.java
index 896c2648..7a8641aa 100644
--- a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageFilter.java
+++ b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageFilter.java
@@ -54,8 +54,8 @@
     protected int mGLAttribPosition;
     protected int mGLUniformTexture;
     protected int mGLAttribTextureCoordinate;
-    private int mOutputWidth;
-    private int mOutputHeight;
+    protected int mOutputWidth;
+    protected int mOutputHeight;
     private boolean mIsInitialized;
 
     public GPUImageFilter() {
@@ -222,9 +222,9 @@ protected void setPoint(final int location, final PointF point) {
 
             @Override
             public void run() {
-            	float[] vec2 = new float[2];
-            	vec2[0] = point.x;
-            	vec2[1] = point.y;
+                float[] vec2 = new float[2];
+                vec2[0] = point.x;
+                vec2[1] = point.y;
                 GLES20.glUniform2fv(location, 1, vec2, 0);
             }
         });
diff --git a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageFilterGroup.java b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageFilterGroup.java
index 0be65639..10ea41ca 100644
--- a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageFilterGroup.java
+++ b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageFilterGroup.java
@@ -16,12 +16,14 @@
 
 package jp.co.cyberagent.android.gpuimage;
 
+import android.annotation.SuppressLint;
 import android.opengl.GLES20;
 import jp.co.cyberagent.android.gpuimage.util.TextureRotationUtil;
 
 import java.nio.ByteBuffer;
 import java.nio.ByteOrder;
 import java.nio.FloatBuffer;
+import java.util.ArrayList;
 import java.util.List;
 
 import static jp.co.cyberagent.android.gpuimage.GPUImageRenderer.CUBE;
@@ -33,7 +35,8 @@
  */
 public class GPUImageFilterGroup extends GPUImageFilter {
 
-    private final List<GPUImageFilter> mFilters;
+    protected List<GPUImageFilter> mFilters;
+    protected List<GPUImageFilter> mMergedFilters;
     private int[] mFrameBuffers;
     private int[] mFrameBufferTextures;
 
@@ -41,13 +44,26 @@
     private final FloatBuffer mGLTextureBuffer;
     private final FloatBuffer mGLTextureFlipBuffer;
 
+    /**
+     * Instantiates a new GPUImageFilterGroup with no filters.
+     */
+    public GPUImageFilterGroup() {
+        this(null);
+    }
+
     /**
      * Instantiates a new GPUImageFilterGroup with the given filters.
      *
      * @param filters the filters which represent this filter
      */
-    public GPUImageFilterGroup(final List<GPUImageFilter> filters) {
+    public GPUImageFilterGroup(List<GPUImageFilter> filters) {
         mFilters = filters;
+        if (mFilters == null) {
+            mFilters = new ArrayList<GPUImageFilter>();
+        } else {
+            updateMergedFilters();
+        }
+
         mGLCubeBuffer = ByteBuffer.allocateDirect(CUBE.length * 4)
                 .order(ByteOrder.nativeOrder())
                 .asFloatBuffer();
@@ -65,6 +81,14 @@ public GPUImageFilterGroup(final List<GPUImageFilter> filters) {
         mGLTextureFlipBuffer.put(flipTexture).position(0);
     }
 
+    public void addFilter(GPUImageFilter aFilter) {
+        if (aFilter == null) {
+            return;
+        }
+        mFilters.add(aFilter);
+        updateMergedFilters();
+    }
+
     /*
      * (non-Javadoc)
      * @see jp.co.cyberagent.android.gpuimage.GPUImageFilter#onInit()
@@ -113,33 +137,40 @@ public void onOutputSizeChanged(final int width, final int height) {
         if (mFrameBuffers != null) {
             destroyFramebuffers();
         }
-        mFrameBuffers = new int[mFilters.size() - 1];
-        mFrameBufferTextures = new int[mFilters.size() - 1];
 
-        for (int i = 0; i < mFilters.size() - 1; i++) {
+        int size = mFilters.size();
+        for (int i = 0; i < size; i++) {
             mFilters.get(i).onOutputSizeChanged(width, height);
-            GLES20.glGenFramebuffers(1, mFrameBuffers, i);
-            GLES20.glGenTextures(1, mFrameBufferTextures, i);
-            GLES20.glBindTexture(GLES20.GL_TEXTURE_2D, mFrameBufferTextures[i]);
-            GLES20.glTexImage2D(GLES20.GL_TEXTURE_2D, 0, GLES20.GL_RGBA, width, height, 0,
-                    GLES20.GL_RGBA, GLES20.GL_UNSIGNED_BYTE, null);
-            GLES20.glTexParameterf(GLES20.GL_TEXTURE_2D,
-                    GLES20.GL_TEXTURE_MAG_FILTER, GLES20.GL_LINEAR);
-            GLES20.glTexParameterf(GLES20.GL_TEXTURE_2D,
-                    GLES20.GL_TEXTURE_MIN_FILTER, GLES20.GL_LINEAR);
-            GLES20.glTexParameterf(GLES20.GL_TEXTURE_2D,
-                    GLES20.GL_TEXTURE_WRAP_S, GLES20.GL_CLAMP_TO_EDGE);
-            GLES20.glTexParameterf(GLES20.GL_TEXTURE_2D,
-                    GLES20.GL_TEXTURE_WRAP_T, GLES20.GL_CLAMP_TO_EDGE);
-
-            GLES20.glBindFramebuffer(GLES20.GL_FRAMEBUFFER, mFrameBuffers[i]);
-            GLES20.glFramebufferTexture2D(GLES20.GL_FRAMEBUFFER, GLES20.GL_COLOR_ATTACHMENT0,
-                    GLES20.GL_TEXTURE_2D, mFrameBufferTextures[i], 0);
-
-            GLES20.glBindTexture(GLES20.GL_TEXTURE_2D, 0);
-            GLES20.glBindFramebuffer(GLES20.GL_FRAMEBUFFER, 0);
         }
-        mFilters.get(mFilters.size() - 1).onOutputSizeChanged(width, height);
+
+        if (mMergedFilters != null && mMergedFilters.size() > 0) {
+            size = mMergedFilters.size();
+            mFrameBuffers = new int[size - 1];
+            mFrameBufferTextures = new int[size - 1];
+
+            for (int i = 0; i < size - 1; i++) {
+                GLES20.glGenFramebuffers(1, mFrameBuffers, i);
+                GLES20.glGenTextures(1, mFrameBufferTextures, i);
+                GLES20.glBindTexture(GLES20.GL_TEXTURE_2D, mFrameBufferTextures[i]);
+                GLES20.glTexImage2D(GLES20.GL_TEXTURE_2D, 0, GLES20.GL_RGBA, width, height, 0,
+                        GLES20.GL_RGBA, GLES20.GL_UNSIGNED_BYTE, null);
+                GLES20.glTexParameterf(GLES20.GL_TEXTURE_2D,
+                        GLES20.GL_TEXTURE_MAG_FILTER, GLES20.GL_LINEAR);
+                GLES20.glTexParameterf(GLES20.GL_TEXTURE_2D,
+                        GLES20.GL_TEXTURE_MIN_FILTER, GLES20.GL_LINEAR);
+                GLES20.glTexParameterf(GLES20.GL_TEXTURE_2D,
+                        GLES20.GL_TEXTURE_WRAP_S, GLES20.GL_CLAMP_TO_EDGE);
+                GLES20.glTexParameterf(GLES20.GL_TEXTURE_2D,
+                        GLES20.GL_TEXTURE_WRAP_T, GLES20.GL_CLAMP_TO_EDGE);
+
+                GLES20.glBindFramebuffer(GLES20.GL_FRAMEBUFFER, mFrameBuffers[i]);
+                GLES20.glFramebufferTexture2D(GLES20.GL_FRAMEBUFFER, GLES20.GL_COLOR_ATTACHMENT0,
+                        GLES20.GL_TEXTURE_2D, mFrameBufferTextures[i], 0);
+
+                GLES20.glBindTexture(GLES20.GL_TEXTURE_2D, 0);
+                GLES20.glBindFramebuffer(GLES20.GL_FRAMEBUFFER, 0);
+            }
+        }
     }
 
     /*
@@ -147,25 +178,40 @@ public void onOutputSizeChanged(final int width, final int height) {
      * @see jp.co.cyberagent.android.gpuimage.GPUImageFilter#onDraw(int,
      * java.nio.FloatBuffer, java.nio.FloatBuffer)
      */
+    @SuppressLint("WrongCall")    
     @Override
     public void onDraw(final int textureId, final FloatBuffer cubeBuffer,
-            final FloatBuffer textureBuffer) {
+                       final FloatBuffer textureBuffer) {
         runPendingOnDrawTasks();
         if (!isInitialized() || mFrameBuffers == null || mFrameBufferTextures == null) {
             return;
         }
-        int previousTexture = textureId;
-        for (int i = 0; i < mFilters.size() - 1; i++) {
-            GPUImageFilter filter = mFilters.get(i);
-            GLES20.glBindFramebuffer(GLES20.GL_FRAMEBUFFER, mFrameBuffers[i]);
-            GLES20.glClearColor(0, 0, 0, 1);
-            filter.onDraw(previousTexture, mGLCubeBuffer,
-                    (i == 0 && mFilters.size() % 2 == 0) ? mGLTextureFlipBuffer : mGLTextureBuffer);
-            GLES20.glBindFramebuffer(GLES20.GL_FRAMEBUFFER, 0);
-            previousTexture = mFrameBufferTextures[i];
+        if (mMergedFilters != null) {
+            int size = mMergedFilters.size();
+            int previousTexture = textureId;
+            for (int i = 0; i < size; i++) {
+                GPUImageFilter filter = mMergedFilters.get(i);
+                boolean isNotLast = i < size - 1;
+                if (isNotLast) {
+                    GLES20.glBindFramebuffer(GLES20.GL_FRAMEBUFFER, mFrameBuffers[i]);
+                    GLES20.glClearColor(0, 0, 0, 0);
+                }
+
+                if (i == 0) {
+                    filter.onDraw(previousTexture, cubeBuffer, textureBuffer);
+                } else if (i == size - 1) {
+                    filter.onDraw(previousTexture, mGLCubeBuffer, (size % 2 == 0) ? mGLTextureFlipBuffer : mGLTextureBuffer);
+                } else {
+                    filter.onDraw(previousTexture, mGLCubeBuffer, mGLTextureBuffer);
+                }
+
+                if (isNotLast) {
+                    GLES20.glBindFramebuffer(GLES20.GL_FRAMEBUFFER, 0);
+                    previousTexture = mFrameBufferTextures[i];
+                }
+            }
         }
-        mFilters.get(mFilters.size() - 1).onDraw(previousTexture, cubeBuffer, textureBuffer);
-    }
+     }
 
     /**
      * Gets the filters.
@@ -175,4 +221,33 @@ public void onDraw(final int textureId, final FloatBuffer cubeBuffer,
     public List<GPUImageFilter> getFilters() {
         return mFilters;
     }
+
+    public List<GPUImageFilter> getMergedFilters() {
+        return mMergedFilters;
+    }
+
+    public void updateMergedFilters() {
+        if (mFilters == null) {
+            return;
+        }
+
+        if (mMergedFilters == null) {
+            mMergedFilters = new ArrayList<GPUImageFilter>();
+        } else {
+            mMergedFilters.clear();
+        }
+
+        List<GPUImageFilter> filters;
+        for (GPUImageFilter filter : mFilters) {
+            if (filter instanceof GPUImageFilterGroup) {
+                ((GPUImageFilterGroup) filter).updateMergedFilters();
+                filters = ((GPUImageFilterGroup) filter).getMergedFilters();
+                if (filters == null || filters.isEmpty())
+                    continue;
+                mMergedFilters.addAll(filters);
+                continue;
+            }
+            mMergedFilters.add(filter);
+        }
+    }
 }
diff --git a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageGaussianBlurFilter.java b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageGaussianBlurFilter.java
new file mode 100644
index 00000000..c912f73e
--- /dev/null
+++ b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageGaussianBlurFilter.java
@@ -0,0 +1,116 @@
+/*
+ * Copyright (C) 2012 CyberAgent
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package jp.co.cyberagent.android.gpuimage;
+
+/**
+ * A more generalized 9x9 Gaussian blur filter
+ * blurSize value ranging from 0.0 on up, with a default of 1.0
+ */
+public class GPUImageGaussianBlurFilter extends GPUImageTwoPassTextureSamplingFilter {
+    public static final String VERTEX_SHADER =
+            "attribute vec4 position;\n" +
+                    "attribute vec4 inputTextureCoordinate;\n" +
+                    "\n" +
+                    "const int GAUSSIAN_SAMPLES = 9;\n" +
+                    "\n" +
+                    "uniform float texelWidthOffset;\n" +
+                    "uniform float texelHeightOffset;\n" +
+                    "\n" +
+                    "varying vec2 textureCoordinate;\n" +
+                    "varying vec2 blurCoordinates[GAUSSIAN_SAMPLES];\n" +
+                    "\n" +
+                    "void main()\n" +
+                    "{\n" +
+                    "	gl_Position = position;\n" +
+                    "	textureCoordinate = inputTextureCoordinate.xy;\n" +
+                    "	\n" +
+                    "	// Calculate the positions for the blur\n" +
+                    "	int multiplier = 0;\n" +
+                    "	vec2 blurStep;\n" +
+                    "   vec2 singleStepOffset = vec2(texelHeightOffset, texelWidthOffset);\n" +
+                    "    \n" +
+                    "	for (int i = 0; i < GAUSSIAN_SAMPLES; i++)\n" +
+                    "   {\n" +
+                    "		multiplier = (i - ((GAUSSIAN_SAMPLES - 1) / 2));\n" +
+                    "       // Blur in x (horizontal)\n" +
+                    "       blurStep = float(multiplier) * singleStepOffset;\n" +
+                    "		blurCoordinates[i] = inputTextureCoordinate.xy + blurStep;\n" +
+                    "	}\n" +
+                    "}\n";
+
+    public static final String FRAGMENT_SHADER =
+            "uniform sampler2D inputImageTexture;\n" +
+                    "\n" +
+                    "const lowp int GAUSSIAN_SAMPLES = 9;\n" +
+                    "\n" +
+                    "varying highp vec2 textureCoordinate;\n" +
+                    "varying highp vec2 blurCoordinates[GAUSSIAN_SAMPLES];\n" +
+                    "\n" +
+                    "void main()\n" +
+                    "{\n" +
+                    "	lowp vec3 sum = vec3(0.0);\n" +
+                    "   lowp vec4 fragColor=texture2D(inputImageTexture,textureCoordinate);\n" +
+                    "	\n" +
+                    "    sum += texture2D(inputImageTexture, blurCoordinates[0]).rgb * 0.05;\n" +
+                    "    sum += texture2D(inputImageTexture, blurCoordinates[1]).rgb * 0.09;\n" +
+                    "    sum += texture2D(inputImageTexture, blurCoordinates[2]).rgb * 0.12;\n" +
+                    "    sum += texture2D(inputImageTexture, blurCoordinates[3]).rgb * 0.15;\n" +
+                    "    sum += texture2D(inputImageTexture, blurCoordinates[4]).rgb * 0.18;\n" +
+                    "    sum += texture2D(inputImageTexture, blurCoordinates[5]).rgb * 0.15;\n" +
+                    "    sum += texture2D(inputImageTexture, blurCoordinates[6]).rgb * 0.12;\n" +
+                    "    sum += texture2D(inputImageTexture, blurCoordinates[7]).rgb * 0.09;\n" +
+                    "    sum += texture2D(inputImageTexture, blurCoordinates[8]).rgb * 0.05;\n" +
+                    "\n" +
+                    "	gl_FragColor = vec4(sum,fragColor.a);\n" +
+                    "}";
+
+    protected float mBlurSize = 1f;
+
+    public GPUImageGaussianBlurFilter() {
+        this(1f);
+    }
+
+    public GPUImageGaussianBlurFilter(float blurSize) {
+        super(VERTEX_SHADER, FRAGMENT_SHADER, VERTEX_SHADER, FRAGMENT_SHADER);
+        mBlurSize = blurSize;
+    }
+
+    @Override
+    public float getVerticalTexelOffsetRatio() {
+        return mBlurSize;
+    }
+
+    @Override
+    public float getHorizontalTexelOffsetRatio() {
+        return mBlurSize;
+    }
+
+    /**
+     * A multiplier for the blur size, ranging from 0.0 on up, with a default of 1.0
+     *
+     * @param blurSize from 0.0 on up, default 1.0
+     */
+    public void setBlurSize(float blurSize) {
+        mBlurSize = blurSize;
+        runOnDraw(new Runnable() {
+            @Override
+            public void run() {
+                initTexelOffsets();
+            }
+        });
+    }
+}
diff --git a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageGlassSphereFilter.java b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageGlassSphereFilter.java
new file mode 100644
index 00000000..460019cc
--- /dev/null
+++ b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageGlassSphereFilter.java
@@ -0,0 +1,127 @@
+/*
+ * Copyright (C) 2012 CyberAgent
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package jp.co.cyberagent.android.gpuimage;
+
+import android.graphics.PointF;
+import android.opengl.GLES20;
+
+public class GPUImageGlassSphereFilter extends GPUImageFilter {
+    public static final String SPHERE_FRAGMENT_SHADER = "" +
+            "varying highp vec2 textureCoordinate;\n" +
+            "\n" +
+            "uniform sampler2D inputImageTexture;\n" +
+            "\n" +
+            "uniform highp vec2 center;\n" +
+            "uniform highp float radius;\n" +
+            "uniform highp float aspectRatio;\n" +
+            "uniform highp float refractiveIndex;\n" +
+            "// uniform vec3 lightPosition;\n" +
+            "const highp vec3 lightPosition = vec3(-0.5, 0.5, 1.0);\n" +
+            "const highp vec3 ambientLightPosition = vec3(0.0, 0.0, 1.0);\n" +
+            "\n" +
+            "void main()\n" +
+            "{\n" +
+            "highp vec2 textureCoordinateToUse = vec2(textureCoordinate.x, (textureCoordinate.y * aspectRatio + 0.5 - 0.5 * aspectRatio));\n" +
+            "highp float distanceFromCenter = distance(center, textureCoordinateToUse);\n" +
+            "lowp float checkForPresenceWithinSphere = step(distanceFromCenter, radius);\n" +
+            "\n" +
+            "distanceFromCenter = distanceFromCenter / radius;\n" +
+            "\n" +
+            "highp float normalizedDepth = radius * sqrt(1.0 - distanceFromCenter * distanceFromCenter);\n" +
+            "highp vec3 sphereNormal = normalize(vec3(textureCoordinateToUse - center, normalizedDepth));\n" +
+            "\n" +
+            "highp vec3 refractedVector = 2.0 * refract(vec3(0.0, 0.0, -1.0), sphereNormal, refractiveIndex);\n" +
+            "refractedVector.xy = -refractedVector.xy;\n" +
+            "\n" +
+            "highp vec3 finalSphereColor = texture2D(inputImageTexture, (refractedVector.xy + 1.0) * 0.5).rgb;\n" +
+            "\n" +
+            "// Grazing angle lighting\n" +
+            "highp float lightingIntensity = 2.5 * (1.0 - pow(clamp(dot(ambientLightPosition, sphereNormal), 0.0, 1.0), 0.25));\n" +
+            "finalSphereColor += lightingIntensity;\n" +
+            "\n" +
+            "// Specular lighting\n" +
+            "lightingIntensity  = clamp(dot(normalize(lightPosition), sphereNormal), 0.0, 1.0);\n" +
+            "lightingIntensity  = pow(lightingIntensity, 15.0);\n" +
+            "finalSphereColor += vec3(0.8, 0.8, 0.8) * lightingIntensity;\n" +
+            "\n" +
+            "gl_FragColor = vec4(finalSphereColor, 1.0) * checkForPresenceWithinSphere;\n" +
+            "}\n";
+
+    private PointF mCenter;
+    private int mCenterLocation;
+    private float mRadius;
+    private int mRadiusLocation;
+    private float mAspectRatio;
+    private int mAspectRatioLocation;
+    private float mRefractiveIndex;
+    private int mRefractiveIndexLocation;
+
+    public GPUImageGlassSphereFilter() {
+        this(new PointF(0.5f, 0.5f), 0.25f, 0.71f);
+    }
+
+    public GPUImageGlassSphereFilter(PointF center, float radius, float refractiveIndex) {
+        super(NO_FILTER_VERTEX_SHADER, SPHERE_FRAGMENT_SHADER);
+        mCenter = center;
+        mRadius = radius;
+        mRefractiveIndex = refractiveIndex;
+    }
+
+    @Override
+    public void onInit() {
+        super.onInit();
+        mCenterLocation = GLES20.glGetUniformLocation(getProgram(), "center");
+        mRadiusLocation = GLES20.glGetUniformLocation(getProgram(), "radius");
+        mAspectRatioLocation = GLES20.glGetUniformLocation(getProgram(), "aspectRatio");
+        mRefractiveIndexLocation = GLES20.glGetUniformLocation(getProgram(), "refractiveIndex");
+    }
+
+    @Override
+    public void onInitialized() {
+        super.onInitialized();
+        setRadius(mRadius);
+        setCenter(mCenter);
+        setRefractiveIndex(mRefractiveIndex);
+    }
+
+    @Override
+    public void onOutputSizeChanged(int width, int height) {
+        mAspectRatio = (float) height / width;
+        setAspectRatio(mAspectRatio);
+        super.onOutputSizeChanged(width, height);
+    }
+
+    private void setAspectRatio(float aspectRatio) {
+        mAspectRatio = aspectRatio;
+        setFloat(mAspectRatioLocation, aspectRatio);
+    }
+
+    public void setRefractiveIndex(float refractiveIndex) {
+        mRefractiveIndex = refractiveIndex;
+        setFloat(mRefractiveIndexLocation, refractiveIndex);
+    }
+
+    public void setCenter(PointF center) {
+        mCenter = center;
+        setPoint(mCenterLocation, center);
+    }
+
+    public void setRadius(float radius) {
+        mRadius = radius;
+        setFloat(mRadiusLocation, radius);
+    }
+}
diff --git a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageHalftoneFilter.java b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageHalftoneFilter.java
new file mode 100644
index 00000000..52e27d04
--- /dev/null
+++ b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageHalftoneFilter.java
@@ -0,0 +1,67 @@
+package jp.co.cyberagent.android.gpuimage;
+
+import android.opengl.GLES20;
+
+public class GPUImageHalftoneFilter extends GPUImageFilter {
+    public static final String HALFTONE_FRAGMENT_SHADER = "" +
+            "varying highp vec2 textureCoordinate;\n" +
+
+            "uniform sampler2D inputImageTexture;\n" +
+
+            "uniform highp float fractionalWidthOfPixel;\n" +
+            "uniform highp float aspectRatio;\n" +
+
+            "const highp vec3 W = vec3(0.2125, 0.7154, 0.0721);\n" +
+
+            "void main()\n" +
+            "{\n" +
+            "  highp vec2 sampleDivisor = vec2(fractionalWidthOfPixel, fractionalWidthOfPixel / aspectRatio);\n" +
+            "  highp vec2 samplePos = textureCoordinate - mod(textureCoordinate, sampleDivisor) + 0.5 * sampleDivisor;\n" +
+            "  highp vec2 textureCoordinateToUse = vec2(textureCoordinate.x, (textureCoordinate.y * aspectRatio + 0.5 - 0.5 * aspectRatio));\n" +
+            "  highp vec2 adjustedSamplePos = vec2(samplePos.x, (samplePos.y * aspectRatio + 0.5 - 0.5 * aspectRatio));\n" +
+            "  highp float distanceFromSamplePoint = distance(adjustedSamplePos, textureCoordinateToUse);\n" +
+            "  lowp vec3 sampledColor = texture2D(inputImageTexture, samplePos).rgb;\n" +
+            "  highp float dotScaling = 1.0 - dot(sampledColor, W);\n" +
+            "  lowp float checkForPresenceWithinDot = 1.0 - step(distanceFromSamplePoint, (fractionalWidthOfPixel * 0.5) * dotScaling);\n" +
+            "  gl_FragColor = vec4(vec3(checkForPresenceWithinDot), 1.0);\n" +
+            "}";
+
+    private int mFractionalWidthOfPixelLocation;
+    private int mAspectRatioLocation;
+
+    private float mFractionalWidthOfAPixel;
+    private float mAspectRatio;
+
+    public GPUImageHalftoneFilter() {
+        this(0.01f);
+    }
+
+    public GPUImageHalftoneFilter(float fractionalWidthOfAPixel) {
+        super(NO_FILTER_VERTEX_SHADER, HALFTONE_FRAGMENT_SHADER);
+        mFractionalWidthOfAPixel = fractionalWidthOfAPixel;
+    }
+
+    @Override
+    public void onInit() {
+        super.onInit();
+        mFractionalWidthOfPixelLocation = GLES20.glGetUniformLocation(getProgram(), "fractionalWidthOfPixel");
+        mAspectRatioLocation = GLES20.glGetUniformLocation(getProgram(), "aspectRatio");
+        setFractionalWidthOfAPixel(mFractionalWidthOfAPixel);
+    }
+
+    @Override
+    public void onOutputSizeChanged(final int width, final int height) {
+        super.onOutputSizeChanged(width, height);
+        setAspectRatio((float)height / (float) width);
+    }
+
+    public void setFractionalWidthOfAPixel(final float fractionalWidthOfAPixel) {
+        mFractionalWidthOfAPixel = fractionalWidthOfAPixel;
+        setFloat(mFractionalWidthOfPixelLocation, mFractionalWidthOfAPixel);
+    }
+
+    public void setAspectRatio(final float aspectRatio) {
+        mAspectRatio = aspectRatio;
+        setFloat(mAspectRatioLocation, mAspectRatio);
+    }
+}
diff --git a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageHazeFilter.java b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageHazeFilter.java
new file mode 100644
index 00000000..bb230abc
--- /dev/null
+++ b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageHazeFilter.java
@@ -0,0 +1,97 @@
+/*
+ * Copyright (C) 2012 CyberAgent
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package jp.co.cyberagent.android.gpuimage;
+
+import android.opengl.GLES20;
+
+/**
+ * The haze filter can be used to add or remove haze.
+ *
+ * This is similar to a UV filter.
+ */
+public class GPUImageHazeFilter extends GPUImageFilter {
+    public static final String HAZE_FRAGMENT_SHADER = "" +
+            "varying highp vec2 textureCoordinate;\n" +
+            "\n" +
+            "uniform sampler2D inputImageTexture;\n" +
+            "\n" +
+            "uniform lowp float distance;\n" +
+            "uniform highp float slope;\n" +
+            "\n" +
+            "void main()\n" +
+            "{\n" +
+            "	//todo reconsider precision modifiers	 \n" +
+            "	 highp vec4 color = vec4(1.0);//todo reimplement as a parameter\n" +
+            "\n" +
+            "	 highp float  d = textureCoordinate.y * slope  +  distance; \n" +
+            "\n" +
+            "	 highp vec4 c = texture2D(inputImageTexture, textureCoordinate) ; // consider using unpremultiply\n" +
+            "\n" +
+            "	 c = (c - d * color) / (1.0 -d);\n" +
+            "\n" +
+            "	 gl_FragColor = c; //consider using premultiply(c);\n" +
+            "}\n";
+
+    private float mDistance;
+    private int mDistanceLocation;
+    private float mSlope;
+    private int mSlopeLocation;
+
+    public GPUImageHazeFilter() {
+        this(0.2f, 0.0f);
+    }
+
+    public GPUImageHazeFilter(float distance, float slope) {
+        super(NO_FILTER_VERTEX_SHADER, HAZE_FRAGMENT_SHADER);
+        mDistance = distance;
+        mSlope = slope;
+    }
+
+    @Override
+    public void onInit() {
+        super.onInit();
+        mDistanceLocation = GLES20.glGetUniformLocation(getProgram(), "distance");
+        mSlopeLocation = GLES20.glGetUniformLocation(getProgram(), "slope");
+    }
+
+    @Override
+    public void onInitialized() {
+        super.onInitialized();
+        setDistance(mDistance);
+        setSlope(mSlope);
+    }
+
+    /**
+     * Strength of the color applied. Default 0. Values between -.3 and .3 are best.
+     *
+     * @param distance -0.3 to 0.3 are best, default 0
+     */
+    public void setDistance(float distance) {
+        mDistance = distance;
+        setFloat(mDistanceLocation, distance);
+    }
+
+    /**
+     * Amount of color change. Default 0. Values between -.3 and .3 are best.
+     *
+     * @param slope -0.3 to 0.3 are best, default 0
+     */
+    public void setSlope(float slope) {
+        mSlope = slope;
+        setFloat(mSlopeLocation, slope);
+    }
+}
diff --git a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageKuwaharaFilter.java b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageKuwaharaFilter.java
new file mode 100644
index 00000000..6fc7f32b
--- /dev/null
+++ b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageKuwaharaFilter.java
@@ -0,0 +1,151 @@
+/*
+ * Copyright (C) 2012 CyberAgent
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package jp.co.cyberagent.android.gpuimage;
+
+import android.opengl.GLES20;
+
+/**
+ * Kuwahara image abstraction, drawn from the work of Kyprianidis, et. al. in their publication
+ * "Anisotropic Kuwahara Filtering on the GPU" within the GPU Pro collection. This produces an oil-painting-like
+ * image, but it is extremely computationally expensive, so it can take seconds to render a frame on an iPad 2.
+ * This might be best used for still images.
+ */
+public class GPUImageKuwaharaFilter extends GPUImageFilter {
+    public static final String KUWAHARA_FRAGMENT_SHADER = "" +
+            "varying highp vec2 textureCoordinate;\n" +
+            "uniform sampler2D inputImageTexture;\n" +
+            "uniform int radius;\n" +
+            "\n" +
+            "precision highp float;\n" +
+            "\n" +
+            "const vec2 src_size = vec2 (1.0 / 768.0, 1.0 / 1024.0);\n" +
+            "\n" +
+            "void main (void) \n" +
+            "{\n" +
+            "vec2 uv = textureCoordinate;\n" +
+            "float n = float((radius + 1) * (radius + 1));\n" +
+            "int i; int j;\n" +
+            "vec3 m0 = vec3(0.0); vec3 m1 = vec3(0.0); vec3 m2 = vec3(0.0); vec3 m3 = vec3(0.0);\n" +
+            "vec3 s0 = vec3(0.0); vec3 s1 = vec3(0.0); vec3 s2 = vec3(0.0); vec3 s3 = vec3(0.0);\n" +
+            "vec3 c;\n" +
+            "\n" +
+            "for (j = -radius; j <= 0; ++j)  {\n" +
+            "for (i = -radius; i <= 0; ++i)  {\n" +
+            "c = texture2D(inputImageTexture, uv + vec2(i,j) * src_size).rgb;\n" +
+            "m0 += c;\n" +
+            "s0 += c * c;\n" +
+            "}\n" +
+            "}\n" +
+            "\n" +
+            "for (j = -radius; j <= 0; ++j)  {\n" +
+            "for (i = 0; i <= radius; ++i)  {\n" +
+            "c = texture2D(inputImageTexture, uv + vec2(i,j) * src_size).rgb;\n" +
+            "m1 += c;\n" +
+            "s1 += c * c;\n" +
+            "}\n" +
+            "}\n" +
+            "\n" +
+            "for (j = 0; j <= radius; ++j)  {\n" +
+            "for (i = 0; i <= radius; ++i)  {\n" +
+            "c = texture2D(inputImageTexture, uv + vec2(i,j) * src_size).rgb;\n" +
+            "m2 += c;\n" +
+            "s2 += c * c;\n" +
+            "}\n" +
+            "}\n" +
+            "\n" +
+            "for (j = 0; j <= radius; ++j)  {\n" +
+            "for (i = -radius; i <= 0; ++i)  {\n" +
+            "c = texture2D(inputImageTexture, uv + vec2(i,j) * src_size).rgb;\n" +
+            "m3 += c;\n" +
+            "s3 += c * c;\n" +
+            "}\n" +
+            "}\n" +
+            "\n" +
+            "\n" +
+            "float min_sigma2 = 1e+2;\n" +
+            "m0 /= n;\n" +
+            "s0 = abs(s0 / n - m0 * m0);\n" +
+            "\n" +
+            "float sigma2 = s0.r + s0.g + s0.b;\n" +
+            "if (sigma2 < min_sigma2) {\n" +
+            "min_sigma2 = sigma2;\n" +
+            "gl_FragColor = vec4(m0, 1.0);\n" +
+            "}\n" +
+            "\n" +
+            "m1 /= n;\n" +
+            "s1 = abs(s1 / n - m1 * m1);\n" +
+            "\n" +
+            "sigma2 = s1.r + s1.g + s1.b;\n" +
+            "if (sigma2 < min_sigma2) {\n" +
+            "min_sigma2 = sigma2;\n" +
+            "gl_FragColor = vec4(m1, 1.0);\n" +
+            "}\n" +
+            "\n" +
+            "m2 /= n;\n" +
+            "s2 = abs(s2 / n - m2 * m2);\n" +
+            "\n" +
+            "sigma2 = s2.r + s2.g + s2.b;\n" +
+            "if (sigma2 < min_sigma2) {\n" +
+            "min_sigma2 = sigma2;\n" +
+            "gl_FragColor = vec4(m2, 1.0);\n" +
+            "}\n" +
+            "\n" +
+            "m3 /= n;\n" +
+            "s3 = abs(s3 / n - m3 * m3);\n" +
+            "\n" +
+            "sigma2 = s3.r + s3.g + s3.b;\n" +
+            "if (sigma2 < min_sigma2) {\n" +
+            "min_sigma2 = sigma2;\n" +
+            "gl_FragColor = vec4(m3, 1.0);\n" +
+            "}\n" +
+            "}\n";
+
+    private int mRadius;
+    private int mRadiusLocation;
+
+    public GPUImageKuwaharaFilter() {
+        this(3);
+    }
+
+    public GPUImageKuwaharaFilter(int radius) {
+        super(NO_FILTER_VERTEX_SHADER, KUWAHARA_FRAGMENT_SHADER);
+        mRadius = radius;
+    }
+
+    @Override
+    public void onInit() {
+        super.onInit();
+        mRadiusLocation = GLES20.glGetUniformLocation(getProgram(), "radius");
+    }
+
+    @Override
+    public void onInitialized() {
+        super.onInitialized();
+        setRadius(mRadius);
+    }
+
+    /**
+     * The radius to sample from when creating the brush-stroke effect, with a default of 3.
+     * The larger the radius, the slower the filter.
+     *
+     * @param radius default 3
+     */
+    public void setRadius(final int radius) {
+        mRadius = radius;
+        setInteger(mRadiusLocation, radius);
+    }
+}
diff --git a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageLaplacianFilter.java b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageLaplacianFilter.java
new file mode 100644
index 00000000..d320f64d
--- /dev/null
+++ b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageLaplacianFilter.java
@@ -0,0 +1,90 @@
+/*
+ * Copyright (C) 2012 CyberAgent
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package jp.co.cyberagent.android.gpuimage;
+
+import android.opengl.GLES20;
+
+public class GPUImageLaplacianFilter extends GPUImage3x3TextureSamplingFilter {
+    public static final String LAPLACIAN_FRAGMENT_SHADER = "" +
+            "precision highp float;\n" +
+            "\n" +
+            "uniform sampler2D inputImageTexture;\n" +
+            "\n" +
+            "uniform mediump mat3 convolutionMatrix;\n" +
+            "\n" +
+            "varying vec2 textureCoordinate;\n" +
+            "varying vec2 leftTextureCoordinate;\n" +
+            "varying vec2 rightTextureCoordinate;\n" +
+            "\n" +
+            "varying vec2 topTextureCoordinate;\n" +
+            "varying vec2 topLeftTextureCoordinate;\n" +
+            "varying vec2 topRightTextureCoordinate;\n" +
+            "\n" +
+            "varying vec2 bottomTextureCoordinate;\n" +
+            "varying vec2 bottomLeftTextureCoordinate;\n" +
+            "varying vec2 bottomRightTextureCoordinate;\n" +
+            "\n" +
+            "void main()\n" +
+            "{\n" +
+            "mediump vec3 bottomColor = texture2D(inputImageTexture, bottomTextureCoordinate).rgb;\n" +
+            "mediump vec3 bottomLeftColor = texture2D(inputImageTexture, bottomLeftTextureCoordinate).rgb;\n" +
+            "mediump vec3 bottomRightColor = texture2D(inputImageTexture, bottomRightTextureCoordinate).rgb;\n" +
+            "mediump vec4 centerColor = texture2D(inputImageTexture, textureCoordinate);\n" +
+            "mediump vec3 leftColor = texture2D(inputImageTexture, leftTextureCoordinate).rgb;\n" +
+            "mediump vec3 rightColor = texture2D(inputImageTexture, rightTextureCoordinate).rgb;\n" +
+            "mediump vec3 topColor = texture2D(inputImageTexture, topTextureCoordinate).rgb;\n" +
+            "mediump vec3 topRightColor = texture2D(inputImageTexture, topRightTextureCoordinate).rgb;\n" +
+            "mediump vec3 topLeftColor = texture2D(inputImageTexture, topLeftTextureCoordinate).rgb;\n" +
+            "\n" +
+            "mediump vec3 resultColor = topLeftColor * convolutionMatrix[0][0] + topColor * convolutionMatrix[0][1] + topRightColor * convolutionMatrix[0][2];\n" +
+            "resultColor += leftColor * convolutionMatrix[1][0] + centerColor.rgb * convolutionMatrix[1][1] + rightColor * convolutionMatrix[1][2];\n" +
+            "resultColor += bottomLeftColor * convolutionMatrix[2][0] + bottomColor * convolutionMatrix[2][1] + bottomRightColor * convolutionMatrix[2][2];\n" +
+            "\n" +
+            "// Normalize the results to allow for negative gradients in the 0.0-1.0 colorspace\n" +
+            "resultColor = resultColor + 0.5;\n" +
+            "\n" +
+            "gl_FragColor = vec4(resultColor, centerColor.a);\n" +
+            "}\n";
+
+    private float[] mConvolutionKernel;
+    private int mUniformConvolutionMatrix;
+
+    public GPUImageLaplacianFilter() {
+        this(new float[]{
+                0.5f, 1.0f, 0.5f,
+                1.0f, -6.0f, 1.0f,
+                0.5f, 1.0f, 0.5f
+        });
+    }
+
+    private GPUImageLaplacianFilter(final float[] convolutionKernel) {
+        super(LAPLACIAN_FRAGMENT_SHADER);
+        mConvolutionKernel = convolutionKernel;
+    }
+
+    @Override
+    public void onInit() {
+        super.onInit();
+        mUniformConvolutionMatrix = GLES20.glGetUniformLocation(getProgram(), "convolutionMatrix");
+        setConvolutionKernel(mConvolutionKernel);
+    }
+
+    private void setConvolutionKernel(final float[] convolutionKernel) {
+        mConvolutionKernel = convolutionKernel;
+        setUniformMatrix3f(mUniformConvolutionMatrix, mConvolutionKernel);
+    }
+}
diff --git a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageLevelsFilter.java b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageLevelsFilter.java
new file mode 100644
index 00000000..d7fbcfdf
--- /dev/null
+++ b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageLevelsFilter.java
@@ -0,0 +1,130 @@
+package jp.co.cyberagent.android.gpuimage;
+
+import android.opengl.GLES20;
+import android.util.Log;
+
+/**
+ * Created by vashisthg 30/05/14.
+ */
+public class GPUImageLevelsFilter extends GPUImageFilter{
+
+    private static final String LOGTAG = GPUImageLevelsFilter.class.getSimpleName();
+
+    public static final String LEVELS_FRAGMET_SHADER =
+
+            " varying highp vec2 textureCoordinate;\n" +
+            " \n" +
+            " uniform sampler2D inputImageTexture;\n" +
+            " uniform mediump vec3 levelMinimum;\n" +
+            " uniform mediump vec3 levelMiddle;\n" +
+            " uniform mediump vec3 levelMaximum;\n" +
+            " uniform mediump vec3 minOutput;\n" +
+            " uniform mediump vec3 maxOutput;\n" +
+            " \n" +
+            " void main()\n" +
+            " {\n" +
+            "     mediump vec4 textureColor = texture2D(inputImageTexture, textureCoordinate);\n" +
+            "     \n" +
+            "     gl_FragColor = vec4( mix(minOutput, maxOutput, pow(min(max(textureColor.rgb -levelMinimum, vec3(0.0)) / (levelMaximum - levelMinimum  ), vec3(1.0)), 1.0 /levelMiddle)) , textureColor.a);\n" +
+            " }\n";
+
+    private int mMinLocation;
+    private float[] mMin;
+    private int mMidLocation;
+    private float[] mMid;
+    private int mMaxLocation;
+    private float[] mMax;
+    private int mMinOutputLocation;
+    private float[] mMinOutput;
+    private int mMaxOutputLocation;
+    private float[] mMaxOutput;
+
+    public GPUImageLevelsFilter() {
+        this(new float[] {0.0f,0.0f,0.0f}, new float[] {1.0f, 1.0f, 1.0f }, new float[] {1.0f, 1.0f ,1.0f}, new float[] {0.0f, 0.0f, 0.0f}, new float[] {1.0f,1.0f,1.0f});
+    }
+
+    private GPUImageLevelsFilter(final float[] min, final float[] mid, final float[] max, final float[] minOUt, final float[] maxOut) {
+        super(NO_FILTER_VERTEX_SHADER, LEVELS_FRAGMET_SHADER);
+
+        mMin = min;
+        mMid = mid;
+        mMax = max;
+        mMinOutput = minOUt;
+        mMaxOutput = maxOut;
+        setMin(0.0f, 1.0f, 1.0f, 0.0f, 1.0f);
+    }
+
+    @Override
+    public void onInit() {
+        super.onInit();
+        mMinLocation = GLES20.glGetUniformLocation(getProgram(), "levelMinimum");
+        mMidLocation = GLES20.glGetUniformLocation(getProgram(), "levelMiddle");
+        mMaxLocation = GLES20.glGetUniformLocation(getProgram(), "levelMaximum");
+        mMinOutputLocation = GLES20.glGetUniformLocation(getProgram(), "minOutput");
+        mMaxOutputLocation = GLES20.glGetUniformLocation(getProgram(), "maxOutput");
+    }
+
+    @Override
+    public void onInitialized() {
+        super.onInitialized();
+        updateUniforms();
+    }
+
+
+    public void updateUniforms () {
+        setFloatVec3(mMinLocation, mMin);
+        setFloatVec3(mMidLocation, mMid);
+        setFloatVec3(mMaxLocation, mMax);
+        setFloatVec3(mMinOutputLocation, mMinOutput);
+        setFloatVec3(mMaxOutputLocation, mMaxOutput);
+    }
+
+    public void setMin(float min, float mid , float max ,float minOut , float maxOut) {
+        setRedMin(min, mid, max, minOut, maxOut);
+        setGreenMin(min, mid, max, minOut, maxOut);
+        setBlueMin(min, mid, max, minOut, maxOut);
+    }
+
+    public void setMin(float min, float mid , float max ) {
+        setMin(min, mid, max, 0.0f, 1.0f);
+    }
+
+    public void setRedMin(float min, float mid , float max ,float minOut , float maxOut) {
+        mMin[0] = min;
+        mMid[0] = mid;
+        mMax[0] = max;
+        mMinOutput[0] = minOut;
+        mMaxOutput[0] = maxOut;
+        updateUniforms();
+    }
+
+    public void setRedMin(float min, float mid , float max ){
+        setRedMin(min, mid, max, 0, 1);
+    }
+
+    public void setGreenMin(float min, float mid , float max ,float minOut , float maxOut) {
+        mMin[1] = min;
+        mMid[1] = mid;
+        mMax[1] = max;
+        mMinOutput[1] = minOut;
+        mMaxOutput[1] = maxOut;
+        updateUniforms();
+    }
+
+    public void setGreenMin(float min, float mid , float max ){
+        setGreenMin(min, mid, max, 0, 1);
+    }
+
+    public void setBlueMin(float min, float mid , float max ,float minOut , float maxOut) {
+        mMin[2] = min;
+        mMid[2] = mid;
+        mMax[2] = max;
+        mMinOutput[2] = minOut;
+        mMaxOutput[2] = maxOut;
+        updateUniforms();
+    }
+
+    public void setBlueMin(float min, float mid , float max ){
+        setBlueMin(min, mid, max, 0, 1);
+    }
+}
diff --git a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageLookupFilter.java b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageLookupFilter.java
index b9cfa2be..42c9ebdc 100644
--- a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageLookupFilter.java
+++ b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageLookupFilter.java
@@ -16,6 +16,8 @@
 
 package jp.co.cyberagent.android.gpuimage;
 
+import android.opengl.GLES20;
+
 public class GPUImageLookupFilter extends GPUImageTwoInputFilter {
 
     public static final String LOOKUP_FRAGMENT_SHADER = "varying highp vec2 textureCoordinate;\n" +
@@ -24,17 +26,19 @@
             " uniform sampler2D inputImageTexture;\n" +
             " uniform sampler2D inputImageTexture2; // lookup texture\n" +
             " \n" +
+            " uniform lowp float intensity;\n" +
+            " \n" +
             " void main()\n" +
             " {\n" +
-            "     lowp vec4 textureColor = texture2D(inputImageTexture, textureCoordinate);\n" +
+            "     highp vec4 textureColor = texture2D(inputImageTexture, textureCoordinate);\n" +
             "     \n" +
-            "     mediump float blueColor = textureColor.b * 63.0;\n" +
+            "     highp float blueColor = textureColor.b * 63.0;\n" +
             "     \n" +
-            "     mediump vec2 quad1;\n" +
+            "     highp vec2 quad1;\n" +
             "     quad1.y = floor(floor(blueColor) / 8.0);\n" +
             "     quad1.x = floor(blueColor) - (quad1.y * 8.0);\n" +
             "     \n" +
-            "     mediump vec2 quad2;\n" +
+            "     highp vec2 quad2;\n" +
             "     quad2.y = floor(ceil(blueColor) / 8.0);\n" +
             "     quad2.x = ceil(blueColor) - (quad2.y * 8.0);\n" +
             "     \n" +
@@ -50,11 +54,35 @@
             "     lowp vec4 newColor2 = texture2D(inputImageTexture2, texPos2);\n" +
             "     \n" +
             "     lowp vec4 newColor = mix(newColor1, newColor2, fract(blueColor));\n" +
-            "     gl_FragColor = vec4(newColor.rgb, textureColor.w);\n" +
+            "     gl_FragColor = mix(textureColor, vec4(newColor.rgb, textureColor.w), intensity);\n" +
             " }";
 
+    private int mIntensityLocation;
+    private float mIntensity;
 
     public GPUImageLookupFilter() {
+        this(1.0f);
+    }
+
+    public GPUImageLookupFilter(final float intensity) {
         super(LOOKUP_FRAGMENT_SHADER);
+        mIntensity = intensity;
+    }
+
+    @Override
+    public void onInit() {
+        super.onInit();
+        mIntensityLocation = GLES20.glGetUniformLocation(getProgram(), "intensity");
+    }
+
+    @Override
+    public void onInitialized() {
+        super.onInitialized();
+        setIntensity(mIntensity);
+    }
+
+    public void setIntensity(final float intensity) {
+        mIntensity = intensity;
+        setFloat(mIntensityLocation, mIntensity);
     }
 }
diff --git a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageNonMaximumSuppressionFilter.java b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageNonMaximumSuppressionFilter.java
new file mode 100644
index 00000000..a6f5af48
--- /dev/null
+++ b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageNonMaximumSuppressionFilter.java
@@ -0,0 +1,64 @@
+/*
+ * Copyright (C) 2012 CyberAgent
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package jp.co.cyberagent.android.gpuimage;
+
+public class GPUImageNonMaximumSuppressionFilter extends GPUImage3x3TextureSamplingFilter {
+    public static final String NMS_FRAGMENT_SHADER = "" +
+            "uniform sampler2D inputImageTexture;\n" +
+            "\n" +
+            "varying highp vec2 textureCoordinate;\n" +
+            "varying highp vec2 leftTextureCoordinate;\n" +
+            "varying highp vec2 rightTextureCoordinate;\n" +
+            "\n" +
+            "varying highp vec2 topTextureCoordinate;\n" +
+            "varying highp vec2 topLeftTextureCoordinate;\n" +
+            "varying highp vec2 topRightTextureCoordinate;\n" +
+            "\n" +
+            "varying highp vec2 bottomTextureCoordinate;\n" +
+            "varying highp vec2 bottomLeftTextureCoordinate;\n" +
+            "varying highp vec2 bottomRightTextureCoordinate;\n" +
+            "\n" +
+            "void main()\n" +
+            "{\n" +
+            "lowp float bottomColor = texture2D(inputImageTexture, bottomTextureCoordinate).r;\n" +
+            "lowp float bottomLeftColor = texture2D(inputImageTexture, bottomLeftTextureCoordinate).r;\n" +
+            "lowp float bottomRightColor = texture2D(inputImageTexture, bottomRightTextureCoordinate).r;\n" +
+            "lowp vec4 centerColor = texture2D(inputImageTexture, textureCoordinate);\n" +
+            "lowp float leftColor = texture2D(inputImageTexture, leftTextureCoordinate).r;\n" +
+            "lowp float rightColor = texture2D(inputImageTexture, rightTextureCoordinate).r;\n" +
+            "lowp float topColor = texture2D(inputImageTexture, topTextureCoordinate).r;\n" +
+            "lowp float topRightColor = texture2D(inputImageTexture, topRightTextureCoordinate).r;\n" +
+            "lowp float topLeftColor = texture2D(inputImageTexture, topLeftTextureCoordinate).r;\n" +
+            "\n" +
+            "// Use a tiebreaker for pixels to the left and immediately above this one\n" +
+            "lowp float multiplier = 1.0 - step(centerColor.r, topColor);\n" +
+            "multiplier = multiplier * 1.0 - step(centerColor.r, topLeftColor);\n" +
+            "multiplier = multiplier * 1.0 - step(centerColor.r, leftColor);\n" +
+            "multiplier = multiplier * 1.0 - step(centerColor.r, bottomLeftColor);\n" +
+            "\n" +
+            "lowp float maxValue = max(centerColor.r, bottomColor);\n" +
+            "maxValue = max(maxValue, bottomRightColor);\n" +
+            "maxValue = max(maxValue, rightColor);\n" +
+            "maxValue = max(maxValue, topRightColor);\n" +
+            "\n" +
+            "gl_FragColor = vec4((centerColor.rgb * step(maxValue, centerColor.r) * multiplier), 1.0);\n" +
+            "}\n";
+
+    public GPUImageNonMaximumSuppressionFilter() {
+        super(NMS_FRAGMENT_SHADER);
+    }
+}
diff --git a/library/src/jp/co/cyberagent/android/gpuimage/GPUImagePosterizeFilter.java b/library/src/jp/co/cyberagent/android/gpuimage/GPUImagePosterizeFilter.java
index 0ce09fa2..3b7c8ff7 100644
--- a/library/src/jp/co/cyberagent/android/gpuimage/GPUImagePosterizeFilter.java
+++ b/library/src/jp/co/cyberagent/android/gpuimage/GPUImagePosterizeFilter.java
@@ -19,8 +19,8 @@
 import android.opengl.GLES20;
 
 /**
- * Reduces the color range of the image. <br/>
- * <br/>
+ * Reduces the color range of the image. <br>
+ * <br>
  * colorLevels: ranges from 1 to 256, with a default of 10
  */
 public class GPUImagePosterizeFilter extends GPUImageFilter {
diff --git a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageRGBDilationFilter.java b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageRGBDilationFilter.java
new file mode 100644
index 00000000..2d5e28c7
--- /dev/null
+++ b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageRGBDilationFilter.java
@@ -0,0 +1,301 @@
+/*
+ * Copyright (C) 2012 CyberAgent
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package jp.co.cyberagent.android.gpuimage;
+
+/**
+ * For each pixel, this sets it to the maximum value of each color channel in a rectangular neighborhood extending
+ * out dilationRadius pixels from the center.
+ * This extends out brighter colors, and can be used for abstraction of color images.
+ */
+public class GPUImageRGBDilationFilter extends GPUImageTwoPassTextureSamplingFilter {
+    public static final String VERTEX_SHADER_1 =
+            "attribute vec4 position;\n" +
+                    "attribute vec2 inputTextureCoordinate;\n" +
+                    "\n" +
+                    "uniform float texelWidthOffset; \n" +
+                    "uniform float texelHeightOffset; \n" +
+                    "\n" +
+                    "varying vec2 centerTextureCoordinate;\n" +
+                    "varying vec2 oneStepPositiveTextureCoordinate;\n" +
+                    "varying vec2 oneStepNegativeTextureCoordinate;\n" +
+                    "\n" +
+                    "void main()\n" +
+                    "{\n" +
+                    "gl_Position = position;\n" +
+                    "\n" +
+                    "vec2 offset = vec2(texelWidthOffset, texelHeightOffset);\n" +
+                    "\n" +
+                    "centerTextureCoordinate = inputTextureCoordinate;\n" +
+                    "oneStepNegativeTextureCoordinate = inputTextureCoordinate - offset;\n" +
+                    "oneStepPositiveTextureCoordinate = inputTextureCoordinate + offset;\n" +
+                    "}\n";
+
+    public static final String VERTEX_SHADER_2 =
+            "attribute vec4 position;\n" +
+                    "attribute vec2 inputTextureCoordinate;\n" +
+                    "\n" +
+                    "uniform float texelWidthOffset;\n" +
+                    "uniform float texelHeightOffset;\n" +
+                    "\n" +
+                    "varying vec2 centerTextureCoordinate;\n" +
+                    "varying vec2 oneStepPositiveTextureCoordinate;\n" +
+                    "varying vec2 oneStepNegativeTextureCoordinate;\n" +
+                    "varying vec2 twoStepsPositiveTextureCoordinate;\n" +
+                    "varying vec2 twoStepsNegativeTextureCoordinate;\n" +
+                    "\n" +
+                    "void main()\n" +
+                    "{\n" +
+                    "gl_Position = position;\n" +
+                    "\n" +
+                    "vec2 offset = vec2(texelWidthOffset, texelHeightOffset);\n" +
+                    "\n" +
+                    "centerTextureCoordinate = inputTextureCoordinate;\n" +
+                    "oneStepNegativeTextureCoordinate = inputTextureCoordinate - offset;\n" +
+                    "oneStepPositiveTextureCoordinate = inputTextureCoordinate + offset;\n" +
+                    "twoStepsNegativeTextureCoordinate = inputTextureCoordinate - (offset * 2.0);\n" +
+                    "twoStepsPositiveTextureCoordinate = inputTextureCoordinate + (offset * 2.0);\n" +
+                    "}\n";
+
+    public static final String VERTEX_SHADER_3 =
+            "attribute vec4 position;\n" +
+                    "attribute vec2 inputTextureCoordinate;\n" +
+                    "\n" +
+                    "uniform float texelWidthOffset;\n" +
+                    "uniform float texelHeightOffset;\n" +
+                    "\n" +
+                    "varying vec2 centerTextureCoordinate;\n" +
+                    "varying vec2 oneStepPositiveTextureCoordinate;\n" +
+                    "varying vec2 oneStepNegativeTextureCoordinate;\n" +
+                    "varying vec2 twoStepsPositiveTextureCoordinate;\n" +
+                    "varying vec2 twoStepsNegativeTextureCoordinate;\n" +
+                    "varying vec2 threeStepsPositiveTextureCoordinate;\n" +
+                    "varying vec2 threeStepsNegativeTextureCoordinate;\n" +
+                    "\n" +
+                    "void main()\n" +
+                    "{\n" +
+                    "gl_Position = position;\n" +
+                    "\n" +
+                    "vec2 offset = vec2(texelWidthOffset, texelHeightOffset);\n" +
+                    "\n" +
+                    "centerTextureCoordinate = inputTextureCoordinate;\n" +
+                    "oneStepNegativeTextureCoordinate = inputTextureCoordinate - offset;\n" +
+                    "oneStepPositiveTextureCoordinate = inputTextureCoordinate + offset;\n" +
+                    "twoStepsNegativeTextureCoordinate = inputTextureCoordinate - (offset * 2.0);\n" +
+                    "twoStepsPositiveTextureCoordinate = inputTextureCoordinate + (offset * 2.0);\n" +
+                    "threeStepsNegativeTextureCoordinate = inputTextureCoordinate - (offset * 3.0);\n" +
+                    "threeStepsPositiveTextureCoordinate = inputTextureCoordinate + (offset * 3.0);\n" +
+                    "}\n";
+
+    public static final String VERTEX_SHADER_4 =
+            "attribute vec4 position;\n" +
+                    "attribute vec2 inputTextureCoordinate;\n" +
+                    "\n" +
+                    "uniform float texelWidthOffset;\n" +
+                    "uniform float texelHeightOffset;\n" +
+                    "\n" +
+                    "varying vec2 centerTextureCoordinate;\n" +
+                    "varying vec2 oneStepPositiveTextureCoordinate;\n" +
+                    "varying vec2 oneStepNegativeTextureCoordinate;\n" +
+                    "varying vec2 twoStepsPositiveTextureCoordinate;\n" +
+                    "varying vec2 twoStepsNegativeTextureCoordinate;\n" +
+                    "varying vec2 threeStepsPositiveTextureCoordinate;\n" +
+                    "varying vec2 threeStepsNegativeTextureCoordinate;\n" +
+                    "varying vec2 fourStepsPositiveTextureCoordinate;\n" +
+                    "varying vec2 fourStepsNegativeTextureCoordinate;\n" +
+                    "\n" +
+                    "void main()\n" +
+                    "{\n" +
+                    "gl_Position = position;\n" +
+                    "\n" +
+                    "vec2 offset = vec2(texelWidthOffset, texelHeightOffset);\n" +
+                    "\n" +
+                    "centerTextureCoordinate = inputTextureCoordinate;\n" +
+                    "oneStepNegativeTextureCoordinate = inputTextureCoordinate - offset;\n" +
+                    "oneStepPositiveTextureCoordinate = inputTextureCoordinate + offset;\n" +
+                    "twoStepsNegativeTextureCoordinate = inputTextureCoordinate - (offset * 2.0);\n" +
+                    "twoStepsPositiveTextureCoordinate = inputTextureCoordinate + (offset * 2.0);\n" +
+                    "threeStepsNegativeTextureCoordinate = inputTextureCoordinate - (offset * 3.0);\n" +
+                    "threeStepsPositiveTextureCoordinate = inputTextureCoordinate + (offset * 3.0);\n" +
+                    "fourStepsNegativeTextureCoordinate = inputTextureCoordinate - (offset * 4.0);\n" +
+                    "fourStepsPositiveTextureCoordinate = inputTextureCoordinate + (offset * 4.0);\n" +
+                    "}\n";
+
+
+    public static final String FRAGMENT_SHADER_1 =
+            "precision highp float;\n" +
+                    "\n" +
+                    "varying vec2 centerTextureCoordinate;\n" +
+                    "varying vec2 oneStepPositiveTextureCoordinate;\n" +
+                    "varying vec2 oneStepNegativeTextureCoordinate;\n" +
+                    "\n" +
+                    "uniform sampler2D inputImageTexture;\n" +
+                    "\n" +
+                    "void main()\n" +
+                    "{\n" +
+                    "lowp vec4 centerIntensity = texture2D(inputImageTexture, centerTextureCoordinate);\n" +
+                    "lowp vec4 oneStepPositiveIntensity = texture2D(inputImageTexture, oneStepPositiveTextureCoordinate);\n" +
+                    "lowp vec4 oneStepNegativeIntensity = texture2D(inputImageTexture, oneStepNegativeTextureCoordinate);\n" +
+                    "\n" +
+                    "lowp vec4 maxValue = max(centerIntensity, oneStepPositiveIntensity);\n" +
+                    "\n" +
+                    "gl_FragColor = max(maxValue, oneStepNegativeIntensity);\n" +
+                    "}\n";
+
+    public static final String FRAGMENT_SHADER_2 =
+            "precision highp float;\n" +
+                    "\n" +
+                    "varying vec2 centerTextureCoordinate;\n" +
+                    "varying vec2 oneStepPositiveTextureCoordinate;\n" +
+                    "varying vec2 oneStepNegativeTextureCoordinate;\n" +
+                    "varying vec2 twoStepsPositiveTextureCoordinate;\n" +
+                    "varying vec2 twoStepsNegativeTextureCoordinate;\n" +
+                    "\n" +
+                    "uniform sampler2D inputImageTexture;\n" +
+                    "\n" +
+                    "void main()\n" +
+                    "{\n" +
+                    "lowp vec4 centerIntensity = texture2D(inputImageTexture, centerTextureCoordinate);\n" +
+                    "lowp vec4 oneStepPositiveIntensity = texture2D(inputImageTexture, oneStepPositiveTextureCoordinate);\n" +
+                    "lowp vec4 oneStepNegativeIntensity = texture2D(inputImageTexture, oneStepNegativeTextureCoordinate);\n" +
+                    "lowp vec4 twoStepsPositiveIntensity = texture2D(inputImageTexture, twoStepsPositiveTextureCoordinate);\n" +
+                    "lowp vec4 twoStepsNegativeIntensity = texture2D(inputImageTexture, twoStepsNegativeTextureCoordinate);\n" +
+                    "\n" +
+                    "lowp vec4 maxValue = max(centerIntensity, oneStepPositiveIntensity);\n" +
+                    "maxValue = max(maxValue, oneStepNegativeIntensity);\n" +
+                    "maxValue = max(maxValue, twoStepsPositiveIntensity);\n" +
+                    "maxValue = max(maxValue, twoStepsNegativeIntensity);\n" +
+                    "\n" +
+                    "gl_FragColor = max(maxValue, twoStepsNegativeIntensity);\n" +
+                    "}\n";
+
+    public static final String FRAGMENT_SHADER_3 =
+            "precision highp float;\n" +
+                    "\n" +
+                    "varying vec2 centerTextureCoordinate;\n" +
+                    "varying vec2 oneStepPositiveTextureCoordinate;\n" +
+                    "varying vec2 oneStepNegativeTextureCoordinate;\n" +
+                    "varying vec2 twoStepsPositiveTextureCoordinate;\n" +
+                    "varying vec2 twoStepsNegativeTextureCoordinate;\n" +
+                    "varying vec2 threeStepsPositiveTextureCoordinate;\n" +
+                    "varying vec2 threeStepsNegativeTextureCoordinate;\n" +
+                    "\n" +
+                    "uniform sampler2D inputImageTexture;\n" +
+                    "\n" +
+                    "void main()\n" +
+                    "{\n" +
+                    "lowp vec4 centerIntensity = texture2D(inputImageTexture, centerTextureCoordinate);\n" +
+                    "lowp vec4 oneStepPositiveIntensity = texture2D(inputImageTexture, oneStepPositiveTextureCoordinate);\n" +
+                    "lowp vec4 oneStepNegativeIntensity = texture2D(inputImageTexture, oneStepNegativeTextureCoordinate);\n" +
+                    "lowp vec4 twoStepsPositiveIntensity = texture2D(inputImageTexture, twoStepsPositiveTextureCoordinate);\n" +
+                    "lowp vec4 twoStepsNegativeIntensity = texture2D(inputImageTexture, twoStepsNegativeTextureCoordinate);\n" +
+                    "lowp vec4 threeStepsPositiveIntensity = texture2D(inputImageTexture, threeStepsPositiveTextureCoordinate);\n" +
+                    "lowp vec4 threeStepsNegativeIntensity = texture2D(inputImageTexture, threeStepsNegativeTextureCoordinate);\n" +
+                    "\n" +
+                    "lowp vec4 maxValue = max(centerIntensity, oneStepPositiveIntensity);\n" +
+                    "maxValue = max(maxValue, oneStepNegativeIntensity);\n" +
+                    "maxValue = max(maxValue, twoStepsPositiveIntensity);\n" +
+                    "maxValue = max(maxValue, twoStepsNegativeIntensity);\n" +
+                    "maxValue = max(maxValue, threeStepsPositiveIntensity);\n" +
+                    "\n" +
+                    "gl_FragColor = max(maxValue, threeStepsNegativeIntensity);\n" +
+                    "}\n";
+
+    public static final String FRAGMENT_SHADER_4 =
+            "precision highp float;\n" +
+                    "\n" +
+                    "varying vec2 centerTextureCoordinate;\n" +
+                    "varying vec2 oneStepPositiveTextureCoordinate;\n" +
+                    "varying vec2 oneStepNegativeTextureCoordinate;\n" +
+                    "varying vec2 twoStepsPositiveTextureCoordinate;\n" +
+                    "varying vec2 twoStepsNegativeTextureCoordinate;\n" +
+                    "varying vec2 threeStepsPositiveTextureCoordinate;\n" +
+                    "varying vec2 threeStepsNegativeTextureCoordinate;\n" +
+                    "varying vec2 fourStepsPositiveTextureCoordinate;\n" +
+                    "varying vec2 fourStepsNegativeTextureCoordinate;\n" +
+                    "\n" +
+                    "uniform sampler2D inputImageTexture;\n" +
+                    "\n" +
+                    "void main()\n" +
+                    "{\n" +
+                    "lowp vec4 centerIntensity = texture2D(inputImageTexture, centerTextureCoordinate);\n" +
+                    "lowp vec4 oneStepPositiveIntensity = texture2D(inputImageTexture, oneStepPositiveTextureCoordinate);\n" +
+                    "lowp vec4 oneStepNegativeIntensity = texture2D(inputImageTexture, oneStepNegativeTextureCoordinate);\n" +
+                    "lowp vec4 twoStepsPositiveIntensity = texture2D(inputImageTexture, twoStepsPositiveTextureCoordinate);\n" +
+                    "lowp vec4 twoStepsNegativeIntensity = texture2D(inputImageTexture, twoStepsNegativeTextureCoordinate);\n" +
+                    "lowp vec4 threeStepsPositiveIntensity = texture2D(inputImageTexture, threeStepsPositiveTextureCoordinate);\n" +
+                    "lowp vec4 threeStepsNegativeIntensity = texture2D(inputImageTexture, threeStepsNegativeTextureCoordinate);\n" +
+                    "lowp vec4 fourStepsPositiveIntensity = texture2D(inputImageTexture, fourStepsPositiveTextureCoordinate);\n" +
+                    "lowp vec4 fourStepsNegativeIntensity = texture2D(inputImageTexture, fourStepsNegativeTextureCoordinate);\n" +
+                    "\n" +
+                    "lowp vec4 maxValue = max(centerIntensity, oneStepPositiveIntensity);\n" +
+                    "maxValue = max(maxValue, oneStepNegativeIntensity);\n" +
+                    "maxValue = max(maxValue, twoStepsPositiveIntensity);\n" +
+                    "maxValue = max(maxValue, twoStepsNegativeIntensity);\n" +
+                    "maxValue = max(maxValue, threeStepsPositiveIntensity);\n" +
+                    "maxValue = max(maxValue, threeStepsNegativeIntensity);\n" +
+                    "maxValue = max(maxValue, fourStepsPositiveIntensity);\n" +
+                    "\n" +
+                    "gl_FragColor = max(maxValue, fourStepsNegativeIntensity);\n" +
+                    "}\n";
+
+
+    public GPUImageRGBDilationFilter() {
+        this(1);
+    }
+
+    /**
+     * Acceptable values for dilationRadius, which sets the distance in pixels to sample out
+     * from the center, are 1, 2, 3, and 4.
+     *
+     * @param radius 1, 2, 3 or 4
+     */
+    public GPUImageRGBDilationFilter(int radius) {
+        this(getVertexShader(radius), getFragmentShader(radius));
+    }
+
+    private GPUImageRGBDilationFilter(String vertexShader, String fragmentShader) {
+        super(vertexShader, fragmentShader, vertexShader, fragmentShader);
+    }
+
+    private static String getVertexShader(int radius) {
+        switch (radius) {
+            case 0:
+            case 1:
+                return VERTEX_SHADER_1;
+            case 2:
+                return VERTEX_SHADER_2;
+            case 3:
+                return VERTEX_SHADER_3;
+            default:
+                return VERTEX_SHADER_4;
+        }
+    }
+
+    private static String getFragmentShader(int radius) {
+        switch (radius) {
+            case 0:
+            case 1:
+                return FRAGMENT_SHADER_1;
+            case 2:
+                return FRAGMENT_SHADER_2;
+            case 3:
+                return FRAGMENT_SHADER_3;
+            default:
+                return FRAGMENT_SHADER_4;
+        }
+    }
+}
diff --git a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageRenderer.java b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageRenderer.java
index ac2e7c97..691550bd 100644
--- a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageRenderer.java
+++ b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageRenderer.java
@@ -25,6 +25,7 @@
 import android.hardware.Camera.Size;
 import android.opengl.GLES20;
 import android.opengl.GLSurfaceView.Renderer;
+
 import jp.co.cyberagent.android.gpuimage.util.TextureRotationUtil;
 
 import javax.microedition.khronos.egl.EGLConfig;
@@ -66,14 +67,20 @@
     private int mAddedPadding;
 
     private final Queue<Runnable> mRunOnDraw;
+    private final Queue<Runnable> mRunOnDrawEnd;
     private Rotation mRotation;
     private boolean mFlipHorizontal;
     private boolean mFlipVertical;
     private GPUImage.ScaleType mScaleType = GPUImage.ScaleType.CENTER_CROP;
 
+    private float mBackgroundRed = 0;
+    private float mBackgroundGreen = 0;
+    private float mBackgroundBlue = 0;
+
     public GPUImageRenderer(final GPUImageFilter filter) {
         mFilter = filter;
         mRunOnDraw = new LinkedList<Runnable>();
+        mRunOnDrawEnd = new LinkedList<Runnable>();
 
         mGLCubeBuffer = ByteBuffer.allocateDirect(CUBE.length * 4)
                 .order(ByteOrder.nativeOrder())
@@ -88,7 +95,7 @@ public GPUImageRenderer(final GPUImageFilter filter) {
 
     @Override
     public void onSurfaceCreated(final GL10 unused, final EGLConfig config) {
-        GLES20.glClearColor(0, 0, 0, 1);
+        GLES20.glClearColor(mBackgroundRed, mBackgroundGreen, mBackgroundBlue, 1);
         GLES20.glDisable(GLES20.GL_DEPTH_TEST);
         mFilter.init();
     }
@@ -100,6 +107,7 @@ public void onSurfaceChanged(final GL10 gl, final int width, final int height) {
         GLES20.glViewport(0, 0, width, height);
         GLES20.glUseProgram(mFilter.getProgram());
         mFilter.onOutputSizeChanged(width, height);
+        adjustImageScaling();
         synchronized (mSurfaceChangedWaiter) {
             mSurfaceChangedWaiter.notifyAll();
         }
@@ -108,17 +116,35 @@ public void onSurfaceChanged(final GL10 gl, final int width, final int height) {
     @Override
     public void onDrawFrame(final GL10 gl) {
         GLES20.glClear(GLES20.GL_COLOR_BUFFER_BIT | GLES20.GL_DEPTH_BUFFER_BIT);
-        synchronized (mRunOnDraw) {
-            while (!mRunOnDraw.isEmpty()) {
-                mRunOnDraw.poll().run();
-            }
-        }
+        runAll(mRunOnDraw);
         mFilter.onDraw(mGLTextureId, mGLCubeBuffer, mGLTextureBuffer);
+        runAll(mRunOnDrawEnd);
         if (mSurfaceTexture != null) {
             mSurfaceTexture.updateTexImage();
         }
     }
 
+    /**
+     * Sets the background color
+     *
+     * @param red red color value
+     * @param green green color value
+     * @param blue red color value
+     */
+    public void setBackgroundColor(float red, float green, float blue) {
+        mBackgroundRed = red;
+        mBackgroundGreen = green;
+        mBackgroundBlue = blue;
+    }
+
+    private void runAll(Queue<Runnable> queue) {
+        synchronized (queue) {
+            while (!queue.isEmpty()) {
+                queue.poll().run();
+            }
+        }
+    }
+
     @Override
     public void onPreviewFrame(final byte[] data, final Camera camera) {
         final Size previewSize = camera.getParameters().getPreviewSize();
@@ -251,35 +277,30 @@ private void adjustImageScaling() {
 
         float ratio1 = outputWidth / mImageWidth;
         float ratio2 = outputHeight / mImageHeight;
-        float ratioMin = Math.min(ratio1, ratio2);
-        mImageWidth = Math.round(mImageWidth * ratioMin);
-        mImageHeight = Math.round(mImageHeight * ratioMin);
-
-        float ratioWidth = 1.0f;
-        float ratioHeight = 1.0f;
-        if (mImageWidth != outputWidth) {
-            ratioWidth = mImageWidth / outputWidth;
-        } else if (mImageHeight != outputHeight) {
-            ratioHeight = mImageHeight / outputHeight;
-        }
+        float ratioMax = Math.max(ratio1, ratio2);
+        int imageWidthNew = Math.round(mImageWidth * ratioMax);
+        int imageHeightNew = Math.round(mImageHeight * ratioMax);
+
+        float ratioWidth = imageWidthNew / outputWidth;
+        float ratioHeight = imageHeightNew / outputHeight;
 
         float[] cube = CUBE;
         float[] textureCords = TextureRotationUtil.getRotation(mRotation, mFlipHorizontal, mFlipVertical);
         if (mScaleType == GPUImage.ScaleType.CENTER_CROP) {
-            float distHorizontal = (1 / ratioWidth - 1) / 2;
-            float distVertical = (1 / ratioHeight - 1) / 2;
+            float distHorizontal = (1 - 1 / ratioWidth) / 2;
+            float distVertical = (1 - 1 / ratioHeight) / 2;
             textureCords = new float[]{
-                    addDistance(textureCords[0], distVertical), addDistance(textureCords[1], distHorizontal),
-                    addDistance(textureCords[2], distVertical), addDistance(textureCords[3], distHorizontal),
-                    addDistance(textureCords[4], distVertical), addDistance(textureCords[5], distHorizontal),
-                    addDistance(textureCords[6], distVertical), addDistance(textureCords[7], distHorizontal),
+                    addDistance(textureCords[0], distHorizontal), addDistance(textureCords[1], distVertical),
+                    addDistance(textureCords[2], distHorizontal), addDistance(textureCords[3], distVertical),
+                    addDistance(textureCords[4], distHorizontal), addDistance(textureCords[5], distVertical),
+                    addDistance(textureCords[6], distHorizontal), addDistance(textureCords[7], distVertical),
             };
         } else {
             cube = new float[]{
-                    CUBE[0] * ratioWidth, CUBE[1] * ratioHeight,
-                    CUBE[2] * ratioWidth, CUBE[3] * ratioHeight,
-                    CUBE[4] * ratioWidth, CUBE[5] * ratioHeight,
-                    CUBE[6] * ratioWidth, CUBE[7] * ratioHeight,
+                    CUBE[0] / ratioHeight, CUBE[1] / ratioWidth,
+                    CUBE[2] / ratioHeight, CUBE[3] / ratioWidth,
+                    CUBE[4] / ratioHeight, CUBE[5] / ratioWidth,
+                    CUBE[6] / ratioHeight, CUBE[7] / ratioWidth,
             };
         }
 
@@ -298,12 +319,16 @@ public void setRotationCamera(final Rotation rotation, final boolean flipHorizon
         setRotation(rotation, flipVertical, flipHorizontal);
     }
 
-    public void setRotation(final Rotation rotation, final boolean flipHorizontal,
-            final boolean flipVertical) {
+    public void setRotation(final Rotation rotation) {
         mRotation = rotation;
+        adjustImageScaling();
+    }
+
+    public void setRotation(final Rotation rotation,
+                            final boolean flipHorizontal, final boolean flipVertical) {
         mFlipHorizontal = flipHorizontal;
         mFlipVertical = flipVertical;
-        adjustImageScaling();
+        setRotation(rotation);
     }
 
     public Rotation getRotation() {
@@ -323,4 +348,10 @@ protected void runOnDraw(final Runnable runnable) {
             mRunOnDraw.add(runnable);
         }
     }
+
+    protected void runOnDrawEnd(final Runnable runnable) {
+        synchronized (mRunOnDrawEnd) {
+            mRunOnDrawEnd.add(runnable);
+        }
+    }
 }
diff --git a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageSharpenFilter.java b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageSharpenFilter.java
index 48e340e0..4317b66c 100644
--- a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageSharpenFilter.java
+++ b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageSharpenFilter.java
@@ -19,8 +19,8 @@
 import android.opengl.GLES20;
 
 /**
- * Sharpens the picture. <br />
- * <br />
+ * Sharpens the picture. <br>
+ * <br>
  * sharpness: from -4.0 to 4.0, with 0.0 as the normal level
  */
 public class GPUImageSharpenFilter extends GPUImageFilter {
diff --git a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageSketchFilter.java b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageSketchFilter.java
new file mode 100644
index 00000000..dd78e708
--- /dev/null
+++ b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageSketchFilter.java
@@ -0,0 +1,67 @@
+/*
+ * Copyright (C) 2012 CyberAgent
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package jp.co.cyberagent.android.gpuimage;
+
+import java.util.ArrayList;
+import java.util.List;
+
+/**
+ * Converts video to look like a sketch.
+ * This is just the Sobel edge detection filter with the colors inverted.
+ */
+public class GPUImageSketchFilter extends GPUImageFilterGroup {
+    public static final String SKETCH_FRAGMENT_SHADER = "" +
+            "precision mediump float;\n" +
+            "\n" +
+            "varying vec2 textureCoordinate;\n" +
+            "varying vec2 leftTextureCoordinate;\n" +
+            "varying vec2 rightTextureCoordinate;\n" +
+            "\n" +
+            "varying vec2 topTextureCoordinate;\n" +
+            "varying vec2 topLeftTextureCoordinate;\n" +
+            "varying vec2 topRightTextureCoordinate;\n" +
+            "\n" +
+            "varying vec2 bottomTextureCoordinate;\n" +
+            "varying vec2 bottomLeftTextureCoordinate;\n" +
+            "varying vec2 bottomRightTextureCoordinate;\n" +
+            "\n" +
+            "uniform sampler2D inputImageTexture;\n" +
+            "\n" +
+            "void main()\n" +
+            "{\n" +
+            "float bottomLeftIntensity = texture2D(inputImageTexture, bottomLeftTextureCoordinate).r;\n" +
+            "float topRightIntensity = texture2D(inputImageTexture, topRightTextureCoordinate).r;\n" +
+            "float topLeftIntensity = texture2D(inputImageTexture, topLeftTextureCoordinate).r;\n" +
+            "float bottomRightIntensity = texture2D(inputImageTexture, bottomRightTextureCoordinate).r;\n" +
+            "float leftIntensity = texture2D(inputImageTexture, leftTextureCoordinate).r;\n" +
+            "float rightIntensity = texture2D(inputImageTexture, rightTextureCoordinate).r;\n" +
+            "float bottomIntensity = texture2D(inputImageTexture, bottomTextureCoordinate).r;\n" +
+            "float topIntensity = texture2D(inputImageTexture, topTextureCoordinate).r;\n" +
+            "float h = -topLeftIntensity - 2.0 * topIntensity - topRightIntensity + bottomLeftIntensity + 2.0 * bottomIntensity + bottomRightIntensity;\n" +
+            "float v = -bottomLeftIntensity - 2.0 * leftIntensity - topLeftIntensity + bottomRightIntensity + 2.0 * rightIntensity + topRightIntensity;\n" +
+            "\n" +
+            "float mag = 1.0 - length(vec2(h, v));\n" +
+            "\n" +
+            "gl_FragColor = vec4(vec3(mag), 1.0);\n" +
+            "}\n";
+
+    public GPUImageSketchFilter() {
+        super();
+        addFilter(new GPUImageGrayscaleFilter());
+        addFilter(new GPUImage3x3TextureSamplingFilter(SKETCH_FRAGMENT_SHADER));
+    }
+}
diff --git a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageSmoothToonFilter.java b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageSmoothToonFilter.java
new file mode 100644
index 00000000..a569ce97
--- /dev/null
+++ b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageSmoothToonFilter.java
@@ -0,0 +1,71 @@
+/*
+ * Copyright (C) 2012 CyberAgent
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package jp.co.cyberagent.android.gpuimage;
+
+import android.opengl.GLES20;
+
+/**
+ *  This uses a similar process as the GPUImageToonFilter, only it precedes the toon effect
+ *  with a Gaussian blur to smooth out noise.
+ */
+public class GPUImageSmoothToonFilter extends GPUImageFilterGroup {
+    GPUImageGaussianBlurFilter blurFilter;
+    GPUImageToonFilter toonFilter;
+
+    /**
+     * Setup and Tear down
+     */
+    public GPUImageSmoothToonFilter() {
+        // First pass: apply a variable Gaussian blur
+        blurFilter = new GPUImageGaussianBlurFilter();
+        addFilter(blurFilter);
+
+        // Second pass: run the Sobel edge detection on this blurred image, along with a posterization effect
+        toonFilter = new GPUImageToonFilter();
+        addFilter(toonFilter);
+
+        getFilters().add(blurFilter);
+
+        setBlurSize(0.5f);
+        setThreshold(0.2f);
+        setQuantizationLevels(10.0f);
+    }
+
+    /**
+     * Accessors
+     */
+    public void setTexelWidth(float value) {
+        toonFilter.setTexelWidth(value);
+    }
+
+    public void setTexelHeight(float value) {
+        toonFilter.setTexelHeight(value);
+    }
+
+    public void setBlurSize(float value) {
+        blurFilter.setBlurSize(value);
+    }
+
+    public void setThreshold(float value) {
+        toonFilter.setThreshold(value);
+    }
+
+    public void setQuantizationLevels(float value) {
+        toonFilter.setQuantizationLevels(value);
+    }
+
+}
diff --git a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageSobelEdgeDetection.java b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageSobelEdgeDetection.java
index 3381d11e..2a775d48 100644
--- a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageSobelEdgeDetection.java
+++ b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageSobelEdgeDetection.java
@@ -23,7 +23,6 @@
  * Applies sobel edge detection on the image.
  */
 public class GPUImageSobelEdgeDetection extends GPUImageFilterGroup {
-
     public static final String SOBEL_EDGE_DETECTION = "" +
             "precision mediump float;\n" + 
             "\n" + 
@@ -60,14 +59,9 @@
             "}";
 
     public GPUImageSobelEdgeDetection() {
-        super(createFilters());
-    }
-
-    private static List<GPUImageFilter> createFilters() {
-        List<GPUImageFilter> filters = new ArrayList<GPUImageFilter>(2);
-        filters.add(new GPUImageGrayscaleFilter());
-        filters.add(new GPUImage3x3TextureSamplingFilter(SOBEL_EDGE_DETECTION));
-        return filters;
+        super();
+        addFilter(new GPUImageGrayscaleFilter());
+        addFilter(new GPUImage3x3TextureSamplingFilter(SOBEL_EDGE_DETECTION));
     }
 
     public void setLineSize(final float size) {
diff --git a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageSobelThresholdFilter.java b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageSobelThresholdFilter.java
new file mode 100644
index 00000000..f1dcf64e
--- /dev/null
+++ b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageSobelThresholdFilter.java
@@ -0,0 +1,74 @@
+package jp.co.cyberagent.android.gpuimage;
+
+import android.opengl.GLES20;
+
+public class GPUImageSobelThresholdFilter extends
+		GPUImage3x3TextureSamplingFilter {
+    public static final String SOBEL_THRESHOLD_EDGE_DETECTION = "" +
+    		"precision mediump float;\n" +
+    		"\n" +
+    		"varying vec2 textureCoordinate;\n" +
+    		"varying vec2 leftTextureCoordinate;\n" +
+    		"varying vec2 rightTextureCoordinate;\n" +
+    		"\n" +
+    		"varying vec2 topTextureCoordinate;\n" +
+    		"varying vec2 topLeftTextureCoordinate;\n" +
+    		"varying vec2 topRightTextureCoordinate;\n" +
+    		"\n" +
+    		"varying vec2 bottomTextureCoordinate;\n" +
+    		"varying vec2 bottomLeftTextureCoordinate;\n" +
+    		"varying vec2 bottomRightTextureCoordinate;\n" +
+    		"\n" +
+    		"uniform sampler2D inputImageTexture;\n" +
+    		"uniform lowp float threshold;\n" +
+    		"\n" +
+    		"const highp vec3 W = vec3(0.2125, 0.7154, 0.0721);\n" +
+    		"\n" +
+    		"void main()\n" +
+    		"{\n" +
+    		"    float bottomLeftIntensity = texture2D(inputImageTexture, bottomLeftTextureCoordinate).r;\n" +
+    		"    float topRightIntensity = texture2D(inputImageTexture, topRightTextureCoordinate).r;\n" +
+    		"    float topLeftIntensity = texture2D(inputImageTexture, topLeftTextureCoordinate).r;\n" +
+    		"    float bottomRightIntensity = texture2D(inputImageTexture, bottomRightTextureCoordinate).r;\n" +
+    		"    float leftIntensity = texture2D(inputImageTexture, leftTextureCoordinate).r;\n" +
+    		"    float rightIntensity = texture2D(inputImageTexture, rightTextureCoordinate).r;\n" +
+    		"    float bottomIntensity = texture2D(inputImageTexture, bottomTextureCoordinate).r;\n" +
+    		"    float topIntensity = texture2D(inputImageTexture, topTextureCoordinate).r;\n" +
+    		"    float h = -topLeftIntensity - 2.0 * topIntensity - topRightIntensity + bottomLeftIntensity + 2.0 * bottomIntensity + bottomRightIntensity;\n" +
+    		"    float v = -bottomLeftIntensity - 2.0 * leftIntensity - topLeftIntensity + bottomRightIntensity + 2.0 * rightIntensity + topRightIntensity;\n" +
+    		"\n" +
+    		"    float mag = 1.0 - length(vec2(h, v));\n" +
+    		"    mag = step(threshold, mag);\n" +
+    		"\n" +
+    		"    gl_FragColor = vec4(vec3(mag), 1.0);\n" +
+    		"}\n";
+
+    private int mUniformThresholdLocation;
+    private float mThreshold = 0.9f;
+    
+    public GPUImageSobelThresholdFilter() {
+    	this(0.9f);
+    }
+    
+    public GPUImageSobelThresholdFilter(float threshold) {
+    	super(SOBEL_THRESHOLD_EDGE_DETECTION);
+    	mThreshold = threshold;
+    }
+    
+    @Override
+    public void onInit() {
+    	super.onInit();
+    	mUniformThresholdLocation = GLES20.glGetUniformLocation(getProgram(), "threshold");
+    }
+    
+    @Override
+    public void onInitialized() {
+    	super.onInitialized();
+    	setThreshold(mThreshold);
+    }
+    
+    public void setThreshold(final float threshold) {
+    	mThreshold = threshold;
+    	setFloat(mUniformThresholdLocation, threshold);
+    }
+}
diff --git a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageSourceOverBlendFilter.java b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageSourceOverBlendFilter.java
index ac883997..fd6a7b98 100644
--- a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageSourceOverBlendFilter.java
+++ b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageSourceOverBlendFilter.java
@@ -26,7 +26,7 @@
             " void main()\n" +
             " {\n" +
             "   lowp vec4 textureColor = texture2D(inputImageTexture, textureCoordinate);\n" +
-            "   lowp vec4 textureColor2 = texture2D(inputImageTexture2, textureCoordinate);\n" +
+            "   lowp vec4 textureColor2 = texture2D(inputImageTexture2, textureCoordinate2);\n" +
             "   \n" +
             "   gl_FragColor = mix(textureColor, textureColor2, textureColor2.a);\n" +
             " }";
diff --git a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageSphereRefractionFilter.java b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageSphereRefractionFilter.java
new file mode 100644
index 00000000..6314cf19
--- /dev/null
+++ b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageSphereRefractionFilter.java
@@ -0,0 +1,127 @@
+/*
+ * Copyright (C) 2012 CyberAgent
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package jp.co.cyberagent.android.gpuimage;
+
+import android.graphics.PointF;
+import android.opengl.GLES20;
+
+public class GPUImageSphereRefractionFilter extends GPUImageFilter {
+    public static final String SPHERE_FRAGMENT_SHADER = "" +
+            "varying highp vec2 textureCoordinate;\n" +
+            "\n" +
+            "uniform sampler2D inputImageTexture;\n" +
+            "\n" +
+            "uniform highp vec2 center;\n" +
+            "uniform highp float radius;\n" +
+            "uniform highp float aspectRatio;\n" +
+            "uniform highp float refractiveIndex;\n" +
+            "\n" +
+            "void main()\n" +
+            "{\n" +
+            "highp vec2 textureCoordinateToUse = vec2(textureCoordinate.x, (textureCoordinate.y * aspectRatio + 0.5 - 0.5 * aspectRatio));\n" +
+            "highp float distanceFromCenter = distance(center, textureCoordinateToUse);\n" +
+            "lowp float checkForPresenceWithinSphere = step(distanceFromCenter, radius);\n" +
+            "\n" +
+            "distanceFromCenter = distanceFromCenter / radius;\n" +
+            "\n" +
+            "highp float normalizedDepth = radius * sqrt(1.0 - distanceFromCenter * distanceFromCenter);\n" +
+            "highp vec3 sphereNormal = normalize(vec3(textureCoordinateToUse - center, normalizedDepth));\n" +
+            "\n" +
+            "highp vec3 refractedVector = refract(vec3(0.0, 0.0, -1.0), sphereNormal, refractiveIndex);\n" +
+            "\n" +
+            "gl_FragColor = texture2D(inputImageTexture, (refractedVector.xy + 1.0) * 0.5) * checkForPresenceWithinSphere;     \n" +
+            "}\n";
+
+    private PointF mCenter;
+    private int mCenterLocation;
+    private float mRadius;
+    private int mRadiusLocation;
+    private float mAspectRatio;
+    private int mAspectRatioLocation;
+    private float mRefractiveIndex;
+    private int mRefractiveIndexLocation;
+
+    public GPUImageSphereRefractionFilter() {
+        this(new PointF(0.5f, 0.5f), 0.25f, 0.71f);
+    }
+
+    public GPUImageSphereRefractionFilter(PointF center, float radius, float refractiveIndex) {
+        super(NO_FILTER_VERTEX_SHADER, SPHERE_FRAGMENT_SHADER);
+        mCenter = center;
+        mRadius = radius;
+        mRefractiveIndex = refractiveIndex;
+    }
+
+    @Override
+    public void onInit() {
+        super.onInit();
+        mCenterLocation = GLES20.glGetUniformLocation(getProgram(), "center");
+        mRadiusLocation = GLES20.glGetUniformLocation(getProgram(), "radius");
+        mAspectRatioLocation = GLES20.glGetUniformLocation(getProgram(), "aspectRatio");
+        mRefractiveIndexLocation = GLES20.glGetUniformLocation(getProgram(), "refractiveIndex");
+    }
+
+    @Override
+    public void onInitialized() {
+        super.onInitialized();
+        setRadius(mRadius);
+        setCenter(mCenter);
+        setRefractiveIndex(mRefractiveIndex);
+    }
+
+    @Override
+    public void onOutputSizeChanged(int width, int height) {
+        mAspectRatio = (float) height / width;
+        setAspectRatio(mAspectRatio);
+        super.onOutputSizeChanged(width, height);
+    }
+
+    private void setAspectRatio(float aspectRatio) {
+        mAspectRatio = aspectRatio;
+        setFloat(mAspectRatioLocation, aspectRatio);
+    }
+
+    /**
+     * The index of refraction for the sphere, with a default of 0.71
+     *
+     * @param refractiveIndex default 0.71
+     */
+    public void setRefractiveIndex(float refractiveIndex) {
+        mRefractiveIndex = refractiveIndex;
+        setFloat(mRefractiveIndexLocation, refractiveIndex);
+    }
+
+    /**
+     * The center about which to apply the distortion, with a default of (0.5, 0.5)
+     *
+     * @param center default (0.5, 0.5)
+     */
+    public void setCenter(PointF center) {
+        mCenter = center;
+        setPoint(mCenterLocation, center);
+    }
+
+    /**
+     * The radius of the distortion, ranging from 0.0 to 1.0, with a default of 0.25
+     *
+     * @param radius from 0.0 to 1.0, default 0.25
+     */
+    public void setRadius(float radius) {
+        mRadius = radius;
+        setFloat(mRadiusLocation, radius);
+    }
+}
diff --git a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageSwirlFilter.java b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageSwirlFilter.java
new file mode 100644
index 00000000..d4947b9a
--- /dev/null
+++ b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageSwirlFilter.java
@@ -0,0 +1,117 @@
+/*
+ * Copyright (C) 2012 CyberAgent
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package jp.co.cyberagent.android.gpuimage;
+
+import android.graphics.PointF;
+import android.opengl.GLES20;
+
+/**
+ * Creates a swirl distortion on the image.
+ */
+public class GPUImageSwirlFilter extends GPUImageFilter {
+    public static final String SWIRL_FRAGMENT_SHADER = "" +
+            "varying highp vec2 textureCoordinate;\n" +
+            "\n" +
+            "uniform sampler2D inputImageTexture;\n" +
+            "\n" +
+            "uniform highp vec2 center;\n" +
+            "uniform highp float radius;\n" +
+            "uniform highp float angle;\n" +
+            "\n" +
+            "void main()\n" +
+            "{\n" +
+            "highp vec2 textureCoordinateToUse = textureCoordinate;\n" +
+            "highp float dist = distance(center, textureCoordinate);\n" +
+            "if (dist < radius)\n" +
+            "{\n" +
+            "textureCoordinateToUse -= center;\n" +
+            "highp float percent = (radius - dist) / radius;\n" +
+            "highp float theta = percent * percent * angle * 8.0;\n" +
+            "highp float s = sin(theta);\n" +
+            "highp float c = cos(theta);\n" +
+            "textureCoordinateToUse = vec2(dot(textureCoordinateToUse, vec2(c, -s)), dot(textureCoordinateToUse, vec2(s, c)));\n" +
+            "textureCoordinateToUse += center;\n" +
+            "}\n" +
+            "\n" +
+            "gl_FragColor = texture2D(inputImageTexture, textureCoordinateToUse );\n" +
+            "\n" +
+            "}\n";
+
+    private float mAngle;
+    private int mAngleLocation;
+    private float mRadius;
+    private int mRadiusLocation;
+    private PointF mCenter;
+    private int mCenterLocation;
+
+    public GPUImageSwirlFilter() {
+        this(0.5f, 1.0f, new PointF(0.5f, 0.5f));
+    }
+
+    public GPUImageSwirlFilter(float radius, float angle, PointF center) {
+        super(NO_FILTER_VERTEX_SHADER, SWIRL_FRAGMENT_SHADER);
+        mRadius = radius;
+        mAngle = angle;
+        mCenter = center;
+    }
+
+    @Override
+    public void onInit() {
+        super.onInit();
+        mAngleLocation = GLES20.glGetUniformLocation(getProgram(), "angle");
+        mRadiusLocation = GLES20.glGetUniformLocation(getProgram(), "radius");
+        mCenterLocation = GLES20.glGetUniformLocation(getProgram(), "center");
+    }
+
+    @Override
+    public void onInitialized() {
+        super.onInitialized();
+        setRadius(mRadius);
+        setAngle(mAngle);
+        setCenter(mCenter);
+    }
+
+    /**
+     * The radius of the distortion, ranging from 0.0 to 1.0, with a default of 0.5.
+     *
+     * @param radius from 0.0 to 1.0, default 0.5
+     */
+    public void setRadius(float radius) {
+        mRadius = radius;
+        setFloat(mRadiusLocation, radius);
+    }
+
+    /**
+     * The amount of distortion to apply, with a minimum of 0.0 and a default of 1.0.
+     *
+     * @param angle minimum 0.0, default 1.0
+     */
+    public void setAngle(float angle) {
+        mAngle = angle;
+        setFloat(mAngleLocation, angle);
+    }
+
+    /**
+     * The center about which to apply the distortion, with a default of (0.5, 0.5).
+     *
+     * @param center default (0.5, 0.5)
+     */
+    public void setCenter(PointF center) {
+        mCenter = center;
+        setPoint(mCenterLocation, center);
+    }
+}
diff --git a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageThresholdEdgeDetection.java b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageThresholdEdgeDetection.java
new file mode 100644
index 00000000..c136155a
--- /dev/null
+++ b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageThresholdEdgeDetection.java
@@ -0,0 +1,20 @@
+package jp.co.cyberagent.android.gpuimage;
+
+/**
+ * Applies sobel edge detection on the image.
+ */
+public class GPUImageThresholdEdgeDetection extends GPUImageFilterGroup {
+    public GPUImageThresholdEdgeDetection() {
+        super();
+        addFilter(new GPUImageGrayscaleFilter());
+        addFilter(new GPUImageSobelThresholdFilter());
+    }
+
+    public void setLineSize(final float size) {
+        ((GPUImage3x3TextureSamplingFilter) getFilters().get(1)).setLineSize(size);
+    }
+
+    public void setThreshold(final float threshold) {
+        ((GPUImageSobelThresholdFilter) getFilters().get(1)).setThreshold(threshold);
+    }
+}
diff --git a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageToneCurveFilter.java b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageToneCurveFilter.java
index cc710d44..0f6e1d08 100644
--- a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageToneCurveFilter.java
+++ b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageToneCurveFilter.java
@@ -174,9 +174,9 @@ public void run() {
                     byte[] toneCurveByteArray = new byte[256 * 4];
                     for (int currentCurveIndex = 0; currentCurveIndex < 256; currentCurveIndex++) {
                         // BGRA for upload to texture
-                        toneCurveByteArray[currentCurveIndex * 4] = (byte) ((int) Math.min(Math.max(currentCurveIndex + mBlueCurve.get(currentCurveIndex) + mRgbCompositeCurve.get(currentCurveIndex), 0), 255) & 0xff);
+                        toneCurveByteArray[currentCurveIndex * 4 + 2] = (byte) ((int) Math.min(Math.max(currentCurveIndex + mBlueCurve.get(currentCurveIndex) + mRgbCompositeCurve.get(currentCurveIndex), 0), 255) & 0xff);
                         toneCurveByteArray[currentCurveIndex * 4 + 1] = (byte) ((int) Math.min(Math.max(currentCurveIndex + mGreenCurve.get(currentCurveIndex) + mRgbCompositeCurve.get(currentCurveIndex), 0), 255) & 0xff);
-                        toneCurveByteArray[currentCurveIndex * 4 + 2] = (byte) ((int) Math.min(Math.max(currentCurveIndex + mRedCurve.get(currentCurveIndex) + mRgbCompositeCurve.get(currentCurveIndex), 0), 255) & 0xff);
+                        toneCurveByteArray[currentCurveIndex * 4] = (byte) ((int) Math.min(Math.max(currentCurveIndex + mRedCurve.get(currentCurveIndex) + mRgbCompositeCurve.get(currentCurveIndex), 0), 255) & 0xff);
                         toneCurveByteArray[currentCurveIndex * 4 + 3] = (byte) (255 & 0xff);
                     }
 
diff --git a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageToonFilter.java b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageToonFilter.java
new file mode 100644
index 00000000..5148d1d0
--- /dev/null
+++ b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageToonFilter.java
@@ -0,0 +1,121 @@
+/*
+ * Copyright (C) 2012 CyberAgent
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package jp.co.cyberagent.android.gpuimage;
+
+import android.opengl.GLES20;
+
+/**
+ * This uses Sobel edge detection to place a black border around objects,
+ * and then it quantizes the colors present in the image to give a cartoon-like quality to the image.
+ */
+public class GPUImageToonFilter extends GPUImage3x3TextureSamplingFilter {
+    public static final String TOON_FRAGMENT_SHADER = "" +
+            "precision highp float;\n" +
+            "\n" +
+            "varying vec2 textureCoordinate;\n" +
+            "varying vec2 leftTextureCoordinate;\n" +
+            "varying vec2 rightTextureCoordinate;\n" +
+            "\n" +
+            "varying vec2 topTextureCoordinate;\n" +
+            "varying vec2 topLeftTextureCoordinate;\n" +
+            "varying vec2 topRightTextureCoordinate;\n" +
+            "\n" +
+            "varying vec2 bottomTextureCoordinate;\n" +
+            "varying vec2 bottomLeftTextureCoordinate;\n" +
+            "varying vec2 bottomRightTextureCoordinate;\n" +
+            "\n" +
+            "uniform sampler2D inputImageTexture;\n" +
+            "\n" +
+            "uniform highp float intensity;\n" +
+            "uniform highp float threshold;\n" +
+            "uniform highp float quantizationLevels;\n" +
+            "\n" +
+            "const highp vec3 W = vec3(0.2125, 0.7154, 0.0721);\n" +
+            "\n" +
+            "void main()\n" +
+            "{\n" +
+            "vec4 textureColor = texture2D(inputImageTexture, textureCoordinate);\n" +
+            "\n" +
+            "float bottomLeftIntensity = texture2D(inputImageTexture, bottomLeftTextureCoordinate).r;\n" +
+            "float topRightIntensity = texture2D(inputImageTexture, topRightTextureCoordinate).r;\n" +
+            "float topLeftIntensity = texture2D(inputImageTexture, topLeftTextureCoordinate).r;\n" +
+            "float bottomRightIntensity = texture2D(inputImageTexture, bottomRightTextureCoordinate).r;\n" +
+            "float leftIntensity = texture2D(inputImageTexture, leftTextureCoordinate).r;\n" +
+            "float rightIntensity = texture2D(inputImageTexture, rightTextureCoordinate).r;\n" +
+            "float bottomIntensity = texture2D(inputImageTexture, bottomTextureCoordinate).r;\n" +
+            "float topIntensity = texture2D(inputImageTexture, topTextureCoordinate).r;\n" +
+            "float h = -topLeftIntensity - 2.0 * topIntensity - topRightIntensity + bottomLeftIntensity + 2.0 * bottomIntensity + bottomRightIntensity;\n" +
+            "float v = -bottomLeftIntensity - 2.0 * leftIntensity - topLeftIntensity + bottomRightIntensity + 2.0 * rightIntensity + topRightIntensity;\n" +
+            "\n" +
+            "float mag = length(vec2(h, v));\n" +
+            "\n" +
+            "vec3 posterizedImageColor = floor((textureColor.rgb * quantizationLevels) + 0.5) / quantizationLevels;\n" +
+            "\n" +
+            "float thresholdTest = 1.0 - step(threshold, mag);\n" +
+            "\n" +
+            "gl_FragColor = vec4(posterizedImageColor * thresholdTest, textureColor.a);\n" +
+            "}\n";
+
+    float mThreshold;
+    int mThresholdLocation;
+    float mQuantizationLevels;
+    int mQuantizationLevelsLocation;
+
+    public GPUImageToonFilter() {
+        this(0.2f, 10.0f);
+    }
+
+    public GPUImageToonFilter(float threshold, float quantizationLevels) {
+        super(TOON_FRAGMENT_SHADER);
+        mThreshold = threshold;
+        mQuantizationLevels = quantizationLevels;
+    }
+
+    @Override
+    public void onInit() {
+        super.onInit();
+        mThresholdLocation = GLES20.glGetUniformLocation(getProgram(), "threshold");
+        mQuantizationLevelsLocation = GLES20.glGetUniformLocation(getProgram(), "quantizationLevels");
+    }
+
+    @Override
+    public void onInitialized() {
+        super.onInitialized();
+        setThreshold(mThreshold);
+        setQuantizationLevels(mQuantizationLevels);
+    }
+
+    /**
+     * The threshold at which to apply the edges, default of 0.2.
+     *
+     * @param threshold default 0.2
+     */
+    public void setThreshold(final float threshold) {
+        mThreshold = threshold;
+        setFloat(mThresholdLocation, threshold);
+    }
+
+    /**
+     * The levels of quantization for the posterization of colors within the scene, with a default of 10.0.
+     *
+     * @param quantizationLevels default 10.0
+     */
+    public void setQuantizationLevels(final float quantizationLevels) {
+        mQuantizationLevels = quantizationLevels;
+        setFloat(mQuantizationLevelsLocation, quantizationLevels);
+    }
+}
diff --git a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageTransformFilter.java b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageTransformFilter.java
new file mode 100644
index 00000000..0a962cc5
--- /dev/null
+++ b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageTransformFilter.java
@@ -0,0 +1,134 @@
+package jp.co.cyberagent.android.gpuimage;
+
+import android.opengl.GLES20;
+import android.opengl.Matrix;
+
+import java.nio.ByteBuffer;
+import java.nio.ByteOrder;
+import java.nio.FloatBuffer;
+
+public class GPUImageTransformFilter extends GPUImageFilter {
+    public static final String TRANSFORM_VERTEX_SHADER = "" +
+            "attribute vec4 position;\n" +
+            " attribute vec4 inputTextureCoordinate;\n" +
+            " \n" +
+            " uniform mat4 transformMatrix;\n" +
+            " uniform mat4 orthographicMatrix;\n" +
+            " \n" +
+            " varying vec2 textureCoordinate;\n" +
+            " \n" +
+            " void main()\n" +
+            " {\n" +
+            "     gl_Position = transformMatrix * vec4(position.xyz, 1.0) * orthographicMatrix;\n" +
+            "     textureCoordinate = inputTextureCoordinate.xy;\n" +
+            " }";
+
+    private int transformMatrixUniform;
+    private int orthographicMatrixUniform;
+    private float[] orthographicMatrix;
+
+    private float[] transform3D;
+
+    // This applies the transform to the raw frame data if set to YES, the default of NO takes the aspect ratio of the image input into account when rotating
+    private boolean ignoreAspectRatio;
+
+    // sets the anchor point to top left corner
+    private boolean anchorTopLeft;
+
+    public GPUImageTransformFilter() {
+        super(TRANSFORM_VERTEX_SHADER, NO_FILTER_FRAGMENT_SHADER);
+
+        orthographicMatrix = new float[16];
+        Matrix.orthoM(orthographicMatrix, 0, -1.0f, 1.0f, -1.0f, 1.0f, -1.0f, 1.0f);
+
+        transform3D = new float[16];
+        Matrix.setIdentityM(transform3D, 0);
+    }
+
+    @Override
+    public void onInit() {
+        super.onInit();
+        transformMatrixUniform = GLES20.glGetUniformLocation(getProgram(), "transformMatrix");
+        orthographicMatrixUniform = GLES20.glGetUniformLocation(getProgram(), "orthographicMatrix");
+
+        setUniformMatrix4f(transformMatrixUniform, transform3D);
+        setUniformMatrix4f(orthographicMatrixUniform, orthographicMatrix);
+    }
+
+    @Override
+    public void onInitialized() {
+        super.onInitialized();
+    }
+
+    @Override
+    public void onOutputSizeChanged(final int width, final int height) {
+        super.onOutputSizeChanged(width, height);
+
+        if (!ignoreAspectRatio) {
+            Matrix.orthoM(orthographicMatrix, 0, -1.0f, 1.0f, -1.0f * (float) height / (float) width, 1.0f * (float) height / (float) width, -1.0f, 1.0f);
+            setUniformMatrix4f(orthographicMatrixUniform, orthographicMatrix);
+        }
+    }
+
+    @Override
+    public void onDraw(final int textureId, final FloatBuffer cubeBuffer,
+                       final FloatBuffer textureBuffer) {
+
+        FloatBuffer vertBuffer = cubeBuffer;
+
+        if (!ignoreAspectRatio) {
+
+            float[] adjustedVertices = new float[8];
+
+            cubeBuffer.position(0);
+            cubeBuffer.get(adjustedVertices);
+
+            float normalizedHeight = (float) getOutputHeight() / (float) getOutputWidth();
+            adjustedVertices[1] *= normalizedHeight;
+            adjustedVertices[3] *= normalizedHeight;
+            adjustedVertices[5] *= normalizedHeight;
+            adjustedVertices[7] *= normalizedHeight;
+
+            vertBuffer = ByteBuffer.allocateDirect(adjustedVertices.length * 4)
+                    .order(ByteOrder.nativeOrder())
+                    .asFloatBuffer();
+
+            vertBuffer.put(adjustedVertices).position(0);
+        }
+
+        super.onDraw(textureId, vertBuffer, textureBuffer);
+    }
+
+    public void setTransform3D(float[] transform3D) {
+        this.transform3D = transform3D;
+        setUniformMatrix4f(transformMatrixUniform, transform3D);
+    }
+
+    public float[] getTransform3D() {
+        return transform3D;
+    }
+
+    public void setIgnoreAspectRatio(boolean ignoreAspectRatio) {
+        this.ignoreAspectRatio = ignoreAspectRatio;
+
+        if (ignoreAspectRatio) {
+            Matrix.orthoM(orthographicMatrix, 0, -1.0f, 1.0f, -1.0f, 1.0f, -1.0f, 1.0f);
+            setUniformMatrix4f(orthographicMatrixUniform, orthographicMatrix);
+        } else {
+            onOutputSizeChanged(getOutputWidth(), getOutputHeight());
+        }
+    }
+
+    public boolean ignoreAspectRatio() {
+        return ignoreAspectRatio;
+    }
+
+    public void setAnchorTopLeft(boolean anchorTopLeft) {
+        this.anchorTopLeft = anchorTopLeft;
+        setIgnoreAspectRatio(ignoreAspectRatio);
+    }
+
+    public boolean anchorTopLeft() {
+        return anchorTopLeft;
+    }
+}
diff --git a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageTwoInputFilter.java b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageTwoInputFilter.java
index 90645b40..afc3b864 100644
--- a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageTwoInputFilter.java
+++ b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageTwoInputFilter.java
@@ -16,14 +16,14 @@
 
 package jp.co.cyberagent.android.gpuimage;
 
-import android.graphics.Bitmap;
-import android.opengl.GLES20;
-import jp.co.cyberagent.android.gpuimage.util.TextureRotationUtil;
-
 import java.nio.ByteBuffer;
 import java.nio.ByteOrder;
 import java.nio.FloatBuffer;
 
+import jp.co.cyberagent.android.gpuimage.util.TextureRotationUtil;
+import android.graphics.Bitmap;
+import android.opengl.GLES20;
+
 public class GPUImageTwoInputFilter extends GPUImageFilter {
     private static final String VERTEX_SHADER = "attribute vec4 position;\n" +
             "attribute vec4 inputTextureCoordinate;\n" +
@@ -39,9 +39,9 @@
             "    textureCoordinate2 = inputTextureCoordinate2.xy;\n" +
             "}";
 
-    public int filterSecondTextureCoordinateAttribute;
-    public int filterInputTextureUniform2;
-    public int filterSourceTexture2 = OpenGlUtils.NO_TEXTURE;
+    public int mFilterSecondTextureCoordinateAttribute;
+    public int mFilterInputTextureUniform2;
+    public int mFilterSourceTexture2 = OpenGlUtils.NO_TEXTURE;
     private ByteBuffer mTexture2CoordinatesBuffer;
     private Bitmap mBitmap;
 
@@ -58,44 +58,64 @@ public GPUImageTwoInputFilter(String vertexShader, String fragmentShader) {
     public void onInit() {
         super.onInit();
 
-        filterSecondTextureCoordinateAttribute = GLES20.glGetAttribLocation(getProgram(), "inputTextureCoordinate2");
-        filterInputTextureUniform2 = GLES20.glGetUniformLocation(getProgram(), "inputImageTexture2"); // This does assume a name of "inputImageTexture2" for second input texture in the fragment shader
-        GLES20.glEnableVertexAttribArray(filterSecondTextureCoordinateAttribute);
+        mFilterSecondTextureCoordinateAttribute = GLES20.glGetAttribLocation(getProgram(), "inputTextureCoordinate2");
+        mFilterInputTextureUniform2 = GLES20.glGetUniformLocation(getProgram(), "inputImageTexture2"); // This does assume a name of "inputImageTexture2" for second input texture in the fragment shader
+        GLES20.glEnableVertexAttribArray(mFilterSecondTextureCoordinateAttribute);
 
-        if (mBitmap != null) {
+        if (mBitmap != null&&!mBitmap.isRecycled()) {
             setBitmap(mBitmap);
         }
     }
-
+    
     public void setBitmap(final Bitmap bitmap) {
+        if (bitmap != null && bitmap.isRecycled()) {
+            return;
+        }
         mBitmap = bitmap;
+        if (mBitmap == null) {
+            return;
+        }
         runOnDraw(new Runnable() {
             public void run() {
-                if (filterSourceTexture2 == OpenGlUtils.NO_TEXTURE) {
+                if (mFilterSourceTexture2 == OpenGlUtils.NO_TEXTURE) {
+                    if (bitmap == null || bitmap.isRecycled()) {
+                        return;
+                    }
                     GLES20.glActiveTexture(GLES20.GL_TEXTURE3);
-                    filterSourceTexture2 = OpenGlUtils.loadTexture(bitmap, OpenGlUtils.NO_TEXTURE, false);
+                    mFilterSourceTexture2 = OpenGlUtils.loadTexture(bitmap, OpenGlUtils.NO_TEXTURE, false);
                 }
             }
         });
     }
 
+    public Bitmap getBitmap() {
+        return mBitmap;
+    }
+
+    public void recycleBitmap() {
+        if (mBitmap != null && !mBitmap.isRecycled()) {
+            mBitmap.recycle();
+            mBitmap = null;
+        }
+    }
+
     public void onDestroy() {
         super.onDestroy();
         GLES20.glDeleteTextures(1, new int[]{
-                filterSourceTexture2
+                mFilterSourceTexture2
         }, 0);
-        filterSourceTexture2 = OpenGlUtils.NO_TEXTURE;
+        mFilterSourceTexture2 = OpenGlUtils.NO_TEXTURE;
     }
 
     @Override
     protected void onDrawArraysPre() {
-        GLES20.glEnableVertexAttribArray(filterSecondTextureCoordinateAttribute);
+        GLES20.glEnableVertexAttribArray(mFilterSecondTextureCoordinateAttribute);
         GLES20.glActiveTexture(GLES20.GL_TEXTURE3);
-        GLES20.glBindTexture(GLES20.GL_TEXTURE_2D, filterSourceTexture2);
-        GLES20.glUniform1i(filterInputTextureUniform2, 3);
+        GLES20.glBindTexture(GLES20.GL_TEXTURE_2D, mFilterSourceTexture2);
+        GLES20.glUniform1i(mFilterInputTextureUniform2, 3);
 
         mTexture2CoordinatesBuffer.position(0);
-        GLES20.glVertexAttribPointer(filterSecondTextureCoordinateAttribute, 2, GLES20.GL_FLOAT, false, 0, mTexture2CoordinatesBuffer);
+        GLES20.glVertexAttribPointer(mFilterSecondTextureCoordinateAttribute, 2, GLES20.GL_FLOAT, false, 0, mTexture2CoordinatesBuffer);
     }
 
     public void setRotation(final Rotation rotation, final boolean flipHorizontal, final boolean flipVertical) {
diff --git a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageTwoPassFilter.java b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageTwoPassFilter.java
new file mode 100644
index 00000000..bf3fbf17
--- /dev/null
+++ b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageTwoPassFilter.java
@@ -0,0 +1,26 @@
+/*
+ * Copyright (C) 2012 CyberAgent
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package jp.co.cyberagent.android.gpuimage;
+
+public class GPUImageTwoPassFilter extends GPUImageFilterGroup {
+    public GPUImageTwoPassFilter(String firstVertexShader, String firstFragmentShader,
+                                 String secondVertexShader, String secondFragmentShader) {
+        super(null);
+        addFilter(new GPUImageFilter(firstVertexShader, firstFragmentShader));
+        addFilter(new GPUImageFilter(secondVertexShader, secondFragmentShader));
+    }
+}
diff --git a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageTwoPassTextureSamplingFilter.java b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageTwoPassTextureSamplingFilter.java
new file mode 100644
index 00000000..19c0365b
--- /dev/null
+++ b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageTwoPassTextureSamplingFilter.java
@@ -0,0 +1,63 @@
+/*
+ * Copyright (C) 2012 CyberAgent
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package jp.co.cyberagent.android.gpuimage;
+
+import android.opengl.GLES20;
+
+public class GPUImageTwoPassTextureSamplingFilter extends GPUImageTwoPassFilter {
+    public GPUImageTwoPassTextureSamplingFilter(String firstVertexShader, String firstFragmentShader,
+                                                String secondVertexShader, String secondFragmentShader) {
+        super(firstVertexShader, firstFragmentShader,
+                secondVertexShader, secondFragmentShader);
+    }
+
+    @Override
+    public void onInit() {
+        super.onInit();
+        initTexelOffsets();
+    }
+
+    protected void initTexelOffsets() {
+        float ratio = getHorizontalTexelOffsetRatio();
+        GPUImageFilter filter = mFilters.get(0);
+        int texelWidthOffsetLocation = GLES20.glGetUniformLocation(filter.getProgram(), "texelWidthOffset");
+        int texelHeightOffsetLocation = GLES20.glGetUniformLocation(filter.getProgram(), "texelHeightOffset");
+        filter.setFloat(texelWidthOffsetLocation, ratio / mOutputWidth);
+        filter.setFloat(texelHeightOffsetLocation, 0);
+
+        ratio = getVerticalTexelOffsetRatio();
+        filter = mFilters.get(1);
+        texelWidthOffsetLocation = GLES20.glGetUniformLocation(filter.getProgram(), "texelWidthOffset");
+        texelHeightOffsetLocation = GLES20.glGetUniformLocation(filter.getProgram(), "texelHeightOffset");
+        filter.setFloat(texelWidthOffsetLocation, 0);
+        filter.setFloat(texelHeightOffsetLocation, ratio / mOutputHeight);
+    }
+
+    @Override
+    public void onOutputSizeChanged(int width, int height) {
+        super.onOutputSizeChanged(width, height);
+        initTexelOffsets();
+    }
+
+    public float getVerticalTexelOffsetRatio() {
+        return 1f;
+    }
+
+    public float getHorizontalTexelOffsetRatio() {
+        return 1f;
+    }
+}
diff --git a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageView.java b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageView.java
index 9194d895..cc6a0247 100644
--- a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageView.java
+++ b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageView.java
@@ -18,38 +18,54 @@
 
 import android.content.Context;
 import android.graphics.Bitmap;
+import android.graphics.Color;
+import android.graphics.drawable.ColorDrawable;
+import android.graphics.drawable.Drawable;
+import android.media.MediaScannerConnection;
 import android.net.Uri;
+import android.opengl.GLES20;
 import android.opengl.GLSurfaceView;
+import android.os.*;
 import android.util.AttributeSet;
+import android.view.Gravity;
+import android.view.ViewTreeObserver;
+import android.widget.FrameLayout;
+import android.widget.ProgressBar;
 
 import java.io.File;
+import java.io.FileNotFoundException;
+import java.io.FileOutputStream;
+import java.nio.IntBuffer;
+import java.util.concurrent.Semaphore;
 
-public class GPUImageView extends GLSurfaceView {
+public class GPUImageView extends FrameLayout {
 
+    private GLSurfaceView mGLSurfaceView;
     private GPUImage mGPUImage;
     private GPUImageFilter mFilter;
+    public Size mForceSize = null;
     private float mRatio = 0.0f;
 
     public GPUImageView(Context context) {
         super(context);
-        init();
+        init(context, null);
     }
 
     public GPUImageView(Context context, AttributeSet attrs) {
         super(context, attrs);
-        init();
+        init(context, attrs);
     }
 
-    private void init() {
+    private void init(Context context, AttributeSet attrs) {
+        mGLSurfaceView = new GPUImageGLSurfaceView(context, attrs);
+        addView(mGLSurfaceView);
         mGPUImage = new GPUImage(getContext());
-        mGPUImage.setGLSurfaceView(this);
+        mGPUImage.setGLSurfaceView(mGLSurfaceView);
     }
 
     @Override
     protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
-        if (mRatio == 0.0f) {
-            super.onMeasure(widthMeasureSpec, heightMeasureSpec);
-        } else {
+        if (mRatio != 0.0f) {
             int width = MeasureSpec.getSize(widthMeasureSpec);
             int height = MeasureSpec.getSize(heightMeasureSpec);
 
@@ -66,16 +82,57 @@ protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
             int newWidthSpec = MeasureSpec.makeMeasureSpec(newWidth, MeasureSpec.EXACTLY);
             int newHeightSpec = MeasureSpec.makeMeasureSpec(newHeight, MeasureSpec.EXACTLY);
             super.onMeasure(newWidthSpec, newHeightSpec);
+        } else {
+            super.onMeasure(widthMeasureSpec, heightMeasureSpec);
         }
     }
 
+    /**
+     * Retrieve the GPUImage instance used by this view.
+     *
+     * @return used GPUImage instance
+     */
+    public GPUImage getGPUImage() {
+        return mGPUImage;
+    }
+
+    /**
+     * Sets the background color
+     *
+     * @param red red color value
+     * @param green green color value
+     * @param blue red color value
+     */
+    public void setBackgroundColor(float red, float green, float blue) {
+        mGPUImage.setBackgroundColor(red, green, blue);
+    }
+
     // TODO Should be an xml attribute. But then GPUImage can not be distributed as .jar anymore.
     public void setRatio(float ratio) {
         mRatio = ratio;
-        requestLayout();
+        mGLSurfaceView.requestLayout();
         mGPUImage.deleteImage();
     }
 
+    /**
+     * Set the scale type of GPUImage.
+     *
+     * @param scaleType the new ScaleType
+     */
+    public void setScaleType(GPUImage.ScaleType scaleType) {
+        mGPUImage.setScaleType(scaleType);
+    }
+
+    /**
+     * Sets the rotation of the displayed image.
+     *
+     * @param rotation new rotation
+     */
+    public void setRotation(Rotation rotation) {
+        mGPUImage.setRotation(rotation);
+        requestRender();
+    }
+
     /**
      * Set the filter to be applied on the image.
      *
@@ -123,10 +180,14 @@ public void setImage(final File file) {
         mGPUImage.setImage(file);
     }
 
+    public void requestRender() {
+        mGLSurfaceView.requestRender();
+    }
+
     /**
      * Save current image with applied filter to Pictures. It will be stored on
-     * the default Picture folder on the phone below the given folerName and
-     * fileName. <br />
+     * the default Picture folder on the phone below the given folderName and
+     * fileName. <br>
      * This method is async and will notify when the image was saved through the
      * listener.
      *
@@ -135,7 +196,274 @@ public void setImage(final File file) {
      * @param listener the listener
      */
     public void saveToPictures(final String folderName, final String fileName,
-                               final GPUImage.OnPictureSavedListener listener) {
-        mGPUImage.saveToPictures(folderName, fileName, listener);
+                               final OnPictureSavedListener listener) {
+        new SaveTask(folderName, fileName, listener).execute();
+    }
+
+    /**
+     * Save current image with applied filter to Pictures. It will be stored on
+     * the default Picture folder on the phone below the given folderName and
+     * fileName. <br>
+     * This method is async and will notify when the image was saved through the
+     * listener.
+     *
+     * @param folderName the folder name
+     * @param fileName   the file name
+     * @param width      requested output width
+     * @param height     requested output height
+     * @param listener   the listener
+     */
+    public void saveToPictures(final String folderName, final String fileName,
+                               int width, int height,
+                               final OnPictureSavedListener listener) {
+        new SaveTask(folderName, fileName, width, height, listener).execute();
+    }
+
+    /**
+     * Retrieve current image with filter applied and given size as Bitmap.
+     *
+     * @param width  requested Bitmap width
+     * @param height requested Bitmap height
+     * @return Bitmap of picture with given size
+     * @throws InterruptedException
+     */
+    public Bitmap capture(final int width, final int height) throws InterruptedException {
+        // This method needs to run on a background thread because it will take a longer time
+        if (Looper.myLooper() == Looper.getMainLooper()) {
+            throw new IllegalStateException("Do not call this method from the UI thread!");
+        }
+
+        mForceSize = new Size(width, height);
+
+        final Semaphore waiter = new Semaphore(0);
+
+        // Layout with new size
+        getViewTreeObserver().addOnGlobalLayoutListener(new ViewTreeObserver.OnGlobalLayoutListener() {
+            @Override
+            public void onGlobalLayout() {
+                if (Build.VERSION.SDK_INT < Build.VERSION_CODES.JELLY_BEAN) {
+                    getViewTreeObserver().removeGlobalOnLayoutListener(this);
+                } else {
+                    getViewTreeObserver().removeOnGlobalLayoutListener(this);
+                }
+                waiter.release();
+            }
+        });
+        post(new Runnable() {
+            @Override
+            public void run() {
+                // Show loading
+                addView(new LoadingView(getContext()));
+
+                mGLSurfaceView.requestLayout();
+            }
+        });
+        waiter.acquire();
+
+        // Run one render pass
+        mGPUImage.runOnGLThread(new Runnable() {
+            @Override
+            public void run() {
+                waiter.release();
+            }
+        });
+        requestRender();
+        waiter.acquire();
+        Bitmap bitmap = capture();
+
+
+        mForceSize = null;
+        post(new Runnable() {
+            @Override
+            public void run() {
+                mGLSurfaceView.requestLayout();
+            }
+        });
+        requestRender();
+
+        postDelayed(new Runnable() {
+            @Override
+            public void run() {
+                // Remove loading view
+                removeViewAt(1);
+            }
+        }, 300);
+
+        return bitmap;
+    }
+
+    /**
+     * Capture the current image with the size as it is displayed and retrieve it as Bitmap.
+     * @return current output as Bitmap
+     * @throws InterruptedException
+     */
+    public Bitmap capture() throws InterruptedException {
+        final Semaphore waiter = new Semaphore(0);
+
+        final int width = mGLSurfaceView.getMeasuredWidth();
+        final int height = mGLSurfaceView.getMeasuredHeight();
+
+        // Take picture on OpenGL thread
+        final int[] pixelMirroredArray = new int[width * height];
+        mGPUImage.runOnGLThread(new Runnable() {
+            @Override
+            public void run() {
+                final IntBuffer pixelBuffer = IntBuffer.allocate(width * height);
+                GLES20.glReadPixels(0, 0, width, height, GLES20.GL_RGBA, GLES20.GL_UNSIGNED_BYTE, pixelBuffer);
+                int[] pixelArray = pixelBuffer.array();
+
+                // Convert upside down mirror-reversed image to right-side up normal image.
+                for (int i = 0; i < height; i++) {
+                    for (int j = 0; j < width; j++) {
+                        pixelMirroredArray[(height - i - 1) * width + j] = pixelArray[i * width + j];
+                    }
+                }
+                waiter.release();
+            }
+        });
+        requestRender();
+        waiter.acquire();
+
+        Bitmap bitmap = Bitmap.createBitmap(width, height, Bitmap.Config.ARGB_8888);
+        bitmap.copyPixelsFromBuffer(IntBuffer.wrap(pixelMirroredArray));
+        return bitmap;
+    }
+
+    /**
+     * Pauses the GLSurfaceView.
+     */
+    public void onPause() {
+        mGLSurfaceView.onPause();
+    }
+
+    /**
+     * Resumes the GLSurfaceView.
+     */
+    public void onResume() {
+        mGLSurfaceView.onResume();
+    }
+
+    public static class Size {
+        int width;
+        int height;
+
+        public Size(int width, int height) {
+            this.width = width;
+            this.height = height;
+        }
+    }
+
+    private class GPUImageGLSurfaceView extends GLSurfaceView {
+        public GPUImageGLSurfaceView(Context context) {
+            super(context);
+        }
+
+        public GPUImageGLSurfaceView(Context context, AttributeSet attrs) {
+            super(context, attrs);
+        }
+
+        @Override
+        protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
+            if (mForceSize != null) {
+                super.onMeasure(MeasureSpec.makeMeasureSpec(mForceSize.width, MeasureSpec.EXACTLY),
+                        MeasureSpec.makeMeasureSpec(mForceSize.height, MeasureSpec.EXACTLY));
+            } else {
+                super.onMeasure(widthMeasureSpec, heightMeasureSpec);
+            }
+        }
+    }
+
+    private class LoadingView extends FrameLayout {
+        public LoadingView(Context context) {
+            super(context);
+            init();
+        }
+
+        public LoadingView(Context context, AttributeSet attrs) {
+            super(context, attrs);
+            init();
+        }
+
+        public LoadingView(Context context, AttributeSet attrs, int defStyle) {
+            super(context, attrs, defStyle);
+            init();
+        }
+
+        private void init() {
+            ProgressBar view = new ProgressBar(getContext());
+            view.setLayoutParams(
+                    new LayoutParams(LayoutParams.WRAP_CONTENT, LayoutParams.WRAP_CONTENT, Gravity.CENTER));
+            addView(view);
+            setBackgroundColor(Color.BLACK);
+        }
+    }
+
+    private class SaveTask extends AsyncTask<Void, Void, Void> {
+        private final String mFolderName;
+        private final String mFileName;
+        private final int mWidth;
+        private final int mHeight;
+        private final OnPictureSavedListener mListener;
+        private final Handler mHandler;
+
+        public SaveTask(final String folderName, final String fileName,
+                        final OnPictureSavedListener listener) {
+            this(folderName, fileName, 0, 0, listener);
+        }
+
+        public SaveTask(final String folderName, final String fileName, int width, int height,
+                        final OnPictureSavedListener listener) {
+            mFolderName = folderName;
+            mFileName = fileName;
+            mWidth = width;
+            mHeight = height;
+            mListener = listener;
+            mHandler = new Handler();
+        }
+
+        @Override
+        protected Void doInBackground(final Void... params) {
+            try {
+                Bitmap result = mWidth != 0 ? capture(mWidth, mHeight) : capture();
+                saveImage(mFolderName, mFileName, result);
+            } catch (InterruptedException e) {
+                e.printStackTrace();
+            }
+            return null;
+        }
+
+        private void saveImage(final String folderName, final String fileName, final Bitmap image) {
+            File path = Environment
+                    .getExternalStoragePublicDirectory(Environment.DIRECTORY_PICTURES);
+            File file = new File(path, folderName + "/" + fileName);
+            try {
+                file.getParentFile().mkdirs();
+                image.compress(Bitmap.CompressFormat.JPEG, 80, new FileOutputStream(file));
+                MediaScannerConnection.scanFile(getContext(),
+                        new String[]{
+                                file.toString()
+                        }, null,
+                        new MediaScannerConnection.OnScanCompletedListener() {
+                            @Override
+                            public void onScanCompleted(final String path, final Uri uri) {
+                                if (mListener != null) {
+                                    mHandler.post(new Runnable() {
+
+                                        @Override
+                                        public void run() {
+                                            mListener.onPictureSaved(uri);
+                                        }
+                                    });
+                                }
+                            }
+                        });
+            } catch (FileNotFoundException e) {
+                e.printStackTrace();
+            }
+        }
+    }
+
+    public interface OnPictureSavedListener {
+        void onPictureSaved(Uri uri);
     }
 }
diff --git a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageWeakPixelInclusionFilter.java b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageWeakPixelInclusionFilter.java
new file mode 100644
index 00000000..3e1b8f01
--- /dev/null
+++ b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageWeakPixelInclusionFilter.java
@@ -0,0 +1,59 @@
+/*
+ * Copyright (C) 2012 CyberAgent
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package jp.co.cyberagent.android.gpuimage;
+
+public class GPUImageWeakPixelInclusionFilter extends GPUImage3x3TextureSamplingFilter {
+    public static final String WEAKPIXEL_FRAGMENT_SHADER = "" +
+            "precision lowp float;\n" +
+            "\n" +
+            "varying vec2 textureCoordinate;\n" +
+            "varying vec2 leftTextureCoordinate;\n" +
+            "varying vec2 rightTextureCoordinate;\n" +
+            "\n" +
+            "varying vec2 topTextureCoordinate;\n" +
+            "varying vec2 topLeftTextureCoordinate;\n" +
+            "varying vec2 topRightTextureCoordinate;\n" +
+            "\n" +
+            "varying vec2 bottomTextureCoordinate;\n" +
+            "varying vec2 bottomLeftTextureCoordinate;\n" +
+            "varying vec2 bottomRightTextureCoordinate;\n" +
+            "\n" +
+            "uniform sampler2D inputImageTexture;\n" +
+            "\n" +
+            "void main()\n" +
+            "{\n" +
+            "float bottomLeftIntensity = texture2D(inputImageTexture, bottomLeftTextureCoordinate).r;\n" +
+            "float topRightIntensity = texture2D(inputImageTexture, topRightTextureCoordinate).r;\n" +
+            "float topLeftIntensity = texture2D(inputImageTexture, topLeftTextureCoordinate).r;\n" +
+            "float bottomRightIntensity = texture2D(inputImageTexture, bottomRightTextureCoordinate).r;\n" +
+            "float leftIntensity = texture2D(inputImageTexture, leftTextureCoordinate).r;\n" +
+            "float rightIntensity = texture2D(inputImageTexture, rightTextureCoordinate).r;\n" +
+            "float bottomIntensity = texture2D(inputImageTexture, bottomTextureCoordinate).r;\n" +
+            "float topIntensity = texture2D(inputImageTexture, topTextureCoordinate).r;\n" +
+            "float centerIntensity = texture2D(inputImageTexture, textureCoordinate).r;\n" +
+            "\n" +
+            "float pixelIntensitySum = bottomLeftIntensity + topRightIntensity + topLeftIntensity + bottomRightIntensity + leftIntensity + rightIntensity + bottomIntensity + topIntensity + centerIntensity;\n" +
+            "float sumTest = step(1.5, pixelIntensitySum);\n" +
+            "float pixelTest = step(0.01, centerIntensity);\n" +
+            "\n" +
+            "gl_FragColor = vec4(vec3(sumTest * pixelTest), 1.0);\n" +
+            "}\n";
+
+    public GPUImageWeakPixelInclusionFilter() {
+        super(WEAKPIXEL_FRAGMENT_SHADER);
+    }
+}
diff --git a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageWhiteBalanceFilter.java b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageWhiteBalanceFilter.java
index 1816d829..1818da99 100644
--- a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageWhiteBalanceFilter.java
+++ b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageWhiteBalanceFilter.java
@@ -19,8 +19,8 @@
 import android.opengl.GLES20;
 
 /**
- * Adjusts the white balance of incoming image. <br />
- * <br />
+ * Adjusts the white balance of incoming image. <br>
+ * <br>
  * temperature: 
  * tint:
  */
diff --git a/library/src/jp/co/cyberagent/android/gpuimage/PixelBuffer.java b/library/src/jp/co/cyberagent/android/gpuimage/PixelBuffer.java
index 6d45396f..ac23f599 100644
--- a/library/src/jp/co/cyberagent/android/gpuimage/PixelBuffer.java
+++ b/library/src/jp/co/cyberagent/android/gpuimage/PixelBuffer.java
@@ -189,19 +189,22 @@ private int getConfigAttrib(final EGLConfig config, final int attribute) {
     }
 
     private void convertToBitmap() {
+        int[] iat = new int[mWidth * mHeight];
         IntBuffer ib = IntBuffer.allocate(mWidth * mHeight);
-        IntBuffer ibt = IntBuffer.allocate(mWidth * mHeight);
         mGL.glReadPixels(0, 0, mWidth, mHeight, GL_RGBA, GL_UNSIGNED_BYTE, ib);
+        int[] ia = ib.array();
 
+        //Stupid !
         // Convert upside down mirror-reversed image to right-side up normal
         // image.
         for (int i = 0; i < mHeight; i++) {
             for (int j = 0; j < mWidth; j++) {
-                ibt.put((mHeight - i - 1) * mWidth + j, ib.get(i * mWidth + j));
+                iat[(mHeight - i - 1) * mWidth + j] = ia[i * mWidth + j];
             }
         }
+        
 
         mBitmap = Bitmap.createBitmap(mWidth, mHeight, Bitmap.Config.ARGB_8888);
-        mBitmap.copyPixelsFromBuffer(ibt);
+        mBitmap.copyPixelsFromBuffer(IntBuffer.wrap(iat));
     }
 }
diff --git a/library/src/jp/co/cyberagent/android/gpuimage/Rotation.java b/library/src/jp/co/cyberagent/android/gpuimage/Rotation.java
index 9e3cd995..bd2e840e 100644
--- a/library/src/jp/co/cyberagent/android/gpuimage/Rotation.java
+++ b/library/src/jp/co/cyberagent/android/gpuimage/Rotation.java
@@ -17,5 +17,38 @@
 package jp.co.cyberagent.android.gpuimage;
 
 public enum Rotation {
-    NORMAL, ROTATION_90, ROTATION_180, ROTATION_270
+    NORMAL, ROTATION_90, ROTATION_180, ROTATION_270;
+
+    /**
+     * Retrieves the int representation of the Rotation.
+     *
+     * @return 0, 90, 180 or 270
+     */
+    public int asInt() {
+        switch (this) {
+            case NORMAL: return 0;
+            case ROTATION_90: return 90;
+            case ROTATION_180: return 180;
+            case ROTATION_270: return 270;
+            default: throw new IllegalStateException("Unknown Rotation!");
+        }
+    }
+
+    /**
+     * Create a Rotation from an integer. Needs to be either 0, 90, 180 or 270.
+     *
+     * @param rotation 0, 90, 180 or 270
+     * @return Rotation object
+     */
+    public static Rotation fromInt(int rotation) {
+        switch (rotation) {
+            case 0: return NORMAL;
+            case 90: return ROTATION_90;
+            case 180: return ROTATION_180;
+            case 270: return ROTATION_270;
+            case 360: return NORMAL;
+            default: throw new IllegalStateException(
+                    rotation + " is an unknown rotation. Needs to be either 0, 90, 180 or 270!");
+        }
+    }
 }
diff --git a/pom.xml b/pom.xml
deleted file mode 100644
index ad44c478..00000000
--- a/pom.xml
+++ /dev/null
@@ -1,96 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
-  <modelVersion>4.0.0</modelVersion>
-
-  <parent>
-    <groupId>org.sonatype.oss</groupId>
-    <artifactId>oss-parent</artifactId>
-    <version>7</version>
-  </parent>
-
-  <groupId>jp.co.cyberagent.android.gpuimage</groupId>
-  <artifactId>gpuimage-parent</artifactId>
-  <version>1.1.1</version>
-  <packaging>pom</packaging>
-  <name>GPUImage for Android</name>
-  <description>Image filters for Android with OpenGL (based on GPUImage for iOS)</description>
-  <url>https://github.com/cyberagent/android-gpuimage/</url>
-
-  <modules>
-    <module>library</module>
-    <module>sample</module>
-  </modules>
-
-  <scm>
-    <url>git@github.com:CyberAgent/android-gpuimage.git</url>
-    <connection>scm:git:git@github.com:CyberAgent/android-gpuimage.git</connection>
-    <developerConnection>scm:git:git@github.com:CyberAgent/android-gpuimage.git</developerConnection>
-    <tag>v1.1.1</tag>
-  </scm>
-  <developers>
-    <developer>
-      <name>Patrick Boos</name>
-      <email>patrickboos85@gmail.com</email>
-      <id>pboos</id>
-      <url>http://pboos.ch</url>
-      <timezone>+9</timezone>
-      <roles>
-        <role>developer</role>
-      </roles>
-    </developer>
-  </developers>
-  <licenses>
-    <license>
-      <name>Apache License Version 2.0</name>
-      <url>http://www.apache.org/licenses/LICENSE-2.0.txt</url>
-      <distribution>repo</distribution>
-    </license>
-  </licenses>
-
-  <properties>
-    <!-- build settings -->
-    <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
-    <project.reporting.outputEncoding>UTF-8</project.reporting.outputEncoding>
-    <java.version>1.6</java.version>
-    <android.version>4.1.1.4</android.version>
-    <android.platform>16</android.platform>
-    <android-maven.version>3.5.0</android-maven.version>
-  </properties>
-
-  <build>
-    <pluginManagement>
-      <plugins>
-        <!-- compiler settings -->
-        <plugin>
-          <groupId>org.apache.maven.plugins</groupId>
-          <artifactId>maven-compiler-plugin</artifactId>
-          <version>2.3.2</version>
-        </plugin>
-        <plugin>
-          <groupId>org.apache.maven.plugins</groupId>
-          <artifactId>maven-release-plugin</artifactId>
-          <version>2.3.2</version>
-          <configuration>
-            <tagNameFormat>v@{project.version}</tagNameFormat>
-          </configuration>
-        </plugin>
-        <plugin>
-          <groupId>com.jayway.maven.plugins.android.generation2</groupId>
-          <artifactId>android-maven-plugin</artifactId>
-          <version>${android-maven.version}</version>
-          <configuration>
-            <sdk>
-              <platform>${android.platform}</platform>
-            </sdk>
-            <undeployBeforeDeploy>true</undeployBeforeDeploy>
-            <source>${sourceCompatibility}</source>
-            <target>${sourceCompatibility}</target>
-          </configuration>
-          <extensions>true</extensions>
-        </plugin>
-      </plugins>
-    </pluginManagement>
-    <sourceDirectory>src</sourceDirectory>
-  </build>
-
-</project>
diff --git a/release.sh b/release.sh
deleted file mode 100755
index db1e2f22..00000000
--- a/release.sh
+++ /dev/null
@@ -1,31 +0,0 @@
-#!/bin/bash
-if [ -z "$1" ]
-then
-  echo "Usage: sh release.sh 1.0"
-  exit 0
-fi
-VERSION=$1
-echo "New version is: $VERSION"
-
-# Write version into VERSION file
-echo $VERSION > VERSION
-
-#################
-# Android Related
-#################
-
-# Replace version in AndroidManifest.xml
-function updateManifest {
-  perl -pi -e 's#(android:versionCode=")([0-9]+)(")#"$1" . ($2 + 1) . "$3"#e;' $1
-  perl -pi -e "s/android:versionName=\"(.*)\"/android:versionName=\"$VERSION\"/g" $1
-}
-updateManifest "sample/AndroidManifest.xml"
-updateManifest "library/AndroidManifest.xml"
-
-echo ""
-echo "# Now run:"
-echo ""
-echo git commit -a -m \"Update version to v$VERSION\"
-echo mvn release:clean
-echo mvn release:prepare
-echo mvn release:perform
\ No newline at end of file
diff --git a/sample/.classpath b/sample/.classpath
deleted file mode 100644
index a4763d1e..00000000
--- a/sample/.classpath
+++ /dev/null
@@ -1,8 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<classpath>
-	<classpathentry kind="src" path="src"/>
-	<classpathentry kind="src" path="gen"/>
-	<classpathentry kind="con" path="com.android.ide.eclipse.adt.ANDROID_FRAMEWORK"/>
-	<classpathentry kind="con" path="com.android.ide.eclipse.adt.LIBRARIES"/>
-	<classpathentry kind="output" path="bin/classes"/>
-</classpath>
diff --git a/sample/.gitignore b/sample/.gitignore
deleted file mode 100644
index 85e23b43..00000000
--- a/sample/.gitignore
+++ /dev/null
@@ -1,32 +0,0 @@
-#Android generated
-bin
-gen
-obj
-
-#Eclipse
-#.project
-#.classpath
-.settings
-
-#IntelliJ IDEA
-.idea
-*.iml
-*.ipr
-*.iws
-out
-
-#Checkstyle
-.checkstyle
-
-#Maven
-target
-release.properties
-pom.xml.*
-
-#Ant
-build.xml
-local.properties
-proguard.cfg
-
-#OSX
-.DS_Store
diff --git a/sample/.project b/sample/.project
deleted file mode 100644
index 60a19f03..00000000
--- a/sample/.project
+++ /dev/null
@@ -1,33 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<projectDescription>
-	<name>gpuimage-sample</name>
-	<comment></comment>
-	<projects>
-	</projects>
-	<buildSpec>
-		<buildCommand>
-			<name>com.android.ide.eclipse.adt.ResourceManagerBuilder</name>
-			<arguments>
-			</arguments>
-		</buildCommand>
-		<buildCommand>
-			<name>com.android.ide.eclipse.adt.PreCompilerBuilder</name>
-			<arguments>
-			</arguments>
-		</buildCommand>
-		<buildCommand>
-			<name>org.eclipse.jdt.core.javabuilder</name>
-			<arguments>
-			</arguments>
-		</buildCommand>
-		<buildCommand>
-			<name>com.android.ide.eclipse.adt.ApkBuilder</name>
-			<arguments>
-			</arguments>
-		</buildCommand>
-	</buildSpec>
-	<natures>
-		<nature>com.android.ide.eclipse.adt.AndroidNature</nature>
-		<nature>org.eclipse.jdt.core.javanature</nature>
-	</natures>
-</projectDescription>
diff --git a/sample/AndroidManifest.xml b/sample/AndroidManifest.xml
index dfd98f0e..855b72c5 100644
--- a/sample/AndroidManifest.xml
+++ b/sample/AndroidManifest.xml
@@ -1,11 +1,5 @@
 <manifest xmlns:android="http://schemas.android.com/apk/res/android"
-    package="jp.co.cyberagent.android.gpuimage.sample"
-    android:versionCode="4"
-    android:versionName="1.0.3" >
-
-    <uses-sdk
-        android:minSdkVersion="8"
-        android:targetSdkVersion="15" />
+    package="jp.co.cyberagent.android.gpuimage.sample">
 
     <uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE" />
     <uses-permission android:name="android.permission.CAMERA" />
@@ -14,8 +8,10 @@
     <uses-permission android:name="android.permission.INTERNET" />
 
     <application
+        android:allowBackup="true"
         android:hardwareAccelerated="true"
         android:icon="@drawable/ic_launcher"
+        android:largeHeap="true"
         android:label="@string/app_name"
         android:theme="@style/AppTheme" >
         <activity
diff --git a/sample/build.gradle b/sample/build.gradle
new file mode 100644
index 00000000..f64f4a42
--- /dev/null
+++ b/sample/build.gradle
@@ -0,0 +1,39 @@
+apply plugin: 'com.android.application'
+
+android {
+    compileSdkVersion COMPILE_SDK_VERSION as int
+    buildToolsVersion BUILD_TOOLS_VERSION
+
+    defaultConfig {
+        minSdkVersion MIN_SDK_VERSION as int
+        targetSdkVersion TARGET_SDK_VERSION as int
+    }
+
+    sourceSets {
+        main {
+            manifest.srcFile 'AndroidManifest.xml'
+            java.srcDirs = ['src']
+            resources.srcDirs = ['src']
+            aidl.srcDirs = ['src']
+            renderscript.srcDirs = ['src']
+            res.srcDirs = ['res']
+            assets.srcDirs = ['assets']
+        }
+
+        instrumentTest.setRoot('tests')
+    }
+
+    lintOptions {
+        abortOnError true
+    }
+}
+repositories {
+    jcenter()
+    maven { url "https://oss.sonatype.org/content/repositories/snapshots/" }
+}
+
+dependencies {
+    compile project(':library')
+//    compile 'jp.co.cyberagent.android.gpuimage:gpuimage-library:1.4.1'
+    compile 'com.android.support:support-v4:23.1.1'
+}
\ No newline at end of file
diff --git a/sample/libs/android-support-v4.jar b/sample/libs/android-support-v4.jar
deleted file mode 100644
index feaf44f8..00000000
Binary files a/sample/libs/android-support-v4.jar and /dev/null differ
diff --git a/sample/pom.xml b/sample/pom.xml
deleted file mode 100644
index 37d7a7f3..00000000
--- a/sample/pom.xml
+++ /dev/null
@@ -1,53 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
-  <modelVersion>4.0.0</modelVersion>
-
-  <groupId>jp.co.cyberagent.android.gpuimage</groupId>
-  <artifactId>gpuimage-sample</artifactId>
-  <packaging>apk</packaging>
-  <name>GPUImage Sample</name>
-
-  <parent>
-    <groupId>jp.co.cyberagent.android.gpuimage</groupId>
-    <artifactId>gpuimage-parent</artifactId>
-    <version>1.1.1</version>
-  </parent>
-
-  <dependencies>
-    <dependency>
-      <groupId>com.google.android</groupId>
-      <artifactId>android</artifactId>
-      <version>${android.version}</version>
-      <scope>provided</scope>
-    </dependency>
-
-    <dependency>
-      <groupId>${project.groupId}</groupId>
-      <artifactId>gpuimage-library</artifactId>
-      <type>apklib</type>
-      <version>${project.version}</version>
-    </dependency>
-  </dependencies>
-
-  <build>
-    <plugins>
-      <plugin>
-        <groupId>com.jayway.maven.plugins.android.generation2</groupId>
-        <artifactId>android-maven-plugin</artifactId>
-
-        <configuration>
-          <proguard>
-            <skip>true</skip>
-          </proguard>
-        </configuration>
-      </plugin>
-      <plugin>
-        <groupId>org.apache.maven.plugins</groupId>
-        <artifactId>maven-javadoc-plugin</artifactId>
-        <configuration>
-          <skip>true</skip>
-        </configuration>
-      </plugin>
-    </plugins>
-  </build>
-</project>
diff --git a/sample/res/values-v11/styles.xml b/sample/res/values-v11/styles.xml
index 67bb58a1..d408cbc3 100644
--- a/sample/res/values-v11/styles.xml
+++ b/sample/res/values-v11/styles.xml
@@ -1,6 +1,5 @@
 <resources>
 
     <style name="AppTheme" parent="android:Theme.Holo.Light" />
-    <style name="AppTheme.Fullscreen" parent="android:Theme.Holo.Light.NoActionBar.Fullscreen" />
 
 </resources>
\ No newline at end of file
diff --git a/sample/res/values-v14/styles.xml b/sample/res/values-v14/styles.xml
index 1c089a78..b76ce151 100644
--- a/sample/res/values-v14/styles.xml
+++ b/sample/res/values-v14/styles.xml
@@ -1,5 +1,6 @@
 <resources>
 
     <style name="AppTheme" parent="android:Theme.Holo.Light.DarkActionBar" />
+    <style name="AppTheme.Fullscreen" parent="android:Theme.Holo.Light.NoActionBar.Fullscreen" />
 
 </resources>
\ No newline at end of file
diff --git a/sample/src/jp/co/cyberagent/android/gpuimage/sample/GPUImageFilterTools.java b/sample/src/jp/co/cyberagent/android/gpuimage/sample/GPUImageFilterTools.java
index be9bb178..6f2f6dd4 100644
--- a/sample/src/jp/co/cyberagent/android/gpuimage/sample/GPUImageFilterTools.java
+++ b/sample/src/jp/co/cyberagent/android/gpuimage/sample/GPUImageFilterTools.java
@@ -16,17 +16,19 @@
 
 package jp.co.cyberagent.android.gpuimage.sample;
 
-import java.util.LinkedList;
-import java.util.List;
-
-import jp.co.cyberagent.android.gpuimage.*;
 import android.app.AlertDialog;
 import android.content.Context;
 import android.content.DialogInterface;
 import android.graphics.BitmapFactory;
 import android.graphics.PointF;
+import android.opengl.Matrix;
+
+import jp.co.cyberagent.android.gpuimage.*;
 
-public class GPUImageFilterTools {  
+import java.util.LinkedList;
+import java.util.List;
+
+public class GPUImageFilterTools {
     public static void showDialog(final Context context,
             final OnGpuImageFilterChosenListener listener) {
         final FilterList filters = new FilterList();
@@ -80,6 +82,37 @@ public static void showDialog(final Context context,
         filters.addFilter("Blend (Normal)", FilterType.BLEND_NORMAL);
 
         filters.addFilter("Lookup (Amatorka)", FilterType.LOOKUP_AMATORKA);
+        filters.addFilter("Gaussian Blur", FilterType.GAUSSIAN_BLUR);
+        filters.addFilter("Crosshatch", FilterType.CROSSHATCH);
+
+        filters.addFilter("Box Blur", FilterType.BOX_BLUR);
+        filters.addFilter("CGA Color Space", FilterType.CGA_COLORSPACE);
+        filters.addFilter("Dilation", FilterType.DILATION);
+        filters.addFilter("Kuwahara", FilterType.KUWAHARA);
+        filters.addFilter("RGB Dilation", FilterType.RGB_DILATION);
+        filters.addFilter("Sketch", FilterType.SKETCH);
+        filters.addFilter("Toon", FilterType.TOON);
+        filters.addFilter("Smooth Toon", FilterType.SMOOTH_TOON);
+        filters.addFilter("Halftone", FilterType.HALFTONE);
+
+        filters.addFilter("Bulge Distortion", FilterType.BULGE_DISTORTION);
+        filters.addFilter("Glass Sphere", FilterType.GLASS_SPHERE);
+        filters.addFilter("Haze", FilterType.HAZE);
+        filters.addFilter("Laplacian", FilterType.LAPLACIAN);
+        filters.addFilter("Non Maximum Suppression", FilterType.NON_MAXIMUM_SUPPRESSION);
+        filters.addFilter("Sphere Refraction", FilterType.SPHERE_REFRACTION);
+        filters.addFilter("Swirl", FilterType.SWIRL);
+        filters.addFilter("Weak Pixel Inclusion", FilterType.WEAK_PIXEL_INCLUSION);
+        filters.addFilter("False Color", FilterType.FALSE_COLOR);
+
+        filters.addFilter("Color Balance", FilterType.COLOR_BALANCE);
+
+        filters.addFilter("Levels Min (Mid Adjust)", FilterType.LEVELS_FILTER_MIN);
+
+        filters. addFilter("Bilateral Blur", FilterType.BILATERAL_BLUR);
+
+        filters.addFilter("Transform (2-D)", FilterType.TRANSFORM2D);
+
 
         AlertDialog.Builder builder = new AlertDialog.Builder(context);
         builder.setTitle("Choose a filter");
@@ -145,11 +178,11 @@ private static GPUImageFilter createFilterForType(final Context context, final F
             case MONOCHROME:
             	return new GPUImageMonochromeFilter(1.0f, new float[]{0.6f, 0.45f, 0.3f, 1.0f});
             case OPACITY:
-                return new GPUImageOpacityFilter(1.0f);  
+                return new GPUImageOpacityFilter(1.0f);
             case RGB:
-                return new GPUImageRGBFilter(1.0f, 1.0f, 1.0f);  
+                return new GPUImageRGBFilter(1.0f, 1.0f, 1.0f);
             case WHITE_BALANCE:
-                return new GPUImageWhiteBalanceFilter(5000.0f, 0.0f);    
+                return new GPUImageWhiteBalanceFilter(5000.0f, 0.0f);
             case VIGNETTE:
                 PointF centerPoint = new PointF();
                 centerPoint.x = 0.5f;
@@ -215,6 +248,61 @@ private static GPUImageFilter createFilterForType(final Context context, final F
                 GPUImageLookupFilter amatorka = new GPUImageLookupFilter();
                 amatorka.setBitmap(BitmapFactory.decodeResource(context.getResources(), R.drawable.lookup_amatorka));
                 return amatorka;
+            case GAUSSIAN_BLUR:
+                return new GPUImageGaussianBlurFilter();
+            case CROSSHATCH:
+                return new GPUImageCrosshatchFilter();
+
+            case BOX_BLUR:
+                return new GPUImageBoxBlurFilter();
+            case CGA_COLORSPACE:
+                return new GPUImageCGAColorspaceFilter();
+            case DILATION:
+                return new GPUImageDilationFilter();
+            case KUWAHARA:
+                return new GPUImageKuwaharaFilter();
+            case RGB_DILATION:
+                return new GPUImageRGBDilationFilter();
+            case SKETCH:
+                return new GPUImageSketchFilter();
+            case TOON:
+                return new GPUImageToonFilter();
+            case SMOOTH_TOON:
+                return new GPUImageSmoothToonFilter();
+
+            case BULGE_DISTORTION:
+                return new GPUImageBulgeDistortionFilter();
+            case GLASS_SPHERE:
+                return new GPUImageGlassSphereFilter();
+            case HAZE:
+                return new GPUImageHazeFilter();
+            case LAPLACIAN:
+                return new GPUImageLaplacianFilter();
+            case NON_MAXIMUM_SUPPRESSION:
+                return new GPUImageNonMaximumSuppressionFilter();
+            case SPHERE_REFRACTION:
+                return new GPUImageSphereRefractionFilter();
+            case SWIRL:
+                return new GPUImageSwirlFilter();
+            case WEAK_PIXEL_INCLUSION:
+                return new GPUImageWeakPixelInclusionFilter();
+            case FALSE_COLOR:
+                return new GPUImageFalseColorFilter();
+            case COLOR_BALANCE:
+                return new GPUImageColorBalanceFilter();
+            case LEVELS_FILTER_MIN:
+                GPUImageLevelsFilter levelsFilter = new GPUImageLevelsFilter();
+                levelsFilter.setMin(0.0f, 3.0f, 1.0f);
+                return levelsFilter;
+            case HALFTONE:
+                return new GPUImageHalftoneFilter();
+
+            case BILATERAL_BLUR:
+                return new GPUImageBilateralFilter();
+
+            case TRANSFORM2D:
+                return new GPUImageTransformFilter();
+
             default:
                 throw new IllegalStateException("No filter of that type!");
         }
@@ -240,7 +328,9 @@ private static GPUImageFilter createBlendFilter(Context context, Class<? extends
         CONTRAST, GRAYSCALE, SHARPEN, SEPIA, SOBEL_EDGE_DETECTION, THREE_X_THREE_CONVOLUTION, FILTER_GROUP, EMBOSS, POSTERIZE, GAMMA, BRIGHTNESS, INVERT, HUE, PIXELATION,
         SATURATION, EXPOSURE, HIGHLIGHT_SHADOW, MONOCHROME, OPACITY, RGB, WHITE_BALANCE, VIGNETTE, TONE_CURVE, BLEND_COLOR_BURN, BLEND_COLOR_DODGE, BLEND_DARKEN, BLEND_DIFFERENCE,
         BLEND_DISSOLVE, BLEND_EXCLUSION, BLEND_SOURCE_OVER, BLEND_HARD_LIGHT, BLEND_LIGHTEN, BLEND_ADD, BLEND_DIVIDE, BLEND_MULTIPLY, BLEND_OVERLAY, BLEND_SCREEN, BLEND_ALPHA,
-        BLEND_COLOR, BLEND_HUE, BLEND_SATURATION, BLEND_LUMINOSITY, BLEND_LINEAR_BURN, BLEND_SOFT_LIGHT, BLEND_SUBTRACT, BLEND_CHROMA_KEY, BLEND_NORMAL, LOOKUP_AMATORKA
+        BLEND_COLOR, BLEND_HUE, BLEND_SATURATION, BLEND_LUMINOSITY, BLEND_LINEAR_BURN, BLEND_SOFT_LIGHT, BLEND_SUBTRACT, BLEND_CHROMA_KEY, BLEND_NORMAL, LOOKUP_AMATORKA,
+        GAUSSIAN_BLUR, CROSSHATCH, BOX_BLUR, CGA_COLORSPACE, DILATION, KUWAHARA, RGB_DILATION, SKETCH, TOON, SMOOTH_TOON, BULGE_DISTORTION, GLASS_SPHERE, HAZE, LAPLACIAN, NON_MAXIMUM_SUPPRESSION,
+        SPHERE_REFRACTION, SWIRL, WEAK_PIXEL_INCLUSION, FALSE_COLOR, COLOR_BALANCE, LEVELS_FILTER_MIN, BILATERAL_BLUR, HALFTONE, TRANSFORM2D
     }
 
     private static class FilterList {
@@ -269,10 +359,10 @@ public FilterAdjuster(final GPUImageFilter filter) {
                 adjuster = new BrightnessAdjuster().filter(filter);
             } else if (filter instanceof GPUImageSobelEdgeDetection) {
                 adjuster = new SobelAdjuster().filter(filter);
-            } else if (filter instanceof GPUImage3x3TextureSamplingFilter) {
-                adjuster = new GPU3x3TextureAdjuster().filter(filter);
             } else if (filter instanceof GPUImageEmbossFilter) {
                 adjuster = new EmbossAdjuster().filter(filter);
+            } else if (filter instanceof GPUImage3x3TextureSamplingFilter) {
+                adjuster = new GPU3x3TextureAdjuster().filter(filter);
             } else if (filter instanceof GPUImageHueFilter) {
                 adjuster = new HueAdjuster().filter(filter);
             } else if (filter instanceof GPUImagePosterizeFilter) {
@@ -297,11 +387,39 @@ public FilterAdjuster(final GPUImageFilter filter) {
                 adjuster = new VignetteAdjuster().filter(filter);
             } else if (filter instanceof GPUImageDissolveBlendFilter) {
                 adjuster = new DissolveBlendAdjuster().filter(filter);
-            } else {
+            } else if (filter instanceof GPUImageGaussianBlurFilter) {
+                adjuster = new GaussianBlurAdjuster().filter(filter);
+            } else if (filter instanceof GPUImageCrosshatchFilter) {
+                adjuster = new CrosshatchBlurAdjuster().filter(filter);
+            } else if (filter instanceof GPUImageBulgeDistortionFilter) {
+                adjuster = new BulgeDistortionAdjuster().filter(filter);
+            } else if (filter instanceof GPUImageGlassSphereFilter) {
+                adjuster = new GlassSphereAdjuster().filter(filter);
+            } else if (filter instanceof GPUImageHazeFilter) {
+                adjuster = new HazeAdjuster().filter(filter);
+            } else if (filter instanceof GPUImageSphereRefractionFilter) {
+                adjuster = new SphereRefractionAdjuster().filter(filter);
+            } else if (filter instanceof GPUImageSwirlFilter) {
+                adjuster = new SwirlAdjuster().filter(filter);
+            } else if (filter instanceof GPUImageColorBalanceFilter) {
+                adjuster = new ColorBalanceAdjuster().filter(filter);
+            } else if (filter instanceof GPUImageLevelsFilter) {
+                adjuster = new LevelsMinMidAdjuster().filter(filter);
+            } else if (filter instanceof GPUImageBilateralFilter) {
+                adjuster = new BilateralAdjuster().filter(filter);
+            } else if (filter instanceof GPUImageTransformFilter) {
+                adjuster = new RotateAdjuster().filter(filter);
+            }
+            else {
+
                 adjuster = null;
             }
         }
 
+        public boolean canAdjust() {
+            return adjuster != null;
+        }
+
         public void adjust(final int percentage) {
             if (adjuster != null) {
                 adjuster.adjust(percentage);
@@ -416,14 +534,14 @@ public void adjust(final int percentage) {
                 getFilter().setSaturation(range(percentage, 0.0f, 2.0f));
             }
         }
-        
+
         private class ExposureAdjuster extends Adjuster<GPUImageExposureFilter> {
             @Override
             public void adjust(final int percentage) {
                 getFilter().setExposure(range(percentage, -10.0f, 10.0f));
             }
-        }   
-        
+        }
+
         private class HighlightShadowAdjuster extends Adjuster<GPUImageHighlightShadowFilter> {
             @Override
             public void adjust(final int percentage) {
@@ -431,7 +549,7 @@ public void adjust(final int percentage) {
                 getFilter().setHighlights(range(percentage, 0.0f, 1.0f));
             }
         }
-        
+
         private class MonochromeAdjuster extends Adjuster<GPUImageMonochromeFilter> {
             @Override
             public void adjust(final int percentage) {
@@ -439,14 +557,14 @@ public void adjust(final int percentage) {
                 //getFilter().setColor(new float[]{0.6f, 0.45f, 0.3f, 1.0f});
             }
         }
-        
+
         private class OpacityAdjuster extends Adjuster<GPUImageOpacityFilter> {
             @Override
             public void adjust(final int percentage) {
                 getFilter().setOpacity(range(percentage, 0.0f, 1.0f));
             }
-        }   
-        
+        }
+
         private class RGBAdjuster extends Adjuster<GPUImageRGBFilter> {
             @Override
             public void adjust(final int percentage) {
@@ -454,8 +572,8 @@ public void adjust(final int percentage) {
                 //getFilter().setGreen(range(percentage, 0.0f, 1.0f));
                 //getFilter().setBlue(range(percentage, 0.0f, 1.0f));
             }
-        }   
-        
+        }
+
         private class WhiteBalanceAdjuster extends Adjuster<GPUImageWhiteBalanceFilter> {
             @Override
             public void adjust(final int percentage) {
@@ -477,5 +595,92 @@ public void adjust(final int percentage) {
                 getFilter().setMix(range(percentage, 0.0f, 1.0f));
             }
         }
+
+        private class GaussianBlurAdjuster extends Adjuster<GPUImageGaussianBlurFilter> {
+            @Override
+            public void adjust(final int percentage) {
+                getFilter().setBlurSize(range(percentage, 0.0f, 1.0f));
+            }
+        }
+
+        private class CrosshatchBlurAdjuster extends Adjuster<GPUImageCrosshatchFilter> {
+            @Override
+            public void adjust(final int percentage) {
+                getFilter().setCrossHatchSpacing(range(percentage, 0.0f, 0.06f));
+                getFilter().setLineWidth(range(percentage, 0.0f, 0.006f));
+            }
+        }
+
+        private class BulgeDistortionAdjuster extends Adjuster<GPUImageBulgeDistortionFilter> {
+            @Override
+            public void adjust(final int percentage) {
+                getFilter().setRadius(range(percentage, 0.0f, 1.0f));
+                getFilter().setScale(range(percentage, -1.0f, 1.0f));
+            }
+        }
+
+        private class GlassSphereAdjuster extends Adjuster<GPUImageGlassSphereFilter> {
+            @Override
+            public void adjust(final int percentage) {
+                getFilter().setRadius(range(percentage, 0.0f, 1.0f));
+            }
+        }
+
+        private class HazeAdjuster extends Adjuster<GPUImageHazeFilter> {
+            @Override
+            public void adjust(final int percentage) {
+                getFilter().setDistance(range(percentage, -0.3f, 0.3f));
+                getFilter().setSlope(range(percentage, -0.3f, 0.3f));
+            }
+        }
+
+        private class SphereRefractionAdjuster extends Adjuster<GPUImageSphereRefractionFilter> {
+            @Override
+            public void adjust(final int percentage) {
+                getFilter().setRadius(range(percentage, 0.0f, 1.0f));
+            }
+        }
+
+        private class SwirlAdjuster extends Adjuster<GPUImageSwirlFilter> {
+            @Override
+            public void adjust(final int percentage) {
+                getFilter().setAngle(range(percentage, 0.0f, 2.0f));
+            }
+        }
+
+        private class ColorBalanceAdjuster extends Adjuster<GPUImageColorBalanceFilter> {
+
+            @Override
+            public void adjust(int percentage) {
+                getFilter().setMidtones(new float[]{
+                        range(percentage, 0.0f, 1.0f),
+                        range(percentage / 2, 0.0f, 1.0f),
+                        range(percentage / 3, 0.0f, 1.0f)});
+            }
+        }
+
+        private class LevelsMinMidAdjuster extends Adjuster<GPUImageLevelsFilter> {
+            @Override
+            public void adjust(int percentage) {
+                getFilter().setMin(0.0f, range(percentage, 0.0f, 1.0f), 1.0f);
+            }
+        }
+
+        private class BilateralAdjuster extends Adjuster<GPUImageBilateralFilter> {
+            @Override
+            public void adjust(final int percentage) {
+                getFilter().setDistanceNormalizationFactor(range(percentage, 0.0f, 15.0f));
+            }
+        }
+
+        private class RotateAdjuster extends Adjuster<GPUImageTransformFilter> {
+            @Override
+            public void adjust(final int percentage) {
+                float[] transform = new float[16];
+                Matrix.setRotateM(transform, 0, 360 * percentage / 100, 0, 0, 1.0f);
+                getFilter().setTransform3D(transform);
+            }
+        }
+
     }
 }
diff --git a/sample/src/jp/co/cyberagent/android/gpuimage/sample/activity/ActivityCamera.java b/sample/src/jp/co/cyberagent/android/gpuimage/sample/activity/ActivityCamera.java
index 9b99e7bc..ba832284 100644
--- a/sample/src/jp/co/cyberagent/android/gpuimage/sample/activity/ActivityCamera.java
+++ b/sample/src/jp/co/cyberagent/android/gpuimage/sample/activity/ActivityCamera.java
@@ -16,6 +16,22 @@
 
 package jp.co.cyberagent.android.gpuimage.sample.activity;
 
+import android.app.Activity;
+import android.graphics.Bitmap;
+import android.graphics.BitmapFactory;
+import android.hardware.Camera;
+import android.hardware.Camera.CameraInfo;
+import android.hardware.Camera.Parameters;
+import android.net.Uri;
+import android.opengl.GLSurfaceView;
+import android.os.Bundle;
+import android.os.Environment;
+import android.util.Log;
+import android.view.View;
+import android.view.View.OnClickListener;
+import android.widget.SeekBar;
+import android.widget.SeekBar.OnSeekBarChangeListener;
+
 import java.io.File;
 import java.io.FileNotFoundException;
 import java.io.FileOutputStream;
@@ -32,24 +48,8 @@
 import jp.co.cyberagent.android.gpuimage.sample.R;
 import jp.co.cyberagent.android.gpuimage.sample.utils.CameraHelper;
 import jp.co.cyberagent.android.gpuimage.sample.utils.CameraHelper.CameraInfo2;
-import android.app.Activity;
-import android.graphics.Bitmap;
-import android.graphics.BitmapFactory;
-import android.hardware.Camera;
-import android.hardware.Camera.CameraInfo;
-import android.hardware.Camera.Parameters;
-import android.net.Uri;
-import android.opengl.GLSurfaceView;
-import android.os.Bundle;
-import android.os.Environment;
-import android.util.Log;
-import android.view.View;
-import android.view.View.OnClickListener;
-import android.widget.SeekBar;
-import android.widget.SeekBar.OnSeekBarChangeListener;
 
-public class ActivityCamera extends Activity implements OnSeekBarChangeListener,
-        OnClickListener {
+public class ActivityCamera extends Activity implements OnSeekBarChangeListener, OnClickListener {
 
     private GPUImage mGPUImage;
     private CameraHelper mCameraHelper;
@@ -105,7 +105,7 @@ public void onGpuImageFilterChosenListener(final GPUImageFilter filter) {
 
             case R.id.button_capture:
                 if (mCamera.mCameraInstance.getParameters().getFocusMode().equals(
-                        Camera.Parameters.FOCUS_MODE_CONTINUOUS_PICTURE)) {
+                        Parameters.FOCUS_MODE_CONTINUOUS_PICTURE)) {
                     takePicture();
                 } else {
                     mCamera.mCameraInstance.autoFocus(new Camera.AutoFocusCallback() {
@@ -127,12 +127,10 @@ public void onAutoFocus(final boolean success, final Camera camera) {
     private void takePicture() {
         // TODO get a size that is about the size of the screen
         Camera.Parameters params = mCamera.mCameraInstance.getParameters();
-        params.setPictureSize(1280, 960);
         params.setRotation(90);
         mCamera.mCameraInstance.setParameters(params);
-        for (Camera.Size size2 : mCamera.mCameraInstance.getParameters()
-                .getSupportedPictureSizes()) {
-            Log.i("ASDF", "Supported: " + size2.width + "x" + size2.height);
+        for (Camera.Size size : params.getSupportedPictureSizes()) {
+            Log.i("ASDF", "Supported: " + size.width + "x" + size.height);
         }
         mCamera.mCameraInstance.takePicture(null, null,
                 new Camera.PictureCallback() {
@@ -158,8 +156,7 @@ public void onPictureTaken(byte[] data, final Camera camera) {
                         }
 
                         data = null;
-                        Bitmap bitmap = BitmapFactory.decodeFile(pictureFile
-                                .getAbsolutePath());
+                        Bitmap bitmap = BitmapFactory.decodeFile(pictureFile.getAbsolutePath());
                         // mGPUImage.setImage(bitmap);
                         final GLSurfaceView view = (GLSurfaceView) findViewById(R.id.surfaceView);
                         view.setRenderMode(GLSurfaceView.RENDERMODE_WHEN_DIRTY);
@@ -225,7 +222,8 @@ private void switchFilterTo(final GPUImageFilter filter) {
     }
 
     @Override
-    public void onProgressChanged(final SeekBar seekBar, final int progress, final boolean fromUser) {
+    public void onProgressChanged(final SeekBar seekBar, final int progress,
+            final boolean fromUser) {
         if (mFilterAdjuster != null) {
             mFilterAdjuster.adjust(progress);
         }
@@ -240,6 +238,7 @@ public void onStopTrackingTouch(final SeekBar seekBar) {
     }
 
     private class CameraLoader {
+
         private int mCurrentCameraId = 0;
         private Camera mCameraInstance;
 
@@ -262,10 +261,9 @@ private void setUpCamera(final int id) {
             Parameters parameters = mCameraInstance.getParameters();
             // TODO adjust by getting supportedPreviewSizes and then choosing
             // the best one for screen size (best fill screen)
-            parameters.setPreviewSize(720, 480);
             if (parameters.getSupportedFocusModes().contains(
                     Camera.Parameters.FOCUS_MODE_CONTINUOUS_PICTURE)) {
-                parameters.setFocusMode(Camera.Parameters.FOCUS_MODE_CONTINUOUS_PICTURE);
+                parameters.setFocusMode(Parameters.FOCUS_MODE_CONTINUOUS_PICTURE);
             }
             mCameraInstance.setParameters(parameters);
 
@@ -273,8 +271,7 @@ private void setUpCamera(final int id) {
                     ActivityCamera.this, mCurrentCameraId);
             CameraInfo2 cameraInfo = new CameraInfo2();
             mCameraHelper.getCameraInfo(mCurrentCameraId, cameraInfo);
-            boolean flipHorizontal = cameraInfo.facing == CameraInfo.CAMERA_FACING_FRONT
-                    ? true : false;
+            boolean flipHorizontal = cameraInfo.facing == CameraInfo.CAMERA_FACING_FRONT;
             mGPUImage.setUpCamera(mCameraInstance, orientation, flipHorizontal, false);
         }
 
diff --git a/sample/src/jp/co/cyberagent/android/gpuimage/sample/activity/ActivityGallery.java b/sample/src/jp/co/cyberagent/android/gpuimage/sample/activity/ActivityGallery.java
index ee3f76e5..ad734823 100644
--- a/sample/src/jp/co/cyberagent/android/gpuimage/sample/activity/ActivityGallery.java
+++ b/sample/src/jp/co/cyberagent/android/gpuimage/sample/activity/ActivityGallery.java
@@ -16,10 +16,9 @@
 
 package jp.co.cyberagent.android.gpuimage.sample.activity;
 
-import jp.co.cyberagent.android.gpuimage.GPUImage;
-import jp.co.cyberagent.android.gpuimage.GPUImage.OnPictureSavedListener;
 import jp.co.cyberagent.android.gpuimage.GPUImageFilter;
 import jp.co.cyberagent.android.gpuimage.GPUImageView;
+import jp.co.cyberagent.android.gpuimage.GPUImageView.OnPictureSavedListener;
 import jp.co.cyberagent.android.gpuimage.sample.GPUImageFilterTools;
 import jp.co.cyberagent.android.gpuimage.sample.GPUImageFilterTools.FilterAdjuster;
 import jp.co.cyberagent.android.gpuimage.sample.GPUImageFilterTools.OnGpuImageFilterChosenListener;
@@ -27,7 +26,6 @@
 import android.app.Activity;
 import android.content.Intent;
 import android.net.Uri;
-import android.opengl.GLSurfaceView;
 import android.os.Bundle;
 import android.view.View;
 import android.view.View.OnClickListener;
@@ -107,6 +105,7 @@ public void onPictureSaved(final Uri uri) {
     private void saveImage() {
         String fileName = System.currentTimeMillis() + ".jpg";
         mGPUImageView.saveToPictures("GPUImage", fileName, this);
+//        mGPUImageView.saveToPictures("GPUImage", fileName, 1600, 1600, this);
     }
 
     private void switchFilterTo(final GPUImageFilter filter) {
@@ -115,6 +114,9 @@ private void switchFilterTo(final GPUImageFilter filter) {
             mFilter = filter;
             mGPUImageView.setFilter(mFilter);
             mFilterAdjuster = new FilterAdjuster(mFilter);
+
+            findViewById(R.id.seekBar).setVisibility(
+                    mFilterAdjuster.canAdjust() ? View.VISIBLE : View.GONE);
         }
     }
 
diff --git a/sample/src/jp/co/cyberagent/android/gpuimage/sample/activity/ActivityMain.java b/sample/src/jp/co/cyberagent/android/gpuimage/sample/activity/ActivityMain.java
index 0a1d7802..80600ee6 100644
--- a/sample/src/jp/co/cyberagent/android/gpuimage/sample/activity/ActivityMain.java
+++ b/sample/src/jp/co/cyberagent/android/gpuimage/sample/activity/ActivityMain.java
@@ -16,39 +16,56 @@
 
 package jp.co.cyberagent.android.gpuimage.sample.activity;
 
-import jp.co.cyberagent.android.gpuimage.sample.R;
+import android.Manifest;
 import android.app.Activity;
 import android.content.Intent;
+import android.content.pm.PackageManager;
 import android.os.Bundle;
+import android.support.v4.app.ActivityCompat;
+import android.support.v4.content.PermissionChecker;
 import android.view.View;
 import android.view.View.OnClickListener;
+import jp.co.cyberagent.android.gpuimage.sample.R;
 
 public class ActivityMain extends Activity implements OnClickListener {
 
-    @Override
-    public void onCreate(final Bundle savedInstanceState) {
+    @Override public void onCreate(final Bundle savedInstanceState) {
         super.onCreate(savedInstanceState);
         setContentView(R.layout.activity_main);
         findViewById(R.id.button_gallery).setOnClickListener(this);
         findViewById(R.id.button_camera).setOnClickListener(this);
     }
 
-    @Override
-    public void onClick(final View v) {
-        switch (v.getId()) {
+    @Override public void onClick(final View v) {
+        if (PermissionChecker.checkSelfPermission(this, Manifest.permission.CAMERA)
+            == PackageManager.PERMISSION_DENIED) {
+            ActivityCompat.requestPermissions(this, new String[] { Manifest.permission.CAMERA },
+                v.getId());
+        } else {
+            startActivity(v.getId());
+        }
+    }
+
+    @Override public void onRequestPermissionsResult(int requestCode, String[] permissions,
+        int[] grantResults) {
+        if (grantResults.length != 1 || grantResults[0] == PackageManager.PERMISSION_GRANTED) {
+            startActivity(requestCode);
+        } else {
+            super.onRequestPermissionsResult(requestCode, permissions, grantResults);
+        }
+    }
+
+    private void startActivity(int id) {
+        switch (id) {
             case R.id.button_gallery:
-                startActivity(ActivityGallery.class);
+                startActivity(new Intent(this, ActivityGallery.class));
                 break;
             case R.id.button_camera:
-                startActivity(ActivityCamera.class);
+                startActivity(new Intent(this, ActivityCamera.class));
                 break;
 
             default:
                 break;
         }
     }
-
-    private void startActivity(final Class<?> activityClass) {
-        startActivity(new Intent(this, activityClass));
-    }
 }
diff --git a/settings.gradle b/settings.gradle
new file mode 100644
index 00000000..612d9e44
--- /dev/null
+++ b/settings.gradle
@@ -0,0 +1,2 @@
+include ':library'
+include ':sample'
