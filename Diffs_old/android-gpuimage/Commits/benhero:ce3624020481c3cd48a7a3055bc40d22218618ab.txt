diff --git a/gradle.properties b/gradle.properties
index 6cb104fd..f750d136 100644
--- a/gradle.properties
+++ b/gradle.properties
@@ -5,7 +5,7 @@ GROUP=jp.co.cyberagent.android.gpuimage
 COMPILE_SDK_VERSION=23
 BUILD_TOOLS_VERSION=23.0.2
 TARGET_SDK_VERSION=23
-MIN_SDK_VERSION=8
+MIN_SDK_VERSION=18
 
 POM_DESCRIPTION=Image filters for Android with OpenGL (based on GPUImage for iOS)
 POM_URL=https://github.com/cyberagent/android-gpuimage
diff --git a/library/src/jp/co/cyberagent/android/gpuimage/GPUImage.java b/library/src/jp/co/cyberagent/android/gpuimage/GPUImage.java
index 79c58483..c0cdf6e0 100644
--- a/library/src/jp/co/cyberagent/android/gpuimage/GPUImage.java
+++ b/library/src/jp/co/cyberagent/android/gpuimage/GPUImage.java
@@ -74,6 +74,20 @@ public GPUImage(final Context context) {
         mRenderer = new GPUImageRenderer(mFilter);
     }
 
+    public GPUImage(Context context, IRenderCallback surfaceTextureCallback) {
+        if (!supportsOpenGLES2(context)) {
+            throw new IllegalStateException("OpenGL ES 2.0 is not supported on this phone.");
+        }
+
+        mContext = context;
+//        mFilter = new GPUImageOESFilter();
+        GPUImageFilterGroup gpuImageFilterGroup = new GPUImageFilterGroup();
+        mFilter = gpuImageFilterGroup;
+//        gpuImageFilterGroup.addFilter(new GPUImageBoxBlurFilter());
+        gpuImageFilterGroup.addFilter(new GPUImageOESFilter());
+        mRenderer = new GPUImageRenderer(mFilter, surfaceTextureCallback);
+    }
+
     /**
      * Checks if OpenGL ES 2.0 is supported on the current device.
      *
diff --git a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageOESFilter.java b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageOESFilter.java
new file mode 100644
index 00000000..e8c1b919
--- /dev/null
+++ b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageOESFilter.java
@@ -0,0 +1,70 @@
+package jp.co.cyberagent.android.gpuimage;
+
+import android.opengl.GLES11Ext;
+import android.opengl.GLES20;
+
+import java.nio.FloatBuffer;
+
+/**
+ * OES滤镜
+ *
+ * @author Benhero
+ */
+public class GPUImageOESFilter extends GPUImageFilter {
+    public static final String OES_FILTER_VERTEX_SHADER = "" +
+            "attribute vec4 position;\n" +
+            "attribute vec4 inputTextureCoordinate;\n" +
+            " \n" +
+            "varying vec2 textureCoordinate;\n" +
+            " \n" +
+            "void main()\n" +
+            "{\n" +
+            "    gl_Position = position;\n" +
+            "    textureCoordinate = inputTextureCoordinate.xy;\n" +
+            "}";
+    public static final String OES_FILTER_FRAGMENT_SHADER = "" +
+            "#extension GL_OES_EGL_image_external : require\n"+
+            "precision mediump float;" +
+            "varying highp vec2 textureCoordinate;\n" +
+            " \n" +
+            "uniform samplerExternalOES inputImageTexture;\n" +
+            " \n" +
+            "void main()\n" +
+            "{\n" +
+            "     gl_FragColor = texture2D(inputImageTexture, textureCoordinate);\n" +
+            "}";
+
+    public GPUImageOESFilter() {
+        super(OES_FILTER_VERTEX_SHADER, OES_FILTER_FRAGMENT_SHADER);
+    }
+
+    public void onDraw(final int textureId, final FloatBuffer cubeBuffer,
+                       final FloatBuffer textureBuffer) {
+        // 绘制前先刷一层白底
+        GLES20.glClearColor(1, 1, 1, 0);
+        GLES20.glClear(GLES20.GL_DEPTH_BUFFER_BIT | GLES20.GL_COLOR_BUFFER_BIT);
+        GLES20.glUseProgram(mGLProgId);
+        runPendingOnDrawTasks();
+        if (!isInitialized()) {
+            return;
+        }
+
+        cubeBuffer.position(0);
+        GLES20.glVertexAttribPointer(mGLAttribPosition, 2, GLES20.GL_FLOAT, false, 0, cubeBuffer);
+        GLES20.glEnableVertexAttribArray(mGLAttribPosition);
+        textureBuffer.position(0);
+        GLES20.glVertexAttribPointer(mGLAttribTextureCoordinate, 2, GLES20.GL_FLOAT, false, 0,
+                textureBuffer);
+        GLES20.glEnableVertexAttribArray(mGLAttribTextureCoordinate);
+        if (textureId != OpenGlUtils.NO_TEXTURE) {
+            GLES20.glActiveTexture(GLES20.GL_TEXTURE0);
+            GLES20.glBindTexture(GLES11Ext.GL_TEXTURE_EXTERNAL_OES, textureId);
+            GLES20.glUniform1i(mGLUniformTexture, 0);
+        }
+        onDrawArraysPre();
+        GLES20.glDrawArrays(GLES20.GL_TRIANGLE_STRIP, 0, 4);
+        GLES20.glDisableVertexAttribArray(mGLAttribPosition);
+        GLES20.glDisableVertexAttribArray(mGLAttribTextureCoordinate);
+        GLES20.glBindTexture(GLES11Ext.GL_TEXTURE_EXTERNAL_OES, 0);
+    }
+}
\ No newline at end of file
diff --git a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageRenderer.java b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageRenderer.java
index 69e8cc9b..3c82a6c1 100644
--- a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageRenderer.java
+++ b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageRenderer.java
@@ -80,9 +80,11 @@
     private boolean mFlipVertical;
     private GPUImage.ScaleType mScaleType = GPUImage.ScaleType.CENTER_CROP;
 
-    private float mBackgroundRed = 0;
-    private float mBackgroundGreen = 0;
-    private float mBackgroundBlue = 0;
+    private float mBackgroundRed = 1;
+    private float mBackgroundGreen = 1;
+    private float mBackgroundBlue = 1;
+
+    private IRenderCallback mSurfaceTextureCallback;
 
     public GPUImageRenderer(final GPUImageFilter filter) {
         mFilter = filter;
@@ -100,11 +102,33 @@ public GPUImageRenderer(final GPUImageFilter filter) {
         setRotation(Rotation.NORMAL, false, false);
     }
 
+    public GPUImageRenderer(GPUImageFilter filter, IRenderCallback surfaceTextureCallback) {
+        this(filter);
+        mSurfaceTextureCallback = surfaceTextureCallback;
+    }
+
     @Override
     public void onSurfaceCreated(final GL10 unused, final EGLConfig config) {
+        initTexture();
         GLES20.glClearColor(mBackgroundRed, mBackgroundGreen, mBackgroundBlue, 1);
         GLES20.glDisable(GLES20.GL_DEPTH_TEST);
         mFilter.init();
+        if (mSurfaceTextureCallback != null) {
+            mSurfaceTextureCallback.onSurfaceTextureCreated(mSurfaceTexture);
+        }
+    }
+
+    private void initTexture() {
+        int[] textures = new int[1];
+        GLES20.glGenTextures(1, textures, 0);
+        mGLTextureId = textures[0];
+        mSurfaceTexture = new SurfaceTexture(mGLTextureId);
+        mSurfaceTexture.setOnFrameAvailableListener(new SurfaceTexture.OnFrameAvailableListener() {
+            @Override
+            public void onFrameAvailable(SurfaceTexture surfaceTexture) {
+                mSurfaceTextureCallback.onFrameAvailable(surfaceTexture.getTimestamp());
+            }
+        });
     }
 
     @Override
@@ -124,11 +148,11 @@ public void onSurfaceChanged(final GL10 gl, final int width, final int height) {
     public void onDrawFrame(final GL10 gl) {
         GLES20.glClear(GLES20.GL_COLOR_BUFFER_BIT | GLES20.GL_DEPTH_BUFFER_BIT);
         runAll(mRunOnDraw);
-        mFilter.onDraw(mGLTextureId, mGLCubeBuffer, mGLTextureBuffer);
-        runAll(mRunOnDrawEnd);
         if (mSurfaceTexture != null) {
             mSurfaceTexture.updateTexImage();
         }
+        mFilter.onDraw(mGLTextureId, mGLCubeBuffer, mGLTextureBuffer);
+        runAll(mRunOnDrawEnd);
     }
 
     private void runAll(Queue<Runnable> queue) {
@@ -288,42 +312,28 @@ protected int getFrameHeight() {
     }
 
     private void adjustImageScaling() {
-        float outputWidth = mOutputWidth;
-        float outputHeight = mOutputHeight;
-        if (mRotation == Rotation.ROTATION_270 || mRotation == Rotation.ROTATION_90) {
-            outputWidth = mOutputHeight;
-            outputHeight = mOutputWidth;
-        }
-
-        float ratio1 = outputWidth / mImageWidth;
-        float ratio2 = outputHeight / mImageHeight;
-        float ratioMax = Math.max(ratio1, ratio2);
-        int imageWidthNew = Math.round(mImageWidth * ratioMax);
-        int imageHeightNew = Math.round(mImageHeight * ratioMax);
-
-        float ratioWidth = imageWidthNew / outputWidth;
-        float ratioHeight = imageHeightNew / outputHeight;
-        // 以上都是计算出图片缩放到容器上后，占容器的比例值，用于下面正确地绘制到容器的位置上
-
         float[] cube = CUBE;
         float[] textureCords = TextureRotationUtil.getRotation(mRotation, mFlipHorizontal, mFlipVertical);
-        if (mScaleType == GPUImage.ScaleType.CENTER_CROP) {
-            float distHorizontal = (1 - 1 / ratioWidth) / 2;
-            float distVertical = (1 - 1 / ratioHeight) / 2;
-            textureCords = new float[]{
-                    addDistance(textureCords[0], distHorizontal), addDistance(textureCords[1], distVertical),
-                    addDistance(textureCords[2], distHorizontal), addDistance(textureCords[3], distVertical),
-                    addDistance(textureCords[4], distHorizontal), addDistance(textureCords[5], distVertical),
-                    addDistance(textureCords[6], distHorizontal), addDistance(textureCords[7], distVertical),
-            };
-        } else {
-            cube = new float[]{
-                    CUBE[0] / ratioHeight, CUBE[1] / ratioWidth,
-                    CUBE[2] / ratioHeight, CUBE[3] / ratioWidth,
-                    CUBE[4] / ratioHeight, CUBE[5] / ratioWidth,
-                    CUBE[6] / ratioHeight, CUBE[7] / ratioWidth,
-            };
-        }
+
+//        if (mOutputWidth != 0 && mOutputHeight != 0) {
+//            PointF offset = VideoCropManager.getDrawOffset(mCropType, mCropRatio,
+//                    mIsRender, mSrcWidth, mSrcHeight, mOutputWidth, mOutputHeight, isHorizontalRotate(), mIsSrcRotate, mNeedSpliceRotate);
+//            if (mCropType == VideoCropType.TYPE_FULL) {
+//                cube = new float[]{
+//                        CUBE[0] - offset.x, CUBE[1] - offset.y,
+//                        CUBE[2] - offset.x, CUBE[3] - offset.y,
+//                        CUBE[4] - offset.x, CUBE[5] - offset.y,
+//                        CUBE[6] - offset.x, CUBE[7] - offset.y,
+//                };
+//            } else if (mCropType == VideoCropType.TYPE_FIT) {
+//                cube = new float[]{
+//                        CUBE[0] + offset.x, CUBE[1] + offset.y,
+//                        CUBE[2] - offset.x, CUBE[3] + offset.y,
+//                        CUBE[4] + offset.x, CUBE[5] - offset.y,
+//                        CUBE[6] - offset.x, CUBE[7] - offset.y,
+//                };
+//            }
+//        }
 
         mGLCubeBuffer.clear();
         mGLCubeBuffer.put(cube).position(0);
diff --git a/library/src/jp/co/cyberagent/android/gpuimage/IRenderCallback.java b/library/src/jp/co/cyberagent/android/gpuimage/IRenderCallback.java
new file mode 100644
index 00000000..c41488aa
--- /dev/null
+++ b/library/src/jp/co/cyberagent/android/gpuimage/IRenderCallback.java
@@ -0,0 +1,11 @@
+package jp.co.cyberagent.android.gpuimage;
+
+import android.graphics.SurfaceTexture;
+
+/**
+ * Render回调接口
+ */
+public interface IRenderCallback {
+    void onSurfaceTextureCreated(SurfaceTexture surfaceTexture);
+    void onFrameAvailable(long frameTimeNanos);
+}
diff --git a/sample/res/layout/activity_video.xml b/sample/res/layout/activity_video.xml
index 1f2c34ae..6344cf75 100644
--- a/sample/res/layout/activity_video.xml
+++ b/sample/res/layout/activity_video.xml
@@ -8,14 +8,7 @@
         android:layout_height="0dp"
         android:layout_weight="1">
 
-        <jp.co.cyberagent.android.gpuimage.GPUImageView
-            android:id="@+id/gpuimage"
-            android:layout_width="wrap_content"
-            android:layout_height="wrap_content"
-            android:layout_gravity="center"
-            android:visibility="gone"/>
-
-        <SurfaceView
+        <android.opengl.GLSurfaceView
             android:id="@+id/video_surface"
             android:layout_width="match_parent"
             android:layout_height="match_parent"
diff --git a/sample/src/jp/co/cyberagent/android/gpuimage/sample/GPUImageFilterTools.java b/sample/src/jp/co/cyberagent/android/gpuimage/sample/GPUImageFilterTools.java
index c493a044..f49494a0 100644
--- a/sample/src/jp/co/cyberagent/android/gpuimage/sample/GPUImageFilterTools.java
+++ b/sample/src/jp/co/cyberagent/android/gpuimage/sample/GPUImageFilterTools.java
@@ -20,7 +20,6 @@
 import android.graphics.BitmapFactory;
 import android.graphics.PointF;
 import android.opengl.Matrix;
-import android.widget.Toast;
 
 import java.util.LinkedList;
 import java.util.List;
@@ -192,7 +191,7 @@
 
     public static void showDialog(final Context context,
                                   final OnGpuImageFilterChosenListener listener) {
-        Toast.makeText(context, filters.names.get(index), Toast.LENGTH_SHORT).show();
+//        Toast.makeText(context, filters.names.get(index), Toast.LENGTH_SHORT).show();
         listener.onGpuImageFilterChosenListener(
                 createFilterForType(context, filters.filters.get(index)));
         index++;
diff --git a/sample/src/jp/co/cyberagent/android/gpuimage/sample/activity/ActivityVideo.java b/sample/src/jp/co/cyberagent/android/gpuimage/sample/activity/ActivityVideo.java
index 8fa55170..7858dfec 100644
--- a/sample/src/jp/co/cyberagent/android/gpuimage/sample/activity/ActivityVideo.java
+++ b/sample/src/jp/co/cyberagent/android/gpuimage/sample/activity/ActivityVideo.java
@@ -2,20 +2,27 @@
 
 import android.content.Intent;
 import android.database.Cursor;
+import android.graphics.SurfaceTexture;
 import android.media.AudioManager;
 import android.media.MediaPlayer;
 import android.net.Uri;
+import android.opengl.GLSurfaceView;
 import android.os.Bundle;
 import android.provider.MediaStore;
 import android.support.v7.app.AppCompatActivity;
+import android.view.Surface;
 import android.view.SurfaceHolder;
-import android.view.SurfaceView;
 import android.view.View;
 import android.widget.SeekBar;
 import android.widget.Toast;
 
+import jp.co.cyberagent.android.gpuimage.GPUImage;
 import jp.co.cyberagent.android.gpuimage.GPUImageFilter;
+import jp.co.cyberagent.android.gpuimage.GPUImageFilterGroup;
+import jp.co.cyberagent.android.gpuimage.GPUImageOESFilter;
+import jp.co.cyberagent.android.gpuimage.GPUImageRenderer;
 import jp.co.cyberagent.android.gpuimage.GPUImageView;
+import jp.co.cyberagent.android.gpuimage.IRenderCallback;
 import jp.co.cyberagent.android.gpuimage.sample.GPUImageFilterTools;
 import jp.co.cyberagent.android.gpuimage.sample.R;
 
@@ -30,11 +37,12 @@
     private static final int REQUEST_PICK_VIDEO = 1;
     private GPUImageFilter mFilter;
     private GPUImageFilterTools.FilterAdjuster mFilterAdjuster;
-    private GPUImageView mGPUImageView;
-    private SurfaceView mSurfaceView;
+    private GLSurfaceView mSurfaceView;
     private MediaPlayer mMediaPlayer;
     private SurfaceHolder mHolder;
     private String mPath;
+    private GPUImageRenderer mRenderer;
+    private GPUImage mGPUImage;
 
     @Override
     public void onCreate(final Bundle savedInstanceState) {
@@ -43,9 +51,7 @@ public void onCreate(final Bundle savedInstanceState) {
         ((SeekBar) findViewById(R.id.seekBar)).setOnSeekBarChangeListener(this);
         findViewById(R.id.button_choose_filter).setOnClickListener(this);
         findViewById(R.id.button_save).setOnClickListener(this);
-        mSurfaceView = (SurfaceView) findViewById(R.id.video_surface);
-
-        mGPUImageView = (GPUImageView) findViewById(R.id.gpuimage);
+        mSurfaceView = (GLSurfaceView) findViewById(R.id.video_surface);
 
         Intent photoPickerIntent = new Intent(Intent.ACTION_PICK);
         photoPickerIntent.setType("video/*");
@@ -54,47 +60,39 @@ public void onCreate(final Bundle savedInstanceState) {
 
     private void initPlayer() {
         mMediaPlayer = new MediaPlayer();
-        mHolder = mSurfaceView.getHolder();
-        mHolder.setType(SurfaceHolder.SURFACE_TYPE_PUSH_BUFFERS);
-        mHolder.addCallback(new SurfaceHolder.Callback() {
+        mGPUImage = new GPUImage(this, new IRenderCallback() {
             @Override
-            public void surfaceCreated(SurfaceHolder holder) {
-                mHolder = holder;
-                play();
-            }
-
-            @Override
-            public void surfaceChanged(SurfaceHolder holder, int format, int width, int height) {
-
+            public void onSurfaceTextureCreated(SurfaceTexture texture) {
+                try {
+                    Surface surface = new Surface(texture);
+                    mMediaPlayer.reset();
+                    mMediaPlayer.setAudioStreamType(AudioManager.STREAM_MUSIC);
+                    mMediaPlayer.setSurface(surface);
+                    mMediaPlayer.setDataSource(mPath);
+                    mMediaPlayer.prepareAsync();
+                    mMediaPlayer.setLooping(false);
+                    mMediaPlayer.setOnPreparedListener(new MediaPlayer.OnPreparedListener() {
+                        @Override
+                        public void onPrepared(MediaPlayer mp) {
+                            mMediaPlayer.seekTo(0);
+                            mMediaPlayer.start();
+                        }
+                    });
+                } catch (Exception e) {
+                    e.printStackTrace();
+                }
             }
 
             @Override
-            public void surfaceDestroyed(SurfaceHolder holder) {
-                if (mMediaPlayer != null && mMediaPlayer.isPlaying()) {
-                    mMediaPlayer.stop();
-                }
+            public void onFrameAvailable(long frameTimeNanos) {
+                mSurfaceView.requestRender();
             }
         });
+        mGPUImage.setGLSurfaceView(mSurfaceView);
     }
 
     private void play() {
-        try {
-            mMediaPlayer.reset();
-            mMediaPlayer.setDisplay(mHolder);
-            mMediaPlayer.setAudioStreamType(AudioManager.STREAM_MUSIC);
-            mMediaPlayer.setDataSource(mPath);
-            mMediaPlayer.prepareAsync();
-            mMediaPlayer.setLooping(true);
-            mMediaPlayer.setOnPreparedListener(new MediaPlayer.OnPreparedListener() {
-                @Override
-                public void onPrepared(MediaPlayer mp) {
-                    mMediaPlayer.seekTo(0);
-                    mMediaPlayer.start();
-                }
-            });
-        } catch (Exception e) {
-            e.printStackTrace();
-        }
+
     }
 
     @Override
@@ -123,7 +121,7 @@ public void onClick(final View v) {
                     @Override
                     public void onGpuImageFilterChosenListener(final GPUImageFilter filter) {
                         switchFilterTo(filter);
-                        mGPUImageView.requestRender();
+                        mGPUImage.requestRender();
                     }
 
                 });
@@ -145,15 +143,18 @@ public void onPictureSaved(final Uri uri) {
 
     private void saveImage() {
         String fileName = System.currentTimeMillis() + ".jpg";
-        mGPUImageView.saveToPictures("GPUImage", fileName, this);
+//        mGPUImageView.saveToPictures("GPUImage", fileName, this);
 //        mGPUImageView.saveToPictures("GPUImage", fileName, 1600, 1600, this);
     }
 
     private void switchFilterTo(final GPUImageFilter filter) {
         if (mFilter == null
                 || (filter != null && !mFilter.getClass().equals(filter.getClass()))) {
-            mFilter = filter;
-            mGPUImageView.setFilter(mFilter);
+            GPUImageFilterGroup gpuImageFilterGroup = new GPUImageFilterGroup();
+            mFilter = gpuImageFilterGroup;
+//            gpuImageFilterGroup.addFilter(filter);
+            gpuImageFilterGroup.addFilter(new GPUImageOESFilter());
+            mGPUImage.setFilter(mFilter);
             mFilterAdjuster = new GPUImageFilterTools.FilterAdjuster(mFilter);
 
             findViewById(R.id.seekBar).setVisibility(
@@ -166,7 +167,7 @@ public void onProgressChanged(final SeekBar seekBar, final int progress, final b
         if (mFilterAdjuster != null) {
             mFilterAdjuster.adjust(progress);
         }
-        mGPUImageView.requestRender();
+        mGPUImage.requestRender();
     }
 
     @Override
