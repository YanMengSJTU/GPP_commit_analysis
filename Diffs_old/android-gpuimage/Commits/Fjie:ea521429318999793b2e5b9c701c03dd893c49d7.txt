diff --git a/library/src/jp/co/cyberagent/android/gpuimage/core/GPUImageFilter.java b/library/src/jp/co/cyberagent/android/gpuimage/core/GPUImageFilter.java
index 9769c6a3..e99e3de6 100644
--- a/library/src/jp/co/cyberagent/android/gpuimage/core/GPUImageFilter.java
+++ b/library/src/jp/co/cyberagent/android/gpuimage/core/GPUImageFilter.java
@@ -25,7 +25,7 @@
 import java.nio.FloatBuffer;
 import java.util.LinkedList;
 
-import jp.co.cyberagent.android.gpuimage.util.OpenGlUtils;
+import jp.co.cyberagent.android.gpuimage.util.GlUtils;
 
 // TODO: 2017/9/12 滤镜基类
 public class GPUImageFilter {
@@ -79,7 +79,7 @@ public final void init() {
     }
 
     public void onInit() {// TODO: 2017/9/12 初始化主体方法，GLSL配置、传参，子类定制化配置
-        mGLProgId = OpenGlUtils.loadProgram(mVertexShader, mFragmentShader);
+        mGLProgId = GlUtils.loadProgram(mVertexShader, mFragmentShader);
         mGLAttribPosition = GLES20.glGetAttribLocation(mGLProgId, "position");
         mGLUniformTexture = GLES20.glGetUniformLocation(mGLProgId, "inputImageTexture");
         mGLAttribTextureCoordinate = GLES20.glGetAttribLocation(mGLProgId,"inputTextureCoordinate");
@@ -119,7 +119,7 @@ public void onDraw(final int textureId, final FloatBuffer cubeBuffer,
         textureBuffer.position(0);
         GLES20.glVertexAttribPointer(mGLAttribTextureCoordinate, 2, GLES20.GL_FLOAT, false, 0,textureBuffer);
         GLES20.glEnableVertexAttribArray(mGLAttribTextureCoordinate);
-        if (textureId != OpenGlUtils.NO_TEXTURE) {
+        if (textureId != GlUtils.NO_TEXTURE) {
             // TODO: 2017/9/12 应用纹理
             GLES20.glActiveTexture(GLES20.GL_TEXTURE0);
             GLES20.glBindTexture(GLES20.GL_TEXTURE_2D, textureId);
diff --git a/library/src/jp/co/cyberagent/android/gpuimage/core/GPUImageFilterGroup.java b/library/src/jp/co/cyberagent/android/gpuimage/core/GPUImageFilterGroup.java
index b8a6de3c..cdcfc8ec 100644
--- a/library/src/jp/co/cyberagent/android/gpuimage/core/GPUImageFilterGroup.java
+++ b/library/src/jp/co/cyberagent/android/gpuimage/core/GPUImageFilterGroup.java
@@ -25,6 +25,7 @@
 import java.util.ArrayList;
 import java.util.List;
 
+import jp.co.cyberagent.android.gpuimage.util.GlUtils;
 import jp.co.cyberagent.android.gpuimage.util.Rotation;
 import jp.co.cyberagent.android.gpuimage.util.TextureRotationUtil;
 
@@ -35,16 +36,17 @@
  * Resembles a filter that consists of multiple filters applied after each
  * other.
  */
+// TODO: 2017/9/12 多层滤镜，把顶点纹理等buf自己处理，关键在利用帧缓冲逐步加滤镜
 public class GPUImageFilterGroup extends GPUImageFilter {
 
-    protected List<GPUImageFilter> mFilters;
-    protected List<GPUImageFilter> mMergedFilters;
-    private int[] mFrameBuffers;
-    private int[] mFrameBufferTextures;
+    protected List<GPUImageFilter> mFilters; // TODO: 2017/9/12 滤镜列表
+    protected List<GPUImageFilter> mMergedFilters;// TODO: 2017/9/12 相当于flagMap，将滤镜树抹成列表
+    private int[] mFrameBuffers;// TODO: 2017/9/13 帧缓冲，关键
+    private int[] mFrameBufferTextures;// TODO: 2017/9/13 帧缓冲纹理们，怎么绑定的是关键
 
-    private final FloatBuffer mGLCubeBuffer;
-    private final FloatBuffer mGLTextureBuffer;
-    private final FloatBuffer mGLTextureFlipBuffer;
+    private final FloatBuffer mGLCubeBuffer; // TODO: 2017/9/13 顶点buf
+    private final FloatBuffer mGLTextureBuffer;// TODO: 2017/9/13 纹理buf
+    private final FloatBuffer mGLTextureFlipBuffer;// TODO: 2017/9/13 纹理翻转buf?
 
     /**
      * Instantiates a new GPUImageFilterGroup with no filters.
@@ -61,11 +63,12 @@ public GPUImageFilterGroup() {
     public GPUImageFilterGroup(List<GPUImageFilter> filters) {
         mFilters = filters;
         if (mFilters == null) {
-            mFilters = new ArrayList<GPUImageFilter>();
+            mFilters = new ArrayList<>();
         } else {
-            updateMergedFilters();
+            updateMergedFilters();// TODO: 2017/9/13 先合并一下？
         }
 
+        // TODO: 2017/9/13 初始化buf
         mGLCubeBuffer = ByteBuffer.allocateDirect(CUBE.length * 4)
                 .order(ByteOrder.nativeOrder())
                 .asFloatBuffer();
@@ -83,56 +86,33 @@ public GPUImageFilterGroup(List<GPUImageFilter> filters) {
         mGLTextureFlipBuffer.put(flipTexture).position(0);
     }
 
-    public void addFilter(GPUImageFilter aFilter) {
-        if (aFilter == null) {
+    // TODO: 2017/9/13 抹匀滤镜组
+    public void updateMergedFilters() {
+        if (mFilters == null) {
             return;
         }
-        mFilters.add(aFilter);
-        updateMergedFilters();
-    }
 
-    /*
-     * (non-Javadoc)
-     * @see jp.co.cyberagent.android.gpuimage.core.GPUImageFilter#onInit()
-     */
-    @Override
-    public void onInit() {
-        super.onInit();
-        for (GPUImageFilter filter : mFilters) {
-            filter.init();
+        if (mMergedFilters == null) {
+            mMergedFilters = new ArrayList<GPUImageFilter>();
+        } else {
+            mMergedFilters.clear();
         }
-    }
 
-    /*
-     * (non-Javadoc)
-     * @see jp.co.cyberagent.android.gpuimage.core.GPUImageFilter#onDestroy()
-     */
-    @Override
-    public void onDestroy() {
-        destroyFramebuffers();
+        List<GPUImageFilter> filters;
         for (GPUImageFilter filter : mFilters) {
-            filter.destroy();
+            if (filter instanceof GPUImageFilterGroup) {// TODO: 2017/9/13 滤镜组则递归
+                ((GPUImageFilterGroup) filter).updateMergedFilters();
+                filters = ((GPUImageFilterGroup) filter).getMergedFilters();
+                if (filters == null || filters.isEmpty())
+                    continue;
+                mMergedFilters.addAll(filters);
+                continue;
+            }
+            mMergedFilters.add(filter);
         }
-        super.onDestroy();
     }
 
-    private void destroyFramebuffers() {
-        if (mFrameBufferTextures != null) {
-            GLES20.glDeleteTextures(mFrameBufferTextures.length, mFrameBufferTextures, 0);
-            mFrameBufferTextures = null;
-        }
-        if (mFrameBuffers != null) {
-            GLES20.glDeleteFramebuffers(mFrameBuffers.length, mFrameBuffers, 0);
-            mFrameBuffers = null;
-        }
-    }
 
-    /*
-     * (non-Javadoc)
-     * @see
-     * jp.co.cyberagent.android.gpuimage.core.GPUImageFilter#onOutputSizeChanged(int,
-     * int)
-     */
     @Override
     public void onOutputSizeChanged(final int width, final int height) {
         super.onOutputSizeChanged(width, height);
@@ -151,37 +131,24 @@ public void onOutputSizeChanged(final int width, final int height) {
             mFrameBufferTextures = new int[size - 1];
 
             for (int i = 0; i < size - 1; i++) {
-                GLES20.glGenFramebuffers(1, mFrameBuffers, i);
-                GLES20.glGenTextures(1, mFrameBufferTextures, i);
-                GLES20.glBindTexture(GLES20.GL_TEXTURE_2D, mFrameBufferTextures[i]);
-                GLES20.glTexImage2D(GLES20.GL_TEXTURE_2D, 0, GLES20.GL_RGBA, width, height, 0,
-                        GLES20.GL_RGBA, GLES20.GL_UNSIGNED_BYTE, null);
-                GLES20.glTexParameterf(GLES20.GL_TEXTURE_2D,
-                        GLES20.GL_TEXTURE_MAG_FILTER, GLES20.GL_LINEAR);
-                GLES20.glTexParameterf(GLES20.GL_TEXTURE_2D,
-                        GLES20.GL_TEXTURE_MIN_FILTER, GLES20.GL_LINEAR);
-                GLES20.glTexParameterf(GLES20.GL_TEXTURE_2D,
-                        GLES20.GL_TEXTURE_WRAP_S, GLES20.GL_CLAMP_TO_EDGE);
-                GLES20.glTexParameterf(GLES20.GL_TEXTURE_2D,
-                        GLES20.GL_TEXTURE_WRAP_T, GLES20.GL_CLAMP_TO_EDGE);
-
-                GLES20.glBindFramebuffer(GLES20.GL_FRAMEBUFFER, mFrameBuffers[i]);
-                GLES20.glFramebufferTexture2D(GLES20.GL_FRAMEBUFFER, GLES20.GL_COLOR_ATTACHMENT0,
-                        GLES20.GL_TEXTURE_2D, mFrameBufferTextures[i], 0);
-
+                GLES20.glGenFramebuffers(1, mFrameBuffers, i);// TODO: 2017/9/13 启用帧缓冲
+                GLES20.glGenTextures(1, mFrameBufferTextures, i);// TODO: 2017/9/13 启用纹理
+                // TODO: 2017/9/13 一套操作加纹理
+                GLES20.glBindTexture(GLES20.GL_TEXTURE_2D, mFrameBufferTextures[i]);// TODO: 2017/9/13  纹理对应到下标
+                GLES20.glTexImage2D(GLES20.GL_TEXTURE_2D, 0, GLES20.GL_RGBA, width, height, 0,GLES20.GL_RGBA, GLES20.GL_UNSIGNED_BYTE, null);
+                GlUtils.glTexParameterf();
+                GLES20.glBindFramebuffer(GLES20.GL_FRAMEBUFFER, mFrameBuffers[i]);// TODO: 2017/9/13 帧缓冲对应到下标
+                GLES20.glFramebufferTexture2D(GLES20.GL_FRAMEBUFFER, GLES20.GL_COLOR_ATTACHMENT0,GLES20.GL_TEXTURE_2D, mFrameBufferTextures[i], 0);
+                // TODO: 2017/9/13 绑定
                 GLES20.glBindTexture(GLES20.GL_TEXTURE_2D, 0);
                 GLES20.glBindFramebuffer(GLES20.GL_FRAMEBUFFER, 0);
             }
         }
     }
 
-    /*
-     * (non-Javadoc)
-     * @see jp.co.cyberagent.android.gpuimage.core.GPUImageFilter#onDraw(int,
-     * java.nio.FloatBuffer, java.nio.FloatBuffer)
-     */
     @SuppressLint("WrongCall")    
     @Override
+    // TODO: 2017/9/13 复写onDraw实现多滤镜
     public void onDraw(final int textureId, final FloatBuffer cubeBuffer,
                        final FloatBuffer textureBuffer) {
         runPendingOnDrawTasks();
@@ -195,31 +162,27 @@ public void onDraw(final int textureId, final FloatBuffer cubeBuffer,
                 GPUImageFilter filter = mMergedFilters.get(i);
                 boolean isNotLast = i < size - 1;
                 if (isNotLast) {
+                    // TODO: 2017/9/13 非最后项，绑定对应帧缓冲到下标帧，清屏
                     GLES20.glBindFramebuffer(GLES20.GL_FRAMEBUFFER, mFrameBuffers[i]);
                     GLES20.glClearColor(0, 0, 0, 0);
                 }
 
-                if (i == 0) {
+                if (i == 0) {// TODO: 2017/9/13 第一层原版绘制
                     filter.onDraw(previousTexture, cubeBuffer, textureBuffer);
-                } else if (i == size - 1) {
+                } else if (i == size - 1) {// TODO: 2017/9/13 最后一层换本地顶点、本地纹理，偶数层翻转纹理绘制
                     filter.onDraw(previousTexture, mGLCubeBuffer, (size % 2 == 0) ? mGLTextureFlipBuffer : mGLTextureBuffer);
-                } else {
+                } else {// TODO: 2017/9/13  绘制本地顶点、本地纹理
                     filter.onDraw(previousTexture, mGLCubeBuffer, mGLTextureBuffer);
                 }
 
                 if (isNotLast) {
-                    GLES20.glBindFramebuffer(GLES20.GL_FRAMEBUFFER, 0);
-                    previousTexture = mFrameBufferTextures[i];
+                    GLES20.glBindFramebuffer(GLES20.GL_FRAMEBUFFER, 0);// TODO: 2017/9/13 绑定对应帧缓冲到首帧
+                    previousTexture = mFrameBufferTextures[i];// TODO: 2017/9/13 赋值下标纹理给前纹理
                 }
             }
         }
      }
 
-    /**
-     * Gets the filters.
-     *
-     * @return the filters
-     */
     public List<GPUImageFilter> getFilters() {
         return mFilters;
     }
@@ -228,28 +191,38 @@ public void onDraw(final int textureId, final FloatBuffer cubeBuffer,
         return mMergedFilters;
     }
 
-    public void updateMergedFilters() {
-        if (mFilters == null) {
-            return;
+    @Override
+    public void onInit() {
+        super.onInit();
+        for (GPUImageFilter filter : mFilters) {
+            filter.init();// TODO: 2017/9/13 滤镜排队初始化
         }
+    }
+    @Override
+    public void onDestroy() {
+        destroyFramebuffers();
+        for (GPUImageFilter filter : mFilters) {
+            filter.destroy();
+        }
+        super.onDestroy();
+    }
 
-        if (mMergedFilters == null) {
-            mMergedFilters = new ArrayList<GPUImageFilter>();
-        } else {
-            mMergedFilters.clear();
+    private void destroyFramebuffers() {
+        if (mFrameBufferTextures != null) {
+            GLES20.glDeleteTextures(mFrameBufferTextures.length, mFrameBufferTextures, 0);
+            mFrameBufferTextures = null;
+        }
+        if (mFrameBuffers != null) {
+            GLES20.glDeleteFramebuffers(mFrameBuffers.length, mFrameBuffers, 0);
+            mFrameBuffers = null;
         }
+    }
 
-        List<GPUImageFilter> filters;
-        for (GPUImageFilter filter : mFilters) {
-            if (filter instanceof GPUImageFilterGroup) {
-                ((GPUImageFilterGroup) filter).updateMergedFilters();
-                filters = ((GPUImageFilterGroup) filter).getMergedFilters();
-                if (filters == null || filters.isEmpty())
-                    continue;
-                mMergedFilters.addAll(filters);
-                continue;
-            }
-            mMergedFilters.add(filter);
+    public void addFilter(GPUImageFilter aFilter) {
+        if (aFilter == null) {
+            return;
         }
+        mFilters.add(aFilter);
+        updateMergedFilters();
     }
 }
diff --git a/library/src/jp/co/cyberagent/android/gpuimage/core/GPUImageRenderer.java b/library/src/jp/co/cyberagent/android/gpuimage/core/GPUImageRenderer.java
index 6a0bef54..7d88c4ca 100644
--- a/library/src/jp/co/cyberagent/android/gpuimage/core/GPUImageRenderer.java
+++ b/library/src/jp/co/cyberagent/android/gpuimage/core/GPUImageRenderer.java
@@ -38,7 +38,7 @@
 import javax.microedition.khronos.opengles.GL10;
 
 import jp.co.cyberagent.android.gpuimage.GPUImageNativeLibrary;
-import jp.co.cyberagent.android.gpuimage.util.OpenGlUtils;
+import jp.co.cyberagent.android.gpuimage.util.GlUtils;
 import jp.co.cyberagent.android.gpuimage.util.Rotation;
 import jp.co.cyberagent.android.gpuimage.util.TextureRotationUtil;
 
@@ -156,7 +156,7 @@ public void run() {
                     GPUImageNativeLibrary.YUVtoRBGA(data, previewSize.width, previewSize.height,
                             mGLRgbBuffer.array());// TODO: 2017/9/12 转码一波
                     // TODO: 2017/9/12 图像buf填装到OpenGL
-                    mGLTextureId = OpenGlUtils.loadTexture(mGLRgbBuffer, previewSize, mGLTextureId);
+                    mGLTextureId = GlUtils.loadTexture(mGLRgbBuffer, previewSize, mGLTextureId);
                     camera.addCallbackBuffer(data);// TODO: 2017/9/12 还给相机？
 
                     if (mImageWidth != previewSize.width) {
@@ -246,7 +246,7 @@ public void run() {
                 }
 
                 // TODO: 2017/9/12 图片链接到纹理
-                mGLTextureId = OpenGlUtils.loadTexture(resizedBitmap != null ? resizedBitmap : bitmap, mGLTextureId, recycle);
+                mGLTextureId = GlUtils.loadTexture(resizedBitmap != null ? resizedBitmap : bitmap, mGLTextureId, recycle);
                 if (resizedBitmap != null) {
                     resizedBitmap.recycle();// TODO: 2017/9/12 图片给到OpenGL后可释放
                 }
diff --git a/library/src/jp/co/cyberagent/android/gpuimage/filter/GPUImageToneCurveFilter.java b/library/src/jp/co/cyberagent/android/gpuimage/filter/GPUImageToneCurveFilter.java
index b7b2b37e..9e48a50c 100644
--- a/library/src/jp/co/cyberagent/android/gpuimage/filter/GPUImageToneCurveFilter.java
+++ b/library/src/jp/co/cyberagent/android/gpuimage/filter/GPUImageToneCurveFilter.java
@@ -27,7 +27,7 @@
 import java.util.Comparator;
 
 import jp.co.cyberagent.android.gpuimage.core.GPUImageFilter;
-import jp.co.cyberagent.android.gpuimage.util.OpenGlUtils;
+import jp.co.cyberagent.android.gpuimage.util.GlUtils;
 
 public class GPUImageToneCurveFilter extends GPUImageFilter {
     public static final String TONE_CURVE_FRAGMENT_SHADER = "" +
@@ -45,7 +45,7 @@
             "     gl_FragColor = vec4(redCurveValue, greenCurveValue, blueCurveValue, textureColor.a);\n" +
             " }";
 
-    private int[] mToneCurveTexture = new int[]{OpenGlUtils.NO_TEXTURE};
+    private int[] mToneCurveTexture = new int[]{GlUtils.NO_TEXTURE};
     private int mToneCurveTextureUniformLocation;
 
     private PointF[] mRgbCompositeControlPoints;
@@ -93,7 +93,7 @@ public void onInitialized() {
 
     @Override
     protected void onDrawArraysPre() {
-        if (mToneCurveTexture[0] != OpenGlUtils.NO_TEXTURE) {
+        if (mToneCurveTexture[0] != GlUtils.NO_TEXTURE) {
             GLES20.glActiveTexture(GLES20.GL_TEXTURE3);
             GLES20.glBindTexture(GLES20.GL_TEXTURE_2D, mToneCurveTexture[0]);
             GLES20.glUniform1i(mToneCurveTextureUniformLocation, 3);
diff --git a/library/src/jp/co/cyberagent/android/gpuimage/filter/GPUImageTwoInputFilter.java b/library/src/jp/co/cyberagent/android/gpuimage/filter/GPUImageTwoInputFilter.java
index cf1a1645..afcbdb13 100644
--- a/library/src/jp/co/cyberagent/android/gpuimage/filter/GPUImageTwoInputFilter.java
+++ b/library/src/jp/co/cyberagent/android/gpuimage/filter/GPUImageTwoInputFilter.java
@@ -24,7 +24,7 @@
 import java.nio.FloatBuffer;
 
 import jp.co.cyberagent.android.gpuimage.core.GPUImageFilter;
-import jp.co.cyberagent.android.gpuimage.util.OpenGlUtils;
+import jp.co.cyberagent.android.gpuimage.util.GlUtils;
 import jp.co.cyberagent.android.gpuimage.util.Rotation;
 import jp.co.cyberagent.android.gpuimage.util.TextureRotationUtil;
 
@@ -45,7 +45,7 @@
 
     public int mFilterSecondTextureCoordinateAttribute;
     public int mFilterInputTextureUniform2;
-    public int mFilterSourceTexture2 = OpenGlUtils.NO_TEXTURE;
+    public int mFilterSourceTexture2 = GlUtils.NO_TEXTURE;
     private ByteBuffer mTexture2CoordinatesBuffer;
     private Bitmap mBitmap;
 
@@ -81,12 +81,12 @@ public void setBitmap(final Bitmap bitmap) {
         }
         runOnDraw(new Runnable() {
             public void run() {
-                if (mFilterSourceTexture2 == OpenGlUtils.NO_TEXTURE) {
+                if (mFilterSourceTexture2 == GlUtils.NO_TEXTURE) {
                     if (bitmap == null || bitmap.isRecycled()) {
                         return;
                     }
                     GLES20.glActiveTexture(GLES20.GL_TEXTURE3);
-                    mFilterSourceTexture2 = OpenGlUtils.loadTexture(bitmap, OpenGlUtils.NO_TEXTURE, false);
+                    mFilterSourceTexture2 = GlUtils.loadTexture(bitmap, GlUtils.NO_TEXTURE, false);
                 }
             }
         });
@@ -108,7 +108,7 @@ public void onDestroy() {
         GLES20.glDeleteTextures(1, new int[]{
                 mFilterSourceTexture2
         }, 0);
-        mFilterSourceTexture2 = OpenGlUtils.NO_TEXTURE;
+        mFilterSourceTexture2 = GlUtils.NO_TEXTURE;
     }
 
     @Override
diff --git a/library/src/jp/co/cyberagent/android/gpuimage/util/GlUtils.java b/library/src/jp/co/cyberagent/android/gpuimage/util/GlUtils.java
new file mode 100644
index 00000000..2b94698b
--- /dev/null
+++ b/library/src/jp/co/cyberagent/android/gpuimage/util/GlUtils.java
@@ -0,0 +1,135 @@
+/*
+ * Copyright (C) 2012 CyberAgent
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package jp.co.cyberagent.android.gpuimage.util;
+
+import android.graphics.Bitmap;
+import android.graphics.Bitmap.Config;
+import android.hardware.Camera.Size;
+import android.opengl.GLES20;
+import android.opengl.GLUtils;
+import android.util.Log;
+
+import java.nio.IntBuffer;
+
+public class GlUtils {
+    public static final int NO_TEXTURE = -1;
+
+    public static int loadTexture(final Bitmap img, final int usedTexId) {
+        return loadTexture(img, usedTexId, true);
+    }
+
+    public static void glTexParameterf(){
+        GLES20.glTexParameterf(GLES20.GL_TEXTURE_2D,GLES20.GL_TEXTURE_MAG_FILTER, GLES20.GL_LINEAR);
+        GLES20.glTexParameterf(GLES20.GL_TEXTURE_2D,GLES20.GL_TEXTURE_MIN_FILTER, GLES20.GL_LINEAR);
+//            GLES20.glTexParameterf(GLES20.GL_TEXTURE_2D,GLES20.GL_TEXTURE_WRAP_S, GLES20.GL_CLAMP_TO_EDGE);
+//            GLES20.glTexParameterf(GLES20.GL_TEXTURE_2D,GLES20.GL_TEXTURE_WRAP_T, GLES20.GL_CLAMP_TO_EDGE);
+        // TODO: 2017/9/12 我有特殊需要填充方式改为重复
+        GLES20.glTexParameterf(GLES20.GL_TEXTURE_2D,GLES20.GL_TEXTURE_WRAP_S, GLES20.GL_REPEAT);
+        GLES20.glTexParameterf(GLES20.GL_TEXTURE_2D,GLES20.GL_TEXTURE_WRAP_T, GLES20.GL_REPEAT);
+    }
+
+    public static int loadTexture(final Bitmap img, final int usedTexId, final boolean recycle) {
+        int textures[] = new int[1];
+        if (usedTexId == NO_TEXTURE) {
+            GLES20.glGenTextures(1, textures, 0);
+            GLES20.glBindTexture(GLES20.GL_TEXTURE_2D, textures[0]);
+            glTexParameterf();
+            GLUtils.texImage2D(GLES20.GL_TEXTURE_2D, 0, img, 0);
+        } else {
+            GLES20.glBindTexture(GLES20.GL_TEXTURE_2D, usedTexId);
+            GLUtils.texSubImage2D(GLES20.GL_TEXTURE_2D, 0, 0, 0, img);
+            textures[0] = usedTexId;
+        }
+        if (recycle) {
+            img.recycle();
+        }
+        return textures[0];
+    }
+
+    public static int loadTexture(final IntBuffer data, final Size size, final int usedTexId) {
+        int textures[] = new int[1];
+        if (usedTexId == NO_TEXTURE) {
+            GLES20.glGenTextures(1, textures, 0);
+            GLES20.glBindTexture(GLES20.GL_TEXTURE_2D, textures[0]);
+            glTexParameterf();
+            GLES20.glTexImage2D(GLES20.GL_TEXTURE_2D, 0, GLES20.GL_RGBA, size.width, size.height,0, GLES20.GL_RGBA, GLES20.GL_UNSIGNED_BYTE, data);
+        } else {
+            GLES20.glBindTexture(GLES20.GL_TEXTURE_2D, usedTexId);
+            GLES20.glTexSubImage2D(GLES20.GL_TEXTURE_2D, 0, 0, 0, size.width,
+                    size.height, GLES20.GL_RGBA, GLES20.GL_UNSIGNED_BYTE, data);
+            textures[0] = usedTexId;
+        }
+        return textures[0];
+    }
+
+    public static int loadTextureAsBitmap(final IntBuffer data, final Size size, final int usedTexId) {
+        Bitmap bitmap = Bitmap
+                .createBitmap(data.array(), size.width, size.height, Config.ARGB_8888);
+        return loadTexture(bitmap, usedTexId);
+    }
+
+    public static int loadShader(final String strSource, final int iType) {
+        int[] compiled = new int[1];
+        int iShader = GLES20.glCreateShader(iType);
+        GLES20.glShaderSource(iShader, strSource);
+        GLES20.glCompileShader(iShader);
+        GLES20.glGetShaderiv(iShader, GLES20.GL_COMPILE_STATUS, compiled, 0);
+        if (compiled[0] == 0) {
+            Log.d("Load Shader Failed", "Compilation\n" + GLES20.glGetShaderInfoLog(iShader));
+            return 0;
+        }
+        return iShader;
+    }
+
+    public static int loadProgram(final String strVSource, final String strFSource) {
+        int iVShader;
+        int iFShader;
+        int iProgId;
+        int[] link = new int[1];
+        iVShader = loadShader(strVSource, GLES20.GL_VERTEX_SHADER);
+        if (iVShader == 0) {
+            Log.d("Load Program", "Vertex Shader Failed");
+            return 0;
+        }
+        iFShader = loadShader(strFSource, GLES20.GL_FRAGMENT_SHADER);
+        if (iFShader == 0) {
+            Log.d("Load Program", "Fragment Shader Failed");
+            return 0;
+        }
+
+        iProgId = GLES20.glCreateProgram();
+
+        GLES20.glAttachShader(iProgId, iVShader);
+        GLES20.glAttachShader(iProgId, iFShader);
+
+        GLES20.glLinkProgram(iProgId);
+
+        GLES20.glGetProgramiv(iProgId, GLES20.GL_LINK_STATUS, link, 0);
+        if (link[0] <= 0) {
+            Log.d("Load Program", "Linking Failed");
+            return 0;
+        }
+        GLES20.glDeleteShader(iVShader);
+        GLES20.glDeleteShader(iFShader);
+        return iProgId;
+    }
+
+    public static float rnd(final float min, final float max) {
+        float fRandNum = (float) Math.random();
+        return min + (max - min) * fRandNum;
+    }
+}
diff --git a/sample/src/jp/co/cyberagent/android/gpuimage/sample/GPUImageFilterTools.java b/sample/src/jp/co/cyberagent/android/gpuimage/sample/GPUImageFilterTools.java
index f172ced9..4726894b 100644
--- a/sample/src/jp/co/cyberagent/android/gpuimage/sample/GPUImageFilterTools.java
+++ b/sample/src/jp/co/cyberagent/android/gpuimage/sample/GPUImageFilterTools.java
@@ -108,7 +108,7 @@
     public static void showDialog(final Context context,
             final OnGpuImageFilterChosenListener listener) {
         final FilterList filters = new FilterList();
-        filters.addFilter("Me!Me!Me!", FilterType.DOUBLE);
+//        filters.addFilter("Me!Me!Me!", FilterType.DOUBLE);
         filters.addFilter("Contrast", FilterType.CONTRAST);
         filters.addFilter("Invert", FilterType.INVERT);
         filters.addFilter("Pixelation", FilterType.PIXELATION);
@@ -198,12 +198,21 @@ public static void showDialog(final Context context,
                     @Override
                     public void onClick(final DialogInterface dialog, final int item) {
                         listener.onGpuImageFilterChosenListener(
-                                createFilterForType(context, filters.filters.get(item)));
+//                                createFilterForType(context, filters.filters.get(item))
+                                doubleFilter(context, filters.filters.get(item))
+                        );
                     }
                 });
         builder.create().show();
     }
 
+    private static GPUImageFilter doubleFilter(final Context context, final FilterType type){
+        List<GPUImageFilter> filters = new LinkedList<GPUImageFilter>();
+        filters.add(new DoubleFilter());
+        filters.add(createFilterForType(context,type));
+        return new GPUImageFilterGroup(filters);
+    }
+
     private static GPUImageFilter createFilterForType(final Context context, final FilterType type) {
         switch (type) {
             case DOUBLE:
