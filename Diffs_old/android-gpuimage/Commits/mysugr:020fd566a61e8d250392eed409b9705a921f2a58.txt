diff --git a/library/src/jp/co/cyberagent/android/gpuimage/GPUImage.java b/library/src/jp/co/cyberagent/android/gpuimage/GPUImage.java
index 06b65d4b..2b08452e 100644
--- a/library/src/jp/co/cyberagent/android/gpuimage/GPUImage.java
+++ b/library/src/jp/co/cyberagent/android/gpuimage/GPUImage.java
@@ -14,6 +14,13 @@
  * limitations under the License.
  */
 
+/**
+ * Modifications:
+ * - Added method saveToPictures(final Bitmap bitmap, final File file, final int compressedQualitySize, final OnPictureSavedListener listener)
+ * - Added a second constructor for SaveTask {@link #jp.co.cyberagent.android.gpuimage.GPUImage.SaveTask} in order to directly reference to an existing File and choose the size for compress-quality
+ * - split/extract method saveImageToFile in order to reuse code
+ */
+
 package jp.co.cyberagent.android.gpuimage;
 
 import android.annotation.TargetApi;
@@ -48,7 +55,7 @@
  * The main accessor for GPUImage functionality. This class helps to do common
  * tasks through a simple interface.
  */
-public class GPUImage {  
+public class GPUImage {
     private final Context mContext;
     private final GPUImageRenderer mRenderer;
     private GLSurfaceView mGlSurfaceView;
@@ -56,24 +63,24 @@
     private Bitmap mCurrentBitmap;
     private ScaleType mScaleType = ScaleType.CENTER_CROP;
 
-    /**    
-     * Instantiates a new GPUImage object.   
-     * 
+    /**
+     * Instantiates a new GPUImage object.
+     *
      * @param context the context
      */
-    public GPUImage(final Context context) {  
+    public GPUImage(final Context context) {
         if (!supportsOpenGLES2(context)) {
             throw new IllegalStateException("OpenGL ES 2.0 is not supported on this phone.");
         }
- 
-        mContext = context; 
+
+        mContext = context;
         mFilter = new GPUImageFilter();
         mRenderer = new GPUImageRenderer(mFilter);
     }
 
     /**
      * Checks if OpenGL ES 2.0 is supported on the current device.
-     * 
+     *
      * @param context the context
      * @return true, if successful
      */
@@ -87,7 +94,7 @@ private boolean supportsOpenGLES2(final Context context) {
 
     /**
      * Sets the GLSurfaceView which will display the preview.
-     * 
+     *
      * @param view the GLSurfaceView
      */
     public void setGLSurfaceView(final GLSurfaceView view) {
@@ -109,7 +116,7 @@ public void requestRender() {
 
     /**
      * Sets the up camera to be connected to GPUImage to get a filtered preview.
-     * 
+     *
      * @param camera the camera
      */
     public void setUpCamera(final Camera camera) {
@@ -118,14 +125,14 @@ public void setUpCamera(final Camera camera) {
 
     /**
      * Sets the up camera to be connected to GPUImage to get a filtered preview.
-     * 
-     * @param camera the camera
-     * @param degrees by how many degrees the image should be rotated
+     *
+     * @param camera         the camera
+     * @param degrees        by how many degrees the image should be rotated
      * @param flipHorizontal if the image should be flipped horizontally
-     * @param flipVertical if the image should be flipped vertically
+     * @param flipVertical   if the image should be flipped vertically
      */
     public void setUpCamera(final Camera camera, final int degrees, final boolean flipHorizontal,
-            final boolean flipVertical) {
+                            final boolean flipVertical) {
         mGlSurfaceView.setRenderMode(GLSurfaceView.RENDERMODE_CONTINUOUSLY);
         if (Build.VERSION.SDK_INT > Build.VERSION_CODES.GINGERBREAD_MR1) {
             setUpCameraGingerbread(camera);
@@ -156,7 +163,7 @@ private void setUpCameraGingerbread(final Camera camera) {
     /**
      * Sets the filter which should be applied to the image which was (or will
      * be) set by setImage(...).
-     * 
+     *
      * @param filter the new filter
      */
     public void setFilter(final GPUImageFilter filter) {
@@ -167,7 +174,7 @@ public void setFilter(final GPUImageFilter filter) {
 
     /**
      * Sets the image on which the filter should be applied.
-     * 
+     *
      * @param bitmap the new image
      */
     public void setImage(final Bitmap bitmap) {
@@ -205,7 +212,7 @@ public void deleteImage() {
 
     /**
      * Sets the image on which the filter should be applied from a Uri.
-     * 
+     *
      * @param uri the uri of the new image
      */
     public void setImage(final Uri uri) {
@@ -214,7 +221,7 @@ public void setImage(final Uri uri) {
 
     /**
      * Sets the image on which the filter should be applied from a File.
-     * 
+     *
      * @param file the file of the new image
      */
     public void setImage(final File file) {
@@ -238,7 +245,7 @@ private String getPath(final Uri uri) {
 
     /**
      * Gets the current displayed image with applied filter as a Bitmap.
-     * 
+     *
      * @return the current image with filter applied
      */
     public Bitmap getBitmapWithFilterApplied() {
@@ -247,7 +254,7 @@ public Bitmap getBitmapWithFilterApplied() {
 
     /**
      * Gets the given bitmap with current filter applied as a Bitmap.
-     * 
+     *
      * @param bitmap the bitmap on which the current filter should be applied
      * @return the bitmap with filter applied
      */
@@ -299,13 +306,13 @@ public void run() {
      * Whenever a new Bitmap is ready, the listener will be called with the
      * bitmap. The order of the calls to the listener will be the same as the
      * filter order.
-     * 
-     * @param bitmap the bitmap on which the filters will be applied
-     * @param filters the filters which will be applied on the bitmap
+     *
+     * @param bitmap   the bitmap on which the filters will be applied
+     * @param filters  the filters which will be applied on the bitmap
      * @param listener the listener on which the results will be notified
      */
     public static void getBitmapForMultipleFilters(final Bitmap bitmap,
-            final List<GPUImageFilter> filters, final ResponseListener<Bitmap> listener) {
+                                                   final List<GPUImageFilter> filters, final ResponseListener<Bitmap> listener) {
         if (filters.isEmpty()) {
             return;
         }
@@ -329,13 +336,13 @@ public static void getBitmapForMultipleFilters(final Bitmap bitmap,
      * fileName. <br />
      * This method is async and will notify when the image was saved through the
      * listener.
-     * 
+     *
      * @param folderName the folder name
-     * @param fileName the file name
-     * @param listener the listener
+     * @param fileName   the file name
+     * @param listener   the listener
      */
     public void saveToPictures(final String folderName, final String fileName,
-            final OnPictureSavedListener listener) {
+                               final OnPictureSavedListener listener) {
         saveToPictures(mCurrentBitmap, folderName, fileName, listener);
     }
 
@@ -345,17 +352,21 @@ public void saveToPictures(final String folderName, final String fileName,
      * folerName and fileName. <br />
      * This method is async and will notify when the image was saved through the
      * listener.
-     * 
-     * @param bitmap the bitmap
+     *
+     * @param bitmap     the bitmap
      * @param folderName the folder name
-     * @param fileName the file name
-     * @param listener the listener
+     * @param fileName   the file name
+     * @param listener   the listener
      */
     public void saveToPictures(final Bitmap bitmap, final String folderName, final String fileName,
-            final OnPictureSavedListener listener) {
+                               final OnPictureSavedListener listener) {
         new SaveTask(bitmap, folderName, fileName, listener).execute();
     }
 
+    public void saveToPictures(final Bitmap bitmap, final File file, final int compressedQualitySize, final OnPictureSavedListener listener){
+        new SaveTask(bitmap, file, compressedQualitySize, listener).execute();
+    }
+
     private int getOutputWidth() {
         if (mRenderer != null && mRenderer.getFrameWidth() != 0) {
             return mRenderer.getFrameWidth();
@@ -389,33 +400,71 @@ private int getOutputHeight() {
         private final String mFileName;
         private final OnPictureSavedListener mListener;
         private final Handler mHandler;
+        private File mFile;
+        private int mCompressSize;
 
         public SaveTask(final Bitmap bitmap, final String folderName, final String fileName,
-                final OnPictureSavedListener listener) {
+                        final OnPictureSavedListener listener) {
             mBitmap = bitmap;
             mFolderName = folderName;
             mFileName = fileName;
             mListener = listener;
             mHandler = new Handler();
+
+        }
+
+
+        /**
+         * Make a second constructor for directly setting the corresponding File
+         * Plus optional add a compress size -> if not set 80 will be used
+         *
+         * @param bitmap
+         * @param file
+         * @param compressedQualitySize size of the quality the bitmap will be compressed to (between 0 and 100)
+         * @param listener
+         */
+        public SaveTask(final Bitmap bitmap, final File file, final int compressedQualitySize,
+                        final OnPictureSavedListener listener) {
+            mBitmap = bitmap;
+            mFile = file;
+            mListener = listener;
+            mHandler = new Handler();
+            if (compressedQualitySize >= 0 || compressedQualitySize <= 100) {
+                mCompressSize = compressedQualitySize;
+            } else {
+                mCompressSize = 80;
+            }
+
+            //will not be used
+            mFolderName = null;
+            mFileName = null;
         }
 
         @Override
         protected Void doInBackground(final Void... params) {
             Bitmap result = getBitmapWithFilterApplied(mBitmap);
-            saveImage(mFolderName, mFileName, result);
+            if (mFile == null) saveImage(mFolderName, mFileName, result);
+            else saveImageToFile(result, mFile, mCompressSize);
             return null;
         }
 
+
         private void saveImage(final String folderName, final String fileName, final Bitmap image) {
             File path = Environment
                     .getExternalStoragePublicDirectory(Environment.DIRECTORY_PICTURES);
             File file = new File(path, folderName + "/" + fileName);
+
+            file.getParentFile().mkdirs();
+            saveImageToFile(image, file, 80);
+
+        }
+
+        private void saveImageToFile(Bitmap image, File file, int compressedSize) {
             try {
-                file.getParentFile().mkdirs();
-                image.compress(CompressFormat.JPEG, 80, new FileOutputStream(file));
+                image.compress(CompressFormat.JPEG, compressedSize, new FileOutputStream(file));
                 MediaScannerConnection.scanFile(mContext,
-                        new String[] {
-                            file.toString()
+                        new String[]{
+                                file.toString()
                         }, null,
                         new MediaScannerConnection.OnScanCompletedListener() {
                             @Override
@@ -430,7 +479,8 @@ public void run() {
                                     });
                                 }
                             }
-                        });
+                        }
+                );
             } catch (FileNotFoundException e) {
                 e.printStackTrace();
             }
@@ -469,7 +519,7 @@ protected Bitmap decode(BitmapFactory.Options options) {
         @Override
         protected int getImageOrientation() throws IOException {
             Cursor cursor = mContext.getContentResolver().query(mUri,
-                    new String[] { MediaStore.Images.ImageColumns.ORIENTATION }, null, null, null);
+                    new String[]{MediaStore.Images.ImageColumns.ORIENTATION}, null, null, null);
 
             if (cursor == null || cursor.getCount() != 1) {
                 return 0;
@@ -659,5 +709,5 @@ private Bitmap rotateImage(final Bitmap bitmap) {
         void response(T item);
     }
 
-    public enum ScaleType { CENTER_INSIDE, CENTER_CROP }
+    public enum ScaleType {CENTER_INSIDE, CENTER_CROP}
 }
