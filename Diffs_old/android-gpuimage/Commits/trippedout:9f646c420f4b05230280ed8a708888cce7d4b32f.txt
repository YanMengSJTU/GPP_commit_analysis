diff --git a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageChromaKeyBlendFilter.java b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageChromaKeyBlendFilter.java
index c5adf8f4..89572a7c 100644
--- a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageChromaKeyBlendFilter.java
+++ b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageChromaKeyBlendFilter.java
@@ -17,59 +17,47 @@
 package jp.co.cyberagent.android.gpuimage;
 
 import android.opengl.GLES20;
+import android.util.Log;
 
 /**
  * Selectively replaces a color in the first image with the second image
  */
 public class GPUImageChromaKeyBlendFilter extends GPUImageTwoInputFilter {
-    public static final String CHROMA_KEY_BLEND_FRAGMENT_SHADER = "varying highp vec2 textureCoordinate;\n" +
-            " varying highp vec2 textureCoordinate2;\n" +
-            " \n" +
-            " uniform sampler2D inputImageTexture;\n" +
-            " uniform sampler2D inputImageTexture2;\n" +
-            " \n" +
-            " highp float lum(lowp vec3 c) {\n" +
-            "     return dot(c, vec3(0.3, 0.59, 0.11));\n" +
-            " }\n" +
-            " \n" +
-            " lowp vec3 clipcolor(lowp vec3 c) {\n" +
-            "     highp float l = lum(c);\n" +
-            "     lowp float n = min(min(c.r, c.g), c.b);\n" +
-            "     lowp float x = max(max(c.r, c.g), c.b);\n" +
-            "     \n" +
-            "     if (n < 0.0) {\n" +
-            "         c.r = l + ((c.r - l) * l) / (l - n);\n" +
-            "         c.g = l + ((c.g - l) * l) / (l - n);\n" +
-            "         c.b = l + ((c.b - l) * l) / (l - n);\n" +
-            "     }\n" +
-            "     if (x > 1.0) {\n" +
-            "         c.r = l + ((c.r - l) * (1.0 - l)) / (x - l);\n" +
-            "         c.g = l + ((c.g - l) * (1.0 - l)) / (x - l);\n" +
-            "         c.b = l + ((c.b - l) * (1.0 - l)) / (x - l);\n" +
-            "     }\n" +
-            "     \n" +
-            "     return c;\n" +
-            " }\n" +
-            "\n" +
-            " lowp vec3 setlum(lowp vec3 c, highp float l) {\n" +
-            "     highp float d = l - lum(c);\n" +
-            "     c = c + vec3(d);\n" +
-            "     return clipcolor(c);\n" +
-            " }\n" +
-            " \n" +
-            " void main()\n" +
-            " {\n" +
-            "   highp vec4 baseColor = texture2D(inputImageTexture, textureCoordinate);\n" +
-            "   highp vec4 overlayColor = texture2D(inputImageTexture2, textureCoordinate2);\n" +
-            "\n" +
-            "     gl_FragColor = vec4(baseColor.rgb * (1.0 - overlayColor.a) + setlum(overlayColor.rgb, lum(baseColor.rgb)) * overlayColor.a, baseColor.a);\n" +
-            " }";
+    public static final String CHROMA_KEY_BLEND_FRAGMENT_SHADER = "precision highp float;\n" +
+    		"\n" +
+    		" varying highp vec2 textureCoordinate;\n" +
+    		" varying highp vec2 textureCoordinate2;\n" +
+    		"\n" +
+    		" uniform float thresholdSensitivity;\n" +
+    		" uniform float smoothing;\n" +
+    		" uniform vec3 colorToReplace;\n" +
+    		" uniform sampler2D inputImageTexture;\n" +
+    		" uniform sampler2D inputImageTexture2;\n" +
+    		"\n" +
+    		" void main()\n" +
+    		" {\n" +
+    		"     vec4 textureColor = texture2D(inputImageTexture, textureCoordinate);\n" +
+    		"     vec4 textureColor2 = texture2D(inputImageTexture2, textureCoordinate2);\n" +
+    		"\n" +
+    		"     float maskY = 0.2989 * colorToReplace.r + 0.5866 * colorToReplace.g + 0.1145 * colorToReplace.b;\n" +
+    		"     float maskCr = 0.7132 * (colorToReplace.r - maskY);\n" +
+    		"     float maskCb = 0.5647 * (colorToReplace.b - maskY);\n" +
+    		"\n" +
+    		"     float Y = 0.2989 * textureColor.r + 0.5866 * textureColor.g + 0.1145 * textureColor.b;\n" +
+    		"     float Cr = 0.7132 * (textureColor.r - Y);\n" +
+    		"     float Cb = 0.5647 * (textureColor.b - Y);\n" +
+    		"\n" +
+    		"//     float blendValue = 1.0 - smoothstep(thresholdSensitivity - smoothing, thresholdSensitivity , abs(Cr - maskCr) + abs(Cb - maskCb));\n" +
+    		"     float blendValue = 1.0 - smoothstep(thresholdSensitivity, thresholdSensitivity + smoothing, distance(vec2(Cr, Cb), vec2(maskCr, maskCb)));\n" +
+    		"     gl_FragColor = mix(textureColor, textureColor2, blendValue);\n" +
+    		" }\n"
+;
 
     private int mThresholdSensitivityLocation;
     private int mSmoothingLocation;
     private int mColorToReplaceLocation;
     private float mSmoothing = 0.1f;
-    private float mThresholdSensitivity = 0.3f;
+    private float mThresholdSensitivity = 0.4f;
     private float[] mColorToReplace = new float[]{0.0f, 1.0f, 0.0f};
 
     public GPUImageChromaKeyBlendFilter() {
@@ -92,6 +80,14 @@ public void onInitialized() {
         setThresholdSensitivity(mThresholdSensitivity);
         setColorToReplace(mColorToReplace[0], mColorToReplace[1], mColorToReplace[2]);
     }
+    
+    @Override
+    protected void onDrawArraysPre() {
+    	super.onDrawArraysPre();    	
+    	setFloat(mSmoothingLocation, mSmoothing);
+    	setFloat(mThresholdSensitivityLocation, mThresholdSensitivity);
+    	setFloatVec3(mColorToReplaceLocation, mColorToReplace);
+    }
 
     /**
      * The degree of smoothing controls how gradually similar colors are replaced in the image
