diff --git a/build.gradle b/build.gradle
index 1e3515e0..f2cf7fd2 100644
--- a/build.gradle
+++ b/build.gradle
@@ -1,16 +1,20 @@
 // Top-level build file where you can add configuration options common to all sub-projects/modules.
 
 buildscript {
-    ext.kotlin_version = '1.2.71'
+    ext.kotlin_version = '1.3.0'
     repositories {
         google()
         jcenter()
+        mavenCentral()
+
     }
     dependencies {
-        classpath 'com.android.tools.build:gradle:3.4.0-alpha02'
+        classpath 'com.android.tools.build:gradle:3.2.1'
         classpath 'com.jfrog.bintray.gradle:gradle-bintray-plugin:1.8.4'
         classpath 'com.github.dcendents:android-maven-gradle-plugin:2.1'
         classpath "org.jetbrains.kotlin:kotlin-gradle-plugin:$kotlin_version"
+        classpath 'com.jakewharton.hugo:hugo-plugin:1.2.1'
+
     }
 }
 
diff --git a/gradle/wrapper/gradle-wrapper.properties b/gradle/wrapper/gradle-wrapper.properties
index 5c1b6c95..76dd3078 100644
--- a/gradle/wrapper/gradle-wrapper.properties
+++ b/gradle/wrapper/gradle-wrapper.properties
@@ -1,5 +1,6 @@
+#Fri Nov 30 11:26:34 CST 2018
 distributionBase=GRADLE_USER_HOME
 distributionPath=wrapper/dists
-distributionUrl=https\://services.gradle.org/distributions/gradle-4.10.1-bin.zip
 zipStoreBase=GRADLE_USER_HOME
 zipStorePath=wrapper/dists
+distributionUrl=https\://services.gradle.org/distributions/gradle-4.10.1-all.zip
diff --git a/library/build.gradle b/library/build.gradle
index 128a909e..789c746d 100644
--- a/library/build.gradle
+++ b/library/build.gradle
@@ -1,4 +1,5 @@
 apply plugin: 'com.android.library'
+apply plugin: 'com.jakewharton.hugo'
 
 android {
     compileSdkVersion COMPILE_SDK_VERSION as int
@@ -10,11 +11,24 @@ android {
         versionCode = VERSION_CODE as int
         versionName = VERSION_NAME
         externalNativeBuild {
-            cmake { cppFlags "" }
+            cmake {
+                cppFlags "-std=c++11 -fpermissive -frtti -fexceptions"
+                arguments '-DANDROID_PLATFORM=android-18',
+                        '-DANDROID_TOOLCHAIN=clang',
+                        '-DANDROID_ABI=armeabi-v7a',
+                        '-DCMAKE_BUILD_TYPE=Release',
+                        '-DANDROID_ARM_NEON=ON',
+                        "-DANDROID_STL=c++_shared"
+            }
+        }
+        ndk {
+            abiFilters 'armeabi-v7a'
         }
     }
     externalNativeBuild {
-        cmake { path "src/main/cpp/CMakeLists.txt" }
+        cmake {
+            path "src/main/cpp/CMakeLists.txt"
+        }
     }
 
     buildTypes {
diff --git a/library/src/main/cpp/CMakeLists.txt b/library/src/main/cpp/CMakeLists.txt
index af48ac01..a60038dd 100644
--- a/library/src/main/cpp/CMakeLists.txt
+++ b/library/src/main/cpp/CMakeLists.txt
@@ -17,7 +17,8 @@ add_library( # Sets the name of the library.
         SHARED
 
         # Provides a relative path to your source file(s).
-        yuv-decoder.c)
+        yuv-decoder.c
+        yuv2rgb.cpp)
 
 # Searches for a specified prebuilt library and stores the path as a
 # variable. Because CMake includes system libraries in the search path by
diff --git a/library/src/main/cpp/yuv-decoder.c b/library/src/main/cpp/yuv-decoder.c
index b9596f85..2059823c 100644
--- a/library/src/main/cpp/yuv-decoder.c
+++ b/library/src/main/cpp/yuv-decoder.c
@@ -2,6 +2,7 @@
 
 #include <android/bitmap.h>
 #include <GLES2/gl2.h>
+#include "yuv2rgb.h"
 
 
 JNIEXPORT void JNICALL
@@ -125,7 +126,7 @@ Java_jp_co_cyberagent_android_gpuimage_GPUImageNativeLibrary_YUVtoARBG(JNIEnv *e
 
 JNIEXPORT void JNICALL
 Java_jp_co_cyberagent_android_gpuimage_GPUImageNativeLibrary_adjustBitmap(JNIEnv *jenv, jclass thiz,
-                                                                       jobject src) {
+                                                                          jobject src) {
     unsigned char *srcByteBuffer;
     int result = 0;
     int i, j;
@@ -155,4 +156,21 @@ Java_jp_co_cyberagent_android_gpuimage_GPUImageNativeLibrary_adjustBitmap(JNIEnv
         }
     }
     AndroidBitmap_unlockPixels(jenv, src);
-}
\ No newline at end of file
+}
+
+JNIEXPORT void JNICALL
+Java_jp_co_cyberagent_android_gpuimage_GPUImageNativeLibrary_YUVtoRGBANEON(JNIEnv *env,
+                                                                            jobject obj,
+                                                                            jbyteArray yuv420sp,
+                                                                            jint width, jint height,
+                                                                            jintArray rgbOut) {
+    jint *rgbData = (jint *) ((*env)->GetPrimitiveArrayCritical(env, rgbOut, 0));
+    jbyte *yuv = (jbyte *) (*env)->GetPrimitiveArrayCritical(env, yuv420sp, 0);
+    nv21_to_rgba((unsigned char *) rgbData, 0xff, (const unsigned char *) yuv, width, height);
+    (*env)->ReleasePrimitiveArrayCritical(env, rgbOut, rgbData, 0);
+    (*env)->ReleasePrimitiveArrayCritical(env, yuv420sp, yuv, 0);
+}
+
+
+
+
diff --git a/library/src/main/cpp/yuv2rgb.cpp b/library/src/main/cpp/yuv2rgb.cpp
new file mode 100644
index 00000000..75421e21
--- /dev/null
+++ b/library/src/main/cpp/yuv2rgb.cpp
@@ -0,0 +1,374 @@
+/*
+ * Copyright (C) 2012 Andre Chen and contributors.
+ * andre.hl.chen@gmail.com
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+ */
+#include "yuv2rgb.h"
+
+//-----------------------------------------------------------------------------
+#ifdef ARM_NEON_ENABLE
+
+#include <arm_neon.h>
+
+template<typename trait>
+void decode_yuv_neon(unsigned char *out, unsigned char const *y, unsigned char const *uv, int width,
+                     int height, unsigned char fill_alpha = 0xff) {
+    // pre-condition : width, height must be even
+    if (0 != (width & 1) || width < 2 || 0 != (height & 1) || height < 2 || !out || !y || !uv)
+        return;
+
+    // in & out pointers
+    unsigned char *dst = out;
+
+    // constants
+    int const stride = width * trait::bytes_per_pixel;
+    int const itHeight = height >> 1;
+    int const itWidth = width >> 3;
+
+    uint8x8_t const Yshift = vdup_n_u8(16);
+    int16x8_t const half = vdupq_n_u16(128);
+    int32x4_t const rounding = vdupq_n_s32(128);
+
+    // tmp variable
+    uint16x8_t t;
+
+    // pixel block to temporary store 8 pixels
+    typename trait::PixelBlock pblock = trait::init_pixelblock(fill_alpha);
+
+    for (int j = 0; j < itHeight; ++j, y += width, dst += stride) {
+        for (int i = 0; i < itWidth; ++i, y += 8, uv += 8, dst += (8 * trait::bytes_per_pixel)) {
+            t = vmovl_u8(vqsub_u8(vld1_u8(y), Yshift));
+            int32x4_t const Y00 = vmulq_n_u32(vmovl_u16(vget_low_u16(t)), 298);
+            int32x4_t const Y01 = vmulq_n_u32(vmovl_u16(vget_high_u16(t)), 298);
+
+            t = vmovl_u8(vqsub_u8(vld1_u8(y + width), Yshift));
+            int32x4_t const Y10 = vmulq_n_u32(vmovl_u16(vget_low_u16(t)), 298);
+            int32x4_t const Y11 = vmulq_n_u32(vmovl_u16(vget_high_u16(t)), 298);
+
+            // trait::loadvu pack 4 sets of uv into a uint8x8_t, layout : { v0,u0, v1,u1, v2,u2, v3,u3 }
+            t = vsubq_s16((int16x8_t) vmovl_u8(trait::loadvu(uv)), half);
+
+            // UV.val[0] : v0, v1, v2, v3
+            // UV.val[1] : u0, u1, u2, u3
+            int16x4x2_t const UV = vuzp_s16(vget_low_s16(t), vget_high_s16(t));
+
+            // tR : 128+409V
+            // tG : 128-100U-208V
+            // tB : 128+516U
+            int32x4_t const tR = vmlal_n_s16(rounding, UV.val[0], 409);
+            int32x4_t const tG = vmlal_n_s16(vmlal_n_s16(rounding, UV.val[0], -208), UV.val[1],
+                                             -100);
+            int32x4_t const tB = vmlal_n_s16(rounding, UV.val[1], 516);
+
+            int32x4x2_t const R = vzipq_s32(tR, tR); // [tR0, tR0, tR1, tR1] [ tR2, tR2, tR3, tR3]
+            int32x4x2_t const G = vzipq_s32(tG, tG); // [tG0, tG0, tG1, tG1] [ tG2, tG2, tG3, tG3]
+            int32x4x2_t const B = vzipq_s32(tB, tB); // [tB0, tB0, tB1, tB1] [ tB2, tB2, tB3, tB3]
+
+            // upper 8 pixels
+            trait::store_pixel_block(dst, pblock,
+                                     vshrn_n_u16(vcombine_u16(vqmovun_s32(vaddq_s32(R.val[0], Y00)),
+                                                              vqmovun_s32(
+                                                                      vaddq_s32(R.val[1], Y01))),
+                                                 8),
+                                     vshrn_n_u16(vcombine_u16(vqmovun_s32(vaddq_s32(G.val[0], Y00)),
+                                                              vqmovun_s32(
+                                                                      vaddq_s32(G.val[1], Y01))),
+                                                 8),
+                                     vshrn_n_u16(vcombine_u16(vqmovun_s32(vaddq_s32(B.val[0], Y00)),
+                                                              vqmovun_s32(
+                                                                      vaddq_s32(B.val[1], Y01))),
+                                                 8));
+
+            // lower 8 pixels
+            trait::store_pixel_block(dst + stride, pblock,
+                                     vshrn_n_u16(vcombine_u16(vqmovun_s32(vaddq_s32(R.val[0], Y10)),
+                                                              vqmovun_s32(
+                                                                      vaddq_s32(R.val[1], Y11))),
+                                                 8),
+                                     vshrn_n_u16(vcombine_u16(vqmovun_s32(vaddq_s32(G.val[0], Y10)),
+                                                              vqmovun_s32(
+                                                                      vaddq_s32(G.val[1], Y11))),
+                                                 8),
+                                     vshrn_n_u16(vcombine_u16(vqmovun_s32(vaddq_s32(B.val[0], Y10)),
+                                                              vqmovun_s32(
+                                                                      vaddq_s32(B.val[1], Y11))),
+                                                 8));
+        }
+    }
+    return;
+}
+
+//------------------------------------------------------------------------------
+class NV21toRGB_neon {
+public:
+    enum {
+        bytes_per_pixel = 3
+    };
+    typedef uint8x8x3_t PixelBlock;
+
+    static PixelBlock const init_pixelblock(unsigned char /*fill_alpha*/) {
+        return uint8x8x3_t();
+    }
+
+    static uint8x8_t const loadvu(unsigned char const *uv) {
+        return vld1_u8(uv);
+    }
+
+    static void store_pixel_block(unsigned char *dst, PixelBlock &pblock, uint8x8_t const &r,
+                                  uint8x8_t const &g, uint8x8_t const &b) {
+        pblock.val[0] = r;
+        pblock.val[1] = g;
+        pblock.val[2] = b;
+        vst3_u8(dst, pblock);
+    }
+};
+
+void nv21_to_rgb(unsigned char *rgb, unsigned char const *nv21, int width, int height) {
+    return decode_yuv_neon<NV21toRGB_neon>(rgb, nv21, nv21 + (width * height), width, height);
+}
+
+void nv21_to_rgb(unsigned char *rgb, unsigned char const *y, unsigned char const *uv, int width,
+                 int height) {
+    return decode_yuv_neon<NV21toRGB_neon>(rgb, y, uv, width, height);
+}
+
+//------------------------------------------------------------------------------
+class NV21toRGBA_neon {
+public:
+    enum {
+        bytes_per_pixel = 4
+    };
+    typedef uint8x8x4_t PixelBlock;
+
+    static PixelBlock const init_pixelblock(unsigned char fill_alpha) {
+        PixelBlock block;
+        block.val[3] = vdup_n_u8(fill_alpha); // alpha channel in the last
+        return block;
+    }
+
+    static uint8x8_t const loadvu(unsigned char const *uv) {
+        return vld1_u8(uv);
+    }
+
+    static void store_pixel_block(unsigned char *dst, PixelBlock &pblock, uint8x8_t const &r,
+                                  uint8x8_t const &g, uint8x8_t const &b) {
+        pblock.val[0] = r;
+        pblock.val[1] = g;
+        pblock.val[2] = b;
+        vst4_u8(dst, pblock);
+    }
+};
+
+void nv21_to_rgba(unsigned char *rgba, unsigned char alpha, unsigned char const *nv21, int width,
+                  int height) {
+    return decode_yuv_neon<NV21toRGBA_neon>(rgba, nv21, nv21 + (width * height), width, height,
+                                            alpha);
+}
+
+//------------------------------------------------------------------------------
+class NV21toBGRA_neon {
+public:
+    enum {
+        bytes_per_pixel = 4
+    };
+    typedef uint8x8x4_t PixelBlock;
+
+    static PixelBlock const init_pixelblock(unsigned char fill_alpha) {
+        PixelBlock block;
+        block.val[3] = vdup_n_u8(fill_alpha); // alpha channel in the last
+        return block;
+    }
+
+    static uint8x8_t const loadvu(unsigned char const *uv) {
+        return vld1_u8(uv);
+    }
+
+    static void store_pixel_block(unsigned char *dst, PixelBlock &pblock, uint8x8_t const &r,
+                                  uint8x8_t const &g, uint8x8_t const &b) {
+        pblock.val[0] = b;
+        pblock.val[1] = g;
+        pblock.val[2] = r;
+        vst4_u8(dst, pblock);
+    }
+};
+
+void nv21_to_bgra(unsigned char *rgba, unsigned char alpha, unsigned char const *nv21, int width,
+                  int height) {
+    return decode_yuv_neon<NV21toBGRA_neon>(rgba, nv21, nv21 + (width * height), width, height,
+                                            alpha);
+}
+
+//------------------------------------------------------------------------------
+class NV21toBGR_neon {
+public:
+    enum {
+        bytes_per_pixel = 3
+    };
+    typedef uint8x8x3_t PixelBlock;
+
+    static PixelBlock const init_pixelblock(unsigned char /*fill_alpha*/) {
+        return uint8x8x3_t();
+    }
+
+    static uint8x8_t const loadvu(unsigned char const *uv) {
+        return vld1_u8(uv);
+    }
+
+    static void store_pixel_block(unsigned char *dst, PixelBlock &pblock, uint8x8_t const &r,
+                                  uint8x8_t const &g, uint8x8_t const &b) {
+        pblock.val[0] = b;
+        pblock.val[1] = g;
+        pblock.val[2] = r;
+        vst3_u8(dst, pblock);
+    }
+};
+
+void nv21_to_bgr(unsigned char *bgr, unsigned char const *nv21, int width, int height) {
+    return decode_yuv_neon<NV21toBGR_neon>(bgr, nv21, nv21 + (width * height), width, height);
+}
+
+#else // !neon
+
+#ifdef __ANDROID__
+#warning "use SLOW YUV(nv21) decoder : Try #define ARM_NEON_ENABLE if target architecture is ARMv7a"
+#endif
+
+//------------------------------------------------------------------------------
+template<typename trait>
+bool decode_yuv(unsigned char* out, unsigned char const* yuv, int width, int height, unsigned char alpha=0xff)
+{
+    // pre-condition : width and height must be even
+    if (0!=(width&1) || width<2 || 0!=(height&1) || height<2 || !out || !yuv)
+        return false;
+
+    unsigned char* dst0 = out;
+
+    unsigned char const* y0 = yuv;
+    unsigned char const* uv = yuv + (width*height);
+    int const halfHeight = height>>1;
+    int const halfWidth = width>>1;
+
+    int Y00, Y01, Y10, Y11;
+    int V, U;
+    int tR, tG, tB;
+    for (int h=0; h<halfHeight; ++h) {
+        unsigned char const* y1 = y0+width;
+        unsigned char* dst1 = dst0 + width*trait::bytes_per_pixel;
+        for (int w=0; w<halfWidth; ++w) {
+            // shift
+            Y00 = (*y0++) - 16;  Y01 = (*y0++) - 16;
+            Y10 = (*y1++) - 16;  Y11 = (*y1++) - 16;
+
+            // U,V or V,U? our trait will make the right call
+            trait::loadvu(U, V, uv);
+
+            // temps
+            Y00 = (Y00>0) ? (298*Y00):0;
+            Y01 = (Y01>0) ? (298*Y01):0;
+            Y10 = (Y10>0) ? (298*Y10):0;
+            Y11 = (Y11>0) ? (298*Y11):0;
+            tR = 128 + 409*V;
+            tG = 128 - 100*U - 208*V;
+            tB = 128 + 516*U;
+
+            // 2x2 pixels result
+            trait::store_pixel(dst0, Y00+tR, Y00+tG, Y00+tB, alpha);
+            trait::store_pixel(dst0, Y01+tR, Y01+tG, Y01+tB, alpha);
+            trait::store_pixel(dst1, Y10+tR, Y10+tG, Y10+tB, alpha);
+            trait::store_pixel(dst1, Y11+tR, Y11+tG, Y11+tB, alpha);
+        }
+        y0 = y1;
+        dst0 = dst1;
+    }
+    return true;
+}
+
+//------------------------------------------------------------------------------
+class NV21toRGB {
+public:
+    enum { bytes_per_pixel = 3 };
+    static void loadvu(int& U, int& V, unsigned char const* &uv) {
+        V = (*uv++) - 128;
+        U = (*uv++) - 128;
+    }
+    static void store_pixel(unsigned char* &dst, int iR, int iG, int iB, unsigned char/*alpha*/) {
+        *dst++ = (iR>0) ? (iR<65535 ? (unsigned char)(iR>>8):0xff):0;
+        *dst++ = (iG>0) ? (iG<65535 ? (unsigned char)(iG>>8):0xff):0;
+        *dst++ = (iB>0) ? (iB<65535 ? (unsigned char)(iB>>8):0xff):0;
+    }
+};
+bool nv21_to_rgb(unsigned char* rgb, unsigned char const* nv21, int width, int height) {
+    return decode_yuv<NV21toRGB>(rgb, nv21, width, height);
+}
+
+//------------------------------------------------------------------------------
+class NV21toRGBA {
+public:
+    enum { bytes_per_pixel = 4 };
+    static void loadvu(int& U, int& V, unsigned char const* &uv) {
+        V = (*uv++) - 128;
+        U = (*uv++) - 128;
+    }
+    static void store_pixel(unsigned char* &dst, int iR, int iG, int iB, unsigned char alpha) {
+        *dst++ = (iR>0) ? (iR<65535 ? (unsigned char)(iR>>8):0xff):0;
+        *dst++ = (iG>0) ? (iG<65535 ? (unsigned char)(iG>>8):0xff):0;
+        *dst++ = (iB>0) ? (iB<65535 ? (unsigned char)(iB>>8):0xff):0;
+        *dst++ = alpha;
+    }
+};
+
+bool nv21_to_rgba(unsigned char* rgba, unsigned char alpha, unsigned char const* nv21, int width, int height) {
+    return decode_yuv<NV21toRGBA>(rgba, nv21, width, height, alpha);
+}
+
+//------------------------------------------------------------------------------
+class NV21toBGR {
+public:
+    enum { bytes_per_pixel = 3 };
+    static void loadvu(int& U, int& V, unsigned char const* &uv) {
+        V = (*uv++) - 128;
+        U = (*uv++) - 128;
+    }
+    static void store_pixel(unsigned char* &dst, int iR, int iG, int iB, unsigned char/*alpha*/) {
+        *dst++ = (iB>0) ? (iB<65535 ? (unsigned char)(iB>>8):0xff):0;
+        *dst++ = (iG>0) ? (iG<65535 ? (unsigned char)(iG>>8):0xff):0;
+        *dst++ = (iR>0) ? (iR<65535 ? (unsigned char)(iR>>8):0xff):0;
+    }
+};
+bool nv21_to_bgr(unsigned char* bgr, unsigned char const* nv21, int width, int height) {
+    return decode_yuv<NV21toBGR>(bgr, nv21, width, height);
+}
+
+//------------------------------------------------------------------------------
+class NV21toBGRA {
+public:
+    enum { bytes_per_pixel = 4 };
+    static void loadvu(int& U, int& V, unsigned char const* &uv) {
+        V = (*uv++) - 128;
+        U = (*uv++) - 128;
+    }
+    static void store_pixel(unsigned char* &dst, int iR, int iG, int iB, unsigned char alpha) {
+        *dst++ = (iB>0) ? (iB<65535 ? (unsigned char)(iB>>8):0xff):0;
+        *dst++ = (iG>0) ? (iG<65535 ? (unsigned char)(iG>>8):0xff):0;
+        *dst++ = (iR>0) ? (iR<65535 ? (unsigned char)(iR>>8):0xff):0;
+        *dst++ = alpha;
+    }
+};
+
+bool nv21_to_bgra(unsigned char* rgba, unsigned char alpha, unsigned char const* nv21, int width, int height) {
+    return decode_yuv<NV21toBGRA>(rgba, nv21, width, height, alpha);
+}
+
+#endif
\ No newline at end of file
diff --git a/library/src/main/cpp/yuv2rgb.h b/library/src/main/cpp/yuv2rgb.h
new file mode 100644
index 00000000..311c626f
--- /dev/null
+++ b/library/src/main/cpp/yuv2rgb.h
@@ -0,0 +1,93 @@
+/*
+ * Copyright (C) 2012 Andre Chen and contributors.
+ * andre.hl.chen@gmail.com
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+ */
+
+#define ARM_NEON_ENABLE
+/*
+ YUV 4:2:0 (sp for "semi-plane")image with a plane of 8 bit Y samples followed by an interleaved
+ U/V plane containing 8 bit 2x2 subsampled chroma samples.
+ except the interleave order of U and V is reversed.
+Cumbersome YUV formats(http://www.fourcc.org/yuv.php)...
+NV12
+YUV 4:2:0 image with a plane of 8 bit Y samples followed by an interleaved U/V plane containing 8 bit 2x2 subsampled colour difference samples.
+Microsoft defines this format as follows:
+	"A format in which all Y samples are found first in memory as an array of unsigned char with an even number of lines
+	(possibly with a larger stride for memory alignment), followed immediately by an array of unsigned char containing interleaved Cb and Cr
+	samples (such that if addressed as a little-endian WORD type, Cb(U) would be in the LSBs and Cr(V) would be in the MSBs) with the same total
+	stride as the Y samples. This is the preferred 4:2:0 pixel format"
+e.g. YYYYYYYY YYYYYYYY YYYYYYYY YYYYYYYY UVUVUVUV UVUVUVUV
+
+NV21(aka YCrCb format. the default format for camera preview images)
+YUV 4:2:0 image with a plane of 8 bit Y samples followed by an interleaved V/U plane containing 8 bit 2x2 subsampled chroma samples.
+The same as NV12 except the interleave order of U and V is reversed.
+e.g. YYYYYYYY YYYYYYYY YYYYYYYY YYYYYYYY VUVUVUVU VUVUVUVU
+To convert Y'UV to RGB :
+ matrix from:
+ |R|   | 298    0     409 | | Y'- 16  |
+ |G| = | 298  -100   -208 | | U - 128 |
+ |B|   | 298   516     0  | | V - 128 |
+ then shift 8 bits, i.e.
+
+ in integer math:
+ R = clamp((298*(Y'-16)+409*(V-128)+128)>>8)
+ G = clamp((298*(Y'-16)-100*(U-128)-208*(V-128)+128)>>8)
+ B = clamp((298*(Y'-16)+516*(U-128)+128)>>8)
+
+ to encode RGB to Y'UV..
+ Y' = (( 66 * R + 129 * G +  25 * B + 128) >> 8) +  16
+ U  = ((-38 * R -  74 * G + 112 * B + 128) >> 8) + 128
+ V  = ((112 * R -  94 * G -  18 * B + 128) >> 8) + 128
+ */
+
+//
+// [in]
+//		alpha : alpha value if rgba
+//		yuv : nv21 image(size=width*height*3/2)
+//      width : must be even
+//      height = must be even
+// [out]
+//      rgb : rgb buffer(size>=width*height*3) byte order : R0 G0 B0  R1 G1 B1  R2 G2 B2
+//		rgba : rgba buffer(size>=width*height*4) byte order : R0 G0 B0 A0  R1 G1 B1 A1  R2 G2 B2 A2
+void nv21_to_rgb(unsigned char* rgb, unsigned char const* nv21, int width, int height);
+void nv21_to_rgba(unsigned char* rgba, unsigned char alpha, unsigned char const* nv21, int width, int height);
+
+// OpenCV style
+void nv21_to_bgr(unsigned char* bgr, unsigned char const* nv21, int width, int height);
+void nv21_to_bgra(unsigned char* bgra, unsigned char alpha, unsigned char const* nv21, int width, int height);
+
+//
+//
+// to make the buile in android(activate neon), either...
+// method 1)
+//       ifeq ($(TARGET_ARCH_ABI),armeabi-v7a)
+//			LOCAL_CFLAGS += -DARM_NEON_ENABLE -mfpu=neon -flax-vector-conversions
+//       endif
+//       LOCAL_SRC_FILES += yuv2rgb.cpp
+//
+// (note ARM_NEON_ENABLE is defined, in case you'd like to exclude neon stuff from the build)
+//
+// method 2) (use funny suffix as NDK suggestted)
+//		ifeq ($(TARGET_ARCH_ABI),armeabi-v7a)
+//			LOCAL_CFLAGS += -DARM_NEON_ENABLE -flax-vector-conversions
+//			LOCAL_SRC_FILES += yuv2rgb.cpp.neon
+//		else
+//			LOCAL_SRC_FILES += yuv2rgb.cpp
+//		endif
+//
+// this compiles on GCC(android), Xcode(iOS).
+//
+
diff --git a/library/src/main/java/jp/co/cyberagent/android/gpuimage/GPUImageNativeLibrary.java b/library/src/main/java/jp/co/cyberagent/android/gpuimage/GPUImageNativeLibrary.java
index 0a171c7d..b88a9237 100644
--- a/library/src/main/java/jp/co/cyberagent/android/gpuimage/GPUImageNativeLibrary.java
+++ b/library/src/main/java/jp/co/cyberagent/android/gpuimage/GPUImageNativeLibrary.java
@@ -28,4 +28,6 @@
     public static native void YUVtoARBG(byte[] yuv, int width, int height, int[] out);
 
     public static native void adjustBitmap(Bitmap srcBitmap);
+
+    public static native void YUVtoRGBANEON(byte[] yuv, int width, int height, int[] out);
 }
diff --git a/library/src/main/java/jp/co/cyberagent/android/gpuimage/GPUImageRenderer.java b/library/src/main/java/jp/co/cyberagent/android/gpuimage/GPUImageRenderer.java
index e8cd690b..4735a146 100644
--- a/library/src/main/java/jp/co/cyberagent/android/gpuimage/GPUImageRenderer.java
+++ b/library/src/main/java/jp/co/cyberagent/android/gpuimage/GPUImageRenderer.java
@@ -24,6 +24,7 @@
 import android.hardware.Camera.Size;
 import android.opengl.GLES20;
 import android.opengl.GLSurfaceView;
+import android.util.Log;
 
 import java.io.IOException;
 import java.nio.ByteBuffer;
@@ -36,6 +37,7 @@
 import javax.microedition.khronos.egl.EGLConfig;
 import javax.microedition.khronos.opengles.GL10;
 
+import hugo.weaving.DebugLog;
 import jp.co.cyberagent.android.gpuimage.filter.GPUImageFilter;
 import jp.co.cyberagent.android.gpuimage.util.OpenGlUtils;
 import jp.co.cyberagent.android.gpuimage.util.Rotation;
@@ -44,32 +46,27 @@
 import static jp.co.cyberagent.android.gpuimage.util.TextureRotationUtil.TEXTURE_NO_ROTATION;
 
 public class GPUImageRenderer implements GLSurfaceView.Renderer, GLTextureView.Renderer, PreviewCallback {
-    private static final int NO_IMAGE = -1;
     public static final float CUBE[] = {
             -1.0f, -1.0f,
             1.0f, -1.0f,
             -1.0f, 1.0f,
             1.0f, 1.0f,
     };
-
-    private GPUImageFilter filter;
-
+    private static final int NO_IMAGE = -1;
     public final Object surfaceChangedWaiter = new Object();
-
-    private int glTextureId = NO_IMAGE;
-    private SurfaceTexture surfaceTexture = null;
     private final FloatBuffer glCubeBuffer;
     private final FloatBuffer glTextureBuffer;
+    private final Queue<Runnable> runOnDraw;
+    private final Queue<Runnable> runOnDrawEnd;
+    private GPUImageFilter filter;
+    private int glTextureId = NO_IMAGE;
+    private SurfaceTexture surfaceTexture = null;
     private IntBuffer glRgbBuffer;
-
     private int outputWidth;
     private int outputHeight;
     private int imageWidth;
     private int imageHeight;
     private int addedPadding;
-
-    private final Queue<Runnable> runOnDraw;
-    private final Queue<Runnable> runOnDrawEnd;
     private Rotation rotation;
     private boolean flipHorizontal;
     private boolean flipVertical;
@@ -116,10 +113,13 @@ public void onSurfaceChanged(final GL10 gl, final int width, final int height) {
     }
 
     @Override
+    @DebugLog
     public void onDrawFrame(final GL10 gl) {
         GLES20.glClear(GLES20.GL_COLOR_BUFFER_BIT | GLES20.GL_DEPTH_BUFFER_BIT);
         runAll(runOnDraw);
+        long time = System.currentTimeMillis();
         filter.onDraw(glTextureId, glCubeBuffer, glTextureBuffer);
+        Log.d("zcc", "draw filter cost : " + (System.currentTimeMillis() - time));
         runAll(runOnDrawEnd);
         if (surfaceTexture != null) {
             surfaceTexture.updateTexImage();
@@ -139,6 +139,7 @@ public void setBackgroundColor(float red, float green, float blue) {
         backgroundBlue = blue;
     }
 
+    @DebugLog
     private void runAll(Queue<Runnable> queue) {
         synchronized (queue) {
             while (!queue.isEmpty()) {
@@ -161,8 +162,12 @@ public void onPreviewFrame(final byte[] data, final int width, final int height)
             runOnDraw(new Runnable() {
                 @Override
                 public void run() {
-                    GPUImageNativeLibrary.YUVtoRBGA(data, width, height, glRgbBuffer.array());
+                    long time = System.currentTimeMillis();
+                    GPUImageNativeLibrary.YUVtoRGBANEON(data, width, height, glRgbBuffer.array());
+                    Log.d("zcc", "yuv to rgba cost" + (System.currentTimeMillis() - time));
+                    time = System.currentTimeMillis();
                     glTextureId = OpenGlUtils.loadTexture(glRgbBuffer, width, height, glTextureId);
+                    Log.d("zcc", " load to texture cost " + (System.currentTimeMillis() - time));
 
                     if (imageWidth != width) {
                         imageWidth = width;
@@ -323,11 +328,6 @@ public void setRotationCamera(final Rotation rotation, final boolean flipHorizon
         setRotation(rotation, flipVertical, flipHorizontal);
     }
 
-    public void setRotation(final Rotation rotation) {
-        this.rotation = rotation;
-        adjustImageScaling();
-    }
-
     public void setRotation(final Rotation rotation,
                             final boolean flipHorizontal, final boolean flipVertical) {
         this.flipHorizontal = flipHorizontal;
@@ -339,6 +339,11 @@ public Rotation getRotation() {
         return rotation;
     }
 
+    public void setRotation(final Rotation rotation) {
+        this.rotation = rotation;
+        adjustImageScaling();
+    }
+
     public boolean isFlippedHorizontally() {
         return flipHorizontal;
     }
