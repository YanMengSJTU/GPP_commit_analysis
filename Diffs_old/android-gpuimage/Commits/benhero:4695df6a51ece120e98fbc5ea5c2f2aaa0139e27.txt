diff --git a/library/src/jp/co/cyberagent/android/gpuimage/GPUImage.java b/library/src/jp/co/cyberagent/android/gpuimage/GPUImage.java
index 8392a5a9..33c2d780 100644
--- a/library/src/jp/co/cyberagent/android/gpuimage/GPUImage.java
+++ b/library/src/jp/co/cyberagent/android/gpuimage/GPUImage.java
@@ -39,10 +39,13 @@
 import android.view.Display;
 import android.view.WindowManager;
 
-import java.io.*;
+import java.io.File;
+import java.io.FileNotFoundException;
+import java.io.FileOutputStream;
+import java.io.IOException;
+import java.io.InputStream;
 import java.net.URL;
 import java.util.List;
-import java.util.concurrent.Semaphore;
 
 /**
  * The main accessor for GPUImage functionality. This class helps to do common
@@ -103,9 +106,9 @@ public void setGLSurfaceView(final GLSurfaceView view) {
     /**
      * Sets the background color
      *
-     * @param red red color value
+     * @param red   red color value
      * @param green green color value
-     * @param blue red color value
+     * @param blue  red color value
      */
     public void setBackgroundColor(float red, float green, float blue) {
         mRenderer.setBackgroundColor(red, green, blue);
@@ -132,13 +135,13 @@ public void setUpCamera(final Camera camera) {
     /**
      * Sets the up camera to be connected to GPUImage to get a filtered preview.
      *
-     * @param camera the camera
-     * @param degrees by how many degrees the image should be rotated
+     * @param camera         the camera
+     * @param degrees        by how many degrees the image should be rotated
      * @param flipHorizontal if the image should be flipped horizontally
-     * @param flipVertical if the image should be flipped vertically
+     * @param flipVertical   if the image should be flipped vertically
      */
     public void setUpCamera(final Camera camera, final int degrees, final boolean flipHorizontal,
-            final boolean flipVertical) {
+                            final boolean flipVertical) {
         mGlSurfaceView.setRenderMode(GLSurfaceView.RENDERMODE_CONTINUOUSLY);
         if (Build.VERSION.SDK_INT > Build.VERSION_CODES.GINGERBREAD_MR1) {
             setUpCameraGingerbread(camera);
@@ -285,13 +288,13 @@ public Bitmap getBitmapWithFilterApplied(final Bitmap bitmap) {
 
                 @Override
                 public void run() {
-                    synchronized(mFilter) {
+                    synchronized (mFilter) {
                         mFilter.destroy();
                         mFilter.notify();
                     }
                 }
             });
-            synchronized(mFilter) {
+            synchronized (mFilter) {
                 requestRender();
                 try {
                     mFilter.wait();
@@ -329,12 +332,12 @@ public void run() {
      * bitmap. The order of the calls to the listener will be the same as the
      * filter order.
      *
-     * @param bitmap the bitmap on which the filters will be applied
-     * @param filters the filters which will be applied on the bitmap
+     * @param bitmap   the bitmap on which the filters will be applied
+     * @param filters  the filters which will be applied on the bitmap
      * @param listener the listener on which the results will be notified
      */
     public static void getBitmapForMultipleFilters(final Bitmap bitmap,
-            final List<GPUImageFilter> filters, final ResponseListener<Bitmap> listener) {
+                                                   final List<GPUImageFilter> filters, final ResponseListener<Bitmap> listener) {
         if (filters.isEmpty()) {
             return;
         }
@@ -355,7 +358,7 @@ public static void getBitmapForMultipleFilters(final Bitmap bitmap,
     /**
      * Deprecated: Please use
      * {@link GPUImageView#saveToPictures(String, String, jp.co.cyberagent.android.gpuimage.GPUImageView.OnPictureSavedListener)}
-     *
+     * <p>
      * Save current image with applied filter to Pictures. It will be stored on
      * the default Picture folder on the phone below the given folderName and
      * fileName. <br>
@@ -363,33 +366,33 @@ public static void getBitmapForMultipleFilters(final Bitmap bitmap,
      * listener.
      *
      * @param folderName the folder name
-     * @param fileName the file name
-     * @param listener the listener
+     * @param fileName   the file name
+     * @param listener   the listener
      */
     @Deprecated
     public void saveToPictures(final String folderName, final String fileName,
-            final OnPictureSavedListener listener) {
+                               final OnPictureSavedListener listener) {
         saveToPictures(mCurrentBitmap, folderName, fileName, listener);
     }
 
     /**
      * Deprecated: Please use
      * {@link GPUImageView#saveToPictures(String, String, jp.co.cyberagent.android.gpuimage.GPUImageView.OnPictureSavedListener)}
-     *
+     * <p>
      * Apply and save the given bitmap with applied filter to Pictures. It will
      * be stored on the default Picture folder on the phone below the given
      * folerName and fileName. <br>
      * This method is async and will notify when the image was saved through the
      * listener.
      *
-     * @param bitmap the bitmap
+     * @param bitmap     the bitmap
      * @param folderName the folder name
-     * @param fileName the file name
-     * @param listener the listener
+     * @param fileName   the file name
+     * @param listener   the listener
      */
     @Deprecated
     public void saveToPictures(final Bitmap bitmap, final String folderName, final String fileName,
-            final OnPictureSavedListener listener) {
+                               final OnPictureSavedListener listener) {
         new SaveTask(bitmap, folderName, fileName, listener).execute();
     }
 
@@ -438,7 +441,7 @@ private int getOutputHeight() {
         private final Handler mHandler;
 
         public SaveTask(final Bitmap bitmap, final String folderName, final String fileName,
-                final OnPictureSavedListener listener) {
+                        final OnPictureSavedListener listener) {
             mBitmap = bitmap;
             mFolderName = folderName;
             mFileName = fileName;
@@ -461,8 +464,8 @@ private void saveImage(final String folderName, final String fileName, final Bit
                 file.getParentFile().mkdirs();
                 image.compress(CompressFormat.JPEG, 80, new FileOutputStream(file));
                 MediaScannerConnection.scanFile(mContext,
-                        new String[] {
-                            file.toString()
+                        new String[]{
+                                file.toString()
                         }, null,
                         new MediaScannerConnection.OnScanCompletedListener() {
                             @Override
@@ -516,7 +519,7 @@ protected Bitmap decode(BitmapFactory.Options options) {
         @Override
         protected int getImageOrientation() throws IOException {
             Cursor cursor = mContext.getContentResolver().query(mUri,
-                    new String[] { MediaStore.Images.ImageColumns.ORIENTATION }, null, null, null);
+                    new String[]{MediaStore.Images.ImageColumns.ORIENTATION}, null, null, null);
 
             if (cursor == null || cursor.getCount() != 1) {
                 return 0;
@@ -713,5 +716,14 @@ private Bitmap rotateImage(final Bitmap bitmap) {
         void response(T item);
     }
 
-    public enum ScaleType { CENTER_INSIDE, CENTER_CROP }
+    public enum ScaleType {
+        /**
+         * 居中填充
+         */
+        CENTER_INSIDE,
+        /**
+         * 铺满容器，部分裁剪
+         */
+        CENTER_CROP
+    }
 }
diff --git a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageFilterGroup.java b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageFilterGroup.java
index 10ea41ca..1e65e728 100644
--- a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageFilterGroup.java
+++ b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageFilterGroup.java
@@ -18,7 +18,6 @@
 
 import android.annotation.SuppressLint;
 import android.opengl.GLES20;
-import jp.co.cyberagent.android.gpuimage.util.TextureRotationUtil;
 
 import java.nio.ByteBuffer;
 import java.nio.ByteOrder;
@@ -26,6 +25,8 @@
 import java.util.ArrayList;
 import java.util.List;
 
+import jp.co.cyberagent.android.gpuimage.util.TextureRotationUtil;
+
 import static jp.co.cyberagent.android.gpuimage.GPUImageRenderer.CUBE;
 import static jp.co.cyberagent.android.gpuimage.util.TextureRotationUtil.TEXTURE_NO_ROTATION;
 
@@ -34,14 +35,28 @@
  * other.
  */
 public class GPUImageFilterGroup extends GPUImageFilter {
-
-    protected List<GPUImageFilter> mFilters;
-    protected List<GPUImageFilter> mMergedFilters;
+    /**
+     * 多层级的滤镜列表，包含了group
+     */
+    protected List<GPUImageFilter> mFilters = new ArrayList<>();
+    /**
+     * 单层级的滤镜列表，不包含group，拆分自mFilters
+     */
+    protected List<GPUImageFilter> mMergedFilters = new ArrayList<>();
     private int[] mFrameBuffers;
     private int[] mFrameBufferTextures;
 
+    /**
+     * 位置坐标
+     */
     private final FloatBuffer mGLCubeBuffer;
+    /**
+     * 纹理坐标
+     */
     private final FloatBuffer mGLTextureBuffer;
+    /**
+     * TODO : 处理纹理翻转
+     */
     private final FloatBuffer mGLTextureFlipBuffer;
 
     /**
@@ -57,12 +72,8 @@ public GPUImageFilterGroup() {
      * @param filters the filters which represent this filter
      */
     public GPUImageFilterGroup(List<GPUImageFilter> filters) {
-        mFilters = filters;
-        if (mFilters == null) {
-            mFilters = new ArrayList<GPUImageFilter>();
-        } else {
-            updateMergedFilters();
-        }
+        mFilters.addAll(filters);
+        updateMergedFilters();
 
         mGLCubeBuffer = ByteBuffer.allocateDirect(CUBE.length * 4)
                 .order(ByteOrder.nativeOrder())
@@ -81,18 +92,14 @@ public GPUImageFilterGroup(List<GPUImageFilter> filters) {
         mGLTextureFlipBuffer.put(flipTexture).position(0);
     }
 
-    public void addFilter(GPUImageFilter aFilter) {
-        if (aFilter == null) {
+    public void addFilter(GPUImageFilter filter) {
+        if (filter == null) {
             return;
         }
-        mFilters.add(aFilter);
+        mFilters.add(filter);
         updateMergedFilters();
     }
 
-    /*
-     * (non-Javadoc)
-     * @see jp.co.cyberagent.android.gpuimage.GPUImageFilter#onInit()
-     */
     @Override
     public void onInit() {
         super.onInit();
@@ -101,20 +108,16 @@ public void onInit() {
         }
     }
 
-    /*
-     * (non-Javadoc)
-     * @see jp.co.cyberagent.android.gpuimage.GPUImageFilter#onDestroy()
-     */
     @Override
     public void onDestroy() {
-        destroyFramebuffers();
+        destroyFrameBuffers();
         for (GPUImageFilter filter : mFilters) {
             filter.destroy();
         }
         super.onDestroy();
     }
 
-    private void destroyFramebuffers() {
+    private void destroyFrameBuffers() {
         if (mFrameBufferTextures != null) {
             GLES20.glDeleteTextures(mFrameBufferTextures.length, mFrameBufferTextures, 0);
             mFrameBufferTextures = null;
@@ -125,17 +128,11 @@ private void destroyFramebuffers() {
         }
     }
 
-    /*
-     * (non-Javadoc)
-     * @see
-     * jp.co.cyberagent.android.gpuimage.GPUImageFilter#onOutputSizeChanged(int,
-     * int)
-     */
     @Override
     public void onOutputSizeChanged(final int width, final int height) {
         super.onOutputSizeChanged(width, height);
         if (mFrameBuffers != null) {
-            destroyFramebuffers();
+            destroyFrameBuffers();
         }
 
         int size = mFilters.size();
@@ -148,12 +145,19 @@ public void onOutputSizeChanged(final int width, final int height) {
             mFrameBuffers = new int[size - 1];
             mFrameBufferTextures = new int[size - 1];
 
+            // 创建FrameBuffer
             for (int i = 0; i < size - 1; i++) {
+                // 1. 创建FrameBuffer
                 GLES20.glGenFramebuffers(1, mFrameBuffers, i);
+                // 2. 生成纹理对象
                 GLES20.glGenTextures(1, mFrameBufferTextures, i);
+                // 3. 绑定纹理对象
                 GLES20.glBindTexture(GLES20.GL_TEXTURE_2D, mFrameBufferTextures[i]);
+                // 4. 设置纹理对象的相关信息：颜色模式、大小
                 GLES20.glTexImage2D(GLES20.GL_TEXTURE_2D, 0, GLES20.GL_RGBA, width, height, 0,
                         GLES20.GL_RGBA, GLES20.GL_UNSIGNED_BYTE, null);
+
+                // 纹理过滤参数设置
                 GLES20.glTexParameterf(GLES20.GL_TEXTURE_2D,
                         GLES20.GL_TEXTURE_MAG_FILTER, GLES20.GL_LINEAR);
                 GLES20.glTexParameterf(GLES20.GL_TEXTURE_2D,
@@ -163,22 +167,21 @@ public void onOutputSizeChanged(final int width, final int height) {
                 GLES20.glTexParameterf(GLES20.GL_TEXTURE_2D,
                         GLES20.GL_TEXTURE_WRAP_T, GLES20.GL_CLAMP_TO_EDGE);
 
+                // 绑定FrameBuffer
                 GLES20.glBindFramebuffer(GLES20.GL_FRAMEBUFFER, mFrameBuffers[i]);
+                // 将纹理对象挂载到FrameBuffer上，存储颜色信息
                 GLES20.glFramebufferTexture2D(GLES20.GL_FRAMEBUFFER, GLES20.GL_COLOR_ATTACHMENT0,
                         GLES20.GL_TEXTURE_2D, mFrameBufferTextures[i], 0);
 
+                // 解绑纹理
                 GLES20.glBindTexture(GLES20.GL_TEXTURE_2D, 0);
+                // 解绑FrameBuffer
                 GLES20.glBindFramebuffer(GLES20.GL_FRAMEBUFFER, 0);
             }
         }
     }
 
-    /*
-     * (non-Javadoc)
-     * @see jp.co.cyberagent.android.gpuimage.GPUImageFilter#onDraw(int,
-     * java.nio.FloatBuffer, java.nio.FloatBuffer)
-     */
-    @SuppressLint("WrongCall")    
+    @SuppressLint("WrongCall")
     @Override
     public void onDraw(final int textureId, final FloatBuffer cubeBuffer,
                        final FloatBuffer textureBuffer) {
@@ -186,32 +189,30 @@ public void onDraw(final int textureId, final FloatBuffer cubeBuffer,
         if (!isInitialized() || mFrameBuffers == null || mFrameBufferTextures == null) {
             return;
         }
-        if (mMergedFilters != null) {
-            int size = mMergedFilters.size();
-            int previousTexture = textureId;
-            for (int i = 0; i < size; i++) {
-                GPUImageFilter filter = mMergedFilters.get(i);
-                boolean isNotLast = i < size - 1;
-                if (isNotLast) {
-                    GLES20.glBindFramebuffer(GLES20.GL_FRAMEBUFFER, mFrameBuffers[i]);
-                    GLES20.glClearColor(0, 0, 0, 0);
-                }
-
-                if (i == 0) {
-                    filter.onDraw(previousTexture, cubeBuffer, textureBuffer);
-                } else if (i == size - 1) {
-                    filter.onDraw(previousTexture, mGLCubeBuffer, (size % 2 == 0) ? mGLTextureFlipBuffer : mGLTextureBuffer);
-                } else {
-                    filter.onDraw(previousTexture, mGLCubeBuffer, mGLTextureBuffer);
-                }
-
-                if (isNotLast) {
-                    GLES20.glBindFramebuffer(GLES20.GL_FRAMEBUFFER, 0);
-                    previousTexture = mFrameBufferTextures[i];
-                }
+        int size = mMergedFilters.size();
+        int previousTexture = textureId;
+        for (int i = 0; i < size; i++) {
+            GPUImageFilter filter = mMergedFilters.get(i);
+            boolean isNotLast = i < size - 1;
+            if (isNotLast) {
+                GLES20.glBindFramebuffer(GLES20.GL_FRAMEBUFFER, mFrameBuffers[i]);
+                GLES20.glClearColor(0, 0, 0, 0);
+            }
+
+            if (i == 0) {
+                filter.onDraw(previousTexture, cubeBuffer, textureBuffer);
+            } else if (i == size - 1) {
+                filter.onDraw(previousTexture, mGLCubeBuffer, (size % 2 == 0) ? mGLTextureFlipBuffer : mGLTextureBuffer);
+            } else {
+                filter.onDraw(previousTexture, mGLCubeBuffer, mGLTextureBuffer);
+            }
+
+            if (isNotLast) {
+                GLES20.glBindFramebuffer(GLES20.GL_FRAMEBUFFER, 0);
+                previousTexture = mFrameBufferTextures[i];
             }
         }
-     }
+    }
 
     /**
      * Gets the filters.
@@ -227,16 +228,10 @@ public void onDraw(final int textureId, final FloatBuffer cubeBuffer,
     }
 
     public void updateMergedFilters() {
-        if (mFilters == null) {
+        if (mFilters.isEmpty()) {
             return;
         }
-
-        if (mMergedFilters == null) {
-            mMergedFilters = new ArrayList<GPUImageFilter>();
-        } else {
-            mMergedFilters.clear();
-        }
-
+        mMergedFilters.clear();
         List<GPUImageFilter> filters;
         for (GPUImageFilter filter : mFilters) {
             if (filter instanceof GPUImageFilterGroup) {
diff --git a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageRenderer.java b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageRenderer.java
index 691550bd..69e8cc9b 100644
--- a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageRenderer.java
+++ b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageRenderer.java
@@ -26,10 +26,6 @@
 import android.opengl.GLES20;
 import android.opengl.GLSurfaceView.Renderer;
 
-import jp.co.cyberagent.android.gpuimage.util.TextureRotationUtil;
-
-import javax.microedition.khronos.egl.EGLConfig;
-import javax.microedition.khronos.opengles.GL10;
 import java.io.IOException;
 import java.nio.ByteBuffer;
 import java.nio.ByteOrder;
@@ -38,6 +34,11 @@
 import java.util.LinkedList;
 import java.util.Queue;
 
+import javax.microedition.khronos.egl.EGLConfig;
+import javax.microedition.khronos.opengles.GL10;
+
+import jp.co.cyberagent.android.gpuimage.util.TextureRotationUtil;
+
 import static jp.co.cyberagent.android.gpuimage.util.TextureRotationUtil.TEXTURE_NO_ROTATION;
 
 @TargetApi(11)
@@ -66,7 +67,13 @@
     private int mImageHeight;
     private int mAddedPadding;
 
+    /**
+     * 绘制前的任务队列
+     */
     private final Queue<Runnable> mRunOnDraw;
+    /**
+     * 绘制后的任务队列
+     */
     private final Queue<Runnable> mRunOnDrawEnd;
     private Rotation mRotation;
     private boolean mFlipHorizontal;
@@ -124,12 +131,20 @@ public void onDrawFrame(final GL10 gl) {
         }
     }
 
+    private void runAll(Queue<Runnable> queue) {
+        synchronized (queue) {
+            while (!queue.isEmpty()) {
+                queue.poll().run();
+            }
+        }
+    }
+
     /**
-     * Sets the background color
+     * 设置背景色
      *
-     * @param red red color value
+     * @param red   red color value
      * @param green green color value
-     * @param blue red color value
+     * @param blue  red color value
      */
     public void setBackgroundColor(float red, float green, float blue) {
         mBackgroundRed = red;
@@ -137,14 +152,6 @@ public void setBackgroundColor(float red, float green, float blue) {
         mBackgroundBlue = blue;
     }
 
-    private void runAll(Queue<Runnable> queue) {
-        synchronized (queue) {
-            while (!queue.isEmpty()) {
-                queue.poll().run();
-            }
-        }
-    }
-
     @Override
     public void onPreviewFrame(final byte[] data, final Camera camera) {
         final Size previewSize = camera.getParameters().getPreviewSize();
@@ -155,14 +162,17 @@ public void onPreviewFrame(final byte[] data, final Camera camera) {
             runOnDraw(new Runnable() {
                 @Override
                 public void run() {
+                    // YUV数据转RGBA格式
                     GPUImageNativeLibrary.YUVtoRBGA(data, previewSize.width, previewSize.height,
                             mGLRgbBuffer.array());
+                    // 加载纹理ID
                     mGLTextureId = OpenGlUtils.loadTexture(mGLRgbBuffer, previewSize, mGLTextureId);
                     camera.addCallbackBuffer(data);
 
-                    if (mImageWidth != previewSize.width) {
+                    if (mImageWidth != previewSize.width || mImageHeight != previewSize.height) {
                         mImageWidth = previewSize.width;
                         mImageHeight = previewSize.height;
+                        // 预览尺寸发生改变
                         adjustImageScaling();
                     }
                 }
@@ -188,9 +198,11 @@ public void run() {
         });
     }
 
+    /**
+     * 设置新的滤镜：对旧的滤镜进行销毁操作，对新的滤镜进行初始化操作
+     */
     public void setFilter(final GPUImageFilter filter) {
         runOnDraw(new Runnable() {
-
             @Override
             public void run() {
                 final GPUImageFilter oldFilter = mFilter;
@@ -205,9 +217,11 @@ public void run() {
         });
     }
 
+    /**
+     * 销毁原有的图片纹理
+     */
     public void deleteImage() {
         runOnDraw(new Runnable() {
-
             @Override
             public void run() {
                 GLES20.glDeleteTextures(1, new int[]{
@@ -222,6 +236,11 @@ public void setImageBitmap(final Bitmap bitmap) {
         setImageBitmap(bitmap, true);
     }
 
+    /**
+     * 设置图片Bitmap
+     *
+     * @param recycle 生成纹理Id后，是否立刻回收Bitmap对象
+     */
     public void setImageBitmap(final Bitmap bitmap, final boolean recycle) {
         if (bitmap == null) {
             return;
@@ -233,6 +252,7 @@ public void setImageBitmap(final Bitmap bitmap, final boolean recycle) {
             public void run() {
                 Bitmap resizedBitmap = null;
                 if (bitmap.getWidth() % 2 == 1) {
+                    // 对于长或宽为奇数的做处理
                     resizedBitmap = Bitmap.createBitmap(bitmap.getWidth() + 1, bitmap.getHeight(),
                             Bitmap.Config.ARGB_8888);
                     Canvas can = new Canvas(resizedBitmap);
@@ -283,6 +303,7 @@ private void adjustImageScaling() {
 
         float ratioWidth = imageWidthNew / outputWidth;
         float ratioHeight = imageHeightNew / outputHeight;
+        // 以上都是计算出图片缩放到容器上后，占容器的比例值，用于下面正确地绘制到容器的位置上
 
         float[] cube = CUBE;
         float[] textureCords = TextureRotationUtil.getRotation(mRotation, mFlipHorizontal, mFlipVertical);
@@ -315,7 +336,7 @@ private float addDistance(float coordinate, float distance) {
     }
 
     public void setRotationCamera(final Rotation rotation, final boolean flipHorizontal,
-            final boolean flipVertical) {
+                                  final boolean flipVertical) {
         setRotation(rotation, flipVertical, flipHorizontal);
     }
 
diff --git a/library/src/jp/co/cyberagent/android/gpuimage/OpenGlUtils.java b/library/src/jp/co/cyberagent/android/gpuimage/OpenGlUtils.java
index e8589704..81d943bc 100644
--- a/library/src/jp/co/cyberagent/android/gpuimage/OpenGlUtils.java
+++ b/library/src/jp/co/cyberagent/android/gpuimage/OpenGlUtils.java
@@ -16,8 +16,6 @@
 
 package jp.co.cyberagent.android.gpuimage;
 
-import java.nio.IntBuffer;
-
 import android.graphics.Bitmap;
 import android.graphics.Bitmap.Config;
 import android.hardware.Camera.Size;
@@ -25,6 +23,8 @@
 import android.opengl.GLUtils;
 import android.util.Log;
 
+import java.nio.IntBuffer;
+
 public class OpenGlUtils {
     public static final int NO_TEXTURE = -1;
 
@@ -32,6 +32,13 @@ public static int loadTexture(final Bitmap img, final int usedTexId) {
         return loadTexture(img, usedTexId, true);
     }
 
+    /**
+     * 加载纹理ID
+     *
+     * @param img       Bitmap
+     * @param usedTexId 已使用的纹理ID
+     * @param recycle   是否回收Bitmap
+     */
     public static int loadTexture(final Bitmap img, final int usedTexId, final boolean recycle) {
         int textures[] = new int[1];
         if (usedTexId == NO_TEXTURE) {
