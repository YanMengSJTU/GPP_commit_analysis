diff --git a/build.gradle b/build.gradle
index 1e3515e0..ebed5c00 100644
--- a/build.gradle
+++ b/build.gradle
@@ -7,7 +7,7 @@ buildscript {
         jcenter()
     }
     dependencies {
-        classpath 'com.android.tools.build:gradle:3.4.0-alpha02'
+        classpath 'com.android.tools.build:gradle:3.2.1'
         classpath 'com.jfrog.bintray.gradle:gradle-bintray-plugin:1.8.4'
         classpath 'com.github.dcendents:android-maven-gradle-plugin:2.1'
         classpath "org.jetbrains.kotlin:kotlin-gradle-plugin:$kotlin_version"
diff --git a/library/src/main/java/jp/co/cyberagent/android/gpuimage/GPUImage.java b/library/src/main/java/jp/co/cyberagent/android/gpuimage/GPUImage.java
index 962451d3..609917eb 100644
--- a/library/src/main/java/jp/co/cyberagent/android/gpuimage/GPUImage.java
+++ b/library/src/main/java/jp/co/cyberagent/android/gpuimage/GPUImage.java
@@ -80,7 +80,7 @@ public GPUImage(final Context context) {
 
         this.context = context;
         filter = new GPUImageFilter();
-        renderer = new GPUImageRenderer(filter);
+        renderer = new GPUImageRenderer(context,filter);
     }
 
     /**
@@ -363,7 +363,7 @@ public void run() {
             }
         }
 
-        GPUImageRenderer renderer = new GPUImageRenderer(filter);
+        GPUImageRenderer renderer = new GPUImageRenderer(this.context,filter);
         renderer.setRotation(Rotation.NORMAL,
                 this.renderer.isFlippedHorizontally(), this.renderer.isFlippedVertically());
         renderer.setScaleType(scaleType);
@@ -400,7 +400,7 @@ public static void getBitmapForMultipleFilters(final Bitmap bitmap,
         if (filters.isEmpty()) {
             return;
         }
-        GPUImageRenderer renderer = new GPUImageRenderer(filters.get(0));
+        GPUImageRenderer renderer = new GPUImageRenderer(null,filters.get(0));
         renderer.setImageBitmap(bitmap, false);
         PixelBuffer buffer = new PixelBuffer(bitmap.getWidth(), bitmap.getHeight());
         buffer.setRenderer(renderer);
diff --git a/library/src/main/java/jp/co/cyberagent/android/gpuimage/GPUImageRenderer.java b/library/src/main/java/jp/co/cyberagent/android/gpuimage/GPUImageRenderer.java
index e8cd690b..d8cec930 100644
--- a/library/src/main/java/jp/co/cyberagent/android/gpuimage/GPUImageRenderer.java
+++ b/library/src/main/java/jp/co/cyberagent/android/gpuimage/GPUImageRenderer.java
@@ -16,14 +16,17 @@
 
 package jp.co.cyberagent.android.gpuimage;
 
+import android.content.Context;
 import android.graphics.Bitmap;
 import android.graphics.Canvas;
+import android.graphics.ImageFormat;
 import android.graphics.SurfaceTexture;
 import android.hardware.Camera;
 import android.hardware.Camera.PreviewCallback;
 import android.hardware.Camera.Size;
 import android.opengl.GLES20;
 import android.opengl.GLSurfaceView;
+import android.util.Log;
 
 import java.io.IOException;
 import java.nio.ByteBuffer;
@@ -42,6 +45,7 @@
 import jp.co.cyberagent.android.gpuimage.util.TextureRotationUtil;
 
 import static jp.co.cyberagent.android.gpuimage.util.TextureRotationUtil.TEXTURE_NO_ROTATION;
+import android.renderscript.*;
 
 public class GPUImageRenderer implements GLSurfaceView.Renderer, GLTextureView.Renderer, PreviewCallback {
     private static final int NO_IMAGE = -1;
@@ -79,7 +83,16 @@
     private float backgroundGreen = 0;
     private float backgroundBlue = 0;
 
-    public GPUImageRenderer(final GPUImageFilter filter) {
+    private RenderScript rs;
+    private ScriptIntrinsicYuvToRGB yuvToRGBIntrinsic;
+    private Type.Builder yuvType, rgbaType;
+    private Allocation in,out;
+    private  Context context;
+    private byte[]previewBuffer;
+    private ByteBuffer previewByteBuffer;
+
+
+    public GPUImageRenderer(final Context ctx, final GPUImageFilter filter) {
         this.filter = filter;
         runOnDraw = new LinkedList<>();
         runOnDrawEnd = new LinkedList<>();
@@ -93,8 +106,12 @@ public GPUImageRenderer(final GPUImageFilter filter) {
                 .order(ByteOrder.nativeOrder())
                 .asFloatBuffer();
         setRotation(Rotation.NORMAL, false, false);
+        context = ctx;
     }
 
+
+
+
     @Override
     public void onSurfaceCreated(final GL10 unused, final EGLConfig config) {
         GLES20.glClearColor(backgroundRed, backgroundGreen, backgroundBlue, 1);
@@ -153,16 +170,54 @@ public void onPreviewFrame(final byte[] data, final Camera camera) {
         onPreviewFrame(data, previewSize.width, previewSize.height);
     }
 
+
+
+    private void initRenderScript(final Context ctx, int w, int h){
+
+        Log.v("renderscript","initRenderScript");
+        rs = RenderScript.create(ctx);
+
+        yuvToRGBIntrinsic = ScriptIntrinsicYuvToRGB.create(rs,Element.U8_4(rs));
+
+        yuvType = new Type.Builder(rs, Element.U8(rs)).setX(w).
+                setY(h).setMipmaps(false).setYuvFormat(ImageFormat.NV21);
+        in = Allocation.createTyped(rs, yuvType.create(), Allocation.USAGE_SCRIPT);
+
+        rgbaType = new Type.Builder(rs, Element.RGBA_8888(rs)).setX(w).
+                setY(h).setMipmaps(false);
+        out = Allocation.createTyped(rs, rgbaType.create(), Allocation.USAGE_SCRIPT);
+
+        previewBuffer = new byte[w*h*4];
+        previewByteBuffer = ByteBuffer.allocate(w*h*4);
+    }
+
     public void onPreviewFrame(final byte[] data, final int width, final int height) {
         if (glRgbBuffer == null) {
             glRgbBuffer = IntBuffer.allocate(width * height);
         }
+
+        if(rs == null){
+            initRenderScript(this.context, width, height);
+        }
+
         if (runOnDraw.isEmpty()) {
             runOnDraw(new Runnable() {
                 @Override
                 public void run() {
-                    GPUImageNativeLibrary.YUVtoRBGA(data, width, height, glRgbBuffer.array());
-                    glTextureId = OpenGlUtils.loadTexture(glRgbBuffer, width, height, glTextureId);
+
+                    // convert yuv to rgb
+                    in.copyFrom(data);
+                    yuvToRGBIntrinsic.setInput(in);
+                    yuvToRGBIntrinsic.forEach(out);
+                    out.copyTo(previewBuffer);
+                    synchronized (this) {
+                        previewByteBuffer.clear();
+                        previewByteBuffer.put(previewBuffer);
+                    }
+
+                    previewByteBuffer.clear(); // 为啥不加这句会crash？？？
+
+                    glTextureId = OpenGlUtils.loadTexture(previewByteBuffer, width, height, glTextureId);
 
                     if (imageWidth != width) {
                         imageWidth = width;
diff --git a/library/src/main/java/jp/co/cyberagent/android/gpuimage/util/OpenGlUtils.java b/library/src/main/java/jp/co/cyberagent/android/gpuimage/util/OpenGlUtils.java
index efb810a8..20d106c8 100644
--- a/library/src/main/java/jp/co/cyberagent/android/gpuimage/util/OpenGlUtils.java
+++ b/library/src/main/java/jp/co/cyberagent/android/gpuimage/util/OpenGlUtils.java
@@ -23,6 +23,7 @@
 import android.opengl.GLUtils;
 import android.util.Log;
 
+import java.nio.ByteBuffer;
 import java.nio.IntBuffer;
 
 public class OpenGlUtils {
@@ -58,7 +59,7 @@ public static int loadTexture(final Bitmap img, final int usedTexId, final boole
         return textures[0];
     }
 
-    public static int loadTexture(final IntBuffer data, final int width, final int height, final int usedTexId) {
+    public static int loadTexture(final ByteBuffer data, final int width, final int height, final int usedTexId) {
         int textures[] = new int[1];
         if (usedTexId == NO_TEXTURE) {
             GLES20.glGenTextures(1, textures, 0);
