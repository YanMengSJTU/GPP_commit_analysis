diff --git a/build.gradle b/build.gradle
index 30d37363..812762da 100644
--- a/build.gradle
+++ b/build.gradle
@@ -13,6 +13,7 @@ allprojects {
     repositories {
         jcenter()
         maven { url("https://oss.sonatype.org/content/repositories/snapshots/") }
+        maven { url "https://jitpack.io" }
     }
     tasks.withType(JavaCompile) {
         options.encoding = 'UTF-8'
diff --git a/gradle.properties b/gradle.properties
index abbd5c42..fea483de 100644
--- a/gradle.properties
+++ b/gradle.properties
@@ -16,7 +16,7 @@
 POM_SCM_URL=scm\:git@github.com\:CyberAgent/android-gpuimage.git
 POM_DEVELOPER_ID=pboos
 POM_LICENCE_DIST=repo
-MIN_SDK_VERSION=8
+MIN_SDK_VERSION=16
 POM_DEVELOPER_NAME=Patrick Boos
 POM_LICENCE_URL=http\://www.apache.org/licenses/LICENSE-2.0.txt
 POM_DESCRIPTION=Image filters for Android with OpenGL (based on GPUImage for iOS)
diff --git a/library/build.gradle b/library/build.gradle
index 387ea54a..fb6f9bd4 100644
--- a/library/build.gradle
+++ b/library/build.gradle
@@ -39,5 +39,23 @@ android {
         abortOnError false
     }
 
+    android.libraryVariants.all { variant ->
+        if (variant.buildType.isDebuggable()) {
+            return; // Skip debug builds.
+        }
+        task("javadoc${variant.name.capitalize()}", type: Javadoc) {
+            description "Generates Javadoc for $variant.name."
+            source = variant.javaCompile.source
+            ext.androidJar = System.getenv("ANDROID_HOME") + "/platforms/${android.compileSdkVersion}/android.jar"
+            classpath = files(variant.javaCompile.classpath.files) + files(ext.androidJar)
+        }
+
+        task("bundleJavadoc${variant.name.capitalize()}", type: Jar) {
+            description "Bundles Javadoc into zip for $variant.name."
+            classifier = "javadoc"
+            from tasks["javadoc${variant.name.capitalize()}"]
+        }
+    }
 }
 
+apply from: 'android-artifacts.gradle'
diff --git a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageFilter.java b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageFilter.java
index 7a8641aa..16cb436f 100644
--- a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageFilter.java
+++ b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageFilter.java
@@ -19,7 +19,9 @@
 import android.content.Context;
 import android.content.res.AssetManager;
 import android.graphics.PointF;
+import android.opengl.GLES11Ext;
 import android.opengl.GLES20;
+import android.util.Log;
 
 import java.io.InputStream;
 import java.nio.FloatBuffer;
@@ -38,8 +40,9 @@
             "    textureCoordinate = inputTextureCoordinate.xy;\n" +
             "}";
     public static final String NO_FILTER_FRAGMENT_SHADER = "" +
-            "varying highp vec2 textureCoordinate;\n" +
+            "precision mediump float;\n" +
             " \n" +
+            "varying vec2 textureCoordinate;\n" +
             "uniform sampler2D inputImageTexture;\n" +
             " \n" +
             "void main()\n" +
@@ -47,9 +50,10 @@
             "     gl_FragColor = texture2D(inputImageTexture, textureCoordinate);\n" +
             "}";
 
+
     private final LinkedList<Runnable> mRunOnDraw;
-    private final String mVertexShader;
-    private final String mFragmentShader;
+    private String mVertexShader;
+    private String mFragmentShader;
     protected int mGLProgId;
     protected int mGLAttribPosition;
     protected int mGLUniformTexture;
@@ -57,6 +61,8 @@
     protected int mOutputWidth;
     protected int mOutputHeight;
     private boolean mIsInitialized;
+    protected int mGLTexture = GLES20.GL_TEXTURE0;
+    protected boolean mExternalOES;
 
     public GPUImageFilter() {
         this(NO_FILTER_VERTEX_SHADER, NO_FILTER_FRAGMENT_SHADER);
@@ -68,6 +74,32 @@ public GPUImageFilter(final String vertexShader, final String fragmentShader) {
         mFragmentShader = fragmentShader;
     }
 
+    public void reloadShaders() {
+        String fragmentShader = mFragmentShader;
+        String vertexShader = mVertexShader;
+        if (mExternalOES) {
+            if (!fragmentShader.contains("#extension GL_OES_EGL_image_external : require\n")) {
+                fragmentShader = "#extension GL_OES_EGL_image_external : require\n" + fragmentShader;
+                fragmentShader = fragmentShader.replaceAll("sampler2D", "samplerExternalOES");
+            }
+        } else {
+            if (fragmentShader.contains("#extension GL_OES_EGL_image_external : require\n")) {
+                fragmentShader = fragmentShader.replace("#extension GL_OES_EGL_image_external : require\n", "");
+                fragmentShader = fragmentShader.replaceAll("samplerExternalOES", "sampler2D");
+            }
+        }
+        mVertexShader = vertexShader;
+        mFragmentShader = fragmentShader;
+        runOnDraw(new Runnable() {
+            @Override
+            public void run() {
+                destroy();
+                init();
+            }
+        });
+    }
+
+
     public final void init() {
         onInit();
         mIsInitialized = true;
@@ -102,6 +134,7 @@ public void onOutputSizeChanged(final int width, final int height) {
 
     public void onDraw(final int textureId, final FloatBuffer cubeBuffer,
                        final FloatBuffer textureBuffer) {
+
         GLES20.glUseProgram(mGLProgId);
         runPendingOnDrawTasks();
         if (!mIsInitialized) {
@@ -116,18 +149,27 @@ public void onDraw(final int textureId, final FloatBuffer cubeBuffer,
                 textureBuffer);
         GLES20.glEnableVertexAttribArray(mGLAttribTextureCoordinate);
         if (textureId != OpenGlUtils.NO_TEXTURE) {
-            GLES20.glActiveTexture(GLES20.GL_TEXTURE0);
-            GLES20.glBindTexture(GLES20.GL_TEXTURE_2D, textureId);
-            GLES20.glUniform1i(mGLUniformTexture, 0);
+            GLES20.glActiveTexture(mGLTexture);
+            if (mExternalOES) {
+                GLES20.glBindTexture(GLES11Ext.GL_TEXTURE_EXTERNAL_OES, textureId);
+            } else {
+                GLES20.glBindTexture(GLES20.GL_TEXTURE_2D, textureId);
+            }
+            GLES20.glUniform1i(mGLUniformTexture, mGLTexture - GLES20.GL_TEXTURE0);
         }
         onDrawArraysPre();
         GLES20.glDrawArrays(GLES20.GL_TRIANGLE_STRIP, 0, 4);
         GLES20.glDisableVertexAttribArray(mGLAttribPosition);
         GLES20.glDisableVertexAttribArray(mGLAttribTextureCoordinate);
-        GLES20.glBindTexture(GLES20.GL_TEXTURE_2D, 0);
+        if (mExternalOES) {
+            GLES20.glBindTexture(GLES11Ext.GL_TEXTURE_EXTERNAL_OES, 0);
+        } else {
+            GLES20.glBindTexture(GLES20.GL_TEXTURE_2D, 0);
+        }
     }
 
-    protected void onDrawArraysPre() {}
+    protected void onDrawArraysPre() {
+    }
 
     protected void runPendingOnDrawTasks() {
         while (!mRunOnDraw.isEmpty()) {
@@ -250,7 +292,7 @@ public void run() {
         });
     }
 
-    protected void runOnDraw(final Runnable runnable) {
+    public void runOnDraw(final Runnable runnable) {
         synchronized (mRunOnDraw) {
             mRunOnDraw.addLast(runnable);
         }
@@ -275,4 +317,24 @@ public static String convertStreamToString(java.io.InputStream is) {
         java.util.Scanner s = new java.util.Scanner(is).useDelimiter("\\A");
         return s.hasNext() ? s.next() : "";
     }
+
+    public int getGLTexture() {
+        return mGLTexture;
+    }
+
+    public void setGLTexture(int mGLTexture) {
+        this.mGLTexture = mGLTexture;
+    }
+
+    public boolean isExternalOES() {
+        return mExternalOES;
+    }
+
+    public void setExternalOES(boolean mExternalOES) {
+        if (this.mExternalOES != mExternalOES) {
+            this.mExternalOES = mExternalOES;
+            reloadShaders();
+        }
+
+    }
 }
diff --git a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageRenderer.java b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageRenderer.java
index 691550bd..32e0bbd2 100644
--- a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageRenderer.java
+++ b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageRenderer.java
@@ -30,6 +30,7 @@
 
 import javax.microedition.khronos.egl.EGLConfig;
 import javax.microedition.khronos.opengles.GL10;
+
 import java.io.IOException;
 import java.nio.ByteBuffer;
 import java.nio.ByteOrder;
@@ -50,32 +51,32 @@
             1.0f, 1.0f,
     };
 
-    private GPUImageFilter mFilter;
+    protected GPUImageFilter mFilter;
 
     public final Object mSurfaceChangedWaiter = new Object();
 
-    private int mGLTextureId = NO_IMAGE;
-    private SurfaceTexture mSurfaceTexture = null;
-    private final FloatBuffer mGLCubeBuffer;
-    private final FloatBuffer mGLTextureBuffer;
-    private IntBuffer mGLRgbBuffer;
-
-    private int mOutputWidth;
-    private int mOutputHeight;
-    private int mImageWidth;
-    private int mImageHeight;
-    private int mAddedPadding;
-
-    private final Queue<Runnable> mRunOnDraw;
-    private final Queue<Runnable> mRunOnDrawEnd;
-    private Rotation mRotation;
-    private boolean mFlipHorizontal;
-    private boolean mFlipVertical;
-    private GPUImage.ScaleType mScaleType = GPUImage.ScaleType.CENTER_CROP;
-
-    private float mBackgroundRed = 0;
-    private float mBackgroundGreen = 0;
-    private float mBackgroundBlue = 0;
+    protected int mGLTextureId = NO_IMAGE;
+    protected SurfaceTexture mSurfaceTexture = null;
+    protected final FloatBuffer mGLCubeBuffer;
+    protected final FloatBuffer mGLTextureBuffer;
+    protected IntBuffer mGLRgbBuffer;
+
+    protected int mOutputWidth;
+    protected int mOutputHeight;
+    protected int mImageWidth;
+    protected int mImageHeight;
+    protected int mAddedPadding;
+
+    protected final Queue<Runnable> mRunOnDraw;
+    protected final Queue<Runnable> mRunOnDrawEnd;
+    protected Rotation mRotation = Rotation.NORMAL;
+    protected boolean mFlipHorizontal;
+    protected boolean mFlipVertical;
+    protected GPUImage.ScaleType mScaleType = GPUImage.ScaleType.CENTER_CROP;
+
+    protected float mBackgroundRed = 0;
+    protected float mBackgroundGreen = 0;
+    protected float mBackgroundBlue = 0;
 
     public GPUImageRenderer(final GPUImageFilter filter) {
         mFilter = filter;
@@ -127,9 +128,9 @@ public void onDrawFrame(final GL10 gl) {
     /**
      * Sets the background color
      *
-     * @param red red color value
+     * @param red   red color value
      * @param green green color value
-     * @param blue red color value
+     * @param blue  red color value
      */
     public void setBackgroundColor(float red, float green, float blue) {
         mBackgroundRed = red;
@@ -137,7 +138,7 @@ public void setBackgroundColor(float red, float green, float blue) {
         mBackgroundBlue = blue;
     }
 
-    private void runAll(Queue<Runnable> queue) {
+    protected void runAll(Queue<Runnable> queue) {
         synchronized (queue) {
             while (!queue.isEmpty()) {
                 queue.poll().run();
@@ -267,7 +268,7 @@ protected int getFrameHeight() {
         return mOutputHeight;
     }
 
-    private void adjustImageScaling() {
+    protected void adjustImageScaling() {
         float outputWidth = mOutputWidth;
         float outputHeight = mOutputHeight;
         if (mRotation == Rotation.ROTATION_270 || mRotation == Rotation.ROTATION_90) {
@@ -310,12 +311,12 @@ private void adjustImageScaling() {
         mGLTextureBuffer.put(textureCords).position(0);
     }
 
-    private float addDistance(float coordinate, float distance) {
+    protected float addDistance(float coordinate, float distance) {
         return coordinate == 0.0f ? distance : 1 - distance;
     }
 
     public void setRotationCamera(final Rotation rotation, final boolean flipHorizontal,
-            final boolean flipVertical) {
+                                  final boolean flipVertical) {
         setRotation(rotation, flipVertical, flipHorizontal);
     }
 
diff --git a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageTextureRenderer.java b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageTextureRenderer.java
new file mode 100644
index 00000000..5f24a7b7
--- /dev/null
+++ b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageTextureRenderer.java
@@ -0,0 +1,467 @@
+/*
+ * Copyright (C) 2012 CyberAgent
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package jp.co.cyberagent.android.gpuimage;
+
+import android.annotation.TargetApi;
+import android.graphics.SurfaceTexture;
+import android.hardware.Camera;
+import android.opengl.GLES20;
+import android.os.Build;
+import android.os.Handler;
+import android.os.Looper;
+import android.util.Log;
+
+import java.nio.ByteBuffer;
+import java.nio.ByteOrder;
+import java.nio.FloatBuffer;
+import java.nio.IntBuffer;
+
+import javax.microedition.khronos.egl.EGL10;
+import javax.microedition.khronos.egl.EGLConfig;
+import javax.microedition.khronos.egl.EGLContext;
+import javax.microedition.khronos.egl.EGLDisplay;
+import javax.microedition.khronos.egl.EGLSurface;
+
+import jp.co.cyberagent.android.gpuimage.util.TextureRotationUtil;
+
+import static jp.co.cyberagent.android.gpuimage.util.TextureRotationUtil.TEXTURE_NO_ROTATION;
+import static jp.co.cyberagent.android.gpuimage.util.TextureRotationUtil.TEXTURE_ROTATED_180;
+
+@TargetApi(11)
+public class GPUImageTextureRenderer extends GPUImageRenderer implements SurfaceTexture.OnFrameAvailableListener {
+    static final float[] SCREEN_CUBE = {
+            1.0f, 1.0f,
+            -1.0f, 1.0f,
+            1.0f, -1.0f,
+            -1.0f, -1.0f
+    };
+    static final float[] SCREEN_TEXTURE = {
+            0.0f, 0.0f,
+            1.0f, 0.0f,
+            0.0f, 1.0f,
+            1.0f, 1.0f,
+    };
+
+    public GPUImageTextureRenderer(final GPUImageFilter filter) {
+        super(filter);
+        screenCubeBuffer = ByteBuffer.allocateDirect(CUBE.length * 4)
+                .order(ByteOrder.nativeOrder())
+                .asFloatBuffer();
+        screenCubeBuffer.put(CUBE).position(0);
+        screenTextureBuffer = ByteBuffer.allocateDirect(SCREEN_TEXTURE.length * 4)
+                .order(ByteOrder.nativeOrder())
+                .asFloatBuffer();
+        screenTextureBuffer.put(SCREEN_TEXTURE).position(0);
+    }
+
+    protected static final int EGL_OPENGL_ES2_BIT = 4;
+    private static final int EGL_CONTEXT_CLIENT_VERSION = 0x3098;
+    protected static final String LOG_TAG = "GPUImageTextureRenderer";
+    protected SurfaceTexture outputTexture;
+    protected EGL10 egl;
+    protected EGLDisplay eglDisplay;
+    protected EGLContext eglContext;
+    protected EGLSurface eglSurface;
+
+    protected boolean running;
+    GPUImageFilter mNoFilter = new GPUImageFilter();
+    protected FloatBuffer screenCubeBuffer;
+    protected FloatBuffer screenTextureBuffer;
+
+
+    public void startRenderingToOutput(SurfaceTexture outputTexture, Runnable onInputTextureAvailableCallback) {
+        this.outputTexture = outputTexture;
+        this.onInputTextureAvailableCallback = onInputTextureAvailableCallback;
+        mNoFilter.runOnDraw(new Runnable() {
+            @Override
+            public void run() {
+                mNoFilter.init();
+                mNoFilter.setExternalOES(true);
+            }
+        });
+        new Thread(new Runnable() {
+            @Override
+            public void run() {
+                GPUImageTextureRenderer.this.run();
+            }
+        }).start();
+    }
+
+    public boolean isStarted() {
+        return running;
+    }
+
+    public void run() {
+        running = true;
+        try {
+            //Waiting for subclass constructor
+            Thread.sleep(100);
+        } catch (InterruptedException e) {
+
+        }
+        initGL();
+        initGLComponents();
+        if (mFilter != null) {
+            mFilter.setGLTexture(GLES20.GL_TEXTURE1);
+        }
+        Log.d(LOG_TAG, "OpenGL init OK.");
+        while (running) {
+            runAll(mRunOnDraw);
+            long loopStart = System.currentTimeMillis();
+            pingFps();
+
+            if (draw()) {
+                egl.eglSwapBuffers(eglDisplay, eglSurface);
+            }
+            runAll(mRunOnDrawEnd);
+            long waitDelta = 16 - (System.currentTimeMillis() - loopStart);    // Targeting 60 fps, no need for faster
+            if (waitDelta > 0) {
+                try {
+                    Thread.sleep(waitDelta);
+                } catch (InterruptedException e) {
+                    e.printStackTrace();
+                    continue;
+                }
+            }
+        }
+
+        deinitGLComponents();
+        deinitGL();
+        if (shouldReInit) {
+            shouldReInit = false;
+            run();
+        }
+    }
+
+    private long lastFpsOutput = 0;
+    private int frames;
+
+    protected void pingFps() {
+        if (lastFpsOutput == 0)
+            lastFpsOutput = System.currentTimeMillis();
+
+        frames++;
+
+        if (System.currentTimeMillis() - lastFpsOutput > 1000) {
+            lastFpsOutput = System.currentTimeMillis();
+            frames = 0;
+        }
+    }
+
+
+    /**
+     * Call when activity pauses. This stops the rendering thread and deinitializes OpenGL.
+     */
+    public void onPause() {
+        running = false;
+    }
+
+
+    protected void initGL() {
+        egl = (EGL10) EGLContext.getEGL();
+        eglDisplay = egl.eglGetDisplay(EGL10.EGL_DEFAULT_DISPLAY);
+
+        int[] version = new int[2];
+        egl.eglInitialize(eglDisplay, version);
+
+        EGLConfig eglConfig = chooseEglConfig();
+        eglContext = createContext(egl, eglDisplay, eglConfig);
+
+        eglSurface = egl.eglCreateWindowSurface(eglDisplay, eglConfig, outputTexture, null);
+
+        if (eglSurface == null || eglSurface == EGL10.EGL_NO_SURFACE) {
+            throw new RuntimeException("GL Error: ");// + GLUtils.getEGLErrorString(egl.eglGetError()));
+        }
+
+        if (!egl.eglMakeCurrent(eglDisplay, eglSurface, eglSurface, eglContext)) {
+            throw new RuntimeException("GL Make current error: ");// + GLUtils.getEGLErrorString(egl.eglGetError()));
+        }
+    }
+
+    protected void deinitGL() {
+        egl.eglMakeCurrent(eglDisplay, EGL10.EGL_NO_SURFACE, EGL10.EGL_NO_SURFACE, EGL10.EGL_NO_CONTEXT);
+        egl.eglDestroySurface(eglDisplay, eglSurface);
+        egl.eglDestroyContext(eglDisplay, eglContext);
+        egl.eglTerminate(eglDisplay);
+        Log.d(LOG_TAG, "OpenGL deinit OK.");
+    }
+
+    boolean shouldReInit = false;
+
+    public void reinitGL(SurfaceTexture surfaceTexture) {
+        if (surfaceTexture != null) {
+            outputTexture = surfaceTexture;
+        }
+        shouldReInit = true;
+        running = false;
+    }
+
+    private EGLContext createContext(EGL10 egl, EGLDisplay eglDisplay, EGLConfig eglConfig) {
+        int[] attribList = {EGL_CONTEXT_CLIENT_VERSION, 2, EGL10.EGL_NONE};
+        return egl.eglCreateContext(eglDisplay, eglConfig, EGL10.EGL_NO_CONTEXT, attribList);
+    }
+
+    protected EGLConfig chooseEglConfig() {
+        int[] configsCount = new int[1];
+        EGLConfig[] configs = new EGLConfig[1];
+        int[] configSpec = getConfig();
+
+        if (!egl.eglChooseConfig(eglDisplay, configSpec, configs, 1, configsCount)) {
+            throw new IllegalArgumentException("Failed to choose config: ");// + GLUtils.getEGLErrorString(egl.eglGetError()));
+        } else if (configsCount[0] > 0) {
+            return configs[0];
+        }
+
+        return null;
+    }
+
+    protected int[] getConfig() {
+        return new int[]{
+                EGL10.EGL_RENDERABLE_TYPE, EGL_OPENGL_ES2_BIT,
+                EGL10.EGL_RED_SIZE, 8,
+                EGL10.EGL_GREEN_SIZE, 8,
+                EGL10.EGL_BLUE_SIZE, 8,
+                EGL10.EGL_ALPHA_SIZE, 8,
+                EGL10.EGL_DEPTH_SIZE, 8,
+                EGL10.EGL_STENCIL_SIZE, 0,
+                EGL10.EGL_NONE
+        };
+    }
+
+
+    protected Runnable onInputTextureAvailableCallback;
+
+    // Texture to be shown in backgrund
+    private int[] textures = new int[1];
+
+    private SurfaceTexture inputTexture;
+    private float[] videoTextureTransform = new float[16];
+    ;
+    private boolean frameAvailable = false;
+
+    private int[] frameBuffers = new int[1];
+    private int[] renderBuffers = new int[1];
+    private int[] offScreenTextures = new int[1];
+    private boolean frameBufferPrepared;
+
+    private void setupTexture() {
+        GLES20.glGenTextures(1, textures, 0);
+        checkGlError("Texture generate");
+
+        inputTexture = new SurfaceTexture(textures[0]);
+        inputTexture.setOnFrameAvailableListener(this);
+        if (onInputTextureAvailableCallback != null) {
+            onInputTextureAvailableCallback.run();
+        }
+    }
+
+
+    protected boolean draw() {
+
+        synchronized (this) {
+            if (frameAvailable) {
+                inputTexture.updateTexImage();
+                inputTexture.getTransformMatrix(videoTextureTransform);
+                frameAvailable = false;
+            }
+        }
+        if (!frameBufferPrepared) {
+            prepareFramebuffer(mImageWidth, mImageHeight);
+        }
+        if (!frameBufferPrepared) {
+            return false;
+        }
+        GLES20.glBindFramebuffer(GLES20.GL_FRAMEBUFFER, frameBuffers[0]);
+        GLES20.glViewport(0, 0, mImageWidth, mImageHeight);
+        GLES20.glClearColor(0.0f, 0.0f, 0.0f, 0.0f);
+        GLES20.glClear(GLES20.GL_COLOR_BUFFER_BIT | GLES20.GL_DEPTH_BUFFER_BIT);
+        mNoFilter.onDraw(textures[0], mGLCubeBuffer, mGLTextureBuffer);
+        GLES20.glBindFramebuffer(GLES20.GL_FRAMEBUFFER, 0);
+        GLES20.glViewport(0, 0, mOutputWidth, mOutputHeight);
+        GLES20.glClearColor(0.0f, 0.0f, 0.0f, 0.0f);
+        GLES20.glClear(GLES20.GL_COLOR_BUFFER_BIT | GLES20.GL_DEPTH_BUFFER_BIT);
+        mFilter.onDraw(offScreenTextures[0], screenCubeBuffer, screenTextureBuffer);
+        return true;
+    }
+
+
+    protected void initGLComponents() {
+        setupTexture();
+    }
+
+    protected void deinitGLComponents() {
+        GLES20.glDeleteTextures(1, textures, 0);
+        releaseFramebuffer();
+        if (Build.VERSION.SDK_INT >= 14) {
+            inputTexture.release();
+        }
+        inputTexture.setOnFrameAvailableListener(null);
+    }
+
+    public void setOutputSize(int width, int height) {
+        mOutputWidth = width;
+        mOutputHeight = height;
+    }
+
+    public void setVideoSize(final int width, final int height) {
+        mImageWidth = width;
+        mImageHeight = height;
+        mNoFilter.runOnDraw(new Runnable() {
+            @Override
+            public void run() {
+                //NoFilter's output is a framebuffer, therefore it's size is the video size, not the display size.
+                adjustImageScaling();
+                mNoFilter.onOutputSizeChanged(width, height);
+            }
+        });
+    }
+
+
+    public void checkGlError(String op) {
+        int error;
+        while ((error = GLES20.glGetError()) != GLES20.GL_NO_ERROR) {
+            Log.e("SurfaceTest", op + ": glError ");// + GLUtils.getEGLErrorString(error));
+        }
+    }
+
+    public SurfaceTexture getInputTexture() {
+        return inputTexture;
+    }
+
+    @Override
+    public void onFrameAvailable(SurfaceTexture surfaceTexture) {
+        synchronized (this) {
+            frameAvailable = true;
+        }
+    }
+
+    public void releaseFramebuffer() {
+        if (offScreenTextures[0] > 0) {
+            GLES20.glDeleteTextures(1, offScreenTextures, 0);
+            offScreenTextures[0] = -1;
+        }
+        if (renderBuffers[0] > 0) {
+            GLES20.glDeleteRenderbuffers(1, renderBuffers, 0);
+            renderBuffers[0] = -1;
+
+        }
+        if (frameBuffers[0] > 0) {
+            GLES20.glDeleteFramebuffers(1, frameBuffers, 0);
+            frameBuffers[0] = -1;
+        }
+        frameBufferPrepared = false;
+    }
+
+    private void prepareFramebuffer(int width, int height) {
+        if (width == 0 || height == 0) return;
+        // Create a outputTexture object and bind it.  This will be the color buffer.
+        GLES20.glGenTextures(1, offScreenTextures, 0);
+        GLES20.glBindTexture(GLES20.GL_TEXTURE_2D, offScreenTextures[0]);
+        checkGlError("genTexture");
+        // Create outputTexture storage.
+        GLES20.glTexImage2D(GLES20.GL_TEXTURE_2D, 0, GLES20.GL_RGBA, width, height, 0,
+                GLES20.GL_RGBA, GLES20.GL_UNSIGNED_BYTE, null);
+        checkGlError("texImage");
+
+        // Set parameters.  We're probably using non-power-of-two dimensions, so
+        // some values may not be available for use.
+        GLES20.glTexParameterf(GLES20.GL_TEXTURE_2D, GLES20.GL_TEXTURE_MIN_FILTER,
+                GLES20.GL_NEAREST);
+        GLES20.glTexParameterf(GLES20.GL_TEXTURE_2D, GLES20.GL_TEXTURE_MAG_FILTER,
+                GLES20.GL_LINEAR);
+        GLES20.glTexParameteri(GLES20.GL_TEXTURE_2D, GLES20.GL_TEXTURE_WRAP_S,
+                GLES20.GL_CLAMP_TO_EDGE);
+        GLES20.glTexParameteri(GLES20.GL_TEXTURE_2D, GLES20.GL_TEXTURE_WRAP_T,
+                GLES20.GL_CLAMP_TO_EDGE);
+
+        // Create framebuffer object and bind it.
+        GLES20.glGenFramebuffers(1, frameBuffers, 0);
+        GLES20.glBindFramebuffer(GLES20.GL_FRAMEBUFFER, frameBuffers[0]);
+        checkGlError("genFramebuffer");
+
+        // Create a depth buffer and bind it.
+        GLES20.glGenRenderbuffers(1, renderBuffers, 0);
+        GLES20.glBindRenderbuffer(GLES20.GL_RENDERBUFFER, renderBuffers[0]);
+        checkGlError("genRenderbuffer");
+
+        // Allocate storage for the depth buffer.
+        GLES20.glRenderbufferStorage(GLES20.GL_RENDERBUFFER, GLES20.GL_DEPTH_COMPONENT16,
+                width, height);
+        checkGlError("renderbufferStorage");
+
+        // Attach the depth buffer and the outputTexture (color buffer) to the framebuffer object.
+        GLES20.glFramebufferRenderbuffer(GLES20.GL_FRAMEBUFFER, GLES20.GL_DEPTH_ATTACHMENT,
+                GLES20.GL_RENDERBUFFER, renderBuffers[0]);
+        GLES20.glFramebufferTexture2D(GLES20.GL_FRAMEBUFFER, GLES20.GL_COLOR_ATTACHMENT0,
+                GLES20.GL_TEXTURE_2D, offScreenTextures[0], 0);
+
+        // See if GLES is happy with all this.
+        int status = GLES20.glCheckFramebufferStatus(GLES20.GL_FRAMEBUFFER);
+        if (status != GLES20.GL_FRAMEBUFFER_COMPLETE) {
+            throw new RuntimeException("Framebuffer not complete, status=" + status);
+        }
+
+        // Switch back to the default framebuffer.
+        GLES20.glBindFramebuffer(GLES20.GL_FRAMEBUFFER, 0);
+
+        frameBufferPrepared = true;
+    }
+
+    @Override
+    protected void adjustImageScaling() {
+//        float outputWidth = mOutputWidth;
+//        float outputHeight = mOutputHeight;
+//        if (mRotation == Rotation.ROTATION_270 || mRotation == Rotation.ROTATION_90) {
+//            outputWidth = mOutputHeight;
+//            outputHeight = mOutputWidth;
+//        }
+//
+//        float ratio1 = outputWidth / mImageWidth;
+//        float ratio2 = outputHeight / mImageHeight;
+//        float ratioMax = Math.max(ratio1, ratio2);
+//        int imageWidthNew = Math.round(mImageWidth * ratioMax);
+//        int imageHeightNew = Math.round(mImageHeight * ratioMax);
+//
+//        float ratioWidth = imageWidthNew / outputWidth;
+//        float ratioHeight = imageHeightNew / outputHeight;
+//
+//        float[] cube = CUBE;
+//        float[] textureCords = TextureRotationUtil.getRotation(mRotation, mFlipHorizontal, mFlipVertical);
+//        if (mScaleType == GPUImage.ScaleType.CENTER_CROP) {
+//            float distHorizontal = (1 - 1 / ratioWidth) / 2;
+//            float distVertical = (1 - 1 / ratioHeight) / 2;
+//            textureCords = new float[]{
+//                    addDistance(textureCords[0], distHorizontal), addDistance(textureCords[1], distVertical),
+//                    addDistance(textureCords[2], distHorizontal), addDistance(textureCords[3], distVertical),
+//                    addDistance(textureCords[4], distHorizontal), addDistance(textureCords[5], distVertical),
+//                    addDistance(textureCords[6], distHorizontal), addDistance(textureCords[7], distVertical),
+//            };
+//        } else {
+//            cube = new float[]{
+//                    CUBE[0] / ratioHeight, CUBE[1] / ratioWidth,
+//                    CUBE[2] / ratioHeight, CUBE[3] / ratioWidth,
+//                    CUBE[4] / ratioHeight, CUBE[5] / ratioWidth,
+//                    CUBE[6] / ratioHeight, CUBE[7] / ratioWidth,
+//            };
+//        }
+
+        mGLCubeBuffer.clear();
+        mGLCubeBuffer.put(CUBE).position(0);
+        mGLTextureBuffer.clear();
+        mGLTextureBuffer.put(TEXTURE_NO_ROTATION).position(0);
+    }
+}
diff --git a/sample/AndroidManifest.xml b/sample/AndroidManifest.xml
index 855b72c5..d58c6e56 100644
--- a/sample/AndroidManifest.xml
+++ b/sample/AndroidManifest.xml
@@ -1,33 +1,36 @@
-<manifest xmlns:android="http://schemas.android.com/apk/res/android"
-    package="jp.co.cyberagent.android.gpuimage.sample">
+<?xml version="1.0" encoding="utf-8"?>
+<manifest package="jp.co.cyberagent.android.gpuimage.sample"
+          xmlns:android="http://schemas.android.com/apk/res/android">
 
-    <uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE" />
-    <uses-permission android:name="android.permission.CAMERA" />
+    <uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE"/>
+    <uses-permission android:name="android.permission.CAMERA"/>
 
     <!-- For images from picasa -->
-    <uses-permission android:name="android.permission.INTERNET" />
+    <uses-permission android:name="android.permission.INTERNET"/>
 
     <application
         android:allowBackup="true"
         android:hardwareAccelerated="true"
         android:icon="@drawable/ic_launcher"
-        android:largeHeap="true"
         android:label="@string/app_name"
-        android:theme="@style/AppTheme" >
+        android:largeHeap="true"
+        android:theme="@style/AppTheme">
         <activity
             android:name=".activity.ActivityMain"
-            android:label="@string/title_activity_activity_main" >
+            android:label="@string/title_activity_activity_main">
             <intent-filter>
-                <action android:name="android.intent.action.MAIN" />
+                <action android:name="android.intent.action.MAIN"/>
 
-                <category android:name="android.intent.category.LAUNCHER" />
+                <category android:name="android.intent.category.LAUNCHER"/>
             </intent-filter>
         </activity>
-        <activity android:name=".activity.ActivityGallery" />
+        <activity android:name=".activity.ActivityGallery"/>
         <activity
-            android:name="jp.co.cyberagent.android.gpuimage.sample.activity.ActivityCamera"
+            android:name=".activity.ActivityCamera"
             android:screenOrientation="portrait"
-            android:theme="@style/AppTheme.NoActionBar" />
+            android:theme="@style/AppTheme.NoActionBar"/>
+        <activity android:name=".activity.ActivityMovie">
+        </activity>
     </application>
 
-</manifest>
\ No newline at end of file
+</manifest>
diff --git a/sample/build.gradle b/sample/build.gradle
index 5057072e..11f09b01 100644
--- a/sample/build.gradle
+++ b/sample/build.gradle
@@ -5,6 +5,7 @@ android {
     buildToolsVersion BUILD_TOOLS_VERSION
 
     defaultConfig {
+        applicationId 'me.skonb.android_gpuimage.sample'
         minSdkVersion MIN_SDK_VERSION as int
         targetSdkVersion TARGET_SDK_VERSION as int
     }
@@ -36,4 +37,5 @@ dependencies {
     compile project(':library')
 //    compile 'jp.co.cyberagent.android.gpuimage:gpuimage-library:+@aar'
     compile 'com.android.support:support-v4:21.+'
-}
\ No newline at end of file
+    compile 'com.github.skonb:fenster:78b6a3e3a5'
+}
diff --git a/sample/res/layout/activity_main.xml b/sample/res/layout/activity_main.xml
index 6c13bf2f..0f1ec53c 100644
--- a/sample/res/layout/activity_main.xml
+++ b/sample/res/layout/activity_main.xml
@@ -1,14 +1,14 @@
 <FrameLayout xmlns:android="http://schemas.android.com/apk/res/android"
-    xmlns:tools="http://schemas.android.com/tools"
-    android:layout_width="match_parent"
-    android:layout_height="match_parent" >
+             xmlns:tools="http://schemas.android.com/tools"
+             android:layout_width="match_parent"
+             android:layout_height="match_parent">
 
     <LinearLayout
         android:layout_width="wrap_content"
         android:layout_height="wrap_content"
         android:layout_gravity="center"
         android:gravity="center"
-        android:orientation="vertical" >
+        android:orientation="vertical">
 
         <Button
             android:id="@+id/button_gallery"
@@ -16,14 +16,22 @@
             android:layout_height="wrap_content"
             android:layout_marginBottom="10dp"
             android:drawableTop="@android:drawable/ic_menu_gallery"
-            android:text="Gallery" />
+            android:text="Gallery"/>
 
         <Button
             android:id="@+id/button_camera"
             android:layout_width="wrap_content"
             android:layout_height="wrap_content"
+            android:layout_marginBottom="10dp"
             android:drawableTop="@android:drawable/ic_menu_camera"
-            android:text="Camera" />
+            android:text="Camera"/>
+
+        <Button
+            android:id="@+id/button_movie"
+            android:layout_width="wrap_content"
+            android:layout_height="wrap_content"
+            android:drawableTop="@android:drawable/ic_menu_more"
+            android:text="Movie"/>
     </LinearLayout>
 
-</FrameLayout>
\ No newline at end of file
+</FrameLayout>
diff --git a/sample/res/layout/activity_movie.xml b/sample/res/layout/activity_movie.xml
new file mode 100644
index 00000000..757cb1e0
--- /dev/null
+++ b/sample/res/layout/activity_movie.xml
@@ -0,0 +1,15 @@
+<?xml version="1.0" encoding="utf-8"?>
+<RelativeLayout
+    xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:tools="http://schemas.android.com/tools"
+    xmlns:res="http://schemas.android.com/apk/res-auto"
+    android:layout_width="match_parent"
+    android:layout_height="match_parent"
+    tools:context="jp.co.cyberagent.android.gpuimage.sample.activity.ActivityMovie">
+
+    <com.malmstein.fenster.view.FensterVideoView
+        res:scaleType="crop"
+        android:id="@+id/video_view"
+        android:layout_width="match_parent"
+        android:layout_height="match_parent"/>
+</RelativeLayout>
diff --git a/sample/res/values-w820dp/dimens.xml b/sample/res/values-w820dp/dimens.xml
new file mode 100644
index 00000000..63fc8164
--- /dev/null
+++ b/sample/res/values-w820dp/dimens.xml
@@ -0,0 +1,6 @@
+<resources>
+    <!-- Example customization of dimensions originally defined in res/values/dimens.xml
+         (such as screen margins) for screens with more than 820dp of available width. This
+         would include 7" and 10" devices in landscape (~960dp and ~1280dp respectively). -->
+    <dimen name="activity_horizontal_margin">64dp</dimen>
+</resources>
diff --git a/sample/res/values/dimens.xml b/sample/res/values/dimens.xml
new file mode 100644
index 00000000..47c82246
--- /dev/null
+++ b/sample/res/values/dimens.xml
@@ -0,0 +1,5 @@
+<resources>
+    <!-- Default screen margins, per the Android Design guidelines. -->
+    <dimen name="activity_horizontal_margin">16dp</dimen>
+    <dimen name="activity_vertical_margin">16dp</dimen>
+</resources>
diff --git a/sample/src/jp/co/cyberagent/android/gpuimage/sample/activity/ActivityMain.java b/sample/src/jp/co/cyberagent/android/gpuimage/sample/activity/ActivityMain.java
index 0a1d7802..c34619af 100644
--- a/sample/src/jp/co/cyberagent/android/gpuimage/sample/activity/ActivityMain.java
+++ b/sample/src/jp/co/cyberagent/android/gpuimage/sample/activity/ActivityMain.java
@@ -17,6 +17,7 @@
 package jp.co.cyberagent.android.gpuimage.sample.activity;
 
 import jp.co.cyberagent.android.gpuimage.sample.R;
+
 import android.app.Activity;
 import android.content.Intent;
 import android.os.Bundle;
@@ -31,6 +32,7 @@ public void onCreate(final Bundle savedInstanceState) {
         setContentView(R.layout.activity_main);
         findViewById(R.id.button_gallery).setOnClickListener(this);
         findViewById(R.id.button_camera).setOnClickListener(this);
+        findViewById(R.id.button_movie).setOnClickListener(this);
     }
 
     @Override
@@ -42,7 +44,8 @@ public void onClick(final View v) {
             case R.id.button_camera:
                 startActivity(ActivityCamera.class);
                 break;
-
+            case R.id.button_movie:
+                startActivity(ActivityMovie.class);
             default:
                 break;
         }
diff --git a/sample/src/jp/co/cyberagent/android/gpuimage/sample/activity/ActivityMovie.java b/sample/src/jp/co/cyberagent/android/gpuimage/sample/activity/ActivityMovie.java
new file mode 100644
index 00000000..ce09c4c0
--- /dev/null
+++ b/sample/src/jp/co/cyberagent/android/gpuimage/sample/activity/ActivityMovie.java
@@ -0,0 +1,54 @@
+package jp.co.cyberagent.android.gpuimage.sample.activity;
+
+import android.app.Activity;
+import android.graphics.SurfaceTexture;
+import android.media.MediaPlayer;
+import android.os.Bundle;
+
+import com.malmstein.fenster.view.FensterVideoView;
+
+import jp.co.cyberagent.android.gpuimage.GPUImageBrightnessFilter;
+import jp.co.cyberagent.android.gpuimage.GPUImageFilter;
+import jp.co.cyberagent.android.gpuimage.GPUImageGrayscaleFilter;
+import jp.co.cyberagent.android.gpuimage.GPUImageMonochromeFilter;
+import jp.co.cyberagent.android.gpuimage.GPUImageSepiaFilter;
+import jp.co.cyberagent.android.gpuimage.GPUImageSharpenFilter;
+import jp.co.cyberagent.android.gpuimage.GPUImageTextureRenderer;
+import jp.co.cyberagent.android.gpuimage.GPUImageWhiteBalanceFilter;
+import jp.co.cyberagent.android.gpuimage.sample.R;
+
+public class ActivityMovie extends Activity {
+
+    FensterVideoView videoView;
+    GPUImageFilter filter = new GPUImageSepiaFilter();
+
+    class Renderer extends GPUImageTextureRenderer implements FensterVideoView.Renderer {
+        public Renderer(final GPUImageFilter filter) {
+            super(filter);
+            filter.runOnDraw(new Runnable() {
+                @Override
+                public void run() {
+                    filter.init();
+                }
+            });
+        }
+    }
+
+    @Override
+    protected void onCreate(Bundle savedInstanceState) {
+        super.onCreate(savedInstanceState);
+        setContentView(R.layout.activity_movie);
+        videoView = (FensterVideoView) findViewById(R.id.video_view);
+        videoView.setRenderer(new Renderer(filter));
+        videoView.setVideo("http://clips.vorwaerts-gmbh.de/big_buck_bunny.mp4", 0);
+        videoView.setOnPreparedListener(new MediaPlayer.OnPreparedListener() {
+            @Override
+            public void onPrepared(MediaPlayer mp) {
+                videoView.start();
+            }
+        });
+        videoView.start();
+    }
+
+
+}
