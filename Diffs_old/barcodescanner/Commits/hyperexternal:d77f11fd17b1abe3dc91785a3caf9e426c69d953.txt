diff --git a/core/src/main/java/me/dm7/barcodescanner/core/BarcodeScannerView.java b/core/src/main/java/me/dm7/barcodescanner/core/BarcodeScannerView.java
index 42863e1..86c7c3f 100644
--- a/core/src/main/java/me/dm7/barcodescanner/core/BarcodeScannerView.java
+++ b/core/src/main/java/me/dm7/barcodescanner/core/BarcodeScannerView.java
@@ -1,14 +1,13 @@
 package me.dm7.barcodescanner.core;
 
 import android.content.Context;
-import android.content.res.Configuration;
 import android.content.res.TypedArray;
 import android.graphics.Color;
 import android.graphics.Rect;
 import android.hardware.Camera;
+import android.os.Build;
 import android.support.annotation.ColorInt;
 import android.util.AttributeSet;
-import android.util.Log;
 import android.view.Gravity;
 import android.view.View;
 import android.widget.FrameLayout;
@@ -16,6 +15,8 @@
 
 public abstract class BarcodeScannerView extends FrameLayout implements Camera.PreviewCallback  {
 
+    private static final float ASPECT_TOLERANCE_HUAWEI = 0.5f;
+
     private CameraWrapper mCameraWrapper;
     private CameraPreview mPreview;
     private IViewFinder mViewFinderView;
@@ -80,7 +81,7 @@ public final void setupLayout(CameraWrapper cameraWrapper) {
         removeAllViews();
 
         mPreview = new CameraPreview(getContext(), cameraWrapper, this);
-        mPreview.setAspectTolerance(mAspectTolerance);
+        setAspectTolerance(mPreview);
         mPreview.setShouldScaleToFill(mShouldScaleToFill);
         if (!mShouldScaleToFill) {
             RelativeLayout relativeLayout = new RelativeLayout(getContext());
@@ -100,6 +101,19 @@ public final void setupLayout(CameraWrapper cameraWrapper) {
         }
     }
 
+    private void setAspectTolerance(CameraPreview mPreview) {
+        if (isHuaweiLenovoPhones()) { //hard coded huawei and lenovo phones https://github.com/dm77/barcodescanner
+            mPreview.setAspectTolerance(ASPECT_TOLERANCE_HUAWEI);
+        } else {
+            mPreview.setAspectTolerance(mAspectTolerance);
+        }
+    }
+
+    private boolean isHuaweiLenovoPhones() {
+        String manufacturer = Build.MANUFACTURER;
+        return "HUAWEI".equalsIgnoreCase(manufacturer) || "Lenovo".equalsIgnoreCase(manufacturer);
+    }
+
     /**
      * <p>Method that creates view that represents visual appearance of a barcode scanner</p>
      * <p>Override it to provide your own view for visual appearance of a barcode scanner</p>
diff --git a/core/src/main/java/me/dm7/barcodescanner/core/CameraPreview.java b/core/src/main/java/me/dm7/barcodescanner/core/CameraPreview.java
index b9c4fb0..b066e25 100644
--- a/core/src/main/java/me/dm7/barcodescanner/core/CameraPreview.java
+++ b/core/src/main/java/me/dm7/barcodescanner/core/CameraPreview.java
@@ -28,7 +28,6 @@
     private boolean mShouldScaleToFill = true;
     private Camera.PreviewCallback mPreviewCallback;
     private float mAspectTolerance = 0.1f;
-    private static final int MINIMUM_SIZE_HEIGHT = 480;
 
     public CameraPreview(Context context, CameraWrapper cameraWrapper, Camera.PreviewCallback previewCallback) {
         super(context);
@@ -253,10 +252,7 @@ public int getDisplayOrientation() {
         for (Camera.Size size : sizes) {
             double ratio = (double) size.width / size.height;
             if (Math.abs(ratio - targetRatio) > mAspectTolerance) continue;
-            /*ADD another minimum height check condition
-            https://github.com/dm77/barcodescanner/issues/287
-            */
-            if (Math.abs(size.height - targetHeight) < minDiff && size.height >= MINIMUM_SIZE_HEIGHT) {
+            if (Math.abs(size.height - targetHeight) < minDiff) {
                 optimalSize = size;
                 minDiff = Math.abs(size.height - targetHeight);
             }
@@ -266,7 +262,7 @@ public int getDisplayOrientation() {
         if (optimalSize == null) {
             minDiff = Double.MAX_VALUE;
             for (Camera.Size size : sizes) {
-                if (Math.abs(size.height - targetHeight) < minDiff && size.height >= MINIMUM_SIZE_HEIGHT) {//ADD another minimum height check condition
+                if (Math.abs(size.height - targetHeight) < minDiff) {
                     optimalSize = size;
                     minDiff = Math.abs(size.height - targetHeight);
                 }
