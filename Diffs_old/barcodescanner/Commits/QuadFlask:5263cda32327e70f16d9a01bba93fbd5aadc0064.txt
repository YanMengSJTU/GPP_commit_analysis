diff --git a/core/src/main/java/me/dm7/barcodescanner/core/BarcodeScannerView.java b/core/src/main/java/me/dm7/barcodescanner/core/BarcodeScannerView.java
index b2574c8..5cd122d 100644
--- a/core/src/main/java/me/dm7/barcodescanner/core/BarcodeScannerView.java
+++ b/core/src/main/java/me/dm7/barcodescanner/core/BarcodeScannerView.java
@@ -1,124 +1,125 @@
 package me.dm7.barcodescanner.core;
 
 import android.content.Context;
-import android.graphics.Point;
+import android.graphics.Color;
 import android.graphics.Rect;
 import android.hardware.Camera;
-import android.os.AsyncTask;
 import android.util.AttributeSet;
+import android.view.Gravity;
 import android.widget.FrameLayout;
+import android.widget.RelativeLayout;
 
-public abstract class BarcodeScannerView extends FrameLayout implements Camera.PreviewCallback  {
-    private Camera mCamera;
-    private CameraPreview mPreview;
-    private ViewFinderView mViewFinderView;
-    private Rect mFramingRectInPreview;
+public abstract class BarcodeScannerView extends FrameLayout implements Camera.PreviewCallback {
+	private Camera mCamera;
+	private CameraPreview mPreview;
+	private ViewFinderView mViewFinderView;
+	private Rect mFramingRectInPreview;
 
-    public BarcodeScannerView(Context context) {
-        super(context);
-        setupLayout();
-    }
+	public BarcodeScannerView(Context context) {
+		super(context);
+		setupLayout();
+	}
 
-    public BarcodeScannerView(Context context, AttributeSet attributeSet) {
-        super(context, attributeSet);
-        setupLayout();
-    }
+	public BarcodeScannerView(Context context, AttributeSet attributeSet) {
+		super(context, attributeSet);
+		setupLayout();
+	}
 
-    public void setupLayout() {
-        mPreview = new CameraPreview(getContext());
-        mViewFinderView = new ViewFinderView(getContext());
-        addView(mPreview);
-        addView(mViewFinderView);
-    }
+	public void setupLayout() {
+		mPreview = new CameraPreview(getContext());
+		mViewFinderView = new ViewFinderView(getContext());
+		RelativeLayout relativeLayout = new RelativeLayout(getContext());
+		relativeLayout.setGravity(Gravity.CENTER);
+		relativeLayout.setBackgroundColor(Color.BLACK);
+		relativeLayout.addView(mPreview);
+		addView(relativeLayout);
 
-    public void startCamera() {
-        mCamera = CameraUtils.getCameraInstance();
-        if(mCamera != null) {
-            mViewFinderView.setupViewFinder();
-            mPreview.setCamera(mCamera, this);
-            mPreview.initCameraPreview();
-        }
-    }
+		addView(mViewFinderView);
+	}
 
-    public void stopCamera() {
-        if(mCamera != null) {
-            mPreview.stopCameraPreview();
-            mPreview.setCamera(null, null);
-            mCamera.release();
-            mCamera = null;
-        }
-    }
+	public void startCamera() {
+		mCamera = CameraUtils.getCameraInstance();
+		if (mCamera != null) {
+			mViewFinderView.setupViewFinder();
+			mPreview.setCamera(mCamera, this);
+			mPreview.initCameraPreview();
+		}
+	}
 
-    public synchronized Rect getFramingRectInPreview(int width, int height) {
-        if (mFramingRectInPreview == null) {
-            Rect framingRect = mViewFinderView.getFramingRect();
-            if (framingRect == null) {
-                return null;
-            }
-            Rect rect = new Rect(framingRect);
-            Point screenResolution = DisplayUtils.getScreenResolution(getContext());
-            Point cameraResolution = new Point(width, height);
+	public void stopCamera() {
+		if (mCamera != null) {
+			mPreview.stopCameraPreview();
+			mPreview.setCamera(null, null);
+			mCamera.release();
+			mCamera = null;
+		}
+	}
 
-            if (cameraResolution == null || screenResolution == null) {
-                // Called early, before init even finished
-                return null;
-            }
+	public synchronized Rect getFramingRectInPreview(int previewWidth, int previewHeight) {
+		if (mFramingRectInPreview == null) {
+			Rect framingRect = mViewFinderView.getFramingRect();
+			int viewFinderViewWidth = mViewFinderView.getWidth();
+			int viewFinderViewHeight = mViewFinderView.getHeight();
+			if (framingRect == null || viewFinderViewWidth == 0 || viewFinderViewHeight == 0) {
+				return null;
+			}
 
-            rect.left = rect.left * cameraResolution.x / screenResolution.x;
-            rect.right = rect.right * cameraResolution.x / screenResolution.x;
-            rect.top = rect.top * cameraResolution.y / screenResolution.y;
-            rect.bottom = rect.bottom * cameraResolution.y / screenResolution.y;
+			Rect rect = new Rect(framingRect);
+			rect.left = rect.left * previewWidth / viewFinderViewWidth;
+			rect.right = rect.right * previewWidth / viewFinderViewWidth;
+			rect.top = rect.top * previewHeight / viewFinderViewHeight;
+			rect.bottom = rect.bottom * previewHeight / viewFinderViewHeight;
 
-            mFramingRectInPreview = rect;
-        }
-        return mFramingRectInPreview;
-    }
+			mFramingRectInPreview = rect;
+		}
+		return mFramingRectInPreview;
+	}
 
-    public void setFlash(boolean flag) {
-        if(mCamera != null && CameraUtils.isFlashSupported(mCamera)) {
-            Camera.Parameters parameters = mCamera.getParameters();
-            if(flag) {
-                if(parameters.getFlashMode().equals(Camera.Parameters.FLASH_MODE_TORCH)) {
-                    return;
-                }
-                parameters.setFlashMode(Camera.Parameters.FLASH_MODE_TORCH);
-            } else {
-                if(parameters.getFlashMode().equals(Camera.Parameters.FLASH_MODE_OFF)) {
-                    return;
-                }
-                parameters.setFlashMode(Camera.Parameters.FLASH_MODE_OFF);
-            }
-            mCamera.setParameters(parameters);
-        }
-    }
+	public void setFlash(boolean flag) {
+		if (mCamera != null && CameraUtils.isFlashSupported(mCamera)) {
+			Camera.Parameters parameters = mCamera.getParameters();
+			if (flag) {
+				if (parameters.getFlashMode().equals(Camera.Parameters.FLASH_MODE_TORCH)) {
+					return;
+				}
+				parameters.setFlashMode(Camera.Parameters.FLASH_MODE_TORCH);
+			} else {
+				if (parameters.getFlashMode().equals(Camera.Parameters.FLASH_MODE_OFF)) {
+					return;
+				}
+				parameters.setFlashMode(Camera.Parameters.FLASH_MODE_OFF);
+			}
+			mCamera.setParameters(parameters);
+		}
+	}
 
-    public boolean getFlash() {
-        if(mCamera != null && CameraUtils.isFlashSupported(mCamera)) {
-            Camera.Parameters parameters = mCamera.getParameters();
-            if(parameters.getFlashMode().equals(Camera.Parameters.FLASH_MODE_TORCH)) {
-                return true;
-            } else {
-                return false;
-            }
-        }
-        return false;
-    }
+	public boolean getFlash() {
+		if (mCamera != null && CameraUtils.isFlashSupported(mCamera)) {
+			Camera.Parameters parameters = mCamera.getParameters();
+			if (parameters.getFlashMode().equals(Camera.Parameters.FLASH_MODE_TORCH)) {
+				return true;
+			} else {
+				return false;
+			}
+		}
+		return false;
+	}
 
-    public void toggleFlash() {
-        if(mCamera != null && CameraUtils.isFlashSupported(mCamera)) {
-            Camera.Parameters parameters = mCamera.getParameters();
-            if(parameters.getFlashMode().equals(Camera.Parameters.FLASH_MODE_TORCH)) {
-                parameters.setFlashMode(Camera.Parameters.FLASH_MODE_OFF);
-            } else {
-                parameters.setFlashMode(Camera.Parameters.FLASH_MODE_TORCH);
-            }
-            mCamera.setParameters(parameters);
-        }
-    }
+	public void toggleFlash() {
+		if (mCamera != null && CameraUtils.isFlashSupported(mCamera)) {
+			Camera.Parameters parameters = mCamera.getParameters();
+			if (parameters.getFlashMode().equals(Camera.Parameters.FLASH_MODE_TORCH)) {
+				parameters.setFlashMode(Camera.Parameters.FLASH_MODE_OFF);
+			} else {
+				parameters.setFlashMode(Camera.Parameters.FLASH_MODE_TORCH);
+			}
+			mCamera.setParameters(parameters);
+		}
+	}
 
-    public void setAutoFocus(boolean state) {
-        if(mPreview != null) {
-            mPreview.setAutoFocus(state);
-        }
-    }
+	public void setAutoFocus(boolean state) {
+		if (mPreview != null) {
+			mPreview.setAutoFocus(state);
+		}
+	}
 }
diff --git a/core/src/main/java/me/dm7/barcodescanner/core/CameraPreview.java b/core/src/main/java/me/dm7/barcodescanner/core/CameraPreview.java
index 9aed1ec..a25a69d 100644
--- a/core/src/main/java/me/dm7/barcodescanner/core/CameraPreview.java
+++ b/core/src/main/java/me/dm7/barcodescanner/core/CameraPreview.java
@@ -11,204 +11,246 @@
 import android.view.Surface;
 import android.view.SurfaceHolder;
 import android.view.SurfaceView;
+import android.view.ViewGroup;
 import android.view.WindowManager;
 
 import java.util.List;
 
 public class CameraPreview extends SurfaceView implements SurfaceHolder.Callback {
-    private static final String TAG = "CameraPreview";
-
-    private Camera mCamera;
-    private Handler mAutoFocusHandler;
-    private boolean mPreviewing = true;
-    private boolean mAutoFocus = true;
-    private boolean mSurfaceCreated = false;
-    private Camera.PreviewCallback mPreviewCallback;
-
-    public CameraPreview(Context context) {
-        super(context);
-    }
-
-    public CameraPreview(Context context, AttributeSet attrs) {
-        super(context, attrs);
-    }
-
-    public void setCamera(Camera camera, Camera.PreviewCallback previewCallback) {
-        mCamera = camera;
-        mPreviewCallback = previewCallback;
-        mAutoFocusHandler = new Handler();
-    }
-
-    public void initCameraPreview() {
-        if(mCamera != null) {
-            getHolder().addCallback(this);
-            getHolder().setType(SurfaceHolder.SURFACE_TYPE_PUSH_BUFFERS);
-            if(mPreviewing) {
-                requestLayout();
-            } else {
-                showCameraPreview();
-            }
-        }
-    }
-
-    @Override
-    public void surfaceCreated(SurfaceHolder surfaceHolder) {
-        mSurfaceCreated = true;
-    }
-
-    @Override
-    public void surfaceChanged(SurfaceHolder surfaceHolder, int i, int i2, int i3) {
-        if(surfaceHolder.getSurface() == null) {
-            return;
-        }
-        stopCameraPreview();
-        showCameraPreview();
-    }
-
-    @Override
-    public void surfaceDestroyed(SurfaceHolder surfaceHolder) {
-        mSurfaceCreated = false;
-        stopCameraPreview();
-    }
-
-    public void showCameraPreview() {
-        if(mCamera != null) {
-            try {
-                mPreviewing = true;
-                setupCameraParameters();
-                mCamera.setPreviewDisplay(getHolder());
-                mCamera.setDisplayOrientation(getDisplayOrientation());
-                mCamera.setOneShotPreviewCallback(mPreviewCallback);
-                mCamera.startPreview();
-                if(mAutoFocus) {
-                    mCamera.autoFocus(autoFocusCB);
-                }
-            } catch (Exception e) {
-                Log.e(TAG, e.toString(), e);
-            }
-        }
-    }
-
-    public void stopCameraPreview() {
-        if(mCamera != null) {
-            try {
-                mPreviewing = false;
-                mCamera.cancelAutoFocus();
-                mCamera.setOneShotPreviewCallback(null);
-                mCamera.stopPreview();
-            } catch(Exception e) {
-                Log.e(TAG, e.toString(), e);
-            }
-        }
-    }
-
-    public void setupCameraParameters() {
-        Camera.Size optimalSize = getOptimalPreviewSize();
-        Camera.Parameters parameters = mCamera.getParameters();
-        parameters.setPreviewSize(optimalSize.width, optimalSize.height);
-        mCamera.setParameters(parameters);
-    }
-
-    public int getDisplayOrientation() {
-        Camera.CameraInfo info = new Camera.CameraInfo();
-        Camera.getCameraInfo(Camera.CameraInfo.CAMERA_FACING_BACK, info);
-        WindowManager wm = (WindowManager) getContext().getSystemService(Context.WINDOW_SERVICE);
-        Display display = wm.getDefaultDisplay();
-
-        int rotation = display.getRotation();
-        int degrees = 0;
-        switch (rotation) {
-            case Surface.ROTATION_0: degrees = 0; break;
-            case Surface.ROTATION_90: degrees = 90; break;
-            case Surface.ROTATION_180: degrees = 180; break;
-            case Surface.ROTATION_270: degrees = 270; break;
-        }
-
-        int result;
-        if (info.facing == Camera.CameraInfo.CAMERA_FACING_FRONT) {
-            result = (info.orientation + degrees) % 360;
-            result = (360 - result) % 360;  // compensate the mirror
-        } else {  // back-facing
-            result = (info.orientation - degrees + 360) % 360;
-        }
-        return result;
-    }
-
-    private Camera.Size getOptimalPreviewSize() {
-        if(mCamera == null) {
-            return null;
-        }
-
-        List<Camera.Size> sizes = mCamera.getParameters().getSupportedPreviewSizes();
-        Point screenResolution = DisplayUtils.getScreenResolution(getContext());
-        int w = screenResolution.x;
-        int h = screenResolution.y;
-        if (DisplayUtils.getScreenOrientation(getContext()) == Configuration.ORIENTATION_PORTRAIT) {
-            w = screenResolution.y;
-            h = screenResolution.x;
-        }
-
-
-        final double ASPECT_TOLERANCE = 0.1;
-        double targetRatio = (double) w / h;
-        if (sizes == null) return null;
-
-        Camera.Size optimalSize = null;
-        double minDiff = Double.MAX_VALUE;
-
-        int targetHeight = h;
-
-        // Try to find an size match aspect ratio and size
-        for (Camera.Size size : sizes) {
-            double ratio = (double) size.width / size.height;
-            if (Math.abs(ratio - targetRatio) > ASPECT_TOLERANCE) continue;
-            if (Math.abs(size.height - targetHeight) < minDiff) {
-                optimalSize = size;
-                minDiff = Math.abs(size.height - targetHeight);
-            }
-        }
-
-        // Cannot find the one match the aspect ratio, ignore the requirement
-        if (optimalSize == null) {
-            minDiff = Double.MAX_VALUE;
-            for (Camera.Size size : sizes) {
-                if (Math.abs(size.height - targetHeight) < minDiff) {
-                    optimalSize = size;
-                    minDiff = Math.abs(size.height - targetHeight);
-                }
-            }
-        }
-        return optimalSize;
-    }
-
-    public void setAutoFocus(boolean state) {
-        if(mCamera != null && mPreviewing) {
-            if(state == mAutoFocus) {
-                return;
-            }
-            mAutoFocus = state;
-            if(mAutoFocus) {
-                Log.v(TAG, "Starting autofocus");
-                mCamera.autoFocus(autoFocusCB);
-            } else {
-                Log.v(TAG, "Cancelling autofocus");
-                mCamera.cancelAutoFocus();
-            }
-        }
-    }
-
-    private Runnable doAutoFocus = new Runnable() {
-        public void run() {
-            if(mCamera != null && mPreviewing && mAutoFocus && mSurfaceCreated) {
-                mCamera.autoFocus(autoFocusCB);
-            }
-        }
-    };
-
-    // Mimic continuous auto-focusing
-    Camera.AutoFocusCallback autoFocusCB = new Camera.AutoFocusCallback() {
-        public void onAutoFocus(boolean success, Camera camera) {
-            mAutoFocusHandler.postDelayed(doAutoFocus, 1000);
-        }
-    };
+	private static final String TAG = "CameraPreview";
+
+	private Camera mCamera;
+	private Handler mAutoFocusHandler;
+	private boolean mPreviewing = true;
+	private boolean mAutoFocus = true;
+	private boolean mSurfaceCreated = false;
+	private Camera.PreviewCallback mPreviewCallback;
+
+	public CameraPreview(Context context) {
+		super(context);
+	}
+
+	public CameraPreview(Context context, AttributeSet attrs) {
+		super(context, attrs);
+	}
+
+	public void setCamera(Camera camera, Camera.PreviewCallback previewCallback) {
+		mCamera = camera;
+		mPreviewCallback = previewCallback;
+		mAutoFocusHandler = new Handler();
+	}
+
+	public void initCameraPreview() {
+		if (mCamera != null) {
+			getHolder().addCallback(this);
+			getHolder().setType(SurfaceHolder.SURFACE_TYPE_PUSH_BUFFERS);
+			if (mPreviewing) {
+				requestLayout();
+			} else {
+				showCameraPreview();
+			}
+		}
+	}
+
+	@Override
+	public void surfaceCreated(SurfaceHolder surfaceHolder) {
+		mSurfaceCreated = true;
+	}
+
+	@Override
+	public void surfaceChanged(SurfaceHolder surfaceHolder, int i, int i2, int i3) {
+		if (surfaceHolder.getSurface() == null) {
+			return;
+		}
+		stopCameraPreview();
+		showCameraPreview();
+	}
+
+	@Override
+	public void surfaceDestroyed(SurfaceHolder surfaceHolder) {
+		mSurfaceCreated = false;
+		stopCameraPreview();
+	}
+
+	public void showCameraPreview() {
+		if (mCamera != null) {
+			try {
+				mPreviewing = true;
+				setupCameraParameters();
+				mCamera.setPreviewDisplay(getHolder());
+				mCamera.setDisplayOrientation(getDisplayOrientation());
+				mCamera.setOneShotPreviewCallback(mPreviewCallback);
+				mCamera.startPreview();
+				if (mAutoFocus) {
+					mCamera.autoFocus(autoFocusCB);
+				}
+			} catch (Exception e) {
+				Log.e(TAG, e.toString(), e);
+			}
+		}
+	}
+
+	public void stopCameraPreview() {
+		if (mCamera != null) {
+			try {
+				mPreviewing = false;
+				mCamera.cancelAutoFocus();
+				mCamera.setOneShotPreviewCallback(null);
+				mCamera.stopPreview();
+			} catch (Exception e) {
+				Log.e(TAG, e.toString(), e);
+			}
+		}
+	}
+
+	public void setupCameraParameters() {
+		Camera.Size optimalSize = getOptimalPreviewSize();
+		Camera.Parameters parameters = mCamera.getParameters();
+		parameters.setPreviewSize(optimalSize.width, optimalSize.height);
+		mCamera.setParameters(parameters);
+		adjustViewSize(optimalSize);
+	}
+
+	private void adjustViewSize(Camera.Size cameraSize) {
+		Point screenSize = convertSizeToLandscapeOrientation(DisplayUtils.getScreenResolution(getContext()));
+		float cameraRatio = ((float) cameraSize.width) / cameraSize.height;
+		float screenRatio = ((float) screenSize.x) / screenSize.y;
+
+		if (screenRatio > cameraRatio) {
+			setViewSize((int) (screenSize.y * cameraRatio), screenSize.y);
+		} else {
+			setViewSize(screenSize.x, (int) (screenSize.x / cameraRatio));
+		}
+	}
+
+	private Point convertSizeToLandscapeOrientation(Point size) {
+		if (getDisplayOrientation() % 180 == 0) {
+			return size;
+		} else {
+			return new Point(size.y, size.x);
+		}
+	}
+
+	private void setViewSize(int width, int height) {
+		ViewGroup.LayoutParams layoutParams = getLayoutParams();
+		if (getDisplayOrientation() % 180 == 0) {
+			layoutParams.width = width;
+			layoutParams.height = height;
+		} else {
+			layoutParams.width = height;
+			layoutParams.height = width;
+		}
+		setLayoutParams(layoutParams);
+	}
+
+	public int getDisplayOrientation() {
+		Camera.CameraInfo info = new Camera.CameraInfo();
+		Camera.getCameraInfo(Camera.CameraInfo.CAMERA_FACING_BACK, info);
+		WindowManager wm = (WindowManager) getContext().getSystemService(Context.WINDOW_SERVICE);
+		Display display = wm.getDefaultDisplay();
+
+		int rotation = display.getRotation();
+		int degrees = 0;
+		switch (rotation) {
+			case Surface.ROTATION_0:
+				degrees = 0;
+				break;
+			case Surface.ROTATION_90:
+				degrees = 90;
+				break;
+			case Surface.ROTATION_180:
+				degrees = 180;
+				break;
+			case Surface.ROTATION_270:
+				degrees = 270;
+				break;
+		}
+
+		int result;
+		if (info.facing == Camera.CameraInfo.CAMERA_FACING_FRONT) {
+			result = (info.orientation + degrees) % 360;
+			result = (360 - result) % 360;  // compensate the mirror
+		} else {  // back-facing
+			result = (info.orientation - degrees + 360) % 360;
+		}
+		return result;
+	}
+
+	private Camera.Size getOptimalPreviewSize() {
+		if (mCamera == null) {
+			return null;
+		}
+
+		List<Camera.Size> sizes = mCamera.getParameters().getSupportedPreviewSizes();
+		Point screenResolution = DisplayUtils.getScreenResolution(getContext());
+		int w = screenResolution.x;
+		int h = screenResolution.y;
+		if (DisplayUtils.getScreenOrientation(getContext()) == Configuration.ORIENTATION_PORTRAIT) {
+			w = screenResolution.y;
+			h = screenResolution.x;
+		}
+
+
+		final double ASPECT_TOLERANCE = 0.1;
+		double targetRatio = (double) w / h;
+		if (sizes == null) return null;
+
+		Camera.Size optimalSize = null;
+		double minDiff = Double.MAX_VALUE;
+
+		int targetHeight = h;
+
+		// Try to find an size match aspect ratio and size
+		for (Camera.Size size : sizes) {
+			double ratio = (double) size.width / size.height;
+			if (Math.abs(ratio - targetRatio) > ASPECT_TOLERANCE) continue;
+			if (Math.abs(size.height - targetHeight) < minDiff) {
+				optimalSize = size;
+				minDiff = Math.abs(size.height - targetHeight);
+			}
+		}
+
+		// Cannot find the one match the aspect ratio, ignore the requirement
+		if (optimalSize == null) {
+			minDiff = Double.MAX_VALUE;
+			for (Camera.Size size : sizes) {
+				if (Math.abs(size.height - targetHeight) < minDiff) {
+					optimalSize = size;
+					minDiff = Math.abs(size.height - targetHeight);
+				}
+			}
+		}
+		return optimalSize;
+	}
+
+	public void setAutoFocus(boolean state) {
+		if (mCamera != null && mPreviewing) {
+			if (state == mAutoFocus) {
+				return;
+			}
+			mAutoFocus = state;
+			if (mAutoFocus) {
+				Log.v(TAG, "Starting autofocus");
+				mCamera.autoFocus(autoFocusCB);
+			} else {
+				Log.v(TAG, "Cancelling autofocus");
+				mCamera.cancelAutoFocus();
+			}
+		}
+	}
+
+	private Runnable doAutoFocus = new Runnable() {
+		public void run() {
+			if (mCamera != null && mPreviewing && mAutoFocus && mSurfaceCreated) {
+				mCamera.autoFocus(autoFocusCB);
+			}
+		}
+	};
+
+	// Mimic continuous auto-focusing
+	Camera.AutoFocusCallback autoFocusCB = new Camera.AutoFocusCallback() {
+		public void onAutoFocus(boolean success, Camera camera) {
+			mAutoFocusHandler.postDelayed(doAutoFocus, 1000);
+		}
+	};
 }
\ No newline at end of file
diff --git a/core/src/main/java/me/dm7/barcodescanner/core/ViewFinderView.java b/core/src/main/java/me/dm7/barcodescanner/core/ViewFinderView.java
index 9b44f81..e8955f7 100644
--- a/core/src/main/java/me/dm7/barcodescanner/core/ViewFinderView.java
+++ b/core/src/main/java/me/dm7/barcodescanner/core/ViewFinderView.java
@@ -11,145 +11,166 @@
 import android.view.View;
 
 public class ViewFinderView extends View {
-    private static final String TAG = "ViewFinderView";
-
-    private Rect mFramingRect;
-
-    private static final int MIN_FRAME_WIDTH = 240;
-    private static final int MIN_FRAME_HEIGHT = 240;
-
-    private static final float LANDSCAPE_WIDTH_RATIO = 5f/8;
-    private static final float LANDSCAPE_HEIGHT_RATIO = 5f/8;
-    private static final int LANDSCAPE_MAX_FRAME_WIDTH = (int) (1920 * LANDSCAPE_WIDTH_RATIO); // = 5/8 * 1920
-    private static final int LANDSCAPE_MAX_FRAME_HEIGHT = (int) (1080 * LANDSCAPE_HEIGHT_RATIO); // = 5/8 * 1080
-
-    private static final float PORTRAIT_WIDTH_RATIO = 7f/8;
-    private static final float PORTRAIT_HEIGHT_RATIO = 3f/8;
-    private static final int PORTRAIT_MAX_FRAME_WIDTH = (int) (1080 * PORTRAIT_WIDTH_RATIO); // = 7/8 * 1080
-    private static final int PORTRAIT_MAX_FRAME_HEIGHT = (int) (1920 * PORTRAIT_HEIGHT_RATIO); // = 3/8 * 1920
-
-    private static final int[] SCANNER_ALPHA = {0, 64, 128, 192, 255, 192, 128, 64};
-    private int scannerAlpha;
-    private static final int POINT_SIZE = 10;
-    private static final long ANIMATION_DELAY = 80l;
-
-    public ViewFinderView(Context context) {
-        super(context);
-    }
-
-    public ViewFinderView(Context context, AttributeSet attrs) {
-        super(context, attrs);
-    }
-
-    public void setupViewFinder() {
-        updateFramingRect();
-        invalidate();
-    }
-
-    public Rect getFramingRect() {
-        return mFramingRect;
-    }
-
-    @Override
-    public void onDraw(Canvas canvas) {
-        if(mFramingRect == null) {
-            return;
-        }
-
-        drawViewFinderMask(canvas);
-        drawViewFinderBorder(canvas);
-        drawLaser(canvas);
-    }
-
-    public void drawViewFinderMask(Canvas canvas) {
-        Paint paint = new Paint();
-        Resources resources = getResources();
-        paint.setColor(resources.getColor(R.color.viewfinder_mask));
-
-        int width = canvas.getWidth();
-        int height = canvas.getHeight();
-
-        canvas.drawRect(0, 0, width, mFramingRect.top, paint);
-        canvas.drawRect(0, mFramingRect.top, mFramingRect.left, mFramingRect.bottom + 1, paint);
-        canvas.drawRect(mFramingRect.right + 1, mFramingRect.top, width, mFramingRect.bottom + 1, paint);
-        canvas.drawRect(0, mFramingRect.bottom + 1, width, height, paint);
-    }
-
-    public void drawViewFinderBorder(Canvas canvas) {
-        Paint paint = new Paint();
-        Resources resources = getResources();
-        paint.setColor(resources.getColor(R.color.viewfinder_border));
-        paint.setStyle(Paint.Style.STROKE);
-        paint.setStrokeWidth(resources.getInteger(R.integer.viewfinder_border_width));
-        int lineLength = resources.getInteger(R.integer.viewfinder_border_length);
-
-        canvas.drawLine(mFramingRect.left - 1, mFramingRect.top - 1, mFramingRect.left - 1, mFramingRect.top - 1 + lineLength, paint);
-        canvas.drawLine(mFramingRect.left - 1, mFramingRect.top - 1, mFramingRect.left - 1 + lineLength, mFramingRect.top - 1, paint);
-
-        canvas.drawLine(mFramingRect.left - 1, mFramingRect.bottom + 1, mFramingRect.left - 1, mFramingRect.bottom + 1 - lineLength, paint);
-        canvas.drawLine(mFramingRect.left - 1, mFramingRect.bottom + 1, mFramingRect.left - 1 + lineLength, mFramingRect.bottom + 1, paint);
-
-        canvas.drawLine(mFramingRect.right + 1, mFramingRect.top - 1, mFramingRect.right + 1, mFramingRect.top - 1 + lineLength, paint);
-        canvas.drawLine(mFramingRect.right + 1, mFramingRect.top - 1, mFramingRect.right + 1 - lineLength, mFramingRect.top - 1, paint);
-
-        canvas.drawLine(mFramingRect.right + 1, mFramingRect.bottom + 1, mFramingRect.right + 1, mFramingRect.bottom + 1 - lineLength, paint);
-        canvas.drawLine(mFramingRect.right + 1, mFramingRect.bottom + 1, mFramingRect.right + 1 - lineLength, mFramingRect.bottom + 1, paint);
-    }
-
-    public void drawLaser(Canvas canvas) {
-        Paint paint = new Paint();
-        Resources resources = getResources();
-        // Draw a red "laser scanner" line through the middle to show decoding is active
-        paint.setColor(resources.getColor(R.color.viewfinder_laser));
-        paint.setAlpha(SCANNER_ALPHA[scannerAlpha]);
-        paint.setStyle(Paint.Style.FILL);
-        scannerAlpha = (scannerAlpha + 1) % SCANNER_ALPHA.length;
-        int middle = mFramingRect.height() / 2 + mFramingRect.top;
-        canvas.drawRect(mFramingRect.left + 2, middle - 1, mFramingRect.right - 1, middle + 2, paint);
-
-        postInvalidateDelayed(ANIMATION_DELAY,
-                mFramingRect.left - POINT_SIZE,
-                mFramingRect.top - POINT_SIZE,
-                mFramingRect.right + POINT_SIZE,
-                mFramingRect.bottom + POINT_SIZE);
-    }
-
-    @Override
-    protected void onSizeChanged(int xNew, int yNew, int xOld, int yOld) {
-        updateFramingRect();
-    }
-
-    public synchronized void updateFramingRect() {
-        Point viewResolution = new Point(getWidth(), getHeight());
-        if (viewResolution == null) {
-            return;
-        }
-        int width;
-        int height;
-        int orientation = DisplayUtils.getScreenOrientation(getContext());
-
-        if(orientation != Configuration.ORIENTATION_PORTRAIT) {
-            width = findDesiredDimensionInRange(LANDSCAPE_WIDTH_RATIO, viewResolution.x, MIN_FRAME_WIDTH, LANDSCAPE_MAX_FRAME_WIDTH);
-            height = findDesiredDimensionInRange(LANDSCAPE_HEIGHT_RATIO, viewResolution.y, MIN_FRAME_HEIGHT, LANDSCAPE_MAX_FRAME_HEIGHT);
-        } else {
-            width = findDesiredDimensionInRange(PORTRAIT_WIDTH_RATIO, viewResolution.x, MIN_FRAME_WIDTH, PORTRAIT_MAX_FRAME_WIDTH);
-            height = findDesiredDimensionInRange(PORTRAIT_HEIGHT_RATIO, viewResolution.y, MIN_FRAME_HEIGHT, PORTRAIT_MAX_FRAME_HEIGHT);
-        }
-
-        int leftOffset = (viewResolution.x - width) / 2;
-        int topOffset = (viewResolution.y - height) / 2;
-        mFramingRect = new Rect(leftOffset, topOffset, leftOffset + width, topOffset + height);
-    }
-
-    private static int findDesiredDimensionInRange(float ratio, int resolution, int hardMin, int hardMax) {
-        int dim = (int) (ratio * resolution);
-        if (dim < hardMin) {
-            return hardMin;
-        }
-        if (dim > hardMax) {
-            return hardMax;
-        }
-        return dim;
-    }
+	private static final String TAG = "ViewFinderView";
+
+	private Rect mFramingRect;
+
+	private static final int MIN_FRAME_WIDTH = 240;
+	private static final int MIN_FRAME_HEIGHT = 240;
+
+	private static final float LANDSCAPE_WIDTH_RATIO = 5f / 8;
+	private static final float LANDSCAPE_HEIGHT_RATIO = 5f / 8;
+	private static final int LANDSCAPE_MAX_FRAME_WIDTH = (int) (1920 * LANDSCAPE_WIDTH_RATIO); // = 5/8 * 1920
+	private static final int LANDSCAPE_MAX_FRAME_HEIGHT = (int) (1080 * LANDSCAPE_HEIGHT_RATIO); // = 5/8 * 1080
+
+	private static final float PORTRAIT_WIDTH_RATIO = 7f / 8;
+	private static final float PORTRAIT_HEIGHT_RATIO = 4f / 8;
+	private static final int PORTRAIT_MAX_FRAME_WIDTH = (int) (1080 * PORTRAIT_WIDTH_RATIO); // = 7/8 * 1080
+	private static final int PORTRAIT_MAX_FRAME_HEIGHT = (int) (1920 * PORTRAIT_HEIGHT_RATIO); // = 3/8 * 1920
+
+	private Paint maskPaint = new Paint();
+	private Paint borderPaint = new Paint();
+	private int borderLineLength;
+
+	public ViewFinderView(Context context) {
+		super(context);
+	}
+
+	public ViewFinderView(Context context, AttributeSet attrs) {
+		super(context, attrs);
+	}
+
+	public void setupViewFinder() {
+		initPaints();
+		updateFramingRect();
+		invalidate();
+	}
+
+	private void initPaints() {
+		Resources resources = getResources();
+		maskPaint.setColor(resources.getColor(R.color.viewfinder_mask));
+
+		borderPaint.setColor(resources.getColor(R.color.viewfinder_border));
+		borderPaint.setStyle(Paint.Style.STROKE);
+		borderPaint.setStrokeWidth(resources.getInteger(R.integer.viewfinder_border_width));
+		borderLineLength = resources.getInteger(R.integer.viewfinder_border_length);
+	}
+
+	public Rect getFramingRect() {
+		return mFramingRect;
+	}
+
+	@Override
+	public void onDraw(Canvas canvas) {
+		if (mFramingRect == null) {
+			return;
+		}
+
+		drawViewFinderMask(canvas);
+		drawViewFinderBorder(canvas);
+	}
+
+	public void drawViewFinderMask(Canvas canvas) {
+		int width = canvas.getWidth();
+		int height = canvas.getHeight();
+
+		canvas.drawRect(0, 0, width, mFramingRect.top, maskPaint);
+		canvas.drawRect(0, mFramingRect.top, mFramingRect.left, mFramingRect.bottom + 1, maskPaint);
+		canvas.drawRect(mFramingRect.right + 1, mFramingRect.top, width, mFramingRect.bottom + 1, maskPaint);
+		canvas.drawRect(0, mFramingRect.bottom + 1, width, height, maskPaint);
+	}
+
+	public void drawViewFinderBorder(Canvas canvas) {
+		float border = borderPaint.getStrokeWidth() / 2;
+		canvas.drawLine(
+				mFramingRect.left - 1,
+				mFramingRect.top - 1 - border,
+				mFramingRect.left - 1,
+				mFramingRect.top - 1 + borderLineLength,
+				borderPaint);
+		canvas.drawLine(
+				mFramingRect.left - 1 - border,
+				mFramingRect.top - 1,
+				mFramingRect.left - 1 + borderLineLength,
+				mFramingRect.top - 1,
+				borderPaint);
+
+		canvas.drawLine(
+				mFramingRect.left - 1,
+				mFramingRect.bottom + 1 + border,
+				mFramingRect.left - 1,
+				mFramingRect.bottom + 1 - borderLineLength,
+				borderPaint);
+		canvas.drawLine(
+				mFramingRect.left - 1 - border,
+				mFramingRect.bottom + 1,
+				mFramingRect.left - 1 + borderLineLength,
+				mFramingRect.bottom + 1,
+				borderPaint);
+
+		canvas.drawLine(
+				mFramingRect.right + 1,
+				mFramingRect.top - 1 - border,
+				mFramingRect.right + 1,
+				mFramingRect.top - 1 + borderLineLength,
+				borderPaint);
+		canvas.drawLine(
+				mFramingRect.right + 1 + border,
+				mFramingRect.top - 1,
+				mFramingRect.right + 1 - borderLineLength,
+				mFramingRect.top - 1,
+				borderPaint);
+
+		canvas.drawLine(
+				mFramingRect.right + 1,
+				mFramingRect.bottom + 1 + border,
+				mFramingRect.right + 1,
+				mFramingRect.bottom + 1 - borderLineLength,
+				borderPaint);
+		canvas.drawLine(
+				mFramingRect.right + 1 + border,
+				mFramingRect.bottom + 1,
+				mFramingRect.right + 1 - borderLineLength,
+				mFramingRect.bottom + 1,
+				borderPaint);
+	}
+
+	@Override
+	protected void onSizeChanged(int xNew, int yNew, int xOld, int yOld) {
+		updateFramingRect();
+	}
+
+	public synchronized void updateFramingRect() {
+		Point viewResolution = new Point(getWidth(), getHeight());
+		if (viewResolution == null) {
+			return;
+		}
+		int width;
+		int height;
+		int orientation = DisplayUtils.getScreenOrientation(getContext());
+
+		if (orientation != Configuration.ORIENTATION_PORTRAIT) {
+			width = findDesiredDimensionInRange(LANDSCAPE_WIDTH_RATIO, viewResolution.x, MIN_FRAME_WIDTH, LANDSCAPE_MAX_FRAME_WIDTH);
+			height = findDesiredDimensionInRange(LANDSCAPE_HEIGHT_RATIO, viewResolution.y, MIN_FRAME_HEIGHT, LANDSCAPE_MAX_FRAME_HEIGHT);
+		} else {
+			width = findDesiredDimensionInRange(PORTRAIT_WIDTH_RATIO, viewResolution.x, MIN_FRAME_WIDTH, PORTRAIT_MAX_FRAME_WIDTH);
+			height = findDesiredDimensionInRange(PORTRAIT_HEIGHT_RATIO, viewResolution.y, MIN_FRAME_HEIGHT, PORTRAIT_MAX_FRAME_HEIGHT);
+		}
+
+		int leftOffset = (viewResolution.x - width) / 2;
+		int topOffset = (viewResolution.y - height) / 2;
+		mFramingRect = new Rect(leftOffset, topOffset, leftOffset + width, topOffset + height);
+	}
+
+	private static int findDesiredDimensionInRange(float ratio, int resolution, int hardMin, int hardMax) {
+		int dim = (int) (ratio * resolution);
+		if (dim < hardMin) {
+			return hardMin;
+		}
+		if (dim > hardMax) {
+			return hardMax;
+		}
+		return dim;
+	}
 
 }
diff --git a/core/src/main/res/values/colors.xml b/core/src/main/res/values/colors.xml
index 58c019a..1b1ebb2 100644
--- a/core/src/main/res/values/colors.xml
+++ b/core/src/main/res/values/colors.xml
@@ -1,6 +1,6 @@
 <?xml version="1.0" encoding="utf-8"?>
 <resources>
-    <color name="viewfinder_mask">#60000000</color>
+    <color name="viewfinder_mask">#88000000</color>
     <color name="viewfinder_laser">#ffcc0000</color>
     <color name="viewfinder_border">#ffafed44</color>
 </resources>
\ No newline at end of file
diff --git a/gradle/wrapper/gradle-wrapper.jar b/gradle/wrapper/gradle-wrapper.jar
new file mode 100644
index 0000000..8c0fb64
Binary files /dev/null and b/gradle/wrapper/gradle-wrapper.jar differ
diff --git a/gradle/wrapper/gradle-wrapper.properties b/gradle/wrapper/gradle-wrapper.properties
new file mode 100644
index 0000000..0c71e76
--- /dev/null
+++ b/gradle/wrapper/gradle-wrapper.properties
@@ -0,0 +1,6 @@
+#Wed Apr 10 15:27:10 PDT 2013
+distributionBase=GRADLE_USER_HOME
+distributionPath=wrapper/dists
+zipStoreBase=GRADLE_USER_HOME
+zipStorePath=wrapper/dists
+distributionUrl=https\://services.gradle.org/distributions/gradle-2.2.1-all.zip
diff --git a/gradlew b/gradlew
new file mode 100644
index 0000000..91a7e26
--- /dev/null
+++ b/gradlew
@@ -0,0 +1,164 @@
+#!/usr/bin/env bash
+
+##############################################################################
+##
+##  Gradle start up script for UN*X
+##
+##############################################################################
+
+# Add default JVM options here. You can also use JAVA_OPTS and GRADLE_OPTS to pass JVM options to this script.
+DEFAULT_JVM_OPTS=""
+
+APP_NAME="Gradle"
+APP_BASE_NAME=`basename "$0"`
+
+# Use the maximum available, or set MAX_FD != -1 to use that value.
+MAX_FD="maximum"
+
+warn ( ) {
+    echo "$*"
+}
+
+die ( ) {
+    echo
+    echo "$*"
+    echo
+    exit 1
+}
+
+# OS specific support (must be 'true' or 'false').
+cygwin=false
+msys=false
+darwin=false
+case "`uname`" in
+  CYGWIN* )
+    cygwin=true
+    ;;
+  Darwin* )
+    darwin=true
+    ;;
+  MINGW* )
+    msys=true
+    ;;
+esac
+
+# For Cygwin, ensure paths are in UNIX format before anything is touched.
+if $cygwin ; then
+    [ -n "$JAVA_HOME" ] && JAVA_HOME=`cygpath --unix "$JAVA_HOME"`
+fi
+
+# Attempt to set APP_HOME
+# Resolve links: $0 may be a link
+PRG="$0"
+# Need this for relative symlinks.
+while [ -h "$PRG" ] ; do
+    ls=`ls -ld "$PRG"`
+    link=`expr "$ls" : '.*-> \(.*\)$'`
+    if expr "$link" : '/.*' > /dev/null; then
+        PRG="$link"
+    else
+        PRG=`dirname "$PRG"`"/$link"
+    fi
+done
+SAVED="`pwd`"
+cd "`dirname \"$PRG\"`/" >&-
+APP_HOME="`pwd -P`"
+cd "$SAVED" >&-
+
+CLASSPATH=$APP_HOME/gradle/wrapper/gradle-wrapper.jar
+
+# Determine the Java command to use to start the JVM.
+if [ -n "$JAVA_HOME" ] ; then
+    if [ -x "$JAVA_HOME/jre/sh/java" ] ; then
+        # IBM's JDK on AIX uses strange locations for the executables
+        JAVACMD="$JAVA_HOME/jre/sh/java"
+    else
+        JAVACMD="$JAVA_HOME/bin/java"
+    fi
+    if [ ! -x "$JAVACMD" ] ; then
+        die "ERROR: JAVA_HOME is set to an invalid directory: $JAVA_HOME
+
+Please set the JAVA_HOME variable in your environment to match the
+location of your Java installation."
+    fi
+else
+    JAVACMD="java"
+    which java >/dev/null 2>&1 || die "ERROR: JAVA_HOME is not set and no 'java' command could be found in your PATH.
+
+Please set the JAVA_HOME variable in your environment to match the
+location of your Java installation."
+fi
+
+# Increase the maximum file descriptors if we can.
+if [ "$cygwin" = "false" -a "$darwin" = "false" ] ; then
+    MAX_FD_LIMIT=`ulimit -H -n`
+    if [ $? -eq 0 ] ; then
+        if [ "$MAX_FD" = "maximum" -o "$MAX_FD" = "max" ] ; then
+            MAX_FD="$MAX_FD_LIMIT"
+        fi
+        ulimit -n $MAX_FD
+        if [ $? -ne 0 ] ; then
+            warn "Could not set maximum file descriptor limit: $MAX_FD"
+        fi
+    else
+        warn "Could not query maximum file descriptor limit: $MAX_FD_LIMIT"
+    fi
+fi
+
+# For Darwin, add options to specify how the application appears in the dock
+if $darwin; then
+    GRADLE_OPTS="$GRADLE_OPTS \"-Xdock:name=$APP_NAME\" \"-Xdock:icon=$APP_HOME/media/gradle.icns\""
+fi
+
+# For Cygwin, switch paths to Windows format before running java
+if $cygwin ; then
+    APP_HOME=`cygpath --path --mixed "$APP_HOME"`
+    CLASSPATH=`cygpath --path --mixed "$CLASSPATH"`
+
+    # We build the pattern for arguments to be converted via cygpath
+    ROOTDIRSRAW=`find -L / -maxdepth 1 -mindepth 1 -type d 2>/dev/null`
+    SEP=""
+    for dir in $ROOTDIRSRAW ; do
+        ROOTDIRS="$ROOTDIRS$SEP$dir"
+        SEP="|"
+    done
+    OURCYGPATTERN="(^($ROOTDIRS))"
+    # Add a user-defined pattern to the cygpath arguments
+    if [ "$GRADLE_CYGPATTERN" != "" ] ; then
+        OURCYGPATTERN="$OURCYGPATTERN|($GRADLE_CYGPATTERN)"
+    fi
+    # Now convert the arguments - kludge to limit ourselves to /bin/sh
+    i=0
+    for arg in "$@" ; do
+        CHECK=`echo "$arg"|egrep -c "$OURCYGPATTERN" -`
+        CHECK2=`echo "$arg"|egrep -c "^-"`                                 ### Determine if an option
+
+        if [ $CHECK -ne 0 ] && [ $CHECK2 -eq 0 ] ; then                    ### Added a condition
+            eval `echo args$i`=`cygpath --path --ignore --mixed "$arg"`
+        else
+            eval `echo args$i`="\"$arg\""
+        fi
+        i=$((i+1))
+    done
+    case $i in
+        (0) set -- ;;
+        (1) set -- "$args0" ;;
+        (2) set -- "$args0" "$args1" ;;
+        (3) set -- "$args0" "$args1" "$args2" ;;
+        (4) set -- "$args0" "$args1" "$args2" "$args3" ;;
+        (5) set -- "$args0" "$args1" "$args2" "$args3" "$args4" ;;
+        (6) set -- "$args0" "$args1" "$args2" "$args3" "$args4" "$args5" ;;
+        (7) set -- "$args0" "$args1" "$args2" "$args3" "$args4" "$args5" "$args6" ;;
+        (8) set -- "$args0" "$args1" "$args2" "$args3" "$args4" "$args5" "$args6" "$args7" ;;
+        (9) set -- "$args0" "$args1" "$args2" "$args3" "$args4" "$args5" "$args6" "$args7" "$args8" ;;
+    esac
+fi
+
+# Split up the JVM_OPTS And GRADLE_OPTS values into an array, following the shell quoting and substitution rules
+function splitJvmOpts() {
+    JVM_OPTS=("$@")
+}
+eval splitJvmOpts $DEFAULT_JVM_OPTS $JAVA_OPTS $GRADLE_OPTS
+JVM_OPTS[${#JVM_OPTS[*]}]="-Dorg.gradle.appname=$APP_BASE_NAME"
+
+exec "$JAVACMD" "${JVM_OPTS[@]}" -classpath "$CLASSPATH" org.gradle.wrapper.GradleWrapperMain "$@"
diff --git a/gradlew.bat b/gradlew.bat
new file mode 100644
index 0000000..8a0b282
--- /dev/null
+++ b/gradlew.bat
@@ -0,0 +1,90 @@
+@if "%DEBUG%" == "" @echo off
+@rem ##########################################################################
+@rem
+@rem  Gradle startup script for Windows
+@rem
+@rem ##########################################################################
+
+@rem Set local scope for the variables with windows NT shell
+if "%OS%"=="Windows_NT" setlocal
+
+@rem Add default JVM options here. You can also use JAVA_OPTS and GRADLE_OPTS to pass JVM options to this script.
+set DEFAULT_JVM_OPTS=
+
+set DIRNAME=%~dp0
+if "%DIRNAME%" == "" set DIRNAME=.
+set APP_BASE_NAME=%~n0
+set APP_HOME=%DIRNAME%
+
+@rem Find java.exe
+if defined JAVA_HOME goto findJavaFromJavaHome
+
+set JAVA_EXE=java.exe
+%JAVA_EXE% -version >NUL 2>&1
+if "%ERRORLEVEL%" == "0" goto init
+
+echo.
+echo ERROR: JAVA_HOME is not set and no 'java' command could be found in your PATH.
+echo.
+echo Please set the JAVA_HOME variable in your environment to match the
+echo location of your Java installation.
+
+goto fail
+
+:findJavaFromJavaHome
+set JAVA_HOME=%JAVA_HOME:"=%
+set JAVA_EXE=%JAVA_HOME%/bin/java.exe
+
+if exist "%JAVA_EXE%" goto init
+
+echo.
+echo ERROR: JAVA_HOME is set to an invalid directory: %JAVA_HOME%
+echo.
+echo Please set the JAVA_HOME variable in your environment to match the
+echo location of your Java installation.
+
+goto fail
+
+:init
+@rem Get command-line arguments, handling Windowz variants
+
+if not "%OS%" == "Windows_NT" goto win9xME_args
+if "%@eval[2+2]" == "4" goto 4NT_args
+
+:win9xME_args
+@rem Slurp the command line arguments.
+set CMD_LINE_ARGS=
+set _SKIP=2
+
+:win9xME_args_slurp
+if "x%~1" == "x" goto execute
+
+set CMD_LINE_ARGS=%*
+goto execute
+
+:4NT_args
+@rem Get arguments from the 4NT Shell from JP Software
+set CMD_LINE_ARGS=%$
+
+:execute
+@rem Setup the command line
+
+set CLASSPATH=%APP_HOME%\gradle\wrapper\gradle-wrapper.jar
+
+@rem Execute Gradle
+"%JAVA_EXE%" %DEFAULT_JVM_OPTS% %JAVA_OPTS% %GRADLE_OPTS% "-Dorg.gradle.appname=%APP_BASE_NAME%" -classpath "%CLASSPATH%" org.gradle.wrapper.GradleWrapperMain %CMD_LINE_ARGS%
+
+:end
+@rem End local scope for the variables with windows NT shell
+if "%ERRORLEVEL%"=="0" goto mainEnd
+
+:fail
+rem Set variable GRADLE_EXIT_CONSOLE if you need the _script_ return code instead of
+rem the _cmd.exe /c_ return code!
+if  not "" == "%GRADLE_EXIT_CONSOLE%" exit 1
+exit /b 1
+
+:mainEnd
+if "%OS%"=="Windows_NT" endlocal
+
+:omega
diff --git a/zxing/sample/build.gradle b/zxing/sample/build.gradle
index 9f78c6b..a144fbc 100644
--- a/zxing/sample/build.gradle
+++ b/zxing/sample/build.gradle
@@ -1,8 +1,8 @@
 apply plugin: 'com.android.application'
 
 dependencies {
-    //compile project(":zxing:zxing")
-    compile 'me.dm7.barcodescanner:zxing:1.6.3'
+    compile project(":zxing:zxing")
+//    compile 'me.dm7.barcodescanner:zxing:1.6.3'
     compile supportLibraryDependency
     compile 'com.android.support:appcompat-v7:21.0.3'
 }
diff --git a/zxing/zxing/build.gradle b/zxing/zxing/build.gradle
index b0ec247..7aa82c2 100644
--- a/zxing/zxing/build.gradle
+++ b/zxing/zxing/build.gradle
@@ -9,8 +9,8 @@ ext {
 }
 
 dependencies {
-    //compile project(":core")
-    compile 'me.dm7.barcodescanner:core:1.6.3'
+    compile project(":core")
+//    compile 'me.dm7.barcodescanner:core:1.6.3'
     compile 'com.google.zxing:core:3.2.0'
 }
 
