diff --git a/core/src/main/java/me/dm7/barcodescanner/core/CameraPreview.java b/core/src/main/java/me/dm7/barcodescanner/core/CameraPreview.java
deleted file mode 100644
index b066e25..0000000
--- a/core/src/main/java/me/dm7/barcodescanner/core/CameraPreview.java
+++ /dev/null
@@ -1,312 +0,0 @@
-package me.dm7.barcodescanner.core;
-
-import android.content.Context;
-import android.content.res.Configuration;
-import android.graphics.Point;
-import android.hardware.Camera;
-import android.os.Handler;
-import android.util.AttributeSet;
-import android.util.Log;
-import android.view.Display;
-import android.view.Surface;
-import android.view.SurfaceHolder;
-import android.view.SurfaceView;
-import android.view.View;
-import android.view.ViewGroup;
-import android.view.WindowManager;
-
-import java.util.List;
-
-public class CameraPreview extends SurfaceView implements SurfaceHolder.Callback {
-    private static final String TAG = "CameraPreview";
-
-    private CameraWrapper mCameraWrapper;
-    private Handler mAutoFocusHandler;
-    private boolean mPreviewing = true;
-    private boolean mAutoFocus = true;
-    private boolean mSurfaceCreated = false;
-    private boolean mShouldScaleToFill = true;
-    private Camera.PreviewCallback mPreviewCallback;
-    private float mAspectTolerance = 0.1f;
-
-    public CameraPreview(Context context, CameraWrapper cameraWrapper, Camera.PreviewCallback previewCallback) {
-        super(context);
-        init(cameraWrapper, previewCallback);
-    }
-
-    public CameraPreview(Context context, AttributeSet attrs, CameraWrapper cameraWrapper, Camera.PreviewCallback previewCallback) {
-        super(context, attrs);
-        init(cameraWrapper, previewCallback);
-    }
-
-    public void init(CameraWrapper cameraWrapper, Camera.PreviewCallback previewCallback) {
-        setCamera(cameraWrapper, previewCallback);
-        mAutoFocusHandler = new Handler();
-        getHolder().addCallback(this);
-        getHolder().setType(SurfaceHolder.SURFACE_TYPE_PUSH_BUFFERS);
-    }
-
-    public void setCamera(CameraWrapper cameraWrapper, Camera.PreviewCallback previewCallback) {
-        mCameraWrapper = cameraWrapper;
-        mPreviewCallback = previewCallback;
-    }
-
-    public void setShouldScaleToFill(boolean scaleToFill) {
-        mShouldScaleToFill = scaleToFill;
-    }
-
-    public void setAspectTolerance(float aspectTolerance) {
-        mAspectTolerance = aspectTolerance;
-    }
-
-    @Override
-    public void surfaceCreated(SurfaceHolder surfaceHolder) {
-        mSurfaceCreated = true;
-    }
-
-    @Override
-    public void surfaceChanged(SurfaceHolder surfaceHolder, int i, int i2, int i3) {
-        if(surfaceHolder.getSurface() == null) {
-            return;
-        }
-        stopCameraPreview();
-        showCameraPreview();
-    }
-
-    @Override
-    public void surfaceDestroyed(SurfaceHolder surfaceHolder) {
-        mSurfaceCreated = false;
-        stopCameraPreview();
-    }
-
-    public void showCameraPreview() {
-        if(mCameraWrapper != null) {
-            try {
-                getHolder().addCallback(this);
-                mPreviewing = true;
-                setupCameraParameters();
-                mCameraWrapper.mCamera.setPreviewDisplay(getHolder());
-                mCameraWrapper.mCamera.setDisplayOrientation(getDisplayOrientation());
-                mCameraWrapper.mCamera.setOneShotPreviewCallback(mPreviewCallback);
-                mCameraWrapper.mCamera.startPreview();
-                if(mAutoFocus) {
-                    if (mSurfaceCreated) { // check if surface created before using autofocus
-                        safeAutoFocus();
-                    } else {
-                        scheduleAutoFocus(); // wait 1 sec and then do check again
-                    }
-                }
-            } catch (Exception e) {
-                Log.e(TAG, e.toString(), e);
-            }
-        }
-    }
-
-    public void safeAutoFocus() {
-        try {
-            mCameraWrapper.mCamera.autoFocus(autoFocusCB);
-        } catch (RuntimeException re) {
-            // Horrible hack to deal with autofocus errors on Sony devices
-            // See https://github.com/dm77/barcodescanner/issues/7 for example
-            scheduleAutoFocus(); // wait 1 sec and then do check again
-        }
-    }
-
-    public void stopCameraPreview() {
-        if(mCameraWrapper != null) {
-            try {
-                mPreviewing = false;
-                getHolder().removeCallback(this);
-                mCameraWrapper.mCamera.cancelAutoFocus();
-                mCameraWrapper.mCamera.setOneShotPreviewCallback(null);
-                mCameraWrapper.mCamera.stopPreview();
-            } catch(Exception e) {
-                Log.e(TAG, e.toString(), e);
-            }
-        }
-    }
-
-    public void setupCameraParameters() {
-        Camera.Size optimalSize = getOptimalPreviewSize();
-        Camera.Parameters parameters = mCameraWrapper.mCamera.getParameters();
-        parameters.setPreviewSize(optimalSize.width, optimalSize.height);
-        mCameraWrapper.mCamera.setParameters(parameters);
-        adjustViewSize(optimalSize);
-    }
-
-    private void adjustViewSize(Camera.Size cameraSize) {
-        Point previewSize = convertSizeToLandscapeOrientation(new Point(getWidth(), getHeight()));
-        float cameraRatio = ((float) cameraSize.width) / cameraSize.height;
-        float screenRatio = ((float) previewSize.x) / previewSize.y;
-
-        if (screenRatio > cameraRatio) {
-            setViewSize((int) (previewSize.y * cameraRatio), previewSize.y);
-        } else {
-            setViewSize(previewSize.x, (int) (previewSize.x / cameraRatio));
-        }
-    }
-
-    @SuppressWarnings("SuspiciousNameCombination")
-    private Point convertSizeToLandscapeOrientation(Point size) {
-        if (getDisplayOrientation() % 180 == 0) {
-            return size;
-        } else {
-            return new Point(size.y, size.x);
-        }
-    }
-
-    @SuppressWarnings("SuspiciousNameCombination")
-    private void setViewSize(int width, int height) {
-        ViewGroup.LayoutParams layoutParams = getLayoutParams();
-        int tmpWidth;
-        int tmpHeight;
-        if (getDisplayOrientation() % 180 == 0) {
-            tmpWidth = width;
-            tmpHeight = height;
-        } else {
-            tmpWidth = height;
-            tmpHeight = width;
-        }
-
-        if (mShouldScaleToFill) {
-            int parentWidth = ((View) getParent()).getWidth();
-            int parentHeight = ((View) getParent()).getHeight();
-            float ratioWidth = (float) parentWidth / (float) tmpWidth;
-            float ratioHeight = (float) parentHeight / (float) tmpHeight;
-
-            float compensation;
-
-            if (ratioWidth > ratioHeight) {
-                compensation = ratioWidth;
-            } else {
-                compensation = ratioHeight;
-            }
-
-            tmpWidth = Math.round(tmpWidth * compensation);
-            tmpHeight = Math.round(tmpHeight * compensation);
-        }
-
-        layoutParams.width = tmpWidth;
-        layoutParams.height = tmpHeight;
-        setLayoutParams(layoutParams);
-    }
-
-    public int getDisplayOrientation() {
-        if (mCameraWrapper == null) {
-            //If we don't have a camera set there is no orientation so return dummy value
-            return 0;
-        }
-
-        Camera.CameraInfo info = new Camera.CameraInfo();
-        if(mCameraWrapper.mCameraId == -1) {
-            Camera.getCameraInfo(Camera.CameraInfo.CAMERA_FACING_BACK, info);
-        } else {
-            Camera.getCameraInfo(mCameraWrapper.mCameraId, info);
-        }
-
-        WindowManager wm = (WindowManager) getContext().getSystemService(Context.WINDOW_SERVICE);
-        Display display = wm.getDefaultDisplay();
-
-        int rotation = display.getRotation();
-        int degrees = 0;
-        switch (rotation) {
-            case Surface.ROTATION_0: degrees = 0; break;
-            case Surface.ROTATION_90: degrees = 90; break;
-            case Surface.ROTATION_180: degrees = 180; break;
-            case Surface.ROTATION_270: degrees = 270; break;
-        }
-
-        int result;
-        if (info.facing == Camera.CameraInfo.CAMERA_FACING_FRONT) {
-            result = (info.orientation + degrees) % 360;
-            result = (360 - result) % 360;  // compensate the mirror
-        } else {  // back-facing
-            result = (info.orientation - degrees + 360) % 360;
-        }
-        return result;
-    }
-
-    private Camera.Size getOptimalPreviewSize() {
-        if(mCameraWrapper == null) {
-            return null;
-        }
-
-        List<Camera.Size> sizes = mCameraWrapper.mCamera.getParameters().getSupportedPreviewSizes();
-        int w = getWidth();
-        int h = getHeight();
-        if (DisplayUtils.getScreenOrientation(getContext()) == Configuration.ORIENTATION_PORTRAIT) {
-            int portraitWidth = h;
-            h = w;
-            w = portraitWidth;
-        }
-
-        double targetRatio = (double) w / h;
-        if (sizes == null) return null;
-
-        Camera.Size optimalSize = null;
-        double minDiff = Double.MAX_VALUE;
-
-        int targetHeight = h;
-
-        // Try to find an size match aspect ratio and size
-        for (Camera.Size size : sizes) {
-            double ratio = (double) size.width / size.height;
-            if (Math.abs(ratio - targetRatio) > mAspectTolerance) continue;
-            if (Math.abs(size.height - targetHeight) < minDiff) {
-                optimalSize = size;
-                minDiff = Math.abs(size.height - targetHeight);
-            }
-        }
-
-        // Cannot find the one match the aspect ratio, ignore the requirement
-        if (optimalSize == null) {
-            minDiff = Double.MAX_VALUE;
-            for (Camera.Size size : sizes) {
-                if (Math.abs(size.height - targetHeight) < minDiff) {
-                    optimalSize = size;
-                    minDiff = Math.abs(size.height - targetHeight);
-                }
-            }
-        }
-        return optimalSize;
-    }
-
-    public void setAutoFocus(boolean state) {
-        if(mCameraWrapper != null && mPreviewing) {
-            if(state == mAutoFocus) {
-                return;
-            }
-            mAutoFocus = state;
-            if(mAutoFocus) {
-                if (mSurfaceCreated) { // check if surface created before using autofocus
-                    Log.v(TAG, "Starting autofocus");
-                    safeAutoFocus();
-                } else {
-                    scheduleAutoFocus(); // wait 1 sec and then do check again
-                }
-            } else {
-                Log.v(TAG, "Cancelling autofocus");
-                mCameraWrapper.mCamera.cancelAutoFocus();
-            }
-        }
-    }
-
-    private Runnable doAutoFocus = new Runnable() {
-        public void run() {
-            if(mCameraWrapper != null && mPreviewing && mAutoFocus && mSurfaceCreated) {
-                safeAutoFocus();
-            }
-        }
-    };
-
-    // Mimic continuous auto-focusing
-    Camera.AutoFocusCallback autoFocusCB = new Camera.AutoFocusCallback() {
-        public void onAutoFocus(boolean success, Camera camera) {
-            scheduleAutoFocus();
-        }
-    };
-
-    private void scheduleAutoFocus() {
-        mAutoFocusHandler.postDelayed(doAutoFocus, 1000);
-    }
-}
diff --git a/core/src/main/java/me/dm7/barcodescanner/core/CameraPreview.kt b/core/src/main/java/me/dm7/barcodescanner/core/CameraPreview.kt
new file mode 100644
index 0000000..59d6096
--- /dev/null
+++ b/core/src/main/java/me/dm7/barcodescanner/core/CameraPreview.kt
@@ -0,0 +1,321 @@
+package me.dm7.barcodescanner.core
+
+import android.content.Context
+import android.graphics.Point
+import android.hardware.Camera
+import android.os.Handler
+import android.util.AttributeSet
+import android.util.Log
+
+import android.content.res.Configuration
+import android.view.Surface
+import android.view.SurfaceHolder
+import android.view.SurfaceView
+import android.view.WindowManager
+import android.view.View
+
+class CameraPreview : SurfaceView, SurfaceHolder.Callback {
+
+    companion object {
+        private const val TAG = "CameraPreview2"
+    }
+
+    constructor(
+            context: Context,
+            cameraWrapper: CameraWrapper,
+            previewCallback: Camera.PreviewCallback
+    ) : super(context) {
+        this.mCameraWrapper = cameraWrapper
+        this.mPreviewCallback = previewCallback
+    }
+
+    constructor(
+            context: Context,
+            attrs: AttributeSet,
+            cameraWrapper: CameraWrapper,
+            previewCallback: Camera.PreviewCallback
+    ) : super(context, attrs) {
+        this.mCameraWrapper = cameraWrapper
+        this.mPreviewCallback = previewCallback
+    }
+
+    private var mCameraWrapper: CameraWrapper? = null
+    private var mAutoFocusHandler: Handler? = null
+    private var mPreviewing = true
+    private var mAutoFocus = true
+    private var mSurfaceCreated = false
+    private var mShouldScaleToFill = true
+    private var mPreviewCallback: Camera.PreviewCallback? = null
+    private var mAspectTolerance = 0.1f
+
+    init {
+        setCamera(mCameraWrapper, mPreviewCallback)
+        mAutoFocusHandler = Handler()
+        holder.addCallback(this)
+        holder.setType(SurfaceHolder.SURFACE_TYPE_PUSH_BUFFERS)
+    }
+
+
+    fun setCamera(cameraWrapper: CameraWrapper?, previewCallback: Camera.PreviewCallback?) {
+        mCameraWrapper = cameraWrapper
+        mPreviewCallback = previewCallback
+    }
+
+    fun setShouldScaleToFill(scaleToFill: Boolean) {
+        mShouldScaleToFill = scaleToFill
+    }
+
+    fun setAspectTolerance(aspectTolerance: Float) {
+        mAspectTolerance = aspectTolerance
+    }
+
+    override fun surfaceCreated(holder: SurfaceHolder?) {
+        mSurfaceCreated = true
+    }
+
+    override fun surfaceChanged(holder: SurfaceHolder?, format: Int, width: Int, height: Int) {
+        if (holder?.surface == null) {
+            return
+        }
+        stopCameraPreview()
+        showCameraPreview()
+    }
+
+    override fun surfaceDestroyed(holder: SurfaceHolder?) {
+        mSurfaceCreated = false
+        stopCameraPreview()
+    }
+
+    fun showCameraPreview() {
+        if (mCameraWrapper != null) {
+            try {
+                holder.addCallback(this)
+                mPreviewing = true
+                setupCameraParameters()
+                mCameraWrapper?.mCamera?.setPreviewDisplay(holder)
+                mCameraWrapper?.mCamera?.setDisplayOrientation(getDisplayOrientation())
+                mCameraWrapper?.mCamera?.setOneShotPreviewCallback(mPreviewCallback)
+                mCameraWrapper?.mCamera?.startPreview()
+                if (mAutoFocus) {
+                    if (mSurfaceCreated) { // check if surface created before using autofocus
+                        safeAutoFocus()
+                    } else {
+                        scheduleAutoFocus() // wait 1 sec and then do check again
+                    }
+                }
+            } catch (e: Exception) {
+                Log.e(TAG, e.toString(), e)
+            }
+        }
+    }
+
+    fun safeAutoFocus() {
+        try {
+            mCameraWrapper?.mCamera?.autoFocus(autoFocusCB)
+        } catch (re: RuntimeException) {
+            // Horrible hack to deal with autofocus errors on Sony devices
+            // See https://github.com/dm77/barcodescanner/issues/7 for example
+            scheduleAutoFocus() // wait 1 sec and then do check again
+        }
+    }
+
+
+    fun stopCameraPreview() {
+        if (mCameraWrapper != null) {
+            try {
+                mPreviewing = false
+                holder.removeCallback(this)
+                mCameraWrapper?.mCamera?.cancelAutoFocus()
+                mCameraWrapper?.mCamera?.setOneShotPreviewCallback(null)
+                mCameraWrapper?.mCamera?.stopPreview()
+            } catch (e: Exception) {
+                Log.e(TAG, e.toString(), e)
+            }
+        }
+    }
+
+    fun setupCameraParameters() {
+        val optimalSize = getOptimalPreviewSize()
+        val parameters = mCameraWrapper?.mCamera?.parameters
+        optimalSize?.let {
+            parameters?.setPreviewSize(it.width, it.height)
+        }
+        mCameraWrapper?.mCamera?.parameters = parameters
+        adjustViewSize(optimalSize)
+    }
+
+    fun adjustViewSize(cameraSize: Camera.Size?) {
+        cameraSize?.let {
+            val previewSize = convertSizeToLandscapeOrientation(Point(width, height))
+            val cameraRatio = it.width.toFloat() / it.height
+            val screenRatio = previewSize.x.toFloat() / previewSize.y
+            if (screenRatio > cameraRatio) {
+                setViewSize((previewSize.y * cameraRatio).toInt(), previewSize.y)
+            } else {
+                setViewSize(previewSize.x, (previewSize.x / cameraRatio).toInt())
+            }
+        }
+    }
+
+    @SuppressWarnings("SuspiciousNameCombination")
+    private fun convertSizeToLandscapeOrientation(size: Point): Point {
+        return if (getDisplayOrientation() % 180 == 0) {
+            size
+        } else {
+            Point(size.y, size.x)
+        }
+    }
+
+    @SuppressWarnings("SuspiciousNameCombination")
+    private fun setViewSize(width: Int, height: Int) {
+        val layoutParams = layoutParams
+        var tmpWidth: Int
+        var tmpHeight: Int
+        if (getDisplayOrientation() % 180 == 0) {
+            tmpWidth = width
+            tmpHeight = height
+        } else {
+            tmpWidth = height
+            tmpHeight = width
+        }
+
+        if (mShouldScaleToFill) {
+            val parentWidth = (parent as View).width
+            val parentHeight = (parent as View).height
+            val ratioWidth = parentWidth.toFloat() / tmpWidth.toFloat()
+            val ratioHeight = parentHeight.toFloat() / tmpHeight.toFloat()
+
+            val compensation = if (ratioWidth > ratioHeight) {
+                ratioWidth
+            } else {
+                ratioHeight
+            }
+
+            tmpWidth = Math.round(tmpWidth * compensation)
+            tmpHeight = Math.round(tmpHeight * compensation)
+        }
+
+        layoutParams.width = tmpWidth
+        layoutParams.height = tmpHeight
+        setLayoutParams(layoutParams)
+    }
+
+    fun getDisplayOrientation(): Int {
+        if (mCameraWrapper == null) {
+            //If we don't have a camera set there is no orientation so return dummy value
+            return 0
+        }
+
+        val info = Camera.CameraInfo()
+        if (mCameraWrapper?.mCameraId == -1) {
+            Camera.getCameraInfo(Camera.CameraInfo.CAMERA_FACING_BACK, info)
+        } else {
+            mCameraWrapper?.mCameraId?.let {
+                Camera.getCameraInfo(it, info)
+            }
+        }
+
+        val wm: WindowManager = context.getSystemService(Context.WINDOW_SERVICE) as WindowManager
+        val display = wm.defaultDisplay
+
+        val rotation = display.rotation
+        var degrees = 0
+        when (rotation) {
+            Surface.ROTATION_0 -> degrees = 0
+            Surface.ROTATION_90 -> degrees = 90
+            Surface.ROTATION_180 -> degrees = 180
+            Surface.ROTATION_270 -> degrees = 270
+        }
+
+        var result: Int
+        if (info.facing == Camera.CameraInfo.CAMERA_FACING_FRONT) {
+            result = (info.orientation + degrees) % 360
+            result = (360 - result) % 360  // compensate the mirror
+        } else {  // back-facing
+            result = (info.orientation - degrees + 360) % 360
+        }
+        return result
+    }
+
+    private fun getOptimalPreviewSize() : Camera.Size? {
+        if(mCameraWrapper == null) {
+            return null
+        }
+
+        val sizes = mCameraWrapper?.mCamera?.parameters?.supportedPreviewSizes
+        var w = width
+        var h = height
+        if (DisplayUtils.getScreenOrientation(context) == Configuration.ORIENTATION_PORTRAIT) {
+            val portraitWidth = h
+            h = w
+            w = portraitWidth
+        }
+
+        val targetRatio =  (w / h).toDouble()
+        if (sizes == null) return null
+
+        var optimalSize : Camera.Size? = null
+        var minDiff = Double.MAX_VALUE
+
+        val targetHeight = h
+
+        // Try to find an size match aspect ratio and size
+        for (size in sizes) {
+            val ratio = (size.width / size.height).toDouble()
+            if (Math.abs(ratio - targetRatio) > mAspectTolerance) continue
+            if (Math.abs(size.height - targetHeight) < minDiff) {
+                optimalSize = size
+                minDiff = Math.abs(size.height - targetHeight).toDouble()
+            }
+        }
+
+        // Cannot find the one match the aspect ratio, ignore the requirement
+        if (optimalSize == null) {
+            minDiff = Double.MAX_VALUE
+            for (size in sizes) {
+                if (Math.abs(size.height - targetHeight) < minDiff) {
+                    optimalSize = size
+                    minDiff = Math.abs(size.height - targetHeight).toDouble()
+                }
+            }
+        }
+        return optimalSize
+    }
+
+    fun setAutoFocus(state : Boolean) {
+        if(mCameraWrapper != null && mPreviewing) {
+            if(state == mAutoFocus) {
+                return
+            }
+            mAutoFocus = state
+            if(mAutoFocus) {
+                if (mSurfaceCreated) { // check if surface created before using autofocus
+                    Log.v(TAG, "Starting autofocus")
+                    safeAutoFocus()
+                } else {
+                    scheduleAutoFocus() // wait 1 sec and then do check again
+                }
+            } else {
+                Log.v(TAG, "Cancelling autofocus")
+                mCameraWrapper?.mCamera?.cancelAutoFocus()
+            }
+        }
+    }
+
+    private val doAutoFocus = Runnable {
+        if (mCameraWrapper != null && mPreviewing && mAutoFocus && mSurfaceCreated) {
+            safeAutoFocus()
+        }
+    }
+
+    // Mimic continuous auto-focusing
+    val autoFocusCB = object : Camera.AutoFocusCallback {
+        override fun onAutoFocus(success: Boolean, camera: Camera?) {
+            scheduleAutoFocus()
+        }
+    }
+
+    fun scheduleAutoFocus() {
+        mAutoFocusHandler?.postDelayed(doAutoFocus, 1000)
+    }
+}
\ No newline at end of file
