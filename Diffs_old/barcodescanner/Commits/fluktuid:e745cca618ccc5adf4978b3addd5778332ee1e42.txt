diff --git a/build.gradle b/build.gradle
index 31235da..ae021ca 100644
--- a/build.gradle
+++ b/build.gradle
@@ -1,6 +1,7 @@
 apply from: 'dependencies.gradle'
 
 buildscript {
+    ext.kotlin_version = '1.2.60'
     repositories {
         mavenCentral()
         jcenter()
@@ -8,6 +9,7 @@ buildscript {
 
     dependencies {
         classpath 'com.android.tools.build:gradle:2.3.3'
+        classpath "org.jetbrains.kotlin:kotlin-gradle-plugin:$kotlin_version"
     }
 }
 
diff --git a/core/build.gradle b/core/build.gradle
index cc4dabe..59ca8ec 100644
--- a/core/build.gradle
+++ b/core/build.gradle
@@ -1,4 +1,5 @@
 apply plugin: 'com.android.library'
+apply plugin: 'kotlin-android'
 
 ext {
     isLibrary = true
@@ -10,4 +11,9 @@ ext {
 
 dependencies {
     compile libraries.support_v4
+    compile "org.jetbrains.kotlin:kotlin-stdlib-jdk7:$kotlin_version"
+}
+
+repositories {
+    mavenCentral()
 }
diff --git a/core/src/main/java/me/dm7/barcodescanner/core/BarcodeScannerView.java b/core/src/main/java/me/dm7/barcodescanner/core/BarcodeScannerView.java
deleted file mode 100644
index 42863e1..0000000
--- a/core/src/main/java/me/dm7/barcodescanner/core/BarcodeScannerView.java
+++ /dev/null
@@ -1,340 +0,0 @@
-package me.dm7.barcodescanner.core;
-
-import android.content.Context;
-import android.content.res.Configuration;
-import android.content.res.TypedArray;
-import android.graphics.Color;
-import android.graphics.Rect;
-import android.hardware.Camera;
-import android.support.annotation.ColorInt;
-import android.util.AttributeSet;
-import android.util.Log;
-import android.view.Gravity;
-import android.view.View;
-import android.widget.FrameLayout;
-import android.widget.RelativeLayout;
-
-public abstract class BarcodeScannerView extends FrameLayout implements Camera.PreviewCallback  {
-
-    private CameraWrapper mCameraWrapper;
-    private CameraPreview mPreview;
-    private IViewFinder mViewFinderView;
-    private Rect mFramingRectInPreview;
-    private CameraHandlerThread mCameraHandlerThread;
-    private Boolean mFlashState;
-    private boolean mAutofocusState = true;
-    private boolean mShouldScaleToFill = true;
-
-    private boolean mIsLaserEnabled = true;
-    @ColorInt private int mLaserColor = getResources().getColor(R.color.viewfinder_laser);
-    @ColorInt private int mBorderColor = getResources().getColor(R.color.viewfinder_border);
-    private int mMaskColor = getResources().getColor(R.color.viewfinder_mask);
-    private int mBorderWidth = getResources().getInteger(R.integer.viewfinder_border_width);
-    private int mBorderLength = getResources().getInteger(R.integer.viewfinder_border_length);
-    private boolean mRoundedCorner = false;
-    private int mCornerRadius = 0;
-    private boolean mSquaredFinder = false;
-    private float mBorderAlpha = 1.0f;
-    private int mViewFinderOffset = 0;
-    private float mAspectTolerance = 0.1f;
-
-    public BarcodeScannerView(Context context) {
-        super(context);
-        init();
-    }
-
-    public BarcodeScannerView(Context context, AttributeSet attributeSet) {
-        super(context, attributeSet);
-
-        TypedArray a = context.getTheme().obtainStyledAttributes(
-                attributeSet,
-                R.styleable.BarcodeScannerView,
-                0, 0);
-
-        try {
-            setShouldScaleToFill(a.getBoolean(R.styleable.BarcodeScannerView_shouldScaleToFill, true));
-            mIsLaserEnabled = a.getBoolean(R.styleable.BarcodeScannerView_laserEnabled, mIsLaserEnabled);
-            mLaserColor = a.getColor(R.styleable.BarcodeScannerView_laserColor, mLaserColor);
-            mBorderColor = a.getColor(R.styleable.BarcodeScannerView_borderColor, mBorderColor);
-            mMaskColor = a.getColor(R.styleable.BarcodeScannerView_maskColor, mMaskColor);
-            mBorderWidth = a.getDimensionPixelSize(R.styleable.BarcodeScannerView_borderWidth, mBorderWidth);
-            mBorderLength = a.getDimensionPixelSize(R.styleable.BarcodeScannerView_borderLength, mBorderLength);
-
-            mRoundedCorner = a.getBoolean(R.styleable.BarcodeScannerView_roundedCorner, mRoundedCorner);
-            mCornerRadius = a.getDimensionPixelSize(R.styleable.BarcodeScannerView_cornerRadius, mCornerRadius);
-            mSquaredFinder = a.getBoolean(R.styleable.BarcodeScannerView_squaredFinder, mSquaredFinder);
-            mBorderAlpha = a.getFloat(R.styleable.BarcodeScannerView_borderAlpha, mBorderAlpha);
-            mViewFinderOffset = a.getDimensionPixelSize(R.styleable.BarcodeScannerView_finderOffset, mViewFinderOffset);
-        } finally {
-            a.recycle();
-        }
-
-        init();
-    }
-
-    private void init() {
-        mViewFinderView = createViewFinderView(getContext());
-    }
-
-    public final void setupLayout(CameraWrapper cameraWrapper) {
-        removeAllViews();
-
-        mPreview = new CameraPreview(getContext(), cameraWrapper, this);
-        mPreview.setAspectTolerance(mAspectTolerance);
-        mPreview.setShouldScaleToFill(mShouldScaleToFill);
-        if (!mShouldScaleToFill) {
-            RelativeLayout relativeLayout = new RelativeLayout(getContext());
-            relativeLayout.setGravity(Gravity.CENTER);
-            relativeLayout.setBackgroundColor(Color.BLACK);
-            relativeLayout.addView(mPreview);
-            addView(relativeLayout);
-        } else {
-            addView(mPreview);
-        }
-
-        if (mViewFinderView instanceof View) {
-            addView((View) mViewFinderView);
-        } else {
-            throw new IllegalArgumentException("IViewFinder object returned by " +
-                    "'createViewFinderView()' should be instance of android.view.View");
-        }
-    }
-
-    /**
-     * <p>Method that creates view that represents visual appearance of a barcode scanner</p>
-     * <p>Override it to provide your own view for visual appearance of a barcode scanner</p>
-     *
-     * @param context {@link Context}
-     * @return {@link android.view.View} that implements {@link ViewFinderView}
-     */
-    protected IViewFinder createViewFinderView(Context context) {
-        ViewFinderView viewFinderView = new ViewFinderView(context);
-        viewFinderView.setBorderColor(mBorderColor);
-        viewFinderView.setLaserColor(mLaserColor);
-        viewFinderView.setLaserEnabled(mIsLaserEnabled);
-        viewFinderView.setBorderStrokeWidth(mBorderWidth);
-        viewFinderView.setBorderLineLength(mBorderLength);
-        viewFinderView.setMaskColor(mMaskColor);
-
-        viewFinderView.setBorderCornerRounded(mRoundedCorner);
-        viewFinderView.setBorderCornerRadius(mCornerRadius);
-        viewFinderView.setSquareViewFinder(mSquaredFinder);
-        viewFinderView.setViewFinderOffset(mViewFinderOffset);
-        return viewFinderView;
-    }
-
-    public void setLaserColor(int laserColor) {
-        mLaserColor = laserColor;
-        mViewFinderView.setLaserColor(mLaserColor);
-        mViewFinderView.setupViewFinder();
-    }
-    public void setMaskColor(int maskColor) {
-        mMaskColor = maskColor;
-        mViewFinderView.setMaskColor(mMaskColor);
-        mViewFinderView.setupViewFinder();
-    }
-    public void setBorderColor(int borderColor) {
-        mBorderColor = borderColor;
-        mViewFinderView.setBorderColor(mBorderColor);
-        mViewFinderView.setupViewFinder();
-    }
-    public void setBorderStrokeWidth(int borderStrokeWidth) {
-        mBorderWidth = borderStrokeWidth;
-        mViewFinderView.setBorderStrokeWidth(mBorderWidth);
-        mViewFinderView.setupViewFinder();
-    }
-    public void setBorderLineLength(int borderLineLength) {
-        mBorderLength = borderLineLength;
-        mViewFinderView.setBorderLineLength(mBorderLength);
-        mViewFinderView.setupViewFinder();
-    }
-    public void setLaserEnabled(boolean isLaserEnabled) {
-        mIsLaserEnabled = isLaserEnabled;
-        mViewFinderView.setLaserEnabled(mIsLaserEnabled);
-        mViewFinderView.setupViewFinder();
-    }
-    public void setIsBorderCornerRounded(boolean isBorderCornerRounded) {
-        mRoundedCorner = isBorderCornerRounded;
-        mViewFinderView.setBorderCornerRounded(mRoundedCorner);
-        mViewFinderView.setupViewFinder();
-    }
-    public void setBorderCornerRadius(int borderCornerRadius) {
-        mCornerRadius = borderCornerRadius;
-        mViewFinderView.setBorderCornerRadius(mCornerRadius);
-        mViewFinderView.setupViewFinder();
-    }
-    public void setSquareViewFinder(boolean isSquareViewFinder) {
-        mSquaredFinder = isSquareViewFinder;
-        mViewFinderView.setSquareViewFinder(mSquaredFinder);
-        mViewFinderView.setupViewFinder();
-    }
-    public void setBorderAlpha(float borderAlpha) {
-        mBorderAlpha = borderAlpha;
-        mViewFinderView.setBorderAlpha(mBorderAlpha);
-        mViewFinderView.setupViewFinder();
-    }
-
-    public void startCamera(int cameraId) {
-        if(mCameraHandlerThread == null) {
-            mCameraHandlerThread = new CameraHandlerThread(this);
-        }
-        mCameraHandlerThread.startCamera(cameraId);
-    }
-
-    public void setupCameraPreview(CameraWrapper cameraWrapper) {
-        mCameraWrapper = cameraWrapper;
-        if(mCameraWrapper != null) {
-            setupLayout(mCameraWrapper);
-            mViewFinderView.setupViewFinder();
-            if(mFlashState != null) {
-                setFlash(mFlashState);
-            }
-            setAutoFocus(mAutofocusState);
-        }
-    }
-
-    public void startCamera() {
-        startCamera(CameraUtils.getDefaultCameraId());
-    }
-
-    public void stopCamera() {
-        if(mCameraWrapper != null) {
-            mPreview.stopCameraPreview();
-            mPreview.setCamera(null, null);
-            mCameraWrapper.mCamera.release();
-            mCameraWrapper = null;
-        }
-        if(mCameraHandlerThread != null) {
-            mCameraHandlerThread.quit();
-            mCameraHandlerThread = null;
-        }
-    }
-
-    public void stopCameraPreview() {
-        if(mPreview != null) {
-            mPreview.stopCameraPreview();
-        }
-    }
-
-    protected void resumeCameraPreview() {
-        if(mPreview != null) {
-            mPreview.showCameraPreview();
-        }
-    }
-
-    public synchronized Rect getFramingRectInPreview(int previewWidth, int previewHeight) {
-        if (mFramingRectInPreview == null) {
-            Rect framingRect = mViewFinderView.getFramingRect();
-            int viewFinderViewWidth = mViewFinderView.getWidth();
-            int viewFinderViewHeight = mViewFinderView.getHeight();
-            if (framingRect == null || viewFinderViewWidth == 0 || viewFinderViewHeight == 0) {
-                return null;
-            }
-
-            Rect rect = new Rect(framingRect);
-
-            if(previewWidth < viewFinderViewWidth) {
-                rect.left = rect.left * previewWidth / viewFinderViewWidth;
-                rect.right = rect.right * previewWidth / viewFinderViewWidth;
-            }
-
-            if(previewHeight < viewFinderViewHeight) {
-                rect.top = rect.top * previewHeight / viewFinderViewHeight;
-                rect.bottom = rect.bottom * previewHeight / viewFinderViewHeight;
-            }
-
-            mFramingRectInPreview = rect;
-        }
-        return mFramingRectInPreview;
-    }
-
-    public void setFlash(boolean flag) {
-        mFlashState = flag;
-        if(mCameraWrapper != null && CameraUtils.isFlashSupported(mCameraWrapper.mCamera)) {
-
-            Camera.Parameters parameters = mCameraWrapper.mCamera.getParameters();
-            if(flag) {
-                if(parameters.getFlashMode().equals(Camera.Parameters.FLASH_MODE_TORCH)) {
-                    return;
-                }
-                parameters.setFlashMode(Camera.Parameters.FLASH_MODE_TORCH);
-            } else {
-                if(parameters.getFlashMode().equals(Camera.Parameters.FLASH_MODE_OFF)) {
-                    return;
-                }
-                parameters.setFlashMode(Camera.Parameters.FLASH_MODE_OFF);
-            }
-            mCameraWrapper.mCamera.setParameters(parameters);
-        }
-    }
-
-    public boolean getFlash() {
-        if(mCameraWrapper != null && CameraUtils.isFlashSupported(mCameraWrapper.mCamera)) {
-            Camera.Parameters parameters = mCameraWrapper.mCamera.getParameters();
-            if(parameters.getFlashMode().equals(Camera.Parameters.FLASH_MODE_TORCH)) {
-                return true;
-            } else {
-                return false;
-            }
-        }
-        return false;
-    }
-
-    public void toggleFlash() {
-        if(mCameraWrapper != null && CameraUtils.isFlashSupported(mCameraWrapper.mCamera)) {
-            Camera.Parameters parameters = mCameraWrapper.mCamera.getParameters();
-            if(parameters.getFlashMode().equals(Camera.Parameters.FLASH_MODE_TORCH)) {
-                parameters.setFlashMode(Camera.Parameters.FLASH_MODE_OFF);
-            } else {
-                parameters.setFlashMode(Camera.Parameters.FLASH_MODE_TORCH);
-            }
-            mCameraWrapper.mCamera.setParameters(parameters);
-        }
-    }
-
-    public void setAutoFocus(boolean state) {
-        mAutofocusState = state;
-        if(mPreview != null) {
-            mPreview.setAutoFocus(state);
-        }
-    }
-
-    public void setShouldScaleToFill(boolean shouldScaleToFill) {
-        mShouldScaleToFill = shouldScaleToFill;
-    }
-
-    public void setAspectTolerance(float aspectTolerance) {
-        mAspectTolerance = aspectTolerance;
-    }
-
-    public byte[] getRotatedData(byte[] data, Camera camera) {
-        Camera.Parameters parameters = camera.getParameters();
-        Camera.Size size = parameters.getPreviewSize();
-        int width = size.width;
-        int height = size.height;
-
-        int rotationCount = getRotationCount();
-
-        if(rotationCount == 1 || rotationCount == 3) {
-            for (int i = 0; i < rotationCount; i++) {
-                byte[] rotatedData = new byte[data.length];
-                for (int y = 0; y < height; y++) {
-                    for (int x = 0; x < width; x++)
-                        rotatedData[x * height + height - y - 1] = data[x + y * width];
-                }
-                data = rotatedData;
-                int tmp = width;
-                width = height;
-                height = tmp;
-            }
-        }
-
-        return data;
-    }
-
-    public int getRotationCount() {
-        int displayOrientation = mPreview.getDisplayOrientation();
-        return displayOrientation / 90;
-    }
-}
-
diff --git a/core/src/main/java/me/dm7/barcodescanner/core/BarcodeScannerView.kt b/core/src/main/java/me/dm7/barcodescanner/core/BarcodeScannerView.kt
new file mode 100644
index 0000000..b50d621
--- /dev/null
+++ b/core/src/main/java/me/dm7/barcodescanner/core/BarcodeScannerView.kt
@@ -0,0 +1,328 @@
+package me.dm7.barcodescanner.core
+
+import android.content.Context
+import android.graphics.Color
+import android.graphics.Rect
+import android.hardware.Camera
+import android.support.annotation.ColorInt
+import android.util.AttributeSet
+import android.view.Gravity
+import android.view.View
+import android.widget.FrameLayout
+import android.widget.RelativeLayout
+
+abstract class BarcodeScannerView : FrameLayout, Camera.PreviewCallback {
+
+    private var mCameraWrapper: CameraWrapper? = null
+    private var mPreview: CameraPreview? = null
+    private var mViewFinderView: IViewFinder? = null
+    private var mFramingRectInPreview: Rect? = null
+    private var mCameraHandlerThread: CameraHandlerThread? = null
+    private var mFlashState: Boolean? = null
+    private var mAutofocusState = true
+    private var mShouldScaleToFill = true
+
+    private var mIsLaserEnabled = true
+    @ColorInt
+    private var mLaserColor = resources.getColor(R.color.viewfinder_laser)
+    @ColorInt
+    private var mBorderColor = resources.getColor(R.color.viewfinder_border)
+    private var mMaskColor = resources.getColor(R.color.viewfinder_mask)
+    private var mBorderWidth = resources.getInteger(R.integer.viewfinder_border_width)
+    private var mBorderLength = resources.getInteger(R.integer.viewfinder_border_length)
+    private var mRoundedCorner = false
+    private var mCornerRadius = 0
+    private var mSquaredFinder = false
+    private var mBorderAlpha = 1.0f
+    private var mViewFinderOffset = 0
+    private var mAspectTolerance = 0.1f
+
+    open var flash: Boolean
+        get() {
+            if (mCameraWrapper != null && CameraUtils.isFlashSupported(mCameraWrapper!!.mCamera)) {
+                val parameters = mCameraWrapper!!.mCamera.parameters
+                return parameters.flashMode == Camera.Parameters.FLASH_MODE_TORCH
+            }
+            return false
+        }
+        set(flag) {
+            mFlashState = flag
+            if (mCameraWrapper != null && CameraUtils.isFlashSupported(mCameraWrapper!!.mCamera)) {
+
+                val parameters = mCameraWrapper!!.mCamera.parameters
+                if (flag) {
+                    if (parameters.flashMode == Camera.Parameters.FLASH_MODE_TORCH) {
+                        return
+                    }
+                    parameters.flashMode = Camera.Parameters.FLASH_MODE_TORCH
+                } else {
+                    if (parameters.flashMode == Camera.Parameters.FLASH_MODE_OFF) {
+                        return
+                    }
+                    parameters.flashMode = Camera.Parameters.FLASH_MODE_OFF
+                }
+                mCameraWrapper!!.mCamera.parameters = parameters
+            }
+        }
+
+    open val rotationCount: Int
+        get() {
+            val displayOrientation = mPreview!!.displayOrientation
+            return displayOrientation / 90
+        }
+
+    constructor(context: Context) : super(context)
+
+    constructor(context: Context, attributeSet: AttributeSet) : super(context, attributeSet) {
+
+        val a = context.theme.obtainStyledAttributes(
+                attributeSet,
+                R.styleable.BarcodeScannerView,
+                0, 0)
+
+        try {
+            setShouldScaleToFill(a.getBoolean(R.styleable.BarcodeScannerView_shouldScaleToFill, true))
+            mIsLaserEnabled = a.getBoolean(R.styleable.BarcodeScannerView_laserEnabled, mIsLaserEnabled)
+            mLaserColor = a.getColor(R.styleable.BarcodeScannerView_laserColor, mLaserColor)
+            mBorderColor = a.getColor(R.styleable.BarcodeScannerView_borderColor, mBorderColor)
+            mMaskColor = a.getColor(R.styleable.BarcodeScannerView_maskColor, mMaskColor)
+            mBorderWidth = a.getDimensionPixelSize(R.styleable.BarcodeScannerView_borderWidth, mBorderWidth)
+            mBorderLength = a.getDimensionPixelSize(R.styleable.BarcodeScannerView_borderLength, mBorderLength)
+
+            mRoundedCorner = a.getBoolean(R.styleable.BarcodeScannerView_roundedCorner, mRoundedCorner)
+            mCornerRadius = a.getDimensionPixelSize(R.styleable.BarcodeScannerView_cornerRadius, mCornerRadius)
+            mSquaredFinder = a.getBoolean(R.styleable.BarcodeScannerView_squaredFinder, mSquaredFinder)
+            mBorderAlpha = a.getFloat(R.styleable.BarcodeScannerView_borderAlpha, mBorderAlpha)
+            mViewFinderOffset = a.getDimensionPixelSize(R.styleable.BarcodeScannerView_finderOffset, mViewFinderOffset)
+        } finally {
+            a.recycle()
+        }
+    }
+
+    init {
+        mViewFinderView = createViewFinderView(context)
+    }
+
+    private fun setupLayout(cameraWrapper: CameraWrapper) {
+        removeAllViews()
+
+        mPreview = CameraPreview(context, cameraWrapper, this)
+        mPreview!!.setAspectTolerance(mAspectTolerance)
+        mPreview!!.setShouldScaleToFill(mShouldScaleToFill)
+        if (!mShouldScaleToFill) {
+            val relativeLayout = RelativeLayout(context)
+            relativeLayout.gravity = Gravity.CENTER
+            relativeLayout.setBackgroundColor(Color.BLACK)
+            relativeLayout.addView(mPreview)
+            addView(relativeLayout)
+        } else {
+            addView(mPreview)
+        }
+
+        if (mViewFinderView is View) {
+            addView(mViewFinderView as View?)
+        } else {
+            throw IllegalArgumentException("IViewFinder object returned by " + "'createViewFinderView()' should be instance of android.view.View")
+        }
+    }
+
+    /**
+     *
+     * Method that creates view that represents visual appearance of a barcode scanner
+     *
+     * Override it to provide your own view for visual appearance of a barcode scanner
+     *
+     * @param context [Context]
+     * @return [android.view.View] that implements [ViewFinderView]
+     */
+    protected open fun createViewFinderView(context: Context): IViewFinder {
+        val viewFinderView = ViewFinderView(context)
+        viewFinderView.setBorderColor(mBorderColor)
+        viewFinderView.setLaserColor(mLaserColor)
+        viewFinderView.setLaserEnabled(mIsLaserEnabled)
+        viewFinderView.setBorderStrokeWidth(mBorderWidth)
+        viewFinderView.setBorderLineLength(mBorderLength)
+        viewFinderView.setMaskColor(mMaskColor)
+
+        viewFinderView.setBorderCornerRounded(mRoundedCorner)
+        viewFinderView.setBorderCornerRadius(mCornerRadius)
+        viewFinderView.setSquareViewFinder(mSquaredFinder)
+        viewFinderView.setViewFinderOffset(mViewFinderOffset)
+        return viewFinderView
+    }
+
+    public fun setLaserColor(laserColor: Int) {
+        mLaserColor = laserColor
+        mViewFinderView!!.setLaserColor(mLaserColor)
+        mViewFinderView!!.setupViewFinder()
+    }
+
+    public fun setMaskColor(maskColor: Int) {
+        mMaskColor = maskColor
+        mViewFinderView!!.setMaskColor(mMaskColor)
+        mViewFinderView!!.setupViewFinder()
+    }
+
+    public fun setBorderColor(borderColor: Int) {
+        mBorderColor = borderColor
+        mViewFinderView!!.setBorderColor(mBorderColor)
+        mViewFinderView!!.setupViewFinder()
+    }
+
+    public fun setBorderStrokeWidth(borderStrokeWidth: Int) {
+        mBorderWidth = borderStrokeWidth
+        mViewFinderView!!.setBorderStrokeWidth(mBorderWidth)
+        mViewFinderView!!.setupViewFinder()
+    }
+
+    public fun setBorderLineLength(borderLineLength: Int) {
+        mBorderLength = borderLineLength
+        mViewFinderView!!.setBorderLineLength(mBorderLength)
+        mViewFinderView!!.setupViewFinder()
+    }
+
+    public fun setLaserEnabled(isLaserEnabled: Boolean) {
+        mIsLaserEnabled = isLaserEnabled
+        mViewFinderView!!.setLaserEnabled(mIsLaserEnabled)
+        mViewFinderView!!.setupViewFinder()
+    }
+
+    public fun setIsBorderCornerRounded(isBorderCornerRounded: Boolean) {
+        mRoundedCorner = isBorderCornerRounded
+        mViewFinderView!!.setBorderCornerRounded(mRoundedCorner)
+        mViewFinderView!!.setupViewFinder()
+    }
+
+    public fun setBorderCornerRadius(borderCornerRadius: Int) {
+        mCornerRadius = borderCornerRadius
+        mViewFinderView!!.setBorderCornerRadius(mCornerRadius)
+        mViewFinderView!!.setupViewFinder()
+    }
+
+    public fun setSquareViewFinder(isSquareViewFinder: Boolean) {
+        mSquaredFinder = isSquareViewFinder
+        mViewFinderView!!.setSquareViewFinder(mSquaredFinder)
+        mViewFinderView!!.setupViewFinder()
+    }
+
+    public fun setBorderAlpha(borderAlpha: Float) {
+        mBorderAlpha = borderAlpha
+        mViewFinderView!!.setBorderAlpha(mBorderAlpha)
+        mViewFinderView!!.setupViewFinder()
+    }
+
+    @JvmOverloads
+    public fun startCamera(cameraId: Int = CameraUtils.defaultCameraId) {
+        if (mCameraHandlerThread == null) {
+            mCameraHandlerThread = CameraHandlerThread(this)
+        }
+        mCameraHandlerThread!!.startCamera(cameraId)
+    }
+
+    public fun setupCameraPreview(cameraWrapper: CameraWrapper) {
+        mCameraWrapper = cameraWrapper
+
+        setupLayout(cameraWrapper)
+        mViewFinderView!!.setupViewFinder()
+        mFlashState?.let { flash = it }
+        setAutoFocus(mAutofocusState)
+    }
+
+    public fun stopCamera() {
+        mCameraWrapper?.let {
+            mPreview?.stopCameraPreview()
+            mPreview?.setCamera(null, null)
+            it.mCamera.release()
+            mCameraWrapper = null
+        }
+        mCameraHandlerThread?.let {
+            it.quit()
+            mCameraHandlerThread = null
+        }
+    }
+
+    fun stopCameraPreview() = mPreview?.stopCameraPreview()
+
+    protected fun resumeCameraPreview() = mPreview?.showCameraPreview()
+
+    @Synchronized
+    fun getFramingRectInPreview(previewWidth: Int, previewHeight: Int): Rect? {
+        if (mFramingRectInPreview == null) {
+            val framingRect = mViewFinderView!!.framingRect
+            val viewFinderViewWidth = mViewFinderView!!.getWidth()
+            val viewFinderViewHeight = mViewFinderView!!.getHeight()
+            if (framingRect == null || viewFinderViewWidth == 0 || viewFinderViewHeight == 0) {
+                return null
+            }
+
+            val rect = Rect(framingRect)
+
+            if (previewWidth < viewFinderViewWidth) {
+                rect.left = rect.left * previewWidth / viewFinderViewWidth
+                rect.right = rect.right * previewWidth / viewFinderViewWidth
+            }
+
+            if (previewHeight < viewFinderViewHeight) {
+                rect.top = rect.top * previewHeight / viewFinderViewHeight
+                rect.bottom = rect.bottom * previewHeight / viewFinderViewHeight
+            }
+
+            mFramingRectInPreview = rect
+        }
+        return mFramingRectInPreview
+    }
+
+    fun toggleFlash() {
+        mCameraWrapper?.let {
+            if (CameraUtils.isFlashSupported(it.mCamera)) {
+                val parameters = it.mCamera.parameters
+                parameters.flashMode = if (parameters.flashMode == Camera.Parameters.FLASH_MODE_TORCH) {
+                    Camera.Parameters.FLASH_MODE_OFF
+                } else {
+                    Camera.Parameters.FLASH_MODE_TORCH
+                }
+                it.mCamera.parameters = parameters
+            }
+        }
+    }
+
+    open fun setAutoFocus(state: Boolean) {
+        mAutofocusState = state
+        mPreview?.setAutoFocus(state)
+    }
+
+    open fun setShouldScaleToFill(shouldScaleToFill: Boolean) {
+        mShouldScaleToFill = shouldScaleToFill
+    }
+
+    open fun setAspectTolerance(aspectTolerance: Float) {
+        mAspectTolerance = aspectTolerance
+    }
+
+    open fun getRotatedData(data: ByteArray, camera: Camera): ByteArray {
+        var mData = data
+        val parameters = camera.parameters
+        val size = parameters.previewSize
+        var width = size.width
+        var height = size.height
+
+        val rotationCount = rotationCount
+
+        if (rotationCount == 1 || rotationCount == 3) {
+            for (i in 0 until rotationCount) {
+                val rotatedData = ByteArray(mData.size)
+                for (y in 0 until height) {
+                    for (x in 0 until width)
+                        rotatedData[x * height + height - y - 1] = mData[x + y * width]
+                }
+                mData = rotatedData
+                val tmp = width
+                width = height
+                height = tmp
+            }
+        }
+
+        return mData
+    }
+}
+
diff --git a/core/src/main/java/me/dm7/barcodescanner/core/CameraHandlerThread.java b/core/src/main/java/me/dm7/barcodescanner/core/CameraHandlerThread.java
deleted file mode 100644
index 2d4bcee..0000000
--- a/core/src/main/java/me/dm7/barcodescanner/core/CameraHandlerThread.java
+++ /dev/null
@@ -1,37 +0,0 @@
-package me.dm7.barcodescanner.core;
-
-
-import android.hardware.Camera;
-import android.os.Handler;
-import android.os.HandlerThread;
-import android.os.Looper;
-
-// This code is mostly based on the top answer here: http://stackoverflow.com/questions/18149964/best-use-of-handlerthread-over-other-similar-classes
-public class CameraHandlerThread extends HandlerThread {
-    private static final String LOG_TAG = "CameraHandlerThread";
-
-    private BarcodeScannerView mScannerView;
-
-    public CameraHandlerThread(BarcodeScannerView scannerView) {
-        super("CameraHandlerThread");
-        mScannerView = scannerView;
-        start();
-    }
-
-    public void startCamera(final int cameraId) {
-        Handler localHandler = new Handler(getLooper());
-        localHandler.post(new Runnable() {
-            @Override
-            public void run() {
-                final Camera camera = CameraUtils.getCameraInstance(cameraId);
-                Handler mainHandler = new Handler(Looper.getMainLooper());
-                mainHandler.post(new Runnable() {
-                    @Override
-                    public void run() {
-                        mScannerView.setupCameraPreview(CameraWrapper.getWrapper(camera, cameraId));
-                    }
-                });
-            }
-        });
-    }
-}
diff --git a/core/src/main/java/me/dm7/barcodescanner/core/CameraHandlerThread.kt b/core/src/main/java/me/dm7/barcodescanner/core/CameraHandlerThread.kt
new file mode 100644
index 0000000..1d1f9f5
--- /dev/null
+++ b/core/src/main/java/me/dm7/barcodescanner/core/CameraHandlerThread.kt
@@ -0,0 +1,27 @@
+package me.dm7.barcodescanner.core
+
+
+import android.os.Handler
+import android.os.HandlerThread
+import android.os.Looper
+
+// This code is mostly based on the top answer here: http://stackoverflow.com/questions/18149964/best-use-of-handlerthread-over-other-similar-classes
+class CameraHandlerThread(private val mScannerView: BarcodeScannerView) : HandlerThread("CameraHandlerThread") {
+
+    init {
+        start()
+    }
+
+    fun startCamera(cameraId: Int) {
+        val localHandler = Handler(looper)
+        localHandler.post {
+            val camera = CameraUtils.getCameraInstance(cameraId)
+            val mainHandler = Handler(Looper.getMainLooper())
+            mainHandler.post { mScannerView.setupCameraPreview(CameraWrapper.getWrapper(camera, cameraId)!!) }
+        }
+    }
+
+    companion object {
+        private val LOG_TAG = "CameraHandlerThread"
+    }
+}
diff --git a/core/src/main/java/me/dm7/barcodescanner/core/CameraPreview.java b/core/src/main/java/me/dm7/barcodescanner/core/CameraPreview.java
deleted file mode 100644
index b066e25..0000000
--- a/core/src/main/java/me/dm7/barcodescanner/core/CameraPreview.java
+++ /dev/null
@@ -1,312 +0,0 @@
-package me.dm7.barcodescanner.core;
-
-import android.content.Context;
-import android.content.res.Configuration;
-import android.graphics.Point;
-import android.hardware.Camera;
-import android.os.Handler;
-import android.util.AttributeSet;
-import android.util.Log;
-import android.view.Display;
-import android.view.Surface;
-import android.view.SurfaceHolder;
-import android.view.SurfaceView;
-import android.view.View;
-import android.view.ViewGroup;
-import android.view.WindowManager;
-
-import java.util.List;
-
-public class CameraPreview extends SurfaceView implements SurfaceHolder.Callback {
-    private static final String TAG = "CameraPreview";
-
-    private CameraWrapper mCameraWrapper;
-    private Handler mAutoFocusHandler;
-    private boolean mPreviewing = true;
-    private boolean mAutoFocus = true;
-    private boolean mSurfaceCreated = false;
-    private boolean mShouldScaleToFill = true;
-    private Camera.PreviewCallback mPreviewCallback;
-    private float mAspectTolerance = 0.1f;
-
-    public CameraPreview(Context context, CameraWrapper cameraWrapper, Camera.PreviewCallback previewCallback) {
-        super(context);
-        init(cameraWrapper, previewCallback);
-    }
-
-    public CameraPreview(Context context, AttributeSet attrs, CameraWrapper cameraWrapper, Camera.PreviewCallback previewCallback) {
-        super(context, attrs);
-        init(cameraWrapper, previewCallback);
-    }
-
-    public void init(CameraWrapper cameraWrapper, Camera.PreviewCallback previewCallback) {
-        setCamera(cameraWrapper, previewCallback);
-        mAutoFocusHandler = new Handler();
-        getHolder().addCallback(this);
-        getHolder().setType(SurfaceHolder.SURFACE_TYPE_PUSH_BUFFERS);
-    }
-
-    public void setCamera(CameraWrapper cameraWrapper, Camera.PreviewCallback previewCallback) {
-        mCameraWrapper = cameraWrapper;
-        mPreviewCallback = previewCallback;
-    }
-
-    public void setShouldScaleToFill(boolean scaleToFill) {
-        mShouldScaleToFill = scaleToFill;
-    }
-
-    public void setAspectTolerance(float aspectTolerance) {
-        mAspectTolerance = aspectTolerance;
-    }
-
-    @Override
-    public void surfaceCreated(SurfaceHolder surfaceHolder) {
-        mSurfaceCreated = true;
-    }
-
-    @Override
-    public void surfaceChanged(SurfaceHolder surfaceHolder, int i, int i2, int i3) {
-        if(surfaceHolder.getSurface() == null) {
-            return;
-        }
-        stopCameraPreview();
-        showCameraPreview();
-    }
-
-    @Override
-    public void surfaceDestroyed(SurfaceHolder surfaceHolder) {
-        mSurfaceCreated = false;
-        stopCameraPreview();
-    }
-
-    public void showCameraPreview() {
-        if(mCameraWrapper != null) {
-            try {
-                getHolder().addCallback(this);
-                mPreviewing = true;
-                setupCameraParameters();
-                mCameraWrapper.mCamera.setPreviewDisplay(getHolder());
-                mCameraWrapper.mCamera.setDisplayOrientation(getDisplayOrientation());
-                mCameraWrapper.mCamera.setOneShotPreviewCallback(mPreviewCallback);
-                mCameraWrapper.mCamera.startPreview();
-                if(mAutoFocus) {
-                    if (mSurfaceCreated) { // check if surface created before using autofocus
-                        safeAutoFocus();
-                    } else {
-                        scheduleAutoFocus(); // wait 1 sec and then do check again
-                    }
-                }
-            } catch (Exception e) {
-                Log.e(TAG, e.toString(), e);
-            }
-        }
-    }
-
-    public void safeAutoFocus() {
-        try {
-            mCameraWrapper.mCamera.autoFocus(autoFocusCB);
-        } catch (RuntimeException re) {
-            // Horrible hack to deal with autofocus errors on Sony devices
-            // See https://github.com/dm77/barcodescanner/issues/7 for example
-            scheduleAutoFocus(); // wait 1 sec and then do check again
-        }
-    }
-
-    public void stopCameraPreview() {
-        if(mCameraWrapper != null) {
-            try {
-                mPreviewing = false;
-                getHolder().removeCallback(this);
-                mCameraWrapper.mCamera.cancelAutoFocus();
-                mCameraWrapper.mCamera.setOneShotPreviewCallback(null);
-                mCameraWrapper.mCamera.stopPreview();
-            } catch(Exception e) {
-                Log.e(TAG, e.toString(), e);
-            }
-        }
-    }
-
-    public void setupCameraParameters() {
-        Camera.Size optimalSize = getOptimalPreviewSize();
-        Camera.Parameters parameters = mCameraWrapper.mCamera.getParameters();
-        parameters.setPreviewSize(optimalSize.width, optimalSize.height);
-        mCameraWrapper.mCamera.setParameters(parameters);
-        adjustViewSize(optimalSize);
-    }
-
-    private void adjustViewSize(Camera.Size cameraSize) {
-        Point previewSize = convertSizeToLandscapeOrientation(new Point(getWidth(), getHeight()));
-        float cameraRatio = ((float) cameraSize.width) / cameraSize.height;
-        float screenRatio = ((float) previewSize.x) / previewSize.y;
-
-        if (screenRatio > cameraRatio) {
-            setViewSize((int) (previewSize.y * cameraRatio), previewSize.y);
-        } else {
-            setViewSize(previewSize.x, (int) (previewSize.x / cameraRatio));
-        }
-    }
-
-    @SuppressWarnings("SuspiciousNameCombination")
-    private Point convertSizeToLandscapeOrientation(Point size) {
-        if (getDisplayOrientation() % 180 == 0) {
-            return size;
-        } else {
-            return new Point(size.y, size.x);
-        }
-    }
-
-    @SuppressWarnings("SuspiciousNameCombination")
-    private void setViewSize(int width, int height) {
-        ViewGroup.LayoutParams layoutParams = getLayoutParams();
-        int tmpWidth;
-        int tmpHeight;
-        if (getDisplayOrientation() % 180 == 0) {
-            tmpWidth = width;
-            tmpHeight = height;
-        } else {
-            tmpWidth = height;
-            tmpHeight = width;
-        }
-
-        if (mShouldScaleToFill) {
-            int parentWidth = ((View) getParent()).getWidth();
-            int parentHeight = ((View) getParent()).getHeight();
-            float ratioWidth = (float) parentWidth / (float) tmpWidth;
-            float ratioHeight = (float) parentHeight / (float) tmpHeight;
-
-            float compensation;
-
-            if (ratioWidth > ratioHeight) {
-                compensation = ratioWidth;
-            } else {
-                compensation = ratioHeight;
-            }
-
-            tmpWidth = Math.round(tmpWidth * compensation);
-            tmpHeight = Math.round(tmpHeight * compensation);
-        }
-
-        layoutParams.width = tmpWidth;
-        layoutParams.height = tmpHeight;
-        setLayoutParams(layoutParams);
-    }
-
-    public int getDisplayOrientation() {
-        if (mCameraWrapper == null) {
-            //If we don't have a camera set there is no orientation so return dummy value
-            return 0;
-        }
-
-        Camera.CameraInfo info = new Camera.CameraInfo();
-        if(mCameraWrapper.mCameraId == -1) {
-            Camera.getCameraInfo(Camera.CameraInfo.CAMERA_FACING_BACK, info);
-        } else {
-            Camera.getCameraInfo(mCameraWrapper.mCameraId, info);
-        }
-
-        WindowManager wm = (WindowManager) getContext().getSystemService(Context.WINDOW_SERVICE);
-        Display display = wm.getDefaultDisplay();
-
-        int rotation = display.getRotation();
-        int degrees = 0;
-        switch (rotation) {
-            case Surface.ROTATION_0: degrees = 0; break;
-            case Surface.ROTATION_90: degrees = 90; break;
-            case Surface.ROTATION_180: degrees = 180; break;
-            case Surface.ROTATION_270: degrees = 270; break;
-        }
-
-        int result;
-        if (info.facing == Camera.CameraInfo.CAMERA_FACING_FRONT) {
-            result = (info.orientation + degrees) % 360;
-            result = (360 - result) % 360;  // compensate the mirror
-        } else {  // back-facing
-            result = (info.orientation - degrees + 360) % 360;
-        }
-        return result;
-    }
-
-    private Camera.Size getOptimalPreviewSize() {
-        if(mCameraWrapper == null) {
-            return null;
-        }
-
-        List<Camera.Size> sizes = mCameraWrapper.mCamera.getParameters().getSupportedPreviewSizes();
-        int w = getWidth();
-        int h = getHeight();
-        if (DisplayUtils.getScreenOrientation(getContext()) == Configuration.ORIENTATION_PORTRAIT) {
-            int portraitWidth = h;
-            h = w;
-            w = portraitWidth;
-        }
-
-        double targetRatio = (double) w / h;
-        if (sizes == null) return null;
-
-        Camera.Size optimalSize = null;
-        double minDiff = Double.MAX_VALUE;
-
-        int targetHeight = h;
-
-        // Try to find an size match aspect ratio and size
-        for (Camera.Size size : sizes) {
-            double ratio = (double) size.width / size.height;
-            if (Math.abs(ratio - targetRatio) > mAspectTolerance) continue;
-            if (Math.abs(size.height - targetHeight) < minDiff) {
-                optimalSize = size;
-                minDiff = Math.abs(size.height - targetHeight);
-            }
-        }
-
-        // Cannot find the one match the aspect ratio, ignore the requirement
-        if (optimalSize == null) {
-            minDiff = Double.MAX_VALUE;
-            for (Camera.Size size : sizes) {
-                if (Math.abs(size.height - targetHeight) < minDiff) {
-                    optimalSize = size;
-                    minDiff = Math.abs(size.height - targetHeight);
-                }
-            }
-        }
-        return optimalSize;
-    }
-
-    public void setAutoFocus(boolean state) {
-        if(mCameraWrapper != null && mPreviewing) {
-            if(state == mAutoFocus) {
-                return;
-            }
-            mAutoFocus = state;
-            if(mAutoFocus) {
-                if (mSurfaceCreated) { // check if surface created before using autofocus
-                    Log.v(TAG, "Starting autofocus");
-                    safeAutoFocus();
-                } else {
-                    scheduleAutoFocus(); // wait 1 sec and then do check again
-                }
-            } else {
-                Log.v(TAG, "Cancelling autofocus");
-                mCameraWrapper.mCamera.cancelAutoFocus();
-            }
-        }
-    }
-
-    private Runnable doAutoFocus = new Runnable() {
-        public void run() {
-            if(mCameraWrapper != null && mPreviewing && mAutoFocus && mSurfaceCreated) {
-                safeAutoFocus();
-            }
-        }
-    };
-
-    // Mimic continuous auto-focusing
-    Camera.AutoFocusCallback autoFocusCB = new Camera.AutoFocusCallback() {
-        public void onAutoFocus(boolean success, Camera camera) {
-            scheduleAutoFocus();
-        }
-    };
-
-    private void scheduleAutoFocus() {
-        mAutoFocusHandler.postDelayed(doAutoFocus, 1000);
-    }
-}
diff --git a/core/src/main/java/me/dm7/barcodescanner/core/CameraPreview.kt b/core/src/main/java/me/dm7/barcodescanner/core/CameraPreview.kt
new file mode 100644
index 0000000..79a953d
--- /dev/null
+++ b/core/src/main/java/me/dm7/barcodescanner/core/CameraPreview.kt
@@ -0,0 +1,299 @@
+package me.dm7.barcodescanner.core
+
+import android.content.Context
+import android.content.res.Configuration
+import android.graphics.Point
+import android.hardware.Camera
+import android.os.Handler
+import android.util.AttributeSet
+import android.util.Log
+import android.view.*
+
+class CameraPreview : SurfaceView, SurfaceHolder.Callback {
+
+    private var mCameraWrapper: CameraWrapper? = null
+    private var mAutoFocusHandler: Handler? = null
+    private var mPreviewing = true
+    private var mAutoFocus = true
+    private var mSurfaceCreated = false
+    private var mShouldScaleToFill = true
+    private var mPreviewCallback: Camera.PreviewCallback? = null
+    private var mAspectTolerance = 0.1f
+
+    //If we don't have a camera set there is no orientation so return dummy value
+    // compensate the mirror
+    // back-facing
+    val displayOrientation: Int
+        get() {
+            if (mCameraWrapper == null) {
+                return 0
+            }
+
+            val info = Camera.CameraInfo()
+            if (mCameraWrapper!!.mCameraId == -1) {
+                Camera.getCameraInfo(Camera.CameraInfo.CAMERA_FACING_BACK, info)
+            } else {
+                Camera.getCameraInfo(mCameraWrapper!!.mCameraId, info)
+            }
+
+            val wm = context.getSystemService(Context.WINDOW_SERVICE) as WindowManager
+            val display = wm.defaultDisplay
+
+            val rotation = display.rotation
+            var degrees = 0
+            when (rotation) {
+                Surface.ROTATION_0 -> degrees = 0
+                Surface.ROTATION_90 -> degrees = 90
+                Surface.ROTATION_180 -> degrees = 180
+                Surface.ROTATION_270 -> degrees = 270
+            }
+
+            var result: Int
+            if (info.facing == Camera.CameraInfo.CAMERA_FACING_FRONT) {
+                result = (info.orientation + degrees) % 360
+                result = (360 - result) % 360
+            } else {
+                result = (info.orientation - degrees + 360) % 360
+            }
+            return result
+        }
+
+    private// Try to find an size match aspect ratio and size
+    // Cannot find the one match the aspect ratio, ignore the requirement
+    val optimalPreviewSize: Camera.Size?
+        get() {
+            if (mCameraWrapper == null) {
+                return null
+            }
+
+            val sizes = mCameraWrapper!!.mCamera.parameters.supportedPreviewSizes
+            var w = width
+            var h = height
+            if (DisplayUtils.getScreenOrientation(context) == Configuration.ORIENTATION_PORTRAIT) {
+                val portraitWidth = h
+                h = w
+                w = portraitWidth
+            }
+
+            val targetRatio = w.toDouble() / h
+            if (sizes == null) return null
+
+            var optimalSize: Camera.Size? = null
+            var minDiff = java.lang.Double.MAX_VALUE
+
+            val targetHeight = h
+            for (size in sizes) {
+                val ratio = size.width.toDouble() / size.height
+                if (Math.abs(ratio - targetRatio) > mAspectTolerance) continue
+                if (Math.abs(size.height - targetHeight) < minDiff) {
+                    optimalSize = size
+                    minDiff = Math.abs(size.height - targetHeight).toDouble()
+                }
+            }
+            if (optimalSize == null) {
+                minDiff = java.lang.Double.MAX_VALUE
+                for (size in sizes) {
+                    if (Math.abs(size.height - targetHeight) < minDiff) {
+                        optimalSize = size
+                        minDiff = Math.abs(size.height - targetHeight).toDouble()
+                    }
+                }
+            }
+            return optimalSize
+        }
+
+    private val doAutoFocus = Runnable {
+        if (mCameraWrapper != null && mPreviewing && mAutoFocus && mSurfaceCreated) {
+            safeAutoFocus()
+        }
+    }
+
+    // Mimic continuous auto-focusing
+    internal var autoFocusCB: Camera.AutoFocusCallback = Camera.AutoFocusCallback { success, camera -> scheduleAutoFocus() }
+
+    constructor(context: Context, cameraWrapper: CameraWrapper, previewCallback: Camera.PreviewCallback) : super(context) {
+        init(cameraWrapper, previewCallback)
+    }
+
+    constructor(context: Context, attrs: AttributeSet, cameraWrapper: CameraWrapper, previewCallback: Camera.PreviewCallback) : super(context, attrs) {
+        init(cameraWrapper, previewCallback)
+    }
+
+    fun init(cameraWrapper: CameraWrapper, previewCallback: Camera.PreviewCallback) {
+        setCamera(cameraWrapper, previewCallback)
+        mAutoFocusHandler = Handler()
+        holder.addCallback(this)
+        holder.setType(SurfaceHolder.SURFACE_TYPE_PUSH_BUFFERS)
+    }
+
+    fun setCamera(cameraWrapper: CameraWrapper?, previewCallback: Camera.PreviewCallback?) {
+        mCameraWrapper = cameraWrapper
+        mPreviewCallback = previewCallback
+    }
+
+    fun setShouldScaleToFill(scaleToFill: Boolean) {
+        mShouldScaleToFill = scaleToFill
+    }
+
+    fun setAspectTolerance(aspectTolerance: Float) {
+        mAspectTolerance = aspectTolerance
+    }
+
+    override fun surfaceCreated(surfaceHolder: SurfaceHolder) {
+        mSurfaceCreated = true
+    }
+
+    override fun surfaceChanged(surfaceHolder: SurfaceHolder, i: Int, i2: Int, i3: Int) {
+        if (surfaceHolder.surface == null) {
+            return
+        }
+        stopCameraPreview()
+        showCameraPreview()
+    }
+
+    override fun surfaceDestroyed(surfaceHolder: SurfaceHolder) {
+        mSurfaceCreated = false
+        stopCameraPreview()
+    }
+
+    fun showCameraPreview() {
+        if (mCameraWrapper != null) {
+            try {
+                holder.addCallback(this)
+                mPreviewing = true
+                setupCameraParameters()
+                mCameraWrapper!!.mCamera.setPreviewDisplay(holder)
+                mCameraWrapper!!.mCamera.setDisplayOrientation(displayOrientation)
+                mCameraWrapper!!.mCamera.setOneShotPreviewCallback(mPreviewCallback)
+                mCameraWrapper!!.mCamera.startPreview()
+                if (mAutoFocus) {
+                    if (mSurfaceCreated) { // check if surface created before using autofocus
+                        safeAutoFocus()
+                    } else {
+                        scheduleAutoFocus() // wait 1 sec and then do check again
+                    }
+                }
+            } catch (e: Exception) {
+                Log.e(TAG, e.toString(), e)
+            }
+
+        }
+    }
+
+    fun safeAutoFocus() {
+        try {
+            mCameraWrapper!!.mCamera.autoFocus(autoFocusCB)
+        } catch (re: RuntimeException) {
+            // Horrible hack to deal with autofocus errors on Sony devices
+            // See https://github.com/dm77/barcodescanner/issues/7 for example
+            scheduleAutoFocus() // wait 1 sec and then do check again
+        }
+
+    }
+
+    fun stopCameraPreview() {
+        if (mCameraWrapper != null) {
+            try {
+                mPreviewing = false
+                holder.removeCallback(this)
+                mCameraWrapper!!.mCamera.cancelAutoFocus()
+                mCameraWrapper!!.mCamera.setOneShotPreviewCallback(null)
+                mCameraWrapper!!.mCamera.stopPreview()
+            } catch (e: Exception) {
+                Log.e(TAG, e.toString(), e)
+            }
+
+        }
+    }
+
+    fun setupCameraParameters() {
+        val optimalSize = optimalPreviewSize
+        val parameters = mCameraWrapper!!.mCamera.parameters
+        parameters.setPreviewSize(optimalSize!!.width, optimalSize.height)
+        mCameraWrapper!!.mCamera.parameters = parameters
+        adjustViewSize(optimalSize)
+    }
+
+    private fun adjustViewSize(cameraSize: Camera.Size) {
+        val previewSize = convertSizeToLandscapeOrientation(Point(width, height))
+        val cameraRatio = cameraSize.width.toFloat() / cameraSize.height
+        val screenRatio = previewSize.x.toFloat() / previewSize.y
+
+        if (screenRatio > cameraRatio) {
+            setViewSize((previewSize.y * cameraRatio).toInt(), previewSize.y)
+        } else {
+            setViewSize(previewSize.x, (previewSize.x / cameraRatio).toInt())
+        }
+    }
+
+    private fun convertSizeToLandscapeOrientation(size: Point): Point {
+        return if (displayOrientation % 180 == 0) {
+            size
+        } else {
+            Point(size.y, size.x)
+        }
+    }
+
+    private fun setViewSize(width: Int, height: Int) {
+        val layoutParams = layoutParams
+        var tmpWidth: Int
+        var tmpHeight: Int
+        if (displayOrientation % 180 == 0) {
+            tmpWidth = width
+            tmpHeight = height
+        } else {
+            tmpWidth = height
+            tmpHeight = width
+        }
+
+        if (mShouldScaleToFill) {
+            val parentWidth = (parent as View).width
+            val parentHeight = (parent as View).height
+            val ratioWidth = parentWidth.toFloat() / tmpWidth.toFloat()
+            val ratioHeight = parentHeight.toFloat() / tmpHeight.toFloat()
+
+            val compensation: Float
+
+            if (ratioWidth > ratioHeight) {
+                compensation = ratioWidth
+            } else {
+                compensation = ratioHeight
+            }
+
+            tmpWidth = Math.round(tmpWidth * compensation)
+            tmpHeight = Math.round(tmpHeight * compensation)
+        }
+
+        layoutParams.width = tmpWidth
+        layoutParams.height = tmpHeight
+        setLayoutParams(layoutParams)
+    }
+
+    fun setAutoFocus(state: Boolean) {
+        if (mCameraWrapper != null && mPreviewing) {
+            if (state == mAutoFocus) {
+                return
+            }
+            mAutoFocus = state
+            if (mAutoFocus) {
+                if (mSurfaceCreated) { // check if surface created before using autofocus
+                    Log.v(TAG, "Starting autofocus")
+                    safeAutoFocus()
+                } else {
+                    scheduleAutoFocus() // wait 1 sec and then do check again
+                }
+            } else {
+                Log.v(TAG, "Cancelling autofocus")
+                mCameraWrapper!!.mCamera.cancelAutoFocus()
+            }
+        }
+    }
+
+    private fun scheduleAutoFocus() {
+        mAutoFocusHandler!!.postDelayed(doAutoFocus, 1000)
+    }
+
+    companion object {
+        private val TAG = "CameraPreview"
+    }
+}
diff --git a/core/src/main/java/me/dm7/barcodescanner/core/CameraUtils.java b/core/src/main/java/me/dm7/barcodescanner/core/CameraUtils.java
deleted file mode 100644
index 599bd5f..0000000
--- a/core/src/main/java/me/dm7/barcodescanner/core/CameraUtils.java
+++ /dev/null
@@ -1,63 +0,0 @@
-package me.dm7.barcodescanner.core;
-
-import android.hardware.Camera;
-
-import java.util.List;
-
-public class CameraUtils {
-    /** A safe way to get an instance of the Camera object. */
-    public static Camera getCameraInstance() {
-        return getCameraInstance(getDefaultCameraId());
-    }
-
-    /** Favor back-facing camera by default. If none exists, fallback to whatever camera is available **/
-    public static int getDefaultCameraId() {
-        int numberOfCameras = Camera.getNumberOfCameras();
-        Camera.CameraInfo cameraInfo = new Camera.CameraInfo();
-        int defaultCameraId = -1;
-        for (int i = 0; i < numberOfCameras; i++) {
-            defaultCameraId = i;
-            Camera.getCameraInfo(i, cameraInfo);
-            if (cameraInfo.facing == Camera.CameraInfo.CAMERA_FACING_BACK) {
-                return i;
-            }
-        }
-        return defaultCameraId;
-    }
-
-    /** A safe way to get an instance of the Camera object. */
-    public static Camera getCameraInstance(int cameraId) {
-        Camera c = null;
-        try {
-            if(cameraId == -1) {
-                c = Camera.open(); // attempt to get a Camera instance
-            } else {
-                c = Camera.open(cameraId); // attempt to get a Camera instance
-            }
-        }
-        catch (Exception e) {
-            // Camera is not available (in use or does not exist)
-        }
-        return c; // returns null if camera is unavailable
-    }
-
-    public static boolean isFlashSupported(Camera camera) {
-        /* Credits: Top answer at http://stackoverflow.com/a/19599365/868173 */
-        if (camera != null) {
-            Camera.Parameters parameters = camera.getParameters();
-
-            if (parameters.getFlashMode() == null) {
-                return false;
-            }
-
-            List<String> supportedFlashModes = parameters.getSupportedFlashModes();
-            if (supportedFlashModes == null || supportedFlashModes.isEmpty() || supportedFlashModes.size() == 1 && supportedFlashModes.get(0).equals(Camera.Parameters.FLASH_MODE_OFF)) {
-                return false;
-            }
-        } else {
-            return false;
-        }
-
-        return true;
-    }
-}
\ No newline at end of file
diff --git a/core/src/main/java/me/dm7/barcodescanner/core/CameraUtils.kt b/core/src/main/java/me/dm7/barcodescanner/core/CameraUtils.kt
new file mode 100644
index 0000000..9bdb06d
--- /dev/null
+++ b/core/src/main/java/me/dm7/barcodescanner/core/CameraUtils.kt
@@ -0,0 +1,61 @@
+package me.dm7.barcodescanner.core
+
+import android.hardware.Camera
+
+object CameraUtils {
+    /** A safe way to get an instance of the Camera object.  */
+    val cameraInstance: Camera?
+        get() = getCameraInstance(defaultCameraId)
+
+    /** Favor back-facing camera by default. If none exists, fallback to whatever camera is available  */
+    val defaultCameraId: Int
+        get() {
+            val numberOfCameras = Camera.getNumberOfCameras()
+            val cameraInfo = Camera.CameraInfo()
+            var defaultCameraId = -1
+            for (i in 0 until numberOfCameras) {
+                defaultCameraId = i
+                Camera.getCameraInfo(i, cameraInfo)
+                if (cameraInfo.facing == Camera.CameraInfo.CAMERA_FACING_BACK) {
+                    return i
+                }
+            }
+            return defaultCameraId
+        }
+
+    /** A safe way to get an instance of the Camera object.  */
+    fun getCameraInstance(cameraId: Int): Camera? {
+        var c: Camera? = null
+        try {
+            if (cameraId == -1) {
+                c = Camera.open() // attempt to get a Camera instance
+            } else {
+                c = Camera.open(cameraId) // attempt to get a Camera instance
+            }
+        } catch (e: Exception) {
+            // Camera is not available (in use or does not exist)
+        }
+
+        return c // returns null if camera is unavailable
+    }
+
+    fun isFlashSupported(camera: Camera?): Boolean {
+        /* Credits: Top answer at http://stackoverflow.com/a/19599365/868173 */
+        if (camera != null) {
+            val parameters = camera.parameters
+
+            if (parameters.flashMode == null) {
+                return false
+            }
+
+            val supportedFlashModes = parameters.supportedFlashModes
+            if (supportedFlashModes == null || supportedFlashModes.isEmpty() || supportedFlashModes.size == 1 && supportedFlashModes[0] == Camera.Parameters.FLASH_MODE_OFF) {
+                return false
+            }
+        } else {
+            return false
+        }
+
+        return true
+    }
+}
\ No newline at end of file
diff --git a/core/src/main/java/me/dm7/barcodescanner/core/CameraWrapper.java b/core/src/main/java/me/dm7/barcodescanner/core/CameraWrapper.java
deleted file mode 100644
index c030a01..0000000
--- a/core/src/main/java/me/dm7/barcodescanner/core/CameraWrapper.java
+++ /dev/null
@@ -1,25 +0,0 @@
-package me.dm7.barcodescanner.core;
-
-import android.hardware.Camera;
-import android.support.annotation.NonNull;
-
-public class CameraWrapper {
-    public final Camera mCamera;
-    public final int mCameraId;
-
-    private CameraWrapper(@NonNull Camera camera, int cameraId) {
-        if (camera == null) {
-            throw new NullPointerException("Camera cannot be null");
-        }
-        this.mCamera = camera;
-        this.mCameraId = cameraId;
-    }
-
-    public static CameraWrapper getWrapper(Camera camera, int cameraId) {
-        if (camera == null) {
-            return null;
-        } else {
-            return new CameraWrapper(camera, cameraId);
-        }
-    }
-}
diff --git a/core/src/main/java/me/dm7/barcodescanner/core/CameraWrapper.kt b/core/src/main/java/me/dm7/barcodescanner/core/CameraWrapper.kt
new file mode 100644
index 0000000..fa350fb
--- /dev/null
+++ b/core/src/main/java/me/dm7/barcodescanner/core/CameraWrapper.kt
@@ -0,0 +1,23 @@
+package me.dm7.barcodescanner.core
+
+import android.hardware.Camera
+
+class CameraWrapper private constructor(val mCamera: Camera, val mCameraId: Int) {
+
+    init {
+        if (mCamera == null) {
+            throw NullPointerException("Camera cannot be null")
+        }
+    }
+
+    companion object {
+
+        fun getWrapper(camera: Camera?, cameraId: Int): CameraWrapper? {
+            return if (camera == null) {
+                null
+            } else {
+                CameraWrapper(camera, cameraId)
+            }
+        }
+    }
+}
diff --git a/core/src/main/java/me/dm7/barcodescanner/core/DisplayUtils.java b/core/src/main/java/me/dm7/barcodescanner/core/DisplayUtils.java
deleted file mode 100644
index 6c47312..0000000
--- a/core/src/main/java/me/dm7/barcodescanner/core/DisplayUtils.java
+++ /dev/null
@@ -1,41 +0,0 @@
-package me.dm7.barcodescanner.core;
-
-import android.content.Context;
-import android.content.res.Configuration;
-import android.graphics.Point;
-import android.view.Display;
-import android.view.WindowManager;
-
-public class DisplayUtils {
-    public static Point getScreenResolution(Context context) {
-        WindowManager wm = (WindowManager) context.getSystemService(Context.WINDOW_SERVICE);
-        Display display = wm.getDefaultDisplay();
-        Point screenResolution = new Point();
-        if (android.os.Build.VERSION.SDK_INT >= 13) {
-            display.getSize(screenResolution);
-        } else {
-            screenResolution.set(display.getWidth(), display.getHeight());
-        }
-
-        return screenResolution;
-    }
-
-    public static int getScreenOrientation(Context context)
-    {
-        WindowManager wm = (WindowManager) context.getSystemService(Context.WINDOW_SERVICE);
-        Display display = wm.getDefaultDisplay();
-
-        int orientation = Configuration.ORIENTATION_UNDEFINED;
-        if(display.getWidth()==display.getHeight()){
-            orientation = Configuration.ORIENTATION_SQUARE;
-        } else{
-            if(display.getWidth() < display.getHeight()){
-                orientation = Configuration.ORIENTATION_PORTRAIT;
-            }else {
-                orientation = Configuration.ORIENTATION_LANDSCAPE;
-            }
-        }
-        return orientation;
-    }
-
-}
diff --git a/core/src/main/java/me/dm7/barcodescanner/core/DisplayUtils.kt b/core/src/main/java/me/dm7/barcodescanner/core/DisplayUtils.kt
new file mode 100644
index 0000000..bcc1c7d
--- /dev/null
+++ b/core/src/main/java/me/dm7/barcodescanner/core/DisplayUtils.kt
@@ -0,0 +1,37 @@
+package me.dm7.barcodescanner.core
+
+import android.content.Context
+import android.content.res.Configuration
+import android.graphics.Point
+import android.view.WindowManager
+
+object DisplayUtils {
+    fun getScreenResolution(context: Context): Point {
+        val wm = context.getSystemService(Context.WINDOW_SERVICE) as WindowManager
+        val display = wm.defaultDisplay
+        val screenResolution = Point()
+        if (android.os.Build.VERSION.SDK_INT >= 13) {
+            display.getSize(screenResolution)
+        } else {
+            screenResolution.set(display.width, display.height)
+        }
+
+        return screenResolution
+    }
+
+    fun getScreenOrientation(context: Context): Int {
+        val wm = context.getSystemService(Context.WINDOW_SERVICE) as WindowManager
+        val display = wm.defaultDisplay
+
+        return if (display.width == display.height) {
+            Configuration.ORIENTATION_SQUARE
+        } else {
+            if (display.width < display.height) {
+                Configuration.ORIENTATION_PORTRAIT
+            } else {
+                Configuration.ORIENTATION_LANDSCAPE
+            }
+        }
+    }
+
+}
diff --git a/core/src/main/java/me/dm7/barcodescanner/core/IViewFinder.java b/core/src/main/java/me/dm7/barcodescanner/core/IViewFinder.java
deleted file mode 100644
index a6caaa4..0000000
--- a/core/src/main/java/me/dm7/barcodescanner/core/IViewFinder.java
+++ /dev/null
@@ -1,53 +0,0 @@
-package me.dm7.barcodescanner.core;
-
-import android.graphics.Rect;
-
-public interface IViewFinder {
-
-    void setLaserColor(int laserColor);
-    void setMaskColor(int maskColor);
-    void setBorderColor(int borderColor);
-    void setBorderStrokeWidth(int borderStrokeWidth);
-    void setBorderLineLength(int borderLineLength);
-    void setLaserEnabled(boolean isLaserEnabled);
-
-    void setBorderCornerRounded(boolean isBorderCornersRounded);
-    void setBorderAlpha(float alpha);
-    void setBorderCornerRadius(int borderCornersRadius);
-    void setViewFinderOffset(int offset);
-    void setSquareViewFinder(boolean isSquareViewFinder);
-    /**
-     * Method that executes when Camera preview is starting.
-     * It is recommended to update framing rect here and invalidate view after that. <br/>
-     * For example see: {@link ViewFinderView#setupViewFinder()}
-     */
-    void setupViewFinder();
-
-    /**
-     * Provides {@link Rect} that identifies area where barcode scanner can detect visual codes
-     * <p>Note: This rect is a area representation in absolute pixel values. <br/>
-     * For example: <br/>
-     * If View's size is 1024x800 so framing rect might be 500x400</p>
-     *
-     * @return {@link Rect} that identifies barcode scanner area
-     */
-    Rect getFramingRect();
-
-    /**
-     * Width of a {@link android.view.View} that implements this interface
-     * <p>Note: this is already implemented in {@link android.view.View},
-     * so you don't need to override method and provide your implementation</p>
-     *
-     * @return width of a view
-     */
-    int getWidth();
-
-    /**
-     * Height of a {@link android.view.View} that implements this interface
-     * <p>Note: this is already implemented in {@link android.view.View},
-     * so you don't need to override method and provide your implementation</p>
-     *
-     * @return height of a view
-     */
-    int getHeight();
-}
diff --git a/core/src/main/java/me/dm7/barcodescanner/core/IViewFinder.kt b/core/src/main/java/me/dm7/barcodescanner/core/IViewFinder.kt
new file mode 100644
index 0000000..7631348
--- /dev/null
+++ b/core/src/main/java/me/dm7/barcodescanner/core/IViewFinder.kt
@@ -0,0 +1,55 @@
+package me.dm7.barcodescanner.core
+
+
+import android.graphics.Rect
+
+interface IViewFinder {
+
+    /**
+     * Provides [Rect] that identifies area where barcode scanner can detect visual codes
+     *
+     * Note: This rect is a area representation in absolute pixel values. <br></br>
+     * For example: <br></br>
+     * If View's size is 1024x800 so framing rect might be 500x400
+     *
+     * @return [Rect] that identifies barcode scanner area
+     */
+    val framingRect: Rect?
+
+    fun setLaserColor(laserColor: Int)
+    fun setMaskColor(maskColor: Int)
+    fun setBorderColor(borderColor: Int)
+    fun setBorderStrokeWidth(borderStrokeWidth: Int)
+    fun setBorderLineLength(borderLineLength: Int)
+    fun setLaserEnabled(isLaserEnabled: Boolean)
+
+    fun setBorderCornerRounded(isBorderCornersRounded: Boolean)
+    fun setBorderAlpha(alpha: Float)
+    fun setBorderCornerRadius(borderCornersRadius: Int)
+    fun setViewFinderOffset(offset: Int)
+    fun setSquareViewFinder(isSquareViewFinder: Boolean)
+    /**
+     * Method that executes when Camera preview is starting.
+     * It is recommended to update framing rect here and invalidate view after that. <br></br>
+     * For example see: [ViewFinderView.setupViewFinder]
+     */
+    fun setupViewFinder()
+
+    /**
+     * Width of a {@link android.view.View} that implements this interface
+     * <p>Note: this is already implemented in {@link android.view.View},
+     * so you don't need to override method and provide your implementation</p>
+     *
+     * @return width of a view
+     */
+    fun getWidth(): Int
+
+    /**
+     * Height of a {@link android.view.View} that implements this interface
+     * <p>Note: this is already implemented in {@link android.view.View},
+     * so you don't need to override method and provide your implementation</p>
+     *
+     * @return height of a view
+     */
+    fun getHeight(): Int
+}
diff --git a/core/src/main/java/me/dm7/barcodescanner/core/ViewFinderView.java b/core/src/main/java/me/dm7/barcodescanner/core/ViewFinderView.java
deleted file mode 100644
index 307a8a4..0000000
--- a/core/src/main/java/me/dm7/barcodescanner/core/ViewFinderView.java
+++ /dev/null
@@ -1,259 +0,0 @@
-package me.dm7.barcodescanner.core;
-
-import android.content.Context;
-import android.content.res.Configuration;
-import android.graphics.Canvas;
-import android.graphics.CornerPathEffect;
-import android.graphics.Paint;
-import android.graphics.Path;
-import android.graphics.Point;
-import android.graphics.Rect;
-import android.util.AttributeSet;
-import android.view.View;
-
-public class ViewFinderView extends View implements IViewFinder {
-    private static final String TAG = "ViewFinderView";
-
-    private Rect mFramingRect;
-
-    private static final float PORTRAIT_WIDTH_RATIO = 6f/8;
-    private static final float PORTRAIT_WIDTH_HEIGHT_RATIO = 0.75f;
-
-    private static final float LANDSCAPE_HEIGHT_RATIO = 5f/8;
-    private static final float LANDSCAPE_WIDTH_HEIGHT_RATIO = 1.4f;
-    private static final int MIN_DIMENSION_DIFF = 50;
-
-    private static final float DEFAULT_SQUARE_DIMENSION_RATIO = 5f / 8;
-
-    private static final int[] SCANNER_ALPHA = {0, 64, 128, 192, 255, 192, 128, 64};
-    private int scannerAlpha;
-    private static final int POINT_SIZE = 10;
-    private static final long ANIMATION_DELAY = 80l;
-
-    private final int mDefaultLaserColor = getResources().getColor(R.color.viewfinder_laser);
-    private final int mDefaultMaskColor = getResources().getColor(R.color.viewfinder_mask);
-    private final int mDefaultBorderColor = getResources().getColor(R.color.viewfinder_border);
-    private final int mDefaultBorderStrokeWidth = getResources().getInteger(R.integer.viewfinder_border_width);
-    private final int mDefaultBorderLineLength = getResources().getInteger(R.integer.viewfinder_border_length);
-
-    protected Paint mLaserPaint;
-    protected Paint mFinderMaskPaint;
-    protected Paint mBorderPaint;
-    protected int mBorderLineLength;
-    protected boolean mSquareViewFinder;
-    private boolean mIsLaserEnabled;
-    private float mBordersAlpha;
-    private int mViewFinderOffset = 0;
-
-    public ViewFinderView(Context context) {
-        super(context);
-        init();
-    }
-
-    public ViewFinderView(Context context, AttributeSet attributeSet) {
-        super(context, attributeSet);
-        init();
-    }
-
-    private void init() {
-        //set up laser paint
-        mLaserPaint = new Paint();
-        mLaserPaint.setColor(mDefaultLaserColor);
-        mLaserPaint.setStyle(Paint.Style.FILL);
-
-        //finder mask paint
-        mFinderMaskPaint = new Paint();
-        mFinderMaskPaint.setColor(mDefaultMaskColor);
-
-        //border paint
-        mBorderPaint = new Paint();
-        mBorderPaint.setColor(mDefaultBorderColor);
-        mBorderPaint.setStyle(Paint.Style.STROKE);
-        mBorderPaint.setStrokeWidth(mDefaultBorderStrokeWidth);
-        mBorderPaint.setAntiAlias(true);
-
-        mBorderLineLength = mDefaultBorderLineLength;
-    }
-
-    @Override
-    public void setLaserColor(int laserColor) {
-        mLaserPaint.setColor(laserColor);
-    }
-
-    @Override
-    public void setMaskColor(int maskColor) {
-        mFinderMaskPaint.setColor(maskColor);
-    }
-
-    @Override
-    public void setBorderColor(int borderColor) {
-        mBorderPaint.setColor(borderColor);
-    }
-
-    @Override
-    public void setBorderStrokeWidth(int borderStrokeWidth) {
-        mBorderPaint.setStrokeWidth(borderStrokeWidth);
-    }
-
-    @Override
-    public void setBorderLineLength(int borderLineLength) {
-        mBorderLineLength = borderLineLength;
-    }
-
-    @Override
-    public void setLaserEnabled(boolean isLaserEnabled) { mIsLaserEnabled = isLaserEnabled; }
-
-    @Override
-    public void setBorderCornerRounded(boolean isBorderCornersRounded) {
-        if (isBorderCornersRounded) {
-            mBorderPaint.setStrokeJoin(Paint.Join.ROUND);
-        } else {
-            mBorderPaint.setStrokeJoin(Paint.Join.BEVEL);
-        }
-    }
-
-    @Override
-    public void setBorderAlpha(float alpha) {
-        int colorAlpha = (int) (255 * alpha);
-        mBordersAlpha = alpha;
-        mBorderPaint.setAlpha(colorAlpha);
-    }
-
-    @Override
-    public void setBorderCornerRadius(int borderCornersRadius) {
-        mBorderPaint.setPathEffect(new CornerPathEffect(borderCornersRadius));
-    }
-
-    @Override
-    public void setViewFinderOffset(int offset) {
-        mViewFinderOffset = offset;
-    }
-
-    // TODO: Need a better way to configure this. Revisit when working on 2.0
-    @Override
-    public void setSquareViewFinder(boolean set) {
-        mSquareViewFinder = set;
-    }
-
-    public void setupViewFinder() {
-        updateFramingRect();
-        invalidate();
-    }
-
-    public Rect getFramingRect() {
-        return mFramingRect;
-    }
-
-    @Override
-    public void onDraw(Canvas canvas) {
-        if(getFramingRect() == null) {
-            return;
-        }
-
-        drawViewFinderMask(canvas);
-        drawViewFinderBorder(canvas);
-
-        if (mIsLaserEnabled) {
-            drawLaser(canvas);
-        }
-    }
-
-    public void drawViewFinderMask(Canvas canvas) {
-        int width = canvas.getWidth();
-        int height = canvas.getHeight();
-        Rect framingRect = getFramingRect();
-        
-        canvas.drawRect(0, 0, width, framingRect.top, mFinderMaskPaint);
-        canvas.drawRect(0, framingRect.top, framingRect.left, framingRect.bottom + 1, mFinderMaskPaint);
-        canvas.drawRect(framingRect.right + 1, framingRect.top, width, framingRect.bottom + 1, mFinderMaskPaint);
-        canvas.drawRect(0, framingRect.bottom + 1, width, height, mFinderMaskPaint);
-    }
-
-    public void drawViewFinderBorder(Canvas canvas) {
-        Rect framingRect = getFramingRect();
-
-        // Top-left corner
-        Path path = new Path();
-        path.moveTo(framingRect.left, framingRect.top + mBorderLineLength);
-        path.lineTo(framingRect.left, framingRect.top);
-        path.lineTo(framingRect.left + mBorderLineLength, framingRect.top);
-        canvas.drawPath(path, mBorderPaint);
-
-        // Top-right corner
-        path.moveTo(framingRect.right, framingRect.top + mBorderLineLength);
-        path.lineTo(framingRect.right, framingRect.top);
-        path.lineTo(framingRect.right - mBorderLineLength, framingRect.top);
-        canvas.drawPath(path, mBorderPaint);
-
-        // Bottom-right corner
-        path.moveTo(framingRect.right, framingRect.bottom - mBorderLineLength);
-        path.lineTo(framingRect.right, framingRect.bottom);
-        path.lineTo(framingRect.right - mBorderLineLength, framingRect.bottom);
-        canvas.drawPath(path, mBorderPaint);
-
-        // Bottom-left corner
-        path.moveTo(framingRect.left, framingRect.bottom - mBorderLineLength);
-        path.lineTo(framingRect.left, framingRect.bottom);
-        path.lineTo(framingRect.left + mBorderLineLength, framingRect.bottom);
-        canvas.drawPath(path, mBorderPaint);
-    }
-
-    public void drawLaser(Canvas canvas) {
-        Rect framingRect = getFramingRect();
-        
-        // Draw a red "laser scanner" line through the middle to show decoding is active
-        mLaserPaint.setAlpha(SCANNER_ALPHA[scannerAlpha]);
-        scannerAlpha = (scannerAlpha + 1) % SCANNER_ALPHA.length;
-        int middle = framingRect.height() / 2 + framingRect.top;
-        canvas.drawRect(framingRect.left + 2, middle - 1, framingRect.right - 1, middle + 2, mLaserPaint);
-
-        postInvalidateDelayed(ANIMATION_DELAY,
-                framingRect.left - POINT_SIZE,
-                framingRect.top - POINT_SIZE,
-                framingRect.right + POINT_SIZE,
-                framingRect.bottom + POINT_SIZE);
-    }
-
-    @Override
-    protected void onSizeChanged(int xNew, int yNew, int xOld, int yOld) {
-        updateFramingRect();
-    }
-
-    public synchronized void updateFramingRect() {
-        Point viewResolution = new Point(getWidth(), getHeight());
-        int width;
-        int height;
-        int orientation = DisplayUtils.getScreenOrientation(getContext());
-
-        if(mSquareViewFinder) {
-            if(orientation != Configuration.ORIENTATION_PORTRAIT) {
-                height = (int) (getHeight() * DEFAULT_SQUARE_DIMENSION_RATIO);
-                width = height;
-            } else {
-                width = (int) (getWidth() * DEFAULT_SQUARE_DIMENSION_RATIO);
-                height = width;
-            }
-        } else {
-            if(orientation != Configuration.ORIENTATION_PORTRAIT) {
-                height = (int) (getHeight() * LANDSCAPE_HEIGHT_RATIO);
-                width = (int) (LANDSCAPE_WIDTH_HEIGHT_RATIO * height);
-            } else {
-                width = (int) (getWidth() * PORTRAIT_WIDTH_RATIO);
-                height = (int) (PORTRAIT_WIDTH_HEIGHT_RATIO * width);
-            }
-        }
-
-        if(width > getWidth()) {
-            width = getWidth() - MIN_DIMENSION_DIFF;
-        }
-
-        if(height > getHeight()) {
-            height = getHeight() - MIN_DIMENSION_DIFF;
-        }
-
-        int leftOffset = (viewResolution.x - width) / 2;
-        int topOffset = (viewResolution.y - height) / 2;
-        mFramingRect = new Rect(leftOffset + mViewFinderOffset, topOffset + mViewFinderOffset, leftOffset + width - mViewFinderOffset, topOffset + height - mViewFinderOffset);
-    }
-}
-
diff --git a/core/src/main/java/me/dm7/barcodescanner/core/ViewFinderView.kt b/core/src/main/java/me/dm7/barcodescanner/core/ViewFinderView.kt
new file mode 100644
index 0000000..4f3b2b4
--- /dev/null
+++ b/core/src/main/java/me/dm7/barcodescanner/core/ViewFinderView.kt
@@ -0,0 +1,240 @@
+package me.dm7.barcodescanner.core
+
+import android.content.Context
+import android.content.res.Configuration
+import android.graphics.*
+import android.util.AttributeSet
+import android.view.View
+
+open class ViewFinderView : View, IViewFinder {
+
+    private var mFramingRect: Rect? = null
+    private var scannerAlpha: Int = 0
+
+    private val mDefaultLaserColor = resources.getColor(R.color.viewfinder_laser)
+    private val mDefaultMaskColor = resources.getColor(R.color.viewfinder_mask)
+    private val mDefaultBorderColor = resources.getColor(R.color.viewfinder_border)
+    private val mDefaultBorderStrokeWidth = resources.getInteger(R.integer.viewfinder_border_width)
+    private val mDefaultBorderLineLength = resources.getInteger(R.integer.viewfinder_border_length)
+
+
+    override val framingRect: Rect?
+        get() = mFramingRect
+
+    private var mLaserPaint: Paint = Paint()
+    private var mFinderMaskPaint: Paint
+    private var mBorderPaint: Paint
+    private var mBorderLineLength: Int = 0
+    private var mSquareViewFinder: Boolean = false
+    private var mIsLaserEnabled: Boolean = false
+    private var mBordersAlpha: Float = 0.toFloat()
+    private var mViewFinderOffset = 0
+
+    constructor(context: Context) : super(context)
+
+    constructor(context: Context, attributeSet: AttributeSet) : super(context, attributeSet)
+
+    init {
+        //set up laser paint
+        mLaserPaint.color = mDefaultLaserColor
+        mLaserPaint.style = Paint.Style.FILL
+
+        //finder mask paint
+        mFinderMaskPaint = Paint()
+        mFinderMaskPaint.color = mDefaultMaskColor
+
+        //border paint
+        mBorderPaint = Paint()
+        mBorderPaint.color = mDefaultBorderColor
+        mBorderPaint.style = Paint.Style.STROKE
+        mBorderPaint.strokeWidth = mDefaultBorderStrokeWidth.toFloat()
+        mBorderPaint.isAntiAlias = true
+
+        mBorderLineLength = mDefaultBorderLineLength
+    }
+
+    override fun setLaserColor(laserColor: Int) {
+        mLaserPaint.color = laserColor
+    }
+
+    override fun setMaskColor(maskColor: Int) {
+        mFinderMaskPaint.color = maskColor
+    }
+
+    override fun setBorderColor(borderColor: Int) {
+        mBorderPaint.color = borderColor
+    }
+
+    override fun setBorderStrokeWidth(borderStrokeWidth: Int) {
+        mBorderPaint.strokeWidth = borderStrokeWidth.toFloat()
+    }
+
+    override fun setBorderLineLength(borderLineLength: Int) {
+        mBorderLineLength = borderLineLength
+    }
+
+    override fun setLaserEnabled(isLaserEnabled: Boolean) {
+        mIsLaserEnabled = isLaserEnabled
+    }
+
+    override fun setBorderCornerRounded(isBorderCornersRounded: Boolean) {
+        mBorderPaint.strokeJoin = if (isBorderCornersRounded) {
+            Paint.Join.ROUND
+        } else {
+            Paint.Join.BEVEL
+        }
+    }
+
+    override fun setBorderAlpha(alpha: Float) {
+        val colorAlpha = (255 * alpha).toInt()
+        mBordersAlpha = alpha
+        mBorderPaint.alpha = colorAlpha
+    }
+
+    override fun setBorderCornerRadius(borderCornersRadius: Int) {
+        mBorderPaint.pathEffect = CornerPathEffect(borderCornersRadius.toFloat())
+    }
+
+    override fun setViewFinderOffset(offset: Int) {
+        mViewFinderOffset = offset
+    }
+
+    // TODO: Need a better way to configure this. Revisit when working on 2.0
+    override fun setSquareViewFinder(isSquareViewFinder: Boolean) {
+        mSquareViewFinder = isSquareViewFinder
+    }
+
+    override fun setupViewFinder() {
+        updateFramingRect()
+        invalidate()
+    }
+
+    public override fun onDraw(canvas: Canvas) {
+        if (framingRect == null) {
+            return
+        }
+
+        drawViewFinderMask(canvas)
+        drawViewFinderBorder(canvas)
+
+        if (mIsLaserEnabled) {
+            drawLaser(canvas)
+        }
+    }
+
+    open fun drawViewFinderMask(canvas: Canvas) {
+        val width = canvas.width
+        val height = canvas.height
+        val framingRect = framingRect
+
+        canvas.drawRect(0f, 0f, width.toFloat(), framingRect!!.top.toFloat(), mFinderMaskPaint)
+        canvas.drawRect(0f, framingRect.top.toFloat(), framingRect.left.toFloat(), (framingRect.bottom + 1).toFloat(), mFinderMaskPaint)
+        canvas.drawRect((framingRect.right + 1).toFloat(), framingRect.top.toFloat(), width.toFloat(), (framingRect.bottom + 1).toFloat(), mFinderMaskPaint)
+        canvas.drawRect(0f, (framingRect.bottom + 1).toFloat(), width.toFloat(), height.toFloat(), mFinderMaskPaint)
+    }
+
+    open fun drawViewFinderBorder(canvas: Canvas) {
+        val framingRect = framingRect
+
+        // Top-left corner
+        val path = Path()
+        path.moveTo(framingRect!!.left.toFloat(), (framingRect.top + mBorderLineLength).toFloat())
+        path.lineTo(framingRect.left.toFloat(), framingRect.top.toFloat())
+        path.lineTo((framingRect.left + mBorderLineLength).toFloat(), framingRect.top.toFloat())
+        canvas.drawPath(path, mBorderPaint)
+
+        // Top-right corner
+        path.moveTo(framingRect.right.toFloat(), (framingRect.top + mBorderLineLength).toFloat())
+        path.lineTo(framingRect.right.toFloat(), framingRect.top.toFloat())
+        path.lineTo((framingRect.right - mBorderLineLength).toFloat(), framingRect.top.toFloat())
+        canvas.drawPath(path, mBorderPaint)
+
+        // Bottom-right corner
+        path.moveTo(framingRect.right.toFloat(), (framingRect.bottom - mBorderLineLength).toFloat())
+        path.lineTo(framingRect.right.toFloat(), framingRect.bottom.toFloat())
+        path.lineTo((framingRect.right - mBorderLineLength).toFloat(), framingRect.bottom.toFloat())
+        canvas.drawPath(path, mBorderPaint)
+
+        // Bottom-left corner
+        path.moveTo(framingRect.left.toFloat(), (framingRect.bottom - mBorderLineLength).toFloat())
+        path.lineTo(framingRect.left.toFloat(), framingRect.bottom.toFloat())
+        path.lineTo((framingRect.left + mBorderLineLength).toFloat(), framingRect.bottom.toFloat())
+        canvas.drawPath(path, mBorderPaint)
+    }
+
+    open fun drawLaser(canvas: Canvas) {
+        val framingRect = framingRect
+
+        // Draw a red "laser scanner" line through the middle to show decoding is active
+        mLaserPaint.alpha = SCANNER_ALPHA[scannerAlpha]
+        scannerAlpha = (scannerAlpha + 1) % SCANNER_ALPHA.size
+        val middle = framingRect!!.height() / 2 + framingRect.top
+        canvas.drawRect((framingRect.left + 2).toFloat(), (middle - 1).toFloat(), (framingRect.right - 1).toFloat(), (middle + 2).toFloat(), mLaserPaint)
+
+        postInvalidateDelayed(ANIMATION_DELAY,
+                framingRect.left - POINT_SIZE,
+                framingRect.top - POINT_SIZE,
+                framingRect.right + POINT_SIZE,
+                framingRect.bottom + POINT_SIZE)
+    }
+
+    override fun onSizeChanged(xNew: Int, yNew: Int, xOld: Int, yOld: Int) {
+        updateFramingRect()
+    }
+
+    @Synchronized
+    fun updateFramingRect() {
+        val viewResolution = Point(width, height)
+        var width: Int
+        var height: Int
+        val orientation = DisplayUtils.getScreenOrientation(context)
+
+        if (mSquareViewFinder) {
+            if (orientation != Configuration.ORIENTATION_PORTRAIT) {
+                height = (this.height * DEFAULT_SQUARE_DIMENSION_RATIO).toInt()
+                width = height
+            } else {
+                width = (this.width * DEFAULT_SQUARE_DIMENSION_RATIO).toInt()
+                height = width
+            }
+        } else {
+            if (orientation != Configuration.ORIENTATION_PORTRAIT) {
+                height = (this.height * LANDSCAPE_HEIGHT_RATIO).toInt()
+                width = (LANDSCAPE_WIDTH_HEIGHT_RATIO * height).toInt()
+            } else {
+                width = (this.width * PORTRAIT_WIDTH_RATIO).toInt()
+                height = (PORTRAIT_WIDTH_HEIGHT_RATIO * width).toInt()
+            }
+        }
+
+        if (width > this.width) {
+            width = this.width - MIN_DIMENSION_DIFF
+        }
+
+        if (height > this.height) {
+            height = this.height - MIN_DIMENSION_DIFF
+        }
+
+        val leftOffset = (viewResolution.x - width) / 2
+        val topOffset = (viewResolution.y - height) / 2
+        mFramingRect = Rect(leftOffset + mViewFinderOffset, topOffset + mViewFinderOffset, leftOffset + width - mViewFinderOffset, topOffset + height - mViewFinderOffset)
+    }
+
+    companion object {
+        private val TAG = "ViewFinderView"
+
+        private const val PORTRAIT_WIDTH_RATIO = 6f / 8
+        private const val PORTRAIT_WIDTH_HEIGHT_RATIO = 0.75f
+
+        private const val LANDSCAPE_HEIGHT_RATIO = 5f / 8
+        private const val LANDSCAPE_WIDTH_HEIGHT_RATIO = 1.4f
+        private const val MIN_DIMENSION_DIFF = 50
+
+        private const val DEFAULT_SQUARE_DIMENSION_RATIO = 5f / 8
+
+        private val SCANNER_ALPHA = intArrayOf(0, 64, 128, 192, 255, 192, 128, 64)
+        private const val POINT_SIZE = 10
+        private const val ANIMATION_DELAY = 80L
+    }
+}
+
