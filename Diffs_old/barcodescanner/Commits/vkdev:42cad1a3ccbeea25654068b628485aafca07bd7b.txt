diff --git a/core/src/main/java/me/dm7/barcodescanner/core/BarcodeScannerView.java b/core/src/main/java/me/dm7/barcodescanner/core/BarcodeScannerView.java
index 42863e1..45d2d9d 100644
--- a/core/src/main/java/me/dm7/barcodescanner/core/BarcodeScannerView.java
+++ b/core/src/main/java/me/dm7/barcodescanner/core/BarcodeScannerView.java
@@ -76,7 +76,7 @@ private void init() {
         mViewFinderView = createViewFinderView(getContext());
     }
 
-    public final void setupLayout(CameraWrapper cameraWrapper) {
+    public void setupLayout(CameraWrapper cameraWrapper) {
         removeAllViews();
 
         mPreview = new CameraPreview(getContext(), cameraWrapper, this);
@@ -212,13 +212,22 @@ public void stopCamera() {
 
     public void stopCameraPreview() {
         if(mPreview != null) {
-            mPreview.stopCameraPreview();
+            try {
+                mPreview.stopCameraPreview();
+            } catch (Exception e) {
+                Log.e(getClass().getSimpleName(),"Stop preview: error", e);
+            }
+
         }
     }
 
     protected void resumeCameraPreview() {
         if(mPreview != null) {
-            mPreview.showCameraPreview();
+            try {
+                mPreview.showCameraPreview();
+            }catch (Exception e) {
+                Log.e(getClass().getSimpleName(),"Resume preview: error", e);
+            }
         }
     }
 
@@ -313,19 +322,24 @@ public void setAspectTolerance(float aspectTolerance) {
         int width = size.width;
         int height = size.height;
 
+        return getRotatedData(data, width, height);
+    }
+
+    public byte[] getRotatedData(byte[] data, int originalWidth, int originalHeight) {
+
         int rotationCount = getRotationCount();
 
         if(rotationCount == 1 || rotationCount == 3) {
             for (int i = 0; i < rotationCount; i++) {
                 byte[] rotatedData = new byte[data.length];
-                for (int y = 0; y < height; y++) {
-                    for (int x = 0; x < width; x++)
-                        rotatedData[x * height + height - y - 1] = data[x + y * width];
+                for (int y = 0; y < originalHeight; y++) {
+                    for (int x = 0; x < originalWidth; x++)
+                        rotatedData[x * originalHeight + originalHeight - y - 1] = data[x + y * originalWidth];
                 }
                 data = rotatedData;
-                int tmp = width;
-                width = height;
-                height = tmp;
+                int tmp = originalWidth;
+                originalWidth = originalHeight;
+                originalHeight = tmp;
             }
         }
 
diff --git a/core/src/main/java/me/dm7/barcodescanner/core/CameraPreview.java b/core/src/main/java/me/dm7/barcodescanner/core/CameraPreview.java
index b066e25..1c565d5 100644
--- a/core/src/main/java/me/dm7/barcodescanner/core/CameraPreview.java
+++ b/core/src/main/java/me/dm7/barcodescanner/core/CameraPreview.java
@@ -17,6 +17,8 @@
 
 import java.util.List;
 
+import static android.hardware.Camera.Parameters.FOCUS_MODE_AUTO;
+
 public class CameraPreview extends SurfaceView implements SurfaceHolder.Callback {
     private static final String TAG = "CameraPreview";
 
@@ -27,7 +29,7 @@
     private boolean mSurfaceCreated = false;
     private boolean mShouldScaleToFill = true;
     private Camera.PreviewCallback mPreviewCallback;
-    private float mAspectTolerance = 0.1f;
+    private float mAspectTolerance = 0.5f;
 
     public CameraPreview(Context context, CameraWrapper cameraWrapper, Camera.PreviewCallback previewCallback) {
         super(context);
@@ -66,7 +68,7 @@ public void surfaceCreated(SurfaceHolder surfaceHolder) {
 
     @Override
     public void surfaceChanged(SurfaceHolder surfaceHolder, int i, int i2, int i3) {
-        if(surfaceHolder.getSurface() == null) {
+        if (surfaceHolder.getSurface() == null) {
             return;
         }
         stopCameraPreview();
@@ -80,7 +82,7 @@ public void surfaceDestroyed(SurfaceHolder surfaceHolder) {
     }
 
     public void showCameraPreview() {
-        if(mCameraWrapper != null) {
+        if (mCameraWrapper != null) {
             try {
                 getHolder().addCallback(this);
                 mPreviewing = true;
@@ -89,7 +91,7 @@ public void showCameraPreview() {
                 mCameraWrapper.mCamera.setDisplayOrientation(getDisplayOrientation());
                 mCameraWrapper.mCamera.setOneShotPreviewCallback(mPreviewCallback);
                 mCameraWrapper.mCamera.startPreview();
-                if(mAutoFocus) {
+                if (mAutoFocus) {
                     if (mSurfaceCreated) { // check if surface created before using autofocus
                         safeAutoFocus();
                     } else {
@@ -113,14 +115,14 @@ public void safeAutoFocus() {
     }
 
     public void stopCameraPreview() {
-        if(mCameraWrapper != null) {
+        if (mCameraWrapper != null) {
             try {
                 mPreviewing = false;
                 getHolder().removeCallback(this);
                 mCameraWrapper.mCamera.cancelAutoFocus();
                 mCameraWrapper.mCamera.setOneShotPreviewCallback(null);
                 mCameraWrapper.mCamera.stopPreview();
-            } catch(Exception e) {
+            } catch (Exception e) {
                 Log.e(TAG, e.toString(), e);
             }
         }
@@ -129,6 +131,7 @@ public void stopCameraPreview() {
     public void setupCameraParameters() {
         Camera.Size optimalSize = getOptimalPreviewSize();
         Camera.Parameters parameters = mCameraWrapper.mCamera.getParameters();
+        parameters.setFocusMode(FOCUS_MODE_AUTO);
         parameters.setPreviewSize(optimalSize.width, optimalSize.height);
         mCameraWrapper.mCamera.setParameters(parameters);
         adjustViewSize(optimalSize);
@@ -198,7 +201,7 @@ public int getDisplayOrientation() {
         }
 
         Camera.CameraInfo info = new Camera.CameraInfo();
-        if(mCameraWrapper.mCameraId == -1) {
+        if (mCameraWrapper.mCameraId == -1) {
             Camera.getCameraInfo(Camera.CameraInfo.CAMERA_FACING_BACK, info);
         } else {
             Camera.getCameraInfo(mCameraWrapper.mCameraId, info);
@@ -210,10 +213,18 @@ public int getDisplayOrientation() {
         int rotation = display.getRotation();
         int degrees = 0;
         switch (rotation) {
-            case Surface.ROTATION_0: degrees = 0; break;
-            case Surface.ROTATION_90: degrees = 90; break;
-            case Surface.ROTATION_180: degrees = 180; break;
-            case Surface.ROTATION_270: degrees = 270; break;
+            case Surface.ROTATION_0:
+                degrees = 0;
+                break;
+            case Surface.ROTATION_90:
+                degrees = 90;
+                break;
+            case Surface.ROTATION_180:
+                degrees = 180;
+                break;
+            case Surface.ROTATION_270:
+                degrees = 270;
+                break;
         }
 
         int result;
@@ -227,7 +238,7 @@ public int getDisplayOrientation() {
     }
 
     private Camera.Size getOptimalPreviewSize() {
-        if(mCameraWrapper == null) {
+        if (mCameraWrapper == null) {
             return null;
         }
 
@@ -272,12 +283,12 @@ public int getDisplayOrientation() {
     }
 
     public void setAutoFocus(boolean state) {
-        if(mCameraWrapper != null && mPreviewing) {
-            if(state == mAutoFocus) {
+        if (mCameraWrapper != null && mPreviewing) {
+            if (state == mAutoFocus) {
                 return;
             }
             mAutoFocus = state;
-            if(mAutoFocus) {
+            if (mAutoFocus) {
                 if (mSurfaceCreated) { // check if surface created before using autofocus
                     Log.v(TAG, "Starting autofocus");
                     safeAutoFocus();
@@ -293,7 +304,7 @@ public void setAutoFocus(boolean state) {
 
     private Runnable doAutoFocus = new Runnable() {
         public void run() {
-            if(mCameraWrapper != null && mPreviewing && mAutoFocus && mSurfaceCreated) {
+            if (mCameraWrapper != null && mPreviewing && mAutoFocus && mSurfaceCreated) {
                 safeAutoFocus();
             }
         }
diff --git a/dependencies.gradle b/dependencies.gradle
index 075b1dd..cc06233 100644
--- a/dependencies.gradle
+++ b/dependencies.gradle
@@ -1,9 +1,9 @@
 ext.versions = [
-        compile_sdk   : 25,
-        min_sdk       : 9,
-        target_sdk    : 25,
-        build_tools   : "25.0.2",
-        support_lib   : "25.3.1",
+        compile_sdk   : 26,
+        min_sdk       : 14,
+        target_sdk    : 26,
+        build_tools   : "26.0.2",
+        support_lib   : "26.+",
         zxing         : "3.3.0",
         barcodescanner: "1.9.8"
 ]
@@ -13,7 +13,7 @@ ext.libraries = [
         appcompat_v7        : "com.android.support:appcompat-v7:$versions.support_lib",
         design_support      : "com.android.support:design:$versions.support_lib",
         zxing_core          : "com.google.zxing:core:$versions.zxing",
-        barcodescanner_core : "me.dm7.barcodescanner:core:$versions.barcodescanner",
+        /*barcodescanner_core : "me.dm7.barcodescanner:core:$versions.barcodescanner",
         barcodescanner_zbar : "me.dm7.barcodescanner:zbar:$versions.barcodescanner",
-        barcodescanner_zxing: "me.dm7.barcodescanner:zxing:$versions.barcodescanner"
+        barcodescanner_zxing: "me.dm7.barcodescanner:zxing:$versions.barcodescanner"*/
 ]
diff --git a/gradle/wrapper/gradle-wrapper.properties b/gradle/wrapper/gradle-wrapper.properties
index cd0aa28..2fd8d4e 100644
--- a/gradle/wrapper/gradle-wrapper.properties
+++ b/gradle/wrapper/gradle-wrapper.properties
@@ -1,6 +1,6 @@
-#Sat Apr 08 11:44:39 MDT 2017
+#Wed Apr 25 11:20:16 MSK 2018
 distributionBase=GRADLE_USER_HOME
 distributionPath=wrapper/dists
 zipStoreBase=GRADLE_USER_HOME
 zipStorePath=wrapper/dists
-distributionUrl=https\://services.gradle.org/distributions/gradle-3.4.1-all.zip
+distributionUrl=https\://services.gradle.org/distributions/gradle-4.4-all.zip
diff --git a/zbar-sample/build.gradle b/zbar-sample/build.gradle
index c5e0ed3..3d8fc2f 100644
--- a/zbar-sample/build.gradle
+++ b/zbar-sample/build.gradle
@@ -1,8 +1,8 @@
 apply plugin: 'com.android.application'
 
 dependencies {
-    //compile project(":zbar")
-    compile libraries.barcodescanner_zbar
+    compile project(":zbar")
+    //compile libraries.barcodescanner_zbar
     compile libraries.support_v4
     compile libraries.appcompat_v7
     compile libraries.design_support
diff --git a/zbar/build.gradle b/zbar/build.gradle
index ee1c61e..7d97ff6 100644
--- a/zbar/build.gradle
+++ b/zbar/build.gradle
@@ -9,7 +9,7 @@ ext {
 }
 
 dependencies {
-    //compile project(":core")
-    compile libraries.barcodescanner_core
+    compile project(":core")
+    //compile libraries.barcodescanner_core
     compile fileTree(dir: 'libs', include: '*.jar')
 }
diff --git a/zxing-sample/build.gradle b/zxing-sample/build.gradle
index fb6b9ff..65c2a76 100644
--- a/zxing-sample/build.gradle
+++ b/zxing-sample/build.gradle
@@ -1,8 +1,8 @@
 apply plugin: 'com.android.application'
 
 dependencies {
-    //compile project(":zxing")
-    compile libraries.barcodescanner_zxing
+    compile project(":zxing")
+    //compile libraries.barcodescanner_zxing
     compile libraries.support_v4
     compile libraries.appcompat_v7
     compile libraries.design_support
diff --git a/zxing-sample/src/main/java/me/dm7/barcodescanner/zxing/sample/SimpleScannerActivity.java b/zxing-sample/src/main/java/me/dm7/barcodescanner/zxing/sample/SimpleScannerActivity.java
index 88ac069..fa6c052 100644
--- a/zxing-sample/src/main/java/me/dm7/barcodescanner/zxing/sample/SimpleScannerActivity.java
+++ b/zxing-sample/src/main/java/me/dm7/barcodescanner/zxing/sample/SimpleScannerActivity.java
@@ -17,7 +17,7 @@ public void onCreate(Bundle state) {
         super.onCreate(state);
         setContentView(R.layout.activity_simple_scanner);
         setupToolbar();
-
+        counts=0;
         ViewGroup contentFrame = (ViewGroup) findViewById(R.id.content_frame);
         mScannerView = new ZXingScannerView(this);
         contentFrame.addView(mScannerView);
@@ -28,6 +28,8 @@ public void onResume() {
         super.onResume();
         mScannerView.setResultHandler(this);
         mScannerView.startCamera();
+        mScannerView.setAspectTolerance(0.5f);
+        mScannerView.setAutoFocus(true);
     }
 
     @Override
@@ -36,10 +38,13 @@ public void onPause() {
         mScannerView.stopCamera();
     }
 
+    private static int counts;
+
     @Override
     public void handleResult(Result rawResult) {
+        counts++;
         Toast.makeText(this, "Contents = " + rawResult.getText() +
-                ", Format = " + rawResult.getBarcodeFormat().toString(), Toast.LENGTH_SHORT).show();
+                ", Format = " + rawResult.getBarcodeFormat().toString() + " Counts = " + counts, Toast.LENGTH_SHORT).show();
 
         // Note:
         // * Wait 2 seconds to resume the preview.
@@ -51,6 +56,6 @@ public void handleResult(Result rawResult) {
             public void run() {
                 mScannerView.resumeCameraPreview(SimpleScannerActivity.this);
             }
-        }, 2000);
+        }, 500);
     }
 }
diff --git a/zxing/build.gradle b/zxing/build.gradle
index 0496a8e..e1ed30b 100644
--- a/zxing/build.gradle
+++ b/zxing/build.gradle
@@ -9,7 +9,7 @@ ext {
 }
 
 dependencies {
-    //compile project(":core")
-    compile libraries.barcodescanner_core
+    compile project(":core")
+    //compile libraries.barcodescanner_core
     compile libraries.zxing_core
-}
+}
\ No newline at end of file
diff --git a/zxing/src/main/java/me/dm7/barcodescanner/zxing/ZXingScannerView.java b/zxing/src/main/java/me/dm7/barcodescanner/zxing/ZXingScannerView.java
index d1717ba..a9f058b 100644
--- a/zxing/src/main/java/me/dm7/barcodescanner/zxing/ZXingScannerView.java
+++ b/zxing/src/main/java/me/dm7/barcodescanner/zxing/ZXingScannerView.java
@@ -4,8 +4,8 @@
 import android.content.res.Configuration;
 import android.graphics.Rect;
 import android.hardware.Camera;
+import android.os.AsyncTask;
 import android.os.Handler;
-import android.os.Looper;
 import android.util.AttributeSet;
 import android.util.Log;
 
@@ -23,8 +23,11 @@
 import java.util.ArrayList;
 import java.util.Collection;
 import java.util.EnumMap;
+import java.util.HashMap;
 import java.util.List;
 import java.util.Map;
+import java.util.Queue;
+import java.util.concurrent.ArrayBlockingQueue;
 
 import me.dm7.barcodescanner.core.BarcodeScannerView;
 import me.dm7.barcodescanner.core.DisplayUtils;
@@ -36,10 +39,24 @@
         void handleResult(Result rawResult);
     }
 
+    private class ScanResult {
+        byte[] data;
+        int width;
+        int height;
+    }
+
+    private static final int QUEUE_SIZE = 4;
+    private static final long SCHEDULER_DELAY = 1000 / 30;//30 fps; xxx update FPS from parameters
+
     private MultiFormatReader mMultiFormatReader;
     public static final List<BarcodeFormat> ALL_FORMATS = new ArrayList<>();
     private List<BarcodeFormat> mFormats;
     private ResultHandler mResultHandler;
+    private Handler mainHandler;
+    private final Handler decoderHandler;
+    private final Map<ScanResult, AsyncTask> decodeTasks;
+    private final Queue<ScanResult> queue;
+    private boolean isDecodeScheduled;
 
     static {
         ALL_FORMATS.add(BarcodeFormat.AZTEC);
@@ -63,11 +80,23 @@
 
     public ZXingScannerView(Context context) {
         super(context);
+        queue = new ArrayBlockingQueue<>(QUEUE_SIZE);
+        decodeTasks = new HashMap<>();
+        decoderHandler = new Handler(context.getMainLooper());
+
+        mainHandler = new Handler(context.getMainLooper());
+
         initMultiFormatReader();
     }
 
     public ZXingScannerView(Context context, AttributeSet attributeSet) {
         super(context, attributeSet);
+        queue = new ArrayBlockingQueue<>(QUEUE_SIZE);
+        decodeTasks = new HashMap<>();
+        decoderHandler = new Handler(context.getMainLooper());
+
+        mainHandler = new Handler(context.getMainLooper());
+
         initMultiFormatReader();
     }
 
@@ -81,96 +110,109 @@ public void setResultHandler(ResultHandler resultHandler) {
     }
 
     public Collection<BarcodeFormat> getFormats() {
-        if(mFormats == null) {
+        if (mFormats == null) {
             return ALL_FORMATS;
         }
         return mFormats;
     }
 
     private void initMultiFormatReader() {
-        Map<DecodeHintType,Object> hints = new EnumMap<>(DecodeHintType.class);
+        Map<DecodeHintType, Object> hints = new EnumMap<>(DecodeHintType.class);
         hints.put(DecodeHintType.POSSIBLE_FORMATS, getFormats());
         mMultiFormatReader = new MultiFormatReader();
         mMultiFormatReader.setHints(hints);
     }
 
+
+    private synchronized void scheduleDecoder(boolean force) {
+        if (force || !isDecodeScheduled) {
+            isDecodeScheduled = true;
+            decoderHandler.postDelayed(new Runnable() {
+                @Override
+                public void run() {
+
+                    synchronized (queue) {
+                        if (decodeTasks.size() <= QUEUE_SIZE) {
+                            ScanResult sr = queue.poll();
+                            if (sr != null) {
+                                DecodingTask task = new DecodingTask();
+                                decodeTasks.put(sr, task);
+                                task.execute(sr);
+                            }
+                        }
+                    }
+
+                    scheduleDecoder(true);
+                }
+            }, SCHEDULER_DELAY);
+        }
+    }
+
     @Override
-    public void onPreviewFrame(byte[] data, Camera camera) {
-        if(mResultHandler == null) {
+    public void stopCamera() {
+        stop();
+        super.stopCamera();
+    }
+
+    @Override
+    public void stopCameraPreview() {
+        stop();
+        super.stopCameraPreview();
+    }
+
+    private void stop() {
+        synchronized (decoderHandler) {
+            decoderHandler.removeCallbacksAndMessages(null);
+            isDecodeScheduled = false;
+        }
+
+        synchronized (decodeTasks) {
+            for (AsyncTask task : decodeTasks.values()) {
+                task.cancel(true);
+            }
+            decodeTasks.clear();
+        }
+    }
+
+    @Override
+    public synchronized void onPreviewFrame(byte[] data, Camera camera) {
+        if (mResultHandler == null) {
+            Log.e(TAG, "Handler is null! onPreviewFrame");
             return;
         }
-        
+
+        scheduleDecoder(false);
+
+        int width;
+        int height;
+
         try {
             Camera.Parameters parameters = camera.getParameters();
             Camera.Size size = parameters.getPreviewSize();
-            int width = size.width;
-            int height = size.height;
-
-            if (DisplayUtils.getScreenOrientation(getContext()) == Configuration.ORIENTATION_PORTRAIT) {
-                int rotationCount = getRotationCount();
-                if (rotationCount == 1 || rotationCount == 3) {
-                    int tmp = width;
-                    width = height;
-                    height = tmp;
-                }
-                data = getRotatedData(data, camera);
-            }
+            width = size.width;
+            height = size.height;
+        } catch (Exception e) {
+            Log.e(TAG, "Camera Error", e);
+            return;
+        }
 
-            Result rawResult = null;
-            PlanarYUVLuminanceSource source = buildLuminanceSource(data, width, height);
-
-            if (source != null) {
-                BinaryBitmap bitmap = new BinaryBitmap(new HybridBinarizer(source));
-                try {
-                    rawResult = mMultiFormatReader.decodeWithState(bitmap);
-                } catch (ReaderException re) {
-                    // continue
-                } catch (NullPointerException npe) {
-                    // This is terrible
-                } catch (ArrayIndexOutOfBoundsException aoe) {
-
-                } finally {
-                    mMultiFormatReader.reset();
-                }
+        ScanResult scanResult = new ScanResult();
+        scanResult.data = data;
+        scanResult.width = width;
+        scanResult.height = height;
 
-                if (rawResult == null) {
-                    LuminanceSource invertedSource = source.invert();
-                    bitmap = new BinaryBitmap(new HybridBinarizer(invertedSource));
-                    try {
-                        rawResult = mMultiFormatReader.decodeWithState(bitmap);
-                    } catch (NotFoundException e) {
-                        // continue
-                    } finally {
-                        mMultiFormatReader.reset();
-                    }
-                }
+        synchronized (queue) {
+            if (queue.size() >= QUEUE_SIZE) {
+                queue.poll();
             }
 
-            final Result finalRawResult = rawResult;
-
-            if (finalRawResult != null) {
-                Handler handler = new Handler(Looper.getMainLooper());
-                handler.post(new Runnable() {
-                    @Override
-                    public void run() {
-                        // Stopping the preview can take a little long.
-                        // So we want to set result handler to null to discard subsequent calls to
-                        // onPreviewFrame.
-                        ResultHandler tmpResultHandler = mResultHandler;
-                        mResultHandler = null;
-
-                        stopCameraPreview();
-                        if (tmpResultHandler != null) {
-                            tmpResultHandler.handleResult(finalRawResult);
-                        }
-                    }
-                });
-            } else {
-                camera.setOneShotPreviewCallback(this);
-            }
-        } catch(RuntimeException e) {
-            // TODO: Terrible hack. It is possible that this method is invoked after camera is released.
-            Log.e(TAG, e.toString(), e);
+            queue.add(scanResult);
+        }
+
+        try {
+            camera.setPreviewCallback(this);
+        } catch (Exception e) {
+            //camera already released
         }
     }
 
@@ -190,9 +232,103 @@ public PlanarYUVLuminanceSource buildLuminanceSource(byte[] data, int width, int
         try {
             source = new PlanarYUVLuminanceSource(data, width, height, rect.left, rect.top,
                     rect.width(), rect.height(), false);
-        } catch(Exception e) {
+        } catch (Exception e) {
+            Log.e(TAG, "PlanarYUVLuminanceSource error", e);
         }
 
         return source;
     }
+
+    private void handleResult(final Result result) {
+        mainHandler.post(new Runnable() {
+            @Override
+            public void run() {
+                stop();
+                stopCameraPreview();
+                mResultHandler.handleResult(result);
+            }
+        });
+    }
+
+    private class DecodingTask extends AsyncTask<ScanResult, Void, Result> {
+
+        private ScanResult sr;
+
+        @Override
+        protected Result doInBackground(ScanResult... scanResults) {
+            if (scanResults == null || scanResults.length == 0) {
+                return null;
+            }
+
+            sr = scanResults[0];
+
+            try {
+                if (DisplayUtils.getScreenOrientation(getContext()) == Configuration.ORIENTATION_PORTRAIT) {
+
+                    int originalWidth = sr.width;
+                    int originalHeight = sr.height;
+
+                    int rotationCount = getRotationCount();
+                    if (rotationCount == 1 || rotationCount == 3) {
+                        int tmp = sr.width;
+                        sr.width = sr.height;
+                        sr.height = tmp;
+                    }
+                    sr.data = getRotatedData(sr.data, originalWidth, originalHeight);
+                }
+
+                Result rawResult = null;
+                PlanarYUVLuminanceSource source = buildLuminanceSource(sr.data, sr.width, sr.height);
+
+                if (source != null) {
+                    BinaryBitmap bitmap = new BinaryBitmap(new HybridBinarizer(source));
+                    try {
+                        rawResult = mMultiFormatReader.decodeWithState(bitmap);
+                    } catch (ReaderException re) {
+                        //Log.e(TAG, "onPreviewFrame", re);
+                        // continue
+                    } catch (NullPointerException npe) {
+                        //Log.e(TAG, "onPreviewFrame", npe);
+                        // This is terrible
+                    } catch (ArrayIndexOutOfBoundsException aoe) {
+                        //Log.e(TAG, "onPreviewFrame", aoe);
+                    } finally {
+                        mMultiFormatReader.reset();
+                    }
+
+                    if (rawResult == null) {
+                        LuminanceSource invertedSource = source.invert();
+                        bitmap = new BinaryBitmap(new HybridBinarizer(invertedSource));
+                        try {
+                            //Log.e(TAG, "BITMAP w = " + bitmap.getWidth() + "  h = " + bitmap.getHeight());
+                            rawResult = mMultiFormatReader.decodeWithState(bitmap);
+                        } catch (NotFoundException e) {
+                            Log.e(TAG, "onPreviewFrame", e);
+                            // continue
+                        } finally {
+                            mMultiFormatReader.reset();
+                        }
+                    }
+                }
+
+                return rawResult;
+            } catch (RuntimeException e) {
+                // TODO: Terrible hack. It is possible that this method is invoked after camera is released.
+                Log.e(TAG, e.toString(), e);
+            }
+
+            return null;
+        }
+
+        @Override
+        protected void onPostExecute(final Result result) {
+            if (result != null && !isCancelled()) {
+                handleResult(result);
+            }
+
+            synchronized (decodeTasks) {
+                decodeTasks.remove(sr);
+            }
+        }
+    }
 }
