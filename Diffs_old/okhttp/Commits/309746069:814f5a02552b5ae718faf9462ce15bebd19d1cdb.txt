diff --git a/BUG-BOUNTY.md b/BUG-BOUNTY.md
new file mode 100644
index 0000000000..b2c35b2da0
--- /dev/null
+++ b/BUG-BOUNTY.md
@@ -0,0 +1,10 @@
+Serious about security
+======================
+
+Square recognizes the important contributions the security research community
+can make. We therefore encourage reporting security issues with the code
+contained in this repository.
+
+If you believe you have discovered a security vulnerability, please follow the
+guidelines at https://hackerone.com/square-open-source
+
diff --git a/CHANGELOG.md b/CHANGELOG.md
index 71a504176d..00ad4c3936 100644
--- a/CHANGELOG.md
+++ b/CHANGELOG.md
@@ -1,7 +1,204 @@
 Change Log
 ==========
 
-## VERSION 2.2.0
+## Version 2.5.0
+
+_2015-08-25_
+
+ *  **Timeouts now default to 10 seconds.** Previously we defaulted to never
+    timing out, and that was a lousy policy. If establishing a connection,
+    reading the next byte from a connection, or writing the next byte to a
+    connection takes more than 10 seconds to complete, you’ll need to adjust
+    the timeouts manually.
+
+ *  **OkHttp now rejects request headers that contain invalid characters.** This
+    includes potential security problems (newline characters) as well as simple
+    non-ASCII characters (including international characters and emoji).
+
+ *  **Call canceling is more reliable.**  We had a bug where a socket being
+     connected wasn't being closed when the application used `Call.cancel()`.
+
+ *  **Changing a HttpUrl’s scheme now tracks the default port.** We had a bug
+    where changing a URL from `http` to `https` would leave it on port 80.
+
+ *  **Okio has been updated to 1.6.0.**
+     ```
+     <dependency>
+       <groupId>com.squareup.okio</groupId>
+       <artifactId>okio</artifactId>
+       <version>1.6.0</version>
+     </dependency>
+     ```
+
+ *  New: `Cache.initialize()`. Call this on a background thread to eagerly
+    initialize the response cache.
+ *  New: Fold `MockWebServerRule` into `MockWebServer`. This makes it easier to
+    write JUnit tests with `MockWebServer`. The `MockWebServer` library now
+    depends on JUnit, though it continues to work with all testing frameworks.
+ *  Fix: `FormEncodingBuilder` is now consistent with browsers in which
+    characters it escapes. Previously we weren’t percent-encoding commas,
+    parens, and other characters.
+ *  Fix: Relax `FormEncodingBuilder` to support building empty forms.
+ *  Fix: Timeouts throw `SocketTimeoutException`, not `InterruptedIOException`.
+ *  Fix: Change `MockWebServer` to use the same logic as OkHttp when determining
+    whether an HTTP request permits a body.
+ *  Fix: `HttpUrl` now uses the canonical form for IPv6 addresses.
+ *  Fix: Use `HttpUrl` internally.
+ *  Fix: Recover from Android 4.2.2 EBADF crashes.
+ *  Fix: Don't crash with an `IllegalStateException` if an HTTP/2 or SPDY
+    write fails, leaving the connection in an inconsistent state.
+ *  Fix: Make sure the default user agent is ASCII.
+
+
+## Version 2.4.0
+
+_2015-05-22_
+
+ *  **Forbid response bodies on HTTP 204 and 205 responses.** Webservers that
+    return such malformed responses will now trigger a `ProtocolException` in
+    the client.
+
+ *  **WebSocketListener has incompatible changes.** The `onOpen()` method is now
+    called on the reader thread, so implementations must return before further
+    websocket messages will be delivered. The `onFailure()` method now includes
+    an HTTP response if one was returned.
+
+## Version 2.4.0-RC1
+
+_2015-05-16_
+
+ *  **New HttpUrl API.** It's like `java.net.URL` but good. Note that
+    `Request.Builder.url()` now throws `IllegalArgumentException` on malformed
+    URLs. (Previous releases would throw a `MalformedURLException` when calling
+    a malformed URL.)
+
+ *  **We've improved connect failure recovery.** We now differentiate between
+    setup, connecting, and connected and implement appropriate recovery rules
+    for each. This changes `Address` to no longer use `ConnectionSpec`. (This is
+    an incompatible API change).
+
+ *  **`FormEncodingBuilder` now uses `%20` instead of `+` for encoded spaces.**
+    Both are permitted-by-spec, but `%20` requires fewer special cases.
+
+ *  **Okio has been updated to 1.4.0.**
+     ```
+     <dependency>
+       <groupId>com.squareup.okio</groupId>
+       <artifactId>okio</artifactId>
+       <version>1.4.0</version>
+     </dependency>
+     ```
+
+ *  **`Request.Builder` no longer accepts null if a request body is required.**
+    Passing null will now fail for request methods that require a body. Instead
+    use an empty body such as this one:
+
+    ```
+        RequestBody.create(null, new byte[0]);
+    ```
+
+ * **`CertificatePinner` now supports wildcard hostnames.** As always with
+   certificate pinning, you must be very careful to avoid [bricking][brick]
+   your app. You'll need to pin both the top-level domain and the `*.` domain
+   for full coverage.
+
+    ```
+     client.setCertificatePinner(new CertificatePinner.Builder()
+         .add("publicobject.com",   "sha1/DmxUShsZuNiqPQsX2Oi9uv2sCnw=")
+         .add("*.publicobject.com", "sha1/DmxUShsZuNiqPQsX2Oi9uv2sCnw=")
+         .add("publicobject.com",   "sha1/SXxoaOSEzPC6BgGmxAt/EAcsajw=")
+         .add("*.publicobject.com", "sha1/SXxoaOSEzPC6BgGmxAt/EAcsajw=")
+         .add("publicobject.com",   "sha1/blhOM3W9V/bVQhsWAcLYwPU6n24=")
+         .add("*.publicobject.com", "sha1/blhOM3W9V/bVQhsWAcLYwPU6n24=")
+         .add("publicobject.com",   "sha1/T5x9IXmcrQ7YuQxXnxoCmeeQ84c=")
+         .add("*.publicobject.com", "sha1/T5x9IXmcrQ7YuQxXnxoCmeeQ84c=")
+         .build());
+    ```
+
+ *  **Interceptors lists are now deep-copied by `OkHttpClient.clone()`.**
+    Previously clones shared interceptors, which made it difficult to customize
+    the interceptors on a request-by-request basis.
+
+ *  New: `Headers.toMultimap()`.
+ *  New: `RequestBody.create(MediaType, ByteString)`.
+ *  New: `ConnectionSpec.isCompatible(SSLSocket)`.
+ *  New: `Dispatcher.getQueuedCallCount()` and
+    `Dispatcher.getRunningCallCount()`. These can be useful in diagnostics.
+ *  Fix: OkHttp no longer shares timeouts between pooled connections. This was
+    causing some applications to crash when connections were reused.
+ *  Fix: `OkApacheClient` now allows an empty `PUT` and `POST`.
+ *  Fix: Websockets no longer rebuffer socket streams.
+ *  Fix: Websockets are now better at handling close frames.
+ *  Fix: Content type matching is now case insensitive.
+ *  Fix: `Vary` headers are not lost with `android.net.http.HttpResponseCache`.
+ *  Fix: HTTP/2 wasn't enforcing stream timeouts when writing the underlying
+    connection. Now it is.
+ *  Fix: Never return null on `call.proceed()`. This was a bug in call
+    cancelation.
+ *  Fix: When a network interceptor mutates a request, that change is now
+    reflected in `Response.networkResponse()`.
+ *  Fix: Badly-behaving caches now throw a checked exception instead of a
+    `NullPointerException`.
+ *  Fix: Better handling of uncaught exceptions in MockWebServer with HTTP/2.
+
+## Version 2.3.0
+
+_2015-03-16_
+
+ *  **HTTP/2 support.** We've done interop testing and haven't seen any
+    problems. HTTP/2 support has been a big effort and we're particularly
+    thankful to Adrian Cole who has helped us to reach this milestone.
+
+ *  **RC4 cipher suites are no longer supported by default.** To connect to
+    old, obsolete servers relying on these cipher suites, you must create a
+    custom `ConnectionSpec`.
+
+ *  **Beta WebSockets support.**. The `okhttp-ws` subproject offers a new
+    websockets client. Please try it out! When it's ready we intend to include
+    it with the core OkHttp library.
+
+ *  **Okio updated to 1.3.0.**
+
+    ```
+    <dependency>
+      <groupId>com.squareup.okio</groupId>
+      <artifactId>okio</artifactId>
+      <version>1.3.0</version>
+    </dependency>
+    ```
+
+ *  **Fix: improve parallelism of async requests.** OkHttp's Dispatcher had a
+    misconfigured `ExecutorService` that limited the number of worker threads.
+    If you're using `Call.enqueue()` this update should significantly improve
+    request concurrency.
+
+ *  **Fix: Lazily initialize the response cache.** This avoids strict mode
+    warnings when initializing OkHttp on Android‘s main thread.
+
+ *  **Fix: Disable ALPN on Android 4.4.** That release of the feature was
+    unstable and prone to native crashes in the underlying OpenSSL code.
+ *  Fix: Don't send both `If-None-Match` and `If-Modified-Since` cache headers
+    when both are applicable.
+ *  Fix: Fail early when a port is out of range.
+ *  Fix: Offer `Content-Length` headers for multipart request bodies.
+ *  Fix: Throw `UnknownServiceException` if a cleartext connection is attempted
+    when explicitly forbidden.
+ *  Fix: Throw a `SSLPeerUnverifiedException` when host verification fails.
+ *  Fix: MockWebServer explicitly closes sockets. (On some Android releases,
+    closing the input stream and output stream of a socket is not sufficient.
+ *  Fix: Buffer outgoing HTTP/2 frames to limit how many outgoing frames are
+    created.
+ *  Fix: Avoid crashing when cache writing fails due to a full disk.
+ *  Fix: Improve caching of private responses.
+ *  Fix: Update cache-by-default response codes.
+ *  Fix: Reused `Request.Builder` instances no longer hold stale URL fields.
+ *  New: ConnectionSpec can now be configured to use the SSL socket's default
+    cipher suites. To use, set the cipher suites to `null`.
+ *  New: Support `DELETE` with a request body.
+ *  New: `Headers.of(Map)` creates headers from a Map.
+
+
+## Version 2.2.0
 
 _2014-12-30_
 
@@ -9,7 +206,7 @@ _2014-12-30_
     This is a source-incompatible change. If you have code that calls
     `RequestBody.contentLength()`, your compile will break with this
     update. The change is binary-compatible, however: code compiled
-    for OkHttp 2.0 and 2.1 will continue work with this update.
+    for OkHttp 2.0 and 2.1 will continue to work with this update.
 
  *  **`COMPATIBLE_TLS` no longer supports SSLv3.** In response to the
     [POODLE](http://googleonlinesecurity.blogspot.ca/2014/10/this-poodle-bites-exploiting-ssl-30.html)
@@ -43,7 +240,7 @@ _2014-12-30_
  *  Fix: Resurrect http/2 frame logging.
  *  Fix: Limit to 20 authorization attempts.
 
-## VERSION 2.1.0
+## Version 2.1.0
 
 _2014-11-11_
 
@@ -51,7 +248,7 @@ _2014-11-11_
  *  Fix: Don't crash when mixing authorization challenges with upload retries.
 
 
-## VERSION 2.1.0-RC1
+## Version 2.1.0-RC1
 
 _2014-11-04_
 
@@ -269,7 +466,7 @@ in addition to synchronous blocking calls.
  *  **TunnelRequest is gone.** It specified how to connect to an HTTP proxy.
     OkHttp 2 uses the new `Request` class for this.
 
- *  **Dispatcher** is a new class to manages the queue of asynchronous calls. It
+ *  **Dispatcher** is a new class that manages the queue of asynchronous calls. It
     implements limits on total in-flight calls and in-flight calls per host.
 
 #### Implementation changes
@@ -486,3 +683,4 @@ _2013-05-06_
 
 Initial release.
 
+ [brick]: (https://noncombatant.org/2015/05/01/about-http-public-key-pinning/)
diff --git a/README.md b/README.md
index 0e239589a1..4fde155df0 100644
--- a/README.md
+++ b/README.md
@@ -11,12 +11,12 @@ Download [the latest JAR][3] or grab via Maven:
 <dependency>
   <groupId>com.squareup.okhttp</groupId>
   <artifactId>okhttp</artifactId>
-  <version>2.2.0</version>
+  <version>2.5.0</version>
 </dependency>
 ```
 or Gradle:
 ```groovy
-compile 'com.squareup.okhttp:okhttp:2.2.0'
+compile 'com.squareup.okhttp:okhttp:2.5.0'
 ```
 
 Snapshots of the development version are available in [Sonatype's `snapshots` repository][snap].
@@ -36,13 +36,13 @@ Download [the latest JAR][4] or grab via Maven:
 <dependency>
   <groupId>com.squareup.okhttp</groupId>
   <artifactId>mockwebserver</artifactId>
-  <version>2.2.0</version>
+  <version>2.5.0</version>
   <scope>test</scope>
 </dependency>
 ```
 or Gradle:
 ```groovy
-testCompile 'com.squareup.okhttp:mockwebserver:2.2.0'
+testCompile 'com.squareup.okhttp:mockwebserver:2.5.0'
 ```
 
 
diff --git a/benchmarks/pom.xml b/benchmarks/pom.xml
index 4fde956949..d0d2566523 100644
--- a/benchmarks/pom.xml
+++ b/benchmarks/pom.xml
@@ -6,7 +6,7 @@
   <parent>
     <groupId>com.squareup.okhttp</groupId>
     <artifactId>parent</artifactId>
-    <version>2.3.0-SNAPSHOT</version>
+    <version>2.6.0-SNAPSHOT</version>
   </parent>
 
   <artifactId>benchmarks</artifactId>
diff --git a/benchmarks/src/main/java/com/squareup/okhttp/benchmarks/ApacheHttpClient.java b/benchmarks/src/main/java/com/squareup/okhttp/benchmarks/ApacheHttpClient.java
index cb8e719111..3f2609d207 100644
--- a/benchmarks/src/main/java/com/squareup/okhttp/benchmarks/ApacheHttpClient.java
+++ b/benchmarks/src/main/java/com/squareup/okhttp/benchmarks/ApacheHttpClient.java
@@ -15,10 +15,10 @@
  */
 package com.squareup.okhttp.benchmarks;
 
+import com.squareup.okhttp.HttpUrl;
 import com.squareup.okhttp.internal.SslContextBuilder;
 import java.io.IOException;
 import java.io.InputStream;
-import java.net.URL;
 import java.util.concurrent.TimeUnit;
 import java.util.zip.GZIPInputStream;
 import javax.net.ssl.SSLContext;
@@ -49,14 +49,14 @@
     client = new DefaultHttpClient(connectionManager);
   }
 
-  @Override public Runnable request(URL url) {
+  @Override public Runnable request(HttpUrl url) {
     return new ApacheHttpClientRequest(url);
   }
 
   class ApacheHttpClientRequest implements Runnable {
-    private final URL url;
+    private final HttpUrl url;
 
-    public ApacheHttpClientRequest(URL url) {
+    public ApacheHttpClientRequest(HttpUrl url) {
       this.url = url;
     }
 
diff --git a/benchmarks/src/main/java/com/squareup/okhttp/benchmarks/Benchmark.java b/benchmarks/src/main/java/com/squareup/okhttp/benchmarks/Benchmark.java
index 7f0073cc7d..04b7f7fbff 100644
--- a/benchmarks/src/main/java/com/squareup/okhttp/benchmarks/Benchmark.java
+++ b/benchmarks/src/main/java/com/squareup/okhttp/benchmarks/Benchmark.java
@@ -18,6 +18,7 @@
 import com.google.caliper.Param;
 import com.google.caliper.model.ArbitraryMeasurement;
 import com.google.caliper.runner.CaliperMain;
+import com.squareup.okhttp.HttpUrl;
 import com.squareup.okhttp.Protocol;
 import com.squareup.okhttp.internal.SslContextBuilder;
 import com.squareup.okhttp.mockwebserver.Dispatcher;
@@ -25,7 +26,6 @@
 import com.squareup.okhttp.mockwebserver.MockWebServer;
 import com.squareup.okhttp.mockwebserver.RecordedRequest;
 import java.io.IOException;
-import java.net.URL;
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.List;
@@ -101,7 +101,7 @@ public double run() throws Exception {
     // Prepare the client & server
     httpClient.prepare(this);
     MockWebServer server = startServer();
-    URL url = server.getUrl("/");
+    HttpUrl url = server.url("/");
 
     int requestCount = 0;
     long reportStart = System.nanoTime();
diff --git a/benchmarks/src/main/java/com/squareup/okhttp/benchmarks/HttpClient.java b/benchmarks/src/main/java/com/squareup/okhttp/benchmarks/HttpClient.java
index 136c5d86d3..2820dc1cc8 100644
--- a/benchmarks/src/main/java/com/squareup/okhttp/benchmarks/HttpClient.java
+++ b/benchmarks/src/main/java/com/squareup/okhttp/benchmarks/HttpClient.java
@@ -15,11 +15,11 @@
  */
 package com.squareup.okhttp.benchmarks;
 
-import java.net.URL;
+import com.squareup.okhttp.HttpUrl;
 
 /** An HTTP client to benchmark. */
 interface HttpClient {
   void prepare(Benchmark benchmark);
-  void enqueue(URL url) throws Exception;
+  void enqueue(HttpUrl url) throws Exception;
   boolean acceptingJobs();
 }
diff --git a/benchmarks/src/main/java/com/squareup/okhttp/benchmarks/NettyHttpClient.java b/benchmarks/src/main/java/com/squareup/okhttp/benchmarks/NettyHttpClient.java
index 5d8cec5291..1b5571b5de 100644
--- a/benchmarks/src/main/java/com/squareup/okhttp/benchmarks/NettyHttpClient.java
+++ b/benchmarks/src/main/java/com/squareup/okhttp/benchmarks/NettyHttpClient.java
@@ -15,8 +15,8 @@
  */
 package com.squareup.okhttp.benchmarks;
 
+import com.squareup.okhttp.HttpUrl;
 import com.squareup.okhttp.internal.SslContextBuilder;
-import com.squareup.okhttp.internal.Util;
 import io.netty.bootstrap.Bootstrap;
 import io.netty.buffer.ByteBuf;
 import io.netty.buffer.PooledByteBufAllocator;
@@ -41,7 +41,6 @@
 import io.netty.handler.codec.http.HttpVersion;
 import io.netty.handler.codec.http.LastHttpContent;
 import io.netty.handler.ssl.SslHandler;
-import java.net.URL;
 import java.util.ArrayDeque;
 import java.util.Deque;
 import java.util.concurrent.TimeUnit;
@@ -54,7 +53,7 @@
 
   // Guarded by this. Real apps need more capable connection management.
   private final Deque<HttpChannel> freeChannels = new ArrayDeque<>();
-  private final Deque<URL> backlog = new ArrayDeque<>();
+  private final Deque<HttpUrl> backlog = new ArrayDeque<>();
 
   private int totalChannels = 0;
   private int concurrencyLevel;
@@ -89,7 +88,7 @@
         .handler(channelInitializer);
   }
 
-  @Override public void enqueue(URL url) throws Exception {
+  @Override public void enqueue(HttpUrl url) throws Exception {
     HttpChannel httpChannel = null;
     synchronized (this) {
       if (!freeChannels.isEmpty()) {
@@ -102,7 +101,7 @@
       }
     }
     if (httpChannel == null) {
-      Channel channel = bootstrap.connect(url.getHost(), Util.getEffectivePort(url))
+      Channel channel = bootstrap.connect(url.host(), url.port())
           .sync().channel();
       httpChannel = (HttpChannel) channel.pipeline().last();
     }
@@ -119,7 +118,7 @@ private boolean hasFreeChannels() {
   }
 
   private void release(HttpChannel httpChannel) {
-    URL url;
+    HttpUrl url;
     synchronized (this) {
       url = backlog.pop();
       if (url == null) {
@@ -143,12 +142,12 @@ public HttpChannel(SocketChannel channel) {
       this.channel = channel;
     }
 
-    private void sendRequest(URL url) {
+    private void sendRequest(HttpUrl url) {
       start = System.nanoTime();
       total = 0;
       HttpRequest request = new DefaultFullHttpRequest(
-          HttpVersion.HTTP_1_1, HttpMethod.GET, url.getPath());
-      request.headers().set(HttpHeaders.Names.HOST, url.getHost());
+          HttpVersion.HTTP_1_1, HttpMethod.GET, url.encodedPath());
+      request.headers().set(HttpHeaders.Names.HOST, url.host());
       request.headers().set(HttpHeaders.Names.ACCEPT_ENCODING, HttpHeaders.Values.GZIP);
       channel.writeAndFlush(request);
     }
diff --git a/benchmarks/src/main/java/com/squareup/okhttp/benchmarks/OkHttp.java b/benchmarks/src/main/java/com/squareup/okhttp/benchmarks/OkHttp.java
index 3885ed7f53..496e8d30bd 100644
--- a/benchmarks/src/main/java/com/squareup/okhttp/benchmarks/OkHttp.java
+++ b/benchmarks/src/main/java/com/squareup/okhttp/benchmarks/OkHttp.java
@@ -15,12 +15,12 @@
  */
 package com.squareup.okhttp.benchmarks;
 
+import com.squareup.okhttp.HttpUrl;
 import com.squareup.okhttp.OkHttpClient;
 import com.squareup.okhttp.OkUrlFactory;
 import com.squareup.okhttp.internal.SslContextBuilder;
 import java.io.IOException;
 import java.net.HttpURLConnection;
-import java.net.URL;
 import java.util.concurrent.TimeUnit;
 import javax.net.ssl.HostnameVerifier;
 import javax.net.ssl.SSLContext;
@@ -50,21 +50,21 @@
     }
   }
 
-  @Override public Runnable request(URL url) {
+  @Override public Runnable request(HttpUrl url) {
     return new OkHttpRequest(url);
   }
 
   class OkHttpRequest implements Runnable {
-    private final URL url;
+    private final HttpUrl url;
 
-    public OkHttpRequest(URL url) {
+    public OkHttpRequest(HttpUrl url) {
       this.url = url;
     }
 
     public void run() {
       long start = System.nanoTime();
       try {
-        HttpURLConnection urlConnection = new OkUrlFactory(client).open(url);
+        HttpURLConnection urlConnection = new OkUrlFactory(client).open(url.url());
         long total = readAllAndClose(urlConnection.getInputStream());
         long finish = System.nanoTime();
 
diff --git a/benchmarks/src/main/java/com/squareup/okhttp/benchmarks/OkHttpAsync.java b/benchmarks/src/main/java/com/squareup/okhttp/benchmarks/OkHttpAsync.java
index ab7849017c..cf0ad4accf 100644
--- a/benchmarks/src/main/java/com/squareup/okhttp/benchmarks/OkHttpAsync.java
+++ b/benchmarks/src/main/java/com/squareup/okhttp/benchmarks/OkHttpAsync.java
@@ -17,13 +17,13 @@
 
 import com.squareup.okhttp.Callback;
 import com.squareup.okhttp.Dispatcher;
+import com.squareup.okhttp.HttpUrl;
 import com.squareup.okhttp.OkHttpClient;
 import com.squareup.okhttp.Request;
 import com.squareup.okhttp.Response;
 import com.squareup.okhttp.ResponseBody;
 import com.squareup.okhttp.internal.SslContextBuilder;
 import java.io.IOException;
-import java.net.URL;
 import java.util.concurrent.LinkedBlockingQueue;
 import java.util.concurrent.ThreadPoolExecutor;
 import java.util.concurrent.TimeUnit;
@@ -83,7 +83,7 @@
     };
   }
 
-  @Override public void enqueue(URL url) throws Exception {
+  @Override public void enqueue(HttpUrl url) throws Exception {
     requestsInFlight.incrementAndGet();
     client.newCall(new Request.Builder().tag(System.nanoTime()).url(url).build()).enqueue(callback);
   }
diff --git a/benchmarks/src/main/java/com/squareup/okhttp/benchmarks/SynchronousHttpClient.java b/benchmarks/src/main/java/com/squareup/okhttp/benchmarks/SynchronousHttpClient.java
index b15eedcd88..3b9631511b 100644
--- a/benchmarks/src/main/java/com/squareup/okhttp/benchmarks/SynchronousHttpClient.java
+++ b/benchmarks/src/main/java/com/squareup/okhttp/benchmarks/SynchronousHttpClient.java
@@ -15,9 +15,9 @@
  */
 package com.squareup.okhttp.benchmarks;
 
+import com.squareup.okhttp.HttpUrl;
 import java.io.IOException;
 import java.io.InputStream;
-import java.net.URL;
 import java.util.concurrent.LinkedBlockingQueue;
 import java.util.concurrent.ThreadPoolExecutor;
 import java.util.concurrent.TimeUnit;
@@ -33,7 +33,7 @@
         1, TimeUnit.SECONDS, new LinkedBlockingQueue<Runnable>());
   }
 
-  @Override public void enqueue(URL url) {
+  @Override public void enqueue(HttpUrl url) {
     executor.execute(request(url));
   }
 
@@ -51,5 +51,5 @@ static long readAllAndClose(InputStream in) throws IOException {
     return total;
   }
 
-  abstract Runnable request(URL url);
+  abstract Runnable request(HttpUrl url);
 }
diff --git a/benchmarks/src/main/java/com/squareup/okhttp/benchmarks/UrlConnection.java b/benchmarks/src/main/java/com/squareup/okhttp/benchmarks/UrlConnection.java
index 630ec91c54..e17743095a 100644
--- a/benchmarks/src/main/java/com/squareup/okhttp/benchmarks/UrlConnection.java
+++ b/benchmarks/src/main/java/com/squareup/okhttp/benchmarks/UrlConnection.java
@@ -15,11 +15,11 @@
  */
 package com.squareup.okhttp.benchmarks;
 
+import com.squareup.okhttp.HttpUrl;
 import com.squareup.okhttp.internal.SslContextBuilder;
 import java.io.IOException;
 import java.io.InputStream;
 import java.net.HttpURLConnection;
-import java.net.URL;
 import java.util.concurrent.TimeUnit;
 import java.util.zip.GZIPInputStream;
 import javax.net.ssl.HostnameVerifier;
@@ -46,21 +46,21 @@
     }
   }
 
-  @Override public Runnable request(URL url) {
+  @Override public Runnable request(HttpUrl url) {
     return new UrlConnectionRequest(url);
   }
 
   static class UrlConnectionRequest implements Runnable {
-    private final URL url;
+    private final HttpUrl url;
 
-    public UrlConnectionRequest(URL url) {
+    public UrlConnectionRequest(HttpUrl url) {
       this.url = url;
     }
 
     public void run() {
       long start = System.nanoTime();
       try {
-        HttpURLConnection urlConnection = (HttpURLConnection) url.openConnection();
+        HttpURLConnection urlConnection = (HttpURLConnection) url.url().openConnection();
         InputStream in = urlConnection.getInputStream();
         if ("gzip".equals(urlConnection.getHeaderField("Content-Encoding"))) {
           in = new GZIPInputStream(in);
diff --git a/checkstyle.xml b/checkstyle.xml
index f725be3381..fc173af9e0 100644
--- a/checkstyle.xml
+++ b/checkstyle.xml
@@ -66,7 +66,9 @@
     <module name="LineLength">
       <property name="max" value="100"/>
     </module>
-    <module name="MethodLength"/>
+    <module name="MethodLength">
+      <property name="max" value="200"/>
+    </module>
 
 
     <!-- Checks for whitespace                               -->
diff --git a/mockwebserver/README.md b/mockwebserver/README.md
index c72966826c..3fd6ca6e9d 100644
--- a/mockwebserver/README.md
+++ b/mockwebserver/README.md
@@ -42,7 +42,7 @@ public void test() throws Exception {
   server.start();
 
   // Ask the server for its URL. You'll need this to make HTTP requests.
-  URL baseUrl = server.getUrl("/v1/chat/");
+  URL baseUrl = server.url("/v1/chat/");
 
   // Exercise your application code, which should make those HTTP requests.
   // Responses are returned in the same order that they are enqueued.
@@ -116,12 +116,31 @@ assertEquals("{}", request.getUtf8Body());
 By default MockWebServer uses a queue to specify a series of responses. Use a
 Dispatcher to handle requests using another policy. One natural policy is to
 dispatch on the request path.
+You can, for example, filter the request instead of using `server.enqueue()`.
 
+```java
+final Dispatcher dispatcher = new Dispatcher() {
+
+    @Override
+    public MockResponse dispatch(RecordedRequest request) throws InterruptedException {
+
+        if (request.getPath().equals("/v1/login/auth/")){
+            return new MockResponse().setResponseCode(200);
+        } else if (request.getPath().equals("v1/check/version/")){
+            return new MockResponse().setResponseCode(200).setBody("version=9");
+        } else if (request.getPath().equals("/v1/profile/info")) {
+            return new MockResponse().setResponseCode(200).setBody("{\\\"info\\\":{\\\"name\":\"Lucas Albuquerque\",\"age\":\"21\",\"gender\":\"male\"}}");
+        }
+        return new MockResponse().setResponseCode(404);
+    }
+};
+server.setDispatcher(dispatcher);
+```
 
-### Download
 
-The best way to get MockWebServer is via Maven:
+### Download
 
+Get MockWebServer via Maven:
 ```xml
 <dependency>
   <groupId>com.squareup.okhttp</groupId>
@@ -131,6 +150,11 @@ The best way to get MockWebServer is via Maven:
 </dependency>
 ```
 
+or via Gradle 
+```groovy
+testCompile 'com.squareup.okhttp:mockwebserver:(insert latest version)'
+```
+
 ### License
 
     Licensed under the Apache License, Version 2.0 (the "License");
diff --git a/mockwebserver/pom.xml b/mockwebserver/pom.xml
index ae3abb5c66..9ef5211d1f 100644
--- a/mockwebserver/pom.xml
+++ b/mockwebserver/pom.xml
@@ -6,7 +6,7 @@
   <parent>
     <groupId>com.squareup.okhttp</groupId>
     <artifactId>parent</artifactId>
-    <version>2.3.0-SNAPSHOT</version>
+    <version>2.6.0-SNAPSHOT</version>
   </parent>
 
   <artifactId>mockwebserver</artifactId>
@@ -18,6 +18,17 @@
       <artifactId>okhttp</artifactId>
       <version>${project.version}</version>
     </dependency>
+    <dependency>
+      <groupId>com.squareup.okhttp</groupId>
+      <artifactId>okhttp-testing-support</artifactId>
+      <version>${project.version}</version>
+      <scope>test</scope>
+    </dependency>
+    <dependency>
+      <groupId>com.squareup.okhttp</groupId>
+      <artifactId>okhttp-ws</artifactId>
+      <version>${project.version}</version>
+    </dependency>
     <dependency>
       <groupId>org.bouncycastle</groupId>
       <artifactId>bcprov-jdk15on</artifactId>
@@ -25,7 +36,6 @@
     <dependency>
       <groupId>junit</groupId>
       <artifactId>junit</artifactId>
-      <optional>true</optional>
     </dependency>
   </dependencies>
 
diff --git a/mockwebserver/src/main/java/com/squareup/okhttp/internal/SslContextBuilder.java b/mockwebserver/src/main/java/com/squareup/okhttp/internal/SslContextBuilder.java
index 3d61d73b05..546d66036e 100644
--- a/mockwebserver/src/main/java/com/squareup/okhttp/internal/SslContextBuilder.java
+++ b/mockwebserver/src/main/java/com/squareup/okhttp/internal/SslContextBuilder.java
@@ -68,7 +68,7 @@ public SslContextBuilder(String hostName) {
   public static synchronized SSLContext localhost() {
     if (localhost == null) {
       try {
-        localhost = new SslContextBuilder(InetAddress.getByName(null).getHostName()).build();
+        localhost = new SslContextBuilder(InetAddress.getByName("localhost").getHostName()).build();
       } catch (GeneralSecurityException e) {
         throw new RuntimeException(e);
       } catch (UnknownHostException e) {
diff --git a/mockwebserver/src/main/java/com/squareup/okhttp/internal/framed/FramedServer.java b/mockwebserver/src/main/java/com/squareup/okhttp/internal/framed/FramedServer.java
new file mode 100644
index 0000000000..b95b64d899
--- /dev/null
+++ b/mockwebserver/src/main/java/com/squareup/okhttp/internal/framed/FramedServer.java
@@ -0,0 +1,187 @@
+/*
+ * Copyright (C) 2011 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.squareup.okhttp.internal.framed;
+
+import com.squareup.okhttp.Protocol;
+import com.squareup.okhttp.internal.Platform;
+import com.squareup.okhttp.internal.SslContextBuilder;
+import com.squareup.okhttp.internal.Util;
+import java.io.File;
+import java.io.IOException;
+import java.net.ProtocolException;
+import java.net.ServerSocket;
+import java.net.Socket;
+import java.util.Arrays;
+import java.util.List;
+import java.util.logging.Level;
+import java.util.logging.Logger;
+import javax.net.ssl.SSLSocket;
+import javax.net.ssl.SSLSocketFactory;
+import okio.BufferedSink;
+import okio.Okio;
+import okio.Source;
+
+/** A basic SPDY/HTTP_2 server that serves the contents of a local directory. */
+public final class FramedServer implements IncomingStreamHandler {
+  static final Logger logger = Logger.getLogger(FramedServer.class.getName());
+
+  private final List<Protocol> framedProtocols =
+      Util.immutableList(Protocol.HTTP_2, Protocol.SPDY_3);
+
+  private final File baseDirectory;
+  private final SSLSocketFactory sslSocketFactory;
+
+  public FramedServer(File baseDirectory, SSLSocketFactory sslSocketFactory) {
+    this.baseDirectory = baseDirectory;
+    this.sslSocketFactory = sslSocketFactory;
+  }
+
+  private void run() throws Exception {
+    ServerSocket serverSocket = new ServerSocket(8888);
+    serverSocket.setReuseAddress(true);
+
+    while (true) {
+      Socket socket = null;
+      try {
+        socket = serverSocket.accept();
+
+        SSLSocket sslSocket = doSsl(socket);
+        String protocolString = Platform.get().getSelectedProtocol(sslSocket);
+        Protocol protocol = protocolString != null ? Protocol.get(protocolString) : null;
+        if (protocol == null || !framedProtocols.contains(protocol)) {
+          throw new ProtocolException("Protocol " + protocol + " unsupported");
+        }
+        FramedConnection framedConnection = new FramedConnection.Builder(false, sslSocket)
+            .protocol(protocol)
+            .handler(this)
+            .build();
+        framedConnection.sendConnectionPreface();
+      } catch (IOException e) {
+        logger.log(Level.INFO, "FramedServer connection failure: " + e);
+        Util.closeQuietly(socket);
+      } catch (Exception e) {
+        logger.log(Level.WARNING, "FramedServer unexpected failure", e);
+        Util.closeQuietly(socket);
+      }
+    }
+  }
+
+  private SSLSocket doSsl(Socket socket) throws IOException {
+    SSLSocket sslSocket = (SSLSocket) sslSocketFactory.createSocket(
+        socket, socket.getInetAddress().getHostAddress(), socket.getPort(), true);
+    sslSocket.setUseClientMode(false);
+    Platform.get().configureTlsExtensions(sslSocket, null, framedProtocols);
+    sslSocket.startHandshake();
+    return sslSocket;
+  }
+
+  @Override public void receive(final FramedStream stream) throws IOException {
+    try {
+      List<Header> requestHeaders = stream.getRequestHeaders();
+      String path = null;
+      for (int i = 0, size = requestHeaders.size(); i < size; i++) {
+        if (requestHeaders.get(i).name.equals(Header.TARGET_PATH)) {
+          path = requestHeaders.get(i).value.utf8();
+          break;
+        }
+      }
+
+      if (path == null) {
+        // TODO: send bad request error
+        throw new AssertionError();
+      }
+
+      File file = new File(baseDirectory + path);
+
+      if (file.isDirectory()) {
+        serveDirectory(stream, file.listFiles());
+      } else if (file.exists()) {
+        serveFile(stream, file);
+      } else {
+        send404(stream, path);
+      }
+    } catch (IOException e) {
+      System.out.println(e.getMessage());
+    }
+  }
+
+  private void send404(FramedStream stream, String path) throws IOException {
+    List<Header> responseHeaders = Arrays.asList(
+        new Header(":status", "404"),
+        new Header(":version", "HTTP/1.1"),
+        new Header("content-type", "text/plain")
+    );
+    stream.reply(responseHeaders, true);
+    BufferedSink out = Okio.buffer(stream.getSink());
+    out.writeUtf8("Not found: " + path);
+    out.close();
+  }
+
+  private void serveDirectory(FramedStream stream, File[] files) throws IOException {
+    List<Header> responseHeaders = Arrays.asList(
+        new Header(":status", "200"),
+        new Header(":version", "HTTP/1.1"),
+        new Header("content-type", "text/html; charset=UTF-8")
+    );
+    stream.reply(responseHeaders, true);
+    BufferedSink out = Okio.buffer(stream.getSink());
+    for (File file : files) {
+      String target = file.isDirectory() ? (file.getName() + "/") : file.getName();
+      out.writeUtf8("<a href='" + target + "'>" + target + "</a><br>");
+    }
+    out.close();
+  }
+
+  private void serveFile(FramedStream stream, File file) throws IOException {
+    List<Header> responseHeaders = Arrays.asList(
+        new Header(":status", "200"),
+        new Header(":version", "HTTP/1.1"),
+        new Header("content-type", contentType(file))
+    );
+    stream.reply(responseHeaders, true);
+    Source source = Okio.source(file);
+    try {
+      BufferedSink out = Okio.buffer(stream.getSink());
+      out.writeAll(source);
+      out.close();
+    } finally {
+      Util.closeQuietly(source);
+    }
+  }
+
+  private String contentType(File file) {
+    if (file.getName().endsWith(".css")) return "text/css";
+    if (file.getName().endsWith(".gif")) return "image/gif";
+    if (file.getName().endsWith(".html")) return "text/html";
+    if (file.getName().endsWith(".jpeg")) return "image/jpeg";
+    if (file.getName().endsWith(".jpg")) return "image/jpeg";
+    if (file.getName().endsWith(".js")) return "application/javascript";
+    if (file.getName().endsWith(".png")) return "image/png";
+    return "text/plain";
+  }
+
+  public static void main(String... args) throws Exception {
+    if (args.length != 1 || args[0].startsWith("-")) {
+      System.out.println("Usage: FramedServer <base directory>");
+      return;
+    }
+
+    FramedServer server = new FramedServer(new File(args[0]),
+        SslContextBuilder.localhost().getSocketFactory());
+    server.run();
+  }
+}
diff --git a/mockwebserver/src/main/java/com/squareup/okhttp/internal/spdy/SpdyServer.java b/mockwebserver/src/main/java/com/squareup/okhttp/internal/spdy/SpdyServer.java
deleted file mode 100644
index fb21a088d0..0000000000
--- a/mockwebserver/src/main/java/com/squareup/okhttp/internal/spdy/SpdyServer.java
+++ /dev/null
@@ -1,162 +0,0 @@
-/*
- * Copyright (C) 2011 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.squareup.okhttp.internal.spdy;
-
-import com.squareup.okhttp.Protocol;
-import com.squareup.okhttp.internal.Platform;
-import com.squareup.okhttp.internal.SslContextBuilder;
-import com.squareup.okhttp.internal.Util;
-import java.io.File;
-import java.io.IOException;
-import java.net.ServerSocket;
-import java.net.Socket;
-import java.util.Arrays;
-import java.util.List;
-import javax.net.ssl.SSLSocket;
-import javax.net.ssl.SSLSocketFactory;
-import okio.BufferedSink;
-import okio.Okio;
-import okio.Source;
-
-/** A basic SPDY/HTTP_2 server that serves the contents of a local directory. */
-public final class SpdyServer implements IncomingStreamHandler {
-  private final List<Protocol> spdyProtocols = Util.immutableList(Protocol.HTTP_2, Protocol.SPDY_3);
-
-  private final File baseDirectory;
-  private SSLSocketFactory sslSocketFactory;
-  private Protocol protocol;
-
-  public SpdyServer(File baseDirectory) {
-    this.baseDirectory = baseDirectory;
-  }
-
-  public void useHttps(SSLSocketFactory sslSocketFactory) {
-    this.sslSocketFactory = sslSocketFactory;
-  }
-
-  private void run() throws Exception {
-    ServerSocket serverSocket = new ServerSocket(8888);
-    serverSocket.setReuseAddress(true);
-
-    while (true) {
-      Socket socket = serverSocket.accept();
-      if (sslSocketFactory != null) {
-        socket = doSsl(socket);
-      }
-      new SpdyConnection.Builder(false, socket).protocol(protocol).handler(this).build();
-    }
-  }
-
-  private Socket doSsl(Socket socket) throws IOException {
-    SSLSocket sslSocket =
-        (SSLSocket) sslSocketFactory.createSocket(socket, socket.getInetAddress().getHostAddress(),
-            socket.getPort(), true);
-    sslSocket.setUseClientMode(false);
-    Platform.get().configureTlsExtensions(sslSocket, null, spdyProtocols);
-    sslSocket.startHandshake();
-    String protocolString = Platform.get().getSelectedProtocol(sslSocket);
-    protocol = protocolString != null ? Protocol.get(protocolString) : null;
-    if (protocol == null || !spdyProtocols.contains(protocol)) {
-      throw new IllegalStateException("Protocol " + protocol + " unsupported");
-    }
-    return sslSocket;
-  }
-
-  @Override public void receive(final SpdyStream stream) throws IOException {
-    List<Header> requestHeaders = stream.getRequestHeaders();
-    String path = null;
-    for (int i = 0, size = requestHeaders.size(); i < size; i++) {
-      if (requestHeaders.get(i).name.equals(Header.TARGET_PATH)) {
-        path = requestHeaders.get(i).value.utf8();
-        break;
-      }
-    }
-
-    if (path == null) {
-      // TODO: send bad request error
-      throw new AssertionError();
-    }
-
-    File file = new File(baseDirectory + path);
-
-    if (file.isDirectory()) {
-      serveDirectory(stream, file.list());
-    } else if (file.exists()) {
-      serveFile(stream, file);
-    } else {
-      send404(stream, path);
-    }
-  }
-
-  private void send404(SpdyStream stream, String path) throws IOException {
-    List<Header> responseHeaders = Arrays.asList(
-        new Header(":status", "404"),
-        new Header(":version", "HTTP/1.1"),
-        new Header("content-type", "text/plain")
-    );
-    stream.reply(responseHeaders, true);
-    BufferedSink out = Okio.buffer(stream.getSink());
-    out.writeUtf8("Not found: " + path);
-    out.close();
-  }
-
-  private void serveDirectory(SpdyStream stream, String[] files) throws IOException {
-    List<Header> responseHeaders = Arrays.asList(
-        new Header(":status", "200"),
-        new Header(":version", "HTTP/1.1"),
-        new Header("content-type", "text/html; charset=UTF-8")
-    );
-    stream.reply(responseHeaders, true);
-    BufferedSink out = Okio.buffer(stream.getSink());
-    for (String file : files) {
-      out.writeUtf8("<a href='" + file + "'>" + file + "</a><br>");
-    }
-    out.close();
-  }
-
-  private void serveFile(SpdyStream stream, File file) throws IOException {
-    List<Header> responseHeaders = Arrays.asList(
-        new Header(":status", "200"),
-        new Header(":version", "HTTP/1.1"),
-        new Header("content-type", contentType(file))
-    );
-    stream.reply(responseHeaders, true);
-    Source source = Okio.source(file);
-    try {
-      BufferedSink out = Okio.buffer(stream.getSink());
-      out.writeAll(source);
-      out.close();
-    } finally {
-      Util.closeQuietly(source);
-    }
-  }
-
-  private String contentType(File file) {
-    return file.getName().endsWith(".html") ? "text/html" : "text/plain";
-  }
-
-  public static void main(String... args) throws Exception {
-    if (args.length != 1 || args[0].startsWith("-")) {
-      System.out.println("Usage: SpdyServer <base directory>");
-      return;
-    }
-
-    SpdyServer server = new SpdyServer(new File(args[0]));
-    server.useHttps(SslContextBuilder.localhost().getSocketFactory());
-    server.run();
-  }
-}
diff --git a/mockwebserver/src/main/java/com/squareup/okhttp/mockwebserver/MockResponse.java b/mockwebserver/src/main/java/com/squareup/okhttp/mockwebserver/MockResponse.java
index 8f0ee2c50f..09dda5634b 100644
--- a/mockwebserver/src/main/java/com/squareup/okhttp/mockwebserver/MockResponse.java
+++ b/mockwebserver/src/main/java/com/squareup/okhttp/mockwebserver/MockResponse.java
@@ -16,7 +16,7 @@
 package com.squareup.okhttp.mockwebserver;
 
 import com.squareup.okhttp.Headers;
-import com.squareup.okhttp.internal.ws.WebSocketListener;
+import com.squareup.okhttp.ws.WebSocketListener;
 import java.util.ArrayList;
 import java.util.List;
 import java.util.concurrent.TimeUnit;
@@ -153,7 +153,7 @@ public MockResponse setChunkedBody(Buffer body, int maxChunkSize) {
     Buffer bytesOut = new Buffer();
     while (!body.exhausted()) {
       long chunkSize = Math.min(body.size(), maxChunkSize);
-      bytesOut.writeUtf8(Long.toHexString(chunkSize));
+      bytesOut.writeHexadecimalUnsignedLong(chunkSize);
       bytesOut.writeUtf8("\r\n");
       bytesOut.write(body, chunkSize);
       bytesOut.writeUtf8("\r\n");
diff --git a/mockwebserver/src/main/java/com/squareup/okhttp/mockwebserver/MockWebServer.java b/mockwebserver/src/main/java/com/squareup/okhttp/mockwebserver/MockWebServer.java
index 39fbf6fd84..458c6f9a5c 100644
--- a/mockwebserver/src/main/java/com/squareup/okhttp/mockwebserver/MockWebServer.java
+++ b/mockwebserver/src/main/java/com/squareup/okhttp/mockwebserver/MockWebServer.java
@@ -18,24 +18,25 @@
 package com.squareup.okhttp.mockwebserver;
 
 import com.squareup.okhttp.Headers;
+import com.squareup.okhttp.HttpUrl;
 import com.squareup.okhttp.Protocol;
 import com.squareup.okhttp.Request;
 import com.squareup.okhttp.Response;
 import com.squareup.okhttp.internal.NamedRunnable;
 import com.squareup.okhttp.internal.Platform;
 import com.squareup.okhttp.internal.Util;
-import com.squareup.okhttp.internal.spdy.ErrorCode;
-import com.squareup.okhttp.internal.spdy.Header;
-import com.squareup.okhttp.internal.spdy.IncomingStreamHandler;
-import com.squareup.okhttp.internal.spdy.SpdyConnection;
-import com.squareup.okhttp.internal.spdy.SpdyStream;
+import com.squareup.okhttp.internal.framed.ErrorCode;
+import com.squareup.okhttp.internal.framed.FramedConnection;
+import com.squareup.okhttp.internal.framed.FramedStream;
+import com.squareup.okhttp.internal.framed.Header;
+import com.squareup.okhttp.internal.framed.IncomingStreamHandler;
+import com.squareup.okhttp.internal.http.HttpMethod;
 import com.squareup.okhttp.internal.ws.RealWebSocket;
-import com.squareup.okhttp.internal.ws.WebSocketListener;
 import com.squareup.okhttp.internal.ws.WebSocketProtocol;
+import com.squareup.okhttp.ws.WebSocketListener;
 import java.io.IOException;
 import java.net.InetAddress;
 import java.net.InetSocketAddress;
-import java.net.MalformedURLException;
 import java.net.ProtocolException;
 import java.net.Proxy;
 import java.net.ServerSocket;
@@ -56,7 +57,9 @@
 import java.util.concurrent.CountDownLatch;
 import java.util.concurrent.ExecutorService;
 import java.util.concurrent.Executors;
+import java.util.concurrent.LinkedBlockingDeque;
 import java.util.concurrent.LinkedBlockingQueue;
+import java.util.concurrent.ThreadPoolExecutor;
 import java.util.concurrent.TimeUnit;
 import java.util.concurrent.atomic.AtomicInteger;
 import java.util.logging.Level;
@@ -74,15 +77,20 @@
 import okio.Okio;
 import okio.Sink;
 import okio.Timeout;
+import org.junit.rules.TestRule;
+import org.junit.runner.Description;
+import org.junit.runners.model.Statement;
 
 import static com.squareup.okhttp.mockwebserver.SocketPolicy.DISCONNECT_AT_START;
+import static com.squareup.okhttp.mockwebserver.SocketPolicy.DISCONNECT_DURING_RESPONSE_BODY;
 import static com.squareup.okhttp.mockwebserver.SocketPolicy.FAIL_HANDSHAKE;
+import static java.util.concurrent.TimeUnit.SECONDS;
 
 /**
  * A scriptable web server. Callers supply canned responses and the server
  * replays them upon request in sequence.
  */
-public final class MockWebServer {
+public final class MockWebServer implements TestRule {
   private static final X509TrustManager UNTRUSTED_TRUST_MANAGER = new X509TrustManager() {
     @Override public void checkClientTrusted(X509Certificate[] chain, String authType)
         throws CertificateException {
@@ -104,8 +112,8 @@
 
   private final Set<Socket> openClientSockets =
       Collections.newSetFromMap(new ConcurrentHashMap<Socket, Boolean>());
-  private final Set<SpdyConnection> openSpdyConnections =
-      Collections.newSetFromMap(new ConcurrentHashMap<SpdyConnection, Boolean>());
+  private final Set<FramedConnection> openFramedConnections =
+      Collections.newSetFromMap(new ConcurrentHashMap<FramedConnection, Boolean>());
   private final AtomicInteger requestCount = new AtomicInteger();
   private long bodyLimit = Long.MAX_VALUE;
   private ServerSocketFactory serverSocketFactory = ServerSocketFactory.getDefault();
@@ -121,43 +129,75 @@
   private List<Protocol> protocols
       = Util.immutableList(Protocol.HTTP_2, Protocol.SPDY_3, Protocol.HTTP_1_1);
 
-  public void setServerSocketFactory(ServerSocketFactory serverSocketFactory) {
-    if (serverSocketFactory == null) throw new IllegalArgumentException("null serverSocketFactory");
-    this.serverSocketFactory = serverSocketFactory;
+  private boolean started;
+
+  private synchronized void maybeStart() {
+    if (started) return;
+    try {
+      start();
+    } catch (IOException e) {
+      throw new RuntimeException(e);
+    }
+  }
+
+  @Override public Statement apply(final Statement base, Description description) {
+    return new Statement() {
+      @Override public void evaluate() throws Throwable {
+        maybeStart();
+        try {
+          base.evaluate();
+        } finally {
+          try {
+            shutdown();
+          } catch (IOException e) {
+            logger.log(Level.WARNING, "MockWebServer shutdown failed", e);
+          }
+        }
+      }
+    };
   }
 
   public int getPort() {
-    if (port == -1) throw new IllegalStateException("Call start() before getPort()");
+    maybeStart();
     return port;
   }
 
   public String getHostName() {
-    if (inetSocketAddress == null) {
-      throw new IllegalStateException("Call start() before getHostName()");
-    }
+    maybeStart();
     return inetSocketAddress.getHostName();
   }
 
   public Proxy toProxyAddress() {
-    if (inetSocketAddress == null) {
-      throw new IllegalStateException("Call start() before toProxyAddress()");
-    }
+    maybeStart();
     InetSocketAddress address = new InetSocketAddress(inetSocketAddress.getAddress(), getPort());
     return new Proxy(Proxy.Type.HTTP, address);
   }
 
+  public void setServerSocketFactory(ServerSocketFactory serverSocketFactory) {
+    this.serverSocketFactory = serverSocketFactory;
+  }
+
   /**
    * Returns a URL for connecting to this server.
    * @param path the request path, such as "/".
    */
+  @Deprecated
   public URL getUrl(String path) {
-    try {
-      return sslSocketFactory != null
-          ? new URL("https://" + getHostName() + ":" + getPort() + path)
-          : new URL("http://" + getHostName() + ":" + getPort() + path);
-    } catch (MalformedURLException e) {
-      throw new AssertionError(e);
-    }
+    return url(path).url();
+  }
+
+  /**
+   * Returns a URL for connecting to this server.
+   *
+   * @param path the request path, such as "/".
+   */
+  public HttpUrl url(String path) {
+    return new HttpUrl.Builder()
+        .scheme(sslSocketFactory != null ? "https" : "http")
+        .host(getHostName())
+        .port(getPort())
+        .build()
+        .resolve(path);
   }
 
   /**
@@ -263,16 +303,6 @@ public void enqueue(MockResponse response) {
     ((QueueDispatcher) dispatcher).enqueueResponse(response.clone());
   }
 
-  /** @deprecated Use {@link #start()}. */
-  public void play() throws IOException {
-    start();
-  }
-
-  /** @deprecated Use {@link #start(int)}. */
-  public void play(int port) throws IOException {
-    start(port);
-  }
-
   /** Equivalent to {@code start(0)}. */
   public void start() throws IOException {
     start(0);
@@ -307,8 +337,10 @@ public void start(InetAddress inetAddress, int port) throws IOException {
    *
    * @param inetSocketAddress the socket address to bind the server on
    */
-  private void start(InetSocketAddress inetSocketAddress) throws IOException {
-    if (executor != null) throw new IllegalStateException("start() already called");
+  private synchronized void start(InetSocketAddress inetSocketAddress) throws IOException {
+    if (started) throw new IllegalStateException("start() already called");
+    started = true;
+
     executor = Executors.newCachedThreadPool(Util.threadFactory("MockWebServer", false));
     this.inetSocketAddress = inetSocketAddress;
     serverSocket = serverSocketFactory.createServerSocket();
@@ -332,7 +364,7 @@ private void start(InetSocketAddress inetSocketAddress) throws IOException {
           Util.closeQuietly(s.next());
           s.remove();
         }
-        for (Iterator<SpdyConnection> s = openSpdyConnections.iterator(); s.hasNext(); ) {
+        for (Iterator<FramedConnection> s = openFramedConnections.iterator(); s.hasNext(); ) {
           Util.closeQuietly(s.next());
           s.remove();
         }
@@ -361,7 +393,10 @@ private void acceptConnections() throws Exception {
     });
   }
 
-  public void shutdown() throws IOException {
+  public synchronized void shutdown() throws IOException {
+    if (!started) return;
+    if (serverSocket == null) throw new IllegalStateException("shutdown() before start()");
+
     // Cause acceptConnections() to break out.
     serverSocket.close();
 
@@ -426,12 +461,12 @@ public void processConnection() throws Exception {
         }
 
         if (protocol != Protocol.HTTP_1_1) {
-          SpdySocketHandler spdySocketHandler = new SpdySocketHandler(socket, protocol);
-          SpdyConnection spdyConnection =
-              new SpdyConnection.Builder(false, socket).protocol(protocol)
-                  .handler(spdySocketHandler)
+          FramedSocketHandler framedSocketHandler = new FramedSocketHandler(socket, protocol);
+          FramedConnection framedConnection =
+              new FramedConnection.Builder(false, socket).protocol(protocol)
+                  .handler(framedSocketHandler)
                   .build();
-          openSpdyConnections.add(spdyConnection);
+          openFramedConnections.add(framedConnection);
           openClientSockets.remove(socket);
           return;
         }
@@ -472,8 +507,8 @@ private void createTunnel() throws IOException, InterruptedException {
       }
 
       /**
-       * Reads a request and writes its response. Returns true if a request was
-       * processed.
+       * Reads a request and writes its response. Returns true if further calls should be attempted
+       * on the socket.
        */
       private boolean processOneRequest(Socket socket, BufferedSource source, BufferedSink sink)
           throws IOException, InterruptedException {
@@ -494,33 +529,33 @@ private boolean processOneRequest(Socket socket, BufferedSource source, Buffered
           throw new ProtocolException("unexpected data");
         }
 
+        boolean reuseSocket = true;
         boolean requestWantsWebSockets = "Upgrade".equalsIgnoreCase(request.getHeader("Connection"))
             && "websocket".equalsIgnoreCase(request.getHeader("Upgrade"));
         boolean responseWantsWebSockets = response.getWebSocketListener() != null;
         if (requestWantsWebSockets && responseWantsWebSockets) {
           handleWebSocketUpgrade(socket, source, sink, request, response);
+          reuseSocket = false;
         } else {
           writeHttpResponse(socket, sink, response);
         }
 
+        if (logger.isLoggable(Level.INFO)) {
+          logger.info(MockWebServer.this + " received request: " + request
+              + " and responded: " + response);
+        }
+
         if (response.getSocketPolicy() == SocketPolicy.DISCONNECT_AT_END) {
-          source.close();
-          sink.close();
-          // Workaround for bug on Android: closing the input/output streams should close an
-          // SSLSocket but does not. https://code.google.com/p/android/issues/detail?id=97564
           socket.close();
+          return false;
         } else if (response.getSocketPolicy() == SocketPolicy.SHUTDOWN_INPUT_AT_END) {
           socket.shutdownInput();
         } else if (response.getSocketPolicy() == SocketPolicy.SHUTDOWN_OUTPUT_AT_END) {
           socket.shutdownOutput();
         }
-        if (logger.isLoggable(Level.INFO)) {
-          logger.info(
-              MockWebServer.this + " received request: " + request + " and responded: " + response);
-        }
 
         sequenceNumber++;
-        return true;
+        return reuseSocket;
       }
     });
   }
@@ -589,10 +624,10 @@ private RecordedRequest readRequest(Socket socket, BufferedSource source, Buffer
     boolean hasBody = false;
     TruncatingBuffer requestBody = new TruncatingBuffer(bodyLimit);
     List<Integer> chunkSizes = new ArrayList<>();
-    MockResponse throttlePolicy = dispatcher.peek();
+    MockResponse policy = dispatcher.peek();
     if (contentLength != -1) {
       hasBody = contentLength > 0;
-      throttledTransfer(throttlePolicy, socket, source, Okio.buffer(requestBody), contentLength);
+      throttledTransfer(policy, socket, source, Okio.buffer(requestBody), contentLength, true);
     } else if (chunked) {
       hasBody = true;
       while (true) {
@@ -602,24 +637,14 @@ private RecordedRequest readRequest(Socket socket, BufferedSource source, Buffer
           break;
         }
         chunkSizes.add(chunkSize);
-        throttledTransfer(throttlePolicy, socket, source, Okio.buffer(requestBody), chunkSize);
+        throttledTransfer(policy, socket, source, Okio.buffer(requestBody), chunkSize, true);
         readEmptyLine(source);
       }
     }
 
-    if (request.startsWith("OPTIONS ")
-        || request.startsWith("GET ")
-        || request.startsWith("HEAD ")
-        || request.startsWith("TRACE ")
-        || request.startsWith("CONNECT ")) {
-      if (hasBody) {
-        throw new IllegalArgumentException("Request must not have a body: " + request);
-      }
-    } else if (!request.startsWith("POST ")
-        && !request.startsWith("PUT ")
-        && !request.startsWith("PATCH ")
-        && !request.startsWith("DELETE ")) { // Permitted as spec is ambiguous.
-      throw new UnsupportedOperationException("Unexpected method: " + request);
+    String method = request.substring(0, request.indexOf(' '));
+    if (hasBody && !HttpMethod.permitsRequestBody(method)) {
+      throw new IllegalArgumentException("Request must not have a body: " + request);
     }
 
     return new RecordedRequest(request, headers.build(), chunkSizes, requestBody.receivedByteCount,
@@ -636,17 +661,25 @@ private void handleWebSocketUpgrade(Socket socket, BufferedSource source, Buffer
 
     final WebSocketListener listener = response.getWebSocketListener();
     final CountDownLatch connectionClose = new CountDownLatch(1);
+
+    ThreadPoolExecutor replyExecutor =
+        new ThreadPoolExecutor(1, 1, 1, SECONDS, new LinkedBlockingDeque<Runnable>(),
+            Util.threadFactory(String.format("MockWebServer %s WebSocket", request.getPath()),
+                true));
+    replyExecutor.allowCoreThreadTimeOut(true);
     final RealWebSocket webSocket =
-        new RealWebSocket(false, source, sink, new SecureRandom(), listener,
-            request.getPath()) {
+        new RealWebSocket(false /* is server */, source, sink, new SecureRandom(), replyExecutor,
+            listener, request.getPath()) {
           @Override protected void closeConnection() throws IOException {
             connectionClose.countDown();
           }
         };
 
     // Adapt the request and response into our Request and Response domain model.
+    String scheme = request.getTlsVersion() != null ? "https" : "http";
+    String authority = request.getHeader("Host"); // Has host and port.
     final Request fancyRequest = new Request.Builder()
-        .get().url(request.getPath())
+        .url(scheme + "://" + authority + "/")
         .headers(request.getHeaders())
         .build();
     final Response fancyResponse = new Response.Builder()
@@ -657,19 +690,8 @@ private void handleWebSocketUpgrade(Socket socket, BufferedSource source, Buffer
         .protocol(Protocol.HTTP_1_1)
         .build();
 
-    // The callback might act synchronously. Give it its own thread.
-    new Thread(new Runnable() {
-      @Override public void run() {
-        try {
-          listener.onOpen(webSocket, fancyRequest, fancyResponse);
-        } catch (IOException e) {
-          // TODO try to write close frame?
-          connectionClose.countDown();
-        }
-      }
-    }, "MockWebServer WebSocket Writer " + request.getPath()).start();
+    listener.onOpen(webSocket, fancyResponse);
 
-    // Use this thread to continuously read messages.
     while (webSocket.readMessage()) {
     }
 
@@ -702,7 +724,7 @@ private void writeHttpResponse(Socket socket, BufferedSink sink, MockResponse re
     Buffer body = response.getBody();
     if (body == null) return;
     sleepIfDelayed(response);
-    throttledTransfer(response, socket, body, sink, Long.MAX_VALUE);
+    throttledTransfer(response, socket, body, sink, body.size(), false);
   }
 
   private void sleepIfDelayed(MockResponse response) {
@@ -719,19 +741,29 @@ private void sleepIfDelayed(MockResponse response) {
   /**
    * Transfer bytes from {@code source} to {@code sink} until either {@code byteCount}
    * bytes have been transferred or {@code source} is exhausted. The transfer is
-   * throttled according to {@code throttlePolicy}.
+   * throttled according to {@code policy}.
    */
-  private void throttledTransfer(MockResponse throttlePolicy, Socket socket, BufferedSource source,
-      BufferedSink sink, long byteCount) throws IOException {
+  private void throttledTransfer(MockResponse policy, Socket socket, BufferedSource source,
+      BufferedSink sink, long byteCount, boolean isRequest) throws IOException {
     if (byteCount == 0) return;
 
     Buffer buffer = new Buffer();
-    long bytesPerPeriod = throttlePolicy.getThrottleBytesPerPeriod();
-    long periodDelayMs = throttlePolicy.getThrottlePeriod(TimeUnit.MILLISECONDS);
+    long bytesPerPeriod = policy.getThrottleBytesPerPeriod();
+    long periodDelayMs = policy.getThrottlePeriod(TimeUnit.MILLISECONDS);
+
+    long halfByteCount = byteCount / 2;
+    boolean disconnectHalfway =
+        !isRequest && policy.getSocketPolicy() == DISCONNECT_DURING_RESPONSE_BODY;
 
     while (!socket.isClosed()) {
       for (int b = 0; b < bytesPerPeriod; ) {
-        long toRead = Math.min(Math.min(2048, byteCount), bytesPerPeriod - b);
+        // Ensure we do not read past the allotted bytes in this period.
+        long toRead = Math.min(byteCount, bytesPerPeriod - b);
+        // Ensure we do not read past halfway if the policy will kill the connection.
+        if (disconnectHalfway) {
+          toRead = Math.min(toRead, byteCount - halfByteCount);
+        }
+
         long read = source.read(buffer, toRead);
         if (read == -1) return;
 
@@ -740,6 +772,11 @@ private void throttledTransfer(MockResponse throttlePolicy, Socket socket, Buffe
         b += read;
         byteCount -= read;
 
+        if (disconnectHalfway && byteCount == halfByteCount) {
+          socket.close();
+          return;
+        }
+
         if (byteCount == 0) return;
       }
 
@@ -807,18 +844,18 @@ public void setDispatcher(Dispatcher dispatcher) {
     }
   }
 
-  /** Processes HTTP requests layered over SPDY/3. */
-  private class SpdySocketHandler implements IncomingStreamHandler {
+  /** Processes HTTP requests layered over framed protocols. */
+  private class FramedSocketHandler implements IncomingStreamHandler {
     private final Socket socket;
     private final Protocol protocol;
     private final AtomicInteger sequenceNumber = new AtomicInteger();
 
-    private SpdySocketHandler(Socket socket, Protocol protocol) {
+    private FramedSocketHandler(Socket socket, Protocol protocol) {
       this.socket = socket;
       this.protocol = protocol;
     }
 
-    @Override public void receive(SpdyStream stream) throws IOException {
+    @Override public void receive(FramedStream stream) throws IOException {
       RecordedRequest request = readRequest(stream);
       requestQueue.add(request);
       MockResponse response;
@@ -834,15 +871,15 @@ private SpdySocketHandler(Socket socket, Protocol protocol) {
       }
     }
 
-    private RecordedRequest readRequest(SpdyStream stream) throws IOException {
-      List<Header> spdyHeaders = stream.getRequestHeaders();
+    private RecordedRequest readRequest(FramedStream stream) throws IOException {
+      List<Header> streamHeaders = stream.getRequestHeaders();
       Headers.Builder httpHeaders = new Headers.Builder();
       String method = "<:method omitted>";
       String path = "<:path omitted>";
       String version = protocol == Protocol.SPDY_3 ? "<:version omitted>" : "HTTP/1.1";
-      for (int i = 0, size = spdyHeaders.size(); i < size; i++) {
-        ByteString name = spdyHeaders.get(i).name;
-        String value = spdyHeaders.get(i).value.utf8();
+      for (int i = 0, size = streamHeaders.size(); i < size; i++) {
+        ByteString name = streamHeaders.get(i).name;
+        String value = streamHeaders.get(i).value.utf8();
         if (name.equals(Header.TARGET_METHOD)) {
           method = value;
         } else if (name.equals(Header.TARGET_PATH)) {
@@ -864,7 +901,7 @@ private RecordedRequest readRequest(SpdyStream stream) throws IOException {
           sequenceNumber.getAndIncrement(), socket);
     }
 
-    private void writeResponse(SpdyStream stream, MockResponse response) throws IOException {
+    private void writeResponse(FramedStream stream, MockResponse response) throws IOException {
       if (response.getSocketPolicy() == SocketPolicy.NO_RESPONSE) {
         return;
       }
@@ -890,19 +927,19 @@ private void writeResponse(SpdyStream stream, MockResponse response) throws IOEx
       if (body != null) {
         BufferedSink sink = Okio.buffer(stream.getSink());
         sleepIfDelayed(response);
-        throttledTransfer(response, socket, body, sink, bodyLimit);
+        throttledTransfer(response, socket, body, sink, bodyLimit, false);
         sink.close();
       } else if (closeStreamAfterHeaders) {
         stream.close(ErrorCode.NO_ERROR);
       }
     }
 
-    private void pushPromises(SpdyStream stream, List<PushPromise> promises) throws IOException {
+    private void pushPromises(FramedStream stream, List<PushPromise> promises) throws IOException {
       for (PushPromise pushPromise : promises) {
         List<Header> pushedHeaders = new ArrayList<>();
         pushedHeaders.add(new Header(stream.getConnection().getProtocol() == Protocol.SPDY_3
             ? Header.TARGET_HOST
-            : Header.TARGET_AUTHORITY, getUrl(pushPromise.getPath()).getHost()));
+            : Header.TARGET_AUTHORITY, url(pushPromise.getPath()).host()));
         pushedHeaders.add(new Header(Header.TARGET_METHOD, pushPromise.getMethod()));
         pushedHeaders.add(new Header(Header.TARGET_PATH, pushPromise.getPath()));
         Headers pushPromiseHeaders = pushPromise.getHeaders();
@@ -914,7 +951,7 @@ private void pushPromises(SpdyStream stream, List<PushPromise> promises) throws
         requestQueue.add(new RecordedRequest(requestLine, pushPromise.getHeaders(), chunkSizes, 0,
             new Buffer(), sequenceNumber.getAndIncrement(), socket));
         boolean hasBody = pushPromise.getResponse().getBody() != null;
-        SpdyStream pushedStream =
+        FramedStream pushedStream =
             stream.getConnection().pushStream(stream.getId(), pushedHeaders, hasBody);
         writeResponse(pushedStream, pushPromise.getResponse());
       }
diff --git a/mockwebserver/src/main/java/com/squareup/okhttp/mockwebserver/SocketPolicy.java b/mockwebserver/src/main/java/com/squareup/okhttp/mockwebserver/SocketPolicy.java
index e2d5f28481..4583621471 100644
--- a/mockwebserver/src/main/java/com/squareup/okhttp/mockwebserver/SocketPolicy.java
+++ b/mockwebserver/src/main/java/com/squareup/okhttp/mockwebserver/SocketPolicy.java
@@ -50,6 +50,9 @@
    */
   DISCONNECT_AFTER_REQUEST,
 
+  /** Close connection after writing half of the response body (if present). */
+  DISCONNECT_DURING_RESPONSE_BODY,
+
   /** Don't trust the client during the SSL handshake. */
   FAIL_HANDSHAKE,
 
diff --git a/mockwebserver/src/main/java/com/squareup/okhttp/mockwebserver/rule/MockWebServerRule.java b/mockwebserver/src/main/java/com/squareup/okhttp/mockwebserver/rule/MockWebServerRule.java
deleted file mode 100644
index 01df8e219a..0000000000
--- a/mockwebserver/src/main/java/com/squareup/okhttp/mockwebserver/rule/MockWebServerRule.java
+++ /dev/null
@@ -1,87 +0,0 @@
-/*
- * Copyright (C) 2014 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.squareup.okhttp.mockwebserver.rule;
-
-import com.squareup.okhttp.mockwebserver.MockResponse;
-import com.squareup.okhttp.mockwebserver.MockWebServer;
-import com.squareup.okhttp.mockwebserver.RecordedRequest;
-import java.io.IOException;
-import java.net.URL;
-import java.util.logging.Level;
-import java.util.logging.Logger;
-import org.junit.rules.ExternalResource;
-
-/**
- * Allows you to use {@link MockWebServer} as a JUnit test rule.
- *
- * <p>This rule starts {@link MockWebServer} on an available port before your test runs, and shuts
- * it down after it completes.
- */
-public class MockWebServerRule extends ExternalResource {
-  private static final Logger logger = Logger.getLogger(MockWebServerRule.class.getName());
-
-  private final MockWebServer server = new MockWebServer();
-  private boolean started;
-
-  @Override protected void before() {
-    if (started) return;
-    started = true;
-    try {
-      server.start();
-    } catch (IOException e) {
-      throw new RuntimeException(e);
-    }
-  }
-
-  @Override protected void after() {
-    try {
-      server.shutdown();
-    } catch (IOException e) {
-      logger.log(Level.WARNING, "MockWebServer shutdown failed", e);
-    }
-  }
-
-  public String getHostName() {
-    if (!started) before();
-    return server.getHostName();
-  }
-
-  public int getPort() {
-    if (!started) before();
-    return server.getPort();
-  }
-
-  public int getRequestCount() {
-    return server.getRequestCount();
-  }
-
-  public void enqueue(MockResponse response) {
-    server.enqueue(response);
-  }
-
-  public RecordedRequest takeRequest() throws InterruptedException {
-    return server.takeRequest();
-  }
-
-  public URL getUrl(String path) {
-    return server.getUrl(path);
-  }
-
-  /** For any other functionality, use the {@linkplain MockWebServer} directly. */
-  public MockWebServer get() {
-    return server;
-  }
-}
diff --git a/mockwebserver/src/test/java/com/squareup/okhttp/mockwebserver/MockWebServerTest.java b/mockwebserver/src/test/java/com/squareup/okhttp/mockwebserver/MockWebServerTest.java
index 388dbf64f5..e729393893 100644
--- a/mockwebserver/src/test/java/com/squareup/okhttp/mockwebserver/MockWebServerTest.java
+++ b/mockwebserver/src/test/java/com/squareup/okhttp/mockwebserver/MockWebServerTest.java
@@ -16,11 +16,11 @@
 package com.squareup.okhttp.mockwebserver;
 
 import com.squareup.okhttp.Headers;
-import com.squareup.okhttp.mockwebserver.rule.MockWebServerRule;
 import java.io.BufferedReader;
 import java.io.IOException;
 import java.io.InputStream;
 import java.io.InputStreamReader;
+import java.net.ConnectException;
 import java.net.HttpURLConnection;
 import java.net.SocketTimeoutException;
 import java.net.URL;
@@ -29,17 +29,23 @@
 import java.util.Arrays;
 import java.util.List;
 import java.util.concurrent.TimeUnit;
+import java.util.concurrent.atomic.AtomicBoolean;
+import org.junit.After;
 import org.junit.Rule;
 import org.junit.Test;
+import org.junit.runner.Description;
+import org.junit.runners.model.Statement;
 
 import static java.util.concurrent.TimeUnit.NANOSECONDS;
 import static java.util.concurrent.TimeUnit.SECONDS;
 import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertNotEquals;
+import static org.junit.Assert.assertNotNull;
 import static org.junit.Assert.assertTrue;
 import static org.junit.Assert.fail;
 
 public final class MockWebServerTest {
-  @Rule public final MockWebServerRule server = new MockWebServerRule();
+  @Rule public final MockWebServer server = new MockWebServer();
 
   @Test public void defaultMockResponse() {
     MockResponse response = new MockResponse();
@@ -230,9 +236,7 @@
     assertTrue(String.format("Request + Response: %sms", elapsedMillis), elapsedMillis < 1000);
   }
 
-  /**
-   * Delay the response body by sleeping 1s.
-   */
+  /** Delay the response body by sleeping 1s. */
   @Test public void delayResponse() throws IOException {
     server.enqueue(new MockResponse()
         .setBody("ABCDEF")
@@ -242,17 +246,23 @@
     URLConnection connection = server.getUrl("/").openConnection();
     InputStream in = connection.getInputStream();
     assertEquals('A', in.read());
-    assertEquals('B', in.read());
-    assertEquals('C', in.read());
-    assertEquals('D', in.read());
-    assertEquals('E', in.read());
-    assertEquals('F', in.read());
-    assertEquals(-1, in.read());
     long elapsedNanos = System.nanoTime() - startNanos;
     long elapsedMillis = NANOSECONDS.toMillis(elapsedNanos);
-
     assertTrue(String.format("Request + Response: %sms", elapsedMillis), elapsedMillis >= 1000);
-    assertTrue(String.format("Request + Response: %sms", elapsedMillis), elapsedMillis <= 1100);
+
+    in.close();
+  }
+
+  @Test public void disconnectHalfway() throws IOException {
+    server.enqueue(new MockResponse()
+        .setBody("ab")
+        .setSocketPolicy(SocketPolicy.DISCONNECT_DURING_RESPONSE_BODY));
+
+    URLConnection connection = server.getUrl("/").openConnection();
+    assertEquals(2, connection.getHeaderFieldLong("Content-Length", -1));
+    InputStream in = connection.getInputStream();
+    assertEquals('a', in.read());
+    assertEquals(-1, in.read());
   }
 
   private List<String> headersToList(MockResponse response) {
@@ -264,4 +274,56 @@
     }
     return headerList;
   }
+
+  @Test public void shutdownWithoutStart() throws IOException {
+    MockWebServer server = new MockWebServer();
+    server.shutdown();
+  }
+
+  @Test public void shutdownWithoutEnqueue() throws IOException {
+    MockWebServer server = new MockWebServer();
+    server.start();
+    server.shutdown();
+  }
+
+  @After public void tearDown() throws IOException {
+    server.shutdown();
+  }
+
+  @Test public void portImplicitlyStarts() throws IOException {
+    assertTrue(server.getPort() > 0);
+  }
+
+  @Test public void hostNameImplicitlyStarts() throws IOException {
+    assertNotNull(server.getHostName());
+  }
+
+  @Test public void toProxyAddressImplicitlyStarts() throws IOException {
+    assertNotNull(server.toProxyAddress());
+  }
+
+  @Test public void differentInstancesGetDifferentPorts() throws IOException {
+    MockWebServer other = new MockWebServer();
+    assertNotEquals(server.getPort(), other.getPort());
+    other.shutdown();
+  }
+
+  @Test public void statementStartsAndStops() throws Throwable {
+    final AtomicBoolean called = new AtomicBoolean();
+    Statement statement = server.apply(new Statement() {
+      @Override public void evaluate() throws Throwable {
+        called.set(true);
+        server.getUrl("/").openConnection().connect();
+      }
+    }, Description.EMPTY);
+
+    statement.evaluate();
+
+    assertTrue(called.get());
+    try {
+      server.getUrl("/").openConnection().connect();
+      fail();
+    } catch (ConnectException expected) {
+    }
+  }
 }
diff --git a/mockwebserver/src/test/java/com/squareup/okhttp/mockwebserver/rule/MockWebServerRuleTest.java b/mockwebserver/src/test/java/com/squareup/okhttp/mockwebserver/rule/MockWebServerRuleTest.java
deleted file mode 100644
index 43ceebc6bb..0000000000
--- a/mockwebserver/src/test/java/com/squareup/okhttp/mockwebserver/rule/MockWebServerRuleTest.java
+++ /dev/null
@@ -1,84 +0,0 @@
-/*
- * Copyright (C) 2014 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.squareup.okhttp.mockwebserver.rule;
-
-import com.squareup.okhttp.mockwebserver.MockResponse;
-import java.io.BufferedReader;
-import java.io.IOException;
-import java.io.InputStream;
-import java.io.InputStreamReader;
-import java.net.ConnectException;
-import java.net.HttpURLConnection;
-import java.net.URL;
-import org.junit.After;
-import org.junit.Test;
-
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertNotEquals;
-import static org.junit.Assert.assertTrue;
-import static org.junit.Assert.fail;
-
-public class MockWebServerRuleTest {
-
-  private MockWebServerRule server = new MockWebServerRule();
-
-  @After public void tearDown() {
-    server.after();
-  }
-
-  @Test public void whenRuleCreatedPortIsAvailable() throws IOException {
-    assertTrue(server.getPort() > 0);
-  }
-
-  @Test public void differentRulesGetDifferentPorts() throws IOException {
-    assertNotEquals(server.getPort(), new MockWebServerRule().getPort());
-  }
-
-  @Test public void beforePlaysServer() throws Exception {
-    server.before();
-    assertEquals(server.getPort(), server.get().getPort());
-    server.getUrl("/").openConnection().connect();
-  }
-
-  @Test public void afterStopsServer() throws Exception {
-    server.before();
-    server.after();
-
-    try {
-      server.getUrl("/").openConnection().connect();
-      fail();
-    } catch (ConnectException e) {
-    }
-  }
-
-  @Test public void typicalUsage() throws Exception {
-    server.before(); // Implicitly called when @Rule.
-
-    server.enqueue(new MockResponse().setBody("hello world"));
-
-    URL url = server.getUrl("/aaa");
-    HttpURLConnection connection = (HttpURLConnection) url.openConnection();
-    InputStream in = connection.getInputStream();
-    BufferedReader reader = new BufferedReader(new InputStreamReader(in));
-    assertEquals("hello world", reader.readLine());
-
-    assertEquals(1, server.getRequestCount());
-    assertEquals("GET /aaa HTTP/1.1", server.takeRequest().getRequestLine());
-
-    server.after(); // Implicitly called when @Rule.
-  }
-}
-
diff --git a/okcurl/pom.xml b/okcurl/pom.xml
index 047983440b..e80d121eaa 100644
--- a/okcurl/pom.xml
+++ b/okcurl/pom.xml
@@ -6,7 +6,7 @@
   <parent>
     <groupId>com.squareup.okhttp</groupId>
     <artifactId>parent</artifactId>
-    <version>2.3.0-SNAPSHOT</version>
+    <version>2.6.0-SNAPSHOT</version>
   </parent>
 
   <artifactId>okcurl</artifactId>
@@ -18,6 +18,12 @@
       <artifactId>okhttp</artifactId>
       <version>${project.version}</version>
     </dependency>
+    <dependency>
+      <groupId>com.squareup.okhttp</groupId>
+      <artifactId>okhttp-testing-support</artifactId>
+      <version>${project.version}</version>
+      <scope>test</scope>
+    </dependency>
     <dependency>
       <groupId>org.bouncycastle</groupId>
       <artifactId>bcprov-jdk15on</artifactId>
diff --git a/okcurl/src/main/java/com/squareup/okhttp/curl/Main.java b/okcurl/src/main/java/com/squareup/okhttp/curl/Main.java
index e1054c9b1d..dbc51f379a 100644
--- a/okcurl/src/main/java/com/squareup/okhttp/curl/Main.java
+++ b/okcurl/src/main/java/com/squareup/okhttp/curl/Main.java
@@ -25,7 +25,7 @@
 import com.squareup.okhttp.RequestBody;
 import com.squareup.okhttp.Response;
 import com.squareup.okhttp.internal.http.StatusLine;
-import com.squareup.okhttp.internal.spdy.Http20Draft16;
+import com.squareup.okhttp.internal.framed.Http2;
 
 import io.airlift.command.Arguments;
 import io.airlift.command.Command;
@@ -49,7 +49,9 @@
 import javax.net.ssl.SSLSocketFactory;
 import javax.net.ssl.TrustManager;
 import javax.net.ssl.X509TrustManager;
+import okio.BufferedSource;
 import okio.Okio;
+import okio.Sink;
 
 import static java.util.concurrent.TimeUnit.SECONDS;
 
@@ -151,9 +153,15 @@ private static String protocols() {
         System.out.println();
       }
 
-      response.body().source().readAll(Okio.sink(System.out));
+      // Stream the response to the System.out as it is returned from the server.
+      Sink out = Okio.sink(System.out);
+      BufferedSource source = response.body().source();
+      while (!source.exhausted()) {
+        out.write(source.buffer(), source.buffer().size());
+        out.flush();
+      }
+
       response.body().close();
-      System.out.flush();
     } catch (IOException e) {
       e.printStackTrace();
     } finally {
@@ -266,7 +274,7 @@ private static HostnameVerifier createInsecureHostnameVerifier() {
   }
 
   private static void enableHttp2FrameLogging() {
-    Logger logger = Logger.getLogger(Http20Draft16.class.getName() + "$FrameLogger");
+    Logger logger = Logger.getLogger(Http2.class.getName() + "$FrameLogger");
     logger.setLevel(Level.FINE);
     ConsoleHandler handler = new ConsoleHandler();
     handler.setLevel(Level.FINE);
diff --git a/okcurl/src/test/java/com/squareup/okhttp/curl/MainTest.java b/okcurl/src/test/java/com/squareup/okhttp/curl/MainTest.java
index 0cc065c6c0..0e2e3ae1fe 100644
--- a/okcurl/src/test/java/com/squareup/okhttp/curl/MainTest.java
+++ b/okcurl/src/test/java/com/squareup/okhttp/curl/MainTest.java
@@ -29,22 +29,22 @@
   @Test public void simple() {
     Request request = fromArgs("http://example.com").createRequest();
     assertEquals("GET", request.method());
-    assertEquals("http://example.com", request.urlString());
+    assertEquals("http://example.com/", request.urlString());
     assertNull(request.body());
   }
 
   @Test public void put() throws IOException {
-    Request request = fromArgs("-X", "PUT", "http://example.com").createRequest();
+    Request request = fromArgs("-X", "PUT", "-d", "foo", "http://example.com").createRequest();
     assertEquals("PUT", request.method());
-    assertEquals("http://example.com", request.urlString());
-    assertEquals(0, request.body().contentLength());
+    assertEquals("http://example.com/", request.urlString());
+    assertEquals(3, request.body().contentLength());
   }
 
   @Test public void dataPost() {
     Request request = fromArgs("-d", "foo", "http://example.com").createRequest();
     RequestBody body = request.body();
     assertEquals("POST", request.method());
-    assertEquals("http://example.com", request.urlString());
+    assertEquals("http://example.com/", request.urlString());
     assertEquals("application/x-form-urlencoded; charset=utf-8", body.contentType().toString());
     assertEquals("foo", bodyAsString(body));
   }
@@ -53,7 +53,7 @@
     Request request = fromArgs("-d", "foo", "-X", "PUT", "http://example.com").createRequest();
     RequestBody body = request.body();
     assertEquals("PUT", request.method());
-    assertEquals("http://example.com", request.urlString());
+    assertEquals("http://example.com/", request.urlString());
     assertEquals("application/x-form-urlencoded; charset=utf-8", body.contentType().toString());
     assertEquals("foo", bodyAsString(body));
   }
@@ -63,7 +63,7 @@
         "http://example.com").createRequest();
     RequestBody body = request.body();
     assertEquals("POST", request.method());
-    assertEquals("http://example.com", request.urlString());
+    assertEquals("http://example.com/", request.urlString());
     assertEquals("application/json; charset=utf-8", body.contentType().toString());
     assertEquals("foo", bodyAsString(body));
   }
@@ -71,7 +71,7 @@
   @Test public void referer() {
     Request request = fromArgs("-e", "foo", "http://example.com").createRequest();
     assertEquals("GET", request.method());
-    assertEquals("http://example.com", request.urlString());
+    assertEquals("http://example.com/", request.urlString());
     assertEquals("foo", request.header("Referer"));
     assertNull(request.body());
   }
@@ -79,7 +79,7 @@
   @Test public void userAgent() {
     Request request = fromArgs("-A", "foo", "http://example.com").createRequest();
     assertEquals("GET", request.method());
-    assertEquals("http://example.com", request.urlString());
+    assertEquals("http://example.com/", request.urlString());
     assertEquals("foo", request.header("User-Agent"));
     assertNull(request.body());
   }
diff --git a/okhttp-android-support/pom.xml b/okhttp-android-support/pom.xml
index f00d51ad92..f514808304 100644
--- a/okhttp-android-support/pom.xml
+++ b/okhttp-android-support/pom.xml
@@ -6,7 +6,7 @@
   <parent>
     <groupId>com.squareup.okhttp</groupId>
     <artifactId>parent</artifactId>
-    <version>2.3.0-SNAPSHOT</version>
+    <version>2.6.0-SNAPSHOT</version>
   </parent>
 
   <artifactId>okhttp-android-support</artifactId>
@@ -14,6 +14,12 @@
   <description>Classes to support the Android platform's use of OkHttp (not required for most developers).</description>
 
   <dependencies>
+    <dependency>
+      <groupId>com.squareup.okhttp</groupId>
+      <artifactId>okhttp-testing-support</artifactId>
+      <version>${project.version}</version>
+      <scope>test</scope>
+    </dependency>
     <dependency>
       <groupId>com.squareup.okhttp</groupId>
       <artifactId>okhttp-urlconnection</artifactId>
diff --git a/okhttp-android-support/src/main/java/com/squareup/okhttp/AndroidShimResponseCache.java b/okhttp-android-support/src/main/java/com/squareup/okhttp/AndroidShimResponseCache.java
index 488d3d6cd2..4986c38a4b 100644
--- a/okhttp-android-support/src/main/java/com/squareup/okhttp/AndroidShimResponseCache.java
+++ b/okhttp-android-support/src/main/java/com/squareup/okhttp/AndroidShimResponseCache.java
@@ -66,7 +66,11 @@ public Cache getCache() {
   }
 
   @Override public CacheRequest put(URI uri, URLConnection urlConnection) throws IOException {
-    Response okResponse = JavaApiConverter.createOkResponse(uri, urlConnection);
+    Response okResponse = JavaApiConverter.createOkResponseForCachePut(uri, urlConnection);
+    if (okResponse == null) {
+      // The URLConnection is not cacheable or could not be converted. Stop.
+      return null;
+    }
     com.squareup.okhttp.internal.http.CacheRequest okCacheRequest =
         delegate.internalCache.put(okResponse);
     if (okCacheRequest == null) {
diff --git a/okhttp-android-support/src/main/java/com/squareup/okhttp/internal/huc/CacheAdapter.java b/okhttp-android-support/src/main/java/com/squareup/okhttp/internal/huc/CacheAdapter.java
index 13a34c032b..e13c575391 100644
--- a/okhttp-android-support/src/main/java/com/squareup/okhttp/internal/huc/CacheAdapter.java
+++ b/okhttp-android-support/src/main/java/com/squareup/okhttp/internal/huc/CacheAdapter.java
@@ -48,12 +48,12 @@ public ResponseCache getDelegate() {
     if (javaResponse == null) {
       return null;
     }
-    return JavaApiConverter.createOkResponse(request, javaResponse);
+    return JavaApiConverter.createOkResponseForCacheGet(request, javaResponse);
   }
 
   @Override public CacheRequest put(Response response) throws IOException {
     URI uri = response.request().uri();
-    HttpURLConnection connection = JavaApiConverter.createJavaUrlConnection(response);
+    HttpURLConnection connection = JavaApiConverter.createJavaUrlConnectionForCachePut(response);
     final java.net.CacheRequest request = delegate.put(uri, connection);
     if (request == null) {
       return null;
diff --git a/okhttp-android-support/src/main/java/com/squareup/okhttp/internal/huc/JavaApiConverter.java b/okhttp-android-support/src/main/java/com/squareup/okhttp/internal/huc/JavaApiConverter.java
index 603a559980..89570cc874 100644
--- a/okhttp-android-support/src/main/java/com/squareup/okhttp/internal/huc/JavaApiConverter.java
+++ b/okhttp-android-support/src/main/java/com/squareup/okhttp/internal/huc/JavaApiConverter.java
@@ -19,10 +19,13 @@
 import com.squareup.okhttp.Headers;
 import com.squareup.okhttp.MediaType;
 import com.squareup.okhttp.Request;
+import com.squareup.okhttp.RequestBody;
 import com.squareup.okhttp.Response;
 import com.squareup.okhttp.ResponseBody;
+import com.squareup.okhttp.internal.Internal;
 import com.squareup.okhttp.internal.Util;
 import com.squareup.okhttp.internal.http.CacheRequest;
+import com.squareup.okhttp.internal.http.HttpMethod;
 import com.squareup.okhttp.internal.http.OkHeaders;
 import com.squareup.okhttp.internal.http.StatusLine;
 import java.io.IOException;
@@ -39,6 +42,7 @@
 import java.util.Collections;
 import java.util.List;
 import java.util.Map;
+import java.util.Set;
 import javax.net.ssl.HostnameVerifier;
 import javax.net.ssl.HttpsURLConnection;
 import javax.net.ssl.SSLPeerUnverifiedException;
@@ -51,23 +55,42 @@
  * Helper methods that convert between Java and OkHttp representations.
  */
 public final class JavaApiConverter {
+  private static final RequestBody EMPTY_REQUEST_BODY = RequestBody.create(null, new byte[0]);
 
   private JavaApiConverter() {
   }
 
   /**
    * Creates an OkHttp {@link Response} using the supplied {@link URI} and {@link URLConnection}
-   * to supply the data. The URLConnection is assumed to already be connected.
+   * to supply the data. The URLConnection is assumed to already be connected. If this method
+   * returns {@code null} the response is uncacheable.
    */
-  public static Response createOkResponse(URI uri, URLConnection urlConnection) throws IOException {
+  public static Response createOkResponseForCachePut(URI uri, URLConnection urlConnection)
+      throws IOException {
+
     HttpURLConnection httpUrlConnection = (HttpURLConnection) urlConnection;
 
     Response.Builder okResponseBuilder = new Response.Builder();
 
     // Request: Create one from the URL connection.
-    // A connected HttpURLConnection does not permit access to request headers.
-    Map<String, List<String>> requestHeaders = null;
-    Request okRequest = createOkRequest(uri, httpUrlConnection.getRequestMethod(), requestHeaders);
+    Headers responseHeaders = createHeaders(urlConnection.getHeaderFields());
+    // Some request headers are needed for Vary caching.
+    Headers varyHeaders = varyHeaders(urlConnection, responseHeaders);
+    if (varyHeaders == null) {
+      return null;
+    }
+
+    // OkHttp's Call API requires a placeholder body; the real body will be streamed separately.
+    String requestMethod = httpUrlConnection.getRequestMethod();
+    RequestBody placeholderBody = HttpMethod.requiresRequestBody(requestMethod)
+        ? EMPTY_REQUEST_BODY
+        : null;
+
+    Request okRequest = new Request.Builder()
+        .url(uri.toString())
+        .method(requestMethod, placeholderBody)
+        .headers(varyHeaders)
+        .build();
     okResponseBuilder.request(okRequest);
 
     // Status line
@@ -76,6 +99,10 @@ public static Response createOkResponse(URI uri, URLConnection urlConnection) th
     okResponseBuilder.code(statusLine.code);
     okResponseBuilder.message(statusLine.message);
 
+    // A network response is required for the Cache to find any Vary headers it needs.
+    Response networkResponse = okResponseBuilder.build();
+    okResponseBuilder.networkResponse(networkResponse);
+
     // Response headers
     Headers okHeaders = extractOkResponseHeaders(httpUrlConnection);
     okResponseBuilder.headers(okHeaders);
@@ -106,16 +133,92 @@ public static Response createOkResponse(URI uri, URLConnection urlConnection) th
     return okResponseBuilder.build();
   }
 
+  /**
+   * Returns headers for the header names and values in the {@link Map}.
+   */
+  private static Headers createHeaders(Map<String, List<String>> headers) {
+    Headers.Builder builder = new Headers.Builder();
+    for (Map.Entry<String, List<String>> header : headers.entrySet()) {
+      if (header.getKey() == null || header.getValue() == null) {
+        continue;
+      }
+      String name = header.getKey().trim();
+      for (String value : header.getValue()) {
+        String trimmedValue = value.trim();
+        Internal.instance.addLenient(builder, name, trimmedValue);
+      }
+    }
+    return builder.build();
+  }
+
+  private static Headers varyHeaders(URLConnection urlConnection, Headers responseHeaders) {
+    if (OkHeaders.hasVaryAll(responseHeaders)) {
+      // "*" means that this will be treated as uncacheable anyway.
+      return null;
+    }
+    Set<String> varyFields = OkHeaders.varyFields(responseHeaders);
+    if (varyFields.isEmpty()) {
+      return new Headers.Builder().build();
+    }
+
+    // This probably indicates another HTTP stack is trying to use the shared ResponseCache.
+    // We cannot guarantee this case will work properly because we cannot reliably extract *all*
+    // the request header values, and we can't get multiple Vary request header values.
+    // We also can't be sure about the Accept-Encoding behavior of other stacks.
+    if (!(urlConnection instanceof CacheHttpURLConnection
+        || urlConnection instanceof CacheHttpsURLConnection)) {
+      return null;
+    }
+
+    // This is the case we expect: The URLConnection is from a call to
+    // JavaApiConverter.createJavaUrlConnection() and we have access to the user's request headers.
+    Map<String, List<String>> requestProperties = urlConnection.getRequestProperties();
+    Headers.Builder result = new Headers.Builder();
+    for (String fieldName : varyFields) {
+      List<String> fieldValues = requestProperties.get(fieldName);
+      if (fieldValues == null) {
+        if (fieldName.equals("Accept-Encoding")) {
+          // Accept-Encoding is special. If OkHttp sees Accept-Encoding is unset it will add
+          // "gzip". We don't have access to the request that was actually made so we must do the
+          // same.
+          result.add("Accept-Encoding", "gzip");
+        }
+      } else {
+        for (String fieldValue : fieldValues) {
+          Internal.instance.addLenient(result, fieldName, fieldValue);
+        }
+      }
+    }
+    return result.build();
+  }
+
   /**
    * Creates an OkHttp {@link Response} using the supplied {@link Request} and {@link CacheResponse}
    * to supply the data.
    */
-  static Response createOkResponse(Request request, CacheResponse javaResponse)
+  static Response createOkResponseForCacheGet(Request request, CacheResponse javaResponse)
       throws IOException {
+
+    // Build a cache request for the response to use.
+    Headers responseHeaders = createHeaders(javaResponse.getHeaders());
+    Headers varyHeaders;
+    if (OkHeaders.hasVaryAll(responseHeaders)) {
+      // "*" means that this will be treated as uncacheable anyway.
+      varyHeaders = new Headers.Builder().build();
+    } else {
+      varyHeaders = OkHeaders.varyHeaders(request.headers(), responseHeaders);
+    }
+
+    Request cacheRequest = new Request.Builder()
+        .url(request.httpUrl())
+        .method(request.method(), null)
+        .headers(varyHeaders)
+        .build();
+
     Response.Builder okResponseBuilder = new Response.Builder();
 
-    // Request: Use the one provided.
-    okResponseBuilder.request(request);
+    // Request: Use the cacheRequest we built.
+    okResponseBuilder.request(cacheRequest);
 
     // Status line: Java has this as one of the headers.
     StatusLine statusLine = StatusLine.parse(extractStatusLine(javaResponse));
@@ -163,10 +266,14 @@ static Response createOkResponse(Request request, CacheResponse javaResponse)
    */
   public static Request createOkRequest(
       URI uri, String requestMethod, Map<String, List<String>> requestHeaders) {
+    // OkHttp's Call API requires a placeholder body; the real body will be streamed separately.
+    RequestBody placeholderBody = HttpMethod.requiresRequestBody(requestMethod)
+        ? EMPTY_REQUEST_BODY
+        : null;
 
     Request.Builder builder = new Request.Builder()
         .url(uri.toString())
-        .method(requestMethod, null);
+        .method(requestMethod, placeholderBody);
 
     if (requestHeaders != null) {
       Headers headers = extractOkHeaders(requestHeaders);
@@ -268,7 +375,7 @@ public OutputStream getBody() throws IOException {
    * Creates an {@link java.net.HttpURLConnection} of the correct subclass from the supplied OkHttp
    * {@link Response}.
    */
-  static HttpURLConnection createJavaUrlConnection(Response okResponse) {
+  static HttpURLConnection createJavaUrlConnectionForCachePut(Response okResponse) {
     Request request = okResponse.request();
     // Create an object of the correct class in case the ResponseCache uses instanceof.
     if (request.isHttps()) {
@@ -320,7 +427,7 @@ static Headers extractOkHeaders(Map<String, List<String>> javaHeaders) {
         continue;
       }
       for (String value : javaHeader.getValue()) {
-        okHeadersBuilder.add(name, value);
+        Internal.instance.addLenient(okHeadersBuilder, name, value);
       }
     }
     return okHeadersBuilder.build();
@@ -338,8 +445,8 @@ private static String extractStatusLine(HttpURLConnection httpUrlConnection) {
 
   /**
    * Extracts the status line from the supplied Java API {@link java.net.CacheResponse}.
-   * As per the spec, the status line is held as the header with the null key. Returns {@code null}
-   * if there is no status line.
+   * As per the spec, the status line is held as the header with the null key. Throws a
+   * {@link ProtocolException} if there is no status line.
    */
   private static String extractStatusLine(CacheResponse javaResponse) throws IOException {
     Map<String, List<String>> javaResponseHeaders = javaResponse.getHeaders();
@@ -347,10 +454,14 @@ private static String extractStatusLine(CacheResponse javaResponse) throws IOExc
   }
 
   // VisibleForTesting
-  static String extractStatusLine(Map<String, List<String>> javaResponseHeaders) {
+  static String extractStatusLine(Map<String, List<String>> javaResponseHeaders)
+      throws ProtocolException {
     List<String> values = javaResponseHeaders.get(null);
     if (values == null || values.size() == 0) {
-      return null;
+      // The status line is missing. This suggests a badly behaving cache.
+      throw new ProtocolException(
+          "CacheResponse is missing a \'null\' header containing the status line. Headers="
+          + javaResponseHeaders);
     }
     return values.get(0);
   }
@@ -471,9 +582,11 @@ public String getRequestProperty(String key) {
 
     @Override
     public Map<String, List<String>> getRequestProperties() {
-      // This is to preserve RI and compatibility with OkHttp's HttpURLConnectionImpl. There seems
-      // no good reason why this should fail while getRequestProperty() is ok.
-      throw throwRequestHeaderAccessException();
+      // The RI and OkHttp's HttpURLConnectionImpl fail this call after connect() as required by the
+      // spec. There seems no good reason why this should fail while getRequestProperty() is ok.
+      // We don't fail here, because we need all request header values for caching Vary responses
+      // correctly.
+      return OkHeaders.toMultimap(request.headers(), null);
     }
 
     @Override
diff --git a/okhttp-android-support/src/test/java/com/squareup/okhttp/android/HttpResponseCacheTest.java b/okhttp-android-support/src/test/java/com/squareup/okhttp/android/HttpResponseCacheTest.java
index c349790453..851501750b 100644
--- a/okhttp-android-support/src/test/java/com/squareup/okhttp/android/HttpResponseCacheTest.java
+++ b/okhttp-android-support/src/test/java/com/squareup/okhttp/android/HttpResponseCacheTest.java
@@ -17,28 +17,25 @@
 package com.squareup.okhttp.android;
 
 import com.squareup.okhttp.AndroidInternal;
+import com.squareup.okhttp.HttpUrl;
 import com.squareup.okhttp.OkHttpClient;
 import com.squareup.okhttp.OkUrlFactory;
 import com.squareup.okhttp.mockwebserver.MockResponse;
 import com.squareup.okhttp.mockwebserver.MockWebServer;
-import com.squareup.okhttp.mockwebserver.rule.MockWebServerRule;
-
-import org.junit.After;
-import org.junit.Before;
-import org.junit.Rule;
-import org.junit.Test;
-import org.junit.rules.TemporaryFolder;
-
 import java.io.File;
 import java.io.InputStream;
 import java.net.CacheRequest;
 import java.net.CacheResponse;
 import java.net.ResponseCache;
 import java.net.URI;
-import java.net.URL;
 import java.net.URLConnection;
 import java.util.List;
 import java.util.Map;
+import org.junit.After;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.rules.TemporaryFolder;
 
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertNotNull;
@@ -53,14 +50,12 @@
 public final class HttpResponseCacheTest {
 
   @Rule public TemporaryFolder cacheRule = new TemporaryFolder();
-  @Rule public MockWebServerRule serverRule = new MockWebServerRule();
+  @Rule public MockWebServer server = new MockWebServer();
 
   private File cacheDir;
-  private MockWebServer server;
   private OkUrlFactory client;
 
   @Before public void setUp() throws Exception {
-    server = serverRule.get();
     cacheDir = cacheRule.getRoot();
     client = new OkUrlFactory(new OkHttpClient());
   }
@@ -148,7 +143,7 @@ public CacheRequest put(URI uri, URLConnection connection) {
         .addHeader("Cache-Control: max-age=60")
         .setBody("A"));
 
-    URLConnection c1 = openUrl(server.getUrl("/"));
+    URLConnection c1 = openUrl(server.url("/"));
 
     InputStream inputStream = c1.getInputStream();
     assertEquals('A', inputStream.read());
@@ -157,10 +152,10 @@ public CacheRequest put(URI uri, URLConnection connection) {
     assertEquals(1, cache.getNetworkCount());
     assertEquals(0, cache.getHitCount());
 
-    URLConnection c2 = openUrl(server.getUrl("/"));
+    URLConnection c2 = openUrl(server.url("/"));
     assertEquals('A', c2.getInputStream().read());
 
-    URLConnection c3 = openUrl(server.getUrl("/"));
+    URLConnection c3 = openUrl(server.url("/"));
     assertEquals('A', c3.getInputStream().read());
     assertEquals(3, cache.getRequestCount());
     assertEquals(1, cache.getNetworkCount());
@@ -168,10 +163,10 @@ public CacheRequest put(URI uri, URLConnection connection) {
   }
 
   // This mimics the Android HttpHandler, which is found in the com.squareup.okhttp package.
-  private URLConnection openUrl(URL url) {
+  private URLConnection openUrl(HttpUrl url) {
     ResponseCache responseCache = ResponseCache.getDefault();
     AndroidInternal.setResponseCache(client, responseCache);
-    return client.open(url);
+    return client.open(url.url());
   }
 
   private void initializeCache(HttpResponseCache cache) {
diff --git a/okhttp-android-support/src/test/java/com/squareup/okhttp/internal/huc/CacheAdapterTest.java b/okhttp-android-support/src/test/java/com/squareup/okhttp/internal/huc/CacheAdapterTest.java
index 4cca79e5e3..97593d5779 100644
--- a/okhttp-android-support/src/test/java/com/squareup/okhttp/internal/huc/CacheAdapterTest.java
+++ b/okhttp-android-support/src/test/java/com/squareup/okhttp/internal/huc/CacheAdapterTest.java
@@ -22,6 +22,7 @@
 import com.squareup.okhttp.internal.SslContextBuilder;
 import com.squareup.okhttp.mockwebserver.MockResponse;
 import com.squareup.okhttp.mockwebserver.MockWebServer;
+import com.squareup.okhttp.testing.RecordingHostnameVerifier;
 import java.io.IOException;
 import java.net.CacheRequest;
 import java.net.CacheResponse;
@@ -37,13 +38,11 @@
 import javax.net.ssl.HostnameVerifier;
 import javax.net.ssl.HttpsURLConnection;
 import javax.net.ssl.SSLContext;
-import javax.net.ssl.SSLSession;
+import okio.Buffer;
 import org.junit.After;
 import org.junit.Before;
 import org.junit.Test;
 
-import okio.Buffer;
-
 import static org.junit.Assert.assertArrayEquals;
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertFalse;
@@ -59,17 +58,10 @@
  * </ul>
  */
 public class CacheAdapterTest {
-  private static final SSLContext sslContext = SslContextBuilder.localhost();
-  private static final HostnameVerifier NULL_HOSTNAME_VERIFIER = new HostnameVerifier() {
-    public boolean verify(String hostname, SSLSession session) {
-      return true;
-    }
-  };
-
+  private SSLContext sslContext = SslContextBuilder.localhost();
+  private HostnameVerifier hostnameVerifier = new RecordingHostnameVerifier();
   private MockWebServer server;
-
   private OkHttpClient client;
-
   private HttpURLConnection connection;
 
   @Before public void setUp() throws Exception {
@@ -123,7 +115,7 @@ public CacheResponse get(URI uri, String method, Map<String, List<String>> heade
     };
     Internal.instance.setCache(client, new CacheAdapter(responseCache));
     client.setSslSocketFactory(sslContext.getSocketFactory());
-    client.setHostnameVerifier(NULL_HOSTNAME_VERIFIER);
+    client.setHostnameVerifier(hostnameVerifier);
 
     connection = new OkUrlFactory(client).open(serverUrl);
     connection.setRequestProperty("key1", "value1");
@@ -238,7 +230,7 @@ public CacheResponse get(URI uri, String method, Map<String, List<String>> heade
     };
     Internal.instance.setCache(client, new CacheAdapter(responseCache));
     client.setSslSocketFactory(sslContext.getSocketFactory());
-    client.setHostnameVerifier(NULL_HOSTNAME_VERIFIER);
+    client.setHostnameVerifier(hostnameVerifier);
 
     connection = new OkUrlFactory(client).open(serverUrl);
     executeGet(connection);
diff --git a/okhttp-android-support/src/test/java/com/squareup/okhttp/internal/huc/JavaApiConverterTest.java b/okhttp-android-support/src/test/java/com/squareup/okhttp/internal/huc/JavaApiConverterTest.java
index d5dfcd8557..7255372bbe 100644
--- a/okhttp-android-support/src/test/java/com/squareup/okhttp/internal/huc/JavaApiConverterTest.java
+++ b/okhttp-android-support/src/test/java/com/squareup/okhttp/internal/huc/JavaApiConverterTest.java
@@ -18,17 +18,14 @@
 import com.squareup.okhttp.Handshake;
 import com.squareup.okhttp.Headers;
 import com.squareup.okhttp.MediaType;
-import com.squareup.okhttp.OkHttpClient;
-import com.squareup.okhttp.OkUrlFactory;
 import com.squareup.okhttp.Protocol;
 import com.squareup.okhttp.Request;
 import com.squareup.okhttp.RequestBody;
 import com.squareup.okhttp.Response;
 import com.squareup.okhttp.ResponseBody;
-import com.squareup.okhttp.internal.SslContextBuilder;
+import com.squareup.okhttp.internal.Internal;
 import com.squareup.okhttp.internal.Util;
-import com.squareup.okhttp.mockwebserver.MockResponse;
-import com.squareup.okhttp.mockwebserver.rule.MockWebServerRule;
+import com.squareup.okhttp.mockwebserver.MockWebServer;
 import java.io.ByteArrayInputStream;
 import java.io.ByteArrayOutputStream;
 import java.io.IOException;
@@ -37,7 +34,6 @@
 import java.net.HttpURLConnection;
 import java.net.SecureCacheResponse;
 import java.net.URI;
-import java.net.URL;
 import java.nio.charset.StandardCharsets;
 import java.security.Principal;
 import java.security.cert.Certificate;
@@ -51,14 +47,10 @@
 import java.util.List;
 import java.util.Map;
 import java.util.Set;
-import javax.net.ssl.HostnameVerifier;
 import javax.net.ssl.HttpsURLConnection;
-import javax.net.ssl.SSLContext;
 import javax.net.ssl.SSLPeerUnverifiedException;
-import javax.net.ssl.SSLSession;
 import okio.Buffer;
 import okio.BufferedSource;
-import org.junit.After;
 import org.junit.Before;
 import org.junit.Rule;
 import org.junit.Test;
@@ -68,7 +60,6 @@
 import static org.junit.Assert.assertFalse;
 import static org.junit.Assert.assertNotNull;
 import static org.junit.Assert.assertNull;
-import static org.junit.Assert.assertSame;
 import static org.junit.Assert.assertTrue;
 import static org.junit.Assert.fail;
 
@@ -102,109 +93,13 @@
       + "fl2WRY8hb4x+zRrwsFaLEpdEvqcjOQ==\n"
       + "-----END CERTIFICATE-----");
 
-  private static final SSLContext sslContext = SslContextBuilder.localhost();
-  private static final HostnameVerifier NULL_HOSTNAME_VERIFIER = new HostnameVerifier() {
-    public boolean verify(String hostname, SSLSession session) {
-      return true;
-    }
-  };
-
-  @Rule public MockWebServerRule server = new MockWebServerRule();
-
-  private OkHttpClient client;
-
-  private HttpURLConnection connection;
+  @Rule public MockWebServer server = new MockWebServer();
 
   @Before public void setUp() throws Exception {
-    client = new OkHttpClient();
-  }
-
-  @After public void tearDown() throws Exception {
-    if (connection != null) {
-      connection.disconnect();
-    }
-  }
-
-  @Test public void createOkResponse_fromOkHttpUrlConnection() throws Exception {
-    testCreateOkResponseInternal(new OkHttpURLConnectionFactory(client), false /* isSecure */);
+    Internal.initializeInstanceForTests();
   }
 
-  @Test public void createOkResponse_fromJavaHttpUrlConnection() throws Exception {
-    testCreateOkResponseInternal(new JavaHttpURLConnectionFactory(), false /* isSecure */);
-  }
-
-  @Test public void createOkResponse_fromOkHttpsUrlConnection() throws Exception {
-    testCreateOkResponseInternal(new OkHttpURLConnectionFactory(client), true /* isSecure */);
-  }
-
-  @Test public void createOkResponse_fromJavaHttpsUrlConnection() throws Exception {
-    testCreateOkResponseInternal(new JavaHttpURLConnectionFactory(), true /* isSecure */);
-  }
-
-  private void testCreateOkResponseInternal(HttpURLConnectionFactory httpUrlConnectionFactory,
-      boolean isSecure) throws Exception {
-    String statusLine = "HTTP/1.1 200 Fantastic";
-    String body = "Nothing happens";
-    final URL serverUrl;
-    MockResponse mockResponse = new MockResponse()
-        .setStatus(statusLine)
-        .addHeader("xyzzy", "baz")
-        .setBody(body);
-    if (isSecure) {
-      serverUrl = configureHttpsServer(
-          mockResponse);
-
-      assertEquals("https", serverUrl.getProtocol());
-    } else {
-      serverUrl = configureServer(
-          mockResponse);
-      assertEquals("http", serverUrl.getProtocol());
-    }
-
-    connection = httpUrlConnectionFactory.open(serverUrl);
-    if (isSecure) {
-      HttpsURLConnection httpsUrlConnection = (HttpsURLConnection) connection;
-      httpsUrlConnection.setSSLSocketFactory(sslContext.getSocketFactory());
-      httpsUrlConnection.setHostnameVerifier(NULL_HOSTNAME_VERIFIER);
-    }
-    connection.setRequestProperty("snake", "bird");
-    connection.connect();
-    Response response = JavaApiConverter.createOkResponse(serverUrl.toURI(), connection);
-
-    // Check the response.request()
-    Request request = response.request();
-    assertEquals(isSecure, request.isHttps());
-    assertEquals(serverUrl.toURI(), request.uri());
-    assertNull(request.body());
-    Headers okRequestHeaders = request.headers();
-    // In Java the request headers are unavailable for a connected HttpURLConnection.
-    assertEquals(0, okRequestHeaders.size());
-    assertEquals("GET", request.method());
-
-    // Check the response
-    assertEquals(Protocol.HTTP_1_1, response.protocol());
-    assertEquals(200, response.code());
-    assertEquals("Fantastic", response.message());
-    Headers okResponseHeaders = response.headers();
-    assertEquals("baz", okResponseHeaders.get("xyzzy"));
-    if (isSecure) {
-      Handshake handshake = response.handshake();
-      assertNotNull(handshake);
-      HttpsURLConnection httpsURLConnection = (HttpsURLConnection) connection;
-      assertNotNullAndEquals(httpsURLConnection.getCipherSuite(), handshake.cipherSuite());
-      assertEquals(httpsURLConnection.getLocalPrincipal(), handshake.localPrincipal());
-      assertNotNullAndEquals(httpsURLConnection.getPeerPrincipal(), handshake.peerPrincipal());
-      assertNotNull(httpsURLConnection.getServerCertificates());
-      assertEquals(Arrays.asList(httpsURLConnection.getServerCertificates()),
-          handshake.peerCertificates());
-      assertNull(httpsURLConnection.getLocalCertificates());
-    } else {
-      assertNull(response.handshake());
-    }
-    assertEquals(body, response.body().string());
-  }
-
-  @Test public void createOkResponse_fromCacheResponse() throws Exception {
+  @Test public void createOkResponseForCacheGet() throws Exception {
     final String statusLine = "HTTP/1.1 200 Fantastic";
     URI uri = new URI("http://foo/bar");
     Request request = new Request.Builder().url(uri.toURL()).build();
@@ -221,8 +116,11 @@ private void testCreateOkResponseInternal(HttpURLConnectionFactory httpUrlConnec
       }
     };
 
-    Response response = JavaApiConverter.createOkResponse(request, cacheResponse);
-    assertSame(request, response.request());
+    Response response = JavaApiConverter.createOkResponseForCacheGet(request, cacheResponse);
+    Request cacheRequest = response.request();
+    assertEquals(request.httpUrl(), cacheRequest.httpUrl());
+    assertEquals(request.method(), cacheRequest.method());
+    assertEquals(0, request.headers().size());
 
     assertEquals(Protocol.HTTP_1_1, response.protocol());
     assertEquals(200, response.code());
@@ -233,7 +131,31 @@ private void testCreateOkResponseInternal(HttpURLConnectionFactory httpUrlConnec
     assertNull(response.handshake());
   }
 
-  @Test public void createOkResponse_fromSecureCacheResponse() throws Exception {
+  /** Test for https://code.google.com/p/android/issues/detail?id=160522 */
+  @Test public void createOkResponseForCacheGet_withMissingStatusLine() throws Exception {
+    URI uri = new URI("http://foo/bar");
+    Request request = new Request.Builder().url(uri.toURL()).build();
+    CacheResponse cacheResponse = new CacheResponse() {
+      @Override public Map<String, List<String>> getHeaders() throws IOException {
+        Map<String, List<String>> headers = new HashMap<>();
+        // Headers is deliberately missing an entry with a null key.
+        headers.put("xyzzy", Arrays.asList("bar", "baz"));
+        return headers;
+      }
+
+      @Override public InputStream getBody() throws IOException {
+        return null; // Should never be called
+      }
+    };
+
+    try {
+      JavaApiConverter.createOkResponseForCacheGet(request, cacheResponse);
+      fail();
+    } catch (IOException expected) {
+    }
+  }
+
+  @Test public void createOkResponseForCacheGet_secure() throws Exception {
     final String statusLine = "HTTP/1.1 200 Fantastic";
     final Principal localPrincipal = LOCAL_CERT.getSubjectX500Principal();
     final List<Certificate> localCertificates = Arrays.<Certificate>asList(LOCAL_CERT);
@@ -274,8 +196,11 @@ private void testCreateOkResponseInternal(HttpURLConnectionFactory httpUrlConnec
       }
     };
 
-    Response response = JavaApiConverter.createOkResponse(request, cacheResponse);
-    assertSame(request, response.request());
+    Response response = JavaApiConverter.createOkResponseForCacheGet(request, cacheResponse);
+    Request cacheRequest = response.request();
+    assertEquals(request.httpUrl(), cacheRequest.httpUrl());
+    assertEquals(request.method(), cacheRequest.method());
+    assertEquals(0, request.headers().size());
 
     assertEquals(Protocol.HTTP_1_1, response.protocol());
     assertEquals(200, response.code());
@@ -340,7 +265,8 @@ private void testCreateOkResponseInternal(HttpURLConnectionFactory httpUrlConnec
 
   @Test public void createJavaUrlConnection_requestChangesForbidden() throws Exception {
     Response okResponse = createArbitraryOkResponse();
-    HttpURLConnection httpUrlConnection = JavaApiConverter.createJavaUrlConnection(okResponse);
+    HttpURLConnection httpUrlConnection =
+        JavaApiConverter.createJavaUrlConnectionForCachePut(okResponse);
     // Check an arbitrary (not complete) set of methods that can be used to modify the
     // request.
     try {
@@ -372,7 +298,8 @@ private void testCreateOkResponseInternal(HttpURLConnectionFactory httpUrlConnec
 
   @Test public void createJavaUrlConnection_connectionChangesForbidden() throws Exception {
     Response okResponse = createArbitraryOkResponse();
-    HttpURLConnection httpUrlConnection = JavaApiConverter.createJavaUrlConnection(okResponse);
+    HttpURLConnection httpUrlConnection =
+        JavaApiConverter.createJavaUrlConnectionForCachePut(okResponse);
     try {
       httpUrlConnection.connect();
       fail();
@@ -387,7 +314,8 @@ private void testCreateOkResponseInternal(HttpURLConnectionFactory httpUrlConnec
 
   @Test public void createJavaUrlConnection_responseChangesForbidden() throws Exception {
     Response okResponse = createArbitraryOkResponse();
-    HttpURLConnection httpUrlConnection = JavaApiConverter.createJavaUrlConnection(okResponse);
+    HttpURLConnection httpUrlConnection =
+        JavaApiConverter.createJavaUrlConnectionForCachePut(okResponse);
     // Check an arbitrary (not complete) set of methods that can be used to access the response
     // body.
     try {
@@ -431,7 +359,8 @@ private void testCreateOkResponseInternal(HttpURLConnectionFactory httpUrlConnec
         .body(responseBody)
         .build();
 
-    HttpURLConnection httpUrlConnection = JavaApiConverter.createJavaUrlConnection(okResponse);
+    HttpURLConnection httpUrlConnection =
+        JavaApiConverter.createJavaUrlConnectionForCachePut(okResponse);
     assertEquals(200, httpUrlConnection.getResponseCode());
     assertEquals("Fantastic", httpUrlConnection.getResponseMessage());
     assertEquals(responseBody.contentLength(), httpUrlConnection.getContentLength());
@@ -506,7 +435,8 @@ private void assertHeadersContainsMapping(Map<String, List<String>> headers, Str
         .get()
         .build();
     Response okResponse = createArbitraryOkResponse(okRequest);
-    HttpURLConnection httpUrlConnection = JavaApiConverter.createJavaUrlConnection(okResponse);
+    HttpURLConnection httpUrlConnection =
+        JavaApiConverter.createJavaUrlConnectionForCachePut(okResponse);
 
     assertEquals("GET", httpUrlConnection.getRequestMethod());
     assertTrue(httpUrlConnection.getDoInput());
@@ -518,7 +448,8 @@ private void assertHeadersContainsMapping(Map<String, List<String>> headers, Str
         .post(createRequestBody("PostBody"))
         .build();
     Response okResponse = createArbitraryOkResponse(okRequest);
-    HttpURLConnection httpUrlConnection = JavaApiConverter.createJavaUrlConnection(okResponse);
+    HttpURLConnection httpUrlConnection =
+        JavaApiConverter.createJavaUrlConnectionForCachePut(okResponse);
 
     assertEquals("POST", httpUrlConnection.getRequestMethod());
     assertTrue(httpUrlConnection.getDoInput());
@@ -536,7 +467,7 @@ private void assertHeadersContainsMapping(Map<String, List<String>> headers, Str
         .handshake(handshake)
         .build();
     HttpsURLConnection httpsUrlConnection =
-        (HttpsURLConnection) JavaApiConverter.createJavaUrlConnection(okResponse);
+        (HttpsURLConnection) JavaApiConverter.createJavaUrlConnectionForCachePut(okResponse);
 
     assertEquals("SecureCipher", httpsUrlConnection.getCipherSuite());
     assertEquals(SERVER_CERT.getSubjectX500Principal(), httpsUrlConnection.getPeerPrincipal());
@@ -552,7 +483,7 @@ private void assertHeadersContainsMapping(Map<String, List<String>> headers, Str
         .build();
     Response okResponse = createArbitraryOkResponse(okRequest);
     HttpsURLConnection httpsUrlConnection =
-        (HttpsURLConnection) JavaApiConverter.createJavaUrlConnection(okResponse);
+        (HttpsURLConnection) JavaApiConverter.createJavaUrlConnectionForCachePut(okResponse);
 
     try {
       httpsUrlConnection.getHostnameVerifier();
@@ -669,26 +600,18 @@ private void assertHeadersContainsMapping(Map<String, List<String>> headers, Str
     assertEquals(Arrays.asList("value2"), okHeaders.values("key2"));
   }
 
-  @Test public void extractStatusLine() {
+  @Test public void extractStatusLine() throws Exception {
     Map<String, List<String>> javaResponseHeaders = new HashMap<>();
     javaResponseHeaders.put(null, Arrays.asList("StatusLine"));
     javaResponseHeaders.put("key1", Arrays.asList("value1_1", "value1_2"));
     javaResponseHeaders.put("key2", Arrays.asList("value2"));
     assertEquals("StatusLine", JavaApiConverter.extractStatusLine(javaResponseHeaders));
 
-    assertNull(
-        JavaApiConverter.extractStatusLine(Collections.<String, List<String>>emptyMap()));
-  }
-
-  private URL configureServer(MockResponse mockResponse) throws Exception {
-    server.enqueue(mockResponse);
-    return server.getUrl("/");
-  }
-
-  private URL configureHttpsServer(MockResponse mockResponse) throws Exception {
-    server.get().useHttps(sslContext.getSocketFactory(), false /* tunnelProxy */);
-    server.enqueue(mockResponse);
-    return server.getUrl("/");
+    try {
+      JavaApiConverter.extractStatusLine(Collections.<String, List<String>>emptyMap());
+      fail();
+    } catch (IOException expected) {
+    }
   }
 
   private static <T> void assertNotNullAndEquals(T expected, T actual) {
@@ -696,28 +619,6 @@ private URL configureHttpsServer(MockResponse mockResponse) throws Exception {
     assertEquals(expected, actual);
   }
 
-  private interface HttpURLConnectionFactory {
-    public HttpURLConnection open(URL serverUrl) throws IOException;
-  }
-
-  private static class OkHttpURLConnectionFactory implements HttpURLConnectionFactory {
-    protected final OkHttpClient client;
-
-    private OkHttpURLConnectionFactory(OkHttpClient client) {
-      this.client = client;
-    }
-
-    @Override public HttpURLConnection open(URL serverUrl) {
-      return new OkUrlFactory(client).open(serverUrl);
-    }
-  }
-
-  private static class JavaHttpURLConnectionFactory implements HttpURLConnectionFactory {
-    @Override public HttpURLConnection open(URL serverUrl) throws IOException {
-      return (HttpURLConnection) serverUrl.openConnection();
-    }
-  }
-
   private static X509Certificate certificate(String certificate) {
     try {
       return (X509Certificate) CertificateFactory.getInstance("X.509").generateCertificate(
@@ -728,6 +629,7 @@ private static X509Certificate certificate(String certificate) {
     }
   }
 
+  @SafeVarargs
   private static <T> Set<T> newSet(T... elements) {
     return newSet(Arrays.asList(elements));
   }
diff --git a/okhttp-android-support/src/test/java/com/squareup/okhttp/internal/huc/ResponseCacheTest.java b/okhttp-android-support/src/test/java/com/squareup/okhttp/internal/huc/ResponseCacheTest.java
index 5fdb2fcaea..1dbf78fc83 100644
--- a/okhttp-android-support/src/test/java/com/squareup/okhttp/internal/huc/ResponseCacheTest.java
+++ b/okhttp-android-support/src/test/java/com/squareup/okhttp/internal/huc/ResponseCacheTest.java
@@ -17,19 +17,19 @@
 package com.squareup.okhttp.internal.huc;
 
 import com.squareup.okhttp.AbstractResponseCache;
+import com.squareup.okhttp.AndroidInternal;
+import com.squareup.okhttp.AndroidShimResponseCache;
 import com.squareup.okhttp.Headers;
 import com.squareup.okhttp.OkHttpClient;
 import com.squareup.okhttp.OkUrlFactory;
 import com.squareup.okhttp.internal.Internal;
 import com.squareup.okhttp.internal.SslContextBuilder;
-import com.squareup.okhttp.internal.http.HttpDate;
 import com.squareup.okhttp.mockwebserver.MockResponse;
 import com.squareup.okhttp.mockwebserver.MockWebServer;
 import com.squareup.okhttp.mockwebserver.RecordedRequest;
-import com.squareup.okhttp.mockwebserver.rule.MockWebServerRule;
+import com.squareup.okhttp.testing.RecordingHostnameVerifier;
 import java.io.BufferedReader;
 import java.io.ByteArrayInputStream;
-import java.io.ByteArrayOutputStream;
 import java.io.FileNotFoundException;
 import java.io.IOException;
 import java.io.InputStream;
@@ -40,20 +40,26 @@
 import java.net.CookieManager;
 import java.net.HttpCookie;
 import java.net.HttpURLConnection;
+import java.net.ProtocolException;
 import java.net.ResponseCache;
 import java.net.SecureCacheResponse;
 import java.net.URI;
 import java.net.URISyntaxException;
 import java.net.URL;
 import java.net.URLConnection;
+import java.nio.charset.StandardCharsets;
 import java.security.Principal;
 import java.security.cert.Certificate;
+import java.text.DateFormat;
+import java.text.SimpleDateFormat;
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.Date;
 import java.util.HashMap;
 import java.util.List;
+import java.util.Locale;
 import java.util.Map;
+import java.util.TimeZone;
 import java.util.concurrent.TimeUnit;
 import java.util.concurrent.atomic.AtomicBoolean;
 import java.util.concurrent.atomic.AtomicInteger;
@@ -61,8 +67,6 @@
 import javax.net.ssl.HostnameVerifier;
 import javax.net.ssl.HttpsURLConnection;
 import javax.net.ssl.SSLContext;
-import javax.net.ssl.SSLPeerUnverifiedException;
-import javax.net.ssl.SSLSession;
 import okio.Buffer;
 import okio.BufferedSink;
 import okio.GzipSink;
@@ -71,52 +75,142 @@
 import org.junit.Before;
 import org.junit.Rule;
 import org.junit.Test;
+import org.junit.rules.TemporaryFolder;
 
 import static com.squareup.okhttp.mockwebserver.SocketPolicy.DISCONNECT_AT_END;
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertFalse;
 import static org.junit.Assert.assertNotNull;
 import static org.junit.Assert.assertNull;
-import static org.junit.Assert.assertSame;
 import static org.junit.Assert.assertTrue;
 import static org.junit.Assert.fail;
 
-/** Tests the interaction between OkHttp and {@link ResponseCache}. */
+/**
+ * Tests the interaction between OkHttp and {@link ResponseCache}.
+ * Based on com.squareup.okhttp.CacheTest with changes for ResponseCache and HttpURLConnection.
+ */
 public final class ResponseCacheTest {
-  private static final HostnameVerifier NULL_HOSTNAME_VERIFIER = new HostnameVerifier() {
-    @Override public boolean verify(String s, SSLSession sslSession) {
-      return true;
-    }
-  };
-
-  private static final SSLContext sslContext = SslContextBuilder.localhost();
-
-  @Rule public MockWebServerRule serverRule = new MockWebServerRule();
-  @Rule public MockWebServerRule server2Rule = new MockWebServerRule();
+  @Rule public TemporaryFolder cacheRule = new TemporaryFolder();
+  @Rule public MockWebServer server = new MockWebServer();
+  @Rule public MockWebServer server2 = new MockWebServer();
 
+  private HostnameVerifier hostnameVerifier = new RecordingHostnameVerifier();
+  private SSLContext sslContext = SslContextBuilder.localhost();
   private OkHttpClient client;
-  private MockWebServer server;
-  private MockWebServer server2;
   private ResponseCache cache;
+  private CookieManager cookieManager;
 
   @Before public void setUp() throws Exception {
-    server = serverRule.get();
     server.setProtocolNegotiationEnabled(false);
-    server2 = server2Rule.get();
 
     client = new OkHttpClient();
-    cache = new InMemoryResponseCache();
-    Internal.instance.setCache(client, new CacheAdapter(cache));
+
+    cache = AndroidShimResponseCache.create(cacheRule.getRoot(), 10 * 1024 * 1024);
+    AndroidInternal.setResponseCache(new OkUrlFactory(client), cache);
+
+    cookieManager = new CookieManager();
+    CookieManager.setDefault(cookieManager);
   }
 
   @After public void tearDown() throws Exception {
     CookieManager.setDefault(null);
+    ResponseCache.setDefault(null);
   }
 
   private HttpURLConnection openConnection(URL url) {
     return new OkUrlFactory(client).open(url);
   }
 
+  /**
+   * Test that response caching is consistent with the RI and the spec.
+   * http://www.w3.org/Protocols/rfc2616/rfc2616-sec13.html#sec13.4
+   */
+  @Test public void responseCachingByResponseCode() throws Exception {
+    // Test each documented HTTP/1.1 code, plus the first unused value in each range.
+    // http://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html
+
+    // We can't test 100 because it's not really a response.
+    // assertCached(false, 100);
+    assertCached(false, 101);
+    assertCached(false, 102);
+    assertCached(true,  200);
+    assertCached(false, 201);
+    assertCached(false, 202);
+    assertCached(true,  203);
+    assertCached(true,  204);
+    assertCached(false, 205);
+    assertCached(false, 206); //Electing to not cache partial responses
+    assertCached(false, 207);
+    assertCached(true,  300);
+    assertCached(true,  301);
+    assertCached(true,  302);
+    assertCached(false, 303);
+    assertCached(false, 304);
+    assertCached(false, 305);
+    assertCached(false, 306);
+    assertCached(true,  307);
+    assertCached(true,  308);
+    assertCached(false, 400);
+    assertCached(false, 401);
+    assertCached(false, 402);
+    assertCached(false, 403);
+    assertCached(true,  404);
+    assertCached(true,  405);
+    assertCached(false, 406);
+    assertCached(false, 408);
+    assertCached(false, 409);
+    // the HTTP spec permits caching 410s, but the RI doesn't.
+    assertCached(true,  410);
+    assertCached(false, 411);
+    assertCached(false, 412);
+    assertCached(false, 413);
+    assertCached(true,  414);
+    assertCached(false, 415);
+    assertCached(false, 416);
+    assertCached(false, 417);
+    assertCached(false, 418);
+
+    assertCached(false, 500);
+    assertCached(true,  501);
+    assertCached(false, 502);
+    assertCached(false, 503);
+    assertCached(false, 504);
+    assertCached(false, 505);
+    assertCached(false, 506);
+  }
+
+  private void assertCached(boolean shouldPut, int responseCode) throws Exception {
+    server = new MockWebServer();
+    MockResponse mockResponse = new MockResponse()
+        .addHeader("Last-Modified: " + formatDate(-1, TimeUnit.HOURS))
+        .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS))
+        .setResponseCode(responseCode)
+        .setBody("ABCDE")
+        .addHeader("WWW-Authenticate: challenge");
+    if (responseCode == HttpURLConnection.HTTP_PROXY_AUTH) {
+      mockResponse.addHeader("Proxy-Authenticate: Basic realm=\"protected area\"");
+    } else if (responseCode == HttpURLConnection.HTTP_UNAUTHORIZED) {
+      mockResponse.addHeader("WWW-Authenticate: Basic realm=\"protected area\"");
+    }
+    server.enqueue(mockResponse);
+    server.start();
+
+    URL url = server.getUrl("/");
+    HttpURLConnection connection = openConnection(url);
+    assertEquals(responseCode, connection.getResponseCode());
+
+    // Exhaust the content stream.
+    readAscii(connection);
+
+    CacheResponse cached = cache.get(url.toURI(), "GET", null);
+    if (shouldPut) {
+      assertNotNull(Integer.toString(responseCode), cached);
+    } else {
+      assertNull(Integer.toString(responseCode), cached);
+    }
+    server.shutdown(); // tearDown() isn't sufficient; this test starts multiple servers
+  }
+
   @Test public void responseCachingAndInputStreamSkipWithFixedLength() throws IOException {
     testResponseCaching(TransferKind.FIXED_LENGTH);
   }
@@ -134,12 +228,12 @@ private HttpURLConnection openConnection(URL url) {
    * http://code.google.com/p/android/issues/detail?id=8175
    */
   private void testResponseCaching(TransferKind transferKind) throws IOException {
-    MockResponse response =
-        new MockResponse().addHeader("Last-Modified: " + formatDate(-1, TimeUnit.HOURS))
-            .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS))
-            .setStatus("HTTP/1.1 200 Fantastic");
-    transferKind.setBody(response, "I love puppies but hate spiders", 1);
-    server.enqueue(response);
+    MockResponse mockResponse = new MockResponse()
+        .addHeader("Last-Modified: " + formatDate(-1, TimeUnit.HOURS))
+        .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS))
+        .setStatus("HTTP/1.1 200 Fantastic");
+    transferKind.setBody(mockResponse, "I love puppies but hate spiders", 1);
+    server.enqueue(mockResponse);
 
     // Make sure that calling skip() doesn't omit bytes from the cache.
     HttpURLConnection urlConnection = openConnection(server.getUrl("/"));
@@ -161,40 +255,16 @@ private void testResponseCaching(TransferKind transferKind) throws IOException {
     in.close();
   }
 
-  @Test public void responseCachingWithoutBody() throws IOException {
-    MockResponse response =
-        new MockResponse().addHeader("Last-Modified: " + formatDate(-1, TimeUnit.HOURS))
-            .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS))
-            .setStatus("HTTP/1.1 200 Fantastic");
-    server.enqueue(response);
-
-    // Make sure that calling skip() doesn't omit bytes from the cache.
-    HttpURLConnection urlConnection = openConnection(server.getUrl("/"));
-    assertEquals(200, urlConnection.getResponseCode());
-    assertEquals("Fantastic", urlConnection.getResponseMessage());
-    assertTrue(urlConnection.getDoInput());
-    InputStream is = urlConnection.getInputStream();
-    assertEquals(-1, is.read());
-    is.close();
-
-    urlConnection = openConnection(server.getUrl("/")); // cached!
-    assertTrue(urlConnection.getDoInput());
-    InputStream cachedIs = urlConnection.getInputStream();
-    assertEquals(-1, cachedIs.read());
-    cachedIs.close();
-    assertEquals(200, urlConnection.getResponseCode());
-    assertEquals("Fantastic", urlConnection.getResponseMessage());
-  }
-
   @Test public void secureResponseCaching() throws IOException {
     server.useHttps(sslContext.getSocketFactory(), false);
-    server.enqueue(new MockResponse().addHeader("Last-Modified: " + formatDate(-1, TimeUnit.HOURS))
+    server.enqueue(new MockResponse()
+        .addHeader("Last-Modified: " + formatDate(-1, TimeUnit.HOURS))
         .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS))
         .setBody("ABC"));
 
     HttpsURLConnection c1 = (HttpsURLConnection) openConnection(server.getUrl("/"));
     c1.setSSLSocketFactory(sslContext.getSocketFactory());
-    c1.setHostnameVerifier(NULL_HOSTNAME_VERIFIER);
+    c1.setHostnameVerifier(hostnameVerifier);
     assertEquals("ABC", readAscii(c1));
 
     // OpenJDK 6 fails on this line, complaining that the connection isn't open yet
@@ -206,7 +276,7 @@ private void testResponseCaching(TransferKind transferKind) throws IOException {
 
     HttpsURLConnection c2 = (HttpsURLConnection) openConnection(server.getUrl("/")); // cached!
     c2.setSSLSocketFactory(sslContext.getSocketFactory());
-    c2.setHostnameVerifier(NULL_HOSTNAME_VERIFIER);
+    c2.setHostnameVerifier(hostnameVerifier);
     assertEquals("ABC", readAscii(c2));
 
     assertEquals(suite, c2.getCipherSuite());
@@ -216,35 +286,18 @@ private void testResponseCaching(TransferKind transferKind) throws IOException {
     assertEquals(localPrincipal, c2.getLocalPrincipal());
   }
 
-  @Test public void cacheReturnsInsecureResponseForSecureRequest() throws IOException {
-    server.useHttps(sslContext.getSocketFactory(), false);
-    server.enqueue(new MockResponse().setBody("ABC"));
-    server.enqueue(new MockResponse().setBody("DEF"));
-
-    Internal.instance.setCache(client,
-        new CacheAdapter(new InsecureResponseCache(new InMemoryResponseCache())));
-
-    HttpsURLConnection connection1 = (HttpsURLConnection) openConnection(server.getUrl("/"));
-    connection1.setSSLSocketFactory(sslContext.getSocketFactory());
-    connection1.setHostnameVerifier(NULL_HOSTNAME_VERIFIER);
-    assertEquals("ABC", readAscii(connection1));
-
-    // Not cached!
-    HttpsURLConnection connection2 = (HttpsURLConnection) openConnection(server.getUrl("/"));
-    connection2.setSSLSocketFactory(sslContext.getSocketFactory());
-    connection2.setHostnameVerifier(NULL_HOSTNAME_VERIFIER);
-    assertEquals("DEF", readAscii(connection2));
-  }
-
   @Test public void responseCachingAndRedirects() throws Exception {
-    server.enqueue(new MockResponse().addHeader("Last-Modified: " + formatDate(-1, TimeUnit.HOURS))
+    server.enqueue(new MockResponse()
+        .addHeader("Last-Modified: " + formatDate(-1, TimeUnit.HOURS))
         .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS))
         .setResponseCode(HttpURLConnection.HTTP_MOVED_PERM)
         .addHeader("Location: /foo"));
-    server.enqueue(new MockResponse().addHeader("Last-Modified: " + formatDate(-1, TimeUnit.HOURS))
+    server.enqueue(new MockResponse()
+        .addHeader("Last-Modified: " + formatDate(-1, TimeUnit.HOURS))
         .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS))
         .setBody("ABC"));
-    server.enqueue(new MockResponse().setBody("DEF"));
+    server.enqueue(new MockResponse()
+        .setBody("DEF"));
 
     HttpURLConnection connection = openConnection(server.getUrl("/"));
     assertEquals("ABC", readAscii(connection));
@@ -254,10 +307,14 @@ private void testResponseCaching(TransferKind transferKind) throws IOException {
   }
 
   @Test public void redirectToCachedResult() throws Exception {
-    server.enqueue(new MockResponse().addHeader("Cache-Control: max-age=60").setBody("ABC"));
-    server.enqueue(new MockResponse().setResponseCode(HttpURLConnection.HTTP_MOVED_PERM)
+    server.enqueue(new MockResponse()
+        .addHeader("Cache-Control: max-age=60")
+        .setBody("ABC"));
+    server.enqueue(new MockResponse()
+        .setResponseCode(HttpURLConnection.HTTP_MOVED_PERM)
         .addHeader("Location: /foo"));
-    server.enqueue(new MockResponse().setBody("DEF"));
+    server.enqueue(new MockResponse()
+        .setBody("DEF"));
 
     assertEquals("ABC", readAscii(openConnection(server.getUrl("/foo"))));
     RecordedRequest request1 = server.takeRequest();
@@ -278,17 +335,20 @@ private void testResponseCaching(TransferKind transferKind) throws IOException {
 
   @Test public void secureResponseCachingAndRedirects() throws IOException {
     server.useHttps(sslContext.getSocketFactory(), false);
-    server.enqueue(new MockResponse().addHeader("Last-Modified: " + formatDate(-1, TimeUnit.HOURS))
+    server.enqueue(new MockResponse()
+        .addHeader("Last-Modified: " + formatDate(-1, TimeUnit.HOURS))
         .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS))
         .setResponseCode(HttpURLConnection.HTTP_MOVED_PERM)
         .addHeader("Location: /foo"));
-    server.enqueue(new MockResponse().addHeader("Last-Modified: " + formatDate(-1, TimeUnit.HOURS))
+    server.enqueue(new MockResponse()
+        .addHeader("Last-Modified: " + formatDate(-1, TimeUnit.HOURS))
         .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS))
         .setBody("ABC"));
-    server.enqueue(new MockResponse().setBody("DEF"));
+    server.enqueue(new MockResponse()
+        .setBody("DEF"));
 
     client.setSslSocketFactory(sslContext.getSocketFactory());
-    client.setHostnameVerifier(NULL_HOSTNAME_VERIFIER);
+    client.setHostnameVerifier(hostnameVerifier);
 
     HttpsURLConnection connection1 = (HttpsURLConnection) openConnection(server.getUrl("/"));
     assertEquals("ABC", readAscii(connection1));
@@ -312,18 +372,21 @@ private void testResponseCaching(TransferKind transferKind) throws IOException {
    */
   @Test public void secureResponseCachingAndProtocolRedirects() throws IOException {
     server2.useHttps(sslContext.getSocketFactory(), false);
-    server2.enqueue(new MockResponse().addHeader("Last-Modified: " + formatDate(-1, TimeUnit.HOURS))
+    server2.enqueue(new MockResponse()
+        .addHeader("Last-Modified: " + formatDate(-1, TimeUnit.HOURS))
         .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS))
         .setBody("ABC"));
-    server2.enqueue(new MockResponse().setBody("DEF"));
+    server2.enqueue(new MockResponse()
+        .setBody("DEF"));
 
-    server.enqueue(new MockResponse().addHeader("Last-Modified: " + formatDate(-1, TimeUnit.HOURS))
+    server.enqueue(new MockResponse()
+        .addHeader("Last-Modified: " + formatDate(-1, TimeUnit.HOURS))
         .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS))
         .setResponseCode(HttpURLConnection.HTTP_MOVED_PERM)
         .addHeader("Location: " + server2.getUrl("/")));
 
     client.setSslSocketFactory(sslContext.getSocketFactory());
-    client.setHostnameVerifier(NULL_HOSTNAME_VERIFIER);
+    client.setHostnameVerifier(hostnameVerifier);
 
     HttpURLConnection connection1 = openConnection(server.getUrl("/"));
     assertEquals("ABC", readAscii(connection1));
@@ -333,24 +396,61 @@ private void testResponseCaching(TransferKind transferKind) throws IOException {
     assertEquals("ABC", readAscii(connection2));
   }
 
-  @Test public void responseCacheRequestHeaders() throws IOException, URISyntaxException {
-    server.enqueue(new MockResponse().setBody("ABC"));
+  @Test public void foundCachedWithExpiresHeader() throws Exception {
+    temporaryRedirectCachedWithCachingHeader(302, "Expires", formatDate(1, TimeUnit.HOURS));
+  }
 
-    final AtomicReference<Map<String, List<String>>> requestHeadersRef =
-        new AtomicReference<Map<String, List<String>>>();
-    Internal.instance.setCache(client, new CacheAdapter(new AbstractResponseCache() {
-      @Override public CacheResponse get(URI uri, String requestMethod,
-          Map<String, List<String>> requestHeaders) throws IOException {
-        requestHeadersRef.set(requestHeaders);
-        return null;
-      }
-    }));
+  @Test public void foundCachedWithCacheControlHeader() throws Exception {
+    temporaryRedirectCachedWithCachingHeader(302, "Cache-Control", "max-age=60");
+  }
+
+  @Test public void temporaryRedirectCachedWithExpiresHeader() throws Exception {
+    temporaryRedirectCachedWithCachingHeader(307, "Expires", formatDate(1, TimeUnit.HOURS));
+  }
+
+  @Test public void temporaryRedirectCachedWithCacheControlHeader() throws Exception {
+    temporaryRedirectCachedWithCachingHeader(307, "Cache-Control", "max-age=60");
+  }
+
+  @Test public void foundNotCachedWithoutCacheHeader() throws Exception {
+    temporaryRedirectNotCachedWithoutCachingHeader(302);
+  }
+
+  @Test public void temporaryRedirectNotCachedWithoutCacheHeader() throws Exception {
+    temporaryRedirectNotCachedWithoutCachingHeader(307);
+  }
+
+  private void temporaryRedirectCachedWithCachingHeader(
+      int responseCode, String headerName, String headerValue) throws Exception {
+    server.enqueue(new MockResponse()
+        .setResponseCode(responseCode)
+        .addHeader(headerName, headerValue)
+        .addHeader("Location", "/a"));
+    server.enqueue(new MockResponse()
+        .addHeader(headerName, headerValue)
+        .setBody("a"));
+    server.enqueue(new MockResponse()
+        .setBody("b"));
+    server.enqueue(new MockResponse()
+        .setBody("c"));
 
     URL url = server.getUrl("/");
-    URLConnection urlConnection = openConnection(url);
-    urlConnection.addRequestProperty("A", "android");
-    readAscii(urlConnection);
-    assertEquals(Arrays.asList("android"), requestHeadersRef.get().get("A"));
+    assertEquals("a", readAscii(openConnection(url)));
+    assertEquals("a", readAscii(openConnection(url)));
+  }
+
+  private void temporaryRedirectNotCachedWithoutCachingHeader(int responseCode) throws Exception {
+    server.enqueue(new MockResponse()
+        .setResponseCode(responseCode)
+        .addHeader("Location", "/a"));
+    server.enqueue(new MockResponse()
+        .setBody("a"));
+    server.enqueue(new MockResponse()
+        .setBody("b"));
+
+    URL url = server.getUrl("/");
+    assertEquals("a", readAscii(openConnection(url)));
+    assertEquals("b", readAscii(openConnection(url)));
   }
 
   @Test public void serverDisconnectsPrematurelyWithContentLengthHeader() throws IOException {
@@ -371,7 +471,8 @@ private void testServerPrematureDisconnect(TransferKind transferKind) throws IOE
     MockResponse response = new MockResponse();
     transferKind.setBody(response, "ABCDE\nFGHIJKLMNOPQRSTUVWXYZ", 16);
     server.enqueue(truncateViolently(response, 16));
-    server.enqueue(new MockResponse().setBody("Request #2"));
+    server.enqueue(new MockResponse()
+        .setBody("Request #2"));
 
     BufferedReader reader = new BufferedReader(
         new InputStreamReader(openConnection(server.getUrl("/")).getInputStream()));
@@ -402,10 +503,12 @@ private void testServerPrematureDisconnect(TransferKind transferKind) throws IOE
 
   private void testClientPrematureDisconnect(TransferKind transferKind) throws IOException {
     // Setting a low transfer speed ensures that stream discarding will time out.
-    MockResponse response = new MockResponse().throttleBody(6, 1, TimeUnit.SECONDS);
+    MockResponse response = new MockResponse()
+        .throttleBody(6, 1, TimeUnit.SECONDS);
     transferKind.setBody(response, "ABCDE\nFGHIJKLMNOPQRSTUVWXYZ", 1024);
     server.enqueue(response);
-    server.enqueue(new MockResponse().setBody("Request #2"));
+    server.enqueue(new MockResponse()
+        .setBody("Request #2"));
 
     URLConnection connection = openConnection(server.getUrl("/"));
     InputStream in = connection.getInputStream();
@@ -426,10 +529,10 @@ private void testClientPrematureDisconnect(TransferKind transferKind) throws IOE
     //             served:   5 seconds ago
     //   default lifetime: (105 - 5) / 10 = 10 seconds
     //            expires:  10 seconds from served date = 5 seconds from now
-    server.enqueue(
-        new MockResponse().addHeader("Last-Modified: " + formatDate(-105, TimeUnit.SECONDS))
-            .addHeader("Date: " + formatDate(-5, TimeUnit.SECONDS))
-            .setBody("A"));
+    server.enqueue(new MockResponse()
+        .addHeader("Last-Modified: " + formatDate(-105, TimeUnit.SECONDS))
+        .addHeader("Date: " + formatDate(-5, TimeUnit.SECONDS))
+        .setBody("A"));
 
     URL url = server.getUrl("/");
     assertEquals("A", readAscii(openConnection(url)));
@@ -444,9 +547,9 @@ private void testClientPrematureDisconnect(TransferKind transferKind) throws IOE
     //   default lifetime: (115 - 15) / 10 = 10 seconds
     //            expires:  10 seconds from served date = 5 seconds ago
     String lastModifiedDate = formatDate(-115, TimeUnit.SECONDS);
-    RecordedRequest conditionalRequest = assertConditionallyCached(
-        new MockResponse().addHeader("Last-Modified: " + lastModifiedDate)
-            .addHeader("Date: " + formatDate(-15, TimeUnit.SECONDS)));
+    RecordedRequest conditionalRequest = assertConditionallyCached(new MockResponse()
+        .addHeader("Last-Modified: " + lastModifiedDate)
+        .addHeader("Date: " + formatDate(-15, TimeUnit.SECONDS)));
     assertEquals(lastModifiedDate, conditionalRequest.getHeader("If-Modified-Since"));
   }
 
@@ -455,7 +558,8 @@ private void testClientPrematureDisconnect(TransferKind transferKind) throws IOE
     //             served:   5 days ago
     //   default lifetime: (105 - 5) / 10 = 10 days
     //            expires:  10 days from served date = 5 days from now
-    server.enqueue(new MockResponse().addHeader("Last-Modified: " + formatDate(-105, TimeUnit.DAYS))
+    server.enqueue(new MockResponse()
+        .addHeader("Last-Modified: " + formatDate(-105, TimeUnit.DAYS))
         .addHeader("Date: " + formatDate(-5, TimeUnit.DAYS))
         .setBody("A"));
 
@@ -467,11 +571,12 @@ private void testClientPrematureDisconnect(TransferKind transferKind) throws IOE
   }
 
   @Test public void noDefaultExpirationForUrlsWithQueryString() throws Exception {
-    server.enqueue(
-        new MockResponse().addHeader("Last-Modified: " + formatDate(-105, TimeUnit.SECONDS))
-            .addHeader("Date: " + formatDate(-5, TimeUnit.SECONDS))
-            .setBody("A"));
-    server.enqueue(new MockResponse().setBody("B"));
+    server.enqueue(new MockResponse()
+        .addHeader("Last-Modified: " + formatDate(-105, TimeUnit.SECONDS))
+        .addHeader("Date: " + formatDate(-5, TimeUnit.SECONDS))
+        .setBody("A"));
+    server.enqueue(new MockResponse()
+        .setBody("B"));
 
     URL url = server.getUrl("/?foo=bar");
     assertEquals("A", readAscii(openConnection(url)));
@@ -480,98 +585,122 @@ private void testClientPrematureDisconnect(TransferKind transferKind) throws IOE
 
   @Test public void expirationDateInThePastWithLastModifiedHeader() throws Exception {
     String lastModifiedDate = formatDate(-2, TimeUnit.HOURS);
-    RecordedRequest conditionalRequest = assertConditionallyCached(
-        new MockResponse().addHeader("Last-Modified: " + lastModifiedDate)
-            .addHeader("Expires: " + formatDate(-1, TimeUnit.HOURS)));
+    RecordedRequest conditionalRequest = assertConditionallyCached(new MockResponse()
+        .addHeader("Last-Modified: " + lastModifiedDate)
+        .addHeader("Expires: " + formatDate(-1, TimeUnit.HOURS)));
     assertEquals(lastModifiedDate, conditionalRequest.getHeader("If-Modified-Since"));
   }
 
   @Test public void expirationDateInThePastWithNoLastModifiedHeader() throws Exception {
-    assertNotCached(new MockResponse().addHeader("Expires: " + formatDate(-1, TimeUnit.HOURS)));
+    assertNotCached(new MockResponse()
+        .addHeader("Expires: " + formatDate(-1, TimeUnit.HOURS)));
   }
 
   @Test public void expirationDateInTheFuture() throws Exception {
-    assertFullyCached(new MockResponse().addHeader("Expires: " + formatDate(1, TimeUnit.HOURS)));
+    assertFullyCached(new MockResponse()
+        .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS)));
   }
 
   @Test public void maxAgePreferredWithMaxAgeAndExpires() throws Exception {
-    assertFullyCached(new MockResponse().addHeader("Date: " + formatDate(0, TimeUnit.HOURS))
+    assertFullyCached(new MockResponse()
+        .addHeader("Date: " + formatDate(0, TimeUnit.HOURS))
         .addHeader("Expires: " + formatDate(-1, TimeUnit.HOURS))
         .addHeader("Cache-Control: max-age=60"));
   }
 
   @Test public void maxAgeInThePastWithDateAndLastModifiedHeaders() throws Exception {
     String lastModifiedDate = formatDate(-2, TimeUnit.HOURS);
-    RecordedRequest conditionalRequest = assertConditionallyCached(
-        new MockResponse().addHeader("Date: " + formatDate(-120, TimeUnit.SECONDS))
-            .addHeader("Last-Modified: " + lastModifiedDate)
-            .addHeader("Cache-Control: max-age=60"));
+    RecordedRequest conditionalRequest = assertConditionallyCached(new MockResponse()
+        .addHeader("Date: " + formatDate(-120, TimeUnit.SECONDS))
+        .addHeader("Last-Modified: " + lastModifiedDate)
+        .addHeader("Cache-Control: max-age=60"));
     assertEquals(lastModifiedDate, conditionalRequest.getHeader("If-Modified-Since"));
   }
 
   @Test public void maxAgeInThePastWithDateHeaderButNoLastModifiedHeader() throws Exception {
     // Chrome interprets max-age relative to the local clock. Both our cache
     // and Firefox both use the earlier of the local and server's clock.
-    assertNotCached(new MockResponse().addHeader("Date: " + formatDate(-120, TimeUnit.SECONDS))
+    assertNotCached(new MockResponse()
+        .addHeader("Date: " + formatDate(-120, TimeUnit.SECONDS))
         .addHeader("Cache-Control: max-age=60"));
   }
 
   @Test public void maxAgeInTheFutureWithDateHeader() throws Exception {
-    assertFullyCached(new MockResponse().addHeader("Date: " + formatDate(0, TimeUnit.HOURS))
+    assertFullyCached(new MockResponse()
+        .addHeader("Date: " + formatDate(0, TimeUnit.HOURS))
         .addHeader("Cache-Control: max-age=60"));
   }
 
   @Test public void maxAgeInTheFutureWithNoDateHeader() throws Exception {
-    assertFullyCached(new MockResponse().addHeader("Cache-Control: max-age=60"));
+    assertFullyCached(new MockResponse()
+        .addHeader("Cache-Control: max-age=60"));
   }
 
   @Test public void maxAgeWithLastModifiedButNoServedDate() throws Exception {
-    assertFullyCached(
-        new MockResponse().addHeader("Last-Modified: " + formatDate(-120, TimeUnit.SECONDS))
-            .addHeader("Cache-Control: max-age=60"));
+    assertFullyCached(new MockResponse()
+        .addHeader("Last-Modified: " + formatDate(-120, TimeUnit.SECONDS))
+        .addHeader("Cache-Control: max-age=60"));
   }
 
   @Test public void maxAgeInTheFutureWithDateAndLastModifiedHeaders() throws Exception {
-    assertFullyCached(
-        new MockResponse().addHeader("Last-Modified: " + formatDate(-120, TimeUnit.SECONDS))
-            .addHeader("Date: " + formatDate(0, TimeUnit.SECONDS))
-            .addHeader("Cache-Control: max-age=60"));
+    assertFullyCached(new MockResponse()
+        .addHeader("Last-Modified: " + formatDate(-120, TimeUnit.SECONDS))
+        .addHeader("Date: " + formatDate(0, TimeUnit.SECONDS))
+        .addHeader("Cache-Control: max-age=60"));
   }
 
   @Test public void maxAgePreferredOverLowerSharedMaxAge() throws Exception {
-    assertFullyCached(new MockResponse().addHeader("Date: " + formatDate(-2, TimeUnit.MINUTES))
+    assertFullyCached(new MockResponse()
+        .addHeader("Date: " + formatDate(-2, TimeUnit.MINUTES))
         .addHeader("Cache-Control: s-maxage=60")
         .addHeader("Cache-Control: max-age=180"));
   }
 
   @Test public void maxAgePreferredOverHigherMaxAge() throws Exception {
-    assertNotCached(new MockResponse().addHeader("Date: " + formatDate(-2, TimeUnit.MINUTES))
+    assertNotCached(new MockResponse()
+        .addHeader("Date: " + formatDate(-2, TimeUnit.MINUTES))
         .addHeader("Cache-Control: s-maxage=180")
         .addHeader("Cache-Control: max-age=60"));
   }
 
-  /**
-   * Tests that the ResponseCache can cache something. The InMemoryResponseCache only caches GET
-   * requests.
-   */
-  @Test public void responseCacheCanCache() throws Exception {
+  @Test public void requestMethodOptionsIsNotCached() throws Exception {
+    testRequestMethod("OPTIONS", false);
+  }
+
+  @Test public void requestMethodGetIsCached() throws Exception {
     testRequestMethod("GET", true);
   }
 
-  /**
-   * Confirm the ResponseCache can elect to not cache something. The InMemoryResponseCache only
-   * caches GET requests.
-   */
-  @Test public void responseCacheCanIgnore() throws Exception {
+  @Test public void requestMethodHeadIsNotCached() throws Exception {
+    // We could support this but choose not to for implementation simplicity
     testRequestMethod("HEAD", false);
   }
 
+  @Test public void requestMethodPostIsNotCached() throws Exception {
+    // We could support this but choose not to for implementation simplicity
+    testRequestMethod("POST", false);
+  }
+
+  @Test public void requestMethodPutIsNotCached() throws Exception {
+    testRequestMethod("PUT", false);
+  }
+
+  @Test public void requestMethodDeleteIsNotCached() throws Exception {
+    testRequestMethod("DELETE", false);
+  }
+
+  @Test public void requestMethodTraceIsNotCached() throws Exception {
+    testRequestMethod("TRACE", false);
+  }
+
   private void testRequestMethod(String requestMethod, boolean expectCached) throws Exception {
     // 1. seed the cache (potentially)
     // 2. expect a cache hit or miss
-    server.enqueue(new MockResponse().addHeader("Expires: " + formatDate(1, TimeUnit.HOURS))
+    server.enqueue(new MockResponse()
+        .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS))
         .addHeader("X-Response-ID: 1"));
-    server.enqueue(new MockResponse().addHeader("X-Response-ID: 2"));
+    server.enqueue(new MockResponse()
+        .addHeader("X-Response-ID: 2"));
 
     URL url = server.getUrl("/");
 
@@ -590,6 +719,51 @@ private void testRequestMethod(String requestMethod, boolean expectCached) throw
     }
   }
 
+  private void addRequestBodyIfNecessary(String requestMethod, HttpURLConnection connection)
+      throws IOException {
+    if (requestMethod.equals("POST") || requestMethod.equals("PUT")) {
+      connection.setDoOutput(true);
+      OutputStream requestBody = connection.getOutputStream();
+      requestBody.write('x');
+      requestBody.close();
+    }
+  }
+
+  @Test public void postInvalidatesCache() throws Exception {
+    testMethodInvalidates("POST");
+  }
+
+  @Test public void putInvalidatesCache() throws Exception {
+    testMethodInvalidates("PUT");
+  }
+
+  @Test public void deleteMethodInvalidatesCache() throws Exception {
+    testMethodInvalidates("DELETE");
+  }
+
+  private void testMethodInvalidates(String requestMethod) throws Exception {
+    // 1. seed the cache
+    // 2. invalidate it
+    // 3. expect a cache miss
+    server.enqueue(new MockResponse()
+        .setBody("A")
+        .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS)));
+    server.enqueue(new MockResponse()
+        .setBody("B"));
+    server.enqueue(new MockResponse()
+        .setBody("C"));
+
+    URL url = server.getUrl("/");
+
+    assertEquals("A", readAscii(openConnection(url)));
+
+    HttpURLConnection invalidateConnection = openConnection(url);
+    invalidateConnection.setRequestMethod(requestMethod);
+    assertEquals("B", readAscii(invalidateConnection));
+
+    assertEquals("C", readAscii(openConnection(url)));
+  }
+
   /**
    * Equivalent to {@code CacheTest.postInvalidatesCacheWithUncacheableResponse()} but demonstrating
    * that {@link ResponseCache} provides no mechanism for cache invalidation as the result of
@@ -599,9 +773,12 @@ private void testRequestMethod(String requestMethod, boolean expectCached) throw
     // 1. seed the cache
     // 2. invalidate it with uncacheable response
     // 3. the cache to return the original value
-    server.enqueue(
-        new MockResponse().setBody("A").addHeader("Expires: " + formatDate(1, TimeUnit.HOURS)));
-    server.enqueue(new MockResponse().setBody("B").setResponseCode(500));
+    server.enqueue(new MockResponse()
+        .setBody("A")
+        .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS)));
+    server.enqueue(new MockResponse()
+        .setBody("B")
+        .setResponseCode(500));
 
     URL url = server.getUrl("/");
 
@@ -616,59 +793,65 @@ private void testRequestMethod(String requestMethod, boolean expectCached) throw
   }
 
   @Test public void etag() throws Exception {
-    RecordedRequest conditionalRequest =
-        assertConditionallyCached(new MockResponse().addHeader("ETag: v1"));
+    RecordedRequest conditionalRequest = assertConditionallyCached(new MockResponse()
+        .addHeader("ETag: v1"));
     assertEquals("v1", conditionalRequest.getHeader("If-None-Match"));
   }
 
+  /** If both If-Modified-Since and If-None-Match conditions apply, send only If-None-Match. */
   @Test public void etagAndExpirationDateInThePast() throws Exception {
     String lastModifiedDate = formatDate(-2, TimeUnit.HOURS);
-    RecordedRequest conditionalRequest = assertConditionallyCached(
-        new MockResponse().addHeader("ETag: v1")
-            .addHeader("Last-Modified: " + lastModifiedDate)
-            .addHeader("Expires: " + formatDate(-1, TimeUnit.HOURS)));
+    RecordedRequest conditionalRequest = assertConditionallyCached(new MockResponse()
+        .addHeader("ETag: v1")
+        .addHeader("Last-Modified: " + lastModifiedDate)
+        .addHeader("Expires: " + formatDate(-1, TimeUnit.HOURS)));
     assertEquals("v1", conditionalRequest.getHeader("If-None-Match"));
-    assertEquals(lastModifiedDate, conditionalRequest.getHeader("If-Modified-Since"));
+    assertNull(conditionalRequest.getHeader("If-Modified-Since"));
   }
 
   @Test public void etagAndExpirationDateInTheFuture() throws Exception {
-    assertFullyCached(new MockResponse().addHeader("ETag: v1")
+    assertFullyCached(new MockResponse()
+        .addHeader("ETag: v1")
         .addHeader("Last-Modified: " + formatDate(-2, TimeUnit.HOURS))
         .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS)));
   }
 
   @Test public void cacheControlNoCache() throws Exception {
-    assertNotCached(new MockResponse().addHeader("Cache-Control: no-cache"));
+    assertNotCached(new MockResponse()
+        .addHeader("Cache-Control: no-cache"));
   }
 
   @Test public void cacheControlNoCacheAndExpirationDateInTheFuture() throws Exception {
     String lastModifiedDate = formatDate(-2, TimeUnit.HOURS);
-    RecordedRequest conditionalRequest = assertConditionallyCached(
-        new MockResponse().addHeader("Last-Modified: " + lastModifiedDate)
-            .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS))
-            .addHeader("Cache-Control: no-cache"));
+    RecordedRequest conditionalRequest = assertConditionallyCached(new MockResponse()
+        .addHeader("Last-Modified: " + lastModifiedDate)
+        .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS))
+        .addHeader("Cache-Control: no-cache"));
     assertEquals(lastModifiedDate, conditionalRequest.getHeader("If-Modified-Since"));
   }
 
   @Test public void pragmaNoCache() throws Exception {
-    assertNotCached(new MockResponse().addHeader("Pragma: no-cache"));
+    assertNotCached(new MockResponse()
+        .addHeader("Pragma: no-cache"));
   }
 
   @Test public void pragmaNoCacheAndExpirationDateInTheFuture() throws Exception {
     String lastModifiedDate = formatDate(-2, TimeUnit.HOURS);
-    RecordedRequest conditionalRequest = assertConditionallyCached(
-        new MockResponse().addHeader("Last-Modified: " + lastModifiedDate)
-            .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS))
-            .addHeader("Pragma: no-cache"));
+    RecordedRequest conditionalRequest = assertConditionallyCached(new MockResponse()
+        .addHeader("Last-Modified: " + lastModifiedDate)
+        .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS))
+        .addHeader("Pragma: no-cache"));
     assertEquals(lastModifiedDate, conditionalRequest.getHeader("If-Modified-Since"));
   }
 
   @Test public void cacheControlNoStore() throws Exception {
-    assertNotCached(new MockResponse().addHeader("Cache-Control: no-store"));
+    assertNotCached(new MockResponse()
+        .addHeader("Cache-Control: no-store"));
   }
 
   @Test public void cacheControlNoStoreAndExpirationDateInTheFuture() throws Exception {
-    assertNotCached(new MockResponse().addHeader("Last-Modified: " + formatDate(-2, TimeUnit.HOURS))
+    assertNotCached(new MockResponse()
+        .addHeader("Last-Modified: " + formatDate(-2, TimeUnit.HOURS))
         .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS))
         .addHeader("Cache-Control: no-store"));
   }
@@ -676,15 +859,17 @@ private void testRequestMethod(String requestMethod, boolean expectCached) throw
   @Test public void partialRangeResponsesDoNotCorruptCache() throws Exception {
     // 1. request a range
     // 2. request a full document, expecting a cache miss
-    server.enqueue(new MockResponse().setBody("AA")
+    server.enqueue(new MockResponse()
+        .setBody("AA")
         .setResponseCode(HttpURLConnection.HTTP_PARTIAL)
         .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS))
         .addHeader("Content-Range: bytes 1000-1001/2000"));
-    server.enqueue(new MockResponse().setBody("BB"));
+    server.enqueue(new MockResponse()
+        .setBody("BB"));
 
     URL url = server.getUrl("/");
 
-    URLConnection range = openConnection(url);
+    HttpURLConnection range = openConnection(url);
     range.addRequestProperty("Range", "bytes=1000-1001");
     assertEquals("AA", readAscii(range));
 
@@ -692,10 +877,12 @@ private void testRequestMethod(String requestMethod, boolean expectCached) throw
   }
 
   @Test public void serverReturnsDocumentOlderThanCache() throws Exception {
-    server.enqueue(new MockResponse().setBody("A")
+    server.enqueue(new MockResponse()
+        .setBody("A")
         .addHeader("Last-Modified: " + formatDate(-2, TimeUnit.HOURS))
         .addHeader("Expires: " + formatDate(-1, TimeUnit.HOURS)));
-    server.enqueue(new MockResponse().setBody("B")
+    server.enqueue(new MockResponse()
+        .setBody("B")
         .addHeader("Last-Modified: " + formatDate(-4, TimeUnit.HOURS)));
 
     URL url = server.getUrl("/");
@@ -704,23 +891,42 @@ private void testRequestMethod(String requestMethod, boolean expectCached) throw
     assertEquals("A", readAscii(openConnection(url)));
   }
 
+  @Test public void clientSideNoStore() throws Exception {
+    server.enqueue(new MockResponse()
+        .addHeader("Cache-Control: max-age=60")
+        .setBody("A"));
+    server.enqueue(new MockResponse()
+        .addHeader("Cache-Control: max-age=60")
+        .setBody("B"));
+
+    HttpURLConnection connection1 = openConnection(server.getUrl("/"));
+    connection1.setRequestProperty("Cache-Control", "no-store");
+    assertEquals("A", readAscii(connection1));
+
+    HttpURLConnection connection2 = openConnection(server.getUrl("/"));
+    assertEquals("B", readAscii(connection2));
+  }
+
   @Test public void nonIdentityEncodingAndConditionalCache() throws Exception {
-    assertNonIdentityEncodingCached(
-        new MockResponse().addHeader("Last-Modified: " + formatDate(-2, TimeUnit.HOURS))
-            .addHeader("Expires: " + formatDate(-1, TimeUnit.HOURS)));
+    assertNonIdentityEncodingCached(new MockResponse()
+        .addHeader("Last-Modified: " + formatDate(-2, TimeUnit.HOURS))
+        .addHeader("Expires: " + formatDate(-1, TimeUnit.HOURS)));
   }
 
   @Test public void nonIdentityEncodingAndFullCache() throws Exception {
-    assertNonIdentityEncodingCached(
-        new MockResponse().addHeader("Last-Modified: " + formatDate(-2, TimeUnit.HOURS))
-            .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS)));
+    assertNonIdentityEncodingCached(new MockResponse()
+        .addHeader("Last-Modified: " + formatDate(-2, TimeUnit.HOURS))
+        .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS)));
   }
 
   private void assertNonIdentityEncodingCached(MockResponse response) throws Exception {
-    server.enqueue(
-        response.setBody(gzip("ABCABCABC")).addHeader("Content-Encoding: gzip"));
-    server.enqueue(new MockResponse().setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
-    server.enqueue(new MockResponse().setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
+    server.enqueue(response
+        .setBody(gzip("ABCABCABC"))
+        .addHeader("Content-Encoding: gzip"));
+    server.enqueue(new MockResponse()
+        .setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
+    server.enqueue(new MockResponse()
+        .setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
 
     // At least three request/response pairs are required because after the first request is cached
     // a different execution path might be taken. Thus modifications to the cache applied during
@@ -747,18 +953,34 @@ private void assertNonIdentityEncodingCached(MockResponse response) throws Excep
     assertEquals("DEFDEFDEF", readAscii(openConnection(server.getUrl("/"))));
   }
 
+  /** https://github.com/square/okhttp/issues/947 */
+  @Test public void gzipAndVaryOnAcceptEncoding() throws Exception {
+    server.enqueue(new MockResponse()
+        .setBody(gzip("ABCABCABC"))
+        .addHeader("Content-Encoding: gzip")
+        .addHeader("Vary: Accept-Encoding")
+        .addHeader("Cache-Control: max-age=60"));
+    server.enqueue(new MockResponse()
+        .setBody("FAIL"));
+
+    assertEquals("ABCABCABC", readAscii(openConnection(server.getUrl("/"))));
+    assertEquals("ABCABCABC", readAscii(openConnection(server.getUrl("/"))));
+  }
+
   @Test public void expiresDateBeforeModifiedDate() throws Exception {
-    assertConditionallyCached(
-        new MockResponse().addHeader("Last-Modified: " + formatDate(-1, TimeUnit.HOURS))
-            .addHeader("Expires: " + formatDate(-2, TimeUnit.HOURS)));
+    assertConditionallyCached(new MockResponse()
+        .addHeader("Last-Modified: " + formatDate(-1, TimeUnit.HOURS))
+        .addHeader("Expires: " + formatDate(-2, TimeUnit.HOURS)));
   }
 
   @Test public void requestMaxAge() throws IOException {
-    server.enqueue(new MockResponse().setBody("A")
+    server.enqueue(new MockResponse()
+        .setBody("A")
         .addHeader("Last-Modified: " + formatDate(-2, TimeUnit.HOURS))
         .addHeader("Date: " + formatDate(-1, TimeUnit.MINUTES))
         .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS)));
-    server.enqueue(new MockResponse().setBody("B"));
+    server.enqueue(new MockResponse()
+        .setBody("B"));
 
     assertEquals("A", readAscii(openConnection(server.getUrl("/"))));
 
@@ -768,10 +990,12 @@ private void assertNonIdentityEncodingCached(MockResponse response) throws Excep
   }
 
   @Test public void requestMinFresh() throws IOException {
-    server.enqueue(new MockResponse().setBody("A")
+    server.enqueue(new MockResponse()
+        .setBody("A")
         .addHeader("Cache-Control: max-age=60")
         .addHeader("Date: " + formatDate(0, TimeUnit.MINUTES)));
-    server.enqueue(new MockResponse().setBody("B"));
+    server.enqueue(new MockResponse()
+        .setBody("B"));
 
     assertEquals("A", readAscii(openConnection(server.getUrl("/"))));
 
@@ -781,10 +1005,12 @@ private void assertNonIdentityEncodingCached(MockResponse response) throws Excep
   }
 
   @Test public void requestMaxStale() throws IOException {
-    server.enqueue(new MockResponse().setBody("A")
+    server.enqueue(new MockResponse()
+        .setBody("A")
         .addHeader("Cache-Control: max-age=120")
         .addHeader("Date: " + formatDate(-4, TimeUnit.MINUTES)));
-    server.enqueue(new MockResponse().setBody("B"));
+    server.enqueue(new MockResponse()
+        .setBody("B"));
 
     assertEquals("A", readAscii(openConnection(server.getUrl("/"))));
 
@@ -795,11 +1021,32 @@ private void assertNonIdentityEncodingCached(MockResponse response) throws Excep
         connection.getHeaderField("Warning"));
   }
 
-  @Test public void requestMaxStaleNotHonoredWithMustRevalidate() throws IOException {
-    server.enqueue(new MockResponse().setBody("A")
-        .addHeader("Cache-Control: max-age=120, must-revalidate")
+  @Test public void requestMaxStaleDirectiveWithNoValue() throws IOException {
+    // Add a stale response to the cache.
+    server.enqueue(new MockResponse()
+        .setBody("A")
+        .addHeader("Cache-Control: max-age=120")
         .addHeader("Date: " + formatDate(-4, TimeUnit.MINUTES)));
-    server.enqueue(new MockResponse().setBody("B"));
+    server.enqueue(new MockResponse()
+        .setBody("B"));
+
+    assertEquals("A", readAscii(openConnection(server.getUrl("/"))));
+
+    // With max-stale, we'll return that stale response.
+    URLConnection maxStaleConnection = openConnection(server.getUrl("/"));
+    maxStaleConnection.setRequestProperty("Cache-Control", "max-stale");
+    assertEquals("A", readAscii(maxStaleConnection));
+    assertEquals("110 HttpURLConnection \"Response is stale\"",
+        maxStaleConnection.getHeaderField("Warning"));
+  }
+
+  @Test public void requestMaxStaleNotHonoredWithMustRevalidate() throws IOException {
+    server.enqueue(new MockResponse()
+        .setBody("A")
+        .addHeader("Cache-Control: max-age=120, must-revalidate")
+        .addHeader("Date: " + formatDate(-4, TimeUnit.MINUTES)));
+    server.enqueue(new MockResponse()
+        .setBody("B"));
 
     assertEquals("A", readAscii(openConnection(server.getUrl("/"))));
 
@@ -817,7 +1064,8 @@ private void assertNonIdentityEncodingCached(MockResponse response) throws Excep
   }
 
   @Test public void requestOnlyIfCachedWithFullResponseCached() throws IOException {
-    server.enqueue(new MockResponse().setBody("A")
+    server.enqueue(new MockResponse()
+        .setBody("A")
         .addHeader("Cache-Control: max-age=30")
         .addHeader("Date: " + formatDate(0, TimeUnit.MINUTES)));
 
@@ -828,7 +1076,8 @@ private void assertNonIdentityEncodingCached(MockResponse response) throws Excep
   }
 
   @Test public void requestOnlyIfCachedWithConditionalResponseCached() throws IOException {
-    server.enqueue(new MockResponse().setBody("A")
+    server.enqueue(new MockResponse()
+        .setBody("A")
         .addHeader("Cache-Control: max-age=30")
         .addHeader("Date: " + formatDate(-1, TimeUnit.MINUTES)));
 
@@ -839,7 +1088,8 @@ private void assertNonIdentityEncodingCached(MockResponse response) throws Excep
   }
 
   @Test public void requestOnlyIfCachedWithUnhelpfulResponseCached() throws IOException {
-    server.enqueue(new MockResponse().setBody("A"));
+    server.enqueue(new MockResponse()
+        .setBody("A"));
 
     assertEquals("A", readAscii(openConnection(server.getUrl("/"))));
     HttpURLConnection connection = openConnection(server.getUrl("/"));
@@ -848,11 +1098,11 @@ private void assertNonIdentityEncodingCached(MockResponse response) throws Excep
   }
 
   @Test public void requestCacheControlNoCache() throws Exception {
-    server.enqueue(
-        new MockResponse().addHeader("Last-Modified: " + formatDate(-120, TimeUnit.SECONDS))
-            .addHeader("Date: " + formatDate(0, TimeUnit.SECONDS))
-            .addHeader("Cache-Control: max-age=60")
-            .setBody("A"));
+    server.enqueue(new MockResponse()
+        .addHeader("Last-Modified: " + formatDate(-120, TimeUnit.SECONDS))
+        .addHeader("Date: " + formatDate(0, TimeUnit.SECONDS))
+        .addHeader("Cache-Control: max-age=60")
+        .setBody("A"));
     server.enqueue(new MockResponse().setBody("B"));
 
     URL url = server.getUrl("/");
@@ -863,11 +1113,11 @@ private void assertNonIdentityEncodingCached(MockResponse response) throws Excep
   }
 
   @Test public void requestPragmaNoCache() throws Exception {
-    server.enqueue(
-        new MockResponse().addHeader("Last-Modified: " + formatDate(-120, TimeUnit.SECONDS))
-            .addHeader("Date: " + formatDate(0, TimeUnit.SECONDS))
-            .addHeader("Cache-Control: max-age=60")
-            .setBody("A"));
+    server.enqueue(new MockResponse()
+        .addHeader("Last-Modified: " + formatDate(-120, TimeUnit.SECONDS))
+        .addHeader("Date: " + formatDate(0, TimeUnit.SECONDS))
+        .addHeader("Cache-Control: max-age=60")
+        .setBody("A"));
     server.enqueue(new MockResponse().setBody("B"));
 
     URL url = server.getUrl("/");
@@ -878,8 +1128,9 @@ private void assertNonIdentityEncodingCached(MockResponse response) throws Excep
   }
 
   @Test public void clientSuppliedIfModifiedSinceWithCachedResult() throws Exception {
-    MockResponse response =
-        new MockResponse().addHeader("ETag: v3").addHeader("Cache-Control: max-age=0");
+    MockResponse response = new MockResponse()
+        .addHeader("ETag: v3")
+        .addHeader("Cache-Control: max-age=0");
     String ifModifiedSinceDate = formatDate(-24, TimeUnit.HOURS);
     RecordedRequest request =
         assertClientSuppliedCondition(response, "If-Modified-Since", ifModifiedSinceDate);
@@ -889,7 +1140,8 @@ private void assertNonIdentityEncodingCached(MockResponse response) throws Excep
 
   @Test public void clientSuppliedIfNoneMatchSinceWithCachedResult() throws Exception {
     String lastModifiedDate = formatDate(-3, TimeUnit.MINUTES);
-    MockResponse response = new MockResponse().addHeader("Last-Modified: " + lastModifiedDate)
+    MockResponse response = new MockResponse()
+        .addHeader("Last-Modified: " + lastModifiedDate)
         .addHeader("Date: " + formatDate(-2, TimeUnit.MINUTES))
         .addHeader("Cache-Control: max-age=0");
     RecordedRequest request = assertClientSuppliedCondition(response, "If-None-Match", "v1");
@@ -900,7 +1152,8 @@ private void assertNonIdentityEncodingCached(MockResponse response) throws Excep
   private RecordedRequest assertClientSuppliedCondition(MockResponse seed, String conditionName,
       String conditionValue) throws Exception {
     server.enqueue(seed.setBody("A"));
-    server.enqueue(new MockResponse().setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
+    server.enqueue(new MockResponse()
+        .setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
 
     URL url = server.getUrl("/");
     assertEquals("A", readAscii(openConnection(url)));
@@ -914,20 +1167,42 @@ private RecordedRequest assertClientSuppliedCondition(MockResponse seed, String
     return server.takeRequest();
   }
 
-  @Test public void setIfModifiedSince() throws Exception {
-    Date since = new Date();
-    server.enqueue(new MockResponse().setBody("A"));
+  /**
+   * For Last-Modified and Date headers, we should echo the date back in the
+   * exact format we were served.
+   */
+  @Test public void retainServedDateFormat() throws Exception {
+    // Serve a response with a non-standard date format that OkHttp supports.
+    Date lastModifiedDate = new Date(System.currentTimeMillis() + TimeUnit.HOURS.toMillis(-1));
+    Date servedDate = new Date(System.currentTimeMillis() + TimeUnit.HOURS.toMillis(-2));
+    DateFormat dateFormat = new SimpleDateFormat("EEE dd-MMM-yyyy HH:mm:ss z", Locale.US);
+    dateFormat.setTimeZone(TimeZone.getTimeZone("EDT"));
+    String lastModifiedString = dateFormat.format(lastModifiedDate);
+    String servedString = dateFormat.format(servedDate);
+
+    // This response should be conditionally cached.
+    server.enqueue(new MockResponse()
+        .addHeader("Last-Modified: " + lastModifiedString)
+        .addHeader("Expires: " + servedString)
+        .setBody("A"));
+    server.enqueue(new MockResponse()
+        .setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
+
+    assertEquals("A", readAscii(openConnection(server.getUrl("/"))));
+    assertEquals("A", readAscii(openConnection(server.getUrl("/"))));
 
-    URL url = server.getUrl("/");
-    URLConnection connection = openConnection(url);
-    connection.setIfModifiedSince(since.getTime());
-    assertEquals("A", readAscii(connection));
-    RecordedRequest request = server.takeRequest();
-    assertEquals(HttpDate.format(since), request.getHeader("If-Modified-Since"));
+    // The first request has no conditions.
+    RecordedRequest request1 = server.takeRequest();
+    assertNull(request1.getHeader("If-Modified-Since"));
+
+    // The 2nd request uses the server's date format.
+    RecordedRequest request2 = server.takeRequest();
+    assertEquals(lastModifiedString, request2.getHeader("If-Modified-Since"));
   }
 
   @Test public void clientSuppliedConditionWithoutCachedResult() throws Exception {
-    server.enqueue(new MockResponse().setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
+    server.enqueue(new MockResponse()
+        .setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
 
     HttpURLConnection connection = openConnection(server.getUrl("/"));
     String clientIfModifiedSince = formatDate(-24, TimeUnit.HOURS);
@@ -937,8 +1212,11 @@ private RecordedRequest assertClientSuppliedCondition(MockResponse seed, String
   }
 
   @Test public void authorizationRequestFullyCached() throws Exception {
-    server.enqueue(new MockResponse().addHeader("Cache-Control: max-age=60").setBody("A"));
-    server.enqueue(new MockResponse().setBody("B"));
+    server.enqueue(new MockResponse()
+        .addHeader("Cache-Control: max-age=60")
+        .setBody("A"));
+    server.enqueue(new MockResponse()
+        .setBody("B"));
 
     URL url = server.getUrl("/");
     URLConnection connection = openConnection(url);
@@ -948,59 +1226,26 @@ private RecordedRequest assertClientSuppliedCondition(MockResponse seed, String
   }
 
   @Test public void contentLocationDoesNotPopulateCache() throws Exception {
-    server.enqueue(new MockResponse().addHeader("Cache-Control: max-age=60")
+    server.enqueue(new MockResponse()
+        .addHeader("Cache-Control: max-age=60")
         .addHeader("Content-Location: /bar")
         .setBody("A"));
-    server.enqueue(new MockResponse().setBody("B"));
+    server.enqueue(new MockResponse()
+        .setBody("B"));
 
     assertEquals("A", readAscii(openConnection(server.getUrl("/foo"))));
     assertEquals("B", readAscii(openConnection(server.getUrl("/bar"))));
   }
 
-  @Test public void useCachesFalseDoesNotWriteToCache() throws Exception {
-    server.enqueue(
-        new MockResponse().addHeader("Cache-Control: max-age=60").setBody("A").setBody("A"));
-    server.enqueue(new MockResponse().setBody("B"));
-
-    URLConnection connection = openConnection(server.getUrl("/"));
-    connection.setUseCaches(false);
-    assertEquals("A", readAscii(connection));
-    assertEquals("B", readAscii(openConnection(server.getUrl("/"))));
-  }
-
-  @Test public void useCachesFalseDoesNotReadFromCache() throws Exception {
-    server.enqueue(
-        new MockResponse().addHeader("Cache-Control: max-age=60").setBody("A").setBody("A"));
-    server.enqueue(new MockResponse().setBody("B"));
-
-    assertEquals("A", readAscii(openConnection(server.getUrl("/"))));
-    URLConnection connection = openConnection(server.getUrl("/"));
-    connection.setUseCaches(false);
-    assertEquals("B", readAscii(connection));
-  }
-
-  @Test public void defaultUseCachesSetsInitialValueOnly() throws Exception {
-    URL url = new URL("http://localhost/");
-    URLConnection c1 = openConnection(url);
-    URLConnection c2 = openConnection(url);
-    assertTrue(c1.getDefaultUseCaches());
-    c1.setDefaultUseCaches(false);
-    try {
-      assertTrue(c1.getUseCaches());
-      assertTrue(c2.getUseCaches());
-      URLConnection c3 = openConnection(url);
-      assertFalse(c3.getUseCaches());
-    } finally {
-      c1.setDefaultUseCaches(true);
-    }
-  }
-
   @Test public void connectionIsReturnedToPoolAfterConditionalSuccess() throws Exception {
-    server.enqueue(new MockResponse().addHeader("Last-Modified: " + formatDate(-1, TimeUnit.HOURS))
+    server.enqueue(new MockResponse()
+        .addHeader("Last-Modified: " + formatDate(-1, TimeUnit.HOURS))
         .addHeader("Cache-Control: max-age=0")
         .setBody("A"));
-    server.enqueue(new MockResponse().setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
-    server.enqueue(new MockResponse().setBody("B"));
+    server.enqueue(new MockResponse()
+        .setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
+    server.enqueue(new MockResponse()
+        .setBody("B"));
 
     assertEquals("A", readAscii(openConnection(server.getUrl("/a"))));
     assertEquals("A", readAscii(openConnection(server.getUrl("/a"))));
@@ -1011,64 +1256,242 @@ private RecordedRequest assertClientSuppliedCondition(MockResponse seed, String
     assertEquals(2, server.takeRequest().getSequenceNumber());
   }
 
-  /**
-   * Confirms the cache implementation may determine the criteria for caching. In real caches
-   * this would be the "Vary" headers.
-   */
-  @Test public void cacheCanUseCriteriaBesidesVariantObeyed() throws Exception {
-    server.enqueue(
-        new MockResponse().addHeader("Cache-Control: max-age=60")
-            .addHeader(InMemoryResponseCache.CACHE_VARIANT_HEADER, "A").setBody("A"));
-    server.enqueue(
-        new MockResponse().addHeader("Cache-Control: max-age=60")
-            .addHeader(InMemoryResponseCache.CACHE_VARIANT_HEADER, "B").setBody("B"));
+  @Test public void varyMatchesChangedRequestHeaderField() throws Exception {
+    server.enqueue(new MockResponse()
+        .addHeader("Cache-Control: max-age=60")
+        .addHeader("Vary: Accept-Language")
+        .setBody("A"));
+    server.enqueue(new MockResponse()
+        .setBody("B"));
+
+    URL url = server.getUrl("/");
+    HttpURLConnection frenchConnection = openConnection(url);
+    frenchConnection.setRequestProperty("Accept-Language", "fr-CA");
+    assertEquals("A", readAscii(frenchConnection));
+
+    HttpURLConnection englishConnection = openConnection(url);
+    englishConnection.setRequestProperty("Accept-Language", "en-US");
+    assertEquals("B", readAscii(englishConnection));
+  }
+
+  @Test public void varyMatchesUnchangedRequestHeaderField() throws Exception {
+    server.enqueue(new MockResponse()
+        .addHeader("Cache-Control: max-age=60")
+        .addHeader("Vary: Accept-Language")
+        .setBody("A"));
+    server.enqueue(new MockResponse()
+        .setBody("B"));
 
     URL url = server.getUrl("/");
-    URLConnection connection1 = openConnection(url);
-    connection1.addRequestProperty(InMemoryResponseCache.CACHE_VARIANT_HEADER, "A");
+    HttpURLConnection frenchConnection1 = openConnection(url);
+    frenchConnection1.setRequestProperty("Accept-Language", "fr-CA");
+    assertEquals("A", readAscii(frenchConnection1));
+
+    HttpURLConnection frenchConnection2 = openConnection(url);
+    frenchConnection2.setRequestProperty("Accept-Language", "fr-CA");
+    assertEquals("A", readAscii(frenchConnection2));
+  }
+
+  @Test public void varyMatchesAbsentRequestHeaderField() throws Exception {
+    server.enqueue(new MockResponse()
+        .addHeader("Cache-Control: max-age=60")
+        .addHeader("Vary: Foo")
+        .setBody("A"));
+    server.enqueue(new MockResponse()
+        .setBody("B"));
+
+    assertEquals("A", readAscii(openConnection(server.getUrl("/"))));
+    assertEquals("A", readAscii(openConnection(server.getUrl("/"))));
+  }
+
+  @Test public void varyMatchesAddedRequestHeaderField() throws Exception {
+    server.enqueue(new MockResponse()
+        .addHeader("Cache-Control: max-age=60")
+        .addHeader("Vary: Foo")
+        .setBody("A"));
+    server.enqueue(new MockResponse()
+        .setBody("B"));
+
+    assertEquals("A", readAscii(openConnection(server.getUrl("/"))));
+    HttpURLConnection connection2 = openConnection(server.getUrl("/"));
+    connection2.setRequestProperty("Foo", "bar");
+    assertEquals("B", readAscii(connection2));
+  }
+
+  @Test public void varyMatchesRemovedRequestHeaderField() throws Exception {
+    server.enqueue(new MockResponse()
+        .addHeader("Cache-Control: max-age=60")
+        .addHeader("Vary: Foo")
+        .setBody("A"));
+    server.enqueue(new MockResponse()
+        .setBody("B"));
+
+    HttpURLConnection connection1 = openConnection(server.getUrl("/"));
+    connection1.setRequestProperty("Foo", "bar");
     assertEquals("A", readAscii(connection1));
-    URLConnection connection2 = openConnection(url);
-    connection2.addRequestProperty(InMemoryResponseCache.CACHE_VARIANT_HEADER, "A");
-    assertEquals("A", readAscii(connection2));
-    assertEquals(1, server.getRequestCount());
+    assertEquals("B", readAscii(openConnection(server.getUrl("/"))));
+  }
 
-    URLConnection connection3 = openConnection(url);
-    connection3.addRequestProperty(InMemoryResponseCache.CACHE_VARIANT_HEADER, "B");
-    assertEquals("B", readAscii(connection3));
-    assertEquals(2, server.getRequestCount());
+  @Test public void varyFieldsAreCaseInsensitive() throws Exception {
+    server.enqueue(new MockResponse()
+        .addHeader("Cache-Control: max-age=60")
+        .addHeader("Vary: ACCEPT-LANGUAGE")
+        .setBody("A"));
+    server.enqueue(new MockResponse()
+        .setBody("B"));
+
+    URL url = server.getUrl("/");
+    HttpURLConnection frenchConnection1 = openConnection(url);
+    frenchConnection1.setRequestProperty("Accept-Language", "fr-CA");
+    assertEquals("A", readAscii(frenchConnection1));
+    HttpURLConnection frenchConnection2 = openConnection(url);
+    frenchConnection2.setRequestProperty("accept-language", "fr-CA");
+    assertEquals("A", readAscii(frenchConnection2));
+  }
+
+  @Test public void varyMultipleFieldsWithMatch() throws Exception {
+    server.enqueue(new MockResponse()
+        .addHeader("Cache-Control: max-age=60")
+        .addHeader("Vary: Accept-Language, Accept-Charset")
+        .addHeader("Vary: Accept-Encoding")
+        .setBody("A"));
+    server.enqueue(new MockResponse()
+        .setBody("B"));
+
+    URL url = server.getUrl("/");
+    HttpURLConnection frenchConnection1 = openConnection(url);
+    frenchConnection1.setRequestProperty("Accept-Language", "fr-CA");
+    frenchConnection1.setRequestProperty("Accept-Charset", "UTF-8");
+    frenchConnection1.setRequestProperty("Accept-Encoding", "identity");
+    assertEquals("A", readAscii(frenchConnection1));
+    HttpURLConnection frenchConnection2 = openConnection(url);
+    frenchConnection2.setRequestProperty("Accept-Language", "fr-CA");
+    frenchConnection2.setRequestProperty("Accept-Charset", "UTF-8");
+    frenchConnection2.setRequestProperty("Accept-Encoding", "identity");
+    assertEquals("A", readAscii(frenchConnection2));
+  }
+
+  @Test public void varyMultipleFieldsWithNoMatch() throws Exception {
+    server.enqueue(new MockResponse()
+        .addHeader("Cache-Control: max-age=60")
+        .addHeader("Vary: Accept-Language, Accept-Charset")
+        .addHeader("Vary: Accept-Encoding")
+        .setBody("A"));
+    server.enqueue(new MockResponse()
+        .setBody("B"));
+
+    URL url = server.getUrl("/");
+    HttpURLConnection frenchConnection = openConnection(url);
+    frenchConnection.setRequestProperty("Accept-Language", "fr-CA");
+    frenchConnection.setRequestProperty("Accept-Charset", "UTF-8");
+    frenchConnection.setRequestProperty("Accept-Encoding", "identity");
+    assertEquals("A", readAscii(frenchConnection));
+    HttpURLConnection englishConnection = openConnection(url);
+    englishConnection.setRequestProperty("Accept-Language", "en-CA");
+    englishConnection.setRequestProperty("Accept-Charset", "UTF-8");
+    englishConnection.setRequestProperty("Accept-Encoding", "identity");
+    assertEquals("B", readAscii(englishConnection));
+  }
+
+  @Test public void varyMultipleFieldValuesWithMatch() throws Exception {
+    server.enqueue(new MockResponse()
+        .addHeader("Cache-Control: max-age=60")
+        .addHeader("Vary: Accept-Language")
+        .setBody("A"));
+    server.enqueue(new MockResponse()
+        .setBody("B"));
+
+    URL url = server.getUrl("/");
+    HttpURLConnection multiConnection1 = openConnection(url);
+    multiConnection1.setRequestProperty("Accept-Language", "fr-CA, fr-FR");
+    multiConnection1.addRequestProperty("Accept-Language", "en-US");
+    assertEquals("A", readAscii(multiConnection1));
+
+    HttpURLConnection multiConnection2 = openConnection(url);
+    multiConnection2.setRequestProperty("Accept-Language", "fr-CA, fr-FR");
+    multiConnection2.addRequestProperty("Accept-Language", "en-US");
+    assertEquals("A", readAscii(multiConnection2));
+  }
+
+  @Test public void varyMultipleFieldValuesWithNoMatch() throws Exception {
+    server.enqueue(new MockResponse()
+        .addHeader("Cache-Control: max-age=60")
+        .addHeader("Vary: Accept-Language")
+        .setBody("A"));
+    server.enqueue(new MockResponse()
+        .setBody("B"));
+
+    URL url = server.getUrl("/");
+    HttpURLConnection multiConnection = openConnection(url);
+    multiConnection.setRequestProperty("Accept-Language", "fr-CA, fr-FR");
+    multiConnection.addRequestProperty("Accept-Language", "en-US");
+    assertEquals("A", readAscii(multiConnection));
+
+    HttpURLConnection notFrenchConnection = openConnection(url);
+    notFrenchConnection.setRequestProperty("Accept-Language", "fr-CA");
+    notFrenchConnection.addRequestProperty("Accept-Language", "en-US");
+    assertEquals("B", readAscii(notFrenchConnection));
+  }
+
+  @Test public void varyAsterisk() throws Exception {
+    server.enqueue(new MockResponse()
+        .addHeader("Cache-Control: max-age=60")
+        .addHeader("Vary: *")
+        .setBody("A"));
+    server.enqueue(new MockResponse()
+        .setBody("B"));
+
+    assertEquals("A", readAscii(openConnection(server.getUrl("/"))));
+    assertEquals("B", readAscii(openConnection(server.getUrl("/"))));
+  }
+
+  @Test public void varyAndHttps() throws Exception {
+    server.useHttps(sslContext.getSocketFactory(), false);
+    server.enqueue(new MockResponse()
+        .addHeader("Cache-Control: max-age=60")
+        .addHeader("Vary: Accept-Language")
+        .setBody("A"));
+    server.enqueue(new MockResponse()
+        .setBody("B"));
+
+    client.setSslSocketFactory(sslContext.getSocketFactory());
+    client.setHostnameVerifier(hostnameVerifier);
+
+    URL url = server.getUrl("/");
+    HttpURLConnection connection1 = openConnection(url);
+    connection1.setRequestProperty("Accept-Language", "en-US");
+    assertEquals("A", readAscii(connection1));
 
-    URLConnection connection4 = openConnection(url);
-    connection4.addRequestProperty(InMemoryResponseCache.CACHE_VARIANT_HEADER, "A");
-    assertEquals("A", readAscii(connection4));
-    assertEquals(2, server.getRequestCount());
+    HttpURLConnection connection2 = openConnection(url);
+    connection2.setRequestProperty("Accept-Language", "en-US");
+    assertEquals("A", readAscii(connection2));
   }
 
   @Test public void cachePlusCookies() throws Exception {
-    server.enqueue(new MockResponse().addHeader(
-        "Set-Cookie: a=FIRST; domain=" + server.getCookieDomain() + ";")
+    server.enqueue(new MockResponse()
+        .addHeader("Set-Cookie: a=FIRST; domain=" + server.getCookieDomain() + ";")
         .addHeader("Last-Modified: " + formatDate(-1, TimeUnit.HOURS))
         .addHeader("Cache-Control: max-age=0")
         .setBody("A"));
-    server.enqueue(new MockResponse().addHeader(
-        "Set-Cookie: a=SECOND; domain=" + server.getCookieDomain() + ";")
+    server.enqueue(new MockResponse()
+        .addHeader("Set-Cookie: a=SECOND; domain=" + server.getCookieDomain() + ";")
         .setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
 
-    CookieManager cookieManager = new CookieManager();
-    CookieManager.setDefault(cookieManager);
-
     URL url = server.getUrl("/");
     assertEquals("A", readAscii(openConnection(url)));
-    assertCookies(cookieManager, url, "a=FIRST");
+    assertCookies(url, "a=FIRST");
     assertEquals("A", readAscii(openConnection(url)));
-    assertCookies(cookieManager, url, "a=SECOND");
+    assertCookies(url, "a=SECOND");
   }
 
   @Test public void getHeadersReturnsNetworkEndToEndHeaders() throws Exception {
-    server.enqueue(new MockResponse().addHeader("Allow: GET, HEAD")
+    server.enqueue(new MockResponse()
+        .addHeader("Allow: GET, HEAD")
         .addHeader("Last-Modified: " + formatDate(-1, TimeUnit.HOURS))
         .addHeader("Cache-Control: max-age=0")
         .setBody("A"));
-    server.enqueue(new MockResponse().addHeader("Allow: GET, HEAD, PUT")
+    server.enqueue(new MockResponse()
+        .addHeader("Allow: GET, HEAD, PUT")
         .setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
 
     URLConnection connection1 = openConnection(server.getUrl("/"));
@@ -1081,11 +1504,13 @@ private RecordedRequest assertClientSuppliedCondition(MockResponse seed, String
   }
 
   @Test public void getHeadersReturnsCachedHopByHopHeaders() throws Exception {
-    server.enqueue(new MockResponse().addHeader("Transfer-Encoding: identity")
+    server.enqueue(new MockResponse()
+        .addHeader("Transfer-Encoding: identity")
         .addHeader("Last-Modified: " + formatDate(-1, TimeUnit.HOURS))
         .addHeader("Cache-Control: max-age=0")
         .setBody("A"));
-    server.enqueue(new MockResponse().addHeader("Transfer-Encoding: none")
+    server.enqueue(new MockResponse()
+        .addHeader("Transfer-Encoding: none")
         .setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
 
     URLConnection connection1 = openConnection(server.getUrl("/"));
@@ -1098,11 +1523,13 @@ private RecordedRequest assertClientSuppliedCondition(MockResponse seed, String
   }
 
   @Test public void getHeadersDeletesCached100LevelWarnings() throws Exception {
-    server.enqueue(new MockResponse().addHeader("Warning: 199 test danger")
+    server.enqueue(new MockResponse()
+        .addHeader("Warning: 199 test danger")
         .addHeader("Last-Modified: " + formatDate(-1, TimeUnit.HOURS))
         .addHeader("Cache-Control: max-age=0")
         .setBody("A"));
-    server.enqueue(new MockResponse().setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
+    server.enqueue(new MockResponse()
+        .setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
 
     URLConnection connection1 = openConnection(server.getUrl("/"));
     assertEquals("A", readAscii(connection1));
@@ -1114,11 +1541,13 @@ private RecordedRequest assertClientSuppliedCondition(MockResponse seed, String
   }
 
   @Test public void getHeadersRetainsCached200LevelWarnings() throws Exception {
-    server.enqueue(new MockResponse().addHeader("Warning: 299 test danger")
+    server.enqueue(new MockResponse()
+        .addHeader("Warning: 299 test danger")
         .addHeader("Last-Modified: " + formatDate(-1, TimeUnit.HOURS))
         .addHeader("Cache-Control: max-age=0")
         .setBody("A"));
-    server.enqueue(new MockResponse().setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
+    server.enqueue(new MockResponse()
+        .setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
 
     URLConnection connection1 = openConnection(server.getUrl("/"));
     assertEquals("A", readAscii(connection1));
@@ -1129,17 +1558,17 @@ private RecordedRequest assertClientSuppliedCondition(MockResponse seed, String
     assertEquals("299 test danger", connection2.getHeaderField("Warning"));
   }
 
-  public void assertCookies(CookieManager cookieManager, URL url, String... expectedCookies)
-      throws Exception {
-    List<String> actualCookies = new ArrayList<String>();
+  public void assertCookies(URL url, String... expectedCookies) throws Exception {
+    List<String> actualCookies = new ArrayList<>();
     for (HttpCookie cookie : cookieManager.getCookieStore().get(url.toURI())) {
       actualCookies.add(cookie.toString());
     }
     assertEquals(Arrays.asList(expectedCookies), actualCookies);
   }
 
-  @Test public void cachePlusRange() throws Exception {
-    assertNotCached(new MockResponse().setResponseCode(HttpURLConnection.HTTP_PARTIAL)
+  @Test public void doNotCachePartialResponse() throws Exception  {
+    assertNotCached(new MockResponse()
+        .setResponseCode(HttpURLConnection.HTTP_PARTIAL)
         .addHeader("Date: " + formatDate(0, TimeUnit.HOURS))
         .addHeader("Content-Range: bytes 100-100/200")
         .addHeader("Cache-Control: max-age=60"));
@@ -1151,18 +1580,23 @@ public void assertCookies(CookieManager cookieManager, URL url, String... expect
    */
   @Test public void conditionalHitDoesNotUpdateCache() throws Exception {
     // A response that is cacheable, but with a short life.
-    server.enqueue(new MockResponse().addHeader("Last-Modified: " + formatDate(0, TimeUnit.SECONDS))
+    server.enqueue(new MockResponse()
+        .addHeader("Last-Modified: " + formatDate(0, TimeUnit.SECONDS))
         .addHeader("Cache-Control: max-age=0")
         .setBody("A"));
     // A response that refers to the previous response, but is cacheable with a long life.
     // Contains a header we can recognize as having come from the server.
-    server.enqueue(new MockResponse().addHeader("Cache-Control: max-age=30")
+    server.enqueue(new MockResponse()
+        .addHeader("Cache-Control: max-age=30")
         .addHeader("Allow: GET, HEAD")
         .setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
     // A response that is cacheable with a long life.
-    server.enqueue(new MockResponse().setBody("B").addHeader("Cache-Control: max-age=30"));
+    server.enqueue(new MockResponse()
+        .setBody("B")
+        .addHeader("Cache-Control: max-age=30"));
     // A response that should never be requested.
-    server.enqueue(new MockResponse().setBody("C"));
+    server.enqueue(new MockResponse()
+        .setBody("C"));
 
     // cache miss; seed the cache with an entry that will require a network hit to be sure it is
     // still valid
@@ -1188,7 +1622,8 @@ public void assertCookies(CookieManager cookieManager, URL url, String... expect
   }
 
   @Test public void responseSourceHeaderCached() throws IOException {
-    server.enqueue(new MockResponse().setBody("A")
+    server.enqueue(new MockResponse()
+        .setBody("A")
         .addHeader("Cache-Control: max-age=30")
         .addHeader("Date: " + formatDate(0, TimeUnit.MINUTES)));
 
@@ -1199,10 +1634,12 @@ public void assertCookies(CookieManager cookieManager, URL url, String... expect
   }
 
   @Test public void responseSourceHeaderConditionalCacheFetched() throws IOException {
-    server.enqueue(new MockResponse().setBody("A")
+    server.enqueue(new MockResponse()
+        .setBody("A")
         .addHeader("Cache-Control: max-age=30")
         .addHeader("Date: " + formatDate(-31, TimeUnit.MINUTES)));
-    server.enqueue(new MockResponse().setBody("B")
+    server.enqueue(new MockResponse()
+        .setBody("B")
         .addHeader("Cache-Control: max-age=30")
         .addHeader("Date: " + formatDate(0, TimeUnit.MINUTES)));
 
@@ -1212,10 +1649,12 @@ public void assertCookies(CookieManager cookieManager, URL url, String... expect
   }
 
   @Test public void responseSourceHeaderConditionalCacheNotFetched() throws IOException {
-    server.enqueue(new MockResponse().setBody("A")
+    server.enqueue(new MockResponse()
+        .setBody("A")
         .addHeader("Cache-Control: max-age=0")
         .addHeader("Date: " + formatDate(0, TimeUnit.MINUTES)));
-    server.enqueue(new MockResponse().setResponseCode(304));
+    server.enqueue(new MockResponse()
+        .setResponseCode(304));
 
     assertEquals("A", readAscii(openConnection(server.getUrl("/"))));
     HttpURLConnection connection = openConnection(server.getUrl("/"));
@@ -1223,7 +1662,8 @@ public void assertCookies(CookieManager cookieManager, URL url, String... expect
   }
 
   @Test public void responseSourceHeaderFetched() throws IOException {
-    server.enqueue(new MockResponse().setBody("A"));
+    server.enqueue(new MockResponse()
+        .setBody("A"));
 
     URLConnection connection = openConnection(server.getUrl("/"));
     assertEquals("A", readAscii(connection));
@@ -1242,90 +1682,24 @@ public void assertCookies(CookieManager cookieManager, URL url, String... expect
   }
 
   /**
-   * Test that we can interrogate the response when the cache is being
-   * populated. http://code.google.com/p/android/issues/detail?id=7787
+   * @param delta the offset from the current date to use. Negative
+   * values yield dates in the past; positive values yield dates in the
+   * future.
    */
-  @Test public void responseCacheCallbackApis() throws Exception {
-    final String body = "ABCDE";
-    final AtomicInteger cacheCount = new AtomicInteger();
+  private String formatDate(long delta, TimeUnit timeUnit) {
+    return formatDate(new Date(System.currentTimeMillis() + timeUnit.toMillis(delta)));
+  }
+
+  private String formatDate(Date date) {
+    DateFormat rfc1123 = new SimpleDateFormat("EEE, dd MMM yyyy HH:mm:ss zzz", Locale.US);
+    rfc1123.setTimeZone(TimeZone.getTimeZone("GMT"));
+    return rfc1123.format(date);
+  }
 
+  private void assertNotCached(MockResponse response) throws Exception {
+    server.enqueue(response.setBody("A"));
     server.enqueue(new MockResponse()
-        .setStatus("HTTP/1.1 200 Fantastic")
-        .addHeader("Content-Type: text/plain")
-        .addHeader("fgh: ijk")
-        .setBody(body));
-
-    Internal.instance.setCache(client, new CacheAdapter(new AbstractResponseCache() {
-      @Override public CacheRequest put(URI uri, URLConnection connection) throws IOException {
-        HttpURLConnection httpURLConnection = (HttpURLConnection) connection;
-        assertEquals(server.getUrl("/"), uri.toURL());
-        assertEquals(200, httpURLConnection.getResponseCode());
-        try {
-          httpURLConnection.getInputStream();
-          fail();
-        } catch (UnsupportedOperationException expected) {
-        }
-        assertEquals("5", connection.getHeaderField("Content-Length"));
-        assertEquals("text/plain", connection.getHeaderField("Content-Type"));
-        assertEquals("ijk", connection.getHeaderField("fgh"));
-        cacheCount.incrementAndGet();
-        return null;
-      }
-    }));
-
-    URL url = server.getUrl("/");
-    HttpURLConnection connection = openConnection(url);
-    assertEquals(body, readAscii(connection));
-    assertEquals(1, cacheCount.get());
-  }
-
-  /** Don't explode if the cache returns a null body. http://b/3373699 */
-  @Test public void responseCacheReturnsNullOutputStream() throws Exception {
-    final AtomicBoolean aborted = new AtomicBoolean();
-    Internal.instance.setCache(client, new CacheAdapter(new AbstractResponseCache() {
-      @Override public CacheRequest put(URI uri, URLConnection connection) {
-        return new CacheRequest() {
-          @Override public void abort() {
-            aborted.set(true);
-          }
-
-          @Override public OutputStream getBody() throws IOException {
-            return null;
-          }
-        };
-      }
-    }));
-
-    server.enqueue(new MockResponse().setBody("abcdef"));
-
-    HttpURLConnection connection = openConnection(server.getUrl("/"));
-    assertEquals("abc", readAscii(connection, 3));
-    connection.getInputStream().close();
-    assertFalse(aborted.get()); // The best behavior is ambiguous, but RI 6 doesn't abort here
-  }
-
-  /**
-   * @param delta the offset from the current date to use. Negative
-   * values yield dates in the past; positive values yield dates in the
-   * future.
-   */
-  private String formatDate(long delta, TimeUnit timeUnit) {
-    return HttpDate.format(new Date(System.currentTimeMillis() + timeUnit.toMillis(delta)));
-  }
-
-  private void addRequestBodyIfNecessary(String requestMethod, HttpURLConnection invalidate)
-      throws IOException {
-    if (requestMethod.equals("POST") || requestMethod.equals("PUT")) {
-      invalidate.setDoOutput(true);
-      OutputStream requestBody = invalidate.getOutputStream();
-      requestBody.write('x');
-      requestBody.close();
-    }
-  }
-
-  private void assertNotCached(MockResponse response) throws Exception {
-    server.enqueue(response.setBody("A"));
-    server.enqueue(new MockResponse().setBody("B"));
+        .setBody("B"));
 
     URL url = server.getUrl("/");
     assertEquals("A", readAscii(openConnection(url)));
@@ -1390,6 +1764,42 @@ private MockResponse truncateViolently(MockResponse response, int numBytesToKeep
     return response;
   }
 
+  enum TransferKind {
+    CHUNKED() {
+      @Override void setBody(MockResponse response, Buffer content, int chunkSize)
+          throws IOException {
+        response.setChunkedBody(content, chunkSize);
+      }
+    },
+    FIXED_LENGTH() {
+      @Override void setBody(MockResponse response, Buffer content, int chunkSize) {
+        response.setBody(content);
+      }
+    },
+    END_OF_STREAM() {
+      @Override void setBody(MockResponse response, Buffer content, int chunkSize) {
+        response.setBody(content);
+        response.setSocketPolicy(DISCONNECT_AT_END);
+        response.removeHeader("Content-Length");
+      }
+    };
+
+    abstract void setBody(MockResponse response, Buffer content, int chunkSize) throws IOException;
+
+    void setBody(MockResponse response, String content, int chunkSize) throws IOException {
+      setBody(response, new Buffer().writeUtf8(content), chunkSize);
+    }
+  }
+
+  /** Returns a gzipped copy of {@code bytes}. */
+  public Buffer gzip(String data) throws IOException {
+    Buffer result = new Buffer();
+    BufferedSink sink = Okio.buffer(new GzipSink(result));
+    sink.writeUtf8(data);
+    sink.close();
+    return result;
+  }
+
   /**
    * Reads {@code count} characters from the stream. If the stream is
    * exhausted before {@code count} characters can be read, the remaining
@@ -1431,44 +1841,115 @@ private void assertGatewayTimeout(HttpURLConnection connection) throws IOExcepti
     assertEquals(-1, connection.getErrorStream().read());
   }
 
-  enum TransferKind {
-    CHUNKED() {
-      @Override void setBody(MockResponse response, Buffer content, int chunkSize)
-          throws IOException {
-        response.setChunkedBody(content, chunkSize);
-      }
-    },
-    FIXED_LENGTH() {
-      @Override void setBody(MockResponse response, Buffer content, int chunkSize) {
-        response.setBody(content);
+  private static <T> List<T> toListOrNull(T[] arrayOrNull) {
+    return arrayOrNull != null ? Arrays.asList(arrayOrNull) : null;
+  }
+
+  // Android-added tests.
+
+  /**
+   * Test that we can interrogate the response when the cache is being
+   * populated. http://code.google.com/p/android/issues/detail?id=7787
+   */
+  @Test public void responseCacheCallbackApis() throws Exception {
+    final String body = "ABCDE";
+    final AtomicInteger cacheCount = new AtomicInteger();
+
+    server.enqueue(new MockResponse()
+        .setStatus("HTTP/1.1 200 Fantastic")
+        .addHeader("Content-Type: text/plain")
+        .addHeader("fgh: ijk")
+        .setBody(body));
+
+    Internal.instance.setCache(client, new CacheAdapter(new AbstractResponseCache() {
+      @Override public CacheRequest put(URI uri, URLConnection connection) throws IOException {
+        HttpURLConnection httpURLConnection = (HttpURLConnection) connection;
+        assertEquals(server.getUrl("/"), uri.toURL());
+        assertEquals(200, httpURLConnection.getResponseCode());
+        try {
+          httpURLConnection.getInputStream();
+          fail();
+        } catch (UnsupportedOperationException expected) {
+        }
+        assertEquals("5", connection.getHeaderField("Content-Length"));
+        assertEquals("text/plain", connection.getHeaderField("Content-Type"));
+        assertEquals("ijk", connection.getHeaderField("fgh"));
+        cacheCount.incrementAndGet();
+        return null;
       }
-    },
-    END_OF_STREAM() {
-      @Override void setBody(MockResponse response, Buffer content, int chunkSize) {
-        response.setBody(content);
-        response.setSocketPolicy(DISCONNECT_AT_END);
-        response.removeHeader("Content-Length");
+    }));
+
+    URL url = server.getUrl("/");
+    HttpURLConnection connection = openConnection(url);
+    assertEquals(body, readAscii(connection));
+    assertEquals(1, cacheCount.get());
+  }
+
+  /** Don't explode if the cache returns a null body. http://b/3373699 */
+  @Test public void responseCacheReturnsNullOutputStream() throws Exception {
+    final AtomicBoolean aborted = new AtomicBoolean();
+    Internal.instance.setCache(client, new CacheAdapter(new AbstractResponseCache() {
+      @Override public CacheRequest put(URI uri, URLConnection connection) {
+        return new CacheRequest() {
+          @Override public void abort() {
+            aborted.set(true);
+          }
+
+          @Override public OutputStream getBody() throws IOException {
+            return null;
+          }
+        };
       }
-    };
+    }));
 
-    abstract void setBody(MockResponse response, Buffer content, int chunkSize) throws IOException;
+    server.enqueue(new MockResponse().setBody("abcdef"));
 
-    void setBody(MockResponse response, String content, int chunkSize) throws IOException {
-      setBody(response, new Buffer().writeUtf8(content), chunkSize);
-    }
+    HttpURLConnection connection = openConnection(server.getUrl("/"));
+    assertEquals("abc", readAscii(connection, 3));
+    connection.getInputStream().close();
+    assertFalse(aborted.get()); // The best behavior is ambiguous, but RI 6 doesn't abort here
   }
 
-  private <T> List<T> toListOrNull(T[] arrayOrNull) {
-    return arrayOrNull != null ? Arrays.asList(arrayOrNull) : null;
-  }
+  /**
+   * Fail if a badly-behaved cache returns a null status line header.
+   * https://code.google.com/p/android/issues/detail?id=160522
+   */
+  @Test public void responseCacheReturnsNullStatusLine() throws Exception {
+    String cachedContentString = "Hello";
+    final byte[] cachedContent = cachedContentString.getBytes(StandardCharsets.US_ASCII);
 
-  /** Returns a gzipped copy of {@code bytes}. */
-  public Buffer gzip(String data) throws IOException {
-    Buffer result = new Buffer();
-    BufferedSink sink = Okio.buffer(new GzipSink(result));
-    sink.writeUtf8(data);
-    sink.close();
-    return result;
+    Internal.instance.setCache(client, new CacheAdapter(new AbstractResponseCache() {
+      @Override
+      public CacheResponse get(URI uri, String requestMethod,
+          Map<String, List<String>> requestHeaders)
+          throws IOException {
+        return new CacheResponse() {
+          @Override public Map<String, List<String>> getHeaders() throws IOException {
+            String contentType = "text/plain";
+            Map<String, List<String>> headers = new HashMap<>();
+            headers.put("Content-Length", Arrays.asList(Integer.toString(cachedContent.length)));
+            headers.put("Content-Type", Arrays.asList(contentType));
+            headers.put("Expires", Arrays.asList(formatDate(-1, TimeUnit.HOURS)));
+            headers.put("Cache-Control", Arrays.asList("max-age=60"));
+            // Crucially, the header with a null key is missing, which renders the cache response
+            // unusable because OkHttp only caches responses with cacheable response codes.
+            return headers;
+          }
+
+          @Override public InputStream getBody() throws IOException {
+            return new ByteArrayInputStream(cachedContent);
+          }
+        };
+      }
+    }));
+    HttpURLConnection connection = openConnection(server.getUrl("/"));
+    // If there was no status line from the cache an exception will be thrown. No network request
+    // should be made.
+    try {
+      connection.getResponseCode();
+      fail();
+    } catch (ProtocolException expected) {
+    }
   }
 
   private static class InsecureResponseCache extends ResponseCache {
@@ -1500,205 +1981,204 @@ private InsecureResponseCache(ResponseCache delegate) {
     }
   }
 
-  /**
-   * A trivial and non-thread-safe implementation of ResponseCache that uses an in-memory map to
-   * cache GETs.
-   */
-  private static class InMemoryResponseCache extends ResponseCache {
+  @Test public void cacheReturnsInsecureResponseForSecureRequest() throws IOException {
+    server.useHttps(sslContext.getSocketFactory(), false);
+    server.enqueue(new MockResponse().setBody("ABC"));
+    server.enqueue(new MockResponse().setBody("DEF"));
+
+    AndroidInternal.setResponseCache(new OkUrlFactory(client), new InsecureResponseCache(cache));
+
+    HttpsURLConnection connection1 = (HttpsURLConnection) openConnection(server.getUrl("/"));
+    connection1.setSSLSocketFactory(sslContext.getSocketFactory());
+    connection1.setHostnameVerifier(hostnameVerifier);
+    assertEquals("ABC", readAscii(connection1));
 
-    /** A request / response header that acts a bit like Vary but without the complexity. */
-    public static final String CACHE_VARIANT_HEADER = "CacheVariant";
+    // Not cached!
+    HttpsURLConnection connection2 = (HttpsURLConnection) openConnection(server.getUrl("/"));
+    connection2.setSSLSocketFactory(sslContext.getSocketFactory());
+    connection2.setHostnameVerifier(hostnameVerifier);
+    assertEquals("DEF", readAscii(connection2));
+  }
 
-    private static class Key {
-      private final URI uri;
-      private final String cacheVariant;
+  @Test public void responseCacheRequestHeaders() throws IOException, URISyntaxException {
+    server.enqueue(new MockResponse()
+        .setBody("ABC"));
 
-      private Key(URI uri, String cacheVariant) {
-        this.uri = uri;
-        this.cacheVariant = cacheVariant;
+    final AtomicReference<Map<String, List<String>>> requestHeadersRef = new AtomicReference<>();
+    Internal.instance.setCache(client, new CacheAdapter(new AbstractResponseCache() {
+      @Override public CacheResponse get(URI uri, String requestMethod,
+          Map<String, List<String>> requestHeaders) throws IOException {
+        requestHeadersRef.set(requestHeaders);
+        return null;
       }
+    }));
 
-      @Override
-      public boolean equals(Object o) {
-        if (this == o) {
-          return true;
-        }
-        if (o == null || getClass() != o.getClass()) {
-          return false;
-        }
+    URL url = server.getUrl("/");
+    URLConnection urlConnection = openConnection(url);
+    urlConnection.addRequestProperty("A", "android");
+    readAscii(urlConnection);
+    assertEquals(Arrays.asList("android"), requestHeadersRef.get().get("A"));
+  }
 
-        Key key = (Key) o;
+  @Test public void responseCachingWithoutBody() throws IOException {
+    MockResponse response =
+        new MockResponse().addHeader("Last-Modified: " + formatDate(-1, TimeUnit.HOURS))
+            .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS))
+            .setStatus("HTTP/1.1 200 Fantastic");
+    server.enqueue(response);
 
-        if (cacheVariant != null ? !cacheVariant.equals(key.cacheVariant)
-            : key.cacheVariant != null) {
-          return false;
-        }
-        if (!uri.equals(key.uri)) {
-          return false;
-        }
+    HttpURLConnection urlConnection = openConnection(server.getUrl("/"));
+    assertEquals(200, urlConnection.getResponseCode());
+    assertEquals("Fantastic", urlConnection.getResponseMessage());
+    assertTrue(urlConnection.getDoInput());
+    InputStream is = urlConnection.getInputStream();
+    assertEquals(-1, is.read());
+    is.close();
 
-        return true;
-      }
+    urlConnection = openConnection(server.getUrl("/")); // cached!
+    assertTrue(urlConnection.getDoInput());
+    InputStream cachedIs = urlConnection.getInputStream();
+    assertEquals(-1, cachedIs.read());
+    cachedIs.close();
+    assertEquals(200, urlConnection.getResponseCode());
+    assertEquals("Fantastic", urlConnection.getResponseMessage());
+  }
 
-      @Override
-      public int hashCode() {
-        int result = uri.hashCode();
-        result = 31 * result + (cacheVariant != null ? cacheVariant.hashCode() : 0);
-        return result;
-      }
+  @Test public void useCachesFalseDoesNotWriteToCache() throws Exception {
+    server.enqueue(new MockResponse()
+        .addHeader("Cache-Control: max-age=60")
+        .setBody("A"));
+    server.enqueue(new MockResponse()
+        .setBody("B"));
+
+    URLConnection connection = openConnection(server.getUrl("/"));
+    connection.setUseCaches(false);
+    assertEquals("A", readAscii(connection));
+    assertEquals("B", readAscii(openConnection(server.getUrl("/"))));
+  }
+
+  @Test public void useCachesFalseDoesNotReadFromCache() throws Exception {
+    server.enqueue(new MockResponse()
+        .addHeader("Cache-Control: max-age=60")
+        .setBody("A"));
+    server.enqueue(new MockResponse()
+        .setBody("B"));
+
+    assertEquals("A", readAscii(openConnection(server.getUrl("/"))));
+    URLConnection connection = openConnection(server.getUrl("/"));
+    connection.setUseCaches(false);
+    assertEquals("B", readAscii(connection));
+  }
+
+  @Test public void defaultUseCachesSetsInitialValueOnly() throws Exception {
+    URL url = new URL("http://localhost/");
+    URLConnection c1 = openConnection(url);
+    URLConnection c2 = openConnection(url);
+    assertTrue(c1.getDefaultUseCaches());
+    c1.setDefaultUseCaches(false);
+    try {
+      assertTrue(c1.getUseCaches());
+      assertTrue(c2.getUseCaches());
+      URLConnection c3 = openConnection(url);
+      assertFalse(c3.getUseCaches());
+    } finally {
+      c1.setDefaultUseCaches(true);
     }
+  }
 
-    private class Entry {
-
-      private final URI uri;
-      private final String cacheVariant;
-      private final String method;
-      private final Map<String, List<String>> responseHeaders;
-      private final String cipherSuite;
-      private final Certificate[] serverCertificates;
-      private final Certificate[] localCertificates;
-      private byte[] body;
-
-      public Entry(URI uri, URLConnection urlConnection) {
-        this.uri = uri;
-        HttpURLConnection httpUrlConnection = (HttpURLConnection) urlConnection;
-        method = httpUrlConnection.getRequestMethod();
-        cacheVariant = urlConnection.getHeaderField(CACHE_VARIANT_HEADER);
-        responseHeaders = urlConnection.getHeaderFields();
-        if (urlConnection instanceof HttpsURLConnection) {
-          HttpsURLConnection httpsURLConnection = (HttpsURLConnection) urlConnection;
-          cipherSuite = httpsURLConnection.getCipherSuite();
-          Certificate[] serverCertificates;
-          try {
-            serverCertificates = httpsURLConnection.getServerCertificates();
-          } catch (SSLPeerUnverifiedException e) {
-            serverCertificates = null;
-          }
-          this.serverCertificates = serverCertificates;
-          localCertificates = httpsURLConnection.getLocalCertificates();
-        } else {
-          cipherSuite = null;
-          serverCertificates = null;
-          localCertificates = null;
-        }
-      }
+  // Other stacks (e.g. older versions of OkHttp bundled inside Android apps) can interact with the
+  // default ResponseCache. We try to keep this case working as much as possible because apps break
+  // if we don't.
+  @Test public void otherStacks_cacheHitWithoutVary() throws Exception {
+    server.enqueue(new MockResponse()
+        .addHeader("Cache-Control: max-age=60")
+        .setBody("A"));
+    server.enqueue(new MockResponse()
+        .setBody("FAIL"));
 
-      public CacheResponse asCacheResponse() {
-        if (!method.equals(this.method)) {
-          return null;
-        }
+    // Set the cache as the shared cache.
+    ResponseCache.setDefault(cache);
 
-        // Handle SSL
-        if (cipherSuite != null) {
-          return new SecureCacheResponse() {
-            @Override
-            public Map<String, List<String>> getHeaders() throws IOException {
-              return responseHeaders;
-            }
-
-            @Override
-            public InputStream getBody() throws IOException {
-              return new ByteArrayInputStream(body);
-            }
-
-            @Override
-            public String getCipherSuite() {
-              return cipherSuite;
-            }
-
-            @Override
-            public List<Certificate> getLocalCertificateChain() {
-              return localCertificates == null ? null : Arrays.asList(localCertificates);
-            }
-
-            @Override
-            public List<Certificate> getServerCertificateChain() throws SSLPeerUnverifiedException {
-              if (serverCertificates == null) {
-                throw new SSLPeerUnverifiedException("Test implementation");
-              }
-              return Arrays.asList(serverCertificates);
-            }
-
-            @Override
-            public Principal getPeerPrincipal() throws SSLPeerUnverifiedException {
-              throw new UnsupportedOperationException();
-            }
-
-            @Override
-            public Principal getLocalPrincipal() {
-              throw new UnsupportedOperationException();
-            }
-          };
-        } else {
-          return new CacheResponse() {
-            @Override
-            public Map<String, List<String>> getHeaders() throws IOException {
-              return responseHeaders;
-            }
-
-            @Override
-            public InputStream getBody() throws IOException {
-              return new ByteArrayInputStream(body);
-            }
-          };
-        }
-      }
+    // Use the platform's HTTP stack.
+    URLConnection connection = server.getUrl("/").openConnection();
+    assertFalse(connection instanceof HttpURLConnectionImpl);
+    assertEquals("A", readAscii(connection));
 
-      public CacheRequest asCacheRequest() {
-        return new CacheRequest() {
-          @Override
-          public OutputStream getBody() throws IOException {
-            return new ByteArrayOutputStream() {
-              @Override
-              public void close() throws IOException {
-                super.close();
-                body = toByteArray();
-                cache.put(Entry.this.key(), Entry.this);
-              }
-            };
-          }
+    URLConnection connection2 = server.getUrl("/").openConnection();
+    assertFalse(connection2 instanceof HttpURLConnectionImpl);
+    assertEquals("A", readAscii(connection2));
+  }
 
-          @Override
-          public void abort() {
-            // No-op: close() puts the item in the cache, abort need not do anything.
-          }
-        };
-      }
+  // Other stacks (e.g. older versions of OkHttp bundled inside Android apps) can interact with the
+  // default ResponseCache. We can't keep the Vary case working because we can't get to the Vary
+  // request headers after connect(). Accept-Encoding has special behavior so we test it explicitly.
+  @Test public void otherStacks_cacheMissWithVaryAcceptEncoding() throws Exception {
+    server.enqueue(new MockResponse()
+        .addHeader("Cache-Control: max-age=60")
+        .addHeader("Vary: Accept-Encoding")
+        .setBody("A"));
+    server.enqueue(new MockResponse()
+        .setBody("B"));
 
-      private Key key() {
-        return new Key(uri, cacheVariant);
-      }
-    }
+    // Set the cache as the shared cache.
+    ResponseCache.setDefault(cache);
 
-    private Map<Key, Entry> cache = new HashMap<Key, Entry>();
+    // Use the platform's HTTP stack.
+    URLConnection connection = server.getUrl("/").openConnection();
+    assertFalse(connection instanceof HttpURLConnectionImpl);
+    assertEquals("A", readAscii(connection));
 
-    @Override
-    public CacheResponse get(URI uri, String method, Map<String, List<String>> requestHeaders)
-        throws IOException {
+    URLConnection connection2 = server.getUrl("/").openConnection();
+    assertFalse(connection2 instanceof HttpURLConnectionImpl);
+    assertEquals("B", readAscii(connection2));
+  }
 
-      if (!"GET".equals(method)) {
-        return null;
-      }
+  // Other stacks (e.g. older versions of OkHttp bundled inside Android apps) can interact with the
+  // default ResponseCache. We can't keep the Vary case working because we can't get to the Vary
+  // request headers after connect().
+  @Test public void otherStacks_cacheMissWithVary() throws Exception {
+    server.enqueue(new MockResponse()
+        .addHeader("Cache-Control: max-age=60")
+        .addHeader("Vary: Accept-Language")
+        .setBody("A"));
+    server.enqueue(new MockResponse()
+        .setBody("B"));
 
-      String cacheVariant =
-          requestHeaders.containsKey(CACHE_VARIANT_HEADER)
-              ? requestHeaders.get(CACHE_VARIANT_HEADER).get(0) : null;
-      Key key = new Key(uri, cacheVariant);
-      Entry entry = cache.get(key);
-      if (entry == null) {
-        return null;
-      }
-      return entry.asCacheResponse();
-    }
+    // Set the cache as the shared cache.
+    ResponseCache.setDefault(cache);
 
-    @Override
-    public CacheRequest put(URI uri, URLConnection urlConnection) throws IOException {
-      if (!"GET".equals(((HttpURLConnection) urlConnection).getRequestMethod())) {
-        return null;
-      }
+    // Use the platform's HTTP stack.
+    URLConnection connection = server.getUrl("/").openConnection();
+    assertFalse(connection instanceof HttpURLConnectionImpl);
+    connection.setRequestProperty("Accept-Language", "en-US");
+    assertEquals("A", readAscii(connection));
 
-      Entry entry = new Entry(uri, urlConnection);
-      return entry.asCacheRequest();
-    }
+    URLConnection connection2 = server.getUrl("/").openConnection();
+    assertFalse(connection2 instanceof HttpURLConnectionImpl);
+    assertEquals("B", readAscii(connection2));
+  }
+
+  // Other stacks (e.g. older versions of OkHttp bundled inside Android apps) can interact with the
+  // default ResponseCache. We can't keep the Vary case working, because we can't get to the Vary
+  // request headers after connect().
+  @Test public void otherStacks_cacheMissWithVaryAsterisk() throws Exception {
+    server.enqueue(new MockResponse()
+        .addHeader("Cache-Control: max-age=60")
+        .addHeader("Vary: *")
+        .setBody("A"));
+    server.enqueue(new MockResponse()
+        .setBody("B"));
+
+    // Set the cache as the shared cache.
+    ResponseCache.setDefault(cache);
+
+    // Use the platform's HTTP stack.
+    URLConnection connection = server.getUrl("/").openConnection();
+    assertFalse(connection instanceof HttpURLConnectionImpl);
+    assertEquals("A", readAscii(connection));
+
+    URLConnection connection2 = server.getUrl("/").openConnection();
+    assertFalse(connection2 instanceof HttpURLConnectionImpl);
+    assertEquals("B", readAscii(connection2));
   }
 }
diff --git a/okhttp-apache/pom.xml b/okhttp-apache/pom.xml
index 4031304958..74ff837b60 100644
--- a/okhttp-apache/pom.xml
+++ b/okhttp-apache/pom.xml
@@ -6,7 +6,7 @@
   <parent>
     <groupId>com.squareup.okhttp</groupId>
     <artifactId>parent</artifactId>
-    <version>2.3.0-SNAPSHOT</version>
+    <version>2.6.0-SNAPSHOT</version>
   </parent>
 
   <artifactId>okhttp-apache</artifactId>
@@ -18,6 +18,12 @@
       <artifactId>okhttp</artifactId>
       <version>${project.version}</version>
     </dependency>
+    <dependency>
+      <groupId>com.squareup.okhttp</groupId>
+      <artifactId>okhttp-testing-support</artifactId>
+      <version>${project.version}</version>
+      <scope>test</scope>
+    </dependency>
     <dependency>
       <groupId>org.apache.httpcomponents</groupId>
       <artifactId>httpclient</artifactId>
diff --git a/okhttp-apache/src/main/java/com/squareup/okhttp/apache/OkApacheClient.java b/okhttp-apache/src/main/java/com/squareup/okhttp/apache/OkApacheClient.java
index 602a2c8297..3a9174a4d6 100644
--- a/okhttp-apache/src/main/java/com/squareup/okhttp/apache/OkApacheClient.java
+++ b/okhttp-apache/src/main/java/com/squareup/okhttp/apache/OkApacheClient.java
@@ -49,7 +49,7 @@ private static Request transformRequest(HttpRequest request) {
     String contentType = null;
     for (Header header : request.getAllHeaders()) {
       String name = header.getName();
-      if ("Content-Type".equals(name)) {
+      if ("Content-Type".equalsIgnoreCase(name)) {
         contentType = header.getValue();
       } else {
         builder.header(name, header.getValue());
@@ -67,6 +67,8 @@ private static Request transformRequest(HttpRequest request) {
         if (encoding != null) {
           builder.header(encoding.getName(), encoding.getValue());
         }
+      } else {
+        body = RequestBody.create(null, new byte[0]);
       }
     }
     builder.method(method, body);
diff --git a/okhttp-apache/src/test/java/com/squareup/okhttp/apache/OkApacheClientTest.java b/okhttp-apache/src/test/java/com/squareup/okhttp/apache/OkApacheClientTest.java
index ca47c0131a..105f22f3d5 100644
--- a/okhttp-apache/src/test/java/com/squareup/okhttp/apache/OkApacheClientTest.java
+++ b/okhttp-apache/src/test/java/com/squareup/okhttp/apache/OkApacheClientTest.java
@@ -6,6 +6,7 @@
 import java.io.ByteArrayInputStream;
 import java.io.IOException;
 import java.io.InputStream;
+import java.net.URISyntaxException;
 import java.util.zip.GZIPInputStream;
 import okio.Buffer;
 import okio.GzipSink;
@@ -15,6 +16,7 @@
 import org.apache.http.HttpResponse;
 import org.apache.http.client.methods.HttpGet;
 import org.apache.http.client.methods.HttpPost;
+import org.apache.http.client.methods.HttpPut;
 import org.apache.http.entity.ByteArrayEntity;
 import org.apache.http.entity.InputStreamEntity;
 import org.apache.http.entity.StringEntity;
@@ -112,6 +114,24 @@
     assertEquals("Hello, world!", request.getBody().readUtf8());
     assertEquals(request.getHeader("Content-Length"), "13");
   }
+  @Test public void postEmptyEntity() throws Exception {
+    server.enqueue(new MockResponse());
+    final HttpPost post = new HttpPost(server.getUrl("/").toURI());
+    client.execute(post);
+    
+    RecordedRequest request = server.takeRequest();
+    assertEquals(0, request.getBodySize());
+    assertNotNull(request.getBody());
+  }
+  @Test public void putEmptyEntity() throws Exception {
+    server.enqueue(new MockResponse());
+    final HttpPut put = new HttpPut(server.getUrl("/").toURI());
+    client.execute(put);
+    
+    RecordedRequest request = server.takeRequest();
+    assertEquals(0, request.getBodySize());
+    assertNotNull(request.getBody());
+  }
 
   @Test public void postOverrideContentType() throws Exception {
     server.enqueue(new MockResponse());
@@ -156,6 +176,15 @@
     assertNull(response3.getEntity().getContentType());
   }
 
+  @Test public void contentTypeIsCaseInsensitive() throws URISyntaxException, IOException {
+    server.enqueue(new MockResponse().setBody("{\"Message\": { \"text\": \"Hello, World!\" } }")
+        .setHeader("cONTENT-tYPE", "application/json"));
+
+    HttpGet request = new HttpGet(server.getUrl("/").toURI());
+    HttpResponse response = client.execute(request);
+    assertEquals("application/json", response.getEntity().getContentType().getValue());
+  }
+
   @Test public void contentEncoding() throws Exception {
     String text = "{\"Message\": { \"text\": \"Hello, World!\" } }";
     server.enqueue(new MockResponse().setBody(gzip(text))
diff --git a/okhttp-hpacktests/pom.xml b/okhttp-hpacktests/pom.xml
index 70a59f2ad6..4d299fefdc 100644
--- a/okhttp-hpacktests/pom.xml
+++ b/okhttp-hpacktests/pom.xml
@@ -6,7 +6,7 @@
   <parent>
     <groupId>com.squareup.okhttp</groupId>
     <artifactId>parent</artifactId>
-    <version>2.2.0-SNAPSHOT</version>
+    <version>2.4.0-SNAPSHOT</version>
   </parent>
 
   <artifactId>okhttp-hpacktests</artifactId>
@@ -22,6 +22,12 @@
       <artifactId>okhttp</artifactId>
       <version>${project.version}</version>
     </dependency>
+    <dependency>
+      <groupId>com.squareup.okhttp</groupId>
+      <artifactId>okhttp-testing-support</artifactId>
+      <version>${project.version}</version>
+      <scope>test</scope>
+    </dependency>
     <dependency>
       <groupId>junit</groupId>
       <artifactId>junit</artifactId>
diff --git a/okhttp-hpacktests/src/test/java/com/squareup/okhttp/internal/spdy/HpackDecodeInteropTest.java b/okhttp-hpacktests/src/test/java/com/squareup/okhttp/internal/spdy/HpackDecodeInteropTest.java
index 30e1a7b47f..6cb7a86225 100644
--- a/okhttp-hpacktests/src/test/java/com/squareup/okhttp/internal/spdy/HpackDecodeInteropTest.java
+++ b/okhttp-hpacktests/src/test/java/com/squareup/okhttp/internal/spdy/HpackDecodeInteropTest.java
@@ -13,15 +13,15 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.squareup.okhttp.internal.spdy;
+package com.squareup.okhttp.internal.framed;
 
-import com.squareup.okhttp.internal.spdy.hpackjson.Story;
+import com.squareup.okhttp.internal.framed.hpackjson.Story;
 import java.util.Collection;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.junit.runners.Parameterized;
 
-import static com.squareup.okhttp.internal.spdy.hpackjson.HpackJsonUtil.storiesForCurrentDraft;
+import static com.squareup.okhttp.internal.framed.hpackjson.HpackJsonUtil.storiesForCurrentDraft;
 
 @RunWith(Parameterized.class)
 public class HpackDecodeInteropTest extends HpackDecodeTestBase {
diff --git a/okhttp-hpacktests/src/test/java/com/squareup/okhttp/internal/spdy/HpackDecodeTestBase.java b/okhttp-hpacktests/src/test/java/com/squareup/okhttp/internal/spdy/HpackDecodeTestBase.java
index 1bd9b006f2..fe5731911b 100644
--- a/okhttp-hpacktests/src/test/java/com/squareup/okhttp/internal/spdy/HpackDecodeTestBase.java
+++ b/okhttp-hpacktests/src/test/java/com/squareup/okhttp/internal/spdy/HpackDecodeTestBase.java
@@ -13,11 +13,11 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.squareup.okhttp.internal.spdy;
+package com.squareup.okhttp.internal.framed;
 
-import com.squareup.okhttp.internal.spdy.hpackjson.Case;
-import com.squareup.okhttp.internal.spdy.hpackjson.HpackJsonUtil;
-import com.squareup.okhttp.internal.spdy.hpackjson.Story;
+import com.squareup.okhttp.internal.framed.hpackjson.Case;
+import com.squareup.okhttp.internal.framed.hpackjson.HpackJsonUtil;
+import com.squareup.okhttp.internal.framed.hpackjson.Story;
 import java.util.ArrayList;
 import java.util.Collection;
 import java.util.LinkedHashSet;
@@ -51,7 +51,7 @@
   }
 
   private final Buffer bytesIn = new Buffer();
-  private final HpackDraft10.Reader hpackReader = new HpackDraft10.Reader(4096, bytesIn);
+  private final Hpack.Reader hpackReader = new Hpack.Reader(4096, bytesIn);
 
   private final Story story;
 
diff --git a/okhttp-hpacktests/src/test/java/com/squareup/okhttp/internal/spdy/HpackRoundTripTest.java b/okhttp-hpacktests/src/test/java/com/squareup/okhttp/internal/spdy/HpackRoundTripTest.java
index a78dab5abf..3d347590a8 100644
--- a/okhttp-hpacktests/src/test/java/com/squareup/okhttp/internal/spdy/HpackRoundTripTest.java
+++ b/okhttp-hpacktests/src/test/java/com/squareup/okhttp/internal/spdy/HpackRoundTripTest.java
@@ -13,10 +13,10 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.squareup.okhttp.internal.spdy;
+package com.squareup.okhttp.internal.framed;
 
-import com.squareup.okhttp.internal.spdy.hpackjson.Case;
-import com.squareup.okhttp.internal.spdy.hpackjson.Story;
+import com.squareup.okhttp.internal.framed.hpackjson.Case;
+import com.squareup.okhttp.internal.framed.hpackjson.Story;
 import okio.Buffer;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -42,7 +42,7 @@
   }
 
   private Buffer bytesOut = new Buffer();
-  private HpackDraft10.Writer hpackWriter = new HpackDraft10.Writer(bytesOut);
+  private Hpack.Writer hpackWriter = new Hpack.Writer(bytesOut);
 
   public HpackRoundTripTest(Story story) {
     super(story);
diff --git a/okhttp-hpacktests/src/test/java/com/squareup/okhttp/internal/spdy/hpackjson/Case.java b/okhttp-hpacktests/src/test/java/com/squareup/okhttp/internal/spdy/hpackjson/Case.java
index d5d272872c..b62c9f50e3 100644
--- a/okhttp-hpacktests/src/test/java/com/squareup/okhttp/internal/spdy/hpackjson/Case.java
+++ b/okhttp-hpacktests/src/test/java/com/squareup/okhttp/internal/spdy/hpackjson/Case.java
@@ -13,9 +13,9 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.squareup.okhttp.internal.spdy.hpackjson;
+package com.squareup.okhttp.internal.framed.hpackjson;
 
-import com.squareup.okhttp.internal.spdy.Header;
+import com.squareup.okhttp.internal.framed.Header;
 import okio.ByteString;
 
 import java.util.ArrayList;
diff --git a/okhttp-hpacktests/src/test/java/com/squareup/okhttp/internal/spdy/hpackjson/HpackJsonUtil.java b/okhttp-hpacktests/src/test/java/com/squareup/okhttp/internal/spdy/hpackjson/HpackJsonUtil.java
index 9d721abc96..fa52d24287 100644
--- a/okhttp-hpacktests/src/test/java/com/squareup/okhttp/internal/spdy/hpackjson/HpackJsonUtil.java
+++ b/okhttp-hpacktests/src/test/java/com/squareup/okhttp/internal/spdy/hpackjson/HpackJsonUtil.java
@@ -13,7 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.squareup.okhttp.internal.spdy.hpackjson;
+package com.squareup.okhttp.internal.framed.hpackjson;
 
 import com.google.gson.Gson;
 import com.google.gson.GsonBuilder;
@@ -31,7 +31,8 @@
  * Utilities for reading HPACK tests.
  */
 public final class HpackJsonUtil {
-  private static final int CURRENT_DRAFT = 9;
+  /** Earliest draft that is code-compatible with latest. */
+  private static final int BASE_DRAFT = 9;
 
   private static final String STORY_RESOURCE_FORMAT = "/hpack-test-case/%s/story_%02d.json";
 
@@ -49,7 +50,7 @@ private static Story readStory(InputStream jsonResource) throws IOException {
       if (path.isDirectory() && Arrays.asList(path.list()).contains("story_00.json")) {
         try {
           Story firstStory = readStory(new FileInputStream(new File(path, "story_00.json")));
-          if (firstStory.getDraft() == CURRENT_DRAFT) {
+          if (firstStory.getDraft() >= BASE_DRAFT) {
             storyNames.add(path.getName());
           }
         } catch (IOException ignored) {
@@ -85,4 +86,4 @@ private static Story readStory(InputStream jsonResource) throws IOException {
   }
 
   private HpackJsonUtil() { } // Utilities only.
-}
\ No newline at end of file
+}
diff --git a/okhttp-hpacktests/src/test/java/com/squareup/okhttp/internal/spdy/hpackjson/Story.java b/okhttp-hpacktests/src/test/java/com/squareup/okhttp/internal/spdy/hpackjson/Story.java
index 5ff2b07675..cf6a9a0807 100644
--- a/okhttp-hpacktests/src/test/java/com/squareup/okhttp/internal/spdy/hpackjson/Story.java
+++ b/okhttp-hpacktests/src/test/java/com/squareup/okhttp/internal/spdy/hpackjson/Story.java
@@ -13,7 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.squareup.okhttp.internal.spdy.hpackjson;
+package com.squareup.okhttp.internal.framed.hpackjson;
 
 import java.util.ArrayList;
 import java.util.List;
diff --git a/okhttp-testing-support/pom.xml b/okhttp-testing-support/pom.xml
new file mode 100644
index 0000000000..654b0e39e8
--- /dev/null
+++ b/okhttp-testing-support/pom.xml
@@ -0,0 +1,27 @@
+<?xml version="1.0" encoding="UTF-8"?>
+
+<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
+  <modelVersion>4.0.0</modelVersion>
+
+  <parent>
+    <groupId>com.squareup.okhttp</groupId>
+    <artifactId>parent</artifactId>
+    <version>2.6.0-SNAPSHOT</version>
+  </parent>
+
+  <artifactId>okhttp-testing-support</artifactId>
+  <name>OkHttp test support classes</name>
+
+  <dependencies>
+    <dependency>
+      <groupId>junit</groupId>
+      <artifactId>junit</artifactId>
+      <optional>true</optional>
+    </dependency>
+    <dependency>
+      <groupId>com.squareup.okhttp</groupId>
+      <artifactId>okhttp</artifactId>
+      <version>${project.version}</version>
+    </dependency>
+  </dependencies>
+</project>
diff --git a/okhttp-testing-support/src/main/java/com/squareup/okhttp/internal/io/InMemoryFileSystem.java b/okhttp-testing-support/src/main/java/com/squareup/okhttp/internal/io/InMemoryFileSystem.java
new file mode 100644
index 0000000000..3a043cbd1f
--- /dev/null
+++ b/okhttp-testing-support/src/main/java/com/squareup/okhttp/internal/io/InMemoryFileSystem.java
@@ -0,0 +1,75 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.okhttp.internal.io;
+
+import java.io.File;
+import java.io.FileNotFoundException;
+import java.io.IOException;
+import java.util.Iterator;
+import java.util.LinkedHashMap;
+import java.util.Map;
+import okio.Buffer;
+import okio.Sink;
+import okio.Source;
+
+/** A simple file system where all files are held in memory. Not safe for concurrent use. */
+public final class InMemoryFileSystem implements FileSystem {
+  private final Map<File, Buffer> files = new LinkedHashMap<>();
+
+  @Override public Source source(File file) throws FileNotFoundException {
+    Buffer result = files.get(file);
+    if (result == null) throw new FileNotFoundException();
+    return result.clone();
+  }
+
+  @Override public Sink sink(File file) throws FileNotFoundException {
+    Buffer result = new Buffer();
+    files.put(file, result);
+    return result;
+  }
+
+  @Override public Sink appendingSink(File file) throws FileNotFoundException {
+    Buffer result = files.get(file);
+    return result != null ? result : sink(file);
+  }
+
+  @Override public void delete(File file) throws IOException {
+    files.remove(file);
+  }
+
+  @Override public boolean exists(File file) throws IOException {
+    return files.containsKey(file);
+  }
+
+  @Override public long size(File file) {
+    Buffer buffer = files.get(file);
+    return buffer != null ? buffer.size() : 0L;
+  }
+
+  @Override public void rename(File from, File to) throws IOException {
+    Buffer buffer = files.remove(from);
+    if (buffer == null) throw new FileNotFoundException();
+    files.put(to, buffer);
+  }
+
+  @Override public void deleteContents(File directory) throws IOException {
+    String prefix = directory.toString() + "/";
+    for (Iterator<File> i = files.keySet().iterator(); i.hasNext(); ) {
+      File file = i.next();
+      if (file.toString().startsWith(prefix)) i.remove();
+    }
+  }
+}
diff --git a/okhttp-testing-support/src/main/java/com/squareup/okhttp/testing/InstallUncaughtExceptionHandlerListener.java b/okhttp-testing-support/src/main/java/com/squareup/okhttp/testing/InstallUncaughtExceptionHandlerListener.java
new file mode 100644
index 0000000000..4dd4c92e94
--- /dev/null
+++ b/okhttp-testing-support/src/main/java/com/squareup/okhttp/testing/InstallUncaughtExceptionHandlerListener.java
@@ -0,0 +1,66 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.okhttp.testing;
+
+import org.junit.runner.Description;
+import org.junit.runner.Result;
+import org.junit.runner.notification.RunListener;
+
+import java.io.PrintWriter;
+import java.io.StringWriter;
+
+/**
+ * A {@link org.junit.runner.notification.RunListener} used to install an aggressive default
+ * {@link java.lang.Thread.UncaughtExceptionHandler} similar to the one found on Android.
+ * No exceptions should escape from OkHttp that might cause apps to be killed or tests to fail on
+ * Android.
+ */
+public class InstallUncaughtExceptionHandlerListener extends RunListener {
+
+  private Thread.UncaughtExceptionHandler oldDefaultUncaughtExceptionHandler;
+  private Description lastTestStarted;
+
+  @Override public void testRunStarted(Description description) throws Exception {
+    System.err.println("Installing aggressive uncaught exception handler");
+    oldDefaultUncaughtExceptionHandler = Thread.getDefaultUncaughtExceptionHandler();
+    Thread.setDefaultUncaughtExceptionHandler(new Thread.UncaughtExceptionHandler() {
+      @Override public void uncaughtException(Thread thread, Throwable throwable) {
+        StringWriter errorText = new StringWriter(256);
+        errorText.append("Uncaught exception in OkHttp thread \"");
+        errorText.append(thread.getName());
+        errorText.append("\"\n");
+        throwable.printStackTrace(new PrintWriter(errorText));
+        errorText.append("\n");
+        if (lastTestStarted != null) {
+          errorText.append("Last test to start was: ");
+          errorText.append(lastTestStarted.getDisplayName());
+          errorText.append("\n");
+        }
+        System.err.print(errorText.toString());
+        System.exit(-1);
+      }
+    });
+  }
+
+  @Override public void testStarted(Description description) throws Exception {
+    lastTestStarted = description;
+  }
+
+  @Override public void testRunFinished(Result result) throws Exception {
+    Thread.setDefaultUncaughtExceptionHandler(oldDefaultUncaughtExceptionHandler);
+    System.err.println("Uninstalled aggressive uncaught exception handler");
+  }
+}
diff --git a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/RecordingHostnameVerifier.java b/okhttp-testing-support/src/main/java/com/squareup/okhttp/testing/RecordingHostnameVerifier.java
similarity index 96%
rename from okhttp-tests/src/test/java/com/squareup/okhttp/internal/RecordingHostnameVerifier.java
rename to okhttp-testing-support/src/main/java/com/squareup/okhttp/testing/RecordingHostnameVerifier.java
index c9d914f5f2..d4d343a5f3 100644
--- a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/RecordingHostnameVerifier.java
+++ b/okhttp-testing-support/src/main/java/com/squareup/okhttp/testing/RecordingHostnameVerifier.java
@@ -13,7 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.squareup.okhttp.internal;
+package com.squareup.okhttp.testing;
 
 import java.util.ArrayList;
 import java.util.List;
diff --git a/okhttp-tests/pom.xml b/okhttp-tests/pom.xml
index face99dad8..2bb198258a 100644
--- a/okhttp-tests/pom.xml
+++ b/okhttp-tests/pom.xml
@@ -6,7 +6,7 @@
   <parent>
     <groupId>com.squareup.okhttp</groupId>
     <artifactId>parent</artifactId>
-    <version>2.3.0-SNAPSHOT</version>
+    <version>2.6.0-SNAPSHOT</version>
   </parent>
 
   <artifactId>okhttp-tests</artifactId>
@@ -22,6 +22,12 @@
       <artifactId>okhttp</artifactId>
       <version>${project.version}</version>
     </dependency>
+    <dependency>
+      <groupId>com.squareup.okhttp</groupId>
+      <artifactId>okhttp-testing-support</artifactId>
+      <version>${project.version}</version>
+      <scope>test</scope>
+    </dependency>
     <dependency>
       <groupId>com.squareup.okhttp</groupId>
       <artifactId>okhttp-urlconnection</artifactId>
@@ -39,6 +45,11 @@
       <version>${project.version}</version>
       <scope>test</scope>
     </dependency>
+    <dependency>
+      <groupId>com.google.code.gson</groupId>
+      <artifactId>gson</artifactId>
+      <scope>test</scope>
+    </dependency>
   </dependencies>
 
   <build>
diff --git a/okhttp-tests/src/test/java/com/squareup/okhttp/CacheTest.java b/okhttp-tests/src/test/java/com/squareup/okhttp/CacheTest.java
index d422143a1f..b9e1d50139 100644
--- a/okhttp-tests/src/test/java/com/squareup/okhttp/CacheTest.java
+++ b/okhttp-tests/src/test/java/com/squareup/okhttp/CacheTest.java
@@ -19,24 +19,11 @@
 import com.squareup.okhttp.internal.Internal;
 import com.squareup.okhttp.internal.SslContextBuilder;
 import com.squareup.okhttp.internal.Util;
+import com.squareup.okhttp.internal.io.FileSystem;
+import com.squareup.okhttp.internal.io.InMemoryFileSystem;
 import com.squareup.okhttp.mockwebserver.MockResponse;
 import com.squareup.okhttp.mockwebserver.MockWebServer;
 import com.squareup.okhttp.mockwebserver.RecordedRequest;
-import com.squareup.okhttp.mockwebserver.rule.MockWebServerRule;
-import okio.Buffer;
-import okio.BufferedSink;
-import okio.BufferedSource;
-import okio.GzipSink;
-import okio.Okio;
-import org.junit.After;
-import org.junit.Before;
-import org.junit.Rule;
-import org.junit.Test;
-import org.junit.rules.TemporaryFolder;
-
-import javax.net.ssl.HostnameVerifier;
-import javax.net.ssl.SSLContext;
-import javax.net.ssl.SSLSession;
 import java.io.File;
 import java.io.IOException;
 import java.net.CookieHandler;
@@ -44,7 +31,6 @@
 import java.net.HttpCookie;
 import java.net.HttpURLConnection;
 import java.net.ResponseCache;
-import java.net.URL;
 import java.security.Principal;
 import java.security.cert.Certificate;
 import java.text.DateFormat;
@@ -59,6 +45,18 @@
 import java.util.TimeZone;
 import java.util.concurrent.TimeUnit;
 import java.util.concurrent.atomic.AtomicReference;
+import javax.net.ssl.HostnameVerifier;
+import javax.net.ssl.SSLContext;
+import javax.net.ssl.SSLSession;
+import okio.Buffer;
+import okio.BufferedSink;
+import okio.BufferedSource;
+import okio.GzipSink;
+import okio.Okio;
+import org.junit.After;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
 
 import static com.squareup.okhttp.mockwebserver.SocketPolicy.DISCONNECT_AT_END;
 import static org.junit.Assert.assertEquals;
@@ -76,23 +74,18 @@
     }
   };
 
-  private static final SSLContext sslContext = SslContextBuilder.localhost();
-
-  @Rule public TemporaryFolder cacheRule = new TemporaryFolder();
-  @Rule public MockWebServerRule serverRule = new MockWebServerRule();
-  @Rule public MockWebServerRule server2Rule = new MockWebServerRule();
+  @Rule public MockWebServer server = new MockWebServer();
+  @Rule public MockWebServer server2 = new MockWebServer();
 
+  private final SSLContext sslContext = SslContextBuilder.localhost();
+  private final FileSystem fileSystem = new InMemoryFileSystem();
   private final OkHttpClient client = new OkHttpClient();
-  private MockWebServer server;
-  private MockWebServer server2;
   private Cache cache;
   private final CookieManager cookieManager = new CookieManager();
 
   @Before public void setUp() throws Exception {
-    server = serverRule.get();
     server.setProtocolNegotiationEnabled(false);
-    server2 = server2Rule.get();
-    cache = new Cache(cacheRule.getRoot(), Integer.MAX_VALUE);
+    cache = new Cache(new File("/cache/"), Integer.MAX_VALUE, fileSystem);
     client.setCache(cache);
     CookieHandler.setDefault(cookieManager);
   }
@@ -172,12 +165,15 @@ private void assertCached(boolean shouldPut, int responseCode) throws Exception
       mockResponse.addHeader("Proxy-Authenticate: Basic realm=\"protected area\"");
     } else if (responseCode == HttpURLConnection.HTTP_UNAUTHORIZED) {
       mockResponse.addHeader("WWW-Authenticate: Basic realm=\"protected area\"");
+    } else if (responseCode == HttpURLConnection.HTTP_NO_CONTENT
+        || responseCode == HttpURLConnection.HTTP_RESET) {
+      mockResponse.setBody(""); // We forbid bodies for 204 and 205.
     }
     server.enqueue(mockResponse);
     server.start();
 
     Request request = new Request.Builder()
-        .url(server.getUrl("/"))
+        .url(server.url("/"))
         .build();
     Response response = client.newCall(request).execute();
     assertEquals(responseCode, response.code());
@@ -220,7 +216,7 @@ private void testResponseCaching(TransferKind transferKind) throws IOException {
     server.enqueue(mockResponse);
 
     // Make sure that calling skip() doesn't omit bytes from the cache.
-    Request request = new Request.Builder().url(server.getUrl("/")).build();
+    Request request = new Request.Builder().url(server.url("/")).build();
     Response response1 = client.newCall(request).execute();
 
     BufferedSource in1 = response1.body().source();
@@ -257,7 +253,7 @@ private void testResponseCaching(TransferKind transferKind) throws IOException {
     client.setSslSocketFactory(sslContext.getSocketFactory());
     client.setHostnameVerifier(NULL_HOSTNAME_VERIFIER);
 
-    Request request = new Request.Builder().url(server.getUrl("/")).build();
+    Request request = new Request.Builder().url(server.url("/")).build();
     Response response1 = client.newCall(request).execute();
     BufferedSource in = response1.body().source();
     assertEquals("ABC", in.readUtf8());
@@ -296,7 +292,7 @@ private void testResponseCaching(TransferKind transferKind) throws IOException {
     server.enqueue(new MockResponse()
         .setBody("DEF"));
 
-    Request request = new Request.Builder().url(server.getUrl("/")).build();
+    Request request = new Request.Builder().url(server.url("/")).build();
     Response response1 = client.newCall(request).execute();
     assertEquals("ABC", response1.body().string());
 
@@ -318,14 +314,14 @@ private void testResponseCaching(TransferKind transferKind) throws IOException {
     server.enqueue(new MockResponse()
         .setBody("DEF"));
 
-    Request request1 = new Request.Builder().url(server.getUrl("/foo")).build();
+    Request request1 = new Request.Builder().url(server.url("/foo")).build();
     Response response1 = client.newCall(request1).execute();
     assertEquals("ABC", response1.body().string());
     RecordedRequest recordedRequest1 = server.takeRequest();
     assertEquals("GET /foo HTTP/1.1", recordedRequest1.getRequestLine());
     assertEquals(0, recordedRequest1.getSequenceNumber());
 
-    Request request2 = new Request.Builder().url(server.getUrl("/bar")).build();
+    Request request2 = new Request.Builder().url(server.url("/bar")).build();
     Response response2 = client.newCall(request2).execute();
     assertEquals("ABC", response2.body().string());
     RecordedRequest recordedRequest2 = server.takeRequest();
@@ -333,7 +329,7 @@ private void testResponseCaching(TransferKind transferKind) throws IOException {
     assertEquals(1, recordedRequest2.getSequenceNumber());
 
     // an unrelated request should reuse the pooled connection
-    Request request3 = new Request.Builder().url(server.getUrl("/baz")).build();
+    Request request3 = new Request.Builder().url(server.url("/baz")).build();
     Response response3 = client.newCall(request3).execute();
     assertEquals("DEF", response3.body().string());
     RecordedRequest recordedRequest3 = server.takeRequest();
@@ -358,12 +354,12 @@ private void testResponseCaching(TransferKind transferKind) throws IOException {
     client.setSslSocketFactory(sslContext.getSocketFactory());
     client.setHostnameVerifier(NULL_HOSTNAME_VERIFIER);
 
-    Response response1 = get(server.getUrl("/"));
+    Response response1 = get(server.url("/"));
     assertEquals("ABC", response1.body().string());
     assertNotNull(response1.handshake().cipherSuite());
 
     // Cached!
-    Response response2 = get(server.getUrl("/"));
+    Response response2 = get(server.url("/"));
     assertEquals("ABC", response2.body().string());
     assertNotNull(response2.handshake().cipherSuite());
 
@@ -393,16 +389,16 @@ private void testResponseCaching(TransferKind transferKind) throws IOException {
         .addHeader("Last-Modified: " + formatDate(-1, TimeUnit.HOURS))
         .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS))
         .setResponseCode(HttpURLConnection.HTTP_MOVED_PERM)
-        .addHeader("Location: " + server2.getUrl("/")));
+        .addHeader("Location: " + server2.url("/")));
 
     client.setSslSocketFactory(sslContext.getSocketFactory());
     client.setHostnameVerifier(NULL_HOSTNAME_VERIFIER);
 
-    Response response1 = get(server.getUrl("/"));
+    Response response1 = get(server.url("/"));
     assertEquals("ABC", response1.body().string());
 
     // Cached!
-    Response response2 = get(server.getUrl("/"));
+    Response response2 = get(server.url("/"));
     assertEquals("ABC", response2.body().string());
 
     assertEquals(4, cache.getRequestCount()); // 2 direct + 2 redirect = 4
@@ -447,7 +443,7 @@ private void temporaryRedirectCachedWithCachingHeader(
     server.enqueue(new MockResponse()
         .setBody("c"));
 
-    URL url = server.getUrl("/");
+    HttpUrl url = server.url("/");
     assertEquals("a", get(url).body().string());
     assertEquals("a", get(url).body().string());
   }
@@ -461,7 +457,7 @@ private void temporaryRedirectNotCachedWithoutCachingHeader(int responseCode) th
     server.enqueue(new MockResponse()
         .setBody("b"));
 
-    URL url = server.getUrl("/");
+    HttpUrl url = server.url("/");
     assertEquals("a", get(url).body().string());
     assertEquals("b", get(url).body().string());
   }
@@ -487,7 +483,7 @@ private void testServerPrematureDisconnect(TransferKind transferKind) throws IOE
     server.enqueue(new MockResponse()
         .setBody("Request #2"));
 
-    BufferedSource bodySource = get(server.getUrl("/")).body().source();
+    BufferedSource bodySource = get(server.url("/")).body().source();
     assertEquals("ABCDE", bodySource.readUtf8Line());
     try {
       bodySource.readUtf8Line();
@@ -499,7 +495,7 @@ private void testServerPrematureDisconnect(TransferKind transferKind) throws IOE
 
     assertEquals(1, cache.getWriteAbortCount());
     assertEquals(0, cache.getWriteSuccessCount());
-    Response response = get(server.getUrl("/"));
+    Response response = get(server.url("/"));
     assertEquals("Request #2", response.body().string());
     assertEquals(1, cache.getWriteAbortCount());
     assertEquals(1, cache.getWriteSuccessCount());
@@ -526,7 +522,7 @@ private void testClientPrematureDisconnect(TransferKind transferKind) throws IOE
     server.enqueue(new MockResponse()
         .setBody("Request #2"));
 
-    Response response1 = get(server.getUrl("/"));
+    Response response1 = get(server.url("/"));
     BufferedSource in = response1.body().source();
     assertEquals("ABCDE", in.readUtf8(5));
     in.close();
@@ -538,7 +534,7 @@ private void testClientPrematureDisconnect(TransferKind transferKind) throws IOE
 
     assertEquals(1, cache.getWriteAbortCount());
     assertEquals(0, cache.getWriteSuccessCount());
-    Response response2 = get(server.getUrl("/"));
+    Response response2 = get(server.url("/"));
     assertEquals("Request #2", response2.body().string());
     assertEquals(1, cache.getWriteAbortCount());
     assertEquals(1, cache.getWriteSuccessCount());
@@ -554,7 +550,7 @@ private void testClientPrematureDisconnect(TransferKind transferKind) throws IOE
         .addHeader("Date: " + formatDate(-5, TimeUnit.SECONDS))
         .setBody("A"));
 
-    URL url = server.getUrl("/");
+    HttpUrl url = server.url("/");
     Response response1 = get(url);
     assertEquals("A", response1.body().string());
 
@@ -585,8 +581,8 @@ private void testClientPrematureDisconnect(TransferKind transferKind) throws IOE
         .addHeader("Date: " + formatDate(-5, TimeUnit.DAYS))
         .setBody("A"));
 
-    assertEquals("A", get(server.getUrl("/")).body().string());
-    Response response = get(server.getUrl("/"));
+    assertEquals("A", get(server.url("/")).body().string());
+    Response response = get(server.url("/"));
     assertEquals("A", response.body().string());
     assertEquals("113 HttpURLConnection \"Heuristic expiration\"", response.header("Warning"));
   }
@@ -599,7 +595,7 @@ private void testClientPrematureDisconnect(TransferKind transferKind) throws IOE
     server.enqueue(new MockResponse()
         .setBody("B"));
 
-    URL url = server.getUrl("/?foo=bar");
+    HttpUrl url = server.url("/").newBuilder().addQueryParameter("foo", "bar").build();
     assertEquals("A", get(url).body().string());
     assertEquals("B", get(url).body().string());
   }
@@ -723,7 +719,7 @@ private void testRequestMethod(String requestMethod, boolean expectCached) throw
     server.enqueue(new MockResponse()
         .addHeader("X-Response-ID: 2"));
 
-    URL url = server.getUrl("/");
+    HttpUrl url = server.url("/");
 
     Request request = new Request.Builder()
         .url(url)
@@ -772,7 +768,7 @@ private void testMethodInvalidates(String requestMethod) throws Exception {
     server.enqueue(new MockResponse()
         .setBody("C"));
 
-    URL url = server.getUrl("/");
+    HttpUrl url = server.url("/");
 
     assertEquals("A", get(url).body().string());
 
@@ -799,7 +795,7 @@ private void testMethodInvalidates(String requestMethod) throws Exception {
     server.enqueue(new MockResponse()
         .setBody("C"));
 
-    URL url = server.getUrl("/");
+    HttpUrl url = server.url("/");
 
     assertEquals("A", get(url).body().string());
 
@@ -819,6 +815,7 @@ private void testMethodInvalidates(String requestMethod) throws Exception {
     assertEquals("v1", conditionalRequest.getHeader("If-None-Match"));
   }
 
+  /** If both If-Modified-Since and If-None-Match conditions apply, send only If-None-Match. */
   @Test public void etagAndExpirationDateInThePast() throws Exception {
     String lastModifiedDate = formatDate(-2, TimeUnit.HOURS);
     RecordedRequest conditionalRequest = assertConditionallyCached(new MockResponse()
@@ -826,7 +823,7 @@ private void testMethodInvalidates(String requestMethod) throws Exception {
         .addHeader("Last-Modified: " + lastModifiedDate)
         .addHeader("Expires: " + formatDate(-1, TimeUnit.HOURS)));
     assertEquals("v1", conditionalRequest.getHeader("If-None-Match"));
-    assertEquals(lastModifiedDate, conditionalRequest.getHeader("If-Modified-Since"));
+    assertNull(conditionalRequest.getHeader("If-Modified-Since"));
   }
 
   @Test public void etagAndExpirationDateInTheFuture() throws Exception {
@@ -887,7 +884,7 @@ private void testMethodInvalidates(String requestMethod) throws Exception {
     server.enqueue(new MockResponse()
         .setBody("BB"));
 
-    URL url = server.getUrl("/");
+    HttpUrl url = server.url("/");
 
     Request request = new Request.Builder()
         .url(url)
@@ -908,7 +905,7 @@ private void testMethodInvalidates(String requestMethod) throws Exception {
         .setBody("B")
         .addHeader("Last-Modified: " + formatDate(-4, TimeUnit.HOURS)));
 
-    URL url = server.getUrl("/");
+    HttpUrl url = server.url("/");
 
     assertEquals("A", get(url).body().string());
     assertEquals("A", get(url).body().string());
@@ -923,14 +920,14 @@ private void testMethodInvalidates(String requestMethod) throws Exception {
         .setBody("B"));
 
     Request request1 = new Request.Builder()
-        .url(server.getUrl("/"))
+        .url(server.url("/"))
         .cacheControl(new CacheControl.Builder().noStore().build())
         .build();
     Response response1 = client.newCall(request1).execute();
     assertEquals("A", response1.body().string());
 
     Request request2 = new Request.Builder()
-        .url(server.getUrl("/"))
+        .url(server.url("/"))
         .build();
     Response response2 = client.newCall(request2).execute();
     assertEquals("B", response2.body().string());
@@ -960,9 +957,9 @@ private void assertNonIdentityEncodingCached(MockResponse response) throws Excep
     // At least three request/response pairs are required because after the first request is cached
     // a different execution path might be taken. Thus modifications to the cache applied during
     // the second request might not be visible until another request is performed.
-    assertEquals("ABCABCABC", get(server.getUrl("/")).body().string());
-    assertEquals("ABCABCABC", get(server.getUrl("/")).body().string());
-    assertEquals("ABCABCABC", get(server.getUrl("/")).body().string());
+    assertEquals("ABCABCABC", get(server.url("/")).body().string());
+    assertEquals("ABCABCABC", get(server.url("/")).body().string());
+    assertEquals("ABCABCABC", get(server.url("/")).body().string());
   }
 
   @Test public void notModifiedSpecifiesEncoding() throws Exception {
@@ -977,9 +974,9 @@ private void assertNonIdentityEncodingCached(MockResponse response) throws Excep
     server.enqueue(new MockResponse()
         .setBody("DEFDEFDEF"));
 
-    assertEquals("ABCABCABC", get(server.getUrl("/")).body().string());
-    assertEquals("ABCABCABC", get(server.getUrl("/")).body().string());
-    assertEquals("DEFDEFDEF", get(server.getUrl("/")).body().string());
+    assertEquals("ABCABCABC", get(server.url("/")).body().string());
+    assertEquals("ABCABCABC", get(server.url("/")).body().string());
+    assertEquals("DEFDEFDEF", get(server.url("/")).body().string());
   }
 
   /** https://github.com/square/okhttp/issues/947 */
@@ -992,8 +989,8 @@ private void assertNonIdentityEncodingCached(MockResponse response) throws Excep
     server.enqueue(new MockResponse()
         .setBody("FAIL"));
 
-    assertEquals("ABCABCABC", get(server.getUrl("/")).body().string());
-    assertEquals("ABCABCABC", get(server.getUrl("/")).body().string());
+    assertEquals("ABCABCABC", get(server.url("/")).body().string());
+    assertEquals("ABCABCABC", get(server.url("/")).body().string());
   }
 
   @Test public void conditionalCacheHitIsNotDoublePooled() throws Exception {
@@ -1008,8 +1005,8 @@ private void assertNonIdentityEncodingCached(MockResponse response) throws Excep
     pool.evictAll();
     client.setConnectionPool(pool);
 
-    assertEquals("A", get(server.getUrl("/")).body().string());
-    assertEquals("A", get(server.getUrl("/")).body().string());
+    assertEquals("A", get(server.url("/")).body().string());
+    assertEquals("A", get(server.url("/")).body().string());
     assertEquals(1, client.getConnectionPool().getConnectionCount());
   }
 
@@ -1028,10 +1025,10 @@ private void assertNonIdentityEncodingCached(MockResponse response) throws Excep
     server.enqueue(new MockResponse()
         .setBody("B"));
 
-    assertEquals("A", get(server.getUrl("/")).body().string());
+    assertEquals("A", get(server.url("/")).body().string());
 
     Request request = new Request.Builder()
-        .url(server.getUrl("/"))
+        .url(server.url("/"))
         .header("Cache-Control", "max-age=30")
         .build();
     Response response = client.newCall(request).execute();
@@ -1046,10 +1043,10 @@ private void assertNonIdentityEncodingCached(MockResponse response) throws Excep
     server.enqueue(new MockResponse()
         .setBody("B"));
 
-    assertEquals("A", get(server.getUrl("/")).body().string());
+    assertEquals("A", get(server.url("/")).body().string());
 
     Request request = new Request.Builder()
-        .url(server.getUrl("/"))
+        .url(server.url("/"))
         .header("Cache-Control", "min-fresh=120")
         .build();
     Response response = client.newCall(request).execute();
@@ -1064,10 +1061,10 @@ private void assertNonIdentityEncodingCached(MockResponse response) throws Excep
     server.enqueue(new MockResponse()
         .setBody("B"));
 
-    assertEquals("A", get(server.getUrl("/")).body().string());
+    assertEquals("A", get(server.url("/")).body().string());
 
     Request request = new Request.Builder()
-        .url(server.getUrl("/"))
+        .url(server.url("/"))
         .header("Cache-Control", "max-stale=180")
         .build();
     Response response = client.newCall(request).execute();
@@ -1084,11 +1081,11 @@ private void assertNonIdentityEncodingCached(MockResponse response) throws Excep
     server.enqueue(new MockResponse()
         .setBody("B"));
 
-    assertEquals("A", get(server.getUrl("/")).body().string());
+    assertEquals("A", get(server.url("/")).body().string());
 
     // With max-stale, we'll return that stale response.
     Request request = new Request.Builder()
-        .url(server.getUrl("/"))
+        .url(server.url("/"))
         .header("Cache-Control", "max-stale")
         .build();
     Response response = client.newCall(request).execute();
@@ -1104,10 +1101,10 @@ private void assertNonIdentityEncodingCached(MockResponse response) throws Excep
     server.enqueue(new MockResponse()
         .setBody("B"));
 
-    assertEquals("A", get(server.getUrl("/")).body().string());
+    assertEquals("A", get(server.url("/")).body().string());
 
     Request request = new Request.Builder()
-        .url(server.getUrl("/"))
+        .url(server.url("/"))
         .header("Cache-Control", "max-stale=180")
         .build();
     Response response = client.newCall(request).execute();
@@ -1118,7 +1115,7 @@ private void assertNonIdentityEncodingCached(MockResponse response) throws Excep
     // (no responses enqueued)
 
     Request request = new Request.Builder()
-        .url(server.getUrl("/"))
+        .url(server.url("/"))
         .header("Cache-Control", "only-if-cached")
         .build();
     Response response = client.newCall(request).execute();
@@ -1135,9 +1132,9 @@ private void assertNonIdentityEncodingCached(MockResponse response) throws Excep
         .addHeader("Cache-Control: max-age=30")
         .addHeader("Date: " + formatDate(0, TimeUnit.MINUTES)));
 
-    assertEquals("A", get(server.getUrl("/")).body().string());
+    assertEquals("A", get(server.url("/")).body().string());
     Request request = new Request.Builder()
-        .url(server.getUrl("/"))
+        .url(server.url("/"))
         .header("Cache-Control", "only-if-cached")
         .build();
     Response response = client.newCall(request).execute();
@@ -1153,9 +1150,9 @@ private void assertNonIdentityEncodingCached(MockResponse response) throws Excep
         .addHeader("Cache-Control: max-age=30")
         .addHeader("Date: " + formatDate(-1, TimeUnit.MINUTES)));
 
-    assertEquals("A", get(server.getUrl("/")).body().string());
+    assertEquals("A", get(server.url("/")).body().string());
     Request request = new Request.Builder()
-        .url(server.getUrl("/"))
+        .url(server.url("/"))
         .header("Cache-Control", "only-if-cached")
         .build();
     Response response = client.newCall(request).execute();
@@ -1170,9 +1167,9 @@ private void assertNonIdentityEncodingCached(MockResponse response) throws Excep
     server.enqueue(new MockResponse()
         .setBody("A"));
 
-    assertEquals("A", get(server.getUrl("/")).body().string());
+    assertEquals("A", get(server.url("/")).body().string());
     Request request = new Request.Builder()
-        .url(server.getUrl("/"))
+        .url(server.url("/"))
         .header("Cache-Control", "only-if-cached")
         .build();
     Response response = client.newCall(request).execute();
@@ -1192,7 +1189,7 @@ private void assertNonIdentityEncodingCached(MockResponse response) throws Excep
     server.enqueue(new MockResponse()
         .setBody("B"));
 
-    URL url = server.getUrl("/");
+    HttpUrl url = server.url("/");
     assertEquals("A", get(url).body().string());
     Request request = new Request.Builder()
         .url(url)
@@ -1211,7 +1208,7 @@ private void assertNonIdentityEncodingCached(MockResponse response) throws Excep
     server.enqueue(new MockResponse()
         .setBody("B"));
 
-    URL url = server.getUrl("/");
+    HttpUrl url = server.url("/");
     assertEquals("A", get(url).body().string());
     Request request = new Request.Builder()
         .url(url)
@@ -1249,7 +1246,7 @@ private RecordedRequest assertClientSuppliedCondition(MockResponse seed, String
     server.enqueue(new MockResponse()
         .setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
 
-    URL url = server.getUrl("/");
+    HttpUrl url = server.url("/");
     assertEquals("A", get(url).body().string());
 
     Request request = new Request.Builder()
@@ -1285,8 +1282,8 @@ private RecordedRequest assertClientSuppliedCondition(MockResponse seed, String
     server.enqueue(new MockResponse()
         .setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
 
-    assertEquals("A", get(server.getUrl("/")).body().string());
-    assertEquals("A", get(server.getUrl("/")).body().string());
+    assertEquals("A", get(server.url("/")).body().string());
+    assertEquals("A", get(server.url("/")).body().string());
 
     // The first request has no conditions.
     RecordedRequest request1 = server.takeRequest();
@@ -1302,7 +1299,7 @@ private RecordedRequest assertClientSuppliedCondition(MockResponse seed, String
         .setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
 
     Request request = new Request.Builder()
-        .url(server.getUrl("/"))
+        .url(server.url("/"))
         .header("If-Modified-Since", formatDate(-24, TimeUnit.HOURS))
         .build();
     Response response = client.newCall(request).execute();
@@ -1317,7 +1314,7 @@ private RecordedRequest assertClientSuppliedCondition(MockResponse seed, String
     server.enqueue(new MockResponse()
         .setBody("B"));
 
-    URL url = server.getUrl("/");
+    HttpUrl url = server.url("/");
     Request request = new Request.Builder()
         .url(url)
         .header("Authorization", "password")
@@ -1335,8 +1332,8 @@ private RecordedRequest assertClientSuppliedCondition(MockResponse seed, String
     server.enqueue(new MockResponse()
         .setBody("B"));
 
-    assertEquals("A", get(server.getUrl("/foo")).body().string());
-    assertEquals("B", get(server.getUrl("/bar")).body().string());
+    assertEquals("A", get(server.url("/foo")).body().string());
+    assertEquals("B", get(server.url("/bar")).body().string());
   }
 
   @Test public void connectionIsReturnedToPoolAfterConditionalSuccess() throws Exception {
@@ -1349,9 +1346,9 @@ private RecordedRequest assertClientSuppliedCondition(MockResponse seed, String
     server.enqueue(new MockResponse()
         .setBody("B"));
 
-    assertEquals("A", get(server.getUrl("/a")).body().string());
-    assertEquals("A", get(server.getUrl("/a")).body().string());
-    assertEquals("B", get(server.getUrl("/b")).body().string());
+    assertEquals("A", get(server.url("/a")).body().string());
+    assertEquals("A", get(server.url("/a")).body().string());
+    assertEquals("B", get(server.url("/b")).body().string());
 
     assertEquals(0, server.takeRequest().getSequenceNumber());
     assertEquals(1, server.takeRequest().getSequenceNumber());
@@ -1368,12 +1365,12 @@ private RecordedRequest assertClientSuppliedCondition(MockResponse seed, String
     server.enqueue(new MockResponse()
         .setBody("C"));
 
-    assertEquals("A", get(server.getUrl("/")).body().string());
+    assertEquals("A", get(server.url("/")).body().string());
     assertEquals(1, cache.getRequestCount());
     assertEquals(1, cache.getNetworkCount());
     assertEquals(0, cache.getHitCount());
-    assertEquals("B", get(server.getUrl("/")).body().string());
-    assertEquals("C", get(server.getUrl("/")).body().string());
+    assertEquals("B", get(server.url("/")).body().string());
+    assertEquals("C", get(server.url("/")).body().string());
     assertEquals(3, cache.getRequestCount());
     assertEquals(3, cache.getNetworkCount());
     assertEquals(0, cache.getHitCount());
@@ -1389,12 +1386,12 @@ private RecordedRequest assertClientSuppliedCondition(MockResponse seed, String
     server.enqueue(new MockResponse()
         .setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
 
-    assertEquals("A", get(server.getUrl("/")).body().string());
+    assertEquals("A", get(server.url("/")).body().string());
     assertEquals(1, cache.getRequestCount());
     assertEquals(1, cache.getNetworkCount());
     assertEquals(0, cache.getHitCount());
-    assertEquals("A", get(server.getUrl("/")).body().string());
-    assertEquals("A", get(server.getUrl("/")).body().string());
+    assertEquals("A", get(server.url("/")).body().string());
+    assertEquals("A", get(server.url("/")).body().string());
     assertEquals(3, cache.getRequestCount());
     assertEquals(3, cache.getNetworkCount());
     assertEquals(2, cache.getHitCount());
@@ -1405,12 +1402,12 @@ private RecordedRequest assertClientSuppliedCondition(MockResponse seed, String
         .addHeader("Cache-Control: max-age=60")
         .setBody("A"));
 
-    assertEquals("A", get(server.getUrl("/")).body().string());
+    assertEquals("A", get(server.url("/")).body().string());
     assertEquals(1, cache.getRequestCount());
     assertEquals(1, cache.getNetworkCount());
     assertEquals(0, cache.getHitCount());
-    assertEquals("A", get(server.getUrl("/")).body().string());
-    assertEquals("A", get(server.getUrl("/")).body().string());
+    assertEquals("A", get(server.url("/")).body().string());
+    assertEquals("A", get(server.url("/")).body().string());
     assertEquals(3, cache.getRequestCount());
     assertEquals(1, cache.getNetworkCount());
     assertEquals(2, cache.getHitCount());
@@ -1424,7 +1421,7 @@ private RecordedRequest assertClientSuppliedCondition(MockResponse seed, String
     server.enqueue(new MockResponse()
         .setBody("B"));
 
-    URL url = server.getUrl("/");
+    HttpUrl url = server.url("/");
     Request frRequest = new Request.Builder()
         .url(url)
         .header("Accept-Language", "fr-CA")
@@ -1448,7 +1445,7 @@ private RecordedRequest assertClientSuppliedCondition(MockResponse seed, String
     server.enqueue(new MockResponse()
         .setBody("B"));
 
-    URL url = server.getUrl("/");
+    HttpUrl url = server.url("/");
     Request request = new Request.Builder()
         .url(url)
         .header("Accept-Language", "fr-CA")
@@ -1471,8 +1468,8 @@ private RecordedRequest assertClientSuppliedCondition(MockResponse seed, String
     server.enqueue(new MockResponse()
         .setBody("B"));
 
-    assertEquals("A", get(server.getUrl("/")).body().string());
-    assertEquals("A", get(server.getUrl("/")).body().string());
+    assertEquals("A", get(server.url("/")).body().string());
+    assertEquals("A", get(server.url("/")).body().string());
   }
 
   @Test public void varyMatchesAddedRequestHeaderField() throws Exception {
@@ -1483,10 +1480,9 @@ private RecordedRequest assertClientSuppliedCondition(MockResponse seed, String
     server.enqueue(new MockResponse()
         .setBody("B"));
 
-    assertEquals("A", get(server.getUrl("/")).body().string());
+    assertEquals("A", get(server.url("/")).body().string());
     Request request = new Request.Builder()
-        .url(server.getUrl("/"))
-        .header("Foo", "bar")
+        .url(server.url("/")).header("Foo", "bar")
         .build();
     Response response = client.newCall(request).execute();
     assertEquals("B", response.body().string());
@@ -1501,12 +1497,11 @@ private RecordedRequest assertClientSuppliedCondition(MockResponse seed, String
         .setBody("B"));
 
     Request request = new Request.Builder()
-        .url(server.getUrl("/"))
-        .header("Foo", "bar")
+        .url(server.url("/")).header("Foo", "bar")
         .build();
     Response fooresponse = client.newCall(request).execute();
     assertEquals("A", fooresponse.body().string());
-    assertEquals("B", get(server.getUrl("/")).body().string());
+    assertEquals("B", get(server.url("/")).body().string());
   }
 
   @Test public void varyFieldsAreCaseInsensitive() throws Exception {
@@ -1517,7 +1512,7 @@ private RecordedRequest assertClientSuppliedCondition(MockResponse seed, String
     server.enqueue(new MockResponse()
         .setBody("B"));
 
-    URL url = server.getUrl("/");
+    HttpUrl url = server.url("/");
     Request request = new Request.Builder()
         .url(url)
         .header("Accept-Language", "fr-CA")
@@ -1541,7 +1536,7 @@ private RecordedRequest assertClientSuppliedCondition(MockResponse seed, String
     server.enqueue(new MockResponse()
         .setBody("B"));
 
-    URL url = server.getUrl("/");
+    HttpUrl url = server.url("/");
     Request request = new Request.Builder()
         .url(url)
         .header("Accept-Language", "fr-CA")
@@ -1569,7 +1564,7 @@ private RecordedRequest assertClientSuppliedCondition(MockResponse seed, String
     server.enqueue(new MockResponse()
         .setBody("B"));
 
-    URL url = server.getUrl("/");
+    HttpUrl url = server.url("/");
     Request frRequest = new Request.Builder()
         .url(url)
         .header("Accept-Language", "fr-CA")
@@ -1596,7 +1591,7 @@ private RecordedRequest assertClientSuppliedCondition(MockResponse seed, String
     server.enqueue(new MockResponse()
         .setBody("B"));
 
-    URL url = server.getUrl("/");
+    HttpUrl url = server.url("/");
     Request request1 = new Request.Builder()
         .url(url)
         .addHeader("Accept-Language", "fr-CA, fr-FR")
@@ -1622,7 +1617,7 @@ private RecordedRequest assertClientSuppliedCondition(MockResponse seed, String
     server.enqueue(new MockResponse()
         .setBody("B"));
 
-    URL url = server.getUrl("/");
+    HttpUrl url = server.url("/");
     Request request1 = new Request.Builder()
         .url(url)
         .addHeader("Accept-Language", "fr-CA, fr-FR")
@@ -1641,15 +1636,15 @@ private RecordedRequest assertClientSuppliedCondition(MockResponse seed, String
   }
 
   @Test public void varyAsterisk() throws Exception {
-    server.enqueue( new MockResponse()
+    server.enqueue(new MockResponse()
         .addHeader("Cache-Control: max-age=60")
         .addHeader("Vary: *")
         .setBody("A"));
     server.enqueue(new MockResponse()
         .setBody("B"));
 
-    assertEquals("A", get(server.getUrl("/")).body().string());
-    assertEquals("B", get(server.getUrl("/")).body().string());
+    assertEquals("A", get(server.url("/")).body().string());
+    assertEquals("B", get(server.url("/")).body().string());
   }
 
   @Test public void varyAndHttps() throws Exception {
@@ -1664,7 +1659,7 @@ private RecordedRequest assertClientSuppliedCondition(MockResponse seed, String
     client.setSslSocketFactory(sslContext.getSocketFactory());
     client.setHostnameVerifier(NULL_HOSTNAME_VERIFIER);
 
-    URL url = server.getUrl("/");
+    HttpUrl url = server.url("/");
     Request request1 = new Request.Builder()
         .url(url)
         .header("Accept-Language", "en-US")
@@ -1690,7 +1685,7 @@ private RecordedRequest assertClientSuppliedCondition(MockResponse seed, String
         .addHeader("Set-Cookie: a=SECOND; domain=" + server.getCookieDomain() + ";")
         .setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
 
-    URL url = server.getUrl("/");
+    HttpUrl url = server.url("/");
     assertEquals("A", get(url).body().string());
     assertCookies(url, "a=FIRST");
     assertEquals("A", get(url).body().string());
@@ -1707,11 +1702,11 @@ private RecordedRequest assertClientSuppliedCondition(MockResponse seed, String
         .addHeader("Allow: GET, HEAD, PUT")
         .setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
 
-    Response response1 = get(server.getUrl("/"));
+    Response response1 = get(server.url("/"));
     assertEquals("A", response1.body().string());
     assertEquals("GET, HEAD", response1.header("Allow"));
 
-    Response response2 = get(server.getUrl("/"));
+    Response response2 = get(server.url("/"));
     assertEquals("A", response2.body().string());
     assertEquals("GET, HEAD, PUT", response2.header("Allow"));
   }
@@ -1726,11 +1721,11 @@ private RecordedRequest assertClientSuppliedCondition(MockResponse seed, String
         .addHeader("Transfer-Encoding: none")
         .setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
 
-    Response response1 = get(server.getUrl("/"));
+    Response response1 = get(server.url("/"));
     assertEquals("A", response1.body().string());
     assertEquals("identity", response1.header("Transfer-Encoding"));
 
-    Response response2 = get(server.getUrl("/"));
+    Response response2 = get(server.url("/"));
     assertEquals("A", response2.body().string());
     assertEquals("identity", response2.header("Transfer-Encoding"));
   }
@@ -1744,11 +1739,11 @@ private RecordedRequest assertClientSuppliedCondition(MockResponse seed, String
     server.enqueue(new MockResponse()
         .setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
 
-    Response response1 = get(server.getUrl("/"));
+    Response response1 = get(server.url("/"));
     assertEquals("A", response1.body().string());
     assertEquals("199 test danger", response1.header("Warning"));
 
-    Response response2 = get(server.getUrl("/"));
+    Response response2 = get(server.url("/"));
     assertEquals("A", response2.body().string());
     assertEquals(null, response2.header("Warning"));
   }
@@ -1762,18 +1757,18 @@ private RecordedRequest assertClientSuppliedCondition(MockResponse seed, String
     server.enqueue(new MockResponse()
         .setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
 
-    Response response1 = get(server.getUrl("/"));
+    Response response1 = get(server.url("/"));
     assertEquals("A", response1.body().string());
     assertEquals("299 test danger", response1.header("Warning"));
 
-    Response response2 = get(server.getUrl("/"));
+    Response response2 = get(server.url("/"));
     assertEquals("A", response2.body().string());
     assertEquals("299 test danger", response2.header("Warning"));
   }
 
-  public void assertCookies(URL url, String... expectedCookies) throws Exception {
+  public void assertCookies(HttpUrl url, String... expectedCookies) throws Exception {
     List<String> actualCookies = new ArrayList<>();
-    for (HttpCookie cookie : cookieManager.getCookieStore().get(url.toURI())) {
+    for (HttpCookie cookie : cookieManager.getCookieStore().get(url.uri())) {
       actualCookies.add(cookie.toString());
     }
     assertEquals(Arrays.asList(expectedCookies), actualCookies);
@@ -1781,10 +1776,10 @@ public void assertCookies(URL url, String... expectedCookies) throws Exception {
 
   @Test public void doNotCachePartialResponse() throws Exception  {
     assertNotCached(new MockResponse()
-            .setResponseCode(HttpURLConnection.HTTP_PARTIAL)
-            .addHeader("Date: " + formatDate(0, TimeUnit.HOURS))
-            .addHeader("Content-Range: bytes 100-100/200")
-            .addHeader("Cache-Control: max-age=60"));
+        .setResponseCode(HttpURLConnection.HTTP_PARTIAL)
+        .addHeader("Date: " + formatDate(0, TimeUnit.HOURS))
+        .addHeader("Content-Range: bytes 100-100/200")
+        .addHeader("Cache-Control: max-age=60"));
   }
 
   @Test public void conditionalHitUpdatesCache() throws Exception {
@@ -1800,18 +1795,18 @@ public void assertCookies(URL url, String... expectedCookies) throws Exception {
         .setBody("B"));
 
     // cache miss; seed the cache
-    Response response1 = get(server.getUrl("/a"));
+    Response response1 = get(server.url("/a"));
     assertEquals("A", response1.body().string());
     assertEquals(null, response1.header("Allow"));
 
     // conditional cache hit; update the cache
-    Response response2 = get(server.getUrl("/a"));
+    Response response2 = get(server.url("/a"));
     assertEquals(HttpURLConnection.HTTP_OK, response2.code());
     assertEquals("A", response2.body().string());
     assertEquals("GET, HEAD", response2.header("Allow"));
 
     // full cache hit
-    Response response3 = get(server.getUrl("/a"));
+    Response response3 = get(server.url("/a"));
     assertEquals("A", response3.body().string());
     assertEquals("GET, HEAD", response3.header("Allow"));
 
@@ -1824,10 +1819,9 @@ public void assertCookies(URL url, String... expectedCookies) throws Exception {
         .addHeader("Cache-Control: max-age=30")
         .addHeader("Date: " + formatDate(0, TimeUnit.MINUTES)));
 
-    assertEquals("A", get(server.getUrl("/")).body().string());
+    assertEquals("A", get(server.url("/")).body().string());
     Request request = new Request.Builder()
-        .url(server.getUrl("/"))
-        .header("Cache-Control", "only-if-cached")
+        .url(server.url("/")).header("Cache-Control", "only-if-cached")
         .build();
     Response response = client.newCall(request).execute();
     assertEquals("A", response.body().string());
@@ -1843,8 +1837,8 @@ public void assertCookies(URL url, String... expectedCookies) throws Exception {
         .addHeader("Cache-Control: max-age=30")
         .addHeader("Date: " + formatDate(0, TimeUnit.MINUTES)));
 
-    assertEquals("A", get(server.getUrl("/")).body().string());
-    Response response = get(server.getUrl("/"));
+    assertEquals("A", get(server.url("/")).body().string());
+    Response response = get(server.url("/"));
     assertEquals("B", response.body().string());
   }
 
@@ -1856,8 +1850,8 @@ public void assertCookies(URL url, String... expectedCookies) throws Exception {
     server.enqueue(new MockResponse()
         .setResponseCode(304));
 
-    assertEquals("A", get(server.getUrl("/")).body().string());
-    Response response = get(server.getUrl("/"));
+    assertEquals("A", get(server.url("/")).body().string());
+    Response response = get(server.url("/"));
     assertEquals("A", response.body().string());
   }
 
@@ -1865,7 +1859,7 @@ public void assertCookies(URL url, String... expectedCookies) throws Exception {
     server.enqueue(new MockResponse()
         .setBody("A"));
 
-    Response response = get(server.getUrl("/"));
+    Response response = get(server.url("/"));
     assertEquals("A", response.body().string());
   }
 
@@ -1877,7 +1871,7 @@ public void assertCookies(URL url, String... expectedCookies) throws Exception {
         .setHeaders(headers.build())
         .setBody("body"));
 
-    Response response = get(server.getUrl("/"));
+    Response response = get(server.url("/"));
     assertEquals("A", response.header(""));
   }
 
@@ -1895,7 +1889,7 @@ public void assertCookies(URL url, String... expectedCookies) throws Exception {
         .clearHeaders()
         .setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
 
-    URL url = server.getUrl("/");
+    HttpUrl url = server.url("/");
     String urlKey = Util.md5Hex(url.toString());
     String entryMetadata = ""
         + "" + url + "\n"
@@ -1932,7 +1926,7 @@ public void assertCookies(URL url, String... expectedCookies) throws Exception {
     writeFile(cache.getDirectory(), urlKey + ".0", entryMetadata);
     writeFile(cache.getDirectory(), urlKey + ".1", entryBody);
     writeFile(cache.getDirectory(), "journal", journalBody);
-    cache = new Cache(cache.getDirectory(), Integer.MAX_VALUE);
+    cache = new Cache(cache.getDirectory(), Integer.MAX_VALUE, fileSystem);
     client.setCache(cache);
 
     Response response = get(url);
@@ -1948,7 +1942,7 @@ public void assertCookies(URL url, String... expectedCookies) throws Exception {
     server.enqueue(new MockResponse()
         .setBody("B"));
 
-    URL url = server.getUrl("/");
+    HttpUrl url = server.url("/");
     assertEquals("A", get(url).body().string());
     client.getCache().evictAll();
     assertEquals(0, client.getCache().getSize());
@@ -1963,7 +1957,7 @@ public void assertCookies(URL url, String... expectedCookies) throws Exception {
         .setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
 
     // Seed the cache.
-    URL url = server.getUrl("/");
+    HttpUrl url = server.url("/");
     assertEquals("A", get(url).body().string());
 
     final AtomicReference<String> ifNoneMatch = new AtomicReference<>();
@@ -1985,7 +1979,7 @@ public void assertCookies(URL url, String... expectedCookies) throws Exception {
         .setBody("A"));
 
     // Seed the cache.
-    URL url = server.getUrl("/");
+    HttpUrl url = server.url("/");
     assertEquals("A", get(url).body().string());
 
     // Confirm the interceptor isn't exercised.
@@ -2001,17 +1995,17 @@ public void assertCookies(URL url, String... expectedCookies) throws Exception {
     // Put some responses in the cache.
     server.enqueue(new MockResponse()
         .setBody("a"));
-    URL urlA = server.getUrl("/a");
+    HttpUrl urlA = server.url("/a");
     assertEquals("a", get(urlA).body().string());
 
     server.enqueue(new MockResponse()
         .setBody("b"));
-    URL urlB = server.getUrl("/b");
+    HttpUrl urlB = server.url("/b");
     assertEquals("b", get(urlB).body().string());
 
     server.enqueue(new MockResponse()
         .setBody("c"));
-    URL urlC = server.getUrl("/c");
+    HttpUrl urlC = server.url("/c");
     assertEquals("c", get(urlC).body().string());
 
     // Confirm the iterator returns those responses...
@@ -2037,7 +2031,7 @@ public void assertCookies(URL url, String... expectedCookies) throws Exception {
     server.enqueue(new MockResponse()
         .addHeader("Cache-Control: max-age=60")
         .setBody("a"));
-    URL url = server.getUrl("/a");
+    HttpUrl url = server.url("/a");
     assertEquals("a", get(url).body().string());
 
     // Remove it with iteration.
@@ -2055,7 +2049,7 @@ public void assertCookies(URL url, String... expectedCookies) throws Exception {
     // Put a response in the cache.
     server.enqueue(new MockResponse()
         .setBody("a"));
-    URL url = server.getUrl("/a");
+    HttpUrl url = server.url("/a");
     assertEquals("a", get(url).body().string());
 
     Iterator<String> i = cache.urls();
@@ -2071,7 +2065,7 @@ public void assertCookies(URL url, String... expectedCookies) throws Exception {
     // Put a response in the cache.
     server.enqueue(new MockResponse()
         .setBody("a"));
-    URL url = server.getUrl("/a");
+    HttpUrl url = server.url("/a");
     assertEquals("a", get(url).body().string());
 
     Iterator<String> i = cache.urls();
@@ -2090,7 +2084,7 @@ public void assertCookies(URL url, String... expectedCookies) throws Exception {
     // Put a response in the cache.
     server.enqueue(new MockResponse()
         .setBody("a"));
-    URL url = server.getUrl("/a");
+    HttpUrl url = server.url("/a");
     assertEquals("a", get(url).body().string());
 
     // The URL will remain available if hasNext() returned true...
@@ -2109,7 +2103,7 @@ public void assertCookies(URL url, String... expectedCookies) throws Exception {
     // Put a response in the cache.
     server.enqueue(new MockResponse()
         .setBody("a"));
-    URL url = server.getUrl("/a");
+    HttpUrl url = server.url("/a");
     assertEquals("a", get(url).body().string());
 
     Iterator<String> i = cache.urls();
@@ -2124,7 +2118,32 @@ public void assertCookies(URL url, String... expectedCookies) throws Exception {
     }
   }
 
-  private Response get(URL url) throws IOException {
+  /** Test https://github.com/square/okhttp/issues/1712. */
+  @Test public void conditionalMissUpdatesCache() throws Exception {
+    server.enqueue(new MockResponse()
+        .addHeader("ETag: v1")
+        .setBody("A"));
+    server.enqueue(new MockResponse()
+        .setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
+    server.enqueue(new MockResponse()
+        .addHeader("ETag: v2")
+        .setBody("B"));
+    server.enqueue(new MockResponse()
+        .setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
+
+    HttpUrl url = server.url("/");
+    assertEquals("A", get(url).body().string());
+    assertEquals("A", get(url).body().string());
+    assertEquals("B", get(url).body().string());
+    assertEquals("B", get(url).body().string());
+
+    assertEquals(null, server.takeRequest().getHeader("If-None-Match"));
+    assertEquals("v1", server.takeRequest().getHeader("If-None-Match"));
+    assertEquals("v1", server.takeRequest().getHeader("If-None-Match"));
+    assertEquals("v2", server.takeRequest().getHeader("If-None-Match"));
+  }
+
+  private Response get(HttpUrl url) throws IOException {
     Request request = new Request.Builder()
         .url(url)
         .build();
@@ -2133,7 +2152,7 @@ private Response get(URL url) throws IOException {
 
 
   private void writeFile(File directory, String file, String content) throws IOException {
-    BufferedSink sink = Okio.buffer(Okio.sink(new File(directory, file)));
+    BufferedSink sink = Okio.buffer(fileSystem.sink(new File(directory, file)));
     sink.writeUtf8(content);
     sink.close();
   }
@@ -2158,7 +2177,7 @@ private void assertNotCached(MockResponse response) throws Exception {
     server.enqueue(new MockResponse()
         .setBody("B"));
 
-    URL url = server.getUrl("/");
+    HttpUrl url = server.url("/");
     assertEquals("A", get(url).body().string());
     assertEquals("B", get(url).body().string());
   }
@@ -2177,7 +2196,7 @@ private RecordedRequest assertConditionallyCached(MockResponse response) throws
         .setStatus("HTTP/1.1 200 C-OK")
         .setBody("C"));
 
-    URL valid = server.getUrl("/valid");
+    HttpUrl valid = server.url("/valid");
     Response response1 = get(valid);
     assertEquals("A", response1.body().string());
     assertEquals(HttpURLConnection.HTTP_OK, response1.code());
@@ -2187,7 +2206,7 @@ private RecordedRequest assertConditionallyCached(MockResponse response) throws
     assertEquals(HttpURLConnection.HTTP_OK, response2.code());
     assertEquals("A-OK", response2.message());
 
-    URL invalid = server.getUrl("/invalid");
+    HttpUrl invalid = server.url("/invalid");
     Response response3 = get(invalid);
     assertEquals("B", response3.body().string());
     assertEquals(HttpURLConnection.HTTP_OK, response3.code());
@@ -2205,7 +2224,7 @@ private void assertFullyCached(MockResponse response) throws Exception {
     server.enqueue(response.setBody("A"));
     server.enqueue(response.setBody("B"));
 
-    URL url = server.getUrl("/");
+    HttpUrl url = server.url("/");
     assertEquals("A", get(url).body().string());
     assertEquals("A", get(url).body().string());
   }
diff --git a/okhttp-tests/src/test/java/com/squareup/okhttp/CallTest.java b/okhttp-tests/src/test/java/com/squareup/okhttp/CallTest.java
index 868c33cf49..051eae4b07 100644
--- a/okhttp-tests/src/test/java/com/squareup/okhttp/CallTest.java
+++ b/okhttp-tests/src/test/java/com/squareup/okhttp/CallTest.java
@@ -17,28 +17,34 @@
 
 import com.squareup.okhttp.internal.DoubleInetAddressNetwork;
 import com.squareup.okhttp.internal.Internal;
-import com.squareup.okhttp.internal.RecordingHostnameVerifier;
 import com.squareup.okhttp.internal.RecordingOkAuthenticator;
 import com.squareup.okhttp.internal.SingleInetAddressNetwork;
 import com.squareup.okhttp.internal.SslContextBuilder;
+import com.squareup.okhttp.internal.Util;
 import com.squareup.okhttp.internal.Version;
+import com.squareup.okhttp.internal.io.FileSystem;
+import com.squareup.okhttp.internal.io.InMemoryFileSystem;
 import com.squareup.okhttp.mockwebserver.Dispatcher;
 import com.squareup.okhttp.mockwebserver.MockResponse;
+import com.squareup.okhttp.mockwebserver.MockWebServer;
 import com.squareup.okhttp.mockwebserver.RecordedRequest;
 import com.squareup.okhttp.mockwebserver.SocketPolicy;
-import com.squareup.okhttp.mockwebserver.rule.MockWebServerRule;
+import com.squareup.okhttp.testing.RecordingHostnameVerifier;
+import java.io.File;
 import java.io.IOException;
 import java.io.InputStream;
 import java.io.InterruptedIOException;
 import java.net.CookieManager;
 import java.net.HttpCookie;
 import java.net.HttpURLConnection;
-import java.net.SocketException;
-import java.net.URL;
+import java.net.InetAddress;
+import java.net.InetSocketAddress;
+import java.net.ProtocolException;
+import java.net.ServerSocket;
+import java.net.UnknownServiceException;
 import java.security.cert.Certificate;
 import java.util.ArrayList;
 import java.util.Arrays;
-import java.util.Collection;
 import java.util.List;
 import java.util.concurrent.BlockingQueue;
 import java.util.concurrent.Callable;
@@ -50,6 +56,7 @@
 import java.util.concurrent.TimeUnit;
 import java.util.concurrent.atomic.AtomicBoolean;
 import java.util.concurrent.atomic.AtomicReference;
+import javax.net.ServerSocketFactory;
 import javax.net.ssl.SSLContext;
 import javax.net.ssl.SSLHandshakeException;
 import javax.net.ssl.SSLPeerUnverifiedException;
@@ -63,10 +70,8 @@
 import okio.Okio;
 import org.junit.After;
 import org.junit.Before;
-import org.junit.Ignore;
 import org.junit.Rule;
 import org.junit.Test;
-import org.junit.rules.TemporaryFolder;
 import org.junit.rules.TestRule;
 import org.junit.rules.Timeout;
 
@@ -80,29 +85,25 @@
 import static org.junit.Assert.fail;
 
 public final class CallTest {
-  private static final SSLContext sslContext = SslContextBuilder.localhost();
-
-  @Rule public final TemporaryFolder tempDir = new TemporaryFolder();
   @Rule public final TestRule timeout = new Timeout(30_000);
+  @Rule public final MockWebServer server = new MockWebServer();
+  @Rule public final MockWebServer server2 = new MockWebServer();
 
-  @Rule public final MockWebServerRule server = new MockWebServerRule();
-  @Rule public final MockWebServerRule server2 = new MockWebServerRule();
+  private SSLContext sslContext = SslContextBuilder.localhost();
+  private FileSystem fileSystem = new InMemoryFileSystem();
   private OkHttpClient client = new OkHttpClient();
   private RecordingCallback callback = new RecordingCallback();
   private TestLogHandler logHandler = new TestLogHandler();
-  private Cache cache;
+  private Cache cache = new Cache(new File("/cache/"), Integer.MAX_VALUE, fileSystem);
+  private ServerSocket nullServer;
 
   @Before public void setUp() throws Exception {
-    client = new OkHttpClient();
-    callback = new RecordingCallback();
-    logHandler = new TestLogHandler();
-
-    cache = new Cache(tempDir.getRoot(), Integer.MAX_VALUE);
     logger.addHandler(logHandler);
   }
 
   @After public void tearDown() throws Exception {
     cache.delete();
+    Util.closeQuietly(nullServer);
     logger.removeHandler(logHandler);
   }
 
@@ -110,7 +111,7 @@
     server.enqueue(new MockResponse().setBody("abc").addHeader("Content-Type: text/plain"));
 
     Request request = new Request.Builder()
-        .url(server.getUrl("/"))
+        .url(server.url("/"))
         .header("User-Agent", "SyncApiTest")
         .build();
 
@@ -127,30 +128,35 @@
     assertNull(recordedRequest.getHeader("Content-Length"));
   }
 
-  @Test public void lazilyEvaluateRequestUrl() throws Exception {
-    server.enqueue(new MockResponse().setBody("abc"));
+  @Test public void buildRequestUsingHttpUrl() throws Exception {
+    server.enqueue(new MockResponse());
 
-    Request request1 = new Request.Builder()
-        .url("foo://bar?baz")
-        .build();
-    Request request2 = request1.newBuilder()
-        .url(server.getUrl("/"))
+    HttpUrl httpUrl = server.url("/");
+    Request request = new Request.Builder()
+        .url(httpUrl)
         .build();
-    executeSynchronously(request2)
-        .assertCode(200)
-        .assertSuccessful()
-        .assertBody("abc");
+    assertEquals(httpUrl, request.httpUrl());
+
+    executeSynchronously(request).assertSuccessful();
   }
 
-  @Ignore // TODO(jwilson): fix.
   @Test public void invalidScheme() throws Exception {
+    Request.Builder requestBuilder = new Request.Builder();
     try {
-      Request request = new Request.Builder()
-          .url("ftp://hostname/path")
-          .build();
-      executeSynchronously(request);
+      requestBuilder.url("ftp://hostname/path");
       fail();
     } catch (IllegalArgumentException expected) {
+      assertEquals(expected.getMessage(), "unexpected url: ftp://hostname/path");
+    }
+  }
+
+  @Test public void invalidPort() throws Exception {
+    Request.Builder requestBuilder = new Request.Builder();
+    try {
+      requestBuilder.url("http://localhost:65536/");
+      fail();
+    } catch (IllegalArgumentException expected) {
+      assertEquals(expected.getMessage(), "unexpected url: http://localhost:65536/");
     }
   }
 
@@ -158,7 +164,7 @@
     server.enqueue(new MockResponse().setResponseCode(500));
 
     Request request = new Request.Builder()
-        .url(server.getUrl("/"))
+        .url(server.url("/"))
         .build();
 
     executeSynchronously(request)
@@ -190,7 +196,7 @@
     server.enqueue(new MockResponse().addHeader("Content-Type: text/plain"));
 
     Request request = new Request.Builder()
-        .url(server.getUrl("/"))
+        .url(server.url("/"))
         .head()
         .header("User-Agent", "SyncApiTest")
         .build();
@@ -220,7 +226,7 @@
     server.enqueue(new MockResponse().setBody("abc"));
 
     Request request = new Request.Builder()
-        .url(server.getUrl("/"))
+        .url(server.url("/"))
         .post(RequestBody.create(MediaType.parse("text/plain"), "def"))
         .build();
 
@@ -249,8 +255,8 @@
     server.enqueue(new MockResponse().setBody("abc"));
 
     Request request = new Request.Builder()
-        .url(server.getUrl("/"))
-        .method("POST", null)
+        .url(server.url("/"))
+        .method("POST", RequestBody.create(null, new byte[0]))
         .build();
 
     executeSynchronously(request)
@@ -308,7 +314,7 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
     server.enqueue(new MockResponse());
 
     Request request = new Request.Builder()
-        .url(server.getUrl("/"))
+        .url(server.url("/"))
         .method("POST", RequestBody.create(null, body))
         .build();
 
@@ -338,7 +344,7 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
     String credential = Credentials.basic("jesse", "secret");
     client.setAuthenticator(new RecordingOkAuthenticator(credential));
 
-    Request request = new Request.Builder().url(server.getUrl("/")).build();
+    Request request = new Request.Builder().url(server.url("/")).build();
     executeSynchronously(request)
         .assertCode(200)
         .assertBody("Success!");
@@ -353,7 +359,7 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
     client.setAuthenticator(new RecordingOkAuthenticator(credential));
 
     try {
-      client.newCall(new Request.Builder().url(server.getUrl("/0")).build()).execute();
+      client.newCall(new Request.Builder().url(server.url("/0")).build()).execute();
       fail();
     } catch (IOException expected) {
       assertEquals("Too many follow-up requests: 21", expected.getMessage());
@@ -364,7 +370,7 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
     server.enqueue(new MockResponse().setBody("abc"));
 
     Request request = new Request.Builder()
-        .url(server.getUrl("/"))
+        .url(server.url("/"))
         .delete()
         .build();
 
@@ -389,11 +395,28 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
     delete();
   }
 
+  @Test public void deleteWithRequestBody() throws Exception {
+    server.enqueue(new MockResponse().setBody("abc"));
+
+    Request request = new Request.Builder()
+        .url(server.url("/"))
+        .method("DELETE", RequestBody.create(MediaType.parse("text/plain"), "def"))
+        .build();
+
+    executeSynchronously(request)
+        .assertCode(200)
+        .assertBody("abc");
+
+    RecordedRequest recordedRequest = server.takeRequest();
+    assertEquals("DELETE", recordedRequest.getMethod());
+    assertEquals("def", recordedRequest.getBody().readUtf8());
+  }
+
   @Test public void put() throws Exception {
     server.enqueue(new MockResponse().setBody("abc"));
 
     Request request = new Request.Builder()
-        .url(server.getUrl("/"))
+        .url(server.url("/"))
         .put(RequestBody.create(MediaType.parse("text/plain"), "def"))
         .build();
 
@@ -422,7 +445,7 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
     server.enqueue(new MockResponse().setBody("abc"));
 
     Request request = new Request.Builder()
-        .url(server.getUrl("/"))
+        .url(server.url("/"))
         .patch(RequestBody.create(MediaType.parse("text/plain"), "def"))
         .build();
 
@@ -451,7 +474,7 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
     server.enqueue(new MockResponse());
 
     Request request = new Request.Builder()
-        .url(server.getUrl("/"))
+        .url(server.url("/"))
         .method("POST", RequestBody.create(null, "abc"))
         .build();
 
@@ -469,7 +492,7 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
         .addHeader("Content-Type: text/plain"));
 
     Request request = new Request.Builder()
-        .url(server.getUrl("/"))
+        .url(server.url("/"))
         .header("User-Agent", "SyncApiTest")
         .build();
 
@@ -499,7 +522,7 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
         .addHeader("Content-Type: text/plain"));
 
     Request request = new Request.Builder()
-        .url(server.getUrl("/"))
+        .url(server.url("/"))
         .header("User-Agent", "SyncApiTest")
         .build();
 
@@ -529,12 +552,12 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
         .addHeader("Content-Type: text/plain"));
 
     Request request = new Request.Builder()
-        .url(server.getUrl("/"))
+        .url(server.url("/"))
         .header("User-Agent", "AsyncApiTest")
         .build();
     client.newCall(request).enqueue(callback);
 
-    callback.await(request.url())
+    callback.await(request.httpUrl())
         .assertCode(200)
         .assertHeader("Content-Type", "text/plain")
         .assertBody("abc");
@@ -546,7 +569,7 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
     server.enqueue(new MockResponse());
 
     Request request = new Request.Builder()
-        .url(server.getUrl("/secret"))
+        .url(server.url("/secret"))
         .build();
 
     client.newCall(request).enqueue(new Callback() {
@@ -559,7 +582,7 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
       }
     });
 
-    assertEquals("INFO: Callback failure for call to " + server.getUrl("/") + "...",
+    assertEquals("INFO: Callback failure for call to " + server.url("/") + "...",
         logHandler.take());
   }
 
@@ -568,13 +591,13 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
     server.enqueue(new MockResponse().setBody("def"));
     server.enqueue(new MockResponse().setBody("ghi"));
 
-    executeSynchronously(new Request.Builder().url(server.getUrl("/a")).build())
+    executeSynchronously(new Request.Builder().url(server.url("/a")).build())
         .assertBody("abc");
 
-    executeSynchronously(new Request.Builder().url(server.getUrl("/b")).build())
+    executeSynchronously(new Request.Builder().url(server.url("/b")).build())
         .assertBody("def");
 
-    executeSynchronously(new Request.Builder().url(server.getUrl("/c")).build())
+    executeSynchronously(new Request.Builder().url(server.url("/c")).build())
         .assertBody("ghi");
 
     assertEquals(0, server.takeRequest().getSequenceNumber());
@@ -587,14 +610,14 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
     server.enqueue(new MockResponse().setBody("def"));
     server.enqueue(new MockResponse().setBody("ghi"));
 
-    client.newCall(new Request.Builder().url(server.getUrl("/a")).build()).enqueue(callback);
-    callback.await(server.getUrl("/a")).assertBody("abc");
+    client.newCall(new Request.Builder().url(server.url("/a")).build()).enqueue(callback);
+    callback.await(server.url("/a")).assertBody("abc");
 
-    client.newCall(new Request.Builder().url(server.getUrl("/b")).build()).enqueue(callback);
-    callback.await(server.getUrl("/b")).assertBody("def");
+    client.newCall(new Request.Builder().url(server.url("/b")).build()).enqueue(callback);
+    callback.await(server.url("/b")).assertBody("def");
 
-    client.newCall(new Request.Builder().url(server.getUrl("/c")).build()).enqueue(callback);
-    callback.await(server.getUrl("/c")).assertBody("ghi");
+    client.newCall(new Request.Builder().url(server.url("/c")).build()).enqueue(callback);
+    callback.await(server.url("/c")).assertBody("ghi");
 
     assertEquals(0, server.takeRequest().getSequenceNumber());
     assertEquals(1, server.takeRequest().getSequenceNumber());
@@ -605,7 +628,7 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
     server.enqueue(new MockResponse().setBody("abc"));
     server.enqueue(new MockResponse().setBody("def"));
 
-    Request request = new Request.Builder().url(server.getUrl("/a")).build();
+    Request request = new Request.Builder().url(server.url("/a")).build();
     client.newCall(request).enqueue(new Callback() {
       @Override public void onFailure(Request request, IOException e) {
         throw new AssertionError();
@@ -618,11 +641,11 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
         assertEquals('c', bytes.read());
 
         // This request will share a connection with 'A' cause it's all done.
-        client.newCall(new Request.Builder().url(server.getUrl("/b")).build()).enqueue(callback);
+        client.newCall(new Request.Builder().url(server.url("/b")).build()).enqueue(callback);
       }
     });
 
-    callback.await(server.getUrl("/b")).assertCode(200).assertBody("def");
+    callback.await(server.url("/b")).assertCode(200).assertBody("def");
     assertEquals(0, server.takeRequest().getSequenceNumber()); // New connection.
     assertEquals(1, server.takeRequest().getSequenceNumber()); // Connection reuse!
   }
@@ -633,11 +656,11 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
 
     // First request: time out after 1000ms.
     client.setReadTimeout(1000, TimeUnit.MILLISECONDS);
-    executeSynchronously(new Request.Builder().url(server.getUrl("/a")).build()).assertBody("abc");
+    executeSynchronously(new Request.Builder().url(server.url("/a")).build()).assertBody("abc");
 
     // Second request: time out after 250ms.
     client.setReadTimeout(250, TimeUnit.MILLISECONDS);
-    Request request = new Request.Builder().url(server.getUrl("/b")).build();
+    Request request = new Request.Builder().url(server.url("/b")).build();
     Response response = client.newCall(request).execute();
     BufferedSource bodySource = response.body().source();
     assertEquals('d', bodySource.readByte());
@@ -655,6 +678,7 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
     }
   }
 
+  // https://github.com/square/okhttp/issues/442
   @Test public void timeoutsNotRetried() throws Exception {
     server.enqueue(new MockResponse()
         .setSocketPolicy(SocketPolicy.NO_RESPONSE));
@@ -664,7 +688,7 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
     Internal.instance.setNetwork(client, new DoubleInetAddressNetwork());
     client.setReadTimeout(100, TimeUnit.MILLISECONDS);
 
-    Request request = new Request.Builder().url(server.getUrl("/")).build();
+    Request request = new Request.Builder().url(server.url("/")).build();
     try {
       // If this succeeds, too many requests were made.
       client.newCall(request).execute();
@@ -673,8 +697,74 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
     }
   }
 
+  @Test public void reusedSinksGetIndependentTimeoutInstances() throws Exception {
+    server.enqueue(new MockResponse());
+    server.enqueue(new MockResponse());
+
+    // Call 1: set a deadline on the request body.
+    RequestBody requestBody1 = new RequestBody() {
+      @Override public MediaType contentType() {
+        return MediaType.parse("text/plain");
+      }
+      @Override public void writeTo(BufferedSink sink) throws IOException {
+        sink.writeUtf8("abc");
+        sink.timeout().deadline(5, TimeUnit.SECONDS);
+      }
+    };
+    Request request1 = new Request.Builder()
+        .url(server.url("/"))
+        .method("POST", requestBody1)
+        .build();
+    Response response1 = client.newCall(request1).execute();
+    assertEquals(200, response1.code());
+
+    // Call 2: check for the absence of a deadline on the request body.
+    RequestBody requestBody2 = new RequestBody() {
+      @Override public MediaType contentType() {
+        return MediaType.parse("text/plain");
+      }
+      @Override public void writeTo(BufferedSink sink) throws IOException {
+        assertFalse(sink.timeout().hasDeadline());
+        sink.writeUtf8("def");
+      }
+    };
+    Request request2 = new Request.Builder()
+        .url(server.url("/"))
+        .method("POST", requestBody2)
+        .build();
+    Response response2 = client.newCall(request2).execute();
+    assertEquals(200, response2.code());
+
+    // Use sequence numbers to confirm the connection was pooled.
+    assertEquals(0, server.takeRequest().getSequenceNumber());
+    assertEquals(1, server.takeRequest().getSequenceNumber());
+  }
+
+  @Test public void reusedSourcesGetIndependentTimeoutInstances() throws Exception {
+    server.enqueue(new MockResponse().setBody("abc"));
+    server.enqueue(new MockResponse().setBody("def"));
+
+    // Call 1: set a deadline on the response body.
+    Request request1 = new Request.Builder().url(server.url("/")).build();
+    Response response1 = client.newCall(request1).execute();
+    BufferedSource body1 = response1.body().source();
+    assertEquals("abc", body1.readUtf8());
+    body1.timeout().deadline(5, TimeUnit.SECONDS);
+
+    // Call 2: check for the absence of a deadline on the request body.
+    Request request2 = new Request.Builder().url(server.url("/")).build();
+    Response response2 = client.newCall(request2).execute();
+    BufferedSource body2 = response2.body().source();
+    assertEquals("def", body2.readUtf8());
+    assertFalse(body2.timeout().hasDeadline());
+
+    // Use sequence numbers to confirm the connection was pooled.
+    assertEquals(0, server.takeRequest().getSequenceNumber());
+    assertEquals(1, server.takeRequest().getSequenceNumber());
+  }
+
   @Test public void tls() throws Exception {
-    server.get().useHttps(sslContext.getSocketFactory(), false);
+    server.useHttps(sslContext.getSocketFactory(), false);
     server.enqueue(new MockResponse()
         .setBody("abc")
         .addHeader("Content-Type: text/plain"));
@@ -682,12 +772,12 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
     client.setSslSocketFactory(sslContext.getSocketFactory());
     client.setHostnameVerifier(new RecordingHostnameVerifier());
 
-    executeSynchronously(new Request.Builder().url(server.getUrl("/")).build())
+    executeSynchronously(new Request.Builder().url(server.url("/")).build())
         .assertHandshake();
   }
 
   @Test public void tls_Async() throws Exception {
-    server.get().useHttps(sslContext.getSocketFactory(), false);
+    server.useHttps(sslContext.getSocketFactory(), false);
     server.enqueue(new MockResponse()
         .setBody("abc")
         .addHeader("Content-Type: text/plain"));
@@ -696,11 +786,11 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
     client.setHostnameVerifier(new RecordingHostnameVerifier());
 
     Request request = new Request.Builder()
-        .url(server.getUrl("/"))
+        .url(server.url("/"))
         .build();
     client.newCall(request).enqueue(callback);
 
-    callback.await(request.url()).assertHandshake();
+    callback.await(request.httpUrl()).assertHandshake();
   }
 
   @Test public void recoverWhenRetryOnConnectionFailureIsTrue() throws Exception {
@@ -710,7 +800,7 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
     Internal.instance.setNetwork(client, new DoubleInetAddressNetwork());
     assertTrue(client.getRetryOnConnectionFailure());
 
-    Request request = new Request.Builder().url(server.getUrl("/")).build();
+    Request request = new Request.Builder().url(server.url("/")).build();
     Response response = client.newCall(request).execute();
     assertEquals("retry success", response.body().string());
   }
@@ -722,7 +812,7 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
     Internal.instance.setNetwork(client, new DoubleInetAddressNetwork());
     client.setRetryOnConnectionFailure(false);
 
-    Request request = new Request.Builder().url(server.getUrl("/")).build();
+    Request request = new Request.Builder().url(server.url("/")).build();
     try {
       // If this succeeds, too many requests were made.
       client.newCall(request).execute();
@@ -732,7 +822,7 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
   }
 
   @Test public void recoverFromTlsHandshakeFailure() throws Exception {
-    server.get().useHttps(sslContext.getSocketFactory(), false);
+    server.useHttps(sslContext.getSocketFactory(), false);
     server.enqueue(new MockResponse().setSocketPolicy(SocketPolicy.FAIL_HANDSHAKE));
     server.enqueue(new MockResponse().setBody("abc"));
 
@@ -740,7 +830,7 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
     client.setHostnameVerifier(new RecordingHostnameVerifier());
     Internal.instance.setNetwork(client, new SingleInetAddressNetwork());
 
-    executeSynchronously(new Request.Builder().url(server.getUrl("/")).build())
+    executeSynchronously(new Request.Builder().url(server.url("/")).build())
         .assertBody("abc");
   }
 
@@ -753,7 +843,7 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
       return;
     }
 
-    server.get().useHttps(sslContext.getSocketFactory(), false);
+    server.useHttps(sslContext.getSocketFactory(), false);
     server.enqueue(new MockResponse().setSocketPolicy(SocketPolicy.FAIL_HANDSHAKE));
 
     RecordingSSLSocketFactory clientSocketFactory =
@@ -762,7 +852,7 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
     client.setHostnameVerifier(new RecordingHostnameVerifier());
     Internal.instance.setNetwork(client, new SingleInetAddressNetwork());
 
-    Request request = new Request.Builder().url(server.getUrl("/")).build();
+    Request request = new Request.Builder().url(server.url("/")).build();
     try {
       client.newCall(request).execute();
       fail();
@@ -777,7 +867,7 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
   }
 
   @Test public void recoverFromTlsHandshakeFailure_Async() throws Exception {
-    server.get().useHttps(sslContext.getSocketFactory(), false);
+    server.useHttps(sslContext.getSocketFactory(), false);
     server.enqueue(new MockResponse().setSocketPolicy(SocketPolicy.FAIL_HANDSHAKE));
     server.enqueue(new MockResponse().setBody("abc"));
 
@@ -785,24 +875,24 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
     client.setHostnameVerifier(new RecordingHostnameVerifier());
 
     Request request = new Request.Builder()
-        .url(server.getUrl("/"))
+        .url(server.url("/"))
         .build();
     client.newCall(request).enqueue(callback);
 
-    callback.await(request.url()).assertBody("abc");
+    callback.await(request.httpUrl()).assertBody("abc");
   }
 
   @Test public void noRecoveryFromTlsHandshakeFailureWhenTlsFallbackIsDisabled() throws Exception {
     client.setConnectionSpecs(Arrays.asList(ConnectionSpec.MODERN_TLS, ConnectionSpec.CLEARTEXT));
 
-    server.get().useHttps(sslContext.getSocketFactory(), false);
+    server.useHttps(sslContext.getSocketFactory(), false);
     server.enqueue(new MockResponse().setSocketPolicy(SocketPolicy.FAIL_HANDSHAKE));
 
     suppressTlsFallbackScsv(client);
     client.setHostnameVerifier(new RecordingHostnameVerifier());
     Internal.instance.setNetwork(client, new SingleInetAddressNetwork());
 
-    Request request = new Request.Builder().url(server.getUrl("/")).build();
+    Request request = new Request.Builder().url(server.url("/")).build();
     try {
       client.newCall(request).execute();
       fail();
@@ -820,30 +910,30 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
 
     server.enqueue(new MockResponse());
 
-    Request request = new Request.Builder().url(server.getUrl("/")).build();
+    Request request = new Request.Builder().url(server.url("/")).build();
     try {
       client.newCall(request).execute();
       fail();
-    } catch (SocketException expected) {
-      assertTrue(expected.getMessage().contains("exhausted connection specs"));
+    } catch (UnknownServiceException expected) {
+      assertTrue(expected.getMessage().contains("CLEARTEXT communication not supported"));
     }
   }
 
   @Test public void setFollowSslRedirectsFalse() throws Exception {
-    server.get().useHttps(sslContext.getSocketFactory(), false);
+    server.useHttps(sslContext.getSocketFactory(), false);
     server.enqueue(new MockResponse().setResponseCode(301).addHeader("Location: http://square.com"));
 
     client.setFollowSslRedirects(false);
     client.setSslSocketFactory(sslContext.getSocketFactory());
     client.setHostnameVerifier(new RecordingHostnameVerifier());
 
-    Request request = new Request.Builder().url(server.getUrl("/")).build();
+    Request request = new Request.Builder().url(server.url("/")).build();
     Response response = client.newCall(request).execute();
     assertEquals(301, response.code());
   }
 
   @Test public void matchingPinnedCertificate() throws Exception {
-    server.get().useHttps(sslContext.getSocketFactory(), false);
+    server.useHttps(sslContext.getSocketFactory(), false);
     server.enqueue(new MockResponse());
     server.enqueue(new MockResponse());
 
@@ -851,22 +941,22 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
     client.setHostnameVerifier(new RecordingHostnameVerifier());
 
     // Make a first request without certificate pinning. Use it to collect certificates to pin.
-    Request request1 = new Request.Builder().url(server.getUrl("/")).build();
+    Request request1 = new Request.Builder().url(server.url("/")).build();
     Response response1 = client.newCall(request1).execute();
     CertificatePinner.Builder certificatePinnerBuilder = new CertificatePinner.Builder();
     for (Certificate certificate : response1.handshake().peerCertificates()) {
-      certificatePinnerBuilder.add(server.get().getHostName(), CertificatePinner.pin(certificate));
+      certificatePinnerBuilder.add(server.getHostName(), CertificatePinner.pin(certificate));
     }
 
     // Make another request with certificate pinning. It should complete normally.
     client.setCertificatePinner(certificatePinnerBuilder.build());
-    Request request2 = new Request.Builder().url(server.getUrl("/")).build();
+    Request request2 = new Request.Builder().url(server.url("/")).build();
     Response response2 = client.newCall(request2).execute();
     assertNotSame(response2.handshake(), response1.handshake());
   }
 
   @Test public void unmatchingPinnedCertificate() throws Exception {
-    server.get().useHttps(sslContext.getSocketFactory(), false);
+    server.useHttps(sslContext.getSocketFactory(), false);
     server.enqueue(new MockResponse());
 
     client.setSslSocketFactory(sslContext.getSocketFactory());
@@ -874,11 +964,11 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
 
     // Pin publicobject.com's cert.
     client.setCertificatePinner(new CertificatePinner.Builder()
-        .add(server.get().getHostName(), "sha1/DmxUShsZuNiqPQsX2Oi9uv2sCnw=")
+        .add(server.getHostName(), "sha1/DmxUShsZuNiqPQsX2Oi9uv2sCnw=")
         .build());
 
     // When we pin the wrong certificate, connectivity fails.
-    Request request = new Request.Builder().url(server.getUrl("/")).build();
+    Request request = new Request.Builder().url(server.url("/")).build();
     try {
       client.newCall(request).execute();
       fail();
@@ -891,12 +981,12 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
     server.enqueue(new MockResponse().setBody("abc"));
 
     Request request = new Request.Builder()
-        .url(server.getUrl("/"))
+        .url(server.url("/"))
         .post(RequestBody.create(MediaType.parse("text/plain"), "def"))
         .build();
     client.newCall(request).enqueue(callback);
 
-    callback.await(request.url())
+    callback.await(request.httpUrl())
         .assertCode(200)
         .assertBody("abc");
 
@@ -912,12 +1002,12 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
     server.enqueue(new MockResponse().setBody("def"));
 
     // Seed the connection pool so we have something that can fail.
-    Request request1 = new Request.Builder().url(server.getUrl("/")).build();
+    Request request1 = new Request.Builder().url(server.url("/")).build();
     Response response1 = client.newCall(request1).execute();
     assertEquals("abc", response1.body().string());
 
     Request request2 = new Request.Builder()
-        .url(server.getUrl("/"))
+        .url(server.url("/"))
         .post(RequestBody.create(MediaType.parse("text/plain"), "body!"))
         .build();
     Response response2 = client.newCall(request2).execute();
@@ -945,7 +1035,7 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
     client.setCache(cache);
 
     // Store a response in the cache.
-    URL url = server.getUrl("/");
+    HttpUrl url = server.url("/");
     Request cacheStoreRequest = new Request.Builder()
         .url(url)
         .addHeader("Accept-Language", "fr-CA")
@@ -997,7 +1087,7 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
     client.setCache(cache);
 
     // Store a response in the cache.
-    URL url = server.getUrl("/");
+    HttpUrl url = server.url("/");
     Request cacheStoreRequest = new Request.Builder()
         .url(url)
         .addHeader("Accept-Language", "fr-CA")
@@ -1055,17 +1145,17 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
     client.setCache(cache);
 
     Request request1 = new Request.Builder()
-        .url(server.getUrl("/"))
+        .url(server.url("/"))
         .build();
     client.newCall(request1).enqueue(callback);
-    callback.await(request1.url()).assertCode(200).assertBody("A");
+    callback.await(request1.httpUrl()).assertCode(200).assertBody("A");
     assertNull(server.takeRequest().getHeader("If-None-Match"));
 
     Request request2 = new Request.Builder()
-        .url(server.getUrl("/"))
+        .url(server.url("/"))
         .build();
     client.newCall(request2).enqueue(callback);
-    callback.await(request2.url()).assertCode(200).assertBody("A");
+    callback.await(request2.httpUrl()).assertCode(200).assertBody("A");
     assertEquals("v1", server.takeRequest().getHeader("If-None-Match"));
   }
 
@@ -1082,7 +1172,7 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
     client.setCache(cache);
 
     Request cacheStoreRequest = new Request.Builder()
-        .url(server.getUrl("/"))
+        .url(server.url("/"))
         .addHeader("Accept-Language", "fr-CA")
         .addHeader("Accept-Charset", "UTF-8")
         .build();
@@ -1092,7 +1182,7 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
     assertNull(server.takeRequest().getHeader("If-None-Match"));
 
     Request cacheMissRequest = new Request.Builder()
-        .url(server.getUrl("/"))
+        .url(server.url("/"))
         .addHeader("Accept-Language", "en-US") // Different, but Vary says it doesn't matter.
         .addHeader("Accept-Charset", "UTF-8")
         .build();
@@ -1127,23 +1217,23 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
     client.setCache(cache);
 
     Request request1 = new Request.Builder()
-        .url(server.getUrl("/"))
+        .url(server.url("/"))
         .build();
     client.newCall(request1).enqueue(callback);
-    callback.await(request1.url()).assertCode(200).assertBody("A");
+    callback.await(request1.httpUrl()).assertCode(200).assertBody("A");
     assertNull(server.takeRequest().getHeader("If-None-Match"));
 
     Request request2 = new Request.Builder()
-        .url(server.getUrl("/"))
+        .url(server.url("/"))
         .build();
     client.newCall(request2).enqueue(callback);
-    callback.await(request2.url()).assertCode(200).assertBody("B");
+    callback.await(request2.httpUrl()).assertCode(200).assertBody("B");
     assertEquals("v1", server.takeRequest().getHeader("If-None-Match"));
   }
 
   @Test public void onlyIfCachedReturns504WhenNotCached() throws Exception {
     Request request = new Request.Builder()
-        .url(server.getUrl("/"))
+        .url(server.url("/"))
         .header("Cache-Control", "only-if-cached")
         .build();
 
@@ -1167,7 +1257,7 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
         .setBody("/b has moved!"));
     server.enqueue(new MockResponse().setBody("C"));
 
-    executeSynchronously(new Request.Builder().url(server.getUrl("/a")).build())
+    executeSynchronously(new Request.Builder().url(server.url("/a")).build())
         .assertCode(200)
         .assertBody("C")
         .priorResponse()
@@ -1190,7 +1280,7 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
     server.enqueue(new MockResponse().setBody("Page 2"));
 
     Response response = client.newCall(new Request.Builder()
-        .url(server.getUrl("/page1"))
+        .url(server.url("/page1"))
         .post(RequestBody.create(MediaType.parse("text/plain"), "Request Body"))
         .build()).execute();
     assertEquals("Page 2", response.body().string());
@@ -1207,25 +1297,25 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
     server2.enqueue(new MockResponse().setBody("Page 2"));
     server.enqueue(new MockResponse()
         .setResponseCode(HttpURLConnection.HTTP_MOVED_TEMP)
-        .addHeader("Location: " + server2.getUrl("/")));
+        .addHeader("Location: " + server2.url("/")));
 
     CookieManager cookieManager = new CookieManager(null, ACCEPT_ORIGINAL_SERVER);
     HttpCookie cookie = new HttpCookie("c", "cookie");
-    cookie.setDomain(server.get().getCookieDomain());
+    cookie.setDomain(server.getCookieDomain());
     cookie.setPath("/");
     String portList = Integer.toString(server.getPort());
     cookie.setPortlist(portList);
-    cookieManager.getCookieStore().add(server.getUrl("/").toURI(), cookie);
+    cookieManager.getCookieStore().add(server.url("/").uri(), cookie);
     client.setCookieHandler(cookieManager);
 
     Response response = client.newCall(new Request.Builder()
-        .url(server.getUrl("/page1"))
+        .url(server.url("/page1"))
         .build()).execute();
     assertEquals("Page 2", response.body().string());
 
     RecordedRequest request1 = server.takeRequest();
     assertEquals("$Version=\"1\"; c=\"cookie\";$Path=\"/\";$Domain=\""
-        + server.get().getCookieDomain()
+        + server.getCookieDomain()
         + "\";$Port=\""
         + portList
         + "\"", request1.getHeader("Cookie"));
@@ -1240,11 +1330,11 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
         .setResponseCode(401));
     server.enqueue(new MockResponse()
         .setResponseCode(302)
-        .addHeader("Location: " + server2.getUrl("/b")));
+        .addHeader("Location: " + server2.url("/b")));
 
     client.setAuthenticator(new RecordingOkAuthenticator(Credentials.basic("jesse", "secret")));
 
-    Request request = new Request.Builder().url(server.getUrl("/a")).build();
+    Request request = new Request.Builder().url(server.url("/a")).build();
     Response response = client.newCall(request).execute();
     assertEquals("Page 2", response.body().string());
 
@@ -1266,10 +1356,10 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
         .setBody("/b has moved!"));
     server.enqueue(new MockResponse().setBody("C"));
 
-    Request request = new Request.Builder().url(server.getUrl("/a")).build();
+    Request request = new Request.Builder().url(server.url("/a")).build();
     client.newCall(request).enqueue(callback);
 
-    callback.await(server.getUrl("/c"))
+    callback.await(server.url("/c"))
         .assertCode(200)
         .assertBody("C")
         .priorResponse()
@@ -1293,7 +1383,7 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
     }
     server.enqueue(new MockResponse().setBody("Success!"));
 
-    executeSynchronously(new Request.Builder().url(server.getUrl("/0")).build())
+    executeSynchronously(new Request.Builder().url(server.url("/0")).build())
         .assertCode(200)
         .assertBody("Success!");
   }
@@ -1307,9 +1397,9 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
     }
     server.enqueue(new MockResponse().setBody("Success!"));
 
-    Request request = new Request.Builder().url(server.getUrl("/0")).build();
+    Request request = new Request.Builder().url(server.url("/0")).build();
     client.newCall(request).enqueue(callback);
-    callback.await(server.getUrl("/20"))
+    callback.await(server.url("/20"))
         .assertCode(200)
         .assertBody("Success!");
   }
@@ -1323,7 +1413,7 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
     }
 
     try {
-      client.newCall(new Request.Builder().url(server.getUrl("/0")).build()).execute();
+      client.newCall(new Request.Builder().url(server.url("/0")).build()).execute();
       fail();
     } catch (IOException expected) {
       assertEquals("Too many follow-up requests: 21", expected.getMessage());
@@ -1338,13 +1428,39 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
           .setBody("Redirecting to /" + (i + 1)));
     }
 
-    Request request = new Request.Builder().url(server.getUrl("/0")).build();
+    Request request = new Request.Builder().url(server.url("/0")).build();
     client.newCall(request).enqueue(callback);
-    callback.await(server.getUrl("/20")).assertFailure("Too many follow-up requests: 21");
+    callback.await(server.url("/20")).assertFailure("Too many follow-up requests: 21");
+  }
+
+  @Test public void http204WithBodyDisallowed() throws IOException {
+    server.enqueue(new MockResponse()
+        .setResponseCode(204)
+        .setBody("I'm not even supposed to be here today."));
+
+    try {
+      executeSynchronously(new Request.Builder().url(server.url("/")).build());
+      fail();
+    } catch (ProtocolException e) {
+      assertEquals("HTTP 204 had non-zero Content-Length: 39", e.getMessage());
+    }
+  }
+
+  @Test public void http205WithBodyDisallowed() throws IOException {
+    server.enqueue(new MockResponse()
+        .setResponseCode(205)
+        .setBody("I'm not even supposed to be here today."));
+
+    try {
+      executeSynchronously(new Request.Builder().url(server.url("/")).build());
+      fail();
+    } catch (ProtocolException e) {
+      assertEquals("HTTP 205 had non-zero Content-Length: 39", e.getMessage());
+    }
   }
 
   @Test public void canceledBeforeExecute() throws Exception {
-    Call call = client.newCall(new Request.Builder().url(server.getUrl("/a")).build());
+    Call call = client.newCall(new Request.Builder().url(server.url("/a")).build());
     call.cancel();
 
     try {
@@ -1355,21 +1471,60 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
     assertEquals(0, server.getRequestCount());
   }
 
+  @Test public void cancelDuringHttpConnect() throws Exception {
+    cancelDuringConnect("http");
+  }
+
+  @Test public void cancelDuringHttpsConnect() throws Exception {
+    cancelDuringConnect("https");
+  }
+
+  /** Cancel a call that's waiting for connect to complete. */
+  private void cancelDuringConnect(String scheme) throws Exception {
+    InetSocketAddress socketAddress = startNullServer();
+
+    HttpUrl url = new HttpUrl.Builder()
+        .scheme(scheme)
+        .host(socketAddress.getHostName())
+        .port(socketAddress.getPort())
+        .build();
+
+    long cancelDelayMillis = 300L;
+    Call call = client.newCall(new Request.Builder().url(url).build());
+    cancelLater(call, cancelDelayMillis);
+
+    long startNanos = System.nanoTime();
+    try {
+      call.execute();
+      fail();
+    } catch (IOException expected) {
+    }
+    long elapsedNanos = System.nanoTime() - startNanos;
+    assertEquals(cancelDelayMillis, TimeUnit.NANOSECONDS.toMillis(elapsedNanos), 100f);
+  }
+
+  private InetSocketAddress startNullServer() throws IOException {
+    InetSocketAddress address = new InetSocketAddress(InetAddress.getByName("localhost"), 0);
+    nullServer = ServerSocketFactory.getDefault().createServerSocket();
+    nullServer.bind(address);
+    return new InetSocketAddress(address.getAddress(), nullServer.getLocalPort());
+  }
+
   @Test public void cancelTagImmediatelyAfterEnqueue() throws Exception {
     Call call = client.newCall(new Request.Builder()
-        .url(server.getUrl("/a"))
+        .url(server.url("/a"))
         .tag("request")
         .build());
     call.enqueue(callback);
     client.cancel("request");
     assertEquals(0, server.getRequestCount());
-    callback.await(server.getUrl("/a")).assertFailure("Canceled");
+    callback.await(server.url("/a")).assertFailure("Canceled");
   }
 
   @Test public void cancelBeforeBodyIsRead() throws Exception {
     server.enqueue(new MockResponse().setBody("def").throttleBody(1, 750, TimeUnit.MILLISECONDS));
 
-    final Call call = client.newCall(new Request.Builder().url(server.getUrl("/a")).build());
+    final Call call = client.newCall(new Request.Builder().url(server.url("/a")).build());
     ExecutorService executor = Executors.newSingleThreadExecutor();
     Future<Response> result = executor.submit(new Callable<Response>() {
       @Override public Response call() throws Exception {
@@ -1389,14 +1544,14 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
   }
 
   @Test public void cancelInFlightBeforeResponseReadThrowsIOE() throws Exception {
-    server.get().setDispatcher(new Dispatcher() {
+    server.setDispatcher(new Dispatcher() {
       @Override public MockResponse dispatch(RecordedRequest request) {
         client.cancel("request");
         return new MockResponse().setBody("A");
       }
     });
 
-    Request request = new Request.Builder().url(server.getUrl("/a")).tag("request").build();
+    Request request = new Request.Builder().url(server.url("/a")).tag("request").build();
     try {
       client.newCall(request).execute();
       fail();
@@ -1420,7 +1575,7 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
    */
   @Test public void canceledBeforeIOSignalsOnFailure() throws Exception {
     client.getDispatcher().setMaxRequests(1); // Force requests to be executed serially.
-    server.get().setDispatcher(new Dispatcher() {
+    server.setDispatcher(new Dispatcher() {
       char nextResponse = 'A';
 
       @Override public MockResponse dispatch(RecordedRequest request) {
@@ -1429,16 +1584,16 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
       }
     });
 
-    Request requestA = new Request.Builder().url(server.getUrl("/a")).tag("request A").build();
+    Request requestA = new Request.Builder().url(server.url("/a")).tag("request A").build();
     client.newCall(requestA).enqueue(callback);
     assertEquals("/a", server.takeRequest().getPath());
 
-    Request requestB = new Request.Builder().url(server.getUrl("/b")).tag("request B").build();
+    Request requestB = new Request.Builder().url(server.url("/b")).tag("request B").build();
     client.newCall(requestB).enqueue(callback);
 
-    callback.await(requestA.url()).assertBody("A");
+    callback.await(requestA.httpUrl()).assertBody("A");
     // At this point we know the callback is ready, and that it will receive a cancel failure.
-    callback.await(requestB.url()).assertFailure("Canceled");
+    callback.await(requestB.httpUrl()).assertFailure("Canceled");
   }
 
   @Test public void canceledBeforeIOSignalsOnFailure_HTTP_2() throws Exception {
@@ -1452,9 +1607,9 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
   }
 
   @Test public void canceledBeforeResponseReadSignalsOnFailure() throws Exception {
-    Request requestA = new Request.Builder().url(server.getUrl("/a")).tag("request A").build();
+    Request requestA = new Request.Builder().url(server.url("/a")).tag("request A").build();
     final Call call = client.newCall(requestA);
-    server.get().setDispatcher(new Dispatcher() {
+    server.setDispatcher(new Dispatcher() {
       @Override public MockResponse dispatch(RecordedRequest request) {
         call.cancel();
         return new MockResponse().setBody("A");
@@ -1464,7 +1619,7 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
     call.enqueue(callback);
     assertEquals("/a", server.takeRequest().getPath());
 
-    callback.await(requestA.url()).assertFailure("Canceled", "stream was reset: CANCEL",
+    callback.await(requestA.httpUrl()).assertFailure("Canceled", "stream was reset: CANCEL",
         "Socket closed");
   }
 
@@ -1489,7 +1644,7 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
     final AtomicReference<String> bodyRef = new AtomicReference<>();
     final AtomicBoolean failureRef = new AtomicBoolean();
 
-    Request request = new Request.Builder().url(server.getUrl("/a")).tag("request A").build();
+    Request request = new Request.Builder().url(server.url("/a")).tag("request A").build();
     final Call call = client.newCall(request);
     call.enqueue(new Callback() {
       @Override public void onFailure(Request request, IOException e) {
@@ -1527,6 +1682,25 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
     canceledAfterResponseIsDeliveredBreaksStreamButSignalsOnce();
   }
 
+  @Test public void cancelWithInterceptor() throws Exception {
+    client.interceptors().add(new Interceptor() {
+      @Override public Response intercept(Chain chain) throws IOException {
+        chain.proceed(chain.request());
+        throw new AssertionError(); // We expect an exception.
+      }
+    });
+
+    Call call = client.newCall(new Request.Builder().url(server.url("/a")).build());
+    call.cancel();
+
+    try {
+      call.execute();
+      fail();
+    } catch (IOException expected) {
+    }
+    assertEquals(0, server.getRequestCount());
+  }
+
   @Test public void gzip() throws Exception {
     Buffer gzippedBody = gzip("abcabcabc");
     String bodySize = Long.toString(gzippedBody.size());
@@ -1536,7 +1710,7 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
         .addHeader("Content-Encoding: gzip"));
 
     Request request = new Request.Builder()
-        .url(server.getUrl("/"))
+        .url(server.url("/"))
         .build();
 
     // Confirm that the user request doesn't have Accept-Encoding, and the user
@@ -1560,7 +1734,7 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
     server.enqueue(new MockResponse().setBody("def"));
 
     Request request = new Request.Builder()
-        .url(server.getUrl("/"))
+        .url(server.url("/"))
         .header("User-Agent", "SyncApiTest")
         .build();
 
@@ -1584,7 +1758,7 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
     assertEquals("abc", response.body().string());
 
     // Make another request just to confirm that that connection can be reused...
-    executeSynchronously(new Request.Builder().url(server.getUrl("/")).build()).assertBody("def");
+    executeSynchronously(new Request.Builder().url(server.url("/")).build()).assertBody("def");
     assertEquals(0, server.takeRequest().getSequenceNumber()); // New connection.
     assertEquals(1, server.takeRequest().getSequenceNumber()); // Connection reused.
 
@@ -1595,7 +1769,7 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
   @Test public void userAgentIsIncludedByDefault() throws Exception {
     server.enqueue(new MockResponse());
 
-    executeSynchronously(new Request.Builder().url(server.getUrl("/")).build());
+    executeSynchronously(new Request.Builder().url(server.url("/")).build());
 
     RecordedRequest recordedRequest = server.takeRequest();
     assertTrue(recordedRequest.getHeader("User-Agent")
@@ -1611,7 +1785,7 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
 
     client.setFollowRedirects(false);
     RecordedResponse recordedResponse = executeSynchronously(
-        new Request.Builder().url(server.getUrl("/a")).build());
+        new Request.Builder().url(server.url("/a")).build());
 
     recordedResponse
         .assertBody("A")
@@ -1622,7 +1796,7 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
     server.enqueue(new MockResponse());
 
     Request request = new Request.Builder()
-        .url(server.getUrl("/"))
+        .url(server.url("/"))
         .header("Expect", "100-continue")
         .post(RequestBody.create(MediaType.parse("text/plain"), "abc"))
         .build();
@@ -1631,14 +1805,14 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
         .assertCode(200)
         .assertSuccessful();
 
-    assertEquals("abc", server.takeRequest().getUtf8Body());
+    assertEquals("abc", server.takeRequest().getBody().readUtf8());
   }
 
   @Test public void expect100ContinueEmptyRequestBody() throws Exception {
     server.enqueue(new MockResponse());
 
     Request request = new Request.Builder()
-        .url(server.getUrl("/"))
+        .url(server.url("/"))
         .header("Expect", "100-continue")
         .post(RequestBody.create(MediaType.parse("text/plain"), ""))
         .build();
@@ -1648,6 +1822,26 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
         .assertSuccessful();
   }
 
+  /** We forbid non-ASCII characters in outgoing request headers, but accept UTF-8. */
+  @Test public void responseHeaderParsingIsLenient() throws Exception {
+    Headers headers = new Headers.Builder()
+        .add("Content-Length", "0")
+        .addLenient("a\tb: c\u007fd")
+        .addLenient(": ef")
+        .addLenient("\ud83c\udf69: \u2615\ufe0f")
+        .build();
+    server.enqueue(new MockResponse().setHeaders(headers));
+
+    Request request = new Request.Builder()
+        .url(server.url("/"))
+        .build();
+
+    executeSynchronously(request)
+        .assertHeader("a\tb", "c\u007fd")
+        .assertHeader("\ud83c\udf69", "\u2615\ufe0f")
+        .assertHeader("", "ef");
+  }
+
   private RecordedResponse executeSynchronously(Request request) throws IOException {
     Response response = client.newCall(request).execute();
     return new RecordedResponse(request, response, null, response.body().string(), null);
@@ -1661,8 +1855,8 @@ private void enableProtocol(Protocol protocol) {
     client.setSslSocketFactory(sslContext.getSocketFactory());
     client.setHostnameVerifier(new RecordingHostnameVerifier());
     client.setProtocols(Arrays.asList(protocol, Protocol.HTTP_1_1));
-    server.get().useHttps(sslContext.getSocketFactory(), false);
-    server.get().setProtocols(client.getProtocols());
+    server.useHttps(sslContext.getSocketFactory(), false);
+    server.setProtocols(client.getProtocols());
   }
 
   private Buffer gzip(String data) throws IOException {
@@ -1673,32 +1867,31 @@ private Buffer gzip(String data) throws IOException {
     return result;
   }
 
-  private void assertContains(Collection<String> collection, String element) {
-    for (String c : collection) {
-      if (c != null && c.equalsIgnoreCase(element)) return;
-    }
-    fail("No " + element + " in " + collection);
-  }
-
-  private void assertContainsNoneMatching(List<String> headers, String pattern) {
-    for (String header : headers) {
-      if (header.matches(pattern)) {
-        fail("Header " + header + " matches " + pattern);
+  private void cancelLater(final Call call, final long delay) {
+    new Thread("canceler") {
+      @Override public void run() {
+        try {
+          Thread.sleep(delay);
+        } catch (InterruptedException e) {
+          throw new AssertionError();
+        }
+        call.cancel();
       }
-    }
+    }.start();
   }
 
   private static class RecordingSSLSocketFactory extends DelegatingSSLSocketFactory {
 
-    private List<SSLSocket> socketsCreated = new ArrayList<SSLSocket>();
+    private List<SSLSocket> socketsCreated = new ArrayList<>();
 
     public RecordingSSLSocketFactory(SSLSocketFactory delegate) {
       super(delegate);
     }
 
     @Override
-    protected void configureSocket(SSLSocket sslSocket) throws IOException {
+    protected SSLSocket configureSocket(SSLSocket sslSocket) throws IOException {
       socketsCreated.add(sslSocket);
+      return sslSocket;
     }
 
     public List<SSLSocket> getSocketsCreated() {
@@ -1711,7 +1904,7 @@ protected void configureSocket(SSLSocket sslSocket) throws IOException {
    * TLS_FALLBACK_SCSV cipher on fallback connections. See
    * {@link com.squareup.okhttp.FallbackTestClientSocketFactory} for details.
    */
-  private static void suppressTlsFallbackScsv(OkHttpClient client) {
+  private void suppressTlsFallbackScsv(OkHttpClient client) {
     FallbackTestClientSocketFactory clientSocketFactory =
         new FallbackTestClientSocketFactory(sslContext.getSocketFactory());
     client.setSslSocketFactory(clientSocketFactory);
diff --git a/okhttp-tests/src/test/java/com/squareup/okhttp/CertificatePinnerTest.java b/okhttp-tests/src/test/java/com/squareup/okhttp/CertificatePinnerTest.java
index c5cea2803d..91b5a590f1 100644
--- a/okhttp-tests/src/test/java/com/squareup/okhttp/CertificatePinnerTest.java
+++ b/okhttp-tests/src/test/java/com/squareup/okhttp/CertificatePinnerTest.java
@@ -19,10 +19,15 @@
 import java.security.GeneralSecurityException;
 import java.security.KeyPair;
 import java.security.cert.X509Certificate;
+import java.util.Set;
 import javax.net.ssl.SSLPeerUnverifiedException;
+import okio.ByteString;
 import org.junit.Test;
 
+import static com.squareup.okhttp.TestUtil.setOf;
+import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertNull;
 import static org.junit.Assert.assertTrue;
 import static org.junit.Assert.fail;
 
@@ -32,10 +37,16 @@
   static KeyPair keyPairA;
   static X509Certificate keypairACertificate1;
   static String keypairACertificate1Pin;
+  static ByteString keypairACertificate1PinBase64;
 
   static KeyPair keyPairB;
   static X509Certificate keypairBCertificate1;
   static String keypairBCertificate1Pin;
+  static ByteString keypairBCertificate1PinBase64;
+
+  static KeyPair keyPairC;
+  static X509Certificate keypairCCertificate1;
+  static String keypairCCertificate1Pin;
 
   static {
     try {
@@ -44,15 +55,25 @@
       keyPairA = sslContextBuilder.generateKeyPair();
       keypairACertificate1 = sslContextBuilder.selfSignedCertificate(keyPairA, "1");
       keypairACertificate1Pin = CertificatePinner.pin(keypairACertificate1);
+      keypairACertificate1PinBase64 = pinToBase64(keypairACertificate1Pin);
 
       keyPairB = sslContextBuilder.generateKeyPair();
       keypairBCertificate1 = sslContextBuilder.selfSignedCertificate(keyPairB, "1");
       keypairBCertificate1Pin = CertificatePinner.pin(keypairBCertificate1);
+      keypairBCertificate1PinBase64 = pinToBase64(keypairBCertificate1Pin);
+
+      keyPairC = sslContextBuilder.generateKeyPair();
+      keypairCCertificate1 = sslContextBuilder.selfSignedCertificate(keyPairC, "1");
+      keypairCCertificate1Pin = CertificatePinner.pin(keypairCCertificate1);
     } catch (GeneralSecurityException e) {
       throw new AssertionError(e);
     }
   }
 
+  static ByteString pinToBase64(String pin) {
+    return ByteString.decodeBase64(pin.substring("sha1/".length()));
+  }
+
   @Test public void malformedPin() throws Exception {
     CertificatePinner.Builder builder = new CertificatePinner.Builder();
     try {
@@ -135,4 +156,98 @@
     CertificatePinner certificatePinner = new CertificatePinner.Builder().build();
     certificatePinner.check("example.com", keypairACertificate1);
   }
+
+  @Test public void successfulCheckForWildcardHostname() throws Exception {
+    CertificatePinner certificatePinner = new CertificatePinner.Builder()
+        .add("*.example.com", keypairACertificate1Pin)
+        .build();
+
+    certificatePinner.check("a.example.com", keypairACertificate1);
+  }
+
+  @Test public void successfulMatchAcceptsAnyMatchingCertificateForWildcardHostname() throws Exception {
+    CertificatePinner certificatePinner = new CertificatePinner.Builder()
+        .add("*.example.com", keypairBCertificate1Pin)
+        .build();
+
+    certificatePinner.check("a.example.com", keypairACertificate1, keypairBCertificate1);
+  }
+
+  @Test public void unsuccessfulCheckForWildcardHostname() throws Exception {
+    CertificatePinner certificatePinner = new CertificatePinner.Builder()
+        .add("*.example.com", keypairACertificate1Pin)
+        .build();
+
+    try {
+      certificatePinner.check("a.example.com", keypairBCertificate1);
+      fail();
+    } catch (SSLPeerUnverifiedException expected) {
+    }
+  }
+
+  @Test public void multipleCertificatesForOneWildcardHostname() throws Exception {
+    CertificatePinner certificatePinner = new CertificatePinner.Builder()
+        .add("*.example.com", keypairACertificate1Pin, keypairBCertificate1Pin)
+        .build();
+
+    certificatePinner.check("a.example.com", keypairACertificate1);
+    certificatePinner.check("a.example.com", keypairBCertificate1);
+  }
+
+  @Test public void successfulCheckForOneHostnameWithWildcardAndDirectCertificate() throws Exception {
+    CertificatePinner certificatePinner = new CertificatePinner.Builder()
+        .add("*.example.com", keypairACertificate1Pin)
+        .add("a.example.com", keypairBCertificate1Pin)
+        .build();
+
+    certificatePinner.check("a.example.com", keypairACertificate1);
+    certificatePinner.check("a.example.com", keypairBCertificate1);
+  }
+
+  @Test public void unsuccessfulCheckForOneHostnameWithWildcardAndDirectCertificate() throws Exception {
+    CertificatePinner certificatePinner = new CertificatePinner.Builder()
+        .add("*.example.com", keypairACertificate1Pin)
+        .add("a.example.com", keypairBCertificate1Pin)
+        .build();
+
+    try {
+      certificatePinner.check("a.example.com", keypairCCertificate1);
+      fail();
+    } catch (SSLPeerUnverifiedException expected) {
+    }
+  }
+
+  @Test public void successfulFindMatchingPins() {
+    CertificatePinner certificatePinner = new CertificatePinner.Builder()
+        .add("first.com", keypairACertificate1Pin, keypairBCertificate1Pin)
+        .add("second.com", keypairCCertificate1Pin)
+        .build();
+
+    Set<ByteString> expectedPins = setOf(keypairACertificate1PinBase64, keypairBCertificate1PinBase64);
+    Set<ByteString> matchedPins  = certificatePinner.findMatchingPins("first.com");
+
+    assertEquals(expectedPins, matchedPins);
+  }
+
+  @Test public void successfulFindMatchingPinsForWildcardAndDirectCertificates() {
+    CertificatePinner certificatePinner = new CertificatePinner.Builder()
+        .add("*.example.com", keypairACertificate1Pin)
+        .add("a.example.com", keypairBCertificate1Pin)
+        .add("b.example.com", keypairCCertificate1Pin)
+        .build();
+
+    Set<ByteString> expectedPins = setOf(keypairACertificate1PinBase64, keypairBCertificate1PinBase64);
+    Set<ByteString> matchedPins  = certificatePinner.findMatchingPins("a.example.com");
+
+    assertEquals(expectedPins, matchedPins);
+  }
+
+  @Test public void wildcardHostnameShouldNotMatchThroughDot() throws Exception {
+    CertificatePinner certificatePinner = new CertificatePinner.Builder()
+        .add("*.example.com", keypairACertificate1Pin)
+        .build();
+
+    assertNull(certificatePinner.findMatchingPins("example.com"));
+    assertNull(certificatePinner.findMatchingPins("a.b.example.com"));
+  }
 }
diff --git a/okhttp-tests/src/test/java/com/squareup/okhttp/ConnectionPoolTest.java b/okhttp-tests/src/test/java/com/squareup/okhttp/ConnectionPoolTest.java
index ebeb698ae3..d528c7a906 100644
--- a/okhttp-tests/src/test/java/com/squareup/okhttp/ConnectionPoolTest.java
+++ b/okhttp-tests/src/test/java/com/squareup/okhttp/ConnectionPoolTest.java
@@ -15,12 +15,13 @@
  */
 package com.squareup.okhttp;
 
-import com.squareup.okhttp.internal.RecordingHostnameVerifier;
+import com.squareup.okhttp.internal.Internal;
 import com.squareup.okhttp.internal.SslContextBuilder;
 import com.squareup.okhttp.internal.Util;
 import com.squareup.okhttp.internal.http.AuthenticatorAdapter;
 import com.squareup.okhttp.internal.http.RecordingProxySelector;
 import com.squareup.okhttp.mockwebserver.MockWebServer;
+import com.squareup.okhttp.testing.RecordingHostnameVerifier;
 import java.io.IOException;
 import java.net.InetAddress;
 import java.net.InetSocketAddress;
@@ -43,9 +44,16 @@
 import static org.junit.Assert.fail;
 
 public final class ConnectionPoolTest {
+  static {
+    Internal.initializeInstanceForTests();
+  }
+
+  private static final List<ConnectionSpec> CONNECTION_SPECS = Util.immutableList(
+      ConnectionSpec.MODERN_TLS, ConnectionSpec.CLEARTEXT);
+
   private static final int KEEP_ALIVE_DURATION_MS = 5000;
-  private static final SSLContext sslContext = SslContextBuilder.localhost();
 
+  private SSLContext sslContext = SslContextBuilder.localhost();
   private MockWebServer spdyServer;
   private InetSocketAddress spdySocketAddress;
   private Address spdyAddress;
@@ -77,13 +85,10 @@ private void setUp(int poolSize) throws Exception {
     httpServer = new MockWebServer();
     spdyServer.useHttps(sslContext.getSocketFactory(), false);
 
-    List<ConnectionSpec> connectionSpecs = Util.immutableList(
-        ConnectionSpec.MODERN_TLS, ConnectionSpec.CLEARTEXT);
-
     httpServer.start();
     httpAddress = new Address(httpServer.getHostName(), httpServer.getPort(), socketFactory, null,
         null, null, AuthenticatorAdapter.INSTANCE, null,
-        Util.immutableList(Protocol.SPDY_3, Protocol.HTTP_1_1), connectionSpecs, proxySelector);
+        Util.immutableList(Protocol.SPDY_3, Protocol.HTTP_1_1), CONNECTION_SPECS, proxySelector);
     httpSocketAddress = new InetSocketAddress(InetAddress.getByName(httpServer.getHostName()),
         httpServer.getPort());
 
@@ -91,30 +96,28 @@ private void setUp(int poolSize) throws Exception {
     spdyAddress = new Address(spdyServer.getHostName(), spdyServer.getPort(), socketFactory,
         sslContext.getSocketFactory(), new RecordingHostnameVerifier(), CertificatePinner.DEFAULT,
         AuthenticatorAdapter.INSTANCE, null, Util.immutableList(Protocol.SPDY_3, Protocol.HTTP_1_1),
-        connectionSpecs, proxySelector);
+        CONNECTION_SPECS, proxySelector);
     spdySocketAddress = new InetSocketAddress(InetAddress.getByName(spdyServer.getHostName()),
         spdyServer.getPort());
 
-    Route httpRoute = new Route(httpAddress, Proxy.NO_PROXY, httpSocketAddress,
-        ConnectionSpec.CLEARTEXT);
-    Route spdyRoute = new Route(spdyAddress, Proxy.NO_PROXY, spdySocketAddress,
-        ConnectionSpec.MODERN_TLS);
+    Route httpRoute = new Route(httpAddress, Proxy.NO_PROXY, httpSocketAddress);
+    Route spdyRoute = new Route(spdyAddress, Proxy.NO_PROXY, spdySocketAddress);
     pool = new ConnectionPool(poolSize, KEEP_ALIVE_DURATION_MS);
     // Disable the automatic execution of the cleanup.
     cleanupExecutor = new FakeExecutor();
     pool.replaceCleanupExecutorForTests(cleanupExecutor);
     httpA = new Connection(pool, httpRoute);
-    httpA.connect(200, 200, 200, null);
+    httpA.connect(200, 200, 200, null, CONNECTION_SPECS, false /* connectionRetryEnabled */);
     httpB = new Connection(pool, httpRoute);
-    httpB.connect(200, 200, 200, null);
+    httpB.connect(200, 200, 200, null, CONNECTION_SPECS, false /* connectionRetryEnabled */);
     httpC = new Connection(pool, httpRoute);
-    httpC.connect(200, 200, 200, null);
+    httpC.connect(200, 200, 200, null, CONNECTION_SPECS, false /* connectionRetryEnabled */);
     httpD = new Connection(pool, httpRoute);
-    httpD.connect(200, 200, 200, null);
+    httpD.connect(200, 200, 200, null, CONNECTION_SPECS, false /* connectionRetryEnabled */);
     httpE = new Connection(pool, httpRoute);
-    httpE.connect(200, 200, 200, null);
+    httpE.connect(200, 200, 200, null, CONNECTION_SPECS, false /* connectionRetryEnabled */);
     spdyA = new Connection(pool, spdyRoute);
-    spdyA.connect(20000, 20000, 2000, null);
+    spdyA.connect(20000, 20000, 2000, null, CONNECTION_SPECS, false /* connectionRetryEnabled */);
 
     owner = new Object();
     httpA.setOwner(owner);
@@ -146,9 +149,8 @@ private void resetWithPoolSize(int poolSize) throws Exception {
     Connection connection = pool.get(httpAddress);
     assertNull(connection);
 
-    connection = new Connection(pool, new Route(httpAddress, Proxy.NO_PROXY, httpSocketAddress,
-        ConnectionSpec.CLEARTEXT));
-    connection.connect(200, 200, 200, null);
+    connection = new Connection(pool, new Route(httpAddress, Proxy.NO_PROXY, httpSocketAddress));
+    connection.connect(200, 200, 200, null, CONNECTION_SPECS, false /* connectionRetryEnabled */);
     connection.setOwner(owner);
     assertEquals(0, pool.getConnectionCount());
 
diff --git a/okhttp-tests/src/test/java/com/squareup/okhttp/ConnectionSpecTest.java b/okhttp-tests/src/test/java/com/squareup/okhttp/ConnectionSpecTest.java
index df1e58fa71..7833cca694 100644
--- a/okhttp-tests/src/test/java/com/squareup/okhttp/ConnectionSpecTest.java
+++ b/okhttp-tests/src/test/java/com/squareup/okhttp/ConnectionSpecTest.java
@@ -15,13 +15,8 @@
  */
 package com.squareup.okhttp;
 
-import com.squareup.okhttp.internal.http.AuthenticatorAdapter;
-
 import org.junit.Test;
 
-import java.net.InetSocketAddress;
-import java.net.Proxy;
-import java.net.ProxySelector;
 import java.util.Arrays;
 import java.util.LinkedHashSet;
 import java.util.Set;
@@ -35,14 +30,6 @@
 
 public final class ConnectionSpecTest {
 
-  private static final Proxy PROXY = Proxy.NO_PROXY;
-  private static final InetSocketAddress INET_SOCKET_ADDRESS =
-      InetSocketAddress.createUnresolved("host", 443);
-  private static final Address HTTPS_ADDRESS = new Address(
-      INET_SOCKET_ADDRESS.getHostString(), INET_SOCKET_ADDRESS.getPort(), null, null, null, null,
-      AuthenticatorAdapter.INSTANCE, PROXY, Arrays.asList(Protocol.HTTP_1_1),
-      Arrays.asList(ConnectionSpec.MODERN_TLS), ProxySelector.getDefault());
-
   @Test
   public void cleartextBuilder() throws Exception {
     ConnectionSpec cleartextSpec = new ConnectionSpec.Builder(false).build();
@@ -89,9 +76,8 @@ public void tls_defaultCiphers_noFallbackIndicator() throws Exception {
         TlsVersion.TLS_1_1.javaName,
     });
 
-    Route route = new Route(HTTPS_ADDRESS, PROXY, INET_SOCKET_ADDRESS, tlsSpec,
-        false /* shouldSendTlsFallbackIndicator */);
-    tlsSpec.apply(socket, route);
+    assertTrue(tlsSpec.isCompatible(socket));
+    tlsSpec.apply(socket, false /* isFallback */);
 
     assertEquals(createSet(TlsVersion.TLS_1_2.javaName), createSet(socket.getEnabledProtocols()));
 
@@ -119,9 +105,8 @@ public void tls_defaultCiphers_withFallbackIndicator() throws Exception {
         TlsVersion.TLS_1_1.javaName,
     });
 
-    Route route = new Route(HTTPS_ADDRESS, PROXY, INET_SOCKET_ADDRESS, tlsSpec,
-        true /* shouldSendTlsFallbackIndicator */);
-    tlsSpec.apply(socket, route);
+    assertTrue(tlsSpec.isCompatible(socket));
+    tlsSpec.apply(socket, true /* isFallback */);
 
     assertEquals(createSet(TlsVersion.TLS_1_2.javaName), createSet(socket.getEnabledProtocols()));
 
@@ -153,9 +138,8 @@ public void tls_explicitCiphers() throws Exception {
         TlsVersion.TLS_1_1.javaName,
     });
 
-    Route route = new Route(HTTPS_ADDRESS, PROXY, INET_SOCKET_ADDRESS, tlsSpec,
-        true /* shouldSendTlsFallbackIndicator */);
-    tlsSpec.apply(socket, route);
+    assertTrue(tlsSpec.isCompatible(socket));
+    tlsSpec.apply(socket, true /* isFallback */);
 
     assertEquals(createSet(TlsVersion.TLS_1_2.javaName), createSet(socket.getEnabledProtocols()));
 
@@ -166,6 +150,62 @@ public void tls_explicitCiphers() throws Exception {
     assertEquals(expectedCipherSet, expectedCipherSet);
   }
 
+  @Test
+  public void tls_stringCiphersAndVersions() throws Exception {
+    // Supporting arbitrary input strings allows users to enable suites and versions that are not
+    // yet known to the library, but are supported by the platform.
+    ConnectionSpec tlsSpec = new ConnectionSpec.Builder(ConnectionSpec.MODERN_TLS)
+        .cipherSuites("MAGIC-CIPHER")
+        .tlsVersions("TLS9k")
+        .build();
+  }
+
+  public void tls_missingRequiredCipher() throws Exception {
+    ConnectionSpec tlsSpec = new ConnectionSpec.Builder(true)
+        .cipherSuites(CipherSuite.TLS_RSA_WITH_RC4_128_MD5)
+        .tlsVersions(TlsVersion.TLS_1_2)
+        .supportsTlsExtensions(false)
+        .build();
+
+    SSLSocket socket = (SSLSocket) SSLSocketFactory.getDefault().createSocket();
+    socket.setEnabledProtocols(new String[] {
+        TlsVersion.TLS_1_2.javaName,
+        TlsVersion.TLS_1_1.javaName,
+    });
+
+    socket.setEnabledCipherSuites(new String[] {
+        CipherSuite.TLS_RSA_WITH_RC4_128_SHA.javaName,
+        CipherSuite.TLS_RSA_WITH_RC4_128_MD5.javaName,
+    });
+    assertTrue(tlsSpec.isCompatible(socket));
+
+    socket.setEnabledCipherSuites(new String[] {
+        CipherSuite.TLS_RSA_WITH_RC4_128_SHA.javaName,
+    });
+    assertFalse(tlsSpec.isCompatible(socket));
+  }
+
+  @Test
+  public void tls_missingTlsVersion() throws Exception {
+    ConnectionSpec tlsSpec = new ConnectionSpec.Builder(true)
+        .cipherSuites(CipherSuite.TLS_RSA_WITH_RC4_128_MD5)
+        .tlsVersions(TlsVersion.TLS_1_2)
+        .supportsTlsExtensions(false)
+        .build();
+
+    SSLSocket socket = (SSLSocket) SSLSocketFactory.getDefault().createSocket();
+    socket.setEnabledCipherSuites(new String[] {
+        CipherSuite.TLS_RSA_WITH_RC4_128_MD5.javaName,
+    });
+
+    socket.setEnabledProtocols(
+        new String[] { TlsVersion.TLS_1_2.javaName, TlsVersion.TLS_1_1.javaName });
+    assertTrue(tlsSpec.isCompatible(socket));
+
+    socket.setEnabledProtocols(new String[] { TlsVersion.TLS_1_1.javaName });
+    assertFalse(tlsSpec.isCompatible(socket));
+  }
+
   private static Set<String> createSet(String... values) {
     return new LinkedHashSet<String>(Arrays.asList(values));
   }
diff --git a/okhttp-tests/src/test/java/com/squareup/okhttp/DelegatingSSLSocketFactory.java b/okhttp-tests/src/test/java/com/squareup/okhttp/DelegatingSSLSocketFactory.java
index a14db22e67..3fe6eb48ae 100644
--- a/okhttp-tests/src/test/java/com/squareup/okhttp/DelegatingSSLSocketFactory.java
+++ b/okhttp-tests/src/test/java/com/squareup/okhttp/DelegatingSSLSocketFactory.java
@@ -90,7 +90,8 @@ public SSLSocket createSocket(Socket socket, String host, int port, boolean auto
     return sslSocket;
   }
 
-  protected void configureSocket(SSLSocket sslSocket) throws IOException {
+  protected SSLSocket configureSocket(SSLSocket sslSocket) throws IOException {
     // No-op by default.
+    return sslSocket;
   }
 }
diff --git a/okhttp-tests/src/test/java/com/squareup/okhttp/DelegatingServerSocketFactory.java b/okhttp-tests/src/test/java/com/squareup/okhttp/DelegatingServerSocketFactory.java
index ef24aaaaeb..7116fa3023 100644
--- a/okhttp-tests/src/test/java/com/squareup/okhttp/DelegatingServerSocketFactory.java
+++ b/okhttp-tests/src/test/java/com/squareup/okhttp/DelegatingServerSocketFactory.java
@@ -35,33 +35,30 @@ public DelegatingServerSocketFactory(ServerSocketFactory delegate) {
   @Override
   public ServerSocket createServerSocket() throws IOException {
     ServerSocket serverSocket = delegate.createServerSocket();
-    configureServerSocket(serverSocket);
-    return serverSocket;
+    return configureServerSocket(serverSocket);
   }
 
   @Override
   public ServerSocket createServerSocket(int port) throws IOException {
     ServerSocket serverSocket = delegate.createServerSocket(port);
-    configureServerSocket(serverSocket);
-    return serverSocket;
+    return configureServerSocket(serverSocket);
   }
 
   @Override
   public ServerSocket createServerSocket(int port, int backlog) throws IOException {
     ServerSocket serverSocket = delegate.createServerSocket(port, backlog);
-    configureServerSocket(serverSocket);
-    return serverSocket;
+    return configureServerSocket(serverSocket);
   }
 
   @Override
   public ServerSocket createServerSocket(int port, int backlog, InetAddress ifAddress)
       throws IOException {
     ServerSocket serverSocket = delegate.createServerSocket(port, backlog, ifAddress);
-    configureServerSocket(serverSocket);
-    return serverSocket;
+    return configureServerSocket(serverSocket);
   }
 
-  protected void configureServerSocket(ServerSocket serverSocket) throws IOException {
+  protected ServerSocket configureServerSocket(ServerSocket serverSocket) throws IOException {
     // No-op by default.
+    return serverSocket;
   }
 }
diff --git a/okhttp-tests/src/test/java/com/squareup/okhttp/DelegatingSocketFactory.java b/okhttp-tests/src/test/java/com/squareup/okhttp/DelegatingSocketFactory.java
index e8fdfe80fd..e673fdf900 100644
--- a/okhttp-tests/src/test/java/com/squareup/okhttp/DelegatingSocketFactory.java
+++ b/okhttp-tests/src/test/java/com/squareup/okhttp/DelegatingSocketFactory.java
@@ -36,41 +36,37 @@ public DelegatingSocketFactory(SocketFactory delegate) {
   @Override
   public Socket createSocket() throws IOException {
     Socket socket = delegate.createSocket();
-    configureSocket(socket);
-    return socket;
+    return configureSocket(socket);
   }
 
   @Override
   public Socket createSocket(String host, int port) throws IOException, UnknownHostException {
     Socket socket = delegate.createSocket(host, port);
-    configureSocket(socket);
-    return socket;
+    return configureSocket(socket);
   }
 
   @Override
   public Socket createSocket(String host, int port, InetAddress localAddress, int localPort)
       throws IOException, UnknownHostException {
     Socket socket = delegate.createSocket(host, port, localAddress, localPort);
-    configureSocket(socket);
-    return socket;
+    return configureSocket(socket);
   }
 
   @Override
   public Socket createSocket(InetAddress host, int port) throws IOException {
     Socket socket = delegate.createSocket(host, port);
-    configureSocket(socket);
-    return socket;
+    return configureSocket(socket);
   }
 
   @Override
   public Socket createSocket(InetAddress host, int port, InetAddress localAddress, int localPort)
       throws IOException {
     Socket socket = delegate.createSocket(host, port, localAddress, localPort);
-    configureSocket(socket);
-    return socket;
+    return configureSocket(socket);
   }
 
-  protected void configureSocket(Socket socket) throws IOException {
+  protected Socket configureSocket(Socket socket) throws IOException {
     // No-op by default.
+    return socket;
   }
 }
diff --git a/okhttp-tests/src/test/java/com/squareup/okhttp/FallbackTestClientSocketFactory.java b/okhttp-tests/src/test/java/com/squareup/okhttp/FallbackTestClientSocketFactory.java
index 5f9e623c1c..5504e77d4f 100644
--- a/okhttp-tests/src/test/java/com/squareup/okhttp/FallbackTestClientSocketFactory.java
+++ b/okhttp-tests/src/test/java/com/squareup/okhttp/FallbackTestClientSocketFactory.java
@@ -40,37 +40,8 @@ public FallbackTestClientSocketFactory(SSLSocketFactory delegate) {
     super(delegate);
   }
 
-  @Override public SSLSocket createSocket(Socket s, String host, int port, boolean autoClose)
-      throws IOException {
-    SSLSocket socket = super.createSocket(s, host, port, autoClose);
-    return new TlsFallbackScsvDisabledSSLSocket(socket);
-  }
-
-  @Override public SSLSocket createSocket() throws IOException {
-    SSLSocket socket = super.createSocket();
-    return new TlsFallbackScsvDisabledSSLSocket(socket);
-  }
-
-  @Override public SSLSocket createSocket(String host,int port) throws IOException {
-    SSLSocket socket = super.createSocket(host, port);
-    return new TlsFallbackScsvDisabledSSLSocket(socket);
-  }
-
-  @Override public SSLSocket createSocket(String host,int port, InetAddress localHost,
-      int localPort) throws IOException {
-    SSLSocket socket = super.createSocket(host, port, localHost, localPort);
-    return new TlsFallbackScsvDisabledSSLSocket(socket);
-  }
-
-  @Override public SSLSocket createSocket(InetAddress host,int port) throws IOException {
-    SSLSocket socket = super.createSocket(host, port);
-    return new TlsFallbackScsvDisabledSSLSocket(socket);
-  }
-
-  @Override public SSLSocket createSocket(InetAddress address,int port,
-      InetAddress localAddress, int localPort) throws IOException {
-    SSLSocket socket = super.createSocket(address, port, localAddress, localPort);
-    return new TlsFallbackScsvDisabledSSLSocket(socket);
+  @Override protected SSLSocket configureSocket(SSLSocket sslSocket) throws IOException {
+    return new TlsFallbackScsvDisabledSSLSocket(sslSocket);
   }
 
   private static class TlsFallbackScsvDisabledSSLSocket extends DelegatingSSLSocket {
diff --git a/okhttp-tests/src/test/java/com/squareup/okhttp/FormEncodingBuilderTest.java b/okhttp-tests/src/test/java/com/squareup/okhttp/FormEncodingBuilderTest.java
index a9533bf783..04e74a4564 100644
--- a/okhttp-tests/src/test/java/com/squareup/okhttp/FormEncodingBuilderTest.java
+++ b/okhttp-tests/src/test/java/com/squareup/okhttp/FormEncodingBuilderTest.java
@@ -15,6 +15,7 @@
  */
 package com.squareup.okhttp;
 
+import java.io.IOException;
 import okio.Buffer;
 import org.junit.Test;
 
@@ -25,11 +26,12 @@
     RequestBody formEncoding = new FormEncodingBuilder()
         .add("a&b", "c=d")
         .add("space, the", "final frontier")
+        .add("%25", "%25")
         .build();
 
     assertEquals("application/x-www-form-urlencoded", formEncoding.contentType().toString());
 
-    String expected = "a%26b=c%3Dd&space%2C+the=final+frontier";
+    String expected = "a%26b=c%3Dd&space%2C%20the=final%20frontier&%2525=%2525";
     assertEquals(expected.length(), formEncoding.contentLength());
 
     Buffer out = new Buffer();
@@ -37,6 +39,19 @@
     assertEquals(expected, out.readUtf8());
   }
 
+  @Test public void addEncoded() throws Exception {
+    RequestBody formEncoding = new FormEncodingBuilder()
+        .addEncoded("a+=& b", "c+=& d")
+        .addEncoded("e+=& f", "g+=& h")
+        .addEncoded("%25", "%25")
+        .build();
+
+    String expected = "a%20%3D%26%20b=c%20%3D%26%20d&e%20%3D%26%20f=g%20%3D%26%20h&%25=%25";
+    Buffer out = new Buffer();
+    formEncoding.writeTo(out);
+    assertEquals(expected, out.readUtf8());
+  }
+
   @Test public void encodedPair() throws Exception {
     RequestBody formEncoding = new FormEncodingBuilder()
         .add("sim", "ple")
@@ -64,4 +79,103 @@
     formEncoding.writeTo(buffer);
     assertEquals(expected, buffer.readUtf8());
   }
+
+  @Test public void buildEmptyForm() throws Exception {
+    RequestBody formEncoding = new FormEncodingBuilder().build();
+
+    String expected = "";
+    assertEquals(expected.length(), formEncoding.contentLength());
+
+    Buffer buffer = new Buffer();
+    formEncoding.writeTo(buffer);
+    assertEquals(expected, buffer.readUtf8());
+  }
+
+  @Test public void characterEncoding() throws Exception {
+    assertEquals("%00", formEncode(0)); // Browsers convert '\u0000' to '%EF%BF%BD'.
+    assertEquals("%01", formEncode(1));
+    assertEquals("%02", formEncode(2));
+    assertEquals("%03", formEncode(3));
+    assertEquals("%04", formEncode(4));
+    assertEquals("%05", formEncode(5));
+    assertEquals("%06", formEncode(6));
+    assertEquals("%07", formEncode(7));
+    assertEquals("%08", formEncode(8));
+    assertEquals("%09", formEncode(9));
+    assertEquals("%0A", formEncode(10)); // Browsers convert '\n' to '\r\n'
+    assertEquals("%0B", formEncode(11));
+    assertEquals("%0C", formEncode(12));
+    assertEquals("%0D", formEncode(13)); // Browsers convert '\r' to '\r\n'
+    assertEquals("%0E", formEncode(14));
+    assertEquals("%0F", formEncode(15));
+    assertEquals("%10", formEncode(16));
+    assertEquals("%11", formEncode(17));
+    assertEquals("%12", formEncode(18));
+    assertEquals("%13", formEncode(19));
+    assertEquals("%14", formEncode(20));
+    assertEquals("%15", formEncode(21));
+    assertEquals("%16", formEncode(22));
+    assertEquals("%17", formEncode(23));
+    assertEquals("%18", formEncode(24));
+    assertEquals("%19", formEncode(25));
+    assertEquals("%1A", formEncode(26));
+    assertEquals("%1B", formEncode(27));
+    assertEquals("%1C", formEncode(28));
+    assertEquals("%1D", formEncode(29));
+    assertEquals("%1E", formEncode(30));
+    assertEquals("%1F", formEncode(31));
+    assertEquals("%20", formEncode(32)); // Browsers use '+' for space.
+    assertEquals("%21", formEncode(33));
+    assertEquals("%22", formEncode(34));
+    assertEquals("%23", formEncode(35));
+    assertEquals("%24", formEncode(36));
+    assertEquals("%25", formEncode(37));
+    assertEquals("%26", formEncode(38));
+    assertEquals("%27", formEncode(39));
+    assertEquals("%28", formEncode(40));
+    assertEquals("%29", formEncode(41));
+    assertEquals("*", formEncode(42));
+    assertEquals("%2B", formEncode(43));
+    assertEquals("%2C", formEncode(44));
+    assertEquals("-", formEncode(45));
+    assertEquals(".", formEncode(46));
+    assertEquals("%2F", formEncode(47));
+    assertEquals("0", formEncode(48));
+    assertEquals("9", formEncode(57));
+    assertEquals("%3A", formEncode(58));
+    assertEquals("%3B", formEncode(59));
+    assertEquals("%3C", formEncode(60));
+    assertEquals("%3D", formEncode(61));
+    assertEquals("%3E", formEncode(62));
+    assertEquals("%3F", formEncode(63));
+    assertEquals("%40", formEncode(64));
+    assertEquals("A", formEncode(65));
+    assertEquals("Z", formEncode(90));
+    assertEquals("%5B", formEncode(91));
+    assertEquals("%5C", formEncode(92));
+    assertEquals("%5D", formEncode(93));
+    assertEquals("%5E", formEncode(94));
+    assertEquals("_", formEncode(95));
+    assertEquals("%60", formEncode(96));
+    assertEquals("a", formEncode(97));
+    assertEquals("z", formEncode(122));
+    assertEquals("%7B", formEncode(123));
+    assertEquals("%7C", formEncode(124));
+    assertEquals("%7D", formEncode(125));
+    assertEquals("%7E", formEncode(126));
+    assertEquals("%7F", formEncode(127));
+    assertEquals("%C2%80", formEncode(128));
+    assertEquals("%C3%BF", formEncode(255));
+  }
+
+  private String formEncode(int codePoint) throws IOException {
+    // Wrap the codepoint with regular printable characters to prevent trimming.
+    RequestBody body = new FormEncodingBuilder()
+        .add("a", new String(new int[] { 'b', codePoint, 'c' }, 0, 3))
+        .build();
+    Buffer buffer = new Buffer();
+    body.writeTo(buffer);
+    buffer.skip(3); // Skip "a=b" prefix.
+    return buffer.readUtf8(buffer.size() - 1); // Skip the "c" suffix.
+  }
 }
diff --git a/okhttp-tests/src/test/java/com/squareup/okhttp/HttpUrlTest.java b/okhttp-tests/src/test/java/com/squareup/okhttp/HttpUrlTest.java
new file mode 100644
index 0000000000..9ef2004caf
--- /dev/null
+++ b/okhttp-tests/src/test/java/com/squareup/okhttp/HttpUrlTest.java
@@ -0,0 +1,1161 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.okhttp;
+
+import com.squareup.okhttp.UrlComponentEncodingTester.Component;
+import com.squareup.okhttp.UrlComponentEncodingTester.Encoding;
+import java.net.MalformedURLException;
+import java.net.URI;
+import java.net.URL;
+import java.net.UnknownHostException;
+import java.util.Arrays;
+import java.util.Collections;
+import java.util.LinkedHashSet;
+import org.junit.Ignore;
+import org.junit.Test;
+
+import static java.util.Collections.singletonList;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.fail;
+
+public final class HttpUrlTest {
+  @Test public void parseTrimsAsciiWhitespace() throws Exception {
+    HttpUrl expected = HttpUrl.parse("http://host/");
+    assertEquals(expected, HttpUrl.parse("http://host/\f\n\t \r")); // Leading.
+    assertEquals(expected, HttpUrl.parse("\r\n\f \thttp://host/")); // Trailing.
+    assertEquals(expected, HttpUrl.parse(" http://host/ ")); // Both.
+    assertEquals(expected, HttpUrl.parse("    http://host/    ")); // Both.
+    assertEquals(expected, HttpUrl.parse("http://host/").resolve("   "));
+    assertEquals(expected, HttpUrl.parse("http://host/").resolve("  .  "));
+  }
+
+  @Test public void parseDoesNotTrimOtherWhitespaceCharacters() throws Exception {
+    // Whitespace characters list from Google's Guava team: http://goo.gl/IcR9RD
+    assertEquals("/%0B", HttpUrl.parse("http://h/\u000b").encodedPath()); // line tabulation
+    assertEquals("/%1C", HttpUrl.parse("http://h/\u001c").encodedPath()); // information separator 4
+    assertEquals("/%1D", HttpUrl.parse("http://h/\u001d").encodedPath()); // information separator 3
+    assertEquals("/%1E", HttpUrl.parse("http://h/\u001e").encodedPath()); // information separator 2
+    assertEquals("/%1F", HttpUrl.parse("http://h/\u001f").encodedPath()); // information separator 1
+    assertEquals("/%C2%85", HttpUrl.parse("http://h/\u0085").encodedPath()); // next line
+    assertEquals("/%C2%A0", HttpUrl.parse("http://h/\u00a0").encodedPath()); // non-breaking space
+    assertEquals("/%E1%9A%80", HttpUrl.parse("http://h/\u1680").encodedPath()); // ogham space mark
+    assertEquals("/%E1%A0%8E", HttpUrl.parse("http://h/\u180e").encodedPath()); // mongolian vowel separator
+    assertEquals("/%E2%80%80", HttpUrl.parse("http://h/\u2000").encodedPath()); // en quad
+    assertEquals("/%E2%80%81", HttpUrl.parse("http://h/\u2001").encodedPath()); // em quad
+    assertEquals("/%E2%80%82", HttpUrl.parse("http://h/\u2002").encodedPath()); // en space
+    assertEquals("/%E2%80%83", HttpUrl.parse("http://h/\u2003").encodedPath()); // em space
+    assertEquals("/%E2%80%84", HttpUrl.parse("http://h/\u2004").encodedPath()); // three-per-em space
+    assertEquals("/%E2%80%85", HttpUrl.parse("http://h/\u2005").encodedPath()); // four-per-em space
+    assertEquals("/%E2%80%86", HttpUrl.parse("http://h/\u2006").encodedPath()); // six-per-em space
+    assertEquals("/%E2%80%87", HttpUrl.parse("http://h/\u2007").encodedPath()); // figure space
+    assertEquals("/%E2%80%88", HttpUrl.parse("http://h/\u2008").encodedPath()); // punctuation space
+    assertEquals("/%E2%80%89", HttpUrl.parse("http://h/\u2009").encodedPath()); // thin space
+    assertEquals("/%E2%80%8A", HttpUrl.parse("http://h/\u200a").encodedPath()); // hair space
+    assertEquals("/%E2%80%8B", HttpUrl.parse("http://h/\u200b").encodedPath()); // zero-width space
+    assertEquals("/%E2%80%8C", HttpUrl.parse("http://h/\u200c").encodedPath()); // zero-width non-joiner
+    assertEquals("/%E2%80%8D", HttpUrl.parse("http://h/\u200d").encodedPath()); // zero-width joiner
+    assertEquals("/%E2%80%8E", HttpUrl.parse("http://h/\u200e").encodedPath()); // left-to-right mark
+    assertEquals("/%E2%80%8F", HttpUrl.parse("http://h/\u200f").encodedPath()); // right-to-left mark
+    assertEquals("/%E2%80%A8", HttpUrl.parse("http://h/\u2028").encodedPath()); // line separator
+    assertEquals("/%E2%80%A9", HttpUrl.parse("http://h/\u2029").encodedPath()); // paragraph separator
+    assertEquals("/%E2%80%AF", HttpUrl.parse("http://h/\u202f").encodedPath()); // narrow non-breaking space
+    assertEquals("/%E2%81%9F", HttpUrl.parse("http://h/\u205f").encodedPath()); // medium mathematical space
+    assertEquals("/%E3%80%80", HttpUrl.parse("http://h/\u3000").encodedPath()); // ideographic space
+  }
+
+  @Test public void scheme() throws Exception {
+    assertEquals(HttpUrl.parse("http://host/"), HttpUrl.parse("http://host/"));
+    assertEquals(HttpUrl.parse("http://host/"), HttpUrl.parse("Http://host/"));
+    assertEquals(HttpUrl.parse("http://host/"), HttpUrl.parse("http://host/"));
+    assertEquals(HttpUrl.parse("http://host/"), HttpUrl.parse("HTTP://host/"));
+    assertEquals(HttpUrl.parse("https://host/"), HttpUrl.parse("https://host/"));
+    assertEquals(HttpUrl.parse("https://host/"), HttpUrl.parse("HTTPS://host/"));
+    assertEquals(null, HttpUrl.parse("httpp://host/"));
+    assertEquals(null, HttpUrl.parse("0ttp://host/"));
+    assertEquals(null, HttpUrl.parse("ht+tp://host/"));
+    assertEquals(null, HttpUrl.parse("ht.tp://host/"));
+    assertEquals(null, HttpUrl.parse("ht-tp://host/"));
+    assertEquals(null, HttpUrl.parse("ht1tp://host/"));
+    assertEquals(null, HttpUrl.parse("httpss://host/"));
+  }
+
+  @Test public void parseNoScheme() throws Exception {
+    assertEquals(null, HttpUrl.parse("//host"));
+    assertEquals(null, HttpUrl.parse("/path"));
+    assertEquals(null, HttpUrl.parse("path"));
+    assertEquals(null, HttpUrl.parse("?query"));
+    assertEquals(null, HttpUrl.parse("#fragment"));
+  }
+
+  @Test public void resolveNoScheme() throws Exception {
+    HttpUrl base = HttpUrl.parse("http://host/a/b");
+    assertEquals(HttpUrl.parse("http://host2/"), base.resolve("//host2"));
+    assertEquals(HttpUrl.parse("http://host/path"), base.resolve("/path"));
+    assertEquals(HttpUrl.parse("http://host/a/path"), base.resolve("path"));
+    assertEquals(HttpUrl.parse("http://host/a/b?query"), base.resolve("?query"));
+    assertEquals(HttpUrl.parse("http://host/a/b#fragment"), base.resolve("#fragment"));
+    assertEquals(HttpUrl.parse("http://host/a/b"), base.resolve(""));
+    assertEquals(HttpUrl.parse("http://host/path"), base.resolve("\\path"));
+  }
+
+  @Test public void resolveUnsupportedScheme() throws Exception {
+    HttpUrl base = HttpUrl.parse("http://a/");
+    assertEquals(null, base.resolve("ftp://b"));
+    assertEquals(null, base.resolve("ht+tp://b"));
+    assertEquals(null, base.resolve("ht-tp://b"));
+    assertEquals(null, base.resolve("ht.tp://b"));
+  }
+
+  @Test public void resolveSchemeLikePath() throws Exception {
+    HttpUrl base = HttpUrl.parse("http://a/");
+    assertEquals(HttpUrl.parse("http://a/http//b/"), base.resolve("http//b/"));
+    assertEquals(HttpUrl.parse("http://a/ht+tp//b/"), base.resolve("ht+tp//b/"));
+    assertEquals(HttpUrl.parse("http://a/ht-tp//b/"), base.resolve("ht-tp//b/"));
+    assertEquals(HttpUrl.parse("http://a/ht.tp//b/"), base.resolve("ht.tp//b/"));
+  }
+
+  @Test public void parseAuthoritySlashCountDoesntMatter() throws Exception {
+    assertEquals(HttpUrl.parse("http://host/path"), HttpUrl.parse("http:host/path"));
+    assertEquals(HttpUrl.parse("http://host/path"), HttpUrl.parse("http:/host/path"));
+    assertEquals(HttpUrl.parse("http://host/path"), HttpUrl.parse("http:\\host/path"));
+    assertEquals(HttpUrl.parse("http://host/path"), HttpUrl.parse("http://host/path"));
+    assertEquals(HttpUrl.parse("http://host/path"), HttpUrl.parse("http:\\/host/path"));
+    assertEquals(HttpUrl.parse("http://host/path"), HttpUrl.parse("http:/\\host/path"));
+    assertEquals(HttpUrl.parse("http://host/path"), HttpUrl.parse("http:\\\\host/path"));
+    assertEquals(HttpUrl.parse("http://host/path"), HttpUrl.parse("http:///host/path"));
+    assertEquals(HttpUrl.parse("http://host/path"), HttpUrl.parse("http:\\//host/path"));
+    assertEquals(HttpUrl.parse("http://host/path"), HttpUrl.parse("http:/\\/host/path"));
+    assertEquals(HttpUrl.parse("http://host/path"), HttpUrl.parse("http://\\host/path"));
+    assertEquals(HttpUrl.parse("http://host/path"), HttpUrl.parse("http:\\\\/host/path"));
+    assertEquals(HttpUrl.parse("http://host/path"), HttpUrl.parse("http:/\\\\host/path"));
+    assertEquals(HttpUrl.parse("http://host/path"), HttpUrl.parse("http:\\\\\\host/path"));
+    assertEquals(HttpUrl.parse("http://host/path"), HttpUrl.parse("http:////host/path"));
+  }
+
+  @Test public void resolveAuthoritySlashCountDoesntMatterWithDifferentScheme() throws Exception {
+    HttpUrl base = HttpUrl.parse("https://a/b/c");
+    assertEquals(HttpUrl.parse("http://host/path"), base.resolve("http:host/path"));
+    assertEquals(HttpUrl.parse("http://host/path"), base.resolve("http:/host/path"));
+    assertEquals(HttpUrl.parse("http://host/path"), base.resolve("http:\\host/path"));
+    assertEquals(HttpUrl.parse("http://host/path"), base.resolve("http://host/path"));
+    assertEquals(HttpUrl.parse("http://host/path"), base.resolve("http:\\/host/path"));
+    assertEquals(HttpUrl.parse("http://host/path"), base.resolve("http:/\\host/path"));
+    assertEquals(HttpUrl.parse("http://host/path"), base.resolve("http:\\\\host/path"));
+    assertEquals(HttpUrl.parse("http://host/path"), base.resolve("http:///host/path"));
+    assertEquals(HttpUrl.parse("http://host/path"), base.resolve("http:\\//host/path"));
+    assertEquals(HttpUrl.parse("http://host/path"), base.resolve("http:/\\/host/path"));
+    assertEquals(HttpUrl.parse("http://host/path"), base.resolve("http://\\host/path"));
+    assertEquals(HttpUrl.parse("http://host/path"), base.resolve("http:\\\\/host/path"));
+    assertEquals(HttpUrl.parse("http://host/path"), base.resolve("http:/\\\\host/path"));
+    assertEquals(HttpUrl.parse("http://host/path"), base.resolve("http:\\\\\\host/path"));
+    assertEquals(HttpUrl.parse("http://host/path"), base.resolve("http:////host/path"));
+  }
+
+  @Test public void resolveAuthoritySlashCountMattersWithSameScheme() throws Exception {
+    HttpUrl base = HttpUrl.parse("http://a/b/c");
+    assertEquals(HttpUrl.parse("http://a/b/host/path"), base.resolve("http:host/path"));
+    assertEquals(HttpUrl.parse("http://a/host/path"), base.resolve("http:/host/path"));
+    assertEquals(HttpUrl.parse("http://a/host/path"), base.resolve("http:\\host/path"));
+    assertEquals(HttpUrl.parse("http://host/path"), base.resolve("http://host/path"));
+    assertEquals(HttpUrl.parse("http://host/path"), base.resolve("http:\\/host/path"));
+    assertEquals(HttpUrl.parse("http://host/path"), base.resolve("http:/\\host/path"));
+    assertEquals(HttpUrl.parse("http://host/path"), base.resolve("http:\\\\host/path"));
+    assertEquals(HttpUrl.parse("http://host/path"), base.resolve("http:///host/path"));
+    assertEquals(HttpUrl.parse("http://host/path"), base.resolve("http:\\//host/path"));
+    assertEquals(HttpUrl.parse("http://host/path"), base.resolve("http:/\\/host/path"));
+    assertEquals(HttpUrl.parse("http://host/path"), base.resolve("http://\\host/path"));
+    assertEquals(HttpUrl.parse("http://host/path"), base.resolve("http:\\\\/host/path"));
+    assertEquals(HttpUrl.parse("http://host/path"), base.resolve("http:/\\\\host/path"));
+    assertEquals(HttpUrl.parse("http://host/path"), base.resolve("http:\\\\\\host/path"));
+    assertEquals(HttpUrl.parse("http://host/path"), base.resolve("http:////host/path"));
+  }
+
+  @Test public void username() throws Exception {
+    assertEquals(HttpUrl.parse("http://host/path"), HttpUrl.parse("http://@host/path"));
+    assertEquals(HttpUrl.parse("http://user@host/path"), HttpUrl.parse("http://user@host/path"));
+  }
+
+  @Test public void authorityWithMultipleAtSigns() throws Exception {
+    assertEquals(HttpUrl.parse("http://foo%40bar@baz/path"),
+        HttpUrl.parse("http://foo@bar@baz/path"));
+    assertEquals(HttpUrl.parse("http://foo:pass1%40bar%3Apass2@baz/path"),
+        HttpUrl.parse("http://foo:pass1@bar:pass2@baz/path"));
+  }
+
+  @Test public void usernameAndPassword() throws Exception {
+    assertEquals(HttpUrl.parse("http://username:password@host/path"),
+        HttpUrl.parse("http://username:password@host/path"));
+    assertEquals(HttpUrl.parse("http://username@host/path"),
+        HttpUrl.parse("http://username:@host/path"));
+  }
+
+  @Test public void passwordWithEmptyUsername() throws Exception {
+    // Chrome doesn't mind, but Firefox rejects URLs with empty usernames and non-empty passwords.
+    assertEquals(HttpUrl.parse("http://host/path"), HttpUrl.parse("http://:@host/path"));
+    assertEquals("password%40", HttpUrl.parse("http://:password@@host/path").encodedPassword());
+  }
+
+  @Test public void unprintableCharactersArePercentEncoded() throws Exception {
+    assertEquals("/%00", HttpUrl.parse("http://host/\u0000").encodedPath());
+    assertEquals("/%08", HttpUrl.parse("http://host/\u0008").encodedPath());
+    assertEquals("/%EF%BF%BD", HttpUrl.parse("http://host/\ufffd").encodedPath());
+  }
+
+  @Test public void usernameCharacters() throws Exception {
+    new UrlComponentEncodingTester()
+        .override(Encoding.PERCENT, '[', ']', '{', '}', '|', '^', '\'', ';', '=', '@')
+        .override(Encoding.SKIP, ':', '/', '\\', '?', '#')
+        .skipForUri('%')
+        .test(Component.USER);
+  }
+
+  @Test public void passwordCharacters() throws Exception {
+    new UrlComponentEncodingTester()
+        .override(Encoding.PERCENT, '[', ']', '{', '}', '|', '^', '\'', ':', ';', '=', '@')
+        .override(Encoding.SKIP, '/', '\\', '?', '#')
+        .skipForUri('%')
+        .test(Component.PASSWORD);
+  }
+
+  @Test public void hostContainsIllegalCharacter() throws Exception {
+    assertEquals(null, HttpUrl.parse("http://\n/"));
+    assertEquals(null, HttpUrl.parse("http:// /"));
+    assertEquals(null, HttpUrl.parse("http://%20/"));
+  }
+
+  @Test public void hostnameLowercaseCharactersMappedDirectly() throws Exception {
+    assertEquals("abcd", HttpUrl.parse("http://abcd").host());
+    assertEquals("xn--4xa", HttpUrl.parse("http://σ").host());
+  }
+
+  @Test public void hostnameUppercaseCharactersConvertedToLowercase() throws Exception {
+    assertEquals("abcd", HttpUrl.parse("http://ABCD").host());
+    assertEquals("xn--4xa", HttpUrl.parse("http://Σ").host());
+  }
+
+  @Test public void hostnameIgnoredCharacters() throws Exception {
+    // The soft hyphen (­) should be ignored.
+    assertEquals("abcd", HttpUrl.parse("http://AB\u00adCD").host());
+  }
+
+  @Test public void hostnameMultipleCharacterMapping() throws Exception {
+    // Map the single character telephone symbol (℡) to the string "tel".
+    assertEquals("tel", HttpUrl.parse("http://\u2121").host());
+  }
+
+  @Test public void hostnameMappingLastMappedCodePoint() throws Exception {
+    assertEquals("xn--pu5l", HttpUrl.parse("http://\uD87E\uDE1D").host());
+  }
+
+  @Ignore("The java.net.IDN implementation doesn't ignore characters that it should.")
+  @Test public void hostnameMappingLastIgnoredCodePoint() throws Exception {
+    assertEquals("abcd", HttpUrl.parse("http://ab\uDB40\uDDEFcd").host());
+  }
+
+  @Test public void hostnameMappingLastDisallowedCodePoint() throws Exception {
+    assertEquals(null, HttpUrl.parse("http://\uDBFF\uDFFF"));
+  }
+
+  @Test public void hostIpv6() throws Exception {
+    // Square braces are absent from host()...
+    assertEquals("::1", HttpUrl.parse("http://[::1]/").host());
+
+    // ... but they're included in toString().
+    assertEquals("http://[::1]/", HttpUrl.parse("http://[::1]/").toString());
+
+    // IPv6 colons don't interfere with port numbers or passwords.
+    assertEquals(8080, HttpUrl.parse("http://[::1]:8080/").port());
+    assertEquals("password", HttpUrl.parse("http://user:password@[::1]/").password());
+    assertEquals("::1", HttpUrl.parse("http://user:password@[::1]:8080/").host());
+
+    // Permit the contents of IPv6 addresses to be percent-encoded...
+    assertEquals("::1", HttpUrl.parse("http://[%3A%3A%31]/").host());
+
+    // Including the Square braces themselves! (This is what Chrome does.)
+    assertEquals("::1", HttpUrl.parse("http://%5B%3A%3A1%5D/").host());
+  }
+
+  @Test public void hostIpv6AddressDifferentFormats() throws Exception {
+    // Multiple representations of the same address; see http://tools.ietf.org/html/rfc5952.
+    String a3 = "2001:db8::1:0:0:1";
+    assertEquals(a3, HttpUrl.parse("http://[2001:db8:0:0:1:0:0:1]").host());
+    assertEquals(a3, HttpUrl.parse("http://[2001:0db8:0:0:1:0:0:1]").host());
+    assertEquals(a3, HttpUrl.parse("http://[2001:db8::1:0:0:1]").host());
+    assertEquals(a3, HttpUrl.parse("http://[2001:db8::0:1:0:0:1]").host());
+    assertEquals(a3, HttpUrl.parse("http://[2001:0db8::1:0:0:1]").host());
+    assertEquals(a3, HttpUrl.parse("http://[2001:db8:0:0:1::1]").host());
+    assertEquals(a3, HttpUrl.parse("http://[2001:db8:0000:0:1::1]").host());
+    assertEquals(a3, HttpUrl.parse("http://[2001:DB8:0:0:1::1]").host());
+  }
+
+  @Test public void hostIpv6AddressLeadingCompression() throws Exception {
+    assertEquals("::1", HttpUrl.parse("http://[::0001]").host());
+    assertEquals("::1", HttpUrl.parse("http://[0000::0001]").host());
+    assertEquals("::1", HttpUrl.parse("http://[0000:0000:0000:0000:0000:0000:0000:0001]").host());
+    assertEquals("::1", HttpUrl.parse("http://[0000:0000:0000:0000:0000:0000::0001]").host());
+  }
+
+  @Test public void hostIpv6AddressTrailingCompression() throws Exception {
+    assertEquals("1::", HttpUrl.parse("http://[0001:0000::]").host());
+    assertEquals("1::", HttpUrl.parse("http://[0001::0000]").host());
+    assertEquals("1::", HttpUrl.parse("http://[0001::]").host());
+    assertEquals("1::", HttpUrl.parse("http://[1::]").host());
+  }
+
+  @Test public void hostIpv6AddressTooManyDigitsInGroup() throws Exception {
+    assertEquals(null, HttpUrl.parse("http://[00000:0000:0000:0000:0000:0000:0000:0001]"));
+    assertEquals(null, HttpUrl.parse("http://[::00001]"));
+  }
+
+  @Test public void hostIpv6AddressMisplacedColons() throws Exception {
+    assertEquals(null, HttpUrl.parse("http://[:0000:0000:0000:0000:0000:0000:0000:0001]"));
+    assertEquals(null, HttpUrl.parse("http://[:::0000:0000:0000:0000:0000:0000:0000:0001]"));
+    assertEquals(null, HttpUrl.parse("http://[:1]"));
+    assertEquals(null, HttpUrl.parse("http://[:::1]"));
+    assertEquals(null, HttpUrl.parse("http://[0000:0000:0000:0000:0000:0000:0001:]"));
+    assertEquals(null, HttpUrl.parse("http://[0000:0000:0000:0000:0000:0000:0000:0001:]"));
+    assertEquals(null, HttpUrl.parse("http://[0000:0000:0000:0000:0000:0000:0000:0001::]"));
+    assertEquals(null, HttpUrl.parse("http://[0000:0000:0000:0000:0000:0000:0000:0001:::]"));
+    assertEquals(null, HttpUrl.parse("http://[1:]"));
+    assertEquals(null, HttpUrl.parse("http://[1:::]"));
+    assertEquals(null, HttpUrl.parse("http://[1:::1]"));
+    assertEquals(null, HttpUrl.parse("http://[00000:0000:0000:0000::0000:0000:0000:0001]"));
+  }
+
+  @Test public void hostIpv6AddressTooManyGroups() throws Exception {
+    assertEquals(null, HttpUrl.parse("http://[00000:0000:0000:0000:0000:0000:0000:0000:0001]"));
+  }
+
+  @Test public void hostIpv6AddressTooMuchCompression() throws Exception {
+    assertEquals(null, HttpUrl.parse("http://[0000::0000:0000:0000:0000::0001]"));
+    assertEquals(null, HttpUrl.parse("http://[::0000:0000:0000:0000::0001]"));
+  }
+
+  @Test public void hostIpv6ScopedAddress() throws Exception {
+    // java.net.InetAddress parses scoped addresses. These aren't valid in URLs.
+    assertEquals(null, HttpUrl.parse("http://[::1%2544]"));
+  }
+
+  @Test public void hostIpv6WithIpv4Suffix() throws Exception {
+    assertEquals("::1:ffff:ffff", HttpUrl.parse("http://[::1:255.255.255.255]/").host());
+    assertEquals("::1:0:0", HttpUrl.parse("http://[0:0:0:0:0:1:0.0.0.0]/").host());
+  }
+
+  @Test public void hostIpv6WithIpv4SuffixWithOctalPrefix() throws Exception {
+    // Chrome interprets a leading '0' as octal; Firefox rejects them. (We reject them.)
+    assertEquals(null, HttpUrl.parse("http://[0:0:0:0:0:1:0.0.0.000000]/"));
+    assertEquals(null, HttpUrl.parse("http://[0:0:0:0:0:1:0.010.0.010]/"));
+    assertEquals(null, HttpUrl.parse("http://[0:0:0:0:0:1:0.0.0.000001]/"));
+  }
+
+  @Test public void hostIpv6WithIpv4SuffixWithHexadecimalPrefix() throws Exception {
+    // Chrome interprets a leading '0x' as hexadecimal; Firefox rejects them. (We reject them.)
+    assertEquals(null, HttpUrl.parse("http://[0:0:0:0:0:1:0.0x10.0.0x10]/"));
+  }
+
+  @Test public void hostIpv6WithMalformedIpv4Suffix() throws Exception {
+    assertEquals(null, HttpUrl.parse("http://[0:0:0:0:0:1:0.0:0.0]/"));
+    assertEquals(null, HttpUrl.parse("http://[0:0:0:0:0:1:0.0-0.0]/"));
+    assertEquals(null, HttpUrl.parse("http://[0:0:0:0:0:1:.255.255.255]/"));
+    assertEquals(null, HttpUrl.parse("http://[0:0:0:0:0:1:255..255.255]/"));
+    assertEquals(null, HttpUrl.parse("http://[0:0:0:0:0:1:255.255..255]/"));
+    assertEquals(null, HttpUrl.parse("http://[0:0:0:0:0:0:1:255.255]/"));
+    assertEquals(null, HttpUrl.parse("http://[0:0:0:0:0:1:256.255.255.255]/"));
+    assertEquals(null, HttpUrl.parse("http://[0:0:0:0:0:1:ff.255.255.255]/"));
+    assertEquals(null, HttpUrl.parse("http://[0:0:0:0:0:0:1:255.255.255.255]/"));
+    assertEquals(null, HttpUrl.parse("http://[0:0:0:0:1:255.255.255.255]/"));
+    assertEquals(null, HttpUrl.parse("http://[0:0:0:0:1:0.0.0.0:1]/"));
+    assertEquals(null, HttpUrl.parse("http://[0:0.0.0.0:1:0:0:0:0:1]/"));
+    assertEquals(null, HttpUrl.parse("http://[0.0.0.0:0:0:0:0:0:1]/"));
+  }
+
+  @Test public void hostIpv6WithIncompleteIpv4Suffix() throws Exception {
+    // To Chrome & Safari these are well-formed; Firefox disagrees. (We're consistent with Firefox).
+    assertEquals(null, HttpUrl.parse("http://[0:0:0:0:0:1:255.255.255.]/"));
+    assertEquals(null, HttpUrl.parse("http://[0:0:0:0:0:1:255.255.255]/"));
+  }
+
+  @Test public void hostIpv6CanonicalForm() throws Exception {
+    assertEquals("abcd:ef01:2345:6789:abcd:ef01:2345:6789",
+        HttpUrl.parse("http://[abcd:ef01:2345:6789:abcd:ef01:2345:6789]/").host());
+    assertEquals("a::b:0:0:0", HttpUrl.parse("http://[a:0:0:0:b:0:0:0]/").host());
+    assertEquals("a:b:0:0:c::", HttpUrl.parse("http://[a:b:0:0:c:0:0:0]/").host());
+    assertEquals("a:b::c:0:0", HttpUrl.parse("http://[a:b:0:0:0:c:0:0]/").host());
+    assertEquals("a::b:0:0:0", HttpUrl.parse("http://[a:0:0:0:b:0:0:0]/").host());
+    assertEquals("::a:b:0:0:0", HttpUrl.parse("http://[0:0:0:a:b:0:0:0]/").host());
+    assertEquals("::a:0:0:0:b", HttpUrl.parse("http://[0:0:0:a:0:0:0:b]/").host());
+    assertEquals("::a:b:c:d:e:f:1", HttpUrl.parse("http://[0:a:b:c:d:e:f:1]/").host());
+    assertEquals("a:b:c:d:e:f:1::", HttpUrl.parse("http://[a:b:c:d:e:f:1:0]/").host());
+    assertEquals("ff01::101", HttpUrl.parse("http://[FF01:0:0:0:0:0:0:101]/").host());
+    assertEquals("1::", HttpUrl.parse("http://[1:0:0:0:0:0:0:0]/").host());
+    assertEquals("::1", HttpUrl.parse("http://[0:0:0:0:0:0:0:1]/").host());
+    assertEquals("::", HttpUrl.parse("http://[0:0:0:0:0:0:0:0]/").host());
+  }
+
+  @Test public void hostIpv4CanonicalForm() throws Exception {
+    assertEquals("255.255.255.255", HttpUrl.parse("http://255.255.255.255/").host());
+    assertEquals("1.2.3.4", HttpUrl.parse("http://1.2.3.4/").host());
+    assertEquals("0.0.0.0", HttpUrl.parse("http://0.0.0.0/").host());
+  }
+
+  @Ignore("java.net.IDN strips trailing trailing dots on Java 7, but not on Java 8.")
+  @Test public void hostWithTrailingDot() throws Exception {
+    assertEquals("host.", HttpUrl.parse("http://host./").host());
+  }
+
+  @Test public void port() throws Exception {
+    assertEquals(HttpUrl.parse("http://host/"), HttpUrl.parse("http://host:80/"));
+    assertEquals(HttpUrl.parse("http://host:99/"), HttpUrl.parse("http://host:99/"));
+    assertEquals(HttpUrl.parse("http://host/"), HttpUrl.parse("http://host:/"));
+    assertEquals(65535, HttpUrl.parse("http://host:65535/").port());
+    assertEquals(null, HttpUrl.parse("http://host:0/"));
+    assertEquals(null, HttpUrl.parse("http://host:65536/"));
+    assertEquals(null, HttpUrl.parse("http://host:-1/"));
+    assertEquals(null, HttpUrl.parse("http://host:a/"));
+    assertEquals(null, HttpUrl.parse("http://host:%39%39/"));
+  }
+
+  @Test public void pathCharacters() throws Exception {
+    new UrlComponentEncodingTester()
+        .override(Encoding.PERCENT, '^', '{', '}', '|')
+        .override(Encoding.SKIP, '\\', '?', '#')
+        .skipForUri('%', '[', ']')
+        .test(Component.PATH);
+  }
+
+  @Test public void queryCharacters() throws Exception {
+    new UrlComponentEncodingTester()
+        .override(Encoding.IDENTITY, '?', '`')
+        .override(Encoding.PERCENT, '\'')
+        .override(Encoding.SKIP, '#', '+')
+        .skipForUri('%', '\\', '^', '`', '{', '|', '}')
+        .test(Component.QUERY);
+  }
+
+  @Test public void fragmentCharacters() throws Exception {
+    new UrlComponentEncodingTester()
+        .override(Encoding.IDENTITY, ' ', '"', '#', '<', '>', '?', '`')
+        .skipForUri('%', ' ', '"', '#', '<', '>', '\\', '^', '`', '{', '|', '}')
+        .test(Component.FRAGMENT);
+    // TODO(jwilson): don't percent-encode non-ASCII characters. (But do encode control characters!)
+  }
+
+  @Test public void relativePath() throws Exception {
+    HttpUrl base = HttpUrl.parse("http://host/a/b/c");
+    assertEquals(HttpUrl.parse("http://host/a/b/d/e/f"), base.resolve("d/e/f"));
+    assertEquals(HttpUrl.parse("http://host/d/e/f"), base.resolve("../../d/e/f"));
+    assertEquals(HttpUrl.parse("http://host/a/"), base.resolve(".."));
+    assertEquals(HttpUrl.parse("http://host/"), base.resolve("../.."));
+    assertEquals(HttpUrl.parse("http://host/"), base.resolve("../../.."));
+    assertEquals(HttpUrl.parse("http://host/a/b/"), base.resolve("."));
+    assertEquals(HttpUrl.parse("http://host/a/"), base.resolve("././.."));
+    assertEquals(HttpUrl.parse("http://host/a/b/c/"), base.resolve("c/d/../e/../"));
+    assertEquals(HttpUrl.parse("http://host/a/b/..e/"), base.resolve("..e/"));
+    assertEquals(HttpUrl.parse("http://host/a/b/e/f../"), base.resolve("e/f../"));
+    assertEquals(HttpUrl.parse("http://host/a/"), base.resolve("%2E."));
+    assertEquals(HttpUrl.parse("http://host/a/"), base.resolve(".%2E"));
+    assertEquals(HttpUrl.parse("http://host/a/"), base.resolve("%2E%2E"));
+    assertEquals(HttpUrl.parse("http://host/a/"), base.resolve("%2e."));
+    assertEquals(HttpUrl.parse("http://host/a/"), base.resolve(".%2e"));
+    assertEquals(HttpUrl.parse("http://host/a/"), base.resolve("%2e%2e"));
+    assertEquals(HttpUrl.parse("http://host/a/b/"), base.resolve("%2E"));
+    assertEquals(HttpUrl.parse("http://host/a/b/"), base.resolve("%2e"));
+  }
+
+  @Test public void relativePathWithTrailingSlash() throws Exception {
+    HttpUrl base = HttpUrl.parse("http://host/a/b/c/");
+    assertEquals(HttpUrl.parse("http://host/a/b/"), base.resolve(".."));
+    assertEquals(HttpUrl.parse("http://host/a/b/"), base.resolve("../"));
+    assertEquals(HttpUrl.parse("http://host/a/"), base.resolve("../.."));
+    assertEquals(HttpUrl.parse("http://host/a/"), base.resolve("../../"));
+    assertEquals(HttpUrl.parse("http://host/"), base.resolve("../../.."));
+    assertEquals(HttpUrl.parse("http://host/"), base.resolve("../../../"));
+    assertEquals(HttpUrl.parse("http://host/"), base.resolve("../../../.."));
+    assertEquals(HttpUrl.parse("http://host/"), base.resolve("../../../../"));
+    assertEquals(HttpUrl.parse("http://host/a"), base.resolve("../../../../a"));
+    assertEquals(HttpUrl.parse("http://host/"), base.resolve("../../../../a/.."));
+    assertEquals(HttpUrl.parse("http://host/a/"), base.resolve("../../../../a/b/.."));
+  }
+
+  @Test public void pathWithBackslash() throws Exception {
+    HttpUrl base = HttpUrl.parse("http://host/a/b/c");
+    assertEquals(HttpUrl.parse("http://host/a/b/d/e/f"), base.resolve("d\\e\\f"));
+    assertEquals(HttpUrl.parse("http://host/d/e/f"), base.resolve("../..\\d\\e\\f"));
+    assertEquals(HttpUrl.parse("http://host/"), base.resolve("..\\.."));
+  }
+
+  @Test public void relativePathWithSameScheme() throws Exception {
+    HttpUrl base = HttpUrl.parse("http://host/a/b/c");
+    assertEquals(HttpUrl.parse("http://host/a/b/d/e/f"), base.resolve("http:d/e/f"));
+    assertEquals(HttpUrl.parse("http://host/d/e/f"), base.resolve("http:../../d/e/f"));
+  }
+
+  @Test public void decodeUsername() {
+    assertEquals("user", HttpUrl.parse("http://user@host/").username());
+    assertEquals("\uD83C\uDF69", HttpUrl.parse("http://%F0%9F%8D%A9@host/").username());
+  }
+
+  @Test public void decodePassword() {
+    assertEquals("password", HttpUrl.parse("http://user:password@host/").password());
+    assertEquals("", HttpUrl.parse("http://user:@host/").password());
+    assertEquals("\uD83C\uDF69", HttpUrl.parse("http://user:%F0%9F%8D%A9@host/").password());
+  }
+
+  @Test public void decodeSlashCharacterInDecodedPathSegment() {
+    assertEquals(Arrays.asList("a/b/c"),
+        HttpUrl.parse("http://host/a%2Fb%2Fc").pathSegments());
+  }
+
+  @Test public void decodeEmptyPathSegments() {
+    assertEquals(Arrays.asList(""),
+        HttpUrl.parse("http://host/").pathSegments());
+  }
+
+  @Test public void percentDecode() throws Exception {
+    assertEquals(Arrays.asList("\u0000"),
+        HttpUrl.parse("http://host/%00").pathSegments());
+    assertEquals(Arrays.asList("a", "\u2603", "c"),
+        HttpUrl.parse("http://host/a/%E2%98%83/c").pathSegments());
+    assertEquals(Arrays.asList("a", "\uD83C\uDF69", "c"),
+        HttpUrl.parse("http://host/a/%F0%9F%8D%A9/c").pathSegments());
+    assertEquals(Arrays.asList("a", "b", "c"),
+        HttpUrl.parse("http://host/a/%62/c").pathSegments());
+    assertEquals(Arrays.asList("a", "z", "c"),
+        HttpUrl.parse("http://host/a/%7A/c").pathSegments());
+    assertEquals(Arrays.asList("a", "z", "c"),
+        HttpUrl.parse("http://host/a/%7a/c").pathSegments());
+  }
+
+  @Test public void malformedPercentEncoding() {
+    assertEquals(Arrays.asList("a%f", "b"),
+        HttpUrl.parse("http://host/a%f/b").pathSegments());
+    assertEquals(Arrays.asList("%", "b"),
+        HttpUrl.parse("http://host/%/b").pathSegments());
+    assertEquals(Arrays.asList("%"),
+        HttpUrl.parse("http://host/%").pathSegments());
+  }
+
+  @Test public void malformedUtf8Encoding() {
+    // Replace a partial UTF-8 sequence with the Unicode replacement character.
+    assertEquals(Arrays.asList("a", "\ufffdx", "c"),
+        HttpUrl.parse("http://host/a/%E2%98x/c").pathSegments());
+  }
+
+  @Test public void incompleteUrlComposition() throws Exception {
+    try {
+      new HttpUrl.Builder().scheme("http").build();
+      fail();
+    } catch (IllegalStateException expected) {
+      assertEquals("host == null", expected.getMessage());
+    }
+    try {
+      new HttpUrl.Builder().host("host").build();
+      fail();
+    } catch (IllegalStateException expected) {
+      assertEquals("scheme == null", expected.getMessage());
+    }
+  }
+
+  @Test public void minimalUrlComposition() throws Exception {
+    HttpUrl url = new HttpUrl.Builder().scheme("http").host("host").build();
+    assertEquals("http://host/", url.toString());
+    assertEquals("http", url.scheme());
+    assertEquals("", url.username());
+    assertEquals("", url.password());
+    assertEquals("host", url.host());
+    assertEquals(80, url.port());
+    assertEquals("/", url.encodedPath());
+    assertEquals(null, url.query());
+    assertEquals(null, url.fragment());
+  }
+
+  @Test public void fullUrlComposition() throws Exception {
+    HttpUrl url = new HttpUrl.Builder()
+        .scheme("http")
+        .username("username")
+        .password("password")
+        .host("host")
+        .port(8080)
+        .addPathSegment("path")
+        .query("query")
+        .fragment("fragment")
+        .build();
+    assertEquals("http://username:password@host:8080/path?query#fragment", url.toString());
+    assertEquals("http", url.scheme());
+    assertEquals("username", url.username());
+    assertEquals("password", url.password());
+    assertEquals("host", url.host());
+    assertEquals(8080, url.port());
+    assertEquals("/path", url.encodedPath());
+    assertEquals("query", url.query());
+    assertEquals("fragment", url.fragment());
+  }
+
+  @Test public void changingSchemeChangesDefaultPort() throws Exception {
+    assertEquals(443, HttpUrl.parse("http://example.com")
+        .newBuilder()
+        .scheme("https")
+        .build().port());
+
+    assertEquals(80, HttpUrl.parse("https://example.com")
+        .newBuilder()
+        .scheme("http")
+        .build().port());
+
+    assertEquals(1234, HttpUrl.parse("https://example.com:1234")
+        .newBuilder()
+        .scheme("http")
+        .build().port());
+  }
+
+  @Test public void composeEncodesWhitespace() throws Exception {
+    HttpUrl url = new HttpUrl.Builder()
+        .scheme("http")
+        .username("a\r\n\f\t b")
+        .password("c\r\n\f\t d")
+        .host("host")
+        .addPathSegment("e\r\n\f\t f")
+        .query("g\r\n\f\t h")
+        .fragment("i\r\n\f\t j")
+        .build();
+    assertEquals("http://a%0D%0A%0C%09%20b:c%0D%0A%0C%09%20d@host"
+        + "/e%0D%0A%0C%09%20f?g%0D%0A%0C%09%20h#i%0D%0A%0C%09 j", url.toString());
+    assertEquals("a\r\n\f\t b", url.username());
+    assertEquals("c\r\n\f\t d", url.password());
+    assertEquals("e\r\n\f\t f", url.pathSegments().get(0));
+    assertEquals("g\r\n\f\t h", url.query());
+    assertEquals("i\r\n\f\t j", url.fragment());
+  }
+
+  @Test public void composeFromUnencodedComponents() throws Exception {
+    HttpUrl url = new HttpUrl.Builder()
+        .scheme("http")
+        .username("a:\u0001@/\\?#%b")
+        .password("c:\u0001@/\\?#%d")
+        .host("ef")
+        .port(8080)
+        .addPathSegment("g:\u0001@/\\?#%h")
+        .query("i:\u0001@/\\?#%j")
+        .fragment("k:\u0001@/\\?#%l")
+        .build();
+    assertEquals("http://a%3A%01%40%2F%5C%3F%23%25b:c%3A%01%40%2F%5C%3F%23%25d@ef:8080/"
+        + "g:%01@%2F%5C%3F%23%25h?i:%01@/\\?%23%25j#k:%01@/\\?#%25l", url.toString());
+    assertEquals("http", url.scheme());
+    assertEquals("a:\u0001@/\\?#%b", url.username());
+    assertEquals("c:\u0001@/\\?#%d", url.password());
+    assertEquals(Arrays.asList("g:\u0001@/\\?#%h"), url.pathSegments());
+    assertEquals("i:\u0001@/\\?#%j", url.query());
+    assertEquals("k:\u0001@/\\?#%l", url.fragment());
+    assertEquals("a%3A%01%40%2F%5C%3F%23%25b", url.encodedUsername());
+    assertEquals("c%3A%01%40%2F%5C%3F%23%25d", url.encodedPassword());
+    assertEquals("/g:%01@%2F%5C%3F%23%25h", url.encodedPath());
+    assertEquals("i:%01@/\\?%23%25j", url.encodedQuery());
+    assertEquals("k:%01@/\\?#%25l", url.encodedFragment());
+  }
+
+  @Test public void composeFromEncodedComponents() throws Exception {
+    HttpUrl url = new HttpUrl.Builder()
+        .scheme("http")
+        .encodedUsername("a:\u0001@/\\?#%25b")
+        .encodedPassword("c:\u0001@/\\?#%25d")
+        .host("ef")
+        .port(8080)
+        .addEncodedPathSegment("g:\u0001@/\\?#%25h")
+        .encodedQuery("i:\u0001@/\\?#%25j")
+        .encodedFragment("k:\u0001@/\\?#%25l")
+        .build();
+    assertEquals("http://a%3A%01%40%2F%5C%3F%23%25b:c%3A%01%40%2F%5C%3F%23%25d@ef:8080/"
+        + "g:%01@%2F%5C%3F%23%25h?i:%01@/\\?%23%25j#k:%01@/\\?#%25l", url.toString());
+    assertEquals("http", url.scheme());
+    assertEquals("a:\u0001@/\\?#%b", url.username());
+    assertEquals("c:\u0001@/\\?#%d", url.password());
+    assertEquals(Arrays.asList("g:\u0001@/\\?#%h"), url.pathSegments());
+    assertEquals("i:\u0001@/\\?#%j", url.query());
+    assertEquals("k:\u0001@/\\?#%l", url.fragment());
+    assertEquals("a%3A%01%40%2F%5C%3F%23%25b", url.encodedUsername());
+    assertEquals("c%3A%01%40%2F%5C%3F%23%25d", url.encodedPassword());
+    assertEquals("/g:%01@%2F%5C%3F%23%25h", url.encodedPath());
+    assertEquals("i:%01@/\\?%23%25j", url.encodedQuery());
+    assertEquals("k:%01@/\\?#%25l", url.encodedFragment());
+  }
+
+  @Test public void composeWithEncodedPath() throws Exception {
+    HttpUrl url = new HttpUrl.Builder()
+        .scheme("http")
+        .host("host")
+        .encodedPath("/a%2Fb/c")
+        .build();
+    assertEquals("http://host/a%2Fb/c", url.toString());
+    assertEquals("/a%2Fb/c", url.encodedPath());
+    assertEquals(Arrays.asList("a/b", "c"), url.pathSegments());
+  }
+
+  @Test public void composeMixingPathSegments() throws Exception {
+    HttpUrl url = new HttpUrl.Builder()
+        .scheme("http")
+        .host("host")
+        .encodedPath("/a%2fb/c")
+        .addPathSegment("d%25e")
+        .addEncodedPathSegment("f%25g")
+        .build();
+    assertEquals("http://host/a%2fb/c/d%2525e/f%25g", url.toString());
+    assertEquals("/a%2fb/c/d%2525e/f%25g", url.encodedPath());
+    assertEquals(Arrays.asList("a%2fb", "c", "d%2525e", "f%25g"), url.encodedPathSegments());
+    assertEquals(Arrays.asList("a/b", "c", "d%25e", "f%g"), url.pathSegments());
+  }
+
+  @Test public void composeWithAddSegment() throws Exception {
+    HttpUrl base = HttpUrl.parse("http://host/a/b/c");
+    assertEquals("/a/b/c/", base.newBuilder().addPathSegment("").build().encodedPath());
+    assertEquals("/a/b/c/d",
+        base.newBuilder().addPathSegment("").addPathSegment("d").build().encodedPath());
+    assertEquals("/a/b/", base.newBuilder().addPathSegment("..").build().encodedPath());
+    assertEquals("/a/b/", base.newBuilder().addPathSegment("").addPathSegment("..").build()
+        .encodedPath());
+    assertEquals("/a/b/c/", base.newBuilder().addPathSegment("").addPathSegment("").build()
+        .encodedPath());
+  }
+
+  @Test public void pathSize() throws Exception {
+    assertEquals(1, HttpUrl.parse("http://host/").pathSize());
+    assertEquals(3, HttpUrl.parse("http://host/a/b/c").pathSize());
+  }
+
+  @Test public void addPathSegmentDotDoesNothing() throws Exception {
+    HttpUrl base = HttpUrl.parse("http://host/a/b/c");
+    assertEquals("/a/b/c", base.newBuilder().addPathSegment(".").build().encodedPath());
+  }
+
+  @Test public void addPathSegmentEncodes() throws Exception {
+    HttpUrl base = HttpUrl.parse("http://host/a/b/c");
+    assertEquals("/a/b/c/%252e",
+        base.newBuilder().addPathSegment("%2e").build().encodedPath());
+    assertEquals("/a/b/c/%252e%252e",
+        base.newBuilder().addPathSegment("%2e%2e").build().encodedPath());
+  }
+
+  @Test public void addPathSegmentDotDotPopsDirectory() throws Exception {
+    HttpUrl base = HttpUrl.parse("http://host/a/b/c");
+    assertEquals("/a/b/", base.newBuilder().addPathSegment("..").build().encodedPath());
+  }
+
+  @Test public void addPathSegmentDotAndIgnoredCharacter() throws Exception {
+    HttpUrl base = HttpUrl.parse("http://host/a/b/c");
+    assertEquals("/a/b/c/.%0A", base.newBuilder().addPathSegment(".\n").build().encodedPath());
+  }
+
+  @Test public void addEncodedPathSegmentDotAndIgnoredCharacter() throws Exception {
+    HttpUrl base = HttpUrl.parse("http://host/a/b/c");
+    assertEquals("/a/b/c", base.newBuilder().addEncodedPathSegment(".\n").build().encodedPath());
+  }
+
+  @Test public void addEncodedPathSegmentDotDotAndIgnoredCharacter() throws Exception {
+    HttpUrl base = HttpUrl.parse("http://host/a/b/c");
+    assertEquals("/a/b/", base.newBuilder().addEncodedPathSegment("..\n").build().encodedPath());
+  }
+
+  @Test public void setPathSegment() throws Exception {
+    HttpUrl base = HttpUrl.parse("http://host/a/b/c");
+    assertEquals("/d/b/c", base.newBuilder().setPathSegment(0, "d").build().encodedPath());
+    assertEquals("/a/d/c", base.newBuilder().setPathSegment(1, "d").build().encodedPath());
+    assertEquals("/a/b/d", base.newBuilder().setPathSegment(2, "d").build().encodedPath());
+  }
+
+  @Test public void setPathSegmentEncodes() throws Exception {
+    HttpUrl base = HttpUrl.parse("http://host/a/b/c");
+    assertEquals("/%2525/b/c", base.newBuilder().setPathSegment(0, "%25").build().encodedPath());
+    assertEquals("/.%0A/b/c", base.newBuilder().setPathSegment(0, ".\n").build().encodedPath());
+    assertEquals("/%252e/b/c", base.newBuilder().setPathSegment(0, "%2e").build().encodedPath());
+  }
+
+  @Test public void setPathSegmentAcceptsEmpty() throws Exception {
+    HttpUrl base = HttpUrl.parse("http://host/a/b/c");
+    assertEquals("//b/c", base.newBuilder().setPathSegment(0, "").build().encodedPath());
+    assertEquals("/a/b/", base.newBuilder().setPathSegment(2, "").build().encodedPath());
+  }
+
+  @Test public void setPathSegmentRejectsDot() throws Exception {
+    HttpUrl base = HttpUrl.parse("http://host/a/b/c");
+    try {
+      base.newBuilder().setPathSegment(0, ".");
+      fail();
+    } catch (IllegalArgumentException expected) {
+    }
+  }
+
+  @Test public void setPathSegmentRejectsDotDot() throws Exception {
+    HttpUrl base = HttpUrl.parse("http://host/a/b/c");
+    try {
+      base.newBuilder().setPathSegment(0, "..");
+      fail();
+    } catch (IllegalArgumentException expected) {
+    }
+  }
+
+  @Test public void setPathSegmentWithSlash() throws Exception {
+    HttpUrl base = HttpUrl.parse("http://host/a/b/c");
+    HttpUrl url = base.newBuilder().setPathSegment(1, "/").build();
+    assertEquals("/a/%2F/c", url.encodedPath());
+  }
+
+  @Test public void setPathSegmentOutOfBounds() throws Exception {
+    try {
+      new HttpUrl.Builder().setPathSegment(1, "a");
+      fail();
+    } catch (IndexOutOfBoundsException expected) {
+    }
+  }
+
+  @Test public void setEncodedPathSegmentEncodes() throws Exception {
+    HttpUrl base = HttpUrl.parse("http://host/a/b/c");
+    assertEquals("/%25/b/c",
+        base.newBuilder().setEncodedPathSegment(0, "%25").build().encodedPath());
+  }
+
+  @Test public void setEncodedPathSegmentRejectsDot() throws Exception {
+    HttpUrl base = HttpUrl.parse("http://host/a/b/c");
+    try {
+      base.newBuilder().setEncodedPathSegment(0, ".");
+      fail();
+    } catch (IllegalArgumentException expected) {
+    }
+  }
+
+  @Test public void setEncodedPathSegmentRejectsDotAndIgnoredCharacter() throws Exception {
+    HttpUrl base = HttpUrl.parse("http://host/a/b/c");
+    try {
+      base.newBuilder().setEncodedPathSegment(0, ".\n");
+      fail();
+    } catch (IllegalArgumentException expected) {
+    }
+  }
+
+  @Test public void setEncodedPathSegmentRejectsDotDot() throws Exception {
+    HttpUrl base = HttpUrl.parse("http://host/a/b/c");
+    try {
+      base.newBuilder().setEncodedPathSegment(0, "..");
+      fail();
+    } catch (IllegalArgumentException expected) {
+    }
+  }
+
+  @Test public void setEncodedPathSegmentRejectsDotDotAndIgnoredCharacter() throws Exception {
+    HttpUrl base = HttpUrl.parse("http://host/a/b/c");
+    try {
+      base.newBuilder().setEncodedPathSegment(0, "..\n");
+      fail();
+    } catch (IllegalArgumentException expected) {
+    }
+  }
+
+  @Test public void setEncodedPathSegmentWithSlash() throws Exception {
+    HttpUrl base = HttpUrl.parse("http://host/a/b/c");
+    HttpUrl url = base.newBuilder().setEncodedPathSegment(1, "/").build();
+    assertEquals("/a/%2F/c", url.encodedPath());
+  }
+
+  @Test public void setEncodedPathSegmentOutOfBounds() throws Exception {
+    try {
+      new HttpUrl.Builder().setEncodedPathSegment(1, "a");
+      fail();
+    } catch (IndexOutOfBoundsException expected) {
+    }
+  }
+
+  @Test public void removePathSegment() throws Exception {
+    HttpUrl base = HttpUrl.parse("http://host/a/b/c");
+    HttpUrl url = base.newBuilder()
+        .removePathSegment(0)
+        .build();
+    assertEquals("/b/c", url.encodedPath());
+  }
+
+  @Test public void removePathSegmentDoesntRemovePath() throws Exception {
+    HttpUrl base = HttpUrl.parse("http://host/a/b/c");
+    HttpUrl url = base.newBuilder()
+        .removePathSegment(0)
+        .removePathSegment(0)
+        .removePathSegment(0)
+        .build();
+    assertEquals(Arrays.asList(""), url.pathSegments());
+    assertEquals("/", url.encodedPath());
+  }
+
+  @Test public void removePathSegmentOutOfBounds() throws Exception {
+    try {
+      new HttpUrl.Builder().removePathSegment(1);
+      fail();
+    } catch (IndexOutOfBoundsException expected) {
+    }
+  }
+
+  @Test public void toJavaNetUrl() throws Exception {
+    HttpUrl httpUrl = HttpUrl.parse("http://username:password@host/path?query#fragment");
+    URL javaNetUrl = httpUrl.url();
+    assertEquals("http://username:password@host/path?query#fragment", javaNetUrl.toString());
+  }
+
+  @Test public void toUri() throws Exception {
+    HttpUrl httpUrl = HttpUrl.parse("http://username:password@host/path?query#fragment");
+    URI uri = httpUrl.uri();
+    assertEquals("http://username:password@host/path?query#fragment", uri.toString());
+  }
+
+  @Test public void toUriSpecialQueryCharacters() throws Exception {
+    HttpUrl httpUrl = HttpUrl.parse("http://host/?d=abc!@[]^`{}|\\");
+    URI uri = httpUrl.uri();
+    assertEquals("http://host/?d=abc!@[]%5E%60%7B%7D%7C%5C", uri.toString());
+  }
+
+  @Test public void toUriForbiddenCharacter() throws Exception {
+    HttpUrl httpUrl = HttpUrl.parse("http://host/a[b");
+    try {
+      httpUrl.uri();
+      fail();
+    } catch (IllegalStateException expected) {
+      assertEquals("not valid as a java.net.URI: http://host/a[b", expected.getMessage());
+    }
+  }
+
+  @Test public void fromJavaNetUrl() throws Exception {
+    URL javaNetUrl = new URL("http://username:password@host/path?query#fragment");
+    HttpUrl httpUrl = HttpUrl.get(javaNetUrl);
+    assertEquals("http://username:password@host/path?query#fragment", httpUrl.toString());
+  }
+
+  @Test public void fromJavaNetUrlUnsupportedScheme() throws Exception {
+    URL javaNetUrl = new URL("mailto:user@example.com");
+    assertEquals(null, HttpUrl.get(javaNetUrl));
+  }
+
+  @Test public void fromUri() throws Exception {
+    URI uri = new URI("http://username:password@host/path?query#fragment");
+    HttpUrl httpUrl = HttpUrl.get(uri);
+    assertEquals("http://username:password@host/path?query#fragment", httpUrl.toString());
+  }
+
+  @Test public void fromUriUnsupportedScheme() throws Exception {
+    URI uri = new URI("mailto:user@example.com");
+    assertEquals(null, HttpUrl.get(uri));
+  }
+
+  @Test public void fromUriPartial() throws Exception {
+    URI uri = new URI("/path");
+    assertEquals(null, HttpUrl.get(uri));
+  }
+
+  @Test public void fromJavaNetUrl_checked() throws Exception {
+    HttpUrl httpUrl = HttpUrl.getChecked("http://username:password@host/path?query#fragment");
+    assertEquals("http://username:password@host/path?query#fragment", httpUrl.toString());
+  }
+
+  @Test public void fromJavaNetUrlUnsupportedScheme_checked() throws Exception {
+    try {
+      HttpUrl.getChecked("mailto:user@example.com");
+      fail();
+    } catch (MalformedURLException e) {
+    }
+  }
+
+  @Test public void fromJavaNetUrlBadHost_checked() throws Exception {
+    try {
+      HttpUrl.getChecked("http://hostw ithspace/");
+      fail();
+    } catch (UnknownHostException expected) {
+    }
+  }
+
+  @Test public void composeQueryWithComponents() throws Exception {
+    HttpUrl base = HttpUrl.parse("http://host/");
+    HttpUrl url = base.newBuilder().addQueryParameter("a+=& b", "c+=& d").build();
+    assertEquals("http://host/?a%2B%3D%26%20b=c%2B%3D%26%20d", url.toString());
+    assertEquals("c+=& d", url.queryParameterValue(0));
+    assertEquals("a+=& b", url.queryParameterName(0));
+    assertEquals("c+=& d", url.queryParameter("a+=& b"));
+    assertEquals(Collections.singleton("a+=& b"), url.queryParameterNames());
+    assertEquals(singletonList("c+=& d"), url.queryParameterValues("a+=& b"));
+    assertEquals(1, url.querySize());
+    assertEquals("a+=& b=c+=& d", url.query()); // Ambiguous! (Though working as designed.)
+    assertEquals("a%2B%3D%26%20b=c%2B%3D%26%20d", url.encodedQuery());
+  }
+
+  @Test public void composeQueryWithEncodedComponents() throws Exception {
+    HttpUrl base = HttpUrl.parse("http://host/");
+    HttpUrl url = base.newBuilder().addEncodedQueryParameter("a+=& b", "c+=& d").build();
+    assertEquals("http://host/?a%20%3D%26%20b=c%20%3D%26%20d", url.toString());
+    assertEquals("c =& d", url.queryParameter("a =& b"));
+  }
+
+  @Test public void composeQueryRemoveQueryParameter() throws Exception {
+    HttpUrl url = HttpUrl.parse("http://host/").newBuilder()
+        .addQueryParameter("a+=& b", "c+=& d")
+        .removeAllQueryParameters("a+=& b")
+        .build();
+    assertEquals("http://host/", url.toString());
+    assertEquals(null, url.queryParameter("a+=& b"));
+  }
+
+  @Test public void composeQueryRemoveEncodedQueryParameter() throws Exception {
+    HttpUrl url = HttpUrl.parse("http://host/").newBuilder()
+        .addEncodedQueryParameter("a+=& b", "c+=& d")
+        .removeAllEncodedQueryParameters("a+=& b")
+        .build();
+    assertEquals("http://host/", url.toString());
+    assertEquals(null, url.queryParameter("a =& b"));
+  }
+
+  @Test public void composeQuerySetQueryParameter() throws Exception {
+    HttpUrl url = HttpUrl.parse("http://host/").newBuilder()
+        .addQueryParameter("a+=& b", "c+=& d")
+        .setQueryParameter("a+=& b", "ef")
+        .build();
+    assertEquals("http://host/?a%2B%3D%26%20b=ef", url.toString());
+    assertEquals("ef", url.queryParameter("a+=& b"));
+  }
+
+  @Test public void composeQuerySetEncodedQueryParameter() throws Exception {
+    HttpUrl url = HttpUrl.parse("http://host/").newBuilder()
+        .addEncodedQueryParameter("a+=& b", "c+=& d")
+        .setEncodedQueryParameter("a+=& b", "ef")
+        .build();
+    assertEquals("http://host/?a%20%3D%26%20b=ef", url.toString());
+    assertEquals("ef", url.queryParameter("a =& b"));
+  }
+
+  @Test public void composeQueryMultipleEncodedValuesForParameter() throws Exception {
+    HttpUrl url = HttpUrl.parse("http://host/").newBuilder()
+        .addQueryParameter("a+=& b", "c+=& d")
+        .addQueryParameter("a+=& b", "e+=& f")
+        .build();
+    assertEquals("http://host/?a%2B%3D%26%20b=c%2B%3D%26%20d&a%2B%3D%26%20b=e%2B%3D%26%20f",
+        url.toString());
+    assertEquals(2, url.querySize());
+    assertEquals(Collections.singleton("a+=& b"), url.queryParameterNames());
+    assertEquals(Arrays.asList("c+=& d", "e+=& f"), url.queryParameterValues("a+=& b"));
+  }
+
+  @Test public void absentQueryIsZeroNameValuePairs() throws Exception {
+    HttpUrl url = HttpUrl.parse("http://host/").newBuilder()
+        .query(null)
+        .build();
+    assertEquals(0, url.querySize());
+  }
+
+  @Test public void emptyQueryIsSingleNameValuePairWithEmptyKey() throws Exception {
+    HttpUrl url = HttpUrl.parse("http://host/").newBuilder()
+        .query("")
+        .build();
+    assertEquals(1, url.querySize());
+    assertEquals("", url.queryParameterName(0));
+    assertEquals(null, url.queryParameterValue(0));
+  }
+
+  @Test public void ampersandQueryIsTwoNameValuePairsWithEmptyKeys() throws Exception {
+    HttpUrl url = HttpUrl.parse("http://host/").newBuilder()
+        .query("&")
+        .build();
+    assertEquals(2, url.querySize());
+    assertEquals("", url.queryParameterName(0));
+    assertEquals(null, url.queryParameterValue(0));
+    assertEquals("", url.queryParameterName(1));
+    assertEquals(null, url.queryParameterValue(1));
+  }
+
+  @Test public void removeAllDoesNotRemoveQueryIfNoParametersWereRemoved() throws Exception {
+    HttpUrl url = HttpUrl.parse("http://host/").newBuilder()
+        .query("")
+        .removeAllQueryParameters("a")
+        .build();
+    assertEquals("http://host/?", url.toString());
+  }
+
+  @Test public void queryParametersWithoutValues() throws Exception {
+    HttpUrl url = HttpUrl.parse("http://host/?foo&bar&baz");
+    assertEquals(3, url.querySize());
+    assertEquals(new LinkedHashSet<>(Arrays.asList("foo", "bar", "baz")),
+        url.queryParameterNames());
+    assertEquals(null, url.queryParameterValue(0));
+    assertEquals(null, url.queryParameterValue(1));
+    assertEquals(null, url.queryParameterValue(2));
+    assertEquals(singletonList((String) null), url.queryParameterValues("foo"));
+    assertEquals(singletonList((String) null), url.queryParameterValues("bar"));
+    assertEquals(singletonList((String) null), url.queryParameterValues("baz"));
+  }
+
+  @Test public void queryParametersWithEmptyValues() throws Exception {
+    HttpUrl url = HttpUrl.parse("http://host/?foo=&bar=&baz=");
+    assertEquals(3, url.querySize());
+    assertEquals(new LinkedHashSet<>(Arrays.asList("foo", "bar", "baz")),
+        url.queryParameterNames());
+    assertEquals("", url.queryParameterValue(0));
+    assertEquals("", url.queryParameterValue(1));
+    assertEquals("", url.queryParameterValue(2));
+    assertEquals(singletonList(""), url.queryParameterValues("foo"));
+    assertEquals(singletonList(""), url.queryParameterValues("bar"));
+    assertEquals(singletonList(""), url.queryParameterValues("baz"));
+  }
+
+  @Test public void queryParametersWithRepeatedName() throws Exception {
+    HttpUrl url = HttpUrl.parse("http://host/?foo[]=1&foo[]=2&foo[]=3");
+    assertEquals(3, url.querySize());
+    assertEquals(Collections.singleton("foo[]"), url.queryParameterNames());
+    assertEquals("1", url.queryParameterValue(0));
+    assertEquals("2", url.queryParameterValue(1));
+    assertEquals("3", url.queryParameterValue(2));
+    assertEquals(Arrays.asList("1", "2", "3"), url.queryParameterValues("foo[]"));
+  }
+
+  @Test public void queryParameterLookupWithNonCanonicalEncoding() throws Exception {
+    HttpUrl url = HttpUrl.parse("http://host/?%6d=m&+=%20");
+    assertEquals("m", url.queryParameterName(0));
+    assertEquals(" ", url.queryParameterName(1));
+    assertEquals("m", url.queryParameter("m"));
+    assertEquals(" ", url.queryParameter(" "));
+  }
+
+  @Test public void roundTripBuilder() throws Exception {
+    HttpUrl url = new HttpUrl.Builder()
+        .scheme("http")
+        .username("%")
+        .password("%")
+        .host("host")
+        .addPathSegment("%")
+        .query("%")
+        .fragment("%")
+        .build();
+    assertEquals("http://%25:%25@host/%25?%25#%25", url.toString());
+    assertEquals("http://%25:%25@host/%25?%25#%25", url.newBuilder().build().toString());
+    assertEquals("http://%25:%25@host/%25?%25", url.resolve("").toString());
+  }
+
+  /**
+   * Although HttpUrl prefers percent-encodings in uppercase, it should preserve the exact
+   * structure of the original encoding.
+   */
+  @Test public void rawEncodingRetained() throws Exception {
+    String urlString = "http://%6d%6D:%6d%6D@host/%6d%6D?%6d%6D#%6d%6D";
+    HttpUrl url = HttpUrl.parse(urlString);
+    assertEquals("%6d%6D", url.encodedUsername());
+    assertEquals("%6d%6D", url.encodedPassword());
+    assertEquals("/%6d%6D", url.encodedPath());
+    assertEquals(Arrays.asList("%6d%6D"), url.encodedPathSegments());
+    assertEquals("%6d%6D", url.encodedQuery());
+    assertEquals("%6d%6D", url.encodedFragment());
+    assertEquals(urlString, url.toString());
+    assertEquals(urlString, url.newBuilder().build().toString());
+    assertEquals("http://%6d%6D:%6d%6D@host/%6d%6D?%6d%6D", url.resolve("").toString());
+  }
+}
diff --git a/okhttp-tests/src/test/java/com/squareup/okhttp/InterceptorTest.java b/okhttp-tests/src/test/java/com/squareup/okhttp/InterceptorTest.java
index 8d16b07458..054343c811 100644
--- a/okhttp-tests/src/test/java/com/squareup/okhttp/InterceptorTest.java
+++ b/okhttp-tests/src/test/java/com/squareup/okhttp/InterceptorTest.java
@@ -16,13 +16,17 @@
 package com.squareup.okhttp;
 
 import com.squareup.okhttp.mockwebserver.MockResponse;
+import com.squareup.okhttp.mockwebserver.MockWebServer;
 import com.squareup.okhttp.mockwebserver.RecordedRequest;
-import com.squareup.okhttp.mockwebserver.rule.MockWebServerRule;
 import java.io.IOException;
-import java.net.URL;
 import java.util.Arrays;
 import java.util.List;
 import java.util.Locale;
+import java.util.concurrent.BlockingQueue;
+import java.util.concurrent.LinkedBlockingQueue;
+import java.util.concurrent.SynchronousQueue;
+import java.util.concurrent.ThreadPoolExecutor;
+import java.util.concurrent.TimeUnit;
 import okio.Buffer;
 import okio.BufferedSink;
 import okio.ForwardingSink;
@@ -41,13 +45,13 @@
 import static org.junit.Assert.fail;
 
 public final class InterceptorTest {
-  @Rule public MockWebServerRule server = new MockWebServerRule();
+  @Rule public MockWebServer server = new MockWebServer();
 
   private OkHttpClient client = new OkHttpClient();
   private RecordingCallback callback = new RecordingCallback();
 
   @Test public void applicationInterceptorsCanShortCircuitResponses() throws Exception {
-    server.get().shutdown(); // Accept no connections.
+    server.shutdown(); // Accept no connections.
 
     Request request = new Request.Builder()
         .url("https://localhost:1/")
@@ -88,7 +92,7 @@
     client.networkInterceptors().add(interceptor);
 
     Request request = new Request.Builder()
-        .url(server.getUrl("/"))
+        .url(server.url("/"))
         .build();
 
     try {
@@ -113,7 +117,7 @@
     client.networkInterceptors().add(interceptor);
 
     Request request = new Request.Builder()
-        .url(server.getUrl("/"))
+        .url(server.url("/"))
         .build();
 
     try {
@@ -134,14 +138,14 @@
         String sameHost = address.getUriHost();
         int differentPort = address.getUriPort() + 1;
         return chain.proceed(chain.request().newBuilder()
-            .url(new URL("http://" + sameHost + ":" + differentPort + "/"))
+            .url(HttpUrl.parse("http://" + sameHost + ":" + differentPort + "/"))
             .build());
       }
     };
     client.networkInterceptors().add(interceptor);
 
     Request request = new Request.Builder()
-        .url(server.getUrl("/"))
+        .url(server.url("/"))
         .build();
 
     try {
@@ -165,7 +169,7 @@
     });
 
     Request request = new Request.Builder()
-        .url(server.getUrl("/"))
+        .url(server.url("/"))
         .build();
     client.newCall(request).execute();
   }
@@ -180,7 +184,7 @@
         // The network request has everything: User-Agent, Host, Accept-Encoding.
         Request networkRequest = chain.request();
         assertNotNull(networkRequest.header("User-Agent"));
-        assertEquals(server.get().getHostName() + ":" + server.get().getPort(),
+        assertEquals(server.getHostName() + ":" + server.getPort(),
             networkRequest.header("Host"));
         assertNotNull(networkRequest.header("Accept-Encoding"));
 
@@ -192,7 +196,7 @@
     });
 
     Request request = new Request.Builder()
-        .url(server.getUrl("/"))
+        .url(server.url("/"))
         .build();
 
     // No extra headers in the application's request.
@@ -228,7 +232,7 @@ private void rewriteRequestToServer(List<Interceptor> interceptors) throws Excep
     });
 
     Request request = new Request.Builder()
-        .url(server.getUrl("/"))
+        .url(server.url("/"))
         .addHeader("Original-Header", "foo")
         .method("PUT", RequestBody.create(MediaType.parse("text/plain"), "abc"))
         .build();
@@ -266,7 +270,7 @@ private void rewriteResponseFromServer(List<Interceptor> interceptors) throws Ex
     });
 
     Request request = new Request.Builder()
-        .url(server.getUrl("/"))
+        .url(server.url("/"))
         .build();
 
     Response response = client.newCall(request).execute();
@@ -310,7 +314,7 @@ private void multipleInterceptors(List<Interceptor> interceptors) throws Excepti
     });
 
     Request request = new Request.Builder()
-        .url(server.getUrl("/"))
+        .url(server.url("/"))
         .build();
 
     Response response = client.newCall(request).execute();
@@ -343,11 +347,11 @@ private void asyncInterceptors(List<Interceptor> interceptors) throws Exception
     });
 
     Request request = new Request.Builder()
-        .url(server.getUrl("/"))
+        .url(server.url("/"))
         .build();
     client.newCall(request).enqueue(callback);
 
-    callback.await(request.url())
+    callback.await(request.httpUrl())
         .assertCode(200)
         .assertHeader("OkHttp-Intercepted", "yep");
   }
@@ -364,13 +368,163 @@ private void asyncInterceptors(List<Interceptor> interceptors) throws Exception
     });
 
     Request request = new Request.Builder()
-        .url(server.getUrl("/"))
+        .url(server.url("/"))
         .build();
 
     Response response = client.newCall(request).execute();
     assertEquals(response.body().string(), "b");
   }
 
+  /** Make sure interceptors can interact with the OkHttp client. */
+  @Test public void interceptorMakesAnUnrelatedRequest() throws Exception {
+    server.enqueue(new MockResponse().setBody("a")); // Fetched by interceptor.
+    server.enqueue(new MockResponse().setBody("b")); // Fetched directly.
+
+    client.interceptors().add(new Interceptor() {
+      @Override public Response intercept(Chain chain) throws IOException {
+        if (chain.request().url().getPath().equals("/b")) {
+          Request requestA = new Request.Builder()
+              .url(server.url("/a"))
+              .build();
+          Response responseA = client.newCall(requestA).execute();
+          assertEquals("a", responseA.body().string());
+        }
+
+        return chain.proceed(chain.request());
+      }
+    });
+
+    Request requestB = new Request.Builder()
+        .url(server.url("/b"))
+        .build();
+    Response responseB = client.newCall(requestB).execute();
+    assertEquals("b", responseB.body().string());
+  }
+
+  /** Make sure interceptors can interact with the OkHttp client asynchronously. */
+  @Test public void interceptorMakesAnUnrelatedAsyncRequest() throws Exception {
+    server.enqueue(new MockResponse().setBody("a")); // Fetched by interceptor.
+    server.enqueue(new MockResponse().setBody("b")); // Fetched directly.
+
+    client.interceptors().add(new Interceptor() {
+      @Override public Response intercept(Chain chain) throws IOException {
+        if (chain.request().url().getPath().equals("/b")) {
+          Request requestA = new Request.Builder()
+              .url(server.url("/a"))
+              .build();
+
+          try {
+            RecordingCallback callbackA = new RecordingCallback();
+            client.newCall(requestA).enqueue(callbackA);
+            callbackA.await(requestA.httpUrl()).assertBody("a");
+          } catch (Exception e) {
+            throw new RuntimeException(e);
+          }
+        }
+
+        return chain.proceed(chain.request());
+      }
+    });
+
+    Request requestB = new Request.Builder()
+        .url(server.url("/b"))
+        .build();
+    RecordingCallback callbackB = new RecordingCallback();
+    client.newCall(requestB).enqueue(callbackB);
+    callbackB.await(requestB.httpUrl()).assertBody("b");
+  }
+
+  @Test public void applicationkInterceptorThrowsRuntimeExceptionSynchronous() throws Exception {
+    interceptorThrowsRuntimeExceptionSynchronous(client.interceptors());
+  }
+
+  @Test public void networkInterceptorThrowsRuntimeExceptionSynchronous() throws Exception {
+    interceptorThrowsRuntimeExceptionSynchronous(client.networkInterceptors());
+  }
+
+  /**
+   * When an interceptor throws an unexpected exception, synchronous callers can catch it and deal
+   * with it.
+   *
+   * TODO(jwilson): test that resources are not leaked when this happens.
+   */
+  private void interceptorThrowsRuntimeExceptionSynchronous(
+      List<Interceptor> interceptors) throws Exception {
+    interceptors.add(new Interceptor() {
+      @Override public Response intercept(Chain chain) throws IOException {
+        throw new RuntimeException("boom!");
+      }
+    });
+
+    Request request = new Request.Builder()
+        .url(server.url("/"))
+        .build();
+
+    try {
+      client.newCall(request).execute();
+      fail();
+    } catch (RuntimeException expected) {
+      assertEquals("boom!", expected.getMessage());
+    }
+  }
+
+  @Test public void applicationInterceptorThrowsRuntimeExceptionAsynchronous() throws Exception {
+    interceptorThrowsRuntimeExceptionAsynchronous(client.interceptors());
+  }
+
+  @Test public void networkInterceptorThrowsRuntimeExceptionAsynchronous() throws Exception {
+    interceptorThrowsRuntimeExceptionAsynchronous(client.networkInterceptors());
+  }
+
+  @Test public void networkInterceptorModifiedRequestIsReturned() throws IOException {
+    server.enqueue(new MockResponse());
+
+    Interceptor modifyHeaderInterceptor = new Interceptor() {
+      @Override public Response intercept(Chain chain) throws IOException {
+        return chain.proceed(chain.request().newBuilder()
+          .header("User-Agent", "intercepted request")
+          .build());
+      }
+    };
+
+    client.networkInterceptors().add(modifyHeaderInterceptor);
+
+    Request request = new Request.Builder()
+        .url(server.url("/"))
+        .header("User-Agent", "user request")
+        .build();
+
+    Response response = client.newCall(request).execute();
+    assertNotNull(response.request().header("User-Agent"));
+    assertEquals("user request", response.request().header("User-Agent"));
+    assertEquals("intercepted request", response.networkResponse().request().header("User-Agent"));
+  }
+
+  /**
+   * When an interceptor throws an unexpected exception, asynchronous callers are left hanging. The
+   * exception goes to the uncaught exception handler.
+   *
+   * TODO(jwilson): test that resources are not leaked when this happens.
+   */
+  private void interceptorThrowsRuntimeExceptionAsynchronous(
+        List<Interceptor> interceptors) throws Exception {
+    interceptors.add(new Interceptor() {
+      @Override public Response intercept(Chain chain) throws IOException {
+        throw new RuntimeException("boom!");
+      }
+    });
+
+    ExceptionCatchingExecutor executor = new ExceptionCatchingExecutor();
+    client.setDispatcher(new Dispatcher(executor));
+
+    Request request = new Request.Builder()
+        .url(server.url("/"))
+        .build();
+    client.newCall(request).enqueue(callback);
+
+    assertEquals("boom!", executor.takeException().getMessage());
+  }
+
   private RequestBody uppercase(final RequestBody original) {
     return new RequestBody() {
       @Override public MediaType contentType() {
@@ -421,4 +575,29 @@ private Buffer gzip(String data) throws IOException {
     sink.close();
     return result;
   }
+
+  /** Catches exceptions that are otherwise headed for the uncaught exception handler. */
+  private static class ExceptionCatchingExecutor extends ThreadPoolExecutor {
+    private final BlockingQueue<Exception> exceptions = new LinkedBlockingQueue<>();
+
+    public ExceptionCatchingExecutor() {
+      super(1, 1, 0, TimeUnit.SECONDS, new SynchronousQueue<Runnable>());
+    }
+
+    @Override public void execute(final Runnable runnable) {
+      super.execute(new Runnable() {
+        @Override public void run() {
+          try {
+            runnable.run();
+          } catch (Exception e) {
+            exceptions.add(e);
+          }
+        }
+      });
+    }
+
+    public Exception takeException() throws InterruptedException {
+      return exceptions.take();
+    }
+  }
 }
diff --git a/okhttp-tests/src/test/java/com/squareup/okhttp/MultipartBuilderTest.java b/okhttp-tests/src/test/java/com/squareup/okhttp/MultipartBuilderTest.java
index 0e12470afb..4159679c76 100644
--- a/okhttp-tests/src/test/java/com/squareup/okhttp/MultipartBuilderTest.java
+++ b/okhttp-tests/src/test/java/com/squareup/okhttp/MultipartBuilderTest.java
@@ -46,7 +46,8 @@ public void onePartRequired() throws Exception {
 
     Buffer buffer = new Buffer();
     requestBody.writeTo(buffer);
-    assertEquals(-1L, requestBody.contentLength());
+    assertEquals(53, requestBody.contentLength());
+    assertEquals(buffer.size(), requestBody.contentLength());
     assertEquals(expected, buffer.readUtf8());
   }
 
@@ -76,7 +77,8 @@ public void onePartRequired() throws Exception {
 
     Buffer buffer = new Buffer();
     requestBody.writeTo(buffer);
-    assertEquals(-1L, requestBody.contentLength());
+    assertEquals(112, requestBody.contentLength());
+    assertEquals(buffer.size(), requestBody.contentLength());
     assertEquals(expected, buffer.readUtf8());
   }
 
@@ -90,6 +92,7 @@ public void onePartRequired() throws Exception {
         + "--AaB03x\r\n"
         + "Content-Disposition: form-data; name=\"files\"\r\n"
         + "Content-Type: multipart/mixed; boundary=BbC04y\r\n"
+        + "Content-Length: 337\r\n"
         + "\r\n"
         + "--BbC04y\r\n"
         + "Content-Disposition: file; filename=\"file1.txt\"\r\n"
@@ -131,7 +134,8 @@ public void onePartRequired() throws Exception {
 
     Buffer buffer = new Buffer();
     requestBody.writeTo(buffer);
-    assertEquals(-1L, requestBody.contentLength());
+    assertEquals(568, requestBody.contentLength());
+    assertEquals(buffer.size(), requestBody.contentLength());
     assertEquals(expected, buffer.readUtf8());
   }
 
diff --git a/okhttp-tests/src/test/java/com/squareup/okhttp/OkHttpClientTest.java b/okhttp-tests/src/test/java/com/squareup/okhttp/OkHttpClientTest.java
index 0bb8d1a80d..7f2635b306 100644
--- a/okhttp-tests/src/test/java/com/squareup/okhttp/OkHttpClientTest.java
+++ b/okhttp-tests/src/test/java/com/squareup/okhttp/OkHttpClientTest.java
@@ -32,6 +32,7 @@
 import java.util.Arrays;
 import java.util.List;
 import java.util.Map;
+import java.util.concurrent.TimeUnit;
 import javax.net.SocketFactory;
 import org.junit.After;
 import org.junit.Test;
@@ -56,13 +57,48 @@
     Authenticator.setDefault(DEFAULT_AUTHENTICATOR);
   }
 
+  @Test public void timeoutDefaults() {
+    OkHttpClient client = new OkHttpClient();
+    assertEquals(10_000, client.getConnectTimeout());
+    assertEquals(10_000, client.getReadTimeout());
+    assertEquals(10_000, client.getWriteTimeout());
+  }
+
+  @Test public void timeoutValidRange() {
+    OkHttpClient client = new OkHttpClient();
+    try {
+      client.setConnectTimeout(1, TimeUnit.NANOSECONDS);
+    } catch (IllegalArgumentException ignored) {
+    }
+    try {
+      client.setWriteTimeout(1, TimeUnit.NANOSECONDS);
+    } catch (IllegalArgumentException ignored) {
+    }
+    try {
+      client.setReadTimeout(1, TimeUnit.NANOSECONDS);
+    } catch (IllegalArgumentException ignored) {
+    }
+    try {
+      client.setConnectTimeout(365, TimeUnit.DAYS);
+    } catch (IllegalArgumentException ignored) {
+    }
+    try {
+      client.setWriteTimeout(365, TimeUnit.DAYS);
+    } catch (IllegalArgumentException ignored) {
+    }
+    try {
+      client.setReadTimeout(365, TimeUnit.DAYS);
+    } catch (IllegalArgumentException ignored) {
+    }
+  }
+
   /** Confirm that {@code copyWithDefaults} gets expected constant values. */
   @Test public void copyWithDefaultsWhenDefaultIsAConstant() throws Exception {
     OkHttpClient client = new OkHttpClient().copyWithDefaults();
     assertNull(client.internalCache());
-    assertEquals(0, client.getConnectTimeout());
-    assertEquals(0, client.getReadTimeout());
-    assertEquals(0, client.getWriteTimeout());
+    assertEquals(10_000, client.getConnectTimeout());
+    assertEquals(10_000, client.getReadTimeout());
+    assertEquals(10_000, client.getWriteTimeout());
     assertTrue(client.getFollowSslRedirects());
     assertNull(client.getProxy());
     assertEquals(Arrays.asList(Protocol.HTTP_2, Protocol.SPDY_3, Protocol.HTTP_1_1),
@@ -117,6 +153,15 @@
     assertNull(client.internalCache());
   }
 
+  @Test public void clonedInterceptorsListsAreIndependent() throws Exception {
+    OkHttpClient original = new OkHttpClient();
+    OkHttpClient clone = original.clone();
+    clone.interceptors().add(null);
+    clone.networkInterceptors().add(null);
+    assertEquals(0, original.interceptors().size());
+    assertEquals(0, original.networkInterceptors().size());
+  }
+
   /**
    * When copying the client, stateful things like the connection pool are
    * shared across all clients.
@@ -139,49 +184,6 @@
     assertSame(a.getSslSocketFactory(), b.getSslSocketFactory());
   }
 
-  /** We don't want to run user code inside of HttpEngine, etc. */
-  @Test public void copyWithDefaultsDoesNotReturnSubclass() throws Exception {
-    OkHttpClient subclass = new OkHttpClient() {};
-    OkHttpClient copy = subclass.copyWithDefaults();
-    assertEquals(OkHttpClient.class, copy.getClass());
-  }
-
-  @Test public void cloneReturnsSubclass() throws Exception {
-    OkHttpClient subclass = new OkHttpClient() {};
-    OkHttpClient clone = subclass.clone();
-    assertEquals(subclass.getClass(), clone.getClass());
-  }
-
-  /** Exercise a synchronous mocking case. */
-  @Test public void mock() throws Exception {
-    final Request request = new Request.Builder()
-        .url("http://example.com/")
-        .build();
-    final Response response = new Response.Builder()
-        .protocol(Protocol.HTTP_1_1)
-        .request(request)
-        .code(200)
-        .message("Alright")
-        .build();
-
-    OkHttpClient mockClient = new OkHttpClient() {
-      @Override public Call newCall(Request request) {
-        return new Call(this, request) {
-          @Override public Response execute() throws IOException {
-            return response;
-          }
-          @Override public void enqueue(Callback responseCallback) {
-          }
-          @Override public void cancel() {
-          }
-        };
-      }
-    };
-
-    Response actualResponse = mockClient.newCall(request).execute();
-    assertSame(response, actualResponse);
-  }
-
   @Test public void setProtocolsRejectsHttp10() throws Exception {
     OkHttpClient client = new OkHttpClient();
     try {
diff --git a/okhttp-tests/src/test/java/com/squareup/okhttp/RecordedResponse.java b/okhttp-tests/src/test/java/com/squareup/okhttp/RecordedResponse.java
index fdb1404df6..129fecf145 100644
--- a/okhttp-tests/src/test/java/com/squareup/okhttp/RecordedResponse.java
+++ b/okhttp-tests/src/test/java/com/squareup/okhttp/RecordedResponse.java
@@ -15,7 +15,7 @@
  */
 package com.squareup.okhttp;
 
-import com.squareup.okhttp.internal.ws.WebSocket;
+import com.squareup.okhttp.ws.WebSocket;
 import java.io.IOException;
 import java.net.URL;
 import java.util.Arrays;
diff --git a/okhttp-tests/src/test/java/com/squareup/okhttp/RecordingCallback.java b/okhttp-tests/src/test/java/com/squareup/okhttp/RecordingCallback.java
index 73e38f0e95..9d651473bc 100644
--- a/okhttp-tests/src/test/java/com/squareup/okhttp/RecordingCallback.java
+++ b/okhttp-tests/src/test/java/com/squareup/okhttp/RecordingCallback.java
@@ -16,7 +16,6 @@
 package com.squareup.okhttp;
 
 import java.io.IOException;
-import java.net.URL;
 import java.util.ArrayList;
 import java.util.Iterator;
 import java.util.List;
@@ -49,12 +48,12 @@
    * Returns the recorded response triggered by {@code request}. Throws if the
    * response isn't enqueued before the timeout.
    */
-  public synchronized RecordedResponse await(URL url) throws Exception {
+  public synchronized RecordedResponse await(HttpUrl url) throws Exception {
     long timeoutMillis = TimeUnit.NANOSECONDS.toMillis(System.nanoTime()) + TIMEOUT_MILLIS;
     while (true) {
       for (Iterator<RecordedResponse> i = responses.iterator(); i.hasNext(); ) {
         RecordedResponse recordedResponse = i.next();
-        if (recordedResponse.request.url().equals(url)) {
+        if (recordedResponse.request.httpUrl().equals(url)) {
           i.remove();
           return recordedResponse;
         }
@@ -68,9 +67,9 @@ public synchronized RecordedResponse await(URL url) throws Exception {
     throw new AssertionError("Timed out waiting for response to " + url);
   }
 
-  public synchronized void assertNoResponse(URL url) throws Exception {
+  public synchronized void assertNoResponse(HttpUrl url) throws Exception {
     for (RecordedResponse recordedResponse : responses) {
-      if (recordedResponse.request.url().equals(url)) {
+      if (recordedResponse.request.httpUrl().equals(url)) {
         throw new AssertionError("Expected no response for " + url);
       }
     }
diff --git a/okhttp-tests/src/test/java/com/squareup/okhttp/RequestTest.java b/okhttp-tests/src/test/java/com/squareup/okhttp/RequestTest.java
index 8a74d1b6e8..39da50037c 100644
--- a/okhttp-tests/src/test/java/com/squareup/okhttp/RequestTest.java
+++ b/okhttp-tests/src/test/java/com/squareup/okhttp/RequestTest.java
@@ -28,6 +28,7 @@
 
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertNull;
+import static org.junit.Assert.fail;
 
 public final class RequestTest {
   @Test public void string() throws Exception {
@@ -64,6 +65,15 @@
     assertEquals("Retransmit body", "616263", bodyToHex(body));
   }
 
+  @Test public void byteArrayRange() throws Exception {
+    MediaType contentType = MediaType.parse("text/plain");
+    RequestBody body = RequestBody.create(contentType, ".abcd".getBytes(Util.UTF_8), 1, 3);
+    assertEquals(contentType, body.contentType());
+    assertEquals(3, body.contentLength());
+    assertEquals("616263", bodyToHex(body));
+    assertEquals("Retransmit body", "616263", bodyToHex(body));
+  }
+
   @Test public void file() throws Exception {
     File file = File.createTempFile("RequestTest", "tmp");
     FileWriter writer = new FileWriter(file);
@@ -114,6 +124,19 @@
     assertEquals(new URL("http://localhost/api"), request.url());
   }
 
+  @Test public void newBuilderUrlResetsUrl() throws Exception {
+    Request requestWithoutCache = new Request.Builder().url("http://localhost/api").build();
+    Request builtRequestWithoutCache = requestWithoutCache.newBuilder().url("http://localhost/api/foo").build();
+    assertEquals(new URL("http://localhost/api/foo"), builtRequestWithoutCache.url());
+
+    Request requestWithCache = new Request.Builder().url("http://localhost/api").build();
+    // cache url object
+    requestWithCache.url();
+    Request builtRequestWithCache = requestWithCache.newBuilder().url(
+        "http://localhost/api/foo").build();
+    assertEquals(new URL("http://localhost/api/foo"), builtRequestWithCache.url());
+  }
+
   @Test public void cacheControl() throws Exception {
     Request request = new Request.Builder()
         .cacheControl(new CacheControl.Builder().noCache().build())
@@ -131,6 +154,62 @@
     assertEquals(Collections.<String>emptyList(), request.headers("Cache-Control"));
   }
 
+  @Test public void headerAcceptsPermittedCharacters() throws Exception {
+    Request.Builder builder = new Request.Builder();
+    builder.header("AZab09 ~", "AZab09 ~");
+    builder.addHeader("AZab09 ~", "AZab09 ~");
+  }
+
+  @Test public void emptyNameForbidden() throws Exception {
+    Request.Builder builder = new Request.Builder();
+    try {
+      builder.header("", "Value");
+      fail();
+    } catch (IllegalArgumentException expected) {
+    }
+    try {
+      builder.addHeader("", "Value");
+      fail();
+    } catch (IllegalArgumentException expected) {
+    }
+  }
+
+  @Test public void headerForbidsControlCharacters() throws Exception {
+    assertForbiddenHeader(null);
+    assertForbiddenHeader("\u0000");
+    assertForbiddenHeader("\r");
+    assertForbiddenHeader("\n");
+    assertForbiddenHeader("\t");
+    assertForbiddenHeader("\u001f");
+    assertForbiddenHeader("\u007f");
+    assertForbiddenHeader("\u0080");
+    assertForbiddenHeader("\ud83c\udf69");
+  }
+
+  private void assertForbiddenHeader(String s) {
+    Request.Builder builder = new Request.Builder();
+    try {
+      builder.header(s, "Value");
+      fail();
+    } catch (IllegalArgumentException expected) {
+    }
+    try {
+      builder.addHeader(s, "Value");
+      fail();
+    } catch (IllegalArgumentException expected) {
+    }
+    try {
+      builder.header("Name", s);
+      fail();
+    } catch (IllegalArgumentException expected) {
+    }
+    try {
+      builder.addHeader("Name", s);
+      fail();
+    } catch (IllegalArgumentException expected) {
+    }
+  }
+
   private String bodyToHex(RequestBody body) throws IOException {
     Buffer buffer = new Buffer();
     body.writeTo(buffer);
diff --git a/okhttp-tests/src/test/java/com/squareup/okhttp/SocksProxyTest.java b/okhttp-tests/src/test/java/com/squareup/okhttp/SocksProxyTest.java
index 9b10213c27..377ff83d9b 100644
--- a/okhttp-tests/src/test/java/com/squareup/okhttp/SocksProxyTest.java
+++ b/okhttp-tests/src/test/java/com/squareup/okhttp/SocksProxyTest.java
@@ -51,11 +51,11 @@
     OkHttpClient client = new OkHttpClient()
         .setProxy(socksProxy.proxy());
 
-    Request request1 = new Request.Builder().url(server.getUrl("/")).build();
+    Request request1 = new Request.Builder().url(server.url("/")).build();
     Response response1 = client.newCall(request1).execute();
     assertEquals("abc", response1.body().string());
 
-    Request request2 = new Request.Builder().url(server.getUrl("/")).build();
+    Request request2 = new Request.Builder().url(server.url("/")).build();
     Response response2 = client.newCall(request2).execute();
     assertEquals("def", response2.body().string());
 
@@ -79,7 +79,7 @@
     OkHttpClient client = new OkHttpClient()
         .setProxySelector(proxySelector);
 
-    Request request = new Request.Builder().url(server.getUrl("/")).build();
+    Request request = new Request.Builder().url(server.url("/")).build();
     Response response = client.newCall(request).execute();
     assertEquals("abc", response.body().string());
 
diff --git a/okhttp-tests/src/test/java/com/squareup/okhttp/TestUtil.java b/okhttp-tests/src/test/java/com/squareup/okhttp/TestUtil.java
index 10f0d4df19..bf2ed4a237 100644
--- a/okhttp-tests/src/test/java/com/squareup/okhttp/TestUtil.java
+++ b/okhttp-tests/src/test/java/com/squareup/okhttp/TestUtil.java
@@ -1,8 +1,12 @@
 package com.squareup.okhttp;
 
-import com.squareup.okhttp.internal.spdy.Header;
+import com.squareup.okhttp.internal.framed.Header;
 import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.Collection;
+import java.util.LinkedHashSet;
 import java.util.List;
+import java.util.Set;
 
 public final class TestUtil {
   private TestUtil() {
@@ -15,4 +19,18 @@ private TestUtil() {
     }
     return result;
   }
+
+  public static <T> Set<T> setOf(T... elements) {
+    return setOf(Arrays.asList(elements));
+  }
+
+  public static <T> Set<T> setOf(Collection<T> elements) {
+    return new LinkedHashSet<>(elements);
+  }
+
+  public static String repeat(char c, int count) {
+    char[] array = new char[count];
+    Arrays.fill(array, c);
+    return new String(array);
+  }
 }
diff --git a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/URLConnectionTest.java b/okhttp-tests/src/test/java/com/squareup/okhttp/URLConnectionTest.java
similarity index 92%
rename from okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/URLConnectionTest.java
rename to okhttp-tests/src/test/java/com/squareup/okhttp/URLConnectionTest.java
index 330929b332..28dc44b145 100644
--- a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/URLConnectionTest.java
+++ b/okhttp-tests/src/test/java/com/squareup/okhttp/URLConnectionTest.java
@@ -14,35 +14,20 @@
  * limitations under the License.
  */
 
-package com.squareup.okhttp.internal.http;
-
-import com.squareup.okhttp.Cache;
-import com.squareup.okhttp.Challenge;
-import com.squareup.okhttp.ConnectionPool;
-import com.squareup.okhttp.ConnectionSpec;
-import com.squareup.okhttp.Credentials;
-import com.squareup.okhttp.DelegatingServerSocketFactory;
-import com.squareup.okhttp.DelegatingSocketFactory;
-import com.squareup.okhttp.FallbackTestClientSocketFactory;
-import com.squareup.okhttp.Headers;
-import com.squareup.okhttp.Interceptor;
-import com.squareup.okhttp.OkHttpClient;
-import com.squareup.okhttp.OkUrlFactory;
-import com.squareup.okhttp.Protocol;
-import com.squareup.okhttp.Response;
-import com.squareup.okhttp.TlsVersion;
+package com.squareup.okhttp;
+
 import com.squareup.okhttp.internal.Internal;
 import com.squareup.okhttp.internal.RecordingAuthenticator;
-import com.squareup.okhttp.internal.RecordingHostnameVerifier;
 import com.squareup.okhttp.internal.RecordingOkAuthenticator;
 import com.squareup.okhttp.internal.SingleInetAddressNetwork;
 import com.squareup.okhttp.internal.SslContextBuilder;
 import com.squareup.okhttp.internal.Util;
+import com.squareup.okhttp.internal.Version;
 import com.squareup.okhttp.mockwebserver.MockResponse;
 import com.squareup.okhttp.mockwebserver.MockWebServer;
 import com.squareup.okhttp.mockwebserver.RecordedRequest;
 import com.squareup.okhttp.mockwebserver.SocketPolicy;
-import com.squareup.okhttp.mockwebserver.rule.MockWebServerRule;
+import com.squareup.okhttp.testing.RecordingHostnameVerifier;
 import java.io.IOException;
 import java.io.InputStream;
 import java.io.OutputStream;
@@ -57,6 +42,7 @@
 import java.net.ServerSocket;
 import java.net.Socket;
 import java.net.SocketAddress;
+import java.net.SocketTimeoutException;
 import java.net.URI;
 import java.net.URL;
 import java.net.URLConnection;
@@ -67,7 +53,7 @@
 import java.util.Arrays;
 import java.util.Collections;
 import java.util.EnumSet;
-import java.util.HashSet;
+import java.util.LinkedHashSet;
 import java.util.List;
 import java.util.Map;
 import java.util.Random;
@@ -113,18 +99,17 @@
 
 /** Android's URLConnectionTest. */
 public final class URLConnectionTest {
-  private static final SSLContext sslContext = SslContextBuilder.localhost();
-
-  @Rule public final MockWebServerRule server = new MockWebServerRule();
-  @Rule public final MockWebServerRule server2 = new MockWebServerRule();
+  @Rule public final MockWebServer server = new MockWebServer();
+  @Rule public final MockWebServer server2 = new MockWebServer();
   @Rule public final TemporaryFolder tempDir = new TemporaryFolder();
 
+  private SSLContext sslContext = SslContextBuilder.localhost();
   private OkUrlFactory client;
   private HttpURLConnection connection;
   private Cache cache;
 
   @Before public void setUp() throws Exception {
-    server.get().setProtocolNegotiationEnabled(false);
+    server.setProtocolNegotiationEnabled(false);
     client = new OkUrlFactory(new OkHttpClient());
   }
 
@@ -151,8 +136,8 @@
     assertEquals("f", connection.getRequestProperty("D"));
     assertEquals("f", connection.getRequestProperty("d"));
     Map<String, List<String>> requestHeaders = connection.getRequestProperties();
-    assertEquals(newSet("e", "f"), new HashSet<String>(requestHeaders.get("D")));
-    assertEquals(newSet("e", "f"), new HashSet<String>(requestHeaders.get("d")));
+    assertEquals(newSet("e", "f"), new LinkedHashSet<>(requestHeaders.get("D")));
+    assertEquals(newSet("e", "f"), new LinkedHashSet<>(requestHeaders.get("d")));
     try {
       requestHeaders.put("G", Arrays.asList("h"));
       fail("Modified an unmodifiable view.");
@@ -223,8 +208,8 @@
     assertEquals("HTTP/1.0 200 Fantastic", connection.getHeaderField(null));
     Map<String, List<String>> responseHeaders = connection.getHeaderFields();
     assertEquals(Arrays.asList("HTTP/1.0 200 Fantastic"), responseHeaders.get(null));
-    assertEquals(newSet("c", "e"), new HashSet<String>(responseHeaders.get("A")));
-    assertEquals(newSet("c", "e"), new HashSet<String>(responseHeaders.get("a")));
+    assertEquals(newSet("c", "e"), new LinkedHashSet<>(responseHeaders.get("A")));
+    assertEquals(newSet("c", "e"), new LinkedHashSet<>(responseHeaders.get("a")));
     try {
       responseHeaders.put("N", Arrays.asList("o"));
       fail("Modified an unmodifiable view.");
@@ -289,7 +274,7 @@
 
   @Test public void connectRetriesUntilConnectedOrFailed() throws Exception {
     URL url = server.getUrl("/foo");
-    server.get().shutdown();
+    server.shutdown();
 
     connection = client.open(url);
     try {
@@ -316,9 +301,9 @@ private void testRequestBodySurvivesRetries(TransferKind transferKind) throws Ex
 
     // Use a misconfigured proxy to guarantee that the request is retried.
     FakeProxySelector proxySelector = new FakeProxySelector();
-    proxySelector.proxies.add(server2.get().toProxyAddress());
+    proxySelector.proxies.add(server2.toProxyAddress());
     client.client().setProxySelector(proxySelector);
-    server2.get().shutdown();
+    server2.shutdown();
 
     connection = client.open(server.getUrl("/def"));
     connection.setDoOutput(true);
@@ -466,7 +451,7 @@ private void testServerClosesOutput(SocketPolicy socketPolicy) throws Exception
 
   private void doUpload(TransferKind uploadKind, WriteKind writeKind) throws Exception {
     int n = 512 * 1024;
-    server.get().setBodyLimit(0);
+    server.setBodyLimit(0);
     server.enqueue(new MockResponse());
 
     HttpURLConnection conn = client.open(server.getUrl("/"));
@@ -516,7 +501,7 @@ private void doUpload(TransferKind uploadKind, WriteKind writeKind) throws Excep
   }
 
   @Test public void connectViaHttps() throws Exception {
-    server.get().useHttps(sslContext.getSocketFactory(), false);
+    server.useHttps(sslContext.getSocketFactory(), false);
     server.enqueue(new MockResponse().setBody("this response comes via HTTPS"));
 
     client.client().setSslSocketFactory(sslContext.getSocketFactory());
@@ -530,7 +515,7 @@ private void doUpload(TransferKind uploadKind, WriteKind writeKind) throws Excep
   }
 
   @Test public void inspectHandshakeThroughoutRequestLifecycle() throws Exception {
-    server.get().useHttps(sslContext.getSocketFactory(), false);
+    server.useHttps(sslContext.getSocketFactory(), false);
     server.enqueue(new MockResponse());
 
     client.client().setSslSocketFactory(sslContext.getSocketFactory());
@@ -559,7 +544,7 @@ private void doUpload(TransferKind uploadKind, WriteKind writeKind) throws Excep
   }
 
   @Test public void connectViaHttpsReusingConnections() throws IOException, InterruptedException {
-    server.get().useHttps(sslContext.getSocketFactory(), false);
+    server.useHttps(sslContext.getSocketFactory(), false);
     server.enqueue(new MockResponse().setBody("this response comes via HTTPS"));
     server.enqueue(new MockResponse().setBody("another response via HTTPS"));
 
@@ -581,7 +566,7 @@ private void doUpload(TransferKind uploadKind, WriteKind writeKind) throws Excep
 
   @Test public void connectViaHttpsReusingConnectionsDifferentFactories()
       throws IOException, InterruptedException {
-    server.get().useHttps(sslContext.getSocketFactory(), false);
+    server.useHttps(sslContext.getSocketFactory(), false);
     server.enqueue(new MockResponse().setBody("this response comes via HTTPS"));
     server.enqueue(new MockResponse().setBody("another response via HTTPS"));
 
@@ -600,8 +585,8 @@ private void doUpload(TransferKind uploadKind, WriteKind writeKind) throws Excep
     }
   }
 
-  @Test public void connectViaHttpsWithSSLFallback() throws IOException, InterruptedException {
-    server.get().useHttps(sslContext.getSocketFactory(), false);
+  @Test public void connectViaHttpsWithSSLFallback() throws Exception {
+    server.useHttps(sslContext.getSocketFactory(), false);
     server.enqueue(new MockResponse().setSocketPolicy(SocketPolicy.FAIL_HANDSHAKE));
     server.enqueue(new MockResponse().setBody("this response comes via SSL"));
 
@@ -613,6 +598,26 @@ private void doUpload(TransferKind uploadKind, WriteKind writeKind) throws Excep
 
     RecordedRequest request = server.takeRequest();
     assertEquals("GET /foo HTTP/1.1", request.getRequestLine());
+    assertEquals(TlsVersion.TLS_1_0, request.getTlsVersion());
+  }
+
+  @Test public void connectViaHttpsWithSSLFallbackFailuresRecorded() throws Exception {
+    server.useHttps(sslContext.getSocketFactory(), false);
+    server.enqueue(new MockResponse().setSocketPolicy(SocketPolicy.FAIL_HANDSHAKE));
+    server.enqueue(new MockResponse().setSocketPolicy(SocketPolicy.FAIL_HANDSHAKE));
+
+    suppressTlsFallbackScsv(client.client());
+    Internal.instance.setNetwork(client.client(), new SingleInetAddressNetwork());
+
+    client.client().setHostnameVerifier(new RecordingHostnameVerifier());
+    connection = client.open(server.getUrl("/foo"));
+
+    try {
+      connection.getResponseCode();
+      fail();
+    } catch (IOException expected) {
+      assertEquals(1, expected.getSuppressed().length);
+    }
   }
 
   /**
@@ -622,7 +627,7 @@ private void doUpload(TransferKind uploadKind, WriteKind writeKind) throws Excep
    * https://github.com/square/okhttp/issues/515
    */
   @Test public void sslFallbackNotUsedWhenRecycledConnectionFails() throws Exception {
-    server.get().useHttps(sslContext.getSocketFactory(), false);
+    server.useHttps(sslContext.getSocketFactory(), false);
     server.enqueue(new MockResponse()
         .setBody("abc")
         .setSocketPolicy(SocketPolicy.DISCONNECT_AT_END));
@@ -650,7 +655,7 @@ private void doUpload(TransferKind uploadKind, WriteKind writeKind) throws Excep
    * http://code.google.com/p/android/issues/detail?id=13178
    */
   @Test public void connectViaHttpsToUntrustedServer() throws IOException, InterruptedException {
-    server.get().useHttps(sslContext.getSocketFactory(), false);
+    server.useHttps(sslContext.getSocketFactory(), false);
     server.enqueue(new MockResponse()); // unused
 
     connection = client.open(server.getUrl("/foo"));
@@ -680,22 +685,33 @@ private void testConnectViaProxy(ProxyConfig proxyConfig) throws Exception {
     server.enqueue(mockResponse);
 
     URL url = new URL("http://android.com/foo");
-    connection = proxyConfig.connect(server.get(), client, url);
+    connection = proxyConfig.connect(server, client, url);
     assertContent("this response comes via a proxy", connection);
     assertTrue(connection.usingProxy());
 
-    RecordedRequest request = server.get().takeRequest();
+    RecordedRequest request = server.takeRequest();
     assertEquals("GET http://android.com/foo HTTP/1.1", request.getRequestLine());
     assertEquals("android.com", request.getHeader("Host"));
   }
 
-  @Test public void contentDisagreesWithContentLengthHeader() throws IOException {
+  @Test public void contentDisagreesWithContentLengthHeaderBodyTooLong() throws IOException {
     server.enqueue(new MockResponse().setBody("abc\r\nYOU SHOULD NOT SEE THIS")
         .clearHeaders()
         .addHeader("Content-Length: 3"));
     assertContent("abc", client.open(server.getUrl("/")));
   }
 
+  @Test public void contentDisagreesWithContentLengthHeaderBodyTooShort() throws IOException {
+    server.enqueue(new MockResponse().setBody("abc")
+        .setHeader("Content-Length", "5")
+        .setSocketPolicy(SocketPolicy.DISCONNECT_AT_END));
+    try {
+      readAscii(client.open(server.getUrl("/")).getInputStream(), 5);
+      fail();
+    } catch (ProtocolException expected) {
+    }
+  }
+
   public void testConnectViaSocketFactory(boolean useHttps) throws IOException {
     SocketFactory uselessSocketFactory = new SocketFactory() {
       public Socket createSocket() { throw new IllegalArgumentException("useless"); }
@@ -709,7 +725,7 @@ public Socket createSocket(String host, int port, InetAddress localHost, int loc
     };
 
     if (useHttps) {
-      server.get().useHttps(sslContext.getSocketFactory(), false);
+      server.useHttps(sslContext.getSocketFactory(), false);
       client.client().setSslSocketFactory(sslContext.getSocketFactory());
       client.client().setHostnameVerifier(new RecordingHostnameVerifier());
     }
@@ -737,7 +753,7 @@ public Socket createSocket(String host, int port, InetAddress localHost, int loc
     testConnectViaSocketFactory(true);
   }
 
-  @Test public void contentDisagreesWithChunkedHeader() throws IOException {
+  @Test public void contentDisagreesWithChunkedHeaderBodyTooLong() throws IOException {
     MockResponse mockResponse = new MockResponse();
     mockResponse.setChunkedBody("abc", 3);
     Buffer buffer = mockResponse.getBody();
@@ -751,6 +767,28 @@ public Socket createSocket(String host, int port, InetAddress localHost, int loc
     assertContent("abc", client.open(server.getUrl("/")));
   }
 
+  @Test public void contentDisagreesWithChunkedHeaderBodyTooShort() throws IOException {
+    MockResponse mockResponse = new MockResponse();
+    mockResponse.setChunkedBody("abcde", 5);
+
+    Buffer truncatedBody = new Buffer();
+    Buffer fullBody = mockResponse.getBody();
+    truncatedBody.write(fullBody, fullBody.indexOf((byte) 'e'));
+    mockResponse.setBody(truncatedBody);
+
+    mockResponse.clearHeaders();
+    mockResponse.addHeader("Transfer-encoding: chunked");
+    mockResponse.setSocketPolicy(SocketPolicy.DISCONNECT_AT_END);
+
+    server.enqueue(mockResponse);
+
+    try {
+      readAscii(client.open(server.getUrl("/")).getInputStream(), 5);
+      fail();
+    } catch (ProtocolException expected) {
+    }
+  }
+
   @Test public void connectViaHttpProxyToHttpsUsingProxyArgWithNoProxy() throws Exception {
     testConnectViaDirectProxyToHttps(ProxyConfig.NO_PROXY);
   }
@@ -761,13 +799,13 @@ public Socket createSocket(String host, int port, InetAddress localHost, int loc
   }
 
   private void testConnectViaDirectProxyToHttps(ProxyConfig proxyConfig) throws Exception {
-    server.get().useHttps(sslContext.getSocketFactory(), false);
+    server.useHttps(sslContext.getSocketFactory(), false);
     server.enqueue(new MockResponse().setBody("this response comes via HTTPS"));
 
     URL url = server.getUrl("/foo");
     client.client().setSslSocketFactory(sslContext.getSocketFactory());
     client.client().setHostnameVerifier(new RecordingHostnameVerifier());
-    connection = proxyConfig.connect(server.get(), client, url);
+    connection = proxyConfig.connect(server, client, url);
 
     assertContent("this response comes via HTTPS", connection);
 
@@ -798,7 +836,7 @@ private void testConnectViaDirectProxyToHttps(ProxyConfig proxyConfig) throws Ex
   private void testConnectViaHttpProxyToHttps(ProxyConfig proxyConfig) throws Exception {
     RecordingHostnameVerifier hostnameVerifier = new RecordingHostnameVerifier();
 
-    server.get().useHttps(sslContext.getSocketFactory(), true);
+    server.useHttps(sslContext.getSocketFactory(), true);
     server.enqueue(
         new MockResponse().setSocketPolicy(SocketPolicy.UPGRADE_TO_SSL_AT_END).clearHeaders());
     server.enqueue(new MockResponse().setBody("this response comes via a secure proxy"));
@@ -806,7 +844,7 @@ private void testConnectViaHttpProxyToHttps(ProxyConfig proxyConfig) throws Exce
     URL url = new URL("https://android.com/foo");
     client.client().setSslSocketFactory(sslContext.getSocketFactory());
     client.client().setHostnameVerifier(hostnameVerifier);
-    connection = proxyConfig.connect(server.get(), client, url);
+    connection = proxyConfig.connect(server, client, url);
 
     assertContent("this response comes via a secure proxy", connection);
 
@@ -825,7 +863,7 @@ private void testConnectViaHttpProxyToHttps(ProxyConfig proxyConfig) throws Exce
   @Test public void connectViaHttpProxyToHttpsUsingBadProxyAndHttpResponseCache() throws Exception {
     initResponseCache();
 
-    server.get().useHttps(sslContext.getSocketFactory(), true);
+    server.useHttps(sslContext.getSocketFactory(), true);
     // The inclusion of a body in the response to a CONNECT is key to reproducing b/6754912.
     MockResponse badProxyResponse = new MockResponse()
         .setSocketPolicy(SocketPolicy.UPGRADE_TO_SSL_AT_END)
@@ -839,7 +877,7 @@ private void testConnectViaHttpProxyToHttps(ProxyConfig proxyConfig) throws Exce
     client.client().setSslSocketFactory(sslContext.getSocketFactory());
     client.client().setConnectionSpecs(Util.immutableList(ConnectionSpec.MODERN_TLS));
     client.client().setHostnameVerifier(new RecordingHostnameVerifier());
-    client.client().setProxy(server.get().toProxyAddress());
+    client.client().setProxy(server.toProxyAddress());
 
     URL url = new URL("https://android.com/foo");
     connection = client.open(url);
@@ -860,12 +898,12 @@ private void initResponseCache() throws IOException {
       throws IOException, InterruptedException {
     RecordingHostnameVerifier hostnameVerifier = new RecordingHostnameVerifier();
 
-    server.get().useHttps(sslContext.getSocketFactory(), true);
+    server.useHttps(sslContext.getSocketFactory(), true);
     server.enqueue(
         new MockResponse().setSocketPolicy(SocketPolicy.UPGRADE_TO_SSL_AT_END).clearHeaders());
     server.enqueue(new MockResponse().setBody("encrypted response from the origin server"));
 
-    client.client().setProxy(server.get().toProxyAddress());
+    client.client().setProxy(server.toProxyAddress());
 
     URL url = new URL("https://android.com/foo");
     client.client().setSslSocketFactory(sslContext.getSocketFactory());
@@ -890,14 +928,14 @@ private void initResponseCache() throws IOException {
 
   @Test public void proxyAuthenticateOnConnect() throws Exception {
     Authenticator.setDefault(new RecordingAuthenticator());
-    server.get().useHttps(sslContext.getSocketFactory(), true);
+    server.useHttps(sslContext.getSocketFactory(), true);
     server.enqueue(new MockResponse().setResponseCode(407)
         .addHeader("Proxy-Authenticate: Basic realm=\"localhost\""));
     server.enqueue(
         new MockResponse().setSocketPolicy(SocketPolicy.UPGRADE_TO_SSL_AT_END).clearHeaders());
     server.enqueue(new MockResponse().setBody("A"));
 
-    client.client().setProxy(server.get().toProxyAddress());
+    client.client().setProxy(server.toProxyAddress());
 
     URL url = new URL("https://android.com/foo");
     client.client().setSslSocketFactory(sslContext.getSocketFactory());
@@ -922,12 +960,12 @@ private void initResponseCache() throws IOException {
   // Don't disconnect after building a tunnel with CONNECT
   // http://code.google.com/p/android/issues/detail?id=37221
   @Test public void proxyWithConnectionClose() throws IOException {
-    server.get().useHttps(sslContext.getSocketFactory(), true);
+    server.useHttps(sslContext.getSocketFactory(), true);
     server.enqueue(
         new MockResponse().setSocketPolicy(SocketPolicy.UPGRADE_TO_SSL_AT_END).clearHeaders());
     server.enqueue(new MockResponse().setBody("this response comes via a proxy"));
 
-    client.client().setProxy(server.get().toProxyAddress());
+    client.client().setProxy(server.toProxyAddress());
 
     URL url = new URL("https://android.com/foo");
     client.client().setSslSocketFactory(sslContext.getSocketFactory());
@@ -942,13 +980,13 @@ private void initResponseCache() throws IOException {
     SSLSocketFactory socketFactory = sslContext.getSocketFactory();
     RecordingHostnameVerifier hostnameVerifier = new RecordingHostnameVerifier();
 
-    server.get().useHttps(socketFactory, true);
+    server.useHttps(socketFactory, true);
     server.enqueue(
         new MockResponse().setSocketPolicy(SocketPolicy.UPGRADE_TO_SSL_AT_END).clearHeaders());
     server.enqueue(new MockResponse().setBody("response 1"));
     server.enqueue(new MockResponse().setBody("response 2"));
 
-    client.client().setProxy(server.get().toProxyAddress());
+    client.client().setProxy(server.toProxyAddress());
 
     URL url = new URL("https://android.com/foo");
     client.client().setSslSocketFactory(socketFactory);
@@ -1075,6 +1113,28 @@ private void testMarkAndReset(TransferKind transferKind) throws IOException {
     }
   }
 
+  @Test public void malformedChunkSize() throws IOException {
+    server.enqueue(new MockResponse().setBody("5:x\r\nABCDE\r\n0\r\n\r\n")
+        .clearHeaders()
+        .addHeader("Transfer-encoding: chunked"));
+
+    URLConnection connection = client.open(server.getUrl("/"));
+    try {
+      readAscii(connection.getInputStream(), Integer.MAX_VALUE);
+      fail();
+    } catch (IOException e) {
+    }
+  }
+
+  @Test public void extensionAfterChunkSize() throws IOException {
+    server.enqueue(new MockResponse().setBody("5;x\r\nABCDE\r\n0\r\n\r\n")
+        .clearHeaders()
+        .addHeader("Transfer-encoding: chunked"));
+
+    HttpURLConnection connection = client.open(server.getUrl("/"));
+    assertContent("ABCDE", connection);
+  }
+
   @Test public void missingChunkBody() throws IOException {
     server.enqueue(new MockResponse().setBody("5")
         .clearHeaders()
@@ -1162,7 +1222,7 @@ private void testClientConfiguredGzipContentEncodingAndConnectionReuse(TransferK
     if (tls) {
       SSLSocketFactory socketFactory = sslContext.getSocketFactory();
       RecordingHostnameVerifier hostnameVerifier = new RecordingHostnameVerifier();
-      server.get().useHttps(socketFactory, false);
+      server.useHttps(socketFactory, false);
       client.client().setSslSocketFactory(socketFactory);
       client.client().setHostnameVerifier(hostnameVerifier);
     }
@@ -1447,7 +1507,7 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
     server.enqueue(pleaseAuthenticate);
 
     if (proxy) {
-      client.client().setProxy(server.get().toProxyAddress());
+      client.client().setProxy(server.toProxyAddress());
       connection = client.open(new URL("http://android.com"));
     } else {
       connection = client.open(server.getUrl("/"));
@@ -1584,7 +1644,7 @@ private void assertInvalidRequestMethod(String requestMethod) throws Exception {
    * http://code.google.com/p/android/issues/detail?id=12860
    */
   private void testSecureStreamingPost(StreamingMode streamingMode) throws Exception {
-    server.get().useHttps(sslContext.getSocketFactory(), false);
+    server.useHttps(sslContext.getSocketFactory(), false);
     server.enqueue(new MockResponse().setBody("Success!"));
 
     client.client().setSslSocketFactory(sslContext.getSocketFactory());
@@ -1755,7 +1815,7 @@ private void testRedirected(TransferKind transferKind, boolean reuse) throws Exc
   }
 
   @Test public void redirectedOnHttps() throws IOException, InterruptedException {
-    server.get().useHttps(sslContext.getSocketFactory(), false);
+    server.useHttps(sslContext.getSocketFactory(), false);
     server.enqueue(new MockResponse().setResponseCode(HttpURLConnection.HTTP_MOVED_TEMP)
         .addHeader("Location: /foo")
         .setBody("This page has moved!"));
@@ -1775,7 +1835,7 @@ private void testRedirected(TransferKind transferKind, boolean reuse) throws Exc
   }
 
   @Test public void notRedirectedFromHttpsToHttp() throws IOException, InterruptedException {
-    server.get().useHttps(sslContext.getSocketFactory(), false);
+    server.useHttps(sslContext.getSocketFactory(), false);
     server.enqueue(new MockResponse().setResponseCode(HttpURLConnection.HTTP_MOVED_TEMP)
         .addHeader("Location: http://anyhost/foo")
         .setBody("This page has moved!"));
@@ -1800,7 +1860,7 @@ private void testRedirected(TransferKind transferKind, boolean reuse) throws Exc
   @Test public void redirectedFromHttpsToHttpFollowingProtocolRedirects() throws Exception {
     server2.enqueue(new MockResponse().setBody("This is insecure HTTP!"));
 
-    server.get().useHttps(sslContext.getSocketFactory(), false);
+    server.useHttps(sslContext.getSocketFactory(), false);
     server.enqueue(new MockResponse().setResponseCode(HttpURLConnection.HTTP_MOVED_TEMP)
         .addHeader("Location: " + server2.getUrl("/"))
         .setBody("This page has moved!"));
@@ -1818,7 +1878,7 @@ private void testRedirected(TransferKind transferKind, boolean reuse) throws Exc
   }
 
   @Test public void redirectedFromHttpToHttpsFollowingProtocolRedirects() throws Exception {
-    server2.get().useHttps(sslContext.getSocketFactory(), false);
+    server2.useHttps(sslContext.getSocketFactory(), false);
     server2.enqueue(new MockResponse().setBody("This is secure HTTPS!"));
 
     server.enqueue(new MockResponse().setResponseCode(HttpURLConnection.HTTP_MOVED_TEMP)
@@ -1843,9 +1903,9 @@ private void testRedirected(TransferKind transferKind, boolean reuse) throws Exc
 
   private void redirectToAnotherOriginServer(boolean https) throws Exception {
     if (https) {
-      server.get().useHttps(sslContext.getSocketFactory(), false);
-      server2.get().useHttps(sslContext.getSocketFactory(), false);
-      server2.get().setProtocolNegotiationEnabled(false);
+      server.useHttps(sslContext.getSocketFactory(), false);
+      server2.useHttps(sslContext.getSocketFactory(), false);
+      server2.setProtocolNegotiationEnabled(false);
       client.client().setSslSocketFactory(sslContext.getSocketFactory());
       client.client().setHostnameVerifier(new RecordingHostnameVerifier());
     }
@@ -1866,8 +1926,8 @@ private void redirectToAnotherOriginServer(boolean https) throws Exception {
     assertContent("This is the first server again!", client.open(server.getUrl("/")));
     assertContent("This is the 2nd server, again!", client.open(server2.getUrl("/")));
 
-    String server1Host = server.get().getHostName() + ":" + server.getPort();
-    String server2Host = server2.get().getHostName() + ":" + server2.getPort();
+    String server1Host = server.getHostName() + ":" + server.getPort();
+    String server2Host = server2.getHostName() + ":" + server2.getPort();
     assertEquals(server1Host, server.takeRequest().getHeader("Host"));
     assertEquals(server2Host, server2.takeRequest().getHeader("Host"));
     assertEquals("Expected connection reuse", 1, server.takeRequest().getSequenceNumber());
@@ -1879,9 +1939,9 @@ private void redirectToAnotherOriginServer(boolean https) throws Exception {
     client.client().setProxySelector(new ProxySelector() {
       @Override public List<Proxy> select(URI uri) {
         proxySelectionRequests.add(uri);
-        MockWebServer proxyServer = (uri.getPort() == server.get().getPort())
-            ? server.get()
-            : server2.get();
+        MockWebServer proxyServer = (uri.getPort() == server.getPort())
+            ? server
+            : server2;
         return Arrays.asList(proxyServer.toProxyAddress());
       }
 
@@ -2126,7 +2186,7 @@ private void testRedirect(boolean temporary, String method) throws Exception {
 
     client.client().setHostnameVerifier(hostnameVerifier);
     client.client().setSslSocketFactory(sc.getSocketFactory());
-    server.get().useHttps(sslContext.getSocketFactory(), false);
+    server.useHttps(sslContext.getSocketFactory(), false);
     server.enqueue(new MockResponse().setBody("ABC"));
     server.enqueue(new MockResponse().setBody("DEF"));
     server.enqueue(new MockResponse().setBody("GHI"));
@@ -2136,9 +2196,9 @@ private void testRedirect(boolean temporary, String method) throws Exception {
     assertContent("DEF", client.open(url));
     assertContent("GHI", client.open(url));
 
-    assertEquals(Arrays.asList("verify " + server.get().getHostName()),
+    assertEquals(Arrays.asList("verify " + server.getHostName()),
         hostnameVerifier.calls);
-    assertEquals(Arrays.asList("checkServerTrusted [CN=" + server.get().getHostName() + " 1]"),
+    assertEquals(Arrays.asList("checkServerTrusted [CN=" + server.getHostName() + " 1]"),
         trustManager.calls);
   }
 
@@ -2160,7 +2220,7 @@ private void testRedirect(boolean temporary, String method) throws Exception {
     try {
       in.read(); // if Content-Length was accurate, this would return -1 immediately
       fail();
-    } catch (IOException expected) {
+    } catch (SocketTimeoutException expected) {
     }
   }
 
@@ -2169,18 +2229,21 @@ private void testRedirect(boolean temporary, String method) throws Exception {
     // Sockets on some platforms can have large buffers that mean writes do not block when
     // required. These socket factories explicitly set the buffer sizes on sockets created.
     final int SOCKET_BUFFER_SIZE = 256 * 1024;
-    server.get().setServerSocketFactory(
+    server.setServerSocketFactory(
         new DelegatingServerSocketFactory(ServerSocketFactory.getDefault()) {
           @Override
-          protected void configureServerSocket(ServerSocket serverSocket) throws IOException {
+          protected ServerSocket configureServerSocket(ServerSocket serverSocket)
+              throws IOException {
             serverSocket.setReceiveBufferSize(SOCKET_BUFFER_SIZE);
+            return serverSocket;
           }
         });
     client.client().setSocketFactory(new DelegatingSocketFactory(SocketFactory.getDefault()) {
       @Override
-      protected void configureSocket(Socket socket) throws IOException {
+      protected Socket configureSocket(Socket socket) throws IOException {
         socket.setReceiveBufferSize(SOCKET_BUFFER_SIZE);
         socket.setSendBufferSize(SOCKET_BUFFER_SIZE);
+        return socket;
       }
     });
 
@@ -2196,7 +2259,7 @@ protected void configureSocket(Socket socket) throws IOException {
       byte[] data = new byte[16 * 1024 * 1024]; // 16 MiB.
       out.write(data);
       fail();
-    } catch (IOException expected) {
+    } catch (SocketTimeoutException expected) {
     }
   }
 
@@ -2376,11 +2439,11 @@ private void testFlushAfterStreamTransmitted(TransferKind transferKind) throws I
     server.enqueue(new MockResponse().setBody("ABC"));
 
     // The request should work once and then fail
-    HttpURLConnection connection1 = client.open(server.getUrl(""));
+    HttpURLConnection connection1 = client.open(server.getUrl("/"));
     connection1.setReadTimeout(100);
     InputStream input = connection1.getInputStream();
     assertEquals("ABC", readAscii(input, Integer.MAX_VALUE));
-    server.get().shutdown();
+    server.shutdown();
     try {
       HttpURLConnection connection2 = client.open(server.getUrl(""));
       connection2.setReadTimeout(100);
@@ -2424,7 +2487,7 @@ private void testFlushAfterStreamTransmitted(TransferKind transferKind) throws I
       fail();
     } catch (NullPointerException expected) {
     }
-    assertNull(connection.getContent(new Class[]{getClass()}));
+    assertNull(connection.getContent(new Class[] { getClass() }));
   }
 
   @Test public void getOutputStreamOnGetFails() throws Exception {
@@ -2499,7 +2562,7 @@ private void testFlushAfterStreamTransmitted(TransferKind transferKind) throws I
   @Test public void urlContainsQueryButNoPath() throws Exception {
     server.enqueue(new MockResponse().setBody("A"));
 
-    URL url = new URL("http", server.get().getHostName(), server.getPort(), "?query");
+    URL url = new URL("http", server.getHostName(), server.getPort(), "?query");
     assertEquals("A", readAscii(client.open(url).getInputStream(), Integer.MAX_VALUE));
     RecordedRequest request = server.takeRequest();
     assertEquals("GET /?query HTTP/1.1", request.getRequestLine());
@@ -2548,7 +2611,6 @@ private void testInputStreamAvailable(TransferKind transferKind) throws IOExcept
     reusedConnectionFailsWithPost(TransferKind.END_OF_STREAM, 1024);
   }
 
-  // This test is ignored because we don't (yet) reliably recover for large request bodies.
   @Test public void postFailsWithBufferedRequestForLargeRequest() throws Exception {
     reusedConnectionFailsWithPost(TransferKind.END_OF_STREAM, 16384);
   }
@@ -2581,14 +2643,24 @@ private void reusedConnectionFailsWithPost(TransferKind transferKind, int reques
     byte[] requestBody = new byte[requestSize];
     new Random(0).nextBytes(requestBody);
 
-    connection = client.open(server.getUrl("/b"));
-    connection.setRequestMethod("POST");
-    transferKind.setForRequest(connection, requestBody.length);
-    for (int i = 0; i < requestBody.length; i += 1024) {
-      connection.getOutputStream().write(requestBody, i, 1024);
+    for (int j = 0; j < 2; j++) {
+      try {
+        connection = client.open(server.getUrl("/b"));
+        connection.setRequestMethod("POST");
+        transferKind.setForRequest(connection, requestBody.length);
+        for (int i = 0; i < requestBody.length; i += 1024) {
+          connection.getOutputStream().write(requestBody, i, 1024);
+        }
+        connection.getOutputStream().close();
+        assertContent("B", connection);
+        break;
+      } catch (IOException socketException) {
+        // If there's a socket exception, this must have a streamed request body.
+        assertEquals(0, j);
+        assertTrue(transferKind == TransferKind.CHUNKED
+            || transferKind == TransferKind.FIXED_LENGTH);
+      }
     }
-    connection.getOutputStream().close();
-    assertContent("B", connection);
 
     RecordedRequest requestA = server.takeRequest();
     assertEquals("/a", requestA.getPath());
@@ -2715,6 +2787,51 @@ private void reusedConnectionFailsWithPost(TransferKind transferKind, int reques
     assertEquals("A", connection.getHeaderField(""));
   }
 
+  @Test public void requestHeaderValidationIsStrict() throws Exception {
+    connection = client.open(server.getUrl("/"));
+    try {
+      connection.addRequestProperty("a\tb", "Value");
+      fail();
+    } catch (IllegalArgumentException expected) {
+    }
+    try {
+      connection.addRequestProperty("Name", "c\u007fd");
+      fail();
+    } catch (IllegalArgumentException expected) {
+    }
+    try {
+      connection.addRequestProperty("", "Value");
+      fail();
+    } catch (IllegalArgumentException expected) {
+    }
+    try {
+      connection.addRequestProperty("\ud83c\udf69", "Value");
+      fail();
+    } catch (IllegalArgumentException expected) {
+    }
+    try {
+      connection.addRequestProperty("Name", "\u2615\ufe0f");
+      fail();
+    } catch (IllegalArgumentException expected) {
+    }
+  }
+
+  @Test public void responseHeaderParsingIsLenient() throws Exception {
+    Headers headers = new Headers.Builder()
+        .add("Content-Length", "0")
+        .addLenient("a\tb: c\u007fd")
+        .addLenient(": ef")
+        .addLenient("\ud83c\udf69: \u2615\ufe0f")
+        .build();
+    server.enqueue(new MockResponse().setHeaders(headers));
+
+    connection = client.open(server.getUrl("/"));
+    connection.getResponseCode();
+    assertEquals("c\u007fd", connection.getHeaderField("a\tb"));
+    assertEquals("\u2615\ufe0f", connection.getHeaderField("\ud83c\udf69"));
+    assertEquals("ef", connection.getHeaderField(""));
+  }
+
   @Test @Ignore public void deflateCompression() {
     fail("TODO");
   }
@@ -2933,7 +3050,7 @@ private void zeroLengthPayload(String method)
   }
 
   @Test public void veryLargeFixedLengthRequest() throws Exception {
-    server.get().setBodyLimit(0);
+    server.setBodyLimit(0);
     server.enqueue(new MockResponse());
 
     connection = client.open(server.getUrl("/"));
@@ -3031,13 +3148,24 @@ private void zeroLengthPayload(String method)
     assertEquals("foo", request.getHeader("User-Agent"));
   }
 
-  @Test public void userAgentDefaultsToJavaVersion() throws Exception {
+  /** https://github.com/square/okhttp/issues/891 */
+  @Test public void userAgentSystemPropertyIsNotAscii() throws Exception {
     server.enqueue(new MockResponse().setBody("abc"));
 
+    System.setProperty("http.agent", "a\nb\ud83c\udf69c\ud83c\udf68d\u007fe");
     assertContent("abc", client.open(server.getUrl("/")));
 
     RecordedRequest request = server.takeRequest();
-    assertTrue(request.getHeader("User-Agent").startsWith("Java"));
+    assertEquals("a?b?c?d?e", request.getHeader("User-Agent"));
+  }
+
+  @Test public void userAgentDefaultsToOkHttpVersion() throws Exception {
+    server.enqueue(new MockResponse().setBody("abc"));
+
+    assertContent("abc", client.open(server.getUrl("/")));
+
+    RecordedRequest request = server.takeRequest();
+    assertEquals(Version.userAgent(), request.getHeader("User-Agent"));
   }
 
   @Test public void interceptorsNotInvoked() throws Exception {
@@ -3053,6 +3181,37 @@ private void zeroLengthPayload(String method)
     assertContent("abc", client.open(server.getUrl("/")));
   }
 
+  @Test public void urlWithSpaceInHost() throws Exception {
+    URLConnection urlConnection = client.open(new URL("http://and roid.com/"));
+    try {
+      urlConnection.getInputStream();
+      fail();
+    } catch (UnknownHostException expected) {
+    }
+  }
+
+  @Test public void urlWithSpaceInHostViaHttpProxy() throws Exception {
+    server.enqueue(new MockResponse());
+    URLConnection urlConnection =
+        client.open(new URL("http://and roid.com/"), server.toProxyAddress());
+
+    try {
+      // This test is to check that a NullPointerException is not thrown.
+      urlConnection.getInputStream();
+      fail(); // the RI makes a bogus proxy request for "GET http://and roid.com/ HTTP/1.1"
+    } catch (UnknownHostException expected) {
+    }
+  }
+
+  @Test public void urlHostWithNul() throws Exception {
+    URLConnection urlConnection = client.open(new URL("http://host\u0000/"));
+    try {
+      urlConnection.getInputStream();
+      fail();
+    } catch (UnknownHostException expected) {
+    }
+  }
+
   /** Returns a gzipped copy of {@code bytes}. */
   public Buffer gzip(String data) throws IOException {
     Buffer result = new Buffer();
@@ -3077,7 +3236,7 @@ private void assertContent(String expected, HttpURLConnection connection) throws
   }
 
   private Set<String> newSet(String... elements) {
-    return new HashSet<String>(Arrays.asList(elements));
+    return new LinkedHashSet<>(Arrays.asList(elements));
   }
 
   enum TransferKind {
@@ -3218,9 +3377,9 @@ private void enableProtocol(Protocol protocol) {
     client.client().setSslSocketFactory(sslContext.getSocketFactory());
     client.client().setHostnameVerifier(new RecordingHostnameVerifier());
     client.client().setProtocols(Arrays.asList(protocol, Protocol.HTTP_1_1));
-    server.get().useHttps(sslContext.getSocketFactory(), false);
-    server.get().setProtocolNegotiationEnabled(true);
-    server.get().setProtocols(client.client().getProtocols());
+    server.useHttps(sslContext.getSocketFactory(), false);
+    server.setProtocolNegotiationEnabled(true);
+    server.setProtocols(client.client().getProtocols());
   }
 
   /**
@@ -3228,7 +3387,7 @@ private void enableProtocol(Protocol protocol) {
    * TLS_FALLBACK_SCSV cipher on fallback connections. See
    * {@link com.squareup.okhttp.FallbackTestClientSocketFactory} for details.
    */
-  private static void suppressTlsFallbackScsv(OkHttpClient client) {
+  private void suppressTlsFallbackScsv(OkHttpClient client) {
     FallbackTestClientSocketFactory clientSocketFactory =
         new FallbackTestClientSocketFactory(sslContext.getSocketFactory());
     client.setSslSocketFactory(clientSocketFactory);
diff --git a/okhttp-tests/src/test/java/com/squareup/okhttp/UrlComponentEncodingTester.java b/okhttp-tests/src/test/java/com/squareup/okhttp/UrlComponentEncodingTester.java
new file mode 100644
index 0000000000..199279f7c0
--- /dev/null
+++ b/okhttp-tests/src/test/java/com/squareup/okhttp/UrlComponentEncodingTester.java
@@ -0,0 +1,391 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.okhttp;
+
+import java.net.URI;
+import java.net.URL;
+import java.util.Collections;
+import java.util.LinkedHashMap;
+import java.util.Map;
+import okio.Buffer;
+import okio.ByteString;
+
+import static org.junit.Assert.fail;
+
+/** Tests how each code point is encoded and decoded in the context of each URL component. */
+class UrlComponentEncodingTester {
+  /**
+   * The default encode set for the ASCII range. The specific rules vary per-component: for example,
+   * '?' may be identity-encoded in a fragment, but must be percent-encoded in a path.
+   *
+   * See https://url.spec.whatwg.org/#percent-encoded-bytes
+   */
+  private static final Map<Integer, Encoding> defaultEncodings;
+  static {
+    Map<Integer, Encoding> map = new LinkedHashMap<>();
+    map.put(       0x0, Encoding.PERCENT); // Null character
+    map.put(       0x1, Encoding.PERCENT); // Start of Header
+    map.put(       0x2, Encoding.PERCENT); // Start of Text
+    map.put(       0x3, Encoding.PERCENT); // End of Text
+    map.put(       0x4, Encoding.PERCENT); // End of Transmission
+    map.put(       0x5, Encoding.PERCENT); // Enquiry
+    map.put(       0x6, Encoding.PERCENT); // Acknowledgment
+    map.put(       0x7, Encoding.PERCENT); // Bell
+    map.put((int) '\b', Encoding.PERCENT); // Backspace
+    map.put((int) '\t', Encoding.SKIP);    // Horizontal Tab
+    map.put((int) '\n', Encoding.SKIP);    // Line feed
+    map.put(       0xb, Encoding.PERCENT); // Vertical Tab
+    map.put((int) '\f', Encoding.SKIP);    // Form feed
+    map.put((int) '\r', Encoding.SKIP);    // Carriage return
+    map.put(       0xe, Encoding.PERCENT); // Shift Out
+    map.put(       0xf, Encoding.PERCENT); // Shift In
+    map.put(      0x10, Encoding.PERCENT); // Data Link Escape
+    map.put(      0x11, Encoding.PERCENT); // Device Control 1 (oft. XON)
+    map.put(      0x12, Encoding.PERCENT); // Device Control 2
+    map.put(      0x13, Encoding.PERCENT); // Device Control 3 (oft. XOFF)
+    map.put(      0x14, Encoding.PERCENT); // Device Control 4
+    map.put(      0x15, Encoding.PERCENT); // Negative Acknowledgment
+    map.put(      0x16, Encoding.PERCENT); // Synchronous idle
+    map.put(      0x17, Encoding.PERCENT); // End of Transmission Block
+    map.put(      0x18, Encoding.PERCENT); // Cancel
+    map.put(      0x19, Encoding.PERCENT); // End of Medium
+    map.put(      0x1a, Encoding.PERCENT); // Substitute
+    map.put(      0x1b, Encoding.PERCENT); // Escape
+    map.put(      0x1c, Encoding.PERCENT); // File Separator
+    map.put(      0x1d, Encoding.PERCENT); // Group Separator
+    map.put(      0x1e, Encoding.PERCENT); // Record Separator
+    map.put(      0x1f, Encoding.PERCENT); // Unit Separator
+    map.put((int)  ' ', Encoding.PERCENT);
+    map.put((int)  '!', Encoding.IDENTITY);
+    map.put((int)  '"', Encoding.PERCENT);
+    map.put((int)  '#', Encoding.PERCENT);
+    map.put((int)  '$', Encoding.IDENTITY);
+    map.put((int)  '%', Encoding.IDENTITY);
+    map.put((int)  '&', Encoding.IDENTITY);
+    map.put((int) '\'', Encoding.IDENTITY);
+    map.put((int)  '(', Encoding.IDENTITY);
+    map.put((int)  ')', Encoding.IDENTITY);
+    map.put((int)  '*', Encoding.IDENTITY);
+    map.put((int)  '+', Encoding.IDENTITY);
+    map.put((int)  ',', Encoding.IDENTITY);
+    map.put((int)  '-', Encoding.IDENTITY);
+    map.put((int)  '.', Encoding.IDENTITY);
+    map.put((int)  '/', Encoding.IDENTITY);
+    map.put((int)  '0', Encoding.IDENTITY);
+    map.put((int)  '1', Encoding.IDENTITY);
+    map.put((int)  '2', Encoding.IDENTITY);
+    map.put((int)  '3', Encoding.IDENTITY);
+    map.put((int)  '4', Encoding.IDENTITY);
+    map.put((int)  '5', Encoding.IDENTITY);
+    map.put((int)  '6', Encoding.IDENTITY);
+    map.put((int)  '7', Encoding.IDENTITY);
+    map.put((int)  '8', Encoding.IDENTITY);
+    map.put((int)  '9', Encoding.IDENTITY);
+    map.put((int)  ':', Encoding.IDENTITY);
+    map.put((int)  ';', Encoding.IDENTITY);
+    map.put((int)  '<', Encoding.PERCENT);
+    map.put((int)  '=', Encoding.IDENTITY);
+    map.put((int)  '>', Encoding.PERCENT);
+    map.put((int)  '?', Encoding.PERCENT);
+    map.put((int)  '@', Encoding.IDENTITY);
+    map.put((int)  'A', Encoding.IDENTITY);
+    map.put((int)  'B', Encoding.IDENTITY);
+    map.put((int)  'C', Encoding.IDENTITY);
+    map.put((int)  'D', Encoding.IDENTITY);
+    map.put((int)  'E', Encoding.IDENTITY);
+    map.put((int)  'F', Encoding.IDENTITY);
+    map.put((int)  'G', Encoding.IDENTITY);
+    map.put((int)  'H', Encoding.IDENTITY);
+    map.put((int)  'I', Encoding.IDENTITY);
+    map.put((int)  'J', Encoding.IDENTITY);
+    map.put((int)  'K', Encoding.IDENTITY);
+    map.put((int)  'L', Encoding.IDENTITY);
+    map.put((int)  'M', Encoding.IDENTITY);
+    map.put((int)  'N', Encoding.IDENTITY);
+    map.put((int)  'O', Encoding.IDENTITY);
+    map.put((int)  'P', Encoding.IDENTITY);
+    map.put((int)  'Q', Encoding.IDENTITY);
+    map.put((int)  'R', Encoding.IDENTITY);
+    map.put((int)  'S', Encoding.IDENTITY);
+    map.put((int)  'T', Encoding.IDENTITY);
+    map.put((int)  'U', Encoding.IDENTITY);
+    map.put((int)  'V', Encoding.IDENTITY);
+    map.put((int)  'W', Encoding.IDENTITY);
+    map.put((int)  'X', Encoding.IDENTITY);
+    map.put((int)  'Y', Encoding.IDENTITY);
+    map.put((int)  'Z', Encoding.IDENTITY);
+    map.put((int)  '[', Encoding.IDENTITY);
+    map.put((int) '\\', Encoding.IDENTITY);
+    map.put((int)  ']', Encoding.IDENTITY);
+    map.put((int)  '^', Encoding.IDENTITY);
+    map.put((int)  '_', Encoding.IDENTITY);
+    map.put((int)  '`', Encoding.PERCENT);
+    map.put((int)  'a', Encoding.IDENTITY);
+    map.put((int)  'b', Encoding.IDENTITY);
+    map.put((int)  'c', Encoding.IDENTITY);
+    map.put((int)  'd', Encoding.IDENTITY);
+    map.put((int)  'e', Encoding.IDENTITY);
+    map.put((int)  'f', Encoding.IDENTITY);
+    map.put((int)  'g', Encoding.IDENTITY);
+    map.put((int)  'h', Encoding.IDENTITY);
+    map.put((int)  'i', Encoding.IDENTITY);
+    map.put((int)  'j', Encoding.IDENTITY);
+    map.put((int)  'k', Encoding.IDENTITY);
+    map.put((int)  'l', Encoding.IDENTITY);
+    map.put((int)  'm', Encoding.IDENTITY);
+    map.put((int)  'n', Encoding.IDENTITY);
+    map.put((int)  'o', Encoding.IDENTITY);
+    map.put((int)  'p', Encoding.IDENTITY);
+    map.put((int)  'q', Encoding.IDENTITY);
+    map.put((int)  'r', Encoding.IDENTITY);
+    map.put((int)  's', Encoding.IDENTITY);
+    map.put((int)  't', Encoding.IDENTITY);
+    map.put((int)  'u', Encoding.IDENTITY);
+    map.put((int)  'v', Encoding.IDENTITY);
+    map.put((int)  'w', Encoding.IDENTITY);
+    map.put((int)  'x', Encoding.IDENTITY);
+    map.put((int)  'y', Encoding.IDENTITY);
+    map.put((int)  'z', Encoding.IDENTITY);
+    map.put((int)  '{', Encoding.IDENTITY);
+    map.put((int)  '|', Encoding.IDENTITY);
+    map.put((int)  '}', Encoding.IDENTITY);
+    map.put((int)  '~', Encoding.IDENTITY);
+    map.put(      0x7f, Encoding.PERCENT); // Delete
+    defaultEncodings = Collections.unmodifiableMap(map);
+  }
+
+  private final Map<Integer, Encoding> encodings;
+  private final StringBuilder skipForUri = new StringBuilder();
+
+  public UrlComponentEncodingTester() {
+    this.encodings = new LinkedHashMap<>(defaultEncodings);
+  }
+
+  public UrlComponentEncodingTester override(Encoding encoding, int... codePoints) {
+    for (int codePoint : codePoints) {
+      encodings.put(codePoint, encoding);
+    }
+    return this;
+  }
+
+  /**
+   * Configure a character to be skipped but only for conversion to and from {@code java.net.URI}.
+   * That class is more strict than the others.
+   */
+  public UrlComponentEncodingTester skipForUri(int... codePoints) {
+    skipForUri.append(new String(codePoints, 0, codePoints.length));
+    return this;
+  }
+
+  public UrlComponentEncodingTester test(Component component) {
+    for (Map.Entry<Integer, Encoding> entry : encodings.entrySet()) {
+      Encoding encoding = entry.getValue();
+      int codePoint = entry.getKey();
+      testEncodeAndDecode(codePoint, component);
+      if (encoding == Encoding.SKIP) continue;
+
+      testParseOriginal(codePoint, encoding, component);
+      testParseAlreadyEncoded(codePoint, encoding, component);
+      testToUrl(codePoint, encoding, component);
+      testFromUrl(codePoint, encoding, component);
+
+      if (skipForUri.indexOf(Encoding.IDENTITY.encode(codePoint)) == -1) {
+        testToUri(codePoint, encoding, component);
+        testFromUri(codePoint, encoding, component);
+      }
+    }
+    return this;
+  }
+
+  private void testParseAlreadyEncoded(int codePoint, Encoding encoding, Component component) {
+    String encoded = encoding.encode(codePoint);
+    String urlString = component.urlString(encoded);
+    HttpUrl url = HttpUrl.parse(urlString);
+    if (!component.encodedValue(url).equals(encoded)) {
+      fail(String.format("Encoding %s %#x using %s", component, codePoint, encoding));
+    }
+  }
+
+  private void testEncodeAndDecode(int codePoint, Component component) {
+    String expected = Encoding.IDENTITY.encode(codePoint);
+    HttpUrl.Builder builder = HttpUrl.parse("http://host/").newBuilder();
+    component.set(builder, expected);
+    HttpUrl url = builder.build();
+    String actual = component.get(url);
+    if (!expected.equals(actual)) {
+      fail(String.format("Roundtrip %s %#x %s", component, codePoint, url));
+    }
+  }
+
+  private void testParseOriginal(int codePoint, Encoding encoding, Component component) {
+    String encoded = encoding.encode(codePoint);
+    if (encoding != Encoding.PERCENT) return;
+    String identity = Encoding.IDENTITY.encode(codePoint);
+    String urlString = component.urlString(identity);
+    HttpUrl url = HttpUrl.parse(urlString);
+
+    String s = component.encodedValue(url);
+    if (!s.equals(encoded)) {
+      fail(String.format("Encoding %s %#02x using %s", component, codePoint, encoding));
+    }
+  }
+
+  private void testToUrl(int codePoint, Encoding encoding, Component component) {
+    String encoded = encoding.encode(codePoint);
+    HttpUrl httpUrl = HttpUrl.parse(component.urlString(encoded));
+    URL javaNetUrl = httpUrl.url();
+    if (!javaNetUrl.toString().equals(javaNetUrl.toString())) {
+      fail(String.format("Encoding %s %#x using %s", component, codePoint, encoding));
+    }
+  }
+
+  private void testFromUrl(int codePoint, Encoding encoding, Component component) {
+    String encoded = encoding.encode(codePoint);
+    HttpUrl httpUrl = HttpUrl.parse(component.urlString(encoded));
+    HttpUrl toAndFromJavaNetUrl = HttpUrl.get(httpUrl.url());
+    if (!toAndFromJavaNetUrl.equals(httpUrl)) {
+      fail(String.format("Encoding %s %#x using %s", component, codePoint, encoding));
+    }
+  }
+
+  private void testToUri(int codePoint, Encoding encoding, Component component) {
+    String encoded = encoding.encode(codePoint);
+    HttpUrl httpUrl = HttpUrl.parse(component.urlString(encoded));
+    URI uri = httpUrl.uri();
+    if (!uri.toString().equals(uri.toString())) {
+      fail(String.format("Encoding %s %#x using %s", component, codePoint, encoding));
+    }
+  }
+
+  private void testFromUri(int codePoint, Encoding encoding, Component component) {
+    String encoded = encoding.encode(codePoint);
+    HttpUrl httpUrl = HttpUrl.parse(component.urlString(encoded));
+    HttpUrl toAndFromUri = HttpUrl.get(httpUrl.uri());
+    if (!toAndFromUri.equals(httpUrl)) {
+      fail(String.format("Encoding %s %#x using %s", component, codePoint, encoding));
+    }
+  }
+
+  public enum Encoding {
+    IDENTITY {
+      public String encode(int codePoint) {
+        return new String(new int[] { codePoint }, 0, 1);
+      }
+    },
+
+    PERCENT {
+      public String encode(int codePoint) {
+        ByteString utf8 = ByteString.encodeUtf8(IDENTITY.encode(codePoint));
+        Buffer percentEncoded = new Buffer();
+        for (int i = 0; i < utf8.size(); i++) {
+          percentEncoded.writeUtf8(String.format("%%%02X", utf8.getByte(i) & 0xff));
+        }
+        return percentEncoded.readUtf8();
+      }
+    },
+
+    SKIP;
+
+    public String encode(int codePoint) {
+      throw new UnsupportedOperationException();
+    }
+  }
+
+  public enum Component {
+    USER {
+      @Override public String urlString(String value) {
+        return "http://" + value + "@example.com/";
+      }
+      @Override public String encodedValue(HttpUrl url) {
+        return url.encodedUsername();
+      }
+      @Override public void set(HttpUrl.Builder builder, String value) {
+        builder.username(value);
+      }
+      @Override public String get(HttpUrl url) {
+        return url.username();
+      }
+    },
+    PASSWORD {
+      @Override public String urlString(String value) {
+        return "http://:" + value + "@example.com/";
+      }
+      @Override public String encodedValue(HttpUrl url) {
+        return url.encodedPassword();
+      }
+      @Override public void set(HttpUrl.Builder builder, String value) {
+        builder.password(value);
+      }
+      @Override public String get(HttpUrl url) {
+        return url.password();
+      }
+    },
+    PATH {
+      @Override public String urlString(String value) {
+        return "http://example.com/a" + value + "z/";
+      }
+      @Override public String encodedValue(HttpUrl url) {
+        String path = url.encodedPath();
+        return path.substring(2, path.length() - 2);
+      }
+      @Override public void set(HttpUrl.Builder builder, String value) {
+        builder.addPathSegment("a" + value + "z");
+      }
+      @Override public String get(HttpUrl url) {
+        String pathSegment = url.pathSegments().get(0);
+        return pathSegment.substring(1, pathSegment.length() - 1);
+      }
+    },
+    QUERY {
+      @Override public String urlString(String value) {
+        return "http://example.com/?a" + value + "z";
+      }
+      @Override public String encodedValue(HttpUrl url) {
+        String query = url.encodedQuery();
+        return query.substring(1, query.length() - 1);
+      }
+      @Override public void set(HttpUrl.Builder builder, String value) {
+        builder.query(value);
+      }
+      @Override public String get(HttpUrl url) {
+        return url.query();
+      }
+    },
+    FRAGMENT {
+      @Override public String urlString(String value) {
+        return "http://example.com/#a" + value + "z";
+      }
+      @Override public String encodedValue(HttpUrl url) {
+        String fragment = url.encodedFragment();
+        return fragment.substring(1, fragment.length() - 1);
+      }
+      @Override public void set(HttpUrl.Builder builder, String value) {
+        builder.fragment(value);
+      }
+      @Override public String get(HttpUrl url) {
+        return url.fragment();
+      }
+    };
+
+    public abstract String urlString(String value);
+
+    public abstract String encodedValue(HttpUrl url);
+
+    public abstract void set(HttpUrl.Builder builder, String value);
+
+    public abstract String get(HttpUrl url);
+  }
+}
diff --git a/okhttp-tests/src/test/java/com/squareup/okhttp/WebPlatformUrlTest.java b/okhttp-tests/src/test/java/com/squareup/okhttp/WebPlatformUrlTest.java
new file mode 100644
index 0000000000..e45761ce58
--- /dev/null
+++ b/okhttp-tests/src/test/java/com/squareup/okhttp/WebPlatformUrlTest.java
@@ -0,0 +1,133 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.okhttp;
+
+import com.squareup.okhttp.internal.Util;
+import java.io.IOException;
+import java.util.ArrayList;
+import java.util.List;
+import okio.BufferedSource;
+import okio.Okio;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.Parameterized;
+import org.junit.runners.Parameterized.Parameter;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertNotNull;
+import static org.junit.Assert.assertNull;
+
+/** Runs the web platform URL tests against Java URL models. */
+@RunWith(Parameterized.class)
+public final class WebPlatformUrlTest {
+  @Parameterized.Parameters(name = "{0}")
+  public static List<Object[]> parameters() {
+    try {
+      List<Object[]> result = new ArrayList<>();
+      for (WebPlatformUrlTestData urlTestData : loadTests()) {
+        result.add(new Object[] { urlTestData });
+      }
+      return result;
+    } catch (IOException e) {
+      throw new AssertionError();
+    }
+  }
+
+  @Parameter(0)
+  public WebPlatformUrlTestData testData;
+
+  private static final List<String> HTTP_URL_SCHEMES
+      = Util.immutableList("http", "https");
+  private static final List<String> KNOWN_FAILURES = Util.immutableList(
+      "Parsing: <http://example\t.\norg> against <http://example.org/foo/bar>",
+      "Parsing: <http://f:0/c> against <http://example.org/foo/bar>",
+      "Parsing: <http://f:00000000000000/c> against <http://example.org/foo/bar>",
+      "Parsing: <http://f:\n/c> against <http://example.org/foo/bar>",
+      "Parsing: <http://f:999999/c> against <http://example.org/foo/bar>",
+      "Parsing: <#β> against <http://example.org/foo/bar>",
+      "Parsing: <http://www.google.com/foo?bar=baz# »> against <about:blank>",
+      "Parsing: <http://192.0x00A80001> against <about:blank>",
+      // This test fails on Java 7 but passes on Java 8. See HttpUrlTest.hostWithTrailingDot().
+      "Parsing: <http://%30%78%63%30%2e%30%32%35%30.01%2e> against <http://other.com/>",
+      "Parsing: <http://%30%78%63%30%2e%30%32%35%30.01> against <http://other.com/>",
+      "Parsing: <http://192.168.0.257> against <http://other.com/>",
+      "Parsing: <http://０Ｘｃ０．０２５０．０１> against <http://other.com/>"
+  );
+
+  /** Test how {@link HttpUrl} does against the web platform test suite. */
+  @Test public void httpUrl() throws Exception {
+    if (!testData.scheme.isEmpty() && !HTTP_URL_SCHEMES.contains(testData.scheme)) {
+      System.err.println("Ignoring unsupported scheme " + testData.scheme);
+      return;
+    }
+    if (!testData.base.startsWith("https:")
+        && !testData.base.startsWith("http:")
+        && !testData.base.equals("about:blank")) {
+      System.err.println("Ignoring unsupported base " + testData.base);
+      return;
+    }
+
+    try {
+      testHttpUrl();
+      if (KNOWN_FAILURES.contains(testData.toString())) {
+        System.err.println("Expected failure but was success: " + testData);
+      }
+    } catch (Throwable e) {
+      if (KNOWN_FAILURES.contains(testData.toString())) {
+        System.err.println("Ignoring known failure: " + testData);
+        e.printStackTrace();
+      } else {
+        throw e;
+      }
+    }
+  }
+
+  private void testHttpUrl() {
+    HttpUrl url;
+    if (testData.base.equals("about:blank")) {
+      url = HttpUrl.parse(testData.input);
+    } else {
+      HttpUrl baseUrl = HttpUrl.parse(testData.base);
+      url = baseUrl.resolve(testData.input);
+    }
+
+    if (testData.expectParseFailure()) {
+      assertNull("Expected URL to fail parsing", url);
+    } else {
+      assertNotNull("Expected URL to parse successfully, but was null", url);
+      String effectivePort = url.port() != HttpUrl.defaultPort(url.scheme())
+          ? Integer.toString(url.port())
+          : "";
+      String effectiveQuery = url.encodedQuery() != null ? "?" + url.encodedQuery() : "";
+      String effectiveFragment = url.encodedFragment() != null ? "#" + url.encodedFragment() : "";
+      String effectiveHost = url.host().contains(":")
+          ? ("[" + url.host() + "]")
+          : url.host();
+      assertEquals("scheme", testData.scheme, url.scheme());
+      assertEquals("host", testData.host, effectiveHost);
+      assertEquals("port", testData.port, effectivePort);
+      assertEquals("path", testData.path, url.encodedPath());
+      assertEquals("query", testData.query, effectiveQuery);
+      assertEquals("fragment", testData.fragment, effectiveFragment);
+    }
+  }
+
+  private static List<WebPlatformUrlTestData> loadTests() throws IOException {
+    BufferedSource source = Okio.buffer(Okio.source(
+        WebPlatformUrlTest.class.getResourceAsStream("/web-platform-test-urltestdata.txt")));
+    return WebPlatformUrlTestData.load(source);
+  }
+}
diff --git a/okhttp-tests/src/test/java/com/squareup/okhttp/WebPlatformUrlTestData.java b/okhttp-tests/src/test/java/com/squareup/okhttp/WebPlatformUrlTestData.java
new file mode 100644
index 0000000000..2ea36939aa
--- /dev/null
+++ b/okhttp-tests/src/test/java/com/squareup/okhttp/WebPlatformUrlTestData.java
@@ -0,0 +1,156 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.okhttp;
+
+import java.io.EOFException;
+import java.io.IOException;
+import java.util.ArrayList;
+import java.util.List;
+import okio.Buffer;
+import okio.BufferedSource;
+
+/**
+ * A test from the <a href="https://github.com/w3c/web-platform-tests/tree/master/url">Web Platform
+ * URL test suite</a>. Each test is a line of the file {@code urltestdata.txt}; the format is
+ * informally specified by its JavaScript parser {@code urltestparser.js}; with which this class
+ * attempts to be compatible.
+ *
+ * <p>Each line of the urltestdata.text file specifies a test. Lines look like this: <pre>   {@code
+ *
+ *   http://example\t.\norg http://example.org/foo/bar s:http h:example.org p:/
+ * }</pre>
+ */
+public final class WebPlatformUrlTestData {
+  String input;
+  String base;
+  String scheme = "";
+  String username = "";
+  String password = null;
+  String host = "";
+  String port = "";
+  String path = "";
+  String query = "";
+  String fragment = "";
+
+  public boolean expectParseFailure() {
+    return scheme.isEmpty();
+  }
+
+  private void set(String name, String value) {
+    switch (name) {
+      case "s":
+        scheme = value;
+        break;
+      case "u":
+        username = value;
+        break;
+      case "pass":
+        password = value;
+        break;
+      case "h":
+        host = value;
+        break;
+      case "port":
+        port = value;
+        break;
+      case "p":
+        path = value;
+        break;
+      case "q":
+        query = value;
+        break;
+      case "f":
+        fragment = value;
+        break;
+      default:
+        throw new IllegalArgumentException("unexpected attribute: " + value);
+    }
+  }
+
+  @Override public String toString() {
+    return String.format("Parsing: <%s> against <%s>", input, base);
+  }
+
+  public static List<WebPlatformUrlTestData> load(BufferedSource source) throws IOException {
+    List<WebPlatformUrlTestData> list = new ArrayList<>();
+    for (String line; (line = source.readUtf8Line()) != null; ) {
+      if (line.isEmpty() || line.startsWith("#")) continue;
+
+      int i = 0;
+      String[] parts = line.split(" ");
+      WebPlatformUrlTestData element = new WebPlatformUrlTestData();
+      element.input = unescape(parts[i++]);
+
+      String base = i < parts.length ? parts[i++] : null;
+      element.base = (base == null || base.isEmpty())
+          ? list.get(list.size() - 1).base
+          : unescape(base);
+
+      for (; i < parts.length; i++) {
+        String piece = parts[i];
+        if (piece.startsWith("#")) continue;
+        String[] nameAndValue = piece.split(":", 2);
+        element.set(nameAndValue[0], unescape(nameAndValue[1]));
+      }
+
+      list.add(element);
+    }
+    return list;
+  }
+
+  private static String unescape(String s) throws EOFException {
+    Buffer in = new Buffer().writeUtf8(s);
+    StringBuilder result = new StringBuilder();
+    while (!in.exhausted()) {
+      int c = in.readUtf8CodePoint();
+      if (c != '\\') {
+        result.append((char) c);
+        continue;
+      }
+
+      switch (in.readUtf8CodePoint()) {
+        case '\\':
+          result.append('\\');
+          break;
+        case '#':
+          result.append('#');
+          break;
+        case 'n':
+          result.append('\n');
+          break;
+        case 'r':
+          result.append('\r');
+          break;
+        case 's':
+          result.append(' ');
+          break;
+        case 't':
+          result.append('\t');
+          break;
+        case 'f':
+          result.append('\f');
+          break;
+        case 'u':
+          result.append((char) Integer.parseInt(in.readUtf8(4), 16));
+          break;
+        default:
+          throw new IllegalArgumentException("unexpected escape character in " + s);
+      }
+    }
+
+    return result.toString();
+  }
+}
diff --git a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/ConnectionSpecSelectorTest.java b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/ConnectionSpecSelectorTest.java
new file mode 100644
index 0000000000..c94cc23213
--- /dev/null
+++ b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/ConnectionSpecSelectorTest.java
@@ -0,0 +1,141 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.okhttp.internal;
+
+import com.squareup.okhttp.ConnectionSpec;
+import com.squareup.okhttp.TlsVersion;
+import java.io.IOException;
+import java.security.cert.CertificateException;
+import java.util.Arrays;
+import java.util.LinkedHashSet;
+import java.util.Set;
+import javax.net.ssl.SSLContext;
+import javax.net.ssl.SSLHandshakeException;
+import javax.net.ssl.SSLSocket;
+import org.junit.Test;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertTrue;
+
+public class ConnectionSpecSelectorTest {
+  static {
+    Internal.initializeInstanceForTests();
+  }
+
+  public static final SSLHandshakeException RETRYABLE_EXCEPTION = new SSLHandshakeException(
+      "Simulated handshake exception");
+
+  private SSLContext sslContext = SslContextBuilder.localhost();
+
+  @Test
+  public void nonRetryableIOException() throws Exception {
+    ConnectionSpecSelector connectionSpecSelector =
+        createConnectionSpecSelector(ConnectionSpec.MODERN_TLS, ConnectionSpec.COMPATIBLE_TLS);
+    SSLSocket socket = createSocketWithEnabledProtocols(TlsVersion.TLS_1_1, TlsVersion.TLS_1_0);
+    connectionSpecSelector.configureSecureSocket(socket);
+
+    boolean retry = connectionSpecSelector.connectionFailed(
+        new IOException("Non-handshake exception"));
+    assertFalse(retry);
+    socket.close();
+  }
+
+  @Test
+  public void nonRetryableSSLHandshakeException() throws Exception {
+    ConnectionSpecSelector connectionSpecSelector =
+        createConnectionSpecSelector(ConnectionSpec.MODERN_TLS, ConnectionSpec.COMPATIBLE_TLS);
+    SSLSocket socket = createSocketWithEnabledProtocols(TlsVersion.TLS_1_1, TlsVersion.TLS_1_0);
+    connectionSpecSelector.configureSecureSocket(socket);
+
+    SSLHandshakeException trustIssueException =
+        new SSLHandshakeException("Certificate handshake exception");
+    trustIssueException.initCause(new CertificateException());
+    boolean retry = connectionSpecSelector.connectionFailed(trustIssueException);
+    assertFalse(retry);
+    socket.close();
+  }
+
+  @Test
+  public void retryableSSLHandshakeException() throws Exception {
+    ConnectionSpecSelector connectionSpecSelector =
+        createConnectionSpecSelector(ConnectionSpec.MODERN_TLS, ConnectionSpec.COMPATIBLE_TLS);
+    SSLSocket socket = createSocketWithEnabledProtocols(TlsVersion.TLS_1_1, TlsVersion.TLS_1_0);
+    connectionSpecSelector.configureSecureSocket(socket);
+
+    boolean retry = connectionSpecSelector.connectionFailed(RETRYABLE_EXCEPTION);
+    assertTrue(retry);
+    socket.close();
+  }
+
+  @Test
+  public void someFallbacksSupported() throws Exception {
+    ConnectionSpec sslV3 =
+        new ConnectionSpec.Builder(ConnectionSpec.MODERN_TLS)
+            .tlsVersions(TlsVersion.SSL_3_0)
+            .build();
+
+    ConnectionSpecSelector connectionSpecSelector = createConnectionSpecSelector(
+        ConnectionSpec.MODERN_TLS, ConnectionSpec.COMPATIBLE_TLS, sslV3);
+
+    TlsVersion[] enabledSocketTlsVersions = { TlsVersion.TLS_1_1, TlsVersion.TLS_1_0 };
+    SSLSocket socket = createSocketWithEnabledProtocols(enabledSocketTlsVersions);
+
+    // MODERN_TLS is used here.
+    connectionSpecSelector.configureSecureSocket(socket);
+    assertEnabledProtocols(socket, TlsVersion.TLS_1_1, TlsVersion.TLS_1_0);
+
+    boolean retry = connectionSpecSelector.connectionFailed(RETRYABLE_EXCEPTION);
+    assertTrue(retry);
+    socket.close();
+
+    // COMPATIBLE_TLS is used here.
+    socket = createSocketWithEnabledProtocols(enabledSocketTlsVersions);
+    connectionSpecSelector.configureSecureSocket(socket);
+    assertEnabledProtocols(socket, TlsVersion.TLS_1_0);
+
+    retry = connectionSpecSelector.connectionFailed(RETRYABLE_EXCEPTION);
+    assertFalse(retry);
+    socket.close();
+
+    // sslV3 is not used because SSLv3 is not enabled on the socket.
+  }
+
+  private static ConnectionSpecSelector createConnectionSpecSelector(
+      ConnectionSpec... connectionSpecs) {
+    return new ConnectionSpecSelector(Arrays.asList(connectionSpecs));
+  }
+
+  private SSLSocket createSocketWithEnabledProtocols(TlsVersion... tlsVersions) throws IOException {
+    SSLSocket socket = (SSLSocket) sslContext.getSocketFactory().createSocket();
+    socket.setEnabledProtocols(javaNames(tlsVersions));
+    return socket;
+  }
+
+  private static void assertEnabledProtocols(SSLSocket socket, TlsVersion... required) {
+    Set<String> actual = new LinkedHashSet<>(Arrays.asList(socket.getEnabledProtocols()));
+    Set<String> expected = new LinkedHashSet<>(Arrays.asList(javaNames(required)));
+    assertEquals(expected, actual);
+  }
+
+  private static String[] javaNames(TlsVersion... tlsVersions) {
+    String[] protocols = new String[tlsVersions.length];
+    for (int i = 0; i < tlsVersions.length; i++) {
+      protocols[i] = tlsVersions[i].javaName();
+    }
+    return protocols;
+  }
+}
diff --git a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/DiskLruCacheTest.java b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/DiskLruCacheTest.java
index 7326a0da22..c996d202dd 100644
--- a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/DiskLruCacheTest.java
+++ b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/DiskLruCacheTest.java
@@ -15,14 +15,9 @@
  */
 package com.squareup.okhttp.internal;
 
-import java.io.BufferedReader;
+import com.squareup.okhttp.internal.io.FileSystem;
 import java.io.File;
-import java.io.FileReader;
-import java.io.FileWriter;
 import java.io.IOException;
-import java.io.Reader;
-import java.io.StringWriter;
-import java.io.Writer;
 import java.util.ArrayDeque;
 import java.util.ArrayList;
 import java.util.Arrays;
@@ -57,6 +52,7 @@
   @Rule public final TemporaryFolder tempDir = new TemporaryFolder();
   @Rule public final Timeout timeout = new Timeout(30 * 1000);
 
+  private final FaultyFileSystem fileSystem = new FaultyFileSystem(FileSystem.SYSTEM);
   private final int appVersion = 100;
   private File cacheDir;
   private File journalFile;
@@ -71,7 +67,7 @@ private void createNewCache() throws IOException {
   }
 
   private void createNewCacheWithSize(int maxSize) throws IOException {
-    cache = new DiskLruCache(cacheDir, appVersion, 2, maxSize, executor);
+    cache = new DiskLruCache(fileSystem, cacheDir, appVersion, 2, maxSize, executor);
     synchronized (cache) {
       cache.initialize();
     }
@@ -272,7 +268,7 @@ private void createNewCacheWithSize(int maxSize) throws IOException {
     File k1 = getCleanFile("k1", 0);
     assertEquals("ABC", readFile(k1));
     cache.remove("k1");
-    assertFalse(k1.exists());
+    assertFalse(fileSystem.exists(k1));
   }
 
   @Test public void removePreventsActiveEditFromStoringAValue() throws Exception {
@@ -328,10 +324,10 @@ private void createNewCacheWithSize(int maxSize) throws IOException {
     writeFile(dirtyFile1, "D");
     createJournal("CLEAN k1 1 1", "DIRTY   k1");
     createNewCache();
-    assertFalse(cleanFile0.exists());
-    assertFalse(cleanFile1.exists());
-    assertFalse(dirtyFile0.exists());
-    assertFalse(dirtyFile1.exists());
+    assertFalse(fileSystem.exists(cleanFile0));
+    assertFalse(fileSystem.exists(cleanFile1));
+    assertFalse(fileSystem.exists(dirtyFile0));
+    assertFalse(fileSystem.exists(dirtyFile1));
     assertNull(cache.get("k1"));
   }
 
@@ -389,9 +385,10 @@ private void createNewCacheWithSize(int maxSize) throws IOException {
     cache.close();
     writeFile(getCleanFile("k1", 0), "A");
     writeFile(getCleanFile("k1", 1), "B");
-    Writer writer = new FileWriter(journalFile);
-    writer.write(MAGIC + "\n" + VERSION_1 + "\n100\n2\n\nCLEAN k1 1 1"); // no trailing newline
-    writer.close();
+
+    BufferedSink sink = Okio.buffer(fileSystem.sink(journalFile));
+    sink.writeUtf8(MAGIC + "\n" + VERSION_1 + "\n100\n2\n\nCLEAN k1 1 1"); // no trailing newline
+    sink.close();
     createNewCache();
     assertNull(cache.get("k1"));
 
@@ -453,10 +450,10 @@ private void createNewCacheWithSize(int maxSize) throws IOException {
     } catch (IllegalStateException expected) {
     }
 
-    assertFalse(getCleanFile("k1", 0).exists());
-    assertFalse(getCleanFile("k1", 1).exists());
-    assertFalse(getDirtyFile("k1", 0).exists());
-    assertFalse(getDirtyFile("k1", 1).exists());
+    assertFalse(fileSystem.exists(getCleanFile("k1", 0)));
+    assertFalse(fileSystem.exists(getCleanFile("k1", 1)));
+    assertFalse(fileSystem.exists(getDirtyFile("k1", 0)));
+    assertFalse(fileSystem.exists(getDirtyFile("k1", 1)));
     assertNull(cache.get("k1"));
 
     DiskLruCache.Editor creator2 = cache.edit("k1");
@@ -469,10 +466,10 @@ private void createNewCacheWithSize(int maxSize) throws IOException {
     DiskLruCache.Editor creator = cache.edit("k1");
     setString(creator, 1, "A");
     creator.abort();
-    assertFalse(getCleanFile("k1", 0).exists());
-    assertFalse(getCleanFile("k1", 1).exists());
-    assertFalse(getDirtyFile("k1", 0).exists());
-    assertFalse(getDirtyFile("k1", 1).exists());
+    assertFalse(fileSystem.exists(getCleanFile("k1", 0)));
+    assertFalse(fileSystem.exists(getCleanFile("k1", 1)));
+    assertFalse(fileSystem.exists(getDirtyFile("k1", 0)));
+    assertFalse(fileSystem.exists(getDirtyFile("k1", 1)));
     assertNull(cache.get("k1"));
   }
 
@@ -632,7 +629,7 @@ private void createNewCacheWithSize(int maxSize) throws IOException {
 
   @Test public void constructorDoesNotAllowZeroCacheSize() throws Exception {
     try {
-      DiskLruCache.create(cacheDir, appVersion, 2, 0);
+      DiskLruCache.create(fileSystem, cacheDir, appVersion, 2, 0);
       fail();
     } catch (IllegalArgumentException expected) {
     }
@@ -640,7 +637,7 @@ private void createNewCacheWithSize(int maxSize) throws IOException {
 
   @Test public void constructorDoesNotAllowZeroValuesPerEntry() throws Exception {
     try {
-      DiskLruCache.create(cacheDir, appVersion, 0, 10);
+      DiskLruCache.create(fileSystem, cacheDir, appVersion, 0, 10);
       fail();
     } catch (IllegalArgumentException expected) {
     }
@@ -707,8 +704,8 @@ private void createNewCacheWithSize(int maxSize) throws IOException {
     creator.commit();
     cache.close();
 
-    assertTrue(journalFile.renameTo(journalBkpFile));
-    assertFalse(journalFile.exists());
+    fileSystem.rename(journalFile, journalBkpFile);
+    assertFalse(fileSystem.exists(journalFile));
 
     createNewCache();
 
@@ -716,8 +713,8 @@ private void createNewCacheWithSize(int maxSize) throws IOException {
     assertSnapshotValue(snapshot, 0, "ABC");
     assertSnapshotValue(snapshot, 1, "DE");
 
-    assertFalse(journalBkpFile.exists());
-    assertTrue(journalFile.exists());
+    assertFalse(fileSystem.exists(journalBkpFile));
+    assertTrue(fileSystem.exists(journalFile));
   }
 
   @Test public void journalFileIsPreferredOverBackupFile() throws Exception {
@@ -735,8 +732,8 @@ private void createNewCacheWithSize(int maxSize) throws IOException {
     creator.commit();
     cache.close();
 
-    assertTrue(journalFile.exists());
-    assertTrue(journalBkpFile.exists());
+    assertTrue(fileSystem.exists(journalFile));
+    assertTrue(fileSystem.exists(journalBkpFile));
 
     createNewCache();
 
@@ -748,23 +745,23 @@ private void createNewCacheWithSize(int maxSize) throws IOException {
     assertSnapshotValue(snapshotB, 0, "F");
     assertSnapshotValue(snapshotB, 1, "GH");
 
-    assertFalse(journalBkpFile.exists());
-    assertTrue(journalFile.exists());
+    assertFalse(fileSystem.exists(journalBkpFile));
+    assertTrue(fileSystem.exists(journalFile));
   }
 
   @Test public void openCreatesDirectoryIfNecessary() throws Exception {
     cache.close();
     File dir = tempDir.newFolder("testOpenCreatesDirectoryIfNecessary");
-    cache = DiskLruCache.create(dir, appVersion, 2, Integer.MAX_VALUE);
+    cache = DiskLruCache.create(fileSystem, dir, appVersion, 2, Integer.MAX_VALUE);
     set("a", "a", "a");
-    assertTrue(new File(dir, "a.0").exists());
-    assertTrue(new File(dir, "a.1").exists());
-    assertTrue(new File(dir, "journal").exists());
+    assertTrue(fileSystem.exists(new File(dir, "a.0")));
+    assertTrue(fileSystem.exists(new File(dir, "a.1")));
+    assertTrue(fileSystem.exists(new File(dir, "journal")));
   }
 
   @Test public void fileDeletedExternally() throws Exception {
     set("a", "a", "a");
-    getCleanFile("a", 1).delete();
+    fileSystem.delete(getCleanFile("a", 1));
     assertNull(cache.get("a"));
   }
 
@@ -823,7 +820,7 @@ private void createNewCacheWithSize(int maxSize) throws IOException {
 
   /** @see <a href="https://github.com/JakeWharton/DiskLruCache/issues/2">Issue #2</a> */
   @Test public void aggressiveClearingHandlesWrite() throws Exception {
-    tempDir.delete();
+    fileSystem.deleteContents(tempDir.getRoot());
     set("a", "a", "a");
     assertValue("a", "a", "a");
   }
@@ -832,7 +829,7 @@ private void createNewCacheWithSize(int maxSize) throws IOException {
   @Test public void aggressiveClearingHandlesEdit() throws Exception {
     set("a", "a", "a");
     DiskLruCache.Editor a = cache.get("a").edit();
-    tempDir.delete();
+    fileSystem.deleteContents(tempDir.getRoot());
     setString(a, 1, "a2");
     a.commit();
   }
@@ -849,7 +846,7 @@ private void createNewCacheWithSize(int maxSize) throws IOException {
     set("b", "b", "b");
     DiskLruCache.Editor a = cache.get("a").edit();
     setString(a, 0, "a1");
-    tempDir.delete();
+    fileSystem.deleteContents(tempDir.getRoot());
     setString(a, 1, "a2");
     a.commit();
     assertNull(cache.get("a"));
@@ -857,7 +854,7 @@ private void createNewCacheWithSize(int maxSize) throws IOException {
 
   /** @see <a href="https://github.com/JakeWharton/DiskLruCache/issues/2">Issue #2</a> */
   @Test public void aggressiveClearingHandlesRead() throws Exception {
-    tempDir.delete();
+    fileSystem.deleteContents(tempDir.getRoot());
     assertNull(cache.get("a"));
   }
 
@@ -1064,7 +1061,7 @@ private void createNewCacheWithSize(int maxSize) throws IOException {
 
   @Test public void isClosed_uninitializedCache() throws Exception {
     // Create an uninitialized cache.
-    cache = new DiskLruCache(cacheDir, appVersion, 2, Integer.MAX_VALUE, executor);
+    cache = new DiskLruCache(fileSystem, cacheDir, appVersion, 2, Integer.MAX_VALUE, executor);
     toClose.add(cache);
 
     assertFalse(cache.isClosed());
@@ -1072,6 +1069,95 @@ private void createNewCacheWithSize(int maxSize) throws IOException {
     assertTrue(cache.isClosed());
   }
 
+  @Test public void journalWriteFailsDuringEdit() throws Exception {
+    set("a", "a", "a");
+    set("b", "b", "b");
+
+    // We can't begin the edit if writing 'DIRTY' fails.
+    fileSystem.setFaulty(journalFile, true);
+    assertNull(cache.edit("c"));
+
+    // Once the journal has a failure, subsequent writes aren't permitted.
+    fileSystem.setFaulty(journalFile, false);
+    assertNull(cache.edit("d"));
+
+    // Confirm that the fault didn't corrupt entries stored before the fault was introduced.
+    cache.close();
+    cache = new DiskLruCache(fileSystem, cacheDir, appVersion, 2, Integer.MAX_VALUE, executor);
+    assertValue("a", "a", "a");
+    assertValue("b", "b", "b");
+    assertAbsent("c");
+    assertAbsent("d");
+  }
+
+  /**
+   * We had a bug where the cache was left in an inconsistent state after a journal write failed.
+   * https://github.com/square/okhttp/issues/1211
+   */
+  @Test public void journalWriteFailsDuringEditorCommit() throws Exception {
+    set("a", "a", "a");
+    set("b", "b", "b");
+
+    // Create an entry that fails to write to the journal during commit.
+    DiskLruCache.Editor editor = cache.edit("c");
+    setString(editor, 0, "c");
+    setString(editor, 1, "c");
+    fileSystem.setFaulty(journalFile, true);
+    editor.commit();
+
+    // Once the journal has a failure, subsequent writes aren't permitted.
+    fileSystem.setFaulty(journalFile, false);
+    assertNull(cache.edit("d"));
+
+    // Confirm that the fault didn't corrupt entries stored before the fault was introduced.
+    cache.close();
+    cache = new DiskLruCache(fileSystem, cacheDir, appVersion, 2, Integer.MAX_VALUE, executor);
+    assertValue("a", "a", "a");
+    assertValue("b", "b", "b");
+    assertAbsent("c");
+    assertAbsent("d");
+  }
+
+  @Test public void journalWriteFailsDuringEditorAbort() throws Exception {
+    set("a", "a", "a");
+    set("b", "b", "b");
+
+    // Create an entry that fails to write to the journal during abort.
+    DiskLruCache.Editor editor = cache.edit("c");
+    setString(editor, 0, "c");
+    setString(editor, 1, "c");
+    fileSystem.setFaulty(journalFile, true);
+    editor.abort();
+
+    // Once the journal has a failure, subsequent writes aren't permitted.
+    fileSystem.setFaulty(journalFile, false);
+    assertNull(cache.edit("d"));
+
+    // Confirm that the fault didn't corrupt entries stored before the fault was introduced.
+    cache.close();
+    cache = new DiskLruCache(fileSystem, cacheDir, appVersion, 2, Integer.MAX_VALUE, executor);
+    assertValue("a", "a", "a");
+    assertValue("b", "b", "b");
+    assertAbsent("c");
+    assertAbsent("d");
+  }
+
+  @Test public void journalWriteFailsDuringRemove() throws Exception {
+    set("a", "a", "a");
+    set("b", "b", "b");
+
+    // Remove, but the journal write will fail.
+    fileSystem.setFaulty(journalFile, true);
+    assertTrue(cache.remove("a"));
+
+    // Confirm that the entry was still removed.
+    fileSystem.setFaulty(journalFile, false);
+    cache.close();
+    cache = new DiskLruCache(fileSystem, cacheDir, appVersion, 2, Integer.MAX_VALUE, executor);
+    assertAbsent("a");
+    assertValue("b", "b", "b");
+  }
+
   private void assertJournalEquals(String... expectedBodyLines) throws Exception {
     List<String> expectedLines = new ArrayList<>();
     expectedLines.add(MAGIC);
@@ -1089,27 +1175,26 @@ private void createJournal(String... bodyLines) throws Exception {
 
   private void createJournalWithHeader(String magic, String version, String appVersion,
       String valueCount, String blank, String... bodyLines) throws Exception {
-    Writer writer = new FileWriter(journalFile);
-    writer.write(magic + "\n");
-    writer.write(version + "\n");
-    writer.write(appVersion + "\n");
-    writer.write(valueCount + "\n");
-    writer.write(blank + "\n");
+    BufferedSink sink = Okio.buffer(fileSystem.sink(journalFile));
+    sink.writeUtf8(magic + "\n");
+    sink.writeUtf8(version + "\n");
+    sink.writeUtf8(appVersion + "\n");
+    sink.writeUtf8(valueCount + "\n");
+    sink.writeUtf8(blank + "\n");
     for (String line : bodyLines) {
-      writer.write(line);
-      writer.write('\n');
+      sink.writeUtf8(line);
+      sink.writeUtf8("\n");
     }
-    writer.close();
+    sink.close();
   }
 
   private List<String> readJournalLines() throws Exception {
     List<String> result = new ArrayList<>();
-    BufferedReader reader = new BufferedReader(new FileReader(journalFile));
-    String line;
-    while ((line = reader.readLine()) != null) {
+    BufferedSource source = Okio.buffer(fileSystem.source(journalFile));
+    for (String line; (line = source.readUtf8Line()) != null; ) {
       result.add(line);
     }
-    reader.close();
+    source.close();
     return result;
   }
 
@@ -1121,22 +1206,17 @@ private File getDirtyFile(String key, int index) {
     return new File(cacheDir, key + "." + index + ".tmp");
   }
 
-  private static String readFile(File file) throws Exception {
-    Reader reader = new FileReader(file);
-    StringWriter writer = new StringWriter();
-    char[] buffer = new char[1024];
-    int count;
-    while ((count = reader.read(buffer)) != -1) {
-      writer.write(buffer, 0, count);
-    }
-    reader.close();
-    return writer.toString();
+  private String readFile(File file) throws Exception {
+    BufferedSource source = Okio.buffer(fileSystem.source(file));
+    String result = source.readUtf8();
+    source.close();
+    return result;
   }
 
-  public static void writeFile(File file, String content) throws Exception {
-    FileWriter writer = new FileWriter(file);
-    writer.write(content);
-    writer.close();
+  public void writeFile(File file, String content) throws Exception {
+    BufferedSink sink = Okio.buffer(fileSystem.sink(file));
+    sink.writeUtf8(content);
+    sink.close();
   }
 
   private static void assertInoperable(DiskLruCache.Editor editor) throws Exception {
@@ -1176,18 +1256,16 @@ private void generateSomeGarbageFiles() throws Exception {
     writeFile(getCleanFile("g2", 1), "D");
     writeFile(getCleanFile("g2", 1), "D");
     writeFile(new File(cacheDir, "otherFile0"), "E");
-    dir1.mkdir();
-    dir2.mkdir();
     writeFile(new File(dir2, "otherFile1"), "F");
   }
 
   private void assertGarbageFilesAllDeleted() throws Exception {
-    assertFalse(getCleanFile("g1", 0).exists());
-    assertFalse(getCleanFile("g1", 1).exists());
-    assertFalse(getCleanFile("g2", 0).exists());
-    assertFalse(getCleanFile("g2", 1).exists());
-    assertFalse(new File(cacheDir, "otherFile0").exists());
-    assertFalse(new File(cacheDir, "dir1").exists());
+    assertFalse(fileSystem.exists(getCleanFile("g1", 0)));
+    assertFalse(fileSystem.exists(getCleanFile("g1", 1)));
+    assertFalse(fileSystem.exists(getCleanFile("g2", 0)));
+    assertFalse(fileSystem.exists(getCleanFile("g2", 1)));
+    assertFalse(fileSystem.exists(new File(cacheDir, "otherFile0")));
+    assertFalse(fileSystem.exists(new File(cacheDir, "dir1")));
   }
 
   private void set(String key, String value0, String value1) throws Exception {
@@ -1209,18 +1287,18 @@ private void assertAbsent(String key) throws Exception {
       snapshot.close();
       fail();
     }
-    assertFalse(getCleanFile(key, 0).exists());
-    assertFalse(getCleanFile(key, 1).exists());
-    assertFalse(getDirtyFile(key, 0).exists());
-    assertFalse(getDirtyFile(key, 1).exists());
+    assertFalse(fileSystem.exists(getCleanFile(key, 0)));
+    assertFalse(fileSystem.exists(getCleanFile(key, 1)));
+    assertFalse(fileSystem.exists(getDirtyFile(key, 0)));
+    assertFalse(fileSystem.exists(getDirtyFile(key, 1)));
   }
 
   private void assertValue(String key, String value0, String value1) throws Exception {
     DiskLruCache.Snapshot snapshot = cache.get(key);
     assertSnapshotValue(snapshot, 0, value0);
     assertSnapshotValue(snapshot, 1, value1);
-    assertTrue(getCleanFile(key, 0).exists());
-    assertTrue(getCleanFile(key, 1).exists());
+    assertTrue(fileSystem.exists(getCleanFile(key, 0)));
+    assertTrue(fileSystem.exists(getCleanFile(key, 1)));
     snapshot.close();
   }
 
@@ -1235,8 +1313,8 @@ private String sourceAsString(Source source) throws IOException {
   }
 
   private void copyFile(File from, File to) throws IOException {
-    Source source = Okio.source(from);
-    BufferedSink sink = Okio.buffer(Okio.sink(to));
+    Source source = fileSystem.source(from);
+    BufferedSink sink = Okio.buffer(fileSystem.sink(to));
     sink.writeAll(source);
     source.close();
     sink.close();
diff --git a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/FaultyFileSystem.java b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/FaultyFileSystem.java
new file mode 100644
index 0000000000..537f361c38
--- /dev/null
+++ b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/FaultyFileSystem.java
@@ -0,0 +1,90 @@
+/*
+ * Copyright (C) 2011 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.okhttp.internal;
+
+import com.squareup.okhttp.internal.io.FileSystem;
+import java.io.File;
+import java.io.FileNotFoundException;
+import java.io.IOException;
+import java.util.LinkedHashSet;
+import java.util.Set;
+import okio.Buffer;
+import okio.ForwardingSink;
+import okio.Sink;
+import okio.Source;
+
+public final class FaultyFileSystem implements FileSystem {
+  private final FileSystem delegate;
+  private final Set<File> writeFaults = new LinkedHashSet<>();
+
+  public FaultyFileSystem(FileSystem delegate) {
+    this.delegate = delegate;
+  }
+
+  public void setFaulty(File file, boolean faulty) {
+    if (faulty) {
+      writeFaults.add(file);
+    } else {
+      writeFaults.remove(file);
+    }
+  }
+
+  @Override public Source source(File file) throws FileNotFoundException {
+    return delegate.source(file);
+  }
+
+  @Override public Sink sink(File file) throws FileNotFoundException {
+    return new FaultySink(delegate.sink(file), file);
+  }
+
+  @Override public Sink appendingSink(File file) throws FileNotFoundException {
+    return new FaultySink(delegate.appendingSink(file), file);
+  }
+
+  @Override public void delete(File file) throws IOException {
+    delegate.delete(file);
+  }
+
+  @Override public boolean exists(File file) throws IOException {
+    return delegate.exists(file);
+  }
+
+  @Override public long size(File file) {
+    return delegate.size(file);
+  }
+
+  @Override public void rename(File from, File to) throws IOException {
+    delegate.rename(from, to);
+  }
+
+  @Override public void deleteContents(File directory) throws IOException {
+    delegate.deleteContents(directory);
+  }
+
+  private class FaultySink extends ForwardingSink {
+    private final File file;
+
+    public FaultySink(Sink delegate, File file) {
+      super(delegate);
+      this.file = file;
+    }
+
+    @Override public void write(Buffer source, long byteCount) throws IOException {
+      if (writeFaults.contains(file)) throw new IOException("boom!");
+      super.write(source, byteCount);
+    }
+  }
+}
diff --git a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/spdy/BaseTestHandler.java b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/framed/BaseTestHandler.java
similarity index 97%
rename from okhttp-tests/src/test/java/com/squareup/okhttp/internal/spdy/BaseTestHandler.java
rename to okhttp-tests/src/test/java/com/squareup/okhttp/internal/framed/BaseTestHandler.java
index d0b5e97ddb..252b4c7f54 100644
--- a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/spdy/BaseTestHandler.java
+++ b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/framed/BaseTestHandler.java
@@ -13,7 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.squareup.okhttp.internal.spdy;
+package com.squareup.okhttp.internal.framed;
 
 import java.io.IOException;
 import java.util.List;
diff --git a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/spdy/HpackDraft10Test.java b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/framed/HpackTest.java
similarity index 98%
rename from okhttp-tests/src/test/java/com/squareup/okhttp/internal/spdy/HpackDraft10Test.java
rename to okhttp-tests/src/test/java/com/squareup/okhttp/internal/framed/HpackTest.java
index b886a43fdd..aacddaba95 100644
--- a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/spdy/HpackDraft10Test.java
+++ b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/framed/HpackTest.java
@@ -13,7 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.squareup.okhttp.internal.spdy;
+package com.squareup.okhttp.internal.framed;
 
 import java.io.IOException;
 import java.util.Arrays;
@@ -28,23 +28,23 @@
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.fail;
 
-public class HpackDraft10Test {
+public class HpackTest {
 
   private final Buffer bytesIn = new Buffer();
-  private HpackDraft10.Reader hpackReader;
+  private Hpack.Reader hpackReader;
   private Buffer bytesOut = new Buffer();
-  private HpackDraft10.Writer hpackWriter;
+  private Hpack.Writer hpackWriter;
 
   @Before public void reset() {
     hpackReader = newReader(bytesIn);
-    hpackWriter = new HpackDraft10.Writer(bytesOut);
+    hpackWriter = new Hpack.Writer(bytesOut);
   }
 
   /**
    * Variable-length quantity special cases strings which are longer than 127
    * bytes.  Values such as cookies can be 4KiB, and should be possible to send.
    *
-   * <p> http://tools.ietf.org/html/draft-ietf-httpbis-header-compression-10#section-5.2
+   * <p> http://tools.ietf.org/html/draft-ietf-httpbis-header-compression-12#section-5.2
    */
   @Test public void largeHeaderValue() throws IOException {
     char[] value = new char[4096];
@@ -163,7 +163,7 @@
   }
 
   /**
-   * http://tools.ietf.org/html/draft-ietf-httpbis-header-compression-10#appendix-C.2.1
+   * http://tools.ietf.org/html/draft-ietf-httpbis-header-compression-12#appendix-C.2.1
    */
   @Test public void readLiteralHeaderFieldWithIndexing() throws IOException {
     bytesIn.writeByte(0x40); // Literal indexed
@@ -185,7 +185,7 @@
   }
 
   /**
-   * http://tools.ietf.org/html/draft-ietf-httpbis-header-compression-10#appendix-C.2.2
+   * http://tools.ietf.org/html/draft-ietf-httpbis-header-compression-12#appendix-C.2.2
    */
   @Test public void literalHeaderFieldWithoutIndexingIndexedName() throws IOException {
     List<Header> headerBlock = headerEntries(":path", "/sample/path");
@@ -347,7 +347,7 @@
   }
 
   /**
-   * http://tools.ietf.org/html/draft-ietf-httpbis-header-compression-10#appendix-C.2.4
+   * http://tools.ietf.org/html/draft-ietf-httpbis-header-compression-12#appendix-C.2.4
    */
   @Test public void readIndexedHeaderFieldFromStaticTableWithoutBuffering() throws IOException {
     bytesIn.writeByte(0x82); // == Indexed - Add ==
@@ -363,7 +363,7 @@
   }
 
   /**
-   * http://tools.ietf.org/html/draft-ietf-httpbis-header-compression-10#appendix-C.2
+   * http://tools.ietf.org/html/draft-ietf-httpbis-header-compression-12#appendix-C.2
    */
   @Test public void readRequestExamplesWithoutHuffman() throws IOException {
     firstRequestWithoutHuffman();
@@ -492,7 +492,7 @@ private void checkReadThirdRequestWithoutHuffman() {
   }
 
   /**
-   * http://tools.ietf.org/html/draft-ietf-httpbis-header-compression-10#appendix-C.4
+   * http://tools.ietf.org/html/draft-ietf-httpbis-header-compression-12#appendix-C.4
    */
   @Test public void readRequestExamplesWithHuffman() throws IOException {
     firstRequestWithHuffman();
@@ -692,8 +692,8 @@ private void checkReadThirdRequestWithHuffman() {
     assertEquals(ByteString.EMPTY, newReader(byteStream(0)).readByteString());
   }
 
-  private HpackDraft10.Reader newReader(Buffer source) {
-    return new HpackDraft10.Reader(4096, source);
+  private Hpack.Reader newReader(Buffer source) {
+    return new Hpack.Reader(4096, source);
   }
 
   private Buffer byteStream(int... bytes) {
diff --git a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/spdy/Http2ConnectionTest.java b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/framed/Http2ConnectionTest.java
similarity index 80%
rename from okhttp-tests/src/test/java/com/squareup/okhttp/internal/spdy/Http2ConnectionTest.java
rename to okhttp-tests/src/test/java/com/squareup/okhttp/internal/framed/Http2ConnectionTest.java
index 13c91d1620..24c512d9ba 100644
--- a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/spdy/Http2ConnectionTest.java
+++ b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/framed/Http2ConnectionTest.java
@@ -13,10 +13,11 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.squareup.okhttp.internal.spdy;
+package com.squareup.okhttp.internal.framed;
 
 import com.squareup.okhttp.internal.Util;
 import java.io.IOException;
+import java.net.Socket;
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.List;
@@ -30,23 +31,24 @@
 import org.junit.Test;
 
 import static com.squareup.okhttp.TestUtil.headerEntries;
-import static com.squareup.okhttp.internal.spdy.ErrorCode.CANCEL;
-import static com.squareup.okhttp.internal.spdy.ErrorCode.PROTOCOL_ERROR;
-import static com.squareup.okhttp.internal.spdy.Settings.DEFAULT_INITIAL_WINDOW_SIZE;
-import static com.squareup.okhttp.internal.spdy.Settings.PERSIST_VALUE;
-import static com.squareup.okhttp.internal.spdy.Spdy3.TYPE_DATA;
-import static com.squareup.okhttp.internal.spdy.Spdy3.TYPE_HEADERS;
-import static com.squareup.okhttp.internal.spdy.Spdy3.TYPE_PING;
-import static com.squareup.okhttp.internal.spdy.Spdy3.TYPE_RST_STREAM;
-import static com.squareup.okhttp.internal.spdy.Spdy3.TYPE_SETTINGS;
-import static com.squareup.okhttp.internal.spdy.Spdy3.TYPE_WINDOW_UPDATE;
+import static com.squareup.okhttp.TestUtil.repeat;
+import static com.squareup.okhttp.internal.framed.ErrorCode.CANCEL;
+import static com.squareup.okhttp.internal.framed.ErrorCode.PROTOCOL_ERROR;
+import static com.squareup.okhttp.internal.framed.Settings.DEFAULT_INITIAL_WINDOW_SIZE;
+import static com.squareup.okhttp.internal.framed.Settings.PERSIST_VALUE;
+import static com.squareup.okhttp.internal.framed.Spdy3.TYPE_DATA;
+import static com.squareup.okhttp.internal.framed.Spdy3.TYPE_HEADERS;
+import static com.squareup.okhttp.internal.framed.Spdy3.TYPE_PING;
+import static com.squareup.okhttp.internal.framed.Spdy3.TYPE_RST_STREAM;
+import static com.squareup.okhttp.internal.framed.Spdy3.TYPE_SETTINGS;
+import static com.squareup.okhttp.internal.framed.Spdy3.TYPE_WINDOW_UPDATE;
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertFalse;
 import static org.junit.Assert.assertTrue;
 import static org.junit.Assert.fail;
 
 public final class Http2ConnectionTest {
-  private static final Variant HTTP_2 = new Http20Draft16();
+  private static final Variant HTTP_2 = new Http2();
   private final MockSpdyPeer peer = new MockSpdyPeer();
 
   @After public void tearDown() throws Exception {
@@ -82,7 +84,7 @@
     peer.play();
 
     // play it back
-    SpdyConnection connection = connection(peer, HTTP_2);
+    FramedConnection connection = connection(peer, HTTP_2);
     Ping ping = connection.ping();
     assertTrue(ping.roundTripTime() > 0);
     assertTrue(ping.roundTripTime() < TimeUnit.SECONDS.toNanos(1));
@@ -110,7 +112,7 @@
     peer.acceptFrame(); // HEADERS
     peer.play();
 
-    SpdyConnection connection = connection(peer, HTTP_2);
+    FramedConnection connection = connection(peer, HTTP_2);
 
     // Default is 64KiB - 1.
     assertEquals(65535, connection.peerSettings.getInitialWindowSize(-1));
@@ -126,7 +128,7 @@
     assertTrue(ackFrame.ack);
 
     // This stream was created *after* the connection settings were adjusted.
-    SpdyStream stream = connection.newStream(headerEntries("a", "android"), false, true);
+    FramedStream stream = connection.newStream(headerEntries("a", "android"), false, true);
 
     assertEquals(3368, connection.peerSettings.getInitialWindowSize(DEFAULT_INITIAL_WINDOW_SIZE));
     assertEquals(1684, connection.bytesLeftInWriteWindow); // initial wasn't affected.
@@ -139,11 +141,11 @@
     Settings settings = new Settings();
     settings.set(Settings.HEADER_TABLE_SIZE, PERSIST_VALUE, 0);
 
-    SpdyConnection connection = sendHttp2SettingsAndCheckForAck(client, settings);
+    FramedConnection connection = sendHttp2SettingsAndCheckForAck(client, settings);
 
     // verify the peer's settings were read and applied.
     assertEquals(0, connection.peerSettings.getHeaderTableSize());
-    Http20Draft16.Reader frameReader = (Http20Draft16.Reader) connection.readerRunnable.frameReader;
+    Http2.Reader frameReader = (Http2.Reader) connection.readerRunnable.frameReader;
     assertEquals(0, frameReader.hpackReader.maxDynamicTableByteCount());
     // TODO: when supported, check the frameWriter's compression table is unaffected.
   }
@@ -153,7 +155,7 @@
     Settings settings = new Settings();
     settings.set(Settings.ENABLE_PUSH, 0, 0); // The peer client disables push.
 
-    SpdyConnection connection = sendHttp2SettingsAndCheckForAck(client, settings);
+    FramedConnection connection = sendHttp2SettingsAndCheckForAck(client, settings);
 
     // verify the peer's settings were read and applied.
     assertFalse(connection.peerSettings.getEnablePush(true));
@@ -164,7 +166,7 @@
     Settings settings = new Settings();
     settings.set(Settings.MAX_FRAME_SIZE, 0, newMaxFrameSize);
 
-    SpdyConnection connection = sendHttp2SettingsAndCheckForAck(true, settings);
+    FramedConnection connection = sendHttp2SettingsAndCheckForAck(true, settings);
 
     // verify the peer's settings were read and applied.
     assertEquals(newMaxFrameSize, connection.peerSettings.getMaxFrameSize(-1));
@@ -184,9 +186,9 @@
     peer.play();
 
     // play it back
-    SpdyConnection connection = connection(peer, HTTP_2);
-    SpdyStream stream1 = connection.newStream(headerEntries("a", "android"), true, true);
-    SpdyStream stream2 = connection.newStream(headerEntries("b", "banana"), true, true);
+    FramedConnection connection = connection(peer, HTTP_2);
+    FramedStream stream1 = connection.newStream(headerEntries("a", "android"), true, true);
+    FramedStream stream2 = connection.newStream(headerEntries("b", "banana"), true, true);
     connection.ping().roundTripTime(); // Ensure the GO_AWAY that resets stream2 has been received.
     BufferedSink sink1 = Okio.buffer(stream1.getSink());
     BufferedSink sink2 = Okio.buffer(stream2.getSink());
@@ -244,9 +246,9 @@
     peer.play();
 
     // Play it back.
-    SpdyConnection connection = connection(peer, HTTP_2);
+    FramedConnection connection = connection(peer, HTTP_2);
     connection.okHttpSettings.set(Settings.INITIAL_WINDOW_SIZE, 0, windowSize);
-    SpdyStream stream = connection.newStream(headerEntries("b", "banana"), false, true);
+    FramedStream stream = connection.newStream(headerEntries("b", "banana"), false, true);
     assertEquals(0, stream.unacknowledgedBytesRead);
     assertEquals(headerEntries("a", "android"), stream.getResponseHeaders());
     Source in = stream.getSource();
@@ -284,8 +286,8 @@ private Buffer data(int byteCount) {
     peer.play();
 
     // Play it back.
-    SpdyConnection connection = connection(peer, HTTP_2);
-    SpdyStream client = connection.newStream(headerEntries("b", "banana"), false, true);
+    FramedConnection connection = connection(peer, HTTP_2);
+    FramedStream client = connection.newStream(headerEntries("b", "banana"), false, true);
     assertEquals(-1, client.getSource().read(new Buffer(), 1));
 
     // Verify the peer received what was expected.
@@ -304,8 +306,8 @@ private Buffer data(int byteCount) {
     peer.play();
 
     // Play it back.
-    SpdyConnection connection = connection(peer, HTTP_2);
-    SpdyStream client = connection.newStream(headerEntries("b", "banana"), true, true);
+    FramedConnection connection = connection(peer, HTTP_2);
+    FramedStream client = connection.newStream(headerEntries("b", "banana"), true, true);
     BufferedSink out = Okio.buffer(client.getSink());
     out.write(Util.EMPTY_BYTE_ARRAY);
     out.flush();
@@ -331,8 +333,8 @@ private Buffer data(int byteCount) {
     peer.play();
 
     // play it back
-    SpdyConnection connection = connection(peer, HTTP_2);
-    SpdyStream stream = connection.newStream(headerEntries("b", "banana"), true, true);
+    FramedConnection connection = connection(peer, HTTP_2);
+    FramedStream stream = connection.newStream(headerEntries("b", "banana"), true, true);
     BufferedSink out = Okio.buffer(stream.getSink());
     out.write(buff);
     out.flush();
@@ -369,9 +371,9 @@ private Buffer data(int byteCount) {
     RecordingPushObserver observer = new RecordingPushObserver();
 
     // play it back
-    SpdyConnection connection = connectionBuilder(peer, HTTP_2)
+    FramedConnection connection = connectionBuilder(peer, HTTP_2)
         .pushObserver(observer).build();
-    SpdyStream client = connection.newStream(headerEntries("b", "banana"), false, true);
+    FramedStream client = connection.newStream(headerEntries("b", "banana"), false, true);
     assertEquals(-1, client.getSource().read(new Buffer(), 1));
 
     // verify the peer received what was expected
@@ -392,7 +394,7 @@ private Buffer data(int byteCount) {
     peer.play();
 
     // play it back
-    SpdyConnection connection = connectionBuilder(peer, HTTP_2).build();
+    FramedConnection connection = connectionBuilder(peer, HTTP_2).build();
     connection.newStream(headerEntries("b", "banana"), false, true);
 
     // verify the peer received what was expected
@@ -427,7 +429,38 @@ private Buffer data(int byteCount) {
     assertEquals(CANCEL, rstStream.errorCode);
   }
 
-  private SpdyConnection sendHttp2SettingsAndCheckForAck(boolean client, Settings settings)
+  /**
+   * When writing a set of headers fails due to an {@code IOException}, make sure the writer is left
+   * in a consistent state so the next writer also gets an {@code IOException} also instead of
+   * something worse (like an {@link IllegalStateException}.
+   *
+   * <p>See https://github.com/square/okhttp/issues/1651
+   */
+  @Test public void socketExceptionWhileWritingHeaders() throws Exception {
+    peer.setVariantAndClient(HTTP_2, false);
+    peer.acceptFrame(); // SYN_STREAM.
+    peer.play();
+
+    String longString = repeat('a', Http2.INITIAL_MAX_FRAME_SIZE + 1);
+    Socket socket = peer.openSocket();
+    FramedConnection connection = new FramedConnection.Builder(true, socket)
+        .pushObserver(IGNORE)
+        .protocol(HTTP_2.getProtocol())
+        .build();
+    socket.shutdownOutput();
+    try {
+      connection.newStream(headerEntries("a", longString), false, true);
+      fail();
+    } catch (IOException expected) {
+    }
+    try {
+      connection.newStream(headerEntries("b", longString), false, true);
+      fail();
+    } catch (IOException expected) {
+    }
+  }
+
+  private FramedConnection sendHttp2SettingsAndCheckForAck(boolean client, Settings settings)
       throws IOException, InterruptedException {
     peer.setVariantAndClient(HTTP_2, client);
     peer.sendFrame().settings(settings);
@@ -437,7 +470,7 @@ private SpdyConnection sendHttp2SettingsAndCheckForAck(boolean client, Settings
     peer.play();
 
     // play it back
-    SpdyConnection connection = connection(peer, HTTP_2);
+    FramedConnection connection = connection(peer, HTTP_2);
 
     // verify the peer received the ACK
     MockSpdyPeer.InFrame ackFrame = peer.takeFrame();
@@ -449,13 +482,13 @@ private SpdyConnection sendHttp2SettingsAndCheckForAck(boolean client, Settings
     return connection;
   }
 
-  private SpdyConnection connection(MockSpdyPeer peer, Variant variant) throws IOException {
+  private FramedConnection connection(MockSpdyPeer peer, Variant variant) throws IOException {
     return connectionBuilder(peer, variant).build();
   }
 
-  private SpdyConnection.Builder connectionBuilder(MockSpdyPeer peer, Variant variant)
+  private FramedConnection.Builder connectionBuilder(MockSpdyPeer peer, Variant variant)
       throws IOException {
-    return new SpdyConnection.Builder(true, peer.openSocket())
+    return new FramedConnection.Builder(true, peer.openSocket())
         .pushObserver(IGNORE)
         .protocol(variant.getProtocol());
   }
diff --git a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/spdy/Http20Draft16FrameLoggerTest.java b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/framed/Http2FrameLoggerTest.java
similarity index 82%
rename from okhttp-tests/src/test/java/com/squareup/okhttp/internal/spdy/Http20Draft16FrameLoggerTest.java
rename to okhttp-tests/src/test/java/com/squareup/okhttp/internal/framed/Http2FrameLoggerTest.java
index 992611f5eb..12a9e3bf90 100644
--- a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/spdy/Http20Draft16FrameLoggerTest.java
+++ b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/framed/Http2FrameLoggerTest.java
@@ -13,29 +13,29 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.squareup.okhttp.internal.spdy;
+package com.squareup.okhttp.internal.framed;
 
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.List;
 import org.junit.Test;
 
-import static com.squareup.okhttp.internal.spdy.Http20Draft16.FLAG_ACK;
-import static com.squareup.okhttp.internal.spdy.Http20Draft16.FLAG_END_HEADERS;
-import static com.squareup.okhttp.internal.spdy.Http20Draft16.FLAG_END_STREAM;
-import static com.squareup.okhttp.internal.spdy.Http20Draft16.FLAG_NONE;
-import static com.squareup.okhttp.internal.spdy.Http20Draft16.FrameLogger.formatFlags;
-import static com.squareup.okhttp.internal.spdy.Http20Draft16.FrameLogger.formatHeader;
-import static com.squareup.okhttp.internal.spdy.Http20Draft16.TYPE_CONTINUATION;
-import static com.squareup.okhttp.internal.spdy.Http20Draft16.TYPE_DATA;
-import static com.squareup.okhttp.internal.spdy.Http20Draft16.TYPE_GOAWAY;
-import static com.squareup.okhttp.internal.spdy.Http20Draft16.TYPE_HEADERS;
-import static com.squareup.okhttp.internal.spdy.Http20Draft16.TYPE_PING;
-import static com.squareup.okhttp.internal.spdy.Http20Draft16.TYPE_PUSH_PROMISE;
-import static com.squareup.okhttp.internal.spdy.Http20Draft16.TYPE_SETTINGS;
+import static com.squareup.okhttp.internal.framed.Http2.FLAG_ACK;
+import static com.squareup.okhttp.internal.framed.Http2.FLAG_END_HEADERS;
+import static com.squareup.okhttp.internal.framed.Http2.FLAG_END_STREAM;
+import static com.squareup.okhttp.internal.framed.Http2.FLAG_NONE;
+import static com.squareup.okhttp.internal.framed.Http2.FrameLogger.formatFlags;
+import static com.squareup.okhttp.internal.framed.Http2.FrameLogger.formatHeader;
+import static com.squareup.okhttp.internal.framed.Http2.TYPE_CONTINUATION;
+import static com.squareup.okhttp.internal.framed.Http2.TYPE_DATA;
+import static com.squareup.okhttp.internal.framed.Http2.TYPE_GOAWAY;
+import static com.squareup.okhttp.internal.framed.Http2.TYPE_HEADERS;
+import static com.squareup.okhttp.internal.framed.Http2.TYPE_PING;
+import static com.squareup.okhttp.internal.framed.Http2.TYPE_PUSH_PROMISE;
+import static com.squareup.okhttp.internal.framed.Http2.TYPE_SETTINGS;
 import static org.junit.Assert.assertEquals;
 
-public class Http20Draft16FrameLoggerTest {
+public class Http2FrameLoggerTest {
 
   /** Real stream traffic applied to the log format. */
   @Test public void exampleStream() {
diff --git a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/spdy/Http20Draft16Test.java b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/framed/Http2Test.java
similarity index 84%
rename from okhttp-tests/src/test/java/com/squareup/okhttp/internal/spdy/Http20Draft16Test.java
rename to okhttp-tests/src/test/java/com/squareup/okhttp/internal/framed/Http2Test.java
index acf3f1c2f0..8e4f306a54 100644
--- a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/spdy/Http20Draft16Test.java
+++ b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/framed/Http2Test.java
@@ -13,7 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.squareup.okhttp.internal.spdy;
+package com.squareup.okhttp.internal.framed;
 
 import com.squareup.okhttp.internal.Util;
 import java.io.IOException;
@@ -28,26 +28,26 @@
 import org.junit.Test;
 
 import static com.squareup.okhttp.TestUtil.headerEntries;
-import static com.squareup.okhttp.internal.spdy.Http20Draft16.FLAG_COMPRESSED;
-import static com.squareup.okhttp.internal.spdy.Http20Draft16.FLAG_END_HEADERS;
-import static com.squareup.okhttp.internal.spdy.Http20Draft16.FLAG_END_STREAM;
-import static com.squareup.okhttp.internal.spdy.Http20Draft16.FLAG_NONE;
-import static com.squareup.okhttp.internal.spdy.Http20Draft16.FLAG_PADDED;
-import static com.squareup.okhttp.internal.spdy.Http20Draft16.FLAG_PRIORITY;
+import static com.squareup.okhttp.internal.framed.Http2.FLAG_COMPRESSED;
+import static com.squareup.okhttp.internal.framed.Http2.FLAG_END_HEADERS;
+import static com.squareup.okhttp.internal.framed.Http2.FLAG_END_STREAM;
+import static com.squareup.okhttp.internal.framed.Http2.FLAG_NONE;
+import static com.squareup.okhttp.internal.framed.Http2.FLAG_PADDED;
+import static com.squareup.okhttp.internal.framed.Http2.FLAG_PRIORITY;
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertFalse;
 import static org.junit.Assert.assertTrue;
 import static org.junit.Assert.fail;
 
-public class Http20Draft16Test {
+public class Http2Test {
   final Buffer frame = new Buffer();
-  final FrameReader fr = new Http20Draft16.Reader(frame, 4096, false);
+  final FrameReader fr = new Http2.Reader(frame, 4096, false);
   final int expectedStreamId = 15;
 
   @Test public void unknownFrameTypeSkipped() throws IOException {
     writeMedium(frame, 4); // has a 4-byte field
     frame.writeByte(99); // type 99
-    frame.writeByte(Http20Draft16.FLAG_NONE);
+    frame.writeByte(Http2.FLAG_NONE);
     frame.writeInt(expectedStreamId);
     frame.writeInt(111111111); // custom data
 
@@ -59,7 +59,7 @@
 
     Buffer headerBytes = literalHeaders(sentHeaders);
     writeMedium(frame, (int) headerBytes.size());
-    frame.writeByte(Http20Draft16.TYPE_HEADERS);
+    frame.writeByte(Http2.TYPE_HEADERS);
     frame.writeByte(FLAG_END_HEADERS | FLAG_END_STREAM);
     frame.writeInt(expectedStreamId & 0x7fffffff);
     frame.writeAll(headerBytes);
@@ -85,7 +85,7 @@ public void headers(boolean outFinished, boolean inFinished, int streamId,
 
     Buffer headerBytes = literalHeaders(sentHeaders);
     writeMedium(frame, (int) (headerBytes.size() + 5));
-    frame.writeByte(Http20Draft16.TYPE_HEADERS);
+    frame.writeByte(Http2.TYPE_HEADERS);
     frame.writeByte(FLAG_END_HEADERS | FLAG_PRIORITY);
     frame.writeInt(expectedStreamId & 0x7fffffff);
     frame.writeInt(0); // Independent stream.
@@ -120,15 +120,15 @@ public void headers(boolean outFinished, boolean inFinished, int streamId,
     Buffer headerBlock = literalHeaders(sentHeaders);
 
     // Write the first headers frame.
-    writeMedium(frame, Http20Draft16.INITIAL_MAX_FRAME_SIZE);
-    frame.writeByte(Http20Draft16.TYPE_HEADERS);
-    frame.writeByte(Http20Draft16.FLAG_NONE);
+    writeMedium(frame, Http2.INITIAL_MAX_FRAME_SIZE);
+    frame.writeByte(Http2.TYPE_HEADERS);
+    frame.writeByte(Http2.FLAG_NONE);
     frame.writeInt(expectedStreamId & 0x7fffffff);
-    frame.write(headerBlock, Http20Draft16.INITIAL_MAX_FRAME_SIZE);
+    frame.write(headerBlock, Http2.INITIAL_MAX_FRAME_SIZE);
 
     // Write the continuation frame, specifying no more frames are expected.
     writeMedium(frame, (int) headerBlock.size());
-    frame.writeByte(Http20Draft16.TYPE_CONTINUATION);
+    frame.writeByte(Http2.TYPE_CONTINUATION);
     frame.writeByte(FLAG_END_HEADERS);
     frame.writeInt(expectedStreamId & 0x7fffffff);
     frame.writeAll(headerBlock);
@@ -162,8 +162,8 @@ public void headers(boolean outFinished, boolean inFinished, int streamId,
     // Write the push promise frame, specifying the associated stream ID.
     Buffer headerBytes = literalHeaders(pushPromise);
     writeMedium(frame, (int) (headerBytes.size() + 4));
-    frame.writeByte(Http20Draft16.TYPE_PUSH_PROMISE);
-    frame.writeByte(Http20Draft16.FLAG_END_PUSH_PROMISE);
+    frame.writeByte(Http2.TYPE_PUSH_PROMISE);
+    frame.writeByte(Http2.FLAG_END_PUSH_PROMISE);
     frame.writeInt(expectedStreamId & 0x7fffffff);
     frame.writeInt(expectedPromisedStreamId & 0x7fffffff);
     frame.writeAll(headerBytes);
@@ -189,16 +189,16 @@ public void pushPromise(int streamId, int promisedStreamId, List<Header> headerB
     Buffer headerBlock = literalHeaders(pushPromise);
 
     // Write the first headers frame.
-    writeMedium(frame, Http20Draft16.INITIAL_MAX_FRAME_SIZE);
-    frame.writeByte(Http20Draft16.TYPE_PUSH_PROMISE);
-    frame.writeByte(Http20Draft16.FLAG_NONE);
+    writeMedium(frame, Http2.INITIAL_MAX_FRAME_SIZE);
+    frame.writeByte(Http2.TYPE_PUSH_PROMISE);
+    frame.writeByte(Http2.FLAG_NONE);
     frame.writeInt(expectedStreamId & 0x7fffffff);
     frame.writeInt(expectedPromisedStreamId & 0x7fffffff);
-    frame.write(headerBlock, Http20Draft16.INITIAL_MAX_FRAME_SIZE - 4);
+    frame.write(headerBlock, Http2.INITIAL_MAX_FRAME_SIZE - 4);
 
     // Write the continuation frame, specifying no more frames are expected.
     writeMedium(frame, (int) headerBlock.size());
-    frame.writeByte(Http20Draft16.TYPE_CONTINUATION);
+    frame.writeByte(Http2.TYPE_CONTINUATION);
     frame.writeByte(FLAG_END_HEADERS);
     frame.writeInt(expectedStreamId & 0x7fffffff);
     frame.writeAll(headerBlock);
@@ -218,8 +218,8 @@ public void pushPromise(int streamId, int promisedStreamId, List<Header> headerB
 
   @Test public void readRstStreamFrame() throws IOException {
     writeMedium(frame, 4);
-    frame.writeByte(Http20Draft16.TYPE_RST_STREAM);
-    frame.writeByte(Http20Draft16.FLAG_NONE);
+    frame.writeByte(Http2.TYPE_RST_STREAM);
+    frame.writeByte(Http2.FLAG_NONE);
     frame.writeInt(expectedStreamId & 0x7fffffff);
     frame.writeInt(ErrorCode.COMPRESSION_ERROR.httpCode);
 
@@ -235,8 +235,8 @@ public void pushPromise(int streamId, int promisedStreamId, List<Header> headerB
     final int reducedTableSizeBytes = 16;
 
     writeMedium(frame, 12); // 2 settings * 6 bytes (2 for the code and 4 for the value).
-    frame.writeByte(Http20Draft16.TYPE_SETTINGS);
-    frame.writeByte(Http20Draft16.FLAG_NONE);
+    frame.writeByte(Http2.TYPE_SETTINGS);
+    frame.writeByte(Http2.FLAG_NONE);
     frame.writeInt(0); // Settings are always on the connection stream 0.
     frame.writeShort(1); // SETTINGS_HEADER_TABLE_SIZE
     frame.writeInt(reducedTableSizeBytes);
@@ -254,8 +254,8 @@ public void pushPromise(int streamId, int promisedStreamId, List<Header> headerB
 
   @Test public void readSettingsFrameInvalidPushValue() throws IOException {
     writeMedium(frame, 6); // 2 for the code and 4 for the value
-    frame.writeByte(Http20Draft16.TYPE_SETTINGS);
-    frame.writeByte(Http20Draft16.FLAG_NONE);
+    frame.writeByte(Http2.TYPE_SETTINGS);
+    frame.writeByte(Http2.FLAG_NONE);
     frame.writeInt(0); // Settings are always on the connection stream 0.
     frame.writeShort(2);
     frame.writeInt(2);
@@ -270,8 +270,8 @@ public void pushPromise(int streamId, int promisedStreamId, List<Header> headerB
 
   @Test public void readSettingsFrameInvalidSettingId() throws IOException {
     writeMedium(frame, 6); // 2 for the code and 4 for the value
-    frame.writeByte(Http20Draft16.TYPE_SETTINGS);
-    frame.writeByte(Http20Draft16.FLAG_NONE);
+    frame.writeByte(Http2.TYPE_SETTINGS);
+    frame.writeByte(Http2.FLAG_NONE);
     frame.writeInt(0); // Settings are always on the connection stream 0.
     frame.writeShort(7); // old number for SETTINGS_INITIAL_WINDOW_SIZE
     frame.writeInt(1);
@@ -286,8 +286,8 @@ public void pushPromise(int streamId, int promisedStreamId, List<Header> headerB
 
   @Test public void readSettingsFrameNegativeWindowSize() throws IOException {
     writeMedium(frame, 6); // 2 for the code and 4 for the value
-    frame.writeByte(Http20Draft16.TYPE_SETTINGS);
-    frame.writeByte(Http20Draft16.FLAG_NONE);
+    frame.writeByte(Http2.TYPE_SETTINGS);
+    frame.writeByte(Http2.FLAG_NONE);
     frame.writeInt(0); // Settings are always on the connection stream 0.
     frame.writeShort(4); // SETTINGS_INITIAL_WINDOW_SIZE
     frame.writeInt(Integer.MIN_VALUE);
@@ -302,8 +302,8 @@ public void pushPromise(int streamId, int promisedStreamId, List<Header> headerB
 
   @Test public void readSettingsFrameNegativeFrameLength() throws IOException {
     writeMedium(frame, 6); // 2 for the code and 4 for the value
-    frame.writeByte(Http20Draft16.TYPE_SETTINGS);
-    frame.writeByte(Http20Draft16.FLAG_NONE);
+    frame.writeByte(Http2.TYPE_SETTINGS);
+    frame.writeByte(Http2.FLAG_NONE);
     frame.writeInt(0); // Settings are always on the connection stream 0.
     frame.writeShort(5); // SETTINGS_MAX_FRAME_SIZE
     frame.writeInt(Integer.MIN_VALUE);
@@ -318,8 +318,8 @@ public void pushPromise(int streamId, int promisedStreamId, List<Header> headerB
 
   @Test public void readSettingsFrameTooShortFrameLength() throws IOException {
     writeMedium(frame, 6); // 2 for the code and 4 for the value
-    frame.writeByte(Http20Draft16.TYPE_SETTINGS);
-    frame.writeByte(Http20Draft16.FLAG_NONE);
+    frame.writeByte(Http2.TYPE_SETTINGS);
+    frame.writeByte(Http2.FLAG_NONE);
     frame.writeInt(0); // Settings are always on the connection stream 0.
     frame.writeShort(5); // SETTINGS_MAX_FRAME_SIZE
     frame.writeInt((int) Math.pow(2, 14) - 1);
@@ -334,8 +334,8 @@ public void pushPromise(int streamId, int promisedStreamId, List<Header> headerB
 
   @Test public void readSettingsFrameTooLongFrameLength() throws IOException {
     writeMedium(frame, 6); // 2 for the code and 4 for the value
-    frame.writeByte(Http20Draft16.TYPE_SETTINGS);
-    frame.writeByte(Http20Draft16.FLAG_NONE);
+    frame.writeByte(Http2.TYPE_SETTINGS);
+    frame.writeByte(Http2.FLAG_NONE);
     frame.writeInt(0); // Settings are always on the connection stream 0.
     frame.writeShort(5); // SETTINGS_MAX_FRAME_SIZE
     frame.writeInt((int) Math.pow(2, 24));
@@ -353,8 +353,8 @@ public void pushPromise(int streamId, int promisedStreamId, List<Header> headerB
     final int expectedPayload2 = 8;
 
     writeMedium(frame, 8); // length
-    frame.writeByte(Http20Draft16.TYPE_PING);
-    frame.writeByte(Http20Draft16.FLAG_ACK);
+    frame.writeByte(Http2.TYPE_PING);
+    frame.writeByte(Http2.FLAG_ACK);
     frame.writeInt(0); // connection-level
     frame.writeInt(expectedPayload1);
     frame.writeInt(expectedPayload2);
@@ -372,12 +372,12 @@ public void pushPromise(int streamId, int promisedStreamId, List<Header> headerB
   }
 
   @Test public void maxLengthDataFrame() throws IOException {
-    final byte[] expectedData = new byte[Http20Draft16.INITIAL_MAX_FRAME_SIZE];
+    final byte[] expectedData = new byte[Http2.INITIAL_MAX_FRAME_SIZE];
     Arrays.fill(expectedData, (byte) 2);
 
     writeMedium(frame, expectedData.length);
-    frame.writeByte(Http20Draft16.TYPE_DATA);
-    frame.writeByte(Http20Draft16.FLAG_NONE);
+    frame.writeByte(Http2.TYPE_DATA);
+    frame.writeByte(Http2.FLAG_NONE);
     frame.writeInt(expectedStreamId & 0x7fffffff);
     frame.write(expectedData);
 
@@ -389,7 +389,7 @@ public void pushPromise(int streamId, int promisedStreamId, List<Header> headerB
           int length) throws IOException {
         assertFalse(inFinished);
         assertEquals(expectedStreamId, streamId);
-        assertEquals(Http20Draft16.INITIAL_MAX_FRAME_SIZE, length);
+        assertEquals(Http2.INITIAL_MAX_FRAME_SIZE, length);
         ByteString data = source.readByteString(length);
         for (byte b : data.toByteArray()) {
           assertEquals(2, b);
@@ -400,13 +400,13 @@ public void pushPromise(int streamId, int promisedStreamId, List<Header> headerB
 
   /** We do not send SETTINGS_COMPRESS_DATA = 1, nor want to. Let's make sure we error. */
   @Test public void compressedDataFrameWhenSettingDisabled() throws IOException {
-    byte[] expectedData = new byte[Http20Draft16.INITIAL_MAX_FRAME_SIZE];
+    byte[] expectedData = new byte[Http2.INITIAL_MAX_FRAME_SIZE];
     Arrays.fill(expectedData, (byte) 2);
     Buffer zipped = gzip(expectedData);
     int zippedSize = (int) zipped.size();
 
     writeMedium(frame, zippedSize);
-    frame.writeByte(Http20Draft16.TYPE_DATA);
+    frame.writeByte(Http2.TYPE_DATA);
     frame.writeByte(FLAG_COMPRESSED);
     frame.writeInt(expectedStreamId & 0x7fffffff);
     zipped.readAll(frame);
@@ -430,7 +430,7 @@ public void pushPromise(int streamId, int promisedStreamId, List<Header> headerB
     Arrays.fill(padding, (byte) 0);
 
     writeMedium(frame, dataLength + paddingLength + 1);
-    frame.writeByte(Http20Draft16.TYPE_DATA);
+    frame.writeByte(Http2.TYPE_DATA);
     frame.writeByte(FLAG_PADDED);
     frame.writeInt(expectedStreamId & 0x7fffffff);
     frame.writeByte(paddingLength);
@@ -447,7 +447,7 @@ public void pushPromise(int streamId, int promisedStreamId, List<Header> headerB
     Arrays.fill(expectedData, (byte) 2);
 
     writeMedium(frame, dataLength + 1);
-    frame.writeByte(Http20Draft16.TYPE_DATA);
+    frame.writeByte(Http2.TYPE_DATA);
     frame.writeByte(FLAG_PADDED);
     frame.writeInt(expectedStreamId & 0x7fffffff);
     frame.writeByte(0);
@@ -463,7 +463,7 @@ public void pushPromise(int streamId, int promisedStreamId, List<Header> headerB
 
     Buffer headerBlock = literalHeaders(headerEntries("foo", "barrr", "baz", "qux"));
     writeMedium(frame, (int) headerBlock.size() + paddingLength + 1);
-    frame.writeByte(Http20Draft16.TYPE_HEADERS);
+    frame.writeByte(Http2.TYPE_HEADERS);
     frame.writeByte(FLAG_END_HEADERS | FLAG_PADDED);
     frame.writeInt(expectedStreamId & 0x7fffffff);
     frame.writeByte(paddingLength);
@@ -477,7 +477,7 @@ public void pushPromise(int streamId, int promisedStreamId, List<Header> headerB
   @Test public void readPaddedHeadersFrameZeroPadding() throws IOException {
     Buffer headerBlock = literalHeaders(headerEntries("foo", "barrr", "baz", "qux"));
     writeMedium(frame, (int) headerBlock.size() + 1);
-    frame.writeByte(Http20Draft16.TYPE_HEADERS);
+    frame.writeByte(Http2.TYPE_HEADERS);
     frame.writeByte(FLAG_END_HEADERS | FLAG_PADDED);
     frame.writeInt(expectedStreamId & 0x7fffffff);
     frame.writeByte(0);
@@ -497,7 +497,7 @@ public void pushPromise(int streamId, int promisedStreamId, List<Header> headerB
 
     // Write the first headers frame.
     writeMedium(frame, (int) (headerBlock.size() / 2) + paddingLength + 1);
-    frame.writeByte(Http20Draft16.TYPE_HEADERS);
+    frame.writeByte(Http2.TYPE_HEADERS);
     frame.writeByte(FLAG_PADDED);
     frame.writeInt(expectedStreamId & 0x7fffffff);
     frame.writeByte(paddingLength);
@@ -506,7 +506,7 @@ public void pushPromise(int streamId, int promisedStreamId, List<Header> headerB
 
     // Write the continuation frame, specifying no more frames are expected.
     writeMedium(frame, (int) headerBlock.size());
-    frame.writeByte(Http20Draft16.TYPE_CONTINUATION);
+    frame.writeByte(Http2.TYPE_CONTINUATION);
     frame.writeByte(FLAG_END_HEADERS);
     frame.writeInt(expectedStreamId & 0x7fffffff);
     frame.writeAll(headerBlock);
@@ -528,8 +528,8 @@ public void pushPromise(int streamId, int promisedStreamId, List<Header> headerB
     final long expectedWindowSizeIncrement = 0x7fffffff;
 
     writeMedium(frame, 4); // length
-    frame.writeByte(Http20Draft16.TYPE_WINDOW_UPDATE);
-    frame.writeByte(Http20Draft16.FLAG_NONE);
+    frame.writeByte(Http2.TYPE_WINDOW_UPDATE);
+    frame.writeByte(Http2.FLAG_NONE);
     frame.writeInt(expectedStreamId);
     frame.writeInt((int) expectedWindowSizeIncrement);
 
@@ -565,8 +565,8 @@ public void pushPromise(int streamId, int promisedStreamId, List<Header> headerB
     final ErrorCode expectedError = ErrorCode.PROTOCOL_ERROR;
 
     writeMedium(frame, 8); // Without debug data there's only 2 32-bit fields.
-    frame.writeByte(Http20Draft16.TYPE_GOAWAY);
-    frame.writeByte(Http20Draft16.FLAG_NONE);
+    frame.writeByte(Http2.TYPE_GOAWAY);
+    frame.writeByte(Http2.FLAG_NONE);
     frame.writeInt(0); // connection-scope
     frame.writeInt(expectedStreamId); // last good stream.
     frame.writeInt(expectedError.httpCode);
@@ -590,8 +590,8 @@ public void pushPromise(int streamId, int promisedStreamId, List<Header> headerB
 
     // Compose the expected GOAWAY frame without debug data.
     writeMedium(frame, 8 + expectedData.size());
-    frame.writeByte(Http20Draft16.TYPE_GOAWAY);
-    frame.writeByte(Http20Draft16.FLAG_NONE);
+    frame.writeByte(Http2.TYPE_GOAWAY);
+    frame.writeByte(Http2.FLAG_NONE);
     frame.writeInt(0); // connection-scope
     frame.writeInt(0); // never read any stream!
     frame.writeInt(expectedError.httpCode);
@@ -611,10 +611,10 @@ public void pushPromise(int streamId, int promisedStreamId, List<Header> headerB
   }
 
   @Test public void frameSizeError() throws IOException {
-    Http20Draft16.Writer writer = new Http20Draft16.Writer(new Buffer(), true);
+    Http2.Writer writer = new Http2.Writer(new Buffer(), true);
 
     try {
-      writer.frameHeader(0, 16777216, Http20Draft16.TYPE_DATA, FLAG_NONE);
+      writer.frameHeader(0, 16777216, Http2.TYPE_DATA, FLAG_NONE);
       fail();
     } catch (IllegalArgumentException e) {
       // TODO: real max is based on settings between 16384 and 16777215
@@ -625,21 +625,21 @@ public void pushPromise(int streamId, int promisedStreamId, List<Header> headerB
   @Test public void ackSettingsAppliesMaxFrameSize() throws IOException {
     int newMaxFrameSize = 16777215;
 
-    Http20Draft16.Writer writer = new Http20Draft16.Writer(new Buffer(), true);
+    Http2.Writer writer = new Http2.Writer(new Buffer(), true);
 
     writer.ackSettings(new Settings().set(Settings.MAX_FRAME_SIZE, 0, newMaxFrameSize));
 
     assertEquals(newMaxFrameSize, writer.maxDataLength());
-    writer.frameHeader(0, newMaxFrameSize, Http20Draft16.TYPE_DATA, FLAG_NONE);
+    writer.frameHeader(0, newMaxFrameSize, Http2.TYPE_DATA, FLAG_NONE);
   }
 
   @Test public void streamIdHasReservedBit() throws IOException {
-    Http20Draft16.Writer writer = new Http20Draft16.Writer(new Buffer(), true);
+    Http2.Writer writer = new Http2.Writer(new Buffer(), true);
 
     try {
       int streamId = 3;
       streamId |= 1L << 31; // set reserved bit
-      writer.frameHeader(streamId, Http20Draft16.INITIAL_MAX_FRAME_SIZE, Http20Draft16.TYPE_DATA, FLAG_NONE);
+      writer.frameHeader(streamId, Http2.INITIAL_MAX_FRAME_SIZE, Http2.TYPE_DATA, FLAG_NONE);
       fail();
     } catch (IllegalArgumentException e) {
       assertEquals("reserved bit set: -2147483645", e.getMessage());
@@ -648,45 +648,45 @@ public void pushPromise(int streamId, int promisedStreamId, List<Header> headerB
 
   private Buffer literalHeaders(List<Header> sentHeaders) throws IOException {
     Buffer out = new Buffer();
-    new HpackDraft10.Writer(out).writeHeaders(sentHeaders);
+    new Hpack.Writer(out).writeHeaders(sentHeaders);
     return out;
   }
 
   private Buffer sendHeaderFrames(boolean outFinished, List<Header> headers) throws IOException {
     Buffer out = new Buffer();
-    new Http20Draft16.Writer(out, true).headers(outFinished, expectedStreamId, headers);
+    new Http2.Writer(out, true).headers(outFinished, expectedStreamId, headers);
     return out;
   }
 
   private Buffer sendPushPromiseFrames(int streamId, List<Header> headers) throws IOException {
     Buffer out = new Buffer();
-    new Http20Draft16.Writer(out, true).pushPromise(expectedStreamId, streamId, headers);
+    new Http2.Writer(out, true).pushPromise(expectedStreamId, streamId, headers);
     return out;
   }
 
   private Buffer sendPingFrame(boolean ack, int payload1, int payload2) throws IOException {
     Buffer out = new Buffer();
-    new Http20Draft16.Writer(out, true).ping(ack, payload1, payload2);
+    new Http2.Writer(out, true).ping(ack, payload1, payload2);
     return out;
   }
 
   private Buffer sendGoAway(int lastGoodStreamId, ErrorCode errorCode, byte[] debugData)
       throws IOException {
     Buffer out = new Buffer();
-    new Http20Draft16.Writer(out, true).goAway(lastGoodStreamId, errorCode, debugData);
+    new Http2.Writer(out, true).goAway(lastGoodStreamId, errorCode, debugData);
     return out;
   }
 
   private Buffer sendDataFrame(Buffer data) throws IOException {
     Buffer out = new Buffer();
-    new Http20Draft16.Writer(out, true).dataFrame(expectedStreamId, FLAG_NONE, data,
+    new Http2.Writer(out, true).dataFrame(expectedStreamId, FLAG_NONE, data,
         (int) data.size());
     return out;
   }
 
   private Buffer windowUpdate(long windowSizeIncrement) throws IOException {
     Buffer out = new Buffer();
-    new Http20Draft16.Writer(out, true).windowUpdate(expectedStreamId, windowSizeIncrement);
+    new Http2.Writer(out, true).windowUpdate(expectedStreamId, windowSizeIncrement);
     return out;
   }
 
diff --git a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/spdy/HuffmanTest.java b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/framed/HuffmanTest.java
similarity index 97%
rename from okhttp-tests/src/test/java/com/squareup/okhttp/internal/spdy/HuffmanTest.java
rename to okhttp-tests/src/test/java/com/squareup/okhttp/internal/framed/HuffmanTest.java
index 222d23e150..eeddd3e28d 100644
--- a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/spdy/HuffmanTest.java
+++ b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/framed/HuffmanTest.java
@@ -13,7 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.squareup.okhttp.internal.spdy;
+package com.squareup.okhttp.internal.framed;
 
 import java.io.ByteArrayOutputStream;
 import java.io.DataOutputStream;
diff --git a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/spdy/MockSpdyPeer.java b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/framed/MockSpdyPeer.java
similarity index 94%
rename from okhttp-tests/src/test/java/com/squareup/okhttp/internal/spdy/MockSpdyPeer.java
rename to okhttp-tests/src/test/java/com/squareup/okhttp/internal/framed/MockSpdyPeer.java
index fd6da2b0c9..f30d099a9f 100644
--- a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/spdy/MockSpdyPeer.java
+++ b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/framed/MockSpdyPeer.java
@@ -14,7 +14,7 @@
  * limitations under the License.
  */
 
-package com.squareup.okhttp.internal.spdy;
+package com.squareup.okhttp.internal.framed;
 
 import com.squareup.okhttp.internal.Util;
 import java.io.Closeable;
@@ -30,6 +30,7 @@
 import java.util.concurrent.ExecutorService;
 import java.util.concurrent.Executors;
 import java.util.concurrent.LinkedBlockingQueue;
+import java.util.logging.Logger;
 import okio.Buffer;
 import okio.BufferedSource;
 import okio.ByteString;
@@ -37,6 +38,8 @@
 
 /** Replays prerecorded outgoing frames and records incoming frames. */
 public final class MockSpdyPeer implements Closeable {
+  private static final Logger logger = Logger.getLogger(MockSpdyPeer.class.getName());
+
   private int frameCount = 0;
   private boolean client = false;
   private Variant variant = new Spdy3();
@@ -122,7 +125,7 @@ public void play() throws IOException {
           readAndWriteFrames();
         } catch (IOException e) {
           Util.closeQuietly(MockSpdyPeer.this);
-          e.printStackTrace();
+          logger.info(MockSpdyPeer.this + " done: " + e.getMessage());
         }
       }
     });
@@ -131,6 +134,15 @@ public void play() throws IOException {
   private void readAndWriteFrames() throws IOException {
     if (socket != null) throw new IllegalStateException();
     socket = serverSocket.accept();
+
+    // Bail out now if this instance was closed while waiting for the socket to accept.
+    synchronized (this) {
+      if (executor.isShutdown()) {
+        socket.close();
+        return;
+      }
+    }
+
     OutputStream out = socket.getOutputStream();
     InputStream in = socket.getInputStream();
     FrameReader reader = variant.newReader(Okio.buffer(Okio.source(in)), client);
@@ -180,16 +192,12 @@ public Socket openSocket() throws IOException {
 
   @Override public synchronized void close() throws IOException {
     executor.shutdown();
-    Socket socket = this.socket;
-    if (socket != null) {
-      Util.closeQuietly(socket);
-      this.socket = null;
-    }
-    ServerSocket serverSocket = this.serverSocket;
-    if (serverSocket != null) {
-      Util.closeQuietly(serverSocket);
-      this.serverSocket = null;
-    }
+    Util.closeQuietly(socket);
+    Util.closeQuietly(serverSocket);
+  }
+
+  @Override public String toString() {
+    return "MockSpdyPeer[" + port + "]";
   }
 
   private static class OutFrame {
@@ -299,7 +307,7 @@ public InFrame(int sequence, FrameReader reader) {
 
     @Override
     public void pushPromise(int streamId, int associatedStreamId, List<Header> headerBlock) {
-      this.type = Http20Draft16.TYPE_PUSH_PROMISE;
+      this.type = Http2.TYPE_PUSH_PROMISE;
       this.streamId = streamId;
       this.associatedStreamId = associatedStreamId;
       this.headerBlock = headerBlock;
diff --git a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/spdy/SettingsTest.java b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/framed/SettingsTest.java
similarity index 91%
rename from okhttp-tests/src/test/java/com/squareup/okhttp/internal/spdy/SettingsTest.java
rename to okhttp-tests/src/test/java/com/squareup/okhttp/internal/framed/SettingsTest.java
index f9f9efa32d..be5f8ecd1b 100644
--- a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/spdy/SettingsTest.java
+++ b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/framed/SettingsTest.java
@@ -13,17 +13,17 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.squareup.okhttp.internal.spdy;
+package com.squareup.okhttp.internal.framed;
 
 import org.junit.Test;
 
-import static com.squareup.okhttp.internal.spdy.Settings.DEFAULT_INITIAL_WINDOW_SIZE;
-import static com.squareup.okhttp.internal.spdy.Settings.DOWNLOAD_BANDWIDTH;
-import static com.squareup.okhttp.internal.spdy.Settings.DOWNLOAD_RETRANS_RATE;
-import static com.squareup.okhttp.internal.spdy.Settings.MAX_CONCURRENT_STREAMS;
-import static com.squareup.okhttp.internal.spdy.Settings.PERSISTED;
-import static com.squareup.okhttp.internal.spdy.Settings.PERSIST_VALUE;
-import static com.squareup.okhttp.internal.spdy.Settings.UPLOAD_BANDWIDTH;
+import static com.squareup.okhttp.internal.framed.Settings.DEFAULT_INITIAL_WINDOW_SIZE;
+import static com.squareup.okhttp.internal.framed.Settings.DOWNLOAD_BANDWIDTH;
+import static com.squareup.okhttp.internal.framed.Settings.DOWNLOAD_RETRANS_RATE;
+import static com.squareup.okhttp.internal.framed.Settings.MAX_CONCURRENT_STREAMS;
+import static com.squareup.okhttp.internal.framed.Settings.PERSISTED;
+import static com.squareup.okhttp.internal.framed.Settings.PERSIST_VALUE;
+import static com.squareup.okhttp.internal.framed.Settings.UPLOAD_BANDWIDTH;
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertFalse;
 import static org.junit.Assert.assertTrue;
diff --git a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/spdy/Spdy3ConnectionTest.java b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/framed/Spdy3ConnectionTest.java
similarity index 81%
rename from okhttp-tests/src/test/java/com/squareup/okhttp/internal/spdy/Spdy3ConnectionTest.java
rename to okhttp-tests/src/test/java/com/squareup/okhttp/internal/framed/Spdy3ConnectionTest.java
index 110412ec2e..26d4986f26 100644
--- a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/spdy/Spdy3ConnectionTest.java
+++ b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/framed/Spdy3ConnectionTest.java
@@ -13,16 +13,20 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.squareup.okhttp.internal.spdy;
+package com.squareup.okhttp.internal.framed;
 
 import com.squareup.okhttp.internal.Util;
 import java.io.IOException;
 import java.io.InterruptedIOException;
+import java.net.Socket;
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.List;
+import java.util.Random;
+import java.util.concurrent.CountDownLatch;
 import java.util.concurrent.TimeUnit;
 import java.util.concurrent.atomic.AtomicInteger;
+import okio.AsyncTimeout;
 import okio.Buffer;
 import okio.BufferedSink;
 import okio.ByteString;
@@ -33,20 +37,20 @@
 import org.junit.Test;
 
 import static com.squareup.okhttp.TestUtil.headerEntries;
-import static com.squareup.okhttp.internal.spdy.ErrorCode.CANCEL;
-import static com.squareup.okhttp.internal.spdy.ErrorCode.INTERNAL_ERROR;
-import static com.squareup.okhttp.internal.spdy.ErrorCode.INVALID_STREAM;
-import static com.squareup.okhttp.internal.spdy.ErrorCode.PROTOCOL_ERROR;
-import static com.squareup.okhttp.internal.spdy.ErrorCode.REFUSED_STREAM;
-import static com.squareup.okhttp.internal.spdy.ErrorCode.STREAM_IN_USE;
-import static com.squareup.okhttp.internal.spdy.Settings.DEFAULT_INITIAL_WINDOW_SIZE;
-import static com.squareup.okhttp.internal.spdy.Settings.PERSIST_VALUE;
-import static com.squareup.okhttp.internal.spdy.Spdy3.TYPE_DATA;
-import static com.squareup.okhttp.internal.spdy.Spdy3.TYPE_GOAWAY;
-import static com.squareup.okhttp.internal.spdy.Spdy3.TYPE_HEADERS;
-import static com.squareup.okhttp.internal.spdy.Spdy3.TYPE_PING;
-import static com.squareup.okhttp.internal.spdy.Spdy3.TYPE_RST_STREAM;
-import static com.squareup.okhttp.internal.spdy.Spdy3.TYPE_WINDOW_UPDATE;
+import static com.squareup.okhttp.internal.framed.ErrorCode.CANCEL;
+import static com.squareup.okhttp.internal.framed.ErrorCode.INTERNAL_ERROR;
+import static com.squareup.okhttp.internal.framed.ErrorCode.INVALID_STREAM;
+import static com.squareup.okhttp.internal.framed.ErrorCode.PROTOCOL_ERROR;
+import static com.squareup.okhttp.internal.framed.ErrorCode.REFUSED_STREAM;
+import static com.squareup.okhttp.internal.framed.ErrorCode.STREAM_IN_USE;
+import static com.squareup.okhttp.internal.framed.Settings.DEFAULT_INITIAL_WINDOW_SIZE;
+import static com.squareup.okhttp.internal.framed.Settings.PERSIST_VALUE;
+import static com.squareup.okhttp.internal.framed.Spdy3.TYPE_DATA;
+import static com.squareup.okhttp.internal.framed.Spdy3.TYPE_GOAWAY;
+import static com.squareup.okhttp.internal.framed.Spdy3.TYPE_HEADERS;
+import static com.squareup.okhttp.internal.framed.Spdy3.TYPE_PING;
+import static com.squareup.okhttp.internal.framed.Spdy3.TYPE_RST_STREAM;
+import static com.squareup.okhttp.internal.framed.Spdy3.TYPE_WINDOW_UPDATE;
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertFalse;
 import static org.junit.Assert.assertTrue;
@@ -70,8 +74,8 @@
     peer.play();
 
     // play it back
-    SpdyConnection connection = connection(peer, SPDY3);
-    SpdyStream stream = connection.newStream(headerEntries("b", "banana"), true, true);
+    FramedConnection connection = connection(peer, SPDY3);
+    FramedStream stream = connection.newStream(headerEntries("b", "banana"), true, true);
     assertEquals(headerEntries("a", "android"), stream.getResponseHeaders());
     assertStreamData("robot", stream.getSource());
     BufferedSink out = Okio.buffer(stream.getSink());
@@ -99,8 +103,8 @@
     peer.sendFrame().ping(true, 1, 0);
     peer.play();
 
-    SpdyConnection connection = connection(peer, SPDY3);
-    SpdyStream stream = connection.newStream(headerEntries("a", "android"), false, false);
+    FramedConnection connection = connection(peer, SPDY3);
+    FramedStream stream = connection.newStream(headerEntries("a", "android"), false, false);
     assertEquals(1, connection.openStreamCount());
     assertEquals(headerEntries("b", "banana"), stream.getResponseHeaders());
     connection.ping().roundTripTime(); // Ensure that inFinished has been received.
@@ -116,7 +120,7 @@
     peer.play();
 
     // play it back
-    SpdyConnection connection = connection(peer, SPDY3);
+    FramedConnection connection = connection(peer, SPDY3);
     connection.newStream(headerEntries("b", "banana"), false, true);
     assertEquals(1, connection.openStreamCount());
     connection.ping().roundTripTime(); // Ensure that the SYN_REPLY has been received.
@@ -147,14 +151,14 @@
     // play it back
     final AtomicInteger receiveCount = new AtomicInteger();
     IncomingStreamHandler handler = new IncomingStreamHandler() {
-      @Override public void receive(SpdyStream stream) throws IOException {
+      @Override public void receive(FramedStream stream) throws IOException {
         receiveCount.incrementAndGet();
         assertEquals(pushHeaders, stream.getRequestHeaders());
         assertEquals(null, stream.getErrorCode());
         stream.reply(headerEntries("b", "banana"), true);
       }
     };
-    new SpdyConnection.Builder(true, peer.openSocket()).handler(handler).build();
+    new FramedConnection.Builder(true, peer.openSocket()).handler(handler).build();
 
     // verify the peer received what was expected
     MockSpdyPeer.InFrame reply = peer.takeFrame();
@@ -175,7 +179,7 @@
     // play it back
     final AtomicInteger receiveCount = new AtomicInteger();
     IncomingStreamHandler handler = new IncomingStreamHandler() {
-      @Override public void receive(SpdyStream stream) throws IOException {
+      @Override public void receive(FramedStream stream) throws IOException {
         stream.reply(headerEntries("b", "banana"), false);
         receiveCount.incrementAndGet();
       }
@@ -216,7 +220,7 @@
     peer.play();
 
     // play it back
-    SpdyConnection connection = connection(peer, SPDY3);
+    FramedConnection connection = connection(peer, SPDY3);
     Ping ping = connection.ping();
     assertTrue(ping.roundTripTime() > 0);
     assertTrue(ping.roundTripTime() < TimeUnit.SECONDS.toNanos(1));
@@ -258,7 +262,7 @@
     peer.play();
 
     // play it back
-    SpdyConnection connection = connection(peer, SPDY3);
+    FramedConnection connection = connection(peer, SPDY3);
 
     peer.takeFrame(); // Guarantees that the peer Settings frame has been processed.
     synchronized (connection) {
@@ -283,7 +287,7 @@
     peer.play();
 
     // play it back
-    SpdyConnection connection = connection(peer, SPDY3);
+    FramedConnection connection = connection(peer, SPDY3);
 
     peer.takeFrame(); // Guarantees that the Settings frame has been processed.
     synchronized (connection) {
@@ -310,7 +314,7 @@
     peer.play();
 
     // play it back
-    SpdyConnection connection = connection(peer, SPDY3);
+    FramedConnection connection = connection(peer, SPDY3);
 
     peer.takeFrame(); // Guarantees that the Settings frame has been processed.
 
@@ -378,8 +382,8 @@
     peer.play();
 
     // play it back
-    SpdyConnection connection = connection(peer, SPDY3);
-    SpdyStream stream = connection.newStream(headerEntries("a", "android"), true, false);
+    FramedConnection connection = connection(peer, SPDY3);
+    FramedStream stream = connection.newStream(headerEntries("a", "android"), true, false);
     BufferedSink out = Okio.buffer(stream.getSink());
     out.writeUtf8("square");
     out.flush();
@@ -421,8 +425,8 @@
     peer.play();
 
     // play it back
-    SpdyConnection connection = connection(peer, SPDY3);
-    SpdyStream stream = connection.newStream(headerEntries("a", "android"), true, true);
+    FramedConnection connection = connection(peer, SPDY3);
+    FramedStream stream = connection.newStream(headerEntries("a", "android"), true, true);
     BufferedSink out = Okio.buffer(stream.getSink());
     connection.ping().roundTripTime(); // Ensure that the RST_CANCEL has been received.
     try {
@@ -462,8 +466,8 @@
     peer.play();
 
     // play it back
-    SpdyConnection connection = connection(peer, SPDY3);
-    SpdyStream stream = connection.newStream(headerEntries("a", "android"), false, true);
+    FramedConnection connection = connection(peer, SPDY3);
+    FramedStream stream = connection.newStream(headerEntries("a", "android"), false, true);
     Source in = stream.getSource();
     BufferedSink out = Okio.buffer(stream.getSink());
     in.close();
@@ -506,8 +510,8 @@
     peer.play();
 
     // play it back
-    SpdyConnection connection = connection(peer, SPDY3);
-    SpdyStream stream = connection.newStream(headerEntries("a", "android"), true, true);
+    FramedConnection connection = connection(peer, SPDY3);
+    FramedStream stream = connection.newStream(headerEntries("a", "android"), true, true);
     Source source = stream.getSource();
     BufferedSink out = Okio.buffer(stream.getSink());
     source.close();
@@ -550,8 +554,8 @@
     peer.play();
 
     // play it back
-    SpdyConnection connection = connection(peer, SPDY3);
-    SpdyStream stream = connection.newStream(headerEntries("a", "android"), false, true);
+    FramedConnection connection = connection(peer, SPDY3);
+    FramedStream stream = connection.newStream(headerEntries("a", "android"), false, true);
     Source source = stream.getSource();
     assertStreamData("square", source);
     connection.ping().roundTripTime(); // Ensure that inFinished has been received.
@@ -576,8 +580,8 @@
     peer.play();
 
     // play it back
-    SpdyConnection connection = connection(peer, SPDY3);
-    SpdyStream stream = connection.newStream(headerEntries("c", "cola"), true, true);
+    FramedConnection connection = connection(peer, SPDY3);
+    FramedStream stream = connection.newStream(headerEntries("c", "cola"), true, true);
     assertEquals(headerEntries("a", "android"), stream.getResponseHeaders());
     connection.ping().roundTripTime(); // Ensure that the 2nd SYN REPLY has been received.
     try {
@@ -610,14 +614,14 @@
     // play it back
     final AtomicInteger receiveCount = new AtomicInteger();
     IncomingStreamHandler handler = new IncomingStreamHandler() {
-      @Override public void receive(SpdyStream stream) throws IOException {
+      @Override public void receive(FramedStream stream) throws IOException {
         receiveCount.incrementAndGet();
         assertEquals(headerEntries("a", "android"), stream.getRequestHeaders());
         assertEquals(null, stream.getErrorCode());
         stream.reply(headerEntries("c", "cola"), true);
       }
     };
-    new SpdyConnection.Builder(true, peer.openSocket()).handler(handler).build();
+    new FramedConnection.Builder(true, peer.openSocket()).handler(handler).build();
 
     // verify the peer received what was expected
     MockSpdyPeer.InFrame reply = peer.takeFrame();
@@ -641,8 +645,8 @@
     peer.play();
 
     // play it back
-    SpdyConnection connection = connection(peer, SPDY3);
-    SpdyStream stream = connection.newStream(headerEntries("b", "banana"), true, true);
+    FramedConnection connection = connection(peer, SPDY3);
+    FramedStream stream = connection.newStream(headerEntries("b", "banana"), true, true);
     assertEquals(headerEntries("a", "android"), stream.getResponseHeaders());
     assertStreamData("robot", stream.getSource());
 
@@ -666,8 +670,8 @@
     peer.play();
 
     // play it back
-    SpdyConnection connection = connection(peer, SPDY3);
-    SpdyStream stream = connection.newStream(headerEntries("a", "android"), true, true);
+    FramedConnection connection = connection(peer, SPDY3);
+    FramedStream stream = connection.newStream(headerEntries("a", "android"), true, true);
     assertEquals(headerEntries("b", "banana"), stream.getResponseHeaders());
 
     // verify the peer received what was expected
@@ -688,8 +692,8 @@
     peer.play();
 
     // play it back
-    SpdyConnection connection = connection(peer, SPDY3);
-    SpdyStream stream = connection.newStream(headerEntries("a", "android"), true, true);
+    FramedConnection connection = connection(peer, SPDY3);
+    FramedStream stream = connection.newStream(headerEntries("a", "android"), true, true);
     try {
       stream.getResponseHeaders();
       fail();
@@ -707,23 +711,22 @@
     assertEquals(2, ping.payload1);
   }
 
-
   @Test public void receiveGoAway() throws Exception {
     peer.setVariantAndClient(SPDY3, false);
 
     // write the mocking script
     peer.acceptFrame(); // SYN_STREAM 1
     peer.acceptFrame(); // SYN_STREAM 3
+    peer.acceptFrame(); // PING.
     peer.sendFrame().goAway(1, PROTOCOL_ERROR, Util.EMPTY_BYTE_ARRAY);
-    peer.acceptFrame(); // PING
     peer.sendFrame().ping(true, 1, 0);
     peer.acceptFrame(); // DATA STREAM 1
     peer.play();
 
     // play it back
-    SpdyConnection connection = connection(peer, SPDY3);
-    SpdyStream stream1 = connection.newStream(headerEntries("a", "android"), true, true);
-    SpdyStream stream2 = connection.newStream(headerEntries("b", "banana"), true, true);
+    FramedConnection connection = connection(peer, SPDY3);
+    FramedStream stream1 = connection.newStream(headerEntries("a", "android"), true, true);
+    FramedStream stream2 = connection.newStream(headerEntries("b", "banana"), true, true);
     connection.ping().roundTripTime(); // Ensure the GO_AWAY that resets stream2 has been received.
     BufferedSink sink1 = Okio.buffer(stream1.getSink());
     BufferedSink sink2 = Okio.buffer(stream2.getSink());
@@ -770,7 +773,7 @@
     peer.play();
 
     // play it back
-    SpdyConnection connection = connection(peer, SPDY3);
+    FramedConnection connection = connection(peer, SPDY3);
     connection.newStream(headerEntries("a", "android"), true, true);
     Ping ping = connection.ping();
     connection.shutdown(PROTOCOL_ERROR);
@@ -794,7 +797,7 @@
     peer.play();
 
     // play it back
-    SpdyConnection connection = connection(peer, SPDY3);
+    FramedConnection connection = connection(peer, SPDY3);
     connection.shutdown(INTERNAL_ERROR);
     try {
       connection.ping();
@@ -817,8 +820,8 @@
     peer.play();
 
     // play it back
-    SpdyConnection connection = connection(peer, SPDY3);
-    SpdyStream stream = connection.newStream(headerEntries("a", "android"), true, true);
+    FramedConnection connection = connection(peer, SPDY3);
+    FramedStream stream = connection.newStream(headerEntries("a", "android"), true, true);
     assertEquals(1, connection.openStreamCount());
     connection.close();
     assertEquals(0, connection.openStreamCount());
@@ -861,7 +864,7 @@
     peer.play();
 
     // play it back
-    SpdyConnection connection = connection(peer, SPDY3);
+    FramedConnection connection = connection(peer, SPDY3);
     Ping ping = connection.ping();
     connection.close();
     assertEquals(-1, ping.roundTripTime());
@@ -874,8 +877,8 @@
     peer.play();
 
     // play it back
-    SpdyConnection connection = connection(peer, SPDY3);
-    SpdyStream stream = connection.newStream(headerEntries("b", "banana"), true, true);
+    FramedConnection connection = connection(peer, SPDY3);
+    FramedStream stream = connection.newStream(headerEntries("b", "banana"), true, true);
     stream.readTimeout().timeout(500, TimeUnit.MILLISECONDS);
     long startNanos = System.nanoTime();
     try {
@@ -884,6 +887,7 @@
     } catch (InterruptedIOException expected) {
     }
     long elapsedNanos = System.nanoTime() - startNanos;
+    awaitWatchdogIdle();
     assertEquals(500d, TimeUnit.NANOSECONDS.toMillis(elapsedNanos), 200d /* 200ms delta */);
     assertEquals(0, connection.openStreamCount());
 
@@ -900,8 +904,8 @@
     peer.play();
 
     // play it back
-    SpdyConnection connection = connection(peer, SPDY3);
-    SpdyStream stream = connection.newStream(headerEntries("b", "banana"), true, true);
+    FramedConnection connection = connection(peer, SPDY3);
+    FramedStream stream = connection.newStream(headerEntries("b", "banana"), true, true);
     stream.readTimeout().timeout(500, TimeUnit.MILLISECONDS);
     Source source = stream.getSource();
     long startNanos = System.nanoTime();
@@ -911,6 +915,7 @@
     } catch (InterruptedIOException expected) {
     }
     long elapsedNanos = System.nanoTime() - startNanos;
+    awaitWatchdogIdle();
     assertEquals(500d, TimeUnit.NANOSECONDS.toMillis(elapsedNanos), 200d /* 200ms delta */);
     assertEquals(0, connection.openStreamCount());
 
@@ -934,19 +939,21 @@
     peer.play();
 
     // play it back
-    SpdyConnection connection = connection(peer, SPDY3);
+    FramedConnection connection = connection(peer, SPDY3);
     connection.ping().roundTripTime(); // Make sure settings have been received.
-    SpdyStream stream = connection.newStream(headerEntries("b", "banana"), true, true);
+    FramedStream stream = connection.newStream(headerEntries("b", "banana"), true, true);
     Sink sink = stream.getSink();
     sink.write(new Buffer().writeUtf8("abcde"), 5);
     stream.writeTimeout().timeout(500, TimeUnit.MILLISECONDS);
     long startNanos = System.nanoTime();
+    sink.write(new Buffer().writeUtf8("f"), 1);
     try {
-      sink.write(new Buffer().writeUtf8("f"), 1); // This will time out waiting on the write window.
+      sink.flush(); // This will time out waiting on the write window.
       fail();
     } catch (InterruptedIOException expected) {
     }
     long elapsedNanos = System.nanoTime() - startNanos;
+    awaitWatchdogIdle();
     assertEquals(500d, TimeUnit.NANOSECONDS.toMillis(elapsedNanos), 200d /* 200ms delta */);
     assertEquals(0, connection.openStreamCount());
 
@@ -957,6 +964,72 @@
     assertEquals(TYPE_RST_STREAM, peer.takeFrame().type);
   }
 
+  @Test public void writeTimesOutAwaitingConnectionWindow() throws Exception {
+    // Set the peer's receive window to 5 bytes. Give the stream 5 bytes back, so only the
+    // connection-level window is applicable.
+    Settings peerSettings = new Settings().set(Settings.INITIAL_WINDOW_SIZE, PERSIST_VALUE, 5);
+
+    // write the mocking script
+    peer.sendFrame().settings(peerSettings);
+    peer.acceptFrame(); // SYN_STREAM
+    peer.sendFrame().synReply(false, 1, headerEntries("a", "android"));
+    peer.sendFrame().windowUpdate(1, 5);
+    peer.acceptFrame(); // PING
+    peer.sendFrame().ping(true, 1, 0);
+    peer.acceptFrame(); // DATA
+    peer.acceptFrame(); // RST_STREAM
+    peer.play();
+
+    // play it back
+    FramedConnection connection = connection(peer, SPDY3);
+    FramedStream stream = connection.newStream(headerEntries("b", "banana"), true, true);
+    connection.ping().roundTripTime(); // Make sure the window update has been received.
+    Sink sink = stream.getSink();
+    stream.writeTimeout().timeout(500, TimeUnit.MILLISECONDS);
+    sink.write(new Buffer().writeUtf8("abcdef"), 6);
+    long startNanos = System.nanoTime();
+    try {
+      sink.flush(); // This will time out waiting on the write window.
+      fail();
+    } catch (InterruptedIOException expected) {
+    }
+    long elapsedNanos = System.nanoTime() - startNanos;
+    awaitWatchdogIdle();
+    assertEquals(500d, TimeUnit.NANOSECONDS.toMillis(elapsedNanos), 200d /* 200ms delta */);
+    assertEquals(0, connection.openStreamCount());
+
+    // verify the peer received what was expected
+    assertEquals(TYPE_HEADERS, peer.takeFrame().type);
+    assertEquals(TYPE_PING, peer.takeFrame().type);
+    assertEquals(TYPE_DATA, peer.takeFrame().type);
+    assertEquals(TYPE_RST_STREAM, peer.takeFrame().type);
+  }
+
+  @Test public void outgoingWritesAreBatched() throws Exception {
+    // write the mocking script
+    peer.acceptFrame(); // SYN_STREAM
+    peer.sendFrame().synReply(false, 1, headerEntries("a", "android"));
+    peer.acceptFrame(); // DATA
+    peer.play();
+
+    // play it back
+    FramedConnection connection = connection(peer, SPDY3);
+    FramedStream stream = connection.newStream(headerEntries("b", "banana"), true, true);
+
+    // two outgoing writes
+    Sink sink = stream.getSink();
+    sink.write(new Buffer().writeUtf8("abcde"), 5);
+    sink.write(new Buffer().writeUtf8("fghij"), 5);
+    sink.close();
+
+    // verify the peer received one incoming frame
+    assertEquals(TYPE_HEADERS, peer.takeFrame().type);
+    MockSpdyPeer.InFrame data = peer.takeFrame();
+    assertEquals(TYPE_DATA, data.type);
+    assertTrue(Arrays.equals("abcdefghij".getBytes("UTF-8"), data.data));
+    assertTrue(data.inFinished);
+  }
+
   @Test public void headers() throws Exception {
     // write the mocking script
     peer.acceptFrame(); // SYN_STREAM
@@ -967,8 +1040,8 @@
     peer.play();
 
     // play it back
-    SpdyConnection connection = connection(peer, SPDY3);
-    SpdyStream stream = connection.newStream(headerEntries("b", "banana"), true, true);
+    FramedConnection connection = connection(peer, SPDY3);
+    FramedStream stream = connection.newStream(headerEntries("b", "banana"), true, true);
     connection.ping().roundTripTime(); // Ensure that the HEADERS has been received.
     assertEquals(headerEntries("a", "android", "c", "c3po"), stream.getResponseHeaders());
 
@@ -990,8 +1063,8 @@
     peer.play();
 
     // play it back
-    SpdyConnection connection = connection(peer, SPDY3);
-    SpdyStream stream = connection.newStream(headerEntries("b", "banana"), true, true);
+    FramedConnection connection = connection(peer, SPDY3);
+    FramedStream stream = connection.newStream(headerEntries("b", "banana"), true, true);
     connection.ping().roundTripTime(); // Ensure that the HEADERS has been received.
     try {
       stream.getResponseHeaders();
@@ -1032,9 +1105,9 @@
     peer.play();
 
     // Play it back.
-    SpdyConnection connection = connection(peer, SPDY3);
+    FramedConnection connection = connection(peer, SPDY3);
     connection.okHttpSettings.set(Settings.INITIAL_WINDOW_SIZE, 0, windowSize);
-    SpdyStream stream = connection.newStream(headerEntries("b", "banana"), false, true);
+    FramedStream stream = connection.newStream(headerEntries("b", "banana"), false, true);
     assertEquals(0, stream.unacknowledgedBytesRead);
     assertEquals(headerEntries("a", "android"), stream.getResponseHeaders());
     Source in = stream.getSource();
@@ -1072,8 +1145,8 @@ private Buffer data(int byteCount) {
     peer.play();
 
     // Play it back.
-    SpdyConnection connection = connection(peer, SPDY3);
-    SpdyStream client = connection.newStream(headerEntries("b", "banana"), false, true);
+    FramedConnection connection = connection(peer, SPDY3);
+    FramedStream client = connection.newStream(headerEntries("b", "banana"), false, true);
     assertEquals(-1, client.getSource().read(new Buffer(), 1));
 
     // Verify the peer received what was expected.
@@ -1092,8 +1165,8 @@ private Buffer data(int byteCount) {
     peer.play();
 
     // Play it back.
-    SpdyConnection connection = connection(peer, SPDY3);
-    SpdyStream client = connection.newStream(headerEntries("b", "banana"), true, true);
+    FramedConnection connection = connection(peer, SPDY3);
+    FramedStream client = connection.newStream(headerEntries("b", "banana"), true, true);
     BufferedSink out = Okio.buffer(client.getSink());
     out.write(Util.EMPTY_BYTE_ARRAY);
     out.flush();
@@ -1114,8 +1187,8 @@ private Buffer data(int byteCount) {
     peer.play();
 
     // play it back
-    SpdyConnection connection = connection(peer, SPDY3);
-    SpdyStream stream = connection.newStream(headerEntries("b", "banana"), true, true);
+    FramedConnection connection = connection(peer, SPDY3);
+    FramedStream stream = connection.newStream(headerEntries("b", "banana"), true, true);
     assertEquals(headerEntries("a", "android"), stream.getResponseHeaders());
     Source in = stream.getSource();
     try {
@@ -1139,8 +1212,8 @@ private Buffer data(int byteCount) {
     peer.play();
 
     // Play it back.
-    SpdyConnection connection = connection(peer, SPDY3);
-    SpdyStream stream1 = connection.newStream(headerEntries("a", "apple"), true, true);
+    FramedConnection connection = connection(peer, SPDY3);
+    FramedStream stream1 = connection.newStream(headerEntries("a", "apple"), true, true);
     BufferedSink out1 = Okio.buffer(stream1.getSink());
     out1.write(new byte[DEFAULT_INITIAL_WINDOW_SIZE]);
     out1.flush();
@@ -1156,7 +1229,7 @@ private Buffer data(int byteCount) {
     assertEquals(0, connection.getStream(1).bytesLeftInWriteWindow);
 
     // Another stream should be able to send data even though 1 is blocked.
-    SpdyStream stream2 = connection.newStream(headerEntries("b", "banana"), true, true);
+    FramedStream stream2 = connection.newStream(headerEntries("b", "banana"), true, true);
     BufferedSink out2 = Okio.buffer(stream2.getSink());
     out2.writeUtf8("foo");
     out2.flush();
@@ -1229,20 +1302,48 @@ private void headerBlockHasTrailingCompressedBytes(String frame, int length) thr
     peer.play();
 
     // play it back
-    SpdyConnection connection = connection(peer, SPDY3);
-    SpdyStream stream = connection.newStream(headerEntries("b", "banana"), true, true);
+    FramedConnection connection = connection(peer, SPDY3);
+    FramedStream stream = connection.newStream(headerEntries("b", "banana"), true, true);
     assertEquals("a", stream.getResponseHeaders().get(0).name.utf8());
     assertEquals(length, stream.getResponseHeaders().get(0).value.size());
     assertStreamData("robot", stream.getSource());
   }
 
-  private SpdyConnection connection(MockSpdyPeer peer, Variant variant) throws IOException {
+  @Test public void socketExceptionWhileWritingHeaders() throws Exception {
+    peer.acceptFrame(); // SYN_STREAM.
+    peer.play();
+
+    String longString = ByteString.of(randomBytes(2048)).base64();
+    Socket socket = peer.openSocket();
+    FramedConnection connection = new FramedConnection.Builder(true, socket)
+        .protocol(SPDY3.getProtocol())
+        .build();
+    socket.shutdownOutput();
+    try {
+      connection.newStream(headerEntries("a", longString), false, true);
+      fail();
+    } catch (IOException expected) {
+    }
+    try {
+      connection.newStream(headerEntries("b", longString), false, true);
+      fail();
+    } catch (IOException expected) {
+    }
+  }
+
+  private byte[] randomBytes(int length) {
+    byte[] bytes = new byte[length];
+    new Random(0).nextBytes(bytes);
+    return bytes;
+  }
+
+  private FramedConnection connection(MockSpdyPeer peer, Variant variant) throws IOException {
     return connectionBuilder(peer, variant).build();
   }
 
-  private SpdyConnection.Builder connectionBuilder(MockSpdyPeer peer, Variant variant)
+  private FramedConnection.Builder connectionBuilder(MockSpdyPeer peer, Variant variant)
       throws IOException {
-    return new SpdyConnection.Builder(true, peer.openSocket())
+    return new FramedConnection.Builder(true, peer.openSocket())
         .protocol(variant.getProtocol());
   }
 
@@ -1251,15 +1352,6 @@ private void assertStreamData(String expected, Source source) throws IOException
     assertEquals(expected, actual);
   }
 
-  private void assertFlushBlocks(BufferedSink out) throws IOException {
-    interruptAfterDelay(500);
-    try {
-      out.flush();
-      fail();
-    } catch (InterruptedIOException expected) {
-    }
-  }
-
   /** Interrupts the current thread after {@code delayMillis}. */
   private void interruptAfterDelay(final long delayMillis) {
     final Thread toInterrupt = Thread.currentThread();
@@ -1275,6 +1367,23 @@ private void interruptAfterDelay(final long delayMillis) {
     }.start();
   }
 
+  /**
+   * Returns true when all work currently in progress by the watchdog have completed. This method
+   * creates more work for the watchdog and waits for that work to be executed. When it is, we know
+   * work that preceded this call is complete.
+   */
+  private void awaitWatchdogIdle() throws InterruptedException {
+    final CountDownLatch latch = new CountDownLatch(1);
+    AsyncTimeout watchdogJob = new AsyncTimeout() {
+      @Override protected void timedOut() {
+        latch.countDown();
+      }
+    };
+    watchdogJob.deadlineNanoTime(System.nanoTime()); // Due immediately!
+    watchdogJob.enter();
+    latch.await();
+  }
+
   static int roundUp(int num, int divisor) {
     return (num + divisor - 1) / divisor;
   }
diff --git a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/spdy/Spdy3Test.java b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/framed/Spdy3Test.java
similarity index 98%
rename from okhttp-tests/src/test/java/com/squareup/okhttp/internal/spdy/Spdy3Test.java
rename to okhttp-tests/src/test/java/com/squareup/okhttp/internal/framed/Spdy3Test.java
index c902773c9f..2627959fe0 100644
--- a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/spdy/Spdy3Test.java
+++ b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/framed/Spdy3Test.java
@@ -13,7 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.squareup.okhttp.internal.spdy;
+package com.squareup.okhttp.internal.framed;
 
 import com.squareup.okhttp.internal.Util;
 import java.io.IOException;
diff --git a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/CookiesTest.java b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/CookiesTest.java
index d0fa1b2421..043234ec33 100644
--- a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/CookiesTest.java
+++ b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/CookiesTest.java
@@ -195,11 +195,11 @@ public void testNetscapeResponse() throws Exception {
     HttpCookie cookieA = new HttpCookie("a", "android");
     cookieA.setDomain(server.getCookieDomain());
     cookieA.setPath("/");
-    cookieManager.getCookieStore().add(server.getUrl("/").toURI(), cookieA);
+    cookieManager.getCookieStore().add(server.url("/").uri(), cookieA);
     HttpCookie cookieB = new HttpCookie("b", "banana");
     cookieB.setDomain(server.getCookieDomain());
     cookieB.setPath("/");
-    cookieManager.getCookieStore().add(server.getUrl("/").toURI(), cookieB);
+    cookieManager.getCookieStore().add(server.url("/").uri(), cookieB);
     CookieHandler.setDefault(cookieManager);
 
     get(server, "/");
@@ -222,7 +222,7 @@ public void testNetscapeResponse() throws Exception {
     MockWebServer redirectSource = new MockWebServer();
     redirectSource.enqueue(new MockResponse()
         .setResponseCode(HttpURLConnection.HTTP_MOVED_TEMP)
-        .addHeader("Location: " + redirectTarget.getUrl("/")));
+        .addHeader("Location: " + redirectTarget.url("/")));
     redirectSource.start();
 
     CookieManager cookieManager = new CookieManager(null, ACCEPT_ORIGINAL_SERVER);
@@ -231,7 +231,7 @@ public void testNetscapeResponse() throws Exception {
     cookie.setPath("/");
     String portList = Integer.toString(redirectSource.getPort());
     cookie.setPortlist(portList);
-    cookieManager.getCookieStore().add(redirectSource.getUrl("/").toURI(), cookie);
+    cookieManager.getCookieStore().add(redirectSource.url("/").uri(), cookie);
     CookieHandler.setDefault(cookieManager);
 
     get(redirectSource, "/");
diff --git a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/DisconnectTest.java b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/DisconnectTest.java
index 7a70d03e34..d64badbefc 100644
--- a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/DisconnectTest.java
+++ b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/DisconnectTest.java
@@ -55,15 +55,18 @@
     server.setServerSocketFactory(
         new DelegatingServerSocketFactory(ServerSocketFactory.getDefault()) {
           @Override
-          protected void configureServerSocket(ServerSocket serverSocket) throws IOException {
+          protected ServerSocket configureServerSocket(ServerSocket serverSocket)
+              throws IOException {
             serverSocket.setReceiveBufferSize(SOCKET_BUFFER_SIZE);
+            return serverSocket;
           }
         });
     client.setSocketFactory(new DelegatingSocketFactory(SocketFactory.getDefault()) {
       @Override
-      protected void configureSocket(Socket socket) throws IOException {
+      protected Socket configureSocket(Socket socket) throws IOException {
         socket.setSendBufferSize(SOCKET_BUFFER_SIZE);
         socket.setReceiveBufferSize(SOCKET_BUFFER_SIZE);
+        return socket;
       }
     });
   }
diff --git a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/HeadersTest.java b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/HeadersTest.java
index 1d946228ae..1f5ad6d002 100644
--- a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/HeadersTest.java
+++ b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/HeadersTest.java
@@ -19,7 +19,7 @@
 import com.squareup.okhttp.Protocol;
 import com.squareup.okhttp.Request;
 import com.squareup.okhttp.Response;
-import com.squareup.okhttp.internal.spdy.Header;
+import com.squareup.okhttp.internal.framed.Header;
 import java.io.IOException;
 import java.util.Arrays;
 import java.util.Collections;
@@ -43,7 +43,7 @@
         ":version", "HTTP/1.1");
     Request request = new Request.Builder().url("http://square.com/").build();
     Response response =
-        SpdyTransport.readNameValueBlock(headerBlock, Protocol.SPDY_3).request(request).build();
+        FramedTransport.readNameValueBlock(headerBlock, Protocol.SPDY_3).request(request).build();
     Headers headers = response.headers();
     assertEquals(4, headers.size());
     assertEquals(Protocol.SPDY_3, response.protocol());
@@ -71,7 +71,7 @@
         "connection", "close");
     Request request = new Request.Builder().url("http://square.com/").build();
     Response response =
-        SpdyTransport.readNameValueBlock(headerBlock, Protocol.SPDY_3).request(request).build();
+        FramedTransport.readNameValueBlock(headerBlock, Protocol.SPDY_3).request(request).build();
     Headers headers = response.headers();
     assertEquals(1, headers.size());
     assertEquals(OkHeaders.SELECTED_PROTOCOL, headers.name(0));
@@ -84,7 +84,7 @@
         ":version", "HTTP/1.1",
         "connection", "close");
     Request request = new Request.Builder().url("http://square.com/").build();
-    Response response = SpdyTransport.readNameValueBlock(headerBlock, Protocol.HTTP_2)
+    Response response = FramedTransport.readNameValueBlock(headerBlock, Protocol.HTTP_2)
         .request(request).build();
     Headers headers = response.headers();
     assertEquals(1, headers.size());
@@ -101,7 +101,7 @@
         .header(":status", "200 OK")
         .build();
     List<Header> headerBlock =
-        SpdyTransport.writeNameValueBlock(request, Protocol.SPDY_3, "HTTP/1.1");
+        FramedTransport.writeNameValueBlock(request, Protocol.SPDY_3, "HTTP/1.1");
     List<Header> expected = headerEntries(
         ":method", "GET",
         ":path", "/",
@@ -126,7 +126,7 @@
         ":version", "HTTP/1.1",
         ":host", "square.com",
         ":scheme", "http");
-    assertEquals(expected, SpdyTransport.writeNameValueBlock(request, Protocol.SPDY_3, "HTTP/1.1"));
+    assertEquals(expected, FramedTransport.writeNameValueBlock(request, Protocol.SPDY_3, "HTTP/1.1"));
   }
 
   @Test public void toNameValueBlockDropsForbiddenHeadersHttp2() {
@@ -141,7 +141,7 @@
         ":authority", "square.com",
         ":scheme", "http");
     assertEquals(expected,
-        SpdyTransport.writeNameValueBlock(request, Protocol.HTTP_2, "HTTP/1.1"));
+        FramedTransport.writeNameValueBlock(request, Protocol.HTTP_2, "HTTP/1.1"));
   }
 
   @Test public void ofTrims() {
@@ -302,4 +302,14 @@
     } catch (IllegalArgumentException expected) {
     }
   }
+
+  @Test public void toMultimapGroupsHeaders() {
+    Headers headers = Headers.of(
+        "cache-control", "no-cache",
+        "cache-control", "no-store",
+        "user-agent", "OkHttp");
+    Map<String, List<String>> headerMap = headers.toMultimap();
+    assertEquals(2, headerMap.get("cache-control").size());
+    assertEquals(1, headerMap.get("user-agent").size());
+  }
 }
diff --git a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/HttpOverHttp20Draft16Test.java b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/HttpOverHttp2Test.java
similarity index 96%
rename from okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/HttpOverHttp20Draft16Test.java
rename to okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/HttpOverHttp2Test.java
index 7659110e9c..91ba56cef3 100644
--- a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/HttpOverHttp20Draft16Test.java
+++ b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/HttpOverHttp2Test.java
@@ -24,9 +24,9 @@
 
 import static org.junit.Assert.assertEquals;
 
-public class HttpOverHttp20Draft16Test extends HttpOverSpdyTest {
+public class HttpOverHttp2Test extends HttpOverSpdyTest {
 
-  public HttpOverHttp20Draft16Test() {
+  public HttpOverHttp2Test() {
     super(Protocol.HTTP_2);
     this.hostHeader = ":authority";
   }
diff --git a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/HttpOverSpdyTest.java b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/HttpOverSpdyTest.java
index ab8f3c97cc..2d52eee13d 100644
--- a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/HttpOverSpdyTest.java
+++ b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/HttpOverSpdyTest.java
@@ -17,6 +17,7 @@
 
 import com.squareup.okhttp.Cache;
 import com.squareup.okhttp.ConnectionPool;
+import com.squareup.okhttp.HttpUrl;
 import com.squareup.okhttp.OkHttpClient;
 import com.squareup.okhttp.OkUrlFactory;
 import com.squareup.okhttp.Protocol;
@@ -24,15 +25,16 @@
 import com.squareup.okhttp.internal.SslContextBuilder;
 import com.squareup.okhttp.internal.Util;
 import com.squareup.okhttp.mockwebserver.MockResponse;
+import com.squareup.okhttp.mockwebserver.MockWebServer;
 import com.squareup.okhttp.mockwebserver.RecordedRequest;
 import com.squareup.okhttp.mockwebserver.SocketPolicy;
-import com.squareup.okhttp.mockwebserver.rule.MockWebServerRule;
+import com.squareup.okhttp.testing.RecordingHostnameVerifier;
 import java.io.IOException;
 import java.io.InputStream;
 import java.net.Authenticator;
 import java.net.CookieManager;
 import java.net.HttpURLConnection;
-import java.net.URL;
+import java.net.SocketTimeoutException;
 import java.util.Arrays;
 import java.util.Collections;
 import java.util.List;
@@ -43,7 +45,6 @@
 import java.util.concurrent.TimeUnit;
 import javax.net.ssl.HostnameVerifier;
 import javax.net.ssl.SSLContext;
-import javax.net.ssl.SSLSession;
 import okio.Buffer;
 import okio.BufferedSink;
 import okio.GzipSink;
@@ -63,21 +64,15 @@
 
 /** Test how SPDY interacts with HTTP features. */
 public abstract class HttpOverSpdyTest {
-  private static final SSLContext sslContext = SslContextBuilder.localhost();
-
-  private static final HostnameVerifier NULL_HOSTNAME_VERIFIER = new HostnameVerifier() {
-    public boolean verify(String hostname, SSLSession session) {
-      return true;
-    }
-  };
-
   @Rule public final TemporaryFolder tempDir = new TemporaryFolder();
-  @Rule public final MockWebServerRule server = new MockWebServerRule();
+  @Rule public final MockWebServer server = new MockWebServer();
 
   /** Protocol to test, for example {@link com.squareup.okhttp.Protocol#SPDY_3} */
   private final Protocol protocol;
   protected String hostHeader = ":host";
 
+  protected SSLContext sslContext = SslContextBuilder.localhost();
+  protected HostnameVerifier hostnameVerifier = new RecordingHostnameVerifier();
   protected final OkUrlFactory client = new OkUrlFactory(new OkHttpClient());
   protected HttpURLConnection connection;
   protected Cache cache;
@@ -87,10 +82,10 @@ protected HttpOverSpdyTest(Protocol protocol){
   }
 
   @Before public void setUp() throws Exception {
-    server.get().useHttps(sslContext.getSocketFactory(), false);
+    server.useHttps(sslContext.getSocketFactory(), false);
     client.client().setProtocols(Arrays.asList(protocol, Protocol.HTTP_1_1));
     client.client().setSslSocketFactory(sslContext.getSocketFactory());
-    client.client().setHostnameVerifier(NULL_HOSTNAME_VERIFIER);
+    client.client().setHostnameVerifier(hostnameVerifier);
     cache = new Cache(tempDir.getRoot(), Integer.MAX_VALUE);
   }
 
@@ -159,8 +154,8 @@ protected HttpOverSpdyTest(Protocol protocol){
     connection.setRequestProperty("Content-Length", String.valueOf(postBytes.length));
     connection.setDoOutput(true);
     connection.getOutputStream().write(postBytes); // push bytes into SpdyDataOutputStream.buffer
-    connection.getOutputStream().flush(); // SpdyConnection.writeData subject to write window
-    connection.getOutputStream().close(); // SpdyConnection.writeData empty frame
+    connection.getOutputStream().flush(); // FramedConnection.writeData subject to write window
+    connection.getOutputStream().close(); // FramedConnection.writeData empty frame
     assertContent("ABCDE", connection, Integer.MAX_VALUE);
 
     RecordedRequest request = server.takeRequest();
@@ -307,8 +302,8 @@ protected HttpOverSpdyTest(Protocol protocol){
     try {
       readAscii(connection.getInputStream(), Integer.MAX_VALUE);
       fail("Should have timed out!");
-    } catch (IOException e){
-      assertEquals("timeout", e.getMessage());
+    } catch (SocketTimeoutException expected) {
+      assertEquals("timeout", expected.getMessage());
     }
   }
 
@@ -380,18 +375,18 @@ protected HttpOverSpdyTest(Protocol protocol){
     client.client().setCookieHandler(cookieManager);
 
     server.enqueue(new MockResponse()
-        .addHeader("set-cookie: c=oreo; domain=" + server.get().getCookieDomain())
+        .addHeader("set-cookie: c=oreo; domain=" + server.getCookieDomain())
         .setBody("A"));
     server.enqueue(new MockResponse()
         .setBody("B"));
 
-    URL url = server.getUrl("/");
-    assertContent("A", client.open(url), Integer.MAX_VALUE);
+    HttpUrl url = server.url("/");
+    assertContent("A", client.open(url.url()), Integer.MAX_VALUE);
     Map<String, List<String>> requestHeaders = Collections.emptyMap();
     assertEquals(Collections.singletonMap("Cookie", Arrays.asList("c=oreo")),
-        cookieManager.get(url.toURI(), requestHeaders));
+        cookieManager.get(url.uri(), requestHeaders));
 
-    assertContent("B", client.open(url), Integer.MAX_VALUE);
+    assertContent("B", client.open(url.url()), Integer.MAX_VALUE);
     RecordedRequest requestA = server.takeRequest();
     assertNull(requestA.getHeader("Cookie"));
     RecordedRequest requestB = server.takeRequest();
diff --git a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/RouteExceptionTest.java b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/RouteExceptionTest.java
new file mode 100644
index 0000000000..eeb95642cf
--- /dev/null
+++ b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/RouteExceptionTest.java
@@ -0,0 +1,48 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.okhttp.internal.http;
+
+import org.junit.Test;
+
+import java.io.IOException;
+
+import static org.junit.Assert.assertSame;
+
+public class RouteExceptionTest {
+
+  @Test public void getConnectionIOException_single() {
+    IOException firstException = new IOException();
+    RouteException re = new RouteException(firstException);
+    assertSame(firstException, re.getLastConnectException());
+  }
+
+  @Test public void getConnectionIOException_multiple() {
+    IOException firstException = new IOException();
+    IOException secondException = new IOException();
+    IOException thirdException = new IOException();
+    RouteException re = new RouteException(firstException);
+    re.addConnectException(secondException);
+    re.addConnectException(thirdException);
+
+    IOException connectionIOException = re.getLastConnectException();
+    assertSame(thirdException, connectionIOException);
+    Throwable[] thirdSuppressedExceptions = thirdException.getSuppressed();
+    assertSame(secondException, thirdSuppressedExceptions[0]);
+
+    Throwable[] secondSuppressedException = secondException.getSuppressed();
+    assertSame(firstException, secondSuppressedException[0]);
+  }
+}
diff --git a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/RouteSelectorTest.java b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/RouteSelectorTest.java
index 8efd308f76..bb8d0821a6 100644
--- a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/RouteSelectorTest.java
+++ b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/RouteSelectorTest.java
@@ -28,7 +28,6 @@
 import com.squareup.okhttp.internal.RouteDatabase;
 import com.squareup.okhttp.internal.SslContextBuilder;
 import com.squareup.okhttp.internal.Util;
-import java.io.IOException;
 import java.net.InetAddress;
 import java.net.InetSocketAddress;
 import java.net.Proxy;
@@ -41,7 +40,6 @@
 import javax.net.ssl.HostnameVerifier;
 import javax.net.ssl.HttpsURLConnection;
 import javax.net.ssl.SSLContext;
-import javax.net.ssl.SSLHandshakeException;
 import javax.net.ssl.SSLSocketFactory;
 import org.junit.Before;
 import org.junit.Test;
@@ -114,8 +112,7 @@
 
     assertTrue(routeSelector.hasNext());
     dns.inetAddresses = makeFakeAddresses(255, 1);
-    assertRoute(routeSelector.next(), address, NO_PROXY, dns.inetAddresses[0],
-        uriPort, ConnectionSpec.CLEARTEXT);
+    assertRoute(routeSelector.next(), address, NO_PROXY, dns.inetAddresses[0], uriPort);
     dns.assertRequests(uriHost);
 
     assertFalse(routeSelector.hasNext());
@@ -135,8 +132,7 @@
     Route route = routeSelector.next();
     routeDatabase.failed(route);
     routeSelector = RouteSelector.get(address, httpRequest, client);
-    assertRoute(routeSelector.next(), address, NO_PROXY, dns.inetAddresses[0],
-        uriPort, ConnectionSpec.CLEARTEXT);
+    assertRoute(routeSelector.next(), address, NO_PROXY, dns.inetAddresses[0], uriPort);
     assertFalse(routeSelector.hasNext());
     try {
       routeSelector.next();
@@ -153,10 +149,8 @@
 
     assertTrue(routeSelector.hasNext());
     dns.inetAddresses = makeFakeAddresses(255, 2);
-    assertRoute(routeSelector.next(), address, proxyA, dns.inetAddresses[0],
-        proxyAPort, ConnectionSpec.CLEARTEXT);
-    assertRoute(routeSelector.next(), address, proxyA, dns.inetAddresses[1],
-        proxyAPort, ConnectionSpec.CLEARTEXT);
+    assertRoute(routeSelector.next(), address, proxyA, dns.inetAddresses[0], proxyAPort);
+    assertRoute(routeSelector.next(), address, proxyA, dns.inetAddresses[1], proxyAPort);
 
     assertFalse(routeSelector.hasNext());
     dns.assertRequests(proxyAHost);
@@ -171,10 +165,8 @@
 
     assertTrue(routeSelector.hasNext());
     dns.inetAddresses = makeFakeAddresses(255, 2);
-    assertRoute(routeSelector.next(), address, NO_PROXY, dns.inetAddresses[0],
-        uriPort, ConnectionSpec.CLEARTEXT);
-    assertRoute(routeSelector.next(), address, NO_PROXY, dns.inetAddresses[1],
-        uriPort, ConnectionSpec.CLEARTEXT);
+    assertRoute(routeSelector.next(), address, NO_PROXY, dns.inetAddresses[0], uriPort);
+    assertRoute(routeSelector.next(), address, NO_PROXY, dns.inetAddresses[1], uriPort);
 
     assertFalse(routeSelector.hasNext());
     dns.assertRequests(uriHost);
@@ -190,8 +182,7 @@
 
     assertTrue(routeSelector.hasNext());
     dns.inetAddresses = makeFakeAddresses(255, 1);
-    assertRoute(routeSelector.next(), address, NO_PROXY, dns.inetAddresses[0],
-        uriPort, ConnectionSpec.CLEARTEXT);
+    assertRoute(routeSelector.next(), address, NO_PROXY, dns.inetAddresses[0], uriPort);
     dns.assertRequests(uriHost);
 
     assertFalse(routeSelector.hasNext());
@@ -203,10 +194,8 @@
 
     assertTrue(routeSelector.hasNext());
     dns.inetAddresses = makeFakeAddresses(255, 2);
-    assertRoute(routeSelector.next(), address, NO_PROXY, dns.inetAddresses[0],
-        uriPort, ConnectionSpec.CLEARTEXT);
-    assertRoute(routeSelector.next(), address, NO_PROXY, dns.inetAddresses[1],
-        uriPort, ConnectionSpec.CLEARTEXT);
+    assertRoute(routeSelector.next(), address, NO_PROXY, dns.inetAddresses[0], uriPort);
+    assertRoute(routeSelector.next(), address, NO_PROXY, dns.inetAddresses[1], uriPort);
 
     assertFalse(routeSelector.hasNext());
     dns.assertRequests(uriHost);
@@ -224,25 +213,20 @@
     // First try the IP addresses of the first proxy, in sequence.
     assertTrue(routeSelector.hasNext());
     dns.inetAddresses = makeFakeAddresses(255, 2);
-    assertRoute(routeSelector.next(), address, proxyA, dns.inetAddresses[0], proxyAPort,
-        ConnectionSpec.CLEARTEXT);
-    assertRoute(routeSelector.next(), address, proxyA, dns.inetAddresses[1], proxyAPort,
-        ConnectionSpec.CLEARTEXT);
+    assertRoute(routeSelector.next(), address, proxyA, dns.inetAddresses[0], proxyAPort);
+    assertRoute(routeSelector.next(), address, proxyA, dns.inetAddresses[1], proxyAPort);
     dns.assertRequests(proxyAHost);
 
     // Next try the IP address of the second proxy.
     assertTrue(routeSelector.hasNext());
     dns.inetAddresses = makeFakeAddresses(254, 1);
-    assertRoute(routeSelector.next(), address, proxyB, dns.inetAddresses[0],
-        proxyBPort,
-        ConnectionSpec.CLEARTEXT);
+    assertRoute(routeSelector.next(), address, proxyB, dns.inetAddresses[0], proxyBPort);
     dns.assertRequests(proxyBHost);
 
     // Finally try the only IP address of the origin server.
     assertTrue(routeSelector.hasNext());
     dns.inetAddresses = makeFakeAddresses(253, 1);
-    assertRoute(routeSelector.next(), address, NO_PROXY, dns.inetAddresses[0], uriPort,
-        ConnectionSpec.CLEARTEXT);
+    assertRoute(routeSelector.next(), address, NO_PROXY, dns.inetAddresses[0], uriPort);
     dns.assertRequests(uriHost);
 
     assertFalse(routeSelector.hasNext());
@@ -258,8 +242,7 @@
     // Only the origin server will be attempted.
     assertTrue(routeSelector.hasNext());
     dns.inetAddresses = makeFakeAddresses(255, 1);
-    assertRoute(routeSelector.next(), address, NO_PROXY, dns.inetAddresses[0], uriPort,
-        ConnectionSpec.CLEARTEXT);
+    assertRoute(routeSelector.next(), address, NO_PROXY, dns.inetAddresses[0], uriPort);
     dns.assertRequests(uriHost);
 
     assertFalse(routeSelector.hasNext());
@@ -276,8 +259,7 @@
 
     assertTrue(routeSelector.hasNext());
     dns.inetAddresses = makeFakeAddresses(255, 1);
-    assertRoute(routeSelector.next(), address, proxyA, dns.inetAddresses[0],
-        proxyAPort, ConnectionSpec.CLEARTEXT);
+    assertRoute(routeSelector.next(), address, proxyA, dns.inetAddresses[0], proxyAPort);
     dns.assertRequests(proxyAHost);
 
     assertTrue(routeSelector.hasNext());
@@ -291,44 +273,17 @@
 
     assertTrue(routeSelector.hasNext());
     dns.inetAddresses = makeFakeAddresses(255, 1);
-    assertRoute(routeSelector.next(), address, proxyA, dns.inetAddresses[0],
-        proxyAPort, ConnectionSpec.CLEARTEXT);
+    assertRoute(routeSelector.next(), address, proxyA, dns.inetAddresses[0], proxyAPort);
     dns.assertRequests(proxyAHost);
 
     assertTrue(routeSelector.hasNext());
     dns.inetAddresses = makeFakeAddresses(254, 1);
-    assertRoute(routeSelector.next(), address, NO_PROXY, dns.inetAddresses[0],
-        uriPort, ConnectionSpec.CLEARTEXT);
+    assertRoute(routeSelector.next(), address, NO_PROXY, dns.inetAddresses[0], uriPort);
     dns.assertRequests(uriHost);
 
     assertFalse(routeSelector.hasNext());
   }
 
-  // https://github.com/square/okhttp/issues/442
-  @Test public void nonSslErrorAddsAllTlsModesToFailedRoute() throws Exception {
-    Address address = httpsAddress();
-    client.setProxy(Proxy.NO_PROXY);
-    RouteSelector routeSelector = RouteSelector.get(address, httpsRequest, client);
-
-    dns.inetAddresses = makeFakeAddresses(255, 1);
-    Route route = routeSelector.next();
-    routeSelector.connectFailed(route, new IOException("Non SSL exception"));
-    assertEquals(2, routeDatabase.failedRoutesCount());
-    assertFalse(routeSelector.hasNext());
-  }
-
-  @Test public void sslErrorAddsOnlyFailedConfigurationToFailedRoute() throws Exception {
-    Address address = httpsAddress();
-    client.setProxy(Proxy.NO_PROXY);
-    RouteSelector routeSelector = RouteSelector.get(address, httpsRequest, client);
-
-    dns.inetAddresses = makeFakeAddresses(255, 1);
-    Route route = routeSelector.next();
-    routeSelector.connectFailed(route, new SSLHandshakeException("SSL exception"));
-    assertTrue(routeDatabase.failedRoutesCount() == 1);
-    assertTrue(routeSelector.hasNext());
-  }
-
   @Test public void multipleProxiesMultipleInetAddressesMultipleConfigurations() throws Exception {
     Address address = httpsAddress();
     proxySelector.proxies.add(proxyA);
@@ -337,39 +292,21 @@
 
     // Proxy A
     dns.inetAddresses = makeFakeAddresses(255, 2);
-    assertRoute(routeSelector.next(), address, proxyA, dns.inetAddresses[0],
-        proxyAPort, ConnectionSpec.MODERN_TLS);
+    assertRoute(routeSelector.next(), address, proxyA, dns.inetAddresses[0], proxyAPort);
     dns.assertRequests(proxyAHost);
-    assertRoute(routeSelector.next(), address, proxyA, dns.inetAddresses[0],
-        proxyAPort, ConnectionSpec.COMPATIBLE_TLS);
-    assertRoute(routeSelector.next(), address, proxyA, dns.inetAddresses[1],
-        proxyAPort, ConnectionSpec.MODERN_TLS);
-    assertRoute(routeSelector.next(), address, proxyA, dns.inetAddresses[1],
-        proxyAPort, ConnectionSpec.COMPATIBLE_TLS);
+    assertRoute(routeSelector.next(), address, proxyA, dns.inetAddresses[1], proxyAPort);
 
     // Proxy B
     dns.inetAddresses = makeFakeAddresses(254, 2);
-    assertRoute(routeSelector.next(), address, proxyB, dns.inetAddresses[0],
-        proxyBPort, ConnectionSpec.MODERN_TLS);
+    assertRoute(routeSelector.next(), address, proxyB, dns.inetAddresses[0], proxyBPort);
     dns.assertRequests(proxyBHost);
-    assertRoute(routeSelector.next(), address, proxyB, dns.inetAddresses[0],
-        proxyBPort, ConnectionSpec.COMPATIBLE_TLS);
-    assertRoute(routeSelector.next(), address, proxyB, dns.inetAddresses[1],
-        proxyBPort, ConnectionSpec.MODERN_TLS);
-    assertRoute(routeSelector.next(), address, proxyB, dns.inetAddresses[1],
-        proxyBPort, ConnectionSpec.COMPATIBLE_TLS);
+    assertRoute(routeSelector.next(), address, proxyB, dns.inetAddresses[1], proxyBPort);
 
     // Origin
     dns.inetAddresses = makeFakeAddresses(253, 2);
-    assertRoute(routeSelector.next(), address, NO_PROXY, dns.inetAddresses[0],
-        uriPort, ConnectionSpec.MODERN_TLS);
+    assertRoute(routeSelector.next(), address, NO_PROXY, dns.inetAddresses[0], uriPort);
     dns.assertRequests(uriHost);
-    assertRoute(routeSelector.next(), address, NO_PROXY, dns.inetAddresses[0],
-        uriPort, ConnectionSpec.COMPATIBLE_TLS);
-    assertRoute(routeSelector.next(), address, NO_PROXY, dns.inetAddresses[1],
-        uriPort, ConnectionSpec.MODERN_TLS);
-    assertRoute(routeSelector.next(), address, NO_PROXY, dns.inetAddresses[1],
-        uriPort, ConnectionSpec.COMPATIBLE_TLS);
+    assertRoute(routeSelector.next(), address, NO_PROXY, dns.inetAddresses[1], uriPort);
 
     assertFalse(routeSelector.hasNext());
   }
@@ -379,7 +316,8 @@
     client.setProxy(Proxy.NO_PROXY);
     RouteSelector routeSelector = RouteSelector.get(address, httpsRequest, client);
 
-    dns.inetAddresses = makeFakeAddresses(255, 1);
+    final int numberOfAddresses = 2;
+    dns.inetAddresses = makeFakeAddresses(255, numberOfAddresses);
 
     // Extract the regular sequence of routes from selector.
     List<Route> regularRoutes = new ArrayList<>();
@@ -388,7 +326,7 @@
     }
 
     // Check that we do indeed have more than one route.
-    assertTrue(regularRoutes.size() > 1);
+    assertEquals(numberOfAddresses, regularRoutes.size());
     // Add first regular route as failed.
     routeDatabase.failed(regularRoutes.get(0));
     // Reset selector
@@ -422,13 +360,12 @@
     assertEquals("127.0.0.1", RouteSelector.getHostString(socketAddress));
   }
 
-  private void assertRoute(Route route, Address address, Proxy proxy,
-      InetAddress socketAddress, int socketPort, ConnectionSpec connectionSpec) {
+  private void assertRoute(Route route, Address address, Proxy proxy, InetAddress socketAddress,
+      int socketPort) {
     assertEquals(address, route.getAddress());
     assertEquals(proxy, route.getProxy());
     assertEquals(socketAddress, route.getSocketAddress().getAddress());
     assertEquals(socketPort, route.getSocketAddress().getPort());
-    assertEquals(connectionSpec, route.getConnectionSpec());
   }
 
   /** Returns an address that's without an SSL socket factory or hostname verifier. */
diff --git a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/ThreadInterruptTest.java b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/ThreadInterruptTest.java
index 63f55e1f18..a7e6007a20 100644
--- a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/ThreadInterruptTest.java
+++ b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/ThreadInterruptTest.java
@@ -57,15 +57,18 @@
     server.setServerSocketFactory(
         new DelegatingServerSocketFactory(ServerSocketFactory.getDefault()) {
           @Override
-          protected void configureServerSocket(ServerSocket serverSocket) throws IOException {
+          protected ServerSocket configureServerSocket(ServerSocket serverSocket)
+              throws IOException {
             serverSocket.setReceiveBufferSize(SOCKET_BUFFER_SIZE);
+            return serverSocket;
           }
         });
     client.setSocketFactory(new DelegatingSocketFactory(SocketFactory.getDefault()) {
       @Override
-      protected void configureSocket(Socket socket) throws IOException {
+      protected Socket configureSocket(Socket socket) throws IOException {
         socket.setSendBufferSize(SOCKET_BUFFER_SIZE);
         socket.setReceiveBufferSize(SOCKET_BUFFER_SIZE);
+        return socket;
       }
     });
   }
diff --git a/okhttp-tests/src/test/resources/web-platform-test-urltestdata.txt b/okhttp-tests/src/test/resources/web-platform-test-urltestdata.txt
new file mode 100644
index 0000000000..87c4f67135
--- /dev/null
+++ b/okhttp-tests/src/test/resources/web-platform-test-urltestdata.txt
@@ -0,0 +1,342 @@
+# FORMAT NOT DOCUMENTED YET (parser is urltestparser.js)
+
+# Based on http://trac.webkit.org/browser/trunk/LayoutTests/fast/url/script-tests/segments.js
+http://example\t.\norg http://example.org/foo/bar s:http h:example.org p:/
+http://user:pass@foo:21/bar;par?b#c  s:http u:user pass:pass h:foo port:21 p:/bar;par q:?b f:#c
+http:foo.com  s:http h:example.org p:/foo/foo.com
+\t\s\s\s:foo.com\s\s\s\n  s:http h:example.org p:/foo/:foo.com
+\sfoo.com\s\s  s:http h:example.org p:/foo/foo.com
+a:\t\sfoo.com  s:a p:\sfoo.com
+http://f:21/\sb\s?\sd\s#\se\s  s:http h:f port:21 p:/%20b%20 q:?%20d%20 f:#\se
+http://f:/c  s:http h:f p:/c
+http://f:0/c  s:http h:f port:0 p:/c
+http://f:00000000000000/c  s:http h:f port:0 p:/c
+http://f:00000000000000000000080/c  s:http h:f p:/c
+http://f:b/c
+http://f:\s/c
+http://f:\n/c  s:http h:f p:/c
+http://f:fifty-two/c
+http://f:999999/c  s:http h:f port:999999 p:/c
+http://f:\s21\s/\sb\s?\sd\s#\se\s
+  s:http h:example.org p:/foo/bar
+\s\s\t  s:http h:example.org p:/foo/bar
+:foo.com/  s:http h:example.org p:/foo/:foo.com/
+:foo.com\\  s:http h:example.org p:/foo/:foo.com/
+:  s:http h:example.org p:/foo/:
+:a  s:http h:example.org p:/foo/:a
+:/  s:http h:example.org p:/foo/:/
+:\\  s:http h:example.org p:/foo/:/
+:#  s:http h:example.org p:/foo/: f:#
+\#  s:http h:example.org p:/foo/bar f:#
+\#/  s:http h:example.org p:/foo/bar f:#/
+\#\\  s:http h:example.org p:/foo/bar f:#\\
+\#;?  s:http h:example.org p:/foo/bar f:#;?
+?  s:http h:example.org p:/foo/bar q:?
+/  s:http h:example.org p:/
+:23  s:http h:example.org p:/foo/:23
+/:23  s:http h:example.org p:/:23
+::  s:http h:example.org p:/foo/::
+::23  s:http h:example.org p:/foo/::23
+foo://  s:foo p://
+http://a:b@c:29/d  s:http u:a pass:b h:c port:29 p:/d
+http::@c:29  s:http h:example.org p:/foo/:@c:29
+http://&a:foo(b]c@d:2/  s:http u:&a pass:foo(b]c h:d port:2 p:/
+http://::@c@d:2  s:http pass::%40c h:d port:2 p:/
+http://foo.com:b@d/  s:http u:foo.com pass:b h:d p:/
+http://foo.com/\\@  s:http h:foo.com p://@
+http:\\\\foo.com\\  s:http h:foo.com p:/
+http:\\\\a\\b:c\\d@foo.com\\  s:http h:a p:/b:c/d@foo.com/
+foo:/  s:foo p:/
+foo:/bar.com/  s:foo p:/bar.com/
+foo://///////  s:foo p://///////
+foo://///////bar.com/  s:foo p://///////bar.com/
+foo:////://///  s:foo p:////://///
+c:/foo  s:c p:/foo
+//foo/bar  s:http h:foo p:/bar
+http://foo/path;a??e#f#g  s:http h:foo p:/path;a q:??e f:#f#g
+http://foo/abcd?efgh?ijkl  s:http h:foo p:/abcd q:?efgh?ijkl
+http://foo/abcd#foo?bar  s:http h:foo p:/abcd f:#foo?bar
+[61:24:74]:98  s:http h:example.org p:/foo/[61:24:74]:98
+http:[61:27]/:foo  s:http h:example.org p:/foo/[61:27]/:foo
+http://[1::2]:3:4
+http://2001::1
+http://2001::1]
+http://2001::1]:80
+http://[2001::1]  s:http h:[2001::1] p:/
+http://[2001::1]:80  s:http h:[2001::1] p:/
+http:/example.com/  s:http h:example.org p:/example.com/
+ftp:/example.com/  s:ftp h:example.com p:/
+https:/example.com/  s:https h:example.com p:/
+madeupscheme:/example.com/  s:madeupscheme p:/example.com/
+file:/example.com/  s:file p:/example.com/
+ftps:/example.com/  s:ftps p:/example.com/
+gopher:/example.com/  s:gopher h:example.com p:/
+ws:/example.com/  s:ws h:example.com p:/
+wss:/example.com/  s:wss h:example.com p:/
+data:/example.com/  s:data p:/example.com/
+javascript:/example.com/  s:javascript p:/example.com/
+mailto:/example.com/  s:mailto p:/example.com/
+http:example.com/  s:http h:example.org p:/foo/example.com/
+ftp:example.com/  s:ftp h:example.com p:/
+https:example.com/  s:https h:example.com p:/
+madeupscheme:example.com/  s:madeupscheme p:example.com/
+ftps:example.com/  s:ftps p:example.com/
+gopher:example.com/  s:gopher h:example.com p:/
+ws:example.com/  s:ws h:example.com p:/
+wss:example.com/  s:wss h:example.com p:/
+data:example.com/  s:data p:example.com/
+javascript:example.com/  s:javascript p:example.com/
+mailto:example.com/  s:mailto p:example.com/
+/a/b/c  s:http h:example.org p:/a/b/c
+/a/\s/c  s:http h:example.org p:/a/%20/c
+/a%2fc  s:http h:example.org p:/a%2fc
+/a/%2f/c  s:http h:example.org p:/a/%2f/c
+\#\u03B2  s:http h:example.org p:/foo/bar f:#\u03B2
+data:text/html,test#test  s:data p:text/html,test f:#test
+
+# Based on http://trac.webkit.org/browser/trunk/LayoutTests/fast/url/file.html
+
+# Basic canonicalization, uppercase should be converted to lowercase
+file:c:\\foo\\bar.html file:///tmp/mock/path s:file p:/c:/foo/bar.html
+
+# Spaces should fail
+\s\sFile:c|////foo\\bar.html  s:file p:/c:////foo/bar.html
+
+# This should fail
+C|/foo/bar  s:file p:/C:/foo/bar
+
+# This should fail
+/C|\\foo\\bar  s:file p:/C:/foo/bar
+//C|/foo/bar  s:file p:/C:/foo/bar
+//server/file  s:file h:server p:/file
+\\\\server\\file  s:file h:server p:/file
+/\\server/file  s:file h:server p:/file
+file:///foo/bar.txt  s:file p:/foo/bar.txt
+file:///home/me  s:file p:/home/me
+//  s:file p:/
+///  s:file p:/
+///test  s:file p:/test
+file://test  s:file h:test p:/
+file://localhost  s:file h:localhost p:/
+file://localhost/  s:file h:localhost p:/
+file://localhost/test  s:file h:localhost p:/test
+test  s:file p:/tmp/mock/test
+file:test  s:file p:/tmp/mock/test
+
+# Based on http://trac.webkit.org/browser/trunk/LayoutTests/fast/url/script-tests/path.js
+http://example.com/././foo about:blank s:http h:example.com p:/foo
+http://example.com/./.foo  s:http h:example.com p:/.foo
+http://example.com/foo/.  s:http h:example.com p:/foo/
+http://example.com/foo/./  s:http h:example.com p:/foo/
+http://example.com/foo/bar/..  s:http h:example.com p:/foo/
+http://example.com/foo/bar/../  s:http h:example.com p:/foo/
+http://example.com/foo/..bar  s:http h:example.com p:/foo/..bar
+http://example.com/foo/bar/../ton  s:http h:example.com p:/foo/ton
+http://example.com/foo/bar/../ton/../../a  s:http h:example.com p:/a
+http://example.com/foo/../../..  s:http h:example.com p:/
+http://example.com/foo/../../../ton  s:http h:example.com p:/ton
+http://example.com/foo/%2e  s:http h:example.com p:/foo/
+http://example.com/foo/%2e%2  s:http h:example.com p:/foo/%2e%2
+http://example.com/foo/%2e./%2e%2e/.%2e/%2e.bar  s:http h:example.com p:/%2e.bar
+http://example.com////../..  s:http h:example.com p://
+http://example.com/foo/bar//../..  s:http h:example.com p:/foo/
+http://example.com/foo/bar//..  s:http h:example.com p:/foo/bar/
+http://example.com/foo  s:http h:example.com p:/foo
+http://example.com/%20foo  s:http h:example.com p:/%20foo
+http://example.com/foo%  s:http h:example.com p:/foo%
+http://example.com/foo%2  s:http h:example.com p:/foo%2
+http://example.com/foo%2zbar  s:http h:example.com p:/foo%2zbar
+http://example.com/foo%2\u00C2\u00A9zbar  s:http h:example.com p:/foo%2%C3%82%C2%A9zbar
+http://example.com/foo%41%7a  s:http h:example.com p:/foo%41%7a
+http://example.com/foo\t\u0091%91  s:http h:example.com p:/foo%C2%91%91
+http://example.com/foo%00%51  s:http h:example.com p:/foo%00%51
+http://example.com/(%28:%3A%29)  s:http h:example.com p:/(%28:%3A%29)
+http://example.com/%3A%3a%3C%3c  s:http h:example.com p:/%3A%3a%3C%3c
+http://example.com/foo\tbar  s:http h:example.com p:/foobar
+http://example.com\\\\foo\\\\bar  s:http h:example.com p://foo//bar
+http://example.com/%7Ffp3%3Eju%3Dduvgw%3Dd  s:http h:example.com p:/%7Ffp3%3Eju%3Dduvgw%3Dd
+http://example.com/@asdf%40  s:http h:example.com p:/@asdf%40
+http://example.com/\u4F60\u597D\u4F60\u597D  s:http h:example.com p:/%E4%BD%A0%E5%A5%BD%E4%BD%A0%E5%A5%BD
+http://example.com/\u2025/foo  s:http h:example.com p:/%E2%80%A5/foo
+http://example.com/\uFEFF/foo  s:http h:example.com p:/%EF%BB%BF/foo
+http://example.com/\u202E/foo/\u202D/bar  s:http h:example.com p:/%E2%80%AE/foo/%E2%80%AD/bar
+
+# Based on http://trac.webkit.org/browser/trunk/LayoutTests/fast/url/script-tests/relative.js
+http://www.google.com/foo?bar=baz# about:blank s:http h:www.google.com p:/foo q:?bar=baz f:#
+http://www.google.com/foo?bar=baz#\s\u00BB  s:http h:www.google.com p:/foo q:?bar=baz f:#\s\u00BB
+data:test#\s\u00BB  s:data p:test f:#\s\u00BB
+http://[www.google.com]/
+http://www.google.com  s:http h:www.google.com p:/
+http://192.0x00A80001  s:http h:192.168.0.1 p:/
+http://www/foo%2Ehtml  s:http h:www p:/foo%2Ehtml
+http://www/foo/%2E/html  s:http h:www p:/foo/html
+http://user:pass@/
+http://%25DOMAIN:foobar@foodomain.com/  s:http u:%25DOMAIN pass:foobar h:foodomain.com p:/
+http:\\\\www.google.com\\foo  s:http h:www.google.com p:/foo
+http://foo:80/  s:http h:foo p:/
+http://foo:81/  s:http h:foo port:81 p:/
+httpa://foo:80/  s:httpa p://foo:80/
+http://foo:-80/
+https://foo:443/  s:https h:foo p:/
+https://foo:80/  s:https h:foo port:80 p:/
+ftp://foo:21/  s:ftp h:foo p:/
+ftp://foo:80/  s:ftp h:foo port:80 p:/
+gopher://foo:70/  s:gopher h:foo p:/
+gopher://foo:443/  s:gopher h:foo port:443 p:/
+ws://foo:80/  s:ws h:foo p:/
+ws://foo:81/  s:ws h:foo port:81 p:/
+ws://foo:443/  s:ws h:foo port:443 p:/
+ws://foo:815/  s:ws h:foo port:815 p:/
+wss://foo:80/  s:wss h:foo port:80 p:/
+wss://foo:81/  s:wss h:foo port:81 p:/
+wss://foo:443/  s:wss h:foo p:/
+wss://foo:815/  s:wss h:foo port:815 p:/
+http:/example.com/  s:http h:example.com p:/
+ftp:/example.com/  s:ftp h:example.com p:/
+https:/example.com/  s:https h:example.com p:/
+madeupscheme:/example.com/  s:madeupscheme p:/example.com/
+file:/example.com/  s:file p:/example.com/
+ftps:/example.com/  s:ftps p:/example.com/
+gopher:/example.com/  s:gopher h:example.com p:/
+ws:/example.com/  s:ws h:example.com p:/
+wss:/example.com/  s:wss h:example.com p:/
+data:/example.com/  s:data p:/example.com/
+javascript:/example.com/  s:javascript p:/example.com/
+mailto:/example.com/  s:mailto p:/example.com/
+http:example.com/  s:http h:example.com p:/
+ftp:example.com/  s:ftp h:example.com p:/
+https:example.com/  s:https h:example.com p:/
+madeupscheme:example.com/  s:madeupscheme p:example.com/
+ftps:example.com/  s:ftps p:example.com/
+gopher:example.com/  s:gopher h:example.com p:/
+ws:example.com/  s:ws h:example.com p:/
+wss:example.com/  s:wss h:example.com p:/
+data:example.com/  s:data p:example.com/
+javascript:example.com/  s:javascript p:example.com/
+mailto:example.com/  s:mailto p:example.com/
+
+# Based on http://trac.webkit.org/browser/trunk/LayoutTests/fast/url/segments-userinfo-vs-host.html
+http:@www.example.com about:blank s:http h:www.example.com p:/
+http:/@www.example.com  s:http h:www.example.com p:/
+http://@www.example.com  s:http h:www.example.com p:/
+http:a:b@www.example.com  s:http u:a pass:b h:www.example.com p:/
+http:/a:b@www.example.com  s:http u:a pass:b h:www.example.com p:/
+http://a:b@www.example.com  s:http u:a pass:b h:www.example.com p:/
+http://@pple.com  s:http h:pple.com p:/
+http::b@www.example.com  s:http pass:b h:www.example.com p:/
+http:/:b@www.example.com  s:http pass:b h:www.example.com p:/
+http://:b@www.example.com  s:http pass:b h:www.example.com p:/
+http:/:@/www.example.com
+http://user@/www.example.com
+http:@/www.example.com
+http:/@/www.example.com
+http://@/www.example.com
+https:@/www.example.com
+http:a:b@/www.example.com
+http:/a:b@/www.example.com
+http://a:b@/www.example.com
+http::@/www.example.com
+http:a:@www.example.com  s:http u:a pass: h:www.example.com p:/
+http:/a:@www.example.com  s:http u:a pass: h:www.example.com p:/
+http://a:@www.example.com  s:http u:a pass: h:www.example.com p:/
+http://www.@pple.com  s:http u:www. h:pple.com p:/
+http:@:www.example.com
+http:/@:www.example.com
+http://@:www.example.com
+http://:@www.example.com  s:http pass: h:www.example.com p:/
+
+#Others
+/ http://www.example.com/test s:http h:www.example.com p:/
+/test.txt  s:http h:www.example.com p:/test.txt
+.  s:http h:www.example.com p:/
+..  s:http h:www.example.com p:/
+test.txt  s:http h:www.example.com p:/test.txt
+./test.txt  s:http h:www.example.com p:/test.txt
+../test.txt  s:http h:www.example.com p:/test.txt
+../aaa/test.txt  s:http h:www.example.com p:/aaa/test.txt
+../../test.txt  s:http h:www.example.com p:/test.txt
+\u4E2D/test.txt  s:http h:www.example.com p:/%E4%B8%AD/test.txt
+http://www.example2.com  s:http h:www.example2.com p:/
+//www.example2.com  s:http h:www.example2.com p:/
+
+# Based on http://trac.webkit.org/browser/trunk/LayoutTests/fast/url/host.html
+
+# Basic canonicalization, uppercase should be converted to lowercase
+http://ExAmPlE.CoM http://other.com/ s:http p:/ h:example.com
+
+# Spaces should fail
+http://example\sexample.com
+
+# This should fail
+http://Goo%20\sgoo%7C|.com
+
+# U+3000 is mapped to U+0020 (space) which is disallowed
+http://GOO\u00a0\u3000goo.com
+
+# Other types of space (no-break, zero-width, zero-width-no-break) are
+# name-prepped away to nothing.
+# U+200B, U+2060, and U+FEFF, are ignored
+http://GOO\u200b\u2060\ufeffgoo.com  s:http p:/ h:googoo.com
+
+# Ideographic full stop (full-width period for Chinese, etc.) should be
+# treated as a dot.
+# U+3002 is mapped to U+002E (dot)
+http://www.foo\u3002bar.com  s:http p:/ h:www.foo.bar.com
+
+# Invalid unicode characters should fail...
+# U+FDD0 is disallowed; %ef%b7%90 is U+FDD0
+http://\ufdd0zyx.com
+
+# ...This is the same as previous but escaped.
+http://%ef%b7%90zyx.com
+
+# Test name prepping, fullwidth input should be converted to ASCII and NOT
+# IDN-ized. This is "Go" in fullwidth UTF-8/UTF-16.
+http://\uff27\uff4f.com  s:http p:/ h:go.com
+
+# URL spec forbids the following.
+# https://www.w3.org/Bugs/Public/show_bug.cgi?id=24257
+http://\uff05\uff14\uff11.com
+http://%ef%bc%85%ef%bc%94%ef%bc%91.com
+
+# ...%00 in fullwidth should fail (also as escaped UTF-8 input)
+http://\uff05\uff10\uff10.com
+http://%ef%bc%85%ef%bc%90%ef%bc%90.com
+
+# Basic IDN support, UTF-8 and UTF-16 input should be converted to IDN
+http://\u4f60\u597d\u4f60\u597d  s:http p:/ h:xn--6qqa088eba
+
+# Invalid escaped characters should fail and the percents should be
+# escaped. https://www.w3.org/Bugs/Public/show_bug.cgi?id=24191
+http://%zz%66%a.com
+
+# If we get an invalid character that has been escaped.
+http://%25
+http://hello%00
+
+# Escaped numbers should be treated like IP addresses if they are.
+# No special handling for IPv4 or IPv4-like URLs
+http://%30%78%63%30%2e%30%32%35%30.01  s:http p:/ h:192.168.0.1
+http://%30%78%63%30%2e%30%32%35%30.01%2e  s:http p:/ h:0xc0.0250.01.
+http://192.168.0.257
+
+# Invalid escaping should trigger the regular host error handling.
+http://%3g%78%63%30%2e%30%32%35%30%2E.01
+
+# Something that isn't exactly an IP should get treated as a host and
+# spaces escaped.
+http://192.168.0.1\shello
+
+# Fullwidth and escaped UTF-8 fullwidth should still be treated as IP.
+# These are "0Xc0.0250.01" in fullwidth.
+http://\uff10\uff38\uff43\uff10\uff0e\uff10\uff12\uff15\uff10\uff0e\uff10\uff11  s:http p:/ h:192.168.0.1
+
+# Broken IPv6
+http://[google.com]
+
+# Misc Unicode
+http://foo:\uD83D\uDCA9@example.com/bar  s:http h:example.com p:/bar u:foo pass:%F0%9F%92%A9
+
+# resolving a relative reference against an unknown scheme results in an error
+x test:test
+
diff --git a/okhttp-urlconnection/pom.xml b/okhttp-urlconnection/pom.xml
index 790f596bb7..be60560ad7 100644
--- a/okhttp-urlconnection/pom.xml
+++ b/okhttp-urlconnection/pom.xml
@@ -6,7 +6,7 @@
   <parent>
     <groupId>com.squareup.okhttp</groupId>
     <artifactId>parent</artifactId>
-    <version>2.3.0-SNAPSHOT</version>
+    <version>2.6.0-SNAPSHOT</version>
   </parent>
 
   <artifactId>okhttp-urlconnection</artifactId>
@@ -18,6 +18,12 @@
       <artifactId>okhttp</artifactId>
       <version>${project.version}</version>
     </dependency>
+    <dependency>
+      <groupId>com.squareup.okhttp</groupId>
+      <artifactId>okhttp-testing-support</artifactId>
+      <version>${project.version}</version>
+      <scope>test</scope>
+    </dependency>
 
     <dependency>
       <groupId>junit</groupId>
diff --git a/okhttp-urlconnection/src/main/java/com/squareup/okhttp/internal/huc/HttpURLConnectionImpl.java b/okhttp-urlconnection/src/main/java/com/squareup/okhttp/internal/huc/HttpURLConnectionImpl.java
index 04ac55206c..1cddd3ecb2 100644
--- a/okhttp-urlconnection/src/main/java/com/squareup/okhttp/internal/huc/HttpURLConnectionImpl.java
+++ b/okhttp-urlconnection/src/main/java/com/squareup/okhttp/internal/huc/HttpURLConnectionImpl.java
@@ -20,19 +20,24 @@
 import com.squareup.okhttp.Connection;
 import com.squareup.okhttp.Handshake;
 import com.squareup.okhttp.Headers;
+import com.squareup.okhttp.HttpUrl;
 import com.squareup.okhttp.OkHttpClient;
 import com.squareup.okhttp.Protocol;
 import com.squareup.okhttp.Request;
+import com.squareup.okhttp.RequestBody;
 import com.squareup.okhttp.Response;
 import com.squareup.okhttp.Route;
 import com.squareup.okhttp.internal.Internal;
 import com.squareup.okhttp.internal.Platform;
 import com.squareup.okhttp.internal.Util;
+import com.squareup.okhttp.internal.Version;
 import com.squareup.okhttp.internal.http.HttpDate;
 import com.squareup.okhttp.internal.http.HttpEngine;
 import com.squareup.okhttp.internal.http.HttpMethod;
 import com.squareup.okhttp.internal.http.OkHeaders;
+import com.squareup.okhttp.internal.http.RequestException;
 import com.squareup.okhttp.internal.http.RetryableSink;
+import com.squareup.okhttp.internal.http.RouteException;
 import com.squareup.okhttp.internal.http.StatusLine;
 import java.io.FileNotFoundException;
 import java.io.IOException;
@@ -41,10 +46,12 @@
 import java.net.HttpRetryException;
 import java.net.HttpURLConnection;
 import java.net.InetSocketAddress;
+import java.net.MalformedURLException;
 import java.net.ProtocolException;
 import java.net.Proxy;
 import java.net.SocketPermission;
 import java.net.URL;
+import java.net.UnknownHostException;
 import java.security.Permission;
 import java.util.ArrayList;
 import java.util.Arrays;
@@ -73,6 +80,7 @@
 public class HttpURLConnectionImpl extends HttpURLConnection {
   private static final Set<String> METHODS = new LinkedHashSet<>(
       Arrays.asList("OPTIONS", "GET", "HEAD", "POST", "PUT", "DELETE", "TRACE", "PATCH"));
+  private static final RequestBody EMPTY_REQUEST_BODY = RequestBody.create(null, new byte[0]);
 
   final OkHttpClient client;
 
@@ -251,8 +259,11 @@ private static String responseSourceHeader(Response response) {
   }
 
   @Override public final Permission getPermission() throws IOException {
-    String hostName = getURL().getHost();
-    int hostPort = Util.getEffectivePort(getURL());
+    URL url = getURL();
+    String hostName = url.getHost();
+    int hostPort = url.getPort() != -1
+        ? url.getPort()
+        : HttpUrl.defaultPort(url.getProtocol());
     if (usingProxy()) {
       InetSocketAddress proxyAddress = (InetSocketAddress) client.getProxy().address();
       hostName = proxyAddress.getHostName();
@@ -312,11 +323,17 @@ private void initHttpEngine() throws IOException {
     }
   }
 
-  private HttpEngine newHttpEngine(String method, Connection connection,
-      RetryableSink requestBody, Response priorResponse) {
+  private HttpEngine newHttpEngine(String method, Connection connection, RetryableSink requestBody,
+      Response priorResponse) throws MalformedURLException, UnknownHostException {
+    // OkHttp's Call API requires a placeholder body; the real body will be streamed separately.
+    RequestBody placeholderBody = HttpMethod.requiresRequestBody(method)
+        ? EMPTY_REQUEST_BODY
+        : null;
+    URL url = getURL();
+    HttpUrl httpUrl = Internal.instance.getHttpUrlChecked(url.toString());
     Request.Builder builder = new Request.Builder()
-        .url(getURL())
-        .method(method, null /* No body; that's passed separately. */);
+        .url(httpUrl)
+        .method(method, placeholderBody);
     Headers headers = requestHeaders.build();
     for (int i = 0, size = headers.size(); i < size; i++) {
       builder.addHeader(headers.name(i), headers.value(i));
@@ -357,7 +374,7 @@ private HttpEngine newHttpEngine(String method, Connection connection,
 
   private String defaultUserAgent() {
     String agent = System.getProperty("http.agent");
-    return agent != null ? agent : ("Java" + System.getProperty("java.version"));
+    return agent != null ? Util.toHumanReadableAscii(agent) : Version.userAgent();
   }
 
   /**
@@ -405,7 +422,7 @@ private HttpEngine getResponse() throws IOException {
         throw new HttpRetryException("Cannot retry streamed HTTP body", responseCode);
       }
 
-      if (!httpEngine.sameConnection(followUp.url())) {
+      if (!httpEngine.sameConnection(followUp.httpUrl())) {
         httpEngine.releaseConnection();
       }
 
@@ -432,7 +449,25 @@ private boolean execute(boolean readResponse) throws IOException {
       }
 
       return true;
+    } catch (RequestException e) {
+      // An attempt to interpret a request failed.
+      IOException toThrow = e.getCause();
+      httpEngineFailure = toThrow;
+      throw toThrow;
+    } catch (RouteException e) {
+      // The attempt to connect via a route failed. The request will not have been sent.
+      HttpEngine retryEngine = httpEngine.recover(e);
+      if (retryEngine != null) {
+        httpEngine = retryEngine;
+        return false;
+      }
+
+      // Give up; recovery is not possible.
+      IOException toThrow = e.getLastConnectException();
+      httpEngineFailure = toThrow;
+      throw toThrow;
     } catch (IOException e) {
+      // An attempt to communicate with a server failed. The request may have been sent.
       HttpEngine retryEngine = httpEngine.recover(e);
       if (retryEngine != null) {
         httpEngine = retryEngine;
diff --git a/okhttp-urlconnection/src/test/java/com/squareup/okhttp/OkUrlFactoryTest.java b/okhttp-urlconnection/src/test/java/com/squareup/okhttp/OkUrlFactoryTest.java
index a7dc44b0d0..ab792b9906 100644
--- a/okhttp-urlconnection/src/test/java/com/squareup/okhttp/OkUrlFactoryTest.java
+++ b/okhttp-urlconnection/src/test/java/com/squareup/okhttp/OkUrlFactoryTest.java
@@ -1,9 +1,11 @@
 package com.squareup.okhttp;
 
 import com.squareup.okhttp.internal.Platform;
+import com.squareup.okhttp.internal.io.FileSystem;
+import com.squareup.okhttp.internal.io.InMemoryFileSystem;
 import com.squareup.okhttp.mockwebserver.MockResponse;
 import com.squareup.okhttp.mockwebserver.MockWebServer;
-import com.squareup.okhttp.mockwebserver.rule.MockWebServerRule;
+import java.io.File;
 import java.io.IOException;
 import java.net.HttpURLConnection;
 import java.text.DateFormat;
@@ -15,7 +17,6 @@
 import org.junit.Before;
 import org.junit.Rule;
 import org.junit.Test;
-import org.junit.rules.TemporaryFolder;
 
 import static java.nio.charset.StandardCharsets.US_ASCII;
 import static okio.Okio.buffer;
@@ -24,17 +25,14 @@
 import static org.junit.Assert.fail;
 
 public class OkUrlFactoryTest {
-  @Rule public MockWebServerRule serverRule = new MockWebServerRule();
-  @Rule public TemporaryFolder cacheFolder = new TemporaryFolder();
+  @Rule public MockWebServer server = new MockWebServer();
 
-  private MockWebServer server;
+  private FileSystem fileSystem = new InMemoryFileSystem();
   private OkUrlFactory factory;
 
   @Before public void setUp() throws IOException {
-    server = serverRule.get();
-
     OkHttpClient client = new OkHttpClient();
-    client.setCache(new Cache(cacheFolder.getRoot(), 10 * 1024 * 1024));
+    client.setCache(new Cache(new File("/cache/"), 10 * 1024 * 1024, fileSystem));
     factory = new OkUrlFactory(client);
   }
 
diff --git a/okhttp-urlconnection/src/test/java/com/squareup/okhttp/UrlConnectionCacheTest.java b/okhttp-urlconnection/src/test/java/com/squareup/okhttp/UrlConnectionCacheTest.java
index c46fd07169..0af815b14e 100644
--- a/okhttp-urlconnection/src/test/java/com/squareup/okhttp/UrlConnectionCacheTest.java
+++ b/okhttp-urlconnection/src/test/java/com/squareup/okhttp/UrlConnectionCacheTest.java
@@ -19,24 +19,11 @@
 import com.squareup.okhttp.internal.Internal;
 import com.squareup.okhttp.internal.SslContextBuilder;
 import com.squareup.okhttp.internal.Util;
+import com.squareup.okhttp.internal.io.FileSystem;
+import com.squareup.okhttp.internal.io.InMemoryFileSystem;
 import com.squareup.okhttp.mockwebserver.MockResponse;
 import com.squareup.okhttp.mockwebserver.MockWebServer;
 import com.squareup.okhttp.mockwebserver.RecordedRequest;
-import com.squareup.okhttp.mockwebserver.rule.MockWebServerRule;
-import okio.Buffer;
-import okio.BufferedSink;
-import okio.GzipSink;
-import okio.Okio;
-import org.junit.After;
-import org.junit.Before;
-import org.junit.Rule;
-import org.junit.Test;
-import org.junit.rules.TemporaryFolder;
-
-import javax.net.ssl.HostnameVerifier;
-import javax.net.ssl.HttpsURLConnection;
-import javax.net.ssl.SSLContext;
-import javax.net.ssl.SSLSession;
 import java.io.BufferedReader;
 import java.io.File;
 import java.io.FileNotFoundException;
@@ -62,6 +49,18 @@
 import java.util.Locale;
 import java.util.TimeZone;
 import java.util.concurrent.TimeUnit;
+import javax.net.ssl.HostnameVerifier;
+import javax.net.ssl.HttpsURLConnection;
+import javax.net.ssl.SSLContext;
+import javax.net.ssl.SSLSession;
+import okio.Buffer;
+import okio.BufferedSink;
+import okio.GzipSink;
+import okio.Okio;
+import org.junit.After;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
 
 import static com.squareup.okhttp.mockwebserver.SocketPolicy.DISCONNECT_AT_END;
 import static org.junit.Assert.assertEquals;
@@ -80,23 +79,18 @@
     }
   };
 
-  private static final SSLContext sslContext = SslContextBuilder.localhost();
-
-  @Rule public TemporaryFolder cacheRule = new TemporaryFolder();
-  @Rule public MockWebServerRule serverRule = new MockWebServerRule();
-  @Rule public MockWebServerRule server2Rule = new MockWebServerRule();
+  @Rule public MockWebServer server = new MockWebServer();
+  @Rule public MockWebServer server2 = new MockWebServer();
 
+  private final SSLContext sslContext = SslContextBuilder.localhost();
+  private final FileSystem fileSystem = new InMemoryFileSystem();
   private final OkUrlFactory client = new OkUrlFactory(new OkHttpClient());
-  private MockWebServer server;
-  private MockWebServer server2;
   private Cache cache;
   private final CookieManager cookieManager = new CookieManager();
 
   @Before public void setUp() throws Exception {
-    server = serverRule.get();
     server.setProtocolNegotiationEnabled(false);
-    server2 = server2Rule.get();
-    cache = new Cache(cacheRule.getRoot(), Integer.MAX_VALUE);
+    cache = new Cache(new File("/cache/"), Integer.MAX_VALUE, fileSystem);
     client.client().setCache(cache);
     CookieHandler.setDefault(cookieManager);
   }
@@ -717,7 +711,7 @@ private void testMethodInvalidates(String requestMethod) throws Exception {
             .addHeader("Last-Modified: " + lastModifiedDate)
             .addHeader("Expires: " + formatDate(-1, TimeUnit.HOURS)));
     assertEquals("v1", conditionalRequest.getHeader("If-None-Match"));
-    assertEquals(lastModifiedDate, conditionalRequest.getHeader("If-Modified-Since"));
+    assertNull(conditionalRequest.getHeader("If-Modified-Since"));
   }
 
   @Test public void etagAndExpirationDateInTheFuture() throws Exception {
@@ -1645,7 +1639,7 @@ public void assertCookies(URL url, String... expectedCookies) throws Exception {
     writeFile(cache.getDirectory(), urlKey + ".0", entryMetadata);
     writeFile(cache.getDirectory(), urlKey + ".1", entryBody);
     writeFile(cache.getDirectory(), "journal", journalBody);
-    cache = new Cache(cache.getDirectory(), Integer.MAX_VALUE);
+    cache = new Cache(cache.getDirectory(), Integer.MAX_VALUE, fileSystem);
     client.client().setCache(cache);
 
     HttpURLConnection connection = client.open(url);
@@ -1655,7 +1649,7 @@ public void assertCookies(URL url, String... expectedCookies) throws Exception {
   }
 
   private void writeFile(File directory, String file, String content) throws IOException {
-    BufferedSink sink = Okio.buffer(Okio.sink(new File(directory, file)));
+    BufferedSink sink = Okio.buffer(fileSystem.sink(new File(directory, file)));
     sink.writeUtf8(content);
     sink.close();
   }
diff --git a/okhttp-ws-tests/pom.xml b/okhttp-ws-tests/pom.xml
new file mode 100644
index 0000000000..c7d1778e6e
--- /dev/null
+++ b/okhttp-ws-tests/pom.xml
@@ -0,0 +1,53 @@
+<?xml version="1.0" encoding="UTF-8"?>
+
+<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
+  <modelVersion>4.0.0</modelVersion>
+
+  <parent>
+    <groupId>com.squareup.okhttp</groupId>
+    <artifactId>parent</artifactId>
+    <version>2.6.0-SNAPSHOT</version>
+  </parent>
+
+  <artifactId>okhttp-ws-tests</artifactId>
+  <name>OkHttp Web Socket Tests</name>
+
+  <dependencies>
+    <dependency>
+      <groupId>com.squareup.okhttp</groupId>
+      <artifactId>okhttp-testing-support</artifactId>
+      <version>${project.version}</version>
+      <scope>test</scope>
+    </dependency>
+    <dependency>
+      <groupId>com.squareup.okhttp</groupId>
+      <artifactId>okhttp-ws</artifactId>
+      <version>${project.version}</version>
+    </dependency>
+
+    <dependency>
+      <groupId>junit</groupId>
+      <artifactId>junit</artifactId>
+      <scope>test</scope>
+    </dependency>
+    <dependency>
+      <groupId>com.squareup.okhttp</groupId>
+      <artifactId>mockwebserver</artifactId>
+      <version>${project.version}</version>
+      <scope>test</scope>
+    </dependency>
+  </dependencies>
+
+  <build>
+    <plugins>
+      <!-- Do not deploy this as an artifact to Maven central. -->
+      <plugin>
+        <groupId>org.apache.maven.plugins</groupId>
+        <artifactId>maven-deploy-plugin</artifactId>
+        <configuration>
+          <skip>true</skip>
+        </configuration>
+      </plugin>
+    </plugins>
+  </build>
+</project>
diff --git a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/ws/RealWebSocketTest.java b/okhttp-ws-tests/src/test/java/com/squareup/okhttp/internal/ws/RealWebSocketTest.java
similarity index 75%
rename from okhttp-tests/src/test/java/com/squareup/okhttp/internal/ws/RealWebSocketTest.java
rename to okhttp-ws-tests/src/test/java/com/squareup/okhttp/internal/ws/RealWebSocketTest.java
index 7e7f05a2c8..241376d073 100644
--- a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/ws/RealWebSocketTest.java
+++ b/okhttp-ws-tests/src/test/java/com/squareup/okhttp/internal/ws/RealWebSocketTest.java
@@ -15,9 +15,14 @@
  */
 package com.squareup.okhttp.internal.ws;
 
+import com.squareup.okhttp.ws.WebSocketRecorder;
 import java.io.IOException;
 import java.net.ProtocolException;
 import java.util.Random;
+import java.util.concurrent.CountDownLatch;
+import java.util.concurrent.Executor;
+import java.util.concurrent.Executors;
+import java.util.concurrent.TimeUnit;
 import okio.Buffer;
 import okio.BufferedSink;
 import okio.ByteString;
@@ -25,38 +30,45 @@
 import org.junit.Before;
 import org.junit.Test;
 
-import static com.squareup.okhttp.internal.ws.WebSocket.PayloadType.BINARY;
-import static com.squareup.okhttp.internal.ws.WebSocket.PayloadType.TEXT;
+import static com.squareup.okhttp.ws.WebSocket.PayloadType.BINARY;
+import static com.squareup.okhttp.ws.WebSocket.PayloadType.TEXT;
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertFalse;
 import static org.junit.Assert.assertTrue;
 import static org.junit.Assert.fail;
 
 public final class RealWebSocketTest {
-  // NOTE: Types are named 'client' and 'server' for cognitive simplicity. This differentiation has
+  // NOTE: Fields are named 'client' and 'server' for cognitive simplicity. This differentiation has
   // zero effect on the behavior of the WebSocket API which is why tests are only written once
   // from the perspective of a single peer.
 
+  private final Executor clientExecutor = Executors.newSingleThreadExecutor();
   private RealWebSocket client;
+  private boolean clientConnectionCloseThrows;
   private boolean clientConnectionClosed;
   private final Buffer client2Server = new Buffer();
   private final WebSocketRecorder clientListener = new WebSocketRecorder();
 
+  private final Executor serverExecutor = Executors.newSingleThreadExecutor();
   private RealWebSocket server;
   private final Buffer server2client = new Buffer();
   private final WebSocketRecorder serverListener = new WebSocketRecorder();
 
   @Before public void setUp() {
     Random random = new Random(0);
+    String url = "http://example.com/websocket";
 
-    client = new RealWebSocket(true, server2client, client2Server, random, clientListener,
-        "http://example.com/websocket") {
+    client = new RealWebSocket(true, server2client, client2Server, random, clientExecutor,
+        clientListener, url) {
       @Override protected void closeConnection() throws IOException {
         clientConnectionClosed = true;
+        if (clientConnectionCloseThrows) {
+          throw new IOException("Oops!");
+        }
       }
     };
-    server = new RealWebSocket(false, client2Server, server2client, random, serverListener,
-        "http://example.com/websocket") {
+    server = new RealWebSocket(false, client2Server, server2client, random, serverExecutor,
+        serverListener, url) {
       @Override protected void closeConnection() throws IOException {
       }
     };
@@ -96,16 +108,16 @@
     sink.close();
     server.readMessage();
     serverListener.assertTextMessage("Hello!");
-    Thread.sleep(1000); // Wait for pong to be written.
+    waitForExecutor(serverExecutor); // Pong write happens asynchronously.
     client.readMessage();
     clientListener.assertPong(new Buffer().writeUtf8("Pong?"));
   }
 
   @Test public void pingWritesPong() throws IOException, InterruptedException {
     client.sendPing(new Buffer().writeUtf8("Hello!"));
-    server.readMessage(); // Read the ping, enqueue the pong.
-    Thread.sleep(1000); // Wait for pong to be written.
-    client.readMessage();
+    server.readMessage(); // Read the ping, write the pong.
+    waitForExecutor(serverExecutor); // Pong write happens asynchronously.
+    client.readMessage(); // Read the pong.
     clientListener.assertPong(new Buffer().writeUtf8("Hello!"));
   }
 
@@ -117,9 +129,9 @@
 
   @Test public void close() throws IOException {
     client.close(1000, "Hello!");
-    server.readMessage(); // This will trigger a close response.
+    assertFalse(server.readMessage()); // This will trigger a close response.
     serverListener.assertClose(1000, "Hello!");
-    client.readMessage();
+    assertFalse(client.readMessage());
     clientListener.assertClose(1000, "Hello!");
   }
 
@@ -130,25 +142,25 @@
       client.sendPing(new Buffer().writeUtf8("Pong?"));
       fail();
     } catch (IllegalStateException e) {
-      assertEquals("Closed", e.getMessage());
+      assertEquals("closed", e.getMessage());
     }
     try {
       client.close(1000, "Hello!");
       fail();
     } catch (IllegalStateException e) {
-      assertEquals("Closed", e.getMessage());
+      assertEquals("closed", e.getMessage());
     }
     try {
       client.sendMessage(TEXT, new Buffer().writeUtf8("Hello!"));
       fail();
     } catch (IllegalStateException e) {
-      assertEquals("Closed", e.getMessage());
+      assertEquals("closed", e.getMessage());
     }
     try {
       client.newMessageSink(TEXT);
       fail();
     } catch (IllegalStateException e) {
-      assertEquals("Closed", e.getMessage());
+      assertEquals("closed", e.getMessage());
     }
   }
 
@@ -161,19 +173,19 @@
       client.sendPing(new Buffer().writeUtf8("Pong?"));
       fail();
     } catch (IOException e) {
-      assertEquals("Closed", e.getMessage());
+      assertEquals("closed", e.getMessage());
     }
     try {
       client.sendMessage(TEXT, new Buffer().writeUtf8("Hi!"));
       fail();
     } catch (IOException e) {
-      assertEquals("Closed", e.getMessage());
+      assertEquals("closed", e.getMessage());
     }
     try {
       client.close(1000, "Bye!");
       fail();
     } catch (IOException e) {
-      assertEquals("Closed", e.getMessage());
+      assertEquals("closed", e.getMessage());
     }
   }
 
@@ -190,20 +202,20 @@
       sink.writeUtf8("lo!").emit(); // No writing to the underlying sink.
       fail();
     } catch (IOException e) {
-      assertEquals("Closed", e.getMessage());
+      assertEquals("closed", e.getMessage());
       sink.buffer().clear();
     }
     try {
       sink.flush(); // No flushing.
       fail();
     } catch (IOException e) {
-      assertEquals("Closed", e.getMessage());
+      assertEquals("closed", e.getMessage());
     }
     try {
       sink.close(); // No closing because this requires writing a frame.
       fail();
     } catch (IOException e) {
-      assertEquals("Closed", e.getMessage());
+      assertEquals("closed", e.getMessage());
     }
   }
 
@@ -213,7 +225,8 @@
     server.readMessage(); // Read client close, send server close.
     serverListener.assertClose(1000, "Hello!");
 
-    client.readMessage();
+    client.readMessage(); // Read server close.
+    waitForExecutor(clientExecutor); // Close happens asynchronously.
     assertTrue(clientConnectionClosed);
     clientListener.assertClose(1000, "Hello!");
   }
@@ -236,6 +249,7 @@
     assertFalse(clientConnectionClosed);
 
     client.readMessage(); // Read close, should NOT send close.
+    waitForExecutor(clientExecutor); // Close happens asynchronously.
     assertTrue(clientConnectionClosed);
     clientListener.assertClose(1000, "Hello!");
 
@@ -277,4 +291,32 @@
     server.readMessage();
     serverListener.assertClose(1000, "Hello!");
   }
+
+  @Test public void peerConnectionCloseThrowingDoesNotPropagate() throws IOException {
+    clientConnectionCloseThrows = true;
+
+    server.close(1000, "Bye!");
+    client.readMessage();
+    clientListener.assertClose(1000, "Bye!");
+    assertTrue(clientConnectionClosed);
+
+    server.readMessage();
+    serverListener.assertClose(1000, "Bye!");
+  }
+
+  private static void waitForExecutor(Executor executor) {
+    final CountDownLatch latch = new CountDownLatch(1);
+    executor.execute(new Runnable() {
+      @Override public void run() {
+        latch.countDown();
+      }
+    });
+    try {
+      if (!latch.await(10, TimeUnit.SECONDS)) {
+        throw new IllegalStateException("Timed out waiting for executor.");
+      }
+    } catch (InterruptedException e) {
+      Thread.currentThread().interrupt();
+    }
+  }
 }
diff --git a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/ws/WebSocketReaderTest.java b/okhttp-ws-tests/src/test/java/com/squareup/okhttp/internal/ws/WebSocketReaderTest.java
similarity index 91%
rename from okhttp-tests/src/test/java/com/squareup/okhttp/internal/ws/WebSocketReaderTest.java
rename to okhttp-ws-tests/src/test/java/com/squareup/okhttp/internal/ws/WebSocketReaderTest.java
index 2f9dda8bee..1674511a43 100644
--- a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/ws/WebSocketReaderTest.java
+++ b/okhttp-ws-tests/src/test/java/com/squareup/okhttp/internal/ws/WebSocketReaderTest.java
@@ -15,6 +15,7 @@
  */
 package com.squareup.okhttp.internal.ws;
 
+import com.squareup.okhttp.ws.WebSocketRecorder;
 import java.io.EOFException;
 import java.io.IOException;
 import java.net.ProtocolException;
@@ -26,13 +27,13 @@
 import org.junit.After;
 import org.junit.Test;
 
-import static com.squareup.okhttp.internal.ws.WebSocket.PayloadType;
-import static com.squareup.okhttp.internal.ws.WebSocketRecorder.MessageDelegate;
+import static com.squareup.okhttp.ws.WebSocket.PayloadType;
+import static com.squareup.okhttp.ws.WebSocketRecorder.MessageDelegate;
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertNotNull;
 import static org.junit.Assert.fail;
 
-public class WebSocketReaderTest {
+public final class WebSocketReaderTest {
   private final Buffer data = new Buffer();
   private final WebSocketRecorder callback = new WebSocketRecorder();
   private final Random random = new Random(0);
@@ -123,6 +124,28 @@
     callback.assertTextMessage("Hello");
   }
 
+  @Test public void clientFramePayloadShort() throws IOException {
+    data.write(ByteString.decodeHex("817E000548656c6c6f")); // Hello
+    clientReader.processNextFrame();
+    callback.assertTextMessage("Hello");
+  }
+
+  @Test public void clientFramePayloadLong() throws IOException {
+    data.write(ByteString.decodeHex("817f000000000000000548656c6c6f")); // Hello
+    clientReader.processNextFrame();
+    callback.assertTextMessage("Hello");
+  }
+
+  @Test public void clientFramePayloadTooLongThrows() throws IOException {
+    data.write(ByteString.decodeHex("817f8000000000000000"));
+    try {
+      clientReader.processNextFrame();
+      fail();
+    } catch (ProtocolException e) {
+      assertEquals("Frame length 0x8000000000000000 > 0x7FFFFFFFFFFFFFFF", e.getMessage());
+    }
+  }
+
   @Test public void serverHelloTwoChunks() throws IOException {
     data.write(ByteString.decodeHex("818537fa213d7f9f4d")); // Hel
 
diff --git a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/ws/WebSocketWriterTest.java b/okhttp-ws-tests/src/test/java/com/squareup/okhttp/internal/ws/WebSocketWriterTest.java
similarity index 95%
rename from okhttp-tests/src/test/java/com/squareup/okhttp/internal/ws/WebSocketWriterTest.java
rename to okhttp-ws-tests/src/test/java/com/squareup/okhttp/internal/ws/WebSocketWriterTest.java
index 141d9ca4a3..a98e6bbf9d 100644
--- a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/ws/WebSocketWriterTest.java
+++ b/okhttp-ws-tests/src/test/java/com/squareup/okhttp/internal/ws/WebSocketWriterTest.java
@@ -25,13 +25,13 @@
 import org.junit.After;
 import org.junit.Test;
 
-import static com.squareup.okhttp.internal.ws.WebSocket.PayloadType.BINARY;
-import static com.squareup.okhttp.internal.ws.WebSocket.PayloadType.TEXT;
+import static com.squareup.okhttp.ws.WebSocket.PayloadType.BINARY;
+import static com.squareup.okhttp.ws.WebSocket.PayloadType.TEXT;
 import static com.squareup.okhttp.internal.ws.WebSocketProtocol.toggleMask;
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.fail;
 
-public class WebSocketWriterTest {
+public final class WebSocketWriterTest {
   private final Buffer data = new Buffer();
   private final Random random = new Random(0);
 
@@ -100,9 +100,9 @@
   }
 
   @Test public void serverSendBinaryShort() throws IOException {
-    byte[] payload = binaryData(1000);
+    byte[] payload = binaryData(0xffff);
     serverWriter.sendMessage(BINARY, new Buffer().write(payload));
-    assertData("827e03e8");
+    assertData("827effff");
     assertData(payload);
   }
 
@@ -206,12 +206,8 @@
   }
 
   @Test public void closeWithOnlyReasonThrows() throws IOException {
-    try {
-      clientWriter.writeClose(0, "Hello");
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertEquals("Code required to include reason.", e.getMessage());
-    }
+    clientWriter.writeClose(0, "Hello");
+    assertData("888760b420bb60b468de0cd84f");
   }
 
   @Test public void closeCodeOutOfRangeThrows() throws IOException {
diff --git a/okhttp-ws-tests/src/test/java/com/squareup/okhttp/ws/AutobahnTester.java b/okhttp-ws-tests/src/test/java/com/squareup/okhttp/ws/AutobahnTester.java
new file mode 100644
index 0000000000..a592624c67
--- /dev/null
+++ b/okhttp-ws-tests/src/test/java/com/squareup/okhttp/ws/AutobahnTester.java
@@ -0,0 +1,184 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.okhttp.ws;
+
+import com.squareup.okhttp.OkHttpClient;
+import com.squareup.okhttp.Request;
+import com.squareup.okhttp.Response;
+import com.squareup.okhttp.internal.Version;
+import java.io.IOException;
+import java.util.concurrent.CountDownLatch;
+import java.util.concurrent.ExecutorService;
+import java.util.concurrent.Executors;
+import java.util.concurrent.TimeUnit;
+import java.util.concurrent.atomic.AtomicLong;
+import java.util.concurrent.atomic.AtomicReference;
+import okio.Buffer;
+import okio.BufferedSource;
+
+/**
+ * Exercises the web socket implementation against the
+ * <a href="http://autobahn.ws/testsuite/">Autobahn Testsuite</a>.
+ */
+public final class AutobahnTester {
+  private static final String HOST = "ws://localhost:9001";
+
+  public static void main(String... args) throws IOException {
+    new AutobahnTester().run();
+  }
+
+  final OkHttpClient client = new OkHttpClient();
+
+  private WebSocketCall newWebSocket(String path) {
+    Request request = new Request.Builder().url(HOST + path).build();
+    return WebSocketCall.create(client, request);
+  }
+
+  public void run() throws IOException {
+    try {
+      long count = getTestCount();
+      System.out.println("Test count: " + count);
+
+      for (long number = 1; number <= count; number++) {
+        runTest(number, count);
+      }
+
+      updateReports();
+    } finally {
+      client.getDispatcher().getExecutorService().shutdown();
+    }
+  }
+
+  private void runTest(final long number, final long count) throws IOException {
+    final CountDownLatch latch = new CountDownLatch(1);
+    newWebSocket("/runCase?case=" + number + "&agent=" + Version.userAgent()) //
+        .enqueue(new WebSocketListener() {
+          private final ExecutorService sendExecutor = Executors.newSingleThreadExecutor();
+          private WebSocket webSocket;
+
+          @Override public void onOpen(WebSocket webSocket, Response response) {
+            System.out.println("Executing test case " + number + "/" + count);
+            this.webSocket = webSocket;
+          }
+
+          @Override public void onMessage(BufferedSource payload, final WebSocket.PayloadType type)
+              throws IOException {
+            final Buffer buffer = new Buffer();
+            payload.readAll(buffer);
+            payload.close();
+
+            sendExecutor.execute(new Runnable() {
+              @Override public void run() {
+                try {
+                  webSocket.sendMessage(type, buffer);
+                } catch (IOException e) {
+                  e.printStackTrace();
+                }
+              }
+            });
+          }
+
+          @Override public void onPong(Buffer payload) {
+          }
+
+          @Override public void onClose(int code, String reason) {
+            sendExecutor.shutdown();
+            latch.countDown();
+          }
+
+          @Override public void onFailure(IOException e, Response response) {
+            latch.countDown();
+          }
+        });
+    try {
+      if (!latch.await(10, TimeUnit.SECONDS)) {
+        throw new IllegalStateException("Timed out waiting for count.");
+      }
+    } catch (InterruptedException e) {
+      throw new AssertionError();
+    }
+  }
+
+  private long getTestCount() throws IOException {
+    final CountDownLatch latch = new CountDownLatch(1);
+    final AtomicLong countRef = new AtomicLong();
+    final AtomicReference<IOException> failureRef = new AtomicReference<>();
+    newWebSocket("/getCaseCount").enqueue(new WebSocketListener() {
+      @Override public void onOpen(WebSocket webSocket, Response response) {
+      }
+
+      @Override public void onMessage(BufferedSource payload, WebSocket.PayloadType type)
+          throws IOException {
+        countRef.set(payload.readDecimalLong());
+        payload.close();
+      }
+
+      @Override public void onPong(Buffer payload) {
+      }
+
+      @Override public void onClose(int code, String reason) {
+        latch.countDown();
+      }
+
+      @Override public void onFailure(IOException e, Response response) {
+        failureRef.set(e);
+        latch.countDown();
+      }
+    });
+    try {
+      if (!latch.await(10, TimeUnit.SECONDS)) {
+        throw new IllegalStateException("Timed out waiting for count.");
+      }
+    } catch (InterruptedException e) {
+      throw new AssertionError();
+    }
+    IOException failure = failureRef.get();
+    if (failure != null) {
+      throw failure;
+    }
+    return countRef.get();
+  }
+
+  private void updateReports() {
+    final CountDownLatch latch = new CountDownLatch(1);
+    newWebSocket("/updateReports?agent=" + Version.userAgent()).enqueue(new WebSocketListener() {
+      @Override public void onOpen(WebSocket webSocket, Response response) {
+      }
+
+      @Override public void onMessage(BufferedSource payload, WebSocket.PayloadType type)
+          throws IOException {
+      }
+
+      @Override public void onPong(Buffer payload) {
+      }
+
+      @Override public void onClose(int code, String reason) {
+        latch.countDown();
+      }
+
+      @Override public void onFailure(IOException e, Response response) {
+        latch.countDown();
+      }
+    });
+    try {
+      if (!latch.await(10, TimeUnit.SECONDS)) {
+        throw new IllegalStateException("Timed out waiting for count.");
+      }
+    } catch (InterruptedException e) {
+      throw new AssertionError();
+    }
+  }
+}
diff --git a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/ws/WebSocketCallTest.java b/okhttp-ws-tests/src/test/java/com/squareup/okhttp/ws/WebSocketCallTest.java
similarity index 66%
rename from okhttp-tests/src/test/java/com/squareup/okhttp/internal/ws/WebSocketCallTest.java
rename to okhttp-ws-tests/src/test/java/com/squareup/okhttp/ws/WebSocketCallTest.java
index 705b0357f2..895eb1f658 100644
--- a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/ws/WebSocketCallTest.java
+++ b/okhttp-ws-tests/src/test/java/com/squareup/okhttp/ws/WebSocketCallTest.java
@@ -13,20 +13,22 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.squareup.okhttp.internal.ws;
+package com.squareup.okhttp.ws;
 
 import com.squareup.okhttp.OkHttpClient;
-import com.squareup.okhttp.RecordedResponse;
 import com.squareup.okhttp.Request;
 import com.squareup.okhttp.Response;
+import com.squareup.okhttp.internal.SslContextBuilder;
 import com.squareup.okhttp.mockwebserver.MockResponse;
-import com.squareup.okhttp.mockwebserver.rule.MockWebServerRule;
+import com.squareup.okhttp.mockwebserver.MockWebServer;
+import com.squareup.okhttp.testing.RecordingHostnameVerifier;
 import java.io.IOException;
 import java.net.ProtocolException;
 import java.util.Random;
 import java.util.concurrent.CountDownLatch;
 import java.util.concurrent.TimeUnit;
 import java.util.concurrent.atomic.AtomicReference;
+import javax.net.ssl.SSLContext;
 import okio.Buffer;
 import okio.BufferedSink;
 import okio.BufferedSource;
@@ -34,11 +36,12 @@
 import org.junit.Rule;
 import org.junit.Test;
 
-import static com.squareup.okhttp.internal.ws.WebSocket.PayloadType.TEXT;
+import static com.squareup.okhttp.ws.WebSocket.PayloadType.TEXT;
 
 public final class WebSocketCallTest {
-  @Rule public final MockWebServerRule server = new MockWebServerRule();
+  @Rule public final MockWebServer server = new MockWebServer();
 
+  private final SSLContext sslContext = SslContextBuilder.localhost();
   private final WebSocketRecorder listener = new WebSocketRecorder();
   private final OkHttpClient client = new OkHttpClient();
   private final Random random = new Random(0);
@@ -51,7 +54,7 @@
     WebSocketListener serverListener = new EmptyWebSocketListener();
     server.enqueue(new MockResponse().withWebSocketUpgrade(serverListener));
 
-    WebSocket webSocket = awaitCall().webSocket;
+    WebSocket webSocket = awaitWebSocket();
     webSocket.sendPing(new Buffer().writeUtf8("Hello, WebSockets!"));
     listener.assertPong(new Buffer().writeUtf8("Hello, WebSockets!"));
   }
@@ -60,21 +63,28 @@
     WebSocketRecorder serverListener = new WebSocketRecorder();
     server.enqueue(new MockResponse().withWebSocketUpgrade(serverListener));
 
-    WebSocket webSocket = awaitCall().webSocket;
+    WebSocket webSocket = awaitWebSocket();
     webSocket.sendMessage(TEXT, new Buffer().writeUtf8("Hello, WebSockets!"));
     serverListener.assertTextMessage("Hello, WebSockets!");
   }
 
   @Test public void serverMessage() throws IOException {
     WebSocketListener serverListener = new EmptyWebSocketListener() {
-      @Override public void onOpen(WebSocket webSocket, Request request, Response response)
-          throws IOException {
-        webSocket.sendMessage(TEXT, new Buffer().writeUtf8("Hello, WebSockets!"));
+      @Override public void onOpen(final WebSocket webSocket, Response response) {
+        new Thread() {
+          @Override public void run() {
+            try {
+              webSocket.sendMessage(TEXT, new Buffer().writeUtf8("Hello, WebSockets!"));
+            } catch (IOException e) {
+              throw new AssertionError(e);
+            }
+          }
+        }.start();
       }
     };
     server.enqueue(new MockResponse().withWebSocketUpgrade(serverListener));
 
-    awaitCall();
+    awaitWebSocket();
     listener.assertTextMessage("Hello, WebSockets!");
   }
 
@@ -82,7 +92,7 @@
     WebSocketRecorder serverListener = new WebSocketRecorder();
     server.enqueue(new MockResponse().withWebSocketUpgrade(serverListener));
 
-    WebSocket webSocket = awaitCall().webSocket;
+    WebSocket webSocket = awaitWebSocket();
     BufferedSink sink = webSocket.newMessageSink(TEXT);
     sink.writeUtf8("Hello, ").flush();
     sink.writeUtf8("WebSockets!").flush();
@@ -93,29 +103,36 @@
 
   @Test public void serverStreamingMessage() throws IOException {
     WebSocketListener serverListener = new EmptyWebSocketListener() {
-      @Override public void onOpen(WebSocket webSocket, Request request, Response response)
-          throws IOException {
-        BufferedSink sink = webSocket.newMessageSink(TEXT);
-        sink.writeUtf8("Hello, ").flush();
-        sink.writeUtf8("WebSockets!").flush();
-        sink.close();
+      @Override public void onOpen(final WebSocket webSocket, Response response) {
+        new Thread() {
+          @Override public void run() {
+            try {
+              BufferedSink sink = webSocket.newMessageSink(TEXT);
+              sink.writeUtf8("Hello, ").flush();
+              sink.writeUtf8("WebSockets!").flush();
+              sink.close();
+            } catch (IOException e) {
+              throw new AssertionError(e);
+            }
+          }
+        }.start();
       }
     };
     server.enqueue(new MockResponse().withWebSocketUpgrade(serverListener));
 
-    awaitCall();
+    awaitWebSocket();
     listener.assertTextMessage("Hello, WebSockets!");
   }
 
   @Test public void okButNotOk() {
     server.enqueue(new MockResponse());
-    awaitCall();
+    awaitWebSocket();
     listener.assertFailure(ProtocolException.class, "Expected HTTP 101 response but was '200 OK'");
   }
 
   @Test public void notFound() {
     server.enqueue(new MockResponse().setStatus("HTTP/1.1 404 Not Found"));
-    awaitCall();
+    awaitWebSocket();
     listener.assertFailure(ProtocolException.class,
         "Expected HTTP 101 response but was '404 Not Found'");
   }
@@ -125,17 +142,18 @@
         .setResponseCode(101)
         .setHeader("Upgrade", "websocket")
         .setHeader("Sec-WebSocket-Accept", "ujmZX4KXZqjwy6vi1aQFH5p4Ygk="));
-    awaitCall();
+    awaitWebSocket();
     listener.assertFailure(ProtocolException.class,
         "Expected 'Connection' header value 'Upgrade' but was 'null'");
   }
 
   @Test public void wrongConnectionHeader() {
-    server.enqueue(new MockResponse().setResponseCode(101)
+    server.enqueue(new MockResponse()
+        .setResponseCode(101)
         .setHeader("Upgrade", "websocket")
         .setHeader("Connection", "Downgrade")
         .setHeader("Sec-WebSocket-Accept", "ujmZX4KXZqjwy6vi1aQFH5p4Ygk="));
-    awaitCall();
+    awaitWebSocket();
     listener.assertFailure(ProtocolException.class,
         "Expected 'Connection' header value 'Upgrade' but was 'Downgrade'");
   }
@@ -145,7 +163,7 @@
         .setResponseCode(101)
         .setHeader("Connection", "Upgrade")
         .setHeader("Sec-WebSocket-Accept", "ujmZX4KXZqjwy6vi1aQFH5p4Ygk="));
-    awaitCall();
+    awaitWebSocket();
     listener.assertFailure(ProtocolException.class,
         "Expected 'Upgrade' header value 'websocket' but was 'null'");
   }
@@ -156,7 +174,7 @@
         .setHeader("Connection", "Upgrade")
         .setHeader("Upgrade", "Pepsi")
         .setHeader("Sec-WebSocket-Accept", "ujmZX4KXZqjwy6vi1aQFH5p4Ygk="));
-    awaitCall();
+    awaitWebSocket();
     listener.assertFailure(ProtocolException.class,
         "Expected 'Upgrade' header value 'websocket' but was 'Pepsi'");
   }
@@ -166,7 +184,7 @@
         .setResponseCode(101)
         .setHeader("Connection", "Upgrade")
         .setHeader("Upgrade", "websocket"));
-    awaitCall();
+    awaitWebSocket();
     listener.assertFailure(ProtocolException.class,
         "Expected 'Sec-WebSocket-Accept' header value 'ujmZX4KXZqjwy6vi1aQFH5p4Ygk=' but was 'null'");
   }
@@ -177,13 +195,53 @@
         .setHeader("Connection", "Upgrade")
         .setHeader("Upgrade", "websocket")
         .setHeader("Sec-WebSocket-Accept", "magic"));
-    awaitCall();
+    awaitWebSocket();
     listener.assertFailure(ProtocolException.class,
         "Expected 'Sec-WebSocket-Accept' header value 'ujmZX4KXZqjwy6vi1aQFH5p4Ygk=' but was 'magic'");
   }
 
-  private RecordedResponse awaitCall() {
-    Request request = new Request.Builder().get().url(server.getUrl("/")).build();
+  @Test public void wsScheme() throws IOException {
+    websocketScheme("ws");
+  }
+
+  @Test public void wsUppercaseScheme() throws IOException {
+    websocketScheme("WS");
+  }
+
+  @Test public void wssScheme() throws IOException {
+    server.useHttps(sslContext.getSocketFactory(), false);
+    client.setSslSocketFactory(sslContext.getSocketFactory());
+    client.setHostnameVerifier(new RecordingHostnameVerifier());
+
+    websocketScheme("wss");
+  }
+
+  @Test public void httpsScheme() throws IOException {
+    server.useHttps(sslContext.getSocketFactory(), false);
+    client.setSslSocketFactory(sslContext.getSocketFactory());
+    client.setHostnameVerifier(new RecordingHostnameVerifier());
+
+    websocketScheme("https");
+  }
+
+  private void websocketScheme(String scheme) throws IOException {
+    WebSocketRecorder serverListener = new WebSocketRecorder();
+    server.enqueue(new MockResponse().withWebSocketUpgrade(serverListener));
+
+    Request request1 = new Request.Builder()
+        .url(scheme + "://" + server.getHostName() + ":" + server.getPort() + "/")
+        .build();
+
+    WebSocket webSocket = awaitWebSocket(request1);
+    webSocket.sendMessage(TEXT, new Buffer().writeUtf8("abc"));
+    serverListener.assertTextMessage("abc");
+  }
+
+  private WebSocket awaitWebSocket() {
+    return awaitWebSocket(new Request.Builder().get().url(server.url("/")).build());
+  }
+
+  private WebSocket awaitWebSocket(Request request) {
     WebSocketCall call = new WebSocketCall(client, request, random);
 
     final AtomicReference<Response> responseRef = new AtomicReference<>();
@@ -191,8 +249,7 @@ private RecordedResponse awaitCall() {
     final AtomicReference<IOException> failureRef = new AtomicReference<>();
     final CountDownLatch latch = new CountDownLatch(1);
     call.enqueue(new WebSocketListener() {
-      @Override public void onOpen(WebSocket webSocket, Request request, Response response)
-          throws IOException {
+      @Override public void onOpen(WebSocket webSocket, Response response) {
         webSocketRef.set(webSocket);
         responseRef.set(response);
         latch.countDown();
@@ -211,29 +268,26 @@ private RecordedResponse awaitCall() {
         listener.onClose(code, reason);
       }
 
-      @Override public void onFailure(IOException e) {
-        listener.onFailure(e);
+      @Override public void onFailure(IOException e, Response response) {
+        listener.onFailure(e, null);
         failureRef.set(e);
         latch.countDown();
       }
     });
 
     try {
-      latch.await(10, TimeUnit.SECONDS);
+      if (!latch.await(10, TimeUnit.SECONDS)) {
+        throw new AssertionError("Timed out.");
+      }
     } catch (InterruptedException e) {
       throw new AssertionError(e);
     }
-    if (latch.getCount() > 0) {
-      throw new AssertionError("Timed out.");
-    }
 
-    return new RecordedResponse(request, responseRef.get(), webSocketRef.get(), null,
-        failureRef.get());
+    return webSocketRef.get();
   }
 
   private static class EmptyWebSocketListener implements WebSocketListener {
-    @Override public void onOpen(WebSocket webSocket, Request request, Response response)
-        throws IOException {
+    @Override public void onOpen(WebSocket webSocket, Response response) {
     }
 
     @Override public void onMessage(BufferedSource payload, WebSocket.PayloadType type)
@@ -246,7 +300,7 @@ private RecordedResponse awaitCall() {
     @Override public void onClose(int code, String reason) {
     }
 
-    @Override public void onFailure(IOException e) {
+    @Override public void onFailure(IOException e, Response response) {
     }
   }
 }
diff --git a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/ws/WebSocketRecorder.java b/okhttp-ws-tests/src/test/java/com/squareup/okhttp/ws/WebSocketRecorder.java
similarity index 89%
rename from okhttp-tests/src/test/java/com/squareup/okhttp/internal/ws/WebSocketRecorder.java
rename to okhttp-ws-tests/src/test/java/com/squareup/okhttp/ws/WebSocketRecorder.java
index 05b8480485..56b3810630 100644
--- a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/ws/WebSocketRecorder.java
+++ b/okhttp-ws-tests/src/test/java/com/squareup/okhttp/ws/WebSocketRecorder.java
@@ -13,10 +13,10 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.squareup.okhttp.internal.ws;
+package com.squareup.okhttp.ws;
 
-import com.squareup.okhttp.Request;
 import com.squareup.okhttp.Response;
+import com.squareup.okhttp.internal.ws.WebSocketReader;
 import java.io.IOException;
 import java.util.concurrent.BlockingQueue;
 import java.util.concurrent.LinkedBlockingQueue;
@@ -24,13 +24,13 @@
 import okio.Buffer;
 import okio.BufferedSource;
 
-import static com.squareup.okhttp.internal.ws.WebSocket.PayloadType.BINARY;
-import static com.squareup.okhttp.internal.ws.WebSocket.PayloadType.TEXT;
+import static com.squareup.okhttp.ws.WebSocket.PayloadType.BINARY;
+import static com.squareup.okhttp.ws.WebSocket.PayloadType.TEXT;
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertNotNull;
 import static org.junit.Assert.assertTrue;
 
-final class WebSocketRecorder implements WebSocketReader.FrameCallback, WebSocketListener {
+public final class WebSocketRecorder implements WebSocketReader.FrameCallback, WebSocketListener {
   public interface MessageDelegate {
     void onMessage(BufferedSource payload, WebSocket.PayloadType type) throws IOException;
   }
@@ -43,7 +43,7 @@ public void setNextMessageDelegate(MessageDelegate delegate) {
     this.delegate = delegate;
   }
 
-  @Override public void onOpen(WebSocket webSocket, Request request, Response response) {
+  @Override public void onOpen(WebSocket webSocket, Response response) {
   }
 
   @Override public void onMessage(BufferedSource source, WebSocket.PayloadType type)
@@ -71,13 +71,17 @@ public void setNextMessageDelegate(MessageDelegate delegate) {
     events.add(new Close(code, reason));
   }
 
-  @Override public void onFailure(IOException e) {
+  @Override public void onFailure(IOException e, Response response) {
     events.add(e);
   }
 
   private Object nextEvent() {
     try {
-      return events.poll(10, TimeUnit.SECONDS);
+      Object event = events.poll(10, TimeUnit.SECONDS);
+      if (event == null) {
+        throw new AssertionError("Timed out.");
+      }
+      return event;
     } catch (InterruptedException e) {
       throw new AssertionError(e);
     }
@@ -104,7 +108,7 @@ public void assertPong(Buffer payload) {
   }
 
   public void assertClose(int code, String reason) {
-      assertEquals(new Close(code, reason), nextEvent());
+    assertEquals(new Close(code, reason), nextEvent());
   }
 
   public void assertFailure(Class<? extends IOException> cls, String message) {
diff --git a/okhttp-ws/README.md b/okhttp-ws/README.md
new file mode 100644
index 0000000000..054ea91fbf
--- /dev/null
+++ b/okhttp-ws/README.md
@@ -0,0 +1,22 @@
+OkHttp Web Sockets
+==================
+
+RFC6455-compliant web socket implementation.
+
+Create a `WebSocketCall` with a `Request` and an `OkHttpClient` instance.
+```java
+WebSocketCall call = WebSocketCall.create(client, request);
+```
+
+A `WebSocketListener` will notify of the initial connection, server-sent messages, and any failures
+on the connection.
+
+Start the web socket by calling `enqueue` on `WebSocketCall` with the `WebSocketListener`.
+```java
+call.enqueue(new WebSocketListener() {
+  // ...
+});
+```
+
+*Note: This module's API should be considered experimental and may be subject to breaking changes
+in future releases.*
diff --git a/okhttp-ws/pom.xml b/okhttp-ws/pom.xml
new file mode 100644
index 0000000000..81f8afd8c9
--- /dev/null
+++ b/okhttp-ws/pom.xml
@@ -0,0 +1,37 @@
+<?xml version="1.0" encoding="UTF-8"?>
+
+<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
+  <modelVersion>4.0.0</modelVersion>
+
+  <parent>
+    <groupId>com.squareup.okhttp</groupId>
+    <artifactId>parent</artifactId>
+    <version>2.6.0-SNAPSHOT</version>
+  </parent>
+
+  <artifactId>okhttp-ws</artifactId>
+  <name>OkHttp Web Sockets</name>
+
+  <dependencies>
+    <dependency>
+      <groupId>com.squareup.okhttp</groupId>
+      <artifactId>okhttp</artifactId>
+      <version>${project.version}</version>
+    </dependency>
+  </dependencies>
+
+  <build>
+    <plugins>
+      <plugin>
+        <groupId>org.apache.maven.plugins</groupId>
+        <artifactId>maven-javadoc-plugin</artifactId>
+        <configuration>
+          <excludePackageNames>com.squareup.okhttp.internal.*</excludePackageNames>
+          <links>
+            <link>http://square.github.io/okhttp/javadoc/</link>
+          </links>
+        </configuration>
+      </plugin>
+    </plugins>
+  </build>
+</project>
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/ws/RealWebSocket.java b/okhttp-ws/src/main/java/com/squareup/okhttp/internal/ws/RealWebSocket.java
similarity index 73%
rename from okhttp/src/main/java/com/squareup/okhttp/internal/ws/RealWebSocket.java
rename to okhttp-ws/src/main/java/com/squareup/okhttp/internal/ws/RealWebSocket.java
index a926ebccf2..8d6b7c498b 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/ws/RealWebSocket.java
+++ b/okhttp-ws/src/main/java/com/squareup/okhttp/internal/ws/RealWebSocket.java
@@ -16,18 +16,17 @@
 package com.squareup.okhttp.internal.ws;
 
 import com.squareup.okhttp.internal.NamedRunnable;
-import com.squareup.okhttp.internal.Util;
+import com.squareup.okhttp.ws.WebSocket;
+import com.squareup.okhttp.ws.WebSocketListener;
 import java.io.IOException;
 import java.net.ProtocolException;
 import java.util.Random;
-import java.util.concurrent.LinkedBlockingDeque;
-import java.util.concurrent.ThreadPoolExecutor;
+import java.util.concurrent.Executor;
 import okio.Buffer;
 import okio.BufferedSink;
 import okio.BufferedSource;
 
 import static com.squareup.okhttp.internal.ws.WebSocketReader.FrameCallback;
-import static java.util.concurrent.TimeUnit.SECONDS;
 
 public abstract class RealWebSocket implements WebSocket {
   /** A close code which indicates that the peer encountered a protocol exception. */
@@ -45,15 +44,9 @@
   private final Object closeLock = new Object();
 
   public RealWebSocket(boolean isClient, BufferedSource source, BufferedSink sink, Random random,
-      final WebSocketListener listener, final String url) {
+      final Executor replyExecutor, final WebSocketListener listener, final String url) {
     this.listener = listener;
 
-    // Pings come in on the reader thread. This executor contends with callers for writing pongs.
-    final ThreadPoolExecutor pongExecutor = new ThreadPoolExecutor(1, 1, 1, SECONDS,
-        new LinkedBlockingDeque<Runnable>(),
-        Util.threadFactory(String.format("OkHttp %s WebSocket", url), true));
-    pongExecutor.allowCoreThreadTimeOut(true);
-
     writer = new WebSocketWriter(isClient, sink, random);
     reader = new WebSocketReader(isClient, source, new FrameCallback() {
       @Override public void onMessage(BufferedSource source, PayloadType type) throws IOException {
@@ -61,7 +54,7 @@ public RealWebSocket(boolean isClient, BufferedSource source, BufferedSink sink,
       }
 
       @Override public void onPing(final Buffer buffer) {
-        pongExecutor.execute(new NamedRunnable("OkHttp %s WebSocket Pong", url) {
+        replyExecutor.execute(new NamedRunnable("OkHttp %s WebSocket Pong Reply", url) {
           @Override protected void execute() {
             try {
               writer.writePong(buffer);
@@ -75,8 +68,20 @@ public RealWebSocket(boolean isClient, BufferedSource source, BufferedSink sink,
         listener.onPong(buffer);
       }
 
-      @Override public void onClose(int code, String reason) throws IOException {
-        peerClose(code, reason);
+      @Override public void onClose(final int code, final String reason) {
+        final boolean writeCloseResponse;
+        synchronized (closeLock) {
+          readerSentClose = true;
+
+          // If the writer has not indicated a desire to close we will write a close response.
+          writeCloseResponse = !writerSentClose;
+        }
+
+        replyExecutor.execute(new NamedRunnable("OkHttp %s WebSocket Close Reply", url) {
+          @Override protected void execute() {
+            peerClose(code, reason, writeCloseResponse);
+          }
+        });
       }
     });
   }
@@ -96,28 +101,28 @@ public boolean readMessage() {
   }
 
   @Override public BufferedSink newMessageSink(PayloadType type) {
-    if (writerSentClose) throw new IllegalStateException("Closed");
+    if (writerSentClose) throw new IllegalStateException("closed");
     return writer.newMessageSink(type);
   }
 
   @Override public void sendMessage(PayloadType type, Buffer payload) throws IOException {
-    if (writerSentClose) throw new IllegalStateException("Closed");
+    if (writerSentClose) throw new IllegalStateException("closed");
     writer.sendMessage(type, payload);
   }
 
   @Override public void sendPing(Buffer payload) throws IOException {
-    if (writerSentClose) throw new IllegalStateException("Closed");
+    if (writerSentClose) throw new IllegalStateException("closed");
     writer.writePing(payload);
   }
 
   /** Send an unsolicited pong with the specified payload. */
   public void sendPong(Buffer payload) throws IOException {
-    if (writerSentClose) throw new IllegalStateException("Closed");
+    if (writerSentClose) throw new IllegalStateException("closed");
     writer.writePong(payload);
   }
 
   @Override public void close(int code, String reason) throws IOException {
-    if (writerSentClose) throw new IllegalStateException("Closed");
+    if (writerSentClose) throw new IllegalStateException("closed");
 
     boolean closeConnection;
     synchronized (closeLock) {
@@ -134,22 +139,19 @@ public void sendPong(Buffer payload) throws IOException {
     }
   }
 
-  /** Called on the reader thread when a close frame is encountered. */
-  private void peerClose(int code, String reason) throws IOException {
-    boolean writeCloseResponse;
-    synchronized (closeLock) {
-      readerSentClose = true;
-
-      // If the writer has not indicated a desire to close we will write a close response.
-      writeCloseResponse = !writerSentClose;
-    }
-
+  /** Replies and closes this web socket when a close frame is read from the peer. */
+  private void peerClose(int code, String reason, boolean writeCloseResponse) {
     if (writeCloseResponse) {
-      // The reader thread will read no more frames so use it to send the response.
-      writer.writeClose(code, reason);
+      try {
+        writer.writeClose(code, reason);
+      } catch (IOException ignored) {
+      }
     }
 
-    closeConnection();
+    try {
+      closeConnection();
+    } catch (IOException ignored) {
+    }
 
     listener.onClose(code, reason);
   }
@@ -179,7 +181,7 @@ private void readerErrorClose(IOException e) {
     } catch (IOException ignored) {
     }
 
-    listener.onFailure(e);
+    listener.onFailure(e, null);
   }
 
   /** Perform any tear-down work on the connection (close the socket, recycle, etc.). */
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/ws/WebSocketProtocol.java b/okhttp-ws/src/main/java/com/squareup/okhttp/internal/ws/WebSocketProtocol.java
similarity index 93%
rename from okhttp/src/main/java/com/squareup/okhttp/internal/ws/WebSocketProtocol.java
rename to okhttp-ws/src/main/java/com/squareup/okhttp/internal/ws/WebSocketProtocol.java
index b4d17cc507..2b93398fa5 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/ws/WebSocketProtocol.java
+++ b/okhttp-ws/src/main/java/com/squareup/okhttp/internal/ws/WebSocketProtocol.java
@@ -72,9 +72,14 @@
    * {@link #PAYLOAD_SHORT} or {@link #PAYLOAD_LONG}.
    */
   static final int PAYLOAD_MAX = 125;
-  /** Value for {@link #B1_MASK_LENGTH} which indicates the next two bytes are the length. */
+  /**
+   * Value for {@link #B1_MASK_LENGTH} which indicates the next two bytes are the unsigned length.
+   */
   static final int PAYLOAD_SHORT = 126;
-  /** Value for {@link #B1_MASK_LENGTH} which indicates the next eight bytes are the length. */
+  /**
+   * Value for {@link #B1_MASK_LENGTH} which indicates the next eight bytes are the unsigned
+   * length.
+   */
   static final int PAYLOAD_LONG = 127;
 
   static void toggleMask(byte[] buffer, long byteCount, byte[] key, long frameBytesRead) {
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/ws/WebSocketReader.java b/okhttp-ws/src/main/java/com/squareup/okhttp/internal/ws/WebSocketReader.java
similarity index 89%
rename from okhttp/src/main/java/com/squareup/okhttp/internal/ws/WebSocketReader.java
rename to okhttp-ws/src/main/java/com/squareup/okhttp/internal/ws/WebSocketReader.java
index 294854a973..ce548b17ea 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/ws/WebSocketReader.java
+++ b/okhttp-ws/src/main/java/com/squareup/okhttp/internal/ws/WebSocketReader.java
@@ -24,7 +24,7 @@
 import okio.Source;
 import okio.Timeout;
 
-import static com.squareup.okhttp.internal.ws.WebSocket.PayloadType;
+import static com.squareup.okhttp.ws.WebSocket.PayloadType;
 import static com.squareup.okhttp.internal.ws.WebSocketProtocol.B0_FLAG_FIN;
 import static com.squareup.okhttp.internal.ws.WebSocketProtocol.B0_FLAG_RSV1;
 import static com.squareup.okhttp.internal.ws.WebSocketProtocol.B0_FLAG_RSV2;
@@ -53,7 +53,7 @@
     void onMessage(BufferedSource source, PayloadType type) throws IOException;
     void onPing(Buffer buffer);
     void onPong(Buffer buffer);
-    void onClose(int code, String reason) throws IOException;
+    void onClose(int code, String reason);
   }
 
   private final boolean isClient;
@@ -77,8 +77,8 @@
   private final byte[] maskBuffer = new byte[2048];
 
   public WebSocketReader(boolean isClient, BufferedSource source, FrameCallback frameCallback) {
-    if (source == null) throw new NullPointerException("source");
-    if (frameCallback == null) throw new NullPointerException("frameCallback");
+    if (source == null) throw new NullPointerException("source == null");
+    if (frameCallback == null) throw new NullPointerException("frameCallback == null");
     this.isClient = isClient;
     this.source = source;
     this.frameCallback = frameCallback;
@@ -89,7 +89,7 @@ public WebSocketReader(boolean isClient, BufferedSource source, FrameCallback fr
    * <ul>
    * <li>If it is a control frame this will result in a single call to {@link FrameCallback}.</li>
    * <li>If it is a message frame this will result in a single call to {@link
-   * WebSocketListener#onMessage}. If the message spans multiple frames, each interleaved control
+   * FrameCallback#onMessage}. If the message spans multiple frames, each interleaved control
    * frame will result in a corresponding call to {@link FrameCallback}.
    * </ul>
    */
@@ -103,7 +103,7 @@ public void processNextFrame() throws IOException {
   }
 
   private void readHeader() throws IOException {
-    if (closed) throw new IOException("Closed");
+    if (closed) throw new IOException("closed");
 
     int b0 = source.readByte() & 0xff;
 
@@ -135,9 +135,13 @@ private void readHeader() throws IOException {
     // Get frame length, optionally reading from follow-up bytes if indicated by special values.
     frameLength = b1 & B1_MASK_LENGTH;
     if (frameLength == PAYLOAD_SHORT) {
-      frameLength = source.readShort();
+      frameLength = source.readShort() & 0xffffL; // Value is unsigned.
     } else if (frameLength == PAYLOAD_LONG) {
       frameLength = source.readLong();
+      if (frameLength < 0) {
+        throw new ProtocolException(
+            "Frame length 0x" + Long.toHexString(frameLength) + " > 0x7FFFFFFFFFFFFFFF");
+      }
     }
     frameBytesRead = 0;
 
@@ -181,14 +185,21 @@ private void readControlFrame() throws IOException {
         int code = 0;
         String reason = "";
         if (buffer != null) {
+          if (buffer.size() < 2) {
+            throw new ProtocolException("Close payload must be at least two bytes.");
+          }
           code = buffer.readShort();
+          if (code < 1000 || code >= 5000) {
+            throw new ProtocolException("Code must be in range [1000,5000): " + code);
+          }
+
           reason = buffer.readUtf8();
         }
         frameCallback.onClose(code, reason);
         closed = true;
         break;
       default:
-        throw new IllegalStateException("Unknown control opcode: " + toHexString(opcode));
+        throw new ProtocolException("Unknown control opcode: " + toHexString(opcode));
     }
   }
 
@@ -202,7 +213,7 @@ private void readMessageFrame() throws IOException {
         type = PayloadType.BINARY;
         break;
       default:
-        throw new IllegalStateException("Unknown opcode: " + toHexString(opcode));
+        throw new ProtocolException("Unknown opcode: " + toHexString(opcode));
     }
 
     messageClosed = false;
@@ -230,8 +241,8 @@ private void readUntilNonControlFrame() throws IOException {
    */
   private final class FramedMessageSource implements Source {
     @Override public long read(Buffer sink, long byteCount) throws IOException {
-      if (closed) throw new IOException("Closed");
-      if (messageClosed) throw new IllegalStateException("Closed");
+      if (closed) throw new IOException("closed");
+      if (messageClosed) throw new IllegalStateException("closed");
 
       if (frameBytesRead == frameLength) {
         if (isFinalFrame) return -1; // We are exhausted and have no continuations.
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/ws/WebSocketWriter.java b/okhttp-ws/src/main/java/com/squareup/okhttp/internal/ws/WebSocketWriter.java
similarity index 92%
rename from okhttp/src/main/java/com/squareup/okhttp/internal/ws/WebSocketWriter.java
rename to okhttp-ws/src/main/java/com/squareup/okhttp/internal/ws/WebSocketWriter.java
index 16d269bbcd..fc5de753a1 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/ws/WebSocketWriter.java
+++ b/okhttp-ws/src/main/java/com/squareup/okhttp/internal/ws/WebSocketWriter.java
@@ -24,7 +24,7 @@
 import okio.Sink;
 import okio.Timeout;
 
-import static com.squareup.okhttp.internal.ws.WebSocket.PayloadType;
+import static com.squareup.okhttp.ws.WebSocket.PayloadType;
 import static com.squareup.okhttp.internal.ws.WebSocketProtocol.B0_FLAG_FIN;
 import static com.squareup.okhttp.internal.ws.WebSocketProtocol.B1_FLAG_MASK;
 import static com.squareup.okhttp.internal.ws.WebSocketProtocol.OPCODE_BINARY;
@@ -62,8 +62,8 @@
   private final byte[] maskBuffer;
 
   public WebSocketWriter(boolean isClient, BufferedSink sink, Random random) {
-    if (sink == null) throw new NullPointerException("sink");
-    if (random == null) throw new NullPointerException("random");
+    if (sink == null) throw new NullPointerException("sink == null");
+    if (random == null) throw new NullPointerException("random == null");
     this.isClient = isClient;
     this.sink = sink;
     this.random = random;
@@ -93,12 +93,12 @@ public void writePong(Buffer payload) throws IOException {
    * @param code Status code as defined by
    * <a href="http://tools.ietf.org/html/rfc6455#section-7.4">Section 7.4 of RFC 6455</a> or
    * {@code 0}.
-   * @param reason Reason for shutting down or {@code null}. {@code code} is required if set.
+   * @param reason Reason for shutting down or {@code null}.
    */
   public void writeClose(int code, String reason) throws IOException {
     Buffer payload = null;
-    if (code != 0) {
-      if (code < 1000 || code >= 5000) {
+    if (code != 0 || reason != null) {
+      if (code != 0 && (code < 1000 || code >= 5000)) {
         throw new IllegalArgumentException("Code must be in range [1000,5000).");
       }
       payload = new Buffer();
@@ -106,8 +106,6 @@ public void writeClose(int code, String reason) throws IOException {
       if (reason != null) {
         payload.writeUtf8(reason);
       }
-    } else if (reason != null) {
-      throw new IllegalArgumentException("Code required to include reason.");
     }
 
     synchronized (sink) {
@@ -117,7 +115,7 @@ public void writeClose(int code, String reason) throws IOException {
   }
 
   private void writeControlFrame(int opcode, Buffer payload) throws IOException {
-    if (closed) throw new IOException("Closed");
+    if (closed) throw new IOException("closed");
 
     int length = 0;
     if (payload != null) {
@@ -184,7 +182,7 @@ public void sendMessage(PayloadType type, Buffer payload) throws IOException {
 
   private void writeFrame(PayloadType payloadType, Buffer source, long byteCount,
       boolean isFirstFrame, boolean isFinal) throws IOException {
-    if (closed) throw new IOException("Closed");
+    if (closed) throw new IOException("closed");
 
     int opcode = OPCODE_CONTINUATION;
     if (isFirstFrame) {
@@ -215,7 +213,7 @@ private void writeFrame(PayloadType payloadType, Buffer source, long byteCount,
       if (byteCount <= PAYLOAD_MAX) {
         b1 |= (int) byteCount;
         sink.writeByte(b1);
-      } else if (byteCount <= Short.MAX_VALUE) {
+      } else if (byteCount <= 0xffffL) { // Unsigned short.
         b1 |= PAYLOAD_SHORT;
         sink.writeByte(b1);
         sink.writeShort((int) byteCount);
@@ -258,7 +256,7 @@ private void writeAllMasked(BufferedSource source, long byteCount) throws IOExce
     }
 
     @Override public void flush() throws IOException {
-      if (closed) throw new IOException("Closed");
+      if (closed) throw new IOException("closed");
 
       synchronized (sink) {
         sink.flush();
@@ -271,7 +269,7 @@ private void writeAllMasked(BufferedSource source, long byteCount) throws IOExce
 
     @SuppressWarnings("PointlessBitwiseExpression")
     @Override public void close() throws IOException {
-      if (closed) throw new IOException("Closed");
+      if (closed) throw new IOException("closed");
 
       int length = 0;
 
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/ws/WebSocket.java b/okhttp-ws/src/main/java/com/squareup/okhttp/ws/WebSocket.java
similarity index 97%
rename from okhttp/src/main/java/com/squareup/okhttp/internal/ws/WebSocket.java
rename to okhttp-ws/src/main/java/com/squareup/okhttp/ws/WebSocket.java
index 3be790d010..4cf2f42d6f 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/ws/WebSocket.java
+++ b/okhttp-ws/src/main/java/com/squareup/okhttp/ws/WebSocket.java
@@ -13,13 +13,12 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.squareup.okhttp.internal.ws;
+package com.squareup.okhttp.ws;
 
 import java.io.IOException;
 import okio.Buffer;
 import okio.BufferedSink;
 
-// TODO move to public API!
 /** Blocking interface to connect and write to a web socket. */
 public interface WebSocket {
   /** The format of a message payload. */
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/ws/WebSocketCall.java b/okhttp-ws/src/main/java/com/squareup/okhttp/ws/WebSocketCall.java
similarity index 77%
rename from okhttp/src/main/java/com/squareup/okhttp/internal/ws/WebSocketCall.java
rename to okhttp-ws/src/main/java/com/squareup/okhttp/ws/WebSocketCall.java
index 9147e5bed7..46ee8a133e 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/ws/WebSocketCall.java
+++ b/okhttp-ws/src/main/java/com/squareup/okhttp/ws/WebSocketCall.java
@@ -13,7 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.squareup.okhttp.internal.ws;
+package com.squareup.okhttp.ws;
 
 import com.squareup.okhttp.Call;
 import com.squareup.okhttp.Callback;
@@ -22,27 +22,28 @@
 import com.squareup.okhttp.Request;
 import com.squareup.okhttp.Response;
 import com.squareup.okhttp.internal.Internal;
-import com.squareup.okhttp.internal.NamedRunnable;
 import com.squareup.okhttp.internal.Util;
+import com.squareup.okhttp.internal.ws.RealWebSocket;
+import com.squareup.okhttp.internal.ws.WebSocketProtocol;
 import java.io.IOException;
 import java.net.ProtocolException;
-import java.net.Socket;
 import java.security.SecureRandom;
 import java.util.Collections;
 import java.util.Random;
+import java.util.concurrent.Executor;
+import java.util.concurrent.LinkedBlockingDeque;
+import java.util.concurrent.ThreadPoolExecutor;
 import okio.BufferedSink;
 import okio.BufferedSource;
 import okio.ByteString;
-import okio.Okio;
 
-// TODO move to public API!
-public class WebSocketCall {
+import static java.util.concurrent.TimeUnit.SECONDS;
+
+public final class WebSocketCall {
   /**
    * Prepares the {@code request} to create a web socket at some point in the future.
-   * <p>
-   * TODO Move to OkHttpClient as non-static once web sockets are finalized!
    */
-  public static WebSocketCall newWebSocketCall(OkHttpClient client, Request request) {
+  public static WebSocketCall create(OkHttpClient client, Request request) {
     return new WebSocketCall(client, request);
   }
 
@@ -51,7 +52,7 @@ public static WebSocketCall newWebSocketCall(OkHttpClient client, Request reques
   private final Random random;
   private final String key;
 
-  protected WebSocketCall(OkHttpClient client, Request request) {
+  WebSocketCall(OkHttpClient client, Request request) {
     this(client, request, new SecureRandom());
   }
 
@@ -59,19 +60,6 @@ protected WebSocketCall(OkHttpClient client, Request request) {
     if (!"GET".equals(request.method())) {
       throw new IllegalArgumentException("Request must be GET: " + request.method());
     }
-    String url = request.urlString();
-    String httpUrl;
-    if (url.startsWith("ws://")) {
-      httpUrl = "http://" + url.substring(5);
-    } else if (url.startsWith("wss://")) {
-      httpUrl = "https://" + url.substring(6);
-    } else if (url.startsWith("http://") || url.startsWith("https://")) {
-      httpUrl = url;
-    } else {
-      throw new IllegalArgumentException(
-          "Request url must use 'ws', 'wss', 'http', or 'https' scheme: " + url);
-    }
-
     this.random = random;
 
     byte[] nonce = new byte[16];
@@ -85,7 +73,6 @@ protected WebSocketCall(OkHttpClient client, Request request) {
     client.setProtocols(Collections.singletonList(com.squareup.okhttp.Protocol.HTTP_1_1));
 
     request = request.newBuilder()
-        .url(httpUrl)
         .header("Upgrade", "websocket")
         .header("Connection", "Upgrade")
         .header("Sec-WebSocket-Key", key)
@@ -114,12 +101,12 @@ public void enqueue(final WebSocketListener listener) {
         try {
           createWebSocket(response, listener);
         } catch (IOException e) {
-          listener.onFailure(e);
+          listener.onFailure(e, response);
         }
       }
 
       @Override public void onFailure(Request request, IOException e) {
-        listener.onFailure(e);
+        listener.onFailure(e, null);
       }
     };
     // TODO call.enqueue(responseCallback, true);
@@ -170,34 +157,40 @@ private void createWebSocket(Response response, WebSocketListener listener)
       throw new IllegalStateException("Unable to take ownership of connection.");
     }
 
-    Socket socket = connection.getSocket();
-    BufferedSource source = Okio.buffer(Okio.source(socket));
-    BufferedSink sink = Okio.buffer(Okio.sink(socket));
+    BufferedSource source = Internal.instance.connectionRawSource(connection);
+    BufferedSink sink = Internal.instance.connectionRawSink(connection);
 
     final RealWebSocket webSocket =
-        new ConnectionWebSocket(response, connection, source, sink, random, listener);
-
-    // Start a dedicated thread for reading the web socket.
-    new Thread(new NamedRunnable("OkHttp WebSocket reader %s", request.urlString()) {
-      @Override protected void execute() {
-        while (webSocket.readMessage()) {
-        }
-      }
-    }).start();
+        ConnectionWebSocket.create(response, connection, source, sink, random, listener);
 
     // TODO connection.setOwner(webSocket);
     Internal.instance.connectionSetOwner(connection, webSocket);
 
-    listener.onOpen(webSocket, request, response);
+    listener.onOpen(webSocket, response);
+
+    while (webSocket.readMessage()) {
+    }
   }
 
   // Keep static so that the WebSocketCall instance can be garbage collected.
   private static class ConnectionWebSocket extends RealWebSocket {
+    static RealWebSocket create(Response response, Connection connection, BufferedSource source,
+        BufferedSink sink, Random random, WebSocketListener listener) {
+      String url = response.request().urlString();
+      ThreadPoolExecutor replyExecutor =
+          new ThreadPoolExecutor(1, 1, 1, SECONDS, new LinkedBlockingDeque<Runnable>(),
+              Util.threadFactory(String.format("OkHttp %s WebSocket", url), true));
+      replyExecutor.allowCoreThreadTimeOut(true);
+
+      return new ConnectionWebSocket(connection, source, sink, random, replyExecutor, listener,
+          url);
+    }
+
     private final Connection connection;
 
-    public ConnectionWebSocket(Response response, Connection connection, BufferedSource source,
-        BufferedSink sink, Random random, WebSocketListener listener) {
-      super(true /* is client */, source, sink, random, listener, response.request().urlString());
+    private ConnectionWebSocket(Connection connection, BufferedSource source, BufferedSink sink,
+        Random random, Executor replyExecutor, WebSocketListener listener, String url) {
+      super(true /* is client */, source, sink, random, replyExecutor, listener, url);
       this.connection = connection;
     }
 
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/ws/WebSocketListener.java b/okhttp-ws/src/main/java/com/squareup/okhttp/ws/WebSocketListener.java
similarity index 58%
rename from okhttp/src/main/java/com/squareup/okhttp/internal/ws/WebSocketListener.java
rename to okhttp-ws/src/main/java/com/squareup/okhttp/ws/WebSocketListener.java
index 84f7cc0d78..8941b7443b 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/ws/WebSocketListener.java
+++ b/okhttp-ws/src/main/java/com/squareup/okhttp/ws/WebSocketListener.java
@@ -13,24 +13,43 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.squareup.okhttp.internal.ws;
+package com.squareup.okhttp.ws;
 
-import com.squareup.okhttp.Request;
 import com.squareup.okhttp.Response;
 import java.io.IOException;
 import okio.Buffer;
 import okio.BufferedSource;
 
-import static com.squareup.okhttp.internal.ws.WebSocket.PayloadType;
+import static com.squareup.okhttp.ws.WebSocket.PayloadType;
 
-// TODO move to public API!
 /** Listener for server-initiated messages on a connected {@link WebSocket}. */
 public interface WebSocketListener {
-  void onOpen(WebSocket webSocket, Request request, Response response) throws IOException;
+  /**
+   * Called when the request has successfully been upgraded to a web socket. This method is called
+   * on the message reading thread to allow setting up any state before the
+   * {@linkplain #onMessage message}, {@linkplain #onPong pong}, and {@link #onClose close}
+   * callbacks start.
+   * <p>
+   * <b>Do not</b> use this callback to write to the web socket. Start a new thread or use
+   * another thread in your application.
+   */
+  void onOpen(WebSocket webSocket, Response response);
+
+  /**
+   * Called when the transport or protocol layer of this web socket errors during communication.
+   *
+   * @param response Present when the failure is a direct result of the response (e.g., failed
+   * upgrade, non-101 response code, etc.). {@code null} otherwise.
+   */
+  void onFailure(IOException e, Response response);
 
   /**
    * Called when a server message is received. The {@code type} indicates whether the
    * {@code payload} should be interpreted as UTF-8 text or binary data.
+   *
+   * <p>Implementations <strong>must</strong> call {@code source.close()} before returning. This
+   * indicates completion of parsing the message payload and will consume any remaining bytes in
+   * the message.
    */
   void onMessage(BufferedSource payload, PayloadType type) throws IOException;
 
@@ -45,12 +64,9 @@
    * from a call to {@link WebSocket#close(int, String) close()} or as an unprompted
    * message from the server.
    *
-   * @param code The <a href="http://tools.ietf.org/html/rfc6455#section-7.4.1>RFC-compliant</a>
+   * @param code The <a href="http://tools.ietf.org/html/rfc6455#section-7.4.1">RFC-compliant</a>
    * status code.
    * @param reason Reason for close or an empty string.
    */
   void onClose(int code, String reason);
-
-  /** Called when the transport or protocol layer of this web socket errors during communication. */
-  void onFailure(IOException e);
 }
diff --git a/okhttp/pom.xml b/okhttp/pom.xml
index b7232214f7..5cd118711a 100644
--- a/okhttp/pom.xml
+++ b/okhttp/pom.xml
@@ -6,7 +6,7 @@
   <parent>
     <groupId>com.squareup.okhttp</groupId>
     <artifactId>parent</artifactId>
-    <version>2.3.0-SNAPSHOT</version>
+    <version>2.6.0-SNAPSHOT</version>
   </parent>
 
   <artifactId>okhttp</artifactId>
diff --git a/okhttp/src/main/java/com/squareup/okhttp/Address.java b/okhttp/src/main/java/com/squareup/okhttp/Address.java
index 38768a4004..6f6ce08d5f 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/Address.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/Address.java
@@ -139,6 +139,13 @@ public ProxySelector getProxySelector() {
     return proxySelector;
   }
 
+  /**
+   * Returns this address's certificate pinner. Only used for secure connections.
+   */
+  public CertificatePinner getCertificatePinner() {
+    return certificatePinner;
+  }
+
   @Override public boolean equals(Object other) {
     if (other instanceof Address) {
       Address that = (Address) other;
diff --git a/okhttp/src/main/java/com/squareup/okhttp/Cache.java b/okhttp/src/main/java/com/squareup/okhttp/Cache.java
index 2b98355e8c..dcf363486e 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/Cache.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/Cache.java
@@ -24,7 +24,7 @@
 import com.squareup.okhttp.internal.http.HttpMethod;
 import com.squareup.okhttp.internal.http.OkHeaders;
 import com.squareup.okhttp.internal.http.StatusLine;
-import java.io.ByteArrayInputStream;
+import com.squareup.okhttp.internal.io.FileSystem;
 import java.io.File;
 import java.io.IOException;
 import java.security.cert.Certificate;
@@ -36,6 +36,7 @@
 import java.util.Iterator;
 import java.util.List;
 import java.util.NoSuchElementException;
+import okio.Buffer;
 import okio.BufferedSink;
 import okio.BufferedSource;
 import okio.ByteString;
@@ -46,61 +47,86 @@
 import okio.Source;
 
 /**
- * Caches HTTP and HTTPS responses to the filesystem so they may be reused,
- * saving time and bandwidth.
+ * Caches HTTP and HTTPS responses to the filesystem so they may be reused, saving time and
+ * bandwidth.
  *
  * <h3>Cache Optimization</h3>
  * To measure cache effectiveness, this class tracks three statistics:
  * <ul>
- *     <li><strong>{@linkplain #getRequestCount() Request Count:}</strong> the
- *         number of HTTP requests issued since this cache was created.
- *     <li><strong>{@linkplain #getNetworkCount() Network Count:}</strong> the
- *         number of those requests that required network use.
- *     <li><strong>{@linkplain #getHitCount() Hit Count:}</strong> the number of
- *         those requests whose responses were served by the cache.
+ *   <li><strong>{@linkplain #getRequestCount() Request Count:}</strong> the number of HTTP
+ *     requests issued since this cache was created.
+ *   <li><strong>{@linkplain #getNetworkCount() Network Count:}</strong> the number of those
+ *     requests that required network use.
+ *   <li><strong>{@linkplain #getHitCount() Hit Count:}</strong> the number of those requests whose
+ *     responses were served by the cache.
  * </ul>
- * Sometimes a request will result in a conditional cache hit. If the cache
- * contains a stale copy of the response, the client will issue a conditional
- * {@code GET}. The server will then send either the updated response if it has
- * changed, or a short 'not modified' response if the client's copy is still
- * valid. Such responses increment both the network count and hit count.
  *
- * <p>The best way to improve the cache hit rate is by configuring the web
- * server to return cacheable responses. Although this client honors all <a
- * href="http://www.ietf.org/rfc/rfc2616.txt">HTTP/1.1 (RFC 2068)</a> cache
- * headers, it doesn't cache partial responses.
+ * Sometimes a request will result in a conditional cache hit. If the cache contains a stale copy of
+ * the response, the client will issue a conditional {@code GET}. The server will then send either
+ * the updated response if it has changed, or a short 'not modified' response if the client's copy
+ * is still valid. Such responses increment both the network count and hit count.
+ *
+ * <p>The best way to improve the cache hit rate is by configuring the web server to return
+ * cacheable responses. Although this client honors all <a
+ * href="http://tools.ietf.org/html/rfc7234">HTTP/1.1 (RFC 7234)</a> cache headers, it doesn't cache
+ * partial responses.
  *
  * <h3>Force a Network Response</h3>
- * In some situations, such as after a user clicks a 'refresh' button, it may be
- * necessary to skip the cache, and fetch data directly from the server. To force
- * a full refresh, add the {@code no-cache} directive: <pre>   {@code
- *         connection.addRequestProperty("Cache-Control", "no-cache");
+ * In some situations, such as after a user clicks a 'refresh' button, it may be necessary to skip
+ * the cache, and fetch data directly from the server. To force a full refresh, add the {@code
+ * no-cache} directive: <pre>   {@code
+ *
+ *   Request request = new Request.Builder()
+ *       .cacheControl(new CacheControl.Builder().noCache().build())
+ *       .url("http://publicobject.com/helloworld.txt")
+ *       .build();
  * }</pre>
- * If it is only necessary to force a cached response to be validated by the
- * server, use the more efficient {@code max-age=0} instead: <pre>   {@code
- *         connection.addRequestProperty("Cache-Control", "max-age=0");
+ *
+ * If it is only necessary to force a cached response to be validated by the server, use the more
+ * efficient {@code max-age=0} directive instead: <pre>   {@code
+ *
+ *   Request request = new Request.Builder()
+ *       .cacheControl(new CacheControl.Builder()
+ *           .maxAge(0, TimeUnit.SECONDS)
+ *           .build())
+ *       .url("http://publicobject.com/helloworld.txt")
+ *       .build();
  * }</pre>
  *
  * <h3>Force a Cache Response</h3>
- * Sometimes you'll want to show resources if they are available immediately,
- * but not otherwise. This can be used so your application can show
- * <i>something</i> while waiting for the latest data to be downloaded. To
- * restrict a request to locally-cached resources, add the {@code
+ * Sometimes you'll want to show resources if they are available immediately, but not otherwise.
+ * This can be used so your application can show <i>something</i> while waiting for the latest data
+ * to be downloaded. To restrict a request to locally-cached resources, add the {@code
  * only-if-cached} directive: <pre>   {@code
- *     try {
- *         connection.addRequestProperty("Cache-Control", "only-if-cached");
- *         InputStream cached = connection.getInputStream();
- *         // the resource was cached! show it
- *     } catch (FileNotFoundException e) {
- *         // the resource was not cached
+ *
+ *     Request request = new Request.Builder()
+ *         .cacheControl(new CacheControl.Builder()
+ *             .onlyIfCached()
+ *             .build())
+ *         .url("http://publicobject.com/helloworld.txt")
+ *         .build();
+ *     Response forceCacheResponse = client.newCall(request).execute();
+ *     if (forceCacheResponse.code() != 504) {
+ *       // The resource was cached! Show it.
+ *     } else {
+ *       // The resource was not cached.
  *     }
  * }</pre>
- * This technique works even better in situations where a stale response is
- * better than no response. To permit stale cached responses, use the {@code
- * max-stale} directive with the maximum staleness in seconds: <pre>   {@code
- *         int maxStale = 60 * 60 * 24 * 28; // tolerate 4-weeks stale
- *         connection.addRequestProperty("Cache-Control", "max-stale=" + maxStale);
+ * This technique works even better in situations where a stale response is better than no response.
+ * To permit stale cached responses, use the {@code max-stale} directive with the maximum staleness
+ * in seconds: <pre>   {@code
+ *
+ *   Request request = new Request.Builder()
+ *       .cacheControl(new CacheControl.Builder()
+ *           .maxStale(365, TimeUnit.DAYS)
+ *           .build())
+ *       .url("http://publicobject.com/helloworld.txt")
+ *       .build();
  * }</pre>
+ *
+ * <p>The {@link CacheControl} class can configure request caching directives and parse response
+ * caching directives. It even offers convenient constants {@link CacheControl#FORCE_NETWORK} and
+ * {@link CacheControl#FORCE_CACHE} that address the use cases above.
  */
 public final class Cache {
   private static final int VERSION = 201105;
@@ -139,7 +165,11 @@
   private int requestCount;
 
   public Cache(File directory, long maxSize) {
-    cache = DiskLruCache.create(directory, VERSION, ENTRY_COUNT, maxSize);
+    this(directory, maxSize, FileSystem.SYSTEM);
+  }
+
+  Cache(File directory, long maxSize, FileSystem fileSystem) {
+    this.cache = DiskLruCache.create(fileSystem, directory, VERSION, ENTRY_COUNT, maxSize);
   }
 
   private static String urlToKey(Request request) {
@@ -243,6 +273,23 @@ private void abortQuietly(DiskLruCache.Editor editor) {
     }
   }
 
+  /**
+   * Initialize the cache. This will include reading the journal files from
+   * the storage and building up the necessary in-memory cache information.
+   * <p>
+   * The initialization time may vary depending on the journal file size and
+   * the current actual cache size. The application needs to be aware of calling
+   * this function during the initialization phase and preferably in a background
+   * worker thread.
+   * <p>
+   * Note that if the application chooses to not call this method to initialize
+   * the cache. By default, the okhttp will perform lazy initialization upon the
+   * first usage of the cache.
+   */
+  public void initialize() throws IOException {
+    cache.initialize();
+  }
+
   /**
    * Closes the cache and deletes all of its stored values. This will delete
    * all files in the cache directory including files that weren't created by
@@ -534,7 +581,7 @@ public void writeTo(DiskLruCache.Editor editor) throws IOException {
       sink.writeByte('\n');
       sink.writeUtf8(requestMethod);
       sink.writeByte('\n');
-      sink.writeUtf8(Integer.toString(varyHeaders.size()));
+      sink.writeDecimalLong(varyHeaders.size());
       sink.writeByte('\n');
       for (int i = 0, size = varyHeaders.size(); i < size; i++) {
         sink.writeUtf8(varyHeaders.name(i));
@@ -545,7 +592,7 @@ public void writeTo(DiskLruCache.Editor editor) throws IOException {
 
       sink.writeUtf8(new StatusLine(protocol, code, message).toString());
       sink.writeByte('\n');
-      sink.writeUtf8(Integer.toString(responseHeaders.size()));
+      sink.writeDecimalLong(responseHeaders.size());
       sink.writeByte('\n');
       for (int i = 0, size = responseHeaders.size(); i < size; i++) {
         sink.writeUtf8(responseHeaders.name(i));
@@ -558,8 +605,8 @@ public void writeTo(DiskLruCache.Editor editor) throws IOException {
         sink.writeByte('\n');
         sink.writeUtf8(handshake.cipherSuite());
         sink.writeByte('\n');
-        writeCertArray(sink, handshake.peerCertificates());
-        writeCertArray(sink, handshake.localCertificates());
+        writeCertList(sink, handshake.peerCertificates());
+        writeCertList(sink, handshake.localCertificates());
       }
       sink.close();
     }
@@ -577,8 +624,9 @@ private boolean isHttps() {
         List<Certificate> result = new ArrayList<>(length);
         for (int i = 0; i < length; i++) {
           String line = source.readUtf8LineStrict();
-          byte[] bytes = ByteString.decodeBase64(line).toByteArray();
-          result.add(certificateFactory.generateCertificate(new ByteArrayInputStream(bytes)));
+          Buffer bytes = new Buffer();
+          bytes.write(ByteString.decodeBase64(line));
+          result.add(certificateFactory.generateCertificate(bytes.inputStream()));
         }
         return result;
       } catch (CertificateException e) {
@@ -586,10 +634,10 @@ private boolean isHttps() {
       }
     }
 
-    private void writeCertArray(BufferedSink sink, List<Certificate> certificates)
+    private void writeCertList(BufferedSink sink, List<Certificate> certificates)
         throws IOException {
       try {
-        sink.writeUtf8(Integer.toString(certificates.size()));
+        sink.writeDecimalLong(certificates.size());
         sink.writeByte('\n');
         for (int i = 0, size = certificates.size(); i < size; i++) {
           byte[] bytes = certificates.get(i).getEncoded();
@@ -629,11 +677,15 @@ public Response response(Request request, DiskLruCache.Snapshot snapshot) {
   }
 
   private static int readInt(BufferedSource source) throws IOException {
-    String line = source.readUtf8LineStrict();
     try {
-      return Integer.parseInt(line);
+      long result = source.readDecimalLong();
+      String line = source.readUtf8LineStrict();
+      if (result < 0 || result > Integer.MAX_VALUE || !line.isEmpty()) {
+        throw new IOException("expected an int but was \"" + result + line + "\"");
+      }
+      return (int) result;
     } catch (NumberFormatException e) {
-      throw new IOException("Expected an integer but was \"" + line + "\"");
+      throw new IOException(e.getMessage());
     }
   }
 
diff --git a/okhttp/src/main/java/com/squareup/okhttp/Call.java b/okhttp/src/main/java/com/squareup/okhttp/Call.java
index c4742c2799..33561ba24e 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/Call.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/Call.java
@@ -17,10 +17,10 @@
 
 import com.squareup.okhttp.internal.NamedRunnable;
 import com.squareup.okhttp.internal.http.HttpEngine;
+import com.squareup.okhttp.internal.http.RequestException;
+import com.squareup.okhttp.internal.http.RouteException;
 import java.io.IOException;
-import java.net.MalformedURLException;
 import java.net.ProtocolException;
-import java.net.URL;
 import java.util.logging.Level;
 
 import static com.squareup.okhttp.internal.Internal.logger;
@@ -137,7 +137,7 @@ private AsyncCall(Callback responseCallback, boolean forWebSocket) {
     }
 
     String host() {
-      return originalRequest.url().getHost();
+      return originalRequest.httpUrl().host();
     }
 
     Request request() {
@@ -186,12 +186,8 @@ Call get() {
    */
   private String toLoggableString() {
     String string = canceled ? "canceled call" : "call";
-    try {
-      String redactedUrl = new URL(originalRequest.url(), "/...").toString();
-      return string + " to " + redactedUrl;
-    } catch (MalformedURLException e) {
-      return string;
-    }
+    HttpUrl redactedUrl = originalRequest.httpUrl().resolve("/...");
+    return string + " to " + redactedUrl;
   }
 
   private Response getResponseWithInterceptorChain(boolean forWebSocket) throws IOException {
@@ -264,13 +260,26 @@ Response getResponse(Request request, boolean forWebSocket) throws IOException {
     while (true) {
       if (canceled) {
         engine.releaseConnection();
-        return null;
+        throw new IOException("Canceled");
       }
 
       try {
         engine.sendRequest();
         engine.readResponse();
+      } catch (RequestException e) {
+        // The attempt to interpret the request failed. Give up.
+        throw e.getCause();
+      } catch (RouteException e) {
+        // The attempt to connect via a route failed. The request will not have been sent.
+        HttpEngine retryEngine = engine.recover(e);
+        if (retryEngine != null) {
+          engine = retryEngine;
+          continue;
+        }
+        // Give up; recovery is not possible.
+        throw e.getLastConnectException();
       } catch (IOException e) {
+        // An attempt to communicate with a server failed. The request may have been sent.
         HttpEngine retryEngine = engine.recover(e, null);
         if (retryEngine != null) {
           engine = retryEngine;
@@ -295,7 +304,7 @@ Response getResponse(Request request, boolean forWebSocket) throws IOException {
         throw new ProtocolException("Too many follow-up requests: " + followUpCount);
       }
 
-      if (!engine.sameConnection(followUp.url())) {
+      if (!engine.sameConnection(followUp.httpUrl())) {
         engine.releaseConnection();
       }
 
diff --git a/okhttp/src/main/java/com/squareup/okhttp/CertificatePinner.java b/okhttp/src/main/java/com/squareup/okhttp/CertificatePinner.java
index 2c5a2af095..15a29527dc 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/CertificatePinner.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/CertificatePinner.java
@@ -18,15 +18,16 @@
 import com.squareup.okhttp.internal.Util;
 import java.security.cert.Certificate;
 import java.security.cert.X509Certificate;
-import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.LinkedHashMap;
+import java.util.LinkedHashSet;
 import java.util.List;
 import java.util.Map;
+import java.util.Set;
 import javax.net.ssl.SSLPeerUnverifiedException;
 import okio.ByteString;
 
-import static java.util.Collections.unmodifiableList;
+import static java.util.Collections.unmodifiableSet;
 
 /**
  * Constrains which certificates are trusted. Pinning certificates defends
@@ -91,8 +92,28 @@
  *       .build();
  * }</pre>
  *
- * Pinning is per-hostname. To pin both {@code publicobject.com} and {@code
- * www.publicobject.com}, you must configure both hostnames.
+ * Pinning is per-hostname and/or per-wildcard pattern. To pin both
+ * {@code publicobject.com} and {@code www.publicobject.com}, you must
+ * configure both hostnames.
+ *
+ * <p>Wildcard pattern rules:
+ * <ol>
+ *   <li>Asterisk {@code *} is only permitted in the left-most
+ *       domain name label and must be the only character in that label
+ *       (i.e., must match the whole left-most label). For example,
+ *       {@code *.example.com} is permitted, while {@code *a.example.com},
+ *       {@code a*.example.com}, {@code a*b.example.com}, {@code a.*.example.com}
+ *       are not permitted.
+ *   <li>Asterisk {@code *} cannot match across domain name labels.
+ *       For example, {@code *.example.com} matches {@code test.example.com}
+ *       but does not match {@code sub.test.example.com}.
+ *   <li>Wildcard patterns for single-label domain names are not permitted.
+ * </ol>
+ *
+ * If hostname pinned directly and via wildcard pattern, both
+ * direct and wildcard pins will be used. For example: {@code *.example.com} pinned
+ * with {@code pin1} and {@code a.example.com} pinned with {@code pin2},
+ * to check {@code a.example.com} both {@code pin1} and {@code pin2} will be used.
  *
  * <h3>Warning: Certificate Pinning is Dangerous!</h3>
  * Pinning certificates limits your server team's abilities to update their TLS
@@ -100,11 +121,18 @@
  * complexity and limit your ability to migrate between certificate authorities.
  * Do not use certificate pinning without the blessing of your server's TLS
  * administrator!
+ *
+ * <h4>Note about self-signed certificates</h4>
+ * {@link CertificatePinner} can not be used to pin self-signed certificate
+ * if such certificate is not accepted by {@link javax.net.ssl.TrustManager}.
+ *
+ * @see <a href="https://www.owasp.org/index.php/Certificate_and_Public_Key_Pinning">
+ *     OWASP: Certificate and Public Key Pinning</a>
  */
 public final class CertificatePinner {
   public static final CertificatePinner DEFAULT = new Builder().build();
 
-  private final Map<String, List<ByteString>> hostnameToPins;
+  private final Map<String, Set<ByteString>> hostnameToPins;
 
   private CertificatePinner(Builder builder) {
     hostnameToPins = Util.immutableMap(builder.hostnameToPins);
@@ -121,7 +149,9 @@ private CertificatePinner(Builder builder) {
    */
   public void check(String hostname, List<Certificate> peerCertificates)
       throws SSLPeerUnverifiedException {
-    List<ByteString> pins = hostnameToPins.get(hostname);
+
+    Set<ByteString> pins = findMatchingPins(hostname);
+
     if (pins == null) return;
 
     for (int i = 0, size = peerCertificates.size(); i < size; i++) {
@@ -139,8 +169,7 @@ public void check(String hostname, List<Certificate> peerCertificates)
           .append(": ").append(x509Certificate.getSubjectDN().getName());
     }
     message.append("\n  Pinned certificates for ").append(hostname).append(":");
-    for (int i = 0, size = pins.size(); i < size; i++) {
-      ByteString pin = pins.get(i);
+    for (ByteString pin : pins) {
       message.append("\n    sha1/").append(pin.base64());
     }
     throw new SSLPeerUnverifiedException(message.toString());
@@ -152,6 +181,39 @@ public void check(String hostname, Certificate... peerCertificates)
     check(hostname, Arrays.asList(peerCertificates));
   }
 
+  /**
+   * Returns list of matching certificates' pins for the hostname
+   * or {@code null} if hostname does not have pinned certificates.
+   */
+  Set<ByteString> findMatchingPins(String hostname) {
+    Set<ByteString> directPins   = hostnameToPins.get(hostname);
+    Set<ByteString> wildcardPins = null;
+
+    int indexOfFirstDot = hostname.indexOf('.');
+    int indexOfLastDot  = hostname.lastIndexOf('.');
+
+    // Skip hostnames with one dot symbol for wildcard pattern search
+    //   example.com   will  be skipped
+    //   a.example.com won't be skipped
+    if (indexOfFirstDot != indexOfLastDot) {
+      // a.example.com -> search for wildcard pattern *.example.com
+      wildcardPins = hostnameToPins.get("*." + hostname.substring(indexOfFirstDot + 1));
+    }
+
+    if (directPins == null && wildcardPins == null) return null;
+
+    if (directPins != null && wildcardPins != null) {
+      Set<ByteString> pins = new LinkedHashSet<>();
+      pins.addAll(directPins);
+      pins.addAll(wildcardPins);
+      return pins;
+    }
+
+    if (directPins != null) return directPins;
+
+    return wildcardPins;
+  }
+
   /**
    * Returns the SHA-1 of {@code certificate}'s public key. This uses the
    * mechanism Moxie Marlinspike describes in <a
@@ -170,18 +232,21 @@ private static ByteString sha1(X509Certificate x509Certificate) {
 
   /** Builds a configured certificate pinner. */
   public static final class Builder {
-    private final Map<String, List<ByteString>> hostnameToPins = new LinkedHashMap<>();
+    private final Map<String, Set<ByteString>> hostnameToPins = new LinkedHashMap<>();
 
     /**
-     * Pins certificates for {@code hostname}. Each pin is a SHA-1 hash of a
-     * certificate's Subject Public Key Info, base64-encoded and prefixed with
-     * "sha1/".
+     * Pins certificates for {@code hostname}.
+     *
+     * @param hostname lower-case host name or wildcard pattern such as {@code *.example.com}.
+     * @param pins SHA-1 hashes. Each pin is a SHA-1 hash of a
+     *     certificate's Subject Public Key Info, base64-encoded and prefixed with
+     *     {@code sha1/}.
      */
     public Builder add(String hostname, String... pins) {
       if (hostname == null) throw new IllegalArgumentException("hostname == null");
 
-      List<ByteString> hostPins = new ArrayList<>();
-      List<ByteString> previousPins = hostnameToPins.put(hostname, unmodifiableList(hostPins));
+      Set<ByteString> hostPins = new LinkedHashSet<>();
+      Set<ByteString> previousPins = hostnameToPins.put(hostname, unmodifiableSet(hostPins));
       if (previousPins != null) {
         hostPins.addAll(previousPins);
       }
diff --git a/okhttp/src/main/java/com/squareup/okhttp/Connection.java b/okhttp/src/main/java/com/squareup/okhttp/Connection.java
index 8d8586ea07..2a3614e8d7 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/Connection.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/Connection.java
@@ -16,27 +16,33 @@
  */
 package com.squareup.okhttp;
 
+import com.squareup.okhttp.internal.ConnectionSpecSelector;
 import com.squareup.okhttp.internal.Platform;
 import com.squareup.okhttp.internal.Util;
+import com.squareup.okhttp.internal.framed.FramedConnection;
+import com.squareup.okhttp.internal.http.FramedTransport;
 import com.squareup.okhttp.internal.http.HttpConnection;
 import com.squareup.okhttp.internal.http.HttpEngine;
 import com.squareup.okhttp.internal.http.HttpTransport;
 import com.squareup.okhttp.internal.http.OkHeaders;
-import com.squareup.okhttp.internal.http.SpdyTransport;
+import com.squareup.okhttp.internal.http.RouteException;
 import com.squareup.okhttp.internal.http.Transport;
-import com.squareup.okhttp.internal.spdy.SpdyConnection;
 import com.squareup.okhttp.internal.tls.OkHostnameVerifier;
 import java.io.IOException;
 import java.net.Proxy;
 import java.net.Socket;
-import java.net.URL;
+import java.net.UnknownServiceException;
 import java.security.cert.X509Certificate;
+import java.util.List;
 import java.util.concurrent.TimeUnit;
+import javax.net.ssl.SSLPeerUnverifiedException;
 import javax.net.ssl.SSLSocket;
+import javax.net.ssl.SSLSocketFactory;
+import okio.BufferedSink;
+import okio.BufferedSource;
 import okio.Source;
 
-import static com.squareup.okhttp.internal.Util.getDefaultPort;
-import static com.squareup.okhttp.internal.Util.getEffectivePort;
+import static com.squareup.okhttp.internal.Util.closeQuietly;
 import static java.net.HttpURLConnection.HTTP_OK;
 import static java.net.HttpURLConnection.HTTP_PROXY_AUTH;
 
@@ -73,7 +79,7 @@
   private Socket socket;
   private boolean connected = false;
   private HttpConnection httpConnection;
-  private SpdyConnection spdyConnection;
+  private FramedConnection framedConnection;
   private Protocol protocol = Protocol.HTTP_1_1;
   private long idleStartTimeNs;
   private Handshake handshake;
@@ -98,7 +104,7 @@ Object getOwner() {
   }
 
   void setOwner(Object owner) {
-    if (isSpdy()) return; // SPDY connections are shared.
+    if (isFramed()) return; // Framed connections are shared.
     synchronized (pool) {
       if (this.owner != null) throw new IllegalStateException("Connection already has an owner!");
       this.owner = owner;
@@ -128,7 +134,7 @@ boolean clearOwner() {
    * strips the ownership of the connection so it cannot be pooled or reused.
    */
   void closeIfOwnedBy(Object owner) throws IOException {
-    if (isSpdy()) throw new IllegalStateException();
+    if (isFramed()) throw new IllegalStateException();
     synchronized (pool) {
       if (this.owner != owner) {
         return; // Wrong owner. Perhaps a late disconnect?
@@ -138,48 +144,181 @@ void closeIfOwnedBy(Object owner) throws IOException {
     }
 
     // Don't close() inside the synchronized block.
-    socket.close();
+    if (socket != null) {
+      socket.close();
+    }
   }
 
-  void connect(int connectTimeout, int readTimeout, int writeTimeout, Request tunnelRequest)
-      throws IOException {
+  void connect(int connectTimeout, int readTimeout, int writeTimeout, Request request,
+      List<ConnectionSpec> connectionSpecs, boolean connectionRetryEnabled) throws RouteException {
     if (connected) throw new IllegalStateException("already connected");
 
-    if (route.proxy.type() == Proxy.Type.DIRECT || route.proxy.type() == Proxy.Type.HTTP) {
-      socket = route.address.socketFactory.createSocket();
-    } else {
-      socket = new Socket(route.proxy);
+    RouteException routeException = null;
+    ConnectionSpecSelector connectionSpecSelector = new ConnectionSpecSelector(connectionSpecs);
+    Proxy proxy = route.getProxy();
+    Address address = route.getAddress();
+
+    if (route.address.getSslSocketFactory() == null
+        && !connectionSpecs.contains(ConnectionSpec.CLEARTEXT)) {
+      throw new RouteException(new UnknownServiceException(
+          "CLEARTEXT communication not supported: " + connectionSpecs));
     }
 
+    while (!connected) {
+      try {
+        socket = proxy.type() == Proxy.Type.DIRECT || proxy.type() == Proxy.Type.HTTP
+            ? address.getSocketFactory().createSocket()
+            : new Socket(proxy);
+        connectSocket(connectTimeout, readTimeout, writeTimeout, request,
+            connectionSpecSelector);
+        connected = true; // Success!
+      } catch (IOException e) {
+        Util.closeQuietly(socket);
+        socket = null;
+
+        if (routeException == null) {
+          routeException = new RouteException(e);
+        } else {
+          routeException.addConnectException(e);
+        }
+
+        if (!connectionRetryEnabled || !connectionSpecSelector.connectionFailed(e)) {
+          throw routeException;
+        }
+      }
+    }
+  }
+
+  /** Does all the work necessary to build a full HTTP or HTTPS connection on a raw socket. */
+  private void connectSocket(int connectTimeout, int readTimeout, int writeTimeout,
+      Request request, ConnectionSpecSelector connectionSpecSelector) throws IOException {
     socket.setSoTimeout(readTimeout);
-    Platform.get().connectSocket(socket, route.inetSocketAddress, connectTimeout);
+    Platform.get().connectSocket(socket, route.getSocketAddress(), connectTimeout);
+
+    if (route.address.getSslSocketFactory() != null) {
+      connectTls(readTimeout, writeTimeout, request, connectionSpecSelector);
+    }
 
-    if (route.address.sslSocketFactory != null) {
-      upgradeToTls(tunnelRequest, readTimeout, writeTimeout);
+    if (protocol == Protocol.SPDY_3 || protocol == Protocol.HTTP_2) {
+      socket.setSoTimeout(0); // Framed connection timeouts are set per-stream.
+      framedConnection = new FramedConnection.Builder(route.address.uriHost, true, socket)
+          .protocol(protocol).build();
+      framedConnection.sendConnectionPreface();
     } else {
       httpConnection = new HttpConnection(pool, this, socket);
     }
-    connected = true;
+  }
+
+  private void connectTls(int readTimeout, int writeTimeout, Request request,
+      ConnectionSpecSelector connectionSpecSelector) throws IOException {
+    if (route.requiresTunnel()) {
+      createTunnel(readTimeout, writeTimeout, request);
+    }
+
+    Address address = route.getAddress();
+    SSLSocketFactory sslSocketFactory = address.getSslSocketFactory();
+    boolean success = false;
+    SSLSocket sslSocket = null;
+    try {
+      // Create the wrapper over the connected socket.
+      sslSocket = (SSLSocket) sslSocketFactory.createSocket(
+          socket, address.getUriHost(), address.getUriPort(), true /* autoClose */);
+
+      // Configure the socket's ciphers, TLS versions, and extensions.
+      ConnectionSpec connectionSpec = connectionSpecSelector.configureSecureSocket(sslSocket);
+      if (connectionSpec.supportsTlsExtensions()) {
+        Platform.get().configureTlsExtensions(
+            sslSocket, address.getUriHost(), address.getProtocols());
+      }
+
+      // Force handshake. This can throw!
+      sslSocket.startHandshake();
+      Handshake unverifiedHandshake = Handshake.get(sslSocket.getSession());
+
+      // Verify that the socket's certificates are acceptable for the target host.
+      if (!address.getHostnameVerifier().verify(address.getUriHost(), sslSocket.getSession())) {
+        X509Certificate cert = (X509Certificate) unverifiedHandshake.peerCertificates().get(0);
+        throw new SSLPeerUnverifiedException("Hostname " + address.getUriHost() + " not verified:"
+            + "\n    certificate: " + CertificatePinner.pin(cert)
+            + "\n    DN: " + cert.getSubjectDN().getName()
+            + "\n    subjectAltNames: " + OkHostnameVerifier.allSubjectAltNames(cert));
+      }
+
+      // Check that the certificate pinner is satisfied by the certificates presented.
+      address.getCertificatePinner().check(address.getUriHost(),
+          unverifiedHandshake.peerCertificates());
+
+      // Success! Save the handshake and the ALPN protocol.
+      String maybeProtocol = connectionSpec.supportsTlsExtensions()
+          ? Platform.get().getSelectedProtocol(sslSocket)
+          : null;
+      protocol = maybeProtocol != null
+          ? Protocol.get(maybeProtocol)
+          : Protocol.HTTP_1_1;
+      handshake = unverifiedHandshake;
+      socket = sslSocket;
+      success = true;
+    } catch (AssertionError e) {
+      if (Util.isAndroidGetsocknameError(e)) throw new IOException(e);
+      throw e;
+    } finally {
+      if (sslSocket != null) {
+        Platform.get().afterHandshake(sslSocket);
+      }
+      if (!success) {
+        closeQuietly(sslSocket);
+      }
+    }
   }
 
   /**
-   * Connects this connection if it isn't already. This creates tunnels, shares
-   * the connection with the connection pool, and configures timeouts.
+   * To make an HTTPS connection over an HTTP proxy, send an unencrypted
+   * CONNECT request to create the proxy connection. This may need to be
+   * retried if the proxy requires authorization.
    */
-  void connectAndSetOwner(OkHttpClient client, Object owner, Request request) throws IOException {
-    setOwner(owner);
+  private void createTunnel(int readTimeout, int writeTimeout, Request request) throws IOException {
+    // Make an SSL Tunnel on the first message pair of each SSL + proxy connection.
+    Request tunnelRequest = createTunnelRequest(request);
+    HttpConnection tunnelConnection = new HttpConnection(pool, this, socket);
+    tunnelConnection.setTimeouts(readTimeout, writeTimeout);
+    HttpUrl url = tunnelRequest.httpUrl();
+    String requestLine = "CONNECT " + url.host() + ":" + url.port() + " HTTP/1.1";
+    while (true) {
+      tunnelConnection.writeRequest(tunnelRequest.headers(), requestLine);
+      tunnelConnection.flush();
+      Response response = tunnelConnection.readResponse().request(tunnelRequest).build();
+      // The response body from a CONNECT should be empty, but if it is not then we should consume
+      // it before proceeding.
+      long contentLength = OkHeaders.contentLength(response);
+      if (contentLength == -1L) {
+        contentLength = 0L;
+      }
+      Source body = tunnelConnection.newFixedLengthSource(contentLength);
+      Util.skipAll(body, Integer.MAX_VALUE, TimeUnit.MILLISECONDS);
+      body.close();
 
-    if (!isConnected()) {
-      Request tunnelRequest = tunnelRequest(request);
-      connect(client.getConnectTimeout(), client.getReadTimeout(),
-          client.getWriteTimeout(), tunnelRequest);
-      if (isSpdy()) {
-        client.getConnectionPool().share(this);
+      switch (response.code()) {
+        case HTTP_OK:
+          // Assume the server won't send a TLS ServerHello until we send a TLS ClientHello. If
+          // that happens, then we will have buffered bytes that are needed by the SSLSocket!
+          // This check is imperfect: it doesn't tell us whether a handshake will succeed, just
+          // that it will almost certainly fail because the proxy has sent unexpected data.
+          if (tunnelConnection.bufferSize() > 0) {
+            throw new IOException("TLS tunnel buffered too many bytes!");
+          }
+          return;
+
+        case HTTP_PROXY_AUTH:
+          tunnelRequest = OkHeaders.processAuthHeader(
+              route.getAddress().getAuthenticator(), response, route.getProxy());
+          if (tunnelRequest != null) continue;
+          throw new IOException("Failed to authenticate with proxy");
+
+        default:
+          throw new IOException(
+              "Unexpected response code for CONNECT: " + response.code());
       }
-      client.routeDatabase().connected(getRoute());
     }
-
-    setTimeouts(client.getReadTimeout(), client.getWriteTimeout());
   }
 
   /**
@@ -189,15 +328,15 @@ void connectAndSetOwner(OkHttpClient client, Object owner, Request request) thro
    * headers. This avoids sending potentially sensitive data like HTTP cookies
    * to the proxy unencrypted.
    */
-  private Request tunnelRequest(Request request) throws IOException {
-    if (!route.requiresTunnel()) return null;
-
-    String host = request.url().getHost();
-    int port = getEffectivePort(request.url());
-    String authority = (port == getDefaultPort("https")) ? host : (host + ":" + port);
+  private Request createTunnelRequest(Request request) throws IOException {
+    HttpUrl tunnelUrl = new HttpUrl.Builder()
+        .scheme("https")
+        .host(request.httpUrl().host())
+        .port(request.httpUrl().port())
+        .build();
     Request.Builder result = new Request.Builder()
-        .url(new URL("https", host, port, "/"))
-        .header("Host", authority)
+        .url(tunnelUrl)
+        .header("Host", Util.hostHeader(tunnelUrl))
         .header("Proxy-Connection", "Keep-Alive"); // For HTTP/1.0 proxies like Squid.
 
     // Copy over the User-Agent header if it exists.
@@ -216,61 +355,24 @@ private Request tunnelRequest(Request request) throws IOException {
   }
 
   /**
-   * Create an {@code SSLSocket} and perform the TLS handshake and certificate
-   * validation.
+   * Connects this connection if it isn't already. This creates tunnels, shares
+   * the connection with the connection pool, and configures timeouts.
    */
-  private void upgradeToTls(Request tunnelRequest, int readTimeout, int writeTimeout)
-      throws IOException {
-    Platform platform = Platform.get();
-
-    // Make an SSL Tunnel on the first message pair of each SSL + proxy connection.
-    if (tunnelRequest != null) {
-      makeTunnel(tunnelRequest, readTimeout, writeTimeout);
-    }
-
-    // Create the wrapper over connected socket.
-    socket = route.address.sslSocketFactory
-        .createSocket(socket, route.address.uriHost, route.address.uriPort, true /* autoClose */);
-    SSLSocket sslSocket = (SSLSocket) socket;
-
-    // Configure the socket's ciphers, TLS versions, and extensions.
-    route.connectionSpec.apply(sslSocket, route);
-
-    try {
-      // Force handshake. This can throw!
-      sslSocket.startHandshake();
+  void connectAndSetOwner(OkHttpClient client, Object owner, Request request)
+      throws RouteException {
+    setOwner(owner);
 
-      String maybeProtocol;
-      if (route.connectionSpec.supportsTlsExtensions()
-          && (maybeProtocol = platform.getSelectedProtocol(sslSocket)) != null) {
-        protocol = Protocol.get(maybeProtocol); // Throws IOE on unknown.
+    if (!isConnected()) {
+      List<ConnectionSpec> connectionSpecs = route.address.getConnectionSpecs();
+      connect(client.getConnectTimeout(), client.getReadTimeout(), client.getWriteTimeout(),
+          request, connectionSpecs, client.getRetryOnConnectionFailure());
+      if (isFramed()) {
+        client.getConnectionPool().share(this);
       }
-    } finally {
-      platform.afterHandshake(sslSocket);
-    }
-
-    handshake = Handshake.get(sslSocket.getSession());
-
-    // Verify that the socket's certificates are acceptable for the target host.
-    if (!route.address.hostnameVerifier.verify(route.address.uriHost, sslSocket.getSession())) {
-      X509Certificate cert = (X509Certificate) sslSocket.getSession().getPeerCertificates()[0];
-      throw new IOException("Hostname " + route.address.uriHost + " not verified:"
-          + "\n    certificate: " + CertificatePinner.pin(cert)
-          + "\n    DN: " + cert.getSubjectDN().getName()
-          + "\n    subjectAltNames: " + OkHostnameVerifier.allSubjectAltNames(cert));
+      client.routeDatabase().connected(getRoute());
     }
 
-    // Check that the certificate pinner is satisfied by the certificates presented.
-    route.address.certificatePinner.check(route.address.uriHost, handshake.peerCertificates());
-
-    if (protocol == Protocol.SPDY_3 || protocol == Protocol.HTTP_2) {
-      sslSocket.setSoTimeout(0); // SPDY timeouts are set per-stream.
-      spdyConnection = new SpdyConnection.Builder(route.address.getUriHost(), true, socket)
-          .protocol(protocol).build();
-      spdyConnection.sendConnectionPreface();
-    } else {
-      httpConnection = new HttpConnection(pool, this, socket);
-    }
+    setTimeouts(client.getReadTimeout(), client.getWriteTimeout());
   }
 
   /** Returns true if {@link #connect} has been attempted on this connection. */
@@ -291,6 +393,16 @@ public Socket getSocket() {
     return socket;
   }
 
+  BufferedSource rawSource() {
+    if (httpConnection == null) throw new UnsupportedOperationException();
+    return httpConnection.rawSource();
+  }
+
+  BufferedSink rawSink() {
+    if (httpConnection == null) throw new UnsupportedOperationException();
+    return httpConnection.rawSink();
+  }
+
   /** Returns true if this connection is alive. */
   boolean isAlive() {
     return !socket.isClosed() && !socket.isInputShutdown() && !socket.isOutputShutdown();
@@ -303,17 +415,17 @@ boolean isAlive() {
    */
   boolean isReadable() {
     if (httpConnection != null) return httpConnection.isReadable();
-    return true; // SPDY connections, and connections before connect() are both optimistic.
+    return true; // Framed connections, and connections before connect() are both optimistic.
   }
 
   void resetIdleStartTime() {
-    if (spdyConnection != null) throw new IllegalStateException("spdyConnection != null");
+    if (framedConnection != null) throw new IllegalStateException("framedConnection != null");
     this.idleStartTimeNs = System.nanoTime();
   }
 
   /** Returns true if this connection is idle. */
   boolean isIdle() {
-    return spdyConnection == null || spdyConnection.isIdle();
+    return framedConnection == null || framedConnection.isIdle();
   }
 
   /**
@@ -321,7 +433,7 @@ boolean isIdle() {
    * this connection is not idle.
    */
   long getIdleStartTimeNs() {
-    return spdyConnection == null ? idleStartTimeNs : spdyConnection.getIdleStartTimeNs();
+    return framedConnection == null ? idleStartTimeNs : framedConnection.getIdleStartTimeNs();
   }
 
   public Handshake getHandshake() {
@@ -330,8 +442,8 @@ public Handshake getHandshake() {
 
   /** Returns the transport appropriate for this connection. */
   Transport newTransport(HttpEngine httpEngine) throws IOException {
-    return (spdyConnection != null)
-        ? new SpdyTransport(httpEngine, spdyConnection)
+    return (framedConnection != null)
+        ? new FramedTransport(httpEngine, framedConnection)
         : new HttpTransport(httpEngine, httpConnection);
   }
 
@@ -339,8 +451,8 @@ Transport newTransport(HttpEngine httpEngine) throws IOException {
    * Returns true if this is a SPDY connection. Such connections can be used
    * in multiple HTTP requests simultaneously.
    */
-  boolean isSpdy() {
-    return spdyConnection != null;
+  boolean isFramed() {
+    return framedConnection != null;
   }
 
   /**
@@ -360,12 +472,17 @@ void setProtocol(Protocol protocol) {
     this.protocol = protocol;
   }
 
-  void setTimeouts(int readTimeoutMillis, int writeTimeoutMillis) throws IOException {
+  void setTimeouts(int readTimeoutMillis, int writeTimeoutMillis)
+      throws RouteException {
     if (!connected) throw new IllegalStateException("setTimeouts - not connected");
 
     // Don't set timeouts on shared SPDY connections.
     if (httpConnection != null) {
-      socket.setSoTimeout(readTimeoutMillis);
+      try {
+        socket.setSoTimeout(readTimeoutMillis);
+      } catch (IOException e) {
+        throw new RouteException(e);
+      }
       httpConnection.setTimeouts(readTimeoutMillis, writeTimeoutMillis);
     }
   }
@@ -382,55 +499,6 @@ int recycleCount() {
     return recycleCount;
   }
 
-  /**
-   * To make an HTTPS connection over an HTTP proxy, send an unencrypted
-   * CONNECT request to create the proxy connection. This may need to be
-   * retried if the proxy requires authorization.
-   */
-  private void makeTunnel(Request request, int readTimeout, int writeTimeout)
-      throws IOException {
-    HttpConnection tunnelConnection = new HttpConnection(pool, this, socket);
-    tunnelConnection.setTimeouts(readTimeout, writeTimeout);
-    URL url = request.url();
-    String requestLine = "CONNECT " + url.getHost() + ":" + url.getPort() + " HTTP/1.1";
-    while (true) {
-      tunnelConnection.writeRequest(request.headers(), requestLine);
-      tunnelConnection.flush();
-      Response response = tunnelConnection.readResponse().request(request).build();
-      // The response body from a CONNECT should be empty, but if it is not then we should consume
-      // it before proceeding.
-      long contentLength = OkHeaders.contentLength(response);
-      if (contentLength == -1L) {
-        contentLength = 0L;
-      }
-      Source body = tunnelConnection.newFixedLengthSource(contentLength);
-      Util.skipAll(body, Integer.MAX_VALUE, TimeUnit.MILLISECONDS);
-      body.close();
-
-      switch (response.code()) {
-        case HTTP_OK:
-          // Assume the server won't send a TLS ServerHello until we send a TLS ClientHello. If that
-          // happens, then we will have buffered bytes that are needed by the SSLSocket!
-          // This check is imperfect: it doesn't tell us whether a handshake will succeed, just that
-          // it will almost certainly fail because the proxy has sent unexpected data.
-          if (tunnelConnection.bufferSize() > 0) {
-            throw new IOException("TLS tunnel buffered too many bytes!");
-          }
-          return;
-
-        case HTTP_PROXY_AUTH:
-          request = OkHeaders.processAuthHeader(
-              route.address.authenticator, response, route.proxy);
-          if (request != null) continue;
-          throw new IOException("Failed to authenticate with proxy");
-
-        default:
-          throw new IOException(
-              "Unexpected response code for CONNECT: " + response.code());
-      }
-    }
-  }
-
   @Override public String toString() {
     return "Connection{"
         + route.address.uriHost + ":" + route.address.uriPort
diff --git a/okhttp/src/main/java/com/squareup/okhttp/ConnectionPool.java b/okhttp/src/main/java/com/squareup/okhttp/ConnectionPool.java
index ba664ea992..da3ac73c4d 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/ConnectionPool.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/ConnectionPool.java
@@ -122,7 +122,7 @@ public synchronized int getSpdyConnectionCount() {
   public synchronized int getMultiplexedConnectionCount() {
     int total = 0;
     for (Connection connection : connections) {
-      if (connection.isSpdy()) total++;
+      if (connection.isFramed()) total++;
     }
     return total;
   }
@@ -144,7 +144,7 @@ public synchronized Connection get(Address address) {
         continue;
       }
       i.remove();
-      if (!connection.isSpdy()) {
+      if (!connection.isFramed()) {
         try {
           Platform.get().tagSocket(connection.getSocket());
         } catch (SocketException e) {
@@ -158,7 +158,7 @@ public synchronized Connection get(Address address) {
       break;
     }
 
-    if (foundConnection != null && foundConnection.isSpdy()) {
+    if (foundConnection != null && foundConnection.isFramed()) {
       connections.addFirst(foundConnection); // Add it back after iteration.
     }
 
@@ -172,7 +172,7 @@ public synchronized Connection get(Address address) {
    * <p>It is an error to use {@code connection} after calling this method.
    */
   void recycle(Connection connection) {
-    if (connection.isSpdy()) {
+    if (connection.isFramed()) {
       return;
     }
 
@@ -216,7 +216,7 @@ private void addConnection(Connection connection) {
    * continue to use {@code connection}.
    */
   void share(Connection connection) {
-    if (!connection.isSpdy()) throw new IllegalArgumentException();
+    if (!connection.isFramed()) throw new IllegalArgumentException();
     if (!connection.isAlive()) return;
     synchronized (this) {
       addConnection(connection);
diff --git a/okhttp/src/main/java/com/squareup/okhttp/ConnectionSpec.java b/okhttp/src/main/java/com/squareup/okhttp/ConnectionSpec.java
index c075ecff91..5e0f7d868a 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/ConnectionSpec.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/ConnectionSpec.java
@@ -15,7 +15,6 @@
  */
 package com.squareup.okhttp;
 
-import com.squareup.okhttp.internal.Platform;
 import com.squareup.okhttp.internal.Util;
 import java.util.Arrays;
 import java.util.List;
@@ -23,36 +22,38 @@
 
 /**
  * Specifies configuration for the socket connection that HTTP traffic travels through. For {@code
- * https:} URLs, this includes the TLS version and ciphers to use when negotiating a secure
+ * https:} URLs, this includes the TLS version and cipher suites to use when negotiating a secure
  * connection.
  */
 public final class ConnectionSpec {
 
+  // This is a subset of the cipher suites supported in Chrome 37, current as of 2014-10-5.
+  // All of these suites are available on Android 5.0; earlier releases support a subset of
+  // these suites. https://github.com/square/okhttp/issues/330
+  private static final CipherSuite[] APPROVED_CIPHER_SUITES = new CipherSuite[] {
+      CipherSuite.TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256,
+      CipherSuite.TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256,
+      CipherSuite.TLS_DHE_RSA_WITH_AES_128_GCM_SHA256,
+
+      // Note that the following cipher suites are all on HTTP/2's bad cipher suites list. We'll
+      // continue to include them until better suites are commonly available. For example, none
+      // of the better cipher suites listed above shipped with Android 4.4 or Java 7.
+      CipherSuite.TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA,
+      CipherSuite.TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA,
+      CipherSuite.TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA,
+      CipherSuite.TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA,
+      CipherSuite.TLS_DHE_RSA_WITH_AES_128_CBC_SHA,
+      CipherSuite.TLS_DHE_DSS_WITH_AES_128_CBC_SHA,
+      CipherSuite.TLS_DHE_RSA_WITH_AES_256_CBC_SHA,
+      CipherSuite.TLS_RSA_WITH_AES_128_GCM_SHA256,
+      CipherSuite.TLS_RSA_WITH_AES_128_CBC_SHA,
+      CipherSuite.TLS_RSA_WITH_AES_256_CBC_SHA,
+      CipherSuite.TLS_RSA_WITH_3DES_EDE_CBC_SHA,
+  };
+
   /** A modern TLS connection with extensions like SNI and ALPN available. */
   public static final ConnectionSpec MODERN_TLS = new Builder(true)
-      .cipherSuites(
-          // This is a subset of the cipher suites supported in Chrome 37, current as of 2014-10-5.
-          // All of these suites are available on Android L; earlier releases support a subset of
-          // these suites. https://github.com/square/okhttp/issues/330
-          CipherSuite.TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256,
-          CipherSuite.TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256,
-          CipherSuite.TLS_DHE_RSA_WITH_AES_128_GCM_SHA256,
-          CipherSuite.TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA,
-          CipherSuite.TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA,
-          CipherSuite.TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA,
-          CipherSuite.TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA,
-          CipherSuite.TLS_ECDHE_ECDSA_WITH_RC4_128_SHA,
-          CipherSuite.TLS_ECDHE_RSA_WITH_RC4_128_SHA,
-          CipherSuite.TLS_DHE_RSA_WITH_AES_128_CBC_SHA,
-          CipherSuite.TLS_DHE_DSS_WITH_AES_128_CBC_SHA,
-          CipherSuite.TLS_DHE_RSA_WITH_AES_256_CBC_SHA,
-          CipherSuite.TLS_RSA_WITH_AES_128_GCM_SHA256,
-          CipherSuite.TLS_RSA_WITH_AES_128_CBC_SHA,
-          CipherSuite.TLS_RSA_WITH_AES_256_CBC_SHA,
-          CipherSuite.TLS_RSA_WITH_3DES_EDE_CBC_SHA,
-          CipherSuite.TLS_RSA_WITH_RC4_128_SHA,
-          CipherSuite.TLS_RSA_WITH_RC4_128_MD5
-      )
+      .cipherSuites(APPROVED_CIPHER_SUITES)
       .tlsVersions(TlsVersion.TLS_1_2, TlsVersion.TLS_1_1, TlsVersion.TLS_1_0)
       .supportsTlsExtensions(true)
       .build();
@@ -91,8 +92,8 @@ public boolean isTls() {
   }
 
   /**
-   * Return the cipher suites to use with the connection. This method can return {@code null} if the
-   * ciphers enabled by default should be used.
+   * Returns the cipher suites to use for a connection. This method can return {@code null} if the
+   * cipher suites enabled by default should be used.
    */
   public List<CipherSuite> cipherSuites() {
     if (cipherSuites == null) {
@@ -117,14 +118,32 @@ public boolean supportsTlsExtensions() {
     return supportsTlsExtensions;
   }
 
-  /** Applies this spec to {@code sslSocket} for {@code route}. */
-  void apply(SSLSocket sslSocket, Route route) {
-    ConnectionSpec specToApply = supportedSpec(sslSocket);
+  /** Applies this spec to {@code sslSocket}. */
+  void apply(SSLSocket sslSocket, boolean isFallback) {
+    ConnectionSpec specToApply = supportedSpec(sslSocket, isFallback);
 
     sslSocket.setEnabledProtocols(specToApply.tlsVersions);
 
     String[] cipherSuitesToEnable = specToApply.cipherSuites;
-    if (route.shouldSendTlsFallbackIndicator) {
+    // null means "use default set".
+    if (cipherSuitesToEnable != null) {
+      sslSocket.setEnabledCipherSuites(cipherSuitesToEnable);
+    }
+  }
+
+  /**
+   * Returns a copy of this that omits cipher suites and TLS versions not enabled by
+   * {@code sslSocket}.
+   */
+  private ConnectionSpec supportedSpec(SSLSocket sslSocket, boolean isFallback) {
+    String[] cipherSuitesToEnable = null;
+    if (cipherSuites != null) {
+      String[] cipherSuitesToSelectFrom = sslSocket.getEnabledCipherSuites();
+      cipherSuitesToEnable =
+          Util.intersect(String.class, cipherSuites, cipherSuitesToSelectFrom);
+    }
+
+    if (isFallback) {
       // In accordance with https://tools.ietf.org/html/draft-ietf-tls-downgrade-scsv-00
       // the SCSV cipher is added to signal that a protocol fallback has taken place.
       final String fallbackScsv = "TLS_FALLBACK_SCSV";
@@ -132,7 +151,7 @@ void apply(SSLSocket sslSocket, Route route) {
           Arrays.asList(sslSocket.getSupportedCipherSuites()).contains(fallbackScsv);
 
       if (socketSupportsFallbackScsv) {
-        // Add the SCSV cipher to the set of enabled ciphers iff it is supported.
+        // Add the SCSV cipher to the set of enabled cipher suites iff it is supported.
         String[] oldEnabledCipherSuites = cipherSuitesToEnable != null
             ? cipherSuitesToEnable
             : sslSocket.getEnabledCipherSuites();
@@ -143,35 +162,71 @@ void apply(SSLSocket sslSocket, Route route) {
         cipherSuitesToEnable = newEnabledCipherSuites;
       }
     }
-    // null means "use default set".
-    if (cipherSuitesToEnable != null) {
-      sslSocket.setEnabledCipherSuites(cipherSuitesToEnable);
+
+    String[] protocolsToSelectFrom = sslSocket.getEnabledProtocols();
+    String[] protocolsToEnable = Util.intersect(String.class, tlsVersions, protocolsToSelectFrom);
+    return new Builder(this)
+        .cipherSuites(cipherSuitesToEnable)
+        .tlsVersions(protocolsToEnable)
+        .build();
+  }
+
+  /**
+   * Returns {@code true} if the socket, as currently configured, supports this ConnectionSpec.
+   * In order for a socket to be compatible the enabled cipher suites and protocols must intersect.
+   *
+   * <p>For cipher suites, at least one of the {@link #cipherSuites() required cipher suites} must
+   * match the socket's enabled cipher suites. If there are no required cipher suites the socket
+   * must have at least one cipher suite enabled.
+   *
+   * <p>For protocols, at least one of the {@link #tlsVersions() required protocols} must match the
+   * socket's enabled protocols.
+   */
+  public boolean isCompatible(SSLSocket socket) {
+    if (!tls) {
+      return false;
     }
 
-    Platform platform = Platform.get();
-    if (specToApply.supportsTlsExtensions) {
-      platform.configureTlsExtensions(sslSocket, route.address.uriHost, route.address.protocols);
+    String[] enabledProtocols = socket.getEnabledProtocols();
+    boolean requiredProtocolsEnabled = nonEmptyIntersection(tlsVersions, enabledProtocols);
+    if (!requiredProtocolsEnabled) {
+      return false;
     }
+
+    boolean requiredCiphersEnabled;
+    if (cipherSuites == null) {
+      requiredCiphersEnabled = socket.getEnabledCipherSuites().length > 0;
+    } else {
+      String[] enabledCipherSuites = socket.getEnabledCipherSuites();
+      requiredCiphersEnabled = nonEmptyIntersection(cipherSuites, enabledCipherSuites);
+    }
+    return requiredCiphersEnabled;
   }
 
   /**
-   * Returns a copy of this that omits cipher suites and TLS versions not
-   * enabled by {@code sslSocket}.
+   * An N*M intersection that terminates if any intersection is found. The sizes of both
+   * arguments are assumed to be so small, and the likelihood of an intersection so great, that it
+   * is not worth the CPU cost of sorting or the memory cost of hashing.
    */
-  private ConnectionSpec supportedSpec(SSLSocket sslSocket) {
-    String[] cipherSuitesToEnable = null;
-    if (cipherSuites != null) {
-      String[] cipherSuitesToSelectFrom = sslSocket.getEnabledCipherSuites();
-      cipherSuitesToEnable =
-          Util.intersect(String.class, cipherSuites, cipherSuitesToSelectFrom);
+  private static boolean nonEmptyIntersection(String[] a, String[] b) {
+    if (a == null || b == null || a.length == 0 || b.length == 0) {
+      return false;
     }
+    for (String toFind : a) {
+      if (contains(b, toFind)) {
+        return true;
+      }
+    }
+    return false;
+  }
 
-    String[] protocolsToSelectFrom = sslSocket.getEnabledProtocols();
-    String[] tlsVersionsToEnable = Util.intersect(String.class, tlsVersions, protocolsToSelectFrom);
-    return new Builder(this)
-        .cipherSuites(cipherSuitesToEnable)
-        .tlsVersions(tlsVersionsToEnable)
-        .build();
+  private static <T> boolean contains(T[] array, T value) {
+    for (T arrayValue : array) {
+      if (Util.equal(value, arrayValue)) {
+        return true;
+      }
+    }
+    return false;
   }
 
   @Override public boolean equals(Object other) {
@@ -238,29 +293,48 @@ public Builder cipherSuites(CipherSuite... cipherSuites) {
       for (int i = 0; i < cipherSuites.length; i++) {
         strings[i] = cipherSuites[i].javaName;
       }
-
-      return cipherSuites(strings);
+      this.cipherSuites = strings;
+      return this;
     }
 
-    Builder cipherSuites(String[] cipherSuites) {
-      this.cipherSuites = cipherSuites; // No defensive copy.
+    public Builder cipherSuites(String... cipherSuites) {
+      if (!tls) throw new IllegalStateException("no cipher suites for cleartext connections");
+
+      if (cipherSuites == null) {
+        this.cipherSuites = null;
+      } else {
+        // This makes a defensive copy!
+        this.cipherSuites = cipherSuites.clone();
+      }
+
       return this;
     }
 
     public Builder tlsVersions(TlsVersion... tlsVersions) {
       if (!tls) throw new IllegalStateException("no TLS versions for cleartext connections");
+      if (tlsVersions.length == 0) {
+        throw new IllegalArgumentException("At least one TlsVersion is required");
+      }
 
       // Convert enums to the string names Java wants. This makes a defensive copy!
       String[] strings = new String[tlsVersions.length];
       for (int i = 0; i < tlsVersions.length; i++) {
         strings[i] = tlsVersions[i].javaName;
       }
-
-      return tlsVersions(strings);
+      this.tlsVersions = strings;
+      return this;
     }
 
-    Builder tlsVersions(String... tlsVersions) {
-      this.tlsVersions = tlsVersions; // No defensive copy.
+    public Builder tlsVersions(String... tlsVersions) {
+      if (!tls) throw new IllegalStateException("no TLS versions for cleartext connections");
+
+      if (tlsVersions == null) {
+        this.tlsVersions = null;
+      } else {
+        // This makes a defensive copy!
+        this.tlsVersions = tlsVersions.clone();
+      }
+
       return this;
     }
 
diff --git a/okhttp/src/main/java/com/squareup/okhttp/Dispatcher.java b/okhttp/src/main/java/com/squareup/okhttp/Dispatcher.java
index 95eb7b0ad3..a9346701fb 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/Dispatcher.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/Dispatcher.java
@@ -22,7 +22,7 @@
 import java.util.Deque;
 import java.util.Iterator;
 import java.util.concurrent.ExecutorService;
-import java.util.concurrent.LinkedBlockingQueue;
+import java.util.concurrent.SynchronousQueue;
 import java.util.concurrent.ThreadPoolExecutor;
 import java.util.concurrent.TimeUnit;
 
@@ -59,7 +59,7 @@ public Dispatcher() {
   public synchronized ExecutorService getExecutorService() {
     if (executorService == null) {
       executorService = new ThreadPoolExecutor(0, Integer.MAX_VALUE, 60, TimeUnit.SECONDS,
-          new LinkedBlockingQueue<Runnable>(), Util.threadFactory("OkHttp Dispatcher", false));
+          new SynchronousQueue<Runnable>(), Util.threadFactory("OkHttp Dispatcher", false));
     }
     return executorService;
   }
@@ -177,4 +177,12 @@ synchronized void executed(Call call) {
   synchronized void finished(Call call) {
     if (!executedCalls.remove(call)) throw new AssertionError("Call wasn't in-flight!");
   }
+
+  public synchronized int getRunningCallCount() {
+    return runningCalls.size();
+  }
+
+  public synchronized int getQueuedCallCount() {
+    return readyCalls.size();
+  }
 }
diff --git a/okhttp/src/main/java/com/squareup/okhttp/FormEncodingBuilder.java b/okhttp/src/main/java/com/squareup/okhttp/FormEncodingBuilder.java
index 891fbff005..6f4b93c179 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/FormEncodingBuilder.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/FormEncodingBuilder.java
@@ -15,42 +15,45 @@
  */
 package com.squareup.okhttp;
 
-import com.squareup.okhttp.internal.Util;
-import java.io.UnsupportedEncodingException;
-import java.net.URLEncoder;
+import okio.Buffer;
 
 /**
  * Fluent API to build <a href="http://www.w3.org/MarkUp/html-spec/html-spec_8.html#SEC8.2.1">HTML
  * 2.0</a>-compliant form data.
  */
 public final class FormEncodingBuilder {
-  private static final MediaType CONTENT_TYPE
-      = MediaType.parse("application/x-www-form-urlencoded");
+  private static final MediaType CONTENT_TYPE =
+      MediaType.parse("application/x-www-form-urlencoded");
 
-  private final StringBuilder content = new StringBuilder();
+  private final Buffer content = new Buffer();
 
   /** Add new key-value pair. */
   public FormEncodingBuilder add(String name, String value) {
-    if (content.length() > 0) {
-      content.append('&');
-    }
-    try {
-      content.append(URLEncoder.encode(name, "UTF-8"))
-          .append('=')
-          .append(URLEncoder.encode(value, "UTF-8"));
-    } catch (UnsupportedEncodingException e) {
-      throw new AssertionError(e);
+    if (content.size() > 0) {
+      content.writeByte('&');
     }
+    HttpUrl.canonicalize(content, name, 0, name.length(),
+        HttpUrl.FORM_ENCODE_SET, false, true);
+    content.writeByte('=');
+    HttpUrl.canonicalize(content, value, 0, value.length(),
+        HttpUrl.FORM_ENCODE_SET, false, true);
     return this;
   }
 
-  public RequestBody build() {
-    if (content.length() == 0) {
-      throw new IllegalStateException("Form encoded body must have at least one part.");
+  /** Add new key-value pair. */
+  public FormEncodingBuilder addEncoded(String name, String value) {
+    if (content.size() > 0) {
+      content.writeByte('&');
     }
+    HttpUrl.canonicalize(content, name, 0, name.length(),
+        HttpUrl.FORM_ENCODE_SET, true, true);
+    content.writeByte('=');
+    HttpUrl.canonicalize(content, value, 0, value.length(),
+        HttpUrl.FORM_ENCODE_SET, true, true);
+    return this;
+  }
 
-    // Convert to bytes so RequestBody.create() doesn't add a charset to the content-type.
-    byte[] contentBytes = content.toString().getBytes(Util.UTF_8);
-    return RequestBody.create(CONTENT_TYPE, contentBytes);
+  public RequestBody build() {
+    return RequestBody.create(CONTENT_TYPE, content.snapshot());
   }
 }
diff --git a/okhttp/src/main/java/com/squareup/okhttp/Headers.java b/okhttp/src/main/java/com/squareup/okhttp/Headers.java
index 2be385ce2b..0dca4281ec 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/Headers.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/Headers.java
@@ -21,6 +21,7 @@
 import java.util.ArrayList;
 import java.util.Collections;
 import java.util.Date;
+import java.util.LinkedHashMap;
 import java.util.List;
 import java.util.Map;
 import java.util.Set;
@@ -130,6 +131,20 @@ public Builder newBuilder() {
     return result.toString();
   }
 
+  public Map<String, List<String>> toMultimap() {
+    Map<String, List<String>> result = new LinkedHashMap<String, List<String>>();
+    for (int i = 0, size = size(); i < size; i++) {
+      String name = name(i);
+      List<String> values = result.get(name);
+      if (values == null) {
+        values = new ArrayList<>(2);
+        result.put(name, values);
+      }
+      values.add(value(i));
+    }
+    return result;
+  }
+
   private static String get(String[] namesAndValues, String name) {
     for (int i = namesAndValues.length - 2; i >= 0; i -= 2) {
       if (name.equalsIgnoreCase(namesAndValues[i])) {
@@ -227,19 +242,15 @@ public Builder add(String line) {
 
     /** Add a field with the specified value. */
     public Builder add(String name, String value) {
-      if (name == null) throw new IllegalArgumentException("name == null");
-      if (value == null) throw new IllegalArgumentException("value == null");
-      if (name.length() == 0 || name.indexOf('\0') != -1 || value.indexOf('\0') != -1) {
-        throw new IllegalArgumentException("Unexpected header: " + name + ": " + value);
-      }
+      checkNameAndValue(name, value);
       return addLenient(name, value);
     }
 
     /**
      * Add a field with the specified value without any validation. Only
-     * appropriate for headers from the remote peer.
+     * appropriate for headers from the remote peer or cache.
      */
-    private Builder addLenient(String name, String value) {
+    Builder addLenient(String name, String value) {
       namesAndValues.add(name);
       namesAndValues.add(value.trim());
       return this;
@@ -261,11 +272,32 @@ public Builder removeAll(String name) {
      * added. If the field is found, the existing values are replaced.
      */
     public Builder set(String name, String value) {
+      checkNameAndValue(name, value);
       removeAll(name);
-      add(name, value);
+      addLenient(name, value);
       return this;
     }
 
+    private void checkNameAndValue(String name, String value) {
+      if (name == null) throw new IllegalArgumentException("name == null");
+      if (name.isEmpty()) throw new IllegalArgumentException("name is empty");
+      for (int i = 0, length = name.length(); i < length; i++) {
+        char c = name.charAt(i);
+        if (c <= '\u001f' || c >= '\u007f') {
+          throw new IllegalArgumentException(String.format(
+              "Unexpected char %#04x at %d in header name: %s", (int) c, i, name));
+        }
+      }
+      if (value == null) throw new IllegalArgumentException("value == null");
+      for (int i = 0, length = value.length(); i < length; i++) {
+        char c = value.charAt(i);
+        if (c <= '\u001f' || c >= '\u007f') {
+          throw new IllegalArgumentException(String.format(
+              "Unexpected char %#04x at %d in header value: %s", (int) c, i, value));
+        }
+      }
+    }
+
     /** Equivalent to {@code build().get(name)}, but potentially faster. */
     public String get(String name) {
       for (int i = namesAndValues.size() - 2; i >= 0; i -= 2) {
diff --git a/okhttp/src/main/java/com/squareup/okhttp/HttpUrl.java b/okhttp/src/main/java/com/squareup/okhttp/HttpUrl.java
new file mode 100644
index 0000000000..fd1caca7a8
--- /dev/null
+++ b/okhttp/src/main/java/com/squareup/okhttp/HttpUrl.java
@@ -0,0 +1,1553 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.okhttp;
+
+import java.net.IDN;
+import java.net.InetAddress;
+import java.net.MalformedURLException;
+import java.net.URI;
+import java.net.URISyntaxException;
+import java.net.URL;
+import java.net.UnknownHostException;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.Collections;
+import java.util.LinkedHashSet;
+import java.util.List;
+import java.util.Locale;
+import java.util.Set;
+import okio.Buffer;
+
+/**
+ * A uniform resource locator (URL) with a scheme of either {@code http} or {@code https}. Use this
+ * class to compose and decompose Internet addresses. For example, this code will compose and print
+ * a URL for Google search: <pre>   {@code
+ *
+ *   HttpUrl url = new HttpUrl.Builder()
+ *       .scheme("https")
+ *       .host("www.google.com")
+ *       .addPathSegment("search")
+ *       .addQueryParameter("q", "polar bears")
+ *       .build();
+ *   System.out.println(url);
+ * }</pre>
+ *
+ * which prints: <pre>   {@code
+ *
+ *     https://www.google.com/search?q=polar%20bears
+ * }</pre>
+ *
+ * As another example, this code prints the human-readable query parameters of a Twitter search:
+ * <pre>   {@code
+ *
+ *   HttpUrl url = HttpUrl.parse("https://twitter.com/search?q=cute%20%23puppies&f=images");
+ *   for (int i = 0, size = url.querySize(); i < size; i++) {
+ *     System.out.println(url.queryParameterName(i) + ": " + url.queryParameterValue(i));
+ *   }
+ * }</pre>
+ *
+ * which prints: <pre>   {@code
+ *
+ *   q: cute #puppies
+ *   f: images
+ * }</pre>
+ *
+ * In addition to composing URLs from their component parts and decomposing URLs into their
+ * component parts, this class implements relative URL resolution: what address you'd reach by
+ * clicking a relative link on a specified page. For example: <pre>   {@code
+ *
+ *   HttpUrl base = HttpUrl.parse("https://www.youtube.com/user/WatchTheDaily/videos");
+ *   HttpUrl link = base.resolve("../../watch?v=cbP2N1BQdYc");
+ *   System.out.println(link);
+ * }</pre>
+ *
+ * which prints: <pre>   {@code
+ *
+ *   https://www.youtube.com/watch?v=cbP2N1BQdYc
+ * }</pre>
+ *
+ * <h3>What's in a URL?</h3>
+ *
+ * A URL has several components.
+ *
+ * <h4>Scheme</h4>
+ * Sometimes referred to as <i>protocol</i>, A URL's scheme describes what mechanism should be used
+ * to retrieve the resource. Although URLs have many schemes ({@code mailto}, {@code file}, {@code
+ * ftp}), this class only supports {@code http} and {@code https}. Use {@link URI java.net.URI} for
+ * URLs with arbitrary schemes.
+ *
+ * <h4>Username and Password</h4>
+ * Username and password are either present, or the empty string {@code ""} if absent. This class
+ * offers no mechanism to differentiate empty from absent. Neither of these components are popular
+ * in practice. Typically HTTP applications use other mechanisms for user identification and
+ * authentication.
+ *
+ * <h4>Host</h4>
+ * The host identifies the webserver that serves the URL's resource. It is either a hostname like
+ * {@code square.com} or {@code localhost}, an IPv4 address like {@code 192.168.0.1}, or an IPv6
+ * address like {@code ::1}.
+ *
+ * <p>Usually a webserver is reachable with multiple identifiers: its IP addresses, registered
+ * domain names, and even {@code localhost} when connecting from the server itself. Each of a
+ * webserver's names is a distinct URL and they are not interchangeable. For example, even if
+ * {@code http://square.github.io/dagger} and {@code http://google.github.io/dagger} are served by
+ * the same IP address, the two URLs identify different resources.
+ *
+ * <h4>Port</h4>
+ * The port used to connect to the webserver. By default this is 80 for HTTP and 443 for HTTPS. This
+ * class never returns -1 for the port: if no port is explicitly specified in the URL then the
+ * scheme's default is used.
+ *
+ * <h4>Path</h4>
+ * The path identifies a specific resource on the host. Paths have a hierarchical structure like
+ * "/square/okhttp/issues/1486". Each path segment is prefixed with "/". This class offers methods
+ * to compose and decompose paths by segment. If a path's last segment is the empty string, then the
+ * path ends with "/". This class always builds non-empty paths: if the path is omitted it defaults
+ * to "/", which is a path whose only segment is the empty string.
+ *
+ * <h4>Query</h4>
+ * The query is optional: it can be null, empty, or non-empty. For many HTTP URLs the query string
+ * is subdivided into a collection of name-value parameters. This class offers methods to set the
+ * query as the single string, or as individual name-value parameters. With name-value parameters
+ * the values are optional and names may be repeated.
+ *
+ * <h4>Fragment</h4>
+ * The fragment is optional: it can be null, empty, or non-empty. Unlike host, port, path, and query
+ * the fragment is not sent to the webserver: it's private to the client.
+ *
+ * <h3>Encoding</h3>
+ * Each component must be encoded before it is embedded in the complete URL. As we saw above, the
+ * string {@code cute #puppies} is encoded as {@code cute%20%23puppies} when used as a query
+ * parameter value.
+ *
+ * <h4>Percent encoding</h4>
+ * Percent encoding replaces a character (like {@code \ud83c\udf69}) with its UTF-8 hex bytes (like
+ * {@code %F0%9F%8D%A9}). This approach works for whitespace characters, control characters,
+ * non-ASCII characters, and characters that already have another meaning in a particular context.
+ *
+ * <p>Percent encoding is used in every URL component except for the hostname. But the set of
+ * characters that need to be encoded is different for each component. For example, the path
+ * component must escape all of its {@code ?} characters, otherwise it could be interpreted as the
+ * start of the URL's query. But within the query and fragment components, the {@code ?} character
+ * doesn't delimit anything and doesn't need to be escaped. <pre>   {@code
+ *
+ *   HttpUrl url = HttpUrl.parse("http://who-let-the-dogs.out").newBuilder()
+ *       .addPathSegment("_Who?_")
+ *       .query("_Who?_")
+ *       .fragment("_Who?_")
+ *       .build();
+ *   System.out.println(url);
+ * }</pre>
+ *
+ * This prints: <pre>   {@code
+ *
+ *   http://who-let-the-dogs.out/_Who%3F_?_Who?_#_Who?_
+ * }</pre>
+ *
+ * When parsing URLs that lack percent encoding where it is required, this class will percent encode
+ * the offending characters.
+ *
+ * <h4>IDNA Mapping and Punycode encoding</h4>
+ * Hostnames have different requirements and use a different encoding scheme. It consists of IDNA
+ * mapping and Punycode encoding.
+ *
+ * <p>In order to avoid confusion and discourage phishing attacks,
+ * <a href="http://www.unicode.org/reports/tr46/#ToASCII">IDNA Mapping</a> transforms names to avoid
+ * confusing characters. This includes basic case folding: transforming shouting {@code SQUARE.COM}
+ * into cool and casual {@code square.com}. It also handles more exotic characters. For example, the
+ * Unicode trademark sign (™) could be confused for the letters "TM" in {@code http://ho™mail.com}.
+ * To mitigate this, the single character (™) maps to the string (tm). There is similar policy for
+ * all of the 1.1 million Unicode code points. Note that some code points such as "\ud83c\udf69" are
+ * not mapped and cannot be used in a hostname.
+ *
+ * <p><a href="http://ietf.org/rfc/rfc3492.txt">Punycode</a> converts a Unicode string to an ASCII
+ * string to make international domain names work everywhere. For example, "σ" encodes as
+ * "xn--4xa". The encoded string is not human readable, but can be used with classes like {@link
+ * InetAddress} to establish connections.
+ *
+ * <h3>Why another URL model?</h3>
+ * Java includes both {@link URL java.net.URL} and {@link URI java.net.URI}. We offer a new URL
+ * model to address problems that the others don't.
+ *
+ * <h4>Different URLs should be different</h4>
+ * Although they have different content, {@code java.net.URL} considers the following two URLs
+ * equal, and the {@link Object#equals equals()} method between them returns true:
+ * <ul>
+ *   <li>http://square.github.io/
+ *   <li>http://google.github.io/
+ * </ul>
+ * This is because those two hosts share the same IP address. This is an old, bad design decision
+ * that makes {@code java.net.URL} unusable for many things. It shouldn't be used as a {@link
+ * java.util.Map Map} key or in a {@link Set}. Doing so is both inefficient because equality may
+ * require a DNS lookup, and incorrect because unequal URLs may be equal because of how they are
+ * hosted.
+ *
+ * <h4>Equal URLs should be equal</h4>
+ * These two URLs are semantically identical, but {@code java.net.URI} disagrees:
+ * <ul>
+ *   <li>http://host:80/
+ *   <li>http://host
+ * </ul>
+ * Both the unnecessary port specification ({@code :80}) and the absent trailing slash ({@code /})
+ * cause URI to bucket the two URLs separately. This harms URI's usefulness in collections. Any
+ * application that stores information-per-URL will need to either canonicalize manually, or suffer
+ * unnecessary redundancy for such URLs.
+ *
+ * <p>Because they don't attempt canonical form, these classes are surprisingly difficult to use
+ * securely. Suppose you're building a webservice that checks that incoming paths are prefixed
+ * "/static/images/" before serving the corresponding assets from the filesystem. <pre>   {@code
+ *
+ *   String attack = "http://example.com/static/images/../../../../../etc/passwd";
+ *   System.out.println(new URL(attack).getPath());
+ *   System.out.println(new URI(attack).getPath());
+ *   System.out.println(HttpUrl.parse(attack).path());
+ * }</pre>
+ *
+ * By canonicalizing the input paths, they are complicit in directory traversal attacks. Code that
+ * checks only the path prefix may suffer!
+ * <pre>   {@code
+ *
+ *    /static/images/../../../../../etc/passwd
+ *    /static/images/../../../../../etc/passwd
+ *    /etc/passwd
+ * }</pre>
+ *
+ * <h4>If it works on the web, it should work in your application</h4>
+ * The {@code java.net.URI} class is strict around what URLs it accepts. It rejects URLs like
+ * "http://example.com/abc|def" because the '|' character is unsupported. This class is more
+ * forgiving: it will automatically percent-encode the '|', yielding "http://example.com/abc%7Cdef".
+ * This kind behavior is consistent with web browsers. {@code HttpUrl} prefers consistency with
+ * major web browsers over consistency with obsolete specifications.
+ *
+ * <h4>Paths and Queries should decompose</h4>
+ * Neither of the built-in URL models offer direct access to path segments or query parameters.
+ * Manually using {@code StringBuilder} to assemble these components is cumbersome: do '+'
+ * characters get silently replaced with spaces? If a query parameter contains a '&amp;', does that
+ * get escaped? By offering methods to read and write individual query parameters directly,
+ * application developers are saved from the hassles of encoding and decoding.
+ *
+ * <h4>Plus a modern API</h4>
+ * The URL (JDK1.0) and URI (Java 1.4) classes predate builders and instead use telescoping
+ * constructors. For example, there's no API to compose a URI with a custom port without also
+ * providing a query and fragment.
+ *
+ * <p>Instances of {@link HttpUrl} are well-formed and always have a scheme, host, and path. With
+ * {@code java.net.URL} it's possible to create an awkward URL like {@code http:/} with scheme and
+ * path but no hostname. Building APIs that consume such malformed values is difficult!
+ *
+ * <p>This class has a modern API. It avoids punitive checked exceptions: {@link #parse parse()}
+ * returns null if the input is an invalid URL. You can even be explicit about whether each
+ * component has been encoded already.
+ */
+public final class HttpUrl {
+  private static final char[] HEX_DIGITS =
+      { '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F' };
+  static final String USERNAME_ENCODE_SET = " \"':;<=>@[]^`{}|/\\?#";
+  static final String PASSWORD_ENCODE_SET = " \"':;<=>@[]^`{}|/\\?#";
+  static final String PATH_SEGMENT_ENCODE_SET = " \"<>^`{}|/\\?#";
+  static final String QUERY_ENCODE_SET = " \"'<>#";
+  static final String QUERY_COMPONENT_ENCODE_SET = " \"'<>#&=";
+  static final String CONVERT_TO_URI_ENCODE_SET = "^`{}|\\";
+  static final String FORM_ENCODE_SET = " \"':;<=>@[]^`{}|/\\?#&!$(),~";
+  static final String FRAGMENT_ENCODE_SET = "";
+
+  /** Either "http" or "https". */
+  private final String scheme;
+
+  /** Decoded username. */
+  private final String username;
+
+  /** Decoded password. */
+  private final String password;
+
+  /** Canonical hostname. */
+  private final String host;
+
+  /** Either 80, 443 or a user-specified port. In range [1..65535]. */
+  private final int port;
+
+  /**
+   * A list of canonical path segments. This list always contains at least one element, which may
+   * be the empty string. Each segment is formatted with a leading '/', so if path segments were
+   * ["a", "b", ""], then the encoded path would be "/a/b/".
+   */
+  private final List<String> pathSegments;
+
+  /**
+   * Alternating, decoded query names and values, or null for no query. Names may be empty or
+   * non-empty, but never null. Values are null if the name has no corresponding '=' separator, or
+   * empty, or non-empty.
+   */
+  private final List<String> queryNamesAndValues;
+
+  /** Decoded fragment. */
+  private final String fragment;
+
+  /** Canonical URL. */
+  private final String url;
+
+  private HttpUrl(Builder builder) {
+    this.scheme = builder.scheme;
+    this.username = percentDecode(builder.encodedUsername);
+    this.password = percentDecode(builder.encodedPassword);
+    this.host = builder.host;
+    this.port = builder.effectivePort();
+    this.pathSegments = percentDecode(builder.encodedPathSegments);
+    this.queryNamesAndValues = builder.encodedQueryNamesAndValues != null
+        ? percentDecode(builder.encodedQueryNamesAndValues)
+        : null;
+    this.fragment = builder.encodedFragment != null
+        ? percentDecode(builder.encodedFragment)
+        : null;
+    this.url = builder.toString();
+  }
+
+  /** Returns this URL as a {@link URL java.net.URL}. */
+  public URL url() {
+    try {
+      return new URL(url);
+    } catch (MalformedURLException e) {
+      throw new RuntimeException(e); // Unexpected!
+    }
+  }
+
+  /**
+   * Attempt to convert this URL to a {@link URI java.net.URI}. This method throws an unchecked
+   * {@link IllegalStateException} if the URL it holds isn't valid by URI's overly-stringent
+   * standard. For example, URI rejects paths containing the '[' character. Consult that class for
+   * the exact rules of what URLs are permitted.
+   */
+  public URI uri() {
+    try {
+      String uriSafeUrl = canonicalize(url, CONVERT_TO_URI_ENCODE_SET, true, false);
+      return new URI(uriSafeUrl);
+    } catch (URISyntaxException e) {
+      throw new IllegalStateException("not valid as a java.net.URI: " + url);
+    }
+  }
+
+  /** Returns either "http" or "https". */
+  public String scheme() {
+    return scheme;
+  }
+
+  public boolean isHttps() {
+    return scheme.equals("https");
+  }
+
+  /** Returns the username, or an empty string if none is set. */
+  public String encodedUsername() {
+    if (username.isEmpty()) return "";
+    int usernameStart = scheme.length() + 3; // "://".length() == 3.
+    int usernameEnd = delimiterOffset(url, usernameStart, url.length(), ":@");
+    return url.substring(usernameStart, usernameEnd);
+  }
+
+  public String username() {
+    return username;
+  }
+
+  /** Returns the password, or an empty string if none is set. */
+  public String encodedPassword() {
+    if (password.isEmpty()) return "";
+    int passwordStart = url.indexOf(':', scheme.length() + 3) + 1;
+    int passwordEnd = url.indexOf('@');
+    return url.substring(passwordStart, passwordEnd);
+  }
+
+  /** Returns the decoded password, or an empty string if none is present. */
+  public String password() {
+    return password;
+  }
+
+  /**
+   * Returns the host address suitable for use with {@link InetAddress#getAllByName(String)}. May
+   * be:
+   * <ul>
+   *   <li>A regular host name, like {@code android.com}.
+   *   <li>An IPv4 address, like {@code 127.0.0.1}.
+   *   <li>An IPv6 address, like {@code ::1}. Note that there are no square braces.
+   *   <li>An encoded IDN, like {@code xn--n3h.net}.
+   * </ul>
+   */
+  public String host() {
+    return host;
+  }
+
+  /**
+   * Returns the explicitly-specified port if one was provided, or the default port for this URL's
+   * scheme. For example, this returns 8443 for {@code https://square.com:8443/} and 443 for {@code
+   * https://square.com/}. The result is in {@code [1..65535]}.
+   */
+  public int port() {
+    return port;
+  }
+
+  /**
+   * Returns 80 if {@code scheme.equals("http")}, 443 if {@code scheme.equals("https")} and -1
+   * otherwise.
+   */
+  public static int defaultPort(String scheme) {
+    if (scheme.equals("http")) {
+      return 80;
+    } else if (scheme.equals("https")) {
+      return 443;
+    } else {
+      return -1;
+    }
+  }
+
+  public int pathSize() {
+    return pathSegments.size();
+  }
+
+  /**
+   * Returns the entire path of this URL, encoded for use in HTTP resource resolution. The
+   * returned path is always nonempty and is prefixed with {@code /}.
+   */
+  public String encodedPath() {
+    int pathStart = url.indexOf('/', scheme.length() + 3); // "://".length() == 3.
+    int pathEnd = delimiterOffset(url, pathStart, url.length(), "?#");
+    return url.substring(pathStart, pathEnd);
+  }
+
+  static void pathSegmentsToString(StringBuilder out, List<String> pathSegments) {
+    for (int i = 0, size = pathSegments.size(); i < size; i++) {
+      out.append('/');
+      out.append(pathSegments.get(i));
+    }
+  }
+
+  public List<String> encodedPathSegments() {
+    int pathStart = url.indexOf('/', scheme.length() + 3);
+    int pathEnd = delimiterOffset(url, pathStart, url.length(), "?#");
+    List<String> result = new ArrayList<>();
+    for (int i = pathStart; i < pathEnd; ) {
+      i++; // Skip the '/'.
+      int segmentEnd = delimiterOffset(url, i, pathEnd, "/");
+      result.add(url.substring(i, segmentEnd));
+      i = segmentEnd;
+    }
+    return result;
+  }
+
+  public List<String> pathSegments() {
+    return pathSegments;
+  }
+
+  /**
+   * Returns the query of this URL, encoded for use in HTTP resource resolution. The returned string
+   * may be null (for URLs with no query), empty (for URLs with an empty query) or non-empty (all
+   * other URLs).
+   */
+  public String encodedQuery() {
+    if (queryNamesAndValues == null) return null; // No query.
+    int queryStart = url.indexOf('?') + 1;
+    int queryEnd = delimiterOffset(url, queryStart + 1, url.length(), "#");
+    return url.substring(queryStart, queryEnd);
+  }
+
+  static void namesAndValuesToQueryString(StringBuilder out, List<String> namesAndValues) {
+    for (int i = 0, size = namesAndValues.size(); i < size; i += 2) {
+      String name = namesAndValues.get(i);
+      String value = namesAndValues.get(i + 1);
+      if (i > 0) out.append('&');
+      out.append(name);
+      if (value != null) {
+        out.append('=');
+        out.append(value);
+      }
+    }
+  }
+
+  /**
+   * Cuts {@code encodedQuery} up into alternating parameter names and values. This divides a
+   * query string like {@code subject=math&easy&problem=5-2=3} into the list {@code ["subject",
+   * "math", "easy", null, "problem", "5-2=3"]}. Note that values may be null and may contain
+   * '=' characters.
+   */
+  static List<String> queryStringToNamesAndValues(String encodedQuery) {
+    List<String> result = new ArrayList<>();
+    for (int pos = 0; pos <= encodedQuery.length(); ) {
+      int ampersandOffset = encodedQuery.indexOf('&', pos);
+      if (ampersandOffset == -1) ampersandOffset = encodedQuery.length();
+
+      int equalsOffset = encodedQuery.indexOf('=', pos);
+      if (equalsOffset == -1 || equalsOffset > ampersandOffset) {
+        result.add(encodedQuery.substring(pos, ampersandOffset));
+        result.add(null); // No value for this name.
+      } else {
+        result.add(encodedQuery.substring(pos, equalsOffset));
+        result.add(encodedQuery.substring(equalsOffset + 1, ampersandOffset));
+      }
+      pos = ampersandOffset + 1;
+    }
+    return result;
+  }
+
+  public String query() {
+    if (queryNamesAndValues == null) return null; // No query.
+    StringBuilder result = new StringBuilder();
+    namesAndValuesToQueryString(result, queryNamesAndValues);
+    return result.toString();
+  }
+
+  public int querySize() {
+    return queryNamesAndValues != null ? queryNamesAndValues.size() / 2 : 0;
+  }
+
+  /**
+   * Returns the first query parameter named {@code name} decoded using UTF-8, or null if there is
+   * no such query parameter.
+   */
+  public String queryParameter(String name) {
+    if (queryNamesAndValues == null) return null;
+    for (int i = 0, size = queryNamesAndValues.size(); i < size; i += 2) {
+      if (name.equals(queryNamesAndValues.get(i))) {
+        return queryNamesAndValues.get(i + 1);
+      }
+    }
+    return null;
+  }
+
+  public Set<String> queryParameterNames() {
+    if (queryNamesAndValues == null) return Collections.emptySet();
+    Set<String> result = new LinkedHashSet<>();
+    for (int i = 0, size = queryNamesAndValues.size(); i < size; i += 2) {
+      result.add(queryNamesAndValues.get(i));
+    }
+    return Collections.unmodifiableSet(result);
+  }
+
+  public List<String> queryParameterValues(String name) {
+    if (queryNamesAndValues == null) return Collections.emptyList();
+    List<String> result = new ArrayList<>();
+    for (int i = 0, size = queryNamesAndValues.size(); i < size; i += 2) {
+      if (name.equals(queryNamesAndValues.get(i))) {
+        result.add(queryNamesAndValues.get(i + 1));
+      }
+    }
+    return Collections.unmodifiableList(result);
+  }
+
+  public String queryParameterName(int index) {
+    return queryNamesAndValues.get(index * 2);
+  }
+
+  public String queryParameterValue(int index) {
+    return queryNamesAndValues.get(index * 2 + 1);
+  }
+
+  public String encodedFragment() {
+    if (fragment == null) return null;
+    int fragmentStart = url.indexOf('#') + 1;
+    return url.substring(fragmentStart);
+  }
+
+  public String fragment() {
+    return fragment;
+  }
+
+  /** Returns the URL that would be retrieved by following {@code link} from this URL. */
+  public HttpUrl resolve(String link) {
+    Builder builder = new Builder();
+    Builder.ParseResult result = builder.parse(this, link);
+    return result == Builder.ParseResult.SUCCESS ? builder.build() : null;
+  }
+
+  public Builder newBuilder() {
+    Builder result = new Builder();
+    result.scheme = scheme;
+    result.encodedUsername = encodedUsername();
+    result.encodedPassword = encodedPassword();
+    result.host = host;
+    // If we're set to a default port, unset it, in case of a scheme change.
+    if (port == defaultPort(scheme)) {
+      result.port = -1;
+    } else {
+      result.port = port;
+    }
+    result.encodedPathSegments.clear();
+    result.encodedPathSegments.addAll(encodedPathSegments());
+    result.encodedQuery(encodedQuery());
+    result.encodedFragment = encodedFragment();
+    return result;
+  }
+
+  /**
+   * Returns a new {@code HttpUrl} representing {@code url} if it is a well-formed HTTP or HTTPS
+   * URL, or null if it isn't.
+   */
+  public static HttpUrl parse(String url) {
+    Builder builder = new Builder();
+    Builder.ParseResult result = builder.parse(null, url);
+    return result == Builder.ParseResult.SUCCESS ? builder.build() : null;
+  }
+
+  /**
+   * Returns an {@link HttpUrl} for {@code url} if its protocol is {@code http} or {@code https}, or
+   * null if it has any other protocol.
+   */
+  public static HttpUrl get(URL url) {
+    return parse(url.toString());
+  }
+
+  /**
+   * Returns a new {@code HttpUrl} representing {@code url} if it is a well-formed HTTP or HTTPS
+   * URL, or throws an exception if it isn't.
+   *
+   * @throws MalformedURLException if there was a non-host related URL issue
+   * @throws UnknownHostException if the host was invalid
+   */
+  static HttpUrl getChecked(String url) throws MalformedURLException, UnknownHostException {
+    Builder builder = new Builder();
+    Builder.ParseResult result = builder.parse(null, url);
+    switch (result) {
+      case SUCCESS:
+        return builder.build();
+      case INVALID_HOST:
+        throw new UnknownHostException("Invalid host: " + url);
+      case UNSUPPORTED_SCHEME:
+      case MISSING_SCHEME:
+      case INVALID_PORT:
+      default:
+        throw new MalformedURLException("Invalid URL: " + result + " for " + url);
+    }
+  }
+
+  public static HttpUrl get(URI uri) {
+    return parse(uri.toString());
+  }
+
+  @Override public boolean equals(Object o) {
+    return o instanceof HttpUrl && ((HttpUrl) o).url.equals(url);
+  }
+
+  @Override public int hashCode() {
+    return url.hashCode();
+  }
+
+  @Override public String toString() {
+    return url;
+  }
+
+  public static final class Builder {
+    String scheme;
+    String encodedUsername = "";
+    String encodedPassword = "";
+    String host;
+    int port = -1;
+    final List<String> encodedPathSegments = new ArrayList<>();
+    List<String> encodedQueryNamesAndValues;
+    String encodedFragment;
+
+    public Builder() {
+      encodedPathSegments.add(""); // The default path is '/' which needs a trailing space.
+    }
+
+    public Builder scheme(String scheme) {
+      if (scheme == null) {
+        throw new IllegalArgumentException("scheme == null");
+      } else if (scheme.equalsIgnoreCase("http")) {
+        this.scheme = "http";
+      } else if (scheme.equalsIgnoreCase("https")) {
+        this.scheme = "https";
+      } else {
+        throw new IllegalArgumentException("unexpected scheme: " + scheme);
+      }
+      return this;
+    }
+
+    public Builder username(String username) {
+      if (username == null) throw new IllegalArgumentException("username == null");
+      this.encodedUsername = canonicalize(username, USERNAME_ENCODE_SET, false, false);
+      return this;
+    }
+
+    public Builder encodedUsername(String encodedUsername) {
+      if (encodedUsername == null) throw new IllegalArgumentException("encodedUsername == null");
+      this.encodedUsername = canonicalize(encodedUsername, USERNAME_ENCODE_SET, true, false);
+      return this;
+    }
+
+    public Builder password(String password) {
+      if (password == null) throw new IllegalArgumentException("password == null");
+      this.encodedPassword = canonicalize(password, PASSWORD_ENCODE_SET, false, false);
+      return this;
+    }
+
+    public Builder encodedPassword(String encodedPassword) {
+      if (encodedPassword == null) throw new IllegalArgumentException("encodedPassword == null");
+      this.encodedPassword = canonicalize(encodedPassword, PASSWORD_ENCODE_SET, true, false);
+      return this;
+    }
+
+    /**
+     * @param host either a regular hostname, International Domain Name, IPv4 address, or IPv6
+     *     address.
+     */
+    public Builder host(String host) {
+      if (host == null) throw new IllegalArgumentException("host == null");
+      String encoded = canonicalizeHost(host, 0, host.length());
+      if (encoded == null) throw new IllegalArgumentException("unexpected host: " + host);
+      this.host = encoded;
+      return this;
+    }
+
+    public Builder port(int port) {
+      if (port <= 0 || port > 65535) throw new IllegalArgumentException("unexpected port: " + port);
+      this.port = port;
+      return this;
+    }
+
+    int effectivePort() {
+      return port != -1 ? port : defaultPort(scheme);
+    }
+
+    public Builder addPathSegment(String pathSegment) {
+      if (pathSegment == null) throw new IllegalArgumentException("pathSegment == null");
+      push(pathSegment, 0, pathSegment.length(), false, false);
+      return this;
+    }
+
+    public Builder addEncodedPathSegment(String encodedPathSegment) {
+      if (encodedPathSegment == null) {
+        throw new IllegalArgumentException("encodedPathSegment == null");
+      }
+      push(encodedPathSegment, 0, encodedPathSegment.length(), false, true);
+      return this;
+    }
+
+    public Builder setPathSegment(int index, String pathSegment) {
+      if (pathSegment == null) throw new IllegalArgumentException("pathSegment == null");
+      String canonicalPathSegment = canonicalize(
+          pathSegment, 0, pathSegment.length(), PATH_SEGMENT_ENCODE_SET, false, false);
+      if (isDot(canonicalPathSegment) || isDotDot(canonicalPathSegment)) {
+        throw new IllegalArgumentException("unexpected path segment: " + pathSegment);
+      }
+      encodedPathSegments.set(index, canonicalPathSegment);
+      return this;
+    }
+
+    public Builder setEncodedPathSegment(int index, String encodedPathSegment) {
+      if (encodedPathSegment == null) {
+        throw new IllegalArgumentException("encodedPathSegment == null");
+      }
+      String canonicalPathSegment = canonicalize(encodedPathSegment,
+          0, encodedPathSegment.length(), PATH_SEGMENT_ENCODE_SET, true, false);
+      encodedPathSegments.set(index, canonicalPathSegment);
+      if (isDot(canonicalPathSegment) || isDotDot(canonicalPathSegment)) {
+        throw new IllegalArgumentException("unexpected path segment: " + encodedPathSegment);
+      }
+      return this;
+    }
+
+    public Builder removePathSegment(int index) {
+      encodedPathSegments.remove(index);
+      if (encodedPathSegments.isEmpty()) {
+        encodedPathSegments.add(""); // Always leave at least one '/'.
+      }
+      return this;
+    }
+
+    public Builder encodedPath(String encodedPath) {
+      if (encodedPath == null) throw new IllegalArgumentException("encodedPath == null");
+      if (!encodedPath.startsWith("/")) {
+        throw new IllegalArgumentException("unexpected encodedPath: " + encodedPath);
+      }
+      resolvePath(encodedPath, 0, encodedPath.length());
+      return this;
+    }
+
+    public Builder query(String query) {
+      this.encodedQueryNamesAndValues = query != null
+          ? queryStringToNamesAndValues(canonicalize(query, QUERY_ENCODE_SET, false, true))
+          : null;
+      return this;
+    }
+
+    public Builder encodedQuery(String encodedQuery) {
+      this.encodedQueryNamesAndValues = encodedQuery != null
+          ? queryStringToNamesAndValues(canonicalize(encodedQuery, QUERY_ENCODE_SET, true, true))
+          : null;
+      return this;
+    }
+
+    /** Encodes the query parameter using UTF-8 and adds it to this URL's query string. */
+    public Builder addQueryParameter(String name, String value) {
+      if (name == null) throw new IllegalArgumentException("name == null");
+      if (encodedQueryNamesAndValues == null) encodedQueryNamesAndValues = new ArrayList<>();
+      encodedQueryNamesAndValues.add(canonicalize(name, QUERY_COMPONENT_ENCODE_SET, false, true));
+      encodedQueryNamesAndValues.add(value != null
+          ? canonicalize(value, QUERY_COMPONENT_ENCODE_SET, false, true)
+          : null);
+      return this;
+    }
+
+    /** Adds the pre-encoded query parameter to this URL's query string. */
+    public Builder addEncodedQueryParameter(String encodedName, String encodedValue) {
+      if (encodedName == null) throw new IllegalArgumentException("encodedName == null");
+      if (encodedQueryNamesAndValues == null) encodedQueryNamesAndValues = new ArrayList<>();
+      encodedQueryNamesAndValues.add(
+          canonicalize(encodedName, QUERY_COMPONENT_ENCODE_SET, true, true));
+      encodedQueryNamesAndValues.add(encodedValue != null
+          ? canonicalize(encodedValue, QUERY_COMPONENT_ENCODE_SET, true, true)
+          : null);
+      return this;
+    }
+
+    public Builder setQueryParameter(String name, String value) {
+      removeAllQueryParameters(name);
+      addQueryParameter(name, value);
+      return this;
+    }
+
+    public Builder setEncodedQueryParameter(String encodedName, String encodedValue) {
+      removeAllEncodedQueryParameters(encodedName);
+      addEncodedQueryParameter(encodedName, encodedValue);
+      return this;
+    }
+
+    public Builder removeAllQueryParameters(String name) {
+      if (name == null) throw new IllegalArgumentException("name == null");
+      if (encodedQueryNamesAndValues == null) return this;
+      String nameToRemove = canonicalize(name, QUERY_COMPONENT_ENCODE_SET, false, true);
+      removeAllCanonicalQueryParameters(nameToRemove);
+      return this;
+    }
+
+    public Builder removeAllEncodedQueryParameters(String encodedName) {
+      if (encodedName == null) throw new IllegalArgumentException("encodedName == null");
+      if (encodedQueryNamesAndValues == null) return this;
+      removeAllCanonicalQueryParameters(
+          canonicalize(encodedName, QUERY_COMPONENT_ENCODE_SET, true, true));
+      return this;
+    }
+
+    private void removeAllCanonicalQueryParameters(String canonicalName) {
+      for (int i = encodedQueryNamesAndValues.size() - 2; i >= 0; i -= 2) {
+        if (canonicalName.equals(encodedQueryNamesAndValues.get(i))) {
+          encodedQueryNamesAndValues.remove(i + 1);
+          encodedQueryNamesAndValues.remove(i);
+          if (encodedQueryNamesAndValues.isEmpty()) {
+            encodedQueryNamesAndValues = null;
+            return;
+          }
+        }
+      }
+    }
+
+    public Builder fragment(String fragment) {
+      if (fragment == null) throw new IllegalArgumentException("fragment == null");
+      this.encodedFragment = canonicalize(fragment, FRAGMENT_ENCODE_SET, false, false);
+      return this;
+    }
+
+    public Builder encodedFragment(String encodedFragment) {
+      if (encodedFragment == null) throw new IllegalArgumentException("encodedFragment == null");
+      this.encodedFragment = canonicalize(encodedFragment, FRAGMENT_ENCODE_SET, true, false);
+      return this;
+    }
+
+    public HttpUrl build() {
+      if (scheme == null) throw new IllegalStateException("scheme == null");
+      if (host == null) throw new IllegalStateException("host == null");
+      return new HttpUrl(this);
+    }
+
+    @Override public String toString() {
+      StringBuilder result = new StringBuilder();
+      result.append(scheme);
+      result.append("://");
+
+      if (!encodedUsername.isEmpty() || !encodedPassword.isEmpty()) {
+        result.append(encodedUsername);
+        if (!encodedPassword.isEmpty()) {
+          result.append(':');
+          result.append(encodedPassword);
+        }
+        result.append('@');
+      }
+
+      if (host.indexOf(':') != -1) {
+        // Host is an IPv6 address.
+        result.append('[');
+        result.append(host);
+        result.append(']');
+      } else {
+        result.append(host);
+      }
+
+      int effectivePort = effectivePort();
+      if (effectivePort != defaultPort(scheme)) {
+        result.append(':');
+        result.append(effectivePort);
+      }
+
+      pathSegmentsToString(result, encodedPathSegments);
+
+      if (encodedQueryNamesAndValues != null) {
+        result.append('?');
+        namesAndValuesToQueryString(result, encodedQueryNamesAndValues);
+      }
+
+      if (encodedFragment != null) {
+        result.append('#');
+        result.append(encodedFragment);
+      }
+
+      return result.toString();
+    }
+
+    enum ParseResult {
+      SUCCESS,
+      MISSING_SCHEME,
+      UNSUPPORTED_SCHEME,
+      INVALID_PORT,
+      INVALID_HOST,
+    }
+
+    ParseResult parse(HttpUrl base, String input) {
+      int pos = skipLeadingAsciiWhitespace(input, 0, input.length());
+      int limit = skipTrailingAsciiWhitespace(input, pos, input.length());
+
+      // Scheme.
+      int schemeDelimiterOffset = schemeDelimiterOffset(input, pos, limit);
+      if (schemeDelimiterOffset != -1) {
+        if (input.regionMatches(true, pos, "https:", 0, 6)) {
+          this.scheme = "https";
+          pos += "https:".length();
+        } else if (input.regionMatches(true, pos, "http:", 0, 5)) {
+          this.scheme = "http";
+          pos += "http:".length();
+        } else {
+          return ParseResult.UNSUPPORTED_SCHEME; // Not an HTTP scheme.
+        }
+      } else if (base != null) {
+        this.scheme = base.scheme;
+      } else {
+        return ParseResult.MISSING_SCHEME; // No scheme.
+      }
+
+      // Authority.
+      boolean hasUsername = false;
+      boolean hasPassword = false;
+      int slashCount = slashCount(input, pos, limit);
+      if (slashCount >= 2 || base == null || !base.scheme.equals(this.scheme)) {
+        // Read an authority if either:
+        //  * The input starts with 2 or more slashes. These follow the scheme if it exists.
+        //  * The input scheme exists and is different from the base URL's scheme.
+        //
+        // The structure of an authority is:
+        //   username:password@host:port
+        //
+        // Username, password and port are optional.
+        //   [username[:password]@]host[:port]
+        pos += slashCount;
+        authority:
+        while (true) {
+          int componentDelimiterOffset = delimiterOffset(input, pos, limit, "@/\\?#");
+          int c = componentDelimiterOffset != limit
+              ? input.charAt(componentDelimiterOffset)
+              : -1;
+          switch (c) {
+            case '@':
+              // User info precedes.
+              if (!hasPassword) {
+                int passwordColonOffset = delimiterOffset(
+                    input, pos, componentDelimiterOffset, ":");
+                String canonicalUsername = canonicalize(
+                    input, pos, passwordColonOffset, USERNAME_ENCODE_SET, true, false);
+                this.encodedUsername = hasUsername
+                    ? this.encodedUsername + "%40" + canonicalUsername
+                    : canonicalUsername;
+                if (passwordColonOffset != componentDelimiterOffset) {
+                  hasPassword = true;
+                  this.encodedPassword = canonicalize(input, passwordColonOffset + 1,
+                      componentDelimiterOffset, PASSWORD_ENCODE_SET, true, false);
+                }
+                hasUsername = true;
+              } else {
+                this.encodedPassword = this.encodedPassword + "%40" + canonicalize(
+                    input, pos, componentDelimiterOffset, PASSWORD_ENCODE_SET, true, false);
+              }
+              pos = componentDelimiterOffset + 1;
+              break;
+
+            case -1:
+            case '/':
+            case '\\':
+            case '?':
+            case '#':
+              // Host info precedes.
+              int portColonOffset = portColonOffset(input, pos, componentDelimiterOffset);
+              if (portColonOffset + 1 < componentDelimiterOffset) {
+                this.host = canonicalizeHost(input, pos, portColonOffset);
+                this.port = parsePort(input, portColonOffset + 1, componentDelimiterOffset);
+                if (this.port == -1) return ParseResult.INVALID_PORT; // Invalid port.
+              } else {
+                this.host = canonicalizeHost(input, pos, portColonOffset);
+                this.port = defaultPort(this.scheme);
+              }
+              if (this.host == null) return ParseResult.INVALID_HOST; // Invalid host.
+              pos = componentDelimiterOffset;
+              break authority;
+          }
+        }
+      } else {
+        // This is a relative link. Copy over all authority components. Also maybe the path & query.
+        this.encodedUsername = base.encodedUsername();
+        this.encodedPassword = base.encodedPassword();
+        this.host = base.host;
+        this.port = base.port;
+        this.encodedPathSegments.clear();
+        this.encodedPathSegments.addAll(base.encodedPathSegments());
+        if (pos == limit || input.charAt(pos) == '#') {
+          encodedQuery(base.encodedQuery());
+        }
+      }
+
+      // Resolve the relative path.
+      int pathDelimiterOffset = delimiterOffset(input, pos, limit, "?#");
+      resolvePath(input, pos, pathDelimiterOffset);
+      pos = pathDelimiterOffset;
+
+      // Query.
+      if (pos < limit && input.charAt(pos) == '?') {
+        int queryDelimiterOffset = delimiterOffset(input, pos, limit, "#");
+        this.encodedQueryNamesAndValues = queryStringToNamesAndValues(canonicalize(
+            input, pos + 1, queryDelimiterOffset, QUERY_ENCODE_SET, true, true));
+        pos = queryDelimiterOffset;
+      }
+
+      // Fragment.
+      if (pos < limit && input.charAt(pos) == '#') {
+        this.encodedFragment = canonicalize(
+            input, pos + 1, limit, FRAGMENT_ENCODE_SET, true, false);
+      }
+
+      return ParseResult.SUCCESS;
+    }
+
+    private void resolvePath(String input, int pos, int limit) {
+      // Read a delimiter.
+      if (pos == limit) {
+        // Empty path: keep the base path as-is.
+        return;
+      }
+      char c = input.charAt(pos);
+      if (c == '/' || c == '\\') {
+        // Absolute path: reset to the default "/".
+        encodedPathSegments.clear();
+        encodedPathSegments.add("");
+        pos++;
+      } else {
+        // Relative path: clear everything after the last '/'.
+        encodedPathSegments.set(encodedPathSegments.size() - 1, "");
+      }
+
+      // Read path segments.
+      for (int i = pos; i < limit; ) {
+        int pathSegmentDelimiterOffset = delimiterOffset(input, i, limit, "/\\");
+        boolean segmentHasTrailingSlash = pathSegmentDelimiterOffset < limit;
+        push(input, i, pathSegmentDelimiterOffset, segmentHasTrailingSlash, true);
+        i = pathSegmentDelimiterOffset;
+        if (segmentHasTrailingSlash) i++;
+      }
+    }
+
+    /** Adds a path segment. If the input is ".." or equivalent, this pops a path segment. */
+    private void push(String input, int pos, int limit, boolean addTrailingSlash,
+        boolean alreadyEncoded) {
+      String segment = canonicalize(
+          input, pos, limit, PATH_SEGMENT_ENCODE_SET, alreadyEncoded, false);
+      if (isDot(segment)) {
+        return; // Skip '.' path segments.
+      }
+      if (isDotDot(segment)) {
+        pop();
+        return;
+      }
+      if (encodedPathSegments.get(encodedPathSegments.size() - 1).isEmpty()) {
+        encodedPathSegments.set(encodedPathSegments.size() - 1, segment);
+      } else {
+        encodedPathSegments.add(segment);
+      }
+      if (addTrailingSlash) {
+        encodedPathSegments.add("");
+      }
+    }
+
+    private boolean isDot(String input) {
+      return input.equals(".") || input.equalsIgnoreCase("%2e");
+    }
+
+    private boolean isDotDot(String input) {
+      return input.equals("..")
+          || input.equalsIgnoreCase("%2e.")
+          || input.equalsIgnoreCase(".%2e")
+          || input.equalsIgnoreCase("%2e%2e");
+    }
+
+    /**
+     * Removes a path segment. When this method returns the last segment is always "", which means
+     * the encoded path will have a trailing '/'.
+     *
+     * <p>Popping "/a/b/c/" yields "/a/b/". In this case the list of path segments goes from
+     * ["a", "b", "c", ""] to ["a", "b", ""].
+     *
+     * <p>Popping "/a/b/c" also yields "/a/b/". The list of path segments goes from ["a", "b", "c"]
+     * to ["a", "b", ""].
+     */
+    private void pop() {
+      String removed = encodedPathSegments.remove(encodedPathSegments.size() - 1);
+
+      // Make sure the path ends with a '/' by either adding an empty string or clearing a segment.
+      if (removed.isEmpty() && !encodedPathSegments.isEmpty()) {
+        encodedPathSegments.set(encodedPathSegments.size() - 1, "");
+      } else {
+        encodedPathSegments.add("");
+      }
+    }
+
+    /**
+     * Increments {@code pos} until {@code input[pos]} is not ASCII whitespace. Stops at {@code
+     * limit}.
+     */
+    private int skipLeadingAsciiWhitespace(String input, int pos, int limit) {
+      for (int i = pos; i < limit; i++) {
+        switch (input.charAt(i)) {
+          case '\t':
+          case '\n':
+          case '\f':
+          case '\r':
+          case ' ':
+            continue;
+          default:
+            return i;
+        }
+      }
+      return limit;
+    }
+
+    /**
+     * Decrements {@code limit} until {@code input[limit - 1]} is not ASCII whitespace. Stops at
+     * {@code pos}.
+     */
+    private int skipTrailingAsciiWhitespace(String input, int pos, int limit) {
+      for (int i = limit - 1; i >= pos; i--) {
+        switch (input.charAt(i)) {
+          case '\t':
+          case '\n':
+          case '\f':
+          case '\r':
+          case ' ':
+            continue;
+          default:
+            return i + 1;
+        }
+      }
+      return pos;
+    }
+
+    /**
+     * Returns the index of the ':' in {@code input} that is after scheme characters. Returns -1 if
+     * {@code input} does not have a scheme that starts at {@code pos}.
+     */
+    private static int schemeDelimiterOffset(String input, int pos, int limit) {
+      if (limit - pos < 2) return -1;
+
+      char c0 = input.charAt(pos);
+      if ((c0 < 'a' || c0 > 'z') && (c0 < 'A' || c0 > 'Z')) return -1; // Not a scheme start char.
+
+      for (int i = pos + 1; i < limit; i++) {
+        char c = input.charAt(i);
+
+        if ((c >= 'a' && c <= 'z')
+            || (c >= 'A' && c <= 'Z')
+            || c == '+'
+            || c == '-'
+            || c == '.') {
+          continue; // Scheme character. Keep going.
+        } else if (c == ':') {
+          return i; // Scheme prefix!
+        } else {
+          return -1; // Non-scheme character before the first ':'.
+        }
+      }
+
+      return -1; // No ':'; doesn't start with a scheme.
+    }
+
+    /** Returns the number of '/' and '\' slashes in {@code input}, starting at {@code pos}. */
+    private static int slashCount(String input, int pos, int limit) {
+      int slashCount = 0;
+      while (pos < limit) {
+        char c = input.charAt(pos);
+        if (c == '\\' || c == '/') {
+          slashCount++;
+          pos++;
+        } else {
+          break;
+        }
+      }
+      return slashCount;
+    }
+
+    /** Finds the first ':' in {@code input}, skipping characters between square braces "[...]". */
+    private static int portColonOffset(String input, int pos, int limit) {
+      for (int i = pos; i < limit; i++) {
+        switch (input.charAt(i)) {
+          case '[':
+            while (++i < limit) {
+              if (input.charAt(i) == ']') break;
+            }
+            break;
+          case ':':
+            return i;
+        }
+      }
+      return limit; // No colon.
+    }
+
+    private static String canonicalizeHost(String input, int pos, int limit) {
+      // Start by percent decoding the host. The WHATWG spec suggests doing this only after we've
+      // checked for IPv6 square braces. But Chrome does it first, and that's more lenient.
+      String percentDecoded = percentDecode(input, pos, limit);
+
+      // If the input is encased in square braces "[...]", drop 'em. We have an IPv6 address.
+      if (percentDecoded.startsWith("[") && percentDecoded.endsWith("]")) {
+        InetAddress inetAddress = decodeIpv6(percentDecoded, 1, percentDecoded.length() - 1);
+        if (inetAddress == null) return null;
+        byte[] address = inetAddress.getAddress();
+        if (address.length == 16) return inet6AddressToAscii(address);
+        throw new AssertionError();
+      }
+
+      // Do IDN decoding. This converts {@code ☃.net} to {@code xn--n3h.net}.
+      String idnDecoded = domainToAscii(percentDecoded);
+      if (idnDecoded == null) return null;
+
+      // Confirm that the decoded result doesn't contain any illegal characters.
+      int length = idnDecoded.length();
+      if (delimiterOffset(idnDecoded, 0, length, "\u0000\t\n\r #%/:?@[\\]") != length) {
+        return null;
+      }
+
+      return idnDecoded;
+    }
+
+    /** Decodes an IPv6 address like 1111:2222:3333:4444:5555:6666:7777:8888 or ::1. */
+    private static InetAddress decodeIpv6(String input, int pos, int limit) {
+      byte[] address = new byte[16];
+      int b = 0;
+      int compress = -1;
+      int groupOffset = -1;
+
+      for (int i = pos; i < limit; ) {
+        if (b == address.length) return null; // Too many groups.
+
+        // Read a delimiter.
+        if (i + 2 <= limit && input.regionMatches(i, "::", 0, 2)) {
+          // Compression "::" delimiter, which is anywhere in the input, including its prefix.
+          if (compress != -1) return null; // Multiple "::" delimiters.
+          i += 2;
+          b += 2;
+          compress = b;
+          if (i == limit) break;
+        } else if (b != 0) {
+          // Group separator ":" delimiter.
+          if (input.regionMatches(i, ":", 0, 1)) {
+            i++;
+          } else if (input.regionMatches(i, ".", 0, 1)) {
+            // If we see a '.', rewind to the beginning of the previous group and parse as IPv4.
+            if (!decodeIpv4Suffix(input, groupOffset, limit, address, b - 2)) return null;
+            b += 2; // We rewound two bytes and then added four.
+            break;
+          } else {
+            return null; // Wrong delimiter.
+          }
+        }
+
+        // Read a group, one to four hex digits.
+        int value = 0;
+        groupOffset = i;
+        for (; i < limit; i++) {
+          char c = input.charAt(i);
+          int hexDigit = decodeHexDigit(c);
+          if (hexDigit == -1) break;
+          value = (value << 4) + hexDigit;
+        }
+        int groupLength = i - groupOffset;
+        if (groupLength == 0 || groupLength > 4) return null; // Group is the wrong size.
+
+        // We've successfully read a group. Assign its value to our byte array.
+        address[b++] = (byte) ((value >>> 8) & 0xff);
+        address[b++] = (byte) (value & 0xff);
+      }
+
+      // All done. If compression happened, we need to move bytes to the right place in the
+      // address. Here's a sample:
+      //
+      //      input: "1111:2222:3333::7777:8888"
+      //     before: { 11, 11, 22, 22, 33, 33, 00, 00, 77, 77, 88, 88, 00, 00, 00, 00  }
+      //   compress: 6
+      //          b: 10
+      //      after: { 11, 11, 22, 22, 33, 33, 00, 00, 00, 00, 00, 00, 77, 77, 88, 88 }
+      //
+      if (b != address.length) {
+        if (compress == -1) return null; // Address didn't have compression or enough groups.
+        System.arraycopy(address, compress, address, address.length - (b - compress), b - compress);
+        Arrays.fill(address, compress, compress + (address.length - b), (byte) 0);
+      }
+
+      try {
+        return InetAddress.getByAddress(address);
+      } catch (UnknownHostException e) {
+        throw new AssertionError();
+      }
+    }
+
+    /** Decodes an IPv4 address suffix of an IPv6 address, like 1111::5555:6666:192.168.0.1. */
+    private static boolean decodeIpv4Suffix(
+        String input, int pos, int limit, byte[] address, int addressOffset) {
+      int b = addressOffset;
+
+      for (int i = pos; i < limit; ) {
+        if (b == address.length) return false; // Too many groups.
+
+        // Read a delimiter.
+        if (b != addressOffset) {
+          if (input.charAt(i) != '.') return false; // Wrong delimiter.
+          i++;
+        }
+
+        // Read 1 or more decimal digits for a value in 0..255.
+        int value = 0;
+        int groupOffset = i;
+        for (; i < limit; i++) {
+          char c = input.charAt(i);
+          if (c < '0' || c > '9') break;
+          if (value == 0 && groupOffset != i) return false; // Reject unnecessary leading '0's.
+          value = (value * 10) + c - '0';
+          if (value > 255) return false; // Value out of range.
+        }
+        int groupLength = i - groupOffset;
+        if (groupLength == 0) return false; // No digits.
+
+        // We've successfully read a byte.
+        address[b++] = (byte) value;
+      }
+
+      if (b != addressOffset + 4) return false; // Too few groups. We wanted exactly four.
+      return true; // Success.
+    }
+
+    private static String domainToAscii(String input) {
+      try {
+        String result = IDN.toASCII(input).toLowerCase(Locale.US);
+        if (result.isEmpty()) return null;
+        // TODO: implement all label limits.
+        return result;
+      } catch (IllegalArgumentException e) {
+        return null;
+      }
+    }
+
+    private static String inet6AddressToAscii(byte[] address) {
+      // Go through the address looking for the longest run of 0s. Each group is 2-bytes.
+      int longestRunOffset = -1;
+      int longestRunLength = 0;
+      for (int i = 0; i < address.length; i += 2) {
+        int currentRunOffset = i;
+        while (i < 16 && address[i] == 0 && address[i + 1] == 0) {
+          i += 2;
+        }
+        int currentRunLength = i - currentRunOffset;
+        if (currentRunLength > longestRunLength) {
+          longestRunOffset = currentRunOffset;
+          longestRunLength = currentRunLength;
+        }
+      }
+
+      // Emit each 2-byte group in hex, separated by ':'. The longest run of zeroes is "::".
+      Buffer result = new Buffer();
+      for (int i = 0; i < address.length; ) {
+        if (i == longestRunOffset) {
+          result.writeByte(':');
+          i += longestRunLength;
+          if (i == 16) result.writeByte(':');
+        } else {
+          if (i > 0) result.writeByte(':');
+          int group = (address[i] & 0xff) << 8 | address[i + 1] & 0xff;
+          result.writeHexadecimalUnsignedLong(group);
+          i += 2;
+        }
+      }
+      return result.readUtf8();
+    }
+
+    private static int parsePort(String input, int pos, int limit) {
+      try {
+        // Canonicalize the port string to skip '\n' etc.
+        String portString = canonicalize(input, pos, limit, "", false, false);
+        int i = Integer.parseInt(portString);
+        if (i > 0 && i <= 65535) return i;
+        return -1;
+      } catch (NumberFormatException e) {
+        return -1; // Invalid port.
+      }
+    }
+  }
+
+  /**
+   * Returns the index of the first character in {@code input} that contains a character in {@code
+   * delimiters}. Returns limit if there is no such character.
+   */
+  private static int delimiterOffset(String input, int pos, int limit, String delimiters) {
+    for (int i = pos; i < limit; i++) {
+      if (delimiters.indexOf(input.charAt(i)) != -1) return i;
+    }
+    return limit;
+  }
+
+  static String percentDecode(String encoded) {
+    return percentDecode(encoded, 0, encoded.length());
+  }
+
+  private List<String> percentDecode(List<String> list) {
+    List<String> result = new ArrayList<>(list.size());
+    for (String s : list) {
+      result.add(s != null ? percentDecode(s) : null);
+    }
+    return Collections.unmodifiableList(result);
+  }
+
+  static String percentDecode(String encoded, int pos, int limit) {
+    for (int i = pos; i < limit; i++) {
+      char c = encoded.charAt(i);
+      if (c == '%') {
+        // Slow path: the character at i requires decoding!
+        Buffer out = new Buffer();
+        out.writeUtf8(encoded, pos, i);
+        percentDecode(out, encoded, i, limit);
+        return out.readUtf8();
+      }
+    }
+
+    // Fast path: no characters in [pos..limit) required decoding.
+    return encoded.substring(pos, limit);
+  }
+
+  static void percentDecode(Buffer out, String encoded, int pos, int limit) {
+    int codePoint;
+    for (int i = pos; i < limit; i += Character.charCount(codePoint)) {
+      codePoint = encoded.codePointAt(i);
+      if (codePoint == '%' && i + 2 < limit) {
+        int d1 = decodeHexDigit(encoded.charAt(i + 1));
+        int d2 = decodeHexDigit(encoded.charAt(i + 2));
+        if (d1 != -1 && d2 != -1) {
+          out.writeByte((d1 << 4) + d2);
+          i += 2;
+          continue;
+        }
+      }
+      out.writeUtf8CodePoint(codePoint);
+    }
+  }
+
+  static int decodeHexDigit(char c) {
+    if (c >= '0' && c <= '9') return c - '0';
+    if (c >= 'a' && c <= 'f') return c - 'a' + 10;
+    if (c >= 'A' && c <= 'F') return c - 'A' + 10;
+    return -1;
+  }
+
+  /**
+   * Returns a substring of {@code input} on the range {@code [pos..limit)} with the following
+   * transformations:
+   * <ul>
+   *   <li>Tabs, newlines, form feeds and carriage returns are skipped.
+   *   <li>In queries, ' ' is encoded to '+' and '+' is encoded to "%2B".
+   *   <li>Characters in {@code encodeSet} are percent-encoded.
+   *   <li>Control characters and non-ASCII characters are percent-encoded.
+   *   <li>All other characters are copied without transformation.
+   * </ul>
+   *
+   * @param alreadyEncoded true to leave '%' as-is; false to convert it to '%25'.
+   * @param query true if to encode ' ' as '+', and '+' as "%2B".
+   */
+  static String canonicalize(String input, int pos, int limit, String encodeSet,
+      boolean alreadyEncoded, boolean query) {
+    int codePoint;
+    for (int i = pos; i < limit; i += Character.charCount(codePoint)) {
+      codePoint = input.codePointAt(i);
+      if (codePoint < 0x20
+          || codePoint >= 0x7f
+          || encodeSet.indexOf(codePoint) != -1
+          || (codePoint == '%' && !alreadyEncoded)
+          || (query && codePoint == '+')) {
+        // Slow path: the character at i requires encoding!
+        Buffer out = new Buffer();
+        out.writeUtf8(input, pos, i);
+        canonicalize(out, input, i, limit, encodeSet, alreadyEncoded, query);
+        return out.readUtf8();
+      }
+    }
+
+    // Fast path: no characters in [pos..limit) required encoding.
+    return input.substring(pos, limit);
+  }
+
+  static void canonicalize(Buffer out, String input, int pos, int limit,
+      String encodeSet, boolean alreadyEncoded, boolean query) {
+    Buffer utf8Buffer = null; // Lazily allocated.
+    int codePoint;
+    for (int i = pos; i < limit; i += Character.charCount(codePoint)) {
+      codePoint = input.codePointAt(i);
+      if (alreadyEncoded
+          && (codePoint == '\t' || codePoint == '\n' || codePoint == '\f' || codePoint == '\r')) {
+        // Skip this character.
+      } else if (query && codePoint == '+') {
+        // HTML permits space to be encoded as '+'. We use '%20' to avoid special cases.
+        out.writeUtf8(alreadyEncoded ? "%20" : "%2B");
+      } else if (codePoint < 0x20
+          || codePoint >= 0x7f
+          || encodeSet.indexOf(codePoint) != -1
+          || (codePoint == '%' && !alreadyEncoded)) {
+        // Percent encode this character.
+        if (utf8Buffer == null) {
+          utf8Buffer = new Buffer();
+        }
+        utf8Buffer.writeUtf8CodePoint(codePoint);
+        while (!utf8Buffer.exhausted()) {
+          int b = utf8Buffer.readByte() & 0xff;
+          out.writeByte('%');
+          out.writeByte(HEX_DIGITS[(b >> 4) & 0xf]);
+          out.writeByte(HEX_DIGITS[b & 0xf]);
+        }
+      } else {
+        // This character doesn't need encoding. Just copy it over.
+        out.writeUtf8CodePoint(codePoint);
+      }
+    }
+  }
+
+  static String canonicalize(
+      String input, String encodeSet, boolean alreadyEncoded, boolean query) {
+    return canonicalize(input, 0, input.length(), encodeSet, alreadyEncoded, query);
+  }
+}
diff --git a/okhttp/src/main/java/com/squareup/okhttp/MultipartBuilder.java b/okhttp/src/main/java/com/squareup/okhttp/MultipartBuilder.java
index be24c7b8a7..5b160b6741 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/MultipartBuilder.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/MultipartBuilder.java
@@ -20,6 +20,7 @@
 import java.util.ArrayList;
 import java.util.List;
 import java.util.UUID;
+import okio.Buffer;
 import okio.BufferedSink;
 import okio.ByteString;
 
@@ -197,6 +198,7 @@ public RequestBody build() {
     private final MediaType contentType;
     private final List<Headers> partHeaders;
     private final List<RequestBody> partBodies;
+    private long contentLength = -1L;
 
     public MultipartRequestBody(MediaType type, ByteString boundary, List<Headers> partHeaders,
         List<RequestBody> partBodies) {
@@ -213,10 +215,25 @@ public MultipartRequestBody(MediaType type, ByteString boundary, List<Headers> p
     }
 
     @Override public long contentLength() throws IOException {
-      return -1L;
+      long result = contentLength;
+      if (result != -1L) return result;
+      return contentLength = writeOrCountBytes(null, true);
     }
 
-    @Override public void writeTo(BufferedSink sink) throws IOException {
+    /**
+     * Either writes this request to {@code sink} or measures its content length. We have one method
+     * do double-duty to make sure the counting and content are consistent, particularly when it
+     * comes to awkward operations like measuring the encoded length of header strings, or the
+     * length-in-digits of an encoded integer.
+     */
+    private long writeOrCountBytes(BufferedSink sink, boolean countBytes) throws IOException {
+      long byteCount = 0L;
+
+      Buffer byteCountBuffer = null;
+      if (countBytes) {
+        sink = byteCountBuffer = new Buffer();
+      }
+
       for (int p = 0, partCount = partHeaders.size(); p < partCount; p++) {
         Headers headers = partHeaders.get(p);
         RequestBody body = partBodies.get(p);
@@ -244,12 +261,22 @@ public MultipartRequestBody(MediaType type, ByteString boundary, List<Headers> p
         long contentLength = body.contentLength();
         if (contentLength != -1) {
           sink.writeUtf8("Content-Length: ")
-              .writeUtf8(Long.toString(contentLength))
+              .writeDecimalLong(contentLength)
               .write(CRLF);
+        } else if (countBytes) {
+          // We can't measure the body's size without the sizes of its components.
+          byteCountBuffer.clear();
+          return -1L;
         }
 
         sink.write(CRLF);
-        partBodies.get(p).writeTo(sink);
+
+        if (countBytes) {
+          byteCount += contentLength;
+        } else {
+          partBodies.get(p).writeTo(sink);
+        }
+
         sink.write(CRLF);
       }
 
@@ -257,6 +284,17 @@ public MultipartRequestBody(MediaType type, ByteString boundary, List<Headers> p
       sink.write(boundary);
       sink.write(DASHDASH);
       sink.write(CRLF);
+
+      if (countBytes) {
+        byteCount += byteCountBuffer.size();
+        byteCountBuffer.clear();
+      }
+
+      return byteCount;
+    }
+
+    @Override public void writeTo(BufferedSink sink) throws IOException {
+      writeOrCountBytes(sink, false);
     }
   }
 }
diff --git a/okhttp/src/main/java/com/squareup/okhttp/OkHttpClient.java b/okhttp/src/main/java/com/squareup/okhttp/OkHttpClient.java
index 56b55f9da7..4ed8000a66 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/OkHttpClient.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/OkHttpClient.java
@@ -22,13 +22,16 @@
 import com.squareup.okhttp.internal.Util;
 import com.squareup.okhttp.internal.http.AuthenticatorAdapter;
 import com.squareup.okhttp.internal.http.HttpEngine;
+import com.squareup.okhttp.internal.http.RouteException;
 import com.squareup.okhttp.internal.http.Transport;
 import com.squareup.okhttp.internal.tls.OkHostnameVerifier;
 import java.io.IOException;
 import java.net.CookieHandler;
+import java.net.MalformedURLException;
 import java.net.Proxy;
 import java.net.ProxySelector;
 import java.net.URLConnection;
+import java.net.UnknownHostException;
 import java.security.GeneralSecurityException;
 import java.util.ArrayList;
 import java.util.List;
@@ -36,7 +39,10 @@
 import javax.net.SocketFactory;
 import javax.net.ssl.HostnameVerifier;
 import javax.net.ssl.SSLContext;
+import javax.net.ssl.SSLSocket;
 import javax.net.ssl.SSLSocketFactory;
+import okio.BufferedSink;
+import okio.BufferedSource;
 
 /**
  * Configures and creates HTTP connections. Most applications can use a single
@@ -91,6 +97,10 @@
         builder.addLenient(line);
       }
 
+      @Override public void addLenient(Headers.Builder builder, String name, String value) {
+        builder.addLenient(name, value);
+      }
+
       @Override public void setCache(OkHttpClient client, InternalCache internalCache) {
         client.setInternalCache(internalCache);
       }
@@ -116,7 +126,7 @@
       }
 
       @Override public void connectAndSetOwner(OkHttpClient client, Connection connection,
-          HttpEngine owner, Request request) throws IOException {
+          HttpEngine owner, Request request) throws RouteException {
         connection.connectAndSetOwner(client, owner, request);
       }
 
@@ -133,9 +143,27 @@ public void callEnqueue(Call call, Callback responseCallback, boolean forWebSock
         return call.engine.getConnection();
       }
 
+      @Override public BufferedSource connectionRawSource(Connection connection) {
+        return connection.rawSource();
+      }
+
+      @Override public BufferedSink connectionRawSink(Connection connection) {
+        return connection.rawSink();
+      }
+
       @Override public void connectionSetOwner(Connection connection, Object owner) {
         connection.setOwner(owner);
       }
+
+      @Override
+      public void apply(ConnectionSpec tlsConfiguration, SSLSocket sslSocket, boolean isFallback) {
+        tlsConfiguration.apply(sslSocket, isFallback);
+      }
+
+      @Override public HttpUrl getHttpUrlChecked(String url)
+          throws MalformedURLException, UnknownHostException {
+        return HttpUrl.getChecked(url);
+      }
     };
   }
 
@@ -166,9 +194,9 @@ public void callEnqueue(Call call, Callback responseCallback, boolean forWebSock
   private boolean followSslRedirects = true;
   private boolean followRedirects = true;
   private boolean retryOnConnectionFailure = true;
-  private int connectTimeout;
-  private int readTimeout;
-  private int writeTimeout;
+  private int connectTimeout = 10_000;
+  private int readTimeout = 10_000;
+  private int writeTimeout = 10_000;
 
   public OkHttpClient() {
     routeDatabase = new RouteDatabase();
@@ -203,54 +231,60 @@ private OkHttpClient(OkHttpClient okHttpClient) {
   }
 
   /**
-   * Sets the default connect timeout for new connections. A value of 0 means no timeout.
+   * Sets the default connect timeout for new connections. A value of 0 means no timeout, otherwise
+   * values must be between 1 and {@link Integer#MAX_VALUE} when converted to milliseconds.
    *
    * @see URLConnection#setConnectTimeout(int)
    */
-  public final void setConnectTimeout(long timeout, TimeUnit unit) {
+  public void setConnectTimeout(long timeout, TimeUnit unit) {
     if (timeout < 0) throw new IllegalArgumentException("timeout < 0");
     if (unit == null) throw new IllegalArgumentException("unit == null");
     long millis = unit.toMillis(timeout);
     if (millis > Integer.MAX_VALUE) throw new IllegalArgumentException("Timeout too large.");
+    if (millis == 0 && timeout > 0) throw new IllegalArgumentException("Timeout too small.");
     connectTimeout = (int) millis;
   }
 
   /** Default connect timeout (in milliseconds). */
-  public final int getConnectTimeout() {
+  public int getConnectTimeout() {
     return connectTimeout;
   }
 
   /**
-   * Sets the default read timeout for new connections. A value of 0 means no timeout.
+   * Sets the default read timeout for new connections. A value of 0 means no timeout, otherwise
+   * values must be between 1 and {@link Integer#MAX_VALUE} when converted to milliseconds.
    *
    * @see URLConnection#setReadTimeout(int)
    */
-  public final void setReadTimeout(long timeout, TimeUnit unit) {
+  public void setReadTimeout(long timeout, TimeUnit unit) {
     if (timeout < 0) throw new IllegalArgumentException("timeout < 0");
     if (unit == null) throw new IllegalArgumentException("unit == null");
     long millis = unit.toMillis(timeout);
     if (millis > Integer.MAX_VALUE) throw new IllegalArgumentException("Timeout too large.");
+    if (millis == 0 && timeout > 0) throw new IllegalArgumentException("Timeout too small.");
     readTimeout = (int) millis;
   }
 
   /** Default read timeout (in milliseconds). */
-  public final int getReadTimeout() {
+  public int getReadTimeout() {
     return readTimeout;
   }
 
   /**
-   * Sets the default write timeout for new connections. A value of 0 means no timeout.
+   * Sets the default write timeout for new connections. A value of 0 means no timeout, otherwise
+   * values must be between 1 and {@link Integer#MAX_VALUE} when converted to milliseconds.
    */
-  public final void setWriteTimeout(long timeout, TimeUnit unit) {
+  public void setWriteTimeout(long timeout, TimeUnit unit) {
     if (timeout < 0) throw new IllegalArgumentException("timeout < 0");
     if (unit == null) throw new IllegalArgumentException("unit == null");
     long millis = unit.toMillis(timeout);
     if (millis > Integer.MAX_VALUE) throw new IllegalArgumentException("Timeout too large.");
+    if (millis == 0 && timeout > 0) throw new IllegalArgumentException("Timeout too small.");
     writeTimeout = (int) millis;
   }
 
   /** Default write timeout (in milliseconds). */
-  public final int getWriteTimeout() {
+  public int getWriteTimeout() {
     return writeTimeout;
   }
 
@@ -260,12 +294,12 @@ public final int getWriteTimeout() {
    * only honored when this proxy is null (which it is by default). To disable
    * proxy use completely, call {@code setProxy(Proxy.NO_PROXY)}.
    */
-  public final OkHttpClient setProxy(Proxy proxy) {
+  public OkHttpClient setProxy(Proxy proxy) {
     this.proxy = proxy;
     return this;
   }
 
-  public final Proxy getProxy() {
+  public Proxy getProxy() {
     return proxy;
   }
 
@@ -278,12 +312,12 @@ public final Proxy getProxy() {
    * <p>If unset, the {@link ProxySelector#getDefault() system-wide default}
    * proxy selector will be used.
    */
-  public final OkHttpClient setProxySelector(ProxySelector proxySelector) {
+  public OkHttpClient setProxySelector(ProxySelector proxySelector) {
     this.proxySelector = proxySelector;
     return this;
   }
 
-  public final ProxySelector getProxySelector() {
+  public ProxySelector getProxySelector() {
     return proxySelector;
   }
 
@@ -294,47 +328,50 @@ public final ProxySelector getProxySelector() {
    * <p>If unset, the {@link CookieHandler#getDefault() system-wide default}
    * cookie handler will be used.
    */
-  public final OkHttpClient setCookieHandler(CookieHandler cookieHandler) {
+  public OkHttpClient setCookieHandler(CookieHandler cookieHandler) {
     this.cookieHandler = cookieHandler;
     return this;
   }
 
-  public final CookieHandler getCookieHandler() {
+  public CookieHandler getCookieHandler() {
     return cookieHandler;
   }
 
   /** Sets the response cache to be used to read and write cached responses. */
-  final void setInternalCache(InternalCache internalCache) {
+  void setInternalCache(InternalCache internalCache) {
     this.internalCache = internalCache;
     this.cache = null;
   }
 
-  final InternalCache internalCache() {
+  InternalCache internalCache() {
     return internalCache;
   }
 
-  public final OkHttpClient setCache(Cache cache) {
+  public OkHttpClient setCache(Cache cache) {
     this.cache = cache;
     this.internalCache = null;
     return this;
   }
 
-  public final Cache getCache() {
+  public Cache getCache() {
     return cache;
   }
 
   /**
-   * Sets the socket factory used to create connections.
+   * Sets the socket factory used to create connections. OkHttp only uses
+   * the parameterless {@link SocketFactory#createSocket() createSocket()}
+   * method to create unconnected sockets. Overriding this method,
+   * e. g., allows the socket to be bound to a specific local address.
    *
    * <p>If unset, the {@link SocketFactory#getDefault() system-wide default}
    * socket factory will be used.
    */
-  public final OkHttpClient setSocketFactory(SocketFactory socketFactory) {
+  public OkHttpClient setSocketFactory(SocketFactory socketFactory) {
     this.socketFactory = socketFactory;
     return this;
   }
 
-  public final SocketFactory getSocketFactory() {
+  public SocketFactory getSocketFactory() {
     return socketFactory;
   }
 
@@ -343,12 +380,12 @@ public final SocketFactory getSocketFactory() {
    *
    * <p>If unset, a lazily created SSL socket factory will be used.
    */
-  public final OkHttpClient setSslSocketFactory(SSLSocketFactory sslSocketFactory) {
+  public OkHttpClient setSslSocketFactory(SSLSocketFactory sslSocketFactory) {
     this.sslSocketFactory = sslSocketFactory;
     return this;
   }
 
-  public final SSLSocketFactory getSslSocketFactory() {
+  public SSLSocketFactory getSslSocketFactory() {
     return sslSocketFactory;
   }
 
@@ -358,12 +395,12 @@ public final SSLSocketFactory getSslSocketFactory() {
    *
    * <p>If unset, a default hostname verifier will be used.
    */
-  public final OkHttpClient setHostnameVerifier(HostnameVerifier hostnameVerifier) {
+  public OkHttpClient setHostnameVerifier(HostnameVerifier hostnameVerifier) {
     this.hostnameVerifier = hostnameVerifier;
     return this;
   }
 
-  public final HostnameVerifier getHostnameVerifier() {
+  public HostnameVerifier getHostnameVerifier() {
     return hostnameVerifier;
   }
 
@@ -373,12 +410,12 @@ public final HostnameVerifier getHostnameVerifier() {
    * SSL socket factory} to establish trust. Pinning certificates avoids the
    * need to trust certificate authorities.
    */
-  public final OkHttpClient setCertificatePinner(CertificatePinner certificatePinner) {
+  public OkHttpClient setCertificatePinner(CertificatePinner certificatePinner) {
     this.certificatePinner = certificatePinner;
     return this;
   }
 
-  public final CertificatePinner getCertificatePinner() {
+  public CertificatePinner getCertificatePinner() {
     return certificatePinner;
   }
 
@@ -389,12 +426,12 @@ public final CertificatePinner getCertificatePinner() {
    * <p>If unset, the {@link java.net.Authenticator#setDefault system-wide default}
    * authenticator will be used.
    */
-  public final OkHttpClient setAuthenticator(Authenticator authenticator) {
+  public OkHttpClient setAuthenticator(Authenticator authenticator) {
     this.authenticator = authenticator;
     return this;
   }
 
-  public final Authenticator getAuthenticator() {
+  public Authenticator getAuthenticator() {
     return authenticator;
   }
 
@@ -404,12 +441,12 @@ public final Authenticator getAuthenticator() {
    * <p>If unset, the {@link ConnectionPool#getDefault() system-wide
    * default} connection pool will be used.
    */
-  public final OkHttpClient setConnectionPool(ConnectionPool connectionPool) {
+  public OkHttpClient setConnectionPool(ConnectionPool connectionPool) {
     this.connectionPool = connectionPool;
     return this;
   }
 
-  public final ConnectionPool getConnectionPool() {
+  public ConnectionPool getConnectionPool() {
     return connectionPool;
   }
 
@@ -420,21 +457,21 @@ public final ConnectionPool getConnectionPool() {
    * <p>If unset, protocol redirects will be followed. This is different than
    * the built-in {@code HttpURLConnection}'s default.
    */
-  public final OkHttpClient setFollowSslRedirects(boolean followProtocolRedirects) {
+  public OkHttpClient setFollowSslRedirects(boolean followProtocolRedirects) {
     this.followSslRedirects = followProtocolRedirects;
     return this;
   }
 
-  public final boolean getFollowSslRedirects() {
+  public boolean getFollowSslRedirects() {
     return followSslRedirects;
   }
 
   /** Configure this client to follow redirects. If unset, redirects be followed. */
-  public final void setFollowRedirects(boolean followRedirects) {
+  public void setFollowRedirects(boolean followRedirects) {
     this.followRedirects = followRedirects;
   }
 
-  public final boolean getFollowRedirects() {
+  public boolean getFollowRedirects() {
     return followRedirects;
   }
 
@@ -456,15 +493,15 @@ public final boolean getFollowRedirects() {
    * Set this to false to avoid retrying requests when doing so is destructive. In this case the
    * calling application should do its own recovery of connectivity failures.
    */
-  public final void setRetryOnConnectionFailure(boolean retryOnConnectionFailure) {
+  public void setRetryOnConnectionFailure(boolean retryOnConnectionFailure) {
     this.retryOnConnectionFailure = retryOnConnectionFailure;
   }
 
-  public final boolean getRetryOnConnectionFailure() {
+  public boolean getRetryOnConnectionFailure() {
     return retryOnConnectionFailure;
   }
 
-  final RouteDatabase routeDatabase() {
+  RouteDatabase routeDatabase() {
     return routeDatabase;
   }
 
@@ -472,13 +509,13 @@ final RouteDatabase routeDatabase() {
    * Sets the dispatcher used to set policy and execute asynchronous requests.
    * Must not be null.
    */
-  public final OkHttpClient setDispatcher(Dispatcher dispatcher) {
+  public OkHttpClient setDispatcher(Dispatcher dispatcher) {
     if (dispatcher == null) throw new IllegalArgumentException("dispatcher == null");
     this.dispatcher = dispatcher;
     return this;
   }
 
-  public final Dispatcher getDispatcher() {
+  public Dispatcher getDispatcher() {
     return dispatcher;
   }
 
@@ -493,12 +530,12 @@ public final Dispatcher getDispatcher() {
    * <ul>
    *   <li><a href="http://www.w3.org/Protocols/rfc2616/rfc2616.html">http/1.1</a>
    *   <li><a href="http://www.chromium.org/spdy/spdy-protocol/spdy-protocol-draft3-1">spdy/3.1</a>
-   *   <li><a href="http://tools.ietf.org/html/draft-ietf-httpbis-http2-16">h2-16</a>
+   *   <li><a href="http://tools.ietf.org/html/draft-ietf-httpbis-http2-17">h2</a>
    * </ul>
    *
-   * <p><strong>This is an evolving set.</strong> Future releases may drop
-   * support for transitional protocols (like h2-16), in favor of their
-   * successors (h2). The http/1.1 transport will never be dropped.
+   * <p><strong>This is an evolving set.</strong> Future releases include
+   * support for transitional protocols. The http/1.1 transport will never be
+   * dropped.
    *
    * <p>If multiple protocols are specified, <a
    * href="http://tools.ietf.org/html/draft-ietf-tls-applayerprotoneg">ALPN</a>
@@ -512,7 +549,7 @@ public final Dispatcher getDispatcher() {
    *     must contain {@link Protocol#HTTP_1_1}. It must not contain null or
    *     {@link Protocol#HTTP_1_0}.
    */
-  public final OkHttpClient setProtocols(List<Protocol> protocols) {
+  public OkHttpClient setProtocols(List<Protocol> protocols) {
     protocols = Util.immutableList(protocols);
     if (!protocols.contains(Protocol.HTTP_1_1)) {
       throw new IllegalArgumentException("protocols doesn't contain http/1.1: " + protocols);
@@ -527,16 +564,16 @@ public final OkHttpClient setProtocols(List<Protocol> protocols) {
     return this;
   }
 
-  public final List<Protocol> getProtocols() {
+  public List<Protocol> getProtocols() {
     return protocols;
   }
 
-  public final OkHttpClient setConnectionSpecs(List<ConnectionSpec> connectionSpecs) {
+  public OkHttpClient setConnectionSpecs(List<ConnectionSpec> connectionSpecs) {
     this.connectionSpecs = Util.immutableList(connectionSpecs);
     return this;
   }
 
-  public final List<ConnectionSpec> getConnectionSpecs() {
+  public List<ConnectionSpec> getConnectionSpecs() {
     return connectionSpecs;
   }
 
@@ -578,7 +615,7 @@ public OkHttpClient cancel(Object tag) {
    * Returns a shallow copy of this OkHttpClient that uses the system-wide
    * default for each field that hasn't been explicitly configured.
    */
-  final OkHttpClient copyWithDefaults() {
+  OkHttpClient copyWithDefaults() {
     OkHttpClient result = new OkHttpClient(this);
     if (result.proxySelector == null) {
       result.proxySelector = ProxySelector.getDefault();
@@ -641,11 +678,7 @@ private synchronized SSLSocketFactory getDefaultSSLSocketFactory() {
   }
 
   /** Returns a shallow copy of this OkHttpClient. */
-  @Override public final OkHttpClient clone() {
-    try {
-      return (OkHttpClient) super.clone();
-    } catch (CloneNotSupportedException e) {
-      throw new AssertionError();
-    }
+  @Override public OkHttpClient clone() {
+    return new OkHttpClient(this);
   }
 }
diff --git a/okhttp/src/main/java/com/squareup/okhttp/Protocol.java b/okhttp/src/main/java/com/squareup/okhttp/Protocol.java
index 03093df041..6b02098133 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/Protocol.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/Protocol.java
@@ -61,19 +61,12 @@
    * multiplexing multiple requests on the same socket, and server-push.
    * HTTP/1.1 semantics are layered on HTTP/2.
    *
-   * <p>This version of OkHttp implements HTTP/2 <a
-   * href="http://tools.ietf.org/html/draft-ietf-httpbis-http2-16">draft 16</a>
-   * with HPACK <a
-   * href="http://tools.ietf.org/html/draft-ietf-httpbis-header-compression-10">draft
-   * 10</a>. Future releases of OkHttp may use this identifier for a newer draft
-   * of these specs.
-   *
    * <p>HTTP/2 requires deployments of HTTP/2 that use TLS 1.2 support
    * {@linkplain com.squareup.okhttp.CipherSuite#TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256}
    * , present in Java 8+ and Android 5+. Servers that enforce this may send an
    * exception message including the string {@code INADEQUATE_SECURITY}.
    */
-  HTTP_2("h2-16");
+  HTTP_2("h2");
 
   private final String protocol;
 
@@ -96,7 +89,7 @@ public static Protocol get(String protocol) throws IOException {
 
   /**
    * Returns the string used to identify this protocol for ALPN, like
-   * "http/1.1", "spdy/3.1" or "h2-16".
+   * "http/1.1", "spdy/3.1" or "h2".
    */
   @Override public String toString() {
     return protocol;
diff --git a/okhttp/src/main/java/com/squareup/okhttp/Request.java b/okhttp/src/main/java/com/squareup/okhttp/Request.java
index c40ada31ae..2417c132aa 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/Request.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/Request.java
@@ -15,13 +15,9 @@
  */
 package com.squareup.okhttp;
 
-import com.squareup.okhttp.internal.Platform;
-import com.squareup.okhttp.internal.Util;
 import com.squareup.okhttp.internal.http.HttpMethod;
 import java.io.IOException;
-import java.net.MalformedURLException;
 import java.net.URI;
-import java.net.URISyntaxException;
 import java.net.URL;
 import java.util.List;
 
@@ -30,45 +26,44 @@
  * is null or itself immutable.
  */
 public final class Request {
-  private final String urlString;
+  private final HttpUrl url;
   private final String method;
   private final Headers headers;
   private final RequestBody body;
   private final Object tag;
 
-  private volatile URL url; // Lazily initialized.
-  private volatile URI uri; // Lazily initialized.
+  private volatile URL javaNetUrl; // Lazily initialized.
+  private volatile URI javaNetUri; // Lazily initialized.
   private volatile CacheControl cacheControl; // Lazily initialized.
 
   private Request(Builder builder) {
-    this.urlString = builder.urlString;
+    this.url = builder.url;
     this.method = builder.method;
     this.headers = builder.headers.build();
     this.body = builder.body;
     this.tag = builder.tag != null ? builder.tag : this;
-    this.url = builder.url;
+  }
+
+  public HttpUrl httpUrl() {
+    return url;
   }
 
   public URL url() {
-    try {
-      URL result = url;
-      return result != null ? result : (url = new URL(urlString));
-    } catch (MalformedURLException e) {
-      throw new RuntimeException("Malformed URL: " + urlString, e);
-    }
+    URL result = javaNetUrl;
+    return result != null ? result : (javaNetUrl = url.url());
   }
 
   public URI uri() throws IOException {
     try {
-      URI result = uri;
-      return result != null ? result : (uri = Platform.get().toUriLenient(url()));
-    } catch (URISyntaxException e) {
+      URI result = javaNetUri;
+      return result != null ? result : (javaNetUri = url.uri());
+    } catch (IllegalStateException e) {
       throw new IOException(e.getMessage());
     }
   }
 
   public String urlString() {
-    return urlString;
+    return url.toString();
   }
 
   public String method() {
@@ -109,22 +104,21 @@ public CacheControl cacheControl() {
   }
 
   public boolean isHttps() {
-    return url().getProtocol().equals("https");
+    return url.isHttps();
   }
 
   @Override public String toString() {
     return "Request{method="
         + method
         + ", url="
-        + urlString
+        + url
         + ", tag="
         + (tag != this ? tag : null)
         + '}';
   }
 
   public static class Builder {
-    private String urlString;
-    private URL url;
+    private HttpUrl url;
     private String method;
     private Headers.Builder headers;
     private RequestBody body;
@@ -136,7 +130,6 @@ public Builder() {
     }
 
     private Builder(Request request) {
-      this.urlString = request.urlString;
       this.url = request.url;
       this.method = request.method;
       this.body = request.body;
@@ -144,17 +137,44 @@ private Builder(Request request) {
       this.headers = request.headers.newBuilder();
     }
 
-    public Builder url(String url) {
+    public Builder url(HttpUrl url) {
       if (url == null) throw new IllegalArgumentException("url == null");
-      urlString = url;
+      this.url = url;
       return this;
     }
 
+    /**
+     * Sets the URL target of this request.
+     *
+     * @throws IllegalArgumentException if {@code url} is not a valid HTTP or HTTPS URL. Avoid this
+     *     exception by calling {@link HttpUrl#parse}; it returns null for invalid URLs.
+     */
+    public Builder url(String url) {
+      if (url == null) throw new IllegalArgumentException("url == null");
+
+      // Silently replace websocket URLs with HTTP URLs.
+      if (url.regionMatches(true, 0, "ws:", 0, 3)) {
+        url = "http:" + url.substring(3);
+      } else if (url.regionMatches(true, 0, "wss:", 0, 4)) {
+        url = "https:" + url.substring(4);
+      }
+
+      HttpUrl parsed = HttpUrl.parse(url);
+      if (parsed == null) throw new IllegalArgumentException("unexpected url: " + url);
+      return url(parsed);
+    }
+
+    /**
+     * Sets the URL target of this request.
+     *
+     * @throws IllegalArgumentException if the scheme of {@code url} is not {@code http} or {@code
+     *     https}.
+     */
     public Builder url(URL url) {
       if (url == null) throw new IllegalArgumentException("url == null");
-      this.url = url;
-      this.urlString = url.toString();
-      return this;
+      HttpUrl parsed = HttpUrl.get(url);
+      if (parsed == null) throw new IllegalArgumentException("unexpected url: " + url);
+      return url(parsed);
     }
 
     /**
@@ -214,7 +234,7 @@ public Builder delete(RequestBody body) {
     }
 
     public Builder delete() {
-      return method("DELETE", null);
+      return delete(RequestBody.create(null, new byte[0]));
     }
 
     public Builder put(RequestBody body) {
@@ -232,8 +252,8 @@ public Builder method(String method, RequestBody body) {
       if (body != null && !HttpMethod.permitsRequestBody(method)) {
         throw new IllegalArgumentException("method " + method + " must not have a request body.");
       }
-      if (body == null && HttpMethod.permitsRequestBody(method)) {
-        body = RequestBody.create(null, Util.EMPTY_BYTE_ARRAY);
+      if (body == null && HttpMethod.requiresRequestBody(method)) {
+        throw new IllegalArgumentException("method " + method + " must have a request body.");
       }
       this.method = method;
       this.body = body;
@@ -251,7 +271,7 @@ public Builder tag(Object tag) {
     }
 
     public Request build() {
-      if (urlString == null) throw new IllegalStateException("url == null");
+      if (url == null) throw new IllegalStateException("url == null");
       return new Request(this);
     }
   }
diff --git a/okhttp/src/main/java/com/squareup/okhttp/RequestBody.java b/okhttp/src/main/java/com/squareup/okhttp/RequestBody.java
index 5d7483767e..50933f71fd 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/RequestBody.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/RequestBody.java
@@ -20,6 +20,7 @@
 import java.io.IOException;
 import java.nio.charset.Charset;
 import okio.BufferedSink;
+import okio.ByteString;
 import okio.Okio;
 import okio.Source;
 
@@ -55,21 +56,44 @@ public static RequestBody create(MediaType contentType, String content) {
     return create(contentType, bytes);
   }
 
+  /** Returns a new request body that transmits {@code content}. */
+  public static RequestBody create(final MediaType contentType, final ByteString content) {
+    return new RequestBody() {
+      @Override public MediaType contentType() {
+        return contentType;
+      }
+
+      @Override public long contentLength() throws IOException {
+        return content.size();
+      }
+
+      @Override public void writeTo(BufferedSink sink) throws IOException {
+        sink.write(content);
+      }
+    };
+  }
+
   /** Returns a new request body that transmits {@code content}. */
   public static RequestBody create(final MediaType contentType, final byte[] content) {
-    if (content == null) throw new NullPointerException("content == null");
+    return create(contentType, content, 0, content.length);
+  }
 
+  /** Returns a new request body that transmits {@code content}. */
+  public static RequestBody create(final MediaType contentType, final byte[] content,
+      final int offset, final int byteCount) {
+    if (content == null) throw new NullPointerException("content == null");
+    Util.checkOffsetAndCount(content.length, offset, byteCount);
     return new RequestBody() {
       @Override public MediaType contentType() {
         return contentType;
       }
 
       @Override public long contentLength() {
-        return content.length;
+        return byteCount;
       }
 
       @Override public void writeTo(BufferedSink sink) throws IOException {
-        sink.write(content);
+        sink.write(content, offset, byteCount);
       }
     };
   }
diff --git a/okhttp/src/main/java/com/squareup/okhttp/Route.java b/okhttp/src/main/java/com/squareup/okhttp/Route.java
index f24431132f..2d27a03090 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/Route.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/Route.java
@@ -28,8 +28,6 @@
  *   <li><strong>IP address:</strong> whether connecting directly to an origin
  *       server or a proxy, opening a socket requires an IP address. The DNS
  *       server may return multiple IP addresses to attempt.
- *   <li><strong>TLS configuration:</strong> which cipher suites and TLS
- *       versions to attempt with the HTTPS connection.
  * </ul>
  * Each route is a specific selection of these options.
  */
@@ -37,17 +35,8 @@
   final Address address;
   final Proxy proxy;
   final InetSocketAddress inetSocketAddress;
-  final ConnectionSpec connectionSpec;
-  final boolean shouldSendTlsFallbackIndicator;
 
-  public Route(Address address, Proxy proxy, InetSocketAddress inetSocketAddress,
-      ConnectionSpec connectionSpec) {
-    this(address, proxy, inetSocketAddress, connectionSpec,
-        false /* shouldSendTlsFallbackIndicator */);
-  }
-
-  public Route(Address address, Proxy proxy, InetSocketAddress inetSocketAddress,
-      ConnectionSpec connectionSpec, boolean shouldSendTlsFallbackIndicator) {
+  public Route(Address address, Proxy proxy, InetSocketAddress inetSocketAddress) {
     if (address == null) {
       throw new NullPointerException("address == null");
     }
@@ -57,14 +46,9 @@ public Route(Address address, Proxy proxy, InetSocketAddress inetSocketAddress,
     if (inetSocketAddress == null) {
       throw new NullPointerException("inetSocketAddress == null");
     }
-    if (connectionSpec == null) {
-      throw new NullPointerException("connectionConfiguration == null");
-    }
     this.address = address;
     this.proxy = proxy;
     this.inetSocketAddress = inetSocketAddress;
-    this.connectionSpec = connectionSpec;
-    this.shouldSendTlsFallbackIndicator = shouldSendTlsFallbackIndicator;
   }
 
   public Address getAddress() {
@@ -86,14 +70,6 @@ public InetSocketAddress getSocketAddress() {
     return inetSocketAddress;
   }
 
-  public ConnectionSpec getConnectionSpec() {
-    return connectionSpec;
-  }
-
-  public boolean getShouldSendTlsFallbackIndicator() {
-    return shouldSendTlsFallbackIndicator;
-  }
-
   /**
    * Returns true if this route tunnels HTTPS through an HTTP proxy. See <a
    * href="http://www.ietf.org/rfc/rfc2817.txt">RFC 2817, Section 5.2</a>.
@@ -107,9 +83,7 @@ public boolean requiresTunnel() {
       Route other = (Route) obj;
       return address.equals(other.address)
           && proxy.equals(other.proxy)
-          && inetSocketAddress.equals(other.inetSocketAddress)
-          && connectionSpec.equals(other.connectionSpec)
-          && shouldSendTlsFallbackIndicator == other.shouldSendTlsFallbackIndicator;
+          && inetSocketAddress.equals(other.inetSocketAddress);
     }
     return false;
   }
@@ -119,8 +93,6 @@ public boolean requiresTunnel() {
     result = 31 * result + address.hashCode();
     result = 31 * result + proxy.hashCode();
     result = 31 * result + inetSocketAddress.hashCode();
-    result = 31 * result + connectionSpec.hashCode();
-    result = 31 * result + (shouldSendTlsFallbackIndicator ? 1 : 0);
     return result;
   }
 }
diff --git a/okhttp/src/main/java/com/squareup/okhttp/TlsVersion.java b/okhttp/src/main/java/com/squareup/okhttp/TlsVersion.java
index a8d7b9b311..bfa95c410b 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/TlsVersion.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/TlsVersion.java
@@ -43,4 +43,8 @@ public static TlsVersion forJavaName(String javaName) {
     }
     throw new IllegalArgumentException("Unexpected TLS version: " + javaName);
   }
+
+  public String javaName() {
+    return javaName;
+  }
 }
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/ConnectionSpecSelector.java b/okhttp/src/main/java/com/squareup/okhttp/internal/ConnectionSpecSelector.java
new file mode 100644
index 0000000000..1b2dc03866
--- /dev/null
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/ConnectionSpecSelector.java
@@ -0,0 +1,143 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.squareup.okhttp.internal;
+
+import com.squareup.okhttp.ConnectionSpec;
+import java.io.IOException;
+import java.io.InterruptedIOException;
+import java.net.ProtocolException;
+import java.net.UnknownServiceException;
+import java.security.cert.CertificateException;
+import java.util.Arrays;
+import java.util.List;
+import javax.net.ssl.SSLHandshakeException;
+import javax.net.ssl.SSLPeerUnverifiedException;
+import javax.net.ssl.SSLProtocolException;
+import javax.net.ssl.SSLSocket;
+
+/**
+ * Handles the connection spec fallback strategy: When a secure socket connection fails
+ * due to a handshake / protocol problem the connection may be retried with different protocols.
+ * Instances are stateful and should be created and used for a single connection attempt.
+ */
+public final class ConnectionSpecSelector {
+
+  private final List<ConnectionSpec> connectionSpecs;
+  private int nextModeIndex;
+  private boolean isFallbackPossible;
+  private boolean isFallback;
+
+  public ConnectionSpecSelector(List<ConnectionSpec> connectionSpecs) {
+    this.nextModeIndex = 0;
+    this.connectionSpecs = connectionSpecs;
+  }
+
+  /**
+   * Configures the supplied {@link SSLSocket} to connect to the specified host using an appropriate
+   * {@link ConnectionSpec}. Returns the chosen {@link ConnectionSpec}, never {@code null}.
+   *
+   * @throws IOException if the socket does not support any of the TLS modes available
+   */
+  public ConnectionSpec configureSecureSocket(SSLSocket sslSocket) throws IOException {
+    ConnectionSpec tlsConfiguration = null;
+    for (int i = nextModeIndex, size = connectionSpecs.size(); i < size; i++) {
+      ConnectionSpec connectionSpec = connectionSpecs.get(i);
+      if (connectionSpec.isCompatible(sslSocket)) {
+        tlsConfiguration = connectionSpec;
+        nextModeIndex = i + 1;
+        break;
+      }
+    }
+
+    if (tlsConfiguration == null) {
+      // This may be the first time a connection has been attempted and the socket does not support
+      // any the required protocols, or it may be a retry (but this socket supports fewer
+      // protocols than was suggested by a prior socket).
+      throw new UnknownServiceException(
+          "Unable to find acceptable protocols. isFallback=" + isFallback
+              + ", modes=" + connectionSpecs
+              + ", supported protocols=" + Arrays.toString(sslSocket.getEnabledProtocols()));
+    }
+
+    isFallbackPossible = isFallbackPossible(sslSocket);
+
+    Internal.instance.apply(tlsConfiguration, sslSocket, isFallback);
+
+    return tlsConfiguration;
+  }
+
+  /**
+   * Reports a failure to complete a connection. Determines the next {@link ConnectionSpec} to
+   * try, if any.
+   *
+   * @return {@code true} if the connection should be retried using
+   *     {@link #configureSecureSocket(SSLSocket)} or {@code false} if not
+   */
+  public boolean connectionFailed(IOException e) {
+    // Any future attempt to connect using this strategy will be a fallback attempt.
+    isFallback = true;
+
+    if (!isFallbackPossible) {
+      return false;
+    }
+
+    // If there was a protocol problem, don't recover.
+    if (e instanceof ProtocolException) {
+      return false;
+    }
+
+    // If there was an interruption or timeout (SocketTimeoutException), don't recover.
+    // For the socket connect timeout case we do not try the same host with a different
+    // ConnectionSpec: we assume it is unreachable.
+    if (e instanceof InterruptedIOException) {
+      return false;
+    }
+
+    // Look for known client-side or negotiation errors that are unlikely to be fixed by trying
+    // again with a different connection spec.
+    if (e instanceof SSLHandshakeException) {
+      // If the problem was a CertificateException from the X509TrustManager,
+      // do not retry.
+      if (e.getCause() instanceof CertificateException) {
+        return false;
+      }
+    }
+    if (e instanceof SSLPeerUnverifiedException) {
+      // e.g. a certificate pinning error.
+      return false;
+    }
+
+
+    // On Android, SSLProtocolExceptions can be caused by TLS_FALLBACK_SCSV failures, which means we
+    // retry those when we probably should not.
+    return (e instanceof SSLHandshakeException || e instanceof SSLProtocolException);
+  }
+
+  /**
+   * Returns {@code true} if any later {@link ConnectionSpec} in the fallback strategy looks
+   * possible based on the supplied {@link SSLSocket}. It assumes that a future socket will have the
+   * same capabilities as the supplied socket.
+   */
+  private boolean isFallbackPossible(SSLSocket socket) {
+    for (int i = nextModeIndex; i < connectionSpecs.size(); i++) {
+      if (connectionSpecs.get(i).isCompatible(socket)) {
+        return true;
+      }
+    }
+    return false;
+  }
+}
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/DiskLruCache.java b/okhttp/src/main/java/com/squareup/okhttp/internal/DiskLruCache.java
index 8bddc3dac2..b940168957 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/DiskLruCache.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/DiskLruCache.java
@@ -16,6 +16,7 @@
 
 package com.squareup.okhttp.internal;
 
+import com.squareup.okhttp.internal.io.FileSystem;
 import java.io.Closeable;
 import java.io.EOFException;
 import java.io.File;
@@ -35,7 +36,6 @@
 import okio.Buffer;
 import okio.BufferedSink;
 import okio.BufferedSource;
-import okio.ForwardingSink;
 import okio.Okio;
 import okio.Sink;
 import okio.Source;
@@ -138,6 +138,7 @@
      * it exists when the cache is opened.
      */
 
+  private final FileSystem fileSystem;
   private final File directory;
   private final File journalFile;
   private final File journalFileTmp;
@@ -149,6 +150,7 @@
   private BufferedSink journalWriter;
   private final LinkedHashMap<String, Entry> lruEntries = new LinkedHashMap<>(0, 0.75f, true);
   private int redundantOpCount;
+  private boolean hasJournalErrors;
 
   // Must be read and written when synchronized on 'this'.
   private boolean initialized;
@@ -182,7 +184,9 @@ public void run() {
     }
   };
 
-  DiskLruCache(File directory, int appVersion, int valueCount, long maxSize, Executor executor) {
+  DiskLruCache(FileSystem fileSystem, File directory, int appVersion, int valueCount, long maxSize,
+      Executor executor) {
+    this.fileSystem = fileSystem;
     this.directory = directory;
     this.appVersion = appVersion;
     this.journalFile = new File(directory, JOURNAL_FILE);
@@ -193,8 +197,7 @@ public void run() {
     this.executor = executor;
   }
 
-  // Visible for testing.
-  void initialize() throws IOException {
+  public synchronized void initialize() throws IOException {
     assert Thread.holdsLock(this);
 
     if (initialized) {
@@ -202,17 +205,17 @@ void initialize() throws IOException {
     }
 
     // If a bkp file exists, use it instead.
-    if (journalFileBackup.exists()) {
+    if (fileSystem.exists(journalFileBackup)) {
       // If journal file also exists just delete backup file.
-      if (journalFile.exists()) {
-        journalFileBackup.delete();
+      if (fileSystem.exists(journalFile)) {
+        fileSystem.delete(journalFileBackup);
       } else {
-        renameTo(journalFileBackup, journalFile, false);
+        fileSystem.rename(journalFileBackup, journalFile);
       }
     }
 
     // Prefer to pick up where we left off.
-    if (journalFile.exists()) {
+    if (fileSystem.exists(journalFile)) {
       try {
         readJournal();
         processJournal();
@@ -226,7 +229,6 @@ void initialize() throws IOException {
       }
     }
 
-    directory.mkdirs();
     rebuildJournal();
 
     initialized = true;
@@ -240,7 +242,8 @@ void initialize() throws IOException {
    * @param valueCount the number of values per cache entry. Must be positive.
    * @param maxSize the maximum number of bytes this cache should use to store
    */
-  public static DiskLruCache create(File directory, int appVersion, int valueCount, long maxSize) {
+  public static DiskLruCache create(FileSystem fileSystem, File directory, int appVersion,
+      int valueCount, long maxSize) {
     if (maxSize <= 0) {
       throw new IllegalArgumentException("maxSize <= 0");
     }
@@ -252,11 +255,11 @@ public static DiskLruCache create(File directory, int appVersion, int valueCount
     Executor executor = new ThreadPoolExecutor(0, 1, 60L, TimeUnit.SECONDS,
         new LinkedBlockingQueue<Runnable>(), Util.threadFactory("OkHttp DiskLruCache", true));
 
-    return new DiskLruCache(directory, appVersion, valueCount, maxSize, executor);
+    return new DiskLruCache(fileSystem, directory, appVersion, valueCount, maxSize, executor);
   }
 
   private void readJournal() throws IOException {
-    BufferedSource source = Okio.buffer(Okio.source(journalFile));
+    BufferedSource source = Okio.buffer(fileSystem.source(journalFile));
     try {
       String magic = source.readUtf8LineStrict();
       String version = source.readUtf8LineStrict();
@@ -287,13 +290,24 @@ private void readJournal() throws IOException {
       if (!source.exhausted()) {
         rebuildJournal();
       } else {
-        journalWriter = Okio.buffer(Okio.appendingSink(journalFile));
+        journalWriter = newJournalWriter();
       }
     } finally {
       Util.closeQuietly(source);
     }
   }
 
+  private BufferedSink newJournalWriter() throws FileNotFoundException {
+    Sink fileSink = fileSystem.appendingSink(journalFile);
+    Sink faultHidingSink = new FaultHidingSink(fileSink) {
+      @Override protected void onException(IOException e) {
+        assert (Thread.holdsLock(DiskLruCache.this));
+        hasJournalErrors = true;
+      }
+    };
+    return Okio.buffer(faultHidingSink);
+  }
+
   private void readJournalLine(String line) throws IOException {
     int firstSpace = line.indexOf(' ');
     if (firstSpace == -1) {
@@ -338,7 +352,7 @@ private void readJournalLine(String line) throws IOException {
    * cache. Dirty entries are assumed to be inconsistent and will be deleted.
    */
   private void processJournal() throws IOException {
-    deleteIfExists(journalFileTmp);
+    fileSystem.delete(journalFileTmp);
     for (Iterator<Entry> i = lruEntries.values().iterator(); i.hasNext(); ) {
       Entry entry = i.next();
       if (entry.currentEditor == null) {
@@ -348,8 +362,8 @@ private void processJournal() throws IOException {
       } else {
         entry.currentEditor = null;
         for (int t = 0; t < valueCount; t++) {
-          deleteIfExists(entry.cleanFiles[t]);
-          deleteIfExists(entry.dirtyFiles[t]);
+          fileSystem.delete(entry.cleanFiles[t]);
+          fileSystem.delete(entry.dirtyFiles[t]);
         }
         i.remove();
       }
@@ -365,12 +379,12 @@ private synchronized void rebuildJournal() throws IOException {
       journalWriter.close();
     }
 
-    BufferedSink writer = Okio.buffer(Okio.sink(journalFileTmp));
+    BufferedSink writer = Okio.buffer(fileSystem.sink(journalFileTmp));
     try {
       writer.writeUtf8(MAGIC).writeByte('\n');
       writer.writeUtf8(VERSION_1).writeByte('\n');
-      writer.writeUtf8(Integer.toString(appVersion)).writeByte('\n');
-      writer.writeUtf8(Integer.toString(valueCount)).writeByte('\n');
+      writer.writeDecimalLong(appVersion).writeByte('\n');
+      writer.writeDecimalLong(valueCount).writeByte('\n');
       writer.writeByte('\n');
 
       for (Entry entry : lruEntries.values()) {
@@ -389,29 +403,14 @@ private synchronized void rebuildJournal() throws IOException {
       writer.close();
     }
 
-    if (journalFile.exists()) {
-      renameTo(journalFile, journalFileBackup, true);
+    if (fileSystem.exists(journalFile)) {
+      fileSystem.rename(journalFile, journalFileBackup);
     }
-    renameTo(journalFileTmp, journalFile, false);
-    journalFileBackup.delete();
+    fileSystem.rename(journalFileTmp, journalFile);
+    fileSystem.delete(journalFileBackup);
 
-    journalWriter = Okio.buffer(Okio.appendingSink(journalFile));
-  }
-
-  private static void deleteIfExists(File file) throws IOException {
-    // If delete() fails, make sure it's because the file didn't exist!
-    if (!file.delete() && file.exists()) {
-      throw new IOException("failed to delete " + file);
-    }
-  }
-
-  private static void renameTo(File from, File to, boolean deleteDestination) throws IOException {
-    if (deleteDestination) {
-      deleteIfExists(to);
-    }
-    if (!from.renameTo(to)) {
-      throw new IOException();
-    }
+    journalWriter = newJournalWriter();
+    hasJournalErrors = false;
   }
 
   /**
@@ -457,19 +456,24 @@ private synchronized Editor edit(String key, long expectedSequenceNumber) throws
         || entry.sequenceNumber != expectedSequenceNumber)) {
       return null; // Snapshot is stale.
     }
-    if (entry == null) {
-      entry = new Entry(key);
-      lruEntries.put(key, entry);
-    } else if (entry.currentEditor != null) {
+    if (entry != null && entry.currentEditor != null) {
       return null; // Another edit is in progress.
     }
 
-    Editor editor = new Editor(entry);
-    entry.currentEditor = editor;
-
     // Flush the journal before creating files to prevent file leaks.
     journalWriter.writeUtf8(DIRTY).writeByte(' ').writeUtf8(key).writeByte('\n');
     journalWriter.flush();
+
+    if (hasJournalErrors) {
+      return null; // Don't edit; the journal can't be written.
+    }
+
+    if (entry == null) {
+      entry = new Entry(key);
+      lruEntries.put(key, entry);
+    }
+    Editor editor = new Editor(entry);
+    entry.currentEditor = editor;
     return editor;
   }
 
@@ -520,7 +524,7 @@ private synchronized void completeEdit(Editor editor, boolean success) throws IO
           editor.abort();
           throw new IllegalStateException("Newly created entry didn't create value for index " + i);
         }
-        if (!entry.dirtyFiles[i].exists()) {
+        if (!fileSystem.exists(entry.dirtyFiles[i])) {
           editor.abort();
           return;
         }
@@ -530,16 +534,16 @@ private synchronized void completeEdit(Editor editor, boolean success) throws IO
     for (int i = 0; i < valueCount; i++) {
       File dirty = entry.dirtyFiles[i];
       if (success) {
-        if (dirty.exists()) {
+        if (fileSystem.exists(dirty)) {
           File clean = entry.cleanFiles[i];
-          dirty.renameTo(clean);
+          fileSystem.rename(dirty, clean);
           long oldLength = entry.lengths[i];
-          long newLength = clean.length();
+          long newLength = fileSystem.size(clean);
           entry.lengths[i] = newLength;
           size = size - oldLength + newLength;
         }
       } else {
-        deleteIfExists(dirty);
+        fileSystem.delete(dirty);
       }
     }
 
@@ -600,8 +604,7 @@ private boolean removeEntry(Entry entry) throws IOException {
     }
 
     for (int i = 0; i < valueCount; i++) {
-      File file = entry.cleanFiles[i];
-      deleteIfExists(file);
+      fileSystem.delete(entry.cleanFiles[i]);
       size -= entry.lengths[i];
       entry.lengths[i] = 0;
     }
@@ -669,7 +672,7 @@ private void trimToSize() throws IOException {
    */
   public void delete() throws IOException {
     close();
-    Util.deleteContents(directory);
+    fileSystem.deleteContents(directory);
   }
 
   /**
@@ -844,7 +847,7 @@ public Source newSource(int index) throws IOException {
           return null;
         }
         try {
-          return Okio.source(entry.cleanFiles[index]);
+          return fileSystem.source(entry.cleanFiles[index]);
         } catch (FileNotFoundException e) {
           return null;
         }
@@ -869,18 +872,17 @@ public Sink newSink(int index) throws IOException {
         File dirtyFile = entry.dirtyFiles[index];
         Sink sink;
         try {
-          sink = Okio.sink(dirtyFile);
+          sink = fileSystem.sink(dirtyFile);
         } catch (FileNotFoundException e) {
-          // Attempt to recreate the cache directory.
-          directory.mkdirs();
-          try {
-            sink = Okio.sink(dirtyFile);
-          } catch (FileNotFoundException e2) {
-            // We are unable to recover. Silently eat the writes.
-            return NULL_SINK;
-          }
+          return NULL_SINK;
         }
-        return new FaultHidingSink(sink);
+        return new FaultHidingSink(sink) {
+          @Override protected void onException(IOException e) {
+            synchronized (DiskLruCache.this) {
+              hasErrors = true;
+            }
+          }
+        };
       }
     }
 
@@ -920,42 +922,6 @@ public void abortUnlessCommitted() {
         }
       }
     }
-
-    private class FaultHidingSink extends ForwardingSink {
-      public FaultHidingSink(Sink delegate) {
-        super(delegate);
-      }
-
-      @Override public void write(Buffer source, long byteCount) throws IOException {
-        try {
-          super.write(source, byteCount);
-        } catch (IOException e) {
-          synchronized (DiskLruCache.this) {
-            hasErrors = true;
-          }
-        }
-      }
-
-      @Override public void flush() throws IOException {
-        try {
-          super.flush();
-        } catch (IOException e) {
-          synchronized (DiskLruCache.this) {
-            hasErrors = true;
-          }
-        }
-      }
-
-      @Override public void close() throws IOException {
-        try {
-          super.close();
-        } catch (IOException e) {
-          synchronized (DiskLruCache.this) {
-            hasErrors = true;
-          }
-        }
-      }
-    }
   }
 
   private final class Entry {
@@ -1012,7 +978,7 @@ private void setLengths(String[] strings) throws IOException {
     /** Append space-prefixed lengths to {@code writer}. */
     void writeLengths(BufferedSink writer) throws IOException {
       for (long length : lengths) {
-        writer.writeByte(' ').writeUtf8(Long.toString(length));
+        writer.writeByte(' ').writeDecimalLong(length);
       }
     }
 
@@ -1032,7 +998,7 @@ Snapshot snapshot() {
       long[] lengths = this.lengths.clone(); // Defensive copy since these can be zeroed out.
       try {
         for (int i = 0; i < valueCount; i++) {
-          sources[i] = Okio.source(cleanFiles[i]);
+          sources[i] = fileSystem.source(cleanFiles[i]);
         }
         return new Snapshot(key, sequenceNumber, sources, lengths);
       } catch (FileNotFoundException e) {
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/FaultHidingSink.java b/okhttp/src/main/java/com/squareup/okhttp/internal/FaultHidingSink.java
new file mode 100644
index 0000000000..91e990db8d
--- /dev/null
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/FaultHidingSink.java
@@ -0,0 +1,51 @@
+package com.squareup.okhttp.internal;
+
+import java.io.IOException;
+import okio.Buffer;
+import okio.ForwardingSink;
+import okio.Sink;
+
+/** A sink that never throws IOExceptions, even if the underlying sink does. */
+class FaultHidingSink extends ForwardingSink {
+  private boolean hasErrors;
+
+  public FaultHidingSink(Sink delegate) {
+    super(delegate);
+  }
+
+  @Override public void write(Buffer source, long byteCount) throws IOException {
+    if (hasErrors) {
+      source.skip(byteCount);
+      return;
+    }
+    try {
+      super.write(source, byteCount);
+    } catch (IOException e) {
+      hasErrors = true;
+      onException(e);
+    }
+  }
+
+  @Override public void flush() throws IOException {
+    if (hasErrors) return;
+    try {
+      super.flush();
+    } catch (IOException e) {
+      hasErrors = true;
+      onException(e);
+    }
+  }
+
+  @Override public void close() throws IOException {
+    if (hasErrors) return;
+    try {
+      super.close();
+    } catch (IOException e) {
+      hasErrors = true;
+      onException(e);
+    }
+  }
+
+  protected void onException(IOException e) {
+  }
+}
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/Internal.java b/okhttp/src/main/java/com/squareup/okhttp/internal/Internal.java
index d806b483c2..21bcbf5c30 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/Internal.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/Internal.java
@@ -19,14 +19,22 @@
 import com.squareup.okhttp.Callback;
 import com.squareup.okhttp.Connection;
 import com.squareup.okhttp.ConnectionPool;
+import com.squareup.okhttp.ConnectionSpec;
 import com.squareup.okhttp.Headers;
+import com.squareup.okhttp.HttpUrl;
 import com.squareup.okhttp.OkHttpClient;
 import com.squareup.okhttp.Protocol;
 import com.squareup.okhttp.Request;
 import com.squareup.okhttp.internal.http.HttpEngine;
+import com.squareup.okhttp.internal.http.RouteException;
 import com.squareup.okhttp.internal.http.Transport;
 import java.io.IOException;
+import java.net.MalformedURLException;
+import java.net.UnknownHostException;
 import java.util.logging.Logger;
+import javax.net.ssl.SSLSocket;
+import okio.BufferedSink;
+import okio.BufferedSource;
 
 /**
  * Escalate internal APIs in {@code com.squareup.okhttp} so they can be used
@@ -35,6 +43,12 @@
  */
 public abstract class Internal {
   public static final Logger logger = Logger.getLogger(OkHttpClient.class.getName());
+
+  public static void initializeInstanceForTests() {
+    // Needed in tests to ensure that the instance is actually pointing to something.
+    new OkHttpClient();
+  }
+
   public static Internal instance;
 
   public abstract Transport newTransport(Connection connection, HttpEngine httpEngine)
@@ -54,6 +68,8 @@ public abstract Transport newTransport(Connection connection, HttpEngine httpEng
 
   public abstract void addLenient(Headers.Builder builder, String line);
 
+  public abstract void addLenient(Headers.Builder builder, String name, String value);
+
   public abstract void setCache(OkHttpClient client, InternalCache internalCache);
 
   public abstract InternalCache internalCache(OkHttpClient client);
@@ -67,11 +83,19 @@ public abstract Transport newTransport(Connection connection, HttpEngine httpEng
   public abstract void setNetwork(OkHttpClient client, Network network);
 
   public abstract void connectAndSetOwner(OkHttpClient client, Connection connection,
-      HttpEngine owner, Request request) throws IOException;
+      HttpEngine owner, Request request) throws RouteException;
+
+  public abstract void apply(ConnectionSpec tlsConfiguration, SSLSocket sslSocket,
+      boolean isFallback);
+
+  public abstract HttpUrl getHttpUrlChecked(String url)
+      throws MalformedURLException, UnknownHostException;
 
   // TODO delete the following when web sockets move into the main package.
   public abstract void callEnqueue(Call call, Callback responseCallback, boolean forWebSocket);
   public abstract void callEngineReleaseConnection(Call call) throws IOException;
   public abstract Connection callEngineGetConnection(Call call);
+  public abstract BufferedSource connectionRawSource(Connection connection);
+  public abstract BufferedSink connectionRawSink(Connection connection);
   public abstract void connectionSetOwner(Connection connection, Object owner);
 }
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/Platform.java b/okhttp/src/main/java/com/squareup/okhttp/internal/Platform.java
index 14b5fb1623..b9064959e0 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/Platform.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/Platform.java
@@ -25,9 +25,6 @@
 import java.net.InetSocketAddress;
 import java.net.Socket;
 import java.net.SocketException;
-import java.net.URI;
-import java.net.URISyntaxException;
-import java.net.URL;
 import java.util.ArrayList;
 import java.util.List;
 import java.util.logging.Level;
@@ -37,15 +34,22 @@
 import static com.squareup.okhttp.internal.Internal.logger;
 
 /**
- * Access to Platform-specific features necessary for SPDY and advanced TLS.
- * This includes Server Name Indication (SNI) and session tickets.
+ * Access to platform-specific features.
  *
- * <h3>ALPN</h3>
- * This class uses TLS extension ALPN to negotiate the upgrade from HTTP/1.1
- * (the default protocol to use with TLS on port 443) to either SPDY or HTTP/2.
+ * <h3>Server name indication (SNI)</h3>
+ * Supported on Android 2.3+.
  *
- * <p>ALPN (Application Layer Protocol Negotiation) first arrived in Android 4.4,
- * ALPN is supported on OpenJDK 7 and 8 (via the Jetty ALPN-boot library).
+ * <h3>Session Tickets</h3>
+ * Supported on Android 2.3+.
+ *
+ * <h3>Android Traffic Stats (Socket Tagging)</h3>
+ * Supported on Android 4.0+.
+ *
+ * <h3>ALPN (Application Layer Protocol Negotiation)</h3>
+ * Supported on Android 5.0+. The APIs were present in Android 4.4, but that implementation was
+ * unstable.
+ *
+ * Supported on OpenJDK 7 and 8 (via the JettyALPN-boot library).
  */
 public class Platform {
   private static final Platform PLATFORM = findPlatform();
@@ -69,10 +73,6 @@ public void tagSocket(Socket socket) throws SocketException {
   public void untagSocket(Socket socket) throws SocketException {
   }
 
-  public URI toUriLenient(URL url) throws URISyntaxException {
-    return url.toURI(); // this isn't as good as the built-in toUriLenient
-  }
-
   /**
    * Configure TLS extensions on {@code sslSocket} for {@code route}.
    *
@@ -106,28 +106,44 @@ private static Platform findPlatform() {
     try {
       try {
         Class.forName("com.android.org.conscrypt.OpenSSLSocketImpl");
-      } catch (ClassNotFoundException ignored) {
+      } catch (ClassNotFoundException e) {
         // Older platform before being unbundled.
         Class.forName("org.apache.harmony.xnet.provider.jsse.OpenSSLSocketImpl");
       }
 
-      // Attempt to find Android 4.0+ APIs.
+      OptionalMethod<Socket> setUseSessionTickets
+          = new OptionalMethod<>(null, "setUseSessionTickets", boolean.class);
+      OptionalMethod<Socket> setHostname
+          = new OptionalMethod<>(null, "setHostname", String.class);
       Method trafficStatsTagSocket = null;
       Method trafficStatsUntagSocket = null;
+      OptionalMethod<Socket> getAlpnSelectedProtocol = null;
+      OptionalMethod<Socket> setAlpnProtocols = null;
+
+      // Attempt to find Android 4.0+ APIs.
       try {
         Class<?> trafficStats = Class.forName("android.net.TrafficStats");
         trafficStatsTagSocket = trafficStats.getMethod("tagSocket", Socket.class);
         trafficStatsUntagSocket = trafficStats.getMethod("untagSocket", Socket.class);
-      } catch (ClassNotFoundException ignored) {
-      } catch (NoSuchMethodException ignored) {
+
+        // Attempt to find Android 5.0+ APIs.
+        try {
+          Class.forName("android.net.Network"); // Arbitrary class added in Android 5.0.
+          getAlpnSelectedProtocol = new OptionalMethod<>(byte[].class, "getAlpnSelectedProtocol");
+          setAlpnProtocols = new OptionalMethod<>(null, "setAlpnProtocols", byte[].class);
+        } catch (ClassNotFoundException ignored) {
+        }
+      } catch (ClassNotFoundException | NoSuchMethodException ignored) {
       }
 
-      return new Android(trafficStatsTagSocket, trafficStatsUntagSocket);
+      return new Android(setUseSessionTickets, setHostname, trafficStatsTagSocket,
+          trafficStatsUntagSocket, getAlpnSelectedProtocol, setAlpnProtocols);
     } catch (ClassNotFoundException ignored) {
       // This isn't an Android runtime.
     }
 
-    try { // to find the Jetty's ALPN extension for OpenJDK.
+    // Find Jetty's ALPN extension for OpenJDK.
+    try {
       String negoClassName = "org.eclipse.jetty.alpn.ALPN";
       Class<?> negoClass = Class.forName(negoClassName);
       Class<?> providerClass = Class.forName(negoClassName + "$Provider");
@@ -138,39 +154,34 @@ private static Platform findPlatform() {
       Method removeMethod = negoClass.getMethod("remove", SSLSocket.class);
       return new JdkWithJettyBootPlatform(
           putMethod, getMethod, removeMethod, clientProviderClass, serverProviderClass);
-    } catch (ClassNotFoundException ignored) {
-    } catch (NoSuchMethodException ignored) { // The ALPN version isn't what we expect.
+    } catch (ClassNotFoundException | NoSuchMethodException ignored) {
     }
 
     return new Platform();
   }
 
-  /**
-   * Android 2.3 or better. Version 2.3 supports TLS session tickets and server
-   * name indication (SNI). Versions 4.4 supports ALPN.
-   */
+  /** Android 2.3 or better. */
   private static class Android extends Platform {
-
-    // setUseSessionTickets(boolean)
-    private static final OptionalMethod<Socket> SET_USE_SESSION_TICKETS =
-        new OptionalMethod<Socket>(null, "setUseSessionTickets", Boolean.TYPE);
-    // setHostname(String)
-    private static final OptionalMethod<Socket> SET_HOSTNAME =
-        new OptionalMethod<Socket>(null, "setHostname", String.class);
-    // byte[] getAlpnSelectedProtocol()
-    private static final OptionalMethod<Socket> GET_ALPN_SELECTED_PROTOCOL =
-        new OptionalMethod<Socket>(byte[].class, "getAlpnSelectedProtocol");
-    // setAlpnSelectedProtocol(byte[])
-    private static final OptionalMethod<Socket> SET_ALPN_PROTOCOLS =
-        new OptionalMethod<Socket>(null, "setAlpnProtocols", byte[].class);
+    private final OptionalMethod<Socket> setUseSessionTickets;
+    private final OptionalMethod<Socket> setHostname;
 
     // Non-null on Android 4.0+.
     private final Method trafficStatsTagSocket;
     private final Method trafficStatsUntagSocket;
 
-    private Android(Method trafficStatsTagSocket, Method trafficStatsUntagSocket) {
+    // Non-null on Android 5.0+.
+    private final OptionalMethod<Socket> getAlpnSelectedProtocol;
+    private final OptionalMethod<Socket> setAlpnProtocols;
+
+    public Android(OptionalMethod<Socket> setUseSessionTickets, OptionalMethod<Socket> setHostname,
+        Method trafficStatsTagSocket, Method trafficStatsUntagSocket,
+        OptionalMethod<Socket> getAlpnSelectedProtocol, OptionalMethod<Socket> setAlpnProtocols) {
+      this.setUseSessionTickets = setUseSessionTickets;
+      this.setHostname = setHostname;
       this.trafficStatsTagSocket = trafficStatsTagSocket;
       this.trafficStatsUntagSocket = trafficStatsUntagSocket;
+      this.getAlpnSelectedProtocol = getAlpnSelectedProtocol;
+      this.setAlpnProtocols = setAlpnProtocols;
     }
 
     @Override public void connectSocket(Socket socket, InetSocketAddress address,
@@ -190,32 +201,23 @@ private Android(Method trafficStatsTagSocket, Method trafficStatsUntagSocket) {
         SSLSocket sslSocket, String hostname, List<Protocol> protocols) {
       // Enable SNI and session tickets.
       if (hostname != null) {
-        SET_USE_SESSION_TICKETS.invokeOptionalWithoutCheckedException(sslSocket, true);
-        SET_HOSTNAME.invokeOptionalWithoutCheckedException(sslSocket, hostname);
+        setUseSessionTickets.invokeOptionalWithoutCheckedException(sslSocket, true);
+        setHostname.invokeOptionalWithoutCheckedException(sslSocket, hostname);
       }
 
       // Enable ALPN.
-      boolean alpnSupported = SET_ALPN_PROTOCOLS.isSupported(sslSocket);
-      if (!alpnSupported) {
-        return;
+      if (setAlpnProtocols != null && setAlpnProtocols.isSupported(sslSocket)) {
+        Object[] parameters = { concatLengthPrefixed(protocols) };
+        setAlpnProtocols.invokeWithoutCheckedException(sslSocket, parameters);
       }
-
-      Object[] parameters = { concatLengthPrefixed(protocols) };
-      SET_ALPN_PROTOCOLS.invokeWithoutCheckedException(sslSocket, parameters);
     }
 
     @Override public String getSelectedProtocol(SSLSocket socket) {
-      boolean alpnSupported = GET_ALPN_SELECTED_PROTOCOL.isSupported(socket);
-      if (!alpnSupported) {
-        return null;
-      }
+      if (getAlpnSelectedProtocol == null) return null;
+      if (!getAlpnSelectedProtocol.isSupported(socket)) return null;
 
-      byte[] alpnResult =
-          (byte[]) GET_ALPN_SELECTED_PROTOCOL.invokeWithoutCheckedException(socket);
-      if (alpnResult != null) {
-        return new String(alpnResult, Util.UTF_8);
-      }
-      return null;
+      byte[] alpnResult = (byte[]) getAlpnSelectedProtocol.invokeWithoutCheckedException(socket);
+      return alpnResult != null ? new String(alpnResult, Util.UTF_8) : null;
     }
 
     @Override public void tagSocket(Socket socket) throws SocketException {
@@ -274,9 +276,7 @@ public JdkWithJettyBootPlatform(Method putMethod, Method getMethod, Method remov
         Object provider = Proxy.newProxyInstance(Platform.class.getClassLoader(),
             new Class[] { clientProviderClass, serverProviderClass }, new JettyNegoProvider(names));
         putMethod.invoke(null, sslSocket, provider);
-      } catch (InvocationTargetException e) {
-        throw new AssertionError(e);
-      } catch (IllegalAccessException e) {
+      } catch (InvocationTargetException | IllegalAccessException e) {
         throw new AssertionError(e);
       }
     }
@@ -284,9 +284,7 @@ public JdkWithJettyBootPlatform(Method putMethod, Method getMethod, Method remov
     @Override public void afterHandshake(SSLSocket sslSocket) {
       try {
         removeMethod.invoke(null, sslSocket);
-      } catch (IllegalAccessException ignored) {
-        throw new AssertionError();
-      } catch (InvocationTargetException ignored) {
+      } catch (IllegalAccessException | InvocationTargetException ignored) {
         throw new AssertionError();
       }
     }
@@ -301,9 +299,7 @@ public JdkWithJettyBootPlatform(Method putMethod, Method getMethod, Method remov
           return null;
         }
         return provider.unsupported ? null : provider.selected;
-      } catch (InvocationTargetException e) {
-        throw new AssertionError();
-      } catch (IllegalAccessException e) {
+      } catch (InvocationTargetException | IllegalAccessException e) {
         throw new AssertionError();
       }
     }
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/RouteDatabase.java b/okhttp/src/main/java/com/squareup/okhttp/internal/RouteDatabase.java
index 52c211eb54..1c96c7f6b2 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/RouteDatabase.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/RouteDatabase.java
@@ -22,9 +22,8 @@
 /**
  * A blacklist of failed routes to avoid when creating a new connection to a
  * target address. This is used so that OkHttp can learn from its mistakes: if
- * there was a failure attempting to connect to a specific IP address, proxy
- * server or TLS mode, that failure is remembered and alternate routes are
- * preferred.
+ * there was a failure attempting to connect to a specific IP address or proxy
+ * server, that failure is remembered and alternate routes are preferred.
  */
 public final class RouteDatabase {
   private final Set<Route> failedRoutes = new LinkedHashSet<>();
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/Util.java b/okhttp/src/main/java/com/squareup/okhttp/internal/Util.java
index 5f8e8cb281..efc26ec811 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/Util.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/Util.java
@@ -16,16 +16,14 @@
 
 package com.squareup.okhttp.internal;
 
+import com.squareup.okhttp.HttpUrl;
 import java.io.Closeable;
-import java.io.File;
 import java.io.IOException;
 import java.io.InterruptedIOException;
 import java.io.UnsupportedEncodingException;
 import java.lang.reflect.Array;
 import java.net.ServerSocket;
 import java.net.Socket;
-import java.net.URI;
-import java.net.URL;
 import java.nio.charset.Charset;
 import java.security.MessageDigest;
 import java.security.NoSuchAlgorithmException;
@@ -52,24 +50,6 @@
   private Util() {
   }
 
-  public static int getEffectivePort(URI uri) {
-    return getEffectivePort(uri.getScheme(), uri.getPort());
-  }
-
-  public static int getEffectivePort(URL url) {
-    return getEffectivePort(url.getProtocol(), url.getPort());
-  }
-
-  private static int getEffectivePort(String scheme, int specifiedPort) {
-    return specifiedPort != -1 ? specifiedPort : getDefaultPort(scheme);
-  }
-
-  public static int getDefaultPort(String protocol) {
-    if ("http".equals(protocol)) return 80;
-    if ("https".equals(protocol)) return 443;
-    return -1;
-  }
-
   public static void checkOffsetAndCount(long arrayLength, long offset, long count) {
     if ((offset | count) < 0 || offset > arrayLength || arrayLength - offset < count) {
       throw new ArrayIndexOutOfBoundsException();
@@ -104,6 +84,8 @@ public static void closeQuietly(Socket socket) {
     if (socket != null) {
       try {
         socket.close();
+      } catch (AssertionError e) {
+        if (!isAndroidGetsocknameError(e)) throw e;
       } catch (RuntimeException rethrown) {
         throw rethrown;
       } catch (Exception ignored) {
@@ -149,25 +131,6 @@ public static void closeAll(Closeable a, Closeable b) throws IOException {
     throw new AssertionError(thrown);
   }
 
-  /**
-   * Deletes the contents of {@code dir}. Throws an IOException if any file
-   * could not be deleted, or if {@code dir} is not a readable directory.
-   */
-  public static void deleteContents(File dir) throws IOException {
-    File[] files = dir.listFiles();
-    if (files == null) {
-      throw new IOException("not a readable directory: " + dir);
-    }
-    for (File file : files) {
-      if (file.isDirectory()) {
-        deleteContents(file);
-      }
-      if (!file.delete()) {
-        throw new IOException("failed to delete file: " + file);
-      }
-    }
-  }
-
   /**
    * Attempts to exhaust {@code source}, returning true if successful. This is useful when reading
    * a complete source is helpful, such as when doing so completes a cache body or frees a socket
@@ -292,4 +255,37 @@ public static ThreadFactory threadFactory(final String name, final boolean daemo
     }
     return result;
   }
+
+  public static String hostHeader(HttpUrl url) {
+    // TODO: square braces for IPv6 ?
+    return url.port() != HttpUrl.defaultPort(url.scheme())
+        ? url.host() + ":" + url.port()
+        : url.host();
+  }
+
+  /** Returns {@code s} with control characters and non-ASCII characters replaced with '?'. */
+  public static String toHumanReadableAscii(String s) {
+    for (int i = 0, length = s.length(), c; i < length; i += Character.charCount(c)) {
+      c = s.codePointAt(i);
+      if (c > '\u001f' && c < '\u007f') continue;
+
+      Buffer buffer = new Buffer();
+      buffer.writeUtf8(s, 0, i);
+      for (int j = i; j < length; j += Character.charCount(c)) {
+        c = s.codePointAt(j);
+        buffer.writeUtf8CodePoint(c > '\u001f' && c < '\u007f' ? c : '?');
+      }
+      return buffer.readUtf8();
+    }
+    return s;
+  }
+
+  /**
+   * Returns true if {@code e} is due to a firmware bug fixed after Android 4.2.2.
+   * https://code.google.com/p/android/issues/detail?id=54072
+   */
+  public static boolean isAndroidGetsocknameError(AssertionError e) {
+    return e.getCause() != null && e.getMessage() != null
+        && e.getMessage().contains("getsockname failed");
+  }
 }
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/ErrorCode.java b/okhttp/src/main/java/com/squareup/okhttp/internal/framed/ErrorCode.java
similarity index 95%
rename from okhttp/src/main/java/com/squareup/okhttp/internal/spdy/ErrorCode.java
rename to okhttp/src/main/java/com/squareup/okhttp/internal/framed/ErrorCode.java
index b5f46b8bee..0edd5ef74f 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/ErrorCode.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/framed/ErrorCode.java
@@ -13,9 +13,9 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.squareup.okhttp.internal.spdy;
+package com.squareup.okhttp.internal.framed;
 
-// http://tools.ietf.org/html/draft-ietf-httpbis-http2-16#section-7
+// http://tools.ietf.org/html/draft-ietf-httpbis-http2-17#section-7
 public enum ErrorCode {
   /** Not an error! For SPDY stream resets, prefer null over NO_ERROR. */
   NO_ERROR(0, -1, 0),
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/FrameReader.java b/okhttp/src/main/java/com/squareup/okhttp/internal/framed/FrameReader.java
similarity index 98%
rename from okhttp/src/main/java/com/squareup/okhttp/internal/spdy/FrameReader.java
rename to okhttp/src/main/java/com/squareup/okhttp/internal/framed/FrameReader.java
index e3736c5fe4..9f7f0868b2 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/FrameReader.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/framed/FrameReader.java
@@ -14,7 +14,7 @@
  * limitations under the License.
  */
 
-package com.squareup.okhttp.internal.spdy;
+package com.squareup.okhttp.internal.framed;
 
 import java.io.Closeable;
 import java.io.IOException;
@@ -27,7 +27,7 @@
   void readConnectionPreface() throws IOException;
   boolean nextFrame(Handler handler) throws IOException;
 
-  public interface Handler {
+  interface Handler {
     void data(boolean inFinished, int streamId, BufferedSource source, int length)
         throws IOException;
 
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/FrameWriter.java b/okhttp/src/main/java/com/squareup/okhttp/internal/framed/FrameWriter.java
similarity index 98%
rename from okhttp/src/main/java/com/squareup/okhttp/internal/spdy/FrameWriter.java
rename to okhttp/src/main/java/com/squareup/okhttp/internal/framed/FrameWriter.java
index 0f4b799366..dcaaf3ac90 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/FrameWriter.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/framed/FrameWriter.java
@@ -14,7 +14,7 @@
  * limitations under the License.
  */
 
-package com.squareup.okhttp.internal.spdy;
+package com.squareup.okhttp.internal.framed;
 
 import java.io.Closeable;
 import java.io.IOException;
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/SpdyConnection.java b/okhttp/src/main/java/com/squareup/okhttp/internal/framed/FramedConnection.java
similarity index 83%
rename from okhttp/src/main/java/com/squareup/okhttp/internal/spdy/SpdyConnection.java
rename to okhttp/src/main/java/com/squareup/okhttp/internal/framed/FramedConnection.java
index e7ab87348a..a86924b897 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/SpdyConnection.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/framed/FramedConnection.java
@@ -13,7 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.squareup.okhttp.internal.spdy;
+package com.squareup.okhttp.internal.framed;
 
 import com.squareup.okhttp.Protocol;
 import com.squareup.okhttp.internal.NamedRunnable;
@@ -33,12 +33,14 @@
 import java.util.concurrent.SynchronousQueue;
 import java.util.concurrent.ThreadPoolExecutor;
 import java.util.concurrent.TimeUnit;
+import java.util.logging.Level;
 import okio.Buffer;
 import okio.BufferedSource;
 import okio.ByteString;
 import okio.Okio;
 
-import static com.squareup.okhttp.internal.spdy.Settings.DEFAULT_INITIAL_WINDOW_SIZE;
+import static com.squareup.okhttp.internal.Internal.logger;
+import static com.squareup.okhttp.internal.framed.Settings.DEFAULT_INITIAL_WINDOW_SIZE;
 
 /**
  * A socket connection to a remote peer. A connection hosts streams which can
@@ -49,7 +51,7 @@
  * for SPDY. This is motivated by exception transparency: an IOException that
  * was triggered by a certain caller can be caught and handled by that caller.
  */
-public final class SpdyConnection implements Closeable {
+public final class FramedConnection implements Closeable {
 
   // Internal state of this connection is guarded by 'this'. No blocking
   // operations may be performed while holding this lock!
@@ -65,9 +67,9 @@
 
   private static final ExecutorService executor = new ThreadPoolExecutor(0,
       Integer.MAX_VALUE, 60, TimeUnit.SECONDS, new SynchronousQueue<Runnable>(),
-      Util.threadFactory("OkHttp SpdyConnection", true));
+      Util.threadFactory("OkHttp FramedConnection", true));
 
-  /** The protocol variant, like {@link com.squareup.okhttp.internal.spdy.Spdy3}. */
+  /** The protocol variant, like {@link com.squareup.okhttp.internal.framed.Spdy3}. */
   final Protocol protocol;
 
   /** True if this peer initiated the connection. */
@@ -78,7 +80,7 @@
    * run on the callback executor.
    */
   private final IncomingStreamHandler handler;
-  private final Map<Integer, SpdyStream> streams = new HashMap<>();
+  private final Map<Integer, FramedStream> streams = new HashMap<>();
   private final String hostName;
   private int lastGoodStreamId;
   private int nextStreamId;
@@ -126,12 +128,12 @@
   // Visible for testing
   final Reader readerRunnable;
 
-  private SpdyConnection(Builder builder) throws IOException {
+  private FramedConnection(Builder builder) throws IOException {
     protocol = builder.protocol;
     pushObserver = builder.pushObserver;
     client = builder.client;
     handler = builder.handler;
-    // http://tools.ietf.org/html/draft-ietf-httpbis-http2-16#section-5.1.1
+    // http://tools.ietf.org/html/draft-ietf-httpbis-http2-17#section-5.1.1
     nextStreamId = builder.client ? 1 : 2;
     if (builder.client && protocol == Protocol.HTTP_2) {
       nextStreamId += 2; // In HTTP/2, 1 on client is reserved for Upgrade.
@@ -150,14 +152,14 @@ private SpdyConnection(Builder builder) throws IOException {
     hostName = builder.hostName;
 
     if (protocol == Protocol.HTTP_2) {
-      variant = new Http20Draft16();
+      variant = new Http2();
       // Like newSingleThreadExecutor, except lazy creates the thread.
       pushExecutor = new ThreadPoolExecutor(0, 1, 60, TimeUnit.SECONDS,
           new LinkedBlockingQueue<Runnable>(),
           Util.threadFactory(String.format("OkHttp %s Push Observer", hostName), true));
-      // 1 less than SPDY http://tools.ietf.org/html/draft-ietf-httpbis-http2-16#section-6.9.2
+      // 1 less than SPDY http://tools.ietf.org/html/draft-ietf-httpbis-http2-17#section-6.9.2
       peerSettings.set(Settings.INITIAL_WINDOW_SIZE, 0, 65535);
-      peerSettings.set(Settings.MAX_FRAME_SIZE, 0, Http20Draft16.INITIAL_MAX_FRAME_SIZE);
+      peerSettings.set(Settings.MAX_FRAME_SIZE, 0, Http2.INITIAL_MAX_FRAME_SIZE);
     } else if (protocol == Protocol.SPDY_3) {
       variant = new Spdy3();
       pushExecutor = null;
@@ -178,22 +180,23 @@ public Protocol getProtocol() {
   }
 
   /**
-   * Returns the number of {@link SpdyStream#isOpen() open streams} on this
+   * Returns the number of {@link FramedStream#isOpen() open streams} on this
    * connection.
    */
   public synchronized int openStreamCount() {
     return streams.size();
   }
 
-  synchronized SpdyStream getStream(int id) {
+  synchronized FramedStream getStream(int id) {
     return streams.get(id);
   }
 
-  synchronized SpdyStream removeStream(int streamId) {
-    SpdyStream stream = streams.remove(streamId);
+  synchronized FramedStream removeStream(int streamId) {
+    FramedStream stream = streams.remove(streamId);
     if (stream != null && streams.isEmpty()) {
       setIdle(true);
     }
+    notifyAll(); // The removed stream may be blocked on a connection-wide window update.
     return stream;
   }
 
@@ -222,7 +225,7 @@ public synchronized long getIdleStartTimeNs() {
    * @param out true to create an output stream that we can use to send data
    *     to the remote peer. Corresponds to {@code FLAG_FIN}.
    */
-  public SpdyStream pushStream(int associatedStreamId, List<Header> requestHeaders, boolean out)
+  public FramedStream pushStream(int associatedStreamId, List<Header> requestHeaders, boolean out)
       throws IOException {
     if (client) throw new IllegalStateException("Client cannot push requests.");
     if (protocol != Protocol.HTTP_2) throw new IllegalStateException("protocol != HTTP_2");
@@ -237,16 +240,16 @@ public SpdyStream pushStream(int associatedStreamId, List<Header> requestHeaders
    * @param in true to create an input stream that the remote peer can use to send data to us.
    *     Corresponds to {@code FLAG_UNIDIRECTIONAL}.
    */
-  public SpdyStream newStream(List<Header> requestHeaders, boolean out, boolean in)
+  public FramedStream newStream(List<Header> requestHeaders, boolean out, boolean in)
       throws IOException {
     return newStream(0, requestHeaders, out, in);
   }
 
-  private SpdyStream newStream(int associatedStreamId, List<Header> requestHeaders, boolean out,
+  private FramedStream newStream(int associatedStreamId, List<Header> requestHeaders, boolean out,
       boolean in) throws IOException {
     boolean outFinished = !out;
     boolean inFinished = !in;
-    SpdyStream stream;
+    FramedStream stream;
     int streamId;
 
     synchronized (frameWriter) {
@@ -256,7 +259,7 @@ private SpdyStream newStream(int associatedStreamId, List<Header> requestHeaders
         }
         streamId = nextStreamId;
         nextStreamId += 2;
-        stream = new SpdyStream(streamId, this, outFinished, inFinished, requestHeaders);
+        stream = new FramedStream(streamId, this, outFinished, inFinished, requestHeaders);
         if (stream.isOpen()) {
           streams.put(streamId, stream);
           setIdle(false);
@@ -285,19 +288,16 @@ void writeSynReply(int streamId, boolean outFinished, List<Header> alternating)
   }
 
   /**
-   * Callers of this method are not thread safe, and sometimes on application
-   * threads.  Most often, this method will be called to send a buffer worth of
-   * data to the peer.
-   * <p>
-   * Writes are subject to the write window of the stream and the connection.
-   * Until there is a window sufficient to send {@code byteCount}, the caller
-   * will block.  For example, a user of {@code HttpURLConnection} who flushes
-   * more bytes to the output stream than the connection's write window will
-   * block.
-   * <p>
-   * Zero {@code byteCount} writes are not subject to flow control and
-   * will not block.  The only use case for zero {@code byteCount} is closing
-   * a flushed output stream.
+   * Callers of this method are not thread safe, and sometimes on application threads. Most often,
+   * this method will be called to send a buffer worth of data to the peer.
+   *
+   * <p>Writes are subject to the write window of the stream and the connection. Until there is a
+   * window sufficient to send {@code byteCount}, the caller will block. For example, a user of
+   * {@code HttpURLConnection} who flushes more bytes to the output stream than the connection's
+   * write window will block.
+   *
+   * <p>Zero {@code byteCount} writes are not subject to flow control and will not block. The only
+   * use case for zero {@code byteCount} is closing a flushed output stream.
    */
   public void writeData(int streamId, boolean outFinished, Buffer buffer, long byteCount)
       throws IOException {
@@ -308,10 +308,15 @@ public void writeData(int streamId, boolean outFinished, Buffer buffer, long byt
 
     while (byteCount > 0) {
       int toWrite;
-      synchronized (SpdyConnection.this) {
+      synchronized (FramedConnection.this) {
         try {
           while (bytesLeftInWriteWindow <= 0) {
-            SpdyConnection.this.wait(); // Wait until we receive a WINDOW_UPDATE.
+            // Before blocking, confirm that the stream we're writing is still open. It's possible
+            // that the stream has since been closed (such as if this write timed out.)
+            if (!streams.containsKey(streamId)) {
+              throw new IOException("stream closed");
+            }
+            FramedConnection.this.wait(); // Wait until we receive a WINDOW_UPDATE.
           }
         } catch (InterruptedException e) {
           throw new InterruptedIOException();
@@ -333,7 +338,7 @@ public void writeData(int streamId, boolean outFinished, Buffer buffer, long byt
    */
   void addBytesToWriteWindow(long delta) {
     bytesLeftInWriteWindow += delta;
-    if (delta > 0) SpdyConnection.this.notifyAll();
+    if (delta > 0) FramedConnection.this.notifyAll();
   }
 
   void writeSynResetLater(final int streamId, final ErrorCode errorCode) {
@@ -352,7 +357,7 @@ void writeSynReset(int streamId, ErrorCode statusCode) throws IOException {
   }
 
   void writeWindowUpdateLater(final int streamId, final long unacknowledgedBytesRead) {
-    executor.submit(new NamedRunnable("OkHttp Window Update %s stream %d", hostName, streamId) {
+    executor.execute(new NamedRunnable("OkHttp Window Update %s stream %d", hostName, streamId) {
       @Override public void execute() {
         try {
           frameWriter.windowUpdate(streamId, unacknowledgedBytesRead);
@@ -384,7 +389,7 @@ public Ping ping() throws IOException {
 
   private void writePingLater(
       final boolean reply, final int payload1, final int payload2, final Ping ping) {
-    executor.submit(new NamedRunnable("OkHttp %s ping %08x%08x",
+    executor.execute(new NamedRunnable("OkHttp %s ping %08x%08x",
         hostName, payload1, payload2) {
       @Override public void execute() {
         try {
@@ -450,11 +455,11 @@ private void close(ErrorCode connectionCode, ErrorCode streamCode) throws IOExce
       thrown = e;
     }
 
-    SpdyStream[] streamsToClose = null;
+    FramedStream[] streamsToClose = null;
     Ping[] pingsToCancel = null;
     synchronized (this) {
       if (!streams.isEmpty()) {
-        streamsToClose = streams.values().toArray(new SpdyStream[streams.size()]);
+        streamsToClose = streams.values().toArray(new FramedStream[streams.size()]);
         streams.clear();
         setIdle(false);
       }
@@ -465,7 +470,7 @@ private void close(ErrorCode connectionCode, ErrorCode streamCode) throws IOExce
     }
 
     if (streamsToClose != null) {
-      for (SpdyStream stream : streamsToClose) {
+      for (FramedStream stream : streamsToClose) {
         try {
           stream.close(streamCode);
         } catch (IOException e) {
@@ -547,8 +552,8 @@ public Builder pushObserver(PushObserver pushObserver) {
       return this;
     }
 
-    public SpdyConnection build() throws IOException {
-      return new SpdyConnection(this);
+    public FramedConnection build() throws IOException {
+      return new FramedConnection(this);
     }
   }
 
@@ -593,7 +598,7 @@ private Reader() {
         pushDataLater(streamId, source, length, inFinished);
         return;
       }
-      SpdyStream dataStream = getStream(streamId);
+      FramedStream dataStream = getStream(streamId);
       if (dataStream == null) {
         writeSynResetLater(streamId, ErrorCode.INVALID_STREAM);
         source.skip(length);
@@ -611,8 +616,8 @@ private Reader() {
         pushHeadersLater(streamId, headerBlock, inFinished);
         return;
       }
-      SpdyStream stream;
-      synchronized (SpdyConnection.this) {
+      FramedStream stream;
+      synchronized (FramedConnection.this) {
         // If we're shutdown, don't bother with this stream.
         if (shutdown) return;
 
@@ -632,16 +637,21 @@ private Reader() {
           if (streamId % 2 == nextStreamId % 2) return;
 
           // Create a stream.
-          final SpdyStream newStream = new SpdyStream(streamId, SpdyConnection.this, outFinished,
+          final FramedStream
+              newStream = new FramedStream(streamId, FramedConnection.this, outFinished,
               inFinished, headerBlock);
           lastGoodStreamId = streamId;
           streams.put(streamId, newStream);
-          executor.submit(new NamedRunnable("OkHttp %s stream %d", hostName, streamId) {
+          executor.execute(new NamedRunnable("OkHttp %s stream %d", hostName, streamId) {
             @Override public void execute() {
               try {
                 handler.receive(newStream);
               } catch (IOException e) {
-                throw new RuntimeException(e);
+                logger.log(Level.INFO, "StreamHandler failure for " + hostName, e);
+                try {
+                  newStream.close(ErrorCode.PROTOCOL_ERROR);
+                } catch (IOException ignored) {
+                }
               }
             }
           });
@@ -666,7 +676,7 @@ private Reader() {
         pushResetLater(streamId, errorCode);
         return;
       }
-      SpdyStream rstStream = removeStream(streamId);
+      FramedStream rstStream = removeStream(streamId);
       if (rstStream != null) {
         rstStream.receiveRstStream(errorCode);
       }
@@ -674,8 +684,8 @@ private Reader() {
 
     @Override public void settings(boolean clearPrevious, Settings newSettings) {
       long delta = 0;
-      SpdyStream[] streamsToNotify = null;
-      synchronized (SpdyConnection.this) {
+      FramedStream[] streamsToNotify = null;
+      synchronized (FramedConnection.this) {
         int priorWriteWindowSize = peerSettings.getInitialWindowSize(DEFAULT_INITIAL_WINDOW_SIZE);
         if (clearPrevious) peerSettings.clear();
         peerSettings.merge(newSettings);
@@ -690,12 +700,12 @@ private Reader() {
             receivedInitialPeerSettings = true;
           }
           if (!streams.isEmpty()) {
-            streamsToNotify = streams.values().toArray(new SpdyStream[streams.size()]);
+            streamsToNotify = streams.values().toArray(new FramedStream[streams.size()]);
           }
         }
       }
       if (streamsToNotify != null && delta != 0) {
-        for (SpdyStream stream : streamsToNotify) {
+        for (FramedStream stream : streamsToNotify) {
           synchronized (stream) {
             stream.addBytesToWriteWindow(delta);
           }
@@ -704,7 +714,7 @@ private Reader() {
     }
 
     private void ackSettingsLater(final Settings peerSettings) {
-      executor.submit(new NamedRunnable("OkHttp %s ACK Settings", hostName) {
+      executor.execute(new NamedRunnable("OkHttp %s ACK Settings", hostName) {
         @Override public void execute() {
           try {
             frameWriter.ackSettings(peerSettings);
@@ -735,29 +745,29 @@ private void ackSettingsLater(final Settings peerSettings) {
       }
 
       // Copy the streams first. We don't want to hold a lock when we call receiveRstStream().
-      SpdyStream[] streamsCopy;
-      synchronized (SpdyConnection.this) {
-        streamsCopy = streams.values().toArray(new SpdyStream[streams.size()]);
+      FramedStream[] streamsCopy;
+      synchronized (FramedConnection.this) {
+        streamsCopy = streams.values().toArray(new FramedStream[streams.size()]);
         shutdown = true;
       }
 
       // Fail all streams created after the last good stream ID.
-      for (SpdyStream spdyStream : streamsCopy) {
-        if (spdyStream.getId() > lastGoodStreamId && spdyStream.isLocallyInitiated()) {
-          spdyStream.receiveRstStream(ErrorCode.REFUSED_STREAM);
-          removeStream(spdyStream.getId());
+      for (FramedStream framedStream : streamsCopy) {
+        if (framedStream.getId() > lastGoodStreamId && framedStream.isLocallyInitiated()) {
+          framedStream.receiveRstStream(ErrorCode.REFUSED_STREAM);
+          removeStream(framedStream.getId());
         }
       }
     }
 
     @Override public void windowUpdate(int streamId, long windowSizeIncrement) {
       if (streamId == 0) {
-        synchronized (SpdyConnection.this) {
+        synchronized (FramedConnection.this) {
           bytesLeftInWriteWindow += windowSizeIncrement;
-          SpdyConnection.this.notifyAll();
+          FramedConnection.this.notifyAll();
         }
       } else {
-        SpdyStream stream = getStream(streamId);
+        FramedStream stream = getStream(streamId);
         if (stream != null) {
           synchronized (stream) {
             stream.addBytesToWriteWindow(windowSizeIncrement);
@@ -798,13 +808,13 @@ private void pushRequestLater(final int streamId, final List<Header> requestHead
       }
       currentPushRequests.add(streamId);
     }
-    pushExecutor.submit(new NamedRunnable("OkHttp %s Push Request[%s]", hostName, streamId) {
+    pushExecutor.execute(new NamedRunnable("OkHttp %s Push Request[%s]", hostName, streamId) {
       @Override public void execute() {
         boolean cancel = pushObserver.onRequest(streamId, requestHeaders);
         try {
           if (cancel) {
             frameWriter.rstStream(streamId, ErrorCode.CANCEL);
-            synchronized (SpdyConnection.this) {
+            synchronized (FramedConnection.this) {
               currentPushRequests.remove(streamId);
             }
           }
@@ -816,13 +826,13 @@ private void pushRequestLater(final int streamId, final List<Header> requestHead
 
   private void pushHeadersLater(final int streamId, final List<Header> requestHeaders,
       final boolean inFinished) {
-    pushExecutor.submit(new NamedRunnable("OkHttp %s Push Headers[%s]", hostName, streamId) {
+    pushExecutor.execute(new NamedRunnable("OkHttp %s Push Headers[%s]", hostName, streamId) {
       @Override public void execute() {
         boolean cancel = pushObserver.onHeaders(streamId, requestHeaders, inFinished);
         try {
           if (cancel) frameWriter.rstStream(streamId, ErrorCode.CANCEL);
           if (cancel || inFinished) {
-            synchronized (SpdyConnection.this) {
+            synchronized (FramedConnection.this) {
               currentPushRequests.remove(streamId);
             }
           }
@@ -842,13 +852,13 @@ private void pushDataLater(final int streamId, final BufferedSource source, fina
     source.require(byteCount); // Eagerly read the frame before firing client thread.
     source.read(buffer, byteCount);
     if (buffer.size() != byteCount) throw new IOException(buffer.size() + " != " + byteCount);
-    pushExecutor.submit(new NamedRunnable("OkHttp %s Push Data[%s]", hostName, streamId) {
+    pushExecutor.execute(new NamedRunnable("OkHttp %s Push Data[%s]", hostName, streamId) {
       @Override public void execute() {
         try {
           boolean cancel = pushObserver.onData(streamId, buffer, byteCount, inFinished);
           if (cancel) frameWriter.rstStream(streamId, ErrorCode.CANCEL);
           if (cancel || inFinished) {
-            synchronized (SpdyConnection.this) {
+            synchronized (FramedConnection.this) {
               currentPushRequests.remove(streamId);
             }
           }
@@ -859,10 +869,10 @@ private void pushDataLater(final int streamId, final BufferedSource source, fina
   }
 
   private void pushResetLater(final int streamId, final ErrorCode errorCode) {
-    pushExecutor.submit(new NamedRunnable("OkHttp %s Push Reset[%s]", hostName, streamId) {
+    pushExecutor.execute(new NamedRunnable("OkHttp %s Push Reset[%s]", hostName, streamId) {
       @Override public void execute() {
         pushObserver.onReset(streamId, errorCode);
-        synchronized (SpdyConnection.this) {
+        synchronized (FramedConnection.this) {
           currentPushRequests.remove(streamId);
         }
       }
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/SpdyStream.java b/okhttp/src/main/java/com/squareup/okhttp/internal/framed/FramedStream.java
similarity index 77%
rename from okhttp/src/main/java/com/squareup/okhttp/internal/spdy/SpdyStream.java
rename to okhttp/src/main/java/com/squareup/okhttp/internal/framed/FramedStream.java
index 331536d376..a47b12e627 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/SpdyStream.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/framed/FramedStream.java
@@ -14,11 +14,12 @@
  * limitations under the License.
  */
 
-package com.squareup.okhttp.internal.spdy;
+package com.squareup.okhttp.internal.framed;
 
 import java.io.EOFException;
 import java.io.IOException;
 import java.io.InterruptedIOException;
+import java.net.SocketTimeoutException;
 import java.util.ArrayList;
 import java.util.List;
 import okio.AsyncTimeout;
@@ -28,16 +29,16 @@
 import okio.Source;
 import okio.Timeout;
 
-import static com.squareup.okhttp.internal.spdy.Settings.DEFAULT_INITIAL_WINDOW_SIZE;
+import static com.squareup.okhttp.internal.framed.Settings.DEFAULT_INITIAL_WINDOW_SIZE;
 
 /** A logical bidirectional stream. */
-public final class SpdyStream {
+public final class FramedStream {
   // Internal state is guarded by this. No long-running or potentially
   // blocking operations are performed while the lock is held.
 
   /**
    * The total number of bytes consumed by the application (with {@link
-   * SpdyDataSource#read}), but not yet acknowledged by sending a {@code
+   * FramedDataSource#read}), but not yet acknowledged by sending a {@code
    * WINDOW_UPDATE} frame on this stream.
    */
   // Visible for testing
@@ -52,8 +53,7 @@
   long bytesLeftInWriteWindow;
 
   private final int id;
-  private final SpdyConnection connection;
-  private long readTimeoutMillis = 0;
+  private final FramedConnection connection;
 
   /** Headers sent by the stream initiator. Immutable and non null. */
   private final List<Header> requestHeaders;
@@ -61,10 +61,10 @@
   /** Headers sent in the stream reply. Null if reply is either not sent or not sent yet. */
   private List<Header> responseHeaders;
 
-  private final SpdyDataSource source;
-  final SpdyDataSink sink;
-  private final SpdyTimeout readTimeout = new SpdyTimeout();
-  private final SpdyTimeout writeTimeout = new SpdyTimeout();
+  private final FramedDataSource source;
+  final FramedDataSink sink;
+  private final StreamTimeout readTimeout = new StreamTimeout();
+  private final StreamTimeout writeTimeout = new StreamTimeout();
 
   /**
    * The reason why this stream was abnormally closed. If there are multiple
@@ -73,7 +73,7 @@
    */
   private ErrorCode errorCode = null;
 
-  SpdyStream(int id, SpdyConnection connection, boolean outFinished, boolean inFinished,
+  FramedStream(int id, FramedConnection connection, boolean outFinished, boolean inFinished,
       List<Header> requestHeaders) {
     if (connection == null) throw new NullPointerException("connection == null");
     if (requestHeaders == null) throw new NullPointerException("requestHeaders == null");
@@ -81,9 +81,9 @@
     this.connection = connection;
     this.bytesLeftInWriteWindow =
         connection.peerSettings.getInitialWindowSize(DEFAULT_INITIAL_WINDOW_SIZE);
-    this.source = new SpdyDataSource(
+    this.source = new FramedDataSource(
         connection.okHttpSettings.getInitialWindowSize(DEFAULT_INITIAL_WINDOW_SIZE));
-    this.sink = new SpdyDataSink();
+    this.sink = new FramedDataSink();
     this.source.finished = inFinished;
     this.sink.finished = outFinished;
     this.requestHeaders = requestHeaders;
@@ -121,7 +121,7 @@ public boolean isLocallyInitiated() {
     return connection.client == streamIsClient;
   }
 
-  public SpdyConnection getConnection() {
+  public FramedConnection getConnection() {
     return connection;
   }
 
@@ -161,7 +161,7 @@ public synchronized ErrorCode getErrorCode() {
    * to the remote peer. Corresponds to {@code FLAG_FIN}.
    */
   public void reply(List<Header> responseHeaders, boolean out) throws IOException {
-    assert (!Thread.holdsLock(SpdyStream.this));
+    assert (!Thread.holdsLock(FramedStream.this));
     boolean outFinished = false;
     synchronized (this) {
       if (responseHeaders == null) {
@@ -251,7 +251,7 @@ private boolean closeInternal(ErrorCode errorCode) {
   }
 
   void receiveHeaders(List<Header> headers, HeadersMode headersMode) {
-    assert (!Thread.holdsLock(SpdyStream.this));
+    assert (!Thread.holdsLock(FramedStream.this));
     ErrorCode errorCode = null;
     boolean open = true;
     synchronized (this) {
@@ -282,12 +282,12 @@ void receiveHeaders(List<Header> headers, HeadersMode headersMode) {
   }
 
   void receiveData(BufferedSource in, int length) throws IOException {
-    assert (!Thread.holdsLock(SpdyStream.this));
+    assert (!Thread.holdsLock(FramedStream.this));
     this.source.receive(in, length);
   }
 
   void receiveFin() {
-    assert (!Thread.holdsLock(SpdyStream.this));
+    assert (!Thread.holdsLock(FramedStream.this));
     boolean open;
     synchronized (this) {
       this.source.finished = true;
@@ -311,11 +311,11 @@ synchronized void receiveRstStream(ErrorCode errorCode) {
    * class uses synchronization to safely receive incoming data frames, it is
    * not intended for use by multiple readers.
    */
-  private final class SpdyDataSource implements Source {
+  private final class FramedDataSource implements Source {
     /** Buffer to receive data from the network into. Only accessed by the reader thread. */
     private final Buffer receiveBuffer = new Buffer();
 
-    /** Buffer with readable data. Guarded by SpdyStream.this. */
+    /** Buffer with readable data. Guarded by FramedStream.this. */
     private final Buffer readBuffer = new Buffer();
 
     /** Maximum number of bytes to buffer before reporting a flow control error. */
@@ -330,7 +330,7 @@ synchronized void receiveRstStream(ErrorCode errorCode) {
      */
     private boolean finished;
 
-    private SpdyDataSource(long maxByteCount) {
+    private FramedDataSource(long maxByteCount) {
       this.maxByteCount = maxByteCount;
     }
 
@@ -339,7 +339,7 @@ private SpdyDataSource(long maxByteCount) {
       if (byteCount < 0) throw new IllegalArgumentException("byteCount < 0: " + byteCount);
 
       long read;
-      synchronized (SpdyStream.this) {
+      synchronized (FramedStream.this) {
         waitUntilReadable();
         checkNotClosed();
         if (readBuffer.size() == 0) return -1; // This source is exhausted.
@@ -382,12 +382,12 @@ private void waitUntilReadable() throws IOException {
     }
 
     void receive(BufferedSource in, long byteCount) throws IOException {
-      assert (!Thread.holdsLock(SpdyStream.this));
+      assert (!Thread.holdsLock(FramedStream.this));
 
       while (byteCount > 0) {
         boolean finished;
         boolean flowControlError;
-        synchronized (SpdyStream.this) {
+        synchronized (FramedStream.this) {
           finished = this.finished;
           flowControlError = byteCount + readBuffer.size() > maxByteCount;
         }
@@ -411,11 +411,11 @@ void receive(BufferedSource in, long byteCount) throws IOException {
         byteCount -= read;
 
         // Move the received data to the read buffer to the reader can read it.
-        synchronized (SpdyStream.this) {
+        synchronized (FramedStream.this) {
           boolean wasEmpty = readBuffer.size() == 0;
           readBuffer.writeAll(receiveBuffer);
           if (wasEmpty) {
-            SpdyStream.this.notifyAll();
+            FramedStream.this.notifyAll();
           }
         }
       }
@@ -426,10 +426,10 @@ void receive(BufferedSource in, long byteCount) throws IOException {
     }
 
     @Override public void close() throws IOException {
-      synchronized (SpdyStream.this) {
+      synchronized (FramedStream.this) {
         closed = true;
         readBuffer.clear();
-        SpdyStream.this.notifyAll();
+        FramedStream.this.notifyAll();
       }
       cancelStreamIfNecessary();
     }
@@ -445,7 +445,7 @@ private void checkNotClosed() throws IOException {
   }
 
   private void cancelStreamIfNecessary() throws IOException {
-    assert (!Thread.holdsLock(SpdyStream.this));
+    assert (!Thread.holdsLock(FramedStream.this));
     boolean open;
     boolean cancel;
     synchronized (this) {
@@ -457,7 +457,7 @@ private void cancelStreamIfNecessary() throws IOException {
       // is safe because the input stream is closed (we won't use any
       // further bytes) and the output stream is either finished or closed
       // (so RSTing both streams doesn't cause harm).
-      SpdyStream.this.close(ErrorCode.CANCEL);
+      FramedStream.this.close(ErrorCode.CANCEL);
     } else if (!open) {
       connection.removeStream(id);
     }
@@ -467,7 +467,15 @@ private void cancelStreamIfNecessary() throws IOException {
    * A sink that writes outgoing data frames of a stream. This class is not
    * thread safe.
    */
-  final class SpdyDataSink implements Sink {
+  final class FramedDataSink implements Sink {
+    private static final long EMIT_BUFFER_SIZE = 16384;
+
+    /**
+     * Buffer of outgoing data. This batches writes of small writes into this sink as larges
+     * frames written to the outgoing connection. Batching saves the (small) framing overhead.
+     */
+    private final Buffer sendBuffer = new Buffer();
+
     private boolean closed;
 
     /**
@@ -477,35 +485,51 @@ private void cancelStreamIfNecessary() throws IOException {
     private boolean finished;
 
     @Override public void write(Buffer source, long byteCount) throws IOException {
-      assert (!Thread.holdsLock(SpdyStream.this));
-      while (byteCount > 0) {
-        long toWrite;
-        synchronized (SpdyStream.this) {
-          writeTimeout.enter();
-          try {
-            while (bytesLeftInWriteWindow <= 0 && !finished && !closed && errorCode == null) {
-              waitForIo(); // Wait until we receive a WINDOW_UPDATE.
-            }
-          } finally {
-            writeTimeout.exitAndThrowIfTimedOut();
-          }
+      assert (!Thread.holdsLock(FramedStream.this));
+      sendBuffer.write(source, byteCount);
+      while (sendBuffer.size() >= EMIT_BUFFER_SIZE) {
+        emitDataFrame(false);
+      }
+    }
 
-          checkOutNotClosed(); // Kick out if the stream was reset or closed while waiting.
-          toWrite = Math.min(bytesLeftInWriteWindow, byteCount);
-          bytesLeftInWriteWindow -= toWrite;
+    /**
+     * Emit a single data frame to the connection. The frame's size be limited by this stream's
+     * write window. This method will block until the write window is nonempty.
+     */
+    private void emitDataFrame(boolean outFinished) throws IOException {
+      long toWrite;
+      synchronized (FramedStream.this) {
+        writeTimeout.enter();
+        try {
+          while (bytesLeftInWriteWindow <= 0 && !finished && !closed && errorCode == null) {
+            waitForIo(); // Wait until we receive a WINDOW_UPDATE for this stream.
+          }
+        } finally {
+          writeTimeout.exitAndThrowIfTimedOut();
         }
 
-        byteCount -= toWrite;
-        connection.writeData(id, false, source, toWrite);
+        checkOutNotClosed(); // Kick out if the stream was reset or closed while waiting.
+        toWrite = Math.min(bytesLeftInWriteWindow, sendBuffer.size());
+        bytesLeftInWriteWindow -= toWrite;
+      }
+
+      writeTimeout.enter();
+      try {
+        connection.writeData(id, outFinished && toWrite == sendBuffer.size(), sendBuffer, toWrite);
+      } finally {
+        writeTimeout.exitAndThrowIfTimedOut();
       }
     }
 
     @Override public void flush() throws IOException {
-      assert (!Thread.holdsLock(SpdyStream.this));
-      synchronized (SpdyStream.this) {
+      assert (!Thread.holdsLock(FramedStream.this));
+      synchronized (FramedStream.this) {
         checkOutNotClosed();
       }
-      connection.flush();
+      while (sendBuffer.size() > 0) {
+        emitDataFrame(false);
+        connection.flush();
+      }
     }
 
     @Override public Timeout timeout() {
@@ -513,14 +537,22 @@ private void cancelStreamIfNecessary() throws IOException {
     }
 
     @Override public void close() throws IOException {
-      assert (!Thread.holdsLock(SpdyStream.this));
-      synchronized (SpdyStream.this) {
+      assert (!Thread.holdsLock(FramedStream.this));
+      synchronized (FramedStream.this) {
         if (closed) return;
       }
       if (!sink.finished) {
-        connection.writeData(id, true, null, 0);
+        // Emit the remaining data, setting the END_STREAM flag on the last frame.
+        if (sendBuffer.size() > 0) {
+          while (sendBuffer.size() > 0) {
+            emitDataFrame(true);
+          }
+        } else {
+          // Send an empty frame just so we can set the END_STREAM flag.
+          connection.writeData(id, true, null, 0);
+        }
       }
-      synchronized (SpdyStream.this) {
+      synchronized (FramedStream.this) {
         closed = true;
       }
       connection.flush();
@@ -534,7 +566,7 @@ private void cancelStreamIfNecessary() throws IOException {
    */
   void addBytesToWriteWindow(long delta) {
     bytesLeftInWriteWindow += delta;
-    if (delta > 0) SpdyStream.this.notifyAll();
+    if (delta > 0) FramedStream.this.notifyAll();
   }
 
   private void checkOutNotClosed() throws IOException {
@@ -564,13 +596,21 @@ private void waitForIo() throws InterruptedIOException {
    * reached. In that case we close the stream (asynchronously) which will
    * notify the waiting thread.
    */
-  class SpdyTimeout extends AsyncTimeout {
+  class StreamTimeout extends AsyncTimeout {
     @Override protected void timedOut() {
       closeLater(ErrorCode.CANCEL);
     }
 
-    public void exitAndThrowIfTimedOut() throws InterruptedIOException {
-      if (exit()) throw new InterruptedIOException("timeout");
+    @Override protected IOException newTimeoutException(IOException cause) {
+      SocketTimeoutException socketTimeoutException = new SocketTimeoutException("timeout");
+      if (cause != null) {
+        socketTimeoutException.initCause(cause);
+      }
+      return socketTimeoutException;
+    }
+
+    public void exitAndThrowIfTimedOut() throws IOException {
+      if (exit()) throw newTimeoutException(null /* cause */);
     }
   }
 }
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/Header.java b/okhttp/src/main/java/com/squareup/okhttp/internal/framed/Header.java
similarity index 97%
rename from okhttp/src/main/java/com/squareup/okhttp/internal/spdy/Header.java
rename to okhttp/src/main/java/com/squareup/okhttp/internal/framed/Header.java
index d14d13115d..af5594f614 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/Header.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/framed/Header.java
@@ -1,4 +1,4 @@
-package com.squareup.okhttp.internal.spdy;
+package com.squareup.okhttp.internal.framed;
 
 import okio.ByteString;
 
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/HeadersMode.java b/okhttp/src/main/java/com/squareup/okhttp/internal/framed/HeadersMode.java
similarity index 96%
rename from okhttp/src/main/java/com/squareup/okhttp/internal/spdy/HeadersMode.java
rename to okhttp/src/main/java/com/squareup/okhttp/internal/framed/HeadersMode.java
index c06327acf4..b42915b610 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/HeadersMode.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/framed/HeadersMode.java
@@ -13,7 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.squareup.okhttp.internal.spdy;
+package com.squareup.okhttp.internal.framed;
 
 public enum HeadersMode {
   SPDY_SYN_STREAM,
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/HpackDraft10.java b/okhttp/src/main/java/com/squareup/okhttp/internal/framed/Hpack.java
similarity index 98%
rename from okhttp/src/main/java/com/squareup/okhttp/internal/spdy/HpackDraft10.java
rename to okhttp/src/main/java/com/squareup/okhttp/internal/framed/Hpack.java
index 2e7801533b..171516f7af 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/HpackDraft10.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/framed/Hpack.java
@@ -13,7 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.squareup.okhttp.internal.spdy;
+package com.squareup.okhttp.internal.framed;
 
 import java.io.IOException;
 import java.util.ArrayList;
@@ -31,13 +31,13 @@
 /**
  * Read and write HPACK v10.
  *
- * http://tools.ietf.org/html/draft-ietf-httpbis-header-compression-10
+ * http://tools.ietf.org/html/draft-ietf-httpbis-header-compression-12
  *
  * This implementation uses an array for the dynamic table and a list for
  * indexed entries.  Dynamic entries are added to the array, starting in the
  * last position moving forward.  When the array fills, it is doubled.
  */
-final class HpackDraft10 {
+final class Hpack {
   private static final int PREFIX_4_BITS = 0x0f;
   private static final int PREFIX_5_BITS = 0x1f;
   private static final int PREFIX_6_BITS = 0x3f;
@@ -107,10 +107,10 @@
       new Header("www-authenticate", "")
   };
 
-  private HpackDraft10() {
+  private Hpack() {
   }
 
-  // http://tools.ietf.org/html/draft-ietf-httpbis-header-compression-10#section-3.1
+  // http://tools.ietf.org/html/draft-ietf-httpbis-header-compression-12#section-3.1
   static final class Reader {
 
     private final List<Header> headerList = new ArrayList<>();
@@ -374,7 +374,7 @@ ByteString readByteString() throws IOException {
     }
 
     /** This does not use "never indexed" semantics for sensitive headers. */
-    // http://tools.ietf.org/html/draft-ietf-httpbis-header-compression-10#section-6.2.3
+    // http://tools.ietf.org/html/draft-ietf-httpbis-header-compression-12#section-6.2.3
     void writeHeaders(List<Header> headerBlock) throws IOException {
       // TODO: implement index tracking
       for (int i = 0, size = headerBlock.size(); i < size; i++) {
@@ -392,7 +392,7 @@ void writeHeaders(List<Header> headerBlock) throws IOException {
       }
     }
 
-    // http://tools.ietf.org/html/draft-ietf-httpbis-header-compression-10#section-4.1.1
+    // http://tools.ietf.org/html/draft-ietf-httpbis-header-compression-12#section-4.1.1
     void writeInt(int value, int prefixMask, int bits) throws IOException {
       // Write the raw value for a single byte value.
       if (value < prefixMask) {
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/Http20Draft16.java b/okhttp/src/main/java/com/squareup/okhttp/internal/framed/Http2.java
similarity index 97%
rename from okhttp/src/main/java/com/squareup/okhttp/internal/spdy/Http20Draft16.java
rename to okhttp/src/main/java/com/squareup/okhttp/internal/framed/Http2.java
index 3b6095ce0a..0fde974400 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/Http20Draft16.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/framed/Http2.java
@@ -13,7 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.squareup.okhttp.internal.spdy;
+package com.squareup.okhttp.internal.framed;
 
 import com.squareup.okhttp.Protocol;
 import java.io.IOException;
@@ -26,20 +26,20 @@
 import okio.Source;
 import okio.Timeout;
 
-import static com.squareup.okhttp.internal.spdy.Http20Draft16.FrameLogger.formatHeader;
+import static com.squareup.okhttp.internal.framed.Http2.FrameLogger.formatHeader;
 import static java.lang.String.format;
 import static java.util.logging.Level.FINE;
 import static okio.ByteString.EMPTY;
 
 /**
- * Read and write HTTP/2 v16 frames.
+ * Read and write HTTP/2 frames.
  * <p>
  * This implementation assumes we do not send an increased
  * {@link Settings#getMaxFrameSize frame size setting} to the peer. Hence, we
  * expect all frames to have a max length of {@link #INITIAL_MAX_FRAME_SIZE}.
- * <p>http://tools.ietf.org/html/draft-ietf-httpbis-http2-16
+ * <p>http://tools.ietf.org/html/draft-ietf-httpbis-http2-17
  */
-public final class Http20Draft16 implements Variant {
+public final class Http2 implements Variant {
   private static final Logger logger = Logger.getLogger(FrameLogger.class.getName());
 
   @Override public Protocol getProtocol() {
@@ -90,13 +90,13 @@
     private final boolean client;
 
     // Visible for testing.
-    final HpackDraft10.Reader hpackReader;
+    final Hpack.Reader hpackReader;
 
     Reader(BufferedSource source, int headerTableSize, boolean client) {
       this.source = source;
       this.client = client;
       this.continuation = new ContinuationSource(this.source);
-      this.hpackReader = new HpackDraft10.Reader(headerTableSize, continuation);
+      this.hpackReader = new Hpack.Reader(headerTableSize, continuation);
     }
 
     @Override public void readConnectionPreface() throws IOException {
@@ -208,7 +208,7 @@ private void readHeaders(Handler handler, int length, byte flags, int streamId)
       continuation.streamId = streamId;
 
       // TODO: Concat multi-value headers with 0x0, except COOKIE, which uses 0x3B, 0x20.
-      // http://tools.ietf.org/html/draft-ietf-httpbis-http2-16#section-8.1.2.5
+      // http://tools.ietf.org/html/draft-ietf-httpbis-http2-17#section-8.1.2.5
       hpackReader.readHeaders();
       return hpackReader.getAndResetHeaderList();
     }
@@ -364,7 +364,7 @@ private void readWindowUpdate(Handler handler, int length, byte flags, int strea
     private final BufferedSink sink;
     private final boolean client;
     private final Buffer hpackBuffer;
-    private final HpackDraft10.Writer hpackWriter;
+    private final Hpack.Writer hpackWriter;
     private int maxFrameSize;
     private boolean closed;
 
@@ -372,7 +372,7 @@ private void readWindowUpdate(Handler handler, int length, byte flags, int strea
       this.sink = sink;
       this.client = client;
       this.hpackBuffer = new Buffer();
-      this.hpackWriter = new HpackDraft10.Writer(hpackBuffer);
+      this.hpackWriter = new Hpack.Writer(hpackBuffer);
       this.maxFrameSize = INITIAL_MAX_FRAME_SIZE;
     }
 
@@ -425,7 +425,6 @@ private void readWindowUpdate(Handler handler, int length, byte flags, int strea
     @Override public synchronized void pushPromise(int streamId, int promisedStreamId,
         List<Header> requestHeaders) throws IOException {
       if (closed) throw new IOException("closed");
-      if (hpackBuffer.size() != 0) throw new IllegalStateException();
       hpackWriter.writeHeaders(requestHeaders);
 
       long byteCount = hpackBuffer.size();
@@ -441,7 +440,6 @@ private void readWindowUpdate(Handler handler, int length, byte flags, int strea
 
     void headers(boolean outFinished, int streamId, List<Header> headerBlock) throws IOException {
       if (closed) throw new IOException("closed");
-      if (hpackBuffer.size() != 0) throw new IllegalStateException();
       hpackWriter.writeHeaders(headerBlock);
 
       long byteCount = hpackBuffer.size();
@@ -467,7 +465,7 @@ private void writeContinuationFrames(int streamId, long byteCount) throws IOExce
     @Override public synchronized void rstStream(int streamId, ErrorCode errorCode)
         throws IOException {
       if (closed) throw new IOException("closed");
-      if (errorCode.spdyRstCode == -1) throw new IllegalArgumentException();
+      if (errorCode.httpCode == -1) throw new IllegalArgumentException();
 
       int length = 4;
       byte type = TYPE_RST_STREAM;
@@ -589,7 +587,7 @@ private static IOException ioException(String message, Object... args) throws IO
   /**
    * Decompression of the header block occurs above the framing layer. This
    * class lazily reads continuation frames as they are needed by {@link
-   * HpackDraft10.Reader#readHeaders()}.
+   * Hpack.Reader#readHeaders()}.
    */
   static final class ContinuationSource implements Source {
     private final BufferedSource source;
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/Huffman.java b/okhttp/src/main/java/com/squareup/okhttp/internal/framed/Huffman.java
similarity index 99%
rename from okhttp/src/main/java/com/squareup/okhttp/internal/spdy/Huffman.java
rename to okhttp/src/main/java/com/squareup/okhttp/internal/framed/Huffman.java
index 298087bf21..f21a16ded0 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/Huffman.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/framed/Huffman.java
@@ -13,7 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.squareup.okhttp.internal.spdy;
+package com.squareup.okhttp.internal.framed;
 
 import java.io.ByteArrayOutputStream;
 import java.io.IOException;
@@ -31,7 +31,7 @@
 class Huffman {
 
   // Appendix C: Huffman Codes
-  // http://tools.ietf.org/html/draft-ietf-httpbis-header-compression-10#appendix-B
+  // http://tools.ietf.org/html/draft-ietf-httpbis-header-compression-12#appendix-B
   private static final int[] CODES = {
       0x1ff8, 0x7fffd8, 0xfffffe2, 0xfffffe3, 0xfffffe4, 0xfffffe5, 0xfffffe6, 0xfffffe7, 0xfffffe8,
       0xffffea, 0x3ffffffc, 0xfffffe9, 0xfffffea, 0x3ffffffd, 0xfffffeb, 0xfffffec, 0xfffffed,
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/IncomingStreamHandler.java b/okhttp/src/main/java/com/squareup/okhttp/internal/framed/IncomingStreamHandler.java
similarity index 75%
rename from okhttp/src/main/java/com/squareup/okhttp/internal/spdy/IncomingStreamHandler.java
rename to okhttp/src/main/java/com/squareup/okhttp/internal/framed/IncomingStreamHandler.java
index 44d4ea2bfa..57863df113 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/IncomingStreamHandler.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/framed/IncomingStreamHandler.java
@@ -14,23 +14,23 @@
  * limitations under the License.
  */
 
-package com.squareup.okhttp.internal.spdy;
+package com.squareup.okhttp.internal.framed;
 
 import java.io.IOException;
 
 /** Listener to be notified when a connected peer creates a new stream. */
 public interface IncomingStreamHandler {
   IncomingStreamHandler REFUSE_INCOMING_STREAMS = new IncomingStreamHandler() {
-    @Override public void receive(SpdyStream stream) throws IOException {
+    @Override public void receive(FramedStream stream) throws IOException {
       stream.close(ErrorCode.REFUSED_STREAM);
     }
   };
 
   /**
    * Handle a new stream from this connection's peer. Implementations should
-   * respond by either {@link SpdyStream#reply replying to the stream} or
-   * {@link SpdyStream#close closing it}. This response does not need to be
+   * respond by either {@link FramedStream#reply replying to the stream} or
+   * {@link FramedStream#close closing it}. This response does not need to be
    * synchronous.
    */
-  void receive(SpdyStream stream) throws IOException;
+  void receive(FramedStream stream) throws IOException;
 }
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/NameValueBlockReader.java b/okhttp/src/main/java/com/squareup/okhttp/internal/framed/NameValueBlockReader.java
similarity index 98%
rename from okhttp/src/main/java/com/squareup/okhttp/internal/spdy/NameValueBlockReader.java
rename to okhttp/src/main/java/com/squareup/okhttp/internal/framed/NameValueBlockReader.java
index 6413f36345..d9554a361b 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/NameValueBlockReader.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/framed/NameValueBlockReader.java
@@ -13,7 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.squareup.okhttp.internal.spdy;
+package com.squareup.okhttp.internal.framed;
 
 import java.io.IOException;
 import java.util.ArrayList;
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/Ping.java b/okhttp/src/main/java/com/squareup/okhttp/internal/framed/Ping.java
similarity index 97%
rename from okhttp/src/main/java/com/squareup/okhttp/internal/spdy/Ping.java
rename to okhttp/src/main/java/com/squareup/okhttp/internal/framed/Ping.java
index 06b0aefccf..35f9cf5be6 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/Ping.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/framed/Ping.java
@@ -13,7 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.squareup.okhttp.internal.spdy;
+package com.squareup.okhttp.internal.framed;
 
 import java.util.concurrent.CountDownLatch;
 import java.util.concurrent.TimeUnit;
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/PushObserver.java b/okhttp/src/main/java/com/squareup/okhttp/internal/framed/PushObserver.java
similarity index 98%
rename from okhttp/src/main/java/com/squareup/okhttp/internal/spdy/PushObserver.java
rename to okhttp/src/main/java/com/squareup/okhttp/internal/framed/PushObserver.java
index cdb51f65a5..33ebc617e3 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/PushObserver.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/framed/PushObserver.java
@@ -13,7 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.squareup.okhttp.internal.spdy;
+package com.squareup.okhttp.internal.framed;
 
 import java.io.IOException;
 import java.util.List;
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/Settings.java b/okhttp/src/main/java/com/squareup/okhttp/internal/framed/Settings.java
similarity index 98%
rename from okhttp/src/main/java/com/squareup/okhttp/internal/spdy/Settings.java
rename to okhttp/src/main/java/com/squareup/okhttp/internal/framed/Settings.java
index bb67b8311a..935d489045 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/Settings.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/framed/Settings.java
@@ -13,13 +13,13 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.squareup.okhttp.internal.spdy;
+package com.squareup.okhttp.internal.framed;
 
 import java.util.Arrays;
 
 /**
  * Settings describe characteristics of the sending peer, which are used by the receiving peer.
- * Settings are {@link com.squareup.okhttp.internal.spdy.SpdyConnection connection} scoped.
+ * Settings are {@link FramedConnection connection} scoped.
  */
 public final class Settings {
   /**
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/Spdy3.java b/okhttp/src/main/java/com/squareup/okhttp/internal/framed/Spdy3.java
similarity index 99%
rename from okhttp/src/main/java/com/squareup/okhttp/internal/spdy/Spdy3.java
rename to okhttp/src/main/java/com/squareup/okhttp/internal/framed/Spdy3.java
index c5cebe7c73..bea53f7969 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/Spdy3.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/framed/Spdy3.java
@@ -13,7 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.squareup.okhttp.internal.spdy;
+package com.squareup.okhttp.internal.framed;
 
 import com.squareup.okhttp.Protocol;
 import com.squareup.okhttp.internal.Util;
@@ -406,7 +406,6 @@ void sendDataFrame(int streamId, int flags, Buffer buffer, int byteCount)
     }
 
     private void writeNameValueBlockToBuffer(List<Header> headerBlock) throws IOException {
-      if (headerBlockBuffer.size() != 0) throw new IllegalStateException();
       headerBlockOut.writeInt(headerBlock.size());
       for (int i = 0, size = headerBlock.size(); i < size; i++) {
         ByteString name = headerBlock.get(i).name;
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/Variant.java b/okhttp/src/main/java/com/squareup/okhttp/internal/framed/Variant.java
similarity index 96%
rename from okhttp/src/main/java/com/squareup/okhttp/internal/spdy/Variant.java
rename to okhttp/src/main/java/com/squareup/okhttp/internal/framed/Variant.java
index c4b082d706..0782ba1a86 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/Variant.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/framed/Variant.java
@@ -13,7 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.squareup.okhttp.internal.spdy;
+package com.squareup.okhttp.internal.framed;
 
 import com.squareup.okhttp.Protocol;
 import okio.BufferedSink;
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/http/AuthenticatorAdapter.java b/okhttp/src/main/java/com/squareup/okhttp/internal/http/AuthenticatorAdapter.java
index a517ada7cc..8d884105d0 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/http/AuthenticatorAdapter.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/http/AuthenticatorAdapter.java
@@ -18,6 +18,7 @@
 import com.squareup.okhttp.Authenticator;
 import com.squareup.okhttp.Challenge;
 import com.squareup.okhttp.Credentials;
+import com.squareup.okhttp.HttpUrl;
 import com.squareup.okhttp.Request;
 import com.squareup.okhttp.Response;
 import java.io.IOException;
@@ -26,7 +27,6 @@
 import java.net.InetSocketAddress;
 import java.net.PasswordAuthentication;
 import java.net.Proxy;
-import java.net.URL;
 import java.util.List;
 
 /** Adapts {@link java.net.Authenticator} to {@link com.squareup.okhttp.Authenticator}. */
@@ -37,14 +37,14 @@
   @Override public Request authenticate(Proxy proxy, Response response) throws IOException {
     List<Challenge> challenges = response.challenges();
     Request request = response.request();
-    URL url = request.url();
+    HttpUrl url = request.httpUrl();
     for (int i = 0, size = challenges.size(); i < size; i++) {
       Challenge challenge = challenges.get(i);
       if (!"Basic".equalsIgnoreCase(challenge.getScheme())) continue;
 
       PasswordAuthentication auth = java.net.Authenticator.requestPasswordAuthentication(
-          url.getHost(), getConnectToInetAddress(proxy, url), url.getPort(), url.getProtocol(),
-          challenge.getRealm(), challenge.getScheme(), url, RequestorType.SERVER);
+          url.host(), getConnectToInetAddress(proxy, url), url.port(), url.scheme(),
+          challenge.getRealm(), challenge.getScheme(), url.url(), RequestorType.SERVER);
       if (auth == null) continue;
 
       String credential = Credentials.basic(auth.getUserName(), new String(auth.getPassword()));
@@ -59,7 +59,7 @@
   @Override public Request authenticateProxy(Proxy proxy, Response response) throws IOException {
     List<Challenge> challenges = response.challenges();
     Request request = response.request();
-    URL url = request.url();
+    HttpUrl url = request.httpUrl();
     for (int i = 0, size = challenges.size(); i < size; i++) {
       Challenge challenge = challenges.get(i);
       if (!"Basic".equalsIgnoreCase(challenge.getScheme())) continue;
@@ -67,7 +67,7 @@
       InetSocketAddress proxyAddress = (InetSocketAddress) proxy.address();
       PasswordAuthentication auth = java.net.Authenticator.requestPasswordAuthentication(
           proxyAddress.getHostName(), getConnectToInetAddress(proxy, url), proxyAddress.getPort(),
-          url.getProtocol(), challenge.getRealm(), challenge.getScheme(), url,
+          url.scheme(), challenge.getRealm(), challenge.getScheme(), url.url(),
           RequestorType.PROXY);
       if (auth == null) continue;
 
@@ -79,9 +79,9 @@
     return null;
   }
 
-  private InetAddress getConnectToInetAddress(Proxy proxy, URL url) throws IOException {
+  private InetAddress getConnectToInetAddress(Proxy proxy, HttpUrl url) throws IOException {
     return (proxy != null && proxy.type() != Proxy.Type.DIRECT)
         ? ((InetSocketAddress) proxy.address()).getAddress()
-        : InetAddress.getByName(url.getHost());
+        : InetAddress.getByName(url.host());
   }
 }
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/http/CacheStrategy.java b/okhttp/src/main/java/com/squareup/okhttp/internal/http/CacheStrategy.java
index ff613cd9e8..aee0dae500 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/http/CacheStrategy.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/http/CacheStrategy.java
@@ -4,7 +4,6 @@
 import com.squareup.okhttp.Headers;
 import com.squareup.okhttp.Request;
 import com.squareup.okhttp.Response;
-
 import java.util.Date;
 
 import static com.squareup.okhttp.internal.http.StatusLine.HTTP_PERM_REDIRECT;
@@ -225,16 +224,14 @@ private CacheStrategy getCandidate() {
 
       Request.Builder conditionalRequestBuilder = request.newBuilder();
 
-      if (lastModified != null) {
+      if (etag != null) {
+        conditionalRequestBuilder.header("If-None-Match", etag);
+      } else if (lastModified != null) {
         conditionalRequestBuilder.header("If-Modified-Since", lastModifiedString);
       } else if (servedDate != null) {
         conditionalRequestBuilder.header("If-Modified-Since", servedDateString);
       }
 
-      if (etag != null) {
-        conditionalRequestBuilder.header("If-None-Match", etag);
-      }
-
       Request conditionalRequest = conditionalRequestBuilder.build();
       return hasConditions(conditionalRequest)
           ? new CacheStrategy(conditionalRequest, cacheResponse)
@@ -256,7 +253,7 @@ private long computeFreshnessLifetime() {
         long delta = expires.getTime() - servedMillis;
         return delta > 0 ? delta : 0;
       } else if (lastModified != null
-          && cacheResponse.request().url().getQuery() == null) {
+          && cacheResponse.request().httpUrl().query() == null) {
         // As recommended by the HTTP RFC and implemented in Firefox, the
         // max age of a document should be defaulted to 10% of the
         // document's age at the time it was served. Default expiration
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/http/SpdyTransport.java b/okhttp/src/main/java/com/squareup/okhttp/internal/http/FramedTransport.java
similarity index 84%
rename from okhttp/src/main/java/com/squareup/okhttp/internal/http/SpdyTransport.java
rename to okhttp/src/main/java/com/squareup/okhttp/internal/http/FramedTransport.java
index 61b6610810..abeaf869e8 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/http/SpdyTransport.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/http/FramedTransport.java
@@ -22,10 +22,10 @@
 import com.squareup.okhttp.Response;
 import com.squareup.okhttp.ResponseBody;
 import com.squareup.okhttp.internal.Util;
-import com.squareup.okhttp.internal.spdy.ErrorCode;
-import com.squareup.okhttp.internal.spdy.Header;
-import com.squareup.okhttp.internal.spdy.SpdyConnection;
-import com.squareup.okhttp.internal.spdy.SpdyStream;
+import com.squareup.okhttp.internal.framed.ErrorCode;
+import com.squareup.okhttp.internal.framed.FramedConnection;
+import com.squareup.okhttp.internal.framed.FramedStream;
+import com.squareup.okhttp.internal.framed.Header;
 import java.io.IOException;
 import java.net.ProtocolException;
 import java.util.ArrayList;
@@ -38,15 +38,15 @@
 import okio.Okio;
 import okio.Sink;
 
-import static com.squareup.okhttp.internal.spdy.Header.RESPONSE_STATUS;
-import static com.squareup.okhttp.internal.spdy.Header.TARGET_AUTHORITY;
-import static com.squareup.okhttp.internal.spdy.Header.TARGET_HOST;
-import static com.squareup.okhttp.internal.spdy.Header.TARGET_METHOD;
-import static com.squareup.okhttp.internal.spdy.Header.TARGET_PATH;
-import static com.squareup.okhttp.internal.spdy.Header.TARGET_SCHEME;
-import static com.squareup.okhttp.internal.spdy.Header.VERSION;
+import static com.squareup.okhttp.internal.framed.Header.RESPONSE_STATUS;
+import static com.squareup.okhttp.internal.framed.Header.TARGET_AUTHORITY;
+import static com.squareup.okhttp.internal.framed.Header.TARGET_HOST;
+import static com.squareup.okhttp.internal.framed.Header.TARGET_METHOD;
+import static com.squareup.okhttp.internal.framed.Header.TARGET_PATH;
+import static com.squareup.okhttp.internal.framed.Header.TARGET_SCHEME;
+import static com.squareup.okhttp.internal.framed.Header.VERSION;
 
-public final class SpdyTransport implements Transport {
+public final class FramedTransport implements Transport {
   /** See http://www.chromium.org/spdy/spdy-protocol/spdy-protocol-draft3-1#TOC-3.2.1-Request. */
   private static final List<ByteString> SPDY_3_PROHIBITED_HEADERS = Util.immutableList(
       ByteString.encodeUtf8("connection"),
@@ -67,12 +67,12 @@
       ByteString.encodeUtf8("upgrade"));
 
   private final HttpEngine httpEngine;
-  private final SpdyConnection spdyConnection;
-  private SpdyStream stream;
+  private final FramedConnection framedConnection;
+  private FramedStream stream;
 
-  public SpdyTransport(HttpEngine httpEngine, SpdyConnection spdyConnection) {
+  public FramedTransport(HttpEngine httpEngine, FramedConnection framedConnection) {
     this.httpEngine = httpEngine;
-    this.spdyConnection = spdyConnection;
+    this.framedConnection = framedConnection;
   }
 
   @Override public Sink createRequestBody(Request request, long contentLength) throws IOException {
@@ -86,8 +86,8 @@ public SpdyTransport(HttpEngine httpEngine, SpdyConnection spdyConnection) {
     boolean permitsRequestBody = httpEngine.permitsRequestBody();
     boolean hasResponseBody = true;
     String version = RequestLine.version(httpEngine.getConnection().getProtocol());
-    stream = spdyConnection.newStream(
-        writeNameValueBlock(request, spdyConnection.getProtocol(), version), permitsRequestBody,
+    stream = framedConnection.newStream(
+        writeNameValueBlock(request, framedConnection.getProtocol(), version), permitsRequestBody,
         hasResponseBody);
     stream.readTimeout().timeout(httpEngine.client.getReadTimeout(), TimeUnit.MILLISECONDS);
   }
@@ -101,7 +101,7 @@ public SpdyTransport(HttpEngine httpEngine, SpdyConnection spdyConnection) {
   }
 
   @Override public Response.Builder readResponseHeaders() throws IOException {
-    return readNameValueBlock(stream.getResponseHeaders(), spdyConnection.getProtocol());
+    return readNameValueBlock(stream.getResponseHeaders(), framedConnection.getProtocol());
   }
 
   /**
@@ -114,8 +114,8 @@ public SpdyTransport(HttpEngine httpEngine, SpdyConnection spdyConnection) {
     Headers headers = request.headers();
     List<Header> result = new ArrayList<>(headers.size() + 10);
     result.add(new Header(TARGET_METHOD, request.method()));
-    result.add(new Header(TARGET_PATH, RequestLine.requestPath(request.url())));
-    String host = HttpEngine.hostHeader(request.url());
+    result.add(new Header(TARGET_PATH, RequestLine.requestPath(request.httpUrl())));
+    String host = Util.hostHeader(request.httpUrl());
     if (Protocol.SPDY_3 == protocol) {
       result.add(new Header(VERSION, version));
       result.add(new Header(TARGET_HOST, host));
@@ -124,7 +124,7 @@ public SpdyTransport(HttpEngine httpEngine, SpdyConnection spdyConnection) {
     } else {
       throw new AssertionError();
     }
-    result.add(new Header(TARGET_SCHEME, request.url().getProtocol()));
+    result.add(new Header(TARGET_SCHEME, request.httpUrl().scheme()));
 
     Set<ByteString> names = new LinkedHashSet<ByteString>();
     for (int i = 0, size = headers.size(); i < size; i++) {
@@ -216,7 +216,7 @@ private static String joinOnNull(String first, String second) {
   }
 
   @Override public boolean canReuseConnection() {
-    return true; // TODO: spdyConnection.isClosed() ?
+    return true; // TODO: framedConnection.isClosed() ?
   }
 
   /** When true, this header should not be emitted or consumed. */
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpConnection.java b/okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpConnection.java
index d4743d2772..1bbde80b48 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpConnection.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpConnection.java
@@ -22,6 +22,7 @@
 import com.squareup.okhttp.Response;
 import com.squareup.okhttp.internal.Internal;
 import com.squareup.okhttp.internal.Util;
+import java.io.EOFException;
 import java.io.IOException;
 import java.net.ProtocolException;
 import java.net.Socket;
@@ -29,6 +30,7 @@
 import okio.Buffer;
 import okio.BufferedSink;
 import okio.BufferedSource;
+import okio.ForwardingTimeout;
 import okio.Okio;
 import okio.Sink;
 import okio.Source;
@@ -184,23 +186,31 @@ public void writeRequest(Headers headers, String requestLine) throws IOException
       throw new IllegalStateException("state: " + state);
     }
 
-    while (true) {
-      StatusLine statusLine = StatusLine.parse(source.readUtf8LineStrict());
-
-      Response.Builder responseBuilder = new Response.Builder()
-          .protocol(statusLine.protocol)
-          .code(statusLine.code)
-          .message(statusLine.message);
-
-      Headers.Builder headersBuilder = new Headers.Builder();
-      readHeaders(headersBuilder);
-      headersBuilder.add(OkHeaders.SELECTED_PROTOCOL, statusLine.protocol.toString());
-      responseBuilder.headers(headersBuilder.build());
-
-      if (statusLine.code != HTTP_CONTINUE) {
-        state = STATE_OPEN_RESPONSE_BODY;
-        return responseBuilder;
+    try {
+      while (true) {
+        StatusLine statusLine = StatusLine.parse(source.readUtf8LineStrict());
+
+        Response.Builder responseBuilder = new Response.Builder()
+            .protocol(statusLine.protocol)
+            .code(statusLine.code)
+            .message(statusLine.message);
+
+        Headers.Builder headersBuilder = new Headers.Builder();
+        readHeaders(headersBuilder);
+        headersBuilder.add(OkHeaders.SELECTED_PROTOCOL, statusLine.protocol.toString());
+        responseBuilder.headers(headersBuilder.build());
+
+        if (statusLine.code != HTTP_CONTINUE) {
+          state = STATE_OPEN_RESPONSE_BODY;
+          return responseBuilder;
+        }
       }
+    } catch (EOFException e) {
+      // Provide more context if the server ends the stream before sending a response.
+      IOException exception = new IOException("unexpected end of stream on " + connection
+          + " (recycle count=" + Internal.instance.recycleCount(connection) + ")");
+      exception.initCause(e);
+      throw exception;
     }
   }
 
@@ -248,8 +258,29 @@ public Source newUnknownLengthSource() throws IOException {
     return new UnknownLengthSource();
   }
 
+  public BufferedSink rawSink() {
+    return sink;
+  }
+
+  public BufferedSource rawSource() {
+    return source;
+  }
+
+  /**
+   * Sets the delegate of {@code timeout} to {@link Timeout#NONE} and resets its underlying timeout
+   * to the default configuration. Use this to avoid unexpected sharing of timeouts between pooled
+   * connections.
+   */
+  private void detachTimeout(ForwardingTimeout timeout) {
+    Timeout oldDelegate = timeout.delegate();
+    timeout.setDelegate(Timeout.NONE);
+    oldDelegate.clearDeadline();
+    oldDelegate.clearTimeout();
+  }
+
   /** An HTTP body with a fixed length known in advance. */
   private final class FixedLengthSink implements Sink {
+    private final ForwardingTimeout timeout = new ForwardingTimeout(sink.timeout());
     private boolean closed;
     private long bytesRemaining;
 
@@ -258,7 +289,7 @@ private FixedLengthSink(long bytesRemaining) {
     }
 
     @Override public Timeout timeout() {
-      return sink.timeout();
+      return timeout;
     }
 
     @Override public void write(Buffer source, long byteCount) throws IOException {
@@ -281,38 +312,32 @@ private FixedLengthSink(long bytesRemaining) {
       if (closed) return;
       closed = true;
       if (bytesRemaining > 0) throw new ProtocolException("unexpected end of stream");
+      detachTimeout(timeout);
       state = STATE_READ_RESPONSE_HEADERS;
     }
   }
 
-  private static final byte[] CRLF = { '\r', '\n' };
-  private static final byte[] HEX_DIGITS = {
-      '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f'
-  };
-  private static final byte[] FINAL_CHUNK = { '0', '\r', '\n', '\r', '\n' };
-
   /**
    * An HTTP body with alternating chunk sizes and chunk bodies. It is the
    * caller's responsibility to buffer chunks; typically by using a buffered
    * sink with this sink.
    */
   private final class ChunkedSink implements Sink {
-    /** Scratch space for up to 16 hex digits, and then a constant CRLF. */
-    private final byte[] hex = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, '\r', '\n' };
-
+    private final ForwardingTimeout timeout = new ForwardingTimeout(sink.timeout());
     private boolean closed;
 
     @Override public Timeout timeout() {
-      return sink.timeout();
+      return timeout;
     }
 
     @Override public void write(Buffer source, long byteCount) throws IOException {
       if (closed) throw new IllegalStateException("closed");
       if (byteCount == 0) return;
 
-      writeHex(byteCount);
+      sink.writeHexadecimalUnsignedLong(byteCount);
+      sink.writeUtf8("\r\n");
       sink.write(source, byteCount);
-      sink.write(CRLF);
+      sink.writeUtf8("\r\n");
     }
 
     @Override public synchronized void flush() throws IOException {
@@ -323,28 +348,18 @@ private FixedLengthSink(long bytesRemaining) {
     @Override public synchronized void close() throws IOException {
       if (closed) return;
       closed = true;
-      sink.write(FINAL_CHUNK);
+      sink.writeUtf8("0\r\n\r\n");
+      detachTimeout(timeout);
       state = STATE_READ_RESPONSE_HEADERS;
     }
-
-    /**
-     * Equivalent to, but cheaper than writing Long.toHexString().getBytes()
-     * followed by CRLF.
-     */
-    private void writeHex(long i) throws IOException {
-      int cursor = 16;
-      do {
-        hex[--cursor] = HEX_DIGITS[((int) (i & 0xf))];
-      } while ((i >>>= 4) != 0);
-      sink.write(hex, cursor, hex.length - cursor);
-    }
   }
 
   private abstract class AbstractSource implements Source {
+    protected final ForwardingTimeout timeout = new ForwardingTimeout(source.timeout());
     protected boolean closed;
 
     @Override public Timeout timeout() {
-      return source.timeout();
+      return timeout;
     }
 
     /**
@@ -354,6 +369,8 @@ private void writeHex(long i) throws IOException {
     protected final void endOfInput(boolean recyclable) throws IOException {
       if (state != STATE_READING_RESPONSE_BODY) throw new IllegalStateException("state: " + state);
 
+      detachTimeout(timeout);
+
       state = STATE_IDLE;
       if (recyclable && onIdle == ON_IDLE_POOL) {
         onIdle = ON_IDLE_HOLD; // Set the on idle policy back to the default.
@@ -425,8 +442,8 @@ public FixedLengthSource(long length) throws IOException {
 
   /** An HTTP body with alternating chunk sizes and chunk bodies. */
   private class ChunkedSource extends AbstractSource {
-    private static final int NO_CHUNK_YET = -1;
-    private int bytesRemainingInChunk = NO_CHUNK_YET;
+    private static final long NO_CHUNK_YET = -1L;
+    private long bytesRemainingInChunk = NO_CHUNK_YET;
     private boolean hasMoreChunks = true;
     private final HttpEngine httpEngine;
 
@@ -447,7 +464,7 @@ public FixedLengthSource(long length) throws IOException {
       long read = source.read(sink, Math.min(byteCount, bytesRemainingInChunk));
       if (read == -1) {
         unexpectedEndOfInput(); // The server didn't supply the promised chunk length.
-        throw new IOException("unexpected end of stream");
+        throw new ProtocolException("unexpected end of stream");
       }
       bytesRemainingInChunk -= read;
       return read;
@@ -458,17 +475,17 @@ private void readChunkSize() throws IOException {
       if (bytesRemainingInChunk != NO_CHUNK_YET) {
         source.readUtf8LineStrict();
       }
-      String chunkSizeString = source.readUtf8LineStrict();
-      int index = chunkSizeString.indexOf(";");
-      if (index != -1) {
-        chunkSizeString = chunkSizeString.substring(0, index);
-      }
       try {
-        bytesRemainingInChunk = Integer.parseInt(chunkSizeString.trim(), 16);
+        bytesRemainingInChunk = source.readHexadecimalUnsignedLong();
+        String extensions = source.readUtf8LineStrict().trim();
+        if (bytesRemainingInChunk < 0 || (!extensions.isEmpty() && !extensions.startsWith(";"))) {
+          throw new ProtocolException("expected chunk size and optional extensions but was \""
+              + bytesRemainingInChunk + extensions + "\"");
+        }
       } catch (NumberFormatException e) {
-        throw new ProtocolException("Expected a hex chunk size but was " + chunkSizeString);
+        throw new ProtocolException(e.getMessage());
       }
-      if (bytesRemainingInChunk == 0) {
+      if (bytesRemainingInChunk == 0L) {
         hasMoreChunks = false;
         Headers.Builder trailersBuilder = new Headers.Builder();
         readHeaders(trailersBuilder);
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpEngine.java b/okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpEngine.java
index 643fa09e53..70eeaaa2e4 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpEngine.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpEngine.java
@@ -22,6 +22,7 @@
 import com.squareup.okhttp.Connection;
 import com.squareup.okhttp.ConnectionPool;
 import com.squareup.okhttp.Headers;
+import com.squareup.okhttp.HttpUrl;
 import com.squareup.okhttp.Interceptor;
 import com.squareup.okhttp.MediaType;
 import com.squareup.okhttp.OkHttpClient;
@@ -39,8 +40,7 @@
 import java.net.CookieHandler;
 import java.net.ProtocolException;
 import java.net.Proxy;
-import java.net.URL;
-import java.net.UnknownHostException;
+import java.net.SocketTimeoutException;
 import java.security.cert.CertificateException;
 import java.util.Date;
 import java.util.List;
@@ -59,8 +59,6 @@
 import okio.Timeout;
 
 import static com.squareup.okhttp.internal.Util.closeQuietly;
-import static com.squareup.okhttp.internal.Util.getDefaultPort;
-import static com.squareup.okhttp.internal.Util.getEffectivePort;
 import static com.squareup.okhttp.internal.http.StatusLine.HTTP_CONTINUE;
 import static com.squareup.okhttp.internal.http.StatusLine.HTTP_PERM_REDIRECT;
 import static com.squareup.okhttp.internal.http.StatusLine.HTTP_TEMP_REDIRECT;
@@ -210,8 +208,15 @@ public HttpEngine(OkHttpClient client, Request request, boolean bufferRequestBod
    * Figures out what the response source will be, and opens a socket to that
    * source if necessary. Prepares the request headers and gets ready to start
    * writing the request body if it exists.
+   *
+   * @throws RequestException if there was a problem with request setup. Unrecoverable.
+   * @throws RouteException if the was a problem during connection via a specific route. Sometimes
+   *     recoverable. See {@link #recover(RouteException)}.
+   * @throws IOException if there was a problem while making a request. Sometimes recoverable. See
+   *     {@link #recover(IOException)}.
+   *
    */
-  public void sendRequest() throws IOException {
+  public void sendRequest() throws RequestException, RouteException, IOException {
     if (cacheStrategy != null) return; // Already sent.
     if (transport != null) throw new IllegalStateException();
 
@@ -308,30 +313,24 @@ private static Response stripBody(Response response) {
   }
 
   /** Connect to the origin server either directly or via a proxy. */
-  private void connect() throws IOException {
+  private void connect() throws RequestException, RouteException {
     if (connection != null) throw new IllegalStateException();
 
     if (routeSelector == null) {
       address = createAddress(client, networkRequest);
-      routeSelector = RouteSelector.get(address, networkRequest, client);
+      try {
+        routeSelector = RouteSelector.get(address, networkRequest, client);
+      } catch (IOException e) {
+        throw new RequestException(e);
+      }
     }
 
-    connection = nextConnection();
-    route = connection.getRoute();
-  }
-
-  /**
-   * Returns the next connection to attempt.
-   *
-   * @throws java.util.NoSuchElementException if there are no more routes to attempt.
-   */
-  private Connection nextConnection() throws IOException {
-    Connection connection = createNextConnection();
+    connection = createNextConnection();
     Internal.instance.connectAndSetOwner(client, connection, this, networkRequest);
-    return connection;
+    route = connection.getRoute();
   }
 
-  private Connection createNextConnection() throws IOException {
+  private Connection createNextConnection() throws RouteException {
     ConnectionPool pool = client.getConnectionPool();
 
     // Always prefer pooled connections over new connections.
@@ -339,10 +338,15 @@ private Connection createNextConnection() throws IOException {
       if (networkRequest.method().equals("GET") || Internal.instance.isReadable(pooled)) {
         return pooled;
       }
-      pooled.getSocket().close();
+      closeQuietly(pooled.getSocket());
+    }
+
+    try {
+      Route route = routeSelector.next();
+      return new Connection(pool, route);
+    } catch (IOException e) {
+      throw new RouteException(e);
     }
-    Route route = routeSelector.next();
-    return new Connection(pool, route);
   }
 
   /**
@@ -393,8 +397,74 @@ public Connection getConnection() {
   }
 
   /**
-   * Report and attempt to recover from {@code e}. Returns a new HTTP engine
-   * that should be used for the retry if {@code e} is recoverable, or null if
+   * Attempt to recover from failure to connect via a route. Returns a new HTTP engine
+   * that should be used for the retry if there are other routes to try, or null if
+   * there are no more routes to try.
+   */
+  public HttpEngine recover(RouteException e) {
+    if (routeSelector != null && connection != null) {
+      connectFailed(routeSelector, e.getLastConnectException());
+    }
+
+    if (routeSelector == null && connection == null // No connection.
+        || routeSelector != null && !routeSelector.hasNext() // No more routes to attempt.
+        || !isRecoverable(e)) {
+      return null;
+    }
+
+    Connection connection = close();
+
+    // For failure recovery, use the same route selector with a new connection.
+    return new HttpEngine(client, userRequest, bufferRequestBody, callerWritesRequestBody,
+        forWebSocket, connection, routeSelector, (RetryableSink) requestBodyOut, priorResponse);
+  }
+
+  private boolean isRecoverable(RouteException e) {
+    // If the application has opted-out of recovery, don't recover.
+    if (!client.getRetryOnConnectionFailure()) {
+      return false;
+    }
+
+    // Problems with a route may mean the connection can be retried with a new route, or may
+    // indicate a client-side or server-side issue that should not be retried. To tell, we must look
+    // at the cause.
+
+    IOException ioe = e.getLastConnectException();
+
+    // If there was a protocol problem, don't recover.
+    if (ioe instanceof ProtocolException) {
+      return false;
+    }
+
+    // If there was an interruption don't recover, but if there was a timeout
+    // we should try the next route (if there is one).
+    if (ioe instanceof InterruptedIOException) {
+      return ioe instanceof SocketTimeoutException;
+    }
+
+    // Look for known client-side or negotiation errors that are unlikely to be fixed by trying
+    // again with a different route.
+    if (ioe instanceof SSLHandshakeException) {
+      // If the problem was a CertificateException from the X509TrustManager,
+      // do not retry.
+      if (ioe.getCause() instanceof CertificateException) {
+        return false;
+      }
+    }
+    if (ioe instanceof SSLPeerUnverifiedException) {
+      // e.g. a certificate pinning error.
+      return false;
+    }
+
+    // An example of one we might want to retry with a different route is a problem connecting to a
+    // proxy and would manifest as a standard IOException. Unless it is one we know we should not
+    // retry, we return true and try a new route.
+    return true;
+  }
+
+  /**
+   * Report and attempt to recover from a failure to communicate with a server. Returns a new
+   * HTTP engine that should be used for the retry if {@code e} is recoverable, or null if
    * the failure is permanent. Requests with a body can only be recovered if the
    * body is buffered.
    */
@@ -435,13 +505,6 @@ private boolean isRecoverable(IOException e) {
       return false;
     }
 
-    // If the problem was a CertificateException from the X509TrustManager,
-    // do not retry, we didn't have an abrupt server-initiated exception.
-    if (e instanceof SSLPeerUnverifiedException
-        || (e instanceof SSLHandshakeException && e.getCause() instanceof CertificateException)) {
-      return false;
-    }
-
     // If there was a protocol problem, don't recover.
     if (e instanceof ProtocolException) {
       return false;
@@ -496,17 +559,25 @@ public void releaseConnection() throws IOException {
   }
 
   /**
-   * Immediately closes the socket connection if it's currently held by this
-   * engine. Use this to interrupt an in-flight request from any thread. It's
-   * the caller's responsibility to close the request body and response body
-   * streams; otherwise resources may be leaked.
+   * Immediately closes the socket connection if it's currently held by this engine. Use this to
+   * interrupt an in-flight request from any thread. It's the caller's responsibility to close the
+   * request body and response body streams; otherwise resources may be leaked.
+   *
+   * <p>This method is safe to be called concurrently, but provides limited guarantees. If a
+   * transport layer connection has been established (such as a HTTP/2 stream) that is terminated.
+   * Otherwise if a socket connection is being established, that is terminated.
    */
   public void disconnect() {
-    if (transport != null) {
-      try {
+    try {
+      if (transport != null) {
         transport.disconnect(this);
-      } catch (IOException ignored) {
+      } else {
+        Connection connection = this.connection;
+        if (connection != null) {
+          Internal.instance.closeIfOwnedBy(connection, this);
+        }
       }
+    } catch (IOException ignored) {
     }
   }
 
@@ -620,7 +691,7 @@ private Request networkRequest(Request request) throws IOException {
     Request.Builder result = request.newBuilder();
 
     if (request.header("Host") == null) {
-      result.header("Host", hostHeader(request.url()));
+      result.header("Host", Util.hostHeader(request.httpUrl()));
     }
 
     if ((connection == null || connection.getProtocol() != Protocol.HTTP_1_0)
@@ -653,12 +724,6 @@ private Request networkRequest(Request request) throws IOException {
     return result.build();
   }
 
-  public static String hostHeader(URL url) {
-    return getEffectivePort(url) != getDefaultPort(url.getProtocol())
-        ? url.getHost() + ":" + url.getPort()
-        : url.getHost();
-  }
-
   /**
    * Flushes the remaining request header and body, parses the HTTP response
    * headers and starts reading the HTTP response body if it exists.
@@ -783,8 +848,8 @@ public void readResponse() throws IOException {
         Address address = connection().getRoute().getAddress();
 
         // Confirm that the interceptor uses the connection we've already prepared.
-        if (!request.url().getHost().equals(address.getUriHost())
-            || getEffectivePort(request.url()) != address.getUriPort()) {
+        if (!request.httpUrl().host().equals(address.getUriHost())
+            || request.httpUrl().port() != address.getUriPort()) {
           throw new IllegalStateException("network interceptor " + caller
               + " must retain the same host and port");
         }
@@ -813,6 +878,9 @@ public void readResponse() throws IOException {
 
       transport.writeRequestHeaders(request);
 
+      //Update the networkRequest with the possibly updated interceptor request.
+      networkRequest = request;
+
       if (permitsRequestBody() && request.body() != null) {
         Sink requestBodyOut = transport.createRequestBody(request, request.body().contentLength());
         BufferedSink bufferedRequestBody = Okio.buffer(requestBodyOut);
@@ -820,7 +888,15 @@ public void readResponse() throws IOException {
         bufferedRequestBody.close();
       }
 
-      return readNetworkResponse();
+      Response response = readNetworkResponse();
+
+      int code = response.code();
+      if ((code == 204 || code == 205) && response.body().contentLength() > 0) {
+        throw new ProtocolException(
+            "HTTP " + code + " had non-zero Content-Length: " + response.body().contentLength());
+      }
+
+      return response;
     }
   }
 
@@ -1006,14 +1082,14 @@ public Request followUpRequest() throws IOException {
 
         String location = userResponse.header("Location");
         if (location == null) return null;
-        URL url = new URL(userRequest.url(), location);
+        HttpUrl url = userRequest.httpUrl().resolve(location);
 
         // Don't follow redirects to unsupported protocols.
-        if (!url.getProtocol().equals("https") && !url.getProtocol().equals("http")) return null;
+        if (url == null) return null;
 
         // If configured, don't follow redirects between SSL and non-SSL.
-        boolean sameProtocol = url.getProtocol().equals(userRequest.url().getProtocol());
-        if (!sameProtocol && !client.getFollowSslRedirects()) return null;
+        boolean sameScheme = url.scheme().equals(userRequest.httpUrl().scheme());
+        if (!sameScheme && !client.getFollowSslRedirects()) return null;
 
         // Redirects don't include a request body.
         Request.Builder requestBuilder = userRequest.newBuilder();
@@ -1042,20 +1118,14 @@ public Request followUpRequest() throws IOException {
    * Returns true if an HTTP request for {@code followUp} can reuse the
    * connection used by this engine.
    */
-  public boolean sameConnection(URL followUp) {
-    URL url = userRequest.url();
-    return url.getHost().equals(followUp.getHost())
-        && getEffectivePort(url) == getEffectivePort(followUp)
-        && url.getProtocol().equals(followUp.getProtocol());
+  public boolean sameConnection(HttpUrl followUp) {
+    HttpUrl url = userRequest.httpUrl();
+    return url.host().equals(followUp.host())
+        && url.port() == followUp.port()
+        && url.scheme().equals(followUp.scheme());
   }
 
-  private static Address createAddress(OkHttpClient client, Request request)
-      throws UnknownHostException {
-    String uriHost = request.url().getHost();
-    if (uriHost == null || uriHost.length() == 0) {
-      throw new UnknownHostException(request.url().toString());
-    }
-
+  private static Address createAddress(OkHttpClient client, Request request) {
     SSLSocketFactory sslSocketFactory = null;
     HostnameVerifier hostnameVerifier = null;
     CertificatePinner certificatePinner = null;
@@ -1065,7 +1135,7 @@ private static Address createAddress(OkHttpClient client, Request request)
       certificatePinner = client.getCertificatePinner();
     }
 
-    return new Address(uriHost, getEffectivePort(request.url()),
+    return new Address(request.httpUrl().host(), request.httpUrl().port(),
         client.getSocketFactory(), sslSocketFactory, hostnameVerifier, certificatePinner,
         client.getAuthenticator(), client.getProxy(), client.getProtocols(),
         client.getConnectionSpecs(), client.getProxySelector());
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/http/OkHeaders.java b/okhttp/src/main/java/com/squareup/okhttp/internal/http/OkHeaders.java
index a39c657efa..c381c47562 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/http/OkHeaders.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/http/OkHeaders.java
@@ -146,16 +146,31 @@ public static boolean varyMatches(
    * be cached.
    */
   public static boolean hasVaryAll(Response response) {
-    return varyFields(response).contains("*");
+    return hasVaryAll(response.headers());
+  }
+
+  /**
+   * Returns true if a Vary header contains an asterisk. Such responses cannot
+   * be cached.
+   */
+  public static boolean hasVaryAll(Headers responseHeaders) {
+    return varyFields(responseHeaders).contains("*");
   }
 
   private static Set<String> varyFields(Response response) {
+    return varyFields(response.headers());
+  }
+
+  /**
+   * Returns the names of the request headers that need to be checked for
+   * equality when caching.
+   */
+  public static Set<String> varyFields(Headers responseHeaders) {
     Set<String> result = Collections.emptySet();
-    Headers headers = response.headers();
-    for (int i = 0, size = headers.size(); i < size; i++) {
-      if (!"Vary".equalsIgnoreCase(headers.name(i))) continue;
+    for (int i = 0, size = responseHeaders.size(); i < size; i++) {
+      if (!"Vary".equalsIgnoreCase(responseHeaders.name(i))) continue;
 
-      String value = headers.value(i);
+      String value = responseHeaders.value(i);
       if (result.isEmpty()) {
         result = new TreeSet<>(String.CASE_INSENSITIVE_ORDER);
       }
@@ -171,13 +186,21 @@ public static boolean hasVaryAll(Response response) {
    * impact the content of response's body.
    */
   public static Headers varyHeaders(Response response) {
-    Set<String> varyFields = varyFields(response);
-    if (varyFields.isEmpty()) return new Headers.Builder().build();
-
     // Use the request headers sent over the network, since that's what the
     // response varies on. Otherwise OkHttp-supplied headers like
     // "Accept-Encoding: gzip" may be lost.
     Headers requestHeaders = response.networkResponse().request().headers();
+    Headers responseHeaders = response.headers();
+    return varyHeaders(requestHeaders, responseHeaders);
+  }
+
+  /**
+   * Returns the subset of the headers in {@code requestHeaders} that
+   * impact the content of response's body.
+   */
+  public static Headers varyHeaders(Headers requestHeaders, Headers responseHeaders) {
+    Set<String> varyFields = varyFields(responseHeaders);
+    if (varyFields.isEmpty()) return new Headers.Builder().build();
 
     Headers.Builder result = new Headers.Builder();
     for (int i = 0, size = requestHeaders.size(); i < size; i++) {
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/http/RequestException.java b/okhttp/src/main/java/com/squareup/okhttp/internal/http/RequestException.java
new file mode 100644
index 0000000000..16893acdfb
--- /dev/null
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/http/RequestException.java
@@ -0,0 +1,34 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.okhttp.internal.http;
+
+import java.io.IOException;
+
+/**
+ * Indicates a problem with interpreting a request. It may indicate there was a problem with the
+ * request itself, or the environment being used to interpret the request (network failure, etc.).
+ */
+public final class RequestException extends Exception {
+
+  public RequestException(IOException cause) {
+    super(cause);
+  }
+
+  @Override
+  public IOException getCause() {
+    return (IOException) super.getCause();
+  }
+}
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/http/RequestLine.java b/okhttp/src/main/java/com/squareup/okhttp/internal/http/RequestLine.java
index f764afd326..d22be27011 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/http/RequestLine.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/http/RequestLine.java
@@ -1,10 +1,10 @@
 package com.squareup.okhttp.internal.http;
 
+import com.squareup.okhttp.HttpUrl;
 import com.squareup.okhttp.Protocol;
 import com.squareup.okhttp.Request;
 import java.net.HttpURLConnection;
 import java.net.Proxy;
-import java.net.URL;
 
 public final class RequestLine {
   private RequestLine() {
@@ -21,9 +21,9 @@ static String get(Request request, Proxy.Type proxyType, Protocol protocol) {
     result.append(' ');
 
     if (includeAuthorityInRequestLine(request, proxyType)) {
-      result.append(request.url());
+      result.append(request.httpUrl());
     } else {
-      result.append(requestPath(request.url()));
+      result.append(requestPath(request.httpUrl()));
     }
 
     result.append(' ');
@@ -44,11 +44,10 @@ private static boolean includeAuthorityInRequestLine(Request request, Proxy.Type
    * Returns the path to request, like the '/' in 'GET / HTTP/1.1'. Never empty,
    * even if the request URL is. Includes the query component if it exists.
    */
-  public static String requestPath(URL url) {
-    String pathAndQuery = url.getFile();
-    if (pathAndQuery == null) return "/";
-    if (!pathAndQuery.startsWith("/")) return "/" + pathAndQuery;
-    return pathAndQuery;
+  public static String requestPath(HttpUrl url) {
+    String path = url.encodedPath();
+    String query = url.encodedQuery();
+    return query != null ? (path + '?' + query) : path;
   }
 
   public static String version(Protocol protocol) {
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/http/RouteException.java b/okhttp/src/main/java/com/squareup/okhttp/internal/http/RouteException.java
new file mode 100644
index 0000000000..62b31751e9
--- /dev/null
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/http/RouteException.java
@@ -0,0 +1,61 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.okhttp.internal.http;
+
+import java.io.IOException;
+import java.lang.reflect.InvocationTargetException;
+import java.lang.reflect.Method;
+
+/**
+ * An exception thrown to indicate a problem connecting via a single Route. Multiple attempts may
+ * have been made with alternative protocols, none of which were successful.
+ */
+public final class RouteException extends Exception {
+  private static final Method addSuppressedExceptionMethod;
+  static {
+    Method m;
+    try {
+      m = Throwable.class.getDeclaredMethod("addSuppressed", Throwable.class);
+    } catch (Exception e) {
+      m = null;
+    }
+    addSuppressedExceptionMethod = m;
+  }
+  private IOException lastException;
+
+  public RouteException(IOException cause) {
+    super(cause);
+    lastException = cause;
+  }
+
+  public IOException getLastConnectException() {
+    return lastException;
+  }
+
+  public void addConnectException(IOException e) {
+    addSuppressedIfPossible(e, lastException);
+    lastException = e;
+  }
+
+  private void addSuppressedIfPossible(IOException e, IOException suppressed) {
+    if (addSuppressedExceptionMethod != null) {
+      try {
+        addSuppressedExceptionMethod.invoke(e, suppressed);
+      } catch (InvocationTargetException | IllegalAccessException ignored) {
+      }
+    }
+  }
+}
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/http/RouteSelector.java b/okhttp/src/main/java/com/squareup/okhttp/internal/http/RouteSelector.java
index db9ae3b6c0..b16bab3fd6 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/http/RouteSelector.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/http/RouteSelector.java
@@ -16,7 +16,7 @@
 package com.squareup.okhttp.internal.http;
 
 import com.squareup.okhttp.Address;
-import com.squareup.okhttp.ConnectionSpec;
+import com.squareup.okhttp.HttpUrl;
 import com.squareup.okhttp.OkHttpClient;
 import com.squareup.okhttp.Request;
 import com.squareup.okhttp.Route;
@@ -29,16 +29,10 @@
 import java.net.Proxy;
 import java.net.SocketAddress;
 import java.net.SocketException;
-import java.net.URI;
-import java.net.UnknownHostException;
 import java.util.ArrayList;
 import java.util.Collections;
 import java.util.List;
 import java.util.NoSuchElementException;
-import javax.net.ssl.SSLHandshakeException;
-import javax.net.ssl.SSLProtocolException;
-
-import static com.squareup.okhttp.internal.Util.getEffectivePort;
 
 /**
  * Selects routes to connect to an origin server. Each connection requires a
@@ -47,16 +41,14 @@
  */
 public final class RouteSelector {
   private final Address address;
-  private final URI uri;
+  private final HttpUrl url;
   private final Network network;
   private final OkHttpClient client;
   private final RouteDatabase routeDatabase;
-  private final Request request;
 
   /* The most recently attempted route. */
   private Proxy lastProxy;
   private InetSocketAddress lastInetSocketAddress;
-  private ConnectionSpec lastSpec;
 
   /* State for negotiating the next proxy to use. */
   private List<Proxy> proxies = Collections.emptyList();
@@ -66,27 +58,22 @@
   private List<InetSocketAddress> inetSocketAddresses = Collections.emptyList();
   private int nextInetSocketAddressIndex;
 
-  /* Specs to attempt with the connection. */
-  private List<ConnectionSpec> connectionSpecs = Collections.emptyList();
-  private int nextSpecIndex;
-
   /* State for negotiating failed routes */
   private final List<Route> postponedRoutes = new ArrayList<>();
 
-  private RouteSelector(Address address, URI uri, OkHttpClient client, Request request) {
+  private RouteSelector(Address address, HttpUrl url, OkHttpClient client) {
     this.address = address;
-    this.uri = uri;
+    this.url = url;
     this.client = client;
     this.routeDatabase = Internal.instance.routeDatabase(client);
     this.network = Internal.instance.network(client);
-    this.request = request;
 
-    resetNextProxy(uri, address.getProxy());
+    resetNextProxy(url, address.getProxy());
   }
 
   public static RouteSelector get(Address address, Request request, OkHttpClient client)
       throws IOException {
-    return new RouteSelector(address, request.uri(), client, request);
+    return new RouteSelector(address, request.httpUrl(), client);
   }
 
   /**
@@ -94,31 +81,25 @@ public static RouteSelector get(Address address, Request request, OkHttpClient c
    * least one route.
    */
   public boolean hasNext() {
-    return hasNextConnectionSpec()
-        || hasNextInetSocketAddress()
+    return hasNextInetSocketAddress()
         || hasNextProxy()
         || hasNextPostponed();
   }
 
   public Route next() throws IOException {
     // Compute the next route to attempt.
-    if (!hasNextConnectionSpec()) {
-      if (!hasNextInetSocketAddress()) {
-        if (!hasNextProxy()) {
-          if (!hasNextPostponed()) {
-            throw new NoSuchElementException();
-          }
-          return nextPostponed();
+    if (!hasNextInetSocketAddress()) {
+      if (!hasNextProxy()) {
+        if (!hasNextPostponed()) {
+          throw new NoSuchElementException();
         }
-        lastProxy = nextProxy();
+        return nextPostponed();
       }
-      lastInetSocketAddress = nextInetSocketAddress();
+      lastProxy = nextProxy();
     }
-    lastSpec = nextConnectionSpec();
+    lastInetSocketAddress = nextInetSocketAddress();
 
-    final boolean shouldSendTlsFallbackIndicator = shouldSendTlsFallbackIndicator(lastSpec);
-    Route route = new Route(address, lastProxy, lastInetSocketAddress, lastSpec,
-        shouldSendTlsFallbackIndicator);
+    Route route = new Route(address, lastProxy, lastInetSocketAddress);
     if (routeDatabase.shouldPostpone(route)) {
       postponedRoutes.add(route);
       // We will only recurse in order to skip previously failed routes. They will be tried last.
@@ -128,11 +109,6 @@ public Route next() throws IOException {
     return route;
   }
 
-  private boolean shouldSendTlsFallbackIndicator(ConnectionSpec connectionSpec) {
-    return connectionSpec != connectionSpecs.get(0)
-        && connectionSpec.isTls();
-  }
-
   /**
    * Clients should invoke this method when they encounter a connectivity
    * failure on a connection returned by this route selector.
@@ -140,28 +116,15 @@ private boolean shouldSendTlsFallbackIndicator(ConnectionSpec connectionSpec) {
   public void connectFailed(Route failedRoute, IOException failure) {
     if (failedRoute.getProxy().type() != Proxy.Type.DIRECT && address.getProxySelector() != null) {
       // Tell the proxy selector when we fail to connect on a fresh connection.
-      address.getProxySelector().connectFailed(uri, failedRoute.getProxy().address(), failure);
+      address.getProxySelector().connectFailed(
+          url.uri(), failedRoute.getProxy().address(), failure);
     }
 
     routeDatabase.failed(failedRoute);
-
-    // If the previously returned route's problem was not related to the connection's spec, and the
-    // next route only changes that, we shouldn't even attempt it. This suppresses it in both this
-    // selector and also in the route database.
-    if (!(failure instanceof SSLHandshakeException) && !(failure instanceof SSLProtocolException)) {
-      while (nextSpecIndex < connectionSpecs.size()) {
-        ConnectionSpec connectionSpec = connectionSpecs.get(nextSpecIndex++);
-        final boolean shouldSendTlsFallbackIndicator =
-            shouldSendTlsFallbackIndicator(connectionSpec);
-        Route toSuppress = new Route(address, lastProxy, lastInetSocketAddress, connectionSpec,
-            shouldSendTlsFallbackIndicator);
-        routeDatabase.failed(toSuppress);
-      }
-    }
   }
 
   /** Prepares the proxy servers to try. */
-  private void resetNextProxy(URI uri, Proxy proxy) {
+  private void resetNextProxy(HttpUrl url, Proxy proxy) {
     if (proxy != null) {
       // If the user specifies a proxy, try that and only that.
       proxies = Collections.singletonList(proxy);
@@ -169,7 +132,7 @@ private void resetNextProxy(URI uri, Proxy proxy) {
       // Try each of the ProxySelector choices until one connection succeeds. If none succeed
       // then we'll try a direct connection below.
       proxies = new ArrayList<>();
-      List<Proxy> selectedProxies = client.getProxySelector().select(uri);
+      List<Proxy> selectedProxies = client.getProxySelector().select(url.uri());
       if (selectedProxies != null) proxies.addAll(selectedProxies);
       // Finally try a direct connection. We only try it once!
       proxies.removeAll(Collections.singleton(Proxy.NO_PROXY));
@@ -195,7 +158,7 @@ private Proxy nextProxy() throws IOException {
   }
 
   /** Prepares the socket addresses to attempt for the current proxy or host. */
-  private void resetNextInetSocketAddress(Proxy proxy) throws UnknownHostException {
+  private void resetNextInetSocketAddress(Proxy proxy) throws IOException {
     // Clear the addresses. Necessary if getAllByName() below throws!
     inetSocketAddresses = new ArrayList<>();
 
@@ -203,7 +166,7 @@ private void resetNextInetSocketAddress(Proxy proxy) throws UnknownHostException
     int socketPort;
     if (proxy.type() == Proxy.Type.DIRECT || proxy.type() == Proxy.Type.SOCKS) {
       socketHost = address.getUriHost();
-      socketPort = getEffectivePort(uri);
+      socketPort = address.getUriPort();
     } else {
       SocketAddress proxyAddress = proxy.address();
       if (!(proxyAddress instanceof InetSocketAddress)) {
@@ -215,10 +178,16 @@ private void resetNextInetSocketAddress(Proxy proxy) throws UnknownHostException
       socketPort = proxySocketAddress.getPort();
     }
 
+    if (socketPort < 1 || socketPort > 65535) {
+      throw new SocketException("No route to " + socketHost + ":" + socketPort
+          + "; port is out of range");
+    }
+
     // Try each address for best behavior in mixed IPv4/IPv6 environments.
     for (InetAddress inetAddress : network.resolveInetAddresses(socketHost)) {
       inetSocketAddresses.add(new InetSocketAddress(inetAddress, socketPort));
     }
+
     nextInetSocketAddressIndex = 0;
   }
 
@@ -251,36 +220,7 @@ private InetSocketAddress nextInetSocketAddress() throws IOException {
       throw new SocketException("No route to " + address.getUriHost()
           + "; exhausted inet socket addresses: " + inetSocketAddresses);
     }
-    InetSocketAddress result = inetSocketAddresses.get(nextInetSocketAddressIndex++);
-    resetConnectionSpecs();
-    return result;
-  }
-
-  /** Prepares the connection specs to attempt. */
-  private void resetConnectionSpecs() {
-    connectionSpecs = new ArrayList<>();
-    List<ConnectionSpec> specs = address.getConnectionSpecs();
-    for (int i = 0, size = specs.size(); i < size; i++) {
-      ConnectionSpec spec = specs.get(i);
-      if (request.isHttps() == spec.isTls()) {
-        connectionSpecs.add(spec);
-      }
-    }
-    nextSpecIndex = 0;
-  }
-
-  /** Returns true if there's another connection spec to try. */
-  private boolean hasNextConnectionSpec() {
-    return nextSpecIndex < connectionSpecs.size();
-  }
-
-  /** Returns the next connection spec to try. */
-  private ConnectionSpec nextConnectionSpec() throws IOException {
-    if (!hasNextConnectionSpec()) {
-      throw new SocketException("No route to " + address.getUriHost()
-          + "; exhausted connection specs: " + connectionSpecs);
-    }
-    return connectionSpecs.get(nextSpecIndex++);
+    return inetSocketAddresses.get(nextInetSocketAddressIndex++);
   }
 
   /** Returns true if there is another postponed route to try. */
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/io/FileSystem.java b/okhttp/src/main/java/com/squareup/okhttp/internal/io/FileSystem.java
new file mode 100644
index 0000000000..74245997a5
--- /dev/null
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/io/FileSystem.java
@@ -0,0 +1,137 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.okhttp.internal.io;
+
+import java.io.File;
+import java.io.FileNotFoundException;
+import java.io.IOException;
+import okio.Okio;
+import okio.Sink;
+import okio.Source;
+
+/**
+ * Access to read and write files on a hierarchical data store. Most callers should use the {@link
+ * #SYSTEM} implementation, which uses the host machine's local file system. Alternate
+ * implementations may be used to inject faults (for testing) or to transform stored data (to add
+ * encryption, for example).
+ *
+ * <p>All operations on a file system are racy. For example, guarding a call to {@link #source}
+ * with {@link #exists} does not guarantee that {@link FileNotFoundException} will not be thrown.
+ * The file may be moved between the two calls!
+ *
+ * <p>This interface is less ambitious than {@link java.nio.file.FileSystem} introduced in Java 7.
+ * It lacks important features like file watching, metadata, permissions, and disk space
+ * information. In exchange for these limitations, this interface is easier to implement and works
+ * on all versions of Java and Android.
+ */
+public interface FileSystem {
+  /** The host machine's local file system. */
+  FileSystem SYSTEM = new FileSystem() {
+    @Override public Source source(File file) throws FileNotFoundException {
+      return Okio.source(file);
+    }
+
+    @Override public Sink sink(File file) throws FileNotFoundException {
+      try {
+        return Okio.sink(file);
+      } catch (FileNotFoundException e) {
+        // Maybe the parent directory doesn't exist? Try creating it first.
+        file.getParentFile().mkdirs();
+        return Okio.sink(file);
+      }
+    }
+
+    @Override public Sink appendingSink(File file) throws FileNotFoundException {
+      try {
+        return Okio.appendingSink(file);
+      } catch (FileNotFoundException e) {
+        // Maybe the parent directory doesn't exist? Try creating it first.
+        file.getParentFile().mkdirs();
+        return Okio.appendingSink(file);
+      }
+    }
+
+    @Override public void delete(File file) throws IOException {
+      // If delete() fails, make sure it's because the file didn't exist!
+      if (!file.delete() && file.exists()) {
+        throw new IOException("failed to delete " + file);
+      }
+    }
+
+    @Override public boolean exists(File file) throws IOException {
+      return file.exists();
+    }
+
+    @Override public long size(File file) {
+      return file.length();
+    }
+
+    @Override public void rename(File from, File to) throws IOException {
+      delete(to);
+      if (!from.renameTo(to)) {
+        throw new IOException("failed to rename " + from + " to " + to);
+      }
+    }
+
+    @Override public void deleteContents(File directory) throws IOException {
+      File[] files = directory.listFiles();
+      if (files == null) {
+        throw new IOException("not a readable directory: " + directory);
+      }
+      for (File file : files) {
+        if (file.isDirectory()) {
+          deleteContents(file);
+        }
+        if (!file.delete()) {
+          throw new IOException("failed to delete " + file);
+        }
+      }
+    }
+  };
+
+  /** Reads from {@code file}. */
+  Source source(File file) throws FileNotFoundException;
+
+  /**
+   * Writes to {@code file}, discarding any data already present. Creates parent directories if
+   * necessary.
+   */
+  Sink sink(File file) throws FileNotFoundException;
+
+  /**
+   * Writes to {@code file}, appending if data is already present. Creates parent directories if
+   * necessary.
+   */
+  Sink appendingSink(File file) throws FileNotFoundException;
+
+  /** Deletes {@code file} if it exists. Throws if the file exists and cannot be deleted. */
+  void delete(File file) throws IOException;
+
+  /** Returns true if {@code file} exists on the file system. */
+  boolean exists(File file) throws IOException;
+
+  /** Returns the number of bytes stored in {@code file}, or 0 if it does not exist. */
+  long size(File file);
+
+  /** Renames {@code from} to {@code to}. Throws if the file cannot be renamed. */
+  void rename(File from, File to) throws IOException;
+
+  /**
+   * Recursively delete the contents of {@code directory}. Throws an IOException if any file could
+   * not be deleted, or if {@code dir} is not a readable directory.
+   */
+  void deleteContents(File directory) throws IOException;
+}
diff --git a/pom.xml b/pom.xml
index 884718b481..7219018974 100644
--- a/pom.xml
+++ b/pom.xml
@@ -11,7 +11,7 @@
 
   <groupId>com.squareup.okhttp</groupId>
   <artifactId>parent</artifactId>
-  <version>2.3.0-SNAPSHOT</version>
+  <version>2.6.0-SNAPSHOT</version>
   <packaging>pom</packaging>
 
   <name>OkHttp (Parent)</name>
@@ -20,10 +20,17 @@
 
   <modules>
     <module>okhttp</module>
-    <module>okhttp-apache</module>
     <module>okhttp-tests</module>
-    <module>okhttp-urlconnection</module>
+
     <module>okhttp-android-support</module>
+
+    <module>okhttp-apache</module>
+    <module>okhttp-testing-support</module>
+    <module>okhttp-urlconnection</module>
+
+    <module>okhttp-ws</module>
+    <module>okhttp-ws-tests</module>
+
     <module>okcurl</module>
     <module>mockwebserver</module>
     <module>samples</module>
@@ -35,7 +42,7 @@
 
     <!-- Compilation -->
     <java.version>1.7</java.version>
-    <okio.version>1.2.0</okio.version>
+    <okio.version>1.6.0</okio.version>
     <!-- ALPN library targeted to Java 7 -->
     <alpn.jdk7.version>7.1.2.v20141202</alpn.jdk7.version>
     <!-- ALPN library targeted to Java 8 update 25. -->
@@ -126,6 +133,19 @@
           <groupId>org.apache.maven.plugins</groupId>
           <artifactId>maven-surefire-plugin</artifactId>
           <version>2.17</version>
+          <configuration>
+            <properties>
+              <!--
+                Configure a listener for enforcing that no uncaught exceptions issue from OkHttp
+                tests. Every test must have a <scope>test</scope> dependency on
+                okhttp-testing-support.
+                -->
+              <property>
+                <name>listener</name>
+                <value>com.squareup.okhttp.testing.InstallUncaughtExceptionHandlerListener</value>
+              </property>
+            </properties>
+          </configuration>
           <dependencies>
             <dependency>
               <groupId>org.apache.maven.surefire</groupId>
diff --git a/samples/crawler/pom.xml b/samples/crawler/pom.xml
index 2be2bab302..aebd0eb2e4 100644
--- a/samples/crawler/pom.xml
+++ b/samples/crawler/pom.xml
@@ -6,7 +6,7 @@
   <parent>
     <groupId>com.squareup.okhttp.sample</groupId>
     <artifactId>sample-parent</artifactId>
-    <version>2.3.0-SNAPSHOT</version>
+    <version>2.6.0-SNAPSHOT</version>
   </parent>
 
   <artifactId>crawler</artifactId>
diff --git a/samples/crawler/src/main/java/com/squareup/okhttp/sample/Crawler.java b/samples/crawler/src/main/java/com/squareup/okhttp/sample/Crawler.java
index 24383fe47e..8c731bebac 100644
--- a/samples/crawler/src/main/java/com/squareup/okhttp/sample/Crawler.java
+++ b/samples/crawler/src/main/java/com/squareup/okhttp/sample/Crawler.java
@@ -16,19 +16,21 @@
 package com.squareup.okhttp.sample;
 
 import com.squareup.okhttp.Cache;
+import com.squareup.okhttp.HttpUrl;
 import com.squareup.okhttp.OkHttpClient;
 import com.squareup.okhttp.Request;
 import com.squareup.okhttp.Response;
+import com.squareup.okhttp.internal.NamedRunnable;
 import java.io.File;
 import java.io.IOException;
-import java.net.MalformedURLException;
-import java.net.URL;
 import java.util.Collections;
 import java.util.LinkedHashSet;
 import java.util.Set;
+import java.util.concurrent.ConcurrentHashMap;
 import java.util.concurrent.ExecutorService;
 import java.util.concurrent.Executors;
 import java.util.concurrent.LinkedBlockingQueue;
+import java.util.concurrent.atomic.AtomicInteger;
 import org.jsoup.Jsoup;
 import org.jsoup.nodes.Document;
 import org.jsoup.nodes.Element;
@@ -38,8 +40,10 @@
  */
 public final class Crawler {
   private final OkHttpClient client;
-  private final Set<URL> fetchedUrls = Collections.synchronizedSet(new LinkedHashSet<URL>());
-  private final LinkedBlockingQueue<URL> queue = new LinkedBlockingQueue<>();
+  private final Set<HttpUrl> fetchedUrls = Collections.synchronizedSet(
+      new LinkedHashSet<HttpUrl>());
+  private final LinkedBlockingQueue<HttpUrl> queue = new LinkedBlockingQueue<>();
+  private final ConcurrentHashMap<String, AtomicInteger> hostnames = new ConcurrentHashMap<>();
 
   public Crawler(OkHttpClient client) {
     this.client = client;
@@ -48,8 +52,8 @@ public Crawler(OkHttpClient client) {
   private void parallelDrainQueue(int threadCount) {
     ExecutorService executor = Executors.newFixedThreadPool(threadCount);
     for (int i = 0; i < threadCount; i++) {
-      executor.execute(new Runnable() {
-        @Override public void run() {
+      executor.execute(new NamedRunnable("Crawler %s", i) {
+        @Override protected void execute() {
           try {
             drainQueue();
           } catch (Exception e) {
@@ -62,7 +66,7 @@ private void parallelDrainQueue(int threadCount) {
   }
 
   private void drainQueue() throws Exception {
-    for (URL url; (url = queue.take()) != null; ) {
+    for (HttpUrl url; (url = queue.take()) != null; ) {
       if (!fetchedUrls.add(url)) {
         continue;
       }
@@ -75,13 +79,19 @@ private void drainQueue() throws Exception {
     }
   }
 
-  public void fetch(URL url) throws IOException {
+  public void fetch(HttpUrl url) throws IOException {
+    // Skip hosts that we've visited many times.
+    AtomicInteger hostnameCount = new AtomicInteger();
+    AtomicInteger previous = hostnames.putIfAbsent(url.host(), hostnameCount);
+    if (previous != null) hostnameCount = previous;
+    if (hostnameCount.incrementAndGet() > 100) return;
+
     Request request = new Request.Builder()
         .url(url)
         .build();
     Response response = client.newCall(request).execute();
     String responseSource = response.networkResponse() != null
-        ? ("(network: " + response.networkResponse().code() + ")")
+        ? ("(network: " + response.networkResponse().code() + " over " + response.protocol() + ")")
         : "(cache)";
     int responseCode = response.code();
 
@@ -96,22 +106,11 @@ public void fetch(URL url) throws IOException {
     Document document = Jsoup.parse(response.body().string(), url.toString());
     for (Element element : document.select("a[href]")) {
       String href = element.attr("href");
-      URL link = parseUrl(url, href);
+      HttpUrl link = response.request().httpUrl().resolve(href);
       if (link != null) queue.add(link);
     }
   }
 
-  private URL parseUrl(URL url, String href) {
-    try {
-      URL result = new URL(url, href);
-      return result.getProtocol().equals("http") || result.getProtocol().equals("https")
-          ? result
-          : null;
-    } catch (MalformedURLException e) {
-      return null;
-    }
-  }
-
   public static void main(String[] args) throws IOException {
     if (args.length != 2) {
       System.out.println("Usage: Crawler <cache dir> <root>");
@@ -126,7 +125,7 @@ public static void main(String[] args) throws IOException {
     client.setCache(cache);
 
     Crawler crawler = new Crawler(client);
-    crawler.queue.add(new URL(args[1]));
+    crawler.queue.add(HttpUrl.parse(args[1]));
     crawler.parallelDrainQueue(threadCount);
   }
 }
diff --git a/samples/guide/pom.xml b/samples/guide/pom.xml
index 1cc1b6a5ee..55e2671c29 100644
--- a/samples/guide/pom.xml
+++ b/samples/guide/pom.xml
@@ -6,7 +6,7 @@
   <parent>
     <groupId>com.squareup.okhttp.sample</groupId>
     <artifactId>sample-parent</artifactId>
-    <version>2.3.0-SNAPSHOT</version>
+    <version>2.6.0-SNAPSHOT</version>
   </parent>
 
   <artifactId>guide</artifactId>
@@ -18,6 +18,11 @@
       <artifactId>okhttp</artifactId>
       <version>${project.version}</version>
     </dependency>
+    <dependency>
+      <groupId>com.squareup.okhttp</groupId>
+      <artifactId>okhttp-ws</artifactId>
+      <version>${project.version}</version>
+    </dependency>
     <dependency>
       <groupId>com.google.code.gson</groupId>
       <artifactId>gson</artifactId>
diff --git a/samples/guide/src/main/java/com/squareup/okhttp/recipes/CustomTrust.java b/samples/guide/src/main/java/com/squareup/okhttp/recipes/CustomTrust.java
new file mode 100644
index 0000000000..f99dc627a9
--- /dev/null
+++ b/samples/guide/src/main/java/com/squareup/okhttp/recipes/CustomTrust.java
@@ -0,0 +1,206 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.okhttp.recipes;
+
+import com.squareup.okhttp.CertificatePinner;
+import com.squareup.okhttp.Headers;
+import com.squareup.okhttp.OkHttpClient;
+import com.squareup.okhttp.Request;
+import com.squareup.okhttp.Response;
+import java.io.IOException;
+import java.io.InputStream;
+import java.security.GeneralSecurityException;
+import java.security.KeyStore;
+import java.security.SecureRandom;
+import java.security.cert.Certificate;
+import java.security.cert.CertificateFactory;
+import java.util.Collection;
+import javax.net.ssl.KeyManagerFactory;
+import javax.net.ssl.SSLContext;
+import javax.net.ssl.TrustManagerFactory;
+import okio.Buffer;
+
+public final class CustomTrust {
+  private final OkHttpClient client;
+
+  public CustomTrust() {
+    client = new OkHttpClient();
+    SSLContext sslContext = sslContextForTrustedCertificates(trustedCertificatesInputStream());
+    client.setSslSocketFactory(sslContext.getSocketFactory());
+  }
+
+  public void run() throws Exception {
+    Request request = new Request.Builder()
+        .url("https://publicobject.com/helloworld.txt")
+        .build();
+
+    Response response = client.newCall(request).execute();
+    if (!response.isSuccessful()) throw new IOException("Unexpected code " + response);
+
+    Headers responseHeaders = response.headers();
+    for (int i = 0; i < responseHeaders.size(); i++) {
+      System.out.println(responseHeaders.name(i) + ": " + responseHeaders.value(i));
+    }
+
+    System.out.println(response.body().string());
+  }
+
+  /**
+   * Returns an input stream containing one or more certificate PEM files. This implementation just
+   * embeds the PEM files in Java strings; most applications will instead read this from a resource
+   * file that gets bundled with the application.
+   */
+  private InputStream trustedCertificatesInputStream() {
+    // PEM files for root certificates of Comodo and Entrust. These two CAs are sufficient to view
+    // https://publicobject.com (Comodo) and https://squareup.com (Entrust). But they aren't
+    // sufficient to connect to most HTTPS sites including https://godaddy.com and https://visa.com.
+    // Typically developers will need to get a PEM file from their organization's TLS administrator.
+    String comodoRsaCertificationAuthority = ""
+        + "-----BEGIN CERTIFICATE-----\n"
+        + "MIIF2DCCA8CgAwIBAgIQTKr5yttjb+Af907YWwOGnTANBgkqhkiG9w0BAQwFADCB\n"
+        + "hTELMAkGA1UEBhMCR0IxGzAZBgNVBAgTEkdyZWF0ZXIgTWFuY2hlc3RlcjEQMA4G\n"
+        + "A1UEBxMHU2FsZm9yZDEaMBgGA1UEChMRQ09NT0RPIENBIExpbWl0ZWQxKzApBgNV\n"
+        + "BAMTIkNPTU9ETyBSU0EgQ2VydGlmaWNhdGlvbiBBdXRob3JpdHkwHhcNMTAwMTE5\n"
+        + "MDAwMDAwWhcNMzgwMTE4MjM1OTU5WjCBhTELMAkGA1UEBhMCR0IxGzAZBgNVBAgT\n"
+        + "EkdyZWF0ZXIgTWFuY2hlc3RlcjEQMA4GA1UEBxMHU2FsZm9yZDEaMBgGA1UEChMR\n"
+        + "Q09NT0RPIENBIExpbWl0ZWQxKzApBgNVBAMTIkNPTU9ETyBSU0EgQ2VydGlmaWNh\n"
+        + "dGlvbiBBdXRob3JpdHkwggIiMA0GCSqGSIb3DQEBAQUAA4ICDwAwggIKAoICAQCR\n"
+        + "6FSS0gpWsawNJN3Fz0RndJkrN6N9I3AAcbxT38T6KhKPS38QVr2fcHK3YX/JSw8X\n"
+        + "pz3jsARh7v8Rl8f0hj4K+j5c+ZPmNHrZFGvnnLOFoIJ6dq9xkNfs/Q36nGz637CC\n"
+        + "9BR++b7Epi9Pf5l/tfxnQ3K9DADWietrLNPtj5gcFKt+5eNu/Nio5JIk2kNrYrhV\n"
+        + "/erBvGy2i/MOjZrkm2xpmfh4SDBF1a3hDTxFYPwyllEnvGfDyi62a+pGx8cgoLEf\n"
+        + "Zd5ICLqkTqnyg0Y3hOvozIFIQ2dOciqbXL1MGyiKXCJ7tKuY2e7gUYPDCUZObT6Z\n"
+        + "+pUX2nwzV0E8jVHtC7ZcryxjGt9XyD+86V3Em69FmeKjWiS0uqlWPc9vqv9JWL7w\n"
+        + "qP/0uK3pN/u6uPQLOvnoQ0IeidiEyxPx2bvhiWC4jChWrBQdnArncevPDt09qZah\n"
+        + "SL0896+1DSJMwBGB7FY79tOi4lu3sgQiUpWAk2nojkxl8ZEDLXB0AuqLZxUpaVIC\n"
+        + "u9ffUGpVRr+goyhhf3DQw6KqLCGqR84onAZFdr+CGCe01a60y1Dma/RMhnEw6abf\n"
+        + "Fobg2P9A3fvQQoh/ozM6LlweQRGBY84YcWsr7KaKtzFcOmpH4MN5WdYgGq/yapiq\n"
+        + "crxXStJLnbsQ/LBMQeXtHT1eKJ2czL+zUdqnR+WEUwIDAQABo0IwQDAdBgNVHQ4E\n"
+        + "FgQUu69+Aj36pvE8hI6t7jiY7NkyMtQwDgYDVR0PAQH/BAQDAgEGMA8GA1UdEwEB\n"
+        + "/wQFMAMBAf8wDQYJKoZIhvcNAQEMBQADggIBAArx1UaEt65Ru2yyTUEUAJNMnMvl\n"
+        + "wFTPoCWOAvn9sKIN9SCYPBMtrFaisNZ+EZLpLrqeLppysb0ZRGxhNaKatBYSaVqM\n"
+        + "4dc+pBroLwP0rmEdEBsqpIt6xf4FpuHA1sj+nq6PK7o9mfjYcwlYRm6mnPTXJ9OV\n"
+        + "2jeDchzTc+CiR5kDOF3VSXkAKRzH7JsgHAckaVd4sjn8OoSgtZx8jb8uk2Intzna\n"
+        + "FxiuvTwJaP+EmzzV1gsD41eeFPfR60/IvYcjt7ZJQ3mFXLrrkguhxuhoqEwWsRqZ\n"
+        + "CuhTLJK7oQkYdQxlqHvLI7cawiiFwxv/0Cti76R7CZGYZ4wUAc1oBmpjIXUDgIiK\n"
+        + "boHGhfKppC3n9KUkEEeDys30jXlYsQab5xoq2Z0B15R97QNKyvDb6KkBPvVWmcke\n"
+        + "jkk9u+UJueBPSZI9FoJAzMxZxuY67RIuaTxslbH9qh17f4a+Hg4yRvv7E491f0yL\n"
+        + "S0Zj/gA0QHDBw7mh3aZw4gSzQbzpgJHqZJx64SIDqZxubw5lT2yHh17zbqD5daWb\n"
+        + "QOhTsiedSrnAdyGN/4fy3ryM7xfft0kL0fJuMAsaDk527RH89elWsn2/x20Kk4yl\n"
+        + "0MC2Hb46TpSi125sC8KKfPog88Tk5c0NqMuRkrF8hey1FGlmDoLnzc7ILaZRfyHB\n"
+        + "NVOFBkpdn627G190\n"
+        + "-----END CERTIFICATE-----\n";
+    String entrustRootCertificateAuthority = ""
+        + "-----BEGIN CERTIFICATE-----\n"
+        + "MIIEkTCCA3mgAwIBAgIERWtQVDANBgkqhkiG9w0BAQUFADCBsDELMAkGA1UEBhMC\n"
+        + "VVMxFjAUBgNVBAoTDUVudHJ1c3QsIEluYy4xOTA3BgNVBAsTMHd3dy5lbnRydXN0\n"
+        + "Lm5ldC9DUFMgaXMgaW5jb3Jwb3JhdGVkIGJ5IHJlZmVyZW5jZTEfMB0GA1UECxMW\n"
+        + "KGMpIDIwMDYgRW50cnVzdCwgSW5jLjEtMCsGA1UEAxMkRW50cnVzdCBSb290IENl\n"
+        + "cnRpZmljYXRpb24gQXV0aG9yaXR5MB4XDTA2MTEyNzIwMjM0MloXDTI2MTEyNzIw\n"
+        + "NTM0MlowgbAxCzAJBgNVBAYTAlVTMRYwFAYDVQQKEw1FbnRydXN0LCBJbmMuMTkw\n"
+        + "NwYDVQQLEzB3d3cuZW50cnVzdC5uZXQvQ1BTIGlzIGluY29ycG9yYXRlZCBieSBy\n"
+        + "ZWZlcmVuY2UxHzAdBgNVBAsTFihjKSAyMDA2IEVudHJ1c3QsIEluYy4xLTArBgNV\n"
+        + "BAMTJEVudHJ1c3QgUm9vdCBDZXJ0aWZpY2F0aW9uIEF1dGhvcml0eTCCASIwDQYJ\n"
+        + "KoZIhvcNAQEBBQADggEPADCCAQoCggEBALaVtkNC+sZtKm9I35RMOVcF7sN5EUFo\n"
+        + "Nu3s/poBj6E4KPz3EEZmLk0eGrEaTsbRwJWIsMn/MYszA9u3g3s+IIRe7bJWKKf4\n"
+        + "4LlAcTfFy0cOlypowCKVYhXbR9n10Cv/gkvJrT7eTNuQgFA/CYqEAOwwCj0Yzfv9\n"
+        + "KlmaI5UXLEWeH25DeW0MXJj+SKfFI0dcXv1u5x609mhF0YaDW6KKjbHjKYD+JXGI\n"
+        + "rb68j6xSlkuqUY3kEzEZ6E5Nn9uss2rVvDlUccp6en+Q3X0dgNmBu1kmwhH+5pPi\n"
+        + "94DkZfs0Nw4pgHBNrziGLp5/V6+eF67rHMsoIV+2HNjnogQi+dPa2MsCAwEAAaOB\n"
+        + "sDCBrTAOBgNVHQ8BAf8EBAMCAQYwDwYDVR0TAQH/BAUwAwEB/zArBgNVHRAEJDAi\n"
+        + "gA8yMDA2MTEyNzIwMjM0MlqBDzIwMjYxMTI3MjA1MzQyWjAfBgNVHSMEGDAWgBRo\n"
+        + "kORnpKZTgMeGZqTx90tD+4S9bTAdBgNVHQ4EFgQUaJDkZ6SmU4DHhmak8fdLQ/uE\n"
+        + "vW0wHQYJKoZIhvZ9B0EABBAwDhsIVjcuMTo0LjADAgSQMA0GCSqGSIb3DQEBBQUA\n"
+        + "A4IBAQCT1DCw1wMgKtD5Y+iRDAUgqV8ZyntyTtSx29CW+1RaGSwMCPeyvIWonX9t\n"
+        + "O1KzKtvn1ISMY/YPyyYBkVBs9F8U4pN0wBOeMDpQ47RgxRzwIkSNcUesyBrJ6Zua\n"
+        + "AGAT/3B+XxFNSRuzFVJ7yVTav52Vr2ua2J7p8eRDjeIRRDq/r72DQnNSi6q7pynP\n"
+        + "9WQcCk3RvKqsnyrQ/39/2n3qse0wJcGE2jTSW3iDVuycNsMm4hH2Z0kdkquM++v/\n"
+        + "eu6FSqdQgPCnXEqULl8FmTxSQeDNtGPPAUO6nIPcj2A781q0tHuu2guQOHXvgR1m\n"
+        + "0vdXcDazv/wor3ElhVsT/h5/WrQ8\n"
+        + "-----END CERTIFICATE-----\n";
+    return new Buffer()
+        .writeUtf8(comodoRsaCertificationAuthority)
+        .writeUtf8(entrustRootCertificateAuthority)
+        .inputStream();
+  }
+
+  /**
+   * Returns a SSL context that trusts {@code certificates} and none other. HTTPS services whose
+   * certificates have not been signed by these certificates will fail with a {@code
+   * SSLHandshakeException}.
+   *
+   * <p>This can be used to replace the host platform's built-in trusted certificates with a custom
+   * set. This is useful in development where certificate authority-trusted certificates aren't
+   * available. Or in production, to avoid reliance on third-party certificate authorities.
+   *
+   * <p>See also {@link CertificatePinner}, which can limit trusted certificates while still using
+   * the host platform's built-in trust store.
+   *
+   * <h3>Warning: Customizing Trusted Certificates is Dangerous!</h3>
+   * Relying on your own trusted certificates limits your server team's ability to update their TLS
+   * certificates. By installing a specific set of trusted certificates, you take on additional
+   * operational complexity and limit your ability to migrate between certificate authorities. Do
+   * not use custom trusted certificates in production without the blessing of your server's TLS
+   * administrator.
+   */
+  public SSLContext sslContextForTrustedCertificates(InputStream in) {
+    try {
+      CertificateFactory certificateFactory = CertificateFactory.getInstance("X.509");
+      Collection<? extends Certificate> certificates = certificateFactory.generateCertificates(in);
+      if (certificates.isEmpty()) {
+        throw new IllegalArgumentException("expected non-empty set of trusted certificates");
+      }
+
+      // Put the certificates a key store.
+      char[] password = "password".toCharArray(); // Any password will work.
+      KeyStore keyStore = newEmptyKeyStore(password);
+      int index = 0;
+      for (Certificate certificate : certificates) {
+        String certificateAlias = Integer.toString(index++);
+        keyStore.setCertificateEntry(certificateAlias, certificate);
+      }
+
+      // Wrap it up in an SSL context.
+      KeyManagerFactory keyManagerFactory = KeyManagerFactory.getInstance(
+          KeyManagerFactory.getDefaultAlgorithm());
+      keyManagerFactory.init(keyStore, password);
+      TrustManagerFactory trustManagerFactory = TrustManagerFactory.getInstance(
+          TrustManagerFactory.getDefaultAlgorithm());
+      trustManagerFactory.init(keyStore);
+      SSLContext sslContext = SSLContext.getInstance("TLS");
+      sslContext.init(keyManagerFactory.getKeyManagers(), trustManagerFactory.getTrustManagers(),
+          new SecureRandom());
+      return sslContext;
+    } catch (GeneralSecurityException e) {
+      throw new RuntimeException(e);
+    }
+  }
+
+  private KeyStore newEmptyKeyStore(char[] password) throws GeneralSecurityException {
+    try {
+      KeyStore keyStore = KeyStore.getInstance(KeyStore.getDefaultType());
+      InputStream in = null; // By convention, 'null' creates an empty key store.
+      keyStore.load(in, password);
+      return keyStore;
+    } catch (IOException e) {
+      throw new AssertionError(e);
+    }
+  }
+
+  public static void main(String... args) throws Exception {
+    new CustomTrust().run();
+  }
+}
diff --git a/samples/guide/src/main/java/com/squareup/okhttp/recipes/LoggingInterceptors.java b/samples/guide/src/main/java/com/squareup/okhttp/recipes/LoggingInterceptors.java
index d70f1070a2..bcfa6e9aa9 100644
--- a/samples/guide/src/main/java/com/squareup/okhttp/recipes/LoggingInterceptors.java
+++ b/samples/guide/src/main/java/com/squareup/okhttp/recipes/LoggingInterceptors.java
@@ -32,12 +32,12 @@ public LoggingInterceptors() {
         long t1 = System.nanoTime();
         Request request = chain.request();
         logger.info(String.format("Sending request %s on %s%n%s",
-            request.url(), chain.connection(), request.headers()));
+            request.httpUrl(), chain.connection(), request.headers()));
         Response response = chain.proceed(request);
 
         long t2 = System.nanoTime();
         logger.info(String.format("Received response for %s in %.1fms%n%s",
-            request.url(), (t2 - t1) / 1e6d, response.headers()));
+            request.httpUrl(), (t2 - t1) / 1e6d, response.headers()));
         return response;
       }
     });
diff --git a/samples/guide/src/main/java/com/squareup/okhttp/recipes/Progress.java b/samples/guide/src/main/java/com/squareup/okhttp/recipes/Progress.java
new file mode 100644
index 0000000000..9d329fa16e
--- /dev/null
+++ b/samples/guide/src/main/java/com/squareup/okhttp/recipes/Progress.java
@@ -0,0 +1,111 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.okhttp.recipes;
+
+import com.squareup.okhttp.Interceptor;
+import com.squareup.okhttp.MediaType;
+import com.squareup.okhttp.OkHttpClient;
+import com.squareup.okhttp.Response;
+import com.squareup.okhttp.ResponseBody;
+import com.squareup.okhttp.Request;
+import java.io.IOException;
+import okio.Buffer;
+import okio.BufferedSource;
+import okio.ForwardingSource;
+import okio.Okio;
+import okio.Source;
+
+public final class Progress {
+
+  private final OkHttpClient client = new OkHttpClient();
+
+  public void run() throws Exception {
+    Request request = new Request.Builder()
+        .url("https://publicobject.com/helloworld.txt")
+        .build();
+
+    final ProgressListener progressListener = new ProgressListener() {
+      @Override public void update(long bytesRead, long contentLength, boolean done) {
+        System.out.println(bytesRead);
+        System.out.println(contentLength);
+        System.out.println(done);
+        System.out.format("%d%% done\n", (100 * bytesRead) / contentLength);
+      }
+    };
+
+    client.networkInterceptors().add(new Interceptor() {
+      @Override public Response intercept(Chain chain) throws IOException {
+        Response originalResponse = chain.proceed(chain.request());
+        return originalResponse.newBuilder()
+            .body(new ProgressResponseBody(originalResponse.body(), progressListener))
+            .build();
+        }
+    });
+
+    Response response = client.newCall(request).execute();
+    if (!response.isSuccessful()) throw new IOException("Unexpected code " + response);
+
+    System.out.println(response.body().string());
+  }
+
+  public static void main(String... args) throws Exception {
+    new Progress().run();
+  }
+
+  private static class ProgressResponseBody extends ResponseBody {
+
+    private final ResponseBody responseBody;
+    private final ProgressListener progressListener;
+    private BufferedSource bufferedSource;
+
+    public ProgressResponseBody(ResponseBody responseBody, ProgressListener progressListener) {
+      this.responseBody = responseBody;
+      this.progressListener = progressListener;
+    }
+
+    @Override public MediaType contentType() {
+      return responseBody.contentType();
+    }
+
+    @Override public long contentLength() throws IOException {
+      return responseBody.contentLength();
+    }
+
+    @Override public BufferedSource source() throws IOException {
+      if (bufferedSource == null) {
+        bufferedSource = Okio.buffer(source(responseBody.source()));
+      }
+      return bufferedSource;
+    }
+
+    private Source source(Source source) {
+      return new ForwardingSource(source) {
+        long totalBytesRead = 0L;
+        @Override public long read(Buffer sink, long byteCount) throws IOException {
+          long bytesRead = super.read(sink, byteCount);
+          // read() returns the number of bytes read, or -1 if this source is exhausted.
+          totalBytesRead += bytesRead != -1 ? bytesRead : 0;
+          progressListener.update(totalBytesRead, responseBody.contentLength(), bytesRead == -1);
+          return bytesRead;
+        }
+      };
+    }
+  }
+
+  interface ProgressListener {
+    void update(long bytesRead, long contentLength, boolean done);
+  }
+}
diff --git a/samples/guide/src/main/java/com/squareup/okhttp/recipes/WebSocketEcho.java b/samples/guide/src/main/java/com/squareup/okhttp/recipes/WebSocketEcho.java
index 738191a9be..d439e99b68 100644
--- a/samples/guide/src/main/java/com/squareup/okhttp/recipes/WebSocketEcho.java
+++ b/samples/guide/src/main/java/com/squareup/okhttp/recipes/WebSocketEcho.java
@@ -3,48 +3,56 @@
 import com.squareup.okhttp.OkHttpClient;
 import com.squareup.okhttp.Request;
 import com.squareup.okhttp.Response;
-import com.squareup.okhttp.internal.ws.WebSocket;
-import com.squareup.okhttp.internal.ws.WebSocketCall;
-import com.squareup.okhttp.internal.ws.WebSocketListener;
+import com.squareup.okhttp.ws.WebSocket;
+import com.squareup.okhttp.ws.WebSocketCall;
+import com.squareup.okhttp.ws.WebSocketListener;
 import java.io.IOException;
+import java.util.concurrent.Executor;
+import java.util.concurrent.Executors;
 import okio.Buffer;
 import okio.BufferedSource;
 
-import static com.squareup.okhttp.internal.ws.WebSocket.PayloadType;
-import static com.squareup.okhttp.internal.ws.WebSocket.PayloadType.BINARY;
-import static com.squareup.okhttp.internal.ws.WebSocket.PayloadType.TEXT;
+import static com.squareup.okhttp.ws.WebSocket.PayloadType;
+import static com.squareup.okhttp.ws.WebSocket.PayloadType.BINARY;
+import static com.squareup.okhttp.ws.WebSocket.PayloadType.TEXT;
 
-/**
- * WARNING: This recipe is for an API that is not final and subject to change at any time!
- */
 public final class WebSocketEcho implements WebSocketListener {
+  private final Executor writeExecutor = Executors.newSingleThreadExecutor();
+
   private void run() throws IOException {
     OkHttpClient client = new OkHttpClient();
 
     Request request = new Request.Builder()
         .url("ws://echo.websocket.org")
         .build();
-    WebSocketCall.newWebSocketCall(client, request).enqueue(this);
+    WebSocketCall.create(client, request).enqueue(this);
 
     // Trigger shutdown of the dispatcher's executor so this process can exit cleanly.
     client.getDispatcher().getExecutorService().shutdown();
   }
 
-  @Override public void onOpen(WebSocket webSocket, Request request, Response response)
-      throws IOException {
-    webSocket.sendMessage(TEXT, new Buffer().writeUtf8("Hello..."));
-    webSocket.sendMessage(TEXT, new Buffer().writeUtf8("...World!"));
-    webSocket.sendMessage(BINARY, new Buffer().writeInt(0xdeadbeef));
-    webSocket.close(1000, "Goodbye, World!");
+  @Override public void onOpen(final WebSocket webSocket, Response response) {
+    writeExecutor.execute(new Runnable() {
+      @Override public void run() {
+        try {
+          webSocket.sendMessage(TEXT, new Buffer().writeUtf8("Hello..."));
+          webSocket.sendMessage(TEXT, new Buffer().writeUtf8("...World!"));
+          webSocket.sendMessage(BINARY, new Buffer().writeInt(0xdeadbeef));
+          webSocket.close(1000, "Goodbye, World!");
+        } catch (IOException e) {
+          System.err.println("Unable to send messages: " + e.getMessage());
+        }
+      }
+    });
   }
 
   @Override public void onMessage(BufferedSource payload, PayloadType type) throws IOException {
     switch (type) {
       case TEXT:
-        System.out.println(payload.readUtf8());
+        System.out.println("MESSAGE: " + payload.readUtf8());
         break;
       case BINARY:
-        System.out.println(payload.readByteString().hex());
+        System.out.println("MESSAGE: " + payload.readByteString().hex());
         break;
       default:
         throw new IllegalStateException("Unknown payload type: " + type);
@@ -60,7 +68,7 @@ private void run() throws IOException {
     System.out.println("CLOSE: " + code + " " + reason);
   }
 
-  @Override public void onFailure(IOException e) {
+  @Override public void onFailure(IOException e, Response response) {
     e.printStackTrace();
   }
 
diff --git a/samples/pom.xml b/samples/pom.xml
index 6991fa9165..29f1e87db9 100644
--- a/samples/pom.xml
+++ b/samples/pom.xml
@@ -6,7 +6,7 @@
   <parent>
     <groupId>com.squareup.okhttp</groupId>
     <artifactId>parent</artifactId>
-    <version>2.3.0-SNAPSHOT</version>
+    <version>2.6.0-SNAPSHOT</version>
   </parent>
 
   <groupId>com.squareup.okhttp.sample</groupId>
diff --git a/samples/simple-client/pom.xml b/samples/simple-client/pom.xml
index 3ebf058230..3a1aa7d0f7 100644
--- a/samples/simple-client/pom.xml
+++ b/samples/simple-client/pom.xml
@@ -6,7 +6,7 @@
   <parent>
     <groupId>com.squareup.okhttp.sample</groupId>
     <artifactId>sample-parent</artifactId>
-    <version>2.3.0-SNAPSHOT</version>
+    <version>2.6.0-SNAPSHOT</version>
   </parent>
 
   <artifactId>simple-client</artifactId>
diff --git a/samples/static-server/pom.xml b/samples/static-server/pom.xml
index e3dc358364..f223151016 100644
--- a/samples/static-server/pom.xml
+++ b/samples/static-server/pom.xml
@@ -6,7 +6,7 @@
   <parent>
     <groupId>com.squareup.okhttp.sample</groupId>
     <artifactId>sample-parent</artifactId>
-    <version>2.3.0-SNAPSHOT</version>
+    <version>2.6.0-SNAPSHOT</version>
   </parent>
 
   <artifactId>static-server</artifactId>
diff --git a/website/index.html b/website/index.html
index 57c412f767..86695a403a 100644
--- a/website/index.html
+++ b/website/index.html
@@ -121,6 +121,9 @@ <h4>Maven</h4>
   &lt;version><span class="version pln"><em>(insert latest version)</em></span>&lt;/version>
 &lt;/dependency></pre>
 
+            <h4>Gradle</h4>
+            <pre class="prettyprint">compile 'com.squareup.okhttp:okhttp:<span class="version pln"><em>(insert latest version)</em></span>'</pre>
+
             <h3 id="contributing">Contributing</h3>
             <p>If you would like to contribute code you can do so through GitHub by forking the repository and sending a pull request.</p>
             <p>When submitting code, please make every effort to follow existing conventions and style in order to keep the code as readable as possible. Please also make sure your code compiles by running <code>mvn clean verify</code>.</p>
