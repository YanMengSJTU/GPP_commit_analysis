diff --git a/okhttp/src/main/java/okhttp3/internal/http/RequestLine.java b/okhttp/src/main/java/okhttp3/internal/http/RequestLine.java
index 3e09098097..03fc01f568 100644
--- a/okhttp/src/main/java/okhttp3/internal/http/RequestLine.java
+++ b/okhttp/src/main/java/okhttp3/internal/http/RequestLine.java
@@ -17,48 +17,49 @@
 
 import java.net.HttpURLConnection;
 import java.net.Proxy;
+
 import okhttp3.HttpUrl;
 import okhttp3.Request;
 
 public final class RequestLine {
-  private RequestLine() {
-  }
+    private RequestLine() {
+    }
 
-  /**
-   * Returns the request status line, like "GET / HTTP/1.1". This is exposed to the application by
-   * {@link HttpURLConnection#getHeaderFields}, so it needs to be set even if the transport is
-   * HTTP/2.
-   */
-  public static String get(Request request, Proxy.Type proxyType) {
-    StringBuilder result = new StringBuilder();
-    result.append(request.method());
-    result.append(' ');
+    /**
+     * Returns the request status line, like "GET / HTTP/1.1". This is exposed to the application by
+     * {@link HttpURLConnection#getHeaderFields}, so it needs to be set even if the transport is
+     * HTTP/2.
+     */
+    public static String get(Request request, Proxy.Type proxyType) {
+        StringBuilder result = new StringBuilder();
+        result.append(request.method());
+        result.append(' ');
 
-    if (includeAuthorityInRequestLine(request, proxyType)) {
-      result.append(request.url());
-    } else {
-      result.append(requestPath(request.url()));
-    }
+        if (includeAuthorityInRequestLine(request, proxyType)) {
+            result.append(request.url());
+        } else {
+            result.append(requestPath(request.url()));
+        }
 
-    result.append(" HTTP/1.1");
-    return result.toString();
-  }
+        result.append(" HTTP/1.1");
+        return result.toString();
+    }
 
-  /**
-   * Returns true if the request line should contain the full URL with host and port (like "GET
-   * http://android.com/foo HTTP/1.1") or only the path (like "GET /foo HTTP/1.1").
-   */
-  private static boolean includeAuthorityInRequestLine(Request request, Proxy.Type proxyType) {
-    return !request.isHttps() && proxyType == Proxy.Type.HTTP;
-  }
+    /**
+     * Returns true if the request line should contain the full URL with host and port (like "GET
+     * http://android.com/foo HTTP/1.1") or only the path (like "GET /foo HTTP/1.1").
+     */
+    private static boolean includeAuthorityInRequestLine(Request request, Proxy.Type proxyType) {
+        return !request.isHttps() && proxyType == Proxy.Type.HTTP;
+    }
 
-  /**
-   * Returns the path to request, like the '/' in 'GET / HTTP/1.1'. Never empty, even if the request
-   * URL is. Includes the query component if it exists.
-   */
-  public static String requestPath(HttpUrl url) {
-    String path = url.encodedPath();
-    String query = url.encodedQuery();
-    return query != null ? (path + '?' + query) : path;
-  }
+    /**
+     * Returns the path to request, like the '/' in 'GET / HTTP/1.1'. Never empty, even if the request
+     * URL is. Includes the query component if it exists.
+     */
+    public static String requestPath(HttpUrl url) {
+        String path = url.encodedPath();
+        String query = url.encodedQuery();
+        return query != null ? (path + '?' + query) : path;
+    }
 }
diff --git a/okhttp/src/main/java/okhttp3/internal/http1/Http1Codec.java b/okhttp/src/main/java/okhttp3/internal/http1/Http1Codec.java
index c3ae5ca233..53839e9411 100644
--- a/okhttp/src/main/java/okhttp3/internal/http1/Http1Codec.java
+++ b/okhttp/src/main/java/okhttp3/internal/http1/Http1Codec.java
@@ -92,7 +92,7 @@
     private long headerLimit = HEADER_LIMIT;
 
     /**
-     * Received trailers. Null unless the response body uses chunked transfer-encoding and includes
+     * Received trailers. Null unless the response body uses chunked（分块） transfer-encoding and includes
      * trailers. Undefined until the end of the response body.
      */
     private Headers trailers;
@@ -108,12 +108,12 @@ public Http1Codec(OkHttpClient client, StreamAllocation streamAllocation, Buffer
     @Override
     public Sink createRequestBody(Request request, long contentLength) {
         if ("chunked".equalsIgnoreCase(request.header("Transfer-Encoding"))) {
-            // Stream a request body of unknown length.
+            // Stream a request body of unknown length.分块上传
             return newChunkedSink();
         }
 
         if (contentLength != -1) {
-            // Stream a request body of a known length.
+            // Stream a request body of a known length.定长消息体
             return newFixedLengthSink(contentLength);
         }
 
diff --git a/okhttp/src/main/java/okhttp3/internal/ws/WebSocketReader.java b/okhttp/src/main/java/okhttp3/internal/ws/WebSocketReader.java
index 6d5d22e67d..eb3599f3c8 100644
--- a/okhttp/src/main/java/okhttp3/internal/ws/WebSocketReader.java
+++ b/okhttp/src/main/java/okhttp3/internal/ws/WebSocketReader.java
@@ -18,6 +18,7 @@
 import java.io.IOException;
 import java.net.ProtocolException;
 import java.util.concurrent.TimeUnit;
+
 import okio.Buffer;
 import okio.BufferedSource;
 import okio.ByteString;
@@ -49,216 +50,222 @@
  * <p>This class is not thread safe.
  */
 final class WebSocketReader {
-  public interface FrameCallback {
-    void onReadMessage(String text) throws IOException;
-    void onReadMessage(ByteString bytes) throws IOException;
-    void onReadPing(ByteString buffer);
-    void onReadPong(ByteString buffer);
-    void onReadClose(int code, String reason);
-  }
-
-  final boolean isClient;
-  final BufferedSource source;
-  final FrameCallback frameCallback;
-
-  boolean closed;
-
-  // Stateful data about the current frame.
-  int opcode;
-  long frameLength;
-  boolean isFinalFrame;
-  boolean isControlFrame;
-
-  private final Buffer controlFrameBuffer = new Buffer();
-  private final Buffer messageFrameBuffer = new Buffer();
-
-  private final byte[] maskKey;
-  private final Buffer.UnsafeCursor maskCursor;
-
-  WebSocketReader(boolean isClient, BufferedSource source, FrameCallback frameCallback) {
-    if (source == null) throw new NullPointerException("source == null");
-    if (frameCallback == null) throw new NullPointerException("frameCallback == null");
-    this.isClient = isClient;
-    this.source = source;
-    this.frameCallback = frameCallback;
-
-    // Masks are only a concern for server writers.
-    maskKey = isClient ? null : new byte[4];
-    maskCursor = isClient ? null : new Buffer.UnsafeCursor();
-  }
-
-  /**
-   * Process the next protocol frame.
-   *
-   * <ul>
-   *     <li>If it is a control frame this will result in a single call to {@link FrameCallback}.
-   *     <li>If it is a message frame this will result in a single call to {@link
-   *         FrameCallback#onReadMessage}. If the message spans multiple frames, each interleaved
-   *         control frame will result in a corresponding call to {@link FrameCallback}.
-   * </ul>
-   */
-  void processNextFrame() throws IOException {
-    readHeader();
-    if (isControlFrame) {
-      readControlFrame();
-    } else {
-      readMessageFrame();
-    }
-  }
-
-  private void readHeader() throws IOException {
-    if (closed) throw new IOException("closed");
-
-    // Disable the timeout to read the first byte of a new frame.
-    int b0;
-    long timeoutBefore = source.timeout().timeoutNanos();
-    source.timeout().clearTimeout();
-    try {
-      b0 = source.readByte() & 0xff;
-    } finally {
-      source.timeout().timeout(timeoutBefore, TimeUnit.NANOSECONDS);
-    }
+    public interface FrameCallback {
+        void onReadMessage(String text) throws IOException;
 
-    opcode = b0 & B0_MASK_OPCODE;
-    isFinalFrame = (b0 & B0_FLAG_FIN) != 0;
-    isControlFrame = (b0 & OPCODE_FLAG_CONTROL) != 0;
+        void onReadMessage(ByteString bytes) throws IOException;
 
-    // Control frames must be final frames (cannot contain continuations).
-    if (isControlFrame && !isFinalFrame) {
-      throw new ProtocolException("Control frames must be final.");
-    }
+        void onReadPing(ByteString buffer);
+
+        void onReadPong(ByteString buffer);
 
-    boolean reservedFlag1 = (b0 & B0_FLAG_RSV1) != 0;
-    boolean reservedFlag2 = (b0 & B0_FLAG_RSV2) != 0;
-    boolean reservedFlag3 = (b0 & B0_FLAG_RSV3) != 0;
-    if (reservedFlag1 || reservedFlag2 || reservedFlag3) {
-      // Reserved flags are for extensions which we currently do not support.
-      throw new ProtocolException("Reserved flags are unsupported.");
+        void onReadClose(int code, String reason);
     }
 
-    int b1 = source.readByte() & 0xff;
+    final boolean isClient;
+    final BufferedSource source;
+    final FrameCallback frameCallback;
 
-    boolean isMasked = (b1 & B1_FLAG_MASK) != 0;
-    if (isMasked == isClient) {
-      // Masked payloads must be read on the server. Unmasked payloads must be read on the client.
-      throw new ProtocolException(isClient
-          ? "Server-sent frames must not be masked."
-          : "Client-sent frames must be masked.");
-    }
+    boolean closed;
 
-    // Get frame length, optionally reading from follow-up bytes if indicated by special values.
-    frameLength = b1 & B1_MASK_LENGTH;
-    if (frameLength == PAYLOAD_SHORT) {
-      frameLength = source.readShort() & 0xffffL; // Value is unsigned.
-    } else if (frameLength == PAYLOAD_LONG) {
-      frameLength = source.readLong();
-      if (frameLength < 0) {
-        throw new ProtocolException(
-            "Frame length 0x" + Long.toHexString(frameLength) + " > 0x7FFFFFFFFFFFFFFF");
-      }
-    }
+    // Stateful data about the current frame.
+    int opcode;
+    long frameLength;
+    boolean isFinalFrame;
+    boolean isControlFrame;
 
-    if (isControlFrame && frameLength > PAYLOAD_BYTE_MAX) {
-      throw new ProtocolException("Control frame must be less than " + PAYLOAD_BYTE_MAX + "B.");
-    }
+    private final Buffer controlFrameBuffer = new Buffer();
+    private final Buffer messageFrameBuffer = new Buffer();
 
-    if (isMasked) {
-      // Read the masking key as bytes so that they can be used directly for unmasking.
-      source.readFully(maskKey);
-    }
-  }
-
-  private void readControlFrame() throws IOException {
-    if (frameLength > 0) {
-      source.readFully(controlFrameBuffer, frameLength);
-
-      if (!isClient) {
-        controlFrameBuffer.readAndWriteUnsafe(maskCursor);
-        maskCursor.seek(0);
-        toggleMask(maskCursor, maskKey);
-        maskCursor.close();
-      }
+    private final byte[] maskKey;
+    private final Buffer.UnsafeCursor maskCursor;
+
+    WebSocketReader(boolean isClient, BufferedSource source, FrameCallback frameCallback) {
+        if (source == null) throw new NullPointerException("source == null");
+        if (frameCallback == null) throw new NullPointerException("frameCallback == null");
+        this.isClient = isClient;
+        this.source = source;
+        this.frameCallback = frameCallback;
+
+        // Masks are only a concern for server writers.
+        maskKey = isClient ? null : new byte[4];
+        maskCursor = isClient ? null : new Buffer.UnsafeCursor();
     }
 
-    switch (opcode) {
-      case OPCODE_CONTROL_PING:
-        frameCallback.onReadPing(controlFrameBuffer.readByteString());
-        break;
-      case OPCODE_CONTROL_PONG:
-        frameCallback.onReadPong(controlFrameBuffer.readByteString());
-        break;
-      case OPCODE_CONTROL_CLOSE:
-        int code = CLOSE_NO_STATUS_CODE;
-        String reason = "";
-        long bufferSize = controlFrameBuffer.size();
-        if (bufferSize == 1) {
-          throw new ProtocolException("Malformed close payload length of 1.");
-        } else if (bufferSize != 0) {
-          code = controlFrameBuffer.readShort();
-          reason = controlFrameBuffer.readUtf8();
-          String codeExceptionMessage = WebSocketProtocol.closeCodeExceptionMessage(code);
-          if (codeExceptionMessage != null) throw new ProtocolException(codeExceptionMessage);
+    /**
+     * Process the next protocol frame.
+     *
+     * <ul>
+     * <li>If it is a control frame this will result in a single call to {@link FrameCallback}.
+     * <li>If it is a message frame this will result in a single call to {@link
+     * FrameCallback#onReadMessage}. If the message spans multiple frames, each interleaved
+     * control frame will result in a corresponding call to {@link FrameCallback}.
+     * </ul>
+     */
+    void processNextFrame() throws IOException {
+        readHeader();
+        if (isControlFrame) {
+            readControlFrame();
+        } else {
+            readMessageFrame();
         }
-        frameCallback.onReadClose(code, reason);
-        closed = true;
-        break;
-      default:
-        throw new ProtocolException("Unknown control opcode: " + toHexString(opcode));
     }
-  }
 
-  private void readMessageFrame() throws IOException {
-    int opcode = this.opcode;
-    if (opcode != OPCODE_TEXT && opcode != OPCODE_BINARY) {
-      throw new ProtocolException("Unknown opcode: " + toHexString(opcode));
-    }
+    private void readHeader() throws IOException {
+        if (closed) throw new IOException("closed");
+
+        // Disable the timeout to read the first byte of a new frame.
+        int b0;
+        long timeoutBefore = source.timeout().timeoutNanos();
+        source.timeout().clearTimeout();
+        try {
+            b0 = source.readByte() & 0xff;
+        } finally {
+            source.timeout().timeout(timeoutBefore, TimeUnit.NANOSECONDS);
+        }
+
+        opcode = b0 & B0_MASK_OPCODE;
+        isFinalFrame = (b0 & B0_FLAG_FIN) != 0;
+        isControlFrame = (b0 & OPCODE_FLAG_CONTROL) != 0;
+
+        // Control frames must be final frames (cannot contain continuations).
+        if (isControlFrame && !isFinalFrame) {
+            throw new ProtocolException("Control frames must be final.");
+        }
+
+        boolean reservedFlag1 = (b0 & B0_FLAG_RSV1) != 0;
+        boolean reservedFlag2 = (b0 & B0_FLAG_RSV2) != 0;
+        boolean reservedFlag3 = (b0 & B0_FLAG_RSV3) != 0;
+        if (reservedFlag1 || reservedFlag2 || reservedFlag3) {
+            // Reserved flags are for extensions which we currently do not support.
+            throw new ProtocolException("Reserved flags are unsupported.");
+        }
+
+        int b1 = source.readByte() & 0xff;
 
-    readMessage();
+        boolean isMasked = (b1 & B1_FLAG_MASK) != 0;
+        if (isMasked == isClient) {
+            // Masked payloads must be read on the server. Unmasked payloads must be read on the client.
+            throw new ProtocolException(isClient
+                    ? "Server-sent frames must not be masked."
+                    : "Client-sent frames must be masked.");
+        }
+
+        // Get frame length, optionally reading from follow-up bytes if indicated by special values.
+        frameLength = b1 & B1_MASK_LENGTH;
+        if (frameLength == PAYLOAD_SHORT) {
+            frameLength = source.readShort() & 0xffffL; // Value is unsigned.
+        } else if (frameLength == PAYLOAD_LONG) {
+            frameLength = source.readLong();
+            if (frameLength < 0) {
+                throw new ProtocolException(
+                        "Frame length 0x" + Long.toHexString(frameLength) + " > 0x7FFFFFFFFFFFFFFF");
+            }
+        }
+
+        if (isControlFrame && frameLength > PAYLOAD_BYTE_MAX) {
+            throw new ProtocolException("Control frame must be less than " + PAYLOAD_BYTE_MAX + "B.");
+        }
 
-    if (opcode == OPCODE_TEXT) {
-      frameCallback.onReadMessage(messageFrameBuffer.readUtf8());
-    } else {
-      frameCallback.onReadMessage(messageFrameBuffer.readByteString());
+        if (isMasked) {
+            // Read the masking key as bytes so that they can be used directly for unmasking.
+            source.readFully(maskKey);
+        }
     }
-  }
-
-  /** Read headers and process any control frames until we reach a non-control frame. */
-  private void readUntilNonControlFrame() throws IOException {
-    while (!closed) {
-      readHeader();
-      if (!isControlFrame) {
-        break;
-      }
-      readControlFrame();
+
+    private void readControlFrame() throws IOException {
+        if (frameLength > 0) {
+            source.readFully(controlFrameBuffer, frameLength);
+
+            if (!isClient) {
+                controlFrameBuffer.readAndWriteUnsafe(maskCursor);
+                maskCursor.seek(0);
+                toggleMask(maskCursor, maskKey);
+                maskCursor.close();
+            }
+        }
+
+        switch (opcode) {
+            case OPCODE_CONTROL_PING:
+                frameCallback.onReadPing(controlFrameBuffer.readByteString());
+                break;
+            case OPCODE_CONTROL_PONG:
+                frameCallback.onReadPong(controlFrameBuffer.readByteString());
+                break;
+            case OPCODE_CONTROL_CLOSE:
+                int code = CLOSE_NO_STATUS_CODE;
+                String reason = "";
+                long bufferSize = controlFrameBuffer.size();
+                if (bufferSize == 1) {
+                    throw new ProtocolException("Malformed close payload length of 1.");
+                } else if (bufferSize != 0) {
+                    code = controlFrameBuffer.readShort();
+                    reason = controlFrameBuffer.readUtf8();
+                    String codeExceptionMessage = WebSocketProtocol.closeCodeExceptionMessage(code);
+                    if (codeExceptionMessage != null) throw new ProtocolException(codeExceptionMessage);
+                }
+                frameCallback.onReadClose(code, reason);
+                closed = true;
+                break;
+            default:
+                throw new ProtocolException("Unknown control opcode: " + toHexString(opcode));
+        }
     }
-  }
-
-  /**
-   * Reads a message body into across one or more frames. Control frames that occur between
-   * fragments will be processed. If the message payload is masked this will unmask as it's being
-   * processed.
-   */
-  private void readMessage() throws IOException {
-    while (true) {
-      if (closed) throw new IOException("closed");
-
-      if (frameLength > 0) {
-        source.readFully(messageFrameBuffer, frameLength);
-
-        if (!isClient) {
-          messageFrameBuffer.readAndWriteUnsafe(maskCursor);
-          maskCursor.seek(messageFrameBuffer.size() - frameLength);
-          toggleMask(maskCursor, maskKey);
-          maskCursor.close();
+
+    private void readMessageFrame() throws IOException {
+        int opcode = this.opcode;
+        if (opcode != OPCODE_TEXT && opcode != OPCODE_BINARY) {
+            throw new ProtocolException("Unknown opcode: " + toHexString(opcode));
         }
-      }
 
-      if (isFinalFrame) break; // We are exhausted and have no continuations.
+        readMessage();
+
+        if (opcode == OPCODE_TEXT) {
+            frameCallback.onReadMessage(messageFrameBuffer.readUtf8());
+        } else {
+            frameCallback.onReadMessage(messageFrameBuffer.readByteString());
+        }
+    }
 
-      readUntilNonControlFrame();
-      if (opcode != OPCODE_CONTINUATION) {
-        throw new ProtocolException("Expected continuation opcode. Got: " + toHexString(opcode));
-      }
+    /**
+     * Read headers and process any control frames until we reach a non-control frame.
+     */
+    private void readUntilNonControlFrame() throws IOException {
+        while (!closed) {
+            readHeader();
+            if (!isControlFrame) {
+                break;
+            }
+            readControlFrame();
+        }
+    }
+
+    /**
+     * Reads a message body into across one or more frames. Control frames that occur between
+     * fragments will be processed. If the message payload is masked this will unmask as it's being
+     * processed.
+     */
+    private void readMessage() throws IOException {
+        while (true) {
+            if (closed) throw new IOException("closed");
+
+            if (frameLength > 0) {
+                source.readFully(messageFrameBuffer, frameLength);
+
+                if (!isClient) {
+                    messageFrameBuffer.readAndWriteUnsafe(maskCursor);
+                    maskCursor.seek(messageFrameBuffer.size() - frameLength);
+                    toggleMask(maskCursor, maskKey);
+                    maskCursor.close();
+                }
+            }
+
+            if (isFinalFrame) break; // We are exhausted and have no continuations.
+
+            readUntilNonControlFrame();
+            if (opcode != OPCODE_CONTINUATION) {
+                throw new ProtocolException("Expected continuation opcode. Got: " + toHexString(opcode));
+            }
+        }
     }
-  }
 }
diff --git a/samples/simple-client/src/main/java/okhttp3/sample/OkHttpContributors.java b/samples/simple-client/src/main/java/okhttp3/sample/OkHttpContributors.java
index 077b7e4230..1c8ee3d9fe 100644
--- a/samples/simple-client/src/main/java/okhttp3/sample/OkHttpContributors.java
+++ b/samples/simple-client/src/main/java/okhttp3/sample/OkHttpContributors.java
@@ -15,6 +15,7 @@
 /**
  * 参考文章
  * okhttp源码学习笔记（二）-- 连接与连接管理 https://www.jianshu.com/p/671a123ec163
+ * 代理、网关与隧道 https://blog.csdn.net/sjailjq/article/details/82287345
  */
 public class OkHttpContributors {
     private static final String ENDPOINT = "https://api.github.com/repos/square/okhttp/contributors";
