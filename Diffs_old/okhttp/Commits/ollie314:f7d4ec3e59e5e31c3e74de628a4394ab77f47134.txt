diff --git a/CHANGELOG.md b/CHANGELOG.md
index b7d52c8f37..960d7d2f60 100644
--- a/CHANGELOG.md
+++ b/CHANGELOG.md
@@ -1,6 +1,19 @@
 Change Log
 ==========
 
+## Version 3.2.0
+
+_2016-02-25_
+
+ *  Fix: Change the certificate pinner to always build full chains. This
+    prevents a potential crash when using certificate pinning with the Google
+    Play Services security provider.
+ *  Fix: Make IPv6 request lines consistent with Firefox and Chrome.
+ *  Fix: Recover gracefully when trimming the response cache fails.
+ *  New: Add multiple path segments using a single string in `HttpUrl.Builder`.
+ *  New: Support SHA-256 pins in certificate pinner.
+
+
 ## Version 3.1.2
 
 _2016-02-10_
@@ -174,6 +187,15 @@ stuck on the old version.
  *  New: Make `HttpUrl` the blessed URL method of `Request`.
 
 
+## Version 2.7.5
+
+_2016-02-25_
+
+ *  Fix: Change the certificate pinner to always build full chains. This
+    prevents a potential crash when using certificate pinning with the Google
+    Play Services security provider.
+
+
 ## Version 2.7.4
 
 _2016-02-07_
diff --git a/README.md b/README.md
index 09a3831f82..b6b059deb4 100644
--- a/README.md
+++ b/README.md
@@ -11,12 +11,12 @@ Download [the latest JAR][3] or grab via Maven:
 <dependency>
   <groupId>com.squareup.okhttp3</groupId>
   <artifactId>okhttp</artifactId>
-  <version>3.1.2</version>
+  <version>3.2.0</version>
 </dependency>
 ```
 or Gradle:
 ```groovy
-compile 'com.squareup.okhttp3:okhttp:3.1.2'
+compile 'com.squareup.okhttp3:okhttp:3.2.0'
 ```
 
 Snapshots of the development version are available in [Sonatype's `snapshots` repository][snap].
@@ -36,13 +36,13 @@ Download [the latest JAR][4] or grab via Maven:
 <dependency>
   <groupId>com.squareup.okhttp3</groupId>
   <artifactId>mockwebserver</artifactId>
-  <version>3.1.2</version>
+  <version>3.2.0</version>
   <scope>test</scope>
 </dependency>
 ```
 or Gradle:
 ```groovy
-testCompile 'com.squareup.okhttp3:mockwebserver:3.1.2'
+testCompile 'com.squareup.okhttp3:mockwebserver:3.2.0'
 ```
 
 
diff --git a/benchmarks/pom.xml b/benchmarks/pom.xml
index cf29f7bcf4..2dab72f0ef 100644
--- a/benchmarks/pom.xml
+++ b/benchmarks/pom.xml
@@ -6,7 +6,7 @@
   <parent>
     <groupId>com.squareup.okhttp3</groupId>
     <artifactId>parent</artifactId>
-    <version>3.2.0-SNAPSHOT</version>
+    <version>3.3.0-SNAPSHOT</version>
   </parent>
 
   <artifactId>benchmarks</artifactId>
diff --git a/mockwebserver/pom.xml b/mockwebserver/pom.xml
index 379b323805..0d858e5524 100644
--- a/mockwebserver/pom.xml
+++ b/mockwebserver/pom.xml
@@ -6,7 +6,7 @@
   <parent>
     <groupId>com.squareup.okhttp3</groupId>
     <artifactId>parent</artifactId>
-    <version>3.2.0-SNAPSHOT</version>
+    <version>3.3.0-SNAPSHOT</version>
   </parent>
 
   <artifactId>mockwebserver</artifactId>
diff --git a/okcurl/pom.xml b/okcurl/pom.xml
index 0b6f0d6c05..63b1cc8c8b 100644
--- a/okcurl/pom.xml
+++ b/okcurl/pom.xml
@@ -6,7 +6,7 @@
   <parent>
     <groupId>com.squareup.okhttp3</groupId>
     <artifactId>parent</artifactId>
-    <version>3.2.0-SNAPSHOT</version>
+    <version>3.3.0-SNAPSHOT</version>
   </parent>
 
   <artifactId>okcurl</artifactId>
diff --git a/okhttp-android-support/pom.xml b/okhttp-android-support/pom.xml
index 066fb72649..9f6f647bc6 100644
--- a/okhttp-android-support/pom.xml
+++ b/okhttp-android-support/pom.xml
@@ -6,7 +6,7 @@
   <parent>
     <groupId>com.squareup.okhttp3</groupId>
     <artifactId>parent</artifactId>
-    <version>3.2.0-SNAPSHOT</version>
+    <version>3.3.0-SNAPSHOT</version>
   </parent>
 
   <artifactId>okhttp-android-support</artifactId>
diff --git a/okhttp-apache/pom.xml b/okhttp-apache/pom.xml
index 6235935f98..68fcf1add9 100644
--- a/okhttp-apache/pom.xml
+++ b/okhttp-apache/pom.xml
@@ -6,7 +6,7 @@
   <parent>
     <groupId>com.squareup.okhttp3</groupId>
     <artifactId>parent</artifactId>
-    <version>3.2.0-SNAPSHOT</version>
+    <version>3.3.0-SNAPSHOT</version>
   </parent>
 
   <artifactId>okhttp-apache</artifactId>
diff --git a/okhttp-logging-interceptor/pom.xml b/okhttp-logging-interceptor/pom.xml
index 17e074e735..a837c6c898 100644
--- a/okhttp-logging-interceptor/pom.xml
+++ b/okhttp-logging-interceptor/pom.xml
@@ -6,7 +6,7 @@
   <parent>
     <groupId>com.squareup.okhttp3</groupId>
     <artifactId>parent</artifactId>
-    <version>3.2.0-SNAPSHOT</version>
+    <version>3.3.0-SNAPSHOT</version>
   </parent>
 
   <artifactId>logging-interceptor</artifactId>
diff --git a/okhttp-logging-interceptor/src/main/java/okhttp3/logging/HttpLoggingInterceptor.java b/okhttp-logging-interceptor/src/main/java/okhttp3/logging/HttpLoggingInterceptor.java
index 5e738b341a..532b80ce4a 100644
--- a/okhttp-logging-interceptor/src/main/java/okhttp3/logging/HttpLoggingInterceptor.java
+++ b/okhttp-logging-interceptor/src/main/java/okhttp3/logging/HttpLoggingInterceptor.java
@@ -15,6 +15,7 @@
  */
 package okhttp3.logging;
 
+import java.io.EOFException;
 import java.io.IOException;
 import java.nio.charset.Charset;
 import java.nio.charset.UnsupportedCharsetException;
@@ -192,10 +193,14 @@ public Level getLevel() {
         }
 
         logger.log("");
-        logger.log(buffer.readString(charset));
-
-        logger.log("--> END " + request.method()
-            + " (" + requestBody.contentLength() + "-byte body)");
+        if (isPlaintext(buffer)) {
+          logger.log(buffer.readString(charset));
+          logger.log("--> END " + request.method()
+              + " (" + requestBody.contentLength() + "-byte body)");
+        } else {
+          logger.log("--> END " + request.method() + " (binary "
+              + requestBody.contentLength() + "-byte body omitted)");
+        }
       }
     }
 
@@ -239,6 +244,12 @@ public Level getLevel() {
           }
         }
 
+        if (!isPlaintext(buffer)) {
+          logger.log("");
+          logger.log("<-- END HTTP (binary " + buffer.size() + "-byte body omitted)");
+          return response;
+        }
+
         if (contentLength != 0) {
           logger.log("");
           logger.log(buffer.clone().readString(charset));
@@ -251,6 +262,29 @@ public Level getLevel() {
     return response;
   }
 
+  /**
+   * Returns true if the body in question probably contains human readable text. Uses a small sample
+   * of code points to detect unicode control characters commonly used in binary file signatures.
+   */
+  static boolean isPlaintext(Buffer buffer) throws EOFException {
+    try {
+      Buffer prefix = new Buffer();
+      long byteCount = buffer.size() < 64 ? buffer.size() : 64;
+      buffer.copyTo(prefix, 0, byteCount);
+      for (int i = 0; i < 16; i++) {
+        if (prefix.exhausted()) {
+          break;
+        }
+        if (Character.isISOControl(prefix.readUtf8CodePoint())) {
+          return false;
+        }
+      }
+      return true;
+    } catch (EOFException e) {
+      return false; // Truncated UTF-8 sequence.
+    }
+  }
+
   private boolean bodyEncoded(Headers headers) {
     String contentEncoding = headers.get("Content-Encoding");
     return contentEncoding != null && !contentEncoding.equalsIgnoreCase("identity");
diff --git a/okhttp-logging-interceptor/src/test/java/okhttp3/logging/HttpLoggingInterceptorTest.java b/okhttp-logging-interceptor/src/test/java/okhttp3/logging/HttpLoggingInterceptorTest.java
index 88630b500c..3159ad2f75 100644
--- a/okhttp-logging-interceptor/src/test/java/okhttp3/logging/HttpLoggingInterceptorTest.java
+++ b/okhttp-logging-interceptor/src/test/java/okhttp3/logging/HttpLoggingInterceptorTest.java
@@ -37,6 +37,7 @@
 import org.junit.Test;
 
 import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
 import static org.junit.Assert.assertSame;
 import static org.junit.Assert.assertTrue;
 import static org.junit.Assert.fail;
@@ -638,6 +639,60 @@ private void bodyGetNoBody(int code) throws IOException {
         .assertNoMoreLogs();
   }
 
+  @Test public void isPlaintext() throws IOException {
+    assertTrue(HttpLoggingInterceptor.isPlaintext(new Buffer()));
+    assertTrue(HttpLoggingInterceptor.isPlaintext(new Buffer().writeUtf8("abc")));
+    assertTrue(HttpLoggingInterceptor.isPlaintext(new Buffer().writeByte(0x80)));
+    assertFalse(HttpLoggingInterceptor.isPlaintext(new Buffer().writeByte(0x00)));
+    assertFalse(HttpLoggingInterceptor.isPlaintext(new Buffer().writeByte(0xc0)));
+  }
+
+  @Test public void responseBodyIsBinary() throws IOException {
+    setLevel(Level.BODY);
+    Buffer buffer = new Buffer();
+    buffer.writeUtf8CodePoint(0x89);
+    buffer.writeUtf8CodePoint(0x50);
+    buffer.writeUtf8CodePoint(0x4e);
+    buffer.writeUtf8CodePoint(0x47);
+    buffer.writeUtf8CodePoint(0x0d);
+    buffer.writeUtf8CodePoint(0x0a);
+    buffer.writeUtf8CodePoint(0x1a);
+    buffer.writeUtf8CodePoint(0x0a);
+    server.enqueue(new MockResponse()
+        .setBody(buffer)
+        .setHeader("Content-Type", "image/png; charset=utf-8"));
+    Response response = client.newCall(request().build()).execute();
+    response.body().close();
+
+    applicationLogs
+        .assertLogEqual("--> GET " + url + " http/1.1")
+        .assertLogEqual("--> END GET")
+        .assertLogMatch("<-- 200 OK " + url + " \\(\\d+ms\\)")
+        .assertLogEqual("Content-Length: 9")
+        .assertLogEqual("Content-Type: image/png; charset=utf-8")
+        .assertLogMatch("OkHttp-Sent-Millis: \\d+")
+        .assertLogMatch("OkHttp-Received-Millis: \\d+")
+        .assertLogEqual("")
+        .assertLogEqual("<-- END HTTP (binary 9-byte body omitted)")
+        .assertNoMoreLogs();
+
+    networkLogs
+        .assertLogEqual("--> GET " + url + " http/1.1")
+        .assertLogEqual("Host: " + host)
+        .assertLogEqual("Connection: Keep-Alive")
+        .assertLogEqual("Accept-Encoding: gzip")
+        .assertLogMatch("User-Agent: okhttp/.+")
+        .assertLogEqual("--> END GET")
+        .assertLogMatch("<-- 200 OK " + url + " \\(\\d+ms\\)")
+        .assertLogEqual("Content-Length: 9")
+        .assertLogEqual("Content-Type: image/png; charset=utf-8")
+        .assertLogMatch("OkHttp-Sent-Millis: \\d+")
+        .assertLogMatch("OkHttp-Received-Millis: \\d+")
+        .assertLogEqual("")
+        .assertLogEqual("<-- END HTTP (binary 9-byte body omitted)")
+        .assertNoMoreLogs();
+  }
+
   private Request.Builder request() {
     return new Request.Builder().url(url);
   }
diff --git a/okhttp-testing-support/pom.xml b/okhttp-testing-support/pom.xml
index c1e13b7498..7b6ad7cd7e 100644
--- a/okhttp-testing-support/pom.xml
+++ b/okhttp-testing-support/pom.xml
@@ -6,7 +6,7 @@
   <parent>
     <groupId>com.squareup.okhttp3</groupId>
     <artifactId>parent</artifactId>
-    <version>3.2.0-SNAPSHOT</version>
+    <version>3.3.0-SNAPSHOT</version>
   </parent>
 
   <artifactId>okhttp-testing-support</artifactId>
diff --git a/okhttp-testing-support/src/main/java/okhttp3/internal/io/InMemoryFileSystem.java b/okhttp-testing-support/src/main/java/okhttp3/internal/io/InMemoryFileSystem.java
index b4299fd09b..bb6f519092 100644
--- a/okhttp-testing-support/src/main/java/okhttp3/internal/io/InMemoryFileSystem.java
+++ b/okhttp-testing-support/src/main/java/okhttp3/internal/io/InMemoryFileSystem.java
@@ -113,7 +113,7 @@ private Sink sink(File file, boolean appending) {
     files.remove(file);
   }
 
-  @Override public boolean exists(File file) throws IOException {
+  @Override public boolean exists(File file) {
     return files.containsKey(file);
   }
 
diff --git a/okhttp-tests/pom.xml b/okhttp-tests/pom.xml
index 20f51832bc..d9f8596922 100644
--- a/okhttp-tests/pom.xml
+++ b/okhttp-tests/pom.xml
@@ -6,7 +6,7 @@
   <parent>
     <groupId>com.squareup.okhttp3</groupId>
     <artifactId>parent</artifactId>
-    <version>3.2.0-SNAPSHOT</version>
+    <version>3.3.0-SNAPSHOT</version>
   </parent>
 
   <artifactId>okhttp-tests</artifactId>
diff --git a/okhttp-tests/src/test/java/okhttp3/CallTest.java b/okhttp-tests/src/test/java/okhttp3/CallTest.java
index 3cb960f4bf..e46e9747a4 100644
--- a/okhttp-tests/src/test/java/okhttp3/CallTest.java
+++ b/okhttp-tests/src/test/java/okhttp3/CallTest.java
@@ -2197,6 +2197,75 @@ private InetSocketAddress startNullServer() throws IOException {
     assertNull(get.getHeader("Proxy-Authorization"));
   }
 
+  /** Confirm that the proxy authenticator works for unencrypted HTTP proxies. */
+  @Test public void httpProxyAuthenticate() throws Exception {
+    server.enqueue(new MockResponse()
+        .setResponseCode(407)
+        .addHeader("Proxy-Authenticate: Basic realm=\"localhost\""));
+    server.enqueue(new MockResponse()
+        .setBody("response body"));
+
+    client = client.newBuilder()
+        .proxy(server.toProxyAddress())
+        .proxyAuthenticator(new RecordingOkAuthenticator("password"))
+        .build();
+
+    Request request = new Request.Builder()
+        .url("http://android.com/foo")
+        .build();
+    Response response = client.newCall(request).execute();
+    assertEquals("response body", response.body().string());
+
+    RecordedRequest get1 = server.takeRequest();
+    assertEquals("GET http://android.com/foo HTTP/1.1", get1.getRequestLine());
+    assertNull(get1.getHeader("Proxy-Authorization"));
+
+    RecordedRequest get2 = server.takeRequest();
+    assertEquals("GET http://android.com/foo HTTP/1.1", get2.getRequestLine());
+    assertEquals("password", get2.getHeader("Proxy-Authorization"));
+  }
+
+  /**
+   * OkHttp has a bug where a `Connection: close` response header is not honored when establishing
+   * a TLS tunnel. https://github.com/square/okhttp/issues/2426
+   */
+  @Ignore("currently broken")
+  @Test public void proxyAuthenticateOnConnectWithConnectionClose() throws Exception {
+    server.useHttps(sslContext.getSocketFactory(), true);
+    server.setProtocols(Collections.singletonList(Protocol.HTTP_1_1));
+    server.enqueue(new MockResponse()
+        .setResponseCode(407)
+        .addHeader("Proxy-Authenticate: Basic realm=\"localhost\"")
+        .addHeader("Connection: close"));
+    server.enqueue(new MockResponse()
+        .setSocketPolicy(SocketPolicy.UPGRADE_TO_SSL_AT_END)
+        .clearHeaders());
+    server.enqueue(new MockResponse()
+        .setBody("response body"));
+
+    client = client.newBuilder()
+        .sslSocketFactory(sslContext.getSocketFactory())
+        .proxy(server.toProxyAddress())
+        .proxyAuthenticator(new RecordingOkAuthenticator("password"))
+        .hostnameVerifier(new RecordingHostnameVerifier())
+        .build();
+
+    Request request = new Request.Builder()
+        .url("https://android.com/foo")
+        .build();
+    Response response = client.newCall(request).execute();
+    assertEquals("response body", response.body().string());
+
+    // First CONNECT call needs a new connection.
+    assertEquals(0, server.takeRequest().getSequenceNumber());
+
+    // Second CONNECT call needs a new connection.
+    assertEquals(0, server.takeRequest().getSequenceNumber());
+
+    // GET reuses the connection from the second connect.
+    assertEquals(1, server.takeRequest().getSequenceNumber());
+  }
+
   /**
    * Confirm that we don't send the Proxy-Authorization header from the request to the proxy server.
    * We used to have that behavior but it is problematic because unrelated requests end up sharing
diff --git a/okhttp-tests/src/test/java/okhttp3/CertificateChainCleanerTest.java b/okhttp-tests/src/test/java/okhttp3/CertificateChainCleanerTest.java
index 647ee1a327..8bfcb8c2ae 100644
--- a/okhttp-tests/src/test/java/okhttp3/CertificateChainCleanerTest.java
+++ b/okhttp-tests/src/test/java/okhttp3/CertificateChainCleanerTest.java
@@ -23,7 +23,6 @@
 import javax.net.ssl.SSLPeerUnverifiedException;
 import okhttp3.internal.HeldCertificate;
 import okhttp3.internal.tls.CertificateChainCleaner;
-import okhttp3.internal.tls.RealTrustRootIndex;
 import org.junit.Test;
 
 import static org.junit.Assert.assertEquals;
@@ -34,19 +33,18 @@
     HeldCertificate root = new HeldCertificate.Builder()
         .serialNumber("1")
         .build();
-    CertificateChainCleaner council = new CertificateChainCleaner(
-        new RealTrustRootIndex(root.certificate));
-    assertEquals(list(root), council.clean(list(root)));
+    CertificateChainCleaner cleaner = CertificateChainCleaner.get(root.certificate);
+    assertEquals(list(root), cleaner.clean(list(root), "hostname"));
   }
 
   @Test public void normalizeUnknownSelfSignedCertificate() throws Exception {
     HeldCertificate root = new HeldCertificate.Builder()
         .serialNumber("1")
         .build();
-    CertificateChainCleaner council = new CertificateChainCleaner(new RealTrustRootIndex());
+    CertificateChainCleaner cleaner = CertificateChainCleaner.get();
 
     try {
-      council.clean(list(root));
+      cleaner.clean(list(root), "hostname");
       fail();
     } catch (SSLPeerUnverifiedException expected) {
     }
@@ -65,9 +63,8 @@
         .issuedBy(certA)
         .build();
 
-    CertificateChainCleaner council = new CertificateChainCleaner(
-        new RealTrustRootIndex(root.certificate));
-    assertEquals(list(certB, certA, root), council.clean(list(certB, certA, root)));
+    CertificateChainCleaner cleaner = CertificateChainCleaner.get(root.certificate);
+    assertEquals(list(certB, certA, root), cleaner.clean(list(certB, certA, root), "hostname"));
   }
 
   @Test public void orderedChainOfCertificatesWithoutRoot() throws Exception {
@@ -83,9 +80,9 @@
         .issuedBy(certA)
         .build();
 
-    CertificateChainCleaner council = new CertificateChainCleaner(
-        new RealTrustRootIndex(root.certificate));
-    assertEquals(list(certB, certA, root), council.clean(list(certB, certA))); // Root is added!
+    CertificateChainCleaner cleaner = CertificateChainCleaner.get(root.certificate);
+    assertEquals(list(certB, certA, root),
+        cleaner.clean(list(certB, certA), "hostname")); // Root is added!
   }
 
   @Test public void unorderedChainOfCertificatesWithRoot() throws Exception {
@@ -105,9 +102,9 @@
         .issuedBy(certB)
         .build();
 
-    CertificateChainCleaner council = new CertificateChainCleaner(
-        new RealTrustRootIndex(root.certificate));
-    assertEquals(list(certC, certB, certA, root), council.clean(list(certC, certA, root, certB)));
+    CertificateChainCleaner cleaner = CertificateChainCleaner.get(root.certificate);
+    assertEquals(list(certC, certB, certA, root),
+        cleaner.clean(list(certC, certA, root, certB), "hostname"));
   }
 
   @Test public void unorderedChainOfCertificatesWithoutRoot() throws Exception {
@@ -127,9 +124,9 @@
         .issuedBy(certB)
         .build();
 
-    CertificateChainCleaner council = new CertificateChainCleaner(
-        new RealTrustRootIndex(root.certificate));
-    assertEquals(list(certC, certB, certA, root), council.clean(list(certC, certA, certB)));
+    CertificateChainCleaner cleaner = CertificateChainCleaner.get(root.certificate);
+    assertEquals(list(certC, certB, certA, root),
+        cleaner.clean(list(certC, certA, certB), "hostname"));
   }
 
   @Test public void unrelatedCertificatesAreOmitted() throws Exception {
@@ -148,10 +145,9 @@
         .serialNumber("4")
         .build();
 
-    CertificateChainCleaner council = new CertificateChainCleaner(
-        new RealTrustRootIndex(root.certificate));
+    CertificateChainCleaner cleaner = CertificateChainCleaner.get(root.certificate);
     assertEquals(list(certB, certA, root),
-        council.clean(list(certB, certUnnecessary, certA, root)));
+        cleaner.clean(list(certB, certUnnecessary, certA, root), "hostname"));
   }
 
   @Test public void chainGoesAllTheWayToSelfSignedRoot() throws Exception {
@@ -171,14 +167,14 @@
         .issuedBy(certA)
         .build();
 
-    CertificateChainCleaner council = new CertificateChainCleaner(
-        new RealTrustRootIndex(selfSigned.certificate, trusted.certificate));
+    CertificateChainCleaner cleaner = CertificateChainCleaner.get(
+        selfSigned.certificate, trusted.certificate);
     assertEquals(list(certB, certA, trusted, selfSigned),
-        council.clean(list(certB, certA)));
+        cleaner.clean(list(certB, certA), "hostname"));
     assertEquals(list(certB, certA, trusted, selfSigned),
-        council.clean(list(certB, certA, trusted)));
+        cleaner.clean(list(certB, certA, trusted), "hostname"));
     assertEquals(list(certB, certA, trusted, selfSigned),
-        council.clean(list(certB, certA, trusted, selfSigned)));
+        cleaner.clean(list(certB, certA, trusted, selfSigned), "hostname"));
   }
 
   @Test public void trustedRootNotSelfSigned() throws Exception {
@@ -198,12 +194,11 @@
         .serialNumber("4")
         .build();
 
-    CertificateChainCleaner council = new CertificateChainCleaner(
-        new RealTrustRootIndex(trusted.certificate));
+    CertificateChainCleaner cleaner = CertificateChainCleaner.get(trusted.certificate);
     assertEquals(list(certificate, intermediateCa, trusted),
-        council.clean(list(certificate, intermediateCa)));
+        cleaner.clean(list(certificate, intermediateCa), "hostname"));
     assertEquals(list(certificate, intermediateCa, trusted),
-        council.clean(list(certificate, intermediateCa, trusted)));
+        cleaner.clean(list(certificate, intermediateCa, trusted), "hostname"));
   }
 
   @Test public void chainMaxLength() throws Exception {
@@ -214,9 +209,9 @@
     }
 
     X509Certificate root = heldCertificates.get(heldCertificates.size() - 1).certificate;
-    CertificateChainCleaner council = new CertificateChainCleaner(new RealTrustRootIndex(root));
-    assertEquals(certificates, council.clean(certificates));
-    assertEquals(certificates, council.clean(certificates.subList(0, 9)));
+    CertificateChainCleaner cleaner = CertificateChainCleaner.get(root);
+    assertEquals(certificates, cleaner.clean(certificates, "hostname"));
+    assertEquals(certificates, cleaner.clean(certificates.subList(0, 9), "hostname"));
   }
 
   @Test public void chainTooLong() throws Exception {
@@ -227,9 +222,9 @@
     }
 
     X509Certificate root = heldCertificates.get(heldCertificates.size() - 1).certificate;
-    CertificateChainCleaner council = new CertificateChainCleaner(new RealTrustRootIndex(root));
+    CertificateChainCleaner cleaner = CertificateChainCleaner.get(root);
     try {
-      council.clean(certificates);
+      cleaner.clean(certificates, "hostname");
       fail();
     } catch (SSLPeerUnverifiedException expected) {
     }
diff --git a/okhttp-tests/src/test/java/okhttp3/CookieTest.java b/okhttp-tests/src/test/java/okhttp3/CookieTest.java
index 9ab211780f..bee549dc7d 100644
--- a/okhttp-tests/src/test/java/okhttp3/CookieTest.java
+++ b/okhttp-tests/src/test/java/okhttp3/CookieTest.java
@@ -399,7 +399,7 @@
     try {
       new Cookie.Builder().hostOnlyDomain(null);
       fail();
-    } catch (IllegalArgumentException expected) {
+    } catch (NullPointerException expected) {
     }
     try {
       new Cookie.Builder().hostOnlyDomain("a/b");
diff --git a/okhttp-tests/src/test/java/okhttp3/InterceptorTest.java b/okhttp-tests/src/test/java/okhttp3/InterceptorTest.java
index dd1f3a977b..287f12a317 100644
--- a/okhttp-tests/src/test/java/okhttp3/InterceptorTest.java
+++ b/okhttp-tests/src/test/java/okhttp3/InterceptorTest.java
@@ -26,6 +26,7 @@
 import okhttp3.mockwebserver.MockResponse;
 import okhttp3.mockwebserver.MockWebServer;
 import okhttp3.mockwebserver.RecordedRequest;
+import okhttp3.mockwebserver.SocketPolicy;
 import okio.Buffer;
 import okio.BufferedSink;
 import okio.ForwardingSink;
@@ -630,6 +631,31 @@ private void interceptorThrowsRuntimeExceptionAsynchronous(boolean network) thro
     }
   }
 
+  @Test public void networkInterceptorReturnsConnectionOnEmptyBody() throws Exception {
+    server.enqueue(new MockResponse()
+        .setSocketPolicy(SocketPolicy.DISCONNECT_AT_END)
+        .addHeader("Connection", "Close"));
+
+    Interceptor interceptor = new Interceptor() {
+      @Override public Response intercept(Chain chain) throws IOException {
+        Response response = chain.proceed(chain.request());
+        assertNotNull(chain.connection());
+        return response;
+      }
+    };
+
+    client = client.newBuilder()
+        .addNetworkInterceptor(interceptor)
+        .build();
+
+    Request request = new Request.Builder()
+        .url(server.url("/"))
+        .build();
+
+    Response response = client.newCall(request).execute();
+    response.body().close();
+  }
+
   private RequestBody uppercase(final RequestBody original) {
     return new RequestBody() {
       @Override public MediaType contentType() {
diff --git a/okhttp-tests/src/test/java/okhttp3/RequestTest.java b/okhttp-tests/src/test/java/okhttp3/RequestTest.java
index 0ef87d6c86..4668f6005d 100644
--- a/okhttp-tests/src/test/java/okhttp3/RequestTest.java
+++ b/okhttp-tests/src/test/java/okhttp3/RequestTest.java
@@ -174,8 +174,31 @@
     }
   }
 
+  @Test public void headerForbidsNullArguments() throws Exception {
+    Request.Builder builder = new Request.Builder();
+    try {
+      builder.header(null, "Value");
+      fail();
+    } catch (NullPointerException expected) {
+    }
+    try {
+      builder.addHeader(null, "Value");
+      fail();
+    } catch (NullPointerException expected) {
+    }
+    try {
+      builder.header("Name", null);
+      fail();
+    } catch (NullPointerException expected) {
+    }
+    try {
+      builder.addHeader("Name", null);
+      fail();
+    } catch (NullPointerException expected) {
+    }
+  }
+
   @Test public void headerForbidsControlCharacters() throws Exception {
-    assertForbiddenHeader(null);
     assertForbiddenHeader("\u0000");
     assertForbiddenHeader("\r");
     assertForbiddenHeader("\n");
diff --git a/okhttp-tests/src/test/java/okhttp3/URLConnectionTest.java b/okhttp-tests/src/test/java/okhttp3/URLConnectionTest.java
index 768adf78fe..c50838c2fa 100644
--- a/okhttp-tests/src/test/java/okhttp3/URLConnectionTest.java
+++ b/okhttp-tests/src/test/java/okhttp3/URLConnectionTest.java
@@ -1596,15 +1596,16 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
         .setBody("Please authenticate.");
     server.enqueue(pleaseAuthenticate);
 
-    urlFactory.setClient(urlFactory.client().newBuilder()
-        .authenticator(new JavaNetAuthenticator())
-        .build());
     if (proxy) {
       urlFactory.setClient(urlFactory.client().newBuilder()
           .proxy(server.toProxyAddress())
+          .proxyAuthenticator(new JavaNetAuthenticator())
           .build());
-      connection = urlFactory.open(new URL("http://android.com"));
+      connection = urlFactory.open(new URL("http://android.com/"));
     } else {
+      urlFactory.setClient(urlFactory.client().newBuilder()
+          .authenticator(new JavaNetAuthenticator())
+          .build());
       connection = urlFactory.open(server.url("/").url());
     }
     assertEquals(responseCode, connection.getResponseCode());
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/DiskLruCacheTest.java b/okhttp-tests/src/test/java/okhttp3/internal/DiskLruCacheTest.java
index 6a559d3b5e..be2d0be61d 100644
--- a/okhttp-tests/src/test/java/okhttp3/internal/DiskLruCacheTest.java
+++ b/okhttp-tests/src/test/java/okhttp3/internal/DiskLruCacheTest.java
@@ -50,7 +50,7 @@
 
 public final class DiskLruCacheTest {
   @Rule public final TemporaryFolder tempDir = new TemporaryFolder();
-  @Rule public final Timeout timeout = new Timeout(30 * 1000);
+  @Rule public final Timeout timeout = new Timeout(60 * 1000);
 
   private final FaultyFileSystem fileSystem = new FaultyFileSystem(FileSystem.SYSTEM);
   private final int appVersion = 100;
@@ -697,6 +697,199 @@ private void createNewCacheWithSize(int maxSize) throws IOException {
     }
   }
 
+  @Test public void rebuildJournalFailurePreventsEditors() throws Exception {
+    while (executor.jobs.isEmpty()) {
+      set("a", "a", "a");
+      set("b", "b", "b");
+    }
+
+    // Cause the rebuild action to fail.
+    fileSystem.setFaultyRename(new File(cacheDir, DiskLruCache.JOURNAL_FILE_BACKUP), true);
+    executor.jobs.removeFirst().run();
+
+    // Don't allow edits under any circumstances.
+    assertNull(cache.edit("a"));
+    assertNull(cache.edit("c"));
+    DiskLruCache.Snapshot snapshot = cache.get("a");
+    assertNull(snapshot.edit());
+    snapshot.close();
+  }
+
+  @Test public void rebuildJournalFailureIsRetried() throws Exception {
+    while (executor.jobs.isEmpty()) {
+      set("a", "a", "a");
+      set("b", "b", "b");
+    }
+
+    // Cause the rebuild action to fail.
+    fileSystem.setFaultyRename(new File(cacheDir, DiskLruCache.JOURNAL_FILE_BACKUP), true);
+    executor.jobs.removeFirst().run();
+
+    // The rebuild is retried on cache hits and on cache edits.
+    DiskLruCache.Snapshot snapshot = cache.get("b");
+    snapshot.close();
+    assertNull(cache.edit("d"));
+    assertEquals(2, executor.jobs.size());
+
+    // On cache misses, no retry job is queued.
+    assertNull(cache.get("c"));
+    assertEquals(2, executor.jobs.size());
+
+    // Let the rebuild complete successfully.
+    fileSystem.setFaultyRename(new File(cacheDir, DiskLruCache.JOURNAL_FILE_BACKUP), false);
+    executor.jobs.removeFirst().run();
+    assertJournalEquals("CLEAN a 1 1", "CLEAN b 1 1");
+  }
+
+  @Test public void rebuildJournalFailureWithInFlightEditors() throws Exception {
+    while (executor.jobs.isEmpty()) {
+      set("a", "a", "a");
+      set("b", "b", "b");
+    }
+    DiskLruCache.Editor commitEditor = cache.edit("c");
+    DiskLruCache.Editor abortEditor = cache.edit("d");
+    cache.edit("e"); // Grab an editor, but don't do anything with it.
+
+    // Cause the rebuild action to fail.
+    fileSystem.setFaultyRename(new File(cacheDir, DiskLruCache.JOURNAL_FILE_BACKUP), true);
+    executor.jobs.removeFirst().run();
+
+    // In-flight editors can commit and have their values retained.
+    setString(commitEditor, 0, "c");
+    setString(commitEditor, 1, "c");
+    commitEditor.commit();
+    assertValue("c", "c", "c");
+
+    abortEditor.abort();
+
+    // Let the rebuild complete successfully.
+    fileSystem.setFaultyRename(new File(cacheDir, DiskLruCache.JOURNAL_FILE_BACKUP), false);
+    executor.jobs.removeFirst().run();
+    assertJournalEquals("CLEAN a 1 1", "CLEAN b 1 1", "DIRTY e", "CLEAN c 1 1");
+  }
+
+  @Test public void rebuildJournalFailureWithEditorsInFlightThenClose() throws Exception {
+    while (executor.jobs.isEmpty()) {
+      set("a", "a", "a");
+      set("b", "b", "b");
+    }
+    DiskLruCache.Editor commitEditor = cache.edit("c");
+    DiskLruCache.Editor abortEditor = cache.edit("d");
+    cache.edit("e"); // Grab an editor, but don't do anything with it.
+
+    // Cause the rebuild action to fail.
+    fileSystem.setFaultyRename(new File(cacheDir, DiskLruCache.JOURNAL_FILE_BACKUP), true);
+    executor.jobs.removeFirst().run();
+
+    setString(commitEditor, 0, "c");
+    setString(commitEditor, 1, "c");
+    commitEditor.commit();
+    assertValue("c", "c", "c");
+
+    abortEditor.abort();
+
+    cache.close();
+    createNewCache();
+
+    // Although 'c' successfully committed above, the journal wasn't available to issue a CLEAN op.
+    // Because the last state of 'c' was DIRTY before the journal failed, it should be removed
+    // entirely on a subsequent open.
+    assertEquals(4, cache.size());
+    assertAbsent("c");
+    assertAbsent("d");
+    assertAbsent("e");
+  }
+
+  @Test public void rebuildJournalFailureAllowsRemovals() throws Exception {
+    while (executor.jobs.isEmpty()) {
+      set("a", "a", "a");
+      set("b", "b", "b");
+    }
+
+    // Cause the rebuild action to fail.
+    fileSystem.setFaultyRename(new File(cacheDir, DiskLruCache.JOURNAL_FILE_BACKUP), true);
+    executor.jobs.removeFirst().run();
+
+    assertTrue(cache.remove("a"));
+    assertAbsent("a");
+
+    // Let the rebuild complete successfully.
+    fileSystem.setFaultyRename(new File(cacheDir, DiskLruCache.JOURNAL_FILE_BACKUP), false);
+    executor.jobs.removeFirst().run();
+
+    assertJournalEquals("CLEAN b 1 1");
+  }
+
+  @Test public void rebuildJournalFailureWithRemovalThenClose() throws Exception {
+    while (executor.jobs.isEmpty()) {
+      set("a", "a", "a");
+      set("b", "b", "b");
+    }
+
+    // Cause the rebuild action to fail.
+    fileSystem.setFaultyRename(new File(cacheDir, DiskLruCache.JOURNAL_FILE_BACKUP), true);
+    executor.jobs.removeFirst().run();
+
+    assertTrue(cache.remove("a"));
+    assertAbsent("a");
+
+    cache.close();
+    createNewCache();
+
+    // The journal will have no record that 'a' was removed. It will have an entry for 'a', but when
+    // it tries to read the cache files, it will find they were deleted. Once it encounters an entry
+    // with missing cache files, it should remove it from the cache entirely.
+    assertEquals(4, cache.size());
+    assertNull(cache.get("a"));
+    assertEquals(2, cache.size());
+  }
+
+  @Test public void rebuildJournalFailureAllowsEvictAll() throws Exception {
+    while (executor.jobs.isEmpty()) {
+      set("a", "a", "a");
+      set("b", "b", "b");
+    }
+
+    // Cause the rebuild action to fail.
+    fileSystem.setFaultyRename(new File(cacheDir, DiskLruCache.JOURNAL_FILE_BACKUP), true);
+    executor.jobs.removeFirst().run();
+
+    cache.evictAll();
+
+    assertEquals(0, cache.size());
+    assertAbsent("a");
+    assertAbsent("b");
+
+    cache.close();
+    createNewCache();
+
+    // The journal has no record that 'a' and 'b' were removed. It will have an entry for both, but
+    // when it tries to read the cache files for either entry, it will discover the cache files are
+    // missing and remove the entries from the cache.
+    assertEquals(4, cache.size());
+    assertNull(cache.get("a"));
+    assertNull(cache.get("b"));
+    assertEquals(0, cache.size());
+  }
+
+  @Test public void rebuildJournalFailureWithCacheTrim() throws Exception {
+    while (executor.jobs.isEmpty()) {
+      set("a", "aa", "aa");
+      set("b", "bb", "bb");
+    }
+
+    // Cause the rebuild action to fail.
+    fileSystem.setFaultyRename(new File(cacheDir, DiskLruCache.JOURNAL_FILE_BACKUP), true);
+    executor.jobs.removeFirst().run();
+
+    // Trigger a job to trim the cache.
+    cache.setMaxSize(4);
+    executor.jobs.removeFirst().run();
+
+    assertAbsent("a");
+    assertValue("b", "bb", "bb");
+  }
+
   @Test public void restoreBackupFile() throws Exception {
     DiskLruCache.Editor creator = cache.edit("k1");
     setString(creator, 0, "ABC");
@@ -763,6 +956,7 @@ private void createNewCacheWithSize(int maxSize) throws IOException {
     set("a", "a", "a");
     fileSystem.delete(getCleanFile("a", 1));
     assertNull(cache.get("a"));
+    assertEquals(0, cache.size());
   }
 
   @Test public void editSameVersion() throws Exception {
@@ -1342,6 +1536,80 @@ private void createNewCacheWithSize(int maxSize) throws IOException {
     assertNull(cache.get("a"));
   }
 
+  @Test public void noSizeCorruptionAfterCreatorDetached() throws Exception {
+    // Create an editor for k1. Detach it by clearing the cache.
+    DiskLruCache.Editor editor = cache.edit("k1");
+    setString(editor, 0, "a");
+    setString(editor, 1, "a");
+    cache.evictAll();
+
+    // Create a new value in its place.
+    set("k1", "bb", "bb");
+    assertEquals(4, cache.size());
+
+    // Committing the detached editor should not change the cache's size.
+    editor.commit();
+    assertEquals(4, cache.size());
+    assertValue("k1", "bb", "bb");
+  }
+
+  @Test public void noSizeCorruptionAfterEditorDetached() throws Exception {
+    set("k1", "a", "a");
+
+    // Create an editor for k1. Detach it by clearing the cache.
+    DiskLruCache.Editor editor = cache.edit("k1");
+    setString(editor, 0, "bb");
+    setString(editor, 1, "bb");
+    cache.evictAll();
+
+    // Create a new value in its place.
+    set("k1", "ccc", "ccc");
+    assertEquals(6, cache.size());
+
+    // Committing the detached editor should not change the cache's size.
+    editor.commit();
+    assertEquals(6, cache.size());
+    assertValue("k1", "ccc", "ccc");
+  }
+
+  @Test public void noNewSourceAfterEditorDetached() throws Exception {
+    set("k1", "a", "a");
+
+    DiskLruCache.Editor editor = cache.edit("k1");
+    cache.evictAll();
+
+    assertNull(editor.newSource(0));
+  }
+
+  @Test public void editsDiscardedAfterEditorDetached() throws Exception {
+    set("k1", "a", "a");
+
+    // Create an editor, then detach it.
+    DiskLruCache.Editor editor = cache.edit("k1");
+    BufferedSink sink = Okio.buffer(editor.newSink(0));
+    cache.evictAll();
+
+    // Create another value in its place.
+    set("k1", "ccc", "ccc");
+
+    // Complete the original edit. It goes into a black hole.
+    sink.writeUtf8("bb");
+    sink.close();
+
+    assertValue("k1", "ccc", "ccc");
+  }
+
+  @Test public void abortAfterDetach() throws Exception {
+    set("k1", "a", "a");
+
+    DiskLruCache.Editor editor = cache.edit("k1");
+    cache.evictAll();
+
+    editor.abort();
+    assertEquals(0, cache.size());
+    assertAbsent("k1");
+  }
+
   private void assertJournalEquals(String... expectedBodyLines) throws Exception {
     List<String> expectedLines = new ArrayList<>();
     expectedLines.add(MAGIC);
@@ -1443,7 +1711,7 @@ private void generateSomeGarbageFiles() throws Exception {
     writeFile(new File(dir2, "otherFile1"), "F");
   }
 
-  private void assertGarbageFilesAllDeleted() throws Exception {
+  private void assertGarbageFilesAllDeleted() {
     assertFalse(fileSystem.exists(getCleanFile("g1", 0)));
     assertFalse(fileSystem.exists(getCleanFile("g1", 1)));
     assertFalse(fileSystem.exists(getCleanFile("g2", 0)));
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/FaultyFileSystem.java b/okhttp-tests/src/test/java/okhttp3/internal/FaultyFileSystem.java
index bd38dced6b..3f237d0ad0 100644
--- a/okhttp-tests/src/test/java/okhttp3/internal/FaultyFileSystem.java
+++ b/okhttp-tests/src/test/java/okhttp3/internal/FaultyFileSystem.java
@@ -30,6 +30,7 @@
   private final FileSystem delegate;
   private final Set<File> writeFaults = new LinkedHashSet<>();
   private final Set<File> deleteFaults = new LinkedHashSet<>();
+  private final Set<File> renameFaults = new LinkedHashSet<>();
 
   public FaultyFileSystem(FileSystem delegate) {
     this.delegate = delegate;
@@ -51,6 +52,14 @@ public void setFaultyDelete(File file, boolean faulty) {
     }
   }
 
+  public void setFaultyRename(File file, boolean faulty) {
+    if (faulty) {
+      renameFaults.add(file);
+    } else {
+      renameFaults.remove(file);
+    }
+  }
+
   @Override public Source source(File file) throws FileNotFoundException {
     return delegate.source(file);
   }
@@ -68,7 +77,7 @@ public void setFaultyDelete(File file, boolean faulty) {
     delegate.delete(file);
   }
 
-  @Override public boolean exists(File file) throws IOException {
+  @Override public boolean exists(File file) {
     return delegate.exists(file);
   }
 
@@ -77,6 +86,7 @@ public void setFaultyDelete(File file, boolean faulty) {
   }
 
   @Override public void rename(File from, File to) throws IOException {
+    if (renameFaults.contains(from) || renameFaults.contains(to)) throw new IOException("boom!");
     delegate.rename(from, to);
   }
 
diff --git a/okhttp-urlconnection/pom.xml b/okhttp-urlconnection/pom.xml
index 322dab6436..2c95ffc6c2 100644
--- a/okhttp-urlconnection/pom.xml
+++ b/okhttp-urlconnection/pom.xml
@@ -6,7 +6,7 @@
   <parent>
     <groupId>com.squareup.okhttp3</groupId>
     <artifactId>parent</artifactId>
-    <version>3.2.0-SNAPSHOT</version>
+    <version>3.3.0-SNAPSHOT</version>
   </parent>
 
   <artifactId>okhttp-urlconnection</artifactId>
diff --git a/okhttp-urlconnection/src/test/java/okhttp3/OkUrlFactoryTest.java b/okhttp-urlconnection/src/test/java/okhttp3/OkUrlFactoryTest.java
index d357807ef3..39f6066805 100644
--- a/okhttp-urlconnection/src/test/java/okhttp3/OkUrlFactoryTest.java
+++ b/okhttp-urlconnection/src/test/java/okhttp3/OkUrlFactoryTest.java
@@ -12,8 +12,8 @@
 import java.util.concurrent.TimeUnit;
 import javax.net.ssl.HttpsURLConnection;
 import javax.net.ssl.SSLContext;
-import okhttp3.internal.URLFilter;
 import okhttp3.internal.SslContextBuilder;
+import okhttp3.internal.URLFilter;
 import okhttp3.internal.http.OkHeaders;
 import okhttp3.internal.io.InMemoryFileSystem;
 import okhttp3.mockwebserver.MockResponse;
diff --git a/okhttp-ws-tests/pom.xml b/okhttp-ws-tests/pom.xml
index cb2972a3f9..783385c8f2 100644
--- a/okhttp-ws-tests/pom.xml
+++ b/okhttp-ws-tests/pom.xml
@@ -6,7 +6,7 @@
   <parent>
     <groupId>com.squareup.okhttp3</groupId>
     <artifactId>parent</artifactId>
-    <version>3.2.0-SNAPSHOT</version>
+    <version>3.3.0-SNAPSHOT</version>
   </parent>
 
   <artifactId>okhttp-ws-tests</artifactId>
diff --git a/okhttp-ws/pom.xml b/okhttp-ws/pom.xml
index 5f9655b39e..e6dbdb5472 100644
--- a/okhttp-ws/pom.xml
+++ b/okhttp-ws/pom.xml
@@ -6,7 +6,7 @@
   <parent>
     <groupId>com.squareup.okhttp3</groupId>
     <artifactId>parent</artifactId>
-    <version>3.2.0-SNAPSHOT</version>
+    <version>3.3.0-SNAPSHOT</version>
   </parent>
 
   <artifactId>okhttp-ws</artifactId>
diff --git a/okhttp/pom.xml b/okhttp/pom.xml
index dc8dad8130..0db4e1a85e 100644
--- a/okhttp/pom.xml
+++ b/okhttp/pom.xml
@@ -6,7 +6,7 @@
   <parent>
     <groupId>com.squareup.okhttp3</groupId>
     <artifactId>parent</artifactId>
-    <version>3.2.0-SNAPSHOT</version>
+    <version>3.3.0-SNAPSHOT</version>
   </parent>
 
   <artifactId>okhttp</artifactId>
diff --git a/okhttp/src/main/java/okhttp3/Address.java b/okhttp/src/main/java/okhttp3/Address.java
index cec154262d..4fd97764a3 100644
--- a/okhttp/src/main/java/okhttp3/Address.java
+++ b/okhttp/src/main/java/okhttp3/Address.java
@@ -57,24 +57,24 @@ public Address(String uriHost, int uriPort, Dns dns, SocketFactory socketFactory
         .port(uriPort)
         .build();
 
-    if (dns == null) throw new IllegalArgumentException("dns == null");
+    if (dns == null) throw new NullPointerException("dns == null");
     this.dns = dns;
 
-    if (socketFactory == null) throw new IllegalArgumentException("socketFactory == null");
+    if (socketFactory == null) throw new NullPointerException("socketFactory == null");
     this.socketFactory = socketFactory;
 
     if (proxyAuthenticator == null) {
-      throw new IllegalArgumentException("proxyAuthenticator == null");
+      throw new NullPointerException("proxyAuthenticator == null");
     }
     this.proxyAuthenticator = proxyAuthenticator;
 
-    if (protocols == null) throw new IllegalArgumentException("protocols == null");
+    if (protocols == null) throw new NullPointerException("protocols == null");
     this.protocols = Util.immutableList(protocols);
 
-    if (connectionSpecs == null) throw new IllegalArgumentException("connectionSpecs == null");
+    if (connectionSpecs == null) throw new NullPointerException("connectionSpecs == null");
     this.connectionSpecs = Util.immutableList(connectionSpecs);
 
-    if (proxySelector == null) throw new IllegalArgumentException("proxySelector == null");
+    if (proxySelector == null) throw new NullPointerException("proxySelector == null");
     this.proxySelector = proxySelector;
 
     this.proxy = proxy;
diff --git a/okhttp/src/main/java/okhttp3/CertificatePinner.java b/okhttp/src/main/java/okhttp3/CertificatePinner.java
index f7a1367649..626b91e774 100644
--- a/okhttp/src/main/java/okhttp3/CertificatePinner.java
+++ b/okhttp/src/main/java/okhttp3/CertificatePinner.java
@@ -24,7 +24,6 @@
 import javax.net.ssl.SSLPeerUnverifiedException;
 import okhttp3.internal.Util;
 import okhttp3.internal.tls.CertificateChainCleaner;
-import okhttp3.internal.tls.TrustRootIndex;
 import okio.ByteString;
 
 /**
@@ -125,11 +124,11 @@
   public static final CertificatePinner DEFAULT = new Builder().build();
 
   private final List<Pin> pins;
-  private final TrustRootIndex trustRootIndex;
+  private final CertificateChainCleaner certificateChainCleaner;
 
-  private CertificatePinner(Builder builder) {
-    this.pins = Util.immutableList(builder.pins);
-    this.trustRootIndex = builder.trustRootIndex;
+  private CertificatePinner(List<Pin> pins, CertificateChainCleaner certificateChainCleaner) {
+    this.pins = pins;
+    this.certificateChainCleaner = certificateChainCleaner;
   }
 
   /**
@@ -145,8 +144,8 @@ public void check(String hostname, List<Certificate> peerCertificates)
     List<Pin> pins = findMatchingPins(hostname);
     if (pins.isEmpty()) return;
 
-    if (trustRootIndex != null) {
-      peerCertificates = new CertificateChainCleaner(trustRootIndex).clean(peerCertificates);
+    if (certificateChainCleaner != null) {
+      peerCertificates = certificateChainCleaner.clean(peerCertificates, hostname);
     }
 
     for (int c = 0, certsSize = peerCertificates.size(); c < certsSize; c++) {
@@ -208,8 +207,11 @@ public void check(String hostname, Certificate... peerCertificates)
     return result;
   }
 
-  Builder newBuilder() {
-    return new Builder(this);
+  /** Returns a certificate pinner that uses {@code certificateChainCleaner}. */
+  CertificatePinner withCertificateChainCleaner(CertificateChainCleaner certificateChainCleaner) {
+    return this.certificateChainCleaner != certificateChainCleaner
+        ? new CertificatePinner(pins, certificateChainCleaner)
+        : this;
   }
 
   /**
@@ -289,20 +291,6 @@ boolean matches(String hostname) {
   /** Builds a configured certificate pinner. */
   public static final class Builder {
     private final List<Pin> pins = new ArrayList<>();
-    private TrustRootIndex trustRootIndex;
-
-    public Builder() {
-    }
-
-    Builder(CertificatePinner certificatePinner) {
-      this.pins.addAll(certificatePinner.pins);
-      this.trustRootIndex = certificatePinner.trustRootIndex;
-    }
-
-    public Builder trustRootIndex(TrustRootIndex trustRootIndex) {
-      this.trustRootIndex = trustRootIndex;
-      return this;
-    }
 
     /**
      * Pins certificates for {@code pattern}.
@@ -312,7 +300,7 @@ public Builder trustRootIndex(TrustRootIndex trustRootIndex) {
      * Info, base64-encoded and prefixed with either {@code sha256/} or {@code sha1/}.
      */
     public Builder add(String pattern, String... pins) {
-      if (pattern == null) throw new IllegalArgumentException("pattern == null");
+      if (pattern == null) throw new NullPointerException("pattern == null");
 
       for (String pin : pins) {
         this.pins.add(new Pin(pattern, pin));
@@ -322,7 +310,7 @@ public Builder add(String pattern, String... pins) {
     }
 
     public CertificatePinner build() {
-      return new CertificatePinner(this);
+      return new CertificatePinner(Util.immutableList(pins), null);
     }
   }
 }
diff --git a/okhttp/src/main/java/okhttp3/Cookie.java b/okhttp/src/main/java/okhttp3/Cookie.java
index 74e341de4d..29a4bf84d1 100644
--- a/okhttp/src/main/java/okhttp3/Cookie.java
+++ b/okhttp/src/main/java/okhttp3/Cookie.java
@@ -75,9 +75,9 @@ private Cookie(String name, String value, long expiresAt, String domain, String
   }
 
   private Cookie(Builder builder) {
-    if (builder.name == null) throw new IllegalArgumentException("builder.name == null");
-    if (builder.value == null) throw new IllegalArgumentException("builder.value == null");
-    if (builder.domain == null) throw new IllegalArgumentException("builder.domain == null");
+    if (builder.name == null) throw new NullPointerException("builder.name == null");
+    if (builder.value == null) throw new NullPointerException("builder.value == null");
+    if (builder.domain == null) throw new NullPointerException("builder.domain == null");
 
     this.name = builder.name;
     this.value = builder.value;
@@ -498,7 +498,7 @@ public Builder hostOnlyDomain(String domain) {
     }
 
     private Builder domain(String domain, boolean hostOnly) {
-      if (domain == null) throw new IllegalArgumentException("domain == null");
+      if (domain == null) throw new NullPointerException("domain == null");
       String canonicalDomain = Util.domainToAscii(domain);
       if (canonicalDomain == null) {
         throw new IllegalArgumentException("unexpected domain: " + domain);
diff --git a/okhttp/src/main/java/okhttp3/Handshake.java b/okhttp/src/main/java/okhttp3/Handshake.java
index 56e1fd4a2e..d2c08be57e 100644
--- a/okhttp/src/main/java/okhttp3/Handshake.java
+++ b/okhttp/src/main/java/okhttp3/Handshake.java
@@ -74,7 +74,7 @@ public static Handshake get(SSLSession session) {
 
   public static Handshake get(TlsVersion tlsVersion, CipherSuite cipherSuite,
       List<Certificate> peerCertificates, List<Certificate> localCertificates) {
-    if (cipherSuite == null) throw new IllegalArgumentException("cipherSuite == null");
+    if (cipherSuite == null) throw new NullPointerException("cipherSuite == null");
     return new Handshake(tlsVersion, cipherSuite, Util.immutableList(peerCertificates),
         Util.immutableList(localCertificates));
   }
diff --git a/okhttp/src/main/java/okhttp3/Headers.java b/okhttp/src/main/java/okhttp3/Headers.java
index 6f72d0cc4d..992569a501 100644
--- a/okhttp/src/main/java/okhttp3/Headers.java
+++ b/okhttp/src/main/java/okhttp3/Headers.java
@@ -148,7 +148,8 @@ private static String get(String[] namesAndValues, String name) {
    * arguments, and they must alternate between header names and values.
    */
   public static Headers of(String... namesAndValues) {
-    if (namesAndValues == null || namesAndValues.length % 2 != 0) {
+    if (namesAndValues == null) throw new NullPointerException("namesAndValues == null");
+    if (namesAndValues.length % 2 != 0) {
       throw new IllegalArgumentException("Expected alternating header names and values");
     }
 
@@ -175,9 +176,7 @@ public static Headers of(String... namesAndValues) {
    * Returns headers for the header names and values in the {@link Map}.
    */
   public static Headers of(Map<String, String> headers) {
-    if (headers == null) {
-      throw new IllegalArgumentException("Expected map with header names and values");
-    }
+    if (headers == null) throw new NullPointerException("headers == null");
 
     // Make a defensive copy and clean it up.
     String[] namesAndValues = new String[headers.size() * 2];
@@ -267,7 +266,7 @@ public Builder set(String name, String value) {
     }
 
     private void checkNameAndValue(String name, String value) {
-      if (name == null) throw new IllegalArgumentException("name == null");
+      if (name == null) throw new NullPointerException("name == null");
       if (name.isEmpty()) throw new IllegalArgumentException("name is empty");
       for (int i = 0, length = name.length(); i < length; i++) {
         char c = name.charAt(i);
@@ -276,7 +275,7 @@ private void checkNameAndValue(String name, String value) {
               "Unexpected char %#04x at %d in header name: %s", (int) c, i, name));
         }
       }
-      if (value == null) throw new IllegalArgumentException("value == null");
+      if (value == null) throw new NullPointerException("value == null");
       for (int i = 0, length = value.length(); i < length; i++) {
         char c = value.charAt(i);
         if (c <= '\u001f' || c >= '\u007f') {
diff --git a/okhttp/src/main/java/okhttp3/HttpUrl.java b/okhttp/src/main/java/okhttp3/HttpUrl.java
index d7c0c35c30..45effb8f6d 100644
--- a/okhttp/src/main/java/okhttp3/HttpUrl.java
+++ b/okhttp/src/main/java/okhttp3/HttpUrl.java
@@ -707,7 +707,7 @@ public Builder() {
 
     public Builder scheme(String scheme) {
       if (scheme == null) {
-        throw new IllegalArgumentException("scheme == null");
+        throw new NullPointerException("scheme == null");
       } else if (scheme.equalsIgnoreCase("http")) {
         this.scheme = "http";
       } else if (scheme.equalsIgnoreCase("https")) {
@@ -719,26 +719,26 @@ public Builder scheme(String scheme) {
     }
 
     public Builder username(String username) {
-      if (username == null) throw new IllegalArgumentException("username == null");
+      if (username == null) throw new NullPointerException("username == null");
       this.encodedUsername = canonicalize(username, USERNAME_ENCODE_SET, false, false, false, true);
       return this;
     }
 
     public Builder encodedUsername(String encodedUsername) {
-      if (encodedUsername == null) throw new IllegalArgumentException("encodedUsername == null");
+      if (encodedUsername == null) throw new NullPointerException("encodedUsername == null");
       this.encodedUsername = canonicalize(
           encodedUsername, USERNAME_ENCODE_SET, true, false, false, true);
       return this;
     }
 
     public Builder password(String password) {
-      if (password == null) throw new IllegalArgumentException("password == null");
+      if (password == null) throw new NullPointerException("password == null");
       this.encodedPassword = canonicalize(password, PASSWORD_ENCODE_SET, false, false, false, true);
       return this;
     }
 
     public Builder encodedPassword(String encodedPassword) {
-      if (encodedPassword == null) throw new IllegalArgumentException("encodedPassword == null");
+      if (encodedPassword == null) throw new NullPointerException("encodedPassword == null");
       this.encodedPassword = canonicalize(
           encodedPassword, PASSWORD_ENCODE_SET, true, false, false, true);
       return this;
@@ -749,7 +749,7 @@ public Builder encodedPassword(String encodedPassword) {
      * address.
      */
     public Builder host(String host) {
-      if (host == null) throw new IllegalArgumentException("host == null");
+      if (host == null) throw new NullPointerException("host == null");
       String encoded = canonicalizeHost(host, 0, host.length());
       if (encoded == null) throw new IllegalArgumentException("unexpected host: " + host);
       this.host = encoded;
@@ -767,7 +767,7 @@ int effectivePort() {
     }
 
     public Builder addPathSegment(String pathSegment) {
-      if (pathSegment == null) throw new IllegalArgumentException("pathSegment == null");
+      if (pathSegment == null) throw new NullPointerException("pathSegment == null");
       push(pathSegment, 0, pathSegment.length(), false, false);
       return this;
     }
@@ -777,13 +777,13 @@ public Builder addPathSegment(String pathSegment) {
      * {@code pathSegments} starts with a slash, the resulting URL will have empty path segment.
      */
     public Builder addPathSegments(String pathSegments) {
-      if (pathSegments == null) throw new IllegalArgumentException("pathSegments == null");
+      if (pathSegments == null) throw new NullPointerException("pathSegments == null");
       return addPathSegments(pathSegments, false);
     }
 
     public Builder addEncodedPathSegment(String encodedPathSegment) {
       if (encodedPathSegment == null) {
-        throw new IllegalArgumentException("encodedPathSegment == null");
+        throw new NullPointerException("encodedPathSegment == null");
       }
       push(encodedPathSegment, 0, encodedPathSegment.length(), false, true);
       return this;
@@ -796,7 +796,7 @@ public Builder addEncodedPathSegment(String encodedPathSegment) {
      */
     public Builder addEncodedPathSegments(String encodedPathSegments) {
       if (encodedPathSegments == null) {
-        throw new IllegalArgumentException("encodedPathSegments == null");
+        throw new NullPointerException("encodedPathSegments == null");
       }
       return addPathSegments(encodedPathSegments, true);
     }
@@ -813,7 +813,7 @@ private Builder addPathSegments(String pathSegments, boolean alreadyEncoded) {
     }
 
     public Builder setPathSegment(int index, String pathSegment) {
-      if (pathSegment == null) throw new IllegalArgumentException("pathSegment == null");
+      if (pathSegment == null) throw new NullPointerException("pathSegment == null");
       String canonicalPathSegment = canonicalize(
           pathSegment, 0, pathSegment.length(), PATH_SEGMENT_ENCODE_SET, false, false, false, true);
       if (isDot(canonicalPathSegment) || isDotDot(canonicalPathSegment)) {
@@ -825,7 +825,7 @@ public Builder setPathSegment(int index, String pathSegment) {
 
     public Builder setEncodedPathSegment(int index, String encodedPathSegment) {
       if (encodedPathSegment == null) {
-        throw new IllegalArgumentException("encodedPathSegment == null");
+        throw new NullPointerException("encodedPathSegment == null");
       }
       String canonicalPathSegment = canonicalize(encodedPathSegment,
           0, encodedPathSegment.length(), PATH_SEGMENT_ENCODE_SET, true, false, false, true);
@@ -845,7 +845,7 @@ public Builder removePathSegment(int index) {
     }
 
     public Builder encodedPath(String encodedPath) {
-      if (encodedPath == null) throw new IllegalArgumentException("encodedPath == null");
+      if (encodedPath == null) throw new NullPointerException("encodedPath == null");
       if (!encodedPath.startsWith("/")) {
         throw new IllegalArgumentException("unexpected encodedPath: " + encodedPath);
       }
@@ -871,7 +871,7 @@ public Builder encodedQuery(String encodedQuery) {
 
     /** Encodes the query parameter using UTF-8 and adds it to this URL's query string. */
     public Builder addQueryParameter(String name, String value) {
-      if (name == null) throw new IllegalArgumentException("name == null");
+      if (name == null) throw new NullPointerException("name == null");
       if (encodedQueryNamesAndValues == null) encodedQueryNamesAndValues = new ArrayList<>();
       encodedQueryNamesAndValues.add(
           canonicalize(name, QUERY_COMPONENT_ENCODE_SET, false, false, true, true));
@@ -883,7 +883,7 @@ public Builder addQueryParameter(String name, String value) {
 
     /** Adds the pre-encoded query parameter to this URL's query string. */
     public Builder addEncodedQueryParameter(String encodedName, String encodedValue) {
-      if (encodedName == null) throw new IllegalArgumentException("encodedName == null");
+      if (encodedName == null) throw new NullPointerException("encodedName == null");
       if (encodedQueryNamesAndValues == null) encodedQueryNamesAndValues = new ArrayList<>();
       encodedQueryNamesAndValues.add(
           canonicalize(encodedName, QUERY_COMPONENT_ENCODE_SET, true, false, true, true));
@@ -906,7 +906,7 @@ public Builder setEncodedQueryParameter(String encodedName, String encodedValue)
     }
 
     public Builder removeAllQueryParameters(String name) {
-      if (name == null) throw new IllegalArgumentException("name == null");
+      if (name == null) throw new NullPointerException("name == null");
       if (encodedQueryNamesAndValues == null) return this;
       String nameToRemove = canonicalize(
           name, QUERY_COMPONENT_ENCODE_SET, false, false, true, true);
@@ -915,7 +915,7 @@ public Builder removeAllQueryParameters(String name) {
     }
 
     public Builder removeAllEncodedQueryParameters(String encodedName) {
-      if (encodedName == null) throw new IllegalArgumentException("encodedName == null");
+      if (encodedName == null) throw new NullPointerException("encodedName == null");
       if (encodedQueryNamesAndValues == null) return this;
       removeAllCanonicalQueryParameters(
           canonicalize(encodedName, QUERY_COMPONENT_ENCODE_SET, true, false, true, true));
diff --git a/okhttp/src/main/java/okhttp3/Interceptor.java b/okhttp/src/main/java/okhttp3/Interceptor.java
index 94effbdf40..c1f8840a3c 100644
--- a/okhttp/src/main/java/okhttp3/Interceptor.java
+++ b/okhttp/src/main/java/okhttp3/Interceptor.java
@@ -19,8 +19,8 @@
 
 /**
  * Observes, modifies, and potentially short-circuits requests going out and the corresponding
- * requests coming back in. Typically interceptors will be used to add, remove, or transform headers
- * on the request or response.
+ * responses coming back in. Typically interceptors add, remove, or transform headers on the request
+ * or response.
  */
 public interface Interceptor {
   Response intercept(Chain chain) throws IOException;
diff --git a/okhttp/src/main/java/okhttp3/OkHttpClient.java b/okhttp/src/main/java/okhttp3/OkHttpClient.java
index 4d5cbce187..8df00c54a4 100644
--- a/okhttp/src/main/java/okhttp3/OkHttpClient.java
+++ b/okhttp/src/main/java/okhttp3/OkHttpClient.java
@@ -20,7 +20,9 @@
 import java.net.ProxySelector;
 import java.net.UnknownHostException;
 import java.security.GeneralSecurityException;
+import java.security.KeyStore;
 import java.util.ArrayList;
+import java.util.Arrays;
 import java.util.List;
 import java.util.concurrent.TimeUnit;
 import javax.net.SocketFactory;
@@ -28,6 +30,8 @@
 import javax.net.ssl.SSLContext;
 import javax.net.ssl.SSLSocket;
 import javax.net.ssl.SSLSocketFactory;
+import javax.net.ssl.TrustManager;
+import javax.net.ssl.TrustManagerFactory;
 import javax.net.ssl.X509TrustManager;
 import okhttp3.internal.Internal;
 import okhttp3.internal.InternalCache;
@@ -36,8 +40,8 @@
 import okhttp3.internal.Util;
 import okhttp3.internal.http.StreamAllocation;
 import okhttp3.internal.io.RealConnection;
+import okhttp3.internal.tls.CertificateChainCleaner;
 import okhttp3.internal.tls.OkHostnameVerifier;
-import okhttp3.internal.tls.TrustRootIndex;
 
 /**
  * Factory for {@linkplain Call calls}, which can be used to send HTTP requests and read their
@@ -133,7 +137,7 @@ public void apply(ConnectionSpec tlsConfiguration, SSLSocket sslSocket, boolean
   final InternalCache internalCache;
   final SocketFactory socketFactory;
   final SSLSocketFactory sslSocketFactory;
-  final TrustRootIndex trustRootIndex;
+  final CertificateChainCleaner certificateChainCleaner;
   final HostnameVerifier hostnameVerifier;
   final CertificatePinner certificatePinner;
   final Authenticator proxyAuthenticator;
@@ -171,30 +175,16 @@ private OkHttpClient(Builder builder) {
 
     if (builder.sslSocketFactory != null || !isTLS) {
       this.sslSocketFactory = builder.sslSocketFactory;
+      this.certificateChainCleaner = builder.certificateChainCleaner;
     } else {
-      try {
-        SSLContext sslContext = SSLContext.getInstance("TLS");
-        sslContext.init(null, null, null);
-        this.sslSocketFactory = sslContext.getSocketFactory();
-      } catch (GeneralSecurityException e) {
-        throw new AssertionError(); // The system has no TLS. Just give up.
-      }
-    }
-    if (sslSocketFactory != null && builder.trustRootIndex == null) {
-      X509TrustManager trustManager = Platform.get().trustManager(sslSocketFactory);
-      if (trustManager == null) {
-        throw new IllegalStateException("Unable to extract the trust manager on " + Platform.get()
-            + ", sslSocketFactory is " + sslSocketFactory.getClass());
-      }
-      this.trustRootIndex = Platform.get().trustRootIndex(trustManager);
-      this.certificatePinner = builder.certificatePinner.newBuilder()
-          .trustRootIndex(trustRootIndex)
-          .build();
-    } else {
-      this.trustRootIndex = builder.trustRootIndex;
-      this.certificatePinner = builder.certificatePinner;
+      X509TrustManager trustManager = systemDefaultTrustManager();
+      this.sslSocketFactory = systemDefaultSslSocketFactory(trustManager);
+      this.certificateChainCleaner = CertificateChainCleaner.get(trustManager);
     }
+
     this.hostnameVerifier = builder.hostnameVerifier;
+    this.certificatePinner = builder.certificatePinner.withCertificateChainCleaner(
+        certificateChainCleaner);
     this.proxyAuthenticator = builder.proxyAuthenticator;
     this.authenticator = builder.authenticator;
     this.connectionPool = builder.connectionPool;
@@ -207,6 +197,32 @@ private OkHttpClient(Builder builder) {
     this.writeTimeout = builder.writeTimeout;
   }
 
+  private X509TrustManager systemDefaultTrustManager() {
+    try {
+      TrustManagerFactory trustManagerFactory = TrustManagerFactory.getInstance(
+          TrustManagerFactory.getDefaultAlgorithm());
+      trustManagerFactory.init((KeyStore) null);
+      TrustManager[] trustManagers = trustManagerFactory.getTrustManagers();
+      if (trustManagers.length != 1 || !(trustManagers[0] instanceof X509TrustManager)) {
+        throw new IllegalStateException("Unexpected default trust managers:"
+            + Arrays.toString(trustManagers));
+      }
+      return (X509TrustManager) trustManagers[0];
+    } catch (GeneralSecurityException e) {
+      throw new AssertionError(); // The system has no TLS. Just give up.
+    }
+  }
+
+  private SSLSocketFactory systemDefaultSslSocketFactory(X509TrustManager trustManager) {
+    try {
+      SSLContext sslContext = SSLContext.getInstance("TLS");
+      sslContext.init(null, new TrustManager[] { trustManager }, null);
+      return sslContext.getSocketFactory();
+    } catch (GeneralSecurityException e) {
+      throw new AssertionError(); // The system has no TLS. Just give up.
+    }
+  }
+
   /** Default connect timeout (in milliseconds). */
   public int connectTimeoutMillis() {
     return connectTimeout;
@@ -340,7 +356,7 @@ public Builder newBuilder() {
     InternalCache internalCache;
     SocketFactory socketFactory;
     SSLSocketFactory sslSocketFactory;
-    TrustRootIndex trustRootIndex;
+    CertificateChainCleaner certificateChainCleaner;
     HostnameVerifier hostnameVerifier;
     CertificatePinner certificatePinner;
     Authenticator proxyAuthenticator;
@@ -388,7 +404,7 @@ public Builder() {
       this.cache = okHttpClient.cache;
       this.socketFactory = okHttpClient.socketFactory;
       this.sslSocketFactory = okHttpClient.sslSocketFactory;
-      this.trustRootIndex = okHttpClient.trustRootIndex;
+      this.certificateChainCleaner = okHttpClient.certificateChainCleaner;
       this.hostnameVerifier = okHttpClient.hostnameVerifier;
       this.certificatePinner = okHttpClient.certificatePinner;
       this.proxyAuthenticator = okHttpClient.proxyAuthenticator;
@@ -410,7 +426,7 @@ public Builder() {
      */
     public Builder connectTimeout(long timeout, TimeUnit unit) {
       if (timeout < 0) throw new IllegalArgumentException("timeout < 0");
-      if (unit == null) throw new IllegalArgumentException("unit == null");
+      if (unit == null) throw new NullPointerException("unit == null");
       long millis = unit.toMillis(timeout);
       if (millis > Integer.MAX_VALUE) throw new IllegalArgumentException("Timeout too large.");
       if (millis == 0 && timeout > 0) throw new IllegalArgumentException("Timeout too small.");
@@ -424,7 +440,7 @@ public Builder connectTimeout(long timeout, TimeUnit unit) {
      */
     public Builder readTimeout(long timeout, TimeUnit unit) {
       if (timeout < 0) throw new IllegalArgumentException("timeout < 0");
-      if (unit == null) throw new IllegalArgumentException("unit == null");
+      if (unit == null) throw new NullPointerException("unit == null");
       long millis = unit.toMillis(timeout);
       if (millis > Integer.MAX_VALUE) throw new IllegalArgumentException("Timeout too large.");
       if (millis == 0 && timeout > 0) throw new IllegalArgumentException("Timeout too small.");
@@ -438,7 +454,7 @@ public Builder readTimeout(long timeout, TimeUnit unit) {
      */
     public Builder writeTimeout(long timeout, TimeUnit unit) {
       if (timeout < 0) throw new IllegalArgumentException("timeout < 0");
-      if (unit == null) throw new IllegalArgumentException("unit == null");
+      if (unit == null) throw new NullPointerException("unit == null");
       long millis = unit.toMillis(timeout);
       if (millis > Integer.MAX_VALUE) throw new IllegalArgumentException("Timeout too large.");
       if (millis == 0 && timeout > 0) throw new IllegalArgumentException("Timeout too small.");
@@ -519,14 +535,62 @@ public Builder socketFactory(SocketFactory socketFactory) {
     }
 
     /**
-     * Sets the socket factory used to secure HTTPS connections.
+     * Sets the socket factory used to secure HTTPS connections. If unset, the system default will
+     * be used.
      *
-     * <p>If unset, a lazily created SSL socket factory will be used.
+     * @deprecated {@code SSLSocketFactory} does not expose its {@link X509TrustManager}, which is
+     *     a field that OkHttp needs to build a clean certificate chain. This method instead must
+     *     use reflection to extract the trust manager. Applications should prefer to call {@link
+     *     #sslSocketFactory(SSLSocketFactory, X509TrustManager)}, which avoids such reflection.
      */
     public Builder sslSocketFactory(SSLSocketFactory sslSocketFactory) {
       if (sslSocketFactory == null) throw new NullPointerException("sslSocketFactory == null");
+      X509TrustManager trustManager = Platform.get().trustManager(sslSocketFactory);
+      if (trustManager == null) {
+        throw new IllegalStateException("Unable to extract the trust manager on " + Platform.get()
+            + ", sslSocketFactory is " + sslSocketFactory.getClass());
+      }
+      this.sslSocketFactory = sslSocketFactory;
+      this.certificateChainCleaner = CertificateChainCleaner.get(trustManager);
+      return this;
+    }
+
+    /**
+     * Sets the socket factory and trust manager used to secure HTTPS connections. If unset, the
+     * system defaults will be used.
+     *
+     * <p>Most applications should not call this method, and instead use the system defaults. Those
+     * classes include special optimizations that can be lost if the implementations are decorated.
+     *
+     * <p>If necessary, you can create and configure the defaults yourself with the following code:
+     *
+     * <pre>   {@code
+     *
+     *   TrustManagerFactory trustManagerFactory = TrustManagerFactory.getInstance(
+     *       TrustManagerFactory.getDefaultAlgorithm());
+     *   trustManagerFactory.init((KeyStore) null);
+     *   TrustManager[] trustManagers = trustManagerFactory.getTrustManagers();
+     *   if (trustManagers.length != 1 || !(trustManagers[0] instanceof X509TrustManager)) {
+     *     throw new IllegalStateException("Unexpected default trust managers:"
+     *         + Arrays.toString(trustManagers));
+     *   }
+     *   X509TrustManager trustManager = (X509TrustManager) trustManagers[0];
+     *
+     *   SSLContext sslContext = SSLContext.getInstance("TLS");
+     *   sslContext.init(null, new TrustManager[] { trustManager }, null);
+     *   SSLSocketFactory sslSocketFactory = sslContext.getSocketFactory();
+     *
+     *   OkHttpClient client = new OkHttpClient.Builder()
+     *       .sslSocketFactory(sslSocketFactory, trustManager);
+     *       .build();
+     * }</pre>
+     */
+    public Builder sslSocketFactory(
+        SSLSocketFactory sslSocketFactory, X509TrustManager trustManager) {
+      if (sslSocketFactory == null) throw new NullPointerException("sslSocketFactory == null");
+      if (trustManager == null) throw new NullPointerException("trustManager == null");
       this.sslSocketFactory = sslSocketFactory;
-      this.trustRootIndex = null;
+      this.certificateChainCleaner = CertificateChainCleaner.get(trustManager);
       return this;
     }
 
diff --git a/okhttp/src/main/java/okhttp3/Request.java b/okhttp/src/main/java/okhttp3/Request.java
index 2daa0ab9b3..89188ec587 100644
--- a/okhttp/src/main/java/okhttp3/Request.java
+++ b/okhttp/src/main/java/okhttp3/Request.java
@@ -15,7 +15,6 @@
  */
 package okhttp3;
 
-import java.net.URI;
 import java.net.URL;
 import java.util.List;
 import okhttp3.internal.http.HttpMethod;
@@ -31,7 +30,6 @@
   private final RequestBody body;
   private final Object tag;
 
-  private volatile URI javaNetUri; // Lazily initialized.
   private volatile CacheControl cacheControl; // Lazily initialized.
 
   private Request(Builder builder) {
@@ -118,7 +116,7 @@ private Builder(Request request) {
     }
 
     public Builder url(HttpUrl url) {
-      if (url == null) throw new IllegalArgumentException("url == null");
+      if (url == null) throw new NullPointerException("url == null");
       this.url = url;
       return this;
     }
@@ -130,7 +128,7 @@ public Builder url(HttpUrl url) {
      * exception by calling {@link HttpUrl#parse}; it returns null for invalid URLs.
      */
     public Builder url(String url) {
-      if (url == null) throw new IllegalArgumentException("url == null");
+      if (url == null) throw new NullPointerException("url == null");
 
       // Silently replace websocket URLs with HTTP URLs.
       if (url.regionMatches(true, 0, "ws:", 0, 3)) {
@@ -151,7 +149,7 @@ public Builder url(String url) {
      * https}.
      */
     public Builder url(URL url) {
-      if (url == null) throw new IllegalArgumentException("url == null");
+      if (url == null) throw new NullPointerException("url == null");
       HttpUrl parsed = HttpUrl.get(url);
       if (parsed == null) throw new IllegalArgumentException("unexpected url: " + url);
       return url(parsed);
@@ -229,9 +227,8 @@ public Builder patch(RequestBody body) {
     }
 
     public Builder method(String method, RequestBody body) {
-      if (method == null || method.length() == 0) {
-        throw new IllegalArgumentException("method == null || method.length() == 0");
-      }
+      if (method == null) throw new NullPointerException("method == null");
+      if (method.length() == 0) throw new IllegalArgumentException("method.length() == 0");
       if (body != null && !HttpMethod.permitsRequestBody(method)) {
         throw new IllegalArgumentException("method " + method + " must not have a request body.");
       }
diff --git a/okhttp/src/main/java/okhttp3/Response.java b/okhttp/src/main/java/okhttp3/Response.java
index 7a2d717e22..7a3d80264b 100644
--- a/okhttp/src/main/java/okhttp3/Response.java
+++ b/okhttp/src/main/java/okhttp3/Response.java
@@ -157,6 +157,9 @@ public ResponseBody peekBody(long byteCount) throws IOException {
     return ResponseBody.create(body.contentType(), result.size(), result);
   }
 
+  /**
+   * Never {@code null}, must be closed after consumption, can be consumed only once.
+   */
   public ResponseBody body() {
     return body;
   }
diff --git a/okhttp/src/main/java/okhttp3/internal/DiskLruCache.java b/okhttp/src/main/java/okhttp3/internal/DiskLruCache.java
index 1be6a93b4f..51ce88e9fc 100644
--- a/okhttp/src/main/java/okhttp3/internal/DiskLruCache.java
+++ b/okhttp/src/main/java/okhttp3/internal/DiskLruCache.java
@@ -152,6 +152,7 @@
   private boolean initialized;
   private boolean closed;
   private boolean mostRecentTrimFailed;
+  private boolean mostRecentRebuildFailed;
 
   /**
    * To differentiate between old and current snapshots, each entry is given a sequence number each
@@ -181,7 +182,8 @@ public void run() {
             redundantOpCount = 0;
           }
         } catch (IOException e) {
-          throw new RuntimeException(e);
+          mostRecentRebuildFailed = true;
+          journalWriter = Okio.buffer(NULL_SINK);
         }
       }
     }
@@ -414,6 +416,7 @@ private synchronized void rebuildJournal() throws IOException {
 
     journalWriter = newJournalWriter();
     hasJournalErrors = false;
+    mostRecentRebuildFailed = false;
   }
 
   /**
@@ -460,8 +463,12 @@ private synchronized Editor edit(String key, long expectedSequenceNumber) throws
     if (entry != null && entry.currentEditor != null) {
       return null; // Another edit is in progress.
     }
-    if (mostRecentTrimFailed) {
-      // Prevent new writes so the cache doesn't grow any further and retry the clean up operation.
+    if (mostRecentTrimFailed || mostRecentRebuildFailed) {
+      // The OS has become our enemy! If the trim job failed, it means we are storing more data than
+      // requested by the user. Do not allow edits so we do not go over that limit any further. If
+      // the journal rebuild failed, the journal writer will not be active, meaning we will not be
+      // able to record the edit, causing file leaks. In both cases, we want to retry the clean up
+      // so we can get out of this state!
       executor.execute(cleanupRunnable);
       return null;
     }
@@ -605,7 +612,7 @@ public synchronized boolean remove(String key) throws IOException {
 
   private boolean removeEntry(Entry entry) throws IOException {
     if (entry.currentEditor != null) {
-      entry.currentEditor.hasErrors = true; // Prevent the edit from completing normally.
+      entry.currentEditor.detach(); // Prevent the edit from completing normally.
     }
 
     for (int i = 0; i < valueCount; i++) {
@@ -831,24 +838,42 @@ public void close() {
   public final class Editor {
     private final Entry entry;
     private final boolean[] written;
-    private boolean hasErrors;
-    private boolean committed;
+    private boolean done;
 
     private Editor(Entry entry) {
       this.entry = entry;
       this.written = (entry.readable) ? null : new boolean[valueCount];
     }
 
+    /**
+     * Prevents this editor from completing normally. This is necessary either when the edit causes
+     * an I/O error, or if the target entry is evicted while this editor is active. In either case
+     * we delete the editor's created files and prevent new files from being created. Note that once
+     * an editor has been detached it is possible for another editor to edit the entry.
+     */
+    void detach() {
+      if (entry.currentEditor == this) {
+        for (int i = 0; i < valueCount; i++) {
+          try {
+            fileSystem.delete(entry.dirtyFiles[i]);
+          } catch (IOException e) {
+            // This file is potentially leaked. Not much we can do about that.
+          }
+        }
+        entry.currentEditor = null;
+      }
+    }
+
     /**
      * Returns an unbuffered input stream to read the last committed value, or null if no value has
      * been committed.
      */
     public Source newSource(int index) throws IOException {
       synchronized (DiskLruCache.this) {
-        if (entry.currentEditor != this) {
+        if (done) {
           throw new IllegalStateException();
         }
-        if (!entry.readable) {
+        if (!entry.readable || entry.currentEditor != this) {
           return null;
         }
         try {
@@ -866,9 +891,12 @@ public Source newSource(int index) throws IOException {
      */
     public Sink newSink(int index) throws IOException {
       synchronized (DiskLruCache.this) {
-        if (entry.currentEditor != this) {
+        if (done) {
           throw new IllegalStateException();
         }
+        if (entry.currentEditor != this) {
+          return NULL_SINK;
+        }
         if (!entry.readable) {
           written[index] = true;
         }
@@ -882,7 +910,7 @@ public Sink newSink(int index) throws IOException {
         return new FaultHidingSink(sink) {
           @Override protected void onException(IOException e) {
             synchronized (DiskLruCache.this) {
-              hasErrors = true;
+              detach();
             }
           }
         };
@@ -895,13 +923,13 @@ public Sink newSink(int index) throws IOException {
      */
     public void commit() throws IOException {
       synchronized (DiskLruCache.this) {
-        if (hasErrors) {
-          completeEdit(this, false);
-          removeEntry(entry); // The previous entry is stale.
-        } else {
+        if (done) {
+          throw new IllegalStateException();
+        }
+        if (entry.currentEditor == this) {
           completeEdit(this, true);
         }
-        committed = true;
+        done = true;
       }
     }
 
@@ -911,13 +939,19 @@ public void commit() throws IOException {
      */
     public void abort() throws IOException {
       synchronized (DiskLruCache.this) {
-        completeEdit(this, false);
+        if (done) {
+          throw new IllegalStateException();
+        }
+        if (entry.currentEditor == this) {
+          completeEdit(this, false);
+        }
+        done = true;
       }
     }
 
     public void abortUnlessCommitted() {
       synchronized (DiskLruCache.this) {
-        if (!committed) {
+        if (!done && entry.currentEditor == this) {
           try {
             completeEdit(this, false);
           } catch (IOException ignored) {
@@ -1013,6 +1047,12 @@ Snapshot snapshot() {
             break;
           }
         }
+        // Since the entry is no longer valid, remove it so the metadata is accurate (i.e. the cache
+        // size.)
+        try {
+          removeEntry(this);
+        } catch (IOException ignored) {
+        }
         return null;
       }
     }
diff --git a/okhttp/src/main/java/okhttp3/internal/Platform.java b/okhttp/src/main/java/okhttp3/internal/Platform.java
index 91568ab4ff..2125c991d4 100644
--- a/okhttp/src/main/java/okhttp3/internal/Platform.java
+++ b/okhttp/src/main/java/okhttp3/internal/Platform.java
@@ -32,9 +32,6 @@
 import javax.net.ssl.SSLSocketFactory;
 import javax.net.ssl.X509TrustManager;
 import okhttp3.Protocol;
-import okhttp3.internal.tls.AndroidTrustRootIndex;
-import okhttp3.internal.tls.RealTrustRootIndex;
-import okhttp3.internal.tls.TrustRootIndex;
 import okio.Buffer;
 
 import static okhttp3.internal.Internal.logger;
@@ -96,10 +93,6 @@ public X509TrustManager trustManager(SSLSocketFactory sslSocketFactory) {
     }
   }
 
-  public TrustRootIndex trustRootIndex(X509TrustManager trustManager) {
-    return new RealTrustRootIndex(trustManager.getAcceptedIssuers());
-  }
-
   /**
    * Configure TLS extensions on {@code sslSocket} for {@code route}.
    *
@@ -243,12 +236,6 @@ public Android(Class<?> sslParametersClass, OptionalMethod<Socket> setUseSession
       return readFieldOrNull(context, X509TrustManager.class, "trustManager");
     }
 
-    @Override public TrustRootIndex trustRootIndex(X509TrustManager trustManager) {
-      TrustRootIndex result = AndroidTrustRootIndex.get(trustManager);
-      if (result != null) return result;
-      return super.trustRootIndex(trustManager);
-    }
-
     @Override public void configureTlsExtensions(
         SSLSocket sslSocket, String hostname, List<Protocol> protocols) {
       // Enable SNI and session tickets.
diff --git a/okhttp/src/main/java/okhttp3/internal/http/HttpEngine.java b/okhttp/src/main/java/okhttp3/internal/http/HttpEngine.java
index b7c9f6432f..514ee65eb6 100644
--- a/okhttp/src/main/java/okhttp3/internal/http/HttpEngine.java
+++ b/okhttp/src/main/java/okhttp3/internal/http/HttpEngine.java
@@ -560,7 +560,8 @@ public void readResponse() throws IOException {
       httpStream.writeRequestHeaders(networkRequest);
       networkResponse = readNetworkResponse();
     } else if (!callerWritesRequestBody) {
-      networkResponse = new NetworkInterceptorChain(0, networkRequest).proceed(networkRequest);
+      networkResponse = new NetworkInterceptorChain(0, networkRequest,
+          streamAllocation.connection()).proceed(networkRequest);
     } else {
       // Emit the request body's buffer so that everything is in requestBodyOut.
       if (bufferedRequestBody != null && bufferedRequestBody.buffer().size() > 0) {
@@ -638,15 +639,17 @@ public void readResponse() throws IOException {
   class NetworkInterceptorChain implements Interceptor.Chain {
     private final int index;
     private final Request request;
+    private final Connection connection;
     private int calls;
 
-    NetworkInterceptorChain(int index, Request request) {
+    NetworkInterceptorChain(int index, Request request, Connection connection) {
       this.index = index;
       this.request = request;
+      this.connection = connection;
     }
 
     @Override public Connection connection() {
-      return streamAllocation.connection();
+      return connection;
     }
 
     @Override public Request request() {
@@ -676,7 +679,7 @@ public void readResponse() throws IOException {
 
       if (index < client.networkInterceptors().size()) {
         // There's another interceptor in the chain. Call that.
-        NetworkInterceptorChain chain = new NetworkInterceptorChain(index + 1, request);
+        NetworkInterceptorChain chain = new NetworkInterceptorChain(index + 1, request, connection);
         Interceptor interceptor = client.networkInterceptors().get(index);
         Response interceptedResponse = interceptor.intercept(chain);
 
@@ -888,7 +891,8 @@ public Request followUpRequest() throws IOException {
         if (selectedProxy.type() != Proxy.Type.HTTP) {
           throw new ProtocolException("Received HTTP_PROXY_AUTH (407) code while not using proxy");
         }
-        // fall-through
+        return client.proxyAuthenticator().authenticate(route, userResponse);
+
       case HTTP_UNAUTHORIZED:
         return client.authenticator().authenticate(route, userResponse);
 
diff --git a/okhttp/src/main/java/okhttp3/internal/io/FileSystem.java b/okhttp/src/main/java/okhttp3/internal/io/FileSystem.java
index 6a786954b3..0b1b1cfbc4 100644
--- a/okhttp/src/main/java/okhttp3/internal/io/FileSystem.java
+++ b/okhttp/src/main/java/okhttp3/internal/io/FileSystem.java
@@ -71,7 +71,7 @@
       }
     }
 
-    @Override public boolean exists(File file) throws IOException {
+    @Override public boolean exists(File file) {
       return file.exists();
     }
 
@@ -121,7 +121,7 @@
   void delete(File file) throws IOException;
 
   /** Returns true if {@code file} exists on the file system. */
-  boolean exists(File file) throws IOException;
+  boolean exists(File file);
 
   /** Returns the number of bytes stored in {@code file}, or 0 if it does not exist. */
   long size(File file);
diff --git a/okhttp/src/main/java/okhttp3/internal/tls/AndroidTrustRootIndex.java b/okhttp/src/main/java/okhttp3/internal/tls/AndroidTrustRootIndex.java
deleted file mode 100644
index 3074a1e98d..0000000000
--- a/okhttp/src/main/java/okhttp3/internal/tls/AndroidTrustRootIndex.java
+++ /dev/null
@@ -1,65 +0,0 @@
-/*
- * Copyright (C) 2016 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.internal.tls;
-
-import java.lang.reflect.InvocationTargetException;
-import java.lang.reflect.Method;
-import java.security.cert.TrustAnchor;
-import java.security.cert.X509Certificate;
-import javax.net.ssl.X509TrustManager;
-
-/**
- * A index of trusted root certificates that exploits knowledge of Android implementation details.
- * This class is potentially much faster to initialize than {@link RealTrustRootIndex} because
- * it doesn't need to load and index trusted CA certificates.
- */
-public final class AndroidTrustRootIndex implements TrustRootIndex {
-  private final X509TrustManager trustManager;
-  private final Method findByIssuerAndSignatureMethod;
-
-  public AndroidTrustRootIndex(
-      X509TrustManager trustManager, Method findByIssuerAndSignatureMethod) {
-    this.findByIssuerAndSignatureMethod = findByIssuerAndSignatureMethod;
-    this.trustManager = trustManager;
-  }
-
-  @Override public X509Certificate findByIssuerAndSignature(X509Certificate cert) {
-    try {
-      TrustAnchor trustAnchor = (TrustAnchor) findByIssuerAndSignatureMethod.invoke(
-          trustManager, cert);
-      return trustAnchor != null
-          ? trustAnchor.getTrustedCert()
-          : null;
-    } catch (IllegalAccessException e) {
-      throw new AssertionError();
-    } catch (InvocationTargetException e) {
-      return null;
-    }
-  }
-
-  public static TrustRootIndex get(X509TrustManager trustManager) {
-    // From org.conscrypt.TrustManagerImpl, we want the method with this signature:
-    // private TrustAnchor findTrustAnchorByIssuerAndSignature(X509Certificate lastCert);
-    try {
-      Method method = trustManager.getClass().getDeclaredMethod(
-          "findTrustAnchorByIssuerAndSignature", X509Certificate.class);
-      method.setAccessible(true);
-      return new AndroidTrustRootIndex(trustManager, method);
-    } catch (NoSuchMethodException e) {
-      return null;
-    }
-  }
-}
diff --git a/okhttp/src/main/java/okhttp3/internal/tls/CertificateChainCleaner.java b/okhttp/src/main/java/okhttp3/internal/tls/CertificateChainCleaner.java
index d887df615c..672e48651b 100644
--- a/okhttp/src/main/java/okhttp3/internal/tls/CertificateChainCleaner.java
+++ b/okhttp/src/main/java/okhttp3/internal/tls/CertificateChainCleaner.java
@@ -16,6 +16,9 @@
  */
 package okhttp3.internal.tls;
 
+import java.lang.reflect.Constructor;
+import java.lang.reflect.InvocationTargetException;
+import java.lang.reflect.Method;
 import java.security.GeneralSecurityException;
 import java.security.cert.Certificate;
 import java.security.cert.X509Certificate;
@@ -25,6 +28,7 @@
 import java.util.Iterator;
 import java.util.List;
 import javax.net.ssl.SSLPeerUnverifiedException;
+import javax.net.ssl.X509TrustManager;
 
 /**
  * Computes the effective certificate chain from the raw array returned by Java's built in TLS APIs.
@@ -35,83 +39,143 @@
  * <p>Use of the chain cleaner is necessary to omit unexpected certificates that aren't relevant to
  * the TLS handshake and to extract the trusted CA certificate for the benefit of certificate
  * pinning.
- *
- * <p>This class includes code from <a href="https://conscrypt.org/">Conscrypt's</a> {@code
- * TrustManagerImpl} and {@code TrustedCertificateIndex}.
  */
-public final class CertificateChainCleaner {
-  /** The maximum number of signers in a chain. We use 9 for consistency with OpenSSL. */
-  private static final int MAX_SIGNERS = 9;
+public abstract class CertificateChainCleaner {
+  public abstract List<Certificate> clean(List<Certificate> chain, String hostname)
+      throws SSLPeerUnverifiedException;
 
-  private final TrustRootIndex trustRootIndex;
+  public static CertificateChainCleaner get(X509TrustManager trustManager) {
+    try {
+      Class<?> extensionsClass = Class.forName("android.net.http.X509TrustManagerExtensions");
+      Constructor<?> constructor = extensionsClass.getConstructor(X509TrustManager.class);
+      Object extensions = constructor.newInstance(trustManager);
+      Method checkServerTrusted = extensionsClass.getMethod(
+          "checkServerTrusted", X509Certificate[].class, String.class, String.class);
+      return new AndroidCertificateChainCleaner(extensions, checkServerTrusted);
+    } catch (Exception e) {
+      return new BasicCertificateChainCleaner(TrustRootIndex.get(trustManager));
+    }
+  }
 
-  public CertificateChainCleaner(TrustRootIndex trustRootIndex) {
-    this.trustRootIndex = trustRootIndex;
+  public static CertificateChainCleaner get(X509Certificate... caCerts) {
+    return new BasicCertificateChainCleaner(TrustRootIndex.get(caCerts));
   }
 
   /**
-   * Returns a cleaned chain for {@code chain}.
+   * A certificate chain cleaner that uses a set of trusted root certificates to build the trusted
+   * chain. This class duplicates the clean chain building performed during the TLS handshake. We
+   * prefer other mechanisms where they exist, such as with {@link AndroidCertificateChainCleaner}.
    *
-   * <p>This method throws if the complete chain to a trusted CA certificate cannot be constructed.
-   * This is unexpected unless the trust root index in this class has a different trust manager than
-   * what was used to establish {@code chain}.
+   * <p>This class includes code from <a href="https://conscrypt.org/">Conscrypt's</a> {@code
+   * TrustManagerImpl} and {@code TrustedCertificateIndex}.
    */
-  public List<Certificate> clean(List<Certificate> chain) throws SSLPeerUnverifiedException {
-    Deque<Certificate> queue = new ArrayDeque<>(chain);
-    List<Certificate> result = new ArrayList<>();
-    result.add(queue.removeFirst());
-    boolean foundTrustedCertificate = false;
-
-    followIssuerChain:
-    for (int c = 0; c < MAX_SIGNERS; c++) {
-      X509Certificate toVerify = (X509Certificate) result.get(result.size() - 1);
-
-      // If this cert has been signed by a trusted cert, use that. Add the trusted certificate to
-      // the end of the chain unless it's already present. (That would happen if the first
-      // certificate in the chain is itself a self-signed and trusted CA certificate.)
-      X509Certificate trustedCert = trustRootIndex.findByIssuerAndSignature(toVerify);
-      if (trustedCert != null) {
-        if (result.size() > 1 || !toVerify.equals(trustedCert)) {
-          result.add(trustedCert);
+  static final class BasicCertificateChainCleaner extends CertificateChainCleaner {
+    /** The maximum number of signers in a chain. We use 9 for consistency with OpenSSL. */
+    private static final int MAX_SIGNERS = 9;
+
+    private final TrustRootIndex trustRootIndex;
+
+    public BasicCertificateChainCleaner(TrustRootIndex trustRootIndex) {
+      this.trustRootIndex = trustRootIndex;
+    }
+
+    /**
+     * Returns a cleaned chain for {@code chain}.
+     *
+     * <p>This method throws if the complete chain to a trusted CA certificate cannot be
+     * constructed. This is unexpected unless the trust root index in this class has a different
+     * trust manager than what was used to establish {@code chain}.
+     */
+    @Override public List<Certificate> clean(List<Certificate> chain, String hostname)
+        throws SSLPeerUnverifiedException {
+      Deque<Certificate> queue = new ArrayDeque<>(chain);
+      List<Certificate> result = new ArrayList<>();
+      result.add(queue.removeFirst());
+      boolean foundTrustedCertificate = false;
+
+      followIssuerChain:
+      for (int c = 0; c < MAX_SIGNERS; c++) {
+        X509Certificate toVerify = (X509Certificate) result.get(result.size() - 1);
+
+        // If this cert has been signed by a trusted cert, use that. Add the trusted certificate to
+        // the end of the chain unless it's already present. (That would happen if the first
+        // certificate in the chain is itself a self-signed and trusted CA certificate.)
+        X509Certificate trustedCert = trustRootIndex.findByIssuerAndSignature(toVerify);
+        if (trustedCert != null) {
+          if (result.size() > 1 || !toVerify.equals(trustedCert)) {
+            result.add(trustedCert);
+          }
+          if (verifySignature(trustedCert, trustedCert)) {
+            return result; // The self-signed cert is a root CA. We're done.
+          }
+          foundTrustedCertificate = true;
+          continue;
         }
-        if (verifySignature(trustedCert, trustedCert)) {
-          return result; // The self-signed cert is a root CA. We're done.
+
+        // Search for the certificate in the chain that signed this certificate. This is typically
+        // the next element in the chain, but it could be any element.
+        for (Iterator<Certificate> i = queue.iterator(); i.hasNext(); ) {
+          X509Certificate signingCert = (X509Certificate) i.next();
+          if (verifySignature(toVerify, signingCert)) {
+            i.remove();
+            result.add(signingCert);
+            continue followIssuerChain;
+          }
         }
-        foundTrustedCertificate = true;
-        continue;
-      }
 
-      // Search for the certificate in the chain that signed this certificate. This is typically the
-      // next element in the chain, but it could be any element.
-      for (Iterator<Certificate> i = queue.iterator(); i.hasNext(); ) {
-        X509Certificate signingCert = (X509Certificate) i.next();
-        if (verifySignature(toVerify, signingCert)) {
-          i.remove();
-          result.add(signingCert);
-          continue followIssuerChain;
+        // We've reached the end of the chain. If any cert in the chain is trusted, we're done.
+        if (foundTrustedCertificate) {
+          return result;
         }
-      }
 
-      // We've reached the end of the chain. If any cert in the chain is trusted, we're done.
-      if (foundTrustedCertificate) {
-        return result;
+        // The last link isn't trusted. Fail.
+        throw new SSLPeerUnverifiedException(
+            "Failed to find a trusted cert that signed " + toVerify);
       }
 
-      // The last link isn't trusted. Fail.
-      throw new SSLPeerUnverifiedException("Failed to find a trusted cert that signed " + toVerify);
+      throw new SSLPeerUnverifiedException("Certificate chain too long: " + result);
     }
 
-    throw new SSLPeerUnverifiedException("Certificate chain too long: " + result);
+    /** Returns true if {@code toVerify} was signed by {@code signingCert}'s public key. */
+    private boolean verifySignature(X509Certificate toVerify, X509Certificate signingCert) {
+      if (!toVerify.getIssuerDN().equals(signingCert.getSubjectDN())) return false;
+      try {
+        toVerify.verify(signingCert.getPublicKey());
+        return true;
+      } catch (GeneralSecurityException verifyFailed) {
+        return false;
+      }
+    }
   }
 
-  /** Returns true if {@code toVerify} was signed by {@code signingCert}'s public key. */
-  private boolean verifySignature(X509Certificate toVerify, X509Certificate signingCert) {
-    if (!toVerify.getIssuerDN().equals(signingCert.getSubjectDN())) return false;
-    try {
-      toVerify.verify(signingCert.getPublicKey());
-      return true;
-    } catch (GeneralSecurityException verifyFailed) {
-      return false;
+  /**
+   * X509TrustManagerExtensions was added to Android in API 17 (Android 4.2, released in late 2012).
+   * This is the best way to get a clean chain on Android because it uses the same code as the TLS
+   * handshake.
+   */
+  static final class AndroidCertificateChainCleaner extends CertificateChainCleaner {
+    private final Object x509TrustManagerExtensions;
+    private final Method checkServerTrusted;
+
+    AndroidCertificateChainCleaner(Object x509TrustManagerExtensions, Method checkServerTrusted) {
+      this.x509TrustManagerExtensions = x509TrustManagerExtensions;
+      this.checkServerTrusted = checkServerTrusted;
+    }
+
+    @SuppressWarnings({"unchecked", "SuspiciousToArrayCall"}) // Reflection on List<Certificate>.
+    @Override public List<Certificate> clean(List<Certificate> chain, String hostname)
+        throws SSLPeerUnverifiedException {
+      try {
+        X509Certificate[] certificates = chain.toArray(new X509Certificate[chain.size()]);
+        return (List<Certificate>) checkServerTrusted.invoke(
+            x509TrustManagerExtensions, certificates, "RSA", hostname);
+      } catch (InvocationTargetException e) {
+        SSLPeerUnverifiedException exception = new SSLPeerUnverifiedException(e.getMessage());
+        exception.initCause(e);
+        throw exception;
+      } catch (IllegalAccessException e) {
+        throw new AssertionError(e);
+      }
     }
   }
 }
diff --git a/okhttp/src/main/java/okhttp3/internal/tls/RealTrustRootIndex.java b/okhttp/src/main/java/okhttp3/internal/tls/RealTrustRootIndex.java
deleted file mode 100644
index fb688328f5..0000000000
--- a/okhttp/src/main/java/okhttp3/internal/tls/RealTrustRootIndex.java
+++ /dev/null
@@ -1,58 +0,0 @@
-/*
- * Copyright (C) 2016 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.internal.tls;
-
-import java.security.PublicKey;
-import java.security.cert.X509Certificate;
-import java.util.ArrayList;
-import java.util.LinkedHashMap;
-import java.util.List;
-import java.util.Map;
-import javax.security.auth.x500.X500Principal;
-
-public final class RealTrustRootIndex implements TrustRootIndex {
-  private final Map<X500Principal, List<X509Certificate>> subjectToCaCerts;
-
-  public RealTrustRootIndex(X509Certificate... caCerts) {
-    subjectToCaCerts = new LinkedHashMap<>();
-    for (X509Certificate caCert : caCerts) {
-      X500Principal subject = caCert.getSubjectX500Principal();
-      List<X509Certificate> subjectCaCerts = subjectToCaCerts.get(subject);
-      if (subjectCaCerts == null) {
-        subjectCaCerts = new ArrayList<>(1);
-        subjectToCaCerts.put(subject, subjectCaCerts);
-      }
-      subjectCaCerts.add(caCert);
-    }
-  }
-
-  @Override public X509Certificate findByIssuerAndSignature(X509Certificate cert) {
-    X500Principal issuer = cert.getIssuerX500Principal();
-    List<X509Certificate> subjectCaCerts = subjectToCaCerts.get(issuer);
-    if (subjectCaCerts == null) return null;
-
-    for (X509Certificate caCert : subjectCaCerts) {
-      PublicKey publicKey = caCert.getPublicKey();
-      try {
-        cert.verify(publicKey);
-        return caCert;
-      } catch (Exception ignored) {
-      }
-    }
-
-    return null;
-  }
-}
diff --git a/okhttp/src/main/java/okhttp3/internal/tls/TrustRootIndex.java b/okhttp/src/main/java/okhttp3/internal/tls/TrustRootIndex.java
index 499f120e33..fcc7468e0e 100644
--- a/okhttp/src/main/java/okhttp3/internal/tls/TrustRootIndex.java
+++ b/okhttp/src/main/java/okhttp3/internal/tls/TrustRootIndex.java
@@ -15,9 +15,104 @@
  */
 package okhttp3.internal.tls;
 
+import java.lang.reflect.InvocationTargetException;
+import java.lang.reflect.Method;
+import java.security.PublicKey;
+import java.security.cert.TrustAnchor;
 import java.security.cert.X509Certificate;
+import java.util.ArrayList;
+import java.util.LinkedHashMap;
+import java.util.List;
+import java.util.Map;
+import javax.net.ssl.X509TrustManager;
+import javax.security.auth.x500.X500Principal;
 
-public interface TrustRootIndex {
+public abstract class TrustRootIndex {
   /** Returns the trusted CA certificate that signed {@code cert}. */
-  X509Certificate findByIssuerAndSignature(X509Certificate cert);
+  abstract X509Certificate findByIssuerAndSignature(X509Certificate cert);
+
+  public static TrustRootIndex get(X509TrustManager trustManager) {
+    try {
+      // From org.conscrypt.TrustManagerImpl, we want the method with this signature:
+      // private TrustAnchor findTrustAnchorByIssuerAndSignature(X509Certificate lastCert);
+      Method method = trustManager.getClass().getDeclaredMethod(
+          "findTrustAnchorByIssuerAndSignature", X509Certificate.class);
+      method.setAccessible(true);
+      return new AndroidTrustRootIndex(trustManager, method);
+    } catch (NoSuchMethodException e) {
+      return get(trustManager.getAcceptedIssuers());
+    }
+  }
+
+  public static TrustRootIndex get(X509Certificate... caCerts) {
+    return new BasicTrustRootIndex(caCerts);
+  }
+
+  /**
+   * An index of trusted root certificates that exploits knowledge of Android implementation
+   * details. This class is potentially much faster to initialize than {@link BasicTrustRootIndex}
+   * because it doesn't need to load and index trusted CA certificates.
+   *
+   * <p>This class uses APIs added to Android in API 14 (Android 4.0, released October 2011). This
+   * class shouldn't be used in Android API 17 or better because those releases are better served by
+   * {@link CertificateChainCleaner.AndroidCertificateChainCleaner}.
+   */
+  static final class AndroidTrustRootIndex extends TrustRootIndex {
+    private final X509TrustManager trustManager;
+    private final Method findByIssuerAndSignatureMethod;
+
+    AndroidTrustRootIndex(X509TrustManager trustManager, Method findByIssuerAndSignatureMethod) {
+      this.findByIssuerAndSignatureMethod = findByIssuerAndSignatureMethod;
+      this.trustManager = trustManager;
+    }
+
+    @Override public X509Certificate findByIssuerAndSignature(X509Certificate cert) {
+      try {
+        TrustAnchor trustAnchor = (TrustAnchor) findByIssuerAndSignatureMethod.invoke(
+            trustManager, cert);
+        return trustAnchor != null
+            ? trustAnchor.getTrustedCert()
+            : null;
+      } catch (IllegalAccessException e) {
+        throw new AssertionError();
+      } catch (InvocationTargetException e) {
+        return null;
+      }
+    }
+  }
+
+  /** A simple index that of trusted root certificates that have been loaded into memory. */
+  static final class BasicTrustRootIndex extends TrustRootIndex {
+    private final Map<X500Principal, List<X509Certificate>> subjectToCaCerts;
+
+    public BasicTrustRootIndex(X509Certificate... caCerts) {
+      subjectToCaCerts = new LinkedHashMap<>();
+      for (X509Certificate caCert : caCerts) {
+        X500Principal subject = caCert.getSubjectX500Principal();
+        List<X509Certificate> subjectCaCerts = subjectToCaCerts.get(subject);
+        if (subjectCaCerts == null) {
+          subjectCaCerts = new ArrayList<>(1);
+          subjectToCaCerts.put(subject, subjectCaCerts);
+        }
+        subjectCaCerts.add(caCert);
+      }
+    }
+
+    @Override public X509Certificate findByIssuerAndSignature(X509Certificate cert) {
+      X500Principal issuer = cert.getIssuerX500Principal();
+      List<X509Certificate> subjectCaCerts = subjectToCaCerts.get(issuer);
+      if (subjectCaCerts == null) return null;
+
+      for (X509Certificate caCert : subjectCaCerts) {
+        PublicKey publicKey = caCert.getPublicKey();
+        try {
+          cert.verify(publicKey);
+          return caCert;
+        } catch (Exception ignored) {
+        }
+      }
+
+      return null;
+    }
+  }
 }
diff --git a/pom.xml b/pom.xml
index 90500efd4e..52c283ed13 100644
--- a/pom.xml
+++ b/pom.xml
@@ -11,7 +11,7 @@
 
   <groupId>com.squareup.okhttp3</groupId>
   <artifactId>parent</artifactId>
-  <version>3.2.0-SNAPSHOT</version>
+  <version>3.3.0-SNAPSHOT</version>
   <packaging>pom</packaging>
 
   <name>OkHttp (Parent)</name>
diff --git a/samples/crawler/pom.xml b/samples/crawler/pom.xml
index 80c803d86a..0daef2b940 100644
--- a/samples/crawler/pom.xml
+++ b/samples/crawler/pom.xml
@@ -6,7 +6,7 @@
   <parent>
     <groupId>com.squareup.okhttp3.sample</groupId>
     <artifactId>sample-parent</artifactId>
-    <version>3.2.0-SNAPSHOT</version>
+    <version>3.3.0-SNAPSHOT</version>
   </parent>
 
   <artifactId>crawler</artifactId>
diff --git a/samples/guide/pom.xml b/samples/guide/pom.xml
index b2d38e5fb6..cb497502f2 100644
--- a/samples/guide/pom.xml
+++ b/samples/guide/pom.xml
@@ -6,7 +6,7 @@
   <parent>
     <groupId>com.squareup.okhttp3.sample</groupId>
     <artifactId>sample-parent</artifactId>
-    <version>3.2.0-SNAPSHOT</version>
+    <version>3.3.0-SNAPSHOT</version>
   </parent>
 
   <artifactId>guide</artifactId>
diff --git a/samples/guide/src/main/java/okhttp3/recipes/CustomTrust.java b/samples/guide/src/main/java/okhttp3/recipes/CustomTrust.java
index 6fe27a3933..0ee606cbf0 100644
--- a/samples/guide/src/main/java/okhttp3/recipes/CustomTrust.java
+++ b/samples/guide/src/main/java/okhttp3/recipes/CustomTrust.java
@@ -19,13 +19,16 @@
 import java.io.InputStream;
 import java.security.GeneralSecurityException;
 import java.security.KeyStore;
-import java.security.SecureRandom;
 import java.security.cert.Certificate;
 import java.security.cert.CertificateFactory;
+import java.util.Arrays;
 import java.util.Collection;
 import javax.net.ssl.KeyManagerFactory;
 import javax.net.ssl.SSLContext;
+import javax.net.ssl.SSLSocketFactory;
+import javax.net.ssl.TrustManager;
 import javax.net.ssl.TrustManagerFactory;
+import javax.net.ssl.X509TrustManager;
 import okhttp3.CertificatePinner;
 import okhttp3.Headers;
 import okhttp3.OkHttpClient;
@@ -37,9 +40,19 @@
   private final OkHttpClient client;
 
   public CustomTrust() {
-    SSLContext sslContext = sslContextForTrustedCertificates(trustedCertificatesInputStream());
+    X509TrustManager trustManager;
+    SSLSocketFactory sslSocketFactory;
+    try {
+      trustManager = trustManagerForCertificates(trustedCertificatesInputStream());
+      SSLContext sslContext = SSLContext.getInstance("TLS");
+      sslContext.init(null, new TrustManager[] { trustManager }, null);
+      sslSocketFactory = sslContext.getSocketFactory();
+    } catch (GeneralSecurityException e) {
+      throw new RuntimeException(e);
+    }
+
     client = new OkHttpClient.Builder()
-        .sslSocketFactory(sslContext.getSocketFactory())
+        .sslSocketFactory(sslSocketFactory, trustManager)
         .build();
   }
 
@@ -139,7 +152,7 @@ private InputStream trustedCertificatesInputStream() {
   }
 
   /**
-   * Returns a SSL context that trusts {@code certificates} and none other. HTTPS services whose
+   * Returns a trust manager that trusts {@code certificates} and none other. HTTPS services whose
    * certificates have not been signed by these certificates will fail with a {@code
    * SSLHandshakeException}.
    *
@@ -158,37 +171,36 @@ private InputStream trustedCertificatesInputStream() {
    * not use custom trusted certificates in production without the blessing of your server's TLS
    * administrator.
    */
-  public SSLContext sslContextForTrustedCertificates(InputStream in) {
-    try {
-      CertificateFactory certificateFactory = CertificateFactory.getInstance("X.509");
-      Collection<? extends Certificate> certificates = certificateFactory.generateCertificates(in);
-      if (certificates.isEmpty()) {
-        throw new IllegalArgumentException("expected non-empty set of trusted certificates");
-      }
+  private X509TrustManager trustManagerForCertificates(InputStream in)
+      throws GeneralSecurityException {
+    CertificateFactory certificateFactory = CertificateFactory.getInstance("X.509");
+    Collection<? extends Certificate> certificates = certificateFactory.generateCertificates(in);
+    if (certificates.isEmpty()) {
+      throw new IllegalArgumentException("expected non-empty set of trusted certificates");
+    }
 
-      // Put the certificates a key store.
-      char[] password = "password".toCharArray(); // Any password will work.
-      KeyStore keyStore = newEmptyKeyStore(password);
-      int index = 0;
-      for (Certificate certificate : certificates) {
-        String certificateAlias = Integer.toString(index++);
-        keyStore.setCertificateEntry(certificateAlias, certificate);
-      }
+    // Put the certificates a key store.
+    char[] password = "password".toCharArray(); // Any password will work.
+    KeyStore keyStore = newEmptyKeyStore(password);
+    int index = 0;
+    for (Certificate certificate : certificates) {
+      String certificateAlias = Integer.toString(index++);
+      keyStore.setCertificateEntry(certificateAlias, certificate);
+    }
 
-      // Wrap it up in an SSL context.
-      KeyManagerFactory keyManagerFactory = KeyManagerFactory.getInstance(
-          KeyManagerFactory.getDefaultAlgorithm());
-      keyManagerFactory.init(keyStore, password);
-      TrustManagerFactory trustManagerFactory = TrustManagerFactory.getInstance(
-          TrustManagerFactory.getDefaultAlgorithm());
-      trustManagerFactory.init(keyStore);
-      SSLContext sslContext = SSLContext.getInstance("TLS");
-      sslContext.init(keyManagerFactory.getKeyManagers(), trustManagerFactory.getTrustManagers(),
-          new SecureRandom());
-      return sslContext;
-    } catch (GeneralSecurityException e) {
-      throw new RuntimeException(e);
+    // Use it to build an X509 trust manager.
+    KeyManagerFactory keyManagerFactory = KeyManagerFactory.getInstance(
+        KeyManagerFactory.getDefaultAlgorithm());
+    keyManagerFactory.init(keyStore, password);
+    TrustManagerFactory trustManagerFactory = TrustManagerFactory.getInstance(
+        TrustManagerFactory.getDefaultAlgorithm());
+    trustManagerFactory.init(keyStore);
+    TrustManager[] trustManagers = trustManagerFactory.getTrustManagers();
+    if (trustManagers.length != 1 || !(trustManagers[0] instanceof X509TrustManager)) {
+      throw new IllegalStateException("Unexpected default trust managers:"
+          + Arrays.toString(trustManagers));
     }
+    return (X509TrustManager) trustManagers[0];
   }
 
   private KeyStore newEmptyKeyStore(char[] password) throws GeneralSecurityException {
diff --git a/samples/pom.xml b/samples/pom.xml
index d6f08bcb5e..4c484cbf13 100644
--- a/samples/pom.xml
+++ b/samples/pom.xml
@@ -6,7 +6,7 @@
   <parent>
     <groupId>com.squareup.okhttp3</groupId>
     <artifactId>parent</artifactId>
-    <version>3.2.0-SNAPSHOT</version>
+    <version>3.3.0-SNAPSHOT</version>
   </parent>
 
   <groupId>com.squareup.okhttp3.sample</groupId>
diff --git a/samples/simple-client/pom.xml b/samples/simple-client/pom.xml
index d255e16775..1e40e2ea19 100644
--- a/samples/simple-client/pom.xml
+++ b/samples/simple-client/pom.xml
@@ -6,7 +6,7 @@
   <parent>
     <groupId>com.squareup.okhttp3.sample</groupId>
     <artifactId>sample-parent</artifactId>
-    <version>3.2.0-SNAPSHOT</version>
+    <version>3.3.0-SNAPSHOT</version>
   </parent>
 
   <artifactId>simple-client</artifactId>
diff --git a/samples/static-server/pom.xml b/samples/static-server/pom.xml
index c32ea5c1c1..f9e5101f9c 100644
--- a/samples/static-server/pom.xml
+++ b/samples/static-server/pom.xml
@@ -6,7 +6,7 @@
   <parent>
     <groupId>com.squareup.okhttp3.sample</groupId>
     <artifactId>sample-parent</artifactId>
-    <version>3.2.0-SNAPSHOT</version>
+    <version>3.3.0-SNAPSHOT</version>
   </parent>
 
   <artifactId>static-server</artifactId>
