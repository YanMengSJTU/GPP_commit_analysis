diff --git a/CHANGELOG.md b/CHANGELOG.md
index 5c5aa522fb..647c1581d4 100644
--- a/CHANGELOG.md
+++ b/CHANGELOG.md
@@ -1,6 +1,20 @@
 Change Log
 ==========
 
+## Version 4.2.1
+
+_2019-10-02_
+
+ *  Fix: In 4.1.0 we introduced a performance regression that prevented connections from being
+    pooled in certain situations. We have good test coverage for connection pooling but we missed
+    this because it only occurs if you have proxy configured and you share a connection pool among
+    multiple `OkHttpClient` instances.
+
+    This particularly-subtle bug was caused by us assigning each `OkHttpClient` instance its own
+    `NullProxySelector` when an explicit proxy is configured. But we don't share connections when
+    the proxy selectors are different. Ugh!
+
+
 ## Version 4.2.0
 
 _2019-09-10_
diff --git a/README.md b/README.md
index 3b9e7a708f..b70a70c3a5 100644
--- a/README.md
+++ b/README.md
@@ -100,7 +100,7 @@ Releases
 Our [change log][changelog] has release history.
 
 ```kotlin
-implementation("com.squareup.okhttp3:okhttp:4.2.0")
+implementation("com.squareup.okhttp3:okhttp:4.2.1")
 ```
 
 Snapshot builds are [available][snap].
@@ -120,7 +120,7 @@ MockWebServer
 OkHttp includes a library for testing HTTP, HTTPS, and HTTP/2 clients.
 
 ```kotlin
-testImplementation("com.squareup.okhttp3:mockwebserver:4.2.0")
+testImplementation("com.squareup.okhttp3:mockwebserver:4.2.1")
 ```
 
 
diff --git a/build.gradle b/build.gradle
index 02466bc312..e490a1cbfa 100644
--- a/build.gradle
+++ b/build.gradle
@@ -131,7 +131,7 @@ subprojects { project ->
     }
   }
 
-  def platform = System.getProperty("okhttp.platform", "jdk8")
+  def platform = System.getProperty("okhttp.platform", "jdk9")
   def platformJavaHome = System.getProperty('test.java.home')
 
   test {
diff --git a/mockwebserver/README.md b/mockwebserver/README.md
index 454b760a0e..b6d2443dc6 100644
--- a/mockwebserver/README.md
+++ b/mockwebserver/README.md
@@ -142,7 +142,7 @@ server.setDispatcher(dispatcher);
 ### Download
 
 ```kotlin
-testImplementation("com.squareup.okhttp3:mockwebserver:4.2.0")
+testImplementation("com.squareup.okhttp3:mockwebserver:4.2.1")
 ```
 
 ### License
diff --git a/mockwebserver/src/main/java/okhttp3/mockwebserver/MockWebServer.kt b/mockwebserver/src/main/java/okhttp3/mockwebserver/MockWebServer.kt
index 8371a81314..a8ef919334 100644
--- a/mockwebserver/src/main/java/okhttp3/mockwebserver/MockWebServer.kt
+++ b/mockwebserver/src/main/java/okhttp3/mockwebserver/MockWebServer.kt
@@ -459,7 +459,7 @@ class MockWebServer : ExternalResource(), Closeable {
 
     for (queue in taskRunner.activeQueues()) {
       if (!queue.awaitIdle(TimeUnit.MILLISECONDS.toNanos(500L))) {
-        throw IOException("Gave up waiting for ${queue.owner} to shut down")
+        throw IOException("Gave up waiting for queue to shut down")
       }
     }
   }
diff --git a/okhttp-brotli/README.md b/okhttp-brotli/README.md
index 27bdc13619..6ed3f15371 100644
--- a/okhttp-brotli/README.md
+++ b/okhttp-brotli/README.md
@@ -14,7 +14,7 @@ OkHttpClient client = new OkHttpClient.Builder()
 ```
 
 ```kotlin
-implementation("com.squareup.okhttp3:okhttp-brotli:4.2.0")
+implementation("com.squareup.okhttp3:okhttp-brotli:4.2.1")
 ```
 
  [1]: https://github.com/google/brotli
diff --git a/okhttp-dnsoverhttps/README.md b/okhttp-dnsoverhttps/README.md
index 92e3cc0df8..638671f38b 100644
--- a/okhttp-dnsoverhttps/README.md
+++ b/okhttp-dnsoverhttps/README.md
@@ -7,5 +7,5 @@ API is not considered stable and may change at any time.
 ### Download
 
 ```kotlin
-testImplementation("com.squareup.okhttp3:okhttp-dnsoverhttps:4.2.0")
+testImplementation("com.squareup.okhttp3:okhttp-dnsoverhttps:4.2.1")
 ```
diff --git a/okhttp-logging-interceptor/README.md b/okhttp-logging-interceptor/README.md
index 358938ed2d..2007278869 100644
--- a/okhttp-logging-interceptor/README.md
+++ b/okhttp-logging-interceptor/README.md
@@ -37,7 +37,7 @@ Download
 --------
 
 ```kotlin
-implementation("com.squareup.okhttp3:logging-interceptor:4.2.0")
+implementation("com.squareup.okhttp3:logging-interceptor:4.2.1")
 ```
 
 
diff --git a/okhttp-sse/README.md b/okhttp-sse/README.md
index 18168bcf09..cf64bc1f8a 100644
--- a/okhttp-sse/README.md
+++ b/okhttp-sse/README.md
@@ -7,5 +7,5 @@ API is not considered stable and may change at any time.
 ### Download
 
 ```kotlin
-testImplementation("com.squareup.okhttp3:okhttp-sse:4.2.0")
+testImplementation("com.squareup.okhttp3:okhttp-sse:4.2.1")
 ```
diff --git a/okhttp-testing-support/src/main/java/okhttp3/OkHttpClientTestRule.kt b/okhttp-testing-support/src/main/java/okhttp3/OkHttpClientTestRule.kt
index ed0ef26d7a..933d986a1e 100644
--- a/okhttp-testing-support/src/main/java/okhttp3/OkHttpClientTestRule.kt
+++ b/okhttp-testing-support/src/main/java/okhttp3/OkHttpClientTestRule.kt
@@ -69,7 +69,7 @@ class OkHttpClientTestRule : TestRule {
   private fun ensureAllTaskQueuesIdle() {
     for (queue in TaskRunner.INSTANCE.activeQueues()) {
       assertThat(queue.awaitIdle(TimeUnit.MILLISECONDS.toNanos(500L)))
-          .withFailMessage("Queue ${queue.owner} still active after 500ms")
+          .withFailMessage("Queue still active after 500ms")
           .isTrue()
     }
   }
diff --git a/okhttp-tls/README.md b/okhttp-tls/README.md
index ecdcc38137..52a4bfc321 100644
--- a/okhttp-tls/README.md
+++ b/okhttp-tls/README.md
@@ -227,7 +227,7 @@ Download
 --------
 
 ```kotlin
-implementation("com.squareup.okhttp3:okhttp-tls:4.2.0")
+implementation("com.squareup.okhttp3:okhttp-tls:4.2.1")
 ```
 
  [held_certificate]: http://square.github.io/okhttp/4.x/okhttp-tls/okhttp3.tls/-held-certificate/
diff --git a/okhttp-urlconnection/README.md b/okhttp-urlconnection/README.md
index 74dac40dc0..56064181cb 100644
--- a/okhttp-urlconnection/README.md
+++ b/okhttp-urlconnection/README.md
@@ -6,5 +6,5 @@ This module integrates OkHttp with `Authenticator` and `CookieHandler` from `jav
 ### Download
 
 ```kotlin
-testImplementation("com.squareup.okhttp3:okhttp-urlconnection:4.2.0")
+testImplementation("com.squareup.okhttp3:okhttp-urlconnection:4.2.1")
 ```
diff --git a/okhttp/src/main/java/okhttp3/OkHttpClient.kt b/okhttp/src/main/java/okhttp3/OkHttpClient.kt
index ffc23c8013..b7056985b1 100644
--- a/okhttp/src/main/java/okhttp3/OkHttpClient.kt
+++ b/okhttp/src/main/java/okhttp3/OkHttpClient.kt
@@ -163,9 +163,9 @@ open class OkHttpClient internal constructor(
 
   @get:JvmName("proxySelector") val proxySelector: ProxySelector =
       when {
-        // Avoid possible SecurityException from ProxySelector.getDefault
-        builder.proxy != null -> NullProxySelector()
-        else -> builder.proxySelector ?: ProxySelector.getDefault() ?: NullProxySelector()
+        // Defer calls to ProxySelector.getDefault() because it can throw a SecurityException.
+        builder.proxy != null -> NullProxySelector
+        else -> builder.proxySelector ?: ProxySelector.getDefault() ?: NullProxySelector
       }
 
   @get:JvmName("proxyAuthenticator") val proxyAuthenticator: Authenticator =
diff --git a/okhttp/src/main/java/okhttp3/internal/cache/DiskLruCache.kt b/okhttp/src/main/java/okhttp3/internal/cache/DiskLruCache.kt
index ea756eed0f..15ea1f8915 100644
--- a/okhttp/src/main/java/okhttp3/internal/cache/DiskLruCache.kt
+++ b/okhttp/src/main/java/okhttp3/internal/cache/DiskLruCache.kt
@@ -167,8 +167,8 @@ class DiskLruCache internal constructor(
    */
   private var nextSequenceNumber: Long = 0
 
-  private val cleanupQueue = taskRunner.newQueue(this)
-  private val cleanupTask = object : Task("OkHttp DiskLruCache") {
+  private val cleanupQueue = taskRunner.newQueue()
+  private val cleanupTask = object : Task("OkHttp DiskLruCache", cancelable = false) {
     override fun runOnce(): Long {
       synchronized(this@DiskLruCache) {
         if (!initialized || closed) {
diff --git a/okhttp/src/main/java/okhttp3/internal/concurrent/Task.kt b/okhttp/src/main/java/okhttp3/internal/concurrent/Task.kt
index 64c836b736..1100df057c 100644
--- a/okhttp/src/main/java/okhttp3/internal/concurrent/Task.kt
+++ b/okhttp/src/main/java/okhttp3/internal/concurrent/Task.kt
@@ -18,13 +18,6 @@ package okhttp3.internal.concurrent
 /**
  * A unit of work that can be executed one or more times.
  *
- * Cancellation
- * ------------
- *
- * Tasks control their cancellation. If the hosting queue is canceled, the [Task.tryCancel] function
- * returns true if the task should skip the next-scheduled execution. Note that canceling a task is
- * not permanent; it is okay to schedule a task after it has been canceled.
- *
  * Recurrence
  * ----------
  *
@@ -35,6 +28,18 @@ package okhttp3.internal.concurrent
  * earliest one wins. This applies to both executions scheduled with [TaskRunner.Queue.schedule] and
  * those implied by the returned execution delay.
  *
+ * Cancellation
+ * ------------
+ *
+ * Tasks may be canceled while they are waiting to be executed, or while they are executing.
+ *
+ * Canceling a task that is waiting to execute prevents that upcoming execution. Canceling a task
+ * that is currently executing does not impact the ongoing run, but it does prevent a recurrence
+ * from being scheduled.
+ *
+ * Tasks may opt-out of cancellation with `cancelable = false`. Such tasks will recur until they
+ * decide not to by returning -1L.
+ *
  * Task Queues
  * -----------
  *
@@ -42,7 +47,8 @@ package okhttp3.internal.concurrent
  * within it never execute concurrently. It is an error to use a task in multiple queues.
  */
 abstract class Task(
-  val name: String
+  val name: String,
+  val cancelable: Boolean = true
 ) {
   // Guarded by the TaskRunner.
   internal var queue: TaskQueue? = null
@@ -51,14 +57,10 @@ abstract class Task(
   internal var nextExecuteNanoTime = -1L
 
   internal var runRunnable: Runnable? = null
-  internal var cancelRunnable: Runnable? = null
 
   /** Returns the delay in nanoseconds until the next execution, or -1L to not reschedule. */
   abstract fun runOnce(): Long
 
-  /** Return true to skip the scheduled execution. */
-  open fun tryCancel(): Boolean = false
-
   internal fun initQueue(queue: TaskQueue) {
     if (this.queue === queue) return
 
@@ -78,19 +80,5 @@ abstract class Task(
         currentThread.name = oldName
       }
     }
-
-    this.cancelRunnable = Runnable {
-      val currentThread = Thread.currentThread()
-      val oldName = currentThread.name
-      currentThread.name = name
-
-      var skipExecution = false
-      try {
-        skipExecution = tryCancel()
-      } finally {
-        queue.tryCancelCompleted(this, skipExecution)
-        currentThread.name = oldName
-      }
-    }
   }
 }
diff --git a/okhttp/src/main/java/okhttp3/internal/concurrent/TaskQueue.kt b/okhttp/src/main/java/okhttp3/internal/concurrent/TaskQueue.kt
index 5696e73d40..9925c58b95 100644
--- a/okhttp/src/main/java/okhttp3/internal/concurrent/TaskQueue.kt
+++ b/okhttp/src/main/java/okhttp3/internal/concurrent/TaskQueue.kt
@@ -15,7 +15,6 @@
  */
 package okhttp3.internal.concurrent
 
-import okhttp3.internal.addIfAbsent
 import java.util.concurrent.CountDownLatch
 import java.util.concurrent.RejectedExecutionException
 import java.util.concurrent.TimeUnit
@@ -27,25 +26,19 @@ import java.util.concurrent.TimeUnit
  * for its work; in practice a set of queues may share a set of threads to save resources.
  */
 class TaskQueue internal constructor(
-  private val taskRunner: TaskRunner,
-
-  /**
-   * An application-level object like a connection pool or HTTP call that this queue works on behalf
-   * of. This is intended to be useful for testing and debugging only.
-   */
-  val owner: Any
+  private val taskRunner: TaskRunner
 ) {
   private var shutdown = false
 
   /** This queue's currently-executing task, or null if none is currently executing. */
   private var activeTask: Task? = null
 
+  /** True if the [activeTask] should not recur when it completes. */
+  private var cancelActiveTask = false
+
   /** Scheduled tasks ordered by [Task.nextExecuteNanoTime]. */
   private val futureTasks = mutableListOf<Task>()
 
-  /** Tasks to cancel. Always either [activeTask] or a member of [futureTasks]. */
-  private val cancelTasks = mutableListOf<Task>()
-
   internal fun isActive(): Boolean {
     check(Thread.holdsLock(taskRunner))
 
@@ -163,17 +156,18 @@ class TaskQueue internal constructor(
 
   /** Returns true if the coordinator should run. */
   private fun cancelAllAndDecide(): Boolean {
-    val runningTask = activeTask
-    if (runningTask != null) {
-      cancelTasks.addIfAbsent(runningTask)
+    if (activeTask != null && activeTask!!.cancelable) {
+      cancelActiveTask = true
     }
 
-    for (task in futureTasks) {
-      cancelTasks.addIfAbsent(task)
+    var tasksCanceled = false
+    for (i in futureTasks.size - 1 downTo 0) {
+      if (futureTasks[i].cancelable) {
+        tasksCanceled = true
+        futureTasks.removeAt(i)
+      }
     }
-
-    // Run the coordinator if tasks were canceled.
-    return cancelTasks.isNotEmpty()
+    return tasksCanceled
   }
 
   /**
@@ -187,15 +181,6 @@ class TaskQueue internal constructor(
 
     if (activeTask != null) return Long.MAX_VALUE // This queue is busy.
 
-    // Find a task to cancel.
-    val cancelTask = cancelTasks.firstOrNull()
-    if (cancelTask != null) {
-      activeTask = cancelTask
-      cancelTasks.removeAt(0)
-      taskRunner.backend.executeTask(cancelTask.cancelRunnable!!)
-      return Long.MAX_VALUE // This queue is busy until the cancel completes.
-    }
-
     // Check if a task is immediately ready.
     val runTask = futureTasks.firstOrNull() ?: return -1L
     val delayNanos = runTask.nextExecuteNanoTime - now
@@ -214,27 +199,12 @@ class TaskQueue internal constructor(
     synchronized(taskRunner) {
       check(activeTask === task)
 
-      if (delayNanos != -1L && !shutdown) {
+      if (delayNanos != -1L && !cancelActiveTask && !shutdown) {
         scheduleAndDecide(task, delayNanos)
-      } else if (!futureTasks.contains(task)) {
-        cancelTasks.remove(task) // We don't need to cancel it because it isn't scheduled.
-      }
-
-      activeTask = null
-      taskRunner.kickCoordinator(this)
-    }
-  }
-
-  internal fun tryCancelCompleted(task: Task, skipExecution: Boolean) {
-    synchronized(taskRunner) {
-      check(activeTask === task)
-
-      if (skipExecution) {
-        futureTasks.remove(task)
-        cancelTasks.remove(task)
       }
 
       activeTask = null
+      cancelActiveTask = false
       taskRunner.kickCoordinator(this)
     }
   }
diff --git a/okhttp/src/main/java/okhttp3/internal/concurrent/TaskRunner.kt b/okhttp/src/main/java/okhttp3/internal/concurrent/TaskRunner.kt
index a7a1eba554..69c9ee2934 100644
--- a/okhttp/src/main/java/okhttp3/internal/concurrent/TaskRunner.kt
+++ b/okhttp/src/main/java/okhttp3/internal/concurrent/TaskRunner.kt
@@ -44,7 +44,7 @@ class TaskRunner(
   private val activeQueues = mutableListOf<TaskQueue>()
   private val coordinator = Runnable { coordinate() }
 
-  fun newQueue(owner: Any) = TaskQueue(this, owner)
+  fun newQueue() = TaskQueue(this)
 
   /**
    * Returns a snapshot of queues that currently have tasks scheduled. The task runner does not
@@ -113,8 +113,8 @@ class TaskRunner(
   }
 
   private fun cancelAll() {
-    for (queue in activeQueues) {
-      queue.cancelAll()
+    for (i in activeQueues.size - 1 downTo 0) {
+      activeQueues[i].cancelAll()
     }
   }
 
diff --git a/okhttp/src/main/java/okhttp3/internal/connection/RealConnection.kt b/okhttp/src/main/java/okhttp3/internal/connection/RealConnection.kt
index 24b0231c3a..acaf3327d0 100644
--- a/okhttp/src/main/java/okhttp3/internal/connection/RealConnection.kt
+++ b/okhttp/src/main/java/okhttp3/internal/connection/RealConnection.kt
@@ -41,6 +41,7 @@ import okhttp3.internal.http2.ErrorCode
 import okhttp3.internal.http2.Http2Connection
 import okhttp3.internal.http2.Http2ExchangeCodec
 import okhttp3.internal.http2.Http2Stream
+import okhttp3.internal.http2.Settings
 import okhttp3.internal.http2.StreamResetException
 import okhttp3.internal.platform.Platform
 import okhttp3.internal.tls.OkHostnameVerifier
@@ -189,6 +190,7 @@ class RealConnection(
         handshake = null
         protocol = null
         http2Connection = null
+        allocationLimit = 1
 
         eventListener.connectFailed(call, route.socketAddress, route.proxy, null, e)
 
@@ -208,13 +210,6 @@ class RealConnection(
       throw RouteException(ProtocolException(
           "Too many tunnel connections attempted: $MAX_TUNNEL_ATTEMPTS"))
     }
-
-    val http2Connection = this.http2Connection
-    if (http2Connection != null) {
-      synchronized(connectionPool) {
-        allocationLimit = http2Connection.maxConcurrentStreams()
-      }
-    }
   }
 
   /**
@@ -328,6 +323,7 @@ class RealConnection(
         .pingIntervalMillis(pingIntervalMillis)
         .build()
     this.http2Connection = http2Connection
+    this.allocationLimit = Http2Connection.DEFAULT_SETTINGS.getMaxConcurrentStreams()
     http2Connection.start()
   }
 
@@ -645,9 +641,9 @@ class RealConnection(
   }
 
   /** When settings are received, adjust the allocation limit. */
-  override fun onSettings(connection: Http2Connection) {
+  override fun onSettings(connection: Http2Connection, settings: Settings) {
     synchronized(connectionPool) {
-      allocationLimit = connection.maxConcurrentStreams()
+      allocationLimit = settings.getMaxConcurrentStreams()
     }
   }
 
diff --git a/okhttp/src/main/java/okhttp3/internal/connection/RealConnectionPool.kt b/okhttp/src/main/java/okhttp3/internal/connection/RealConnectionPool.kt
index 0bd1c7fab5..34bda48ab3 100644
--- a/okhttp/src/main/java/okhttp3/internal/connection/RealConnectionPool.kt
+++ b/okhttp/src/main/java/okhttp3/internal/connection/RealConnectionPool.kt
@@ -39,10 +39,9 @@ class RealConnectionPool(
 ) {
   private val keepAliveDurationNs: Long = timeUnit.toNanos(keepAliveDuration)
 
-  private val cleanupQueue: TaskQueue = taskRunner.newQueue(this)
+  private val cleanupQueue: TaskQueue = taskRunner.newQueue()
   private val cleanupTask = object : Task("OkHttp ConnectionPool") {
     override fun runOnce() = cleanup(System.nanoTime())
-    override fun tryCancel() = true
   }
 
   private val connections = ArrayDeque<RealConnection>()
diff --git a/okhttp/src/main/java/okhttp3/internal/http2/Http2Connection.kt b/okhttp/src/main/java/okhttp3/internal/http2/Http2Connection.kt
index 65d4c7d6e4..77f448cd0b 100644
--- a/okhttp/src/main/java/okhttp3/internal/http2/Http2Connection.kt
+++ b/okhttp/src/main/java/okhttp3/internal/http2/Http2Connection.kt
@@ -21,14 +21,12 @@ import okhttp3.internal.closeQuietly
 import okhttp3.internal.concurrent.Task
 import okhttp3.internal.concurrent.TaskRunner
 import okhttp3.internal.connectionName
-import okhttp3.internal.execute
 import okhttp3.internal.http2.ErrorCode.REFUSED_STREAM
 import okhttp3.internal.http2.Settings.Companion.DEFAULT_INITIAL_WINDOW_SIZE
 import okhttp3.internal.ignoreIoExceptions
 import okhttp3.internal.notifyAll
 import okhttp3.internal.platform.Platform
 import okhttp3.internal.platform.Platform.Companion.INFO
-import okhttp3.internal.threadFactory
 import okhttp3.internal.toHeaders
 import okhttp3.internal.wait
 import okio.Buffer
@@ -42,8 +40,6 @@ import java.io.Closeable
 import java.io.IOException
 import java.io.InterruptedIOException
 import java.net.Socket
-import java.util.concurrent.SynchronousQueue
-import java.util.concurrent.ThreadPoolExecutor
 import java.util.concurrent.TimeUnit
 
 /**
@@ -71,10 +67,7 @@ class Http2Connection internal constructor(builder: Builder) : Closeable {
   /** True if this peer initiated the connection. */
   internal val client: Boolean = builder.client
 
-  /**
-   * User code to run in response to incoming streams or settings. Calls to this are always invoked
-   * on [listenerExecutor].
-   */
+  /** User code to run in response to incoming streams or settings. */
   internal val listener: Listener = builder.listener
   internal val streams = mutableMapOf<Int, Http2Stream>()
   internal val connectionName: String = builder.connectionName
@@ -86,11 +79,17 @@ class Http2Connection internal constructor(builder: Builder) : Closeable {
   @get:Synchronized var isShutdown = false
     internal set
 
+  /** For scheduling everything asynchronous. */
+  private val taskRunner = builder.taskRunner
+
   /** Asynchronously writes frames to the outgoing socket. */
-  private val writerQueue = builder.taskRunner.newQueue("$connectionName Writer")
+  private val writerQueue = taskRunner.newQueue()
 
   /** Ensures push promise callbacks events are sent in order per stream. */
-  private val pushQueue = builder.taskRunner.newQueue("$connectionName Push")
+  private val pushQueue = taskRunner.newQueue()
+
+  /** Notifies the listener of settings changes. */
+  private val settingsListenerQueue = taskRunner.newQueue()
 
   /** User code to run in response to push promise events. */
   private val pushObserver: PushObserver = builder.pushObserver
@@ -108,12 +107,11 @@ class Http2Connection internal constructor(builder: Builder) : Closeable {
     }
   }
 
-  /** Settings we receive from the peer. */
-  // TODO: MWS will need to guard on this setting before attempting to push.
-  val peerSettings = Settings().apply {
-    set(Settings.INITIAL_WINDOW_SIZE, DEFAULT_INITIAL_WINDOW_SIZE)
-    set(Settings.MAX_FRAME_SIZE, Http2.INITIAL_MAX_FRAME_SIZE)
-  }
+  /**
+   * Settings we receive from the peer. Changes to the field are guarded by this. The instance is
+   * never mutated once it has been assigned.
+   */
+  var peerSettings = DEFAULT_SETTINGS
 
   /** The total number of bytes consumed by the application. */
   var readBytesTotal = 0L
@@ -148,8 +146,6 @@ class Http2Connection internal constructor(builder: Builder) : Closeable {
           writePing(false, 0, 0)
           return pingIntervalNanos
         }
-
-        override fun tryCancel() = true
       }, pingIntervalNanos)
     }
   }
@@ -170,9 +166,6 @@ class Http2Connection internal constructor(builder: Builder) : Closeable {
     return stream
   }
 
-  @Synchronized fun maxConcurrentStreams(): Int =
-      peerSettings.getMaxConcurrentStreams(Integer.MAX_VALUE)
-
   @Synchronized internal fun updateConnectionFlowControl(read: Long) {
     readBytesTotal += read
     val readBytesToAcknowledge = readBytesTotal - readBytesAcknowledged
@@ -227,7 +220,7 @@ class Http2Connection internal constructor(builder: Builder) : Closeable {
 
     synchronized(writer) {
       synchronized(this) {
-        if (nextStreamId > Integer.MAX_VALUE / 2) {
+        if (nextStreamId > Int.MAX_VALUE / 2) {
           shutdown(REFUSED_STREAM)
         }
         if (isShutdown) {
@@ -334,8 +327,6 @@ class Http2Connection internal constructor(builder: Builder) : Closeable {
         }
         return -1L
       }
-
-      override fun tryCancel() = true
     })
   }
 
@@ -360,8 +351,6 @@ class Http2Connection internal constructor(builder: Builder) : Closeable {
         }
         return -1L
       }
-
-      override fun tryCancel() = true
     })
   }
 
@@ -433,7 +422,7 @@ class Http2Connection internal constructor(builder: Builder) : Closeable {
 
   /**
    * Closes this connection. This cancels all open streams and unanswered pings. It closes the
-   * underlying input and output streams and shuts down internal executor services and task queues.
+   * underlying input and output streams and shuts down internal task queues.
    */
   override fun close() {
     close(ErrorCode.NO_ERROR, ErrorCode.CANCEL, null)
@@ -476,6 +465,7 @@ class Http2Connection internal constructor(builder: Builder) : Closeable {
     // Release the threads.
     writerQueue.shutdown()
     pushQueue.shutdown()
+    settingsListenerQueue.shutdown()
   }
 
   private fun failConnection(e: IOException?) {
@@ -639,16 +629,22 @@ class Http2Connection internal constructor(builder: Builder) : Closeable {
           val newStream = Http2Stream(streamId, this@Http2Connection, false, inFinished, headers)
           lastGoodStreamId = streamId
           streams[streamId] = newStream
-          listenerExecutor.execute("OkHttp $connectionName stream $streamId") {
-            try {
-              listener.onStream(newStream)
-            } catch (e: IOException) {
-              Platform.get().log("Http2Connection.Listener failure for $connectionName", INFO, e)
-              ignoreIoExceptions {
-                newStream.close(ErrorCode.PROTOCOL_ERROR, e)
+
+          // Use a different task queue for each stream because they should be handled in parallel.
+          val taskName = "OkHttp $connectionName stream $streamId"
+          taskRunner.newQueue().schedule(object : Task(taskName, cancelable = false) {
+            override fun runOnce(): Long {
+              try {
+                listener.onStream(newStream)
+              } catch (e: IOException) {
+                Platform.get().log("Http2Connection.Listener failure for $connectionName", INFO, e)
+                ignoreIoExceptions {
+                  newStream.close(ErrorCode.PROTOCOL_ERROR, e)
+                }
               }
+              return -1L
             }
-          }
+          })
           return
         }
       }
@@ -672,8 +668,6 @@ class Http2Connection internal constructor(builder: Builder) : Closeable {
           applyAndAckSettings(clearPrevious, settings)
           return -1L
         }
-
-        override fun tryCancel() = true
       })
     }
 
@@ -691,21 +685,40 @@ class Http2Connection internal constructor(builder: Builder) : Closeable {
      * order than received.
      */
     fun applyAndAckSettings(clearPrevious: Boolean, settings: Settings) {
-      var delta = 0L
-      var streamsToNotify: Array<Http2Stream>? = null
+      var delta: Long
+      var streamsToNotify: Array<Http2Stream>?
+      var newPeerSettings: Settings
       synchronized(writer) {
         synchronized(this@Http2Connection) {
-          val priorWriteWindowSize = peerSettings.initialWindowSize
-          if (clearPrevious) peerSettings.clear()
-          peerSettings.merge(settings)
-          val peerInitialWindowSize = peerSettings.initialWindowSize
-          if (peerInitialWindowSize != -1 && peerInitialWindowSize != priorWriteWindowSize) {
-            delta = (peerInitialWindowSize - priorWriteWindowSize).toLong()
-            streamsToNotify = if (streams.isNotEmpty()) streams.values.toTypedArray() else null
+          val previousPeerSettings = peerSettings
+          if (clearPrevious) {
+            newPeerSettings = settings
+          } else {
+            newPeerSettings = Settings().apply {
+              merge(previousPeerSettings)
+              merge(settings)
+            }
           }
+
+          val peerInitialWindowSize = newPeerSettings.initialWindowSize.toLong()
+          delta = peerInitialWindowSize - previousPeerSettings.initialWindowSize.toLong()
+          streamsToNotify = when {
+            delta == 0L || streams.isEmpty() -> null // No adjustment is necessary.
+            else -> streams.values.toTypedArray()
+          }
+
+          peerSettings = newPeerSettings
+
+          settingsListenerQueue.trySchedule(object : Task("$connectionName Listener",
+              cancelable = false) {
+            override fun runOnce(): Long {
+              listener.onSettings(this@Http2Connection, newPeerSettings)
+              return -1L
+            }
+          })
         }
         try {
-          writer.applyAndAckSettings(peerSettings)
+          writer.applyAndAckSettings(newPeerSettings)
         } catch (e: IOException) {
           failConnection(e)
         }
@@ -717,9 +730,6 @@ class Http2Connection internal constructor(builder: Builder) : Closeable {
           }
         }
       }
-      listenerExecutor.execute("OkHttp $connectionName settings") {
-        listener.onSettings(this@Http2Connection)
-      }
     }
 
     override fun ackSettings() {
@@ -743,8 +753,6 @@ class Http2Connection internal constructor(builder: Builder) : Closeable {
             writePing(true, payload1, payload2)
             return -1L
           }
-
-          override fun tryCancel() = true
         })
       }
     }
@@ -843,8 +851,6 @@ class Http2Connection internal constructor(builder: Builder) : Closeable {
         }
         return -1L
       }
-
-      override fun tryCancel() = true
     })
   }
 
@@ -866,8 +872,6 @@ class Http2Connection internal constructor(builder: Builder) : Closeable {
         }
         return -1L
       }
-
-      override fun tryCancel() = true
     })
   }
 
@@ -898,13 +902,12 @@ class Http2Connection internal constructor(builder: Builder) : Closeable {
         }
         return -1L
       }
-
-      override fun tryCancel() = true
     })
   }
 
   internal fun pushResetLater(streamId: Int, errorCode: ErrorCode) {
-    pushQueue.trySchedule(object : Task("OkHttp $connectionName Push Reset[$streamId]") {
+    pushQueue.trySchedule(object : Task("OkHttp $connectionName Push Reset[$streamId]",
+        cancelable = false) {
       override fun runOnce(): Long {
         pushObserver.onReset(streamId, errorCode)
         synchronized(this@Http2Connection) {
@@ -921,19 +924,20 @@ class Http2Connection internal constructor(builder: Builder) : Closeable {
      * Handle a new stream from this connection's peer. Implementations should respond by either
      * [replying to the stream][Http2Stream.writeHeaders] or [closing it][Http2Stream.close]. This
      * response does not need to be synchronous.
+     *
+     * Multiple calls to this method may be made concurrently.
      */
     @Throws(IOException::class)
     abstract fun onStream(stream: Http2Stream)
 
     /**
-     * Notification that the connection's peer's settings may have changed. Implementations should
-     * take appropriate action to handle the updated settings.
+     * Notification that the connection's peer's settings may have changed to [settings].
+     * Implementations should take appropriate action to handle the updated settings.
      *
-     * It is the implementation's responsibility to handle concurrent calls to this method. A remote
-     * peer that sends multiple settings frames will trigger multiple calls to this method, and
-     * those calls are not necessarily serialized.
+     * Methods to this method may be made concurrently with [onStream]. But a calls to this method
+     * are serialized.
      */
-    open fun onSettings(connection: Http2Connection) {}
+    open fun onSettings(connection: Http2Connection, settings: Settings) {}
 
     companion object {
       @JvmField
@@ -949,12 +953,9 @@ class Http2Connection internal constructor(builder: Builder) : Closeable {
   companion object {
     const val OKHTTP_CLIENT_WINDOW_SIZE = 16 * 1024 * 1024
 
-    /**
-     * Shared executor to send notifications of incoming streams. This executor requires multiple
-     * threads because listeners are not required to return promptly.
-     */
-    private val listenerExecutor = ThreadPoolExecutor(0,
-        Integer.MAX_VALUE, 60L, TimeUnit.SECONDS, SynchronousQueue(),
-        threadFactory("OkHttp Http2Connection", true))
+    val DEFAULT_SETTINGS = Settings().apply {
+      set(Settings.INITIAL_WINDOW_SIZE, DEFAULT_INITIAL_WINDOW_SIZE)
+      set(Settings.MAX_FRAME_SIZE, Http2.INITIAL_MAX_FRAME_SIZE)
+    }
   }
 }
diff --git a/okhttp/src/main/java/okhttp3/internal/http2/Settings.kt b/okhttp/src/main/java/okhttp3/internal/http2/Settings.kt
index 91315d3570..7f90fd9e06 100644
--- a/okhttp/src/main/java/okhttp3/internal/http2/Settings.kt
+++ b/okhttp/src/main/java/okhttp3/internal/http2/Settings.kt
@@ -74,9 +74,9 @@ class Settings {
     return if (bit and set != 0) values[ENABLE_PUSH] == 1 else defaultValue
   }
 
-  fun getMaxConcurrentStreams(defaultValue: Int): Int {
+  fun getMaxConcurrentStreams(): Int {
     val bit = 1 shl MAX_CONCURRENT_STREAMS
-    return if (bit and set != 0) values[MAX_CONCURRENT_STREAMS] else defaultValue
+    return if (bit and set != 0) values[MAX_CONCURRENT_STREAMS] else Int.MAX_VALUE
   }
 
   fun getMaxFrameSize(defaultValue: Int): Int {
diff --git a/okhttp/src/main/java/okhttp3/internal/proxy/NullProxySelector.kt b/okhttp/src/main/java/okhttp3/internal/proxy/NullProxySelector.kt
index d18d2eca31..40c0674146 100644
--- a/okhttp/src/main/java/okhttp3/internal/proxy/NullProxySelector.kt
+++ b/okhttp/src/main/java/okhttp3/internal/proxy/NullProxySelector.kt
@@ -24,7 +24,7 @@ import java.net.URI
 /**
  * A proxy selector that always returns the [Proxy.NO_PROXY].
  */
-open class NullProxySelector : ProxySelector() {
+object NullProxySelector : ProxySelector() {
   override fun select(uri: URI?): List<Proxy> {
     requireNotNull(uri) { "uri must not be null" }
     return listOf(Proxy.NO_PROXY)
diff --git a/okhttp/src/main/java/okhttp3/internal/ws/RealWebSocket.kt b/okhttp/src/main/java/okhttp3/internal/ws/RealWebSocket.kt
index 4c29d5233d..1c5269e800 100644
--- a/okhttp/src/main/java/okhttp3/internal/ws/RealWebSocket.kt
+++ b/okhttp/src/main/java/okhttp3/internal/ws/RealWebSocket.kt
@@ -63,7 +63,7 @@ class RealWebSocket(
   private var call: Call? = null
 
   /** This task processes the outgoing queues. Call [runWriter] to after enqueueing. */
-  private val writerTask: Task
+  private var writerTask: Task? = null
 
   /** Null until this web socket is connected. Only accessed by the reader thread. */
   private var reader: WebSocketReader? = null
@@ -74,7 +74,10 @@ class RealWebSocket(
   private var writer: WebSocketWriter? = null
 
   /** Used for writes, pings, and close timeouts. */
-  private var taskQueue = taskRunner.newQueue("OkHttp WebSocket ${originalRequest.url.redact()}")
+  private var taskQueue = taskRunner.newQueue()
+
+  /** Names this web socket for observability and debugging. */
+  private var name: String? = null
 
   /**
    * The streams held by this web socket. This is non-null until all incoming messages have been
@@ -122,18 +125,6 @@ class RealWebSocket(
     }
 
     this.key = ByteArray(16).apply { random.nextBytes(this) }.toByteString().base64()
-    this.writerTask = object : Task("${taskQueue.owner} Writer") {
-      override fun runOnce(): Long {
-        try {
-          if (writeOneFrame()) return 0L
-        } catch (e: IOException) {
-          failWebSocket(e, null)
-        }
-        return -1L
-      }
-
-      override fun tryCancel() = true
-    }
   }
 
   override fun request(): Request = originalRequest
@@ -221,8 +212,10 @@ class RealWebSocket(
   @Throws(IOException::class)
   fun initReaderAndWriter(name: String, streams: Streams) {
     synchronized(this) {
+      this.name = name
       this.streams = streams
       this.writer = WebSocketWriter(streams.client, streams.sink, random)
+      this.writerTask = WriterTask()
       if (pingIntervalMillis != 0L) {
         val pingIntervalNanos = MILLISECONDS.toNanos(pingIntervalMillis)
         taskQueue.schedule(PingTask(pingIntervalNanos), pingIntervalNanos)
@@ -397,7 +390,7 @@ class RealWebSocket(
 
   private fun runWriter() {
     assert(Thread.holdsLock(this))
-    taskQueue.trySchedule(writerTask)
+    taskQueue.trySchedule(writerTask!!)
   }
 
   /**
@@ -442,7 +435,7 @@ class RealWebSocket(
             // When we request a graceful close also schedule a cancel of the web socket.
             val cancelAfterCloseNanos =
                 MILLISECONDS.toNanos((messageOrClose as Close).cancelAfterCloseMillis)
-            taskQueue.schedule(CancelRunnable(), cancelAfterCloseNanos)
+            taskQueue.schedule(CancelTask(), cancelAfterCloseNanos)
           }
         } else if (messageOrClose == null) {
           return false // The queue is exhausted.
@@ -480,15 +473,6 @@ class RealWebSocket(
     }
   }
 
-  private inner class PingTask(val delayNanos: Long) : Task("${taskQueue.owner} Ping") {
-    override fun runOnce(): Long {
-      writePingFrame()
-      return delayNanos
-    }
-
-    override fun tryCancel() = true
-  }
-
   internal fun writePingFrame() {
     val writer: WebSocketWriter?
     val failedPing: Int
@@ -547,13 +531,30 @@ class RealWebSocket(
     val sink: BufferedSink
   ) : Closeable
 
-  internal inner class CancelRunnable : Task("${taskQueue.owner} Cancel") {
+
+  private inner class PingTask(val delayNanos: Long) : Task("$name Ping") {
+    override fun runOnce(): Long {
+      writePingFrame()
+      return delayNanos
+    }
+  }
+
+  private inner class CancelTask : Task("$name Cancel") {
     override fun runOnce(): Long {
       cancel()
       return -1L
     }
+  }
 
-    override fun tryCancel() = true
+  private inner class WriterTask : Task("$name Writer") {
+    override fun runOnce(): Long {
+      try {
+        if (writeOneFrame()) return 0L
+      } catch (e: IOException) {
+        failWebSocket(e, null)
+      }
+      return -1L
+    }
   }
 
   companion object {
diff --git a/okhttp/src/test/java/okhttp3/CallTest.java b/okhttp/src/test/java/okhttp3/CallTest.java
index 2a50b527b6..a1469ae823 100644
--- a/okhttp/src/test/java/okhttp3/CallTest.java
+++ b/okhttp/src/test/java/okhttp3/CallTest.java
@@ -786,6 +786,63 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
     assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(2);
   }
 
+  /**
+   * Each OkHttpClient used to get its own instance of NullProxySelector, and because these weren't
+   * equal their connections weren't pooled. That's a nasty performance bug!
+   *
+   * https://github.com/square/okhttp/issues/5519
+   */
+  @Test public void connectionPoolingWithFreshClientSamePool() throws Exception {
+    server.enqueue(new MockResponse().setBody("abc"));
+    server.enqueue(new MockResponse().setBody("def"));
+    server.enqueue(new MockResponse().setBody("ghi"));
+
+    client = new OkHttpClient.Builder()
+        .connectionPool(client.connectionPool())
+        .proxy(server.toProxyAddress())
+        .build();
+    executeSynchronously("/a").assertBody("abc");
+
+    client = new OkHttpClient.Builder()
+        .connectionPool(client.connectionPool())
+        .proxy(server.toProxyAddress())
+        .build();
+    executeSynchronously("/b").assertBody("def");
+
+    client = new OkHttpClient.Builder()
+        .connectionPool(client.connectionPool())
+        .proxy(server.toProxyAddress())
+        .build();
+    executeSynchronously("/c").assertBody("ghi");
+
+    assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(0);
+    assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(1);
+    assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(2);
+  }
+
+  @Test public void connectionPoolingWithClientBuiltOffProxy() throws Exception {
+    client = new OkHttpClient.Builder()
+        .proxy(server.toProxyAddress())
+        .build();
+
+    server.enqueue(new MockResponse().setBody("abc"));
+    server.enqueue(new MockResponse().setBody("def"));
+    server.enqueue(new MockResponse().setBody("ghi"));
+
+    client = client.newBuilder().build();
+    executeSynchronously("/a").assertBody("abc");
+
+    client = client.newBuilder().build();
+    executeSynchronously("/b").assertBody("def");
+
+    client = client.newBuilder().build();
+    executeSynchronously("/c").assertBody("ghi");
+
+    assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(0);
+    assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(1);
+    assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(2);
+  }
+
   @Test public void connectionPooling_Async() throws Exception {
     server.enqueue(new MockResponse().setBody("abc"));
     server.enqueue(new MockResponse().setBody("def"));
diff --git a/okhttp/src/test/java/okhttp3/KotlinSourceModernTest.kt b/okhttp/src/test/java/okhttp3/KotlinSourceModernTest.kt
index 36d1da59b5..2d76da8ed8 100644
--- a/okhttp/src/test/java/okhttp3/KotlinSourceModernTest.kt
+++ b/okhttp/src/test/java/okhttp3/KotlinSourceModernTest.kt
@@ -847,7 +847,7 @@ class KotlinSourceModernTest {
     builder = builder.pingInterval(0L, TimeUnit.SECONDS)
     builder = builder.pingInterval(Duration.ofSeconds(0L))
     builder = builder.proxy(Proxy.NO_PROXY)
-    builder = builder.proxySelector(NullProxySelector())
+    builder = builder.proxySelector(NullProxySelector)
     builder = builder.cookieJar(CookieJar.NO_COOKIES)
     builder = builder.cache(Cache(File("/cache/"), Integer.MAX_VALUE.toLong()))
     builder = builder.dns(Dns.SYSTEM)
@@ -1150,7 +1150,7 @@ class KotlinSourceModernTest {
         Proxy.NO_PROXY,
         listOf(Protocol.HTTP_1_1),
         listOf(ConnectionSpec.MODERN_TLS),
-        NullProxySelector()
+        NullProxySelector
     )
   }
 
diff --git a/okhttp/src/test/java/okhttp3/internal/concurrent/TaskRunnerRealBackendTest.kt b/okhttp/src/test/java/okhttp3/internal/concurrent/TaskRunnerRealBackendTest.kt
index e8d24f932d..27dcd27779 100644
--- a/okhttp/src/test/java/okhttp3/internal/concurrent/TaskRunnerRealBackendTest.kt
+++ b/okhttp/src/test/java/okhttp3/internal/concurrent/TaskRunnerRealBackendTest.kt
@@ -31,7 +31,7 @@ import java.util.concurrent.TimeUnit
 class TaskRunnerRealBackendTest {
   private val backend = TaskRunner.RealBackend()
   private val taskRunner = TaskRunner(backend)
-  private val queue = taskRunner.newQueue("queue")
+  private val queue = taskRunner.newQueue()
   private val log = LinkedBlockingDeque<String>()
 
   @Test fun test() {
diff --git a/okhttp/src/test/java/okhttp3/internal/concurrent/TaskRunnerTest.kt b/okhttp/src/test/java/okhttp3/internal/concurrent/TaskRunnerTest.kt
index a6eccbd12d..59ab4ff5bb 100644
--- a/okhttp/src/test/java/okhttp3/internal/concurrent/TaskRunnerTest.kt
+++ b/okhttp/src/test/java/okhttp3/internal/concurrent/TaskRunnerTest.kt
@@ -24,9 +24,9 @@ class TaskRunnerTest {
   private val taskFaker = TaskFaker()
   private val taskRunner = taskFaker.taskRunner
   private val log = mutableListOf<String>()
-  private val redQueue = taskRunner.newQueue("red")
-  private val blueQueue = taskRunner.newQueue("blue")
-  private val greenQueue = taskRunner.newQueue("green")
+  private val redQueue = taskRunner.newQueue()
+  private val blueQueue = taskRunner.newQueue()
+  private val greenQueue = taskRunner.newQueue()
 
   @Test fun executeDelayed() {
     redQueue.schedule(object : Task("task") {
@@ -133,11 +133,6 @@ class TaskRunnerTest {
         log += "run@${taskFaker.nanoTime}"
         return -1L
       }
-
-      override fun tryCancel(): Boolean {
-        log += "cancel@${taskFaker.nanoTime}"
-        return true
-      }
     }, 100L)
 
     taskFaker.advanceUntil(0L)
@@ -146,22 +141,17 @@ class TaskRunnerTest {
     redQueue.cancelAll()
 
     taskFaker.advanceUntil(99L)
-    assertThat(log).containsExactly("cancel@99")
+    assertThat(log).isEmpty()
 
     taskFaker.assertNoMoreTasks()
   }
 
   @Test fun cancelReturnsFalseDoesNotCancel() {
-    redQueue.schedule(object : Task("task") {
+    redQueue.schedule(object : Task("task", cancelable = false) {
       override fun runOnce(): Long {
         log += "run@${taskFaker.nanoTime}"
         return -1L
       }
-
-      override fun tryCancel(): Boolean {
-        log += "cancel@${taskFaker.nanoTime}"
-        return false
-      }
     }, 100L)
 
     taskFaker.advanceUntil(0L)
@@ -170,10 +160,10 @@ class TaskRunnerTest {
     redQueue.cancelAll()
 
     taskFaker.advanceUntil(99L)
-    assertThat(log).containsExactly("cancel@99")
+    assertThat(log).isEmpty()
 
     taskFaker.advanceUntil(100L)
-    assertThat(log).containsExactly("cancel@99", "run@100")
+    assertThat(log).containsExactly("run@100")
 
     taskFaker.assertNoMoreTasks()
   }
@@ -185,18 +175,13 @@ class TaskRunnerTest {
         redQueue.cancelAll()
         return 100L
       }
-
-      override fun tryCancel(): Boolean {
-        log += "cancel@${taskFaker.nanoTime}"
-        return true
-      }
     }, 100L)
 
     taskFaker.advanceUntil(0L)
     assertThat(log).isEmpty()
 
     taskFaker.advanceUntil(100L)
-    assertThat(log).containsExactly("run@100", "cancel@100")
+    assertThat(log).containsExactly("run@100")
 
     taskFaker.assertNoMoreTasks()
   }
@@ -208,10 +193,24 @@ class TaskRunnerTest {
         redQueue.cancelAll()
         return -1L
       }
+    }, 100L)
 
-      override fun tryCancel(): Boolean {
-        log += "cancel@${taskFaker.nanoTime}"
-        return true
+    taskFaker.advanceUntil(0L)
+    assertThat(log).isEmpty()
+
+    taskFaker.advanceUntil(100L)
+    assertThat(log).containsExactly("run@100")
+
+    taskFaker.assertNoMoreTasks()
+  }
+
+  @Test fun cancelWhileExecutingDoesNotStopUncancelableTask() {
+    redQueue.schedule(object : Task("task", cancelable = false) {
+      val delays = mutableListOf(50L, -1L)
+      override fun runOnce(): Long {
+        log += "run@${taskFaker.nanoTime}"
+        redQueue.cancelAll()
+        return delays.removeAt(0)
       }
     }, 100L)
 
@@ -221,6 +220,9 @@ class TaskRunnerTest {
     taskFaker.advanceUntil(100L)
     assertThat(log).containsExactly("run@100")
 
+    taskFaker.advanceUntil(150L)
+    assertThat(log).containsExactly("run@100", "run@150")
+
     taskFaker.assertNoMoreTasks()
   }
 
@@ -230,11 +232,6 @@ class TaskRunnerTest {
         log += "run@${taskFaker.nanoTime}"
         return -1L
       }
-
-      override fun tryCancel(): Boolean {
-        log += "cancel@${taskFaker.nanoTime}"
-        return true
-      }
     }, 100L)
 
     taskFaker.advanceUntil(0L)
@@ -243,22 +240,17 @@ class TaskRunnerTest {
     taskFaker.interruptCoordinatorThread()
 
     taskFaker.advanceUntil(0L)
-    assertThat(log).containsExactly("cancel@0")
+    assertThat(log).isEmpty()
 
     taskFaker.assertNoMoreTasks()
   }
 
   @Test fun interruptingCoordinatorAttemptsToCancelsAndFails() {
-    redQueue.schedule(object : Task("task") {
+    redQueue.schedule(object : Task("task", cancelable = false) {
       override fun runOnce(): Long {
         log += "run@${taskFaker.nanoTime}"
         return -1L
       }
-
-      override fun tryCancel(): Boolean {
-        log += "cancel@${taskFaker.nanoTime}"
-        return false
-      }
     }, 100L)
 
     taskFaker.advanceUntil(0L)
@@ -267,10 +259,10 @@ class TaskRunnerTest {
     taskFaker.interruptCoordinatorThread()
 
     taskFaker.advanceUntil(0L)
-    assertThat(log).containsExactly("cancel@0")
+    assertThat(log).isEmpty()
 
     taskFaker.advanceUntil(100L)
-    assertThat(log).containsExactly("cancel@0", "run@100")
+    assertThat(log).containsExactly("run@100")
 
     taskFaker.assertNoMoreTasks()
   }
@@ -452,38 +444,12 @@ class TaskRunnerTest {
     taskFaker.assertNoMoreTasks()
   }
 
-  @Test fun taskNameIsUsedForThreadNameWhenCanceling() {
-    redQueue.schedule(object : Task("lucky task") {
-      override fun tryCancel(): Boolean {
-        log += "cancel threadName:${Thread.currentThread().name}"
-        return true
-      }
-
-      override fun runOnce() = -1L
-    }, 100L)
-
-    taskFaker.advanceUntil(0L)
-    assertThat(log).isEmpty()
-
-    redQueue.cancelAll()
-
-    taskFaker.advanceUntil(0L)
-    assertThat(log).containsExactly("cancel threadName:lucky task")
-
-    taskFaker.assertNoMoreTasks()
-  }
-
   @Test fun shutdownSuccessfullyCancelsScheduledTasks() {
     redQueue.schedule(object : Task("task") {
       override fun runOnce(): Long {
         log += "run@${taskFaker.nanoTime}"
         return -1L
       }
-
-      override fun tryCancel(): Boolean {
-        log += "cancel@${taskFaker.nanoTime}"
-        return true
-      }
     }, 100L)
 
     taskFaker.advanceUntil(0L)
@@ -492,22 +458,17 @@ class TaskRunnerTest {
     redQueue.shutdown()
 
     taskFaker.advanceUntil(99L)
-    assertThat(log).containsExactly("cancel@99")
+    assertThat(log).isEmpty()
 
     taskFaker.assertNoMoreTasks()
   }
 
   @Test fun shutdownFailsToCancelsScheduledTasks() {
-    redQueue.schedule(object : Task("task") {
+    redQueue.schedule(object : Task("task", cancelable = false) {
       override fun runOnce(): Long {
         log += "run@${taskFaker.nanoTime}"
         return 50L
       }
-
-      override fun tryCancel(): Boolean {
-        log += "cancel@${taskFaker.nanoTime}"
-        return false
-      }
     }, 100L)
 
     taskFaker.advanceUntil(0L)
@@ -516,10 +477,10 @@ class TaskRunnerTest {
     redQueue.shutdown()
 
     taskFaker.advanceUntil(99L)
-    assertThat(log).containsExactly("cancel@99")
+    assertThat(log).isEmpty()
 
     taskFaker.advanceUntil(100L)
-    assertThat(log).containsExactly("cancel@99", "run@100")
+    assertThat(log).containsExactly("run@100")
 
     taskFaker.assertNoMoreTasks()
   }
diff --git a/okhttp/src/test/java/okhttp3/internal/http2/Http2ConnectionTest.java b/okhttp/src/test/java/okhttp3/internal/http2/Http2ConnectionTest.java
index a5186d71c1..06daebc53f 100644
--- a/okhttp/src/test/java/okhttp3/internal/http2/Http2ConnectionTest.java
+++ b/okhttp/src/test/java/okhttp3/internal/http2/Http2ConnectionTest.java
@@ -882,15 +882,15 @@
         throw new AssertionError();
       }
 
-      @Override public void onSettings(Http2Connection connection) {
-        maxConcurrentStreams.set(connection.maxConcurrentStreams());
+      @Override public void onSettings(Http2Connection connection, Settings settings) {
+        maxConcurrentStreams.set(settings.getMaxConcurrentStreams());
         maxConcurrentStreamsUpdated.countDown();
       }
     };
     Http2Connection connection = connect(peer, IGNORE, listener);
 
     synchronized (connection) {
-      assertThat(connection.getPeerSettings().getMaxConcurrentStreams(-1)).isEqualTo(10);
+      assertThat(connection.getPeerSettings().getMaxConcurrentStreams()).isEqualTo(10);
     }
     maxConcurrentStreamsUpdated.await();
     assertThat(maxConcurrentStreams.get()).isEqualTo(10);
@@ -923,7 +923,7 @@
       assertThat(connection.getPeerSettings().getHeaderTableSize()).isEqualTo(10000);
       assertThat(connection.getPeerSettings().getInitialWindowSize()).isEqualTo(40000);
       assertThat(connection.getPeerSettings().getMaxFrameSize(-1)).isEqualTo(50000);
-      assertThat(connection.getPeerSettings().getMaxConcurrentStreams(-1)).isEqualTo(60000);
+      assertThat(connection.getPeerSettings().getMaxConcurrentStreams()).isEqualTo(60000);
     }
   }
 
@@ -952,7 +952,7 @@
       assertThat(connection.getPeerSettings().getInitialWindowSize()).isEqualTo(
           (long) DEFAULT_INITIAL_WINDOW_SIZE);
       assertThat(connection.getPeerSettings().getMaxFrameSize(-1)).isEqualTo(-1);
-      assertThat(connection.getPeerSettings().getMaxConcurrentStreams(-1)).isEqualTo(60000);
+      assertThat(connection.getPeerSettings().getMaxConcurrentStreams()).isEqualTo(60000);
     }
   }
 
diff --git a/okhttp/src/test/java/okhttp3/internal/http2/SettingsTest.java b/okhttp/src/test/java/okhttp3/internal/http2/SettingsTest.java
index 9d7cd6d5ff..55cbfc3c10 100644
--- a/okhttp/src/test/java/okhttp3/internal/http2/SettingsTest.java
+++ b/okhttp/src/test/java/okhttp3/internal/http2/SettingsTest.java
@@ -24,7 +24,8 @@
 public final class SettingsTest {
   @Test public void unsetField() {
     Settings settings = new Settings();
-    assertThat(settings.getMaxConcurrentStreams(-3)).isEqualTo(-3);
+    assertThat(settings.isSet(MAX_CONCURRENT_STREAMS)).isFalse();
+    assertThat(settings.getMaxConcurrentStreams()).isEqualTo(Integer.MAX_VALUE);
   }
 
   @Test public void setFields() {
@@ -38,9 +39,9 @@
     assertThat(settings.getEnablePush(false)).isTrue();
     settings.clear();
 
-    assertThat(settings.getMaxConcurrentStreams(-3)).isEqualTo(-3);
+    assertThat(settings.getMaxConcurrentStreams()).isEqualTo(Integer.MAX_VALUE);
     settings.set(MAX_CONCURRENT_STREAMS, 75);
-    assertThat(settings.getMaxConcurrentStreams(-3)).isEqualTo(75);
+    assertThat(settings.getMaxConcurrentStreams()).isEqualTo(75);
 
     settings.clear();
     assertThat(settings.getMaxFrameSize(16384)).isEqualTo(16384);
@@ -72,6 +73,6 @@
     assertThat(a.getHeaderTableSize()).isEqualTo(10000);
     assertThat(a.getMaxHeaderListSize(-1)).isEqualTo(40000);
     assertThat(a.getInitialWindowSize()).isEqualTo(50000);
-    assertThat(a.getMaxConcurrentStreams(-1)).isEqualTo(60000);
+    assertThat(a.getMaxConcurrentStreams()).isEqualTo(60000);
   }
 }
