diff --git a/okhttp-logging-interceptor/src/main/java/okhttp3/logging/HttpLoggingInterceptor.java b/okhttp-logging-interceptor/src/main/java/okhttp3/logging/HttpLoggingInterceptor.java
index abb6f210fd..9b4d0e6b2b 100644
--- a/okhttp-logging-interceptor/src/main/java/okhttp3/logging/HttpLoggingInterceptor.java
+++ b/okhttp-logging-interceptor/src/main/java/okhttp3/logging/HttpLoggingInterceptor.java
@@ -149,7 +149,7 @@ public Level getLevel() {
     boolean hasRequestBody = requestBody != null;
 
     Connection connection = chain.connection();
-    Protocol protocol = connection != null ? connection.getProtocol() : Protocol.HTTP_1_1;
+    Protocol protocol = connection != null ? connection.protocol() : Protocol.HTTP_1_1;
     String requestStartMessage =
         "--> " + request.method() + ' ' + request.url() + ' ' + protocol(protocol);
     if (!logHeaders && hasRequestBody) {
diff --git a/okhttp-tests/src/test/java/okhttp3/ConnectionPoolTest.java b/okhttp-tests/src/test/java/okhttp3/ConnectionPoolTest.java
index 86b5fdaa33..ef298c64ff 100644
--- a/okhttp-tests/src/test/java/okhttp3/ConnectionPoolTest.java
+++ b/okhttp-tests/src/test/java/okhttp3/ConnectionPoolTest.java
@@ -172,7 +172,7 @@
 
   /** Use a helper method so there's no hidden reference remaining on the stack. */
   private void allocateAndLeakAllocation(ConnectionPool pool, RealConnection connection) {
-    StreamAllocation leak = new StreamAllocation(pool, connection.getRoute().address());
+    StreamAllocation leak = new StreamAllocation(pool, connection.route().address());
     leak.acquire(connection);
   }
 
diff --git a/okhttp-tests/src/test/java/okhttp3/InterceptorTest.java b/okhttp-tests/src/test/java/okhttp3/InterceptorTest.java
index ebce641a38..baea2839de 100644
--- a/okhttp-tests/src/test/java/okhttp3/InterceptorTest.java
+++ b/okhttp-tests/src/test/java/okhttp3/InterceptorTest.java
@@ -134,7 +134,7 @@
 
     Interceptor interceptor = new Interceptor() {
       @Override public Response intercept(Chain chain) throws IOException {
-        Address address = chain.connection().getRoute().address();
+        Address address = chain.connection().route().address();
         String sameHost = address.url().host();
         int differentPort = address.url().port() + 1;
         return chain.proceed(chain.request().newBuilder()
diff --git a/okhttp-urlconnection/src/main/java/okhttp3/internal/huc/HttpURLConnectionImpl.java b/okhttp-urlconnection/src/main/java/okhttp3/internal/huc/HttpURLConnectionImpl.java
index 2aa26117c5..6e43756a3f 100644
--- a/okhttp-urlconnection/src/main/java/okhttp3/internal/huc/HttpURLConnectionImpl.java
+++ b/okhttp-urlconnection/src/main/java/okhttp3/internal/huc/HttpURLConnectionImpl.java
@@ -450,8 +450,8 @@ private boolean execute(boolean readResponse) throws IOException {
       httpEngine.sendRequest();
       Connection connection = httpEngine.getConnection();
       if (connection != null) {
-        route = connection.getRoute();
-        handshake = connection.getHandshake();
+        route = connection.route();
+        handshake = connection.handshake();
       } else {
         route = null;
         handshake = null;
diff --git a/okhttp/src/main/java/okhttp3/Connection.java b/okhttp/src/main/java/okhttp3/Connection.java
index 20e4564823..7bb7411732 100644
--- a/okhttp/src/main/java/okhttp3/Connection.java
+++ b/okhttp/src/main/java/okhttp3/Connection.java
@@ -65,20 +65,25 @@
  */
 public interface Connection {
   /** Returns the route used by this connection. */
-  Route getRoute();
+  Route route();
 
   /**
-   * Returns the socket that this connection uses, or null if the connection
-   * is not currently connected.
+   * Returns the socket that this connection is using. Returns an {@linkplain
+   * javax.net.ssl.SSLSocket SSL socket} if this connection is HTTPS. If this is an HTTP/2 or SPDY
+   * connection the socket may be shared by multiple concurrent calls.
    */
-  Socket getSocket();
+  Socket socket();
 
-  Handshake getHandshake();
+  /**
+   * Returns the TLS handshake used to establish this connection, or null if the connection is not
+   * HTTPS.
+   */
+  Handshake handshake();
 
   /**
    * Returns the protocol negotiated by this connection, or {@link Protocol#HTTP_1_1} if no protocol
    * has been negotiated. This method returns {@link Protocol#HTTP_1_1} even if the remote peer is
    * using {@link Protocol#HTTP_1_0}.
    */
-  Protocol getProtocol();
+  Protocol protocol();
 }
diff --git a/okhttp/src/main/java/okhttp3/ConnectionPool.java b/okhttp/src/main/java/okhttp3/ConnectionPool.java
index aefb4e2190..1ef4cbc954 100644
--- a/okhttp/src/main/java/okhttp3/ConnectionPool.java
+++ b/okhttp/src/main/java/okhttp3/ConnectionPool.java
@@ -32,6 +32,8 @@
 import java.util.concurrent.ThreadPoolExecutor;
 import java.util.concurrent.TimeUnit;
 
+import static okhttp3.internal.Util.closeQuietly;
+
 /**
  * Manages reuse of HTTP and SPDY connections for reduced network latency. HTTP
  * requests that share the same {@link Address} may share a
@@ -168,7 +170,7 @@ RealConnection get(Address address, StreamAllocation streamAllocation) {
       // TODO(jwilson): this is awkward. We're already holding a lock on 'this', and
       //     connection.allocationLimit() may also lock the FramedConnection.
       if (connection.allocations.size() < connection.allocationLimit()
-          && address.equals(connection.getRoute().address)
+          && address.equals(connection.route().address)
           && !connection.noNewStreams) {
         streamAllocation.acquire(connection);
         return connection;
@@ -215,7 +217,7 @@ public void evictAll() {
     }
 
     for (RealConnection connection : evictedConnections) {
-      Util.closeQuietly(connection.getSocket());
+      closeQuietly(connection.socket());
     }
   }
 
@@ -273,7 +275,7 @@ long cleanup(long now) {
       }
     }
 
-    Util.closeQuietly(longestIdleConnection.getSocket());
+    closeQuietly(longestIdleConnection.socket());
 
     // Cleanup again immediately.
     return 0;
@@ -296,7 +298,7 @@ private int pruneAndGetAllocationCount(RealConnection connection, long now) {
       }
 
       // We've discovered a leaked allocation. This is an application bug.
-      Internal.logger.warning("A connection to " + connection.getRoute().address().url()
+      Internal.logger.warning("A connection to " + connection.route().address().url()
           + " was leaked. Did you forget to close a response body?");
       references.remove(i);
       connection.noNewStreams = true;
diff --git a/okhttp/src/main/java/okhttp3/internal/http/Http1xStream.java b/okhttp/src/main/java/okhttp3/internal/http/Http1xStream.java
index 1af3079b07..f64dec89aa 100644
--- a/okhttp/src/main/java/okhttp3/internal/http/Http1xStream.java
+++ b/okhttp/src/main/java/okhttp3/internal/http/Http1xStream.java
@@ -119,7 +119,7 @@ public Http1xStream(StreamAllocation streamAllocation, BufferedSource source, Bu
   @Override public void writeRequestHeaders(Request request) throws IOException {
     httpEngine.writingRequestHeaders();
     String requestLine = RequestLine.get(
-        request, httpEngine.getConnection().getRoute().proxy().type());
+        request, httpEngine.getConnection().route().proxy().type());
     writeRequest(request.headers(), requestLine);
   }
 
diff --git a/okhttp/src/main/java/okhttp3/internal/http/HttpEngine.java b/okhttp/src/main/java/okhttp3/internal/http/HttpEngine.java
index 3dde593394..a53a2bd7b8 100644
--- a/okhttp/src/main/java/okhttp3/internal/http/HttpEngine.java
+++ b/okhttp/src/main/java/okhttp3/internal/http/HttpEngine.java
@@ -653,7 +653,7 @@ public void readResponse() throws IOException {
 
       if (index > 0) {
         Interceptor caller = client.networkInterceptors().get(index - 1);
-        Address address = connection().getRoute().address();
+        Address address = connection().route().address();
 
         // Confirm that the interceptor uses the connection we've already prepared.
         if (!request.url().host().equals(address.url().host())
@@ -717,7 +717,7 @@ private Response readNetworkResponse() throws IOException {
 
     Response networkResponse = httpStream.readResponseHeaders()
         .request(networkRequest)
-        .handshake(streamAllocation.connection().getHandshake())
+        .handshake(streamAllocation.connection().handshake())
         .header(OkHeaders.SENT_MILLIS, Long.toString(sentRequestMillis))
         .header(OkHeaders.RECEIVED_MILLIS, Long.toString(System.currentTimeMillis()))
         .build();
@@ -869,7 +869,7 @@ public Request followUpRequest() throws IOException {
     if (userResponse == null) throw new IllegalStateException();
     Connection connection = streamAllocation.connection();
     Route route = connection != null
-        ? connection.getRoute()
+        ? connection.route()
         : null;
     int responseCode = userResponse.code();
 
diff --git a/okhttp/src/main/java/okhttp3/internal/http/StreamAllocation.java b/okhttp/src/main/java/okhttp3/internal/http/StreamAllocation.java
index b3853c32f8..6f3146f422 100644
--- a/okhttp/src/main/java/okhttp3/internal/http/StreamAllocation.java
+++ b/okhttp/src/main/java/okhttp3/internal/http/StreamAllocation.java
@@ -101,7 +101,7 @@ public HttpStream newStream(int connectTimeout, int readTimeout, int writeTimeou
       if (resultConnection.framedConnection != null) {
         resultStream = new Http2xStream(this, resultConnection.framedConnection);
       } else {
-        resultConnection.getSocket().setSoTimeout(readTimeout);
+        resultConnection.socket().setSoTimeout(readTimeout);
         resultConnection.source.timeout().timeout(readTimeout, MILLISECONDS);
         resultConnection.sink.timeout().timeout(writeTimeout, MILLISECONDS);
         resultStream = new Http1xStream(this, resultConnection.source, resultConnection.sink);
@@ -177,7 +177,7 @@ private RealConnection findConnection(int connectTimeout, int readTimeout, int w
 
     newConnection.connect(connectTimeout, readTimeout, writeTimeout, address.connectionSpecs(),
         connectionRetryEnabled);
-    routeDatabase().connected(newConnection.getRoute());
+    routeDatabase().connected(newConnection.route());
 
     return newConnection;
   }
@@ -247,7 +247,7 @@ private void deallocate(boolean noNewStreams, boolean released, boolean streamFi
       }
     }
     if (connectionToClose != null) {
-      Util.closeQuietly(connectionToClose.getSocket());
+      Util.closeQuietly(connectionToClose.socket());
     }
   }
 
diff --git a/okhttp/src/main/java/okhttp3/internal/io/RealConnection.java b/okhttp/src/main/java/okhttp3/internal/io/RealConnection.java
index f4fa537e9a..c6d7ecc54b 100644
--- a/okhttp/src/main/java/okhttp3/internal/io/RealConnection.java
+++ b/okhttp/src/main/java/okhttp3/internal/io/RealConnection.java
@@ -297,7 +297,7 @@ boolean isConnected() {
     return protocol != null;
   }
 
-  @Override public Route getRoute() {
+  @Override public Route route() {
     return route;
   }
 
@@ -306,7 +306,7 @@ public void cancel() {
     closeQuietly(rawSocket);
   }
 
-  @Override public Socket getSocket() {
+  @Override public Socket socket() {
     return socket;
   }
 
@@ -349,7 +349,7 @@ public boolean isHealthy(boolean doExtensiveChecks) {
     return true;
   }
 
-  @Override public Handshake getHandshake() {
+  @Override public Handshake handshake() {
     return handshake;
   }
 
@@ -361,7 +361,7 @@ public boolean isMultiplexed() {
     return framedConnection != null;
   }
 
-  @Override public Protocol getProtocol() {
+  @Override public Protocol protocol() {
     return protocol != null ? protocol : Protocol.HTTP_1_1;
   }
 
diff --git a/samples/guide/src/main/java/okhttp3/recipes/CheckHandshake.java b/samples/guide/src/main/java/okhttp3/recipes/CheckHandshake.java
index d1ba3cee16..504e9c0a3e 100644
--- a/samples/guide/src/main/java/okhttp3/recipes/CheckHandshake.java
+++ b/samples/guide/src/main/java/okhttp3/recipes/CheckHandshake.java
@@ -31,7 +31,7 @@
     Set<String> blacklist = Collections.singleton("sha1/DmxUShsZuNiqPQsX2Oi9uv2sCnw=");
 
     @Override public Response intercept(Chain chain) throws IOException {
-      for (Certificate certificate : chain.connection().getHandshake().peerCertificates()) {
+      for (Certificate certificate : chain.connection().handshake().peerCertificates()) {
         String pin = CertificatePinner.pin(certificate);
         if (blacklist.contains(pin)) {
           throw new IOException("Blacklisted peer certificate: " + pin);
