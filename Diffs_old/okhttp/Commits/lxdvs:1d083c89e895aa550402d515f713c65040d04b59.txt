diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/NamedRunnable.java b/okhttp/src/main/java/com/squareup/okhttp/internal/NamedRunnable.java
new file mode 100644
index 0000000000..992b2ae419
--- /dev/null
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/NamedRunnable.java
@@ -0,0 +1,40 @@
+/*
+ * Copyright (C) 2013 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.squareup.okhttp.internal;
+
+/**
+ * Runnable implementation which always sets its thread name.
+ */
+public abstract class NamedRunnable implements Runnable {
+  private final String name;
+
+  public NamedRunnable(String format, Object... args) {
+    this.name = String.format(format, args);
+  }
+
+  @Override public final void run() {
+    String oldName = Thread.currentThread().getName();
+    Thread.currentThread().setName(name);
+    try {
+      execute();
+    } finally {
+      Thread.currentThread().setName(oldName);
+    }
+  }
+
+  protected abstract void execute();
+}
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/Platform.java b/okhttp/src/main/java/com/squareup/okhttp/internal/Platform.java
new file mode 100644
index 0000000000..905641a30a
--- /dev/null
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/Platform.java
@@ -0,0 +1,422 @@
+/*
+ * Copyright (C) 2012 Square, Inc.
+ * Copyright (C) 2012 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.okhttp.internal;
+
+import java.io.IOException;
+import java.io.OutputStream;
+import java.io.UnsupportedEncodingException;
+import java.lang.reflect.Constructor;
+import java.lang.reflect.InvocationHandler;
+import java.lang.reflect.InvocationTargetException;
+import java.lang.reflect.Method;
+import java.lang.reflect.Proxy;
+import java.net.InetSocketAddress;
+import java.net.NetworkInterface;
+import java.net.Socket;
+import java.net.SocketException;
+import java.net.URI;
+import java.net.URISyntaxException;
+import java.net.URL;
+import java.util.ArrayList;
+import java.util.List;
+import java.util.logging.Level;
+import java.util.logging.Logger;
+import java.util.zip.Deflater;
+import java.util.zip.DeflaterOutputStream;
+import javax.net.ssl.SSLSocket;
+
+/**
+ * Access to Platform-specific features necessary for SPDY and advanced TLS.
+ *
+ * <h3>SPDY</h3>
+ * SPDY requires a TLS extension called NPN (Next Protocol Negotiation) that's
+ * available in Android 4.1+ and OpenJDK 7+ (with the npn-boot extension). It
+ * also requires a recent version of {@code DeflaterOutputStream} that is
+ * public API in Java 7 and callable via reflection in Android 4.1+.
+ */
+public class Platform {
+  private static final Platform PLATFORM = findPlatform();
+
+  private Constructor<DeflaterOutputStream> deflaterConstructor;
+
+  public static Platform get() {
+    return PLATFORM;
+  }
+
+  /** Prefix used on custom headers. */
+  public String getPrefix() {
+    return "OkHttp";
+  }
+
+  public void logW(String warning) {
+    System.out.println(warning);
+  }
+
+  public void tagSocket(Socket socket) throws SocketException {
+  }
+
+  public void untagSocket(Socket socket) throws SocketException {
+  }
+
+  public URI toUriLenient(URL url) throws URISyntaxException {
+    return url.toURI(); // this isn't as good as the built-in toUriLenient
+  }
+
+  /**
+   * Attempt a TLS connection with useful extensions enabled. This mode
+   * supports more features, but is less likely to be compatible with older
+   * HTTPS servers.
+   */
+  public void enableTlsExtensions(SSLSocket socket, String uriHost) {
+  }
+
+  /**
+   * Attempt a secure connection with basic functionality to maximize
+   * compatibility. Currently this uses SSL 3.0.
+   */
+  public void supportTlsIntolerantServer(SSLSocket socket) {
+    socket.setEnabledProtocols(new String[] {"SSLv3"});
+  }
+
+  /** Returns the negotiated protocol, or null if no protocol was negotiated. */
+  public byte[] getNpnSelectedProtocol(SSLSocket socket) {
+    return null;
+  }
+
+  /**
+   * Sets client-supported protocols on a socket to send to a server. The
+   * protocols are only sent if the socket implementation supports NPN.
+   */
+  public void setNpnProtocols(SSLSocket socket, byte[] npnProtocols) {
+  }
+
+  public void connectSocket(Socket socket, InetSocketAddress address,
+      int connectTimeout) throws IOException {
+    socket.connect(address, connectTimeout);
+  }
+
+  /**
+   * Returns a deflater output stream that supports SYNC_FLUSH for SPDY name
+   * value blocks. This throws an {@link UnsupportedOperationException} on
+   * Java 6 and earlier where there is no built-in API to do SYNC_FLUSH.
+   */
+  public OutputStream newDeflaterOutputStream(OutputStream out, Deflater deflater,
+      boolean syncFlush) {
+    try {
+      Constructor<DeflaterOutputStream> constructor = deflaterConstructor;
+      if (constructor == null) {
+        constructor = deflaterConstructor = DeflaterOutputStream.class.getConstructor(
+            OutputStream.class, Deflater.class, boolean.class);
+      }
+      return constructor.newInstance(out, deflater, syncFlush);
+    } catch (NoSuchMethodException e) {
+      throw new UnsupportedOperationException("Cannot SPDY; no SYNC_FLUSH available");
+    } catch (InvocationTargetException e) {
+      throw e.getCause() instanceof RuntimeException ? (RuntimeException) e.getCause()
+          : new RuntimeException(e.getCause());
+    } catch (InstantiationException e) {
+      throw new RuntimeException(e);
+    } catch (IllegalAccessException e) {
+      throw new AssertionError();
+    }
+  }
+
+  /**
+   * Returns the maximum transmission unit of the network interface used by
+   * {@code socket}, or a reasonable default if this platform doesn't expose the
+   * MTU to the application layer.
+   *
+   * <p>The returned value should only be used as an optimization; such as to
+   * size buffers efficiently.
+   */
+  public int getMtu(Socket socket) throws IOException {
+    return 1400; // Smaller than 1500 to leave room for headers on interfaces like PPPoE.
+  }
+
+  /** Attempt to match the host runtime to a capable Platform implementation. */
+  private static Platform findPlatform() {
+    Method getMtu;
+    try {
+      getMtu = NetworkInterface.class.getMethod("getMTU");
+    } catch (NoSuchMethodException e) {
+      return new Platform(); // No Java 1.6 APIs. It's either Java 1.5, Android 2.2 or earlier.
+    }
+
+    // Attempt to find Android 2.3+ APIs.
+    Class<?> openSslSocketClass;
+    Method setUseSessionTickets;
+    Method setHostname;
+    try {
+      try {
+        openSslSocketClass = Class.forName("com.android.org.conscrypt.OpenSSLSocketImpl");
+      } catch (ClassNotFoundException ignored) {
+        // Older platform before being unbundled.
+        openSslSocketClass = Class.forName(
+            "org.apache.harmony.xnet.provider.jsse.OpenSSLSocketImpl");
+      }
+
+      setUseSessionTickets = openSslSocketClass.getMethod("setUseSessionTickets", boolean.class);
+      setHostname = openSslSocketClass.getMethod("setHostname", String.class);
+
+      // Attempt to find Android 4.1+ APIs.
+      try {
+        Method setNpnProtocols = openSslSocketClass.getMethod("setNpnProtocols", byte[].class);
+        Method getNpnSelectedProtocol = openSslSocketClass.getMethod("getNpnSelectedProtocol");
+        return new Android41(getMtu, openSslSocketClass, setUseSessionTickets, setHostname,
+            setNpnProtocols, getNpnSelectedProtocol);
+      } catch (NoSuchMethodException ignored) {
+        return new Android23(getMtu, openSslSocketClass, setUseSessionTickets, setHostname);
+      }
+    } catch (ClassNotFoundException ignored) {
+      // This isn't an Android runtime.
+    } catch (NoSuchMethodException ignored) {
+      // This isn't Android 2.3 or better.
+    }
+
+    // Attempt to find the Jetty's NPN extension for OpenJDK.
+    try {
+      String npnClassName = "org.eclipse.jetty.npn.NextProtoNego";
+      Class<?> nextProtoNegoClass = Class.forName(npnClassName);
+      Class<?> providerClass = Class.forName(npnClassName + "$Provider");
+      Class<?> clientProviderClass = Class.forName(npnClassName + "$ClientProvider");
+      Class<?> serverProviderClass = Class.forName(npnClassName + "$ServerProvider");
+      Method putMethod = nextProtoNegoClass.getMethod("put", SSLSocket.class, providerClass);
+      Method getMethod = nextProtoNegoClass.getMethod("get", SSLSocket.class);
+      return new JdkWithJettyNpnPlatform(getMtu, putMethod, getMethod, clientProviderClass,
+          serverProviderClass);
+    } catch (ClassNotFoundException ignored) {
+      // NPN isn't on the classpath.
+    } catch (NoSuchMethodException ignored) {
+      // The NPN version isn't what we expect.
+    }
+
+    return new Java6(getMtu);
+  }
+
+  private static class Java6 extends Platform {
+    private final Method getMtu;
+
+    private Java6(Method getMtu) {
+      this.getMtu = getMtu;
+    }
+
+    @Override public int getMtu(Socket socket) throws IOException {
+      try {
+        NetworkInterface networkInterface = NetworkInterface.getByInetAddress(
+            socket.getLocalAddress());
+        if (networkInterface == null) {
+          return super.getMtu(socket); // There's no longer an interface with this local address.
+        }
+        return (Integer) getMtu.invoke(networkInterface);
+      } catch (NullPointerException e) {
+        // Certain Alcatel devices throw on getByInetAddress. Return default.
+        return super.getMtu(socket);
+      } catch (SocketException e) {
+        // Certain Motorola devices always throw on getByInetAddress. Return the default for those.
+        return super.getMtu(socket);
+      } catch (IllegalAccessException e) {
+        throw new AssertionError(e);
+      } catch (InvocationTargetException e) {
+        if (e.getCause() instanceof IOException) throw (IOException) e.getCause();
+        throw new RuntimeException(e.getCause());
+      }
+    }
+  }
+
+  /** Android version 2.3 and newer support TLS session tickets and server name indication (SNI). */
+  private static class Android23 extends Java6 {
+    protected final Class<?> openSslSocketClass;
+    private final Method setUseSessionTickets;
+    private final Method setHostname;
+
+    private Android23(Method getMtu, Class<?> openSslSocketClass, Method setUseSessionTickets,
+        Method setHostname) {
+      super(getMtu);
+      this.openSslSocketClass = openSslSocketClass;
+      this.setUseSessionTickets = setUseSessionTickets;
+      this.setHostname = setHostname;
+    }
+
+    @Override public void connectSocket(Socket socket, InetSocketAddress address,
+        int connectTimeout) throws IOException {
+      try {
+        socket.connect(address, connectTimeout);
+      } catch (SecurityException se) {
+        // Before android 4.3, socket.connect could throw a SecurityException
+        // if opening a socket resulted in an EACCES error.
+        IOException ioException = new IOException("Exception in connect");
+        ioException.initCause(se);
+        throw ioException;
+      }
+    }
+
+    @Override public void enableTlsExtensions(SSLSocket socket, String uriHost) {
+      super.enableTlsExtensions(socket, uriHost);
+      if (openSslSocketClass.isInstance(socket)) {
+        // This is Android: use reflection on OpenSslSocketImpl.
+        try {
+          setUseSessionTickets.invoke(socket, true);
+          setHostname.invoke(socket, uriHost);
+        } catch (InvocationTargetException e) {
+          throw new RuntimeException(e);
+        } catch (IllegalAccessException e) {
+          throw new AssertionError(e);
+        }
+      }
+    }
+  }
+
+  /** Android version 4.1 and newer support NPN. */
+  private static class Android41 extends Android23 {
+    private final Method setNpnProtocols;
+    private final Method getNpnSelectedProtocol;
+
+    private Android41(Method getMtu, Class<?> openSslSocketClass, Method setUseSessionTickets,
+        Method setHostname, Method setNpnProtocols, Method getNpnSelectedProtocol) {
+      super(getMtu, openSslSocketClass, setUseSessionTickets, setHostname);
+      this.setNpnProtocols = setNpnProtocols;
+      this.getNpnSelectedProtocol = getNpnSelectedProtocol;
+    }
+
+    @Override public void setNpnProtocols(SSLSocket socket, byte[] npnProtocols) {
+      if (!openSslSocketClass.isInstance(socket)) {
+        return;
+      }
+      try {
+        setNpnProtocols.invoke(socket, new Object[] {npnProtocols});
+      } catch (IllegalAccessException e) {
+        throw new AssertionError(e);
+      } catch (InvocationTargetException e) {
+        throw new RuntimeException(e);
+      }
+    }
+
+    @Override public byte[] getNpnSelectedProtocol(SSLSocket socket) {
+      if (!openSslSocketClass.isInstance(socket)) {
+        return null;
+      }
+      try {
+        return (byte[]) getNpnSelectedProtocol.invoke(socket);
+      } catch (InvocationTargetException e) {
+        throw new RuntimeException(e);
+      } catch (IllegalAccessException e) {
+        throw new AssertionError(e);
+      }
+    }
+  }
+
+  /** OpenJDK 7 plus {@code org.mortbay.jetty.npn/npn-boot} on the boot class path. */
+  private static class JdkWithJettyNpnPlatform extends Java6 {
+    private final Method getMethod;
+    private final Method putMethod;
+    private final Class<?> clientProviderClass;
+    private final Class<?> serverProviderClass;
+
+    public JdkWithJettyNpnPlatform(Method getMtu, Method putMethod, Method getMethod,
+        Class<?> clientProviderClass, Class<?> serverProviderClass) {
+      super(getMtu);
+      this.putMethod = putMethod;
+      this.getMethod = getMethod;
+      this.clientProviderClass = clientProviderClass;
+      this.serverProviderClass = serverProviderClass;
+    }
+
+    @Override public void setNpnProtocols(SSLSocket socket, byte[] npnProtocols) {
+      try {
+        List<String> strings = new ArrayList<String>();
+        for (int i = 0; i < npnProtocols.length; ) {
+          int length = npnProtocols[i++];
+          strings.add(new String(npnProtocols, i, length, "US-ASCII"));
+          i += length;
+        }
+        Object provider = Proxy.newProxyInstance(Platform.class.getClassLoader(),
+            new Class[] {clientProviderClass, serverProviderClass},
+            new JettyNpnProvider(strings));
+        putMethod.invoke(null, socket, provider);
+      } catch (UnsupportedEncodingException e) {
+        throw new AssertionError(e);
+      } catch (InvocationTargetException e) {
+        throw new AssertionError(e);
+      } catch (IllegalAccessException e) {
+        throw new AssertionError(e);
+      }
+    }
+
+    @Override public byte[] getNpnSelectedProtocol(SSLSocket socket) {
+      try {
+        JettyNpnProvider provider =
+            (JettyNpnProvider) Proxy.getInvocationHandler(getMethod.invoke(null, socket));
+        if (!provider.unsupported && provider.selected == null) {
+          Logger logger = Logger.getLogger("com.squareup.okhttp.OkHttpClient");
+          logger.log(Level.INFO,
+              "NPN callback dropped so SPDY is disabled. " + "Is npn-boot on the boot class path?");
+          return null;
+        }
+        return provider.unsupported ? null : provider.selected.getBytes("US-ASCII");
+      } catch (UnsupportedEncodingException e) {
+        throw new AssertionError();
+      } catch (InvocationTargetException e) {
+        throw new AssertionError();
+      } catch (IllegalAccessException e) {
+        throw new AssertionError();
+      }
+    }
+  }
+
+  /**
+   * Handle the methods of NextProtoNego's ClientProvider and ServerProvider
+   * without a compile-time dependency on those interfaces.
+   */
+  private static class JettyNpnProvider implements InvocationHandler {
+    private final List<String> protocols;
+    private boolean unsupported;
+    private String selected;
+
+    public JettyNpnProvider(List<String> protocols) {
+      this.protocols = protocols;
+    }
+
+    @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
+      String methodName = method.getName();
+      Class<?> returnType = method.getReturnType();
+      if (args == null) {
+        args = Util.EMPTY_STRING_ARRAY;
+      }
+      if (methodName.equals("supports") && boolean.class == returnType) {
+        return true;
+      } else if (methodName.equals("unsupported") && void.class == returnType) {
+        this.unsupported = true;
+        return null;
+      } else if (methodName.equals("protocols") && args.length == 0) {
+        return protocols;
+      } else if (methodName.equals("selectProtocol")
+          && String.class == returnType
+          && args.length == 1
+          && (args[0] == null || args[0] instanceof List)) {
+        // TODO: use OpenSSL's algorithm which uses both lists
+        List<?> serverProtocols = (List) args[0];
+        this.selected = protocols.get(0);
+        return selected;
+      } else if (methodName.equals("protocolSelected") && args.length == 1) {
+        this.selected = (String) args[0];
+        return null;
+      } else {
+        return method.invoke(this, args);
+      }
+    }
+  }
+}
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/Util.java b/okhttp/src/main/java/com/squareup/okhttp/internal/Util.java
new file mode 100644
index 0000000000..d1b285708e
--- /dev/null
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/Util.java
@@ -0,0 +1,348 @@
+/*
+ * Copyright (C) 2012 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.squareup.okhttp.internal;
+
+import java.io.Closeable;
+import java.io.EOFException;
+import java.io.File;
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.OutputStream;
+import java.io.Reader;
+import java.io.StringWriter;
+import java.net.Socket;
+import java.net.URI;
+import java.net.URL;
+import java.nio.ByteOrder;
+import java.nio.charset.Charset;
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.List;
+import java.util.concurrent.ThreadFactory;
+import java.util.concurrent.atomic.AtomicReference;
+
+/** Junk drawer of utility methods. */
+public final class Util {
+  public static final byte[] EMPTY_BYTE_ARRAY = new byte[0];
+  public static final String[] EMPTY_STRING_ARRAY = new String[0];
+
+  /** A cheap and type-safe constant for the ISO-8859-1 Charset. */
+  public static final Charset ISO_8859_1 = Charset.forName("ISO-8859-1");
+
+  /** A cheap and type-safe constant for the US-ASCII Charset. */
+  public static final Charset US_ASCII = Charset.forName("US-ASCII");
+
+  /** A cheap and type-safe constant for the UTF-8 Charset. */
+  public static final Charset UTF_8 = Charset.forName("UTF-8");
+  private static AtomicReference<byte[]> skipBuffer = new AtomicReference<byte[]>();
+
+  private Util() {
+  }
+
+  public static int getEffectivePort(URI uri) {
+    return getEffectivePort(uri.getScheme(), uri.getPort());
+  }
+
+  public static int getEffectivePort(URL url) {
+    return getEffectivePort(url.getProtocol(), url.getPort());
+  }
+
+  private static int getEffectivePort(String scheme, int specifiedPort) {
+    return specifiedPort != -1 ? specifiedPort : getDefaultPort(scheme);
+  }
+
+  public static int getDefaultPort(String scheme) {
+    if ("http".equalsIgnoreCase(scheme)) {
+      return 80;
+    } else if ("https".equalsIgnoreCase(scheme)) {
+      return 443;
+    } else {
+      return -1;
+    }
+  }
+
+  public static void checkOffsetAndCount(int arrayLength, int offset, int count) {
+    if ((offset | count) < 0 || offset > arrayLength || arrayLength - offset < count) {
+      throw new ArrayIndexOutOfBoundsException();
+    }
+  }
+
+  public static void pokeInt(byte[] dst, int offset, int value, ByteOrder order) {
+    if (order == ByteOrder.BIG_ENDIAN) {
+      dst[offset++] = (byte) ((value >> 24) & 0xff);
+      dst[offset++] = (byte) ((value >> 16) & 0xff);
+      dst[offset++] = (byte) ((value >> 8) & 0xff);
+      dst[offset] = (byte) ((value >> 0) & 0xff);
+    } else {
+      dst[offset++] = (byte) ((value >> 0) & 0xff);
+      dst[offset++] = (byte) ((value >> 8) & 0xff);
+      dst[offset++] = (byte) ((value >> 16) & 0xff);
+      dst[offset] = (byte) ((value >> 24) & 0xff);
+    }
+  }
+
+  /** Returns true if two possibly-null objects are equal. */
+  public static boolean equal(Object a, Object b) {
+    return a == b || (a != null && a.equals(b));
+  }
+
+  /**
+   * Closes {@code closeable}, ignoring any checked exceptions. Does nothing
+   * if {@code closeable} is null.
+   */
+  public static void closeQuietly(Closeable closeable) {
+    if (closeable != null) {
+      try {
+        closeable.close();
+      } catch (RuntimeException rethrown) {
+        throw rethrown;
+      } catch (Exception ignored) {
+      }
+    }
+  }
+
+  /**
+   * Closes {@code socket}, ignoring any checked exceptions. Does nothing if
+   * {@code socket} is null.
+   */
+  public static void closeQuietly(Socket socket) {
+    if (socket != null) {
+      try {
+        socket.close();
+      } catch (RuntimeException rethrown) {
+        throw rethrown;
+      } catch (Exception ignored) {
+      }
+    }
+  }
+
+  /**
+   * Closes {@code a} and {@code b}. If either close fails, this completes
+   * the other close and rethrows the first encountered exception.
+   */
+  public static void closeAll(Closeable a, Closeable b) throws IOException {
+    Throwable thrown = null;
+    try {
+      a.close();
+    } catch (Throwable e) {
+      thrown = e;
+    }
+    try {
+      b.close();
+    } catch (Throwable e) {
+      if (thrown == null) thrown = e;
+    }
+    if (thrown == null) return;
+    if (thrown instanceof IOException) throw (IOException) thrown;
+    if (thrown instanceof RuntimeException) throw (RuntimeException) thrown;
+    if (thrown instanceof Error) throw (Error) thrown;
+    throw new AssertionError(thrown);
+  }
+
+  /**
+   * Deletes the contents of {@code dir}. Throws an IOException if any file
+   * could not be deleted, or if {@code dir} is not a readable directory.
+   */
+  public static void deleteContents(File dir) throws IOException {
+    File[] files = dir.listFiles();
+    if (files == null) {
+      throw new IOException("not a readable directory: " + dir);
+    }
+    for (File file : files) {
+      if (file.isDirectory()) {
+        deleteContents(file);
+      }
+      if (!file.delete()) {
+        throw new IOException("failed to delete file: " + file);
+      }
+    }
+  }
+
+  /**
+   * Implements InputStream.read(int) in terms of InputStream.read(byte[], int, int).
+   * InputStream assumes that you implement InputStream.read(int) and provides default
+   * implementations of the others, but often the opposite is more efficient.
+   */
+  public static int readSingleByte(InputStream in) throws IOException {
+    byte[] buffer = new byte[1];
+    int result = in.read(buffer, 0, 1);
+    return (result != -1) ? buffer[0] & 0xff : -1;
+  }
+
+  /**
+   * Implements OutputStream.write(int) in terms of OutputStream.write(byte[], int, int).
+   * OutputStream assumes that you implement OutputStream.write(int) and provides default
+   * implementations of the others, but often the opposite is more efficient.
+   */
+  public static void writeSingleByte(OutputStream out, int b) throws IOException {
+    byte[] buffer = new byte[1];
+    buffer[0] = (byte) (b & 0xff);
+    out.write(buffer);
+  }
+
+  /**
+   * Fills 'dst' with bytes from 'in', throwing EOFException if insufficient bytes are available.
+   */
+  public static void readFully(InputStream in, byte[] dst) throws IOException {
+    readFully(in, dst, 0, dst.length);
+  }
+
+  /**
+   * Reads exactly 'byteCount' bytes from 'in' (into 'dst' at offset 'offset'), and throws
+   * EOFException if insufficient bytes are available.
+   *
+   * Used to implement {@link java.io.DataInputStream#readFully(byte[], int, int)}.
+   */
+  public static void readFully(InputStream in, byte[] dst, int offset, int byteCount)
+      throws IOException {
+    if (byteCount == 0) {
+      return;
+    }
+    if (in == null) {
+      throw new NullPointerException("in == null");
+    }
+    if (dst == null) {
+      throw new NullPointerException("dst == null");
+    }
+    checkOffsetAndCount(dst.length, offset, byteCount);
+    while (byteCount > 0) {
+      int bytesRead = in.read(dst, offset, byteCount);
+      if (bytesRead < 0) {
+        throw new EOFException();
+      }
+      offset += bytesRead;
+      byteCount -= bytesRead;
+    }
+  }
+
+  /** Returns the remainder of 'reader' as a string, closing it when done. */
+  public static String readFully(Reader reader) throws IOException {
+    try {
+      StringWriter writer = new StringWriter();
+      char[] buffer = new char[1024];
+      int count;
+      while ((count = reader.read(buffer)) != -1) {
+        writer.write(buffer, 0, count);
+      }
+      return writer.toString();
+    } finally {
+      reader.close();
+    }
+  }
+
+  public static void skipAll(InputStream in) throws IOException {
+    do {
+      in.skip(Long.MAX_VALUE);
+    } while (in.read() != -1);
+  }
+
+  /**
+   * Call {@code in.read()} repeatedly until either the stream is exhausted or
+   * {@code byteCount} bytes have been read.
+   *
+   * <p>This method reuses the skip buffer but is careful to never use it at
+   * the same time that another stream is using it. Otherwise streams that use
+   * the caller's buffer for consistency checks like CRC could be clobbered by
+   * other threads. A thread-local buffer is also insufficient because some
+   * streams may call other streams in their skip() method, also clobbering the
+   * buffer.
+   */
+  public static long skipByReading(InputStream in, long byteCount) throws IOException {
+    if (byteCount == 0) return 0L;
+
+    // acquire the shared skip buffer.
+    byte[] buffer = skipBuffer.getAndSet(null);
+    if (buffer == null) {
+      buffer = new byte[4096];
+    }
+
+    long skipped = 0;
+    while (skipped < byteCount) {
+      int toRead = (int) Math.min(byteCount - skipped, buffer.length);
+      int read = in.read(buffer, 0, toRead);
+      if (read == -1) {
+        break;
+      }
+      skipped += read;
+      if (read < toRead) {
+        break;
+      }
+    }
+
+    // release the shared skip buffer.
+    skipBuffer.set(buffer);
+
+    return skipped;
+  }
+
+  /**
+   * Copies all of the bytes from {@code in} to {@code out}. Neither stream is closed.
+   * Returns the total number of bytes transferred.
+   */
+  public static int copy(InputStream in, OutputStream out) throws IOException {
+    int total = 0;
+    byte[] buffer = new byte[8192];
+    int c;
+    while ((c = in.read(buffer)) != -1) {
+      total += c;
+      out.write(buffer, 0, c);
+    }
+    return total;
+  }
+
+  /**
+   * Returns the ASCII characters up to but not including the next "\r\n", or
+   * "\n".
+   *
+   * @throws java.io.EOFException if the stream is exhausted before the next newline
+   * character.
+   */
+  public static String readAsciiLine(InputStream in) throws IOException {
+    // TODO: support UTF-8 here instead
+    StringBuilder result = new StringBuilder(80);
+    while (true) {
+      int c = in.read();
+      if (c == -1) {
+        throw new EOFException();
+      } else if (c == '\n') {
+        break;
+      }
+
+      result.append((char) c);
+    }
+    int length = result.length();
+    if (length > 0 && result.charAt(length - 1) == '\r') {
+      result.setLength(length - 1);
+    }
+    return result.toString();
+  }
+
+  /** Returns an immutable copy of {@code list}. */
+  public static <T> List<T> immutableList(List<T> list) {
+    return Collections.unmodifiableList(new ArrayList<T>(list));
+  }
+
+  public static ThreadFactory daemonThreadFactory(final String name) {
+    return new ThreadFactory() {
+      @Override public Thread newThread(Runnable runnable) {
+        Thread result = new Thread(runnable, name);
+        result.setDaemon(true);
+        return result;
+      }
+    };
+  }
+}
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpURLConnectionImpl.java b/okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpURLConnectionImpl.java
index 214f25add9..f5174d8243 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpURLConnectionImpl.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpURLConnectionImpl.java
@@ -17,10 +17,8 @@
 
 package com.squareup.okhttp.internal.http;
 
-import com.squareup.okhttp.Connection;
-import com.squareup.okhttp.OkHttpClient;
-import com.squareup.okhttp.internal.Platform;
-import com.squareup.okhttp.internal.Util;
+import static com.squareup.okhttp.internal.Util.getEffectivePort;
+
 import java.io.FileNotFoundException;
 import java.io.IOException;
 import java.io.InputStream;
@@ -38,9 +36,13 @@
 import java.util.List;
 import java.util.Map;
 import java.util.concurrent.TimeUnit;
+
 import javax.net.ssl.SSLHandshakeException;
 
-import static com.squareup.okhttp.internal.Util.getEffectivePort;
+import com.squareup.okhttp.Connection;
+import com.squareup.okhttp.OkHttpClient;
+import com.squareup.okhttp.internal.Platform;
+import com.squareup.okhttp.internal.Util;
 
 /**
  * This implementation uses HttpEngine to send requests and receive responses.
@@ -58,510 +60,544 @@
  */
 public class HttpURLConnectionImpl extends HttpURLConnection implements Policy {
 
-  /** Numeric status code, 307: Temporary Redirect. */
-  static final int HTTP_TEMP_REDIRECT = 307;
-
-  /**
-   * How many redirects should we follow? Chrome follows 21; Firefox, curl,
-   * and wget follow 20; Safari follows 16; and HTTP/1.0 recommends 5.
-   */
-  private static final int MAX_REDIRECTS = 20;
-
-  final OkHttpClient client;
-
-  private final RawHeaders rawRequestHeaders = new RawHeaders();
-  /** Like the superclass field of the same name, but a long and available on all platforms. */
-  private long fixedContentLength = -1;
-  private int redirectionCount;
-  protected IOException httpEngineFailure;
-  protected HttpEngine httpEngine;
-
-  public HttpURLConnectionImpl(URL url, OkHttpClient client) {
-    super(url);
-    this.client = client;
-  }
-
-  @Override public final void connect() throws IOException {
-    initHttpEngine();
-    boolean success;
-    do {
-      success = execute(false);
-    } while (!success);
-  }
-
-  @Override public final void disconnect() {
-    // Calling disconnect() before a connection exists should have no effect.
-    if (httpEngine != null) {
-      // We close the response body here instead of in
-      // HttpEngine.release because that is called when input
-      // has been completely read from the underlying socket.
-      // However the response body can be a GZIPInputStream that
-      // still has unread data.
-      if (httpEngine.hasResponse()) {
-        Util.closeQuietly(httpEngine.getResponseBody());
-      }
-      httpEngine.release(true);
-    }
-  }
-
-  /**
-   * Returns an input stream from the server in the case of error such as the
-   * requested file (txt, htm, html) is not found on the remote server.
-   */
-  @Override public final InputStream getErrorStream() {
-    try {
-      HttpEngine response = getResponse();
-      if (response.hasResponseBody() && response.getResponseCode() >= HTTP_BAD_REQUEST) {
-        return response.getResponseBody();
-      }
-      return null;
-    } catch (IOException e) {
-      return null;
-    }
-  }
-
-  /**
-   * Returns the value of the field at {@code position}. Returns null if there
-   * are fewer than {@code position} headers.
-   */
-  @Override public final String getHeaderField(int position) {
-    try {
-      return getResponse().getResponseHeaders().getHeaders().getValue(position);
-    } catch (IOException e) {
-      return null;
-    }
-  }
-
-  /**
-   * Returns the value of the field corresponding to the {@code fieldName}, or
-   * null if there is no such field. If the field has multiple values, the
-   * last value is returned.
-   */
-  @Override public final String getHeaderField(String fieldName) {
-    try {
-      RawHeaders rawHeaders = getResponse().getResponseHeaders().getHeaders();
-      return fieldName == null ? rawHeaders.getStatusLine() : rawHeaders.get(fieldName);
-    } catch (IOException e) {
-      return null;
-    }
-  }
-
-  @Override public final String getHeaderFieldKey(int position) {
-    try {
-      return getResponse().getResponseHeaders().getHeaders().getFieldName(position);
-    } catch (IOException e) {
-      return null;
-    }
-  }
-
-  @Override public final Map<String, List<String>> getHeaderFields() {
-    try {
-      return getResponse().getResponseHeaders().getHeaders().toMultimap(true);
-    } catch (IOException e) {
-      return null;
-    }
-  }
-
-  @Override public final Map<String, List<String>> getRequestProperties() {
-    if (connected) {
-      throw new IllegalStateException(
-          "Cannot access request header fields after connection is set");
-    }
-    return rawRequestHeaders.toMultimap(false);
-  }
-
-  @Override public final InputStream getInputStream() throws IOException {
-    if (!doInput) {
-      throw new ProtocolException("This protocol does not support input");
-    }
-
-    HttpEngine response = getResponse();
-
-    // if the requested file does not exist, throw an exception formerly the
-    // Error page from the server was returned if the requested file was
-    // text/html this has changed to return FileNotFoundException for all
-    // file types
-    if (getResponseCode() >= HTTP_BAD_REQUEST) {
-      throw new FileNotFoundException(url.toString());
-    }
-
-    InputStream result = response.getResponseBody();
-    if (result == null) {
-      throw new ProtocolException("No response body exists; responseCode=" + getResponseCode());
-    }
-    return result;
-  }
-
-  @Override public final OutputStream getOutputStream() throws IOException {
-    connect();
-
-    OutputStream out = httpEngine.getRequestBody();
-    if (out == null) {
-      throw new ProtocolException("method does not support a request body: " + method);
-    } else if (httpEngine.hasResponse()) {
-      throw new ProtocolException("cannot write request body after response has been read");
-    }
-
-    return out;
-  }
-
-  @Override public final Permission getPermission() throws IOException {
-    String hostName = getURL().getHost();
-    int hostPort = Util.getEffectivePort(getURL());
-    if (usingProxy()) {
-      InetSocketAddress proxyAddress = (InetSocketAddress) client.getProxy().address();
-      hostName = proxyAddress.getHostName();
-      hostPort = proxyAddress.getPort();
-    }
-    return new SocketPermission(hostName + ":" + hostPort, "connect, resolve");
-  }
-
-  @Override public final String getRequestProperty(String field) {
-    if (field == null) {
-      return null;
-    }
-    return rawRequestHeaders.get(field);
-  }
-
-  @Override public void setConnectTimeout(int timeoutMillis) {
-    client.setConnectTimeout(timeoutMillis, TimeUnit.MILLISECONDS);
-  }
-
-  @Override public int getConnectTimeout() {
-    return client.getConnectTimeout();
-  }
-
-  @Override public void setReadTimeout(int timeoutMillis) {
-    client.setReadTimeout(timeoutMillis, TimeUnit.MILLISECONDS);
-  }
-
-  @Override public int getReadTimeout() {
-    return client.getReadTimeout();
-  }
-
-  private void initHttpEngine() throws IOException {
-    if (httpEngineFailure != null) {
-      throw httpEngineFailure;
-    } else if (httpEngine != null) {
-      return;
+    /** Numeric status code, 307: Temporary Redirect. */
+    static final int HTTP_TEMP_REDIRECT = 307;
+
+    /**
+     * How many redirects should we follow? Chrome follows 21; Firefox, curl,
+     * and wget follow 20; Safari follows 16; and HTTP/1.0 recommends 5.
+     */
+    private static final int MAX_REDIRECTS = 20;
+
+    final OkHttpClient client;
+
+    private final RawHeaders rawRequestHeaders = new RawHeaders();
+    /** Like the superclass field of the same name, but a long and available on all platforms. */
+    private long fixedContentLength = -1;
+    private int redirectionCount;
+    protected IOException httpEngineFailure;
+    protected HttpEngine httpEngine;
+    boolean allowFailedPostRetry = true;
+
+    public HttpURLConnectionImpl(URL url, OkHttpClient client) {
+        super(url);
+        this.client = client;
+    }
+
+    @Override
+    public final void connect() throws IOException {
+        initHttpEngine();
+        boolean success;
+        do {
+            success = execute(false);
+        } while (!success);
+    }
+
+    @Override
+    public final void disconnect() {
+        // Calling disconnect() before a connection exists should have no effect.
+        if (httpEngine != null) {
+            // We close the response body here instead of in
+            // HttpEngine.release because that is called when input
+            // has been completely read from the underlying socket.
+            // However the response body can be a GZIPInputStream that
+            // still has unread data.
+            if (httpEngine.hasResponse()) {
+                Util.closeQuietly(httpEngine.getResponseBody());
+            }
+            httpEngine.release(true);
+        }
+    }
+
+    /**
+     * Returns an input stream from the server in the case of error such as the
+     * requested file (txt, htm, html) is not found on the remote server.
+     */
+    @Override
+    public final InputStream getErrorStream() {
+        try {
+            HttpEngine response = getResponse();
+            if (response.hasResponseBody() && response.getResponseCode() >= HTTP_BAD_REQUEST) {
+                return response.getResponseBody();
+            }
+            return null;
+        } catch (IOException e) {
+            return null;
+        }
+    }
+
+    /**
+     * Returns the value of the field at {@code position}. Returns null if there
+     * are fewer than {@code position} headers.
+     */
+    @Override
+    public final String getHeaderField(int position) {
+        try {
+            return getResponse().getResponseHeaders().getHeaders().getValue(position);
+        } catch (IOException e) {
+            return null;
+        }
+    }
+
+    /**
+     * Returns the value of the field corresponding to the {@code fieldName}, or
+     * null if there is no such field. If the field has multiple values, the
+     * last value is returned.
+     */
+    @Override
+    public final String getHeaderField(String fieldName) {
+        try {
+            RawHeaders rawHeaders = getResponse().getResponseHeaders().getHeaders();
+            return fieldName == null ? rawHeaders.getStatusLine() : rawHeaders.get(fieldName);
+        } catch (IOException e) {
+            return null;
+        }
+    }
+
+    @Override
+    public final String getHeaderFieldKey(int position) {
+        try {
+            return getResponse().getResponseHeaders().getHeaders().getFieldName(position);
+        } catch (IOException e) {
+            return null;
+        }
+    }
+
+    @Override
+    public final Map< String, List< String >> getHeaderFields() {
+        try {
+            return getResponse().getResponseHeaders().getHeaders().toMultimap(true);
+        } catch (IOException e) {
+            return null;
+        }
+    }
+
+    @Override
+    public final Map< String, List< String >> getRequestProperties() {
+        if (connected) {
+            throw new IllegalStateException(
+                    "Cannot access request header fields after connection is set");
+        }
+        return rawRequestHeaders.toMultimap(false);
+    }
+
+    @Override
+    public final InputStream getInputStream() throws IOException {
+        if (!doInput) {
+            throw new ProtocolException("This protocol does not support input");
+        }
+
+        HttpEngine response = getResponse();
+
+        // if the requested file does not exist, throw an exception formerly the
+        // Error page from the server was returned if the requested file was
+        // text/html this has changed to return FileNotFoundException for all
+        // file types
+        if (getResponseCode() >= HTTP_BAD_REQUEST) {
+            throw new FileNotFoundException(url.toString());
+        }
+
+        InputStream result = response.getResponseBody();
+        if (result == null) {
+            throw new ProtocolException("No response body exists; responseCode=" + getResponseCode());
+        }
+        return result;
+    }
+
+    @Override
+    public final OutputStream getOutputStream() throws IOException {
+        connect();
+
+        OutputStream out = httpEngine.getRequestBody();
+        if (out == null) {
+            throw new ProtocolException("method does not support a request body: " + method);
+        } else if (httpEngine.hasResponse()) {
+            throw new ProtocolException("cannot write request body after response has been read");
+        }
+
+        return out;
+    }
+
+    @Override
+    public final Permission getPermission() throws IOException {
+        String hostName = getURL().getHost();
+        int hostPort = Util.getEffectivePort(getURL());
+        if (usingProxy()) {
+            InetSocketAddress proxyAddress = (InetSocketAddress) client.getProxy().address();
+            hostName = proxyAddress.getHostName();
+            hostPort = proxyAddress.getPort();
+        }
+        return new SocketPermission(hostName + ":" + hostPort, "connect, resolve");
+    }
+
+    @Override
+    public final String getRequestProperty(String field) {
+        if (field == null) {
+            return null;
+        }
+        return rawRequestHeaders.get(field);
+    }
+
+    @Override
+    public void setConnectTimeout(int timeoutMillis) {
+        client.setConnectTimeout(timeoutMillis, TimeUnit.MILLISECONDS);
+    }
+
+    @Override
+    public int getConnectTimeout() {
+        return client.getConnectTimeout();
+    }
+
+    @Override
+    public void setReadTimeout(int timeoutMillis) {
+        client.setReadTimeout(timeoutMillis, TimeUnit.MILLISECONDS);
+    }
+
+    @Override
+    public int getReadTimeout() {
+        return client.getReadTimeout();
+    }
+
+    private void initHttpEngine() throws IOException {
+        if (httpEngineFailure != null) {
+            throw httpEngineFailure;
+        } else if (httpEngine != null) {
+            return;
+        }
+
+        connected = true;
+        try {
+            if (doOutput) {
+                if (method.equals("GET")) {
+                    // they are requesting a stream to write to. This implies a POST method
+                    method = "POST";
+                } else if (!method.equals("POST") && !method.equals("PUT")) {
+                    // If the request method is neither POST nor PUT, then you're not writing
+                    throw new ProtocolException(method + " does not support writing");
+                }
+            }
+            httpEngine = newHttpEngine(method, rawRequestHeaders, null, null);
+        } catch (IOException e) {
+            httpEngineFailure = e;
+            throw e;
+        }
+    }
+
+    @Override
+    public HttpURLConnection getHttpConnectionToCache() {
+        return this;
+    }
+
+    private HttpEngine newHttpEngine(String method, RawHeaders requestHeaders,
+            Connection connection, RetryableOutputStream requestBody) throws IOException {
+        if (url.getProtocol().equals("http")) {
+            return new HttpEngine(client, this, method, requestHeaders, connection, requestBody);
+        } else if (url.getProtocol().equals("https")) {
+            return new HttpsEngine(client, this, method, requestHeaders, connection, requestBody);
+        } else {
+            throw new AssertionError();
+        }
+    }
+
+    /**
+     * Aggressively tries to get the final HTTP response, potentially making
+     * many HTTP requests in the process in order to cope with redirects and
+     * authentication.
+     */
+    private HttpEngine getResponse() throws IOException {
+        initHttpEngine();
+
+        if (httpEngine.hasResponse()) {
+            return httpEngine;
+        }
+
+        while (true) {
+            if (!execute(true)) {
+                continue;
+            }
+
+            Retry retry = processResponseHeaders();
+            if (retry == Retry.NONE) {
+                httpEngine.automaticallyReleaseConnectionToPool();
+                return httpEngine;
+            }
+
+            // The first request was insufficient. Prepare for another...
+            String retryMethod = method;
+            OutputStream requestBody = httpEngine.getRequestBody();
+
+            // Although RFC 2616 10.3.2 specifies that a HTTP_MOVED_PERM
+            // redirect should keep the same method, Chrome, Firefox and the
+            // RI all issue GETs when following any redirect.
+            int responseCode = getResponseCode();
+            if (responseCode == HTTP_MULT_CHOICE
+                    || responseCode == HTTP_MOVED_PERM
+                    || responseCode == HTTP_MOVED_TEMP
+                    || responseCode == HTTP_SEE_OTHER) {
+                retryMethod = "GET";
+                requestBody = null;
+            }
+
+            if (requestBody != null && !(requestBody instanceof RetryableOutputStream)) {
+                throw new HttpRetryException("Cannot retry streamed HTTP body",
+                        httpEngine.getResponseCode());
+            }
+
+            if (retry == Retry.DIFFERENT_CONNECTION) {
+                httpEngine.automaticallyReleaseConnectionToPool();
+            }
+
+            httpEngine.release(false);
+
+            httpEngine = newHttpEngine(retryMethod, rawRequestHeaders, httpEngine.getConnection(),
+                    (RetryableOutputStream) requestBody);
+        }
     }
 
-    connected = true;
-    try {
-      if (doOutput) {
-        if (method.equals("GET")) {
-          // they are requesting a stream to write to. This implies a POST method
-          method = "POST";
-        } else if (!method.equals("POST") && !method.equals("PUT")) {
-          // If the request method is neither POST nor PUT, then you're not writing
-          throw new ProtocolException(method + " does not support writing");
-        }
-      }
-      httpEngine = newHttpEngine(method, rawRequestHeaders, null, null);
-    } catch (IOException e) {
-      httpEngineFailure = e;
-      throw e;
+    /**
+     * Sends a request and optionally reads a response. Returns true if the
+     * request was successfully executed, and false if the request can be
+     * retried. Throws an exception if the request failed permanently.
+     */
+    private boolean execute(boolean readResponse) throws IOException {
+        try {
+            httpEngine.sendRequest();
+            if (readResponse) {
+                httpEngine.readResponse();
+            }
+            return true;
+        } catch (IOException e) {
+            if (handleFailure(e)) {
+                return false;
+            } else {
+                throw e;
+            }
+        }
     }
-  }
-
-  @Override public HttpURLConnection getHttpConnectionToCache() {
-    return this;
-  }
-
-  private HttpEngine newHttpEngine(String method, RawHeaders requestHeaders,
-      Connection connection, RetryableOutputStream requestBody) throws IOException {
-    if (url.getProtocol().equals("http")) {
-      return new HttpEngine(client, this, method, requestHeaders, connection, requestBody);
-    } else if (url.getProtocol().equals("https")) {
-      return new HttpsEngine(client, this, method, requestHeaders, connection, requestBody);
-    } else {
-      throw new AssertionError();
-    }
-  }
-
-  /**
-   * Aggressively tries to get the final HTTP response, potentially making
-   * many HTTP requests in the process in order to cope with redirects and
-   * authentication.
-   */
-  private HttpEngine getResponse() throws IOException {
-    initHttpEngine();
-
-    if (httpEngine.hasResponse()) {
-      return httpEngine;
-    }
-
-    while (true) {
-      if (!execute(true)) {
-        continue;
-      }
-
-      Retry retry = processResponseHeaders();
-      if (retry == Retry.NONE) {
-        httpEngine.automaticallyReleaseConnectionToPool();
+
+    /**
+     * Report and attempt to recover from {@code e}. Returns true if the HTTP
+     * engine was replaced and the request should be retried. Otherwise the
+     * failure is permanent.
+     */
+    private boolean handleFailure(IOException e) throws IOException {
+        RouteSelector routeSelector = httpEngine.routeSelector;
+        if (routeSelector != null && httpEngine.connection != null) {
+            routeSelector.connectFailed(httpEngine.connection, e);
+        }
+
+        OutputStream requestBody = httpEngine.getRequestBody();
+        boolean canRetryRequestBody = requestBody == null
+                || requestBody instanceof RetryableOutputStream;
+        if (routeSelector == null && httpEngine.connection == null // No connection.
+                || routeSelector != null && !routeSelector.hasNext() // No more routes to attempt.
+                || !isRecoverable(e)
+                || !canRetryRequestBody
+                || !allowFailedPostRetry) {
+            httpEngineFailure = e;
+            return false;
+        }
+
+        httpEngine.release(true);
+        RetryableOutputStream retryableOutputStream = (RetryableOutputStream) requestBody;
+        httpEngine = newHttpEngine(method, rawRequestHeaders, null, retryableOutputStream);
+        httpEngine.routeSelector = routeSelector; // Keep the same routeSelector.
+        return true;
+    }
+
+    private boolean isRecoverable(IOException e) {
+        // If the problem was a CertificateException from the X509TrustManager,
+        // do not retry, we didn't have an abrupt server initiated exception.
+        boolean sslFailure =
+                e instanceof SSLHandshakeException && e.getCause() instanceof CertificateException;
+        boolean protocolFailure = e instanceof ProtocolException;
+        return !sslFailure && !protocolFailure;
+    }
+
+    public HttpEngine getHttpEngine() {
         return httpEngine;
-      }
-
-      // The first request was insufficient. Prepare for another...
-      String retryMethod = method;
-      OutputStream requestBody = httpEngine.getRequestBody();
-
-      // Although RFC 2616 10.3.2 specifies that a HTTP_MOVED_PERM
-      // redirect should keep the same method, Chrome, Firefox and the
-      // RI all issue GETs when following any redirect.
-      int responseCode = getResponseCode();
-      if (responseCode == HTTP_MULT_CHOICE
-          || responseCode == HTTP_MOVED_PERM
-          || responseCode == HTTP_MOVED_TEMP
-          || responseCode == HTTP_SEE_OTHER) {
-        retryMethod = "GET";
-        requestBody = null;
-      }
-
-      if (requestBody != null && !(requestBody instanceof RetryableOutputStream)) {
-        throw new HttpRetryException("Cannot retry streamed HTTP body",
-            httpEngine.getResponseCode());
-      }
-
-      if (retry == Retry.DIFFERENT_CONNECTION) {
-        httpEngine.automaticallyReleaseConnectionToPool();
-      }
-
-      httpEngine.release(false);
-
-      httpEngine = newHttpEngine(retryMethod, rawRequestHeaders, httpEngine.getConnection(),
-          (RetryableOutputStream) requestBody);
-    }
-  }
-
-  /**
-   * Sends a request and optionally reads a response. Returns true if the
-   * request was successfully executed, and false if the request can be
-   * retried. Throws an exception if the request failed permanently.
-   */
-  private boolean execute(boolean readResponse) throws IOException {
-    try {
-      httpEngine.sendRequest();
-      if (readResponse) {
-        httpEngine.readResponse();
-      }
-      return true;
-    } catch (IOException e) {
-      if (handleFailure(e)) {
-        return false;
-      } else {
-        throw e;
-      }
-    }
-  }
-
-  /**
-   * Report and attempt to recover from {@code e}. Returns true if the HTTP
-   * engine was replaced and the request should be retried. Otherwise the
-   * failure is permanent.
-   */
-  private boolean handleFailure(IOException e) throws IOException {
-    RouteSelector routeSelector = httpEngine.routeSelector;
-    if (routeSelector != null && httpEngine.connection != null) {
-      routeSelector.connectFailed(httpEngine.connection, e);
-    }
-
-    OutputStream requestBody = httpEngine.getRequestBody();
-    boolean canRetryRequestBody = requestBody == null
-        || requestBody instanceof RetryableOutputStream;
-    if (routeSelector == null && httpEngine.connection == null // No connection.
-        || routeSelector != null && !routeSelector.hasNext() // No more routes to attempt.
-        || !isRecoverable(e)
-        || !canRetryRequestBody) {
-      httpEngineFailure = e;
-      return false;
-    }
-
-    httpEngine.release(true);
-    RetryableOutputStream retryableOutputStream = (RetryableOutputStream) requestBody;
-    httpEngine = newHttpEngine(method, rawRequestHeaders, null, retryableOutputStream);
-    httpEngine.routeSelector = routeSelector; // Keep the same routeSelector.
-    return true;
-  }
-
-  private boolean isRecoverable(IOException e) {
-    // If the problem was a CertificateException from the X509TrustManager,
-    // do not retry, we didn't have an abrupt server initiated exception.
-    boolean sslFailure =
-        e instanceof SSLHandshakeException && e.getCause() instanceof CertificateException;
-    boolean protocolFailure = e instanceof ProtocolException;
-    return !sslFailure && !protocolFailure;
-  }
-
-  public HttpEngine getHttpEngine() {
-    return httpEngine;
-  }
-
-  enum Retry {
-    NONE,
-    SAME_CONNECTION,
-    DIFFERENT_CONNECTION
-  }
-
-  /**
-   * Returns the retry action to take for the current response headers. The
-   * headers, proxy and target URL or this connection may be adjusted to
-   * prepare for a follow up request.
-   */
-  private Retry processResponseHeaders() throws IOException {
-    Proxy selectedProxy = httpEngine.connection != null
-        ? httpEngine.connection.getRoute().getProxy()
-        : client.getProxy();
-    final int responseCode = getResponseCode();
-    switch (responseCode) {
-      case HTTP_PROXY_AUTH:
-        if (selectedProxy.type() != Proxy.Type.HTTP) {
-          throw new ProtocolException("Received HTTP_PROXY_AUTH (407) code while not using proxy");
-        }
-        // fall-through
-      case HTTP_UNAUTHORIZED:
-        boolean credentialsFound = HttpAuthenticator.processAuthHeader(client.getAuthenticator(),
-            getResponseCode(), httpEngine.getResponseHeaders().getHeaders(), rawRequestHeaders,
-            selectedProxy, url);
-        return credentialsFound ? Retry.SAME_CONNECTION : Retry.NONE;
-
-      case HTTP_MULT_CHOICE:
-      case HTTP_MOVED_PERM:
-      case HTTP_MOVED_TEMP:
-      case HTTP_SEE_OTHER:
-      case HTTP_TEMP_REDIRECT:
-        if (!getInstanceFollowRedirects()) {
-          return Retry.NONE;
-        }
-        if (++redirectionCount > MAX_REDIRECTS) {
-          throw new ProtocolException("Too many redirects: " + redirectionCount);
-        }
-        if (responseCode == HTTP_TEMP_REDIRECT && !method.equals("GET") && !method.equals("HEAD")) {
-          // "If the 307 status code is received in response to a request other than GET or HEAD,
-          // the user agent MUST NOT automatically redirect the request"
-          return Retry.NONE;
-        }
-        String location = getHeaderField("Location");
-        if (location == null) {
-          return Retry.NONE;
-        }
-        URL previousUrl = url;
-        url = new URL(previousUrl, location);
-        if (!url.getProtocol().equals("https") && !url.getProtocol().equals("http")) {
-          return Retry.NONE; // Don't follow redirects to unsupported protocols.
-        }
-        boolean sameProtocol = previousUrl.getProtocol().equals(url.getProtocol());
-        if (!sameProtocol && !client.getFollowProtocolRedirects()) {
-          return Retry.NONE; // This client doesn't follow redirects across protocols.
-        }
-        boolean sameHost = previousUrl.getHost().equals(url.getHost());
-        boolean samePort = getEffectivePort(previousUrl) == getEffectivePort(url);
-        if (sameHost && samePort && sameProtocol) {
-          return Retry.SAME_CONNECTION;
+    }
+
+    enum Retry {
+        NONE,
+        SAME_CONNECTION,
+        DIFFERENT_CONNECTION
+    }
+
+    /**
+     * Returns the retry action to take for the current response headers. The
+     * headers, proxy and target URL or this connection may be adjusted to
+     * prepare for a follow up request.
+     */
+    private Retry processResponseHeaders() throws IOException {
+        Proxy selectedProxy = httpEngine.connection != null
+                ? httpEngine.connection.getRoute().getProxy()
+                : client.getProxy();
+        final int responseCode = getResponseCode();
+        switch (responseCode) {
+            case HTTP_PROXY_AUTH:
+                if (selectedProxy.type() != Proxy.Type.HTTP) {
+                    throw new ProtocolException("Received HTTP_PROXY_AUTH (407) code while not using proxy");
+                }
+                // fall-through
+            case HTTP_UNAUTHORIZED:
+                boolean credentialsFound = HttpAuthenticator.processAuthHeader(client.getAuthenticator(),
+                        getResponseCode(), httpEngine.getResponseHeaders().getHeaders(), rawRequestHeaders,
+                        selectedProxy, url);
+                return credentialsFound ? Retry.SAME_CONNECTION : Retry.NONE;
+
+            case HTTP_MULT_CHOICE:
+            case HTTP_MOVED_PERM:
+            case HTTP_MOVED_TEMP:
+            case HTTP_SEE_OTHER:
+            case HTTP_TEMP_REDIRECT:
+                if (!getInstanceFollowRedirects()) {
+                    return Retry.NONE;
+                }
+                if (++redirectionCount > MAX_REDIRECTS) {
+                    throw new ProtocolException("Too many redirects: " + redirectionCount);
+                }
+                if (responseCode == HTTP_TEMP_REDIRECT && !method.equals("GET") && !method.equals("HEAD")) {
+                    // "If the 307 status code is received in response to a request other than GET or HEAD,
+                    // the user agent MUST NOT automatically redirect the request"
+                    return Retry.NONE;
+                }
+                String location = getHeaderField("Location");
+                if (location == null) {
+                    return Retry.NONE;
+                }
+                URL previousUrl = url;
+                url = new URL(previousUrl, location);
+                if (!url.getProtocol().equals("https") && !url.getProtocol().equals("http")) {
+                    return Retry.NONE; // Don't follow redirects to unsupported protocols.
+                }
+                boolean sameProtocol = previousUrl.getProtocol().equals(url.getProtocol());
+                if (!sameProtocol && !client.getFollowProtocolRedirects()) {
+                    return Retry.NONE; // This client doesn't follow redirects across protocols.
+                }
+                boolean sameHost = previousUrl.getHost().equals(url.getHost());
+                boolean samePort = getEffectivePort(previousUrl) == getEffectivePort(url);
+                if (sameHost && samePort && sameProtocol) {
+                    return Retry.SAME_CONNECTION;
+                } else {
+                    return Retry.DIFFERENT_CONNECTION;
+                }
+
+            default:
+                return Retry.NONE;
+        }
+    }
+
+    /** @see java.net.HttpURLConnection#setFixedLengthStreamingMode(int) */
+    @Override
+    public final long getFixedContentLength() {
+        return fixedContentLength;
+    }
+
+    @Override
+    public final int getChunkLength() {
+        return chunkLength;
+    }
+
+    @Override
+    public final boolean usingProxy() {
+        Proxy proxy = client.getProxy();
+        return proxy != null && proxy.type() != Proxy.Type.DIRECT;
+    }
+
+    @Override
+    public String getResponseMessage() throws IOException {
+        return getResponse().getResponseHeaders().getHeaders().getResponseMessage();
+    }
+
+    @Override
+    public final int getResponseCode() throws IOException {
+        return getResponse().getResponseCode();
+    }
+
+    @Override
+    public final void setRequestProperty(String field, String newValue) {
+        if (connected) {
+            throw new IllegalStateException("Cannot set request property after connection is made");
+        }
+        if (field == null) {
+            throw new NullPointerException("field == null");
+        }
+        if (newValue == null) {
+            // Silently ignore null header values for backwards compatibility with older
+            // android versions as well as with other URLConnection implementations.
+            //
+            // Some implementations send a malformed HTTP header when faced with
+            // such requests, we respect the spec and ignore the header.
+            Platform.get().logW("Ignoring header " + field + " because its value was null.");
+            return;
+        }
+
+        if ("X-Android-Transports".equals(field)) {
+            setTransports(newValue, false /* append */);
+        } else {
+            rawRequestHeaders.set(field, newValue);
+        }
+    }
+
+    public void setAllowFailedPostRetry(boolean allow) {
+        allowFailedPostRetry = allow;
+    }
+
+    @Override
+    public final void addRequestProperty(String field, String value) {
+        if (connected) {
+            throw new IllegalStateException("Cannot add request property after connection is made");
+        }
+        if (field == null) {
+            throw new NullPointerException("field == null");
+        }
+        if (value == null) {
+            // Silently ignore null header values for backwards compatibility with older
+            // android versions as well as with other URLConnection implementations.
+            //
+            // Some implementations send a malformed HTTP header when faced with
+            // such requests, we respect the spec and ignore the header.
+            Platform.get().logW("Ignoring header " + field + " because its value was null.");
+            return;
+        }
+
+        if ("X-Android-Transports".equals(field)) {
+            setTransports(value, true /* append */);
         } else {
-          return Retry.DIFFERENT_CONNECTION;
+            rawRequestHeaders.add(field, value);
         }
+    }
 
-      default:
-        return Retry.NONE;
-    }
-  }
-
-  /** @see java.net.HttpURLConnection#setFixedLengthStreamingMode(int) */
-  @Override public final long getFixedContentLength() {
-    return fixedContentLength;
-  }
-
-  @Override public final int getChunkLength() {
-    return chunkLength;
-  }
-
-  @Override public final boolean usingProxy() {
-    Proxy proxy = client.getProxy();
-    return proxy != null && proxy.type() != Proxy.Type.DIRECT;
-  }
-
-  @Override public String getResponseMessage() throws IOException {
-    return getResponse().getResponseHeaders().getHeaders().getResponseMessage();
-  }
-
-  @Override public final int getResponseCode() throws IOException {
-    return getResponse().getResponseCode();
-  }
-
-  @Override public final void setRequestProperty(String field, String newValue) {
-    if (connected) {
-      throw new IllegalStateException("Cannot set request property after connection is made");
-    }
-    if (field == null) {
-      throw new NullPointerException("field == null");
-    }
-    if (newValue == null) {
-      // Silently ignore null header values for backwards compatibility with older
-      // android versions as well as with other URLConnection implementations.
-      //
-      // Some implementations send a malformed HTTP header when faced with
-      // such requests, we respect the spec and ignore the header.
-      Platform.get().logW("Ignoring header " + field + " because its value was null.");
-      return;
-    }
-
-    if ("X-Android-Transports".equals(field)) {
-      setTransports(newValue, false /* append */);
-    } else {
-      rawRequestHeaders.set(field, newValue);
-    }
-  }
-
-  @Override public final void addRequestProperty(String field, String value) {
-    if (connected) {
-      throw new IllegalStateException("Cannot add request property after connection is made");
-    }
-    if (field == null) {
-      throw new NullPointerException("field == null");
-    }
-    if (value == null) {
-      // Silently ignore null header values for backwards compatibility with older
-      // android versions as well as with other URLConnection implementations.
-      //
-      // Some implementations send a malformed HTTP header when faced with
-      // such requests, we respect the spec and ignore the header.
-      Platform.get().logW("Ignoring header " + field + " because its value was null.");
-      return;
-    }
-
-    if ("X-Android-Transports".equals(field)) {
-      setTransports(value, true /* append */);
-    } else {
-      rawRequestHeaders.add(field, value);
-    }
-  }
-
-  /*
-   * Splits and validates a comma-separated string of transports.
-   * When append == false, we require that the transport list contains "http/1.1".
-   */
-  private void setTransports(String transportsString, boolean append) {
-    List<String> transportsList = new ArrayList<String>();
-    if (append) {
-      transportsList.addAll(client.getTransports());
-    }
-    for (String transport : transportsString.split(",", -1)) {
-      transportsList.add(transport);
-    }
-    client.setTransports(transportsList);
-  }
-
-  @Override public void setFixedLengthStreamingMode(int contentLength) {
-    setFixedLengthStreamingMode((long) contentLength);
-  }
-
-  // @Override Don't override: this overload method doesn't exist prior to Java 1.7.
-  public void setFixedLengthStreamingMode(long contentLength) {
-    if (super.connected) throw new IllegalStateException("Already connected");
-    if (chunkLength > 0) throw new IllegalStateException("Already in chunked mode");
-    if (contentLength < 0) throw new IllegalArgumentException("contentLength < 0");
-    this.fixedContentLength = contentLength;
-    super.fixedContentLength = (int) Math.min(contentLength, Integer.MAX_VALUE);
-  }
+    /*
+     * Splits and validates a comma-separated string of transports.
+     * When append == false, we require that the transport list contains "http/1.1".
+     */
+    private void setTransports(String transportsString, boolean append) {
+        List< String > transportsList = new ArrayList< String >();
+        if (append) {
+            transportsList.addAll(client.getTransports());
+        }
+        for (String transport : transportsString.split(",", -1)) {
+            transportsList.add(transport);
+        }
+        client.setTransports(transportsList);
+    }
+
+    @Override
+    public void setFixedLengthStreamingMode(int contentLength) {
+        setFixedLengthStreamingMode((long) contentLength);
+    }
+
+    // @Override Don't override: this overload method doesn't exist prior to Java 1.7.
+    public void setFixedLengthStreamingMode(long contentLength) {
+        if (super.connected)
+            throw new IllegalStateException("Already connected");
+        if (chunkLength > 0)
+            throw new IllegalStateException("Already in chunked mode");
+        if (contentLength < 0)
+            throw new IllegalArgumentException("contentLength < 0");
+        fixedContentLength = contentLength;
+        super.fixedContentLength = (int) Math.min(contentLength, Integer.MAX_VALUE);
+    }
 }
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpsURLConnectionImpl.java b/okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpsURLConnectionImpl.java
index 0a4efea785..87aa90735d 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpsURLConnectionImpl.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpsURLConnectionImpl.java
@@ -341,6 +341,11 @@ private SSLSocket getSslSocket() {
   @Override public SSLSocketFactory getSSLSocketFactory() {
     return delegate.client.getSslSocketFactory();
   }
+  
+  public
+  void setAllowFailedPostRetry(boolean allow) {
+      delegate.setAllowFailedPostRetry(allow);
+  }
 
   private final class HttpUrlConnectionDelegate extends HttpURLConnectionImpl {
     private HttpUrlConnectionDelegate(URL url, OkHttpClient client) {
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/ErrorCode.java b/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/ErrorCode.java
new file mode 100644
index 0000000000..d3a32e1172
--- /dev/null
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/ErrorCode.java
@@ -0,0 +1,67 @@
+package com.squareup.okhttp.internal.spdy;
+
+public enum ErrorCode {
+  /** Not an error! For SPDY stream resets, prefer null over NO_ERROR. */
+  NO_ERROR(0, -1, 0),
+
+  PROTOCOL_ERROR(1, 1, 1),
+
+  /** A subtype of PROTOCOL_ERROR used by SPDY. */
+  INVALID_STREAM(1, 2, -1),
+
+  /** A subtype of PROTOCOL_ERROR used by SPDY. */
+  UNSUPPORTED_VERSION(1, 4, -1),
+
+  /** A subtype of PROTOCOL_ERROR used by SPDY. */
+  STREAM_IN_USE(1, 8, -1),
+
+  /** A subtype of PROTOCOL_ERROR used by SPDY. */
+  STREAM_ALREADY_CLOSED(1, 9, -1),
+
+  INTERNAL_ERROR(2, 6, 2),
+
+  FLOW_CONTROL_ERROR(3, 7, -1),
+
+  STREAM_CLOSED(5, -1, -1),
+
+  FRAME_TOO_LARGE(6, 11, -1),
+
+  REFUSED_STREAM(7, 3, -1),
+
+  CANCEL(8, 5, -1),
+
+  COMPRESSION_ERROR(9, -1, -1),
+
+  INVALID_CREDENTIALS(-1, 10, -1);
+
+  public final int httpCode;
+  public final int spdyRstCode;
+  public final int spdyGoAwayCode;
+
+  private ErrorCode(int httpCode, int spdyRstCode, int spdyGoAwayCode) {
+    this.httpCode = httpCode;
+    this.spdyRstCode = spdyRstCode;
+    this.spdyGoAwayCode = spdyGoAwayCode;
+  }
+
+  public static ErrorCode fromSpdy3Rst(int code) {
+    for (ErrorCode errorCode : ErrorCode.values()) {
+      if (errorCode.spdyRstCode == code) return errorCode;
+    }
+    return null;
+  }
+
+  public static ErrorCode fromHttp2(int code) {
+    for (ErrorCode errorCode : ErrorCode.values()) {
+      if (errorCode.httpCode == code) return errorCode;
+    }
+    return null;
+  }
+
+  public static ErrorCode fromSpdyGoAway(int code) {
+    for (ErrorCode errorCode : ErrorCode.values()) {
+      if (errorCode.spdyGoAwayCode == code) return errorCode;
+    }
+    return null;
+  }
+}
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/FrameReader.java b/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/FrameReader.java
new file mode 100644
index 0000000000..f47561ee22
--- /dev/null
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/FrameReader.java
@@ -0,0 +1,42 @@
+/*
+ * Copyright (C) 2011 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.squareup.okhttp.internal.spdy;
+
+import java.io.Closeable;
+import java.io.IOException;
+import java.io.InputStream;
+import java.util.List;
+
+/** Reads transport frames for SPDY/3 or HTTP/2.0. */
+public interface FrameReader extends Closeable {
+  boolean nextFrame(Handler handler) throws IOException;
+
+  public interface Handler {
+    void data(boolean inFinished, int streamId, InputStream in, int length) throws IOException;
+    void synStream(boolean outFinished, boolean inFinished, int streamId, int associatedStreamId,
+        int priority, int slot, List<String> nameValueBlock);
+    void synReply(boolean inFinished, int streamId, List<String> nameValueBlock) throws IOException;
+    void headers(int streamId, List<String> nameValueBlock) throws IOException;
+    void rstStream(int streamId, ErrorCode errorCode);
+    void settings(boolean clearPrevious, Settings settings);
+    void noop();
+    void ping(boolean reply, int payload1, int payload2);
+    void goAway(int lastGoodStreamId, ErrorCode errorCode);
+    void windowUpdate(int streamId, int deltaWindowSize, boolean endFlowControl);
+    void priority(int streamId, int priority);
+  }
+}
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/FrameWriter.java b/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/FrameWriter.java
new file mode 100644
index 0000000000..0c694e361d
--- /dev/null
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/FrameWriter.java
@@ -0,0 +1,43 @@
+/*
+ * Copyright (C) 2011 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.squareup.okhttp.internal.spdy;
+
+import java.io.Closeable;
+import java.io.IOException;
+import java.util.List;
+
+/** Writes transport frames for SPDY/3 or HTTP/2.0. */
+public interface FrameWriter extends Closeable {
+  /** HTTP/2.0 only. */
+  void connectionHeader();
+
+  /** SPDY/3 only. */
+  void flush() throws IOException;
+  void synStream(boolean outFinished, boolean inFinished, int streamId, int associatedStreamId,
+      int priority, int slot, List<String> nameValueBlock) throws IOException;
+  void synReply(boolean outFinished, int streamId, List<String> nameValueBlock) throws IOException;
+  void headers(int streamId, List<String> nameValueBlock) throws IOException;
+  void rstStream(int streamId, ErrorCode errorCode) throws IOException;
+  void data(boolean outFinished, int streamId, byte[] data) throws IOException;
+  void data(boolean outFinished, int streamId, byte[] data, int offset, int byteCount)
+      throws IOException;
+  void settings(Settings settings) throws IOException;
+  void noop() throws IOException;
+  void ping(boolean reply, int payload1, int payload2) throws IOException;
+  void goAway(int lastGoodStreamId, ErrorCode errorCode) throws IOException;
+  void windowUpdate(int streamId, int deltaWindowSize) throws IOException;
+}
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/Http20Draft04.java b/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/Http20Draft04.java
new file mode 100644
index 0000000000..7dd2295054
--- /dev/null
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/Http20Draft04.java
@@ -0,0 +1,271 @@
+/*
+ * Copyright (C) 2013 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.okhttp.internal.spdy;
+
+import com.squareup.okhttp.internal.Util;
+import java.io.DataInputStream;
+import java.io.DataOutputStream;
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.OutputStream;
+import java.util.List;
+
+final class Http20Draft04 implements Variant {
+  static final int TYPE_DATA = 0x0;
+  static final int TYPE_HEADERS = 0x1;
+  static final int TYPE_PRIORITY = 0x2;
+  static final int TYPE_RST_STREAM = 0x3;
+  static final int TYPE_SETTINGS = 0x4;
+  static final int TYPE_PUSH_PROMISE = 0x5;
+  static final int TYPE_PING = 0x6;
+  static final int TYPE_GOAWAY = 0x7;
+  static final int TYPE_WINDOW_UPDATE = 0x9;
+
+  static final int FLAG_END_STREAM = 0x1;
+  static final int FLAG_END_HEADERS = 0x4;
+  static final int FLAG_PRIORITY = 0x8;
+  static final int FLAG_PONG = 0x1;
+  static final int FLAG_END_FLOW_CONTROL = 0x1;
+
+  @Override public FrameReader newReader(InputStream in, boolean client) {
+    return new Reader(in);
+  }
+
+  @Override public FrameWriter newWriter(OutputStream out, boolean client) {
+    return new Writer(out);
+  }
+
+  static final class Reader implements FrameReader {
+    private final DataInputStream in;
+
+    Reader(InputStream in) {
+      this.in = new DataInputStream(in);
+    }
+
+    @Override public boolean nextFrame(Handler handler) throws IOException {
+      int w1;
+      try {
+        w1 = in.readInt();
+      } catch (IOException e) {
+        return false; // This might be a normal socket close.
+      }
+      int w2 = in.readInt();
+
+      int length = w1 & 0xffff;
+      int type = (w1 & 0xff0000) >> 16;
+      int flags = (w1 & 0xff000000) >> 24;
+      // boolean r = (w2 & 0x80000000) != 0; // Reserved.
+      int streamId = (w2 & 0x7fffffff);
+
+      switch (type) {
+        case TYPE_DATA:
+          readData(handler, flags, length, streamId);
+          return true;
+
+        case TYPE_PRIORITY:
+          readPriority(handler, flags, length, streamId);
+          return true;
+
+        case TYPE_RST_STREAM:
+          readRstStream(handler, flags, length, streamId);
+          return true;
+
+        case TYPE_SETTINGS:
+          readSettings(handler, flags, length, streamId);
+          return true;
+
+        case TYPE_PUSH_PROMISE:
+          readPushPromise(handler, flags, length, streamId);
+          return true;
+
+        case TYPE_PING:
+          readPing(handler, flags, length, streamId);
+          return true;
+
+        case TYPE_GOAWAY:
+          readGoAway(handler, flags, length, streamId);
+          return true;
+
+        case TYPE_WINDOW_UPDATE:
+          readWindowUpdate(handler, flags, length, streamId);
+          return true;
+      }
+
+      throw new UnsupportedOperationException("TODO");
+    }
+
+    private void readData(Handler handler, int flags, int length, int streamId) throws IOException {
+      boolean inFinished = (flags & FLAG_END_STREAM) != 0;
+      handler.data(inFinished, streamId, in, length);
+    }
+
+    private void readPriority(Handler handler, int flags, int length, int streamId)
+        throws IOException {
+      if (length != 4) throw ioException("TYPE_PRIORITY length: %d != 4", length);
+      if (streamId == 0) throw ioException("TYPE_PRIORITY streamId == 0");
+      int w1 = in.readInt();
+      // boolean r = (w1 & 0x80000000) != 0; // Reserved.
+      int priority = (w1 & 0x7fffffff);
+      handler.priority(streamId, priority);
+    }
+
+    private void readRstStream(Handler handler, int flags, int length, int streamId)
+        throws IOException {
+      if (length != 4) throw ioException("TYPE_RST_STREAM length: %d != 4", length);
+      if (streamId == 0) throw ioException("TYPE_RST_STREAM streamId == 0");
+      int errorCodeInt = in.readInt();
+      ErrorCode errorCode = ErrorCode.fromHttp2(errorCodeInt);
+      if (errorCode == null) {
+        throw ioException("TYPE_RST_STREAM unexpected error code: %d", errorCodeInt);
+      }
+      handler.rstStream(streamId, errorCode);
+    }
+
+    private void readSettings(Handler handler, int flags, int length, int streamId)
+        throws IOException {
+      if (length % 8 != 0) throw ioException("TYPE_SETTINGS length %% 8 != 0: %s", length);
+      if (streamId != 0) throw ioException("TYPE_SETTINGS streamId != 0");
+      Settings settings = new Settings();
+      for (int i = 0; i < length; i += 8) {
+        int w1 = in.readInt();
+        int value = in.readInt();
+        // int r = (w1 & 0xff000000) >>> 24; // Reserved.
+        int id = w1 & 0xffffff;
+        settings.set(id, 0, value);
+      }
+      handler.settings(false, settings);
+    }
+
+    private void readPushPromise(Handler handler, int flags, int length, int streamId) {
+      // TODO:
+    }
+
+    private void readPing(Handler handler, int flags, int length, int streamId) throws IOException {
+      if (length != 8) throw ioException("TYPE_PING length != 8: %s", length);
+      if (streamId != 0) throw ioException("TYPE_PING streamId != 0");
+      int payload1 = in.readInt();
+      int payload2 = in.readInt();
+      boolean reply = (flags & FLAG_PONG) != 0;
+      handler.ping(reply, payload1, payload2);
+    }
+
+    private void readGoAway(Handler handler, int flags, int length, int streamId)
+        throws IOException {
+      if (length < 8) throw ioException("TYPE_GOAWAY length < 8: %s", length);
+      int lastStreamId = in.readInt();
+      int errorCodeInt = in.readInt();
+      int opaqueDataLength = length - 8;
+      ErrorCode errorCode = ErrorCode.fromHttp2(errorCodeInt);
+      if (errorCode == null) {
+        throw ioException("TYPE_RST_STREAM unexpected error code: %d", errorCodeInt);
+      }
+      if (Util.skipByReading(in, opaqueDataLength) != opaqueDataLength) {
+        throw new IOException("TYPE_GOAWAY opaque data was truncated");
+      }
+      handler.goAway(lastStreamId, errorCode);
+    }
+
+    private void readWindowUpdate(Handler handler, int flags, int length, int streamId)
+        throws IOException {
+      int w1 = in.readInt();
+      // boolean r = (w1 & 0x80000000) != 0; // Reserved.
+      int windowSizeIncrement = (w1 & 0x7fffffff);
+      boolean endFlowControl = (flags & FLAG_END_FLOW_CONTROL) != 0;
+      handler.windowUpdate(streamId, windowSizeIncrement, endFlowControl);
+    }
+
+    private static IOException ioException(String message, Object... args) throws IOException {
+      throw new IOException(String.format(message, args));
+    }
+
+    @Override public void close() throws IOException {
+      in.close();
+    }
+  }
+
+  static final class Writer implements FrameWriter {
+    private final DataOutputStream out;
+
+    Writer(OutputStream out) {
+      this.out = new DataOutputStream(out);
+    }
+
+    @Override public synchronized void flush() throws IOException {
+      out.flush();
+    }
+
+    @Override public synchronized void connectionHeader() {
+      throw new UnsupportedOperationException("TODO");
+    }
+
+    @Override public synchronized void synStream(boolean outFinished, boolean inFinished,
+        int streamId, int associatedStreamId, int priority, int slot, List<String> nameValueBlock)
+        throws IOException {
+      throw new UnsupportedOperationException("TODO");
+    }
+
+    @Override public synchronized void synReply(boolean outFinished, int streamId,
+        List<String> nameValueBlock) throws IOException {
+      throw new UnsupportedOperationException("TODO");
+    }
+
+    @Override public synchronized void headers(int streamId, List<String> nameValueBlock)
+        throws IOException {
+      throw new UnsupportedOperationException("TODO");
+    }
+
+    @Override public synchronized void rstStream(int streamId, ErrorCode errorCode)
+        throws IOException {
+      throw new UnsupportedOperationException("TODO");
+    }
+
+    @Override public void data(boolean outFinished, int streamId, byte[] data) throws IOException {
+      data(outFinished, streamId, data, 0, data.length);
+    }
+
+    @Override public synchronized void data(boolean outFinished, int streamId, byte[] data,
+        int offset, int byteCount) throws IOException {
+      throw new UnsupportedOperationException("TODO");
+    }
+
+    @Override public synchronized void settings(Settings settings) throws IOException {
+      throw new UnsupportedOperationException("TODO");
+    }
+
+    @Override public synchronized void noop() throws IOException {
+      throw new UnsupportedOperationException("TODO");
+    }
+
+    @Override public synchronized void ping(boolean reply, int payload1, int payload2)
+        throws IOException {
+      throw new UnsupportedOperationException("TODO");
+    }
+
+    @Override public synchronized void goAway(int lastGoodStreamId, ErrorCode errorCode)
+        throws IOException {
+      throw new UnsupportedOperationException("TODO");
+    }
+
+    @Override public synchronized void windowUpdate(int streamId, int deltaWindowSize)
+        throws IOException {
+      throw new UnsupportedOperationException("TODO");
+    }
+
+    @Override public void close() throws IOException {
+      out.close();
+    }
+  }
+}
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/IncomingStreamHandler.java b/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/IncomingStreamHandler.java
new file mode 100644
index 0000000000..44d4ea2bfa
--- /dev/null
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/IncomingStreamHandler.java
@@ -0,0 +1,36 @@
+/*
+ * Copyright (C) 2011 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.squareup.okhttp.internal.spdy;
+
+import java.io.IOException;
+
+/** Listener to be notified when a connected peer creates a new stream. */
+public interface IncomingStreamHandler {
+  IncomingStreamHandler REFUSE_INCOMING_STREAMS = new IncomingStreamHandler() {
+    @Override public void receive(SpdyStream stream) throws IOException {
+      stream.close(ErrorCode.REFUSED_STREAM);
+    }
+  };
+
+  /**
+   * Handle a new stream from this connection's peer. Implementations should
+   * respond by either {@link SpdyStream#reply replying to the stream} or
+   * {@link SpdyStream#close closing it}. This response does not need to be
+   * synchronous.
+   */
+  void receive(SpdyStream stream) throws IOException;
+}
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/Ping.java b/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/Ping.java
new file mode 100644
index 0000000000..c585255780
--- /dev/null
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/Ping.java
@@ -0,0 +1,71 @@
+/*
+ * Copyright (C) 2012 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.okhttp.internal.spdy;
+
+import java.util.concurrent.CountDownLatch;
+import java.util.concurrent.TimeUnit;
+
+/**
+ * A locally-originated ping.
+ */
+public final class Ping {
+  private final CountDownLatch latch = new CountDownLatch(1);
+  private long sent = -1;
+  private long received = -1;
+
+  Ping() {
+  }
+
+  void send() {
+    if (sent != -1) throw new IllegalStateException();
+    sent = System.nanoTime();
+  }
+
+  void receive() {
+    if (received != -1 || sent == -1) throw new IllegalStateException();
+    received = System.nanoTime();
+    latch.countDown();
+  }
+
+  void cancel() {
+    if (received != -1 || sent == -1) throw new IllegalStateException();
+    received = sent - 1;
+    latch.countDown();
+  }
+
+  /**
+   * Returns the round trip time for this ping in nanoseconds, waiting for the
+   * response to arrive if necessary. Returns -1 if the response was
+   * cancelled.
+   */
+  public long roundTripTime() throws InterruptedException {
+    latch.await();
+    return received - sent;
+  }
+
+  /**
+   * Returns the round trip time for this ping in nanoseconds, or -1 if the
+   * response was cancelled, or -2 if the timeout elapsed before the round
+   * trip completed.
+   */
+  public long roundTripTime(long timeout, TimeUnit unit) throws InterruptedException {
+    if (latch.await(timeout, unit)) {
+      return received - sent;
+    } else {
+      return -2;
+    }
+  }
+}
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/Settings.java b/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/Settings.java
new file mode 100644
index 0000000000..05380e27e1
--- /dev/null
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/Settings.java
@@ -0,0 +1,187 @@
+/*
+ * Copyright (C) 2012 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.okhttp.internal.spdy;
+
+final class Settings {
+  /**
+   * From the spdy/3 spec, the default initial window size for all streams is
+   * 64 KiB. (Chrome 25 uses 10 MiB).
+   */
+  static final int DEFAULT_INITIAL_WINDOW_SIZE = 64 * 1024;
+
+  /** Peer request to clear durable settings. */
+  static final int FLAG_CLEAR_PREVIOUSLY_PERSISTED_SETTINGS = 0x1;
+
+  /** Sent by servers only. The peer requests this setting persisted for future connections. */
+  static final int PERSIST_VALUE = 0x1;
+  /** Sent by clients only. The client is reminding the server of a persisted value. */
+  static final int PERSISTED = 0x2;
+
+  /** Sender's estimate of max incoming kbps. */
+  static final int UPLOAD_BANDWIDTH = 1;
+  /** Sender's estimate of max outgoing kbps. */
+  static final int DOWNLOAD_BANDWIDTH = 2;
+  /** Sender's estimate of milliseconds between sending a request and receiving a response. */
+  static final int ROUND_TRIP_TIME = 3;
+  /** Sender's maximum number of concurrent streams. */
+  static final int MAX_CONCURRENT_STREAMS = 4;
+  /** Current CWND in Packets. */
+  static final int CURRENT_CWND = 5;
+  /** Retransmission rate. Percentage */
+  static final int DOWNLOAD_RETRANS_RATE = 6;
+  /** Window size in bytes. */
+  static final int INITIAL_WINDOW_SIZE = 7;
+  /** Window size in bytes. */
+  static final int CLIENT_CERTIFICATE_VECTOR_SIZE = 8;
+  /** Flow control options. */
+  static final int FLOW_CONTROL_OPTIONS = 9;
+
+  /** Total number of settings. */
+  static final int COUNT = 10;
+
+  /** If set, flow control is disabled for streams directed to the sender of these settings. */
+  static final int FLOW_CONTROL_OPTIONS_DISABLED = 0x1;
+
+  /** Bitfield of which flags that values. */
+  private int set;
+
+  /** Bitfield of flags that have {@link #PERSIST_VALUE}. */
+  private int persistValue;
+
+  /** Bitfield of flags that have {@link #PERSISTED}. */
+  private int persisted;
+
+  /** Flag values. */
+  private final int[] values = new int[COUNT];
+
+  void set(int id, int idFlags, int value) {
+    if (id >= values.length) {
+      return; // Discard unknown settings.
+    }
+
+    int bit = 1 << id;
+    set |= bit;
+    if ((idFlags & PERSIST_VALUE) != 0) {
+      persistValue |= bit;
+    } else {
+      persistValue &= ~bit;
+    }
+    if ((idFlags & PERSISTED) != 0) {
+      persisted |= bit;
+    } else {
+      persisted &= ~bit;
+    }
+
+    values[id] = value;
+  }
+
+  /** Returns true if a value has been assigned for the setting {@code id}. */
+  boolean isSet(int id) {
+    int bit = 1 << id;
+    return (set & bit) != 0;
+  }
+
+  /** Returns the value for the setting {@code id}, or 0 if unset. */
+  int get(int id) {
+    return values[id];
+  }
+
+  /** Returns the flags for the setting {@code id}, or 0 if unset. */
+  int flags(int id) {
+    int result = 0;
+    if (isPersisted(id)) result |= Settings.PERSISTED;
+    if (persistValue(id)) result |= Settings.PERSIST_VALUE;
+    return result;
+  }
+
+  /** Returns the number of settings that have values assigned. */
+  int size() {
+    return Integer.bitCount(set);
+  }
+
+  int getUploadBandwidth(int defaultValue) {
+    int bit = 1 << UPLOAD_BANDWIDTH;
+    return (bit & set) != 0 ? values[UPLOAD_BANDWIDTH] : defaultValue;
+  }
+
+  int getDownloadBandwidth(int defaultValue) {
+    int bit = 1 << DOWNLOAD_BANDWIDTH;
+    return (bit & set) != 0 ? values[DOWNLOAD_BANDWIDTH] : defaultValue;
+  }
+
+  int getRoundTripTime(int defaultValue) {
+    int bit = 1 << ROUND_TRIP_TIME;
+    return (bit & set) != 0 ? values[ROUND_TRIP_TIME] : defaultValue;
+  }
+
+  int getMaxConcurrentStreams(int defaultValue) {
+    int bit = 1 << MAX_CONCURRENT_STREAMS;
+    return (bit & set) != 0 ? values[MAX_CONCURRENT_STREAMS] : defaultValue;
+  }
+
+  int getCurrentCwnd(int defaultValue) {
+    int bit = 1 << CURRENT_CWND;
+    return (bit & set) != 0 ? values[CURRENT_CWND] : defaultValue;
+  }
+
+  int getDownloadRetransRate(int defaultValue) {
+    int bit = 1 << DOWNLOAD_RETRANS_RATE;
+    return (bit & set) != 0 ? values[DOWNLOAD_RETRANS_RATE] : defaultValue;
+  }
+
+  int getInitialWindowSize(int defaultValue) {
+    int bit = 1 << INITIAL_WINDOW_SIZE;
+    return (bit & set) != 0 ? values[INITIAL_WINDOW_SIZE] : defaultValue;
+  }
+
+  int getClientCertificateVectorSize(int defaultValue) {
+    int bit = 1 << CLIENT_CERTIFICATE_VECTOR_SIZE;
+    return (bit & set) != 0 ? values[CLIENT_CERTIFICATE_VECTOR_SIZE] : defaultValue;
+  }
+
+  // TODO: honor this setting.
+  boolean isFlowControlDisabled() {
+    int bit = 1 << FLOW_CONTROL_OPTIONS;
+    int value = (bit & set) != 0 ? values[FLOW_CONTROL_OPTIONS] : 0;
+    return (value & FLOW_CONTROL_OPTIONS_DISABLED) != 0;
+  }
+
+  /**
+   * Returns true if this user agent should use this setting in future SPDY
+   * connections to the same host.
+   */
+  boolean persistValue(int id) {
+    int bit = 1 << id;
+    return (persistValue & bit) != 0;
+  }
+
+  /** Returns true if this setting was persisted. */
+  boolean isPersisted(int id) {
+    int bit = 1 << id;
+    return (persisted & bit) != 0;
+  }
+
+  /**
+   * Writes {@code other} into this. If any setting is populated by this and
+   * {@code other}, the value and flags from {@code other} will be kept.
+   */
+  void merge(Settings other) {
+    for (int i = 0; i < COUNT; i++) {
+      if (!other.isSet(i)) continue;
+      set(i, other.flags(i), other.get(i));
+    }
+  }
+}
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/Spdy3.java b/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/Spdy3.java
new file mode 100644
index 0000000000..25fbbfa045
--- /dev/null
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/Spdy3.java
@@ -0,0 +1,535 @@
+/*
+ * Copyright (C) 2011 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.okhttp.internal.spdy;
+
+import com.squareup.okhttp.internal.Platform;
+import com.squareup.okhttp.internal.Util;
+import java.io.ByteArrayOutputStream;
+import java.io.DataInputStream;
+import java.io.DataOutputStream;
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.OutputStream;
+import java.io.UnsupportedEncodingException;
+import java.net.ProtocolException;
+import java.util.ArrayList;
+import java.util.List;
+import java.util.logging.Logger;
+import java.util.zip.DataFormatException;
+import java.util.zip.Deflater;
+import java.util.zip.Inflater;
+import java.util.zip.InflaterInputStream;
+
+final class Spdy3 implements Variant {
+  static final int TYPE_DATA = 0x0;
+  static final int TYPE_SYN_STREAM = 0x1;
+  static final int TYPE_SYN_REPLY = 0x2;
+  static final int TYPE_RST_STREAM = 0x3;
+  static final int TYPE_SETTINGS = 0x4;
+  static final int TYPE_NOOP = 0x5;
+  static final int TYPE_PING = 0x6;
+  static final int TYPE_GOAWAY = 0x7;
+  static final int TYPE_HEADERS = 0x8;
+  static final int TYPE_WINDOW_UPDATE = 0x9;
+  static final int TYPE_CREDENTIAL = 0x10;
+
+  static final int FLAG_FIN = 0x1;
+  static final int FLAG_UNIDIRECTIONAL = 0x2;
+
+  static final int VERSION = 3;
+
+  static final byte[] DICTIONARY;
+  static {
+    try {
+      DICTIONARY = ("\u0000\u0000\u0000\u0007options\u0000\u0000\u0000\u0004hea"
+          + "d\u0000\u0000\u0000\u0004post\u0000\u0000\u0000\u0003put\u0000\u0000\u0000\u0006dele"
+          + "te\u0000\u0000\u0000\u0005trace\u0000\u0000\u0000\u0006accept\u0000\u0000\u0000"
+          + "\u000Eaccept-charset\u0000\u0000\u0000\u000Faccept-encoding\u0000\u0000\u0000\u000Fa"
+          + "ccept-language\u0000\u0000\u0000\raccept-ranges\u0000\u0000\u0000\u0003age\u0000"
+          + "\u0000\u0000\u0005allow\u0000\u0000\u0000\rauthorization\u0000\u0000\u0000\rcache-co"
+          + "ntrol\u0000\u0000\u0000\nconnection\u0000\u0000\u0000\fcontent-base\u0000\u0000"
+          + "\u0000\u0010content-encoding\u0000\u0000\u0000\u0010content-language\u0000\u0000"
+          + "\u0000\u000Econtent-length\u0000\u0000\u0000\u0010content-location\u0000\u0000\u0000"
+          + "\u000Bcontent-md5\u0000\u0000\u0000\rcontent-range\u0000\u0000\u0000\fcontent-type"
+          + "\u0000\u0000\u0000\u0004date\u0000\u0000\u0000\u0004etag\u0000\u0000\u0000\u0006expe"
+          + "ct\u0000\u0000\u0000\u0007expires\u0000\u0000\u0000\u0004from\u0000\u0000\u0000"
+          + "\u0004host\u0000\u0000\u0000\bif-match\u0000\u0000\u0000\u0011if-modified-since"
+          + "\u0000\u0000\u0000\rif-none-match\u0000\u0000\u0000\bif-range\u0000\u0000\u0000"
+          + "\u0013if-unmodified-since\u0000\u0000\u0000\rlast-modified\u0000\u0000\u0000\blocati"
+          + "on\u0000\u0000\u0000\fmax-forwards\u0000\u0000\u0000\u0006pragma\u0000\u0000\u0000"
+          + "\u0012proxy-authenticate\u0000\u0000\u0000\u0013proxy-authorization\u0000\u0000"
+          + "\u0000\u0005range\u0000\u0000\u0000\u0007referer\u0000\u0000\u0000\u000Bretry-after"
+          + "\u0000\u0000\u0000\u0006server\u0000\u0000\u0000\u0002te\u0000\u0000\u0000\u0007trai"
+          + "ler\u0000\u0000\u0000\u0011transfer-encoding\u0000\u0000\u0000\u0007upgrade\u0000"
+          + "\u0000\u0000\nuser-agent\u0000\u0000\u0000\u0004vary\u0000\u0000\u0000\u0003via"
+          + "\u0000\u0000\u0000\u0007warning\u0000\u0000\u0000\u0010www-authenticate\u0000\u0000"
+          + "\u0000\u0006method\u0000\u0000\u0000\u0003get\u0000\u0000\u0000\u0006status\u0000"
+          + "\u0000\u0000\u0006200 OK\u0000\u0000\u0000\u0007version\u0000\u0000\u0000\bHTTP/1.1"
+          + "\u0000\u0000\u0000\u0003url\u0000\u0000\u0000\u0006public\u0000\u0000\u0000\nset-coo"
+          + "kie\u0000\u0000\u0000\nkeep-alive\u0000\u0000\u0000\u0006origin100101201202205206300"
+          + "302303304305306307402405406407408409410411412413414415416417502504505203 Non-Authori"
+          + "tative Information204 No Content301 Moved Permanently400 Bad Request401 Unauthorized"
+          + "403 Forbidden404 Not Found500 Internal Server Error501 Not Implemented503 Service Un"
+          + "availableJan Feb Mar Apr May Jun Jul Aug Sept Oct Nov Dec 00:00:00 Mon, Tue, Wed, Th"
+          + "u, Fri, Sat, Sun, GMTchunked,text/html,image/png,image/jpg,image/gif,application/xml"
+          + ",application/xhtml+xml,text/plain,text/javascript,publicprivatemax-age=gzip,deflate,"
+          + "sdchcharset=utf-8charset=iso-8859-1,utf-,*,enq=0.").getBytes(Util.UTF_8.name());
+    } catch (UnsupportedEncodingException e) {
+      throw new AssertionError();
+    }
+  }
+
+  @Override public FrameReader newReader(InputStream in, boolean client) {
+    return new Reader(in, client);
+  }
+
+  @Override public FrameWriter newWriter(OutputStream out, boolean client) {
+    return new Writer(out, client);
+  }
+
+  /** Read spdy/3 frames. */
+  static final class Reader implements FrameReader {
+    private final DataInputStream in;
+    private final DataInputStream nameValueBlockIn;
+    private final boolean client;
+    private int compressedLimit;
+
+    Reader(InputStream in, boolean client) {
+      this.in = new DataInputStream(in);
+      this.nameValueBlockIn = newNameValueBlockStream();
+      this.client = client;
+    }
+
+    /**
+     * Send the next frame to {@code handler}. Returns true unless there are no
+     * more frames on the stream.
+     */
+    @Override public boolean nextFrame(Handler handler) throws IOException {
+      int w1;
+      try {
+        w1 = in.readInt();
+      } catch (IOException e) {
+        return false; // This might be a normal socket close.
+      }
+      int w2 = in.readInt();
+
+      boolean control = (w1 & 0x80000000) != 0;
+      int flags = (w2 & 0xff000000) >>> 24;
+      int length = (w2 & 0xffffff);
+
+      if (control) {
+        int version = (w1 & 0x7fff0000) >>> 16;
+        int type = (w1 & 0xffff);
+
+        if (version != 3) {
+          throw new ProtocolException("version != 3: " + version);
+        }
+
+        switch (type) {
+          case TYPE_SYN_STREAM:
+            readSynStream(handler, flags, length);
+            return true;
+
+          case TYPE_SYN_REPLY:
+            readSynReply(handler, flags, length);
+            return true;
+
+          case TYPE_RST_STREAM:
+            readRstStream(handler, flags, length);
+            return true;
+
+          case TYPE_SETTINGS:
+            readSettings(handler, flags, length);
+            return true;
+
+          case TYPE_NOOP:
+            if (length != 0) throw ioException("TYPE_NOOP length: %d != 0", length);
+            handler.noop();
+            return true;
+
+          case TYPE_PING:
+            readPing(handler, flags, length);
+            return true;
+
+          case TYPE_GOAWAY:
+            readGoAway(handler, flags, length);
+            return true;
+
+          case TYPE_HEADERS:
+            readHeaders(handler, flags, length);
+            return true;
+
+          case TYPE_WINDOW_UPDATE:
+            readWindowUpdate(handler, flags, length);
+            return true;
+
+          case TYPE_CREDENTIAL:
+            Util.skipByReading(in, length);
+            throw new UnsupportedOperationException("TODO"); // TODO: implement
+
+          default:
+            throw new IOException("Unexpected frame");
+        }
+      } else {
+        int streamId = w1 & 0x7fffffff;
+        boolean inFinished = (flags & FLAG_FIN) != 0;
+        handler.data(inFinished, streamId, in, length);
+        return true;
+      }
+    }
+
+    private void readSynStream(Handler handler, int flags, int length) throws IOException {
+      int w1 = in.readInt();
+      int w2 = in.readInt();
+      int s3 = in.readShort();
+      int streamId = w1 & 0x7fffffff;
+      int associatedStreamId = w2 & 0x7fffffff;
+      int priority = (s3 & 0xe000) >>> 13;
+      int slot = s3 & 0xff;
+      List<String> nameValueBlock = readNameValueBlock(length - 10);
+
+      boolean inFinished = (flags & FLAG_FIN) != 0;
+      boolean outFinished = (flags & FLAG_UNIDIRECTIONAL) != 0;
+      handler.synStream(outFinished, inFinished, streamId, associatedStreamId, priority, slot,
+          nameValueBlock);
+    }
+
+    private void readSynReply(Handler handler, int flags, int length) throws IOException {
+      int w1 = in.readInt();
+      int streamId = w1 & 0x7fffffff;
+      List<String> nameValueBlock = readNameValueBlock(length - 4);
+      boolean inFinished = (flags & FLAG_FIN) != 0;
+      handler.synReply(inFinished, streamId, nameValueBlock);
+    }
+
+    private void readRstStream(Handler handler, int flags, int length) throws IOException {
+      if (length != 8) throw ioException("TYPE_RST_STREAM length: %d != 8", length);
+      int streamId = in.readInt() & 0x7fffffff;
+      int errorCodeInt = in.readInt();
+      ErrorCode errorCode = ErrorCode.fromSpdy3Rst(errorCodeInt);
+      if (errorCode == null) {
+        throw ioException("TYPE_RST_STREAM unexpected error code: %d", errorCodeInt);
+      }
+      handler.rstStream(streamId, errorCode);
+    }
+
+    private void readHeaders(Handler handler, int flags, int length) throws IOException {
+      int w1 = in.readInt();
+      int streamId = w1 & 0x7fffffff;
+      List<String> nameValueBlock = readNameValueBlock(length - 4);
+      handler.headers(streamId, nameValueBlock);
+    }
+
+    private void readWindowUpdate(Handler handler, int flags, int length) throws IOException {
+      if (length != 8) throw ioException("TYPE_WINDOW_UPDATE length: %d != 8", length);
+      int w1 = in.readInt();
+      int w2 = in.readInt();
+      int streamId = w1 & 0x7fffffff;
+      int deltaWindowSize = w2 & 0x7fffffff;
+      handler.windowUpdate(streamId, deltaWindowSize, false);
+    }
+
+    private DataInputStream newNameValueBlockStream() {
+      // Limit the inflater input stream to only those bytes in the Name/Value block.
+      final InputStream throttleStream = new InputStream() {
+        @Override public int read() throws IOException {
+          return Util.readSingleByte(this);
+        }
+
+        @Override public int read(byte[] buffer, int offset, int byteCount) throws IOException {
+          byteCount = Math.min(byteCount, compressedLimit);
+          int consumed = in.read(buffer, offset, byteCount);
+          compressedLimit -= consumed;
+          return consumed;
+        }
+
+        @Override public void close() throws IOException {
+          in.close();
+        }
+      };
+
+      // Subclass inflater to install a dictionary when it's needed.
+      Inflater inflater = new Inflater() {
+        @Override public int inflate(byte[] buffer, int offset, int count)
+            throws DataFormatException {
+          int result = super.inflate(buffer, offset, count);
+          if (result == 0 && needsDictionary()) {
+            setDictionary(DICTIONARY);
+            result = super.inflate(buffer, offset, count);
+          }
+          return result;
+        }
+      };
+
+      return new DataInputStream(new InflaterInputStream(throttleStream, inflater));
+    }
+
+    private List<String> readNameValueBlock(int length) throws IOException {
+      this.compressedLimit += length;
+      try {
+        int numberOfPairs = nameValueBlockIn.readInt();
+        if ((numberOfPairs * 2) < 0) {
+          Logger.getLogger(getClass().getName()).warning("numberOfPairs < 0: " + numberOfPairs);
+          throw ioException("numberOfPairs < 0");
+        }
+        List<String> entries = new ArrayList<String>(numberOfPairs * 2);
+        for (int i = 0; i < numberOfPairs; i++) {
+          String name = readString();
+          String values = readString();
+          if (name.length() == 0) throw ioException("name.length == 0");
+          entries.add(name);
+          entries.add(values);
+        }
+
+        if (compressedLimit != 0) {
+          Logger.getLogger(getClass().getName()).warning("compressedLimit > 0: " + compressedLimit);
+        }
+
+        return entries;
+      } catch (DataFormatException e) {
+        throw new IOException(e.getMessage());
+      }
+    }
+
+    private String readString() throws DataFormatException, IOException {
+      int length = nameValueBlockIn.readInt();
+      byte[] bytes = new byte[length];
+      Util.readFully(nameValueBlockIn, bytes);
+      return new String(bytes, 0, length, "UTF-8");
+    }
+
+    private void readPing(Handler handler, int flags, int length) throws IOException {
+      if (length != 4) throw ioException("TYPE_PING length: %d != 4", length);
+      int id = in.readInt();
+      boolean reply = client == ((id % 2) == 1);
+      handler.ping(reply, id, 0);
+    }
+
+    private void readGoAway(Handler handler, int flags, int length) throws IOException {
+      if (length != 8) throw ioException("TYPE_GOAWAY length: %d != 8", length);
+      int lastGoodStreamId = in.readInt() & 0x7fffffff;
+      int errorCodeInt = in.readInt();
+      ErrorCode errorCode = ErrorCode.fromSpdyGoAway(errorCodeInt);
+      if (errorCode == null) {
+        throw ioException("TYPE_GOAWAY unexpected error code: %d", errorCodeInt);
+      }
+      handler.goAway(lastGoodStreamId, errorCode);
+    }
+
+    private void readSettings(Handler handler, int flags, int length) throws IOException {
+      int numberOfEntries = in.readInt();
+      if (length != 4 + 8 * numberOfEntries) {
+        throw ioException("TYPE_SETTINGS length: %d != 4 + 8 * %d", length, numberOfEntries);
+      }
+      Settings settings = new Settings();
+      for (int i = 0; i < numberOfEntries; i++) {
+        int w1 = in.readInt();
+        int value = in.readInt();
+        int idFlags = (w1 & 0xff000000) >>> 24;
+        int id = w1 & 0xffffff;
+        settings.set(id, idFlags, value);
+      }
+      boolean clearPrevious = (flags & Settings.FLAG_CLEAR_PREVIOUSLY_PERSISTED_SETTINGS) != 0;
+      handler.settings(clearPrevious, settings);
+    }
+
+    private static IOException ioException(String message, Object... args) throws IOException {
+      throw new IOException(String.format(message, args));
+    }
+
+    @Override public void close() throws IOException {
+      Util.closeAll(in, nameValueBlockIn);
+    }
+  }
+
+  /** Write spdy/3 frames. */
+  static final class Writer implements FrameWriter {
+    private final DataOutputStream out;
+    private final ByteArrayOutputStream nameValueBlockBuffer;
+    private final DataOutputStream nameValueBlockOut;
+    private final boolean client;
+
+    Writer(OutputStream out, boolean client) {
+      this.out = new DataOutputStream(out);
+      this.client = client;
+
+      Deflater deflater = new Deflater();
+      deflater.setDictionary(DICTIONARY);
+      nameValueBlockBuffer = new ByteArrayOutputStream();
+      nameValueBlockOut = new DataOutputStream(
+          Platform.get().newDeflaterOutputStream(nameValueBlockBuffer, deflater, true));
+    }
+
+    @Override public synchronized void connectionHeader() {
+      // Do nothing: no connection header for SPDY/3.
+    }
+
+    @Override public synchronized void flush() throws IOException {
+      out.flush();
+    }
+
+    @Override public synchronized void synStream(boolean outFinished, boolean inFinished,
+        int streamId, int associatedStreamId, int priority, int slot, List<String> nameValueBlock)
+        throws IOException {
+      writeNameValueBlockToBuffer(nameValueBlock);
+      int length = 10 + nameValueBlockBuffer.size();
+      int type = TYPE_SYN_STREAM;
+      int flags = (outFinished ? FLAG_FIN : 0) | (inFinished ? FLAG_UNIDIRECTIONAL : 0);
+
+      int unused = 0;
+      out.writeInt(0x80000000 | (VERSION & 0x7fff) << 16 | type & 0xffff);
+      out.writeInt((flags & 0xff) << 24 | length & 0xffffff);
+      out.writeInt(streamId & 0x7fffffff);
+      out.writeInt(associatedStreamId & 0x7fffffff);
+      out.writeShort((priority & 0x7) << 13 | (unused & 0x1f) << 8 | (slot & 0xff));
+      nameValueBlockBuffer.writeTo(out);
+      out.flush();
+    }
+
+    @Override public synchronized void synReply(
+        boolean outFinished, int streamId, List<String> nameValueBlock) throws IOException {
+      writeNameValueBlockToBuffer(nameValueBlock);
+      int type = TYPE_SYN_REPLY;
+      int flags = (outFinished ? FLAG_FIN : 0);
+      int length = nameValueBlockBuffer.size() + 4;
+
+      out.writeInt(0x80000000 | (VERSION & 0x7fff) << 16 | type & 0xffff);
+      out.writeInt((flags & 0xff) << 24 | length & 0xffffff);
+      out.writeInt(streamId & 0x7fffffff);
+      nameValueBlockBuffer.writeTo(out);
+      out.flush();
+    }
+
+    @Override public synchronized void headers(int streamId, List<String> nameValueBlock)
+        throws IOException {
+      writeNameValueBlockToBuffer(nameValueBlock);
+      int flags = 0;
+      int type = TYPE_HEADERS;
+      int length = nameValueBlockBuffer.size() + 4;
+
+      out.writeInt(0x80000000 | (VERSION & 0x7fff) << 16 | type & 0xffff);
+      out.writeInt((flags & 0xff) << 24 | length & 0xffffff);
+      out.writeInt(streamId & 0x7fffffff);
+      nameValueBlockBuffer.writeTo(out);
+      out.flush();
+    }
+
+    @Override public synchronized void rstStream(int streamId, ErrorCode errorCode)
+        throws IOException {
+      if (errorCode.spdyRstCode == -1) throw new IllegalArgumentException();
+      int flags = 0;
+      int type = TYPE_RST_STREAM;
+      int length = 8;
+      out.writeInt(0x80000000 | (VERSION & 0x7fff) << 16 | type & 0xffff);
+      out.writeInt((flags & 0xff) << 24 | length & 0xffffff);
+      out.writeInt(streamId & 0x7fffffff);
+      out.writeInt(errorCode.spdyRstCode);
+      out.flush();
+    }
+
+    @Override public synchronized void data(boolean outFinished, int streamId, byte[] data)
+        throws IOException {
+      data(outFinished, streamId, data, 0, data.length);
+    }
+
+    @Override public synchronized void data(boolean outFinished, int streamId, byte[] data,
+        int offset, int byteCount) throws IOException {
+      int flags = (outFinished ? FLAG_FIN : 0);
+      out.writeInt(streamId & 0x7fffffff);
+      out.writeInt((flags & 0xff) << 24 | byteCount & 0xffffff);
+      out.write(data, offset, byteCount);
+    }
+
+    private void writeNameValueBlockToBuffer(List<String> nameValueBlock) throws IOException {
+      nameValueBlockBuffer.reset();
+      int numberOfPairs = nameValueBlock.size() / 2;
+      nameValueBlockOut.writeInt(numberOfPairs);
+      for (String s : nameValueBlock) {
+        nameValueBlockOut.writeInt(s.length());
+        nameValueBlockOut.write(s.getBytes("UTF-8"));
+      }
+      nameValueBlockOut.flush();
+    }
+
+    @Override public synchronized void settings(Settings settings) throws IOException {
+      int type = TYPE_SETTINGS;
+      int flags = 0;
+      int size = settings.size();
+      int length = 4 + size * 8;
+      out.writeInt(0x80000000 | (VERSION & 0x7fff) << 16 | type & 0xffff);
+      out.writeInt((flags & 0xff) << 24 | length & 0xffffff);
+      out.writeInt(size);
+      for (int i = 0; i <= Settings.COUNT; i++) {
+        if (!settings.isSet(i)) continue;
+        int settingsFlags = settings.flags(i);
+        out.writeInt((settingsFlags & 0xff) << 24 | (i & 0xffffff));
+        out.writeInt(settings.get(i));
+      }
+      out.flush();
+    }
+
+    @Override public synchronized void noop() throws IOException {
+      int type = TYPE_NOOP;
+      int length = 0;
+      int flags = 0;
+      out.writeInt(0x80000000 | (VERSION & 0x7fff) << 16 | type & 0xffff);
+      out.writeInt((flags & 0xff) << 24 | length & 0xffffff);
+      out.flush();
+    }
+
+    @Override public synchronized void ping(boolean reply, int payload1, int payload2)
+        throws IOException {
+      boolean payloadIsReply = client != ((payload1 % 2) == 1);
+      if (reply != payloadIsReply) throw new IllegalArgumentException("payload != reply");
+      int type = TYPE_PING;
+      int flags = 0;
+      int length = 4;
+      out.writeInt(0x80000000 | (VERSION & 0x7fff) << 16 | type & 0xffff);
+      out.writeInt((flags & 0xff) << 24 | length & 0xffffff);
+      out.writeInt(payload1);
+      out.flush();
+    }
+
+    @Override public synchronized void goAway(int lastGoodStreamId, ErrorCode errorCode)
+        throws IOException {
+      if (errorCode.spdyGoAwayCode == -1) throw new IllegalArgumentException();
+      int type = TYPE_GOAWAY;
+      int flags = 0;
+      int length = 8;
+      out.writeInt(0x80000000 | (VERSION & 0x7fff) << 16 | type & 0xffff);
+      out.writeInt((flags & 0xff) << 24 | length & 0xffffff);
+      out.writeInt(lastGoodStreamId);
+      out.writeInt(errorCode.spdyGoAwayCode);
+      out.flush();
+    }
+
+    @Override public synchronized void windowUpdate(int streamId, int deltaWindowSize)
+        throws IOException {
+      int type = TYPE_WINDOW_UPDATE;
+      int flags = 0;
+      int length = 8;
+      out.writeInt(0x80000000 | (VERSION & 0x7fff) << 16 | type & 0xffff);
+      out.writeInt((flags & 0xff) << 24 | length & 0xffffff);
+      out.writeInt(streamId);
+      out.writeInt(deltaWindowSize);
+      out.flush();
+    }
+
+    @Override public void close() throws IOException {
+      Util.closeAll(out, nameValueBlockOut);
+    }
+  }
+}
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/SpdyConnection.java b/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/SpdyConnection.java
new file mode 100644
index 0000000000..16e662c286
--- /dev/null
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/SpdyConnection.java
@@ -0,0 +1,585 @@
+/*
+ * Copyright (C) 2011 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.squareup.okhttp.internal.spdy;
+
+import com.squareup.okhttp.internal.NamedRunnable;
+import com.squareup.okhttp.internal.Util;
+import java.io.Closeable;
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.OutputStream;
+import java.net.Socket;
+import java.util.HashMap;
+import java.util.Iterator;
+import java.util.List;
+import java.util.Map;
+import java.util.concurrent.ExecutorService;
+import java.util.concurrent.SynchronousQueue;
+import java.util.concurrent.ThreadPoolExecutor;
+import java.util.concurrent.TimeUnit;
+
+/**
+ * A socket connection to a remote peer. A connection hosts streams which can
+ * send and receive data.
+ *
+ * <p>Many methods in this API are <strong>synchronous:</strong> the call is
+ * completed before the method returns. This is typical for Java but atypical
+ * for SPDY. This is motivated by exception transparency: an IOException that
+ * was triggered by a certain caller can be caught and handled by that caller.
+ */
+public final class SpdyConnection implements Closeable {
+
+  // Internal state of this connection is guarded by 'this'. No blocking
+  // operations may be performed while holding this lock!
+  //
+  // Socket writes are guarded by frameWriter.
+  //
+  // Socket reads are unguarded but are only made by the reader thread.
+  //
+  // Certain operations (like SYN_STREAM) need to synchronize on both the
+  // frameWriter (to do blocking I/O) and this (to create streams). Such
+  // operations must synchronize on 'this' last. This ensures that we never
+  // wait for a blocking operation while holding 'this'.
+
+  private static final ExecutorService executor = new ThreadPoolExecutor(0,
+      Integer.MAX_VALUE, 60, TimeUnit.SECONDS, new SynchronousQueue<Runnable>(),
+      Util.daemonThreadFactory("OkHttp SpdyConnection"));
+
+  /** The protocol variant, like SPDY/3 or HTTP-draft-04/2.0. */
+  final Variant variant;
+
+  /** True if this peer initiated the connection. */
+  final boolean client;
+
+  /**
+   * User code to run in response to an incoming stream. Callbacks must not be
+   * run on the callback executor.
+   */
+  private final IncomingStreamHandler handler;
+  private final FrameReader frameReader;
+  private final FrameWriter frameWriter;
+
+  private final Map<Integer, SpdyStream> streams = new HashMap<Integer, SpdyStream>();
+  private final String hostName;
+  private int lastGoodStreamId;
+  private int nextStreamId;
+  private boolean shutdown;
+  private long idleStartTimeNs = System.nanoTime();
+
+  /** Lazily-created map of in-flight pings awaiting a response. Guarded by this. */
+  private Map<Integer, Ping> pings;
+  private int nextPingId;
+
+  /** Lazily-created settings for this connection. */
+  Settings settings;
+
+  private SpdyConnection(Builder builder) {
+    variant = builder.variant;
+    client = builder.client;
+    handler = builder.handler;
+    frameReader = variant.newReader(builder.in, client);
+    frameWriter = variant.newWriter(builder.out, client);
+    nextStreamId = builder.client ? 1 : 2;
+    nextPingId = builder.client ? 1 : 2;
+
+    hostName = builder.hostName;
+
+    new Thread(new Reader(), "Spdy Reader " + hostName).start();
+  }
+
+  /**
+   * Returns the number of {@link SpdyStream#isOpen() open streams} on this
+   * connection.
+   */
+  public synchronized int openStreamCount() {
+    return streams.size();
+  }
+
+  private synchronized SpdyStream getStream(int id) {
+    return streams.get(id);
+  }
+
+  synchronized SpdyStream removeStream(int streamId) {
+    SpdyStream stream = streams.remove(streamId);
+    if (stream != null && streams.isEmpty()) {
+      setIdle(true);
+    }
+    return stream;
+  }
+
+  private synchronized void setIdle(boolean value) {
+    idleStartTimeNs = value ? System.nanoTime() : 0L;
+  }
+
+  /** Returns true if this connection is idle. */
+  public synchronized boolean isIdle() {
+    return idleStartTimeNs != 0L;
+  }
+
+  /** Returns the time in ns when this connection became idle or 0L if connection is not idle. */
+  public synchronized long getIdleStartTimeNs() {
+    return idleStartTimeNs;
+  }
+
+  /**
+   * Returns a new locally-initiated stream.
+   *
+   * @param out true to create an output stream that we can use to send data
+   *     to the remote peer. Corresponds to {@code FLAG_FIN}.
+   * @param in true to create an input stream that the remote peer can use to
+   *     send data to us. Corresponds to {@code FLAG_UNIDIRECTIONAL}.
+   */
+  public SpdyStream newStream(List<String> requestHeaders, boolean out, boolean in)
+      throws IOException {
+    boolean outFinished = !out;
+    boolean inFinished = !in;
+    int associatedStreamId = 0;  // TODO: permit the caller to specify an associated stream?
+    int priority = 0; // TODO: permit the caller to specify a priority?
+    int slot = 0; // TODO: permit the caller to specify a slot?
+    SpdyStream stream;
+    int streamId;
+
+    synchronized (frameWriter) {
+      synchronized (this) {
+        if (shutdown) {
+          throw new IOException("shutdown");
+        }
+        streamId = nextStreamId;
+        nextStreamId += 2;
+        stream = new SpdyStream(streamId, this, outFinished, inFinished, priority, slot,
+            requestHeaders, settings);
+        if (stream.isOpen()) {
+          streams.put(streamId, stream);
+          setIdle(false);
+        }
+      }
+
+      frameWriter.synStream(outFinished, inFinished, streamId, associatedStreamId, priority, slot,
+          requestHeaders);
+    }
+
+    return stream;
+  }
+
+  void writeSynReply(int streamId, boolean outFinished, List<String> alternating)
+      throws IOException {
+    frameWriter.synReply(outFinished, streamId, alternating);
+  }
+
+  public void writeData(int streamId, boolean outFinished, byte[] buffer, int offset, int byteCount)
+      throws IOException {
+    frameWriter.data(outFinished, streamId, buffer, offset, byteCount);
+  }
+
+  void writeSynResetLater(final int streamId, final ErrorCode errorCode) {
+    executor.submit(new NamedRunnable("OkHttp SPDY Writer %s stream %d", hostName, streamId) {
+      @Override public void execute() {
+        try {
+          writeSynReset(streamId, errorCode);
+        } catch (IOException ignored) {
+        }
+      }
+    });
+  }
+
+  void writeSynReset(int streamId, ErrorCode statusCode) throws IOException {
+    frameWriter.rstStream(streamId, statusCode);
+  }
+
+  void writeWindowUpdateLater(final int streamId, final int deltaWindowSize) {
+    executor.submit(new NamedRunnable("OkHttp SPDY Writer %s stream %d", hostName, streamId) {
+      @Override public void execute() {
+        try {
+          writeWindowUpdate(streamId, deltaWindowSize);
+        } catch (IOException ignored) {
+        }
+      }
+    });
+  }
+
+  void writeWindowUpdate(int streamId, int deltaWindowSize) throws IOException {
+    frameWriter.windowUpdate(streamId, deltaWindowSize);
+  }
+
+  /**
+   * Sends a ping frame to the peer. Use the returned object to await the
+   * ping's response and observe its round trip time.
+   */
+  public Ping ping() throws IOException {
+    Ping ping = new Ping();
+    int pingId;
+    synchronized (this) {
+      if (shutdown) {
+        throw new IOException("shutdown");
+      }
+      pingId = nextPingId;
+      nextPingId += 2;
+      if (pings == null) pings = new HashMap<Integer, Ping>();
+      pings.put(pingId, ping);
+    }
+    writePing(false, pingId, 0x4f4b6f6b /* ASCII "OKok" */, ping);
+    return ping;
+  }
+
+  private void writePingLater(
+      final boolean reply, final int payload1, final int payload2, final Ping ping) {
+    executor.submit(new NamedRunnable("OkHttp SPDY Writer %s ping %08x%08x",
+        hostName, payload1, payload2) {
+      @Override public void execute() {
+        try {
+          writePing(reply, payload1, payload2, ping);
+        } catch (IOException ignored) {
+        }
+      }
+    });
+  }
+
+  private void writePing(boolean reply, int payload1, int payload2, Ping ping) throws IOException {
+    synchronized (frameWriter) {
+      // Observe the sent time immediately before performing I/O.
+      if (ping != null) ping.send();
+      frameWriter.ping(reply, payload1, payload2);
+    }
+  }
+
+  private synchronized Ping removePing(int id) {
+    return pings != null ? pings.remove(id) : null;
+  }
+
+  /** Sends a noop frame to the peer. */
+  public void noop() throws IOException {
+    frameWriter.noop();
+  }
+
+  public void flush() throws IOException {
+    frameWriter.flush();
+  }
+
+  /**
+   * Degrades this connection such that new streams can neither be created
+   * locally, nor accepted from the remote peer. Existing streams are not
+   * impacted. This is intended to permit an endpoint to gracefully stop
+   * accepting new requests without harming previously established streams.
+   */
+  public void shutdown(ErrorCode statusCode) throws IOException {
+    synchronized (frameWriter) {
+      int lastGoodStreamId;
+      synchronized (this) {
+        if (shutdown) {
+          return;
+        }
+        shutdown = true;
+        lastGoodStreamId = this.lastGoodStreamId;
+      }
+      frameWriter.goAway(lastGoodStreamId, statusCode);
+    }
+  }
+
+  /**
+   * Closes this connection. This cancels all open streams and unanswered
+   * pings. It closes the underlying input and output streams and shuts down
+   * internal executor services.
+   */
+  @Override public void close() throws IOException {
+    close(ErrorCode.NO_ERROR, ErrorCode.CANCEL);
+  }
+
+  private void close(ErrorCode connectionCode, ErrorCode streamCode) throws IOException {
+    assert (!Thread.holdsLock(this));
+    IOException thrown = null;
+    try {
+      shutdown(connectionCode);
+    } catch (IOException e) {
+      thrown = e;
+    }
+
+    SpdyStream[] streamsToClose = null;
+    Ping[] pingsToCancel = null;
+    synchronized (this) {
+      if (!streams.isEmpty()) {
+        streamsToClose = streams.values().toArray(new SpdyStream[streams.size()]);
+        streams.clear();
+        setIdle(false);
+      }
+      if (pings != null) {
+        pingsToCancel = pings.values().toArray(new Ping[pings.size()]);
+        pings = null;
+      }
+    }
+
+    if (streamsToClose != null) {
+      for (SpdyStream stream : streamsToClose) {
+        try {
+          stream.close(streamCode);
+        } catch (IOException e) {
+          if (thrown != null) thrown = e;
+        }
+      }
+    }
+
+    if (pingsToCancel != null) {
+      for (Ping ping : pingsToCancel) {
+        ping.cancel();
+      }
+    }
+
+    try {
+      frameReader.close();
+    } catch (IOException e) {
+      thrown = e;
+    }
+    try {
+      frameWriter.close();
+    } catch (IOException e) {
+      if (thrown == null) thrown = e;
+    }
+
+    if (thrown != null) throw thrown;
+  }
+
+  /**
+   * Sends a connection header if the current variant requires it. This should
+   * be called after {@link Builder#build} for all new connections.
+   */
+  public void sendConnectionHeader() {
+    frameWriter.connectionHeader();
+  }
+
+  public static class Builder {
+    private String hostName;
+    private InputStream in;
+    private OutputStream out;
+    private IncomingStreamHandler handler = IncomingStreamHandler.REFUSE_INCOMING_STREAMS;
+    private Variant variant = Variant.SPDY3;
+    private boolean client;
+
+    public Builder(boolean client, Socket socket) throws IOException {
+      this("", client, socket.getInputStream(), socket.getOutputStream());
+    }
+
+    public Builder(boolean client, InputStream in, OutputStream out) {
+      this("", client, in, out);
+    }
+
+    /**
+     * @param client true if this peer initiated the connection; false if
+     * this peer accepted the connection.
+     */
+    public Builder(String hostName, boolean client, Socket socket) throws IOException {
+      this(hostName, client, socket.getInputStream(), socket.getOutputStream());
+    }
+
+    /**
+     * @param client true if this peer initiated the connection; false if this
+     * peer accepted the connection.
+     */
+    public Builder(String hostName, boolean client, InputStream in, OutputStream out) {
+      this.hostName = hostName;
+      this.client = client;
+      this.in = in;
+      this.out = out;
+    }
+
+    public Builder handler(IncomingStreamHandler handler) {
+      this.handler = handler;
+      return this;
+    }
+
+    public Builder spdy3() {
+      this.variant = Variant.SPDY3;
+      return this;
+    }
+
+    public Builder http20Draft04() {
+      this.variant = Variant.HTTP_20_DRAFT_04;
+      return this;
+    }
+
+    public SpdyConnection build() {
+      return new SpdyConnection(this);
+    }
+  }
+
+  private class Reader implements Runnable, FrameReader.Handler {
+    @Override public void run() {
+      ErrorCode connectionErrorCode = ErrorCode.INTERNAL_ERROR;
+      ErrorCode streamErrorCode = ErrorCode.INTERNAL_ERROR;
+      try {
+        while (frameReader.nextFrame(this)) {
+        }
+        connectionErrorCode = ErrorCode.NO_ERROR;
+        streamErrorCode = ErrorCode.CANCEL;
+      } catch (IOException e) {
+        connectionErrorCode = ErrorCode.PROTOCOL_ERROR;
+        streamErrorCode = ErrorCode.PROTOCOL_ERROR;
+      } finally {
+        try {
+          close(connectionErrorCode, streamErrorCode);
+        } catch (IOException ignored) {
+        }
+      }
+    }
+
+    @Override public void data(boolean inFinished, int streamId, InputStream in, int length)
+        throws IOException {
+      SpdyStream dataStream = getStream(streamId);
+      if (dataStream == null) {
+        writeSynResetLater(streamId, ErrorCode.INVALID_STREAM);
+        Util.skipByReading(in, length);
+        return;
+      }
+      dataStream.receiveData(in, length);
+      if (inFinished) {
+        dataStream.receiveFin();
+      }
+    }
+
+    @Override public void synStream(boolean outFinished, boolean inFinished, int streamId,
+        int associatedStreamId, int priority, int slot, List<String> nameValueBlock) {
+      final SpdyStream synStream;
+      final SpdyStream previous;
+      synchronized (SpdyConnection.this) {
+        synStream = new SpdyStream(streamId, SpdyConnection.this, outFinished, inFinished, priority,
+            slot, nameValueBlock, settings);
+        if (shutdown) {
+          return;
+        }
+        lastGoodStreamId = streamId;
+        previous = streams.put(streamId, synStream);
+      }
+      if (previous != null) {
+        previous.closeLater(ErrorCode.PROTOCOL_ERROR);
+        removeStream(streamId);
+        return;
+      }
+
+      executor.submit(new NamedRunnable("OkHttp SPDY Callback %s stream %d", hostName, streamId) {
+        @Override public void execute() {
+          try {
+            handler.receive(synStream);
+          } catch (IOException e) {
+            throw new RuntimeException(e);
+          }
+        }
+      });
+    }
+
+    @Override public void synReply(boolean inFinished, int streamId, List<String> nameValueBlock)
+        throws IOException {
+      SpdyStream replyStream = getStream(streamId);
+      if (replyStream == null) {
+        writeSynResetLater(streamId, ErrorCode.INVALID_STREAM);
+        return;
+      }
+      replyStream.receiveReply(nameValueBlock);
+      if (inFinished) {
+        replyStream.receiveFin();
+      }
+    }
+
+    @Override public void headers(int streamId, List<String> nameValueBlock)
+        throws IOException {
+      SpdyStream replyStream = getStream(streamId);
+      if (replyStream != null) {
+        replyStream.receiveHeaders(nameValueBlock);
+      }
+    }
+
+    @Override public void rstStream(int streamId, ErrorCode errorCode) {
+      SpdyStream rstStream = removeStream(streamId);
+      if (rstStream != null) {
+        rstStream.receiveRstStream(errorCode);
+      }
+    }
+
+    @Override public void settings(boolean clearPrevious, Settings newSettings) {
+      SpdyStream[] streamsToNotify = null;
+      synchronized (SpdyConnection.this) {
+        if (settings == null || clearPrevious) {
+          settings = newSettings;
+        } else {
+          settings.merge(newSettings);
+        }
+        if (!streams.isEmpty()) {
+          streamsToNotify = streams.values().toArray(new SpdyStream[streams.size()]);
+        }
+      }
+      if (streamsToNotify != null) {
+        for (SpdyStream stream : streamsToNotify) {
+          // The synchronization here is ugly. We need to synchronize on 'this' to guard
+          // reads to 'settings'. We synchronize on 'stream' to guard the state change.
+          // And we need to acquire the 'stream' lock first, since that may block.
+          // TODO: this can block the reader thread until a write completes. That's bad!
+          synchronized (stream) {
+            synchronized (SpdyConnection.this) {
+              stream.receiveSettings(settings);
+            }
+          }
+        }
+      }
+    }
+
+    @Override public void noop() {
+    }
+
+    @Override public void ping(boolean reply, int payload1, int payload2) {
+      if (reply) {
+        Ping ping = removePing(payload1);
+        if (ping != null) {
+          ping.receive();
+        }
+      } else {
+        // Send a reply to a client ping if this is a server and vice versa.
+        writePingLater(true, payload1, payload2, null);
+      }
+    }
+
+    @Override public void goAway(int lastGoodStreamId, ErrorCode errorCode) {
+      synchronized (SpdyConnection.this) {
+        shutdown = true;
+
+        // Fail all streams created after the last good stream ID.
+        for (Iterator<Map.Entry<Integer, SpdyStream>> i = streams.entrySet().iterator();
+            i.hasNext(); ) {
+          Map.Entry<Integer, SpdyStream> entry = i.next();
+          int streamId = entry.getKey();
+          if (streamId > lastGoodStreamId && entry.getValue().isLocallyInitiated()) {
+            entry.getValue().receiveRstStream(ErrorCode.REFUSED_STREAM);
+            i.remove();
+          }
+        }
+      }
+    }
+
+    @Override public void windowUpdate(int streamId, int deltaWindowSize, boolean endFlowControl) {
+      if (streamId == 0) {
+        // TODO: honor whole-stream flow control
+        return;
+      }
+
+      // TODO: honor endFlowControl
+      SpdyStream stream = getStream(streamId);
+      if (stream != null) {
+        stream.receiveWindowUpdate(deltaWindowSize);
+      }
+    }
+
+    @Override public void priority(int streamId, int priority) {
+      // TODO: honor priority.
+    }
+  }
+}
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/SpdyStream.java b/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/SpdyStream.java
new file mode 100644
index 0000000000..a0de22d716
--- /dev/null
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/SpdyStream.java
@@ -0,0 +1,683 @@
+/*
+ * Copyright (C) 2011 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.squareup.okhttp.internal.spdy;
+
+import com.squareup.okhttp.internal.Util;
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.InterruptedIOException;
+import java.io.OutputStream;
+import java.net.SocketTimeoutException;
+import java.util.ArrayList;
+import java.util.List;
+
+import static com.squareup.okhttp.internal.Util.checkOffsetAndCount;
+
+/** A logical bidirectional stream. */
+public final class SpdyStream {
+
+  // Internal state is guarded by this. No long-running or potentially
+  // blocking operations are performed while the lock is held.
+
+  /**
+   * The number of unacknowledged bytes at which the input stream will send
+   * the peer a {@code WINDOW_UPDATE} frame. Must be less than this client's
+   * window size, otherwise the remote peer will stop sending data on this
+   * stream. (Chrome 25 uses 5 MiB.)
+   */
+  public static final int WINDOW_UPDATE_THRESHOLD = Settings.DEFAULT_INITIAL_WINDOW_SIZE / 2;
+
+  private final int id;
+  private final SpdyConnection connection;
+  private final int priority;
+  private final int slot;
+  private long readTimeoutMillis = 0;
+  private int writeWindowSize;
+
+  /** Headers sent by the stream initiator. Immutable and non null. */
+  private final List<String> requestHeaders;
+
+  /** Headers sent in the stream reply. Null if reply is either not sent or not sent yet. */
+  private List<String> responseHeaders;
+
+  private final SpdyDataInputStream in = new SpdyDataInputStream();
+  private final SpdyDataOutputStream out = new SpdyDataOutputStream();
+
+  /**
+   * The reason why this stream was abnormally closed. If there are multiple
+   * reasons to abnormally close this stream (such as both peers closing it
+   * near-simultaneously) then this is the first reason known to this peer.
+   */
+  private ErrorCode errorCode = null;
+
+  SpdyStream(int id, SpdyConnection connection, boolean outFinished, boolean inFinished,
+      int priority, int slot, List<String> requestHeaders, Settings settings) {
+    if (connection == null) throw new NullPointerException("connection == null");
+    if (requestHeaders == null) throw new NullPointerException("requestHeaders == null");
+    this.id = id;
+    this.connection = connection;
+    this.in.finished = inFinished;
+    this.out.finished = outFinished;
+    this.priority = priority;
+    this.slot = slot;
+    this.requestHeaders = requestHeaders;
+
+    setSettings(settings);
+  }
+
+  /**
+   * Returns true if this stream is open. A stream is open until either:
+   * <ul>
+   * <li>A {@code SYN_RESET} frame abnormally terminates the stream.
+   * <li>Both input and output streams have transmitted all data and
+   * headers.
+   * </ul>
+   * Note that the input stream may continue to yield data even after a stream
+   * reports itself as not open. This is because input data is buffered.
+   */
+  public synchronized boolean isOpen() {
+    if (errorCode != null) {
+      return false;
+    }
+    if ((in.finished || in.closed) && (out.finished || out.closed) && responseHeaders != null) {
+      return false;
+    }
+    return true;
+  }
+
+  /** Returns true if this stream was created by this peer. */
+  public boolean isLocallyInitiated() {
+    boolean streamIsClient = (id % 2 == 1);
+    return connection.client == streamIsClient;
+  }
+
+  public SpdyConnection getConnection() {
+    return connection;
+  }
+
+  public List<String> getRequestHeaders() {
+    return requestHeaders;
+  }
+
+  /**
+   * Returns the stream's response headers, blocking if necessary if they
+   * have not been received yet.
+   */
+  public synchronized List<String> getResponseHeaders() throws IOException {
+    try {
+      while (responseHeaders == null && errorCode == null) {
+        wait();
+      }
+      if (responseHeaders != null) {
+        return responseHeaders;
+      }
+      throw new IOException("stream was reset: " + errorCode);
+    } catch (InterruptedException e) {
+      InterruptedIOException rethrow = new InterruptedIOException();
+      rethrow.initCause(e);
+      throw rethrow;
+    }
+  }
+
+  /**
+   * Returns the reason why this stream was closed, or null if it closed
+   * normally or has not yet been closed.
+   */
+  public synchronized ErrorCode getErrorCode() {
+    return errorCode;
+  }
+
+  /**
+   * Sends a reply to an incoming stream.
+   *
+   * @param out true to create an output stream that we can use to send data
+   * to the remote peer. Corresponds to {@code FLAG_FIN}.
+   */
+  public void reply(List<String> responseHeaders, boolean out) throws IOException {
+    assert (!Thread.holdsLock(SpdyStream.this));
+    boolean outFinished = false;
+    synchronized (this) {
+      if (responseHeaders == null) {
+        throw new NullPointerException("responseHeaders == null");
+      }
+      if (isLocallyInitiated()) {
+        throw new IllegalStateException("cannot reply to a locally initiated stream");
+      }
+      if (this.responseHeaders != null) {
+        throw new IllegalStateException("reply already sent");
+      }
+      this.responseHeaders = responseHeaders;
+      if (!out) {
+        this.out.finished = true;
+        outFinished = true;
+      }
+    }
+    connection.writeSynReply(id, outFinished, responseHeaders);
+  }
+
+  /**
+   * Sets the maximum time to wait on input stream reads before failing with a
+   * {@code SocketTimeoutException}, or {@code 0} to wait indefinitely.
+   */
+  public void setReadTimeout(long readTimeoutMillis) {
+    this.readTimeoutMillis = readTimeoutMillis;
+  }
+
+  public long getReadTimeoutMillis() {
+    return readTimeoutMillis;
+  }
+
+  /** Returns an input stream that can be used to read data from the peer. */
+  public InputStream getInputStream() {
+    return in;
+  }
+
+  /**
+   * Returns an output stream that can be used to write data to the peer.
+   *
+   * @throws IllegalStateException if this stream was initiated by the peer
+   * and a {@link #reply} has not yet been sent.
+   */
+  public OutputStream getOutputStream() {
+    synchronized (this) {
+      if (responseHeaders == null && !isLocallyInitiated()) {
+        throw new IllegalStateException("reply before requesting the output stream");
+      }
+    }
+    return out;
+  }
+
+  /**
+   * Abnormally terminate this stream. This blocks until the {@code RST_STREAM}
+   * frame has been transmitted.
+   */
+  public void close(ErrorCode rstStatusCode) throws IOException {
+    if (!closeInternal(rstStatusCode)) {
+      return; // Already closed.
+    }
+    connection.writeSynReset(id, rstStatusCode);
+  }
+
+  /**
+   * Abnormally terminate this stream. This enqueues a {@code RST_STREAM}
+   * frame and returns immediately.
+   */
+  public void closeLater(ErrorCode errorCode) {
+    if (!closeInternal(errorCode)) {
+      return; // Already closed.
+    }
+    connection.writeSynResetLater(id, errorCode);
+  }
+
+  /** Returns true if this stream was closed. */
+  private boolean closeInternal(ErrorCode errorCode) {
+    assert (!Thread.holdsLock(this));
+    synchronized (this) {
+      if (this.errorCode != null) {
+        return false;
+      }
+      if (in.finished && out.finished) {
+        return false;
+      }
+      this.errorCode = errorCode;
+      notifyAll();
+    }
+    connection.removeStream(id);
+    return true;
+  }
+
+  void receiveReply(List<String> strings) throws IOException {
+    assert (!Thread.holdsLock(SpdyStream.this));
+    boolean streamInUseError = false;
+    boolean open = true;
+    synchronized (this) {
+      if (isLocallyInitiated() && responseHeaders == null) {
+        responseHeaders = strings;
+        open = isOpen();
+        notifyAll();
+      } else {
+        streamInUseError = true;
+      }
+    }
+    if (streamInUseError) {
+      closeLater(ErrorCode.STREAM_IN_USE);
+    } else if (!open) {
+      connection.removeStream(id);
+    }
+  }
+
+  void receiveHeaders(List<String> headers) throws IOException {
+    assert (!Thread.holdsLock(SpdyStream.this));
+    boolean protocolError = false;
+    synchronized (this) {
+      if (responseHeaders != null) {
+        List<String> newHeaders = new ArrayList<String>();
+        newHeaders.addAll(responseHeaders);
+        newHeaders.addAll(headers);
+        this.responseHeaders = newHeaders;
+      } else {
+        protocolError = true;
+      }
+    }
+    if (protocolError) {
+      closeLater(ErrorCode.PROTOCOL_ERROR);
+    }
+  }
+
+  void receiveData(InputStream in, int length) throws IOException {
+    assert (!Thread.holdsLock(SpdyStream.this));
+    this.in.receive(in, length);
+  }
+
+  void receiveFin() {
+    assert (!Thread.holdsLock(SpdyStream.this));
+    boolean open;
+    synchronized (this) {
+      this.in.finished = true;
+      open = isOpen();
+      notifyAll();
+    }
+    if (!open) {
+      connection.removeStream(id);
+    }
+  }
+
+  synchronized void receiveRstStream(ErrorCode errorCode) {
+    if (this.errorCode == null) {
+      this.errorCode = errorCode;
+      notifyAll();
+    }
+  }
+
+  private void setSettings(Settings settings) {
+    // TODO: For HTTP/2.0, also adjust the stream flow control window size
+    // by the difference between the new value and the old value.
+    assert (Thread.holdsLock(connection)); // Because 'settings' is guarded by 'connection'.
+    this.writeWindowSize = settings != null
+        ? settings.getInitialWindowSize(Settings.DEFAULT_INITIAL_WINDOW_SIZE)
+        : Settings.DEFAULT_INITIAL_WINDOW_SIZE;
+  }
+
+  void receiveSettings(Settings settings) {
+    assert (Thread.holdsLock(this));
+    setSettings(settings);
+    notifyAll();
+  }
+
+  synchronized void receiveWindowUpdate(int deltaWindowSize) {
+    out.unacknowledgedBytes -= deltaWindowSize;
+    notifyAll();
+  }
+
+  int getPriority() {
+    return priority;
+  }
+
+  int getSlot() {
+    return slot;
+  }
+
+  /**
+   * An input stream that reads the incoming data frames of a stream. Although
+   * this class uses synchronization to safely receive incoming data frames,
+   * it is not intended for use by multiple readers.
+   */
+  private final class SpdyDataInputStream extends InputStream {
+    // Store incoming data bytes in a circular buffer. When the buffer is
+    // empty, pos == -1. Otherwise pos is the first byte to read and limit
+    // is the first byte to write.
+    //
+    // { - - - X X X X - - - }
+    //         ^       ^
+    //        pos    limit
+    //
+    // { X X X - - - - X X X }
+    //         ^       ^
+    //       limit    pos
+
+    private final byte[] buffer = new byte[Settings.DEFAULT_INITIAL_WINDOW_SIZE];
+
+    /** the next byte to be read, or -1 if the buffer is empty. Never buffer.length */
+    private int pos = -1;
+
+    /** the last byte to be read. Never buffer.length */
+    private int limit;
+
+    /** True if the caller has closed this stream. */
+    private boolean closed;
+
+    /**
+     * True if either side has cleanly shut down this stream. We will
+     * receive no more bytes beyond those already in the buffer.
+     */
+    private boolean finished;
+
+    /**
+     * The total number of bytes consumed by the application (with {@link
+     * #read}), but not yet acknowledged by sending a {@code WINDOW_UPDATE}
+     * frame.
+     */
+    private int unacknowledgedBytes = 0;
+
+    @Override public int available() throws IOException {
+      synchronized (SpdyStream.this) {
+        checkNotClosed();
+        if (pos == -1) {
+          return 0;
+        } else if (limit > pos) {
+          return limit - pos;
+        } else {
+          return limit + (buffer.length - pos);
+        }
+      }
+    }
+
+    @Override public int read() throws IOException {
+      return Util.readSingleByte(this);
+    }
+
+    @Override public int read(byte[] b, int offset, int count) throws IOException {
+      synchronized (SpdyStream.this) {
+        checkOffsetAndCount(b.length, offset, count);
+        waitUntilReadable();
+        checkNotClosed();
+
+        if (pos == -1) {
+          return -1;
+        }
+
+        int copied = 0;
+
+        // drain from [pos..buffer.length)
+        if (limit <= pos) {
+          int bytesToCopy = Math.min(count, buffer.length - pos);
+          System.arraycopy(buffer, pos, b, offset, bytesToCopy);
+          pos += bytesToCopy;
+          copied += bytesToCopy;
+          if (pos == buffer.length) {
+            pos = 0;
+          }
+        }
+
+        // drain from [pos..limit)
+        if (copied < count) {
+          int bytesToCopy = Math.min(limit - pos, count - copied);
+          System.arraycopy(buffer, pos, b, offset + copied, bytesToCopy);
+          pos += bytesToCopy;
+          copied += bytesToCopy;
+        }
+
+        // Flow control: notify the peer that we're ready for more data!
+        unacknowledgedBytes += copied;
+        if (unacknowledgedBytes >= WINDOW_UPDATE_THRESHOLD) {
+          connection.writeWindowUpdateLater(id, unacknowledgedBytes);
+          unacknowledgedBytes = 0;
+        }
+
+        if (pos == limit) {
+          pos = -1;
+          limit = 0;
+        }
+
+        return copied;
+      }
+    }
+
+    /**
+     * Returns once the input stream is either readable or finished. Throws
+     * a {@link SocketTimeoutException} if the read timeout elapses before
+     * that happens.
+     */
+    private void waitUntilReadable() throws IOException {
+      long start = 0;
+      long remaining = 0;
+      if (readTimeoutMillis != 0) {
+        start = (System.nanoTime() / 1000000);
+        remaining = readTimeoutMillis;
+      }
+      try {
+        while (pos == -1 && !finished && !closed && errorCode == null) {
+          if (readTimeoutMillis == 0) {
+            SpdyStream.this.wait();
+          } else if (remaining > 0) {
+            SpdyStream.this.wait(remaining);
+            remaining = start + readTimeoutMillis - (System.nanoTime() / 1000000);
+          } else {
+            throw new SocketTimeoutException();
+          }
+        }
+      } catch (InterruptedException e) {
+        throw new InterruptedIOException();
+      }
+    }
+
+    void receive(InputStream in, int byteCount) throws IOException {
+      assert (!Thread.holdsLock(SpdyStream.this));
+
+      if (byteCount == 0) {
+        return;
+      }
+
+      int pos;
+      int limit;
+      int firstNewByte;
+      boolean finished;
+      boolean flowControlError;
+      synchronized (SpdyStream.this) {
+        finished = this.finished;
+        pos = this.pos;
+        firstNewByte = this.limit;
+        limit = this.limit;
+        flowControlError = byteCount > buffer.length - available();
+      }
+
+      // If the peer sends more data than we can handle, discard it and close the connection.
+      if (flowControlError) {
+        Util.skipByReading(in, byteCount);
+        closeLater(ErrorCode.FLOW_CONTROL_ERROR);
+        return;
+      }
+
+      // Discard data received after the stream is finished. It's probably a benign race.
+      if (finished) {
+        Util.skipByReading(in, byteCount);
+        return;
+      }
+
+      // Fill the buffer without holding any locks. First fill [limit..buffer.length) if that
+      // won't overwrite unread data. Then fill [limit..pos). We can't hold a lock, otherwise
+      // writes will be blocked until reads complete.
+      if (pos < limit) {
+        int firstCopyCount = Math.min(byteCount, buffer.length - limit);
+        Util.readFully(in, buffer, limit, firstCopyCount);
+        limit += firstCopyCount;
+        byteCount -= firstCopyCount;
+        if (limit == buffer.length) {
+          limit = 0;
+        }
+      }
+      if (byteCount > 0) {
+        Util.readFully(in, buffer, limit, byteCount);
+        limit += byteCount;
+      }
+
+      synchronized (SpdyStream.this) {
+        // Update the new limit, and mark the position as readable if necessary.
+        this.limit = limit;
+        if (this.pos == -1) {
+          this.pos = firstNewByte;
+          SpdyStream.this.notifyAll();
+        }
+      }
+    }
+
+    @Override public void close() throws IOException {
+      synchronized (SpdyStream.this) {
+        closed = true;
+        SpdyStream.this.notifyAll();
+      }
+      cancelStreamIfNecessary();
+    }
+
+    private void checkNotClosed() throws IOException {
+      if (closed) {
+        throw new IOException("stream closed");
+      }
+      if (errorCode != null) {
+        throw new IOException("stream was reset: " + errorCode);
+      }
+    }
+  }
+
+  private void cancelStreamIfNecessary() throws IOException {
+    assert (!Thread.holdsLock(SpdyStream.this));
+    boolean open;
+    boolean cancel;
+    synchronized (this) {
+      cancel = !in.finished && in.closed && (out.finished || out.closed);
+      open = isOpen();
+    }
+    if (cancel) {
+      // RST this stream to prevent additional data from being sent. This
+      // is safe because the input stream is closed (we won't use any
+      // further bytes) and the output stream is either finished or closed
+      // (so RSTing both streams doesn't cause harm).
+      SpdyStream.this.close(ErrorCode.CANCEL);
+    } else if (!open) {
+      connection.removeStream(id);
+    }
+  }
+
+  /**
+   * An output stream that writes outgoing data frames of a stream. This class
+   * is not thread safe.
+   */
+  private final class SpdyDataOutputStream extends OutputStream {
+    private final byte[] buffer = new byte[8192];
+    private int pos = 0;
+
+    /** True if the caller has closed this stream. */
+    private boolean closed;
+
+    /**
+     * True if either side has cleanly shut down this stream. We shall send
+     * no more bytes.
+     */
+    private boolean finished;
+
+    /**
+     * The total number of bytes written out to the peer, but not yet
+     * acknowledged with an incoming {@code WINDOW_UPDATE} frame. Writes
+     * block if they cause this to exceed the {@code WINDOW_SIZE}.
+     */
+    private int unacknowledgedBytes = 0;
+
+    @Override public void write(int b) throws IOException {
+      Util.writeSingleByte(this, b);
+    }
+
+    @Override public void write(byte[] bytes, int offset, int count) throws IOException {
+      assert (!Thread.holdsLock(SpdyStream.this));
+      checkOffsetAndCount(bytes.length, offset, count);
+      checkNotClosed();
+
+      while (count > 0) {
+        if (pos == buffer.length) {
+          writeFrame(false);
+        }
+        int bytesToCopy = Math.min(count, buffer.length - pos);
+        System.arraycopy(bytes, offset, buffer, pos, bytesToCopy);
+        pos += bytesToCopy;
+        offset += bytesToCopy;
+        count -= bytesToCopy;
+      }
+    }
+
+    @Override public void flush() throws IOException {
+      assert (!Thread.holdsLock(SpdyStream.this));
+      checkNotClosed();
+      if (pos > 0) {
+        writeFrame(false);
+        connection.flush();
+      }
+    }
+
+    @Override public void close() throws IOException {
+      assert (!Thread.holdsLock(SpdyStream.this));
+      synchronized (SpdyStream.this) {
+        if (closed) {
+          return;
+        }
+        closed = true;
+      }
+      if (!out.finished) {
+        writeFrame(true);
+      }
+      connection.flush();
+      cancelStreamIfNecessary();
+    }
+
+    private void writeFrame(boolean outFinished) throws IOException {
+      assert (!Thread.holdsLock(SpdyStream.this));
+
+      int length = pos;
+      synchronized (SpdyStream.this) {
+        waitUntilWritable(length, outFinished);
+        unacknowledgedBytes += length;
+      }
+      connection.writeData(id, outFinished, buffer, 0, pos);
+      pos = 0;
+    }
+
+    /**
+     * Returns once the peer is ready to receive {@code count} bytes.
+     *
+     * @throws IOException if the stream was finished or closed, or the
+     * thread was interrupted.
+     */
+    private void waitUntilWritable(int count, boolean last) throws IOException {
+      try {
+        while (unacknowledgedBytes + count >= writeWindowSize) {
+          SpdyStream.this.wait(); // Wait until we receive a WINDOW_UPDATE.
+
+          // The stream may have been closed or reset while we were waiting!
+          if (!last && closed) {
+            throw new IOException("stream closed");
+          } else if (finished) {
+            throw new IOException("stream finished");
+          } else if (errorCode != null) {
+            throw new IOException("stream was reset: " + errorCode);
+          }
+        }
+      } catch (InterruptedException e) {
+        throw new InterruptedIOException();
+      }
+    }
+
+    private void checkNotClosed() throws IOException {
+      synchronized (SpdyStream.this) {
+        if (closed) {
+          throw new IOException("stream closed");
+        } else if (finished) {
+          throw new IOException("stream finished");
+        } else if (errorCode != null) {
+          throw new IOException("stream was reset: " + errorCode);
+        }
+      }
+    }
+  }
+}
diff --git a/okhttp/src/test/java/com/squareup/okhttp/internal/RecordingHostnameVerifier.java b/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/Variant.java
similarity index 54%
rename from okhttp/src/test/java/com/squareup/okhttp/internal/RecordingHostnameVerifier.java
rename to okhttp/src/main/java/com/squareup/okhttp/internal/spdy/Variant.java
index b3e2369b79..b60c70845a 100644
--- a/okhttp/src/test/java/com/squareup/okhttp/internal/RecordingHostnameVerifier.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/Variant.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2013 The Android Open Source Project
+ * Copyright (C) 2013 Square, Inc.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,18 +13,16 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.squareup.okhttp.internal;
+package com.squareup.okhttp.internal.spdy;
 
-import java.util.ArrayList;
-import java.util.List;
-import javax.net.ssl.HostnameVerifier;
-import javax.net.ssl.SSLSession;
+import java.io.InputStream;
+import java.io.OutputStream;
 
-public final class RecordingHostnameVerifier implements HostnameVerifier {
-  public final List<String> calls = new ArrayList<String>();
+/** A version and dialect of the framed socket protocol. */
+interface Variant {
+  Variant SPDY3 = new Spdy3();
+  Variant HTTP_20_DRAFT_04 = new Http20Draft04();
 
-  public boolean verify(String hostname, SSLSession session) {
-    calls.add("verify " + hostname);
-    return true;
-  }
+  FrameReader newReader(InputStream in, boolean client);
+  FrameWriter newWriter(OutputStream out, boolean client);
 }
diff --git a/okhttp/src/test/java/com/squareup/okhttp/AsyncApiTest.java b/okhttp/src/test/java/com/squareup/okhttp/AsyncApiTest.java
deleted file mode 100644
index 6636ca7cc6..0000000000
--- a/okhttp/src/test/java/com/squareup/okhttp/AsyncApiTest.java
+++ /dev/null
@@ -1,72 +0,0 @@
-/*
- * Copyright (C) 2013 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.squareup.okhttp;
-
-import com.squareup.okhttp.mockwebserver.MockResponse;
-import com.squareup.okhttp.mockwebserver.MockWebServer;
-import com.squareup.okhttp.mockwebserver.RecordedRequest;
-import org.junit.After;
-import org.junit.Test;
-
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertTrue;
-
-public final class AsyncApiTest {
-  private MockWebServer server = new MockWebServer();
-  private OkHttpClient client = new OkHttpClient();
-  private RecordingReceiver receiver = new RecordingReceiver();
-
-  @After public void tearDown() throws Exception {
-    server.shutdown();
-  }
-
-  @Test public void get() throws Exception {
-    server.enqueue(new MockResponse()
-        .setBody("abc")
-        .addHeader("Content-Type: text/plain"));
-    server.play();
-
-    Request request = new Request.Builder(server.getUrl("/"))
-        .header("User-Agent", "AsyncApiTest")
-        .build();
-    client.enqueue(request, receiver);
-
-    receiver.await(request)
-        .assertCode(200)
-        .assertContainsHeaders("Content-Type: text/plain")
-        .assertBody("abc");
-
-    assertTrue(server.takeRequest().getHeaders().contains("User-Agent: AsyncApiTest"));
-  }
-
-  @Test public void post() throws Exception {
-    server.enqueue(new MockResponse().setBody("abc"));
-    server.play();
-
-    Request request = new Request.Builder(server.getUrl("/"))
-        .post(Request.Body.create(MediaType.parse("text/plain"), "def"))
-        .build();
-    client.enqueue(request, receiver);
-
-    receiver.await(request)
-        .assertCode(200)
-        .assertBody("abc");
-
-    RecordedRequest recordedRequest = server.takeRequest();
-    assertEquals("def", recordedRequest.getUtf8Body());
-    assertEquals("3", recordedRequest.getHeader("Content-Length"));
-  }
-}
diff --git a/okhttp/src/test/java/com/squareup/okhttp/ConnectionPoolTest.java b/okhttp/src/test/java/com/squareup/okhttp/ConnectionPoolTest.java
deleted file mode 100644
index e243857333..0000000000
--- a/okhttp/src/test/java/com/squareup/okhttp/ConnectionPoolTest.java
+++ /dev/null
@@ -1,409 +0,0 @@
-/*
- * Copyright (C) 2013 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.squareup.okhttp;
-
-import com.squareup.okhttp.internal.RecordingHostnameVerifier;
-import com.squareup.okhttp.internal.SslContextBuilder;
-import com.squareup.okhttp.internal.Util;
-import com.squareup.okhttp.internal.http.HttpAuthenticator;
-import com.squareup.okhttp.mockwebserver.MockWebServer;
-import java.io.IOException;
-import java.net.InetAddress;
-import java.net.InetSocketAddress;
-import java.net.Proxy;
-import java.net.UnknownHostException;
-import java.security.GeneralSecurityException;
-import java.util.Arrays;
-import javax.net.ssl.SSLContext;
-import org.junit.After;
-import org.junit.Before;
-import org.junit.Test;
-
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertNotNull;
-import static org.junit.Assert.assertNull;
-import static org.junit.Assert.assertSame;
-import static org.junit.Assert.assertTrue;
-
-public final class ConnectionPoolTest {
-  private static final int KEEP_ALIVE_DURATION_MS = 5000;
-  private static final SSLContext sslContext;
-
-  static {
-    try {
-      sslContext = new SslContextBuilder(InetAddress.getLocalHost().getHostName()).build();
-    } catch (GeneralSecurityException e) {
-      throw new RuntimeException(e);
-    } catch (UnknownHostException e) {
-      throw new RuntimeException(e);
-    }
-  }
-
-  private final MockWebServer spdyServer = new MockWebServer();
-  private InetSocketAddress spdySocketAddress;
-  private Address spdyAddress;
-
-  private final MockWebServer httpServer = new MockWebServer();
-  private Address httpAddress;
-  private InetSocketAddress httpSocketAddress;
-
-  private Connection httpA;
-  private Connection httpB;
-  private Connection httpC;
-  private Connection httpD;
-  private Connection httpE;
-  private Connection spdyA;
-  private Connection spdyB;
-
-  @Before public void setUp() throws Exception {
-    spdyServer.useHttps(sslContext.getSocketFactory(), false);
-
-    httpServer.play();
-    httpAddress = new Address(httpServer.getHostName(), httpServer.getPort(), null, null,
-        HttpAuthenticator.SYSTEM_DEFAULT, null, Arrays.asList("spdy/3", "http/1.1"));
-    httpSocketAddress = new InetSocketAddress(InetAddress.getByName(httpServer.getHostName()),
-        httpServer.getPort());
-
-    spdyServer.play();
-    spdyAddress = new Address(spdyServer.getHostName(), spdyServer.getPort(),
-        sslContext.getSocketFactory(), new RecordingHostnameVerifier(),
-        HttpAuthenticator.SYSTEM_DEFAULT, null, Arrays.asList("spdy/3", "http/1.1"));
-    spdySocketAddress = new InetSocketAddress(InetAddress.getByName(spdyServer.getHostName()),
-        spdyServer.getPort());
-
-    Route httpRoute = new Route(httpAddress, Proxy.NO_PROXY, httpSocketAddress, true);
-    Route spdyRoute = new Route(spdyAddress, Proxy.NO_PROXY, spdySocketAddress, true);
-    httpA = new Connection(httpRoute);
-    httpA.connect(100, 100, null);
-    httpB = new Connection(httpRoute);
-    httpB.connect(100, 100, null);
-    httpC = new Connection(httpRoute);
-    httpC.connect(100, 100, null);
-    httpD = new Connection(httpRoute);
-    httpD.connect(100, 100, null);
-    httpE = new Connection(httpRoute);
-    httpE.connect(100, 100, null);
-    spdyA = new Connection(spdyRoute);
-    spdyA.connect(100, 100, null);
-    spdyB = new Connection(spdyRoute);
-    spdyB.connect(100, 100, null);
-  }
-
-  @After public void tearDown() throws Exception {
-    httpServer.shutdown();
-    spdyServer.shutdown();
-
-    Util.closeQuietly(httpA);
-    Util.closeQuietly(httpB);
-    Util.closeQuietly(httpC);
-    Util.closeQuietly(httpD);
-    Util.closeQuietly(httpE);
-    Util.closeQuietly(spdyA);
-    Util.closeQuietly(spdyB);
-  }
-
-  @Test public void poolSingleHttpConnection() throws IOException {
-    ConnectionPool pool = new ConnectionPool(1, KEEP_ALIVE_DURATION_MS);
-    Connection connection = pool.get(httpAddress);
-    assertNull(connection);
-
-    connection = new Connection(new Route(httpAddress, Proxy.NO_PROXY, httpSocketAddress, true));
-    connection.connect(100, 100, null);
-    assertEquals(0, pool.getConnectionCount());
-    pool.recycle(connection);
-    assertEquals(1, pool.getConnectionCount());
-    assertEquals(1, pool.getHttpConnectionCount());
-    assertEquals(0, pool.getSpdyConnectionCount());
-
-    Connection recycledConnection = pool.get(httpAddress);
-    assertEquals(connection, recycledConnection);
-    assertTrue(recycledConnection.isAlive());
-
-    recycledConnection = pool.get(httpAddress);
-    assertNull(recycledConnection);
-  }
-
-  @Test public void poolPrefersMostRecentlyRecycled() throws Exception {
-    ConnectionPool pool = new ConnectionPool(2, KEEP_ALIVE_DURATION_MS);
-    pool.recycle(httpA);
-    pool.recycle(httpB);
-    pool.recycle(httpC);
-    assertPooled(pool, httpC, httpB);
-  }
-
-  @Test public void getSpdyConnection() throws Exception {
-    ConnectionPool pool = new ConnectionPool(2, KEEP_ALIVE_DURATION_MS);
-    pool.maybeShare(spdyA);
-    assertSame(spdyA, pool.get(spdyAddress));
-    assertPooled(pool, spdyA);
-  }
-
-  @Test public void getHttpConnection() throws Exception {
-    ConnectionPool pool = new ConnectionPool(2, KEEP_ALIVE_DURATION_MS);
-    pool.recycle(httpA);
-    assertSame(httpA, pool.get(httpAddress));
-    assertPooled(pool);
-  }
-
-  @Test public void idleConnectionNotReturned() throws Exception {
-    ConnectionPool pool = new ConnectionPool(2, KEEP_ALIVE_DURATION_MS);
-    pool.recycle(httpA);
-    Thread.sleep(KEEP_ALIVE_DURATION_MS * 2);
-    assertNull(pool.get(httpAddress));
-    assertPooled(pool);
-  }
-
-  @Test public void maxIdleConnectionLimitIsEnforced() throws Exception {
-    ConnectionPool pool = new ConnectionPool(2, KEEP_ALIVE_DURATION_MS);
-    pool.recycle(httpA);
-    pool.recycle(httpB);
-    pool.recycle(httpC);
-    pool.recycle(httpD);
-    assertPooled(pool, httpD, httpC);
-  }
-
-  @Test public void expiredConnectionsAreEvicted() throws Exception {
-    ConnectionPool pool = new ConnectionPool(2, KEEP_ALIVE_DURATION_MS);
-    pool.recycle(httpA);
-    pool.recycle(httpB);
-    Thread.sleep(2 * KEEP_ALIVE_DURATION_MS);
-    pool.get(spdyAddress); // Force the cleanup callable to run.
-    assertPooled(pool);
-  }
-
-  @Test public void nonAliveConnectionNotReturned() throws Exception {
-    ConnectionPool pool = new ConnectionPool(2, KEEP_ALIVE_DURATION_MS);
-    pool.recycle(httpA);
-    httpA.close();
-    assertNull(pool.get(httpAddress));
-    assertPooled(pool);
-  }
-
-  @Test public void differentAddressConnectionNotReturned() throws Exception {
-    ConnectionPool pool = new ConnectionPool(2, KEEP_ALIVE_DURATION_MS);
-    pool.recycle(httpA);
-    assertNull(pool.get(spdyAddress));
-    assertPooled(pool, httpA);
-  }
-
-  @Test public void gettingSpdyConnectionPromotesItToFrontOfQueue() throws Exception {
-    ConnectionPool pool = new ConnectionPool(2, KEEP_ALIVE_DURATION_MS);
-    pool.maybeShare(spdyA);
-    pool.recycle(httpA);
-    assertPooled(pool, httpA, spdyA);
-    assertSame(spdyA, pool.get(spdyAddress));
-    assertPooled(pool, spdyA, httpA);
-  }
-
-  @Test public void gettingConnectionReturnsOldestFirst() throws Exception {
-    ConnectionPool pool = new ConnectionPool(2, KEEP_ALIVE_DURATION_MS);
-    pool.recycle(httpA);
-    pool.recycle(httpB);
-    assertSame(httpA, pool.get(httpAddress));
-  }
-
-  @Test public void recyclingNonAliveConnectionClosesThatConnection() throws Exception {
-    ConnectionPool pool = new ConnectionPool(2, KEEP_ALIVE_DURATION_MS);
-    httpA.getSocket().shutdownInput();
-    pool.recycle(httpA); // Should close httpA.
-    assertTrue(httpA.getSocket().isClosed());
-  }
-
-  @Test public void shareHttpConnectionDoesNothing() throws Exception {
-    ConnectionPool pool = new ConnectionPool(2, KEEP_ALIVE_DURATION_MS);
-    pool.maybeShare(httpA);
-    assertPooled(pool);
-  }
-
-  @Test public void recycleSpdyConnectionDoesNothing() throws Exception {
-    ConnectionPool pool = new ConnectionPool(2, KEEP_ALIVE_DURATION_MS);
-    pool.recycle(spdyA);
-    assertPooled(pool);
-  }
-
-  @Test public void validateIdleSpdyConnectionTimeout() throws Exception {
-    ConnectionPool pool = new ConnectionPool(2, KEEP_ALIVE_DURATION_MS);
-    pool.maybeShare(spdyA);
-    Thread.sleep((int) (KEEP_ALIVE_DURATION_MS * 0.7));
-    assertNull(pool.get(httpAddress));
-    assertPooled(pool, spdyA); // Connection should still be in the pool.
-    Thread.sleep((int) (KEEP_ALIVE_DURATION_MS * 0.4));
-    assertNull(pool.get(httpAddress));
-    assertPooled(pool);
-  }
-
-  @Test public void validateIdleHttpConnectionTimeout() throws Exception {
-    ConnectionPool pool = new ConnectionPool(2, KEEP_ALIVE_DURATION_MS);
-    pool.recycle(httpA);
-    Thread.sleep((int) (KEEP_ALIVE_DURATION_MS * 0.7));
-    assertNull(pool.get(spdyAddress));
-    assertPooled(pool, httpA); // Connection should still be in the pool.
-    Thread.sleep((int) (KEEP_ALIVE_DURATION_MS * 0.4));
-    assertNull(pool.get(spdyAddress));
-    assertPooled(pool);
-  }
-
-  @Test public void maxConnections() throws IOException, InterruptedException {
-    ConnectionPool pool = new ConnectionPool(2, KEEP_ALIVE_DURATION_MS);
-
-    // Pool should be empty.
-    assertEquals(0, pool.getConnectionCount());
-
-    // http A should be added to the pool.
-    pool.recycle(httpA);
-    assertEquals(1, pool.getConnectionCount());
-    assertEquals(1, pool.getHttpConnectionCount());
-    assertEquals(0, pool.getSpdyConnectionCount());
-
-    // http B should be added to the pool.
-    pool.recycle(httpB);
-    assertEquals(2, pool.getConnectionCount());
-    assertEquals(2, pool.getHttpConnectionCount());
-    assertEquals(0, pool.getSpdyConnectionCount());
-
-    // http C should be added and http A should be removed.
-    pool.recycle(httpC);
-    Thread.sleep(50);
-    assertEquals(2, pool.getConnectionCount());
-    assertEquals(2, pool.getHttpConnectionCount());
-    assertEquals(0, pool.getSpdyConnectionCount());
-
-    // spdy A should be added and http B should be removed.
-    pool.maybeShare(spdyA);
-    Thread.sleep(50);
-    assertEquals(2, pool.getConnectionCount());
-    assertEquals(1, pool.getHttpConnectionCount());
-    assertEquals(1, pool.getSpdyConnectionCount());
-
-    // http C should be removed from the pool.
-    Connection recycledHttpConnection = pool.get(httpAddress);
-    assertNotNull(recycledHttpConnection);
-    assertTrue(recycledHttpConnection.isAlive());
-    assertEquals(1, pool.getConnectionCount());
-    assertEquals(0, pool.getHttpConnectionCount());
-    assertEquals(1, pool.getSpdyConnectionCount());
-
-    // spdy A will be returned and kept in the pool.
-    Connection sharedSpdyConnection = pool.get(spdyAddress);
-    assertNotNull(sharedSpdyConnection);
-    assertEquals(spdyA, sharedSpdyConnection);
-    assertEquals(1, pool.getConnectionCount());
-    assertEquals(0, pool.getHttpConnectionCount());
-    assertEquals(1, pool.getSpdyConnectionCount());
-
-    // Nothing should change.
-    pool.recycle(httpC);
-    Thread.sleep(50);
-    assertEquals(2, pool.getConnectionCount());
-    assertEquals(1, pool.getHttpConnectionCount());
-    assertEquals(1, pool.getSpdyConnectionCount());
-
-    // Nothing should change.
-    pool.maybeShare(spdyB);
-    Thread.sleep(50);
-    assertEquals(2, pool.getConnectionCount());
-    assertEquals(1, pool.getHttpConnectionCount());
-    assertEquals(1, pool.getSpdyConnectionCount());
-
-    // An http connection should be removed from the pool.
-    recycledHttpConnection = pool.get(httpAddress);
-    assertNotNull(recycledHttpConnection);
-    assertTrue(recycledHttpConnection.isAlive());
-    assertEquals(1, pool.getConnectionCount());
-    assertEquals(0, pool.getHttpConnectionCount());
-    assertEquals(1, pool.getSpdyConnectionCount());
-
-    // Shouldn't change numbers because spdyConnections A and B user the same server address.
-    pool.maybeShare(spdyB);
-    Thread.sleep(50);
-    assertEquals(1, pool.getConnectionCount());
-    assertEquals(0, pool.getHttpConnectionCount());
-    assertEquals(1, pool.getSpdyConnectionCount());
-
-    // spdy A will be returned and kept in the pool. Pool shouldn't change.
-    sharedSpdyConnection = pool.get(spdyAddress);
-    assertEquals(spdyA, sharedSpdyConnection);
-    assertNotNull(sharedSpdyConnection);
-    assertEquals(1, pool.getConnectionCount());
-    assertEquals(0, pool.getHttpConnectionCount());
-    assertEquals(1, pool.getSpdyConnectionCount());
-
-    // http D should be added to the pool.
-    pool.recycle(httpD);
-    Thread.sleep(50);
-    assertEquals(2, pool.getConnectionCount());
-    assertEquals(1, pool.getHttpConnectionCount());
-    assertEquals(1, pool.getSpdyConnectionCount());
-
-    // http E should be added to the pool. spdy A should be removed from the pool.
-    pool.recycle(httpE);
-    Thread.sleep(50);
-    assertEquals(2, pool.getConnectionCount());
-    assertEquals(2, pool.getHttpConnectionCount());
-    assertEquals(0, pool.getSpdyConnectionCount());
-  }
-
-  @Test public void connectionCleanup() throws IOException, InterruptedException {
-    ConnectionPool pool = new ConnectionPool(10, KEEP_ALIVE_DURATION_MS);
-
-    // Add 3 connections to the pool.
-    pool.recycle(httpA);
-    pool.recycle(httpB);
-    pool.maybeShare(spdyA);
-    assertEquals(3, pool.getConnectionCount());
-    assertEquals(2, pool.getHttpConnectionCount());
-    assertEquals(1, pool.getSpdyConnectionCount());
-
-    // Kill http A.
-    Util.closeQuietly(httpA);
-
-    // Force pool to run a clean up.
-    assertNotNull(pool.get(spdyAddress));
-    Thread.sleep(50);
-
-    assertEquals(2, pool.getConnectionCount());
-    assertEquals(1, pool.getHttpConnectionCount());
-    assertEquals(1, pool.getSpdyConnectionCount());
-
-    Thread.sleep(KEEP_ALIVE_DURATION_MS);
-    // Force pool to run a clean up.
-    assertNull(pool.get(httpAddress));
-    assertNull(pool.get(spdyAddress));
-
-    Thread.sleep(50);
-
-    assertEquals(0, pool.getConnectionCount());
-    assertEquals(0, pool.getHttpConnectionCount());
-    assertEquals(0, pool.getSpdyConnectionCount());
-  }
-
-  @Test public void evictAllConnections() {
-    ConnectionPool pool = new ConnectionPool(10, KEEP_ALIVE_DURATION_MS);
-    pool.recycle(httpA);
-    Util.closeQuietly(httpA); // Include a closed connection in the pool.
-    pool.recycle(httpB);
-    pool.maybeShare(spdyA);
-    int connectionCount = pool.getConnectionCount();
-    assertTrue(connectionCount == 2 || connectionCount == 3);
-
-    pool.evictAll();
-    assertEquals(0, pool.getConnectionCount());
-  }
-
-  private void assertPooled(ConnectionPool pool, Connection... connections) throws Exception {
-    assertEquals(Arrays.asList(connections), pool.getConnections());
-  }
-}
diff --git a/okhttp/src/test/java/com/squareup/okhttp/MediaTypeTest.java b/okhttp/src/test/java/com/squareup/okhttp/MediaTypeTest.java
deleted file mode 100644
index acbfdd5c16..0000000000
--- a/okhttp/src/test/java/com/squareup/okhttp/MediaTypeTest.java
+++ /dev/null
@@ -1,151 +0,0 @@
-/*
- * Copyright (C) 2013 Square, Inc.
- * Copyright (C) 2011 The Guava Authors
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.squareup.okhttp;
-
-import com.squareup.okhttp.internal.Util;
-import java.nio.charset.Charset;
-import java.nio.charset.IllegalCharsetNameException;
-import java.nio.charset.UnsupportedCharsetException;
-import org.junit.Test;
-
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertNull;
-import static org.junit.Assert.assertTrue;
-import static org.junit.Assert.fail;
-
-/**
- * Test MediaType API and parsing.
- *
- * <p>This test includes tests from <a
- * href="https://code.google.com/p/guava-libraries/">Guava's</a> MediaTypeTest.
- */
-public class MediaTypeTest {
-  @Test public void testParse() throws Exception {
-    MediaType mediaType = MediaType.parse("text/plain;boundary=foo;charset=utf-8");
-    assertEquals("text", mediaType.type());
-    assertEquals("plain", mediaType.subtype());
-    assertEquals("UTF-8", mediaType.charset().name());
-    assertEquals("text/plain;boundary=foo;charset=utf-8", mediaType.toString());
-    assertTrue(mediaType.equals(MediaType.parse("text/plain;boundary=foo;charset=utf-8")));
-    assertEquals(mediaType.hashCode(),
-        MediaType.parse("text/plain;boundary=foo;charset=utf-8").hashCode());
-  }
-
-  @Test public void testValidParse() throws Exception {
-    assertMediaType("text/plain");
-    assertMediaType("application/atom+xml; charset=utf-8");
-    assertMediaType("application/atom+xml; a=1; a=2; b=3");
-    assertMediaType("image/gif; foo=bar");
-    assertMediaType("text/plain; a=1");
-    assertMediaType("text/plain; a=1; a=2; b=3");
-    assertMediaType("text/plain; charset=utf-16");
-    assertMediaType("text/plain; \t \n \r a=b");
-  }
-
-  @Test public void testInvalidParse() throws Exception {
-    assertInvalid("");
-    assertInvalid("/");
-    assertInvalid("/");
-    assertInvalid("text");
-    assertInvalid("text/");
-    assertInvalid("te<t/plain");
-    assertInvalid("text/pl@in");
-    assertInvalid("text/plain;");
-    assertInvalid("text/plain; ");
-    assertInvalid("text/plain; a");
-    assertInvalid("text/plain; a=");
-    assertInvalid("text/plain; a=@");
-    assertInvalid("text/plain; a=\"@");
-    assertInvalid("text/plain; a=1;");
-    assertInvalid("text/plain; a=1; ");
-    assertInvalid("text/plain; a=1; b");
-    assertInvalid("text/plain; a=1; b=");
-    assertInvalid("text/plain; a=\u2025");
-    assertInvalid(" text/plain");
-    assertInvalid("te xt/plain");
-    assertInvalid("text /plain");
-    assertInvalid("text/ plain");
-    assertInvalid("text/pl ain");
-    assertInvalid("text/plain ");
-    assertInvalid("text/plain ; a=1");
-  }
-
-  @Test public void testParseWithSpecialCharacters() throws Exception {
-    MediaType mediaType = MediaType.parse(
-        "!#$%&'*+-.{|}~/!#$%&'*+-.{|}~; !#$%&'*+-.{|}~=!#$%&'*+-.{|}~");
-    assertEquals("!#$%&'*+-.{|}~", mediaType.type());
-    assertEquals("!#$%&'*+-.{|}~", mediaType.subtype());
-  }
-
-  @Test public void testCharsetIsOneOfManyParameters() throws Exception {
-    MediaType mediaType = MediaType.parse("text/plain;a=1;b=2;charset=utf-8;c=3");
-    assertEquals("text", mediaType.type());
-    assertEquals("plain", mediaType.subtype());
-    assertEquals("UTF-8", mediaType.charset().name());
-  }
-
-  @Test public void testCharsetAndQuoting() throws Exception {
-    MediaType mediaType = MediaType.parse(
-        "text/plain;a=\";charset=us-ascii\";charset=\"utf-8\";b=\"iso-8859-1\"");
-    assertEquals("UTF-8", mediaType.charset().name());
-  }
-
-  @Test public void testMultipleCharsets() {
-    try {
-      MediaType.parse("text/plain; charset=utf-8; charset=utf-16");
-      fail();
-    } catch (IllegalArgumentException expected) {
-    }
-  }
-
-  @Test public void testIllegalCharsetName() {
-    MediaType mediaType = MediaType.parse("text/plain; charset=\"!@#$%^&*()\"");
-    try {
-      mediaType.charset();
-      fail();
-    } catch (IllegalCharsetNameException expected) {
-    }
-  }
-
-  @Test public void testUnsupportedCharset() {
-    MediaType mediaType = MediaType.parse("text/plain; charset=utf-wtf");
-    try {
-      mediaType.charset();
-      fail();
-    } catch (UnsupportedCharsetException expected) {
-    }
-  }
-
-  @Test public void testDefaultCharset() throws Exception {
-    MediaType noCharset = MediaType.parse("text/plain");
-    assertEquals("UTF-8", noCharset.charset(Util.UTF_8).name());
-    assertEquals("US-ASCII", noCharset.charset(Charset.forName("US-ASCII")).name());
-
-    MediaType charset = MediaType.parse("text/plain; charset=iso-8859-1");
-    assertEquals("ISO-8859-1", charset.charset(Util.UTF_8).name());
-    assertEquals("ISO-8859-1", charset.charset(Charset.forName("US-ASCII")).name());
-  }
-
-  private void assertMediaType(String string) {
-    MediaType mediaType = MediaType.parse(string);
-    assertEquals(string, mediaType.toString());
-  }
-
-  private void assertInvalid(String string) {
-    assertNull(string, MediaType.parse(string));
-  }
-}
diff --git a/okhttp/src/test/java/com/squareup/okhttp/RecordedResponse.java b/okhttp/src/test/java/com/squareup/okhttp/RecordedResponse.java
deleted file mode 100644
index f30ae98573..0000000000
--- a/okhttp/src/test/java/com/squareup/okhttp/RecordedResponse.java
+++ /dev/null
@@ -1,61 +0,0 @@
-/*
- * Copyright (C) 2013 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.squareup.okhttp;
-
-import java.util.ArrayList;
-import java.util.Arrays;
-import java.util.List;
-
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.fail;
-
-/**
- * A received response or failure recorded by the response recorder.
- */
-public class RecordedResponse {
-  public final Request request;
-  public final Response response;
-  public final String body;
-  public final Failure failure;
-
-  RecordedResponse(Request request, Response response, String body, Failure failure) {
-    this.request = request;
-    this.response = response;
-    this.body = body;
-    this.failure = failure;
-  }
-
-  public RecordedResponse assertCode(int expectedCode) {
-    assertEquals(expectedCode, response.code());
-    return this;
-  }
-
-  public RecordedResponse assertContainsHeaders(String... expectedHeaders) {
-    List<String> actualHeaders = new ArrayList<String>();
-    for (int i = 0; i < response.headerCount(); i++) {
-      actualHeaders.add(response.headerName(i) + ": " + response.headerValue(i));
-    }
-    if (!actualHeaders.containsAll(Arrays.asList(expectedHeaders))) {
-      fail("Expected: " + actualHeaders + "\nto contain: " + Arrays.toString(expectedHeaders));
-    }
-    return this;
-  }
-
-  public RecordedResponse assertBody(String expectedBody) {
-    assertEquals(expectedBody, body);
-    return this;
-  }
-}
diff --git a/okhttp/src/test/java/com/squareup/okhttp/RecordingReceiver.java b/okhttp/src/test/java/com/squareup/okhttp/RecordingReceiver.java
deleted file mode 100644
index ee0db124a9..0000000000
--- a/okhttp/src/test/java/com/squareup/okhttp/RecordingReceiver.java
+++ /dev/null
@@ -1,62 +0,0 @@
-/*
- * Copyright (C) 2013 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.squareup.okhttp;
-
-import java.io.IOException;
-import java.util.ArrayList;
-import java.util.List;
-import java.util.concurrent.TimeUnit;
-
-/**
- * Records received HTTP responses so they can be later retrieved by tests.
- */
-public class RecordingReceiver implements Response.Receiver {
-  public static final long TIMEOUT_MILLIS = TimeUnit.SECONDS.toMillis(10);
-
-  private final List<RecordedResponse> responses = new ArrayList<RecordedResponse>();
-
-  @Override public synchronized void onFailure(Failure failure) {
-    responses.add(new RecordedResponse(failure.request(), null, null, failure));
-    notifyAll();
-  }
-
-  @Override public synchronized void onResponse(Response response) throws IOException {
-    responses.add(new RecordedResponse(
-        response.request(), response, response.body().string(), null));
-    notifyAll();
-  }
-
-  /**
-   * Returns the recorded response triggered by {@code request}. Throws if the
-   * response isn't enqueued before the timeout.
-   */
-  public synchronized RecordedResponse await(Request request) throws Exception {
-    long timeoutMillis = TimeUnit.NANOSECONDS.toMillis(System.nanoTime()) + TIMEOUT_MILLIS;
-    while (true) {
-      for (RecordedResponse recordedResponse : responses) {
-        if (recordedResponse.request == request) {
-          return recordedResponse;
-        }
-      }
-
-      long nowMillis = TimeUnit.NANOSECONDS.toMillis(System.nanoTime());
-      if (nowMillis >= timeoutMillis) break;
-      wait(timeoutMillis - nowMillis);
-    }
-
-    throw new AssertionError("Timed out waiting for response to " + request);
-  }
-}
diff --git a/okhttp/src/test/java/com/squareup/okhttp/RequestTest.java b/okhttp/src/test/java/com/squareup/okhttp/RequestTest.java
deleted file mode 100644
index ed43e194a7..0000000000
--- a/okhttp/src/test/java/com/squareup/okhttp/RequestTest.java
+++ /dev/null
@@ -1,90 +0,0 @@
-/*
- * Copyright (C) 2013 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.squareup.okhttp;
-
-import com.squareup.okhttp.internal.Util;
-import java.io.ByteArrayOutputStream;
-import java.io.File;
-import java.io.FileWriter;
-import java.io.IOException;
-import org.junit.Test;
-
-import static org.junit.Assert.assertEquals;
-
-public final class RequestTest {
-  @Test public void string() throws Exception {
-    MediaType contentType = MediaType.parse("text/plain; charset=utf-8");
-    Request.Body body = Request.Body.create(contentType, "abc".getBytes(Util.UTF_8));
-    assertEquals(contentType, body.contentType());
-    assertEquals(3, body.contentLength());
-    assertEquals("616263", bodyToHex(body));
-    assertEquals("Retransmit body", "616263", bodyToHex(body));
-  }
-
-  @Test public void stringWithDefaultCharsetAdded() throws Exception {
-    MediaType contentType = MediaType.parse("text/plain");
-    Request.Body body = Request.Body.create(contentType, "\u0800");
-    assertEquals(MediaType.parse("text/plain; charset=utf-8"), body.contentType());
-    assertEquals(3, body.contentLength());
-    assertEquals("e0a080", bodyToHex(body));
-  }
-
-  @Test public void stringWithNonDefaultCharsetSpecified() throws Exception {
-    MediaType contentType = MediaType.parse("text/plain; charset=utf-16be");
-    Request.Body body = Request.Body.create(contentType, "\u0800");
-    assertEquals(contentType, body.contentType());
-    assertEquals(2, body.contentLength());
-    assertEquals("0800", bodyToHex(body));
-  }
-
-  @Test public void byteArray() throws Exception {
-    MediaType contentType = MediaType.parse("text/plain");
-    Request.Body body = Request.Body.create(contentType, "abc".getBytes(Util.UTF_8));
-    assertEquals(contentType, body.contentType());
-    assertEquals(3, body.contentLength());
-    assertEquals("616263", bodyToHex(body));
-    assertEquals("Retransmit body", "616263", bodyToHex(body));
-  }
-
-  @Test public void file() throws Exception {
-    File file = File.createTempFile("RequestTest", "tmp");
-    FileWriter writer = new FileWriter(file);
-    writer.write("abc");
-    writer.close();
-
-    MediaType contentType = MediaType.parse("text/plain");
-    Request.Body body = Request.Body.create(contentType, file);
-    assertEquals(contentType, body.contentType());
-    assertEquals(3, body.contentLength());
-    assertEquals("616263", bodyToHex(body));
-    assertEquals("Retransmit body", "616263", bodyToHex(body));
-  }
-
-  private String bodyToHex(Request.Body body) throws IOException {
-    ByteArrayOutputStream bytes = new ByteArrayOutputStream();
-    body.writeTo(bytes);
-    return bytesToHex(bytes.toByteArray());
-  }
-
-  private String bytesToHex(byte[] bytes) {
-    StringBuilder hex = new StringBuilder();
-    for (byte b : bytes) {
-      if ((b & 0xff) < 0x10) hex.append('0');
-      hex.append(Integer.toHexString(b & 0xff));
-    }
-    return hex.toString();
-  }
-}
diff --git a/okhttp/src/test/java/com/squareup/okhttp/internal/FaultRecoveringOutputStreamTest.java b/okhttp/src/test/java/com/squareup/okhttp/internal/FaultRecoveringOutputStreamTest.java
deleted file mode 100644
index e933c177c3..0000000000
--- a/okhttp/src/test/java/com/squareup/okhttp/internal/FaultRecoveringOutputStreamTest.java
+++ /dev/null
@@ -1,224 +0,0 @@
-/*
- * Copyright (C) 2013 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.squareup.okhttp.internal;
-
-import java.io.IOException;
-import java.io.OutputStream;
-import java.util.ArrayDeque;
-import java.util.ArrayList;
-import java.util.Arrays;
-import java.util.Deque;
-import java.util.List;
-import org.junit.Test;
-
-import static com.squareup.okhttp.internal.Util.UTF_8;
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertFalse;
-import static org.junit.Assert.assertTrue;
-import static org.junit.Assert.fail;
-
-public final class FaultRecoveringOutputStreamTest {
-  @Test public void noRecoveryWithoutReplacement() throws Exception {
-    FaultingOutputStream faulting = new FaultingOutputStream();
-    TestFaultRecoveringOutputStream recovering = new TestFaultRecoveringOutputStream(10, faulting);
-
-    recovering.write('a');
-    faulting.nextFault = "system on fire";
-    try {
-      recovering.write('b');
-      fail();
-    } catch (IOException e) {
-      assertEquals(Arrays.asList("system on fire"), recovering.exceptionMessages);
-      assertEquals("ab", faulting.receivedUtf8);
-      assertFalse(faulting.closed);
-    }
-  }
-
-  @Test public void successfulRecoveryOnWriteFault() throws Exception {
-    FaultingOutputStream faulting1 = new FaultingOutputStream();
-    FaultingOutputStream faulting2 = new FaultingOutputStream();
-    TestFaultRecoveringOutputStream recovering = new TestFaultRecoveringOutputStream(10, faulting1);
-    recovering.replacements.addLast(faulting2);
-
-    recovering.write('a');
-    assertEquals("a", faulting1.receivedUtf8);
-    assertEquals("", faulting2.receivedUtf8);
-    faulting1.nextFault = "system under water";
-    recovering.write('b');
-    assertEquals(Arrays.asList("system under water"), recovering.exceptionMessages);
-    assertEquals("ab", faulting1.receivedUtf8);
-    assertEquals("ab", faulting2.receivedUtf8);
-    assertTrue(faulting1.closed);
-    assertFalse(faulting2.closed);
-
-    // Confirm that new data goes to the new stream.
-    recovering.write('c');
-    assertEquals("ab", faulting1.receivedUtf8);
-    assertEquals("abc", faulting2.receivedUtf8);
-  }
-
-  @Test public void successfulRecoveryOnFlushFault() throws Exception {
-    FaultingOutputStream faulting1 = new FaultingOutputStream();
-    FaultingOutputStream faulting2 = new FaultingOutputStream();
-    TestFaultRecoveringOutputStream recovering = new TestFaultRecoveringOutputStream(10, faulting1);
-    recovering.replacements.addLast(faulting2);
-
-    recovering.write('a');
-    faulting1.nextFault = "bad weather";
-    recovering.flush();
-    assertEquals(Arrays.asList("bad weather"), recovering.exceptionMessages);
-    assertEquals("a", faulting1.receivedUtf8);
-    assertEquals("a", faulting2.receivedUtf8);
-    assertTrue(faulting1.closed);
-    assertFalse(faulting2.closed);
-    assertEquals("a", faulting2.flushedUtf8);
-
-    // Confirm that new data goes to the new stream.
-    recovering.write('b');
-    assertEquals("a", faulting1.receivedUtf8);
-    assertEquals("ab", faulting2.receivedUtf8);
-    assertEquals("a", faulting2.flushedUtf8);
-  }
-
-  @Test public void successfulRecoveryOnCloseFault() throws Exception {
-    FaultingOutputStream faulting1 = new FaultingOutputStream();
-    FaultingOutputStream faulting2 = new FaultingOutputStream();
-    TestFaultRecoveringOutputStream recovering = new TestFaultRecoveringOutputStream(10, faulting1);
-    recovering.replacements.addLast(faulting2);
-
-    recovering.write('a');
-    faulting1.nextFault = "termites";
-    recovering.close();
-    assertEquals(Arrays.asList("termites"), recovering.exceptionMessages);
-    assertEquals("a", faulting1.receivedUtf8);
-    assertEquals("a", faulting2.receivedUtf8);
-    assertTrue(faulting1.closed);
-    assertTrue(faulting2.closed);
-  }
-
-  @Test public void replacementStreamFaultsImmediately() throws Exception {
-    FaultingOutputStream faulting1 = new FaultingOutputStream();
-    FaultingOutputStream faulting2 = new FaultingOutputStream();
-    FaultingOutputStream faulting3 = new FaultingOutputStream();
-    TestFaultRecoveringOutputStream recovering = new TestFaultRecoveringOutputStream(10, faulting1);
-    recovering.replacements.addLast(faulting2);
-    recovering.replacements.addLast(faulting3);
-
-    recovering.write('a');
-    assertEquals("a", faulting1.receivedUtf8);
-    assertEquals("", faulting2.receivedUtf8);
-    assertEquals("", faulting3.receivedUtf8);
-    faulting1.nextFault = "offline";
-    faulting2.nextFault = "slow";
-    recovering.write('b');
-    assertEquals(Arrays.asList("offline", "slow"), recovering.exceptionMessages);
-    assertEquals("ab", faulting1.receivedUtf8);
-    assertEquals("a", faulting2.receivedUtf8);
-    assertEquals("ab", faulting3.receivedUtf8);
-    assertTrue(faulting1.closed);
-    assertTrue(faulting2.closed);
-    assertFalse(faulting3.closed);
-
-    // Confirm that new data goes to the new stream.
-    recovering.write('c');
-    assertEquals("ab", faulting1.receivedUtf8);
-    assertEquals("a", faulting2.receivedUtf8);
-    assertEquals("abc", faulting3.receivedUtf8);
-  }
-
-  @Test public void recoverWithFullBuffer() throws Exception {
-    FaultingOutputStream faulting1 = new FaultingOutputStream();
-    FaultingOutputStream faulting2 = new FaultingOutputStream();
-    TestFaultRecoveringOutputStream recovering = new TestFaultRecoveringOutputStream(10, faulting1);
-    recovering.replacements.addLast(faulting2);
-
-    recovering.write("abcdefghij".getBytes(UTF_8)); // 10 bytes.
-    faulting1.nextFault = "unlucky";
-    recovering.write('k');
-    assertEquals("abcdefghijk", faulting1.receivedUtf8);
-    assertEquals("abcdefghijk", faulting2.receivedUtf8);
-    assertEquals(Arrays.asList("unlucky"), recovering.exceptionMessages);
-    assertTrue(faulting1.closed);
-    assertFalse(faulting2.closed);
-
-    // Confirm that new data goes to the new stream.
-    recovering.write('l');
-    assertEquals("abcdefghijk", faulting1.receivedUtf8);
-    assertEquals("abcdefghijkl", faulting2.receivedUtf8);
-  }
-
-  @Test public void noRecoveryWithOverfullBuffer() throws Exception {
-    FaultingOutputStream faulting1 = new FaultingOutputStream();
-    FaultingOutputStream faulting2 = new FaultingOutputStream();
-    TestFaultRecoveringOutputStream recovering = new TestFaultRecoveringOutputStream(10, faulting1);
-    recovering.replacements.addLast(faulting2);
-
-    recovering.write("abcdefghijk".getBytes(UTF_8)); // 11 bytes.
-    faulting1.nextFault = "out to lunch";
-    try {
-      recovering.write('l');
-      fail();
-    } catch (IOException expected) {
-      assertEquals("out to lunch", expected.getMessage());
-    }
-
-    assertEquals(Arrays.<String>asList(), recovering.exceptionMessages);
-    assertEquals("abcdefghijkl", faulting1.receivedUtf8);
-    assertEquals("", faulting2.receivedUtf8);
-    assertFalse(faulting1.closed);
-    assertFalse(faulting2.closed);
-  }
-
-  static class FaultingOutputStream extends OutputStream {
-    String receivedUtf8 = "";
-    String flushedUtf8 = null;
-    String nextFault;
-    boolean closed;
-
-    @Override public final void write(int data) throws IOException {
-      write(new byte[] { (byte) data });
-    }
-
-    @Override public void write(byte[] buffer, int offset, int count) throws IOException {
-      receivedUtf8 += new String(buffer, offset, count, UTF_8);
-      if (nextFault != null) throw new IOException(nextFault);
-    }
-
-    @Override public void flush() throws IOException {
-      flushedUtf8 = receivedUtf8;
-      if (nextFault != null) throw new IOException(nextFault);
-    }
-
-    @Override public void close() throws IOException {
-      closed = true;
-      if (nextFault != null) throw new IOException(nextFault);
-    }
-  }
-
-  static class TestFaultRecoveringOutputStream extends FaultRecoveringOutputStream {
-    final List<String> exceptionMessages = new ArrayList<String>();
-    final Deque<OutputStream> replacements = new ArrayDeque<OutputStream>();
-
-    TestFaultRecoveringOutputStream(int maxReplayBufferLength, OutputStream first) {
-      super(maxReplayBufferLength, first);
-    }
-
-    @Override protected OutputStream replacementStream(IOException e) {
-      exceptionMessages.add(e.getMessage());
-      return replacements.poll();
-    }
-  }
-}
diff --git a/okhttp/src/test/java/com/squareup/okhttp/internal/RecordingAuthenticator.java b/okhttp/src/test/java/com/squareup/okhttp/internal/RecordingAuthenticator.java
deleted file mode 100644
index 9eff91919a..0000000000
--- a/okhttp/src/test/java/com/squareup/okhttp/internal/RecordingAuthenticator.java
+++ /dev/null
@@ -1,58 +0,0 @@
-/*
- * Copyright (C) 2013 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.squareup.okhttp.internal;
-
-import java.net.Authenticator;
-import java.net.PasswordAuthentication;
-import java.util.ArrayList;
-import java.util.List;
-
-public final class RecordingAuthenticator extends Authenticator {
-  /** base64("username:password") */
-  public static final String BASE_64_CREDENTIALS = "dXNlcm5hbWU6cGFzc3dvcmQ=";
-
-  public final List<String> calls = new ArrayList<String>();
-  public final PasswordAuthentication authentication;
-
-  public RecordingAuthenticator(PasswordAuthentication authentication) {
-    this.authentication = authentication;
-  }
-
-  public RecordingAuthenticator() {
-    this(new PasswordAuthentication("username", "password".toCharArray()));
-  }
-
-  @Override protected PasswordAuthentication getPasswordAuthentication() {
-    this.calls
-        .add("host="
-            + getRequestingHost()
-            + " port="
-            + getRequestingPort()
-            + " site="
-            + getRequestingSite()
-            + " url="
-            + getRequestingURL()
-            + " type="
-            + getRequestorType()
-            + " prompt="
-            + getRequestingPrompt()
-            + " protocol="
-            + getRequestingProtocol()
-            + " scheme="
-            + getRequestingScheme());
-    return authentication;
-  }
-}
diff --git a/okhttp/src/test/java/com/squareup/okhttp/internal/RecordingOkAuthenticator.java b/okhttp/src/test/java/com/squareup/okhttp/internal/RecordingOkAuthenticator.java
deleted file mode 100644
index 636acbde11..0000000000
--- a/okhttp/src/test/java/com/squareup/okhttp/internal/RecordingOkAuthenticator.java
+++ /dev/null
@@ -1,50 +0,0 @@
-/*
- * Copyright (C) 2013 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.squareup.okhttp.internal;
-
-import com.squareup.okhttp.OkAuthenticator;
-import java.io.IOException;
-import java.net.Proxy;
-import java.net.URL;
-import java.util.ArrayList;
-import java.util.List;
-
-public final class RecordingOkAuthenticator implements OkAuthenticator {
-  public final List<String> calls = new ArrayList<String>();
-  public final Credential credential;
-
-  public RecordingOkAuthenticator(Credential credential) {
-    this.credential = credential;
-  }
-
-  @Override public Credential authenticate(Proxy proxy, URL url, List<Challenge> challenges)
-      throws IOException {
-    calls.add("authenticate"
-        + " proxy=" + proxy.type()
-        + " url=" + url
-        + " challenges=" + challenges);
-    return credential;
-  }
-
-  @Override public Credential authenticateProxy(Proxy proxy, URL url, List<Challenge> challenges)
-      throws IOException {
-    calls.add("authenticateProxy"
-        + " proxy=" + proxy.type()
-        + " url=" + url
-        + " challenges=" + challenges);
-    return credential;
-  }
-}
diff --git a/okhttp/src/test/java/com/squareup/okhttp/internal/StrictLineReaderTest.java b/okhttp/src/test/java/com/squareup/okhttp/internal/StrictLineReaderTest.java
deleted file mode 100644
index 252f6ac85c..0000000000
--- a/okhttp/src/test/java/com/squareup/okhttp/internal/StrictLineReaderTest.java
+++ /dev/null
@@ -1,75 +0,0 @@
-/*
- * Copyright (C) 2012 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.squareup.okhttp.internal;
-
-import java.io.ByteArrayInputStream;
-import java.io.EOFException;
-import java.io.InputStream;
-import org.junit.Test;
-
-import static com.squareup.okhttp.internal.Util.US_ASCII;
-import static org.junit.Assert.fail;
-
-public final class StrictLineReaderTest {
-  @Test public void lineReaderConsistencyWithReadAsciiLine() throws Exception {
-    // Testing with LineReader buffer capacity 32 to check some corner cases.
-    StrictLineReader lineReader = new StrictLineReader(createTestInputStream(), 32, US_ASCII);
-    InputStream refStream = createTestInputStream();
-    while (true) {
-      try {
-        String refLine = Util.readAsciiLine(refStream);
-        try {
-          String line = lineReader.readLine();
-          if (!refLine.equals(line)) {
-            fail("line (\"" + line + "\") differs from expected (\"" + refLine + "\").");
-          }
-        } catch (EOFException eof) {
-          fail("line reader threw EOFException too early.");
-        }
-      } catch (EOFException refEof) {
-        try {
-          lineReader.readLine();
-          fail("line reader didn't throw the expected EOFException.");
-        } catch (EOFException eof) {
-          // OK
-          break;
-        }
-      }
-    }
-    refStream.close();
-    lineReader.close();
-  }
-
-  private InputStream createTestInputStream() {
-    return new ByteArrayInputStream((
-                /* each source lines below should represent 32 bytes, until the next comment */
-        "12 byte line\n18 byte line......\n" +
-            "pad\nline spanning two 32-byte bu" +
-            "ffers\npad......................\n" +
-            "pad\nline spanning three 32-byte " +
-            "buffers and ending with LF at th" +
-            "e end of a 32 byte buffer......\n" +
-            "pad\nLine ending with CRLF split" +
-            " at the end of a 32-byte buffer\r" +
-            "\npad...........................\n" +
-                        /* end of 32-byte lines */
-            "line ending with CRLF\r\n" +
-            "this is a long line with embedded CR \r ending with CRLF and having more than " +
-            "32 characters\r\n" +
-            "unterminated line - should be dropped").getBytes());
-  }
-}
diff --git a/okhttp/src/test/java/com/squareup/okhttp/internal/http/ExternalSpdyExample.java b/okhttp/src/test/java/com/squareup/okhttp/internal/http/ExternalSpdyExample.java
deleted file mode 100644
index 11d7239050..0000000000
--- a/okhttp/src/test/java/com/squareup/okhttp/internal/http/ExternalSpdyExample.java
+++ /dev/null
@@ -1,49 +0,0 @@
-/*
- * Copyright (C) 2009 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.squareup.okhttp.internal.http;
-
-import com.squareup.okhttp.OkHttpClient;
-import java.io.BufferedReader;
-import java.io.InputStreamReader;
-import java.net.URL;
-import javax.net.ssl.HostnameVerifier;
-import javax.net.ssl.HttpsURLConnection;
-import javax.net.ssl.SSLSession;
-
-public final class ExternalSpdyExample {
-  public static void main(String[] args) throws Exception {
-    URL url = new URL("https://www.google.ca/");
-    HttpsURLConnection connection = (HttpsURLConnection) new OkHttpClient().open(url);
-
-    connection.setHostnameVerifier(new HostnameVerifier() {
-      @Override public boolean verify(String s, SSLSession sslSession) {
-        System.out.println("VERIFYING " + s);
-        return true;
-      }
-    });
-
-    int responseCode = connection.getResponseCode();
-    System.out.println(responseCode);
-
-    BufferedReader reader =
-        new BufferedReader(new InputStreamReader(connection.getInputStream(), "UTF-8"));
-    String line;
-    while ((line = reader.readLine()) != null) {
-      System.out.println(line);
-    }
-  }
-}
diff --git a/okhttp/src/test/java/com/squareup/okhttp/internal/http/HttpOverSpdyTest.java b/okhttp/src/test/java/com/squareup/okhttp/internal/http/HttpOverSpdyTest.java
deleted file mode 100644
index ca240f1311..0000000000
--- a/okhttp/src/test/java/com/squareup/okhttp/internal/http/HttpOverSpdyTest.java
+++ /dev/null
@@ -1,296 +0,0 @@
-/*
- * Copyright (C) 2013 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.squareup.okhttp.internal.http;
-
-import com.squareup.okhttp.HttpResponseCache;
-import com.squareup.okhttp.OkHttpClient;
-import com.squareup.okhttp.internal.RecordingAuthenticator;
-import com.squareup.okhttp.internal.SslContextBuilder;
-import com.squareup.okhttp.internal.Util;
-import com.squareup.okhttp.mockwebserver.MockResponse;
-import com.squareup.okhttp.mockwebserver.MockWebServer;
-import com.squareup.okhttp.mockwebserver.RecordedRequest;
-import java.io.ByteArrayOutputStream;
-import java.io.File;
-import java.io.IOException;
-import java.io.InputStream;
-import java.io.OutputStream;
-import java.net.Authenticator;
-import java.net.CookieManager;
-import java.net.HttpURLConnection;
-import java.net.InetAddress;
-import java.net.URL;
-import java.net.URLConnection;
-import java.net.UnknownHostException;
-import java.security.GeneralSecurityException;
-import java.util.Arrays;
-import java.util.Collection;
-import java.util.Collections;
-import java.util.List;
-import java.util.Map;
-import java.util.UUID;
-import java.util.zip.GZIPOutputStream;
-import javax.net.ssl.HostnameVerifier;
-import javax.net.ssl.SSLContext;
-import javax.net.ssl.SSLSession;
-import org.junit.After;
-import org.junit.Before;
-import org.junit.Test;
-
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertTrue;
-import static org.junit.Assert.fail;
-
-/** Test how SPDY interacts with HTTP features. */
-public final class HttpOverSpdyTest {
-  private static final HostnameVerifier NULL_HOSTNAME_VERIFIER = new HostnameVerifier() {
-    public boolean verify(String hostname, SSLSession session) {
-      return true;
-    }
-  };
-
-  private static final SSLContext sslContext;
-  static {
-    try {
-      sslContext = new SslContextBuilder(InetAddress.getLocalHost().getHostName()).build();
-    } catch (GeneralSecurityException e) {
-      throw new RuntimeException(e);
-    } catch (UnknownHostException e) {
-      throw new RuntimeException(e);
-    }
-  }
-  private final MockWebServer server = new MockWebServer();
-  private final String hostName = server.getHostName();
-  private final OkHttpClient client = new OkHttpClient();
-  private HttpResponseCache cache;
-
-  @Before public void setUp() throws Exception {
-    server.useHttps(sslContext.getSocketFactory(), false);
-    client.setSslSocketFactory(sslContext.getSocketFactory());
-    client.setHostnameVerifier(NULL_HOSTNAME_VERIFIER);
-    String systemTmpDir = System.getProperty("java.io.tmpdir");
-    File cacheDir = new File(systemTmpDir, "HttpCache-" + UUID.randomUUID());
-    cache = new HttpResponseCache(cacheDir, Integer.MAX_VALUE);
-  }
-
-  @After public void tearDown() throws Exception {
-    Authenticator.setDefault(null);
-    server.shutdown();
-  }
-
-  @Test public void get() throws Exception {
-    MockResponse response = new MockResponse().setBody("ABCDE").setStatus("HTTP/1.1 200 Sweet");
-    server.enqueue(response);
-    server.play();
-
-    HttpURLConnection connection = client.open(server.getUrl("/foo"));
-    assertContent("ABCDE", connection, Integer.MAX_VALUE);
-    assertEquals(200, connection.getResponseCode());
-    assertEquals("Sweet", connection.getResponseMessage());
-
-    RecordedRequest request = server.takeRequest();
-    assertEquals("GET /foo HTTP/1.1", request.getRequestLine());
-    assertContains(request.getHeaders(), ":scheme: https");
-    assertContains(request.getHeaders(), ":host: " + hostName + ":" + server.getPort());
-  }
-
-  @Test public void emptyResponse() throws IOException {
-    server.enqueue(new MockResponse());
-    server.play();
-
-    HttpURLConnection connection = client.open(server.getUrl("/foo"));
-    assertEquals(-1, connection.getInputStream().read());
-  }
-
-  @Test public void post() throws Exception {
-    MockResponse response = new MockResponse().setBody("ABCDE");
-    server.enqueue(response);
-    server.play();
-
-    HttpURLConnection connection = client.open(server.getUrl("/foo"));
-    connection.setDoOutput(true);
-    connection.getOutputStream().write("FGHIJ".getBytes(Util.UTF_8));
-    assertContent("ABCDE", connection, Integer.MAX_VALUE);
-
-    RecordedRequest request = server.takeRequest();
-    assertEquals("POST /foo HTTP/1.1", request.getRequestLine());
-    assertEquals("FGHIJ", request.getUtf8Body());
-  }
-
-  @Test public void spdyConnectionReuse() throws Exception {
-    server.enqueue(new MockResponse().setBody("ABCDEF"));
-    server.enqueue(new MockResponse().setBody("GHIJKL"));
-    server.play();
-
-    HttpURLConnection connection1 = client.open(server.getUrl("/r1"));
-    HttpURLConnection connection2 = client.open(server.getUrl("/r2"));
-    assertEquals("ABC", readAscii(connection1.getInputStream(), 3));
-    assertEquals("GHI", readAscii(connection2.getInputStream(), 3));
-    assertEquals("DEF", readAscii(connection1.getInputStream(), 3));
-    assertEquals("JKL", readAscii(connection2.getInputStream(), 3));
-    assertEquals(0, server.takeRequest().getSequenceNumber());
-    assertEquals(0, server.takeRequest().getSequenceNumber());
-  }
-
-  @Test public void gzippedResponseBody() throws Exception {
-    server.enqueue(new MockResponse().addHeader("Content-Encoding: gzip")
-        .setBody(gzip("ABCABCABC".getBytes(Util.UTF_8))));
-    server.play();
-    assertContent("ABCABCABC", client.open(server.getUrl("/r1")), Integer.MAX_VALUE);
-  }
-
-  @Test public void authenticate() throws Exception {
-    server.enqueue(new MockResponse().setResponseCode(HttpURLConnection.HTTP_UNAUTHORIZED)
-        .addHeader("www-authenticate: Basic realm=\"protected area\"")
-        .setBody("Please authenticate."));
-    server.enqueue(new MockResponse().setBody("Successful auth!"));
-    server.play();
-
-    Authenticator.setDefault(new RecordingAuthenticator());
-    HttpURLConnection connection = client.open(server.getUrl("/"));
-    assertEquals("Successful auth!", readAscii(connection.getInputStream(), Integer.MAX_VALUE));
-
-    RecordedRequest denied = server.takeRequest();
-    assertContainsNoneMatching(denied.getHeaders(), "authorization: Basic .*");
-    RecordedRequest accepted = server.takeRequest();
-    assertEquals("GET / HTTP/1.1", accepted.getRequestLine());
-    assertContains(accepted.getHeaders(),
-        "authorization: Basic " + RecordingAuthenticator.BASE_64_CREDENTIALS);
-  }
-
-  @Test public void redirect() throws Exception {
-    server.enqueue(new MockResponse().setResponseCode(HttpURLConnection.HTTP_MOVED_TEMP)
-        .addHeader("Location: /foo")
-        .setBody("This page has moved!"));
-    server.enqueue(new MockResponse().setBody("This is the new location!"));
-    server.play();
-
-    HttpURLConnection connection = client.open(server.getUrl("/"));
-    assertContent("This is the new location!", connection, Integer.MAX_VALUE);
-
-    RecordedRequest request1 = server.takeRequest();
-    assertEquals("/", request1.getPath());
-    RecordedRequest request2 = server.takeRequest();
-    assertEquals("/foo", request2.getPath());
-  }
-
-  @Test public void readAfterLastByte() throws Exception {
-    server.enqueue(new MockResponse().setBody("ABC"));
-    server.play();
-
-    HttpURLConnection connection = client.open(server.getUrl("/"));
-    InputStream in = connection.getInputStream();
-    assertEquals("ABC", readAscii(in, 3));
-    assertEquals(-1, in.read());
-    assertEquals(-1, in.read());
-  }
-
-  @Test public void responsesAreCached() throws IOException {
-    client.setResponseCache(cache);
-
-    server.enqueue(new MockResponse().addHeader("cache-control: max-age=60").setBody("A"));
-    server.play();
-
-    assertContent("A", client.open(server.getUrl("/")), Integer.MAX_VALUE);
-    assertEquals(1, cache.getRequestCount());
-    assertEquals(1, cache.getNetworkCount());
-    assertEquals(0, cache.getHitCount());
-    assertContent("A", client.open(server.getUrl("/")), Integer.MAX_VALUE);
-    assertContent("A", client.open(server.getUrl("/")), Integer.MAX_VALUE);
-    assertEquals(3, cache.getRequestCount());
-    assertEquals(1, cache.getNetworkCount());
-    assertEquals(2, cache.getHitCount());
-  }
-
-  @Test public void conditionalCache() throws IOException {
-    client.setResponseCache(cache);
-
-    server.enqueue(new MockResponse().addHeader("ETag: v1").setBody("A"));
-    server.enqueue(new MockResponse().setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
-    server.play();
-
-    assertContent("A", client.open(server.getUrl("/")), Integer.MAX_VALUE);
-    assertEquals(1, cache.getRequestCount());
-    assertEquals(1, cache.getNetworkCount());
-    assertEquals(0, cache.getHitCount());
-    assertContent("A", client.open(server.getUrl("/")), Integer.MAX_VALUE);
-    assertEquals(2, cache.getRequestCount());
-    assertEquals(2, cache.getNetworkCount());
-    assertEquals(1, cache.getHitCount());
-  }
-
-  @Test public void acceptAndTransmitCookies() throws Exception {
-    CookieManager cookieManager = new CookieManager();
-    client.setCookieHandler(cookieManager);
-    server.enqueue(
-        new MockResponse().addHeader("set-cookie: c=oreo; domain=" + server.getCookieDomain())
-            .setBody("A"));
-    server.enqueue(new MockResponse().setBody("B"));
-    server.play();
-
-    URL url = server.getUrl("/");
-    assertContent("A", client.open(url), Integer.MAX_VALUE);
-    Map<String, List<String>> requestHeaders = Collections.emptyMap();
-    assertEquals(Collections.singletonMap("Cookie", Arrays.asList("c=oreo")),
-        cookieManager.get(url.toURI(), requestHeaders));
-
-    assertContent("B", client.open(url), Integer.MAX_VALUE);
-    RecordedRequest requestA = server.takeRequest();
-    assertContainsNoneMatching(requestA.getHeaders(), "Cookie.*");
-    RecordedRequest requestB = server.takeRequest();
-    assertContains(requestB.getHeaders(), "cookie: c=oreo");
-  }
-
-  private <T> void assertContains(Collection<T> collection, T value) {
-    assertTrue(collection.toString(), collection.contains(value));
-  }
-
-  private void assertContent(String expected, URLConnection connection, int limit)
-      throws IOException {
-    connection.connect();
-    assertEquals(expected, readAscii(connection.getInputStream(), limit));
-    ((HttpURLConnection) connection).disconnect();
-  }
-
-  private void assertContainsNoneMatching(List<String> headers, String pattern) {
-    for (String header : headers) {
-      if (header.matches(pattern)) {
-        fail("Header " + header + " matches " + pattern);
-      }
-    }
-  }
-
-  private String readAscii(InputStream in, int count) throws IOException {
-    StringBuilder result = new StringBuilder();
-    for (int i = 0; i < count; i++) {
-      int value = in.read();
-      if (value == -1) {
-        in.close();
-        break;
-      }
-      result.append((char) value);
-    }
-    return result.toString();
-  }
-
-  public byte[] gzip(byte[] bytes) throws IOException {
-    ByteArrayOutputStream bytesOut = new ByteArrayOutputStream();
-    OutputStream gzippedOut = new GZIPOutputStream(bytesOut);
-    gzippedOut.write(bytes);
-    gzippedOut.close();
-    return bytesOut.toByteArray();
-  }
-}
diff --git a/okhttp/src/test/java/com/squareup/okhttp/internal/http/HttpResponseCacheTest.java b/okhttp/src/test/java/com/squareup/okhttp/internal/http/HttpResponseCacheTest.java
deleted file mode 100644
index 8a2e900a26..0000000000
--- a/okhttp/src/test/java/com/squareup/okhttp/internal/http/HttpResponseCacheTest.java
+++ /dev/null
@@ -1,1938 +0,0 @@
-/*
- * Copyright (C) 2011 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.squareup.okhttp.internal.http;
-
-import com.squareup.okhttp.HttpResponseCache;
-import com.squareup.okhttp.OkHttpClient;
-import com.squareup.okhttp.ResponseSource;
-import com.squareup.okhttp.internal.SslContextBuilder;
-import com.squareup.okhttp.mockwebserver.MockResponse;
-import com.squareup.okhttp.mockwebserver.MockWebServer;
-import com.squareup.okhttp.mockwebserver.RecordedRequest;
-import java.io.BufferedReader;
-import java.io.ByteArrayOutputStream;
-import java.io.File;
-import java.io.FileNotFoundException;
-import java.io.IOException;
-import java.io.InputStream;
-import java.io.InputStreamReader;
-import java.io.OutputStream;
-import java.net.CacheRequest;
-import java.net.CacheResponse;
-import java.net.CookieHandler;
-import java.net.CookieManager;
-import java.net.HttpCookie;
-import java.net.HttpURLConnection;
-import java.net.InetAddress;
-import java.net.ResponseCache;
-import java.net.SecureCacheResponse;
-import java.net.URI;
-import java.net.URISyntaxException;
-import java.net.URL;
-import java.net.URLConnection;
-import java.net.UnknownHostException;
-import java.security.GeneralSecurityException;
-import java.security.Principal;
-import java.security.cert.Certificate;
-import java.text.DateFormat;
-import java.text.SimpleDateFormat;
-import java.util.ArrayList;
-import java.util.Arrays;
-import java.util.Collections;
-import java.util.Date;
-import java.util.Iterator;
-import java.util.List;
-import java.util.Locale;
-import java.util.Map;
-import java.util.TimeZone;
-import java.util.UUID;
-import java.util.concurrent.TimeUnit;
-import java.util.concurrent.atomic.AtomicInteger;
-import java.util.concurrent.atomic.AtomicReference;
-import java.util.zip.GZIPOutputStream;
-import javax.net.ssl.HostnameVerifier;
-import javax.net.ssl.HttpsURLConnection;
-import javax.net.ssl.SSLContext;
-import javax.net.ssl.SSLSession;
-import org.junit.After;
-import org.junit.Before;
-import org.junit.Test;
-
-import static com.squareup.okhttp.mockwebserver.SocketPolicy.DISCONNECT_AT_END;
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertFalse;
-import static org.junit.Assert.assertNotNull;
-import static org.junit.Assert.assertNull;
-import static org.junit.Assert.assertTrue;
-import static org.junit.Assert.fail;
-
-/** Android's HttpResponseCacheTest. */
-public final class HttpResponseCacheTest {
-  private static final HostnameVerifier NULL_HOSTNAME_VERIFIER = new HostnameVerifier() {
-    @Override public boolean verify(String s, SSLSession sslSession) {
-      return true;
-    }
-  };
-  private final OkHttpClient client = new OkHttpClient();
-  private MockWebServer server = new MockWebServer();
-  private MockWebServer server2 = new MockWebServer();
-  private HttpResponseCache cache;
-  private final CookieManager cookieManager = new CookieManager();
-
-  private static final SSLContext sslContext;
-  static {
-    try {
-      sslContext = new SslContextBuilder(InetAddress.getLocalHost().getHostName()).build();
-    } catch (GeneralSecurityException e) {
-      throw new RuntimeException(e);
-    } catch (UnknownHostException e) {
-      throw new RuntimeException(e);
-    }
-  }
-
-  @Before public void setUp() throws Exception {
-    String tmp = System.getProperty("java.io.tmpdir");
-    File cacheDir = new File(tmp, "HttpCache-" + UUID.randomUUID());
-    cache = new HttpResponseCache(cacheDir, Integer.MAX_VALUE);
-    ResponseCache.setDefault(cache);
-    CookieHandler.setDefault(cookieManager);
-    server.setNpnEnabled(false);
-  }
-
-  @After public void tearDown() throws Exception {
-    server.shutdown();
-    server2.shutdown();
-    ResponseCache.setDefault(null);
-    cache.delete();
-    CookieHandler.setDefault(null);
-  }
-
-  private HttpURLConnection openConnection(URL url) {
-    return client.open(url);
-  }
-
-  /**
-   * Test that response caching is consistent with the RI and the spec.
-   * http://www.w3.org/Protocols/rfc2616/rfc2616-sec13.html#sec13.4
-   */
-  @Test public void responseCachingByResponseCode() throws Exception {
-    // Test each documented HTTP/1.1 code, plus the first unused value in each range.
-    // http://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html
-
-    // We can't test 100 because it's not really a response.
-    // assertCached(false, 100);
-    assertCached(false, 101);
-    assertCached(false, 102);
-    assertCached(true, 200);
-    assertCached(false, 201);
-    assertCached(false, 202);
-    assertCached(true, 203);
-    assertCached(false, 204);
-    assertCached(false, 205);
-    assertCached(false, 206); // we don't cache partial responses
-    assertCached(false, 207);
-    assertCached(true, 300);
-    assertCached(true, 301);
-    for (int i = 302; i <= 308; ++i) {
-      assertCached(false, i);
-    }
-    for (int i = 400; i <= 406; ++i) {
-      assertCached(false, i);
-    }
-    // (See test_responseCaching_407.)
-    assertCached(false, 408);
-    assertCached(false, 409);
-    // (See test_responseCaching_410.)
-    for (int i = 411; i <= 418; ++i) {
-      assertCached(false, i);
-    }
-    for (int i = 500; i <= 506; ++i) {
-      assertCached(false, i);
-    }
-  }
-
-  /**
-   * Response code 407 should only come from proxy servers. Android's client
-   * throws if it is sent by an origin server.
-   */
-  @Test public void originServerSends407() throws Exception {
-    server.enqueue(new MockResponse().setResponseCode(407));
-    server.play();
-
-    URL url = server.getUrl("/");
-    HttpURLConnection conn = openConnection(url);
-    try {
-      conn.getResponseCode();
-      fail();
-    } catch (IOException expected) {
-    }
-  }
-
-  @Test public void responseCaching_410() throws Exception {
-    // the HTTP spec permits caching 410s, but the RI doesn't.
-    assertCached(true, 410);
-  }
-
-  private void assertCached(boolean shouldPut, int responseCode) throws Exception {
-    server = new MockWebServer();
-    MockResponse response =
-        new MockResponse().addHeader("Last-Modified: " + formatDate(-1, TimeUnit.HOURS))
-            .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS))
-            .setResponseCode(responseCode)
-            .setBody("ABCDE")
-            .addHeader("WWW-Authenticate: challenge");
-    if (responseCode == HttpURLConnection.HTTP_PROXY_AUTH) {
-      response.addHeader("Proxy-Authenticate: Basic realm=\"protected area\"");
-    } else if (responseCode == HttpURLConnection.HTTP_UNAUTHORIZED) {
-      response.addHeader("WWW-Authenticate: Basic realm=\"protected area\"");
-    }
-    server.enqueue(response);
-    server.play();
-
-    URL url = server.getUrl("/");
-    HttpURLConnection conn = openConnection(url);
-    assertEquals(responseCode, conn.getResponseCode());
-
-    // exhaust the content stream
-    readAscii(conn);
-
-    CacheResponse cached =
-        cache.get(url.toURI(), "GET", Collections.<String, List<String>>emptyMap());
-    if (shouldPut) {
-      assertNotNull(Integer.toString(responseCode), cached);
-      cached.getBody().close();
-    } else {
-      assertNull(Integer.toString(responseCode), cached);
-    }
-    server.shutdown(); // tearDown() isn't sufficient; this test starts multiple servers
-  }
-
-  /**
-   * Test that we can interrogate the response when the cache is being
-   * populated. http://code.google.com/p/android/issues/detail?id=7787
-   */
-  @Test public void responseCacheCallbackApis() throws Exception {
-    final String body = "ABCDE";
-    final AtomicInteger cacheCount = new AtomicInteger();
-
-    server.enqueue(
-        new MockResponse().setStatus("HTTP/1.1 200 Fantastic").addHeader("fgh: ijk").setBody(body));
-    server.play();
-
-    ResponseCache.setDefault(new ResponseCache() {
-      @Override public CacheResponse get(URI uri, String requestMethod,
-          Map<String, List<String>> requestHeaders) throws IOException {
-        return null;
-      }
-
-      @Override public CacheRequest put(URI uri, URLConnection conn) throws IOException {
-        HttpURLConnection httpConnection = (HttpURLConnection) conn;
-        try {
-          httpConnection.getRequestProperties();
-          fail();
-        } catch (IllegalStateException expected) {
-        }
-        try {
-          httpConnection.addRequestProperty("K", "V");
-          fail();
-        } catch (IllegalStateException expected) {
-        }
-        assertEquals("HTTP/1.1 200 Fantastic", httpConnection.getHeaderField(null));
-        assertEquals(Arrays.asList("HTTP/1.1 200 Fantastic"),
-            httpConnection.getHeaderFields().get(null));
-        assertEquals(200, httpConnection.getResponseCode());
-        assertEquals("Fantastic", httpConnection.getResponseMessage());
-        assertEquals(body.length(), httpConnection.getContentLength());
-        assertEquals("ijk", httpConnection.getHeaderField("fgh"));
-        try {
-          httpConnection.getInputStream(); // the RI doesn't forbid this, but it should
-          fail();
-        } catch (IOException expected) {
-        }
-        cacheCount.incrementAndGet();
-        return null;
-      }
-    });
-
-    URL url = server.getUrl("/");
-    HttpURLConnection connection = openConnection(url);
-    assertEquals(body, readAscii(connection));
-    assertEquals(1, cacheCount.get());
-  }
-
-  @Test public void responseCachingAndInputStreamSkipWithFixedLength() throws IOException {
-    testResponseCaching(TransferKind.FIXED_LENGTH);
-  }
-
-  @Test public void responseCachingAndInputStreamSkipWithChunkedEncoding() throws IOException {
-    testResponseCaching(TransferKind.CHUNKED);
-  }
-
-  @Test public void responseCachingAndInputStreamSkipWithNoLengthHeaders() throws IOException {
-    testResponseCaching(TransferKind.END_OF_STREAM);
-  }
-
-  /**
-   * HttpURLConnection.getInputStream().skip(long) causes ResponseCache corruption
-   * http://code.google.com/p/android/issues/detail?id=8175
-   */
-  private void testResponseCaching(TransferKind transferKind) throws IOException {
-    MockResponse response =
-        new MockResponse().addHeader("Last-Modified: " + formatDate(-1, TimeUnit.HOURS))
-            .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS))
-            .setStatus("HTTP/1.1 200 Fantastic");
-    transferKind.setBody(response, "I love puppies but hate spiders", 1);
-    server.enqueue(response);
-    server.play();
-
-    // Make sure that calling skip() doesn't omit bytes from the cache.
-    HttpURLConnection urlConnection = openConnection(server.getUrl("/"));
-    InputStream in = urlConnection.getInputStream();
-    assertEquals("I love ", readAscii(urlConnection, "I love ".length()));
-    reliableSkip(in, "puppies but hate ".length());
-    assertEquals("spiders", readAscii(urlConnection, "spiders".length()));
-    assertEquals(-1, in.read());
-    in.close();
-    assertEquals(1, cache.getWriteSuccessCount());
-    assertEquals(0, cache.getWriteAbortCount());
-
-    urlConnection = openConnection(server.getUrl("/")); // cached!
-    in = urlConnection.getInputStream();
-    assertEquals("I love puppies but hate spiders",
-        readAscii(urlConnection, "I love puppies but hate spiders".length()));
-    assertEquals(200, urlConnection.getResponseCode());
-    assertEquals("Fantastic", urlConnection.getResponseMessage());
-
-    assertEquals(-1, in.read());
-    in.close();
-    assertEquals(1, cache.getWriteSuccessCount());
-    assertEquals(0, cache.getWriteAbortCount());
-    assertEquals(2, cache.getRequestCount());
-    assertEquals(1, cache.getHitCount());
-  }
-
-  @Test public void secureResponseCaching() throws IOException {
-    server.useHttps(sslContext.getSocketFactory(), false);
-    server.enqueue(new MockResponse().addHeader("Last-Modified: " + formatDate(-1, TimeUnit.HOURS))
-        .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS))
-        .setBody("ABC"));
-    server.play();
-
-    HttpsURLConnection connection = (HttpsURLConnection) client.open(server.getUrl("/"));
-    connection.setSSLSocketFactory(sslContext.getSocketFactory());
-    connection.setHostnameVerifier(NULL_HOSTNAME_VERIFIER);
-    assertEquals("ABC", readAscii(connection));
-
-    // OpenJDK 6 fails on this line, complaining that the connection isn't open yet
-    String suite = connection.getCipherSuite();
-    List<Certificate> localCerts = toListOrNull(connection.getLocalCertificates());
-    List<Certificate> serverCerts = toListOrNull(connection.getServerCertificates());
-    Principal peerPrincipal = connection.getPeerPrincipal();
-    Principal localPrincipal = connection.getLocalPrincipal();
-
-    connection = (HttpsURLConnection) client.open(server.getUrl("/")); // cached!
-    connection.setSSLSocketFactory(sslContext.getSocketFactory());
-    connection.setHostnameVerifier(NULL_HOSTNAME_VERIFIER);
-    assertEquals("ABC", readAscii(connection));
-
-    assertEquals(2, cache.getRequestCount());
-    assertEquals(1, cache.getNetworkCount());
-    assertEquals(1, cache.getHitCount());
-
-    assertEquals(suite, connection.getCipherSuite());
-    assertEquals(localCerts, toListOrNull(connection.getLocalCertificates()));
-    assertEquals(serverCerts, toListOrNull(connection.getServerCertificates()));
-    assertEquals(peerPrincipal, connection.getPeerPrincipal());
-    assertEquals(localPrincipal, connection.getLocalPrincipal());
-  }
-
-  @Test public void cacheReturnsInsecureResponseForSecureRequest() throws IOException {
-    server.useHttps(sslContext.getSocketFactory(), false);
-    server.enqueue(new MockResponse().setBody("ABC"));
-    server.enqueue(new MockResponse().setBody("DEF"));
-    server.play();
-
-    ResponseCache.setDefault(new InsecureResponseCache());
-
-    HttpsURLConnection connection1 = (HttpsURLConnection) client.open(server.getUrl("/"));
-    connection1.setSSLSocketFactory(sslContext.getSocketFactory());
-    connection1.setHostnameVerifier(NULL_HOSTNAME_VERIFIER);
-    assertEquals("ABC", readAscii(connection1));
-
-    // Not cached!
-    HttpsURLConnection connection2 = (HttpsURLConnection) client.open(server.getUrl("/"));
-    connection2.setSSLSocketFactory(sslContext.getSocketFactory());
-    connection2.setHostnameVerifier(NULL_HOSTNAME_VERIFIER);
-    assertEquals("DEF", readAscii(connection2));
-  }
-
-  @Test public void responseCachingAndRedirects() throws Exception {
-    server.enqueue(new MockResponse().addHeader("Last-Modified: " + formatDate(-1, TimeUnit.HOURS))
-        .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS))
-        .setResponseCode(HttpURLConnection.HTTP_MOVED_PERM)
-        .addHeader("Location: /foo"));
-    server.enqueue(new MockResponse().addHeader("Last-Modified: " + formatDate(-1, TimeUnit.HOURS))
-        .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS))
-        .setBody("ABC"));
-    server.enqueue(new MockResponse().setBody("DEF"));
-    server.play();
-
-    HttpURLConnection connection = openConnection(server.getUrl("/"));
-    assertEquals("ABC", readAscii(connection));
-
-    connection = openConnection(server.getUrl("/")); // cached!
-    assertEquals("ABC", readAscii(connection));
-
-    assertEquals(4, cache.getRequestCount()); // 2 requests + 2 redirects
-    assertEquals(2, cache.getNetworkCount());
-    assertEquals(2, cache.getHitCount());
-  }
-
-  @Test public void redirectToCachedResult() throws Exception {
-    server.enqueue(new MockResponse().addHeader("Cache-Control: max-age=60").setBody("ABC"));
-    server.enqueue(new MockResponse().setResponseCode(HttpURLConnection.HTTP_MOVED_PERM)
-        .addHeader("Location: /foo"));
-    server.enqueue(new MockResponse().setBody("DEF"));
-    server.play();
-
-    assertEquals("ABC", readAscii(openConnection(server.getUrl("/foo"))));
-    RecordedRequest request1 = server.takeRequest();
-    assertEquals("GET /foo HTTP/1.1", request1.getRequestLine());
-    assertEquals(0, request1.getSequenceNumber());
-
-    assertEquals("ABC", readAscii(openConnection(server.getUrl("/bar"))));
-    RecordedRequest request2 = server.takeRequest();
-    assertEquals("GET /bar HTTP/1.1", request2.getRequestLine());
-    assertEquals(1, request2.getSequenceNumber());
-
-    // an unrelated request should reuse the pooled connection
-    assertEquals("DEF", readAscii(openConnection(server.getUrl("/baz"))));
-    RecordedRequest request3 = server.takeRequest();
-    assertEquals("GET /baz HTTP/1.1", request3.getRequestLine());
-    assertEquals(2, request3.getSequenceNumber());
-  }
-
-  @Test public void secureResponseCachingAndRedirects() throws IOException {
-    server.useHttps(sslContext.getSocketFactory(), false);
-    server.enqueue(new MockResponse().addHeader("Last-Modified: " + formatDate(-1, TimeUnit.HOURS))
-        .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS))
-        .setResponseCode(HttpURLConnection.HTTP_MOVED_PERM)
-        .addHeader("Location: /foo"));
-    server.enqueue(new MockResponse().addHeader("Last-Modified: " + formatDate(-1, TimeUnit.HOURS))
-        .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS))
-        .setBody("ABC"));
-    server.enqueue(new MockResponse().setBody("DEF"));
-    server.play();
-
-    client.setSslSocketFactory(sslContext.getSocketFactory());
-    client.setHostnameVerifier(NULL_HOSTNAME_VERIFIER);
-
-    HttpsURLConnection connection1 = (HttpsURLConnection) client.open(server.getUrl("/"));
-    assertEquals("ABC", readAscii(connection1));
-
-    // Cached!
-    HttpsURLConnection connection2 = (HttpsURLConnection) client.open(server.getUrl("/"));
-    assertEquals("ABC", readAscii(connection2));
-
-    assertEquals(4, cache.getRequestCount()); // 2 direct + 2 redirect = 4
-    assertEquals(2, cache.getHitCount());
-  }
-
-  /**
-   * We've had bugs where caching and cross-protocol redirects yield class
-   * cast exceptions internal to the cache because we incorrectly assumed that
-   * HttpsURLConnection was always HTTPS and HttpURLConnection was always HTTP;
-   * in practice redirects mean that each can do either.
-   *
-   * https://github.com/square/okhttp/issues/214
-   */
-  @Test public void secureResponseCachingAndProtocolRedirects() throws IOException {
-    server2.useHttps(sslContext.getSocketFactory(), false);
-    server2.enqueue(new MockResponse().addHeader("Last-Modified: " + formatDate(-1, TimeUnit.HOURS))
-        .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS))
-        .setBody("ABC"));
-    server2.enqueue(new MockResponse().setBody("DEF"));
-    server2.play();
-
-    server.enqueue(new MockResponse().addHeader("Last-Modified: " + formatDate(-1, TimeUnit.HOURS))
-        .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS))
-        .setResponseCode(HttpURLConnection.HTTP_MOVED_PERM)
-        .addHeader("Location: " + server2.getUrl("/")));
-    server.play();
-
-    client.setSslSocketFactory(sslContext.getSocketFactory());
-    client.setHostnameVerifier(NULL_HOSTNAME_VERIFIER);
-
-    HttpURLConnection connection1 = client.open(server.getUrl("/"));
-    assertEquals("ABC", readAscii(connection1));
-
-    // Cached!
-    HttpURLConnection connection2 = client.open(server.getUrl("/"));
-    assertEquals("ABC", readAscii(connection2));
-
-    assertEquals(4, cache.getRequestCount()); // 2 direct + 2 redirect = 4
-    assertEquals(2, cache.getHitCount());
-  }
-
-  @Test public void responseCacheRequestHeaders() throws IOException, URISyntaxException {
-    server.enqueue(new MockResponse().setBody("ABC"));
-    server.play();
-
-    final AtomicReference<Map<String, List<String>>> requestHeadersRef =
-        new AtomicReference<Map<String, List<String>>>();
-    ResponseCache.setDefault(new ResponseCache() {
-      @Override public CacheResponse get(URI uri, String requestMethod,
-          Map<String, List<String>> requestHeaders) throws IOException {
-        requestHeadersRef.set(requestHeaders);
-        return null;
-      }
-      @Override public CacheRequest put(URI uri, URLConnection conn) throws IOException {
-        return null;
-      }
-    });
-
-    URL url = server.getUrl("/");
-    URLConnection urlConnection = openConnection(url);
-    urlConnection.addRequestProperty("A", "android");
-    readAscii(urlConnection);
-    assertEquals(Arrays.asList("android"), requestHeadersRef.get().get("A"));
-  }
-
-  @Test public void serverDisconnectsPrematurelyWithContentLengthHeader() throws IOException {
-    testServerPrematureDisconnect(TransferKind.FIXED_LENGTH);
-  }
-
-  @Test public void serverDisconnectsPrematurelyWithChunkedEncoding() throws IOException {
-    testServerPrematureDisconnect(TransferKind.CHUNKED);
-  }
-
-  @Test public void serverDisconnectsPrematurelyWithNoLengthHeaders() throws IOException {
-    // Intentionally empty. This case doesn't make sense because there's no
-    // such thing as a premature disconnect when the disconnect itself
-    // indicates the end of the data stream.
-  }
-
-  private void testServerPrematureDisconnect(TransferKind transferKind) throws IOException {
-    MockResponse response = new MockResponse();
-    transferKind.setBody(response, "ABCDE\nFGHIJKLMNOPQRSTUVWXYZ", 16);
-    server.enqueue(truncateViolently(response, 16));
-    server.enqueue(new MockResponse().setBody("Request #2"));
-    server.play();
-
-    BufferedReader reader = new BufferedReader(
-        new InputStreamReader(openConnection(server.getUrl("/")).getInputStream()));
-    assertEquals("ABCDE", reader.readLine());
-    try {
-      reader.readLine();
-      fail("This implementation silently ignored a truncated HTTP body.");
-    } catch (IOException expected) {
-    } finally {
-      reader.close();
-    }
-
-    assertEquals(1, cache.getWriteAbortCount());
-    assertEquals(0, cache.getWriteSuccessCount());
-    URLConnection connection = openConnection(server.getUrl("/"));
-    assertEquals("Request #2", readAscii(connection));
-    assertEquals(1, cache.getWriteAbortCount());
-    assertEquals(1, cache.getWriteSuccessCount());
-  }
-
-  @Test public void clientPrematureDisconnectWithContentLengthHeader() throws IOException {
-    testClientPrematureDisconnect(TransferKind.FIXED_LENGTH);
-  }
-
-  @Test public void clientPrematureDisconnectWithChunkedEncoding() throws IOException {
-    testClientPrematureDisconnect(TransferKind.CHUNKED);
-  }
-
-  @Test public void clientPrematureDisconnectWithNoLengthHeaders() throws IOException {
-    testClientPrematureDisconnect(TransferKind.END_OF_STREAM);
-  }
-
-  private void testClientPrematureDisconnect(TransferKind transferKind) throws IOException {
-    // Setting a low transfer speed ensures that stream discarding will time out.
-    MockResponse response = new MockResponse().setBytesPerSecond(6);
-    transferKind.setBody(response, "ABCDE\nFGHIJKLMNOPQRSTUVWXYZ", 1024);
-    server.enqueue(response);
-    server.enqueue(new MockResponse().setBody("Request #2"));
-    server.play();
-
-    URLConnection connection = openConnection(server.getUrl("/"));
-    InputStream in = connection.getInputStream();
-    assertEquals("ABCDE", readAscii(connection, 5));
-    in.close();
-    try {
-      in.read();
-      fail("Expected an IOException because the stream is closed.");
-    } catch (IOException expected) {
-    }
-
-    assertEquals(1, cache.getWriteAbortCount());
-    assertEquals(0, cache.getWriteSuccessCount());
-    connection = openConnection(server.getUrl("/"));
-    assertEquals("Request #2", readAscii(connection));
-    assertEquals(1, cache.getWriteAbortCount());
-    assertEquals(1, cache.getWriteSuccessCount());
-  }
-
-  @Test public void defaultExpirationDateFullyCachedForLessThan24Hours() throws Exception {
-    //      last modified: 105 seconds ago
-    //             served:   5 seconds ago
-    //   default lifetime: (105 - 5) / 10 = 10 seconds
-    //            expires:  10 seconds from served date = 5 seconds from now
-    server.enqueue(
-        new MockResponse().addHeader("Last-Modified: " + formatDate(-105, TimeUnit.SECONDS))
-            .addHeader("Date: " + formatDate(-5, TimeUnit.SECONDS))
-            .setBody("A"));
-    server.play();
-
-    URL url = server.getUrl("/");
-    assertEquals("A", readAscii(openConnection(url)));
-    URLConnection connection = openConnection(url);
-    assertEquals("A", readAscii(connection));
-    assertNull(connection.getHeaderField("Warning"));
-  }
-
-  @Test public void defaultExpirationDateConditionallyCached() throws Exception {
-    //      last modified: 115 seconds ago
-    //             served:  15 seconds ago
-    //   default lifetime: (115 - 15) / 10 = 10 seconds
-    //            expires:  10 seconds from served date = 5 seconds ago
-    String lastModifiedDate = formatDate(-115, TimeUnit.SECONDS);
-    RecordedRequest conditionalRequest = assertConditionallyCached(
-        new MockResponse().addHeader("Last-Modified: " + lastModifiedDate)
-            .addHeader("Date: " + formatDate(-15, TimeUnit.SECONDS)));
-    List<String> headers = conditionalRequest.getHeaders();
-    assertTrue(headers.contains("If-Modified-Since: " + lastModifiedDate));
-  }
-
-  @Test public void defaultExpirationDateFullyCachedForMoreThan24Hours() throws Exception {
-    //      last modified: 105 days ago
-    //             served:   5 days ago
-    //   default lifetime: (105 - 5) / 10 = 10 days
-    //            expires:  10 days from served date = 5 days from now
-    server.enqueue(new MockResponse().addHeader("Last-Modified: " + formatDate(-105, TimeUnit.DAYS))
-        .addHeader("Date: " + formatDate(-5, TimeUnit.DAYS))
-        .setBody("A"));
-    server.play();
-
-    assertEquals("A", readAscii(openConnection(server.getUrl("/"))));
-    URLConnection connection = openConnection(server.getUrl("/"));
-    assertEquals("A", readAscii(connection));
-    assertEquals("113 HttpURLConnection \"Heuristic expiration\"",
-        connection.getHeaderField("Warning"));
-  }
-
-  @Test public void noDefaultExpirationForUrlsWithQueryString() throws Exception {
-    server.enqueue(
-        new MockResponse().addHeader("Last-Modified: " + formatDate(-105, TimeUnit.SECONDS))
-            .addHeader("Date: " + formatDate(-5, TimeUnit.SECONDS))
-            .setBody("A"));
-    server.enqueue(new MockResponse().setBody("B"));
-    server.play();
-
-    URL url = server.getUrl("/?foo=bar");
-    assertEquals("A", readAscii(openConnection(url)));
-    assertEquals("B", readAscii(openConnection(url)));
-  }
-
-  @Test public void expirationDateInThePastWithLastModifiedHeader() throws Exception {
-    String lastModifiedDate = formatDate(-2, TimeUnit.HOURS);
-    RecordedRequest conditionalRequest = assertConditionallyCached(
-        new MockResponse().addHeader("Last-Modified: " + lastModifiedDate)
-            .addHeader("Expires: " + formatDate(-1, TimeUnit.HOURS)));
-    List<String> headers = conditionalRequest.getHeaders();
-    assertTrue(headers.contains("If-Modified-Since: " + lastModifiedDate));
-  }
-
-  @Test public void expirationDateInThePastWithNoLastModifiedHeader() throws Exception {
-    assertNotCached(new MockResponse().addHeader("Expires: " + formatDate(-1, TimeUnit.HOURS)));
-  }
-
-  @Test public void expirationDateInTheFuture() throws Exception {
-    assertFullyCached(new MockResponse().addHeader("Expires: " + formatDate(1, TimeUnit.HOURS)));
-  }
-
-  @Test public void maxAgePreferredWithMaxAgeAndExpires() throws Exception {
-    assertFullyCached(new MockResponse().addHeader("Date: " + formatDate(0, TimeUnit.HOURS))
-        .addHeader("Expires: " + formatDate(-1, TimeUnit.HOURS))
-        .addHeader("Cache-Control: max-age=60"));
-  }
-
-  @Test public void maxAgeInThePastWithDateAndLastModifiedHeaders() throws Exception {
-    String lastModifiedDate = formatDate(-2, TimeUnit.HOURS);
-    RecordedRequest conditionalRequest = assertConditionallyCached(
-        new MockResponse().addHeader("Date: " + formatDate(-120, TimeUnit.SECONDS))
-            .addHeader("Last-Modified: " + lastModifiedDate)
-            .addHeader("Cache-Control: max-age=60"));
-    List<String> headers = conditionalRequest.getHeaders();
-    assertTrue(headers.contains("If-Modified-Since: " + lastModifiedDate));
-  }
-
-  @Test public void maxAgeInThePastWithDateHeaderButNoLastModifiedHeader() throws Exception {
-    // Chrome interprets max-age relative to the local clock. Both our cache
-    // and Firefox both use the earlier of the local and server's clock.
-    assertNotCached(new MockResponse().addHeader("Date: " + formatDate(-120, TimeUnit.SECONDS))
-        .addHeader("Cache-Control: max-age=60"));
-  }
-
-  @Test public void maxAgeInTheFutureWithDateHeader() throws Exception {
-    assertFullyCached(new MockResponse().addHeader("Date: " + formatDate(0, TimeUnit.HOURS))
-        .addHeader("Cache-Control: max-age=60"));
-  }
-
-  @Test public void maxAgeInTheFutureWithNoDateHeader() throws Exception {
-    assertFullyCached(new MockResponse().addHeader("Cache-Control: max-age=60"));
-  }
-
-  @Test public void maxAgeWithLastModifiedButNoServedDate() throws Exception {
-    assertFullyCached(
-        new MockResponse().addHeader("Last-Modified: " + formatDate(-120, TimeUnit.SECONDS))
-            .addHeader("Cache-Control: max-age=60"));
-  }
-
-  @Test public void maxAgeInTheFutureWithDateAndLastModifiedHeaders() throws Exception {
-    assertFullyCached(
-        new MockResponse().addHeader("Last-Modified: " + formatDate(-120, TimeUnit.SECONDS))
-            .addHeader("Date: " + formatDate(0, TimeUnit.SECONDS))
-            .addHeader("Cache-Control: max-age=60"));
-  }
-
-  @Test public void maxAgePreferredOverLowerSharedMaxAge() throws Exception {
-    assertFullyCached(new MockResponse().addHeader("Date: " + formatDate(-2, TimeUnit.MINUTES))
-        .addHeader("Cache-Control: s-maxage=60")
-        .addHeader("Cache-Control: max-age=180"));
-  }
-
-  @Test public void maxAgePreferredOverHigherMaxAge() throws Exception {
-    assertNotCached(new MockResponse().addHeader("Date: " + formatDate(-2, TimeUnit.MINUTES))
-        .addHeader("Cache-Control: s-maxage=180")
-        .addHeader("Cache-Control: max-age=60"));
-  }
-
-  @Test public void requestMethodOptionsIsNotCached() throws Exception {
-    testRequestMethod("OPTIONS", false);
-  }
-
-  @Test public void requestMethodGetIsCached() throws Exception {
-    testRequestMethod("GET", true);
-  }
-
-  @Test public void requestMethodHeadIsNotCached() throws Exception {
-    // We could support this but choose not to for implementation simplicity
-    testRequestMethod("HEAD", false);
-  }
-
-  @Test public void requestMethodPostIsNotCached() throws Exception {
-    // We could support this but choose not to for implementation simplicity
-    testRequestMethod("POST", false);
-  }
-
-  @Test public void requestMethodPutIsNotCached() throws Exception {
-    testRequestMethod("PUT", false);
-  }
-
-  @Test public void requestMethodDeleteIsNotCached() throws Exception {
-    testRequestMethod("DELETE", false);
-  }
-
-  @Test public void requestMethodTraceIsNotCached() throws Exception {
-    testRequestMethod("TRACE", false);
-  }
-
-  private void testRequestMethod(String requestMethod, boolean expectCached) throws Exception {
-    // 1. seed the cache (potentially)
-    // 2. expect a cache hit or miss
-    server.enqueue(new MockResponse().addHeader("Expires: " + formatDate(1, TimeUnit.HOURS))
-        .addHeader("X-Response-ID: 1"));
-    server.enqueue(new MockResponse().addHeader("X-Response-ID: 2"));
-    server.play();
-
-    URL url = server.getUrl("/");
-
-    HttpURLConnection request1 = openConnection(url);
-    request1.setRequestMethod(requestMethod);
-    addRequestBodyIfNecessary(requestMethod, request1);
-    assertEquals("1", request1.getHeaderField("X-Response-ID"));
-
-    URLConnection request2 = openConnection(url);
-    if (expectCached) {
-      assertEquals("1", request1.getHeaderField("X-Response-ID"));
-    } else {
-      assertEquals("2", request2.getHeaderField("X-Response-ID"));
-    }
-  }
-
-  @Test public void postInvalidatesCache() throws Exception {
-    testMethodInvalidates("POST");
-  }
-
-  @Test public void putInvalidatesCache() throws Exception {
-    testMethodInvalidates("PUT");
-  }
-
-  @Test public void deleteMethodInvalidatesCache() throws Exception {
-    testMethodInvalidates("DELETE");
-  }
-
-  private void testMethodInvalidates(String requestMethod) throws Exception {
-    // 1. seed the cache
-    // 2. invalidate it
-    // 3. expect a cache miss
-    server.enqueue(
-        new MockResponse().setBody("A").addHeader("Expires: " + formatDate(1, TimeUnit.HOURS)));
-    server.enqueue(new MockResponse().setBody("B"));
-    server.enqueue(new MockResponse().setBody("C"));
-    server.play();
-
-    URL url = server.getUrl("/");
-
-    assertEquals("A", readAscii(openConnection(url)));
-
-    HttpURLConnection invalidate = openConnection(url);
-    invalidate.setRequestMethod(requestMethod);
-    addRequestBodyIfNecessary(requestMethod, invalidate);
-    assertEquals("B", readAscii(invalidate));
-
-    assertEquals("C", readAscii(openConnection(url)));
-  }
-
-  @Test public void postInvalidatesCacheWithUncacheableResponse() throws Exception {
-    // 1. seed the cache
-    // 2. invalidate it with uncacheable response
-    // 3. expect a cache miss
-    server.enqueue(
-        new MockResponse().setBody("A").addHeader("Expires: " + formatDate(1, TimeUnit.HOURS)));
-    server.enqueue(new MockResponse().setBody("B").setResponseCode(500));
-    server.enqueue(new MockResponse().setBody("C"));
-    server.play();
-
-    URL url = server.getUrl("/");
-
-    assertEquals("A", readAscii(openConnection(url)));
-
-    HttpURLConnection invalidate = openConnection(url);
-    invalidate.setRequestMethod("POST");
-    addRequestBodyIfNecessary("POST", invalidate);
-    assertEquals("B", readAscii(invalidate));
-
-    assertEquals("C", readAscii(openConnection(url)));
-  }
-
-  @Test public void etag() throws Exception {
-    RecordedRequest conditionalRequest =
-        assertConditionallyCached(new MockResponse().addHeader("ETag: v1"));
-    assertTrue(conditionalRequest.getHeaders().contains("If-None-Match: v1"));
-  }
-
-  @Test public void etagAndExpirationDateInThePast() throws Exception {
-    String lastModifiedDate = formatDate(-2, TimeUnit.HOURS);
-    RecordedRequest conditionalRequest = assertConditionallyCached(
-        new MockResponse().addHeader("ETag: v1")
-            .addHeader("Last-Modified: " + lastModifiedDate)
-            .addHeader("Expires: " + formatDate(-1, TimeUnit.HOURS)));
-    List<String> headers = conditionalRequest.getHeaders();
-    assertTrue(headers.contains("If-None-Match: v1"));
-    assertTrue(headers.contains("If-Modified-Since: " + lastModifiedDate));
-  }
-
-  @Test public void etagAndExpirationDateInTheFuture() throws Exception {
-    assertFullyCached(new MockResponse().addHeader("ETag: v1")
-        .addHeader("Last-Modified: " + formatDate(-2, TimeUnit.HOURS))
-        .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS)));
-  }
-
-  @Test public void cacheControlNoCache() throws Exception {
-    assertNotCached(new MockResponse().addHeader("Cache-Control: no-cache"));
-  }
-
-  @Test public void cacheControlNoCacheAndExpirationDateInTheFuture() throws Exception {
-    String lastModifiedDate = formatDate(-2, TimeUnit.HOURS);
-    RecordedRequest conditionalRequest = assertConditionallyCached(
-        new MockResponse().addHeader("Last-Modified: " + lastModifiedDate)
-            .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS))
-            .addHeader("Cache-Control: no-cache"));
-    List<String> headers = conditionalRequest.getHeaders();
-    assertTrue(headers.contains("If-Modified-Since: " + lastModifiedDate));
-  }
-
-  @Test public void pragmaNoCache() throws Exception {
-    assertNotCached(new MockResponse().addHeader("Pragma: no-cache"));
-  }
-
-  @Test public void pragmaNoCacheAndExpirationDateInTheFuture() throws Exception {
-    String lastModifiedDate = formatDate(-2, TimeUnit.HOURS);
-    RecordedRequest conditionalRequest = assertConditionallyCached(
-        new MockResponse().addHeader("Last-Modified: " + lastModifiedDate)
-            .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS))
-            .addHeader("Pragma: no-cache"));
-    List<String> headers = conditionalRequest.getHeaders();
-    assertTrue(headers.contains("If-Modified-Since: " + lastModifiedDate));
-  }
-
-  @Test public void cacheControlNoStore() throws Exception {
-    assertNotCached(new MockResponse().addHeader("Cache-Control: no-store"));
-  }
-
-  @Test public void cacheControlNoStoreAndExpirationDateInTheFuture() throws Exception {
-    assertNotCached(new MockResponse().addHeader("Last-Modified: " + formatDate(-2, TimeUnit.HOURS))
-        .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS))
-        .addHeader("Cache-Control: no-store"));
-  }
-
-  @Test public void partialRangeResponsesDoNotCorruptCache() throws Exception {
-    // 1. request a range
-    // 2. request a full document, expecting a cache miss
-    server.enqueue(new MockResponse().setBody("AA")
-        .setResponseCode(HttpURLConnection.HTTP_PARTIAL)
-        .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS))
-        .addHeader("Content-Range: bytes 1000-1001/2000"));
-    server.enqueue(new MockResponse().setBody("BB"));
-    server.play();
-
-    URL url = server.getUrl("/");
-
-    URLConnection range = openConnection(url);
-    range.addRequestProperty("Range", "bytes=1000-1001");
-    assertEquals("AA", readAscii(range));
-
-    assertEquals("BB", readAscii(openConnection(url)));
-  }
-
-  @Test public void serverReturnsDocumentOlderThanCache() throws Exception {
-    server.enqueue(new MockResponse().setBody("A")
-        .addHeader("Last-Modified: " + formatDate(-2, TimeUnit.HOURS))
-        .addHeader("Expires: " + formatDate(-1, TimeUnit.HOURS)));
-    server.enqueue(new MockResponse().setBody("B")
-        .addHeader("Last-Modified: " + formatDate(-4, TimeUnit.HOURS)));
-    server.play();
-
-    URL url = server.getUrl("/");
-
-    assertEquals("A", readAscii(openConnection(url)));
-    assertEquals("A", readAscii(openConnection(url)));
-  }
-
-  @Test public void nonIdentityEncodingAndConditionalCache() throws Exception {
-    assertNonIdentityEncodingCached(
-        new MockResponse().addHeader("Last-Modified: " + formatDate(-2, TimeUnit.HOURS))
-            .addHeader("Expires: " + formatDate(-1, TimeUnit.HOURS)));
-  }
-
-  @Test public void nonIdentityEncodingAndFullCache() throws Exception {
-    assertNonIdentityEncodingCached(
-        new MockResponse().addHeader("Last-Modified: " + formatDate(-2, TimeUnit.HOURS))
-            .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS)));
-  }
-
-  private void assertNonIdentityEncodingCached(MockResponse response) throws Exception {
-    server.enqueue(
-        response.setBody(gzip("ABCABCABC".getBytes("UTF-8"))).addHeader("Content-Encoding: gzip"));
-    server.enqueue(new MockResponse().setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
-
-    server.play();
-    assertEquals("ABCABCABC", readAscii(openConnection(server.getUrl("/"))));
-    assertEquals("ABCABCABC", readAscii(openConnection(server.getUrl("/"))));
-  }
-
-  @Test public void notModifiedSpecifiesEncoding() throws Exception {
-    server.enqueue(new MockResponse()
-        .setBody(gzip("ABCABCABC".getBytes("UTF-8")))
-        .addHeader("Content-Encoding: gzip")
-        .addHeader("Last-Modified: " + formatDate(-2, TimeUnit.HOURS))
-        .addHeader("Expires: " + formatDate(-1, TimeUnit.HOURS)));
-    server.enqueue(new MockResponse()
-        .setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED)
-        .addHeader("Content-Encoding: gzip"));
-    server.enqueue(new MockResponse()
-        .setBody("DEFDEFDEF"));
-
-    server.play();
-    assertEquals("ABCABCABC", readAscii(openConnection(server.getUrl("/"))));
-    assertEquals("ABCABCABC", readAscii(openConnection(server.getUrl("/"))));
-    assertEquals("DEFDEFDEF", readAscii(openConnection(server.getUrl("/"))));
-  }
-
-  @Test public void expiresDateBeforeModifiedDate() throws Exception {
-    assertConditionallyCached(
-        new MockResponse().addHeader("Last-Modified: " + formatDate(-1, TimeUnit.HOURS))
-            .addHeader("Expires: " + formatDate(-2, TimeUnit.HOURS)));
-  }
-
-  @Test public void requestMaxAge() throws IOException {
-    server.enqueue(new MockResponse().setBody("A")
-        .addHeader("Last-Modified: " + formatDate(-2, TimeUnit.HOURS))
-        .addHeader("Date: " + formatDate(-1, TimeUnit.MINUTES))
-        .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS)));
-    server.enqueue(new MockResponse().setBody("B"));
-
-    server.play();
-    assertEquals("A", readAscii(openConnection(server.getUrl("/"))));
-
-    URLConnection connection = openConnection(server.getUrl("/"));
-    connection.addRequestProperty("Cache-Control", "max-age=30");
-    assertEquals("B", readAscii(connection));
-  }
-
-  @Test public void requestMinFresh() throws IOException {
-    server.enqueue(new MockResponse().setBody("A")
-        .addHeader("Cache-Control: max-age=60")
-        .addHeader("Date: " + formatDate(0, TimeUnit.MINUTES)));
-    server.enqueue(new MockResponse().setBody("B"));
-
-    server.play();
-    assertEquals("A", readAscii(openConnection(server.getUrl("/"))));
-
-    URLConnection connection = openConnection(server.getUrl("/"));
-    connection.addRequestProperty("Cache-Control", "min-fresh=120");
-    assertEquals("B", readAscii(connection));
-  }
-
-  @Test public void requestMaxStale() throws IOException {
-    server.enqueue(new MockResponse().setBody("A")
-        .addHeader("Cache-Control: max-age=120")
-        .addHeader("Date: " + formatDate(-4, TimeUnit.MINUTES)));
-    server.enqueue(new MockResponse().setBody("B"));
-
-    server.play();
-    assertEquals("A", readAscii(openConnection(server.getUrl("/"))));
-
-    URLConnection connection = openConnection(server.getUrl("/"));
-    connection.addRequestProperty("Cache-Control", "max-stale=180");
-    assertEquals("A", readAscii(connection));
-    assertEquals("110 HttpURLConnection \"Response is stale\"",
-        connection.getHeaderField("Warning"));
-  }
-
-  @Test public void requestMaxStaleNotHonoredWithMustRevalidate() throws IOException {
-    server.enqueue(new MockResponse().setBody("A")
-        .addHeader("Cache-Control: max-age=120, must-revalidate")
-        .addHeader("Date: " + formatDate(-4, TimeUnit.MINUTES)));
-    server.enqueue(new MockResponse().setBody("B"));
-
-    server.play();
-    assertEquals("A", readAscii(openConnection(server.getUrl("/"))));
-
-    URLConnection connection = openConnection(server.getUrl("/"));
-    connection.addRequestProperty("Cache-Control", "max-stale=180");
-    assertEquals("B", readAscii(connection));
-  }
-
-  @Test public void requestOnlyIfCachedWithNoResponseCached() throws IOException {
-    // (no responses enqueued)
-    server.play();
-
-    HttpURLConnection connection = openConnection(server.getUrl("/"));
-    connection.addRequestProperty("Cache-Control", "only-if-cached");
-    assertGatewayTimeout(connection);
-  }
-
-  @Test public void requestOnlyIfCachedWithFullResponseCached() throws IOException {
-    server.enqueue(new MockResponse().setBody("A")
-        .addHeader("Cache-Control: max-age=30")
-        .addHeader("Date: " + formatDate(0, TimeUnit.MINUTES)));
-    server.play();
-
-    assertEquals("A", readAscii(openConnection(server.getUrl("/"))));
-    URLConnection connection = openConnection(server.getUrl("/"));
-    connection.addRequestProperty("Cache-Control", "only-if-cached");
-    assertEquals("A", readAscii(connection));
-  }
-
-  @Test public void requestOnlyIfCachedWithConditionalResponseCached() throws IOException {
-    server.enqueue(new MockResponse().setBody("A")
-        .addHeader("Cache-Control: max-age=30")
-        .addHeader("Date: " + formatDate(-1, TimeUnit.MINUTES)));
-    server.play();
-
-    assertEquals("A", readAscii(openConnection(server.getUrl("/"))));
-    HttpURLConnection connection = openConnection(server.getUrl("/"));
-    connection.addRequestProperty("Cache-Control", "only-if-cached");
-    assertGatewayTimeout(connection);
-  }
-
-  @Test public void requestOnlyIfCachedWithUnhelpfulResponseCached() throws IOException {
-    server.enqueue(new MockResponse().setBody("A"));
-    server.play();
-
-    assertEquals("A", readAscii(openConnection(server.getUrl("/"))));
-    HttpURLConnection connection = openConnection(server.getUrl("/"));
-    connection.addRequestProperty("Cache-Control", "only-if-cached");
-    assertGatewayTimeout(connection);
-  }
-
-  @Test public void requestCacheControlNoCache() throws Exception {
-    server.enqueue(
-        new MockResponse().addHeader("Last-Modified: " + formatDate(-120, TimeUnit.SECONDS))
-            .addHeader("Date: " + formatDate(0, TimeUnit.SECONDS))
-            .addHeader("Cache-Control: max-age=60")
-            .setBody("A"));
-    server.enqueue(new MockResponse().setBody("B"));
-    server.play();
-
-    URL url = server.getUrl("/");
-    assertEquals("A", readAscii(openConnection(url)));
-    URLConnection connection = openConnection(url);
-    connection.setRequestProperty("Cache-Control", "no-cache");
-    assertEquals("B", readAscii(connection));
-  }
-
-  @Test public void requestPragmaNoCache() throws Exception {
-    server.enqueue(
-        new MockResponse().addHeader("Last-Modified: " + formatDate(-120, TimeUnit.SECONDS))
-            .addHeader("Date: " + formatDate(0, TimeUnit.SECONDS))
-            .addHeader("Cache-Control: max-age=60")
-            .setBody("A"));
-    server.enqueue(new MockResponse().setBody("B"));
-    server.play();
-
-    URL url = server.getUrl("/");
-    assertEquals("A", readAscii(openConnection(url)));
-    URLConnection connection = openConnection(url);
-    connection.setRequestProperty("Pragma", "no-cache");
-    assertEquals("B", readAscii(connection));
-  }
-
-  @Test public void clientSuppliedIfModifiedSinceWithCachedResult() throws Exception {
-    MockResponse response =
-        new MockResponse().addHeader("ETag: v3").addHeader("Cache-Control: max-age=0");
-    String ifModifiedSinceDate = formatDate(-24, TimeUnit.HOURS);
-    RecordedRequest request =
-        assertClientSuppliedCondition(response, "If-Modified-Since", ifModifiedSinceDate);
-    List<String> headers = request.getHeaders();
-    assertTrue(headers.contains("If-Modified-Since: " + ifModifiedSinceDate));
-    assertFalse(headers.contains("If-None-Match: v3"));
-  }
-
-  @Test public void clientSuppliedIfNoneMatchSinceWithCachedResult() throws Exception {
-    String lastModifiedDate = formatDate(-3, TimeUnit.MINUTES);
-    MockResponse response = new MockResponse().addHeader("Last-Modified: " + lastModifiedDate)
-        .addHeader("Date: " + formatDate(-2, TimeUnit.MINUTES))
-        .addHeader("Cache-Control: max-age=0");
-    RecordedRequest request = assertClientSuppliedCondition(response, "If-None-Match", "v1");
-    List<String> headers = request.getHeaders();
-    assertTrue(headers.contains("If-None-Match: v1"));
-    assertFalse(headers.contains("If-Modified-Since: " + lastModifiedDate));
-  }
-
-  private RecordedRequest assertClientSuppliedCondition(MockResponse seed, String conditionName,
-      String conditionValue) throws Exception {
-    server.enqueue(seed.setBody("A"));
-    server.enqueue(new MockResponse().setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
-    server.play();
-
-    URL url = server.getUrl("/");
-    assertEquals("A", readAscii(openConnection(url)));
-
-    HttpURLConnection connection = openConnection(url);
-    connection.addRequestProperty(conditionName, conditionValue);
-    assertEquals(HttpURLConnection.HTTP_NOT_MODIFIED, connection.getResponseCode());
-    assertEquals("", readAscii(connection));
-
-    server.takeRequest(); // seed
-    return server.takeRequest();
-  }
-
-  @Test public void setIfModifiedSince() throws Exception {
-    Date since = new Date();
-    server.enqueue(new MockResponse().setBody("A"));
-    server.play();
-
-    URL url = server.getUrl("/");
-    URLConnection connection = openConnection(url);
-    connection.setIfModifiedSince(since.getTime());
-    assertEquals("A", readAscii(connection));
-    RecordedRequest request = server.takeRequest();
-    assertTrue(request.getHeaders().contains("If-Modified-Since: " + formatDate(since)));
-  }
-
-  @Test public void clientSuppliedConditionWithoutCachedResult() throws Exception {
-    server.enqueue(new MockResponse().setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
-    server.play();
-
-    HttpURLConnection connection = openConnection(server.getUrl("/"));
-    String clientIfModifiedSince = formatDate(-24, TimeUnit.HOURS);
-    connection.addRequestProperty("If-Modified-Since", clientIfModifiedSince);
-    assertEquals(HttpURLConnection.HTTP_NOT_MODIFIED, connection.getResponseCode());
-    assertEquals("", readAscii(connection));
-  }
-
-  @Test public void authorizationRequestHeaderPreventsCaching() throws Exception {
-    server.enqueue(
-        new MockResponse().addHeader("Last-Modified: " + formatDate(-2, TimeUnit.MINUTES))
-            .addHeader("Cache-Control: max-age=60")
-            .setBody("A"));
-    server.enqueue(new MockResponse().setBody("B"));
-    server.play();
-
-    URL url = server.getUrl("/");
-    URLConnection connection = openConnection(url);
-    connection.addRequestProperty("Authorization", "password");
-    assertEquals("A", readAscii(connection));
-    assertEquals("B", readAscii(openConnection(url)));
-  }
-
-  @Test public void authorizationResponseCachedWithSMaxAge() throws Exception {
-    assertAuthorizationRequestFullyCached(
-        new MockResponse().addHeader("Cache-Control: s-maxage=60"));
-  }
-
-  @Test public void authorizationResponseCachedWithPublic() throws Exception {
-    assertAuthorizationRequestFullyCached(new MockResponse().addHeader("Cache-Control: public"));
-  }
-
-  @Test public void authorizationResponseCachedWithMustRevalidate() throws Exception {
-    assertAuthorizationRequestFullyCached(
-        new MockResponse().addHeader("Cache-Control: must-revalidate"));
-  }
-
-  public void assertAuthorizationRequestFullyCached(MockResponse response) throws Exception {
-    server.enqueue(response.addHeader("Cache-Control: max-age=60").setBody("A"));
-    server.enqueue(new MockResponse().setBody("B"));
-    server.play();
-
-    URL url = server.getUrl("/");
-    URLConnection connection = openConnection(url);
-    connection.addRequestProperty("Authorization", "password");
-    assertEquals("A", readAscii(connection));
-    assertEquals("A", readAscii(openConnection(url)));
-  }
-
-  @Test public void contentLocationDoesNotPopulateCache() throws Exception {
-    server.enqueue(new MockResponse().addHeader("Cache-Control: max-age=60")
-        .addHeader("Content-Location: /bar")
-        .setBody("A"));
-    server.enqueue(new MockResponse().setBody("B"));
-    server.play();
-
-    assertEquals("A", readAscii(openConnection(server.getUrl("/foo"))));
-    assertEquals("B", readAscii(openConnection(server.getUrl("/bar"))));
-  }
-
-  @Test public void useCachesFalseDoesNotWriteToCache() throws Exception {
-    server.enqueue(
-        new MockResponse().addHeader("Cache-Control: max-age=60").setBody("A").setBody("A"));
-    server.enqueue(new MockResponse().setBody("B"));
-    server.play();
-
-    URLConnection connection = openConnection(server.getUrl("/"));
-    connection.setUseCaches(false);
-    assertEquals("A", readAscii(connection));
-    assertEquals("B", readAscii(openConnection(server.getUrl("/"))));
-  }
-
-  @Test public void useCachesFalseDoesNotReadFromCache() throws Exception {
-    server.enqueue(
-        new MockResponse().addHeader("Cache-Control: max-age=60").setBody("A").setBody("A"));
-    server.enqueue(new MockResponse().setBody("B"));
-    server.play();
-
-    assertEquals("A", readAscii(openConnection(server.getUrl("/"))));
-    URLConnection connection = openConnection(server.getUrl("/"));
-    connection.setUseCaches(false);
-    assertEquals("B", readAscii(connection));
-  }
-
-  @Test public void defaultUseCachesSetsInitialValueOnly() throws Exception {
-    URL url = new URL("http://localhost/");
-    URLConnection c1 = openConnection(url);
-    URLConnection c2 = openConnection(url);
-    assertTrue(c1.getDefaultUseCaches());
-    c1.setDefaultUseCaches(false);
-    try {
-      assertTrue(c1.getUseCaches());
-      assertTrue(c2.getUseCaches());
-      URLConnection c3 = openConnection(url);
-      assertFalse(c3.getUseCaches());
-    } finally {
-      c1.setDefaultUseCaches(true);
-    }
-  }
-
-  @Test public void connectionIsReturnedToPoolAfterConditionalSuccess() throws Exception {
-    server.enqueue(new MockResponse().addHeader("Last-Modified: " + formatDate(-1, TimeUnit.HOURS))
-        .addHeader("Cache-Control: max-age=0")
-        .setBody("A"));
-    server.enqueue(new MockResponse().setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
-    server.enqueue(new MockResponse().setBody("B"));
-    server.play();
-
-    assertEquals("A", readAscii(openConnection(server.getUrl("/a"))));
-    assertEquals("A", readAscii(openConnection(server.getUrl("/a"))));
-    assertEquals("B", readAscii(openConnection(server.getUrl("/b"))));
-
-    assertEquals(0, server.takeRequest().getSequenceNumber());
-    assertEquals(1, server.takeRequest().getSequenceNumber());
-    assertEquals(2, server.takeRequest().getSequenceNumber());
-  }
-
-  @Test public void statisticsConditionalCacheMiss() throws Exception {
-    server.enqueue(new MockResponse().addHeader("Last-Modified: " + formatDate(-1, TimeUnit.HOURS))
-        .addHeader("Cache-Control: max-age=0")
-        .setBody("A"));
-    server.enqueue(new MockResponse().setBody("B"));
-    server.enqueue(new MockResponse().setBody("C"));
-    server.play();
-
-    assertEquals("A", readAscii(openConnection(server.getUrl("/"))));
-    assertEquals(1, cache.getRequestCount());
-    assertEquals(1, cache.getNetworkCount());
-    assertEquals(0, cache.getHitCount());
-    assertEquals("B", readAscii(openConnection(server.getUrl("/"))));
-    assertEquals("C", readAscii(openConnection(server.getUrl("/"))));
-    assertEquals(3, cache.getRequestCount());
-    assertEquals(3, cache.getNetworkCount());
-    assertEquals(0, cache.getHitCount());
-  }
-
-  @Test public void statisticsConditionalCacheHit() throws Exception {
-    server.enqueue(new MockResponse().addHeader("Last-Modified: " + formatDate(-1, TimeUnit.HOURS))
-        .addHeader("Cache-Control: max-age=0")
-        .setBody("A"));
-    server.enqueue(new MockResponse().setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
-    server.enqueue(new MockResponse().setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
-    server.play();
-
-    assertEquals("A", readAscii(openConnection(server.getUrl("/"))));
-    assertEquals(1, cache.getRequestCount());
-    assertEquals(1, cache.getNetworkCount());
-    assertEquals(0, cache.getHitCount());
-    assertEquals("A", readAscii(openConnection(server.getUrl("/"))));
-    assertEquals("A", readAscii(openConnection(server.getUrl("/"))));
-    assertEquals(3, cache.getRequestCount());
-    assertEquals(3, cache.getNetworkCount());
-    assertEquals(2, cache.getHitCount());
-  }
-
-  @Test public void statisticsFullCacheHit() throws Exception {
-    server.enqueue(new MockResponse().addHeader("Cache-Control: max-age=60").setBody("A"));
-    server.play();
-
-    assertEquals("A", readAscii(openConnection(server.getUrl("/"))));
-    assertEquals(1, cache.getRequestCount());
-    assertEquals(1, cache.getNetworkCount());
-    assertEquals(0, cache.getHitCount());
-    assertEquals("A", readAscii(openConnection(server.getUrl("/"))));
-    assertEquals("A", readAscii(openConnection(server.getUrl("/"))));
-    assertEquals(3, cache.getRequestCount());
-    assertEquals(1, cache.getNetworkCount());
-    assertEquals(2, cache.getHitCount());
-  }
-
-  @Test public void varyMatchesChangedRequestHeaderField() throws Exception {
-    server.enqueue(new MockResponse().addHeader("Cache-Control: max-age=60")
-        .addHeader("Vary: Accept-Language")
-        .setBody("A"));
-    server.enqueue(new MockResponse().setBody("B"));
-    server.play();
-
-    URL url = server.getUrl("/");
-    HttpURLConnection frConnection = openConnection(url);
-    frConnection.addRequestProperty("Accept-Language", "fr-CA");
-    assertEquals("A", readAscii(frConnection));
-
-    HttpURLConnection enConnection = openConnection(url);
-    enConnection.addRequestProperty("Accept-Language", "en-US");
-    assertEquals("B", readAscii(enConnection));
-  }
-
-  @Test public void varyMatchesUnchangedRequestHeaderField() throws Exception {
-    server.enqueue(new MockResponse().addHeader("Cache-Control: max-age=60")
-        .addHeader("Vary: Accept-Language")
-        .setBody("A"));
-    server.enqueue(new MockResponse().setBody("B"));
-    server.play();
-
-    URL url = server.getUrl("/");
-    URLConnection connection1 = openConnection(url);
-    connection1.addRequestProperty("Accept-Language", "fr-CA");
-    assertEquals("A", readAscii(connection1));
-    URLConnection connection2 = openConnection(url);
-    connection2.addRequestProperty("Accept-Language", "fr-CA");
-    assertEquals("A", readAscii(connection2));
-  }
-
-  @Test public void varyMatchesAbsentRequestHeaderField() throws Exception {
-    server.enqueue(new MockResponse().addHeader("Cache-Control: max-age=60")
-        .addHeader("Vary: Foo")
-        .setBody("A"));
-    server.enqueue(new MockResponse().setBody("B"));
-    server.play();
-
-    assertEquals("A", readAscii(openConnection(server.getUrl("/"))));
-    assertEquals("A", readAscii(openConnection(server.getUrl("/"))));
-  }
-
-  @Test public void varyMatchesAddedRequestHeaderField() throws Exception {
-    server.enqueue(new MockResponse().addHeader("Cache-Control: max-age=60")
-        .addHeader("Vary: Foo")
-        .setBody("A"));
-    server.enqueue(new MockResponse().setBody("B"));
-    server.play();
-
-    assertEquals("A", readAscii(openConnection(server.getUrl("/"))));
-    URLConnection fooConnection = openConnection(server.getUrl("/"));
-    fooConnection.addRequestProperty("Foo", "bar");
-    assertEquals("B", readAscii(fooConnection));
-  }
-
-  @Test public void varyMatchesRemovedRequestHeaderField() throws Exception {
-    server.enqueue(new MockResponse().addHeader("Cache-Control: max-age=60")
-        .addHeader("Vary: Foo")
-        .setBody("A"));
-    server.enqueue(new MockResponse().setBody("B"));
-    server.play();
-
-    URLConnection fooConnection = openConnection(server.getUrl("/"));
-    fooConnection.addRequestProperty("Foo", "bar");
-    assertEquals("A", readAscii(fooConnection));
-    assertEquals("B", readAscii(openConnection(server.getUrl("/"))));
-  }
-
-  @Test public void varyFieldsAreCaseInsensitive() throws Exception {
-    server.enqueue(new MockResponse().addHeader("Cache-Control: max-age=60")
-        .addHeader("Vary: ACCEPT-LANGUAGE")
-        .setBody("A"));
-    server.enqueue(new MockResponse().setBody("B"));
-    server.play();
-
-    URL url = server.getUrl("/");
-    URLConnection connection1 = openConnection(url);
-    connection1.addRequestProperty("Accept-Language", "fr-CA");
-    assertEquals("A", readAscii(connection1));
-    URLConnection connection2 = openConnection(url);
-    connection2.addRequestProperty("accept-language", "fr-CA");
-    assertEquals("A", readAscii(connection2));
-  }
-
-  @Test public void varyMultipleFieldsWithMatch() throws Exception {
-    server.enqueue(new MockResponse().addHeader("Cache-Control: max-age=60")
-        .addHeader("Vary: Accept-Language, Accept-Charset")
-        .addHeader("Vary: Accept-Encoding")
-        .setBody("A"));
-    server.enqueue(new MockResponse().setBody("B"));
-    server.play();
-
-    URL url = server.getUrl("/");
-    URLConnection connection1 = openConnection(url);
-    connection1.addRequestProperty("Accept-Language", "fr-CA");
-    connection1.addRequestProperty("Accept-Charset", "UTF-8");
-    connection1.addRequestProperty("Accept-Encoding", "identity");
-    assertEquals("A", readAscii(connection1));
-    URLConnection connection2 = openConnection(url);
-    connection2.addRequestProperty("Accept-Language", "fr-CA");
-    connection2.addRequestProperty("Accept-Charset", "UTF-8");
-    connection2.addRequestProperty("Accept-Encoding", "identity");
-    assertEquals("A", readAscii(connection2));
-  }
-
-  @Test public void varyMultipleFieldsWithNoMatch() throws Exception {
-    server.enqueue(new MockResponse().addHeader("Cache-Control: max-age=60")
-        .addHeader("Vary: Accept-Language, Accept-Charset")
-        .addHeader("Vary: Accept-Encoding")
-        .setBody("A"));
-    server.enqueue(new MockResponse().setBody("B"));
-    server.play();
-
-    URL url = server.getUrl("/");
-    URLConnection frConnection = openConnection(url);
-    frConnection.addRequestProperty("Accept-Language", "fr-CA");
-    frConnection.addRequestProperty("Accept-Charset", "UTF-8");
-    frConnection.addRequestProperty("Accept-Encoding", "identity");
-    assertEquals("A", readAscii(frConnection));
-    URLConnection enConnection = openConnection(url);
-    enConnection.addRequestProperty("Accept-Language", "en-CA");
-    enConnection.addRequestProperty("Accept-Charset", "UTF-8");
-    enConnection.addRequestProperty("Accept-Encoding", "identity");
-    assertEquals("B", readAscii(enConnection));
-  }
-
-  @Test public void varyMultipleFieldValuesWithMatch() throws Exception {
-    server.enqueue(new MockResponse().addHeader("Cache-Control: max-age=60")
-        .addHeader("Vary: Accept-Language")
-        .setBody("A"));
-    server.enqueue(new MockResponse().setBody("B"));
-    server.play();
-
-    URL url = server.getUrl("/");
-    URLConnection connection1 = openConnection(url);
-    connection1.addRequestProperty("Accept-Language", "fr-CA, fr-FR");
-    connection1.addRequestProperty("Accept-Language", "en-US");
-    assertEquals("A", readAscii(connection1));
-
-    URLConnection connection2 = openConnection(url);
-    connection2.addRequestProperty("Accept-Language", "fr-CA, fr-FR");
-    connection2.addRequestProperty("Accept-Language", "en-US");
-    assertEquals("A", readAscii(connection2));
-  }
-
-  @Test public void varyMultipleFieldValuesWithNoMatch() throws Exception {
-    server.enqueue(new MockResponse().addHeader("Cache-Control: max-age=60")
-        .addHeader("Vary: Accept-Language")
-        .setBody("A"));
-    server.enqueue(new MockResponse().setBody("B"));
-    server.play();
-
-    URL url = server.getUrl("/");
-    URLConnection connection1 = openConnection(url);
-    connection1.addRequestProperty("Accept-Language", "fr-CA, fr-FR");
-    connection1.addRequestProperty("Accept-Language", "en-US");
-    assertEquals("A", readAscii(connection1));
-
-    URLConnection connection2 = openConnection(url);
-    connection2.addRequestProperty("Accept-Language", "fr-CA");
-    connection2.addRequestProperty("Accept-Language", "en-US");
-    assertEquals("B", readAscii(connection2));
-  }
-
-  @Test public void varyAsterisk() throws Exception {
-    server.enqueue(new MockResponse().addHeader("Cache-Control: max-age=60")
-        .addHeader("Vary: *")
-        .setBody("A"));
-    server.enqueue(new MockResponse().setBody("B"));
-    server.play();
-
-    assertEquals("A", readAscii(openConnection(server.getUrl("/"))));
-    assertEquals("B", readAscii(openConnection(server.getUrl("/"))));
-  }
-
-  @Test public void varyAndHttps() throws Exception {
-    server.useHttps(sslContext.getSocketFactory(), false);
-    server.enqueue(new MockResponse().addHeader("Cache-Control: max-age=60")
-        .addHeader("Vary: Accept-Language")
-        .setBody("A"));
-    server.enqueue(new MockResponse().setBody("B"));
-    server.play();
-
-    URL url = server.getUrl("/");
-    HttpsURLConnection connection1 = (HttpsURLConnection) client.open(url);
-    connection1.setSSLSocketFactory(sslContext.getSocketFactory());
-    connection1.setHostnameVerifier(NULL_HOSTNAME_VERIFIER);
-    connection1.addRequestProperty("Accept-Language", "en-US");
-    assertEquals("A", readAscii(connection1));
-
-    HttpsURLConnection connection2 = (HttpsURLConnection) client.open(url);
-    connection2.setSSLSocketFactory(sslContext.getSocketFactory());
-    connection2.setHostnameVerifier(NULL_HOSTNAME_VERIFIER);
-    connection2.addRequestProperty("Accept-Language", "en-US");
-    assertEquals("A", readAscii(connection2));
-  }
-
-  @Test public void cachePlusCookies() throws Exception {
-    server.enqueue(new MockResponse().addHeader(
-        "Set-Cookie: a=FIRST; domain=" + server.getCookieDomain() + ";")
-        .addHeader("Last-Modified: " + formatDate(-1, TimeUnit.HOURS))
-        .addHeader("Cache-Control: max-age=0")
-        .setBody("A"));
-    server.enqueue(new MockResponse().addHeader(
-        "Set-Cookie: a=SECOND; domain=" + server.getCookieDomain() + ";")
-        .setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
-    server.play();
-
-    URL url = server.getUrl("/");
-    assertEquals("A", readAscii(openConnection(url)));
-    assertCookies(url, "a=FIRST");
-    assertEquals("A", readAscii(openConnection(url)));
-    assertCookies(url, "a=SECOND");
-  }
-
-  @Test public void getHeadersReturnsNetworkEndToEndHeaders() throws Exception {
-    server.enqueue(new MockResponse().addHeader("Allow: GET, HEAD")
-        .addHeader("Last-Modified: " + formatDate(-1, TimeUnit.HOURS))
-        .addHeader("Cache-Control: max-age=0")
-        .setBody("A"));
-    server.enqueue(new MockResponse().addHeader("Allow: GET, HEAD, PUT")
-        .setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
-    server.play();
-
-    URLConnection connection1 = openConnection(server.getUrl("/"));
-    assertEquals("A", readAscii(connection1));
-    assertEquals("GET, HEAD", connection1.getHeaderField("Allow"));
-
-    URLConnection connection2 = openConnection(server.getUrl("/"));
-    assertEquals("A", readAscii(connection2));
-    assertEquals("GET, HEAD, PUT", connection2.getHeaderField("Allow"));
-  }
-
-  @Test public void getHeadersReturnsCachedHopByHopHeaders() throws Exception {
-    server.enqueue(new MockResponse().addHeader("Transfer-Encoding: identity")
-        .addHeader("Last-Modified: " + formatDate(-1, TimeUnit.HOURS))
-        .addHeader("Cache-Control: max-age=0")
-        .setBody("A"));
-    server.enqueue(new MockResponse().addHeader("Transfer-Encoding: none")
-        .setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
-    server.play();
-
-    URLConnection connection1 = openConnection(server.getUrl("/"));
-    assertEquals("A", readAscii(connection1));
-    assertEquals("identity", connection1.getHeaderField("Transfer-Encoding"));
-
-    URLConnection connection2 = openConnection(server.getUrl("/"));
-    assertEquals("A", readAscii(connection2));
-    assertEquals("identity", connection2.getHeaderField("Transfer-Encoding"));
-  }
-
-  @Test public void getHeadersDeletesCached100LevelWarnings() throws Exception {
-    server.enqueue(new MockResponse().addHeader("Warning: 199 test danger")
-        .addHeader("Last-Modified: " + formatDate(-1, TimeUnit.HOURS))
-        .addHeader("Cache-Control: max-age=0")
-        .setBody("A"));
-    server.enqueue(new MockResponse().setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
-    server.play();
-
-    URLConnection connection1 = openConnection(server.getUrl("/"));
-    assertEquals("A", readAscii(connection1));
-    assertEquals("199 test danger", connection1.getHeaderField("Warning"));
-
-    URLConnection connection2 = openConnection(server.getUrl("/"));
-    assertEquals("A", readAscii(connection2));
-    assertEquals(null, connection2.getHeaderField("Warning"));
-  }
-
-  @Test public void getHeadersRetainsCached200LevelWarnings() throws Exception {
-    server.enqueue(new MockResponse().addHeader("Warning: 299 test danger")
-        .addHeader("Last-Modified: " + formatDate(-1, TimeUnit.HOURS))
-        .addHeader("Cache-Control: max-age=0")
-        .setBody("A"));
-    server.enqueue(new MockResponse().setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
-    server.play();
-
-    URLConnection connection1 = openConnection(server.getUrl("/"));
-    assertEquals("A", readAscii(connection1));
-    assertEquals("299 test danger", connection1.getHeaderField("Warning"));
-
-    URLConnection connection2 = openConnection(server.getUrl("/"));
-    assertEquals("A", readAscii(connection2));
-    assertEquals("299 test danger", connection2.getHeaderField("Warning"));
-  }
-
-  public void assertCookies(URL url, String... expectedCookies) throws Exception {
-    List<String> actualCookies = new ArrayList<String>();
-    for (HttpCookie cookie : cookieManager.getCookieStore().get(url.toURI())) {
-      actualCookies.add(cookie.toString());
-    }
-    assertEquals(Arrays.asList(expectedCookies), actualCookies);
-  }
-
-  @Test public void cachePlusRange() throws Exception {
-    assertNotCached(new MockResponse().setResponseCode(HttpURLConnection.HTTP_PARTIAL)
-        .addHeader("Date: " + formatDate(0, TimeUnit.HOURS))
-        .addHeader("Content-Range: bytes 100-100/200")
-        .addHeader("Cache-Control: max-age=60"));
-  }
-
-  @Test public void conditionalHitUpdatesCache() throws Exception {
-    server.enqueue(new MockResponse().addHeader("Last-Modified: " + formatDate(0, TimeUnit.SECONDS))
-        .addHeader("Cache-Control: max-age=0")
-        .setBody("A"));
-    server.enqueue(new MockResponse().addHeader("Cache-Control: max-age=30")
-        .addHeader("Allow: GET, HEAD")
-        .setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
-    server.enqueue(new MockResponse().setBody("B"));
-    server.play();
-
-    // cache miss; seed the cache
-    HttpURLConnection connection1 = openConnection(server.getUrl("/a"));
-    assertEquals("A", readAscii(connection1));
-    assertEquals(null, connection1.getHeaderField("Allow"));
-
-    // conditional cache hit; update the cache
-    HttpURLConnection connection2 = openConnection(server.getUrl("/a"));
-    assertEquals(HttpURLConnection.HTTP_OK, connection2.getResponseCode());
-    assertEquals("A", readAscii(connection2));
-    assertEquals("GET, HEAD", connection2.getHeaderField("Allow"));
-
-    // full cache hit
-    HttpURLConnection connection3 = openConnection(server.getUrl("/a"));
-    assertEquals("A", readAscii(connection3));
-    assertEquals("GET, HEAD", connection3.getHeaderField("Allow"));
-
-    assertEquals(2, server.getRequestCount());
-  }
-
-  @Test public void responseSourceHeaderCached() throws IOException {
-    server.enqueue(new MockResponse().setBody("A")
-        .addHeader("Cache-Control: max-age=30")
-        .addHeader("Date: " + formatDate(0, TimeUnit.MINUTES)));
-    server.play();
-
-    assertEquals("A", readAscii(openConnection(server.getUrl("/"))));
-    URLConnection connection = openConnection(server.getUrl("/"));
-    connection.addRequestProperty("Cache-Control", "only-if-cached");
-    assertEquals("A", readAscii(connection));
-
-    String source = connection.getHeaderField(ResponseHeaders.RESPONSE_SOURCE);
-    assertEquals(ResponseSource.CACHE.toString() + " 200", source);
-  }
-
-  @Test public void responseSourceHeaderConditionalCacheFetched() throws IOException {
-    server.enqueue(new MockResponse().setBody("A")
-        .addHeader("Cache-Control: max-age=30")
-        .addHeader("Date: " + formatDate(-31, TimeUnit.MINUTES)));
-    server.enqueue(new MockResponse().setBody("B")
-        .addHeader("Cache-Control: max-age=30")
-        .addHeader("Date: " + formatDate(0, TimeUnit.MINUTES)));
-    server.play();
-
-    assertEquals("A", readAscii(openConnection(server.getUrl("/"))));
-    HttpURLConnection connection = openConnection(server.getUrl("/"));
-    assertEquals("B", readAscii(connection));
-
-    String source = connection.getHeaderField(ResponseHeaders.RESPONSE_SOURCE);
-    assertEquals(ResponseSource.CONDITIONAL_CACHE.toString() + " 200", source);
-  }
-
-  @Test public void responseSourceHeaderConditionalCacheNotFetched() throws IOException {
-    server.enqueue(new MockResponse().setBody("A")
-        .addHeader("Cache-Control: max-age=0")
-        .addHeader("Date: " + formatDate(0, TimeUnit.MINUTES)));
-    server.enqueue(new MockResponse().setResponseCode(304));
-    server.play();
-
-    assertEquals("A", readAscii(openConnection(server.getUrl("/"))));
-    HttpURLConnection connection = openConnection(server.getUrl("/"));
-    assertEquals("A", readAscii(connection));
-
-    String source = connection.getHeaderField(ResponseHeaders.RESPONSE_SOURCE);
-    assertEquals(ResponseSource.CONDITIONAL_CACHE.toString() + " 304", source);
-  }
-
-  @Test public void responseSourceHeaderFetched() throws IOException {
-    server.enqueue(new MockResponse().setBody("A"));
-    server.play();
-
-    URLConnection connection = openConnection(server.getUrl("/"));
-    assertEquals("A", readAscii(connection));
-
-    String source = connection.getHeaderField(ResponseHeaders.RESPONSE_SOURCE);
-    assertEquals(ResponseSource.NETWORK.toString() + " 200", source);
-  }
-
-  @Test public void emptyResponseHeaderNameFromCacheIsLenient() throws Exception {
-    server.enqueue(new MockResponse()
-        .addHeader("Cache-Control: max-age=120")
-        .addHeader(": A")
-        .setBody("body"));
-    server.play();
-    HttpURLConnection connection = client.open(server.getUrl("/"));
-    assertEquals("A", connection.getHeaderField(""));
-  }
-
-  /**
-   * @param delta the offset from the current date to use. Negative
-   * values yield dates in the past; positive values yield dates in the
-   * future.
-   */
-  private String formatDate(long delta, TimeUnit timeUnit) {
-    return formatDate(new Date(System.currentTimeMillis() + timeUnit.toMillis(delta)));
-  }
-
-  private String formatDate(Date date) {
-    DateFormat rfc1123 = new SimpleDateFormat("EEE, dd MMM yyyy HH:mm:ss zzz", Locale.US);
-    rfc1123.setTimeZone(TimeZone.getTimeZone("UTC"));
-    return rfc1123.format(date);
-  }
-
-  private void addRequestBodyIfNecessary(String requestMethod, HttpURLConnection invalidate)
-      throws IOException {
-    if (requestMethod.equals("POST") || requestMethod.equals("PUT")) {
-      invalidate.setDoOutput(true);
-      OutputStream requestBody = invalidate.getOutputStream();
-      requestBody.write('x');
-      requestBody.close();
-    }
-  }
-
-  private void assertNotCached(MockResponse response) throws Exception {
-    server.enqueue(response.setBody("A"));
-    server.enqueue(new MockResponse().setBody("B"));
-    server.play();
-
-    URL url = server.getUrl("/");
-    assertEquals("A", readAscii(openConnection(url)));
-    assertEquals("B", readAscii(openConnection(url)));
-  }
-
-  /** @return the request with the conditional get headers. */
-  private RecordedRequest assertConditionallyCached(MockResponse response) throws Exception {
-    // scenario 1: condition succeeds
-    server.enqueue(response.setBody("A").setStatus("HTTP/1.1 200 A-OK"));
-    server.enqueue(new MockResponse().setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
-
-    // scenario 2: condition fails
-    server.enqueue(response.setBody("B").setStatus("HTTP/1.1 200 B-OK"));
-    server.enqueue(new MockResponse().setStatus("HTTP/1.1 200 C-OK").setBody("C"));
-
-    server.play();
-
-    URL valid = server.getUrl("/valid");
-    HttpURLConnection connection1 = openConnection(valid);
-    assertEquals("A", readAscii(connection1));
-    assertEquals(HttpURLConnection.HTTP_OK, connection1.getResponseCode());
-    assertEquals("A-OK", connection1.getResponseMessage());
-    HttpURLConnection connection2 = openConnection(valid);
-    assertEquals("A", readAscii(connection2));
-    assertEquals(HttpURLConnection.HTTP_OK, connection2.getResponseCode());
-    assertEquals("A-OK", connection2.getResponseMessage());
-
-    URL invalid = server.getUrl("/invalid");
-    HttpURLConnection connection3 = openConnection(invalid);
-    assertEquals("B", readAscii(connection3));
-    assertEquals(HttpURLConnection.HTTP_OK, connection3.getResponseCode());
-    assertEquals("B-OK", connection3.getResponseMessage());
-    HttpURLConnection connection4 = openConnection(invalid);
-    assertEquals("C", readAscii(connection4));
-    assertEquals(HttpURLConnection.HTTP_OK, connection4.getResponseCode());
-    assertEquals("C-OK", connection4.getResponseMessage());
-
-    server.takeRequest(); // regular get
-    return server.takeRequest(); // conditional get
-  }
-
-  private void assertFullyCached(MockResponse response) throws Exception {
-    server.enqueue(response.setBody("A"));
-    server.enqueue(response.setBody("B"));
-    server.play();
-
-    URL url = server.getUrl("/");
-    assertEquals("A", readAscii(openConnection(url)));
-    assertEquals("A", readAscii(openConnection(url)));
-  }
-
-  /**
-   * Shortens the body of {@code response} but not the corresponding headers.
-   * Only useful to test how clients respond to the premature conclusion of
-   * the HTTP body.
-   */
-  private MockResponse truncateViolently(MockResponse response, int numBytesToKeep) {
-    response.setSocketPolicy(DISCONNECT_AT_END);
-    List<String> headers = new ArrayList<String>(response.getHeaders());
-    response.setBody(Arrays.copyOfRange(response.getBody(), 0, numBytesToKeep));
-    response.getHeaders().clear();
-    response.getHeaders().addAll(headers);
-    return response;
-  }
-
-  /**
-   * Reads {@code count} characters from the stream. If the stream is
-   * exhausted before {@code count} characters can be read, the remaining
-   * characters are returned and the stream is closed.
-   */
-  private String readAscii(URLConnection connection, int count) throws IOException {
-    HttpURLConnection httpConnection = (HttpURLConnection) connection;
-    InputStream in = httpConnection.getResponseCode() < HttpURLConnection.HTTP_BAD_REQUEST
-        ? connection.getInputStream() : httpConnection.getErrorStream();
-    StringBuilder result = new StringBuilder();
-    for (int i = 0; i < count; i++) {
-      int value = in.read();
-      if (value == -1) {
-        in.close();
-        break;
-      }
-      result.append((char) value);
-    }
-    return result.toString();
-  }
-
-  private String readAscii(URLConnection connection) throws IOException {
-    return readAscii(connection, Integer.MAX_VALUE);
-  }
-
-  private void reliableSkip(InputStream in, int length) throws IOException {
-    while (length > 0) {
-      length -= in.skip(length);
-    }
-  }
-
-  private void assertGatewayTimeout(HttpURLConnection connection) throws IOException {
-    try {
-      connection.getInputStream();
-      fail();
-    } catch (FileNotFoundException expected) {
-    }
-    assertEquals(504, connection.getResponseCode());
-    assertEquals(-1, connection.getErrorStream().read());
-  }
-
-  enum TransferKind {
-    CHUNKED() {
-      @Override void setBody(MockResponse response, byte[] content, int chunkSize)
-          throws IOException {
-        response.setChunkedBody(content, chunkSize);
-      }
-    },
-    FIXED_LENGTH() {
-      @Override void setBody(MockResponse response, byte[] content, int chunkSize) {
-        response.setBody(content);
-      }
-    },
-    END_OF_STREAM() {
-      @Override void setBody(MockResponse response, byte[] content, int chunkSize) {
-        response.setBody(content);
-        response.setSocketPolicy(DISCONNECT_AT_END);
-        for (Iterator<String> h = response.getHeaders().iterator(); h.hasNext(); ) {
-          if (h.next().startsWith("Content-Length:")) {
-            h.remove();
-            break;
-          }
-        }
-      }
-    };
-
-    abstract void setBody(MockResponse response, byte[] content, int chunkSize) throws IOException;
-
-    void setBody(MockResponse response, String content, int chunkSize) throws IOException {
-      setBody(response, content.getBytes("UTF-8"), chunkSize);
-    }
-  }
-
-  private <T> List<T> toListOrNull(T[] arrayOrNull) {
-    return arrayOrNull != null ? Arrays.asList(arrayOrNull) : null;
-  }
-
-  /** Returns a gzipped copy of {@code bytes}. */
-  public byte[] gzip(byte[] bytes) throws IOException {
-    ByteArrayOutputStream bytesOut = new ByteArrayOutputStream();
-    OutputStream gzippedOut = new GZIPOutputStream(bytesOut);
-    gzippedOut.write(bytes);
-    gzippedOut.close();
-    return bytesOut.toByteArray();
-  }
-
-  private class InsecureResponseCache extends ResponseCache {
-    @Override public CacheRequest put(URI uri, URLConnection connection) throws IOException {
-      return cache.put(uri, connection);
-    }
-
-    @Override public CacheResponse get(URI uri, String requestMethod,
-        Map<String, List<String>> requestHeaders) throws IOException {
-      final CacheResponse response = cache.get(uri, requestMethod, requestHeaders);
-      if (response instanceof SecureCacheResponse) {
-        return new CacheResponse() {
-          @Override public InputStream getBody() throws IOException {
-            return response.getBody();
-          }
-          @Override public Map<String, List<String>> getHeaders() throws IOException {
-            return response.getHeaders();
-          }
-        };
-      }
-      return response;
-    }
-  }
-}
diff --git a/okhttp/src/test/java/com/squareup/okhttp/internal/http/RawHeadersTest.java b/okhttp/src/test/java/com/squareup/okhttp/internal/http/RawHeadersTest.java
deleted file mode 100644
index 4ce80a5ebb..0000000000
--- a/okhttp/src/test/java/com/squareup/okhttp/internal/http/RawHeadersTest.java
+++ /dev/null
@@ -1,104 +0,0 @@
-/*
- * Copyright (C) 2012 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.squareup.okhttp.internal.http;
-
-import java.io.IOException;
-import java.util.Arrays;
-import java.util.List;
-import org.junit.Test;
-
-import static junit.framework.Assert.assertNull;
-import static org.junit.Assert.assertEquals;
-
-public final class RawHeadersTest {
-  @Test public void parseNameValueBlock() throws IOException {
-    List<String> nameValueBlock = Arrays.asList(
-        "cache-control", "no-cache, no-store",
-        "set-cookie", "Cookie1\u0000Cookie2",
-        ":status", "200 OK",
-        ":version", "HTTP/1.1");
-    RawHeaders rawHeaders = RawHeaders.fromNameValueBlock(nameValueBlock);
-    assertEquals(3, rawHeaders.length());
-    assertEquals("HTTP/1.1 200 OK", rawHeaders.getStatusLine());
-    assertEquals("no-cache, no-store", rawHeaders.get("cache-control"));
-    assertEquals("Cookie2", rawHeaders.get("set-cookie"));
-    assertEquals("cache-control", rawHeaders.getFieldName(0));
-    assertEquals("no-cache, no-store", rawHeaders.getValue(0));
-    assertEquals("set-cookie", rawHeaders.getFieldName(1));
-    assertEquals("Cookie1", rawHeaders.getValue(1));
-    assertEquals("set-cookie", rawHeaders.getFieldName(2));
-    assertEquals("Cookie2", rawHeaders.getValue(2));
-    assertNull(rawHeaders.get(":status"));
-    assertNull(rawHeaders.get(":version"));
-  }
-
-  @Test public void toNameValueBlock() {
-    RawHeaders rawHeaders = new RawHeaders();
-    rawHeaders.add("cache-control", "no-cache, no-store");
-    rawHeaders.add("set-cookie", "Cookie1");
-    rawHeaders.add("set-cookie", "Cookie2");
-    rawHeaders.add(":status", "200 OK");
-    // TODO: fromNameValueBlock should take the status line headers
-    List<String> nameValueBlock = rawHeaders.toNameValueBlock();
-    List<String> expected =
-        Arrays.asList("cache-control", "no-cache, no-store", "set-cookie", "Cookie1\u0000Cookie2",
-            ":status", "200 OK");
-    assertEquals(expected, nameValueBlock);
-  }
-
-  @Test public void toNameValueBlockDropsForbiddenHeaders() {
-    RawHeaders rawHeaders = new RawHeaders();
-    rawHeaders.add("Connection", "close");
-    rawHeaders.add("Transfer-Encoding", "chunked");
-    assertEquals(Arrays.<String>asList(), rawHeaders.toNameValueBlock());
-  }
-
-  @Test public void statusMessage() throws IOException {
-    RawHeaders rawHeaders = new RawHeaders();
-    final String message = "Temporary Redirect";
-    final int version = 1;
-    final int code = 200;
-    rawHeaders.setStatusLine("HTTP/1." + version + " " + code + " " + message);
-    assertEquals(message, rawHeaders.getResponseMessage());
-    assertEquals(version, rawHeaders.getHttpMinorVersion());
-    assertEquals(code, rawHeaders.getResponseCode());
-  }
-
-  @Test public void statusMessageWithEmptyMessage() throws IOException {
-    RawHeaders rawHeaders = new RawHeaders();
-    final int version = 1;
-    final int code = 503;
-    rawHeaders.setStatusLine("HTTP/1." + version + " " + code + " ");
-    assertEquals("", rawHeaders.getResponseMessage());
-    assertEquals(version, rawHeaders.getHttpMinorVersion());
-    assertEquals(code, rawHeaders.getResponseCode());
-  }
-
-  /**
-   * This is not defined in the protocol but some servers won't add the leading
-   * empty space when the message is empty.
-   * http://www.w3.org/Protocols/rfc2616/rfc2616-sec6.html#sec6.1
-   */
-  @Test public void statusMessageWithEmptyMessageAndNoLeadingSpace() throws IOException {
-    RawHeaders rawHeaders = new RawHeaders();
-    final int version = 1;
-    final int code = 503;
-    rawHeaders.setStatusLine("HTTP/1." + version + " " + code);
-    assertEquals("", rawHeaders.getResponseMessage());
-    assertEquals(version, rawHeaders.getHttpMinorVersion());
-    assertEquals(code, rawHeaders.getResponseCode());
-  }
-}
diff --git a/okhttp/src/test/java/com/squareup/okhttp/internal/http/RouteSelectorTest.java b/okhttp/src/test/java/com/squareup/okhttp/internal/http/RouteSelectorTest.java
deleted file mode 100644
index a92db9ee14..0000000000
--- a/okhttp/src/test/java/com/squareup/okhttp/internal/http/RouteSelectorTest.java
+++ /dev/null
@@ -1,451 +0,0 @@
-/*
- * Copyright (C) 2012 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.squareup.okhttp.internal.http;
-
-import com.squareup.okhttp.Address;
-import com.squareup.okhttp.Connection;
-import com.squareup.okhttp.ConnectionPool;
-import com.squareup.okhttp.OkAuthenticator;
-import com.squareup.okhttp.RouteDatabase;
-import com.squareup.okhttp.internal.Dns;
-import com.squareup.okhttp.internal.SslContextBuilder;
-import java.io.IOException;
-import java.net.InetAddress;
-import java.net.InetSocketAddress;
-import java.net.Proxy;
-import java.net.ProxySelector;
-import java.net.SocketAddress;
-import java.net.URI;
-import java.net.UnknownHostException;
-import java.util.ArrayList;
-import java.util.Arrays;
-import java.util.List;
-import java.util.NoSuchElementException;
-import javax.net.ssl.HostnameVerifier;
-import javax.net.ssl.SSLContext;
-import javax.net.ssl.SSLHandshakeException;
-import javax.net.ssl.SSLSocketFactory;
-import org.junit.Test;
-
-import static java.net.Proxy.NO_PROXY;
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertFalse;
-import static org.junit.Assert.assertTrue;
-import static org.junit.Assert.fail;
-
-public final class RouteSelectorTest {
-  private static final int proxyAPort = 1001;
-  private static final String proxyAHost = "proxyA";
-  private static final Proxy proxyA =
-      new Proxy(Proxy.Type.HTTP, new InetSocketAddress(proxyAHost, proxyAPort));
-  private static final int proxyBPort = 1002;
-  private static final String proxyBHost = "proxyB";
-  private static final Proxy proxyB =
-      new Proxy(Proxy.Type.HTTP, new InetSocketAddress(proxyBHost, proxyBPort));
-  private static final URI uri;
-  private static final String uriHost = "hostA";
-  private static final int uriPort = 80;
-
-  private static final SSLContext sslContext;
-  private static final SSLSocketFactory socketFactory;
-  private static final HostnameVerifier hostnameVerifier;
-  private static final ConnectionPool pool;
-
-  static {
-    try {
-      uri = new URI("http://" + uriHost + ":" + uriPort + "/path");
-      sslContext = new SslContextBuilder(InetAddress.getLocalHost().getHostName()).build();
-      socketFactory = sslContext.getSocketFactory();
-      pool = ConnectionPool.getDefault();
-      hostnameVerifier = HttpsURLConnectionImpl.getDefaultHostnameVerifier();
-    } catch (Exception e) {
-      throw new AssertionError(e);
-    }
-  }
-
-  private final OkAuthenticator authenticator = HttpAuthenticator.SYSTEM_DEFAULT;
-  private final List<String> transports = Arrays.asList("http/1.1");
-  private final FakeDns dns = new FakeDns();
-  private final FakeProxySelector proxySelector = new FakeProxySelector();
-
-  @Test public void singleRoute() throws Exception {
-    Address address = new Address(uriHost, uriPort, null, null, authenticator, null, transports);
-    RouteSelector routeSelector = new RouteSelector(address, uri, proxySelector, pool, dns,
-        new RouteDatabase());
-
-    assertTrue(routeSelector.hasNext());
-    dns.inetAddresses = makeFakeAddresses(255, 1);
-    assertConnection(routeSelector.next("GET"), address, NO_PROXY, dns.inetAddresses[0], uriPort,
-        false);
-    dns.assertRequests(uriHost);
-
-    assertFalse(routeSelector.hasNext());
-    try {
-      routeSelector.next("GET");
-      fail();
-    } catch (NoSuchElementException expected) {
-    }
-  }
-
-  @Test public void singleRouteReturnsFailedRoute() throws Exception {
-    Address address = new Address(uriHost, uriPort, null, null, authenticator, null, transports);
-    RouteSelector routeSelector = new RouteSelector(address, uri, proxySelector, pool, dns,
-        new RouteDatabase());
-
-    assertTrue(routeSelector.hasNext());
-    dns.inetAddresses = makeFakeAddresses(255, 1);
-    Connection connection = routeSelector.next("GET");
-    RouteDatabase routeDatabase = new RouteDatabase();
-    routeDatabase.failed(connection.getRoute(), new IOException());
-    routeSelector = new RouteSelector(address, uri, proxySelector, pool, dns, routeDatabase);
-    assertConnection(routeSelector.next("GET"), address, NO_PROXY, dns.inetAddresses[0], uriPort,
-        false);
-    assertFalse(routeSelector.hasNext());
-    try {
-      routeSelector.next("GET");
-      fail();
-    } catch (NoSuchElementException expected) {
-    }
-  }
-
-  @Test public void explicitProxyTriesThatProxiesAddressesOnly() throws Exception {
-    Address address = new Address(uriHost, uriPort, null, null, authenticator, proxyA, transports);
-    RouteSelector routeSelector = new RouteSelector(address, uri, proxySelector, pool, dns,
-        new RouteDatabase());
-
-    assertTrue(routeSelector.hasNext());
-    dns.inetAddresses = makeFakeAddresses(255, 2);
-    assertConnection(routeSelector.next("GET"), address, proxyA, dns.inetAddresses[0], proxyAPort,
-        false);
-    assertConnection(routeSelector.next("GET"), address, proxyA, dns.inetAddresses[1], proxyAPort,
-        false);
-
-    assertFalse(routeSelector.hasNext());
-    dns.assertRequests(proxyAHost);
-    proxySelector.assertRequests(); // No proxy selector requests!
-  }
-
-  @Test public void explicitDirectProxy() throws Exception {
-    Address address = new Address(uriHost, uriPort, null, null, authenticator, NO_PROXY,
-        transports);
-    RouteSelector routeSelector = new RouteSelector(address, uri, proxySelector, pool, dns,
-        new RouteDatabase());
-
-    assertTrue(routeSelector.hasNext());
-    dns.inetAddresses = makeFakeAddresses(255, 2);
-    assertConnection(routeSelector.next("GET"), address, NO_PROXY, dns.inetAddresses[0], uriPort,
-        false);
-    assertConnection(routeSelector.next("GET"), address, NO_PROXY, dns.inetAddresses[1], uriPort,
-        false);
-
-    assertFalse(routeSelector.hasNext());
-    dns.assertRequests(uri.getHost());
-    proxySelector.assertRequests(); // No proxy selector requests!
-  }
-
-  @Test public void proxySelectorReturnsNull() throws Exception {
-    Address address = new Address(uriHost, uriPort, null, null, authenticator, null, transports);
-
-    proxySelector.proxies = null;
-    RouteSelector routeSelector = new RouteSelector(address, uri, proxySelector, pool, dns,
-        new RouteDatabase());
-    proxySelector.assertRequests(uri);
-
-    assertTrue(routeSelector.hasNext());
-    dns.inetAddresses = makeFakeAddresses(255, 1);
-    assertConnection(routeSelector.next("GET"), address, NO_PROXY, dns.inetAddresses[0], uriPort,
-        false);
-    dns.assertRequests(uriHost);
-
-    assertFalse(routeSelector.hasNext());
-  }
-
-  @Test public void proxySelectorReturnsNoProxies() throws Exception {
-    Address address = new Address(uriHost, uriPort, null, null, authenticator, null, transports);
-    RouteSelector routeSelector = new RouteSelector(address, uri, proxySelector, pool, dns,
-        new RouteDatabase());
-
-    assertTrue(routeSelector.hasNext());
-    dns.inetAddresses = makeFakeAddresses(255, 2);
-    assertConnection(routeSelector.next("GET"), address, NO_PROXY, dns.inetAddresses[0], uriPort,
-        false);
-    assertConnection(routeSelector.next("GET"), address, NO_PROXY, dns.inetAddresses[1], uriPort,
-        false);
-
-    assertFalse(routeSelector.hasNext());
-    dns.assertRequests(uri.getHost());
-    proxySelector.assertRequests(uri);
-  }
-
-  @Test public void proxySelectorReturnsMultipleProxies() throws Exception {
-    Address address = new Address(uriHost, uriPort, null, null, authenticator, null, transports);
-
-    proxySelector.proxies.add(proxyA);
-    proxySelector.proxies.add(proxyB);
-    RouteSelector routeSelector = new RouteSelector(address, uri, proxySelector, pool, dns,
-        new RouteDatabase());
-    proxySelector.assertRequests(uri);
-
-    // First try the IP addresses of the first proxy, in sequence.
-    assertTrue(routeSelector.hasNext());
-    dns.inetAddresses = makeFakeAddresses(255, 2);
-    assertConnection(routeSelector.next("GET"), address, proxyA, dns.inetAddresses[0], proxyAPort,
-        false);
-    assertConnection(routeSelector.next("GET"), address, proxyA, dns.inetAddresses[1], proxyAPort,
-        false);
-    dns.assertRequests(proxyAHost);
-
-    // Next try the IP address of the second proxy.
-    assertTrue(routeSelector.hasNext());
-    dns.inetAddresses = makeFakeAddresses(254, 1);
-    assertConnection(routeSelector.next("GET"), address, proxyB, dns.inetAddresses[0], proxyBPort,
-        false);
-    dns.assertRequests(proxyBHost);
-
-    // Finally try the only IP address of the origin server.
-    assertTrue(routeSelector.hasNext());
-    dns.inetAddresses = makeFakeAddresses(253, 1);
-    assertConnection(routeSelector.next("GET"), address, NO_PROXY, dns.inetAddresses[0], uriPort,
-        false);
-    dns.assertRequests(uriHost);
-
-    assertFalse(routeSelector.hasNext());
-  }
-
-  @Test public void proxySelectorDirectConnectionsAreSkipped() throws Exception {
-    Address address = new Address(uriHost, uriPort, null, null, authenticator, null, transports);
-
-    proxySelector.proxies.add(NO_PROXY);
-    RouteSelector routeSelector = new RouteSelector(address, uri, proxySelector, pool, dns,
-        new RouteDatabase());
-    proxySelector.assertRequests(uri);
-
-    // Only the origin server will be attempted.
-    assertTrue(routeSelector.hasNext());
-    dns.inetAddresses = makeFakeAddresses(255, 1);
-    assertConnection(routeSelector.next("GET"), address, NO_PROXY, dns.inetAddresses[0], uriPort,
-        false);
-    dns.assertRequests(uriHost);
-
-    assertFalse(routeSelector.hasNext());
-  }
-
-  @Test public void proxyDnsFailureContinuesToNextProxy() throws Exception {
-    Address address = new Address(uriHost, uriPort, null, null, authenticator, null, transports);
-
-    proxySelector.proxies.add(proxyA);
-    proxySelector.proxies.add(proxyB);
-    proxySelector.proxies.add(proxyA);
-    RouteSelector routeSelector = new RouteSelector(address, uri, proxySelector, pool, dns,
-        new RouteDatabase());
-    proxySelector.assertRequests(uri);
-
-    assertTrue(routeSelector.hasNext());
-    dns.inetAddresses = makeFakeAddresses(255, 1);
-    assertConnection(routeSelector.next("GET"), address, proxyA, dns.inetAddresses[0], proxyAPort,
-        false);
-    dns.assertRequests(proxyAHost);
-
-    assertTrue(routeSelector.hasNext());
-    dns.inetAddresses = null;
-    try {
-      routeSelector.next("GET");
-      fail();
-    } catch (UnknownHostException expected) {
-    }
-    dns.assertRequests(proxyBHost);
-
-    assertTrue(routeSelector.hasNext());
-    dns.inetAddresses = makeFakeAddresses(255, 1);
-    assertConnection(routeSelector.next("GET"), address, proxyA, dns.inetAddresses[0], proxyAPort,
-        false);
-    dns.assertRequests(proxyAHost);
-
-    assertTrue(routeSelector.hasNext());
-    dns.inetAddresses = makeFakeAddresses(254, 1);
-    assertConnection(routeSelector.next("GET"), address, NO_PROXY, dns.inetAddresses[0], uriPort,
-        false);
-    dns.assertRequests(uriHost);
-
-    assertFalse(routeSelector.hasNext());
-  }
-
-  @Test public void nonSslErrorAddsAllTlsModesToFailedRoute() throws Exception {
-    Address address = new Address(uriHost, uriPort, socketFactory, hostnameVerifier, authenticator,
-        Proxy.NO_PROXY, transports);
-    RouteDatabase routeDatabase = new RouteDatabase();
-    RouteSelector routeSelector = new RouteSelector(address, uri, proxySelector, pool, dns,
-        routeDatabase);
-
-    dns.inetAddresses = makeFakeAddresses(255, 1);
-    Connection connection = routeSelector.next("GET");
-    routeSelector.connectFailed(connection, new IOException("Non SSL exception"));
-    assertTrue(routeDatabase.failedRoutesCount() == 2);
-  }
-
-  @Test public void sslErrorAddsOnlyFailedTlsModeToFailedRoute() throws Exception {
-    Address address = new Address(uriHost, uriPort, socketFactory, hostnameVerifier, authenticator,
-        Proxy.NO_PROXY, transports);
-    RouteDatabase routeDatabase = new RouteDatabase();
-    RouteSelector routeSelector = new RouteSelector(address, uri, proxySelector, pool, dns,
-        routeDatabase);
-
-    dns.inetAddresses = makeFakeAddresses(255, 1);
-    Connection connection = routeSelector.next("GET");
-    routeSelector.connectFailed(connection, new SSLHandshakeException("SSL exception"));
-    assertTrue(routeDatabase.failedRoutesCount() == 1);
-  }
-
-  @Test public void multipleProxiesMultipleInetAddressesMultipleTlsModes() throws Exception {
-    Address address = new Address(uriHost, uriPort, socketFactory, hostnameVerifier, authenticator,
-        null, transports);
-    proxySelector.proxies.add(proxyA);
-    proxySelector.proxies.add(proxyB);
-    RouteSelector routeSelector = new RouteSelector(address, uri, proxySelector, pool, dns,
-        new RouteDatabase());
-
-    // Proxy A
-    dns.inetAddresses = makeFakeAddresses(255, 2);
-    assertConnection(routeSelector.next("GET"), address, proxyA, dns.inetAddresses[0], proxyAPort,
-        true);
-    dns.assertRequests(proxyAHost);
-    assertConnection(routeSelector.next("GET"), address, proxyA, dns.inetAddresses[0], proxyAPort,
-        false);
-    assertConnection(routeSelector.next("GET"), address, proxyA, dns.inetAddresses[1], proxyAPort,
-        true);
-    assertConnection(routeSelector.next("GET"), address, proxyA, dns.inetAddresses[1], proxyAPort,
-        false);
-
-    // Proxy B
-    dns.inetAddresses = makeFakeAddresses(254, 2);
-    assertConnection(routeSelector.next("GET"), address, proxyB, dns.inetAddresses[0], proxyBPort,
-        true);
-    dns.assertRequests(proxyBHost);
-    assertConnection(routeSelector.next("GET"), address, proxyB, dns.inetAddresses[0], proxyBPort,
-        false);
-    assertConnection(routeSelector.next("GET"), address, proxyB, dns.inetAddresses[1], proxyBPort,
-        true);
-    assertConnection(routeSelector.next("GET"), address, proxyB, dns.inetAddresses[1], proxyBPort,
-        false);
-
-    // Origin
-    dns.inetAddresses = makeFakeAddresses(253, 2);
-    assertConnection(routeSelector.next("GET"), address, NO_PROXY, dns.inetAddresses[0], uriPort,
-        true);
-    dns.assertRequests(uriHost);
-    assertConnection(routeSelector.next("GET"), address, NO_PROXY, dns.inetAddresses[0], uriPort,
-        false);
-    assertConnection(routeSelector.next("GET"), address, NO_PROXY, dns.inetAddresses[1], uriPort,
-        true);
-    assertConnection(routeSelector.next("GET"), address, NO_PROXY, dns.inetAddresses[1], uriPort,
-        false);
-
-    assertFalse(routeSelector.hasNext());
-  }
-
-  @Test public void failedRoutesAreLast() throws Exception {
-    Address address = new Address(uriHost, uriPort, socketFactory, hostnameVerifier, authenticator,
-        Proxy.NO_PROXY, transports);
-
-    RouteDatabase routeDatabase = new RouteDatabase();
-    RouteSelector routeSelector = new RouteSelector(address, uri, proxySelector, pool, dns,
-        routeDatabase);
-    dns.inetAddresses = makeFakeAddresses(255, 1);
-
-    // Extract the regular sequence of routes from selector.
-    List<Connection> regularRoutes = new ArrayList<Connection>();
-    while (routeSelector.hasNext()) {
-      regularRoutes.add(routeSelector.next("GET"));
-    }
-
-    // Check that we do indeed have more than one route.
-    assertTrue(regularRoutes.size() > 1);
-    // Add first regular route as failed.
-    routeDatabase.failed(regularRoutes.get(0).getRoute(), new SSLHandshakeException("none"));
-    // Reset selector
-    routeSelector = new RouteSelector(address, uri, proxySelector, pool, dns, routeDatabase);
-
-    List<Connection> routesWithFailedRoute = new ArrayList<Connection>();
-    while (routeSelector.hasNext()) {
-      routesWithFailedRoute.add(routeSelector.next("GET"));
-    }
-
-    assertEquals(regularRoutes.get(0).getRoute(),
-        routesWithFailedRoute.get(routesWithFailedRoute.size() - 1).getRoute());
-    assertEquals(regularRoutes.size(), routesWithFailedRoute.size());
-  }
-
-  private void assertConnection(Connection connection, Address address, Proxy proxy,
-      InetAddress socketAddress, int socketPort, boolean modernTls) {
-    assertEquals(address, connection.getRoute().getAddress());
-    assertEquals(proxy, connection.getRoute().getProxy());
-    assertEquals(socketAddress, connection.getRoute().getSocketAddress().getAddress());
-    assertEquals(socketPort, connection.getRoute().getSocketAddress().getPort());
-    assertEquals(modernTls, connection.getRoute().isModernTls());
-  }
-
-  private static InetAddress[] makeFakeAddresses(int prefix, int count) {
-    try {
-      InetAddress[] result = new InetAddress[count];
-      for (int i = 0; i < count; i++) {
-        result[i] =
-            InetAddress.getByAddress(new byte[] { (byte) prefix, (byte) 0, (byte) 0, (byte) i });
-      }
-      return result;
-    } catch (UnknownHostException e) {
-      throw new AssertionError();
-    }
-  }
-
-  private static class FakeDns implements Dns {
-    List<String> requestedHosts = new ArrayList<String>();
-    InetAddress[] inetAddresses;
-
-    @Override public InetAddress[] getAllByName(String host) throws UnknownHostException {
-      requestedHosts.add(host);
-      if (inetAddresses == null) throw new UnknownHostException();
-      return inetAddresses;
-    }
-
-    public void assertRequests(String... expectedHosts) {
-      assertEquals(Arrays.asList(expectedHosts), requestedHosts);
-      requestedHosts.clear();
-    }
-  }
-
-  private static class FakeProxySelector extends ProxySelector {
-    List<URI> requestedUris = new ArrayList<URI>();
-    List<Proxy> proxies = new ArrayList<Proxy>();
-    List<String> failures = new ArrayList<String>();
-
-    @Override public List<Proxy> select(URI uri) {
-      requestedUris.add(uri);
-      return proxies;
-    }
-
-    public void assertRequests(URI... expectedUris) {
-      assertEquals(Arrays.asList(expectedUris), requestedUris);
-      requestedUris.clear();
-    }
-
-    @Override public void connectFailed(URI uri, SocketAddress sa, IOException ioe) {
-      InetSocketAddress socketAddress = (InetSocketAddress) sa;
-      failures.add(
-          String.format("%s %s:%d %s", uri, socketAddress.getHostName(), socketAddress.getPort(),
-              ioe.getMessage()));
-    }
-  }
-}
diff --git a/okhttp/src/test/java/com/squareup/okhttp/internal/http/URLConnectionTest.java b/okhttp/src/test/java/com/squareup/okhttp/internal/http/URLConnectionTest.java
deleted file mode 100644
index f59df39c37..0000000000
--- a/okhttp/src/test/java/com/squareup/okhttp/internal/http/URLConnectionTest.java
+++ /dev/null
@@ -1,2681 +0,0 @@
-/*
- * Copyright (C) 2009 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.squareup.okhttp.internal.http;
-
-import com.squareup.okhttp.mockwebserver.MockResponse;
-import com.squareup.okhttp.mockwebserver.MockWebServer;
-import com.squareup.okhttp.mockwebserver.RecordedRequest;
-import com.squareup.okhttp.mockwebserver.SocketPolicy;
-import com.squareup.okhttp.HttpResponseCache;
-import com.squareup.okhttp.OkHttpClient;
-import com.squareup.okhttp.internal.RecordingAuthenticator;
-import com.squareup.okhttp.internal.RecordingHostnameVerifier;
-import com.squareup.okhttp.internal.RecordingOkAuthenticator;
-import com.squareup.okhttp.internal.SslContextBuilder;
-import java.io.ByteArrayOutputStream;
-import java.io.File;
-import java.io.IOException;
-import java.io.InputStream;
-import java.io.OutputStream;
-import java.net.Authenticator;
-import java.net.CacheRequest;
-import java.net.CacheResponse;
-import java.net.ConnectException;
-import java.net.HttpRetryException;
-import java.net.HttpURLConnection;
-import java.net.InetAddress;
-import java.net.ProtocolException;
-import java.net.Proxy;
-import java.net.ProxySelector;
-import java.net.ResponseCache;
-import java.net.SocketAddress;
-import java.net.SocketTimeoutException;
-import java.net.URI;
-import java.net.URL;
-import java.net.URLConnection;
-import java.net.UnknownHostException;
-import java.security.GeneralSecurityException;
-import java.security.cert.CertificateException;
-import java.security.cert.X509Certificate;
-import java.util.ArrayList;
-import java.util.Arrays;
-import java.util.Collections;
-import java.util.HashSet;
-import java.util.Iterator;
-import java.util.List;
-import java.util.Map;
-import java.util.Random;
-import java.util.Set;
-import java.util.UUID;
-import java.util.concurrent.atomic.AtomicBoolean;
-import java.util.zip.GZIPInputStream;
-import java.util.zip.GZIPOutputStream;
-import javax.net.ssl.HttpsURLConnection;
-import javax.net.ssl.SSLContext;
-import javax.net.ssl.SSLException;
-import javax.net.ssl.SSLHandshakeException;
-import javax.net.ssl.SSLSocketFactory;
-import javax.net.ssl.TrustManager;
-import javax.net.ssl.X509TrustManager;
-import org.junit.After;
-import org.junit.Before;
-import org.junit.Ignore;
-import org.junit.Test;
-
-import static com.squareup.okhttp.mockwebserver.SocketPolicy.DISCONNECT_AT_END;
-import static com.squareup.okhttp.mockwebserver.SocketPolicy.DISCONNECT_AT_START;
-import static com.squareup.okhttp.mockwebserver.SocketPolicy.SHUTDOWN_INPUT_AT_END;
-import static com.squareup.okhttp.mockwebserver.SocketPolicy.SHUTDOWN_OUTPUT_AT_END;
-import static com.squareup.okhttp.OkAuthenticator.Credential;
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertFalse;
-import static org.junit.Assert.assertNull;
-import static org.junit.Assert.assertTrue;
-import static org.junit.Assert.fail;
-
-/** Android's URLConnectionTest. */
-public final class URLConnectionTest {
-  private MockWebServer server = new MockWebServer();
-  private MockWebServer server2 = new MockWebServer();
-
-  private final OkHttpClient client = new OkHttpClient();
-  private HttpResponseCache cache;
-  private String hostName;
-
-  private static final SSLContext sslContext;
-  static {
-    try {
-      sslContext = new SslContextBuilder(InetAddress.getLocalHost().getHostName()).build();
-    } catch (GeneralSecurityException e) {
-      throw new RuntimeException(e);
-    } catch (UnknownHostException e) {
-      throw new RuntimeException(e);
-    }
-  }
-
-  @Before public void setUp() throws Exception {
-    hostName = server.getHostName();
-    server.setNpnEnabled(false);
-  }
-
-  @After public void tearDown() throws Exception {
-    Authenticator.setDefault(null);
-    System.clearProperty("proxyHost");
-    System.clearProperty("proxyPort");
-    System.clearProperty("http.proxyHost");
-    System.clearProperty("http.proxyPort");
-    System.clearProperty("https.proxyHost");
-    System.clearProperty("https.proxyPort");
-    server.shutdown();
-    server2.shutdown();
-    if (cache != null) {
-      cache.delete();
-    }
-  }
-
-  @Test public void requestHeaders() throws IOException, InterruptedException {
-    server.enqueue(new MockResponse());
-    server.play();
-
-    HttpURLConnection urlConnection = client.open(server.getUrl("/"));
-    urlConnection.addRequestProperty("D", "e");
-    urlConnection.addRequestProperty("D", "f");
-    assertEquals("f", urlConnection.getRequestProperty("D"));
-    assertEquals("f", urlConnection.getRequestProperty("d"));
-    Map<String, List<String>> requestHeaders = urlConnection.getRequestProperties();
-    assertEquals(newSet("e", "f"), new HashSet<String>(requestHeaders.get("D")));
-    assertEquals(newSet("e", "f"), new HashSet<String>(requestHeaders.get("d")));
-    try {
-      requestHeaders.put("G", Arrays.asList("h"));
-      fail("Modified an unmodifiable view.");
-    } catch (UnsupportedOperationException expected) {
-    }
-    try {
-      requestHeaders.get("D").add("i");
-      fail("Modified an unmodifiable view.");
-    } catch (UnsupportedOperationException expected) {
-    }
-    try {
-      urlConnection.setRequestProperty(null, "j");
-      fail();
-    } catch (NullPointerException expected) {
-    }
-    try {
-      urlConnection.addRequestProperty(null, "k");
-      fail();
-    } catch (NullPointerException expected) {
-    }
-    urlConnection.setRequestProperty("NullValue", null);
-    assertNull(urlConnection.getRequestProperty("NullValue"));
-    urlConnection.addRequestProperty("AnotherNullValue", null);
-    assertNull(urlConnection.getRequestProperty("AnotherNullValue"));
-
-    urlConnection.getResponseCode();
-    RecordedRequest request = server.takeRequest();
-    assertContains(request.getHeaders(), "D: e");
-    assertContains(request.getHeaders(), "D: f");
-    assertContainsNoneMatching(request.getHeaders(), "NullValue.*");
-    assertContainsNoneMatching(request.getHeaders(), "AnotherNullValue.*");
-    assertContainsNoneMatching(request.getHeaders(), "G:.*");
-    assertContainsNoneMatching(request.getHeaders(), "null:.*");
-
-    try {
-      urlConnection.addRequestProperty("N", "o");
-      fail("Set header after connect");
-    } catch (IllegalStateException expected) {
-    }
-    try {
-      urlConnection.setRequestProperty("P", "q");
-      fail("Set header after connect");
-    } catch (IllegalStateException expected) {
-    }
-    try {
-      urlConnection.getRequestProperties();
-      fail();
-    } catch (IllegalStateException expected) {
-    }
-  }
-
-  @Test public void getRequestPropertyReturnsLastValue() throws Exception {
-    server.play();
-    HttpURLConnection urlConnection = client.open(server.getUrl("/"));
-    urlConnection.addRequestProperty("A", "value1");
-    urlConnection.addRequestProperty("A", "value2");
-    assertEquals("value2", urlConnection.getRequestProperty("A"));
-  }
-
-  @Test public void responseHeaders() throws IOException, InterruptedException {
-    server.enqueue(new MockResponse().setStatus("HTTP/1.0 200 Fantastic")
-        .addHeader("A: c")
-        .addHeader("B: d")
-        .addHeader("A: e")
-        .setChunkedBody("ABCDE\nFGHIJ\nKLMNO\nPQR", 8));
-    server.play();
-
-    HttpURLConnection urlConnection = client.open(server.getUrl("/"));
-    assertEquals(200, urlConnection.getResponseCode());
-    assertEquals("Fantastic", urlConnection.getResponseMessage());
-    assertEquals("HTTP/1.0 200 Fantastic", urlConnection.getHeaderField(null));
-    Map<String, List<String>> responseHeaders = urlConnection.getHeaderFields();
-    assertEquals(Arrays.asList("HTTP/1.0 200 Fantastic"), responseHeaders.get(null));
-    assertEquals(newSet("c", "e"), new HashSet<String>(responseHeaders.get("A")));
-    assertEquals(newSet("c", "e"), new HashSet<String>(responseHeaders.get("a")));
-    try {
-      responseHeaders.put("N", Arrays.asList("o"));
-      fail("Modified an unmodifiable view.");
-    } catch (UnsupportedOperationException expected) {
-    }
-    try {
-      responseHeaders.get("A").add("f");
-      fail("Modified an unmodifiable view.");
-    } catch (UnsupportedOperationException expected) {
-    }
-    assertEquals("A", urlConnection.getHeaderFieldKey(0));
-    assertEquals("c", urlConnection.getHeaderField(0));
-    assertEquals("B", urlConnection.getHeaderFieldKey(1));
-    assertEquals("d", urlConnection.getHeaderField(1));
-    assertEquals("A", urlConnection.getHeaderFieldKey(2));
-    assertEquals("e", urlConnection.getHeaderField(2));
-  }
-
-  @Test public void serverSendsInvalidResponseHeaders() throws Exception {
-    server.enqueue(new MockResponse().setStatus("HTP/1.1 200 OK"));
-    server.play();
-
-    HttpURLConnection urlConnection = client.open(server.getUrl("/"));
-    try {
-      urlConnection.getResponseCode();
-      fail();
-    } catch (IOException expected) {
-    }
-  }
-
-  @Test public void serverSendsInvalidCodeTooLarge() throws Exception {
-    server.enqueue(new MockResponse().setStatus("HTTP/1.1 2147483648 OK"));
-    server.play();
-
-    HttpURLConnection urlConnection = client.open(server.getUrl("/"));
-    try {
-      urlConnection.getResponseCode();
-      fail();
-    } catch (IOException expected) {
-    }
-  }
-
-  @Test public void serverSendsInvalidCodeNotANumber() throws Exception {
-    server.enqueue(new MockResponse().setStatus("HTTP/1.1 00a OK"));
-    server.play();
-
-    HttpURLConnection urlConnection = client.open(server.getUrl("/"));
-    try {
-      urlConnection.getResponseCode();
-      fail();
-    } catch (IOException expected) {
-    }
-  }
-
-  @Test public void serverSendsUnnecessaryWhitespace() throws Exception {
-    server.enqueue(new MockResponse().setStatus(" HTTP/1.1 2147483648 OK"));
-    server.play();
-
-    HttpURLConnection urlConnection = client.open(server.getUrl("/"));
-    try {
-      urlConnection.getResponseCode();
-      fail();
-    } catch (IOException expected) {
-    }
-  }
-
-  @Test public void connectRetriesUntilConnectedOrFailed() throws Exception {
-    server.play();
-    URL url = server.getUrl("/foo");
-    server.shutdown();
-
-    HttpURLConnection connection = client.open(url);
-    try {
-      connection.connect();
-      fail();
-    } catch (IOException expected) {
-    }
-  }
-
-  @Test public void requestBodySurvivesRetriesWithFixedLength() throws Exception {
-    testRequestBodySurvivesRetries(TransferKind.FIXED_LENGTH);
-  }
-
-  @Test public void requestBodySurvivesRetriesWithChunkedStreaming() throws Exception {
-    testRequestBodySurvivesRetries(TransferKind.CHUNKED);
-  }
-
-  @Test public void requestBodySurvivesRetriesWithBufferedBody() throws Exception {
-    testRequestBodySurvivesRetries(TransferKind.END_OF_STREAM);
-  }
-
-  private void testRequestBodySurvivesRetries(TransferKind transferKind) throws Exception {
-    server.enqueue(new MockResponse().setBody("abc"));
-    server.play();
-
-    // Use a misconfigured proxy to guarantee that the request is retried.
-    server2.play();
-    FakeProxySelector proxySelector = new FakeProxySelector();
-    proxySelector.proxies.add(server2.toProxyAddress());
-    client.setProxySelector(proxySelector);
-    server2.shutdown();
-
-    HttpURLConnection connection = client.open(server.getUrl("/def"));
-    connection.setDoOutput(true);
-    transferKind.setForRequest(connection, 4);
-    connection.getOutputStream().write("body".getBytes("UTF-8"));
-    assertContent("abc", connection);
-
-    assertEquals("body", server.takeRequest().getUtf8Body());
-  }
-
-  @Test public void getErrorStreamOnSuccessfulRequest() throws Exception {
-    server.enqueue(new MockResponse().setBody("A"));
-    server.play();
-    HttpURLConnection connection = client.open(server.getUrl("/"));
-    assertNull(connection.getErrorStream());
-  }
-
-  @Test public void getErrorStreamOnUnsuccessfulRequest() throws Exception {
-    server.enqueue(new MockResponse().setResponseCode(404).setBody("A"));
-    server.play();
-    HttpURLConnection connection = client.open(server.getUrl("/"));
-    assertEquals("A", readAscii(connection.getErrorStream(), Integer.MAX_VALUE));
-  }
-
-  // Check that if we don't read to the end of a response, the next request on the
-  // recycled connection doesn't get the unread tail of the first request's response.
-  // http://code.google.com/p/android/issues/detail?id=2939
-  @Test public void bug2939() throws Exception {
-    MockResponse response = new MockResponse().setChunkedBody("ABCDE\nFGHIJ\nKLMNO\nPQR", 8);
-
-    server.enqueue(response);
-    server.enqueue(response);
-    server.play();
-
-    assertContent("ABCDE", client.open(server.getUrl("/")), 5);
-    assertContent("ABCDE", client.open(server.getUrl("/")), 5);
-  }
-
-  // Check that we recognize a few basic mime types by extension.
-  // http://code.google.com/p/android/issues/detail?id=10100
-  @Test public void bug10100() throws Exception {
-    assertEquals("image/jpeg", URLConnection.guessContentTypeFromName("someFile.jpg"));
-    assertEquals("application/pdf", URLConnection.guessContentTypeFromName("stuff.pdf"));
-  }
-
-  @Test public void connectionsArePooled() throws Exception {
-    MockResponse response = new MockResponse().setBody("ABCDEFGHIJKLMNOPQR");
-
-    server.enqueue(response);
-    server.enqueue(response);
-    server.enqueue(response);
-    server.play();
-
-    assertContent("ABCDEFGHIJKLMNOPQR", client.open(server.getUrl("/foo")));
-    assertEquals(0, server.takeRequest().getSequenceNumber());
-    assertContent("ABCDEFGHIJKLMNOPQR", client.open(server.getUrl("/bar?baz=quux")));
-    assertEquals(1, server.takeRequest().getSequenceNumber());
-    assertContent("ABCDEFGHIJKLMNOPQR", client.open(server.getUrl("/z")));
-    assertEquals(2, server.takeRequest().getSequenceNumber());
-  }
-
-  @Test public void chunkedConnectionsArePooled() throws Exception {
-    MockResponse response = new MockResponse().setChunkedBody("ABCDEFGHIJKLMNOPQR", 5);
-
-    server.enqueue(response);
-    server.enqueue(response);
-    server.enqueue(response);
-    server.play();
-
-    assertContent("ABCDEFGHIJKLMNOPQR", client.open(server.getUrl("/foo")));
-    assertEquals(0, server.takeRequest().getSequenceNumber());
-    assertContent("ABCDEFGHIJKLMNOPQR", client.open(server.getUrl("/bar?baz=quux")));
-    assertEquals(1, server.takeRequest().getSequenceNumber());
-    assertContent("ABCDEFGHIJKLMNOPQR", client.open(server.getUrl("/z")));
-    assertEquals(2, server.takeRequest().getSequenceNumber());
-  }
-
-  @Test public void serverClosesSocket() throws Exception {
-    testServerClosesOutput(DISCONNECT_AT_END);
-  }
-
-  @Test public void serverShutdownInput() throws Exception {
-    testServerClosesOutput(SHUTDOWN_INPUT_AT_END);
-  }
-
-  @Test public void serverShutdownOutput() throws Exception {
-    testServerClosesOutput(SHUTDOWN_OUTPUT_AT_END);
-  }
-
-  private void testServerClosesOutput(SocketPolicy socketPolicy) throws Exception {
-    server.enqueue(new MockResponse().setBody("This connection won't pool properly")
-        .setSocketPolicy(socketPolicy));
-    MockResponse responseAfter = new MockResponse().setBody("This comes after a busted connection");
-    server.enqueue(responseAfter);
-    server.enqueue(responseAfter); // Enqueue 2x because the broken connection may be reused.
-    server.play();
-
-    HttpURLConnection connection1 = client.open(server.getUrl("/a"));
-    connection1.setReadTimeout(100);
-    assertContent("This connection won't pool properly", connection1);
-    assertEquals(0, server.takeRequest().getSequenceNumber());
-    HttpURLConnection connection2 = client.open(server.getUrl("/b"));
-    connection2.setReadTimeout(100);
-    assertContent("This comes after a busted connection", connection2);
-
-    // Check that a fresh connection was created, either immediately or after attempting reuse.
-    RecordedRequest requestAfter = server.takeRequest();
-    if (server.getRequestCount() == 3) {
-      requestAfter = server.takeRequest(); // The failure consumed a response.
-    }
-    // sequence number 0 means the HTTP socket connection was not reused
-    assertEquals(0, requestAfter.getSequenceNumber());
-  }
-
-  enum WriteKind {BYTE_BY_BYTE, SMALL_BUFFERS, LARGE_BUFFERS}
-
-  @Test public void chunkedUpload_byteByByte() throws Exception {
-    doUpload(TransferKind.CHUNKED, WriteKind.BYTE_BY_BYTE);
-  }
-
-  @Test public void chunkedUpload_smallBuffers() throws Exception {
-    doUpload(TransferKind.CHUNKED, WriteKind.SMALL_BUFFERS);
-  }
-
-  @Test public void chunkedUpload_largeBuffers() throws Exception {
-    doUpload(TransferKind.CHUNKED, WriteKind.LARGE_BUFFERS);
-  }
-
-  @Test public void fixedLengthUpload_byteByByte() throws Exception {
-    doUpload(TransferKind.FIXED_LENGTH, WriteKind.BYTE_BY_BYTE);
-  }
-
-  @Test public void fixedLengthUpload_smallBuffers() throws Exception {
-    doUpload(TransferKind.FIXED_LENGTH, WriteKind.SMALL_BUFFERS);
-  }
-
-  @Test public void fixedLengthUpload_largeBuffers() throws Exception {
-    doUpload(TransferKind.FIXED_LENGTH, WriteKind.LARGE_BUFFERS);
-  }
-
-  private void doUpload(TransferKind uploadKind, WriteKind writeKind) throws Exception {
-    int n = 512 * 1024;
-    server.setBodyLimit(0);
-    server.enqueue(new MockResponse());
-    server.play();
-
-    HttpURLConnection conn = client.open(server.getUrl("/"));
-    conn.setDoOutput(true);
-    conn.setRequestMethod("POST");
-    if (uploadKind == TransferKind.CHUNKED) {
-      conn.setChunkedStreamingMode(-1);
-    } else {
-      conn.setFixedLengthStreamingMode(n);
-    }
-    OutputStream out = conn.getOutputStream();
-    if (writeKind == WriteKind.BYTE_BY_BYTE) {
-      for (int i = 0; i < n; ++i) {
-        out.write('x');
-      }
-    } else {
-      byte[] buf = new byte[writeKind == WriteKind.SMALL_BUFFERS ? 256 : 64 * 1024];
-      Arrays.fill(buf, (byte) 'x');
-      for (int i = 0; i < n; i += buf.length) {
-        out.write(buf, 0, Math.min(buf.length, n - i));
-      }
-    }
-    out.close();
-    assertEquals(200, conn.getResponseCode());
-    RecordedRequest request = server.takeRequest();
-    assertEquals(n, request.getBodySize());
-    if (uploadKind == TransferKind.CHUNKED) {
-      assertTrue(request.getChunkSizes().size() > 0);
-    } else {
-      assertTrue(request.getChunkSizes().isEmpty());
-    }
-  }
-
-  @Test public void getResponseCodeNoResponseBody() throws Exception {
-    server.enqueue(new MockResponse().addHeader("abc: def"));
-    server.play();
-
-    URL url = server.getUrl("/");
-    HttpURLConnection conn = client.open(url);
-    conn.setDoInput(false);
-    assertEquals("def", conn.getHeaderField("abc"));
-    assertEquals(200, conn.getResponseCode());
-    try {
-      conn.getInputStream();
-      fail();
-    } catch (ProtocolException expected) {
-    }
-  }
-
-  @Test public void connectViaHttps() throws Exception {
-    server.useHttps(sslContext.getSocketFactory(), false);
-    server.enqueue(new MockResponse().setBody("this response comes via HTTPS"));
-    server.play();
-
-    client.setSslSocketFactory(sslContext.getSocketFactory());
-    client.setHostnameVerifier(new RecordingHostnameVerifier());
-    HttpURLConnection connection = client.open(server.getUrl("/foo"));
-
-    assertContent("this response comes via HTTPS", connection);
-
-    RecordedRequest request = server.takeRequest();
-    assertEquals("GET /foo HTTP/1.1", request.getRequestLine());
-  }
-
-  @Test public void connectViaHttpsReusingConnections() throws IOException, InterruptedException {
-    server.useHttps(sslContext.getSocketFactory(), false);
-    server.enqueue(new MockResponse().setBody("this response comes via HTTPS"));
-    server.enqueue(new MockResponse().setBody("another response via HTTPS"));
-    server.play();
-
-    // The pool will only reuse sockets if the SSL socket factories are the same.
-    SSLSocketFactory clientSocketFactory = sslContext.getSocketFactory();
-    RecordingHostnameVerifier hostnameVerifier = new RecordingHostnameVerifier();
-
-    client.setSslSocketFactory(clientSocketFactory);
-    client.setHostnameVerifier(hostnameVerifier);
-    HttpURLConnection connection = client.open(server.getUrl("/"));
-    assertContent("this response comes via HTTPS", connection);
-
-    connection = client.open(server.getUrl("/"));
-    assertContent("another response via HTTPS", connection);
-
-    assertEquals(0, server.takeRequest().getSequenceNumber());
-    assertEquals(1, server.takeRequest().getSequenceNumber());
-  }
-
-  @Test public void connectViaHttpsReusingConnectionsDifferentFactories()
-      throws IOException, InterruptedException {
-    server.useHttps(sslContext.getSocketFactory(), false);
-    server.enqueue(new MockResponse().setBody("this response comes via HTTPS"));
-    server.enqueue(new MockResponse().setBody("another response via HTTPS"));
-    server.play();
-
-    // install a custom SSL socket factory so the server can be authorized
-    client.setSslSocketFactory(sslContext.getSocketFactory());
-    client.setHostnameVerifier(new RecordingHostnameVerifier());
-    HttpURLConnection connection1 = client.open(server.getUrl("/"));
-    assertContent("this response comes via HTTPS", connection1);
-
-    client.setSslSocketFactory(null);
-    HttpURLConnection connection2 = client.open(server.getUrl("/"));
-    try {
-      readAscii(connection2.getInputStream(), Integer.MAX_VALUE);
-      fail("without an SSL socket factory, the connection should fail");
-    } catch (SSLException expected) {
-    }
-  }
-
-  @Test public void connectViaHttpsWithSSLFallback() throws IOException, InterruptedException {
-    server.useHttps(sslContext.getSocketFactory(), false);
-    server.enqueue(new MockResponse().setSocketPolicy(SocketPolicy.FAIL_HANDSHAKE));
-    server.enqueue(new MockResponse().setBody("this response comes via SSL"));
-    server.play();
-
-    client.setSslSocketFactory(sslContext.getSocketFactory());
-    client.setHostnameVerifier(new RecordingHostnameVerifier());
-    HttpURLConnection connection = client.open(server.getUrl("/foo"));
-
-    assertContent("this response comes via SSL", connection);
-
-    RecordedRequest request = server.takeRequest();
-    assertEquals("GET /foo HTTP/1.1", request.getRequestLine());
-  }
-
-  /**
-   * Verify that we don't retry connections on certificate verification errors.
-   *
-   * http://code.google.com/p/android/issues/detail?id=13178
-   */
-  @Test public void connectViaHttpsToUntrustedServer() throws IOException, InterruptedException {
-    server.useHttps(sslContext.getSocketFactory(), false);
-    server.enqueue(new MockResponse()); // unused
-    server.play();
-
-    HttpURLConnection connection = client.open(server.getUrl("/foo"));
-    try {
-      connection.getInputStream();
-      fail();
-    } catch (SSLHandshakeException expected) {
-      assertTrue(expected.getCause() instanceof CertificateException);
-    }
-    assertEquals(0, server.getRequestCount());
-  }
-
-  @Test public void connectViaProxyUsingProxyArg() throws Exception {
-    testConnectViaProxy(ProxyConfig.CREATE_ARG);
-  }
-
-  @Test public void connectViaProxyUsingProxySystemProperty() throws Exception {
-    testConnectViaProxy(ProxyConfig.PROXY_SYSTEM_PROPERTY);
-  }
-
-  @Test public void connectViaProxyUsingHttpProxySystemProperty() throws Exception {
-    testConnectViaProxy(ProxyConfig.HTTP_PROXY_SYSTEM_PROPERTY);
-  }
-
-  private void testConnectViaProxy(ProxyConfig proxyConfig) throws Exception {
-    MockResponse mockResponse = new MockResponse().setBody("this response comes via a proxy");
-    server.enqueue(mockResponse);
-    server.play();
-
-    URL url = new URL("http://android.com/foo");
-    HttpURLConnection connection = proxyConfig.connect(server, client, url);
-    assertContent("this response comes via a proxy", connection);
-
-    RecordedRequest request = server.takeRequest();
-    assertEquals("GET http://android.com/foo HTTP/1.1", request.getRequestLine());
-    assertContains(request.getHeaders(), "Host: android.com");
-  }
-
-  @Test public void contentDisagreesWithContentLengthHeader() throws IOException {
-    server.enqueue(new MockResponse().setBody("abc\r\nYOU SHOULD NOT SEE THIS")
-        .clearHeaders()
-        .addHeader("Content-Length: 3"));
-    server.play();
-
-    assertContent("abc", client.open(server.getUrl("/")));
-  }
-
-  @Test public void contentDisagreesWithChunkedHeader() throws IOException {
-    MockResponse mockResponse = new MockResponse();
-    mockResponse.setChunkedBody("abc", 3);
-    ByteArrayOutputStream bytesOut = new ByteArrayOutputStream();
-    bytesOut.write(mockResponse.getBody());
-    bytesOut.write("\r\nYOU SHOULD NOT SEE THIS".getBytes("UTF-8"));
-    mockResponse.setBody(bytesOut.toByteArray());
-    mockResponse.clearHeaders();
-    mockResponse.addHeader("Transfer-encoding: chunked");
-
-    server.enqueue(mockResponse);
-    server.play();
-
-    assertContent("abc", client.open(server.getUrl("/")));
-  }
-
-  @Test public void connectViaHttpProxyToHttpsUsingProxyArgWithNoProxy() throws Exception {
-    testConnectViaDirectProxyToHttps(ProxyConfig.NO_PROXY);
-  }
-
-  @Test public void connectViaHttpProxyToHttpsUsingHttpProxySystemProperty() throws Exception {
-    // https should not use http proxy
-    testConnectViaDirectProxyToHttps(ProxyConfig.HTTP_PROXY_SYSTEM_PROPERTY);
-  }
-
-  private void testConnectViaDirectProxyToHttps(ProxyConfig proxyConfig) throws Exception {
-    server.useHttps(sslContext.getSocketFactory(), false);
-    server.enqueue(new MockResponse().setBody("this response comes via HTTPS"));
-    server.play();
-
-    URL url = server.getUrl("/foo");
-    client.setSslSocketFactory(sslContext.getSocketFactory());
-    client.setHostnameVerifier(new RecordingHostnameVerifier());
-    HttpURLConnection connection = proxyConfig.connect(server, client, url);
-
-    assertContent("this response comes via HTTPS", connection);
-
-    RecordedRequest request = server.takeRequest();
-    assertEquals("GET /foo HTTP/1.1", request.getRequestLine());
-  }
-
-  @Test public void connectViaHttpProxyToHttpsUsingProxyArg() throws Exception {
-    testConnectViaHttpProxyToHttps(ProxyConfig.CREATE_ARG);
-  }
-
-  /**
-   * We weren't honoring all of the appropriate proxy system properties when
-   * connecting via HTTPS. http://b/3097518
-   */
-  @Test public void connectViaHttpProxyToHttpsUsingProxySystemProperty() throws Exception {
-    testConnectViaHttpProxyToHttps(ProxyConfig.PROXY_SYSTEM_PROPERTY);
-  }
-
-  @Test public void connectViaHttpProxyToHttpsUsingHttpsProxySystemProperty() throws Exception {
-    testConnectViaHttpProxyToHttps(ProxyConfig.HTTPS_PROXY_SYSTEM_PROPERTY);
-  }
-
-  /**
-   * We were verifying the wrong hostname when connecting to an HTTPS site
-   * through a proxy. http://b/3097277
-   */
-  private void testConnectViaHttpProxyToHttps(ProxyConfig proxyConfig) throws Exception {
-    RecordingHostnameVerifier hostnameVerifier = new RecordingHostnameVerifier();
-
-    server.useHttps(sslContext.getSocketFactory(), true);
-    server.enqueue(
-        new MockResponse().setSocketPolicy(SocketPolicy.UPGRADE_TO_SSL_AT_END).clearHeaders());
-    server.enqueue(new MockResponse().setBody("this response comes via a secure proxy"));
-    server.play();
-
-    URL url = new URL("https://android.com/foo");
-    client.setSslSocketFactory(sslContext.getSocketFactory());
-    client.setHostnameVerifier(hostnameVerifier);
-    HttpURLConnection connection = proxyConfig.connect(server, client, url);
-
-    assertContent("this response comes via a secure proxy", connection);
-
-    RecordedRequest connect = server.takeRequest();
-    assertEquals("Connect line failure on proxy", "CONNECT android.com:443 HTTP/1.1",
-        connect.getRequestLine());
-    assertContains(connect.getHeaders(), "Host: android.com");
-
-    RecordedRequest get = server.takeRequest();
-    assertEquals("GET /foo HTTP/1.1", get.getRequestLine());
-    assertContains(get.getHeaders(), "Host: android.com");
-    assertEquals(Arrays.asList("verify android.com"), hostnameVerifier.calls);
-  }
-
-  /** Tolerate bad https proxy response when using HttpResponseCache. http://b/6754912 */
-  @Test public void connectViaHttpProxyToHttpsUsingBadProxyAndHttpResponseCache() throws Exception {
-    initResponseCache();
-
-    server.useHttps(sslContext.getSocketFactory(), true);
-    MockResponse response = new MockResponse() // Key to reproducing b/6754912
-        .setSocketPolicy(SocketPolicy.UPGRADE_TO_SSL_AT_END)
-        .setBody("bogus proxy connect response content");
-
-    // Enqueue a pair of responses for every IP address held by localhost, because the
-    // route selector will try each in sequence.
-    // TODO: use the fake Dns implementation instead of a loop
-    for (InetAddress inetAddress : InetAddress.getAllByName(server.getHostName())) {
-      server.enqueue(response); // For the first TLS tolerant connection
-      server.enqueue(response); // For the backwards-compatible SSLv3 retry
-    }
-    server.play();
-    client.setProxy(server.toProxyAddress());
-
-    URL url = new URL("https://android.com/foo");
-    client.setSslSocketFactory(sslContext.getSocketFactory());
-    HttpURLConnection connection = client.open(url);
-
-    try {
-      connection.getResponseCode();
-      fail();
-    } catch (IOException expected) {
-      // Thrown when the connect causes SSLSocket.startHandshake() to throw
-      // when it sees the "bogus proxy connect response content"
-      // instead of a ServerHello handshake message.
-    }
-
-    RecordedRequest connect = server.takeRequest();
-    assertEquals("Connect line failure on proxy", "CONNECT android.com:443 HTTP/1.1",
-        connect.getRequestLine());
-    assertContains(connect.getHeaders(), "Host: android.com");
-  }
-
-  private void initResponseCache() throws IOException {
-    String tmp = System.getProperty("java.io.tmpdir");
-    File cacheDir = new File(tmp, "HttpCache-" + UUID.randomUUID());
-    cache = new HttpResponseCache(cacheDir, Integer.MAX_VALUE);
-    client.setResponseCache(cache);
-  }
-
-  /** Test which headers are sent unencrypted to the HTTP proxy. */
-  @Test public void proxyConnectIncludesProxyHeadersOnly()
-      throws IOException, InterruptedException {
-    RecordingHostnameVerifier hostnameVerifier = new RecordingHostnameVerifier();
-
-    server.useHttps(sslContext.getSocketFactory(), true);
-    server.enqueue(
-        new MockResponse().setSocketPolicy(SocketPolicy.UPGRADE_TO_SSL_AT_END).clearHeaders());
-    server.enqueue(new MockResponse().setBody("encrypted response from the origin server"));
-    server.play();
-    client.setProxy(server.toProxyAddress());
-
-    URL url = new URL("https://android.com/foo");
-    client.setSslSocketFactory(sslContext.getSocketFactory());
-    client.setHostnameVerifier(hostnameVerifier);
-    HttpURLConnection connection = client.open(url);
-    connection.addRequestProperty("Private", "Secret");
-    connection.addRequestProperty("Proxy-Authorization", "bar");
-    connection.addRequestProperty("User-Agent", "baz");
-    assertContent("encrypted response from the origin server", connection);
-
-    RecordedRequest connect = server.takeRequest();
-    assertContainsNoneMatching(connect.getHeaders(), "Private.*");
-    assertContains(connect.getHeaders(), "Proxy-Authorization: bar");
-    assertContains(connect.getHeaders(), "User-Agent: baz");
-    assertContains(connect.getHeaders(), "Host: android.com");
-    assertContains(connect.getHeaders(), "Proxy-Connection: Keep-Alive");
-
-    RecordedRequest get = server.takeRequest();
-    assertContains(get.getHeaders(), "Private: Secret");
-    assertEquals(Arrays.asList("verify android.com"), hostnameVerifier.calls);
-  }
-
-  @Test public void proxyAuthenticateOnConnect() throws Exception {
-    Authenticator.setDefault(new RecordingAuthenticator());
-    server.useHttps(sslContext.getSocketFactory(), true);
-    server.enqueue(new MockResponse().setResponseCode(407)
-        .addHeader("Proxy-Authenticate: Basic realm=\"localhost\""));
-    server.enqueue(
-        new MockResponse().setSocketPolicy(SocketPolicy.UPGRADE_TO_SSL_AT_END).clearHeaders());
-    server.enqueue(new MockResponse().setBody("A"));
-    server.play();
-    client.setProxy(server.toProxyAddress());
-
-    URL url = new URL("https://android.com/foo");
-    client.setSslSocketFactory(sslContext.getSocketFactory());
-    client.setHostnameVerifier(new RecordingHostnameVerifier());
-    HttpURLConnection connection = client.open(url);
-    assertContent("A", connection);
-
-    RecordedRequest connect1 = server.takeRequest();
-    assertEquals("CONNECT android.com:443 HTTP/1.1", connect1.getRequestLine());
-    assertContainsNoneMatching(connect1.getHeaders(), "Proxy\\-Authorization.*");
-
-    RecordedRequest connect2 = server.takeRequest();
-    assertEquals("CONNECT android.com:443 HTTP/1.1", connect2.getRequestLine());
-    assertContains(connect2.getHeaders(),
-        "Proxy-Authorization: Basic " + RecordingAuthenticator.BASE_64_CREDENTIALS);
-
-    RecordedRequest get = server.takeRequest();
-    assertEquals("GET /foo HTTP/1.1", get.getRequestLine());
-    assertContainsNoneMatching(get.getHeaders(), "Proxy\\-Authorization.*");
-  }
-
-  // Don't disconnect after building a tunnel with CONNECT
-  // http://code.google.com/p/android/issues/detail?id=37221
-  @Test public void proxyWithConnectionClose() throws IOException {
-    server.useHttps(sslContext.getSocketFactory(), true);
-    server.enqueue(
-        new MockResponse().setSocketPolicy(SocketPolicy.UPGRADE_TO_SSL_AT_END).clearHeaders());
-    server.enqueue(new MockResponse().setBody("this response comes via a proxy"));
-    server.play();
-    client.setProxy(server.toProxyAddress());
-
-    URL url = new URL("https://android.com/foo");
-    client.setSslSocketFactory(sslContext.getSocketFactory());
-    client.setHostnameVerifier(new RecordingHostnameVerifier());
-    HttpURLConnection connection = client.open(url);
-    connection.setRequestProperty("Connection", "close");
-
-    assertContent("this response comes via a proxy", connection);
-  }
-
-  @Test public void proxyWithConnectionReuse() throws IOException {
-    SSLSocketFactory socketFactory = sslContext.getSocketFactory();
-    RecordingHostnameVerifier hostnameVerifier = new RecordingHostnameVerifier();
-
-    server.useHttps(socketFactory, true);
-    server.enqueue(
-        new MockResponse().setSocketPolicy(SocketPolicy.UPGRADE_TO_SSL_AT_END).clearHeaders());
-    server.enqueue(new MockResponse().setBody("response 1"));
-    server.enqueue(new MockResponse().setBody("response 2"));
-    server.play();
-    client.setProxy(server.toProxyAddress());
-
-    URL url = new URL("https://android.com/foo");
-    client.setSslSocketFactory(socketFactory);
-    client.setHostnameVerifier(hostnameVerifier);
-    assertContent("response 1", client.open(url));
-    assertContent("response 2", client.open(url));
-  }
-
-  @Test public void disconnectedConnection() throws IOException {
-    server.enqueue(new MockResponse().setBody("ABCDEFGHIJKLMNOPQR"));
-    server.play();
-
-    HttpURLConnection connection = client.open(server.getUrl("/"));
-    InputStream in = connection.getInputStream();
-    assertEquals('A', (char) in.read());
-    connection.disconnect();
-    try {
-      in.read();
-      fail("Expected a connection closed exception");
-    } catch (IOException expected) {
-    }
-  }
-
-  @Test public void disconnectBeforeConnect() throws IOException {
-    server.enqueue(new MockResponse().setBody("A"));
-    server.play();
-
-    HttpURLConnection connection = client.open(server.getUrl("/"));
-    connection.disconnect();
-
-    assertContent("A", connection);
-    assertEquals(200, connection.getResponseCode());
-  }
-
-  @SuppressWarnings("deprecation") @Test public void defaultRequestProperty() throws Exception {
-    URLConnection.setDefaultRequestProperty("X-testSetDefaultRequestProperty", "A");
-    assertNull(URLConnection.getDefaultRequestProperty("X-setDefaultRequestProperty"));
-  }
-
-  /**
-   * Reads {@code count} characters from the stream. If the stream is
-   * exhausted before {@code count} characters can be read, the remaining
-   * characters are returned and the stream is closed.
-   */
-  private String readAscii(InputStream in, int count) throws IOException {
-    StringBuilder result = new StringBuilder();
-    for (int i = 0; i < count; i++) {
-      int value = in.read();
-      if (value == -1) {
-        in.close();
-        break;
-      }
-      result.append((char) value);
-    }
-    return result.toString();
-  }
-
-  @Test public void markAndResetWithContentLengthHeader() throws IOException {
-    testMarkAndReset(TransferKind.FIXED_LENGTH);
-  }
-
-  @Test public void markAndResetWithChunkedEncoding() throws IOException {
-    testMarkAndReset(TransferKind.CHUNKED);
-  }
-
-  @Test public void markAndResetWithNoLengthHeaders() throws IOException {
-    testMarkAndReset(TransferKind.END_OF_STREAM);
-  }
-
-  private void testMarkAndReset(TransferKind transferKind) throws IOException {
-    MockResponse response = new MockResponse();
-    transferKind.setBody(response, "ABCDEFGHIJKLMNOPQRSTUVWXYZ", 1024);
-    server.enqueue(response);
-    server.enqueue(response);
-    server.play();
-
-    InputStream in = client.open(server.getUrl("/")).getInputStream();
-    assertFalse("This implementation claims to support mark().", in.markSupported());
-    in.mark(5);
-    assertEquals("ABCDE", readAscii(in, 5));
-    try {
-      in.reset();
-      fail();
-    } catch (IOException expected) {
-    }
-    assertEquals("FGHIJKLMNOPQRSTUVWXYZ", readAscii(in, Integer.MAX_VALUE));
-    assertContent("ABCDEFGHIJKLMNOPQRSTUVWXYZ", client.open(server.getUrl("/")));
-  }
-
-  /**
-   * We've had a bug where we forget the HTTP response when we see response
-   * code 401. This causes a new HTTP request to be issued for every call into
-   * the URLConnection.
-   */
-  @Test public void unauthorizedResponseHandling() throws IOException {
-    MockResponse response = new MockResponse().addHeader("WWW-Authenticate: challenge")
-        .setResponseCode(401) // UNAUTHORIZED
-        .setBody("Unauthorized");
-    server.enqueue(response);
-    server.enqueue(response);
-    server.enqueue(response);
-    server.play();
-
-    URL url = server.getUrl("/");
-    HttpURLConnection conn = client.open(url);
-
-    assertEquals(401, conn.getResponseCode());
-    assertEquals(401, conn.getResponseCode());
-    assertEquals(401, conn.getResponseCode());
-    assertEquals(1, server.getRequestCount());
-  }
-
-  @Test public void nonHexChunkSize() throws IOException {
-    server.enqueue(new MockResponse().setBody("5\r\nABCDE\r\nG\r\nFGHIJKLMNOPQRSTU\r\n0\r\n\r\n")
-        .clearHeaders()
-        .addHeader("Transfer-encoding: chunked"));
-    server.play();
-
-    URLConnection connection = client.open(server.getUrl("/"));
-    try {
-      readAscii(connection.getInputStream(), Integer.MAX_VALUE);
-      fail();
-    } catch (IOException e) {
-    }
-  }
-
-  @Test public void missingChunkBody() throws IOException {
-    server.enqueue(new MockResponse().setBody("5")
-        .clearHeaders()
-        .addHeader("Transfer-encoding: chunked")
-        .setSocketPolicy(DISCONNECT_AT_END));
-    server.play();
-
-    URLConnection connection = client.open(server.getUrl("/"));
-    try {
-      readAscii(connection.getInputStream(), Integer.MAX_VALUE);
-      fail();
-    } catch (IOException e) {
-    }
-  }
-
-  /**
-   * This test checks whether connections are gzipped by default. This
-   * behavior in not required by the API, so a failure of this test does not
-   * imply a bug in the implementation.
-   */
-  @Test public void gzipEncodingEnabledByDefault() throws IOException, InterruptedException {
-    server.enqueue(new MockResponse().setBody(gzip("ABCABCABC".getBytes("UTF-8")))
-        .addHeader("Content-Encoding: gzip"));
-    server.play();
-
-    URLConnection connection = client.open(server.getUrl("/"));
-    assertEquals("ABCABCABC", readAscii(connection.getInputStream(), Integer.MAX_VALUE));
-    assertNull(connection.getContentEncoding());
-    assertEquals(-1, connection.getContentLength());
-
-    RecordedRequest request = server.takeRequest();
-    assertContains(request.getHeaders(), "Accept-Encoding: gzip");
-  }
-
-  @Test public void clientConfiguredGzipContentEncoding() throws Exception {
-    byte[] bodyBytes = gzip("ABCDEFGHIJKLMNOPQRSTUVWXYZ".getBytes("UTF-8"));
-    server.enqueue(new MockResponse()
-        .setBody(bodyBytes)
-        .addHeader("Content-Encoding: gzip"));
-    server.play();
-
-    URLConnection connection = client.open(server.getUrl("/"));
-    connection.addRequestProperty("Accept-Encoding", "gzip");
-    InputStream gunzippedIn = new GZIPInputStream(connection.getInputStream());
-    assertEquals("ABCDEFGHIJKLMNOPQRSTUVWXYZ", readAscii(gunzippedIn, Integer.MAX_VALUE));
-    assertEquals(bodyBytes.length, connection.getContentLength());
-
-    RecordedRequest request = server.takeRequest();
-    assertContains(request.getHeaders(), "Accept-Encoding: gzip");
-  }
-
-  @Test public void gzipAndConnectionReuseWithFixedLength() throws Exception {
-    testClientConfiguredGzipContentEncodingAndConnectionReuse(TransferKind.FIXED_LENGTH, false);
-  }
-
-  @Test public void gzipAndConnectionReuseWithChunkedEncoding() throws Exception {
-    testClientConfiguredGzipContentEncodingAndConnectionReuse(TransferKind.CHUNKED, false);
-  }
-
-  @Test public void gzipAndConnectionReuseWithFixedLengthAndTls() throws Exception {
-    testClientConfiguredGzipContentEncodingAndConnectionReuse(TransferKind.FIXED_LENGTH, true);
-  }
-
-  @Test public void gzipAndConnectionReuseWithChunkedEncodingAndTls() throws Exception {
-    testClientConfiguredGzipContentEncodingAndConnectionReuse(TransferKind.CHUNKED, true);
-  }
-
-  @Test public void clientConfiguredCustomContentEncoding() throws Exception {
-    server.enqueue(new MockResponse().setBody("ABCDE").addHeader("Content-Encoding: custom"));
-    server.play();
-
-    URLConnection connection = client.open(server.getUrl("/"));
-    connection.addRequestProperty("Accept-Encoding", "custom");
-    assertEquals("ABCDE", readAscii(connection.getInputStream(), Integer.MAX_VALUE));
-
-    RecordedRequest request = server.takeRequest();
-    assertContains(request.getHeaders(), "Accept-Encoding: custom");
-  }
-
-  /**
-   * Test a bug where gzip input streams weren't exhausting the input stream,
-   * which corrupted the request that followed or prevented connection reuse.
-   * http://code.google.com/p/android/issues/detail?id=7059
-   * http://code.google.com/p/android/issues/detail?id=38817
-   */
-  private void testClientConfiguredGzipContentEncodingAndConnectionReuse(TransferKind transferKind,
-      boolean tls) throws Exception {
-    if (tls) {
-      SSLSocketFactory socketFactory = sslContext.getSocketFactory();
-      RecordingHostnameVerifier hostnameVerifier = new RecordingHostnameVerifier();
-      server.useHttps(socketFactory, false);
-      client.setSslSocketFactory(socketFactory);
-      client.setHostnameVerifier(hostnameVerifier);
-    }
-
-    MockResponse responseOne = new MockResponse();
-    responseOne.addHeader("Content-Encoding: gzip");
-    transferKind.setBody(responseOne, gzip("one (gzipped)".getBytes("UTF-8")), 5);
-    server.enqueue(responseOne);
-    MockResponse responseTwo = new MockResponse();
-    transferKind.setBody(responseTwo, "two (identity)", 5);
-    server.enqueue(responseTwo);
-    server.play();
-
-    HttpURLConnection connection1 = client.open(server.getUrl("/"));
-    connection1.addRequestProperty("Accept-Encoding", "gzip");
-    InputStream gunzippedIn = new GZIPInputStream(connection1.getInputStream());
-    assertEquals("one (gzipped)", readAscii(gunzippedIn, Integer.MAX_VALUE));
-    assertEquals(0, server.takeRequest().getSequenceNumber());
-
-    HttpURLConnection connection2 = client.open(server.getUrl("/"));
-    assertEquals("two (identity)", readAscii(connection2.getInputStream(), Integer.MAX_VALUE));
-    assertEquals(1, server.takeRequest().getSequenceNumber());
-  }
-
-  @Test public void earlyDisconnectDoesntHarmPoolingWithChunkedEncoding() throws Exception {
-    testEarlyDisconnectDoesntHarmPooling(TransferKind.CHUNKED);
-  }
-
-  @Test public void earlyDisconnectDoesntHarmPoolingWithFixedLengthEncoding() throws Exception {
-    testEarlyDisconnectDoesntHarmPooling(TransferKind.FIXED_LENGTH);
-  }
-
-  private void testEarlyDisconnectDoesntHarmPooling(TransferKind transferKind) throws Exception {
-    MockResponse response1 = new MockResponse();
-    transferKind.setBody(response1, "ABCDEFGHIJK", 1024);
-    server.enqueue(response1);
-
-    MockResponse response2 = new MockResponse();
-    transferKind.setBody(response2, "LMNOPQRSTUV", 1024);
-    server.enqueue(response2);
-
-    server.play();
-
-    URLConnection connection1 = client.open(server.getUrl("/"));
-    InputStream in1 = connection1.getInputStream();
-    assertEquals("ABCDE", readAscii(in1, 5));
-    in1.close();
-
-    HttpURLConnection connection2 = client.open(server.getUrl("/"));
-    InputStream in2 = connection2.getInputStream();
-    assertEquals("LMNOP", readAscii(in2, 5));
-    in2.close();
-
-    assertEquals(0, server.takeRequest().getSequenceNumber());
-    assertEquals(1, server.takeRequest().getSequenceNumber()); // Connection is pooled!
-  }
-
-  /**
-   * Obnoxiously test that the chunk sizes transmitted exactly equal the
-   * requested data+chunk header size. Although setChunkedStreamingMode()
-   * isn't specific about whether the size applies to the data or the
-   * complete chunk, the RI interprets it as a complete chunk.
-   */
-  @Test public void setChunkedStreamingMode() throws IOException, InterruptedException {
-    server.enqueue(new MockResponse());
-    server.play();
-
-    HttpURLConnection urlConnection = client.open(server.getUrl("/"));
-    urlConnection.setChunkedStreamingMode(8);
-    urlConnection.setDoOutput(true);
-    OutputStream outputStream = urlConnection.getOutputStream();
-    outputStream.write("ABCDEFGHIJKLMNOPQ".getBytes("US-ASCII"));
-    assertEquals(200, urlConnection.getResponseCode());
-
-    RecordedRequest request = server.takeRequest();
-    assertEquals("ABCDEFGHIJKLMNOPQ", new String(request.getBody(), "US-ASCII"));
-    assertEquals(Arrays.asList(3, 3, 3, 3, 3, 2), request.getChunkSizes());
-  }
-
-  @Test public void authenticateWithFixedLengthStreaming() throws Exception {
-    testAuthenticateWithStreamingPost(StreamingMode.FIXED_LENGTH);
-  }
-
-  @Test public void authenticateWithChunkedStreaming() throws Exception {
-    testAuthenticateWithStreamingPost(StreamingMode.CHUNKED);
-  }
-
-  private void testAuthenticateWithStreamingPost(StreamingMode streamingMode) throws Exception {
-    MockResponse pleaseAuthenticate = new MockResponse().setResponseCode(401)
-        .addHeader("WWW-Authenticate: Basic realm=\"protected area\"")
-        .setBody("Please authenticate.");
-    server.enqueue(pleaseAuthenticate);
-    server.play();
-
-    Authenticator.setDefault(new RecordingAuthenticator());
-    HttpURLConnection connection = client.open(server.getUrl("/"));
-    connection.setDoOutput(true);
-    byte[] requestBody = { 'A', 'B', 'C', 'D' };
-    if (streamingMode == StreamingMode.FIXED_LENGTH) {
-      connection.setFixedLengthStreamingMode(requestBody.length);
-    } else if (streamingMode == StreamingMode.CHUNKED) {
-      connection.setChunkedStreamingMode(0);
-    }
-    OutputStream outputStream = connection.getOutputStream();
-    outputStream.write(requestBody);
-    outputStream.close();
-    try {
-      connection.getInputStream();
-      fail();
-    } catch (HttpRetryException expected) {
-    }
-
-    // no authorization header for the request...
-    RecordedRequest request = server.takeRequest();
-    assertContainsNoneMatching(request.getHeaders(), "Authorization: Basic .*");
-    assertEquals(Arrays.toString(requestBody), Arrays.toString(request.getBody()));
-  }
-
-  @Test public void nonStandardAuthenticationScheme() throws Exception {
-    List<String> calls = authCallsForHeader("WWW-Authenticate: Foo");
-    assertEquals(Collections.<String>emptyList(), calls);
-  }
-
-  @Test public void nonStandardAuthenticationSchemeWithRealm() throws Exception {
-    List<String> calls = authCallsForHeader("WWW-Authenticate: Foo realm=\"Bar\"");
-    assertEquals(1, calls.size());
-    String call = calls.get(0);
-    assertTrue(call, call.contains("scheme=Foo"));
-    assertTrue(call, call.contains("prompt=Bar"));
-  }
-
-  // Digest auth is currently unsupported. Test that digest requests should fail reasonably.
-  // http://code.google.com/p/android/issues/detail?id=11140
-  @Test public void digestAuthentication() throws Exception {
-    List<String> calls = authCallsForHeader("WWW-Authenticate: Digest "
-        + "realm=\"testrealm@host.com\", qop=\"auth,auth-int\", "
-        + "nonce=\"dcd98b7102dd2f0e8b11d0f600bfb0c093\", "
-        + "opaque=\"5ccc069c403ebaf9f0171e9517f40e41\"");
-    assertEquals(1, calls.size());
-    String call = calls.get(0);
-    assertTrue(call, call.contains("scheme=Digest"));
-    assertTrue(call, call.contains("prompt=testrealm@host.com"));
-  }
-
-  @Test public void allAttributesSetInServerAuthenticationCallbacks() throws Exception {
-    List<String> calls = authCallsForHeader("WWW-Authenticate: Basic realm=\"Bar\"");
-    assertEquals(1, calls.size());
-    URL url = server.getUrl("/");
-    String call = calls.get(0);
-    assertTrue(call, call.contains("host=" + url.getHost()));
-    assertTrue(call, call.contains("port=" + url.getPort()));
-    assertTrue(call, call.contains("site=" + InetAddress.getAllByName(url.getHost())[0]));
-    assertTrue(call, call.contains("url=" + url));
-    assertTrue(call, call.contains("type=" + Authenticator.RequestorType.SERVER));
-    assertTrue(call, call.contains("prompt=Bar"));
-    assertTrue(call, call.contains("protocol=http"));
-    assertTrue(call, call.toLowerCase().contains("scheme=basic")); // lowercase for the RI.
-  }
-
-  @Test public void allAttributesSetInProxyAuthenticationCallbacks() throws Exception {
-    List<String> calls = authCallsForHeader("Proxy-Authenticate: Basic realm=\"Bar\"");
-    assertEquals(1, calls.size());
-    URL url = server.getUrl("/");
-    String call = calls.get(0);
-    assertTrue(call, call.contains("host=" + url.getHost()));
-    assertTrue(call, call.contains("port=" + url.getPort()));
-    assertTrue(call, call.contains("site=" + InetAddress.getAllByName(url.getHost())[0]));
-    assertTrue(call, call.contains("url=http://android.com"));
-    assertTrue(call, call.contains("type=" + Authenticator.RequestorType.PROXY));
-    assertTrue(call, call.contains("prompt=Bar"));
-    assertTrue(call, call.contains("protocol=http"));
-    assertTrue(call, call.toLowerCase().contains("scheme=basic")); // lowercase for the RI.
-  }
-
-  private List<String> authCallsForHeader(String authHeader) throws IOException {
-    boolean proxy = authHeader.startsWith("Proxy-");
-    int responseCode = proxy ? 407 : 401;
-    RecordingAuthenticator authenticator = new RecordingAuthenticator(null);
-    Authenticator.setDefault(authenticator);
-    MockResponse pleaseAuthenticate = new MockResponse().setResponseCode(responseCode)
-        .addHeader(authHeader)
-        .setBody("Please authenticate.");
-    server.enqueue(pleaseAuthenticate);
-    server.play();
-
-    HttpURLConnection connection;
-    if (proxy) {
-      client.setProxy(server.toProxyAddress());
-      connection = client.open(new URL("http://android.com"));
-    } else {
-      connection = client.open(server.getUrl("/"));
-    }
-    assertEquals(responseCode, connection.getResponseCode());
-    return authenticator.calls;
-  }
-
-  @Test public void setValidRequestMethod() throws Exception {
-    server.play();
-    assertValidRequestMethod("GET");
-    assertValidRequestMethod("DELETE");
-    assertValidRequestMethod("HEAD");
-    assertValidRequestMethod("OPTIONS");
-    assertValidRequestMethod("POST");
-    assertValidRequestMethod("PUT");
-    assertValidRequestMethod("TRACE");
-  }
-
-  private void assertValidRequestMethod(String requestMethod) throws Exception {
-    HttpURLConnection connection = client.open(server.getUrl("/"));
-    connection.setRequestMethod(requestMethod);
-    assertEquals(requestMethod, connection.getRequestMethod());
-  }
-
-  @Test public void setInvalidRequestMethodLowercase() throws Exception {
-    server.play();
-    assertInvalidRequestMethod("get");
-  }
-
-  @Test public void setInvalidRequestMethodConnect() throws Exception {
-    server.play();
-    assertInvalidRequestMethod("CONNECT");
-  }
-
-  private void assertInvalidRequestMethod(String requestMethod) throws Exception {
-    HttpURLConnection connection = client.open(server.getUrl("/"));
-    try {
-      connection.setRequestMethod(requestMethod);
-      fail();
-    } catch (ProtocolException expected) {
-    }
-  }
-
-  @Test public void cannotSetNegativeFixedLengthStreamingMode() throws Exception {
-    server.play();
-    HttpURLConnection connection = client.open(server.getUrl("/"));
-    try {
-      connection.setFixedLengthStreamingMode(-2);
-      fail();
-    } catch (IllegalArgumentException expected) {
-    }
-  }
-
-  @Test public void canSetNegativeChunkedStreamingMode() throws Exception {
-    server.play();
-    HttpURLConnection connection = client.open(server.getUrl("/"));
-    connection.setChunkedStreamingMode(-2);
-  }
-
-  @Test public void cannotSetFixedLengthStreamingModeAfterConnect() throws Exception {
-    server.enqueue(new MockResponse().setBody("A"));
-    server.play();
-    HttpURLConnection connection = client.open(server.getUrl("/"));
-    assertEquals("A", readAscii(connection.getInputStream(), Integer.MAX_VALUE));
-    try {
-      connection.setFixedLengthStreamingMode(1);
-      fail();
-    } catch (IllegalStateException expected) {
-    }
-  }
-
-  @Test public void cannotSetChunkedStreamingModeAfterConnect() throws Exception {
-    server.enqueue(new MockResponse().setBody("A"));
-    server.play();
-    HttpURLConnection connection = client.open(server.getUrl("/"));
-    assertEquals("A", readAscii(connection.getInputStream(), Integer.MAX_VALUE));
-    try {
-      connection.setChunkedStreamingMode(1);
-      fail();
-    } catch (IllegalStateException expected) {
-    }
-  }
-
-  @Test public void cannotSetFixedLengthStreamingModeAfterChunkedStreamingMode() throws Exception {
-    server.play();
-    HttpURLConnection connection = client.open(server.getUrl("/"));
-    connection.setChunkedStreamingMode(1);
-    try {
-      connection.setFixedLengthStreamingMode(1);
-      fail();
-    } catch (IllegalStateException expected) {
-    }
-  }
-
-  @Test public void cannotSetChunkedStreamingModeAfterFixedLengthStreamingMode() throws Exception {
-    server.play();
-    HttpURLConnection connection = client.open(server.getUrl("/"));
-    connection.setFixedLengthStreamingMode(1);
-    try {
-      connection.setChunkedStreamingMode(1);
-      fail();
-    } catch (IllegalStateException expected) {
-    }
-  }
-
-  @Test public void secureFixedLengthStreaming() throws Exception {
-    testSecureStreamingPost(StreamingMode.FIXED_LENGTH);
-  }
-
-  @Test public void secureChunkedStreaming() throws Exception {
-    testSecureStreamingPost(StreamingMode.CHUNKED);
-  }
-
-  /**
-   * Users have reported problems using HTTPS with streaming request bodies.
-   * http://code.google.com/p/android/issues/detail?id=12860
-   */
-  private void testSecureStreamingPost(StreamingMode streamingMode) throws Exception {
-    server.useHttps(sslContext.getSocketFactory(), false);
-    server.enqueue(new MockResponse().setBody("Success!"));
-    server.play();
-
-    client.setSslSocketFactory(sslContext.getSocketFactory());
-    client.setHostnameVerifier(new RecordingHostnameVerifier());
-    HttpURLConnection connection = client.open(server.getUrl("/"));
-    connection.setDoOutput(true);
-    byte[] requestBody = { 'A', 'B', 'C', 'D' };
-    if (streamingMode == StreamingMode.FIXED_LENGTH) {
-      connection.setFixedLengthStreamingMode(requestBody.length);
-    } else if (streamingMode == StreamingMode.CHUNKED) {
-      connection.setChunkedStreamingMode(0);
-    }
-    OutputStream outputStream = connection.getOutputStream();
-    outputStream.write(requestBody);
-    outputStream.close();
-    assertEquals("Success!", readAscii(connection.getInputStream(), Integer.MAX_VALUE));
-
-    RecordedRequest request = server.takeRequest();
-    assertEquals("POST / HTTP/1.1", request.getRequestLine());
-    if (streamingMode == StreamingMode.FIXED_LENGTH) {
-      assertEquals(Collections.<Integer>emptyList(), request.getChunkSizes());
-    } else if (streamingMode == StreamingMode.CHUNKED) {
-      assertEquals(Arrays.asList(4), request.getChunkSizes());
-    }
-    assertEquals(Arrays.toString(requestBody), Arrays.toString(request.getBody()));
-  }
-
-  enum StreamingMode {
-    FIXED_LENGTH, CHUNKED
-  }
-
-  @Test public void authenticateWithPost() throws Exception {
-    MockResponse pleaseAuthenticate = new MockResponse().setResponseCode(401)
-        .addHeader("WWW-Authenticate: Basic realm=\"protected area\"")
-        .setBody("Please authenticate.");
-    // fail auth three times...
-    server.enqueue(pleaseAuthenticate);
-    server.enqueue(pleaseAuthenticate);
-    server.enqueue(pleaseAuthenticate);
-    // ...then succeed the fourth time
-    server.enqueue(new MockResponse().setBody("Successful auth!"));
-    server.play();
-
-    Authenticator.setDefault(new RecordingAuthenticator());
-    HttpURLConnection connection = client.open(server.getUrl("/"));
-    connection.setDoOutput(true);
-    byte[] requestBody = { 'A', 'B', 'C', 'D' };
-    OutputStream outputStream = connection.getOutputStream();
-    outputStream.write(requestBody);
-    outputStream.close();
-    assertEquals("Successful auth!", readAscii(connection.getInputStream(), Integer.MAX_VALUE));
-
-    // no authorization header for the first request...
-    RecordedRequest request = server.takeRequest();
-    assertContainsNoneMatching(request.getHeaders(), "Authorization: Basic .*");
-
-    // ...but the three requests that follow include an authorization header
-    for (int i = 0; i < 3; i++) {
-      request = server.takeRequest();
-      assertEquals("POST / HTTP/1.1", request.getRequestLine());
-      assertContains(request.getHeaders(),
-          "Authorization: Basic " + RecordingAuthenticator.BASE_64_CREDENTIALS);
-      assertEquals(Arrays.toString(requestBody), Arrays.toString(request.getBody()));
-    }
-  }
-
-  @Test public void authenticateWithGet() throws Exception {
-    MockResponse pleaseAuthenticate = new MockResponse().setResponseCode(401)
-        .addHeader("WWW-Authenticate: Basic realm=\"protected area\"")
-        .setBody("Please authenticate.");
-    // fail auth three times...
-    server.enqueue(pleaseAuthenticate);
-    server.enqueue(pleaseAuthenticate);
-    server.enqueue(pleaseAuthenticate);
-    // ...then succeed the fourth time
-    server.enqueue(new MockResponse().setBody("Successful auth!"));
-    server.play();
-
-    Authenticator.setDefault(new RecordingAuthenticator());
-    HttpURLConnection connection = client.open(server.getUrl("/"));
-    assertEquals("Successful auth!", readAscii(connection.getInputStream(), Integer.MAX_VALUE));
-
-    // no authorization header for the first request...
-    RecordedRequest request = server.takeRequest();
-    assertContainsNoneMatching(request.getHeaders(), "Authorization: Basic .*");
-
-    // ...but the three requests that follow requests include an authorization header
-    for (int i = 0; i < 3; i++) {
-      request = server.takeRequest();
-      assertEquals("GET / HTTP/1.1", request.getRequestLine());
-      assertContains(request.getHeaders(),
-          "Authorization: Basic " + RecordingAuthenticator.BASE_64_CREDENTIALS);
-    }
-  }
-
-  @Test public void redirectedWithChunkedEncoding() throws Exception {
-    testRedirected(TransferKind.CHUNKED, true);
-  }
-
-  @Test public void redirectedWithContentLengthHeader() throws Exception {
-    testRedirected(TransferKind.FIXED_LENGTH, true);
-  }
-
-  @Test public void redirectedWithNoLengthHeaders() throws Exception {
-    testRedirected(TransferKind.END_OF_STREAM, false);
-  }
-
-  private void testRedirected(TransferKind transferKind, boolean reuse) throws Exception {
-    MockResponse response = new MockResponse().setResponseCode(HttpURLConnection.HTTP_MOVED_TEMP)
-        .addHeader("Location: /foo");
-    transferKind.setBody(response, "This page has moved!", 10);
-    server.enqueue(response);
-    server.enqueue(new MockResponse().setBody("This is the new location!"));
-    server.play();
-
-    URLConnection connection = client.open(server.getUrl("/"));
-    assertEquals("This is the new location!",
-        readAscii(connection.getInputStream(), Integer.MAX_VALUE));
-
-    RecordedRequest first = server.takeRequest();
-    assertEquals("GET / HTTP/1.1", first.getRequestLine());
-    RecordedRequest retry = server.takeRequest();
-    assertEquals("GET /foo HTTP/1.1", retry.getRequestLine());
-    if (reuse) {
-      assertEquals("Expected connection reuse", 1, retry.getSequenceNumber());
-    }
-  }
-
-  @Test public void redirectedOnHttps() throws IOException, InterruptedException {
-    server.useHttps(sslContext.getSocketFactory(), false);
-    server.enqueue(new MockResponse().setResponseCode(HttpURLConnection.HTTP_MOVED_TEMP)
-        .addHeader("Location: /foo")
-        .setBody("This page has moved!"));
-    server.enqueue(new MockResponse().setBody("This is the new location!"));
-    server.play();
-
-    client.setSslSocketFactory(sslContext.getSocketFactory());
-    client.setHostnameVerifier(new RecordingHostnameVerifier());
-    HttpURLConnection connection = client.open(server.getUrl("/"));
-    assertEquals("This is the new location!",
-        readAscii(connection.getInputStream(), Integer.MAX_VALUE));
-
-    RecordedRequest first = server.takeRequest();
-    assertEquals("GET / HTTP/1.1", first.getRequestLine());
-    RecordedRequest retry = server.takeRequest();
-    assertEquals("GET /foo HTTP/1.1", retry.getRequestLine());
-    assertEquals("Expected connection reuse", 1, retry.getSequenceNumber());
-  }
-
-  @Test public void notRedirectedFromHttpsToHttp() throws IOException, InterruptedException {
-    server.useHttps(sslContext.getSocketFactory(), false);
-    server.enqueue(new MockResponse().setResponseCode(HttpURLConnection.HTTP_MOVED_TEMP)
-        .addHeader("Location: http://anyhost/foo")
-        .setBody("This page has moved!"));
-    server.play();
-
-    client.setFollowProtocolRedirects(false);
-    client.setSslSocketFactory(sslContext.getSocketFactory());
-    client.setHostnameVerifier(new RecordingHostnameVerifier());
-    HttpURLConnection connection = client.open(server.getUrl("/"));
-    assertEquals("This page has moved!", readAscii(connection.getInputStream(), Integer.MAX_VALUE));
-  }
-
-  @Test public void notRedirectedFromHttpToHttps() throws IOException, InterruptedException {
-    server.enqueue(new MockResponse().setResponseCode(HttpURLConnection.HTTP_MOVED_TEMP)
-        .addHeader("Location: https://anyhost/foo")
-        .setBody("This page has moved!"));
-    server.play();
-
-    client.setFollowProtocolRedirects(false);
-    HttpURLConnection connection = client.open(server.getUrl("/"));
-    assertEquals("This page has moved!", readAscii(connection.getInputStream(), Integer.MAX_VALUE));
-  }
-
-  @Test public void redirectedFromHttpsToHttpFollowingProtocolRedirects() throws Exception {
-    server2 = new MockWebServer();
-    server2.enqueue(new MockResponse().setBody("This is insecure HTTP!"));
-    server2.play();
-
-    server.useHttps(sslContext.getSocketFactory(), false);
-    server.enqueue(new MockResponse().setResponseCode(HttpURLConnection.HTTP_MOVED_TEMP)
-        .addHeader("Location: " + server2.getUrl("/"))
-        .setBody("This page has moved!"));
-    server.play();
-
-    client.setSslSocketFactory(sslContext.getSocketFactory());
-    client.setHostnameVerifier(new RecordingHostnameVerifier());
-    client.setFollowProtocolRedirects(true);
-    HttpsURLConnection connection = (HttpsURLConnection) client.open(server.getUrl("/"));
-    assertContent("This is insecure HTTP!", connection);
-    assertNull(connection.getCipherSuite());
-    assertNull(connection.getLocalCertificates());
-    assertNull(connection.getServerCertificates());
-    assertNull(connection.getPeerPrincipal());
-    assertNull(connection.getLocalPrincipal());
-  }
-
-  @Test public void redirectedFromHttpToHttpsFollowingProtocolRedirects() throws Exception {
-    server2 = new MockWebServer();
-    server2.useHttps(sslContext.getSocketFactory(), false);
-    server2.enqueue(new MockResponse().setBody("This is secure HTTPS!"));
-    server2.play();
-
-    server.enqueue(new MockResponse().setResponseCode(HttpURLConnection.HTTP_MOVED_TEMP)
-        .addHeader("Location: " + server2.getUrl("/"))
-        .setBody("This page has moved!"));
-    server.play();
-
-    client.setSslSocketFactory(sslContext.getSocketFactory());
-    client.setHostnameVerifier(new RecordingHostnameVerifier());
-    client.setFollowProtocolRedirects(true);
-    HttpURLConnection connection = client.open(server.getUrl("/"));
-    assertContent("This is secure HTTPS!", connection);
-    assertFalse(connection instanceof HttpsURLConnection);
-  }
-
-  @Test public void redirectToAnotherOriginServer() throws Exception {
-    redirectToAnotherOriginServer(false);
-  }
-
-  @Test public void redirectToAnotherOriginServerWithHttps() throws Exception {
-    redirectToAnotherOriginServer(true);
-  }
-
-  private void redirectToAnotherOriginServer(boolean https) throws Exception {
-    server2 = new MockWebServer();
-    if (https) {
-      server.useHttps(sslContext.getSocketFactory(), false);
-      server2.useHttps(sslContext.getSocketFactory(), false);
-      server2.setNpnEnabled(false);
-      client.setSslSocketFactory(sslContext.getSocketFactory());
-      client.setHostnameVerifier(new RecordingHostnameVerifier());
-    }
-
-    server2.enqueue(new MockResponse().setBody("This is the 2nd server!"));
-    server2.enqueue(new MockResponse().setBody("This is the 2nd server, again!"));
-    server2.play();
-
-    server.enqueue(new MockResponse().setResponseCode(HttpURLConnection.HTTP_MOVED_TEMP)
-        .addHeader("Location: " + server2.getUrl("/").toString())
-        .setBody("This page has moved!"));
-    server.enqueue(new MockResponse().setBody("This is the first server again!"));
-    server.play();
-
-    URLConnection connection = client.open(server.getUrl("/"));
-    assertContent("This is the 2nd server!", connection);
-    assertEquals(server2.getUrl("/"), connection.getURL());
-
-    // make sure the first server was careful to recycle the connection
-    assertContent("This is the first server again!", client.open(server.getUrl("/")));
-    assertContent("This is the 2nd server, again!", client.open(server2.getUrl("/")));
-
-    String server1Host = hostName + ":" + server.getPort();
-    String server2Host = hostName + ":" + server2.getPort();
-    assertContains(server.takeRequest().getHeaders(), "Host: " + server1Host);
-    assertContains(server2.takeRequest().getHeaders(), "Host: " + server2Host);
-    assertEquals("Expected connection reuse", 1, server.takeRequest().getSequenceNumber());
-    assertEquals("Expected connection reuse", 1, server2.takeRequest().getSequenceNumber());
-  }
-
-  @Test public void redirectWithProxySelector() throws Exception {
-    final List<URI> proxySelectionRequests = new ArrayList<URI>();
-    client.setProxySelector(new ProxySelector() {
-      @Override public List<Proxy> select(URI uri) {
-        proxySelectionRequests.add(uri);
-        MockWebServer proxyServer = (uri.getPort() == server.getPort()) ? server : server2;
-        return Arrays.asList(proxyServer.toProxyAddress());
-      }
-      @Override public void connectFailed(URI uri, SocketAddress address, IOException failure) {
-        throw new AssertionError();
-      }
-    });
-
-    server2 = new MockWebServer();
-    server2.enqueue(new MockResponse().setBody("This is the 2nd server!"));
-    server2.play();
-
-    server.enqueue(new MockResponse().setResponseCode(HttpURLConnection.HTTP_MOVED_TEMP)
-        .addHeader("Location: " + server2.getUrl("/b").toString())
-        .setBody("This page has moved!"));
-    server.play();
-
-    assertContent("This is the 2nd server!", client.open(server.getUrl("/a")));
-
-    assertEquals(Arrays.asList(server.getUrl("/a").toURI(), server2.getUrl("/b").toURI()),
-        proxySelectionRequests);
-
-    server2.shutdown();
-  }
-
-  @Test public void response300MultipleChoiceWithPost() throws Exception {
-    // Chrome doesn't follow the redirect, but Firefox and the RI both do
-    testResponseRedirectedWithPost(HttpURLConnection.HTTP_MULT_CHOICE);
-  }
-
-  @Test public void response301MovedPermanentlyWithPost() throws Exception {
-    testResponseRedirectedWithPost(HttpURLConnection.HTTP_MOVED_PERM);
-  }
-
-  @Test public void response302MovedTemporarilyWithPost() throws Exception {
-    testResponseRedirectedWithPost(HttpURLConnection.HTTP_MOVED_TEMP);
-  }
-
-  @Test public void response303SeeOtherWithPost() throws Exception {
-    testResponseRedirectedWithPost(HttpURLConnection.HTTP_SEE_OTHER);
-  }
-
-  private void testResponseRedirectedWithPost(int redirectCode) throws Exception {
-    server.enqueue(new MockResponse().setResponseCode(redirectCode)
-        .addHeader("Location: /page2")
-        .setBody("This page has moved!"));
-    server.enqueue(new MockResponse().setBody("Page 2"));
-    server.play();
-
-    HttpURLConnection connection = client.open(server.getUrl("/page1"));
-    connection.setDoOutput(true);
-    byte[] requestBody = { 'A', 'B', 'C', 'D' };
-    OutputStream outputStream = connection.getOutputStream();
-    outputStream.write(requestBody);
-    outputStream.close();
-    assertEquals("Page 2", readAscii(connection.getInputStream(), Integer.MAX_VALUE));
-    assertTrue(connection.getDoOutput());
-
-    RecordedRequest page1 = server.takeRequest();
-    assertEquals("POST /page1 HTTP/1.1", page1.getRequestLine());
-    assertEquals(Arrays.toString(requestBody), Arrays.toString(page1.getBody()));
-
-    RecordedRequest page2 = server.takeRequest();
-    assertEquals("GET /page2 HTTP/1.1", page2.getRequestLine());
-  }
-
-  @Test public void response305UseProxy() throws Exception {
-    server.play();
-    server.enqueue(new MockResponse().setResponseCode(HttpURLConnection.HTTP_USE_PROXY)
-        .addHeader("Location: " + server.getUrl("/"))
-        .setBody("This page has moved!"));
-    server.enqueue(new MockResponse().setBody("Proxy Response"));
-
-    HttpURLConnection connection = client.open(server.getUrl("/foo"));
-    // Fails on the RI, which gets "Proxy Response"
-    assertEquals("This page has moved!", readAscii(connection.getInputStream(), Integer.MAX_VALUE));
-
-    RecordedRequest page1 = server.takeRequest();
-    assertEquals("GET /foo HTTP/1.1", page1.getRequestLine());
-    assertEquals(1, server.getRequestCount());
-  }
-
-  @Test public void response307WithGet() throws Exception {
-    test307Redirect("GET");
-  }
-
-  @Test public void response307WithHead() throws Exception {
-    test307Redirect("HEAD");
-  }
-
-  @Test public void response307WithOptions() throws Exception {
-    test307Redirect("OPTIONS");
-  }
-
-  @Test public void response307WithPost() throws Exception {
-    test307Redirect("POST");
-  }
-
-  private void test307Redirect(String method) throws Exception {
-    MockResponse response1 = new MockResponse()
-        .setResponseCode(HttpURLConnectionImpl.HTTP_TEMP_REDIRECT)
-        .addHeader("Location: /page2");
-    if (!method.equals("HEAD")) {
-      response1.setBody("This page has moved!");
-    }
-    server.enqueue(response1);
-    server.enqueue(new MockResponse().setBody("Page 2"));
-    server.play();
-
-    HttpURLConnection connection = client.open(server.getUrl("/page1"));
-    connection.setRequestMethod(method);
-    byte[] requestBody = { 'A', 'B', 'C', 'D' };
-    if (method.equals("POST")) {
-      connection.setDoOutput(true);
-      OutputStream outputStream = connection.getOutputStream();
-      outputStream.write(requestBody);
-      outputStream.close();
-    }
-
-    String response = readAscii(connection.getInputStream(), Integer.MAX_VALUE);
-
-    RecordedRequest page1 = server.takeRequest();
-    assertEquals(method + " /page1 HTTP/1.1", page1.getRequestLine());
-
-    if (method.equals("GET")) {
-        assertEquals("Page 2", response);
-    } else if (method.equals("HEAD"))  {
-        assertEquals("", response);
-    } else {
-      // Methods other than GET/HEAD shouldn't follow the redirect
-      if (method.equals("POST")) {
-        assertTrue(connection.getDoOutput());
-        assertEquals(Arrays.toString(requestBody), Arrays.toString(page1.getBody()));
-      }
-      assertEquals(1, server.getRequestCount());
-      assertEquals("This page has moved!", response);
-      return;
-    }
-
-    // GET/HEAD requests should have followed the redirect with the same method
-    assertFalse(connection.getDoOutput());
-    assertEquals(2, server.getRequestCount());
-    RecordedRequest page2 = server.takeRequest();
-    assertEquals(method + " /page2 HTTP/1.1", page2.getRequestLine());
-  }
-
-  @Test public void follow20Redirects() throws Exception {
-    for (int i = 0; i < 20; i++) {
-      server.enqueue(new MockResponse().setResponseCode(HttpURLConnection.HTTP_MOVED_TEMP)
-          .addHeader("Location: /" + (i + 1))
-          .setBody("Redirecting to /" + (i + 1)));
-    }
-    server.enqueue(new MockResponse().setBody("Success!"));
-    server.play();
-
-    HttpURLConnection connection = client.open(server.getUrl("/0"));
-    assertContent("Success!", connection);
-    assertEquals(server.getUrl("/20"), connection.getURL());
-  }
-
-  @Test public void doesNotFollow21Redirects() throws Exception {
-    for (int i = 0; i < 21; i++) {
-      server.enqueue(new MockResponse().setResponseCode(HttpURLConnection.HTTP_MOVED_TEMP)
-          .addHeader("Location: /" + (i + 1))
-          .setBody("Redirecting to /" + (i + 1)));
-    }
-    server.play();
-
-    HttpURLConnection connection = client.open(server.getUrl("/0"));
-    try {
-      connection.getInputStream();
-      fail();
-    } catch (ProtocolException expected) {
-      assertEquals(HttpURLConnection.HTTP_MOVED_TEMP, connection.getResponseCode());
-      assertEquals("Too many redirects: 21", expected.getMessage());
-      assertContent("Redirecting to /21", connection);
-      assertEquals(server.getUrl("/20"), connection.getURL());
-    }
-  }
-
-  @Test public void httpsWithCustomTrustManager() throws Exception {
-    RecordingHostnameVerifier hostnameVerifier = new RecordingHostnameVerifier();
-    RecordingTrustManager trustManager = new RecordingTrustManager();
-    SSLContext sc = SSLContext.getInstance("TLS");
-    sc.init(null, new TrustManager[] { trustManager }, new java.security.SecureRandom());
-
-    client.setHostnameVerifier(hostnameVerifier);
-    client.setSslSocketFactory(sc.getSocketFactory());
-    server.useHttps(sslContext.getSocketFactory(), false);
-    server.enqueue(new MockResponse().setBody("ABC"));
-    server.enqueue(new MockResponse().setBody("DEF"));
-    server.enqueue(new MockResponse().setBody("GHI"));
-    server.play();
-
-    URL url = server.getUrl("/");
-    assertContent("ABC", client.open(url));
-    assertContent("DEF", client.open(url));
-    assertContent("GHI", client.open(url));
-
-    assertEquals(Arrays.asList("verify " + hostName), hostnameVerifier.calls);
-    assertEquals(Arrays.asList("checkServerTrusted [CN=" + hostName + " 1]"), trustManager.calls);
-  }
-
-  @Test public void readTimeouts() throws IOException {
-    // This relies on the fact that MockWebServer doesn't close the
-    // connection after a response has been sent. This causes the client to
-    // try to read more bytes than are sent, which results in a timeout.
-    MockResponse timeout =
-        new MockResponse().setBody("ABC").clearHeaders().addHeader("Content-Length: 4");
-    server.enqueue(timeout);
-    server.enqueue(new MockResponse().setBody("unused")); // to keep the server alive
-    server.play();
-
-    URLConnection urlConnection = client.open(server.getUrl("/"));
-    urlConnection.setReadTimeout(1000);
-    InputStream in = urlConnection.getInputStream();
-    assertEquals('A', in.read());
-    assertEquals('B', in.read());
-    assertEquals('C', in.read());
-    try {
-      in.read(); // if Content-Length was accurate, this would return -1 immediately
-      fail();
-    } catch (SocketTimeoutException expected) {
-    }
-  }
-
-  @Test public void setChunkedEncodingAsRequestProperty() throws IOException, InterruptedException {
-    server.enqueue(new MockResponse());
-    server.play();
-
-    HttpURLConnection urlConnection = client.open(server.getUrl("/"));
-    urlConnection.setRequestProperty("Transfer-encoding", "chunked");
-    urlConnection.setDoOutput(true);
-    urlConnection.getOutputStream().write("ABC".getBytes("UTF-8"));
-    assertEquals(200, urlConnection.getResponseCode());
-
-    RecordedRequest request = server.takeRequest();
-    assertEquals("ABC", new String(request.getBody(), "UTF-8"));
-  }
-
-  @Test public void connectionCloseInRequest() throws IOException, InterruptedException {
-    server.enqueue(new MockResponse()); // server doesn't honor the connection: close header!
-    server.enqueue(new MockResponse());
-    server.play();
-
-    HttpURLConnection a = client.open(server.getUrl("/"));
-    a.setRequestProperty("Connection", "close");
-    assertEquals(200, a.getResponseCode());
-
-    HttpURLConnection b = client.open(server.getUrl("/"));
-    assertEquals(200, b.getResponseCode());
-
-    assertEquals(0, server.takeRequest().getSequenceNumber());
-    assertEquals("When connection: close is used, each request should get its own connection", 0,
-        server.takeRequest().getSequenceNumber());
-  }
-
-  @Test public void connectionCloseInResponse() throws IOException, InterruptedException {
-    server.enqueue(new MockResponse().addHeader("Connection: close"));
-    server.enqueue(new MockResponse());
-    server.play();
-
-    HttpURLConnection a = client.open(server.getUrl("/"));
-    assertEquals(200, a.getResponseCode());
-
-    HttpURLConnection b = client.open(server.getUrl("/"));
-    assertEquals(200, b.getResponseCode());
-
-    assertEquals(0, server.takeRequest().getSequenceNumber());
-    assertEquals("When connection: close is used, each request should get its own connection", 0,
-        server.takeRequest().getSequenceNumber());
-  }
-
-  @Test public void connectionCloseWithRedirect() throws IOException, InterruptedException {
-    MockResponse response = new MockResponse().setResponseCode(HttpURLConnection.HTTP_MOVED_TEMP)
-        .addHeader("Location: /foo")
-        .addHeader("Connection: close");
-    server.enqueue(response);
-    server.enqueue(new MockResponse().setBody("This is the new location!"));
-    server.play();
-
-    URLConnection connection = client.open(server.getUrl("/"));
-    assertEquals("This is the new location!",
-        readAscii(connection.getInputStream(), Integer.MAX_VALUE));
-
-    assertEquals(0, server.takeRequest().getSequenceNumber());
-    assertEquals("When connection: close is used, each request should get its own connection", 0,
-        server.takeRequest().getSequenceNumber());
-  }
-
-  /**
-   * Retry redirects if the socket is closed.
-   * https://code.google.com/p/android/issues/detail?id=41576
-   */
-  @Test public void sameConnectionRedirectAndReuse() throws Exception {
-    server.enqueue(new MockResponse().setResponseCode(HttpURLConnection.HTTP_MOVED_TEMP)
-        .setSocketPolicy(SHUTDOWN_INPUT_AT_END)
-        .addHeader("Location: /foo"));
-    server.enqueue(new MockResponse().setBody("This is the new page!"));
-    server.play();
-
-    assertContent("This is the new page!", client.open(server.getUrl("/")));
-
-    assertEquals(0, server.takeRequest().getSequenceNumber());
-    assertEquals(0, server.takeRequest().getSequenceNumber());
-  }
-
-  @Test public void responseCodeDisagreesWithHeaders() throws IOException, InterruptedException {
-    server.enqueue(new MockResponse().setResponseCode(HttpURLConnection.HTTP_NO_CONTENT)
-        .setBody("This body is not allowed!"));
-    server.play();
-
-    URLConnection connection = client.open(server.getUrl("/"));
-    assertEquals("This body is not allowed!",
-        readAscii(connection.getInputStream(), Integer.MAX_VALUE));
-  }
-
-  @Test public void singleByteReadIsSigned() throws IOException {
-    server.enqueue(new MockResponse().setBody(new byte[] { -2, -1 }));
-    server.play();
-
-    URLConnection connection = client.open(server.getUrl("/"));
-    InputStream in = connection.getInputStream();
-    assertEquals(254, in.read());
-    assertEquals(255, in.read());
-    assertEquals(-1, in.read());
-  }
-
-  @Test public void flushAfterStreamTransmittedWithChunkedEncoding() throws IOException {
-    testFlushAfterStreamTransmitted(TransferKind.CHUNKED);
-  }
-
-  @Test public void flushAfterStreamTransmittedWithFixedLength() throws IOException {
-    testFlushAfterStreamTransmitted(TransferKind.FIXED_LENGTH);
-  }
-
-  @Test public void flushAfterStreamTransmittedWithNoLengthHeaders() throws IOException {
-    testFlushAfterStreamTransmitted(TransferKind.END_OF_STREAM);
-  }
-
-  /**
-   * We explicitly permit apps to close the upload stream even after it has
-   * been transmitted.  We also permit flush so that buffered streams can
-   * do a no-op flush when they are closed. http://b/3038470
-   */
-  private void testFlushAfterStreamTransmitted(TransferKind transferKind) throws IOException {
-    server.enqueue(new MockResponse().setBody("abc"));
-    server.play();
-
-    HttpURLConnection connection = client.open(server.getUrl("/"));
-    connection.setDoOutput(true);
-    byte[] upload = "def".getBytes("UTF-8");
-
-    if (transferKind == TransferKind.CHUNKED) {
-      connection.setChunkedStreamingMode(0);
-    } else if (transferKind == TransferKind.FIXED_LENGTH) {
-      connection.setFixedLengthStreamingMode(upload.length);
-    }
-
-    OutputStream out = connection.getOutputStream();
-    out.write(upload);
-    assertEquals("abc", readAscii(connection.getInputStream(), Integer.MAX_VALUE));
-
-    out.flush(); // dubious but permitted
-    try {
-      out.write("ghi".getBytes("UTF-8"));
-      fail();
-    } catch (IOException expected) {
-    }
-  }
-
-  @Test public void getHeadersThrows() throws IOException {
-    // Enqueue a response for every IP address held by localhost, because the route selector
-    // will try each in sequence.
-    // TODO: use the fake Dns implementation instead of a loop
-    for (InetAddress inetAddress : InetAddress.getAllByName(server.getHostName())) {
-      server.enqueue(new MockResponse().setSocketPolicy(DISCONNECT_AT_START));
-    }
-    server.play();
-
-    HttpURLConnection connection = client.open(server.getUrl("/"));
-    try {
-      connection.getInputStream();
-      fail();
-    } catch (IOException expected) {
-    }
-
-    try {
-      connection.getInputStream();
-      fail();
-    } catch (IOException expected) {
-    }
-  }
-
-  @Test public void dnsFailureThrowsIOException() throws IOException {
-    HttpURLConnection connection = client.open(new URL("http://host.unlikelytld"));
-    try {
-      connection.connect();
-      fail();
-    } catch (IOException expected) {
-    }
-  }
-
-  @Test public void malformedUrlThrowsUnknownHostException() throws IOException {
-    HttpURLConnection connection = client.open(new URL("http:///foo.html"));
-    try {
-      connection.connect();
-      fail();
-    } catch (UnknownHostException expected) {
-    }
-  }
-
-  @Test public void getKeepAlive() throws Exception {
-    MockWebServer server = new MockWebServer();
-    server.enqueue(new MockResponse().setBody("ABC"));
-    server.play();
-
-    // The request should work once and then fail
-    URLConnection connection1 = client.open(server.getUrl(""));
-    connection1.setReadTimeout(100);
-    InputStream input = connection1.getInputStream();
-    assertEquals("ABC", readAscii(input, Integer.MAX_VALUE));
-    input.close();
-    server.shutdown();
-    try {
-      HttpURLConnection connection2 = client.open(server.getUrl(""));
-      connection2.setReadTimeout(100);
-      connection2.getInputStream();
-      fail();
-    } catch (ConnectException expected) {
-    }
-  }
-
-  /** Don't explode if the cache returns a null body. http://b/3373699 */
-  @Test public void responseCacheReturnsNullOutputStream() throws Exception {
-    final AtomicBoolean aborted = new AtomicBoolean();
-    client.setResponseCache(new ResponseCache() {
-      @Override public CacheResponse get(URI uri, String requestMethod,
-          Map<String, List<String>> requestHeaders) throws IOException {
-        return null;
-      }
-
-      @Override public CacheRequest put(URI uri, URLConnection connection) throws IOException {
-        return new CacheRequest() {
-          @Override public void abort() {
-            aborted.set(true);
-          }
-
-          @Override public OutputStream getBody() throws IOException {
-            return null;
-          }
-        };
-      }
-    });
-
-    server.enqueue(new MockResponse().setBody("abcdef"));
-    server.play();
-
-    HttpURLConnection connection = client.open(server.getUrl("/"));
-    InputStream in = connection.getInputStream();
-    assertEquals("abc", readAscii(in, 3));
-    in.close();
-    assertFalse(aborted.get()); // The best behavior is ambiguous, but RI 6 doesn't abort here
-  }
-
-  /** http://code.google.com/p/android/issues/detail?id=14562 */
-  @Test public void readAfterLastByte() throws Exception {
-    server.enqueue(new MockResponse().setBody("ABC")
-        .clearHeaders()
-        .addHeader("Connection: close")
-        .setSocketPolicy(SocketPolicy.DISCONNECT_AT_END));
-    server.play();
-
-    HttpURLConnection connection = client.open(server.getUrl("/"));
-    InputStream in = connection.getInputStream();
-    assertEquals("ABC", readAscii(in, 3));
-    assertEquals(-1, in.read());
-    assertEquals(-1, in.read()); // throws IOException in Gingerbread
-  }
-
-  @Test public void getContent() throws Exception {
-    server.enqueue(new MockResponse().addHeader("Content-Type: text/plain").setBody("A"));
-    server.play();
-    HttpURLConnection connection = client.open(server.getUrl("/"));
-    InputStream in = (InputStream) connection.getContent();
-    assertEquals("A", readAscii(in, Integer.MAX_VALUE));
-  }
-
-  @Test public void getContentOfType() throws Exception {
-    server.enqueue(new MockResponse().addHeader("Content-Type: text/plain").setBody("A"));
-    server.play();
-    HttpURLConnection connection = client.open(server.getUrl("/"));
-    try {
-      connection.getContent(null);
-      fail();
-    } catch (NullPointerException expected) {
-    }
-    try {
-      connection.getContent(new Class[] { null });
-      fail();
-    } catch (NullPointerException expected) {
-    }
-    assertNull(connection.getContent(new Class[] { getClass() }));
-    connection.disconnect();
-  }
-
-  @Test public void getOutputStreamOnGetFails() throws Exception {
-    server.enqueue(new MockResponse());
-    server.play();
-    HttpURLConnection connection = client.open(server.getUrl("/"));
-    try {
-      connection.getOutputStream();
-      fail();
-    } catch (ProtocolException expected) {
-    }
-  }
-
-  @Test public void getOutputAfterGetInputStreamFails() throws Exception {
-    server.enqueue(new MockResponse());
-    server.play();
-    HttpURLConnection connection = client.open(server.getUrl("/"));
-    connection.setDoOutput(true);
-    try {
-      connection.getInputStream();
-      connection.getOutputStream();
-      fail();
-    } catch (ProtocolException expected) {
-    }
-  }
-
-  @Test public void setDoOutputOrDoInputAfterConnectFails() throws Exception {
-    server.enqueue(new MockResponse());
-    server.play();
-    HttpURLConnection connection = client.open(server.getUrl("/"));
-    connection.connect();
-    try {
-      connection.setDoOutput(true);
-      fail();
-    } catch (IllegalStateException expected) {
-    }
-    try {
-      connection.setDoInput(true);
-      fail();
-    } catch (IllegalStateException expected) {
-    }
-    connection.disconnect();
-  }
-
-  @Test public void clientSendsContentLength() throws Exception {
-    server.enqueue(new MockResponse().setBody("A"));
-    server.play();
-    HttpURLConnection connection = client.open(server.getUrl("/"));
-    connection.setDoOutput(true);
-    OutputStream out = connection.getOutputStream();
-    out.write(new byte[] { 'A', 'B', 'C' });
-    out.close();
-    assertEquals("A", readAscii(connection.getInputStream(), Integer.MAX_VALUE));
-    RecordedRequest request = server.takeRequest();
-    assertContains(request.getHeaders(), "Content-Length: 3");
-  }
-
-  @Test public void getContentLengthConnects() throws Exception {
-    server.enqueue(new MockResponse().setBody("ABC"));
-    server.play();
-    HttpURLConnection connection = client.open(server.getUrl("/"));
-    assertEquals(3, connection.getContentLength());
-    connection.disconnect();
-  }
-
-  @Test public void getContentTypeConnects() throws Exception {
-    server.enqueue(new MockResponse().addHeader("Content-Type: text/plain").setBody("ABC"));
-    server.play();
-    HttpURLConnection connection = client.open(server.getUrl("/"));
-    assertEquals("text/plain", connection.getContentType());
-    connection.disconnect();
-  }
-
-  @Test public void getContentEncodingConnects() throws Exception {
-    server.enqueue(new MockResponse().addHeader("Content-Encoding: identity").setBody("ABC"));
-    server.play();
-    HttpURLConnection connection = client.open(server.getUrl("/"));
-    assertEquals("identity", connection.getContentEncoding());
-    connection.disconnect();
-  }
-
-  // http://b/4361656
-  @Test public void urlContainsQueryButNoPath() throws Exception {
-    server.enqueue(new MockResponse().setBody("A"));
-    server.play();
-    URL url = new URL("http", server.getHostName(), server.getPort(), "?query");
-    assertEquals("A", readAscii(client.open(url).getInputStream(), Integer.MAX_VALUE));
-    RecordedRequest request = server.takeRequest();
-    assertEquals("GET /?query HTTP/1.1", request.getRequestLine());
-  }
-
-  // http://code.google.com/p/android/issues/detail?id=20442
-  @Test public void inputStreamAvailableWithChunkedEncoding() throws Exception {
-    testInputStreamAvailable(TransferKind.CHUNKED);
-  }
-
-  @Test public void inputStreamAvailableWithContentLengthHeader() throws Exception {
-    testInputStreamAvailable(TransferKind.FIXED_LENGTH);
-  }
-
-  @Test public void inputStreamAvailableWithNoLengthHeaders() throws Exception {
-    testInputStreamAvailable(TransferKind.END_OF_STREAM);
-  }
-
-  private void testInputStreamAvailable(TransferKind transferKind) throws IOException {
-    String body = "ABCDEFGH";
-    MockResponse response = new MockResponse();
-    transferKind.setBody(response, body, 4);
-    server.enqueue(response);
-    server.play();
-    URLConnection connection = client.open(server.getUrl("/"));
-    InputStream in = connection.getInputStream();
-    for (int i = 0; i < body.length(); i++) {
-      assertTrue(in.available() >= 0);
-      assertEquals(body.charAt(i), in.read());
-    }
-    assertEquals(0, in.available());
-    assertEquals(-1, in.read());
-  }
-
-  @Test public void postFailsWithBufferedRequestForSmallRequest() throws Exception {
-    reusedConnectionFailsWithPost(TransferKind.END_OF_STREAM, 1024);
-  }
-
-  // This test is ignored because we don't (yet) reliably recover for large request bodies.
-  @Test public void postFailsWithBufferedRequestForLargeRequest() throws Exception {
-    reusedConnectionFailsWithPost(TransferKind.END_OF_STREAM, 16384);
-  }
-
-  @Test public void postFailsWithChunkedRequestForSmallRequest() throws Exception {
-    reusedConnectionFailsWithPost(TransferKind.CHUNKED, 1024);
-  }
-
-  @Test public void postFailsWithChunkedRequestForLargeRequest() throws Exception {
-    reusedConnectionFailsWithPost(TransferKind.CHUNKED, 16384);
-  }
-
-  @Test public void postFailsWithFixedLengthRequestForSmallRequest() throws Exception {
-    reusedConnectionFailsWithPost(TransferKind.FIXED_LENGTH, 1024);
-  }
-
-  @Test public void postFailsWithFixedLengthRequestForLargeRequest() throws Exception {
-    reusedConnectionFailsWithPost(TransferKind.FIXED_LENGTH, 16384);
-  }
-
-  private void reusedConnectionFailsWithPost(TransferKind transferKind, int requestSize)
-      throws Exception {
-    server.enqueue(new MockResponse().setBody("A").setSocketPolicy(SHUTDOWN_INPUT_AT_END));
-    server.enqueue(new MockResponse().setBody("B"));
-    server.play();
-
-    assertContent("A", client.open(server.getUrl("/a")));
-
-    // If the request body is larger than OkHttp's replay buffer, the failure may still occur.
-    byte[] requestBody = new byte[requestSize];
-    new Random(0).nextBytes(requestBody);
-
-    HttpURLConnection connection = client.open(server.getUrl("/b"));
-    connection.setRequestMethod("POST");
-    transferKind.setForRequest(connection, requestBody.length);
-    for (int i = 0; i < requestBody.length; i += 1024) {
-      connection.getOutputStream().write(requestBody, i, 1024);
-    }
-    connection.getOutputStream().close();
-    assertContent("B", connection);
-
-    RecordedRequest requestA = server.takeRequest();
-    assertEquals("/a", requestA.getPath());
-    RecordedRequest requestB = server.takeRequest();
-    assertEquals("/b", requestB.getPath());
-    assertEquals(Arrays.toString(requestBody), Arrays.toString(requestB.getBody()));
-  }
-
-  @Test public void fullyBufferedPostIsTooShort() throws Exception {
-    server.enqueue(new MockResponse().setBody("A"));
-    server.play();
-
-    HttpURLConnection connection = client.open(server.getUrl("/b"));
-    connection.setRequestProperty("Content-Length", "4");
-    connection.setRequestMethod("POST");
-    OutputStream out = connection.getOutputStream();
-    out.write('a');
-    out.write('b');
-    out.write('c');
-    try {
-      out.close();
-      fail();
-    } catch (IOException expected) {
-    }
-  }
-
-  @Test public void fullyBufferedPostIsTooLong() throws Exception {
-    server.enqueue(new MockResponse().setBody("A"));
-    server.play();
-
-    HttpURLConnection connection = client.open(server.getUrl("/b"));
-    connection.setRequestProperty("Content-Length", "3");
-    connection.setRequestMethod("POST");
-    OutputStream out = connection.getOutputStream();
-    out.write('a');
-    out.write('b');
-    out.write('c');
-    try {
-      out.write('d');
-      fail();
-    } catch (IOException expected) {
-    }
-  }
-
-  @Test @Ignore public void testPooledConnectionsDetectHttp10() {
-    // TODO: write a test that shows pooled connections detect HTTP/1.0 (vs. HTTP/1.1)
-    fail("TODO");
-  }
-
-  @Test @Ignore public void postBodiesRetransmittedOnAuthProblems() {
-    fail("TODO");
-  }
-
-  @Test @Ignore public void cookiesAndTrailers() {
-    // Do cookie headers get processed too many times?
-    fail("TODO");
-  }
-
-  @Test @Ignore public void headerNamesContainingNullCharacter() {
-    // This is relevant for SPDY
-    fail("TODO");
-  }
-
-  @Test @Ignore public void headerValuesContainingNullCharacter() {
-    // This is relevant for SPDY
-    fail("TODO");
-  }
-
-  @Test public void emptyRequestHeaderValueIsAllowed() throws Exception {
-    server.enqueue(new MockResponse().setBody("body"));
-    server.play();
-    HttpURLConnection urlConnection = client.open(server.getUrl("/"));
-    urlConnection.addRequestProperty("B", "");
-    assertContent("body", urlConnection);
-    assertEquals("", urlConnection.getRequestProperty("B"));
-  }
-
-  @Test public void emptyResponseHeaderValueIsAllowed() throws Exception {
-    server.enqueue(new MockResponse().addHeader("A:").setBody("body"));
-    server.play();
-    HttpURLConnection urlConnection = client.open(server.getUrl("/"));
-    assertContent("body", urlConnection);
-    assertEquals("", urlConnection.getHeaderField("A"));
-  }
-
-  @Test public void emptyRequestHeaderNameIsStrict() throws Exception {
-    server.enqueue(new MockResponse().setBody("body"));
-    server.play();
-    HttpURLConnection urlConnection = client.open(server.getUrl("/"));
-    try {
-      urlConnection.setRequestProperty("", "A");
-      fail();
-    } catch (IllegalArgumentException expected) {
-    }
-  }
-
-  @Test public void emptyResponseHeaderNameIsLenient() throws Exception {
-    server.enqueue(new MockResponse().addHeader(":A").setBody("body"));
-    server.play();
-    HttpURLConnection urlConnection = client.open(server.getUrl("/"));
-    urlConnection.getResponseCode();
-    assertEquals("A", urlConnection.getHeaderField(""));
-  }
-
-  @Test @Ignore public void deflateCompression() {
-    fail("TODO");
-  }
-
-  @Test @Ignore public void postBodiesRetransmittedOnIpAddressProblems() {
-    fail("TODO");
-  }
-
-  @Test @Ignore public void pooledConnectionProblemsNotReportedToProxySelector() {
-    fail("TODO");
-  }
-
-  @Test public void customAuthenticator() throws Exception {
-    MockResponse pleaseAuthenticate = new MockResponse().setResponseCode(401)
-        .addHeader("WWW-Authenticate: Basic realm=\"protected area\"")
-        .setBody("Please authenticate.");
-    server.enqueue(pleaseAuthenticate);
-    server.enqueue(new MockResponse().setBody("A"));
-    server.play();
-
-    Credential credential = Credential.basic("jesse", "peanutbutter");
-    RecordingOkAuthenticator authenticator = new RecordingOkAuthenticator(credential);
-    client.setAuthenticator(authenticator);
-    assertContent("A", client.open(server.getUrl("/private")));
-
-    assertContainsNoneMatching(server.takeRequest().getHeaders(), "Authorization: .*");
-    assertContains(server.takeRequest().getHeaders(),
-        "Authorization: " + credential.getHeaderValue());
-
-    assertEquals(1, authenticator.calls.size());
-    String call = authenticator.calls.get(0);
-    assertTrue(call, call.contains("proxy=DIRECT"));
-    assertTrue(call, call.contains("url=" + server.getUrl("/private")));
-    assertTrue(call, call.contains("challenges=[Basic realm=\"protected area\"]"));
-  }
-
-  @Test public void setTransports() throws Exception {
-    server.enqueue(new MockResponse().setBody("A"));
-    server.play();
-    client.setTransports(Arrays.asList("http/1.1"));
-    assertContent("A", client.open(server.getUrl("/")));
-  }
-
-  @Test public void setTransportsWithoutHttp11() throws Exception {
-    try {
-      client.setTransports(Arrays.asList("spdy/3"));
-      fail();
-    } catch (IllegalArgumentException expected) {
-    }
-  }
-
-  @Test public void setTransportsWithNull() throws Exception {
-    try {
-      client.setTransports(Arrays.asList("http/1.1", null));
-      fail();
-    } catch (IllegalArgumentException expected) {
-    }
-  }
-
-  @Test public void veryLargeFixedLengthRequest() throws Exception {
-    server.setBodyLimit(0);
-    server.enqueue(new MockResponse());
-    server.play();
-
-    HttpURLConnection connection = client.open(server.getUrl("/"));
-    connection.setDoOutput(true);
-    long contentLength = Integer.MAX_VALUE + 1L;
-    connection.setFixedLengthStreamingMode(contentLength);
-    OutputStream out = connection.getOutputStream();
-    byte[] buffer = new byte[1024 * 1024];
-    for (long bytesWritten = 0; bytesWritten < contentLength; ) {
-      int byteCount = (int) Math.min(buffer.length, contentLength - bytesWritten);
-      out.write(buffer, 0, byteCount);
-      bytesWritten += byteCount;
-    }
-    assertContent("", connection);
-
-    RecordedRequest request = server.takeRequest();
-    assertEquals(Long.toString(contentLength), request.getHeader("Content-Length"));
-  }
-
-  /** Returns a gzipped copy of {@code bytes}. */
-  public byte[] gzip(byte[] bytes) throws IOException {
-    ByteArrayOutputStream bytesOut = new ByteArrayOutputStream();
-    OutputStream gzippedOut = new GZIPOutputStream(bytesOut);
-    gzippedOut.write(bytes);
-    gzippedOut.close();
-    return bytesOut.toByteArray();
-  }
-
-  /**
-   * Reads at most {@code limit} characters from {@code in} and asserts that
-   * content equals {@code expected}.
-   */
-  private void assertContent(String expected, URLConnection connection, int limit)
-      throws IOException {
-    connection.connect();
-    assertEquals(expected, readAscii(connection.getInputStream(), limit));
-    ((HttpURLConnection) connection).disconnect();
-  }
-
-  private void assertContent(String expected, URLConnection connection) throws IOException {
-    assertContent(expected, connection, Integer.MAX_VALUE);
-  }
-
-  private void assertContains(List<String> headers, String header) {
-    assertTrue(headers.toString(), headers.contains(header));
-  }
-
-  private void assertContainsNoneMatching(List<String> headers, String pattern) {
-    for (String header : headers) {
-      if (header.matches(pattern)) {
-        fail("Header " + header + " matches " + pattern);
-      }
-    }
-  }
-
-  private Set<String> newSet(String... elements) {
-    return new HashSet<String>(Arrays.asList(elements));
-  }
-
-  enum TransferKind {
-    CHUNKED() {
-      @Override void setBody(MockResponse response, byte[] content, int chunkSize)
-          throws IOException {
-        response.setChunkedBody(content, chunkSize);
-      }
-      @Override void setForRequest(HttpURLConnection connection, int contentLength) {
-        connection.setChunkedStreamingMode(5);
-      }
-    },
-    FIXED_LENGTH() {
-      @Override void setBody(MockResponse response, byte[] content, int chunkSize) {
-        response.setBody(content);
-      }
-      @Override void setForRequest(HttpURLConnection connection, int contentLength) {
-        connection.setFixedLengthStreamingMode(contentLength);
-      }
-    },
-    END_OF_STREAM() {
-      @Override void setBody(MockResponse response, byte[] content, int chunkSize) {
-        response.setBody(content);
-        response.setSocketPolicy(DISCONNECT_AT_END);
-        for (Iterator<String> h = response.getHeaders().iterator(); h.hasNext(); ) {
-          if (h.next().startsWith("Content-Length:")) {
-            h.remove();
-            break;
-          }
-        }
-      }
-      @Override void setForRequest(HttpURLConnection connection, int contentLength) {
-      }
-    };
-
-    abstract void setBody(MockResponse response, byte[] content, int chunkSize) throws IOException;
-
-    abstract void setForRequest(HttpURLConnection connection, int contentLength);
-
-    void setBody(MockResponse response, String content, int chunkSize) throws IOException {
-      setBody(response, content.getBytes("UTF-8"), chunkSize);
-    }
-  }
-
-  enum ProxyConfig {
-    NO_PROXY() {
-      @Override public HttpURLConnection connect(MockWebServer server, OkHttpClient client, URL url)
-          throws IOException {
-        client.setProxy(Proxy.NO_PROXY);
-        return client.open(url);
-      }
-    },
-
-    CREATE_ARG() {
-      @Override public HttpURLConnection connect(MockWebServer server, OkHttpClient client, URL url)
-          throws IOException {
-        client.setProxy(server.toProxyAddress());
-        return client.open(url);
-      }
-    },
-
-    PROXY_SYSTEM_PROPERTY() {
-      @Override public HttpURLConnection connect(MockWebServer server, OkHttpClient client, URL url)
-          throws IOException {
-        System.setProperty("proxyHost", "localhost");
-        System.setProperty("proxyPort", Integer.toString(server.getPort()));
-        return client.open(url);
-      }
-    },
-
-    HTTP_PROXY_SYSTEM_PROPERTY() {
-      @Override public HttpURLConnection connect(MockWebServer server, OkHttpClient client, URL url)
-          throws IOException {
-        System.setProperty("http.proxyHost", "localhost");
-        System.setProperty("http.proxyPort", Integer.toString(server.getPort()));
-        return client.open(url);
-      }
-    },
-
-    HTTPS_PROXY_SYSTEM_PROPERTY() {
-      @Override public HttpURLConnection connect(MockWebServer server, OkHttpClient client, URL url)
-          throws IOException {
-        System.setProperty("https.proxyHost", "localhost");
-        System.setProperty("https.proxyPort", Integer.toString(server.getPort()));
-        return client.open(url);
-      }
-    };
-
-    public abstract HttpURLConnection connect(MockWebServer server, OkHttpClient client, URL url)
-        throws IOException;
-  }
-
-  private static class RecordingTrustManager implements X509TrustManager {
-    private final List<String> calls = new ArrayList<String>();
-
-    public X509Certificate[] getAcceptedIssuers() {
-      return new X509Certificate[] { };
-    }
-
-    public void checkClientTrusted(X509Certificate[] chain, String authType)
-        throws CertificateException {
-      calls.add("checkClientTrusted " + certificatesToString(chain));
-    }
-
-    public void checkServerTrusted(X509Certificate[] chain, String authType)
-        throws CertificateException {
-      calls.add("checkServerTrusted " + certificatesToString(chain));
-    }
-
-    private String certificatesToString(X509Certificate[] certificates) {
-      List<String> result = new ArrayList<String>();
-      for (X509Certificate certificate : certificates) {
-        result.add(certificate.getSubjectDN() + " " + certificate.getSerialNumber());
-      }
-      return result.toString();
-    }
-  }
-
-  private static class FakeProxySelector extends ProxySelector {
-    List<Proxy> proxies = new ArrayList<Proxy>();
-
-    @Override public List<Proxy> select(URI uri) {
-      // Don't handle 'socket' schemes, which the RI's Socket class may request (for SOCKS).
-      return uri.getScheme().equals("http") || uri.getScheme().equals("https") ? proxies
-          : Collections.singletonList(Proxy.NO_PROXY);
-    }
-
-    @Override public void connectFailed(URI uri, SocketAddress sa, IOException ioe) {
-    }
-  }
-}
diff --git a/okhttp/src/test/java/com/squareup/okhttp/internal/http/URLEncodingTest.java b/okhttp/src/test/java/com/squareup/okhttp/internal/http/URLEncodingTest.java
deleted file mode 100644
index 6ca375691b..0000000000
--- a/okhttp/src/test/java/com/squareup/okhttp/internal/http/URLEncodingTest.java
+++ /dev/null
@@ -1,150 +0,0 @@
-/*
- * Copyright (C) 2009 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.squareup.okhttp.internal.http;
-
-import com.squareup.okhttp.OkHttpClient;
-import java.io.IOException;
-import java.net.CacheRequest;
-import java.net.CacheResponse;
-import java.net.HttpURLConnection;
-import java.net.ResponseCache;
-import java.net.URI;
-import java.net.URISyntaxException;
-import java.net.URL;
-import java.net.URLConnection;
-import java.util.List;
-import java.util.Map;
-import java.util.concurrent.atomic.AtomicReference;
-import org.junit.Ignore;
-import org.junit.Test;
-
-import static org.junit.Assert.assertEquals;
-
-/**
- * Exercises HttpURLConnection to convert URL to a URI. Unlike URL#toURI,
- * HttpURLConnection recovers from URLs with unescaped but unsupported URI
- * characters like '{' and '|' by escaping these characters.
- */
-public final class URLEncodingTest {
-  /**
-   * This test goes through the exhaustive set of interesting ASCII characters
-   * because most of those characters are interesting in some way according to
-   * RFC 2396 and RFC 2732. http://b/1158780
-   */
-  @Test @Ignore public void lenientUrlToUri() throws Exception {
-    // alphanum
-    testUrlToUriMapping("abzABZ09", "abzABZ09", "abzABZ09", "abzABZ09", "abzABZ09");
-
-    // control characters
-    testUrlToUriMapping("\u0001", "%01", "%01", "%01", "%01");
-    testUrlToUriMapping("\u001f", "%1F", "%1F", "%1F", "%1F");
-
-    // ascii characters
-    testUrlToUriMapping("%20", "%20", "%20", "%20", "%20");
-    testUrlToUriMapping("%20", "%20", "%20", "%20", "%20");
-    testUrlToUriMapping(" ", "%20", "%20", "%20", "%20");
-    testUrlToUriMapping("!", "!", "!", "!", "!");
-    testUrlToUriMapping("\"", "%22", "%22", "%22", "%22");
-    testUrlToUriMapping("#", null, null, null, "%23");
-    testUrlToUriMapping("$", "$", "$", "$", "$");
-    testUrlToUriMapping("&", "&", "&", "&", "&");
-    testUrlToUriMapping("'", "'", "'", "'", "'");
-    testUrlToUriMapping("(", "(", "(", "(", "(");
-    testUrlToUriMapping(")", ")", ")", ")", ")");
-    testUrlToUriMapping("*", "*", "*", "*", "*");
-    testUrlToUriMapping("+", "+", "+", "+", "+");
-    testUrlToUriMapping(",", ",", ",", ",", ",");
-    testUrlToUriMapping("-", "-", "-", "-", "-");
-    testUrlToUriMapping(".", ".", ".", ".", ".");
-    testUrlToUriMapping("/", null, "/", "/", "/");
-    testUrlToUriMapping(":", null, ":", ":", ":");
-    testUrlToUriMapping(";", ";", ";", ";", ";");
-    testUrlToUriMapping("<", "%3C", "%3C", "%3C", "%3C");
-    testUrlToUriMapping("=", "=", "=", "=", "=");
-    testUrlToUriMapping(">", "%3E", "%3E", "%3E", "%3E");
-    testUrlToUriMapping("?", null, null, "?", "?");
-    testUrlToUriMapping("@", "@", "@", "@", "@");
-    testUrlToUriMapping("[", null, "%5B", null, "%5B");
-    testUrlToUriMapping("\\", "%5C", "%5C", "%5C", "%5C");
-    testUrlToUriMapping("]", null, "%5D", null, "%5D");
-    testUrlToUriMapping("^", "%5E", "%5E", "%5E", "%5E");
-    testUrlToUriMapping("_", "_", "_", "_", "_");
-    testUrlToUriMapping("`", "%60", "%60", "%60", "%60");
-    testUrlToUriMapping("{", "%7B", "%7B", "%7B", "%7B");
-    testUrlToUriMapping("|", "%7C", "%7C", "%7C", "%7C");
-    testUrlToUriMapping("}", "%7D", "%7D", "%7D", "%7D");
-    testUrlToUriMapping("~", "~", "~", "~", "~");
-    testUrlToUriMapping("~", "~", "~", "~", "~");
-    testUrlToUriMapping("\u007f", "%7F", "%7F", "%7F", "%7F");
-
-    // beyond ascii
-    testUrlToUriMapping("\u0080", "%C2%80", "%C2%80", "%C2%80", "%C2%80");
-    testUrlToUriMapping("\u20ac", "\u20ac", "\u20ac", "\u20ac", "\u20ac");
-    testUrlToUriMapping("\ud842\udf9f", "\ud842\udf9f", "\ud842\udf9f", "\ud842\udf9f",
-        "\ud842\udf9f");
-  }
-
-  @Test @Ignore public void lenientUrlToUriNul() throws Exception {
-    testUrlToUriMapping("\u0000", "%00", "%00", "%00", "%00"); // RI fails this
-  }
-
-  private void testUrlToUriMapping(String string, String asAuthority, String asFile, String asQuery,
-      String asFragment) throws Exception {
-    if (asAuthority != null) {
-      assertEquals("http://host" + asAuthority + ".tld/",
-          backdoorUrlToUri(new URL("http://host" + string + ".tld/")).toString());
-    }
-    if (asFile != null) {
-      assertEquals("http://host.tld/file" + asFile + "/",
-          backdoorUrlToUri(new URL("http://host.tld/file" + string + "/")).toString());
-    }
-    if (asQuery != null) {
-      assertEquals("http://host.tld/file?q" + asQuery + "=x",
-          backdoorUrlToUri(new URL("http://host.tld/file?q" + string + "=x")).toString());
-    }
-    assertEquals("http://host.tld/file#" + asFragment + "-x",
-        backdoorUrlToUri(new URL("http://host.tld/file#" + asFragment + "-x")).toString());
-  }
-
-  private URI backdoorUrlToUri(URL url) throws Exception {
-    final AtomicReference<URI> uriReference = new AtomicReference<URI>();
-
-    OkHttpClient client = new OkHttpClient();
-    client.setResponseCache(new ResponseCache() {
-      @Override public CacheRequest put(URI uri, URLConnection connection) throws IOException {
-        return null;
-      }
-
-      @Override public CacheResponse get(URI uri, String requestMethod,
-          Map<String, List<String>> requestHeaders) throws IOException {
-        uriReference.set(uri);
-        throw new UnsupportedOperationException();
-      }
-    });
-
-    try {
-      HttpURLConnection connection = client.open(url);
-      connection.getResponseCode();
-    } catch (Exception expected) {
-      if (expected.getCause() instanceof URISyntaxException) {
-        expected.printStackTrace();
-      }
-    }
-
-    return uriReference.get();
-  }
-}
diff --git a/okhttp/src/test/java/com/squareup/okhttp/internal/tls/FakeSSLSession.java b/okhttp/src/test/java/com/squareup/okhttp/internal/tls/FakeSSLSession.java
deleted file mode 100644
index 215e968dfe..0000000000
--- a/okhttp/src/test/java/com/squareup/okhttp/internal/tls/FakeSSLSession.java
+++ /dev/null
@@ -1,120 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements. See the NOTICE file distributed with this
- * work for additional information regarding copyright ownership. The ASF
- * licenses this file to You under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
- * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
- * License for the specific language governing permissions and limitations under
- * the License.
- */
-package com.squareup.okhttp.internal.tls;
-
-import java.security.Principal;
-import java.security.cert.Certificate;
-import javax.net.ssl.SSLPeerUnverifiedException;
-import javax.net.ssl.SSLSession;
-import javax.net.ssl.SSLSessionContext;
-import javax.security.cert.X509Certificate;
-
-final class FakeSSLSession implements SSLSession {
-  private final Certificate[] certificates;
-
-  public FakeSSLSession(Certificate... certificates) throws Exception {
-    this.certificates = certificates;
-  }
-
-  public int getApplicationBufferSize() {
-    throw new UnsupportedOperationException();
-  }
-
-  public String getCipherSuite() {
-    throw new UnsupportedOperationException();
-  }
-
-  public long getCreationTime() {
-    throw new UnsupportedOperationException();
-  }
-
-  public byte[] getId() {
-    throw new UnsupportedOperationException();
-  }
-
-  public long getLastAccessedTime() {
-    throw new UnsupportedOperationException();
-  }
-
-  public Certificate[] getLocalCertificates() {
-    throw new UnsupportedOperationException();
-  }
-
-  public Principal getLocalPrincipal() {
-    throw new UnsupportedOperationException();
-  }
-
-  public int getPacketBufferSize() {
-    throw new UnsupportedOperationException();
-  }
-
-  public Certificate[] getPeerCertificates() throws SSLPeerUnverifiedException {
-    if (certificates.length == 0) {
-      throw new SSLPeerUnverifiedException("peer not authenticated");
-    } else {
-      return certificates;
-    }
-  }
-
-  public X509Certificate[] getPeerCertificateChain() throws SSLPeerUnverifiedException {
-    throw new UnsupportedOperationException();
-  }
-
-  public String getPeerHost() {
-    throw new UnsupportedOperationException();
-  }
-
-  public int getPeerPort() {
-    throw new UnsupportedOperationException();
-  }
-
-  public Principal getPeerPrincipal() throws SSLPeerUnverifiedException {
-    throw new UnsupportedOperationException();
-  }
-
-  public String getProtocol() {
-    throw new UnsupportedOperationException();
-  }
-
-  public SSLSessionContext getSessionContext() {
-    throw new UnsupportedOperationException();
-  }
-
-  public void putValue(String s, Object obj) {
-    throw new UnsupportedOperationException();
-  }
-
-  public void removeValue(String s) {
-    throw new UnsupportedOperationException();
-  }
-
-  public Object getValue(String s) {
-    throw new UnsupportedOperationException();
-  }
-
-  public String[] getValueNames() {
-    throw new UnsupportedOperationException();
-  }
-
-  public void invalidate() {
-    throw new UnsupportedOperationException();
-  }
-
-  public boolean isValid() {
-    throw new UnsupportedOperationException();
-  }
-}
diff --git a/okhttp/src/test/java/com/squareup/okhttp/internal/tls/HostnameVerifierTest.java b/okhttp/src/test/java/com/squareup/okhttp/internal/tls/HostnameVerifierTest.java
deleted file mode 100644
index f1decc8df0..0000000000
--- a/okhttp/src/test/java/com/squareup/okhttp/internal/tls/HostnameVerifierTest.java
+++ /dev/null
@@ -1,553 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements. See the NOTICE file distributed with this
- * work for additional information regarding copyright ownership. The ASF
- * licenses this file to You under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
- * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
- * License for the specific language governing permissions and limitations under
- * the License.
- */
-
-package com.squareup.okhttp.internal.tls;
-
-import com.squareup.okhttp.internal.Util;
-import java.io.ByteArrayInputStream;
-import java.security.cert.CertificateFactory;
-import java.security.cert.X509Certificate;
-import javax.net.ssl.HostnameVerifier;
-import javax.net.ssl.SSLSession;
-import javax.security.auth.x500.X500Principal;
-import org.junit.Ignore;
-import org.junit.Test;
-
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertFalse;
-import static org.junit.Assert.assertTrue;
-
-/**
- * Tests for our hostname verifier. Most of these tests are from AOSP, which
- * itself includes tests from the Apache HTTP Client test suite.
- */
-public final class HostnameVerifierTest {
-  private HostnameVerifier verifier = OkHostnameVerifier.INSTANCE;
-
-  @Test public void verify() throws Exception {
-    FakeSSLSession session = new FakeSSLSession();
-    assertFalse(verifier.verify("localhost", session));
-  }
-
-  @Test public void verifyCn() throws Exception {
-    // CN=foo.com
-    SSLSession session = session(""
-        + "-----BEGIN CERTIFICATE-----\n"
-        + "MIIERjCCAy6gAwIBAgIJAIz+EYMBU6aQMA0GCSqGSIb3DQEBBQUAMIGiMQswCQYD\n"
-        + "VQQGEwJDQTELMAkGA1UECBMCQkMxEjAQBgNVBAcTCVZhbmNvdXZlcjEWMBQGA1UE\n"
-        + "ChMNd3d3LmN1Y2JjLmNvbTEUMBIGA1UECxQLY29tbW9uc19zc2wxHTAbBgNVBAMU\n"
-        + "FGRlbW9faW50ZXJtZWRpYXRlX2NhMSUwIwYJKoZIhvcNAQkBFhZqdWxpdXNkYXZp\n"
-        + "ZXNAZ21haWwuY29tMB4XDTA2MTIxMTE1MzE0MVoXDTI4MTEwNTE1MzE0MVowgaQx\n"
-        + "CzAJBgNVBAYTAlVTMREwDwYDVQQIEwhNYXJ5bGFuZDEUMBIGA1UEBxMLRm9yZXN0\n"
-        + "IEhpbGwxFzAVBgNVBAoTDmh0dHBjb21wb25lbnRzMRowGAYDVQQLExF0ZXN0IGNl\n"
-        + "cnRpZmljYXRlczEQMA4GA1UEAxMHZm9vLmNvbTElMCMGCSqGSIb3DQEJARYWanVs\n"
-        + "aXVzZGF2aWVzQGdtYWlsLmNvbTCCASIwDQYJKoZIhvcNAQEBBQADggEPADCCAQoC\n"
-        + "ggEBAMhjr5aCPoyp0R1iroWAfnEyBMGYWoCidH96yGPFjYLowez5aYKY1IOKTY2B\n"
-        + "lYho4O84X244QrZTRl8kQbYtxnGh4gSCD+Z8gjZ/gMvLUlhqOb+WXPAUHMB39GRy\n"
-        + "zerA/ZtrlUqf+lKo0uWcocxeRc771KN8cPH3nHZ0rV0Hx4ZAZy6U4xxObe4rtSVY\n"
-        + "07hNKXAb2odnVqgzcYiDkLV8ilvEmoNWMWrp8UBqkTcpEhYhCYp3cTkgJwMSuqv8\n"
-        + "BqnGd87xQU3FVZI4tbtkB+KzjD9zz8QCDJAfDjZHR03KNQ5mxOgXwxwKw6lGMaiV\n"
-        + "JTxpTKqym93whYk93l3ocEe55c0CAwEAAaN7MHkwCQYDVR0TBAIwADAsBglghkgB\n"
-        + "hvhCAQ0EHxYdT3BlblNTTCBHZW5lcmF0ZWQgQ2VydGlmaWNhdGUwHQYDVR0OBBYE\n"
-        + "FJ8Ud78/OrbKOIJCSBYs2tDLXofYMB8GA1UdIwQYMBaAFHua2o+QmU5S0qzbswNS\n"
-        + "yoemDT4NMA0GCSqGSIb3DQEBBQUAA4IBAQC3jRmEya6sQCkmieULcvx8zz1euCk9\n"
-        + "fSez7BEtki8+dmfMXe3K7sH0lI8f4jJR0rbSCjpmCQLYmzC3NxBKeJOW0RcjNBpO\n"
-        + "c2JlGO9auXv2GDP4IYiXElLJ6VSqc8WvDikv0JmCCWm0Zga+bZbR/EWN5DeEtFdF\n"
-        + "815CLpJZNcYwiYwGy/CVQ7w2TnXlG+mraZOz+owr+cL6J/ZesbdEWfjoS1+cUEhE\n"
-        + "HwlNrAu8jlZ2UqSgskSWlhYdMTAP9CPHiUv9N7FcT58Itv/I4fKREINQYjDpvQcx\n"
-        + "SaTYb9dr5sB4WLNglk7zxDtM80H518VvihTcP7FHL+Gn6g4j5fkI98+S\n"
-        + "-----END CERTIFICATE-----\n");
-    assertTrue(verifier.verify("foo.com", session));
-    assertFalse(verifier.verify("a.foo.com", session));
-    assertFalse(verifier.verify("bar.com", session));
-  }
-
-  @Test public void verifyNonAsciiCn() throws Exception {
-    // CN=&#x82b1;&#x5b50;.co.jp
-    SSLSession session = session(""
-        + "-----BEGIN CERTIFICATE-----\n"
-        + "MIIESzCCAzOgAwIBAgIJAIz+EYMBU6aTMA0GCSqGSIb3DQEBBQUAMIGiMQswCQYD\n"
-        + "VQQGEwJDQTELMAkGA1UECBMCQkMxEjAQBgNVBAcTCVZhbmNvdXZlcjEWMBQGA1UE\n"
-        + "ChMNd3d3LmN1Y2JjLmNvbTEUMBIGA1UECxQLY29tbW9uc19zc2wxHTAbBgNVBAMU\n"
-        + "FGRlbW9faW50ZXJtZWRpYXRlX2NhMSUwIwYJKoZIhvcNAQkBFhZqdWxpdXNkYXZp\n"
-        + "ZXNAZ21haWwuY29tMB4XDTA2MTIxMTE1NDIxNVoXDTI4MTEwNTE1NDIxNVowgakx\n"
-        + "CzAJBgNVBAYTAlVTMREwDwYDVQQIDAhNYXJ5bGFuZDEUMBIGA1UEBwwLRm9yZXN0\n"
-        + "IEhpbGwxFzAVBgNVBAoMDmh0dHBjb21wb25lbnRzMRowGAYDVQQLDBF0ZXN0IGNl\n"
-        + "cnRpZmljYXRlczEVMBMGA1UEAwwM6Iqx5a2QLmNvLmpwMSUwIwYJKoZIhvcNAQkB\n"
-        + "FhZqdWxpdXNkYXZpZXNAZ21haWwuY29tMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8A\n"
-        + "MIIBCgKCAQEAyGOvloI+jKnRHWKuhYB+cTIEwZhagKJ0f3rIY8WNgujB7PlpgpjU\n"
-        + "g4pNjYGViGjg7zhfbjhCtlNGXyRBti3GcaHiBIIP5nyCNn+Ay8tSWGo5v5Zc8BQc\n"
-        + "wHf0ZHLN6sD9m2uVSp/6UqjS5ZyhzF5FzvvUo3xw8fecdnStXQfHhkBnLpTjHE5t\n"
-        + "7iu1JVjTuE0pcBvah2dWqDNxiIOQtXyKW8Sag1YxaunxQGqRNykSFiEJindxOSAn\n"
-        + "AxK6q/wGqcZ3zvFBTcVVkji1u2QH4rOMP3PPxAIMkB8ONkdHTco1DmbE6BfDHArD\n"
-        + "qUYxqJUlPGlMqrKb3fCFiT3eXehwR7nlzQIDAQABo3sweTAJBgNVHRMEAjAAMCwG\n"
-        + "CWCGSAGG+EIBDQQfFh1PcGVuU1NMIEdlbmVyYXRlZCBDZXJ0aWZpY2F0ZTAdBgNV\n"
-        + "HQ4EFgQUnxR3vz86tso4gkJIFiza0Mteh9gwHwYDVR0jBBgwFoAUe5raj5CZTlLS\n"
-        + "rNuzA1LKh6YNPg0wDQYJKoZIhvcNAQEFBQADggEBALJ27i3okV/KvlDp6KMID3gd\n"
-        + "ITl68PyItzzx+SquF8gahMh016NX73z/oVZoVUNdftla8wPUB1GwIkAnGkhQ9LHK\n"
-        + "spBdbRiCj0gMmLCsX8SrjFvr7cYb2cK6J/fJe92l1tg/7Y4o7V/s4JBe/cy9U9w8\n"
-        + "a0ctuDmEBCgC784JMDtT67klRfr/2LlqWhlOEq7pUFxRLbhpquaAHSOjmIcWnVpw\n"
-        + "9BsO7qe46hidgn39hKh1WjKK2VcL/3YRsC4wUi0PBtFW6ScMCuMhgIRXSPU55Rae\n"
-        + "UIlOdPjjr1SUNWGId1rD7W16Scpwnknn310FNxFMHVI0GTGFkNdkilNCFJcIoRA=\n"
-        + "-----END CERTIFICATE-----\n");
-    assertTrue(verifier.verify("\u82b1\u5b50.co.jp", session));
-    assertFalse(verifier.verify("a.\u82b1\u5b50.co.jp", session));
-  }
-
-  @Test public void verifySubjectAlt() throws Exception {
-    // CN=foo.com, subjectAlt=bar.com
-    SSLSession session = session(""
-        + "-----BEGIN CERTIFICATE-----\n"
-        + "MIIEXDCCA0SgAwIBAgIJAIz+EYMBU6aRMA0GCSqGSIb3DQEBBQUAMIGiMQswCQYD\n"
-        + "VQQGEwJDQTELMAkGA1UECBMCQkMxEjAQBgNVBAcTCVZhbmNvdXZlcjEWMBQGA1UE\n"
-        + "ChMNd3d3LmN1Y2JjLmNvbTEUMBIGA1UECxQLY29tbW9uc19zc2wxHTAbBgNVBAMU\n"
-        + "FGRlbW9faW50ZXJtZWRpYXRlX2NhMSUwIwYJKoZIhvcNAQkBFhZqdWxpdXNkYXZp\n"
-        + "ZXNAZ21haWwuY29tMB4XDTA2MTIxMTE1MzYyOVoXDTI4MTEwNTE1MzYyOVowgaQx\n"
-        + "CzAJBgNVBAYTAlVTMREwDwYDVQQIEwhNYXJ5bGFuZDEUMBIGA1UEBxMLRm9yZXN0\n"
-        + "IEhpbGwxFzAVBgNVBAoTDmh0dHBjb21wb25lbnRzMRowGAYDVQQLExF0ZXN0IGNl\n"
-        + "cnRpZmljYXRlczEQMA4GA1UEAxMHZm9vLmNvbTElMCMGCSqGSIb3DQEJARYWanVs\n"
-        + "aXVzZGF2aWVzQGdtYWlsLmNvbTCCASIwDQYJKoZIhvcNAQEBBQADggEPADCCAQoC\n"
-        + "ggEBAMhjr5aCPoyp0R1iroWAfnEyBMGYWoCidH96yGPFjYLowez5aYKY1IOKTY2B\n"
-        + "lYho4O84X244QrZTRl8kQbYtxnGh4gSCD+Z8gjZ/gMvLUlhqOb+WXPAUHMB39GRy\n"
-        + "zerA/ZtrlUqf+lKo0uWcocxeRc771KN8cPH3nHZ0rV0Hx4ZAZy6U4xxObe4rtSVY\n"
-        + "07hNKXAb2odnVqgzcYiDkLV8ilvEmoNWMWrp8UBqkTcpEhYhCYp3cTkgJwMSuqv8\n"
-        + "BqnGd87xQU3FVZI4tbtkB+KzjD9zz8QCDJAfDjZHR03KNQ5mxOgXwxwKw6lGMaiV\n"
-        + "JTxpTKqym93whYk93l3ocEe55c0CAwEAAaOBkDCBjTAJBgNVHRMEAjAAMCwGCWCG\n"
-        + "SAGG+EIBDQQfFh1PcGVuU1NMIEdlbmVyYXRlZCBDZXJ0aWZpY2F0ZTAdBgNVHQ4E\n"
-        + "FgQUnxR3vz86tso4gkJIFiza0Mteh9gwHwYDVR0jBBgwFoAUe5raj5CZTlLSrNuz\n"
-        + "A1LKh6YNPg0wEgYDVR0RBAswCYIHYmFyLmNvbTANBgkqhkiG9w0BAQUFAAOCAQEA\n"
-        + "dQyprNZBmVnvuVWjV42sey/PTfkYShJwy1j0/jcFZR/ypZUovpiHGDO1DgL3Y3IP\n"
-        + "zVQ26uhUsSw6G0gGRiaBDe/0LUclXZoJzXX1qpS55OadxW73brziS0sxRgGrZE/d\n"
-        + "3g5kkio6IED47OP6wYnlmZ7EKP9cqjWwlnvHnnUcZ2SscoLNYs9rN9ccp8tuq2by\n"
-        + "88OyhKwGjJfhOudqfTNZcDzRHx4Fzm7UsVaycVw4uDmhEHJrAsmMPpj/+XRK9/42\n"
-        + "2xq+8bc6HojdtbCyug/fvBZvZqQXSmU8m8IVcMmWMz0ZQO8ee3QkBHMZfCy7P/kr\n"
-        + "VbWx/uETImUu+NZg22ewEw==\n"
-        + "-----END CERTIFICATE-----\n");
-    assertFalse(verifier.verify("foo.com", session));
-    assertFalse(verifier.verify("a.foo.com", session));
-    assertTrue(verifier.verify("bar.com", session));
-    assertFalse(verifier.verify("a.bar.com", session));
-  }
-
-  /**
-   * Ignored due to incompatibilities between Android and Java on how non-ASCII
-   * subject alt names are parsed. Android fails to parse these, which means we
-   * fall back to the CN. The RI does parse them, so the CN is unused.
-   */
-  @Test @Ignore public void verifyNonAsciiSubjectAlt() throws Exception {
-    // CN=foo.com, subjectAlt=bar.com, subjectAlt=&#x82b1;&#x5b50;.co.jp
-    // (hanako.co.jp in kanji)
-    SSLSession session = session(""
-        + "-----BEGIN CERTIFICATE-----\n"
-        + "MIIEajCCA1KgAwIBAgIJAIz+EYMBU6aSMA0GCSqGSIb3DQEBBQUAMIGiMQswCQYD\n"
-        + "VQQGEwJDQTELMAkGA1UECBMCQkMxEjAQBgNVBAcTCVZhbmNvdXZlcjEWMBQGA1UE\n"
-        + "ChMNd3d3LmN1Y2JjLmNvbTEUMBIGA1UECxQLY29tbW9uc19zc2wxHTAbBgNVBAMU\n"
-        + "FGRlbW9faW50ZXJtZWRpYXRlX2NhMSUwIwYJKoZIhvcNAQkBFhZqdWxpdXNkYXZp\n"
-        + "ZXNAZ21haWwuY29tMB4XDTA2MTIxMTE1MzgxM1oXDTI4MTEwNTE1MzgxM1owgaQx\n"
-        + "CzAJBgNVBAYTAlVTMREwDwYDVQQIEwhNYXJ5bGFuZDEUMBIGA1UEBxMLRm9yZXN0\n"
-        + "IEhpbGwxFzAVBgNVBAoTDmh0dHBjb21wb25lbnRzMRowGAYDVQQLExF0ZXN0IGNl\n"
-        + "cnRpZmljYXRlczEQMA4GA1UEAxMHZm9vLmNvbTElMCMGCSqGSIb3DQEJARYWanVs\n"
-        + "aXVzZGF2aWVzQGdtYWlsLmNvbTCCASIwDQYJKoZIhvcNAQEBBQADggEPADCCAQoC\n"
-        + "ggEBAMhjr5aCPoyp0R1iroWAfnEyBMGYWoCidH96yGPFjYLowez5aYKY1IOKTY2B\n"
-        + "lYho4O84X244QrZTRl8kQbYtxnGh4gSCD+Z8gjZ/gMvLUlhqOb+WXPAUHMB39GRy\n"
-        + "zerA/ZtrlUqf+lKo0uWcocxeRc771KN8cPH3nHZ0rV0Hx4ZAZy6U4xxObe4rtSVY\n"
-        + "07hNKXAb2odnVqgzcYiDkLV8ilvEmoNWMWrp8UBqkTcpEhYhCYp3cTkgJwMSuqv8\n"
-        + "BqnGd87xQU3FVZI4tbtkB+KzjD9zz8QCDJAfDjZHR03KNQ5mxOgXwxwKw6lGMaiV\n"
-        + "JTxpTKqym93whYk93l3ocEe55c0CAwEAAaOBnjCBmzAJBgNVHRMEAjAAMCwGCWCG\n"
-        + "SAGG+EIBDQQfFh1PcGVuU1NMIEdlbmVyYXRlZCBDZXJ0aWZpY2F0ZTAdBgNVHQ4E\n"
-        + "FgQUnxR3vz86tso4gkJIFiza0Mteh9gwHwYDVR0jBBgwFoAUe5raj5CZTlLSrNuz\n"
-        + "A1LKh6YNPg0wIAYDVR0RBBkwF4IHYmFyLmNvbYIM6Iqx5a2QLmNvLmpwMA0GCSqG\n"
-        + "SIb3DQEBBQUAA4IBAQBeZs7ZIYyKtdnVxVvdLgwySEPOE4pBSXii7XYv0Q9QUvG/\n"
-        + "++gFGQh89HhABzA1mVUjH5dJTQqSLFvRfqTHqLpxSxSWqMHnvRM4cPBkIRp/XlMK\n"
-        + "PlXadYtJLPTgpbgvulA1ickC9EwlNYWnowZ4uxnfsMghW4HskBqaV+PnQ8Zvy3L0\n"
-        + "12c7Cg4mKKS5pb1HdRuiD2opZ+Hc77gRQLvtWNS8jQvd/iTbh6fuvTKfAOFoXw22\n"
-        + "sWIKHYrmhCIRshUNohGXv50m2o+1w9oWmQ6Dkq7lCjfXfUB4wIbggJjpyEtbNqBt\n"
-        + "j4MC2x5rfsLKKqToKmNE7pFEgqwe8//Aar1b+Qj+\n"
-        + "-----END CERTIFICATE-----\n");
-    assertTrue(verifier.verify("foo.com", session));
-    assertFalse(verifier.verify("a.foo.com", session));
-    // these checks test alternative subjects. The test data contains an
-    // alternative subject starting with a japanese kanji character. This is
-    // not supported by Android because the underlying implementation from
-    // harmony follows the definition from rfc 1034 page 10 for alternative
-    // subject names. This causes the code to drop all alternative subjects.
-    // assertTrue(verifier.verify("bar.com", session));
-    // assertFalse(verifier.verify("a.bar.com", session));
-    // assertFalse(verifier.verify("a.\u82b1\u5b50.co.jp", session));
-  }
-
-  @Test public void verifySubjectAltOnly() throws Exception {
-    // subjectAlt=foo.com
-    SSLSession session = session(""
-        + "-----BEGIN CERTIFICATE-----\n"
-        + "MIIESjCCAzKgAwIBAgIJAIz+EYMBU6aYMA0GCSqGSIb3DQEBBQUAMIGiMQswCQYD\n"
-        + "VQQGEwJDQTELMAkGA1UECBMCQkMxEjAQBgNVBAcTCVZhbmNvdXZlcjEWMBQGA1UE\n"
-        + "ChMNd3d3LmN1Y2JjLmNvbTEUMBIGA1UECxQLY29tbW9uc19zc2wxHTAbBgNVBAMU\n"
-        + "FGRlbW9faW50ZXJtZWRpYXRlX2NhMSUwIwYJKoZIhvcNAQkBFhZqdWxpdXNkYXZp\n"
-        + "ZXNAZ21haWwuY29tMB4XDTA2MTIxMTE2MjYxMFoXDTI4MTEwNTE2MjYxMFowgZIx\n"
-        + "CzAJBgNVBAYTAlVTMREwDwYDVQQIDAhNYXJ5bGFuZDEUMBIGA1UEBwwLRm9yZXN0\n"
-        + "IEhpbGwxFzAVBgNVBAoMDmh0dHBjb21wb25lbnRzMRowGAYDVQQLDBF0ZXN0IGNl\n"
-        + "cnRpZmljYXRlczElMCMGCSqGSIb3DQEJARYWanVsaXVzZGF2aWVzQGdtYWlsLmNv\n"
-        + "bTCCASIwDQYJKoZIhvcNAQEBBQADggEPADCCAQoCggEBAMhjr5aCPoyp0R1iroWA\n"
-        + "fnEyBMGYWoCidH96yGPFjYLowez5aYKY1IOKTY2BlYho4O84X244QrZTRl8kQbYt\n"
-        + "xnGh4gSCD+Z8gjZ/gMvLUlhqOb+WXPAUHMB39GRyzerA/ZtrlUqf+lKo0uWcocxe\n"
-        + "Rc771KN8cPH3nHZ0rV0Hx4ZAZy6U4xxObe4rtSVY07hNKXAb2odnVqgzcYiDkLV8\n"
-        + "ilvEmoNWMWrp8UBqkTcpEhYhCYp3cTkgJwMSuqv8BqnGd87xQU3FVZI4tbtkB+Kz\n"
-        + "jD9zz8QCDJAfDjZHR03KNQ5mxOgXwxwKw6lGMaiVJTxpTKqym93whYk93l3ocEe5\n"
-        + "5c0CAwEAAaOBkDCBjTAJBgNVHRMEAjAAMCwGCWCGSAGG+EIBDQQfFh1PcGVuU1NM\n"
-        + "IEdlbmVyYXRlZCBDZXJ0aWZpY2F0ZTAdBgNVHQ4EFgQUnxR3vz86tso4gkJIFiza\n"
-        + "0Mteh9gwHwYDVR0jBBgwFoAUe5raj5CZTlLSrNuzA1LKh6YNPg0wEgYDVR0RBAsw\n"
-        + "CYIHZm9vLmNvbTANBgkqhkiG9w0BAQUFAAOCAQEAjl78oMjzFdsMy6F1sGg/IkO8\n"
-        + "tF5yUgPgFYrs41yzAca7IQu6G9qtFDJz/7ehh/9HoG+oqCCIHPuIOmS7Sd0wnkyJ\n"
-        + "Y7Y04jVXIb3a6f6AgBkEFP1nOT0z6kjT7vkA5LJ2y3MiDcXuRNMSta5PYVnrX8aZ\n"
-        + "yiqVUNi40peuZ2R8mAUSBvWgD7z2qWhF8YgDb7wWaFjg53I36vWKn90ZEti3wNCw\n"
-        + "qAVqixM+J0qJmQStgAc53i2aTMvAQu3A3snvH/PHTBo+5UL72n9S1kZyNCsVf1Qo\n"
-        + "n8jKTiRriEM+fMFlcgQP284EBFzYHyCXFb9O/hMjK2+6mY9euMB1U1aFFzM/Bg==\n"
-        + "-----END CERTIFICATE-----\n");
-    assertTrue(verifier.verify("foo.com", session));
-    assertFalse(verifier.verify("a.foo.com", session));
-    assertTrue(verifier.verify("foo.com", session));
-    assertFalse(verifier.verify("a.foo.com", session));
-  }
-
-  @Test public void verifyMultipleCn() throws Exception {
-    // CN=foo.com, CN=bar.com, CN=&#x82b1;&#x5b50;.co.jp
-    SSLSession session = session(""
-        + "-----BEGIN CERTIFICATE-----\n"
-        + "MIIEbzCCA1egAwIBAgIJAIz+EYMBU6aXMA0GCSqGSIb3DQEBBQUAMIGiMQswCQYD\n"
-        + "VQQGEwJDQTELMAkGA1UECBMCQkMxEjAQBgNVBAcTCVZhbmNvdXZlcjEWMBQGA1UE\n"
-        + "ChMNd3d3LmN1Y2JjLmNvbTEUMBIGA1UECxQLY29tbW9uc19zc2wxHTAbBgNVBAMU\n"
-        + "FGRlbW9faW50ZXJtZWRpYXRlX2NhMSUwIwYJKoZIhvcNAQkBFhZqdWxpdXNkYXZp\n"
-        + "ZXNAZ21haWwuY29tMB4XDTA2MTIxMTE2MTk0NVoXDTI4MTEwNTE2MTk0NVowgc0x\n"
-        + "CzAJBgNVBAYTAlVTMREwDwYDVQQIDAhNYXJ5bGFuZDEUMBIGA1UEBwwLRm9yZXN0\n"
-        + "IEhpbGwxFzAVBgNVBAoMDmh0dHBjb21wb25lbnRzMRowGAYDVQQLDBF0ZXN0IGNl\n"
-        + "cnRpZmljYXRlczEQMA4GA1UEAwwHZm9vLmNvbTEQMA4GA1UEAwwHYmFyLmNvbTEV\n"
-        + "MBMGA1UEAwwM6Iqx5a2QLmNvLmpwMSUwIwYJKoZIhvcNAQkBFhZqdWxpdXNkYXZp\n"
-        + "ZXNAZ21haWwuY29tMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAyGOv\n"
-        + "loI+jKnRHWKuhYB+cTIEwZhagKJ0f3rIY8WNgujB7PlpgpjUg4pNjYGViGjg7zhf\n"
-        + "bjhCtlNGXyRBti3GcaHiBIIP5nyCNn+Ay8tSWGo5v5Zc8BQcwHf0ZHLN6sD9m2uV\n"
-        + "Sp/6UqjS5ZyhzF5FzvvUo3xw8fecdnStXQfHhkBnLpTjHE5t7iu1JVjTuE0pcBva\n"
-        + "h2dWqDNxiIOQtXyKW8Sag1YxaunxQGqRNykSFiEJindxOSAnAxK6q/wGqcZ3zvFB\n"
-        + "TcVVkji1u2QH4rOMP3PPxAIMkB8ONkdHTco1DmbE6BfDHArDqUYxqJUlPGlMqrKb\n"
-        + "3fCFiT3eXehwR7nlzQIDAQABo3sweTAJBgNVHRMEAjAAMCwGCWCGSAGG+EIBDQQf\n"
-        + "Fh1PcGVuU1NMIEdlbmVyYXRlZCBDZXJ0aWZpY2F0ZTAdBgNVHQ4EFgQUnxR3vz86\n"
-        + "tso4gkJIFiza0Mteh9gwHwYDVR0jBBgwFoAUe5raj5CZTlLSrNuzA1LKh6YNPg0w\n"
-        + "DQYJKoZIhvcNAQEFBQADggEBAGuZb8ai1NO2j4v3y9TLZvd5s0vh5/TE7n7RX+8U\n"
-        + "y37OL5k7x9nt0mM1TyAKxlCcY+9h6frue8MemZIILSIvMrtzccqNz0V1WKgA+Orf\n"
-        + "uUrabmn+CxHF5gpy6g1Qs2IjVYWA5f7FROn/J+Ad8gJYc1azOWCLQqSyfpNRLSvY\n"
-        + "EriQFEV63XvkJ8JrG62b+2OT2lqT4OO07gSPetppdlSa8NBSKP6Aro9RIX1ZjUZQ\n"
-        + "SpQFCfo02NO0uNRDPUdJx2huycdNb+AXHaO7eXevDLJ+QnqImIzxWiY6zLOdzjjI\n"
-        + "VBMkLHmnP7SjGSQ3XA4ByrQOxfOUTyLyE7NuemhHppuQPxE=\n"
-        + "-----END CERTIFICATE-----\n");
-    assertFalse(verifier.verify("foo.com", session));
-    assertFalse(verifier.verify("a.foo.com", session));
-    assertFalse(verifier.verify("bar.com", session));
-    assertFalse(verifier.verify("a.bar.com", session));
-    assertTrue(verifier.verify("\u82b1\u5b50.co.jp", session));
-    assertFalse(verifier.verify("a.\u82b1\u5b50.co.jp", session));
-  }
-
-  @Test public void verifyWilcardCn() throws Exception {
-    // CN=*.foo.com
-    SSLSession session = session(""
-        + "-----BEGIN CERTIFICATE-----\n"
-        + "MIIESDCCAzCgAwIBAgIJAIz+EYMBU6aUMA0GCSqGSIb3DQEBBQUAMIGiMQswCQYD\n"
-        + "VQQGEwJDQTELMAkGA1UECBMCQkMxEjAQBgNVBAcTCVZhbmNvdXZlcjEWMBQGA1UE\n"
-        + "ChMNd3d3LmN1Y2JjLmNvbTEUMBIGA1UECxQLY29tbW9uc19zc2wxHTAbBgNVBAMU\n"
-        + "FGRlbW9faW50ZXJtZWRpYXRlX2NhMSUwIwYJKoZIhvcNAQkBFhZqdWxpdXNkYXZp\n"
-        + "ZXNAZ21haWwuY29tMB4XDTA2MTIxMTE2MTU1NVoXDTI4MTEwNTE2MTU1NVowgaYx\n"
-        + "CzAJBgNVBAYTAlVTMREwDwYDVQQIEwhNYXJ5bGFuZDEUMBIGA1UEBxMLRm9yZXN0\n"
-        + "IEhpbGwxFzAVBgNVBAoTDmh0dHBjb21wb25lbnRzMRowGAYDVQQLExF0ZXN0IGNl\n"
-        + "cnRpZmljYXRlczESMBAGA1UEAxQJKi5mb28uY29tMSUwIwYJKoZIhvcNAQkBFhZq\n"
-        + "dWxpdXNkYXZpZXNAZ21haWwuY29tMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIB\n"
-        + "CgKCAQEAyGOvloI+jKnRHWKuhYB+cTIEwZhagKJ0f3rIY8WNgujB7PlpgpjUg4pN\n"
-        + "jYGViGjg7zhfbjhCtlNGXyRBti3GcaHiBIIP5nyCNn+Ay8tSWGo5v5Zc8BQcwHf0\n"
-        + "ZHLN6sD9m2uVSp/6UqjS5ZyhzF5FzvvUo3xw8fecdnStXQfHhkBnLpTjHE5t7iu1\n"
-        + "JVjTuE0pcBvah2dWqDNxiIOQtXyKW8Sag1YxaunxQGqRNykSFiEJindxOSAnAxK6\n"
-        + "q/wGqcZ3zvFBTcVVkji1u2QH4rOMP3PPxAIMkB8ONkdHTco1DmbE6BfDHArDqUYx\n"
-        + "qJUlPGlMqrKb3fCFiT3eXehwR7nlzQIDAQABo3sweTAJBgNVHRMEAjAAMCwGCWCG\n"
-        + "SAGG+EIBDQQfFh1PcGVuU1NMIEdlbmVyYXRlZCBDZXJ0aWZpY2F0ZTAdBgNVHQ4E\n"
-        + "FgQUnxR3vz86tso4gkJIFiza0Mteh9gwHwYDVR0jBBgwFoAUe5raj5CZTlLSrNuz\n"
-        + "A1LKh6YNPg0wDQYJKoZIhvcNAQEFBQADggEBAH0ipG6J561UKUfgkeW7GvYwW98B\n"
-        + "N1ZooWX+JEEZK7+Pf/96d3Ij0rw9ACfN4bpfnCq0VUNZVSYB+GthQ2zYuz7tf/UY\n"
-        + "A6nxVgR/IjG69BmsBl92uFO7JTNtHztuiPqBn59pt+vNx4yPvno7zmxsfI7jv0ww\n"
-        + "yfs+0FNm7FwdsC1k47GBSOaGw38kuIVWqXSAbL4EX9GkryGGOKGNh0qvAENCdRSB\n"
-        + "G9Z6tyMbmfRY+dLSh3a9JwoEcBUso6EWYBakLbq4nG/nvYdYvG9ehrnLVwZFL82e\n"
-        + "l3Q/RK95bnA6cuRClGusLad0e6bjkBzx/VQ3VarDEpAkTLUGVAa0CLXtnyc=\n"
-        + "-----END CERTIFICATE-----\n");
-    assertTrue(verifier.verify("foo.com", session));
-    assertTrue(verifier.verify("www.foo.com", session));
-    assertTrue(verifier.verify("\u82b1\u5b50.foo.com", session));
-    assertFalse(verifier.verify("a.b.foo.com", session));
-  }
-
-  @Test public void verifyWilcardCnOnTld() throws Exception {
-    // It's the CA's responsibility to not issue broad-matching certificates!
-    // CN=*.co.jp
-    SSLSession session = session(""
-        + "-----BEGIN CERTIFICATE-----\n"
-        + "MIIERjCCAy6gAwIBAgIJAIz+EYMBU6aVMA0GCSqGSIb3DQEBBQUAMIGiMQswCQYD\n"
-        + "VQQGEwJDQTELMAkGA1UECBMCQkMxEjAQBgNVBAcTCVZhbmNvdXZlcjEWMBQGA1UE\n"
-        + "ChMNd3d3LmN1Y2JjLmNvbTEUMBIGA1UECxQLY29tbW9uc19zc2wxHTAbBgNVBAMU\n"
-        + "FGRlbW9faW50ZXJtZWRpYXRlX2NhMSUwIwYJKoZIhvcNAQkBFhZqdWxpdXNkYXZp\n"
-        + "ZXNAZ21haWwuY29tMB4XDTA2MTIxMTE2MTYzMFoXDTI4MTEwNTE2MTYzMFowgaQx\n"
-        + "CzAJBgNVBAYTAlVTMREwDwYDVQQIEwhNYXJ5bGFuZDEUMBIGA1UEBxMLRm9yZXN0\n"
-        + "IEhpbGwxFzAVBgNVBAoTDmh0dHBjb21wb25lbnRzMRowGAYDVQQLExF0ZXN0IGNl\n"
-        + "cnRpZmljYXRlczEQMA4GA1UEAxQHKi5jby5qcDElMCMGCSqGSIb3DQEJARYWanVs\n"
-        + "aXVzZGF2aWVzQGdtYWlsLmNvbTCCASIwDQYJKoZIhvcNAQEBBQADggEPADCCAQoC\n"
-        + "ggEBAMhjr5aCPoyp0R1iroWAfnEyBMGYWoCidH96yGPFjYLowez5aYKY1IOKTY2B\n"
-        + "lYho4O84X244QrZTRl8kQbYtxnGh4gSCD+Z8gjZ/gMvLUlhqOb+WXPAUHMB39GRy\n"
-        + "zerA/ZtrlUqf+lKo0uWcocxeRc771KN8cPH3nHZ0rV0Hx4ZAZy6U4xxObe4rtSVY\n"
-        + "07hNKXAb2odnVqgzcYiDkLV8ilvEmoNWMWrp8UBqkTcpEhYhCYp3cTkgJwMSuqv8\n"
-        + "BqnGd87xQU3FVZI4tbtkB+KzjD9zz8QCDJAfDjZHR03KNQ5mxOgXwxwKw6lGMaiV\n"
-        + "JTxpTKqym93whYk93l3ocEe55c0CAwEAAaN7MHkwCQYDVR0TBAIwADAsBglghkgB\n"
-        + "hvhCAQ0EHxYdT3BlblNTTCBHZW5lcmF0ZWQgQ2VydGlmaWNhdGUwHQYDVR0OBBYE\n"
-        + "FJ8Ud78/OrbKOIJCSBYs2tDLXofYMB8GA1UdIwQYMBaAFHua2o+QmU5S0qzbswNS\n"
-        + "yoemDT4NMA0GCSqGSIb3DQEBBQUAA4IBAQA0sWglVlMx2zNGvUqFC73XtREwii53\n"
-        + "CfMM6mtf2+f3k/d8KXhLNySrg8RRlN11zgmpPaLtbdTLrmG4UdAHHYr8O4y2BBmE\n"
-        + "1cxNfGxxechgF8HX10QV4dkyzp6Z1cfwvCeMrT5G/V1pejago0ayXx+GPLbWlNeZ\n"
-        + "S+Kl0m3p+QplXujtwG5fYcIpaGpiYraBLx3Tadih39QN65CnAh/zRDhLCUzKyt9l\n"
-        + "UGPLEUDzRHMPHLnSqT1n5UU5UDRytbjJPXzF+l/+WZIsanefWLsxnkgAuZe/oMMF\n"
-        + "EJMryEzOjg4Tfuc5qM0EXoPcQ/JlheaxZ40p2IyHqbsWV4MRYuFH4bkM\n"
-        + "-----END CERTIFICATE-----\n");
-    assertTrue(verifier.verify("foo.co.jp", session));
-    assertTrue(verifier.verify("\u82b1\u5b50.co.jp", session));
-  }
-
-  /**
-   * Ignored due to incompatibilities between Android and Java on how non-ASCII
-   * subject alt names are parsed. Android fails to parse these, which means we
-   * fall back to the CN. The RI does parse them, so the CN is unused.
-   */
-  @Test @Ignore public void testWilcardNonAsciiSubjectAlt() throws Exception {
-    // CN=*.foo.com, subjectAlt=*.bar.com, subjectAlt=*.&#x82b1;&#x5b50;.co.jp
-    // (*.hanako.co.jp in kanji)
-    SSLSession session = session(""
-        + "-----BEGIN CERTIFICATE-----\n"
-        + "MIIEcDCCA1igAwIBAgIJAIz+EYMBU6aWMA0GCSqGSIb3DQEBBQUAMIGiMQswCQYD\n"
-        + "VQQGEwJDQTELMAkGA1UECBMCQkMxEjAQBgNVBAcTCVZhbmNvdXZlcjEWMBQGA1UE\n"
-        + "ChMNd3d3LmN1Y2JjLmNvbTEUMBIGA1UECxQLY29tbW9uc19zc2wxHTAbBgNVBAMU\n"
-        + "FGRlbW9faW50ZXJtZWRpYXRlX2NhMSUwIwYJKoZIhvcNAQkBFhZqdWxpdXNkYXZp\n"
-        + "ZXNAZ21haWwuY29tMB4XDTA2MTIxMTE2MTczMVoXDTI4MTEwNTE2MTczMVowgaYx\n"
-        + "CzAJBgNVBAYTAlVTMREwDwYDVQQIEwhNYXJ5bGFuZDEUMBIGA1UEBxMLRm9yZXN0\n"
-        + "IEhpbGwxFzAVBgNVBAoTDmh0dHBjb21wb25lbnRzMRowGAYDVQQLExF0ZXN0IGNl\n"
-        + "cnRpZmljYXRlczESMBAGA1UEAxQJKi5mb28uY29tMSUwIwYJKoZIhvcNAQkBFhZq\n"
-        + "dWxpdXNkYXZpZXNAZ21haWwuY29tMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIB\n"
-        + "CgKCAQEAyGOvloI+jKnRHWKuhYB+cTIEwZhagKJ0f3rIY8WNgujB7PlpgpjUg4pN\n"
-        + "jYGViGjg7zhfbjhCtlNGXyRBti3GcaHiBIIP5nyCNn+Ay8tSWGo5v5Zc8BQcwHf0\n"
-        + "ZHLN6sD9m2uVSp/6UqjS5ZyhzF5FzvvUo3xw8fecdnStXQfHhkBnLpTjHE5t7iu1\n"
-        + "JVjTuE0pcBvah2dWqDNxiIOQtXyKW8Sag1YxaunxQGqRNykSFiEJindxOSAnAxK6\n"
-        + "q/wGqcZ3zvFBTcVVkji1u2QH4rOMP3PPxAIMkB8ONkdHTco1DmbE6BfDHArDqUYx\n"
-        + "qJUlPGlMqrKb3fCFiT3eXehwR7nlzQIDAQABo4GiMIGfMAkGA1UdEwQCMAAwLAYJ\n"
-        + "YIZIAYb4QgENBB8WHU9wZW5TU0wgR2VuZXJhdGVkIENlcnRpZmljYXRlMB0GA1Ud\n"
-        + "DgQWBBSfFHe/Pzq2yjiCQkgWLNrQy16H2DAfBgNVHSMEGDAWgBR7mtqPkJlOUtKs\n"
-        + "27MDUsqHpg0+DTAkBgNVHREEHTAbggkqLmJhci5jb22CDiou6Iqx5a2QLmNvLmpw\n"
-        + "MA0GCSqGSIb3DQEBBQUAA4IBAQBobWC+D5/lx6YhX64CwZ26XLjxaE0S415ajbBq\n"
-        + "DK7lz+Rg7zOE3GsTAMi+ldUYnhyz0wDiXB8UwKXl0SDToB2Z4GOgqQjAqoMmrP0u\n"
-        + "WB6Y6dpkfd1qDRUzI120zPYgSdsXjHW9q2H77iV238hqIU7qCvEz+lfqqWEY504z\n"
-        + "hYNlknbUnR525ItosEVwXFBJTkZ3Yw8gg02c19yi8TAh5Li3Ad8XQmmSJMWBV4XK\n"
-        + "qFr0AIZKBlg6NZZFf/0dP9zcKhzSriW27bY0XfzA6GSiRDXrDjgXq6baRT6YwgIg\n"
-        + "pgJsDbJtZfHnV1nd3M6zOtQPm1TIQpNmMMMd/DPrGcUQerD3\n"
-        + "-----END CERTIFICATE-----\n");
-    // try the foo.com variations
-    assertTrue(verifier.verify("foo.com", session));
-    assertTrue(verifier.verify("www.foo.com", session));
-    assertTrue(verifier.verify("\u82b1\u5b50.foo.com", session));
-    assertFalse(verifier.verify("a.b.foo.com", session));
-    // these checks test alternative subjects. The test data contains an
-    // alternative subject starting with a japanese kanji character. This is
-    // not supported by Android because the underlying implementation from
-    // harmony follows the definition from rfc 1034 page 10 for alternative
-    // subject names. This causes the code to drop all alternative subjects.
-    // assertFalse(verifier.verify("bar.com", session));
-    // assertTrue(verifier.verify("www.bar.com", session));
-    // assertTrue(verifier.verify("\u82b1\u5b50.bar.com", session));
-    // assertTrue(verifier.verify("a.b.bar.com", session));
-  }
-
-  @Test public void subjectAltUsesLocalDomainAndIp() throws Exception {
-    // cat cert.cnf
-    // [req]
-    // distinguished_name=distinguished_name
-    // req_extensions=req_extensions
-    // x509_extensions=x509_extensions
-    // [distinguished_name]
-    // [req_extensions]
-    // [x509_extensions]
-    // subjectAltName=DNS:localhost.localdomain,DNS:localhost,IP:127.0.0.1
-    //
-    // $ openssl req -x509 -nodes -days 36500 -subj '/CN=localhost' -config ./cert.cnf \
-    //     -newkey rsa:512 -out cert.pem
-    X509Certificate certificate = certificate(""
-        + "-----BEGIN CERTIFICATE-----\n"
-        + "MIIBWDCCAQKgAwIBAgIJANS1EtICX2AZMA0GCSqGSIb3DQEBBQUAMBQxEjAQBgNV\n"
-        + "BAMTCWxvY2FsaG9zdDAgFw0xMjAxMDIxOTA4NThaGA8yMTExMTIwOTE5MDg1OFow\n"
-        + "FDESMBAGA1UEAxMJbG9jYWxob3N0MFwwDQYJKoZIhvcNAQEBBQADSwAwSAJBAPpt\n"
-        + "atK8r4/hf4hSIs0os/BSlQLbRBaK9AfBReM4QdAklcQqe6CHsStKfI8pp0zs7Ptg\n"
-        + "PmMdpbttL0O7mUboBC8CAwEAAaM1MDMwMQYDVR0RBCowKIIVbG9jYWxob3N0Lmxv\n"
-        + "Y2FsZG9tYWlugglsb2NhbGhvc3SHBH8AAAEwDQYJKoZIhvcNAQEFBQADQQD0ntfL\n"
-        + "DCzOCv9Ma6Lv5o5jcYWVxvBSTsnt22hsJpWD1K7iY9lbkLwl0ivn73pG2evsAn9G\n"
-        + "X8YKH52fnHsCrhSD\n"
-        + "-----END CERTIFICATE-----");
-    assertEquals(new X500Principal("CN=localhost"), certificate.getSubjectX500Principal());
-
-    FakeSSLSession session = new FakeSSLSession(certificate);
-    assertTrue(verifier.verify("localhost", session));
-    assertTrue(verifier.verify("localhost.localdomain", session));
-    assertFalse(verifier.verify("local.host", session));
-
-    assertTrue(verifier.verify("127.0.0.1", session));
-    assertFalse(verifier.verify("127.0.0.2", session));
-  }
-
-  @Test public void wildcardsCannotMatchIpAddresses() throws Exception {
-    // openssl req -x509 -nodes -days 36500 -subj '/CN=*.0.0.1' -newkey rsa:512 -out cert.pem
-    SSLSession session = session(""
-        + "-----BEGIN CERTIFICATE-----\n"
-        + "MIIBkjCCATygAwIBAgIJAMdemqOwd/BEMA0GCSqGSIb3DQEBBQUAMBIxEDAOBgNV\n"
-        + "BAMUByouMC4wLjEwIBcNMTAxMjIwMTY0NDI1WhgPMjExMDExMjYxNjQ0MjVaMBIx\n"
-        + "EDAOBgNVBAMUByouMC4wLjEwXDANBgkqhkiG9w0BAQEFAANLADBIAkEAqY8c9Qrt\n"
-        + "YPWCvb7lclI+aDHM6fgbJcHsS9Zg8nUOh5dWrS7AgeA25wyaokFl4plBbbHQe2j+\n"
-        + "cCjsRiJIcQo9HwIDAQABo3MwcTAdBgNVHQ4EFgQUJ436TZPJvwCBKklZZqIvt1Yt\n"
-        + "JjEwQgYDVR0jBDswOYAUJ436TZPJvwCBKklZZqIvt1YtJjGhFqQUMBIxEDAOBgNV\n"
-        + "BAMUByouMC4wLjGCCQDHXpqjsHfwRDAMBgNVHRMEBTADAQH/MA0GCSqGSIb3DQEB\n"
-        + "BQUAA0EAk9i88xdjWoewqvE+iMC9tD2obMchgFDaHH0ogxxiRaIKeEly3g0uGxIt\n"
-        + "fl2WRY8hb4x+zRrwsFaLEpdEvqcjOQ==\n"
-        + "-----END CERTIFICATE-----");
-    assertFalse(verifier.verify("127.0.0.1", session));
-  }
-
-  /**
-   * Earlier implementations of Android's hostname verifier required that
-   * wildcard names wouldn't match "*.com" or similar. This was a nonstandard
-   * check that we've since dropped. It is the CA's responsibility to not hand
-   * out certificates that match so broadly.
-   */
-  @Test public void wildcardsDoesNotNeedTwoDots() throws Exception {
-    // openssl req -x509 -nodes -days 36500 -subj '/CN=*.com' -newkey rsa:512 -out cert.pem
-    SSLSession session = session(""
-        + "-----BEGIN CERTIFICATE-----\n"
-        + "MIIBjDCCATagAwIBAgIJAOVulXCSu6HuMA0GCSqGSIb3DQEBBQUAMBAxDjAMBgNV\n"
-        + "BAMUBSouY29tMCAXDTEwMTIyMDE2NDkzOFoYDzIxMTAxMTI2MTY0OTM4WjAQMQ4w\n"
-        + "DAYDVQQDFAUqLmNvbTBcMA0GCSqGSIb3DQEBAQUAA0sAMEgCQQDJd8xqni+h7Iaz\n"
-        + "ypItivs9kPuiJUqVz+SuJ1C05SFc3PmlRCvwSIfhyD67fHcbMdl+A/LrIjhhKZJe\n"
-        + "1joO0+pFAgMBAAGjcTBvMB0GA1UdDgQWBBS4Iuzf5w8JdCp+EtBfdFNudf6+YzBA\n"
-        + "BgNVHSMEOTA3gBS4Iuzf5w8JdCp+EtBfdFNudf6+Y6EUpBIwEDEOMAwGA1UEAxQF\n"
-        + "Ki5jb22CCQDlbpVwkruh7jAMBgNVHRMEBTADAQH/MA0GCSqGSIb3DQEBBQUAA0EA\n"
-        + "U6LFxmZr31lFyis2/T68PpjAppc0DpNQuA2m/Y7oTHBDi55Fw6HVHCw3lucuWZ5d\n"
-        + "qUYo4ES548JdpQtcLrW2sA==\n"
-        + "-----END CERTIFICATE-----");
-    assertTrue(verifier.verify("google.com", session));
-  }
-
-  @Test public void subjectAltName() throws Exception {
-    // $ cat ./cert.cnf
-    // [req]
-    // distinguished_name=distinguished_name
-    // req_extensions=req_extensions
-    // x509_extensions=x509_extensions
-    // [distinguished_name]
-    // [req_extensions]
-    // [x509_extensions]
-    // subjectAltName=DNS:bar.com,DNS:baz.com
-    //
-    // $ openssl req -x509 -nodes -days 36500 -subj '/CN=foo.com' -config ./cert.cnf \
-    //     -newkey rsa:512 -out cert.pem
-    SSLSession session = session(""
-        + "-----BEGIN CERTIFICATE-----\n"
-        + "MIIBPTCB6KADAgECAgkA7zoHaaqNGHQwDQYJKoZIhvcNAQEFBQAwEjEQMA4GA1UE\n"
-        + "AxMHZm9vLmNvbTAgFw0xMDEyMjAxODM5MzZaGA8yMTEwMTEyNjE4MzkzNlowEjEQ\n"
-        + "MA4GA1UEAxMHZm9vLmNvbTBcMA0GCSqGSIb3DQEBAQUAA0sAMEgCQQC+gmoSxF+8\n"
-        + "hbV+rgRQqHIJd50216OWQJbU3BvdlPbca779NYO4+UZWTFdBM8BdQqs3H4B5Agvp\n"
-        + "y7HeSff1F7XRAgMBAAGjHzAdMBsGA1UdEQQUMBKCB2Jhci5jb22CB2Jhei5jb20w\n"
-        + "DQYJKoZIhvcNAQEFBQADQQBXpZZPOY2Dy1lGG81JTr8L4or9jpKacD7n51eS8iqI\n"
-        + "oTznPNuXHU5bFN0AAGX2ij47f/EahqTpo5RdS95P4sVm\n"
-        + "-----END CERTIFICATE-----");
-    assertFalse(verifier.verify("foo.com", session));
-    assertTrue(verifier.verify("bar.com", session));
-    assertTrue(verifier.verify("baz.com", session));
-    assertFalse(verifier.verify("a.foo.com", session));
-    assertFalse(verifier.verify("quux.com", session));
-  }
-
-  @Test public void subjectAltNameWithWildcard() throws Exception {
-    // $ cat ./cert.cnf
-    // [req]
-    // distinguished_name=distinguished_name
-    // req_extensions=req_extensions
-    // x509_extensions=x509_extensions
-    // [distinguished_name]
-    // [req_extensions]
-    // [x509_extensions]
-    // subjectAltName=DNS:bar.com,DNS:*.baz.com
-    //
-    // $ openssl req -x509 -nodes -days 36500 -subj '/CN=foo.com' -config ./cert.cnf \
-    //     -newkey rsa:512 -out cert.pem
-    SSLSession session = session(""
-        + "-----BEGIN CERTIFICATE-----\n"
-        + "MIIBPzCB6qADAgECAgkAnv/7Jv5r7pMwDQYJKoZIhvcNAQEFBQAwEjEQMA4GA1UE\n"
-        + "AxMHZm9vLmNvbTAgFw0xMDEyMjAxODQ2MDFaGA8yMTEwMTEyNjE4NDYwMVowEjEQ\n"
-        + "MA4GA1UEAxMHZm9vLmNvbTBcMA0GCSqGSIb3DQEBAQUAA0sAMEgCQQDAz2YXnyog\n"
-        + "YdYLSFr/OEgSumtwqtZKJTB4wqTW/eKbBCEzxnyUMxWZIqUGu353PzwfOuWp2re3\n"
-        + "nvVV+QDYQlh9AgMBAAGjITAfMB0GA1UdEQQWMBSCB2Jhci5jb22CCSouYmF6LmNv\n"
-        + "bTANBgkqhkiG9w0BAQUFAANBAB8yrSl8zqy07i0SNYx2B/FnvQY734pxioaqFWfO\n"
-        + "Bqo1ZZl/9aPHEWIwBrxYNVB0SGu/kkbt/vxqOjzzrkXukmI=\n"
-        + "-----END CERTIFICATE-----");
-    assertFalse(verifier.verify("foo.com", session));
-    assertTrue(verifier.verify("bar.com", session));
-    assertTrue(verifier.verify("a.baz.com", session));
-    assertTrue(verifier.verify("baz.com", session));
-    assertFalse(verifier.verify("a.foo.com", session));
-    assertFalse(verifier.verify("a.bar.com", session));
-    assertFalse(verifier.verify("quux.com", session));
-  }
-
-  @Test public void verifyAsIpAddress() {
-    // IPv4
-    assertTrue(OkHostnameVerifier.verifyAsIpAddress("127.0.0.1"));
-    assertTrue(OkHostnameVerifier.verifyAsIpAddress("1.2.3.4"));
-
-    // IPv6
-    assertTrue(OkHostnameVerifier.verifyAsIpAddress("::1"));
-    assertTrue(OkHostnameVerifier.verifyAsIpAddress("2001:db8::1"));
-    assertTrue(OkHostnameVerifier.verifyAsIpAddress("::192.168.0.1"));
-    assertTrue(OkHostnameVerifier.verifyAsIpAddress("::ffff:192.168.0.1"));
-    assertTrue(OkHostnameVerifier.verifyAsIpAddress("FEDC:BA98:7654:3210:FEDC:BA98:7654:3210"));
-    assertTrue(OkHostnameVerifier.verifyAsIpAddress("1080:0:0:0:8:800:200C:417A"));
-    assertTrue(OkHostnameVerifier.verifyAsIpAddress("1080::8:800:200C:417A"));
-    assertTrue(OkHostnameVerifier.verifyAsIpAddress("FF01::101"));
-    assertTrue(OkHostnameVerifier.verifyAsIpAddress("0:0:0:0:0:0:13.1.68.3"));
-    assertTrue(OkHostnameVerifier.verifyAsIpAddress("0:0:0:0:0:FFFF:129.144.52.38"));
-    assertTrue(OkHostnameVerifier.verifyAsIpAddress("::13.1.68.3"));
-    assertTrue(OkHostnameVerifier.verifyAsIpAddress("::FFFF:129.144.52.38"));
-
-    // Hostnames
-    assertFalse(OkHostnameVerifier.verifyAsIpAddress("go"));
-    assertFalse(OkHostnameVerifier.verifyAsIpAddress("localhost"));
-    assertFalse(OkHostnameVerifier.verifyAsIpAddress("squareup.com"));
-    assertFalse(OkHostnameVerifier.verifyAsIpAddress("www.nintendo.co.jp"));
-  }
-
-  private X509Certificate certificate(String certificate) throws Exception {
-    return (X509Certificate) CertificateFactory.getInstance("X.509").generateCertificate(
-        new ByteArrayInputStream(certificate.getBytes(Util.UTF_8)));
-  }
-
-  private SSLSession session(String certificate) throws Exception {
-    return new FakeSSLSession(certificate(certificate));
-  }
-}
diff --git a/pom.xml b/pom.xml
index 3fd8405b01..8551faf574 100644
--- a/pom.xml
+++ b/pom.xml
@@ -22,7 +22,6 @@
     <module>okhttp</module>
     <module>okhttp-apache</module>
     <module>okhttp-protocols</module>
-    <module>mockwebserver</module>
     <module>samples</module>
   </modules>
 
