diff --git a/okhttp/src/main/java/okhttp3/Dispatcher.java b/okhttp/src/main/java/okhttp3/Dispatcher.java
index 43f5aa48e7..4feb696a91 100644
--- a/okhttp/src/main/java/okhttp3/Dispatcher.java
+++ b/okhttp/src/main/java/okhttp3/Dispatcher.java
@@ -48,9 +48,11 @@
   private final Deque<AsyncCall> readyAsyncCalls = new ArrayDeque<>();
 
   /** Running asynchronous calls. Includes canceled calls that haven't finished yet. */
+  //异步任务的双端队列
   private final Deque<AsyncCall> runningAsyncCalls = new ArrayDeque<>();
 
   /** Running synchronous calls. Includes canceled calls that haven't finished yet. */
+  //同步任务的双端队列
   private final Deque<RealCall> runningSyncCalls = new ArrayDeque<>();
 
   public Dispatcher(ExecutorService executorService) {
diff --git a/okhttp/src/main/java/okhttp3/EventListener.java b/okhttp/src/main/java/okhttp3/EventListener.java
index 1feebd3ad0..7829909607 100644
--- a/okhttp/src/main/java/okhttp3/EventListener.java
+++ b/okhttp/src/main/java/okhttp3/EventListener.java
@@ -15,6 +15,8 @@
  */
 package okhttp3;
 
+import android.util.Log;
+
 import java.io.IOException;
 import java.net.InetAddress;
 import java.net.InetSocketAddress;
@@ -56,6 +58,7 @@
  * Any IO - writing to files or network should be done asynchronously.
  */
 public abstract class EventListener {
+  private static final String TAG = "EventListener";
   public static final EventListener NONE = new EventListener() {
   };
 
@@ -76,6 +79,7 @@ public EventListener create(Call call) {
    * #callEnd}/{@link #callFailed} pair.
    */
   public void callStart(Call call) {
+      Log.i(TAG, "callStart: ");
   }
 
   /**
@@ -88,6 +92,7 @@ public void callStart(Call call) {
    * invoked. See {@link ConnectionPool}.
    */
   public void dnsStart(Call call, String domainName) {
+      Log.i(TAG, "dnsStart: ");
   }
 
   /**
@@ -281,6 +286,7 @@ public void callEnd(Call call) {
    * <p>This method is always invoked after {@link #callStart(Call)}.
    */
   public void callFailed(Call call, IOException ioe) {
+      Log.i(TAG, "callFailed: ");
   }
 
   /**
diff --git a/okhttp/src/main/java/okhttp3/RealCall.java b/okhttp/src/main/java/okhttp3/RealCall.java
index 808b3dc7ba..0553219705 100644
--- a/okhttp/src/main/java/okhttp3/RealCall.java
+++ b/okhttp/src/main/java/okhttp3/RealCall.java
@@ -73,6 +73,7 @@ static RealCall newRealCall(OkHttpClient client, Request originalRequest, boolea
     captureCallStackTrace();
     eventListener.callStart(this);
     try {
+      //把这次请求加入到分发器里
       client.dispatcher().executed(this);
       Response result = getResponseWithInterceptorChain();
       if (result == null) throw new IOException("Canceled");
@@ -92,7 +93,10 @@ private void captureCallStackTrace() {
 
   @Override public void enqueue(Callback responseCallback) {
     synchronized (this) {
-      if (executed) throw new IllegalStateException("Already Executed");
+      //如果已经执行过就不在执行
+      if (executed) {
+        throw new IllegalStateException("Already Executed");
+      }
       executed = true;
     }
     captureCallStackTrace();
@@ -141,14 +145,20 @@ RealCall get() {
       return RealCall.this;
     }
 
+    /**
+     * 真正执行网络请求的方法
+     */
     @Override protected void execute() {
       boolean signalledCallback = false;
       try {
         Response response = getResponseWithInterceptorChain();
+
         if (retryAndFollowUpInterceptor.isCanceled()) {
+          //取消call调用onFailure回调
           signalledCallback = true;
           responseCallback.onFailure(RealCall.this, new IOException("Canceled"));
         } else {
+          //请求成功，回调onResponse
           signalledCallback = true;
           responseCallback.onResponse(RealCall.this, response);
         }
