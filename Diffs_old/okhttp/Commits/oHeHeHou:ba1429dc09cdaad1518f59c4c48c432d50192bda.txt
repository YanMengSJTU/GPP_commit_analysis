diff --git a/okhttp/src/main/java/okhttp3/RealCall.java b/okhttp/src/main/java/okhttp3/RealCall.java
index a9ba5be366..417f23b4a3 100644
--- a/okhttp/src/main/java/okhttp3/RealCall.java
+++ b/okhttp/src/main/java/okhttp3/RealCall.java
@@ -192,7 +192,7 @@ void executeOn(ExecutorService executorService) {
         }
       }
     }
-
+    //核心方法，在Runnable的run()中调用
     @Override protected void execute() {
       boolean signalledCallback = false;
       timeout.enter();
@@ -247,9 +247,10 @@ Response getResponseWithInterceptorChain() throws IOException {
     }
     interceptors.add(new CallServerInterceptor(forWebSocket));
 
+    //初始化基础拦截器RealInterceptorChain，这个拦截器的proceed执行完之后才会依次执行interceptors中的拦截器
     Interceptor.Chain chain = new RealInterceptorChain(interceptors, null, null, null, 0,
-        originalRequest, this, eventListener, client.connectTimeoutMillis(),
-        client.readTimeoutMillis(), client.writeTimeoutMillis());
+            originalRequest, this, eventListener, client.connectTimeoutMillis(),
+            client.readTimeoutMillis(), client.writeTimeoutMillis());
 
     return chain.proceed(originalRequest);
   }
diff --git a/okhttp/src/main/java/okhttp3/internal/http/RealInterceptorChain.java b/okhttp/src/main/java/okhttp3/internal/http/RealInterceptorChain.java
index c2dcf16986..b7265425d4 100644
--- a/okhttp/src/main/java/okhttp3/internal/http/RealInterceptorChain.java
+++ b/okhttp/src/main/java/okhttp3/internal/http/RealInterceptorChain.java
@@ -48,6 +48,7 @@
   private final int writeTimeout;
   private int calls;
 
+  //首先在RealCall的execute()中被初始化
   public RealInterceptorChain(List<Interceptor> interceptors, StreamAllocation streamAllocation,
       HttpCodec httpCodec, RealConnection connection, int index, Request request, Call call,
       EventListener eventListener, int connectTimeout, int readTimeout, int writeTimeout) {
@@ -122,8 +123,10 @@ public EventListener eventListener() {
     return proceed(request, streamAllocation, httpCodec, connection);
   }
 
+  //拦截器链中默认处理请求的部分
   public Response proceed(Request request, StreamAllocation streamAllocation, HttpCodec httpCodec,
       RealConnection connection) throws IOException {
+    //执行到最后一个拦截器之后退出,在Call的execute()中的try finally中执行client.dispatcher().finished(this);完成一次请求过程
     if (index >= interceptors.size()) throw new AssertionError();
 
     calls++;
@@ -135,16 +138,19 @@ public Response proceed(Request request, StreamAllocation streamAllocation, Http
     }
 
     // If we already have a stream, confirm that this is the only call to chain.proceed().
+    //确保proceed只能被调用一次
     if (this.httpCodec != null && calls > 1) {
       throw new IllegalStateException("network interceptor " + interceptors.get(index - 1)
           + " must call proceed() exactly once");
     }
 
     // Call the next interceptor in the chain.
+    // index初始值为0
     RealInterceptorChain next = new RealInterceptorChain(interceptors, streamAllocation, httpCodec,
         connection, index + 1, request, call, eventListener, connectTimeout, readTimeout,
         writeTimeout);
     Interceptor interceptor = interceptors.get(index);
+    //在下一个拦截器中重写的intercept中,选择抛出异常中断拦截器链,或者调用chain.proceed继续下一个拦截器
     Response response = interceptor.intercept(next);
 
     // Confirm that the next interceptor made its required call to chain.proceed().
