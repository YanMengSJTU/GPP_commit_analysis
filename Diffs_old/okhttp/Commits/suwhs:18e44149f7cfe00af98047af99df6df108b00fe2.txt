diff --git a/CONTRIBUTING.md b/.github/CONTRIBUTING.md
similarity index 100%
rename from CONTRIBUTING.md
rename to .github/CONTRIBUTING.md
diff --git a/.github/ISSUE_TEMPLATE.md b/.github/ISSUE_TEMPLATE.md
new file mode 100644
index 0000000000..e65d371715
--- /dev/null
+++ b/.github/ISSUE_TEMPLATE.md
@@ -0,0 +1,12 @@
+What kind of issue is this?
+
+ - [ ] Question. This issue tracker is not the place for questions. If you want to ask how to do
+       something, or to understand why something isn't working the way you expect it to, use Stack
+       Overflow. https://stackoverflow.com/questions/tagged/okhttp
+
+ - [ ] Bug report. If you’ve found a bug, spend the time to write a failing test. Bugs with tests
+       get fixed. Here’s an example: https://gist.github.com/swankjesse/981fcae102f513eb13ed
+
+ - [ ] Feature Request. Start by telling us what problem you’re trying to solve. Often a solution
+       already exists! Don’t send pull requests to implement new features without first getting our
+       support. Sometimes we leave features out on purpose to keep the project small.
diff --git a/CHANGELOG.md b/CHANGELOG.md
index b7d52c8f37..960d7d2f60 100644
--- a/CHANGELOG.md
+++ b/CHANGELOG.md
@@ -1,6 +1,19 @@
 Change Log
 ==========
 
+## Version 3.2.0
+
+_2016-02-25_
+
+ *  Fix: Change the certificate pinner to always build full chains. This
+    prevents a potential crash when using certificate pinning with the Google
+    Play Services security provider.
+ *  Fix: Make IPv6 request lines consistent with Firefox and Chrome.
+ *  Fix: Recover gracefully when trimming the response cache fails.
+ *  New: Add multiple path segments using a single string in `HttpUrl.Builder`.
+ *  New: Support SHA-256 pins in certificate pinner.
+
+
 ## Version 3.1.2
 
 _2016-02-10_
@@ -174,6 +187,15 @@ stuck on the old version.
  *  New: Make `HttpUrl` the blessed URL method of `Request`.
 
 
+## Version 2.7.5
+
+_2016-02-25_
+
+ *  Fix: Change the certificate pinner to always build full chains. This
+    prevents a potential crash when using certificate pinning with the Google
+    Play Services security provider.
+
+
 ## Version 2.7.4
 
 _2016-02-07_
diff --git a/README.md b/README.md
index 09a3831f82..b6b059deb4 100644
--- a/README.md
+++ b/README.md
@@ -11,12 +11,12 @@ Download [the latest JAR][3] or grab via Maven:
 <dependency>
   <groupId>com.squareup.okhttp3</groupId>
   <artifactId>okhttp</artifactId>
-  <version>3.1.2</version>
+  <version>3.2.0</version>
 </dependency>
 ```
 or Gradle:
 ```groovy
-compile 'com.squareup.okhttp3:okhttp:3.1.2'
+compile 'com.squareup.okhttp3:okhttp:3.2.0'
 ```
 
 Snapshots of the development version are available in [Sonatype's `snapshots` repository][snap].
@@ -36,13 +36,13 @@ Download [the latest JAR][4] or grab via Maven:
 <dependency>
   <groupId>com.squareup.okhttp3</groupId>
   <artifactId>mockwebserver</artifactId>
-  <version>3.1.2</version>
+  <version>3.2.0</version>
   <scope>test</scope>
 </dependency>
 ```
 or Gradle:
 ```groovy
-testCompile 'com.squareup.okhttp3:mockwebserver:3.1.2'
+testCompile 'com.squareup.okhttp3:mockwebserver:3.2.0'
 ```
 
 
diff --git a/benchmarks/pom.xml b/benchmarks/pom.xml
index cf29f7bcf4..2dab72f0ef 100644
--- a/benchmarks/pom.xml
+++ b/benchmarks/pom.xml
@@ -6,7 +6,7 @@
   <parent>
     <groupId>com.squareup.okhttp3</groupId>
     <artifactId>parent</artifactId>
-    <version>3.2.0-SNAPSHOT</version>
+    <version>3.3.0-SNAPSHOT</version>
   </parent>
 
   <artifactId>benchmarks</artifactId>
diff --git a/mockwebserver/pom.xml b/mockwebserver/pom.xml
index 379b323805..0d858e5524 100644
--- a/mockwebserver/pom.xml
+++ b/mockwebserver/pom.xml
@@ -6,7 +6,7 @@
   <parent>
     <groupId>com.squareup.okhttp3</groupId>
     <artifactId>parent</artifactId>
-    <version>3.2.0-SNAPSHOT</version>
+    <version>3.3.0-SNAPSHOT</version>
   </parent>
 
   <artifactId>mockwebserver</artifactId>
diff --git a/okcurl/pom.xml b/okcurl/pom.xml
index 0b6f0d6c05..63b1cc8c8b 100644
--- a/okcurl/pom.xml
+++ b/okcurl/pom.xml
@@ -6,7 +6,7 @@
   <parent>
     <groupId>com.squareup.okhttp3</groupId>
     <artifactId>parent</artifactId>
-    <version>3.2.0-SNAPSHOT</version>
+    <version>3.3.0-SNAPSHOT</version>
   </parent>
 
   <artifactId>okcurl</artifactId>
diff --git a/okcurl/src/main/java/okhttp3/curl/Main.java b/okcurl/src/main/java/okhttp3/curl/Main.java
index 21a9d0f75e..4268ec04ef 100644
--- a/okcurl/src/main/java/okhttp3/curl/Main.java
+++ b/okcurl/src/main/java/okhttp3/curl/Main.java
@@ -16,11 +16,11 @@
 package okhttp3.curl;
 
 import com.google.common.base.Joiner;
-import io.airlift.command.Arguments;
-import io.airlift.command.Command;
-import io.airlift.command.HelpOption;
-import io.airlift.command.Option;
-import io.airlift.command.SingleCommand;
+import io.airlift.airline.Arguments;
+import io.airlift.airline.Command;
+import io.airlift.airline.HelpOption;
+import io.airlift.airline.Option;
+import io.airlift.airline.SingleCommand;
 import java.io.IOException;
 import java.io.InputStream;
 import java.security.cert.CertificateException;
diff --git a/okhttp-android-support/pom.xml b/okhttp-android-support/pom.xml
index 066fb72649..9f6f647bc6 100644
--- a/okhttp-android-support/pom.xml
+++ b/okhttp-android-support/pom.xml
@@ -6,7 +6,7 @@
   <parent>
     <groupId>com.squareup.okhttp3</groupId>
     <artifactId>parent</artifactId>
-    <version>3.2.0-SNAPSHOT</version>
+    <version>3.3.0-SNAPSHOT</version>
   </parent>
 
   <artifactId>okhttp-android-support</artifactId>
diff --git a/okhttp-apache/pom.xml b/okhttp-apache/pom.xml
index 6235935f98..68fcf1add9 100644
--- a/okhttp-apache/pom.xml
+++ b/okhttp-apache/pom.xml
@@ -6,7 +6,7 @@
   <parent>
     <groupId>com.squareup.okhttp3</groupId>
     <artifactId>parent</artifactId>
-    <version>3.2.0-SNAPSHOT</version>
+    <version>3.3.0-SNAPSHOT</version>
   </parent>
 
   <artifactId>okhttp-apache</artifactId>
diff --git a/okhttp-logging-interceptor/pom.xml b/okhttp-logging-interceptor/pom.xml
index 17e074e735..a837c6c898 100644
--- a/okhttp-logging-interceptor/pom.xml
+++ b/okhttp-logging-interceptor/pom.xml
@@ -6,7 +6,7 @@
   <parent>
     <groupId>com.squareup.okhttp3</groupId>
     <artifactId>parent</artifactId>
-    <version>3.2.0-SNAPSHOT</version>
+    <version>3.3.0-SNAPSHOT</version>
   </parent>
 
   <artifactId>logging-interceptor</artifactId>
diff --git a/okhttp-logging-interceptor/src/main/java/okhttp3/logging/HttpLoggingInterceptor.java b/okhttp-logging-interceptor/src/main/java/okhttp3/logging/HttpLoggingInterceptor.java
index 5e738b341a..532b80ce4a 100644
--- a/okhttp-logging-interceptor/src/main/java/okhttp3/logging/HttpLoggingInterceptor.java
+++ b/okhttp-logging-interceptor/src/main/java/okhttp3/logging/HttpLoggingInterceptor.java
@@ -15,6 +15,7 @@
  */
 package okhttp3.logging;
 
+import java.io.EOFException;
 import java.io.IOException;
 import java.nio.charset.Charset;
 import java.nio.charset.UnsupportedCharsetException;
@@ -192,10 +193,14 @@ public Level getLevel() {
         }
 
         logger.log("");
-        logger.log(buffer.readString(charset));
-
-        logger.log("--> END " + request.method()
-            + " (" + requestBody.contentLength() + "-byte body)");
+        if (isPlaintext(buffer)) {
+          logger.log(buffer.readString(charset));
+          logger.log("--> END " + request.method()
+              + " (" + requestBody.contentLength() + "-byte body)");
+        } else {
+          logger.log("--> END " + request.method() + " (binary "
+              + requestBody.contentLength() + "-byte body omitted)");
+        }
       }
     }
 
@@ -239,6 +244,12 @@ public Level getLevel() {
           }
         }
 
+        if (!isPlaintext(buffer)) {
+          logger.log("");
+          logger.log("<-- END HTTP (binary " + buffer.size() + "-byte body omitted)");
+          return response;
+        }
+
         if (contentLength != 0) {
           logger.log("");
           logger.log(buffer.clone().readString(charset));
@@ -251,6 +262,29 @@ public Level getLevel() {
     return response;
   }
 
+  /**
+   * Returns true if the body in question probably contains human readable text. Uses a small sample
+   * of code points to detect unicode control characters commonly used in binary file signatures.
+   */
+  static boolean isPlaintext(Buffer buffer) throws EOFException {
+    try {
+      Buffer prefix = new Buffer();
+      long byteCount = buffer.size() < 64 ? buffer.size() : 64;
+      buffer.copyTo(prefix, 0, byteCount);
+      for (int i = 0; i < 16; i++) {
+        if (prefix.exhausted()) {
+          break;
+        }
+        if (Character.isISOControl(prefix.readUtf8CodePoint())) {
+          return false;
+        }
+      }
+      return true;
+    } catch (EOFException e) {
+      return false; // Truncated UTF-8 sequence.
+    }
+  }
+
   private boolean bodyEncoded(Headers headers) {
     String contentEncoding = headers.get("Content-Encoding");
     return contentEncoding != null && !contentEncoding.equalsIgnoreCase("identity");
diff --git a/okhttp-logging-interceptor/src/test/java/okhttp3/logging/HttpLoggingInterceptorTest.java b/okhttp-logging-interceptor/src/test/java/okhttp3/logging/HttpLoggingInterceptorTest.java
index 88630b500c..3159ad2f75 100644
--- a/okhttp-logging-interceptor/src/test/java/okhttp3/logging/HttpLoggingInterceptorTest.java
+++ b/okhttp-logging-interceptor/src/test/java/okhttp3/logging/HttpLoggingInterceptorTest.java
@@ -37,6 +37,7 @@
 import org.junit.Test;
 
 import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
 import static org.junit.Assert.assertSame;
 import static org.junit.Assert.assertTrue;
 import static org.junit.Assert.fail;
@@ -638,6 +639,60 @@ private void bodyGetNoBody(int code) throws IOException {
         .assertNoMoreLogs();
   }
 
+  @Test public void isPlaintext() throws IOException {
+    assertTrue(HttpLoggingInterceptor.isPlaintext(new Buffer()));
+    assertTrue(HttpLoggingInterceptor.isPlaintext(new Buffer().writeUtf8("abc")));
+    assertTrue(HttpLoggingInterceptor.isPlaintext(new Buffer().writeByte(0x80)));
+    assertFalse(HttpLoggingInterceptor.isPlaintext(new Buffer().writeByte(0x00)));
+    assertFalse(HttpLoggingInterceptor.isPlaintext(new Buffer().writeByte(0xc0)));
+  }
+
+  @Test public void responseBodyIsBinary() throws IOException {
+    setLevel(Level.BODY);
+    Buffer buffer = new Buffer();
+    buffer.writeUtf8CodePoint(0x89);
+    buffer.writeUtf8CodePoint(0x50);
+    buffer.writeUtf8CodePoint(0x4e);
+    buffer.writeUtf8CodePoint(0x47);
+    buffer.writeUtf8CodePoint(0x0d);
+    buffer.writeUtf8CodePoint(0x0a);
+    buffer.writeUtf8CodePoint(0x1a);
+    buffer.writeUtf8CodePoint(0x0a);
+    server.enqueue(new MockResponse()
+        .setBody(buffer)
+        .setHeader("Content-Type", "image/png; charset=utf-8"));
+    Response response = client.newCall(request().build()).execute();
+    response.body().close();
+
+    applicationLogs
+        .assertLogEqual("--> GET " + url + " http/1.1")
+        .assertLogEqual("--> END GET")
+        .assertLogMatch("<-- 200 OK " + url + " \\(\\d+ms\\)")
+        .assertLogEqual("Content-Length: 9")
+        .assertLogEqual("Content-Type: image/png; charset=utf-8")
+        .assertLogMatch("OkHttp-Sent-Millis: \\d+")
+        .assertLogMatch("OkHttp-Received-Millis: \\d+")
+        .assertLogEqual("")
+        .assertLogEqual("<-- END HTTP (binary 9-byte body omitted)")
+        .assertNoMoreLogs();
+
+    networkLogs
+        .assertLogEqual("--> GET " + url + " http/1.1")
+        .assertLogEqual("Host: " + host)
+        .assertLogEqual("Connection: Keep-Alive")
+        .assertLogEqual("Accept-Encoding: gzip")
+        .assertLogMatch("User-Agent: okhttp/.+")
+        .assertLogEqual("--> END GET")
+        .assertLogMatch("<-- 200 OK " + url + " \\(\\d+ms\\)")
+        .assertLogEqual("Content-Length: 9")
+        .assertLogEqual("Content-Type: image/png; charset=utf-8")
+        .assertLogMatch("OkHttp-Sent-Millis: \\d+")
+        .assertLogMatch("OkHttp-Received-Millis: \\d+")
+        .assertLogEqual("")
+        .assertLogEqual("<-- END HTTP (binary 9-byte body omitted)")
+        .assertNoMoreLogs();
+  }
+
   private Request.Builder request() {
     return new Request.Builder().url(url);
   }
diff --git a/okhttp-testing-support/pom.xml b/okhttp-testing-support/pom.xml
index c1e13b7498..7b6ad7cd7e 100644
--- a/okhttp-testing-support/pom.xml
+++ b/okhttp-testing-support/pom.xml
@@ -6,7 +6,7 @@
   <parent>
     <groupId>com.squareup.okhttp3</groupId>
     <artifactId>parent</artifactId>
-    <version>3.2.0-SNAPSHOT</version>
+    <version>3.3.0-SNAPSHOT</version>
   </parent>
 
   <artifactId>okhttp-testing-support</artifactId>
diff --git a/okhttp-testing-support/src/main/java/okhttp3/internal/io/InMemoryFileSystem.java b/okhttp-testing-support/src/main/java/okhttp3/internal/io/InMemoryFileSystem.java
index b4299fd09b..bb6f519092 100644
--- a/okhttp-testing-support/src/main/java/okhttp3/internal/io/InMemoryFileSystem.java
+++ b/okhttp-testing-support/src/main/java/okhttp3/internal/io/InMemoryFileSystem.java
@@ -113,7 +113,7 @@ private Sink sink(File file, boolean appending) {
     files.remove(file);
   }
 
-  @Override public boolean exists(File file) throws IOException {
+  @Override public boolean exists(File file) {
     return files.containsKey(file);
   }
 
diff --git a/okhttp-tests/pom.xml b/okhttp-tests/pom.xml
index 20f51832bc..d9f8596922 100644
--- a/okhttp-tests/pom.xml
+++ b/okhttp-tests/pom.xml
@@ -6,7 +6,7 @@
   <parent>
     <groupId>com.squareup.okhttp3</groupId>
     <artifactId>parent</artifactId>
-    <version>3.2.0-SNAPSHOT</version>
+    <version>3.3.0-SNAPSHOT</version>
   </parent>
 
   <artifactId>okhttp-tests</artifactId>
diff --git a/okhttp-tests/src/test/java/okhttp3/CallTest.java b/okhttp-tests/src/test/java/okhttp3/CallTest.java
index 08af3bc11a..3cb960f4bf 100644
--- a/okhttp-tests/src/test/java/okhttp3/CallTest.java
+++ b/okhttp-tests/src/test/java/okhttp3/CallTest.java
@@ -31,6 +31,7 @@
 import java.security.cert.Certificate;
 import java.util.ArrayList;
 import java.util.Arrays;
+import java.util.Collections;
 import java.util.List;
 import java.util.concurrent.BlockingQueue;
 import java.util.concurrent.Callable;
@@ -2149,7 +2150,7 @@ private InetSocketAddress startNullServer() throws IOException {
     assertNull(connect.getHeader("Private"));
     assertEquals(Version.userAgent(), connect.getHeader("User-Agent"));
     assertEquals("Keep-Alive", connect.getHeader("Proxy-Connection"));
-    assertEquals("android.com", connect.getHeader("Host"));
+    assertEquals("android.com:443", connect.getHeader("Host"));
 
     RecordedRequest get = server.takeRequest();
     assertEquals("Secret", get.getHeader("Private"));
@@ -2355,6 +2356,38 @@ private void upload(
         .build());
   }
 
+  /** https://github.com/square/okhttp/issues/2344 */
+  @Test public void ipv6HostHasSquareBraces() throws Exception {
+    // Use a proxy to fake IPv6 connectivity, even if localhost doesn't have IPv6.
+    server.useHttps(sslContext.getSocketFactory(), true);
+    server.setProtocols(Collections.singletonList(Protocol.HTTP_1_1));
+    server.enqueue(new MockResponse()
+        .setSocketPolicy(SocketPolicy.UPGRADE_TO_SSL_AT_END)
+        .clearHeaders());
+    server.enqueue(new MockResponse()
+        .setBody("response body"));
+
+    client = client.newBuilder()
+        .sslSocketFactory(sslContext.getSocketFactory())
+        .hostnameVerifier(new RecordingHostnameVerifier())
+        .proxy(server.toProxyAddress())
+        .build();
+
+    Request request = new Request.Builder()
+        .url("https://[::1]/")
+        .build();
+    Response response = client.newCall(request).execute();
+    assertEquals("response body", response.body().string());
+
+    RecordedRequest connect = server.takeRequest();
+    assertEquals("CONNECT [::1]:443 HTTP/1.1", connect.getRequestLine());
+    assertEquals("[::1]:443", connect.getHeader("Host"));
+
+    RecordedRequest get = server.takeRequest();
+    assertEquals("GET / HTTP/1.1", get.getRequestLine());
+    assertEquals("[::1]", get.getHeader("Host"));
+  }
+
   private RequestBody requestBody(final boolean chunked, final long size, final int writeSize) {
     final byte[] buffer = new byte[writeSize];
     Arrays.fill(buffer, (byte) 'x');
diff --git a/okhttp-tests/src/test/java/okhttp3/CertificateChainCleanerTest.java b/okhttp-tests/src/test/java/okhttp3/CertificateChainCleanerTest.java
index 6959f86b31..647ee1a327 100644
--- a/okhttp-tests/src/test/java/okhttp3/CertificateChainCleanerTest.java
+++ b/okhttp-tests/src/test/java/okhttp3/CertificateChainCleanerTest.java
@@ -15,7 +15,9 @@
  */
 package okhttp3;
 
+import java.security.GeneralSecurityException;
 import java.security.cert.Certificate;
+import java.security.cert.X509Certificate;
 import java.util.ArrayList;
 import java.util.List;
 import javax.net.ssl.SSLPeerUnverifiedException;
@@ -152,17 +154,17 @@
         council.clean(list(certB, certUnnecessary, certA, root)));
   }
 
-  @Test public void unnecessaryTrustedCertificatesAreOmitted() throws Exception {
-    HeldCertificate superRoot = new HeldCertificate.Builder()
+  @Test public void chainGoesAllTheWayToSelfSignedRoot() throws Exception {
+    HeldCertificate selfSigned = new HeldCertificate.Builder()
         .serialNumber("1")
         .build();
-    HeldCertificate root = new HeldCertificate.Builder()
+    HeldCertificate trusted = new HeldCertificate.Builder()
         .serialNumber("2")
-        .issuedBy(superRoot)
+        .issuedBy(selfSigned)
         .build();
     HeldCertificate certA = new HeldCertificate.Builder()
         .serialNumber("3")
-        .issuedBy(root)
+        .issuedBy(trusted)
         .build();
     HeldCertificate certB = new HeldCertificate.Builder()
         .serialNumber("4")
@@ -170,8 +172,79 @@
         .build();
 
     CertificateChainCleaner council = new CertificateChainCleaner(
-        new RealTrustRootIndex(superRoot.certificate, root.certificate));
-    assertEquals(list(certB, certA, root), council.clean(list(certB, certA, root, superRoot)));
+        new RealTrustRootIndex(selfSigned.certificate, trusted.certificate));
+    assertEquals(list(certB, certA, trusted, selfSigned),
+        council.clean(list(certB, certA)));
+    assertEquals(list(certB, certA, trusted, selfSigned),
+        council.clean(list(certB, certA, trusted)));
+    assertEquals(list(certB, certA, trusted, selfSigned),
+        council.clean(list(certB, certA, trusted, selfSigned)));
+  }
+
+  @Test public void trustedRootNotSelfSigned() throws Exception {
+    HeldCertificate unknownSigner = new HeldCertificate.Builder()
+        .serialNumber("1")
+        .build();
+    HeldCertificate trusted = new HeldCertificate.Builder()
+        .issuedBy(unknownSigner)
+        .serialNumber("2")
+        .build();
+    HeldCertificate intermediateCa = new HeldCertificate.Builder()
+        .issuedBy(trusted)
+        .serialNumber("3")
+        .build();
+    HeldCertificate certificate = new HeldCertificate.Builder()
+        .issuedBy(intermediateCa)
+        .serialNumber("4")
+        .build();
+
+    CertificateChainCleaner council = new CertificateChainCleaner(
+        new RealTrustRootIndex(trusted.certificate));
+    assertEquals(list(certificate, intermediateCa, trusted),
+        council.clean(list(certificate, intermediateCa)));
+    assertEquals(list(certificate, intermediateCa, trusted),
+        council.clean(list(certificate, intermediateCa, trusted)));
+  }
+
+  @Test public void chainMaxLength() throws Exception {
+    List<HeldCertificate> heldCertificates = chainOfLength(10);
+    List<Certificate> certificates = new ArrayList<>();
+    for (HeldCertificate heldCertificate : heldCertificates) {
+      certificates.add(heldCertificate.certificate);
+    }
+
+    X509Certificate root = heldCertificates.get(heldCertificates.size() - 1).certificate;
+    CertificateChainCleaner council = new CertificateChainCleaner(new RealTrustRootIndex(root));
+    assertEquals(certificates, council.clean(certificates));
+    assertEquals(certificates, council.clean(certificates.subList(0, 9)));
+  }
+
+  @Test public void chainTooLong() throws Exception {
+    List<HeldCertificate> heldCertificates = chainOfLength(11);
+    List<Certificate> certificates = new ArrayList<>();
+    for (HeldCertificate heldCertificate : heldCertificates) {
+      certificates.add(heldCertificate.certificate);
+    }
+
+    X509Certificate root = heldCertificates.get(heldCertificates.size() - 1).certificate;
+    CertificateChainCleaner council = new CertificateChainCleaner(new RealTrustRootIndex(root));
+    try {
+      council.clean(certificates);
+      fail();
+    } catch (SSLPeerUnverifiedException expected) {
+    }
+  }
+
+  /** Returns a chain starting at the leaf certificate and progressing to the root. */
+  private List<HeldCertificate> chainOfLength(int length) throws GeneralSecurityException {
+    List<HeldCertificate> result = new ArrayList<>();
+    for (int i = 1; i <= length; i++) {
+      result.add(0, new HeldCertificate.Builder()
+          .issuedBy(!result.isEmpty() ? result.get(0) : null)
+          .serialNumber(Integer.toString(i))
+          .build());
+    }
+    return result;
   }
 
   private List<Certificate> list(HeldCertificate... heldCertificates) {
diff --git a/okhttp-tests/src/test/java/okhttp3/CertificatePinnerTest.java b/okhttp-tests/src/test/java/okhttp3/CertificatePinnerTest.java
index b088f8c141..9442ddaf71 100644
--- a/okhttp-tests/src/test/java/okhttp3/CertificatePinnerTest.java
+++ b/okhttp-tests/src/test/java/okhttp3/CertificatePinnerTest.java
@@ -16,58 +16,50 @@
 package okhttp3;
 
 import java.security.GeneralSecurityException;
-import java.util.Set;
+import java.util.Arrays;
+import java.util.Collections;
+import java.util.List;
 import javax.net.ssl.SSLPeerUnverifiedException;
+import okhttp3.CertificatePinner.Pin;
 import okhttp3.internal.HeldCertificate;
-import okio.ByteString;
 import org.junit.Test;
 
-import static okhttp3.TestUtil.setOf;
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertFalse;
-import static org.junit.Assert.assertNull;
 import static org.junit.Assert.assertTrue;
 import static org.junit.Assert.fail;
 
 public final class CertificatePinnerTest {
   static HeldCertificate certA1;
-  static String certA1Pin;
-  static ByteString certA1PinBase64;
+  static String certA1Sha256Pin;
 
   static HeldCertificate certB1;
-  static String certB1Pin;
-  static ByteString certB1PinBase64;
+  static String certB1Sha256Pin;
 
   static HeldCertificate certC1;
-  static String certC1Pin;
+  static String certC1Sha256Pin;
 
   static {
     try {
       certA1 = new HeldCertificate.Builder()
           .serialNumber("100")
           .build();
-      certA1Pin = CertificatePinner.pin(certA1.certificate);
-      certA1PinBase64 = pinToBase64(certA1Pin);
+      certA1Sha256Pin = "sha256/" + CertificatePinner.sha256(certA1.certificate).base64();
 
       certB1 = new HeldCertificate.Builder()
           .serialNumber("200")
           .build();
-      certB1Pin = CertificatePinner.pin(certB1.certificate);
-      certB1PinBase64 = pinToBase64(certB1Pin);
+      certB1Sha256Pin = "sha256/" + CertificatePinner.sha256(certB1.certificate).base64();
 
       certC1 = new HeldCertificate.Builder()
           .serialNumber("300")
           .build();
-      certC1Pin = CertificatePinner.pin(certC1.certificate);
+      certC1Sha256Pin = "sha256/" + CertificatePinner.sha256(certC1.certificate).base64();
     } catch (GeneralSecurityException e) {
       throw new AssertionError(e);
     }
   }
 
-  static ByteString pinToBase64(String pin) {
-    return ByteString.decodeBase64(pin.substring("sha1/".length()));
-  }
-
   @Test public void malformedPin() throws Exception {
     CertificatePinner.Builder builder = new CertificatePinner.Builder();
     try {
@@ -100,14 +92,22 @@ static ByteString pinToBase64(String pin) {
         .build();
     String keypairBCertificate2Pin = CertificatePinner.pin(heldCertificateB2.certificate);
 
-    assertTrue(certA1Pin.equals(keypairACertificate2Pin));
-    assertTrue(certB1Pin.equals(keypairBCertificate2Pin));
-    assertFalse(certA1Pin.equals(certB1Pin));
+    assertTrue(certA1Sha256Pin.equals(keypairACertificate2Pin));
+    assertTrue(certB1Sha256Pin.equals(keypairBCertificate2Pin));
+    assertFalse(certA1Sha256Pin.equals(certB1Sha256Pin));
   }
 
   @Test public void successfulCheck() throws Exception {
     CertificatePinner certificatePinner = new CertificatePinner.Builder()
-        .add("example.com", certA1Pin)
+        .add("example.com", certA1Sha256Pin)
+        .build();
+
+    certificatePinner.check("example.com", certA1.certificate);
+  }
+
+  @Test public void successfulCheckSha1Pin() throws Exception {
+    CertificatePinner certificatePinner = new CertificatePinner.Builder()
+        .add("example.com", "sha1/" + CertificatePinner.sha1(certA1.certificate).base64())
         .build();
 
     certificatePinner.check("example.com", certA1.certificate);
@@ -115,7 +115,7 @@ static ByteString pinToBase64(String pin) {
 
   @Test public void successfulMatchAcceptsAnyMatchingCertificate() throws Exception {
     CertificatePinner certificatePinner = new CertificatePinner.Builder()
-        .add("example.com", certB1Pin)
+        .add("example.com", certB1Sha256Pin)
         .build();
 
     certificatePinner.check("example.com", certA1.certificate, certB1.certificate);
@@ -123,7 +123,7 @@ static ByteString pinToBase64(String pin) {
 
   @Test public void unsuccessfulCheck() throws Exception {
     CertificatePinner certificatePinner = new CertificatePinner.Builder()
-        .add("example.com", certA1Pin)
+        .add("example.com", certA1Sha256Pin)
         .build();
 
     try {
@@ -135,7 +135,7 @@ static ByteString pinToBase64(String pin) {
 
   @Test public void multipleCertificatesForOneHostname() throws Exception {
     CertificatePinner certificatePinner = new CertificatePinner.Builder()
-        .add("example.com", certA1Pin, certB1Pin)
+        .add("example.com", certA1Sha256Pin, certB1Sha256Pin)
         .build();
 
     certificatePinner.check("example.com", certA1.certificate);
@@ -144,8 +144,8 @@ static ByteString pinToBase64(String pin) {
 
   @Test public void multipleHostnamesForOneCertificate() throws Exception {
     CertificatePinner certificatePinner = new CertificatePinner.Builder()
-        .add("example.com", certA1Pin)
-        .add("www.example.com", certA1Pin)
+        .add("example.com", certA1Sha256Pin)
+        .add("www.example.com", certA1Sha256Pin)
         .build();
 
     certificatePinner.check("example.com", certA1.certificate);
@@ -159,7 +159,7 @@ static ByteString pinToBase64(String pin) {
 
   @Test public void successfulCheckForWildcardHostname() throws Exception {
     CertificatePinner certificatePinner = new CertificatePinner.Builder()
-        .add("*.example.com", certA1Pin)
+        .add("*.example.com", certA1Sha256Pin)
         .build();
 
     certificatePinner.check("a.example.com", certA1.certificate);
@@ -168,7 +168,7 @@ static ByteString pinToBase64(String pin) {
   @Test public void successfulMatchAcceptsAnyMatchingCertificateForWildcardHostname()
       throws Exception {
     CertificatePinner certificatePinner = new CertificatePinner.Builder()
-        .add("*.example.com", certB1Pin)
+        .add("*.example.com", certB1Sha256Pin)
         .build();
 
     certificatePinner.check("a.example.com", certA1.certificate, certB1.certificate);
@@ -176,7 +176,7 @@ static ByteString pinToBase64(String pin) {
 
   @Test public void unsuccessfulCheckForWildcardHostname() throws Exception {
     CertificatePinner certificatePinner = new CertificatePinner.Builder()
-        .add("*.example.com", certA1Pin)
+        .add("*.example.com", certA1Sha256Pin)
         .build();
 
     try {
@@ -188,7 +188,7 @@ static ByteString pinToBase64(String pin) {
 
   @Test public void multipleCertificatesForOneWildcardHostname() throws Exception {
     CertificatePinner certificatePinner = new CertificatePinner.Builder()
-        .add("*.example.com", certA1Pin, certB1Pin)
+        .add("*.example.com", certA1Sha256Pin, certB1Sha256Pin)
         .build();
 
     certificatePinner.check("a.example.com", certA1.certificate);
@@ -198,8 +198,8 @@ static ByteString pinToBase64(String pin) {
   @Test public void successfulCheckForOneHostnameWithWildcardAndDirectCertificate()
       throws Exception {
     CertificatePinner certificatePinner = new CertificatePinner.Builder()
-        .add("*.example.com", certA1Pin)
-        .add("a.example.com", certB1Pin)
+        .add("*.example.com", certA1Sha256Pin)
+        .add("a.example.com", certB1Sha256Pin)
         .build();
 
     certificatePinner.check("a.example.com", certA1.certificate);
@@ -209,8 +209,8 @@ static ByteString pinToBase64(String pin) {
   @Test public void unsuccessfulCheckForOneHostnameWithWildcardAndDirectCertificate()
       throws Exception {
     CertificatePinner certificatePinner = new CertificatePinner.Builder()
-        .add("*.example.com", certA1Pin)
-        .add("a.example.com", certB1Pin)
+        .add("*.example.com", certA1Sha256Pin)
+        .add("a.example.com", certB1Sha256Pin)
         .build();
 
     try {
@@ -222,35 +222,35 @@ static ByteString pinToBase64(String pin) {
 
   @Test public void successfulFindMatchingPins() {
     CertificatePinner certificatePinner = new CertificatePinner.Builder()
-        .add("first.com", certA1Pin, certB1Pin)
-        .add("second.com", certC1Pin)
+        .add("first.com", certA1Sha256Pin, certB1Sha256Pin)
+        .add("second.com", certC1Sha256Pin)
         .build();
 
-    Set<ByteString> expectedPins = setOf(certA1PinBase64, certB1PinBase64);
-    Set<ByteString> matchedPins = certificatePinner.findMatchingPins("first.com");
-
-    assertEquals(expectedPins, matchedPins);
+    List<Pin> expectedPins = Arrays.asList(
+        new Pin("first.com", certA1Sha256Pin),
+        new Pin("first.com", certB1Sha256Pin));
+    assertEquals(expectedPins, certificatePinner.findMatchingPins("first.com"));
   }
 
   @Test public void successfulFindMatchingPinsForWildcardAndDirectCertificates() {
     CertificatePinner certificatePinner = new CertificatePinner.Builder()
-        .add("*.example.com", certA1Pin)
-        .add("a.example.com", certB1Pin)
-        .add("b.example.com", certC1Pin)
+        .add("*.example.com", certA1Sha256Pin)
+        .add("a.example.com", certB1Sha256Pin)
+        .add("b.example.com", certC1Sha256Pin)
         .build();
 
-    Set<ByteString> expectedPins = setOf(certA1PinBase64, certB1PinBase64);
-    Set<ByteString> matchedPins = certificatePinner.findMatchingPins("a.example.com");
-
-    assertEquals(expectedPins, matchedPins);
+    List<Pin> expectedPins = Arrays.asList(
+        new Pin("*.example.com", certA1Sha256Pin),
+        new Pin("a.example.com", certB1Sha256Pin));
+    assertEquals(expectedPins, certificatePinner.findMatchingPins("a.example.com"));
   }
 
   @Test public void wildcardHostnameShouldNotMatchThroughDot() throws Exception {
     CertificatePinner certificatePinner = new CertificatePinner.Builder()
-        .add("*.example.com", certA1Pin)
+        .add("*.example.com", certA1Sha256Pin)
         .build();
 
-    assertNull(certificatePinner.findMatchingPins("example.com"));
-    assertNull(certificatePinner.findMatchingPins("a.b.example.com"));
+    assertEquals(Collections.emptyList(), certificatePinner.findMatchingPins("example.com"));
+    assertEquals(Collections.emptyList(), certificatePinner.findMatchingPins("a.b.example.com"));
   }
 }
diff --git a/okhttp-tests/src/test/java/okhttp3/CookieTest.java b/okhttp-tests/src/test/java/okhttp3/CookieTest.java
index 9ab211780f..bee549dc7d 100644
--- a/okhttp-tests/src/test/java/okhttp3/CookieTest.java
+++ b/okhttp-tests/src/test/java/okhttp3/CookieTest.java
@@ -399,7 +399,7 @@
     try {
       new Cookie.Builder().hostOnlyDomain(null);
       fail();
-    } catch (IllegalArgumentException expected) {
+    } catch (NullPointerException expected) {
     }
     try {
       new Cookie.Builder().hostOnlyDomain("a/b");
diff --git a/okhttp-tests/src/test/java/okhttp3/HttpUrlTest.java b/okhttp-tests/src/test/java/okhttp3/HttpUrlTest.java
index a67dc380d4..f7d655dbf0 100644
--- a/okhttp-tests/src/test/java/okhttp3/HttpUrlTest.java
+++ b/okhttp-tests/src/test/java/okhttp3/HttpUrlTest.java
@@ -438,6 +438,15 @@
     assertEquals("::", HttpUrl.parse("http://[0:0:0:0:0:0:0:0]/").host());
   }
 
+  /** The builder permits square braces but does not require them. */
+  @Test public void hostIPv6Builder() throws Exception {
+    HttpUrl base = HttpUrl.parse("http://example.com/");
+    assertEquals("http://[::1]/", base.newBuilder().host("[::1]").build().toString());
+    assertEquals("http://[::1]/", base.newBuilder().host("[::0001]").build().toString());
+    assertEquals("http://[::1]/", base.newBuilder().host("::1").build().toString());
+    assertEquals("http://[::1]/", base.newBuilder().host("::0001").build().toString());
+  }
+
   @Test public void hostIpv4CanonicalForm() throws Exception {
     assertEquals("255.255.255.255", HttpUrl.parse("http://255.255.255.255/").host());
     assertEquals("1.2.3.4", HttpUrl.parse("http://1.2.3.4/").host());
@@ -801,6 +810,64 @@
     assertEquals(3, HttpUrl.parse("http://host/a/b/c").pathSize());
   }
 
+  @Test public void addPathSegments() throws Exception {
+    HttpUrl base = HttpUrl.parse("http://host/a/b/c");
+
+    // Add a string with zero slashes: resulting URL gains one slash.
+    assertEquals("/a/b/c/", base.newBuilder().addPathSegments("").build().encodedPath());
+    assertEquals("/a/b/c/d", base.newBuilder().addPathSegments("d").build().encodedPath());
+
+    // Add a string with one slash: resulting URL gains two slashes.
+    assertEquals("/a/b/c//", base.newBuilder().addPathSegments("/").build().encodedPath());
+    assertEquals("/a/b/c/d/", base.newBuilder().addPathSegments("d/").build().encodedPath());
+    assertEquals("/a/b/c//d", base.newBuilder().addPathSegments("/d").build().encodedPath());
+
+    // Add a string with two slashes: resulting URL gains three slashes.
+    assertEquals("/a/b/c///", base.newBuilder().addPathSegments("//").build().encodedPath());
+    assertEquals("/a/b/c//d/", base.newBuilder().addPathSegments("/d/").build().encodedPath());
+    assertEquals("/a/b/c/d//", base.newBuilder().addPathSegments("d//").build().encodedPath());
+    assertEquals("/a/b/c///d", base.newBuilder().addPathSegments("//d").build().encodedPath());
+    assertEquals("/a/b/c/d/e/f", base.newBuilder().addPathSegments("d/e/f").build().encodedPath());
+  }
+
+  @Test public void addPathSegmentsOntoTrailingSlash() throws Exception {
+    HttpUrl base = HttpUrl.parse("http://host/a/b/c/");
+
+    // Add a string with zero slashes: resulting URL gains zero slashes.
+    assertEquals("/a/b/c/", base.newBuilder().addPathSegments("").build().encodedPath());
+    assertEquals("/a/b/c/d", base.newBuilder().addPathSegments("d").build().encodedPath());
+
+    // Add a string with one slash: resulting URL gains one slash.
+    assertEquals("/a/b/c//", base.newBuilder().addPathSegments("/").build().encodedPath());
+    assertEquals("/a/b/c/d/", base.newBuilder().addPathSegments("d/").build().encodedPath());
+    assertEquals("/a/b/c//d", base.newBuilder().addPathSegments("/d").build().encodedPath());
+
+    // Add a string with two slashes: resulting URL gains two slashes.
+    assertEquals("/a/b/c///", base.newBuilder().addPathSegments("//").build().encodedPath());
+    assertEquals("/a/b/c//d/", base.newBuilder().addPathSegments("/d/").build().encodedPath());
+    assertEquals("/a/b/c/d//", base.newBuilder().addPathSegments("d//").build().encodedPath());
+    assertEquals("/a/b/c///d", base.newBuilder().addPathSegments("//d").build().encodedPath());
+    assertEquals("/a/b/c/d/e/f", base.newBuilder().addPathSegments("d/e/f").build().encodedPath());
+  }
+
+  @Test public void addPathSegmentsWithBackslash() throws Exception {
+    HttpUrl base = HttpUrl.parse("http://host/");
+    assertEquals("/d/e", base.newBuilder().addPathSegments("d\\e").build().encodedPath());
+    assertEquals("/d/e", base.newBuilder().addEncodedPathSegments("d\\e").build().encodedPath());
+  }
+
+  @Test public void addPathSegmentsWithEmptyPaths() throws Exception {
+    HttpUrl base = HttpUrl.parse("http://host/a/b/c");
+    assertEquals("/a/b/c//d/e///f",
+        base.newBuilder().addPathSegments("/d/e///f").build().encodedPath());
+  }
+
+  @Test public void addEncodedPathSegments() throws Exception {
+    HttpUrl base = HttpUrl.parse("http://host/a/b/c");
+    assertEquals("/a/b/c/d/e/%20/",
+        base.newBuilder().addEncodedPathSegments("d/e/%20/\n").build().encodedPath());
+  }
+
   @Test public void addPathSegmentDotDoesNothing() throws Exception {
     HttpUrl base = HttpUrl.parse("http://host/a/b/c");
     assertEquals("/a/b/c", base.newBuilder().addPathSegment(".").build().encodedPath());
diff --git a/okhttp-tests/src/test/java/okhttp3/RequestTest.java b/okhttp-tests/src/test/java/okhttp3/RequestTest.java
index 0ef87d6c86..4668f6005d 100644
--- a/okhttp-tests/src/test/java/okhttp3/RequestTest.java
+++ b/okhttp-tests/src/test/java/okhttp3/RequestTest.java
@@ -174,8 +174,31 @@
     }
   }
 
+  @Test public void headerForbidsNullArguments() throws Exception {
+    Request.Builder builder = new Request.Builder();
+    try {
+      builder.header(null, "Value");
+      fail();
+    } catch (NullPointerException expected) {
+    }
+    try {
+      builder.addHeader(null, "Value");
+      fail();
+    } catch (NullPointerException expected) {
+    }
+    try {
+      builder.header("Name", null);
+      fail();
+    } catch (NullPointerException expected) {
+    }
+    try {
+      builder.addHeader("Name", null);
+      fail();
+    } catch (NullPointerException expected) {
+    }
+  }
+
   @Test public void headerForbidsControlCharacters() throws Exception {
-    assertForbiddenHeader(null);
     assertForbiddenHeader("\u0000");
     assertForbiddenHeader("\r");
     assertForbiddenHeader("\n");
diff --git a/okhttp-tests/src/test/java/okhttp3/URLConnectionTest.java b/okhttp-tests/src/test/java/okhttp3/URLConnectionTest.java
index 5a68c7aade..768adf78fe 100644
--- a/okhttp-tests/src/test/java/okhttp3/URLConnectionTest.java
+++ b/okhttp-tests/src/test/java/okhttp3/URLConnectionTest.java
@@ -915,7 +915,7 @@ private void testConnectViaHttpProxyToHttps(ProxyConfig proxyConfig) throws Exce
     RecordedRequest connect = server.takeRequest();
     assertEquals("Connect line failure on proxy", "CONNECT android.com:443 HTTP/1.1",
         connect.getRequestLine());
-    assertEquals("android.com", connect.getHeader("Host"));
+    assertEquals("android.com:443", connect.getHeader("Host"));
 
     RecordedRequest get = server.takeRequest();
     assertEquals("GET /foo HTTP/1.1", get.getRequestLine());
@@ -951,7 +951,7 @@ private void testConnectViaHttpProxyToHttps(ProxyConfig proxyConfig) throws Exce
 
     RecordedRequest connect = server.takeRequest();
     assertEquals("CONNECT android.com:443 HTTP/1.1", connect.getRequestLine());
-    assertEquals("android.com", connect.getHeader("Host"));
+    assertEquals("android.com:443", connect.getHeader("Host"));
   }
 
   private void initResponseCache() throws IOException {
@@ -988,7 +988,7 @@ private void initResponseCache() throws IOException {
     assertNull(connect.getHeader("Private"));
     assertNull(connect.getHeader("Proxy-Authorization"));
     assertEquals(Version.userAgent(), connect.getHeader("User-Agent"));
-    assertEquals("android.com", connect.getHeader("Host"));
+    assertEquals("android.com:443", connect.getHeader("Host"));
     assertEquals("Keep-Alive", connect.getHeader("Proxy-Connection"));
 
     RecordedRequest get = server.takeRequest();
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/DiskLruCacheTest.java b/okhttp-tests/src/test/java/okhttp3/internal/DiskLruCacheTest.java
index 955214068e..777f3bd73f 100644
--- a/okhttp-tests/src/test/java/okhttp3/internal/DiskLruCacheTest.java
+++ b/okhttp-tests/src/test/java/okhttp3/internal/DiskLruCacheTest.java
@@ -50,7 +50,7 @@
 
 public final class DiskLruCacheTest {
   @Rule public final TemporaryFolder tempDir = new TemporaryFolder();
-  @Rule public final Timeout timeout = new Timeout(30 * 1000);
+  @Rule public final Timeout timeout = new Timeout(60 * 1000);
 
   private final FaultyFileSystem fileSystem = new FaultyFileSystem(FileSystem.SYSTEM);
   private final int appVersion = 100;
@@ -1073,11 +1073,11 @@ private void createNewCacheWithSize(int maxSize) throws IOException {
     set("b", "b", "b");
 
     // We can't begin the edit if writing 'DIRTY' fails.
-    fileSystem.setFaulty(journalFile, true);
+    fileSystem.setFaultyWrite(journalFile, true);
     assertNull(cache.edit("c"));
 
     // Once the journal has a failure, subsequent writes aren't permitted.
-    fileSystem.setFaulty(journalFile, false);
+    fileSystem.setFaultyWrite(journalFile, false);
     assertNull(cache.edit("d"));
 
     // Confirm that the fault didn't corrupt entries stored before the fault was introduced.
@@ -1101,11 +1101,11 @@ private void createNewCacheWithSize(int maxSize) throws IOException {
     DiskLruCache.Editor editor = cache.edit("c");
     setString(editor, 0, "c");
     setString(editor, 1, "c");
-    fileSystem.setFaulty(journalFile, true);
+    fileSystem.setFaultyWrite(journalFile, true);
     editor.commit();
 
     // Once the journal has a failure, subsequent writes aren't permitted.
-    fileSystem.setFaulty(journalFile, false);
+    fileSystem.setFaultyWrite(journalFile, false);
     assertNull(cache.edit("d"));
 
     // Confirm that the fault didn't corrupt entries stored before the fault was introduced.
@@ -1125,11 +1125,11 @@ private void createNewCacheWithSize(int maxSize) throws IOException {
     DiskLruCache.Editor editor = cache.edit("c");
     setString(editor, 0, "c");
     setString(editor, 1, "c");
-    fileSystem.setFaulty(journalFile, true);
+    fileSystem.setFaultyWrite(journalFile, true);
     editor.abort();
 
     // Once the journal has a failure, subsequent writes aren't permitted.
-    fileSystem.setFaulty(journalFile, false);
+    fileSystem.setFaultyWrite(journalFile, false);
     assertNull(cache.edit("d"));
 
     // Confirm that the fault didn't corrupt entries stored before the fault was introduced.
@@ -1146,17 +1146,202 @@ private void createNewCacheWithSize(int maxSize) throws IOException {
     set("b", "b", "b");
 
     // Remove, but the journal write will fail.
-    fileSystem.setFaulty(journalFile, true);
+    fileSystem.setFaultyWrite(journalFile, true);
     assertTrue(cache.remove("a"));
 
     // Confirm that the entry was still removed.
-    fileSystem.setFaulty(journalFile, false);
+    fileSystem.setFaultyWrite(journalFile, false);
     cache.close();
     cache = new DiskLruCache(fileSystem, cacheDir, appVersion, 2, Integer.MAX_VALUE, executor);
     assertAbsent("a");
     assertValue("b", "b", "b");
   }
 
+  @Test public void cleanupTrimFailurePreventsNewEditors() throws Exception {
+    cache.setMaxSize(8);
+    executor.jobs.pop();
+    set("a", "aa", "aa");
+    set("b", "bb", "bbb");
+
+    // Cause the cache trim job to fail.
+    fileSystem.setFaultyDelete(new File(cacheDir, "a.0"), true);
+    executor.jobs.pop().run();
+
+    // Confirm that edits are prevented after a cache trim failure.
+    assertNull(cache.edit("a"));
+    assertNull(cache.edit("b"));
+    assertNull(cache.edit("c"));
+
+    // Allow the test to clean up.
+    fileSystem.setFaultyDelete(new File(cacheDir, "a.0"), false);
+  }
+
+  @Test public void cleanupTrimFailureRetriedOnEditors() throws Exception {
+    cache.setMaxSize(8);
+    executor.jobs.pop();
+    set("a", "aa", "aa");
+    set("b", "bb", "bbb");
+
+    // Cause the cache trim job to fail.
+    fileSystem.setFaultyDelete(new File(cacheDir, "a.0"), true);
+    executor.jobs.pop().run();
+
+    // An edit should now add a job to clean up if the most recent trim failed.
+    assertNull(cache.edit("b"));
+    executor.jobs.pop().run();
+
+    // Confirm a successful cache trim now allows edits.
+    fileSystem.setFaultyDelete(new File(cacheDir, "a.0"), false);
+    assertNull(cache.edit("c"));
+    executor.jobs.pop().run();
+    set("c", "cc", "cc");
+    assertValue("c", "cc", "cc");
+  }
+
+  @Test public void cleanupTrimFailureWithInFlightEditor() throws Exception {
+    cache.setMaxSize(8);
+    executor.jobs.pop();
+    set("a", "aa", "aaa");
+    set("b", "bb", "bb");
+    DiskLruCache.Editor inFlightEditor = cache.edit("c");
+
+    // Cause the cache trim job to fail.
+    fileSystem.setFaultyDelete(new File(cacheDir, "a.0"), true);
+    executor.jobs.pop().run();
+
+    // The in-flight editor can still write after a trim failure.
+    setString(inFlightEditor, 0, "cc");
+    setString(inFlightEditor, 1, "cc");
+    inFlightEditor.commit();
+
+    // Confirm the committed values are present after a successful cache trim.
+    fileSystem.setFaultyDelete(new File(cacheDir, "a.0"), false);
+    executor.jobs.pop().run();
+    assertValue("c", "cc", "cc");
+  }
+
+  @Test public void cleanupTrimFailureAllowsSnapshotReads() throws Exception {
+    cache.setMaxSize(8);
+    executor.jobs.pop();
+    set("a", "aa", "aa");
+    set("b", "bb", "bbb");
+
+    // Cause the cache trim job to fail.
+    fileSystem.setFaultyDelete(new File(cacheDir, "a.0"), true);
+    executor.jobs.pop().run();
+
+    // Confirm we still allow snapshot reads after a trim failure.
+    assertValue("a", "aa", "aa");
+    assertValue("b", "bb", "bbb");
+
+    // Allow the test to clean up.
+    fileSystem.setFaultyDelete(new File(cacheDir, "a.0"), false);
+  }
+
+  @Test public void cleanupTrimFailurePreventsSnapshotWrites() throws Exception {
+    cache.setMaxSize(8);
+    executor.jobs.pop();
+    set("a", "aa", "aa");
+    set("b", "bb", "bbb");
+
+    // Cause the cache trim job to fail.
+    fileSystem.setFaultyDelete(new File(cacheDir, "a.0"), true);
+    executor.jobs.pop().run();
+
+    // Confirm snapshot writes are prevented after a trim failure.
+    DiskLruCache.Snapshot snapshot1 = cache.get("a");
+    assertNull(snapshot1.edit());
+    snapshot1.close();
+    DiskLruCache.Snapshot snapshot2 = cache.get("b");
+    assertNull(snapshot2.edit());
+    snapshot2.close();
+
+    // Allow the test to clean up.
+    fileSystem.setFaultyDelete(new File(cacheDir, "a.0"), false);
+  }
+
+  @Test public void evictAllAfterCleanupTrimFailure() throws Exception {
+    cache.setMaxSize(8);
+    executor.jobs.pop();
+    set("a", "aa", "aa");
+    set("b", "bb", "bbb");
+
+    // Cause the cache trim job to fail.
+    fileSystem.setFaultyDelete(new File(cacheDir, "a.0"), true);
+    executor.jobs.pop().run();
+
+    // Confirm we prevent edits after a trim failure.
+    assertNull(cache.edit("c"));
+
+    // A successful eviction should allow new writes.
+    fileSystem.setFaultyDelete(new File(cacheDir, "a.0"), false);
+    cache.evictAll();
+    set("c", "cc", "cc");
+    assertValue("c", "cc", "cc");
+  }
+
+  @Test public void manualRemovalAfterCleanupTrimFailure() throws Exception {
+    cache.setMaxSize(8);
+    executor.jobs.pop();
+    set("a", "aa", "aa");
+    set("b", "bb", "bbb");
+
+    // Cause the cache trim job to fail.
+    fileSystem.setFaultyDelete(new File(cacheDir, "a.0"), true);
+    executor.jobs.pop().run();
+
+    // Confirm we prevent edits after a trim failure.
+    assertNull(cache.edit("c"));
+
+    // A successful removal which trims the cache should allow new writes.
+    fileSystem.setFaultyDelete(new File(cacheDir, "a.0"), false);
+    cache.remove("a");
+    set("c", "cc", "cc");
+    assertValue("c", "cc", "cc");
+  }
+
+  @Test public void flushingAfterCleanupTrimFailure() throws Exception {
+    cache.setMaxSize(8);
+    executor.jobs.pop();
+    set("a", "aa", "aa");
+    set("b", "bb", "bbb");
+
+    // Cause the cache trim job to fail.
+    fileSystem.setFaultyDelete(new File(cacheDir, "a.0"), true);
+    executor.jobs.pop().run();
+
+    // Confirm we prevent edits after a trim failure.
+    assertNull(cache.edit("c"));
+
+    // A successful flush trims the cache and should allow new writes.
+    fileSystem.setFaultyDelete(new File(cacheDir, "a.0"), false);
+    cache.flush();
+    set("c", "cc", "cc");
+    assertValue("c", "cc", "cc");
+  }
+
+  @Test public void cleanupTrimFailureWithPartialSnapshot() throws Exception {
+    cache.setMaxSize(8);
+    executor.jobs.pop();
+    set("a", "aa", "aa");
+    set("b", "bb", "bbb");
+
+    // Cause the cache trim to fail on the second value leaving a partial snapshot.
+    fileSystem.setFaultyDelete(new File(cacheDir, "a.1"), true);
+    executor.jobs.pop().run();
+
+    // Confirm the partial snapshot is not returned.
+    assertNull(cache.get("a"));
+
+    // Confirm we prevent edits after a trim failure.
+    assertNull(cache.edit("a"));
+
+    // Confirm the partial snapshot is not returned after a successful trim.
+    fileSystem.setFaultyDelete(new File(cacheDir, "a.1"), false);
+    executor.jobs.pop().run();
+    assertNull(cache.get("a"));
+  }
+
   private void assertJournalEquals(String... expectedBodyLines) throws Exception {
     List<String> expectedLines = new ArrayList<>();
     expectedLines.add(MAGIC);
@@ -1258,7 +1443,7 @@ private void generateSomeGarbageFiles() throws Exception {
     writeFile(new File(dir2, "otherFile1"), "F");
   }
 
-  private void assertGarbageFilesAllDeleted() throws Exception {
+  private void assertGarbageFilesAllDeleted() {
     assertFalse(fileSystem.exists(getCleanFile("g1", 0)));
     assertFalse(fileSystem.exists(getCleanFile("g1", 1)));
     assertFalse(fileSystem.exists(getCleanFile("g2", 0)));
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/FaultyFileSystem.java b/okhttp-tests/src/test/java/okhttp3/internal/FaultyFileSystem.java
index 22b1758227..77cdd9c485 100644
--- a/okhttp-tests/src/test/java/okhttp3/internal/FaultyFileSystem.java
+++ b/okhttp-tests/src/test/java/okhttp3/internal/FaultyFileSystem.java
@@ -29,12 +29,13 @@
 public final class FaultyFileSystem implements FileSystem {
   private final FileSystem delegate;
   private final Set<File> writeFaults = new LinkedHashSet<>();
+  private final Set<File> deleteFaults = new LinkedHashSet<>();
 
   public FaultyFileSystem(FileSystem delegate) {
     this.delegate = delegate;
   }
 
-  public void setFaulty(File file, boolean faulty) {
+  public void setFaultyWrite(File file, boolean faulty) {
     if (faulty) {
       writeFaults.add(file);
     } else {
@@ -42,6 +43,14 @@ public void setFaulty(File file, boolean faulty) {
     }
   }
 
+  public void setFaultyDelete(File file, boolean faulty) {
+    if (faulty) {
+      deleteFaults.add(file);
+    } else {
+      deleteFaults.remove(file);
+    }
+  }
+
   @Override public Source source(File file) throws FileNotFoundException {
     return delegate.source(file);
   }
@@ -55,10 +64,11 @@ public void setFaulty(File file, boolean faulty) {
   }
 
   @Override public void delete(File file) throws IOException {
+    if (deleteFaults.contains(file)) throw new IOException("boom!");
     delegate.delete(file);
   }
 
-  @Override public boolean exists(File file) throws IOException {
+  @Override public boolean exists(File file) {
     return delegate.exists(file);
   }
 
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/tls/CertificatePinnerChainValidationTest.java b/okhttp-tests/src/test/java/okhttp3/internal/tls/CertificatePinnerChainValidationTest.java
new file mode 100644
index 0000000000..8c50399878
--- /dev/null
+++ b/okhttp-tests/src/test/java/okhttp3/internal/tls/CertificatePinnerChainValidationTest.java
@@ -0,0 +1,305 @@
+/*
+ * Copyright (C) 2016 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.internal.tls;
+
+import javax.net.ssl.SSLContext;
+import javax.net.ssl.SSLHandshakeException;
+import javax.net.ssl.SSLPeerUnverifiedException;
+import okhttp3.Call;
+import okhttp3.CertificatePinner;
+import okhttp3.OkHttpClient;
+import okhttp3.RecordingHostnameVerifier;
+import okhttp3.Request;
+import okhttp3.Response;
+import okhttp3.internal.HeldCertificate;
+import okhttp3.internal.SslContextBuilder;
+import okhttp3.mockwebserver.MockResponse;
+import okhttp3.mockwebserver.MockWebServer;
+import okhttp3.mockwebserver.SocketPolicy;
+import org.junit.Rule;
+import org.junit.Test;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertTrue;
+import static org.junit.Assert.fail;
+
+public final class CertificatePinnerChainValidationTest {
+  @Rule public final MockWebServer server = new MockWebServer();
+
+  /** The pinner should pull the root certificate from the trust manager. */
+  @Test public void pinRootNotPresentInChain() throws Exception {
+    HeldCertificate rootCa = new HeldCertificate.Builder()
+        .serialNumber("1")
+        .ca(3)
+        .commonName("root")
+        .build();
+    HeldCertificate intermediateCa = new HeldCertificate.Builder()
+        .issuedBy(rootCa)
+        .ca(2)
+        .serialNumber("2")
+        .commonName("intermediate_ca")
+        .build();
+    HeldCertificate certificate = new HeldCertificate.Builder()
+        .issuedBy(intermediateCa)
+        .serialNumber("3")
+        .commonName(server.getHostName())
+        .build();
+    CertificatePinner certificatePinner = new CertificatePinner.Builder()
+        .add(server.getHostName(), CertificatePinner.pin(rootCa.certificate))
+        .build();
+    SSLContext clientContext = new SslContextBuilder()
+        .addTrustedCertificate(rootCa.certificate)
+        .build();
+    OkHttpClient client = new OkHttpClient.Builder()
+        .sslSocketFactory(clientContext.getSocketFactory())
+        .hostnameVerifier(new RecordingHostnameVerifier())
+        .certificatePinner(certificatePinner)
+        .build();
+
+    SSLContext serverSslContext = new SslContextBuilder()
+        .certificateChain(certificate, intermediateCa)
+        .build();
+    server.useHttps(serverSslContext.getSocketFactory(), false);
+
+    // The request should complete successfully.
+    server.enqueue(new MockResponse()
+        .setBody("abc")
+        .setSocketPolicy(SocketPolicy.DISCONNECT_AT_END));
+    Call call1 = client.newCall(new Request.Builder()
+        .url(server.url("/"))
+        .build());
+    Response response1 = call1.execute();
+    assertEquals("abc", response1.body().string());
+
+    // Confirm that a second request also succeeds. This should detect caching problems.
+    server.enqueue(new MockResponse()
+        .setBody("def")
+        .setSocketPolicy(SocketPolicy.DISCONNECT_AT_END));
+    Call call2 = client.newCall(new Request.Builder()
+        .url(server.url("/"))
+        .build());
+    Response response2 = call2.execute();
+    assertEquals("def", response2.body().string());
+  }
+
+  /** The pinner should accept an intermediate from the server's chain. */
+  @Test public void pinIntermediatePresentInChain() throws Exception {
+    HeldCertificate rootCa = new HeldCertificate.Builder()
+        .serialNumber("1")
+        .ca(3)
+        .commonName("root")
+        .build();
+    HeldCertificate intermediateCa = new HeldCertificate.Builder()
+        .issuedBy(rootCa)
+        .ca(2)
+        .serialNumber("2")
+        .commonName("intermediate_ca")
+        .build();
+    HeldCertificate certificate = new HeldCertificate.Builder()
+        .issuedBy(intermediateCa)
+        .serialNumber("3")
+        .commonName(server.getHostName())
+        .build();
+    CertificatePinner certificatePinner = new CertificatePinner.Builder()
+        .add(server.getHostName(), CertificatePinner.pin(intermediateCa.certificate))
+        .build();
+    SSLContext clientContext = new SslContextBuilder()
+        .addTrustedCertificate(rootCa.certificate)
+        .build();
+    OkHttpClient client = new OkHttpClient.Builder()
+        .sslSocketFactory(clientContext.getSocketFactory())
+        .hostnameVerifier(new RecordingHostnameVerifier())
+        .certificatePinner(certificatePinner)
+        .build();
+
+    SSLContext serverSslContext = new SslContextBuilder()
+        .certificateChain(certificate, intermediateCa)
+        .build();
+    server.useHttps(serverSslContext.getSocketFactory(), false);
+
+    // The request should complete successfully.
+    server.enqueue(new MockResponse()
+        .setBody("abc")
+        .setSocketPolicy(SocketPolicy.DISCONNECT_AT_END));
+    Call call1 = client.newCall(new Request.Builder()
+        .url(server.url("/"))
+        .build());
+    Response response1 = call1.execute();
+    assertEquals("abc", response1.body().string());
+
+    // Confirm that a second request also succeeds. This should detect caching problems.
+    server.enqueue(new MockResponse()
+        .setBody("def")
+        .setSocketPolicy(SocketPolicy.DISCONNECT_AT_END));
+    Call call2 = client.newCall(new Request.Builder()
+        .url(server.url("/"))
+        .build());
+    Response response2 = call2.execute();
+    assertEquals("def", response2.body().string());
+  }
+
+  @Test public void unrelatedPinnedLeafCertificateInChain() throws Exception {
+    // Start with a trusted root CA certificate.
+    HeldCertificate rootCa = new HeldCertificate.Builder()
+        .serialNumber("1")
+        .ca(3)
+        .commonName("root")
+        .build();
+
+    // Add a good intermediate CA, and have that issue a good certificate to localhost. Prepare an
+    // SSL context for an HTTP client under attack. It includes the trusted CA and a pinned
+    // certificate.
+    HeldCertificate goodIntermediateCa = new HeldCertificate.Builder()
+        .issuedBy(rootCa)
+        .ca(2)
+        .serialNumber("2")
+        .commonName("good_intermediate_ca")
+        .build();
+    HeldCertificate goodCertificate = new HeldCertificate.Builder()
+        .issuedBy(goodIntermediateCa)
+        .serialNumber("3")
+        .commonName(server.getHostName())
+        .build();
+    CertificatePinner certificatePinner = new CertificatePinner.Builder()
+        .add(server.getHostName(), CertificatePinner.pin(goodCertificate.certificate))
+        .build();
+    SSLContext clientContext = new SslContextBuilder()
+        .addTrustedCertificate(rootCa.certificate)
+        .build();
+    OkHttpClient client = new OkHttpClient.Builder()
+        .sslSocketFactory(clientContext.getSocketFactory())
+        .hostnameVerifier(new RecordingHostnameVerifier())
+        .certificatePinner(certificatePinner)
+        .build();
+
+    // Add a bad intermediate CA and have that issue a rogue certificate for localhost. Prepare
+    // an SSL context for an attacking webserver. It includes both these rogue certificates plus the
+    // trusted good certificate above. The attack is that by including the good certificate in the
+    // chain, we may trick the certificate pinner into accepting the rouge certificate.
+    HeldCertificate compromisedIntermediateCa = new HeldCertificate.Builder()
+        .issuedBy(rootCa)
+        .ca(2)
+        .serialNumber("4")
+        .commonName("bad_intermediate_ca")
+        .build();
+    HeldCertificate rogueCertificate = new HeldCertificate.Builder()
+        .serialNumber("5")
+        .issuedBy(compromisedIntermediateCa)
+        .commonName(server.getHostName())
+        .build();
+    SSLContext serverSslContext = new SslContextBuilder()
+        .certificateChain(rogueCertificate, compromisedIntermediateCa, goodCertificate, rootCa)
+        .build();
+    server.useHttps(serverSslContext.getSocketFactory(), false);
+    server.enqueue(new MockResponse()
+        .setBody("abc")
+        .addHeader("Content-Type: text/plain"));
+
+    // Make a request from client to server. It should succeed certificate checks (unfortunately the
+    // rogue CA is trusted) but it should fail certificate pinning.
+    Request request = new Request.Builder()
+        .url(server.url("/"))
+        .build();
+    Call call = client.newCall(request);
+    try {
+      call.execute();
+      fail();
+    } catch (SSLPeerUnverifiedException expected) {
+      // Certificate pinning fails!
+      String message = expected.getMessage();
+      assertTrue(message, message.startsWith("Certificate pinning failure!"));
+    }
+  }
+
+  @Test public void unrelatedPinnedIntermediateCertificateInChain() throws Exception {
+    // Start with two root CA certificates, one is good and the other is compromised.
+    HeldCertificate rootCa = new HeldCertificate.Builder()
+        .serialNumber("1")
+        .ca(3)
+        .commonName("root")
+        .build();
+    HeldCertificate compromisedRootCa = new HeldCertificate.Builder()
+        .serialNumber("2")
+        .ca(3)
+        .commonName("compromised_root")
+        .build();
+
+    // Add a good intermediate CA, and have that issue a good certificate to localhost. Prepare an
+    // SSL context for an HTTP client under attack. It includes the trusted CA and a pinned
+    // certificate.
+    HeldCertificate goodIntermediateCa = new HeldCertificate.Builder()
+        .issuedBy(rootCa)
+        .ca(2)
+        .serialNumber("3")
+        .commonName("intermediate_ca")
+        .build();
+    CertificatePinner certificatePinner = new CertificatePinner.Builder()
+        .add(server.getHostName(), CertificatePinner.pin(goodIntermediateCa.certificate))
+        .build();
+    SSLContext clientContext = new SslContextBuilder()
+        .addTrustedCertificate(rootCa.certificate)
+        .addTrustedCertificate(compromisedRootCa.certificate)
+        .build();
+    OkHttpClient client = new OkHttpClient.Builder()
+        .sslSocketFactory(clientContext.getSocketFactory())
+        .hostnameVerifier(new RecordingHostnameVerifier())
+        .certificatePinner(certificatePinner)
+        .build();
+
+    // The attacker compromises the root CA, issues an intermediate with the same common name
+    // "intermediate_ca" as the good CA. This signs a rogue certificate for localhost. The server
+    // serves the good CAs certificate in the chain, which means the certificate pinner sees a
+    // different set of certificates than the SSL verifier.
+    HeldCertificate compromisedIntermediateCa = new HeldCertificate.Builder()
+        .issuedBy(compromisedRootCa)
+        .ca(2)
+        .serialNumber("4")
+        .commonName("intermediate_ca")
+        .build();
+    HeldCertificate rogueCertificate = new HeldCertificate.Builder()
+        .serialNumber("5")
+        .issuedBy(compromisedIntermediateCa)
+        .commonName(server.getHostName())
+        .build();
+    SSLContext serverSslContext = new SslContextBuilder()
+        .certificateChain(
+            rogueCertificate, goodIntermediateCa, compromisedIntermediateCa, compromisedRootCa)
+        .build();
+    server.useHttps(serverSslContext.getSocketFactory(), false);
+    server.enqueue(new MockResponse()
+        .setBody("abc")
+        .addHeader("Content-Type: text/plain"));
+
+    // Make a request from client to server. It should succeed certificate checks (unfortunately the
+    // rogue CA is trusted) but it should fail certificate pinning.
+    Request request = new Request.Builder()
+        .url(server.url("/"))
+        .build();
+    Call call = client.newCall(request);
+    try {
+      call.execute();
+      fail();
+    } catch (SSLHandshakeException expected) {
+      // On Android, the handshake fails before the certificate pinner runs.
+      String message = expected.getMessage();
+      assertTrue(message, message.contains("Could not validate certificate"));
+    } catch (SSLPeerUnverifiedException expected) {
+      // On OpenJDK, the handshake succeeds but the certificate pinner fails.
+      String message = expected.getMessage();
+      assertTrue(message, message.startsWith("Certificate pinning failure!"));
+    }
+  }
+}
diff --git a/okhttp-urlconnection/pom.xml b/okhttp-urlconnection/pom.xml
index 322dab6436..2c95ffc6c2 100644
--- a/okhttp-urlconnection/pom.xml
+++ b/okhttp-urlconnection/pom.xml
@@ -6,7 +6,7 @@
   <parent>
     <groupId>com.squareup.okhttp3</groupId>
     <artifactId>parent</artifactId>
-    <version>3.2.0-SNAPSHOT</version>
+    <version>3.3.0-SNAPSHOT</version>
   </parent>
 
   <artifactId>okhttp-urlconnection</artifactId>
diff --git a/okhttp-ws-tests/pom.xml b/okhttp-ws-tests/pom.xml
index cb2972a3f9..783385c8f2 100644
--- a/okhttp-ws-tests/pom.xml
+++ b/okhttp-ws-tests/pom.xml
@@ -6,7 +6,7 @@
   <parent>
     <groupId>com.squareup.okhttp3</groupId>
     <artifactId>parent</artifactId>
-    <version>3.2.0-SNAPSHOT</version>
+    <version>3.3.0-SNAPSHOT</version>
   </parent>
 
   <artifactId>okhttp-ws-tests</artifactId>
diff --git a/okhttp-ws/pom.xml b/okhttp-ws/pom.xml
index 5f9655b39e..e6dbdb5472 100644
--- a/okhttp-ws/pom.xml
+++ b/okhttp-ws/pom.xml
@@ -6,7 +6,7 @@
   <parent>
     <groupId>com.squareup.okhttp3</groupId>
     <artifactId>parent</artifactId>
-    <version>3.2.0-SNAPSHOT</version>
+    <version>3.3.0-SNAPSHOT</version>
   </parent>
 
   <artifactId>okhttp-ws</artifactId>
diff --git a/okhttp/pom.xml b/okhttp/pom.xml
index dc8dad8130..0db4e1a85e 100644
--- a/okhttp/pom.xml
+++ b/okhttp/pom.xml
@@ -6,7 +6,7 @@
   <parent>
     <groupId>com.squareup.okhttp3</groupId>
     <artifactId>parent</artifactId>
-    <version>3.2.0-SNAPSHOT</version>
+    <version>3.3.0-SNAPSHOT</version>
   </parent>
 
   <artifactId>okhttp</artifactId>
diff --git a/okhttp/src/main/java/okhttp3/Address.java b/okhttp/src/main/java/okhttp3/Address.java
index cec154262d..4fd97764a3 100644
--- a/okhttp/src/main/java/okhttp3/Address.java
+++ b/okhttp/src/main/java/okhttp3/Address.java
@@ -57,24 +57,24 @@ public Address(String uriHost, int uriPort, Dns dns, SocketFactory socketFactory
         .port(uriPort)
         .build();
 
-    if (dns == null) throw new IllegalArgumentException("dns == null");
+    if (dns == null) throw new NullPointerException("dns == null");
     this.dns = dns;
 
-    if (socketFactory == null) throw new IllegalArgumentException("socketFactory == null");
+    if (socketFactory == null) throw new NullPointerException("socketFactory == null");
     this.socketFactory = socketFactory;
 
     if (proxyAuthenticator == null) {
-      throw new IllegalArgumentException("proxyAuthenticator == null");
+      throw new NullPointerException("proxyAuthenticator == null");
     }
     this.proxyAuthenticator = proxyAuthenticator;
 
-    if (protocols == null) throw new IllegalArgumentException("protocols == null");
+    if (protocols == null) throw new NullPointerException("protocols == null");
     this.protocols = Util.immutableList(protocols);
 
-    if (connectionSpecs == null) throw new IllegalArgumentException("connectionSpecs == null");
+    if (connectionSpecs == null) throw new NullPointerException("connectionSpecs == null");
     this.connectionSpecs = Util.immutableList(connectionSpecs);
 
-    if (proxySelector == null) throw new IllegalArgumentException("proxySelector == null");
+    if (proxySelector == null) throw new NullPointerException("proxySelector == null");
     this.proxySelector = proxySelector;
 
     this.proxy = proxy;
diff --git a/okhttp/src/main/java/okhttp3/Call.java b/okhttp/src/main/java/okhttp3/Call.java
index 3baaf647da..58506d1376 100644
--- a/okhttp/src/main/java/okhttp3/Call.java
+++ b/okhttp/src/main/java/okhttp3/Call.java
@@ -51,8 +51,7 @@
    * immediately unless there are several other requests currently being executed.
    *
    * <p>This client will later call back {@code responseCallback} with either an HTTP response or a
-   * failure exception. If you {@link #cancel} a request before it completes the callback will not
-   * be invoked.
+   * failure exception.
    *
    * @throws IllegalStateException when the call has already been executed.
    */
diff --git a/okhttp/src/main/java/okhttp3/CertificatePinner.java b/okhttp/src/main/java/okhttp3/CertificatePinner.java
index e485c87f52..d55e5eeb97 100644
--- a/okhttp/src/main/java/okhttp3/CertificatePinner.java
+++ b/okhttp/src/main/java/okhttp3/CertificatePinner.java
@@ -17,30 +17,25 @@
 
 import java.security.cert.Certificate;
 import java.security.cert.X509Certificate;
+import java.util.ArrayList;
 import java.util.Arrays;
-import java.util.LinkedHashMap;
-import java.util.LinkedHashSet;
+import java.util.Collections;
 import java.util.List;
-import java.util.Map;
-import java.util.Set;
 import javax.net.ssl.SSLPeerUnverifiedException;
 import okhttp3.internal.Util;
 import okhttp3.internal.tls.CertificateChainCleaner;
 import okhttp3.internal.tls.TrustRootIndex;
 import okio.ByteString;
 
-import static java.util.Collections.unmodifiableSet;
-
 /**
  * Constrains which certificates are trusted. Pinning certificates defends against attacks on
  * certificate authorities. It also prevents connections through man-in-the-middle certificate
  * authorities either known or unknown to the application's user.
  *
  * <p>This class currently pins a certificate's Subject Public Key Info as described on <a
- * href="http://goo.gl/AIx3e5">Adam Langley's Weblog</a>. Pins are base-64 SHA-1 hashes, consistent
- * with the format Chromium uses for <a href="http://goo.gl/XDh6je">static certificates</a>. See
- * Chromium's <a href="http://goo.gl/4CCnGs">pinsets</a> for hostnames that are pinned in that
- * browser.
+ * href="http://goo.gl/AIx3e5">Adam Langley's Weblog</a>. Pins are either base64 SHA-256 hashes as
+ * in <a href="http://tools.ietf.org/html/rfc7469">HTTP Public Key Pinning (HPKP)</a> or SHA-1
+ * base64 hashes as in Chromium's <a href="http://goo.gl/XDh6je">static certificates</a>.
  *
  * <h3>Setting up Certificate Pinning</h3>
  *
@@ -54,7 +49,7 @@
  *
  *     String hostname = "publicobject.com";
  *     CertificatePinner certificatePinner = new CertificatePinner.Builder()
- *         .add(hostname, "sha1/AAAAAAAAAAAAAAAAAAAAAAAAAAA=")
+ *         .add(hostname, "sha256/AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA=")
  *         .build();
  *     OkHttpClient client = new OkHttpClient();
  *     client.setCertificatePinner(certificatePinner);
@@ -69,12 +64,12 @@
  *
  * javax.net.ssl.SSLPeerUnverifiedException: Certificate pinning failure!
  *   Peer certificate chain:
- *     sha1/DmxUShsZuNiqPQsX2Oi9uv2sCnw=: CN=publicobject.com, OU=PositiveSSL
- *     sha1/SXxoaOSEzPC6BgGmxAt/EAcsajw=: CN=COMODO RSA Domain Validation Secure Server CA
- *     sha1/blhOM3W9V/bVQhsWAcLYwPU6n24=: CN=COMODO RSA Certification Authority
- *     sha1/T5x9IXmcrQ7YuQxXnxoCmeeQ84c=: CN=AddTrust External CA Root
+ *     sha256/afwiKY3RxoMmLkuRW1l7QsPZTJPwDS2pdDROQjXw8ig=: CN=publicobject.com, OU=PositiveSSL
+ *     sha256/klO23nT2ehFDXCfx3eHTDRESMz3asj1muO+4aIdjiuY=: CN=COMODO RSA Secure Server CA
+ *     sha256/grX4Ta9HpZx6tSHkmCrvpApTQGo67CYDnvprLg5yRME=: CN=COMODO RSA Certification Authority
+ *     sha256/lCppFqbkrlJ3EcVFAkeip0+44VaoJUymbnOaEUk7tEU=: CN=AddTrust External CA Root
  *   Pinned certificates for publicobject.com:
- *     sha1/AAAAAAAAAAAAAAAAAAAAAAAAAAA=
+ *     sha256/AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA=
  *   at okhttp3.CertificatePinner.check(CertificatePinner.java)
  *   at okhttp3.Connection.upgradeToTls(Connection.java)
  *   at okhttp3.Connection.connect(Connection.java)
@@ -85,10 +80,10 @@
  * certificate pinner's configuration: <pre>   {@code
  *
  *     CertificatePinner certificatePinner = new CertificatePinner.Builder()
- *       .add("publicobject.com", "sha1/DmxUShsZuNiqPQsX2Oi9uv2sCnw=")
- *       .add("publicobject.com", "sha1/SXxoaOSEzPC6BgGmxAt/EAcsajw=")
- *       .add("publicobject.com", "sha1/blhOM3W9V/bVQhsWAcLYwPU6n24=")
- *       .add("publicobject.com", "sha1/T5x9IXmcrQ7YuQxXnxoCmeeQ84c=")
+ *       .add("publicobject.com", "sha256/afwiKY3RxoMmLkuRW1l7QsPZTJPwDS2pdDROQjXw8ig=")
+ *       .add("publicobject.com", "sha256/klO23nT2ehFDXCfx3eHTDRESMz3asj1muO+4aIdjiuY=")
+ *       .add("publicobject.com", "sha256/grX4Ta9HpZx6tSHkmCrvpApTQGo67CYDnvprLg5yRME=")
+ *       .add("publicobject.com", "sha256/lCppFqbkrlJ3EcVFAkeip0+44VaoJUymbnOaEUk7tEU=")
  *       .build();
  * }</pre>
  *
@@ -129,11 +124,11 @@
 public final class CertificatePinner {
   public static final CertificatePinner DEFAULT = new Builder().build();
 
-  private final Map<String, Set<ByteString>> hostnameToPins;
+  private final List<Pin> pins;
   private final TrustRootIndex trustRootIndex;
 
   private CertificatePinner(Builder builder) {
-    this.hostnameToPins = Util.immutableMap(builder.hostnameToPins);
+    this.pins = Util.immutableList(builder.pins);
     this.trustRootIndex = builder.trustRootIndex;
   }
 
@@ -147,31 +142,47 @@ private CertificatePinner(Builder builder) {
    */
   public void check(String hostname, List<Certificate> peerCertificates)
       throws SSLPeerUnverifiedException {
-    Set<ByteString> pins = findMatchingPins(hostname);
-
-    if (pins == null) return;
+    List<Pin> pins = findMatchingPins(hostname);
+    if (pins.isEmpty()) return;
 
     if (trustRootIndex != null) {
       peerCertificates = new CertificateChainCleaner(trustRootIndex).clean(peerCertificates);
     }
 
-    for (int i = 0, size = peerCertificates.size(); i < size; i++) {
-      X509Certificate x509Certificate = (X509Certificate) peerCertificates.get(i);
-      if (pins.contains(sha1(x509Certificate))) return; // Success!
+    for (int c = 0, certsSize = peerCertificates.size(); c < certsSize; c++) {
+      X509Certificate x509Certificate = (X509Certificate) peerCertificates.get(c);
+
+      // Lazily compute the hashes for each certificate.
+      ByteString sha1 = null;
+      ByteString sha256 = null;
+
+      for (int p = 0, pinsSize = pins.size(); p < pinsSize; p++) {
+        Pin pin = pins.get(p);
+        if (pin.hashAlgorithm.equals("sha256/")) {
+          if (sha256 == null) sha256 = sha256(x509Certificate);
+          if (pin.hash.equals(sha256)) return; // Success!
+        } else if (pin.hashAlgorithm.equals("sha1/")) {
+          if (sha1 == null) sha1 = sha1(x509Certificate);
+          if (pin.hash.equals(sha1)) return; // Success!
+        } else {
+          throw new AssertionError();
+        }
+      }
     }
 
     // If we couldn't find a matching pin, format a nice exception.
     StringBuilder message = new StringBuilder()
         .append("Certificate pinning failure!")
         .append("\n  Peer certificate chain:");
-    for (int i = 0, size = peerCertificates.size(); i < size; i++) {
-      X509Certificate x509Certificate = (X509Certificate) peerCertificates.get(i);
+    for (int c = 0, certsSize = peerCertificates.size(); c < certsSize; c++) {
+      X509Certificate x509Certificate = (X509Certificate) peerCertificates.get(c);
       message.append("\n    ").append(pin(x509Certificate))
           .append(": ").append(x509Certificate.getSubjectDN().getName());
     }
     message.append("\n  Pinned certificates for ").append(hostname).append(":");
-    for (ByteString pin : pins) {
-      message.append("\n    sha1/").append(pin.base64());
+    for (int p = 0, pinsSize = pins.size(); p < pinsSize; p++) {
+      Pin pin = pins.get(p);
+      message.append("\n    ").append(pin);
     }
     throw new SSLPeerUnverifiedException(message.toString());
   }
@@ -183,36 +194,18 @@ public void check(String hostname, Certificate... peerCertificates)
   }
 
   /**
-   * Returns list of matching certificates' pins for the hostname or {@code null} if hostname does
-   * not have pinned certificates.
+   * Returns list of matching certificates' pins for the hostname. Returns an empty list if the
+   * hostname does not have pinned certificates.
    */
-  Set<ByteString> findMatchingPins(String hostname) {
-    Set<ByteString> directPins = hostnameToPins.get(hostname);
-    Set<ByteString> wildcardPins = null;
-
-    int indexOfFirstDot = hostname.indexOf('.');
-    int indexOfLastDot = hostname.lastIndexOf('.');
-
-    // Skip hostnames with one dot symbol for wildcard pattern search
-    //   example.com   will  be skipped
-    //   a.example.com won't be skipped
-    if (indexOfFirstDot != indexOfLastDot) {
-      // a.example.com -> search for wildcard pattern *.example.com
-      wildcardPins = hostnameToPins.get("*." + hostname.substring(indexOfFirstDot + 1));
-    }
-
-    if (directPins == null && wildcardPins == null) return null;
-
-    if (directPins != null && wildcardPins != null) {
-      Set<ByteString> pins = new LinkedHashSet<>();
-      pins.addAll(directPins);
-      pins.addAll(wildcardPins);
-      return pins;
+  List<Pin> findMatchingPins(String hostname) {
+    List<Pin> result = Collections.emptyList();
+    for (Pin pin : pins) {
+      if (pin.matches(hostname)) {
+        if (result.isEmpty()) result = new ArrayList<>();
+        result.add(pin);
+      }
     }
-
-    if (directPins != null) return directPins;
-
-    return wildcardPins;
+    return result;
   }
 
   Builder newBuilder() {
@@ -220,31 +213,89 @@ Builder newBuilder() {
   }
 
   /**
-   * Returns the SHA-1 of {@code certificate}'s public key. This uses the mechanism Moxie
-   * Marlinspike describes in <a href="https://github.com/moxie0/AndroidPinning">Android
-   * Pinning</a>.
+   * Returns the SHA-256 of {@code certificate}'s public key.
+   *
+   * <p>In OkHttp 3.1.2 and earlier, this returned a SHA-1 hash of the public key. Both types are
+   * supported, but SHA-256 is preferred.
    */
   public static String pin(Certificate certificate) {
     if (!(certificate instanceof X509Certificate)) {
       throw new IllegalArgumentException("Certificate pinning requires X509 certificates");
     }
-    return "sha1/" + sha1((X509Certificate) certificate).base64();
+    return "sha256/" + sha256((X509Certificate) certificate).base64();
   }
 
-  private static ByteString sha1(X509Certificate x509Certificate) {
+  static ByteString sha1(X509Certificate x509Certificate) {
     return Util.sha1(ByteString.of(x509Certificate.getPublicKey().getEncoded()));
   }
 
+  static ByteString sha256(X509Certificate x509Certificate) {
+    return Util.sha256(ByteString.of(x509Certificate.getPublicKey().getEncoded()));
+  }
+
+  static final class Pin {
+    /** A hostname like {@code example.com} or a pattern like {@code *.example.com}. */
+    final String pattern;
+    /** Either {@code sha1/} or {@code sha256/}. */
+    final String hashAlgorithm;
+    /** The hash of the pinned certificate using {@link #hashAlgorithm}. */
+    final ByteString hash;
+
+    Pin(String pattern, String pin) {
+      this.pattern = pattern;
+      if (pin.startsWith("sha1/")) {
+        this.hashAlgorithm = "sha1/";
+        this.hash = ByteString.decodeBase64(pin.substring("sha1/".length()));
+      } else if (pin.startsWith("sha256/")) {
+        this.hashAlgorithm = "sha256/";
+        this.hash = ByteString.decodeBase64(pin.substring("sha256/".length()));
+      } else {
+        throw new IllegalArgumentException("pins must start with 'sha256/' or 'sha1/': " + pin);
+      }
+
+      if (this.hash == null) {
+        throw new IllegalArgumentException("pins must be base64: " + pin);
+      }
+    }
+
+    boolean matches(String hostname) {
+      if (pattern.equals(hostname)) return true;
+
+      int firstDot = hostname.indexOf('.');
+      return pattern.startsWith("*.")
+          && hostname.regionMatches(false, firstDot + 1, pattern, 2, pattern.length() - 2);
+    }
+
+    @Override public boolean equals(Object other) {
+      return other instanceof Pin
+          && pattern.equals(((Pin) other).pattern)
+          && hashAlgorithm.equals(((Pin) other).hashAlgorithm)
+          && hash.equals(((Pin) other).hash);
+    }
+
+    @Override public int hashCode() {
+      int result = 17;
+      result = 31 * result + pattern.hashCode();
+      result = 31 * result + hashAlgorithm.hashCode();
+      result = 31 * result + hash.hashCode();
+      return result;
+    }
+
+    @Override public String toString() {
+      return hashAlgorithm + hash.base64();
+    }
+  }
+
   /** Builds a configured certificate pinner. */
   public static final class Builder {
-    private final Map<String, Set<ByteString>> hostnameToPins = new LinkedHashMap<>();
+    private final List<Pin> pins = new ArrayList<>();
     private TrustRootIndex trustRootIndex;
 
     public Builder() {
     }
 
     Builder(CertificatePinner certificatePinner) {
-      this.hostnameToPins.putAll(certificatePinner.hostnameToPins);
+      this.pins.addAll(certificatePinner.pins);
       this.trustRootIndex = certificatePinner.trustRootIndex;
     }
 
@@ -254,30 +305,17 @@ public Builder trustRootIndex(TrustRootIndex trustRootIndex) {
     }
 
     /**
-     * Pins certificates for {@code hostname}.
+     * Pins certificates for {@code pattern}.
      *
-     * @param hostname lower-case host name or wildcard pattern such as {@code *.example.com}.
-     * @param pins SHA-1 hashes. Each pin is a SHA-1 hash of a certificate's Subject Public Key
-     * Info, base64-encoded and prefixed with {@code sha1/}.
+     * @param pattern lower-case host name or wildcard pattern such as {@code *.example.com}.
+     * @param pins SHA-256 or SHA-1 hashes. Each pin is a hash of a certificate's Subject Public Key
+     * Info, base64-encoded and prefixed with either {@code sha256/} or {@code sha1/}.
      */
-    public Builder add(String hostname, String... pins) {
-      if (hostname == null) throw new IllegalArgumentException("hostname == null");
-
-      Set<ByteString> hostPins = new LinkedHashSet<>();
-      Set<ByteString> previousPins = hostnameToPins.put(hostname, unmodifiableSet(hostPins));
-      if (previousPins != null) {
-        hostPins.addAll(previousPins);
-      }
+    public Builder add(String pattern, String... pins) {
+      if (pattern == null) throw new NullPointerException("pattern == null");
 
       for (String pin : pins) {
-        if (!pin.startsWith("sha1/")) {
-          throw new IllegalArgumentException("pins must start with 'sha1/': " + pin);
-        }
-        ByteString decodedPin = ByteString.decodeBase64(pin.substring("sha1/".length()));
-        if (decodedPin == null) {
-          throw new IllegalArgumentException("pins must be base64: " + pin);
-        }
-        hostPins.add(decodedPin);
+        this.pins.add(new Pin(pattern, pin));
       }
 
       return this;
diff --git a/okhttp/src/main/java/okhttp3/Cookie.java b/okhttp/src/main/java/okhttp3/Cookie.java
index 74e341de4d..29a4bf84d1 100644
--- a/okhttp/src/main/java/okhttp3/Cookie.java
+++ b/okhttp/src/main/java/okhttp3/Cookie.java
@@ -75,9 +75,9 @@ private Cookie(String name, String value, long expiresAt, String domain, String
   }
 
   private Cookie(Builder builder) {
-    if (builder.name == null) throw new IllegalArgumentException("builder.name == null");
-    if (builder.value == null) throw new IllegalArgumentException("builder.value == null");
-    if (builder.domain == null) throw new IllegalArgumentException("builder.domain == null");
+    if (builder.name == null) throw new NullPointerException("builder.name == null");
+    if (builder.value == null) throw new NullPointerException("builder.value == null");
+    if (builder.domain == null) throw new NullPointerException("builder.domain == null");
 
     this.name = builder.name;
     this.value = builder.value;
@@ -498,7 +498,7 @@ public Builder hostOnlyDomain(String domain) {
     }
 
     private Builder domain(String domain, boolean hostOnly) {
-      if (domain == null) throw new IllegalArgumentException("domain == null");
+      if (domain == null) throw new NullPointerException("domain == null");
       String canonicalDomain = Util.domainToAscii(domain);
       if (canonicalDomain == null) {
         throw new IllegalArgumentException("unexpected domain: " + domain);
diff --git a/okhttp/src/main/java/okhttp3/Handshake.java b/okhttp/src/main/java/okhttp3/Handshake.java
index 56e1fd4a2e..d2c08be57e 100644
--- a/okhttp/src/main/java/okhttp3/Handshake.java
+++ b/okhttp/src/main/java/okhttp3/Handshake.java
@@ -74,7 +74,7 @@ public static Handshake get(SSLSession session) {
 
   public static Handshake get(TlsVersion tlsVersion, CipherSuite cipherSuite,
       List<Certificate> peerCertificates, List<Certificate> localCertificates) {
-    if (cipherSuite == null) throw new IllegalArgumentException("cipherSuite == null");
+    if (cipherSuite == null) throw new NullPointerException("cipherSuite == null");
     return new Handshake(tlsVersion, cipherSuite, Util.immutableList(peerCertificates),
         Util.immutableList(localCertificates));
   }
diff --git a/okhttp/src/main/java/okhttp3/Headers.java b/okhttp/src/main/java/okhttp3/Headers.java
index 6f72d0cc4d..992569a501 100644
--- a/okhttp/src/main/java/okhttp3/Headers.java
+++ b/okhttp/src/main/java/okhttp3/Headers.java
@@ -148,7 +148,8 @@ private static String get(String[] namesAndValues, String name) {
    * arguments, and they must alternate between header names and values.
    */
   public static Headers of(String... namesAndValues) {
-    if (namesAndValues == null || namesAndValues.length % 2 != 0) {
+    if (namesAndValues == null) throw new NullPointerException("namesAndValues == null");
+    if (namesAndValues.length % 2 != 0) {
       throw new IllegalArgumentException("Expected alternating header names and values");
     }
 
@@ -175,9 +176,7 @@ public static Headers of(String... namesAndValues) {
    * Returns headers for the header names and values in the {@link Map}.
    */
   public static Headers of(Map<String, String> headers) {
-    if (headers == null) {
-      throw new IllegalArgumentException("Expected map with header names and values");
-    }
+    if (headers == null) throw new NullPointerException("headers == null");
 
     // Make a defensive copy and clean it up.
     String[] namesAndValues = new String[headers.size() * 2];
@@ -267,7 +266,7 @@ public Builder set(String name, String value) {
     }
 
     private void checkNameAndValue(String name, String value) {
-      if (name == null) throw new IllegalArgumentException("name == null");
+      if (name == null) throw new NullPointerException("name == null");
       if (name.isEmpty()) throw new IllegalArgumentException("name is empty");
       for (int i = 0, length = name.length(); i < length; i++) {
         char c = name.charAt(i);
@@ -276,7 +275,7 @@ private void checkNameAndValue(String name, String value) {
               "Unexpected char %#04x at %d in header name: %s", (int) c, i, name));
         }
       }
-      if (value == null) throw new IllegalArgumentException("value == null");
+      if (value == null) throw new NullPointerException("value == null");
       for (int i = 0, length = value.length(); i < length; i++) {
         char c = value.charAt(i);
         if (c <= '\u001f' || c >= '\u007f') {
diff --git a/okhttp/src/main/java/okhttp3/HttpUrl.java b/okhttp/src/main/java/okhttp3/HttpUrl.java
index 59cbdd4350..45effb8f6d 100644
--- a/okhttp/src/main/java/okhttp3/HttpUrl.java
+++ b/okhttp/src/main/java/okhttp3/HttpUrl.java
@@ -707,7 +707,7 @@ public Builder() {
 
     public Builder scheme(String scheme) {
       if (scheme == null) {
-        throw new IllegalArgumentException("scheme == null");
+        throw new NullPointerException("scheme == null");
       } else if (scheme.equalsIgnoreCase("http")) {
         this.scheme = "http";
       } else if (scheme.equalsIgnoreCase("https")) {
@@ -719,26 +719,26 @@ public Builder scheme(String scheme) {
     }
 
     public Builder username(String username) {
-      if (username == null) throw new IllegalArgumentException("username == null");
+      if (username == null) throw new NullPointerException("username == null");
       this.encodedUsername = canonicalize(username, USERNAME_ENCODE_SET, false, false, false, true);
       return this;
     }
 
     public Builder encodedUsername(String encodedUsername) {
-      if (encodedUsername == null) throw new IllegalArgumentException("encodedUsername == null");
+      if (encodedUsername == null) throw new NullPointerException("encodedUsername == null");
       this.encodedUsername = canonicalize(
           encodedUsername, USERNAME_ENCODE_SET, true, false, false, true);
       return this;
     }
 
     public Builder password(String password) {
-      if (password == null) throw new IllegalArgumentException("password == null");
+      if (password == null) throw new NullPointerException("password == null");
       this.encodedPassword = canonicalize(password, PASSWORD_ENCODE_SET, false, false, false, true);
       return this;
     }
 
     public Builder encodedPassword(String encodedPassword) {
-      if (encodedPassword == null) throw new IllegalArgumentException("encodedPassword == null");
+      if (encodedPassword == null) throw new NullPointerException("encodedPassword == null");
       this.encodedPassword = canonicalize(
           encodedPassword, PASSWORD_ENCODE_SET, true, false, false, true);
       return this;
@@ -749,7 +749,7 @@ public Builder encodedPassword(String encodedPassword) {
      * address.
      */
     public Builder host(String host) {
-      if (host == null) throw new IllegalArgumentException("host == null");
+      if (host == null) throw new NullPointerException("host == null");
       String encoded = canonicalizeHost(host, 0, host.length());
       if (encoded == null) throw new IllegalArgumentException("unexpected host: " + host);
       this.host = encoded;
@@ -767,21 +767,53 @@ int effectivePort() {
     }
 
     public Builder addPathSegment(String pathSegment) {
-      if (pathSegment == null) throw new IllegalArgumentException("pathSegment == null");
+      if (pathSegment == null) throw new NullPointerException("pathSegment == null");
       push(pathSegment, 0, pathSegment.length(), false, false);
       return this;
     }
 
+    /**
+     * Adds a set of path segments separated by a slash (either {@code \} or {@code /}). If
+     * {@code pathSegments} starts with a slash, the resulting URL will have empty path segment.
+     */
+    public Builder addPathSegments(String pathSegments) {
+      if (pathSegments == null) throw new NullPointerException("pathSegments == null");
+      return addPathSegments(pathSegments, false);
+    }
+
     public Builder addEncodedPathSegment(String encodedPathSegment) {
       if (encodedPathSegment == null) {
-        throw new IllegalArgumentException("encodedPathSegment == null");
+        throw new NullPointerException("encodedPathSegment == null");
       }
       push(encodedPathSegment, 0, encodedPathSegment.length(), false, true);
       return this;
     }
 
+    /**
+     * Adds a set of encoded path segments separated by a slash (either {@code \} or {@code /}). If
+     * {@code encodedPathSegments} starts with a slash, the resulting URL will have empty path
+     * segment.
+     */
+    public Builder addEncodedPathSegments(String encodedPathSegments) {
+      if (encodedPathSegments == null) {
+        throw new NullPointerException("encodedPathSegments == null");
+      }
+      return addPathSegments(encodedPathSegments, true);
+    }
+
+    private Builder addPathSegments(String pathSegments, boolean alreadyEncoded) {
+      int offset = 0;
+      do {
+        int segmentEnd = delimiterOffset(pathSegments, offset, pathSegments.length(), "/\\");
+        boolean addTrailingSlash = segmentEnd < pathSegments.length();
+        push(pathSegments, offset, segmentEnd, addTrailingSlash, alreadyEncoded);
+        offset = segmentEnd + 1;
+      } while (offset <= pathSegments.length());
+      return this;
+    }
+
     public Builder setPathSegment(int index, String pathSegment) {
-      if (pathSegment == null) throw new IllegalArgumentException("pathSegment == null");
+      if (pathSegment == null) throw new NullPointerException("pathSegment == null");
       String canonicalPathSegment = canonicalize(
           pathSegment, 0, pathSegment.length(), PATH_SEGMENT_ENCODE_SET, false, false, false, true);
       if (isDot(canonicalPathSegment) || isDotDot(canonicalPathSegment)) {
@@ -793,7 +825,7 @@ public Builder setPathSegment(int index, String pathSegment) {
 
     public Builder setEncodedPathSegment(int index, String encodedPathSegment) {
       if (encodedPathSegment == null) {
-        throw new IllegalArgumentException("encodedPathSegment == null");
+        throw new NullPointerException("encodedPathSegment == null");
       }
       String canonicalPathSegment = canonicalize(encodedPathSegment,
           0, encodedPathSegment.length(), PATH_SEGMENT_ENCODE_SET, true, false, false, true);
@@ -813,7 +845,7 @@ public Builder removePathSegment(int index) {
     }
 
     public Builder encodedPath(String encodedPath) {
-      if (encodedPath == null) throw new IllegalArgumentException("encodedPath == null");
+      if (encodedPath == null) throw new NullPointerException("encodedPath == null");
       if (!encodedPath.startsWith("/")) {
         throw new IllegalArgumentException("unexpected encodedPath: " + encodedPath);
       }
@@ -839,7 +871,7 @@ public Builder encodedQuery(String encodedQuery) {
 
     /** Encodes the query parameter using UTF-8 and adds it to this URL's query string. */
     public Builder addQueryParameter(String name, String value) {
-      if (name == null) throw new IllegalArgumentException("name == null");
+      if (name == null) throw new NullPointerException("name == null");
       if (encodedQueryNamesAndValues == null) encodedQueryNamesAndValues = new ArrayList<>();
       encodedQueryNamesAndValues.add(
           canonicalize(name, QUERY_COMPONENT_ENCODE_SET, false, false, true, true));
@@ -851,7 +883,7 @@ public Builder addQueryParameter(String name, String value) {
 
     /** Adds the pre-encoded query parameter to this URL's query string. */
     public Builder addEncodedQueryParameter(String encodedName, String encodedValue) {
-      if (encodedName == null) throw new IllegalArgumentException("encodedName == null");
+      if (encodedName == null) throw new NullPointerException("encodedName == null");
       if (encodedQueryNamesAndValues == null) encodedQueryNamesAndValues = new ArrayList<>();
       encodedQueryNamesAndValues.add(
           canonicalize(encodedName, QUERY_COMPONENT_ENCODE_SET, true, false, true, true));
@@ -874,7 +906,7 @@ public Builder setEncodedQueryParameter(String encodedName, String encodedValue)
     }
 
     public Builder removeAllQueryParameters(String name) {
-      if (name == null) throw new IllegalArgumentException("name == null");
+      if (name == null) throw new NullPointerException("name == null");
       if (encodedQueryNamesAndValues == null) return this;
       String nameToRemove = canonicalize(
           name, QUERY_COMPONENT_ENCODE_SET, false, false, true, true);
@@ -883,7 +915,7 @@ public Builder removeAllQueryParameters(String name) {
     }
 
     public Builder removeAllEncodedQueryParameters(String encodedName) {
-      if (encodedName == null) throw new IllegalArgumentException("encodedName == null");
+      if (encodedName == null) throw new NullPointerException("encodedName == null");
       if (encodedQueryNamesAndValues == null) return this;
       removeAllCanonicalQueryParameters(
           canonicalize(encodedName, QUERY_COMPONENT_ENCODE_SET, true, false, true, true));
@@ -1270,9 +1302,12 @@ private static String canonicalizeHost(String input, int pos, int limit) {
       // checked for IPv6 square braces. But Chrome does it first, and that's more lenient.
       String percentDecoded = percentDecode(input, pos, limit, false);
 
-      // If the input is encased in square braces "[...]", drop 'em. We have an IPv6 address.
-      if (percentDecoded.startsWith("[") && percentDecoded.endsWith("]")) {
-        InetAddress inetAddress = decodeIpv6(percentDecoded, 1, percentDecoded.length() - 1);
+      // If the input contains a :, it’s an IPv6 address.
+      if (percentDecoded.contains(":")) {
+        // If the input is encased in square braces "[...]", drop 'em.
+        InetAddress inetAddress = percentDecoded.startsWith("[") && percentDecoded.endsWith("]")
+            ? decodeIpv6(percentDecoded, 1, percentDecoded.length() - 1)
+            : decodeIpv6(percentDecoded, 0, percentDecoded.length());
         if (inetAddress == null) return null;
         byte[] address = inetAddress.getAddress();
         if (address.length == 16) return inet6AddressToAscii(address);
diff --git a/okhttp/src/main/java/okhttp3/OkHttpClient.java b/okhttp/src/main/java/okhttp3/OkHttpClient.java
index 4d5cbce187..3930c75c10 100644
--- a/okhttp/src/main/java/okhttp3/OkHttpClient.java
+++ b/okhttp/src/main/java/okhttp3/OkHttpClient.java
@@ -410,7 +410,7 @@ public Builder() {
      */
     public Builder connectTimeout(long timeout, TimeUnit unit) {
       if (timeout < 0) throw new IllegalArgumentException("timeout < 0");
-      if (unit == null) throw new IllegalArgumentException("unit == null");
+      if (unit == null) throw new NullPointerException("unit == null");
       long millis = unit.toMillis(timeout);
       if (millis > Integer.MAX_VALUE) throw new IllegalArgumentException("Timeout too large.");
       if (millis == 0 && timeout > 0) throw new IllegalArgumentException("Timeout too small.");
@@ -424,7 +424,7 @@ public Builder connectTimeout(long timeout, TimeUnit unit) {
      */
     public Builder readTimeout(long timeout, TimeUnit unit) {
       if (timeout < 0) throw new IllegalArgumentException("timeout < 0");
-      if (unit == null) throw new IllegalArgumentException("unit == null");
+      if (unit == null) throw new NullPointerException("unit == null");
       long millis = unit.toMillis(timeout);
       if (millis > Integer.MAX_VALUE) throw new IllegalArgumentException("Timeout too large.");
       if (millis == 0 && timeout > 0) throw new IllegalArgumentException("Timeout too small.");
@@ -438,7 +438,7 @@ public Builder readTimeout(long timeout, TimeUnit unit) {
      */
     public Builder writeTimeout(long timeout, TimeUnit unit) {
       if (timeout < 0) throw new IllegalArgumentException("timeout < 0");
-      if (unit == null) throw new IllegalArgumentException("unit == null");
+      if (unit == null) throw new NullPointerException("unit == null");
       long millis = unit.toMillis(timeout);
       if (millis > Integer.MAX_VALUE) throw new IllegalArgumentException("Timeout too large.");
       if (millis == 0 && timeout > 0) throw new IllegalArgumentException("Timeout too small.");
diff --git a/okhttp/src/main/java/okhttp3/Request.java b/okhttp/src/main/java/okhttp3/Request.java
index 2daa0ab9b3..194e855c1e 100644
--- a/okhttp/src/main/java/okhttp3/Request.java
+++ b/okhttp/src/main/java/okhttp3/Request.java
@@ -118,7 +118,7 @@ private Builder(Request request) {
     }
 
     public Builder url(HttpUrl url) {
-      if (url == null) throw new IllegalArgumentException("url == null");
+      if (url == null) throw new NullPointerException("url == null");
       this.url = url;
       return this;
     }
@@ -130,7 +130,7 @@ public Builder url(HttpUrl url) {
      * exception by calling {@link HttpUrl#parse}; it returns null for invalid URLs.
      */
     public Builder url(String url) {
-      if (url == null) throw new IllegalArgumentException("url == null");
+      if (url == null) throw new NullPointerException("url == null");
 
       // Silently replace websocket URLs with HTTP URLs.
       if (url.regionMatches(true, 0, "ws:", 0, 3)) {
@@ -151,7 +151,7 @@ public Builder url(String url) {
      * https}.
      */
     public Builder url(URL url) {
-      if (url == null) throw new IllegalArgumentException("url == null");
+      if (url == null) throw new NullPointerException("url == null");
       HttpUrl parsed = HttpUrl.get(url);
       if (parsed == null) throw new IllegalArgumentException("unexpected url: " + url);
       return url(parsed);
@@ -229,9 +229,8 @@ public Builder patch(RequestBody body) {
     }
 
     public Builder method(String method, RequestBody body) {
-      if (method == null || method.length() == 0) {
-        throw new IllegalArgumentException("method == null || method.length() == 0");
-      }
+      if (method == null) throw new NullPointerException("method == null");
+      if (method.length() == 0) throw new IllegalArgumentException("method.length() == 0");
       if (body != null && !HttpMethod.permitsRequestBody(method)) {
         throw new IllegalArgumentException("method " + method + " must not have a request body.");
       }
diff --git a/okhttp/src/main/java/okhttp3/internal/DiskLruCache.java b/okhttp/src/main/java/okhttp3/internal/DiskLruCache.java
index 25e12eeb92..1be6a93b4f 100644
--- a/okhttp/src/main/java/okhttp3/internal/DiskLruCache.java
+++ b/okhttp/src/main/java/okhttp3/internal/DiskLruCache.java
@@ -151,6 +151,7 @@
   // Must be read and written when synchronized on 'this'.
   private boolean initialized;
   private boolean closed;
+  private boolean mostRecentTrimFailed;
 
   /**
    * To differentiate between old and current snapshots, each entry is given a sequence number each
@@ -167,8 +168,14 @@ public void run() {
         if (!initialized | closed) {
           return; // Nothing to do
         }
+
         try {
           trimToSize();
+        } catch (IOException ignored) {
+          mostRecentTrimFailed = true;
+        }
+
+        try {
           if (journalRebuildRequired()) {
             rebuildJournal();
             redundantOpCount = 0;
@@ -453,6 +460,11 @@ private synchronized Editor edit(String key, long expectedSequenceNumber) throws
     if (entry != null && entry.currentEditor != null) {
       return null; // Another edit is in progress.
     }
+    if (mostRecentTrimFailed) {
+      // Prevent new writes so the cache doesn't grow any further and retry the clean up operation.
+      executor.execute(cleanupRunnable);
+      return null;
+    }
 
     // Flush the journal before creating files to prevent file leaks.
     journalWriter.writeUtf8(DIRTY).writeByte(' ').writeUtf8(key).writeByte('\n');
@@ -586,7 +598,9 @@ public synchronized boolean remove(String key) throws IOException {
     validateKey(key);
     Entry entry = lruEntries.get(key);
     if (entry == null) return false;
-    return removeEntry(entry);
+    boolean removed = removeEntry(entry);
+    if (removed && size <= maxSize) mostRecentTrimFailed = false;
+    return removed;
   }
 
   private boolean removeEntry(Entry entry) throws IOException {
@@ -654,6 +668,7 @@ private void trimToSize() throws IOException {
       Entry toEvict = lruEntries.values().iterator().next();
       removeEntry(toEvict);
     }
+    mostRecentTrimFailed = false;
   }
 
   /**
@@ -675,6 +690,7 @@ public synchronized void evictAll() throws IOException {
     for (Entry entry : lruEntries.values().toArray(new Entry[lruEntries.size()])) {
       removeEntry(entry);
     }
+    mostRecentTrimFailed = false;
   }
 
   private void validateKey(String key) {
diff --git a/okhttp/src/main/java/okhttp3/internal/Util.java b/okhttp/src/main/java/okhttp3/internal/Util.java
index e9efad04c6..4dc139f4fb 100644
--- a/okhttp/src/main/java/okhttp3/internal/Util.java
+++ b/okhttp/src/main/java/okhttp3/internal/Util.java
@@ -223,6 +223,17 @@ public static ByteString sha1(ByteString s) {
     }
   }
 
+  /** Returns a SHA-256 hash of {@code s}. */
+  public static ByteString sha256(ByteString s) {
+    try {
+      MessageDigest messageDigest = MessageDigest.getInstance("SHA-256");
+      byte[] sha1Bytes = messageDigest.digest(s.toByteArray());
+      return ByteString.of(sha1Bytes);
+    } catch (NoSuchAlgorithmException e) {
+      throw new AssertionError(e);
+    }
+  }
+
   /** Returns an immutable copy of {@code list}. */
   public static <T> List<T> immutableList(List<T> list) {
     return Collections.unmodifiableList(new ArrayList<>(list));
@@ -275,11 +286,13 @@ public static ThreadFactory threadFactory(final String name, final boolean daemo
     return result;
   }
 
-  public static String hostHeader(HttpUrl url) {
-    // TODO: square braces for IPv6 ?
-    return url.port() != HttpUrl.defaultPort(url.scheme())
-        ? url.host() + ":" + url.port()
+  public static String hostHeader(HttpUrl url, boolean includeDefaultPort) {
+    String host = url.host().contains(":")
+        ? "[" + url.host() + "]"
         : url.host();
+    return includeDefaultPort || url.port() != HttpUrl.defaultPort(url.scheme())
+        ? host + ":" + url.port()
+        : host;
   }
 
   /** Returns {@code s} with control characters and non-ASCII characters replaced with '?'. */
diff --git a/okhttp/src/main/java/okhttp3/internal/http/Http2xStream.java b/okhttp/src/main/java/okhttp3/internal/http/Http2xStream.java
index 83cddc3e5a..99151f8371 100644
--- a/okhttp/src/main/java/okhttp3/internal/http/Http2xStream.java
+++ b/okhttp/src/main/java/okhttp3/internal/http/Http2xStream.java
@@ -161,7 +161,7 @@ public Http2xStream(StreamAllocation streamAllocation, FramedConnection framedCo
     result.add(new Header(TARGET_METHOD, request.method()));
     result.add(new Header(TARGET_PATH, RequestLine.requestPath(request.url())));
     result.add(new Header(VERSION, "HTTP/1.1"));
-    result.add(new Header(TARGET_HOST, Util.hostHeader(request.url())));
+    result.add(new Header(TARGET_HOST, Util.hostHeader(request.url(), false)));
     result.add(new Header(TARGET_SCHEME, request.url().scheme()));
 
     Set<ByteString> names = new LinkedHashSet<>();
@@ -200,7 +200,7 @@ private static String joinOnNull(String first, String second) {
     List<Header> result = new ArrayList<>(headers.size() + 4);
     result.add(new Header(TARGET_METHOD, request.method()));
     result.add(new Header(TARGET_PATH, RequestLine.requestPath(request.url())));
-    result.add(new Header(TARGET_AUTHORITY, Util.hostHeader(request.url()))); // Optional.
+    result.add(new Header(TARGET_AUTHORITY, Util.hostHeader(request.url(), false))); // Optional.
     result.add(new Header(TARGET_SCHEME, request.url().scheme()));
 
     for (int i = 0, size = headers.size(); i < size; i++) {
diff --git a/okhttp/src/main/java/okhttp3/internal/http/HttpEngine.java b/okhttp/src/main/java/okhttp3/internal/http/HttpEngine.java
index a4de543bc7..b7c9f6432f 100644
--- a/okhttp/src/main/java/okhttp3/internal/http/HttpEngine.java
+++ b/okhttp/src/main/java/okhttp3/internal/http/HttpEngine.java
@@ -502,7 +502,7 @@ private Request networkRequest(Request request) throws IOException {
     Request.Builder result = request.newBuilder();
 
     if (request.header("Host") == null) {
-      result.header("Host", hostHeader(request.url()));
+      result.header("Host", hostHeader(request.url(), false));
     }
 
     if (request.header("Connection") == null) {
diff --git a/okhttp/src/main/java/okhttp3/internal/io/FileSystem.java b/okhttp/src/main/java/okhttp3/internal/io/FileSystem.java
index 6a786954b3..0b1b1cfbc4 100644
--- a/okhttp/src/main/java/okhttp3/internal/io/FileSystem.java
+++ b/okhttp/src/main/java/okhttp3/internal/io/FileSystem.java
@@ -71,7 +71,7 @@
       }
     }
 
-    @Override public boolean exists(File file) throws IOException {
+    @Override public boolean exists(File file) {
       return file.exists();
     }
 
@@ -121,7 +121,7 @@
   void delete(File file) throws IOException;
 
   /** Returns true if {@code file} exists on the file system. */
-  boolean exists(File file) throws IOException;
+  boolean exists(File file);
 
   /** Returns the number of bytes stored in {@code file}, or 0 if it does not exist. */
   long size(File file);
diff --git a/okhttp/src/main/java/okhttp3/internal/io/RealConnection.java b/okhttp/src/main/java/okhttp3/internal/io/RealConnection.java
index e0fe6ccc7d..ed8019e2f6 100644
--- a/okhttp/src/main/java/okhttp3/internal/io/RealConnection.java
+++ b/okhttp/src/main/java/okhttp3/internal/io/RealConnection.java
@@ -241,7 +241,7 @@ private void createTunnel(int readTimeout, int writeTimeout) throws IOException
     // Make an SSL Tunnel on the first message pair of each SSL + proxy connection.
     Request tunnelRequest = createTunnelRequest();
     HttpUrl url = tunnelRequest.url();
-    String requestLine = "CONNECT " + url.host() + ":" + url.port() + " HTTP/1.1";
+    String requestLine = "CONNECT " + Util.hostHeader(url, true) + " HTTP/1.1";
     while (true) {
       Http1xStream tunnelConnection = new Http1xStream(null, source, sink);
       source.timeout().timeout(readTimeout, MILLISECONDS);
@@ -291,7 +291,7 @@ private void createTunnel(int readTimeout, int writeTimeout) throws IOException
   private Request createTunnelRequest() throws IOException {
     return new Request.Builder()
         .url(route.address().url())
-        .header("Host", Util.hostHeader(route.address().url()))
+        .header("Host", Util.hostHeader(route.address().url(), true))
         .header("Proxy-Connection", "Keep-Alive")
         .header("User-Agent", Version.userAgent()) // For HTTP/1.0 proxies like Squid.
         .build();
diff --git a/okhttp/src/main/java/okhttp3/internal/tls/AndroidTrustRootIndex.java b/okhttp/src/main/java/okhttp3/internal/tls/AndroidTrustRootIndex.java
index 3805939c1c..3074a1e98d 100644
--- a/okhttp/src/main/java/okhttp3/internal/tls/AndroidTrustRootIndex.java
+++ b/okhttp/src/main/java/okhttp3/internal/tls/AndroidTrustRootIndex.java
@@ -40,7 +40,9 @@ public AndroidTrustRootIndex(
     try {
       TrustAnchor trustAnchor = (TrustAnchor) findByIssuerAndSignatureMethod.invoke(
           trustManager, cert);
-      return trustAnchor.getTrustedCert();
+      return trustAnchor != null
+          ? trustAnchor.getTrustedCert()
+          : null;
     } catch (IllegalAccessException e) {
       throw new AssertionError();
     } catch (InvocationTargetException e) {
diff --git a/okhttp/src/main/java/okhttp3/internal/tls/CertificateChainCleaner.java b/okhttp/src/main/java/okhttp3/internal/tls/CertificateChainCleaner.java
index 0121aba30c..d887df615c 100644
--- a/okhttp/src/main/java/okhttp3/internal/tls/CertificateChainCleaner.java
+++ b/okhttp/src/main/java/okhttp3/internal/tls/CertificateChainCleaner.java
@@ -40,6 +40,9 @@
  * TrustManagerImpl} and {@code TrustedCertificateIndex}.
  */
 public final class CertificateChainCleaner {
+  /** The maximum number of signers in a chain. We use 9 for consistency with OpenSSL. */
+  private static final int MAX_SIGNERS = 9;
+
   private final TrustRootIndex trustRootIndex;
 
   public CertificateChainCleaner(TrustRootIndex trustRootIndex) {
@@ -57,40 +60,53 @@ public CertificateChainCleaner(TrustRootIndex trustRootIndex) {
     Deque<Certificate> queue = new ArrayDeque<>(chain);
     List<Certificate> result = new ArrayList<>();
     result.add(queue.removeFirst());
+    boolean foundTrustedCertificate = false;
 
     followIssuerChain:
-    while (true) {
+    for (int c = 0; c < MAX_SIGNERS; c++) {
       X509Certificate toVerify = (X509Certificate) result.get(result.size() - 1);
 
-      // If this cert has been signed by a trusted CA cert, we're done. Add the trusted CA
-      // certificate to the end of the chain, unless it's already present. (That would happen if the
-      // first certificate in the chain is itself a self-signed and trusted CA certificate.)
-      X509Certificate caCert = trustRootIndex.findByIssuerAndSignature(toVerify);
-      if (caCert != null) {
-        if (result.size() > 1 || !toVerify.equals(caCert)) {
-          result.add(caCert);
+      // If this cert has been signed by a trusted cert, use that. Add the trusted certificate to
+      // the end of the chain unless it's already present. (That would happen if the first
+      // certificate in the chain is itself a self-signed and trusted CA certificate.)
+      X509Certificate trustedCert = trustRootIndex.findByIssuerAndSignature(toVerify);
+      if (trustedCert != null) {
+        if (result.size() > 1 || !toVerify.equals(trustedCert)) {
+          result.add(trustedCert);
         }
-        return result;
+        if (verifySignature(trustedCert, trustedCert)) {
+          return result; // The self-signed cert is a root CA. We're done.
+        }
+        foundTrustedCertificate = true;
+        continue;
       }
 
       // Search for the certificate in the chain that signed this certificate. This is typically the
       // next element in the chain, but it could be any element.
       for (Iterator<Certificate> i = queue.iterator(); i.hasNext(); ) {
         X509Certificate signingCert = (X509Certificate) i.next();
-        if (toVerify.getIssuerDN().equals(signingCert.getSubjectDN())
-            && verifySignature(toVerify, signingCert)) {
+        if (verifySignature(toVerify, signingCert)) {
           i.remove();
           result.add(signingCert);
           continue followIssuerChain;
         }
       }
 
-      throw new SSLPeerUnverifiedException("Failed to find a cert that signed " + toVerify);
+      // We've reached the end of the chain. If any cert in the chain is trusted, we're done.
+      if (foundTrustedCertificate) {
+        return result;
+      }
+
+      // The last link isn't trusted. Fail.
+      throw new SSLPeerUnverifiedException("Failed to find a trusted cert that signed " + toVerify);
     }
+
+    throw new SSLPeerUnverifiedException("Certificate chain too long: " + result);
   }
 
   /** Returns true if {@code toVerify} was signed by {@code signingCert}'s public key. */
   private boolean verifySignature(X509Certificate toVerify, X509Certificate signingCert) {
+    if (!toVerify.getIssuerDN().equals(signingCert.getSubjectDN())) return false;
     try {
       toVerify.verify(signingCert.getPublicKey());
       return true;
diff --git a/pom.xml b/pom.xml
index 7eb918ac0c..52c283ed13 100644
--- a/pom.xml
+++ b/pom.xml
@@ -11,7 +11,7 @@
 
   <groupId>com.squareup.okhttp3</groupId>
   <artifactId>parent</artifactId>
-  <version>3.2.0-SNAPSHOT</version>
+  <version>3.3.0-SNAPSHOT</version>
   <packaging>pom</packaging>
 
   <name>OkHttp (Parent)</name>
@@ -52,7 +52,7 @@
     <bouncycastle.version>1.50</bouncycastle.version>
     <gson.version>2.2.3</gson.version>
     <apache.http.version>4.2.2</apache.http.version>
-    <airlift.version>0.6</airlift.version>
+    <airlift.version>0.7</airlift.version>
     <guava.version>16.0</guava.version>
     <android.version>4.1.1.4</android.version>
 
diff --git a/samples/crawler/pom.xml b/samples/crawler/pom.xml
index 80c803d86a..0daef2b940 100644
--- a/samples/crawler/pom.xml
+++ b/samples/crawler/pom.xml
@@ -6,7 +6,7 @@
   <parent>
     <groupId>com.squareup.okhttp3.sample</groupId>
     <artifactId>sample-parent</artifactId>
-    <version>3.2.0-SNAPSHOT</version>
+    <version>3.3.0-SNAPSHOT</version>
   </parent>
 
   <artifactId>crawler</artifactId>
diff --git a/samples/guide/pom.xml b/samples/guide/pom.xml
index b2d38e5fb6..cb497502f2 100644
--- a/samples/guide/pom.xml
+++ b/samples/guide/pom.xml
@@ -6,7 +6,7 @@
   <parent>
     <groupId>com.squareup.okhttp3.sample</groupId>
     <artifactId>sample-parent</artifactId>
-    <version>3.2.0-SNAPSHOT</version>
+    <version>3.3.0-SNAPSHOT</version>
   </parent>
 
   <artifactId>guide</artifactId>
diff --git a/samples/guide/src/main/java/okhttp3/recipes/CertificatePinning.java b/samples/guide/src/main/java/okhttp3/recipes/CertificatePinning.java
index b890be7577..0dbf7aaf9a 100644
--- a/samples/guide/src/main/java/okhttp3/recipes/CertificatePinning.java
+++ b/samples/guide/src/main/java/okhttp3/recipes/CertificatePinning.java
@@ -29,10 +29,10 @@ public CertificatePinning() {
     client = new OkHttpClient.Builder()
         .certificatePinner(
             new CertificatePinner.Builder()
-                .add("publicobject.com", "sha1/DmxUShsZuNiqPQsX2Oi9uv2sCnw=")
-                .add("publicobject.com", "sha1/SXxoaOSEzPC6BgGmxAt/EAcsajw=")
-                .add("publicobject.com", "sha1/blhOM3W9V/bVQhsWAcLYwPU6n24=")
-                .add("publicobject.com", "sha1/T5x9IXmcrQ7YuQxXnxoCmeeQ84c=")
+                .add("publicobject.com", "sha256/afwiKY3RxoMmLkuRW1l7QsPZTJPwDS2pdDROQjXw8ig=")
+                .add("publicobject.com", "sha256/klO23nT2ehFDXCfx3eHTDRESMz3asj1muO+4aIdjiuY=")
+                .add("publicobject.com", "sha256/grX4Ta9HpZx6tSHkmCrvpApTQGo67CYDnvprLg5yRME=")
+                .add("publicobject.com", "sha256/lCppFqbkrlJ3EcVFAkeip0+44VaoJUymbnOaEUk7tEU=")
                 .build())
         .build();
   }
diff --git a/samples/pom.xml b/samples/pom.xml
index d6f08bcb5e..4c484cbf13 100644
--- a/samples/pom.xml
+++ b/samples/pom.xml
@@ -6,7 +6,7 @@
   <parent>
     <groupId>com.squareup.okhttp3</groupId>
     <artifactId>parent</artifactId>
-    <version>3.2.0-SNAPSHOT</version>
+    <version>3.3.0-SNAPSHOT</version>
   </parent>
 
   <groupId>com.squareup.okhttp3.sample</groupId>
diff --git a/samples/simple-client/pom.xml b/samples/simple-client/pom.xml
index d255e16775..1e40e2ea19 100644
--- a/samples/simple-client/pom.xml
+++ b/samples/simple-client/pom.xml
@@ -6,7 +6,7 @@
   <parent>
     <groupId>com.squareup.okhttp3.sample</groupId>
     <artifactId>sample-parent</artifactId>
-    <version>3.2.0-SNAPSHOT</version>
+    <version>3.3.0-SNAPSHOT</version>
   </parent>
 
   <artifactId>simple-client</artifactId>
diff --git a/samples/static-server/pom.xml b/samples/static-server/pom.xml
index c32ea5c1c1..f9e5101f9c 100644
--- a/samples/static-server/pom.xml
+++ b/samples/static-server/pom.xml
@@ -6,7 +6,7 @@
   <parent>
     <groupId>com.squareup.okhttp3.sample</groupId>
     <artifactId>sample-parent</artifactId>
-    <version>3.2.0-SNAPSHOT</version>
+    <version>3.3.0-SNAPSHOT</version>
   </parent>
 
   <artifactId>static-server</artifactId>
