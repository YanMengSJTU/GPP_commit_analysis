diff --git a/okhttp-tests/src/test/java/okhttp3/internal/cache/DiskLruCacheTest.java b/okhttp-tests/src/test/java/okhttp3/internal/cache/DiskLruCacheTest.java
index d4ae88b84a..6475cf8da3 100644
--- a/okhttp-tests/src/test/java/okhttp3/internal/cache/DiskLruCacheTest.java
+++ b/okhttp-tests/src/test/java/okhttp3/internal/cache/DiskLruCacheTest.java
@@ -33,6 +33,7 @@
 import okio.Source;
 import org.junit.After;
 import org.junit.Before;
+import org.junit.Ignore;
 import org.junit.Rule;
 import org.junit.Test;
 import org.junit.rules.TemporaryFolder;
@@ -93,6 +94,38 @@ private void createNewCacheWithSize(int maxSize) throws IOException {
     assertJournalEquals();
   }
 
+  @Test
+  @Ignore
+  public void recoverFromInitializationFailure() throws IOException {
+    // Add an uncommitted entry. This will get detected on initialization, and the cache will
+    // attempt to delete the file. Do not explicitly close the cache here so the entry is left as
+    // incomplete.
+    DiskLruCache.Editor creator = cache.edit("k1");
+    BufferedSink sink = Okio.buffer(creator.newSink(0));
+    sink.writeUtf8("Hello");
+    sink.close();
+
+    // Simulate a filesystem failure on the first initialization.
+    fileSystem.setFaultyDelete(new File(cacheDir, "k1.0.tmp"), true);
+    fileSystem.setFaultyDelete(cacheDir, true);
+
+    cache = new DiskLruCache(fileSystem, cacheDir, appVersion, 2, Integer.MAX_VALUE, executor);
+    toClose.add(cache);
+
+    try {
+      cache.get("k1");
+      fail();
+    } catch (Exception expected) {
+    }
+
+    // Now let it operate normally.
+    fileSystem.setFaultyDelete(new File(cacheDir, "k1.0.tmp"), false);
+    fileSystem.setFaultyDelete(cacheDir, false);
+
+    DiskLruCache.Snapshot snapshot = cache.get("k1");
+    assertNull(snapshot);
+  }
+
   @Test public void validateKey() throws Exception {
     String key = null;
     try {
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/io/FaultyFileSystem.java b/okhttp-tests/src/test/java/okhttp3/internal/io/FaultyFileSystem.java
index 40aca93adb..bc0263d830 100644
--- a/okhttp-tests/src/test/java/okhttp3/internal/io/FaultyFileSystem.java
+++ b/okhttp-tests/src/test/java/okhttp3/internal/io/FaultyFileSystem.java
@@ -90,6 +90,7 @@ public void setFaultyRename(File file, boolean faulty) {
   }
 
   @Override public void deleteContents(File directory) throws IOException {
+    if (deleteFaults.contains(directory)) throw new IOException("boom!");
     delegate.deleteContents(directory);
   }
 
diff --git a/okhttp/src/main/java/okhttp3/ConnectionPool.java b/okhttp/src/main/java/okhttp3/ConnectionPool.java
index f07db53a90..a589e3ad1d 100644
--- a/okhttp/src/main/java/okhttp3/ConnectionPool.java
+++ b/okhttp/src/main/java/okhttp3/ConnectionPool.java
@@ -16,8 +16,8 @@
  */
 package okhttp3;
 
-import java.io.Closeable;
 import java.lang.ref.Reference;
+import java.net.Socket;
 import java.util.ArrayDeque;
 import java.util.ArrayList;
 import java.util.Deque;
@@ -130,7 +130,7 @@ RealConnection get(Address address, StreamAllocation streamAllocation) {
    * Replaces the connection held by {@code streamAllocation} with a shared connection if possible.
    * This recovers when multiple multiplexed connections are created concurrently.
    */
-  Closeable deduplicate(Address address, StreamAllocation streamAllocation) {
+  Socket deduplicate(Address address, StreamAllocation streamAllocation) {
     assert (Thread.holdsLock(this));
     for (RealConnection connection : connections) {
       if (connection.isEligible(address)
diff --git a/okhttp/src/main/java/okhttp3/OkHttpClient.java b/okhttp/src/main/java/okhttp3/OkHttpClient.java
index 6565b9fcd9..e9a636d179 100644
--- a/okhttp/src/main/java/okhttp3/OkHttpClient.java
+++ b/okhttp/src/main/java/okhttp3/OkHttpClient.java
@@ -15,10 +15,10 @@
  */
 package okhttp3;
 
-import java.io.Closeable;
 import java.net.MalformedURLException;
 import java.net.Proxy;
 import java.net.ProxySelector;
+import java.net.Socket;
 import java.net.UnknownHostException;
 import java.security.GeneralSecurityException;
 import java.security.KeyStore;
@@ -149,7 +149,7 @@
         return pool.get(address, streamAllocation);
       }
 
-      @Override public Closeable deduplicate(
+      @Override public Socket deduplicate(
           ConnectionPool pool, Address address, StreamAllocation streamAllocation) {
         return pool.deduplicate(address, streamAllocation);
       }
diff --git a/okhttp/src/main/java/okhttp3/internal/Internal.java b/okhttp/src/main/java/okhttp3/internal/Internal.java
index 1f0b3daeca..a72f71e4d4 100644
--- a/okhttp/src/main/java/okhttp3/internal/Internal.java
+++ b/okhttp/src/main/java/okhttp3/internal/Internal.java
@@ -15,8 +15,8 @@
  */
 package okhttp3.internal;
 
-import java.io.Closeable;
 import java.net.MalformedURLException;
+import java.net.Socket;
 import java.net.UnknownHostException;
 import javax.net.ssl.SSLSocket;
 import okhttp3.Address;
@@ -55,7 +55,7 @@ public static void initializeInstanceForTests() {
   public abstract RealConnection get(
       ConnectionPool pool, Address address, StreamAllocation streamAllocation);
 
-  public abstract Closeable deduplicate(
+  public abstract Socket deduplicate(
       ConnectionPool pool, Address address, StreamAllocation streamAllocation);
 
   public abstract void put(ConnectionPool pool, RealConnection connection);
diff --git a/okhttp/src/main/java/okhttp3/internal/connection/StreamAllocation.java b/okhttp/src/main/java/okhttp3/internal/connection/StreamAllocation.java
index 4b95dff8b0..fbe83067ab 100644
--- a/okhttp/src/main/java/okhttp3/internal/connection/StreamAllocation.java
+++ b/okhttp/src/main/java/okhttp3/internal/connection/StreamAllocation.java
@@ -15,10 +15,10 @@
  */
 package okhttp3.internal.connection;
 
-import java.io.Closeable;
 import java.io.IOException;
 import java.lang.ref.Reference;
 import java.lang.ref.WeakReference;
+import java.net.Socket;
 import okhttp3.Address;
 import okhttp3.ConnectionPool;
 import okhttp3.OkHttpClient;
@@ -186,7 +186,7 @@ private RealConnection findConnection(int connectTimeout, int readTimeout, int w
     result.connect(connectTimeout, readTimeout, writeTimeout, connectionRetryEnabled);
     routeDatabase().connected(result.route());
 
-    Closeable closeable = null;
+    Socket socket = null;
     synchronized (connectionPool) {
       // Pool the connection.
       Internal.instance.put(connectionPool, result);
@@ -194,17 +194,17 @@ private RealConnection findConnection(int connectTimeout, int readTimeout, int w
       // If another multiplexed connection to the same address was created concurrently, then
       // release this connection and acquire that one.
       if (result.isMultiplexed()) {
-        closeable = Internal.instance.deduplicate(connectionPool, address, this);
+        socket = Internal.instance.deduplicate(connectionPool, address, this);
         result = connection;
       }
     }
-    closeQuietly(closeable);
+    closeQuietly(socket);
 
     return result;
   }
 
   public void streamFinished(boolean noNewStreams, HttpCodec codec) {
-    Closeable closeable;
+    Socket socket;
     synchronized (connectionPool) {
       if (codec == null || codec != this.codec) {
         throw new IllegalStateException("expected " + this.codec + " but was " + codec);
@@ -212,9 +212,9 @@ public void streamFinished(boolean noNewStreams, HttpCodec codec) {
       if (!noNewStreams) {
         connection.successCount++;
       }
-      closeable = deallocate(noNewStreams, false, true);
+      socket = deallocate(noNewStreams, false, true);
     }
-    closeQuietly(closeable);
+    closeQuietly(socket);
   }
 
   public HttpCodec codec() {
@@ -232,20 +232,20 @@ public synchronized RealConnection connection() {
   }
 
   public void release() {
-    Closeable closeable;
+    Socket socket;
     synchronized (connectionPool) {
-      closeable = deallocate(false, true, false);
+      socket = deallocate(false, true, false);
     }
-    closeQuietly(closeable);
+    closeQuietly(socket);
   }
 
   /** Forbid new streams from being created on the connection that hosts this allocation. */
   public void noNewStreams() {
-    Closeable closeable;
+    Socket socket;
     synchronized (connectionPool) {
-      closeable = deallocate(true, false, false);
+      socket = deallocate(true, false, false);
     }
-    closeQuietly(closeable);
+    closeQuietly(socket);
   }
 
   /**
@@ -255,7 +255,7 @@ public void noNewStreams() {
    * <p>Returns a closeable that the caller should pass to {@link Util#closeQuietly} upon completion
    * of the synchronized block. (We don't do I/O while synchronized on the connection pool.)
    */
-  private Closeable deallocate(boolean noNewStreams, boolean released, boolean streamFinished) {
+  private Socket deallocate(boolean noNewStreams, boolean released, boolean streamFinished) {
     assert (Thread.holdsLock(connectionPool));
 
     if (streamFinished) {
@@ -264,7 +264,7 @@ private Closeable deallocate(boolean noNewStreams, boolean released, boolean str
     if (released) {
       this.released = true;
     }
-    Closeable closeable = null;
+    Socket socket = null;
     if (connection != null) {
       if (noNewStreams) {
         connection.noNewStreams = true;
@@ -274,13 +274,13 @@ private Closeable deallocate(boolean noNewStreams, boolean released, boolean str
         if (connection.allocations.isEmpty()) {
           connection.idleAtNanos = System.nanoTime();
           if (Internal.instance.connectionBecameIdle(connectionPool, connection)) {
-            closeable = connection.socket();
+            socket = connection.socket();
           }
         }
         connection = null;
       }
     }
-    return closeable;
+    return socket;
   }
 
   public void cancel() {
@@ -299,7 +299,7 @@ public void cancel() {
   }
 
   public void streamFailed(IOException e) {
-    Closeable closeable;
+    Socket socket;
     boolean noNewStreams = false;
 
     synchronized (connectionPool) {
@@ -326,10 +326,10 @@ public void streamFailed(IOException e) {
           route = null;
         }
       }
-      closeable = deallocate(noNewStreams, false, true);
+      socket = deallocate(noNewStreams, false, true);
     }
 
-    closeQuietly(closeable);
+    closeQuietly(socket);
   }
 
   /**
@@ -364,19 +364,19 @@ private void release(RealConnection connection) {
    * <p>Returns a closeable that the caller should pass to {@link Util#closeQuietly} upon completion
    * of the synchronized block. (We don't do I/O while synchronized on the connection pool.)
    */
-  public Closeable releaseAndAcquire(RealConnection newConnection) {
+  public Socket releaseAndAcquire(RealConnection newConnection) {
     assert (Thread.holdsLock(connectionPool));
     if (codec != null || connection.allocations.size() != 1) throw new IllegalStateException();
 
     // Release the old connection.
     Reference<StreamAllocation> onlyAllocation = connection.allocations.get(0);
-    Closeable closeable = deallocate(true, false, false);
+    Socket socket = deallocate(true, false, false);
 
     // Acquire the new connection.
     this.connection = newConnection;
     newConnection.allocations.add(onlyAllocation);
 
-    return closeable;
+    return socket;
   }
 
   public boolean hasMoreRoutes() {
diff --git a/pom.xml b/pom.xml
index 35a0210990..3b2b33b774 100644
--- a/pom.xml
+++ b/pom.xml
@@ -507,6 +507,14 @@
         <alpn.jdk8.version>8.1.9.v20160720</alpn.jdk8.version>
       </properties>
     </profile>
+    <profile>
+      <id>alpn-when-jdk8_121</id>
+      <activation>
+        <jdk>1.8.0_121</jdk>
+      </activation>
+      <properties>
+        <alpn.jdk8.version>8.1.11.v20170118</alpn.jdk8.version>
+      </properties>
+    </profile>
   </profiles>
 </project>
-
