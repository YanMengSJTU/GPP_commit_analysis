diff --git a/okhttp-tests/src/test/java/okhttp3/EventListenerTest.java b/okhttp-tests/src/test/java/okhttp3/EventListenerTest.java
index 5a20e3045f..4283e5a812 100644
--- a/okhttp-tests/src/test/java/okhttp3/EventListenerTest.java
+++ b/okhttp-tests/src/test/java/okhttp3/EventListenerTest.java
@@ -83,7 +83,7 @@
     List<Class<?>> expectedEvents = Arrays.asList(
         DnsStart.class, DnsEnd.class,
         ConnectStart.class, ConnectEnd.class,
-        ConnectionFound.class);
+        ConnectionAcquired.class);
     assertEquals(expectedEvents, listener.recordedEventTypes());
   }
 
@@ -102,7 +102,7 @@
         DnsStart.class, DnsEnd.class,
         ConnectStart.class, SecureConnectStart.class,
         SecureConnectEnd.class, ConnectEnd.class,
-        ConnectionFound.class);
+        ConnectionAcquired.class);
     assertEquals(expectedEvents, listener.recordedEventTypes());
   }
 
@@ -535,9 +535,9 @@
     assertEquals(200, response.code());
     response.body().close();
 
-    ConnectionFound connectionFound = listener.removeUpToEvent(ConnectionFound.class);
-    assertSame(call, connectionFound.call);
-    assertNotNull(connectionFound.connection);
+    ConnectionAcquired connectionAcquired = listener.removeUpToEvent(ConnectionAcquired.class);
+    assertSame(call, connectionAcquired.call);
+    assertNotNull(connectionAcquired.connection);
   }
 
   @Test public void noConnectionFoundOnFollowUp() throws IOException {
@@ -553,10 +553,10 @@
     Response response = call.execute();
     assertEquals("ABC", response.body().string());
 
-    listener.removeUpToEvent(ConnectionFound.class);
+    listener.removeUpToEvent(ConnectionAcquired.class);
 
     List<Class<?>> remainingEvents = listener.recordedEventTypes();
-    assertFalse(remainingEvents.contains(ConnectionFound.class));
+    assertFalse(remainingEvents.contains(ConnectionAcquired.class));
   }
 
   @Test public void pooledConnectionFound() throws IOException {
@@ -571,7 +571,7 @@
     assertEquals(200, response1.code());
     response1.body().close();
 
-    ConnectionFound connectionFound1 = listener.removeUpToEvent(ConnectionFound.class);
+    ConnectionAcquired connectionAcquired1 = listener.removeUpToEvent(ConnectionAcquired.class);
     listener.clearAllEvents();
 
     Call call2 = client.newCall(new Request.Builder()
@@ -581,8 +581,8 @@
     assertEquals(200, response2.code());
     response2.body().close();
 
-    ConnectionFound connectionFound2 = listener.removeUpToEvent(ConnectionFound.class);
-    assertSame(connectionFound1.connection, connectionFound2.connection);
+    ConnectionAcquired connectionAcquired2 = listener.removeUpToEvent(ConnectionAcquired.class);
+    assertSame(connectionAcquired1.connection, connectionAcquired2.connection);
   }
 
   @Test public void multipleConnectionsFoundForSingleCall() throws IOException {
@@ -599,8 +599,8 @@
     Response response = call.execute();
     assertEquals("ABC", response.body().string());
 
-    listener.removeUpToEvent(ConnectionFound.class);
-    listener.removeUpToEvent(ConnectionFound.class);
+    listener.removeUpToEvent(ConnectionAcquired.class);
+    listener.removeUpToEvent(ConnectionAcquired.class);
   }
 
   private void enableTlsWithTunnel(boolean tunnelProxy) {
@@ -681,11 +681,21 @@ private void enableTlsWithTunnel(boolean tunnelProxy) {
     }
   }
 
-  static final class ConnectionFound {
+  static final class ConnectionAcquired {
     final Call call;
     final Connection connection;
 
-    ConnectionFound(Call call, Connection connection) {
+    ConnectionAcquired(Call call, Connection connection) {
+      this.call = call;
+      this.connection = connection;
+    }
+  }
+
+  static final class ConnectionReleased {
+    final Call call;
+    final Connection connection;
+
+    ConnectionReleased(Call call, Connection connection) {
       this.call = call;
       this.connection = connection;
     }
@@ -742,12 +752,16 @@ void clearAllEvents() {
     }
 
     @Override public void connectEnd(Call call, InetSocketAddress inetSocketAddress,
-        Protocol protocol, Throwable throwable) {
+        Proxy proxy, Protocol protocol, Throwable throwable) {
       eventSequence.offer(new ConnectEnd(call, inetSocketAddress, protocol, throwable));
     }
 
-    @Override public void connectionFound(Call call, Connection connection) {
-      eventSequence.offer(new ConnectionFound(call, connection));
+    @Override public void connectionAcquired(Call call, Connection connection) {
+      eventSequence.offer(new ConnectionAcquired(call, connection));
+    }
+
+    @Override public void connectionReleased(Call call, Connection connection) {
+      eventSequence.offer(new ConnectionReleased(call, connection));
     }
   }
 }
diff --git a/okhttp/src/main/java/okhttp3/EventListener.java b/okhttp/src/main/java/okhttp3/EventListener.java
index d1126f7b70..38d2b7b989 100644
--- a/okhttp/src/main/java/okhttp3/EventListener.java
+++ b/okhttp/src/main/java/okhttp3/EventListener.java
@@ -33,6 +33,14 @@ public EventListener create(Call call) {
     };
   }
 
+  /**
+   * Invoked as soon as a call is enqueued or executed by a client. In case of thread or stream
+   * limits, this call may be executed well before processing the request is able to begin.
+   *
+   * <p>This will be invoked only once for a single {@link Call}. Retries of different routes
+   * or redirects will be handled within the boundaries of a single fetchStart and
+   * {@link #fetchEnd(Call, Throwable)} pair.
+   */
   public void fetchStart(Call call) {
   }
 
@@ -112,14 +120,14 @@ public void secureConnectEnd(Call call, @Nullable Handshake handshake,
    * {@link #secureConnectEnd(Call, Handshake, Throwable)}, otherwise it will invoked after
    * {@link #connectStart(Call, InetSocketAddress, Proxy)}.
    *
-   * <p>{@code protocol} will be non-null and {@code throwable} will be null when the connection is
-   * successfully established.
+   * <p>{@code protocol} and {@code proxy} will be non-null and {@code throwable} will be null when
+   * the connection is successfully established.
    *
-   * <p>{@code protocol} will be null and {@code throwable} will be non-null in the case of a failed
-   * connection attempt.
+   * <p>{@code protocol} and {@code proxy} will be null and {@code throwable} will be non-null in
+   * the case of a failed connection attempt.
    */
   public void connectEnd(Call call, InetSocketAddress inetSocketAddress,
-      @Nullable Protocol protocol, @Nullable Throwable throwable) {
+      Proxy proxy, @Nullable Protocol protocol, @Nullable Throwable throwable) {
   }
 
   /**
@@ -128,33 +136,130 @@ public void connectEnd(Call call, InetSocketAddress inetSocketAddress,
    * <p>This can be invoked more than 1 time for a single {@link Call}. For example, if the response
    * to the {@link Call#request()} is a redirect to a different address.
    */
-  public void connectionFound(Call call, Connection connection) {
+  public void connectionAcquired(Call call, Connection connection) {
   }
 
+  /**
+   * Invoked after a connection has been released for the {@code call}.
+   *
+   * <p>This method is always invoked after {@link #connectionAcquired(Call, Connection)}.
+   *
+   * <p>This can be invoked more than 1 time for a single {@link Call}. For example, if the response
+   * to the {@link Call#request()} is a redirect to a different address.
+   */
+  public void connectionReleased(Call call, Connection connection) {
+  }
+
+  /**
+   * Invoked just prior to sending request headers.
+   *
+   * <p>The connection is implicit, and will generally relate to the last
+   * {@link #connectionAcquired(Call, Connection)} event.
+   *
+   * <p>This can be invoked more than 1 time for a single {@link Call}. For example, if the response
+   * to the {@link Call#request()} is a redirect to a different address.
+   */
   public void requestHeadersStart(Call call) {
   }
 
+  /**
+   * Invoked immediately after sending request headers.
+   *
+   * <p>This method is always invoked after {@link #requestHeadersStart(Call)}.
+   *
+   * <p>{@code throwable} will be null in the case of a successful attempt to send the headers.
+   *
+   * <p>{@code throwable} will be non-null in the case of a failed attempt to send the headers.
+   */
   public void requestHeadersEnd(Call call, Throwable throwable) {
   }
 
+  /**
+   * Invoked just prior to sending a request body.  Will only be invoked for request allowing and
+   * having a request body to send.
+   *
+   * <p>The connection is implicit, and will generally relate to the last
+   * {@link #connectionAcquired(Call, Connection)} event.
+   *
+   * <p>This can be invoked more than 1 time for a single {@link Call}. For example, if the response
+   * to the {@link Call#request()} is a redirect to a different address.
+   */
   public void requestBodyStart(Call call) {
   }
 
+  /**
+   * Invoked immediately after sending a request body.
+   *
+   * <p>This method is always invoked after {@link #requestBodyStart(Call)}.
+   *
+   * <p>{@code throwable} will be null in the case of a successful attempt to send the body.
+   *
+   * <p>{@code throwable} will be non-null in the case of a failed attempt to send the body.
+   */
   public void requestBodyEnd(Call call, Throwable throwable) {
   }
 
+  /**
+   * Invoked just prior to receiving response headers.
+   *
+   * <p>The connection is implicit, and will generally relate to the last
+   * {@link #connectionAcquired(Call, Connection)} event.
+   *
+   * <p>This can be invoked more than 1 time for a single {@link Call}. For example, if the response
+   * to the {@link Call#request()} is a redirect to a different address.
+   */
   public void responseHeadersStart(Call call) {
   }
 
+  /**
+   * Invoked immediately after receiving response headers.
+   *
+   * <p>This method is always invoked after {@link #responseHeadersStart(Call)}.
+   *
+   * <p>{@code throwable} will be null in the case of a successful attempt to receive the headers.
+   *
+   * <p>{@code throwable} will be non-null in the case of a failed attempt to receive the headers.
+   */
   public void responseHeadersEnd(Call call, Throwable throwable) {
   }
 
+  /**
+   * Invoked just prior to receiving the response body.
+   *
+   * <p>The connection is implicit, and will generally relate to the last
+   * {@link #connectionAcquired(Call, Connection)} event.
+   *
+   * <p>This will usually be invoked only 1 time for a single {@link Call},
+   * exceptions are a limited set of cases including failure recovery.
+   */
   public void responseBodyStart(Call call) {
   }
 
+  /**
+   * Invoked immediately after receiving a response body and completing reading it.
+   *
+   * <p>Will only be invoked for requests having a response body e.g. won't be invoked for a
+   * websocket upgrade.
+   *
+   * <p>This method is always invoked after {@link #requestBodyStart(Call)}.
+   *
+   * <p>{@code throwable} will be null in the case of a successful attempt to send the body.
+   *
+   * <p>{@code throwable} will be non-null in the case of a failed attempt to send the body.
+   */
   public void responseBodyEnd(Call call, Throwable throwable) {
   }
 
+  /**
+   * Invoked immediately after a call has completely ended.  This includes delayed consumption
+   * of response body by the caller.
+   *
+   * <p>This method is always invoked after {@link #fetchStart(Call)}.
+   *
+   * <p>{@code throwable} will be null in the case of a successful attempt to execute the call.
+   *
+   * <p>{@code throwable} will be non-null in the case of a failed attempt to execute the call.
+   */
   public void fetchEnd(Call call, Throwable throwable) {
   }
 
diff --git a/okhttp/src/main/java/okhttp3/internal/connection/RealConnection.java b/okhttp/src/main/java/okhttp3/internal/connection/RealConnection.java
index d95dc99f92..c9bb6f9dd3 100644
--- a/okhttp/src/main/java/okhttp3/internal/connection/RealConnection.java
+++ b/okhttp/src/main/java/okhttp3/internal/connection/RealConnection.java
@@ -158,7 +158,7 @@ public void connect(int connectTimeout, int readTimeout, int writeTimeout,
           connectSocket(connectTimeout, readTimeout, call, eventListener);
         }
         establishProtocol(connectionSpecSelector, call, eventListener);
-        eventListener.connectEnd(call, route.socketAddress(), protocol, null);
+        eventListener.connectEnd(call, route.socketAddress(), route.proxy(), protocol, null);
         break;
       } catch (IOException e) {
         closeQuietly(socket);
@@ -171,7 +171,7 @@ public void connect(int connectTimeout, int readTimeout, int writeTimeout,
         protocol = null;
         http2Connection = null;
 
-        eventListener.connectEnd(call, route.socketAddress(), null, e);
+        eventListener.connectEnd(call, route.socketAddress(), route.proxy(), null, e);
 
         if (routeException == null) {
           routeException = new RouteException(e);
@@ -218,7 +218,7 @@ private void connectTunnel(int connectTimeout, int readTimeout, int writeTimeout
       rawSocket = null;
       sink = null;
       source = null;
-      eventListener.connectEnd(call, route.socketAddress(), null, null);
+      eventListener.connectEnd(call, route.socketAddress(), route.proxy(), null, null);
     }
   }
 
diff --git a/okhttp/src/main/java/okhttp3/internal/connection/StreamAllocation.java b/okhttp/src/main/java/okhttp3/internal/connection/StreamAllocation.java
index 79457075f7..656a69de12 100644
--- a/okhttp/src/main/java/okhttp3/internal/connection/StreamAllocation.java
+++ b/okhttp/src/main/java/okhttp3/internal/connection/StreamAllocation.java
@@ -115,7 +115,7 @@ public HttpCodec newStream(
       HttpCodec resultCodec = resultConnection.newCodec(client, chain, this);
 
       if (existingConnection != connection) {
-        eventListener.connectionFound(call, connection);
+        eventListener.connectionAcquired(call, connection);
       }
 
       synchronized (connectionPool) {
