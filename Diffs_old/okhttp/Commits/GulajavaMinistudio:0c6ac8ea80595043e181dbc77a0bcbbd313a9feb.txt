diff --git a/android-test/src/androidTest/java/okhttp/android/test/OkHttpTest.kt b/android-test/src/androidTest/java/okhttp/android/test/OkHttpTest.kt
index 24db91b753..69229bf3fa 100644
--- a/android-test/src/androidTest/java/okhttp/android/test/OkHttpTest.kt
+++ b/android-test/src/androidTest/java/okhttp/android/test/OkHttpTest.kt
@@ -55,7 +55,7 @@ import java.security.Security
 import javax.net.ssl.SSLPeerUnverifiedException
 import javax.net.ssl.SSLSocket
 import okhttp3.internal.platform.AndroidPlatform
-import okhttp3.internal.platform.AndroidQPlatform
+import okhttp3.internal.platform.Android10Platform
 
 /**
  * Run with "./gradlew :android-test:connectedCheck" and make sure ANDROID_SDK_ROOT is set.
@@ -86,7 +86,7 @@ class OkHttpTest {
   @Test
   fun testPlatform() {
     if (Build.VERSION.SDK_INT >= 29) {
-      assertTrue(Platform.get() is AndroidQPlatform)
+      assertTrue(Platform.get() is Android10Platform)
     } else {
       assertTrue(Platform.get() is AndroidPlatform)
     }
diff --git a/okhttp-logging-interceptor/src/main/java/okhttp3/logging/HttpLoggingInterceptor.kt b/okhttp-logging-interceptor/src/main/java/okhttp3/logging/HttpLoggingInterceptor.kt
index 233142b7a3..745a860a9f 100644
--- a/okhttp-logging-interceptor/src/main/java/okhttp3/logging/HttpLoggingInterceptor.kt
+++ b/okhttp-logging-interceptor/src/main/java/okhttp3/logging/HttpLoggingInterceptor.kt
@@ -191,6 +191,8 @@ class HttpLoggingInterceptor @JvmOverloads constructor(
         logger.log("--> END ${request.method} (encoded body omitted)")
       } else if (requestBody.isDuplex()) {
         logger.log("--> END ${request.method} (duplex request body omitted)")
+      } else if (requestBody.isOneShot()) {
+        logger.log("--> END ${request.method} (one-shot body omitted)")
       } else {
         val buffer = Buffer()
         requestBody.writeTo(buffer)
diff --git a/okhttp-logging-interceptor/src/test/java/okhttp3/logging/HttpLoggingInterceptorTest.java b/okhttp-logging-interceptor/src/test/java/okhttp3/logging/HttpLoggingInterceptorTest.java
index 48e8a50e9e..3591bc9c0a 100644
--- a/okhttp-logging-interceptor/src/test/java/okhttp3/logging/HttpLoggingInterceptorTest.java
+++ b/okhttp-logging-interceptor/src/test/java/okhttp3/logging/HttpLoggingInterceptorTest.java
@@ -875,6 +875,51 @@ public void headersAreRedacted() throws Exception {
         .assertNoMoreLogs();
   }
 
+  @Test public void oneShotRequestsAreNotLogged() throws Exception {
+    url = server.url("/");
+
+    setLevel(Level.BODY);
+
+    server.enqueue(new MockResponse()
+                           .setBody("Hello response!"));
+
+    RequestBody asyncRequestBody = new RequestBody() {
+      @Override public @Nullable MediaType contentType() {
+        return null;
+      }
+
+      int counter = 0;
+      @Override public void writeTo(BufferedSink sink) throws IOException {
+        counter++;
+        assertThat(counter).isLessThanOrEqualTo(1);
+
+        sink.writeUtf8("Hello request!");
+        sink.close();
+      }
+
+      @Override public boolean isOneShot() {
+        return true;
+      }
+    };
+
+    Request request = request()
+                              .post(asyncRequestBody)
+                              .build();
+    Response response = client.newCall(request).execute();
+
+    assertThat(response.body().string()).isEqualTo("Hello response!");
+
+    applicationLogs
+            .assertLogEqual("--> POST " + url)
+            .assertLogEqual("--> END POST (one-shot body omitted)")
+            .assertLogMatch("<-- 200 OK " + url + " \\(\\d+ms\\)")
+            .assertLogEqual("Content-Length: 15")
+            .assertLogEqual("")
+            .assertLogEqual("Hello response!")
+            .assertLogEqual("<-- END HTTP (15-byte body)")
+            .assertNoMoreLogs();
+  }
+
   private Request.Builder request() {
     return new Request.Builder().url(url);
   }
diff --git a/okhttp/src/main/java/okhttp3/internal/Util.kt b/okhttp/src/main/java/okhttp3/internal/Util.kt
index d40f16c4d6..1748d996ac 100644
--- a/okhttp/src/main/java/okhttp3/internal/Util.kt
+++ b/okhttp/src/main/java/okhttp3/internal/Util.kt
@@ -516,10 +516,8 @@ fun Int.toHexString(): String = Integer.toHexString(this)
  */
 @Throws(InterruptedException::class)
 fun Any.lockAndWaitNanos(nanos: Long) {
-  val ms = nanos / 1_000_000L
-  val ns = nanos - (ms * 1_000_000L)
   synchronized(this) {
-    waitMillis(ms, ns.toInt())
+    objectWaitNanos(nanos)
   }
 }
 
@@ -527,13 +525,16 @@ fun Any.lockAndWaitNanos(nanos: Long) {
 inline fun Any.wait() = (this as Object).wait()
 
 /**
- * Lock and wait a duration in milliseconds and nanos.
- * Unlike [java.lang.Object.wait] this interprets 0 as "don't wait" instead of "wait forever".
+ * Wait a duration in nanoseconds. Unlike [java.lang.Object.wait] this interprets 0 as "don't wait"
+ * instead of "wait forever".
  */
+@Throws(InterruptedException::class)
 @Suppress("PLATFORM_CLASS_MAPPED_TO_KOTLIN")
-fun Any.waitMillis(timeout: Long, nanos: Int = 0) {
-  if (timeout > 0L || nanos > 0) {
-    (this as Object).wait(timeout, nanos)
+fun Any.objectWaitNanos(nanos: Long) {
+  val ms = nanos / 1_000_000L
+  val ns = nanos - (ms * 1_000_000L)
+  if (ms > 0L || nanos > 0) {
+    (this as Object).wait(ms, ns.toInt())
   }
 }
 
@@ -566,3 +567,7 @@ fun <T> readFieldOrNull(instance: Any, fieldType: Class<T>, fieldName: String):
 
   return null
 }
+
+internal fun <E> MutableList<E>.addIfAbsent(element: E) {
+  if (!contains(element)) add(element)
+}
diff --git a/okhttp/src/main/java/okhttp3/internal/concurrent/Task.kt b/okhttp/src/main/java/okhttp3/internal/concurrent/Task.kt
index 541011e47d..22d7f3316e 100644
--- a/okhttp/src/main/java/okhttp3/internal/concurrent/Task.kt
+++ b/okhttp/src/main/java/okhttp3/internal/concurrent/Task.kt
@@ -45,9 +45,43 @@ abstract class Task(
   val name: String,
   val daemon: Boolean = true
 ) {
+  // Guarded by the TaskRunner.
+  internal var queue: TaskQueue? = null
+
+  /** Undefined unless this is in [TaskQueue.futureTasks]. */
+  internal var nextExecuteNanoTime = -1L
+
+  internal var runRunnable: Runnable? = null
+  internal var cancelRunnable: Runnable? = null
+
   /** Returns the delay in nanoseconds until the next execution, or -1L to not reschedule. */
   abstract fun runOnce(): Long
 
   /** Return true to skip the scheduled execution. */
   open fun tryCancel(): Boolean = false
+
+  internal fun initQueue(queue: TaskQueue) {
+    if (this.queue === queue) return
+
+    check(this.queue === null) { "task is in multiple queues" }
+    this.queue = queue
+
+    this.runRunnable = Runnable {
+      var delayNanos = -1L
+      try {
+        delayNanos = runOnce()
+      } finally {
+        queue.runCompleted(this, delayNanos)
+      }
+    }
+
+    this.cancelRunnable = Runnable {
+      var skipExecution = false
+      try {
+        skipExecution = tryCancel()
+      } finally {
+        queue.tryCancelCompleted(this, skipExecution)
+      }
+    }
+  }
 }
diff --git a/okhttp/src/main/java/okhttp3/internal/concurrent/TaskQueue.kt b/okhttp/src/main/java/okhttp3/internal/concurrent/TaskQueue.kt
index 554232c50d..7838180068 100644
--- a/okhttp/src/main/java/okhttp3/internal/concurrent/TaskQueue.kt
+++ b/okhttp/src/main/java/okhttp3/internal/concurrent/TaskQueue.kt
@@ -15,21 +15,44 @@
  */
 package okhttp3.internal.concurrent
 
+import okhttp3.internal.addIfAbsent
+
 /**
  * A set of tasks that are executed in sequential order.
  *
  * Work within queues is not concurrent. This is equivalent to each queue having a dedicated thread
  * for its work; in practice a set of queues may share a set of threads to save resources.
  */
-interface TaskQueue {
+class TaskQueue internal constructor(
+  private val taskRunner: TaskRunner,
+
   /**
    * An application-level object like a connection pool or HTTP call that this queue works on behalf
    * of. This is intended to be useful for testing and debugging only.
    */
   val owner: Any
+) {
+  /** This queue's currently-executing task, or null if none is currently executing. */
+  private var activeTask: Task? = null
+
+  /** Scheduled tasks ordered by [Task.nextExecuteNanoTime]. */
+  private val futureTasks = mutableListOf<Task>()
+
+  /** Tasks to cancel. Always either [activeTask] or a member of [futureTasks]. */
+  private val cancelTasks = mutableListOf<Task>()
 
-  /** Returns a snapshot of tasks currently scheduled for execution. */
+  internal fun isActive(): Boolean {
+    check(Thread.holdsLock(taskRunner))
+
+    return activeTask != null || futureTasks.isNotEmpty()
+  }
+
+  /**
+   * Returns a snapshot of tasks currently scheduled for execution. Does not include the
+   * currently-executing task unless it is also scheduled for future execution.
+   */
   val scheduledTasks: List<Task>
+    get() = synchronized(taskRunner) { futureTasks.toList() }
 
   /**
    * Schedules [task] for execution in [delayNanos]. A task may only have one future execution
@@ -39,12 +62,126 @@ interface TaskQueue {
    * is running when that time is reached, that task is allowed to complete before this task is
    * started. Similarly the task will be delayed if the host lacks compute resources.
    */
-  fun schedule(task: Task, delayNanos: Long = 0L)
+  fun schedule(task: Task, delayNanos: Long) {
+    task.initQueue(this)
+
+    synchronized(taskRunner) {
+      if (scheduleAndDecide(task, delayNanos)) {
+        taskRunner.kickCoordinator(this)
+      }
+    }
+  }
+
+  /** Adds [task] to run in [delayNanos]. Returns true if the coordinator should run. */
+  private fun scheduleAndDecide(task: Task, delayNanos: Long): Boolean {
+    val now = taskRunner.backend.nanoTime()
+    val executeNanoTime = now + delayNanos
+
+    // If the task is already scheduled, take the earlier of the two times.
+    val existingIndex = futureTasks.indexOf(task)
+    if (existingIndex != -1) {
+      if (task.nextExecuteNanoTime <= executeNanoTime) return false // Already scheduled earlier.
+      futureTasks.removeAt(existingIndex) // Already scheduled later: reschedule below!
+    }
+    task.nextExecuteNanoTime = executeNanoTime
+
+    // Insert in chronological order. Always compare deltas because nanoTime() is permitted to wrap.
+    var insertAt = futureTasks.indexOfFirst { it.nextExecuteNanoTime - now > delayNanos }
+    if (insertAt == -1) insertAt = futureTasks.size
+    futureTasks.add(insertAt, task)
+
+    // Run the coordinator if we inserted at the front.
+    return insertAt == 0
+  }
 
   /**
    * Schedules immediate execution of [Task.tryCancel] on all currently-enqueued tasks. These calls
    * will not be made until any currently-executing task has completed. Tasks that return true will
    * be removed from the execution schedule.
    */
-  fun cancelAll()
+  fun cancelAll() {
+    synchronized(taskRunner) {
+      if (cancelAllAndDecide()) {
+        taskRunner.kickCoordinator(this)
+      }
+    }
+  }
+
+  /** Returns true if the coordinator should run. */
+  private fun cancelAllAndDecide(): Boolean {
+    val runningTask = activeTask
+    if (runningTask != null) {
+      cancelTasks.addIfAbsent(runningTask)
+    }
+
+    for (task in futureTasks) {
+      cancelTasks.addIfAbsent(task)
+    }
+
+    // Run the coordinator if tasks were canceled.
+    return cancelTasks.isNotEmpty()
+  }
+
+  /**
+   * Posts the next available task to an executor for immediate execution.
+   *
+   * Returns the delay until the next call to this method, -1L for no further calls, or
+   * [Long.MAX_VALUE] to wait indefinitely.
+   */
+  internal fun executeReadyTask(now: Long): Long {
+    check(Thread.holdsLock(taskRunner))
+
+    if (activeTask != null) return Long.MAX_VALUE // This queue is busy.
+
+    // Find a task to cancel.
+    val cancelTask = cancelTasks.firstOrNull()
+    if (cancelTask != null) {
+      activeTask = cancelTask
+      cancelTasks.removeAt(0)
+      taskRunner.backend.executeTask(cancelTask.cancelRunnable!!)
+      return Long.MAX_VALUE // This queue is busy until the cancel completes.
+    }
+
+    // Check if a task is immediately ready.
+    val runTask = futureTasks.firstOrNull() ?: return -1L
+    val delayNanos = runTask.nextExecuteNanoTime - now
+    if (delayNanos <= 0) {
+      activeTask = runTask
+      futureTasks.removeAt(0)
+      taskRunner.backend.executeTask(runTask.runRunnable!!)
+      return Long.MAX_VALUE // This queue is busy until the run completes.
+    }
+
+    // Wait until the next task is ready.
+    return delayNanos
+  }
+
+  internal fun runCompleted(task: Task, delayNanos: Long) {
+    synchronized(taskRunner) {
+      check(activeTask === task)
+
+      if (delayNanos != -1L) {
+        scheduleAndDecide(task, delayNanos)
+      } else if (!futureTasks.contains(task)) {
+        cancelTasks.remove(task) // We don't need to cancel it because it isn't scheduled.
+      }
+
+      activeTask = null
+      taskRunner.kickCoordinator(this)
+    }
+  }
+
+  internal fun tryCancelCompleted(task: Task, skipExecution: Boolean) {
+    synchronized(taskRunner) {
+      check(activeTask === task)
+
+      if (skipExecution) {
+        futureTasks.remove(task)
+        cancelTasks.remove(task)
+      }
+
+      activeTask = null
+      taskRunner.kickCoordinator(this)
+    }
+  }
 }
diff --git a/okhttp/src/main/java/okhttp3/internal/concurrent/TaskRunner.kt b/okhttp/src/main/java/okhttp3/internal/concurrent/TaskRunner.kt
index f003f15b3d..494f12b7d2 100644
--- a/okhttp/src/main/java/okhttp3/internal/concurrent/TaskRunner.kt
+++ b/okhttp/src/main/java/okhttp3/internal/concurrent/TaskRunner.kt
@@ -15,6 +15,15 @@
  */
 package okhttp3.internal.concurrent
 
+import okhttp3.internal.addIfAbsent
+import okhttp3.internal.notify
+import okhttp3.internal.objectWaitNanos
+import okhttp3.internal.threadFactory
+import java.util.concurrent.Executor
+import java.util.concurrent.SynchronousQueue
+import java.util.concurrent.ThreadPoolExecutor
+import java.util.concurrent.TimeUnit
+
 /**
  * A set of worker threads that are shared among a set of task queues.
  *
@@ -27,12 +36,130 @@ package okhttp3.internal.concurrent
  *
  * Most applications should share a process-wide [TaskRunner] and use queues for per-client work.
  */
-interface TaskRunner {
-  fun newQueue(owner: Any): TaskQueue
+class TaskRunner(
+  val backend: Backend = RealBackend()
+) {
+  // All state in all tasks and queues is guarded by this.
+
+  private var coordinatorRunning = false
+  private val activeQueues = mutableListOf<TaskQueue>()
+  private val coordinator = Runnable { coordinate() }
+
+  fun newQueue(owner: Any) = TaskQueue(this, owner)
 
   /**
    * Returns a snapshot of queues that currently have tasks scheduled. The task runner does not
    * necessarily track queues that have no tasks scheduled.
    */
-  fun activeQueues(): List<TaskQueue>
+  fun activeQueues(): List<TaskQueue> {
+    synchronized(this) {
+      return activeQueues.toList()
+    }
+  }
+
+  internal fun kickCoordinator(queue: TaskQueue) {
+    check(Thread.holdsLock(this))
+
+    if (queue.isActive()) {
+      activeQueues.addIfAbsent(queue)
+    } else {
+      activeQueues.remove(queue)
+    }
+
+    if (coordinatorRunning) {
+      backend.coordinatorNotify(this)
+    } else {
+      coordinatorRunning = true
+      backend.executeCoordinator(coordinator)
+    }
+  }
+
+  private fun coordinate() {
+    synchronized(this) {
+      while (true) {
+        val now = backend.nanoTime()
+        val delayNanos = executeReadyTasks(now)
+
+        if (delayNanos == -1L) {
+          coordinatorRunning = false
+          return
+        }
+
+        try {
+          backend.coordinatorWait(this, delayNanos)
+        } catch (_: InterruptedException) {
+          // Will cause the coordinator to exit unless other tasks are scheduled!
+          cancelAll()
+        }
+      }
+    }
+  }
+
+  /**
+   * Start executing the next available tasks for all queues.
+   *
+   * Returns the delay until the next call to this method, -1L for no further calls, or
+   * [Long.MAX_VALUE] to wait indefinitely.
+   */
+  private fun executeReadyTasks(now: Long): Long {
+    var result = -1L
+
+    for (queue in activeQueues) {
+      val delayNanos = queue.executeReadyTask(now)
+      if (delayNanos == -1L) continue
+      result = if (result == -1L) delayNanos else minOf(result, delayNanos)
+    }
+
+    return result
+  }
+
+  private fun cancelAll() {
+    for (queue in activeQueues) {
+      queue.cancelAll()
+    }
+  }
+
+  interface Backend {
+    fun executeCoordinator(runnable: Runnable)
+    fun executeTask(runnable: Runnable)
+    fun nanoTime(): Long
+    fun coordinatorNotify(taskRunner: TaskRunner)
+    fun coordinatorWait(taskRunner: TaskRunner, nanos: Long)
+  }
+
+  class RealBackend : Backend {
+    private val coordinatorExecutor: Executor = ThreadPoolExecutor(
+        0, // corePoolSize.
+        1, // maximumPoolSize.
+        60L, TimeUnit.SECONDS, // keepAliveTime.
+        SynchronousQueue(),
+        threadFactory("OkHttp Task Coordinator", false)
+    )
+
+    private val taskExecutor: Executor = ThreadPoolExecutor(
+        0, // corePoolSize.
+        Int.MAX_VALUE, // maximumPoolSize.
+        60L, TimeUnit.SECONDS, // keepAliveTime.
+        SynchronousQueue(),
+        threadFactory("OkHttp Task", true)
+    )
+
+    override fun executeCoordinator(runnable: Runnable) {
+      coordinatorExecutor.execute(runnable)
+    }
+
+    override fun executeTask(runnable: Runnable) {
+      taskExecutor.execute(runnable)
+    }
+
+    override fun nanoTime() = System.nanoTime()
+
+    override fun coordinatorNotify(taskRunner: TaskRunner) {
+      taskRunner.notify()
+    }
+
+    override fun coordinatorWait(taskRunner: TaskRunner, nanos: Long) {
+      taskRunner.objectWaitNanos(nanos)
+    }
+  }
 }
diff --git a/okhttp/src/test/java/okhttp3/internal/concurrent/TaskRunnerTest.kt b/okhttp/src/test/java/okhttp3/internal/concurrent/TaskRunnerTest.kt
new file mode 100644
index 0000000000..5fb285cfcf
--- /dev/null
+++ b/okhttp/src/test/java/okhttp3/internal/concurrent/TaskRunnerTest.kt
@@ -0,0 +1,509 @@
+/*
+ * Copyright (C) 2019 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.internal.concurrent
+
+import okhttp3.internal.concurrent.TaskRunnerTest.FakeBackend
+import okhttp3.internal.notify
+import okhttp3.internal.threadFactory
+import okhttp3.internal.wait
+import org.assertj.core.api.Assertions.assertThat
+import org.junit.Test
+import java.util.concurrent.Executor
+import java.util.concurrent.SynchronousQueue
+import java.util.concurrent.ThreadPoolExecutor
+import java.util.concurrent.TimeUnit
+
+/**
+ * This test uses [FakeBackend] so that everything is sequential and deterministic.
+ *
+ * All tasks are executed synchronously on the test thread. The coordinator does run in a background
+ * thread. Its [FakeBackend.coordinatorNotify] and [FakeBackend.coordinatorWait] calls don't use
+ * wall-clock time to avoid delays.
+ */
+class TaskRunnerTest {
+  private val backend = FakeBackend()
+  private val taskRunner = TaskRunner(backend)
+  private val log = mutableListOf<String>()
+  private val redQueue = taskRunner.newQueue("red")
+  private val blueQueue = taskRunner.newQueue("blue")
+  private val greenQueue = taskRunner.newQueue("green")
+
+  init {
+    backend.taskRunner = taskRunner
+  }
+
+  @Test fun executeDelayed() {
+    redQueue.schedule(object : Task("task", false) {
+      override fun runOnce(): Long {
+        log += "run@${backend.nanoTime()}"
+        return -1L
+      }
+    }, 100L)
+
+    backend.advanceUntil(0L)
+    assertThat(log).containsExactly()
+
+    backend.advanceUntil(99L)
+    assertThat(log).containsExactly()
+
+    backend.advanceUntil(100L)
+    assertThat(log).containsExactly("run@100")
+
+    backend.assertNoMoreTasks()
+  }
+
+  @Test fun executeRepeated() {
+    redQueue.schedule(object : Task("task", false) {
+      val delays = mutableListOf(50L, 150L, -1L)
+      override fun runOnce(): Long {
+        log += "run@${backend.nanoTime()}"
+        return delays.removeAt(0)
+      }
+    }, 100L)
+
+    backend.advanceUntil(0L)
+    assertThat(log).containsExactly()
+
+    backend.advanceUntil(100L)
+    assertThat(log).containsExactly("run@100")
+
+    backend.advanceUntil(150L)
+    assertThat(log).containsExactly("run@100", "run@150")
+
+    backend.advanceUntil(299L)
+    assertThat(log).containsExactly("run@100", "run@150")
+
+    backend.advanceUntil(300L)
+    assertThat(log).containsExactly("run@100", "run@150", "run@300")
+
+    backend.assertNoMoreTasks()
+  }
+
+  /** Repeat with a delay of 200 but schedule with a delay of 50. The schedule wins. */
+  @Test fun executeScheduledEarlierReplacesRepeatedLater() {
+    redQueue.schedule(object : Task("task", false) {
+      val schedules = mutableListOf(50L)
+      val delays = mutableListOf(200L, -1L)
+      override fun runOnce(): Long {
+        log += "run@${backend.nanoTime()}"
+        if (schedules.isNotEmpty()) {
+          redQueue.schedule(this, schedules.removeAt(0))
+        }
+        return delays.removeAt(0)
+      }
+    }, 100L)
+
+    backend.advanceUntil(0L)
+    assertThat(log).isEmpty()
+
+    backend.advanceUntil(100L)
+    assertThat(log).containsExactly("run@100")
+
+    backend.advanceUntil(150L)
+    assertThat(log).containsExactly("run@100", "run@150")
+
+    backend.assertNoMoreTasks()
+  }
+
+  /** Schedule with a delay of 200 but repeat with a delay of 50. The repeat wins. */
+  @Test fun executeRepeatedEarlierReplacesScheduledLater() {
+    redQueue.schedule(object : Task("task", false) {
+      val schedules = mutableListOf(200L)
+      val delays = mutableListOf(50L, -1L)
+      override fun runOnce(): Long {
+        log += "run@${backend.nanoTime()}"
+        if (schedules.isNotEmpty()) {
+          redQueue.schedule(this, schedules.removeAt(0))
+        }
+        return delays.removeAt(0)
+      }
+    }, 100L)
+
+    backend.advanceUntil(0L)
+    assertThat(log).isEmpty()
+
+    backend.advanceUntil(100L)
+    assertThat(log).containsExactly("run@100")
+
+    backend.advanceUntil(150L)
+    assertThat(log).containsExactly("run@100", "run@150")
+
+    backend.assertNoMoreTasks()
+  }
+
+  @Test fun cancelReturnsTruePreventsNextExecution() {
+    redQueue.schedule(object : Task("task", false) {
+      override fun runOnce(): Long {
+        log += "run@${backend.nanoTime()}"
+        return -1L
+      }
+
+      override fun tryCancel(): Boolean {
+        log += "cancel@${backend.nanoTime()}"
+        return true
+      }
+    }, 100L)
+
+    backend.advanceUntil(0L)
+    assertThat(log).isEmpty()
+
+    redQueue.cancelAll()
+
+    backend.advanceUntil(99L)
+    assertThat(log).containsExactly("cancel@99")
+
+    backend.assertNoMoreTasks()
+  }
+
+  @Test fun cancelReturnsFalseDoesNotCancel() {
+    redQueue.schedule(object : Task("task", false) {
+      override fun runOnce(): Long {
+        log += "run@${backend.nanoTime()}"
+        return -1L
+      }
+
+      override fun tryCancel(): Boolean {
+        log += "cancel@${backend.nanoTime()}"
+        return false
+      }
+    }, 100L)
+
+    backend.advanceUntil(0L)
+    assertThat(log).isEmpty()
+
+    redQueue.cancelAll()
+
+    backend.advanceUntil(99L)
+    assertThat(log).containsExactly("cancel@99")
+
+    backend.advanceUntil(100L)
+    assertThat(log).containsExactly("cancel@99", "run@100")
+
+    backend.assertNoMoreTasks()
+  }
+
+  @Test fun cancelWhileExecutingPreventsRepeat() {
+    redQueue.schedule(object : Task("task", false) {
+      override fun runOnce(): Long {
+        log += "run@${backend.nanoTime()}"
+        redQueue.cancelAll()
+        return 100L
+      }
+
+      override fun tryCancel(): Boolean {
+        log += "cancel@${backend.nanoTime()}"
+        return true
+      }
+    }, 100L)
+
+    backend.advanceUntil(0L)
+    assertThat(log).isEmpty()
+
+    backend.advanceUntil(100L)
+    assertThat(log).containsExactly("run@100", "cancel@100")
+
+    backend.assertNoMoreTasks()
+  }
+
+  @Test fun cancelWhileExecutingDoesNothingIfTaskDoesNotRepeat() {
+    redQueue.schedule(object : Task("task", false) {
+      override fun runOnce(): Long {
+        log += "run@${backend.nanoTime()}"
+        redQueue.cancelAll()
+        return -1L
+      }
+
+      override fun tryCancel(): Boolean {
+        log += "cancel@${backend.nanoTime()}"
+        return true
+      }
+    }, 100L)
+
+    backend.advanceUntil(0L)
+    assertThat(log).isEmpty()
+
+    backend.advanceUntil(100L)
+    assertThat(log).containsExactly("run@100")
+
+    backend.assertNoMoreTasks()
+  }
+
+  /** Inspect how many runnables have been enqueued. If none then we're truly sequential. */
+  @Test fun singleQueueIsSerial() {
+    redQueue.schedule(object : Task("task one", false) {
+      override fun runOnce(): Long {
+        log += "one:run@${backend.nanoTime()} tasksSize=${backend.tasksSize}"
+        return -1L
+      }
+    }, 100L)
+
+    redQueue.schedule(object : Task("task two", false) {
+      override fun runOnce(): Long {
+        log += "two:run@${backend.nanoTime()} tasksSize=${backend.tasksSize}"
+        return -1L
+      }
+    }, 100L)
+
+    redQueue.schedule(object : Task("task three", false) {
+      override fun runOnce(): Long {
+        log += "three:run@${backend.nanoTime()} tasksSize=${backend.tasksSize}"
+        return -1L
+      }
+    }, 100L)
+
+    backend.advanceUntil(0L)
+    assertThat(log).isEmpty()
+
+    backend.advanceUntil(100L)
+    assertThat(log).containsExactly(
+        "one:run@100 tasksSize=0",
+        "two:run@100 tasksSize=0",
+        "three:run@100 tasksSize=0"
+    )
+
+    backend.assertNoMoreTasks()
+  }
+
+  /** Inspect how many runnables have been enqueued. If non-zero then we're truly parallel. */
+  @Test fun differentQueuesAreParallel() {
+    redQueue.schedule(object : Task("task one", false) {
+      override fun runOnce(): Long {
+        log += "one:run@${backend.nanoTime()} tasksSize=${backend.tasksSize}"
+        return -1L
+      }
+    }, 100L)
+
+    blueQueue.schedule(object : Task("task two", false) {
+      override fun runOnce(): Long {
+        log += "two:run@${backend.nanoTime()} tasksSize=${backend.tasksSize}"
+        return -1L
+      }
+    }, 100L)
+
+    greenQueue.schedule(object : Task("task three", false) {
+      override fun runOnce(): Long {
+        log += "three:run@${backend.nanoTime()} tasksSize=${backend.tasksSize}"
+        return -1L
+      }
+    }, 100L)
+
+    backend.advanceUntil(0L)
+    assertThat(log).isEmpty()
+
+    backend.advanceUntil(100L)
+    assertThat(log).containsExactly(
+        "one:run@100 tasksSize=2",
+        "two:run@100 tasksSize=1",
+        "three:run@100 tasksSize=0"
+    )
+
+    backend.assertNoMoreTasks()
+  }
+
+  /** Test the introspection method [TaskQueue.scheduledTasks]. */
+  @Test fun scheduledTasks() {
+    redQueue.schedule(object : Task("task one", false) {
+      override fun runOnce(): Long = -1L
+
+      override fun toString() = "one"
+    }, 100L)
+
+    redQueue.schedule(object : Task("task two", false) {
+      override fun runOnce(): Long = -1L
+
+      override fun toString() = "two"
+    }, 200L)
+
+    assertThat(redQueue.scheduledTasks.toString()).isEqualTo("[one, two]")
+  }
+
+  /**
+   * We don't track the active task in scheduled tasks. This behavior might be a mistake, but it's
+   * cumbersome to implement properly because the active task might be a cancel.
+   */
+  @Test fun scheduledTasksDoesNotIncludeRunningTask() {
+    redQueue.schedule(object : Task("task one", false) {
+      val schedules = mutableListOf(200L)
+      override fun runOnce(): Long {
+        if (schedules.isNotEmpty()) {
+          redQueue.schedule(this, schedules.removeAt(0)) // Add it at the end also.
+        }
+        log += "scheduledTasks=${redQueue.scheduledTasks}"
+        return -1L
+      }
+
+      override fun toString() = "one"
+    }, 100L)
+
+    redQueue.schedule(object : Task("task two", false) {
+      override fun runOnce(): Long {
+        log += "scheduledTasks=${redQueue.scheduledTasks}"
+        return -1L
+      }
+
+      override fun toString() = "two"
+    }, 200L)
+
+    backend.advanceUntil(100L)
+    assertThat(log).containsExactly(
+        "scheduledTasks=[two, one]"
+    )
+
+    backend.advanceUntil(200L)
+    assertThat(log).containsExactly(
+        "scheduledTasks=[two, one]",
+        "scheduledTasks=[one]"
+    )
+
+    backend.advanceUntil(300L)
+    assertThat(log).containsExactly(
+        "scheduledTasks=[two, one]",
+        "scheduledTasks=[one]",
+        "scheduledTasks=[]"
+    )
+
+    backend.assertNoMoreTasks()
+  }
+
+  /**
+   * The runner doesn't hold references to its queues! Otherwise we'd need a mechanism to clean them
+   * up when they're no longer needed and that's annoying. Instead the task runner only tracks which
+   * queues have work scheduled.
+   */
+  @Test fun activeQueuesContainsOnlyQueuesWithScheduledTasks() {
+    redQueue.schedule(object : Task("task one", false) {
+      override fun runOnce() = -1L
+    }, 100L)
+
+    blueQueue.schedule(object : Task("task two", false) {
+      override fun runOnce() = -1L
+    }, 200L)
+
+    backend.advanceUntil(0L)
+    assertThat(taskRunner.activeQueues()).containsExactly(redQueue, blueQueue)
+
+    backend.advanceUntil(100L)
+    assertThat(taskRunner.activeQueues()).containsExactly(blueQueue)
+
+    backend.advanceUntil(200L)
+    assertThat(taskRunner.activeQueues()).isEmpty()
+
+    backend.assertNoMoreTasks()
+  }
+
+  class FakeBackend : TaskRunner.Backend {
+    private val coordinatorExecutor: Executor = ThreadPoolExecutor(
+        0, // corePoolSize.
+        1, // maximumPoolSize.
+        100, TimeUnit.MILLISECONDS, // keepAliveTime.
+        SynchronousQueue(),
+        threadFactory("TaskRunner.FakeBackend", true)
+    )
+    private var coordinatorToExecute: Runnable? = null
+    private val tasks = mutableListOf<Runnable>()
+
+    /** How many tasks can be executed immediately. */
+    val tasksSize: Int get() = tasks.size
+
+    /** The task runner to lock on. */
+    lateinit var taskRunner: TaskRunner
+
+    /** Guarded by taskRunner. */
+    private var nanoTime = 0L
+
+    /** Guarded by taskRunner. Time at which we should yield execution to the coordinator. */
+    private var coordinatorWaitingUntilTime = Long.MAX_VALUE
+
+    override fun executeCoordinator(runnable: Runnable) {
+      check(coordinatorToExecute == null)
+      coordinatorToExecute = Runnable {
+        runnable.run()
+        synchronized(taskRunner) {
+          coordinatorWaitingUntilTime = Long.MAX_VALUE
+          taskRunner.notify() // Release the waiting advanceUntil() or runRunnables() call.
+        }
+      }
+    }
+
+    override fun executeTask(runnable: Runnable) {
+      check(Thread.holdsLock(taskRunner))
+      tasks += runnable
+    }
+
+    override fun nanoTime(): Long {
+      check(Thread.holdsLock(taskRunner))
+      return nanoTime
+    }
+
+    override fun coordinatorNotify(taskRunner: TaskRunner) {
+      check(Thread.holdsLock(taskRunner))
+      coordinatorWaitingUntilTime = nanoTime
+    }
+
+    override fun coordinatorWait(taskRunner: TaskRunner, nanos: Long) {
+      check(Thread.holdsLock(taskRunner))
+
+      coordinatorWaitingUntilTime = if (nanos < Long.MAX_VALUE) nanoTime + nanos else Long.MAX_VALUE
+      if (nanoTime < coordinatorWaitingUntilTime) {
+        // Stall because there's no work to do.
+        taskRunner.notify()
+        taskRunner.wait()
+      }
+      coordinatorWaitingUntilTime = Long.MAX_VALUE
+    }
+
+    /** Advance the simulated clock and run anything ready at the new time. */
+    fun advanceUntil(newTime: Long) {
+      check(!Thread.holdsLock(taskRunner))
+
+      synchronized(taskRunner) {
+        nanoTime = newTime
+
+        while (true) {
+          runRunnables()
+
+          if (coordinatorWaitingUntilTime <= nanoTime) {
+            // Let the coordinator do its business at the new time.
+            taskRunner.notify()
+            taskRunner.wait()
+          } else {
+            return
+          }
+        }
+      }
+    }
+
+    /** Returns true if anything was executed. */
+    private fun runRunnables() {
+      if (coordinatorToExecute != null) {
+        coordinatorExecutor.execute(coordinatorToExecute!!)
+        coordinatorToExecute = null
+        taskRunner.wait() // Wait for the coordinator to stall.
+      }
+
+      while (tasks.isNotEmpty()) {
+        val task = tasks.removeAt(0)
+        task.run()
+      }
+    }
+
+    fun assertNoMoreTasks() {
+      assertThat(coordinatorToExecute).isNull()
+      assertThat(tasks).isEmpty()
+      assertThat(coordinatorWaitingUntilTime).isEqualTo(Long.MAX_VALUE)
+    }
+  }
+}
