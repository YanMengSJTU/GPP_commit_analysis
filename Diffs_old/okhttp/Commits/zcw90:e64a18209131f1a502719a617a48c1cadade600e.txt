diff --git a/.circleci/config.yml b/.circleci/config.yml
index afe75ce9d5..9f7d51ff11 100644
--- a/.circleci/config.yml
+++ b/.circleci/config.yml
@@ -6,6 +6,9 @@ commands:
     parameters:
       platform:
         type: string
+      testjdk:
+        type: string
+        default: ""
     steps:
       - restore_cache:
           keys:
@@ -17,7 +20,7 @@ commands:
           name: Run tests
           command: ./gradlew --build-cache --parallel --continue test
           environment:
-            GRADLE_OPTS: -Dorg.gradle.daemon=false -Dokhttp.platform=<< parameters.platform >> -Dorg.gradle.workers.max=3 -Xmx1G
+            GRADLE_OPTS: -Dorg.gradle.daemon=false -Dokhttp.platform=<< parameters.platform >> -Dorg.gradle.workers.max=3 -Xmx1G << parameters.testjdk >>
 
       - save_cache:
           paths:
@@ -51,7 +54,7 @@ commands:
 jobs:
   compile:
     docker:
-      - image: circleci/openjdk:8u222-jdk-stretch
+      - image: circleci/openjdk:11.0.4-jdk-stretch
 
     environment:
       JVM_OPTS: -Xmx1g
@@ -70,7 +73,7 @@ jobs:
           name: Run tests
           command: ./gradlew --parallel --build-cache test
           environment:
-            GRADLE_OPTS: -Dorg.gradle.daemon=false -Dorg.gradle.workers.max=3 -Xmx1G
+            GRADLE_OPTS: -Dorg.gradle.daemon=false -Dokhttp.platform=jdk9 -Dorg.gradle.workers.max=3 -Xmx1G
 
       - save_cache:
           paths:
@@ -79,9 +82,9 @@ jobs:
           # Under normal usage, saves compiled results from master at least once a day
           key: v4-{{ .Branch }}-{{ .Environment.CIRCLE_JOB }}-{{ epoch }}
 
-  checkjdk8:
+  checkjdk11:
     docker:
-      - image: circleci/openjdk:8u222-jdk-stretch
+      - image: circleci/openjdk:11.0.4-jdk-stretch
 
     environment:
       JVM_OPTS: -Xmx1g
@@ -114,7 +117,7 @@ jobs:
 
   testjdk8:
     docker:
-      - image: circleci/openjdk:8u222-jdk-stretch
+      - image: circleci/openjdk:11.0.4-jdk-stretch
 
     environment:
       JVM_OPTS: -Xmx1g
@@ -125,10 +128,11 @@ jobs:
 
       - runtests:
           platform: jdk8
+          testjdk: -Dtest.java.home=/usr/lib/jvm/java-8-openjdk-amd64
 
   testjdk8alpn:
     docker:
-      - image: circleci/openjdk:8u222-jdk-stretch
+      - image: circleci/openjdk:11.0.4-jdk-stretch
 
     environment:
       JVM_OPTS: -Xmx1g
@@ -139,10 +143,11 @@ jobs:
 
       - runtests:
           platform: jdk8alpn
+          testjdk: -Dtest.java.home=/usr/lib/jvm/java-8-openjdk-amd64 -Dalpn.boot.version=8.1.13.v20181017
 
   testopenjsse:
     docker:
-      - image: circleci/openjdk:8u222-jdk-stretch
+      - image: circleci/openjdk:11.0.4-jdk-stretch
 
     environment:
       JVM_OPTS: -Xmx1g
@@ -153,6 +158,7 @@ jobs:
 
       - runtests:
           platform: openjsse
+          testjdk: -Dtest.java.home=/usr/lib/jvm/java-8-openjdk-amd64
 
   testjdk11:
     docker:
@@ -205,7 +211,7 @@ workflows:
           filters:
             branches:
               only: master
-      - checkjdk8:
+      - checkjdk11:
           filters:
             branches:
               ignore:
@@ -245,7 +251,7 @@ workflows:
               only: master
     jobs:
       - compile
-      - checkjdk8:
+      - checkjdk11:
           requires:
             - compile
       - testjdk8:
diff --git a/CHANGELOG.md b/CHANGELOG.md
index 887bbc5e04..26fa988932 100644
--- a/CHANGELOG.md
+++ b/CHANGELOG.md
@@ -1,6 +1,73 @@
 Change Log
 ==========
 
+## Version 4.2.2
+
+_2019-10-06_
+
+ *  Fix: When closing a canceled HTTP/2 stream, don't send the `END_STREAM` flag. This could cause
+    the server to incorrectly interpret the stream as having completed normally. This is most useful
+    when a request body needs to cancel its own call.
+
+
+## Version 4.2.1
+
+_2019-10-02_
+
+ *  Fix: In 4.1.0 we introduced a performance regression that prevented connections from being
+    pooled in certain situations. We have good test coverage for connection pooling but we missed
+    this because it only occurs if you have proxy configured and you share a connection pool among
+    multiple `OkHttpClient` instances.
+
+    This particularly-subtle bug was caused by us assigning each `OkHttpClient` instance its own
+    `NullProxySelector` when an explicit proxy is configured. But we don't share connections when
+    the proxy selectors are different. Ugh!
+
+
+## Version 4.2.0
+
+_2019-09-10_
+
+ *  New: API to decode a certificate and private key to create a `HeldCertificate`. This accepts a
+    string containing both a certificate and PKCS #8-encoded private key.
+
+    ```kotlin
+    val heldCertificate = HeldCertificate.decode("""
+        |-----BEGIN CERTIFICATE-----
+        |MIIBYTCCAQegAwIBAgIBKjAKBggqhkjOPQQDAjApMRQwEgYDVQQLEwtlbmdpbmVl
+        |cmluZzERMA8GA1UEAxMIY2FzaC5hcHAwHhcNNzAwMTAxMDAwMDA1WhcNNzAwMTAx
+        |MDAwMDEwWjApMRQwEgYDVQQLEwtlbmdpbmVlcmluZzERMA8GA1UEAxMIY2FzaC5h
+        |cHAwWTATBgcqhkjOPQIBBggqhkjOPQMBBwNCAASda8ChkQXxGELnrV/oBnIAx3dD
+        |ocUOJfdz4pOJTP6dVQB9U3UBiW5uSX/MoOD0LL5zG3bVyL3Y6pDwKuYvfLNhoyAw
+        |HjAcBgNVHREBAf8EEjAQhwQBAQEBgghjYXNoLmFwcDAKBggqhkjOPQQDAgNIADBF
+        |AiAyHHg1N6YDDQiY920+cnI5XSZwEGhAtb9PYWO8bLmkcQIhAI2CfEZf3V/obmdT
+        |yyaoEufLKVXhrTQhRfodTeigi4RX
+        |-----END CERTIFICATE-----
+        |-----BEGIN PRIVATE KEY-----
+        |MEECAQAwEwYHKoZIzj0CAQYIKoZIzj0DAQcEJzAlAgEBBCA7ODT0xhGSNn4ESj6J
+        |lu/GJQZoU9lDrCPeUcQ28tzOWw==
+        |-----END PRIVATE KEY-----
+        """.trimMargin())
+    val handshakeCertificates = HandshakeCertificates.Builder()
+        .heldCertificate(heldCertificate)
+        .build()
+    val server = MockWebServer()
+    server.useHttps(handshakeCertificates.sslSocketFactory(), false)
+    ```
+
+    Get these strings with `HeldCertificate.certificatePem()` and `privateKeyPkcs8Pem()`.
+
+ *  Fix: Handshake now returns peer certificates in canonical order: each certificate is signed by
+    the certificate that follows and the last certificate is signed by a trusted root.
+
+ *  Fix: Don't lose HTTP/2 flow control bytes when incoming data races with a stream close. If this
+    happened enough then eventually the connection would stall.
+
+ *  Fix: Acknowledge and apply inbound HTTP/2 settings atomically. Previously we had a race where we
+    could use new flow control capacity before acknowledging it, causing strict HTTP/2 servers to
+    fail the call.
+
+
 ## Version 4.1.1
 
 _2019-09-05_
@@ -34,7 +101,7 @@ _2019-08-12_
  *  New: Permit [new WebSocket response codes][iana_websocket]: 1012 (Service Restart), 1013 (Try
     Again Later), and 1014 (invalid response from the upstream).
  *  New: Build with Kotlin 1.3.41, BouncyCastle 1.62, and Conscrypt 2.2.1.
- *  Fix: Recover gracefully when a a coalesced connection immediately goes unhealthy.
+ *  Fix: Recover gracefully when a coalesced connection immediately goes unhealthy.
  *  Fix: Defer the `SecurityException` when looking up the default proxy selector.
  *  Fix: Don't use brackets formatting IPv6 host names in MockWebServer.
  *  Fix: Don't permit cache iterators to remove entries that are being written.
diff --git a/README.md b/README.md
index 4077be843d..b70a70c3a5 100644
--- a/README.md
+++ b/README.md
@@ -55,7 +55,7 @@ public static final MediaType JSON
 OkHttpClient client = new OkHttpClient();
 
 String post(String url, String json) throws IOException {
-  RequestBody body = RequestBody.create(json, JSON);
+  RequestBody body = RequestBody.create(JSON, json);
   Request request = new Request.Builder()
       .url(url)
       .post(body)
@@ -100,7 +100,7 @@ Releases
 Our [change log][changelog] has release history.
 
 ```kotlin
-implementation("com.squareup.okhttp3:okhttp:4.1.1")
+implementation("com.squareup.okhttp3:okhttp:4.2.1")
 ```
 
 Snapshot builds are [available][snap].
@@ -120,7 +120,7 @@ MockWebServer
 OkHttp includes a library for testing HTTP, HTTPS, and HTTP/2 clients.
 
 ```kotlin
-testImplementation("com.squareup.okhttp3:mockwebserver:4.1.1")
+testImplementation("com.squareup.okhttp3:mockwebserver:4.2.1")
 ```
 
 
diff --git a/android-test/build.gradle b/android-test/build.gradle
index d521be6791..1f6c8248aa 100644
--- a/android-test/build.gradle
+++ b/android-test/build.gradle
@@ -25,18 +25,26 @@ android {
     versionName "1.0"
 
     testInstrumentationRunner "android.support.test.runner.AndroidJUnitRunner"
+    testInstrumentationRunnerArguments(['notClass': 'org.conscrypt.KitKatPlatformOpenSSLSocketImplAdapter'])
   }
 }
 
 dependencies {
   implementation "org.jetbrains.kotlin:kotlin-stdlib-jdk8:${versions.kotlin}"
+  implementation "org.jetbrains.kotlin:kotlin-reflect:${versions.kotlin}"
   implementation project(':okhttp')
   testImplementation 'junit:junit:4.12'
   androidTestImplementation(project(':okhttp-testing-support')) {
-     exclude group: 'org.openjsse', module: 'openjsse'
+    exclude group: 'org.openjsse', module: 'openjsse'
+    exclude group: 'org.conscrypt', module: 'conscrypt-openjdk-uber'
   }
+  androidTestImplementation "org.conscrypt:conscrypt-android:2.2.1"
   androidTestImplementation project(':mockwebserver')
   androidTestImplementation project(':okhttp-tls')
+  androidTestImplementation project(':okhttp-dnsoverhttps')
+  androidTestImplementation project(':okhttp-logging-interceptor')
   androidTestImplementation 'com.android.support.test:runner:1.0.2'
   androidTestImplementation 'com.android.support.test.espresso:espresso-core:3.0.2'
+  androidTestImplementation 'com.squareup.moshi:moshi:1.8.0'
+  androidTestImplementation 'com.squareup.moshi:moshi-kotlin:1.8.0'
 }
diff --git a/android-test/src/androidTest/java/okhttp/android/test/OkHttpTest.kt b/android-test/src/androidTest/java/okhttp/android/test/OkHttpTest.kt
index 3aec4cab37..f605522ee9 100644
--- a/android-test/src/androidTest/java/okhttp/android/test/OkHttpTest.kt
+++ b/android-test/src/androidTest/java/okhttp/android/test/OkHttpTest.kt
@@ -17,19 +17,27 @@ package okhttp.android.test
 
 import android.os.Build
 import android.support.test.runner.AndroidJUnit4
+import com.squareup.moshi.Moshi
+import com.squareup.moshi.kotlin.reflect.KotlinJsonAdapterFactory
 import okhttp3.Call
 import okhttp3.CertificatePinner
 import okhttp3.Connection
 import okhttp3.EventListener
+import okhttp3.HttpUrl.Companion.toHttpUrl
 import okhttp3.OkHttpClient
 import okhttp3.Protocol
 import okhttp3.RecordingEventListener
 import okhttp3.Request
 import okhttp3.TlsVersion
+import okhttp3.dnsoverhttps.DnsOverHttps
+import okhttp3.internal.asFactory
+import okhttp3.internal.platform.Platform
+import okhttp3.logging.LoggingEventListener
 import okhttp3.mockwebserver.MockResponse
 import okhttp3.mockwebserver.MockWebServer
 import okhttp3.tls.internal.TlsUtil.localhost
 import okio.ByteString.Companion.toByteString
+import org.conscrypt.Conscrypt
 import org.junit.After
 import org.junit.Assert.assertEquals
 import org.junit.Assert.assertTrue
@@ -37,13 +45,18 @@ import org.junit.Assert.fail
 import org.junit.Assume.assumeNoException
 import org.junit.Assume.assumeTrue
 import org.junit.Before
+import org.junit.Ignore
 import org.junit.Rule
 import org.junit.Test
 import org.junit.runner.RunWith
 import java.net.InetAddress
 import java.net.UnknownHostException
+import java.security.cert.X509Certificate
+import java.security.Security
 import javax.net.ssl.SSLPeerUnverifiedException
 import javax.net.ssl.SSLSocket
+import okhttp3.internal.platform.AndroidPlatform
+import okhttp3.internal.platform.Android10Platform
 
 /**
  * Run with "./gradlew :android-test:connectedCheck" and make sure ANDROID_SDK_ROOT is set.
@@ -52,6 +65,10 @@ import javax.net.ssl.SSLSocket
 class OkHttpTest {
   private lateinit var client: OkHttpClient
 
+  private val moshi = Moshi.Builder()
+      .add(KotlinJsonAdapterFactory())
+      .build()
+
   @JvmField
   @Rule
   val server = MockWebServer()
@@ -59,8 +76,7 @@ class OkHttpTest {
 
   @Before
   fun createClient() {
-    client = OkHttpClient.Builder()
-        .build()
+    client = OkHttpClient.Builder().build()
   }
 
   @After
@@ -68,6 +84,15 @@ class OkHttpTest {
     client.dispatcher.executorService.shutdownNow()
   }
 
+  @Test
+  fun testPlatform() {
+    if (Build.VERSION.SDK_INT >= 29) {
+      assertTrue(Platform.get() is Android10Platform)
+    } else {
+      assertTrue(Platform.get() is AndroidPlatform)
+    }
+  }
+
   @Test
   fun testRequest() {
     assumeNetwork()
@@ -81,6 +106,41 @@ class OkHttpTest {
     }
   }
 
+  @Test
+  fun testConscryptRequest() {
+    assumeNetwork()
+
+    try {
+      Security.insertProviderAt(Conscrypt.newProviderBuilder().build(), 1)
+
+      val request = Request.Builder().url("https://facebook.com/robots.txt").build()
+
+      var socketClass: String? = null
+
+      client = OkHttpClient.Builder().eventListener(object : EventListener() {
+        override fun connectionAcquired(call: Call, connection: Connection) {
+          socketClass = connection.socket().javaClass.name
+        }
+      }).build()
+
+      val response = client.newCall(request).execute()
+
+      response.use {
+        assertEquals(Protocol.HTTP_2, response.protocol)
+        assertEquals(TlsVersion.TLS_1_3, response.handshake?.tlsVersion)
+        assertEquals(200, response.code)
+        // see https://github.com/google/conscrypt/blob/b9463b2f74df42d85c73715a5f19e005dfb7b802/android/src/main/java/org/conscrypt/Platform.java#L613
+        if (Build.VERSION.SDK_INT >= 24) {
+          assertEquals("org.conscrypt.Java8FileDescriptorSocket", socketClass)
+        } else {
+          assertEquals("org.conscrypt.ConscryptFileDescriptorSocket", socketClass)
+        }
+      }
+    } finally {
+      Security.removeProvider("Conscrypt")
+    }
+  }
+
   @Test
   fun testRequestUsesAndroidConscrypt() {
     assumeNetwork()
@@ -137,6 +197,44 @@ class OkHttpTest {
     }
   }
 
+  data class HowsMySslResults(
+    val unknown_cipher_suite_supported: Boolean,
+    val beast_vuln: Boolean,
+    val session_ticket_supported: Boolean,
+    val tls_compression_supported: Boolean,
+    val ephemeral_keys_supported: Boolean,
+    val rating: String,
+    val tls_version: String,
+    val able_to_detect_n_minus_one_splitting: Boolean,
+    val insecure_cipher_suites: Map<String, List<String>>,
+    val given_cipher_suites: List<String>?
+  )
+
+  @Test
+  @Ignore
+  fun testSSLFeatures() {
+    assumeNetwork()
+
+    val request = Request.Builder().url("https://www.howsmyssl.com/a/check").build()
+
+    val response = client.newCall(request).execute()
+
+    val results = response.use {
+      moshi.adapter(HowsMySslResults::class.java).fromJson(response.body!!.string())!!
+    }
+
+    Platform.get().log("results $results", Platform.WARN)
+
+    assertTrue(results.session_ticket_supported)
+    assertEquals("Probably Okay", results.rating)
+    // TODO map to expected versions automatically, test ignored for now.  Run manually.
+    assertEquals("TLS 1.3", results.tls_version)
+    assertEquals(0, results.insecure_cipher_suites.size)
+
+    assertEquals(TlsVersion.TLS_1_3, response.handshake?.tlsVersion)
+    assertEquals(Protocol.HTTP_2, response.protocol)
+  }
+
   @Test
   fun testMockWebserverRequest() {
     enableTls()
@@ -149,6 +247,8 @@ class OkHttpTest {
 
     response.use {
       assertEquals(200, response.code)
+      assertEquals("CN=localhost",
+          (response.handshake!!.peerCertificates.single() as X509Certificate).subjectDN.name)
     }
   }
 
@@ -197,10 +297,10 @@ class OkHttpTest {
   fun testEventListener() {
     val eventListener = RecordingEventListener()
 
-    client = client.newBuilder().eventListener(eventListener).build()
-
     enableTls()
 
+    client = client.newBuilder().eventListener(eventListener).build()
+
     server.enqueue(MockResponse().setBody("abc1"))
     server.enqueue(MockResponse().setBody("abc2"))
 
@@ -232,6 +332,8 @@ class OkHttpTest {
   fun testSessionReuse() {
     val sessionIds = mutableListOf<String>()
 
+    enableTls()
+
     client = client.newBuilder().eventListener(object : EventListener() {
       override fun connectionAcquired(call: Call, connection: Connection) {
         val sslSocket = connection.socket() as SSLSocket
@@ -240,8 +342,6 @@ class OkHttpTest {
       }
     }).build()
 
-    enableTls()
-
     server.enqueue(MockResponse().setBody("abc1"))
     server.enqueue(MockResponse().setBody("abc2"))
 
@@ -262,6 +362,37 @@ class OkHttpTest {
     assertEquals(sessionIds[0], sessionIds[1])
   }
 
+  @Test
+  fun testDnsOverHttps() {
+    assumeNetwork()
+
+    client = client.newBuilder()
+        .eventListenerFactory(LoggingEventListener.Factory())
+        .build()
+
+    val dohDns = buildCloudflareIp(client)
+    val dohEnabledClient =
+        client.newBuilder().eventListenerFactory(EventListener.NONE.asFactory()).dns(dohDns).build()
+
+    dohEnabledClient.get("https://www.twitter.com/robots.txt")
+    dohEnabledClient.get("https://www.facebook.com/robots.txt")
+  }
+
+  private fun OkHttpClient.get(url: String) {
+    val request = Request.Builder().url(url).build()
+    val response = this.newCall(request).execute()
+
+    response.use {
+      assertEquals(200, response.code)
+    }
+  }
+
+  fun buildCloudflareIp(bootstrapClient: OkHttpClient): DnsOverHttps {
+    return DnsOverHttps.Builder().client(bootstrapClient)
+        .url("https://1.1.1.1/dns-query".toHttpUrl())
+        .build()
+  }
+
   private fun enableTls() {
     client = client.newBuilder()
         .sslSocketFactory(
diff --git a/build.gradle b/build.gradle
index b71f328cc7..e490a1cbfa 100644
--- a/build.gradle
+++ b/build.gradle
@@ -2,7 +2,6 @@ import net.ltgt.gradle.errorprone.CheckSeverity
 
 buildscript {
   ext.versions = [
-      'android': '4.1.1.4',
       'animalSniffer': '1.17',
       'assertj': '3.11.0',
       'bouncycastle': '1.62',
@@ -25,7 +24,7 @@ buildscript {
 
   ext.deps = [
       'picocli': "info.picocli:picocli:${versions.picocli}",
-      'android': "com.google.android:android:${versions.android}",
+      'android': "org.robolectric:android-all:9-robolectric-4913185-2",
       'animalSniffer': "org.codehaus.mojo:animal-sniffer-annotations:${versions.animalSniffer}",
       'assertj': "org.assertj:assertj-core:${versions.assertj}",
       'bouncycastle': "org.bouncycastle:bcprov-jdk15on:${versions.bouncycastle}",
@@ -38,6 +37,7 @@ buildscript {
       'junit': "junit:junit:${versions.junit}",
       'kotlinStdlib': "org.jetbrains.kotlin:kotlin-stdlib:${versions.kotlin}",
       'moshi': "com.squareup.moshi:moshi:${versions.moshi}",
+      'moshiKotlin': "com.squareup.moshi:moshi-kotlin-codegen:${versions.moshi}",
       'okio': "com.squareup.okio:okio:${versions.okio}",
       'openjsse': "org.openjsse:openjsse:${versions.openjsse}"
   ]
@@ -131,12 +131,17 @@ subprojects { project ->
     }
   }
 
-  def platform = System.getProperty("okhttp.platform", "jdk8")
+  def platform = System.getProperty("okhttp.platform", "jdk9")
+  def platformJavaHome = System.getProperty('test.java.home')
 
   test {
     jvmArgs += "-Dlistener=okhttp3.testing.InstallUncaughtExceptionHandlerListener"
     jvmArgs += "-Dokhttp.platform=$platform"
 
+    if (platformJavaHome != null) {
+      executable = "$platformJavaHome/bin/java"
+    }
+
     maxParallelForks Runtime.runtime.availableProcessors() * 2
     testLogging {
       exceptionFormat = 'full'
@@ -211,6 +216,12 @@ tasks.wrapper {
  * https://github.com/xjdr/xio/blob/master/alpn-boot.gradle
  */
 def alpnBootVersion() {
+  def version = System.getProperty('alpn.boot.version')
+
+  if (version != null) {
+    return version
+  }
+
   def javaVersion = System.getProperty("java.version")
   def patchVersionMatcher = (javaVersion =~ /1\.8\.0_(\d+)(-.*)?/)
   if (!patchVersionMatcher.find()) return null
diff --git a/deploy_website.sh b/deploy_website.sh
index 202321d658..43fb0f485f 100755
--- a/deploy_website.sh
+++ b/deploy_website.sh
@@ -23,6 +23,7 @@ cd $DIR
 # Generate the API docs
 ./gradlew \
   :mockwebserver:dokka \
+  :okhttp-brotli:dokka \
   :okhttp-dnsoverhttps:dokka \
   :okhttp-logging-interceptor:dokka \
   :okhttp-sse:dokka \
@@ -30,6 +31,26 @@ cd $DIR
   :okhttp-urlconnection:dokka \
   :okhttp:dokka
 
+# Dokka filenames like `-http-url/index.md` don't work well with MkDocs <title> tags.
+# Assign metadata to the file's first Markdown heading.
+# https://www.mkdocs.org/user-guide/writing-your-docs/#meta-data
+title_markdown_file() {
+  TITLE_PATTERN="s/^[#]+ *(.*)/title: \1 - OkHttp/"
+  echo "---"                                                     > "$1.fixed"
+  cat $1 | sed -E "$TITLE_PATTERN" | grep "title: " | head -n 1 >> "$1.fixed"
+  echo "---"                                                    >> "$1.fixed"
+  echo                                                          >> "$1.fixed"
+  cat $1                                                        >> "$1.fixed"
+  mv "$1.fixed" "$1"
+}
+
+set +x
+for MARKDOWN_FILE in $(find docs/4.x/ -name '*.md'); do
+  echo $MARKDOWN_FILE
+  title_markdown_file $MARKDOWN_FILE
+done
+set -x
+
 # Copy in special files that GitHub wants in the project root.
 cat README.md | grep -v 'project website' > docs/index.md
 cp CHANGELOG.md docs/changelog.md
diff --git a/docs/changelog_3x.md b/docs/changelog_3x.md
index 4da5a56fde..a54dc7d4f7 100644
--- a/docs/changelog_3x.md
+++ b/docs/changelog_3x.md
@@ -1,6 +1,32 @@
 OkHttp 3.x Change Log
 =====================
 
+## Version 3.14.4
+
+_2019-09-29_
+
+ *  Fix: Cancel calls that fail due to unexpected exceptions. We had a bug where an enqueued call
+    would never call back if it crashed with an unchecked throwable, such as a
+    `NullPointerException` or `OutOfMemoryError`. We now call `Callback.onFailure()` with an
+    `IOException` that reports the call as canceled. The triggering exception is still delivered to
+    the thread's `UncaughtExceptionHandler`.
+ *  Fix: Don't evict incomplete entries when iterating the cache. We had a bug where iterating
+    `Cache.urls()` would prevent in-flight entries from being written.
+
+
+## Version 3.14.3
+
+_2019-09-10_
+
+ *  Fix: Don't lose HTTP/2 flow control bytes when incoming data races with a stream close. If this
+    happened enough then eventually the connection would stall.
+
+ *  Fix: Acknowledge and apply inbound HTTP/2 settings atomically. Previously we had a race where we
+    could use new flow control capacity before acknowledging it, causing strict HTTP/2 servers to
+    fail the call.
+
+ *  Fix: Recover gracefully when a coalesced connection immediately goes unhealthy.
+
 ## Version 3.14.2
 
 _2019-05-19_
@@ -150,6 +176,31 @@ _2019-02-04_
  *  New: Log the TLS handshake in `LoggingEventListener`.
 
 
+## Version 3.12.6
+
+_2019-09-29_
+
+ *  Fix: Cancel calls that fail due to unexpected exceptions. We had a bug where an enqueued call
+    would never call back if it crashed with an unchecked throwable, such as a
+    `NullPointerException` or `OutOfMemoryError`. We now call `Callback.onFailure()` with an
+    `IOException` that reports the call as canceled. The triggering exception is still delivered to
+    the thread's `UncaughtExceptionHandler`.
+ *  Fix: Don't evict incomplete entries when iterating the cache. We had a bug where iterating
+    `Cache.urls()` would prevent in-flight entries from being written.
+
+
+## Version 3.12.5
+
+_2019-09-10_
+
+ *  Fix: Don't lose HTTP/2 flow control bytes when incoming data races with a stream close. If this
+    happened enough then eventually the connection would stall.
+
+ *  Fix: Acknowledge and apply inbound HTTP/2 settings atomically. Previously we had a race where we
+    could use new flow control capacity before acknowledging it, causing strict HTTP/2 servers to
+    fail the call.
+
+
 ## Version 3.12.4
 
 _2019-09-04_
diff --git a/docs/connections.md b/docs/connections.md
index 5c2f525883..37bba50de4 100644
--- a/docs/connections.md
+++ b/docs/connections.md
@@ -3,7 +3,7 @@ Connections
 
 Although you provide only the URL, OkHttp plans its connection to your webserver using three types: URL, Address, and Route.
 
-#### [URLs](http://square.github.io/okhttp/4.x/okhttp/okhttp3/-http-url/)
+### [URLs](http://square.github.io/okhttp/4.x/okhttp/okhttp3/-http-url/)
 
 URLs (like `https://github.com/square/okhttp`) are fundamental to HTTP and the Internet. In addition to being a universal, decentralized naming scheme for everything on the web, they also specify how to access web resources.
 
@@ -14,7 +14,7 @@ URLs are abstract:
 
 They're also concrete: each URL identifies a specific path (like `/square/okhttp`) and query (like `?q=sharks&lang=en`). Each webserver hosts many URLs.
 
-#### [Addresses](http://square.github.io/okhttp/4.x/okhttp/okhttp3/-address/)
+### [Addresses](http://square.github.io/okhttp/4.x/okhttp/okhttp3/-address/)
 
 Addresses specify a webserver (like `github.com`) and all of the **static** configuration necessary to connect to that server: the port number, HTTPS settings, and preferred network protocols (like HTTP/2 or SPDY).
 
@@ -22,13 +22,13 @@ URLs that share the same address may also share the same underlying TCP socket c
 
 In OkHttp some fields of the address come from the URL (scheme, hostname, port) and the rest come from the [OkHttpClient](http://square.github.io/okhttp/4.x/okhttp/okhttp3/-ok-http-client/).
 
-#### [Routes](http://square.github.io/okhttp/4.x/okhttp/okhttp3/-route/)
+### [Routes](http://square.github.io/okhttp/4.x/okhttp/okhttp3/-route/)
 
 Routes supply the **dynamic** information necessary to actually connect to a webserver. This is the specific IP address to attempt (as discovered by a DNS query), the exact proxy server to use (if a [ProxySelector](http://developer.android.com/reference/java/net/ProxySelector.html) is in use), and which version of TLS to negotiate (for HTTPS connections).
 
 There may be many routes for a single address. For example, a webserver that is hosted in multiple datacenters may yield multiple IP addresses in its DNS response.
 
-#### [Connections](http://square.github.io/okhttp/4.x/okhttp/okhttp3/-connection/)
+### [Connections](http://square.github.io/okhttp/4.x/okhttp/okhttp3/-connection/)
 
 When you request a URL with OkHttp, here's what it does:
 
diff --git a/docs/https.md b/docs/https.md
index 142b7c3d9c..a4c8a0301b 100644
--- a/docs/https.md
+++ b/docs/https.md
@@ -43,46 +43,123 @@ OkHttpClient client = new OkHttpClient.Builder()
     .build();
 ```
 
-#### [Certificate Pinning](https://github.com/square/okhttp/blob/master/samples/guide/src/main/java/okhttp3/recipes/CertificatePinning.java)
+### Certificate Pinning ([.kt][CertificatePinningKotlin], [.java][CertificatePinningJava]) 
 
 By default, OkHttp trusts the certificate authorities of the host platform. This strategy maximizes connectivity, but it is subject to certificate authority attacks such as the [2011 DigiNotar attack](http://www.computerworld.com/article/2510951/cybercrime-hacking/hackers-spied-on-300-000-iranians-using-fake-google-certificate.html). It also assumes your HTTPS servers’ certificates are signed by a certificate authority.
 
 Use [CertificatePinner](http://square.github.io/okhttp/4.x/okhttp/okhttp3/-certificate-pinner/) to restrict which certificates and certificate authorities are trusted. Certificate pinning increases security, but limits your server team’s abilities to update their TLS certificates. **Do not use certificate pinning without the blessing of your server’s TLS administrator!**
 
-```java
-  public CertificatePinning() {
-    client = new OkHttpClient.Builder()
-        .certificatePinner(new CertificatePinner.Builder()
-            .add("publicobject.com", "sha256/afwiKY3RxoMmLkuRW1l7QsPZTJPwDS2pdDROQjXw8ig=")
-            .build())
-        .build();
+```Kotlin tab=
+  private val client = OkHttpClient.Builder()
+      .certificatePinner(
+          CertificatePinner.Builder()
+              .add("publicobject.com", "sha256/afwiKY3RxoMmLkuRW1l7QsPZTJPwDS2pdDROQjXw8ig=")
+              .build())
+      .build()
+
+  fun run() {
+    val request = Request.Builder()
+        .url("https://publicobject.com/robots.txt")
+        .build()
+
+    client.newCall(request).execute().use { response ->
+      if (!response.isSuccessful) throw IOException("Unexpected code $response")
+
+      for (certificate in response.handshake!!.peerCertificates) {
+        println(CertificatePinner.pin(certificate))
+      }
+    }
   }
+```
+
+```Java tab=
+  private final OkHttpClient client = new OkHttpClient.Builder()
+      .certificatePinner(
+          new CertificatePinner.Builder()
+              .add("publicobject.com", "sha256/afwiKY3RxoMmLkuRW1l7QsPZTJPwDS2pdDROQjXw8ig=")
+              .build())
+      .build();
 
   public void run() throws Exception {
     Request request = new Request.Builder()
         .url("https://publicobject.com/robots.txt")
         .build();
 
-    Response response = client.newCall(request).execute();
-    if (!response.isSuccessful()) throw new IOException("Unexpected code " + response);
+    try (Response response = client.newCall(request).execute()) {
+      if (!response.isSuccessful()) throw new IOException("Unexpected code " + response);
 
-    for (Certificate certificate : response.handshake().peerCertificates()) {
-      System.out.println(CertificatePinner.pin(certificate));
+      for (Certificate certificate : response.handshake().peerCertificates()) {
+        System.out.println(CertificatePinner.pin(certificate));
+      }
     }
   }
 ```
 
-#### [Customizing Trusted Certificates](https://github.com/square/okhttp/blob/master/samples/guide/src/main/java/okhttp3/recipes/CustomTrust.java)
+### Customizing Trusted Certificates ([.kt][CustomTrustKotlin], [.java][CustomTrustJava])
 
 The full code sample shows how to replace the host platform’s certificate authorities with your own set. As above, **do not use custom certificates without the blessing of your server’s TLS administrator!**
 
-```java
+```Kotlin tab=
+  private val client: OkHttpClient
+
+  init {
+    val trustManager = trustManagerForCertificates(trustedCertificatesInputStream())
+    val sslContext = SSLContext.getInstance("TLS")
+    sslContext.init(null, arrayOf<TrustManager>(trustManager), null)
+    val sslSocketFactory = sslContext.socketFactory
+
+    client = OkHttpClient.Builder()
+        .sslSocketFactory(sslSocketFactory, trustManager)
+        .build()
+  }
+
+  fun run() {
+    val request = Request.Builder()
+        .url("https://publicobject.com/helloworld.txt")
+        .build()
+
+    client.newCall(request).execute().use { response ->
+      if (!response.isSuccessful) throw IOException("Unexpected code $response")
+
+      for ((name, value) in response.headers) {
+        println("$name: $value")
+      }
+
+      println(response.body!!.string())
+    }
+  }
+
+  /**
+   * Returns an input stream containing one or more certificate PEM files. This implementation just
+   * embeds the PEM files in Java strings; most applications will instead read this from a resource
+   * file that gets bundled with the application.
+   */
+  private fun trustedCertificatesInputStream(): InputStream {
+    ... // Full source omitted. See sample.
+  }
+
+  private fun trustManagerForCertificates(inputStream: InputStream): X509TrustManager {
+    ... // Full source omitted. See sample.
+  }
+```
+
+```Java tab=
   private final OkHttpClient client;
 
   public CustomTrust() {
-    SSLContext sslContext = sslContextForTrustedCertificates(trustedCertificatesInputStream());
+    X509TrustManager trustManager;
+    SSLSocketFactory sslSocketFactory;
+    try {
+      trustManager = trustManagerForCertificates(trustedCertificatesInputStream());
+      SSLContext sslContext = SSLContext.getInstance("TLS");
+      sslContext.init(null, new TrustManager[] { trustManager }, null);
+      sslSocketFactory = sslContext.getSocketFactory();
+    } catch (GeneralSecurityException e) {
+      throw new RuntimeException(e);
+    }
+
     client = new OkHttpClient.Builder()
-        .sslSocketFactory(sslContext.getSocketFactory())
+        .sslSocketFactory(sslSocketFactory, trustManager)
         .build();
   }
 
@@ -103,3 +180,8 @@ The full code sample shows how to replace the host platform’s certificate auth
     ... // Full source omitted. See sample.
   }
 ```
+
+ [CustomTrustJava]: https://github.com/square/okhttp/blob/master/samples/guide/src/main/java/okhttp3/recipes/CustomTrust.java
+ [CustomTrustKotlin]: https://github.com/square/okhttp/blob/master/samples/guide/src/main/java/okhttp3/recipes/kt/CustomTrust.kt
+ [CertificatePinningJava]: https://github.com/square/okhttp/blob/master/samples/guide/src/main/java/okhttp3/recipes/CertificatePinning.java
+ [CertificatePinningKotlin]: https://github.com/square/okhttp/blob/master/samples/guide/src/main/java/okhttp3/recipes/kt/CertificatePinning.kt
diff --git a/docs/interceptors.md b/docs/interceptors.md
index b3d759e9d0..e040b23f6c 100644
--- a/docs/interceptors.md
+++ b/docs/interceptors.md
@@ -29,7 +29,7 @@ Interceptors can be chained. Suppose you have both a compressing interceptor and
 
 ![Interceptors Diagram](images/interceptors@2x.png)
 
-#### Application Interceptors
+### Application Interceptors
 
 Interceptors are registered as either _application_ or _network_ interceptors. We'll use the `LoggingInterceptor` defined above to show the difference.
 
@@ -64,7 +64,7 @@ Connection: keep-alive
 
 We can see that we were redirected because `response.request().url()` is different from `request.url()`. The two log statements log two different URLs.
 
-#### Network Interceptors
+### Network Interceptors
 
 Registering a network interceptor is quite similar. Call `addNetworkInterceptor()` instead of `addInterceptor()`:
 
@@ -113,7 +113,7 @@ Connection: keep-alive
 
 The network requests also contain more data, such as the `Accept-Encoding: gzip` header added by OkHttp to advertise support for response compression. The network interceptor's `Chain` has a non-null `Connection` that can be used to interrogate the IP address and TLS configuration that were used to connect to the webserver.
 
-#### Choosing between application and network interceptors
+### Choosing between application and network interceptors
 
 Each interceptor chain has relative merits.
 
@@ -132,7 +132,7 @@ Each interceptor chain has relative merits.
  * Observe the data just as it will be transmitted over the network.
  * Access to the `Connection` that carries the request.
 
-#### Rewriting Requests
+### Rewriting Requests
 
 Interceptors can add, remove, or replace request headers. They can also transform the body of those requests that have one. For example, you can use an application interceptor to add request body compression if you're connecting to a webserver known to support it.
 
@@ -172,7 +172,7 @@ final class GzipRequestInterceptor implements Interceptor {
 }
 ```
 
-#### Rewriting Responses
+### Rewriting Responses
 
 Symmetrically, interceptors can rewrite response headers and transform the response body. This is generally more dangerous than rewriting request headers because it may violate the webserver's expectations!
 
diff --git a/docs/recipes.md b/docs/recipes.md
index c9bb42a6e3..fb153c3abf 100644
--- a/docs/recipes.md
+++ b/docs/recipes.md
@@ -2,14 +2,34 @@ Recipes
 =======
 
 We've written some recipes that demonstrate how to solve common problems with OkHttp. Read through them to learn about how everything works together. Cut-and-paste these examples freely; that's what they're for.
-
-#### [Synchronous Get](https://github.com/square/okhttp/blob/master/samples/guide/src/main/java/okhttp3/recipes/SynchronousGet.java)
+ 
+### Synchronous Get ([.kt][SynchronousGetKotlin], [.java][SynchronousGetJava])
 
 Download a file, print its headers, and print its response body as a string.
 
 The `string()` method on response body is convenient and efficient for small documents. But if the response body is large (greater than 1 MiB), avoid `string()` because it will load the entire document into memory. In that case, prefer to process the body as a stream.
 
-```java
+```Kotlin tab=
+  private val client = OkHttpClient()
+
+  fun run() {
+    val request = Request.Builder()
+        .url("https://publicobject.com/helloworld.txt")
+        .build()
+
+    client.newCall(request).execute().use { response ->
+      if (!response.isSuccessful) throw IOException("Unexpected code $response")
+
+      for ((name, value) in response.headers) {
+        println("$name: $value")
+      }
+
+      println(response.body!!.string())
+    }
+  }
+```
+
+```Java tab=
   private final OkHttpClient client = new OkHttpClient();
 
   public void run() throws Exception {
@@ -29,12 +49,40 @@ The `string()` method on response body is convenient and efficient for small doc
     }
   }
 ```
-
-#### [Asynchronous Get](https://github.com/square/okhttp/blob/master/samples/guide/src/main/java/okhttp3/recipes/AsynchronousGet.java)
+ 
+### Asynchronous Get ([.kt][AsynchronousGetKotlin], [.java][AsynchronousGetJava])
 
 Download a file on a worker thread, and get called back when the response is readable. The callback is made after the response headers are ready. Reading the response body may still block. OkHttp doesn't currently offer asynchronous APIs to receive a response body in parts.
 
-```java
+```Kotlin tab=
+  private val client = OkHttpClient()
+
+  fun run() {
+    val request = Request.Builder()
+        .url("http://publicobject.com/helloworld.txt")
+        .build()
+
+    client.newCall(request).enqueue(object : Callback {
+      override fun onFailure(call: Call, e: IOException) {
+        e.printStackTrace()
+      }
+
+      override fun onResponse(call: Call, response: Response) {
+        response.use {
+          if (!response.isSuccessful) throw IOException("Unexpected code $response")
+
+          for ((name, value) in response.headers) {
+            println("$name: $value")
+          }
+
+          println(response.body!!.string())
+        }
+      }
+    })
+  }
+```
+
+```Java tab=
   private final OkHttpClient client = new OkHttpClient();
 
   public void run() throws Exception {
@@ -62,8 +110,8 @@ Download a file on a worker thread, and get called back when the response is rea
     });
   }
 ```
-
-#### [Accessing Headers](https://github.com/square/okhttp/blob/master/samples/guide/src/main/java/okhttp3/recipes/AccessHeaders.java)
+ 
+### Accessing Headers ([.kt][AccessHeadersKotlin], [.java][AccessHeadersJava])
 
 Typically HTTP headers work like a `Map<String, String>`: each field has one value or none. But some headers permit multiple values, like Guava's [Multimap](http://docs.guava-libraries.googlecode.com/git/javadoc/com/google/common/collect/Multimap.html). For example, it's legal and common for an HTTP response to supply multiple `Vary` headers. OkHttp's APIs attempt to make both cases comfortable.
 
@@ -73,7 +121,28 @@ When reading response a header, use `header(name)` to return the _last_ occurren
 
 To visit all headers, use the `Headers` class which supports access by index.
 
-```java
+```Kotlin tab=
+  private val client = OkHttpClient()
+
+  fun run() {
+    val request = Request.Builder()
+        .url("https://api.github.com/repos/square/okhttp/issues")
+        .header("User-Agent", "OkHttp Headers.java")
+        .addHeader("Accept", "application/json; q=0.5")
+        .addHeader("Accept", "application/vnd.github.v3+json")
+        .build()
+
+    client.newCall(request).execute().use { response ->
+      if (!response.isSuccessful) throw IOException("Unexpected code $response")
+
+      println("Server: ${response.header("Server")}")
+      println("Date: ${response.header("Date")}")
+      println("Vary: ${response.headers("Vary")}")
+    }
+  }
+```
+
+```Java tab=
   private final OkHttpClient client = new OkHttpClient();
 
   public void run() throws Exception {
@@ -93,12 +162,42 @@ To visit all headers, use the `Headers` class which supports access by index.
     }
   }
 ```
-
-#### [Posting a String](https://github.com/square/okhttp/blob/master/samples/guide/src/main/java/okhttp3/recipes/PostString.java)
+ 
+### Posting a String ([.kt][PostStringKotlin], [.java][PostStringJava])
 
 Use an HTTP POST to send a request body to a service. This example posts a markdown document to a web service that renders markdown as HTML. Because the entire request body is in memory simultaneously, avoid posting large (greater than 1 MiB) documents using this API.
 
-```java
+```Kotlin tab=
+  private val client = OkHttpClient()
+
+  fun run() {
+    val postBody = """
+        |Releases
+        |--------
+        |
+        | * _1.0_ May 6, 2013
+        | * _1.1_ June 15, 2013
+        | * _1.2_ August 11, 2013
+        |""".trimMargin()
+
+    val request = Request.Builder()
+        .url("https://api.github.com/markdown/raw")
+        .post(postBody.toRequestBody(MEDIA_TYPE_MARKDOWN))
+        .build()
+
+    client.newCall(request).execute().use { response ->
+      if (!response.isSuccessful) throw IOException("Unexpected code $response")
+
+      println(response.body!!.string())
+    }
+  }
+
+  companion object {
+    val MEDIA_TYPE_MARKDOWN = "text/x-markdown; charset=utf-8".toMediaType()
+  }
+```
+
+```Java tab=
   public static final MediaType MEDIA_TYPE_MARKDOWN
       = MediaType.parse("text/x-markdown; charset=utf-8");
 
@@ -125,12 +224,53 @@ Use an HTTP POST to send a request body to a service. This example posts a markd
     }
   }
 ```
+ 
+### Post Streaming ([.kt][PostStreamingKotlin], [.java][PostStreamingJava])
+ 
+Here we `POST` a request body as a stream. The content of this request body is being generated as it's being written. This example streams directly into the [Okio](https://github.com/square/okio) buffered sink. Your programs may prefer an `OutputStream`, which you can get from `BufferedSink.outputStream()`.
 
-#### [Post Streaming](https://github.com/square/okhttp/blob/master/samples/guide/src/main/java/okhttp3/recipes/PostStreaming.java)
+```Kotlin tab=
+  private val client = OkHttpClient()
 
-Here we `POST` a request body as a stream. The content of this request body is being generated as it's being written. This example streams directly into the [Okio](https://github.com/square/okio) buffered sink. Your programs may prefer an `OutputStream`, which you can get from `BufferedSink.outputStream()`.
+  fun run() {
+    val requestBody = object : RequestBody() {
+      override fun contentType() = MEDIA_TYPE_MARKDOWN
 
-```java
+      override fun writeTo(sink: BufferedSink) {
+        sink.writeUtf8("Numbers\n")
+        sink.writeUtf8("-------\n")
+        for (i in 2..997) {
+          sink.writeUtf8(String.format(" * $i = ${factor(i)}\n"))
+        }
+      }
+
+      private fun factor(n: Int): String {
+        for (i in 2 until n) {
+          val x = n / i
+          if (x * i == n) return "${factor(x)} × $i"
+        }
+        return n.toString()
+      }
+    }
+
+    val request = Request.Builder()
+        .url("https://api.github.com/markdown/raw")
+        .post(requestBody)
+        .build()
+
+    client.newCall(request).execute().use { response ->
+      if (!response.isSuccessful) throw IOException("Unexpected code $response")
+
+      println(response.body!!.string())
+    }
+  }
+
+  companion object {
+    val MEDIA_TYPE_MARKDOWN = "text/x-markdown; charset=utf-8".toMediaType()
+  }
+```
+
+```Java tab=
   public static final MediaType MEDIA_TYPE_MARKDOWN
       = MediaType.parse("text/x-markdown; charset=utf-8");
 
@@ -171,12 +311,35 @@ Here we `POST` a request body as a stream. The content of this request body is b
     }
   }
 ```
-
-#### [Posting a File](https://github.com/square/okhttp/blob/master/samples/guide/src/main/java/okhttp3/recipes/PostFile.java)
+ 
+### Posting a File ([.kt][PostFileKotlin], [.java][PostFileJava])
 
 It's easy to use a file as a request body.
 
-```java
+```Kotlin tab=
+  private val client = OkHttpClient()
+
+  fun run() {
+    val file = File("README.md")
+
+    val request = Request.Builder()
+        .url("https://api.github.com/markdown/raw")
+        .post(file.asRequestBody(MEDIA_TYPE_MARKDOWN))
+        .build()
+
+    client.newCall(request).execute().use { response ->
+      if (!response.isSuccessful) throw IOException("Unexpected code $response")
+
+      println(response.body!!.string())
+    }
+  }
+
+  companion object {
+    val MEDIA_TYPE_MARKDOWN = "text/x-markdown; charset=utf-8".toMediaType()
+  }
+```
+
+```Java tab=
   public static final MediaType MEDIA_TYPE_MARKDOWN
       = MediaType.parse("text/x-markdown; charset=utf-8");
 
@@ -197,12 +360,32 @@ It's easy to use a file as a request body.
     }
   }
 ```
-
-#### [Posting form parameters](https://github.com/square/okhttp/blob/master/samples/guide/src/main/java/okhttp3/recipes/PostForm.java)
+ 
+### Posting form parameters ([.kt][PostFormKotlin], [.java][PostFormJava])
 
 Use `FormBody.Builder` to build a request body that works like an HTML `<form>` tag. Names and values will be encoded using an HTML-compatible form URL encoding.
 
-```java
+```Kotlin tab=
+  private val client = OkHttpClient()
+
+  fun run() {
+    val formBody = FormBody.Builder()
+        .add("search", "Jurassic Park")
+        .build()
+    val request = Request.Builder()
+        .url("https://en.wikipedia.org/w/index.php")
+        .post(formBody)
+        .build()
+
+    client.newCall(request).execute().use { response ->
+      if (!response.isSuccessful) throw IOException("Unexpected code $response")
+
+      println(response.body!!.string())
+    }
+  }
+```
+
+```Java tab=
   private final OkHttpClient client = new OkHttpClient();
 
   public void run() throws Exception {
@@ -221,12 +404,47 @@ Use `FormBody.Builder` to build a request body that works like an HTML `<form>`
     }
   }
 ```
-
-#### [Posting a multipart request](https://github.com/square/okhttp/blob/master/samples/guide/src/main/java/okhttp3/recipes/PostMultipart.java)
+ 
+### Posting a multipart request ([.kt][PostMultipartKotlin], [.java][PostMultipartJava])
 
 `MultipartBody.Builder` can build sophisticated request bodies compatible with HTML file upload forms. Each part of a multipart request body is itself a request body, and can define its own headers. If present, these headers should describe the part body, such as its `Content-Disposition`. The `Content-Length` and `Content-Type` headers are added automatically if they're available.
 
-```java
+```Kotlin tab=
+  private val client = OkHttpClient()
+
+  fun run() {
+    // Use the imgur image upload API as documented at https://api.imgur.com/endpoints/image
+    val requestBody = MultipartBody.Builder()
+        .setType(MultipartBody.FORM)
+        .addFormDataPart("title", "Square Logo")
+        .addFormDataPart("image", "logo-square.png",
+            File("docs/images/logo-square.png").asRequestBody(MEDIA_TYPE_PNG))
+        .build()
+
+    val request = Request.Builder()
+        .header("Authorization", "Client-ID $IMGUR_CLIENT_ID")
+        .url("https://api.imgur.com/3/image")
+        .post(requestBody)
+        .build()
+
+    client.newCall(request).execute().use { response ->
+      if (!response.isSuccessful) throw IOException("Unexpected code $response")
+
+      println(response.body!!.string())
+    }
+  }
+
+  companion object {
+    /**
+     * The imgur client ID for OkHttp recipes. If you're using imgur for anything other than running
+     * these examples, please request your own client ID! https://api.imgur.com/oauth2
+     */
+    private val IMGUR_CLIENT_ID = "9199fdef135c122"
+    private val MEDIA_TYPE_PNG = "image/png".toMediaType()
+  }
+```
+
+```Java tab=
   /**
    * The imgur client ID for OkHttp recipes. If you're using imgur for anything other than running
    * these examples, please request your own client ID! https://api.imgur.com/oauth2
@@ -258,14 +476,42 @@ Use `FormBody.Builder` to build a request body that works like an HTML `<form>`
     }
   }
 ```
-
-#### [Parse a JSON Response With Moshi](https://github.com/square/okhttp/blob/master/samples/guide/src/main/java/okhttp3/recipes/ParseResponseWithMoshi.java)
-
+ 
+### Parse a JSON Response With Moshi ([.kt][ParseResponseWithMoshiKotlin], [.java][ParseResponseWithMoshiJava])
+  
 [Moshi](https://github.com/square/moshi) is a handy API for converting between JSON and Java objects. Here we're using it to decode a JSON response from a GitHub API.
 
 Note that `ResponseBody.charStream()` uses the `Content-Type` response header to select which charset to use when decoding the response body. It defaults to `UTF-8` if no charset is specified.
 
-```java
+```Kotlin tab=
+  private val client = OkHttpClient()
+  private val moshi = Moshi.Builder().build()
+  private val gistJsonAdapter = moshi.adapter(Gist::class.java)
+
+  fun run() {
+    val request = Request.Builder()
+        .url("https://api.github.com/gists/c2a7c39532239ff261be")
+        .build()
+    client.newCall(request).execute().use { response ->
+      if (!response.isSuccessful) throw IOException("Unexpected code $response")
+
+      val gist = gistJsonAdapter.fromJson(response.body!!.source())
+
+      for ((key, value) in gist!!.files!!) {
+        println(key)
+        println(value.content)
+      }
+    }
+  }
+
+  @JsonClass(generateAdapter = true)
+  data class Gist(var files: Map<String, GistFile>?)
+
+  @JsonClass(generateAdapter = true)
+  data class GistFile(var content: String?)
+```
+
+```Java tab=
   private final OkHttpClient client = new OkHttpClient();
   private final Moshi moshi = new Moshi.Builder().build();
   private final JsonAdapter<Gist> gistJsonAdapter = moshi.adapter(Gist.class);
@@ -294,8 +540,8 @@ Note that `ResponseBody.charStream()` uses the `Content-Type` response header to
     String content;
   }
 ```
-
-#### [Response Caching](https://github.com/square/okhttp/blob/master/samples/guide/src/main/java/okhttp3/recipes/CacheResponse.java)
+ 
+### Response Caching ([.kt][CacheResponseKotlin], [.java][CacheResponseJava])
 
 To cache responses, you'll need a cache directory that you can read and write to, and a limit on the cache's size. The cache directory should be private, and untrusted applications should not be able to read its contents!
 
@@ -303,7 +549,42 @@ It is an error to have multiple caches accessing the same cache directory simult
 
 Response caching uses HTTP headers for all configuration. You can add request headers like `Cache-Control: max-stale=3600` and OkHttp's cache will honor them. Your webserver configures how long responses are cached with its own response headers, like `Cache-Control: max-age=9600`. There are cache headers to force a cached response, force a network response, or force the network response to be validated with a conditional GET.
 
-```java
+```Kotlin tab=
+  private val client: OkHttpClient = OkHttpClient.Builder()
+      .cache(Cache(
+          directory = cacheDirectory,
+          maxSize = 10L * 1024L * 1024L // 1 MiB
+      ))
+      .build()
+
+  fun run() {
+    val request = Request.Builder()
+        .url("http://publicobject.com/helloworld.txt")
+        .build()
+
+    val response1Body = client.newCall(request).execute().use {
+      if (!it.isSuccessful) throw IOException("Unexpected code $it")
+
+      println("Response 1 response:          $it")
+      println("Response 1 cache response:    ${it.cacheResponse}")
+      println("Response 1 network response:  ${it.networkResponse}")
+      return@use it.body!!.string()
+    }
+
+    val response2Body = client.newCall(request).execute().use {
+      if (!it.isSuccessful) throw IOException("Unexpected code $it")
+
+      println("Response 2 response:          $it")
+      println("Response 2 cache response:    ${it.cacheResponse}")
+      println("Response 2 network response:  ${it.networkResponse}")
+      return@use it.body!!.string()
+    }
+
+    println("Response 2 equals Response 1? " + (response1Body == response2Body))
+  }
+```
+
+```Java tab=
   private final OkHttpClient client;
 
   public CacheResponse(File cacheDirectory) throws Exception {
@@ -343,13 +624,46 @@ Response caching uses HTTP headers for all configuration. You can add request he
     System.out.println("Response 2 equals Response 1? " + response1Body.equals(response2Body));
   }
 ```
-To prevent a response from using the cache, use [`CacheControl.FORCE_NETWORK`](http://square.github.io/okhttp/4.x/okhttp/okhttp3/-cache-control/-f-o-r-c-e_-n-e-t-w-o-r-k/). To prevent it from using the network, use [`CacheControl.FORCE_CACHE`](http://square.github.io/okhttp/4.x/okhttp/okhttp3/-cache-control/-f-o-r-c-e_-c-a-c-h-e/). Be warned: if you use `FORCE_CACHE` and the response requires the network, OkHttp will return a `504 Unsatisfiable Request` response.
 
-#### [Canceling a Call](https://github.com/square/okhttp/blob/master/samples/guide/src/main/java/okhttp3/recipes/CancelCall.java)
+To prevent a response from using the cache, use [`CacheControl.FORCE_NETWORK`](http://square.github.io/okhttp/4.x/okhttp/okhttp3/-cache-control/-f-o-r-c-e_-n-e-t-w-o-r-k/). To prevent it from using the network, use [`CacheControl.FORCE_CACHE`](http://square.github.io/okhttp/4.x/okhttp/okhttp3/-cache-control/-f-o-r-c-e_-c-a-c-h-e/). Be warned: if you use `FORCE_CACHE` and the response requires the network, OkHttp will return a `504 Unsatisfiable Request` response.
+ 
+### Canceling a Call ([.kt][CancelCallKotlin], [.java][CancelCallJava])
 
 Use `Call.cancel()` to stop an ongoing call immediately. If a thread is currently writing a request or reading a response, it will receive an `IOException`. Use this to conserve the network when a call is no longer necessary; for example when your user navigates away from an application. Both synchronous and asynchronous calls can be canceled.
 
-```java
+```Kotlin tab=
+  private val executor = Executors.newScheduledThreadPool(1)
+  private val client = OkHttpClient()
+
+  fun run() {
+    val request = Request.Builder()
+        .url("http://httpbin.org/delay/2") // This URL is served with a 2 second delay.
+        .build()
+
+    val startNanos = System.nanoTime()
+    val call = client.newCall(request)
+
+    // Schedule a job to cancel the call in 1 second.
+    executor.schedule({
+      System.out.printf("%.2f Canceling call.%n", (System.nanoTime() - startNanos) / 1e9f)
+      call.cancel()
+      System.out.printf("%.2f Canceled call.%n", (System.nanoTime() - startNanos) / 1e9f)
+    }, 1, TimeUnit.SECONDS)
+
+    System.out.printf("%.2f Executing call.%n", (System.nanoTime() - startNanos) / 1e9f)
+    try {
+      call.execute().use { response ->
+        System.out.printf("%.2f Call was expected to fail, but completed: %s%n",
+            (System.nanoTime() - startNanos) / 1e9f, response)
+      }
+    } catch (e: IOException) {
+      System.out.printf("%.2f Call failed as expected: %s%n",
+          (System.nanoTime() - startNanos) / 1e9f, e)
+    }
+  }
+```
+
+```Java tab=
   private final ScheduledExecutorService executor = Executors.newScheduledThreadPool(1);
   private final OkHttpClient client = new OkHttpClient();
 
@@ -380,12 +694,31 @@ Use `Call.cancel()` to stop an ongoing call immediately. If a thread is currentl
     }
   }
 ```
+ 
+### Timeouts ([.kt][ConfigureTimeoutsKotlin], [.java][ConfigureTimeoutsJava])
 
-#### [Timeouts](https://github.com/square/okhttp/blob/master/samples/guide/src/main/java/okhttp3/recipes/ConfigureTimeouts.java)
+Use timeouts to fail a call when its peer is unreachable. Network partitions can be due to client connectivity problems, server availability problems, or anything between. OkHttp supports connect, write, read, and full call timeouts.
 
-Use timeouts to fail a call when its peer is unreachable. Network partitions can be due to client connectivity problems, server availability problems, or anything between. OkHttp supports connect, read, and write timeouts.
+```Kotlin tab=
+  private val client: OkHttpClient = OkHttpClient.Builder()
+      .connectTimeout(5, TimeUnit.SECONDS)
+      .writeTimeout(5, TimeUnit.SECONDS)
+      .readTimeout(5, TimeUnit.SECONDS)
+      .callTimeout(10, TimeUnit.SECONDS)
+      .build()
 
-```java
+  fun run() {
+    val request = Request.Builder()
+        .url("http://httpbin.org/delay/2") // This URL is served with a 2 second delay.
+        .build()
+
+    client.newCall(request).execute().use { response ->
+      println("Response completed: $response")
+    }
+  }
+```
+
+```Java tab=
   private final OkHttpClient client;
 
   public ConfigureTimeouts() throws Exception {
@@ -406,12 +739,46 @@ Use timeouts to fail a call when its peer is unreachable. Network partitions can
     }
   }
 ```
-
-#### [Per-call Configuration](https://github.com/square/okhttp/blob/master/samples/guide/src/main/java/okhttp3/recipes/PerCallSettings.java)
+ 
+### Per-call Configuration ([.kt][PerCallSettingsKotlin], [.java][PerCallSettingsJava])
 
 All the HTTP client configuration lives in `OkHttpClient` including proxy settings, timeouts, and caches. When you need to change the configuration of a single call, call `OkHttpClient.newBuilder()`. This returns a builder that shares the same connection pool, dispatcher, and configuration with the original client. In the example below, we make one request with a 500 ms timeout and another with a 3000 ms timeout.
 
-```java
+```Kotlin tab=
+  private val client = OkHttpClient()
+
+  fun run() {
+    val request = Request.Builder()
+        .url("http://httpbin.org/delay/1") // This URL is served with a 1 second delay.
+        .build()
+
+    // Copy to customize OkHttp for this request.
+    val client1 = client.newBuilder()
+        .readTimeout(500, TimeUnit.MILLISECONDS)
+        .build()
+    try {
+      client1.newCall(request).execute().use { response ->
+        println("Response 1 succeeded: $response")
+      }
+    } catch (e: IOException) {
+      println("Response 1 failed: $e")
+    }
+
+    // Copy to customize OkHttp for this request.
+    val client2 = client.newBuilder()
+        .readTimeout(3000, TimeUnit.MILLISECONDS)
+        .build()
+    try {
+      client2.newCall(request).execute().use { response ->
+        println("Response 2 succeeded: $response")
+      }
+    } catch (e: IOException) {
+      println("Response 2 failed: $e")
+    }
+  }
+```
+
+```Java tab=
   private final OkHttpClient client = new OkHttpClient();
 
   public void run() throws Exception {
@@ -440,14 +807,46 @@ All the HTTP client configuration lives in `OkHttpClient` including proxy settin
     }
   }
 ```
-
-#### [Handling authentication](https://github.com/square/okhttp/blob/master/samples/guide/src/main/java/okhttp3/recipes/Authenticate.java)
+ 
+### Handling authentication ([.kt][AuthenticateKotlin], [.java][AuthenticateJava])
 
 OkHttp can automatically retry unauthenticated requests. When a response is `401 Not Authorized`, an `Authenticator` is asked to supply credentials. Implementations should build a new request that includes the missing credentials. If no credentials are available, return null to skip the retry.
 
 Use `Response.challenges()` to get the schemes and realms of any authentication challenges. When fulfilling a `Basic` challenge, use `Credentials.basic(username, password)` to encode the request header.
 
-```java
+```Kotlin tab=
+  private val client = OkHttpClient.Builder()
+      .authenticator(object : Authenticator {
+        @Throws(IOException::class)
+        override fun authenticate(route: Route?, response: Response): Request? {
+          if (response.request.header("Authorization") != null) {
+            return null // Give up, we've already attempted to authenticate.
+          }
+
+          println("Authenticating for response: $response")
+          println("Challenges: ${response.challenges()}")
+          val credential = Credentials.basic("jesse", "password1")
+          return response.request.newBuilder()
+              .header("Authorization", credential)
+              .build()
+        }
+      })
+      .build()
+
+  fun run() {
+    val request = Request.Builder()
+        .url("http://publicobject.com/secrets/hellosecret.txt")
+        .build()
+
+    client.newCall(request).execute().use { response ->
+      if (!response.isSuccessful) throw IOException("Unexpected code $response")
+
+      println(response.body!!.string())
+    }
+  }
+```
+
+```Java tab=
   private final OkHttpClient client;
 
   public Authenticate() {
@@ -509,3 +908,32 @@ This above code relies on this `responseCount()` method:
     return result;
   }
 ```
+
+ [SynchronousGetJava]: https://github.com/square/okhttp/blob/master/samples/guide/src/main/java/okhttp3/recipes/SynchronousGet.java 
+ [SynchronousGetKotlin]: https://github.com/square/okhttp/blob/master/samples/guide/src/main/java/okhttp3/recipes/kt/SynchronousGet.kt
+ [AsynchronousGetJava]: https://github.com/square/okhttp/blob/master/samples/guide/src/main/java/okhttp3/recipes/AsynchronousGet.java 
+ [AsynchronousGetKotlin]: https://github.com/square/okhttp/blob/master/samples/guide/src/main/java/okhttp3/recipes/kt/AsynchronousGet.kt
+ [AccessHeadersJava]: https://github.com/square/okhttp/blob/master/samples/guide/src/main/java/okhttp3/recipes/AccessHeaders.java 
+ [AccessHeadersKotlin]: https://github.com/square/okhttp/blob/master/samples/guide/src/main/java/okhttp3/recipes/kt/AccessHeaders.kt
+ [PostStringJava]: https://github.com/square/okhttp/blob/master/samples/guide/src/main/java/okhttp3/recipes/PostString.java 
+ [PostStringKotlin]: https://github.com/square/okhttp/blob/master/samples/guide/src/main/java/okhttp3/recipes/kt/PostString.kt
+ [PostStreamingJava]: https://github.com/square/okhttp/blob/master/samples/guide/src/main/java/okhttp3/recipes/PostStreaming.java 
+ [PostStreamingKotlin]: https://github.com/square/okhttp/blob/master/samples/guide/src/main/java/okhttp3/recipes/kt/PostStreaming.kt
+ [PostFileJava]: https://github.com/square/okhttp/blob/master/samples/guide/src/main/java/okhttp3/recipes/PostFile.java 
+ [PostFileKotlin]: https://github.com/square/okhttp/blob/master/samples/guide/src/main/java/okhttp3/recipes/kt/PostFile.kt
+ [PostFormJava]: https://github.com/square/okhttp/blob/master/samples/guide/src/main/java/okhttp3/recipes/PostForm.java 
+ [PostFormKotlin]: https://github.com/square/okhttp/blob/master/samples/guide/src/main/java/okhttp3/recipes/kt/PostForm.kt
+ [PostMultipartJava]: https://github.com/square/okhttp/blob/master/samples/guide/src/main/java/okhttp3/recipes/PostMultipart.java 
+ [PostMultipartKotlin]: https://github.com/square/okhttp/blob/master/samples/guide/src/main/java/okhttp3/recipes/kt/PostMultipart.kt
+ [ParseResponseWithMoshiJava]: https://github.com/square/okhttp/blob/master/samples/guide/src/main/java/okhttp3/recipes/ParseResponseWithMoshi.java 
+ [ParseResponseWithMoshiKotlin]: https://github.com/square/okhttp/blob/master/samples/guide/src/main/java/okhttp3/recipes/kt/ParseResponseWithMoshi.kt
+ [CacheResponseJava]: https://github.com/square/okhttp/blob/master/samples/guide/src/main/java/okhttp3/recipes/CacheResponse.java 
+ [CacheResponseKotlin]: https://github.com/square/okhttp/blob/master/samples/guide/src/main/java/okhttp3/recipes/kt/CacheResponse.kt
+ [CancelCallJava]: https://github.com/square/okhttp/blob/master/samples/guide/src/main/java/okhttp3/recipes/CancelCall.java 
+ [CancelCallKotlin]: https://github.com/square/okhttp/blob/master/samples/guide/src/main/java/okhttp3/recipes/kt/CancelCall.kt
+ [ConfigureTimeoutsJava]: https://github.com/square/okhttp/blob/master/samples/guide/src/main/java/okhttp3/recipes/ConfigureTimeouts.java 
+ [ConfigureTimeoutsKotlin]: https://github.com/square/okhttp/blob/master/samples/guide/src/main/java/okhttp3/recipes/kt/ConfigureTimeouts.kt
+ [PerCallSettingsJava]: https://github.com/square/okhttp/blob/master/samples/guide/src/main/java/okhttp3/recipes/PerCallSettings.java 
+ [PerCallSettingsKotlin]: https://github.com/square/okhttp/blob/master/samples/guide/src/main/java/okhttp3/recipes/kt/PerCallSettings.kt
+ [AuthenticateJava]: https://github.com/square/okhttp/blob/master/samples/guide/src/main/java/okhttp3/recipes/Authenticate.java 
+ [AuthenticateKotlin]: https://github.com/square/okhttp/blob/master/samples/guide/src/main/java/okhttp3/recipes/kt/Authenticate.kt
diff --git a/gradle.properties b/gradle.properties
index 1a261d695b..f1a5f65598 100644
--- a/gradle.properties
+++ b/gradle.properties
@@ -1,7 +1,7 @@
 org.gradle.jvmargs='-Dfile.encoding=UTF-8'
 
 GROUP=com.squareup.okhttp3
-VERSION_NAME=4.2.0-SNAPSHOT
+VERSION_NAME=4.3.0-SNAPSHOT
 
 POM_URL=https://github.com/square/okhttp
 POM_SCM_URL=https://github.com/square/okhttp
diff --git a/mkdocs.yml b/mkdocs.yml
index f54d97518b..ba91c4d1c2 100644
--- a/mkdocs.yml
+++ b/mkdocs.yml
@@ -33,6 +33,7 @@ markdown_extensions:
   - pymdownx.magiclink
   - pymdownx.smartsymbols
   - pymdownx.superfences
+  - pymdownx.tilde
   - tables
 
 nav:
@@ -47,6 +48,7 @@ nav:
   - 'Stack Overflow ⏏': https://stackoverflow.com/questions/tagged/okhttp?sort=active
   - '4.x API':
     - 'okhttp': 4.x/okhttp/okhttp3/index.md
+    - 'brotli': 4.x/okhttp-brotli/okhttp3.brotli/index.md
     - 'dnsoverhttps': 4.x/okhttp-dnsoverhttps/okhttp3.dnsoverhttps/index.md
     - 'logging-interceptor': 4.x/okhttp-logging-interceptor/okhttp3.logging/index.md
     - 'sse': 4.x/okhttp-sse/okhttp3.sse/index.md
diff --git a/mockwebserver/README.md b/mockwebserver/README.md
index 5843aa1558..b6d2443dc6 100644
--- a/mockwebserver/README.md
+++ b/mockwebserver/README.md
@@ -142,7 +142,7 @@ server.setDispatcher(dispatcher);
 ### Download
 
 ```kotlin
-testImplementation("com.squareup.okhttp3:mockwebserver:4.1.1")
+testImplementation("com.squareup.okhttp3:mockwebserver:4.2.1")
 ```
 
 ### License
diff --git a/mockwebserver/src/main/java/okhttp3/mockwebserver/MockWebServer.kt b/mockwebserver/src/main/java/okhttp3/mockwebserver/MockWebServer.kt
index 14f69c51e0..f6782c11cf 100644
--- a/mockwebserver/src/main/java/okhttp3/mockwebserver/MockWebServer.kt
+++ b/mockwebserver/src/main/java/okhttp3/mockwebserver/MockWebServer.kt
@@ -25,8 +25,8 @@ import okhttp3.Request
 import okhttp3.Response
 import okhttp3.internal.addHeaderLenient
 import okhttp3.internal.closeQuietly
+import okhttp3.internal.concurrent.TaskRunner
 import okhttp3.internal.duplex.MwsDuplexAccess
-import okhttp3.internal.execute
 import okhttp3.internal.http.HttpMethod
 import okhttp3.internal.http2.ErrorCode
 import okhttp3.internal.http2.Header
@@ -80,8 +80,6 @@ import java.util.Collections
 import java.util.Locale
 import java.util.concurrent.ConcurrentHashMap
 import java.util.concurrent.CountDownLatch
-import java.util.concurrent.ExecutorService
-import java.util.concurrent.Executors
 import java.util.concurrent.LinkedBlockingQueue
 import java.util.concurrent.TimeUnit
 import java.util.concurrent.atomic.AtomicInteger
@@ -99,6 +97,9 @@ import javax.net.ssl.X509TrustManager
  * in sequence.
  */
 class MockWebServer : ExternalResource(), Closeable {
+  private val taskRunnerBackend = TaskRunner.RealBackend(
+      threadFactory("MockWebServer TaskRunner", true))
+  private val taskRunner = TaskRunner(taskRunnerBackend)
   private val requestQueue = LinkedBlockingQueue<RecordedRequest>()
   private val openClientSockets =
       Collections.newSetFromMap(ConcurrentHashMap<Socket, Boolean>())
@@ -131,7 +132,6 @@ class MockWebServer : ExternalResource(), Closeable {
 
   private var serverSocket: ServerSocket? = null
   private var sslSocketFactory: SSLSocketFactory? = null
-  private var executor: ExecutorService? = null
   private var tunnelProxy: Boolean = false
   private var clientAuth = CLIENT_AUTH_NONE
 
@@ -329,7 +329,8 @@ class MockWebServer : ExternalResource(), Closeable {
    * @return the head of the request queue
    */
   @Throws(InterruptedException::class)
-  fun takeRequest(timeout: Long, unit: TimeUnit): RecordedRequest? = requestQueue.poll(timeout, unit)
+  fun takeRequest(timeout: Long, unit: TimeUnit): RecordedRequest? =
+      requestQueue.poll(timeout, unit)
 
   @JvmName("-deprecated_requestCount")
   @Deprecated(
@@ -378,7 +379,6 @@ class MockWebServer : ExternalResource(), Closeable {
     require(!started) { "start() already called" }
     started = true
 
-    executor = Executors.newCachedThreadPool(threadFactory("MockWebServer", false))
     this.inetSocketAddress = inetSocketAddress
 
     serverSocket = serverSocketFactory!!.createServerSocket()
@@ -388,7 +388,8 @@ class MockWebServer : ExternalResource(), Closeable {
     serverSocket!!.bind(inetSocketAddress, 50)
 
     portField = serverSocket!!.localPort
-    executor!!.execute("MockWebServer $portField") {
+
+    taskRunner.newQueue().execute("MockWebServer $portField", cancelable = false) {
       try {
         logger.info("${this@MockWebServer} starting to accept connections")
         acceptConnections()
@@ -411,7 +412,6 @@ class MockWebServer : ExternalResource(), Closeable {
         httpConnection.remove()
       }
       dispatcher.shutdown()
-      executor!!.shutdown()
     }
   }
 
@@ -447,13 +447,12 @@ class MockWebServer : ExternalResource(), Closeable {
     serverSocket!!.close()
 
     // Await shutdown.
-    try {
-      if (!executor!!.awaitTermination(5, TimeUnit.SECONDS)) {
-        throw IOException("Gave up waiting for executor to shut down")
+    for (queue in taskRunner.activeQueues()) {
+      if (!queue.awaitIdle(TimeUnit.SECONDS.toNanos(5))) {
+        throw IOException("Gave up waiting for queue to shut down")
       }
-    } catch (e: InterruptedException) {
-      throw AssertionError()
     }
+    taskRunnerBackend.shutdown()
   }
 
   @Synchronized override fun after() {
@@ -465,7 +464,7 @@ class MockWebServer : ExternalResource(), Closeable {
   }
 
   private fun serveConnection(raw: Socket) {
-    executor!!.execute("MockWebServer ${raw.remoteSocketAddress}") {
+    taskRunner.newQueue().execute("MockWebServer ${raw.remoteSocketAddress}", cancelable = false) {
       try {
         SocketHandler(raw).handle()
       } catch (e: IOException) {
@@ -507,7 +506,7 @@ class MockWebServer : ExternalResource(), Closeable {
           openClientSockets.add(socket)
 
           if (protocolNegotiationEnabled) {
-            Platform.get().configureTlsExtensions(sslSocket, null, protocols)
+            Platform.get().configureTlsExtensions(sslSocket, protocols)
           }
 
           sslSocket.startHandshake()
@@ -533,7 +532,7 @@ class MockWebServer : ExternalResource(), Closeable {
 
       if (protocol === Protocol.HTTP_2 || protocol === Protocol.H2_PRIOR_KNOWLEDGE) {
         val http2SocketHandler = Http2SocketHandler(socket, protocol)
-        val connection = Http2Connection.Builder(false)
+        val connection = Http2Connection.Builder(false, taskRunner)
             .socket(socket)
             .listener(http2SocketHandler)
             .build()
@@ -585,11 +584,18 @@ class MockWebServer : ExternalResource(), Closeable {
       source: BufferedSource,
       sink: BufferedSink
     ): Boolean {
-      val request = readRequest(socket, source, sink, sequenceNumber) ?: return false
+      if (source.exhausted()) {
+        return false // No more requests on this socket.
+      }
 
+      val request = readRequest(socket, source, sink, sequenceNumber)
       atomicRequestCount.incrementAndGet()
       requestQueue.add(request)
 
+      if (request.failure != null) {
+        return false // Nothing to respond to.
+      }
+
       val response = dispatcher.dispatch(request)
       if (response.socketPolicy === DISCONNECT_AFTER_REQUEST) {
         socket.close()
@@ -666,78 +672,80 @@ class MockWebServer : ExternalResource(), Closeable {
     source: BufferedSource,
     sink: BufferedSink,
     sequenceNumber: Int
-  ): RecordedRequest? {
-    val request: String
-    try {
-      request = source.readUtf8LineStrict()
-    } catch (streamIsClosed: IOException) {
-      return null // no request because we closed the stream
-    }
-
-    if (request.isEmpty()) {
-      return null // no request because the stream is exhausted
-    }
+  ): RecordedRequest {
+    var request = ""
     val headers = Headers.Builder()
     var contentLength = -1L
     var chunked = false
     var expectContinue = false
-    while (true) {
-      val header = source.readUtf8LineStrict()
-      if (header.isEmpty()) {
-        break
-      }
-      addHeaderLenient(headers, header)
-      val lowercaseHeader = header.toLowerCase(Locale.US)
-      if (contentLength == -1L && lowercaseHeader.startsWith("content-length:")) {
-        contentLength = header.substring(15).trim().toLong()
-      }
-      if (lowercaseHeader.startsWith("transfer-encoding:") && lowercaseHeader.substring(
-              18).trim() == "chunked") {
-        chunked = true
+    val requestBody = TruncatingBuffer(bodyLimit)
+    val chunkSizes = mutableListOf<Int>()
+    var failure: IOException? = null
+
+    try {
+      request = source.readUtf8LineStrict()
+      if (request.isEmpty()) {
+        throw ProtocolException("no request because the stream is exhausted")
       }
-      if (lowercaseHeader.startsWith("expect:") && lowercaseHeader.substring(
-              7).trim().equals("100-continue", ignoreCase = true)) {
-        expectContinue = true
+
+      while (true) {
+        val header = source.readUtf8LineStrict()
+        if (header.isEmpty()) {
+          break
+        }
+        addHeaderLenient(headers, header)
+        val lowercaseHeader = header.toLowerCase(Locale.US)
+        if (contentLength == -1L && lowercaseHeader.startsWith("content-length:")) {
+          contentLength = header.substring(15).trim().toLong()
+        }
+        if (lowercaseHeader.startsWith("transfer-encoding:") && lowercaseHeader.substring(
+                18).trim() == "chunked") {
+          chunked = true
+        }
+        if (lowercaseHeader.startsWith("expect:") && lowercaseHeader.substring(
+                7).trim().equals("100-continue", ignoreCase = true)) {
+          expectContinue = true
+        }
       }
-    }
 
-    val socketPolicy = dispatcher.peek().socketPolicy
-    if (expectContinue && socketPolicy === EXPECT_CONTINUE || socketPolicy === CONTINUE_ALWAYS) {
-      sink.writeUtf8("HTTP/1.1 100 Continue\r\n")
-      sink.writeUtf8("Content-Length: 0\r\n")
-      sink.writeUtf8("\r\n")
-      sink.flush()
-    }
+      val socketPolicy = dispatcher.peek().socketPolicy
+      if (expectContinue && socketPolicy === EXPECT_CONTINUE || socketPolicy === CONTINUE_ALWAYS) {
+        sink.writeUtf8("HTTP/1.1 100 Continue\r\n")
+        sink.writeUtf8("Content-Length: 0\r\n")
+        sink.writeUtf8("\r\n")
+        sink.flush()
+      }
 
-    var hasBody = false
-    val requestBody = TruncatingBuffer(bodyLimit)
-    val chunkSizes = mutableListOf<Int>()
-    val policy = dispatcher.peek()
-    if (contentLength != -1L) {
-      hasBody = contentLength > 0L
-      throttledTransfer(policy, socket, source, requestBody.buffer(), contentLength, true)
-    } else if (chunked) {
-      hasBody = true
-      while (true) {
-        val chunkSize = Integer.parseInt(source.readUtf8LineStrict().trim(), 16)
-        if (chunkSize == 0) {
+      var hasBody = false
+      val policy = dispatcher.peek()
+      if (contentLength != -1L) {
+        hasBody = contentLength > 0L
+        throttledTransfer(policy, socket, source, requestBody.buffer(), contentLength, true)
+      } else if (chunked) {
+        hasBody = true
+        while (true) {
+          val chunkSize = source.readUtf8LineStrict().trim().toInt(16)
+          if (chunkSize == 0) {
+            readEmptyLine(source)
+            break
+          }
+          chunkSizes.add(chunkSize)
+          throttledTransfer(policy, socket, source,
+              requestBody.buffer(), chunkSize.toLong(), true)
           readEmptyLine(source)
-          break
         }
-        chunkSizes.add(chunkSize)
-        throttledTransfer(policy, socket, source,
-            requestBody.buffer(), chunkSize.toLong(), true)
-        readEmptyLine(source)
       }
-    }
 
-    val method = request.substringBefore(' ')
-    require(!hasBody || HttpMethod.permitsRequestBody(method)) {
-      "Request must not have a body: $request"
+      val method = request.substringBefore(' ')
+      require(!hasBody || HttpMethod.permitsRequestBody(method)) {
+        "Request must not have a body: $request"
+      }
+    } catch (e: IOException) {
+      failure = e
     }
 
     return RecordedRequest(request, headers.build(), chunkSizes, requestBody.receivedByteCount,
-        requestBody.buffer, sequenceNumber, socket)
+        requestBody.buffer, sequenceNumber, socket, failure)
   }
 
   @Throws(IOException::class)
@@ -762,7 +770,7 @@ class MockWebServer : ExternalResource(), Closeable {
         .build()
     val statusParts = response.status.split(' ', limit = 3)
     val fancyResponse = Response.Builder()
-        .code(Integer.parseInt(statusParts[1]))
+        .code(statusParts[1].toInt())
         .message(statusParts[2])
         .headers(response.headers)
         .request(fancyRequest)
@@ -773,7 +781,13 @@ class MockWebServer : ExternalResource(), Closeable {
     val streams = object : RealWebSocket.Streams(false, source, sink) {
       override fun close() = connectionClose.countDown()
     }
-    val webSocket = RealWebSocket(fancyRequest, response.webSocketListener!!, SecureRandom(), 0)
+    val webSocket = RealWebSocket(
+        taskRunner = taskRunner,
+        originalRequest = fancyRequest,
+        listener = response.webSocketListener!!,
+        random = SecureRandom(),
+        pingIntervalMillis = 0
+    )
     response.webSocketListener!!.onOpen(webSocket, fancyResponse)
     val name = "MockWebServer WebSocket ${request.path!!}"
     webSocket.initReaderAndWriter(name, streams)
@@ -945,6 +959,9 @@ class MockWebServer : ExternalResource(), Closeable {
       val request = readRequest(stream)
       atomicRequestCount.incrementAndGet()
       requestQueue.add(request)
+      if (request.failure != null) {
+        return // Nothing to respond to.
+      }
 
       val response: MockResponse = dispatcher.dispatch(request)
 
@@ -999,17 +1016,21 @@ class MockWebServer : ExternalResource(), Closeable {
       }
 
       val body = Buffer()
+      val requestLine = "$method $path HTTP/1.1"
+      var exception: IOException? = null
       if (readBody && !peek.isDuplex) {
-        val contentLengthString = headers["content-length"]
-        val byteCount = contentLengthString?.toLong() ?: Long.MAX_VALUE
-        throttledTransfer(peek, socket, stream.getSource().buffer(),
-            body, byteCount, true)
+        try {
+          val contentLengthString = headers["content-length"]
+          val byteCount = contentLengthString?.toLong() ?: Long.MAX_VALUE
+          throttledTransfer(peek, socket, stream.getSource().buffer(),
+              body, byteCount, true)
+        } catch (e: IOException) {
+          exception = e
+        }
       }
 
-      val requestLine = "$method $path HTTP/1.1"
-      val chunkSizes = emptyList<Int>() // No chunked encoding for HTTP/2.
-      return RecordedRequest(requestLine, headers, chunkSizes, body.size, body,
-          sequenceNumber.getAndIncrement(), socket)
+      return RecordedRequest(requestLine, headers, emptyList(), body.size, body,
+          sequenceNumber.getAndIncrement(), socket, exception)
     }
 
     @Throws(IOException::class)
diff --git a/mockwebserver/src/main/java/okhttp3/mockwebserver/RecordedRequest.kt b/mockwebserver/src/main/java/okhttp3/mockwebserver/RecordedRequest.kt
index 9b34b23203..1db64aa94a 100644
--- a/mockwebserver/src/main/java/okhttp3/mockwebserver/RecordedRequest.kt
+++ b/mockwebserver/src/main/java/okhttp3/mockwebserver/RecordedRequest.kt
@@ -29,7 +29,7 @@ import java.net.Socket
 import javax.net.ssl.SSLSocket
 
 /** An HTTP request that came into the mock web server. */
-class RecordedRequest(
+class RecordedRequest @JvmOverloads constructor(
   val requestLine: String,
 
   /** All headers. */
@@ -52,7 +52,13 @@ class RecordedRequest(
    * multiple requests, each request is assigned its own sequence number.
    */
   val sequenceNumber: Int,
-  socket: Socket
+  socket: Socket,
+
+  /**
+   * The failure MockWebServer recorded when attempting to decode this request. If, for example,
+   * the inbound request was truncated, this exception will be non-null.
+   */
+  val failure: IOException? = null
 ) {
   val method: String?
   val path: String?
diff --git a/mockwebserver/src/test/java/okhttp3/mockwebserver/internal/http2/Http2Server.java b/mockwebserver/src/test/java/okhttp3/mockwebserver/internal/http2/Http2Server.java
index 160159d98e..185dde5bfc 100644
--- a/mockwebserver/src/test/java/okhttp3/mockwebserver/internal/http2/Http2Server.java
+++ b/mockwebserver/src/test/java/okhttp3/mockwebserver/internal/http2/Http2Server.java
@@ -29,6 +29,7 @@
 import javax.net.ssl.SSLSocketFactory;
 import okhttp3.Headers;
 import okhttp3.Protocol;
+import okhttp3.internal.concurrent.TaskRunner;
 import okhttp3.internal.http2.Header;
 import okhttp3.internal.http2.Http2Connection;
 import okhttp3.internal.http2.Http2Stream;
@@ -69,7 +70,7 @@ private void run() throws Exception {
         if (protocol != Protocol.HTTP_2) {
           throw new ProtocolException("Protocol " + protocol + " unsupported");
         }
-        Http2Connection connection = new Http2Connection.Builder(false)
+        Http2Connection connection = new Http2Connection.Builder(false, TaskRunner.INSTANCE)
             .socket(sslSocket)
             .listener(this)
             .build();
@@ -92,7 +93,7 @@ private SSLSocket doSsl(Socket socket) throws IOException {
     SSLSocket sslSocket = (SSLSocket) sslSocketFactory.createSocket(
         socket, socket.getInetAddress().getHostAddress(), socket.getPort(), true);
     sslSocket.setUseClientMode(false);
-    Platform.get().configureTlsExtensions(sslSocket, null,
+    Platform.get().configureTlsExtensions(sslSocket,
         Collections.singletonList(Protocol.HTTP_2));
     sslSocket.startHandshake();
     return sslSocket;
@@ -124,7 +125,7 @@ private SSLSocket doSsl(Socket socket) throws IOException {
         send404(stream, path);
       }
     } catch (IOException e) {
-      Platform.get().log(INFO, "Failure serving Http2Stream: " + e.getMessage(), null);
+      Platform.get().log("Failure serving Http2Stream: " + e.getMessage(), INFO, null);
     }
   }
 
diff --git a/okhttp-brotli/README.md b/okhttp-brotli/README.md
index 95d73f722e..6ed3f15371 100644
--- a/okhttp-brotli/README.md
+++ b/okhttp-brotli/README.md
@@ -14,7 +14,7 @@ OkHttpClient client = new OkHttpClient.Builder()
 ```
 
 ```kotlin
-implementation("com.squareup.okhttp3:okhttp-brotli:4.1.1")
+implementation("com.squareup.okhttp3:okhttp-brotli:4.2.1")
 ```
 
  [1]: https://github.com/google/brotli
diff --git a/okhttp-brotli/build.gradle b/okhttp-brotli/build.gradle
index c04a996383..ef901c0477 100644
--- a/okhttp-brotli/build.gradle
+++ b/okhttp-brotli/build.gradle
@@ -17,3 +17,10 @@ dependencies {
   testImplementation deps.junit
   testImplementation deps.assertj
 }
+
+afterEvaluate { project ->
+  project.tasks.dokka {
+    outputDirectory = "$rootDir/docs/4.x"
+    outputFormat = 'gfm'
+  }
+}
diff --git a/okhttp-dnsoverhttps/README.md b/okhttp-dnsoverhttps/README.md
index bd9c0ea601..638671f38b 100644
--- a/okhttp-dnsoverhttps/README.md
+++ b/okhttp-dnsoverhttps/README.md
@@ -7,5 +7,5 @@ API is not considered stable and may change at any time.
 ### Download
 
 ```kotlin
-testImplementation("com.squareup.okhttp3:okhttp-dnsoverhttps:4.1.1")
+testImplementation("com.squareup.okhttp3:okhttp-dnsoverhttps:4.2.1")
 ```
diff --git a/okhttp-dnsoverhttps/src/main/java/okhttp3/dnsoverhttps/DnsOverHttps.kt b/okhttp-dnsoverhttps/src/main/java/okhttp3/dnsoverhttps/DnsOverHttps.kt
index bb4d37cfc2..e8a35ed0cf 100644
--- a/okhttp-dnsoverhttps/src/main/java/okhttp3/dnsoverhttps/DnsOverHttps.kt
+++ b/okhttp-dnsoverhttps/src/main/java/okhttp3/dnsoverhttps/DnsOverHttps.kt
@@ -204,7 +204,7 @@ class DnsOverHttps internal constructor(
   @Throws(Exception::class)
   private fun readResponse(hostname: String, response: Response): List<InetAddress> {
     if (response.cacheResponse == null && response.protocol !== Protocol.HTTP_2) {
-      Platform.get().log(Platform.WARN, "Incorrect protocol: ${response.protocol}", null)
+      Platform.get().log("Incorrect protocol: ${response.protocol}", Platform.WARN)
     }
 
     response.use {
diff --git a/okhttp-logging-interceptor/README.md b/okhttp-logging-interceptor/README.md
index e09ca8fd50..5f0f513740 100644
--- a/okhttp-logging-interceptor/README.md
+++ b/okhttp-logging-interceptor/README.md
@@ -1,7 +1,7 @@
 Logging Interceptor
 ===================
 
-An [OkHttp interceptor][1] which logs HTTP request and response data.
+An [OkHttp interceptor][interceptors] which logs HTTP request and response data.
 
 ```java
 HttpLoggingInterceptor logging = new HttpLoggingInterceptor();
@@ -37,9 +37,8 @@ Download
 --------
 
 ```kotlin
-implementation("com.squareup.okhttp3:logging-interceptor:4.1.1")
+implementation("com.squareup.okhttp3:logging-interceptor:4.2.1")
 ```
 
 
-
- [1]: ../INTERCEPTORS.md
+[interceptors]: https://square.github.io/okhttp/interceptors/
diff --git a/okhttp-logging-interceptor/src/main/java/okhttp3/logging/HttpLoggingInterceptor.kt b/okhttp-logging-interceptor/src/main/java/okhttp3/logging/HttpLoggingInterceptor.kt
index 233142b7a3..e346c74f70 100644
--- a/okhttp-logging-interceptor/src/main/java/okhttp3/logging/HttpLoggingInterceptor.kt
+++ b/okhttp-logging-interceptor/src/main/java/okhttp3/logging/HttpLoggingInterceptor.kt
@@ -21,7 +21,6 @@ import okhttp3.OkHttpClient
 import okhttp3.Response
 import okhttp3.internal.http.promisesBody
 import okhttp3.internal.platform.Platform
-import okhttp3.internal.platform.Platform.Companion.INFO
 import okio.Buffer
 import okio.GzipSource
 import java.io.IOException
@@ -113,7 +112,7 @@ class HttpLoggingInterceptor @JvmOverloads constructor(
       @JvmField
       val DEFAULT: Logger = object : Logger {
         override fun log(message: String) {
-          Platform.get().log(INFO, message, null)
+          Platform.get().log(message)
         }
       }
     }
@@ -191,6 +190,8 @@ class HttpLoggingInterceptor @JvmOverloads constructor(
         logger.log("--> END ${request.method} (encoded body omitted)")
       } else if (requestBody.isDuplex()) {
         logger.log("--> END ${request.method} (duplex request body omitted)")
+      } else if (requestBody.isOneShot()) {
+        logger.log("--> END ${request.method} (one-shot body omitted)")
       } else {
         val buffer = Buffer()
         requestBody.writeTo(buffer)
diff --git a/okhttp-logging-interceptor/src/test/java/okhttp3/logging/HttpLoggingInterceptorTest.java b/okhttp-logging-interceptor/src/test/java/okhttp3/logging/HttpLoggingInterceptorTest.java
index 48e8a50e9e..3591bc9c0a 100644
--- a/okhttp-logging-interceptor/src/test/java/okhttp3/logging/HttpLoggingInterceptorTest.java
+++ b/okhttp-logging-interceptor/src/test/java/okhttp3/logging/HttpLoggingInterceptorTest.java
@@ -875,6 +875,51 @@ public void headersAreRedacted() throws Exception {
         .assertNoMoreLogs();
   }
 
+  @Test public void oneShotRequestsAreNotLogged() throws Exception {
+    url = server.url("/");
+
+    setLevel(Level.BODY);
+
+    server.enqueue(new MockResponse()
+                           .setBody("Hello response!"));
+
+    RequestBody asyncRequestBody = new RequestBody() {
+      @Override public @Nullable MediaType contentType() {
+        return null;
+      }
+
+      int counter = 0;
+      @Override public void writeTo(BufferedSink sink) throws IOException {
+        counter++;
+        assertThat(counter).isLessThanOrEqualTo(1);
+
+        sink.writeUtf8("Hello request!");
+        sink.close();
+      }
+
+      @Override public boolean isOneShot() {
+        return true;
+      }
+    };
+
+    Request request = request()
+                              .post(asyncRequestBody)
+                              .build();
+    Response response = client.newCall(request).execute();
+
+    assertThat(response.body().string()).isEqualTo("Hello response!");
+
+    applicationLogs
+            .assertLogEqual("--> POST " + url)
+            .assertLogEqual("--> END POST (one-shot body omitted)")
+            .assertLogMatch("<-- 200 OK " + url + " \\(\\d+ms\\)")
+            .assertLogEqual("Content-Length: 15")
+            .assertLogEqual("")
+            .assertLogEqual("Hello response!")
+            .assertLogEqual("<-- END HTTP (15-byte body)")
+            .assertNoMoreLogs();
+  }
+
   private Request.Builder request() {
     return new Request.Builder().url(url);
   }
diff --git a/okhttp-sse/README.md b/okhttp-sse/README.md
index a8d7227903..cf64bc1f8a 100644
--- a/okhttp-sse/README.md
+++ b/okhttp-sse/README.md
@@ -7,5 +7,5 @@ API is not considered stable and may change at any time.
 ### Download
 
 ```kotlin
-testImplementation("com.squareup.okhttp3:okhttp-sse:4.1.1")
+testImplementation("com.squareup.okhttp3:okhttp-sse:4.2.1")
 ```
diff --git a/okhttp-sse/src/test/java/okhttp3/internal/sse/EventSourceHttpTest.java b/okhttp-sse/src/test/java/okhttp3/internal/sse/EventSourceHttpTest.java
index be0e5e69db..d96f38e84d 100644
--- a/okhttp-sse/src/test/java/okhttp3/internal/sse/EventSourceHttpTest.java
+++ b/okhttp-sse/src/test/java/okhttp3/internal/sse/EventSourceHttpTest.java
@@ -24,7 +24,6 @@
 import okhttp3.sse.EventSource;
 import okhttp3.sse.EventSources;
 import org.junit.After;
-import org.junit.Before;
 import org.junit.Rule;
 import org.junit.Test;
 
@@ -35,11 +34,7 @@
   @Rule public final OkHttpClientTestRule clientTestRule = new OkHttpClientTestRule();
 
   private final EventSourceRecorder listener = new EventSourceRecorder();
-  private OkHttpClient client;
-
-  @Before public void setUp() {
-    client = clientTestRule.newClient();
-  }
+  private OkHttpClient client = clientTestRule.newClient();
 
   @After public void after() {
     listener.assertExhausted();
diff --git a/okhttp-sse/src/test/java/okhttp3/internal/sse/EventSourceRecorder.java b/okhttp-sse/src/test/java/okhttp3/internal/sse/EventSourceRecorder.java
index bc87c5a644..c96672d273 100644
--- a/okhttp-sse/src/test/java/okhttp3/internal/sse/EventSourceRecorder.java
+++ b/okhttp-sse/src/test/java/okhttp3/internal/sse/EventSourceRecorder.java
@@ -31,24 +31,24 @@
   private final BlockingQueue<Object> events = new LinkedBlockingDeque<>();
 
   @Override public void onOpen(EventSource eventSource, Response response) {
-    Platform.get().log(Platform.INFO, "[ES] onOpen", null);
+    Platform.get().log("[ES] onOpen", Platform.INFO, null);
     events.add(new Open(eventSource, response));
   }
 
   @Override public void onEvent(EventSource eventSource, @Nullable String id, @Nullable String type,
       String data) {
-    Platform.get().log(Platform.INFO, "[ES] onEvent", null);
+    Platform.get().log("[ES] onEvent", Platform.INFO, null);
     events.add(new Event(id, type, data));
   }
 
   @Override public void onClosed(EventSource eventSource) {
-    Platform.get().log(Platform.INFO, "[ES] onClosed", null);
+    Platform.get().log("[ES] onClosed", Platform.INFO, null);
     events.add(new Closed());
   }
 
   @Override
   public void onFailure(EventSource eventSource, @Nullable Throwable t, @Nullable Response response) {
-    Platform.get().log(Platform.INFO, "[ES] onFailure", t);
+    Platform.get().log("[ES] onFailure", Platform.INFO, t);
     events.add(new Failure(t, response));
   }
 
diff --git a/okhttp-testing-support/src/main/java/okhttp3/OkHttpClientTestRule.kt b/okhttp-testing-support/src/main/java/okhttp3/OkHttpClientTestRule.kt
index 6d3484807e..b4de378151 100644
--- a/okhttp-testing-support/src/main/java/okhttp3/OkHttpClientTestRule.kt
+++ b/okhttp-testing-support/src/main/java/okhttp3/OkHttpClientTestRule.kt
@@ -15,36 +15,43 @@
  */
 package okhttp3
 
+import okhttp3.internal.concurrent.TaskRunner
 import okhttp3.testing.Flaky
 import org.assertj.core.api.Assertions.assertThat
 import org.junit.rules.TestRule
 import org.junit.runner.Description
 import org.junit.runners.model.Statement
 import java.net.InetAddress
-import java.util.concurrent.ConcurrentLinkedDeque
+import java.util.concurrent.TimeUnit
 
 /** Apply this rule to tests that need an OkHttpClient instance. */
 class OkHttpClientTestRule : TestRule {
   private val clientEventsList = mutableListOf<String>()
-  private var prototype: OkHttpClient? = null
+  private var testClient: OkHttpClient? = null
 
   /**
-   * Returns an OkHttpClient for all tests to use as a starting point.
+   * Returns an OkHttpClient for tests to use as a starting point.
    *
-   * The shared instance allows all tests to share a single connection pool, which prevents idle
-   * connections from consuming unnecessary resources while connections wait to be evicted.
+   * The returned client installs a default event listener that gathers debug information. This will
+   * be logged if the test fails.
    *
    * This client is also configured to be slightly more deterministic, returning a single IP
    * address for all hosts, regardless of the actual number of IP addresses reported by DNS.
    */
   fun newClient(): OkHttpClient {
-    return newClientBuilder().build()
+    var client = testClient
+    if (client == null) {
+      client = OkHttpClient.Builder()
+          .dns(SINGLE_INET_ADDRESS_DNS) // Prevent unexpected fallback addresses.
+          .eventListener(ClientRuleEventListener { addEvent(it) })
+          .build()
+      testClient = client
+    }
+    return client
   }
 
   fun newClientBuilder(): OkHttpClient.Builder {
-    return checkNotNull(prototype) { "don't create clients in test initialization!" }
-        .newBuilder()
-        .eventListener(ClientRuleEventListener { addEvent(it) })
+    return newClient().newBuilder()
   }
 
   @Synchronized private fun addEvent(it: String) {
@@ -52,17 +59,24 @@ class OkHttpClientTestRule : TestRule {
   }
 
   fun ensureAllConnectionsReleased() {
-    prototype?.let {
+    testClient?.let {
       val connectionPool = it.connectionPool
       connectionPool.evictAll()
       assertThat(connectionPool.connectionCount()).isEqualTo(0)
     }
   }
 
+  private fun ensureAllTaskQueuesIdle() {
+    for (queue in TaskRunner.INSTANCE.activeQueues()) {
+      assertThat(queue.awaitIdle(TimeUnit.MILLISECONDS.toNanos(1000L)))
+          .withFailMessage("Queue still active after 1000ms")
+          .isTrue()
+    }
+  }
+
   override fun apply(base: Statement, description: Description): Statement {
     return object : Statement() {
       override fun evaluate() {
-        acquireClient()
         try {
           base.evaluate()
           logEventsIfFlaky(description)
@@ -72,18 +86,12 @@ class OkHttpClientTestRule : TestRule {
         } finally {
           ensureAllConnectionsReleased()
           releaseClient()
+          ensureAllTaskQueuesIdle()
         }
       }
 
-      private fun acquireClient() {
-        prototype = prototypes.poll() ?: freshClient()
-      }
-
       private fun releaseClient() {
-        prototype?.let {
-          prototypes.push(it)
-          prototype = null
-        }
+        testClient?.dispatcher?.executorService?.shutdown()
       }
     }
   }
@@ -108,40 +116,16 @@ class OkHttpClientTestRule : TestRule {
     }
   }
 
-  /**
-   * Called if a test is known to be leaky.
-   */
-  fun abandonClient() {
-    prototype?.let {
-      prototype = null
-      it.dispatcher.executorService.shutdownNow()
-      it.connectionPool.evictAll()
-    }
-  }
-
   companion object {
-    /**
-     * Quick and dirty pool of OkHttpClient instances. Each has its own independent dispatcher and
-     * connection pool. This way we can reuse expensive resources while preventing concurrent tests
-     * from interfering with each other.
-     */
-    internal val prototypes = ConcurrentLinkedDeque<OkHttpClient>()
-
     /**
      * A network that resolves only one IP address per host. Use this when testing route selection
      * fallbacks to prevent the host machine's various IP addresses from interfering.
      */
-    internal val SINGLE_INET_ADDRESS_DNS = object : Dns {
+    private val SINGLE_INET_ADDRESS_DNS = object : Dns {
       override fun lookup(hostname: String): List<InetAddress> {
         val addresses = Dns.SYSTEM.lookup(hostname)
         return listOf(addresses[0])
       }
     }
-
-    private fun freshClient(): OkHttpClient {
-      return OkHttpClient.Builder()
-          .dns(SINGLE_INET_ADDRESS_DNS) // Prevent unexpected fallback addresses.
-          .build()
-    }
   }
 }
diff --git a/okhttp-tls/README.md b/okhttp-tls/README.md
index ec3f7857dd..52a4bfc321 100644
--- a/okhttp-tls/README.md
+++ b/okhttp-tls/README.md
@@ -227,7 +227,7 @@ Download
 --------
 
 ```kotlin
-implementation("com.squareup.okhttp3:okhttp-tls:4.1.1")
+implementation("com.squareup.okhttp3:okhttp-tls:4.2.1")
 ```
 
  [held_certificate]: http://square.github.io/okhttp/4.x/okhttp-tls/okhttp3.tls/-held-certificate/
diff --git a/okhttp-tls/src/main/java/okhttp3/tls/HeldCertificate.kt b/okhttp-tls/src/main/java/okhttp3/tls/HeldCertificate.kt
index 6fae9ee615..e82a9fde19 100644
--- a/okhttp-tls/src/main/java/okhttp3/tls/HeldCertificate.kt
+++ b/okhttp-tls/src/main/java/okhttp3/tls/HeldCertificate.kt
@@ -16,7 +16,9 @@
 package okhttp3.tls
 
 import okhttp3.internal.canParseAsIpAddress
+import okio.Buffer
 import okio.ByteString
+import okio.ByteString.Companion.decodeBase64
 import okio.ByteString.Companion.toByteString
 import org.bouncycastle.asn1.ASN1Encodable
 import org.bouncycastle.asn1.DERSequence
@@ -27,14 +29,20 @@ import org.bouncycastle.asn1.x509.X509Extensions
 import org.bouncycastle.jce.provider.BouncyCastleProvider
 import org.bouncycastle.x509.X509V3CertificateGenerator
 import java.math.BigInteger
+import java.security.GeneralSecurityException
+import java.security.KeyFactory
 import java.security.KeyPair
 import java.security.KeyPairGenerator
 import java.security.PrivateKey
 import java.security.PublicKey
 import java.security.SecureRandom
 import java.security.Security
+import java.security.cert.CertificateFactory
 import java.security.cert.X509Certificate
+import java.security.interfaces.ECPublicKey
 import java.security.interfaces.RSAPrivateKey
+import java.security.interfaces.RSAPublicKey
+import java.security.spec.PKCS8EncodedKeySpec
 import java.util.Date
 import java.util.UUID
 import java.util.concurrent.TimeUnit
@@ -353,7 +361,7 @@ class HeldCertificate(
         BigInteger.ONE
       }
       val signatureAlgorithm = if (signedByKeyPair.private is RSAPrivateKey) {
-        "SHA256WithRSAEncryption"
+        "SHA256WithRSA"
       } else {
         "SHA256withECDSA"
       }
@@ -419,4 +427,103 @@ class HeldCertificate(
       }
     }
   }
+
+  companion object {
+    private val PEM_REGEX = Regex("""-----BEGIN ([!-,.-~ ]*)-----([^-]*)-----END \1-----""")
+
+    /**
+     * Decodes a multiline string that contains both a [certificate][certificatePem] and a
+     * [private key][privateKeyPkcs8Pem], both [PEM-encoded][rfc_7468]. A typical input string looks
+     * like this:
+     *
+     * ```
+     * -----BEGIN CERTIFICATE-----
+     * MIIBYTCCAQegAwIBAgIBKjAKBggqhkjOPQQDAjApMRQwEgYDVQQLEwtlbmdpbmVl
+     * cmluZzERMA8GA1UEAxMIY2FzaC5hcHAwHhcNNzAwMTAxMDAwMDA1WhcNNzAwMTAx
+     * MDAwMDEwWjApMRQwEgYDVQQLEwtlbmdpbmVlcmluZzERMA8GA1UEAxMIY2FzaC5h
+     * cHAwWTATBgcqhkjOPQIBBggqhkjOPQMBBwNCAASda8ChkQXxGELnrV/oBnIAx3dD
+     * ocUOJfdz4pOJTP6dVQB9U3UBiW5uSX/MoOD0LL5zG3bVyL3Y6pDwKuYvfLNhoyAw
+     * HjAcBgNVHREBAf8EEjAQhwQBAQEBgghjYXNoLmFwcDAKBggqhkjOPQQDAgNIADBF
+     * AiAyHHg1N6YDDQiY920+cnI5XSZwEGhAtb9PYWO8bLmkcQIhAI2CfEZf3V/obmdT
+     * yyaoEufLKVXhrTQhRfodTeigi4RX
+     * -----END CERTIFICATE-----
+     * -----BEGIN PRIVATE KEY-----
+     * MEECAQAwEwYHKoZIzj0CAQYIKoZIzj0DAQcEJzAlAgEBBCA7ODT0xhGSNn4ESj6J
+     * lu/GJQZoU9lDrCPeUcQ28tzOWw==
+     * -----END PRIVATE KEY-----
+     * ```
+     *
+     * The string should contain exactly one certificate and one private key in [PKCS #8][rfc_5208]
+     * format. It should not contain any other PEM-encoded blocks, but it may contain other text
+     * which will be ignored.
+     *
+     * Encode a held certificate into this format by concatenating the results of
+     * [certificatePem()][certificatePem] and [privateKeyPkcs8Pem()][privateKeyPkcs8Pem].
+     *
+     * [rfc_7468]: https://tools.ietf.org/html/rfc7468
+     * [rfc_5208]: https://tools.ietf.org/html/rfc5208
+     */
+    @JvmStatic
+    fun decode(certificateAndPrivateKeyPem: String): HeldCertificate {
+      var certificatePem: String? = null
+      var pkcs8Base64: String? = null
+      for (match in PEM_REGEX.findAll(certificateAndPrivateKeyPem)) {
+        when (val label = match.groups[1]!!.value) {
+          "CERTIFICATE" -> {
+            require(certificatePem == null) { "string includes multiple certificates" }
+            certificatePem = match.groups[0]!!.value // Keep --BEGIN-- and --END-- for certificates.
+          }
+          "PRIVATE KEY" -> {
+            require(pkcs8Base64 == null) { "string includes multiple private keys" }
+            pkcs8Base64 = match.groups[2]!!.value // Include the contents only for PKCS8.
+          }
+          else -> {
+            throw IllegalArgumentException("unexpected type: $label")
+          }
+        }
+      }
+      require(certificatePem != null) { "string does not include a certificate" }
+      require(pkcs8Base64 != null) { "string does not include a private key" }
+
+      return decode(certificatePem, pkcs8Base64)
+    }
+
+    private fun decode(certificatePem: String, pkcs8Base64Text: String): HeldCertificate {
+      val certificate = try {
+        decodePem(certificatePem)
+      } catch (e: GeneralSecurityException) {
+        throw IllegalArgumentException("failed to decode certificate", e)
+      }
+
+      val privateKey = try {
+        val pkcs8Bytes = pkcs8Base64Text.decodeBase64()
+            ?: throw IllegalArgumentException("failed to decode private key")
+
+        // The private key doesn't tell us its type but it's okay because the certificate knows!
+        val keyType = when (certificate.publicKey) {
+          is ECPublicKey -> "EC"
+          is RSAPublicKey -> "RSA"
+          else -> throw IllegalArgumentException("unexpected key type: ${certificate.publicKey}")
+        }
+
+        decodePkcs8(pkcs8Bytes, keyType)
+      } catch (e: GeneralSecurityException) {
+        throw IllegalArgumentException("failed to decode private key", e)
+      }
+
+      val keyPair = KeyPair(certificate.publicKey, privateKey)
+      return HeldCertificate(keyPair, certificate)
+    }
+
+    private fun decodePem(pem: String): X509Certificate {
+      val certificates = CertificateFactory.getInstance("X.509")
+          .generateCertificates(Buffer().writeUtf8(pem).inputStream())
+      return certificates.iterator().next() as X509Certificate
+    }
+
+    private fun decodePkcs8(data: ByteString, keyAlgorithm: String): PrivateKey {
+      val keyFactory = KeyFactory.getInstance(keyAlgorithm)
+      return keyFactory.generatePrivate(PKCS8EncodedKeySpec(data.toByteArray()))
+    }
+  }
 }
diff --git a/okhttp-tls/src/test/java/okhttp3/tls/HeldCertificateTest.java b/okhttp-tls/src/test/java/okhttp3/tls/HeldCertificateTest.java
index 76dbeb81f1..378e154069 100644
--- a/okhttp-tls/src/test/java/okhttp3/tls/HeldCertificateTest.java
+++ b/okhttp-tls/src/test/java/okhttp3/tls/HeldCertificateTest.java
@@ -31,6 +31,7 @@
 import static java.util.Arrays.asList;
 import static org.assertj.core.api.Assertions.assertThat;
 import static org.assertj.core.data.Offset.offset;
+import static org.junit.Assert.fail;
 
 public final class HeldCertificateTest {
   @Test public void defaultCertificate() throws CertificateParsingException {
@@ -219,4 +220,268 @@
     assertThat(root.certificate().getSigAlgName()).isEqualTo("SHA256WITHECDSA");
     assertThat(leaf.certificate().getSigAlgName()).isEqualTo("SHA256WITHECDSA");
   }
+
+  @Test public void decodeEcdsa256() throws Exception {
+    // The certificate + private key below was generated programmatically:
+    //
+    // HeldCertificate heldCertificate = new HeldCertificate.Builder()
+    //     .validityInterval(5_000L, 10_000L)
+    //     .addSubjectAlternativeName("1.1.1.1")
+    //     .addSubjectAlternativeName("cash.app")
+    //     .serialNumber(42L)
+    //     .commonName("cash.app")
+    //     .organizationalUnit("engineering")
+    //     .ecdsa256()
+    //     .build();
+
+    String certificatePem = ""
+        + "-----BEGIN CERTIFICATE-----\n"
+        + "MIIBYTCCAQegAwIBAgIBKjAKBggqhkjOPQQDAjApMRQwEgYDVQQLEwtlbmdpbmVl\n"
+        + "cmluZzERMA8GA1UEAxMIY2FzaC5hcHAwHhcNNzAwMTAxMDAwMDA1WhcNNzAwMTAx\n"
+        + "MDAwMDEwWjApMRQwEgYDVQQLEwtlbmdpbmVlcmluZzERMA8GA1UEAxMIY2FzaC5h\n"
+        + "cHAwWTATBgcqhkjOPQIBBggqhkjOPQMBBwNCAASda8ChkQXxGELnrV/oBnIAx3dD\n"
+        + "ocUOJfdz4pOJTP6dVQB9U3UBiW5uSX/MoOD0LL5zG3bVyL3Y6pDwKuYvfLNhoyAw\n"
+        + "HjAcBgNVHREBAf8EEjAQhwQBAQEBgghjYXNoLmFwcDAKBggqhkjOPQQDAgNIADBF\n"
+        + "AiAyHHg1N6YDDQiY920+cnI5XSZwEGhAtb9PYWO8bLmkcQIhAI2CfEZf3V/obmdT\n"
+        + "yyaoEufLKVXhrTQhRfodTeigi4RX\n"
+        + "-----END CERTIFICATE-----\n";
+    String pkcs8Pem = ""
+        + "-----BEGIN PRIVATE KEY-----\n"
+        + "MEECAQAwEwYHKoZIzj0CAQYIKoZIzj0DAQcEJzAlAgEBBCA7ODT0xhGSNn4ESj6J\n"
+        + "lu/GJQZoU9lDrCPeUcQ28tzOWw==\n"
+        + "-----END PRIVATE KEY-----\n";
+
+    HeldCertificate heldCertificate = HeldCertificate.decode(certificatePem + pkcs8Pem);
+    assertThat(heldCertificate.certificatePem()).isEqualTo(certificatePem);
+    assertThat(heldCertificate.privateKeyPkcs8Pem()).isEqualTo(pkcs8Pem);
+
+    X509Certificate certificate = heldCertificate.certificate();
+    assertThat(certificate.getNotBefore().getTime()).isEqualTo(5_000L);
+    assertThat(certificate.getNotAfter().getTime()).isEqualTo(10_000L);
+
+    assertThat(certificate.getSubjectAlternativeNames()).containsExactly(
+        asList(GeneralName.iPAddress, "1.1.1.1"),
+        asList(GeneralName.dNSName, "cash.app"));
+
+    assertThat(certificate.getSubjectX500Principal().getName())
+        .isEqualTo("CN=cash.app,OU=engineering");
+  }
+
+  @Test public void decodeRsa512() throws Exception {
+    // The certificate + private key below was generated with OpenSSL. Never generate certificates
+    // with MD5 or 512-bit RSA; that's insecure!
+    //
+    // openssl req \
+    //   -x509 \
+    //   -md5 \
+    //   -nodes \
+    //   -days 1 \
+    //   -newkey rsa:512 \
+    //   -keyout privateKey.key \
+    //   -out certificate.crt
+
+    String certificatePem = ""
+        + "-----BEGIN CERTIFICATE-----\n"
+        + "MIIBFzCBwgIJAIVAqagcVN7/MA0GCSqGSIb3DQEBBAUAMBMxETAPBgNVBAMMCGNh\n"
+        + "c2guYXBwMB4XDTE5MDkwNzAyMjg0NFoXDTE5MDkwODAyMjg0NFowEzERMA8GA1UE\n"
+        + "AwwIY2FzaC5hcHAwXDANBgkqhkiG9w0BAQEFAANLADBIAkEA8qAeoubm4mBTD9/J\n"
+        + "ujLQkfk/fuJt/T5pVQ1vUEqxfcMw0zYgszQ5C2MiIl7M6JkTRKU01q9hVFCR83wX\n"
+        + "zIdrLQIDAQABMA0GCSqGSIb3DQEBBAUAA0EAO1UpwhrkW3Ho1nZK/taoUQOoqz/n\n"
+        + "HFVMtyEkm5gBDgz8nJXwb3zbegclQyH+kVou02S8zC5WWzEtd0R8S0LsTA==\n"
+        + "-----END CERTIFICATE-----\n";
+    String pkcs8Pem = ""
+        + "-----BEGIN PRIVATE KEY-----\n"
+        + "MIIBVQIBADANBgkqhkiG9w0BAQEFAASCAT8wggE7AgEAAkEA8qAeoubm4mBTD9/J\n"
+        + "ujLQkfk/fuJt/T5pVQ1vUEqxfcMw0zYgszQ5C2MiIl7M6JkTRKU01q9hVFCR83wX\n"
+        + "zIdrLQIDAQABAkEA7dEA9o/5k77y68ZhRv9z7QEwucBcKzQ3rsSCbWMpYqg924F9\n"
+        + "L8Z76kzSedSO2PN8mg6y/OLL+qBuTeUK/yiowQIhAP0cknFMbqeNX6uvj/S+V7in\n"
+        + "bIhQkhcSdJjRw8fxMnJpAiEA9WTp9wzJpn+9etZo0jJ8wkM0+LTMNELo47Ctz7l1\n"
+        + "kiUCIQCi34vslD5wWyzBEcwUtZdFH5dbcF1Rs3KMFA9jzfWkYQIgHtiWiFV1K5a3\n"
+        + "DK/S8UkjYY/tIq4nVRJsD+LvlkLrwnkCIECcz4yF4HQgv+Tbzj/gGSBl1VIliTcB\n"
+        + "Rc5RUQ0mZJQF\n"
+        + "-----END PRIVATE KEY-----\n";
+
+    HeldCertificate heldCertificate = HeldCertificate.decode(pkcs8Pem + certificatePem);
+    assertThat(heldCertificate.certificatePem()).isEqualTo(certificatePem);
+    assertThat(heldCertificate.privateKeyPkcs8Pem()).isEqualTo(pkcs8Pem);
+
+    X509Certificate certificate = heldCertificate.certificate();
+    assertThat(certificate.getSubjectX500Principal().getName())
+        .isEqualTo("CN=cash.app");
+  }
+
+  @Test public void decodeRsa2048() throws Exception {
+    // The certificate + private key below was generated programmatically:
+    //
+    // HeldCertificate heldCertificate = new HeldCertificate.Builder()
+    //     .validityInterval(5_000L, 10_000L)
+    //     .addSubjectAlternativeName("1.1.1.1")
+    //     .addSubjectAlternativeName("cash.app")
+    //     .serialNumber(42L)
+    //     .commonName("cash.app")
+    //     .organizationalUnit("engineering")
+    //     .rsa2048()
+    //     .build();
+
+    String certificatePem = ""
+        + "-----BEGIN CERTIFICATE-----\n"
+        + "MIIC7TCCAdWgAwIBAgIBKjANBgkqhkiG9w0BAQsFADApMRQwEgYDVQQLEwtlbmdp\n"
+        + "bmVlcmluZzERMA8GA1UEAxMIY2FzaC5hcHAwHhcNNzAwMTAxMDAwMDA1WhcNNzAw\n"
+        + "MTAxMDAwMDEwWjApMRQwEgYDVQQLEwtlbmdpbmVlcmluZzERMA8GA1UEAxMIY2Fz\n"
+        + "aC5hcHAwggEiMA0GCSqGSIb3DQEBAQUAA4IBDwAwggEKAoIBAQCaU+vrUPL0APGI\n"
+        + "SXIuRX4xRrigXmGKx+GRPnWDWvGJwOm23Vpq/eZxQx6PbSUB1+QZzAwge20RpNAp\n"
+        + "2lt5/qFtgUpEon2j06rd/0+ODqqVJX+6d3SpmF1fPfKUB6AOZbxEkaJpBSTavoTg\n"
+        + "G2M/NMdjZjrcB3quNQcLg54mmI3HJm1zOd/8i2fZjvoiyVY30Inn2SmQsAotXw1u\n"
+        + "aE/319bnR2sQlnkp6MJU0eLEtKyRif/IODvY+mtRYYdkFtoeT6qQPMIh+gF/H3to\n"
+        + "5tjs3g59QC8k2TJDop4EFYUOwdrtnb8wUiBnLyURD1szASE2IO2Ftk1zaNOPKtrv\n"
+        + "VeJuB/mpAgMBAAGjIDAeMBwGA1UdEQEB/wQSMBCHBAEBAQGCCGNhc2guYXBwMA0G\n"
+        + "CSqGSIb3DQEBCwUAA4IBAQAPm7vfk+rxSucxxbFiimmFKBw+ymieLY/kznNh0lHJ\n"
+        + "q15fsMYK7TTTt2FFqyfVXhhRZegLrkrGb3+4Dz1uNtcRrjT4qo+T/JOuZGxtBLbm\n"
+        + "4/hkFSYavtd2FW+/CK7EnQKUyabgLOblb21IHOlcPwpSe6KkJjpwq0TV/ozzfk/q\n"
+        + "kGRA7/Ubn5TMRYyHWnod2SS14+BkItcWN03Z7kvyMYrpNZpu6vQRYsqJJFMcmpGZ\n"
+        + "sZQW31gO2arPmfNotkQdFdNL12c9YZKkJGhyK6NcpffD2l6O9NS5SRD5RnkvBxQw\n"
+        + "fX5DamL8je/YKSLQ4wgUA/5iVKlCiJGQi6fYIJ0kxayO\n"
+        + "-----END CERTIFICATE-----\n";
+    String pkcs8Pem = ""
+        + "-----BEGIN PRIVATE KEY-----\n"
+        + "MIIEvwIBADANBgkqhkiG9w0BAQEFAASCBKkwggSlAgEAAoIBAQCaU+vrUPL0APGI\n"
+        + "SXIuRX4xRrigXmGKx+GRPnWDWvGJwOm23Vpq/eZxQx6PbSUB1+QZzAwge20RpNAp\n"
+        + "2lt5/qFtgUpEon2j06rd/0+ODqqVJX+6d3SpmF1fPfKUB6AOZbxEkaJpBSTavoTg\n"
+        + "G2M/NMdjZjrcB3quNQcLg54mmI3HJm1zOd/8i2fZjvoiyVY30Inn2SmQsAotXw1u\n"
+        + "aE/319bnR2sQlnkp6MJU0eLEtKyRif/IODvY+mtRYYdkFtoeT6qQPMIh+gF/H3to\n"
+        + "5tjs3g59QC8k2TJDop4EFYUOwdrtnb8wUiBnLyURD1szASE2IO2Ftk1zaNOPKtrv\n"
+        + "VeJuB/mpAgMBAAECggEAOlOXaYNZn1Cv+INRrR1EmVkSNEIXeX0bymohvbhka1zG\n"
+        + "t/8myiMVsh7c8PYeM3kl034j4y7ixPVWW0sUoaHT3vArYo9LDtzTyj1REu6GGAJp\n"
+        + "KM82/1X/jBx8jufm3SokIoIsMKbqC+ZPj+ep9dx7sxyTCE+nVSnjdL2Uyx+DDg3o\n"
+        + "na237HTScWIi+tMv5QGEwqLHS2q+NZYfjgnSxNY8BRw4XZCcIZRko9niuB5gUjj/\n"
+        + "y01HwvOCWuOMaSKZak1OdOaz3427/TkhYIqf6ft0ELF+ASRk3BLQA06pRt88H3u2\n"
+        + "3vsHJsWr2rkCN0h9uDp2o50ZQ5fvlxqG0QIZmvkIkQKBgQDOHeZKvXO5IxQ+S8ed\n"
+        + "09bC5SKiclCdW+Ry7N2x1MBfrxc4TTTTNaUN9Qdc6RXANG9bX2CJv0Dkh/0yH3z9\n"
+        + "Bdq6YcoP6DFCX46jwhCKvxMX9h9PFLvY7l2VSe7NfboGzvYLCy8ErsGuio8u9MHZ\n"
+        + "osX2ch6Gdhn1xUwLCw+T7rNwjQKBgQC/rWb0sWfgbKhEqV+u5oov+fFjooWmTQlQ\n"
+        + "jcj+lMWUOkitnPmX9TsH5JDa8I89Y0gJGu7Lfg8XSH+4FCCfX3mSLYwVH5vAIvmr\n"
+        + "TjMqRwSahQuTr/g+lx7alpcUHYv3z6b3WYIXFPPr3t7grWNJ14wMv9DnItWOg84H\n"
+        + "LlxAvXXsjQKBgQCRPPhdignVVyaYjwVl7TPTuWoiVbMAbxQW91lwSZ4UzmfqQF0M\n"
+        + "xyw7HYHGsmelPE2LcTWxWpb7cee0PgPwtwNdejLL6q1rO7JjKghF/EYUCFYff1iu\n"
+        + "j6hZ3fLr0cAXtBYjygmjnxDTUMd8KvO9y7j644cm8GlyiUgAMBcWAolmsQKBgQCT\n"
+        + "AJQTWfPGxM6QSi3d32VfwhsFROGnVzGrm/HofYTCV6jhraAmkKcDOKJ3p0LT286l\n"
+        + "XQiC/FzqiGmbbaRPVlPQbiofESzMQIamgMTwyaKYNy1XyP9kUVYSYqfff4GXPqRY\n"
+        + "00bYGPOxlC3utkuNmEgKhxnaCncqY5+hFkceR6+nCQKBgQC1Gonjhw0lYe43aHpp\n"
+        + "nDJKv3FnyN3wxjsR2c9sWpDzHA6CMVhSeLoXCB9ishmrSE/CygNlTU1TEy63xN22\n"
+        + "+dMHl5I/urMesjKKWiKZHdbWVIjJDv25r3jrN9VLr4q6AD9r1Su5G0o2j0N5ujVg\n"
+        + "SzpFHp+ZzhL/SANa8EqlcF6ItQ==\n"
+        + "-----END PRIVATE KEY-----\n";
+
+    HeldCertificate heldCertificate = HeldCertificate.decode(pkcs8Pem + certificatePem);
+    assertThat(heldCertificate.certificatePem()).isEqualTo(certificatePem);
+    assertThat(heldCertificate.privateKeyPkcs8Pem()).isEqualTo(pkcs8Pem);
+
+    X509Certificate certificate = heldCertificate.certificate();
+    assertThat(certificate.getNotBefore().getTime()).isEqualTo(5_000L);
+    assertThat(certificate.getNotAfter().getTime()).isEqualTo(10_000L);
+
+    assertThat(certificate.getSubjectAlternativeNames()).containsExactly(
+        asList(GeneralName.iPAddress, "1.1.1.1"),
+        asList(GeneralName.dNSName, "cash.app"));
+
+    assertThat(certificate.getSubjectX500Principal().getName())
+        .isEqualTo("CN=cash.app,OU=engineering");
+  }
+
+  @Test public void decodeWrongNumber() {
+    String certificatePem = ""
+        + "-----BEGIN CERTIFICATE-----\n"
+        + "MIIBYTCCAQegAwIBAgIBKjAKBggqhkjOPQQDAjApMRQwEgYDVQQLEwtlbmdpbmVl\n"
+        + "cmluZzERMA8GA1UEAxMIY2FzaC5hcHAwHhcNNzAwMTAxMDAwMDA1WhcNNzAwMTAx\n"
+        + "MDAwMDEwWjApMRQwEgYDVQQLEwtlbmdpbmVlcmluZzERMA8GA1UEAxMIY2FzaC5h\n"
+        + "cHAwWTATBgcqhkjOPQIBBggqhkjOPQMBBwNCAASda8ChkQXxGELnrV/oBnIAx3dD\n"
+        + "ocUOJfdz4pOJTP6dVQB9U3UBiW5uSX/MoOD0LL5zG3bVyL3Y6pDwKuYvfLNhoyAw\n"
+        + "HjAcBgNVHREBAf8EEjAQhwQBAQEBgghjYXNoLmFwcDAKBggqhkjOPQQDAgNIADBF\n"
+        + "AiAyHHg1N6YDDQiY920+cnI5XSZwEGhAtb9PYWO8bLmkcQIhAI2CfEZf3V/obmdT\n"
+        + "yyaoEufLKVXhrTQhRfodTeigi4RX\n"
+        + "-----END CERTIFICATE-----\n";
+    String pkcs8Pem = ""
+        + "-----BEGIN PRIVATE KEY-----\n"
+        + "MEECAQAwEwYHKoZIzj0CAQYIKoZIzj0DAQcEJzAlAgEBBCA7ODT0xhGSNn4ESj6J\n"
+        + "lu/GJQZoU9lDrCPeUcQ28tzOWw==\n"
+        + "-----END PRIVATE KEY-----\n";
+
+    try {
+      HeldCertificate.decode(certificatePem);
+      fail();
+    } catch (IllegalArgumentException expected) {
+      assertThat(expected).hasMessage("string does not include a private key");
+    }
+
+    try {
+      HeldCertificate.decode(pkcs8Pem);
+      fail();
+    } catch (IllegalArgumentException expected) {
+      assertThat(expected).hasMessage("string does not include a certificate");
+    }
+
+    try {
+      HeldCertificate.decode(certificatePem + pkcs8Pem + certificatePem);
+      fail();
+    } catch (IllegalArgumentException expected) {
+      assertThat(expected).hasMessage("string includes multiple certificates");
+    }
+
+    try {
+      HeldCertificate.decode(pkcs8Pem + certificatePem + pkcs8Pem);
+      fail();
+    } catch (IllegalArgumentException expected) {
+      assertThat(expected).hasMessage("string includes multiple private keys");
+    }
+  }
+
+  @Test public void decodeWrongType() {
+    try {
+      HeldCertificate.decode(""
+          + "-----BEGIN CERTIFICATE-----\n"
+          + "MIIBmjCCAQOgAwIBAgIBATANBgkqhkiG9w0BAQsFADATMREwDwYDVQQDEwhjYXNo\n"
+          + "-----END CERTIFICATE-----\n"
+          + "-----BEGIN RSA PRIVATE KEY-----\n"
+          + "sXPVYAsGD1wizrXX+wFaL3chtF1oG1Fx/jcsSsG6BA==\n"
+          + "-----END RSA PRIVATE KEY-----\n");
+      fail();
+    } catch (IllegalArgumentException expected) {
+      assertThat(expected).hasMessage("unexpected type: RSA PRIVATE KEY");
+    }
+  }
+
+  @Test public void decodeMalformed() {
+    try {
+      HeldCertificate.decode(""
+          + "-----BEGIN CERTIFICATE-----\n"
+          + "MIIBYTCCAQegAwIBAgIBKjAKBggqhkjOPQQDAjApMRQwEgYDVQQLEwtlbmdpbmVl\n"
+          + "-----END CERTIFICATE-----\n"
+          + "-----BEGIN PRIVATE KEY-----\n"
+          + "MEECAQAwEwYHKoZIzj0CAQYIKoZIzj0DAQcEJzAlAgEBBCA7ODT0xhGSNn4ESj6J\n"
+          + "lu/GJQZoU9lDrCPeUcQ28tzOWw==\n"
+          + "-----END PRIVATE KEY-----\n");
+      fail();
+    } catch (IllegalArgumentException expected) {
+      assertThat(expected).hasMessage("failed to decode certificate");
+    }
+    try {
+      HeldCertificate.decode(""
+          + "-----BEGIN CERTIFICATE-----\n"
+          + "MIIBYTCCAQegAwIBAgIBKjAKBggqhkjOPQQDAjApMRQwEgYDVQQLEwtlbmdpbmVl\n"
+          + "cmluZzERMA8GA1UEAxMIY2FzaC5hcHAwHhcNNzAwMTAxMDAwMDA1WhcNNzAwMTAx\n"
+          + "MDAwMDEwWjApMRQwEgYDVQQLEwtlbmdpbmVlcmluZzERMA8GA1UEAxMIY2FzaC5h\n"
+          + "cHAwWTATBgcqhkjOPQIBBggqhkjOPQMBBwNCAASda8ChkQXxGELnrV/oBnIAx3dD\n"
+          + "ocUOJfdz4pOJTP6dVQB9U3UBiW5uSX/MoOD0LL5zG3bVyL3Y6pDwKuYvfLNhoyAw\n"
+          + "HjAcBgNVHREBAf8EEjAQhwQBAQEBgghjYXNoLmFwcDAKBggqhkjOPQQDAgNIADBF\n"
+          + "AiAyHHg1N6YDDQiY920+cnI5XSZwEGhAtb9PYWO8bLmkcQIhAI2CfEZf3V/obmdT\n"
+          + "yyaoEufLKVXhrTQhRfodTeigi4RX\n"
+          + "-----END CERTIFICATE-----\n"
+          + "-----BEGIN PRIVATE KEY-----\n"
+          + "MEECAQAwEwYHKoZIzj0CAQYIKoZIzj0DAQcEJzAlAgEBBCA7ODT0xhGSNn4ESj6J\n"
+          + "-----END PRIVATE KEY-----\n");
+      fail();
+    } catch (IllegalArgumentException expected) {
+      assertThat(expected).hasMessage("failed to decode private key");
+    }
+  }
 }
diff --git a/okhttp-urlconnection/README.md b/okhttp-urlconnection/README.md
index fffe6dbd9c..56064181cb 100644
--- a/okhttp-urlconnection/README.md
+++ b/okhttp-urlconnection/README.md
@@ -6,5 +6,5 @@ This module integrates OkHttp with `Authenticator` and `CookieHandler` from `jav
 ### Download
 
 ```kotlin
-testImplementation("com.squareup.okhttp3:okhttp-urlconnection:4.1.1")
+testImplementation("com.squareup.okhttp3:okhttp-urlconnection:4.2.1")
 ```
diff --git a/okhttp-urlconnection/src/main/java/okhttp3/JavaNetCookieJar.kt b/okhttp-urlconnection/src/main/java/okhttp3/JavaNetCookieJar.kt
index 0b3f7afa85..ea8b2fb1ba 100644
--- a/okhttp-urlconnection/src/main/java/okhttp3/JavaNetCookieJar.kt
+++ b/okhttp-urlconnection/src/main/java/okhttp3/JavaNetCookieJar.kt
@@ -37,7 +37,7 @@ class JavaNetCookieJar(private val cookieHandler: CookieHandler) : CookieJar {
     try {
       cookieHandler.put(url.toUri(), multimap)
     } catch (e: IOException) {
-      Platform.get().log(WARN, "Saving cookies failed for " + url.resolve("/...")!!, e)
+      Platform.get().log("Saving cookies failed for " + url.resolve("/...")!!, WARN, e)
     }
   }
 
@@ -46,7 +46,7 @@ class JavaNetCookieJar(private val cookieHandler: CookieHandler) : CookieJar {
       // The RI passes all headers. We don't have 'em, so we don't pass 'em!
       cookieHandler.get(url.toUri(), emptyMap<String, List<String>>())
     } catch (e: IOException) {
-      Platform.get().log(WARN, "Loading cookies failed for " + url.resolve("/...")!!, e)
+      Platform.get().log("Loading cookies failed for " + url.resolve("/...")!!, WARN, e)
       return emptyList()
     }
 
diff --git a/okhttp/build.gradle b/okhttp/build.gradle
index 087ca5b6f8..8c88317eb9 100644
--- a/okhttp/build.gradle
+++ b/okhttp/build.gradle
@@ -25,9 +25,9 @@ task copyJavaTemplates(type: Copy) {
 dependencies {
   api deps.okio
   api deps.kotlinStdlib
+  compileOnly deps.android
   compileOnly deps.conscrypt
   compileOnly deps.openjsse
-  compileOnly deps.android
   compileOnly deps.jsr305
   compileOnly deps.animalSniffer
 
@@ -50,6 +50,10 @@ afterEvaluate { project ->
   }
 }
 
+animalsniffer {
+    ignore 'javax.net.ssl.SSLParameters', 'javax.net.ssl.SSLSocket'
+}
+
 task japicmp(type: me.champeau.gradle.japicmp.JapicmpTask, dependsOn: 'jar') {
   oldClasspath = files(baselineJar(project, baselineVersion))
   newClasspath = files(jar.archivePath)
diff --git a/okhttp/src/main/java/okhttp3/Cache.kt b/okhttp/src/main/java/okhttp3/Cache.kt
index b84bb141e1..380c04a6f1 100644
--- a/okhttp/src/main/java/okhttp3/Cache.kt
+++ b/okhttp/src/main/java/okhttp3/Cache.kt
@@ -21,6 +21,7 @@ import okhttp3.internal.cache.CacheRequest
 import okhttp3.internal.cache.CacheStrategy
 import okhttp3.internal.cache.DiskLruCache
 import okhttp3.internal.closeQuietly
+import okhttp3.internal.concurrent.TaskRunner
 import okhttp3.internal.http.HttpMethod
 import okhttp3.internal.http.StatusLine
 import okhttp3.internal.io.FileSystem
@@ -142,8 +143,14 @@ class Cache internal constructor(
   maxSize: Long,
   fileSystem: FileSystem
 ) : Closeable, Flushable {
-  internal val cache: DiskLruCache =
-      DiskLruCache.create(fileSystem, directory, VERSION, ENTRY_COUNT, maxSize)
+  internal val cache = DiskLruCache(
+      fileSystem = fileSystem,
+      directory = directory,
+      appVersion = VERSION,
+      valueCount = ENTRY_COUNT,
+      maxSize = maxSize,
+      taskRunner = TaskRunner.INSTANCE
+  )
 
   // read and write statistics, all guarded by 'this'.
   internal var writeSuccessCount = 0
diff --git a/okhttp/src/main/java/okhttp3/CertificatePinner.kt b/okhttp/src/main/java/okhttp3/CertificatePinner.kt
index 29e3f9ddaf..db95d81ef3 100644
--- a/okhttp/src/main/java/okhttp3/CertificatePinner.kt
+++ b/okhttp/src/main/java/okhttp3/CertificatePinner.kt
@@ -126,7 +126,7 @@ import javax.net.ssl.SSLPeerUnverifiedException
 @Suppress("NAME_SHADOWING")
 class CertificatePinner internal constructor(
   private val pins: Set<Pin>,
-  private val certificateChainCleaner: CertificateChainCleaner?
+  internal val certificateChainCleaner: CertificateChainCleaner?
 ) {
   /**
    * Confirms that at least one of the certificates pinned for `hostname` is in `peerCertificates`.
@@ -138,17 +138,19 @@ class CertificatePinner internal constructor(
    */
   @Throws(SSLPeerUnverifiedException::class)
   fun check(hostname: String, peerCertificates: List<Certificate>) {
-    var peerCertificates = peerCertificates
+    return check(hostname) {
+      (certificateChainCleaner?.clean(peerCertificates, hostname) ?: peerCertificates)
+          .map { it as X509Certificate }
+    }
+  }
+
+  internal fun check(hostname: String, cleanedPeerCertificatesFn: () -> List<X509Certificate>) {
     val pins = findMatchingPins(hostname)
     if (pins.isEmpty()) return
 
-    if (certificateChainCleaner != null) {
-      peerCertificates = certificateChainCleaner.clean(peerCertificates, hostname)
-    }
+    val peerCertificates = cleanedPeerCertificatesFn()
 
     for (peerCertificate in peerCertificates) {
-      val x509Certificate = peerCertificate as X509Certificate
-
       // Lazily compute the hashes for each certificate.
       var sha1: ByteString? = null
       var sha256: ByteString? = null
@@ -156,11 +158,11 @@ class CertificatePinner internal constructor(
       for (pin in pins) {
         when (pin.hashAlgorithm) {
           "sha256/" -> {
-            if (sha256 == null) sha256 = x509Certificate.toSha256ByteString()
+            if (sha256 == null) sha256 = peerCertificate.toSha256ByteString()
             if (pin.hash == sha256) return // Success!
           }
           "sha1/" -> {
-            if (sha1 == null) sha1 = x509Certificate.toSha1ByteString()
+            if (sha1 == null) sha1 = peerCertificate.toSha1ByteString()
             if (pin.hash == sha1) return // Success!
           }
           else -> throw AssertionError("unsupported hashAlgorithm: ${pin.hashAlgorithm}")
@@ -172,8 +174,8 @@ class CertificatePinner internal constructor(
     val message = buildString {
       append("Certificate pinning failure!")
       append("\n  Peer certificate chain:")
-      for (c in 0 until peerCertificates.size) {
-        val x509Certificate = peerCertificates[c] as X509Certificate
+      for (element in peerCertificates) {
+        val x509Certificate = element as X509Certificate
         append("\n    ")
         append(pin(x509Certificate))
         append(": ")
@@ -195,7 +197,7 @@ class CertificatePinner internal constructor(
       ReplaceWith("check(hostname, peerCertificates.toList())")
   )
   @Throws(SSLPeerUnverifiedException::class)
-  inline fun check(hostname: String, vararg peerCertificates: Certificate) {
+  fun check(hostname: String, vararg peerCertificates: Certificate) {
     check(hostname, peerCertificates.toList())
   }
 
diff --git a/okhttp/src/main/java/okhttp3/ConnectionPool.kt b/okhttp/src/main/java/okhttp3/ConnectionPool.kt
index 3bdc491397..4dbcb9514d 100644
--- a/okhttp/src/main/java/okhttp3/ConnectionPool.kt
+++ b/okhttp/src/main/java/okhttp3/ConnectionPool.kt
@@ -16,6 +16,7 @@
  */
 package okhttp3
 
+import okhttp3.internal.concurrent.TaskRunner
 import okhttp3.internal.connection.RealConnectionPool
 import java.util.concurrent.TimeUnit
 
@@ -29,12 +30,19 @@ import java.util.concurrent.TimeUnit
  * Currently this pool holds up to 5 idle connections which will be evicted after 5 minutes of
  * inactivity.
  */
-class ConnectionPool(
-  maxIdleConnections: Int,
-  keepAliveDuration: Long,
-  timeUnit: TimeUnit
+class ConnectionPool internal constructor(
+  internal val delegate: RealConnectionPool
 ) {
-  internal val delegate = RealConnectionPool(maxIdleConnections, keepAliveDuration, timeUnit)
+  constructor(
+    maxIdleConnections: Int,
+    keepAliveDuration: Long,
+    timeUnit: TimeUnit
+  ) : this(RealConnectionPool(
+      taskRunner = TaskRunner.INSTANCE,
+      maxIdleConnections = maxIdleConnections,
+      keepAliveDuration = keepAliveDuration,
+      timeUnit = timeUnit
+  ))
 
   constructor() : this(5, 5, TimeUnit.MINUTES)
 
diff --git a/okhttp/src/main/java/okhttp3/Cookie.kt b/okhttp/src/main/java/okhttp3/Cookie.kt
index 3a16bb64f9..d56aa593a1 100644
--- a/okhttp/src/main/java/okhttp3/Cookie.kt
+++ b/okhttp/src/main/java/okhttp3/Cookie.kt
@@ -501,19 +501,19 @@ class Cookie private constructor(
 
         when {
           hour == -1 && matcher.usePattern(TIME_PATTERN).matches() -> {
-            hour = Integer.parseInt(matcher.group(1))
-            minute = Integer.parseInt(matcher.group(2))
-            second = Integer.parseInt(matcher.group(3))
+            hour = matcher.group(1).toInt()
+            minute = matcher.group(2).toInt()
+            second = matcher.group(3).toInt()
           }
           dayOfMonth == -1 && matcher.usePattern(DAY_OF_MONTH_PATTERN).matches() -> {
-            dayOfMonth = Integer.parseInt(matcher.group(1))
+            dayOfMonth = matcher.group(1).toInt()
           }
           month == -1 && matcher.usePattern(MONTH_PATTERN).matches() -> {
             val monthString = matcher.group(1).toLowerCase(Locale.US)
             month = MONTH_PATTERN.pattern().indexOf(monthString) / 4 // Sneaky! jan=1, dec=12.
           }
           year == -1 && matcher.usePattern(YEAR_PATTERN).matches() -> {
-            year = Integer.parseInt(matcher.group(1))
+            year = matcher.group(1).toInt()
           }
         }
 
diff --git a/okhttp/src/main/java/okhttp3/Handshake.kt b/okhttp/src/main/java/okhttp3/Handshake.kt
index ffe41afd2e..2f45057421 100644
--- a/okhttp/src/main/java/okhttp3/Handshake.kt
+++ b/okhttp/src/main/java/okhttp3/Handshake.kt
@@ -15,8 +15,8 @@
  */
 package okhttp3
 
-import okhttp3.internal.toImmutableList
 import okhttp3.internal.immutableListOf
+import okhttp3.internal.toImmutableList
 import java.io.IOException
 import java.security.Principal
 import java.security.cert.Certificate
@@ -31,7 +31,7 @@ import javax.net.ssl.SSLSession
  * This value object describes a completed handshake. Use [ConnectionSpec] to set policy for new
  * handshakes.
  */
-class Handshake private constructor(
+class Handshake internal constructor(
   /**
    * Returns the TLS version used for this connection. This value wasn't tracked prior to OkHttp
    * 3.0. For responses cached by preceding versions this returns [TlsVersion.SSL_3_0].
@@ -41,12 +41,15 @@ class Handshake private constructor(
   /** Returns the cipher suite used for the connection. */
   @get:JvmName("cipherSuite") val cipherSuite: CipherSuite,
 
-  /** Returns a possibly-empty list of certificates that identify the remote peer. */
-  @get:JvmName("peerCertificates") val peerCertificates: List<Certificate>,
-
   /** Returns a possibly-empty list of certificates that identify this peer. */
-  @get:JvmName("localCertificates") val localCertificates: List<Certificate>
+  @get:JvmName("localCertificates") val localCertificates: List<Certificate>,
+
+  // Delayed provider of peerCertificates, to allow lazy cleaning.
+  peerCertificatesFn: () -> List<Certificate>
 ) {
+  /** Returns a possibly-empty list of certificates that identify the remote peer. */
+  @get:JvmName("peerCertificates") val peerCertificates: List<Certificate> by lazy(
+      peerCertificatesFn)
 
   @JvmName("-deprecated_tlsVersion")
   @Deprecated(
@@ -137,35 +140,33 @@ class Handshake private constructor(
     @JvmName("get")
     fun SSLSession.handshake(): Handshake {
       val cipherSuiteString = checkNotNull(cipherSuite) { "cipherSuite == null" }
-      if ("SSL_NULL_WITH_NULL_NULL" == cipherSuiteString) {
-        throw IOException("cipherSuite == SSL_NULL_WITH_NULL_NULL")
+      val cipherSuite = when (cipherSuiteString) {
+        "TLS_NULL_WITH_NULL_NULL", "SSL_NULL_WITH_NULL_NULL" -> {
+          throw IOException("cipherSuite == $cipherSuiteString")
+        }
+        else -> CipherSuite.forJavaName(cipherSuiteString)
       }
-      val cipherSuite = CipherSuite.forJavaName(cipherSuiteString)
 
       val tlsVersionString = checkNotNull(protocol) { "tlsVersion == null" }
       if ("NONE" == tlsVersionString) throw IOException("tlsVersion == NONE")
       val tlsVersion = TlsVersion.forJavaName(tlsVersionString)
 
-      val peerCertificates: Array<Certificate>? = try {
-        peerCertificates
+      val peerCertificatesCopy = try {
+        peerCertificates.toImmutableList()
       } catch (_: SSLPeerUnverifiedException) {
-        null
+        listOf<Certificate>()
       }
 
-      val peerCertificatesList = if (peerCertificates != null) {
-        immutableListOf(*peerCertificates)
-      } else {
-        emptyList()
-      }
+      return Handshake(tlsVersion, cipherSuite,
+          localCertificates.toImmutableList()) { peerCertificatesCopy }
+    }
 
-      val localCertificates = localCertificates
-      val localCertificatesList = if (localCertificates != null) {
-        immutableListOf(*localCertificates)
+    private fun Array<out Certificate>?.toImmutableList(): List<Certificate> {
+      return if (this != null) {
+        immutableListOf(*this)
       } else {
         emptyList()
       }
-
-      return Handshake(tlsVersion, cipherSuite, peerCertificatesList, localCertificatesList)
     }
 
     @Throws(IOException::class)
@@ -183,8 +184,10 @@ class Handshake private constructor(
       peerCertificates: List<Certificate>,
       localCertificates: List<Certificate>
     ): Handshake {
-      return Handshake(tlsVersion, cipherSuite, peerCertificates.toImmutableList(),
-          localCertificates.toImmutableList())
+      val peerCertificatesCopy = peerCertificates.toImmutableList()
+      return Handshake(tlsVersion, cipherSuite, localCertificates.toImmutableList()) {
+        peerCertificatesCopy
+      }
     }
   }
-}
\ No newline at end of file
+}
diff --git a/okhttp/src/main/java/okhttp3/HttpUrl.kt b/okhttp/src/main/java/okhttp3/HttpUrl.kt
index b415928d83..1e905dc91a 100644
--- a/okhttp/src/main/java/okhttp3/HttpUrl.kt
+++ b/okhttp/src/main/java/okhttp3/HttpUrl.kt
@@ -1540,7 +1540,7 @@ class HttpUrl internal constructor(
         return try {
           // Canonicalize the port string to skip '\n' etc.
           val portString = input.canonicalize(pos = pos, limit = limit, encodeSet = "")
-          val i = Integer.parseInt(portString)
+          val i = portString.toInt()
           if (i in 1..65535) i else -1
         } catch (_: NumberFormatException) {
           -1 // Invalid port.
diff --git a/okhttp/src/main/java/okhttp3/OkHttpClient.kt b/okhttp/src/main/java/okhttp3/OkHttpClient.kt
index 009f303cf9..b7056985b1 100644
--- a/okhttp/src/main/java/okhttp3/OkHttpClient.kt
+++ b/okhttp/src/main/java/okhttp3/OkHttpClient.kt
@@ -19,6 +19,7 @@ import okhttp3.Protocol.HTTP_1_1
 import okhttp3.Protocol.HTTP_2
 import okhttp3.internal.asFactory
 import okhttp3.internal.checkDuration
+import okhttp3.internal.concurrent.TaskRunner
 import okhttp3.internal.immutableListOf
 import okhttp3.internal.platform.Platform
 import okhttp3.internal.proxy.NullProxySelector
@@ -162,9 +163,9 @@ open class OkHttpClient internal constructor(
 
   @get:JvmName("proxySelector") val proxySelector: ProxySelector =
       when {
-        // Avoid possible SecurityException from ProxySelector.getDefault
-        builder.proxy != null -> NullProxySelector()
-        else -> builder.proxySelector ?: ProxySelector.getDefault() ?: NullProxySelector()
+        // Defer calls to ProxySelector.getDefault() because it can throw a SecurityException.
+        builder.proxy != null -> NullProxySelector
+        else -> builder.proxySelector ?: ProxySelector.getDefault() ?: NullProxySelector
       }
 
   @get:JvmName("proxyAuthenticator") val proxyAuthenticator: Authenticator =
@@ -244,7 +245,13 @@ open class OkHttpClient internal constructor(
 
   /** Uses [request] to connect a new web socket. */
   override fun newWebSocket(request: Request, listener: WebSocketListener): WebSocket {
-    val webSocket = RealWebSocket(request, listener, Random(), pingIntervalMillis.toLong())
+    val webSocket = RealWebSocket(
+        TaskRunner.INSTANCE,
+        request,
+        listener,
+        Random(),
+        pingIntervalMillis.toLong()
+    )
     webSocket.connect(this)
     return webSocket
   }
diff --git a/okhttp/src/main/java/okhttp3/RealCall.kt b/okhttp/src/main/java/okhttp3/RealCall.kt
index 34057964b2..0442d6798b 100644
--- a/okhttp/src/main/java/okhttp3/RealCall.kt
+++ b/okhttp/src/main/java/okhttp3/RealCall.kt
@@ -139,10 +139,18 @@ internal class RealCall private constructor(
         } catch (e: IOException) {
           if (signalledCallback) {
             // Do not signal the callback twice!
-            Platform.get().log(INFO, "Callback failure for ${toLoggableString()}", e)
+            Platform.get().log("Callback failure for ${toLoggableString()}", INFO, e)
           } else {
             responseCallback.onFailure(this@RealCall, e)
           }
+        } catch (t: Throwable) {
+          cancel()
+          if (!signalledCallback) {
+            val canceledException = IOException("canceled due to $t")
+            canceledException.addSuppressed(t)
+            responseCallback.onFailure(this@RealCall, canceledException)
+          }
+          throw t
         } finally {
           client.dispatcher.finished(this)
         }
diff --git a/okhttp/src/main/java/okhttp3/internal/Util.kt b/okhttp/src/main/java/okhttp3/internal/Util.kt
index d40f16c4d6..89b548d891 100644
--- a/okhttp/src/main/java/okhttp3/internal/Util.kt
+++ b/okhttp/src/main/java/okhttp3/internal/Util.kt
@@ -48,8 +48,6 @@ import java.util.Comparator
 import java.util.LinkedHashMap
 import java.util.Locale
 import java.util.TimeZone
-import java.util.concurrent.Executor
-import java.util.concurrent.RejectedExecutionException
 import java.util.concurrent.ThreadFactory
 import java.util.concurrent.TimeUnit
 import kotlin.text.Charsets.UTF_32BE
@@ -360,7 +358,7 @@ fun Source.discard(timeout: Int, timeUnit: TimeUnit): Boolean = try {
   false
 }
 
-fun Socket.connectionName(): String {
+fun Socket.peerName(): String {
   val address = remoteSocketAddress
   return if (address is InetSocketAddress) address.hostName else address.toString()
 }
@@ -384,23 +382,6 @@ inline fun threadName(name: String, block: () -> Unit) {
   }
 }
 
-/** Execute [block], setting the executing thread's name to [name] for the duration. */
-inline fun Executor.execute(name: String, crossinline block: () -> Unit) {
-  execute {
-    threadName(name) {
-      block()
-    }
-  }
-}
-
-/** Executes [block] unless this executor has been shutdown, in which case this does nothing. */
-inline fun Executor.tryExecute(name: String, crossinline block: () -> Unit) {
-  try {
-    execute(name, block)
-  } catch (_: RejectedExecutionException) {
-  }
-}
-
 fun Buffer.skipAll(b: Byte): Int {
   var count = 0
   while (!exhausted() && this[0] == b) {
@@ -510,33 +491,9 @@ fun Long.toHexString(): String = java.lang.Long.toHexString(this)
 
 fun Int.toHexString(): String = Integer.toHexString(this)
 
-/**
- * Lock and wait a duration in nanoseconds. Unlike [java.lang.Object.wait] this interprets 0 as
- * "don't wait" instead of "wait forever".
- */
-@Throws(InterruptedException::class)
-fun Any.lockAndWaitNanos(nanos: Long) {
-  val ms = nanos / 1_000_000L
-  val ns = nanos - (ms * 1_000_000L)
-  synchronized(this) {
-    waitMillis(ms, ns.toInt())
-  }
-}
-
 @Suppress("PLATFORM_CLASS_MAPPED_TO_KOTLIN", "NOTHING_TO_INLINE")
 inline fun Any.wait() = (this as Object).wait()
 
-/**
- * Lock and wait a duration in milliseconds and nanos.
- * Unlike [java.lang.Object.wait] this interprets 0 as "don't wait" instead of "wait forever".
- */
-@Suppress("PLATFORM_CLASS_MAPPED_TO_KOTLIN")
-fun Any.waitMillis(timeout: Long, nanos: Int = 0) {
-  if (timeout > 0L || nanos > 0) {
-    (this as Object).wait(timeout, nanos)
-  }
-}
-
 @Suppress("PLATFORM_CLASS_MAPPED_TO_KOTLIN", "NOTHING_TO_INLINE")
 inline fun Any.notify() = (this as Object).notify()
 
@@ -566,3 +523,7 @@ fun <T> readFieldOrNull(instance: Any, fieldType: Class<T>, fieldName: String):
 
   return null
 }
+
+internal fun <E> MutableList<E>.addIfAbsent(element: E) {
+  if (!contains(element)) add(element)
+}
diff --git a/okhttp/src/main/java/okhttp3/internal/cache/DiskLruCache.kt b/okhttp/src/main/java/okhttp3/internal/cache/DiskLruCache.kt
index b9d028b094..477b0cfa78 100644
--- a/okhttp/src/main/java/okhttp3/internal/cache/DiskLruCache.kt
+++ b/okhttp/src/main/java/okhttp3/internal/cache/DiskLruCache.kt
@@ -17,10 +17,11 @@ package okhttp3.internal.cache
 
 import okhttp3.internal.cache.DiskLruCache.Editor
 import okhttp3.internal.closeQuietly
+import okhttp3.internal.concurrent.Task
+import okhttp3.internal.concurrent.TaskRunner
 import okhttp3.internal.io.FileSystem
 import okhttp3.internal.platform.Platform
 import okhttp3.internal.platform.Platform.Companion.WARN
-import okhttp3.internal.threadFactory
 import okio.BufferedSink
 import okio.Sink
 import okio.Source
@@ -35,10 +36,6 @@ import java.io.IOException
 import java.util.ArrayList
 import java.util.LinkedHashMap
 import java.util.NoSuchElementException
-import java.util.concurrent.Executor
-import java.util.concurrent.LinkedBlockingQueue
-import java.util.concurrent.ThreadPoolExecutor
-import java.util.concurrent.TimeUnit
 
 /**
  * A cache that uses a bounded amount of space on a filesystem. Each cache entry has a string key
@@ -76,6 +73,12 @@ import java.util.concurrent.TimeUnit
  * corresponding entries will be dropped from the cache. If an error occurs while writing a cache
  * value, the edit will fail silently. Callers should handle other problems by catching
  * `IOException` and responding appropriately.
+ *
+ * @constructor Create a cache which will reside in [directory]. This cache is lazily initialized on
+ *     first access and will be created if it does not exist.
+ * @param directory a writable directory.
+ * @param valueCount the number of values per cache entry. Must be positive.
+ * @param maxSize the maximum number of bytes this cache should use to store.
  */
 class DiskLruCache internal constructor(
   internal val fileSystem: FileSystem,
@@ -90,16 +93,15 @@ class DiskLruCache internal constructor(
   /** Returns the maximum number of bytes that this cache should use to store its data. */
   maxSize: Long,
 
-  /** Used to run 'cleanupRunnable' for journal rebuilds. */
-  private val executor: Executor
-
+  /** Used for asynchronous journal rebuilds. */
+  taskRunner: TaskRunner
 ) : Closeable, Flushable {
   /** The maximum number of bytes that this cache should use to store its data. */
   @get:Synchronized @set:Synchronized var maxSize: Long = maxSize
     set(value) {
       field = value
       if (initialized) {
-        executor.execute(cleanupRunnable) // Trim the existing store if necessary.
+        cleanupQueue.schedule(cleanupTask) // Trim the existing store if necessary.
       }
     }
 
@@ -165,31 +167,39 @@ class DiskLruCache internal constructor(
    */
   private var nextSequenceNumber: Long = 0
 
-  private val cleanupRunnable = Runnable {
-    synchronized(this@DiskLruCache) {
-      if (!initialized || closed) {
-        return@Runnable // Nothing to do
-      }
+  private val cleanupQueue = taskRunner.newQueue()
+  private val cleanupTask = object : Task("OkHttp Cache") {
+    override fun runOnce(): Long {
+      synchronized(this@DiskLruCache) {
+        if (!initialized || closed) {
+          return -1L // Nothing to do.
+        }
 
-      try {
-        trimToSize()
-      } catch (_: IOException) {
-        mostRecentTrimFailed = true
-      }
+        try {
+          trimToSize()
+        } catch (_: IOException) {
+          mostRecentTrimFailed = true
+        }
 
-      try {
-        if (journalRebuildRequired()) {
-          rebuildJournal()
-          redundantOpCount = 0
+        try {
+          if (journalRebuildRequired()) {
+            rebuildJournal()
+            redundantOpCount = 0
+          }
+        } catch (_: IOException) {
+          mostRecentRebuildFailed = true
+          journalWriter = blackholeSink().buffer()
         }
-      } catch (_: IOException) {
-        mostRecentRebuildFailed = true
-        journalWriter = blackholeSink().buffer()
+
+        return -1L
       }
     }
   }
 
   init {
+    require(maxSize > 0L) { "maxSize <= 0" }
+    require(valueCount > 0) { "valueCount <= 0" }
+
     this.journalFile = File(directory, JOURNAL_FILE)
     this.journalFileTmp = File(directory, JOURNAL_FILE_TEMP)
     this.journalFileBackup = File(directory, JOURNAL_FILE_BACKUP)
@@ -221,8 +231,9 @@ class DiskLruCache internal constructor(
         initialized = true
         return
       } catch (journalIsCorrupt: IOException) {
-        Platform.get().log(WARN,
+        Platform.get().log(
             "DiskLruCache $directory is corrupt: ${journalIsCorrupt.message}, removing",
+            WARN,
             journalIsCorrupt)
       }
 
@@ -419,7 +430,7 @@ class DiskLruCache internal constructor(
         .writeUtf8(key)
         .writeByte('\n'.toInt())
     if (journalRebuildRequired()) {
-      executor.execute(cleanupRunnable)
+      cleanupQueue.schedule(cleanupTask)
     }
 
     return snapshot
@@ -449,7 +460,7 @@ class DiskLruCache internal constructor(
       // the journal rebuild failed, the journal writer will not be active, meaning we will not be
       // able to record the edit, causing file leaks. In both cases, we want to retry the clean up
       // so we can get out of this state!
-      executor.execute(cleanupRunnable)
+      cleanupQueue.schedule(cleanupTask)
       return null
     }
 
@@ -541,7 +552,7 @@ class DiskLruCache internal constructor(
     }
 
     if (size > maxSize || journalRebuildRequired()) {
-      executor.execute(cleanupRunnable)
+      cleanupQueue.schedule(cleanupTask)
     }
   }
 
@@ -591,7 +602,7 @@ class DiskLruCache internal constructor(
     lruEntries.remove(entry.key)
 
     if (journalRebuildRequired()) {
-      executor.execute(cleanupRunnable)
+      cleanupQueue.schedule(cleanupTask)
     }
 
     return true
@@ -974,30 +985,5 @@ class DiskLruCache internal constructor(
     @JvmField val DIRTY = "DIRTY"
     @JvmField val REMOVE = "REMOVE"
     @JvmField val READ = "READ"
-
-    /**
-     * Create a cache which will reside in [directory]. This cache is lazily initialized on first
-     * access and will be created if it does not exist.
-     *
-     * @param directory a writable directory
-     * @param valueCount the number of values per cache entry. Must be positive.
-     * @param maxSize the maximum number of bytes this cache should use to store
-     */
-    fun create(
-      fileSystem: FileSystem,
-      directory: File,
-      appVersion: Int,
-      valueCount: Int,
-      maxSize: Long
-    ): DiskLruCache {
-      require(maxSize > 0L) { "maxSize <= 0" }
-      require(valueCount > 0) { "valueCount <= 0" }
-
-      // Use a single background thread to evict entries.
-      val executor = ThreadPoolExecutor(0, 1, 60L, TimeUnit.SECONDS,
-          LinkedBlockingQueue(), threadFactory("OkHttp DiskLruCache", true))
-
-      return DiskLruCache(fileSystem, directory, appVersion, valueCount, maxSize, executor)
-    }
   }
 }
diff --git a/okhttp/src/main/java/okhttp3/internal/concurrent/Task.kt b/okhttp/src/main/java/okhttp3/internal/concurrent/Task.kt
new file mode 100644
index 0000000000..61cef201a4
--- /dev/null
+++ b/okhttp/src/main/java/okhttp3/internal/concurrent/Task.kt
@@ -0,0 +1,70 @@
+/*
+ * Copyright (C) 2019 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.internal.concurrent
+
+/**
+ * A unit of work that can be executed one or more times.
+ *
+ * Recurrence
+ * ----------
+ *
+ * Tasks control their recurrence schedule. The [runOnce] function returns -1L to signify that the
+ * task should not be executed again. Otherwise it returns a delay until the next execution.
+ *
+ * A task has at most one next execution. If the same task instance is scheduled multiple times, the
+ * earliest one wins. This applies to both executions scheduled with [TaskRunner.Queue.schedule] and
+ * those implied by the returned execution delay.
+ *
+ * Cancellation
+ * ------------
+ *
+ * Tasks may be canceled while they are waiting to be executed, or while they are executing.
+ *
+ * Canceling a task that is waiting to execute prevents that upcoming execution. Canceling a task
+ * that is currently executing does not impact the ongoing run, but it does prevent a recurrence
+ * from being scheduled.
+ *
+ * Tasks may opt-out of cancellation with `cancelable = false`. Such tasks will recur until they
+ * decide not to by returning -1L.
+ *
+ * Task Queues
+ * -----------
+ *
+ * Tasks are bound to the [TaskQueue] they are scheduled in. Each queue is sequential and the tasks
+ * within it never execute concurrently. It is an error to use a task in multiple queues.
+ */
+abstract class Task(
+  val name: String,
+  val cancelable: Boolean = true
+) {
+  // Guarded by the TaskRunner.
+  internal var queue: TaskQueue? = null
+
+  /** Undefined unless this is in [TaskQueue.futureTasks]. */
+  internal var nextExecuteNanoTime = -1L
+
+  /** Returns the delay in nanoseconds until the next execution, or -1L to not reschedule. */
+  abstract fun runOnce(): Long
+
+  internal fun initQueue(queue: TaskQueue) {
+    if (this.queue === queue) return
+
+    check(this.queue === null) { "task is in multiple queues" }
+    this.queue = queue
+  }
+
+  override fun toString() = name
+}
diff --git a/okhttp/src/main/java/okhttp3/internal/concurrent/TaskQueue.kt b/okhttp/src/main/java/okhttp3/internal/concurrent/TaskQueue.kt
new file mode 100644
index 0000000000..13ed3c802f
--- /dev/null
+++ b/okhttp/src/main/java/okhttp3/internal/concurrent/TaskQueue.kt
@@ -0,0 +1,184 @@
+/*
+ * Copyright (C) 2019 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.internal.concurrent
+
+import java.util.concurrent.CountDownLatch
+import java.util.concurrent.RejectedExecutionException
+import java.util.concurrent.TimeUnit
+
+/**
+ * A set of tasks that are executed in sequential order.
+ *
+ * Work within queues is not concurrent. This is equivalent to each queue having a dedicated thread
+ * for its work; in practice a set of queues may share a set of threads to save resources.
+ */
+class TaskQueue internal constructor(
+  private val taskRunner: TaskRunner
+) {
+  internal var shutdown = false
+
+  /** This queue's currently-executing task, or null if none is currently executing. */
+  internal var activeTask: Task? = null
+
+  /** Scheduled tasks ordered by [Task.nextExecuteNanoTime]. */
+  internal val futureTasks = mutableListOf<Task>()
+
+  /** True if the [activeTask] should be canceled when it completes. */
+  internal var cancelActiveTask = false
+
+  /**
+   * Returns a snapshot of tasks currently scheduled for execution. Does not include the
+   * currently-executing task unless it is also scheduled for future execution.
+   */
+  val scheduledTasks: List<Task>
+    get() = synchronized(taskRunner) { futureTasks.toList() }
+
+  /**
+   * Schedules [task] for execution in [delayNanos]. A task may only have one future execution
+   * scheduled. If the task is already in the queue, the earliest execution time is used.
+   *
+   * The target execution time is implemented on a best-effort basis. If another task in this queue
+   * is running when that time is reached, that task is allowed to complete before this task is
+   * started. Similarly the task will be delayed if the host lacks compute resources.
+   *
+   * @throws RejectedExecutionException if the queue is shut down and the task is not cancelable.
+   */
+  fun schedule(task: Task, delayNanos: Long = 0L) {
+    synchronized(taskRunner) {
+      if (shutdown) {
+        if (task.cancelable) return
+        throw RejectedExecutionException()
+      }
+
+      if (scheduleAndDecide(task, delayNanos)) {
+        taskRunner.kickCoordinator(this)
+      }
+    }
+  }
+
+  /** Overload of [schedule] that uses a lambda for a repeating task. */
+  inline fun schedule(
+    name: String,
+    delayNanos: Long = 0L,
+    crossinline block: () -> Long
+  ) {
+    schedule(object : Task(name) {
+      override fun runOnce() = block()
+    }, delayNanos)
+  }
+
+  /** Executes [block] once on a task runner thread. */
+  inline fun execute(
+    name: String,
+    delayNanos: Long = 0L,
+    cancelable: Boolean = true,
+    crossinline block: () -> Unit
+  ) {
+    schedule(object : Task(name, cancelable) {
+      override fun runOnce(): Long {
+        block()
+        return -1L
+      }
+    }, delayNanos)
+  }
+
+  /** Returns true if this queue became idle before the timeout elapsed. */
+  fun awaitIdle(delayNanos: Long): Boolean {
+    val latch = CountDownLatch(1)
+
+    val task = object : Task("OkHttp awaitIdle", cancelable = false) {
+      override fun runOnce(): Long {
+        latch.countDown()
+        return -1L
+      }
+    }
+
+    // Don't delegate to schedule because that has to honor shutdown rules.
+    synchronized(taskRunner) {
+      if (scheduleAndDecide(task, 0L)) {
+        taskRunner.kickCoordinator(this)
+      }
+    }
+
+    return latch.await(delayNanos, TimeUnit.NANOSECONDS)
+  }
+
+  /** Adds [task] to run in [delayNanos]. Returns true if the coordinator is impacted. */
+  internal fun scheduleAndDecide(task: Task, delayNanos: Long): Boolean {
+    task.initQueue(this)
+
+    val now = taskRunner.backend.nanoTime()
+    val executeNanoTime = now + delayNanos
+
+    // If the task is already scheduled, take the earlier of the two times.
+    val existingIndex = futureTasks.indexOf(task)
+    if (existingIndex != -1) {
+      if (task.nextExecuteNanoTime <= executeNanoTime) return false // Already scheduled earlier.
+      futureTasks.removeAt(existingIndex) // Already scheduled later: reschedule below!
+    }
+    task.nextExecuteNanoTime = executeNanoTime
+
+    // Insert in chronological order. Always compare deltas because nanoTime() is permitted to wrap.
+    var insertAt = futureTasks.indexOfFirst { it.nextExecuteNanoTime - now > delayNanos }
+    if (insertAt == -1) insertAt = futureTasks.size
+    futureTasks.add(insertAt, task)
+
+    // Impact the coordinator if we inserted at the front.
+    return insertAt == 0
+  }
+
+  /**
+   * Schedules immediate execution of [Task.tryCancel] on all currently-enqueued tasks. These calls
+   * will not be made until any currently-executing task has completed. Tasks that return true will
+   * be removed from the execution schedule.
+   */
+  fun cancelAll() {
+    check(!Thread.holdsLock(this))
+
+    synchronized(taskRunner) {
+      if (cancelAllAndDecide()) {
+        taskRunner.kickCoordinator(this)
+      }
+    }
+  }
+
+  fun shutdown() {
+    check(!Thread.holdsLock(this))
+
+    synchronized(taskRunner) {
+      shutdown = true
+      if (cancelAllAndDecide()) {
+        taskRunner.kickCoordinator(this)
+      }
+    }
+  }
+
+  /** Returns true if the coordinator is impacted. */
+  internal fun cancelAllAndDecide(): Boolean {
+    if (activeTask != null && activeTask!!.cancelable) {
+      cancelActiveTask = true
+    }
+
+    var tasksCanceled = false
+    for (i in futureTasks.size - 1 downTo 0) {
+      if (futureTasks[i].cancelable) {
+        tasksCanceled = true
+        futureTasks.removeAt(i)
+      }
+    }
+    return tasksCanceled
+  }
+}
diff --git a/okhttp/src/main/java/okhttp3/internal/concurrent/TaskRunner.kt b/okhttp/src/main/java/okhttp3/internal/concurrent/TaskRunner.kt
new file mode 100644
index 0000000000..f5571fb484
--- /dev/null
+++ b/okhttp/src/main/java/okhttp3/internal/concurrent/TaskRunner.kt
@@ -0,0 +1,292 @@
+/*
+ * Copyright (C) 2019 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.internal.concurrent
+
+import okhttp3.internal.addIfAbsent
+import okhttp3.internal.notify
+import okhttp3.internal.threadFactory
+import java.util.concurrent.SynchronousQueue
+import java.util.concurrent.ThreadFactory
+import java.util.concurrent.ThreadPoolExecutor
+import java.util.concurrent.TimeUnit
+
+/**
+ * A set of worker threads that are shared among a set of task queues.
+ *
+ * The task runner is responsible for managing non-daemon threads. It keeps the process alive while
+ * user-visible (ie. non-daemon) tasks are scheduled, and allows the process to exit when only
+ * housekeeping (ie. daemon) tasks are scheduled.
+ *
+ * The task runner is also responsible for releasing held threads when the library is unloaded.
+ * This is for the benefit of container environments that implement code unloading.
+ *
+ * Most applications should share a process-wide [TaskRunner] and use queues for per-client work.
+ */
+class TaskRunner(
+  val backend: Backend
+) {
+  private var coordinatorWaiting = false
+  private var coordinatorWakeUpAt = 0L
+
+  /** Queues with tasks that are currently executing their [TaskQueue.activeTask]. */
+  private val busyQueues = mutableListOf<TaskQueue>()
+
+  /** Queues not in [busyQueues] that have non-empty [TaskQueue.futureTasks]. */
+  private val readyQueues = mutableListOf<TaskQueue>()
+
+  private val runnable: Runnable = object : Runnable {
+    override fun run() {
+      while (true) {
+        val task = synchronized(this@TaskRunner) {
+          awaitTaskToRun()
+        } ?: return
+
+        runTask(task)
+      }
+    }
+  }
+
+  internal fun kickCoordinator(taskQueue: TaskQueue) {
+    check(Thread.holdsLock(this))
+
+    if (taskQueue.activeTask == null) {
+      if (taskQueue.futureTasks.isNotEmpty()) {
+        readyQueues.addIfAbsent(taskQueue)
+      } else {
+        readyQueues.remove(taskQueue)
+      }
+    }
+
+    if (coordinatorWaiting) {
+      backend.coordinatorNotify(this@TaskRunner)
+    } else {
+      backend.execute(runnable)
+    }
+  }
+
+  private fun beforeRun(task: Task) {
+    check(Thread.holdsLock(this))
+
+    task.nextExecuteNanoTime = -1L
+    val queue = task.queue!!
+    queue.futureTasks.remove(task)
+    readyQueues.remove(queue)
+    queue.activeTask = task
+    busyQueues.add(queue)
+  }
+
+  private fun runTask(task: Task) {
+    check(!Thread.holdsLock(this))
+
+    val currentThread = Thread.currentThread()
+    val oldName = currentThread.name
+    currentThread.name = task.name
+
+    var delayNanos = -1L
+    try {
+      delayNanos = task.runOnce()
+    } finally {
+      synchronized(this) {
+        afterRun(task, delayNanos)
+      }
+      currentThread.name = oldName
+    }
+  }
+
+  private fun afterRun(task: Task, delayNanos: Long) {
+    check(Thread.holdsLock(this))
+
+    val queue = task.queue!!
+    check(queue.activeTask === task)
+
+    val cancelActiveTask = queue.cancelActiveTask
+    queue.cancelActiveTask = false
+    queue.activeTask = null
+    busyQueues.remove(queue)
+
+    if (delayNanos != -1L && !cancelActiveTask && !queue.shutdown) {
+      queue.scheduleAndDecide(task, delayNanos)
+    }
+
+    if (queue.futureTasks.isNotEmpty()) {
+      readyQueues.add(queue)
+    }
+  }
+
+  /**
+   * Returns an immediately-executable task for the calling thread to execute, sleeping as necessary
+   * until one is ready. If there are no ready queues, or if other threads have everything under
+   * control this will return null. If there is more than a single task ready to execute immediately
+   * this will launch another thread to handle that work.
+   */
+  fun awaitTaskToRun(): Task? {
+    check(Thread.holdsLock(this))
+
+    while (true) {
+      if (readyQueues.isEmpty()) {
+        return null // Nothing to do.
+      }
+
+      val now = backend.nanoTime()
+      var minDelayNanos = Long.MAX_VALUE
+      var readyTask: Task? = null
+      var multipleReadyTasks = false
+
+      // Decide what to run. This loop's goal wants to:
+      //  * Find out what this thread should do (either run a task or sleep)
+      //  * Find out if there's enough work to start another thread.
+      eachQueue@ for (queue in readyQueues) {
+        val candidate = queue.futureTasks[0]
+        val candidateDelay = maxOf(0L, candidate.nextExecuteNanoTime - now)
+
+        when {
+          // Compute the delay of the soonest-executable task.
+          candidateDelay > 0L -> {
+            minDelayNanos = minOf(candidateDelay, minDelayNanos)
+            continue@eachQueue
+          }
+
+          // If we already have more than one task, that's enough work for now. Stop searching.
+          readyTask != null -> {
+            multipleReadyTasks = true
+            break@eachQueue
+          }
+
+          // We have a task to execute when we complete the loop.
+          else -> {
+            readyTask = candidate
+          }
+        }
+      }
+
+      // Implement the decision.
+      when {
+        // We have a task ready to go. Get ready.
+        readyTask != null -> {
+          beforeRun(readyTask)
+
+          // Also start another thread if there's more work or scheduling to do.
+          if (multipleReadyTasks || !coordinatorWaiting && readyQueues.isNotEmpty()) {
+            backend.execute(runnable)
+          }
+
+          return readyTask
+        }
+
+        // Notify the coordinator of a task that's coming up soon.
+        coordinatorWaiting -> {
+          if (minDelayNanos < coordinatorWakeUpAt - now) {
+            backend.coordinatorNotify(this@TaskRunner)
+          }
+          return null
+        }
+
+        // No other thread is coordinating. Become the coordinator!
+        else -> {
+          coordinatorWaiting = true
+          coordinatorWakeUpAt = now + minDelayNanos
+          try {
+            backend.coordinatorWait(this@TaskRunner, minDelayNanos)
+          } catch (_: InterruptedException) {
+            // Will cause all tasks to exit unless more are scheduled!
+            cancelAll()
+          } finally {
+            coordinatorWaiting = false
+          }
+        }
+      }
+    }
+  }
+
+  fun newQueue() = TaskQueue(this)
+
+  /**
+   * Returns a snapshot of queues that currently have tasks scheduled. The task runner does not
+   * necessarily track queues that have no tasks scheduled.
+   */
+  fun activeQueues(): List<TaskQueue> {
+    synchronized(this) {
+      return busyQueues + readyQueues
+    }
+  }
+
+  private fun cancelAll() {
+    for (i in busyQueues.size - 1 downTo 0) {
+      readyQueues[i].cancelAllAndDecide()
+    }
+    for (i in readyQueues.size - 1 downTo 0) {
+      val queue = readyQueues[i]
+      queue.cancelAllAndDecide()
+      if (queue.futureTasks.isEmpty()) {
+        readyQueues.removeAt(i)
+      }
+    }
+  }
+
+  interface Backend {
+    fun beforeTask(taskRunner: TaskRunner)
+    fun nanoTime(): Long
+    fun coordinatorNotify(taskRunner: TaskRunner)
+    fun coordinatorWait(taskRunner: TaskRunner, nanos: Long)
+    fun execute(runnable: Runnable)
+  }
+
+  class RealBackend(threadFactory: ThreadFactory) : Backend {
+    private val executor = ThreadPoolExecutor(
+        0, // corePoolSize.
+        Int.MAX_VALUE, // maximumPoolSize.
+        60L, TimeUnit.SECONDS, // keepAliveTime.
+        SynchronousQueue(),
+        threadFactory
+    )
+
+    override fun beforeTask(taskRunner: TaskRunner) {
+    }
+
+    override fun nanoTime() = System.nanoTime()
+
+    override fun coordinatorNotify(taskRunner: TaskRunner) {
+      taskRunner.notify()
+    }
+
+    /**
+     * Wait a duration in nanoseconds. Unlike [java.lang.Object.wait] this interprets 0 as
+     * "don't wait" instead of "wait forever".
+     */
+    @Throws(InterruptedException::class)
+    @Suppress("PLATFORM_CLASS_MAPPED_TO_KOTLIN")
+    override fun coordinatorWait(taskRunner: TaskRunner, nanos: Long) {
+      val ms = nanos / 1_000_000L
+      val ns = nanos - (ms * 1_000_000L)
+      if (ms > 0L || nanos > 0) {
+        (taskRunner as Object).wait(ms, ns.toInt())
+      }
+    }
+
+    override fun execute(runnable: Runnable) {
+      executor.execute(runnable)
+    }
+
+    fun shutdown() {
+      executor.shutdown()
+    }
+  }
+
+  companion object {
+    @JvmField
+    val INSTANCE = TaskRunner(RealBackend(threadFactory("OkHttp TaskRunner", true)))
+  }
+}
diff --git a/okhttp/src/main/java/okhttp3/internal/connection/RealConnection.kt b/okhttp/src/main/java/okhttp3/internal/connection/RealConnection.kt
index fce137c6b9..acaf3327d0 100644
--- a/okhttp/src/main/java/okhttp3/internal/connection/RealConnection.kt
+++ b/okhttp/src/main/java/okhttp3/internal/connection/RealConnection.kt
@@ -33,7 +33,7 @@ import okhttp3.Response
 import okhttp3.Route
 import okhttp3.internal.EMPTY_RESPONSE
 import okhttp3.internal.closeQuietly
-import okhttp3.internal.toHostHeader
+import okhttp3.internal.concurrent.TaskRunner
 import okhttp3.internal.http.ExchangeCodec
 import okhttp3.internal.http1.Http1ExchangeCodec
 import okhttp3.internal.http2.ConnectionShutdownException
@@ -41,9 +41,11 @@ import okhttp3.internal.http2.ErrorCode
 import okhttp3.internal.http2.Http2Connection
 import okhttp3.internal.http2.Http2ExchangeCodec
 import okhttp3.internal.http2.Http2Stream
+import okhttp3.internal.http2.Settings
 import okhttp3.internal.http2.StreamResetException
 import okhttp3.internal.platform.Platform
 import okhttp3.internal.tls.OkHostnameVerifier
+import okhttp3.internal.toHostHeader
 import okhttp3.internal.userAgent
 import okhttp3.internal.ws.RealWebSocket
 import okio.BufferedSink
@@ -188,6 +190,7 @@ class RealConnection(
         handshake = null
         protocol = null
         http2Connection = null
+        allocationLimit = 1
 
         eventListener.connectFailed(call, route.socketAddress, route.proxy, null, e)
 
@@ -207,13 +210,6 @@ class RealConnection(
       throw RouteException(ProtocolException(
           "Too many tunnel connections attempted: $MAX_TUNNEL_ATTEMPTS"))
     }
-
-    val http2Connection = this.http2Connection
-    if (http2Connection != null) {
-      synchronized(connectionPool) {
-        allocationLimit = http2Connection.maxConcurrentStreams()
-      }
-    }
   }
 
   /**
@@ -321,12 +317,13 @@ class RealConnection(
     val source = this.source!!
     val sink = this.sink!!
     socket.soTimeout = 0 // HTTP/2 connection timeouts are set per-stream.
-    val http2Connection = Http2Connection.Builder(true)
+    val http2Connection = Http2Connection.Builder(client = true, taskRunner = TaskRunner.INSTANCE)
         .socket(socket, route.address.url.host, source, sink)
         .listener(this)
         .pingIntervalMillis(pingIntervalMillis)
         .build()
     this.http2Connection = http2Connection
+    this.allocationLimit = Http2Connection.DEFAULT_SETTINGS.getMaxConcurrentStreams()
     http2Connection.start()
   }
 
@@ -344,7 +341,7 @@ class RealConnection(
       // Configure the socket's ciphers, TLS versions, and extensions.
       val connectionSpec = connectionSpecSelector.configureSecureSocket(sslSocket)
       if (connectionSpec.supportsTlsExtensions) {
-        Platform.get().configureTlsExtensions(sslSocket, address.url.host, address.protocols)
+        Platform.get().configureTlsExtensions(sslSocket, address.protocols)
       }
 
       // Force handshake. This can throw!
@@ -370,9 +367,18 @@ class RealConnection(
         }
       }
 
+      val certificatePinner = address.certificatePinner!!
+
+      handshake = Handshake(unverifiedHandshake.tlsVersion, unverifiedHandshake.cipherSuite,
+          unverifiedHandshake.localCertificates) {
+        certificatePinner.certificateChainCleaner!!.clean(unverifiedHandshake.peerCertificates,
+            address.url.host)
+      }
+
       // Check that the certificate pinner is satisfied by the certificates presented.
-      address.certificatePinner!!.check(address.url.host,
-          unverifiedHandshake.peerCertificates)
+      certificatePinner.check(address.url.host) {
+        handshake!!.peerCertificates.map { it as X509Certificate }
+      }
 
       // Success! Save the handshake and the ALPN protocol.
       val maybeProtocol = if (connectionSpec.supportsTlsExtensions) {
@@ -383,7 +389,6 @@ class RealConnection(
       socket = sslSocket
       source = sslSocket.source().buffer()
       sink = sslSocket.sink().buffer()
-      handshake = unverifiedHandshake
       protocol = if (maybeProtocol != null) Protocol.get(maybeProtocol) else Protocol.HTTP_1_1
       success = true
     } finally {
@@ -636,9 +641,9 @@ class RealConnection(
   }
 
   /** When settings are received, adjust the allocation limit. */
-  override fun onSettings(connection: Http2Connection) {
+  override fun onSettings(connection: Http2Connection, settings: Settings) {
     synchronized(connectionPool) {
-      allocationLimit = connection.maxConcurrentStreams()
+      allocationLimit = settings.getMaxConcurrentStreams()
     }
   }
 
diff --git a/okhttp/src/main/java/okhttp3/internal/connection/RealConnectionPool.kt b/okhttp/src/main/java/okhttp3/internal/connection/RealConnectionPool.kt
index 8dc3c57bce..34bda48ab3 100644
--- a/okhttp/src/main/java/okhttp3/internal/connection/RealConnectionPool.kt
+++ b/okhttp/src/main/java/okhttp3/internal/connection/RealConnectionPool.kt
@@ -20,19 +20,18 @@ import okhttp3.Address
 import okhttp3.ConnectionPool
 import okhttp3.Route
 import okhttp3.internal.closeQuietly
+import okhttp3.internal.concurrent.Task
+import okhttp3.internal.concurrent.TaskQueue
+import okhttp3.internal.concurrent.TaskRunner
 import okhttp3.internal.connection.Transmitter.TransmitterReference
-import okhttp3.internal.lockAndWaitNanos
-import okhttp3.internal.notifyAll
 import okhttp3.internal.platform.Platform
-import okhttp3.internal.threadFactory
 import java.io.IOException
 import java.net.Proxy
 import java.util.ArrayDeque
-import java.util.concurrent.SynchronousQueue
-import java.util.concurrent.ThreadPoolExecutor
 import java.util.concurrent.TimeUnit
 
 class RealConnectionPool(
+  taskRunner: TaskRunner,
   /** The maximum number of idle connections for each address. */
   private val maxIdleConnections: Int,
   keepAliveDuration: Long,
@@ -40,24 +39,13 @@ class RealConnectionPool(
 ) {
   private val keepAliveDurationNs: Long = timeUnit.toNanos(keepAliveDuration)
 
-  private val cleanupRunnable = object : Runnable {
-    override fun run() {
-      while (true) {
-        val waitNanos = cleanup(System.nanoTime())
-        if (waitNanos == -1L) return
-        try {
-          this@RealConnectionPool.lockAndWaitNanos(waitNanos)
-        } catch (ie: InterruptedException) {
-          // Will cause the thread to exit unless other connections are created!
-          evictAll()
-        }
-      }
-    }
+  private val cleanupQueue: TaskQueue = taskRunner.newQueue()
+  private val cleanupTask = object : Task("OkHttp ConnectionPool") {
+    override fun runOnce() = cleanup(System.nanoTime())
   }
 
   private val connections = ArrayDeque<RealConnection>()
   val routeDatabase = RouteDatabase()
-  var cleanupRunning: Boolean = false
 
   init {
     // Put a floor on the keep alive duration, otherwise cleanup will spin loop.
@@ -98,11 +86,8 @@ class RealConnectionPool(
 
   fun put(connection: RealConnection) {
     assert(Thread.holdsLock(this))
-    if (!cleanupRunning) {
-      cleanupRunning = true
-      executor.execute(cleanupRunnable)
-    }
     connections.add(connection)
+    cleanupQueue.schedule(cleanupTask)
   }
 
   /**
@@ -113,10 +98,10 @@ class RealConnectionPool(
     assert(Thread.holdsLock(this))
     return if (connection.noNewExchanges || maxIdleConnections == 0) {
       connections.remove(connection)
+      if (connections.isEmpty()) cleanupQueue.cancelAll()
       true
     } else {
-      // Awake the cleanup thread: we may have exceeded the idle connection limit.
-      this.notifyAll()
+      cleanupQueue.schedule(cleanupTask)
       false
     }
   }
@@ -133,6 +118,7 @@ class RealConnectionPool(
           i.remove()
         }
       }
+      if (connections.isEmpty()) cleanupQueue.cancelAll()
     }
 
     for (connection in evictedConnections) {
@@ -144,8 +130,8 @@ class RealConnectionPool(
    * Performs maintenance on this pool, evicting the connection that has been idle the longest if
    * either it has exceeded the keep alive limit or the idle connections limit.
    *
-   * Returns the duration in nanos to sleep until the next scheduled call to this method. Returns
-   * -1 if no further cleanups are required.
+   * Returns the duration in nanoseconds to sleep until the next scheduled call to this method.
+   * Returns -1 if no further cleanups are required.
    */
   fun cleanup(now: Long): Long {
     var inUseConnectionCount = 0
@@ -178,6 +164,7 @@ class RealConnectionPool(
           // We've found a connection to evict. Remove it from the list, then close it below
           // (outside of the synchronized block).
           connections.remove(longestIdleConnection)
+          if (connections.isEmpty()) cleanupQueue.cancelAll()
         }
         idleConnectionCount > 0 -> {
           // A connection will be ready to evict soon.
@@ -190,7 +177,6 @@ class RealConnectionPool(
         }
         else -> {
           // No connections, idle or in use.
-          cleanupRunning = false
           return -1
         }
       }
@@ -199,7 +185,7 @@ class RealConnectionPool(
     longestIdleConnection!!.socket().closeQuietly()
 
     // Cleanup again immediately.
-    return 0
+    return 0L
   }
 
   /**
@@ -250,19 +236,6 @@ class RealConnectionPool(
   }
 
   companion object {
-    /**
-     * Background threads are used to cleanup expired connections. There will be at most a single
-     * thread running per connection pool. The thread pool executor permits the pool itself to be
-     * garbage collected.
-     */
-    private val executor = ThreadPoolExecutor(
-        0, // corePoolSize.
-        Int.MAX_VALUE, // maximumPoolSize.
-        60L, TimeUnit.SECONDS, // keepAliveTime.
-        SynchronousQueue(),
-        threadFactory("OkHttp ConnectionPool", true)
-    )
-
     fun get(connectionPool: ConnectionPool): RealConnectionPool = connectionPool.delegate
   }
 }
diff --git a/okhttp/src/main/java/okhttp3/internal/connection/Transmitter.kt b/okhttp/src/main/java/okhttp3/internal/connection/Transmitter.kt
index b58ab9cc0c..8c9083ae01 100644
--- a/okhttp/src/main/java/okhttp3/internal/connection/Transmitter.kt
+++ b/okhttp/src/main/java/okhttp3/internal/connection/Transmitter.kt
@@ -204,6 +204,7 @@ class Transmitter(
 
   fun exchangeDoneDueToException() {
     synchronized(connectionPool) {
+      exchange?.detachWithViolence()
       check(!noMoreExchanges)
       exchange = null
     }
diff --git a/okhttp/src/main/java/okhttp3/internal/http/ExchangeCode.kt b/okhttp/src/main/java/okhttp3/internal/http/ExchangeCodec.kt
similarity index 100%
rename from okhttp/src/main/java/okhttp3/internal/http/ExchangeCode.kt
rename to okhttp/src/main/java/okhttp3/internal/http/ExchangeCodec.kt
diff --git a/okhttp/src/main/java/okhttp3/internal/http/HttpHeaders.kt b/okhttp/src/main/java/okhttp3/internal/http/HttpHeaders.kt
index b9cf66e682..f87da0117d 100644
--- a/okhttp/src/main/java/okhttp3/internal/http/HttpHeaders.kt
+++ b/okhttp/src/main/java/okhttp3/internal/http/HttpHeaders.kt
@@ -64,7 +64,7 @@ fun Headers.parseChallenges(headerName: String): List<Challenge> {
       try {
         header.readChallengeHeader(result)
       } catch (e: EOFException) {
-        Platform.get().log(Platform.WARN, "Unable to parse challenge", e)
+        Platform.get().log("Unable to parse challenge", Platform.WARN, e)
       }
     }
   }
diff --git a/okhttp/src/main/java/okhttp3/internal/http2/Http2Connection.kt b/okhttp/src/main/java/okhttp3/internal/http2/Http2Connection.kt
index 663b6f4038..7b6a402721 100644
--- a/okhttp/src/main/java/okhttp3/internal/http2/Http2Connection.kt
+++ b/okhttp/src/main/java/okhttp3/internal/http2/Http2Connection.kt
@@ -18,19 +18,15 @@ package okhttp3.internal.http2
 import okhttp3.internal.EMPTY_BYTE_ARRAY
 import okhttp3.internal.EMPTY_HEADERS
 import okhttp3.internal.closeQuietly
-import okhttp3.internal.connectionName
-import okhttp3.internal.execute
-import okhttp3.internal.format
+import okhttp3.internal.concurrent.TaskRunner
 import okhttp3.internal.http2.ErrorCode.REFUSED_STREAM
 import okhttp3.internal.http2.Settings.Companion.DEFAULT_INITIAL_WINDOW_SIZE
 import okhttp3.internal.ignoreIoExceptions
 import okhttp3.internal.notifyAll
+import okhttp3.internal.peerName
 import okhttp3.internal.platform.Platform
 import okhttp3.internal.platform.Platform.Companion.INFO
-import okhttp3.internal.threadFactory
-import okhttp3.internal.threadName
 import okhttp3.internal.toHeaders
-import okhttp3.internal.tryExecute
 import okhttp3.internal.wait
 import okio.Buffer
 import okio.BufferedSink
@@ -43,12 +39,7 @@ import java.io.Closeable
 import java.io.IOException
 import java.io.InterruptedIOException
 import java.net.Socket
-import java.util.concurrent.LinkedBlockingQueue
-import java.util.concurrent.ScheduledThreadPoolExecutor
-import java.util.concurrent.SynchronousQueue
-import java.util.concurrent.ThreadPoolExecutor
 import java.util.concurrent.TimeUnit
-import java.util.concurrent.TimeUnit.MILLISECONDS
 
 /**
  * A socket connection to a remote peer. A connection hosts streams which can send and receive
@@ -75,10 +66,7 @@ class Http2Connection internal constructor(builder: Builder) : Closeable {
   /** True if this peer initiated the connection. */
   internal val client: Boolean = builder.client
 
-  /**
-   * User code to run in response to incoming streams or settings. Calls to this are always invoked
-   * on [listenerExecutor].
-   */
+  /** User code to run in response to incoming streams or settings. */
   internal val listener: Listener = builder.listener
   internal val streams = mutableMapOf<Int, Http2Stream>()
   internal val connectionName: String = builder.connectionName
@@ -90,14 +78,17 @@ class Http2Connection internal constructor(builder: Builder) : Closeable {
   @get:Synchronized var isShutdown = false
     internal set
 
+  /** For scheduling everything asynchronous. */
+  private val taskRunner = builder.taskRunner
+
   /** Asynchronously writes frames to the outgoing socket. */
-  private val writerExecutor = ScheduledThreadPoolExecutor(1,
-      threadFactory(format("OkHttp %s Writer", connectionName), false))
+  private val writerQueue = taskRunner.newQueue()
 
   /** Ensures push promise callbacks events are sent in order per stream. */
-  // Like newSingleThreadExecutor, except lazy creates the thread.
-  private val pushExecutor = ThreadPoolExecutor(0, 1, 60L, TimeUnit.SECONDS, LinkedBlockingQueue(),
-      threadFactory(format("OkHttp %s Push Observer", connectionName), true))
+  private val pushQueue = taskRunner.newQueue()
+
+  /** Notifies the listener of settings changes. */
+  private val settingsListenerQueue = taskRunner.newQueue()
 
   /** User code to run in response to push promise events. */
   private val pushObserver: PushObserver = builder.pushObserver
@@ -115,29 +106,28 @@ class Http2Connection internal constructor(builder: Builder) : Closeable {
     }
   }
 
-  /** Settings we receive from the peer. */
-  // TODO: MWS will need to guard on this setting before attempting to push.
-  val peerSettings = Settings().apply {
-    set(Settings.INITIAL_WINDOW_SIZE, DEFAULT_INITIAL_WINDOW_SIZE)
-    set(Settings.MAX_FRAME_SIZE, Http2.INITIAL_MAX_FRAME_SIZE)
-  }
-
   /**
-   * The total number of bytes consumed by the application, but not yet acknowledged by sending a
-   * `WINDOW_UPDATE` frame on this connection.
+   * Settings we receive from the peer. Changes to the field are guarded by this. The instance is
+   * never mutated once it has been assigned.
    */
-  // Visible for testing
-  var unacknowledgedBytesRead = 0L
+  var peerSettings = DEFAULT_SETTINGS
+
+  /** The total number of bytes consumed by the application. */
+  var readBytesTotal = 0L
     private set
 
-  /**
-   * Count of bytes that can be written on the connection before receiving a window update.
-   */
-  // Visible for testing
-  var bytesLeftInWriteWindow: Long = peerSettings.initialWindowSize.toLong()
-    internal set
+  /** The total number of bytes acknowledged by outgoing `WINDOW_UPDATE` frames. */
+  var readBytesAcknowledged = 0L
+    private set
+
+  /** The total number of bytes produced by the application. */
+  var writeBytesTotal = 0L
+    private set
+
+  /** The total number of bytes permitted to be produced according to `WINDOW_UPDATE` frames. */
+  var writeBytesMaximum: Long = peerSettings.initialWindowSize.toLong()
+    private set
 
-  internal var receivedInitialPeerSettings = false
   internal val socket: Socket = builder.socket
   val writer = Http2Writer(builder.sink, client)
 
@@ -149,11 +139,11 @@ class Http2Connection internal constructor(builder: Builder) : Closeable {
 
   init {
     if (builder.pingIntervalMillis != 0) {
-      writerExecutor.scheduleAtFixedRate({
-        threadName("OkHttp $connectionName ping") {
-          writePing(false, 0, 0)
-        }
-      }, builder.pingIntervalMillis.toLong(), builder.pingIntervalMillis.toLong(), MILLISECONDS)
+      val pingIntervalNanos = TimeUnit.MILLISECONDS.toNanos(builder.pingIntervalMillis.toLong())
+      writerQueue.schedule("$connectionName ping", pingIntervalNanos) {
+        writePing(false, 0, 0)
+        return@schedule pingIntervalNanos
+      }
     }
   }
 
@@ -173,14 +163,12 @@ class Http2Connection internal constructor(builder: Builder) : Closeable {
     return stream
   }
 
-  @Synchronized fun maxConcurrentStreams(): Int =
-      peerSettings.getMaxConcurrentStreams(Integer.MAX_VALUE)
-
   @Synchronized internal fun updateConnectionFlowControl(read: Long) {
-    unacknowledgedBytesRead += read
-    if (unacknowledgedBytesRead >= okHttpSettings.initialWindowSize / 2) {
-      writeWindowUpdateLater(0, unacknowledgedBytesRead)
-      unacknowledgedBytesRead = 0
+    readBytesTotal += read
+    val readBytesToAcknowledge = readBytesTotal - readBytesAcknowledged
+    if (readBytesToAcknowledge >= okHttpSettings.initialWindowSize / 2) {
+      writeWindowUpdateLater(0, readBytesToAcknowledge)
+      readBytesAcknowledged += readBytesToAcknowledge
     }
   }
 
@@ -229,7 +217,7 @@ class Http2Connection internal constructor(builder: Builder) : Closeable {
 
     synchronized(writer) {
       synchronized(this) {
-        if (nextStreamId > Integer.MAX_VALUE / 2) {
+        if (nextStreamId > Int.MAX_VALUE / 2) {
           shutdown(REFUSED_STREAM)
         }
         if (isShutdown) {
@@ -238,7 +226,9 @@ class Http2Connection internal constructor(builder: Builder) : Closeable {
         streamId = nextStreamId
         nextStreamId += 2
         stream = Http2Stream(streamId, this, outFinished, inFinished, null)
-        flushHeaders = (!out || bytesLeftInWriteWindow == 0L || stream.bytesLeftInWriteWindow == 0L)
+        flushHeaders = !out ||
+            writeBytesTotal >= writeBytesMaximum ||
+            stream.writeBytesTotal >= stream.writeBytesMaximum
         if (stream.isOpen) {
           streams[streamId] = stream
         }
@@ -298,7 +288,7 @@ class Http2Connection internal constructor(builder: Builder) : Closeable {
       var toWrite: Int
       synchronized(this@Http2Connection) {
         try {
-          while (bytesLeftInWriteWindow <= 0L) {
+          while (writeBytesTotal >= writeBytesMaximum) {
             // Before blocking, confirm that the stream we're writing is still open. It's possible
             // that the stream has since been closed (such as if this write timed out.)
             if (!streams.containsKey(streamId)) {
@@ -311,9 +301,9 @@ class Http2Connection internal constructor(builder: Builder) : Closeable {
           throw InterruptedIOException()
         }
 
-        toWrite = minOf(byteCount, bytesLeftInWriteWindow).toInt()
+        toWrite = minOf(byteCount, writeBytesMaximum - writeBytesTotal).toInt()
         toWrite = minOf(toWrite, writer.maxDataLength())
-        bytesLeftInWriteWindow -= toWrite.toLong()
+        writeBytesTotal += toWrite.toLong()
       }
 
       byteCount -= toWrite.toLong()
@@ -325,7 +315,7 @@ class Http2Connection internal constructor(builder: Builder) : Closeable {
     streamId: Int,
     errorCode: ErrorCode
   ) {
-    writerExecutor.tryExecute("OkHttp $connectionName stream $streamId") {
+    writerQueue.execute("$connectionName[$streamId] writeSynReset") {
       try {
         writeSynReset(streamId, errorCode)
       } catch (e: IOException) {
@@ -346,7 +336,7 @@ class Http2Connection internal constructor(builder: Builder) : Closeable {
     streamId: Int,
     unacknowledgedBytesRead: Long
   ) {
-    writerExecutor.tryExecute("OkHttp Window Update $connectionName stream $streamId") {
+    writerQueue.execute("$connectionName[$streamId] windowUpdate") {
       try {
         writer.windowUpdate(streamId, unacknowledgedBytesRead)
       } catch (e: IOException) {
@@ -423,7 +413,7 @@ class Http2Connection internal constructor(builder: Builder) : Closeable {
 
   /**
    * Closes this connection. This cancels all open streams and unanswered pings. It closes the
-   * underlying input and output streams and shuts down internal executor services.
+   * underlying input and output streams and shuts down internal task queues.
    */
   override fun close() {
     close(ErrorCode.NO_ERROR, ErrorCode.CANCEL, null)
@@ -464,8 +454,9 @@ class Http2Connection internal constructor(builder: Builder) : Closeable {
     }
 
     // Release the threads.
-    writerExecutor.shutdown()
-    pushExecutor.shutdown()
+    writerQueue.shutdown()
+    pushQueue.shutdown()
+    settingsListenerQueue.shutdown()
   }
 
   private fun failConnection(e: IOException?) {
@@ -489,7 +480,7 @@ class Http2Connection internal constructor(builder: Builder) : Closeable {
         writer.windowUpdate(0, (windowSize - DEFAULT_INITIAL_WINDOW_SIZE).toLong())
       }
     }
-    Thread(readerRunnable, "OkHttp $connectionName").start() // Not a daemon thread.
+    Thread(readerRunnable, connectionName).start() // Not a daemon thread.
   }
 
   /** Merges [settings] into this peer's settings and sends them to the remote peer. */
@@ -508,7 +499,8 @@ class Http2Connection internal constructor(builder: Builder) : Closeable {
 
   class Builder(
     /** True if this peer initiated the connection; false if this peer accepted the connection. */
-    internal var client: Boolean
+    internal var client: Boolean,
+    internal val taskRunner: TaskRunner
   ) {
     internal lateinit var socket: Socket
     internal lateinit var connectionName: String
@@ -521,12 +513,15 @@ class Http2Connection internal constructor(builder: Builder) : Closeable {
     @Throws(IOException::class) @JvmOverloads
     fun socket(
       socket: Socket,
-      connectionName: String = socket.connectionName(),
+      peerName: String = socket.peerName(),
       source: BufferedSource = socket.source().buffer(),
       sink: BufferedSink = socket.sink().buffer()
     ) = apply {
       this.socket = socket
-      this.connectionName = connectionName
+      this.connectionName = when {
+        client -> "OkHttp $peerName"
+        else -> "MockWebServer $peerName"
+      }
       this.source = source
       this.sink = sink
     }
@@ -628,11 +623,13 @@ class Http2Connection internal constructor(builder: Builder) : Closeable {
           val newStream = Http2Stream(streamId, this@Http2Connection, false, inFinished, headers)
           lastGoodStreamId = streamId
           streams[streamId] = newStream
-          listenerExecutor.execute("OkHttp $connectionName stream $streamId") {
+
+          // Use a different task queue for each stream because they should be handled in parallel.
+          taskRunner.newQueue().execute("$connectionName[$streamId] onStream") {
             try {
               listener.onStream(newStream)
             } catch (e: IOException) {
-              Platform.get().log(INFO, "Http2Connection.Listener failure for $connectionName", e)
+              Platform.get().log("Http2Connection.Listener failure for $connectionName", INFO, e)
               ignoreIoExceptions {
                 newStream.close(ErrorCode.PROTOCOL_ERROR, e)
               }
@@ -656,28 +653,60 @@ class Http2Connection internal constructor(builder: Builder) : Closeable {
     }
 
     override fun settings(clearPrevious: Boolean, settings: Settings) {
-      var delta = 0L
-      var streamsToNotify: Array<Http2Stream>? = null
-      synchronized(this@Http2Connection) {
-        val priorWriteWindowSize = peerSettings.initialWindowSize
-        if (clearPrevious) peerSettings.clear()
-        peerSettings.merge(settings)
-        applyAndAckSettings(settings)
-        val peerInitialWindowSize = peerSettings.initialWindowSize
-        if (peerInitialWindowSize != -1 && peerInitialWindowSize != priorWriteWindowSize) {
-          delta = (peerInitialWindowSize - priorWriteWindowSize).toLong()
-          if (!receivedInitialPeerSettings) {
-            receivedInitialPeerSettings = true
+      writerQueue.execute("$connectionName applyAndAckSettings") {
+        applyAndAckSettings(clearPrevious, settings)
+      }
+    }
+
+    /**
+     * Apply inbound settings and send an acknowledgement to the peer that provided them.
+     *
+     * We need to apply the settings and ack them atomically. This is because some HTTP/2
+     * implementations (nghttp2) forbid peers from taking advantage of settings before they have
+     * acknowledged! In particular, we shouldn't send frames that assume a new `initialWindowSize`
+     * until we send the frame that acknowledges this new size.
+     *
+     * Since we can't ACK settings on the current reader thread (the reader thread can't write) we
+     * execute all peer settings logic on the writer thread. This relies on the fact that the
+     * writer task queue won't reorder tasks; otherwise settings could be applied in the opposite
+     * order than received.
+     */
+    fun applyAndAckSettings(clearPrevious: Boolean, settings: Settings) {
+      var delta: Long
+      var streamsToNotify: Array<Http2Stream>?
+      var newPeerSettings: Settings
+      synchronized(writer) {
+        synchronized(this@Http2Connection) {
+          val previousPeerSettings = peerSettings
+          if (clearPrevious) {
+            newPeerSettings = settings
+          } else {
+            newPeerSettings = Settings().apply {
+              merge(previousPeerSettings)
+              merge(settings)
+            }
+          }
+
+          val peerInitialWindowSize = newPeerSettings.initialWindowSize.toLong()
+          delta = peerInitialWindowSize - previousPeerSettings.initialWindowSize.toLong()
+          streamsToNotify = when {
+            delta == 0L || streams.isEmpty() -> null // No adjustment is necessary.
+            else -> streams.values.toTypedArray()
           }
-          if (streams.isNotEmpty()) {
-            streamsToNotify = streams.values.toTypedArray()
+
+          peerSettings = newPeerSettings
+
+          settingsListenerQueue.execute("$connectionName onSettings") {
+            listener.onSettings(this@Http2Connection, newPeerSettings)
           }
         }
-        listenerExecutor.execute("OkHttp $connectionName settings") {
-          listener.onSettings(this@Http2Connection)
+        try {
+          writer.applyAndAckSettings(newPeerSettings)
+        } catch (e: IOException) {
+          failConnection(e)
         }
       }
-      if (streamsToNotify != null && delta != 0L) {
+      if (streamsToNotify != null) {
         for (stream in streamsToNotify!!) {
           synchronized(stream) {
             stream.addBytesToWriteWindow(delta)
@@ -686,16 +715,6 @@ class Http2Connection internal constructor(builder: Builder) : Closeable {
       }
     }
 
-    private fun applyAndAckSettings(peerSettings: Settings) {
-      writerExecutor.tryExecute("OkHttp $connectionName ACK Settings") {
-        try {
-          writer.applyAndAckSettings(peerSettings)
-        } catch (e: IOException) {
-          failConnection(e)
-        }
-      }
-    }
-
     override fun ackSettings() {
       // TODO: If we don't get this callback after sending settings to the peer, SETTINGS_TIMEOUT.
     }
@@ -712,7 +731,7 @@ class Http2Connection internal constructor(builder: Builder) : Closeable {
         }
       } else {
         // Send a reply to a client ping if this is a server and vice versa.
-        writerExecutor.tryExecute("OkHttp $connectionName ping") {
+        writerQueue.execute("$connectionName ping") {
           writePing(true, payload1, payload2)
         }
       }
@@ -746,7 +765,7 @@ class Http2Connection internal constructor(builder: Builder) : Closeable {
     override fun windowUpdate(streamId: Int, windowSizeIncrement: Long) {
       if (streamId == 0) {
         synchronized(this@Http2Connection) {
-          bytesLeftInWriteWindow += windowSizeIncrement
+          writeBytesMaximum += windowSizeIncrement
           this@Http2Connection.notifyAll()
         }
       } else {
@@ -799,15 +818,13 @@ class Http2Connection internal constructor(builder: Builder) : Closeable {
       }
       currentPushRequests.add(streamId)
     }
-    if (!isShutdown) {
-      pushExecutor.tryExecute("OkHttp $connectionName Push Request[$streamId]") {
-        val cancel = pushObserver.onRequest(streamId, requestHeaders)
-        ignoreIoExceptions {
-          if (cancel) {
-            writer.rstStream(streamId, ErrorCode.CANCEL)
-            synchronized(this@Http2Connection) {
-              currentPushRequests.remove(streamId)
-            }
+    pushQueue.execute("$connectionName[$streamId] onRequest") {
+      val cancel = pushObserver.onRequest(streamId, requestHeaders)
+      ignoreIoExceptions {
+        if (cancel) {
+          writer.rstStream(streamId, ErrorCode.CANCEL)
+          synchronized(this@Http2Connection) {
+            currentPushRequests.remove(streamId)
           }
         }
       }
@@ -819,15 +836,13 @@ class Http2Connection internal constructor(builder: Builder) : Closeable {
     requestHeaders: List<Header>,
     inFinished: Boolean
   ) {
-    if (!isShutdown) {
-      pushExecutor.tryExecute("OkHttp $connectionName Push Headers[$streamId]") {
-        val cancel = pushObserver.onHeaders(streamId, requestHeaders, inFinished)
-        ignoreIoExceptions {
-          if (cancel) writer.rstStream(streamId, ErrorCode.CANCEL)
-          if (cancel || inFinished) {
-            synchronized(this@Http2Connection) {
-              currentPushRequests.remove(streamId)
-            }
+    pushQueue.execute("$connectionName[$streamId] onHeaders") {
+      val cancel = pushObserver.onHeaders(streamId, requestHeaders, inFinished)
+      ignoreIoExceptions {
+        if (cancel) writer.rstStream(streamId, ErrorCode.CANCEL)
+        if (cancel || inFinished) {
+          synchronized(this@Http2Connection) {
+            currentPushRequests.remove(streamId)
           }
         }
       }
@@ -848,15 +863,13 @@ class Http2Connection internal constructor(builder: Builder) : Closeable {
     val buffer = Buffer()
     source.require(byteCount.toLong()) // Eagerly read the frame before firing client thread.
     source.read(buffer, byteCount.toLong())
-    if (!isShutdown) {
-      pushExecutor.execute("OkHttp $connectionName Push Data[$streamId]") {
-        ignoreIoExceptions {
-          val cancel = pushObserver.onData(streamId, buffer, byteCount, inFinished)
-          if (cancel) writer.rstStream(streamId, ErrorCode.CANCEL)
-          if (cancel || inFinished) {
-            synchronized(this@Http2Connection) {
-              currentPushRequests.remove(streamId)
-            }
+    pushQueue.execute("$connectionName[$streamId] onData") {
+      ignoreIoExceptions {
+        val cancel = pushObserver.onData(streamId, buffer, byteCount, inFinished)
+        if (cancel) writer.rstStream(streamId, ErrorCode.CANCEL)
+        if (cancel || inFinished) {
+          synchronized(this@Http2Connection) {
+            currentPushRequests.remove(streamId)
           }
         }
       }
@@ -864,12 +877,10 @@ class Http2Connection internal constructor(builder: Builder) : Closeable {
   }
 
   internal fun pushResetLater(streamId: Int, errorCode: ErrorCode) {
-    if (!isShutdown) {
-      pushExecutor.execute("OkHttp $connectionName Push Reset[$streamId]") {
-        pushObserver.onReset(streamId, errorCode)
-        synchronized(this@Http2Connection) {
-          currentPushRequests.remove(streamId)
-        }
+    pushQueue.execute("$connectionName[$streamId] onReset") {
+      pushObserver.onReset(streamId, errorCode)
+      synchronized(this@Http2Connection) {
+        currentPushRequests.remove(streamId)
       }
     }
   }
@@ -880,19 +891,20 @@ class Http2Connection internal constructor(builder: Builder) : Closeable {
      * Handle a new stream from this connection's peer. Implementations should respond by either
      * [replying to the stream][Http2Stream.writeHeaders] or [closing it][Http2Stream.close]. This
      * response does not need to be synchronous.
+     *
+     * Multiple calls to this method may be made concurrently.
      */
     @Throws(IOException::class)
     abstract fun onStream(stream: Http2Stream)
 
     /**
-     * Notification that the connection's peer's settings may have changed. Implementations should
-     * take appropriate action to handle the updated settings.
+     * Notification that the connection's peer's settings may have changed to [settings].
+     * Implementations should take appropriate action to handle the updated settings.
      *
-     * It is the implementation's responsibility to handle concurrent calls to this method. A remote
-     * peer that sends multiple settings frames will trigger multiple calls to this method, and
-     * those calls are not necessarily serialized.
+     * Methods to this method may be made concurrently with [onStream]. But a calls to this method
+     * are serialized.
      */
-    open fun onSettings(connection: Http2Connection) {}
+    open fun onSettings(connection: Http2Connection, settings: Settings) {}
 
     companion object {
       @JvmField
@@ -908,12 +920,9 @@ class Http2Connection internal constructor(builder: Builder) : Closeable {
   companion object {
     const val OKHTTP_CLIENT_WINDOW_SIZE = 16 * 1024 * 1024
 
-    /**
-     * Shared executor to send notifications of incoming streams. This executor requires multiple
-     * threads because listeners are not required to return promptly.
-     */
-    private val listenerExecutor = ThreadPoolExecutor(0,
-        Integer.MAX_VALUE, 60L, TimeUnit.SECONDS, SynchronousQueue(),
-        threadFactory("OkHttp Http2Connection", true))
+    val DEFAULT_SETTINGS = Settings().apply {
+      set(Settings.INITIAL_WINDOW_SIZE, DEFAULT_INITIAL_WINDOW_SIZE)
+      set(Settings.MAX_FRAME_SIZE, Http2.INITIAL_MAX_FRAME_SIZE)
+    }
   }
 }
diff --git a/okhttp/src/main/java/okhttp3/internal/http2/Http2Stream.kt b/okhttp/src/main/java/okhttp3/internal/http2/Http2Stream.kt
index 045150fed3..7dad0e67f2 100644
--- a/okhttp/src/main/java/okhttp3/internal/http2/Http2Stream.kt
+++ b/okhttp/src/main/java/okhttp3/internal/http2/Http2Stream.kt
@@ -44,20 +44,20 @@ class Http2Stream internal constructor(
   // Internal state is guarded by this. No long-running or potentially blocking operations are
   // performed while the lock is held.
 
-  /**
-   * The total number of bytes consumed by the application (with [FramingSource.read]), but
-   * not yet acknowledged by sending a `WINDOW_UPDATE` frame on this stream.
-   */
-  var unacknowledgedBytesRead = 0L
+  /** The total number of bytes consumed by the application. */
+  var readBytesTotal = 0L
     internal set
 
-  /**
-   * Count of bytes that can be written on the stream before receiving a window update. Even if this
-   * is positive, writes will block until there available bytes in
-   * [Http2Connection.bytesLeftInWriteWindow].
-   */
-  // guarded by this
-  var bytesLeftInWriteWindow: Long = connection.peerSettings.initialWindowSize.toLong()
+  /** The total number of bytes acknowledged by outgoing `WINDOW_UPDATE` frames. */
+  var readBytesAcknowledged = 0L
+    internal set
+
+  /** The total number of bytes produced by the application. */
+  var writeBytesTotal = 0L
+    internal set
+
+  /** The total number of bytes permitted to be produced by incoming `WINDOW_UPDATE` frame. */
+  var writeBytesMaximum: Long = connection.peerSettings.initialWindowSize.toLong()
     internal set
 
   /** Received headers yet to be [taken][takeHeaders], or [read][FramingSource.read]. */
@@ -185,7 +185,7 @@ class Http2Stream internal constructor(
     // flow-control window is fully depleted.
     if (!flushHeaders) {
       synchronized(connection) {
-        flushHeaders = connection.bytesLeftInWriteWindow == 0L
+        flushHeaders = (connection.writeBytesTotal >= connection.writeBytesMaximum)
       }
     }
 
@@ -358,14 +358,15 @@ class Http2Stream internal constructor(
             } else if (readBuffer.size > 0L) {
               // Prepare to read bytes. Start by moving them to the caller's buffer.
               readBytesDelivered = readBuffer.read(sink, minOf(byteCount, readBuffer.size))
-              unacknowledgedBytesRead += readBytesDelivered
+              readBytesTotal += readBytesDelivered
 
+              val unacknowledgedBytesRead = readBytesTotal - readBytesAcknowledged
               if (errorExceptionToDeliver == null &&
                   unacknowledgedBytesRead >= connection.okHttpSettings.initialWindowSize / 2) {
                 // Flow control: notify the peer that we're ready for more data! Only send a
                 // WINDOW_UPDATE if the stream isn't in error.
                 connection.writeWindowUpdateLater(id, unacknowledgedBytesRead)
-                unacknowledgedBytesRead = 0
+                readBytesAcknowledged = readBytesTotal
               }
             } else if (!finished && errorExceptionToDeliver == null) {
               // Nothing to do. Wait until that changes then try again.
@@ -406,6 +407,10 @@ class Http2Stream internal constructor(
       connection.updateConnectionFlowControl(read)
     }
 
+    /**
+     * Accept bytes on the connection's reader thread. This function avoids holding locks while it
+     * performs blocking reads for the incoming bytes.
+     */
     @Throws(IOException::class)
     internal fun receive(source: BufferedSource, byteCount: Long) {
       var byteCount = byteCount
@@ -437,14 +442,25 @@ class Http2Stream internal constructor(
         if (read == -1L) throw EOFException()
         byteCount -= read
 
-        // Move the received data to the read buffer to the reader can read it.
+        // Move the received data to the read buffer to the reader can read it. If this source has
+        // been closed since this read began we must discard the incoming data and tell the
+        // connection we've done so.
+        var bytesDiscarded = 0L
         synchronized(this@Http2Stream) {
-          val wasEmpty = readBuffer.size == 0L
-          readBuffer.writeAll(receiveBuffer)
-          if (wasEmpty) {
-            this@Http2Stream.notifyAll()
+          if (closed) {
+            bytesDiscarded = receiveBuffer.size
+            receiveBuffer.clear()
+          } else {
+            val wasEmpty = readBuffer.size == 0L
+            readBuffer.writeAll(receiveBuffer)
+            if (wasEmpty) {
+              this@Http2Stream.notifyAll()
+            }
           }
         }
+        if (bytesDiscarded > 0L) {
+          updateConnectionFlowControl(bytesDiscarded)
+        }
       }
     }
 
@@ -518,10 +534,14 @@ class Http2Stream internal constructor(
     @Throws(IOException::class)
     private fun emitFrame(outFinishedOnLastFrame: Boolean) {
       val toWrite: Long
+      val outFinished: Boolean
       synchronized(this@Http2Stream) {
         writeTimeout.enter()
         try {
-          while (bytesLeftInWriteWindow <= 0L && !finished && !closed && errorCode == null) {
+          while (writeBytesTotal >= writeBytesMaximum &&
+              !finished &&
+              !closed &&
+              errorCode == null) {
             waitForIo() // Wait until we receive a WINDOW_UPDATE for this stream.
           }
         } finally {
@@ -529,13 +549,13 @@ class Http2Stream internal constructor(
         }
 
         checkOutNotClosed() // Kick out if the stream was reset or closed while waiting.
-        toWrite = minOf(bytesLeftInWriteWindow, sendBuffer.size)
-        bytesLeftInWriteWindow -= toWrite
+        toWrite = minOf(writeBytesMaximum - writeBytesTotal, sendBuffer.size)
+        writeBytesTotal += toWrite
+        outFinished = outFinishedOnLastFrame && toWrite == sendBuffer.size && errorCode == null
       }
 
       writeTimeout.enter()
       try {
-        val outFinished = outFinishedOnLastFrame && toWrite == sendBuffer.size
         connection.writeData(id, outFinished, sendBuffer, toWrite)
       } finally {
         writeTimeout.exitAndThrowIfTimedOut()
@@ -559,8 +579,11 @@ class Http2Stream internal constructor(
     @Throws(IOException::class)
     override fun close() {
       assert(!Thread.holdsLock(this@Http2Stream))
+
+      val outFinished: Boolean
       synchronized(this@Http2Stream) {
         if (closed) return
+        outFinished = errorCode == null
       }
       if (!sink.finished) {
         // We have 0 or more frames of data, and 0 or more frames of trailers. We need to send at
@@ -573,7 +596,7 @@ class Http2Stream internal constructor(
             while (sendBuffer.size > 0L) {
               emitFrame(false)
             }
-            connection.writeHeaders(id, true, trailers!!.toHeaderList())
+            connection.writeHeaders(id, outFinished, trailers!!.toHeaderList())
           }
 
           hasData -> {
@@ -582,7 +605,7 @@ class Http2Stream internal constructor(
             }
           }
 
-          else -> {
+          outFinished -> {
             connection.writeData(id, true, null, 0L)
           }
         }
@@ -601,7 +624,7 @@ class Http2Stream internal constructor(
 
   /** [delta] will be negative if a settings frame initial window is smaller than the last. */
   fun addBytesToWriteWindow(delta: Long) {
-    bytesLeftInWriteWindow += delta
+    writeBytesMaximum += delta
     if (delta > 0L) {
       this@Http2Stream.notifyAll()
     }
diff --git a/okhttp/src/main/java/okhttp3/internal/http2/Settings.kt b/okhttp/src/main/java/okhttp3/internal/http2/Settings.kt
index 91315d3570..7f90fd9e06 100644
--- a/okhttp/src/main/java/okhttp3/internal/http2/Settings.kt
+++ b/okhttp/src/main/java/okhttp3/internal/http2/Settings.kt
@@ -74,9 +74,9 @@ class Settings {
     return if (bit and set != 0) values[ENABLE_PUSH] == 1 else defaultValue
   }
 
-  fun getMaxConcurrentStreams(defaultValue: Int): Int {
+  fun getMaxConcurrentStreams(): Int {
     val bit = 1 shl MAX_CONCURRENT_STREAMS
-    return if (bit and set != 0) values[MAX_CONCURRENT_STREAMS] else defaultValue
+    return if (bit and set != 0) values[MAX_CONCURRENT_STREAMS] else Int.MAX_VALUE
   }
 
   fun getMaxFrameSize(defaultValue: Int): Int {
diff --git a/okhttp/src/main/java/okhttp3/internal/platform/Android10Platform.kt b/okhttp/src/main/java/okhttp3/internal/platform/Android10Platform.kt
new file mode 100644
index 0000000000..fda2a2c105
--- /dev/null
+++ b/okhttp/src/main/java/okhttp3/internal/platform/Android10Platform.kt
@@ -0,0 +1,69 @@
+/*
+ * Copyright (C) 2016 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.internal.platform
+
+import android.os.Build
+import android.security.NetworkSecurityPolicy
+import okhttp3.Protocol
+import okhttp3.internal.platform.AndroidPlatform.Companion.isAndroid
+import okhttp3.internal.platform.android.Android10CertificateChainCleaner
+import okhttp3.internal.platform.android.Android10SocketAdapter
+import okhttp3.internal.platform.android.ConscryptSocketAdapter
+import okhttp3.internal.platform.android.DeferredSocketAdapter
+import okhttp3.internal.platform.android.androidLog
+import okhttp3.internal.tls.CertificateChainCleaner
+import javax.net.ssl.SSLSocket
+import javax.net.ssl.SSLSocketFactory
+import javax.net.ssl.X509TrustManager
+
+/** Android 29+. */
+class Android10Platform : Platform() {
+  private val socketAdapters = listOfNotNull(
+      Android10SocketAdapter.buildIfSupported(),
+      ConscryptSocketAdapter.buildIfSupported(),
+      DeferredSocketAdapter("com.google.android.gms.org.conscrypt")
+  ).filter { it.isSupported() }
+
+  override fun trustManager(sslSocketFactory: SSLSocketFactory): X509TrustManager? =
+      socketAdapters.find { it.matchesSocketFactory(sslSocketFactory) }
+          ?.trustManager(sslSocketFactory)
+
+  override fun configureTlsExtensions(sslSocket: SSLSocket, protocols: List<Protocol>) {
+    // No TLS extensions if the socket class is custom.
+    socketAdapters.find { it.matchesSocket(sslSocket) }
+        ?.configureTlsExtensions(sslSocket, protocols)
+  }
+
+  override fun getSelectedProtocol(sslSocket: SSLSocket) =
+      // No TLS extensions if the socket class is custom.
+      socketAdapters.find { it.matchesSocket(sslSocket) }?.getSelectedProtocol(sslSocket)
+
+  override fun log(message: String, level: Int, t: Throwable?) {
+    androidLog(level, message, t)
+  }
+
+  override fun isCleartextTrafficPermitted(hostname: String): Boolean =
+      NetworkSecurityPolicy.getInstance().isCleartextTrafficPermitted(hostname)
+
+  override fun buildCertificateChainCleaner(trustManager: X509TrustManager): CertificateChainCleaner =
+      Android10CertificateChainCleaner(trustManager)
+
+  companion object {
+    val isSupported: Boolean = isAndroid && Build.VERSION.SDK_INT >= 29
+
+    fun buildIfSupported(): Platform? = if (isSupported) Android10Platform() else null
+  }
+}
diff --git a/okhttp/src/main/java/okhttp3/internal/platform/AndroidPlatform.kt b/okhttp/src/main/java/okhttp3/internal/platform/AndroidPlatform.kt
index 331850b07c..6e917029f9 100644
--- a/okhttp/src/main/java/okhttp3/internal/platform/AndroidPlatform.kt
+++ b/okhttp/src/main/java/okhttp3/internal/platform/AndroidPlatform.kt
@@ -17,6 +17,7 @@ package okhttp3.internal.platform
 
 import android.os.Build
 import okhttp3.Protocol
+import okhttp3.internal.platform.android.AndroidCertificateChainCleaner
 import okhttp3.internal.platform.android.CloseGuard
 import okhttp3.internal.platform.android.ConscryptSocketAdapter
 import okhttp3.internal.platform.android.DeferredSocketAdapter
@@ -30,10 +31,8 @@ import java.lang.reflect.InvocationTargetException
 import java.lang.reflect.Method
 import java.net.InetSocketAddress
 import java.net.Socket
-import java.security.cert.Certificate
 import java.security.cert.TrustAnchor
 import java.security.cert.X509Certificate
-import javax.net.ssl.SSLPeerUnverifiedException
 import javax.net.ssl.SSLSocket
 import javax.net.ssl.SSLSocketFactory
 import javax.net.ssl.X509TrustManager
@@ -73,19 +72,18 @@ class AndroidPlatform : Platform() {
 
   override fun configureTlsExtensions(
     sslSocket: SSLSocket,
-    hostname: String?,
-    protocols: List<Protocol>
+    protocols: List<@JvmSuppressWildcards Protocol>
   ) {
     // No TLS extensions if the socket class is custom.
     socketAdapters.find { it.matchesSocket(sslSocket) }
-        ?.configureTlsExtensions(sslSocket, hostname, protocols)
+        ?.configureTlsExtensions(sslSocket, protocols)
   }
 
   override fun getSelectedProtocol(sslSocket: SSLSocket) =
       // No TLS extensions if the socket class is custom.
       socketAdapters.find { it.matchesSocket(sslSocket) }?.getSelectedProtocol(sslSocket)
 
-  override fun log(level: Int, message: String, t: Throwable?) {
+  override fun log(message: String, level: Int, t: Throwable?) {
     androidLog(level, message, t)
   }
 
@@ -95,7 +93,7 @@ class AndroidPlatform : Platform() {
     val reported = closeGuard.warnIfOpen(stackTrace)
     if (!reported) {
       // Unable to report via CloseGuard. As a last-ditch effort, send it to the logger.
-      log(WARN, message, null)
+      log(message, WARN)
     }
   }
 
@@ -145,17 +143,7 @@ class AndroidPlatform : Platform() {
   }
 
   override fun buildCertificateChainCleaner(trustManager: X509TrustManager): CertificateChainCleaner =
-      try {
-        val extensionsClass = Class.forName("android.net.http.X509TrustManagerExtensions")
-        val constructor = extensionsClass.getConstructor(X509TrustManager::class.java)
-        val extensions = constructor.newInstance(trustManager)
-        val checkServerTrusted = extensionsClass.getMethod(
-            "checkServerTrusted", Array<X509Certificate>::class.java, String::class.java,
-            String::class.java)
-        AndroidCertificateChainCleaner(extensions, checkServerTrusted)
-      } catch (_: Exception) {
-        super.buildCertificateChainCleaner(trustManager)
-      }
+        AndroidCertificateChainCleaner.build(trustManager) ?: super.buildCertificateChainCleaner(trustManager)
 
   override fun buildTrustRootIndex(trustManager: X509TrustManager): TrustRootIndex = try {
     // From org.conscrypt.TrustManagerImpl, we want the method with this signature:
@@ -168,37 +156,6 @@ class AndroidPlatform : Platform() {
     super.buildTrustRootIndex(trustManager)
   }
 
-  /**
-   * X509TrustManagerExtensions was added to Android in API 17 (Android 4.2, released in late 2012).
-   * This is the best way to get a clean chain on Android because it uses the same code as the TLS
-   * handshake.
-   */
-  internal class AndroidCertificateChainCleaner(
-    private val x509TrustManagerExtensions: Any,
-    private val checkServerTrusted: Method
-  ) : CertificateChainCleaner() {
-
-    @Suppress("UNCHECKED_CAST")
-    @Throws(SSLPeerUnverifiedException::class)
-    override // Reflection on List<Certificate>.
-    fun clean(chain: List<Certificate>, hostname: String): List<Certificate> = try {
-      val certificates = (chain as List<X509Certificate>).toTypedArray()
-      checkServerTrusted.invoke(
-          x509TrustManagerExtensions, certificates, "RSA", hostname) as List<Certificate>
-    } catch (e: InvocationTargetException) {
-      val exception = SSLPeerUnverifiedException(e.message)
-      exception.initCause(e)
-      throw exception
-    } catch (e: IllegalAccessException) {
-      throw AssertionError(e)
-    }
-
-    override fun equals(other: Any?): Boolean =
-        other is AndroidCertificateChainCleaner // All instances are equivalent.
-
-    override fun hashCode(): Int = 0
-  }
-
   /**
    * A trust manager for Android applications that customize the trust manager.
    *
@@ -224,16 +181,31 @@ class AndroidPlatform : Platform() {
   }
 
   companion object {
-    val isSupported: Boolean = try {
+    val isAndroid: Boolean = try {
       // Trigger an early exception over a fatal error, prefer a RuntimeException over Error.
       Class.forName("com.android.org.conscrypt.OpenSSLSocketImpl")
 
-      // Fail Fast
-      check(Build.VERSION.SDK_INT >= 21) { "Expected Android API level 21+ but was ${Build.VERSION.SDK_INT}" }
+      // account for android-all, forces UnsatisfiedLinkError in Intellij
+      check(Build.VERSION.SDK_INT > 0)
 
       true
     } catch (_: ClassNotFoundException) {
+      // Running in a JVM
       false
+    } catch (_: UnsatisfiedLinkError) {
+      // Running in a JVM/Intellij with android-all on the classpath
+      false
+    }
+
+    val isSupported: Boolean = when {
+      !isAndroid -> false
+      else -> {
+        // Fail Fast
+        check(
+            Build.VERSION.SDK_INT >= 21) { "Expected Android API level 21+ but was ${Build.VERSION.SDK_INT}" }
+
+        true
+      }
     }
 
     fun buildIfSupported(): Platform? = if (isSupported) AndroidPlatform() else null
diff --git a/okhttp/src/main/java/okhttp3/internal/platform/ConscryptPlatform.kt b/okhttp/src/main/java/okhttp3/internal/platform/ConscryptPlatform.kt
index a5f9911c21..3ab0859988 100644
--- a/okhttp/src/main/java/okhttp3/internal/platform/ConscryptPlatform.kt
+++ b/okhttp/src/main/java/okhttp3/internal/platform/ConscryptPlatform.kt
@@ -64,21 +64,17 @@ class ConscryptPlatform private constructor() : Platform() {
 
   override fun configureTlsExtensions(
     sslSocket: SSLSocket,
-    hostname: String?,
-    protocols: List<Protocol>
+    protocols: List<@JvmSuppressWildcards Protocol>
   ) {
     if (Conscrypt.isConscrypt(sslSocket)) {
-      // Enable SNI and session tickets.
-      if (hostname != null) {
-        Conscrypt.setUseSessionTickets(sslSocket, true)
-        Conscrypt.setHostname(sslSocket, hostname)
-      }
+      // Enable session tickets.
+      Conscrypt.setUseSessionTickets(sslSocket, true)
 
       // Enable ALPN.
       val names = alpnProtocolNames(protocols)
       Conscrypt.setApplicationProtocols(sslSocket, names.toTypedArray())
     } else {
-      super.configureTlsExtensions(sslSocket, hostname, protocols)
+      super.configureTlsExtensions(sslSocket, protocols)
     }
   }
 
diff --git a/okhttp/src/main/java/okhttp3/internal/platform/Jdk8WithJettyBootPlatform.kt b/okhttp/src/main/java/okhttp3/internal/platform/Jdk8WithJettyBootPlatform.kt
index 92e8d1c96e..65ba5c3062 100644
--- a/okhttp/src/main/java/okhttp3/internal/platform/Jdk8WithJettyBootPlatform.kt
+++ b/okhttp/src/main/java/okhttp3/internal/platform/Jdk8WithJettyBootPlatform.kt
@@ -32,7 +32,6 @@ class Jdk8WithJettyBootPlatform(
 ) : Platform() {
   override fun configureTlsExtensions(
     sslSocket: SSLSocket,
-    hostname: String?,
     protocols: List<Protocol>
   ) {
     val names = alpnProtocolNames(protocols)
@@ -58,13 +57,11 @@ class Jdk8WithJettyBootPlatform(
     }
   }
 
-  override fun getSelectedProtocol(socket: SSLSocket): String? {
+  override fun getSelectedProtocol(sslSocket: SSLSocket): String? {
     try {
-      val provider = Proxy.getInvocationHandler(getMethod.invoke(null, socket)) as AlpnProvider
+      val provider = Proxy.getInvocationHandler(getMethod.invoke(null, sslSocket)) as AlpnProvider
       if (!provider.unsupported && provider.selected == null) {
-        Platform.get().log(INFO,
-            "ALPN callback dropped: HTTP/2 is disabled. " + "Is alpn-boot on the boot class path?",
-            null)
+        log("ALPN callback dropped: HTTP/2 is disabled. " + "Is alpn-boot on the boot class path?")
         return null
       }
       return if (provider.unsupported) null else provider.selected
diff --git a/okhttp/src/main/java/okhttp3/internal/platform/Jdk9Platform.kt b/okhttp/src/main/java/okhttp3/internal/platform/Jdk9Platform.kt
index 6d6e1d1fcc..84d605bee3 100644
--- a/okhttp/src/main/java/okhttp3/internal/platform/Jdk9Platform.kt
+++ b/okhttp/src/main/java/okhttp3/internal/platform/Jdk9Platform.kt
@@ -15,50 +15,33 @@
  */
 package okhttp3.internal.platform
 
-import java.lang.reflect.InvocationTargetException
-import java.lang.reflect.Method
-import javax.net.ssl.SSLParameters
+import okhttp3.Protocol
 import javax.net.ssl.SSLSocket
 import javax.net.ssl.SSLSocketFactory
 import javax.net.ssl.X509TrustManager
-import okhttp3.Protocol
 
 /** OpenJDK 9+. */
-class Jdk9Platform(
-  @JvmField val setProtocolMethod: Method,
-  @JvmField val getProtocolMethod: Method
-) : Platform() {
+open class Jdk9Platform : Platform() {
   override fun configureTlsExtensions(
     sslSocket: SSLSocket,
-    hostname: String?,
-    protocols: List<Protocol>
+    protocols: List<@JvmSuppressWildcards Protocol>
   ) {
-    try {
-      val sslParameters = sslSocket.sslParameters
+    val sslParameters = sslSocket.sslParameters
 
-      val names = alpnProtocolNames(protocols)
+    val names = alpnProtocolNames(protocols)
 
-      setProtocolMethod.invoke(sslParameters, names.toTypedArray())
+    sslParameters.applicationProtocols = names.toTypedArray()
 
-      sslSocket.sslParameters = sslParameters
-    } catch (e: IllegalAccessException) {
-      throw AssertionError("failed to set SSL parameters", e)
-    } catch (e: InvocationTargetException) {
-      throw AssertionError("failed to set SSL parameters", e)
-    }
+    sslSocket.sslParameters = sslParameters
   }
 
-  override fun getSelectedProtocol(socket: SSLSocket): String? = try {
+  override fun getSelectedProtocol(sslSocket: SSLSocket): String? {
     // SSLSocket.getApplicationProtocol returns "" if application protocols values will not
     // be used. Observed if you didn't specify SSLParameters.setApplicationProtocols
-    when (val protocol = getProtocolMethod.invoke(socket) as String?) {
+    return when (val protocol = sslSocket.applicationProtocol) {
       null, "" -> null
       else -> protocol
     }
-  } catch (e: IllegalAccessException) {
-    throw AssertionError("failed to get ALPN selected protocol", e)
-  } catch (e: InvocationTargetException) {
-    throw AssertionError("failed to get ALPN selected protocol", e)
   }
 
   public override fun trustManager(sslSocketFactory: SSLSocketFactory): X509TrustManager? {
@@ -71,17 +54,13 @@ class Jdk9Platform(
   }
 
   companion object {
-    fun buildIfSupported(): Jdk9Platform? =
-        try {
-          // Find JDK 9 methods
-          val setProtocolMethod = SSLParameters::class.java.getMethod("setApplicationProtocols",
-              Array<String>::class.java)
-          val getProtocolMethod = SSLSocket::class.java.getMethod("getApplicationProtocol")
+    val isAvailable: Boolean
+
+    init {
+      val majorVersion: Int = Integer.getInteger("java.specification.version") ?: 8
+      isAvailable = majorVersion >= 9
+    }
 
-          Jdk9Platform(setProtocolMethod, getProtocolMethod)
-        } catch (_: NoSuchMethodException) {
-          // pre JDK 9
-          null
-        }
+    fun buildIfSupported(): Jdk9Platform? = if (isAvailable) Jdk9Platform() else null
   }
 }
diff --git a/okhttp/src/main/java/okhttp3/internal/platform/OpenJSSEPlatform.kt b/okhttp/src/main/java/okhttp3/internal/platform/OpenJSSEPlatform.kt
index bf80f22120..7e5f62810b 100644
--- a/okhttp/src/main/java/okhttp3/internal/platform/OpenJSSEPlatform.kt
+++ b/okhttp/src/main/java/okhttp3/internal/platform/OpenJSSEPlatform.kt
@@ -56,8 +56,7 @@ class OpenJSSEPlatform private constructor() : Platform() {
 
   override fun configureTlsExtensions(
     sslSocket: SSLSocket,
-    hostname: String?,
-    protocols: List<Protocol>
+    protocols: List<@JvmSuppressWildcards Protocol>
   ) {
     if (sslSocket is org.openjsse.javax.net.ssl.SSLSocket) {
       val sslParameters = sslSocket.sslParameters
@@ -70,7 +69,7 @@ class OpenJSSEPlatform private constructor() : Platform() {
         sslSocket.sslParameters = sslParameters
       }
     } else {
-      super.configureTlsExtensions(sslSocket, hostname, protocols)
+      super.configureTlsExtensions(sslSocket, protocols)
     }
   }
 
diff --git a/okhttp/src/main/java/okhttp3/internal/platform/Platform.kt b/okhttp/src/main/java/okhttp3/internal/platform/Platform.kt
index 99607dfa35..aa625412a8 100644
--- a/okhttp/src/main/java/okhttp3/internal/platform/Platform.kt
+++ b/okhttp/src/main/java/okhttp3/internal/platform/Platform.kt
@@ -40,26 +40,16 @@ import javax.net.ssl.X509TrustManager
 /**
  * Access to platform-specific features.
  *
- * ### Server name indication (SNI)
- *
- * Supported on Android 2.3+.
- *
- * Supported on OpenJDK 7+
- *
  * ### Session Tickets
  *
  * Supported on Android 2.3+.
- *
- * ### Android Traffic Stats (Socket Tagging)
- *
- * Supported on Android 4.0+.
+ * Supported on JDK 8+ via Conscrypt.
  *
  * ### ALPN (Application Layer Protocol Negotiation)
  *
- * Supported on Android 5.0+. The APIs were present in Android 4.4, but that implementation was
- * unstable.
+ * Supported on Android 5.0+.
  *
- * Supported on OpenJDK 8 via the JettyALPN-boot library.
+ * Supported on OpenJDK 8 via the JettyALPN-boot library or Conscrypt.
  *
  * Supported on OpenJDK 9+ via SSLParameters and SSLSocket features.
  *
@@ -68,6 +58,8 @@ import javax.net.ssl.X509TrustManager
  * Supported on Android 2.3+ and OpenJDK 7+. There are no public APIs to recover the trust
  * manager that was used to create an [SSLSocketFactory].
  *
+ * Not supported by choice on JDK9+ due to access checks.
+ *
  * ### Android Cleartext Permit Detection
  *
  * Supported on Android 6.0+ via `NetworkSecurityPolicy`.
@@ -105,12 +97,9 @@ open class Platform {
 
   /**
    * Configure TLS extensions on `sslSocket` for `route`.
-   *
-   * @param hostname non-null for client-side handshakes; null for server-side handshakes.
    */
   open fun configureTlsExtensions(
     sslSocket: SSLSocket,
-    hostname: String?,
     protocols: List<@JvmSuppressWildcards Protocol>
   ) {
   }
@@ -127,7 +116,7 @@ open class Platform {
     socket.connect(address, connectTimeout)
   }
 
-  open fun log(level: Int, message: String, t: Throwable?) {
+  open fun log(message: String, level: Int = INFO, t: Throwable? = null) {
     val logLevel = if (level == WARN) Level.WARNING else Level.INFO
     logger.log(logLevel, message, t)
   }
@@ -152,7 +141,7 @@ open class Platform {
       logMessage += " To see where this was allocated, set the OkHttpClient logger level to " +
           "FINE: Logger.getLogger(OkHttpClient.class.getName()).setLevel(Level.FINE);"
     }
-    log(WARN, logMessage, stackTrace as Throwable?)
+    log(logMessage, WARN, stackTrace as Throwable?)
   }
 
   open fun buildCertificateChainCleaner(trustManager: X509TrustManager): CertificateChainCleaner =
@@ -208,6 +197,12 @@ open class Platform {
 
     /** Attempt to match the host runtime to a capable Platform implementation. */
     private fun findPlatform(): Platform {
+      val android10 = Android10Platform.buildIfSupported()
+
+      if (android10 != null) {
+        return android10
+      }
+
       val android = AndroidPlatform.buildIfSupported()
 
       if (android != null) {
diff --git a/okhttp/src/main/java/okhttp3/internal/platform/android/Android10CertificateChainCleaner.kt b/okhttp/src/main/java/okhttp3/internal/platform/android/Android10CertificateChainCleaner.kt
new file mode 100644
index 0000000000..93bfb6690d
--- /dev/null
+++ b/okhttp/src/main/java/okhttp3/internal/platform/android/Android10CertificateChainCleaner.kt
@@ -0,0 +1,55 @@
+/*
+ * Copyright (C) 2019 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.internal.platform.android
+
+import android.net.http.X509TrustManagerExtensions
+import okhttp3.internal.tls.CertificateChainCleaner
+import java.security.cert.Certificate
+import java.security.cert.CertificateException
+import java.security.cert.X509Certificate
+import javax.net.ssl.SSLPeerUnverifiedException
+import javax.net.ssl.X509TrustManager
+
+/**
+ * Android Q+ implementation of CertificateChainCleaner using direct Android API calls.
+ *
+ * X509TrustManagerExtensions was added to Android in API 17 (Android 4.2, released in late 2012).
+ * This is the best way to get a clean chain on Android because it uses the same code as the TLS
+ * handshake.
+ */
+internal class Android10CertificateChainCleaner(
+  private val trustManager: X509TrustManager
+) : CertificateChainCleaner() {
+  val extensions = X509TrustManagerExtensions(trustManager)
+
+  @Suppress("UNCHECKED_CAST")
+  @Throws(SSLPeerUnverifiedException::class)
+  override
+  fun clean(chain: List<Certificate>, hostname: String): List<Certificate> {
+    val certificates = (chain as List<X509Certificate>).toTypedArray()
+    try {
+      return extensions.checkServerTrusted(certificates, "RSA", hostname)
+    } catch (ce: CertificateException) {
+      throw SSLPeerUnverifiedException(ce.message).apply { initCause(ce) }
+    }
+  }
+
+  override fun equals(other: Any?): Boolean =
+      other is Android10CertificateChainCleaner &&
+          other.trustManager === this.trustManager
+
+  override fun hashCode(): Int = System.identityHashCode(trustManager)
+}
\ No newline at end of file
diff --git a/okhttp/src/main/java/okhttp3/internal/platform/android/Android10SocketAdapter.kt b/okhttp/src/main/java/okhttp3/internal/platform/android/Android10SocketAdapter.kt
new file mode 100644
index 0000000000..5837a7843a
--- /dev/null
+++ b/okhttp/src/main/java/okhttp3/internal/platform/android/Android10SocketAdapter.kt
@@ -0,0 +1,69 @@
+/*
+ * Copyright (C) 2019 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.internal.platform.android
+
+import android.net.SSLCertificateSocketFactory
+import android.os.Build
+import okhttp3.Protocol
+import okhttp3.internal.platform.AndroidPlatform.Companion.isAndroid
+import okhttp3.internal.platform.Platform
+import javax.net.ssl.SSLSocket
+import javax.net.ssl.SSLSocketFactory
+import javax.net.ssl.X509TrustManager
+
+/**
+ * Simple non-reflection SocketAdapter for Android Q.
+ */
+class Android10SocketAdapter : SocketAdapter {
+  private val socketFactory =
+      SSLCertificateSocketFactory.getDefault(10000) as SSLCertificateSocketFactory
+
+  override fun trustManager(sslSocketFactory: SSLSocketFactory): X509TrustManager? = null
+
+  override fun matchesSocketFactory(sslSocketFactory: SSLSocketFactory): Boolean = false
+
+  override fun matchesSocket(sslSocket: SSLSocket): Boolean = sslSocket.javaClass.name.startsWith(
+      "com.android.org.conscrypt")
+
+  override fun isSupported(): Boolean = Companion.isSupported()
+
+  override fun getSelectedProtocol(sslSocket: SSLSocket): String? =
+      when (val protocol = sslSocket.applicationProtocol) {
+        null, "" -> null
+        else -> protocol
+      }
+
+  override fun configureTlsExtensions(
+    sslSocket: SSLSocket,
+    protocols: List<Protocol>
+  ) {
+    socketFactory.setUseSessionTickets(sslSocket, true)
+
+    val sslParameters = sslSocket.sslParameters
+
+    // Enable ALPN.
+    sslParameters.applicationProtocols = Platform.alpnProtocolNames(protocols).toTypedArray()
+
+    sslSocket.sslParameters = sslParameters
+  }
+
+  companion object {
+    fun buildIfSupported(): SocketAdapter? =
+        if (isSupported()) Android10SocketAdapter() else null
+
+    fun isSupported() = isAndroid && Build.VERSION.SDK_INT >= 29
+  }
+}
diff --git a/okhttp/src/main/java/okhttp3/internal/platform/android/AndroidCertificateChainCleaner.kt b/okhttp/src/main/java/okhttp3/internal/platform/android/AndroidCertificateChainCleaner.kt
new file mode 100644
index 0000000000..5e24c571d4
--- /dev/null
+++ b/okhttp/src/main/java/okhttp3/internal/platform/android/AndroidCertificateChainCleaner.kt
@@ -0,0 +1,71 @@
+/*
+ * Copyright (C) 2019 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.internal.platform.android
+
+import okhttp3.internal.tls.CertificateChainCleaner
+import java.lang.reflect.InvocationTargetException
+import java.lang.reflect.Method
+import java.security.cert.Certificate
+import java.security.cert.X509Certificate
+import javax.net.ssl.SSLPeerUnverifiedException
+import javax.net.ssl.X509TrustManager
+
+/**
+ * Legacy Android implementation of CertificateChainCleaner relying on reflection.
+ *
+ * X509TrustManagerExtensions was added to Android in API 17 (Android 4.2, released in late 2012).
+ * This is the best way to get a clean chain on Android because it uses the same code as the TLS
+ * handshake.
+ */
+internal class AndroidCertificateChainCleaner(
+  private val trustManager: X509TrustManager,
+  private val x509TrustManagerExtensions: Any,
+  private val checkServerTrusted: Method
+) : CertificateChainCleaner() {
+
+  @Suppress("UNCHECKED_CAST") // Reflection on List<Certificate>
+  @Throws(SSLPeerUnverifiedException::class)
+  override
+  fun clean(chain: List<Certificate>, hostname: String): List<Certificate> = try {
+    val certificates = (chain as List<X509Certificate>).toTypedArray()
+    checkServerTrusted.invoke(
+        x509TrustManagerExtensions, certificates, "RSA", hostname) as List<Certificate>
+  } catch (e: InvocationTargetException) {
+    throw SSLPeerUnverifiedException(e.message).apply { initCause(e) }
+  } catch (e: IllegalAccessException) {
+    throw AssertionError(e)
+  }
+
+  override fun equals(other: Any?): Boolean =
+      other is AndroidCertificateChainCleaner &&
+          other.trustManager === this.trustManager
+
+  override fun hashCode(): Int = System.identityHashCode(trustManager)
+
+  companion object {
+    fun build(trustManager: X509TrustManager): AndroidCertificateChainCleaner? = try {
+      val extensionsClass = Class.forName("android.net.http.X509TrustManagerExtensions")
+      val constructor = extensionsClass.getConstructor(X509TrustManager::class.java)
+      val extensions = constructor.newInstance(trustManager)
+      val checkServerTrusted = extensionsClass.getMethod(
+          "checkServerTrusted", Array<X509Certificate>::class.java, String::class.java,
+          String::class.java)
+      AndroidCertificateChainCleaner(trustManager, extensions, checkServerTrusted)
+    } catch (_: Exception) {
+      null
+    }
+  }
+}
\ No newline at end of file
diff --git a/okhttp/src/main/java/okhttp3/internal/platform/android/AndroidSocketAdapter.kt b/okhttp/src/main/java/okhttp3/internal/platform/android/AndroidSocketAdapter.kt
index 4ac9e4c0cf..e58cf78dae 100644
--- a/okhttp/src/main/java/okhttp3/internal/platform/android/AndroidSocketAdapter.kt
+++ b/okhttp/src/main/java/okhttp3/internal/platform/android/AndroidSocketAdapter.kt
@@ -32,7 +32,6 @@ open class AndroidSocketAdapter(private val sslSocketClass: Class<in SSLSocket>)
     SocketAdapter {
   private val setUseSessionTickets: Method =
       sslSocketClass.getDeclaredMethod("setUseSessionTickets", Boolean::class.javaPrimitiveType)
-  private val setHostname = sslSocketClass.getMethod("setHostname", String::class.java)
   private val getAlpnSelectedProtocol = sslSocketClass.getMethod("getAlpnSelectedProtocol")
   private val setAlpnProtocols =
       sslSocketClass.getMethod("setAlpnProtocols", ByteArray::class.java)
@@ -47,18 +46,13 @@ open class AndroidSocketAdapter(private val sslSocketClass: Class<in SSLSocket>)
 
   override fun configureTlsExtensions(
     sslSocket: SSLSocket,
-    hostname: String?,
     protocols: List<Protocol>
   ) {
     // No TLS extensions if the socket class is custom.
     if (matchesSocket(sslSocket)) {
       try {
-        // Enable SNI and session tickets.
-        if (hostname != null) {
-          setUseSessionTickets.invoke(sslSocket, true)
-          // This is SSLParameters.setServerNames() in API 24+.
-          setHostname.invoke(sslSocket, hostname)
-        }
+        // Enable session tickets.
+        setUseSessionTickets.invoke(sslSocket, true)
 
         // Enable ALPN.
         setAlpnProtocols.invoke(sslSocket,
diff --git a/okhttp/src/main/java/okhttp3/internal/platform/android/ConscryptSocketAdapter.kt b/okhttp/src/main/java/okhttp3/internal/platform/android/ConscryptSocketAdapter.kt
index 11f574b544..21b311d8a7 100644
--- a/okhttp/src/main/java/okhttp3/internal/platform/android/ConscryptSocketAdapter.kt
+++ b/okhttp/src/main/java/okhttp3/internal/platform/android/ConscryptSocketAdapter.kt
@@ -26,7 +26,7 @@ import javax.net.ssl.X509TrustManager
 /**
  * Simple non-reflection SocketAdapter for Conscrypt.
  */
-object ConscryptSocketAdapter : SocketAdapter {
+class ConscryptSocketAdapter : SocketAdapter {
   override fun trustManager(sslSocketFactory: SSLSocketFactory): X509TrustManager? = null
 
   override fun matchesSocketFactory(sslSocketFactory: SSLSocketFactory): Boolean = false
@@ -43,16 +43,12 @@ object ConscryptSocketAdapter : SocketAdapter {
 
   override fun configureTlsExtensions(
     sslSocket: SSLSocket,
-    hostname: String?,
     protocols: List<Protocol>
   ) {
     // No TLS extensions if the socket class is custom.
     if (matchesSocket(sslSocket)) {
-      // Enable SNI and session tickets.
-      if (hostname != null) {
-        Conscrypt.setUseSessionTickets(sslSocket, true)
-        Conscrypt.setHostname(sslSocket, hostname)
-      }
+      // Enable session tickets.
+      Conscrypt.setUseSessionTickets(sslSocket, true)
 
       // Enable ALPN.
       val names = Platform.alpnProtocolNames(protocols)
@@ -60,6 +56,8 @@ object ConscryptSocketAdapter : SocketAdapter {
     }
   }
 
-  fun buildIfSupported(): SocketAdapter? =
-      if (ConscryptPlatform.isSupported) ConscryptSocketAdapter else null
+  companion object {
+    fun buildIfSupported(): SocketAdapter? =
+        if (ConscryptPlatform.isSupported) ConscryptSocketAdapter() else null
+  }
 }
diff --git a/okhttp/src/main/java/okhttp3/internal/platform/android/DeferredSocketAdapter.kt b/okhttp/src/main/java/okhttp3/internal/platform/android/DeferredSocketAdapter.kt
index 87d1277f2e..b008e99c8a 100644
--- a/okhttp/src/main/java/okhttp3/internal/platform/android/DeferredSocketAdapter.kt
+++ b/okhttp/src/main/java/okhttp3/internal/platform/android/DeferredSocketAdapter.kt
@@ -39,10 +39,9 @@ class DeferredSocketAdapter(private val socketPackage: String) : SocketAdapter {
 
   override fun configureTlsExtensions(
     sslSocket: SSLSocket,
-    hostname: String?,
     protocols: List<Protocol>
   ) {
-    getDelegate(sslSocket)?.configureTlsExtensions(sslSocket, hostname, protocols)
+    getDelegate(sslSocket)?.configureTlsExtensions(sslSocket, protocols)
   }
 
   override fun getSelectedProtocol(sslSocket: SSLSocket): String? {
@@ -65,7 +64,7 @@ class DeferredSocketAdapter(private val socketPackage: String) : SocketAdapter {
         delegate = AndroidSocketAdapter(possibleClass)
       } catch (e: Exception) {
         Platform.get()
-            .log(Platform.WARN, "Failed to initialize DeferredSocketAdapter $socketPackage", e)
+            .log("Failed to initialize DeferredSocketAdapter $socketPackage", Platform.WARN, e)
       }
 
       initialized = true
diff --git a/okhttp/src/main/java/okhttp3/internal/platform/android/SocketAdapter.kt b/okhttp/src/main/java/okhttp3/internal/platform/android/SocketAdapter.kt
index 5555f1c695..66fb0611c6 100644
--- a/okhttp/src/main/java/okhttp3/internal/platform/android/SocketAdapter.kt
+++ b/okhttp/src/main/java/okhttp3/internal/platform/android/SocketAdapter.kt
@@ -28,7 +28,6 @@ interface SocketAdapter {
 
   open fun configureTlsExtensions(
     sslSocket: SSLSocket,
-    hostname: String?,
     protocols: List<Protocol>
   )
 
diff --git a/okhttp/src/main/java/okhttp3/internal/platform/android/util.kt b/okhttp/src/main/java/okhttp3/internal/platform/android/util.kt
index 4a3bf12e42..71a701232e 100644
--- a/okhttp/src/main/java/okhttp3/internal/platform/android/util.kt
+++ b/okhttp/src/main/java/okhttp3/internal/platform/android/util.kt
@@ -22,7 +22,10 @@ private const val MAX_LOG_LENGTH = 4000
 
 internal fun androidLog(level: Int, message: String, t: Throwable?) {
   var logMessage = message
-  val logLevel = if (level == Platform.WARN) Log.WARN else Log.DEBUG
+  val logLevel = when (level) {
+    Platform.WARN -> Log.WARN
+    else -> Log.DEBUG
+  }
   if (t != null) logMessage = logMessage + '\n'.toString() + Log.getStackTraceString(t)
 
   // Split by line, then ensure each line can fit into Log's maximum length.
diff --git a/okhttp/src/main/java/okhttp3/internal/proxy/NullProxySelector.kt b/okhttp/src/main/java/okhttp3/internal/proxy/NullProxySelector.kt
index d18d2eca31..40c0674146 100644
--- a/okhttp/src/main/java/okhttp3/internal/proxy/NullProxySelector.kt
+++ b/okhttp/src/main/java/okhttp3/internal/proxy/NullProxySelector.kt
@@ -24,7 +24,7 @@ import java.net.URI
 /**
  * A proxy selector that always returns the [Proxy.NO_PROXY].
  */
-open class NullProxySelector : ProxySelector() {
+object NullProxySelector : ProxySelector() {
   override fun select(uri: URI?): List<Proxy> {
     requireNotNull(uri) { "uri must not be null" }
     return listOf(Proxy.NO_PROXY)
diff --git a/okhttp/src/main/java/okhttp3/internal/publicsuffix/PublicSuffixDatabase.kt b/okhttp/src/main/java/okhttp3/internal/publicsuffix/PublicSuffixDatabase.kt
index 9021066066..8e4a4c367c 100644
--- a/okhttp/src/main/java/okhttp3/internal/publicsuffix/PublicSuffixDatabase.kt
+++ b/okhttp/src/main/java/okhttp3/internal/publicsuffix/PublicSuffixDatabase.kt
@@ -178,7 +178,7 @@ class PublicSuffixDatabase {
           Thread.interrupted() // Temporarily clear the interrupted state.
           interrupted = true
         } catch (e: IOException) {
-          Platform.get().log(Platform.WARN, "Failed to read public suffix list", e)
+          Platform.get().log("Failed to read public suffix list", Platform.WARN, e)
           return
         }
       }
diff --git a/okhttp/src/main/java/okhttp3/internal/ws/RealWebSocket.kt b/okhttp/src/main/java/okhttp3/internal/ws/RealWebSocket.kt
index c7feccef49..b93e1c233c 100644
--- a/okhttp/src/main/java/okhttp3/internal/ws/RealWebSocket.kt
+++ b/okhttp/src/main/java/okhttp3/internal/ws/RealWebSocket.kt
@@ -26,8 +26,9 @@ import okhttp3.Response
 import okhttp3.WebSocket
 import okhttp3.WebSocketListener
 import okhttp3.internal.closeQuietly
+import okhttp3.internal.concurrent.Task
+import okhttp3.internal.concurrent.TaskRunner
 import okhttp3.internal.connection.Exchange
-import okhttp3.internal.threadFactory
 import okhttp3.internal.ws.WebSocketProtocol.CLOSE_CLIENT_GOING_AWAY
 import okhttp3.internal.ws.WebSocketProtocol.CLOSE_MESSAGE_MAX
 import okhttp3.internal.ws.WebSocketProtocol.OPCODE_BINARY
@@ -45,13 +46,11 @@ import java.net.ProtocolException
 import java.net.SocketTimeoutException
 import java.util.ArrayDeque
 import java.util.Random
-import java.util.concurrent.ScheduledExecutorService
-import java.util.concurrent.ScheduledFuture
-import java.util.concurrent.ScheduledThreadPoolExecutor
 import java.util.concurrent.TimeUnit
 import java.util.concurrent.TimeUnit.MILLISECONDS
 
 class RealWebSocket(
+  taskRunner: TaskRunner,
   /** The application's original request unadulterated by web socket headers. */
   private val originalRequest: Request,
   internal val listener: WebSocketListener,
@@ -63,8 +62,8 @@ class RealWebSocket(
   /** Non-null for client web sockets. These can be canceled. */
   private var call: Call? = null
 
-  /** This runnable processes the outgoing queues. Call [runWriter] to after enqueueing. */
-  private val writerRunnable: Runnable
+  /** This task processes the outgoing queues. Call [runWriter] to after enqueueing. */
+  private var writerTask: Task? = null
 
   /** Null until this web socket is connected. Only accessed by the reader thread. */
   private var reader: WebSocketReader? = null
@@ -74,8 +73,11 @@ class RealWebSocket(
   /** Null until this web socket is connected. Note that messages may be enqueued before that. */
   private var writer: WebSocketWriter? = null
 
-  /** Null until this web socket is connected. Used for writes, pings, and close timeouts. */
-  private var executor: ScheduledExecutorService? = null
+  /** Used for writes, pings, and close timeouts. */
+  private var taskQueue = taskRunner.newQueue()
+
+  /** Names this web socket for observability and debugging. */
+  private var name: String? = null
 
   /**
    * The streams held by this web socket. This is non-null until all incoming messages have been
@@ -96,12 +98,6 @@ class RealWebSocket(
   /** True if we've enqueued a close frame. No further message frames will be enqueued. */
   private var enqueuedClose = false
 
-  /**
-   * When executed this will cancel this web socket. This future itself should be canceled if that
-   * is unnecessary because the web socket is already closed or canceled.
-   */
-  private var cancelFuture: ScheduledFuture<*>? = null
-
   /** The close code from the peer, or -1 if this web socket has not yet read a close frame. */
   private var receivedCloseCode = -1
 
@@ -129,14 +125,6 @@ class RealWebSocket(
     }
 
     this.key = ByteArray(16).apply { random.nextBytes(this) }.toByteString().base64()
-    this.writerRunnable = Runnable {
-      try {
-        while (writeOneFrame()) {
-        }
-      } catch (e: IOException) {
-        failWebSocket(e, null)
-      }
-    }
   }
 
   override fun request(): Request = originalRequest
@@ -224,12 +212,16 @@ class RealWebSocket(
   @Throws(IOException::class)
   fun initReaderAndWriter(name: String, streams: Streams) {
     synchronized(this) {
+      this.name = name
       this.streams = streams
       this.writer = WebSocketWriter(streams.client, streams.sink, random)
-      this.executor = ScheduledThreadPoolExecutor(1, threadFactory(name, false))
+      this.writerTask = WriterTask()
       if (pingIntervalMillis != 0L) {
-        executor!!.scheduleAtFixedRate(
-            PingRunnable(), pingIntervalMillis, pingIntervalMillis, MILLISECONDS)
+        val pingIntervalNanos = MILLISECONDS.toNanos(pingIntervalMillis)
+        taskQueue.schedule("$name ping", pingIntervalNanos) {
+          writePingFrame()
+          return@schedule pingIntervalNanos
+        }
       }
       if (messageAndCloseQueue.isNotEmpty()) {
         runWriter() // Send messages that were enqueued before we were connected.
@@ -265,18 +257,15 @@ class RealWebSocket(
 
   /** For testing: wait until the web socket's executor has terminated. */
   @Throws(InterruptedException::class)
-  fun awaitTermination(timeout: Int, timeUnit: TimeUnit) {
-    executor!!.awaitTermination(timeout.toLong(), timeUnit)
+  fun awaitTermination(timeout: Long, timeUnit: TimeUnit) {
+    taskQueue.awaitIdle(timeUnit.toNanos(timeout))
   }
 
   /** For testing: force this web socket to release its threads. */
   @Throws(InterruptedException::class)
   fun tearDown() {
-    if (cancelFuture != null) {
-      cancelFuture!!.cancel(false)
-    }
-    executor!!.shutdown()
-    executor!!.awaitTermination(10, TimeUnit.SECONDS)
+    taskQueue.shutdown()
+    taskQueue.awaitIdle(TimeUnit.SECONDS.toNanos(10L))
   }
 
   @Synchronized fun sentPingCount(): Int = sentPingCount
@@ -321,8 +310,7 @@ class RealWebSocket(
       if (enqueuedClose && messageAndCloseQueue.isEmpty()) {
         toClose = this.streams
         this.streams = null
-        if (cancelFuture != null) cancelFuture!!.cancel(false)
-        this.executor!!.shutdown()
+        this.taskQueue.shutdown()
       }
     }
 
@@ -405,7 +393,7 @@ class RealWebSocket(
 
   private fun runWriter() {
     assert(Thread.holdsLock(this))
-    executor?.execute(writerRunnable)
+    taskQueue.schedule(writerTask!!)
   }
 
   /**
@@ -445,11 +433,13 @@ class RealWebSocket(
           if (receivedCloseCode != -1) {
             streamsToClose = this.streams
             this.streams = null
-            this.executor!!.shutdown()
+            this.taskQueue.shutdown()
           } else {
             // When we request a graceful close also schedule a cancel of the web socket.
-            cancelFuture = executor!!.schedule(CancelRunnable(),
-                (messageOrClose as Close).cancelAfterCloseMillis, MILLISECONDS)
+            val cancelAfterCloseMillis = (messageOrClose as Close).cancelAfterCloseMillis
+            taskQueue.execute("$name cancel", MILLISECONDS.toNanos(cancelAfterCloseMillis)) {
+              cancel()
+            }
           }
         } else if (messageOrClose == null) {
           return false // The queue is exhausted.
@@ -487,12 +477,6 @@ class RealWebSocket(
     }
   }
 
-  private inner class PingRunnable : Runnable {
-    override fun run() {
-      writePingFrame()
-    }
-  }
-
   internal fun writePingFrame() {
     val writer: WebSocketWriter?
     val failedPing: Int
@@ -524,8 +508,7 @@ class RealWebSocket(
       failed = true
       streamsToClose = this.streams
       this.streams = null
-      cancelFuture?.cancel(false)
-      executor?.shutdown()
+      taskQueue.shutdown()
     }
 
     try {
@@ -552,9 +535,14 @@ class RealWebSocket(
     val sink: BufferedSink
   ) : Closeable
 
-  internal inner class CancelRunnable : Runnable {
-    override fun run() {
-      cancel()
+  private inner class WriterTask : Task("$name writer") {
+    override fun runOnce(): Long {
+      try {
+        if (writeOneFrame()) return 0L
+      } catch (e: IOException) {
+        failWebSocket(e, null)
+      }
+      return -1L
     }
   }
 
diff --git a/okhttp/src/test/java/okhttp3/CallKotlinTest.kt b/okhttp/src/test/java/okhttp3/CallKotlinTest.kt
index df7e3f2f89..f70e6c46ad 100644
--- a/okhttp/src/test/java/okhttp3/CallKotlinTest.kt
+++ b/okhttp/src/test/java/okhttp3/CallKotlinTest.kt
@@ -15,15 +15,21 @@
  */
 package okhttp3
 
+import okhttp3.MediaType.Companion.toMediaType
 import okhttp3.mockwebserver.MockResponse
 import okhttp3.mockwebserver.MockWebServer
 import okhttp3.testing.PlatformRule
+import okhttp3.tls.internal.TlsUtil.localhost
+import okio.BufferedSink
 import org.assertj.core.api.Assertions.assertThat
-import org.junit.Before
+import org.junit.Assert.assertEquals
+import org.junit.Assert.fail
 import org.junit.Rule
 import org.junit.Test
 import org.junit.rules.TestRule
 import org.junit.rules.Timeout
+import java.io.IOException
+import java.security.cert.X509Certificate
 import java.util.concurrent.TimeUnit
 
 class CallKotlinTest {
@@ -32,11 +38,8 @@ class CallKotlinTest {
   @JvmField @Rule val server = MockWebServer()
   @JvmField @Rule val clientTestRule = OkHttpClientTestRule()
 
-  private lateinit var client: OkHttpClient
-
-  @Before fun setUp() {
-    client = clientTestRule.newClient()
-  }
+  private var client = clientTestRule.newClient()
+  private val handshakeCertificates = localhost()
 
   @Test
   fun legalToExecuteTwiceCloning() {
@@ -56,4 +59,113 @@ class CallKotlinTest {
     assertThat("abc").isEqualTo(response1.body!!.string())
     assertThat("def").isEqualTo(response2.body!!.string())
   }
+
+  @Test
+  fun testMockWebserverRequest() {
+    enableTls()
+
+    server.enqueue(MockResponse().setBody("abc"))
+
+    val request = Request.Builder().url(server.url("/")).build()
+
+    val response = client.newCall(request).execute()
+
+    response.use {
+      assertEquals(200, response.code)
+      assertEquals("CN=localhost",
+          (response.handshake!!.peerCertificates.single() as X509Certificate).subjectDN.name)
+    }
+  }
+
+  private fun enableTls() {
+    client = client.newBuilder()
+        .sslSocketFactory(
+            handshakeCertificates.sslSocketFactory(), handshakeCertificates.trustManager)
+        .build()
+    server.useHttps(handshakeCertificates.sslSocketFactory(), false)
+  }
+
+  @Test
+  fun testHeadAfterPut() {
+    class ErringRequestBody : RequestBody() {
+      override fun contentType(): MediaType {
+        return "application/xml".toMediaType()
+      }
+
+      override fun writeTo(sink: BufferedSink) {
+        sink.writeUtf8("<el")
+        sink.flush()
+        throw IOException("failed to stream the XML")
+      }
+    }
+
+    class ValidRequestBody : RequestBody() {
+      override fun contentType(): MediaType {
+        return "application/xml".toMediaType()
+      }
+
+      override fun writeTo(sink: BufferedSink) {
+        sink.writeUtf8("<element/>")
+        sink.flush()
+      }
+    }
+
+    server.enqueue(MockResponse().apply {
+      setResponseCode(201)
+    })
+    server.enqueue(MockResponse().apply {
+      setResponseCode(204)
+    })
+    server.enqueue(MockResponse().apply {
+      setResponseCode(204)
+    })
+
+    val endpointUrl = server.url("/endpoint")
+
+    var request = Request.Builder()
+        .url(endpointUrl)
+        .header("Content-Type", "application/xml")
+        .put(ValidRequestBody())
+        .build()
+    // 201
+    client.newCall(request).execute()
+
+    request = Request.Builder()
+        .url(endpointUrl)
+        .head()
+        .build()
+    // 204
+    client.newCall(request).execute()
+
+    request = Request.Builder()
+        .url(endpointUrl)
+        .header("Content-Type", "application/xml")
+        .put(ErringRequestBody())
+        .build()
+    try {
+      client.newCall(request).execute()
+      fail("test should always throw exception")
+    } catch (_: IOException) {
+      // NOTE: expected
+    }
+
+    request = Request.Builder()
+        .url(endpointUrl)
+        .head()
+        .build()
+
+    client.newCall(request).execute()
+
+    var recordedRequest = server.takeRequest()
+    assertEquals("PUT", recordedRequest.method)
+
+    recordedRequest = server.takeRequest()
+    assertEquals("HEAD", recordedRequest.method)
+
+    recordedRequest = server.takeRequest()
+    assertThat(recordedRequest.failure).isNotNull()
+
+    recordedRequest = server.takeRequest()
+    assertEquals("HEAD", recordedRequest.method)
+  }
 }
diff --git a/okhttp/src/test/java/okhttp3/CallTest.java b/okhttp/src/test/java/okhttp3/CallTest.java
index cfe907a53b..b0eb67dffb 100644
--- a/okhttp/src/test/java/okhttp3/CallTest.java
+++ b/okhttp/src/test/java/okhttp3/CallTest.java
@@ -26,6 +26,7 @@
 import java.net.InetAddress;
 import java.net.ProtocolException;
 import java.net.Proxy;
+import java.net.SocketException;
 import java.net.SocketTimeoutException;
 import java.net.UnknownHostException;
 import java.net.UnknownServiceException;
@@ -110,7 +111,9 @@
 
   private RecordingEventListener listener = new RecordingEventListener();
   private HandshakeCertificates handshakeCertificates = localhost();
-  private OkHttpClient client;
+  private OkHttpClient client = clientTestRule.newClientBuilder()
+      .eventListener(listener)
+      .build();
   private RecordingCallback callback = new RecordingCallback();
   private TestLogHandler logHandler = new TestLogHandler();
   private Cache cache = new Cache(new File("/cache/"), Integer.MAX_VALUE, fileSystem);
@@ -120,9 +123,6 @@
     platform.assumeNotOpenJSSE();
 
     logger.addHandler(logHandler);
-    client = clientTestRule.newClientBuilder()
-        .eventListener(listener)
-        .build();
   }
 
   @After public void tearDown() throws Exception {
@@ -787,6 +787,63 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
     assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(2);
   }
 
+  /**
+   * Each OkHttpClient used to get its own instance of NullProxySelector, and because these weren't
+   * equal their connections weren't pooled. That's a nasty performance bug!
+   *
+   * https://github.com/square/okhttp/issues/5519
+   */
+  @Test public void connectionPoolingWithFreshClientSamePool() throws Exception {
+    server.enqueue(new MockResponse().setBody("abc"));
+    server.enqueue(new MockResponse().setBody("def"));
+    server.enqueue(new MockResponse().setBody("ghi"));
+
+    client = new OkHttpClient.Builder()
+        .connectionPool(client.connectionPool())
+        .proxy(server.toProxyAddress())
+        .build();
+    executeSynchronously("/a").assertBody("abc");
+
+    client = new OkHttpClient.Builder()
+        .connectionPool(client.connectionPool())
+        .proxy(server.toProxyAddress())
+        .build();
+    executeSynchronously("/b").assertBody("def");
+
+    client = new OkHttpClient.Builder()
+        .connectionPool(client.connectionPool())
+        .proxy(server.toProxyAddress())
+        .build();
+    executeSynchronously("/c").assertBody("ghi");
+
+    assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(0);
+    assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(1);
+    assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(2);
+  }
+
+  @Test public void connectionPoolingWithClientBuiltOffProxy() throws Exception {
+    client = new OkHttpClient.Builder()
+        .proxy(server.toProxyAddress())
+        .build();
+
+    server.enqueue(new MockResponse().setBody("abc"));
+    server.enqueue(new MockResponse().setBody("def"));
+    server.enqueue(new MockResponse().setBody("ghi"));
+
+    client = client.newBuilder().build();
+    executeSynchronously("/a").assertBody("abc");
+
+    client = client.newBuilder().build();
+    executeSynchronously("/b").assertBody("def");
+
+    client = client.newBuilder().build();
+    executeSynchronously("/c").assertBody("ghi");
+
+    assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(0);
+    assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(1);
+    assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(2);
+  }
+
   @Test public void connectionPooling_Async() throws Exception {
     server.enqueue(new MockResponse().setBody("abc"));
     server.enqueue(new MockResponse().setBody("def"));
@@ -900,7 +957,6 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
 
     server.enqueue(new MockResponse()
         .setBody("success!"));
-
     client = client.newBuilder()
         .proxySelector(proxySelector)
         .readTimeout(100, TimeUnit.MILLISECONDS)
@@ -940,12 +996,15 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
   }
 
   /** https://github.com/square/okhttp/issues/4761 */
-  @Test public void interceptorCallsProceedWithoutClosingPriorResponse() throws Exception {
+  @Test
+  public void interceptorCallsProceedWithoutClosingPriorResponse() throws Exception {
     server.enqueue(new MockResponse()
+        .setBodyDelay(250, TimeUnit.MILLISECONDS)
         .setBody("abc"));
-    server.enqueue(new MockResponse());
+    server.enqueue(new MockResponse()
+        .setBody("def"));
 
-    client = client.newBuilder()
+    client = clientTestRule.newClientBuilder()
         .addInterceptor(new Interceptor() {
           @Override public Response intercept(Chain chain) throws IOException {
             Response response = chain.proceed(chain.request());
@@ -964,8 +1023,7 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
         .url(server.url("/"))
         .build();
     executeSynchronously(request)
-        .assertCode(200)
-        .assertBody("abc");
+        .assertFailure(SocketException.class);
   }
 
   /**
@@ -1964,7 +2022,7 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
           }
 
           @Override public void writeTo(BufferedSink sink) throws IOException {
-            sink.writeUtf8("attempt " + (attempt++));
+            sink.writeUtf8("attempt " + attempt++);
           }
         })
         .build();
@@ -1995,7 +2053,7 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
           }
 
           @Override public void writeTo(BufferedSink sink) throws IOException {
-            sink.writeUtf8("attempt " + (attempt++));
+            sink.writeUtf8("attempt " + attempt++);
           }
 
           @Override public boolean isOneShot() {
@@ -2318,7 +2376,7 @@ private void cancelDuringConnect(String scheme) throws Exception {
     call.cancel();
     latch.countDown();
 
-    callback.await(server.url("/a")).assertFailure("Canceled", "Socket closed");
+    callback.await(server.url("/a")).assertFailure("Canceled", "Socket closed", "Socket is closed");
   }
 
   @Test public void cancelAll() throws Exception {
@@ -2327,7 +2385,7 @@ private void cancelDuringConnect(String scheme) throws Exception {
         .build());
     call.enqueue(callback);
     client.dispatcher().cancelAll();
-    callback.await(server.url("/")).assertFailure("Canceled", "Socket closed");
+    callback.await(server.url("/")).assertFailure("Canceled", "Socket closed", "Socket is closed");
   }
 
   @Test
@@ -2394,6 +2452,8 @@ public void cancelWhileRequestHeadersAreSent_HTTP_2() throws Exception {
       fail();
     } catch (IOException expected) {
     }
+
+    assertThat(server.takeRequest().getPath()).isEqualTo("/a");
   }
 
   @Test public void cancelInFlightBeforeResponseReadThrowsIOE_HTTPS() throws Exception {
@@ -3730,12 +3790,15 @@ private RequestBody requestBody(final boolean chunked, final long size, final in
           }
 
           @Override public void writeTo(BufferedSink sink) throws IOException {
+            sink.flush(); // For determinism, always send a partial request to the server.
             throw new IOException("boom");
           }
         })
         .build();
 
     executeSynchronously(request).assertFailure("boom");
+
+    assertThat(server.takeRequest().getFailure()).isNotNull();
   }
 
   @Test public void requestBodyThrowsUnrelatedToNetwork_HTTP2() throws Exception {
@@ -3783,6 +3846,7 @@ private void makeFailingCall() {
       }
 
       @Override public void writeTo(BufferedSink sink) throws IOException {
+        sink.flush(); // For determinism, always send a partial request to the server.
         throw new IOException("write body fail!");
       }
     };
diff --git a/okhttp/src/test/java/okhttp3/ConnectionReuseTest.java b/okhttp/src/test/java/okhttp3/ConnectionReuseTest.java
index a3445d7813..ea1a635f9e 100644
--- a/okhttp/src/test/java/okhttp3/ConnectionReuseTest.java
+++ b/okhttp/src/test/java/okhttp3/ConnectionReuseTest.java
@@ -24,7 +24,6 @@
 import okhttp3.mockwebserver.SocketPolicy;
 import okhttp3.testing.PlatformRule;
 import okhttp3.tls.HandshakeCertificates;
-import org.junit.Before;
 import org.junit.Rule;
 import org.junit.Test;
 import org.junit.rules.TestRule;
@@ -43,11 +42,7 @@
   @Rule public final OkHttpClientTestRule clientTestRule = new OkHttpClientTestRule();
 
   private HandshakeCertificates handshakeCertificates = localhost();
-  private OkHttpClient client;
-
-  @Before public void setUp() {
-    client = clientTestRule.newClient();
-  }
+  private OkHttpClient client = clientTestRule.newClient();
 
   @Test public void connectionsAreReused() throws Exception {
     server.enqueue(new MockResponse().setBody("a"));
diff --git a/okhttp/src/test/java/okhttp3/ConscryptTest.kt b/okhttp/src/test/java/okhttp3/ConscryptTest.kt
index 47381de1d0..b2a53ef0b9 100644
--- a/okhttp/src/test/java/okhttp3/ConscryptTest.kt
+++ b/okhttp/src/test/java/okhttp3/ConscryptTest.kt
@@ -35,11 +35,10 @@ class ConscryptTest {
 
   @JvmField @Rule val clientTestRule = OkHttpClientTestRule()
 
-  private lateinit var client: OkHttpClient
+  private val client = clientTestRule.newClient()
 
   @Before fun setUp() {
     platform.assumeConscrypt()
-    client = clientTestRule.newClient()
   }
 
   @Test
diff --git a/okhttp/src/test/java/okhttp3/CookiesTest.java b/okhttp/src/test/java/okhttp3/CookiesTest.java
index 758a0936cc..44ac99fd12 100644
--- a/okhttp/src/test/java/okhttp3/CookiesTest.java
+++ b/okhttp/src/test/java/okhttp3/CookiesTest.java
@@ -30,7 +30,6 @@
 import okhttp3.mockwebserver.MockResponse;
 import okhttp3.mockwebserver.MockWebServer;
 import okhttp3.mockwebserver.RecordedRequest;
-import org.junit.Before;
 import org.junit.Rule;
 import org.junit.Test;
 
@@ -45,11 +44,7 @@
   @Rule public final MockWebServer server = new MockWebServer();
   @Rule public final OkHttpClientTestRule clientTestRule = new OkHttpClientTestRule();
 
-  private OkHttpClient client;
-
-  @Before public void setUp() {
-    client = clientTestRule.newClient();
-  }
+  private OkHttpClient client = clientTestRule.newClient();
 
   @Test
   public void testNetscapeResponse() throws Exception {
diff --git a/okhttp/src/test/java/okhttp3/DelegatingSSLSession.java b/okhttp/src/test/java/okhttp3/DelegatingSSLSession.java
new file mode 100644
index 0000000000..0e15e825b9
--- /dev/null
+++ b/okhttp/src/test/java/okhttp3/DelegatingSSLSession.java
@@ -0,0 +1,116 @@
+/*
+ * Copyright 2019 Square Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3;
+
+import java.security.Principal;
+import java.security.cert.Certificate;
+import javax.net.ssl.SSLPeerUnverifiedException;
+import javax.net.ssl.SSLSession;
+import javax.net.ssl.SSLSessionContext;
+import javax.security.cert.X509Certificate;
+
+/** An {@link SSLSession} that delegates all calls. */
+public abstract class DelegatingSSLSession implements SSLSession {
+  protected final SSLSession delegate;
+
+  public DelegatingSSLSession(SSLSession delegate) {
+    this.delegate = delegate;
+  }
+
+  @Override public byte[] getId() {
+    return delegate.getId();
+  }
+
+  @Override public SSLSessionContext getSessionContext() {
+    return delegate.getSessionContext();
+  }
+
+  @Override public long getCreationTime() {
+    return delegate.getCreationTime();
+  }
+
+  @Override public long getLastAccessedTime() {
+    return delegate.getLastAccessedTime();
+  }
+
+  @Override public void invalidate() {
+    delegate.invalidate();
+  }
+
+  @Override public boolean isValid() {
+    return delegate.isValid();
+  }
+
+  @Override public void putValue(String s, Object o) {
+    delegate.putValue(s, o);
+  }
+
+  @Override public Object getValue(String s) {
+    return delegate.getValue(s);
+  }
+
+  @Override public void removeValue(String s) {
+    delegate.removeValue(s);
+  }
+
+  @Override public String[] getValueNames() {
+    return delegate.getValueNames();
+  }
+
+  @Override public Certificate[] getPeerCertificates() throws SSLPeerUnverifiedException {
+    return delegate.getPeerCertificates();
+  }
+
+  @Override public Certificate[] getLocalCertificates() {
+    return delegate.getLocalCertificates();
+  }
+
+  @Override public X509Certificate[] getPeerCertificateChain() throws SSLPeerUnverifiedException {
+    return delegate.getPeerCertificateChain();
+  }
+
+  @Override public Principal getPeerPrincipal() throws SSLPeerUnverifiedException {
+    return delegate.getPeerPrincipal();
+  }
+
+  @Override public Principal getLocalPrincipal() {
+    return delegate.getLocalPrincipal();
+  }
+
+  @Override public String getCipherSuite() {
+    return delegate.getCipherSuite();
+  }
+
+  @Override public String getProtocol() {
+    return delegate.getProtocol();
+  }
+
+  @Override public String getPeerHost() {
+    return delegate.getPeerHost();
+  }
+
+  @Override public int getPeerPort() {
+    return delegate.getPeerPort();
+  }
+
+  @Override public int getPacketBufferSize() {
+    return delegate.getPacketBufferSize();
+  }
+
+  @Override public int getApplicationBufferSize() {
+    return delegate.getApplicationBufferSize();
+  }
+}
diff --git a/okhttp/src/test/java/okhttp3/DelegatingSSLSocket.java b/okhttp/src/test/java/okhttp3/DelegatingSSLSocket.java
index 6647dfc4d9..8a772e7a1c 100644
--- a/okhttp/src/test/java/okhttp3/DelegatingSSLSocket.java
+++ b/okhttp/src/test/java/okhttp3/DelegatingSSLSocket.java
@@ -31,9 +31,7 @@
 import javax.net.ssl.SSLSession;
 import javax.net.ssl.SSLSocket;
 
-/**
- * An {@link javax.net.ssl.SSLSocket} that delegates all calls.
- */
+/** An {@link SSLSocket} that delegates all calls. */
 public abstract class DelegatingSSLSocket extends SSLSocket {
   protected final SSLSocket delegate;
 
diff --git a/okhttp/src/test/java/okhttp3/DispatcherTest.java b/okhttp/src/test/java/okhttp3/DispatcherTest.java
index 2a7c9a06b6..edcd981c8a 100644
--- a/okhttp/src/test/java/okhttp3/DispatcherTest.java
+++ b/okhttp/src/test/java/okhttp3/DispatcherTest.java
@@ -20,16 +20,15 @@
   RecordingWebSocketListener webSocketListener = new RecordingWebSocketListener();
   Dispatcher dispatcher = new Dispatcher(executor);
   RecordingEventListener listener = new RecordingEventListener();
-  OkHttpClient client;
+  OkHttpClient client = clientTestRule.newClientBuilder()
+      .dispatcher(dispatcher)
+      .eventListener(listener)
+      .build();
 
   @Before public void setUp() throws Exception {
     dispatcher.setMaxRequests(20);
     dispatcher.setMaxRequestsPerHost(10);
     listener.forbidLock(dispatcher);
-    client = clientTestRule.newClientBuilder()
-        .dispatcher(dispatcher)
-        .eventListener(listener)
-        .build();
   }
 
   @Test public void maxRequestsZero() throws Exception {
diff --git a/okhttp/src/test/java/okhttp3/DuplexTest.java b/okhttp/src/test/java/okhttp3/DuplexTest.java
index 7453035a96..d33b3e8b61 100644
--- a/okhttp/src/test/java/okhttp3/DuplexTest.java
+++ b/okhttp/src/test/java/okhttp3/DuplexTest.java
@@ -51,14 +51,13 @@
 
   private RecordingEventListener listener = new RecordingEventListener();
   private HandshakeCertificates handshakeCertificates = localhost();
-  private OkHttpClient client;
+  private OkHttpClient client = clientTestRule.newClientBuilder()
+      .eventListener(listener)
+      .build();
 
   @Before public void setUp() {
     platform.assumeNotOpenJSSE();
     platform.assumeHttp2Support();
-    client = clientTestRule.newClientBuilder()
-        .eventListener(listener)
-        .build();
   }
 
   @Test public void http1DoesntSupportDuplex() throws IOException {
diff --git a/okhttp/src/test/java/okhttp3/EventListenerTest.java b/okhttp/src/test/java/okhttp3/EventListenerTest.java
index d5f23f6031..f5a8fb3ae9 100644
--- a/okhttp/src/test/java/okhttp3/EventListenerTest.java
+++ b/okhttp/src/test/java/okhttp3/EventListenerTest.java
@@ -82,16 +82,14 @@
   private final RecordingEventListener listener = new RecordingEventListener();
   private final HandshakeCertificates handshakeCertificates = localhost();
 
-  private OkHttpClient client;
+  private OkHttpClient client = clientTestRule.newClientBuilder()
+      .eventListener(listener)
+      .build();
   private SocksProxy socksProxy;
 
   @Before public void setUp() {
     platform.assumeNotOpenJSSE();
 
-    client = clientTestRule.newClientBuilder()
-        .eventListener(listener)
-        .build();
-
     listener.forbidLock(RealConnectionPool.Companion.get(client.connectionPool()));
     listener.forbidLock(client.dispatcher());
   }
diff --git a/okhttp/src/test/java/okhttp3/HandshakeTest.kt b/okhttp/src/test/java/okhttp3/HandshakeTest.kt
new file mode 100644
index 0000000000..80e6bcc032
--- /dev/null
+++ b/okhttp/src/test/java/okhttp3/HandshakeTest.kt
@@ -0,0 +1,126 @@
+/*
+ * Copyright (C) 2019 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3
+
+import okhttp3.Handshake.Companion.handshake
+import okhttp3.tls.HeldCertificate
+import org.assertj.core.api.Assertions.assertThat
+import org.junit.Assert.fail
+import org.junit.Test
+import java.io.IOException
+import java.security.cert.Certificate
+
+class HandshakeTest {
+  val serverRoot = HeldCertificate.Builder()
+      .certificateAuthority(1)
+      .build()
+  val serverIntermediate = HeldCertificate.Builder()
+      .certificateAuthority(0)
+      .signedBy(serverRoot)
+      .build()
+  val serverCertificate = HeldCertificate.Builder()
+      .signedBy(serverIntermediate)
+      .build()
+
+  @Test
+  fun createFromParts() {
+    val handshake = Handshake.get(
+        tlsVersion = TlsVersion.TLS_1_3,
+        cipherSuite = CipherSuite.TLS_AES_128_GCM_SHA256,
+        peerCertificates = listOf(serverCertificate.certificate, serverIntermediate.certificate),
+        localCertificates = listOf()
+    )
+
+    assertThat(handshake.tlsVersion).isEqualTo(TlsVersion.TLS_1_3)
+    assertThat(handshake.cipherSuite).isEqualTo(CipherSuite.TLS_AES_128_GCM_SHA256)
+    assertThat(handshake.peerCertificates).containsExactly(
+        serverCertificate.certificate, serverIntermediate.certificate)
+    assertThat(handshake.localPrincipal).isNull()
+    assertThat(handshake.peerPrincipal)
+        .isEqualTo(serverCertificate.certificate.subjectX500Principal)
+    assertThat(handshake.localCertificates).isEmpty()
+  }
+
+  @Test
+  fun createFromSslSession() {
+    val sslSession = FakeSSLSession(
+        "TLSv1.3",
+        "TLS_AES_128_GCM_SHA256",
+        arrayOf(serverCertificate.certificate, serverIntermediate.certificate),
+        null
+    )
+
+    val handshake = sslSession.handshake()
+
+    assertThat(handshake.tlsVersion).isEqualTo(TlsVersion.TLS_1_3)
+    assertThat(handshake.cipherSuite).isEqualTo(CipherSuite.TLS_AES_128_GCM_SHA256)
+    assertThat(handshake.peerCertificates).containsExactly(
+        serverCertificate.certificate, serverIntermediate.certificate)
+    assertThat(handshake.localPrincipal).isNull()
+    assertThat(handshake.peerPrincipal)
+        .isEqualTo(serverCertificate.certificate.subjectX500Principal)
+    assertThat(handshake.localCertificates).isEmpty()
+  }
+
+  @Test
+  fun sslWithNullNullNull() {
+    val sslSession = FakeSSLSession(
+        "TLSv1.3",
+        "SSL_NULL_WITH_NULL_NULL",
+        arrayOf(serverCertificate.certificate, serverIntermediate.certificate),
+        null
+    )
+
+    try {
+      sslSession.handshake()
+      fail()
+    } catch (expected: IOException) {
+      assertThat(expected).hasMessage("cipherSuite == SSL_NULL_WITH_NULL_NULL")
+    }
+  }
+
+  @Test
+  fun tlsWithNullNullNull() {
+    val sslSession = FakeSSLSession(
+        "TLSv1.3",
+        "TLS_NULL_WITH_NULL_NULL",
+        arrayOf(serverCertificate.certificate, serverIntermediate.certificate),
+        null
+    )
+
+    try {
+      sslSession.handshake()
+      fail()
+    } catch (expected: IOException) {
+      assertThat(expected).hasMessage("cipherSuite == TLS_NULL_WITH_NULL_NULL")
+    }
+  }
+
+  class FakeSSLSession(
+    private val protocol: String,
+    private val cipherSuite: String,
+    private val peerCertificates: Array<Certificate>?,
+    private val localCertificates: Array<Certificate>?
+  ) : DelegatingSSLSession(null) {
+    override fun getProtocol() = protocol
+
+    override fun getCipherSuite() = cipherSuite
+
+    override fun getPeerCertificates() = peerCertificates
+
+    override fun getLocalCertificates() = localCertificates
+  }
+}
diff --git a/okhttp/src/test/java/okhttp3/InterceptorTest.java b/okhttp/src/test/java/okhttp3/InterceptorTest.java
index 5428f06acd..b85efb6bd5 100644
--- a/okhttp/src/test/java/okhttp3/InterceptorTest.java
+++ b/okhttp/src/test/java/okhttp3/InterceptorTest.java
@@ -39,7 +39,6 @@
 import okio.Okio;
 import okio.Sink;
 import okio.Source;
-import org.junit.Before;
 import org.junit.Rule;
 import org.junit.Test;
 
@@ -50,13 +49,9 @@
   @Rule public MockWebServer server = new MockWebServer();
   @Rule public final OkHttpClientTestRule clientTestRule = new OkHttpClientTestRule();
 
-  private OkHttpClient client;
+  private OkHttpClient client = clientTestRule.newClient();
   private RecordingCallback callback = new RecordingCallback();
 
-  @Before public void setUp() {
-    client = clientTestRule.newClient();
-  }
-
   @Test public void applicationInterceptorsCanShortCircuitResponses() throws Exception {
     server.shutdown(); // Accept no connections.
 
@@ -521,11 +516,12 @@ private void interceptorThrowsRuntimeExceptionSynchronous(boolean network) throw
   }
 
   /**
-   * When an interceptor throws an unexpected exception, asynchronous callers are left hanging. The
+   * When an interceptor throws an unexpected exception, asynchronous calls are canceled. The
    * exception goes to the uncaught exception handler.
    */
   private void interceptorThrowsRuntimeExceptionAsynchronous(boolean network) throws Exception {
-    addInterceptor(network, chain -> { throw new RuntimeException("boom!"); });
+    RuntimeException boom = new RuntimeException("boom!");
+    addInterceptor(network, chain -> { throw boom; });
 
     ExceptionCatchingExecutor executor = new ExceptionCatchingExecutor();
     client = client.newBuilder()
@@ -535,9 +531,15 @@ private void interceptorThrowsRuntimeExceptionAsynchronous(boolean network) thro
     Request request = new Request.Builder()
         .url(server.url("/"))
         .build();
-    client.newCall(request).enqueue(callback);
-
-    assertThat(executor.takeException().getMessage()).isEqualTo("boom!");
+    Call call = client.newCall(request);
+    call.enqueue(callback);
+    RecordedResponse recordedResponse = callback.await(server.url("/"));
+    assertThat(recordedResponse.failure)
+        .hasMessage("canceled due to java.lang.RuntimeException: boom!");
+    assertThat(recordedResponse.failure).hasSuppressedException(boom);
+    assertThat(call.isCanceled()).isTrue();
+
+    assertThat(executor.takeException()).isEqualTo(boom);
   }
 
   @Test public void applicationInterceptorReturnsNull() throws Exception {
diff --git a/okhttp/src/test/java/okhttp3/KotlinSourceModernTest.kt b/okhttp/src/test/java/okhttp3/KotlinSourceModernTest.kt
index 36d1da59b5..2d76da8ed8 100644
--- a/okhttp/src/test/java/okhttp3/KotlinSourceModernTest.kt
+++ b/okhttp/src/test/java/okhttp3/KotlinSourceModernTest.kt
@@ -847,7 +847,7 @@ class KotlinSourceModernTest {
     builder = builder.pingInterval(0L, TimeUnit.SECONDS)
     builder = builder.pingInterval(Duration.ofSeconds(0L))
     builder = builder.proxy(Proxy.NO_PROXY)
-    builder = builder.proxySelector(NullProxySelector())
+    builder = builder.proxySelector(NullProxySelector)
     builder = builder.cookieJar(CookieJar.NO_COOKIES)
     builder = builder.cache(Cache(File("/cache/"), Integer.MAX_VALUE.toLong()))
     builder = builder.dns(Dns.SYSTEM)
@@ -1150,7 +1150,7 @@ class KotlinSourceModernTest {
         Proxy.NO_PROXY,
         listOf(Protocol.HTTP_1_1),
         listOf(ConnectionSpec.MODERN_TLS),
-        NullProxySelector()
+        NullProxySelector
     )
   }
 
diff --git a/okhttp/src/test/java/okhttp3/OkHttpClientTest.java b/okhttp/src/test/java/okhttp3/OkHttpClientTest.java
index 1e4c4b84c4..421cdf12e8 100644
--- a/okhttp/src/test/java/okhttp3/OkHttpClientTest.java
+++ b/okhttp/src/test/java/okhttp3/OkHttpClientTest.java
@@ -284,7 +284,7 @@
       new OkHttpClient.Builder().protocols(protocols);
       fail();
     } catch (IllegalArgumentException expected) {
-      assertThat(expected.getMessage()).isEqualTo(("protocols must not contain null"));
+      assertThat(expected.getMessage()).isEqualTo("protocols must not contain null");
     }
   }
 
diff --git a/okhttp/src/test/java/okhttp3/OpenJSSETest.kt b/okhttp/src/test/java/okhttp3/OpenJSSETest.kt
index a992435760..8b4ac73922 100644
--- a/okhttp/src/test/java/okhttp3/OpenJSSETest.kt
+++ b/okhttp/src/test/java/okhttp3/OpenJSSETest.kt
@@ -36,13 +36,11 @@ class OpenJSSETest {
   @JvmField @Rule var platform = PlatformRule()
   @JvmField @Rule val clientTestRule = OkHttpClientTestRule()
   @JvmField @Rule val server = MockWebServer()
-  lateinit var client: OkHttpClient
+  var client = clientTestRule.newClient()
 
   @Before
   fun setUp() {
     platform.assumeOpenJSSE()
-
-    client = clientTestRule.newClient()
   }
 
   @Test
@@ -109,4 +107,4 @@ class OpenJSSETest {
         .build()
     server.useHttps(handshakeCertificates.sslSocketFactory(), false)
   }
-}
\ No newline at end of file
+}
diff --git a/okhttp/src/test/java/okhttp3/RecordedResponse.java b/okhttp/src/test/java/okhttp3/RecordedResponse.java
index 482d78179b..a33ec8dfb1 100644
--- a/okhttp/src/test/java/okhttp3/RecordedResponse.java
+++ b/okhttp/src/test/java/okhttp3/RecordedResponse.java
@@ -63,6 +63,7 @@ public RecordedResponse assertCode(int expectedCode) {
   }
 
   public RecordedResponse assertSuccessful() {
+    assertThat(failure).isNull();
     assertThat(response.isSuccessful()).isTrue();
     return this;
   }
diff --git a/okhttp/src/test/java/okhttp3/URLConnectionTest.java b/okhttp/src/test/java/okhttp3/URLConnectionTest.java
index 656122295c..230bf4495f 100644
--- a/okhttp/src/test/java/okhttp3/URLConnectionTest.java
+++ b/okhttp/src/test/java/okhttp3/URLConnectionTest.java
@@ -114,12 +114,11 @@
   @Rule public final OkHttpClientTestRule clientTestRule = new OkHttpClientTestRule();
 
   private HandshakeCertificates handshakeCertificates = localhost();
-  private OkHttpClient client;
+  private OkHttpClient client = clientTestRule.newClient();
   private @Nullable Cache cache;
 
   @Before public void setUp() {
     server.setProtocolNegotiationEnabled(false);
-    client = clientTestRule.newClient();
   }
 
   @After public void tearDown() throws Exception {
diff --git a/okhttp/src/test/java/okhttp3/WholeOperationTimeoutTest.java b/okhttp/src/test/java/okhttp3/WholeOperationTimeoutTest.java
index bf8b54343a..376642db16 100644
--- a/okhttp/src/test/java/okhttp3/WholeOperationTimeoutTest.java
+++ b/okhttp/src/test/java/okhttp3/WholeOperationTimeoutTest.java
@@ -25,7 +25,6 @@
 import okhttp3.mockwebserver.MockWebServer;
 import okhttp3.testing.Flaky;
 import okio.BufferedSink;
-import org.junit.Before;
 import org.junit.Rule;
 import org.junit.Test;
 
@@ -39,11 +38,7 @@
   @Rule public final MockWebServer server = new MockWebServer();
   @Rule public final OkHttpClientTestRule clientTestRule = new OkHttpClientTestRule();
 
-  private OkHttpClient client;
-
-  @Before public void setUp() {
-    client = clientTestRule.newClient();
-  }
+  private final OkHttpClient client = clientTestRule.newClient();
 
   @Test public void defaultConfigIsNoTimeout() throws Exception {
     Request request = new Request.Builder()
diff --git a/okhttp/src/test/java/okhttp3/internal/cache/DiskLruCacheTest.java b/okhttp/src/test/java/okhttp3/internal/cache/DiskLruCacheTest.java
index a37395f27b..9fe5131094 100644
--- a/okhttp/src/test/java/okhttp3/internal/cache/DiskLruCacheTest.java
+++ b/okhttp/src/test/java/okhttp3/internal/cache/DiskLruCacheTest.java
@@ -23,7 +23,8 @@
 import java.util.Iterator;
 import java.util.List;
 import java.util.NoSuchElementException;
-import java.util.concurrent.Executor;
+import okhttp3.internal.concurrent.TaskFaker;
+import okhttp3.internal.concurrent.TaskRunner;
 import okhttp3.internal.io.FaultyFileSystem;
 import okhttp3.internal.io.FileSystem;
 import okio.BufferedSink;
@@ -54,7 +55,8 @@
   private File cacheDir;
   private File journalFile;
   private File journalBkpFile;
-  private final TestExecutor executor = new TestExecutor();
+  private final TaskFaker taskFaker = new TaskFaker();
+  private final TaskRunner taskRunner = taskFaker.getTaskRunner();
 
   private DiskLruCache cache;
   private final Deque<DiskLruCache> toClose = new ArrayDeque<>();
@@ -64,7 +66,7 @@ private void createNewCache() throws IOException {
   }
 
   private void createNewCacheWithSize(int maxSize) throws IOException {
-    cache = new DiskLruCache(fileSystem, cacheDir, appVersion, 2, maxSize, executor);
+    cache = new DiskLruCache(fileSystem, cacheDir, appVersion, 2, maxSize, taskRunner);
     synchronized (cache) {
       cache.initialize();
     }
@@ -102,7 +104,7 @@ private void createNewCacheWithSize(int maxSize) throws IOException {
     fileSystem.setFaultyDelete(new File(cacheDir, "k1.0.tmp"), true);
     fileSystem.setFaultyDelete(cacheDir, true);
 
-    cache = new DiskLruCache(fileSystem, cacheDir, appVersion, 2, Integer.MAX_VALUE, executor);
+    cache = new DiskLruCache(fileSystem, cacheDir, appVersion, 2, Integer.MAX_VALUE, taskRunner);
     toClose.add(cache);
 
     try {
@@ -539,7 +541,7 @@ private void createNewCacheWithSize(int maxSize) throws IOException {
     set("b", "bb", "bbbb"); // size 6
     set("c", "c", "c"); // size 12
     cache.setMaxSize(10);
-    assertThat(executor.jobs.size()).isEqualTo(1);
+    assertThat(taskFaker.isIdle()).isFalse();
   }
 
   @Test public void evictOnInsert() throws Exception {
@@ -662,7 +664,7 @@ private void createNewCacheWithSize(int maxSize) throws IOException {
 
   @Test public void constructorDoesNotAllowZeroCacheSize() throws Exception {
     try {
-      DiskLruCache.Companion.create(fileSystem, cacheDir, appVersion, 2, 0);
+      new DiskLruCache(fileSystem, cacheDir, appVersion, 2, 0, taskRunner);
       fail();
     } catch (IllegalArgumentException expected) {
     }
@@ -670,7 +672,7 @@ private void createNewCacheWithSize(int maxSize) throws IOException {
 
   @Test public void constructorDoesNotAllowZeroValuesPerEntry() throws Exception {
     try {
-      DiskLruCache.Companion.create(fileSystem, cacheDir, appVersion, 0, 10);
+      new DiskLruCache(fileSystem, cacheDir, appVersion, 0, 10, taskRunner);
       fail();
     } catch (IllegalArgumentException expected) {
     }
@@ -690,18 +692,18 @@ private void createNewCacheWithSize(int maxSize) throws IOException {
   @Test public void rebuildJournalOnRepeatedReads() throws Exception {
     set("a", "a", "a");
     set("b", "b", "b");
-    while (executor.jobs.isEmpty()) {
+    while (taskFaker.isIdle()) {
       assertValue("a", "a", "a");
       assertValue("b", "b", "b");
     }
   }
 
   @Test public void rebuildJournalOnRepeatedEdits() throws Exception {
-    while (executor.jobs.isEmpty()) {
+    while (taskFaker.isIdle()) {
       set("a", "a", "a");
       set("b", "b", "b");
     }
-    executor.jobs.removeFirst().run();
+    taskFaker.runNextTask();
 
     // Sanity check that a rebuilt journal behaves normally.
     assertValue("a", "a", "a");
@@ -712,7 +714,7 @@ private void createNewCacheWithSize(int maxSize) throws IOException {
   @Test public void rebuildJournalOnRepeatedReadsWithOpenAndClose() throws Exception {
     set("a", "a", "a");
     set("b", "b", "b");
-    while (executor.jobs.isEmpty()) {
+    while (taskFaker.isIdle()) {
       assertValue("a", "a", "a");
       assertValue("b", "b", "b");
       cache.close();
@@ -722,7 +724,7 @@ private void createNewCacheWithSize(int maxSize) throws IOException {
 
   /** @see <a href="https://github.com/JakeWharton/DiskLruCache/issues/28">Issue #28</a> */
   @Test public void rebuildJournalOnRepeatedEditsWithOpenAndClose() throws Exception {
-    while (executor.jobs.isEmpty()) {
+    while (taskFaker.isIdle()) {
       set("a", "a", "a");
       set("b", "b", "b");
       cache.close();
@@ -731,14 +733,14 @@ private void createNewCacheWithSize(int maxSize) throws IOException {
   }
 
   @Test public void rebuildJournalFailurePreventsEditors() throws Exception {
-    while (executor.jobs.isEmpty()) {
+    while (taskFaker.isIdle()) {
       set("a", "a", "a");
       set("b", "b", "b");
     }
 
     // Cause the rebuild action to fail.
     fileSystem.setFaultyRename(new File(cacheDir, DiskLruCache.JOURNAL_FILE_BACKUP), true);
-    executor.jobs.removeFirst().run();
+    taskFaker.runNextTask();
 
     // Don't allow edits under any circumstances.
     assertThat(cache.edit("a")).isNull();
@@ -749,33 +751,33 @@ private void createNewCacheWithSize(int maxSize) throws IOException {
   }
 
   @Test public void rebuildJournalFailureIsRetried() throws Exception {
-    while (executor.jobs.isEmpty()) {
+    while (taskFaker.isIdle()) {
       set("a", "a", "a");
       set("b", "b", "b");
     }
 
     // Cause the rebuild action to fail.
     fileSystem.setFaultyRename(new File(cacheDir, DiskLruCache.JOURNAL_FILE_BACKUP), true);
-    executor.jobs.removeFirst().run();
+    taskFaker.runNextTask();
 
     // The rebuild is retried on cache hits and on cache edits.
     DiskLruCache.Snapshot snapshot = cache.get("b");
     snapshot.close();
     assertThat(cache.edit("d")).isNull();
-    assertThat(executor.jobs.size()).isEqualTo(2);
+    assertThat(taskFaker.isIdle()).isFalse();
 
     // On cache misses, no retry job is queued.
     assertThat(cache.get("c")).isNull();
-    assertThat(executor.jobs.size()).isEqualTo(2);
+    assertThat(taskFaker.isIdle()).isFalse();
 
     // Let the rebuild complete successfully.
     fileSystem.setFaultyRename(new File(cacheDir, DiskLruCache.JOURNAL_FILE_BACKUP), false);
-    executor.jobs.removeFirst().run();
+    taskFaker.runNextTask();
     assertJournalEquals("CLEAN a 1 1", "CLEAN b 1 1");
   }
 
   @Test public void rebuildJournalFailureWithInFlightEditors() throws Exception {
-    while (executor.jobs.isEmpty()) {
+    while (taskFaker.isIdle()) {
       set("a", "a", "a");
       set("b", "b", "b");
     }
@@ -785,7 +787,7 @@ private void createNewCacheWithSize(int maxSize) throws IOException {
 
     // Cause the rebuild action to fail.
     fileSystem.setFaultyRename(new File(cacheDir, DiskLruCache.JOURNAL_FILE_BACKUP), true);
-    executor.jobs.removeFirst().run();
+    taskFaker.runNextTask();
 
     // In-flight editors can commit and have their values retained.
     setString(commitEditor, 0, "c");
@@ -797,12 +799,12 @@ private void createNewCacheWithSize(int maxSize) throws IOException {
 
     // Let the rebuild complete successfully.
     fileSystem.setFaultyRename(new File(cacheDir, DiskLruCache.JOURNAL_FILE_BACKUP), false);
-    executor.jobs.removeFirst().run();
+    taskFaker.runNextTask();
     assertJournalEquals("CLEAN a 1 1", "CLEAN b 1 1", "DIRTY e", "CLEAN c 1 1");
   }
 
   @Test public void rebuildJournalFailureWithEditorsInFlightThenClose() throws Exception {
-    while (executor.jobs.isEmpty()) {
+    while (taskFaker.isIdle()) {
       set("a", "a", "a");
       set("b", "b", "b");
     }
@@ -812,7 +814,7 @@ private void createNewCacheWithSize(int maxSize) throws IOException {
 
     // Cause the rebuild action to fail.
     fileSystem.setFaultyRename(new File(cacheDir, DiskLruCache.JOURNAL_FILE_BACKUP), true);
-    executor.jobs.removeFirst().run();
+    taskFaker.runNextTask();
 
     setString(commitEditor, 0, "c");
     setString(commitEditor, 1, "c");
@@ -834,34 +836,34 @@ private void createNewCacheWithSize(int maxSize) throws IOException {
   }
 
   @Test public void rebuildJournalFailureAllowsRemovals() throws Exception {
-    while (executor.jobs.isEmpty()) {
+    while (taskFaker.isIdle()) {
       set("a", "a", "a");
       set("b", "b", "b");
     }
 
     // Cause the rebuild action to fail.
     fileSystem.setFaultyRename(new File(cacheDir, DiskLruCache.JOURNAL_FILE_BACKUP), true);
-    executor.jobs.removeFirst().run();
+    taskFaker.runNextTask();
 
     assertThat(cache.remove("a")).isTrue();
     assertAbsent("a");
 
     // Let the rebuild complete successfully.
     fileSystem.setFaultyRename(new File(cacheDir, DiskLruCache.JOURNAL_FILE_BACKUP), false);
-    executor.jobs.removeFirst().run();
+    taskFaker.runNextTask();
 
     assertJournalEquals("CLEAN b 1 1");
   }
 
   @Test public void rebuildJournalFailureWithRemovalThenClose() throws Exception {
-    while (executor.jobs.isEmpty()) {
+    while (taskFaker.isIdle()) {
       set("a", "a", "a");
       set("b", "b", "b");
     }
 
     // Cause the rebuild action to fail.
     fileSystem.setFaultyRename(new File(cacheDir, DiskLruCache.JOURNAL_FILE_BACKUP), true);
-    executor.jobs.removeFirst().run();
+    taskFaker.runNextTask();
 
     assertThat(cache.remove("a")).isTrue();
     assertAbsent("a");
@@ -878,14 +880,14 @@ private void createNewCacheWithSize(int maxSize) throws IOException {
   }
 
   @Test public void rebuildJournalFailureAllowsEvictAll() throws Exception {
-    while (executor.jobs.isEmpty()) {
+    while (taskFaker.isIdle()) {
       set("a", "a", "a");
       set("b", "b", "b");
     }
 
     // Cause the rebuild action to fail.
     fileSystem.setFaultyRename(new File(cacheDir, DiskLruCache.JOURNAL_FILE_BACKUP), true);
-    executor.jobs.removeFirst().run();
+    taskFaker.runNextTask();
 
     cache.evictAll();
 
@@ -906,18 +908,18 @@ private void createNewCacheWithSize(int maxSize) throws IOException {
   }
 
   @Test public void rebuildJournalFailureWithCacheTrim() throws Exception {
-    while (executor.jobs.isEmpty()) {
+    while (taskFaker.isIdle()) {
       set("a", "aa", "aa");
       set("b", "bb", "bb");
     }
 
     // Cause the rebuild action to fail.
     fileSystem.setFaultyRename(new File(cacheDir, DiskLruCache.JOURNAL_FILE_BACKUP), true);
-    executor.jobs.removeFirst().run();
+    taskFaker.runNextTask();
 
     // Trigger a job to trim the cache.
     cache.setMaxSize(4);
-    executor.jobs.removeFirst().run();
+    taskFaker.runNextTask();
 
     assertAbsent("a");
     assertValue("b", "bb", "bb");
@@ -978,7 +980,7 @@ private void createNewCacheWithSize(int maxSize) throws IOException {
   @Test public void openCreatesDirectoryIfNecessary() throws Exception {
     cache.close();
     File dir = tempDir.newFolder("testOpenCreatesDirectoryIfNecessary");
-    cache = DiskLruCache.Companion.create(fileSystem, dir, appVersion, 2, Integer.MAX_VALUE);
+    cache = new DiskLruCache(fileSystem, dir, appVersion, 2, Integer.MAX_VALUE, taskRunner);
     set("a", "a", "a");
     assertThat(fileSystem.exists(new File(dir, "a.0"))).isTrue();
     assertThat(fileSystem.exists(new File(dir, "a.1"))).isTrue();
@@ -1287,7 +1289,7 @@ private void createNewCacheWithSize(int maxSize) throws IOException {
 
   @Test public void isClosed_uninitializedCache() throws Exception {
     // Create an uninitialized cache.
-    cache = new DiskLruCache(fileSystem, cacheDir, appVersion, 2, Integer.MAX_VALUE, executor);
+    cache = new DiskLruCache(fileSystem, cacheDir, appVersion, 2, Integer.MAX_VALUE, taskRunner);
     toClose.add(cache);
 
     assertThat(cache.isClosed()).isFalse();
@@ -1309,7 +1311,7 @@ private void createNewCacheWithSize(int maxSize) throws IOException {
 
     // Confirm that the fault didn't corrupt entries stored before the fault was introduced.
     cache.close();
-    cache = new DiskLruCache(fileSystem, cacheDir, appVersion, 2, Integer.MAX_VALUE, executor);
+    cache = new DiskLruCache(fileSystem, cacheDir, appVersion, 2, Integer.MAX_VALUE, taskRunner);
     assertValue("a", "a", "a");
     assertValue("b", "b", "b");
     assertAbsent("c");
@@ -1337,7 +1339,7 @@ private void createNewCacheWithSize(int maxSize) throws IOException {
 
     // Confirm that the fault didn't corrupt entries stored before the fault was introduced.
     cache.close();
-    cache = new DiskLruCache(fileSystem, cacheDir, appVersion, 2, Integer.MAX_VALUE, executor);
+    cache = new DiskLruCache(fileSystem, cacheDir, appVersion, 2, Integer.MAX_VALUE, taskRunner);
     assertValue("a", "a", "a");
     assertValue("b", "b", "b");
     assertAbsent("c");
@@ -1361,7 +1363,7 @@ private void createNewCacheWithSize(int maxSize) throws IOException {
 
     // Confirm that the fault didn't corrupt entries stored before the fault was introduced.
     cache.close();
-    cache = new DiskLruCache(fileSystem, cacheDir, appVersion, 2, Integer.MAX_VALUE, executor);
+    cache = new DiskLruCache(fileSystem, cacheDir, appVersion, 2, Integer.MAX_VALUE, taskRunner);
     assertValue("a", "a", "a");
     assertValue("b", "b", "b");
     assertAbsent("c");
@@ -1379,20 +1381,20 @@ private void createNewCacheWithSize(int maxSize) throws IOException {
     // Confirm that the entry was still removed.
     fileSystem.setFaultyWrite(journalFile, false);
     cache.close();
-    cache = new DiskLruCache(fileSystem, cacheDir, appVersion, 2, Integer.MAX_VALUE, executor);
+    cache = new DiskLruCache(fileSystem, cacheDir, appVersion, 2, Integer.MAX_VALUE, taskRunner);
     assertAbsent("a");
     assertValue("b", "b", "b");
   }
 
   @Test public void cleanupTrimFailurePreventsNewEditors() throws Exception {
     cache.setMaxSize(8);
-    executor.jobs.pop();
+    taskFaker.runNextTask();
     set("a", "aa", "aa");
     set("b", "bb", "bbb");
 
     // Cause the cache trim job to fail.
     fileSystem.setFaultyDelete(new File(cacheDir, "a.0"), true);
-    executor.jobs.pop().run();
+    taskFaker.runNextTask();
 
     // Confirm that edits are prevented after a cache trim failure.
     assertThat(cache.edit("a")).isNull();
@@ -1405,36 +1407,36 @@ private void createNewCacheWithSize(int maxSize) throws IOException {
 
   @Test public void cleanupTrimFailureRetriedOnEditors() throws Exception {
     cache.setMaxSize(8);
-    executor.jobs.pop();
+    taskFaker.runNextTask();
     set("a", "aa", "aa");
     set("b", "bb", "bbb");
 
     // Cause the cache trim job to fail.
     fileSystem.setFaultyDelete(new File(cacheDir, "a.0"), true);
-    executor.jobs.pop().run();
+    taskFaker.runNextTask();
 
     // An edit should now add a job to clean up if the most recent trim failed.
     assertThat(cache.edit("b")).isNull();
-    executor.jobs.pop().run();
+    taskFaker.runNextTask();
 
     // Confirm a successful cache trim now allows edits.
     fileSystem.setFaultyDelete(new File(cacheDir, "a.0"), false);
     assertThat(cache.edit("c")).isNull();
-    executor.jobs.pop().run();
+    taskFaker.runNextTask();
     set("c", "cc", "cc");
     assertValue("c", "cc", "cc");
   }
 
   @Test public void cleanupTrimFailureWithInFlightEditor() throws Exception {
     cache.setMaxSize(8);
-    executor.jobs.pop();
+    taskFaker.runNextTask();
     set("a", "aa", "aaa");
     set("b", "bb", "bb");
     DiskLruCache.Editor inFlightEditor = cache.edit("c");
 
     // Cause the cache trim job to fail.
     fileSystem.setFaultyDelete(new File(cacheDir, "a.0"), true);
-    executor.jobs.pop().run();
+    taskFaker.runNextTask();
 
     // The in-flight editor can still write after a trim failure.
     setString(inFlightEditor, 0, "cc");
@@ -1443,19 +1445,19 @@ private void createNewCacheWithSize(int maxSize) throws IOException {
 
     // Confirm the committed values are present after a successful cache trim.
     fileSystem.setFaultyDelete(new File(cacheDir, "a.0"), false);
-    executor.jobs.pop().run();
+    taskFaker.runNextTask();
     assertValue("c", "cc", "cc");
   }
 
   @Test public void cleanupTrimFailureAllowsSnapshotReads() throws Exception {
     cache.setMaxSize(8);
-    executor.jobs.pop();
+    taskFaker.runNextTask();
     set("a", "aa", "aa");
     set("b", "bb", "bbb");
 
     // Cause the cache trim job to fail.
     fileSystem.setFaultyDelete(new File(cacheDir, "a.0"), true);
-    executor.jobs.pop().run();
+    taskFaker.runNextTask();
 
     // Confirm we still allow snapshot reads after a trim failure.
     assertValue("a", "aa", "aa");
@@ -1467,13 +1469,13 @@ private void createNewCacheWithSize(int maxSize) throws IOException {
 
   @Test public void cleanupTrimFailurePreventsSnapshotWrites() throws Exception {
     cache.setMaxSize(8);
-    executor.jobs.pop();
+    taskFaker.runNextTask();
     set("a", "aa", "aa");
     set("b", "bb", "bbb");
 
     // Cause the cache trim job to fail.
     fileSystem.setFaultyDelete(new File(cacheDir, "a.0"), true);
-    executor.jobs.pop().run();
+    taskFaker.runNextTask();
 
     // Confirm snapshot writes are prevented after a trim failure.
     DiskLruCache.Snapshot snapshot1 = cache.get("a");
@@ -1489,13 +1491,13 @@ private void createNewCacheWithSize(int maxSize) throws IOException {
 
   @Test public void evictAllAfterCleanupTrimFailure() throws Exception {
     cache.setMaxSize(8);
-    executor.jobs.pop();
+    taskFaker.runNextTask();
     set("a", "aa", "aa");
     set("b", "bb", "bbb");
 
     // Cause the cache trim job to fail.
     fileSystem.setFaultyDelete(new File(cacheDir, "a.0"), true);
-    executor.jobs.pop().run();
+    taskFaker.runNextTask();
 
     // Confirm we prevent edits after a trim failure.
     assertThat(cache.edit("c")).isNull();
@@ -1509,13 +1511,13 @@ private void createNewCacheWithSize(int maxSize) throws IOException {
 
   @Test public void manualRemovalAfterCleanupTrimFailure() throws Exception {
     cache.setMaxSize(8);
-    executor.jobs.pop();
+    taskFaker.runNextTask();
     set("a", "aa", "aa");
     set("b", "bb", "bbb");
 
     // Cause the cache trim job to fail.
     fileSystem.setFaultyDelete(new File(cacheDir, "a.0"), true);
-    executor.jobs.pop().run();
+    taskFaker.runNextTask();
 
     // Confirm we prevent edits after a trim failure.
     assertThat(cache.edit("c")).isNull();
@@ -1529,13 +1531,13 @@ private void createNewCacheWithSize(int maxSize) throws IOException {
 
   @Test public void flushingAfterCleanupTrimFailure() throws Exception {
     cache.setMaxSize(8);
-    executor.jobs.pop();
+    taskFaker.runNextTask();
     set("a", "aa", "aa");
     set("b", "bb", "bbb");
 
     // Cause the cache trim job to fail.
     fileSystem.setFaultyDelete(new File(cacheDir, "a.0"), true);
-    executor.jobs.pop().run();
+    taskFaker.runNextTask();
 
     // Confirm we prevent edits after a trim failure.
     assertThat(cache.edit("c")).isNull();
@@ -1549,13 +1551,13 @@ private void createNewCacheWithSize(int maxSize) throws IOException {
 
   @Test public void cleanupTrimFailureWithPartialSnapshot() throws Exception {
     cache.setMaxSize(8);
-    executor.jobs.pop();
+    taskFaker.runNextTask();
     set("a", "aa", "aa");
     set("b", "bb", "bbb");
 
     // Cause the cache trim to fail on the second value leaving a partial snapshot.
     fileSystem.setFaultyDelete(new File(cacheDir, "a.1"), true);
-    executor.jobs.pop().run();
+    taskFaker.runNextTask();
 
     // Confirm the partial snapshot is not returned.
     assertThat(cache.get("a")).isNull();
@@ -1565,7 +1567,7 @@ private void createNewCacheWithSize(int maxSize) throws IOException {
 
     // Confirm the partial snapshot is not returned after a successful trim.
     fileSystem.setFaultyDelete(new File(cacheDir, "a.1"), false);
-    executor.jobs.pop().run();
+    taskFaker.runNextTask();
     assertThat(cache.get("a")).isNull();
   }
 
@@ -1824,12 +1826,4 @@ private void copyFile(File from, File to) throws IOException {
     source.close();
     sink.close();
   }
-
-  private static class TestExecutor implements Executor {
-    final Deque<Runnable> jobs = new ArrayDeque<>();
-
-    @Override public void execute(Runnable command) {
-      jobs.addLast(command);
-    }
-  }
 }
diff --git a/okhttp/src/test/java/okhttp3/internal/concurrent/TaskFaker.kt b/okhttp/src/test/java/okhttp3/internal/concurrent/TaskFaker.kt
new file mode 100644
index 0000000000..2e3a960ba5
--- /dev/null
+++ b/okhttp/src/test/java/okhttp3/internal/concurrent/TaskFaker.kt
@@ -0,0 +1,177 @@
+/*
+ * Copyright (C) 2019 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.internal.concurrent
+
+import okhttp3.internal.notify
+import okhttp3.internal.wait
+import org.assertj.core.api.Assertions.assertThat
+import java.util.concurrent.Executors
+
+/**
+ * Runs a [TaskRunner] in a controlled environment so that everything is sequential and
+ * deterministic. All tasks are executed on-demand on the test thread by calls to [runTasks] and
+ * [advanceUntil].
+ */
+class TaskFaker {
+  /** Runnables scheduled for execution. These will execute tasks and perform scheduling. */
+  private val futureRunnables = mutableListOf<Runnable>()
+
+  /** Runnables currently executing. */
+  private val currentRunnables = mutableListOf<Runnable>()
+
+  /**
+   * Executor service for the runnables above. This executor service should never have more than two
+   * active threads: one for a currently-executing task and one for a currently-sleeping task.
+   */
+  private val executorService = Executors.newCachedThreadPool()
+
+  /** True if this task faker has ever had multiple tasks scheduled to run concurrently. */
+  var isParallel = false
+
+  /** Guarded by [taskRunner]. */
+  var nanoTime = 0L
+    private set
+
+  /** The thread currently waiting for time to advance. */
+  private var waitingThread: Thread? = null
+
+  /** Guarded by taskRunner. Time at which we should yield execution to a waiting runnable. */
+  private var waitingUntilTime = Long.MAX_VALUE
+
+  /** Total number of runnables executed. */
+  private var executedRunnableCount = 0
+
+  /** Stall once we've executed this many runnables. */
+  private var executedTaskLimit = Int.MAX_VALUE
+
+  /** A task runner that posts tasks to this fake. Tasks won't be executed until requested. */
+  val taskRunner: TaskRunner = TaskRunner(object : TaskRunner.Backend {
+    override fun beforeTask(taskRunner: TaskRunner) {
+      check(Thread.holdsLock(taskRunner))
+      while (executedRunnableCount >= executedTaskLimit) {
+        coordinatorWait(taskRunner, Long.MAX_VALUE)
+      }
+    }
+
+    override fun execute(runnable: Runnable) {
+      futureRunnables.add(runnable)
+    }
+
+    override fun nanoTime() = nanoTime
+
+    override fun coordinatorNotify(taskRunner: TaskRunner) {
+      check(Thread.holdsLock(taskRunner))
+      waitingUntilTime = nanoTime
+    }
+
+    override fun coordinatorWait(taskRunner: TaskRunner, nanos: Long) {
+      check(Thread.holdsLock(taskRunner))
+      check(waitingUntilTime == Long.MAX_VALUE)
+      check(waitingThread == null)
+
+      waitingThread = Thread.currentThread()
+      waitingUntilTime = if (nanos < Long.MAX_VALUE) nanoTime + nanos else Long.MAX_VALUE
+      try {
+        if (nanoTime < waitingUntilTime) {
+          // Stall because there's no work to do.
+          taskRunner.notify()
+          taskRunner.wait()
+        }
+      } finally {
+        waitingThread = null
+        waitingUntilTime = Long.MAX_VALUE
+      }
+    }
+  })
+
+  /** Runs all tasks that are ready without advancing the simulated clock. */
+  fun runTasks() {
+    advanceUntil(nanoTime)
+  }
+
+  /** Advance the simulated clock and run anything ready at the new time. */
+  fun advanceUntil(newTime: Long) {
+    check(!Thread.holdsLock(taskRunner))
+
+    synchronized(taskRunner) {
+      nanoTime = newTime
+
+      while (true) {
+        runRunnables(taskRunner)
+
+        if (waitingUntilTime <= nanoTime) {
+          // Let the coordinator do its business at the new time.
+          taskRunner.notify()
+          taskRunner.wait()
+        } else {
+          return
+        }
+      }
+    }
+  }
+
+  /** Returns true if anything was executed. */
+  private fun runRunnables(taskRunner: TaskRunner) {
+    check(Thread.holdsLock(taskRunner))
+
+    while (futureRunnables.isNotEmpty()) {
+      val runnable = futureRunnables.removeAt(0)
+      currentRunnables.add(runnable)
+      if (currentRunnables.size > 1) isParallel = true
+      executorService.execute(Runnable {
+        try {
+          runnable.run()
+        } finally {
+          currentRunnables.remove(runnable)
+          synchronized(taskRunner) {
+            taskRunner.notify()
+          }
+        }
+      })
+      taskRunner.wait() // Wait for the coordinator to stall.
+    }
+  }
+
+  fun assertNoMoreTasks() {
+    assertThat(futureRunnables).isEmpty()
+    assertThat(waitingUntilTime)
+        .withFailMessage("tasks are scheduled to run at $waitingUntilTime")
+        .isEqualTo(Long.MAX_VALUE)
+  }
+
+  fun interruptCoordinatorThread() {
+    check(!Thread.holdsLock(taskRunner))
+
+    synchronized(taskRunner) {
+      check(waitingThread != null) { "no thread currently waiting" }
+      waitingThread!!.interrupt()
+      taskRunner.wait() // Wait for the coordinator to stall.
+    }
+  }
+
+  /** Advances and runs up to one task. */
+  fun runNextTask() {
+    executedTaskLimit = executedRunnableCount + 1
+    try {
+      advanceUntil(nanoTime)
+    } finally {
+      executedTaskLimit = Int.MAX_VALUE
+    }
+  }
+
+  /** Returns true if no tasks have been scheduled. This runs the coordinator for confirmation. */
+  fun isIdle() = taskRunner.activeQueues().isEmpty()
+}
diff --git a/okhttp/src/test/java/okhttp3/internal/concurrent/TaskRunnerRealBackendTest.kt b/okhttp/src/test/java/okhttp3/internal/concurrent/TaskRunnerRealBackendTest.kt
new file mode 100644
index 0000000000..a762daf73d
--- /dev/null
+++ b/okhttp/src/test/java/okhttp3/internal/concurrent/TaskRunnerRealBackendTest.kt
@@ -0,0 +1,57 @@
+/*
+ * Copyright (C) 2019 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.internal.concurrent
+
+import okhttp3.internal.threadFactory
+import org.assertj.core.api.Assertions.assertThat
+import org.assertj.core.data.Offset
+import org.junit.Test
+import java.util.concurrent.LinkedBlockingDeque
+import java.util.concurrent.TimeUnit
+
+/**
+ * Integration test to confirm that [TaskRunner] works with a real backend. Business logic is all
+ * exercised by [TaskRunnerTest].
+ *
+ * This test is doing real sleeping with tolerances of 250 ms. Hopefully that's enough for even the
+ * busiest of CI servers.
+ */
+class TaskRunnerRealBackendTest {
+  private val backend = TaskRunner.RealBackend(threadFactory("TaskRunnerRealBackendTest", true))
+  private val taskRunner = TaskRunner(backend)
+  private val queue = taskRunner.newQueue()
+  private val log = LinkedBlockingDeque<String>()
+
+  @Test fun test() {
+    val t1 = System.nanoTime() / 1e6
+
+    val delays = mutableListOf(TimeUnit.MILLISECONDS.toNanos(1000), -1L)
+    queue.schedule("task", TimeUnit.MILLISECONDS.toNanos(750)) {
+      log.put("runOnce delays.size=${delays.size}")
+      return@schedule delays.removeAt(0)
+    }
+
+    assertThat(log.take()).isEqualTo("runOnce delays.size=2")
+    val t2 = System.nanoTime() / 1e6 - t1
+    assertThat(t2).isCloseTo(750.0, Offset.offset(250.0))
+
+    assertThat(log.take()).isEqualTo("runOnce delays.size=1")
+    val t3 = System.nanoTime() / 1e6 - t1
+    assertThat(t3).isCloseTo(1750.0, Offset.offset(250.0))
+
+    backend.shutdown()
+  }
+}
diff --git a/okhttp/src/test/java/okhttp3/internal/concurrent/TaskRunnerTest.kt b/okhttp/src/test/java/okhttp3/internal/concurrent/TaskRunnerTest.kt
new file mode 100644
index 0000000000..f6066b4cac
--- /dev/null
+++ b/okhttp/src/test/java/okhttp3/internal/concurrent/TaskRunnerTest.kt
@@ -0,0 +1,465 @@
+/*
+ * Copyright (C) 2019 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.internal.concurrent
+
+import org.assertj.core.api.Assertions.assertThat
+import org.junit.Assert.fail
+import org.junit.Test
+import java.util.concurrent.RejectedExecutionException
+
+class TaskRunnerTest {
+  private val taskFaker = TaskFaker()
+  private val taskRunner = taskFaker.taskRunner
+  private val log = mutableListOf<String>()
+  private val redQueue = taskRunner.newQueue()
+  private val blueQueue = taskRunner.newQueue()
+  private val greenQueue = taskRunner.newQueue()
+
+  @Test fun executeDelayed() {
+    redQueue.execute("task", 100L) {
+      log += "run@${taskFaker.nanoTime}"
+    }
+
+    taskFaker.advanceUntil(0L)
+    assertThat(log).containsExactly()
+
+    taskFaker.advanceUntil(99L)
+    assertThat(log).containsExactly()
+
+    taskFaker.advanceUntil(100L)
+    assertThat(log).containsExactly("run@100")
+
+    taskFaker.assertNoMoreTasks()
+  }
+
+  @Test fun executeRepeated() {
+    val delays = mutableListOf(50L, 150L, -1L)
+    redQueue.schedule("task", 100L) {
+      log += "run@${taskFaker.nanoTime}"
+      return@schedule delays.removeAt(0)
+    }
+
+    taskFaker.advanceUntil(0L)
+    assertThat(log).containsExactly()
+
+    taskFaker.advanceUntil(100L)
+    assertThat(log).containsExactly("run@100")
+
+    taskFaker.advanceUntil(150L)
+    assertThat(log).containsExactly("run@100", "run@150")
+
+    taskFaker.advanceUntil(299L)
+    assertThat(log).containsExactly("run@100", "run@150")
+
+    taskFaker.advanceUntil(300L)
+    assertThat(log).containsExactly("run@100", "run@150", "run@300")
+
+    taskFaker.assertNoMoreTasks()
+  }
+
+  /** Repeat with a delay of 200 but schedule with a delay of 50. The schedule wins. */
+  @Test fun executeScheduledEarlierReplacesRepeatedLater() {
+    val task = object : Task("task") {
+      val schedules = mutableListOf(50L)
+      val delays = mutableListOf(200L, -1L)
+      override fun runOnce(): Long {
+        log += "run@${taskFaker.nanoTime}"
+        if (schedules.isNotEmpty()) {
+          redQueue.schedule(this, schedules.removeAt(0))
+        }
+        return delays.removeAt(0)
+      }
+    }
+    redQueue.schedule(task, 100L)
+
+    taskFaker.advanceUntil(0L)
+    assertThat(log).isEmpty()
+
+    taskFaker.advanceUntil(100L)
+    assertThat(log).containsExactly("run@100")
+
+    taskFaker.advanceUntil(150L)
+    assertThat(log).containsExactly("run@100", "run@150")
+
+    taskFaker.assertNoMoreTasks()
+  }
+
+  /** Schedule with a delay of 200 but repeat with a delay of 50. The repeat wins. */
+  @Test fun executeRepeatedEarlierReplacesScheduledLater() {
+    val task = object : Task("task") {
+      val schedules = mutableListOf(200L)
+      val delays = mutableListOf(50L, -1L)
+      override fun runOnce(): Long {
+        log += "run@${taskFaker.nanoTime}"
+        if (schedules.isNotEmpty()) {
+          redQueue.schedule(this, schedules.removeAt(0))
+        }
+        return delays.removeAt(0)
+      }
+    }
+    redQueue.schedule(task, 100L)
+
+    taskFaker.advanceUntil(0L)
+    assertThat(log).isEmpty()
+
+    taskFaker.advanceUntil(100L)
+    assertThat(log).containsExactly("run@100")
+
+    taskFaker.advanceUntil(150L)
+    assertThat(log).containsExactly("run@100", "run@150")
+
+    taskFaker.assertNoMoreTasks()
+  }
+
+  @Test fun cancelReturnsTruePreventsNextExecution() {
+    redQueue.execute("task", 100L) {
+      log += "run@${taskFaker.nanoTime}"
+    }
+
+    taskFaker.advanceUntil(0L)
+    assertThat(log).isEmpty()
+
+    redQueue.cancelAll()
+
+    taskFaker.advanceUntil(99L)
+    assertThat(log).isEmpty()
+
+    taskFaker.assertNoMoreTasks()
+  }
+
+  @Test fun cancelReturnsFalseDoesNotCancel() {
+    redQueue.schedule(object : Task("task", cancelable = false) {
+      override fun runOnce(): Long {
+        log += "run@${taskFaker.nanoTime}"
+        return -1L
+      }
+    }, 100L)
+
+    taskFaker.advanceUntil(0L)
+    assertThat(log).isEmpty()
+
+    redQueue.cancelAll()
+
+    taskFaker.advanceUntil(99L)
+    assertThat(log).isEmpty()
+
+    taskFaker.advanceUntil(100L)
+    assertThat(log).containsExactly("run@100")
+
+    taskFaker.assertNoMoreTasks()
+  }
+
+  @Test fun cancelWhileExecutingPreventsRepeat() {
+    redQueue.schedule("task", 100L) {
+      log += "run@${taskFaker.nanoTime}"
+      redQueue.cancelAll()
+      return@schedule 100L
+    }
+
+    taskFaker.advanceUntil(0L)
+    assertThat(log).isEmpty()
+
+    taskFaker.advanceUntil(100L)
+    assertThat(log).containsExactly("run@100")
+
+    taskFaker.assertNoMoreTasks()
+  }
+
+  @Test fun cancelWhileExecutingDoesNothingIfTaskDoesNotRepeat() {
+    redQueue.execute("task", 100L) {
+      log += "run@${taskFaker.nanoTime}"
+      redQueue.cancelAll()
+    }
+
+    taskFaker.advanceUntil(0L)
+    assertThat(log).isEmpty()
+
+    taskFaker.advanceUntil(100L)
+    assertThat(log).containsExactly("run@100")
+
+    taskFaker.assertNoMoreTasks()
+  }
+
+  @Test fun cancelWhileExecutingDoesNotStopUncancelableTask() {
+    redQueue.schedule(object : Task("task", cancelable = false) {
+      val delays = mutableListOf(50L, -1L)
+      override fun runOnce(): Long {
+        log += "run@${taskFaker.nanoTime}"
+        redQueue.cancelAll()
+        return delays.removeAt(0)
+      }
+    }, 100L)
+
+    taskFaker.advanceUntil(0L)
+    assertThat(log).isEmpty()
+
+    taskFaker.advanceUntil(100L)
+    assertThat(log).containsExactly("run@100")
+
+    taskFaker.advanceUntil(150L)
+    assertThat(log).containsExactly("run@100", "run@150")
+
+    taskFaker.assertNoMoreTasks()
+  }
+
+  @Test fun interruptingCoordinatorAttemptsToCancelsAndSucceeds() {
+    redQueue.execute("task", 100L) {
+      log += "run@${taskFaker.nanoTime}"
+    }
+
+    taskFaker.advanceUntil(0L)
+    assertThat(log).isEmpty()
+
+    taskFaker.interruptCoordinatorThread()
+
+    taskFaker.advanceUntil(0L)
+    assertThat(log).isEmpty()
+
+    taskFaker.assertNoMoreTasks()
+  }
+
+  @Test fun interruptingCoordinatorAttemptsToCancelsAndFails() {
+    redQueue.schedule(object : Task("task", cancelable = false) {
+      override fun runOnce(): Long {
+        log += "run@${taskFaker.nanoTime}"
+        return -1L
+      }
+    }, 100L)
+
+    taskFaker.advanceUntil(0L)
+    assertThat(log).isEmpty()
+
+    taskFaker.interruptCoordinatorThread()
+
+    taskFaker.advanceUntil(0L)
+    assertThat(log).isEmpty()
+
+    taskFaker.advanceUntil(100L)
+    assertThat(log).containsExactly("run@100")
+
+    taskFaker.assertNoMoreTasks()
+  }
+
+  /** Inspect how many runnables have been enqueued. If none then we're truly sequential. */
+  @Test fun singleQueueIsSerial() {
+    redQueue.execute("task one", 100L) {
+      log += "one:run@${taskFaker.nanoTime} parallel=${taskFaker.isParallel}"
+    }
+
+    redQueue.execute("task two", 100L) {
+      log += "two:run@${taskFaker.nanoTime} parallel=${taskFaker.isParallel}"
+    }
+
+    redQueue.execute("task three", 100L) {
+      log += "three:run@${taskFaker.nanoTime} parallel=${taskFaker.isParallel}"
+    }
+
+    taskFaker.advanceUntil(0L)
+    assertThat(log).isEmpty()
+
+    taskFaker.advanceUntil(100L)
+    assertThat(log).containsExactly(
+        "one:run@100 parallel=false",
+        "two:run@100 parallel=false",
+        "three:run@100 parallel=false"
+    )
+
+    taskFaker.assertNoMoreTasks()
+  }
+
+  /** Inspect how many runnables have been enqueued. If non-zero then we're truly parallel. */
+  @Test fun differentQueuesAreParallel() {
+    redQueue.execute("task one", 100L) {
+      log += "one:run@${taskFaker.nanoTime} parallel=${taskFaker.isParallel}"
+    }
+
+    blueQueue.execute("task two", 100L) {
+      log += "two:run@${taskFaker.nanoTime} parallel=${taskFaker.isParallel}"
+    }
+
+    greenQueue.execute("task three", 100L) {
+      log += "three:run@${taskFaker.nanoTime} parallel=${taskFaker.isParallel}"
+    }
+
+    taskFaker.advanceUntil(0L)
+    assertThat(log).isEmpty()
+
+    taskFaker.advanceUntil(100L)
+    assertThat(log).containsExactly(
+        "one:run@100 parallel=true",
+        "two:run@100 parallel=true",
+        "three:run@100 parallel=true"
+    )
+
+    taskFaker.assertNoMoreTasks()
+  }
+
+  /** Test the introspection method [TaskQueue.scheduledTasks]. */
+  @Test fun scheduledTasks() {
+    redQueue.execute("task one", 100L) {
+      // Do nothing.
+    }
+
+    redQueue.execute("task two", 200L) {
+      // Do nothing.
+    }
+
+    assertThat(redQueue.scheduledTasks.toString()).isEqualTo("[task one, task two]")
+  }
+
+  /**
+   * We don't track the active task in scheduled tasks. This behavior might be a mistake, but it's
+   * cumbersome to implement properly because the active task might be a cancel.
+   */
+  @Test fun scheduledTasksDoesNotIncludeRunningTask() {
+    val task = object : Task("task one") {
+      val schedules = mutableListOf(200L)
+      override fun runOnce(): Long {
+        if (schedules.isNotEmpty()) {
+          redQueue.schedule(this, schedules.removeAt(0)) // Add it at the end also.
+        }
+        log += "scheduledTasks=${redQueue.scheduledTasks}"
+        return -1L
+      }
+    }
+    redQueue.schedule(task, 100L)
+
+    redQueue.execute("task two", 200L) {
+      log += "scheduledTasks=${redQueue.scheduledTasks}"
+    }
+
+    taskFaker.advanceUntil(100L)
+    assertThat(log).containsExactly(
+        "scheduledTasks=[task two, task one]"
+    )
+
+    taskFaker.advanceUntil(200L)
+    assertThat(log).containsExactly(
+        "scheduledTasks=[task two, task one]",
+        "scheduledTasks=[task one]"
+    )
+
+    taskFaker.advanceUntil(300L)
+    assertThat(log).containsExactly(
+        "scheduledTasks=[task two, task one]",
+        "scheduledTasks=[task one]",
+        "scheduledTasks=[]"
+    )
+
+    taskFaker.assertNoMoreTasks()
+  }
+
+  /**
+   * The runner doesn't hold references to its queues! Otherwise we'd need a mechanism to clean them
+   * up when they're no longer needed and that's annoying. Instead the task runner only tracks which
+   * queues have work scheduled.
+   */
+  @Test fun activeQueuesContainsOnlyQueuesWithScheduledTasks() {
+    redQueue.execute("task one", 100L) {
+      // Do nothing.
+    }
+
+    blueQueue.execute("task two", 200L) {
+      // Do nothing.
+    }
+
+    taskFaker.advanceUntil(0L)
+    assertThat(taskRunner.activeQueues()).containsExactly(redQueue, blueQueue)
+
+    taskFaker.advanceUntil(100L)
+    assertThat(taskRunner.activeQueues()).containsExactly(blueQueue)
+
+    taskFaker.advanceUntil(200L)
+    assertThat(taskRunner.activeQueues()).isEmpty()
+
+    taskFaker.assertNoMoreTasks()
+  }
+
+  @Test fun taskNameIsUsedForThreadNameWhenRunning() {
+    redQueue.execute("lucky task") {
+      log += "run threadName:${Thread.currentThread().name}"
+    }
+
+    taskFaker.advanceUntil(0L)
+    assertThat(log).containsExactly("run threadName:lucky task")
+
+    taskFaker.assertNoMoreTasks()
+  }
+
+  @Test fun shutdownSuccessfullyCancelsScheduledTasks() {
+    redQueue.execute("task", 100L) {
+      log += "run@${taskFaker.nanoTime}"
+    }
+
+    taskFaker.advanceUntil(0L)
+    assertThat(log).isEmpty()
+
+    redQueue.shutdown()
+
+    taskFaker.advanceUntil(99L)
+    assertThat(log).isEmpty()
+
+    taskFaker.assertNoMoreTasks()
+  }
+
+  @Test fun shutdownFailsToCancelsScheduledTasks() {
+    redQueue.schedule(object : Task("task", false) {
+      override fun runOnce(): Long {
+        log += "run@${taskFaker.nanoTime}"
+        return 50L
+      }
+    }, 100L)
+
+    taskFaker.advanceUntil(0L)
+    assertThat(log).isEmpty()
+
+    redQueue.shutdown()
+
+    taskFaker.advanceUntil(99L)
+    assertThat(log).isEmpty()
+
+    taskFaker.advanceUntil(100L)
+    assertThat(log).containsExactly("run@100")
+
+    taskFaker.assertNoMoreTasks()
+  }
+
+  @Test fun scheduleDiscardsTaskWhenShutdown() {
+    redQueue.shutdown()
+
+    redQueue.execute("task", 100L) {
+      // Do nothing.
+    }
+
+    taskFaker.assertNoMoreTasks()
+  }
+
+  @Test fun scheduleThrowsWhenShutdown() {
+    redQueue.shutdown()
+
+    try {
+      redQueue.schedule(object : Task("task", cancelable = false) {
+        override fun runOnce(): Long {
+          return -1L
+        }
+      }, 100L)
+      fail()
+    } catch (_: RejectedExecutionException) {
+    }
+
+    taskFaker.assertNoMoreTasks()
+  }
+}
diff --git a/okhttp/src/test/java/okhttp3/internal/connection/ConnectionPoolTest.java b/okhttp/src/test/java/okhttp3/internal/connection/ConnectionPoolTest.java
index e9908f89f2..06e92889c5 100644
--- a/okhttp/src/test/java/okhttp3/internal/connection/ConnectionPoolTest.java
+++ b/okhttp/src/test/java/okhttp3/internal/connection/ConnectionPoolTest.java
@@ -30,12 +30,16 @@
 import okhttp3.Request;
 import okhttp3.Route;
 import okhttp3.internal.RecordingOkAuthenticator;
+import okhttp3.internal.concurrent.TaskFaker;
+import okhttp3.internal.concurrent.TaskRunner;
 import org.junit.Test;
 
 import static okhttp3.TestUtil.awaitGarbageCollection;
 import static org.assertj.core.api.Assertions.assertThat;
 
 public final class ConnectionPoolTest {
+  /** The fake task runner prevents the cleanup runnable from being started. */
+  private final TaskRunner taskRunner = new TaskFaker().getTaskRunner();
   private final Address addressA = newAddress("a");
   private final Route routeA1 = newRoute(addressA);
   private final Address addressB = newAddress("b");
@@ -44,8 +48,8 @@
   private final Route routeC1 = newRoute(addressC);
 
   @Test public void connectionsEvictedWhenIdleLongEnough() throws Exception {
-    RealConnectionPool pool = new RealConnectionPool(Integer.MAX_VALUE, 100L, TimeUnit.NANOSECONDS);
-    pool.setCleanupRunning(true); // Prevent the cleanup runnable from being started.
+    RealConnectionPool pool = new RealConnectionPool(
+        taskRunner, Integer.MAX_VALUE, 100L, TimeUnit.NANOSECONDS);
 
     RealConnection c1 = newConnection(pool, routeA1, 50L);
 
@@ -76,9 +80,9 @@
   }
 
   @Test public void inUseConnectionsNotEvicted() throws Exception {
-    ConnectionPool poolApi = new ConnectionPool(Integer.MAX_VALUE, 100L, TimeUnit.NANOSECONDS);
-    RealConnectionPool pool = RealConnectionPool.Companion.get(poolApi);
-    pool.setCleanupRunning(true); // Prevent the cleanup runnable from being started.
+    RealConnectionPool pool = new RealConnectionPool(
+        taskRunner, Integer.MAX_VALUE, 100L, TimeUnit.NANOSECONDS);
+    ConnectionPool poolApi = new ConnectionPool(pool);
 
     RealConnection c1 = newConnection(pool, routeA1, 50L);
     synchronized (pool) {
@@ -108,8 +112,8 @@
   }
 
   @Test public void cleanupPrioritizesEarliestEviction() throws Exception {
-    RealConnectionPool pool = new RealConnectionPool(Integer.MAX_VALUE, 100L, TimeUnit.NANOSECONDS);
-    pool.setCleanupRunning(true); // Prevent the cleanup runnable from being started.
+    RealConnectionPool pool = new RealConnectionPool(
+        taskRunner, Integer.MAX_VALUE, 100L, TimeUnit.NANOSECONDS);
 
     RealConnection c1 = newConnection(pool, routeA1, 75L);
     RealConnection c2 = newConnection(pool, routeB1, 50L);
@@ -140,8 +144,8 @@
   }
 
   @Test public void oldestConnectionsEvictedIfIdleLimitExceeded() throws Exception {
-    RealConnectionPool pool = new RealConnectionPool(2, 100L, TimeUnit.NANOSECONDS);
-    pool.setCleanupRunning(true); // Prevent the cleanup runnable from being started.
+    RealConnectionPool pool = new RealConnectionPool(
+        taskRunner, 2, 100L, TimeUnit.NANOSECONDS);
 
     RealConnection c1 = newConnection(pool, routeA1, 50L);
     RealConnection c2 = newConnection(pool, routeB1, 75L);
@@ -164,9 +168,9 @@
   }
 
   @Test public void leakedAllocation() throws Exception {
-    ConnectionPool poolApi = new ConnectionPool(Integer.MAX_VALUE, 100L, TimeUnit.NANOSECONDS);
-    RealConnectionPool pool = RealConnectionPool.Companion.get(poolApi);
-    pool.setCleanupRunning(true); // Prevent the cleanup runnable from being started.
+    RealConnectionPool pool = new RealConnectionPool(
+        taskRunner, Integer.MAX_VALUE, 100L, TimeUnit.NANOSECONDS);
+    ConnectionPool poolApi = new ConnectionPool(pool);
 
     RealConnection c1 = newConnection(pool, routeA1, 0L);
     allocateAndLeakAllocation(poolApi, c1);
@@ -180,24 +184,26 @@
   }
 
   @Test public void interruptStopsThread() throws Exception {
-    RealConnectionPool pool = new RealConnectionPool(2, 100L, TimeUnit.NANOSECONDS);
+    TaskRunner realTaskRunner = TaskRunner.INSTANCE;
+    RealConnectionPool pool = new RealConnectionPool(
+        realTaskRunner, 2, 100L, TimeUnit.NANOSECONDS);
     RealConnection c1 = newConnection(pool, routeA1, Long.MAX_VALUE);
 
-    assertThat(pool.getCleanupRunning()).isTrue();
+    assertThat(realTaskRunner.activeQueues()).isNotEmpty();
 
     Thread.sleep(100);
 
     Thread[] threads = new Thread[Thread.activeCount() * 2];
     Thread.enumerate(threads);
     for (Thread t: threads) {
-      if (t != null && t.getName().equals("OkHttp ConnectionPool")) {
+      if (t != null && t.getName().equals("OkHttp TaskRunner")) {
         t.interrupt();
       }
     }
 
     Thread.sleep(100);
 
-    assertThat(pool.getCleanupRunning()).isFalse();
+    assertThat(realTaskRunner.activeQueues()).isEmpty();
   }
 
   /** Use a helper method so there's no hidden reference remaining on the stack. */
diff --git a/okhttp/src/test/java/okhttp3/internal/http2/Http2ConnectionTest.java b/okhttp/src/test/java/okhttp3/internal/http2/Http2ConnectionTest.java
index f8d5fb82ca..06daebc53f 100644
--- a/okhttp/src/test/java/okhttp3/internal/http2/Http2ConnectionTest.java
+++ b/okhttp/src/test/java/okhttp3/internal/http2/Http2ConnectionTest.java
@@ -27,6 +27,7 @@
 import java.util.concurrent.atomic.AtomicInteger;
 import okhttp3.Headers;
 import okhttp3.internal.Util;
+import okhttp3.internal.concurrent.TaskRunner;
 import okhttp3.internal.http2.MockHttp2Peer.InFrame;
 import okio.AsyncTimeout;
 import okio.Buffer;
@@ -37,7 +38,6 @@
 import okio.Source;
 import okio.Utf8;
 import org.junit.After;
-import org.junit.Before;
 import org.junit.Rule;
 import org.junit.Test;
 import org.junit.rules.TestRule;
@@ -114,9 +114,10 @@
     // This stream was created *after* the connection settings were adjusted.
     Http2Stream stream = connection.newStream(headerEntries("a", "android"), false);
 
-    assertThat(connection.getPeerSettings().getInitialWindowSize()).isEqualTo(3368);
+    assertThat(connection.getPeerSettings().getInitialWindowSize()).isEqualTo(3368L);
     // New Stream is has the most recent initial window size.
-    assertThat(stream.getBytesLeftInWriteWindow()).isEqualTo(3368);
+    assertThat(stream.getWriteBytesTotal()).isEqualTo(0L);
+    assertThat(stream.getWriteBytesMaximum()).isEqualTo(3368L);
   }
 
   @Test public void peerHttp2ServerZerosCompressionTable() throws Exception {
@@ -229,7 +230,8 @@
     InFrame frame3 = peer.takeFrame();
     assertThat(frame3.type).isEqualTo(Http2.TYPE_RST_STREAM);
 
-    assertThat(connection.getUnacknowledgedBytesRead()).isEqualTo(2048);
+    assertThat(connection.getReadBytesAcknowledged()).isEqualTo(0L);
+    assertThat(connection.getReadBytesTotal()).isEqualTo(2048L);
   }
 
   @Test public void receiveGoAwayHttp2() throws Exception {
@@ -307,7 +309,8 @@
     Http2Connection connection = connect(peer);
     connection.getOkHttpSettings().set(INITIAL_WINDOW_SIZE, windowSize);
     Http2Stream stream = connection.newStream(headerEntries("b", "banana"), false);
-    assertThat(stream.getUnacknowledgedBytesRead()).isEqualTo(0);
+    assertThat(stream.getReadBytesAcknowledged()).isEqualTo(0L);
+    assertThat(stream.getReadBytesTotal()).isEqualTo(0L);
     assertThat(stream.takeHeaders()).isEqualTo(Headers.of("a", "android"));
     Source in = stream.getSource();
     Buffer buffer = new Buffer();
@@ -496,7 +499,7 @@
 
     String longString = repeat('a', Http2.INITIAL_MAX_FRAME_SIZE + 1);
     Socket socket = peer.openSocket();
-    Http2Connection connection = new Http2Connection.Builder(true)
+    Http2Connection connection = new Http2Connection.Builder(true, TaskRunner.INSTANCE)
         .socket(socket)
         .pushObserver(IGNORE)
         .build();
@@ -879,15 +882,15 @@
         throw new AssertionError();
       }
 
-      @Override public void onSettings(Http2Connection connection) {
-        maxConcurrentStreams.set(connection.maxConcurrentStreams());
+      @Override public void onSettings(Http2Connection connection, Settings settings) {
+        maxConcurrentStreams.set(settings.getMaxConcurrentStreams());
         maxConcurrentStreamsUpdated.countDown();
       }
     };
     Http2Connection connection = connect(peer, IGNORE, listener);
 
     synchronized (connection) {
-      assertThat(connection.getPeerSettings().getMaxConcurrentStreams(-1)).isEqualTo(10);
+      assertThat(connection.getPeerSettings().getMaxConcurrentStreams()).isEqualTo(10);
     }
     maxConcurrentStreamsUpdated.await();
     assertThat(maxConcurrentStreams.get()).isEqualTo(10);
@@ -920,7 +923,7 @@
       assertThat(connection.getPeerSettings().getHeaderTableSize()).isEqualTo(10000);
       assertThat(connection.getPeerSettings().getInitialWindowSize()).isEqualTo(40000);
       assertThat(connection.getPeerSettings().getMaxFrameSize(-1)).isEqualTo(50000);
-      assertThat(connection.getPeerSettings().getMaxConcurrentStreams(-1)).isEqualTo(60000);
+      assertThat(connection.getPeerSettings().getMaxConcurrentStreams()).isEqualTo(60000);
     }
   }
 
@@ -942,14 +945,14 @@
     // fake a settings frame with clear flag set.
     Settings settings2 = new Settings();
     settings2.set(MAX_CONCURRENT_STREAMS, 60000);
-    connection.getReaderRunnable().settings(true, settings2);
+    connection.getReaderRunnable().applyAndAckSettings(true, settings2);
 
     synchronized (connection) {
       assertThat(connection.getPeerSettings().getHeaderTableSize()).isEqualTo(-1);
       assertThat(connection.getPeerSettings().getInitialWindowSize()).isEqualTo(
           (long) DEFAULT_INITIAL_WINDOW_SIZE);
       assertThat(connection.getPeerSettings().getMaxFrameSize(-1)).isEqualTo(-1);
-      assertThat(connection.getPeerSettings().getMaxConcurrentStreams(-1)).isEqualTo(60000);
+      assertThat(connection.getPeerSettings().getMaxConcurrentStreams()).isEqualTo(60000);
     }
   }
 
@@ -1637,7 +1640,8 @@
     Http2Connection connection = connect(peer);
     connection.getOkHttpSettings().set(INITIAL_WINDOW_SIZE, windowSize);
     Http2Stream stream = connection.newStream(headerEntries("b", "banana"), false);
-    assertThat(stream.getUnacknowledgedBytesRead()).isEqualTo(0);
+    assertThat(stream.getReadBytesAcknowledged()).isEqualTo(0L);
+    assertThat(stream.getReadBytesTotal()).isEqualTo(0L);
     assertThat(stream.takeHeaders()).isEqualTo(Headers.of("a", "android"));
     Source in = stream.getSource();
     Buffer buffer = new Buffer();
@@ -1749,14 +1753,18 @@
     out1.flush();
 
     // Check that we've filled the window for both the stream and also the connection.
-    assertThat(connection.getBytesLeftInWriteWindow()).isEqualTo(0);
-    assertThat(connection.getStream(3).getBytesLeftInWriteWindow()).isEqualTo(0);
+    assertThat(connection.getWriteBytesTotal()).isEqualTo(DEFAULT_INITIAL_WINDOW_SIZE);
+    assertThat(connection.getWriteBytesMaximum()).isEqualTo(DEFAULT_INITIAL_WINDOW_SIZE);
+    assertThat(stream1.getWriteBytesTotal()).isEqualTo(DEFAULT_INITIAL_WINDOW_SIZE);
+    assertThat(stream1.getWriteBytesMaximum()).isEqualTo(DEFAULT_INITIAL_WINDOW_SIZE);
 
     // receiving a window update on the connection will unblock new streams.
     connection.getReaderRunnable().windowUpdate(0, 3);
 
-    assertThat(connection.getBytesLeftInWriteWindow()).isEqualTo(3);
-    assertThat(connection.getStream(3).getBytesLeftInWriteWindow()).isEqualTo(0);
+    assertThat(connection.getWriteBytesTotal()).isEqualTo(DEFAULT_INITIAL_WINDOW_SIZE);
+    assertThat(connection.getWriteBytesMaximum()).isEqualTo(DEFAULT_INITIAL_WINDOW_SIZE + 3);
+    assertThat(stream1.getWriteBytesTotal()).isEqualTo(DEFAULT_INITIAL_WINDOW_SIZE);
+    assertThat(stream1.getWriteBytesMaximum()).isEqualTo(DEFAULT_INITIAL_WINDOW_SIZE);
 
     // Another stream should be able to send data even though 1 is blocked.
     Http2Stream stream2 = connection.newStream(headerEntries("b", "banana"), true);
@@ -1764,10 +1772,12 @@
     out2.writeUtf8("foo");
     out2.flush();
 
-    assertThat(connection.getBytesLeftInWriteWindow()).isEqualTo(0);
-    assertThat(connection.getStream(3).getBytesLeftInWriteWindow()).isEqualTo(0);
-    assertThat(connection.getStream(5).getBytesLeftInWriteWindow()).isEqualTo(
-        (long) (DEFAULT_INITIAL_WINDOW_SIZE - 3));
+    assertThat(connection.getWriteBytesTotal()).isEqualTo(DEFAULT_INITIAL_WINDOW_SIZE + 3);
+    assertThat(connection.getWriteBytesMaximum()).isEqualTo(DEFAULT_INITIAL_WINDOW_SIZE + 3);
+    assertThat(stream1.getWriteBytesTotal()).isEqualTo(DEFAULT_INITIAL_WINDOW_SIZE);
+    assertThat(stream1.getWriteBytesMaximum()).isEqualTo(DEFAULT_INITIAL_WINDOW_SIZE);
+    assertThat(stream2.getWriteBytesTotal()).isEqualTo(3L);
+    assertThat(stream2.getWriteBytesMaximum()).isEqualTo(DEFAULT_INITIAL_WINDOW_SIZE);
   }
 
   @Test public void remoteOmitsInitialSettings() throws Exception {
@@ -1777,7 +1787,7 @@
     peer.acceptFrame(); // GOAWAY
     peer.play();
 
-    Http2Connection connection = new Http2Connection.Builder(true)
+    Http2Connection connection = new Http2Connection.Builder(true, TaskRunner.INSTANCE)
         .socket(peer.openSocket())
         .build();
     connection.start(false);
@@ -1848,7 +1858,7 @@ private Http2Connection connect(MockHttp2Peer peer) throws Exception {
   /** Builds a new connection to {@code peer} with settings acked. */
   private Http2Connection connect(MockHttp2Peer peer, PushObserver pushObserver,
       Http2Connection.Listener listener) throws Exception {
-    Http2Connection connection = new Http2Connection.Builder(true)
+    Http2Connection connection = new Http2Connection.Builder(true, TaskRunner.INSTANCE)
         .socket(peer.openSocket())
         .pushObserver(pushObserver)
         .listener(listener)
diff --git a/okhttp/src/test/java/okhttp3/internal/http2/HttpOverHttp2Test.java b/okhttp/src/test/java/okhttp3/internal/http2/HttpOverHttp2Test.java
index 7a05f6b43d..43e665019d 100644
--- a/okhttp/src/test/java/okhttp3/internal/http2/HttpOverHttp2Test.java
+++ b/okhttp/src/test/java/okhttp3/internal/http2/HttpOverHttp2Test.java
@@ -30,8 +30,10 @@
 import java.util.concurrent.LinkedBlockingQueue;
 import java.util.concurrent.SynchronousQueue;
 import java.util.concurrent.TimeUnit;
+import java.util.concurrent.atomic.AtomicReference;
 import java.util.logging.Level;
 import java.util.logging.Logger;
+import javax.annotation.Nullable;
 import okhttp3.Cache;
 import okhttp3.Call;
 import okhttp3.Callback;
@@ -1620,4 +1622,33 @@ public void shutdownAfterLateCoalescing() throws Exception {
 
     latch.await();
   }
+
+  @Test public void cancelWhileWritingRequestBodySendsCancelToServer() throws Exception {
+    server.enqueue(new MockResponse());
+
+    AtomicReference<Call> callReference = new AtomicReference<>();
+    Call call = client.newCall(new Request.Builder()
+        .url(server.url("/"))
+        .post(new RequestBody() {
+          @Override public @Nullable MediaType contentType() {
+            return MediaType.get("text/plain; charset=utf-8");
+          }
+
+          @Override public void writeTo(BufferedSink sink) {
+            callReference.get().cancel();
+          }
+        })
+        .build());
+    callReference.set(call);
+
+    try {
+      call.execute();
+      fail();
+    } catch (IOException expected) {
+      assertThat(call.isCanceled()).isTrue();
+    }
+
+    RecordedRequest recordedRequest = server.takeRequest();
+    assertThat(recordedRequest.getFailure()).hasMessage("stream was reset: CANCEL");
+  }
 }
diff --git a/okhttp/src/test/java/okhttp3/internal/http2/SettingsTest.java b/okhttp/src/test/java/okhttp3/internal/http2/SettingsTest.java
index 9d7cd6d5ff..55cbfc3c10 100644
--- a/okhttp/src/test/java/okhttp3/internal/http2/SettingsTest.java
+++ b/okhttp/src/test/java/okhttp3/internal/http2/SettingsTest.java
@@ -24,7 +24,8 @@
 public final class SettingsTest {
   @Test public void unsetField() {
     Settings settings = new Settings();
-    assertThat(settings.getMaxConcurrentStreams(-3)).isEqualTo(-3);
+    assertThat(settings.isSet(MAX_CONCURRENT_STREAMS)).isFalse();
+    assertThat(settings.getMaxConcurrentStreams()).isEqualTo(Integer.MAX_VALUE);
   }
 
   @Test public void setFields() {
@@ -38,9 +39,9 @@
     assertThat(settings.getEnablePush(false)).isTrue();
     settings.clear();
 
-    assertThat(settings.getMaxConcurrentStreams(-3)).isEqualTo(-3);
+    assertThat(settings.getMaxConcurrentStreams()).isEqualTo(Integer.MAX_VALUE);
     settings.set(MAX_CONCURRENT_STREAMS, 75);
-    assertThat(settings.getMaxConcurrentStreams(-3)).isEqualTo(75);
+    assertThat(settings.getMaxConcurrentStreams()).isEqualTo(75);
 
     settings.clear();
     assertThat(settings.getMaxFrameSize(16384)).isEqualTo(16384);
@@ -72,6 +73,6 @@
     assertThat(a.getHeaderTableSize()).isEqualTo(10000);
     assertThat(a.getMaxHeaderListSize(-1)).isEqualTo(40000);
     assertThat(a.getInitialWindowSize()).isEqualTo(50000);
-    assertThat(a.getMaxConcurrentStreams(-1)).isEqualTo(60000);
+    assertThat(a.getMaxConcurrentStreams()).isEqualTo(60000);
   }
 }
diff --git a/okhttp/src/test/java/okhttp3/internal/platform/Jdk9PlatformTest.java b/okhttp/src/test/java/okhttp3/internal/platform/Jdk9PlatformTest.java
index 12e085e18c..484c1e0ded 100644
--- a/okhttp/src/test/java/okhttp3/internal/platform/Jdk9PlatformTest.java
+++ b/okhttp/src/test/java/okhttp3/internal/platform/Jdk9PlatformTest.java
@@ -15,7 +15,6 @@
  */
 package okhttp3.internal.platform;
 
-import java.lang.reflect.Method;
 import okhttp3.testing.PlatformRule;
 import org.junit.Rule;
 import org.junit.Test;
@@ -30,17 +29,8 @@ public void buildsWhenJdk9() {
     assertThat(Jdk9Platform.Companion.buildIfSupported()).isNotNull();
   }
 
-  @Test
-  public void findsAlpnMethods() {
-    Jdk9Platform platform = Jdk9Platform.Companion.buildIfSupported();
-
-    assertThat(platform.getProtocolMethod.getName()).isEqualTo("getApplicationProtocol");
-    assertThat(platform.setProtocolMethod.getName()).isEqualTo("setApplicationProtocols");
-  }
-
   @Test
   public void testToStringIsClassname() throws NoSuchMethodException {
-    Method method = this.getClass().getMethod("toString");
-    assertThat(new Jdk9Platform(method, method).toString()).isEqualTo("Jdk9Platform");
+    assertThat(new Jdk9Platform().toString()).isEqualTo("Jdk9Platform");
   }
 }
diff --git a/okhttp/src/test/java/okhttp3/internal/platform/android/AndroidSocketAdapterTest.kt b/okhttp/src/test/java/okhttp3/internal/platform/android/AndroidSocketAdapterTest.kt
index d9d6017336..534d413f6a 100644
--- a/okhttp/src/test/java/okhttp3/internal/platform/android/AndroidSocketAdapterTest.kt
+++ b/okhttp/src/test/java/okhttp3/internal/platform/android/AndroidSocketAdapterTest.kt
@@ -19,6 +19,7 @@ import okhttp3.DelegatingSSLSocket
 import okhttp3.DelegatingSSLSocketFactory
 import okhttp3.Protocol.HTTP_1_1
 import okhttp3.Protocol.HTTP_2
+import okhttp3.testing.PlatformRule
 import org.conscrypt.Conscrypt
 import org.junit.Assert.assertFalse
 import org.junit.Assert.assertNotNull
@@ -26,6 +27,7 @@ import org.junit.Assert.assertNull
 import org.junit.Assert.assertTrue
 import org.junit.Assume.assumeFalse
 import org.junit.Assume.assumeTrue
+import org.junit.Rule
 import org.junit.Test
 import org.junit.runner.RunWith
 import org.junit.runners.Parameterized
@@ -35,11 +37,17 @@ import javax.net.ssl.SSLSocket
 
 @RunWith(Parameterized::class)
 class AndroidSocketAdapterTest(private val adapter: SocketAdapter) {
-  private val provider: Provider = Conscrypt.newProviderBuilder().provideTrustManager(true).build()
-  val context: SSLContext = SSLContext.getInstance("TLS", provider)
+  @Suppress("RedundantVisibilityModifier")
+  @JvmField
+  @Rule
+  public val platform = PlatformRule.conscrypt()
 
-  init {
-    context.init(null, null, null)
+  val context by lazy {
+    val provider: Provider = Conscrypt.newProviderBuilder().provideTrustManager(true).build()
+
+    SSLContext.getInstance("TLS", provider).apply {
+      init(null, null, null)
+    }
   }
 
   @Test
@@ -49,7 +57,7 @@ class AndroidSocketAdapterTest(private val adapter: SocketAdapter) {
     val sslSocket = socketFactory.createSocket() as SSLSocket
     assertTrue(adapter.matchesSocket(sslSocket))
 
-    adapter.configureTlsExtensions(sslSocket, "example.com", listOf(HTTP_2, HTTP_1_1))
+    adapter.configureTlsExtensions(sslSocket, listOf(HTTP_2, HTTP_1_1))
     // not connected
     assertNull(adapter.getSelectedProtocol(sslSocket))
   }
@@ -80,7 +88,7 @@ class AndroidSocketAdapterTest(private val adapter: SocketAdapter) {
         object : DelegatingSSLSocket(context.socketFactory.createSocket() as SSLSocket) {}
     assertFalse(adapter.matchesSocket(sslSocket))
 
-    adapter.configureTlsExtensions(sslSocket, "example.com", listOf(HTTP_2, HTTP_1_1))
+    adapter.configureTlsExtensions(sslSocket, listOf(HTTP_2, HTTP_1_1))
     // not connected
     assertNull(adapter.getSelectedProtocol(sslSocket))
   }
@@ -89,11 +97,11 @@ class AndroidSocketAdapterTest(private val adapter: SocketAdapter) {
     @JvmStatic
     @Parameterized.Parameters(name = "{0}")
     fun data(): Collection<SocketAdapter> {
-      return listOf(
-          ConscryptSocketAdapter,
+      return listOfNotNull(
+          ConscryptSocketAdapter.buildIfSupported(),
           DeferredSocketAdapter("org.conscrypt"),
-          AndroidSocketAdapter.buildIfSupported("org.conscrypt")!!,
-          StandardAndroidSocketAdapter.buildIfSupported("org.conscrypt")!!
+          AndroidSocketAdapter.buildIfSupported("org.conscrypt"),
+          StandardAndroidSocketAdapter.buildIfSupported("org.conscrypt")
       )
     }
   }
diff --git a/okhttp/src/test/java/okhttp3/internal/tls/ClientAuthTest.java b/okhttp/src/test/java/okhttp3/internal/tls/ClientAuthTest.java
index 25a3c66d13..33d367f997 100644
--- a/okhttp/src/test/java/okhttp3/internal/tls/ClientAuthTest.java
+++ b/okhttp/src/test/java/okhttp3/internal/tls/ClientAuthTest.java
@@ -34,6 +34,7 @@
 import okhttp3.OkHttpClientTestRule;
 import okhttp3.Request;
 import okhttp3.Response;
+import okhttp3.internal.http2.ConnectionShutdownException;
 import okhttp3.mockwebserver.MockResponse;
 import okhttp3.mockwebserver.MockWebServer;
 import okhttp3.testing.PlatformRule;
@@ -257,6 +258,8 @@ public void setUp() {
     } catch (SocketException expected) {
       assertThat(getPlatformSystemProperty()).isIn(PlatformRule.JDK9_PROPERTY,
           PlatformRule.CONSCRYPT_PROPERTY);
+    } catch (ConnectionShutdownException expected) {
+      // It didn't fail until it reached the application layer.
     }
   }
 
diff --git a/okhttp/src/test/java/okhttp3/internal/ws/RealWebSocketTest.java b/okhttp/src/test/java/okhttp3/internal/ws/RealWebSocketTest.java
index 6fcf0f1da2..bbabd9ddae 100644
--- a/okhttp/src/test/java/okhttp3/internal/ws/RealWebSocketTest.java
+++ b/okhttp/src/test/java/okhttp3/internal/ws/RealWebSocketTest.java
@@ -24,6 +24,7 @@
 import okhttp3.Protocol;
 import okhttp3.Request;
 import okhttp3.Response;
+import okhttp3.internal.concurrent.TaskRunner;
 import okio.ByteString;
 import okio.Okio;
 import okio.Pipe;
@@ -372,7 +373,8 @@ public void initWebSocket(Random random, int pingIntervalMillis) throws IOExcept
           .request(new Request.Builder().url(url).build())
           .protocol(Protocol.HTTP_1_1)
           .build();
-      webSocket = new RealWebSocket(response.request(), listener, random, pingIntervalMillis);
+      webSocket = new RealWebSocket(
+          TaskRunner.INSTANCE, response.request(), listener, random, pingIntervalMillis);
       webSocket.initReaderAndWriter(name, this);
     }
 
diff --git a/okhttp/src/test/java/okhttp3/internal/ws/WebSocketHttpTest.java b/okhttp/src/test/java/okhttp3/internal/ws/WebSocketHttpTest.java
index 2006f235e4..52ae73969f 100644
--- a/okhttp/src/test/java/okhttp3/internal/ws/WebSocketHttpTest.java
+++ b/okhttp/src/test/java/okhttp3/internal/ws/WebSocketHttpTest.java
@@ -36,6 +36,7 @@
 import okhttp3.TestLogHandler;
 import okhttp3.WebSocket;
 import okhttp3.WebSocketListener;
+import okhttp3.internal.concurrent.TaskRunner;
 import okhttp3.mockwebserver.Dispatcher;
 import okhttp3.mockwebserver.MockResponse;
 import okhttp3.mockwebserver.MockWebServer;
@@ -72,28 +73,23 @@
   private final WebSocketRecorder clientListener = new WebSocketRecorder("client");
   private final WebSocketRecorder serverListener = new WebSocketRecorder("server");
   private final Random random = new Random(0);
-  private OkHttpClient client;
+  private OkHttpClient client = clientTestRule.newClientBuilder()
+      .writeTimeout(500, TimeUnit.MILLISECONDS)
+      .readTimeout(500, TimeUnit.MILLISECONDS)
+      .addInterceptor(chain -> {
+        Response response = chain.proceed(chain.request());
+        // Ensure application interceptors never see a null body.
+        assertThat(response.body()).isNotNull();
+        return response;
+      })
+      .build();
 
   @Before public void setUp() {
     platform.assumeNotOpenJSSE();
-
-    client = clientTestRule.newClientBuilder()
-        .writeTimeout(500, TimeUnit.MILLISECONDS)
-        .readTimeout(500, TimeUnit.MILLISECONDS)
-        .addInterceptor(chain -> {
-          Response response = chain.proceed(chain.request());
-          // Ensure application interceptors never see a null body.
-          assertThat(response.body()).isNotNull();
-          return response;
-        })
-        .build();
   }
 
   @After public void tearDown() {
     clientListener.assertExhausted();
-
-    // TODO: assert all connections are released once leaks are fixed
-    clientTestRule.abandonClient();
   }
 
   @Test public void textMessage() {
@@ -803,7 +799,7 @@ private RealWebSocket newWebSocket() {
 
   private RealWebSocket newWebSocket(Request request) {
     RealWebSocket webSocket = new RealWebSocket(
-        request, clientListener, random, client.pingIntervalMillis());
+        TaskRunner.INSTANCE, request, clientListener, random, client.pingIntervalMillis());
     webSocket.connect(client);
     return webSocket;
   }
diff --git a/okhttp/src/test/java/okhttp3/internal/ws/WebSocketRecorder.java b/okhttp/src/test/java/okhttp3/internal/ws/WebSocketRecorder.java
index 0ab1d1857b..17a43c5fa7 100644
--- a/okhttp/src/test/java/okhttp3/internal/ws/WebSocketRecorder.java
+++ b/okhttp/src/test/java/okhttp3/internal/ws/WebSocketRecorder.java
@@ -44,7 +44,7 @@ public void setNextEventDelegate(WebSocketListener delegate) {
   }
 
   @Override public void onOpen(WebSocket webSocket, Response response) {
-    Platform.get().log(Platform.INFO, "[WS " + name + "] onOpen", null);
+    Platform.get().log("[WS " + name + "] onOpen", Platform.INFO, null);
 
     WebSocketListener delegate = this.delegate;
     if (delegate != null) {
@@ -56,7 +56,7 @@ public void setNextEventDelegate(WebSocketListener delegate) {
   }
 
   @Override public void onMessage(WebSocket webSocket, ByteString bytes) {
-    Platform.get().log(Platform.INFO, "[WS " + name + "] onMessage", null);
+    Platform.get().log("[WS " + name + "] onMessage", Platform.INFO, null);
 
     WebSocketListener delegate = this.delegate;
     if (delegate != null) {
@@ -69,7 +69,7 @@ public void setNextEventDelegate(WebSocketListener delegate) {
   }
 
   @Override public void onMessage(WebSocket webSocket, String text) {
-    Platform.get().log(Platform.INFO, "[WS " + name + "] onMessage", null);
+    Platform.get().log("[WS " + name + "] onMessage", Platform.INFO, null);
 
     WebSocketListener delegate = this.delegate;
     if (delegate != null) {
@@ -82,7 +82,7 @@ public void setNextEventDelegate(WebSocketListener delegate) {
   }
 
   @Override public void onClosing(WebSocket webSocket, int code, String reason) {
-    Platform.get().log(Platform.INFO, "[WS " + name + "] onClosing " + code, null);
+    Platform.get().log("[WS " + name + "] onClosing " + code, Platform.INFO, null);
 
     WebSocketListener delegate = this.delegate;
     if (delegate != null) {
@@ -94,7 +94,7 @@ public void setNextEventDelegate(WebSocketListener delegate) {
   }
 
   @Override public void onClosed(WebSocket webSocket, int code, String reason) {
-    Platform.get().log(Platform.INFO, "[WS " + name + "] onClosed " + code, null);
+    Platform.get().log("[WS " + name + "] onClosed " + code, Platform.INFO, null);
 
     WebSocketListener delegate = this.delegate;
     if (delegate != null) {
@@ -106,7 +106,7 @@ public void setNextEventDelegate(WebSocketListener delegate) {
   }
 
   @Override public void onFailure(WebSocket webSocket, Throwable t, @Nullable Response response)  {
-    Platform.get().log(Platform.INFO, "[WS " + name + "] onFailure", t);
+    Platform.get().log("[WS " + name + "] onFailure", Platform.INFO, t);
 
     WebSocketListener delegate = this.delegate;
     if (delegate != null) {
diff --git a/samples/guide/build.gradle b/samples/guide/build.gradle
index f7864f3c93..493dbe78bf 100644
--- a/samples/guide/build.gradle
+++ b/samples/guide/build.gradle
@@ -1,8 +1,11 @@
+apply plugin: 'kotlin-kapt'
+
 dependencies {
   implementation project(':okhttp')
   implementation project(':mockwebserver')
   implementation project(':okhttp-tls')
   implementation deps.moshi
+  kapt deps.moshiKotlin
 }
 
 tasks.withType(JavaCompile) {
diff --git a/samples/guide/src/main/java/okhttp3/recipes/CertificatePinning.java b/samples/guide/src/main/java/okhttp3/recipes/CertificatePinning.java
index 91c3fcc59f..87ea039730 100644
--- a/samples/guide/src/main/java/okhttp3/recipes/CertificatePinning.java
+++ b/samples/guide/src/main/java/okhttp3/recipes/CertificatePinning.java
@@ -23,16 +23,12 @@
 import okhttp3.Response;
 
 public final class CertificatePinning {
-  private final OkHttpClient client;
-
-  public CertificatePinning() {
-    client = new OkHttpClient.Builder()
-        .certificatePinner(
-            new CertificatePinner.Builder()
-                .add("publicobject.com", "sha256/afwiKY3RxoMmLkuRW1l7QsPZTJPwDS2pdDROQjXw8ig=")
-                .build())
-        .build();
-  }
+  private final OkHttpClient client = new OkHttpClient.Builder()
+      .certificatePinner(
+          new CertificatePinner.Builder()
+              .add("publicobject.com", "sha256/afwiKY3RxoMmLkuRW1l7QsPZTJPwDS2pdDROQjXw8ig=")
+              .build())
+      .build();
 
   public void run() throws Exception {
     Request request = new Request.Builder()
diff --git a/samples/guide/src/main/java/okhttp3/recipes/ConfigureTimeouts.java b/samples/guide/src/main/java/okhttp3/recipes/ConfigureTimeouts.java
index a6d3000732..3c429bf23b 100644
--- a/samples/guide/src/main/java/okhttp3/recipes/ConfigureTimeouts.java
+++ b/samples/guide/src/main/java/okhttp3/recipes/ConfigureTimeouts.java
@@ -25,9 +25,10 @@
 
   public ConfigureTimeouts() throws Exception {
     client = new OkHttpClient.Builder()
-        .connectTimeout(10, TimeUnit.SECONDS)
-        .writeTimeout(10, TimeUnit.SECONDS)
-        .readTimeout(30, TimeUnit.SECONDS)
+        .connectTimeout(5, TimeUnit.SECONDS)
+        .writeTimeout(5, TimeUnit.SECONDS)
+        .readTimeout(5, TimeUnit.SECONDS)
+        .callTimeout(10, TimeUnit.SECONDS)
         .build();
   }
 
diff --git a/samples/guide/src/main/java/okhttp3/recipes/kt/AccessHeaders.kt b/samples/guide/src/main/java/okhttp3/recipes/kt/AccessHeaders.kt
new file mode 100644
index 0000000000..ca9a946615
--- /dev/null
+++ b/samples/guide/src/main/java/okhttp3/recipes/kt/AccessHeaders.kt
@@ -0,0 +1,45 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.recipes.kt
+
+import okhttp3.OkHttpClient
+import okhttp3.Request
+import java.io.IOException
+
+class AccessHeaders {
+  private val client = OkHttpClient()
+
+  fun run() {
+    val request = Request.Builder()
+        .url("https://api.github.com/repos/square/okhttp/issues")
+        .header("User-Agent", "OkHttp Headers.java")
+        .addHeader("Accept", "application/json; q=0.5")
+        .addHeader("Accept", "application/vnd.github.v3+json")
+        .build()
+
+    client.newCall(request).execute().use { response ->
+      if (!response.isSuccessful) throw IOException("Unexpected code $response")
+
+      println("Server: ${response.header("Server")}")
+      println("Date: ${response.header("Date")}")
+      println("Vary: ${response.headers("Vary")}")
+    }
+  }
+}
+
+fun main() {
+  AccessHeaders().run()
+}
diff --git a/samples/guide/src/main/java/okhttp3/recipes/kt/AsynchronousGet.kt b/samples/guide/src/main/java/okhttp3/recipes/kt/AsynchronousGet.kt
new file mode 100644
index 0000000000..ca35b3906c
--- /dev/null
+++ b/samples/guide/src/main/java/okhttp3/recipes/kt/AsynchronousGet.kt
@@ -0,0 +1,55 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.recipes.kt
+
+import okhttp3.Call
+import okhttp3.Callback
+import okhttp3.OkHttpClient
+import okhttp3.Request
+import okhttp3.Response
+import java.io.IOException
+
+class AsynchronousGet {
+  private val client = OkHttpClient()
+
+  fun run() {
+    val request = Request.Builder()
+        .url("http://publicobject.com/helloworld.txt")
+        .build()
+
+    client.newCall(request).enqueue(object : Callback {
+      override fun onFailure(call: Call, e: IOException) {
+        e.printStackTrace()
+      }
+
+      override fun onResponse(call: Call, response: Response) {
+        response.use {
+          if (!response.isSuccessful) throw IOException("Unexpected code $response")
+
+          for ((name, value) in response.headers) {
+            println("$name: $value")
+          }
+
+          println(response.body!!.string())
+        }
+      }
+    })
+  }
+}
+
+fun main() {
+  AsynchronousGet().run()
+}
diff --git a/samples/guide/src/main/java/okhttp3/recipes/kt/Authenticate.kt b/samples/guide/src/main/java/okhttp3/recipes/kt/Authenticate.kt
new file mode 100644
index 0000000000..7a56b425cd
--- /dev/null
+++ b/samples/guide/src/main/java/okhttp3/recipes/kt/Authenticate.kt
@@ -0,0 +1,60 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.recipes.kt
+
+import okhttp3.Authenticator
+import okhttp3.Credentials
+import okhttp3.OkHttpClient
+import okhttp3.Request
+import okhttp3.Response
+import okhttp3.Route
+import java.io.IOException
+
+class Authenticate {
+  private val client = OkHttpClient.Builder()
+      .authenticator(object : Authenticator {
+        @Throws(IOException::class)
+        override fun authenticate(route: Route?, response: Response): Request? {
+          if (response.request.header("Authorization") != null) {
+            return null // Give up, we've already attempted to authenticate.
+          }
+
+          println("Authenticating for response: $response")
+          println("Challenges: ${response.challenges()}")
+          val credential = Credentials.basic("jesse", "password1")
+          return response.request.newBuilder()
+              .header("Authorization", credential)
+              .build()
+        }
+      })
+      .build()
+
+  fun run() {
+    val request = Request.Builder()
+        .url("http://publicobject.com/secrets/hellosecret.txt")
+        .build()
+
+    client.newCall(request).execute().use { response ->
+      if (!response.isSuccessful) throw IOException("Unexpected code $response")
+
+      println(response.body!!.string())
+    }
+  }
+}
+
+fun main() {
+  Authenticate().run()
+}
diff --git a/samples/guide/src/main/java/okhttp3/recipes/kt/CacheResponse.kt b/samples/guide/src/main/java/okhttp3/recipes/kt/CacheResponse.kt
new file mode 100644
index 0000000000..b700690f80
--- /dev/null
+++ b/samples/guide/src/main/java/okhttp3/recipes/kt/CacheResponse.kt
@@ -0,0 +1,61 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.recipes.kt
+
+import okhttp3.Cache
+import okhttp3.OkHttpClient
+import okhttp3.Request
+import java.io.File
+import java.io.IOException
+
+class CacheResponse(cacheDirectory: File) {
+  private val client: OkHttpClient = OkHttpClient.Builder()
+      .cache(Cache(
+          directory = cacheDirectory,
+          maxSize = 10L * 1024L * 1024L // 1 MiB
+      ))
+      .build()
+
+  fun run() {
+    val request = Request.Builder()
+        .url("http://publicobject.com/helloworld.txt")
+        .build()
+
+    val response1Body = client.newCall(request).execute().use {
+      if (!it.isSuccessful) throw IOException("Unexpected code $it")
+
+      println("Response 1 response:          $it")
+      println("Response 1 cache response:    ${it.cacheResponse}")
+      println("Response 1 network response:  ${it.networkResponse}")
+      return@use it.body!!.string()
+    }
+
+    val response2Body = client.newCall(request).execute().use {
+      if (!it.isSuccessful) throw IOException("Unexpected code $it")
+
+      println("Response 2 response:          $it")
+      println("Response 2 cache response:    ${it.cacheResponse}")
+      println("Response 2 network response:  ${it.networkResponse}")
+      return@use it.body!!.string()
+    }
+
+    println("Response 2 equals Response 1? " + (response1Body == response2Body))
+  }
+}
+
+fun main() {
+  CacheResponse(File("CacheResponse.tmp")).run()
+}
diff --git a/samples/guide/src/main/java/okhttp3/recipes/kt/CancelCall.kt b/samples/guide/src/main/java/okhttp3/recipes/kt/CancelCall.kt
new file mode 100644
index 0000000000..b1932a3c30
--- /dev/null
+++ b/samples/guide/src/main/java/okhttp3/recipes/kt/CancelCall.kt
@@ -0,0 +1,58 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.recipes.kt
+
+import okhttp3.OkHttpClient
+import okhttp3.Request
+import java.io.IOException
+import java.util.concurrent.Executors
+import java.util.concurrent.TimeUnit
+
+class CancelCall {
+  private val executor = Executors.newScheduledThreadPool(1)
+  private val client = OkHttpClient()
+
+  fun run() {
+    val request = Request.Builder()
+        .url("http://httpbin.org/delay/2") // This URL is served with a 2 second delay.
+        .build()
+
+    val startNanos = System.nanoTime()
+    val call = client.newCall(request)
+
+    // Schedule a job to cancel the call in 1 second.
+    executor.schedule({
+      System.out.printf("%.2f Canceling call.%n", (System.nanoTime() - startNanos) / 1e9f)
+      call.cancel()
+      System.out.printf("%.2f Canceled call.%n", (System.nanoTime() - startNanos) / 1e9f)
+    }, 1, TimeUnit.SECONDS)
+
+    System.out.printf("%.2f Executing call.%n", (System.nanoTime() - startNanos) / 1e9f)
+    try {
+      call.execute().use { response ->
+        System.out.printf("%.2f Call was expected to fail, but completed: %s%n",
+            (System.nanoTime() - startNanos) / 1e9f, response)
+      }
+    } catch (e: IOException) {
+      System.out.printf("%.2f Call failed as expected: %s%n",
+          (System.nanoTime() - startNanos) / 1e9f, e)
+    }
+  }
+}
+
+fun main() {
+  CancelCall().run()
+}
diff --git a/samples/guide/src/main/java/okhttp3/recipes/kt/CertificatePinning.kt b/samples/guide/src/main/java/okhttp3/recipes/kt/CertificatePinning.kt
new file mode 100644
index 0000000000..ec3b79f452
--- /dev/null
+++ b/samples/guide/src/main/java/okhttp3/recipes/kt/CertificatePinning.kt
@@ -0,0 +1,48 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.recipes.kt
+
+import okhttp3.CertificatePinner
+import okhttp3.OkHttpClient
+import okhttp3.Request
+import java.io.IOException
+
+class CertificatePinning {
+  private val client = OkHttpClient.Builder()
+      .certificatePinner(
+          CertificatePinner.Builder()
+              .add("publicobject.com", "sha256/afwiKY3RxoMmLkuRW1l7QsPZTJPwDS2pdDROQjXw8ig=")
+              .build())
+      .build()
+
+  fun run() {
+    val request = Request.Builder()
+        .url("https://publicobject.com/robots.txt")
+        .build()
+
+    client.newCall(request).execute().use { response ->
+      if (!response.isSuccessful) throw IOException("Unexpected code $response")
+
+      for (certificate in response.handshake!!.peerCertificates) {
+        println(CertificatePinner.pin(certificate))
+      }
+    }
+  }
+}
+
+fun main() {
+  CertificatePinning().run()
+}
diff --git a/samples/guide/src/main/java/okhttp3/recipes/kt/ConfigureTimeouts.kt b/samples/guide/src/main/java/okhttp3/recipes/kt/ConfigureTimeouts.kt
new file mode 100644
index 0000000000..4ffeeab97c
--- /dev/null
+++ b/samples/guide/src/main/java/okhttp3/recipes/kt/ConfigureTimeouts.kt
@@ -0,0 +1,43 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.recipes.kt
+
+import okhttp3.OkHttpClient
+import okhttp3.Request
+import java.util.concurrent.TimeUnit
+
+class ConfigureTimeouts {
+  private val client: OkHttpClient = OkHttpClient.Builder()
+      .connectTimeout(5, TimeUnit.SECONDS)
+      .writeTimeout(5, TimeUnit.SECONDS)
+      .readTimeout(5, TimeUnit.SECONDS)
+      .callTimeout(10, TimeUnit.SECONDS)
+      .build()
+
+  fun run() {
+    val request = Request.Builder()
+        .url("http://httpbin.org/delay/2") // This URL is served with a 2 second delay.
+        .build()
+
+    client.newCall(request).execute().use { response ->
+      println("Response completed: $response")
+    }
+  }
+}
+
+fun main() {
+  ConfigureTimeouts().run()
+}
diff --git a/samples/guide/src/main/java/okhttp3/recipes/kt/CustomTrust.kt b/samples/guide/src/main/java/okhttp3/recipes/kt/CustomTrust.kt
new file mode 100644
index 0000000000..cae979e1a1
--- /dev/null
+++ b/samples/guide/src/main/java/okhttp3/recipes/kt/CustomTrust.kt
@@ -0,0 +1,204 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.recipes.kt
+
+import okhttp3.CertificatePinner
+import okhttp3.OkHttpClient
+import okhttp3.Request
+import okio.Buffer
+import java.io.IOException
+import java.io.InputStream
+import java.security.KeyStore
+import java.security.cert.CertificateFactory
+import java.util.Arrays
+import javax.net.ssl.KeyManagerFactory
+import javax.net.ssl.SSLContext
+import javax.net.ssl.TrustManager
+import javax.net.ssl.TrustManagerFactory
+import javax.net.ssl.X509TrustManager
+
+class CustomTrust {
+  private val client: OkHttpClient
+
+  init {
+    val trustManager = trustManagerForCertificates(trustedCertificatesInputStream())
+    val sslContext = SSLContext.getInstance("TLS")
+    sslContext.init(null, arrayOf<TrustManager>(trustManager), null)
+    val sslSocketFactory = sslContext.socketFactory
+
+    client = OkHttpClient.Builder()
+        .sslSocketFactory(sslSocketFactory, trustManager)
+        .build()
+  }
+
+  fun run() {
+    val request = Request.Builder()
+        .url("https://publicobject.com/helloworld.txt")
+        .build()
+
+    client.newCall(request).execute().use { response ->
+      if (!response.isSuccessful) throw IOException("Unexpected code $response")
+
+      for ((name, value) in response.headers) {
+        println("$name: $value")
+      }
+
+      println(response.body!!.string())
+    }
+  }
+
+  /**
+   * Returns an input stream containing one or more certificate PEM files. This implementation just
+   * embeds the PEM files in Java strings; most applications will instead read this from a resource
+   * file that gets bundled with the application.
+   */
+  private fun trustedCertificatesInputStream(): InputStream {
+    // PEM files for root certificates of Comodo and Entrust. These two CAs are sufficient to view
+    // https://publicobject.com (Comodo) and https://squareup.com (Entrust). But they aren't
+    // sufficient to connect to most HTTPS sites including https://godaddy.com and https://visa.com.
+    // Typically developers will need to get a PEM file from their organization's TLS administrator.
+    val comodoRsaCertificationAuthority = """
+        |-----BEGIN CERTIFICATE-----
+        |MIIF2DCCA8CgAwIBAgIQTKr5yttjb+Af907YWwOGnTANBgkqhkiG9w0BAQwFADCB
+        |hTELMAkGA1UEBhMCR0IxGzAZBgNVBAgTEkdyZWF0ZXIgTWFuY2hlc3RlcjEQMA4G
+        |A1UEBxMHU2FsZm9yZDEaMBgGA1UEChMRQ09NT0RPIENBIExpbWl0ZWQxKzApBgNV
+        |BAMTIkNPTU9ETyBSU0EgQ2VydGlmaWNhdGlvbiBBdXRob3JpdHkwHhcNMTAwMTE5
+        |MDAwMDAwWhcNMzgwMTE4MjM1OTU5WjCBhTELMAkGA1UEBhMCR0IxGzAZBgNVBAgT
+        |EkdyZWF0ZXIgTWFuY2hlc3RlcjEQMA4GA1UEBxMHU2FsZm9yZDEaMBgGA1UEChMR
+        |Q09NT0RPIENBIExpbWl0ZWQxKzApBgNVBAMTIkNPTU9ETyBSU0EgQ2VydGlmaWNh
+        |dGlvbiBBdXRob3JpdHkwggIiMA0GCSqGSIb3DQEBAQUAA4ICDwAwggIKAoICAQCR
+        |6FSS0gpWsawNJN3Fz0RndJkrN6N9I3AAcbxT38T6KhKPS38QVr2fcHK3YX/JSw8X
+        |pz3jsARh7v8Rl8f0hj4K+j5c+ZPmNHrZFGvnnLOFoIJ6dq9xkNfs/Q36nGz637CC
+        |9BR++b7Epi9Pf5l/tfxnQ3K9DADWietrLNPtj5gcFKt+5eNu/Nio5JIk2kNrYrhV
+        |/erBvGy2i/MOjZrkm2xpmfh4SDBF1a3hDTxFYPwyllEnvGfDyi62a+pGx8cgoLEf
+        |Zd5ICLqkTqnyg0Y3hOvozIFIQ2dOciqbXL1MGyiKXCJ7tKuY2e7gUYPDCUZObT6Z
+        |+pUX2nwzV0E8jVHtC7ZcryxjGt9XyD+86V3Em69FmeKjWiS0uqlWPc9vqv9JWL7w
+        |qP/0uK3pN/u6uPQLOvnoQ0IeidiEyxPx2bvhiWC4jChWrBQdnArncevPDt09qZah
+        |SL0896+1DSJMwBGB7FY79tOi4lu3sgQiUpWAk2nojkxl8ZEDLXB0AuqLZxUpaVIC
+        |u9ffUGpVRr+goyhhf3DQw6KqLCGqR84onAZFdr+CGCe01a60y1Dma/RMhnEw6abf
+        |Fobg2P9A3fvQQoh/ozM6LlweQRGBY84YcWsr7KaKtzFcOmpH4MN5WdYgGq/yapiq
+        |crxXStJLnbsQ/LBMQeXtHT1eKJ2czL+zUdqnR+WEUwIDAQABo0IwQDAdBgNVHQ4E
+        |FgQUu69+Aj36pvE8hI6t7jiY7NkyMtQwDgYDVR0PAQH/BAQDAgEGMA8GA1UdEwEB
+        |/wQFMAMBAf8wDQYJKoZIhvcNAQEMBQADggIBAArx1UaEt65Ru2yyTUEUAJNMnMvl
+        |wFTPoCWOAvn9sKIN9SCYPBMtrFaisNZ+EZLpLrqeLppysb0ZRGxhNaKatBYSaVqM
+        |4dc+pBroLwP0rmEdEBsqpIt6xf4FpuHA1sj+nq6PK7o9mfjYcwlYRm6mnPTXJ9OV
+        |2jeDchzTc+CiR5kDOF3VSXkAKRzH7JsgHAckaVd4sjn8OoSgtZx8jb8uk2Intzna
+        |FxiuvTwJaP+EmzzV1gsD41eeFPfR60/IvYcjt7ZJQ3mFXLrrkguhxuhoqEwWsRqZ
+        |CuhTLJK7oQkYdQxlqHvLI7cawiiFwxv/0Cti76R7CZGYZ4wUAc1oBmpjIXUDgIiK
+        |boHGhfKppC3n9KUkEEeDys30jXlYsQab5xoq2Z0B15R97QNKyvDb6KkBPvVWmcke
+        |jkk9u+UJueBPSZI9FoJAzMxZxuY67RIuaTxslbH9qh17f4a+Hg4yRvv7E491f0yL
+        |S0Zj/gA0QHDBw7mh3aZw4gSzQbzpgJHqZJx64SIDqZxubw5lT2yHh17zbqD5daWb
+        |QOhTsiedSrnAdyGN/4fy3ryM7xfft0kL0fJuMAsaDk527RH89elWsn2/x20Kk4yl
+        |0MC2Hb46TpSi125sC8KKfPog88Tk5c0NqMuRkrF8hey1FGlmDoLnzc7ILaZRfyHB
+        |NVOFBkpdn627G190
+        |-----END CERTIFICATE-----
+        |""".trimMargin()
+    val entrustRootCertificateAuthority = """
+        |-----BEGIN CERTIFICATE-----
+        |MIIEkTCCA3mgAwIBAgIERWtQVDANBgkqhkiG9w0BAQUFADCBsDELMAkGA1UEBhMC
+        |VVMxFjAUBgNVBAoTDUVudHJ1c3QsIEluYy4xOTA3BgNVBAsTMHd3dy5lbnRydXN0
+        |Lm5ldC9DUFMgaXMgaW5jb3Jwb3JhdGVkIGJ5IHJlZmVyZW5jZTEfMB0GA1UECxMW
+        |KGMpIDIwMDYgRW50cnVzdCwgSW5jLjEtMCsGA1UEAxMkRW50cnVzdCBSb290IENl
+        |cnRpZmljYXRpb24gQXV0aG9yaXR5MB4XDTA2MTEyNzIwMjM0MloXDTI2MTEyNzIw
+        |NTM0MlowgbAxCzAJBgNVBAYTAlVTMRYwFAYDVQQKEw1FbnRydXN0LCBJbmMuMTkw
+        |NwYDVQQLEzB3d3cuZW50cnVzdC5uZXQvQ1BTIGlzIGluY29ycG9yYXRlZCBieSBy
+        |ZWZlcmVuY2UxHzAdBgNVBAsTFihjKSAyMDA2IEVudHJ1c3QsIEluYy4xLTArBgNV
+        |BAMTJEVudHJ1c3QgUm9vdCBDZXJ0aWZpY2F0aW9uIEF1dGhvcml0eTCCASIwDQYJ
+        |KoZIhvcNAQEBBQADggEPADCCAQoCggEBALaVtkNC+sZtKm9I35RMOVcF7sN5EUFo
+        |Nu3s/poBj6E4KPz3EEZmLk0eGrEaTsbRwJWIsMn/MYszA9u3g3s+IIRe7bJWKKf4
+        |4LlAcTfFy0cOlypowCKVYhXbR9n10Cv/gkvJrT7eTNuQgFA/CYqEAOwwCj0Yzfv9
+        |KlmaI5UXLEWeH25DeW0MXJj+SKfFI0dcXv1u5x609mhF0YaDW6KKjbHjKYD+JXGI
+        |rb68j6xSlkuqUY3kEzEZ6E5Nn9uss2rVvDlUccp6en+Q3X0dgNmBu1kmwhH+5pPi
+        |94DkZfs0Nw4pgHBNrziGLp5/V6+eF67rHMsoIV+2HNjnogQi+dPa2MsCAwEAAaOB
+        |sDCBrTAOBgNVHQ8BAf8EBAMCAQYwDwYDVR0TAQH/BAUwAwEB/zArBgNVHRAEJDAi
+        |gA8yMDA2MTEyNzIwMjM0MlqBDzIwMjYxMTI3MjA1MzQyWjAfBgNVHSMEGDAWgBRo
+        |kORnpKZTgMeGZqTx90tD+4S9bTAdBgNVHQ4EFgQUaJDkZ6SmU4DHhmak8fdLQ/uE
+        |vW0wHQYJKoZIhvZ9B0EABBAwDhsIVjcuMTo0LjADAgSQMA0GCSqGSIb3DQEBBQUA
+        |A4IBAQCT1DCw1wMgKtD5Y+iRDAUgqV8ZyntyTtSx29CW+1RaGSwMCPeyvIWonX9t
+        |O1KzKtvn1ISMY/YPyyYBkVBs9F8U4pN0wBOeMDpQ47RgxRzwIkSNcUesyBrJ6Zua
+        |AGAT/3B+XxFNSRuzFVJ7yVTav52Vr2ua2J7p8eRDjeIRRDq/r72DQnNSi6q7pynP
+        |9WQcCk3RvKqsnyrQ/39/2n3qse0wJcGE2jTSW3iDVuycNsMm4hH2Z0kdkquM++v/
+        |eu6FSqdQgPCnXEqULl8FmTxSQeDNtGPPAUO6nIPcj2A781q0tHuu2guQOHXvgR1m
+        |0vdXcDazv/wor3ElhVsT/h5/WrQ8
+        |-----END CERTIFICATE-----
+        |""".trimMargin()
+    return Buffer()
+        .writeUtf8(comodoRsaCertificationAuthority)
+        .writeUtf8(entrustRootCertificateAuthority)
+        .inputStream()
+  }
+
+  /**
+   * Returns a trust manager that trusts `certificates` and none other. HTTPS services whose
+   * certificates have not been signed by these certificates will fail with a
+   * `SSLHandshakeException`.
+   *
+   * This can be used to replace the host platform's built-in trusted certificates with a custom
+   * set. This is useful in development where certificate authority-trusted certificates aren't
+   * available. Or in production, to avoid reliance on third-party certificate authorities.
+   *
+   * See also [CertificatePinner], which can limit trusted certificates while still using
+   * the host platform's built-in trust store.
+   *
+   * Warning: Customizing Trusted Certificates is Dangerous!
+   * -------------------------------------------------------
+   *
+   * Relying on your own trusted certificates limits your server team's ability to update their
+   * TLS certificates. By installing a specific set of trusted certificates, you take on additional
+   * operational complexity and limit your ability to migrate between certificate authorities. Do
+   * not use custom trusted certificates in production without the blessing of your server's TLS
+   * administrator.
+   */
+  private fun trustManagerForCertificates(inputStream: InputStream): X509TrustManager {
+    val certificateFactory = CertificateFactory.getInstance("X.509")
+    val certificates = certificateFactory.generateCertificates(inputStream)
+    require(!certificates.isEmpty()) { "expected non-empty set of trusted certificates" }
+
+    // Put the certificates a key store.
+    val password = "password".toCharArray() // Any password will work.
+    val keyStore = newEmptyKeyStore(password)
+    for ((index, certificate) in certificates.withIndex()) {
+      val certificateAlias = index.toString()
+      keyStore.setCertificateEntry(certificateAlias, certificate)
+    }
+
+    // Use it to build an X509 trust manager.
+    val keyManagerFactory = KeyManagerFactory.getInstance(
+        KeyManagerFactory.getDefaultAlgorithm()
+    )
+    keyManagerFactory.init(keyStore, password)
+    val trustManagerFactory = TrustManagerFactory.getInstance(
+        TrustManagerFactory.getDefaultAlgorithm()
+    )
+    trustManagerFactory.init(keyStore)
+    val trustManagers = trustManagerFactory.trustManagers
+    check(trustManagers.size == 1 && trustManagers[0] is X509TrustManager) {
+      "Unexpected default trust managers: ${Arrays.toString(trustManagers)}"
+    }
+    return trustManagers[0] as X509TrustManager
+  }
+
+  private fun newEmptyKeyStore(password: CharArray): KeyStore {
+    val keyStore = KeyStore.getInstance(KeyStore.getDefaultType())
+    val inputStream: InputStream? = null // By convention, 'null' creates an empty key store.
+    keyStore.load(inputStream, password)
+    return keyStore
+  }
+}
+
+fun main() {
+  CustomTrust().run()
+}
diff --git a/samples/guide/src/main/java/okhttp3/recipes/kt/ParseResponseWithMoshi.kt b/samples/guide/src/main/java/okhttp3/recipes/kt/ParseResponseWithMoshi.kt
new file mode 100644
index 0000000000..a5a8ac4633
--- /dev/null
+++ b/samples/guide/src/main/java/okhttp3/recipes/kt/ParseResponseWithMoshi.kt
@@ -0,0 +1,54 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.recipes.kt
+
+import com.squareup.moshi.JsonClass
+import com.squareup.moshi.Moshi
+import okhttp3.OkHttpClient
+import okhttp3.Request
+import java.io.IOException
+
+class ParseResponseWithMoshi {
+  private val client = OkHttpClient()
+  private val moshi = Moshi.Builder().build()
+  private val gistJsonAdapter = moshi.adapter(Gist::class.java)
+
+  fun run() {
+    val request = Request.Builder()
+        .url("https://api.github.com/gists/c2a7c39532239ff261be")
+        .build()
+    client.newCall(request).execute().use { response ->
+      if (!response.isSuccessful) throw IOException("Unexpected code $response")
+
+      val gist = gistJsonAdapter.fromJson(response.body!!.source())
+
+      for ((key, value) in gist!!.files!!) {
+        println(key)
+        println(value.content)
+      }
+    }
+  }
+
+  @JsonClass(generateAdapter = true)
+  data class Gist(var files: Map<String, GistFile>?)
+
+  @JsonClass(generateAdapter = true)
+  data class GistFile(var content: String?)
+}
+
+fun main() {
+  ParseResponseWithMoshi().run()
+}
diff --git a/samples/guide/src/main/java/okhttp3/recipes/kt/PerCallSettings.kt b/samples/guide/src/main/java/okhttp3/recipes/kt/PerCallSettings.kt
new file mode 100644
index 0000000000..4ff5f5a027
--- /dev/null
+++ b/samples/guide/src/main/java/okhttp3/recipes/kt/PerCallSettings.kt
@@ -0,0 +1,59 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.recipes.kt
+
+import okhttp3.OkHttpClient
+import okhttp3.Request
+import java.io.IOException
+import java.util.concurrent.TimeUnit
+
+class PerCallSettings {
+  private val client = OkHttpClient()
+
+  fun run() {
+    val request = Request.Builder()
+        .url("http://httpbin.org/delay/1") // This URL is served with a 1 second delay.
+        .build()
+
+    // Copy to customize OkHttp for this request.
+    val client1 = client.newBuilder()
+        .readTimeout(500, TimeUnit.MILLISECONDS)
+        .build()
+    try {
+      client1.newCall(request).execute().use { response ->
+        println("Response 1 succeeded: $response")
+      }
+    } catch (e: IOException) {
+      println("Response 1 failed: $e")
+    }
+
+    // Copy to customize OkHttp for this request.
+    val client2 = client.newBuilder()
+        .readTimeout(3000, TimeUnit.MILLISECONDS)
+        .build()
+    try {
+      client2.newCall(request).execute().use { response ->
+        println("Response 2 succeeded: $response")
+      }
+    } catch (e: IOException) {
+      println("Response 2 failed: $e")
+    }
+  }
+}
+
+fun main() {
+  PerCallSettings().run()
+}
diff --git a/samples/guide/src/main/java/okhttp3/recipes/kt/PostFile.kt b/samples/guide/src/main/java/okhttp3/recipes/kt/PostFile.kt
new file mode 100644
index 0000000000..cfb983a02d
--- /dev/null
+++ b/samples/guide/src/main/java/okhttp3/recipes/kt/PostFile.kt
@@ -0,0 +1,50 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.recipes.kt
+
+import okhttp3.MediaType.Companion.toMediaType
+import okhttp3.OkHttpClient
+import okhttp3.Request
+import okhttp3.RequestBody.Companion.asRequestBody
+import java.io.File
+import java.io.IOException
+
+class PostFile {
+  private val client = OkHttpClient()
+
+  fun run() {
+    val file = File("README.md")
+
+    val request = Request.Builder()
+        .url("https://api.github.com/markdown/raw")
+        .post(file.asRequestBody(MEDIA_TYPE_MARKDOWN))
+        .build()
+
+    client.newCall(request).execute().use { response ->
+      if (!response.isSuccessful) throw IOException("Unexpected code $response")
+
+      println(response.body!!.string())
+    }
+  }
+
+  companion object {
+    val MEDIA_TYPE_MARKDOWN = "text/x-markdown; charset=utf-8".toMediaType()
+  }
+}
+
+fun main() {
+  PostFile().run()
+}
diff --git a/samples/guide/src/main/java/okhttp3/recipes/kt/PostForm.kt b/samples/guide/src/main/java/okhttp3/recipes/kt/PostForm.kt
new file mode 100644
index 0000000000..189c6f1d7d
--- /dev/null
+++ b/samples/guide/src/main/java/okhttp3/recipes/kt/PostForm.kt
@@ -0,0 +1,45 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.recipes.kt
+
+import okhttp3.FormBody
+import okhttp3.OkHttpClient
+import okhttp3.Request
+import java.io.IOException
+
+class PostForm {
+  private val client = OkHttpClient()
+
+  fun run() {
+    val formBody = FormBody.Builder()
+        .add("search", "Jurassic Park")
+        .build()
+    val request = Request.Builder()
+        .url("https://en.wikipedia.org/w/index.php")
+        .post(formBody)
+        .build()
+
+    client.newCall(request).execute().use { response ->
+      if (!response.isSuccessful) throw IOException("Unexpected code $response")
+
+      println(response.body!!.string())
+    }
+  }
+}
+
+fun main() {
+  PostForm().run()
+}
diff --git a/samples/guide/src/main/java/okhttp3/recipes/kt/PostMultipart.kt b/samples/guide/src/main/java/okhttp3/recipes/kt/PostMultipart.kt
new file mode 100644
index 0000000000..7a56bd3a7f
--- /dev/null
+++ b/samples/guide/src/main/java/okhttp3/recipes/kt/PostMultipart.kt
@@ -0,0 +1,63 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.recipes.kt
+
+import okhttp3.MediaType.Companion.toMediaType
+import okhttp3.MultipartBody
+import okhttp3.OkHttpClient
+import okhttp3.Request
+import okhttp3.RequestBody.Companion.asRequestBody
+import java.io.File
+import java.io.IOException
+
+class PostMultipart {
+  private val client = OkHttpClient()
+
+  fun run() {
+    // Use the imgur image upload API as documented at https://api.imgur.com/endpoints/image
+    val requestBody = MultipartBody.Builder()
+        .setType(MultipartBody.FORM)
+        .addFormDataPart("title", "Square Logo")
+        .addFormDataPart("image", "logo-square.png",
+            File("docs/images/logo-square.png").asRequestBody(MEDIA_TYPE_PNG))
+        .build()
+
+    val request = Request.Builder()
+        .header("Authorization", "Client-ID $IMGUR_CLIENT_ID")
+        .url("https://api.imgur.com/3/image")
+        .post(requestBody)
+        .build()
+
+    client.newCall(request).execute().use { response ->
+      if (!response.isSuccessful) throw IOException("Unexpected code $response")
+
+      println(response.body!!.string())
+    }
+  }
+
+  companion object {
+    /**
+     * The imgur client ID for OkHttp recipes. If you're using imgur for anything other than running
+     * these examples, please request your own client ID! https://api.imgur.com/oauth2
+     */
+    private val IMGUR_CLIENT_ID = "9199fdef135c122"
+    private val MEDIA_TYPE_PNG = "image/png".toMediaType()
+  }
+}
+
+fun main() {
+  PostMultipart().run()
+}
diff --git a/samples/guide/src/main/java/okhttp3/recipes/kt/PostStreaming.kt b/samples/guide/src/main/java/okhttp3/recipes/kt/PostStreaming.kt
new file mode 100644
index 0000000000..5cfcd96a06
--- /dev/null
+++ b/samples/guide/src/main/java/okhttp3/recipes/kt/PostStreaming.kt
@@ -0,0 +1,68 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.recipes.kt
+
+import okhttp3.MediaType.Companion.toMediaType
+import okhttp3.OkHttpClient
+import okhttp3.Request
+import okhttp3.RequestBody
+import okio.BufferedSink
+import java.io.IOException
+
+class PostStreaming {
+  private val client = OkHttpClient()
+
+  fun run() {
+    val requestBody = object : RequestBody() {
+      override fun contentType() = MEDIA_TYPE_MARKDOWN
+
+      override fun writeTo(sink: BufferedSink) {
+        sink.writeUtf8("Numbers\n")
+        sink.writeUtf8("-------\n")
+        for (i in 2..997) {
+          sink.writeUtf8(String.format(" * $i = ${factor(i)}\n"))
+        }
+      }
+
+      private fun factor(n: Int): String {
+        for (i in 2 until n) {
+          val x = n / i
+          if (x * i == n) return "${factor(x)} × $i"
+        }
+        return n.toString()
+      }
+    }
+
+    val request = Request.Builder()
+        .url("https://api.github.com/markdown/raw")
+        .post(requestBody)
+        .build()
+
+    client.newCall(request).execute().use { response ->
+      if (!response.isSuccessful) throw IOException("Unexpected code $response")
+
+      println(response.body!!.string())
+    }
+  }
+
+  companion object {
+    val MEDIA_TYPE_MARKDOWN = "text/x-markdown; charset=utf-8".toMediaType()
+  }
+}
+
+fun main() {
+  PostStreaming().run()
+}
diff --git a/samples/guide/src/main/java/okhttp3/recipes/kt/PostString.kt b/samples/guide/src/main/java/okhttp3/recipes/kt/PostString.kt
new file mode 100644
index 0000000000..d77fda90f8
--- /dev/null
+++ b/samples/guide/src/main/java/okhttp3/recipes/kt/PostString.kt
@@ -0,0 +1,56 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.recipes.kt
+
+import okhttp3.MediaType.Companion.toMediaType
+import okhttp3.OkHttpClient
+import okhttp3.Request
+import okhttp3.RequestBody.Companion.toRequestBody
+import java.io.IOException
+
+class PostString {
+  private val client = OkHttpClient()
+
+  fun run() {
+    val postBody = """
+        |Releases
+        |--------
+        |
+        | * _1.0_ May 6, 2013
+        | * _1.1_ June 15, 2013
+        | * _1.2_ August 11, 2013
+        |""".trimMargin()
+
+    val request = Request.Builder()
+        .url("https://api.github.com/markdown/raw")
+        .post(postBody.toRequestBody(MEDIA_TYPE_MARKDOWN))
+        .build()
+
+    client.newCall(request).execute().use { response ->
+      if (!response.isSuccessful) throw IOException("Unexpected code $response")
+
+      println(response.body!!.string())
+    }
+  }
+
+  companion object {
+    val MEDIA_TYPE_MARKDOWN = "text/x-markdown; charset=utf-8".toMediaType()
+  }
+}
+
+fun main() {
+  PostString().run()
+}
diff --git a/samples/guide/src/main/java/okhttp3/recipes/kt/SynchronousGet.kt b/samples/guide/src/main/java/okhttp3/recipes/kt/SynchronousGet.kt
new file mode 100644
index 0000000000..d5e0634d17
--- /dev/null
+++ b/samples/guide/src/main/java/okhttp3/recipes/kt/SynchronousGet.kt
@@ -0,0 +1,44 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.recipes.kt
+
+import okhttp3.OkHttpClient
+import okhttp3.Request
+import java.io.IOException
+
+class SynchronousGet {
+  private val client = OkHttpClient()
+
+  fun run() {
+    val request = Request.Builder()
+        .url("https://publicobject.com/helloworld.txt")
+        .build()
+
+    client.newCall(request).execute().use { response ->
+      if (!response.isSuccessful) throw IOException("Unexpected code $response")
+
+      for ((name, value) in response.headers) {
+        println("$name: $value")
+      }
+
+      println(response.body!!.string())
+    }
+  }
+}
+
+fun main() {
+  SynchronousGet().run()
+}
