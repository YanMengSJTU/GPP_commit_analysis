diff --git a/okhttp-tests/src/test/java/com/squareup/okhttp/CallTest.java b/okhttp-tests/src/test/java/com/squareup/okhttp/CallTest.java
index f2f97d0cb4..d766ec40a2 100644
--- a/okhttp-tests/src/test/java/com/squareup/okhttp/CallTest.java
+++ b/okhttp-tests/src/test/java/com/squareup/okhttp/CallTest.java
@@ -69,7 +69,6 @@
 import okio.Okio;
 import org.junit.After;
 import org.junit.Before;
-import org.junit.Ignore;
 import org.junit.Rule;
 import org.junit.Test;
 import org.junit.rules.TestRule;
@@ -1972,7 +1971,6 @@ private InetSocketAddress startNullServer() throws IOException {
   }
 
   /** We had a bug where failed HTTP/2 calls could break the entire connection. */
-  @Ignore // TODO(jwilson): fix HttpEngine connection cleanups.
   @Test public void failingCallsDoNotInterfereWithConnection() throws Exception {
     enableProtocol(Protocol.HTTP_2);
 
diff --git a/okhttp-tests/src/test/java/com/squareup/okhttp/ConnectionPoolTest.java b/okhttp-tests/src/test/java/com/squareup/okhttp/ConnectionPoolTest.java
index 9a178574dc..0a8753546d 100644
--- a/okhttp-tests/src/test/java/com/squareup/okhttp/ConnectionPoolTest.java
+++ b/okhttp-tests/src/test/java/com/squareup/okhttp/ConnectionPoolTest.java
@@ -40,14 +40,14 @@
   private final Route routeA1 = newRoute(addressA);
   private final Address addressB = newAddress("b");
   private final Route routeB1 = newRoute(addressB);
+  private final Address addressC = newAddress("c");
+  private final Route routeC1 = newRoute(addressC);
 
   @Test public void connectionsEvictedWhenIdleLongEnough() throws Exception {
-    ConnectionPool pool = new ConnectionPool(1, 100L, TimeUnit.NANOSECONDS);
+    ConnectionPool pool = new ConnectionPool(Integer.MAX_VALUE, 100L, TimeUnit.NANOSECONDS);
     pool.setCleanupRunnableForTest(emptyRunnable);
-    RealConnection c1 = new RealConnection(routeA1);
-    c1.idleAtNanos = 50L;
-    c1.socket = new Socket();
-    assertFalse(c1.socket.isClosed());
+
+    RealConnection c1 = newConnection(routeA1, 50L);
     pool.put(c1);
 
     // Running at time 50, the pool returns that nothing can be evicted until time 150.
@@ -77,13 +77,11 @@
   }
 
   @Test public void inUseConnectionsNotEvicted() throws Exception {
-    ConnectionPool pool = new ConnectionPool(1, 100L, TimeUnit.NANOSECONDS);
+    ConnectionPool pool = new ConnectionPool(Integer.MAX_VALUE, 100L, TimeUnit.NANOSECONDS);
     pool.setCleanupRunnableForTest(emptyRunnable);
-    RealConnection c1 = new RealConnection(routeA1);
+
+    RealConnection c1 = newConnection(routeA1, 50L);
     c1.allocationCount = 1;
-    c1.idleAtNanos = 50L;
-    c1.socket = new Socket();
-    assertFalse(c1.socket.isClosed());
     pool.put(c1);
 
     // Running at time 50, the pool returns that nothing can be evicted until time 150.
@@ -103,16 +101,13 @@
   }
 
   @Test public void cleanupPrioritizesEarliestEviction() throws Exception {
-    ConnectionPool pool = new ConnectionPool(1, 100L, TimeUnit.NANOSECONDS);
+    ConnectionPool pool = new ConnectionPool(Integer.MAX_VALUE, 100L, TimeUnit.NANOSECONDS);
     pool.setCleanupRunnableForTest(emptyRunnable);
-    RealConnection c1 = new RealConnection(routeA1);
-    c1.idleAtNanos = 75L;
-    c1.socket = new Socket();
+
+    RealConnection c1 = newConnection(routeA1, 75L);
     pool.put(c1);
 
-    RealConnection c2 = new RealConnection(routeB1);
-    c2.idleAtNanos = 50L;
-    c2.socket = new Socket();
+    RealConnection c2 = newConnection(routeB1, 50L);
     pool.put(c2);
 
     // Running at time 75, the pool returns that nothing can be evicted until time 150.
@@ -140,6 +135,41 @@
     assertTrue(c2.socket.isClosed());
   }
 
+  @Test public void oldestConnectionsEvictedIfIdleLimitExceeded() throws Exception {
+    ConnectionPool pool = new ConnectionPool(2, 100L, TimeUnit.NANOSECONDS);
+    pool.setCleanupRunnableForTest(emptyRunnable);
+
+    RealConnection c1 = newConnection(routeA1, 50L);
+    pool.put(c1);
+
+    RealConnection c2 = newConnection(routeB1, 75L);
+    pool.put(c2);
+
+    // With 2 connections, there's no need to evict until the connections time out.
+    assertEquals(50L, pool.cleanup(100L));
+    assertEquals(2, pool.getConnectionCount());
+    assertFalse(c1.socket.isClosed());
+    assertFalse(c2.socket.isClosed());
+
+    // Add a third connection
+    RealConnection c3 = newConnection(routeC1, 75L);
+    pool.put(c3);
+
+    // The third connection bounces the first.
+    assertEquals(0L, pool.cleanup(100L));
+    assertEquals(2, pool.getConnectionCount());
+    assertTrue(c1.socket.isClosed());
+    assertFalse(c2.socket.isClosed());
+    assertFalse(c3.socket.isClosed());
+  }
+
+  private RealConnection newConnection(Route route, long idleAtNanos) {
+    RealConnection connection = new RealConnection(route);
+    connection.idleAtNanos = idleAtNanos;
+    connection.socket = new Socket();
+    return connection;
+  }
+
   private Address newAddress(String name) {
     return new Address(name, 1, Dns.SYSTEM, SocketFactory.getDefault(), null, null, null,
         new RecordingOkAuthenticator("password"), null, Collections.<Protocol>emptyList(),
diff --git a/okhttp-tests/src/test/java/com/squareup/okhttp/NewConnectionPoolTest.java b/okhttp-tests/src/test/java/com/squareup/okhttp/ConnectionReuseTest.java
similarity index 98%
rename from okhttp-tests/src/test/java/com/squareup/okhttp/NewConnectionPoolTest.java
rename to okhttp-tests/src/test/java/com/squareup/okhttp/ConnectionReuseTest.java
index 3ca0e6f924..f445dac7a7 100644
--- a/okhttp-tests/src/test/java/com/squareup/okhttp/NewConnectionPoolTest.java
+++ b/okhttp-tests/src/test/java/com/squareup/okhttp/ConnectionReuseTest.java
@@ -23,7 +23,6 @@
 import java.util.Arrays;
 import java.util.concurrent.TimeUnit;
 import javax.net.ssl.SSLContext;
-import org.junit.Ignore;
 import org.junit.Rule;
 import org.junit.Test;
 import org.junit.rules.TestRule;
@@ -31,7 +30,7 @@
 
 import static org.junit.Assert.assertEquals;
 
-public final class NewConnectionPoolTest {
+public final class ConnectionReuseTest {
   @Rule public final TestRule timeout = new Timeout(30_000);
   @Rule public final MockWebServer server = new MockWebServer();
 
@@ -101,7 +100,6 @@
     assertConnectionNotReused(request, request);
   }
 
-  @Ignore("TODO(jwilson): this is broken (and flaky). Fixed with new connection pool")
   @Test public void connectionsAreNotReusedIfPoolIsSizeZero() throws Exception {
     client.setConnectionPool(new ConnectionPool(0, 5000));
     server.enqueue(new MockResponse().setBody("a"));
diff --git a/okhttp/src/main/java/com/squareup/okhttp/ConnectionPool.java b/okhttp/src/main/java/com/squareup/okhttp/ConnectionPool.java
index 1ae23790b0..f2f56c10de 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/ConnectionPool.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/ConnectionPool.java
@@ -187,9 +187,19 @@ public synchronized void put(RealConnection connection) {
     connections.add(connection);
   }
 
+  /**
+   * Notify this pool that {@code connection} has become idle. Returns true if the connection
+   * has been removed from the pool and should be closed.
+   */
   // TODO(jwilson): reduce visibility.
-  public synchronized void remove(RealConnection connection) {
-    connections.remove(connection);
+  public synchronized boolean connectionBecameIdle(RealConnection connection) {
+    if (connection.noNewStreams || maxIdleConnections == 0) {
+      connections.remove(connection);
+      return true;
+    } else {
+      notifyAll(); // Awake the cleanup thread: we may have exceeded the idle connection limit.
+      return false;
+    }
   }
 
   /** Close and remove all idle connections in the pool. */
@@ -212,15 +222,17 @@ public void evictAll() {
   }
 
   /**
-   * Performs maintenance on this pool, evicting connections that have expired.
+   * Performs maintenance on this pool, evicting the connection that has been idle the longest if
+   * either it has exceeded the keep alive limit or the idle connections limit.
    *
    * <p>Returns the duration in nanos to sleep until the next scheduled call to this method.
    * Returns -1 if no further cleanups are required.
    */
   long cleanup(long now) {
     int inUseConnectionCount = 0;
-    long nanosUntilNextCleanup = -1L;
-    RealConnection connectionToEvict = null;
+    int idleConnectionCount = 0;
+    RealConnection longestIdleConnection = null;
+    long longestIdleDurationNs = Long.MIN_VALUE;
 
     // Find either a connection to evict, or the time that the next eviction is due.
     synchronized (this) {
@@ -230,41 +242,43 @@ long cleanup(long now) {
         // If the connection is in use, keep searching.
         if (connection.allocationCount > 0) {
           inUseConnectionCount++;
-          nanosUntilNextCleanup = keepAliveDurationNs;
           continue;
         }
 
+        idleConnectionCount++;
+
         // If the connection is ready to be evicted, we're done.
-        long evictAtNanos = connection.idleAtNanos + keepAliveDurationNs;
-        long nanosUntilEviction = evictAtNanos - now;
-        if (nanosUntilEviction <= 0) {
-          connection.noNewStreams = true;
-          connectionToEvict = connection;
-          i.remove();
-          break;
+        long idleDurationNs = now - connection.idleAtNanos;
+        if (idleDurationNs > longestIdleDurationNs) {
+          longestIdleDurationNs = idleDurationNs;
+          longestIdleConnection = connection;
         }
+      }
 
-        // Is this the next connection to evict?
-        if (nanosUntilNextCleanup == -1L || nanosUntilNextCleanup > nanosUntilEviction) {
-          nanosUntilNextCleanup = nanosUntilEviction;
-        }
+      if (longestIdleDurationNs >= this.keepAliveDurationNs
+          || idleConnectionCount > this.maxIdleConnections) {
+        // We've found a connection to evict. Remove it from the list, then close it below (outside
+        // of the synchronized block).
+        connections.remove(longestIdleConnection);
+
+      } else if (idleConnectionCount > 0) {
+        // A connection will be ready to evict soon.
+        return keepAliveDurationNs - longestIdleDurationNs;
+
+      } else if (inUseConnectionCount > 0) {
+        // All connections are in use. It'll be at least the keep alive duration 'til we run again.
+        return keepAliveDurationNs;
+
+      } else {
+        // No connections, idle or in use.
+        return -1;
       }
     }
 
-    if (connectionToEvict != null) {
-      Util.closeQuietly(connectionToEvict.getSocket());
-      // Cleanup again immediately.
-      return 0;
-    } else if (nanosUntilNextCleanup != -1) {
-      // A connection will be ready to evict soon.
-      return nanosUntilNextCleanup;
-    } else if (inUseConnectionCount != 0) {
-      // All connections are in use. It'll be at least the keep alive duration 'til we run again.
-      return keepAliveDurationNs;
-    } else {
-      // No connections, idle or in use.
-      return -1;
-    }
+    Util.closeQuietly(longestIdleConnection.getSocket());
+
+    // Cleanup again immediately.
+    return 0;
   }
 
   void setCleanupRunnableForTest(Runnable cleanupRunnable) {
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/http/StreamAllocation.java b/okhttp/src/main/java/com/squareup/okhttp/internal/http/StreamAllocation.java
index 35c87d8f82..787de7e217 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/http/StreamAllocation.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/http/StreamAllocation.java
@@ -243,8 +243,7 @@ private void deallocate(boolean noNewStreams, boolean released, boolean streamFi
           if (connection.streamCount > 0) {
             routeSelector = null;
           }
-          if (connection.noNewStreams && connection.allocationCount == 0) {
-            connectionPool.remove(connection);
+          if (connection.allocationCount == 0 && connectionPool.connectionBecameIdle(connection)) {
             connectionToClose = connection;
           }
           connection = null;
