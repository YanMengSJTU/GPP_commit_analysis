diff --git a/mockwebserver/src/main/java/com/squareup/okhttp/mockwebserver/MockWebServer.java b/mockwebserver/src/main/java/com/squareup/okhttp/mockwebserver/MockWebServer.java
index 72ee5549de..24eb57de42 100644
--- a/mockwebserver/src/main/java/com/squareup/okhttp/mockwebserver/MockWebServer.java
+++ b/mockwebserver/src/main/java/com/squareup/okhttp/mockwebserver/MockWebServer.java
@@ -15,85 +15,95 @@
  * limitations under the License.
  */
 
-package com.squareup.okhttp.mockwebserver;
-
-import com.squareup.okhttp.Headers;
-import com.squareup.okhttp.HttpUrl;
-import com.squareup.okhttp.Protocol;
-import com.squareup.okhttp.Request;
-import com.squareup.okhttp.Response;
-import com.squareup.okhttp.internal.NamedRunnable;
-import com.squareup.okhttp.internal.Platform;
-import com.squareup.okhttp.internal.Util;
-import com.squareup.okhttp.internal.framed.ErrorCode;
-import com.squareup.okhttp.internal.framed.FramedConnection;
-import com.squareup.okhttp.internal.framed.FramedStream;
-import com.squareup.okhttp.internal.framed.Header;
-import com.squareup.okhttp.internal.framed.Settings;
-import com.squareup.okhttp.internal.http.HttpMethod;
-import com.squareup.okhttp.internal.ws.RealWebSocket;
-import com.squareup.okhttp.internal.ws.WebSocketProtocol;
-import com.squareup.okhttp.ws.WebSocketListener;
-import java.io.IOException;
-import java.net.InetAddress;
-import java.net.InetSocketAddress;
-import java.net.ProtocolException;
-import java.net.Proxy;
-import java.net.ServerSocket;
-import java.net.Socket;
-import java.net.SocketException;
-import java.security.SecureRandom;
-import java.security.cert.CertificateException;
-import java.security.cert.X509Certificate;
-import java.util.ArrayList;
-import java.util.Collections;
-import java.util.Iterator;
-import java.util.List;
-import java.util.Locale;
-import java.util.Set;
-import java.util.concurrent.BlockingQueue;
-import java.util.concurrent.ConcurrentHashMap;
-import java.util.concurrent.CountDownLatch;
-import java.util.concurrent.ExecutorService;
-import java.util.concurrent.Executors;
-import java.util.concurrent.LinkedBlockingDeque;
-import java.util.concurrent.LinkedBlockingQueue;
-import java.util.concurrent.ThreadPoolExecutor;
-import java.util.concurrent.TimeUnit;
-import java.util.concurrent.atomic.AtomicInteger;
-import java.util.logging.Level;
-import java.util.logging.Logger;
-import javax.net.ServerSocketFactory;
-import javax.net.ssl.SSLContext;
-import javax.net.ssl.SSLSocket;
-import javax.net.ssl.SSLSocketFactory;
-import javax.net.ssl.TrustManager;
-import javax.net.ssl.X509TrustManager;
-import okio.Buffer;
-import okio.BufferedSink;
-import okio.BufferedSource;
-import okio.ByteString;
-import okio.Okio;
-import okio.Sink;
-import okio.Timeout;
-import org.junit.rules.TestRule;
-import org.junit.runner.Description;
-import org.junit.runners.model.Statement;
-
-import static com.squareup.okhttp.mockwebserver.SocketPolicy.DISCONNECT_AT_START;
-import static com.squareup.okhttp.mockwebserver.SocketPolicy.DISCONNECT_DURING_REQUEST_BODY;
-import static com.squareup.okhttp.mockwebserver.SocketPolicy.DISCONNECT_DURING_RESPONSE_BODY;
-import static com.squareup.okhttp.mockwebserver.SocketPolicy.FAIL_HANDSHAKE;
-import static java.util.concurrent.TimeUnit.SECONDS;
+package com.squareup.okhttp.mockwebserver; 
+
+import com.squareup.okhttp.Headers; 
+import com.squareup.okhttp.HttpUrl; 
+import com.squareup.okhttp.Protocol; 
+import com.squareup.okhttp.Request; 
+import com.squareup.okhttp.Response; 
+import com.squareup.okhttp.internal.NamedRunnable; 
+import com.squareup.okhttp.internal.Platform; 
+import com.squareup.okhttp.internal.Util; 
+import com.squareup.okhttp.internal.framed.ErrorCode; 
+import com.squareup.okhttp.internal.framed.FramedConnection; 
+import com.squareup.okhttp.internal.framed.FramedStream; 
+import com.squareup.okhttp.internal.framed.Header; 
+import com.squareup.okhttp.internal.framed.Settings; 
+import com.squareup.okhttp.internal.http.HttpMethod; 
+ 
+ 
+ 
+ 
+ 
+import com.squareup.okhttp.internal.ws.RealWebSocket; 
+ 
+import com.squareup.okhttp.internal.ws.WebSocketProtocol; 
+import com.squareup.okhttp.ws.WebSocketListener; 
+import java.io.IOException; 
+import java.net.InetAddress; 
+import java.net.InetSocketAddress; 
+ 
+import java.net.ProtocolException; 
+import java.net.Proxy; 
+import java.net.ServerSocket; 
+import java.net.Socket; 
+import java.net.SocketException; 
+ 
+import java.security.SecureRandom; 
+import java.security.cert.CertificateException; 
+import java.security.cert.X509Certificate; 
+import java.util.ArrayList; 
+import java.util.Collections; 
+import java.util.Iterator; 
+import java.util.List; 
+import java.util.Locale; 
+import java.util.Set; 
+import java.util.concurrent.BlockingQueue; 
+import java.util.concurrent.ConcurrentHashMap; 
+import java.util.concurrent.CountDownLatch; 
+import java.util.concurrent.ExecutorService; 
+import java.util.concurrent.Executors; 
+import java.util.concurrent.LinkedBlockingDeque; 
+import java.util.concurrent.LinkedBlockingQueue; 
+import java.util.concurrent.ThreadPoolExecutor; 
+import java.util.concurrent.TimeUnit; 
+import java.util.concurrent.atomic.AtomicInteger; 
+import java.util.logging.Level; 
+import java.util.logging.Logger; 
+import javax.net.ServerSocketFactory; 
+import javax.net.ssl.SSLContext; 
+import javax.net.ssl.SSLSocket; 
+import javax.net.ssl.SSLSocketFactory; 
+import javax.net.ssl.TrustManager; 
+import javax.net.ssl.X509TrustManager; 
+import okio.Buffer; 
+import okio.BufferedSink; 
+import okio.BufferedSource; 
+import okio.ByteString; 
+import okio.Okio; 
+import okio.Sink; 
+import okio.Timeout; 
+import org.junit.rules.TestRule; 
+import org.junit.runner.Description; 
+import org.junit.runners.model.Statement; 
+
+import static com.squareup.okhttp.mockwebserver.SocketPolicy.DISCONNECT_AT_START; 
+import static com.squareup.okhttp.mockwebserver.SocketPolicy.DISCONNECT_DURING_REQUEST_BODY; 
+import static com.squareup.okhttp.mockwebserver.SocketPolicy.DISCONNECT_DURING_RESPONSE_BODY; 
+import static com.squareup.okhttp.mockwebserver.SocketPolicy.FAIL_HANDSHAKE; 
+import static java.util.concurrent.TimeUnit.SECONDS; 
 
 /**
  * A scriptable web server. Callers supply canned responses and the server
  * replays them upon request in sequence.
  */
-public final class MockWebServer implements TestRule {
+public final  class  MockWebServer  implements TestRule {
+	
+  
+
   private static final X509TrustManager UNTRUSTED_TRUST_MANAGER = new X509TrustManager() {
-    @Override public void checkClientTrusted(X509Certificate[] chain, String authType)
-        throws CertificateException {
+    @Override public void checkClientTrusted(X509Certificate[] chain, String authType) throws CertificateException {
       throw new CertificateException();
     }
 
@@ -106,30 +116,97 @@
     }
   };
 
+	
+
+  
+
   private static final Logger logger = Logger.getLogger(MockWebServer.class.getName());
 
+	
+
+  
+
   private final BlockingQueue<RecordedRequest> requestQueue = new LinkedBlockingQueue<>();
 
-  private final Set<Socket> openClientSockets =
-      Collections.newSetFromMap(new ConcurrentHashMap<Socket, Boolean>());
+	
+
+  
+
+  private final Set<Socket> openClientSockets = Collections.newSetFromMap(new ConcurrentHashMap<Socket, Boolean>());
+
+	
   private final Set<FramedConnection> openFramedConnections =
       Collections.newSetFromMap(new ConcurrentHashMap<FramedConnection, Boolean>());
+	
+  
+
+
+	
+  
+
   private final AtomicInteger requestCount = new AtomicInteger();
+
+	
+  
+
   private long bodyLimit = Long.MAX_VALUE;
+
+	
+  
+
   private ServerSocketFactory serverSocketFactory = ServerSocketFactory.getDefault();
+
+	
+  
+
   private ServerSocket serverSocket;
+
+	
+  
+
   private SSLSocketFactory sslSocketFactory;
+
+	
+  
+
   private ExecutorService executor;
+
+	
+  
+
   private boolean tunnelProxy;
+
+	
+  
+
   private Dispatcher dispatcher = new QueueDispatcher();
 
+	
+
+  
+
   private int port = -1;
+
+	
   private InetSocketAddress inetSocketAddress;
+	
+  
+
+
+	
+  
+
   private boolean protocolNegotiationEnabled = true;
-  private List<Protocol> protocols
-      = Util.immutableList(Protocol.HTTP_2, Protocol.SPDY_3, Protocol.HTTP_1_1);
+
+	
+  
+
+  private List<Protocol> protocols = Util.immutableList(Protocol.HTTP_2, Protocol.SPDY_3, Protocol.HTTP_1_1);
+
+	
 
   private boolean started;
+	
 
   private synchronized void maybeStart() {
     if (started) return;
@@ -139,6 +216,7 @@ private synchronized void maybeStart() {
       throw new RuntimeException(e);
     }
   }
+	
 
   @Override public Statement apply(final Statement base, Description description) {
     return new Statement() {
@@ -156,72 +234,110 @@ private synchronized void maybeStart() {
       }
     };
   }
+	
+
+  
+
+  public void setServerSocketFactory(ServerSocketFactory serverSocketFactory) {
+    if (executor != null) {
+      throw new IllegalStateException("setServerSocketFactory() must be called before start()");
+    }
+    this.serverSocketFactory = serverSocketFactory;
+  }
+
+	
+
+  /**
+   * Returns a URL for connecting to this server.
+   *
+   * @param path the request path, such as "/".
+   */
+  public HttpUrl url(String path) {
+    return new HttpUrl.Builder()
+        .scheme(sslSocketFactory != null ? "https" : "http")
+        .host(getHostName())
+        .port(getPort())
+        .build()
+        .resolve(path);
+  }
+	
+
+  
 
   public int getPort() {
     maybeStart();
     return port;
   }
 
+	
+
+  
+
   public String getHostName() {
     maybeStart();
     return inetSocketAddress.getHostName();
   }
 
+	
+
+  
+
   public Proxy toProxyAddress() {
     maybeStart();
     InetSocketAddress address = new InetSocketAddress(inetSocketAddress.getAddress(), getPort());
     return new Proxy(Proxy.Type.HTTP, address);
   }
 
-  public void setServerSocketFactory(ServerSocketFactory serverSocketFactory) {
-    if (executor != null) {
-      throw new IllegalStateException(
-          "setServerSocketFactory() must be called before start()");
-    }
-    this.serverSocketFactory = serverSocketFactory;
-  }
+	
 
   /**
    * Returns a URL for connecting to this server.
-   *
    * @param path the request path, such as "/".
    */
-  public HttpUrl url(String path) {
-    return new HttpUrl.Builder()
-        .scheme(sslSocketFactory != null ? "https" : "http")
-        .host(getHostName())
-        .port(getPort())
-        .build()
-        .resolve(path);
-  }
+  
+
+
+	
 
   /**
    * Returns a cookie domain for this server. This returns the server's
    * non-loopback host name if it is known. Otherwise this returns ".local" for
    * this server's loopback name.
    */
+  
+
   public String getCookieDomain() {
     String hostName = getHostName();
     return hostName.contains(".") ? hostName : ".local";
   }
 
+	
+
   /**
    * Sets the number of bytes of the POST body to keep in memory to the given
    * limit.
    */
+  
+
   public void setBodyLimit(long maxBodyLength) {
     this.bodyLimit = maxBodyLength;
   }
 
+	
+
   /**
    * Sets whether ALPN is used on incoming HTTPS connections to
    * negotiate a protocol like HTTP/1.1 or HTTP/2. Call this method to disable
    * negotiation and restrict connections to HTTP/1.1.
    */
+  
+
   public void setProtocolNegotiationEnabled(boolean protocolNegotiationEnabled) {
     this.protocolNegotiationEnabled = protocolNegotiationEnabled;
   }
 
+	
+
   /**
    * Indicates the protocols supported by ALPN on incoming HTTPS
    * connections. This list is ignored when
@@ -230,10 +346,12 @@ public void setProtocolNegotiationEnabled(boolean protocolNegotiationEnabled) {
    * @param protocols the protocols to use, in order of preference. The list
    * must contain {@linkplain Protocol#HTTP_1_1}. It must not contain null.
    */
+  
+
   public void setProtocols(List<Protocol> protocols) {
     protocols = Util.immutableList(protocols);
     if (!protocols.contains(Protocol.HTTP_1_1)) {
-      throw new IllegalArgumentException("protocols doesn't contain http/1.1: " + protocols);
+      throw new IllegalArgumentException("protocols doesn\'t contain http/1.1: " + protocols);
     }
     if (protocols.contains(null)) {
       throw new IllegalArgumentException("protocols must not contain null");
@@ -241,17 +359,23 @@ public void setProtocols(List<Protocol> protocols) {
     this.protocols = protocols;
   }
 
+	
+
   /**
    * Serve requests with HTTPS rather than otherwise.
    *
    * @param tunnelProxy true to expect the HTTP CONNECT method before
    * negotiating TLS.
    */
+  
+
   public void useHttps(SSLSocketFactory sslSocketFactory, boolean tunnelProxy) {
     this.sslSocketFactory = sslSocketFactory;
     this.tunnelProxy = tunnelProxy;
   }
 
+	
+
   /**
    * Awaits the next HTTP request, removes it, and returns it. Callers should
    * use this to verify the request was sent as intended. This method will block until the
@@ -259,10 +383,14 @@ public void useHttps(SSLSocketFactory sslSocketFactory, boolean tunnelProxy) {
    *
    * @return the head of the request queue
    */
+  
+
   public RecordedRequest takeRequest() throws InterruptedException {
     return requestQueue.take();
   }
 
+	
+
   /**
    * Awaits the next HTTP request (waiting up to the
    * specified wait time if necessary), removes it, and returns it. Callers should
@@ -274,19 +402,27 @@ public RecordedRequest takeRequest() throws InterruptedException {
    * {@code timeout} parameter
    * @return the head of the request queue
    */
+  
+
   public RecordedRequest takeRequest(long timeout, TimeUnit unit) throws InterruptedException {
     return requestQueue.poll(timeout, unit);
   }
 
+	
+
   /**
    * Returns the number of HTTP requests received thus far by this server. This
    * may exceed the number of HTTP connections when connection reuse is in
    * practice.
    */
+  
+
   public int getRequestCount() {
     return requestCount.get();
   }
 
+	
+
   /**
    * Scripts {@code response} to be returned to a request made in sequence. The
    * first request is served by the first enqueued response; the second request
@@ -295,15 +431,35 @@ public int getRequestCount() {
    * @throws ClassCastException if the default dispatcher has been replaced
    * with {@link #setDispatcher(Dispatcher)}.
    */
+  
+
   public void enqueue(MockResponse response) {
     ((QueueDispatcher) dispatcher).enqueueResponse(response.clone());
   }
 
+	
+
+  /** @deprecated Use {@link #start()}. */
+  
+
+
+	
+
+  /** @deprecated Use {@link #start(int)}. */
+  
+
+
+	
+
   /** Equivalent to {@code start(0)}. */
+  
+
   public void start() throws IOException {
     start(0);
   }
 
+	
+
   /**
    * Starts the server on the loopback interface for the given port.
    *
@@ -311,10 +467,14 @@ public void start() throws IOException {
    * tests should always use port 0 to avoid flakiness when a specific port
    * is unavailable.
    */
+  
+
   public void start(int port) throws IOException {
     start(InetAddress.getByName("localhost"), port);
   }
 
+	
+
   /**
    * Starts the server on the given address and port.
    *
@@ -326,6 +486,7 @@ public void start(int port) throws IOException {
   public void start(InetAddress inetAddress, int port) throws IOException {
     start(new InetSocketAddress(inetAddress, port));
   }
+	
 
   /**
    * Starts the server and binds to the given socket address.
@@ -387,15 +548,18 @@ private void acceptConnections() throws Exception {
       }
     });
   }
+	
 
-  public synchronized void shutdown() throws IOException {
-    if (!started) return;
-    if (serverSocket == null) throw new IllegalStateException("shutdown() before start()");
+  
 
-    // Cause acceptConnections() to break out.
+  public synchronized void shutdown() throws IOException {
+    if (!started) {
+      return;
+    }
+    if (serverSocket == null) {
+      throw new IllegalStateException("shutdown() before start()");
+    }
     serverSocket.close();
-
-    // Await shutdown.
     try {
       if (!executor.awaitTermination(5, TimeUnit.SECONDS)) {
         throw new IOException("Gave up waiting for executor to shut down");
@@ -405,6 +569,10 @@ public synchronized void shutdown() throws IOException {
     }
   }
 
+	
+
+  
+
   private void serveConnection(final Socket raw) {
     executor.execute(new NamedRunnable("MockWebServer %s", raw.getRemoteSocketAddress()) {
       int sequenceNumber = 0;
@@ -413,11 +581,9 @@ private void serveConnection(final Socket raw) {
         try {
           processConnection();
         } catch (IOException e) {
-          logger.info(
-              MockWebServer.this + " connection from " + raw.getInetAddress() + " failed: " + e);
+          logger.info(MockWebServer.this + " connection from " + raw.getInetAddress() + " failed: " + e);
         } catch (Exception e) {
-          logger.log(Level.SEVERE,
-              MockWebServer.this + " connection from " + raw.getInetAddress() + " crashed", e);
+          logger.log(Level.SEVERE, MockWebServer.this + " connection from " + raw.getInetAddress() + " crashed", e);
         }
       }
 
@@ -434,18 +600,14 @@ public void processConnection() throws Exception {
             processHandshakeFailure(raw);
             return;
           }
-          socket = sslSocketFactory.createSocket(raw, raw.getInetAddress().getHostAddress(),
-              raw.getPort(), true);
+          socket = sslSocketFactory.createSocket(raw, raw.getInetAddress().getHostAddress(), raw.getPort(), true);
           SSLSocket sslSocket = (SSLSocket) socket;
           sslSocket.setUseClientMode(false);
           openClientSockets.add(socket);
-
           if (protocolNegotiationEnabled) {
             Platform.get().configureTlsExtensions(sslSocket, null, protocols);
           }
-
           sslSocket.startHandshake();
-
           if (protocolNegotiationEnabled) {
             String protocolString = Platform.get().getSelectedProtocol(sslSocket);
             protocol = protocolString != null ? Protocol.get(protocolString) : Protocol.HTTP_1_1;
@@ -454,32 +616,20 @@ public void processConnection() throws Exception {
         } else {
           socket = raw;
         }
-
         if (protocol != Protocol.HTTP_1_1) {
           FramedSocketHandler framedSocketListener = new FramedSocketHandler(socket, protocol);
-          FramedConnection framedConnection = new FramedConnection.Builder(false)
-              .socket(socket)
-              .protocol(protocol)
-              .listener(framedSocketListener)
-              .build();
+          FramedConnection framedConnection = new FramedConnection.Builder(false).socket(socket).protocol(protocol).listener(framedSocketListener).build();
           openFramedConnections.add(framedConnection);
           openClientSockets.remove(socket);
           return;
         }
-
         BufferedSource source = Okio.buffer(Okio.source(socket));
         BufferedSink sink = Okio.buffer(Okio.sink(socket));
-
         while (processOneRequest(socket, source, sink)) {
         }
-
         if (sequenceNumber == 0) {
-          logger.warning(MockWebServer.this
-              + " connection from "
-              + raw.getInetAddress()
-              + " didn't make a request");
+          logger.warning(MockWebServer.this + " connection from " + raw.getInetAddress() + " didn\'t make a request");
         }
-
         source.close();
         sink.close();
         socket.close();
@@ -498,7 +648,9 @@ private void createTunnel() throws IOException, InterruptedException {
           if (!processOneRequest(raw, source, sink)) {
             throw new IllegalStateException("Tunnel without any CONNECT!");
           }
-          if (socketPolicy == SocketPolicy.UPGRADE_TO_SSL_AT_END) return;
+          if (socketPolicy == SocketPolicy.UPGRADE_TO_SSL_AT_END) {
+            return;
+          }
         }
       }
 
@@ -506,28 +658,26 @@ private void createTunnel() throws IOException, InterruptedException {
        * Reads a request and writes its response. Returns true if further calls should be attempted
        * on the socket.
        */
-      private boolean processOneRequest(Socket socket, BufferedSource source, BufferedSink sink)
-          throws IOException, InterruptedException {
+      private boolean processOneRequest(Socket socket, BufferedSource source, BufferedSink sink) throws IOException, InterruptedException {
         RecordedRequest request = readRequest(socket, source, sink, sequenceNumber);
-        if (request == null) return false;
-
+        if (request == null) {
+          return false;
+        }
         requestCount.incrementAndGet();
         requestQueue.add(request);
-
         MockResponse response = dispatcher.dispatch(request);
         if (response.getSocketPolicy() == SocketPolicy.DISCONNECT_AFTER_REQUEST) {
           socket.close();
           return false;
         }
         if (response.getSocketPolicy() == SocketPolicy.NO_RESPONSE) {
-          // This read should block until the socket is closed. (Because nobody is writing.)
-          if (source.exhausted()) return false;
+          if (source.exhausted()) {
+            return false;
+          }
           throw new ProtocolException("unexpected data");
         }
-
         boolean reuseSocket = true;
-        boolean requestWantsWebSockets = "Upgrade".equalsIgnoreCase(request.getHeader("Connection"))
-            && "websocket".equalsIgnoreCase(request.getHeader("Upgrade"));
+        boolean requestWantsWebSockets = "Upgrade".equalsIgnoreCase(request.getHeader("Connection")) && "websocket".equalsIgnoreCase(request.getHeader("Upgrade"));
         boolean responseWantsWebSockets = response.getWebSocketListener() != null;
         if (requestWantsWebSockets && responseWantsWebSockets) {
           handleWebSocketUpgrade(socket, source, sink, request, response);
@@ -535,60 +685,68 @@ private boolean processOneRequest(Socket socket, BufferedSource source, Buffered
         } else {
           writeHttpResponse(socket, sink, response);
         }
-
         if (logger.isLoggable(Level.INFO)) {
-          logger.info(MockWebServer.this + " received request: " + request
-              + " and responded: " + response);
+          logger.info(MockWebServer.this + " received request: " + request + " and responded: " + response);
         }
-
         if (response.getSocketPolicy() == SocketPolicy.DISCONNECT_AT_END) {
           socket.close();
           return false;
-        } else if (response.getSocketPolicy() == SocketPolicy.SHUTDOWN_INPUT_AT_END) {
-          socket.shutdownInput();
-        } else if (response.getSocketPolicy() == SocketPolicy.SHUTDOWN_OUTPUT_AT_END) {
-          socket.shutdownOutput();
+        } else {
+          if (response.getSocketPolicy() == SocketPolicy.SHUTDOWN_INPUT_AT_END) {
+            socket.shutdownInput();
+          } else {
+            if (response.getSocketPolicy() == SocketPolicy.SHUTDOWN_OUTPUT_AT_END) {
+              socket.shutdownOutput();
+            }
+          }
         }
-
         sequenceNumber++;
         return reuseSocket;
       }
     });
   }
 
+	
+
+  
+
   private void processHandshakeFailure(Socket raw) throws Exception {
     SSLContext context = SSLContext.getInstance("TLS");
     context.init(null, new TrustManager[] { UNTRUSTED_TRUST_MANAGER }, new SecureRandom());
     SSLSocketFactory sslSocketFactory = context.getSocketFactory();
-    SSLSocket socket = (SSLSocket) sslSocketFactory.createSocket(
-        raw, raw.getInetAddress().getHostAddress(), raw.getPort(), true);
+    SSLSocket socket = (SSLSocket) sslSocketFactory.createSocket(raw, raw.getInetAddress().getHostAddress(), raw.getPort(), true);
     try {
-      socket.startHandshake(); // we're testing a handshake failure
+      socket.startHandshake();
       throw new AssertionError();
     } catch (IOException expected) {
     }
     socket.close();
   }
 
-  private void dispatchBookkeepingRequest(int sequenceNumber, Socket socket)
-      throws InterruptedException {
+	
+
+  
+
+  private void dispatchBookkeepingRequest(int sequenceNumber, Socket socket) throws InterruptedException {
     requestCount.incrementAndGet();
     dispatcher.dispatch(new RecordedRequest(null, null, null, -1, null, sequenceNumber, socket));
   }
 
+	
+
   /** @param sequenceNumber the index of this request on this connection. */
-  private RecordedRequest readRequest(Socket socket, BufferedSource source, BufferedSink sink,
-      int sequenceNumber) throws IOException {
+  
+
+  private RecordedRequest readRequest(Socket socket, BufferedSource source, BufferedSink sink, int sequenceNumber) throws IOException {
     String request;
     try {
       request = source.readUtf8LineStrict();
     } catch (IOException streamIsClosed) {
-      return null; // no request because we closed the stream
+      return null;
     }
     if (request.length() == 0) {
-      return null; // no request because the stream is exhausted
+      return null;
     }
-
     Headers.Builder headers = new Headers.Builder();
     long contentLength = -1;
     boolean chunked = false;
@@ -600,23 +758,19 @@ private RecordedRequest readRequest(Socket socket, BufferedSource source, Buffer
       if (contentLength == -1 && lowercaseHeader.startsWith("content-length:")) {
         contentLength = Long.parseLong(header.substring(15).trim());
       }
-      if (lowercaseHeader.startsWith("transfer-encoding:")
-          && lowercaseHeader.substring(18).trim().equals("chunked")) {
+      if (lowercaseHeader.startsWith("transfer-encoding:") && lowercaseHeader.substring(18).trim().equals("chunked")) {
         chunked = true;
       }
-      if (lowercaseHeader.startsWith("expect:")
-          && lowercaseHeader.substring(7).trim().equals("100-continue")) {
+      if (lowercaseHeader.startsWith("expect:") && lowercaseHeader.substring(7).trim().equals("100-continue")) {
         expectContinue = true;
       }
     }
-
     if (expectContinue) {
       sink.writeUtf8("HTTP/1.1 100 Continue\r\n");
       sink.writeUtf8("Content-Length: 0\r\n");
       sink.writeUtf8("\r\n");
       sink.flush();
     }
-
     boolean hasBody = false;
     TruncatingBuffer requestBody = new TruncatingBuffer(bodyLimit);
     List<Integer> chunkSizes = new ArrayList<>();
@@ -624,90 +778,70 @@ private RecordedRequest readRequest(Socket socket, BufferedSource source, Buffer
     if (contentLength != -1) {
       hasBody = contentLength > 0;
       throttledTransfer(policy, socket, source, Okio.buffer(requestBody), contentLength, true);
-    } else if (chunked) {
-      hasBody = true;
-      while (true) {
-        int chunkSize = Integer.parseInt(source.readUtf8LineStrict().trim(), 16);
-        if (chunkSize == 0) {
+    } else {
+      if (chunked) {
+        hasBody = true;
+        while (true) {
+          int chunkSize = Integer.parseInt(source.readUtf8LineStrict().trim(), 16);
+          if (chunkSize == 0) {
+            readEmptyLine(source);
+            break;
+          }
+          chunkSizes.add(chunkSize);
+          throttledTransfer(policy, socket, source, Okio.buffer(requestBody), chunkSize, true);
           readEmptyLine(source);
-          break;
         }
-        chunkSizes.add(chunkSize);
-        throttledTransfer(policy, socket, source, Okio.buffer(requestBody), chunkSize, true);
-        readEmptyLine(source);
       }
     }
-
     String method = request.substring(0, request.indexOf(' '));
     if (hasBody && !HttpMethod.permitsRequestBody(method)) {
       throw new IllegalArgumentException("Request must not have a body: " + request);
     }
-
-    return new RecordedRequest(request, headers.build(), chunkSizes, requestBody.receivedByteCount,
-        requestBody.buffer, sequenceNumber, socket);
+    return new RecordedRequest(request, headers.build(), chunkSizes, requestBody.receivedByteCount, requestBody.buffer, sequenceNumber, socket);
   }
 
-  private void handleWebSocketUpgrade(Socket socket, BufferedSource source, BufferedSink sink,
-      RecordedRequest request, MockResponse response) throws IOException {
+	
+
+  
+
+  private void handleWebSocketUpgrade(Socket socket, BufferedSource source, BufferedSink sink, RecordedRequest request, MockResponse response) throws IOException {
     String key = request.getHeader("Sec-WebSocket-Key");
     String acceptKey = Util.shaBase64(key + WebSocketProtocol.ACCEPT_MAGIC);
     response.setHeader("Sec-WebSocket-Accept", acceptKey);
-
     writeHttpResponse(socket, sink, response);
-
     final WebSocketListener listener = response.getWebSocketListener();
     final CountDownLatch connectionClose = new CountDownLatch(1);
-
-    ThreadPoolExecutor replyExecutor =
-        new ThreadPoolExecutor(1, 1, 1, SECONDS, new LinkedBlockingDeque<Runnable>(),
-            Util.threadFactory(String.format("MockWebServer %s WebSocket", request.getPath()),
-                true));
+    ThreadPoolExecutor replyExecutor = new ThreadPoolExecutor(1, 1, 1, SECONDS, new LinkedBlockingDeque<Runnable>(), Util.threadFactory(String.format("MockWebServer %s WebSocket", request.getPath()), true));
     replyExecutor.allowCoreThreadTimeOut(true);
-    final RealWebSocket webSocket =
-        new RealWebSocket(false /* is server */, source, sink, new SecureRandom(), replyExecutor,
-            listener, request.getPath()) {
-          @Override protected void close() throws IOException {
-            connectionClose.countDown();
-          }
-        };
-
-    // Adapt the request and response into our Request and Response domain model.
+    final RealWebSocket webSocket = new RealWebSocket(false, source, sink, new SecureRandom(), replyExecutor, listener, request.getPath()) {
+      @Override protected void close() throws IOException {
+        connectionClose.countDown();
+      }
+    };
     String scheme = request.getTlsVersion() != null ? "https" : "http";
-    String authority = request.getHeader("Host"); // Has host and port.
-    final Request fancyRequest = new Request.Builder()
-        .url(scheme + "://" + authority + "/")
-        .headers(request.getHeaders())
-        .build();
-    final Response fancyResponse = new Response.Builder()
-        .code(Integer.parseInt(response.getStatus().split(" ")[1]))
-        .message(response.getStatus().split(" ", 3)[2])
-        .headers(response.getHeaders())
-        .request(fancyRequest)
-        .protocol(Protocol.HTTP_1_1)
-        .build();
-
+    String authority = request.getHeader("Host");
+    final Request fancyRequest = new Request.Builder().url(scheme + "://" + authority + "/").headers(request.getHeaders()).build();
+    final Response fancyResponse = new Response.Builder().code(Integer.parseInt(response.getStatus().split(" ")[1])).message(response.getStatus().split(" ", 3)[2]).headers(response.getHeaders()).request(fancyRequest).protocol(Protocol.HTTP_1_1).build();
     listener.onOpen(webSocket, fancyResponse);
-
     while (webSocket.readMessage()) {
     }
-
-    // Even if messages are no longer being read we need to wait for the connection close signal.
     try {
       connectionClose.await();
     } catch (InterruptedException e) {
       throw new RuntimeException(e);
     }
-
     replyExecutor.shutdown();
     Util.closeQuietly(sink);
     Util.closeQuietly(source);
   }
 
-  private void writeHttpResponse(Socket socket, BufferedSink sink, MockResponse response)
-      throws IOException {
+	
+
+  
+
+  private void writeHttpResponse(Socket socket, BufferedSink sink, MockResponse response) throws IOException {
     sink.writeUtf8(response.getStatus());
     sink.writeUtf8("\r\n");
-
     Headers headers = response.getHeaders();
     for (int i = 0, size = headers.size(); i < size; i++) {
       sink.writeUtf8(headers.name(i));
@@ -717,13 +851,18 @@ private void writeHttpResponse(Socket socket, BufferedSink sink, MockResponse re
     }
     sink.writeUtf8("\r\n");
     sink.flush();
-
     Buffer body = response.getBody();
-    if (body == null) return;
+    if (body == null) {
+      return;
+    }
     sleepIfDelayed(response);
     throttledTransfer(response, socket, body, sink, body.size(), false);
   }
 
+	
+
+  
+
   private void sleepIfDelayed(MockResponse response) {
     long delayMs = response.getBodyDelay(TimeUnit.MILLISECONDS);
     if (delayMs != 0) {
@@ -735,6 +874,8 @@ private void sleepIfDelayed(MockResponse response) {
     }
   }
 
+	
+
   /**
    * Transfer bytes from {@code source} to {@code sink} until either {@code byteCount}
    * bytes have been transferred or {@code source} is exhausted. The transfer is
@@ -787,71 +928,137 @@ private void throttledTransfer(MockResponse policy, Socket socket, BufferedSourc
       }
     }
   }
+	
+
+  /**
+   * Transfer bytes from {@code source} to {@code sink} until either {@code byteCount}
+   * bytes have been transferred or {@code source} is exhausted. The transfer is
+   * throttled according to {@code throttlePolicy}.
+   */
+  
+
+
+	
+
+  
 
   private void readEmptyLine(BufferedSource source) throws IOException {
     String line = source.readUtf8LineStrict();
-    if (line.length() != 0) throw new IllegalStateException("Expected empty but was: " + line);
+    if (line.length() != 0) {
+      throw new IllegalStateException("Expected empty but was: " + line);
+    }
   }
 
+	
+
   /**
    * Sets the dispatcher used to match incoming requests to mock responses.
    * The default dispatcher simply serves a fixed sequence of responses from
    * a {@link #enqueue(MockResponse) queue}; custom dispatchers can vary the
    * response based on timing or the content of the request.
    */
+  
+
   public void setDispatcher(Dispatcher dispatcher) {
-    if (dispatcher == null) throw new NullPointerException();
+    if (dispatcher == null) {
+      throw new NullPointerException();
+    }
     this.dispatcher = dispatcher;
   }
 
+	
+
+  
+
   @Override public String toString() {
     return "MockWebServer[" + port + "]";
   }
 
+	
+
   /** A buffer wrapper that drops data after {@code bodyLimit} bytes. */
-  private static class TruncatingBuffer implements Sink {
-    private final Buffer buffer = new Buffer();
-    private long remainingByteCount;
-    private long receivedByteCount;
+  private static  class  TruncatingBuffer  implements Sink {
+		
+    
 
-    TruncatingBuffer(long bodyLimit) {
-      remainingByteCount = bodyLimit;
-    }
+  private final Buffer buffer = new Buffer();
 
-    @Override public void write(Buffer source, long byteCount) throws IOException {
-      long toRead = Math.min(remainingByteCount, byteCount);
-      if (toRead > 0) {
-        source.read(buffer, toRead);
-      }
-      long toSkip = byteCount - toRead;
-      if (toSkip > 0) {
-        source.skip(toSkip);
-      }
-      remainingByteCount -= toRead;
-      receivedByteCount += byteCount;
-    }
+		
+    
 
-    @Override public void flush() throws IOException {
-    }
+  private long remainingByteCount;
 
-    @Override public Timeout timeout() {
-      return Timeout.NONE;
-    }
+		
+    
+
+  private long receivedByteCount;
+
+		
+
+    
+
+  TruncatingBuffer(long bodyLimit) {
+    remainingByteCount = bodyLimit;
+  }
+
+		
 
-    @Override public void close() throws IOException {
+    
+
+  @Override public void write(Buffer source, long byteCount) throws IOException {
+    long toRead = Math.min(remainingByteCount, byteCount);
+    if (toRead > 0) {
+      source.read(buffer, toRead);
+    }
+    long toSkip = byteCount - toRead;
+    if (toSkip > 0) {
+      source.skip(toSkip);
     }
+    remainingByteCount -= toRead;
+    receivedByteCount += byteCount;
+  }
+
+		
+
+    
+
+  @Override public void flush() throws IOException {
   }
 
+		
+
+    
+
+  @Override public Timeout timeout() {
+    return Timeout.NONE;
+  }
+
+		
+
+    
+
+  @Override public void close() throws IOException {
+  }
+
+
+	}
+	
+
   /** Processes HTTP requests layered over framed protocols. */
-  private class FramedSocketHandler extends FramedConnection.Listener {
+  private  class  FramedSocketHandler  extends FramedConnection.Listener {
+		
     private final Socket socket;
+		
     private final Protocol protocol;
+		
     private final AtomicInteger sequenceNumber = new AtomicInteger();
+		
 
     private FramedSocketHandler(Socket socket, Protocol protocol) {
       this.socket = socket;
       this.protocol = protocol;
     }
+		
 
     @Override public void onStream(FramedStream stream) throws IOException {
       RecordedRequest request = readRequest(stream);
@@ -868,6 +1075,7 @@ private FramedSocketHandler(Socket socket, Protocol protocol) {
             + " and responded: " + response + " protocol is " + protocol.toString());
       }
     }
+		
 
     private RecordedRequest readRequest(FramedStream stream) throws IOException {
       List<Header> streamHeaders = stream.getRequestHeaders();
@@ -904,6 +1112,7 @@ private RecordedRequest readRequest(FramedStream stream) throws IOException {
       return new RecordedRequest(requestLine, httpHeaders.build(), chunkSizes, body.size(), body,
           sequenceNumber.getAndIncrement(), socket);
     }
+		
 
     private void writeResponse(FramedStream stream, MockResponse response) throws IOException {
       Settings settings = response.getSettings();
@@ -942,6 +1151,7 @@ private void writeResponse(FramedStream stream, MockResponse response) throws IO
         stream.close(ErrorCode.NO_ERROR);
       }
     }
+		
 
     private void pushPromises(FramedStream stream, List<PushPromise> promises) throws IOException {
       for (PushPromise pushPromise : promises) {
@@ -965,5 +1175,50 @@ private void pushPromises(FramedStream stream, List<PushPromise> promises) throw
         writeResponse(pushedStream, pushPromise.getResponse());
       }
     }
-  }
+
+	}
+	
+
+  /** Processes HTTP requests layered over SPDY/3. */
+      SpdySocketHandler   {
+		
+    
+
+
+		
+    
+
+
+		
+    
+
+
+		
+
+    
+
+
+		
+
+    
+
+
+		
+
+    
+
+
+		
+
+    
+
+
+		
+
+    
+
+
+
+	}
+
 }
diff --git a/mockwebserver/src/main/java/com/squareup/okhttp/mockwebserver/SocketPolicy.java b/mockwebserver/src/main/java/com/squareup/okhttp/mockwebserver/SocketPolicy.java
index f71f33df1f..8992c5c48b 100644
--- a/mockwebserver/src/main/java/com/squareup/okhttp/mockwebserver/SocketPolicy.java
+++ b/mockwebserver/src/main/java/com/squareup/okhttp/mockwebserver/SocketPolicy.java
@@ -13,67 +13,46 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-
 package com.squareup.okhttp.mockwebserver;
 
 /** What should be done with the incoming socket. */
 public enum SocketPolicy {
 
-  /**
+    /**
    * Keep the socket open after the response. This is the default HTTP/1.1
    * behavior.
    */
-  KEEP_OPEN,
-
-  /**
+    KEEP_OPEN(), /**
    * Close the socket after the response. This is the default HTTP/1.0
    * behavior.
    */
-  DISCONNECT_AT_END,
-
-  /**
+    DISCONNECT_AT_END(), /**
    * Wrap the socket with SSL at the completion of this request/response pair.
    * Used for CONNECT messages to tunnel SSL over an HTTP proxy.
    */
-  UPGRADE_TO_SSL_AT_END,
-
-  /**
+    UPGRADE_TO_SSL_AT_END(), /**
    * Request immediate close of connection without even reading the request. Use
    * to simulate buggy SSL servers closing connections in response to
    * unrecognized TLS extensions.
    */
-  DISCONNECT_AT_START,
-
-  /**
+    DISCONNECT_AT_START(), /**
    * Close connection after reading the request but before writing the response.
    * Use this to simulate late connection pool failures.
    */
-  DISCONNECT_AFTER_REQUEST,
-
-  /** Close connection after reading half of the request body (if present). */
-  DISCONNECT_DURING_REQUEST_BODY,
-
-  /** Close connection after writing half of the response body (if present). */
-  DISCONNECT_DURING_RESPONSE_BODY,
-
-  /** Don't trust the client during the SSL handshake. */
-  FAIL_HANDSHAKE,
-
-  /**
+    DISCONNECT_AFTER_REQUEST(), /** Close connection after reading half of the request body (if present). */
+    DISCONNECT_DURING_REQUEST_BODY(), /** Close connection after writing half of the response body (if present). */
+    DISCONNECT_DURING_RESPONSE_BODY(), /** Don't trust the client during the SSL handshake. */
+    FAIL_HANDSHAKE(), /**
    * Shutdown the socket input after sending the response. For testing bad
    * behavior.
    */
-  SHUTDOWN_INPUT_AT_END,
-
-  /**
+    SHUTDOWN_INPUT_AT_END(), /**
    * Shutdown the socket output after sending the response. For testing bad
    * behavior.
    */
-  SHUTDOWN_OUTPUT_AT_END,
-
-  /**
+    SHUTDOWN_OUTPUT_AT_END(), /**
    * Don't respond to the request but keep the socket open. For testing
    * read response header timeout issue.
    */
-  NO_RESPONSE
+    NO_RESPONSE()
 }
diff --git a/okhttp-tests/src/test/java/com/squareup/okhttp/URLConnectionTest.java b/okhttp-tests/src/test/java/com/squareup/okhttp/URLConnectionTest.java
index 9c384a5211..bc9d6e00b2 100644
--- a/okhttp-tests/src/test/java/com/squareup/okhttp/URLConnectionTest.java
+++ b/okhttp-tests/src/test/java/com/squareup/okhttp/URLConnectionTest.java
@@ -12,3446 +12,3257 @@
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the License for the specific language governing permissions and
  * limitations under the License.
- */
-
-package com.squareup.okhttp;
-
-import com.squareup.okhttp.internal.Internal;
-import com.squareup.okhttp.internal.RecordingAuthenticator;
-import com.squareup.okhttp.internal.RecordingOkAuthenticator;
-import com.squareup.okhttp.internal.SingleInetAddressDns;
-import com.squareup.okhttp.internal.SslContextBuilder;
-import com.squareup.okhttp.internal.Util;
-import com.squareup.okhttp.internal.Version;
-import com.squareup.okhttp.mockwebserver.MockResponse;
-import com.squareup.okhttp.mockwebserver.MockWebServer;
-import com.squareup.okhttp.mockwebserver.RecordedRequest;
-import com.squareup.okhttp.mockwebserver.SocketPolicy;
-import com.squareup.okhttp.testing.RecordingHostnameVerifier;
-import java.io.IOException;
-import java.io.InputStream;
-import java.io.OutputStream;
-import java.net.Authenticator;
-import java.net.ConnectException;
-import java.net.HttpRetryException;
-import java.net.HttpURLConnection;
-import java.net.InetAddress;
-import java.net.ProtocolException;
-import java.net.Proxy;
-import java.net.ProxySelector;
-import java.net.ServerSocket;
-import java.net.Socket;
-import java.net.SocketAddress;
-import java.net.SocketTimeoutException;
-import java.net.URI;
-import java.net.URL;
-import java.net.URLConnection;
-import java.net.UnknownHostException;
-import java.security.cert.CertificateException;
-import java.security.cert.X509Certificate;
-import java.util.ArrayList;
-import java.util.Arrays;
-import java.util.Collections;
-import java.util.EnumSet;
-import java.util.LinkedHashSet;
-import java.util.List;
-import java.util.Map;
-import java.util.Random;
-import java.util.Set;
-import java.util.concurrent.TimeUnit;
-import java.util.zip.GZIPInputStream;
-import javax.net.ServerSocketFactory;
-import javax.net.SocketFactory;
-import javax.net.ssl.HttpsURLConnection;
-import javax.net.ssl.SSLContext;
-import javax.net.ssl.SSLException;
-import javax.net.ssl.SSLHandshakeException;
-import javax.net.ssl.SSLSocketFactory;
-import javax.net.ssl.TrustManager;
-import javax.net.ssl.X509TrustManager;
-import okio.Buffer;
-import okio.BufferedSink;
-import okio.GzipSink;
-import okio.Okio;
-import org.junit.After;
-import org.junit.Before;
-import org.junit.Ignore;
-import org.junit.Rule;
-import org.junit.Test;
-import org.junit.rules.TemporaryFolder;
-
-import static com.squareup.okhttp.internal.Util.UTF_8;
-import static com.squareup.okhttp.internal.http.OkHeaders.SELECTED_PROTOCOL;
-import static com.squareup.okhttp.internal.http.StatusLine.HTTP_PERM_REDIRECT;
-import static com.squareup.okhttp.internal.http.StatusLine.HTTP_TEMP_REDIRECT;
-import static com.squareup.okhttp.mockwebserver.SocketPolicy.DISCONNECT_AT_END;
-import static com.squareup.okhttp.mockwebserver.SocketPolicy.DISCONNECT_AT_START;
-import static com.squareup.okhttp.mockwebserver.SocketPolicy.SHUTDOWN_INPUT_AT_END;
-import static com.squareup.okhttp.mockwebserver.SocketPolicy.SHUTDOWN_OUTPUT_AT_END;
-import static java.util.concurrent.TimeUnit.MILLISECONDS;
-import static java.util.concurrent.TimeUnit.NANOSECONDS;
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertFalse;
-import static org.junit.Assert.assertNotNull;
-import static org.junit.Assert.assertNull;
-import static org.junit.Assert.assertTrue;
-import static org.junit.Assert.fail;
-
-/** Android's URLConnectionTest. */
-public final class URLConnectionTest {
-  @Rule public final MockWebServer server = new MockWebServer();
-  @Rule public final MockWebServer server2 = new MockWebServer();
-  @Rule public final TemporaryFolder tempDir = new TemporaryFolder();
-
-  private SSLContext sslContext = SslContextBuilder.localhost();
-  private OkUrlFactory client;
-  private HttpURLConnection connection;
-  private Cache cache;
-
-  @Before public void setUp() throws Exception {
-    server.setProtocolNegotiationEnabled(false);
-    client = new OkUrlFactory(new OkHttpClient());
-  }
-
-  @After public void tearDown() throws Exception {
-    Authenticator.setDefault(null);
-    System.clearProperty("proxyHost");
-    System.clearProperty("proxyPort");
-    System.clearProperty("http.agent");
-    System.clearProperty("http.proxyHost");
-    System.clearProperty("http.proxyPort");
-    System.clearProperty("https.proxyHost");
-    System.clearProperty("https.proxyPort");
-    if (cache != null) {
-      cache.delete();
-    }
-  }
-
-  @Test public void requestHeaders() throws IOException, InterruptedException {
-    server.enqueue(new MockResponse());
-
-    connection = client.open(server.url("/").url());
-    connection.addRequestProperty("D", "e");
-    connection.addRequestProperty("D", "f");
-    assertEquals("f", connection.getRequestProperty("D"));
-    assertEquals("f", connection.getRequestProperty("d"));
-    Map<String, List<String>> requestHeaders = connection.getRequestProperties();
-    assertEquals(newSet("e", "f"), new LinkedHashSet<>(requestHeaders.get("D")));
-    assertEquals(newSet("e", "f"), new LinkedHashSet<>(requestHeaders.get("d")));
-    try {
-      requestHeaders.put("G", Arrays.asList("h"));
-      fail("Modified an unmodifiable view.");
-    } catch (UnsupportedOperationException expected) {
-    }
-    try {
-      requestHeaders.get("D").add("i");
-      fail("Modified an unmodifiable view.");
-    } catch (UnsupportedOperationException expected) {
-    }
-    try {
-      connection.setRequestProperty(null, "j");
-      fail();
-    } catch (NullPointerException expected) {
-    }
-    try {
-      connection.addRequestProperty(null, "k");
-      fail();
-    } catch (NullPointerException expected) {
-    }
-    connection.setRequestProperty("NullValue", null);
-    assertNull(connection.getRequestProperty("NullValue"));
-    connection.addRequestProperty("AnotherNullValue", null);
-    assertNull(connection.getRequestProperty("AnotherNullValue"));
-
-    connection.getResponseCode();
-    RecordedRequest request = server.takeRequest();
-    assertEquals(Arrays.asList("e", "f"), request.getHeaders().values("D"));
-    assertNull(request.getHeader("NullValue"));
-    assertNull(request.getHeader("AnotherNullValue"));
-    assertNull(request.getHeader("G"));
-    assertNull(request.getHeader("null"));
-
-    try {
-      connection.addRequestProperty("N", "o");
-      fail("Set header after connect");
-    } catch (IllegalStateException expected) {
-    }
-    try {
-      connection.setRequestProperty("P", "q");
-      fail("Set header after connect");
-    } catch (IllegalStateException expected) {
-    }
-    try {
-      connection.getRequestProperties();
-      fail();
-    } catch (IllegalStateException expected) {
-    }
-  }
-
-  @Test public void getRequestPropertyReturnsLastValue() throws Exception {
-    connection = client.open(server.url("/").url());
-    connection.addRequestProperty("A", "value1");
-    connection.addRequestProperty("A", "value2");
-    assertEquals("value2", connection.getRequestProperty("A"));
-  }
-
-  @Test public void responseHeaders() throws IOException, InterruptedException {
-    server.enqueue(new MockResponse().setStatus("HTTP/1.0 200 Fantastic")
-        .addHeader("A: c")
-        .addHeader("B: d")
-        .addHeader("A: e")
-        .setChunkedBody("ABCDE\nFGHIJ\nKLMNO\nPQR", 8));
-
-    connection = client.open(server.url("/").url());
-    assertEquals(200, connection.getResponseCode());
-    assertEquals("Fantastic", connection.getResponseMessage());
-    assertEquals("HTTP/1.0 200 Fantastic", connection.getHeaderField(null));
-    Map<String, List<String>> responseHeaders = connection.getHeaderFields();
-    assertEquals(Arrays.asList("HTTP/1.0 200 Fantastic"), responseHeaders.get(null));
-    assertEquals(newSet("c", "e"), new LinkedHashSet<>(responseHeaders.get("A")));
-    assertEquals(newSet("c", "e"), new LinkedHashSet<>(responseHeaders.get("a")));
-    try {
-      responseHeaders.put("N", Arrays.asList("o"));
-      fail("Modified an unmodifiable view.");
-    } catch (UnsupportedOperationException expected) {
-    }
-    try {
-      responseHeaders.get("A").add("f");
-      fail("Modified an unmodifiable view.");
-    } catch (UnsupportedOperationException expected) {
-    }
-    assertEquals("A", connection.getHeaderFieldKey(0));
-    assertEquals("c", connection.getHeaderField(0));
-    assertEquals("B", connection.getHeaderFieldKey(1));
-    assertEquals("d", connection.getHeaderField(1));
-    assertEquals("A", connection.getHeaderFieldKey(2));
-    assertEquals("e", connection.getHeaderField(2));
-    connection.getInputStream().close();
-  }
-
-  @Test public void serverSendsInvalidResponseHeaders() throws Exception {
-    server.enqueue(new MockResponse().setStatus("HTP/1.1 200 OK"));
-
-    connection = client.open(server.url("/").url());
-    try {
-      connection.getResponseCode();
-      fail();
-    } catch (IOException expected) {
-    }
-  }
-
-  @Test public void serverSendsInvalidCodeTooLarge() throws Exception {
-    server.enqueue(new MockResponse().setStatus("HTTP/1.1 2147483648 OK"));
-
-    connection = client.open(server.url("/").url());
-    try {
-      connection.getResponseCode();
-      fail();
-    } catch (IOException expected) {
-    }
-  }
-
-  @Test public void serverSendsInvalidCodeNotANumber() throws Exception {
-    server.enqueue(new MockResponse().setStatus("HTTP/1.1 00a OK"));
-
-    connection = client.open(server.url("/").url());
-    try {
-      connection.getResponseCode();
-      fail();
-    } catch (IOException expected) {
-    }
-  }
-
-  @Test public void serverSendsUnnecessaryWhitespace() throws Exception {
-    server.enqueue(new MockResponse().setStatus(" HTTP/1.1 2147483648 OK"));
-
-    connection = client.open(server.url("/").url());
-    try {
-      connection.getResponseCode();
-      fail();
-    } catch (IOException expected) {
-    }
-  }
-
-  @Test public void connectRetriesUntilConnectedOrFailed() throws Exception {
-    URL url = server.url("/foo").url();
-    server.shutdown();
-
-    connection = client.open(url);
-    try {
-      connection.connect();
-      fail();
-    } catch (IOException expected) {
-    }
-  }
-
-  @Test public void requestBodySurvivesRetriesWithFixedLength() throws Exception {
-    testRequestBodySurvivesRetries(TransferKind.FIXED_LENGTH);
-  }
-
-  @Test public void requestBodySurvivesRetriesWithChunkedStreaming() throws Exception {
-    testRequestBodySurvivesRetries(TransferKind.CHUNKED);
-  }
-
-  @Test public void requestBodySurvivesRetriesWithBufferedBody() throws Exception {
-    testRequestBodySurvivesRetries(TransferKind.END_OF_STREAM);
-  }
-
-  private void testRequestBodySurvivesRetries(TransferKind transferKind) throws Exception {
-    server.enqueue(new MockResponse().setBody("abc"));
-
-    // Use a misconfigured proxy to guarantee that the request is retried.
-    FakeProxySelector proxySelector = new FakeProxySelector();
-    proxySelector.proxies.add(server2.toProxyAddress());
-    client.client().setProxySelector(proxySelector);
-    server2.shutdown();
-
-    connection = client.open(server.url("/def").url());
-    connection.setDoOutput(true);
-    transferKind.setForRequest(connection, 4);
-    connection.getOutputStream().write("body".getBytes("UTF-8"));
-    assertContent("abc", connection);
-
-    assertEquals("body", server.takeRequest().getBody().readUtf8());
-  }
-
-  @Test public void getErrorStreamOnSuccessfulRequest() throws Exception {
-    server.enqueue(new MockResponse().setBody("A"));
-    connection = client.open(server.url("/").url());
-    assertNull(connection.getErrorStream());
-    connection.getInputStream().close();
-  }
-
-  @Test public void getErrorStreamOnUnsuccessfulRequest() throws Exception {
-    server.enqueue(new MockResponse().setResponseCode(404).setBody("A"));
-    connection = client.open(server.url("/").url());
-    assertEquals("A", readAscii(connection.getErrorStream(), Integer.MAX_VALUE));
-  }
-
-  // Check that if we don't read to the end of a response, the next request on the
-  // recycled connection doesn't get the unread tail of the first request's response.
-  // http://code.google.com/p/android/issues/detail?id=2939
-  @Test public void bug2939() throws Exception {
-    MockResponse response = new MockResponse().setChunkedBody("ABCDE\nFGHIJ\nKLMNO\nPQR", 8);
-
-    server.enqueue(response);
-    server.enqueue(response);
-
-    HttpURLConnection c1 = client.open(server.url("/").url());
-    assertContent("ABCDE", c1, 5);
-    HttpURLConnection c2 = client.open(server.url("/").url());
-    assertContent("ABCDE", c2, 5);
-
-    c1.getInputStream().close();
-    c2.getInputStream().close();
-  }
-
-  // Check that we recognize a few basic mime types by extension.
-  // http://code.google.com/p/android/issues/detail?id=10100
-  @Test public void bug10100() throws Exception {
-    assertEquals("image/jpeg", URLConnection.guessContentTypeFromName("someFile.jpg"));
-    assertEquals("application/pdf", URLConnection.guessContentTypeFromName("stuff.pdf"));
-  }
-
-  @Test public void connectionsArePooled() throws Exception {
-    MockResponse response = new MockResponse().setBody("ABCDEFGHIJKLMNOPQR");
-
-    server.enqueue(response);
-    server.enqueue(response);
-    server.enqueue(response);
-
-    assertContent("ABCDEFGHIJKLMNOPQR", client.open(server.url("/foo").url()));
-    assertEquals(0, server.takeRequest().getSequenceNumber());
-    assertContent("ABCDEFGHIJKLMNOPQR", client.open(server.url("/bar?baz=quux").url()));
-    assertEquals(1, server.takeRequest().getSequenceNumber());
-    assertContent("ABCDEFGHIJKLMNOPQR", client.open(server.url("/z").url()));
-    assertEquals(2, server.takeRequest().getSequenceNumber());
-  }
-
-  @Test public void chunkedConnectionsArePooled() throws Exception {
-    MockResponse response = new MockResponse().setChunkedBody("ABCDEFGHIJKLMNOPQR", 5);
-
-    server.enqueue(response);
-    server.enqueue(response);
-    server.enqueue(response);
-
-    assertContent("ABCDEFGHIJKLMNOPQR", client.open(server.url("/foo").url()));
-    assertEquals(0, server.takeRequest().getSequenceNumber());
-    assertContent("ABCDEFGHIJKLMNOPQR", client.open(server.url("/bar?baz=quux").url()));
-    assertEquals(1, server.takeRequest().getSequenceNumber());
-    assertContent("ABCDEFGHIJKLMNOPQR", client.open(server.url("/z").url()));
-    assertEquals(2, server.takeRequest().getSequenceNumber());
-  }
-
-  @Test public void serverClosesSocket() throws Exception {
-    testServerClosesOutput(DISCONNECT_AT_END);
-  }
-
-  @Test public void serverShutdownInput() throws Exception {
-    testServerClosesOutput(SHUTDOWN_INPUT_AT_END);
-  }
-
-  @Test public void serverShutdownOutput() throws Exception {
-    testServerClosesOutput(SHUTDOWN_OUTPUT_AT_END);
-  }
-
-  @Test public void invalidHost() throws Exception {
-    // Note that 1234.1.1.1 is an invalid host in a URI, but URL isn't as strict.
-    URL url = new URL("http://1234.1.1.1/index.html");
-    HttpURLConnection connection = client.open(url);
-    try {
-      connection.connect();
-      fail();
-    } catch (UnknownHostException expected) {
-    }
-  }
-
-  private void testServerClosesOutput(SocketPolicy socketPolicy) throws Exception {
-    server.enqueue(new MockResponse().setBody("This connection won't pool properly")
-        .setSocketPolicy(socketPolicy));
-    MockResponse responseAfter = new MockResponse().setBody("This comes after a busted connection");
-    server.enqueue(responseAfter);
-    server.enqueue(responseAfter); // Enqueue 2x because the broken connection may be reused.
-
-    HttpURLConnection connection1 = client.open(server.url("/a").url());
-    connection1.setReadTimeout(100);
-    assertContent("This connection won't pool properly", connection1);
-    assertEquals(0, server.takeRequest().getSequenceNumber());
-    HttpURLConnection connection2 = client.open(server.url("/b").url());
-    connection2.setReadTimeout(100);
-    assertContent("This comes after a busted connection", connection2);
-
-    // Check that a fresh connection was created, either immediately or after attempting reuse.
-    RecordedRequest requestAfter = server.takeRequest();
-    if (server.getRequestCount() == 3) {
-      requestAfter = server.takeRequest(); // The failure consumed a response.
-    }
-    // sequence number 0 means the HTTP socket connection was not reused
-    assertEquals(0, requestAfter.getSequenceNumber());
-  }
-
-  enum WriteKind {BYTE_BY_BYTE, SMALL_BUFFERS, LARGE_BUFFERS}
-
-  @Test public void chunkedUpload_byteByByte() throws Exception {
-    doUpload(TransferKind.CHUNKED, WriteKind.BYTE_BY_BYTE);
-  }
-
-  @Test public void chunkedUpload_smallBuffers() throws Exception {
-    doUpload(TransferKind.CHUNKED, WriteKind.SMALL_BUFFERS);
-  }
-
-  @Test public void chunkedUpload_largeBuffers() throws Exception {
-    doUpload(TransferKind.CHUNKED, WriteKind.LARGE_BUFFERS);
-  }
-
-  @Test public void fixedLengthUpload_byteByByte() throws Exception {
-    doUpload(TransferKind.FIXED_LENGTH, WriteKind.BYTE_BY_BYTE);
-  }
-
-  @Test public void fixedLengthUpload_smallBuffers() throws Exception {
-    doUpload(TransferKind.FIXED_LENGTH, WriteKind.SMALL_BUFFERS);
-  }
-
-  @Test public void fixedLengthUpload_largeBuffers() throws Exception {
-    doUpload(TransferKind.FIXED_LENGTH, WriteKind.LARGE_BUFFERS);
-  }
-
-  private void doUpload(TransferKind uploadKind, WriteKind writeKind) throws Exception {
-    int n = 512 * 1024;
-    server.setBodyLimit(0);
-    server.enqueue(new MockResponse());
-
-    HttpURLConnection conn = client.open(server.url("/").url());
-    conn.setDoOutput(true);
-    conn.setRequestMethod("POST");
-    if (uploadKind == TransferKind.CHUNKED) {
-      conn.setChunkedStreamingMode(-1);
-    } else {
-      conn.setFixedLengthStreamingMode(n);
-    }
-    OutputStream out = conn.getOutputStream();
-    if (writeKind == WriteKind.BYTE_BY_BYTE) {
-      for (int i = 0; i < n; ++i) {
-        out.write('x');
-      }
-    } else {
-      byte[] buf = new byte[writeKind == WriteKind.SMALL_BUFFERS ? 256 : 64 * 1024];
-      Arrays.fill(buf, (byte) 'x');
-      for (int i = 0; i < n; i += buf.length) {
-        out.write(buf, 0, Math.min(buf.length, n - i));
-      }
-    }
-    out.close();
-    assertEquals(200, conn.getResponseCode());
-    RecordedRequest request = server.takeRequest();
-    assertEquals(n, request.getBodySize());
-    if (uploadKind == TransferKind.CHUNKED) {
-      assertTrue(request.getChunkSizes().size() > 0);
-    } else {
-      assertTrue(request.getChunkSizes().isEmpty());
-    }
-  }
-
-  @Test public void getResponseCodeNoResponseBody() throws Exception {
-    server.enqueue(new MockResponse().addHeader("abc: def"));
-
-    URL url = server.url("/").url();
-    HttpURLConnection conn = client.open(url);
-    conn.setDoInput(false);
-    assertEquals("def", conn.getHeaderField("abc"));
-    assertEquals(200, conn.getResponseCode());
-    try {
-      conn.getInputStream();
-      fail();
-    } catch (ProtocolException expected) {
-    }
-  }
-
-  @Test public void connectViaHttps() throws Exception {
-    server.useHttps(sslContext.getSocketFactory(), false);
-    server.enqueue(new MockResponse().setBody("this response comes via HTTPS"));
-
-    client.client().setSslSocketFactory(sslContext.getSocketFactory());
-    client.client().setHostnameVerifier(new RecordingHostnameVerifier());
-    connection = client.open(server.url("/foo").url());
-
-    assertContent("this response comes via HTTPS", connection);
-
-    RecordedRequest request = server.takeRequest();
-    assertEquals("GET /foo HTTP/1.1", request.getRequestLine());
-  }
-
-  @Test public void inspectHandshakeThroughoutRequestLifecycle() throws Exception {
-    server.useHttps(sslContext.getSocketFactory(), false);
-    server.enqueue(new MockResponse());
-
-    client.client().setSslSocketFactory(sslContext.getSocketFactory());
-    client.client().setHostnameVerifier(new RecordingHostnameVerifier());
-
-    HttpsURLConnection httpsConnection = (HttpsURLConnection) client.open(server.url("/foo").url());
-
-    // Prior to calling connect(), getting the cipher suite is forbidden.
-    try {
-      httpsConnection.getCipherSuite();
-      fail();
-    } catch (IllegalStateException expected) {
-    }
-
-    // Calling connect establishes a handshake...
-    httpsConnection.connect();
-    assertNotNull(httpsConnection.getCipherSuite());
-
-    // ...which remains after we read the response body...
-    assertContent("", httpsConnection);
-    assertNotNull(httpsConnection.getCipherSuite());
-
-    // ...and after we disconnect.
-    httpsConnection.disconnect();
-    assertNotNull(httpsConnection.getCipherSuite());
-  }
-
-  @Test public void connectViaHttpsReusingConnections() throws IOException, InterruptedException {
-    server.useHttps(sslContext.getSocketFactory(), false);
-    server.enqueue(new MockResponse().setBody("this response comes via HTTPS"));
-    server.enqueue(new MockResponse().setBody("another response via HTTPS"));
-
-    // The pool will only reuse sockets if the SSL socket factories are the same.
-    SSLSocketFactory clientSocketFactory = sslContext.getSocketFactory();
-    RecordingHostnameVerifier hostnameVerifier = new RecordingHostnameVerifier();
-
-    client.client().setSslSocketFactory(clientSocketFactory);
-    client.client().setHostnameVerifier(hostnameVerifier);
-    connection = client.open(server.url("/").url());
-    assertContent("this response comes via HTTPS", connection);
-
-    connection = client.open(server.url("/").url());
-    assertContent("another response via HTTPS", connection);
-
-    assertEquals(0, server.takeRequest().getSequenceNumber());
-    assertEquals(1, server.takeRequest().getSequenceNumber());
-  }
-
-  @Test public void connectViaHttpsReusingConnectionsDifferentFactories()
-      throws IOException, InterruptedException {
-    server.useHttps(sslContext.getSocketFactory(), false);
-    server.enqueue(new MockResponse().setBody("this response comes via HTTPS"));
-    server.enqueue(new MockResponse().setBody("another response via HTTPS"));
-
-    // install a custom SSL socket factory so the server can be authorized
-    client.client().setSslSocketFactory(sslContext.getSocketFactory());
-    client.client().setHostnameVerifier(new RecordingHostnameVerifier());
-    HttpURLConnection connection1 = client.open(server.url("/").url());
-    assertContent("this response comes via HTTPS", connection1);
-
-    client.client().setSslSocketFactory(null);
-    HttpURLConnection connection2 = client.open(server.url("/").url());
-    try {
-      readAscii(connection2.getInputStream(), Integer.MAX_VALUE);
-      fail("without an SSL socket factory, the connection should fail");
-    } catch (SSLException expected) {
-    }
-  }
-
-  @Test public void connectViaHttpsWithSSLFallback() throws Exception {
-    server.useHttps(sslContext.getSocketFactory(), false);
-    server.enqueue(new MockResponse().setSocketPolicy(SocketPolicy.FAIL_HANDSHAKE));
-    server.enqueue(new MockResponse().setBody("this response comes via SSL"));
-
-    suppressTlsFallbackScsv(client.client());
-    client.client().setHostnameVerifier(new RecordingHostnameVerifier());
-    connection = client.open(server.url("/foo").url());
-
-    assertContent("this response comes via SSL", connection);
-
-    RecordedRequest request = server.takeRequest();
-    assertEquals("GET /foo HTTP/1.1", request.getRequestLine());
-    assertEquals(TlsVersion.TLS_1_0, request.getTlsVersion());
-  }
-
-  @Test public void connectViaHttpsWithSSLFallbackFailuresRecorded() throws Exception {
-    server.useHttps(sslContext.getSocketFactory(), false);
-    server.enqueue(new MockResponse().setSocketPolicy(SocketPolicy.FAIL_HANDSHAKE));
-    server.enqueue(new MockResponse().setSocketPolicy(SocketPolicy.FAIL_HANDSHAKE));
-
-    suppressTlsFallbackScsv(client.client());
-    client.client().setDns(new SingleInetAddressDns());
-
-    client.client().setHostnameVerifier(new RecordingHostnameVerifier());
-    connection = client.open(server.url("/foo").url());
-
-    try {
-      connection.getResponseCode();
-      fail();
-    } catch (IOException expected) {
-      assertEquals(1, expected.getSuppressed().length);
-    }
-  }
-
-  /**
+ */
+package com.squareup.okhttp;
+
+import com.squareup.okhttp.internal.Internal;
+import com.squareup.okhttp.internal.RecordingAuthenticator;
+import com.squareup.okhttp.internal.RecordingOkAuthenticator;
+import com.squareup.okhttp.internal.SingleInetAddressDns;
+import com.squareup.okhttp.internal.SslContextBuilder;
+import com.squareup.okhttp.internal.Util;
+import com.squareup.okhttp.internal.Version;
+import com.squareup.okhttp.mockwebserver.MockResponse;
+import com.squareup.okhttp.mockwebserver.MockWebServer;
+import com.squareup.okhttp.mockwebserver.RecordedRequest;
+import com.squareup.okhttp.mockwebserver.SocketPolicy;
+import com.squareup.okhttp.testing.RecordingHostnameVerifier;
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.OutputStream;
+import java.net.Authenticator;
+import java.net.ConnectException;
+import java.net.HttpRetryException;
+import java.net.HttpURLConnection;
+import java.net.InetAddress;
+import java.net.ProtocolException;
+import java.net.Proxy;
+import java.net.ProxySelector;
+import java.net.ServerSocket;
+import java.net.Socket;
+import java.net.SocketAddress;
+import java.net.SocketTimeoutException;
+import java.net.URI;
+import java.net.URL;
+import java.net.URLConnection;
+import java.net.UnknownHostException;
+import java.security.cert.CertificateException;
+import java.security.cert.X509Certificate;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.Collections;
+import java.util.EnumSet;
+import java.util.LinkedHashSet;
+import java.util.List;
+import java.util.Map;
+import java.util.Random;
+import java.util.Set;
+import java.util.concurrent.TimeUnit;
+import java.util.zip.GZIPInputStream;
+import javax.net.ServerSocketFactory;
+import javax.net.SocketFactory;
+import javax.net.ssl.HttpsURLConnection;
+import javax.net.ssl.SSLContext;
+import javax.net.ssl.SSLException;
+import javax.net.ssl.SSLHandshakeException;
+import javax.net.ssl.SSLSocketFactory;
+import javax.net.ssl.TrustManager;
+import javax.net.ssl.X509TrustManager;
+import okio.Buffer;
+import okio.BufferedSink;
+import okio.GzipSink;
+import okio.Okio;
+import org.junit.After;
+import org.junit.Before;
+import org.junit.Ignore;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.rules.TemporaryFolder;
+import static com.squareup.okhttp.internal.Util.UTF_8;
+import static com.squareup.okhttp.internal.http.OkHeaders.SELECTED_PROTOCOL;
+import static com.squareup.okhttp.internal.http.StatusLine.HTTP_PERM_REDIRECT;
+import static com.squareup.okhttp.internal.http.StatusLine.HTTP_TEMP_REDIRECT;
+import static com.squareup.okhttp.mockwebserver.SocketPolicy.DISCONNECT_AT_END;
+import static com.squareup.okhttp.mockwebserver.SocketPolicy.DISCONNECT_AT_START;
+import static com.squareup.okhttp.mockwebserver.SocketPolicy.SHUTDOWN_INPUT_AT_END;
+import static com.squareup.okhttp.mockwebserver.SocketPolicy.SHUTDOWN_OUTPUT_AT_END;
+import static java.util.concurrent.TimeUnit.MILLISECONDS;
+import static java.util.concurrent.TimeUnit.NANOSECONDS;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertNotNull;
+import static org.junit.Assert.assertNull;
+import static org.junit.Assert.assertTrue;
+import static org.junit.Assert.fail;
+
+/** Android's URLConnectionTest. */
+public final class URLConnectionTest {
+
+    private SSLContext sslContext = SslContextBuilder.localhost();
+
+    @Rule
+    public final MockWebServer server = new MockWebServer();
+
+    @Rule
+    public final MockWebServer server2 = new MockWebServer();
+
+    @Rule
+    public final TemporaryFolder tempDir = new TemporaryFolder();
+
+    private OkUrlFactory client;
+
+    private HttpURLConnection connection;
+
+    private Cache cache;
+
+    @Before
+    public void setUp() throws Exception {
+        server.setProtocolNegotiationEnabled(false);
+        client = new OkUrlFactory(new OkHttpClient());
+    }
+
+    @After
+    public void tearDown() throws Exception {
+        Authenticator.setDefault(null);
+        System.clearProperty("proxyHost");
+        System.clearProperty("proxyPort");
+        System.clearProperty("http.agent");
+        System.clearProperty("http.proxyHost");
+        System.clearProperty("http.proxyPort");
+        System.clearProperty("https.proxyHost");
+        System.clearProperty("https.proxyPort");
+        if (cache != null) {
+            cache.delete();
+        }
+    }
+
+    @Test
+    public void requestHeaders() throws IOException, InterruptedException {
+        server.enqueue(new MockResponse());
+        connection = client.open(server.url("/").url());
+        connection.addRequestProperty("D", "e");
+        connection.addRequestProperty("D", "f");
+        assertEquals("f", connection.getRequestProperty("D"));
+        assertEquals("f", connection.getRequestProperty("d"));
+        Map<String, List<String>> requestHeaders = connection.getRequestProperties();
+        assertEquals(newSet("e", "f"), new LinkedHashSet<>(requestHeaders.get("D")));
+        assertEquals(newSet("e", "f"), new LinkedHashSet<>(requestHeaders.get("d")));
+        try {
+            requestHeaders.put("G", Arrays.asList("h"));
+            fail("Modified an unmodifiable view.");
+        } catch (UnsupportedOperationException expected) {
+        }
+        try {
+            requestHeaders.get("D").add("i");
+            fail("Modified an unmodifiable view.");
+        } catch (UnsupportedOperationException expected) {
+        }
+        try {
+            connection.setRequestProperty(null, "j");
+            fail();
+        } catch (NullPointerException expected) {
+        }
+        try {
+            connection.addRequestProperty(null, "k");
+            fail();
+        } catch (NullPointerException expected) {
+        }
+        connection.setRequestProperty("NullValue", null);
+        assertNull(connection.getRequestProperty("NullValue"));
+        connection.addRequestProperty("AnotherNullValue", null);
+        assertNull(connection.getRequestProperty("AnotherNullValue"));
+        connection.getResponseCode();
+        RecordedRequest request = server.takeRequest();
+        assertEquals(Arrays.asList("e", "f"), request.getHeaders().values("D"));
+        assertNull(request.getHeader("NullValue"));
+        assertNull(request.getHeader("AnotherNullValue"));
+        assertNull(request.getHeader("G"));
+        assertNull(request.getHeader("null"));
+        try {
+            connection.addRequestProperty("N", "o");
+            fail("Set header after connect");
+        } catch (IllegalStateException expected) {
+        }
+        try {
+            connection.setRequestProperty("P", "q");
+            fail("Set header after connect");
+        } catch (IllegalStateException expected) {
+        }
+        try {
+            connection.getRequestProperties();
+            fail();
+        } catch (IllegalStateException expected) {
+        }
+    }
+
+    @Test
+    public void getRequestPropertyReturnsLastValue() throws Exception {
+        connection = client.open(server.url("/").url());
+        connection.addRequestProperty("A", "value1");
+        connection.addRequestProperty("A", "value2");
+        assertEquals("value2", connection.getRequestProperty("A"));
+    }
+
+    @Test
+    public void responseHeaders() throws IOException, InterruptedException {
+        server.enqueue(new MockResponse().setStatus("HTTP/1.0 200 Fantastic").addHeader("A: c").addHeader("B: d").addHeader("A: e").setChunkedBody("ABCDE\nFGHIJ\nKLMNO\nPQR", 8));
+        connection = client.open(server.url("/").url());
+        assertEquals(200, connection.getResponseCode());
+        assertEquals("Fantastic", connection.getResponseMessage());
+        assertEquals("HTTP/1.0 200 Fantastic", connection.getHeaderField(null));
+        Map<String, List<String>> responseHeaders = connection.getHeaderFields();
+        assertEquals(Arrays.asList("HTTP/1.0 200 Fantastic"), responseHeaders.get(null));
+        assertEquals(newSet("c", "e"), new LinkedHashSet<>(responseHeaders.get("A")));
+        assertEquals(newSet("c", "e"), new LinkedHashSet<>(responseHeaders.get("a")));
+        try {
+            responseHeaders.put("N", Arrays.asList("o"));
+            fail("Modified an unmodifiable view.");
+        } catch (UnsupportedOperationException expected) {
+        }
+        try {
+            responseHeaders.get("A").add("f");
+            fail("Modified an unmodifiable view.");
+        } catch (UnsupportedOperationException expected) {
+        }
+        assertEquals("A", connection.getHeaderFieldKey(0));
+        assertEquals("c", connection.getHeaderField(0));
+        assertEquals("B", connection.getHeaderFieldKey(1));
+        assertEquals("d", connection.getHeaderField(1));
+        assertEquals("A", connection.getHeaderFieldKey(2));
+        assertEquals("e", connection.getHeaderField(2));
+        connection.getInputStream().close();
+    }
+
+    @Test
+    public void serverSendsInvalidResponseHeaders() throws Exception {
+        server.enqueue(new MockResponse().setStatus("HTP/1.1 200 OK"));
+        connection = client.open(server.url("/").url());
+        try {
+            connection.getResponseCode();
+            fail();
+        } catch (IOException expected) {
+        }
+    }
+
+    @Test
+    public void serverSendsInvalidCodeTooLarge() throws Exception {
+        server.enqueue(new MockResponse().setStatus("HTTP/1.1 2147483648 OK"));
+        connection = client.open(server.url("/").url());
+        try {
+            connection.getResponseCode();
+            fail();
+        } catch (IOException expected) {
+        }
+    }
+
+    @Test
+    public void serverSendsInvalidCodeNotANumber() throws Exception {
+        server.enqueue(new MockResponse().setStatus("HTTP/1.1 00a OK"));
+        connection = client.open(server.url("/").url());
+        try {
+            connection.getResponseCode();
+            fail();
+        } catch (IOException expected) {
+        }
+    }
+
+    @Test
+    public void serverSendsUnnecessaryWhitespace() throws Exception {
+        server.enqueue(new MockResponse().setStatus(" HTTP/1.1 2147483648 OK"));
+        connection = client.open(server.url("/").url());
+        try {
+            connection.getResponseCode();
+            fail();
+        } catch (IOException expected) {
+        }
+    }
+
+    @Test
+    public void connectRetriesUntilConnectedOrFailed() throws Exception {
+        URL url = server.url("/foo").url();
+        server.shutdown();
+        connection = client.open(url);
+        try {
+            connection.connect();
+            fail();
+        } catch (IOException expected) {
+        }
+    }
+
+    @Test
+    public void requestBodySurvivesRetriesWithFixedLength() throws Exception {
+        testRequestBodySurvivesRetries(TransferKind.FIXED_LENGTH);
+    }
+
+    @Test
+    public void requestBodySurvivesRetriesWithChunkedStreaming() throws Exception {
+        testRequestBodySurvivesRetries(TransferKind.CHUNKED);
+    }
+
+    @Test
+    public void requestBodySurvivesRetriesWithBufferedBody() throws Exception {
+        testRequestBodySurvivesRetries(TransferKind.END_OF_STREAM);
+    }
+
+    private void testRequestBodySurvivesRetries(TransferKind transferKind) throws Exception {
+        server.enqueue(new MockResponse().setBody("abc"));
+        FakeProxySelector proxySelector = new FakeProxySelector();
+        proxySelector.proxies.add(server2.toProxyAddress());
+        client.client().setProxySelector(proxySelector);
+        server2.shutdown();
+        connection = client.open(server.url("/def").url());
+        connection.setDoOutput(true);
+        transferKind.setForRequest(connection, 4);
+        connection.getOutputStream().write("body".getBytes("UTF-8"));
+        assertContent("abc", connection);
+        assertEquals("body", server.takeRequest().getBody().readUtf8());
+    }
+
+    @Test
+    public void getErrorStreamOnSuccessfulRequest() throws Exception {
+        server.enqueue(new MockResponse().setBody("A"));
+        connection = client.open(server.url("/").url());
+        assertNull(connection.getErrorStream());
+        connection.getInputStream().close();
+    }
+
+    @Test
+    public void getErrorStreamOnUnsuccessfulRequest() throws Exception {
+        server.enqueue(new MockResponse().setResponseCode(404).setBody("A"));
+        connection = client.open(server.url("/").url());
+        assertEquals("A", readAscii(connection.getErrorStream(), Integer.MAX_VALUE));
+    }
+
+    // Check that if we don't read to the end of a response, the next request on the
+    // recycled connection doesn't get the unread tail of the first request's response.
+    // http://code.google.com/p/android/issues/detail?id=2939
+    @Test
+    public void bug2939() throws Exception {
+        MockResponse response = new MockResponse().setChunkedBody("ABCDE\nFGHIJ\nKLMNO\nPQR", 8);
+        server.enqueue(response);
+        server.enqueue(response);
+        HttpURLConnection c1 = client.open(server.url("/").url());
+        assertContent("ABCDE", c1, 5);
+        HttpURLConnection c2 = client.open(server.url("/").url());
+        assertContent("ABCDE", c2, 5);
+        c1.getInputStream().close();
+        c2.getInputStream().close();
+    }
+
+    // Check that we recognize a few basic mime types by extension.
+    // http://code.google.com/p/android/issues/detail?id=10100
+    @Test
+    public void bug10100() throws Exception {
+        assertEquals("image/jpeg", URLConnection.guessContentTypeFromName("someFile.jpg"));
+        assertEquals("application/pdf", URLConnection.guessContentTypeFromName("stuff.pdf"));
+    }
+
+    @Test
+    public void connectionsArePooled() throws Exception {
+        MockResponse response = new MockResponse().setBody("ABCDEFGHIJKLMNOPQR");
+        server.enqueue(response);
+        server.enqueue(response);
+        server.enqueue(response);
+        assertContent("ABCDEFGHIJKLMNOPQR", client.open(server.url("/foo").url()));
+        assertEquals(0, server.takeRequest().getSequenceNumber());
+        assertContent("ABCDEFGHIJKLMNOPQR", client.open(server.url("/bar?baz=quux").url()));
+        assertEquals(1, server.takeRequest().getSequenceNumber());
+        assertContent("ABCDEFGHIJKLMNOPQR", client.open(server.url("/z").url()));
+        assertEquals(2, server.takeRequest().getSequenceNumber());
+    }
+
+    @Test
+    public void chunkedConnectionsArePooled() throws Exception {
+        MockResponse response = new MockResponse().setChunkedBody("ABCDEFGHIJKLMNOPQR", 5);
+        server.enqueue(response);
+        server.enqueue(response);
+        server.enqueue(response);
+        assertContent("ABCDEFGHIJKLMNOPQR", client.open(server.url("/foo").url()));
+        assertEquals(0, server.takeRequest().getSequenceNumber());
+        assertContent("ABCDEFGHIJKLMNOPQR", client.open(server.url("/bar?baz=quux").url()));
+        assertEquals(1, server.takeRequest().getSequenceNumber());
+        assertContent("ABCDEFGHIJKLMNOPQR", client.open(server.url("/z").url()));
+        assertEquals(2, server.takeRequest().getSequenceNumber());
+    }
+
+    @Test
+    public void serverClosesSocket() throws Exception {
+        testServerClosesOutput(DISCONNECT_AT_END);
+    }
+
+    @Test
+    public void serverShutdownInput() throws Exception {
+        testServerClosesOutput(SHUTDOWN_INPUT_AT_END);
+    }
+
+    @Test
+    public void serverShutdownOutput() throws Exception {
+        testServerClosesOutput(SHUTDOWN_OUTPUT_AT_END);
+    }
+
+    @Test
+    public void invalidHost() throws Exception {
+        URL url = new URL("http://1234.1.1.1/index.html");
+        HttpURLConnection connection = client.open(url);
+        try {
+            connection.connect();
+            fail();
+        } catch (UnknownHostException expected) {
+        }
+    }
+
+    private void testServerClosesOutput(SocketPolicy socketPolicy) throws Exception {
+        server.enqueue(new MockResponse().setBody("This connection won\'t pool properly").setSocketPolicy(socketPolicy));
+        MockResponse responseAfter = new MockResponse().setBody("This comes after a busted connection");
+        server.enqueue(responseAfter);
+        server.enqueue(responseAfter);
+        HttpURLConnection connection1 = client.open(server.url("/a").url());
+        connection1.setReadTimeout(100);
+        assertContent("This connection won\'t pool properly", connection1);
+        assertEquals(0, server.takeRequest().getSequenceNumber());
+        Thread.sleep(500);
+        HttpURLConnection connection2 = client.open(server.url("/b").url());
+        connection2.setReadTimeout(100);
+        assertContent("This comes after a busted connection", connection2);
+        RecordedRequest requestAfter = server.takeRequest();
+        if (server.getRequestCount() == 3) {
+            requestAfter = server.takeRequest();
+        }
+        assertEquals(0, requestAfter.getSequenceNumber());
+    }
+
+    enum WriteKind {
+
+        BYTE_BY_BYTE(), SMALL_BUFFERS(), LARGE_BUFFERS()
+    }
+
+    @Test
+    public void chunkedUpload_byteByByte() throws Exception {
+        doUpload(TransferKind.CHUNKED, WriteKind.BYTE_BY_BYTE);
+    }
+
+    @Test
+    public void chunkedUpload_smallBuffers() throws Exception {
+        doUpload(TransferKind.CHUNKED, WriteKind.SMALL_BUFFERS);
+    }
+
+    @Test
+    public void chunkedUpload_largeBuffers() throws Exception {
+        doUpload(TransferKind.CHUNKED, WriteKind.LARGE_BUFFERS);
+    }
+
+    @Test
+    public void fixedLengthUpload_byteByByte() throws Exception {
+        doUpload(TransferKind.FIXED_LENGTH, WriteKind.BYTE_BY_BYTE);
+    }
+
+    @Test
+    public void fixedLengthUpload_smallBuffers() throws Exception {
+        doUpload(TransferKind.FIXED_LENGTH, WriteKind.SMALL_BUFFERS);
+    }
+
+    @Test
+    public void fixedLengthUpload_largeBuffers() throws Exception {
+        doUpload(TransferKind.FIXED_LENGTH, WriteKind.LARGE_BUFFERS);
+    }
+
+    private void doUpload(TransferKind uploadKind, WriteKind writeKind) throws Exception {
+        int n = 512 * 1024;
+        server.setBodyLimit(0);
+        server.enqueue(new MockResponse());
+        HttpURLConnection conn = client.open(server.url("/").url());
+        conn.setDoOutput(true);
+        conn.setRequestMethod("POST");
+        if (uploadKind == TransferKind.CHUNKED) {
+            conn.setChunkedStreamingMode(-1);
+        } else {
+            conn.setFixedLengthStreamingMode(n);
+        }
+        OutputStream out = conn.getOutputStream();
+        if (writeKind == WriteKind.BYTE_BY_BYTE) {
+            for (int i = 0; i < n; ++i) {
+                out.write('x');
+            }
+        } else {
+            byte[] buf = new byte[writeKind == WriteKind.SMALL_BUFFERS ? 256 : 64 * 1024];
+            Arrays.fill(buf, (byte) 'x');
+            for (int i = 0; i < n; i += buf.length) {
+                out.write(buf, 0, Math.min(buf.length, n - i));
+            }
+        }
+        out.close();
+        assertEquals(200, conn.getResponseCode());
+        RecordedRequest request = server.takeRequest();
+        assertEquals(n, request.getBodySize());
+        if (uploadKind == TransferKind.CHUNKED) {
+            assertTrue(request.getChunkSizes().size() > 0);
+        } else {
+            assertTrue(request.getChunkSizes().isEmpty());
+        }
+    }
+
+    @Test
+    public void getResponseCodeNoResponseBody() throws Exception {
+        server.enqueue(new MockResponse().addHeader("abc: def"));
+        URL url = server.url("/").url();
+        HttpURLConnection conn = client.open(url);
+        conn.setDoInput(false);
+        assertEquals("def", conn.getHeaderField("abc"));
+        assertEquals(200, conn.getResponseCode());
+        try {
+            conn.getInputStream();
+            fail();
+        } catch (ProtocolException expected) {
+        }
+    }
+
+    @Test
+    public void connectViaHttps() throws Exception {
+        server.useHttps(sslContext.getSocketFactory(), false);
+        server.enqueue(new MockResponse().setBody("this response comes via HTTPS"));
+        client.client().setSslSocketFactory(sslContext.getSocketFactory());
+        client.client().setHostnameVerifier(new RecordingHostnameVerifier());
+        connection = client.open(server.url("/foo").url());
+        assertContent("this response comes via HTTPS", connection);
+        RecordedRequest request = server.takeRequest();
+        assertEquals("GET /foo HTTP/1.1", request.getRequestLine());
+    }
+
+    @Test
+    public void inspectHandshakeThroughoutRequestLifecycle() throws Exception {
+        server.useHttps(sslContext.getSocketFactory(), false);
+        server.enqueue(new MockResponse());
+        client.client().setSslSocketFactory(sslContext.getSocketFactory());
+        client.client().setHostnameVerifier(new RecordingHostnameVerifier());
+        HttpsURLConnection httpsConnection = (HttpsURLConnection) client.open(server.url("/foo").url());
+        try {
+            httpsConnection.getCipherSuite();
+            fail();
+        } catch (IllegalStateException expected) {
+        }
+        httpsConnection.connect();
+        assertNotNull(httpsConnection.getCipherSuite());
+        assertContent("", httpsConnection);
+        assertNotNull(httpsConnection.getCipherSuite());
+        httpsConnection.disconnect();
+        assertNotNull(httpsConnection.getCipherSuite());
+    }
+
+    @Test
+    public void connectViaHttpsReusingConnections() throws IOException, InterruptedException {
+        server.useHttps(sslContext.getSocketFactory(), false);
+        server.enqueue(new MockResponse().setBody("this response comes via HTTPS"));
+        server.enqueue(new MockResponse().setBody("another response via HTTPS"));
+        SSLSocketFactory clientSocketFactory = sslContext.getSocketFactory();
+        RecordingHostnameVerifier hostnameVerifier = new RecordingHostnameVerifier();
+        client.client().setSslSocketFactory(clientSocketFactory);
+        client.client().setHostnameVerifier(hostnameVerifier);
+        connection = client.open(server.url("/").url());
+        assertContent("this response comes via HTTPS", connection);
+        connection = client.open(server.url("/").url());
+        assertContent("another response via HTTPS", connection);
+        assertEquals(0, server.takeRequest().getSequenceNumber());
+        assertEquals(1, server.takeRequest().getSequenceNumber());
+    }
+
+    @Test
+    public void connectViaHttpsReusingConnectionsDifferentFactories() throws IOException, InterruptedException {
+        server.useHttps(sslContext.getSocketFactory(), false);
+        server.enqueue(new MockResponse().setBody("this response comes via HTTPS"));
+        server.enqueue(new MockResponse().setBody("another response via HTTPS"));
+        client.client().setSslSocketFactory(sslContext.getSocketFactory());
+        client.client().setHostnameVerifier(new RecordingHostnameVerifier());
+        HttpURLConnection connection1 = client.open(server.url("/").url());
+        assertContent("this response comes via HTTPS", connection1);
+        client.client().setSslSocketFactory(null);
+        HttpURLConnection connection2 = client.open(server.url("/").url());
+        try {
+            readAscii(connection2.getInputStream(), Integer.MAX_VALUE);
+            fail("without an SSL socket factory, the connection should fail");
+        } catch (SSLException expected) {
+        }
+    }
+
+    @Test
+    public void connectViaHttpsWithSSLFallback() throws Exception {
+        server.useHttps(sslContext.getSocketFactory(), false);
+        server.enqueue(new MockResponse().setSocketPolicy(SocketPolicy.FAIL_HANDSHAKE));
+        server.enqueue(new MockResponse().setBody("this response comes via SSL"));
+        suppressTlsFallbackScsv(client.client());
+        client.client().setHostnameVerifier(new RecordingHostnameVerifier());
+        connection = client.open(server.url("/foo").url());
+        assertContent("this response comes via SSL", connection);
+        RecordedRequest request = server.takeRequest();
+        assertEquals("GET /foo HTTP/1.1", request.getRequestLine());
+        assertEquals(TlsVersion.TLS_1_0, request.getTlsVersion());
+    }
+
+    @Test
+    public void connectViaHttpsWithSSLFallbackFailuresRecorded() throws Exception {
+        server.useHttps(sslContext.getSocketFactory(), false);
+        server.enqueue(new MockResponse().setSocketPolicy(SocketPolicy.FAIL_HANDSHAKE));
+        server.enqueue(new MockResponse().setSocketPolicy(SocketPolicy.FAIL_HANDSHAKE));
+        suppressTlsFallbackScsv(client.client());
+        client.client().setDns(new SingleInetAddressDns());
+        client.client().setHostnameVerifier(new RecordingHostnameVerifier());
+        connection = client.open(server.url("/foo").url());
+        try {
+            connection.getResponseCode();
+            fail();
+        } catch (IOException expected) {
+            assertEquals(1, expected.getSuppressed().length);
+        }
+    }
+
+    /**
    * When a pooled connection fails, don't blame the route. Otherwise pooled
    * connection failures can cause unnecessary SSL fallbacks.
    *
    * https://github.com/square/okhttp/issues/515
-   */
-  @Test public void sslFallbackNotUsedWhenRecycledConnectionFails() throws Exception {
-    server.useHttps(sslContext.getSocketFactory(), false);
-    server.enqueue(new MockResponse()
-        .setBody("abc")
-        .setSocketPolicy(SocketPolicy.DISCONNECT_AT_END));
-    server.enqueue(new MockResponse().setBody("def"));
-
-    suppressTlsFallbackScsv(client.client());
-    client.client().setHostnameVerifier(new RecordingHostnameVerifier());
-
-    assertContent("abc", client.open(server.url("/").url()));
-    assertContent("def", client.open(server.url("/").url()));
-
-    Set<TlsVersion> tlsVersions =
-        EnumSet.of(TlsVersion.TLS_1_0, TlsVersion.TLS_1_2); // v1.2 on OpenJDK 8.
-
-    RecordedRequest request1 = server.takeRequest();
-    assertTrue(tlsVersions.contains(request1.getTlsVersion()));
-
-    RecordedRequest request2 = server.takeRequest();
-    assertTrue(tlsVersions.contains(request2.getTlsVersion()));
-  }
-
-  /**
+   */
+    @Test
+    public void sslFallbackNotUsedWhenRecycledConnectionFails() throws Exception {
+        server.useHttps(sslContext.getSocketFactory(), false);
+        server.enqueue(new MockResponse().setBody("abc").setSocketPolicy(SocketPolicy.DISCONNECT_AT_END));
+        server.enqueue(new MockResponse().setBody("def"));
+        suppressTlsFallbackScsv(client.client());
+        client.client().setHostnameVerifier(new RecordingHostnameVerifier());
+        assertContent("abc", client.open(server.url("/").url()));
+        Thread.sleep(500);
+        assertContent("def", client.open(server.url("/").url()));
+        Set<TlsVersion> tlsVersions = EnumSet.of(TlsVersion.TLS_1_0, TlsVersion.TLS_1_2);
+        RecordedRequest request1 = server.takeRequest();
+        assertTrue(tlsVersions.contains(request1.getTlsVersion()));
+        RecordedRequest request2 = server.takeRequest();
+        assertTrue(tlsVersions.contains(request2.getTlsVersion()));
+    }
+
+    /**
    * Verify that we don't retry connections on certificate verification errors.
    *
    * http://code.google.com/p/android/issues/detail?id=13178
-   */
-  @Test public void connectViaHttpsToUntrustedServer() throws IOException, InterruptedException {
-    server.useHttps(sslContext.getSocketFactory(), false);
-    server.enqueue(new MockResponse()); // unused
-
-    connection = client.open(server.url("/foo").url());
-    try {
-      connection.getInputStream();
-      fail();
-    } catch (SSLHandshakeException expected) {
-      assertTrue(expected.getCause() instanceof CertificateException);
-    }
-    assertEquals(0, server.getRequestCount());
-  }
-
-  @Test public void connectViaProxyUsingProxyArg() throws Exception {
-    testConnectViaProxy(ProxyConfig.CREATE_ARG);
-  }
-
-  @Test public void connectViaProxyUsingProxySystemProperty() throws Exception {
-    testConnectViaProxy(ProxyConfig.PROXY_SYSTEM_PROPERTY);
-  }
-
-  @Test public void connectViaProxyUsingHttpProxySystemProperty() throws Exception {
-    testConnectViaProxy(ProxyConfig.HTTP_PROXY_SYSTEM_PROPERTY);
-  }
-
-  private void testConnectViaProxy(ProxyConfig proxyConfig) throws Exception {
-    MockResponse mockResponse = new MockResponse().setBody("this response comes via a proxy");
-    server.enqueue(mockResponse);
-
-    URL url = new URL("http://android.com/foo");
-    connection = proxyConfig.connect(server, client, url);
-    assertContent("this response comes via a proxy", connection);
-    assertTrue(connection.usingProxy());
-
-    RecordedRequest request = server.takeRequest();
-    assertEquals("GET http://android.com/foo HTTP/1.1", request.getRequestLine());
-    assertEquals("android.com", request.getHeader("Host"));
-  }
-
-  @Test public void contentDisagreesWithContentLengthHeaderBodyTooLong() throws IOException {
-    server.enqueue(new MockResponse().setBody("abc\r\nYOU SHOULD NOT SEE THIS")
-        .clearHeaders()
-        .addHeader("Content-Length: 3"));
-    assertContent("abc", client.open(server.url("/").url()));
-  }
-
-  @Test public void contentDisagreesWithContentLengthHeaderBodyTooShort() throws IOException {
-    server.enqueue(new MockResponse().setBody("abc")
-        .setHeader("Content-Length", "5")
-        .setSocketPolicy(SocketPolicy.DISCONNECT_AT_END));
-    try {
-      readAscii(client.open(server.url("/").url()).getInputStream(), 5);
-      fail();
-    } catch (ProtocolException expected) {
-    }
-  }
-
-  public void testConnectViaSocketFactory(boolean useHttps) throws IOException {
-    SocketFactory uselessSocketFactory = new SocketFactory() {
-      public Socket createSocket() { throw new IllegalArgumentException("useless"); }
-      public Socket createSocket(InetAddress host, int port) { return null; }
-      public Socket createSocket(InetAddress address, int port, InetAddress localAddress,
-          int localPort) { return null; }
-      public Socket createSocket(String host, int port) { return null; }
-      public Socket createSocket(String host, int port, InetAddress localHost, int localPort) {
-        return null;
-      }
-    };
-
-    if (useHttps) {
-      server.useHttps(sslContext.getSocketFactory(), false);
-      client.client().setSslSocketFactory(sslContext.getSocketFactory());
-      client.client().setHostnameVerifier(new RecordingHostnameVerifier());
-    }
-
-    server.enqueue(new MockResponse().setStatus("HTTP/1.1 200 OK"));
-
-    client.client().setSocketFactory(uselessSocketFactory);
-    connection = client.open(server.url("/").url());
-    try {
-      connection.getResponseCode();
-      fail();
-    } catch (IllegalArgumentException expected) {
-    }
-
-    client.client().setSocketFactory(SocketFactory.getDefault());
-    connection = client.open(server.url("/").url());
-    assertEquals(200, connection.getResponseCode());
-  }
-
-  @Test public void connectHttpViaSocketFactory() throws Exception {
-    testConnectViaSocketFactory(false);
-  }
-
-  @Test public void connectHttpsViaSocketFactory() throws Exception {
-    testConnectViaSocketFactory(true);
-  }
-
-  @Test public void contentDisagreesWithChunkedHeaderBodyTooLong() throws IOException {
-    MockResponse mockResponse = new MockResponse();
-    mockResponse.setChunkedBody("abc", 3);
-    Buffer buffer = mockResponse.getBody();
-    buffer.writeUtf8("\r\nYOU SHOULD NOT SEE THIS");
-    mockResponse.setBody(buffer);
-    mockResponse.clearHeaders();
-    mockResponse.addHeader("Transfer-encoding: chunked");
-
-    server.enqueue(mockResponse);
-
-    assertContent("abc", client.open(server.url("/").url()));
-  }
-
-  @Test public void contentDisagreesWithChunkedHeaderBodyTooShort() throws IOException {
-    MockResponse mockResponse = new MockResponse();
-    mockResponse.setChunkedBody("abcde", 5);
-
-    Buffer truncatedBody = new Buffer();
-    Buffer fullBody = mockResponse.getBody();
-    truncatedBody.write(fullBody, fullBody.indexOf((byte) 'e'));
-    mockResponse.setBody(truncatedBody);
-
-    mockResponse.clearHeaders();
-    mockResponse.addHeader("Transfer-encoding: chunked");
-    mockResponse.setSocketPolicy(SocketPolicy.DISCONNECT_AT_END);
-
-    server.enqueue(mockResponse);
-
-    try {
-      readAscii(client.open(server.url("/").url()).getInputStream(), 5);
-      fail();
-    } catch (ProtocolException expected) {
-    }
-  }
-
-  @Test public void connectViaHttpProxyToHttpsUsingProxyArgWithNoProxy() throws Exception {
-    testConnectViaDirectProxyToHttps(ProxyConfig.NO_PROXY);
-  }
-
-  @Test public void connectViaHttpProxyToHttpsUsingHttpProxySystemProperty() throws Exception {
-    // https should not use http proxy
-    testConnectViaDirectProxyToHttps(ProxyConfig.HTTP_PROXY_SYSTEM_PROPERTY);
-  }
-
-  private void testConnectViaDirectProxyToHttps(ProxyConfig proxyConfig) throws Exception {
-    server.useHttps(sslContext.getSocketFactory(), false);
-    server.enqueue(new MockResponse().setBody("this response comes via HTTPS"));
-
-    URL url = server.url("/foo").url();
-    client.client().setSslSocketFactory(sslContext.getSocketFactory());
-    client.client().setHostnameVerifier(new RecordingHostnameVerifier());
-    connection = proxyConfig.connect(server, client, url);
-
-    assertContent("this response comes via HTTPS", connection);
-
-    RecordedRequest request = server.takeRequest();
-    assertEquals("GET /foo HTTP/1.1", request.getRequestLine());
-  }
-
-  @Test public void connectViaHttpProxyToHttpsUsingProxyArg() throws Exception {
-    testConnectViaHttpProxyToHttps(ProxyConfig.CREATE_ARG);
-  }
-
-  /**
+   */
+    @Test
+    public void connectViaHttpsToUntrustedServer() throws IOException, InterruptedException {
+        server.useHttps(sslContext.getSocketFactory(), false);
+        server.enqueue(new MockResponse());
+        connection = client.open(server.url("/foo").url());
+        try {
+            connection.getInputStream();
+            fail();
+        } catch (SSLHandshakeException expected) {
+            assertTrue(expected.getCause() instanceof CertificateException);
+        }
+        assertEquals(0, server.getRequestCount());
+    }
+
+    @Test
+    public void connectViaProxyUsingProxyArg() throws Exception {
+        testConnectViaProxy(ProxyConfig.CREATE_ARG);
+    }
+
+    @Test
+    public void connectViaProxyUsingProxySystemProperty() throws Exception {
+        testConnectViaProxy(ProxyConfig.PROXY_SYSTEM_PROPERTY);
+    }
+
+    @Test
+    public void connectViaProxyUsingHttpProxySystemProperty() throws Exception {
+        testConnectViaProxy(ProxyConfig.HTTP_PROXY_SYSTEM_PROPERTY);
+    }
+
+    private void testConnectViaProxy(ProxyConfig proxyConfig) throws Exception {
+        MockResponse mockResponse = new MockResponse().setBody("this response comes via a proxy");
+        server.enqueue(mockResponse);
+        URL url = new URL("http://android.com/foo");
+        connection = proxyConfig.connect(server, client, url);
+        assertContent("this response comes via a proxy", connection);
+        assertTrue(connection.usingProxy());
+        RecordedRequest request = server.takeRequest();
+        assertEquals("GET http://android.com/foo HTTP/1.1", request.getRequestLine());
+        assertEquals("android.com", request.getHeader("Host"));
+    }
+
+    @Test
+    public void contentDisagreesWithContentLengthHeaderBodyTooLong() throws IOException {
+        server.enqueue(new MockResponse().setBody("abc\r\nYOU SHOULD NOT SEE THIS").clearHeaders().addHeader("Content-Length: 3"));
+        assertContent("abc", client.open(server.url("/").url()));
+    }
+
+    @Test
+    public void contentDisagreesWithContentLengthHeaderBodyTooShort() throws IOException {
+        server.enqueue(new MockResponse().setBody("abc").setHeader("Content-Length", "5").setSocketPolicy(SocketPolicy.DISCONNECT_AT_END));
+        try {
+            readAscii(client.open(server.url("/").url()).getInputStream(), 5);
+            fail();
+        } catch (ProtocolException expected) {
+        }
+    }
+
+    public void testConnectViaSocketFactory(boolean useHttps) throws IOException {
+        SocketFactory uselessSocketFactory = new SocketFactory() {
+
+            public Socket createSocket() {
+                throw new IllegalArgumentException("useless");
+            }
+
+            public Socket createSocket(InetAddress host, int port) {
+                return null;
+            }
+
+            public Socket createSocket(InetAddress address, int port, InetAddress localAddress, int localPort) {
+                return null;
+            }
+
+            public Socket createSocket(String host, int port) {
+                return null;
+            }
+
+            public Socket createSocket(String host, int port, InetAddress localHost, int localPort) {
+                return null;
+            }
+        };
+        if (useHttps) {
+            server.useHttps(sslContext.getSocketFactory(), false);
+            client.client().setSslSocketFactory(sslContext.getSocketFactory());
+            client.client().setHostnameVerifier(new RecordingHostnameVerifier());
+        }
+        server.enqueue(new MockResponse().setStatus("HTTP/1.1 200 OK"));
+        client.client().setSocketFactory(uselessSocketFactory);
+        connection = client.open(server.url("/").url());
+        try {
+            connection.getResponseCode();
+            fail();
+        } catch (IllegalArgumentException expected) {
+        }
+        client.client().setSocketFactory(SocketFactory.getDefault());
+        connection = client.open(server.url("/").url());
+        assertEquals(200, connection.getResponseCode());
+    }
+
+    @Test
+    public void connectHttpViaSocketFactory() throws Exception {
+        testConnectViaSocketFactory(false);
+    }
+
+    @Test
+    public void connectHttpsViaSocketFactory() throws Exception {
+        testConnectViaSocketFactory(true);
+    }
+
+    @Test
+    public void contentDisagreesWithChunkedHeaderBodyTooLong() throws IOException {
+        MockResponse mockResponse = new MockResponse();
+        mockResponse.setChunkedBody("abc", 3);
+        Buffer buffer = mockResponse.getBody();
+        buffer.writeUtf8("\r\nYOU SHOULD NOT SEE THIS");
+        mockResponse.setBody(buffer);
+        mockResponse.clearHeaders();
+        mockResponse.addHeader("Transfer-encoding: chunked");
+        server.enqueue(mockResponse);
+        assertContent("abc", client.open(server.url("/").url()));
+    }
+
+    @Test
+    public void contentDisagreesWithChunkedHeaderBodyTooShort() throws IOException {
+        MockResponse mockResponse = new MockResponse();
+        mockResponse.setChunkedBody("abcde", 5);
+        Buffer truncatedBody = new Buffer();
+        Buffer fullBody = mockResponse.getBody();
+        truncatedBody.write(fullBody, fullBody.indexOf((byte) 'e'));
+        mockResponse.setBody(truncatedBody);
+        mockResponse.clearHeaders();
+        mockResponse.addHeader("Transfer-encoding: chunked");
+        mockResponse.setSocketPolicy(SocketPolicy.DISCONNECT_AT_END);
+        server.enqueue(mockResponse);
+        try {
+            readAscii(client.open(server.url("/").url()).getInputStream(), 5);
+            fail();
+        } catch (ProtocolException expected) {
+        }
+    }
+
+    @Test
+    public void connectViaHttpProxyToHttpsUsingProxyArgWithNoProxy() throws Exception {
+        testConnectViaDirectProxyToHttps(ProxyConfig.NO_PROXY);
+    }
+
+    @Test
+    public void connectViaHttpProxyToHttpsUsingHttpProxySystemProperty() throws Exception {
+        testConnectViaDirectProxyToHttps(ProxyConfig.HTTP_PROXY_SYSTEM_PROPERTY);
+    }
+
+    private void testConnectViaDirectProxyToHttps(ProxyConfig proxyConfig) throws Exception {
+        server.useHttps(sslContext.getSocketFactory(), false);
+        server.enqueue(new MockResponse().setBody("this response comes via HTTPS"));
+        URL url = server.url("/foo").url();
+        client.client().setSslSocketFactory(sslContext.getSocketFactory());
+        client.client().setHostnameVerifier(new RecordingHostnameVerifier());
+        connection = proxyConfig.connect(server, client, url);
+        assertContent("this response comes via HTTPS", connection);
+        RecordedRequest request = server.takeRequest();
+        assertEquals("GET /foo HTTP/1.1", request.getRequestLine());
+    }
+
+    @Test
+    public void connectViaHttpProxyToHttpsUsingProxyArg() throws Exception {
+        testConnectViaHttpProxyToHttps(ProxyConfig.CREATE_ARG);
+    }
+
+    /**
    * We weren't honoring all of the appropriate proxy system properties when
    * connecting via HTTPS. http://b/3097518
-   */
-  @Test public void connectViaHttpProxyToHttpsUsingProxySystemProperty() throws Exception {
-    testConnectViaHttpProxyToHttps(ProxyConfig.PROXY_SYSTEM_PROPERTY);
-  }
-
-  @Test public void connectViaHttpProxyToHttpsUsingHttpsProxySystemProperty() throws Exception {
-    testConnectViaHttpProxyToHttps(ProxyConfig.HTTPS_PROXY_SYSTEM_PROPERTY);
-  }
-
-  /**
+   */
+    @Test
+    public void connectViaHttpProxyToHttpsUsingProxySystemProperty() throws Exception {
+        testConnectViaHttpProxyToHttps(ProxyConfig.PROXY_SYSTEM_PROPERTY);
+    }
+
+    @Test
+    public void connectViaHttpProxyToHttpsUsingHttpsProxySystemProperty() throws Exception {
+        testConnectViaHttpProxyToHttps(ProxyConfig.HTTPS_PROXY_SYSTEM_PROPERTY);
+    }
+
+    /**
    * We were verifying the wrong hostname when connecting to an HTTPS site
    * through a proxy. http://b/3097277
-   */
-  private void testConnectViaHttpProxyToHttps(ProxyConfig proxyConfig) throws Exception {
-    RecordingHostnameVerifier hostnameVerifier = new RecordingHostnameVerifier();
-
-    server.useHttps(sslContext.getSocketFactory(), true);
-    server.enqueue(
-        new MockResponse().setSocketPolicy(SocketPolicy.UPGRADE_TO_SSL_AT_END).clearHeaders());
-    server.enqueue(new MockResponse().setBody("this response comes via a secure proxy"));
-
-    URL url = new URL("https://android.com/foo");
-    client.client().setSslSocketFactory(sslContext.getSocketFactory());
-    client.client().setHostnameVerifier(hostnameVerifier);
-    connection = proxyConfig.connect(server, client, url);
-
-    assertContent("this response comes via a secure proxy", connection);
-
-    RecordedRequest connect = server.takeRequest();
-    assertEquals("Connect line failure on proxy", "CONNECT android.com:443 HTTP/1.1",
-        connect.getRequestLine());
-    assertEquals("android.com", connect.getHeader("Host"));
-
-    RecordedRequest get = server.takeRequest();
-    assertEquals("GET /foo HTTP/1.1", get.getRequestLine());
-    assertEquals("android.com", get.getHeader("Host"));
-    assertEquals(Arrays.asList("verify android.com"), hostnameVerifier.calls);
-  }
-
-  /** Tolerate bad https proxy response when using HttpResponseCache. Android bug 6754912. */
-  @Test public void connectViaHttpProxyToHttpsUsingBadProxyAndHttpResponseCache() throws Exception {
-    initResponseCache();
-
-    server.useHttps(sslContext.getSocketFactory(), true);
-    // The inclusion of a body in the response to a CONNECT is key to reproducing b/6754912.
-    MockResponse badProxyResponse = new MockResponse()
-        .setSocketPolicy(SocketPolicy.UPGRADE_TO_SSL_AT_END)
-        .setBody("bogus proxy connect response content");
-    server.enqueue(badProxyResponse);
-    server.enqueue(new MockResponse().setBody("response"));
-
-    // Configure a single IP address for the host and a single configuration, so we only need one
-    // failure to fail permanently.
-    client.client().setDns(new SingleInetAddressDns());
-    client.client().setSslSocketFactory(sslContext.getSocketFactory());
-    client.client().setConnectionSpecs(Util.immutableList(ConnectionSpec.MODERN_TLS));
-    client.client().setHostnameVerifier(new RecordingHostnameVerifier());
-    client.client().setProxy(server.toProxyAddress());
-
-    URL url = new URL("https://android.com/foo");
-    connection = client.open(url);
-    assertContent("response", connection);
-
-    RecordedRequest connect = server.takeRequest();
-    assertEquals("CONNECT android.com:443 HTTP/1.1", connect.getRequestLine());
-    assertEquals("android.com", connect.getHeader("Host"));
-  }
-
-  private void initResponseCache() throws IOException {
-    cache = new Cache(tempDir.getRoot(), Integer.MAX_VALUE);
-    client.client().setCache(cache);
-  }
-
-  /** Test which headers are sent unencrypted to the HTTP proxy. */
-  @Test public void proxyConnectIncludesProxyHeadersOnly()
-      throws IOException, InterruptedException {
-    RecordingHostnameVerifier hostnameVerifier = new RecordingHostnameVerifier();
-
-    server.useHttps(sslContext.getSocketFactory(), true);
-    server.enqueue(
-        new MockResponse().setSocketPolicy(SocketPolicy.UPGRADE_TO_SSL_AT_END).clearHeaders());
-    server.enqueue(new MockResponse().setBody("encrypted response from the origin server"));
-
-    client.client().setProxy(server.toProxyAddress());
-
-    URL url = new URL("https://android.com/foo");
-    client.client().setSslSocketFactory(sslContext.getSocketFactory());
-    client.client().setHostnameVerifier(hostnameVerifier);
-    connection = client.open(url);
-    connection.addRequestProperty("Private", "Secret");
-    connection.addRequestProperty("Proxy-Authorization", "bar");
-    connection.addRequestProperty("User-Agent", "baz");
-    assertContent("encrypted response from the origin server", connection);
-
-    RecordedRequest connect = server.takeRequest();
-    assertNull(connect.getHeader("Private"));
-    assertNull(connect.getHeader("Proxy-Authorization"));
-    assertEquals(Version.userAgent(), connect.getHeader("User-Agent"));
-    assertEquals("android.com", connect.getHeader("Host"));
-    assertEquals("Keep-Alive", connect.getHeader("Proxy-Connection"));
-
-    RecordedRequest get = server.takeRequest();
-    assertEquals("Secret", get.getHeader("Private"));
-    assertEquals(Arrays.asList("verify android.com"), hostnameVerifier.calls);
-  }
-
-  @Test public void proxyAuthenticateOnConnect() throws Exception {
-    Authenticator.setDefault(new RecordingAuthenticator());
-    server.useHttps(sslContext.getSocketFactory(), true);
-    server.enqueue(new MockResponse().setResponseCode(407)
-        .addHeader("Proxy-Authenticate: Basic realm=\"localhost\""));
-    server.enqueue(
-        new MockResponse().setSocketPolicy(SocketPolicy.UPGRADE_TO_SSL_AT_END).clearHeaders());
-    server.enqueue(new MockResponse().setBody("A"));
-
-    client.client().setProxy(server.toProxyAddress());
-
-    URL url = new URL("https://android.com/foo");
-    client.client().setSslSocketFactory(sslContext.getSocketFactory());
-    client.client().setHostnameVerifier(new RecordingHostnameVerifier());
-    connection = client.open(url);
-    assertContent("A", connection);
-
-    RecordedRequest connect1 = server.takeRequest();
-    assertEquals("CONNECT android.com:443 HTTP/1.1", connect1.getRequestLine());
-    assertNull(connect1.getHeader("Proxy-Authorization"));
-
-    RecordedRequest connect2 = server.takeRequest();
-    assertEquals("CONNECT android.com:443 HTTP/1.1", connect2.getRequestLine());
-    assertEquals("Basic " + RecordingAuthenticator.BASE_64_CREDENTIALS,
-        connect2.getHeader("Proxy-Authorization"));
-
-    RecordedRequest get = server.takeRequest();
-    assertEquals("GET /foo HTTP/1.1", get.getRequestLine());
-    assertNull(get.getHeader("Proxy-Authorization"));
-  }
-
-  // Don't disconnect after building a tunnel with CONNECT
-  // http://code.google.com/p/android/issues/detail?id=37221
-  @Test public void proxyWithConnectionClose() throws IOException {
-    server.useHttps(sslContext.getSocketFactory(), true);
-    server.enqueue(
-        new MockResponse().setSocketPolicy(SocketPolicy.UPGRADE_TO_SSL_AT_END).clearHeaders());
-    server.enqueue(new MockResponse().setBody("this response comes via a proxy"));
-
-    client.client().setProxy(server.toProxyAddress());
-
-    URL url = new URL("https://android.com/foo");
-    client.client().setSslSocketFactory(sslContext.getSocketFactory());
-    client.client().setHostnameVerifier(new RecordingHostnameVerifier());
-    connection = client.open(url);
-    connection.setRequestProperty("Connection", "close");
-
-    assertContent("this response comes via a proxy", connection);
-  }
-
-  @Test public void proxyWithConnectionReuse() throws IOException {
-    SSLSocketFactory socketFactory = sslContext.getSocketFactory();
-    RecordingHostnameVerifier hostnameVerifier = new RecordingHostnameVerifier();
-
-    server.useHttps(socketFactory, true);
-    server.enqueue(
-        new MockResponse().setSocketPolicy(SocketPolicy.UPGRADE_TO_SSL_AT_END).clearHeaders());
-    server.enqueue(new MockResponse().setBody("response 1"));
-    server.enqueue(new MockResponse().setBody("response 2"));
-
-    client.client().setProxy(server.toProxyAddress());
-
-    URL url = new URL("https://android.com/foo");
-    client.client().setSslSocketFactory(socketFactory);
-    client.client().setHostnameVerifier(hostnameVerifier);
-    assertContent("response 1", client.open(url));
-    assertContent("response 2", client.open(url));
-  }
-
-  @Test public void disconnectedConnection() throws IOException {
-    server.enqueue(new MockResponse()
-        .throttleBody(2, 100, TimeUnit.MILLISECONDS)
-        .setBody("ABCD"));
-
-    connection = client.open(server.url("/").url());
-    InputStream in = connection.getInputStream();
-    assertEquals('A', (char) in.read());
-    connection.disconnect();
-    try {
-      // Reading 'B' may succeed if it's buffered.
-      in.read();
-
-      // But 'C' shouldn't be buffered (the response is throttled) and this should fail.
-      in.read();
-      fail("Expected a connection closed exception");
-    } catch (IOException expected) {
-    }
-    in.close();
-  }
-
-  @Test public void disconnectBeforeConnect() throws IOException {
-    server.enqueue(new MockResponse().setBody("A"));
-
-    connection = client.open(server.url("/").url());
-    connection.disconnect();
-    assertContent("A", connection);
-    assertEquals(200, connection.getResponseCode());
-  }
-
-  @SuppressWarnings("deprecation") @Test public void defaultRequestProperty() throws Exception {
-    URLConnection.setDefaultRequestProperty("X-testSetDefaultRequestProperty", "A");
-    assertNull(URLConnection.getDefaultRequestProperty("X-setDefaultRequestProperty"));
-  }
-
-  /**
+   */
+    private void testConnectViaHttpProxyToHttps(ProxyConfig proxyConfig) throws Exception {
+        RecordingHostnameVerifier hostnameVerifier = new RecordingHostnameVerifier();
+        server.useHttps(sslContext.getSocketFactory(), true);
+        server.enqueue(new MockResponse().setSocketPolicy(SocketPolicy.UPGRADE_TO_SSL_AT_END).clearHeaders());
+        server.enqueue(new MockResponse().setBody("this response comes via a secure proxy"));
+        URL url = new URL("https://android.com/foo");
+        client.client().setSslSocketFactory(sslContext.getSocketFactory());
+        client.client().setHostnameVerifier(hostnameVerifier);
+        connection = proxyConfig.connect(server, client, url);
+        assertContent("this response comes via a secure proxy", connection);
+        RecordedRequest connect = server.takeRequest();
+        assertEquals("Connect line failure on proxy", "CONNECT android.com:443 HTTP/1.1", connect.getRequestLine());
+        assertEquals("android.com", connect.getHeader("Host"));
+        RecordedRequest get = server.takeRequest();
+        assertEquals("GET /foo HTTP/1.1", get.getRequestLine());
+        assertEquals("android.com", get.getHeader("Host"));
+        assertEquals(Arrays.asList("verify android.com"), hostnameVerifier.calls);
+    }
+
+    /** Tolerate bad https proxy response when using HttpResponseCache. Android bug 6754912. */
+    @Test
+    public void connectViaHttpProxyToHttpsUsingBadProxyAndHttpResponseCache() throws Exception {
+        initResponseCache();
+        server.useHttps(sslContext.getSocketFactory(), true);
+        MockResponse badProxyResponse = new MockResponse().setSocketPolicy(SocketPolicy.UPGRADE_TO_SSL_AT_END).setBody("bogus proxy connect response content");
+        server.enqueue(badProxyResponse);
+        server.enqueue(new MockResponse().setBody("response"));
+        client.client().setDns(new SingleInetAddressDns());
+        client.client().setSslSocketFactory(sslContext.getSocketFactory());
+        client.client().setConnectionSpecs(Util.immutableList(ConnectionSpec.MODERN_TLS));
+        client.client().setHostnameVerifier(new RecordingHostnameVerifier());
+        client.client().setProxy(server.toProxyAddress());
+        URL url = new URL("https://android.com/foo");
+        connection = client.open(url);
+        assertContent("response", connection);
+        RecordedRequest connect = server.takeRequest();
+        assertEquals("CONNECT android.com:443 HTTP/1.1", connect.getRequestLine());
+        assertEquals("android.com", connect.getHeader("Host"));
+    }
+
+    private void initResponseCache() throws IOException {
+        cache = new Cache(tempDir.getRoot(), Integer.MAX_VALUE);
+        client.client().setCache(cache);
+    }
+
+    /** Test which headers are sent unencrypted to the HTTP proxy. */
+    @Test
+    public void proxyConnectIncludesProxyHeadersOnly() throws IOException, InterruptedException {
+        RecordingHostnameVerifier hostnameVerifier = new RecordingHostnameVerifier();
+        server.useHttps(sslContext.getSocketFactory(), true);
+        server.enqueue(new MockResponse().setSocketPolicy(SocketPolicy.UPGRADE_TO_SSL_AT_END).clearHeaders());
+        server.enqueue(new MockResponse().setBody("encrypted response from the origin server"));
+        client.client().setProxy(server.toProxyAddress());
+        URL url = new URL("https://android.com/foo");
+        client.client().setSslSocketFactory(sslContext.getSocketFactory());
+        client.client().setHostnameVerifier(hostnameVerifier);
+        connection = client.open(url);
+        connection.addRequestProperty("Private", "Secret");
+        connection.addRequestProperty("Proxy-Authorization", "bar");
+        connection.addRequestProperty("User-Agent", "baz");
+        assertContent("encrypted response from the origin server", connection);
+        RecordedRequest connect = server.takeRequest();
+        assertNull(connect.getHeader("Private"));
+        assertNull(connect.getHeader("Proxy-Authorization"));
+        assertEquals(Version.userAgent(), connect.getHeader("User-Agent"));
+        assertEquals("android.com", connect.getHeader("Host"));
+        assertEquals("Keep-Alive", connect.getHeader("Proxy-Connection"));
+        RecordedRequest get = server.takeRequest();
+        assertEquals("Secret", get.getHeader("Private"));
+        assertEquals(Arrays.asList("verify android.com"), hostnameVerifier.calls);
+    }
+
+    @Test
+    public void proxyAuthenticateOnConnect() throws Exception {
+        Authenticator.setDefault(new RecordingAuthenticator());
+        server.useHttps(sslContext.getSocketFactory(), true);
+        server.enqueue(new MockResponse().setResponseCode(407).addHeader("Proxy-Authenticate: Basic realm=\"localhost\""));
+        server.enqueue(new MockResponse().setSocketPolicy(SocketPolicy.UPGRADE_TO_SSL_AT_END).clearHeaders());
+        server.enqueue(new MockResponse().setBody("A"));
+        client.client().setProxy(server.toProxyAddress());
+        URL url = new URL("https://android.com/foo");
+        client.client().setSslSocketFactory(sslContext.getSocketFactory());
+        client.client().setHostnameVerifier(new RecordingHostnameVerifier());
+        connection = client.open(url);
+        assertContent("A", connection);
+        RecordedRequest connect1 = server.takeRequest();
+        assertEquals("CONNECT android.com:443 HTTP/1.1", connect1.getRequestLine());
+        assertNull(connect1.getHeader("Proxy-Authorization"));
+        RecordedRequest connect2 = server.takeRequest();
+        assertEquals("CONNECT android.com:443 HTTP/1.1", connect2.getRequestLine());
+        assertEquals("Basic " + RecordingAuthenticator.BASE_64_CREDENTIALS, connect2.getHeader("Proxy-Authorization"));
+        RecordedRequest get = server.takeRequest();
+        assertEquals("GET /foo HTTP/1.1", get.getRequestLine());
+        assertNull(get.getHeader("Proxy-Authorization"));
+    }
+
+    // Don't disconnect after building a tunnel with CONNECT
+    // http://code.google.com/p/android/issues/detail?id=37221
+    @Test
+    public void proxyWithConnectionClose() throws IOException {
+        server.useHttps(sslContext.getSocketFactory(), true);
+        server.enqueue(new MockResponse().setSocketPolicy(SocketPolicy.UPGRADE_TO_SSL_AT_END).clearHeaders());
+        server.enqueue(new MockResponse().setBody("this response comes via a proxy"));
+        client.client().setProxy(server.toProxyAddress());
+        URL url = new URL("https://android.com/foo");
+        client.client().setSslSocketFactory(sslContext.getSocketFactory());
+        client.client().setHostnameVerifier(new RecordingHostnameVerifier());
+        connection = client.open(url);
+        connection.setRequestProperty("Connection", "close");
+        assertContent("this response comes via a proxy", connection);
+    }
+
+    @Test
+    public void proxyWithConnectionReuse() throws IOException {
+        SSLSocketFactory socketFactory = sslContext.getSocketFactory();
+        RecordingHostnameVerifier hostnameVerifier = new RecordingHostnameVerifier();
+        server.useHttps(socketFactory, true);
+        server.enqueue(new MockResponse().setSocketPolicy(SocketPolicy.UPGRADE_TO_SSL_AT_END).clearHeaders());
+        server.enqueue(new MockResponse().setBody("response 1"));
+        server.enqueue(new MockResponse().setBody("response 2"));
+        client.client().setProxy(server.toProxyAddress());
+        URL url = new URL("https://android.com/foo");
+        client.client().setSslSocketFactory(socketFactory);
+        client.client().setHostnameVerifier(hostnameVerifier);
+        assertContent("response 1", client.open(url));
+        assertContent("response 2", client.open(url));
+    }
+
+    @Test
+    public void disconnectedConnection() throws IOException {
+        server.enqueue(new MockResponse().throttleBody(2, 100, TimeUnit.MILLISECONDS).setBody("ABCD"));
+        connection = client.open(server.url("/").url());
+        InputStream in = connection.getInputStream();
+        assertEquals('A', (char) in.read());
+        connection.disconnect();
+        try {
+            in.read();
+            in.read();
+            fail("Expected a connection closed exception");
+        } catch (IOException expected) {
+        }
+        in.close();
+    }
+
+    @Test
+    public void disconnectBeforeConnect() throws IOException {
+        server.enqueue(new MockResponse().setBody("A"));
+        connection = client.open(server.url("/").url());
+        connection.disconnect();
+        assertContent("A", connection);
+        assertEquals(200, connection.getResponseCode());
+    }
+
+    @SuppressWarnings(value = { "deprecation" })
+    @Test
+    public void defaultRequestProperty() throws Exception {
+        URLConnection.setDefaultRequestProperty("X-testSetDefaultRequestProperty", "A");
+        assertNull(URLConnection.getDefaultRequestProperty("X-setDefaultRequestProperty"));
+    }
+
+    /**
    * Reads {@code count} characters from the stream. If the stream is
    * exhausted before {@code count} characters can be read, the remaining
    * characters are returned and the stream is closed.
-   */
-  private String readAscii(InputStream in, int count) throws IOException {
-    StringBuilder result = new StringBuilder();
-    for (int i = 0; i < count; i++) {
-      int value = in.read();
-      if (value == -1) {
-        in.close();
-        break;
-      }
-      result.append((char) value);
-    }
-    return result.toString();
-  }
-
-  @Test public void markAndResetWithContentLengthHeader() throws IOException {
-    testMarkAndReset(TransferKind.FIXED_LENGTH);
-  }
-
-  @Test public void markAndResetWithChunkedEncoding() throws IOException {
-    testMarkAndReset(TransferKind.CHUNKED);
-  }
-
-  @Test public void markAndResetWithNoLengthHeaders() throws IOException {
-    testMarkAndReset(TransferKind.END_OF_STREAM);
-  }
-
-  private void testMarkAndReset(TransferKind transferKind) throws IOException {
-    MockResponse response = new MockResponse();
-    transferKind.setBody(response, "ABCDEFGHIJKLMNOPQRSTUVWXYZ", 1024);
-    server.enqueue(response);
-    server.enqueue(response);
-
-    InputStream in = client.open(server.url("/").url()).getInputStream();
-    assertFalse("This implementation claims to support mark().", in.markSupported());
-    in.mark(5);
-    assertEquals("ABCDE", readAscii(in, 5));
-    try {
-      in.reset();
-      fail();
-    } catch (IOException expected) {
-    }
-    assertEquals("FGHIJKLMNOPQRSTUVWXYZ", readAscii(in, Integer.MAX_VALUE));
-    in.close();
-    assertContent("ABCDEFGHIJKLMNOPQRSTUVWXYZ", client.open(server.url("/").url()));
-  }
-
-  /**
+   */
+    private String readAscii(InputStream in, int count) throws IOException {
+        StringBuilder result = new StringBuilder();
+        for (int i = 0; i < count; i++) {
+            int value = in.read();
+            if (value == -1) {
+                in.close();
+                break;
+            }
+            result.append((char) value);
+        }
+        return result.toString();
+    }
+
+    @Test
+    public void markAndResetWithContentLengthHeader() throws IOException {
+        testMarkAndReset(TransferKind.FIXED_LENGTH);
+    }
+
+    @Test
+    public void markAndResetWithChunkedEncoding() throws IOException {
+        testMarkAndReset(TransferKind.CHUNKED);
+    }
+
+    @Test
+    public void markAndResetWithNoLengthHeaders() throws IOException {
+        testMarkAndReset(TransferKind.END_OF_STREAM);
+    }
+
+    private void testMarkAndReset(TransferKind transferKind) throws IOException {
+        MockResponse response = new MockResponse();
+        transferKind.setBody(response, "ABCDEFGHIJKLMNOPQRSTUVWXYZ", 1024);
+        server.enqueue(response);
+        server.enqueue(response);
+        InputStream in = client.open(server.url("/").url()).getInputStream();
+        assertFalse("This implementation claims to support mark().", in.markSupported());
+        in.mark(5);
+        assertEquals("ABCDE", readAscii(in, 5));
+        try {
+            in.reset();
+            fail();
+        } catch (IOException expected) {
+        }
+        assertEquals("FGHIJKLMNOPQRSTUVWXYZ", readAscii(in, Integer.MAX_VALUE));
+        in.close();
+        assertContent("ABCDEFGHIJKLMNOPQRSTUVWXYZ", client.open(server.url("/").url()));
+    }
+
+    /**
    * We've had a bug where we forget the HTTP response when we see response
    * code 401. This causes a new HTTP request to be issued for every call into
    * the URLConnection.
-   */
-  @Test public void unauthorizedResponseHandling() throws IOException {
-    MockResponse response = new MockResponse().addHeader("WWW-Authenticate: challenge")
-        .setResponseCode(401) // UNAUTHORIZED
-        .setBody("Unauthorized");
-    server.enqueue(response);
-    server.enqueue(response);
-    server.enqueue(response);
-
-    URL url = server.url("/").url();
-    HttpURLConnection conn = client.open(url);
-
-    assertEquals(401, conn.getResponseCode());
-    assertEquals(401, conn.getResponseCode());
-    assertEquals(401, conn.getResponseCode());
-    assertEquals(1, server.getRequestCount());
-    conn.getErrorStream().close();
-  }
-
-  @Test public void nonHexChunkSize() throws IOException {
-    server.enqueue(new MockResponse().setBody("5\r\nABCDE\r\nG\r\nFGHIJKLMNOPQRSTU\r\n0\r\n\r\n")
-        .clearHeaders()
-        .addHeader("Transfer-encoding: chunked"));
-
-    URLConnection connection = client.open(server.url("/").url());
-    try {
-      readAscii(connection.getInputStream(), Integer.MAX_VALUE);
-      fail();
-    } catch (IOException e) {
-    }
-    connection.getInputStream().close();
-  }
-
-  @Test public void malformedChunkSize() throws IOException {
-    server.enqueue(new MockResponse().setBody("5:x\r\nABCDE\r\n0\r\n\r\n")
-        .clearHeaders()
-        .addHeader("Transfer-encoding: chunked"));
-
-    URLConnection connection = client.open(server.url("/").url());
-    try {
-      readAscii(connection.getInputStream(), Integer.MAX_VALUE);
-      fail();
-    } catch (IOException e) {
-    } finally {
-      connection.getInputStream().close();
-    }
-  }
-
-  @Test public void extensionAfterChunkSize() throws IOException {
-    server.enqueue(new MockResponse().setBody("5;x\r\nABCDE\r\n0\r\n\r\n")
-        .clearHeaders()
-        .addHeader("Transfer-encoding: chunked"));
-
-    HttpURLConnection connection = client.open(server.url("/").url());
-    assertContent("ABCDE", connection);
-  }
-
-  @Test public void missingChunkBody() throws IOException {
-    server.enqueue(new MockResponse().setBody("5")
-        .clearHeaders()
-        .addHeader("Transfer-encoding: chunked")
-        .setSocketPolicy(DISCONNECT_AT_END));
-
-    URLConnection connection = client.open(server.url("/").url());
-    try {
-      readAscii(connection.getInputStream(), Integer.MAX_VALUE);
-      fail();
-    } catch (IOException e) {
-    } finally {
-      connection.getInputStream().close();
-    }
-  }
-
-  /**
+   */
+    @Test
+    public void unauthorizedResponseHandling() throws IOException {
+        MockResponse response = new MockResponse().addHeader("WWW-Authenticate: challenge").setResponseCode(401).setBody("Unauthorized");
+        server.enqueue(response);
+        server.enqueue(response);
+        server.enqueue(response);
+        URL url = server.url("/").url();
+        HttpURLConnection conn = client.open(url);
+        assertEquals(401, conn.getResponseCode());
+        assertEquals(401, conn.getResponseCode());
+        assertEquals(401, conn.getResponseCode());
+        assertEquals(1, server.getRequestCount());
+        conn.getErrorStream().close();
+    }
+
+    @Test
+    public void nonHexChunkSize() throws IOException {
+        server.enqueue(new MockResponse().setBody("5\r\nABCDE\r\nG\r\nFGHIJKLMNOPQRSTU\r\n0\r\n\r\n").clearHeaders().addHeader("Transfer-encoding: chunked"));
+        URLConnection connection = client.open(server.url("/").url());
+        try {
+            readAscii(connection.getInputStream(), Integer.MAX_VALUE);
+            fail();
+        } catch (IOException e) {
+        }
+        connection.getInputStream().close();
+    }
+
+    @Test
+    public void malformedChunkSize() throws IOException {
+        server.enqueue(new MockResponse().setBody("5:x\r\nABCDE\r\n0\r\n\r\n").clearHeaders().addHeader("Transfer-encoding: chunked"));
+        URLConnection connection = client.open(server.url("/").url());
+        try {
+            readAscii(connection.getInputStream(), Integer.MAX_VALUE);
+            fail();
+        } catch (IOException e) {
+        } finally {
+            connection.getInputStream().close();
+        }
+    }
+
+    @Test
+    public void extensionAfterChunkSize() throws IOException {
+        server.enqueue(new MockResponse().setBody("5;x\r\nABCDE\r\n0\r\n\r\n").clearHeaders().addHeader("Transfer-encoding: chunked"));
+        HttpURLConnection connection = client.open(server.url("/").url());
+        assertContent("ABCDE", connection);
+    }
+
+    @Test
+    public void missingChunkBody() throws IOException {
+        server.enqueue(new MockResponse().setBody("5").clearHeaders().addHeader("Transfer-encoding: chunked").setSocketPolicy(DISCONNECT_AT_END));
+        URLConnection connection = client.open(server.url("/").url());
+        try {
+            readAscii(connection.getInputStream(), Integer.MAX_VALUE);
+            fail();
+        } catch (IOException e) {
+        } finally {
+            connection.getInputStream().close();
+        }
+    }
+
+    /**
    * This test checks whether connections are gzipped by default. This
    * behavior in not required by the API, so a failure of this test does not
    * imply a bug in the implementation.
-   */
-  @Test public void gzipEncodingEnabledByDefault() throws IOException, InterruptedException {
-    server.enqueue(new MockResponse()
-        .setBody(gzip("ABCABCABC"))
-        .addHeader("Content-Encoding: gzip"));
-
-    URLConnection connection = client.open(server.url("/").url());
-    assertEquals("ABCABCABC", readAscii(connection.getInputStream(), Integer.MAX_VALUE));
-    assertNull(connection.getContentEncoding());
-    assertEquals(-1, connection.getContentLength());
-
-    RecordedRequest request = server.takeRequest();
-    assertEquals("gzip", request.getHeader("Accept-Encoding"));
-  }
-
-  @Test public void clientConfiguredGzipContentEncoding() throws Exception {
-    Buffer bodyBytes = gzip("ABCDEFGHIJKLMNOPQRSTUVWXYZ");
-    server.enqueue(new MockResponse()
-        .setBody(bodyBytes)
-        .addHeader("Content-Encoding: gzip"));
-
-    URLConnection connection = client.open(server.url("/").url());
-    connection.addRequestProperty("Accept-Encoding", "gzip");
-    InputStream gunzippedIn = new GZIPInputStream(connection.getInputStream());
-    assertEquals("ABCDEFGHIJKLMNOPQRSTUVWXYZ", readAscii(gunzippedIn, Integer.MAX_VALUE));
-    assertEquals(bodyBytes.size(), connection.getContentLength());
-
-    RecordedRequest request = server.takeRequest();
-    assertEquals("gzip", request.getHeader("Accept-Encoding"));
-  }
-
-  @Test public void gzipAndConnectionReuseWithFixedLength() throws Exception {
-    testClientConfiguredGzipContentEncodingAndConnectionReuse(TransferKind.FIXED_LENGTH, false);
-  }
-
-  @Test public void gzipAndConnectionReuseWithChunkedEncoding() throws Exception {
-    testClientConfiguredGzipContentEncodingAndConnectionReuse(TransferKind.CHUNKED, false);
-  }
-
-  @Test public void gzipAndConnectionReuseWithFixedLengthAndTls() throws Exception {
-    testClientConfiguredGzipContentEncodingAndConnectionReuse(TransferKind.FIXED_LENGTH, true);
-  }
-
-  @Test public void gzipAndConnectionReuseWithChunkedEncodingAndTls() throws Exception {
-    testClientConfiguredGzipContentEncodingAndConnectionReuse(TransferKind.CHUNKED, true);
-  }
-
-  @Test public void clientConfiguredCustomContentEncoding() throws Exception {
-    server.enqueue(new MockResponse().setBody("ABCDE").addHeader("Content-Encoding: custom"));
-
-    URLConnection connection = client.open(server.url("/").url());
-    connection.addRequestProperty("Accept-Encoding", "custom");
-    assertEquals("ABCDE", readAscii(connection.getInputStream(), Integer.MAX_VALUE));
-
-    RecordedRequest request = server.takeRequest();
-    assertEquals("custom", request.getHeader("Accept-Encoding"));
-  }
-
-  /**
+   */
+    @Test
+    public void gzipEncodingEnabledByDefault() throws IOException, InterruptedException {
+        server.enqueue(new MockResponse().setBody(gzip("ABCABCABC")).addHeader("Content-Encoding: gzip"));
+        URLConnection connection = client.open(server.url("/").url());
+        assertEquals("ABCABCABC", readAscii(connection.getInputStream(), Integer.MAX_VALUE));
+        assertNull(connection.getContentEncoding());
+        assertEquals(-1, connection.getContentLength());
+        RecordedRequest request = server.takeRequest();
+        assertEquals("gzip", request.getHeader("Accept-Encoding"));
+    }
+
+    @Test
+    public void clientConfiguredGzipContentEncoding() throws Exception {
+        Buffer bodyBytes = gzip("ABCDEFGHIJKLMNOPQRSTUVWXYZ");
+        server.enqueue(new MockResponse().setBody(bodyBytes).addHeader("Content-Encoding: gzip"));
+        URLConnection connection = client.open(server.url("/").url());
+        connection.addRequestProperty("Accept-Encoding", "gzip");
+        InputStream gunzippedIn = new GZIPInputStream(connection.getInputStream());
+        assertEquals("ABCDEFGHIJKLMNOPQRSTUVWXYZ", readAscii(gunzippedIn, Integer.MAX_VALUE));
+        assertEquals(bodyBytes.size(), connection.getContentLength());
+        RecordedRequest request = server.takeRequest();
+        assertEquals("gzip", request.getHeader("Accept-Encoding"));
+    }
+
+    @Test
+    public void gzipAndConnectionReuseWithFixedLength() throws Exception {
+        testClientConfiguredGzipContentEncodingAndConnectionReuse(TransferKind.FIXED_LENGTH, false);
+    }
+
+    @Test
+    public void gzipAndConnectionReuseWithChunkedEncoding() throws Exception {
+        testClientConfiguredGzipContentEncodingAndConnectionReuse(TransferKind.CHUNKED, false);
+    }
+
+    @Test
+    public void gzipAndConnectionReuseWithFixedLengthAndTls() throws Exception {
+        testClientConfiguredGzipContentEncodingAndConnectionReuse(TransferKind.FIXED_LENGTH, true);
+    }
+
+    @Test
+    public void gzipAndConnectionReuseWithChunkedEncodingAndTls() throws Exception {
+        testClientConfiguredGzipContentEncodingAndConnectionReuse(TransferKind.CHUNKED, true);
+    }
+
+    @Test
+    public void clientConfiguredCustomContentEncoding() throws Exception {
+        server.enqueue(new MockResponse().setBody("ABCDE").addHeader("Content-Encoding: custom"));
+        URLConnection connection = client.open(server.url("/").url());
+        connection.addRequestProperty("Accept-Encoding", "custom");
+        assertEquals("ABCDE", readAscii(connection.getInputStream(), Integer.MAX_VALUE));
+        RecordedRequest request = server.takeRequest();
+        assertEquals("custom", request.getHeader("Accept-Encoding"));
+    }
+
+    /**
    * Test a bug where gzip input streams weren't exhausting the input stream,
    * which corrupted the request that followed or prevented connection reuse.
    * http://code.google.com/p/android/issues/detail?id=7059
    * http://code.google.com/p/android/issues/detail?id=38817
-   */
-  private void testClientConfiguredGzipContentEncodingAndConnectionReuse(TransferKind transferKind,
-      boolean tls) throws Exception {
-    if (tls) {
-      SSLSocketFactory socketFactory = sslContext.getSocketFactory();
-      RecordingHostnameVerifier hostnameVerifier = new RecordingHostnameVerifier();
-      server.useHttps(socketFactory, false);
-      client.client().setSslSocketFactory(socketFactory);
-      client.client().setHostnameVerifier(hostnameVerifier);
-    }
-
-    MockResponse responseOne = new MockResponse();
-    responseOne.addHeader("Content-Encoding: gzip");
-    transferKind.setBody(responseOne, gzip("one (gzipped)"), 5);
-    server.enqueue(responseOne);
-    MockResponse responseTwo = new MockResponse();
-    transferKind.setBody(responseTwo, "two (identity)", 5);
-    server.enqueue(responseTwo);
-
-    HttpURLConnection connection1 = client.open(server.url("/").url());
-    connection1.addRequestProperty("Accept-Encoding", "gzip");
-    InputStream gunzippedIn = new GZIPInputStream(connection1.getInputStream());
-    assertEquals("one (gzipped)", readAscii(gunzippedIn, Integer.MAX_VALUE));
-    assertEquals(0, server.takeRequest().getSequenceNumber());
-
-    HttpURLConnection connection2 = client.open(server.url("/").url());
-    assertEquals("two (identity)", readAscii(connection2.getInputStream(), Integer.MAX_VALUE));
-    assertEquals(1, server.takeRequest().getSequenceNumber());
-  }
-
-  @Test public void transparentGzipWorksAfterExceptionRecovery() throws Exception {
-    server.enqueue(new MockResponse()
-        .setBody("a")
-        .setSocketPolicy(SHUTDOWN_INPUT_AT_END));
-    server.enqueue(new MockResponse()
-        .addHeader("Content-Encoding: gzip")
-        .setBody(gzip("b")));
-
-    // Seed the pool with a bad connection.
-    assertContent("a", client.open(server.url("/").url()));
-
-    // This connection will need to be recovered. When it is, transparent gzip should still work!
-    assertContent("b", client.open(server.url("/").url()));
-
-    assertEquals(0, server.takeRequest().getSequenceNumber());
-    assertEquals(0, server.takeRequest().getSequenceNumber()); // Connection is not pooled.
-  }
-
-  @Test public void endOfStreamResponseIsNotPooled() throws Exception {
-    server.enqueue(new MockResponse()
-        .setBody("{}")
-        .clearHeaders()
-        .setSocketPolicy(DISCONNECT_AT_END));
-
-    ConnectionPool pool = ConnectionPool.getDefault();
-    pool.evictAll();
-    client.client().setConnectionPool(pool);
-
-    HttpURLConnection connection = client.open(server.url("/").url());
-    assertContent("{}", connection);
-    assertEquals(0, client.client().getConnectionPool().getIdleConnectionCount());
-  }
-
-  @Test public void earlyDisconnectDoesntHarmPoolingWithChunkedEncoding() throws Exception {
-    testEarlyDisconnectDoesntHarmPooling(TransferKind.CHUNKED);
-  }
-
-  @Test public void earlyDisconnectDoesntHarmPoolingWithFixedLengthEncoding() throws Exception {
-    testEarlyDisconnectDoesntHarmPooling(TransferKind.FIXED_LENGTH);
-  }
-
-  private void testEarlyDisconnectDoesntHarmPooling(TransferKind transferKind) throws Exception {
-    MockResponse response1 = new MockResponse();
-    transferKind.setBody(response1, "ABCDEFGHIJK", 1024);
-    server.enqueue(response1);
-
-    MockResponse response2 = new MockResponse();
-    transferKind.setBody(response2, "LMNOPQRSTUV", 1024);
-    server.enqueue(response2);
-
-    HttpURLConnection connection1 = client.open(server.url("/").url());
-    InputStream in1 = connection1.getInputStream();
-    assertEquals("ABCDE", readAscii(in1, 5));
-    in1.close();
-    connection1.disconnect();
-
-    HttpURLConnection connection2 = client.open(server.url("/").url());
-    InputStream in2 = connection2.getInputStream();
-    assertEquals("LMNOP", readAscii(in2, 5));
-    in2.close();
-    connection2.disconnect();
-
-    assertEquals(0, server.takeRequest().getSequenceNumber());
-    assertEquals(1, server.takeRequest().getSequenceNumber()); // Connection is pooled!
-  }
-
-  @Test public void streamDiscardingIsTimely() throws Exception {
-    // This response takes at least a full second to serve: 10,000 bytes served 100 bytes at a time.
-    server.enqueue(new MockResponse()
-        .setBody(new Buffer().write(new byte[10000]))
-        .throttleBody(100, 10, MILLISECONDS));
-    server.enqueue(new MockResponse().setBody("A"));
-
-    long startNanos = System.nanoTime();
-    URLConnection connection1 = client.open(server.url("/").url());
-    InputStream in = connection1.getInputStream();
-    in.close();
-    long elapsedNanos = System.nanoTime() - startNanos;
-    long elapsedMillis = NANOSECONDS.toMillis(elapsedNanos);
-
-    // If we're working correctly, this should be greater than 100ms, but less than double that.
-    // Previously we had a bug where we would download the entire response body as long as no
-    // individual read took longer than 100ms.
-    assertTrue(String.format("Time to close: %sms", elapsedMillis), elapsedMillis < 500);
-
-    // Do another request to confirm that the discarded connection was not pooled.
-    assertContent("A", client.open(server.url("/").url()));
-
-    assertEquals(0, server.takeRequest().getSequenceNumber());
-    assertEquals(0, server.takeRequest().getSequenceNumber()); // Connection is not pooled.
-  }
-
-  @Test public void setChunkedStreamingMode() throws IOException, InterruptedException {
-    server.enqueue(new MockResponse());
-
-    String body = "ABCDEFGHIJKLMNOPQ";
-    connection = client.open(server.url("/").url());
-    connection.setChunkedStreamingMode(0); // OkHttp does not honor specific chunk sizes.
-    connection.setDoOutput(true);
-    OutputStream outputStream = connection.getOutputStream();
-    outputStream.write(body.getBytes("US-ASCII"));
-    assertEquals(200, connection.getResponseCode());
-    connection.getInputStream().close();
-
-    RecordedRequest request = server.takeRequest();
-    assertEquals(body, request.getBody().readUtf8());
-    assertEquals(Arrays.asList(body.length()), request.getChunkSizes());
-  }
-
-  @Test public void authenticateWithFixedLengthStreaming() throws Exception {
-    testAuthenticateWithStreamingPost(StreamingMode.FIXED_LENGTH);
-  }
-
-  @Test public void authenticateWithChunkedStreaming() throws Exception {
-    testAuthenticateWithStreamingPost(StreamingMode.CHUNKED);
-  }
-
-  private void testAuthenticateWithStreamingPost(StreamingMode streamingMode) throws Exception {
-    MockResponse pleaseAuthenticate = new MockResponse().setResponseCode(401)
-        .addHeader("WWW-Authenticate: Basic realm=\"protected area\"")
-        .setBody("Please authenticate.");
-    server.enqueue(pleaseAuthenticate);
-
-    Authenticator.setDefault(new RecordingAuthenticator());
-    connection = client.open(server.url("/").url());
-    connection.setDoOutput(true);
-    byte[] requestBody = { 'A', 'B', 'C', 'D' };
-    if (streamingMode == StreamingMode.FIXED_LENGTH) {
-      connection.setFixedLengthStreamingMode(requestBody.length);
-    } else if (streamingMode == StreamingMode.CHUNKED) {
-      connection.setChunkedStreamingMode(0);
-    }
-    OutputStream outputStream = connection.getOutputStream();
-    outputStream.write(requestBody);
-    outputStream.close();
-    try {
-      connection.getInputStream();
-      fail();
-    } catch (HttpRetryException expected) {
-    }
-
-    // no authorization header for the request...
-    RecordedRequest request = server.takeRequest();
-    assertNull(request.getHeader("Authorization"));
-    assertEquals("ABCD", request.getBody().readUtf8());
-  }
-
-  @Test public void postBodyRetransmittedAfterAuthorizationFail() throws Exception {
-    postBodyRetransmittedAfterAuthorizationFail("abc");
-  }
-
-  @Test public void postBodyRetransmittedAfterAuthorizationFail_SPDY_3() throws Exception {
-    enableProtocol(Protocol.SPDY_3);
-    postBodyRetransmittedAfterAuthorizationFail("abc");
-  }
-
-  @Test public void postBodyRetransmittedAfterAuthorizationFail_HTTP_2() throws Exception {
-    enableProtocol(Protocol.HTTP_2);
-    postBodyRetransmittedAfterAuthorizationFail("abc");
-  }
-
-  /** Don't explode when resending an empty post. https://github.com/square/okhttp/issues/1131 */
-  @Test public void postEmptyBodyRetransmittedAfterAuthorizationFail() throws Exception {
-    postBodyRetransmittedAfterAuthorizationFail("");
-  }
-
-  @Test public void postEmptyBodyRetransmittedAfterAuthorizationFail_SPDY_3() throws Exception {
-    enableProtocol(Protocol.SPDY_3);
-    postBodyRetransmittedAfterAuthorizationFail("");
-  }
-
-  @Test public void postEmptyBodyRetransmittedAfterAuthorizationFail_HTTP_2() throws Exception {
-    enableProtocol(Protocol.HTTP_2);
-    postBodyRetransmittedAfterAuthorizationFail("");
-  }
-
-  private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exception {
-    server.enqueue(new MockResponse().setResponseCode(401));
-    server.enqueue(new MockResponse());
-
-    String credential = Credentials.basic("jesse", "secret");
-    client.client().setAuthenticator(new RecordingOkAuthenticator(credential));
-
-    connection = client.open(server.url("/").url());
-    connection.setDoOutput(true);
-    OutputStream outputStream = connection.getOutputStream();
-    outputStream.write(body.getBytes("UTF-8"));
-    outputStream.close();
-    assertEquals(200, connection.getResponseCode());
-
-    RecordedRequest recordedRequest1 = server.takeRequest();
-    assertEquals("POST", recordedRequest1.getMethod());
-    assertEquals(body, recordedRequest1.getBody().readUtf8());
-    assertNull(recordedRequest1.getHeader("Authorization"));
-
-    RecordedRequest recordedRequest2 = server.takeRequest();
-    assertEquals("POST", recordedRequest2.getMethod());
-    assertEquals(body, recordedRequest2.getBody().readUtf8());
-    assertEquals(credential, recordedRequest2.getHeader("Authorization"));
-  }
-
-  @Test public void nonStandardAuthenticationScheme() throws Exception {
-    List<String> calls = authCallsForHeader("WWW-Authenticate: Foo");
-    assertEquals(Collections.<String>emptyList(), calls);
-  }
-
-  @Test public void nonStandardAuthenticationSchemeWithRealm() throws Exception {
-    List<String> calls = authCallsForHeader("WWW-Authenticate: Foo realm=\"Bar\"");
-    assertEquals(0, calls.size());
-  }
-
-  // Digest auth is currently unsupported. Test that digest requests should fail reasonably.
-  // http://code.google.com/p/android/issues/detail?id=11140
-  @Test public void digestAuthentication() throws Exception {
-    List<String> calls = authCallsForHeader("WWW-Authenticate: Digest "
-        + "realm=\"testrealm@host.com\", qop=\"auth,auth-int\", "
-        + "nonce=\"dcd98b7102dd2f0e8b11d0f600bfb0c093\", "
-        + "opaque=\"5ccc069c403ebaf9f0171e9517f40e41\"");
-    assertEquals(0, calls.size());
-  }
-
-  @Test public void allAttributesSetInServerAuthenticationCallbacks() throws Exception {
-    List<String> calls = authCallsForHeader("WWW-Authenticate: Basic realm=\"Bar\"");
-    assertEquals(1, calls.size());
-    URL url = server.url("/").url();
-    String call = calls.get(0);
-    assertTrue(call, call.contains("host=" + url.getHost()));
-    assertTrue(call, call.contains("port=" + url.getPort()));
-    assertTrue(call, call.contains("site=" + url.getHost()));
-    assertTrue(call, call.contains("url=" + url));
-    assertTrue(call, call.contains("type=" + Authenticator.RequestorType.SERVER));
-    assertTrue(call, call.contains("prompt=Bar"));
-    assertTrue(call, call.contains("protocol=http"));
-    assertTrue(call, call.toLowerCase().contains("scheme=basic")); // lowercase for the RI.
-  }
-
-  @Test public void allAttributesSetInProxyAuthenticationCallbacks() throws Exception {
-    List<String> calls = authCallsForHeader("Proxy-Authenticate: Basic realm=\"Bar\"");
-    assertEquals(1, calls.size());
-    URL url = server.url("/").url();
-    String call = calls.get(0);
-    assertTrue(call, call.contains("host=" + url.getHost()));
-    assertTrue(call, call.contains("port=" + url.getPort()));
-    assertTrue(call, call.contains("site=" + url.getHost()));
-    assertTrue(call, call.contains("url=http://android.com"));
-    assertTrue(call, call.contains("type=" + Authenticator.RequestorType.PROXY));
-    assertTrue(call, call.contains("prompt=Bar"));
-    assertTrue(call, call.contains("protocol=http"));
-    assertTrue(call, call.toLowerCase().contains("scheme=basic")); // lowercase for the RI.
-  }
-
-  private List<String> authCallsForHeader(String authHeader) throws IOException {
-    boolean proxy = authHeader.startsWith("Proxy-");
-    int responseCode = proxy ? 407 : 401;
-    RecordingAuthenticator authenticator = new RecordingAuthenticator(null);
-    Authenticator.setDefault(authenticator);
-    MockResponse pleaseAuthenticate = new MockResponse()
-        .setResponseCode(responseCode)
-        .addHeader(authHeader)
-        .setBody("Please authenticate.");
-    server.enqueue(pleaseAuthenticate);
-
-    if (proxy) {
-      client.client().setProxy(server.toProxyAddress());
-      connection = client.open(new URL("http://android.com"));
-    } else {
-      connection = client.open(server.url("/").url());
-    }
-    assertEquals(responseCode, connection.getResponseCode());
-    connection.getErrorStream().close();
-    return authenticator.calls;
-  }
-
-  @Test public void setValidRequestMethod() throws Exception {
-    assertValidRequestMethod("GET");
-    assertValidRequestMethod("DELETE");
-    assertValidRequestMethod("HEAD");
-    assertValidRequestMethod("OPTIONS");
-    assertValidRequestMethod("POST");
-    assertValidRequestMethod("PUT");
-    assertValidRequestMethod("TRACE");
-    assertValidRequestMethod("PATCH");
-  }
-
-  private void assertValidRequestMethod(String requestMethod) throws Exception {
-    connection = client.open(server.url("/").url());
-    connection.setRequestMethod(requestMethod);
-    assertEquals(requestMethod, connection.getRequestMethod());
-  }
-
-  @Test public void setInvalidRequestMethodLowercase() throws Exception {
-    assertInvalidRequestMethod("get");
-  }
-
-  @Test public void setInvalidRequestMethodConnect() throws Exception {
-    assertInvalidRequestMethod("CONNECT");
-  }
-
-  private void assertInvalidRequestMethod(String requestMethod) throws Exception {
-    connection = client.open(server.url("/").url());
-    try {
-      connection.setRequestMethod(requestMethod);
-      fail();
-    } catch (ProtocolException expected) {
-    }
-  }
-
-  @Test public void shoutcast() throws Exception {
-    server.enqueue(new MockResponse().setStatus("ICY 200 OK")
-        // .addHeader("HTTP/1.0 200 OK")
-        .addHeader("Accept-Ranges: none")
-        .addHeader("Content-Type: audio/mpeg")
-        .addHeader("icy-br:128")
-        .addHeader("ice-audio-info: bitrate=128;samplerate=44100;channels=2")
-        .addHeader("icy-br:128")
-        .addHeader("icy-description:Rock")
-        .addHeader("icy-genre:riders")
-        .addHeader("icy-name:A2RRock")
-        .addHeader("icy-pub:1")
-        .addHeader("icy-url:http://www.A2Rradio.com")
-        .addHeader("Server: Icecast 2.3.3-kh8")
-        .addHeader("Cache-Control: no-cache")
-        .addHeader("Pragma: no-cache")
-        .addHeader("Expires: Mon, 26 Jul 1997 05:00:00 GMT")
-        .addHeader("icy-metaint:16000")
-        .setBody("mp3 data"));
-    connection = client.open(server.url("/").url());
-    assertEquals(200, connection.getResponseCode());
-    assertEquals("OK", connection.getResponseMessage());
-    assertContent("mp3 data", connection);
-  }
-
-  @Test public void cannotSetNegativeFixedLengthStreamingMode() throws Exception {
-    connection = client.open(server.url("/").url());
-    try {
-      connection.setFixedLengthStreamingMode(-2);
-      fail();
-    } catch (IllegalArgumentException expected) {
-    }
-  }
-
-  @Test public void canSetNegativeChunkedStreamingMode() throws Exception {
-    connection = client.open(server.url("/").url());
-    connection.setChunkedStreamingMode(-2);
-  }
-
-  @Test public void cannotSetFixedLengthStreamingModeAfterConnect() throws Exception {
-    server.enqueue(new MockResponse().setBody("A"));
-    connection = client.open(server.url("/").url());
-    assertEquals("A", readAscii(connection.getInputStream(), Integer.MAX_VALUE));
-    try {
-      connection.setFixedLengthStreamingMode(1);
-      fail();
-    } catch (IllegalStateException expected) {
-    }
-  }
-
-  @Test public void cannotSetChunkedStreamingModeAfterConnect() throws Exception {
-    server.enqueue(new MockResponse().setBody("A"));
-    connection = client.open(server.url("/").url());
-    assertEquals("A", readAscii(connection.getInputStream(), Integer.MAX_VALUE));
-    try {
-      connection.setChunkedStreamingMode(1);
-      fail();
-    } catch (IllegalStateException expected) {
-    }
-  }
-
-  @Test public void cannotSetFixedLengthStreamingModeAfterChunkedStreamingMode() throws Exception {
-    connection = client.open(server.url("/").url());
-    connection.setChunkedStreamingMode(1);
-    try {
-      connection.setFixedLengthStreamingMode(1);
-      fail();
-    } catch (IllegalStateException expected) {
-    }
-  }
-
-  @Test public void cannotSetChunkedStreamingModeAfterFixedLengthStreamingMode() throws Exception {
-    connection = client.open(server.url("/").url());
-    connection.setFixedLengthStreamingMode(1);
-    try {
-      connection.setChunkedStreamingMode(1);
-      fail();
-    } catch (IllegalStateException expected) {
-    }
-  }
-
-  @Test public void secureFixedLengthStreaming() throws Exception {
-    testSecureStreamingPost(StreamingMode.FIXED_LENGTH);
-  }
-
-  @Test public void secureChunkedStreaming() throws Exception {
-    testSecureStreamingPost(StreamingMode.CHUNKED);
-  }
-
-  /**
+   */
+    private void testClientConfiguredGzipContentEncodingAndConnectionReuse(TransferKind transferKind, boolean tls) throws Exception {
+        if (tls) {
+            SSLSocketFactory socketFactory = sslContext.getSocketFactory();
+            RecordingHostnameVerifier hostnameVerifier = new RecordingHostnameVerifier();
+            server.useHttps(socketFactory, false);
+            client.client().setSslSocketFactory(socketFactory);
+            client.client().setHostnameVerifier(hostnameVerifier);
+        }
+        MockResponse responseOne = new MockResponse();
+        responseOne.addHeader("Content-Encoding: gzip");
+        transferKind.setBody(responseOne, gzip("one (gzipped)"), 5);
+        server.enqueue(responseOne);
+        MockResponse responseTwo = new MockResponse();
+        transferKind.setBody(responseTwo, "two (identity)", 5);
+        server.enqueue(responseTwo);
+        HttpURLConnection connection1 = client.open(server.url("/").url());
+        connection1.addRequestProperty("Accept-Encoding", "gzip");
+        InputStream gunzippedIn = new GZIPInputStream(connection1.getInputStream());
+        assertEquals("one (gzipped)", readAscii(gunzippedIn, Integer.MAX_VALUE));
+        assertEquals(0, server.takeRequest().getSequenceNumber());
+        HttpURLConnection connection2 = client.open(server.url("/").url());
+        assertEquals("two (identity)", readAscii(connection2.getInputStream(), Integer.MAX_VALUE));
+        assertEquals(1, server.takeRequest().getSequenceNumber());
+    }
+
+    @Test
+    public void transparentGzipWorksAfterExceptionRecovery() throws Exception {
+        server.enqueue(new MockResponse().setBody("a").setSocketPolicy(SHUTDOWN_INPUT_AT_END));
+        server.enqueue(new MockResponse().addHeader("Content-Encoding: gzip").setBody(gzip("b")));
+        assertContent("a", client.open(server.url("/").url()));
+        Thread.sleep(500);
+        assertContent("b", client.open(server.url("/").url()));
+        assertEquals(0, server.takeRequest().getSequenceNumber());
+        assertEquals(0, server.takeRequest().getSequenceNumber());
+    }
+
+    @Test
+    public void endOfStreamResponseIsNotPooled() throws Exception {
+        server.enqueue(new MockResponse().setBody("{}").clearHeaders().setSocketPolicy(DISCONNECT_AT_END));
+        ConnectionPool pool = ConnectionPool.getDefault();
+        pool.evictAll();
+        client.client().setConnectionPool(pool);
+        HttpURLConnection connection = client.open(server.url("/").url());
+        assertContent("{}", connection);
+        assertEquals(0, client.client().getConnectionPool().getIdleConnectionCount());
+    }
+
+    @Test
+    public void earlyDisconnectDoesntHarmPoolingWithChunkedEncoding() throws Exception {
+        testEarlyDisconnectDoesntHarmPooling(TransferKind.CHUNKED);
+    }
+
+    @Test
+    public void earlyDisconnectDoesntHarmPoolingWithFixedLengthEncoding() throws Exception {
+        testEarlyDisconnectDoesntHarmPooling(TransferKind.FIXED_LENGTH);
+    }
+
+    private void testEarlyDisconnectDoesntHarmPooling(TransferKind transferKind) throws Exception {
+        MockResponse response1 = new MockResponse();
+        transferKind.setBody(response1, "ABCDEFGHIJK", 1024);
+        server.enqueue(response1);
+        MockResponse response2 = new MockResponse();
+        transferKind.setBody(response2, "LMNOPQRSTUV", 1024);
+        server.enqueue(response2);
+        HttpURLConnection connection1 = client.open(server.url("/").url());
+        InputStream in1 = connection1.getInputStream();
+        assertEquals("ABCDE", readAscii(in1, 5));
+        in1.close();
+        connection1.disconnect();
+        HttpURLConnection connection2 = client.open(server.url("/").url());
+        InputStream in2 = connection2.getInputStream();
+        assertEquals("LMNOP", readAscii(in2, 5));
+        in2.close();
+        connection2.disconnect();
+        assertEquals(0, server.takeRequest().getSequenceNumber());
+        assertEquals(1, server.takeRequest().getSequenceNumber());
+    }
+
+    @Test
+    public void streamDiscardingIsTimely() throws Exception {
+        server.enqueue(new MockResponse().setBody(new Buffer().write(new byte[10000])).throttleBody(100, 10, MILLISECONDS));
+        server.enqueue(new MockResponse().setBody("A"));
+        long startNanos = System.nanoTime();
+        URLConnection connection1 = client.open(server.url("/").url());
+        InputStream in = connection1.getInputStream();
+        in.close();
+        long elapsedNanos = System.nanoTime() - startNanos;
+        long elapsedMillis = NANOSECONDS.toMillis(elapsedNanos);
+        assertTrue(String.format("Time to close: %sms", elapsedMillis), elapsedMillis < 500);
+        assertContent("A", client.open(server.url("/").url()));
+        assertEquals(0, server.takeRequest().getSequenceNumber());
+        assertEquals(0, server.takeRequest().getSequenceNumber());
+    }
+
+    @Test
+    public void setChunkedStreamingMode() throws IOException, InterruptedException {
+        server.enqueue(new MockResponse());
+        String body = "ABCDEFGHIJKLMNOPQ";
+        connection = client.open(server.url("/").url());
+        connection.setChunkedStreamingMode(0);
+        connection.setDoOutput(true);
+        OutputStream outputStream = connection.getOutputStream();
+        outputStream.write(body.getBytes("US-ASCII"));
+        assertEquals(200, connection.getResponseCode());
+        connection.getInputStream().close();
+        RecordedRequest request = server.takeRequest();
+        assertEquals(body, request.getBody().readUtf8());
+        assertEquals(Arrays.asList(body.length()), request.getChunkSizes());
+    }
+
+    @Test
+    public void authenticateWithFixedLengthStreaming() throws Exception {
+        testAuthenticateWithStreamingPost(StreamingMode.FIXED_LENGTH);
+    }
+
+    @Test
+    public void authenticateWithChunkedStreaming() throws Exception {
+        testAuthenticateWithStreamingPost(StreamingMode.CHUNKED);
+    }
+
+    private void testAuthenticateWithStreamingPost(StreamingMode streamingMode) throws Exception {
+        MockResponse pleaseAuthenticate = new MockResponse().setResponseCode(401).addHeader("WWW-Authenticate: Basic realm=\"protected area\"").setBody("Please authenticate.");
+        server.enqueue(pleaseAuthenticate);
+        Authenticator.setDefault(new RecordingAuthenticator());
+        connection = client.open(server.url("/").url());
+        connection.setDoOutput(true);
+        byte[] requestBody = { 'A', 'B', 'C', 'D' };
+        if (streamingMode == StreamingMode.FIXED_LENGTH) {
+            connection.setFixedLengthStreamingMode(requestBody.length);
+        } else {
+            if (streamingMode == StreamingMode.CHUNKED) {
+                connection.setChunkedStreamingMode(0);
+            }
+        }
+        OutputStream outputStream = connection.getOutputStream();
+        outputStream.write(requestBody);
+        outputStream.close();
+        try {
+            connection.getInputStream();
+            fail();
+        } catch (HttpRetryException expected) {
+        }
+        RecordedRequest request = server.takeRequest();
+        assertNull(request.getHeader("Authorization"));
+        assertEquals("ABCD", request.getBody().readUtf8());
+    }
+
+    @Test
+    public void postBodyRetransmittedAfterAuthorizationFail() throws Exception {
+        postBodyRetransmittedAfterAuthorizationFail("abc");
+    }
+
+    @Test
+    public void postBodyRetransmittedAfterAuthorizationFail_SPDY_3() throws Exception {
+        enableProtocol(Protocol.SPDY_3);
+        postBodyRetransmittedAfterAuthorizationFail("abc");
+    }
+
+    @Test
+    public void postBodyRetransmittedAfterAuthorizationFail_HTTP_2() throws Exception {
+        enableProtocol(Protocol.HTTP_2);
+        postBodyRetransmittedAfterAuthorizationFail("abc");
+    }
+
+    /** Don't explode when resending an empty post. https://github.com/square/okhttp/issues/1131 */
+    @Test
+    public void postEmptyBodyRetransmittedAfterAuthorizationFail() throws Exception {
+        postBodyRetransmittedAfterAuthorizationFail("");
+    }
+
+    @Test
+    public void postEmptyBodyRetransmittedAfterAuthorizationFail_SPDY_3() throws Exception {
+        enableProtocol(Protocol.SPDY_3);
+        postBodyRetransmittedAfterAuthorizationFail("");
+    }
+
+    @Test
+    public void postEmptyBodyRetransmittedAfterAuthorizationFail_HTTP_2() throws Exception {
+        enableProtocol(Protocol.HTTP_2);
+        postBodyRetransmittedAfterAuthorizationFail("");
+    }
+
+    private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exception {
+        server.enqueue(new MockResponse().setResponseCode(401));
+        server.enqueue(new MockResponse());
+        String credential = Credentials.basic("jesse", "secret");
+        client.client().setAuthenticator(new RecordingOkAuthenticator(credential));
+        connection = client.open(server.url("/").url());
+        connection.setDoOutput(true);
+        OutputStream outputStream = connection.getOutputStream();
+        outputStream.write(body.getBytes("UTF-8"));
+        outputStream.close();
+        assertEquals(200, connection.getResponseCode());
+        RecordedRequest recordedRequest1 = server.takeRequest();
+        assertEquals("POST", recordedRequest1.getMethod());
+        assertEquals(body, recordedRequest1.getBody().readUtf8());
+        assertNull(recordedRequest1.getHeader("Authorization"));
+        RecordedRequest recordedRequest2 = server.takeRequest();
+        assertEquals("POST", recordedRequest2.getMethod());
+        assertEquals(body, recordedRequest2.getBody().readUtf8());
+        assertEquals(credential, recordedRequest2.getHeader("Authorization"));
+    }
+
+    @Test
+    public void nonStandardAuthenticationScheme() throws Exception {
+        List<String> calls = authCallsForHeader("WWW-Authenticate: Foo");
+        assertEquals(Collections.<String>emptyList(), calls);
+    }
+
+    @Test
+    public void nonStandardAuthenticationSchemeWithRealm() throws Exception {
+        List<String> calls = authCallsForHeader("WWW-Authenticate: Foo realm=\"Bar\"");
+        assertEquals(0, calls.size());
+    }
+
+    // Digest auth is currently unsupported. Test that digest requests should fail reasonably.
+    // http://code.google.com/p/android/issues/detail?id=11140
+    @Test
+    public void digestAuthentication() throws Exception {
+        List<String> calls = authCallsForHeader("WWW-Authenticate: Digest " + "realm=\"testrealm@host.com\", qop=\"auth,auth-int\", " + "nonce=\"dcd98b7102dd2f0e8b11d0f600bfb0c093\", " + "opaque=\"5ccc069c403ebaf9f0171e9517f40e41\"");
+        assertEquals(0, calls.size());
+    }
+
+    @Test
+    public void allAttributesSetInServerAuthenticationCallbacks() throws Exception {
+        List<String> calls = authCallsForHeader("WWW-Authenticate: Basic realm=\"Bar\"");
+        assertEquals(1, calls.size());
+        URL url = server.url("/").url();
+        String call = calls.get(0);
+        assertTrue(call, call.contains("host=" + url.getHost()));
+        assertTrue(call, call.contains("port=" + url.getPort()));
+        assertTrue(call, call.contains("site=" + url.getHost()));
+        assertTrue(call, call.contains("url=" + url));
+        assertTrue(call, call.contains("type=" + Authenticator.RequestorType.SERVER));
+        assertTrue(call, call.contains("prompt=Bar"));
+        assertTrue(call, call.contains("protocol=http"));
+        assertTrue(call, call.toLowerCase().contains("scheme=basic"));
+    }
+
+    @Test
+    public void allAttributesSetInProxyAuthenticationCallbacks() throws Exception {
+        List<String> calls = authCallsForHeader("Proxy-Authenticate: Basic realm=\"Bar\"");
+        assertEquals(1, calls.size());
+        URL url = server.url("/").url();
+        String call = calls.get(0);
+        assertTrue(call, call.contains("host=" + url.getHost()));
+        assertTrue(call, call.contains("port=" + url.getPort()));
+        assertTrue(call, call.contains("site=" + url.getHost()));
+        assertTrue(call, call.contains("url=http://android.com"));
+        assertTrue(call, call.contains("type=" + Authenticator.RequestorType.PROXY));
+        assertTrue(call, call.contains("prompt=Bar"));
+        assertTrue(call, call.contains("protocol=http"));
+        assertTrue(call, call.toLowerCase().contains("scheme=basic"));
+    }
+
+    private List<String> authCallsForHeader(String authHeader) throws IOException {
+        boolean proxy = authHeader.startsWith("Proxy-");
+        int responseCode = proxy ? 407 : 401;
+        RecordingAuthenticator authenticator = new RecordingAuthenticator(null);
+        Authenticator.setDefault(authenticator);
+        MockResponse pleaseAuthenticate = new MockResponse().setResponseCode(responseCode).addHeader(authHeader).setBody("Please authenticate.");
+        server.enqueue(pleaseAuthenticate);
+        if (proxy) {
+            client.client().setProxy(server.toProxyAddress());
+            connection = client.open(new URL("http://android.com"));
+        } else {
+            connection = client.open(server.url("/").url());
+        }
+        assertEquals(responseCode, connection.getResponseCode());
+        connection.getErrorStream().close();
+        return authenticator.calls;
+    }
+
+    @Test
+    public void setValidRequestMethod() throws Exception {
+        assertValidRequestMethod("GET");
+        assertValidRequestMethod("DELETE");
+        assertValidRequestMethod("HEAD");
+        assertValidRequestMethod("OPTIONS");
+        assertValidRequestMethod("POST");
+        assertValidRequestMethod("PUT");
+        assertValidRequestMethod("TRACE");
+        assertValidRequestMethod("PATCH");
+    }
+
+    private void assertValidRequestMethod(String requestMethod) throws Exception {
+        connection = client.open(server.url("/").url());
+        connection.setRequestMethod(requestMethod);
+        assertEquals(requestMethod, connection.getRequestMethod());
+    }
+
+    @Test
+    public void setInvalidRequestMethodLowercase() throws Exception {
+        assertInvalidRequestMethod("get");
+    }
+
+    @Test
+    public void setInvalidRequestMethodConnect() throws Exception {
+        assertInvalidRequestMethod("CONNECT");
+    }
+
+    private void assertInvalidRequestMethod(String requestMethod) throws Exception {
+        connection = client.open(server.url("/").url());
+        try {
+            connection.setRequestMethod(requestMethod);
+            fail();
+        } catch (ProtocolException expected) {
+        }
+    }
+
+    @Test
+    public void shoutcast() throws Exception {
+        server.enqueue(new MockResponse().setStatus("ICY 200 OK").addHeader("Accept-Ranges: none").addHeader("Content-Type: audio/mpeg").addHeader("icy-br:128").addHeader("ice-audio-info: bitrate=128;samplerate=44100;channels=2").addHeader("icy-br:128").addHeader("icy-description:Rock").addHeader("icy-genre:riders").addHeader("icy-name:A2RRock").addHeader("icy-pub:1").addHeader("icy-url:http://www.A2Rradio.com").addHeader("Server: Icecast 2.3.3-kh8").addHeader("Cache-Control: no-cache").addHeader("Pragma: no-cache").addHeader("Expires: Mon, 26 Jul 1997 05:00:00 GMT").addHeader("icy-metaint:16000").setBody("mp3 data"));
+        connection = client.open(server.url("/").url());
+        assertEquals(200, connection.getResponseCode());
+        assertEquals("OK", connection.getResponseMessage());
+        assertContent("mp3 data", connection);
+    }
+
+    @Test
+    public void cannotSetNegativeFixedLengthStreamingMode() throws Exception {
+        connection = client.open(server.url("/").url());
+        try {
+            connection.setFixedLengthStreamingMode(-2);
+            fail();
+        } catch (IllegalArgumentException expected) {
+        }
+    }
+
+    @Test
+    public void canSetNegativeChunkedStreamingMode() throws Exception {
+        connection = client.open(server.url("/").url());
+        connection.setChunkedStreamingMode(-2);
+    }
+
+    @Test
+    public void cannotSetFixedLengthStreamingModeAfterConnect() throws Exception {
+        server.enqueue(new MockResponse().setBody("A"));
+        connection = client.open(server.url("/").url());
+        assertEquals("A", readAscii(connection.getInputStream(), Integer.MAX_VALUE));
+        try {
+            connection.setFixedLengthStreamingMode(1);
+            fail();
+        } catch (IllegalStateException expected) {
+        }
+    }
+
+    @Test
+    public void cannotSetChunkedStreamingModeAfterConnect() throws Exception {
+        server.enqueue(new MockResponse().setBody("A"));
+        connection = client.open(server.url("/").url());
+        assertEquals("A", readAscii(connection.getInputStream(), Integer.MAX_VALUE));
+        try {
+            connection.setChunkedStreamingMode(1);
+            fail();
+        } catch (IllegalStateException expected) {
+        }
+    }
+
+    @Test
+    public void cannotSetFixedLengthStreamingModeAfterChunkedStreamingMode() throws Exception {
+        connection = client.open(server.url("/").url());
+        connection.setChunkedStreamingMode(1);
+        try {
+            connection.setFixedLengthStreamingMode(1);
+            fail();
+        } catch (IllegalStateException expected) {
+        }
+    }
+
+    @Test
+    public void cannotSetChunkedStreamingModeAfterFixedLengthStreamingMode() throws Exception {
+        connection = client.open(server.url("/").url());
+        connection.setFixedLengthStreamingMode(1);
+        try {
+            connection.setChunkedStreamingMode(1);
+            fail();
+        } catch (IllegalStateException expected) {
+        }
+    }
+
+    @Test
+    public void secureFixedLengthStreaming() throws Exception {
+        testSecureStreamingPost(StreamingMode.FIXED_LENGTH);
+    }
+
+    @Test
+    public void secureChunkedStreaming() throws Exception {
+        testSecureStreamingPost(StreamingMode.CHUNKED);
+    }
+
+    /**
    * Users have reported problems using HTTPS with streaming request bodies.
    * http://code.google.com/p/android/issues/detail?id=12860
-   */
-  private void testSecureStreamingPost(StreamingMode streamingMode) throws Exception {
-    server.useHttps(sslContext.getSocketFactory(), false);
-    server.enqueue(new MockResponse().setBody("Success!"));
-
-    client.client().setSslSocketFactory(sslContext.getSocketFactory());
-    client.client().setHostnameVerifier(new RecordingHostnameVerifier());
-    connection = client.open(server.url("/").url());
-    connection.setDoOutput(true);
-    byte[] requestBody = { 'A', 'B', 'C', 'D' };
-    if (streamingMode == StreamingMode.FIXED_LENGTH) {
-      connection.setFixedLengthStreamingMode(requestBody.length);
-    } else if (streamingMode == StreamingMode.CHUNKED) {
-      connection.setChunkedStreamingMode(0);
-    }
-    OutputStream outputStream = connection.getOutputStream();
-    outputStream.write(requestBody);
-    outputStream.close();
-    assertEquals("Success!", readAscii(connection.getInputStream(), Integer.MAX_VALUE));
-
-    RecordedRequest request = server.takeRequest();
-    assertEquals("POST / HTTP/1.1", request.getRequestLine());
-    if (streamingMode == StreamingMode.FIXED_LENGTH) {
-      assertEquals(Collections.<Integer>emptyList(), request.getChunkSizes());
-    } else if (streamingMode == StreamingMode.CHUNKED) {
-      assertEquals(Arrays.asList(4), request.getChunkSizes());
-    }
-    assertEquals("ABCD", request.getBody().readUtf8());
-  }
-
-  enum StreamingMode {
-    FIXED_LENGTH, CHUNKED
-  }
-
-  @Test public void authenticateWithPost() throws Exception {
-    MockResponse pleaseAuthenticate = new MockResponse().setResponseCode(401)
-        .addHeader("WWW-Authenticate: Basic realm=\"protected area\"")
-        .setBody("Please authenticate.");
-    // fail auth three times...
-    server.enqueue(pleaseAuthenticate);
-    server.enqueue(pleaseAuthenticate);
-    server.enqueue(pleaseAuthenticate);
-    // ...then succeed the fourth time
-    server.enqueue(new MockResponse().setBody("Successful auth!"));
-
-    Authenticator.setDefault(new RecordingAuthenticator());
-    connection = client.open(server.url("/").url());
-    connection.setDoOutput(true);
-    byte[] requestBody = { 'A', 'B', 'C', 'D' };
-    OutputStream outputStream = connection.getOutputStream();
-    outputStream.write(requestBody);
-    outputStream.close();
-    assertEquals("Successful auth!", readAscii(connection.getInputStream(), Integer.MAX_VALUE));
-
-    // no authorization header for the first request...
-    RecordedRequest request = server.takeRequest();
-    assertNull(request.getHeader("Authorization"));
-
-    // ...but the three requests that follow include an authorization header
-    for (int i = 0; i < 3; i++) {
-      request = server.takeRequest();
-      assertEquals("POST / HTTP/1.1", request.getRequestLine());
-      assertEquals("Basic " + RecordingAuthenticator.BASE_64_CREDENTIALS,
-          request.getHeader("Authorization"));
-      assertEquals("ABCD", request.getBody().readUtf8());
-    }
-  }
-
-  @Test public void authenticateWithGet() throws Exception {
-    MockResponse pleaseAuthenticate = new MockResponse().setResponseCode(401)
-        .addHeader("WWW-Authenticate: Basic realm=\"protected area\"")
-        .setBody("Please authenticate.");
-    // fail auth three times...
-    server.enqueue(pleaseAuthenticate);
-    server.enqueue(pleaseAuthenticate);
-    server.enqueue(pleaseAuthenticate);
-    // ...then succeed the fourth time
-    server.enqueue(new MockResponse().setBody("Successful auth!"));
-
-    Authenticator.setDefault(new RecordingAuthenticator());
-    connection = client.open(server.url("/").url());
-    assertEquals("Successful auth!", readAscii(connection.getInputStream(), Integer.MAX_VALUE));
-
-    // no authorization header for the first request...
-    RecordedRequest request = server.takeRequest();
-    assertNull(request.getHeader("Authorization"));
-
-    // ...but the three requests that follow requests include an authorization header
-    for (int i = 0; i < 3; i++) {
-      request = server.takeRequest();
-      assertEquals("GET / HTTP/1.1", request.getRequestLine());
-      assertEquals("Basic " + RecordingAuthenticator.BASE_64_CREDENTIALS,
-          request.getHeader("Authorization"));
-    }
-  }
-
-  /** https://code.google.com/p/android/issues/detail?id=74026 */
-  @Test public void authenticateWithGetAndTransparentGzip() throws Exception {
-    MockResponse pleaseAuthenticate = new MockResponse().setResponseCode(401)
-        .addHeader("WWW-Authenticate: Basic realm=\"protected area\"")
-        .setBody("Please authenticate.");
-    // fail auth three times...
-    server.enqueue(pleaseAuthenticate);
-    server.enqueue(pleaseAuthenticate);
-    server.enqueue(pleaseAuthenticate);
-    // ...then succeed the fourth time
-    MockResponse successfulResponse = new MockResponse()
-        .addHeader("Content-Encoding", "gzip")
-        .setBody(gzip("Successful auth!"));
-    server.enqueue(successfulResponse);
-
-    Authenticator.setDefault(new RecordingAuthenticator());
-    connection = client.open(server.url("/").url());
-    assertEquals("Successful auth!", readAscii(connection.getInputStream(), Integer.MAX_VALUE));
-
-    // no authorization header for the first request...
-    RecordedRequest request = server.takeRequest();
-    assertNull(request.getHeader("Authorization"));
-
-    // ...but the three requests that follow requests include an authorization header
-    for (int i = 0; i < 3; i++) {
-      request = server.takeRequest();
-      assertEquals("GET / HTTP/1.1", request.getRequestLine());
-      assertEquals("Basic " + RecordingAuthenticator.BASE_64_CREDENTIALS,
-          request.getHeader("Authorization"));
-    }
-  }
-
-  /** https://github.com/square/okhttp/issues/342 */
-  @Test public void authenticateRealmUppercase() throws Exception {
-    server.enqueue(new MockResponse().setResponseCode(401)
-        .addHeader("wWw-aUtHeNtIcAtE: bAsIc rEaLm=\"pRoTeCtEd aReA\"")
-        .setBody("Please authenticate."));
-    server.enqueue(new MockResponse().setBody("Successful auth!"));
-
-    Authenticator.setDefault(new RecordingAuthenticator());
-    connection = client.open(server.url("/").url());
-    assertEquals("Successful auth!", readAscii(connection.getInputStream(), Integer.MAX_VALUE));
-  }
-
-  @Test public void redirectedWithChunkedEncoding() throws Exception {
-    testRedirected(TransferKind.CHUNKED, true);
-  }
-
-  @Test public void redirectedWithContentLengthHeader() throws Exception {
-    testRedirected(TransferKind.FIXED_LENGTH, true);
-  }
-
-  @Test public void redirectedWithNoLengthHeaders() throws Exception {
-    testRedirected(TransferKind.END_OF_STREAM, false);
-  }
-
-  private void testRedirected(TransferKind transferKind, boolean reuse) throws Exception {
-    MockResponse response = new MockResponse().setResponseCode(HttpURLConnection.HTTP_MOVED_TEMP)
-        .addHeader("Location: /foo");
-    transferKind.setBody(response, "This page has moved!", 10);
-    server.enqueue(response);
-    server.enqueue(new MockResponse().setBody("This is the new location!"));
-
-    URLConnection connection = client.open(server.url("/").url());
-    assertEquals("This is the new location!",
-        readAscii(connection.getInputStream(), Integer.MAX_VALUE));
-
-    RecordedRequest first = server.takeRequest();
-    assertEquals("GET / HTTP/1.1", first.getRequestLine());
-    RecordedRequest retry = server.takeRequest();
-    assertEquals("GET /foo HTTP/1.1", retry.getRequestLine());
-    if (reuse) {
-      assertEquals("Expected connection reuse", 1, retry.getSequenceNumber());
-    }
-  }
-
-  @Test public void redirectedOnHttps() throws IOException, InterruptedException {
-    server.useHttps(sslContext.getSocketFactory(), false);
-    server.enqueue(new MockResponse().setResponseCode(HttpURLConnection.HTTP_MOVED_TEMP)
-        .addHeader("Location: /foo")
-        .setBody("This page has moved!"));
-    server.enqueue(new MockResponse().setBody("This is the new location!"));
-
-    client.client().setSslSocketFactory(sslContext.getSocketFactory());
-    client.client().setHostnameVerifier(new RecordingHostnameVerifier());
-    connection = client.open(server.url("/").url());
-    assertEquals("This is the new location!",
-        readAscii(connection.getInputStream(), Integer.MAX_VALUE));
-
-    RecordedRequest first = server.takeRequest();
-    assertEquals("GET / HTTP/1.1", first.getRequestLine());
-    RecordedRequest retry = server.takeRequest();
-    assertEquals("GET /foo HTTP/1.1", retry.getRequestLine());
-    assertEquals("Expected connection reuse", 1, retry.getSequenceNumber());
-  }
-
-  @Test public void notRedirectedFromHttpsToHttp() throws IOException, InterruptedException {
-    server.useHttps(sslContext.getSocketFactory(), false);
-    server.enqueue(new MockResponse().setResponseCode(HttpURLConnection.HTTP_MOVED_TEMP)
-        .addHeader("Location: http://anyhost/foo")
-        .setBody("This page has moved!"));
-
-    client.client().setFollowSslRedirects(false);
-    client.client().setSslSocketFactory(sslContext.getSocketFactory());
-    client.client().setHostnameVerifier(new RecordingHostnameVerifier());
-    connection = client.open(server.url("/").url());
-    assertEquals("This page has moved!", readAscii(connection.getInputStream(), Integer.MAX_VALUE));
-  }
-
-  @Test public void notRedirectedFromHttpToHttps() throws IOException, InterruptedException {
-    server.enqueue(new MockResponse().setResponseCode(HttpURLConnection.HTTP_MOVED_TEMP)
-        .addHeader("Location: https://anyhost/foo")
-        .setBody("This page has moved!"));
-
-    client.client().setFollowSslRedirects(false);
-    connection = client.open(server.url("/").url());
-    assertEquals("This page has moved!", readAscii(connection.getInputStream(), Integer.MAX_VALUE));
-  }
-
-  @Test public void redirectedFromHttpsToHttpFollowingProtocolRedirects() throws Exception {
-    server2.enqueue(new MockResponse().setBody("This is insecure HTTP!"));
-
-    server.useHttps(sslContext.getSocketFactory(), false);
-    server.enqueue(new MockResponse().setResponseCode(HttpURLConnection.HTTP_MOVED_TEMP)
-        .addHeader("Location: " + server2.url("/").url())
-        .setBody("This page has moved!"));
-
-    client.client().setSslSocketFactory(sslContext.getSocketFactory());
-    client.client().setHostnameVerifier(new RecordingHostnameVerifier());
-    client.client().setFollowSslRedirects(true);
-    HttpsURLConnection connection = (HttpsURLConnection) client.open(server.url("/").url());
-    assertContent("This is insecure HTTP!", connection);
-    assertNull(connection.getCipherSuite());
-    assertNull(connection.getLocalCertificates());
-    assertNull(connection.getServerCertificates());
-    assertNull(connection.getPeerPrincipal());
-    assertNull(connection.getLocalPrincipal());
-  }
-
-  @Test public void redirectedFromHttpToHttpsFollowingProtocolRedirects() throws Exception {
-    server2.useHttps(sslContext.getSocketFactory(), false);
-    server2.enqueue(new MockResponse().setBody("This is secure HTTPS!"));
-
-    server.enqueue(new MockResponse().setResponseCode(HttpURLConnection.HTTP_MOVED_TEMP)
-        .addHeader("Location: " + server2.url("/").url())
-        .setBody("This page has moved!"));
-
-    client.client().setSslSocketFactory(sslContext.getSocketFactory());
-    client.client().setHostnameVerifier(new RecordingHostnameVerifier());
-    client.client().setFollowSslRedirects(true);
-    connection = client.open(server.url("/").url());
-    assertContent("This is secure HTTPS!", connection);
-    assertFalse(connection instanceof HttpsURLConnection);
-  }
-
-  @Test public void redirectToAnotherOriginServer() throws Exception {
-    redirectToAnotherOriginServer(false);
-  }
-
-  @Test public void redirectToAnotherOriginServerWithHttps() throws Exception {
-    redirectToAnotherOriginServer(true);
-  }
-
-  private void redirectToAnotherOriginServer(boolean https) throws Exception {
-    if (https) {
-      server.useHttps(sslContext.getSocketFactory(), false);
-      server2.useHttps(sslContext.getSocketFactory(), false);
-      server2.setProtocolNegotiationEnabled(false);
-      client.client().setSslSocketFactory(sslContext.getSocketFactory());
-      client.client().setHostnameVerifier(new RecordingHostnameVerifier());
-    }
-
-    server2.enqueue(new MockResponse().setBody("This is the 2nd server!"));
-    server2.enqueue(new MockResponse().setBody("This is the 2nd server, again!"));
-
-    server.enqueue(new MockResponse().setResponseCode(HttpURLConnection.HTTP_MOVED_TEMP)
-        .addHeader("Location: " + server2.url("/").url().toString())
-        .setBody("This page has moved!"));
-    server.enqueue(new MockResponse().setBody("This is the first server again!"));
-
-    connection = client.open(server.url("/").url());
-    assertContent("This is the 2nd server!", connection);
-    assertEquals(server2.url("/").url(), connection.getURL());
-
-    // make sure the first server was careful to recycle the connection
-    assertContent("This is the first server again!", client.open(server.url("/").url()));
-    assertContent("This is the 2nd server, again!", client.open(server2.url("/").url()));
-
-    String server1Host = server.getHostName() + ":" + server.getPort();
-    String server2Host = server2.getHostName() + ":" + server2.getPort();
-    assertEquals(server1Host, server.takeRequest().getHeader("Host"));
-    assertEquals(server2Host, server2.takeRequest().getHeader("Host"));
-    assertEquals("Expected connection reuse", 1, server.takeRequest().getSequenceNumber());
-    assertEquals("Expected connection reuse", 1, server2.takeRequest().getSequenceNumber());
-  }
-
-  @Test public void redirectWithProxySelector() throws Exception {
-    final List<URI> proxySelectionRequests = new ArrayList<URI>();
-    client.client().setProxySelector(new ProxySelector() {
-      @Override public List<Proxy> select(URI uri) {
-        proxySelectionRequests.add(uri);
-        MockWebServer proxyServer = (uri.getPort() == server.getPort())
-            ? server
-            : server2;
-        return Arrays.asList(proxyServer.toProxyAddress());
-      }
-
-      @Override public void connectFailed(URI uri, SocketAddress address, IOException failure) {
-        throw new AssertionError();
-      }
-    });
-
-    server2.enqueue(new MockResponse().setBody("This is the 2nd server!"));
-
-    server.enqueue(new MockResponse().setResponseCode(HttpURLConnection.HTTP_MOVED_TEMP)
-        .addHeader("Location: " + server2.url("/b").url().toString())
-        .setBody("This page has moved!"));
-
-    assertContent("This is the 2nd server!", client.open(server.url("/a").url()));
-
-    assertEquals(Arrays.asList(server.url("/").url().toURI(), server2.url("/").url().toURI()),
-        proxySelectionRequests);
-  }
-
-  @Test public void redirectWithAuthentication() throws Exception {
-    server2.enqueue(new MockResponse().setBody("Page 2"));
-
-    server.enqueue(new MockResponse().setResponseCode(401));
-    server.enqueue(new MockResponse().setResponseCode(302)
-        .addHeader("Location: " + server2.url("/b").url()));
-
-    client.client().setAuthenticator(
-        new RecordingOkAuthenticator(Credentials.basic("jesse", "secret")));
-    assertContent("Page 2", client.open(server.url("/a").url()));
-
-    RecordedRequest redirectRequest = server2.takeRequest();
-    assertNull(redirectRequest.getHeader("Authorization"));
-    assertEquals("/b", redirectRequest.getPath());
-  }
-
-  @Test public void response300MultipleChoiceWithPost() throws Exception {
-    // Chrome doesn't follow the redirect, but Firefox and the RI both do
-    testResponseRedirectedWithPost(HttpURLConnection.HTTP_MULT_CHOICE, TransferKind.END_OF_STREAM);
-  }
-
-  @Test public void response301MovedPermanentlyWithPost() throws Exception {
-    testResponseRedirectedWithPost(HttpURLConnection.HTTP_MOVED_PERM, TransferKind.END_OF_STREAM);
-  }
-
-  @Test public void response302MovedTemporarilyWithPost() throws Exception {
-    testResponseRedirectedWithPost(HttpURLConnection.HTTP_MOVED_TEMP, TransferKind.END_OF_STREAM);
-  }
-
-  @Test public void response303SeeOtherWithPost() throws Exception {
-    testResponseRedirectedWithPost(HttpURLConnection.HTTP_SEE_OTHER, TransferKind.END_OF_STREAM);
-  }
-
-  @Test public void postRedirectToGetWithChunkedRequest() throws Exception {
-    testResponseRedirectedWithPost(HttpURLConnection.HTTP_MOVED_TEMP, TransferKind.CHUNKED);
-  }
-
-  @Test public void postRedirectToGetWithStreamedRequest() throws Exception {
-    testResponseRedirectedWithPost(HttpURLConnection.HTTP_MOVED_TEMP, TransferKind.FIXED_LENGTH);
-  }
-
-  private void testResponseRedirectedWithPost(int redirectCode, TransferKind transferKind)
-      throws Exception {
-    server.enqueue(new MockResponse().setResponseCode(redirectCode)
-        .addHeader("Location: /page2")
-        .setBody("This page has moved!"));
-    server.enqueue(new MockResponse().setBody("Page 2"));
-
-    connection = client.open(server.url("/page1").url());
-    connection.setDoOutput(true);
-    transferKind.setForRequest(connection, 4);
-    byte[] requestBody = { 'A', 'B', 'C', 'D' };
-    OutputStream outputStream = connection.getOutputStream();
-    outputStream.write(requestBody);
-    outputStream.close();
-    assertEquals("Page 2", readAscii(connection.getInputStream(), Integer.MAX_VALUE));
-    assertTrue(connection.getDoOutput());
-
-    RecordedRequest page1 = server.takeRequest();
-    assertEquals("POST /page1 HTTP/1.1", page1.getRequestLine());
-    assertEquals("ABCD", page1.getBody().readUtf8());
-
-    RecordedRequest page2 = server.takeRequest();
-    assertEquals("GET /page2 HTTP/1.1", page2.getRequestLine());
-  }
-
-  @Test public void redirectedPostStripsRequestBodyHeaders() throws Exception {
-    server.enqueue(new MockResponse().setResponseCode(HttpURLConnection.HTTP_MOVED_TEMP)
-        .addHeader("Location: /page2"));
-    server.enqueue(new MockResponse().setBody("Page 2"));
-
-    connection = client.open(server.url("/page1").url());
-    connection.setDoOutput(true);
-    connection.addRequestProperty("Content-Length", "4");
-    connection.addRequestProperty("Content-Type", "text/plain; charset=utf-8");
-    connection.addRequestProperty("Transfer-Encoding", "identity");
-    OutputStream outputStream = connection.getOutputStream();
-    outputStream.write("ABCD".getBytes("UTF-8"));
-    outputStream.close();
-    assertEquals("Page 2", readAscii(connection.getInputStream(), Integer.MAX_VALUE));
-
-    assertEquals("POST /page1 HTTP/1.1", server.takeRequest().getRequestLine());
-
-    RecordedRequest page2 = server.takeRequest();
-    assertEquals("GET /page2 HTTP/1.1", page2.getRequestLine());
-    assertNull(page2.getHeader("Content-Length"));
-    assertNull(page2.getHeader("Content-Type"));
-    assertNull(page2.getHeader("Transfer-Encoding"));
-  }
-
-  @Test public void response305UseProxy() throws Exception {
-    server.enqueue(new MockResponse().setResponseCode(HttpURLConnection.HTTP_USE_PROXY)
-        .addHeader("Location: " + server.url("/").url())
-        .setBody("This page has moved!"));
-    server.enqueue(new MockResponse().setBody("Proxy Response"));
-
-    connection = client.open(server.url("/foo").url());
-    // Fails on the RI, which gets "Proxy Response"
-    assertEquals("This page has moved!", readAscii(connection.getInputStream(), Integer.MAX_VALUE));
-
-    RecordedRequest page1 = server.takeRequest();
-    assertEquals("GET /foo HTTP/1.1", page1.getRequestLine());
-    assertEquals(1, server.getRequestCount());
-  }
-
-  @Test public void response307WithGet() throws Exception {
-    testRedirect(true, "GET");
-  }
-
-  @Test public void response307WithHead() throws Exception {
-    testRedirect(true, "HEAD");
-  }
-
-  @Test public void response307WithOptions() throws Exception {
-    testRedirect(true, "OPTIONS");
-  }
-
-  @Test public void response307WithPost() throws Exception {
-    testRedirect(true, "POST");
-  }
-
-  @Test public void response308WithGet() throws Exception {
-    testRedirect(false, "GET");
-  }
-
-  @Test public void response308WithHead() throws Exception {
-    testRedirect(false, "HEAD");
-  }
-
-  @Test public void response308WithOptions() throws Exception {
-    testRedirect(false, "OPTIONS");
-  }
-
-  @Test public void response308WithPost() throws Exception {
-    testRedirect(false, "POST");
-  }
-
-  private void testRedirect(boolean temporary, String method) throws Exception {
-    MockResponse response1 = new MockResponse()
-        .setResponseCode(temporary ? HTTP_TEMP_REDIRECT : HTTP_PERM_REDIRECT)
-        .addHeader("Location: /page2");
-    if (!method.equals("HEAD")) {
-      response1.setBody("This page has moved!");
-    }
-    server.enqueue(response1);
-    server.enqueue(new MockResponse().setBody("Page 2"));
-
-    connection = client.open(server.url("/page1").url());
-    connection.setRequestMethod(method);
-    byte[] requestBody = { 'A', 'B', 'C', 'D' };
-    if (method.equals("POST")) {
-      connection.setDoOutput(true);
-      OutputStream outputStream = connection.getOutputStream();
-      outputStream.write(requestBody);
-      outputStream.close();
-    }
-
-    String response = readAscii(connection.getInputStream(), Integer.MAX_VALUE);
-
-    RecordedRequest page1 = server.takeRequest();
-    assertEquals(method + " /page1 HTTP/1.1", page1.getRequestLine());
-
-    if (method.equals("GET")) {
-      assertEquals("Page 2", response);
-    } else if (method.equals("HEAD"))  {
-      assertEquals("", response);
-    } else {
-      // Methods other than GET/HEAD shouldn't follow the redirect
-      if (method.equals("POST")) {
-        assertTrue(connection.getDoOutput());
-        assertEquals("ABCD", page1.getBody().readUtf8());
-      }
-      assertEquals(1, server.getRequestCount());
-      assertEquals("This page has moved!", response);
-      return;
-    }
-
-    // GET/HEAD requests should have followed the redirect with the same method
-    assertFalse(connection.getDoOutput());
-    assertEquals(2, server.getRequestCount());
-    RecordedRequest page2 = server.takeRequest();
-    assertEquals(method + " /page2 HTTP/1.1", page2.getRequestLine());
-  }
-
-  @Test public void follow20Redirects() throws Exception {
-    for (int i = 0; i < 20; i++) {
-      server.enqueue(new MockResponse().setResponseCode(HttpURLConnection.HTTP_MOVED_TEMP)
-          .addHeader("Location: /" + (i + 1))
-          .setBody("Redirecting to /" + (i + 1)));
-    }
-    server.enqueue(new MockResponse().setBody("Success!"));
-
-    connection = client.open(server.url("/0").url());
-    assertContent("Success!", connection);
-    assertEquals(server.url("/20").url(), connection.getURL());
-  }
-
-  @Test public void doesNotFollow21Redirects() throws Exception {
-    for (int i = 0; i < 21; i++) {
-      server.enqueue(new MockResponse().setResponseCode(HttpURLConnection.HTTP_MOVED_TEMP)
-          .addHeader("Location: /" + (i + 1))
-          .setBody("Redirecting to /" + (i + 1)));
-    }
-
-    connection = client.open(server.url("/0").url());
-    try {
-      connection.getInputStream();
-      fail();
-    } catch (ProtocolException expected) {
-      assertEquals(HttpURLConnection.HTTP_MOVED_TEMP, connection.getResponseCode());
-      assertEquals("Too many follow-up requests: 21", expected.getMessage());
-      assertContent("Redirecting to /21", connection);
-      assertEquals(server.url("/20").url(), connection.getURL());
-    }
-  }
-
-  @Test public void httpsWithCustomTrustManager() throws Exception {
-    RecordingHostnameVerifier hostnameVerifier = new RecordingHostnameVerifier();
-    RecordingTrustManager trustManager = new RecordingTrustManager();
-    SSLContext sc = SSLContext.getInstance("TLS");
-    sc.init(null, new TrustManager[] { trustManager }, new java.security.SecureRandom());
-
-    client.client().setHostnameVerifier(hostnameVerifier);
-    client.client().setSslSocketFactory(sc.getSocketFactory());
-    server.useHttps(sslContext.getSocketFactory(), false);
-    server.enqueue(new MockResponse().setBody("ABC"));
-    server.enqueue(new MockResponse().setBody("DEF"));
-    server.enqueue(new MockResponse().setBody("GHI"));
-
-    URL url = server.url("/").url();
-    assertContent("ABC", client.open(url));
-    assertContent("DEF", client.open(url));
-    assertContent("GHI", client.open(url));
-
-    assertEquals(Arrays.asList("verify " + server.getHostName()),
-        hostnameVerifier.calls);
-    assertEquals(Arrays.asList("checkServerTrusted [CN=" + server.getHostName() + " 1]"),
-        trustManager.calls);
-  }
-
-  @Test public void readTimeouts() throws IOException {
-    // This relies on the fact that MockWebServer doesn't close the
-    // connection after a response has been sent. This causes the client to
-    // try to read more bytes than are sent, which results in a timeout.
-    MockResponse timeout =
-        new MockResponse().setBody("ABC").clearHeaders().addHeader("Content-Length: 4");
-    server.enqueue(timeout);
-    server.enqueue(new MockResponse().setBody("unused")); // to keep the server alive
-
-    URLConnection connection = client.open(server.url("/").url());
-    connection.setReadTimeout(1000);
-    InputStream in = connection.getInputStream();
-    assertEquals('A', in.read());
-    assertEquals('B', in.read());
-    assertEquals('C', in.read());
-    try {
-      in.read(); // if Content-Length was accurate, this would return -1 immediately
-      fail();
-    } catch (SocketTimeoutException expected) {
-    }
-    in.close();
-  }
-
-  /** Confirm that an unacknowledged write times out. */
-  @Test public void writeTimeouts() throws IOException {
-    MockWebServer server = new MockWebServer();
-    // Sockets on some platforms can have large buffers that mean writes do not block when
-    // required. These socket factories explicitly set the buffer sizes on sockets created.
-    final int SOCKET_BUFFER_SIZE = 4 * 1024;
-    server.setServerSocketFactory(
-        new DelegatingServerSocketFactory(ServerSocketFactory.getDefault()) {
-          @Override
-          protected ServerSocket configureServerSocket(ServerSocket serverSocket)
-              throws IOException {
-            serverSocket.setReceiveBufferSize(SOCKET_BUFFER_SIZE);
-            return serverSocket;
-          }
-        });
-    client.client().setSocketFactory(new DelegatingSocketFactory(SocketFactory.getDefault()) {
-      @Override
-      protected Socket configureSocket(Socket socket) throws IOException {
-        socket.setReceiveBufferSize(SOCKET_BUFFER_SIZE);
-        socket.setSendBufferSize(SOCKET_BUFFER_SIZE);
-        return socket;
-      }
-    });
-
-    server.start();
-    server.enqueue(new MockResponse()
-        .throttleBody(1, 1, TimeUnit.SECONDS)); // Prevent the server from reading!
-
-    client.client().setWriteTimeout(500, TimeUnit.MILLISECONDS);
-    connection = client.open(server.url("/").url());
-    connection.setDoOutput(true);
-    connection.setChunkedStreamingMode(0);
-    OutputStream out = connection.getOutputStream();
-    try {
-      byte[] data = new byte[2 * 1024 * 1024]; // 2 MiB.
-      out.write(data);
-      fail();
-    } catch (SocketTimeoutException expected) {
-    }
-  }
-
-  @Test public void setChunkedEncodingAsRequestProperty() throws IOException, InterruptedException {
-    server.enqueue(new MockResponse());
-
-    connection = client.open(server.url("/").url());
-    connection.setRequestProperty("Transfer-encoding", "chunked");
-    connection.setDoOutput(true);
-    connection.getOutputStream().write("ABC".getBytes("UTF-8"));
-    assertEquals(200, connection.getResponseCode());
-
-    RecordedRequest request = server.takeRequest();
-    assertEquals("ABC", request.getBody().readUtf8());
-  }
-
-  @Test public void connectionCloseInRequest() throws IOException, InterruptedException {
-    server.enqueue(new MockResponse()); // server doesn't honor the connection: close header!
-    server.enqueue(new MockResponse());
-
-    HttpURLConnection a = client.open(server.url("/").url());
-    a.setRequestProperty("Connection", "close");
-    assertEquals(200, a.getResponseCode());
-
-    HttpURLConnection b = client.open(server.url("/").url());
-    assertEquals(200, b.getResponseCode());
-
-    assertEquals(0, server.takeRequest().getSequenceNumber());
-    assertEquals("When connection: close is used, each request should get its own connection", 0,
-        server.takeRequest().getSequenceNumber());
-  }
-
-  @Test public void connectionCloseInResponse() throws IOException, InterruptedException {
-    server.enqueue(new MockResponse().addHeader("Connection: close"));
-    server.enqueue(new MockResponse());
-
-    HttpURLConnection a = client.open(server.url("/").url());
-    assertEquals(200, a.getResponseCode());
-
-    HttpURLConnection b = client.open(server.url("/").url());
-    assertEquals(200, b.getResponseCode());
-
-    assertEquals(0, server.takeRequest().getSequenceNumber());
-    assertEquals("When connection: close is used, each request should get its own connection", 0,
-        server.takeRequest().getSequenceNumber());
-  }
-
-  @Test public void connectionCloseWithRedirect() throws IOException, InterruptedException {
-    MockResponse response = new MockResponse().setResponseCode(HttpURLConnection.HTTP_MOVED_TEMP)
-        .addHeader("Location: /foo")
-        .addHeader("Connection: close");
-    server.enqueue(response);
-    server.enqueue(new MockResponse().setBody("This is the new location!"));
-
-    URLConnection connection = client.open(server.url("/").url());
-    assertEquals("This is the new location!",
-        readAscii(connection.getInputStream(), Integer.MAX_VALUE));
-
-    assertEquals(0, server.takeRequest().getSequenceNumber());
-    assertEquals("When connection: close is used, each request should get its own connection", 0,
-        server.takeRequest().getSequenceNumber());
-  }
-
-  /**
+   */
+    private void testSecureStreamingPost(StreamingMode streamingMode) throws Exception {
+        server.useHttps(sslContext.getSocketFactory(), false);
+        server.enqueue(new MockResponse().setBody("Success!"));
+        client.client().setSslSocketFactory(sslContext.getSocketFactory());
+        client.client().setHostnameVerifier(new RecordingHostnameVerifier());
+        connection = client.open(server.url("/").url());
+        connection.setDoOutput(true);
+        byte[] requestBody = { 'A', 'B', 'C', 'D' };
+        if (streamingMode == StreamingMode.FIXED_LENGTH) {
+            connection.setFixedLengthStreamingMode(requestBody.length);
+        } else {
+            if (streamingMode == StreamingMode.CHUNKED) {
+                connection.setChunkedStreamingMode(0);
+            }
+        }
+        OutputStream outputStream = connection.getOutputStream();
+        outputStream.write(requestBody);
+        outputStream.close();
+        assertEquals("Success!", readAscii(connection.getInputStream(), Integer.MAX_VALUE));
+        RecordedRequest request = server.takeRequest();
+        assertEquals("POST / HTTP/1.1", request.getRequestLine());
+        if (streamingMode == StreamingMode.FIXED_LENGTH) {
+            assertEquals(Collections.<Integer>emptyList(), request.getChunkSizes());
+        } else {
+            if (streamingMode == StreamingMode.CHUNKED) {
+                assertEquals(Arrays.asList(4), request.getChunkSizes());
+            }
+        }
+        assertEquals("ABCD", request.getBody().readUtf8());
+    }
+
+    enum StreamingMode {
+
+        FIXED_LENGTH(), CHUNKED()
+    }
+
+    @Test
+    public void authenticateWithPost() throws Exception {
+        MockResponse pleaseAuthenticate = new MockResponse().setResponseCode(401).addHeader("WWW-Authenticate: Basic realm=\"protected area\"").setBody("Please authenticate.");
+        server.enqueue(pleaseAuthenticate);
+        server.enqueue(pleaseAuthenticate);
+        server.enqueue(pleaseAuthenticate);
+        server.enqueue(new MockResponse().setBody("Successful auth!"));
+        Authenticator.setDefault(new RecordingAuthenticator());
+        connection = client.open(server.url("/").url());
+        connection.setDoOutput(true);
+        byte[] requestBody = { 'A', 'B', 'C', 'D' };
+        OutputStream outputStream = connection.getOutputStream();
+        outputStream.write(requestBody);
+        outputStream.close();
+        assertEquals("Successful auth!", readAscii(connection.getInputStream(), Integer.MAX_VALUE));
+        RecordedRequest request = server.takeRequest();
+        assertNull(request.getHeader("Authorization"));
+        for (int i = 0; i < 3; i++) {
+            request = server.takeRequest();
+            assertEquals("POST / HTTP/1.1", request.getRequestLine());
+            assertEquals("Basic " + RecordingAuthenticator.BASE_64_CREDENTIALS, request.getHeader("Authorization"));
+            assertEquals("ABCD", request.getBody().readUtf8());
+        }
+    }
+
+    @Test
+    public void authenticateWithGet() throws Exception {
+        MockResponse pleaseAuthenticate = new MockResponse().setResponseCode(401).addHeader("WWW-Authenticate: Basic realm=\"protected area\"").setBody("Please authenticate.");
+        server.enqueue(pleaseAuthenticate);
+        server.enqueue(pleaseAuthenticate);
+        server.enqueue(pleaseAuthenticate);
+        server.enqueue(new MockResponse().setBody("Successful auth!"));
+        Authenticator.setDefault(new RecordingAuthenticator());
+        connection = client.open(server.url("/").url());
+        assertEquals("Successful auth!", readAscii(connection.getInputStream(), Integer.MAX_VALUE));
+        RecordedRequest request = server.takeRequest();
+        assertNull(request.getHeader("Authorization"));
+        for (int i = 0; i < 3; i++) {
+            request = server.takeRequest();
+            assertEquals("GET / HTTP/1.1", request.getRequestLine());
+            assertEquals("Basic " + RecordingAuthenticator.BASE_64_CREDENTIALS, request.getHeader("Authorization"));
+        }
+    }
+
+    /** https://code.google.com/p/android/issues/detail?id=74026 */
+    @Test
+    public void authenticateWithGetAndTransparentGzip() throws Exception {
+        MockResponse pleaseAuthenticate = new MockResponse().setResponseCode(401).addHeader("WWW-Authenticate: Basic realm=\"protected area\"").setBody("Please authenticate.");
+        server.enqueue(pleaseAuthenticate);
+        server.enqueue(pleaseAuthenticate);
+        server.enqueue(pleaseAuthenticate);
+        MockResponse successfulResponse = new MockResponse().addHeader("Content-Encoding", "gzip").setBody(gzip("Successful auth!"));
+        server.enqueue(successfulResponse);
+        Authenticator.setDefault(new RecordingAuthenticator());
+        connection = client.open(server.url("/").url());
+        assertEquals("Successful auth!", readAscii(connection.getInputStream(), Integer.MAX_VALUE));
+        RecordedRequest request = server.takeRequest();
+        assertNull(request.getHeader("Authorization"));
+        for (int i = 0; i < 3; i++) {
+            request = server.takeRequest();
+            assertEquals("GET / HTTP/1.1", request.getRequestLine());
+            assertEquals("Basic " + RecordingAuthenticator.BASE_64_CREDENTIALS, request.getHeader("Authorization"));
+        }
+    }
+
+    /** https://github.com/square/okhttp/issues/342 */
+    @Test
+    public void authenticateRealmUppercase() throws Exception {
+        server.enqueue(new MockResponse().setResponseCode(401).addHeader("wWw-aUtHeNtIcAtE: bAsIc rEaLm=\"pRoTeCtEd aReA\"").setBody("Please authenticate."));
+        server.enqueue(new MockResponse().setBody("Successful auth!"));
+        Authenticator.setDefault(new RecordingAuthenticator());
+        connection = client.open(server.url("/").url());
+        assertEquals("Successful auth!", readAscii(connection.getInputStream(), Integer.MAX_VALUE));
+    }
+
+    @Test
+    public void redirectedWithChunkedEncoding() throws Exception {
+        testRedirected(TransferKind.CHUNKED, true);
+    }
+
+    @Test
+    public void redirectedWithContentLengthHeader() throws Exception {
+        testRedirected(TransferKind.FIXED_LENGTH, true);
+    }
+
+    @Test
+    public void redirectedWithNoLengthHeaders() throws Exception {
+        testRedirected(TransferKind.END_OF_STREAM, false);
+    }
+
+    private void testRedirected(TransferKind transferKind, boolean reuse) throws Exception {
+        MockResponse response = new MockResponse().setResponseCode(HttpURLConnection.HTTP_MOVED_TEMP).addHeader("Location: /foo");
+        transferKind.setBody(response, "This page has moved!", 10);
+        server.enqueue(response);
+        server.enqueue(new MockResponse().setBody("This is the new location!"));
+        URLConnection connection = client.open(server.url("/").url());
+        assertEquals("This is the new location!", readAscii(connection.getInputStream(), Integer.MAX_VALUE));
+        RecordedRequest first = server.takeRequest();
+        assertEquals("GET / HTTP/1.1", first.getRequestLine());
+        RecordedRequest retry = server.takeRequest();
+        assertEquals("GET /foo HTTP/1.1", retry.getRequestLine());
+        if (reuse) {
+            assertEquals("Expected connection reuse", 1, retry.getSequenceNumber());
+        }
+    }
+
+    @Test
+    public void redirectedOnHttps() throws IOException, InterruptedException {
+        server.useHttps(sslContext.getSocketFactory(), false);
+        server.enqueue(new MockResponse().setResponseCode(HttpURLConnection.HTTP_MOVED_TEMP).addHeader("Location: /foo").setBody("This page has moved!"));
+        server.enqueue(new MockResponse().setBody("This is the new location!"));
+        client.client().setSslSocketFactory(sslContext.getSocketFactory());
+        client.client().setHostnameVerifier(new RecordingHostnameVerifier());
+        connection = client.open(server.url("/").url());
+        assertEquals("This is the new location!", readAscii(connection.getInputStream(), Integer.MAX_VALUE));
+        RecordedRequest first = server.takeRequest();
+        assertEquals("GET / HTTP/1.1", first.getRequestLine());
+        RecordedRequest retry = server.takeRequest();
+        assertEquals("GET /foo HTTP/1.1", retry.getRequestLine());
+        assertEquals("Expected connection reuse", 1, retry.getSequenceNumber());
+    }
+
+    @Test
+    public void notRedirectedFromHttpsToHttp() throws IOException, InterruptedException {
+        server.useHttps(sslContext.getSocketFactory(), false);
+        server.enqueue(new MockResponse().setResponseCode(HttpURLConnection.HTTP_MOVED_TEMP).addHeader("Location: http://anyhost/foo").setBody("This page has moved!"));
+        client.client().setFollowSslRedirects(false);
+        client.client().setSslSocketFactory(sslContext.getSocketFactory());
+        client.client().setHostnameVerifier(new RecordingHostnameVerifier());
+        connection = client.open(server.url("/").url());
+        assertEquals("This page has moved!", readAscii(connection.getInputStream(), Integer.MAX_VALUE));
+    }
+
+    @Test
+    public void notRedirectedFromHttpToHttps() throws IOException, InterruptedException {
+        server.enqueue(new MockResponse().setResponseCode(HttpURLConnection.HTTP_MOVED_TEMP).addHeader("Location: https://anyhost/foo").setBody("This page has moved!"));
+        client.client().setFollowSslRedirects(false);
+        connection = client.open(server.url("/").url());
+        assertEquals("This page has moved!", readAscii(connection.getInputStream(), Integer.MAX_VALUE));
+    }
+
+    @Test
+    public void redirectedFromHttpsToHttpFollowingProtocolRedirects() throws Exception {
+        server2.enqueue(new MockResponse().setBody("This is insecure HTTP!"));
+        server.useHttps(sslContext.getSocketFactory(), false);
+        server.enqueue(new MockResponse().setResponseCode(HttpURLConnection.HTTP_MOVED_TEMP).addHeader("Location: " + server2.url("/").url()).setBody("This page has moved!"));
+        client.client().setSslSocketFactory(sslContext.getSocketFactory());
+        client.client().setHostnameVerifier(new RecordingHostnameVerifier());
+        client.client().setFollowSslRedirects(true);
+        HttpsURLConnection connection = (HttpsURLConnection) client.open(server.url("/").url());
+        assertContent("This is insecure HTTP!", connection);
+        assertNull(connection.getCipherSuite());
+        assertNull(connection.getLocalCertificates());
+        assertNull(connection.getServerCertificates());
+        assertNull(connection.getPeerPrincipal());
+        assertNull(connection.getLocalPrincipal());
+    }
+
+    @Test
+    public void redirectedFromHttpToHttpsFollowingProtocolRedirects() throws Exception {
+        server2.useHttps(sslContext.getSocketFactory(), false);
+        server2.enqueue(new MockResponse().setBody("This is secure HTTPS!"));
+        server.enqueue(new MockResponse().setResponseCode(HttpURLConnection.HTTP_MOVED_TEMP).addHeader("Location: " + server2.url("/").url()).setBody("This page has moved!"));
+        client.client().setSslSocketFactory(sslContext.getSocketFactory());
+        client.client().setHostnameVerifier(new RecordingHostnameVerifier());
+        client.client().setFollowSslRedirects(true);
+        connection = client.open(server.url("/").url());
+        assertContent("This is secure HTTPS!", connection);
+        assertFalse(connection instanceof HttpsURLConnection);
+    }
+
+    @Test
+    public void redirectToAnotherOriginServer() throws Exception {
+        redirectToAnotherOriginServer(false);
+    }
+
+    @Test
+    public void redirectToAnotherOriginServerWithHttps() throws Exception {
+        redirectToAnotherOriginServer(true);
+    }
+
+    private void redirectToAnotherOriginServer(boolean https) throws Exception {
+        if (https) {
+            server.useHttps(sslContext.getSocketFactory(), false);
+            server2.useHttps(sslContext.getSocketFactory(), false);
+            server2.setProtocolNegotiationEnabled(false);
+            client.client().setSslSocketFactory(sslContext.getSocketFactory());
+            client.client().setHostnameVerifier(new RecordingHostnameVerifier());
+        }
+        server2.enqueue(new MockResponse().setBody("This is the 2nd server!"));
+        server2.enqueue(new MockResponse().setBody("This is the 2nd server, again!"));
+        server.enqueue(new MockResponse().setResponseCode(HttpURLConnection.HTTP_MOVED_TEMP).addHeader("Location: " + server2.url("/").url().toString()).setBody("This page has moved!"));
+        server.enqueue(new MockResponse().setBody("This is the first server again!"));
+        connection = client.open(server.url("/").url());
+        assertContent("This is the 2nd server!", connection);
+        assertEquals(server2.url("/").url(), connection.getURL());
+        assertContent("This is the first server again!", client.open(server.url("/").url()));
+        assertContent("This is the 2nd server, again!", client.open(server2.url("/").url()));
+        String server1Host = server.getHostName() + ":" + server.getPort();
+        String server2Host = server2.getHostName() + ":" + server2.getPort();
+        assertEquals(server1Host, server.takeRequest().getHeader("Host"));
+        assertEquals(server2Host, server2.takeRequest().getHeader("Host"));
+        assertEquals("Expected connection reuse", 1, server.takeRequest().getSequenceNumber());
+        assertEquals("Expected connection reuse", 1, server2.takeRequest().getSequenceNumber());
+    }
+
+    @Test
+    public void redirectWithProxySelector() throws Exception {
+        final List<URI> proxySelectionRequests = new ArrayList<URI>();
+        client.client().setProxySelector(new ProxySelector() {
+
+            @Override
+            public List<Proxy> select(URI uri) {
+                proxySelectionRequests.add(uri);
+                MockWebServer proxyServer = (uri.getPort() == server.getPort()) ? server : server2;
+                return Arrays.asList(proxyServer.toProxyAddress());
+            }
+
+            @Override
+            public void connectFailed(URI uri, SocketAddress address, IOException failure) {
+                throw new AssertionError();
+            }
+        });
+        server2.enqueue(new MockResponse().setBody("This is the 2nd server!"));
+        server.enqueue(new MockResponse().setResponseCode(HttpURLConnection.HTTP_MOVED_TEMP).addHeader("Location: " + server2.url("/b").url().toString()).setBody("This page has moved!"));
+        assertContent("This is the 2nd server!", client.open(server.url("/a").url()));
+        assertEquals(Arrays.asList(server.url("/").url().toURI(), server2.url("/").url().toURI()), proxySelectionRequests);
+    }
+
+    @Test
+    public void redirectWithAuthentication() throws Exception {
+        server2.enqueue(new MockResponse().setBody("Page 2"));
+        server.enqueue(new MockResponse().setResponseCode(401));
+        server.enqueue(new MockResponse().setResponseCode(302).addHeader("Location: " + server2.url("/b").url()));
+        client.client().setAuthenticator(new RecordingOkAuthenticator(Credentials.basic("jesse", "secret")));
+        assertContent("Page 2", client.open(server.url("/a").url()));
+        RecordedRequest redirectRequest = server2.takeRequest();
+        assertNull(redirectRequest.getHeader("Authorization"));
+        assertEquals("/b", redirectRequest.getPath());
+    }
+
+    @Test
+    public void response300MultipleChoiceWithPost() throws Exception {
+        testResponseRedirectedWithPost(HttpURLConnection.HTTP_MULT_CHOICE, TransferKind.END_OF_STREAM);
+    }
+
+    @Test
+    public void response301MovedPermanentlyWithPost() throws Exception {
+        testResponseRedirectedWithPost(HttpURLConnection.HTTP_MOVED_PERM, TransferKind.END_OF_STREAM);
+    }
+
+    @Test
+    public void response302MovedTemporarilyWithPost() throws Exception {
+        testResponseRedirectedWithPost(HttpURLConnection.HTTP_MOVED_TEMP, TransferKind.END_OF_STREAM);
+    }
+
+    @Test
+    public void response303SeeOtherWithPost() throws Exception {
+        testResponseRedirectedWithPost(HttpURLConnection.HTTP_SEE_OTHER, TransferKind.END_OF_STREAM);
+    }
+
+    @Test
+    public void postRedirectToGetWithChunkedRequest() throws Exception {
+        testResponseRedirectedWithPost(HttpURLConnection.HTTP_MOVED_TEMP, TransferKind.CHUNKED);
+    }
+
+    @Test
+    public void postRedirectToGetWithStreamedRequest() throws Exception {
+        testResponseRedirectedWithPost(HttpURLConnection.HTTP_MOVED_TEMP, TransferKind.FIXED_LENGTH);
+    }
+
+    private void testResponseRedirectedWithPost(int redirectCode, TransferKind transferKind) throws Exception {
+        server.enqueue(new MockResponse().setResponseCode(redirectCode).addHeader("Location: /page2").setBody("This page has moved!"));
+        server.enqueue(new MockResponse().setBody("Page 2"));
+        connection = client.open(server.url("/page1").url());
+        connection.setDoOutput(true);
+        transferKind.setForRequest(connection, 4);
+        byte[] requestBody = { 'A', 'B', 'C', 'D' };
+        OutputStream outputStream = connection.getOutputStream();
+        outputStream.write(requestBody);
+        outputStream.close();
+        assertEquals("Page 2", readAscii(connection.getInputStream(), Integer.MAX_VALUE));
+        assertTrue(connection.getDoOutput());
+        RecordedRequest page1 = server.takeRequest();
+        assertEquals("POST /page1 HTTP/1.1", page1.getRequestLine());
+        assertEquals("ABCD", page1.getBody().readUtf8());
+        RecordedRequest page2 = server.takeRequest();
+        assertEquals("GET /page2 HTTP/1.1", page2.getRequestLine());
+    }
+
+    @Test
+    public void redirectedPostStripsRequestBodyHeaders() throws Exception {
+        server.enqueue(new MockResponse().setResponseCode(HttpURLConnection.HTTP_MOVED_TEMP).addHeader("Location: /page2"));
+        server.enqueue(new MockResponse().setBody("Page 2"));
+        connection = client.open(server.url("/page1").url());
+        connection.setDoOutput(true);
+        connection.addRequestProperty("Content-Length", "4");
+        connection.addRequestProperty("Content-Type", "text/plain; charset=utf-8");
+        connection.addRequestProperty("Transfer-Encoding", "identity");
+        OutputStream outputStream = connection.getOutputStream();
+        outputStream.write("ABCD".getBytes("UTF-8"));
+        outputStream.close();
+        assertEquals("Page 2", readAscii(connection.getInputStream(), Integer.MAX_VALUE));
+        assertEquals("POST /page1 HTTP/1.1", server.takeRequest().getRequestLine());
+        RecordedRequest page2 = server.takeRequest();
+        assertEquals("GET /page2 HTTP/1.1", page2.getRequestLine());
+        assertNull(page2.getHeader("Content-Length"));
+        assertNull(page2.getHeader("Content-Type"));
+        assertNull(page2.getHeader("Transfer-Encoding"));
+    }
+
+    @Test
+    public void response305UseProxy() throws Exception {
+        server.enqueue(new MockResponse().setResponseCode(HttpURLConnection.HTTP_USE_PROXY).addHeader("Location: " + server.url("/").url()).setBody("This page has moved!"));
+        server.enqueue(new MockResponse().setBody("Proxy Response"));
+        connection = client.open(server.url("/foo").url());
+        assertEquals("This page has moved!", readAscii(connection.getInputStream(), Integer.MAX_VALUE));
+        RecordedRequest page1 = server.takeRequest();
+        assertEquals("GET /foo HTTP/1.1", page1.getRequestLine());
+        assertEquals(1, server.getRequestCount());
+    }
+
+    @Test
+    public void response307WithGet() throws Exception {
+        testRedirect(true, "GET");
+    }
+
+    @Test
+    public void response307WithHead() throws Exception {
+        testRedirect(true, "HEAD");
+    }
+
+    @Test
+    public void response307WithOptions() throws Exception {
+        testRedirect(true, "OPTIONS");
+    }
+
+    @Test
+    public void response307WithPost() throws Exception {
+        testRedirect(true, "POST");
+    }
+
+    @Test
+    public void response308WithGet() throws Exception {
+        testRedirect(false, "GET");
+    }
+
+    @Test
+    public void response308WithHead() throws Exception {
+        testRedirect(false, "HEAD");
+    }
+
+    @Test
+    public void response308WithOptions() throws Exception {
+        testRedirect(false, "OPTIONS");
+    }
+
+    @Test
+    public void response308WithPost() throws Exception {
+        testRedirect(false, "POST");
+    }
+
+    private void testRedirect(boolean temporary, String method) throws Exception {
+        MockResponse response1 = new MockResponse().setResponseCode(temporary ? HTTP_TEMP_REDIRECT : HTTP_PERM_REDIRECT).addHeader("Location: /page2");
+        if (!method.equals("HEAD")) {
+            response1.setBody("This page has moved!");
+        }
+        server.enqueue(response1);
+        server.enqueue(new MockResponse().setBody("Page 2"));
+        connection = client.open(server.url("/page1").url());
+        connection.setRequestMethod(method);
+        byte[] requestBody = { 'A', 'B', 'C', 'D' };
+        if (method.equals("POST")) {
+            connection.setDoOutput(true);
+            OutputStream outputStream = connection.getOutputStream();
+            outputStream.write(requestBody);
+            outputStream.close();
+        }
+        String response = readAscii(connection.getInputStream(), Integer.MAX_VALUE);
+        RecordedRequest page1 = server.takeRequest();
+        assertEquals(method + " /page1 HTTP/1.1", page1.getRequestLine());
+        if (method.equals("GET")) {
+            assertEquals("Page 2", response);
+        } else {
+            if (method.equals("HEAD")) {
+                assertEquals("", response);
+            } else {
+                if (method.equals("POST")) {
+                    assertTrue(connection.getDoOutput());
+                    assertEquals("ABCD", page1.getBody().readUtf8());
+                }
+                assertEquals(1, server.getRequestCount());
+                assertEquals("This page has moved!", response);
+                return;
+            }
+        }
+        assertFalse(connection.getDoOutput());
+        assertEquals(2, server.getRequestCount());
+        RecordedRequest page2 = server.takeRequest();
+        assertEquals(method + " /page2 HTTP/1.1", page2.getRequestLine());
+    }
+
+    @Test
+    public void follow20Redirects() throws Exception {
+        for (int i = 0; i < 20; i++) {
+            server.enqueue(new MockResponse().setResponseCode(HttpURLConnection.HTTP_MOVED_TEMP).addHeader("Location: /" + (i + 1)).setBody("Redirecting to /" + (i + 1)));
+        }
+        server.enqueue(new MockResponse().setBody("Success!"));
+        connection = client.open(server.url("/0").url());
+        assertContent("Success!", connection);
+        assertEquals(server.url("/20").url(), connection.getURL());
+    }
+
+    @Test
+    public void doesNotFollow21Redirects() throws Exception {
+        for (int i = 0; i < 21; i++) {
+            server.enqueue(new MockResponse().setResponseCode(HttpURLConnection.HTTP_MOVED_TEMP).addHeader("Location: /" + (i + 1)).setBody("Redirecting to /" + (i + 1)));
+        }
+        connection = client.open(server.url("/0").url());
+        try {
+            connection.getInputStream();
+            fail();
+        } catch (ProtocolException expected) {
+            assertEquals(HttpURLConnection.HTTP_MOVED_TEMP, connection.getResponseCode());
+            assertEquals("Too many follow-up requests: 21", expected.getMessage());
+            assertContent("Redirecting to /21", connection);
+            assertEquals(server.url("/20").url(), connection.getURL());
+        }
+    }
+
+    @Test
+    public void httpsWithCustomTrustManager() throws Exception {
+        RecordingHostnameVerifier hostnameVerifier = new RecordingHostnameVerifier();
+        RecordingTrustManager trustManager = new RecordingTrustManager();
+        SSLContext sc = SSLContext.getInstance("TLS");
+        sc.init(null, new TrustManager[] { trustManager }, new java.security.SecureRandom());
+        client.client().setHostnameVerifier(hostnameVerifier);
+        client.client().setSslSocketFactory(sc.getSocketFactory());
+        server.useHttps(sslContext.getSocketFactory(), false);
+        server.enqueue(new MockResponse().setBody("ABC"));
+        server.enqueue(new MockResponse().setBody("DEF"));
+        server.enqueue(new MockResponse().setBody("GHI"));
+        URL url = server.url("/").url();
+        assertContent("ABC", client.open(url));
+        assertContent("DEF", client.open(url));
+        assertContent("GHI", client.open(url));
+        assertEquals(Arrays.asList("verify " + server.getHostName()), hostnameVerifier.calls);
+        assertEquals(Arrays.asList("checkServerTrusted [CN=" + server.getHostName() + " 1]"), trustManager.calls);
+    }
+
+    @Test
+    public void readTimeouts() throws IOException {
+        MockResponse timeout = new MockResponse().setBody("ABC").clearHeaders().addHeader("Content-Length: 4");
+        server.enqueue(timeout);
+        server.enqueue(new MockResponse().setBody("unused"));
+        URLConnection connection = client.open(server.url("/").url());
+        connection.setReadTimeout(1000);
+        InputStream in = connection.getInputStream();
+        assertEquals('A', in.read());
+        assertEquals('B', in.read());
+        assertEquals('C', in.read());
+        try {
+            in.read();
+            fail();
+        } catch (SocketTimeoutException expected) {
+        }
+        in.close();
+    }
+
+    /** Confirm that an unacknowledged write times out. */
+    @Test
+    public void writeTimeouts() throws IOException {
+        MockWebServer server = new MockWebServer();
+        final int SOCKET_BUFFER_SIZE = 4 * 1024;
+        server.setServerSocketFactory(new DelegatingServerSocketFactory(ServerSocketFactory.getDefault()) {
+
+            @Override
+            protected ServerSocket configureServerSocket(ServerSocket serverSocket) throws IOException {
+                serverSocket.setReceiveBufferSize(SOCKET_BUFFER_SIZE);
+                return serverSocket;
+            }
+        });
+        client.client().setSocketFactory(new DelegatingSocketFactory(SocketFactory.getDefault()) {
+
+            @Override
+            protected Socket configureSocket(Socket socket) throws IOException {
+                socket.setReceiveBufferSize(SOCKET_BUFFER_SIZE);
+                socket.setSendBufferSize(SOCKET_BUFFER_SIZE);
+                return socket;
+            }
+        });
+        server.start();
+        server.enqueue(new MockResponse().throttleBody(1, 1, TimeUnit.SECONDS));
+        client.client().setWriteTimeout(500, TimeUnit.MILLISECONDS);
+        connection = client.open(server.url("/").url());
+        connection.setDoOutput(true);
+        connection.setChunkedStreamingMode(0);
+        OutputStream out = connection.getOutputStream();
+        try {
+            byte[] data = new byte[2 * 1024 * 1024];
+            out.write(data);
+            fail();
+        } catch (SocketTimeoutException expected) {
+        }
+    }
+
+    @Test
+    public void setChunkedEncodingAsRequestProperty() throws IOException, InterruptedException {
+        server.enqueue(new MockResponse());
+        connection = client.open(server.url("/").url());
+        connection.setRequestProperty("Transfer-encoding", "chunked");
+        connection.setDoOutput(true);
+        connection.getOutputStream().write("ABC".getBytes("UTF-8"));
+        assertEquals(200, connection.getResponseCode());
+        RecordedRequest request = server.takeRequest();
+        assertEquals("ABC", request.getBody().readUtf8());
+    }
+
+    @Test
+    public void connectionCloseInRequest() throws IOException, InterruptedException {
+        server.enqueue(new MockResponse());
+        server.enqueue(new MockResponse());
+        HttpURLConnection a = client.open(server.url("/").url());
+        a.setRequestProperty("Connection", "close");
+        assertEquals(200, a.getResponseCode());
+        HttpURLConnection b = client.open(server.url("/").url());
+        assertEquals(200, b.getResponseCode());
+        assertEquals(0, server.takeRequest().getSequenceNumber());
+        assertEquals("When connection: close is used, each request should get its own connection", 0, server.takeRequest().getSequenceNumber());
+    }
+
+    @Test
+    public void connectionCloseInResponse() throws IOException, InterruptedException {
+        server.enqueue(new MockResponse().addHeader("Connection: close"));
+        server.enqueue(new MockResponse());
+        HttpURLConnection a = client.open(server.url("/").url());
+        assertEquals(200, a.getResponseCode());
+        HttpURLConnection b = client.open(server.url("/").url());
+        assertEquals(200, b.getResponseCode());
+        assertEquals(0, server.takeRequest().getSequenceNumber());
+        assertEquals("When connection: close is used, each request should get its own connection", 0, server.takeRequest().getSequenceNumber());
+    }
+
+    @Test
+    public void connectionCloseWithRedirect() throws IOException, InterruptedException {
+        MockResponse response = new MockResponse().setResponseCode(HttpURLConnection.HTTP_MOVED_TEMP).addHeader("Location: /foo").addHeader("Connection: close");
+        server.enqueue(response);
+        server.enqueue(new MockResponse().setBody("This is the new location!"));
+        URLConnection connection = client.open(server.url("/").url());
+        assertEquals("This is the new location!", readAscii(connection.getInputStream(), Integer.MAX_VALUE));
+        assertEquals(0, server.takeRequest().getSequenceNumber());
+        assertEquals("When connection: close is used, each request should get its own connection", 0, server.takeRequest().getSequenceNumber());
+    }
+
+    /**
    * Retry redirects if the socket is closed.
    * https://code.google.com/p/android/issues/detail?id=41576
-   */
-  @Test public void sameConnectionRedirectAndReuse() throws Exception {
-    server.enqueue(new MockResponse().setResponseCode(HttpURLConnection.HTTP_MOVED_TEMP)
-        .setSocketPolicy(SHUTDOWN_INPUT_AT_END)
-        .addHeader("Location: /foo"));
-    server.enqueue(new MockResponse().setBody("This is the new page!"));
-
-    assertContent("This is the new page!", client.open(server.url("/").url()));
-
-    assertEquals(0, server.takeRequest().getSequenceNumber());
-    assertEquals(0, server.takeRequest().getSequenceNumber());
-  }
-
-  @Test public void responseCodeDisagreesWithHeaders() throws IOException, InterruptedException {
-    server.enqueue(new MockResponse().setResponseCode(HttpURLConnection.HTTP_NO_CONTENT)
-        .setBody("This body is not allowed!"));
-
-    URLConnection connection = client.open(server.url("/").url());
-    assertEquals("This body is not allowed!",
-        readAscii(connection.getInputStream(), Integer.MAX_VALUE));
-  }
-
-  @Test public void singleByteReadIsSigned() throws IOException {
-    server.enqueue(new MockResponse().setBody(new Buffer().writeByte(-2).writeByte(-1)));
-
-    connection = client.open(server.url("/").url());
-    InputStream in = connection.getInputStream();
-    assertEquals(254, in.read());
-    assertEquals(255, in.read());
-    assertEquals(-1, in.read());
-  }
-
-  @Test public void flushAfterStreamTransmittedWithChunkedEncoding() throws IOException {
-    testFlushAfterStreamTransmitted(TransferKind.CHUNKED);
-  }
-
-  @Test public void flushAfterStreamTransmittedWithFixedLength() throws IOException {
-    testFlushAfterStreamTransmitted(TransferKind.FIXED_LENGTH);
-  }
-
-  @Test public void flushAfterStreamTransmittedWithNoLengthHeaders() throws IOException {
-    testFlushAfterStreamTransmitted(TransferKind.END_OF_STREAM);
-  }
-
-  /**
+   */
+    @Test
+    public void sameConnectionRedirectAndReuse() throws Exception {
+        server.enqueue(new MockResponse().setResponseCode(HttpURLConnection.HTTP_MOVED_TEMP).setSocketPolicy(SHUTDOWN_INPUT_AT_END).addHeader("Location: /foo"));
+        server.enqueue(new MockResponse().setBody("This is the new page!"));
+        assertContent("This is the new page!", client.open(server.url("/").url()));
+        assertEquals(0, server.takeRequest().getSequenceNumber());
+        assertEquals(0, server.takeRequest().getSequenceNumber());
+    }
+
+    @Test
+    public void responseCodeDisagreesWithHeaders() throws IOException, InterruptedException {
+        server.enqueue(new MockResponse().setResponseCode(HttpURLConnection.HTTP_NO_CONTENT).setBody("This body is not allowed!"));
+        URLConnection connection = client.open(server.url("/").url());
+        assertEquals("This body is not allowed!", readAscii(connection.getInputStream(), Integer.MAX_VALUE));
+    }
+
+    @Test
+    public void singleByteReadIsSigned() throws IOException {
+        server.enqueue(new MockResponse().setBody(new Buffer().writeByte(-2).writeByte(-1)));
+        connection = client.open(server.url("/").url());
+        InputStream in = connection.getInputStream();
+        assertEquals(254, in.read());
+        assertEquals(255, in.read());
+        assertEquals(-1, in.read());
+    }
+
+    @Test
+    public void flushAfterStreamTransmittedWithChunkedEncoding() throws IOException {
+        testFlushAfterStreamTransmitted(TransferKind.CHUNKED);
+    }
+
+    @Test
+    public void flushAfterStreamTransmittedWithFixedLength() throws IOException {
+        testFlushAfterStreamTransmitted(TransferKind.FIXED_LENGTH);
+    }
+
+    @Test
+    public void flushAfterStreamTransmittedWithNoLengthHeaders() throws IOException {
+        testFlushAfterStreamTransmitted(TransferKind.END_OF_STREAM);
+    }
+
+    /**
    * We explicitly permit apps to close the upload stream even after it has
    * been transmitted.  We also permit flush so that buffered streams can
    * do a no-op flush when they are closed. http://b/3038470
-   */
-  private void testFlushAfterStreamTransmitted(TransferKind transferKind) throws IOException {
-    server.enqueue(new MockResponse().setBody("abc"));
-
-    connection = client.open(server.url("/").url());
-    connection.setDoOutput(true);
-    byte[] upload = "def".getBytes("UTF-8");
-
-    if (transferKind == TransferKind.CHUNKED) {
-      connection.setChunkedStreamingMode(0);
-    } else if (transferKind == TransferKind.FIXED_LENGTH) {
-      connection.setFixedLengthStreamingMode(upload.length);
-    }
-
-    OutputStream out = connection.getOutputStream();
-    out.write(upload);
-    assertEquals("abc", readAscii(connection.getInputStream(), Integer.MAX_VALUE));
-
-    out.flush(); // Dubious but permitted.
-    try {
-      out.write("ghi".getBytes("UTF-8"));
-      fail();
-    } catch (IOException expected) {
-    }
-  }
-
-  @Test public void getHeadersThrows() throws IOException {
-    server.enqueue(new MockResponse().setSocketPolicy(DISCONNECT_AT_START));
-
-    connection = client.open(server.url("/").url());
-    try {
-      connection.getInputStream();
-      fail();
-    } catch (IOException expected) {
-    }
-
-    try {
-      connection.getInputStream();
-      fail();
-    } catch (IOException expected) {
-    }
-  }
-
-  @Test public void dnsFailureThrowsIOException() throws IOException {
-    connection = client.open(new URL("http://host.unlikelytld"));
-    try {
-      connection.connect();
-      fail();
-    } catch (IOException expected) {
-    }
-  }
-
-  @Test public void malformedUrlThrowsUnknownHostException() throws IOException {
-    connection = client.open(new URL("http://./foo.html"));
-    try {
-      connection.connect();
-      fail();
-    } catch (UnknownHostException expected) {
-    }
-  }
-
-  @Test public void getKeepAlive() throws Exception {
-    server.enqueue(new MockResponse().setBody("ABC"));
-
-    // The request should work once and then fail
-    HttpURLConnection connection1 = client.open(server.url("/").url());
-    connection1.setReadTimeout(100);
-    InputStream input = connection1.getInputStream();
-    assertEquals("ABC", readAscii(input, Integer.MAX_VALUE));
-    server.shutdown();
-    try {
-      HttpURLConnection connection2 = client.open(server.url("").url());
-      connection2.setReadTimeout(100);
-      connection2.getInputStream();
-      fail();
-    } catch (ConnectException expected) {
-    }
-  }
-
-  /** http://code.google.com/p/android/issues/detail?id=14562 */
-  @Test public void readAfterLastByte() throws Exception {
-    server.enqueue(new MockResponse().setBody("ABC")
-        .clearHeaders()
-        .addHeader("Connection: close")
-        .setSocketPolicy(SocketPolicy.DISCONNECT_AT_END));
-
-    connection = client.open(server.url("/").url());
-    InputStream in = connection.getInputStream();
-    assertEquals("ABC", readAscii(in, 3));
-    assertEquals(-1, in.read());
-    assertEquals(-1, in.read()); // throws IOException in Gingerbread
-  }
-
-  @Test public void getContent() throws Exception {
-    server.enqueue(new MockResponse().addHeader("Content-Type: text/plain").setBody("A"));
-    connection = client.open(server.url("/").url());
-    InputStream in = (InputStream) connection.getContent();
-    assertEquals("A", readAscii(in, Integer.MAX_VALUE));
-  }
-
-  @Test public void getContentOfType() throws Exception {
-    server.enqueue(new MockResponse().addHeader("Content-Type: text/plain").setBody("A"));
-    connection = client.open(server.url("/").url());
-    try {
-      connection.getContent(null);
-      fail();
-    } catch (NullPointerException expected) {
-    }
-    try {
-      connection.getContent(new Class[] { null });
-      fail();
-    } catch (NullPointerException expected) {
-    }
-    assertNull(connection.getContent(new Class[] { getClass() }));
-    connection.getInputStream().close();
-  }
-
-  @Test public void getOutputStreamOnGetFails() throws Exception {
-    server.enqueue(new MockResponse());
-    connection = client.open(server.url("/").url());
-    try {
-      connection.getOutputStream();
-      fail();
-    } catch (ProtocolException expected) {
-    }
-    connection.getInputStream().close();
-  }
-
-  @Test public void getOutputAfterGetInputStreamFails() throws Exception {
-    server.enqueue(new MockResponse());
-    connection = client.open(server.url("/").url());
-    connection.setDoOutput(true);
-    try {
-      connection.getInputStream();
-      connection.getOutputStream();
-      fail();
-    } catch (ProtocolException expected) {
-    }
-  }
-
-  @Test public void setDoOutputOrDoInputAfterConnectFails() throws Exception {
-    server.enqueue(new MockResponse());
-    connection = client.open(server.url("/").url());
-    connection.connect();
-    try {
-      connection.setDoOutput(true);
-      fail();
-    } catch (IllegalStateException expected) {
-    }
-    try {
-      connection.setDoInput(true);
-      fail();
-    } catch (IllegalStateException expected) {
-    }
-    connection.getInputStream().close();
-  }
-
-  @Test public void clientSendsContentLength() throws Exception {
-    server.enqueue(new MockResponse().setBody("A"));
-    connection = client.open(server.url("/").url());
-    connection.setDoOutput(true);
-    OutputStream out = connection.getOutputStream();
-    out.write(new byte[] { 'A', 'B', 'C' });
-    out.close();
-    assertEquals("A", readAscii(connection.getInputStream(), Integer.MAX_VALUE));
-    RecordedRequest request = server.takeRequest();
-    assertEquals("3", request.getHeader("Content-Length"));
-    connection.getInputStream().close();
-  }
-
-  @Test public void getContentLengthConnects() throws Exception {
-    server.enqueue(new MockResponse().setBody("ABC"));
-    connection = client.open(server.url("/").url());
-    assertEquals(3, connection.getContentLength());
-    connection.getInputStream().close();
-  }
-
-  @Test public void getContentTypeConnects() throws Exception {
-    server.enqueue(new MockResponse().addHeader("Content-Type: text/plain").setBody("ABC"));
-    connection = client.open(server.url("/").url());
-    assertEquals("text/plain", connection.getContentType());
-    connection.getInputStream().close();
-  }
-
-  @Test public void getContentEncodingConnects() throws Exception {
-    server.enqueue(new MockResponse().addHeader("Content-Encoding: identity").setBody("ABC"));
-    connection = client.open(server.url("/").url());
-    assertEquals("identity", connection.getContentEncoding());
-    connection.getInputStream().close();
-  }
-
-  // http://b/4361656
-  @Test public void urlContainsQueryButNoPath() throws Exception {
-    server.enqueue(new MockResponse().setBody("A"));
-
-    URL url = new URL("http", server.getHostName(), server.getPort(), "?query");
-    assertEquals("A", readAscii(client.open(url).getInputStream(), Integer.MAX_VALUE));
-    RecordedRequest request = server.takeRequest();
-    assertEquals("GET /?query HTTP/1.1", request.getRequestLine());
-  }
-
-  @Test public void doOutputForMethodThatDoesntSupportOutput() throws Exception {
-    connection = client.open(server.url("/").url());
-    connection.setRequestMethod("HEAD");
-    connection.setDoOutput(true);
-    try {
-      connection.connect();
-      fail();
-    } catch (IOException expected) {
-    }
-  }
-
-  // http://code.google.com/p/android/issues/detail?id=20442
-  @Test public void inputStreamAvailableWithChunkedEncoding() throws Exception {
-    testInputStreamAvailable(TransferKind.CHUNKED);
-  }
-
-  @Test public void inputStreamAvailableWithContentLengthHeader() throws Exception {
-    testInputStreamAvailable(TransferKind.FIXED_LENGTH);
-  }
-
-  @Test public void inputStreamAvailableWithNoLengthHeaders() throws Exception {
-    testInputStreamAvailable(TransferKind.END_OF_STREAM);
-  }
-
-  private void testInputStreamAvailable(TransferKind transferKind) throws IOException {
-    String body = "ABCDEFGH";
-    MockResponse response = new MockResponse();
-    transferKind.setBody(response, body, 4);
-    server.enqueue(response);
-    connection = client.open(server.url("/").url());
-    InputStream in = connection.getInputStream();
-    for (int i = 0; i < body.length(); i++) {
-      assertTrue(in.available() >= 0);
-      assertEquals(body.charAt(i), in.read());
-    }
-    assertEquals(0, in.available());
-    assertEquals(-1, in.read());
-  }
-
-  @Test public void postFailsWithBufferedRequestForSmallRequest() throws Exception {
-    reusedConnectionFailsWithPost(TransferKind.END_OF_STREAM, 1024);
-  }
-
-  @Test public void postFailsWithBufferedRequestForLargeRequest() throws Exception {
-    reusedConnectionFailsWithPost(TransferKind.END_OF_STREAM, 16384);
-  }
-
-  @Test public void postFailsWithChunkedRequestForSmallRequest() throws Exception {
-    reusedConnectionFailsWithPost(TransferKind.CHUNKED, 1024);
-  }
-
-  @Test public void postFailsWithChunkedRequestForLargeRequest() throws Exception {
-    reusedConnectionFailsWithPost(TransferKind.CHUNKED, 16384);
-  }
-
-  @Test public void postFailsWithFixedLengthRequestForSmallRequest() throws Exception {
-    reusedConnectionFailsWithPost(TransferKind.FIXED_LENGTH, 1024);
-  }
-
-  @Test public void postFailsWithFixedLengthRequestForLargeRequest() throws Exception {
-    reusedConnectionFailsWithPost(TransferKind.FIXED_LENGTH, 16384);
-  }
-
-  private void reusedConnectionFailsWithPost(TransferKind transferKind, int requestSize)
-      throws Exception {
-    server.enqueue(new MockResponse().setBody("A").setSocketPolicy(DISCONNECT_AT_END));
-    server.enqueue(new MockResponse().setBody("B"));
-    server.enqueue(new MockResponse().setBody("C"));
-
-    assertContent("A", client.open(server.url("/a").url()));
-
-    // If the request body is larger than OkHttp's replay buffer, the failure may still occur.
-    byte[] requestBody = new byte[requestSize];
-    new Random(0).nextBytes(requestBody);
-
-    for (int j = 0; j < 2; j++) {
-      try {
-        connection = client.open(server.url("/b").url());
-        connection.setRequestMethod("POST");
-        transferKind.setForRequest(connection, requestBody.length);
-        for (int i = 0; i < requestBody.length; i += 1024) {
-          connection.getOutputStream().write(requestBody, i, 1024);
-        }
-        connection.getOutputStream().close();
-        assertContent("B", connection);
-        break;
-      } catch (IOException socketException) {
-        // If there's a socket exception, this must have a streamed request body.
-        assertEquals(0, j);
-        assertTrue(transferKind == TransferKind.CHUNKED
-            || transferKind == TransferKind.FIXED_LENGTH);
-      }
-    }
-
-    RecordedRequest requestA = server.takeRequest();
-    assertEquals("/a", requestA.getPath());
-    RecordedRequest requestB = server.takeRequest();
-    assertEquals("/b", requestB.getPath());
-    assertEquals(Arrays.toString(requestBody), Arrays.toString(requestB.getBody().readByteArray()));
-  }
-
-  @Test public void postBodyRetransmittedOnFailureRecovery() throws Exception {
-    server.enqueue(new MockResponse().setBody("abc"));
-    server.enqueue(new MockResponse().setSocketPolicy(SocketPolicy.DISCONNECT_AFTER_REQUEST));
-    server.enqueue(new MockResponse().setBody("def"));
-
-    // Seed the connection pool so we have something that can fail.
-    assertContent("abc", client.open(server.url("/").url()));
-
-    HttpURLConnection post = client.open(server.url("/").url());
-    post.setDoOutput(true);
-    post.getOutputStream().write("body!".getBytes(Util.UTF_8));
-    assertContent("def", post);
-
-    RecordedRequest get = server.takeRequest();
-    assertEquals(0, get.getSequenceNumber());
-
-    RecordedRequest post1 = server.takeRequest();
-    assertEquals("body!", post1.getBody().readUtf8());
-    assertEquals(1, post1.getSequenceNumber());
-
-    RecordedRequest post2 = server.takeRequest();
-    assertEquals("body!", post2.getBody().readUtf8());
-    assertEquals(0, post2.getSequenceNumber());
-  }
-
-  @Test public void fullyBufferedPostIsTooShort() throws Exception {
-    server.enqueue(new MockResponse().setBody("A"));
-
-    connection = client.open(server.url("/b").url());
-    connection.setRequestProperty("Content-Length", "4");
-    connection.setRequestMethod("POST");
-    OutputStream out = connection.getOutputStream();
-    out.write('a');
-    out.write('b');
-    out.write('c');
-    try {
-      out.close();
-      fail();
-    } catch (IOException expected) {
-    }
-  }
-
-  @Test public void fullyBufferedPostIsTooLong() throws Exception {
-    server.enqueue(new MockResponse().setBody("A"));
-
-    connection = client.open(server.url("/b").url());
-    connection.setRequestProperty("Content-Length", "3");
-    connection.setRequestMethod("POST");
-    OutputStream out = connection.getOutputStream();
-    out.write('a');
-    out.write('b');
-    out.write('c');
-    try {
-      out.write('d');
-      out.flush();
-      fail();
-    } catch (IOException expected) {
-    }
-  }
-
-  @Test @Ignore public void testPooledConnectionsDetectHttp10() {
-    // TODO: write a test that shows pooled connections detect HTTP/1.0 (vs. HTTP/1.1)
-    fail("TODO");
-  }
-
-  @Test @Ignore public void postBodiesRetransmittedOnAuthProblems() {
-    fail("TODO");
-  }
-
-  @Test @Ignore public void cookiesAndTrailers() {
-    // Do cookie headers get processed too many times?
-    fail("TODO");
-  }
-
-  @Test @Ignore public void headerNamesContainingNullCharacter() {
-    // This is relevant for SPDY
-    fail("TODO");
-  }
-
-  @Test @Ignore public void headerValuesContainingNullCharacter() {
-    // This is relevant for SPDY
-    fail("TODO");
-  }
-
-  @Test public void emptyRequestHeaderValueIsAllowed() throws Exception {
-    server.enqueue(new MockResponse().setBody("body"));
-    connection = client.open(server.url("/").url());
-    connection.addRequestProperty("B", "");
-    assertContent("body", connection);
-    assertEquals("", connection.getRequestProperty("B"));
-  }
-
-  @Test public void emptyResponseHeaderValueIsAllowed() throws Exception {
-    server.enqueue(new MockResponse().addHeader("A:").setBody("body"));
-    connection = client.open(server.url("/").url());
-    assertContent("body", connection);
-    assertEquals("", connection.getHeaderField("A"));
-  }
-
-  @Test public void emptyRequestHeaderNameIsStrict() throws Exception {
-    server.enqueue(new MockResponse().setBody("body"));
-    connection = client.open(server.url("/").url());
-    try {
-      connection.setRequestProperty("", "A");
-      fail();
-    } catch (IllegalArgumentException expected) {
-    }
-  }
-
-  @Test public void emptyResponseHeaderNameIsLenient() throws Exception {
-    Headers.Builder headers = new Headers.Builder();
-    Internal.instance.addLenient(headers, ":A");
-    server.enqueue(new MockResponse().setHeaders(headers.build()).setBody("body"));
-    connection = client.open(server.url("/").url());
-    connection.getResponseCode();
-    assertEquals("A", connection.getHeaderField(""));
-    connection.getInputStream().close();
-  }
-
-  @Test public void requestHeaderValidationIsStrict() throws Exception {
-    connection = client.open(server.url("/").url());
-    try {
-      connection.addRequestProperty("a\tb", "Value");
-      fail();
-    } catch (IllegalArgumentException expected) {
-    }
-    try {
-      connection.addRequestProperty("Name", "c\u007fd");
-      fail();
-    } catch (IllegalArgumentException expected) {
-    }
-    try {
-      connection.addRequestProperty("", "Value");
-      fail();
-    } catch (IllegalArgumentException expected) {
-    }
-    try {
-      connection.addRequestProperty("\ud83c\udf69", "Value");
-      fail();
-    } catch (IllegalArgumentException expected) {
-    }
-    try {
-      connection.addRequestProperty("Name", "\u2615\ufe0f");
-      fail();
-    } catch (IllegalArgumentException expected) {
-    }
-  }
-
-  @Test public void responseHeaderParsingIsLenient() throws Exception {
-    Headers headers = new Headers.Builder()
-        .add("Content-Length", "0")
-        .addLenient("a\tb: c\u007fd")
-        .addLenient(": ef")
-        .addLenient("\ud83c\udf69: \u2615\ufe0f")
-        .build();
-    server.enqueue(new MockResponse().setHeaders(headers));
-
-    connection = client.open(server.url("/").url());
-    connection.getResponseCode();
-    assertEquals("c\u007fd", connection.getHeaderField("a\tb"));
-    assertEquals("\u2615\ufe0f", connection.getHeaderField("\ud83c\udf69"));
-    assertEquals("ef", connection.getHeaderField(""));
-  }
-
-  @Test @Ignore public void deflateCompression() {
-    fail("TODO");
-  }
-
-  @Test @Ignore public void postBodiesRetransmittedOnIpAddressProblems() {
-    fail("TODO");
-  }
-
-  @Test @Ignore public void pooledConnectionProblemsNotReportedToProxySelector() {
-    fail("TODO");
-  }
-
-  @Test public void customBasicAuthenticator() throws Exception {
-    MockResponse pleaseAuthenticate = new MockResponse().setResponseCode(401)
-        .addHeader("WWW-Authenticate: Basic realm=\"protected area\"")
-        .setBody("Please authenticate.");
-    server.enqueue(pleaseAuthenticate);
-    server.enqueue(new MockResponse().setBody("A"));
-
-    String credential = Credentials.basic("jesse", "peanutbutter");
-    RecordingOkAuthenticator authenticator = new RecordingOkAuthenticator(credential);
-    client.client().setAuthenticator(authenticator);
-    assertContent("A", client.open(server.url("/private").url()));
-
-    assertNull(server.takeRequest().getHeader("Authorization"));
-    assertEquals(credential, server.takeRequest().getHeader("Authorization"));
-
-    assertEquals(Proxy.NO_PROXY, authenticator.onlyProxy());
-    Response response = authenticator.onlyResponse();
-    assertEquals("/private", response.request().url().url().getPath());
-    assertEquals(Arrays.asList(new Challenge("Basic", "protected area")), response.challenges());
-  }
-
-  @Test public void customTokenAuthenticator() throws Exception {
-    MockResponse pleaseAuthenticate = new MockResponse().setResponseCode(401)
-            .addHeader("WWW-Authenticate: Bearer realm=\"oauthed\"")
-            .setBody("Please authenticate.");
-    server.enqueue(pleaseAuthenticate);
-    server.enqueue(new MockResponse().setBody("A"));
-
-    RecordingOkAuthenticator authenticator = new RecordingOkAuthenticator("oauthed abc123");
-    client.client().setAuthenticator(authenticator);
-    assertContent("A", client.open(server.url("/private").url()));
-
-    assertNull(server.takeRequest().getHeader("Authorization"));
-    assertEquals("oauthed abc123", server.takeRequest().getHeader("Authorization"));
-
-    Response response = authenticator.onlyResponse();
-    assertEquals("/private", response.request().url().url().getPath());
-    assertEquals(Arrays.asList(new Challenge("Bearer", "oauthed")), response.challenges());
-  }
-
-  @Test public void authenticateCallsTrackedAsRedirects() throws Exception {
-    server.enqueue(new MockResponse()
-        .setResponseCode(302)
-        .addHeader("Location: /b"));
-    server.enqueue(new MockResponse()
-        .setResponseCode(401)
-        .addHeader("WWW-Authenticate: Basic realm=\"protected area\""));
-    server.enqueue(new MockResponse().setBody("c"));
-
-    RecordingOkAuthenticator authenticator = new RecordingOkAuthenticator(
-        Credentials.basic("jesse", "peanutbutter"));
-    client.client().setAuthenticator(authenticator);
-    assertContent("c", client.open(server.url("/a").url()));
-
-    Response challengeResponse = authenticator.responses.get(0);
-    assertEquals("/b", challengeResponse.request().url().url().getPath());
-
-    Response redirectedBy = challengeResponse.priorResponse();
-    assertEquals("/a", redirectedBy.request().url().url().getPath());
-  }
-
-  @Test public void attemptAuthorization20Times() throws Exception {
-    for (int i = 0; i < 20; i++) {
-      server.enqueue(new MockResponse().setResponseCode(401));
-    }
-    server.enqueue(new MockResponse().setBody("Success!"));
-
-    String credential = Credentials.basic("jesse", "peanutbutter");
-    client.client().setAuthenticator(new RecordingOkAuthenticator(credential));
-
-    connection = client.open(server.url("/0").url());
-    assertContent("Success!", connection);
-  }
-
-  @Test public void doesNotAttemptAuthorization21Times() throws Exception {
-    for (int i = 0; i < 21; i++) {
-      server.enqueue(new MockResponse().setResponseCode(401));
-    }
-
-    String credential = Credentials.basic("jesse", "peanutbutter");
-    client.client().setAuthenticator(new RecordingOkAuthenticator(credential));
-
-    connection = client.open(server.url("/").url());
-    try {
-      connection.getInputStream();
-      fail();
-    } catch (ProtocolException expected) {
-      assertEquals(401, connection.getResponseCode());
-      assertEquals("Too many follow-up requests: 21", expected.getMessage());
-    }
-  }
-
-  @Test public void setsNegotiatedProtocolHeader_SPDY_3() throws Exception {
-    setsNegotiatedProtocolHeader(Protocol.SPDY_3);
-  }
-
-  @Test public void setsNegotiatedProtocolHeader_HTTP_2() throws Exception {
-    setsNegotiatedProtocolHeader(Protocol.HTTP_2);
-  }
-
-  private void setsNegotiatedProtocolHeader(Protocol protocol) throws IOException {
-    enableProtocol(protocol);
-    server.enqueue(new MockResponse().setBody("A"));
-    client.client().setProtocols(Arrays.asList(protocol, Protocol.HTTP_1_1));
-    connection = client.open(server.url("/").url());
-    List<String> protocolValues = connection.getHeaderFields().get(SELECTED_PROTOCOL);
-    assertEquals(Arrays.asList(protocol.toString()), protocolValues);
-    assertContent("A", connection);
-  }
-
-  @Test public void http10SelectedProtocol() throws Exception {
-    server.enqueue(new MockResponse().setStatus("HTTP/1.0 200 OK"));
-    connection = client.open(server.url("/").url());
-    List<String> protocolValues = connection.getHeaderFields().get(SELECTED_PROTOCOL);
-    assertEquals(Arrays.asList("http/1.0"), protocolValues);
-  }
-
-  @Test public void http11SelectedProtocol() throws Exception {
-    server.enqueue(new MockResponse().setStatus("HTTP/1.1 200 OK"));
-    connection = client.open(server.url("/").url());
-    List<String> protocolValues = connection.getHeaderFields().get(SELECTED_PROTOCOL);
-    assertEquals(Arrays.asList("http/1.1"), protocolValues);
-  }
-
-  /** For example, empty Protobuf RPC messages end up as a zero-length POST. */
-  @Test public void zeroLengthPost() throws IOException, InterruptedException {
-    zeroLengthPayload("POST");
-  }
-
-  @Test public void zeroLengthPost_SPDY_3() throws Exception {
-    enableProtocol(Protocol.SPDY_3);
-    zeroLengthPost();
-  }
-
-  @Test public void zeroLengthPost_HTTP_2() throws Exception {
-    enableProtocol(Protocol.HTTP_2);
-    zeroLengthPost();
-  }
-
-  /** For example, creating an Amazon S3 bucket ends up as a zero-length POST. */
-  @Test public void zeroLengthPut() throws IOException, InterruptedException {
-    zeroLengthPayload("PUT");
-  }
-
-  @Test public void zeroLengthPut_SPDY_3() throws Exception {
-    enableProtocol(Protocol.SPDY_3);
-    zeroLengthPut();
-  }
-
-  @Test public void zeroLengthPut_HTTP_2() throws Exception {
-    enableProtocol(Protocol.HTTP_2);
-    zeroLengthPut();
-  }
-
-  private void zeroLengthPayload(String method)
-      throws IOException, InterruptedException {
-    server.enqueue(new MockResponse());
-    connection = client.open(server.url("/").url());
-    connection.setRequestProperty("Content-Length", "0");
-    connection.setRequestMethod(method);
-    connection.setFixedLengthStreamingMode(0);
-    connection.setDoOutput(true);
-    assertContent("", connection);
-    RecordedRequest zeroLengthPayload = server.takeRequest();
-    assertEquals(method, zeroLengthPayload.getMethod());
-    assertEquals("0", zeroLengthPayload.getHeader("content-length"));
-    assertEquals(0L, zeroLengthPayload.getBodySize());
-  }
-
-  @Test public void unspecifiedRequestBodyContentTypeGetsDefault() throws Exception {
-    server.enqueue(new MockResponse());
-
-    connection = client.open(server.url("/").url());
-    connection.setDoOutput(true);
-    connection.getOutputStream().write("abc".getBytes(UTF_8));
-    assertEquals(200, connection.getResponseCode());
-
-    RecordedRequest request = server.takeRequest();
-    assertEquals("application/x-www-form-urlencoded", request.getHeader("Content-Type"));
-    assertEquals("3", request.getHeader("Content-Length"));
-    assertEquals("abc", request.getBody().readUtf8());
-  }
-
-  @Test public void setProtocols() throws Exception {
-    server.enqueue(new MockResponse().setBody("A"));
-    client.client().setProtocols(Arrays.asList(Protocol.HTTP_1_1));
-    assertContent("A", client.open(server.url("/").url()));
-  }
-
-  @Test public void setProtocolsWithoutHttp11() throws Exception {
-    try {
-      client.client().setProtocols(Arrays.asList(Protocol.SPDY_3));
-      fail();
-    } catch (IllegalArgumentException expected) {
-    }
-  }
-
-  @Test public void setProtocolsWithNull() throws Exception {
-    try {
-      client.client().setProtocols(Arrays.asList(Protocol.HTTP_1_1, null));
-      fail();
-    } catch (IllegalArgumentException expected) {
-    }
-  }
-
-  @Test public void veryLargeFixedLengthRequest() throws Exception {
-    server.setBodyLimit(0);
-    server.enqueue(new MockResponse());
-
-    connection = client.open(server.url("/").url());
-    connection.setDoOutput(true);
-    long contentLength = Integer.MAX_VALUE + 1L;
-    connection.setFixedLengthStreamingMode(contentLength);
-    OutputStream out = connection.getOutputStream();
-    byte[] buffer = new byte[1024 * 1024];
-    for (long bytesWritten = 0; bytesWritten < contentLength; ) {
-      int byteCount = (int) Math.min(buffer.length, contentLength - bytesWritten);
-      out.write(buffer, 0, byteCount);
-      bytesWritten += byteCount;
-    }
-    assertContent("", connection);
-
-    RecordedRequest request = server.takeRequest();
-    assertEquals(Long.toString(contentLength), request.getHeader("Content-Length"));
-  }
-
-  /**
+   */
+    private void testFlushAfterStreamTransmitted(TransferKind transferKind) throws IOException {
+        server.enqueue(new MockResponse().setBody("abc"));
+        connection = client.open(server.url("/").url());
+        connection.setDoOutput(true);
+        byte[] upload = "def".getBytes("UTF-8");
+        if (transferKind == TransferKind.CHUNKED) {
+            connection.setChunkedStreamingMode(0);
+        } else {
+            if (transferKind == TransferKind.FIXED_LENGTH) {
+                connection.setFixedLengthStreamingMode(upload.length);
+            }
+        }
+        OutputStream out = connection.getOutputStream();
+        out.write(upload);
+        assertEquals("abc", readAscii(connection.getInputStream(), Integer.MAX_VALUE));
+        out.flush();
+        try {
+            out.write("ghi".getBytes("UTF-8"));
+            fail();
+        } catch (IOException expected) {
+        }
+    }
+
+    @Test
+    public void getHeadersThrows() throws IOException {
+        server.enqueue(new MockResponse().setSocketPolicy(DISCONNECT_AT_START));
+        connection = client.open(server.url("/").url());
+        try {
+            connection.getInputStream();
+            fail();
+        } catch (IOException expected) {
+        }
+        try {
+            connection.getInputStream();
+            fail();
+        } catch (IOException expected) {
+        }
+    }
+
+    @Test
+    public void dnsFailureThrowsIOException() throws IOException {
+        connection = client.open(new URL("http://host.unlikelytld"));
+        try {
+            connection.connect();
+            fail();
+        } catch (IOException expected) {
+        }
+    }
+
+    @Test
+    public void malformedUrlThrowsUnknownHostException() throws IOException {
+        connection = client.open(new URL("http://./foo.html"));
+        try {
+            connection.connect();
+            fail();
+        } catch (UnknownHostException expected) {
+        }
+    }
+
+    @Test
+    public void getKeepAlive() throws Exception {
+        server.enqueue(new MockResponse().setBody("ABC"));
+        HttpURLConnection connection1 = client.open(server.url("/").url());
+        connection1.setReadTimeout(100);
+        InputStream input = connection1.getInputStream();
+        assertEquals("ABC", readAscii(input, Integer.MAX_VALUE));
+        server.shutdown();
+        try {
+            HttpURLConnection connection2 = client.open(server.url("").url());
+            connection2.setReadTimeout(100);
+            connection2.getInputStream();
+            fail();
+        } catch (ConnectException expected) {
+        }
+    }
+
+    /** http://code.google.com/p/android/issues/detail?id=14562 */
+    @Test
+    public void readAfterLastByte() throws Exception {
+        server.enqueue(new MockResponse().setBody("ABC").clearHeaders().addHeader("Connection: close").setSocketPolicy(SocketPolicy.DISCONNECT_AT_END));
+        connection = client.open(server.url("/").url());
+        InputStream in = connection.getInputStream();
+        assertEquals("ABC", readAscii(in, 3));
+        assertEquals(-1, in.read());
+        assertEquals(-1, in.read());
+    }
+
+    @Test
+    public void getContent() throws Exception {
+        server.enqueue(new MockResponse().addHeader("Content-Type: text/plain").setBody("A"));
+        connection = client.open(server.url("/").url());
+        InputStream in = (InputStream) connection.getContent();
+        assertEquals("A", readAscii(in, Integer.MAX_VALUE));
+    }
+
+    @Test
+    public void getContentOfType() throws Exception {
+        server.enqueue(new MockResponse().addHeader("Content-Type: text/plain").setBody("A"));
+        connection = client.open(server.url("/").url());
+        try {
+            connection.getContent(null);
+            fail();
+        } catch (NullPointerException expected) {
+        }
+        try {
+            connection.getContent(new Class[] { null });
+            fail();
+        } catch (NullPointerException expected) {
+        }
+        assertNull(connection.getContent(new Class[] { getClass() }));
+        connection.getInputStream().close();
+    }
+
+    @Test
+    public void getOutputStreamOnGetFails() throws Exception {
+        server.enqueue(new MockResponse());
+        connection = client.open(server.url("/").url());
+        try {
+            connection.getOutputStream();
+            fail();
+        } catch (ProtocolException expected) {
+        }
+        connection.getInputStream().close();
+    }
+
+    @Test
+    public void getOutputAfterGetInputStreamFails() throws Exception {
+        server.enqueue(new MockResponse());
+        connection = client.open(server.url("/").url());
+        connection.setDoOutput(true);
+        try {
+            connection.getInputStream();
+            connection.getOutputStream();
+            fail();
+        } catch (ProtocolException expected) {
+        }
+    }
+
+    @Test
+    public void setDoOutputOrDoInputAfterConnectFails() throws Exception {
+        server.enqueue(new MockResponse());
+        connection = client.open(server.url("/").url());
+        connection.connect();
+        try {
+            connection.setDoOutput(true);
+            fail();
+        } catch (IllegalStateException expected) {
+        }
+        try {
+            connection.setDoInput(true);
+            fail();
+        } catch (IllegalStateException expected) {
+        }
+        connection.getInputStream().close();
+    }
+
+    @Test
+    public void clientSendsContentLength() throws Exception {
+        server.enqueue(new MockResponse().setBody("A"));
+        connection = client.open(server.url("/").url());
+        connection.setDoOutput(true);
+        OutputStream out = connection.getOutputStream();
+        out.write(new byte[] { 'A', 'B', 'C' });
+        out.close();
+        assertEquals("A", readAscii(connection.getInputStream(), Integer.MAX_VALUE));
+        RecordedRequest request = server.takeRequest();
+        assertEquals("3", request.getHeader("Content-Length"));
+        connection.getInputStream().close();
+    }
+
+    @Test
+    public void getContentLengthConnects() throws Exception {
+        server.enqueue(new MockResponse().setBody("ABC"));
+        connection = client.open(server.url("/").url());
+        assertEquals(3, connection.getContentLength());
+        connection.getInputStream().close();
+    }
+
+    @Test
+    public void getContentTypeConnects() throws Exception {
+        server.enqueue(new MockResponse().addHeader("Content-Type: text/plain").setBody("ABC"));
+        connection = client.open(server.url("/").url());
+        assertEquals("text/plain", connection.getContentType());
+        connection.getInputStream().close();
+    }
+
+    @Test
+    public void getContentEncodingConnects() throws Exception {
+        server.enqueue(new MockResponse().addHeader("Content-Encoding: identity").setBody("ABC"));
+        connection = client.open(server.url("/").url());
+        assertEquals("identity", connection.getContentEncoding());
+        connection.getInputStream().close();
+    }
+
+    // http://b/4361656
+    @Test
+    public void urlContainsQueryButNoPath() throws Exception {
+        server.enqueue(new MockResponse().setBody("A"));
+        URL url = new URL("http", server.getHostName(), server.getPort(), "?query");
+        assertEquals("A", readAscii(client.open(url).getInputStream(), Integer.MAX_VALUE));
+        RecordedRequest request = server.takeRequest();
+        assertEquals("GET /?query HTTP/1.1", request.getRequestLine());
+    }
+
+    @Test
+    public void doOutputForMethodThatDoesntSupportOutput() throws Exception {
+        connection = client.open(server.url("/").url());
+        connection.setRequestMethod("HEAD");
+        connection.setDoOutput(true);
+        try {
+            connection.connect();
+            fail();
+        } catch (IOException expected) {
+        }
+    }
+
+    // http://code.google.com/p/android/issues/detail?id=20442
+    @Test
+    public void inputStreamAvailableWithChunkedEncoding() throws Exception {
+        testInputStreamAvailable(TransferKind.CHUNKED);
+    }
+
+    @Test
+    public void inputStreamAvailableWithContentLengthHeader() throws Exception {
+        testInputStreamAvailable(TransferKind.FIXED_LENGTH);
+    }
+
+    @Test
+    public void inputStreamAvailableWithNoLengthHeaders() throws Exception {
+        testInputStreamAvailable(TransferKind.END_OF_STREAM);
+    }
+
+    private void testInputStreamAvailable(TransferKind transferKind) throws IOException {
+        String body = "ABCDEFGH";
+        MockResponse response = new MockResponse();
+        transferKind.setBody(response, body, 4);
+        server.enqueue(response);
+        connection = client.open(server.url("/").url());
+        InputStream in = connection.getInputStream();
+        for (int i = 0; i < body.length(); i++) {
+            assertTrue(in.available() >= 0);
+            assertEquals(body.charAt(i), in.read());
+        }
+        assertEquals(0, in.available());
+        assertEquals(-1, in.read());
+    }
+
+    @Test
+    public void postFailsWithBufferedRequestForSmallRequest() throws Exception {
+        reusedConnectionFailsWithPost(TransferKind.END_OF_STREAM, 1024);
+    }
+
+    @Test
+    public void postFailsWithBufferedRequestForLargeRequest() throws Exception {
+        reusedConnectionFailsWithPost(TransferKind.END_OF_STREAM, 16384);
+    }
+
+    @Test
+    public void postFailsWithChunkedRequestForSmallRequest() throws Exception {
+        reusedConnectionFailsWithPost(TransferKind.CHUNKED, 1024);
+    }
+
+    @Test
+    public void postFailsWithChunkedRequestForLargeRequest() throws Exception {
+        reusedConnectionFailsWithPost(TransferKind.CHUNKED, 16384);
+    }
+
+    @Test
+    public void postFailsWithFixedLengthRequestForSmallRequest() throws Exception {
+        reusedConnectionFailsWithPost(TransferKind.FIXED_LENGTH, 1024);
+    }
+
+    @Test
+    public void postFailsWithFixedLengthRequestForLargeRequest() throws Exception {
+        reusedConnectionFailsWithPost(TransferKind.FIXED_LENGTH, 16384);
+    }
+
+    private void reusedConnectionFailsWithPost(TransferKind transferKind, int requestSize) throws Exception {
+        server.enqueue(new MockResponse().setBody("A").setSocketPolicy(DISCONNECT_AT_END));
+        server.enqueue(new MockResponse().setBody("B"));
+        server.enqueue(new MockResponse().setBody("C"));
+        assertContent("A", client.open(server.url("/a").url()));
+        Thread.sleep(500);
+        byte[] requestBody = new byte[requestSize];
+        new Random(0).nextBytes(requestBody);
+        for (int j = 0; j < 2; j++) {
+            try {
+                connection = client.open(server.url("/b").url());
+                connection.setRequestMethod("POST");
+                transferKind.setForRequest(connection, requestBody.length);
+                for (int i = 0; i < requestBody.length; i += 1024) {
+                    connection.getOutputStream().write(requestBody, i, 1024);
+                }
+                connection.getOutputStream().close();
+                assertContent("B", connection);
+                break;
+            } catch (IOException socketException) {
+                assertEquals(0, j);
+                assertTrue(transferKind == TransferKind.CHUNKED || transferKind == TransferKind.FIXED_LENGTH);
+            }
+        }
+        RecordedRequest requestA = server.takeRequest();
+        assertEquals("/a", requestA.getPath());
+        RecordedRequest requestB = server.takeRequest();
+        assertEquals("/b", requestB.getPath());
+        assertEquals(Arrays.toString(requestBody), Arrays.toString(requestB.getBody().readByteArray()));
+    }
+
+    @Test
+    public void postBodyRetransmittedOnFailureRecovery() throws Exception {
+        server.enqueue(new MockResponse().setBody("abc"));
+        server.enqueue(new MockResponse().setSocketPolicy(SocketPolicy.DISCONNECT_AFTER_REQUEST));
+        server.enqueue(new MockResponse().setBody("def"));
+        assertContent("abc", client.open(server.url("/").url()));
+        HttpURLConnection post = client.open(server.url("/").url());
+        post.setDoOutput(true);
+        post.getOutputStream().write("body!".getBytes(Util.UTF_8));
+        assertContent("def", post);
+        RecordedRequest get = server.takeRequest();
+        assertEquals(0, get.getSequenceNumber());
+        RecordedRequest post1 = server.takeRequest();
+        assertEquals("body!", post1.getBody().readUtf8());
+        assertEquals(1, post1.getSequenceNumber());
+        RecordedRequest post2 = server.takeRequest();
+        assertEquals("body!", post2.getBody().readUtf8());
+        assertEquals(0, post2.getSequenceNumber());
+    }
+
+    @Test
+    public void fullyBufferedPostIsTooShort() throws Exception {
+        server.enqueue(new MockResponse().setBody("A"));
+        connection = client.open(server.url("/b").url());
+        connection.setRequestProperty("Content-Length", "4");
+        connection.setRequestMethod("POST");
+        OutputStream out = connection.getOutputStream();
+        out.write('a');
+        out.write('b');
+        out.write('c');
+        try {
+            out.close();
+            fail();
+        } catch (IOException expected) {
+        }
+    }
+
+    @Test
+    public void fullyBufferedPostIsTooLong() throws Exception {
+        server.enqueue(new MockResponse().setBody("A"));
+        connection = client.open(server.url("/b").url());
+        connection.setRequestProperty("Content-Length", "3");
+        connection.setRequestMethod("POST");
+        OutputStream out = connection.getOutputStream();
+        out.write('a');
+        out.write('b');
+        out.write('c');
+        try {
+            out.write('d');
+            out.flush();
+            fail();
+        } catch (IOException expected) {
+        }
+    }
+
+    @Test
+    @Ignore
+    public void testPooledConnectionsDetectHttp10() {
+        fail("TODO");
+    }
+
+    @Test
+    @Ignore
+    public void postBodiesRetransmittedOnAuthProblems() {
+        fail("TODO");
+    }
+
+    @Test
+    @Ignore
+    public void cookiesAndTrailers() {
+        fail("TODO");
+    }
+
+    @Test
+    @Ignore
+    public void headerNamesContainingNullCharacter() {
+        fail("TODO");
+    }
+
+    @Test
+    @Ignore
+    public void headerValuesContainingNullCharacter() {
+        fail("TODO");
+    }
+
+    @Test
+    public void emptyRequestHeaderValueIsAllowed() throws Exception {
+        server.enqueue(new MockResponse().setBody("body"));
+        connection = client.open(server.url("/").url());
+        connection.addRequestProperty("B", "");
+        assertContent("body", connection);
+        assertEquals("", connection.getRequestProperty("B"));
+    }
+
+    @Test
+    public void emptyResponseHeaderValueIsAllowed() throws Exception {
+        server.enqueue(new MockResponse().addHeader("A:").setBody("body"));
+        connection = client.open(server.url("/").url());
+        assertContent("body", connection);
+        assertEquals("", connection.getHeaderField("A"));
+    }
+
+    @Test
+    public void emptyRequestHeaderNameIsStrict() throws Exception {
+        server.enqueue(new MockResponse().setBody("body"));
+        connection = client.open(server.url("/").url());
+        try {
+            connection.setRequestProperty("", "A");
+            fail();
+        } catch (IllegalArgumentException expected) {
+        }
+    }
+
+    @Test
+    public void emptyResponseHeaderNameIsLenient() throws Exception {
+        Headers.Builder headers = new Headers.Builder();
+        Internal.instance.addLenient(headers, ":A");
+        server.enqueue(new MockResponse().setHeaders(headers.build()).setBody("body"));
+        connection = client.open(server.url("/").url());
+        connection.getResponseCode();
+        assertEquals("A", connection.getHeaderField(""));
+        connection.getInputStream().close();
+    }
+
+    @Test
+    public void requestHeaderValidationIsStrict() throws Exception {
+        connection = client.open(server.url("/").url());
+        try {
+            connection.addRequestProperty("a\tb", "Value");
+            fail();
+        } catch (IllegalArgumentException expected) {
+        }
+        try {
+            connection.addRequestProperty("Name", "cd");
+            fail();
+        } catch (IllegalArgumentException expected) {
+        }
+        try {
+            connection.addRequestProperty("", "Value");
+            fail();
+        } catch (IllegalArgumentException expected) {
+        }
+        try {
+            connection.addRequestProperty("?", "Value");
+            fail();
+        } catch (IllegalArgumentException expected) {
+        }
+        try {
+            connection.addRequestProperty("Name", "??");
+            fail();
+        } catch (IllegalArgumentException expected) {
+        }
+    }
+
+    @Test
+    public void responseHeaderParsingIsLenient() throws Exception {
+        Headers headers = new Headers.Builder().add("Content-Length", "0").addLenient("a\tb: cd").addLenient(": ef").addLenient("?: ??").build();
+        server.enqueue(new MockResponse().setHeaders(headers));
+        connection = client.open(server.url("/").url());
+        connection.getResponseCode();
+        assertEquals("cd", connection.getHeaderField("a\tb"));
+        assertEquals("??", connection.getHeaderField("?"));
+        assertEquals("ef", connection.getHeaderField(""));
+    }
+
+    @Test
+    @Ignore
+    public void deflateCompression() {
+        fail("TODO");
+    }
+
+    @Test
+    @Ignore
+    public void postBodiesRetransmittedOnIpAddressProblems() {
+        fail("TODO");
+    }
+
+    @Test
+    @Ignore
+    public void pooledConnectionProblemsNotReportedToProxySelector() {
+        fail("TODO");
+    }
+
+    @Test
+    public void customBasicAuthenticator() throws Exception {
+        MockResponse pleaseAuthenticate = new MockResponse().setResponseCode(401).addHeader("WWW-Authenticate: Basic realm=\"protected area\"").setBody("Please authenticate.");
+        server.enqueue(pleaseAuthenticate);
+        server.enqueue(new MockResponse().setBody("A"));
+        String credential = Credentials.basic("jesse", "peanutbutter");
+        RecordingOkAuthenticator authenticator = new RecordingOkAuthenticator(credential);
+        client.client().setAuthenticator(authenticator);
+        assertContent("A", client.open(server.url("/private").url()));
+        assertNull(server.takeRequest().getHeader("Authorization"));
+        assertEquals(credential, server.takeRequest().getHeader("Authorization"));
+        assertEquals(Proxy.NO_PROXY, authenticator.onlyProxy());
+        Response response = authenticator.onlyResponse();
+        assertEquals("/private", response.request().url().url().getPath());
+        assertEquals(Arrays.asList(new Challenge("Basic", "protected area")), response.challenges());
+    }
+
+    @Test
+    public void customTokenAuthenticator() throws Exception {
+        MockResponse pleaseAuthenticate = new MockResponse().setResponseCode(401).addHeader("WWW-Authenticate: Bearer realm=\"oauthed\"").setBody("Please authenticate.");
+        server.enqueue(pleaseAuthenticate);
+        server.enqueue(new MockResponse().setBody("A"));
+        RecordingOkAuthenticator authenticator = new RecordingOkAuthenticator("oauthed abc123");
+        client.client().setAuthenticator(authenticator);
+        assertContent("A", client.open(server.url("/private").url()));
+        assertNull(server.takeRequest().getHeader("Authorization"));
+        assertEquals("oauthed abc123", server.takeRequest().getHeader("Authorization"));
+        Response response = authenticator.onlyResponse();
+        assertEquals("/private", response.request().url().url().getPath());
+        assertEquals(Arrays.asList(new Challenge("Bearer", "oauthed")), response.challenges());
+    }
+
+    @Test
+    public void authenticateCallsTrackedAsRedirects() throws Exception {
+        server.enqueue(new MockResponse().setResponseCode(302).addHeader("Location: /b"));
+        server.enqueue(new MockResponse().setResponseCode(401).addHeader("WWW-Authenticate: Basic realm=\"protected area\""));
+        server.enqueue(new MockResponse().setBody("c"));
+        RecordingOkAuthenticator authenticator = new RecordingOkAuthenticator(Credentials.basic("jesse", "peanutbutter"));
+        client.client().setAuthenticator(authenticator);
+        assertContent("c", client.open(server.url("/a").url()));
+        Response challengeResponse = authenticator.responses.get(0);
+        assertEquals("/b", challengeResponse.request().url().url().getPath());
+        Response redirectedBy = challengeResponse.priorResponse();
+        assertEquals("/a", redirectedBy.request().url().url().getPath());
+    }
+
+    @Test
+    public void attemptAuthorization20Times() throws Exception {
+        for (int i = 0; i < 20; i++) {
+            server.enqueue(new MockResponse().setResponseCode(401));
+        }
+        server.enqueue(new MockResponse().setBody("Success!"));
+        String credential = Credentials.basic("jesse", "peanutbutter");
+        client.client().setAuthenticator(new RecordingOkAuthenticator(credential));
+        connection = client.open(server.url("/0").url());
+        assertContent("Success!", connection);
+    }
+
+    @Test
+    public void doesNotAttemptAuthorization21Times() throws Exception {
+        for (int i = 0; i < 21; i++) {
+            server.enqueue(new MockResponse().setResponseCode(401));
+        }
+        String credential = Credentials.basic("jesse", "peanutbutter");
+        client.client().setAuthenticator(new RecordingOkAuthenticator(credential));
+        connection = client.open(server.url("/").url());
+        try {
+            connection.getInputStream();
+            fail();
+        } catch (ProtocolException expected) {
+            assertEquals(401, connection.getResponseCode());
+            assertEquals("Too many follow-up requests: 21", expected.getMessage());
+        }
+    }
+
+    @Test
+    public void setsNegotiatedProtocolHeader_SPDY_3() throws Exception {
+        setsNegotiatedProtocolHeader(Protocol.SPDY_3);
+    }
+
+    @Test
+    public void setsNegotiatedProtocolHeader_HTTP_2() throws Exception {
+        setsNegotiatedProtocolHeader(Protocol.HTTP_2);
+    }
+
+    private void setsNegotiatedProtocolHeader(Protocol protocol) throws IOException {
+        enableProtocol(protocol);
+        server.enqueue(new MockResponse().setBody("A"));
+        client.client().setProtocols(Arrays.asList(protocol, Protocol.HTTP_1_1));
+        connection = client.open(server.url("/").url());
+        List<String> protocolValues = connection.getHeaderFields().get(SELECTED_PROTOCOL);
+        assertEquals(Arrays.asList(protocol.toString()), protocolValues);
+        assertContent("A", connection);
+    }
+
+    @Test
+    public void http10SelectedProtocol() throws Exception {
+        server.enqueue(new MockResponse().setStatus("HTTP/1.0 200 OK"));
+        connection = client.open(server.url("/").url());
+        List<String> protocolValues = connection.getHeaderFields().get(SELECTED_PROTOCOL);
+        assertEquals(Arrays.asList("http/1.0"), protocolValues);
+    }
+
+    @Test
+    public void http11SelectedProtocol() throws Exception {
+        server.enqueue(new MockResponse().setStatus("HTTP/1.1 200 OK"));
+        connection = client.open(server.url("/").url());
+        List<String> protocolValues = connection.getHeaderFields().get(SELECTED_PROTOCOL);
+        assertEquals(Arrays.asList("http/1.1"), protocolValues);
+    }
+
+    /** For example, empty Protobuf RPC messages end up as a zero-length POST. */
+    @Test
+    public void zeroLengthPost() throws IOException, InterruptedException {
+        zeroLengthPayload("POST");
+    }
+
+    @Test
+    public void zeroLengthPost_SPDY_3() throws Exception {
+        enableProtocol(Protocol.SPDY_3);
+        zeroLengthPost();
+    }
+
+    @Test
+    public void zeroLengthPost_HTTP_2() throws Exception {
+        enableProtocol(Protocol.HTTP_2);
+        zeroLengthPost();
+    }
+
+    /** For example, creating an Amazon S3 bucket ends up as a zero-length POST. */
+    @Test
+    public void zeroLengthPut() throws IOException, InterruptedException {
+        zeroLengthPayload("PUT");
+    }
+
+    @Test
+    public void zeroLengthPut_SPDY_3() throws Exception {
+        enableProtocol(Protocol.SPDY_3);
+        zeroLengthPut();
+    }
+
+    @Test
+    public void zeroLengthPut_HTTP_2() throws Exception {
+        enableProtocol(Protocol.HTTP_2);
+        zeroLengthPut();
+    }
+
+    private void zeroLengthPayload(String method) throws IOException, InterruptedException {
+        server.enqueue(new MockResponse());
+        connection = client.open(server.url("/").url());
+        connection.setRequestProperty("Content-Length", "0");
+        connection.setRequestMethod(method);
+        connection.setFixedLengthStreamingMode(0);
+        connection.setDoOutput(true);
+        assertContent("", connection);
+        RecordedRequest zeroLengthPayload = server.takeRequest();
+        assertEquals(method, zeroLengthPayload.getMethod());
+        assertEquals("0", zeroLengthPayload.getHeader("content-length"));
+        assertEquals(0L, zeroLengthPayload.getBodySize());
+    }
+
+    @Test
+    public void unspecifiedRequestBodyContentTypeGetsDefault() throws Exception {
+        server.enqueue(new MockResponse());
+        connection = client.open(server.url("/").url());
+        connection.setDoOutput(true);
+        connection.getOutputStream().write("abc".getBytes(UTF_8));
+        assertEquals(200, connection.getResponseCode());
+        RecordedRequest request = server.takeRequest();
+        assertEquals("application/x-www-form-urlencoded", request.getHeader("Content-Type"));
+        assertEquals("3", request.getHeader("Content-Length"));
+        assertEquals("abc", request.getBody().readUtf8());
+    }
+
+    @Test
+    public void setProtocols() throws Exception {
+        server.enqueue(new MockResponse().setBody("A"));
+        client.client().setProtocols(Arrays.asList(Protocol.HTTP_1_1));
+        assertContent("A", client.open(server.url("/").url()));
+    }
+
+    @Test
+    public void setProtocolsWithoutHttp11() throws Exception {
+        try {
+            client.client().setProtocols(Arrays.asList(Protocol.SPDY_3));
+            fail();
+        } catch (IllegalArgumentException expected) {
+        }
+    }
+
+    @Test
+    public void setProtocolsWithNull() throws Exception {
+        try {
+            client.client().setProtocols(Arrays.asList(Protocol.HTTP_1_1, null));
+            fail();
+        } catch (IllegalArgumentException expected) {
+        }
+    }
+
+    @Test
+    public void veryLargeFixedLengthRequest() throws Exception {
+        server.setBodyLimit(0);
+        server.enqueue(new MockResponse());
+        connection = client.open(server.url("/").url());
+        connection.setDoOutput(true);
+        long contentLength = Integer.MAX_VALUE + 1L;
+        connection.setFixedLengthStreamingMode(contentLength);
+        OutputStream out = connection.getOutputStream();
+        byte[] buffer = new byte[1024 * 1024];
+        for (long bytesWritten = 0; bytesWritten < contentLength; ) {
+            int byteCount = (int) Math.min(buffer.length, contentLength - bytesWritten);
+            out.write(buffer, 0, byteCount);
+            bytesWritten += byteCount;
+        }
+        assertContent("", connection);
+        RecordedRequest request = server.takeRequest();
+        assertEquals(Long.toString(contentLength), request.getHeader("Content-Length"));
+    }
+
+    /**
    * We had a bug where we attempted to gunzip responses that didn't have a
    * body. This only came up with 304s since that response code can include
    * headers (like "Content-Encoding") without any content to go along with it.
    * https://github.com/square/okhttp/issues/358
-   */
-  @Test public void noTransparentGzipFor304NotModified() throws Exception {
-    server.enqueue(new MockResponse()
-        .clearHeaders()
-        .setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED)
-        .addHeader("Content-Encoding: gzip"));
-    server.enqueue(new MockResponse().setBody("b"));
-
-    HttpURLConnection connection1 = client.open(server.url("/").url());
-    assertEquals(HttpURLConnection.HTTP_NOT_MODIFIED, connection1.getResponseCode());
-    assertContent("", connection1);
-
-    HttpURLConnection connection2 = client.open(server.url("/").url());
-    assertEquals(HttpURLConnection.HTTP_OK, connection2.getResponseCode());
-    assertContent("b", connection2);
-
-    RecordedRequest requestA = server.takeRequest();
-    assertEquals(0, requestA.getSequenceNumber());
-
-    RecordedRequest requestB = server.takeRequest();
-    assertEquals(1, requestB.getSequenceNumber());
-  }
-
-  /**
+   */
+    @Test
+    public void noTransparentGzipFor304NotModified() throws Exception {
+        server.enqueue(new MockResponse().clearHeaders().setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED).addHeader("Content-Encoding: gzip"));
+        server.enqueue(new MockResponse().setBody("b"));
+        HttpURLConnection connection1 = client.open(server.url("/").url());
+        assertEquals(HttpURLConnection.HTTP_NOT_MODIFIED, connection1.getResponseCode());
+        assertContent("", connection1);
+        HttpURLConnection connection2 = client.open(server.url("/").url());
+        assertEquals(HttpURLConnection.HTTP_OK, connection2.getResponseCode());
+        assertContent("b", connection2);
+        RecordedRequest requestA = server.takeRequest();
+        assertEquals(0, requestA.getSequenceNumber());
+        RecordedRequest requestB = server.takeRequest();
+        assertEquals(1, requestB.getSequenceNumber());
+    }
+
+    /**
    * We had a bug where we weren't closing Gzip streams on redirects.
    * https://github.com/square/okhttp/issues/441
-   */
-  @Test public void gzipWithRedirectAndConnectionReuse() throws Exception {
-    server.enqueue(new MockResponse()
-        .setResponseCode(HttpURLConnection.HTTP_MOVED_TEMP)
-        .addHeader("Location: /foo")
-        .addHeader("Content-Encoding: gzip")
-        .setBody(gzip("Moved! Moved! Moved!")));
-    server.enqueue(new MockResponse().setBody("This is the new page!"));
-
-    HttpURLConnection connection = client.open(server.url("/").url());
-    assertContent("This is the new page!", connection);
-
-    RecordedRequest requestA = server.takeRequest();
-    assertEquals(0, requestA.getSequenceNumber());
-
-    RecordedRequest requestB = server.takeRequest();
-    assertEquals(1, requestB.getSequenceNumber());
-  }
-
-  /**
+   */
+    @Test
+    public void gzipWithRedirectAndConnectionReuse() throws Exception {
+        server.enqueue(new MockResponse().setResponseCode(HttpURLConnection.HTTP_MOVED_TEMP).addHeader("Location: /foo").addHeader("Content-Encoding: gzip").setBody(gzip("Moved! Moved! Moved!")));
+        server.enqueue(new MockResponse().setBody("This is the new page!"));
+        HttpURLConnection connection = client.open(server.url("/").url());
+        assertContent("This is the new page!", connection);
+        RecordedRequest requestA = server.takeRequest();
+        assertEquals(0, requestA.getSequenceNumber());
+        RecordedRequest requestB = server.takeRequest();
+        assertEquals(1, requestB.getSequenceNumber());
+    }
+
+    /**
    * The RFC is unclear in this regard as it only specifies that this should
    * invalidate the cache entry (if any).
-   */
-  @Test public void bodyPermittedOnDelete() throws Exception {
-    server.enqueue(new MockResponse());
-
-    HttpURLConnection connection = client.open(server.url("/").url());
-    connection.setRequestMethod("DELETE");
-    connection.setDoOutput(true);
-    connection.getOutputStream().write("BODY".getBytes(UTF_8));
-    assertEquals(200, connection.getResponseCode());
-
-    RecordedRequest request = server.takeRequest();
-    assertEquals("DELETE", request.getMethod());
-    assertEquals("BODY", request.getBody().readUtf8());
-  }
-
-  @Test public void userAgentPicksUpHttpAgentSystemProperty() throws Exception {
-    server.enqueue(new MockResponse().setBody("abc"));
-
-    System.setProperty("http.agent", "foo");
-    assertContent("abc", client.open(server.url("/").url()));
-
-    RecordedRequest request = server.takeRequest();
-    assertEquals("foo", request.getHeader("User-Agent"));
-  }
-
-  /** https://github.com/square/okhttp/issues/891 */
-  @Test public void userAgentSystemPropertyIsNotAscii() throws Exception {
-    server.enqueue(new MockResponse().setBody("abc"));
-
-    System.setProperty("http.agent", "a\nb\ud83c\udf69c\ud83c\udf68d\u007fe");
-    assertContent("abc", client.open(server.url("/").url()));
-
-    RecordedRequest request = server.takeRequest();
-    assertEquals("a?b?c?d?e", request.getHeader("User-Agent"));
-  }
-
-  @Test public void userAgentDefaultsToOkHttpVersion() throws Exception {
-    server.enqueue(new MockResponse().setBody("abc"));
-
-    assertContent("abc", client.open(server.url("/").url()));
-
-    RecordedRequest request = server.takeRequest();
-    assertEquals(Version.userAgent(), request.getHeader("User-Agent"));
-  }
-
-  @Test public void interceptorsNotInvoked() throws Exception {
-    Interceptor interceptor = new Interceptor() {
-      @Override public Response intercept(Chain chain) throws IOException {
-        throw new AssertionError();
-      }
-    };
-    client.client().interceptors().add(interceptor);
-    client.client().networkInterceptors().add(interceptor);
-
-    server.enqueue(new MockResponse().setBody("abc"));
-    assertContent("abc", client.open(server.url("/").url()));
-  }
-
-  @Test public void urlWithSpaceInHost() throws Exception {
-    URLConnection urlConnection = client.open(new URL("http://and roid.com/"));
-    try {
-      urlConnection.getInputStream();
-      fail();
-    } catch (UnknownHostException expected) {
-    }
-  }
-
-  @Test public void urlWithSpaceInHostViaHttpProxy() throws Exception {
-    server.enqueue(new MockResponse());
-    URLConnection urlConnection =
-        client.open(new URL("http://and roid.com/"), server.toProxyAddress());
-
-    try {
-      // This test is to check that a NullPointerException is not thrown.
-      urlConnection.getInputStream();
-      fail(); // the RI makes a bogus proxy request for "GET http://and roid.com/ HTTP/1.1"
-    } catch (UnknownHostException expected) {
-    }
-  }
-
-  @Test public void urlHostWithNul() throws Exception {
-    URLConnection urlConnection = client.open(new URL("http://host\u0000/"));
-    try {
-      urlConnection.getInputStream();
-      fail();
-    } catch (UnknownHostException expected) {
-    }
-  }
-
-  @Test public void urlRedirectToHostWithNul() throws Exception {
-    String redirectUrl = "http://host\u0000/";
-    server.enqueue(new MockResponse().setResponseCode(302)
-        .addHeaderLenient("Location", redirectUrl));
-
-    HttpURLConnection urlConnection = client.open(server.url("/").url());
-    assertEquals(302, urlConnection.getResponseCode());
-    assertEquals(redirectUrl, urlConnection.getHeaderField("Location"));
-  }
-
-  @Test public void urlWithBadAsciiHost() throws Exception {
-    URLConnection urlConnection = client.open(new URL("http://host\u0001/"));
-    try {
-      urlConnection.getInputStream();
-      fail();
-    } catch (UnknownHostException expected) {
-    }
-  }
-
-  @Test public void instanceFollowsRedirects() throws Exception {
-    testInstanceFollowsRedirects("http://www.google.com/");
-    testInstanceFollowsRedirects("https://www.google.com/");
-  }
-
-  private void testInstanceFollowsRedirects(String spec) throws Exception {
-    URL url = new URL(spec);
-    HttpURLConnection urlConnection = client.open(url);
-    urlConnection.setInstanceFollowRedirects(true);
-    assertTrue(urlConnection.getInstanceFollowRedirects());
-    urlConnection.setInstanceFollowRedirects(false);
-    assertFalse(urlConnection.getInstanceFollowRedirects());
-  }
-
-  /** Returns a gzipped copy of {@code bytes}. */
-  public Buffer gzip(String data) throws IOException {
-    Buffer result = new Buffer();
-    BufferedSink gzipSink = Okio.buffer(new GzipSink(result));
-    gzipSink.writeUtf8(data);
-    gzipSink.close();
-    return result;
-  }
-
-  /**
+   */
+    @Test
+    public void bodyPermittedOnDelete() throws Exception {
+        server.enqueue(new MockResponse());
+        HttpURLConnection connection = client.open(server.url("/").url());
+        connection.setRequestMethod("DELETE");
+        connection.setDoOutput(true);
+        connection.getOutputStream().write("BODY".getBytes(UTF_8));
+        assertEquals(200, connection.getResponseCode());
+        RecordedRequest request = server.takeRequest();
+        assertEquals("DELETE", request.getMethod());
+        assertEquals("BODY", request.getBody().readUtf8());
+    }
+
+    @Test
+    public void userAgentPicksUpHttpAgentSystemProperty() throws Exception {
+        server.enqueue(new MockResponse().setBody("abc"));
+        System.setProperty("http.agent", "foo");
+        assertContent("abc", client.open(server.url("/").url()));
+        RecordedRequest request = server.takeRequest();
+        assertEquals("foo", request.getHeader("User-Agent"));
+    }
+
+    /** https://github.com/square/okhttp/issues/891 */
+    @Test
+    public void userAgentSystemPropertyIsNotAscii() throws Exception {
+        server.enqueue(new MockResponse().setBody("abc"));
+        System.setProperty("http.agent", "a\nb?c?de");
+        assertContent("abc", client.open(server.url("/").url()));
+        RecordedRequest request = server.takeRequest();
+        assertEquals("a?b?c?d?e", request.getHeader("User-Agent"));
+    }
+
+    @Test
+    public void userAgentDefaultsToOkHttpVersion() throws Exception {
+        server.enqueue(new MockResponse().setBody("abc"));
+        assertContent("abc", client.open(server.url("/").url()));
+        RecordedRequest request = server.takeRequest();
+        assertEquals(Version.userAgent(), request.getHeader("User-Agent"));
+    }
+
+    @Test
+    public void interceptorsNotInvoked() throws Exception {
+        Interceptor interceptor = new Interceptor() {
+
+            @Override
+            public Response intercept(Chain chain) throws IOException {
+                throw new AssertionError();
+            }
+        };
+        client.client().interceptors().add(interceptor);
+        client.client().networkInterceptors().add(interceptor);
+        server.enqueue(new MockResponse().setBody("abc"));
+        assertContent("abc", client.open(server.url("/").url()));
+    }
+
+    @Test
+    public void urlWithSpaceInHost() throws Exception {
+        URLConnection urlConnection = client.open(new URL("http://and roid.com/"));
+        try {
+            urlConnection.getInputStream();
+            fail();
+        } catch (UnknownHostException expected) {
+        }
+    }
+
+    @Test
+    public void urlWithSpaceInHostViaHttpProxy() throws Exception {
+        server.enqueue(new MockResponse());
+        URLConnection urlConnection = client.open(new URL("http://and roid.com/"), server.toProxyAddress());
+        try {
+            // This test is to check that a NullPointerException is not thrown.
+            urlConnection.getInputStream();
+            // the RI makes a bogus proxy request for "GET http://and roid.com/ HTTP/1.1"
+            fail();
+        } catch (UnknownHostException expected) {
+        }
+    }
+
+    @Test
+    public void urlHostWithNul() throws Exception {
+        URLConnection urlConnection = client.open(new URL("http://host /"));
+        try {
+            urlConnection.getInputStream();
+            fail();
+        } catch (UnknownHostException expected) {
+        }
+    }
+
+    @Test
+    public void urlRedirectToHostWithNul() throws Exception {
+        String redirectUrl = "http://host /";
+        server.enqueue(new MockResponse().setResponseCode(302).addHeaderLenient("Location", redirectUrl));
+        HttpURLConnection urlConnection = client.open(server.url("/").url());
+        assertEquals(302, urlConnection.getResponseCode());
+        assertEquals(redirectUrl, urlConnection.getHeaderField("Location"));
+    }
+
+    @Test
+    public void urlWithBadAsciiHost() throws Exception {
+        URLConnection urlConnection = client.open(new URL("http://host/"));
+        try {
+            urlConnection.getInputStream();
+            fail();
+        } catch (UnknownHostException expected) {
+        }
+    }
+
+    @Test
+    public void instanceFollowsRedirects() throws Exception {
+        testInstanceFollowsRedirects("http://www.google.com/");
+        testInstanceFollowsRedirects("https://www.google.com/");
+    }
+
+    private void testInstanceFollowsRedirects(String spec) throws Exception {
+        URL url = new URL(spec);
+        HttpURLConnection urlConnection = client.open(url);
+        urlConnection.setInstanceFollowRedirects(true);
+        assertTrue(urlConnection.getInstanceFollowRedirects());
+        urlConnection.setInstanceFollowRedirects(false);
+        assertFalse(urlConnection.getInstanceFollowRedirects());
+    }
+
+    /** Returns a gzipped copy of {@code bytes}. */
+    public Buffer gzip(String data) throws IOException {
+        Buffer result = new Buffer();
+        BufferedSink gzipSink = Okio.buffer(new GzipSink(result));
+        gzipSink.writeUtf8(data);
+        gzipSink.close();
+        return result;
+    }
+
+    /**
    * Reads at most {@code limit} characters from {@code in} and asserts that
    * content equals {@code expected}.
-   */
-  private void assertContent(String expected, HttpURLConnection connection, int limit)
-      throws IOException {
-    connection.connect();
-    assertEquals(expected, readAscii(connection.getInputStream(), limit));
-  }
-
-  private void assertContent(String expected, HttpURLConnection connection) throws IOException {
-    assertContent(expected, connection, Integer.MAX_VALUE);
-  }
-
-  private Set<String> newSet(String... elements) {
-    return new LinkedHashSet<>(Arrays.asList(elements));
-  }
-
-  enum TransferKind {
-    CHUNKED() {
-      @Override void setBody(MockResponse response, Buffer content, int chunkSize)
-          throws IOException {
-        response.setChunkedBody(content, chunkSize);
-      }
-      @Override void setForRequest(HttpURLConnection connection, int contentLength) {
-        connection.setChunkedStreamingMode(5);
-      }
-    },
-    FIXED_LENGTH() {
-      @Override void setBody(MockResponse response, Buffer content, int chunkSize) {
-        response.setBody(content);
-      }
-      @Override void setForRequest(HttpURLConnection connection, int contentLength) {
-        connection.setFixedLengthStreamingMode(contentLength);
-      }
-    },
-    END_OF_STREAM() {
-      @Override void setBody(MockResponse response, Buffer content, int chunkSize) {
-        response.setBody(content);
-        response.setSocketPolicy(DISCONNECT_AT_END);
-        response.removeHeader("Content-Length");
-      }
-      @Override void setForRequest(HttpURLConnection connection, int contentLength) {
-      }
-    };
-
-    abstract void setBody(MockResponse response, Buffer content, int chunkSize) throws IOException;
-
-    abstract void setForRequest(HttpURLConnection connection, int contentLength);
-
-    void setBody(MockResponse response, String content, int chunkSize) throws IOException {
-      setBody(response, new Buffer().writeUtf8(content), chunkSize);
-    }
-  }
-
-  enum ProxyConfig {
-    NO_PROXY() {
-      @Override public HttpURLConnection connect(
-          MockWebServer server, OkUrlFactory streamHandlerFactory, URL url)
-          throws IOException {
-        streamHandlerFactory.client().setProxy(Proxy.NO_PROXY);
-        return streamHandlerFactory.open(url);
-      }
-    },
-
-    CREATE_ARG() {
-      @Override public HttpURLConnection connect(
-          MockWebServer server, OkUrlFactory streamHandlerFactory, URL url)
-          throws IOException {
-        streamHandlerFactory.client().setProxy(server.toProxyAddress());
-        return streamHandlerFactory.open(url);
-      }
-    },
-
-    PROXY_SYSTEM_PROPERTY() {
-      @Override public HttpURLConnection connect(
-          MockWebServer server, OkUrlFactory streamHandlerFactory, URL url)
-          throws IOException {
-        System.setProperty("proxyHost", server.getHostName());
-        System.setProperty("proxyPort", Integer.toString(server.getPort()));
-        return streamHandlerFactory.open(url);
-      }
-    },
-
-    HTTP_PROXY_SYSTEM_PROPERTY() {
-      @Override public HttpURLConnection connect(
-          MockWebServer server, OkUrlFactory streamHandlerFactory, URL url)
-          throws IOException {
-        System.setProperty("http.proxyHost", server.getHostName());
-        System.setProperty("http.proxyPort", Integer.toString(server.getPort()));
-        return streamHandlerFactory.open(url);
-      }
-    },
-
-    HTTPS_PROXY_SYSTEM_PROPERTY() {
-      @Override public HttpURLConnection connect(
-          MockWebServer server, OkUrlFactory streamHandlerFactory, URL url)
-          throws IOException {
-        System.setProperty("https.proxyHost", server.getHostName());
-        System.setProperty("https.proxyPort", Integer.toString(server.getPort()));
-        return streamHandlerFactory.open(url);
-      }
-    };
-
-    public abstract HttpURLConnection connect(
-        MockWebServer server, OkUrlFactory streamHandlerFactory, URL url)
-        throws IOException;
-  }
-
-  private static class RecordingTrustManager implements X509TrustManager {
-    private final List<String> calls = new ArrayList<String>();
-
-    public X509Certificate[] getAcceptedIssuers() {
-      return new X509Certificate[] { };
-    }
-
-    public void checkClientTrusted(X509Certificate[] chain, String authType)
-        throws CertificateException {
-      calls.add("checkClientTrusted " + certificatesToString(chain));
-    }
-
-    public void checkServerTrusted(X509Certificate[] chain, String authType)
-        throws CertificateException {
-      calls.add("checkServerTrusted " + certificatesToString(chain));
-    }
-
-    private String certificatesToString(X509Certificate[] certificates) {
-      List<String> result = new ArrayList<String>();
-      for (X509Certificate certificate : certificates) {
-        result.add(certificate.getSubjectDN() + " " + certificate.getSerialNumber());
-      }
-      return result.toString();
-    }
-  }
-
-  private static class FakeProxySelector extends ProxySelector {
-    List<Proxy> proxies = new ArrayList<>();
-
-    @Override public List<Proxy> select(URI uri) {
-      // Don't handle 'socket' schemes, which the RI's Socket class may request (for SOCKS).
-      return uri.getScheme().equals("http") || uri.getScheme().equals("https") ? proxies
-          : Collections.singletonList(Proxy.NO_PROXY);
-    }
-
-    @Override public void connectFailed(URI uri, SocketAddress sa, IOException ioe) {
-    }
-  }
-
-  /**
+   */
+    private void assertContent(String expected, HttpURLConnection connection, int limit) throws IOException {
+        connection.connect();
+        assertEquals(expected, readAscii(connection.getInputStream(), limit));
+    }
+
+    private void assertContent(String expected, HttpURLConnection connection) throws IOException {
+        assertContent(expected, connection, Integer.MAX_VALUE);
+    }
+
+    private Set<String> newSet(String... elements) {
+        return new LinkedHashSet<>(Arrays.asList(elements));
+    }
+
+    enum TransferKind {
+
+        CHUNKED() {
+
+            @Override
+            void setBody(MockResponse response, Buffer content, int chunkSize) throws IOException {
+                response.setChunkedBody(content, chunkSize);
+            }
+
+            @Override
+            void setForRequest(HttpURLConnection connection, int contentLength) {
+                connection.setChunkedStreamingMode(5);
+            }
+        }
+        , FIXED_LENGTH() {
+
+            @Override
+            void setBody(MockResponse response, Buffer content, int chunkSize) {
+                response.setBody(content);
+            }
+
+            @Override
+            void setForRequest(HttpURLConnection connection, int contentLength) {
+                connection.setFixedLengthStreamingMode(contentLength);
+            }
+        }
+        , END_OF_STREAM() {
+
+            @Override
+            void setBody(MockResponse response, Buffer content, int chunkSize) {
+                response.setBody(content);
+                response.setSocketPolicy(DISCONNECT_AT_END);
+                response.removeHeader("Content-Length");
+            }
+
+            @Override
+            void setForRequest(HttpURLConnection connection, int contentLength) {
+            }
+        }
+        ;
+
+        abstract void setBody(MockResponse response, Buffer content, int chunkSize) throws IOException;
+
+        abstract void setForRequest(HttpURLConnection connection, int contentLength);
+
+        void setBody(MockResponse response, String content, int chunkSize) throws IOException {
+            setBody(response, new Buffer().writeUtf8(content), chunkSize);
+        }
+    }
+
+    enum ProxyConfig {
+
+        NO_PROXY() {
+
+            @Override
+            public HttpURLConnection connect(MockWebServer server, OkUrlFactory streamHandlerFactory, URL url) throws IOException {
+                streamHandlerFactory.client().setProxy(Proxy.NO_PROXY);
+                return streamHandlerFactory.open(url);
+            }
+        }
+        , CREATE_ARG() {
+
+            @Override
+            public HttpURLConnection connect(MockWebServer server, OkUrlFactory streamHandlerFactory, URL url) throws IOException {
+                streamHandlerFactory.client().setProxy(server.toProxyAddress());
+                return streamHandlerFactory.open(url);
+            }
+        }
+        , PROXY_SYSTEM_PROPERTY() {
+
+            @Override
+            public HttpURLConnection connect(MockWebServer server, OkUrlFactory streamHandlerFactory, URL url) throws IOException {
+                System.setProperty("proxyHost", server.getHostName());
+                System.setProperty("proxyPort", Integer.toString(server.getPort()));
+                return streamHandlerFactory.open(url);
+            }
+        }
+        , HTTP_PROXY_SYSTEM_PROPERTY() {
+
+            @Override
+            public HttpURLConnection connect(MockWebServer server, OkUrlFactory streamHandlerFactory, URL url) throws IOException {
+                System.setProperty("http.proxyHost", server.getHostName());
+                System.setProperty("http.proxyPort", Integer.toString(server.getPort()));
+                return streamHandlerFactory.open(url);
+            }
+        }
+        , HTTPS_PROXY_SYSTEM_PROPERTY() {
+
+            @Override
+            public HttpURLConnection connect(MockWebServer server, OkUrlFactory streamHandlerFactory, URL url) throws IOException {
+                System.setProperty("https.proxyHost", server.getHostName());
+                System.setProperty("https.proxyPort", Integer.toString(server.getPort()));
+                return streamHandlerFactory.open(url);
+            }
+        }
+        ;
+
+        public abstract HttpURLConnection connect(MockWebServer server, OkUrlFactory streamHandlerFactory, URL url) throws IOException;
+    }
+
+    private static class RecordingTrustManager implements X509TrustManager {
+
+        private final List<String> calls = new ArrayList<String>();
+
+        public X509Certificate[] getAcceptedIssuers() {
+            return new X509Certificate[] {};
+        }
+
+        public void checkClientTrusted(X509Certificate[] chain, String authType) throws CertificateException {
+            calls.add("checkClientTrusted " + certificatesToString(chain));
+        }
+
+        public void checkServerTrusted(X509Certificate[] chain, String authType) throws CertificateException {
+            calls.add("checkServerTrusted " + certificatesToString(chain));
+        }
+
+        private String certificatesToString(X509Certificate[] certificates) {
+            List<String> result = new ArrayList<String>();
+            for (X509Certificate certificate : certificates) {
+                result.add(certificate.getSubjectDN() + " " + certificate.getSerialNumber());
+            }
+            return result.toString();
+        }
+    }
+
+    private static class FakeProxySelector extends ProxySelector {
+
+        List<Proxy> proxies = new ArrayList<>();
+
+        @Override
+        public List<Proxy> select(URI uri) {
+            return uri.getScheme().equals("http") || uri.getScheme().equals("https") ? proxies : Collections.singletonList(Proxy.NO_PROXY);
+        }
+
+        @Override
+        public void connectFailed(URI uri, SocketAddress sa, IOException ioe) {
+        }
+    }
+
+    /**
    * Tests that use this will fail unless boot classpath is set. Ex. {@code
    * -Xbootclasspath/p:/tmp/alpn-boot-8.0.0.v20140317}
-   */
-  private void enableProtocol(Protocol protocol) {
-    client.client().setSslSocketFactory(sslContext.getSocketFactory());
-    client.client().setHostnameVerifier(new RecordingHostnameVerifier());
-    client.client().setProtocols(Arrays.asList(protocol, Protocol.HTTP_1_1));
-    server.useHttps(sslContext.getSocketFactory(), false);
-    server.setProtocolNegotiationEnabled(true);
-    server.setProtocols(client.client().getProtocols());
-  }
-
-  /**
+   */
+    private void enableProtocol(Protocol protocol) {
+        client.client().setSslSocketFactory(sslContext.getSocketFactory());
+        client.client().setHostnameVerifier(new RecordingHostnameVerifier());
+        client.client().setProtocols(Arrays.asList(protocol, Protocol.HTTP_1_1));
+        server.useHttps(sslContext.getSocketFactory(), false);
+        server.setProtocolNegotiationEnabled(true);
+        server.setProtocols(client.client().getProtocols());
+    }
+
+    /**
    * Used during tests that involve TLS connection fallback attempts. OkHttp includes the
    * TLS_FALLBACK_SCSV cipher on fallback connections. See
    * {@link com.squareup.okhttp.FallbackTestClientSocketFactory} for details.
-   */
-  private void suppressTlsFallbackScsv(OkHttpClient client) {
-    FallbackTestClientSocketFactory clientSocketFactory =
-        new FallbackTestClientSocketFactory(sslContext.getSocketFactory());
-    client.setSslSocketFactory(clientSocketFactory);
-  }
-}
+   */
+    private void suppressTlsFallbackScsv(OkHttpClient client) {
+        FallbackTestClientSocketFactory clientSocketFactory = new FallbackTestClientSocketFactory(sslContext.getSocketFactory());
+        client.setSslSocketFactory(clientSocketFactory);
+    }
+}
