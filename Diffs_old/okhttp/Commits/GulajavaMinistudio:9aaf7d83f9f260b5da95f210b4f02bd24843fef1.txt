diff --git a/okhttp/src/main/java/okhttp3/internal/platform/AndroidPlatform.kt b/okhttp/src/main/java/okhttp3/internal/platform/AndroidPlatform.kt
index b47772f4a6..e272481d55 100644
--- a/okhttp/src/main/java/okhttp3/internal/platform/AndroidPlatform.kt
+++ b/okhttp/src/main/java/okhttp3/internal/platform/AndroidPlatform.kt
@@ -16,8 +16,12 @@
 package okhttp3.internal.platform
 
 import android.os.Build
-import android.util.Log
 import okhttp3.Protocol
+import okhttp3.internal.platform.android.CloseGuard
+import okhttp3.internal.platform.android.ConscryptSocketAdapter
+import okhttp3.internal.platform.android.DeferredSocketAdapter
+import okhttp3.internal.platform.android.StandardAndroidSocketAdapter
+import okhttp3.internal.platform.android.androidLog
 import okhttp3.internal.tls.BasicTrustRootIndex
 import okhttp3.internal.tls.CertificateChainCleaner
 import okhttp3.internal.tls.TrustRootIndex
@@ -26,7 +30,6 @@ import java.lang.reflect.InvocationTargetException
 import java.lang.reflect.Method
 import java.net.InetSocketAddress
 import java.net.Socket
-import java.nio.charset.StandardCharsets.UTF_8
 import java.security.cert.Certificate
 import java.security.cert.TrustAnchor
 import java.security.cert.X509Certificate
@@ -36,14 +39,13 @@ import javax.net.ssl.SSLSocketFactory
 import javax.net.ssl.X509TrustManager
 
 /** Android 5+. */
-class AndroidPlatform(
-  private val sslParametersClass: Class<*>,
-  private val sslSocketClass: Class<*>,
-  private val setUseSessionTickets: Method,
-  private val setHostname: Method,
-  private val getAlpnSelectedProtocol: Method,
-  private val setAlpnProtocols: Method
-) : Platform() {
+class AndroidPlatform : Platform() {
+  private val socketAdapters = listOfNotNull(
+      StandardAndroidSocketAdapter.buildIfSupported(),
+      ConscryptSocketAdapter.buildIfSupported(),
+      DeferredSocketAdapter("com.google.android.gms.org.conscrypt")
+  ).filter { it.isSupported() }
+
   private val closeGuard = CloseGuard.get()
 
   @Throws(IOException::class)
@@ -65,87 +67,26 @@ class AndroidPlatform(
     }
   }
 
-  override fun trustManager(sslSocketFactory: SSLSocketFactory): X509TrustManager? {
-    var context: Any? =
-        readFieldOrNull(sslSocketFactory, sslParametersClass, "sslParameters")
-    if (context == null) {
-      // If that didn't work, try the Google Play Services SSL provider before giving up. This
-      // must be loaded by the SSLSocketFactory's class loader.
-      try {
-        val gmsSslParametersClass = Class.forName(
-            "com.google.android.gms.org.conscrypt.SSLParametersImpl", false,
-            sslSocketFactory.javaClass.classLoader)
-        context = readFieldOrNull(sslSocketFactory, gmsSslParametersClass,
-            "sslParameters")
-      } catch (e: ClassNotFoundException) {
-        return super.trustManager(sslSocketFactory)
-      }
-    }
-
-    val x509TrustManager = readFieldOrNull(
-        context!!, X509TrustManager::class.java, "x509TrustManager")
-    return x509TrustManager ?: readFieldOrNull(context, X509TrustManager::class.java,
-        "trustManager")
-  }
+  override fun trustManager(sslSocketFactory: SSLSocketFactory): X509TrustManager? =
+      socketAdapters.find { it.matchesSocketFactory(sslSocketFactory) }
+          ?.trustManager(sslSocketFactory)
 
   override fun configureTlsExtensions(
     sslSocket: SSLSocket,
     hostname: String?,
     protocols: List<Protocol>
   ) {
-    if (!sslSocketClass.isInstance(sslSocket)) {
-      return // No TLS extensions if the socket class is custom.
-    }
-    try {
-      // Enable SNI and session tickets.
-      if (hostname != null) {
-        setUseSessionTickets.invoke(sslSocket, true)
-        // This is SSLParameters.setServerNames() in API 24+.
-        setHostname.invoke(sslSocket, hostname)
-      }
-
-      // Enable ALPN.
-      setAlpnProtocols.invoke(sslSocket, concatLengthPrefixed(protocols))
-    } catch (e: IllegalAccessException) {
-      throw AssertionError(e)
-    } catch (e: InvocationTargetException) {
-      throw AssertionError(e)
-    }
+    // No TLS extensions if the socket class is custom.
+    socketAdapters.find { it.matchesSocket(sslSocket) }
+        ?.configureTlsExtensions(sslSocket, hostname, protocols)
   }
 
-  override fun getSelectedProtocol(socket: SSLSocket): String? {
-    return if (sslSocketClass.isInstance(socket))
-      try {
-        val alpnResult = getAlpnSelectedProtocol.invoke(socket) as ByteArray?
-        if (alpnResult != null) String(alpnResult, UTF_8) else null
-      } catch (e: IllegalAccessException) {
-        throw AssertionError(e)
-      } catch (e: InvocationTargetException) {
-        throw AssertionError(e)
-      }
-    else {
-      null // No TLS extensions if the socket class is custom.
-    }
-  }
+  override fun getSelectedProtocol(sslSocket: SSLSocket) =
+      // No TLS extensions if the socket class is custom.
+      socketAdapters.find { it.matchesSocket(sslSocket) }?.getSelectedProtocol(sslSocket)
 
   override fun log(level: Int, message: String, t: Throwable?) {
-    var logMessage = message
-    val logLevel = if (level == WARN) Log.WARN else Log.DEBUG
-    if (t != null) logMessage = logMessage + '\n'.toString() + Log.getStackTraceString(t)
-
-    // Split by line, then ensure each line can fit into Log's maximum length.
-    var i = 0
-    val length = logMessage.length
-    while (i < length) {
-      var newline = logMessage.indexOf('\n', i)
-      newline = if (newline != -1) newline else length
-      do {
-        val end = minOf(newline, i + MAX_LOG_LENGTH)
-        Log.println(logLevel, "OkHttp", logMessage.substring(i, end))
-        i = end
-      } while (i < newline)
-      i++
-    }
+    androidLog(level, message, t)
   }
 
   override fun getStackTraceForCloseable(closer: String): Any? = closeGuard.createAndOpen(closer)
@@ -258,67 +199,9 @@ class AndroidPlatform(
     override fun hashCode(): Int = 0
   }
 
-  /**
-   * Provides access to the internal dalvik.system.CloseGuard class. Android uses this in
-   * combination with android.os.StrictMode to report on leaked java.io.Closeable's. Available since
-   * Android API 11.
-   */
-  internal class CloseGuard(
-    private val getMethod: Method?,
-    private val openMethod: Method?,
-    private val warnIfOpenMethod: Method?
-  ) {
-
-    fun createAndOpen(closer: String): Any? {
-      if (getMethod != null) {
-        try {
-          val closeGuardInstance = getMethod.invoke(null)
-          openMethod!!.invoke(closeGuardInstance, closer)
-          return closeGuardInstance
-        } catch (_: Exception) {
-        }
-      }
-      return null
-    }
-
-    fun warnIfOpen(closeGuardInstance: Any?): Boolean {
-      var reported = false
-      if (closeGuardInstance != null) {
-        try {
-          warnIfOpenMethod!!.invoke(closeGuardInstance)
-          reported = true
-        } catch (_: Exception) {
-        }
-      }
-      return reported
-    }
-
-    companion object {
-      fun get(): CloseGuard {
-        var getMethod: Method?
-        var openMethod: Method?
-        var warnIfOpenMethod: Method?
-
-        try {
-          val closeGuardClass = Class.forName("dalvik.system.CloseGuard")
-          getMethod = closeGuardClass.getMethod("get")
-          openMethod = closeGuardClass.getMethod("open", String::class.java)
-          warnIfOpenMethod = closeGuardClass.getMethod("warnIfOpen")
-        } catch (_: Exception) {
-          getMethod = null
-          openMethod = null
-          warnIfOpenMethod = null
-        }
-
-        return CloseGuard(getMethod, openMethod, warnIfOpenMethod)
-      }
-    }
-  }
-
   /**
    * A trust manager for Android applications that customize the trust manager.
    *
-   *
    * This class exploits knowledge of Android implementation details. This class is potentially
    * much faster to initialize than [BasicTrustRootIndex] because it doesn't need to load and
    * index trusted CA certificates.
@@ -327,7 +210,6 @@ class AndroidPlatform(
     private val trustManager: X509TrustManager,
     private val findByIssuerAndSignatureMethod: Method
   ) : TrustRootIndex {
-
     override fun findByIssuerAndSignature(cert: X509Certificate): X509Certificate? {
       return try {
         val trustAnchor = findByIssuerAndSignatureMethod.invoke(
@@ -342,32 +224,21 @@ class AndroidPlatform(
   }
 
   companion object {
-    private const val MAX_LOG_LENGTH = 4000
-
-    fun buildIfSupported(): Platform? {
-      // Attempt to find Android 5+ APIs.
-      val sslParametersClass: Class<*>
-      val sslSocketClass: Class<*>
-      try {
-        sslParametersClass = Class.forName("com.android.org.conscrypt.SSLParametersImpl")
-        sslSocketClass = Class.forName("com.android.org.conscrypt.OpenSSLSocketImpl")
-      } catch (_: ClassNotFoundException) {
-        return null // Not an Android runtime.
+    val isSupported: Boolean = try {
+      // Trigger an early exception over a fatal error, prefer a RuntimeException over Error.
+      Class.forName("com.android.org.conscrypt.OpenSSLSocketImpl")
+
+      // Fail Fast
+      if (Build.VERSION.SDK_INT < 21) {
+        throw IllegalStateException(
+            "Expected Android API level 21+ but was ${Build.VERSION.SDK_INT}")
       }
 
-      if (Build.VERSION.SDK_INT >= 21) {
-        try {
-          val setUseSessionTickets = sslSocketClass.getDeclaredMethod(
-              "setUseSessionTickets", Boolean::class.javaPrimitiveType)
-          val setHostname = sslSocketClass.getMethod("setHostname", String::class.java)
-          val getAlpnSelectedProtocol = sslSocketClass.getMethod("getAlpnSelectedProtocol")
-          val setAlpnProtocols = sslSocketClass.getMethod("setAlpnProtocols", ByteArray::class.java)
-          return AndroidPlatform(sslParametersClass, sslSocketClass, setUseSessionTickets,
-              setHostname, getAlpnSelectedProtocol, setAlpnProtocols)
-        } catch (_: NoSuchMethodException) {
-        }
-      }
-      throw IllegalStateException("Expected Android API level 21+ but was ${Build.VERSION.SDK_INT}")
+      true
+    } catch (e: ClassNotFoundException) {
+      false
     }
+
+    fun buildIfSupported(): Platform? = if (isSupported) AndroidPlatform() else null
   }
 }
diff --git a/okhttp/src/main/java/okhttp3/internal/platform/ConscryptPlatform.kt b/okhttp/src/main/java/okhttp3/internal/platform/ConscryptPlatform.kt
index 882653c6fc..22670dee6e 100644
--- a/okhttp/src/main/java/okhttp3/internal/platform/ConscryptPlatform.kt
+++ b/okhttp/src/main/java/okhttp3/internal/platform/ConscryptPlatform.kt
@@ -85,11 +85,11 @@ class ConscryptPlatform private constructor() : Platform() {
     }
   }
 
-  override fun getSelectedProtocol(socket: SSLSocket): String? =
-      if (Conscrypt.isConscrypt(socket)) {
-        Conscrypt.getApplicationProtocol(socket)
+  override fun getSelectedProtocol(sslSocket: SSLSocket): String? =
+      if (Conscrypt.isConscrypt(sslSocket)) {
+        Conscrypt.getApplicationProtocol(sslSocket)
       } else {
-        super.getSelectedProtocol(socket)
+        super.getSelectedProtocol(sslSocket)
       }
 
   override fun configureSslSocketFactory(socketFactory: SSLSocketFactory) {
@@ -106,18 +106,20 @@ class ConscryptPlatform private constructor() : Platform() {
   }
 
   companion object {
-    fun buildIfSupported(): ConscryptPlatform? = try {
+    val isSupported: Boolean = try {
       // Trigger an early exception over a fatal error, prefer a RuntimeException over Error.
       Class.forName("org.conscrypt.Conscrypt\$Version")
 
       when {
-        Conscrypt.isAvailable() && atLeastVersion(2, 1, 0) -> ConscryptPlatform()
-        else -> null
+        Conscrypt.isAvailable() && atLeastVersion(2, 1, 0) -> true
+        else -> false
       }
     } catch (e: ClassNotFoundException) {
-      null
+      false
     }
 
+    fun buildIfSupported(): ConscryptPlatform? = if (isSupported) ConscryptPlatform() else null
+
     fun atLeastVersion(major: Int, minor: Int = 0, patch: Int = 0): Boolean {
       val conscryptVersion = Conscrypt.version()
 
diff --git a/okhttp/src/main/java/okhttp3/internal/platform/Platform.kt b/okhttp/src/main/java/okhttp3/internal/platform/Platform.kt
index bd86cdaf6c..fda0ed0102 100644
--- a/okhttp/src/main/java/okhttp3/internal/platform/Platform.kt
+++ b/okhttp/src/main/java/okhttp3/internal/platform/Platform.kt
@@ -119,7 +119,7 @@ open class Platform {
   }
 
   /** Returns the negotiated protocol, or null if no protocol was negotiated. */
-  open fun getSelectedProtocol(socket: SSLSocket): String? = null
+  open fun getSelectedProtocol(sslSocket: SSLSocket): String? = null
 
   @Throws(IOException::class)
   open fun connectSocket(socket: Socket, address: InetSocketAddress, connectTimeout: Int) {
diff --git a/okhttp/src/main/java/okhttp3/internal/platform/android/AndroidSocketAdapter.kt b/okhttp/src/main/java/okhttp3/internal/platform/android/AndroidSocketAdapter.kt
new file mode 100644
index 0000000000..4ac9e4c0cf
--- /dev/null
+++ b/okhttp/src/main/java/okhttp3/internal/platform/android/AndroidSocketAdapter.kt
@@ -0,0 +1,103 @@
+/*
+ * Copyright (C) 2019 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.internal.platform.android
+
+import okhttp3.Protocol
+import okhttp3.internal.platform.AndroidPlatform
+import okhttp3.internal.platform.Platform
+import java.lang.reflect.InvocationTargetException
+import java.lang.reflect.Method
+import java.nio.charset.StandardCharsets
+import javax.net.ssl.SSLSocket
+import javax.net.ssl.SSLSocketFactory
+import javax.net.ssl.X509TrustManager
+
+/**
+ * Modern reflection based SocketAdapter for Conscrypt class SSLSockets.
+ */
+open class AndroidSocketAdapter(private val sslSocketClass: Class<in SSLSocket>) :
+    SocketAdapter {
+  private val setUseSessionTickets: Method =
+      sslSocketClass.getDeclaredMethod("setUseSessionTickets", Boolean::class.javaPrimitiveType)
+  private val setHostname = sslSocketClass.getMethod("setHostname", String::class.java)
+  private val getAlpnSelectedProtocol = sslSocketClass.getMethod("getAlpnSelectedProtocol")
+  private val setAlpnProtocols =
+      sslSocketClass.getMethod("setAlpnProtocols", ByteArray::class.java)
+
+  override fun isSupported(): Boolean = AndroidPlatform.isSupported
+
+  override fun trustManager(sslSocketFactory: SSLSocketFactory): X509TrustManager? = null
+
+  override fun matchesSocket(sslSocket: SSLSocket): Boolean = sslSocketClass.isInstance(sslSocket)
+
+  override fun matchesSocketFactory(sslSocketFactory: SSLSocketFactory): Boolean = false
+
+  override fun configureTlsExtensions(
+    sslSocket: SSLSocket,
+    hostname: String?,
+    protocols: List<Protocol>
+  ) {
+    // No TLS extensions if the socket class is custom.
+    if (matchesSocket(sslSocket)) {
+      try {
+        // Enable SNI and session tickets.
+        if (hostname != null) {
+          setUseSessionTickets.invoke(sslSocket, true)
+          // This is SSLParameters.setServerNames() in API 24+.
+          setHostname.invoke(sslSocket, hostname)
+        }
+
+        // Enable ALPN.
+        setAlpnProtocols.invoke(sslSocket,
+            Platform.concatLengthPrefixed(protocols))
+      } catch (e: IllegalAccessException) {
+        throw AssertionError(e)
+      } catch (e: InvocationTargetException) {
+        throw AssertionError(e)
+      }
+    }
+  }
+
+  override fun getSelectedProtocol(sslSocket: SSLSocket): String? {
+    // No TLS extensions if the socket class is custom.
+    if (!matchesSocket(sslSocket)) {
+      return null
+    }
+
+    return try {
+      val alpnResult = getAlpnSelectedProtocol.invoke(sslSocket) as ByteArray?
+      if (alpnResult != null) String(alpnResult, StandardCharsets.UTF_8) else null
+    } catch (e: IllegalAccessException) {
+      throw AssertionError(e)
+    } catch (e: InvocationTargetException) {
+      throw AssertionError(e)
+    }
+  }
+
+  companion object {
+    fun buildIfSupported(packageName: String): SocketAdapter? {
+      return try {
+        @Suppress("UNCHECKED_CAST")
+        val sslSocketClass = Class.forName("$packageName.OpenSSLSocketImpl") as Class<in SSLSocket>
+
+        AndroidSocketAdapter(sslSocketClass)
+      } catch (e: Exception) {
+        androidLog(Platform.WARN, "unable to load android socket classes", e)
+        null
+      }
+    }
+  }
+}
diff --git a/okhttp/src/main/java/okhttp3/internal/platform/android/CloseGuard.kt b/okhttp/src/main/java/okhttp3/internal/platform/android/CloseGuard.kt
new file mode 100644
index 0000000000..b3930aafd7
--- /dev/null
+++ b/okhttp/src/main/java/okhttp3/internal/platform/android/CloseGuard.kt
@@ -0,0 +1,75 @@
+/*
+ * Copyright (C) 2019 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.internal.platform.android
+
+import java.lang.reflect.Method
+
+/**
+ * Provides access to the internal dalvik.system.CloseGuard class. Android uses this in
+ * combination with android.os.StrictMode to report on leaked java.io.Closeable's. Available since
+ * Android API 11.
+ */
+internal class CloseGuard(
+  private val getMethod: Method?,
+  private val openMethod: Method?,
+  private val warnIfOpenMethod: Method?
+) {
+
+  fun createAndOpen(closer: String): Any? {
+    if (getMethod != null) {
+      try {
+        val closeGuardInstance = getMethod.invoke(null)
+        openMethod!!.invoke(closeGuardInstance, closer)
+        return closeGuardInstance
+      } catch (_: Exception) {
+      }
+    }
+    return null
+  }
+
+  fun warnIfOpen(closeGuardInstance: Any?): Boolean {
+    var reported = false
+    if (closeGuardInstance != null) {
+      try {
+        warnIfOpenMethod!!.invoke(closeGuardInstance)
+        reported = true
+      } catch (_: Exception) {
+      }
+    }
+    return reported
+  }
+
+  companion object {
+    fun get(): CloseGuard {
+      var getMethod: Method?
+      var openMethod: Method?
+      var warnIfOpenMethod: Method?
+
+      try {
+        val closeGuardClass = Class.forName("dalvik.system.CloseGuard")
+        getMethod = closeGuardClass.getMethod("get")
+        openMethod = closeGuardClass.getMethod("open", String::class.java)
+        warnIfOpenMethod = closeGuardClass.getMethod("warnIfOpen")
+      } catch (_: Exception) {
+        getMethod = null
+        openMethod = null
+        warnIfOpenMethod = null
+      }
+
+      return CloseGuard(getMethod, openMethod, warnIfOpenMethod)
+    }
+  }
+}
diff --git a/okhttp/src/main/java/okhttp3/internal/platform/android/ConscryptSocketAdapter.kt b/okhttp/src/main/java/okhttp3/internal/platform/android/ConscryptSocketAdapter.kt
new file mode 100644
index 0000000000..11f574b544
--- /dev/null
+++ b/okhttp/src/main/java/okhttp3/internal/platform/android/ConscryptSocketAdapter.kt
@@ -0,0 +1,65 @@
+/*
+ * Copyright (C) 2019 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.internal.platform.android
+
+import okhttp3.Protocol
+import okhttp3.internal.platform.ConscryptPlatform
+import okhttp3.internal.platform.Platform
+import org.conscrypt.Conscrypt
+import javax.net.ssl.SSLSocket
+import javax.net.ssl.SSLSocketFactory
+import javax.net.ssl.X509TrustManager
+
+/**
+ * Simple non-reflection SocketAdapter for Conscrypt.
+ */
+object ConscryptSocketAdapter : SocketAdapter {
+  override fun trustManager(sslSocketFactory: SSLSocketFactory): X509TrustManager? = null
+
+  override fun matchesSocketFactory(sslSocketFactory: SSLSocketFactory): Boolean = false
+
+  override fun matchesSocket(sslSocket: SSLSocket): Boolean = Conscrypt.isConscrypt(sslSocket)
+
+  override fun isSupported(): Boolean = ConscryptPlatform.isSupported
+
+  override fun getSelectedProtocol(sslSocket: SSLSocket): String? =
+      when {
+        matchesSocket(sslSocket) -> Conscrypt.getApplicationProtocol(sslSocket)
+        else -> null // No TLS extensions if the socket class is custom.
+      }
+
+  override fun configureTlsExtensions(
+    sslSocket: SSLSocket,
+    hostname: String?,
+    protocols: List<Protocol>
+  ) {
+    // No TLS extensions if the socket class is custom.
+    if (matchesSocket(sslSocket)) {
+      // Enable SNI and session tickets.
+      if (hostname != null) {
+        Conscrypt.setUseSessionTickets(sslSocket, true)
+        Conscrypt.setHostname(sslSocket, hostname)
+      }
+
+      // Enable ALPN.
+      val names = Platform.alpnProtocolNames(protocols)
+      Conscrypt.setApplicationProtocols(sslSocket, names.toTypedArray())
+    }
+  }
+
+  fun buildIfSupported(): SocketAdapter? =
+      if (ConscryptPlatform.isSupported) ConscryptSocketAdapter else null
+}
diff --git a/okhttp/src/main/java/okhttp3/internal/platform/android/DeferredSocketAdapter.kt b/okhttp/src/main/java/okhttp3/internal/platform/android/DeferredSocketAdapter.kt
new file mode 100644
index 0000000000..87d1277f2e
--- /dev/null
+++ b/okhttp/src/main/java/okhttp3/internal/platform/android/DeferredSocketAdapter.kt
@@ -0,0 +1,85 @@
+/*
+ * Copyright (C) 2019 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.internal.platform.android
+
+import okhttp3.Protocol
+import okhttp3.internal.platform.Platform
+import javax.net.ssl.SSLSocket
+import javax.net.ssl.SSLSocketFactory
+import javax.net.ssl.X509TrustManager
+
+/**
+ * Deferred implementation of SocketAdapter that can only work by observing the socket
+ * and initializing on first use.
+ */
+class DeferredSocketAdapter(private val socketPackage: String) : SocketAdapter {
+  private var initialized = false
+  private var delegate: SocketAdapter? = null
+
+  override fun isSupported(): Boolean {
+    return true
+  }
+
+  override fun matchesSocket(sslSocket: SSLSocket): Boolean {
+    return sslSocket.javaClass.name.startsWith(socketPackage)
+  }
+
+  override fun configureTlsExtensions(
+    sslSocket: SSLSocket,
+    hostname: String?,
+    protocols: List<Protocol>
+  ) {
+    getDelegate(sslSocket)?.configureTlsExtensions(sslSocket, hostname, protocols)
+  }
+
+  override fun getSelectedProtocol(sslSocket: SSLSocket): String? {
+    return getDelegate(sslSocket)?.getSelectedProtocol(sslSocket)
+  }
+
+  @Synchronized private fun getDelegate(actualSSLSocketClass: SSLSocket): SocketAdapter? {
+    if (!initialized) {
+      try {
+        var possibleClass: Class<in SSLSocket> = actualSSLSocketClass.javaClass
+        while (possibleClass.name != "$socketPackage.OpenSSLSocketImpl") {
+          possibleClass = possibleClass.superclass
+
+          if (possibleClass == null) {
+            throw AssertionError(
+                "No OpenSSLSocketImpl superclass of socket of type $actualSSLSocketClass")
+          }
+        }
+
+        delegate = AndroidSocketAdapter(possibleClass)
+      } catch (e: Exception) {
+        Platform.get()
+            .log(Platform.WARN, "Failed to initialize DeferredSocketAdapter $socketPackage", e)
+      }
+
+      initialized = true
+    }
+
+    return delegate
+  }
+
+  override fun trustManager(sslSocketFactory: SSLSocketFactory): X509TrustManager? {
+    // not supported with modern Android and opt-in Gms Provider
+    return null
+  }
+
+  override fun matchesSocketFactory(sslSocketFactory: SSLSocketFactory): Boolean {
+    return false
+  }
+}
diff --git a/okhttp/src/main/java/okhttp3/internal/platform/android/SocketAdapter.kt b/okhttp/src/main/java/okhttp3/internal/platform/android/SocketAdapter.kt
new file mode 100644
index 0000000000..5555f1c695
--- /dev/null
+++ b/okhttp/src/main/java/okhttp3/internal/platform/android/SocketAdapter.kt
@@ -0,0 +1,36 @@
+/*
+ * Copyright (C) 2019 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.internal.platform.android
+
+import okhttp3.Protocol
+import javax.net.ssl.SSLSocket
+import javax.net.ssl.SSLSocketFactory
+import javax.net.ssl.X509TrustManager
+
+interface SocketAdapter {
+  open fun isSupported(): Boolean
+  fun trustManager(sslSocketFactory: SSLSocketFactory): X509TrustManager?
+  fun matchesSocket(sslSocket: SSLSocket): Boolean
+  fun matchesSocketFactory(sslSocketFactory: SSLSocketFactory): Boolean
+
+  open fun configureTlsExtensions(
+    sslSocket: SSLSocket,
+    hostname: String?,
+    protocols: List<Protocol>
+  )
+
+  open fun getSelectedProtocol(sslSocket: SSLSocket): String?
+}
diff --git a/okhttp/src/main/java/okhttp3/internal/platform/android/StandardAndroidSocketAdapter.kt b/okhttp/src/main/java/okhttp3/internal/platform/android/StandardAndroidSocketAdapter.kt
new file mode 100644
index 0000000000..bb66604ff4
--- /dev/null
+++ b/okhttp/src/main/java/okhttp3/internal/platform/android/StandardAndroidSocketAdapter.kt
@@ -0,0 +1,63 @@
+/*
+ * Copyright (C) 2019 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.internal.platform.android
+
+import okhttp3.internal.platform.Platform
+import javax.net.ssl.SSLSocket
+import javax.net.ssl.SSLSocketFactory
+import javax.net.ssl.X509TrustManager
+
+/**
+ * Base Android reflection based SocketAdapter for the built in Android SSLSocket.
+ */
+class StandardAndroidSocketAdapter(
+  sslSocketClass: Class<in SSLSocket>,
+  private val sslSocketFactoryClass: Class<in SSLSocketFactory>,
+  private val paramClass: Class<*>
+) : AndroidSocketAdapter(
+    sslSocketClass) {
+
+  override fun matchesSocketFactory(sslSocketFactory: SSLSocketFactory): Boolean =
+      sslSocketFactoryClass.isInstance(sslSocketFactory)
+
+  override fun trustManager(sslSocketFactory: SSLSocketFactory): X509TrustManager? {
+    val context: Any? =
+        Platform.readFieldOrNull(sslSocketFactory, paramClass,
+            "sslParameters")
+    val x509TrustManager = Platform.readFieldOrNull(
+        context!!, X509TrustManager::class.java, "x509TrustManager")
+    return x509TrustManager ?: Platform.readFieldOrNull(context,
+        X509TrustManager::class.java,
+        "trustManager")
+  }
+
+  companion object {
+    @Suppress("UNCHECKED_CAST")
+    fun buildIfSupported(packageName: String = "com.android.org.conscrypt"): SocketAdapter? {
+      return try {
+        val sslSocketClass = Class.forName("$packageName.OpenSSLSocketImpl") as Class<in SSLSocket>
+        val sslSocketFactoryClass =
+            Class.forName("$packageName.OpenSSLSocketFactoryImpl") as Class<in SSLSocketFactory>
+        val paramsClass = Class.forName("$packageName.SSLParametersImpl")
+
+        StandardAndroidSocketAdapter(sslSocketClass, sslSocketFactoryClass, paramsClass)
+      } catch (e: Exception) {
+        androidLog(Platform.WARN, "unable to load android socket classes", e)
+        null
+      }
+    }
+  }
+}
diff --git a/okhttp/src/main/java/okhttp3/internal/platform/android/util.kt b/okhttp/src/main/java/okhttp3/internal/platform/android/util.kt
new file mode 100644
index 0000000000..4a3bf12e42
--- /dev/null
+++ b/okhttp/src/main/java/okhttp3/internal/platform/android/util.kt
@@ -0,0 +1,41 @@
+/*
+ * Copyright (C) 2019 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.internal.platform.android
+
+import android.util.Log
+import okhttp3.internal.platform.Platform
+
+private const val MAX_LOG_LENGTH = 4000
+
+internal fun androidLog(level: Int, message: String, t: Throwable?) {
+  var logMessage = message
+  val logLevel = if (level == Platform.WARN) Log.WARN else Log.DEBUG
+  if (t != null) logMessage = logMessage + '\n'.toString() + Log.getStackTraceString(t)
+
+  // Split by line, then ensure each line can fit into Log's maximum length.
+  var i = 0
+  val length = logMessage.length
+  while (i < length) {
+    var newline = logMessage.indexOf('\n', i)
+    newline = if (newline != -1) newline else length
+    do {
+      val end = minOf(newline, i + MAX_LOG_LENGTH)
+      Log.println(logLevel, "OkHttp", logMessage.substring(i, end))
+      i = end
+    } while (i < newline)
+    i++
+  }
+}
\ No newline at end of file
diff --git a/okhttp/src/test/java/okhttp3/internal/platform/android/AndroidSocketAdapterTest.kt b/okhttp/src/test/java/okhttp3/internal/platform/android/AndroidSocketAdapterTest.kt
new file mode 100644
index 0000000000..d9d6017336
--- /dev/null
+++ b/okhttp/src/test/java/okhttp3/internal/platform/android/AndroidSocketAdapterTest.kt
@@ -0,0 +1,100 @@
+/*
+ * Copyright (C) 2019 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.internal.platform.android
+
+import okhttp3.DelegatingSSLSocket
+import okhttp3.DelegatingSSLSocketFactory
+import okhttp3.Protocol.HTTP_1_1
+import okhttp3.Protocol.HTTP_2
+import org.conscrypt.Conscrypt
+import org.junit.Assert.assertFalse
+import org.junit.Assert.assertNotNull
+import org.junit.Assert.assertNull
+import org.junit.Assert.assertTrue
+import org.junit.Assume.assumeFalse
+import org.junit.Assume.assumeTrue
+import org.junit.Test
+import org.junit.runner.RunWith
+import org.junit.runners.Parameterized
+import java.security.Provider
+import javax.net.ssl.SSLContext
+import javax.net.ssl.SSLSocket
+
+@RunWith(Parameterized::class)
+class AndroidSocketAdapterTest(private val adapter: SocketAdapter) {
+  private val provider: Provider = Conscrypt.newProviderBuilder().provideTrustManager(true).build()
+  val context: SSLContext = SSLContext.getInstance("TLS", provider)
+
+  init {
+    context.init(null, null, null)
+  }
+
+  @Test
+  fun testMatchesSupportedSocket() {
+    val socketFactory = context.socketFactory
+
+    val sslSocket = socketFactory.createSocket() as SSLSocket
+    assertTrue(adapter.matchesSocket(sslSocket))
+
+    adapter.configureTlsExtensions(sslSocket, "example.com", listOf(HTTP_2, HTTP_1_1))
+    // not connected
+    assertNull(adapter.getSelectedProtocol(sslSocket))
+  }
+
+  @Test
+  fun testMatchesSupportedAndroidSocketFactory() {
+    assumeTrue(adapter is StandardAndroidSocketAdapter)
+
+    assertTrue(adapter.matchesSocketFactory(context.socketFactory))
+    assertNotNull(adapter.trustManager(context.socketFactory))
+  }
+
+  @Test
+  fun testDoesntMatchSupportedCustomSocketFactory() {
+    assumeFalse(adapter is StandardAndroidSocketAdapter)
+
+    assertFalse(adapter.matchesSocketFactory(context.socketFactory))
+    assertNull(adapter.trustManager(context.socketFactory))
+  }
+
+  @Test
+  fun testCustomSocket() {
+    val socketFactory = DelegatingSSLSocketFactory(context.socketFactory)
+
+    assertFalse(adapter.matchesSocketFactory(socketFactory))
+
+    val sslSocket =
+        object : DelegatingSSLSocket(context.socketFactory.createSocket() as SSLSocket) {}
+    assertFalse(adapter.matchesSocket(sslSocket))
+
+    adapter.configureTlsExtensions(sslSocket, "example.com", listOf(HTTP_2, HTTP_1_1))
+    // not connected
+    assertNull(adapter.getSelectedProtocol(sslSocket))
+  }
+
+  companion object {
+    @JvmStatic
+    @Parameterized.Parameters(name = "{0}")
+    fun data(): Collection<SocketAdapter> {
+      return listOf(
+          ConscryptSocketAdapter,
+          DeferredSocketAdapter("org.conscrypt"),
+          AndroidSocketAdapter.buildIfSupported("org.conscrypt")!!,
+          StandardAndroidSocketAdapter.buildIfSupported("org.conscrypt")!!
+      )
+    }
+  }
+}
