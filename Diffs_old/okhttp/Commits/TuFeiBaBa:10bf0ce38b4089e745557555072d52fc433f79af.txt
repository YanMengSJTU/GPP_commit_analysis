diff --git a/okhttp-tests/src/test/java/okhttp3/CacheTest.java b/okhttp-tests/src/test/java/okhttp3/CacheTest.java
index 325004e659..066410e02a 100644
--- a/okhttp-tests/src/test/java/okhttp3/CacheTest.java
+++ b/okhttp-tests/src/test/java/okhttp3/CacheTest.java
@@ -1122,6 +1122,8 @@ private void assertNonIdentityEncodingCached(MockResponse response) throws Excep
     server.enqueue(new MockResponse()
         .setBody(gzip("ABCABCABC"))
         .addHeader("Content-Encoding: gzip")
+        //告诉代理服务器缓存两种版本的资源：压缩和非压缩，这有助于
+        //避免一些公共代理不能正确地检测Content-Encoding标头的问题。
         .addHeader("Vary: Accept-Encoding")
         .addHeader("Cache-Control: max-age=60"));
     server.enqueue(new MockResponse()
@@ -1145,6 +1147,7 @@ private void assertNonIdentityEncodingCached(MockResponse response) throws Excep
 
     assertEquals("A", get(server.url("/")).body().string());
     assertEquals("A", get(server.url("/")).body().string());
+    assertEquals(2, cache.networkCount());
     assertEquals(1, client.connectionPool().idleConnectionCount());
   }
 
@@ -1176,8 +1179,10 @@ private void assertNonIdentityEncodingCached(MockResponse response) throws Excep
   @Test public void requestMinFresh() throws IOException {
     server.enqueue(new MockResponse()
         .setBody("A")
+        //如果max-age的值大于下面的min-fresh的值，返回的还是缓存里的值
         .addHeader("Cache-Control: max-age=60")
-        .addHeader("Date: " + formatDate(0, TimeUnit.MINUTES)));
+        //有没有这句，都不影响测试结果
+        .addHeader("Date: " + formatDate(1, TimeUnit.MINUTES)));
     server.enqueue(new MockResponse()
         .setBody("B"));
 
@@ -1185,6 +1190,7 @@ private void assertNonIdentityEncodingCached(MockResponse response) throws Excep
 
     Request request = new Request.Builder()
         .url(server.url("/"))
+        //告知（代理）服务器，客户端希望接收一个在小于xx秒内被更新过的资源
         .header("Cache-Control", "min-fresh=120")
         .build();
     Response response = client.newCall(request).execute();
@@ -1195,6 +1201,7 @@ private void assertNonIdentityEncodingCached(MockResponse response) throws Excep
     server.enqueue(new MockResponse()
         .setBody("A")
         .addHeader("Cache-Control: max-age=120")
+        //如果大于等于-5，测试失败。不再是获取到缓存中的“A”,而是重新请求获得的“B”
         .addHeader("Date: " + formatDate(-4, TimeUnit.MINUTES)));
     server.enqueue(new MockResponse()
         .setBody("B"));
@@ -1203,6 +1210,9 @@ private void assertNonIdentityEncodingCached(MockResponse response) throws Excep
 
     Request request = new Request.Builder()
         .url(server.url("/"))
+        //max-stale = delta-seconds
+        //告知（代理）服务器，客户端愿意接收一个超过缓存时间的资源，
+        //若有定义delta-seconds，则为delta-seconds秒，没有则为任意超出的时间
         .header("Cache-Control", "max-stale=180")
         .build();
     Response response = client.newCall(request).execute();
@@ -1224,6 +1234,7 @@ private void assertNonIdentityEncodingCached(MockResponse response) throws Excep
     // With max-stale, we'll return that stale response.
     Request request = new Request.Builder()
         .url(server.url("/"))
+        //没有设置超出时间。客服端读取的永远是缓存里的响应，即使它过时很久很久了。
         .header("Cache-Control", "max-stale")
         .build();
     Response response = client.newCall(request).execute();
@@ -1234,6 +1245,8 @@ private void assertNonIdentityEncodingCached(MockResponse response) throws Excep
   @Test public void requestMaxStaleNotHonoredWithMustRevalidate() throws IOException {
     server.enqueue(new MockResponse()
         .setBody("A")
+        //缓存有效期为120秒，如果缓存有效期过期了，必须去原始服务器重新验证请求
+        //这时候，设置的max-stale不起作用
         .addHeader("Cache-Control: max-age=120, must-revalidate")
         .addHeader("Date: " + formatDate(-4, TimeUnit.MINUTES)));
     server.enqueue(new MockResponse()
@@ -1254,6 +1267,7 @@ private void assertNonIdentityEncodingCached(MockResponse response) throws Excep
 
     Request request = new Request.Builder()
         .url(server.url("/"))
+        //表示不进行与网络相关的交互，只返回已经缓存且满足要求的数据，否则的话返回 504 错误。
         .header("Cache-Control", "only-if-cached")
         .build();
     Response response = client.newCall(request).execute();
@@ -1465,13 +1479,17 @@ private RecordedRequest assertClientSuppliedCondition(MockResponse seed, String
   @Test public void contentLocationDoesNotPopulateCache() throws Exception {
     server.enqueue(new MockResponse()
         .addHeader("Cache-Control: max-age=60")
+        //Location和Content-Location是不同的：Location表明重定向的目标（302），
+        //而Content-Location表明无需进行进一步的内容协商就可以直接访问的资源的URL
         .addHeader("Content-Location: /bar")
         .setBody("A"));
     server.enqueue(new MockResponse()
         .setBody("B"));
 
     assertEquals("A", get(server.url("/foo")).body().string());
+    //这时候，直接请求/bar并不会触发缓存。请求结果也不会覆盖/foo的缓存。
     assertEquals("B", get(server.url("/bar")).body().string());
+    assertEquals("A", get(server.url("/foo")).body().string());
   }
 
   @Test public void connectionIsReturnedToPoolAfterConditionalSuccess() throws Exception {
@@ -1954,6 +1972,8 @@ private RecordedRequest assertClientSuppliedCondition(MockResponse seed, String
     Response response3 = get(server.url("/a"));
     assertEquals("A", response3.body().string());
     assertEquals("GET, HEAD", response3.header("Allow"));
+    //receivedResponseAtMillis()，获取到的时间，是从网络里获取到该请求结果的时间。
+    //而不是从缓存里获取到结果的时间。
     assertEquals(0, response3.receivedResponseAtMillis() - t1, 250.0);
 
     assertEquals(2, server.getRequestCount());
@@ -1997,8 +2017,8 @@ private RecordedRequest assertClientSuppliedCondition(MockResponse seed, String
         .setResponseCode(304));
 
     assertEquals("A", get(server.url("/")).body().string());
-    Response response = get(server.url("/"));
-    assertEquals("A", response.body().string());
+    assertEquals("A", get(server.url("/")).body().string());
+    assertEquals(2, server.getRequestCount());
   }
 
   @Test public void responseSourceHeaderFetched() throws IOException {
@@ -2532,7 +2552,8 @@ private RecordedRequest assertConditionallyCached(MockResponse response) throws
     Response response2 = get(valid);
     assertEquals("A", response2.body().string());
     //为什么返回的响应码不是304？
-    //应该是碰到了304响应，然后就去请求本地的缓存代理服务器，最后返回了200。
+    //应该是碰到了304响应，然后就去请求本地的缓存代理服务器，
+    //如果命中了缓存，最后会返回200。如果没有命中，最后依然会返回304。
     assertEquals(HttpURLConnection.HTTP_OK, response2.code());
     assertEquals("A-OK", response2.message());
 
