diff --git a/okhttp/src/main/java/okhttp3/Cache.java b/okhttp/src/main/java/okhttp3/Cache.java
index 343df45113..690f7b25ab 100644
--- a/okhttp/src/main/java/okhttp3/Cache.java
+++ b/okhttp/src/main/java/okhttp3/Cache.java
@@ -28,7 +28,9 @@
 import java.util.Iterator;
 import java.util.List;
 import java.util.NoSuchElementException;
+
 import javax.annotation.Nullable;
+
 import okhttp3.internal.Util;
 import okhttp3.internal.cache.CacheRequest;
 import okhttp3.internal.cache.CacheStrategy;
@@ -52,44 +54,44 @@
 /**
  * Caches HTTP and HTTPS responses to the filesystem so they may be reused, saving time and
  * bandwidth.
- *
+ * <p>
  * <h3>Cache Optimization</h3>
- *
+ * <p>
  * <p>To measure cache effectiveness, this class tracks three statistics:
  * <ul>
- *     <li><strong>{@linkplain #requestCount() Request Count:}</strong> the number of HTTP
- *         requests issued since this cache was created.
- *     <li><strong>{@linkplain #networkCount() Network Count:}</strong> the number of those
- *         requests that required network use.
- *     <li><strong>{@linkplain #hitCount() Hit Count:}</strong> the number of those requests
- *         whose responses were served by the cache.
+ * <li><strong>{@linkplain #requestCount() Request Count:}</strong> the number of HTTP
+ * requests issued since this cache was created.
+ * <li><strong>{@linkplain #networkCount() Network Count:}</strong> the number of those
+ * requests that required network use.
+ * <li><strong>{@linkplain #hitCount() Hit Count:}</strong> the number of those requests
+ * whose responses were served by the cache.
  * </ul>
- *
+ * <p>
  * Sometimes a request will result in a conditional cache hit. If the cache contains a stale copy of
  * the response, the client will issue a conditional {@code GET}. The server will then send either
  * the updated response if it has changed, or a short 'not modified' response if the client's copy
  * is still valid. Such responses increment both the network count and hit count.
- *
+ * <p>
  * <p>The best way to improve the cache hit rate is by configuring the web server to return
  * cacheable responses. Although this client honors all <a
  * href="http://tools.ietf.org/html/rfc7234">HTTP/1.1 (RFC 7234)</a> cache headers, it doesn't cache
  * partial responses.
- *
+ * <p>
  * <h3>Force a Network Response</h3>
- *
+ * <p>
  * <p>In some situations, such as after a user clicks a 'refresh' button, it may be necessary to
  * skip the cache, and fetch data directly from the server. To force a full refresh, add the {@code
  * no-cache} directive: <pre>   {@code
- *
+ * <p>
  *   Request request = new Request.Builder()
  *       .cacheControl(new CacheControl.Builder().noCache().build())
  *       .url("http://publicobject.com/helloworld.txt")
  *       .build();
  * }</pre>
- *
+ * <p>
  * If it is only necessary to force a cached response to be validated by the server, use the more
  * efficient {@code max-age=0} directive instead: <pre>   {@code
- *
+ * <p>
  *   Request request = new Request.Builder()
  *       .cacheControl(new CacheControl.Builder()
  *           .maxAge(0, TimeUnit.SECONDS)
@@ -97,14 +99,14 @@
  *       .url("http://publicobject.com/helloworld.txt")
  *       .build();
  * }</pre>
- *
+ * <p>
  * <h3>Force a Cache Response</h3>
- *
+ * <p>
  * <p>Sometimes you'll want to show resources if they are available immediately, but not otherwise.
  * This can be used so your application can show <i>something</i> while waiting for the latest data
  * to be downloaded. To restrict a request to locally-cached resources, add the {@code
  * only-if-cached} directive: <pre>   {@code
- *
+ * <p>
  *     Request request = new Request.Builder()
  *         .cacheControl(new CacheControl.Builder()
  *             .onlyIfCached()
@@ -121,7 +123,7 @@
  * This technique works even better in situations where a stale response is better than no response.
  * To permit stale cached responses, use the {@code max-stale} directive with the maximum staleness
  * in seconds: <pre>   {@code
- *
+ * <p>
  *   Request request = new Request.Builder()
  *       .cacheControl(new CacheControl.Builder()
  *           .maxStale(365, TimeUnit.DAYS)
@@ -129,646 +131,690 @@
  *       .url("http://publicobject.com/helloworld.txt")
  *       .build();
  * }</pre>
- *
+ * <p>
  * <p>The {@link CacheControl} class can configure request caching directives and parse response
  * caching directives. It even offers convenient constants {@link CacheControl#FORCE_NETWORK} and
  * {@link CacheControl#FORCE_CACHE} that address the use cases above.
  */
 public final class Cache implements Closeable, Flushable {
-  private static final int VERSION = 201105;
-  private static final int ENTRY_METADATA = 0;
-  private static final int ENTRY_BODY = 1;
-  private static final int ENTRY_COUNT = 2;
-
-  final InternalCache internalCache = new InternalCache() {
-    @Override public Response get(Request request) throws IOException {
-      return Cache.this.get(request);
-    }
+    private static final int VERSION = 201105;
+    private static final int ENTRY_METADATA = 0;
+    private static final int ENTRY_BODY = 1;
+    private static final int ENTRY_COUNT = 2;
+
+    final InternalCache internalCache = new InternalCache() {
+        @Override
+        public Response get(Request request) throws IOException {
+            return Cache.this.get(request);
+        }
 
-    @Override public CacheRequest put(Response response) throws IOException {
-      return Cache.this.put(response);
-    }
+        @Override
+        public CacheRequest put(Response response) throws IOException {
+            return Cache.this.put(response);
+        }
 
-    @Override public void remove(Request request) throws IOException {
-      Cache.this.remove(request);
-    }
+        @Override
+        public void remove(Request request) throws IOException {
+            Cache.this.remove(request);
+        }
 
-    @Override public void update(Response cached, Response network) {
-      Cache.this.update(cached, network);
-    }
+        @Override
+        public void update(Response cached, Response network) {
+            Cache.this.update(cached, network);
+        }
 
-    @Override public void trackConditionalCacheHit() {
-      Cache.this.trackConditionalCacheHit();
-    }
+        @Override
+        public void trackConditionalCacheHit() {
+            Cache.this.trackConditionalCacheHit();
+        }
+
+        @Override
+        public void trackResponse(CacheStrategy cacheStrategy) {
+            Cache.this.trackResponse(cacheStrategy);
+        }
+    };
+
+    final DiskLruCache cache;
+
+    /* read and write statistics, all guarded by 'this' */
+    int writeSuccessCount;
+    int writeAbortCount;
+    private int networkCount;
+    private int hitCount;
+    private int requestCount;
 
-    @Override public void trackResponse(CacheStrategy cacheStrategy) {
-      Cache.this.trackResponse(cacheStrategy);
+    /**
+     * Create a cache of at most {@code maxSize} bytes in {@code directory}.
+     */
+    public Cache(File directory, long maxSize) {
+        this(directory, maxSize, FileSystem.SYSTEM);
     }
-  };
-
-  final DiskLruCache cache;
-
-  /* read and write statistics, all guarded by 'this' */
-  int writeSuccessCount;
-  int writeAbortCount;
-  private int networkCount;
-  private int hitCount;
-  private int requestCount;
-
-  /**
-   * Create a cache of at most {@code maxSize} bytes in {@code directory}.
-   */
-  public Cache(File directory, long maxSize) {
-    this(directory, maxSize, FileSystem.SYSTEM);
-  }
-
-  Cache(File directory, long maxSize, FileSystem fileSystem) {
-    this.cache = DiskLruCache.create(fileSystem, directory, VERSION, ENTRY_COUNT, maxSize);
-  }
-
-  public static String key(HttpUrl url) {
-    return ByteString.encodeUtf8(url.toString()).md5().hex();
-  }
-
-  @Nullable Response get(Request request) {
-    String key = key(request.url());
-    DiskLruCache.Snapshot snapshot;
-    Entry entry;
-    try {
-      snapshot = cache.get(key);
-      if (snapshot == null) {
-        return null;
-      }
-    } catch (IOException e) {
-      // Give up because the cache cannot be read.
-      return null;
+
+    Cache(File directory, long maxSize, FileSystem fileSystem) {
+        this.cache = DiskLruCache.create(fileSystem, directory, VERSION, ENTRY_COUNT, maxSize);
     }
 
-    try {
-      entry = new Entry(snapshot.getSource(ENTRY_METADATA));
-    } catch (IOException e) {
-      Util.closeQuietly(snapshot);
-      return null;
+    public static String key(HttpUrl url) {
+        return ByteString.encodeUtf8(url.toString()).md5().hex();
     }
 
-    Response response = entry.response(snapshot);
+    /**
+     * 从缓存中获取响应Response
+     * @param request
+     * @return
+     */
+    @Nullable
+    Response get(Request request) {
+        // 获取Key值
+        String key = key(request.url());
+
+        // 缓存快照
+        DiskLruCache.Snapshot snapshot;
+        Entry entry;
+        try {
+            snapshot = cache.get(key);
+            if (snapshot == null) {
+                return null;
+            }
+        } catch (IOException e) {
+            // Give up because the cache cannot be read.
+            return null;
+        }
 
-    if (!entry.matches(request, response)) {
-      Util.closeQuietly(response.body());
-      return null;
+        try {
+            entry = new Entry(snapshot.getSource(ENTRY_METADATA));
+        } catch (IOException e) {
+            Util.closeQuietly(snapshot);
+            return null;
+        }
+
+        Response response = entry.response(snapshot);
+
+        if (!entry.matches(request, response)) {
+            Util.closeQuietly(response.body());
+            return null;
+        }
+
+        return response;
     }
 
-    return response;
-  }
+    @Nullable
+    CacheRequest put(Response response) {
+        // 获取Http请求的方法。
+        String requestMethod = response.request().method();
+
+        if (HttpMethod.invalidatesCache(response.request().method())) {
+            try {
+                remove(response.request());
+            } catch (IOException ignored) {
+                // The cache cannot be written.
+            }
+            return null;
+        }
+        // 如果该Http请求的请求 Method不是GET，则直接返回
+        // 也就是 OkHttp中 只缓存GET方法的响应
+        if (!requestMethod.equals("GET")) {
+            // Don't cache non-GET responses. We're technically allowed to cache
+            // HEAD requests and some POST requests, but the complexity of doing
+            // so is high and the benefit is low.
+            return null;
+        }
 
-  @Nullable CacheRequest put(Response response) {
-    String requestMethod = response.request().method();
+        if (HttpHeaders.hasVaryAll(response)) {
+            return null;
+        }
 
-    if (HttpMethod.invalidatesCache(response.request().method())) {
-      try {
-        remove(response.request());
-      } catch (IOException ignored) {
-        // The cache cannot be written.
-      }
-      return null;
+        Entry entry = new Entry(response);
+        // 使用 DiskLru来进行缓存
+        DiskLruCache.Editor editor = null;
+        try {
+            editor = cache.edit(key(response.request().url()));
+            if (editor == null) {
+                return null;
+            }
+            // 真正缓存的方法
+            entry.writeTo(editor);
+            return new CacheRequestImpl(editor);
+        } catch (IOException e) {
+            abortQuietly(editor);
+            return null;
+        }
     }
-    if (!requestMethod.equals("GET")) {
-      // Don't cache non-GET responses. We're technically allowed to cache
-      // HEAD requests and some POST requests, but the complexity of doing
-      // so is high and the benefit is low.
-      return null;
+
+    void remove(Request request) throws IOException {
+        cache.remove(key(request.url()));
     }
 
-    if (HttpHeaders.hasVaryAll(response)) {
-      return null;
+    void update(Response cached, Response network) {
+        Entry entry = new Entry(network);
+        DiskLruCache.Snapshot snapshot = ((CacheResponseBody) cached.body()).snapshot;
+        DiskLruCache.Editor editor = null;
+        try {
+            editor = snapshot.edit(); // Returns null if snapshot is not current.
+            if (editor != null) {
+                entry.writeTo(editor);
+                editor.commit();
+            }
+        } catch (IOException e) {
+            abortQuietly(editor);
+        }
     }
 
-    Entry entry = new Entry(response);
-    DiskLruCache.Editor editor = null;
-    try {
-      editor = cache.edit(key(response.request().url()));
-      if (editor == null) {
-        return null;
-      }
-      entry.writeTo(editor);
-      return new CacheRequestImpl(editor);
-    } catch (IOException e) {
-      abortQuietly(editor);
-      return null;
+    private void abortQuietly(@Nullable DiskLruCache.Editor editor) {
+        // Give up because the cache cannot be written.
+        try {
+            if (editor != null) {
+                editor.abort();
+            }
+        } catch (IOException ignored) {
+        }
     }
-  }
-
-  void remove(Request request) throws IOException {
-    cache.remove(key(request.url()));
-  }
-
-  void update(Response cached, Response network) {
-    Entry entry = new Entry(network);
-    DiskLruCache.Snapshot snapshot = ((CacheResponseBody) cached.body()).snapshot;
-    DiskLruCache.Editor editor = null;
-    try {
-      editor = snapshot.edit(); // Returns null if snapshot is not current.
-      if (editor != null) {
-        entry.writeTo(editor);
-        editor.commit();
-      }
-    } catch (IOException e) {
-      abortQuietly(editor);
+
+    /**
+     * Initialize the cache. This will include reading the journal files from the storage and building
+     * up the necessary in-memory cache information.
+     * <p>
+     * <p>The initialization time may vary depending on the journal file size and the current actual
+     * cache size. The application needs to be aware of calling this function during the
+     * initialization phase and preferably in a background worker thread.
+     * <p>
+     * <p>Note that if the application chooses to not call this method to initialize the cache. By
+     * default, the okhttp will perform lazy initialization upon the first usage of the cache.
+     */
+    public void initialize() throws IOException {
+        cache.initialize();
     }
-  }
-
-  private void abortQuietly(@Nullable DiskLruCache.Editor editor) {
-    // Give up because the cache cannot be written.
-    try {
-      if (editor != null) {
-        editor.abort();
-      }
-    } catch (IOException ignored) {
+
+    /**
+     * Closes the cache and deletes all of its stored values. This will delete all files in the cache
+     * directory including files that weren't created by the cache.
+     */
+    public void delete() throws IOException {
+        cache.delete();
     }
-  }
-
-  /**
-   * Initialize the cache. This will include reading the journal files from the storage and building
-   * up the necessary in-memory cache information.
-   *
-   * <p>The initialization time may vary depending on the journal file size and the current actual
-   * cache size. The application needs to be aware of calling this function during the
-   * initialization phase and preferably in a background worker thread.
-   *
-   * <p>Note that if the application chooses to not call this method to initialize the cache. By
-   * default, the okhttp will perform lazy initialization upon the first usage of the cache.
-   */
-  public void initialize() throws IOException {
-    cache.initialize();
-  }
-
-  /**
-   * Closes the cache and deletes all of its stored values. This will delete all files in the cache
-   * directory including files that weren't created by the cache.
-   */
-  public void delete() throws IOException {
-    cache.delete();
-  }
-
-  /**
-   * Deletes all values stored in the cache. In-flight writes to the cache will complete normally,
-   * but the corresponding responses will not be stored.
-   */
-  public void evictAll() throws IOException {
-    cache.evictAll();
-  }
-
-  /**
-   * Returns an iterator over the URLs in this cache. This iterator doesn't throw {@code
-   * ConcurrentModificationException}, but if new responses are added while iterating, their URLs
-   * will not be returned. If existing responses are evicted during iteration, they will be absent
-   * (unless they were already returned).
-   *
-   * <p>The iterator supports {@linkplain Iterator#remove}. Removing a URL from the iterator evicts
-   * the corresponding response from the cache. Use this to evict selected responses.
-   */
-  public Iterator<String> urls() throws IOException {
-    return new Iterator<String>() {
-      final Iterator<DiskLruCache.Snapshot> delegate = cache.snapshots();
-
-      @Nullable String nextUrl;
-      boolean canRemove;
-
-      @Override public boolean hasNext() {
-        if (nextUrl != null) return true;
-
-        canRemove = false; // Prevent delegate.remove() on the wrong item!
-        while (delegate.hasNext()) {
-          DiskLruCache.Snapshot snapshot = delegate.next();
-          try {
-            BufferedSource metadata = Okio.buffer(snapshot.getSource(ENTRY_METADATA));
-            nextUrl = metadata.readUtf8LineStrict();
-            return true;
-          } catch (IOException ignored) {
-            // We couldn't read the metadata for this snapshot; possibly because the host filesystem
-            // has disappeared! Skip it.
-          } finally {
-            snapshot.close();
-          }
-        }
-
-        return false;
-      }
-
-      @Override public String next() {
-        if (!hasNext()) throw new NoSuchElementException();
-        String result = nextUrl;
-        nextUrl = null;
-        canRemove = true;
-        return result;
-      }
-
-      @Override public void remove() {
-        if (!canRemove) throw new IllegalStateException("remove() before next()");
-        delegate.remove();
-      }
-    };
-  }
-
-  public synchronized int writeAbortCount() {
-    return writeAbortCount;
-  }
-
-  public synchronized int writeSuccessCount() {
-    return writeSuccessCount;
-  }
-
-  public long size() throws IOException {
-    return cache.size();
-  }
-
-  /** Max size of the cache (in bytes). */
-  public long maxSize() {
-    return cache.getMaxSize();
-  }
-
-  @Override public void flush() throws IOException {
-    cache.flush();
-  }
-
-  @Override public void close() throws IOException {
-    cache.close();
-  }
-
-  public File directory() {
-    return cache.getDirectory();
-  }
-
-  public boolean isClosed() {
-    return cache.isClosed();
-  }
-
-  synchronized void trackResponse(CacheStrategy cacheStrategy) {
-    requestCount++;
-
-    if (cacheStrategy.networkRequest != null) {
-      // If this is a conditional request, we'll increment hitCount if/when it hits.
-      networkCount++;
-    } else if (cacheStrategy.cacheResponse != null) {
-      // This response uses the cache and not the network. That's a cache hit.
-      hitCount++;
+
+    /**
+     * Deletes all values stored in the cache. In-flight writes to the cache will complete normally,
+     * but the corresponding responses will not be stored.
+     */
+    public void evictAll() throws IOException {
+        cache.evictAll();
     }
-  }
-
-  synchronized void trackConditionalCacheHit() {
-    hitCount++;
-  }
-
-  public synchronized int networkCount() {
-    return networkCount;
-  }
-
-  public synchronized int hitCount() {
-    return hitCount;
-  }
-
-  public synchronized int requestCount() {
-    return requestCount;
-  }
-
-  private final class CacheRequestImpl implements CacheRequest {
-    private final DiskLruCache.Editor editor;
-    private Sink cacheOut;
-    private Sink body;
-    boolean done;
-
-    CacheRequestImpl(final DiskLruCache.Editor editor) {
-      this.editor = editor;
-      this.cacheOut = editor.newSink(ENTRY_BODY);
-      this.body = new ForwardingSink(cacheOut) {
-        @Override public void close() throws IOException {
-          synchronized (Cache.this) {
-            if (done) {
-              return;
+
+    /**
+     * Returns an iterator over the URLs in this cache. This iterator doesn't throw {@code
+     * ConcurrentModificationException}, but if new responses are added while iterating, their URLs
+     * will not be returned. If existing responses are evicted during iteration, they will be absent
+     * (unless they were already returned).
+     * <p>
+     * <p>The iterator supports {@linkplain Iterator#remove}. Removing a URL from the iterator evicts
+     * the corresponding response from the cache. Use this to evict selected responses.
+     */
+    public Iterator<String> urls() throws IOException {
+        return new Iterator<String>() {
+            final Iterator<DiskLruCache.Snapshot> delegate = cache.snapshots();
+
+            @Nullable
+            String nextUrl;
+            boolean canRemove;
+
+            @Override
+            public boolean hasNext() {
+                if (nextUrl != null) return true;
+
+                canRemove = false; // Prevent delegate.remove() on the wrong item!
+                while (delegate.hasNext()) {
+                    DiskLruCache.Snapshot snapshot = delegate.next();
+                    try {
+                        BufferedSource metadata = Okio.buffer(snapshot.getSource(ENTRY_METADATA));
+                        nextUrl = metadata.readUtf8LineStrict();
+                        return true;
+                    } catch (IOException ignored) {
+                        // We couldn't read the metadata for this snapshot; possibly because the host filesystem
+                        // has disappeared! Skip it.
+                    } finally {
+                        snapshot.close();
+                    }
+                }
+
+                return false;
             }
-            done = true;
-            writeSuccessCount++;
-          }
-          super.close();
-          editor.commit();
-        }
-      };
+
+            @Override
+            public String next() {
+                if (!hasNext()) throw new NoSuchElementException();
+                String result = nextUrl;
+                nextUrl = null;
+                canRemove = true;
+                return result;
+            }
+
+            @Override
+            public void remove() {
+                if (!canRemove) throw new IllegalStateException("remove() before next()");
+                delegate.remove();
+            }
+        };
     }
 
-    @Override public void abort() {
-      synchronized (Cache.this) {
-        if (done) {
-          return;
-        }
-        done = true;
-        writeAbortCount++;
-      }
-      Util.closeQuietly(cacheOut);
-      try {
-        editor.abort();
-      } catch (IOException ignored) {
-      }
+    public synchronized int writeAbortCount() {
+        return writeAbortCount;
     }
 
-    @Override public Sink body() {
-      return body;
+    public synchronized int writeSuccessCount() {
+        return writeSuccessCount;
+    }
+
+    public long size() throws IOException {
+        return cache.size();
     }
-  }
-
-  private static final class Entry {
-    /** Synthetic response header: the local time when the request was sent. */
-    private static final String SENT_MILLIS = Platform.get().getPrefix() + "-Sent-Millis";
-
-    /** Synthetic response header: the local time when the response was received. */
-    private static final String RECEIVED_MILLIS = Platform.get().getPrefix() + "-Received-Millis";
-
-    private final String url;
-    private final Headers varyHeaders;
-    private final String requestMethod;
-    private final Protocol protocol;
-    private final int code;
-    private final String message;
-    private final Headers responseHeaders;
-    private final @Nullable Handshake handshake;
-    private final long sentRequestMillis;
-    private final long receivedResponseMillis;
 
     /**
-     * Reads an entry from an input stream. A typical entry looks like this:
-     * <pre>{@code
-     *   http://google.com/foo
-     *   GET
-     *   2
-     *   Accept-Language: fr-CA
-     *   Accept-Charset: UTF-8
-     *   HTTP/1.1 200 OK
-     *   3
-     *   Content-Type: image/png
-     *   Content-Length: 100
-     *   Cache-Control: max-age=600
-     * }</pre>
-     *
-     * <p>A typical HTTPS file looks like this:
-     * <pre>{@code
-     *   https://google.com/foo
-     *   GET
-     *   2
-     *   Accept-Language: fr-CA
-     *   Accept-Charset: UTF-8
-     *   HTTP/1.1 200 OK
-     *   3
-     *   Content-Type: image/png
-     *   Content-Length: 100
-     *   Cache-Control: max-age=600
-     *
-     *   AES_256_WITH_MD5
-     *   2
-     *   base64-encoded peerCertificate[0]
-     *   base64-encoded peerCertificate[1]
-     *   -1
-     *   TLSv1.2
-     * }</pre>
-     * The file is newline separated. The first two lines are the URL and the request method. Next
-     * is the number of HTTP Vary request header lines, followed by those lines.
-     *
-     * <p>Next is the response status line, followed by the number of HTTP response header lines,
-     * followed by those lines.
-     *
-     * <p>HTTPS responses also contain SSL session information. This begins with a blank line, and
-     * then a line containing the cipher suite. Next is the length of the peer certificate chain.
-     * These certificates are base64-encoded and appear each on their own line. The next line
-     * contains the length of the local certificate chain. These certificates are also
-     * base64-encoded and appear each on their own line. A length of -1 is used to encode a null
-     * array. The last line is optional. If present, it contains the TLS version.
+     * Max size of the cache (in bytes).
      */
-    Entry(Source in) throws IOException {
-      try {
-        BufferedSource source = Okio.buffer(in);
-        url = source.readUtf8LineStrict();
-        requestMethod = source.readUtf8LineStrict();
-        Headers.Builder varyHeadersBuilder = new Headers.Builder();
-        int varyRequestHeaderLineCount = readInt(source);
-        for (int i = 0; i < varyRequestHeaderLineCount; i++) {
-          varyHeadersBuilder.addLenient(source.readUtf8LineStrict());
-        }
-        varyHeaders = varyHeadersBuilder.build();
-
-        StatusLine statusLine = StatusLine.parse(source.readUtf8LineStrict());
-        protocol = statusLine.protocol;
-        code = statusLine.code;
-        message = statusLine.message;
-        Headers.Builder responseHeadersBuilder = new Headers.Builder();
-        int responseHeaderLineCount = readInt(source);
-        for (int i = 0; i < responseHeaderLineCount; i++) {
-          responseHeadersBuilder.addLenient(source.readUtf8LineStrict());
-        }
-        String sendRequestMillisString = responseHeadersBuilder.get(SENT_MILLIS);
-        String receivedResponseMillisString = responseHeadersBuilder.get(RECEIVED_MILLIS);
-        responseHeadersBuilder.removeAll(SENT_MILLIS);
-        responseHeadersBuilder.removeAll(RECEIVED_MILLIS);
-        sentRequestMillis = sendRequestMillisString != null
-            ? Long.parseLong(sendRequestMillisString)
-            : 0L;
-        receivedResponseMillis = receivedResponseMillisString != null
-            ? Long.parseLong(receivedResponseMillisString)
-            : 0L;
-        responseHeaders = responseHeadersBuilder.build();
-
-        if (isHttps()) {
-          String blank = source.readUtf8LineStrict();
-          if (blank.length() > 0) {
-            throw new IOException("expected \"\" but was \"" + blank + "\"");
-          }
-          String cipherSuiteString = source.readUtf8LineStrict();
-          CipherSuite cipherSuite = CipherSuite.forJavaName(cipherSuiteString);
-          List<Certificate> peerCertificates = readCertificateList(source);
-          List<Certificate> localCertificates = readCertificateList(source);
-          TlsVersion tlsVersion = !source.exhausted()
-              ? TlsVersion.forJavaName(source.readUtf8LineStrict())
-              : TlsVersion.SSL_3_0;
-          handshake = Handshake.get(tlsVersion, cipherSuite, peerCertificates, localCertificates);
-        } else {
-          handshake = null;
-        }
-      } finally {
-        in.close();
-      }
+    public long maxSize() {
+        return cache.getMaxSize();
+    }
+
+    @Override
+    public void flush() throws IOException {
+        cache.flush();
     }
 
-    Entry(Response response) {
-      this.url = response.request().url().toString();
-      this.varyHeaders = HttpHeaders.varyHeaders(response);
-      this.requestMethod = response.request().method();
-      this.protocol = response.protocol();
-      this.code = response.code();
-      this.message = response.message();
-      this.responseHeaders = response.headers();
-      this.handshake = response.handshake();
-      this.sentRequestMillis = response.sentRequestAtMillis();
-      this.receivedResponseMillis = response.receivedResponseAtMillis();
+    @Override
+    public void close() throws IOException {
+        cache.close();
     }
 
-    public void writeTo(DiskLruCache.Editor editor) throws IOException {
-      BufferedSink sink = Okio.buffer(editor.newSink(ENTRY_METADATA));
-
-      sink.writeUtf8(url)
-          .writeByte('\n');
-      sink.writeUtf8(requestMethod)
-          .writeByte('\n');
-      sink.writeDecimalLong(varyHeaders.size())
-          .writeByte('\n');
-      for (int i = 0, size = varyHeaders.size(); i < size; i++) {
-        sink.writeUtf8(varyHeaders.name(i))
-            .writeUtf8(": ")
-            .writeUtf8(varyHeaders.value(i))
-            .writeByte('\n');
-      }
-
-      sink.writeUtf8(new StatusLine(protocol, code, message).toString())
-          .writeByte('\n');
-      sink.writeDecimalLong(responseHeaders.size() + 2)
-          .writeByte('\n');
-      for (int i = 0, size = responseHeaders.size(); i < size; i++) {
-        sink.writeUtf8(responseHeaders.name(i))
-            .writeUtf8(": ")
-            .writeUtf8(responseHeaders.value(i))
-            .writeByte('\n');
-      }
-      sink.writeUtf8(SENT_MILLIS)
-          .writeUtf8(": ")
-          .writeDecimalLong(sentRequestMillis)
-          .writeByte('\n');
-      sink.writeUtf8(RECEIVED_MILLIS)
-          .writeUtf8(": ")
-          .writeDecimalLong(receivedResponseMillis)
-          .writeByte('\n');
-
-      if (isHttps()) {
-        sink.writeByte('\n');
-        sink.writeUtf8(handshake.cipherSuite().javaName())
-            .writeByte('\n');
-        writeCertList(sink, handshake.peerCertificates());
-        writeCertList(sink, handshake.localCertificates());
-        sink.writeUtf8(handshake.tlsVersion().javaName()).writeByte('\n');
-      }
-      sink.close();
+    public File directory() {
+        return cache.getDirectory();
     }
 
-    private boolean isHttps() {
-      return url.startsWith("https://");
+    public boolean isClosed() {
+        return cache.isClosed();
     }
 
-    private List<Certificate> readCertificateList(BufferedSource source) throws IOException {
-      int length = readInt(source);
-      if (length == -1) return Collections.emptyList(); // OkHttp v1.2 used -1 to indicate null.
-
-      try {
-        CertificateFactory certificateFactory = CertificateFactory.getInstance("X.509");
-        List<Certificate> result = new ArrayList<>(length);
-        for (int i = 0; i < length; i++) {
-          String line = source.readUtf8LineStrict();
-          Buffer bytes = new Buffer();
-          bytes.write(ByteString.decodeBase64(line));
-          result.add(certificateFactory.generateCertificate(bytes.inputStream()));
-        }
-        return result;
-      } catch (CertificateException e) {
-        throw new IOException(e.getMessage());
-      }
+    synchronized void trackResponse(CacheStrategy cacheStrategy) {
+        requestCount++;
+
+        if (cacheStrategy.networkRequest != null) {
+            // If this is a conditional request, we'll increment hitCount if/when it hits.
+            networkCount++;
+        } else if (cacheStrategy.cacheResponse != null) {
+            // This response uses the cache and not the network. That's a cache hit.
+            hitCount++;
+        }
     }
 
-    private void writeCertList(BufferedSink sink, List<Certificate> certificates)
-        throws IOException {
-      try {
-        sink.writeDecimalLong(certificates.size())
-            .writeByte('\n');
-        for (int i = 0, size = certificates.size(); i < size; i++) {
-          byte[] bytes = certificates.get(i).getEncoded();
-          String line = ByteString.of(bytes).base64();
-          sink.writeUtf8(line)
-              .writeByte('\n');
-        }
-      } catch (CertificateEncodingException e) {
-        throw new IOException(e.getMessage());
-      }
+    synchronized void trackConditionalCacheHit() {
+        hitCount++;
     }
 
-    public boolean matches(Request request, Response response) {
-      return url.equals(request.url().toString())
-          && requestMethod.equals(request.method())
-          && HttpHeaders.varyMatches(response, varyHeaders, request);
+    public synchronized int networkCount() {
+        return networkCount;
     }
 
-    public Response response(DiskLruCache.Snapshot snapshot) {
-      String contentType = responseHeaders.get("Content-Type");
-      String contentLength = responseHeaders.get("Content-Length");
-      Request cacheRequest = new Request.Builder()
-          .url(url)
-          .method(requestMethod, null)
-          .headers(varyHeaders)
-          .build();
-      return new Response.Builder()
-          .request(cacheRequest)
-          .protocol(protocol)
-          .code(code)
-          .message(message)
-          .headers(responseHeaders)
-          .body(new CacheResponseBody(snapshot, contentType, contentLength))
-          .handshake(handshake)
-          .sentRequestAtMillis(sentRequestMillis)
-          .receivedResponseAtMillis(receivedResponseMillis)
-          .build();
+    public synchronized int hitCount() {
+        return hitCount;
     }
-  }
-
-  static int readInt(BufferedSource source) throws IOException {
-    try {
-      long result = source.readDecimalLong();
-      String line = source.readUtf8LineStrict();
-      if (result < 0 || result > Integer.MAX_VALUE || !line.isEmpty()) {
-        throw new IOException("expected an int but was \"" + result + line + "\"");
-      }
-      return (int) result;
-    } catch (NumberFormatException e) {
-      throw new IOException(e.getMessage());
+
+    public synchronized int requestCount() {
+        return requestCount;
     }
-  }
-
-  private static class CacheResponseBody extends ResponseBody {
-    final DiskLruCache.Snapshot snapshot;
-    private final BufferedSource bodySource;
-    private final @Nullable String contentType;
-    private final @Nullable String contentLength;
-
-    CacheResponseBody(final DiskLruCache.Snapshot snapshot,
-        String contentType, String contentLength) {
-      this.snapshot = snapshot;
-      this.contentType = contentType;
-      this.contentLength = contentLength;
-
-      Source source = snapshot.getSource(ENTRY_BODY);
-      bodySource = Okio.buffer(new ForwardingSource(source) {
-        @Override public void close() throws IOException {
-          snapshot.close();
-          super.close();
-        }
-      });
+
+    private final class CacheRequestImpl implements CacheRequest {
+        private final DiskLruCache.Editor editor;
+        private Sink cacheOut;
+        private Sink body;
+        boolean done;
+
+        CacheRequestImpl(final DiskLruCache.Editor editor) {
+            this.editor = editor;
+            this.cacheOut = editor.newSink(ENTRY_BODY);
+            this.body = new ForwardingSink(cacheOut) {
+                @Override
+                public void close() throws IOException {
+                    synchronized (Cache.this) {
+                        if (done) {
+                            return;
+                        }
+                        done = true;
+                        writeSuccessCount++;
+                    }
+                    super.close();
+                    editor.commit();
+                }
+            };
+        }
+
+        @Override
+        public void abort() {
+            synchronized (Cache.this) {
+                if (done) {
+                    return;
+                }
+                done = true;
+                writeAbortCount++;
+            }
+            Util.closeQuietly(cacheOut);
+            try {
+                editor.abort();
+            } catch (IOException ignored) {
+            }
+        }
+
+        @Override
+        public Sink body() {
+            return body;
+        }
     }
 
-    @Override public MediaType contentType() {
-      return contentType != null ? MediaType.parse(contentType) : null;
+    private static final class Entry {
+        /**
+         * Synthetic response header: the local time when the request was sent.
+         */
+        private static final String SENT_MILLIS = Platform.get().getPrefix() + "-Sent-Millis";
+
+        /**
+         * Synthetic response header: the local time when the response was received.
+         */
+        private static final String RECEIVED_MILLIS = Platform.get().getPrefix() + "-Received-Millis";
+
+        private final String url;
+        private final Headers varyHeaders;
+        private final String requestMethod;
+        private final Protocol protocol;
+        private final int code;
+        private final String message;
+        private final Headers responseHeaders;
+        private final @Nullable
+        Handshake handshake;
+        private final long sentRequestMillis;
+        private final long receivedResponseMillis;
+
+        /**
+         * Reads an entry from an input stream. A typical entry looks like this:
+         * <pre>{@code
+         *   http://google.com/foo
+         *   GET
+         *   2
+         *   Accept-Language: fr-CA
+         *   Accept-Charset: UTF-8
+         *   HTTP/1.1 200 OK
+         *   3
+         *   Content-Type: image/png
+         *   Content-Length: 100
+         *   Cache-Control: max-age=600
+         * }</pre>
+         * <p>
+         * <p>A typical HTTPS file looks like this:
+         * <pre>{@code
+         *   https://google.com/foo
+         *   GET
+         *   2
+         *   Accept-Language: fr-CA
+         *   Accept-Charset: UTF-8
+         *   HTTP/1.1 200 OK
+         *   3
+         *   Content-Type: image/png
+         *   Content-Length: 100
+         *   Cache-Control: max-age=600
+         *
+         *   AES_256_WITH_MD5
+         *   2
+         *   base64-encoded peerCertificate[0]
+         *   base64-encoded peerCertificate[1]
+         *   -1
+         *   TLSv1.2
+         * }</pre>
+         * The file is newline separated. The first two lines are the URL and the request method. Next
+         * is the number of HTTP Vary request header lines, followed by those lines.
+         * <p>
+         * <p>Next is the response status line, followed by the number of HTTP response header lines,
+         * followed by those lines.
+         * <p>
+         * <p>HTTPS responses also contain SSL session information. This begins with a blank line, and
+         * then a line containing the cipher suite. Next is the length of the peer certificate chain.
+         * These certificates are base64-encoded and appear each on their own line. The next line
+         * contains the length of the local certificate chain. These certificates are also
+         * base64-encoded and appear each on their own line. A length of -1 is used to encode a null
+         * array. The last line is optional. If present, it contains the TLS version.
+         */
+        Entry(Source in) throws IOException {
+            try {
+                BufferedSource source = Okio.buffer(in);
+                url = source.readUtf8LineStrict();
+                requestMethod = source.readUtf8LineStrict();
+                Headers.Builder varyHeadersBuilder = new Headers.Builder();
+                int varyRequestHeaderLineCount = readInt(source);
+                for (int i = 0; i < varyRequestHeaderLineCount; i++) {
+                    varyHeadersBuilder.addLenient(source.readUtf8LineStrict());
+                }
+                varyHeaders = varyHeadersBuilder.build();
+
+                StatusLine statusLine = StatusLine.parse(source.readUtf8LineStrict());
+                protocol = statusLine.protocol;
+                code = statusLine.code;
+                message = statusLine.message;
+                Headers.Builder responseHeadersBuilder = new Headers.Builder();
+                int responseHeaderLineCount = readInt(source);
+                for (int i = 0; i < responseHeaderLineCount; i++) {
+                    responseHeadersBuilder.addLenient(source.readUtf8LineStrict());
+                }
+                String sendRequestMillisString = responseHeadersBuilder.get(SENT_MILLIS);
+                String receivedResponseMillisString = responseHeadersBuilder.get(RECEIVED_MILLIS);
+                responseHeadersBuilder.removeAll(SENT_MILLIS);
+                responseHeadersBuilder.removeAll(RECEIVED_MILLIS);
+                sentRequestMillis = sendRequestMillisString != null
+                        ? Long.parseLong(sendRequestMillisString)
+                        : 0L;
+                receivedResponseMillis = receivedResponseMillisString != null
+                        ? Long.parseLong(receivedResponseMillisString)
+                        : 0L;
+                responseHeaders = responseHeadersBuilder.build();
+
+                if (isHttps()) {
+                    String blank = source.readUtf8LineStrict();
+                    if (blank.length() > 0) {
+                        throw new IOException("expected \"\" but was \"" + blank + "\"");
+                    }
+                    String cipherSuiteString = source.readUtf8LineStrict();
+                    CipherSuite cipherSuite = CipherSuite.forJavaName(cipherSuiteString);
+                    List<Certificate> peerCertificates = readCertificateList(source);
+                    List<Certificate> localCertificates = readCertificateList(source);
+                    TlsVersion tlsVersion = !source.exhausted()
+                            ? TlsVersion.forJavaName(source.readUtf8LineStrict())
+                            : TlsVersion.SSL_3_0;
+                    handshake = Handshake.get(tlsVersion, cipherSuite, peerCertificates, localCertificates);
+                } else {
+                    handshake = null;
+                }
+            } finally {
+                in.close();
+            }
+        }
+
+        Entry(Response response) {
+            this.url = response.request().url().toString();
+            this.varyHeaders = HttpHeaders.varyHeaders(response);
+            this.requestMethod = response.request().method();
+            this.protocol = response.protocol();
+            this.code = response.code();
+            this.message = response.message();
+            this.responseHeaders = response.headers();
+            this.handshake = response.handshake();
+            this.sentRequestMillis = response.sentRequestAtMillis();
+            this.receivedResponseMillis = response.receivedResponseAtMillis();
+        }
+
+        public void writeTo(DiskLruCache.Editor editor) throws IOException {
+            BufferedSink sink = Okio.buffer(editor.newSink(ENTRY_METADATA));
+
+            sink.writeUtf8(url)
+                    .writeByte('\n');
+            sink.writeUtf8(requestMethod)
+                    .writeByte('\n');
+            sink.writeDecimalLong(varyHeaders.size())
+                    .writeByte('\n');
+            for (int i = 0, size = varyHeaders.size(); i < size; i++) {
+                sink.writeUtf8(varyHeaders.name(i))
+                        .writeUtf8(": ")
+                        .writeUtf8(varyHeaders.value(i))
+                        .writeByte('\n');
+            }
+
+            sink.writeUtf8(new StatusLine(protocol, code, message).toString())
+                    .writeByte('\n');
+            sink.writeDecimalLong(responseHeaders.size() + 2)
+                    .writeByte('\n');
+            for (int i = 0, size = responseHeaders.size(); i < size; i++) {
+                sink.writeUtf8(responseHeaders.name(i))
+                        .writeUtf8(": ")
+                        .writeUtf8(responseHeaders.value(i))
+                        .writeByte('\n');
+            }
+            sink.writeUtf8(SENT_MILLIS)
+                    .writeUtf8(": ")
+                    .writeDecimalLong(sentRequestMillis)
+                    .writeByte('\n');
+            sink.writeUtf8(RECEIVED_MILLIS)
+                    .writeUtf8(": ")
+                    .writeDecimalLong(receivedResponseMillis)
+                    .writeByte('\n');
+
+            if (isHttps()) {
+                sink.writeByte('\n');
+                sink.writeUtf8(handshake.cipherSuite().javaName())
+                        .writeByte('\n');
+                writeCertList(sink, handshake.peerCertificates());
+                writeCertList(sink, handshake.localCertificates());
+                sink.writeUtf8(handshake.tlsVersion().javaName()).writeByte('\n');
+            }
+            sink.close();
+        }
+
+        private boolean isHttps() {
+            return url.startsWith("https://");
+        }
+
+        private List<Certificate> readCertificateList(BufferedSource source) throws IOException {
+            int length = readInt(source);
+            if (length == -1)
+                return Collections.emptyList(); // OkHttp v1.2 used -1 to indicate null.
+
+            try {
+                CertificateFactory certificateFactory = CertificateFactory.getInstance("X.509");
+                List<Certificate> result = new ArrayList<>(length);
+                for (int i = 0; i < length; i++) {
+                    String line = source.readUtf8LineStrict();
+                    Buffer bytes = new Buffer();
+                    bytes.write(ByteString.decodeBase64(line));
+                    result.add(certificateFactory.generateCertificate(bytes.inputStream()));
+                }
+                return result;
+            } catch (CertificateException e) {
+                throw new IOException(e.getMessage());
+            }
+        }
+
+        private void writeCertList(BufferedSink sink, List<Certificate> certificates)
+                throws IOException {
+            try {
+                sink.writeDecimalLong(certificates.size())
+                        .writeByte('\n');
+                for (int i = 0, size = certificates.size(); i < size; i++) {
+                    byte[] bytes = certificates.get(i).getEncoded();
+                    String line = ByteString.of(bytes).base64();
+                    sink.writeUtf8(line)
+                            .writeByte('\n');
+                }
+            } catch (CertificateEncodingException e) {
+                throw new IOException(e.getMessage());
+            }
+        }
+
+        public boolean matches(Request request, Response response) {
+            return url.equals(request.url().toString())
+                    && requestMethod.equals(request.method())
+                    && HttpHeaders.varyMatches(response, varyHeaders, request);
+        }
+
+        public Response response(DiskLruCache.Snapshot snapshot) {
+            String contentType = responseHeaders.get("Content-Type");
+            String contentLength = responseHeaders.get("Content-Length");
+            Request cacheRequest = new Request.Builder()
+                    .url(url)
+                    .method(requestMethod, null)
+                    .headers(varyHeaders)
+                    .build();
+            return new Response.Builder()
+                    .request(cacheRequest)
+                    .protocol(protocol)
+                    .code(code)
+                    .message(message)
+                    .headers(responseHeaders)
+                    .body(new CacheResponseBody(snapshot, contentType, contentLength))
+                    .handshake(handshake)
+                    .sentRequestAtMillis(sentRequestMillis)
+                    .receivedResponseAtMillis(receivedResponseMillis)
+                    .build();
+        }
     }
 
-    @Override public long contentLength() {
-      try {
-        return contentLength != null ? Long.parseLong(contentLength) : -1;
-      } catch (NumberFormatException e) {
-        return -1;
-      }
+    static int readInt(BufferedSource source) throws IOException {
+        try {
+            long result = source.readDecimalLong();
+            String line = source.readUtf8LineStrict();
+            if (result < 0 || result > Integer.MAX_VALUE || !line.isEmpty()) {
+                throw new IOException("expected an int but was \"" + result + line + "\"");
+            }
+            return (int) result;
+        } catch (NumberFormatException e) {
+            throw new IOException(e.getMessage());
+        }
     }
 
-    @Override public BufferedSource source() {
-      return bodySource;
+    private static class CacheResponseBody extends ResponseBody {
+        final DiskLruCache.Snapshot snapshot;
+        private final BufferedSource bodySource;
+        private final @Nullable
+        String contentType;
+        private final @Nullable
+        String contentLength;
+
+        CacheResponseBody(final DiskLruCache.Snapshot snapshot,
+                          String contentType, String contentLength) {
+            this.snapshot = snapshot;
+            this.contentType = contentType;
+            this.contentLength = contentLength;
+
+            Source source = snapshot.getSource(ENTRY_BODY);
+            bodySource = Okio.buffer(new ForwardingSource(source) {
+                @Override
+                public void close() throws IOException {
+                    snapshot.close();
+                    super.close();
+                }
+            });
+        }
+
+        @Override
+        public MediaType contentType() {
+            return contentType != null ? MediaType.parse(contentType) : null;
+        }
+
+        @Override
+        public long contentLength() {
+            try {
+                return contentLength != null ? Long.parseLong(contentLength) : -1;
+            } catch (NumberFormatException e) {
+                return -1;
+            }
+        }
+
+        @Override
+        public BufferedSource source() {
+            return bodySource;
+        }
     }
-  }
 }
diff --git a/okhttp/src/main/java/okhttp3/Dispatcher.java b/okhttp/src/main/java/okhttp3/Dispatcher.java
index e24a2b8438..c5a9fd8853 100644
--- a/okhttp/src/main/java/okhttp3/Dispatcher.java
+++ b/okhttp/src/main/java/okhttp3/Dispatcher.java
@@ -46,6 +46,7 @@
 
     /**
      * Executes calls. Created lazily.
+     * 线程池，用于执行请求
      */
     private @Nullable
     ExecutorService executorService;
@@ -58,7 +59,7 @@
 
     /**
      * Running asynchronous calls. Includes canceled calls that haven't finished yet.
-     * 正在运行的异步请求
+     * 表示 正在运行的异步请求的队列，其中包含了已经取消了的但未完成的任务。
      */
     private final Deque<AsyncCall> runningAsyncCalls = new ArrayDeque<>();
 
@@ -184,31 +185,31 @@ private boolean promoteAndExecute() {
         List<AsyncCall> executableCalls = new ArrayList<>();
         boolean isRunning;
         synchronized (this) {
-            // 遍历 readyAsyncCalls
+            // 1、遍历 readyAsyncCalls
             for (Iterator<AsyncCall> i = readyAsyncCalls.iterator(); i.hasNext(); ) {
                 AsyncCall asyncCall = i.next();
 
-                // 如果 runningAsyncCalls的size大于最大请求数，则直接跳出循环，不再遍历readyAsyncCalls
+                // 1.1 如果 runningAsyncCalls的size大于最大请求数，则直接跳出循环，不再遍历readyAsyncCalls
                 if (runningAsyncCalls.size() >= maxRequests) break; // Max capacity.
 
-                // 如果 该asyncCall所运行的主机上运行的请求数 大于 最大主机请求数，那么跳过执行该请求
+                // 1.2 如果 该asyncCall所运行的主机上运行的请求数 大于 最大主机请求数，那么跳过执行该请求
                 if (runningCallsForHost(asyncCall) >= maxRequestsPerHost)
                     continue; // Host max capacity.
 
-                // 将该请求从 readyAsyncCalls队列中删除
+                // 1.3 将该请求从 readyAsyncCalls队列中删除
                 i.remove();
-                // 将该请求加入到 executableCalls
+                // 1.4 将该请求加入到 executableCalls
                 executableCalls.add(asyncCall);
 
-                // 将该请求加入到 runningAsyncCalls中
+                // 1.5 将该请求加入到 runningAsyncCalls中
                 runningAsyncCalls.add(asyncCall);
             }
 
-            // runningAsyncCalls.size() + runningSyncCalls.size()
+            // 2、runningAsyncCalls.size() + runningSyncCalls.size()
             isRunning = runningCallsCount() > 0;
         }
 
-        // 遍历 executableCalls，将其中的请求对象AsyncCall放入线程池中执行
+        // 3、遍历 executableCalls，将其中的请求对象AsyncCall放入线程池中执行
         for (int i = 0, size = executableCalls.size(); i < size; i++) {
             AsyncCall asyncCall = executableCalls.get(i);
             asyncCall.executeOn(executorService());
@@ -240,6 +241,8 @@ synchronized void executed(RealCall call) {
 
     /**
      * Used by {@code AsyncCall#run} to signal completion.
+     *
+     * 结束异步请求
      */
     void finished(AsyncCall call) {
         finished(runningAsyncCalls, call);
@@ -247,6 +250,8 @@ void finished(AsyncCall call) {
 
     /**
      * Used by {@code Call#execute} to signal completion.
+     *
+     * 结束同步请求
      */
     void finished(RealCall call) {
         finished(runningSyncCalls, call);
@@ -255,13 +260,17 @@ void finished(RealCall call) {
     private <T> void finished(Deque<T> calls, T call) {
         Runnable idleCallback;
         synchronized (this) {
+            // 1、将请求从相应的队列中移出。
             if (!calls.remove(call)) throw new AssertionError("Call wasn't in-flight!");
             idleCallback = this.idleCallback;
         }
 
+        // 2、继续尝试执行readyAsyncCalls中缓存的异步请求。
+        // 如果runningAsyncCalls和runningSyncCalls队列中都没有请求在执行，isRunning = false
         boolean isRunning = promoteAndExecute();
 
         if (!isRunning && idleCallback != null) {
+            // 3、如果没有请求执行isRunning = false，并且设置了idleCallback，则需要回调该callback
             idleCallback.run();
         }
     }
diff --git a/okhttp/src/main/java/okhttp3/RealCall.java b/okhttp/src/main/java/okhttp3/RealCall.java
index 99b4dd2d69..094902cb48 100644
--- a/okhttp/src/main/java/okhttp3/RealCall.java
+++ b/okhttp/src/main/java/okhttp3/RealCall.java
@@ -256,13 +256,13 @@ void executeOn(ExecutorService executorService) {
             assert (!Thread.holdsLock(client.dispatcher()));
             boolean success = false;
             try {
-                // 将该AsyncCall对象加入到线程池中。
+                // 1、将该AsyncCall对象加入到线程池中。
                 // 在线程池中，会调用Runnable的run方法，AsyncCall继承自NamedRunnable。
                 // NamedRunnable中的run方法，会执行抽象方法 execute()
                 executorService.execute(this);
                 success = true;
             } catch (RejectedExecutionException e) {
-                //执行过程中发生了异常
+                //2、执行过程中发生了异常
                 InterruptedIOException ioException = new InterruptedIOException("executor rejected");
                 ioException.initCause(e);
 
@@ -273,7 +273,7 @@ void executeOn(ExecutorService executorService) {
                 responseCallback.onFailure(RealCall.this, ioException);
             } finally {
                 if (!success) {
-                    // 如果线程池处理该请求失败了。调用dispatcher的finish方法。
+                    // 3、如果线程池处理该请求失败了。调用dispatcher的finish方法。
                     // 成功，在execute()方法中已经执行了dispatcher的finish方法
                     client.dispatcher().finished(this); // This call is no longer running!
                 }
@@ -325,13 +325,14 @@ String redactedUrl() {
 
     /**
      * 真正执行 网络请求的方法
-     *
+     * 在该方法中创建拦截器链，通过依次执行每一个不同功能的拦截器来获取服务器的响应返回。
      * @return
      * @throws IOException
      */
     Response getResponseWithInterceptorChain() throws IOException {
         // Build a full stack of interceptors.
         List<Interceptor> interceptors = new ArrayList<>();
+        // 添加用户自定义的拦截器，也就是应用程序拦截器。
         interceptors.addAll(client.interceptors());
 
         //失败和重定向过滤器
diff --git a/okhttp/src/main/java/okhttp3/internal/cache/CacheInterceptor.java b/okhttp/src/main/java/okhttp3/internal/cache/CacheInterceptor.java
index d46494d95b..5ef0dc511f 100644
--- a/okhttp/src/main/java/okhttp3/internal/cache/CacheInterceptor.java
+++ b/okhttp/src/main/java/okhttp3/internal/cache/CacheInterceptor.java
@@ -17,6 +17,7 @@
 package okhttp3.internal.cache;
 
 import java.io.IOException;
+
 import okhttp3.Headers;
 import okhttp3.Interceptor;
 import okhttp3.Protocol;
@@ -41,227 +42,235 @@
 import static okhttp3.internal.Util.closeQuietly;
 import static okhttp3.internal.Util.discard;
 
-/** Serves requests from the cache and writes responses to the cache. */
+/**
+ * Serves requests from the cache and writes responses to the cache.
+ */
 public final class CacheInterceptor implements Interceptor {
-  final InternalCache cache;
-
-  public CacheInterceptor(InternalCache cache) {
-    this.cache = cache;
-  }
-
-  @Override public Response intercept(Chain chain) throws IOException {
-    Response cacheCandidate = cache != null
-        ? cache.get(chain.request())
-        : null;
+    final InternalCache cache;
 
-    long now = System.currentTimeMillis();
-
-    CacheStrategy strategy = new CacheStrategy.Factory(now, chain.request(), cacheCandidate).get();
-    Request networkRequest = strategy.networkRequest;
-    Response cacheResponse = strategy.cacheResponse;
-
-    if (cache != null) {
-      cache.trackResponse(strategy);
+    public CacheInterceptor(InternalCache cache) {
+        this.cache = cache;
     }
 
-    if (cacheCandidate != null && cacheResponse == null) {
-      closeQuietly(cacheCandidate.body()); // The cache candidate wasn't applicable. Close it.
-    }
+    @Override
+    public Response intercept(Chain chain) throws IOException {
+        Response cacheCandidate = cache != null
+                ? cache.get(chain.request())
+                : null;
 
-    // If we're forbidden from using the network and the cache is insufficient, fail.
-    if (networkRequest == null && cacheResponse == null) {
-      return new Response.Builder()
-          .request(chain.request())
-          .protocol(Protocol.HTTP_1_1)
-          .code(504)
-          .message("Unsatisfiable Request (only-if-cached)")
-          .body(Util.EMPTY_RESPONSE)
-          .sentRequestAtMillis(-1L)
-          .receivedResponseAtMillis(System.currentTimeMillis())
-          .build();
-    }
+        long now = System.currentTimeMillis();
 
-    // If we don't need the network, we're done.
-    if (networkRequest == null) {
-      return cacheResponse.newBuilder()
-          .cacheResponse(stripBody(cacheResponse))
-          .build();
-    }
+        CacheStrategy strategy = new CacheStrategy.Factory(now, chain.request(), cacheCandidate).get();
+        Request networkRequest = strategy.networkRequest;
+        Response cacheResponse = strategy.cacheResponse;
 
-    Response networkResponse = null;
-    try {
-      networkResponse = chain.proceed(networkRequest);
-    } finally {
-      // If we're crashing on I/O or otherwise, don't leak the cache body.
-      if (networkResponse == null && cacheCandidate != null) {
-        closeQuietly(cacheCandidate.body());
-      }
-    }
+        if (cache != null) {
+            cache.trackResponse(strategy);
+        }
 
-    // If we have a cache response too, then we're doing a conditional get.
-    if (cacheResponse != null) {
-      if (networkResponse.code() == HTTP_NOT_MODIFIED) {
-        Response response = cacheResponse.newBuilder()
-            .headers(combine(cacheResponse.headers(), networkResponse.headers()))
-            .sentRequestAtMillis(networkResponse.sentRequestAtMillis())
-            .receivedResponseAtMillis(networkResponse.receivedResponseAtMillis())
-            .cacheResponse(stripBody(cacheResponse))
-            .networkResponse(stripBody(networkResponse))
-            .build();
-        networkResponse.body().close();
-
-        // Update the cache after combining headers but before stripping the
-        // Content-Encoding header (as performed by initContentStream()).
-        cache.trackConditionalCacheHit();
-        cache.update(cacheResponse, response);
-        return response;
-      } else {
-        closeQuietly(cacheResponse.body());
-      }
-    }
+        if (cacheCandidate != null && cacheResponse == null) {
+            closeQuietly(cacheCandidate.body()); // The cache candidate wasn't applicable. Close it.
+        }
 
-    Response response = networkResponse.newBuilder()
-        .cacheResponse(stripBody(cacheResponse))
-        .networkResponse(stripBody(networkResponse))
-        .build();
+        // If we're forbidden from using the network and the cache is insufficient, fail.
+        if (networkRequest == null && cacheResponse == null) {
+            return new Response.Builder()
+                    .request(chain.request())
+                    .protocol(Protocol.HTTP_1_1)
+                    .code(504)
+                    .message("Unsatisfiable Request (only-if-cached)")
+                    .body(Util.EMPTY_RESPONSE)
+                    .sentRequestAtMillis(-1L)
+                    .receivedResponseAtMillis(System.currentTimeMillis())
+                    .build();
+        }
 
-    if (cache != null) {
-      if (HttpHeaders.hasBody(response) && CacheStrategy.isCacheable(response, networkRequest)) {
-        // Offer this request to the cache.
-        CacheRequest cacheRequest = cache.put(response);
-        return cacheWritingResponse(cacheRequest, response);
-      }
+        // If we don't need the network, we're done.
+        if (networkRequest == null) {
+            return cacheResponse.newBuilder()
+                    .cacheResponse(stripBody(cacheResponse))
+                    .build();
+        }
 
-      if (HttpMethod.invalidatesCache(networkRequest.method())) {
+        Response networkResponse = null;
         try {
-          cache.remove(networkRequest);
-        } catch (IOException ignored) {
-          // The cache cannot be written.
+            networkResponse = chain.proceed(networkRequest);
+        } finally {
+            // If we're crashing on I/O or otherwise, don't leak the cache body.
+            if (networkResponse == null && cacheCandidate != null) {
+                closeQuietly(cacheCandidate.body());
+            }
         }
-      }
-    }
 
-    return response;
-  }
-
-  private static Response stripBody(Response response) {
-    return response != null && response.body() != null
-        ? response.newBuilder().body(null).build()
-        : response;
-  }
-
-  /**
-   * Returns a new source that writes bytes to {@code cacheRequest} as they are read by the source
-   * consumer. This is careful to discard bytes left over when the stream is closed; otherwise we
-   * may never exhaust the source stream and therefore not complete the cached response.
-   */
-  private Response cacheWritingResponse(final CacheRequest cacheRequest, Response response)
-      throws IOException {
-    // Some apps return a null body; for compatibility we treat that like a null cache request.
-    if (cacheRequest == null) return response;
-    Sink cacheBodyUnbuffered = cacheRequest.body();
-    if (cacheBodyUnbuffered == null) return response;
-
-    final BufferedSource source = response.body().source();
-    final BufferedSink cacheBody = Okio.buffer(cacheBodyUnbuffered);
-
-    Source cacheWritingSource = new Source() {
-      boolean cacheRequestClosed;
-
-      @Override public long read(Buffer sink, long byteCount) throws IOException {
-        long bytesRead;
-        try {
-          bytesRead = source.read(sink, byteCount);
-        } catch (IOException e) {
-          if (!cacheRequestClosed) {
-            cacheRequestClosed = true;
-            cacheRequest.abort(); // Failed to write a complete cache response.
-          }
-          throw e;
+        // If we have a cache response too, then we're doing a conditional get.
+        if (cacheResponse != null) {
+            if (networkResponse.code() == HTTP_NOT_MODIFIED) {
+                Response response = cacheResponse.newBuilder()
+                        .headers(combine(cacheResponse.headers(), networkResponse.headers()))
+                        .sentRequestAtMillis(networkResponse.sentRequestAtMillis())
+                        .receivedResponseAtMillis(networkResponse.receivedResponseAtMillis())
+                        .cacheResponse(stripBody(cacheResponse))
+                        .networkResponse(stripBody(networkResponse))
+                        .build();
+                networkResponse.body().close();
+
+                // Update the cache after combining headers but before stripping the
+                // Content-Encoding header (as performed by initContentStream()).
+                cache.trackConditionalCacheHit();
+                cache.update(cacheResponse, response);
+                return response;
+            } else {
+                closeQuietly(cacheResponse.body());
+            }
         }
 
-        if (bytesRead == -1) {
-          if (!cacheRequestClosed) {
-            cacheRequestClosed = true;
-            cacheBody.close(); // The cache response is complete!
-          }
-          return -1;
+        Response response = networkResponse.newBuilder()
+                .cacheResponse(stripBody(cacheResponse))
+                .networkResponse(stripBody(networkResponse))
+                .build();
+
+        if (cache != null) {
+            if (HttpHeaders.hasBody(response) && CacheStrategy.isCacheable(response, networkRequest)) {
+                // Offer this request to the cache.
+                CacheRequest cacheRequest = cache.put(response);
+                return cacheWritingResponse(cacheRequest, response);
+            }
+
+            if (HttpMethod.invalidatesCache(networkRequest.method())) {
+                try {
+                    cache.remove(networkRequest);
+                } catch (IOException ignored) {
+                    // The cache cannot be written.
+                }
+            }
         }
 
-        sink.copyTo(cacheBody.buffer(), sink.size() - bytesRead, bytesRead);
-        cacheBody.emitCompleteSegments();
-        return bytesRead;
-      }
+        return response;
+    }
 
-      @Override public Timeout timeout() {
-        return source.timeout();
-      }
+    private static Response stripBody(Response response) {
+        return response != null && response.body() != null
+                ? response.newBuilder().body(null).build()
+                : response;
+    }
 
-      @Override public void close() throws IOException {
-        if (!cacheRequestClosed
-            && !discard(this, HttpCodec.DISCARD_STREAM_TIMEOUT_MILLIS, MILLISECONDS)) {
-          cacheRequestClosed = true;
-          cacheRequest.abort();
+    /**
+     * Returns a new source that writes bytes to {@code cacheRequest} as they are read by the source
+     * consumer. This is careful to discard bytes left over when the stream is closed; otherwise we
+     * may never exhaust the source stream and therefore not complete the cached response.
+     */
+    private Response cacheWritingResponse(final CacheRequest cacheRequest, Response response)
+            throws IOException {
+        // Some apps return a null body; for compatibility we treat that like a null cache request.
+        if (cacheRequest == null) return response;
+        Sink cacheBodyUnbuffered = cacheRequest.body();
+        if (cacheBodyUnbuffered == null) return response;
+
+        final BufferedSource source = response.body().source();
+        final BufferedSink cacheBody = Okio.buffer(cacheBodyUnbuffered);
+
+        Source cacheWritingSource = new Source() {
+            boolean cacheRequestClosed;
+
+            @Override
+            public long read(Buffer sink, long byteCount) throws IOException {
+                long bytesRead;
+                try {
+                    bytesRead = source.read(sink, byteCount);
+                } catch (IOException e) {
+                    if (!cacheRequestClosed) {
+                        cacheRequestClosed = true;
+                        cacheRequest.abort(); // Failed to write a complete cache response.
+                    }
+                    throw e;
+                }
+
+                if (bytesRead == -1) {
+                    if (!cacheRequestClosed) {
+                        cacheRequestClosed = true;
+                        cacheBody.close(); // The cache response is complete!
+                    }
+                    return -1;
+                }
+
+                sink.copyTo(cacheBody.buffer(), sink.size() - bytesRead, bytesRead);
+                cacheBody.emitCompleteSegments();
+                return bytesRead;
+            }
+
+            @Override
+            public Timeout timeout() {
+                return source.timeout();
+            }
+
+            @Override
+            public void close() throws IOException {
+                if (!cacheRequestClosed
+                        && !discard(this, HttpCodec.DISCARD_STREAM_TIMEOUT_MILLIS, MILLISECONDS)) {
+                    cacheRequestClosed = true;
+                    cacheRequest.abort();
+                }
+                source.close();
+            }
+        };
+
+        String contentType = response.header("Content-Type");
+        long contentLength = response.body().contentLength();
+        return response.newBuilder()
+                .body(new RealResponseBody(contentType, contentLength, Okio.buffer(cacheWritingSource)))
+                .build();
+    }
+
+    /**
+     * Combines cached headers with a network headers as defined by RFC 7234, 4.3.4.
+     */
+    private static Headers combine(Headers cachedHeaders, Headers networkHeaders) {
+        Headers.Builder result = new Headers.Builder();
+
+        for (int i = 0, size = cachedHeaders.size(); i < size; i++) {
+            String fieldName = cachedHeaders.name(i);
+            String value = cachedHeaders.value(i);
+            if ("Warning".equalsIgnoreCase(fieldName) && value.startsWith("1")) {
+                continue; // Drop 100-level freshness warnings.
+            }
+            if (isContentSpecificHeader(fieldName) || !isEndToEnd(fieldName)
+                    || networkHeaders.get(fieldName) == null) {
+                Internal.instance.addLenient(result, fieldName, value);
+            }
+        }
+
+        for (int i = 0, size = networkHeaders.size(); i < size; i++) {
+            String fieldName = networkHeaders.name(i);
+            if (!isContentSpecificHeader(fieldName) && isEndToEnd(fieldName)) {
+                Internal.instance.addLenient(result, fieldName, networkHeaders.value(i));
+            }
         }
-        source.close();
-      }
-    };
-
-    String contentType = response.header("Content-Type");
-    long contentLength = response.body().contentLength();
-    return response.newBuilder()
-        .body(new RealResponseBody(contentType, contentLength, Okio.buffer(cacheWritingSource)))
-        .build();
-  }
-
-  /** Combines cached headers with a network headers as defined by RFC 7234, 4.3.4. */
-  private static Headers combine(Headers cachedHeaders, Headers networkHeaders) {
-    Headers.Builder result = new Headers.Builder();
-
-    for (int i = 0, size = cachedHeaders.size(); i < size; i++) {
-      String fieldName = cachedHeaders.name(i);
-      String value = cachedHeaders.value(i);
-      if ("Warning".equalsIgnoreCase(fieldName) && value.startsWith("1")) {
-        continue; // Drop 100-level freshness warnings.
-      }
-      if (isContentSpecificHeader(fieldName) || !isEndToEnd(fieldName)
-              || networkHeaders.get(fieldName) == null) {
-        Internal.instance.addLenient(result, fieldName, value);
-      }
+
+        return result.build();
     }
 
-    for (int i = 0, size = networkHeaders.size(); i < size; i++) {
-      String fieldName = networkHeaders.name(i);
-      if (!isContentSpecificHeader(fieldName) && isEndToEnd(fieldName)) {
-        Internal.instance.addLenient(result, fieldName, networkHeaders.value(i));
-      }
+    /**
+     * Returns true if {@code fieldName} is an end-to-end HTTP header, as defined by RFC 2616,
+     * 13.5.1.
+     */
+    static boolean isEndToEnd(String fieldName) {
+        return !"Connection".equalsIgnoreCase(fieldName)
+                && !"Keep-Alive".equalsIgnoreCase(fieldName)
+                && !"Proxy-Authenticate".equalsIgnoreCase(fieldName)
+                && !"Proxy-Authorization".equalsIgnoreCase(fieldName)
+                && !"TE".equalsIgnoreCase(fieldName)
+                && !"Trailers".equalsIgnoreCase(fieldName)
+                && !"Transfer-Encoding".equalsIgnoreCase(fieldName)
+                && !"Upgrade".equalsIgnoreCase(fieldName);
     }
 
-    return result.build();
-  }
-
-  /**
-   * Returns true if {@code fieldName} is an end-to-end HTTP header, as defined by RFC 2616,
-   * 13.5.1.
-   */
-  static boolean isEndToEnd(String fieldName) {
-    return !"Connection".equalsIgnoreCase(fieldName)
-        && !"Keep-Alive".equalsIgnoreCase(fieldName)
-        && !"Proxy-Authenticate".equalsIgnoreCase(fieldName)
-        && !"Proxy-Authorization".equalsIgnoreCase(fieldName)
-        && !"TE".equalsIgnoreCase(fieldName)
-        && !"Trailers".equalsIgnoreCase(fieldName)
-        && !"Transfer-Encoding".equalsIgnoreCase(fieldName)
-        && !"Upgrade".equalsIgnoreCase(fieldName);
-  }
-
-  /**
-   * Returns true if {@code fieldName} is content specific and therefore should always be used
-   * from cached headers.
-   */
-  static boolean isContentSpecificHeader(String fieldName) {
-    return "Content-Length".equalsIgnoreCase(fieldName)
-        || "Content-Encoding".equalsIgnoreCase(fieldName)
-        || "Content-Type".equalsIgnoreCase(fieldName);
-  }
+    /**
+     * Returns true if {@code fieldName} is content specific and therefore should always be used
+     * from cached headers.
+     */
+    static boolean isContentSpecificHeader(String fieldName) {
+        return "Content-Length".equalsIgnoreCase(fieldName)
+                || "Content-Encoding".equalsIgnoreCase(fieldName)
+                || "Content-Type".equalsIgnoreCase(fieldName);
+    }
 }
diff --git a/okhttp/src/main/java/okhttp3/internal/http/BridgeInterceptor.java b/okhttp/src/main/java/okhttp3/internal/http/BridgeInterceptor.java
index c10dc34cdc..258570a948 100644
--- a/okhttp/src/main/java/okhttp3/internal/http/BridgeInterceptor.java
+++ b/okhttp/src/main/java/okhttp3/internal/http/BridgeInterceptor.java
@@ -18,6 +18,7 @@
 
 import java.io.IOException;
 import java.util.List;
+
 import okhttp3.Cookie;
 import okhttp3.CookieJar;
 import okhttp3.Headers;
@@ -36,93 +37,104 @@
  * Bridges from application code to network code. First it builds a network request from a user
  * request. Then it proceeds to call the network. Finally it builds a user response from the network
  * response.
+ * 主要负责 设置内容长度以及我们的编码方式等，主要是添加头部的作用
  */
 public final class BridgeInterceptor implements Interceptor {
-  private final CookieJar cookieJar;
-
-  public BridgeInterceptor(CookieJar cookieJar) {
-    this.cookieJar = cookieJar;
-  }
-
-  @Override public Response intercept(Chain chain) throws IOException {
-    Request userRequest = chain.request();
-    Request.Builder requestBuilder = userRequest.newBuilder();
-
-    RequestBody body = userRequest.body();
-    if (body != null) {
-      MediaType contentType = body.contentType();
-      if (contentType != null) {
-        requestBuilder.header("Content-Type", contentType.toString());
-      }
-
-      long contentLength = body.contentLength();
-      if (contentLength != -1) {
-        requestBuilder.header("Content-Length", Long.toString(contentLength));
-        requestBuilder.removeHeader("Transfer-Encoding");
-      } else {
-        requestBuilder.header("Transfer-Encoding", "chunked");
-        requestBuilder.removeHeader("Content-Length");
-      }
-    }
-
-    if (userRequest.header("Host") == null) {
-      requestBuilder.header("Host", hostHeader(userRequest.url(), false));
-    }
+    private final CookieJar cookieJar;
 
-    if (userRequest.header("Connection") == null) {
-      requestBuilder.header("Connection", "Keep-Alive");
+    public BridgeInterceptor(CookieJar cookieJar) {
+        this.cookieJar = cookieJar;
     }
 
-    // If we add an "Accept-Encoding: gzip" header field we're responsible for also decompressing
-    // the transfer stream.
-    boolean transparentGzip = false;
-    if (userRequest.header("Accept-Encoding") == null && userRequest.header("Range") == null) {
-      transparentGzip = true;
-      requestBuilder.header("Accept-Encoding", "gzip");
-    }
-
-    List<Cookie> cookies = cookieJar.loadForRequest(userRequest.url());
-    if (!cookies.isEmpty()) {
-      requestBuilder.header("Cookie", cookieHeader(cookies));
-    }
-
-    if (userRequest.header("User-Agent") == null) {
-      requestBuilder.header("User-Agent", Version.userAgent());
-    }
-
-    Response networkResponse = chain.proceed(requestBuilder.build());
-
-    HttpHeaders.receiveHeaders(cookieJar, userRequest.url(), networkResponse.headers());
-
-    Response.Builder responseBuilder = networkResponse.newBuilder()
-        .request(userRequest);
-
-    if (transparentGzip
-        && "gzip".equalsIgnoreCase(networkResponse.header("Content-Encoding"))
-        && HttpHeaders.hasBody(networkResponse)) {
-      GzipSource responseBody = new GzipSource(networkResponse.body().source());
-      Headers strippedHeaders = networkResponse.headers().newBuilder()
-          .removeAll("Content-Encoding")
-          .removeAll("Content-Length")
-          .build();
-      responseBuilder.headers(strippedHeaders);
-      String contentType = networkResponse.header("Content-Type");
-      responseBuilder.body(new RealResponseBody(contentType, -1L, Okio.buffer(responseBody)));
+    @Override
+    public Response intercept(Chain chain) throws IOException {
+        Request userRequest = chain.request();
+        Request.Builder requestBuilder = userRequest.newBuilder();
+
+        RequestBody body = userRequest.body();
+        if (body != null) {
+            MediaType contentType = body.contentType();
+            if (contentType != null) {
+                requestBuilder.header("Content-Type", contentType.toString());
+            }
+
+            long contentLength = body.contentLength();
+            if (contentLength != -1) {
+                requestBuilder.header("Content-Length", Long.toString(contentLength));
+                requestBuilder.removeHeader("Transfer-Encoding");
+            } else {
+                requestBuilder.header("Transfer-Encoding", "chunked");
+                requestBuilder.removeHeader("Content-Length");
+            }
+        }
+
+        if (userRequest.header("Host") == null) {
+            requestBuilder.header("Host", hostHeader(userRequest.url(), false));
+        }
+
+        if (userRequest.header("Connection") == null) {
+            requestBuilder.header("Connection", "Keep-Alive");
+        }
+
+        // If we add an "Accept-Encoding: gzip" header field we're responsible for also decompressing
+        // the transfer stream.
+        boolean transparentGzip = false;
+        if (userRequest.header("Accept-Encoding") == null && userRequest.header("Range") == null) {
+            transparentGzip = true;
+            requestBuilder.header("Accept-Encoding", "gzip");
+        }
+
+        List<Cookie> cookies = cookieJar.loadForRequest(userRequest.url());
+        if (!cookies.isEmpty()) {
+            requestBuilder.header("Cookie", cookieHeader(cookies));
+        }
+
+        if (userRequest.header("User-Agent") == null) {
+            requestBuilder.header("User-Agent", Version.userAgent());
+        }
+
+        // 调用连接器的proceed方法
+        Response networkResponse = chain.proceed(requestBuilder.build());
+
+        // 将网络请求 从服务器返回的 响应Response 转化为用户可以使用的Response
+        HttpHeaders.receiveHeaders(cookieJar, userRequest.url(), networkResponse.headers());
+
+        Response.Builder responseBuilder = networkResponse.newBuilder()
+                .request(userRequest);
+
+        // Gzip解压
+        // 判断响应头步的 Content-Encoding 是 gzip
+        if (transparentGzip
+                && "gzip".equalsIgnoreCase(networkResponse.header("Content-Encoding"))
+                && HttpHeaders.hasBody(networkResponse)) {
+            // 将Response的body输入流 转化为 GzipSource
+            // 目的是让调用者 在使用 Response body时 直接以解压的方式读取流数据
+            // 其实就是将响应输入流转化为 解压的输入流
+            GzipSource responseBody = new GzipSource(networkResponse.body().source());
+            Headers strippedHeaders = networkResponse.headers().newBuilder()
+                    .removeAll("Content-Encoding")
+                    .removeAll("Content-Length")
+                    .build();
+            responseBuilder.headers(strippedHeaders);
+            String contentType = networkResponse.header("Content-Type");
+            responseBuilder.body(new RealResponseBody(contentType, -1L, Okio.buffer(responseBody)));
+        }
+
+        return responseBuilder.build();
     }
 
-    return responseBuilder.build();
-  }
-
-  /** Returns a 'Cookie' HTTP request header with all cookies, like {@code a=b; c=d}. */
-  private String cookieHeader(List<Cookie> cookies) {
-    StringBuilder cookieHeader = new StringBuilder();
-    for (int i = 0, size = cookies.size(); i < size; i++) {
-      if (i > 0) {
-        cookieHeader.append("; ");
-      }
-      Cookie cookie = cookies.get(i);
-      cookieHeader.append(cookie.name()).append('=').append(cookie.value());
+    /**
+     * Returns a 'Cookie' HTTP request header with all cookies, like {@code a=b; c=d}.
+     */
+    private String cookieHeader(List<Cookie> cookies) {
+        StringBuilder cookieHeader = new StringBuilder();
+        for (int i = 0, size = cookies.size(); i < size; i++) {
+            if (i > 0) {
+                cookieHeader.append("; ");
+            }
+            Cookie cookie = cookies.get(i);
+            cookieHeader.append(cookie.name()).append('=').append(cookie.value());
+        }
+        return cookieHeader.toString();
     }
-    return cookieHeader.toString();
-  }
 }
diff --git a/okhttp/src/main/java/okhttp3/internal/http/CallServerInterceptor.java b/okhttp/src/main/java/okhttp3/internal/http/CallServerInterceptor.java
index 62531aa514..a5d2fd2306 100644
--- a/okhttp/src/main/java/okhttp3/internal/http/CallServerInterceptor.java
+++ b/okhttp/src/main/java/okhttp3/internal/http/CallServerInterceptor.java
@@ -17,6 +17,7 @@
 
 import java.io.IOException;
 import java.net.ProtocolException;
+
 import okhttp3.Interceptor;
 import okhttp3.Request;
 import okhttp3.Response;
@@ -29,125 +30,129 @@
 import okio.Okio;
 import okio.Sink;
 
-/** This is the last interceptor in the chain. It makes a network call to the server. */
+/**
+ * This is the last interceptor in the chain. It makes a network call to the server.
+ */
 public final class CallServerInterceptor implements Interceptor {
-  private final boolean forWebSocket;
-
-  public CallServerInterceptor(boolean forWebSocket) {
-    this.forWebSocket = forWebSocket;
-  }
-
-  @Override public Response intercept(Chain chain) throws IOException {
-    RealInterceptorChain realChain = (RealInterceptorChain) chain;
-    HttpCodec httpCodec = realChain.httpStream();
-    StreamAllocation streamAllocation = realChain.streamAllocation();
-    RealConnection connection = (RealConnection) realChain.connection();
-    Request request = realChain.request();
-
-    long sentRequestMillis = System.currentTimeMillis();
-
-    realChain.eventListener().requestHeadersStart(realChain.call());
-    httpCodec.writeRequestHeaders(request);
-    realChain.eventListener().requestHeadersEnd(realChain.call(), request);
-
-    Response.Builder responseBuilder = null;
-    if (HttpMethod.permitsRequestBody(request.method()) && request.body() != null) {
-      // If there's a "Expect: 100-continue" header on the request, wait for a "HTTP/1.1 100
-      // Continue" response before transmitting the request body. If we don't get that, return
-      // what we did get (such as a 4xx response) without ever transmitting the request body.
-      if ("100-continue".equalsIgnoreCase(request.header("Expect"))) {
-        httpCodec.flushRequest();
-        realChain.eventListener().responseHeadersStart(realChain.call());
-        responseBuilder = httpCodec.readResponseHeaders(true);
-      }
-
-      if (responseBuilder == null) {
-        // Write the request body if the "Expect: 100-continue" expectation was met.
-        realChain.eventListener().requestBodyStart(realChain.call());
-        long contentLength = request.body().contentLength();
-        CountingSink requestBodyOut =
-            new CountingSink(httpCodec.createRequestBody(request, contentLength));
-        BufferedSink bufferedRequestBody = Okio.buffer(requestBodyOut);
-
-        request.body().writeTo(bufferedRequestBody);
-        bufferedRequestBody.close();
-        realChain.eventListener()
-            .requestBodyEnd(realChain.call(), requestBodyOut.successfulCount);
-      } else if (!connection.isMultiplexed()) {
-        // If the "Expect: 100-continue" expectation wasn't met, prevent the HTTP/1 connection
-        // from being reused. Otherwise we're still obligated to transmit the request body to
-        // leave the connection in a consistent state.
-        streamAllocation.noNewStreams();
-      }
-    }
+    private final boolean forWebSocket;
 
-    httpCodec.finishRequest();
-
-    if (responseBuilder == null) {
-      realChain.eventListener().responseHeadersStart(realChain.call());
-      responseBuilder = httpCodec.readResponseHeaders(false);
+    public CallServerInterceptor(boolean forWebSocket) {
+        this.forWebSocket = forWebSocket;
     }
 
-    Response response = responseBuilder
-        .request(request)
-        .handshake(streamAllocation.connection().handshake())
-        .sentRequestAtMillis(sentRequestMillis)
-        .receivedResponseAtMillis(System.currentTimeMillis())
-        .build();
-
-    int code = response.code();
-    if (code == 100) {
-      // server sent a 100-continue even though we did not request one.
-      // try again to read the actual response
-      responseBuilder = httpCodec.readResponseHeaders(false);
-
-      response = responseBuilder
-              .request(request)
-              .handshake(streamAllocation.connection().handshake())
-              .sentRequestAtMillis(sentRequestMillis)
-              .receivedResponseAtMillis(System.currentTimeMillis())
-              .build();
-
-      code = response.code();
-    }
+    @Override
+    public Response intercept(Chain chain) throws IOException {
+        RealInterceptorChain realChain = (RealInterceptorChain) chain;
+        HttpCodec httpCodec = realChain.httpStream();
+        StreamAllocation streamAllocation = realChain.streamAllocation();
+        RealConnection connection = (RealConnection) realChain.connection();
+        Request request = realChain.request();
+
+        long sentRequestMillis = System.currentTimeMillis();
+
+        realChain.eventListener().requestHeadersStart(realChain.call());
+        httpCodec.writeRequestHeaders(request);
+        realChain.eventListener().requestHeadersEnd(realChain.call(), request);
+
+        Response.Builder responseBuilder = null;
+        if (HttpMethod.permitsRequestBody(request.method()) && request.body() != null) {
+            // If there's a "Expect: 100-continue" header on the request, wait for a "HTTP/1.1 100
+            // Continue" response before transmitting the request body. If we don't get that, return
+            // what we did get (such as a 4xx response) without ever transmitting the request body.
+            if ("100-continue".equalsIgnoreCase(request.header("Expect"))) {
+                httpCodec.flushRequest();
+                realChain.eventListener().responseHeadersStart(realChain.call());
+                responseBuilder = httpCodec.readResponseHeaders(true);
+            }
+
+            if (responseBuilder == null) {
+                // Write the request body if the "Expect: 100-continue" expectation was met.
+                realChain.eventListener().requestBodyStart(realChain.call());
+                long contentLength = request.body().contentLength();
+                CountingSink requestBodyOut =
+                        new CountingSink(httpCodec.createRequestBody(request, contentLength));
+                BufferedSink bufferedRequestBody = Okio.buffer(requestBodyOut);
+
+                request.body().writeTo(bufferedRequestBody);
+                bufferedRequestBody.close();
+                realChain.eventListener()
+                        .requestBodyEnd(realChain.call(), requestBodyOut.successfulCount);
+            } else if (!connection.isMultiplexed()) {
+                // If the "Expect: 100-continue" expectation wasn't met, prevent the HTTP/1 connection
+                // from being reused. Otherwise we're still obligated to transmit the request body to
+                // leave the connection in a consistent state.
+                streamAllocation.noNewStreams();
+            }
+        }
+
+        httpCodec.finishRequest();
+
+        if (responseBuilder == null) {
+            realChain.eventListener().responseHeadersStart(realChain.call());
+            responseBuilder = httpCodec.readResponseHeaders(false);
+        }
+
+        Response response = responseBuilder
+                .request(request)
+                .handshake(streamAllocation.connection().handshake())
+                .sentRequestAtMillis(sentRequestMillis)
+                .receivedResponseAtMillis(System.currentTimeMillis())
+                .build();
+
+        int code = response.code();
+        if (code == 100) {
+            // server sent a 100-continue even though we did not request one.
+            // try again to read the actual response
+            responseBuilder = httpCodec.readResponseHeaders(false);
+
+            response = responseBuilder
+                    .request(request)
+                    .handshake(streamAllocation.connection().handshake())
+                    .sentRequestAtMillis(sentRequestMillis)
+                    .receivedResponseAtMillis(System.currentTimeMillis())
+                    .build();
+
+            code = response.code();
+        }
 
-    realChain.eventListener()
-            .responseHeadersEnd(realChain.call(), response);
-
-    if (forWebSocket && code == 101) {
-      // Connection is upgrading, but we need to ensure interceptors see a non-null response body.
-      response = response.newBuilder()
-          .body(Util.EMPTY_RESPONSE)
-          .build();
-    } else {
-      response = response.newBuilder()
-          .body(httpCodec.openResponseBody(response))
-          .build();
-    }
-
-    if ("close".equalsIgnoreCase(response.request().header("Connection"))
-        || "close".equalsIgnoreCase(response.header("Connection"))) {
-      streamAllocation.noNewStreams();
-    }
-
-    if ((code == 204 || code == 205) && response.body().contentLength() > 0) {
-      throw new ProtocolException(
-          "HTTP " + code + " had non-zero Content-Length: " + response.body().contentLength());
+        realChain.eventListener()
+                .responseHeadersEnd(realChain.call(), response);
+
+        if (forWebSocket && code == 101) {
+            // Connection is upgrading, but we need to ensure interceptors see a non-null response body.
+            response = response.newBuilder()
+                    .body(Util.EMPTY_RESPONSE)
+                    .build();
+        } else {
+            response = response.newBuilder()
+                    .body(httpCodec.openResponseBody(response))
+                    .build();
+        }
+
+        if ("close".equalsIgnoreCase(response.request().header("Connection"))
+                || "close".equalsIgnoreCase(response.header("Connection"))) {
+            streamAllocation.noNewStreams();
+        }
+
+        if ((code == 204 || code == 205) && response.body().contentLength() > 0) {
+            throw new ProtocolException(
+                    "HTTP " + code + " had non-zero Content-Length: " + response.body().contentLength());
+        }
+
+        return response;
     }
 
-    return response;
-  }
-
-  static final class CountingSink extends ForwardingSink {
-    long successfulCount;
+    static final class CountingSink extends ForwardingSink {
+        long successfulCount;
 
-    CountingSink(Sink delegate) {
-      super(delegate);
-    }
+        CountingSink(Sink delegate) {
+            super(delegate);
+        }
 
-    @Override public void write(Buffer source, long byteCount) throws IOException {
-      super.write(source, byteCount);
-      successfulCount += byteCount;
+        @Override
+        public void write(Buffer source, long byteCount) throws IOException {
+            super.write(source, byteCount);
+            successfulCount += byteCount;
+        }
     }
-  }
 }
diff --git a/okhttp/src/main/java/okhttp3/internal/http/RealInterceptorChain.java b/okhttp/src/main/java/okhttp3/internal/http/RealInterceptorChain.java
index 4f4c41082e..ca32df8f40 100644
--- a/okhttp/src/main/java/okhttp3/internal/http/RealInterceptorChain.java
+++ b/okhttp/src/main/java/okhttp3/internal/http/RealInterceptorChain.java
@@ -18,6 +18,7 @@
 import java.io.IOException;
 import java.util.List;
 import java.util.concurrent.TimeUnit;
+
 import okhttp3.Call;
 import okhttp3.Connection;
 import okhttp3.EventListener;
@@ -34,136 +35,149 @@
  * interceptors, the OkHttp core, all network interceptors, and finally the network caller.
  */
 public final class RealInterceptorChain implements Interceptor.Chain {
-  private final List<Interceptor> interceptors;
-  private final StreamAllocation streamAllocation;
-  private final HttpCodec httpCodec;
-  private final RealConnection connection;
-  private final int index;
-  private final Request request;
-  private final Call call;
-  private final EventListener eventListener;
-  private final int connectTimeout;
-  private final int readTimeout;
-  private final int writeTimeout;
-  private int calls;
-
-  public RealInterceptorChain(List<Interceptor> interceptors, StreamAllocation streamAllocation,
-      HttpCodec httpCodec, RealConnection connection, int index, Request request, Call call,
-      EventListener eventListener, int connectTimeout, int readTimeout, int writeTimeout) {
-    this.interceptors = interceptors;
-    this.connection = connection;
-    this.streamAllocation = streamAllocation;
-    this.httpCodec = httpCodec;
-    this.index = index;
-    this.request = request;
-    this.call = call;
-    this.eventListener = eventListener;
-    this.connectTimeout = connectTimeout;
-    this.readTimeout = readTimeout;
-    this.writeTimeout = writeTimeout;
-  }
-
-  @Override public Connection connection() {
-    return connection;
-  }
-
-  @Override public int connectTimeoutMillis() {
-    return connectTimeout;
-  }
-
-  @Override public Interceptor.Chain withConnectTimeout(int timeout, TimeUnit unit) {
-    int millis = checkDuration("timeout", timeout, unit);
-    return new RealInterceptorChain(interceptors, streamAllocation, httpCodec, connection, index,
-        request, call, eventListener, millis, readTimeout, writeTimeout);
-  }
-
-  @Override public int readTimeoutMillis() {
-    return readTimeout;
-  }
-
-  @Override public Interceptor.Chain withReadTimeout(int timeout, TimeUnit unit) {
-    int millis = checkDuration("timeout", timeout, unit);
-    return new RealInterceptorChain(interceptors, streamAllocation, httpCodec, connection, index,
-        request, call, eventListener, connectTimeout, millis, writeTimeout);
-  }
-
-  @Override public int writeTimeoutMillis() {
-    return writeTimeout;
-  }
-
-  @Override public Interceptor.Chain withWriteTimeout(int timeout, TimeUnit unit) {
-    int millis = checkDuration("timeout", timeout, unit);
-    return new RealInterceptorChain(interceptors, streamAllocation, httpCodec, connection, index,
-        request, call, eventListener, connectTimeout, readTimeout, millis);
-  }
-
-  public StreamAllocation streamAllocation() {
-    return streamAllocation;
-  }
-
-  public HttpCodec httpStream() {
-    return httpCodec;
-  }
-
-  @Override public Call call() {
-    return call;
-  }
-
-  public EventListener eventListener() {
-    return eventListener;
-  }
-
-  @Override public Request request() {
-    return request;
-  }
-
-  @Override public Response proceed(Request request) throws IOException {
-    return proceed(request, streamAllocation, httpCodec, connection);
-  }
-
-  public Response proceed(Request request, StreamAllocation streamAllocation, HttpCodec httpCodec,
-      RealConnection connection) throws IOException {
-    if (index >= interceptors.size()) throw new AssertionError();
-
-    calls++;
-
-    // If we already have a stream, confirm that the incoming request will use it.
-    if (this.httpCodec != null && !this.connection.supportsUrl(request.url())) {
-      throw new IllegalStateException("network interceptor " + interceptors.get(index - 1)
-          + " must retain the same host and port");
+    private final List<Interceptor> interceptors;
+    private final StreamAllocation streamAllocation;
+    private final HttpCodec httpCodec;
+    private final RealConnection connection;
+    private final int index;
+    private final Request request;
+    private final Call call;
+    private final EventListener eventListener;
+    private final int connectTimeout;
+    private final int readTimeout;
+    private final int writeTimeout;
+    private int calls;
+
+    public RealInterceptorChain(List<Interceptor> interceptors, StreamAllocation streamAllocation,
+                                HttpCodec httpCodec, RealConnection connection, int index, Request request, Call call,
+                                EventListener eventListener, int connectTimeout, int readTimeout, int writeTimeout) {
+        this.interceptors = interceptors;
+        this.connection = connection;
+        this.streamAllocation = streamAllocation;
+        this.httpCodec = httpCodec;
+        this.index = index;
+        this.request = request;
+        this.call = call;
+        this.eventListener = eventListener;
+        this.connectTimeout = connectTimeout;
+        this.readTimeout = readTimeout;
+        this.writeTimeout = writeTimeout;
+    }
+
+    @Override
+    public Connection connection() {
+        return connection;
+    }
+
+    @Override
+    public int connectTimeoutMillis() {
+        return connectTimeout;
+    }
+
+    @Override
+    public Interceptor.Chain withConnectTimeout(int timeout, TimeUnit unit) {
+        int millis = checkDuration("timeout", timeout, unit);
+        return new RealInterceptorChain(interceptors, streamAllocation, httpCodec, connection, index,
+                request, call, eventListener, millis, readTimeout, writeTimeout);
+    }
+
+    @Override
+    public int readTimeoutMillis() {
+        return readTimeout;
+    }
+
+    @Override
+    public Interceptor.Chain withReadTimeout(int timeout, TimeUnit unit) {
+        int millis = checkDuration("timeout", timeout, unit);
+        return new RealInterceptorChain(interceptors, streamAllocation, httpCodec, connection, index,
+                request, call, eventListener, connectTimeout, millis, writeTimeout);
+    }
+
+    @Override
+    public int writeTimeoutMillis() {
+        return writeTimeout;
+    }
+
+    @Override
+    public Interceptor.Chain withWriteTimeout(int timeout, TimeUnit unit) {
+        int millis = checkDuration("timeout", timeout, unit);
+        return new RealInterceptorChain(interceptors, streamAllocation, httpCodec, connection, index,
+                request, call, eventListener, connectTimeout, readTimeout, millis);
     }
 
-    // If we already have a stream, confirm that this is the only call to chain.proceed().
-    if (this.httpCodec != null && calls > 1) {
-      throw new IllegalStateException("network interceptor " + interceptors.get(index - 1)
-          + " must call proceed() exactly once");
+    public StreamAllocation streamAllocation() {
+        return streamAllocation;
     }
 
-    // Call the next interceptor in the chain.
-    // 创建拦截器链
-    // index+1，访问的时候只能从下一个拦截器访问
-    RealInterceptorChain next = new RealInterceptorChain(interceptors, streamAllocation, httpCodec,
-        connection, index + 1, request, call, eventListener, connectTimeout, readTimeout,
-        writeTimeout);
-    Interceptor interceptor = interceptors.get(index);
-    Response response = interceptor.intercept(next);
-
-    // Confirm that the next interceptor made its required call to chain.proceed().
-    if (httpCodec != null && index + 1 < interceptors.size() && next.calls != 1) {
-      throw new IllegalStateException("network interceptor " + interceptor
-          + " must call proceed() exactly once");
+    public HttpCodec httpStream() {
+        return httpCodec;
     }
 
-    // Confirm that the intercepted response isn't null.
-    if (response == null) {
-      throw new NullPointerException("interceptor " + interceptor + " returned null");
+    @Override
+    public Call call() {
+        return call;
     }
 
-    if (response.body() == null) {
-      throw new IllegalStateException(
-          "interceptor " + interceptor + " returned a response with no body");
+    public EventListener eventListener() {
+        return eventListener;
     }
 
-    return response;
-  }
+    @Override
+    public Request request() {
+        return request;
+    }
+
+    @Override
+    public Response proceed(Request request) throws IOException {
+        return proceed(request, streamAllocation, httpCodec, connection);
+    }
+
+    public Response proceed(Request request, StreamAllocation streamAllocation, HttpCodec httpCodec,
+                            RealConnection connection) throws IOException {
+        if (index >= interceptors.size()) throw new AssertionError();
+
+        calls++;
+
+        // If we already have a stream, confirm that the incoming request will use it.
+        if (this.httpCodec != null && !this.connection.supportsUrl(request.url())) {
+            throw new IllegalStateException("network interceptor " + interceptors.get(index - 1)
+                    + " must retain the same host and port");
+        }
+
+        // If we already have a stream, confirm that this is the only call to chain.proceed().
+        if (this.httpCodec != null && calls > 1) {
+            throw new IllegalStateException("network interceptor " + interceptors.get(index - 1)
+                    + " must call proceed() exactly once");
+        }
+
+        // Call the next interceptor in the chain.
+        // 创建拦截器链
+        // index+1，访问的时候只能从下一个拦截器访问
+        RealInterceptorChain next = new RealInterceptorChain(interceptors, streamAllocation, httpCodec,
+                connection, index + 1, request, call, eventListener, connectTimeout, readTimeout,
+                writeTimeout);
+        // 取出与当前RealInterceptorChain关联的拦截器
+        Interceptor interceptor = interceptors.get(index);
+        // 将之前创建的RealInterceptorChain对象next传入到拦截器中
+        // 这一步的作用就是，责任链模式中为 当前处理器设置下一个处理器的过程
+        Response response = interceptor.intercept(next);
+
+        // Confirm that the next interceptor made its required call to chain.proceed().
+        if (httpCodec != null && index + 1 < interceptors.size() && next.calls != 1) {
+            throw new IllegalStateException("network interceptor " + interceptor
+                    + " must call proceed() exactly once");
+        }
+
+        // Confirm that the intercepted response isn't null.
+        if (response == null) {
+            throw new NullPointerException("interceptor " + interceptor + " returned null");
+        }
+
+        if (response.body() == null) {
+            throw new IllegalStateException(
+                    "interceptor " + interceptor + " returned a response with no body");
+        }
+
+        return response;
+    }
 }
diff --git a/okhttp/src/main/java/okhttp3/internal/http/RetryAndFollowUpInterceptor.java b/okhttp/src/main/java/okhttp3/internal/http/RetryAndFollowUpInterceptor.java
index d682de8bf0..f0c2f91e2a 100644
--- a/okhttp/src/main/java/okhttp3/internal/http/RetryAndFollowUpInterceptor.java
+++ b/okhttp/src/main/java/okhttp3/internal/http/RetryAndFollowUpInterceptor.java
@@ -22,10 +22,12 @@
 import java.net.Proxy;
 import java.net.SocketTimeoutException;
 import java.security.cert.CertificateException;
+
 import javax.net.ssl.HostnameVerifier;
 import javax.net.ssl.SSLHandshakeException;
 import javax.net.ssl.SSLPeerUnverifiedException;
 import javax.net.ssl.SSLSocketFactory;
+
 import okhttp3.Address;
 import okhttp3.Call;
 import okhttp3.CertificatePinner;
@@ -58,359 +60,394 @@
  * {@link IOException} if the call was canceled.
  */
 public final class RetryAndFollowUpInterceptor implements Interceptor {
-  /**
-   * How many redirects and auth challenges should we attempt? Chrome follows 21 redirects; Firefox,
-   * curl, and wget follow 20; Safari follows 16; and HTTP/1.0 recommends 5.
-   */
-  private static final int MAX_FOLLOW_UPS = 20;
-
-  private final OkHttpClient client;
-  private final boolean forWebSocket;
-  private volatile StreamAllocation streamAllocation;
-  private Object callStackTrace;
-  private volatile boolean canceled;
-
-  public RetryAndFollowUpInterceptor(OkHttpClient client, boolean forWebSocket) {
-    this.client = client;
-    this.forWebSocket = forWebSocket;
-  }
-
-  /**
-   * Immediately closes the socket connection if it's currently held. Use this to interrupt an
-   * in-flight request from any thread. It's the caller's responsibility to close the request body
-   * and response body streams; otherwise resources may be leaked.
-   *
-   * <p>This method is safe to be called concurrently, but provides limited guarantees. If a
-   * transport layer connection has been established (such as a HTTP/2 stream) that is terminated.
-   * Otherwise if a socket connection is being established, that is terminated.
-   */
-  public void cancel() {
-    canceled = true;
-    StreamAllocation streamAllocation = this.streamAllocation;
-    if (streamAllocation != null) streamAllocation.cancel();
-  }
-
-  public boolean isCanceled() {
-    return canceled;
-  }
-
-  public void setCallStackTrace(Object callStackTrace) {
-    this.callStackTrace = callStackTrace;
-  }
-
-  public StreamAllocation streamAllocation() {
-    return streamAllocation;
-  }
-
-  @Override public Response intercept(Chain chain) throws IOException {
-    Request request = chain.request();
-    RealInterceptorChain realChain = (RealInterceptorChain) chain;
-    Call call = realChain.call();
-    EventListener eventListener = realChain.eventListener();
-
-    StreamAllocation streamAllocation = new StreamAllocation(client.connectionPool(),
-        createAddress(request.url()), call, eventListener, callStackTrace);
-    this.streamAllocation = streamAllocation;
-
-    int followUpCount = 0;
-    Response priorResponse = null;
-    while (true) {
-      if (canceled) {
-        streamAllocation.release();
-        throw new IOException("Canceled");
-      }
-
-      Response response;
-      boolean releaseConnection = true;
-      try {
-        response = realChain.proceed(request, streamAllocation, null, null);
-        releaseConnection = false;
-      } catch (RouteException e) {
-        // The attempt to connect via a route failed. The request will not have been sent.
-        if (!recover(e.getLastConnectException(), streamAllocation, false, request)) {
-          throw e.getFirstConnectException();
-        }
-        releaseConnection = false;
-        continue;
-      } catch (IOException e) {
-        // An attempt to communicate with a server failed. The request may have been sent.
-        boolean requestSendStarted = !(e instanceof ConnectionShutdownException);
-        if (!recover(e, streamAllocation, requestSendStarted, request)) throw e;
-        releaseConnection = false;
-        continue;
-      } finally {
-        // We're throwing an unchecked exception. Release any resources.
-        if (releaseConnection) {
-          streamAllocation.streamFailed(null);
-          streamAllocation.release();
-        }
-      }
-
-      // Attach the prior response if it exists. Such responses never have a body.
-      if (priorResponse != null) {
-        response = response.newBuilder()
-            .priorResponse(priorResponse.newBuilder()
-                    .body(null)
-                    .build())
-            .build();
-      }
-
-      Request followUp;
-      try {
-        followUp = followUpRequest(response, streamAllocation.route());
-      } catch (IOException e) {
-        streamAllocation.release();
-        throw e;
-      }
-
-      if (followUp == null) {
-        streamAllocation.release();
-        return response;
-      }
-
-      closeQuietly(response.body());
-
-      if (++followUpCount > MAX_FOLLOW_UPS) {
-        streamAllocation.release();
-        throw new ProtocolException("Too many follow-up requests: " + followUpCount);
-      }
-
-      if (followUp.body() instanceof UnrepeatableRequestBody) {
-        streamAllocation.release();
-        throw new HttpRetryException("Cannot retry streamed HTTP body", response.code());
-      }
-
-      if (!sameConnection(response, followUp.url())) {
-        streamAllocation.release();
-        streamAllocation = new StreamAllocation(client.connectionPool(),
-            createAddress(followUp.url()), call, eventListener, callStackTrace);
-        this.streamAllocation = streamAllocation;
-      } else if (streamAllocation.codec() != null) {
-        throw new IllegalStateException("Closing the body of " + response
-            + " didn't close its backing stream. Bad interceptor?");
-      }
-
-      request = followUp;
-      priorResponse = response;
+    /**
+     * How many redirects and auth challenges should we attempt? Chrome follows 21 redirects; Firefox,
+     * curl, and wget follow 20; Safari follows 16; and HTTP/1.0 recommends 5.
+     */
+    private static final int MAX_FOLLOW_UPS = 20;
+
+    private final OkHttpClient client;
+    private final boolean forWebSocket;
+    private volatile StreamAllocation streamAllocation;
+    private Object callStackTrace;
+    private volatile boolean canceled;
+
+    public RetryAndFollowUpInterceptor(OkHttpClient client, boolean forWebSocket) {
+        this.client = client;
+        this.forWebSocket = forWebSocket;
     }
-  }
-
-  private Address createAddress(HttpUrl url) {
-    SSLSocketFactory sslSocketFactory = null;
-    HostnameVerifier hostnameVerifier = null;
-    CertificatePinner certificatePinner = null;
-    if (url.isHttps()) {
-      sslSocketFactory = client.sslSocketFactory();
-      hostnameVerifier = client.hostnameVerifier();
-      certificatePinner = client.certificatePinner();
+
+    /**
+     * Immediately closes the socket connection if it's currently held. Use this to interrupt an
+     * in-flight request from any thread. It's the caller's responsibility to close the request body
+     * and response body streams; otherwise resources may be leaked.
+     * <p>
+     * <p>This method is safe to be called concurrently, but provides limited guarantees. If a
+     * transport layer connection has been established (such as a HTTP/2 stream) that is terminated.
+     * Otherwise if a socket connection is being established, that is terminated.
+     */
+    public void cancel() {
+        canceled = true;
+        StreamAllocation streamAllocation = this.streamAllocation;
+        if (streamAllocation != null) streamAllocation.cancel();
     }
 
-    return new Address(url.host(), url.port(), client.dns(), client.socketFactory(),
-        sslSocketFactory, hostnameVerifier, certificatePinner, client.proxyAuthenticator(),
-        client.proxy(), client.protocols(), client.connectionSpecs(), client.proxySelector());
-  }
-
-  /**
-   * Report and attempt to recover from a failure to communicate with a server. Returns true if
-   * {@code e} is recoverable, or false if the failure is permanent. Requests with a body can only
-   * be recovered if the body is buffered or if the failure occurred before the request has been
-   * sent.
-   */
-  private boolean recover(IOException e, StreamAllocation streamAllocation,
-      boolean requestSendStarted, Request userRequest) {
-    streamAllocation.streamFailed(e);
-
-    // The application layer has forbidden retries.
-    if (!client.retryOnConnectionFailure()) return false;
-
-    // We can't send the request body again.
-    if (requestSendStarted && userRequest.body() instanceof UnrepeatableRequestBody) return false;
-
-    // This exception is fatal.
-    if (!isRecoverable(e, requestSendStarted)) return false;
-
-    // No more routes to attempt.
-    if (!streamAllocation.hasMoreRoutes()) return false;
-
-    // For failure recovery, use the same route selector with a new connection.
-    return true;
-  }
-
-  private boolean isRecoverable(IOException e, boolean requestSendStarted) {
-    // If there was a protocol problem, don't recover.
-    if (e instanceof ProtocolException) {
-      return false;
+    public boolean isCanceled() {
+        return canceled;
     }
 
-    // If there was an interruption don't recover, but if there was a timeout connecting to a route
-    // we should try the next route (if there is one).
-    if (e instanceof InterruptedIOException) {
-      return e instanceof SocketTimeoutException && !requestSendStarted;
+    public void setCallStackTrace(Object callStackTrace) {
+        this.callStackTrace = callStackTrace;
     }
 
-    // Look for known client-side or negotiation errors that are unlikely to be fixed by trying
-    // again with a different route.
-    if (e instanceof SSLHandshakeException) {
-      // If the problem was a CertificateException from the X509TrustManager,
-      // do not retry.
-      if (e.getCause() instanceof CertificateException) {
-        return false;
-      }
+    public StreamAllocation streamAllocation() {
+        return streamAllocation;
     }
-    if (e instanceof SSLPeerUnverifiedException) {
-      // e.g. a certificate pinning error.
-      return false;
+
+    /**
+     *
+     * @param chain - 拦截器链的下一个节点
+     * @return
+     * @throws IOException
+     */
+    @Override
+    public Response intercept(Chain chain) throws IOException {
+        //  获取请求的对象
+        Request request = chain.request();
+        RealInterceptorChain realChain = (RealInterceptorChain) chain;
+        Call call = realChain.call();
+        EventListener eventListener = realChain.eventListener();
+
+        // 创建StreamAllocation对象
+        // 这个实际上是 用来建立执行Http请求的所需要的 网络组件的
+        // 该对象虽然在RetryAndFollowUpInterceptor拦截器中创建，但并没有在这个类中使用。
+        // 真是使用这个对象的是 ConnectInterceptor拦截器
+        // ˙主要用于 1）获取连接服务端的connection 和 2）连接用于服务端进行数据传输的输入输出流
+        StreamAllocation streamAllocation = new StreamAllocation(client.connectionPool(),
+                createAddress(request.url()), call, eventListener, callStackTrace);
+        this.streamAllocation = streamAllocation;
+
+        int followUpCount = 0;
+        Response priorResponse = null;
+        while (true) {
+            // 是否已经被取消
+            if (canceled) {
+                // 是，则释放streamAllocation，并抛出异常
+                streamAllocation.release();
+                throw new IOException("Canceled");
+            }
+
+            Response response;
+            boolean releaseConnection = true;
+            try {
+                // 调用下一个拦截器链节点的proceed方法，让下一个拦截器先去执行请求，并等待响应返回。
+                response = realChain.proceed(request, streamAllocation, null, null);
+                releaseConnection = false;
+            } catch (RouteException e) {
+                // The attempt to connect via a route failed. The request will not have been sent.
+                if (!recover(e.getLastConnectException(), streamAllocation, false, request)) {
+                    throw e.getFirstConnectException();
+                }
+                releaseConnection = false;
+                // 重试
+                continue;
+            } catch (IOException e) {
+                // An attempt to communicate with a server failed. The request may have been sent.
+                // 先判断当前请求是否已经发送了
+                boolean requestSendStarted = !(e instanceof ConnectionShutdownException);
+
+                //同样的重试判断
+                if (!recover(e, streamAllocation, requestSendStarted, request)) throw e;
+                releaseConnection = false;
+
+                // 重试
+                continue;
+            } finally {
+                // We're throwing an unchecked exception. Release any resources.
+                // 没有捕获到的异常，最终要释放
+                if (releaseConnection) {
+                    streamAllocation.streamFailed(null);
+                    streamAllocation.release();
+                }
+            }
+
+            // Attach the prior response if it exists. Such responses never have a body.
+            // priorResponse是用来保存前一个Resposne的，这里可以看到将前一个Response和当前的Resposne结合在一起了，
+            // 对应的场景是，当获得Resposne后，发现需要重定向，则将当前Resposne设置给priorResponse，再执行一遍流程，
+            // 直到不需要重定向了，则将priorResponse和Resposne结合起来。
+            if (priorResponse != null) {
+                response = response.newBuilder()
+                        .priorResponse(priorResponse.newBuilder()
+                                .body(null)
+                                .build())
+                        .build();
+            }
+
+            Request followUp;
+            try {
+                //判断是否需要重定向,如果需要重定向则返回一个重定向的Request，没有则为null
+                followUp = followUpRequest(response, streamAllocation.route());
+            } catch (IOException e) {
+                streamAllocation.release();
+                throw e;
+            }
+
+            if (followUp == null) {
+                //不需要重定向，释放
+                streamAllocation.release();
+                //返回response
+                return response;
+            }
+
+            //需要重定向，关闭响应流
+            closeQuietly(response.body());
+
+            //重定向次数++,并且小于最大重定向次数MAX_FOLLOW_UPS（20）
+            if (++followUpCount > MAX_FOLLOW_UPS) {
+                streamAllocation.release();
+                throw new ProtocolException("Too many follow-up requests: " + followUpCount);
+            }
+
+            //是UnrepeatableRequestBody， 刚才看过也就是是流类型，没有被缓存，不能重定向
+            if (followUp.body() instanceof UnrepeatableRequestBody) {
+                streamAllocation.release();
+                throw new HttpRetryException("Cannot retry streamed HTTP body", response.code());
+            }
+
+            // 判断是否相同，不然重新创建一个streamAllocation
+            if (!sameConnection(response, followUp.url())) {
+                streamAllocation.release();
+                streamAllocation = new StreamAllocation(client.connectionPool(),
+                        createAddress(followUp.url()), call, eventListener, callStackTrace);
+                this.streamAllocation = streamAllocation;
+            } else if (streamAllocation.codec() != null) {
+                throw new IllegalStateException("Closing the body of " + response
+                        + " didn't close its backing stream. Bad interceptor?");
+            }
+
+            //赋值再来！
+            request = followUp;
+            priorResponse = response;
+        }
     }
 
-    // An example of one we might want to retry with a different route is a problem connecting to a
-    // proxy and would manifest as a standard IOException. Unless it is one we know we should not
-    // retry, we return true and try a new route.
-    return true;
-  }
-
-  /**
-   * Figures out the HTTP request to make in response to receiving {@code userResponse}. This will
-   * either add authentication headers, follow redirects or handle a client request timeout. If a
-   * follow-up is either unnecessary or not applicable, this returns null.
-   */
-  private Request followUpRequest(Response userResponse, Route route) throws IOException {
-    if (userResponse == null) throw new IllegalStateException();
-    int responseCode = userResponse.code();
-
-    final String method = userResponse.request().method();
-    switch (responseCode) {
-      case HTTP_PROXY_AUTH:
-        Proxy selectedProxy = route != null
-            ? route.proxy()
-            : client.proxy();
-        if (selectedProxy.type() != Proxy.Type.HTTP) {
-          throw new ProtocolException("Received HTTP_PROXY_AUTH (407) code while not using proxy");
+    private Address createAddress(HttpUrl url) {
+        SSLSocketFactory sslSocketFactory = null;
+        HostnameVerifier hostnameVerifier = null;
+        CertificatePinner certificatePinner = null;
+        if (url.isHttps()) {
+            sslSocketFactory = client.sslSocketFactory();
+            hostnameVerifier = client.hostnameVerifier();
+            certificatePinner = client.certificatePinner();
         }
-        return client.proxyAuthenticator().authenticate(route, userResponse);
 
-      case HTTP_UNAUTHORIZED:
-        return client.authenticator().authenticate(route, userResponse);
+        return new Address(url.host(), url.port(), client.dns(), client.socketFactory(),
+                sslSocketFactory, hostnameVerifier, certificatePinner, client.proxyAuthenticator(),
+                client.proxy(), client.protocols(), client.connectionSpecs(), client.proxySelector());
+    }
 
-      case HTTP_PERM_REDIRECT:
-      case HTTP_TEMP_REDIRECT:
-        // "If the 307 or 308 status code is received in response to a request other than GET
-        // or HEAD, the user agent MUST NOT automatically redirect the request"
-        if (!method.equals("GET") && !method.equals("HEAD")) {
-          return null;
-        }
-        // fall-through
-      case HTTP_MULT_CHOICE:
-      case HTTP_MOVED_PERM:
-      case HTTP_MOVED_TEMP:
-      case HTTP_SEE_OTHER:
-        // Does the client allow redirects?
-        if (!client.followRedirects()) return null;
-
-        String location = userResponse.header("Location");
-        if (location == null) return null;
-        HttpUrl url = userResponse.request().url().resolve(location);
-
-        // Don't follow redirects to unsupported protocols.
-        if (url == null) return null;
-
-        // If configured, don't follow redirects between SSL and non-SSL.
-        boolean sameScheme = url.scheme().equals(userResponse.request().url().scheme());
-        if (!sameScheme && !client.followSslRedirects()) return null;
-
-        // Most redirects don't include a request body.
-        Request.Builder requestBuilder = userResponse.request().newBuilder();
-        if (HttpMethod.permitsRequestBody(method)) {
-          final boolean maintainBody = HttpMethod.redirectsWithBody(method);
-          if (HttpMethod.redirectsToGet(method)) {
-            requestBuilder.method("GET", null);
-          } else {
-            RequestBody requestBody = maintainBody ? userResponse.request().body() : null;
-            requestBuilder.method(method, requestBody);
-          }
-          if (!maintainBody) {
-            requestBuilder.removeHeader("Transfer-Encoding");
-            requestBuilder.removeHeader("Content-Length");
-            requestBuilder.removeHeader("Content-Type");
-          }
-        }
+    /**
+     * Report and attempt to recover from a failure to communicate with a server. Returns true if
+     * {@code e} is recoverable, or false if the failure is permanent. Requests with a body can only
+     * be recovered if the body is buffered or if the failure occurred before the request has been
+     * sent.
+     */
+    private boolean recover(IOException e, StreamAllocation streamAllocation,
+                            boolean requestSendStarted, Request userRequest) {
+        streamAllocation.streamFailed(e);
 
-        // When redirecting across hosts, drop all authentication headers. This
-        // is potentially annoying to the application layer since they have no
-        // way to retain them.
-        if (!sameConnection(userResponse, url)) {
-          requestBuilder.removeHeader("Authorization");
-        }
+        // The application layer has forbidden retries.
+        if (!client.retryOnConnectionFailure()) return false;
 
-        return requestBuilder.url(url).build();
+        // We can't send the request body again.
+        if (requestSendStarted && userRequest.body() instanceof UnrepeatableRequestBody)
+            return false;
 
-      case HTTP_CLIENT_TIMEOUT:
-        // 408's are rare in practice, but some servers like HAProxy use this response code. The
-        // spec says that we may repeat the request without modifications. Modern browsers also
-        // repeat the request (even non-idempotent ones.)
-        if (!client.retryOnConnectionFailure()) {
-          // The application layer has directed us not to retry the request.
-          return null;
-        }
+        // This exception is fatal.
+        if (!isRecoverable(e, requestSendStarted)) return false;
 
-        if (userResponse.request().body() instanceof UnrepeatableRequestBody) {
-          return null;
-        }
+        // No more routes to attempt.
+        if (!streamAllocation.hasMoreRoutes()) return false;
 
-        if (userResponse.priorResponse() != null
-            && userResponse.priorResponse().code() == HTTP_CLIENT_TIMEOUT) {
-          // We attempted to retry and got another timeout. Give up.
-          return null;
-        }
+        // For failure recovery, use the same route selector with a new connection.
+        return true;
+    }
 
-        if (retryAfter(userResponse, 0) > 0) {
-          return null;
+    private boolean isRecoverable(IOException e, boolean requestSendStarted) {
+        // If there was a protocol problem, don't recover.
+        if (e instanceof ProtocolException) {
+            return false;
         }
 
-        return userResponse.request();
-
-      case HTTP_UNAVAILABLE:
-        if (userResponse.priorResponse() != null
-            && userResponse.priorResponse().code() == HTTP_UNAVAILABLE) {
-          // We attempted to retry and got another timeout. Give up.
-          return null;
+        // If there was an interruption don't recover, but if there was a timeout connecting to a route
+        // we should try the next route (if there is one).
+        if (e instanceof InterruptedIOException) {
+            return e instanceof SocketTimeoutException && !requestSendStarted;
         }
 
-        if (retryAfter(userResponse, Integer.MAX_VALUE) == 0) {
-          // specifically received an instruction to retry without delay
-          return userResponse.request();
+        // Look for known client-side or negotiation errors that are unlikely to be fixed by trying
+        // again with a different route.
+        if (e instanceof SSLHandshakeException) {
+            // If the problem was a CertificateException from the X509TrustManager,
+            // do not retry.
+            if (e.getCause() instanceof CertificateException) {
+                return false;
+            }
+        }
+        if (e instanceof SSLPeerUnverifiedException) {
+            // e.g. a certificate pinning error.
+            return false;
         }
 
-        return null;
+        // An example of one we might want to retry with a different route is a problem connecting to a
+        // proxy and would manifest as a standard IOException. Unless it is one we know we should not
+        // retry, we return true and try a new route.
+        return true;
+    }
 
-      default:
-        return null;
+    /**
+     * Figures out the HTTP request to make in response to receiving {@code userResponse}. This will
+     * either add authentication headers, follow redirects or handle a client request timeout. If a
+     * follow-up is either unnecessary or not applicable, this returns null.
+     */
+    private Request followUpRequest(Response userResponse, Route route) throws IOException {
+        if (userResponse == null) throw new IllegalStateException();
+        int responseCode = userResponse.code();
+
+        final String method = userResponse.request().method();
+        switch (responseCode) {
+            case HTTP_PROXY_AUTH:
+                Proxy selectedProxy = route != null
+                        ? route.proxy()
+                        : client.proxy();
+                if (selectedProxy.type() != Proxy.Type.HTTP) {
+                    throw new ProtocolException("Received HTTP_PROXY_AUTH (407) code while not using proxy");
+                }
+                return client.proxyAuthenticator().authenticate(route, userResponse);
+
+            case HTTP_UNAUTHORIZED:
+                return client.authenticator().authenticate(route, userResponse);
+
+            case HTTP_PERM_REDIRECT:
+            case HTTP_TEMP_REDIRECT:
+                // "If the 307 or 308 status code is received in response to a request other than GET
+                // or HEAD, the user agent MUST NOT automatically redirect the request"
+                if (!method.equals("GET") && !method.equals("HEAD")) {
+                    return null;
+                }
+                // fall-through
+            case HTTP_MULT_CHOICE:
+            case HTTP_MOVED_PERM:
+            case HTTP_MOVED_TEMP:
+            case HTTP_SEE_OTHER:
+                // Does the client allow redirects?
+                if (!client.followRedirects()) return null;
+
+                String location = userResponse.header("Location");
+                if (location == null) return null;
+                HttpUrl url = userResponse.request().url().resolve(location);
+
+                // Don't follow redirects to unsupported protocols.
+                if (url == null) return null;
+
+                // If configured, don't follow redirects between SSL and non-SSL.
+                boolean sameScheme = url.scheme().equals(userResponse.request().url().scheme());
+                if (!sameScheme && !client.followSslRedirects()) return null;
+
+                // Most redirects don't include a request body.
+                Request.Builder requestBuilder = userResponse.request().newBuilder();
+                if (HttpMethod.permitsRequestBody(method)) {
+                    final boolean maintainBody = HttpMethod.redirectsWithBody(method);
+                    if (HttpMethod.redirectsToGet(method)) {
+                        requestBuilder.method("GET", null);
+                    } else {
+                        RequestBody requestBody = maintainBody ? userResponse.request().body() : null;
+                        requestBuilder.method(method, requestBody);
+                    }
+                    if (!maintainBody) {
+                        requestBuilder.removeHeader("Transfer-Encoding");
+                        requestBuilder.removeHeader("Content-Length");
+                        requestBuilder.removeHeader("Content-Type");
+                    }
+                }
+
+                // When redirecting across hosts, drop all authentication headers. This
+                // is potentially annoying to the application layer since they have no
+                // way to retain them.
+                if (!sameConnection(userResponse, url)) {
+                    requestBuilder.removeHeader("Authorization");
+                }
+
+                return requestBuilder.url(url).build();
+
+            case HTTP_CLIENT_TIMEOUT:
+                // 408's are rare in practice, but some servers like HAProxy use this response code. The
+                // spec says that we may repeat the request without modifications. Modern browsers also
+                // repeat the request (even non-idempotent ones.)
+                if (!client.retryOnConnectionFailure()) {
+                    // The application layer has directed us not to retry the request.
+                    return null;
+                }
+
+                if (userResponse.request().body() instanceof UnrepeatableRequestBody) {
+                    return null;
+                }
+
+                if (userResponse.priorResponse() != null
+                        && userResponse.priorResponse().code() == HTTP_CLIENT_TIMEOUT) {
+                    // We attempted to retry and got another timeout. Give up.
+                    return null;
+                }
+
+                if (retryAfter(userResponse, 0) > 0) {
+                    return null;
+                }
+
+                return userResponse.request();
+
+            case HTTP_UNAVAILABLE:
+                if (userResponse.priorResponse() != null
+                        && userResponse.priorResponse().code() == HTTP_UNAVAILABLE) {
+                    // We attempted to retry and got another timeout. Give up.
+                    return null;
+                }
+
+                if (retryAfter(userResponse, Integer.MAX_VALUE) == 0) {
+                    // specifically received an instruction to retry without delay
+                    return userResponse.request();
+                }
+
+                return null;
+
+            default:
+                return null;
+        }
     }
-  }
 
-  private int retryAfter(Response userResponse, int defaultDelay) {
-    String header = userResponse.header("Retry-After");
+    private int retryAfter(Response userResponse, int defaultDelay) {
+        String header = userResponse.header("Retry-After");
 
-    if (header == null) {
-      return defaultDelay;
-    }
+        if (header == null) {
+            return defaultDelay;
+        }
 
-    // https://tools.ietf.org/html/rfc7231#section-7.1.3
-    // currently ignores a HTTP-date, and assumes any non int 0 is a delay
-    if (header.matches("\\d+")) {
-      return Integer.valueOf(header);
+        // https://tools.ietf.org/html/rfc7231#section-7.1.3
+        // currently ignores a HTTP-date, and assumes any non int 0 is a delay
+        if (header.matches("\\d+")) {
+            return Integer.valueOf(header);
+        }
+
+        return Integer.MAX_VALUE;
     }
 
-    return Integer.MAX_VALUE;
-  }
-
-  /**
-   * Returns true if an HTTP request for {@code followUp} can reuse the connection used by this
-   * engine.
-   */
-  private boolean sameConnection(Response response, HttpUrl followUp) {
-    HttpUrl url = response.request().url();
-    return url.host().equals(followUp.host())
-        && url.port() == followUp.port()
-        && url.scheme().equals(followUp.scheme());
-  }
+    /**
+     * Returns true if an HTTP request for {@code followUp} can reuse the connection used by this
+     * engine.
+     */
+    private boolean sameConnection(Response response, HttpUrl followUp) {
+        HttpUrl url = response.request().url();
+        return url.host().equals(followUp.host())
+                && url.port() == followUp.port()
+                && url.scheme().equals(followUp.scheme());
+    }
 }
