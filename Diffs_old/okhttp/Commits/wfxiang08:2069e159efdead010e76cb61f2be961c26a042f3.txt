diff --git a/mockwebserver/src/main/java/okhttp3/internal/HeldCertificate.java b/mockwebserver/src/main/java/okhttp3/internal/HeldCertificate.java
index ce79c2817d..d6c45bd30b 100644
--- a/mockwebserver/src/main/java/okhttp3/internal/HeldCertificate.java
+++ b/mockwebserver/src/main/java/okhttp3/internal/HeldCertificate.java
@@ -25,6 +25,8 @@
 import java.util.Date;
 import java.util.UUID;
 import javax.security.auth.x500.X500Principal;
+import org.bouncycastle.asn1.x509.BasicConstraints;
+import org.bouncycastle.asn1.x509.X509Extensions;
 import org.bouncycastle.jce.provider.BouncyCastleProvider;
 import org.bouncycastle.x509.X509V3CertificateGenerator;
 
@@ -52,6 +54,7 @@ public HeldCertificate(X509Certificate certificate, KeyPair keyPair) {
     private String serialNumber = "1";
     private KeyPair keyPair;
     private HeldCertificate issuedBy;
+    private int maxIntermediateCas;
 
     public Builder serialNumber(String serialNumber) {
       this.serialNumber = serialNumber;
@@ -59,10 +62,10 @@ public Builder serialNumber(String serialNumber) {
     }
 
     /**
-     * Set this certificate's hostname. This is the CN (common name) in the certificate. Will be a
-     * random string if no value is provided.
+     * Set this certificate's name. Typically this is the URL hostname for TLS certificates. This is
+     * the CN (common name) in the certificate. Will be a random string if no value is provided.
      */
-    public Builder hostname(String hostname) {
+    public Builder commonName(String hostname) {
       this.hostname = hostname;
       return this;
     }
@@ -81,6 +84,15 @@ public Builder issuedBy(HeldCertificate signedBy) {
       return this;
     }
 
+    /**
+     * Set this certificate to be a certificate authority, with up to {@code maxIntermediateCas}
+     * intermediate certificate authorities beneath it.
+     */
+    public Builder ca(int maxIntermediateCas) {
+      this.maxIntermediateCas = maxIntermediateCas;
+      return this;
+    }
+
     public HeldCertificate build() throws GeneralSecurityException {
       // Subject, public & private keys for this certificate.
       KeyPair heldKeyPair = keyPair != null
@@ -111,6 +123,12 @@ public HeldCertificate build() throws GeneralSecurityException {
       generator.setSubjectDN(subject);
       generator.setPublicKey(heldKeyPair.getPublic());
       generator.setSignatureAlgorithm("SHA256WithRSAEncryption");
+
+      if (maxIntermediateCas > 0) {
+        generator.addExtension(X509Extensions.BasicConstraints, true,
+            new BasicConstraints(maxIntermediateCas));
+      }
+
       X509Certificate certificate = generator.generateX509Certificate(
           signedByKeyPair.getPrivate(), "BC");
       return new HeldCertificate(certificate, heldKeyPair);
diff --git a/mockwebserver/src/main/java/okhttp3/internal/SslContextBuilder.java b/mockwebserver/src/main/java/okhttp3/internal/SslContextBuilder.java
index facbaa45e3..b161e106e2 100644
--- a/mockwebserver/src/main/java/okhttp3/internal/SslContextBuilder.java
+++ b/mockwebserver/src/main/java/okhttp3/internal/SslContextBuilder.java
@@ -23,6 +23,9 @@
 import java.security.KeyStore;
 import java.security.SecureRandom;
 import java.security.cert.Certificate;
+import java.security.cert.X509Certificate;
+import java.util.ArrayList;
+import java.util.List;
 import javax.net.ssl.KeyManagerFactory;
 import javax.net.ssl.SSLContext;
 import javax.net.ssl.TrustManagerFactory;
@@ -36,44 +39,69 @@
  */
 public final class SslContextBuilder {
   private static SSLContext localhost; // Lazily initialized.
-  private final String hostName;
+
+  /** Returns a new SSL context for this host's current localhost address. */
+  public static synchronized SSLContext localhost() {
+    if (localhost != null) return localhost;
+
+    try {
+      // Generate a self-signed cert for the server to serve and the client to trust.
+      HeldCertificate heldCertificate = new HeldCertificate.Builder()
+          .serialNumber("1")
+          .commonName(InetAddress.getByName("localhost").getHostName())
+          .build();
+
+      localhost = new SslContextBuilder()
+          .certificateChain(heldCertificate)
+          .addTrustedCertificate(heldCertificate.certificate)
+          .build();
+
+      return localhost;
+    } catch (GeneralSecurityException e) {
+      throw new RuntimeException(e);
+    } catch (UnknownHostException e) {
+      throw new RuntimeException(e);
+    }
+  }
+
+  private HeldCertificate[] chain;
+  private List<X509Certificate> trustedCertificates = new ArrayList<>();
 
   /**
-   * @param hostName the subject of the host. For TLS this should be the domain name that the client
-   * uses to identify the server.
+   * Configure the certificate chain to use when serving HTTPS responses. The first certificate
+   * in this chain is the server's certificate, further certificates are included in the handshake
+   * so the client can build a trusted path to a CA certificate.
    */
-  public SslContextBuilder(String hostName) {
-    this.hostName = hostName;
+  public SslContextBuilder certificateChain(HeldCertificate... chain) {
+    this.chain = chain;
+    return this;
   }
 
-  /** Returns a new SSL context for this host's current localhost address. */
-  public static synchronized SSLContext localhost() {
-    if (localhost == null) {
-      try {
-        localhost = new SslContextBuilder(InetAddress.getByName("localhost").getHostName()).build();
-      } catch (GeneralSecurityException e) {
-        throw new RuntimeException(e);
-      } catch (UnknownHostException e) {
-        throw new RuntimeException(e);
-      }
-    }
-    return localhost;
+  /**
+   * Add a certificate authority that this client trusts. Servers that provide certificate chains
+   * signed by these roots (or their intermediates) will be accepted.
+   */
+  public SslContextBuilder addTrustedCertificate(X509Certificate certificate) {
+    trustedCertificates.add(certificate);
+    return this;
   }
 
   public SSLContext build() throws GeneralSecurityException {
-    // Generate a self-signed cert for the server to serve and the client to trust.
-    HeldCertificate heldCertificate = new HeldCertificate.Builder()
-        .serialNumber("1")
-        .hostname(hostName)
-        .build();
-
     // Put the certificate in a key store.
     char[] password = "password".toCharArray();
     KeyStore keyStore = newEmptyKeyStore(password);
-    Certificate[] certificateChain = {heldCertificate.certificate};
-    keyStore.setKeyEntry("private",
-        heldCertificate.keyPair.getPrivate(), password, certificateChain);
-    keyStore.setCertificateEntry("cert", heldCertificate.certificate);
+
+    if (chain != null) {
+      Certificate[] certificates = new Certificate[chain.length];
+      for (int i = 0; i < chain.length; i++) {
+        certificates[i] = chain[i].certificate;
+      }
+      keyStore.setKeyEntry("private", chain[0].keyPair.getPrivate(), password, certificates);
+    }
+
+    for (int i = 0; i < trustedCertificates.size(); i++) {
+      keyStore.setCertificateEntry("cert_" + i, trustedCertificates.get(i));
+    }
 
     // Wrap it up in an SSL context.
     KeyManagerFactory keyManagerFactory =
