diff --git a/okhttp/src/main/java/okhttp3/internal/http/RetryAndFollowUpInterceptor.java b/okhttp/src/main/java/okhttp3/internal/http/RetryAndFollowUpInterceptor.java
index 2a7cd13822..b3a744e4b0 100644
--- a/okhttp/src/main/java/okhttp3/internal/http/RetryAndFollowUpInterceptor.java
+++ b/okhttp/src/main/java/okhttp3/internal/http/RetryAndFollowUpInterceptor.java
@@ -137,6 +137,8 @@ public StreamAllocation streamAllocation() {
       }
 
       // Attach the prior response if it exists. Such responses never have a body.
+      // 上一次请求返回的重定向响应结果
+      // 第一次为null，如果发生了重定向，就不为null
       if (priorResponse != null) {
         response = response.newBuilder()
             .priorResponse(priorResponse.newBuilder()
@@ -145,9 +147,11 @@ public StreamAllocation streamAllocation() {
             .build();
       }
 
+      // 判断是否需要重定向
       Request followUp = followUpRequest(response);
 
       if (followUp == null) {
+        // 如果不需要重定向，就直接返回结果
         if (!forWebSocket) {
           streamAllocation.release();
         }
@@ -156,6 +160,7 @@ public StreamAllocation streamAllocation() {
 
       closeQuietly(response.body());
 
+      // 判断重定向次数是否超过限制
       if (++followUpCount > MAX_FOLLOW_UPS) {
         streamAllocation.release();
         throw new ProtocolException("Too many follow-up requests: " + followUpCount);
@@ -166,6 +171,7 @@ public StreamAllocation streamAllocation() {
         throw new HttpRetryException("Cannot retry streamed HTTP body", response.code());
       }
 
+      // 判断重定向Url跟原来的Url是否一致，如果不一致，需要重新构建StreamAllocation
       if (!sameConnection(response, followUp.url())) {
         streamAllocation.release();
         streamAllocation = new StreamAllocation(
