diff --git a/okhttp/src/main/java/okhttp3/ConnectionPool.java b/okhttp/src/main/java/okhttp3/ConnectionPool.java
index 68d89f3981..762326a75b 100644
--- a/okhttp/src/main/java/okhttp3/ConnectionPool.java
+++ b/okhttp/src/main/java/okhttp3/ConnectionPool.java
@@ -49,6 +49,7 @@
      * Background threads are used to cleanup expired connections. There will be at most a single
      * thread running per connection pool. The thread pool executor permits the pool itself to be
      * garbage collected.
+     * 用于清理空闲连接
      */
     private static final Executor executor = new ThreadPoolExecutor(0 /* corePoolSize */,
             Integer.MAX_VALUE /* maximumPoolSize */, 60L /* keepAliveTime */, TimeUnit.SECONDS,
@@ -128,6 +129,7 @@ public synchronized int connectionCount() {
      * {@code route} is the resolved route for a connection.
      */
     void acquire(Address address, StreamAllocation streamAllocation, @Nullable Route route) {
+        // This method is designed to allow a program to assert that the current thread already holds a specified lock:
         assert (Thread.holdsLock(this));
         for (RealConnection connection : connections) {
             if (connection.isEligible(address, route)) {
@@ -221,7 +223,7 @@ long cleanup(long now) {
             for (Iterator<RealConnection> i = connections.iterator(); i.hasNext(); ) {
                 RealConnection connection = i.next();
 
-                // If the connection is in use, keep searching.
+                // If the connection is in use, keep searching.如果连接仍在使用，继续搜索
                 if (pruneAndGetAllocationCount(connection, now) > 0) {
                     inUseConnectionCount++;
                     continue;
diff --git a/okhttp/src/main/java/okhttp3/internal/connection/RealConnection.java b/okhttp/src/main/java/okhttp3/internal/connection/RealConnection.java
index d087e5da65..3c621721e0 100644
--- a/okhttp/src/main/java/okhttp3/internal/connection/RealConnection.java
+++ b/okhttp/src/main/java/okhttp3/internal/connection/RealConnection.java
@@ -31,11 +31,13 @@
 import java.util.ArrayList;
 import java.util.List;
 import java.util.concurrent.TimeUnit;
+
 import javax.annotation.Nullable;
 import javax.net.ssl.SSLPeerUnverifiedException;
 import javax.net.ssl.SSLSession;
 import javax.net.ssl.SSLSocket;
 import javax.net.ssl.SSLSocketFactory;
+
 import okhttp3.Address;
 import okhttp3.Call;
 import okhttp3.CertificatePinner;
@@ -75,553 +77,585 @@
 import static okhttp3.internal.Util.closeQuietly;
 
 public final class RealConnection extends Http2Connection.Listener implements Connection {
-  private static final String NPE_THROW_WITH_NULL = "throw with null exception";
-  private static final int MAX_TUNNEL_ATTEMPTS = 21;
-
-  private final ConnectionPool connectionPool;
-  private final Route route;
-
-  // The fields below are initialized by connect() and never reassigned.
-
-  /** The low-level TCP socket. */
-  private Socket rawSocket;
-
-  /**
-   * The application layer socket. Either an {@link SSLSocket} layered over {@link #rawSocket}, or
-   * {@link #rawSocket} itself if this connection does not use SSL.
-   */
-  private Socket socket;
-  private Handshake handshake;
-  private Protocol protocol;
-  private Http2Connection http2Connection;
-  private BufferedSource source;
-  private BufferedSink sink;
-
-  // The fields below track connection state and are guarded by connectionPool.
-
-  /** If true, no new streams can be created on this connection. Once true this is always true. */
-  public boolean noNewStreams;
-
-  public int successCount;
-
-  /**
-   * The maximum number of concurrent streams that can be carried by this connection. If {@code
-   * allocations.size() < allocationLimit} then new streams can be created on this connection.
-   */
-  public int allocationLimit = 1;
-
-  /** Current streams carried by this connection. */
-  public final List<Reference<StreamAllocation>> allocations = new ArrayList<>();
-
-  /** Nanotime timestamp when {@code allocations.size()} reached zero. */
-  public long idleAtNanos = Long.MAX_VALUE;
-
-  public RealConnection(ConnectionPool connectionPool, Route route) {
-    this.connectionPool = connectionPool;
-    this.route = route;
-  }
-
-  public static RealConnection testConnection(
-      ConnectionPool connectionPool, Route route, Socket socket, long idleAtNanos) {
-    RealConnection result = new RealConnection(connectionPool, route);
-    result.socket = socket;
-    result.idleAtNanos = idleAtNanos;
-    return result;
-  }
-
-  public void connect(int connectTimeout, int readTimeout, int writeTimeout,
-      int pingIntervalMillis, boolean connectionRetryEnabled, Call call,
-      EventListener eventListener) {
-    if (protocol != null) throw new IllegalStateException("already connected");
-
-    RouteException routeException = null;
-    List<ConnectionSpec> connectionSpecs = route.address().connectionSpecs();
-    ConnectionSpecSelector connectionSpecSelector = new ConnectionSpecSelector(connectionSpecs);
-
-    if (route.address().sslSocketFactory() == null) {
-      if (!connectionSpecs.contains(ConnectionSpec.CLEARTEXT)) {
-        throw new RouteException(new UnknownServiceException(
-            "CLEARTEXT communication not enabled for client"));
-      }
-      String host = route.address().url().host();
-      if (!Platform.get().isCleartextTrafficPermitted(host)) {
-        throw new RouteException(new UnknownServiceException(
-            "CLEARTEXT communication to " + host + " not permitted by network security policy"));
-      }
-    } else {
-      if (route.address().protocols().contains(Protocol.H2_PRIOR_KNOWLEDGE)) {
-        throw new RouteException(new UnknownServiceException(
-            "H2_PRIOR_KNOWLEDGE cannot be used with HTTPS"));
-      }
+    private static final String NPE_THROW_WITH_NULL = "throw with null exception";
+    private static final int MAX_TUNNEL_ATTEMPTS = 21;
+
+    private final ConnectionPool connectionPool;
+    private final Route route;
+
+    // The fields below are initialized by connect() and never reassigned.
+
+    /**
+     * The low-level TCP socket.
+     */
+    private Socket rawSocket;
+
+    /**
+     * The application layer socket. Either an {@link SSLSocket} layered over {@link #rawSocket}, or
+     * {@link #rawSocket} itself if this connection does not use SSL.
+     */
+    private Socket socket;
+    private Handshake handshake;
+    private Protocol protocol;
+    private Http2Connection http2Connection;
+    private BufferedSource source;
+    private BufferedSink sink;
+
+    // The fields below track connection state and are guarded by connectionPool.
+
+    /**
+     * If true, no new streams can be created on this connection. Once true this is always true.
+     */
+    public boolean noNewStreams;
+
+    public int successCount;
+
+    /**
+     * The maximum number of concurrent streams that can be carried by this connection. If {@code
+     * allocations.size() < allocationLimit} then new streams can be created on this connection.
+     */
+    public int allocationLimit = 1;
+
+    /**
+     * Current streams carried by this connection.
+     */
+    public final List<Reference<StreamAllocation>> allocations = new ArrayList<>();
+
+    /**
+     * Nanotime timestamp when {@code allocations.size()} reached zero.
+     */
+    public long idleAtNanos = Long.MAX_VALUE;
+
+    public RealConnection(ConnectionPool connectionPool, Route route) {
+        this.connectionPool = connectionPool;
+        this.route = route;
+    }
+
+    public static RealConnection testConnection(
+            ConnectionPool connectionPool, Route route, Socket socket, long idleAtNanos) {
+        RealConnection result = new RealConnection(connectionPool, route);
+        result.socket = socket;
+        result.idleAtNanos = idleAtNanos;
+        return result;
     }
 
-    while (true) {
-      try {
-        if (route.requiresTunnel()) {
-          connectTunnel(connectTimeout, readTimeout, writeTimeout, call, eventListener);
-          if (rawSocket == null) {
-            // We were unable to connect the tunnel but properly closed down our resources.
-            break;
-          }
+    public void connect(int connectTimeout,
+                        int readTimeout,
+                        int writeTimeout,
+                        int pingIntervalMillis,
+                        boolean connectionRetryEnabled,
+                        Call call,
+                        EventListener eventListener) {
+        if (protocol != null) throw new IllegalStateException("already connected");
+
+        RouteException routeException = null;
+        List<ConnectionSpec> connectionSpecs = route.address().connectionSpecs();
+        ConnectionSpecSelector connectionSpecSelector = new ConnectionSpecSelector(connectionSpecs);
+
+        if (route.address().sslSocketFactory() == null) {
+            if (!connectionSpecs.contains(ConnectionSpec.CLEARTEXT)) {
+                throw new RouteException(new UnknownServiceException(
+                        "CLEARTEXT communication not enabled for client"));
+            }
+            String host = route.address().url().host();
+            if (!Platform.get().isCleartextTrafficPermitted(host)) {
+                throw new RouteException(new UnknownServiceException(
+                        "CLEARTEXT communication to " + host + " not permitted by network security policy"));
+            }
         } else {
-          connectSocket(connectTimeout, readTimeout, call, eventListener);
+            if (route.address().protocols().contains(Protocol.H2_PRIOR_KNOWLEDGE)) {
+                throw new RouteException(new UnknownServiceException(
+                        "H2_PRIOR_KNOWLEDGE cannot be used with HTTPS"));
+            }
         }
-        establishProtocol(connectionSpecSelector, pingIntervalMillis, call, eventListener);
-        eventListener.connectEnd(call, route.socketAddress(), route.proxy(), protocol);
-        break;
-      } catch (IOException e) {
-        closeQuietly(socket);
-        closeQuietly(rawSocket);
-        socket = null;
-        rawSocket = null;
-        source = null;
-        sink = null;
-        handshake = null;
-        protocol = null;
-        http2Connection = null;
-
-        eventListener.connectFailed(call, route.socketAddress(), route.proxy(), null, e);
-
-        if (routeException == null) {
-          routeException = new RouteException(e);
-        } else {
-          routeException.addConnectException(e);
+
+        while (true) {
+            try {
+                if (route.requiresTunnel()) {
+                    // 如果是https并且使用了代理
+                    connectTunnel(connectTimeout, readTimeout, writeTimeout, call, eventListener);
+                    if (rawSocket == null) {
+                        // We were unable to connect the tunnel but properly closed down our resources.
+                        break;
+                    }
+                } else {
+                    // 直接建立socket链接
+                    connectSocket(connectTimeout, readTimeout, call, eventListener);
+                }
+                establishProtocol(connectionSpecSelector, pingIntervalMillis, call, eventListener);
+                eventListener.connectEnd(call, route.socketAddress(), route.proxy(), protocol);
+                break;
+            } catch (IOException e) {
+                closeQuietly(socket);
+                closeQuietly(rawSocket);
+                socket = null;
+                rawSocket = null;
+                source = null;
+                sink = null;
+                handshake = null;
+                protocol = null;
+                http2Connection = null;
+
+                eventListener.connectFailed(call, route.socketAddress(), route.proxy(), null, e);
+
+                if (routeException == null) {
+                    routeException = new RouteException(e);
+                } else {
+                    routeException.addConnectException(e);
+                }
+
+                if (!connectionRetryEnabled || !connectionSpecSelector.connectionFailed(e)) {
+                    throw routeException;
+                }
+            }
         }
 
-        if (!connectionRetryEnabled || !connectionSpecSelector.connectionFailed(e)) {
-          throw routeException;
+        if (route.requiresTunnel() && rawSocket == null) {
+            ProtocolException exception = new ProtocolException("Too many tunnel connections attempted: "
+                    + MAX_TUNNEL_ATTEMPTS);
+            throw new RouteException(exception);
         }
-      }
-    }
 
-    if (route.requiresTunnel() && rawSocket == null) {
-      ProtocolException exception = new ProtocolException("Too many tunnel connections attempted: "
-          + MAX_TUNNEL_ATTEMPTS);
-      throw new RouteException(exception);
+        if (http2Connection != null) {
+            synchronized (connectionPool) {
+                allocationLimit = http2Connection.maxConcurrentStreams();
+            }
+        }
     }
 
-    if (http2Connection != null) {
-      synchronized (connectionPool) {
-        allocationLimit = http2Connection.maxConcurrentStreams();
-      }
+    /**
+     * Does all the work to build an HTTPS connection over a proxy tunnel. The catch here is that a
+     * proxy server can issue an auth challenge and then close the connection.
+     */
+    private void connectTunnel(int connectTimeout, int readTimeout, int writeTimeout, Call call,
+                               EventListener eventListener) throws IOException {
+        Request tunnelRequest = createTunnelRequest();
+        HttpUrl url = tunnelRequest.url();
+        for (int i = 0; i < MAX_TUNNEL_ATTEMPTS; i++) {
+            connectSocket(connectTimeout, readTimeout, call, eventListener);
+            tunnelRequest = createTunnel(readTimeout, writeTimeout, tunnelRequest, url);
+
+            if (tunnelRequest == null) break; // Tunnel successfully created.
+
+            // The proxy decided to close the connection after an auth challenge. We need to create a new
+            // connection, but this time with the auth credentials.
+            closeQuietly(rawSocket);
+            rawSocket = null;
+            sink = null;
+            source = null;
+            eventListener.connectEnd(call, route.socketAddress(), route.proxy(), null);
+        }
     }
-  }
-
-  /**
-   * Does all the work to build an HTTPS connection over a proxy tunnel. The catch here is that a
-   * proxy server can issue an auth challenge and then close the connection.
-   */
-  private void connectTunnel(int connectTimeout, int readTimeout, int writeTimeout, Call call,
-      EventListener eventListener) throws IOException {
-    Request tunnelRequest = createTunnelRequest();
-    HttpUrl url = tunnelRequest.url();
-    for (int i = 0; i < MAX_TUNNEL_ATTEMPTS; i++) {
-      connectSocket(connectTimeout, readTimeout, call, eventListener);
-      tunnelRequest = createTunnel(readTimeout, writeTimeout, tunnelRequest, url);
-
-      if (tunnelRequest == null) break; // Tunnel successfully created.
-
-      // The proxy decided to close the connection after an auth challenge. We need to create a new
-      // connection, but this time with the auth credentials.
-      closeQuietly(rawSocket);
-      rawSocket = null;
-      sink = null;
-      source = null;
-      eventListener.connectEnd(call, route.socketAddress(), route.proxy(), null);
+
+    /**
+     * Does all the work necessary to build a full HTTP or HTTPS connection on a raw socket.
+     */
+    private void connectSocket(int connectTimeout, int readTimeout, Call call,
+                               EventListener eventListener) throws IOException {
+        Proxy proxy = route.proxy();
+        Address address = route.address();
+
+        rawSocket = proxy.type() == Proxy.Type.DIRECT || proxy.type() == Proxy.Type.HTTP
+                ? address.socketFactory().createSocket()
+                : new Socket(proxy);
+
+        eventListener.connectStart(call, route.socketAddress(), proxy);
+        rawSocket.setSoTimeout(readTimeout);
+        try {
+            // 打开socket连接
+            Platform.get().connectSocket(rawSocket, route.socketAddress(), connectTimeout);
+        } catch (ConnectException e) {
+            ConnectException ce = new ConnectException("Failed to connect to " + route.socketAddress());
+            ce.initCause(e);
+            throw ce;
+        }
+
+        // The following try/catch block is a pseudo hacky way to get around a crash on Android 7.0
+        // More details:
+        // https://github.com/square/okhttp/issues/3245
+        // https://android-review.googlesource.com/#/c/271775/
+        try {
+            source = Okio.buffer(Okio.source(rawSocket));
+            sink = Okio.buffer(Okio.sink(rawSocket));
+        } catch (NullPointerException npe) {
+            if (NPE_THROW_WITH_NULL.equals(npe.getMessage())) {
+                throw new IOException(npe);
+            }
+        }
     }
-  }
-
-  /** Does all the work necessary to build a full HTTP or HTTPS connection on a raw socket. */
-  private void connectSocket(int connectTimeout, int readTimeout, Call call,
-      EventListener eventListener) throws IOException {
-    Proxy proxy = route.proxy();
-    Address address = route.address();
-
-    rawSocket = proxy.type() == Proxy.Type.DIRECT || proxy.type() == Proxy.Type.HTTP
-        ? address.socketFactory().createSocket()
-        : new Socket(proxy);
-
-    eventListener.connectStart(call, route.socketAddress(), proxy);
-    rawSocket.setSoTimeout(readTimeout);
-    try {
-      Platform.get().connectSocket(rawSocket, route.socketAddress(), connectTimeout);
-    } catch (ConnectException e) {
-      ConnectException ce = new ConnectException("Failed to connect to " + route.socketAddress());
-      ce.initCause(e);
-      throw ce;
+
+    private void establishProtocol(ConnectionSpecSelector connectionSpecSelector,
+                                   int pingIntervalMillis, Call call, EventListener eventListener) throws IOException {
+        if (route.address().sslSocketFactory() == null) {
+            if (route.address().protocols().contains(Protocol.H2_PRIOR_KNOWLEDGE)) {
+                socket = rawSocket;
+                protocol = Protocol.H2_PRIOR_KNOWLEDGE;
+                startHttp2(pingIntervalMillis);
+                return;
+            }
+
+            socket = rawSocket;
+            protocol = Protocol.HTTP_1_1;
+            return;
+        }
+
+        eventListener.secureConnectStart(call);
+        connectTls(connectionSpecSelector);
+        eventListener.secureConnectEnd(call, handshake);
+
+        if (protocol == Protocol.HTTP_2) {
+            startHttp2(pingIntervalMillis);
+        }
     }
 
-    // The following try/catch block is a pseudo hacky way to get around a crash on Android 7.0
-    // More details:
-    // https://github.com/square/okhttp/issues/3245
-    // https://android-review.googlesource.com/#/c/271775/
-    try {
-      source = Okio.buffer(Okio.source(rawSocket));
-      sink = Okio.buffer(Okio.sink(rawSocket));
-    } catch (NullPointerException npe) {
-      if (NPE_THROW_WITH_NULL.equals(npe.getMessage())) {
-        throw new IOException(npe);
-      }
+    private void startHttp2(int pingIntervalMillis) throws IOException {
+        socket.setSoTimeout(0); // HTTP/2 connection timeouts are set per-stream.
+        http2Connection = new Http2Connection.Builder(true)
+                .socket(socket, route.address().url().host(), source, sink)
+                .listener(this)
+                .pingIntervalMillis(pingIntervalMillis)
+                .build();
+        http2Connection.start();
     }
-  }
-
-  private void establishProtocol(ConnectionSpecSelector connectionSpecSelector,
-      int pingIntervalMillis, Call call, EventListener eventListener) throws IOException {
-    if (route.address().sslSocketFactory() == null) {
-      if (route.address().protocols().contains(Protocol.H2_PRIOR_KNOWLEDGE)) {
-        socket = rawSocket;
-        protocol = Protocol.H2_PRIOR_KNOWLEDGE;
-        startHttp2(pingIntervalMillis);
-        return;
-      }
-
-      socket = rawSocket;
-      protocol = Protocol.HTTP_1_1;
-      return;
+
+    private void connectTls(ConnectionSpecSelector connectionSpecSelector) throws IOException {
+        Address address = route.address();
+        SSLSocketFactory sslSocketFactory = address.sslSocketFactory();
+        boolean success = false;
+        SSLSocket sslSocket = null;
+        try {
+            // Create the wrapper over the connected socket.
+            sslSocket = (SSLSocket) sslSocketFactory.createSocket(
+                    rawSocket, address.url().host(), address.url().port(), true /* autoClose */);
+
+            // Configure the socket's ciphers, TLS versions, and extensions.
+            ConnectionSpec connectionSpec = connectionSpecSelector.configureSecureSocket(sslSocket);
+            if (connectionSpec.supportsTlsExtensions()) {
+                Platform.get().configureTlsExtensions(
+                        sslSocket, address.url().host(), address.protocols());
+            }
+
+            // Force handshake. This can throw!
+            sslSocket.startHandshake();
+            // block for session establishment
+            SSLSession sslSocketSession = sslSocket.getSession();
+            Handshake unverifiedHandshake = Handshake.get(sslSocketSession);
+
+            // Verify that the socket's certificates are acceptable for the target host.
+            if (!address.hostnameVerifier().verify(address.url().host(), sslSocketSession)) {
+                List<Certificate> peerCertificates = unverifiedHandshake.peerCertificates();
+                if (!peerCertificates.isEmpty()) {
+                    X509Certificate cert = (X509Certificate) peerCertificates.get(0);
+                    throw new SSLPeerUnverifiedException(
+                            "Hostname " + address.url().host() + " not verified:"
+                                    + "\n    certificate: " + CertificatePinner.pin(cert)
+                                    + "\n    DN: " + cert.getSubjectDN().getName()
+                                    + "\n    subjectAltNames: " + OkHostnameVerifier.allSubjectAltNames(cert));
+                } else {
+                    throw new SSLPeerUnverifiedException(
+                            "Hostname " + address.url().host() + " not verified (no certificates)");
+                }
+            }
+
+            // Check that the certificate pinner is satisfied by the certificates presented.
+            address.certificatePinner().check(address.url().host(),
+                    unverifiedHandshake.peerCertificates());
+
+            // Success! Save the handshake and the ALPN protocol.
+            String maybeProtocol = connectionSpec.supportsTlsExtensions()
+                    ? Platform.get().getSelectedProtocol(sslSocket)
+                    : null;
+            socket = sslSocket;
+            source = Okio.buffer(Okio.source(socket));
+            sink = Okio.buffer(Okio.sink(socket));
+            handshake = unverifiedHandshake;
+            protocol = maybeProtocol != null
+                    ? Protocol.get(maybeProtocol)
+                    : Protocol.HTTP_1_1;
+            success = true;
+        } catch (AssertionError e) {
+            if (Util.isAndroidGetsocknameError(e)) throw new IOException(e);
+            throw e;
+        } finally {
+            if (sslSocket != null) {
+                Platform.get().afterHandshake(sslSocket);
+            }
+            if (!success) {
+                closeQuietly(sslSocket);
+            }
+        }
     }
 
-    eventListener.secureConnectStart(call);
-    connectTls(connectionSpecSelector);
-    eventListener.secureConnectEnd(call, handshake);
+    /**
+     * To make an HTTPS connection over an HTTP proxy, send an unencrypted CONNECT request to create
+     * the proxy connection. This may need to be retried if the proxy requires authorization.
+     */
+    private Request createTunnel(int readTimeout, int writeTimeout, Request tunnelRequest,
+                                 HttpUrl url) throws IOException {
+        // Make an SSL Tunnel on the first message pair of each SSL + proxy connection.
+        String requestLine = "CONNECT " + Util.hostHeader(url, true) + " HTTP/1.1";
+        while (true) {
+            Http1Codec tunnelConnection = new Http1Codec(null, null, source, sink);
+            source.timeout().timeout(readTimeout, MILLISECONDS);
+            sink.timeout().timeout(writeTimeout, MILLISECONDS);
+            tunnelConnection.writeRequest(tunnelRequest.headers(), requestLine);
+            tunnelConnection.finishRequest();
+            Response response = tunnelConnection.readResponseHeaders(false)
+                    .request(tunnelRequest)
+                    .build();
+            // The response body from a CONNECT should be empty, but if it is not then we should consume
+            // it before proceeding.
+            long contentLength = HttpHeaders.contentLength(response);
+            if (contentLength == -1L) {
+                contentLength = 0L;
+            }
+            Source body = tunnelConnection.newFixedLengthSource(contentLength);
+            Util.skipAll(body, Integer.MAX_VALUE, TimeUnit.MILLISECONDS);
+            body.close();
+
+            switch (response.code()) {
+                case HTTP_OK:
+                    // Assume the server won't send a TLS ServerHello until we send a TLS ClientHello. If
+                    // that happens, then we will have buffered bytes that are needed by the SSLSocket!
+                    // This check is imperfect: it doesn't tell us whether a handshake will succeed, just
+                    // that it will almost certainly fail because the proxy has sent unexpected data.
+                    if (!source.getBuffer().exhausted() || !sink.buffer().exhausted()) {
+                        throw new IOException("TLS tunnel buffered too many bytes!");
+                    }
+                    return null;
+
+                case HTTP_PROXY_AUTH:
+                    tunnelRequest = route.address().proxyAuthenticator().authenticate(route, response);
+                    if (tunnelRequest == null)
+                        throw new IOException("Failed to authenticate with proxy");
+
+                    if ("close".equalsIgnoreCase(response.header("Connection"))) {
+                        return tunnelRequest;
+                    }
+                    break;
+
+                default:
+                    throw new IOException(
+                            "Unexpected response code for CONNECT: " + response.code());
+            }
+        }
+    }
 
-    if (protocol == Protocol.HTTP_2) {
-      startHttp2(pingIntervalMillis);
+    /**
+     * Returns a request that creates a TLS tunnel via an HTTP proxy. Everything in the tunnel request
+     * is sent unencrypted to the proxy server, so tunnels include only the minimum set of headers.
+     * This avoids sending potentially sensitive data like HTTP cookies to the proxy unencrypted.
+     * <p>
+     * <p>In order to support preemptive authentication we pass a fake “Auth Failed” response to the
+     * authenticator. This gives the authenticator the option to customize the CONNECT request. It can
+     * decline to do so by returning null, in which case OkHttp will use it as-is
+     */
+    private Request createTunnelRequest() throws IOException {
+        Request proxyConnectRequest = new Request.Builder()
+                .url(route.address().url())
+                .method("CONNECT", null)
+                .header("Host", Util.hostHeader(route.address().url(), true))
+                .header("Proxy-Connection", "Keep-Alive") // For HTTP/1.0 proxies like Squid.
+                .header("User-Agent", Version.userAgent())
+                .build();
+
+        Response fakeAuthChallengeResponse = new Response.Builder()
+                .request(proxyConnectRequest)
+                .protocol(Protocol.HTTP_1_1)
+                .code(HttpURLConnection.HTTP_PROXY_AUTH)
+                .message("Preemptive Authenticate")
+                .body(Util.EMPTY_RESPONSE)
+                .sentRequestAtMillis(-1L)
+                .receivedResponseAtMillis(-1L)
+                .header("Proxy-Authenticate", "OkHttp-Preemptive")
+                .build();
+
+        Request authenticatedRequest = route.address().proxyAuthenticator()
+                .authenticate(route, fakeAuthChallengeResponse);
+
+        return authenticatedRequest != null
+                ? authenticatedRequest
+                : proxyConnectRequest;
     }
-  }
-
-  private void startHttp2(int pingIntervalMillis) throws IOException {
-    socket.setSoTimeout(0); // HTTP/2 connection timeouts are set per-stream.
-    http2Connection = new Http2Connection.Builder(true)
-        .socket(socket, route.address().url().host(), source, sink)
-        .listener(this)
-        .pingIntervalMillis(pingIntervalMillis)
-        .build();
-    http2Connection.start();
-  }
-
-  private void connectTls(ConnectionSpecSelector connectionSpecSelector) throws IOException {
-    Address address = route.address();
-    SSLSocketFactory sslSocketFactory = address.sslSocketFactory();
-    boolean success = false;
-    SSLSocket sslSocket = null;
-    try {
-      // Create the wrapper over the connected socket.
-      sslSocket = (SSLSocket) sslSocketFactory.createSocket(
-          rawSocket, address.url().host(), address.url().port(), true /* autoClose */);
-
-      // Configure the socket's ciphers, TLS versions, and extensions.
-      ConnectionSpec connectionSpec = connectionSpecSelector.configureSecureSocket(sslSocket);
-      if (connectionSpec.supportsTlsExtensions()) {
-        Platform.get().configureTlsExtensions(
-            sslSocket, address.url().host(), address.protocols());
-      }
-
-      // Force handshake. This can throw!
-      sslSocket.startHandshake();
-      // block for session establishment
-      SSLSession sslSocketSession = sslSocket.getSession();
-      Handshake unverifiedHandshake = Handshake.get(sslSocketSession);
-
-      // Verify that the socket's certificates are acceptable for the target host.
-      if (!address.hostnameVerifier().verify(address.url().host(), sslSocketSession)) {
-        List<Certificate> peerCertificates = unverifiedHandshake.peerCertificates();
-        if (!peerCertificates.isEmpty()) {
-          X509Certificate cert = (X509Certificate) peerCertificates.get(0);
-          throw new SSLPeerUnverifiedException(
-              "Hostname " + address.url().host() + " not verified:"
-                  + "\n    certificate: " + CertificatePinner.pin(cert)
-                  + "\n    DN: " + cert.getSubjectDN().getName()
-                  + "\n    subjectAltNames: " + OkHostnameVerifier.allSubjectAltNames(cert));
-        } else {
-          throw new SSLPeerUnverifiedException(
-              "Hostname " + address.url().host() + " not verified (no certificates)");
+
+    /**
+     * Returns true if this connection can carry a stream allocation to {@code address}. If non-null
+     * {@code route} is the resolved route for a connection.
+     */
+    public boolean isEligible(Address address, @Nullable Route route) {
+        // If this connection is not accepting new streams, we're done.
+        if (allocations.size() >= allocationLimit || noNewStreams) return false;
+
+        // If the non-host fields of the address don't overlap, we're done.
+        if (!Internal.instance.equalsNonHost(this.route.address(), address)) return false;
+
+        // If the host exactly matches, we're done: this connection can carry the address.
+        if (address.url().host().equals(this.route().address().url().host())) {
+            return true; // This connection is a perfect match.
         }
-      }
-
-      // Check that the certificate pinner is satisfied by the certificates presented.
-      address.certificatePinner().check(address.url().host(),
-          unverifiedHandshake.peerCertificates());
-
-      // Success! Save the handshake and the ALPN protocol.
-      String maybeProtocol = connectionSpec.supportsTlsExtensions()
-          ? Platform.get().getSelectedProtocol(sslSocket)
-          : null;
-      socket = sslSocket;
-      source = Okio.buffer(Okio.source(socket));
-      sink = Okio.buffer(Okio.sink(socket));
-      handshake = unverifiedHandshake;
-      protocol = maybeProtocol != null
-          ? Protocol.get(maybeProtocol)
-          : Protocol.HTTP_1_1;
-      success = true;
-    } catch (AssertionError e) {
-      if (Util.isAndroidGetsocknameError(e)) throw new IOException(e);
-      throw e;
-    } finally {
-      if (sslSocket != null) {
-        Platform.get().afterHandshake(sslSocket);
-      }
-      if (!success) {
-        closeQuietly(sslSocket);
-      }
-    }
-  }
-
-  /**
-   * To make an HTTPS connection over an HTTP proxy, send an unencrypted CONNECT request to create
-   * the proxy connection. This may need to be retried if the proxy requires authorization.
-   */
-  private Request createTunnel(int readTimeout, int writeTimeout, Request tunnelRequest,
-      HttpUrl url) throws IOException {
-    // Make an SSL Tunnel on the first message pair of each SSL + proxy connection.
-    String requestLine = "CONNECT " + Util.hostHeader(url, true) + " HTTP/1.1";
-    while (true) {
-      Http1Codec tunnelConnection = new Http1Codec(null, null, source, sink);
-      source.timeout().timeout(readTimeout, MILLISECONDS);
-      sink.timeout().timeout(writeTimeout, MILLISECONDS);
-      tunnelConnection.writeRequest(tunnelRequest.headers(), requestLine);
-      tunnelConnection.finishRequest();
-      Response response = tunnelConnection.readResponseHeaders(false)
-          .request(tunnelRequest)
-          .build();
-      // The response body from a CONNECT should be empty, but if it is not then we should consume
-      // it before proceeding.
-      long contentLength = HttpHeaders.contentLength(response);
-      if (contentLength == -1L) {
-        contentLength = 0L;
-      }
-      Source body = tunnelConnection.newFixedLengthSource(contentLength);
-      Util.skipAll(body, Integer.MAX_VALUE, TimeUnit.MILLISECONDS);
-      body.close();
-
-      switch (response.code()) {
-        case HTTP_OK:
-          // Assume the server won't send a TLS ServerHello until we send a TLS ClientHello. If
-          // that happens, then we will have buffered bytes that are needed by the SSLSocket!
-          // This check is imperfect: it doesn't tell us whether a handshake will succeed, just
-          // that it will almost certainly fail because the proxy has sent unexpected data.
-          if (!source.getBuffer().exhausted() || !sink.buffer().exhausted()) {
-            throw new IOException("TLS tunnel buffered too many bytes!");
-          }
-          return null;
-
-        case HTTP_PROXY_AUTH:
-          tunnelRequest = route.address().proxyAuthenticator().authenticate(route, response);
-          if (tunnelRequest == null) throw new IOException("Failed to authenticate with proxy");
-
-          if ("close".equalsIgnoreCase(response.header("Connection"))) {
-            return tunnelRequest;
-          }
-          break;
-
-        default:
-          throw new IOException(
-              "Unexpected response code for CONNECT: " + response.code());
-      }
+
+        // At this point we don't have a hostname match. But we still be able to carry the request if
+        // our connection coalescing requirements are met. See also:
+        // https://hpbn.co/optimizing-application-delivery/#eliminate-domain-sharding
+        // https://daniel.haxx.se/blog/2016/08/18/http2-connection-coalescing/
+
+        // 1. This connection must be HTTP/2.
+        if (http2Connection == null) return false;
+
+        // 2. The routes must share an IP address. This requires us to have a DNS address for both
+        // hosts, which only happens after route planning. We can't coalesce connections that use a
+        // proxy, since proxies don't tell us the origin server's IP address.
+        if (route == null) return false;
+        if (route.proxy().type() != Proxy.Type.DIRECT) return false;
+        if (this.route.proxy().type() != Proxy.Type.DIRECT) return false;
+        if (!this.route.socketAddress().equals(route.socketAddress())) return false;
+
+        // 3. This connection's server certificate's must cover the new host.
+        if (route.address().hostnameVerifier() != OkHostnameVerifier.INSTANCE) return false;
+        if (!supportsUrl(address.url())) return false;
+
+        // 4. Certificate pinning must match the host.
+        try {
+            address.certificatePinner().check(address.url().host(), handshake().peerCertificates());
+        } catch (SSLPeerUnverifiedException e) {
+            return false;
+        }
+
+        return true; // The caller's address can be carried by this connection.
     }
-  }
-
-  /**
-   * Returns a request that creates a TLS tunnel via an HTTP proxy. Everything in the tunnel request
-   * is sent unencrypted to the proxy server, so tunnels include only the minimum set of headers.
-   * This avoids sending potentially sensitive data like HTTP cookies to the proxy unencrypted.
-   *
-   * <p>In order to support preemptive authentication we pass a fake “Auth Failed” response to the
-   * authenticator. This gives the authenticator the option to customize the CONNECT request. It can
-   * decline to do so by returning null, in which case OkHttp will use it as-is
-   */
-  private Request createTunnelRequest() throws IOException {
-    Request proxyConnectRequest = new Request.Builder()
-        .url(route.address().url())
-        .method("CONNECT", null)
-        .header("Host", Util.hostHeader(route.address().url(), true))
-        .header("Proxy-Connection", "Keep-Alive") // For HTTP/1.0 proxies like Squid.
-        .header("User-Agent", Version.userAgent())
-        .build();
-
-    Response fakeAuthChallengeResponse = new Response.Builder()
-        .request(proxyConnectRequest)
-        .protocol(Protocol.HTTP_1_1)
-        .code(HttpURLConnection.HTTP_PROXY_AUTH)
-        .message("Preemptive Authenticate")
-        .body(Util.EMPTY_RESPONSE)
-        .sentRequestAtMillis(-1L)
-        .receivedResponseAtMillis(-1L)
-        .header("Proxy-Authenticate", "OkHttp-Preemptive")
-        .build();
-
-    Request authenticatedRequest = route.address().proxyAuthenticator()
-        .authenticate(route, fakeAuthChallengeResponse);
-
-    return authenticatedRequest != null
-        ? authenticatedRequest
-        : proxyConnectRequest;
-  }
-
-  /**
-   * Returns true if this connection can carry a stream allocation to {@code address}. If non-null
-   * {@code route} is the resolved route for a connection.
-   */
-  public boolean isEligible(Address address, @Nullable Route route) {
-    // If this connection is not accepting new streams, we're done.
-    if (allocations.size() >= allocationLimit || noNewStreams) return false;
-
-    // If the non-host fields of the address don't overlap, we're done.
-    if (!Internal.instance.equalsNonHost(this.route.address(), address)) return false;
-
-    // If the host exactly matches, we're done: this connection can carry the address.
-    if (address.url().host().equals(this.route().address().url().host())) {
-      return true; // This connection is a perfect match.
+
+    public boolean supportsUrl(HttpUrl url) {
+        if (url.port() != route.address().url().port()) {
+            return false; // Port mismatch.
+        }
+
+        if (!url.host().equals(route.address().url().host())) {
+            // We have a host mismatch. But if the certificate matches, we're still good.
+            return handshake != null && OkHostnameVerifier.INSTANCE.verify(
+                    url.host(), (X509Certificate) handshake.peerCertificates().get(0));
+        }
+
+        return true; // Success. The URL is supported.
     }
 
-    // At this point we don't have a hostname match. But we still be able to carry the request if
-    // our connection coalescing requirements are met. See also:
-    // https://hpbn.co/optimizing-application-delivery/#eliminate-domain-sharding
-    // https://daniel.haxx.se/blog/2016/08/18/http2-connection-coalescing/
-
-    // 1. This connection must be HTTP/2.
-    if (http2Connection == null) return false;
-
-    // 2. The routes must share an IP address. This requires us to have a DNS address for both
-    // hosts, which only happens after route planning. We can't coalesce connections that use a
-    // proxy, since proxies don't tell us the origin server's IP address.
-    if (route == null) return false;
-    if (route.proxy().type() != Proxy.Type.DIRECT) return false;
-    if (this.route.proxy().type() != Proxy.Type.DIRECT) return false;
-    if (!this.route.socketAddress().equals(route.socketAddress())) return false;
-
-    // 3. This connection's server certificate's must cover the new host.
-    if (route.address().hostnameVerifier() != OkHostnameVerifier.INSTANCE) return false;
-    if (!supportsUrl(address.url())) return false;
-
-    // 4. Certificate pinning must match the host.
-    try {
-      address.certificatePinner().check(address.url().host(), handshake().peerCertificates());
-    } catch (SSLPeerUnverifiedException e) {
-      return false;
+    public HttpCodec newCodec(OkHttpClient client, Interceptor.Chain chain,
+                              StreamAllocation streamAllocation) throws SocketException {
+        if (http2Connection != null) {
+            return new Http2Codec(client, chain, streamAllocation, http2Connection);
+        } else {
+            socket.setSoTimeout(chain.readTimeoutMillis());
+            source.timeout().timeout(chain.readTimeoutMillis(), MILLISECONDS);
+            sink.timeout().timeout(chain.writeTimeoutMillis(), MILLISECONDS);
+            return new Http1Codec(client, streamAllocation, source, sink);
+        }
     }
 
-    return true; // The caller's address can be carried by this connection.
-  }
+    public RealWebSocket.Streams newWebSocketStreams(final StreamAllocation streamAllocation) {
+        return new RealWebSocket.Streams(true, source, sink) {
+            @Override
+            public void close() throws IOException {
+                streamAllocation.streamFinished(true, streamAllocation.codec(), -1L, null);
+            }
+        };
+    }
 
-  public boolean supportsUrl(HttpUrl url) {
-    if (url.port() != route.address().url().port()) {
-      return false; // Port mismatch.
+    @Override
+    public Route route() {
+        return route;
     }
 
-    if (!url.host().equals(route.address().url().host())) {
-      // We have a host mismatch. But if the certificate matches, we're still good.
-      return handshake != null && OkHostnameVerifier.INSTANCE.verify(
-          url.host(), (X509Certificate) handshake.peerCertificates().get(0));
+    public void cancel() {
+        // Close the raw socket so we don't end up doing synchronous I/O.
+        closeQuietly(rawSocket);
     }
 
-    return true; // Success. The URL is supported.
-  }
-
-  public HttpCodec newCodec(OkHttpClient client, Interceptor.Chain chain,
-      StreamAllocation streamAllocation) throws SocketException {
-    if (http2Connection != null) {
-      return new Http2Codec(client, chain, streamAllocation, http2Connection);
-    } else {
-      socket.setSoTimeout(chain.readTimeoutMillis());
-      source.timeout().timeout(chain.readTimeoutMillis(), MILLISECONDS);
-      sink.timeout().timeout(chain.writeTimeoutMillis(), MILLISECONDS);
-      return new Http1Codec(client, streamAllocation, source, sink);
+    @Override
+    public Socket socket() {
+        return socket;
     }
-  }
-
-  public RealWebSocket.Streams newWebSocketStreams(final StreamAllocation streamAllocation) {
-    return new RealWebSocket.Streams(true, source, sink) {
-      @Override public void close() throws IOException {
-        streamAllocation.streamFinished(true, streamAllocation.codec(), -1L, null);
-      }
-    };
-  }
-
-  @Override public Route route() {
-    return route;
-  }
-
-  public void cancel() {
-    // Close the raw socket so we don't end up doing synchronous I/O.
-    closeQuietly(rawSocket);
-  }
-
-  @Override public Socket socket() {
-    return socket;
-  }
-
-  /** Returns true if this connection is ready to host new streams. */
-  public boolean isHealthy(boolean doExtensiveChecks) {
-    if (socket.isClosed() || socket.isInputShutdown() || socket.isOutputShutdown()) {
-      return false;
+
+    /**
+     * Returns true if this connection is ready to host new streams.
+     */
+    public boolean isHealthy(boolean doExtensiveChecks) {
+        if (socket.isClosed() || socket.isInputShutdown() || socket.isOutputShutdown()) {
+            return false;
+        }
+
+        if (http2Connection != null) {
+            return !http2Connection.isShutdown();
+        }
+
+        if (doExtensiveChecks) {
+            try {
+                int readTimeout = socket.getSoTimeout();
+                try {
+                    socket.setSoTimeout(1);
+                    if (source.exhausted()) {
+                        return false; // Stream is exhausted; socket is closed.
+                    }
+                    return true;
+                } finally {
+                    socket.setSoTimeout(readTimeout);
+                }
+            } catch (SocketTimeoutException ignored) {
+                // Read timed out; socket is good.
+            } catch (IOException e) {
+                return false; // Couldn't read; socket is closed.
+            }
+        }
+
+        return true;
     }
 
-    if (http2Connection != null) {
-      return !http2Connection.isShutdown();
+    /**
+     * Refuse incoming streams.
+     */
+    @Override
+    public void onStream(Http2Stream stream) throws IOException {
+        stream.close(ErrorCode.REFUSED_STREAM);
     }
 
-    if (doExtensiveChecks) {
-      try {
-        int readTimeout = socket.getSoTimeout();
-        try {
-          socket.setSoTimeout(1);
-          if (source.exhausted()) {
-            return false; // Stream is exhausted; socket is closed.
-          }
-          return true;
-        } finally {
-          socket.setSoTimeout(readTimeout);
+    /**
+     * When settings are received, adjust the allocation limit.
+     */
+    @Override
+    public void onSettings(Http2Connection connection) {
+        synchronized (connectionPool) {
+            allocationLimit = connection.maxConcurrentStreams();
         }
-      } catch (SocketTimeoutException ignored) {
-        // Read timed out; socket is good.
-      } catch (IOException e) {
-        return false; // Couldn't read; socket is closed.
-      }
     }
 
-    return true;
-  }
+    @Override
+    public Handshake handshake() {
+        return handshake;
+    }
+
+    /**
+     * Returns true if this is an HTTP/2 connection. Such connections can be used in multiple HTTP
+     * requests simultaneously.
+     */
+    public boolean isMultiplexed() {
+        return http2Connection != null;
+    }
 
-  /** Refuse incoming streams. */
-  @Override public void onStream(Http2Stream stream) throws IOException {
-    stream.close(ErrorCode.REFUSED_STREAM);
-  }
+    @Override
+    public Protocol protocol() {
+        return protocol;
+    }
 
-  /** When settings are received, adjust the allocation limit. */
-  @Override public void onSettings(Http2Connection connection) {
-    synchronized (connectionPool) {
-      allocationLimit = connection.maxConcurrentStreams();
+    @Override
+    public String toString() {
+        return "Connection{"
+                + route.address().url().host() + ":" + route.address().url().port()
+                + ", proxy="
+                + route.proxy()
+                + " hostAddress="
+                + route.socketAddress()
+                + " cipherSuite="
+                + (handshake != null ? handshake.cipherSuite() : "none")
+                + " protocol="
+                + protocol
+                + '}';
     }
-  }
-
-  @Override public Handshake handshake() {
-    return handshake;
-  }
-
-  /**
-   * Returns true if this is an HTTP/2 connection. Such connections can be used in multiple HTTP
-   * requests simultaneously.
-   */
-  public boolean isMultiplexed() {
-    return http2Connection != null;
-  }
-
-  @Override public Protocol protocol() {
-    return protocol;
-  }
-
-  @Override public String toString() {
-    return "Connection{"
-        + route.address().url().host() + ":" + route.address().url().port()
-        + ", proxy="
-        + route.proxy()
-        + " hostAddress="
-        + route.socketAddress()
-        + " cipherSuite="
-        + (handshake != null ? handshake.cipherSuite() : "none")
-        + " protocol="
-        + protocol
-        + '}';
-  }
 }
diff --git a/okhttp/src/main/java/okhttp3/internal/connection/StreamAllocation.java b/okhttp/src/main/java/okhttp3/internal/connection/StreamAllocation.java
index b362192907..40e60969dc 100644
--- a/okhttp/src/main/java/okhttp3/internal/connection/StreamAllocation.java
+++ b/okhttp/src/main/java/okhttp3/internal/connection/StreamAllocation.java
@@ -20,6 +20,7 @@
 import java.lang.ref.WeakReference;
 import java.net.Socket;
 import java.util.List;
+
 import okhttp3.Address;
 import okhttp3.Call;
 import okhttp3.Connection;
@@ -39,507 +40,514 @@
 
 /**
  * This class coordinates the relationship between three entities:
- *
+ * <p>
  * <ul>
- *     <li><strong>Connections:</strong> physical socket connections to remote servers. These are
- *         potentially slow to establish so it is necessary to be able to cancel a connection
- *         currently being connected.
- *     <li><strong>Streams:</strong> logical HTTP request/response pairs that are layered on
- *         connections. Each connection has its own allocation limit, which defines how many
- *         concurrent streams that connection can carry. HTTP/1.x connections can carry 1 stream
- *         at a time, HTTP/2 typically carry multiple.
- *     <li><strong>Calls:</strong> a logical sequence of streams, typically an initial request and
- *         its follow up requests. We prefer to keep all streams of a single call on the same
- *         connection for better behavior and locality.
+ * <li><strong>Connections:</strong> physical socket connections to remote servers. These are
+ * potentially slow to establish so it is necessary to be able to cancel a connection
+ * currently being connected.
+ * <li><strong>Streams:</strong> logical HTTP request/response pairs that are layered on
+ * connections. Each connection has its own allocation limit, which defines how many
+ * concurrent streams that connection can carry. HTTP/1.x connections can carry 1 stream
+ * at a time, HTTP/2 typically carry multiple.
+ * <li><strong>Calls:</strong> a logical sequence of streams, typically an initial request and
+ * its follow up requests. We prefer to keep all streams of a single call on the same
+ * connection for better behavior and locality.
  * </ul>
- *
+ * <p>
  * <p>Instances of this class act on behalf of the call, using one or more streams over one or more
  * connections. This class has APIs to release each of the above resources:
- *
+ * <p>
  * <ul>
- *     <li>{@link #noNewStreams} prevents the connection from being used for new streams in the
- *         future. Use this after a {@code Connection: close} header, or when the connection may be
- *         inconsistent.
- *     <li>{@link #streamFinished streamFinished} releases the active stream from this allocation.
- *         Note that only one stream may be active at a given time, so it is necessary to call
- *         {@link #streamFinished streamFinished()} before creating a subsequent stream with {@link
- *         #newStream newStream()}.
- *     <li>{@link #release} removes the call's hold on the connection. Note that this won't
- *         immediately free the connection if there is a stream still lingering. That happens when a
- *         call is complete but its response body has yet to be fully consumed.
+ * <li>{@link #noNewStreams} prevents the connection from being used for new streams in the
+ * future. Use this after a {@code Connection: close} header, or when the connection may be
+ * inconsistent.
+ * <li>{@link #streamFinished streamFinished} releases the active stream from this allocation.
+ * Note that only one stream may be active at a given time, so it is necessary to call
+ * {@link #streamFinished streamFinished()} before creating a subsequent stream with {@link
+ * #newStream newStream()}.
+ * <li>{@link #release} removes the call's hold on the connection. Note that this won't
+ * immediately free the connection if there is a stream still lingering. That happens when a
+ * call is complete but its response body has yet to be fully consumed.
  * </ul>
- *
+ * <p>
  * <p>This class supports {@linkplain #cancel asynchronous canceling}. This is intended to have the
  * smallest blast radius possible. If an HTTP/2 stream is active, canceling will cancel that stream
  * but not the other streams sharing its connection. But if the TLS handshake is still in progress
  * then canceling may break the entire connection.
  */
 public final class StreamAllocation {
-  public final Address address;
-  private RouteSelector.Selection routeSelection;
-  private Route route;
-  private final ConnectionPool connectionPool;
-  public final Call call;
-  public final EventListener eventListener;
-  private final Object callStackTrace;
-
-  // State guarded by connectionPool.
-  private final RouteSelector routeSelector;
-  private int refusedStreamCount;
-  private RealConnection connection;
-  private boolean reportedAcquired;
-  private boolean released;
-  private boolean canceled;
-  private HttpCodec codec;
-
-  public StreamAllocation(ConnectionPool connectionPool, Address address, Call call,
-      EventListener eventListener, Object callStackTrace) {
-    this.connectionPool = connectionPool;
-    this.address = address;
-    this.call = call;
-    this.eventListener = eventListener;
-    this.routeSelector = new RouteSelector(address, routeDatabase(), call, eventListener);
-    this.callStackTrace = callStackTrace;
-  }
-
-  public HttpCodec newStream(
-      OkHttpClient client, Interceptor.Chain chain, boolean doExtensiveHealthChecks) {
-    int connectTimeout = chain.connectTimeoutMillis();
-    int readTimeout = chain.readTimeoutMillis();
-    int writeTimeout = chain.writeTimeoutMillis();
-    int pingIntervalMillis = client.pingIntervalMillis();
-    boolean connectionRetryEnabled = client.retryOnConnectionFailure();
-
-    try {
-      RealConnection resultConnection = findHealthyConnection(connectTimeout, readTimeout,
-          writeTimeout, pingIntervalMillis, connectionRetryEnabled, doExtensiveHealthChecks);
-      HttpCodec resultCodec = resultConnection.newCodec(client, chain, this);
-
-      synchronized (connectionPool) {
-        codec = resultCodec;
-        return resultCodec;
-      }
-    } catch (IOException e) {
-      throw new RouteException(e);
+    public final Address address;
+    private RouteSelector.Selection routeSelection;
+    private Route route;
+    private final ConnectionPool connectionPool;
+    public final Call call;
+    public final EventListener eventListener;
+    private final Object callStackTrace;
+
+    // State guarded by connectionPool.
+    private final RouteSelector routeSelector;
+    private int refusedStreamCount;
+    private RealConnection connection;
+    private boolean reportedAcquired;
+    private boolean released;
+    private boolean canceled;
+    private HttpCodec codec;
+
+    public StreamAllocation(ConnectionPool connectionPool, Address address, Call call,
+                            EventListener eventListener, Object callStackTrace) {
+        this.connectionPool = connectionPool;
+        this.address = address;
+        this.call = call;
+        this.eventListener = eventListener;
+        this.routeSelector = new RouteSelector(address, routeDatabase(), call, eventListener);
+        this.callStackTrace = callStackTrace;
     }
-  }
-
-  /**
-   * Finds a connection and returns it if it is healthy. If it is unhealthy the process is repeated
-   * until a healthy connection is found.
-   */
-  private RealConnection findHealthyConnection(int connectTimeout, int readTimeout,
-      int writeTimeout, int pingIntervalMillis, boolean connectionRetryEnabled,
-      boolean doExtensiveHealthChecks) throws IOException {
-    while (true) {
-      RealConnection candidate = findConnection(connectTimeout, readTimeout, writeTimeout,
-          pingIntervalMillis, connectionRetryEnabled);
-
-      // If this is a brand new connection, we can skip the extensive health checks.
-      synchronized (connectionPool) {
-        if (candidate.successCount == 0) {
-          return candidate;
-        }
-      }
-
-      // Do a (potentially slow) check to confirm that the pooled connection is still good. If it
-      // isn't, take it out of the pool and start again.
-      if (!candidate.isHealthy(doExtensiveHealthChecks)) {
-        noNewStreams();
-        continue;
-      }
 
-      return candidate;
-    }
-  }
-
-  /**
-   * Returns a connection to host a new stream. This prefers the existing connection if it exists,
-   * then the pool, finally building a new connection.
-   */
-  private RealConnection findConnection(int connectTimeout, int readTimeout, int writeTimeout,
-      int pingIntervalMillis, boolean connectionRetryEnabled) throws IOException {
-    boolean foundPooledConnection = false;
-    RealConnection result = null;
-    Route selectedRoute = null;
-    Connection releasedConnection;
-    Socket toClose;
-    synchronized (connectionPool) {
-      if (released) throw new IllegalStateException("released");
-      if (codec != null) throw new IllegalStateException("codec != null");
-      if (canceled) throw new IOException("Canceled");
-
-      // Attempt to use an already-allocated connection. We need to be careful here because our
-      // already-allocated connection may have been restricted from creating new streams.
-      releasedConnection = this.connection;
-      toClose = releaseIfNoNewStreams();
-      if (this.connection != null) {
-        // We had an already-allocated connection and it's good.
-        result = this.connection;
-        releasedConnection = null;
-      }
-      if (!reportedAcquired) {
-        // If the connection was never reported acquired, don't report it as released!
-        releasedConnection = null;
-      }
-
-      if (result == null) {
-        // Attempt to get a connection from the pool.
-        Internal.instance.acquire(connectionPool, address, this, null);
-        if (connection != null) {
-          foundPooledConnection = true;
-          result = connection;
-        } else {
-          selectedRoute = route;
+    public HttpCodec newStream(OkHttpClient client, Interceptor.Chain chain, boolean doExtensiveHealthChecks) {
+        int connectTimeout = chain.connectTimeoutMillis();
+        int readTimeout = chain.readTimeoutMillis();
+        int writeTimeout = chain.writeTimeoutMillis();
+        int pingIntervalMillis = client.pingIntervalMillis();
+        boolean connectionRetryEnabled = client.retryOnConnectionFailure();
+
+        try {
+            RealConnection resultConnection = findHealthyConnection(connectTimeout, readTimeout,
+                    writeTimeout, pingIntervalMillis, connectionRetryEnabled, doExtensiveHealthChecks);
+            HttpCodec resultCodec = resultConnection.newCodec(client, chain, this);
+
+            synchronized (connectionPool) {
+                codec = resultCodec;
+                return resultCodec;
+            }
+        } catch (IOException e) {
+            throw new RouteException(e);
         }
-      }
     }
-    closeQuietly(toClose);
 
-    if (releasedConnection != null) {
-      eventListener.connectionReleased(call, releasedConnection);
-    }
-    if (foundPooledConnection) {
-      eventListener.connectionAcquired(call, result);
-    }
-    if (result != null) {
-      // If we found an already-allocated or pooled connection, we're done.
-      return result;
+    /**
+     * Finds a connection and returns it if it is healthy. If it is unhealthy the process is repeated
+     * until a healthy connection is found.
+     */
+    private RealConnection findHealthyConnection(int connectTimeout,
+                                                 int readTimeout,
+                                                 int writeTimeout,
+                                                 int pingIntervalMillis,
+                                                 boolean connectionRetryEnabled,
+                                                 boolean doExtensiveHealthChecks) throws IOException {
+        while (true) {
+            RealConnection candidate = findConnection(connectTimeout, readTimeout, writeTimeout,
+                    pingIntervalMillis, connectionRetryEnabled);
+
+            // If this is a brand new connection, we can skip the extensive health checks.
+            synchronized (connectionPool) {
+                if (candidate.successCount == 0) {
+                    return candidate;
+                }
+            }
+
+            // Do a (potentially slow) check to confirm that the pooled connection is still good. If it
+            // isn't, take it out of the pool and start again.
+            if (!candidate.isHealthy(doExtensiveHealthChecks)) {
+                noNewStreams();
+                continue;
+            }
+
+            return candidate;
+        }
     }
 
-    // If we need a route selection, make one. This is a blocking operation.
-    boolean newRouteSelection = false;
-    if (selectedRoute == null && (routeSelection == null || !routeSelection.hasNext())) {
-      newRouteSelection = true;
-      routeSelection = routeSelector.next();
-    }
+    /**
+     * Returns a connection to host a new stream. This prefers the existing connection if it exists,
+     * then the pool, finally building a new connection.
+     */
+    private RealConnection findConnection(int connectTimeout, int readTimeout, int writeTimeout,
+                                          int pingIntervalMillis, boolean connectionRetryEnabled) throws IOException {
+        boolean foundPooledConnection = false;
+        RealConnection result = null;
+        Route selectedRoute = null;
+        Connection releasedConnection;
+        Socket toClose;
+        synchronized (connectionPool) {
+            if (released) throw new IllegalStateException("released");
+            if (codec != null) throw new IllegalStateException("codec != null");
+            if (canceled) throw new IOException("Canceled");
+
+            // Attempt to use an already-allocated connection. We need to be careful here because our
+            // already-allocated connection may have been restricted from creating new streams.
+            releasedConnection = this.connection;
+            toClose = releaseIfNoNewStreams();
+            if (this.connection != null) {
+                // We had an already-allocated connection and it's good.
+                result = this.connection;
+                releasedConnection = null;
+            }
+            if (!reportedAcquired) {
+                // If the connection was never reported acquired, don't report it as released!
+                releasedConnection = null;
+            }
+
+            if (result == null) {
+                // Attempt to get a connection from the pool.
+                Internal.instance.acquire(connectionPool, address, this, null);
+                if (connection != null) {
+                    foundPooledConnection = true;
+                    result = connection;
+                } else {
+                    selectedRoute = route;
+                }
+            }
+        }
+        closeQuietly(toClose);
+
+        if (releasedConnection != null) {
+            eventListener.connectionReleased(call, releasedConnection);
+        }
+        if (foundPooledConnection) {
+            eventListener.connectionAcquired(call, result);
+        }
+        if (result != null) {
+            // If we found an already-allocated or pooled connection, we're done.
+            return result;
+        }
 
-    synchronized (connectionPool) {
-      if (canceled) throw new IOException("Canceled");
-
-      if (newRouteSelection) {
-        // Now that we have a set of IP addresses, make another attempt at getting a connection from
-        // the pool. This could match due to connection coalescing.
-        List<Route> routes = routeSelection.getAll();
-        for (int i = 0, size = routes.size(); i < size; i++) {
-          Route route = routes.get(i);
-          Internal.instance.acquire(connectionPool, address, this, route);
-          if (connection != null) {
-            foundPooledConnection = true;
-            result = connection;
-            this.route = route;
-            break;
-          }
+        // If we need a route selection, make one. This is a blocking operation.
+        boolean newRouteSelection = false;
+        if (selectedRoute == null && (routeSelection == null || !routeSelection.hasNext())) {
+            newRouteSelection = true;
+            routeSelection = routeSelector.next();
         }
-      }
 
-      if (!foundPooledConnection) {
-        if (selectedRoute == null) {
-          selectedRoute = routeSelection.next();
+        synchronized (connectionPool) {
+            if (canceled) throw new IOException("Canceled");
+
+            if (newRouteSelection) {
+                // Now that we have a set of IP addresses, make another attempt at getting a connection from
+                // the pool. This could match due to connection coalescing.
+                List<Route> routes = routeSelection.getAll();
+                for (int i = 0, size = routes.size(); i < size; i++) {
+                    Route route = routes.get(i);
+                    Internal.instance.acquire(connectionPool, address, this, route);
+                    if (connection != null) {
+                        foundPooledConnection = true;
+                        result = connection;
+                        this.route = route;
+                        break;
+                    }
+                }
+            }
+
+            if (!foundPooledConnection) {
+                if (selectedRoute == null) {
+                    selectedRoute = routeSelection.next();
+                }
+
+                // Create a connection and assign it to this allocation immediately. This makes it possible
+                // for an asynchronous cancel() to interrupt the handshake we're about to do.
+                route = selectedRoute;
+                refusedStreamCount = 0;
+                result = new RealConnection(connectionPool, selectedRoute);
+                acquire(result, false);
+            }
         }
 
-        // Create a connection and assign it to this allocation immediately. This makes it possible
-        // for an asynchronous cancel() to interrupt the handshake we're about to do.
-        route = selectedRoute;
-        refusedStreamCount = 0;
-        result = new RealConnection(connectionPool, selectedRoute);
-        acquire(result, false);
-      }
-    }
+        // If we found a pooled connection on the 2nd time around, we're done.
+        if (foundPooledConnection) {
+            eventListener.connectionAcquired(call, result);
+            return result;
+        }
 
-    // If we found a pooled connection on the 2nd time around, we're done.
-    if (foundPooledConnection) {
-      eventListener.connectionAcquired(call, result);
-      return result;
-    }
+        // Do TCP + TLS handshakes. This is a blocking operation.
+        result.connect(connectTimeout, readTimeout, writeTimeout, pingIntervalMillis,
+                connectionRetryEnabled, call, eventListener);
+        routeDatabase().connected(result.route());
 
-    // Do TCP + TLS handshakes. This is a blocking operation.
-    result.connect(connectTimeout, readTimeout, writeTimeout, pingIntervalMillis,
-        connectionRetryEnabled, call, eventListener);
-    routeDatabase().connected(result.route());
+        Socket socket = null;
+        synchronized (connectionPool) {
+            reportedAcquired = true;
 
-    Socket socket = null;
-    synchronized (connectionPool) {
-      reportedAcquired = true;
+            // Pool the connection.
+            Internal.instance.put(connectionPool, result);
 
-      // Pool the connection.
-      Internal.instance.put(connectionPool, result);
+            // If another multiplexed connection to the same address was created concurrently, then
+            // release this connection and acquire that one.
+            if (result.isMultiplexed()) {
+                socket = Internal.instance.deduplicate(connectionPool, address, this);
+                result = connection;
+            }
+        }
+        closeQuietly(socket);
 
-      // If another multiplexed connection to the same address was created concurrently, then
-      // release this connection and acquire that one.
-      if (result.isMultiplexed()) {
-        socket = Internal.instance.deduplicate(connectionPool, address, this);
-        result = connection;
-      }
-    }
-    closeQuietly(socket);
-
-    eventListener.connectionAcquired(call, result);
-    return result;
-  }
-
-  /**
-   * Releases the currently held connection and returns a socket to close if the held connection
-   * restricts new streams from being created. With HTTP/2 multiple requests share the same
-   * connection so it's possible that our connection is restricted from creating new streams during
-   * a follow-up request.
-   */
-  private Socket releaseIfNoNewStreams() {
-    assert (Thread.holdsLock(connectionPool));
-    RealConnection allocatedConnection = this.connection;
-    if (allocatedConnection != null && allocatedConnection.noNewStreams) {
-      return deallocate(false, false, true);
-    }
-    return null;
-  }
-
-  public void streamFinished(boolean noNewStreams, HttpCodec codec, long bytesRead, IOException e) {
-    eventListener.responseBodyEnd(call, bytesRead);
-
-    Socket socket;
-    Connection releasedConnection;
-    boolean callEnd;
-    synchronized (connectionPool) {
-      if (codec == null || codec != this.codec) {
-        throw new IllegalStateException("expected " + this.codec + " but was " + codec);
-      }
-      if (!noNewStreams) {
-        connection.successCount++;
-      }
-      releasedConnection = connection;
-      socket = deallocate(noNewStreams, false, true);
-      if (connection != null) releasedConnection = null;
-      callEnd = this.released;
-    }
-    closeQuietly(socket);
-    if (releasedConnection != null) {
-      eventListener.connectionReleased(call, releasedConnection);
+        eventListener.connectionAcquired(call, result);
+        return result;
     }
 
-    if (e != null) {
-      e = Internal.instance.timeoutExit(call, e);
-      eventListener.callFailed(call, e);
-    } else if (callEnd) {
-      Internal.instance.timeoutExit(call, null);
-      eventListener.callEnd(call);
+    /**
+     * Releases the currently held connection and returns a socket to close if the held connection
+     * restricts new streams from being created. With HTTP/2 multiple requests share the same
+     * connection so it's possible that our connection is restricted from creating new streams during
+     * a follow-up request.
+     */
+    private Socket releaseIfNoNewStreams() {
+        assert (Thread.holdsLock(connectionPool));
+        RealConnection allocatedConnection = this.connection;
+        if (allocatedConnection != null && allocatedConnection.noNewStreams) {
+            return deallocate(false, false, true);
+        }
+        return null;
     }
-  }
 
-  public HttpCodec codec() {
-    synchronized (connectionPool) {
-      return codec;
-    }
-  }
-
-  private RouteDatabase routeDatabase() {
-    return Internal.instance.routeDatabase(connectionPool);
-  }
-
-  public Route route() {
-    return route;
-  }
-
-  public synchronized RealConnection connection() {
-    return connection;
-  }
-
-  public void release(boolean callEnd) {
-    Socket socket;
-    Connection releasedConnection;
-    synchronized (connectionPool) {
-      releasedConnection = connection;
-      socket = deallocate(false, true, false);
-      if (connection != null) releasedConnection = null;
+    public void streamFinished(boolean noNewStreams, HttpCodec codec, long bytesRead, IOException e) {
+        eventListener.responseBodyEnd(call, bytesRead);
+
+        Socket socket;
+        Connection releasedConnection;
+        boolean callEnd;
+        synchronized (connectionPool) {
+            if (codec == null || codec != this.codec) {
+                throw new IllegalStateException("expected " + this.codec + " but was " + codec);
+            }
+            if (!noNewStreams) {
+                connection.successCount++;
+            }
+            releasedConnection = connection;
+            socket = deallocate(noNewStreams, false, true);
+            if (connection != null) releasedConnection = null;
+            callEnd = this.released;
+        }
+        closeQuietly(socket);
+        if (releasedConnection != null) {
+            eventListener.connectionReleased(call, releasedConnection);
+        }
+
+        if (e != null) {
+            e = Internal.instance.timeoutExit(call, e);
+            eventListener.callFailed(call, e);
+        } else if (callEnd) {
+            Internal.instance.timeoutExit(call, null);
+            eventListener.callEnd(call);
+        }
     }
-    closeQuietly(socket);
-    if (releasedConnection != null) {
-      if (callEnd) {
-        Internal.instance.timeoutExit(call, null);
-      }
-      eventListener.connectionReleased(call, releasedConnection);
-      if (callEnd) {
-        eventListener.callEnd(call);
-      }
+
+    public HttpCodec codec() {
+        synchronized (connectionPool) {
+            return codec;
+        }
     }
-  }
-
-  /** Forbid new streams from being created on the connection that hosts this allocation. */
-  public void noNewStreams() {
-    Socket socket;
-    Connection releasedConnection;
-    synchronized (connectionPool) {
-      releasedConnection = connection;
-      socket = deallocate(true, false, false);
-      if (connection != null) releasedConnection = null;
+
+    private RouteDatabase routeDatabase() {
+        return Internal.instance.routeDatabase(connectionPool);
     }
-    closeQuietly(socket);
-    if (releasedConnection != null) {
-      eventListener.connectionReleased(call, releasedConnection);
+
+    public Route route() {
+        return route;
     }
-  }
-
-  /**
-   * Releases resources held by this allocation. If sufficient resources are allocated, the
-   * connection will be detached or closed. Callers must be synchronized on the connection pool.
-   *
-   * <p>Returns a closeable that the caller should pass to {@link Util#closeQuietly} upon completion
-   * of the synchronized block. (We don't do I/O while synchronized on the connection pool.)
-   */
-  private Socket deallocate(boolean noNewStreams, boolean released, boolean streamFinished) {
-    assert (Thread.holdsLock(connectionPool));
-
-    if (streamFinished) {
-      this.codec = null;
+
+    public synchronized RealConnection connection() {
+        return connection;
     }
-    if (released) {
-      this.released = true;
+
+    public void release(boolean callEnd) {
+        Socket socket;
+        Connection releasedConnection;
+        synchronized (connectionPool) {
+            releasedConnection = connection;
+            socket = deallocate(false, true, false);
+            if (connection != null) releasedConnection = null;
+        }
+        closeQuietly(socket);
+        if (releasedConnection != null) {
+            if (callEnd) {
+                Internal.instance.timeoutExit(call, null);
+            }
+            eventListener.connectionReleased(call, releasedConnection);
+            if (callEnd) {
+                eventListener.callEnd(call);
+            }
+        }
     }
-    Socket socket = null;
-    if (connection != null) {
-      if (noNewStreams) {
-        connection.noNewStreams = true;
-      }
-      if (this.codec == null && (this.released || connection.noNewStreams)) {
-        release(connection);
-        if (connection.allocations.isEmpty()) {
-          connection.idleAtNanos = System.nanoTime();
-          if (Internal.instance.connectionBecameIdle(connectionPool, connection)) {
-            socket = connection.socket();
-          }
+
+    /**
+     * Forbid new streams from being created on the connection that hosts this allocation.
+     */
+    public void noNewStreams() {
+        Socket socket;
+        Connection releasedConnection;
+        synchronized (connectionPool) {
+            releasedConnection = connection;
+            socket = deallocate(true, false, false);
+            if (connection != null) releasedConnection = null;
+        }
+        closeQuietly(socket);
+        if (releasedConnection != null) {
+            eventListener.connectionReleased(call, releasedConnection);
         }
-        connection = null;
-      }
     }
-    return socket;
-  }
-
-  public void cancel() {
-    HttpCodec codecToCancel;
-    RealConnection connectionToCancel;
-    synchronized (connectionPool) {
-      canceled = true;
-      codecToCancel = codec;
-      connectionToCancel = connection;
+
+    /**
+     * Releases resources held by this allocation. If sufficient resources are allocated, the
+     * connection will be detached or closed. Callers must be synchronized on the connection pool.
+     * <p>
+     * <p>Returns a closeable that the caller should pass to {@link Util#closeQuietly} upon completion
+     * of the synchronized block. (We don't do I/O while synchronized on the connection pool.)
+     */
+    private Socket deallocate(boolean noNewStreams, boolean released, boolean streamFinished) {
+        assert (Thread.holdsLock(connectionPool));
+
+        if (streamFinished) {
+            this.codec = null;
+        }
+        if (released) {
+            this.released = true;
+        }
+        Socket socket = null;
+        if (connection != null) {
+            if (noNewStreams) {
+                connection.noNewStreams = true;
+            }
+            if (this.codec == null && (this.released || connection.noNewStreams)) {
+                release(connection);
+                if (connection.allocations.isEmpty()) {
+                    connection.idleAtNanos = System.nanoTime();
+                    if (Internal.instance.connectionBecameIdle(connectionPool, connection)) {
+                        socket = connection.socket();
+                    }
+                }
+                connection = null;
+            }
+        }
+        return socket;
     }
-    if (codecToCancel != null) {
-      codecToCancel.cancel();
-    } else if (connectionToCancel != null) {
-      connectionToCancel.cancel();
+
+    public void cancel() {
+        HttpCodec codecToCancel;
+        RealConnection connectionToCancel;
+        synchronized (connectionPool) {
+            canceled = true;
+            codecToCancel = codec;
+            connectionToCancel = connection;
+        }
+        if (codecToCancel != null) {
+            codecToCancel.cancel();
+        } else if (connectionToCancel != null) {
+            connectionToCancel.cancel();
+        }
     }
-  }
-
-  public void streamFailed(IOException e) {
-    Socket socket;
-    Connection releasedConnection;
-    boolean noNewStreams = false;
-
-    synchronized (connectionPool) {
-      if (e instanceof StreamResetException) {
-        ErrorCode errorCode = ((StreamResetException) e).errorCode;
-        if (errorCode == ErrorCode.REFUSED_STREAM) {
-          // Retry REFUSED_STREAM errors once on the same connection.
-          refusedStreamCount++;
-          if (refusedStreamCount > 1) {
-            noNewStreams = true;
-            route = null;
-          }
-        } else if (errorCode != ErrorCode.CANCEL) {
-          // Keep the connection for CANCEL errors. Everything else wants a fresh connection.
-          noNewStreams = true;
-          route = null;
+
+    public void streamFailed(IOException e) {
+        Socket socket;
+        Connection releasedConnection;
+        boolean noNewStreams = false;
+
+        synchronized (connectionPool) {
+            if (e instanceof StreamResetException) {
+                ErrorCode errorCode = ((StreamResetException) e).errorCode;
+                if (errorCode == ErrorCode.REFUSED_STREAM) {
+                    // Retry REFUSED_STREAM errors once on the same connection.
+                    refusedStreamCount++;
+                    if (refusedStreamCount > 1) {
+                        noNewStreams = true;
+                        route = null;
+                    }
+                } else if (errorCode != ErrorCode.CANCEL) {
+                    // Keep the connection for CANCEL errors. Everything else wants a fresh connection.
+                    noNewStreams = true;
+                    route = null;
+                }
+            } else if (connection != null
+                    && (!connection.isMultiplexed() || e instanceof ConnectionShutdownException)) {
+                noNewStreams = true;
+
+                // If this route hasn't completed a call, avoid it for new connections.
+                if (connection.successCount == 0) {
+                    if (route != null && e != null) {
+                        routeSelector.connectFailed(route, e);
+                    }
+                    route = null;
+                }
+            }
+            releasedConnection = connection;
+            socket = deallocate(noNewStreams, false, true);
+            if (connection != null || !reportedAcquired) releasedConnection = null;
         }
-      } else if (connection != null
-          && (!connection.isMultiplexed() || e instanceof ConnectionShutdownException)) {
-        noNewStreams = true;
-
-        // If this route hasn't completed a call, avoid it for new connections.
-        if (connection.successCount == 0) {
-          if (route != null && e != null) {
-            routeSelector.connectFailed(route, e);
-          }
-          route = null;
+
+        closeQuietly(socket);
+        if (releasedConnection != null) {
+            eventListener.connectionReleased(call, releasedConnection);
         }
-      }
-      releasedConnection = connection;
-      socket = deallocate(noNewStreams, false, true);
-      if (connection != null || !reportedAcquired) releasedConnection = null;
     }
 
-    closeQuietly(socket);
-    if (releasedConnection != null) {
-      eventListener.connectionReleased(call, releasedConnection);
+    /**
+     * Use this allocation to hold {@code connection}. Each call to this must be paired with a call to
+     * {@link #release} on the same connection.
+     */
+    public void acquire(RealConnection connection, boolean reportedAcquired) {
+        assert (Thread.holdsLock(connectionPool));
+        if (this.connection != null) throw new IllegalStateException();
+
+        this.connection = connection;
+        this.reportedAcquired = reportedAcquired;
+        connection.allocations.add(new StreamAllocationReference(this, callStackTrace));
     }
-  }
-
-  /**
-   * Use this allocation to hold {@code connection}. Each call to this must be paired with a call to
-   * {@link #release} on the same connection.
-   */
-  public void acquire(RealConnection connection, boolean reportedAcquired) {
-    assert (Thread.holdsLock(connectionPool));
-    if (this.connection != null) throw new IllegalStateException();
-
-    this.connection = connection;
-    this.reportedAcquired = reportedAcquired;
-    connection.allocations.add(new StreamAllocationReference(this, callStackTrace));
-  }
-
-  /** Remove this allocation from the connection's list of allocations. */
-  private void release(RealConnection connection) {
-    for (int i = 0, size = connection.allocations.size(); i < size; i++) {
-      Reference<StreamAllocation> reference = connection.allocations.get(i);
-      if (reference.get() == this) {
-        connection.allocations.remove(i);
-        return;
-      }
+
+    /**
+     * Remove this allocation from the connection's list of allocations.
+     */
+    private void release(RealConnection connection) {
+        for (int i = 0, size = connection.allocations.size(); i < size; i++) {
+            Reference<StreamAllocation> reference = connection.allocations.get(i);
+            if (reference.get() == this) {
+                connection.allocations.remove(i);
+                return;
+            }
+        }
+        throw new IllegalStateException();
     }
-    throw new IllegalStateException();
-  }
-
-  /**
-   * Release the connection held by this connection and acquire {@code newConnection} instead. It is
-   * only safe to call this if the held connection is newly connected but duplicated by {@code
-   * newConnection}. Typically this occurs when concurrently connecting to an HTTP/2 webserver.
-   *
-   * <p>Returns a closeable that the caller should pass to {@link Util#closeQuietly} upon completion
-   * of the synchronized block. (We don't do I/O while synchronized on the connection pool.)
-   */
-  public Socket releaseAndAcquire(RealConnection newConnection) {
-    assert (Thread.holdsLock(connectionPool));
-    if (codec != null || connection.allocations.size() != 1) throw new IllegalStateException();
-
-    // Release the old connection.
-    Reference<StreamAllocation> onlyAllocation = connection.allocations.get(0);
-    Socket socket = deallocate(true, false, false);
-
-    // Acquire the new connection.
-    this.connection = newConnection;
-    newConnection.allocations.add(onlyAllocation);
-
-    return socket;
-  }
-
-  public boolean hasMoreRoutes() {
-    return route != null
-        || (routeSelection != null && routeSelection.hasNext())
-        || routeSelector.hasNext();
-  }
-
-  @Override public String toString() {
-    RealConnection connection = connection();
-    return connection != null ? connection.toString() : address.toString();
-  }
-
-  public static final class StreamAllocationReference extends WeakReference<StreamAllocation> {
+
     /**
-     * Captures the stack trace at the time the Call is executed or enqueued. This is helpful for
-     * identifying the origin of connection leaks.
+     * Release the connection held by this connection and acquire {@code newConnection} instead. It is
+     * only safe to call this if the held connection is newly connected but duplicated by {@code
+     * newConnection}. Typically this occurs when concurrently connecting to an HTTP/2 webserver.
+     * <p>
+     * <p>Returns a closeable that the caller should pass to {@link Util#closeQuietly} upon completion
+     * of the synchronized block. (We don't do I/O while synchronized on the connection pool.)
      */
-    public final Object callStackTrace;
+    public Socket releaseAndAcquire(RealConnection newConnection) {
+        assert (Thread.holdsLock(connectionPool));
+        if (codec != null || connection.allocations.size() != 1) throw new IllegalStateException();
 
-    StreamAllocationReference(StreamAllocation referent, Object callStackTrace) {
-      super(referent);
-      this.callStackTrace = callStackTrace;
+        // Release the old connection.
+        Reference<StreamAllocation> onlyAllocation = connection.allocations.get(0);
+        Socket socket = deallocate(true, false, false);
+
+        // Acquire the new connection.
+        this.connection = newConnection;
+        newConnection.allocations.add(onlyAllocation);
+
+        return socket;
+    }
+
+    public boolean hasMoreRoutes() {
+        return route != null
+                || (routeSelection != null && routeSelection.hasNext())
+                || routeSelector.hasNext();
+    }
+
+    @Override
+    public String toString() {
+        RealConnection connection = connection();
+        return connection != null ? connection.toString() : address.toString();
+    }
+
+    public static final class StreamAllocationReference extends WeakReference<StreamAllocation> {
+        /**
+         * Captures the stack trace at the time the Call is executed or enqueued. This is helpful for
+         * identifying the origin of connection leaks.
+         */
+        public final Object callStackTrace;
+
+        StreamAllocationReference(StreamAllocation referent, Object callStackTrace) {
+            super(referent);
+            this.callStackTrace = callStackTrace;
+        }
     }
-  }
 }
