diff --git a/okhttp-tests/src/test/java/okhttp3/CallTest.java b/okhttp-tests/src/test/java/okhttp3/CallTest.java
index 94da609887..0535641eb9 100644
--- a/okhttp-tests/src/test/java/okhttp3/CallTest.java
+++ b/okhttp-tests/src/test/java/okhttp3/CallTest.java
@@ -1733,17 +1733,25 @@ private InetSocketAddress startNullServer() throws IOException {
     return new InetSocketAddress(address.getAddress(), nullServer.getLocalPort());
   }
 
-  @Test public void cancelTagImmediatelyAfterEnqueue() throws Exception {
+  @Test public void cancelImmediatelyAfterEnqueue() throws Exception {
     server.enqueue(new MockResponse());
     Call call = client.newCall(new Request.Builder()
         .url(server.url("/a"))
-        .tag("request")
         .build());
     call.enqueue(callback);
-    client.cancel("request");
+    call.cancel();
     callback.await(server.url("/a")).assertFailure("Canceled");
   }
 
+  @Test public void cancelAll() throws Exception {
+    Call call = client.newCall(new Request.Builder()
+        .url(server.url("/"))
+        .build());
+    call.enqueue(callback);
+    client.dispatcher().cancelAll();
+    callback.await(server.url("/")).assertFailure("Canceled");
+  }
+
   @Test public void cancelBeforeBodyIsRead() throws Exception {
     server.enqueue(new MockResponse().setBody("def").throttleBody(1, 750, TimeUnit.MILLISECONDS));
 
@@ -1767,16 +1775,18 @@ private InetSocketAddress startNullServer() throws IOException {
   }
 
   @Test public void cancelInFlightBeforeResponseReadThrowsIOE() throws Exception {
+    Request request = new Request.Builder().url(server.url("/a")).build();
+    final Call call = client.newCall(request);
+
     server.setDispatcher(new Dispatcher() {
       @Override public MockResponse dispatch(RecordedRequest request) {
-        client.cancel("request");
+        call.cancel();
         return new MockResponse().setBody("A");
       }
     });
 
-    Request request = new Request.Builder().url(server.url("/a")).tag("request").build();
     try {
-      client.newCall(request).execute();
+      call.execute();
       fail();
     } catch (IOException expected) {
     }
@@ -1803,22 +1813,25 @@ private InetSocketAddress startNullServer() throws IOException {
    */
   @Test public void canceledBeforeIOSignalsOnFailure() throws Exception {
     client.dispatcher().setMaxRequests(1); // Force requests to be executed serially.
+
+    Request requestA = new Request.Builder().url(server.url("/a")).build();
+    Request requestB = new Request.Builder().url(server.url("/b")).build();
+    final Call callA = client.newCall(requestA);
+    final Call callB = client.newCall(requestB);
+
     server.setDispatcher(new Dispatcher() {
       char nextResponse = 'A';
 
       @Override public MockResponse dispatch(RecordedRequest request) {
-        client.cancel("request B");
+        callB.cancel();
         return new MockResponse().setBody(Character.toString(nextResponse++));
       }
     });
 
-    Request requestA = new Request.Builder().url(server.url("/a")).tag("request A").build();
-    client.newCall(requestA).enqueue(callback);
+    callA.enqueue(callback);
+    callB.enqueue(callback);
     assertEquals("/a", server.takeRequest().getPath());
 
-    Request requestB = new Request.Builder().url(server.url("/b")).tag("request B").build();
-    client.newCall(requestB).enqueue(callback);
-
     callback.await(requestA.url()).assertBody("A");
     // At this point we know the callback is ready, and that it will receive a cancel failure.
     callback.await(requestB.url()).assertFailure("Canceled");
@@ -1840,7 +1853,7 @@ private InetSocketAddress startNullServer() throws IOException {
   }
 
   @Test public void canceledBeforeResponseReadSignalsOnFailure() throws Exception {
-    Request requestA = new Request.Builder().url(server.url("/a")).tag("request A").build();
+    Request requestA = new Request.Builder().url(server.url("/a")).build();
     final Call call = client.newCall(requestA);
     server.setDispatcher(new Dispatcher() {
       @Override public MockResponse dispatch(RecordedRequest request) {
@@ -1882,7 +1895,7 @@ private InetSocketAddress startNullServer() throws IOException {
     final AtomicReference<String> bodyRef = new AtomicReference<>();
     final AtomicBoolean failureRef = new AtomicBoolean();
 
-    Request request = new Request.Builder().url(server.url("/a")).tag("request A").build();
+    Request request = new Request.Builder().url(server.url("/a")).build();
     final Call call = client.newCall(request);
     call.enqueue(new Callback() {
       @Override public void onFailure(Request request, IOException e) {
diff --git a/okhttp-tests/src/test/java/okhttp3/DispatcherTest.java b/okhttp-tests/src/test/java/okhttp3/DispatcherTest.java
index 5774dd6806..4dc3d0c6bd 100644
--- a/okhttp-tests/src/test/java/okhttp3/DispatcherTest.java
+++ b/okhttp-tests/src/test/java/okhttp3/DispatcherTest.java
@@ -1,16 +1,23 @@
 package okhttp3;
 
+import java.io.IOException;
 import java.util.ArrayList;
 import java.util.Arrays;
+import java.util.Collections;
 import java.util.Iterator;
+import java.util.LinkedHashSet;
 import java.util.List;
+import java.util.Set;
 import java.util.concurrent.AbstractExecutorService;
+import java.util.concurrent.CountDownLatch;
 import java.util.concurrent.TimeUnit;
 import okhttp3.RealCall.AsyncCall;
 import org.junit.Before;
 import org.junit.Test;
 
 import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertTrue;
 import static org.junit.Assert.fail;
 
 public final class DispatcherTest {
@@ -116,14 +123,118 @@
 
   @Test public void cancelingRunningJobTakesNoEffectUntilJobFinishes() throws Exception {
     dispatcher.setMaxRequests(1);
-    client.newCall(newRequest("http://a/1", "tag1")).enqueue(callback);
-    client.newCall(newRequest("http://a/2")).enqueue(callback);
-    dispatcher.cancel("tag1");
+    Call c1 = client.newCall(newRequest("http://a/1", "tag1"));
+    Call c2 = client.newCall(newRequest("http://a/2"));
+    c1.enqueue(callback);
+    c2.enqueue(callback);
+    c1.cancel();
     executor.assertJobs("http://a/1");
     executor.finishJob("http://a/1");
     executor.assertJobs("http://a/2");
   }
 
+  @Test public void asyncCallAccessors() throws Exception {
+    dispatcher.setMaxRequests(3);
+    Call a1 = client.newCall(newRequest("http://a/1"));
+    Call a2 = client.newCall(newRequest("http://a/2"));
+    Call a3 = client.newCall(newRequest("http://a/3"));
+    Call a4 = client.newCall(newRequest("http://a/4"));
+    Call a5 = client.newCall(newRequest("http://a/5"));
+    a1.enqueue(callback);
+    a2.enqueue(callback);
+    a3.enqueue(callback);
+    a4.enqueue(callback);
+    a5.enqueue(callback);
+    assertEquals(3, dispatcher.runningCallsCount());
+    assertEquals(2, dispatcher.queuedCallsCount());
+    assertEquals(set(a1, a2, a3), set(dispatcher.runningCalls()));
+    assertEquals(set(a4, a5), set(dispatcher.queuedCalls()));
+  }
+
+  @Test public void synchronousCallAccessors() throws Exception {
+    final CountDownLatch ready = new CountDownLatch(2);
+    final CountDownLatch waiting = new CountDownLatch(1);
+    client = client.newBuilder()
+        .addInterceptor(
+            new Interceptor() {
+              @Override public Response intercept(Chain chain) throws IOException {
+                try {
+                  ready.countDown();
+                  waiting.await();
+                } catch (InterruptedException e) {
+                  throw new AssertionError();
+                }
+                throw new IOException();
+              }
+            })
+        .build();
+
+    Call a1 = client.newCall(newRequest("http://a/1"));
+    Call a2 = client.newCall(newRequest("http://a/2"));
+    Call a3 = client.newCall(newRequest("http://a/3"));
+    Call a4 = client.newCall(newRequest("http://a/4"));
+    Thread t1 = makeSynchronousCall(a1);
+    Thread t2 = makeSynchronousCall(a2);
+
+    // We created 4 calls and started 2 of them. That's 2 running calls and 0 queued.
+    ready.await();
+    assertEquals(2, dispatcher.runningCallsCount());
+    assertEquals(0, dispatcher.queuedCallsCount());
+    assertEquals(set(a1, a2), set(dispatcher.runningCalls()));
+    assertEquals(Collections.emptyList(), dispatcher.queuedCalls());
+
+    // Cancel some calls. That doesn't impact running or queued.
+    a2.cancel();
+    a3.cancel();
+    assertEquals(set(a1, a2), set(dispatcher.runningCalls()));
+    assertEquals(Collections.emptyList(), dispatcher.queuedCalls());
+
+    // Let the calls finish.
+    waiting.countDown();
+    t1.join();
+    t2.join();
+
+    // Now we should have 0 running calls and 0 queued calls.
+    assertEquals(0, dispatcher.runningCallsCount());
+    assertEquals(0, dispatcher.queuedCallsCount());
+    assertEquals(Collections.emptyList(), dispatcher.runningCalls());
+    assertEquals(Collections.emptyList(), dispatcher.queuedCalls());
+
+    assertTrue(a1.isExecuted());
+    assertFalse(a1.isCanceled());
+
+    assertTrue(a2.isExecuted());
+    assertTrue(a2.isCanceled());
+
+    assertFalse(a3.isExecuted());
+    assertTrue(a3.isCanceled());
+
+    assertFalse(a4.isExecuted());
+    assertFalse(a4.isCanceled());
+  }
+
+  private <T> Set<T> set(T... values) {
+    return set(Arrays.asList(values));
+  }
+
+  private <T> Set<T> set(List<T> list) {
+    return new LinkedHashSet<>(list);
+  }
+
+  private Thread makeSynchronousCall(final Call call) {
+    Thread thread = new Thread() {
+      @Override public void run() {
+        try {
+          call.execute();
+          throw new AssertionError();
+        } catch (IOException expected) {
+        }
+      }
+    };
+    thread.start();
+    return thread;
+  }
+
   class RecordingExecutor extends AbstractExecutorService {
     private List<AsyncCall> calls = new ArrayList<>();
 
diff --git a/okhttp-urlconnection/src/main/java/okhttp3/JavaNetAuthenticator.java b/okhttp-urlconnection/src/main/java/okhttp3/JavaNetAuthenticator.java
index b7b63f48c0..b5440a4d02 100644
--- a/okhttp-urlconnection/src/main/java/okhttp3/JavaNetAuthenticator.java
+++ b/okhttp-urlconnection/src/main/java/okhttp3/JavaNetAuthenticator.java
@@ -24,9 +24,9 @@
 import java.util.List;
 
 /**
- * Adapts {@link java.net.Authenticator} to {@link Authenticator}. Configure OkHttp to use
- * {@link java.net.Authenticator} with {@link OkHttpClient#setAuthenticator} or {@link
- * OkHttpClient#setProxyAuthenticator(Authenticator)}.
+ * Adapts {@link java.net.Authenticator} to {@link Authenticator}. Configure OkHttp to use {@link
+ * java.net.Authenticator} with {@link OkHttpClient.Builder#authenticator} or {@link
+ * OkHttpClient.Builder#proxyAuthenticator(Authenticator)}.
  */
 public final class JavaNetAuthenticator implements Authenticator {
   @Override public Request authenticate(Route route, Response response) throws IOException {
diff --git a/okhttp/src/main/java/okhttp3/Dispatcher.java b/okhttp/src/main/java/okhttp3/Dispatcher.java
index 103ca788f1..1b05cf4453 100644
--- a/okhttp/src/main/java/okhttp3/Dispatcher.java
+++ b/okhttp/src/main/java/okhttp3/Dispatcher.java
@@ -16,15 +16,17 @@
 package okhttp3;
 
 import java.util.ArrayDeque;
+import java.util.ArrayList;
+import java.util.Collections;
 import java.util.Deque;
 import java.util.Iterator;
+import java.util.List;
 import java.util.concurrent.ExecutorService;
 import java.util.concurrent.SynchronousQueue;
 import java.util.concurrent.ThreadPoolExecutor;
 import java.util.concurrent.TimeUnit;
 import okhttp3.RealCall.AsyncCall;
 import okhttp3.internal.Util;
-import okhttp3.internal.http.HttpEngine;
 
 /**
  * Policy on when async requests are executed.
@@ -40,14 +42,14 @@
   /** Executes calls. Created lazily. */
   private ExecutorService executorService;
 
-  /** Ready calls in the order they'll be run. */
-  private final Deque<AsyncCall> readyCalls = new ArrayDeque<>();
+  /** Ready async calls in the order they'll be run. */
+  private final Deque<AsyncCall> readyAsyncCalls = new ArrayDeque<>();
 
-  /** Running calls. Includes canceled calls that haven't finished yet. */
-  private final Deque<AsyncCall> runningCalls = new ArrayDeque<>();
+  /** Running asynchronous calls. Includes canceled calls that haven't finished yet. */
+  private final Deque<AsyncCall> runningAsyncCalls = new ArrayDeque<>();
 
-  /** In-flight synchronous calls. Includes canceled calls that haven't finished yet. */
-  private final Deque<RealCall> executedCalls = new ArrayDeque<>();
+  /** Running synchronous calls. Includes canceled calls that haven't finished yet. */
+  private final Deque<RealCall> runningSyncCalls = new ArrayDeque<>();
 
   public Dispatcher(ExecutorService executorService) {
     this.executorService = executorService;
@@ -105,64 +107,59 @@ public synchronized int getMaxRequestsPerHost() {
   }
 
   synchronized void enqueue(AsyncCall call) {
-    if (runningCalls.size() < maxRequests && runningCallsForHost(call) < maxRequestsPerHost) {
-      runningCalls.add(call);
+    if (runningAsyncCalls.size() < maxRequests && runningCallsForHost(call) < maxRequestsPerHost) {
+      runningAsyncCalls.add(call);
       getExecutorService().execute(call);
     } else {
-      readyCalls.add(call);
+      readyAsyncCalls.add(call);
     }
   }
 
-  /** Cancel all calls with the tag {@code tag}. */
-  public synchronized void cancel(Object tag) {
-    for (AsyncCall call : readyCalls) {
-      if (Util.equal(tag, call.tag())) {
-        call.cancel();
-      }
+  /**
+   * Cancel all calls currently enqueued or executing. Includes calls executed both {@linkplain
+   * Call#execute() synchronously} and {@linkplain Call#enqueue asynchronously}.
+   */
+  public synchronized void cancelAll() {
+    for (AsyncCall call : readyAsyncCalls) {
+      call.cancel();
     }
 
-    for (AsyncCall call : runningCalls) {
-      if (Util.equal(tag, call.tag())) {
-        call.get().canceled = true;
-        HttpEngine engine = call.get().engine;
-        if (engine != null) engine.cancel();
-      }
+    for (AsyncCall call : runningAsyncCalls) {
+      call.cancel();
     }
 
-    for (RealCall call : executedCalls) {
-      if (Util.equal(tag, call.tag())) {
-        call.cancel();
-      }
+    for (RealCall call : runningSyncCalls) {
+      call.cancel();
     }
   }
 
   /** Used by {@code AsyncCall#run} to signal completion. */
   synchronized void finished(AsyncCall call) {
-    if (!runningCalls.remove(call)) throw new AssertionError("AsyncCall wasn't running!");
+    if (!runningAsyncCalls.remove(call)) throw new AssertionError("AsyncCall wasn't running!");
     promoteCalls();
   }
 
   private void promoteCalls() {
-    if (runningCalls.size() >= maxRequests) return; // Already running max capacity.
-    if (readyCalls.isEmpty()) return; // No ready calls to promote.
+    if (runningAsyncCalls.size() >= maxRequests) return; // Already running max capacity.
+    if (readyAsyncCalls.isEmpty()) return; // No ready calls to promote.
 
-    for (Iterator<AsyncCall> i = readyCalls.iterator(); i.hasNext(); ) {
+    for (Iterator<AsyncCall> i = readyAsyncCalls.iterator(); i.hasNext(); ) {
       AsyncCall call = i.next();
 
       if (runningCallsForHost(call) < maxRequestsPerHost) {
         i.remove();
-        runningCalls.add(call);
+        runningAsyncCalls.add(call);
         getExecutorService().execute(call);
       }
 
-      if (runningCalls.size() >= maxRequests) return; // Reached max capacity.
+      if (runningAsyncCalls.size() >= maxRequests) return; // Reached max capacity.
     }
   }
 
   /** Returns the number of running calls that share a host with {@code call}. */
   private int runningCallsForHost(AsyncCall call) {
     int result = 0;
-    for (AsyncCall c : runningCalls) {
+    for (AsyncCall c : runningAsyncCalls) {
       if (c.host().equals(call.host())) result++;
     }
     return result;
@@ -170,19 +167,38 @@ private int runningCallsForHost(AsyncCall call) {
 
   /** Used by {@code Call#execute} to signal it is in-flight. */
   synchronized void executed(RealCall call) {
-    executedCalls.add(call);
+    runningSyncCalls.add(call);
   }
 
   /** Used by {@code Call#execute} to signal completion. */
   synchronized void finished(Call call) {
-    if (!executedCalls.remove(call)) throw new AssertionError("Call wasn't in-flight!");
+    if (!runningSyncCalls.remove(call)) throw new AssertionError("Call wasn't in-flight!");
+  }
+
+  /** Returns a snapshot of the calls currently awaiting execution. */
+  public synchronized List<Call> queuedCalls() {
+    List<Call> result = new ArrayList<>();
+    for (AsyncCall asyncCall : readyAsyncCalls) {
+      result.add(asyncCall.get());
+    }
+    return Collections.unmodifiableList(result);
+  }
+
+  /** Returns a snapshot of the calls currently being executed. */
+  public synchronized List<Call> runningCalls() {
+    List<Call> result = new ArrayList<>();
+    result.addAll(runningSyncCalls);
+    for (AsyncCall asyncCall : runningAsyncCalls) {
+      result.add(asyncCall.get());
+    }
+    return Collections.unmodifiableList(result);
   }
 
-  public synchronized int getRunningCallCount() {
-    return runningCalls.size();
+  public synchronized int queuedCallsCount() {
+    return readyAsyncCalls.size();
   }
 
-  public synchronized int getQueuedCallCount() {
-    return readyCalls.size();
+  public synchronized int runningCallsCount() {
+    return runningAsyncCalls.size() + runningSyncCalls.size();
   }
 }
diff --git a/okhttp/src/main/java/okhttp3/OkHttpClient.java b/okhttp/src/main/java/okhttp3/OkHttpClient.java
index 121839f3e6..ff30079e65 100644
--- a/okhttp/src/main/java/okhttp3/OkHttpClient.java
+++ b/okhttp/src/main/java/okhttp3/OkHttpClient.java
@@ -37,16 +37,24 @@
 import okhttp3.internal.tls.OkHostnameVerifier;
 
 /**
- * Configures and creates HTTP connections. Most applications can use a single OkHttpClient for all
- * of their HTTP requests - benefiting from a shared response cache, thread pool, connection re-use,
- * etc.
+ * Factory for {@linkplain Call calls}, which can be used to send HTTP requests and read their
+ * responses. Most applications can use a single OkHttpClient for all of their HTTP requests,
+ * benefiting from a shared response cache, thread pool, connection re-use, etc.
  *
- * <p>Instances of OkHttpClient are intended to be fully configured before they're shared - once
- * shared they should be treated as immutable and can safely be used to concurrently open new
- * connections. If required, threads can call {@link #clone()} to make a shallow copy of the
- * OkHttpClient that can be safely modified with further configuration changes.
+ * <p>To create an {@code OkHttpClient} with the default settings, use the {@linkplain
+ * #OkHttpClient() default constructor}. Or create a configured instance with {@link
+ * OkHttpClient.Builder}. To adjust an existing client before making a request, use {@link
+ * #newBuilder()}. This example shows a call with a 30 second timeout:
+ * <pre>   {@code
+ *
+ *   OkHttpClient client = ...
+ *   OkHttpClient clientWith30sTimeout = client.newBuilder()
+ *       .readTimeout(30, TimeUnit.SECONDS)
+ *       .build();
+ *   Response response = clientWith30sTimeout.newCall(request).execute();
+ * }</pre>
  */
-public class OkHttpClient implements Cloneable, Call.Factory {
+public final class OkHttpClient implements Cloneable, Call.Factory {
   private static final List<Protocol> DEFAULT_PROTOCOLS = Util.immutableList(
       Protocol.HTTP_2, Protocol.SPDY_3, Protocol.HTTP_1_1);
 
@@ -292,15 +300,6 @@ public Dispatcher dispatcher() {
     return new RealCall(this, request);
   }
 
-  /**
-   * Cancels all scheduled or in-flight calls tagged with {@code tag}. Requests that are already
-   * complete cannot be canceled.
-   */
-  public OkHttpClient cancel(Object tag) {
-    dispatcher().cancel(tag);
-    return this;
-  }
-
   public Builder newBuilder() {
     return new Builder(this);
   }
@@ -424,9 +423,8 @@ public Builder writeTimeout(long timeout, TimeUnit unit) {
 
     /**
      * Sets the HTTP proxy that will be used by connections created by this client. This takes
-     * precedence over {@link #proxySelector}, which is only honored when this proxy is null
-     * (which it is by default). To disable proxy use completely, call {@code
-     * setProxy(Proxy.NO_PROXY)}.
+     * precedence over {@link #proxySelector}, which is only honored when this proxy is null (which
+     * it is by default). To disable proxy use completely, call {@code setProxy(Proxy.NO_PROXY)}.
      */
     public Builder proxy(Proxy proxy) {
       this.proxy = proxy;
@@ -515,8 +513,8 @@ public Builder hostnameVerifier(HostnameVerifier hostnameVerifier) {
 
     /**
      * Sets the certificate pinner that constrains which certificates are trusted. By default HTTPS
-     * connections rely on only the {@link #sslSocketFactory SSL socket factory} to establish
-     * trust. Pinning certificates avoids the need to trust certificate authorities.
+     * connections rely on only the {@link #sslSocketFactory SSL socket factory} to establish trust.
+     * Pinning certificates avoids the need to trust certificate authorities.
      */
     public Builder certificatePinner(CertificatePinner certificatePinner) {
       this.certificatePinner = certificatePinner;
