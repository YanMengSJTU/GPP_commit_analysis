diff --git a/okhttp-tests/src/test/java/com/squareup/okhttp/ConnectionPoolTest.java b/okhttp-tests/src/test/java/com/squareup/okhttp/ConnectionPoolTest.java
new file mode 100644
index 0000000000..9a178574dc
--- /dev/null
+++ b/okhttp-tests/src/test/java/com/squareup/okhttp/ConnectionPoolTest.java
@@ -0,0 +1,154 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.okhttp;
+
+import com.squareup.okhttp.internal.RecordingOkAuthenticator;
+import com.squareup.okhttp.internal.io.RealConnection;
+import java.net.InetSocketAddress;
+import java.net.Proxy;
+import java.net.ProxySelector;
+import java.net.Socket;
+import java.util.Collections;
+import java.util.concurrent.TimeUnit;
+import javax.net.SocketFactory;
+import org.junit.Test;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertTrue;
+
+public final class ConnectionPoolTest {
+  private final Runnable emptyRunnable = new Runnable() {
+    @Override public void run() {
+    }
+  };
+
+  private final Address addressA = newAddress("a");
+  private final Route routeA1 = newRoute(addressA);
+  private final Address addressB = newAddress("b");
+  private final Route routeB1 = newRoute(addressB);
+
+  @Test public void connectionsEvictedWhenIdleLongEnough() throws Exception {
+    ConnectionPool pool = new ConnectionPool(1, 100L, TimeUnit.NANOSECONDS);
+    pool.setCleanupRunnableForTest(emptyRunnable);
+    RealConnection c1 = new RealConnection(routeA1);
+    c1.idleAtNanos = 50L;
+    c1.socket = new Socket();
+    assertFalse(c1.socket.isClosed());
+    pool.put(c1);
+
+    // Running at time 50, the pool returns that nothing can be evicted until time 150.
+    assertEquals(100L, pool.cleanup(50L));
+    assertEquals(1, pool.getConnectionCount());
+    assertFalse(c1.socket.isClosed());
+
+    // Running at time 60, the pool returns that nothing can be evicted until time 150.
+    assertEquals(90L, pool.cleanup(60L));
+    assertEquals(1, pool.getConnectionCount());
+    assertFalse(c1.socket.isClosed());
+
+    // Running at time 149, the pool returns that nothing can be evicted until time 150.
+    assertEquals(1L, pool.cleanup(149L));
+    assertEquals(1, pool.getConnectionCount());
+    assertFalse(c1.socket.isClosed());
+
+    // Running at time 150, the pool evicts.
+    assertEquals(0, pool.cleanup(150L));
+    assertEquals(0, pool.getConnectionCount());
+    assertTrue(c1.socket.isClosed());
+
+    // Running again, the pool reports that no further runs are necessary.
+    assertEquals(-1, pool.cleanup(150L));
+    assertEquals(0, pool.getConnectionCount());
+    assertTrue(c1.socket.isClosed());
+  }
+
+  @Test public void inUseConnectionsNotEvicted() throws Exception {
+    ConnectionPool pool = new ConnectionPool(1, 100L, TimeUnit.NANOSECONDS);
+    pool.setCleanupRunnableForTest(emptyRunnable);
+    RealConnection c1 = new RealConnection(routeA1);
+    c1.allocationCount = 1;
+    c1.idleAtNanos = 50L;
+    c1.socket = new Socket();
+    assertFalse(c1.socket.isClosed());
+    pool.put(c1);
+
+    // Running at time 50, the pool returns that nothing can be evicted until time 150.
+    assertEquals(100L, pool.cleanup(50L));
+    assertEquals(1, pool.getConnectionCount());
+    assertFalse(c1.socket.isClosed());
+
+    // Running at time 60, the pool returns that nothing can be evicted until time 160.
+    assertEquals(100L, pool.cleanup(60L));
+    assertEquals(1, pool.getConnectionCount());
+    assertFalse(c1.socket.isClosed());
+
+    // Running at time 160, the pool returns that nothing can be evicted until time 260.
+    assertEquals(100L, pool.cleanup(160L));
+    assertEquals(1, pool.getConnectionCount());
+    assertFalse(c1.socket.isClosed());
+  }
+
+  @Test public void cleanupPrioritizesEarliestEviction() throws Exception {
+    ConnectionPool pool = new ConnectionPool(1, 100L, TimeUnit.NANOSECONDS);
+    pool.setCleanupRunnableForTest(emptyRunnable);
+    RealConnection c1 = new RealConnection(routeA1);
+    c1.idleAtNanos = 75L;
+    c1.socket = new Socket();
+    pool.put(c1);
+
+    RealConnection c2 = new RealConnection(routeB1);
+    c2.idleAtNanos = 50L;
+    c2.socket = new Socket();
+    pool.put(c2);
+
+    // Running at time 75, the pool returns that nothing can be evicted until time 150.
+    assertEquals(75L, pool.cleanup(75L));
+    assertEquals(2, pool.getConnectionCount());
+
+    // Running at time 149, the pool returns that nothing can be evicted until time 150.
+    assertEquals(1L, pool.cleanup(149L));
+    assertEquals(2, pool.getConnectionCount());
+
+    // Running at time 150, the pool evicts c2.
+    assertEquals(0L, pool.cleanup(150L));
+    assertEquals(1, pool.getConnectionCount());
+    assertFalse(c1.socket.isClosed());
+    assertTrue(c2.socket.isClosed());
+
+    // Running at time 150, the pool returns that nothing can be evicted until time 175.
+    assertEquals(25L, pool.cleanup(150L));
+    assertEquals(1, pool.getConnectionCount());
+
+    // Running at time 175, the pool evicts c1.
+    assertEquals(0L, pool.cleanup(175L));
+    assertEquals(0, pool.getConnectionCount());
+    assertTrue(c1.socket.isClosed());
+    assertTrue(c2.socket.isClosed());
+  }
+
+  private Address newAddress(String name) {
+    return new Address(name, 1, Dns.SYSTEM, SocketFactory.getDefault(), null, null, null,
+        new RecordingOkAuthenticator("password"), null, Collections.<Protocol>emptyList(),
+        Collections.<ConnectionSpec>emptyList(),
+        ProxySelector.getDefault());
+  }
+
+  private Route newRoute(Address address) {
+    return new Route(address, Proxy.NO_PROXY,
+        InetSocketAddress.createUnresolved(address.url().host(), address.url().port()));
+  }
+}
diff --git a/okhttp-tests/src/test/java/com/squareup/okhttp/NewConnectionPoolTest.java b/okhttp-tests/src/test/java/com/squareup/okhttp/NewConnectionPoolTest.java
index 56732a74c7..3ca0e6f924 100644
--- a/okhttp-tests/src/test/java/com/squareup/okhttp/NewConnectionPoolTest.java
+++ b/okhttp-tests/src/test/java/com/squareup/okhttp/NewConnectionPoolTest.java
@@ -204,6 +204,28 @@
     assertEquals(1, server.takeRequest().getSequenceNumber());
   }
 
+  @Test public void connectionsAreEvicted() throws Exception {
+    server.enqueue(new MockResponse().setBody("a"));
+    server.enqueue(new MockResponse().setBody("b"));
+
+    client.setConnectionPool(new ConnectionPool(5, 250, TimeUnit.MILLISECONDS));
+    Request request = new Request.Builder()
+        .url(server.url("/"))
+        .build();
+
+    Response response1 = client.newCall(request).execute();
+    assertEquals("a", response1.body().string());
+
+    // Give the thread pool a chance to evict.
+    Thread.sleep(500);
+
+    Response response2 = client.newCall(request).execute();
+    assertEquals("b", response2.body().string());
+
+    assertEquals(0, server.takeRequest().getSequenceNumber());
+    assertEquals(0, server.takeRequest().getSequenceNumber());
+  }
+
   private void enableHttp2() {
     client.setSslSocketFactory(sslContext.getSocketFactory());
     client.setHostnameVerifier(new RecordingHostnameVerifier());
diff --git a/okhttp/src/main/java/com/squareup/okhttp/ConnectionPool.java b/okhttp/src/main/java/com/squareup/okhttp/ConnectionPool.java
index 00bc8540dc..1ae23790b0 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/ConnectionPool.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/ConnectionPool.java
@@ -24,6 +24,10 @@
 import java.util.Deque;
 import java.util.Iterator;
 import java.util.List;
+import java.util.concurrent.Executor;
+import java.util.concurrent.LinkedBlockingQueue;
+import java.util.concurrent.ThreadPoolExecutor;
+import java.util.concurrent.TimeUnit;
 
 /**
  * Manages reuse of HTTP and SPDY connections for reduced network latency. HTTP
@@ -57,7 +61,8 @@
     String keepAlive = System.getProperty("http.keepAlive");
     String keepAliveDuration = System.getProperty("http.keepAliveDuration");
     String maxIdleConnections = System.getProperty("http.maxConnections");
-    long keepAliveDurationMs = keepAliveDuration != null ? Long.parseLong(keepAliveDuration)
+    long keepAliveDurationMs = keepAliveDuration != null
+        ? Long.parseLong(keepAliveDuration)
         : DEFAULT_KEEP_ALIVE_DURATION_MS;
     if (keepAlive != null && !Boolean.parseBoolean(keepAlive)) {
       systemDefault = new ConnectionPool(0, keepAliveDurationMs);
@@ -68,16 +73,52 @@
     }
   }
 
+  /**
+   * A background thread is used to cleanup expired connections. There will be, at most, a single
+   * thread running per connection pool. We use a thread pool executor because it can shrink to
+   * zero threads, permitting this pool to be garbage collected.
+   */
+  private final Executor executor = new ThreadPoolExecutor(
+      0 /* corePoolSize */, 1 /* maximumPoolSize */, 60L /* keepAliveTime */, TimeUnit.SECONDS,
+      new LinkedBlockingQueue<Runnable>(), Util.threadFactory("OkHttp ConnectionPool", true));
+
   /** The maximum number of idle connections for each address. */
   private final int maxIdleConnections;
   private final long keepAliveDurationNs;
+  private Runnable cleanupRunnable = new Runnable() {
+    @Override public void run() {
+      while (true) {
+        long waitNanos = cleanup(System.nanoTime());
+        if (waitNanos == -1) return;
+        if (waitNanos > 0) {
+          long waitMillis = waitNanos / 1000000L;
+          waitNanos -= (waitMillis * 1000000L);
+          synchronized (ConnectionPool.this) {
+            try {
+              ConnectionPool.this.wait(waitMillis, (int) waitNanos);
+            } catch (InterruptedException ignored) {
+            }
+          }
+        }
+      }
+    }
+  };
 
   private final Deque<RealConnection> connections = new ArrayDeque<>();
   final RouteDatabase routeDatabase = new RouteDatabase();
 
   public ConnectionPool(int maxIdleConnections, long keepAliveDurationMs) {
+    this(maxIdleConnections, keepAliveDurationMs, TimeUnit.MILLISECONDS);
+  }
+
+  public ConnectionPool(int maxIdleConnections, long keepAliveDuration, TimeUnit timeUnit) {
     this.maxIdleConnections = maxIdleConnections;
-    this.keepAliveDurationNs = keepAliveDurationMs * 1000 * 1000;
+    this.keepAliveDurationNs = timeUnit.toNanos(keepAliveDuration);
+
+    // Put a floor on the keep alive duration, otherwise cleanup will spin loop.
+    if (keepAliveDuration <= 0) {
+      throw new IllegalArgumentException("keepAliveDuration <= 0: " + keepAliveDuration);
+    }
   }
 
   public static ConnectionPool getDefault() {
@@ -140,6 +181,9 @@ public synchronized Connection get(Address address) {
 
   // TODO(jwilson): reduce visibility.
   public synchronized void put(RealConnection connection) {
+    if (connections.isEmpty()) {
+      executor.execute(cleanupRunnable);
+    }
     connections.add(connection);
   }
 
@@ -166,4 +210,64 @@ public void evictAll() {
       Util.closeQuietly(connection.getSocket());
     }
   }
+
+  /**
+   * Performs maintenance on this pool, evicting connections that have expired.
+   *
+   * <p>Returns the duration in nanos to sleep until the next scheduled call to this method.
+   * Returns -1 if no further cleanups are required.
+   */
+  long cleanup(long now) {
+    int inUseConnectionCount = 0;
+    long nanosUntilNextCleanup = -1L;
+    RealConnection connectionToEvict = null;
+
+    // Find either a connection to evict, or the time that the next eviction is due.
+    synchronized (this) {
+      for (Iterator<RealConnection> i = connections.iterator(); i.hasNext(); ) {
+        RealConnection connection = i.next();
+
+        // If the connection is in use, keep searching.
+        if (connection.allocationCount > 0) {
+          inUseConnectionCount++;
+          nanosUntilNextCleanup = keepAliveDurationNs;
+          continue;
+        }
+
+        // If the connection is ready to be evicted, we're done.
+        long evictAtNanos = connection.idleAtNanos + keepAliveDurationNs;
+        long nanosUntilEviction = evictAtNanos - now;
+        if (nanosUntilEviction <= 0) {
+          connection.noNewStreams = true;
+          connectionToEvict = connection;
+          i.remove();
+          break;
+        }
+
+        // Is this the next connection to evict?
+        if (nanosUntilNextCleanup == -1L || nanosUntilNextCleanup > nanosUntilEviction) {
+          nanosUntilNextCleanup = nanosUntilEviction;
+        }
+      }
+    }
+
+    if (connectionToEvict != null) {
+      Util.closeQuietly(connectionToEvict.getSocket());
+      // Cleanup again immediately.
+      return 0;
+    } else if (nanosUntilNextCleanup != -1) {
+      // A connection will be ready to evict soon.
+      return nanosUntilNextCleanup;
+    } else if (inUseConnectionCount != 0) {
+      // All connections are in use. It'll be at least the keep alive duration 'til we run again.
+      return keepAliveDurationNs;
+    } else {
+      // No connections, idle or in use.
+      return -1;
+    }
+  }
+
+  void setCleanupRunnableForTest(Runnable cleanupRunnable) {
+    this.cleanupRunnable = cleanupRunnable;
+  }
 }
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/http/StreamAllocation.java b/okhttp/src/main/java/com/squareup/okhttp/internal/http/StreamAllocation.java
index bf37db05ee..35c87d8f82 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/http/StreamAllocation.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/http/StreamAllocation.java
@@ -237,6 +237,9 @@ private void deallocate(boolean noNewStreams, boolean released, boolean streamFi
         }
         if (this.stream == null && (this.released || connection.noNewStreams)) {
           connection.allocationCount--;
+          if (connection.allocationCount == 0) {
+            connection.idleAtNanos = System.nanoTime();
+          }
           if (connection.streamCount > 0) {
             routeSelector = null;
           }
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/io/RealConnection.java b/okhttp/src/main/java/com/squareup/okhttp/internal/io/RealConnection.java
index ae703c283d..d051ee1f2c 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/io/RealConnection.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/io/RealConnection.java
@@ -67,7 +67,7 @@
    * The application layer socket. Either an {@link SSLSocket} layered over {@link #rawSocket}, or
    * {@link #rawSocket} itself if this connection does not use SSL.
    */
-  private Socket socket;
+  public Socket socket;
   private Handshake handshake;
   private Protocol protocol;
   public volatile FramedConnection framedConnection;
@@ -76,6 +76,7 @@
   public BufferedSink sink;
   public int allocationCount;
   public boolean noNewStreams;
+  public long idleAtNanos = Long.MAX_VALUE;
 
   public RealConnection(Route route) {
     this.route = route;
