diff --git a/README.md b/README.md
index 188ca83562..9191328af9 100644
--- a/README.md
+++ b/README.md
@@ -25,9 +25,9 @@ Snapshots of the development version are available in [Sonatype's `snapshots` re
 MockWebServer
 -------------
 
-A library for testing HTTP, HTTPS, HTTP/2.0, and SPDY clients.
+A library for testing HTTP, HTTPS, and HTTP/2 clients.
 
-MockWebServer coupling with OkHttp is essential for proper testing of HTTP/2.0 so that code can be shared.
+MockWebServer coupling with OkHttp is essential for proper testing of HTTP/2 so that code can be shared.
 
 ### Download
 
diff --git a/benchmarks/src/main/java/okhttp3/benchmarks/Benchmark.java b/benchmarks/src/main/java/okhttp3/benchmarks/Benchmark.java
index 8d4d04386a..0ec59a0573 100644
--- a/benchmarks/src/main/java/okhttp3/benchmarks/Benchmark.java
+++ b/benchmarks/src/main/java/okhttp3/benchmarks/Benchmark.java
@@ -68,7 +68,7 @@
   @Param
   boolean gzip;
 
-  /** Don't combine chunked with SPDY_3 or HTTP_2; that's not allowed. */
+  /** Don't combine chunked with HTTP_2; that's not allowed. */
   @Param
   boolean chunked;
 
diff --git a/mockwebserver/src/main/java/okhttp3/internal/framed/FramedServer.java b/mockwebserver/src/main/java/okhttp3/internal/framed/FramedServer.java
index 9dc3c502e1..373b60fdb0 100644
--- a/mockwebserver/src/main/java/okhttp3/internal/framed/FramedServer.java
+++ b/mockwebserver/src/main/java/okhttp3/internal/framed/FramedServer.java
@@ -22,6 +22,7 @@
 import java.net.ServerSocket;
 import java.net.Socket;
 import java.util.Arrays;
+import java.util.Collections;
 import java.util.List;
 import java.util.logging.Level;
 import java.util.logging.Logger;
@@ -37,13 +38,10 @@
 
 import static okhttp3.internal.platform.Platform.INFO;
 
-/** A basic SPDY/HTTP_2 server that serves the contents of a local directory. */
+/** A basic HTTP_2 server that serves the contents of a local directory. */
 public final class FramedServer extends FramedConnection.Listener {
   static final Logger logger = Logger.getLogger(FramedServer.class.getName());
 
-  private final List<Protocol> framedProtocols =
-      Util.immutableList(Protocol.HTTP_2, Protocol.SPDY_3);
-
   private final File baseDirectory;
   private final SSLSocketFactory sslSocketFactory;
 
@@ -64,12 +62,11 @@ private void run() throws Exception {
         SSLSocket sslSocket = doSsl(socket);
         String protocolString = Platform.get().getSelectedProtocol(sslSocket);
         Protocol protocol = protocolString != null ? Protocol.get(protocolString) : null;
-        if (protocol == null || !framedProtocols.contains(protocol)) {
+        if (protocol != Protocol.HTTP_2) {
           throw new ProtocolException("Protocol " + protocol + " unsupported");
         }
         FramedConnection framedConnection = new FramedConnection.Builder(false)
             .socket(sslSocket)
-            .protocol(protocol)
             .listener(this)
             .build();
         framedConnection.start();
@@ -87,7 +84,8 @@ private SSLSocket doSsl(Socket socket) throws IOException {
     SSLSocket sslSocket = (SSLSocket) sslSocketFactory.createSocket(
         socket, socket.getInetAddress().getHostAddress(), socket.getPort(), true);
     sslSocket.setUseClientMode(false);
-    Platform.get().configureTlsExtensions(sslSocket, null, framedProtocols);
+    Platform.get().configureTlsExtensions(sslSocket, null,
+        Collections.singletonList(Protocol.HTTP_2));
     sslSocket.startHandshake();
     return sslSocket;
   }
diff --git a/mockwebserver/src/main/java/okhttp3/mockwebserver/MockWebServer.java b/mockwebserver/src/main/java/okhttp3/mockwebserver/MockWebServer.java
index cafb1f2b4c..0cd047d7bb 100644
--- a/mockwebserver/src/main/java/okhttp3/mockwebserver/MockWebServer.java
+++ b/mockwebserver/src/main/java/okhttp3/mockwebserver/MockWebServer.java
@@ -139,8 +139,7 @@
   private int port = -1;
   private InetSocketAddress inetSocketAddress;
   private boolean protocolNegotiationEnabled = true;
-  private List<Protocol> protocols
-      = Util.immutableList(Protocol.HTTP_2, Protocol.SPDY_3, Protocol.HTTP_1_1);
+  private List<Protocol> protocols = Util.immutableList(Protocol.HTTP_2, Protocol.HTTP_1_1);
 
   private boolean started;
 
@@ -450,17 +449,18 @@ public void processConnection() throws Exception {
           socket = raw;
         }
 
-        if (protocol != Protocol.HTTP_1_1) {
+        if (protocol == Protocol.HTTP_2) {
           FramedSocketHandler framedSocketListener = new FramedSocketHandler(socket, protocol);
           FramedConnection framedConnection = new FramedConnection.Builder(false)
               .socket(socket)
-              .protocol(protocol)
               .listener(framedSocketListener)
               .build();
           framedConnection.start();
           openFramedConnections.add(framedConnection);
           openClientSockets.remove(socket);
           return;
+        } else if (protocol != Protocol.HTTP_1_1) {
+          throw new AssertionError();
         }
 
         BufferedSource source = Okio.buffer(Okio.source(socket));
@@ -885,7 +885,6 @@ private RecordedRequest readRequest(FramedStream stream) throws IOException {
       Headers.Builder httpHeaders = new Headers.Builder();
       String method = "<:method omitted>";
       String path = "<:path omitted>";
-      String version = protocol == Protocol.SPDY_3 ? "<:version omitted>" : "HTTP/1.1";
       for (int i = 0, size = streamHeaders.size(); i < size; i++) {
         ByteString name = streamHeaders.get(i).name;
         String value = streamHeaders.get(i).value.utf8();
@@ -893,12 +892,6 @@ private RecordedRequest readRequest(FramedStream stream) throws IOException {
           method = value;
         } else if (name.equals(Header.TARGET_PATH)) {
           path = value;
-        } else if (name.equals(Header.VERSION)) {
-          version = value;
-        } else if (protocol == Protocol.SPDY_3) {
-          for (String s : value.split("\u0000", -1)) {
-            httpHeaders.add(name.utf8(), s);
-          }
         } else if (protocol == Protocol.HTTP_2) {
           httpHeaders.add(name.utf8(), value);
         } else {
@@ -910,8 +903,8 @@ private RecordedRequest readRequest(FramedStream stream) throws IOException {
       body.writeAll(stream.getSource());
       body.close();
 
-      String requestLine = method + ' ' + path + ' ' + version;
-      List<Integer> chunkSizes = Collections.emptyList(); // No chunked encoding for SPDY.
+      String requestLine = method + ' ' + path + " HTTP/1.1";
+      List<Integer> chunkSizes = Collections.emptyList(); // No chunked encoding for HTTP/2.
       return new RecordedRequest(requestLine, httpHeaders.build(), chunkSizes, body.size(), body,
           sequenceNumber.getAndIncrement(), socket);
     }
@@ -925,24 +918,21 @@ private void writeResponse(FramedStream stream, MockResponse response) throws IO
       if (response.getSocketPolicy() == NO_RESPONSE) {
         return;
       }
-      List<Header> spdyHeaders = new ArrayList<>();
+      List<Header> http2Headers = new ArrayList<>();
       String[] statusParts = response.getStatus().split(" ", 2);
       if (statusParts.length != 2) {
         throw new AssertionError("Unexpected status: " + response.getStatus());
       }
       // TODO: constants for well-known header names.
-      spdyHeaders.add(new Header(Header.RESPONSE_STATUS, statusParts[1]));
-      if (protocol == Protocol.SPDY_3) {
-        spdyHeaders.add(new Header(Header.VERSION, statusParts[0]));
-      }
+      http2Headers.add(new Header(Header.RESPONSE_STATUS, statusParts[1]));
       Headers headers = response.getHeaders();
       for (int i = 0, size = headers.size(); i < size; i++) {
-        spdyHeaders.add(new Header(headers.name(i), headers.value(i)));
+        http2Headers.add(new Header(headers.name(i), headers.value(i)));
       }
 
       Buffer body = response.getBody();
       boolean closeStreamAfterHeaders = body != null || !response.getPushPromises().isEmpty();
-      stream.reply(spdyHeaders, closeStreamAfterHeaders);
+      stream.reply(http2Headers, closeStreamAfterHeaders);
       pushPromises(stream, response.getPushPromises());
       if (body != null) {
         BufferedSink sink = Okio.buffer(stream.getSink());
@@ -957,9 +947,7 @@ private void writeResponse(FramedStream stream, MockResponse response) throws IO
     private void pushPromises(FramedStream stream, List<PushPromise> promises) throws IOException {
       for (PushPromise pushPromise : promises) {
         List<Header> pushedHeaders = new ArrayList<>();
-        pushedHeaders.add(new Header(stream.getConnection().getProtocol() == Protocol.SPDY_3
-            ? Header.TARGET_HOST
-            : Header.TARGET_AUTHORITY, url(pushPromise.path()).host()));
+        pushedHeaders.add(new Header(Header.TARGET_AUTHORITY, url(pushPromise.path()).host()));
         pushedHeaders.add(new Header(Header.TARGET_METHOD, pushPromise.method()));
         pushedHeaders.add(new Header(Header.TARGET_PATH, pushPromise.path()));
         Headers pushPromiseHeaders = pushPromise.headers();
@@ -967,7 +955,7 @@ private void pushPromises(FramedStream stream, List<PushPromise> promises) throw
           pushedHeaders.add(new Header(pushPromiseHeaders.name(i), pushPromiseHeaders.value(i)));
         }
         String requestLine = pushPromise.method() + ' ' + pushPromise.path() + " HTTP/1.1";
-        List<Integer> chunkSizes = Collections.emptyList(); // No chunked encoding for SPDY.
+        List<Integer> chunkSizes = Collections.emptyList(); // No chunked encoding for HTTP/2.
         requestQueue.add(new RecordedRequest(requestLine, pushPromise.headers(), chunkSizes, 0,
             new Buffer(), sequenceNumber.getAndIncrement(), socket));
         boolean hasBody = pushPromise.response().getBody() != null;
diff --git a/okcurl/README.md b/okcurl/README.md
index cea5be4064..4c65202b11 100644
--- a/okcurl/README.md
+++ b/okcurl/README.md
@@ -4,4 +4,4 @@ OkCurl
 _A curl for the next-generation web._
 
 OkCurl is an OkHttp-backed curl clone which allows you to test OkHttp's HTTP engine (including
-SPDY and HTTP/2) against web servers.
+HTTP/2) against web servers.
diff --git a/okhttp-tests/src/test/java/okhttp3/CallTest.java b/okhttp-tests/src/test/java/okhttp3/CallTest.java
index 44a0a987e6..1222c2a47d 100644
--- a/okhttp-tests/src/test/java/okhttp3/CallTest.java
+++ b/okhttp-tests/src/test/java/okhttp3/CallTest.java
@@ -181,11 +181,6 @@
     get();
   }
 
-  @Test public void get_SPDY_3() throws Exception {
-    enableProtocol(Protocol.SPDY_3);
-    get();
-  }
-
   @Test public void repeatedHeaderNames() throws Exception {
     server.enqueue(new MockResponse()
         .addHeader("B", "123")
@@ -199,11 +194,6 @@
     assertEquals(Arrays.asList("345", "456"), recordedRequest.getHeaders().values("A"));
   }
 
-  @Test public void repeatedHeaderNames_SPDY_3() throws Exception {
-    enableProtocol(Protocol.SPDY_3);
-    repeatedHeaderNames();
-  }
-
   @Test public void repeatedHeaderNames_HTTP_2() throws Exception {
     enableProtocol(Protocol.HTTP_2);
     repeatedHeaderNames();
@@ -249,11 +239,6 @@
     head();
   }
 
-  @Test public void head_SPDY_3() throws Exception {
-    enableProtocol(Protocol.SPDY_3);
-    head();
-  }
-
   @Test public void post() throws Exception {
     server.enqueue(new MockResponse().setBody("abc"));
 
@@ -283,11 +268,6 @@
     post();
   }
 
-  @Test public void post_SPDY_3() throws Exception {
-    enableProtocol(Protocol.SPDY_3);
-    post();
-  }
-
   @Test public void postZeroLength() throws Exception {
     server.enqueue(new MockResponse().setBody("abc"));
 
@@ -317,11 +297,6 @@
     postZeroLength();
   }
 
-  @Test public void postZeroLength_SPDY_3() throws Exception {
-    enableProtocol(Protocol.SPDY_3);
-    postZeroLength();
-  }
-
   @Test public void postBodyRetransmittedAfterAuthorizationFail() throws Exception {
     postBodyRetransmittedAfterAuthorizationFail("abc");
   }
@@ -336,11 +311,6 @@
     postBodyRetransmittedAfterAuthorizationFail("abc");
   }
 
-  @Test public void postBodyRetransmittedAfterAuthorizationFail_SPDY_3() throws Exception {
-    enableProtocol(Protocol.SPDY_3);
-    postBodyRetransmittedAfterAuthorizationFail("abc");
-  }
-
   /** Don't explode when resending an empty post. https://github.com/square/okhttp/issues/1131 */
   @Test public void postEmptyBodyRetransmittedAfterAuthorizationFail() throws Exception {
     postBodyRetransmittedAfterAuthorizationFail("");
@@ -356,11 +326,6 @@
     postBodyRetransmittedAfterAuthorizationFail("");
   }
 
-  @Test public void postEmptyBodyRetransmittedAfterAuthorizationFail_SPDY_3() throws Exception {
-    enableProtocol(Protocol.SPDY_3);
-    postBodyRetransmittedAfterAuthorizationFail("");
-  }
-
   private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exception {
     server.enqueue(new MockResponse().setResponseCode(401));
     server.enqueue(new MockResponse());
@@ -452,11 +417,6 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
     delete();
   }
 
-  @Test public void delete_SPDY_3() throws Exception {
-    enableProtocol(Protocol.SPDY_3);
-    delete();
-  }
-
   @Test public void deleteWithRequestBody() throws Exception {
     server.enqueue(new MockResponse().setBody("abc"));
 
@@ -503,11 +463,6 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
     put();
   }
 
-  @Test public void put_SPDY_3() throws Exception {
-    enableProtocol(Protocol.SPDY_3);
-    put();
-  }
-
   @Test public void patch() throws Exception {
     server.enqueue(new MockResponse().setBody("abc"));
 
@@ -537,11 +492,6 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
     patch();
   }
 
-  @Test public void patch_SPDY_3() throws Exception {
-    enableProtocol(Protocol.SPDY_3);
-    patch();
-  }
-
   @Test public void unspecifiedRequestBodyContentTypeDoesNotGetDefault() throws Exception {
     server.enqueue(new MockResponse());
 
@@ -1890,11 +1840,6 @@ private InetSocketAddress startNullServer() throws IOException {
     cancelInFlightBeforeResponseReadThrowsIOE();
   }
 
-  @Test public void cancelInFlightBeforeResponseReadThrowsIOE_SPDY_3() throws Exception {
-    enableProtocol(Protocol.SPDY_3);
-    cancelInFlightBeforeResponseReadThrowsIOE();
-  }
-
   /**
    * This test puts a request in front of one that is to be canceled, so that it is canceled before
    * I/O takes place.
@@ -1940,11 +1885,6 @@ private InetSocketAddress startNullServer() throws IOException {
     canceledBeforeIOSignalsOnFailure();
   }
 
-  @Test public void canceledBeforeIOSignalsOnFailure_SPDY_3() throws Exception {
-    enableProtocol(Protocol.SPDY_3);
-    canceledBeforeIOSignalsOnFailure();
-  }
-
   @Test public void canceledBeforeResponseReadSignalsOnFailure() throws Exception {
     Request requestA = new Request.Builder().url(server.url("/a")).build();
     final Call call = client.newCall(requestA);
@@ -1972,11 +1912,6 @@ private InetSocketAddress startNullServer() throws IOException {
     canceledBeforeResponseReadSignalsOnFailure();
   }
 
-  @Test public void canceledBeforeResponseReadSignalsOnFailure_SPDY_3() throws Exception {
-    enableProtocol(Protocol.SPDY_3);
-    canceledBeforeResponseReadSignalsOnFailure();
-  }
-
   /**
    * There's a race condition where the cancel may apply after the stream has already been
    * processed.
@@ -2026,12 +1961,6 @@ private InetSocketAddress startNullServer() throws IOException {
     canceledAfterResponseIsDeliveredBreaksStreamButSignalsOnce();
   }
 
-  @Test public void canceledAfterResponseIsDeliveredBreaksStreamButSignalsOnce_SPDY_3()
-      throws Exception {
-    enableProtocol(Protocol.SPDY_3);
-    canceledAfterResponseIsDeliveredBreaksStreamButSignalsOnce();
-  }
-
   @Test public void cancelWithInterceptor() throws Exception {
     client = client.newBuilder()
         .addInterceptor(new Interceptor() {
diff --git a/okhttp-tests/src/test/java/okhttp3/HeadersTest.java b/okhttp-tests/src/test/java/okhttp3/HeadersTest.java
index 10d388eb63..14ff874592 100644
--- a/okhttp-tests/src/test/java/okhttp3/HeadersTest.java
+++ b/okhttp-tests/src/test/java/okhttp3/HeadersTest.java
@@ -21,53 +21,20 @@
 import java.util.HashMap;
 import java.util.List;
 import java.util.Map;
+import okhttp3.internal.Internal;
 import okhttp3.internal.framed.Header;
 import okhttp3.internal.http.Http2xStream;
-import org.junit.Assert;
 import org.junit.Test;
 
 import static okhttp3.TestUtil.headerEntries;
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertFalse;
-import static org.junit.Assert.assertNull;
 import static org.junit.Assert.assertTrue;
 import static org.junit.Assert.fail;
 
 public final class HeadersTest {
-  @Test public void parseNameValueBlock() throws IOException {
-    List<Header> headerBlock = headerEntries(
-        "cache-control", "no-cache, no-store",
-        "set-cookie", "Cookie1\u0000Cookie2",
-        ":status", "200 OK",
-        ":version", "HTTP/1.1");
-    Request request = new Request.Builder().url("http://square.com/").build();
-    Response response = Http2xStream.readSpdy3HeadersList(headerBlock).request(request).build();
-    Headers headers = response.headers();
-    assertEquals(3, headers.size());
-    Assert.assertEquals(Protocol.SPDY_3, response.protocol());
-    assertEquals(200, response.code());
-    assertEquals("OK", response.message());
-    assertEquals("no-cache, no-store", headers.get("cache-control"));
-    assertEquals("Cookie2", headers.get("set-cookie"));
-    assertEquals("cache-control", headers.name(0));
-    assertEquals("no-cache, no-store", headers.value(0));
-    assertEquals("set-cookie", headers.name(1));
-    assertEquals("Cookie1", headers.value(1));
-    assertEquals("set-cookie", headers.name(2));
-    assertEquals("Cookie2", headers.value(2));
-    assertNull(headers.get(":status"));
-    assertNull(headers.get(":version"));
-  }
-
-  @Test public void readNameValueBlockDropsForbiddenHeadersSpdy3() throws IOException {
-    List<Header> headerBlock = headerEntries(
-        ":status", "200 OK",
-        ":version", "HTTP/1.1",
-        "connection", "close");
-    Request request = new Request.Builder().url("http://square.com/").build();
-    Response response = Http2xStream.readSpdy3HeadersList(headerBlock).request(request).build();
-    Headers headers = response.headers();
-    assertEquals(0, headers.size());
+  static {
+    Internal.initializeInstanceForTests();
   }
 
   @Test public void readNameValueBlockDropsForbiddenHeadersHttp2() throws IOException {
@@ -83,42 +50,6 @@
     assertEquals("HTTP/1.1", headers.value(0));
   }
 
-  @Test public void spdy3HeadersList() {
-    Request request = new Request.Builder()
-        .url("http://square.com/")
-        .header("cache-control", "no-cache, no-store")
-        .addHeader("set-cookie", "Cookie1")
-        .addHeader("set-cookie", "Cookie2")
-        .header(":status", "200 OK")
-        .build();
-    List<Header> headerBlock = Http2xStream.spdy3HeadersList(request);
-    List<Header> expected = headerEntries(
-        ":method", "GET",
-        ":path", "/",
-        ":version", "HTTP/1.1",
-        ":host", "square.com",
-        ":scheme", "http",
-        "cache-control", "no-cache, no-store",
-        "set-cookie", "Cookie1\u0000Cookie2",
-        ":status", "200 OK");
-    assertEquals(expected, headerBlock);
-  }
-
-  @Test public void spdy3HeadersListDropsForbiddenHeadersSpdy3() {
-    Request request = new Request.Builder()
-        .url("http://square.com/")
-        .header("Connection", "close")
-        .header("Transfer-Encoding", "chunked")
-        .build();
-    List<Header> expected = headerEntries(
-        ":method", "GET",
-        ":path", "/",
-        ":version", "HTTP/1.1",
-        ":host", "square.com",
-        ":scheme", "http");
-    assertEquals(expected, Http2xStream.spdy3HeadersList(request));
-  }
-
   @Test public void http2HeadersListDropsForbiddenHeadersHttp2() {
     Request request = new Request.Builder()
         .url("http://square.com/")
diff --git a/okhttp-tests/src/test/java/okhttp3/URLConnectionTest.java b/okhttp-tests/src/test/java/okhttp3/URLConnectionTest.java
index 6b4c8f13d2..9fecda9d32 100644
--- a/okhttp-tests/src/test/java/okhttp3/URLConnectionTest.java
+++ b/okhttp-tests/src/test/java/okhttp3/URLConnectionTest.java
@@ -1519,11 +1519,6 @@ private void testAuthenticateWithStreamingPost(StreamingMode streamingMode) thro
     postBodyRetransmittedAfterAuthorizationFail("abc");
   }
 
-  @Test public void postBodyRetransmittedAfterAuthorizationFail_SPDY_3() throws Exception {
-    enableProtocol(Protocol.SPDY_3);
-    postBodyRetransmittedAfterAuthorizationFail("abc");
-  }
-
   @Test public void postBodyRetransmittedAfterAuthorizationFail_HTTP_2() throws Exception {
     enableProtocol(Protocol.HTTP_2);
     postBodyRetransmittedAfterAuthorizationFail("abc");
@@ -1534,11 +1529,6 @@ private void testAuthenticateWithStreamingPost(StreamingMode streamingMode) thro
     postBodyRetransmittedAfterAuthorizationFail("");
   }
 
-  @Test public void postEmptyBodyRetransmittedAfterAuthorizationFail_SPDY_3() throws Exception {
-    enableProtocol(Protocol.SPDY_3);
-    postBodyRetransmittedAfterAuthorizationFail("");
-  }
-
   @Test public void postEmptyBodyRetransmittedAfterAuthorizationFail_HTTP_2() throws Exception {
     enableProtocol(Protocol.HTTP_2);
     postBodyRetransmittedAfterAuthorizationFail("");
@@ -2982,16 +2972,6 @@ private void reusedConnectionFailsWithPost(TransferKind transferKind, int reques
     fail("TODO");
   }
 
-  @Test @Ignore public void headerNamesContainingNullCharacter() {
-    // This is relevant for SPDY
-    fail("TODO");
-  }
-
-  @Test @Ignore public void headerValuesContainingNullCharacter() {
-    // This is relevant for SPDY
-    fail("TODO");
-  }
-
   @Test public void emptyRequestHeaderValueIsAllowed() throws Exception {
     server.enqueue(new MockResponse().setBody("body"));
     connection = urlFactory.open(server.url("/").url());
@@ -3186,10 +3166,6 @@ private void reusedConnectionFailsWithPost(TransferKind transferKind, int reques
     }
   }
 
-  @Test public void setsNegotiatedProtocolHeader_SPDY_3() throws Exception {
-    setsNegotiatedProtocolHeader(Protocol.SPDY_3);
-  }
-
   @Test public void setsNegotiatedProtocolHeader_HTTP_2() throws Exception {
     setsNegotiatedProtocolHeader(Protocol.HTTP_2);
   }
@@ -3225,11 +3201,6 @@ private void setsNegotiatedProtocolHeader(Protocol protocol) throws IOException
     zeroLengthPayload("POST");
   }
 
-  @Test public void zeroLengthPost_SPDY_3() throws Exception {
-    enableProtocol(Protocol.SPDY_3);
-    zeroLengthPost();
-  }
-
   @Test public void zeroLengthPost_HTTP_2() throws Exception {
     enableProtocol(Protocol.HTTP_2);
     zeroLengthPost();
@@ -3240,11 +3211,6 @@ private void setsNegotiatedProtocolHeader(Protocol protocol) throws IOException
     zeroLengthPayload("PUT");
   }
 
-  @Test public void zeroLengthPut_SPDY_3() throws Exception {
-    enableProtocol(Protocol.SPDY_3);
-    zeroLengthPut();
-  }
-
   @Test public void zeroLengthPut_HTTP_2() throws Exception {
     enableProtocol(Protocol.HTTP_2);
     zeroLengthPut();
@@ -3289,7 +3255,7 @@ private void zeroLengthPayload(String method)
 
   @Test public void setProtocolsWithoutHttp11() throws Exception {
     try {
-      new OkHttpClient.Builder().protocols(Arrays.asList(Protocol.SPDY_3));
+      new OkHttpClient.Builder().protocols(Arrays.asList(Protocol.HTTP_2));
       fail();
     } catch (IllegalArgumentException expected) {
     }
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/framed/BaseTestHandler.java b/okhttp-tests/src/test/java/okhttp3/internal/framed/BaseTestHandler.java
index d619feff7c..2ffbbccb9f 100644
--- a/okhttp-tests/src/test/java/okhttp3/internal/framed/BaseTestHandler.java
+++ b/okhttp-tests/src/test/java/okhttp3/internal/framed/BaseTestHandler.java
@@ -28,9 +28,8 @@
     fail();
   }
 
-  @Override
-  public void headers(boolean outFinished, boolean inFinished, int streamId, int associatedStreamId,
-      List<Header> headerBlock, HeadersMode headersMode) {
+  @Override public void headers(boolean inFinished, int streamId, int associatedStreamId,
+      List<Header> headerBlock) {
     fail();
   }
 
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/framed/HpackTest.java b/okhttp-tests/src/test/java/okhttp3/internal/framed/HpackTest.java
index b6b62208a1..afd9dae031 100644
--- a/okhttp-tests/src/test/java/okhttp3/internal/framed/HpackTest.java
+++ b/okhttp-tests/src/test/java/okhttp3/internal/framed/HpackTest.java
@@ -28,8 +28,7 @@
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.fail;
 
-public class HpackTest {
-
+public final class HpackTest {
   private final Buffer bytesIn = new Buffer();
   private Hpack.Reader hpackReader;
   private Buffer bytesOut = new Buffer();
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/framed/Http2ConnectionTest.java b/okhttp-tests/src/test/java/okhttp3/internal/framed/Http2ConnectionTest.java
index 9b7b771367..3c91a3f942 100644
--- a/okhttp-tests/src/test/java/okhttp3/internal/framed/Http2ConnectionTest.java
+++ b/okhttp-tests/src/test/java/okhttp3/internal/framed/Http2ConnectionTest.java
@@ -16,63 +16,74 @@
 package okhttp3.internal.framed;
 
 import java.io.IOException;
+import java.io.InterruptedIOException;
 import java.net.Socket;
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.List;
+import java.util.concurrent.CountDownLatch;
 import java.util.concurrent.TimeUnit;
+import java.util.concurrent.atomic.AtomicInteger;
+import okhttp3.internal.Util;
+import okhttp3.internal.framed.MockHttp2Peer.InFrame;
+import okio.AsyncTimeout;
 import okio.Buffer;
 import okio.BufferedSink;
 import okio.BufferedSource;
 import okio.Okio;
+import okio.Sink;
 import okio.Source;
 import org.junit.After;
-import org.junit.Ignore;
+import org.junit.Rule;
 import org.junit.Test;
+import org.junit.rules.TestRule;
+import org.junit.rules.Timeout;
 
 import static okhttp3.TestUtil.headerEntries;
 import static okhttp3.TestUtil.repeat;
 import static okhttp3.internal.Util.EMPTY_BYTE_ARRAY;
 import static okhttp3.internal.framed.ErrorCode.CANCEL;
+import static okhttp3.internal.framed.ErrorCode.INTERNAL_ERROR;
 import static okhttp3.internal.framed.ErrorCode.PROTOCOL_ERROR;
+import static okhttp3.internal.framed.ErrorCode.REFUSED_STREAM;
+import static okhttp3.internal.framed.Http2.TYPE_DATA;
+import static okhttp3.internal.framed.Http2.TYPE_GOAWAY;
+import static okhttp3.internal.framed.Http2.TYPE_HEADERS;
+import static okhttp3.internal.framed.Http2.TYPE_PING;
+import static okhttp3.internal.framed.Http2.TYPE_RST_STREAM;
+import static okhttp3.internal.framed.Http2.TYPE_SETTINGS;
+import static okhttp3.internal.framed.Http2.TYPE_WINDOW_UPDATE;
 import static okhttp3.internal.framed.Settings.DEFAULT_INITIAL_WINDOW_SIZE;
 import static okhttp3.internal.framed.Settings.ENABLE_PUSH;
 import static okhttp3.internal.framed.Settings.HEADER_TABLE_SIZE;
 import static okhttp3.internal.framed.Settings.INITIAL_WINDOW_SIZE;
+import static okhttp3.internal.framed.Settings.MAX_CONCURRENT_STREAMS;
 import static okhttp3.internal.framed.Settings.MAX_FRAME_SIZE;
-import static okhttp3.internal.framed.Settings.PERSIST_VALUE;
-import static okhttp3.internal.framed.Spdy3.TYPE_DATA;
-import static okhttp3.internal.framed.Spdy3.TYPE_HEADERS;
-import static okhttp3.internal.framed.Spdy3.TYPE_PING;
-import static okhttp3.internal.framed.Spdy3.TYPE_RST_STREAM;
-import static okhttp3.internal.framed.Spdy3.TYPE_SETTINGS;
-import static okhttp3.internal.framed.Spdy3.TYPE_WINDOW_UPDATE;
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertFalse;
 import static org.junit.Assert.assertTrue;
 import static org.junit.Assert.fail;
 
 public final class Http2ConnectionTest {
-  private static final Variant HTTP_2 = new Http2();
-  private final MockSpdyPeer peer = new MockSpdyPeer();
+  private final MockHttp2Peer peer = new MockHttp2Peer();
+
+  @Rule public final TestRule timeout = new Timeout(5_000);
 
   @After public void tearDown() throws Exception {
     peer.close();
   }
 
   @Test public void serverPingsClientHttp2() throws Exception {
-    peer.setVariantAndClient(HTTP_2, false);
-
     // write the mocking script
     peer.sendFrame().ping(false, 2, 3);
     peer.acceptFrame(); // PING
     peer.play();
 
     // play it back
-    connection(peer, HTTP_2);
+    connection(peer);
 
     // verify the peer received what was expected
-    MockSpdyPeer.InFrame ping = peer.takeFrame();
+    InFrame ping = peer.takeFrame();
     assertEquals(TYPE_PING, ping.type);
     assertEquals(0, ping.streamId);
     assertEquals(2, ping.payload1);
@@ -81,21 +92,19 @@
   }
 
   @Test public void clientPingsServerHttp2() throws Exception {
-    peer.setVariantAndClient(HTTP_2, false);
-
     // write the mocking script
     peer.acceptFrame(); // PING
     peer.sendFrame().ping(true, 1, 5);
     peer.play();
 
     // play it back
-    FramedConnection connection = connection(peer, HTTP_2);
+    FramedConnection connection = connection(peer);
     Ping ping = connection.ping();
     assertTrue(ping.roundTripTime() > 0);
     assertTrue(ping.roundTripTime() < TimeUnit.SECONDS.toNanos(1));
 
     // verify the peer received what was expected
-    MockSpdyPeer.InFrame pingFrame = peer.takeFrame();
+    InFrame pingFrame = peer.takeFrame();
     assertEquals(0, pingFrame.streamId);
     assertEquals(1, pingFrame.payload1);
     assertEquals(0x4f4b6f6b, pingFrame.payload2); // connection.ping() sets this.
@@ -103,12 +112,10 @@
   }
 
   @Test public void peerHttp2ServerLowersInitialWindowSize() throws Exception {
-    peer.setVariantAndClient(HTTP_2, false);
-
     Settings initial = new Settings();
-    initial.set(INITIAL_WINDOW_SIZE, PERSIST_VALUE, 1684);
+    initial.set(INITIAL_WINDOW_SIZE, 1684);
     Settings shouldntImpactConnection = new Settings();
-    shouldntImpactConnection.set(INITIAL_WINDOW_SIZE, PERSIST_VALUE, 3368);
+    shouldntImpactConnection.set(INITIAL_WINDOW_SIZE, 3368);
 
     peer.sendFrame().settings(initial);
     peer.acceptFrame(); // ACK
@@ -117,10 +124,10 @@
     peer.acceptFrame(); // HEADERS
     peer.play();
 
-    FramedConnection connection = connection(peer, HTTP_2);
+    FramedConnection connection = connection(peer);
 
     // Verify the peer received the ACK.
-    MockSpdyPeer.InFrame ackFrame = peer.takeFrame();
+    InFrame ackFrame = peer.takeFrame();
     assertEquals(TYPE_SETTINGS, ackFrame.type);
     assertEquals(0, ackFrame.streamId);
     assertTrue(ackFrame.ack);
@@ -130,9 +137,9 @@
     assertTrue(ackFrame.ack);
 
     // This stream was created *after* the connection settings were adjusted.
-    FramedStream stream = connection.newStream(headerEntries("a", "android"), false, true);
+    FramedStream stream = connection.newStream(headerEntries("a", "android"), false);
 
-    assertEquals(3368, connection.peerSettings.getInitialWindowSize(DEFAULT_INITIAL_WINDOW_SIZE));
+    assertEquals(3368, connection.peerSettings.getInitialWindowSize());
     assertEquals(1684, connection.bytesLeftInWriteWindow); // initial wasn't affected.
     // New Stream is has the most recent initial window size.
     assertEquals(3368, stream.bytesLeftInWriteWindow);
@@ -141,13 +148,13 @@
   @Test public void peerHttp2ServerZerosCompressionTable() throws Exception {
     boolean client = false; // Peer is server, so we are client.
     Settings settings = new Settings();
-    settings.set(HEADER_TABLE_SIZE, PERSIST_VALUE, 0);
+    settings.set(HEADER_TABLE_SIZE, 0);
 
     FramedConnection connection = sendHttp2SettingsAndCheckForAck(client, settings);
 
     // Verify the peer's settings were read and applied.
     assertEquals(0, connection.peerSettings.getHeaderTableSize());
-    Http2.Writer frameWriter = (Http2.Writer) connection.frameWriter;
+    FrameWriter frameWriter = connection.frameWriter;
     assertEquals(0, frameWriter.hpackWriter.dynamicTableByteCount);
     assertEquals(0, frameWriter.hpackWriter.headerTableSizeSetting);
   }
@@ -155,7 +162,7 @@
   @Test public void peerHttp2ClientDisablesPush() throws Exception {
     boolean client = false; // Peer is client, so we are server.
     Settings settings = new Settings();
-    settings.set(ENABLE_PUSH, 0, 0); // The peer client disables push.
+    settings.set(ENABLE_PUSH, 0); // The peer client disables push.
 
     FramedConnection connection = sendHttp2SettingsAndCheckForAck(client, settings);
 
@@ -166,7 +173,7 @@
   @Test public void peerIncreasesMaxFrameSize() throws Exception {
     int newMaxFrameSize = 0x4001;
     Settings settings = new Settings();
-    settings.set(MAX_FRAME_SIZE, 0, newMaxFrameSize);
+    settings.set(MAX_FRAME_SIZE, newMaxFrameSize);
 
     FramedConnection connection = sendHttp2SettingsAndCheckForAck(true, settings);
 
@@ -181,10 +188,10 @@
    * https://github.com/square/okhttp/issues/2543
    */
   @Test public void peerSetsZeroFlowControl() throws Exception {
-    peer.setVariantAndClient(HTTP_2, true);
+    peer.setClient(true);
 
     // Write the mocking script.
-    peer.sendFrame().settings(new Settings().set(INITIAL_WINDOW_SIZE, 0, 0));
+    peer.sendFrame().settings(new Settings().set(INITIAL_WINDOW_SIZE, 0));
     peer.sendFrame().windowUpdate(0, 10); // Increase the connection window size.
     peer.acceptFrame(); // PING or SETTINGS ACK
     peer.acceptFrame(); // PING or SETTINGS ACK
@@ -197,9 +204,9 @@
     peer.play();
 
     // Play it back.
-    FramedConnection connection = connection(peer, HTTP_2);
+    FramedConnection connection = connection(peer);
     connection.ping().roundTripTime(); // Ensure the SETTINGS have been received.
-    FramedStream stream = connection.newStream(headerEntries("a", "android"), true, true);
+    FramedStream stream = connection.newStream(headerEntries("a", "android"), true);
     BufferedSink sink = Okio.buffer(stream.getSink());
     sink.writeUtf8("abcdefghi");
     sink.flush();
@@ -207,21 +214,19 @@
     // Verify the peer received what was expected.
     peer.takeFrame(); // PING or SETTINGS ACK
     peer.takeFrame(); // PING or SETTINGS ACK
-    MockSpdyPeer.InFrame headers = peer.takeFrame();
+    InFrame headers = peer.takeFrame();
     assertEquals(TYPE_HEADERS, headers.type);
-    MockSpdyPeer.InFrame data1 = peer.takeFrame();
+    InFrame data1 = peer.takeFrame();
     assertEquals(TYPE_DATA, data1.type);
     assertEquals(3, data1.streamId);
     assertTrue(Arrays.equals("abcde".getBytes("UTF-8"), data1.data));
-    MockSpdyPeer.InFrame data2 = peer.takeFrame();
+    InFrame data2 = peer.takeFrame();
     assertEquals(TYPE_DATA, data2.type);
     assertEquals(3, data2.streamId);
     assertTrue(Arrays.equals("fghi".getBytes("UTF-8"), data2.data));
   }
 
   @Test public void receiveGoAwayHttp2() throws Exception {
-    peer.setVariantAndClient(HTTP_2, false);
-
     // write the mocking script
     peer.acceptFrame(); // SYN_STREAM 3
     peer.acceptFrame(); // SYN_STREAM 5
@@ -232,9 +237,9 @@
     peer.play();
 
     // play it back
-    FramedConnection connection = connection(peer, HTTP_2);
-    FramedStream stream1 = connection.newStream(headerEntries("a", "android"), true, true);
-    FramedStream stream2 = connection.newStream(headerEntries("b", "banana"), true, true);
+    FramedConnection connection = connection(peer);
+    FramedStream stream1 = connection.newStream(headerEntries("a", "android"), true);
+    FramedStream stream2 = connection.newStream(headerEntries("b", "banana"), true);
     connection.ping().roundTripTime(); // Ensure the GO_AWAY that resets stream2 has been received.
     BufferedSink sink1 = Okio.buffer(stream1.getSink());
     BufferedSink sink2 = Okio.buffer(stream2.getSink());
@@ -249,7 +254,7 @@
     sink1.writeUtf8("def");
     sink1.close();
     try {
-      connection.newStream(headerEntries("c", "cola"), true, true);
+      connection.newStream(headerEntries("c", "cola"), true);
       fail();
     } catch (IOException expected) {
       assertEquals("shutdown", expected.getMessage());
@@ -259,21 +264,19 @@
     assertEquals(1, connection.openStreamCount());
 
     // verify the peer received what was expected
-    MockSpdyPeer.InFrame synStream1 = peer.takeFrame();
+    InFrame synStream1 = peer.takeFrame();
     assertEquals(TYPE_HEADERS, synStream1.type);
-    MockSpdyPeer.InFrame synStream2 = peer.takeFrame();
+    InFrame synStream2 = peer.takeFrame();
     assertEquals(TYPE_HEADERS, synStream2.type);
-    MockSpdyPeer.InFrame ping = peer.takeFrame();
+    InFrame ping = peer.takeFrame();
     assertEquals(TYPE_PING, ping.type);
-    MockSpdyPeer.InFrame data1 = peer.takeFrame();
+    InFrame data1 = peer.takeFrame();
     assertEquals(TYPE_DATA, data1.type);
     assertEquals(3, data1.streamId);
     assertTrue(Arrays.equals("abcdef".getBytes("UTF-8"), data1.data));
   }
 
   @Test public void readSendsWindowUpdateHttp2() throws Exception {
-    peer.setVariantAndClient(HTTP_2, false);
-
     int windowSize = 100;
     int windowUpdateThreshold = 50;
 
@@ -292,9 +295,9 @@
     peer.play();
 
     // Play it back.
-    FramedConnection connection = connection(peer, HTTP_2);
-    connection.okHttpSettings.set(INITIAL_WINDOW_SIZE, 0, windowSize);
-    FramedStream stream = connection.newStream(headerEntries("b", "banana"), false, true);
+    FramedConnection connection = connection(peer);
+    connection.okHttpSettings.set(INITIAL_WINDOW_SIZE, windowSize);
+    FramedStream stream = connection.newStream(headerEntries("b", "banana"), false);
     assertEquals(0, stream.unacknowledgedBytesRead);
     assertEquals(headerEntries("a", "android"), stream.getResponseHeaders());
     Source in = stream.getSource();
@@ -303,12 +306,12 @@
     assertEquals(-1, in.read(buffer, 1));
     assertEquals(150, buffer.size());
 
-    MockSpdyPeer.InFrame synStream = peer.takeFrame();
+    InFrame synStream = peer.takeFrame();
     assertEquals(TYPE_HEADERS, synStream.type);
     for (int i = 0; i < 3; i++) {
       List<Integer> windowUpdateStreamIds = new ArrayList<>(2);
       for (int j = 0; j < 2; j++) {
-        MockSpdyPeer.InFrame windowUpdate = peer.takeFrame();
+        InFrame windowUpdate = peer.takeFrame();
         assertEquals(TYPE_WINDOW_UPDATE, windowUpdate.type);
         windowUpdateStreamIds.add(windowUpdate.streamId);
         assertEquals(windowUpdateThreshold, windowUpdate.windowSizeIncrement);
@@ -318,13 +321,7 @@
     }
   }
 
-  private Buffer data(int byteCount) {
-    return new Buffer().write(new byte[byteCount]);
-  }
-
   @Test public void serverSendsEmptyDataClientDoesntSendWindowUpdateHttp2() throws Exception {
-    peer.setVariantAndClient(HTTP_2, false);
-
     // Write the mocking script.
     peer.acceptFrame(); // SYN_STREAM
     peer.sendFrame().synReply(false, 3, headerEntries("a", "android"));
@@ -332,19 +329,17 @@ private Buffer data(int byteCount) {
     peer.play();
 
     // Play it back.
-    FramedConnection connection = connection(peer, HTTP_2);
-    FramedStream client = connection.newStream(headerEntries("b", "banana"), false, true);
+    FramedConnection connection = connection(peer);
+    FramedStream client = connection.newStream(headerEntries("b", "banana"), false);
     assertEquals(-1, client.getSource().read(new Buffer(), 1));
 
     // Verify the peer received what was expected.
-    MockSpdyPeer.InFrame synStream = peer.takeFrame();
+    InFrame synStream = peer.takeFrame();
     assertEquals(TYPE_HEADERS, synStream.type);
     assertEquals(3, peer.frameCount());
   }
 
   @Test public void clientSendsEmptyDataServerDoesntSendWindowUpdateHttp2() throws Exception {
-    peer.setVariantAndClient(HTTP_2, false);
-
     // Write the mocking script.
     peer.acceptFrame(); // SYN_STREAM
     peer.acceptFrame(); // DATA
@@ -352,8 +347,8 @@ private Buffer data(int byteCount) {
     peer.play();
 
     // Play it back.
-    FramedConnection connection = connection(peer, HTTP_2);
-    FramedStream client = connection.newStream(headerEntries("b", "banana"), true, true);
+    FramedConnection connection = connection(peer);
+    FramedStream client = connection.newStream(headerEntries("b", "banana"), true);
     BufferedSink out = Okio.buffer(client.getSink());
     out.write(EMPTY_BYTE_ARRAY);
     out.flush();
@@ -366,8 +361,6 @@ private Buffer data(int byteCount) {
   }
 
   @Test public void maxFrameSizeHonored() throws Exception {
-    peer.setVariantAndClient(HTTP_2, false);
-
     byte[] buff = new byte[peer.maxOutboundDataLength() + 1];
     Arrays.fill(buff, (byte) '*');
 
@@ -379,24 +372,22 @@ private Buffer data(int byteCount) {
     peer.play();
 
     // play it back
-    FramedConnection connection = connection(peer, HTTP_2);
-    FramedStream stream = connection.newStream(headerEntries("b", "banana"), true, true);
+    FramedConnection connection = connection(peer);
+    FramedStream stream = connection.newStream(headerEntries("b", "banana"), true);
     BufferedSink out = Okio.buffer(stream.getSink());
     out.write(buff);
     out.flush();
     out.close();
 
-    MockSpdyPeer.InFrame synStream = peer.takeFrame();
+    InFrame synStream = peer.takeFrame();
     assertEquals(TYPE_HEADERS, synStream.type);
-    MockSpdyPeer.InFrame data = peer.takeFrame();
+    InFrame data = peer.takeFrame();
     assertEquals(peer.maxOutboundDataLength(), data.data.length);
     data = peer.takeFrame();
     assertEquals(1, data.data.length);
   }
 
   @Test public void pushPromiseStream() throws Exception {
-    peer.setVariantAndClient(HTTP_2, false);
-
     // write the mocking script
     peer.acceptFrame(); // SYN_STREAM
     peer.sendFrame().synReply(false, 3, headerEntries("a", "android"));
@@ -417,11 +408,11 @@ private Buffer data(int byteCount) {
     RecordingPushObserver observer = new RecordingPushObserver();
 
     // play it back
-    FramedConnection connection = connectionBuilder(peer, HTTP_2)
+    FramedConnection connection = connectionBuilder(peer)
         .pushObserver(observer)
         .build();
     connection.start(false);
-    FramedStream client = connection.newStream(headerEntries("b", "banana"), false, true);
+    FramedStream client = connection.newStream(headerEntries("b", "banana"), false);
     assertEquals(-1, client.getSource().read(new Buffer(), 1));
 
     // verify the peer received what was expected
@@ -432,8 +423,6 @@ private Buffer data(int byteCount) {
   }
 
   @Test public void doublePushPromise() throws Exception {
-    peer.setVariantAndClient(HTTP_2, false);
-
     // write the mocking script
     peer.sendFrame().pushPromise(3, 2, headerEntries("a", "android"));
     peer.acceptFrame(); // SYN_REPLY
@@ -442,9 +431,9 @@ private Buffer data(int byteCount) {
     peer.play();
 
     // play it back
-    FramedConnection connection = connectionBuilder(peer, HTTP_2).build();
+    FramedConnection connection = connectionBuilder(peer).build();
     connection.start(false);
-    connection.newStream(headerEntries("b", "banana"), false, true);
+    connection.newStream(headerEntries("b", "banana"), false);
 
     // verify the peer received what was expected
     assertEquals(TYPE_HEADERS, peer.takeFrame().type);
@@ -452,8 +441,6 @@ private Buffer data(int byteCount) {
   }
 
   @Test public void pushPromiseStreamsAutomaticallyCancel() throws Exception {
-    peer.setVariantAndClient(HTTP_2, false);
-
     // write the mocking script
     peer.sendFrame().pushPromise(3, 2, Arrays.asList(
         new Header(Header.TARGET_METHOD, "GET"),
@@ -468,13 +455,13 @@ private Buffer data(int byteCount) {
     peer.play();
 
     // play it back
-    FramedConnection connection = connectionBuilder(peer, HTTP_2)
+    FramedConnection connection = connectionBuilder(peer)
         .pushObserver(PushObserver.CANCEL)
         .build();
     connection.start(false);
 
     // verify the peer received what was expected
-    MockSpdyPeer.InFrame rstStream = peer.takeFrame();
+    InFrame rstStream = peer.takeFrame();
     assertEquals(TYPE_RST_STREAM, rstStream.type);
     assertEquals(2, rstStream.streamId);
     assertEquals(CANCEL, rstStream.errorCode);
@@ -488,7 +475,6 @@ private Buffer data(int byteCount) {
    * <p>See https://github.com/square/okhttp/issues/1651
    */
   @Test public void socketExceptionWhileWritingHeaders() throws Exception {
-    peer.setVariantAndClient(HTTP_2, false);
     peer.acceptFrame(); // SYN_STREAM.
     peer.play();
 
@@ -497,56 +483,1066 @@ private Buffer data(int byteCount) {
     FramedConnection connection = new FramedConnection.Builder(true)
         .socket(socket)
         .pushObserver(IGNORE)
-        .protocol(HTTP_2.getProtocol())
         .build();
     connection.start(false);
     socket.shutdownOutput();
     try {
-      connection.newStream(headerEntries("a", longString), false, true);
+      connection.newStream(headerEntries("a", longString), false);
       fail();
     } catch (IOException expected) {
     }
     try {
-      connection.newStream(headerEntries("b", longString), false, true);
+      connection.newStream(headerEntries("b", longString), false);
       fail();
     } catch (IOException expected) {
     }
   }
 
-  private FramedConnection sendHttp2SettingsAndCheckForAck(boolean client, Settings settings)
-      throws IOException, InterruptedException {
-    peer.setVariantAndClient(HTTP_2, client);
-    peer.sendFrame().settings(settings);
-    peer.acceptFrame(); // ACK
+  @Test public void clientCreatesStreamAndServerReplies() throws Exception {
+    // write the mocking script
+    peer.acceptFrame(); // SYN_STREAM
+    peer.acceptFrame(); // DATA
+    peer.sendFrame().synReply(false, 3, headerEntries("a", "android"));
+    peer.sendFrame().data(true, 3, new Buffer().writeUtf8("robot"), 5);
+    peer.acceptFrame(); // PING
+    peer.sendFrame().ping(true, 1, 0); // PING
+    peer.play();
+
+    // play it back
+    FramedConnection connection = connection(peer);
+    FramedStream stream = connection.newStream(headerEntries("b", "banana"), true);
+    BufferedSink out = Okio.buffer(stream.getSink());
+    out.writeUtf8("c3po");
+    out.close();
+    assertEquals(headerEntries("a", "android"), stream.getResponseHeaders());
+    assertStreamData("robot", stream.getSource());
+    connection.ping().roundTripTime();
+    assertEquals(0, connection.openStreamCount());
+
+    // verify the peer received what was expected
+    InFrame synStream = peer.takeFrame();
+    assertEquals(TYPE_HEADERS, synStream.type);
+    assertFalse(synStream.outFinished);
+    assertEquals(3, synStream.streamId);
+    assertEquals(-1, synStream.associatedStreamId);
+    assertEquals(headerEntries("b", "banana"), synStream.headerBlock);
+    InFrame requestData = peer.takeFrame();
+    assertTrue(Arrays.equals("c3po".getBytes("UTF-8"), requestData.data));
+  }
+
+  @Test public void clientCreatesStreamAndServerRepliesWithFin() throws Exception {
+    // write the mocking script
+    peer.acceptFrame(); // SYN_STREAM
     peer.acceptFrame(); // PING
+    peer.sendFrame().synReply(true, 3, headerEntries("a", "android"));
     peer.sendFrame().ping(true, 1, 0);
     peer.play();
 
     // play it back
-    FramedConnection connection = connection(peer, HTTP_2);
+    FramedConnection connection = connection(peer);
+    connection.newStream(headerEntries("b", "banana"), false);
+    assertEquals(1, connection.openStreamCount());
+    connection.ping().roundTripTime(); // Ensure that the SYN_REPLY has been received.
+    assertEquals(0, connection.openStreamCount());
 
-    // verify the peer received the ACK
-    MockSpdyPeer.InFrame ackFrame = peer.takeFrame();
-    assertEquals(TYPE_SETTINGS, ackFrame.type);
-    assertEquals(0, ackFrame.streamId);
-    assertTrue(ackFrame.ack);
+    // verify the peer received what was expected
+    InFrame synStream = peer.takeFrame();
+    assertEquals(TYPE_HEADERS, synStream.type);
+    InFrame ping = peer.takeFrame();
+    assertEquals(TYPE_PING, ping.type);
+  }
 
-    connection.ping().roundTripTime(); // Ensure that settings have been applied before returning.
-    return connection;
+  @Test public void serverPingsClient() throws Exception {
+    // write the mocking script
+    peer.sendFrame().ping(false, 2, 0);
+    peer.acceptFrame(); // PING
+    peer.play();
+
+    // play it back
+    connection(peer);
+
+    // verify the peer received what was expected
+    InFrame ping = peer.takeFrame();
+    assertEquals(0, ping.streamId);
+    assertEquals(2, ping.payload1);
+    assertEquals(0, ping.payload2);
+    assertTrue(ping.ack);
+  }
+
+  @Test public void clientPingsServer() throws Exception {
+    // write the mocking script
+    peer.acceptFrame(); // PING
+    peer.sendFrame().ping(true, 1, 5);
+    peer.play();
+
+    // play it back
+    FramedConnection connection = connection(peer);
+    Ping ping = connection.ping();
+    assertTrue(ping.roundTripTime() > 0);
+    assertTrue(ping.roundTripTime() < TimeUnit.SECONDS.toNanos(1));
+
+    // verify the peer received what was expected
+    InFrame pingFrame = peer.takeFrame();
+    assertEquals(TYPE_PING, pingFrame.type);
+    assertEquals(1, pingFrame.payload1);
+    assertEquals(new Buffer().writeUtf8("OKok").readInt(), pingFrame.payload2);
+    assertFalse(pingFrame.ack);
+  }
+
+  @Test public void unexpectedPingIsNotReturned() throws Exception {
+    // write the mocking script
+    peer.sendFrame().ping(false, 2, 0);
+    peer.acceptFrame(); // PING
+    peer.sendFrame().ping(true, 3, 0); // This ping will not be returned.
+    peer.sendFrame().ping(false, 4, 0);
+    peer.acceptFrame(); // PING
+    peer.play();
+
+    // play it back
+    connection(peer);
+
+    // verify the peer received what was expected
+    InFrame ping2 = peer.takeFrame();
+    assertEquals(2, ping2.payload1);
+    InFrame ping4 = peer.takeFrame();
+    assertEquals(4, ping4.payload1);
   }
 
-  private FramedConnection connection(MockSpdyPeer peer, Variant variant) throws IOException {
-    FramedConnection connection = connectionBuilder(peer, variant).build();
+  @Test public void serverSendsSettingsToClient() throws Exception {
+    // write the mocking script
+    final Settings settings = new Settings();
+    settings.set(MAX_CONCURRENT_STREAMS, 10);
+    peer.sendFrame().settings(settings);
+    peer.sendFrame().ping(false, 2, 0);
+    peer.acceptFrame(); // PING
+    peer.play();
+
+    // play it back
+    final CountDownLatch maxConcurrentStreamsUpdated = new CountDownLatch(1);
+    final AtomicInteger maxConcurrentStreams = new AtomicInteger();
+    FramedConnection.Listener listener = new FramedConnection.Listener() {
+      @Override public void onStream(FramedStream stream) throws IOException {
+        throw new AssertionError();
+      }
+
+      @Override public void onSettings(FramedConnection connection) {
+        maxConcurrentStreams.set(connection.maxConcurrentStreams());
+        maxConcurrentStreamsUpdated.countDown();
+      }
+    };
+    FramedConnection connection = connectionBuilder(peer)
+        .listener(listener)
+        .build();
     connection.start(false);
-    return connection;
+
+    peer.takeFrame(); // Guarantees that the peer Settings frame has been processed.
+    synchronized (connection) {
+      assertEquals(10, connection.peerSettings.getMaxConcurrentStreams(-1));
+    }
+    maxConcurrentStreamsUpdated.await();
+    assertEquals(10, maxConcurrentStreams.get());
   }
 
-  private FramedConnection.Builder connectionBuilder(MockSpdyPeer peer, Variant variant)
-      throws IOException {
-    return new FramedConnection.Builder(true)
-        .socket(peer.openSocket())
-        .pushObserver(IGNORE)
-        .protocol(variant.getProtocol());
+  @Test public void multipleSettingsFramesAreMerged() throws Exception {
+    // write the mocking script
+    Settings settings1 = new Settings();
+    settings1.set(HEADER_TABLE_SIZE, 10000);
+    settings1.set(INITIAL_WINDOW_SIZE, 20000);
+    settings1.set(MAX_FRAME_SIZE, 30000);
+    peer.sendFrame().settings(settings1);
+    peer.acceptFrame(); // ACK SETTINGS
+    Settings settings2 = new Settings();
+    settings2.set(INITIAL_WINDOW_SIZE, 40000);
+    settings2.set(MAX_FRAME_SIZE, 50000);
+    settings2.set(MAX_CONCURRENT_STREAMS, 60000);
+    peer.sendFrame().settings(settings2);
+    peer.acceptFrame(); // ACK SETTINGS
+    peer.sendFrame().ping(false, 2, 0);
+    peer.acceptFrame(); // PING
+    peer.play();
+
+    // play it back
+    FramedConnection connection = connection(peer);
+
+    assertEquals(TYPE_SETTINGS, peer.takeFrame().type);
+    assertEquals(TYPE_SETTINGS, peer.takeFrame().type);
+    assertEquals(TYPE_PING, peer.takeFrame().type);
+    synchronized (connection) {
+      assertEquals(10000, connection.peerSettings.getHeaderTableSize());
+      assertEquals(40000, connection.peerSettings.getInitialWindowSize());
+      assertEquals(50000, connection.peerSettings.getMaxFrameSize(-1));
+      assertEquals(60000, connection.peerSettings.getMaxConcurrentStreams(-1));
+    }
+  }
+
+  @Test public void clearSettingsBeforeMerge() throws Exception {
+    // write the mocking script
+    Settings settings1 = new Settings();
+    settings1.set(HEADER_TABLE_SIZE, 10000);
+    settings1.set(INITIAL_WINDOW_SIZE, 20000);
+    settings1.set(MAX_FRAME_SIZE, 30000);
+    peer.sendFrame().settings(settings1);
+    peer.sendFrame().ping(false, 2, 0);
+    peer.acceptFrame();
+    peer.play();
+
+    // play it back
+    FramedConnection connection = connection(peer);
+
+    peer.takeFrame(); // Guarantees that the Settings frame has been processed.
+
+    // fake a settings frame with clear flag set.
+    Settings settings2 = new Settings();
+    settings2.set(MAX_CONCURRENT_STREAMS, 60000);
+    connection.readerRunnable.settings(true, settings2);
+
+    synchronized (connection) {
+      assertEquals(-1, connection.peerSettings.getHeaderTableSize());
+      assertEquals(DEFAULT_INITIAL_WINDOW_SIZE, connection.peerSettings.getInitialWindowSize());
+      assertEquals(-1, connection.peerSettings.getMaxFrameSize(-1));
+      assertEquals(60000, connection.peerSettings.getMaxConcurrentStreams(-1));
+    }
+  }
+
+  @Test public void bogusDataFrameDoesNotDisruptConnection() throws Exception {
+    // write the mocking script
+    peer.sendFrame().data(true, 41, new Buffer().writeUtf8("bogus"), 5);
+    peer.acceptFrame(); // RST_STREAM
+    peer.sendFrame().ping(false, 2, 0);
+    peer.acceptFrame(); // PING
+    peer.play();
+
+    // play it back
+    connection(peer);
+
+    // verify the peer received what was expected
+    InFrame rstStream = peer.takeFrame();
+    assertEquals(TYPE_RST_STREAM, rstStream.type);
+    assertEquals(41, rstStream.streamId);
+    assertEquals(PROTOCOL_ERROR, rstStream.errorCode);
+    InFrame ping = peer.takeFrame();
+    assertEquals(2, ping.payload1);
+  }
+
+  @Test public void bogusReplySilentlyIgnored() throws Exception {
+    // write the mocking script
+    peer.sendFrame().synReply(false, 41, headerEntries("a", "android"));
+    peer.sendFrame().ping(false, 2, 0);
+    peer.acceptFrame(); // PING
+    peer.play();
+
+    // play it back
+    connection(peer);
+
+    // verify the peer received what was expected
+    InFrame ping = peer.takeFrame();
+    assertEquals(2, ping.payload1);
+  }
+
+  @Test public void serverClosesClientOutputStream() throws Exception {
+    // write the mocking script
+    peer.acceptFrame(); // SYN_STREAM
+    peer.sendFrame().rstStream(3, CANCEL);
+    peer.acceptFrame(); // PING
+    peer.sendFrame().ping(true, 1, 0);
+    peer.play();
+
+    // play it back
+    FramedConnection connection = connection(peer);
+    FramedStream stream = connection.newStream(headerEntries("a", "android"), true);
+    BufferedSink out = Okio.buffer(stream.getSink());
+    connection.ping().roundTripTime(); // Ensure that the RST_CANCEL has been received.
+    try {
+      out.writeUtf8("square");
+      out.flush();
+      fail();
+    } catch (IOException expected) {
+      assertEquals("stream was reset: CANCEL", expected.getMessage());
+    }
+    try {
+      out.close();
+      fail();
+    } catch (IOException expected) {
+      // Close throws because buffered data wasn't flushed.
+    }
+    assertEquals(0, connection.openStreamCount());
+
+    // verify the peer received what was expected
+    InFrame synStream = peer.takeFrame();
+    assertEquals(TYPE_HEADERS, synStream.type);
+    assertFalse(synStream.inFinished);
+    assertFalse(synStream.outFinished);
+    InFrame ping = peer.takeFrame();
+    assertEquals(TYPE_PING, ping.type);
+    assertEquals(1, ping.payload1);
+  }
+
+  /**
+   * Test that the client sends a RST_STREAM if doing so won't disrupt the output stream.
+   */
+  @Test public void clientClosesClientInputStream() throws Exception {
+    // write the mocking script
+    peer.acceptFrame(); // SYN_STREAM
+    peer.acceptFrame(); // RST_STREAM
+    peer.play();
+
+    // play it back
+    FramedConnection connection = connection(peer);
+    FramedStream stream = connection.newStream(headerEntries("a", "android"), false);
+    Source in = stream.getSource();
+    BufferedSink out = Okio.buffer(stream.getSink());
+    in.close();
+    try {
+      in.read(new Buffer(), 1);
+      fail();
+    } catch (IOException expected) {
+      assertEquals("stream closed", expected.getMessage());
+    }
+    try {
+      out.writeUtf8("a");
+      out.flush();
+      fail();
+    } catch (IOException expected) {
+      assertEquals("stream finished", expected.getMessage());
+    }
+    assertEquals(0, connection.openStreamCount());
+
+    // verify the peer received what was expected
+    InFrame synStream = peer.takeFrame();
+    assertEquals(TYPE_HEADERS, synStream.type);
+    assertTrue(synStream.inFinished);
+    assertFalse(synStream.outFinished);
+    InFrame rstStream = peer.takeFrame();
+    assertEquals(TYPE_RST_STREAM, rstStream.type);
+    assertEquals(CANCEL, rstStream.errorCode);
+  }
+
+  /**
+   * Test that the client doesn't send a RST_STREAM if doing so will disrupt the output stream.
+   */
+  @Test public void clientClosesClientInputStreamIfOutputStreamIsClosed() throws Exception {
+    // write the mocking script
+    peer.acceptFrame(); // SYN_STREAM
+    peer.acceptFrame(); // DATA
+    peer.acceptFrame(); // DATA with FLAG_FIN
+    peer.acceptFrame(); // RST_STREAM
+    peer.play();
+
+    // play it back
+    FramedConnection connection = connection(peer);
+    FramedStream stream = connection.newStream(headerEntries("a", "android"), true);
+    Source source = stream.getSource();
+    BufferedSink out = Okio.buffer(stream.getSink());
+    source.close();
+    try {
+      source.read(new Buffer(), 1);
+      fail();
+    } catch (IOException expected) {
+      assertEquals("stream closed", expected.getMessage());
+    }
+    out.writeUtf8("square");
+    out.flush();
+    out.close();
+    assertEquals(0, connection.openStreamCount());
+
+    // verify the peer received what was expected
+    InFrame synStream = peer.takeFrame();
+    assertEquals(TYPE_HEADERS, synStream.type);
+    assertFalse(synStream.inFinished);
+    assertFalse(synStream.outFinished);
+    InFrame data = peer.takeFrame();
+    assertEquals(TYPE_DATA, data.type);
+    assertTrue(Arrays.equals("square".getBytes("UTF-8"), data.data));
+    InFrame fin = peer.takeFrame();
+    assertEquals(TYPE_DATA, fin.type);
+    assertTrue(fin.inFinished);
+    assertFalse(fin.outFinished);
+    InFrame rstStream = peer.takeFrame();
+    assertEquals(TYPE_RST_STREAM, rstStream.type);
+    assertEquals(CANCEL, rstStream.errorCode);
+  }
+
+  @Test public void serverClosesClientInputStream() throws Exception {
+    // write the mocking script
+    peer.acceptFrame(); // SYN_STREAM
+    peer.sendFrame().synReply(false, 3, headerEntries("b", "banana"));
+    peer.sendFrame().data(true, 3, new Buffer().writeUtf8("square"), 6);
+    peer.acceptFrame(); // PING
+    peer.sendFrame().ping(true, 1, 0);
+    peer.play();
+
+    // play it back
+    FramedConnection connection = connection(peer);
+    FramedStream stream = connection.newStream(headerEntries("a", "android"), false);
+    Source source = stream.getSource();
+    assertStreamData("square", source);
+    connection.ping().roundTripTime(); // Ensure that inFinished has been received.
+    assertEquals(0, connection.openStreamCount());
+
+    // verify the peer received what was expected
+    InFrame synStream = peer.takeFrame();
+    assertEquals(TYPE_HEADERS, synStream.type);
+    assertTrue(synStream.inFinished);
+    assertFalse(synStream.outFinished);
+  }
+
+  @Test public void remoteDoubleSynReply() throws Exception {
+    // write the mocking script
+    peer.acceptFrame(); // SYN_STREAM
+    peer.sendFrame().synReply(false, 3, headerEntries("a", "android"));
+    peer.acceptFrame(); // PING
+    peer.sendFrame().synReply(false, 3, headerEntries("b", "banana"));
+    peer.sendFrame().ping(true, 1, 0);
+    peer.play();
+
+    // play it back
+    FramedConnection connection = connection(peer);
+    FramedStream stream = connection.newStream(headerEntries("c", "cola"), false);
+    assertEquals(headerEntries("a", "android"), stream.getResponseHeaders());
+    connection.ping().roundTripTime(); // Ensure that the 2nd SYN REPLY has been received.
+
+    // verify the peer received what was expected
+    InFrame synStream = peer.takeFrame();
+    assertEquals(TYPE_HEADERS, synStream.type);
+    InFrame ping = peer.takeFrame();
+    assertEquals(TYPE_PING, ping.type);
+  }
+
+  @Test public void remoteSendsDataAfterInFinished() throws Exception {
+    // write the mocking script
+    peer.acceptFrame(); // SYN_STREAM
+    peer.sendFrame().synReply(false, 3, headerEntries("a", "android"));
+    peer.sendFrame().data(true, 3, new Buffer().writeUtf8("robot"), 5);
+    peer.sendFrame().data(true, 3, new Buffer().writeUtf8("c3po"), 4);
+    peer.acceptFrame(); // RST_STREAM
+    peer.sendFrame().ping(false, 2, 0); // Ping just to make sure the stream was fastforwarded.
+    peer.acceptFrame(); // PING
+    peer.play();
+
+    // play it back
+    FramedConnection connection = connection(peer);
+    FramedStream stream = connection.newStream(headerEntries("b", "banana"), false);
+    assertEquals(headerEntries("a", "android"), stream.getResponseHeaders());
+    assertStreamData("robot", stream.getSource());
+
+    // verify the peer received what was expected
+    InFrame synStream = peer.takeFrame();
+    assertEquals(TYPE_HEADERS, synStream.type);
+    InFrame rstStream = peer.takeFrame();
+    assertEquals(TYPE_RST_STREAM, rstStream.type);
+    assertEquals(3, rstStream.streamId);
+    InFrame ping = peer.takeFrame();
+    assertEquals(TYPE_PING, ping.type);
+    assertEquals(2, ping.payload1);
+  }
+
+  @Test public void clientDoesNotLimitFlowControl() throws Exception {
+    int dataLength = 16384;
+    // write the mocking script
+    peer.acceptFrame(); // SYN_STREAM
+    peer.sendFrame().synReply(false, 3, headerEntries("b", "banana"));
+    peer.sendFrame().data(false, 3, new Buffer().write(new byte[dataLength]), dataLength);
+    peer.sendFrame().data(false, 3, new Buffer().write(new byte[dataLength]), dataLength);
+    peer.sendFrame().data(false, 3, new Buffer().write(new byte[dataLength]), dataLength);
+    peer.sendFrame().data(false, 3, new Buffer().write(new byte[dataLength]), dataLength);
+    peer.sendFrame().data(false, 3, new Buffer().write(new byte[1]), 1);
+    peer.sendFrame().ping(false, 2, 0); // Ping just to make sure the stream was fastforwarded.
+    peer.acceptFrame(); // PING
+    peer.play();
+
+    // play it back
+    FramedConnection connection = connection(peer);
+    FramedStream stream = connection.newStream(headerEntries("a", "android"), false);
+    assertEquals(headerEntries("b", "banana"), stream.getResponseHeaders());
+
+    // verify the peer received what was expected
+    InFrame synStream = peer.takeFrame();
+    assertEquals(TYPE_HEADERS, synStream.type);
+    InFrame ping = peer.takeFrame();
+    assertEquals(TYPE_PING, ping.type);
+    assertEquals(2, ping.payload1);
+  }
+
+  @Test public void remoteSendsRefusedStreamBeforeReplyHeaders() throws Exception {
+    // write the mocking script
+    peer.acceptFrame(); // SYN_STREAM
+    peer.sendFrame().rstStream(3, REFUSED_STREAM);
+    peer.sendFrame().ping(false, 2, 0);
+    peer.acceptFrame(); // PING
+    peer.play();
+
+    // play it back
+    FramedConnection connection = connection(peer);
+    FramedStream stream = connection.newStream(headerEntries("a", "android"), false);
+    try {
+      stream.getResponseHeaders();
+      fail();
+    } catch (IOException expected) {
+      assertEquals("stream was reset: REFUSED_STREAM", expected.getMessage());
+    }
+    assertEquals(0, connection.openStreamCount());
+
+    // verify the peer received what was expected
+    InFrame synStream = peer.takeFrame();
+    assertEquals(TYPE_HEADERS, synStream.type);
+    InFrame ping = peer.takeFrame();
+    assertEquals(TYPE_PING, ping.type);
+    assertEquals(2, ping.payload1);
+  }
+
+  @Test public void receiveGoAway() throws Exception {
+    // write the mocking script
+    peer.acceptFrame(); // SYN_STREAM 1
+    peer.acceptFrame(); // SYN_STREAM 3
+    peer.acceptFrame(); // PING.
+    peer.sendFrame().goAway(3, PROTOCOL_ERROR, Util.EMPTY_BYTE_ARRAY);
+    peer.sendFrame().ping(true, 1, 0);
+    peer.acceptFrame(); // DATA STREAM 1
+    peer.play();
+
+    // play it back
+    FramedConnection connection = connection(peer);
+    FramedStream stream1 = connection.newStream(headerEntries("a", "android"), true);
+    FramedStream stream2 = connection.newStream(headerEntries("b", "banana"), true);
+    connection.ping().roundTripTime(); // Ensure the GO_AWAY that resets stream2 has been received.
+    BufferedSink sink1 = Okio.buffer(stream1.getSink());
+    BufferedSink sink2 = Okio.buffer(stream2.getSink());
+    sink1.writeUtf8("abc");
+    try {
+      sink2.writeUtf8("abc");
+      sink2.flush();
+      fail();
+    } catch (IOException expected) {
+      assertEquals("stream was reset: REFUSED_STREAM", expected.getMessage());
+    }
+    sink1.writeUtf8("def");
+    sink1.close();
+    try {
+      connection.newStream(headerEntries("c", "cola"), false);
+      fail();
+    } catch (IOException expected) {
+      assertEquals("shutdown", expected.getMessage());
+    }
+    assertTrue(stream1.isOpen());
+    assertFalse(stream2.isOpen());
+    assertEquals(1, connection.openStreamCount());
+
+    // verify the peer received what was expected
+    InFrame synStream1 = peer.takeFrame();
+    assertEquals(TYPE_HEADERS, synStream1.type);
+    InFrame synStream2 = peer.takeFrame();
+    assertEquals(TYPE_HEADERS, synStream2.type);
+    InFrame ping = peer.takeFrame();
+    assertEquals(TYPE_PING, ping.type);
+    InFrame data1 = peer.takeFrame();
+    assertEquals(TYPE_DATA, data1.type);
+    assertEquals(3, data1.streamId);
+    assertTrue(Arrays.equals("abcdef".getBytes("UTF-8"), data1.data));
+  }
+
+  @Test public void sendGoAway() throws Exception {
+    // write the mocking script
+    peer.acceptFrame(); // SYN_STREAM 1
+    peer.acceptFrame(); // GOAWAY
+    peer.acceptFrame(); // PING
+    peer.sendFrame().synStream(false, 2, 0, headerEntries("b", "b")); // Should be ignored!
+    peer.sendFrame().ping(true, 1, 0);
+    peer.play();
+
+    // play it back
+    FramedConnection connection = connection(peer);
+    connection.newStream(headerEntries("a", "android"), false);
+    Ping ping = connection.ping();
+    connection.shutdown(PROTOCOL_ERROR);
+    assertEquals(1, connection.openStreamCount());
+    ping.roundTripTime(); // Prevent the peer from exiting prematurely.
+
+    // verify the peer received what was expected
+    InFrame synStream1 = peer.takeFrame();
+    assertEquals(TYPE_HEADERS, synStream1.type);
+    InFrame pingFrame = peer.takeFrame();
+    assertEquals(TYPE_PING, pingFrame.type);
+    InFrame goaway = peer.takeFrame();
+    assertEquals(TYPE_GOAWAY, goaway.type);
+    assertEquals(0, goaway.streamId);
+    assertEquals(PROTOCOL_ERROR, goaway.errorCode);
+  }
+
+  @Test public void noPingsAfterShutdown() throws Exception {
+    // write the mocking script
+    peer.acceptFrame(); // GOAWAY
+    peer.play();
+
+    // play it back
+    FramedConnection connection = connection(peer);
+    connection.shutdown(INTERNAL_ERROR);
+    try {
+      connection.ping();
+      fail();
+    } catch (IOException expected) {
+      assertEquals("shutdown", expected.getMessage());
+    }
+
+    // verify the peer received what was expected
+    InFrame goaway = peer.takeFrame();
+    assertEquals(TYPE_GOAWAY, goaway.type);
+    assertEquals(INTERNAL_ERROR, goaway.errorCode);
+  }
+
+  @Test public void close() throws Exception {
+    // write the mocking script
+    peer.acceptFrame(); // SYN_STREAM
+    peer.acceptFrame(); // GOAWAY
+    peer.acceptFrame(); // RST_STREAM
+    peer.play();
+
+    // play it back
+    FramedConnection connection = connection(peer);
+    FramedStream stream = connection.newStream(headerEntries("a", "android"), false);
+    assertEquals(1, connection.openStreamCount());
+    connection.close();
+    assertEquals(0, connection.openStreamCount());
+    try {
+      connection.newStream(headerEntries("b", "banana"), false);
+      fail();
+    } catch (IOException expected) {
+      assertEquals("shutdown", expected.getMessage());
+    }
+    BufferedSink sink = Okio.buffer(stream.getSink());
+    try {
+      sink.writeByte(0);
+      sink.flush();
+      fail();
+    } catch (IOException expected) {
+      assertEquals("stream finished", expected.getMessage());
+    }
+    try {
+      stream.getSource().read(new Buffer(), 1);
+      fail();
+    } catch (IOException expected) {
+      assertEquals("stream was reset: CANCEL", expected.getMessage());
+    }
+
+    // verify the peer received what was expected
+    InFrame synStream = peer.takeFrame();
+    assertEquals(TYPE_HEADERS, synStream.type);
+    InFrame goaway = peer.takeFrame();
+    assertEquals(TYPE_GOAWAY, goaway.type);
+    InFrame rstStream = peer.takeFrame();
+    assertEquals(TYPE_RST_STREAM, rstStream.type);
+    assertEquals(3, rstStream.streamId);
+  }
+
+  @Test public void closeCancelsPings() throws Exception {
+    // write the mocking script
+    peer.acceptFrame(); // PING
+    peer.acceptFrame(); // GOAWAY
+    peer.play();
+
+    // play it back
+    FramedConnection connection = connection(peer);
+    Ping ping = connection.ping();
+    connection.close();
+    assertEquals(-1, ping.roundTripTime());
+  }
+
+  @Test public void getResponseHeadersTimesOut() throws Exception {
+    // write the mocking script
+    peer.acceptFrame(); // SYN_STREAM
+    peer.acceptFrame(); // RST_STREAM
+    peer.play();
+
+    // play it back
+    FramedConnection connection = connection(peer);
+    FramedStream stream = connection.newStream(headerEntries("b", "banana"), false);
+    stream.readTimeout().timeout(500, TimeUnit.MILLISECONDS);
+    long startNanos = System.nanoTime();
+    try {
+      stream.getResponseHeaders();
+      fail();
+    } catch (InterruptedIOException expected) {
+    }
+    long elapsedNanos = System.nanoTime() - startNanos;
+    awaitWatchdogIdle();
+    assertEquals(500d, TimeUnit.NANOSECONDS.toMillis(elapsedNanos), 200d /* 200ms delta */);
+    assertEquals(0, connection.openStreamCount());
+
+    // verify the peer received what was expected
+    assertEquals(TYPE_HEADERS, peer.takeFrame().type);
+    assertEquals(TYPE_RST_STREAM, peer.takeFrame().type);
+  }
+
+  @Test public void readTimesOut() throws Exception {
+    // write the mocking script
+    peer.acceptFrame(); // SYN_STREAM
+    peer.sendFrame().synReply(false, 3, headerEntries("a", "android"));
+    peer.acceptFrame(); // RST_STREAM
+    peer.play();
+
+    // play it back
+    FramedConnection connection = connection(peer);
+    FramedStream stream = connection.newStream(headerEntries("b", "banana"), false);
+    stream.readTimeout().timeout(500, TimeUnit.MILLISECONDS);
+    Source source = stream.getSource();
+    long startNanos = System.nanoTime();
+    try {
+      source.read(new Buffer(), 1);
+      fail();
+    } catch (InterruptedIOException expected) {
+    }
+    long elapsedNanos = System.nanoTime() - startNanos;
+    awaitWatchdogIdle();
+    assertEquals(500d, TimeUnit.NANOSECONDS.toMillis(elapsedNanos), 200d /* 200ms delta */);
+    assertEquals(0, connection.openStreamCount());
+
+    // verify the peer received what was expected
+    assertEquals(TYPE_HEADERS, peer.takeFrame().type);
+    assertEquals(TYPE_RST_STREAM, peer.takeFrame().type);
+  }
+
+  @Test public void writeTimesOutAwaitingStreamWindow() throws Exception {
+    // Set the peer's receive window to 5 bytes!
+    Settings peerSettings = new Settings().set(INITIAL_WINDOW_SIZE, 5);
+
+    // write the mocking script
+    peer.acceptFrame(); // PING
+    peer.sendFrame().settings(peerSettings);
+    peer.acceptFrame(); // ACK SETTINGS
+    peer.sendFrame().ping(true, 1, 0);
+    peer.acceptFrame(); // SYN_STREAM
+    peer.sendFrame().synReply(false, 3, headerEntries("a", "android"));
+    peer.acceptFrame(); // DATA
+    peer.acceptFrame(); // RST_STREAM
+    peer.play();
+
+    // play it back
+    FramedConnection connection = connection(peer);
+    connection.ping().roundTripTime(); // Make sure settings have been received.
+    FramedStream stream = connection.newStream(headerEntries("b", "banana"), true);
+    Sink sink = stream.getSink();
+    sink.write(new Buffer().writeUtf8("abcde"), 5);
+    stream.writeTimeout().timeout(500, TimeUnit.MILLISECONDS);
+    long startNanos = System.nanoTime();
+    sink.write(new Buffer().writeUtf8("f"), 1);
+    try {
+      sink.flush(); // This will time out waiting on the write window.
+      fail();
+    } catch (InterruptedIOException expected) {
+    }
+    long elapsedNanos = System.nanoTime() - startNanos;
+    awaitWatchdogIdle();
+    assertEquals(500d, TimeUnit.NANOSECONDS.toMillis(elapsedNanos), 200d /* 200ms delta */);
+    assertEquals(0, connection.openStreamCount());
+
+    // verify the peer received what was expected
+    assertEquals(TYPE_PING, peer.takeFrame().type);
+    assertEquals(TYPE_SETTINGS, peer.takeFrame().type);
+    assertEquals(TYPE_HEADERS, peer.takeFrame().type);
+    assertEquals(TYPE_DATA, peer.takeFrame().type);
+    assertEquals(TYPE_RST_STREAM, peer.takeFrame().type);
+  }
+
+  @Test public void writeTimesOutAwaitingConnectionWindow() throws Exception {
+    // Set the peer's receive window to 5 bytes. Give the stream 5 bytes back, so only the
+    // connection-level window is applicable.
+    Settings peerSettings = new Settings().set(INITIAL_WINDOW_SIZE, 5);
+
+    // write the mocking script
+    peer.acceptFrame(); // PING
+    peer.sendFrame().settings(peerSettings);
+    peer.acceptFrame(); // ACK SETTINGS
+    peer.sendFrame().ping(true, 1, 0);
+    peer.acceptFrame(); // SYN_STREAM
+    peer.sendFrame().synReply(false, 3, headerEntries("a", "android"));
+    peer.sendFrame().windowUpdate(3, 5);
+    peer.acceptFrame(); // PING
+    peer.sendFrame().ping(true, 3, 0);
+    peer.acceptFrame(); // DATA
+    peer.acceptFrame(); // RST_STREAM
+    peer.play();
+
+    // play it back
+    FramedConnection connection = connection(peer);
+    connection.ping().roundTripTime(); // Make sure settings have been acked.
+    FramedStream stream = connection.newStream(headerEntries("b", "banana"), true);
+    connection.ping().roundTripTime(); // Make sure the window update has been received.
+    Sink sink = stream.getSink();
+    stream.writeTimeout().timeout(500, TimeUnit.MILLISECONDS);
+    sink.write(new Buffer().writeUtf8("abcdef"), 6);
+    long startNanos = System.nanoTime();
+    try {
+      sink.flush(); // This will time out waiting on the write window.
+      fail();
+    } catch (InterruptedIOException expected) {
+    }
+    long elapsedNanos = System.nanoTime() - startNanos;
+    awaitWatchdogIdle();
+    assertEquals(500d, TimeUnit.NANOSECONDS.toMillis(elapsedNanos), 200d /* 200ms delta */);
+    assertEquals(0, connection.openStreamCount());
+
+    // verify the peer received what was expected
+    assertEquals(TYPE_PING, peer.takeFrame().type);
+    assertEquals(TYPE_SETTINGS, peer.takeFrame().type);
+    assertEquals(TYPE_HEADERS, peer.takeFrame().type);
+    assertEquals(TYPE_PING, peer.takeFrame().type);
+    assertEquals(TYPE_DATA, peer.takeFrame().type);
+    assertEquals(TYPE_RST_STREAM, peer.takeFrame().type);
+  }
+
+  @Test public void outgoingWritesAreBatched() throws Exception {
+    // write the mocking script
+    peer.acceptFrame(); // SYN_STREAM
+    peer.sendFrame().synReply(false, 3, headerEntries("a", "android"));
+    peer.acceptFrame(); // DATA
+    peer.play();
+
+    // play it back
+    FramedConnection connection = connection(peer);
+    FramedStream stream = connection.newStream(headerEntries("b", "banana"), true);
+
+    // two outgoing writes
+    Sink sink = stream.getSink();
+    sink.write(new Buffer().writeUtf8("abcde"), 5);
+    sink.write(new Buffer().writeUtf8("fghij"), 5);
+    sink.close();
+
+    // verify the peer received one incoming frame
+    assertEquals(TYPE_HEADERS, peer.takeFrame().type);
+    InFrame data = peer.takeFrame();
+    assertEquals(TYPE_DATA, data.type);
+    assertTrue(Arrays.equals("abcdefghij".getBytes("UTF-8"), data.data));
+    assertTrue(data.inFinished);
+  }
+
+  @Test public void headers() throws Exception {
+    // write the mocking script
+    peer.acceptFrame(); // SYN_STREAM
+    peer.acceptFrame(); // PING
+    peer.sendFrame().synReply(false, 3, headerEntries("a", "android"));
+    peer.sendFrame().headers(3, headerEntries("c", "c3po"));
+    peer.sendFrame().ping(true, 1, 0);
+    peer.play();
+
+    // play it back
+    FramedConnection connection = connection(peer);
+    FramedStream stream = connection.newStream(headerEntries("b", "banana"), true);
+    connection.ping().roundTripTime(); // Ensure that the HEADERS has been received.
+    assertEquals(headerEntries("a", "android", "c", "c3po"), stream.getResponseHeaders());
+
+    // verify the peer received what was expected
+    InFrame synStream = peer.takeFrame();
+    assertEquals(TYPE_HEADERS, synStream.type);
+    InFrame ping = peer.takeFrame();
+    assertEquals(TYPE_PING, ping.type);
+  }
+
+  @Test public void readSendsWindowUpdate() throws Exception {
+    int windowSize = 100;
+    int windowUpdateThreshold = 50;
+
+    // Write the mocking script.
+    peer.acceptFrame(); // SYN_STREAM
+    peer.sendFrame().synReply(false, 3, headerEntries("a", "android"));
+    for (int i = 0; i < 3; i++) {
+      // Send frames of summing to size 50, which is windowUpdateThreshold.
+      peer.sendFrame().data(false, 3, data(24), 24);
+      peer.sendFrame().data(false, 3, data(25), 25);
+      peer.sendFrame().data(false, 3, data(1), 1);
+      peer.acceptFrame(); // connection WINDOW UPDATE
+      peer.acceptFrame(); // stream WINDOW UPDATE
+    }
+    peer.sendFrame().data(true, 3, data(0), 0);
+    peer.play();
+
+    // Play it back.
+    FramedConnection connection = connection(peer);
+    connection.okHttpSettings.set(INITIAL_WINDOW_SIZE, windowSize);
+    FramedStream stream = connection.newStream(headerEntries("b", "banana"), false);
+    assertEquals(0, stream.unacknowledgedBytesRead);
+    assertEquals(headerEntries("a", "android"), stream.getResponseHeaders());
+    Source in = stream.getSource();
+    Buffer buffer = new Buffer();
+    buffer.writeAll(in);
+    assertEquals(-1, in.read(buffer, 1));
+    assertEquals(150, buffer.size());
+
+    InFrame synStream = peer.takeFrame();
+    assertEquals(TYPE_HEADERS, synStream.type);
+    for (int i = 0; i < 3; i++) {
+      List<Integer> windowUpdateStreamIds = new ArrayList<>(2);
+      for (int j = 0; j < 2; j++) {
+        InFrame windowUpdate = peer.takeFrame();
+        assertEquals(TYPE_WINDOW_UPDATE, windowUpdate.type);
+        windowUpdateStreamIds.add(windowUpdate.streamId);
+        assertEquals(windowUpdateThreshold, windowUpdate.windowSizeIncrement);
+      }
+      assertTrue(windowUpdateStreamIds.contains(0)); // connection
+      assertTrue(windowUpdateStreamIds.contains(3)); // stream
+    }
+  }
+
+  @Test public void serverSendsEmptyDataClientDoesntSendWindowUpdate() throws Exception {
+    // Write the mocking script.
+    peer.acceptFrame(); // SYN_STREAM
+    peer.sendFrame().synReply(false, 3, headerEntries("a", "android"));
+    peer.sendFrame().data(true, 3, data(0), 0);
+    peer.play();
+
+    // Play it back.
+    FramedConnection connection = connection(peer);
+    FramedStream client = connection.newStream(headerEntries("b", "banana"), false);
+    assertEquals(-1, client.getSource().read(new Buffer(), 1));
+
+    // Verify the peer received what was expected.
+    InFrame synStream = peer.takeFrame();
+    assertEquals(TYPE_HEADERS, synStream.type);
+    assertEquals(3, peer.frameCount());
+  }
+
+  @Test public void clientSendsEmptyDataServerDoesntSendWindowUpdate() throws Exception {
+    // Write the mocking script.
+    peer.acceptFrame(); // SYN_STREAM
+    peer.acceptFrame(); // DATA
+    peer.sendFrame().synReply(false, 3, headerEntries("a", "android"));
+    peer.play();
+
+    // Play it back.
+    FramedConnection connection = connection(peer);
+    FramedStream client = connection.newStream(headerEntries("b", "banana"), true);
+    BufferedSink out = Okio.buffer(client.getSink());
+    out.write(Util.EMPTY_BYTE_ARRAY);
+    out.flush();
+    out.close();
+
+    // Verify the peer received what was expected.
+    assertEquals(TYPE_HEADERS, peer.takeFrame().type);
+    assertEquals(TYPE_DATA, peer.takeFrame().type);
+    assertEquals(3, peer.frameCount());
+  }
+
+  @Test public void testTruncatedDataFrame() throws Exception {
+    // write the mocking script
+    peer.acceptFrame(); // SYN_STREAM
+    peer.sendFrame().synReply(false, 3, headerEntries("a", "android"));
+    peer.sendFrame().data(false, 3, data(1024), 1024);
+    peer.truncateLastFrame(8 + 100);
+    peer.play();
+
+    // play it back
+    FramedConnection connection = connection(peer);
+    FramedStream stream = connection.newStream(headerEntries("b", "banana"), false);
+    assertEquals(headerEntries("a", "android"), stream.getResponseHeaders());
+    Source in = stream.getSource();
+    try {
+      Okio.buffer(in).readByteString(101);
+      fail();
+    } catch (IOException expected) {
+      assertEquals("stream was reset: PROTOCOL_ERROR", expected.getMessage());
+    }
+  }
+
+  @Test public void blockedStreamDoesntStarveNewStream() throws Exception {
+    int framesThatFillWindow = roundUp(DEFAULT_INITIAL_WINDOW_SIZE, peer.maxOutboundDataLength());
+
+    // Write the mocking script. This accepts more data frames than necessary!
+    peer.acceptFrame(); // SYN_STREAM on stream 1
+    for (int i = 0; i < framesThatFillWindow; i++) {
+      peer.acceptFrame(); // DATA on stream 1
+    }
+    peer.acceptFrame(); // SYN_STREAM on stream 2
+    peer.acceptFrame(); // DATA on stream 2
+    peer.play();
+
+    // Play it back.
+    FramedConnection connection = connection(peer);
+    FramedStream stream1 = connection.newStream(headerEntries("a", "apple"), true);
+    BufferedSink out1 = Okio.buffer(stream1.getSink());
+    out1.write(new byte[DEFAULT_INITIAL_WINDOW_SIZE]);
+    out1.flush();
+
+    // Check that we've filled the window for both the stream and also the connection.
+    assertEquals(0, connection.bytesLeftInWriteWindow);
+    assertEquals(0, connection.getStream(3).bytesLeftInWriteWindow);
+
+    // receiving a window update on the the connection will unblock new streams.
+    connection.readerRunnable.windowUpdate(0, 3);
+
+    assertEquals(3, connection.bytesLeftInWriteWindow);
+    assertEquals(0, connection.getStream(3).bytesLeftInWriteWindow);
+
+    // Another stream should be able to send data even though 1 is blocked.
+    FramedStream stream2 = connection.newStream(headerEntries("b", "banana"), true);
+    BufferedSink out2 = Okio.buffer(stream2.getSink());
+    out2.writeUtf8("foo");
+    out2.flush();
+
+    assertEquals(0, connection.bytesLeftInWriteWindow);
+    assertEquals(0, connection.getStream(3).bytesLeftInWriteWindow);
+    assertEquals(DEFAULT_INITIAL_WINDOW_SIZE - 3, connection.getStream(5).bytesLeftInWriteWindow);
+  }
+
+  private Buffer data(int byteCount) {
+    return new Buffer().write(new byte[byteCount]);
+  }
+
+  private void assertStreamData(String expected, Source source) throws IOException {
+    String actual = Okio.buffer(source).readUtf8();
+    assertEquals(expected, actual);
+  }
+
+  /**
+   * Returns true when all work currently in progress by the watchdog have completed. This method
+   * creates more work for the watchdog and waits for that work to be executed. When it is, we know
+   * work that preceded this call is complete.
+   */
+  private void awaitWatchdogIdle() throws InterruptedException {
+    final CountDownLatch latch = new CountDownLatch(1);
+    AsyncTimeout watchdogJob = new AsyncTimeout() {
+      @Override protected void timedOut() {
+        latch.countDown();
+      }
+    };
+    watchdogJob.deadlineNanoTime(System.nanoTime()); // Due immediately!
+    watchdogJob.enter();
+    latch.await();
+  }
+
+  static int roundUp(int num, int divisor) {
+    return (num + divisor - 1) / divisor;
+  }
+
+  private FramedConnection sendHttp2SettingsAndCheckForAck(boolean client, Settings settings)
+      throws IOException, InterruptedException {
+    peer.setClient(client);
+    peer.sendFrame().settings(settings);
+    peer.acceptFrame(); // ACK
+    peer.acceptFrame(); // PING
+    peer.sendFrame().ping(true, 1, 0);
+    peer.play();
+
+    // play it back
+    FramedConnection connection = connection(peer);
+
+    // verify the peer received the ACK
+    InFrame ackFrame = peer.takeFrame();
+    assertEquals(TYPE_SETTINGS, ackFrame.type);
+    assertEquals(0, ackFrame.streamId);
+    assertTrue(ackFrame.ack);
+
+    connection.ping().roundTripTime(); // Ensure that settings have been applied before returning.
+    return connection;
+  }
+
+  private FramedConnection connection(MockHttp2Peer peer) throws IOException {
+    FramedConnection connection = connectionBuilder(peer).build();
+    connection.start(false);
+    return connection;
+  }
+
+  private FramedConnection.Builder connectionBuilder(MockHttp2Peer peer) throws IOException {
+    return new FramedConnection.Builder(true)
+        .socket(peer.openSocket())
+        .pushObserver(IGNORE);
   }
 
   static final PushObserver IGNORE = new PushObserver() {
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/framed/Http2FrameLoggerTest.java b/okhttp-tests/src/test/java/okhttp3/internal/framed/Http2FrameLoggerTest.java
index 864a368774..32bcfc649c 100644
--- a/okhttp-tests/src/test/java/okhttp3/internal/framed/Http2FrameLoggerTest.java
+++ b/okhttp-tests/src/test/java/okhttp3/internal/framed/Http2FrameLoggerTest.java
@@ -24,8 +24,8 @@
 import static okhttp3.internal.framed.Http2.FLAG_END_HEADERS;
 import static okhttp3.internal.framed.Http2.FLAG_END_STREAM;
 import static okhttp3.internal.framed.Http2.FLAG_NONE;
-import static okhttp3.internal.framed.Http2.FrameLogger.formatFlags;
-import static okhttp3.internal.framed.Http2.FrameLogger.formatHeader;
+import static okhttp3.internal.framed.FrameLogger.formatFlags;
+import static okhttp3.internal.framed.FrameLogger.formatHeader;
 import static okhttp3.internal.framed.Http2.TYPE_CONTINUATION;
 import static okhttp3.internal.framed.Http2.TYPE_DATA;
 import static okhttp3.internal.framed.Http2.TYPE_GOAWAY;
@@ -35,7 +35,7 @@
 import static okhttp3.internal.framed.Http2.TYPE_SETTINGS;
 import static org.junit.Assert.assertEquals;
 
-public class Http2FrameLoggerTest {
+public final class Http2FrameLoggerTest {
 
   /** Real stream traffic applied to the log format. */
   @Test public void exampleStream() {
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/framed/Http2Test.java b/okhttp-tests/src/test/java/okhttp3/internal/framed/Http2Test.java
index 72412a5ac6..f639c372c8 100644
--- a/okhttp-tests/src/test/java/okhttp3/internal/framed/Http2Test.java
+++ b/okhttp-tests/src/test/java/okhttp3/internal/framed/Http2Test.java
@@ -42,7 +42,7 @@
 
 public class Http2Test {
   final Buffer frame = new Buffer();
-  final FrameReader fr = new Http2.Reader(frame, 4096, false);
+  final FrameReader fr = new FrameReader(frame, false);
   final int expectedStreamId = 15;
 
   @Test public void unknownFrameTypeSkipped() throws IOException {
@@ -68,15 +68,12 @@
     assertEquals(frame, sendHeaderFrames(true, sentHeaders)); // Check writer sends the same bytes.
 
     fr.nextFrame(new BaseTestHandler() {
-      @Override
-      public void headers(boolean outFinished, boolean inFinished, int streamId,
-          int associatedStreamId, List<Header> headerBlock, HeadersMode headersMode) {
-        assertFalse(outFinished);
+      @Override public void headers(boolean inFinished, int streamId,
+          int associatedStreamId, List<Header> headerBlock) {
         assertTrue(inFinished);
         assertEquals(expectedStreamId, streamId);
         assertEquals(-1, associatedStreamId);
         assertEquals(sentHeaders, headerBlock);
-        assertEquals(HeadersMode.HTTP_20_HEADERS, headersMode);
       }
     });
   }
@@ -101,15 +98,12 @@ public void headers(boolean outFinished, boolean inFinished, int streamId,
         assertFalse(exclusive);
       }
 
-      @Override public void headers(boolean outFinished, boolean inFinished, int streamId,
-          int associatedStreamId, List<Header> nameValueBlock,
-          HeadersMode headersMode) {
-        assertFalse(outFinished);
+      @Override public void headers(boolean inFinished, int streamId,
+          int associatedStreamId, List<Header> nameValueBlock) {
         assertFalse(inFinished);
         assertEquals(expectedStreamId, streamId);
         assertEquals(-1, associatedStreamId);
         assertEquals(sentHeaders, nameValueBlock);
-        assertEquals(HeadersMode.HTTP_20_HEADERS, headersMode);
       }
     });
   }
@@ -138,14 +132,12 @@ public void headers(boolean outFinished, boolean inFinished, int streamId,
 
     // Reading the above frames should result in a concatenated headerBlock.
     fr.nextFrame(new BaseTestHandler() {
-      @Override public void headers(boolean outFinished, boolean inFinished, int streamId,
-          int associatedStreamId, List<Header> headerBlock, HeadersMode headersMode) {
-        assertFalse(outFinished);
+      @Override public void headers(boolean inFinished, int streamId,
+          int associatedStreamId, List<Header> headerBlock) {
         assertFalse(inFinished);
         assertEquals(expectedStreamId, streamId);
         assertEquals(-1, associatedStreamId);
         assertEquals(sentHeaders, headerBlock);
-        assertEquals(HeadersMode.HTTP_20_HEADERS, headersMode);
       }
     });
   }
@@ -222,12 +214,12 @@ public void pushPromise(int streamId, int promisedStreamId, List<Header> headerB
     frame.writeByte(Http2.TYPE_RST_STREAM);
     frame.writeByte(Http2.FLAG_NONE);
     frame.writeInt(expectedStreamId & 0x7fffffff);
-    frame.writeInt(ErrorCode.COMPRESSION_ERROR.httpCode);
+    frame.writeInt(ErrorCode.PROTOCOL_ERROR.httpCode);
 
     fr.nextFrame(new BaseTestHandler() {
       @Override public void rstStream(int streamId, ErrorCode errorCode) {
         assertEquals(expectedStreamId, streamId);
-        assertEquals(ErrorCode.COMPRESSION_ERROR, errorCode);
+        assertEquals(ErrorCode.PROTOCOL_ERROR, errorCode);
       }
     });
   }
@@ -613,7 +605,7 @@ public void pushPromise(int streamId, int promisedStreamId, List<Header> headerB
   }
 
   @Test public void frameSizeError() throws IOException {
-    Http2.Writer writer = new Http2.Writer(new Buffer(), true);
+    FrameWriter writer = new FrameWriter(new Buffer(), true);
 
     try {
       writer.frameHeader(0, 16777216, Http2.TYPE_DATA, FLAG_NONE);
@@ -627,16 +619,16 @@ public void pushPromise(int streamId, int promisedStreamId, List<Header> headerB
   @Test public void ackSettingsAppliesMaxFrameSize() throws IOException {
     int newMaxFrameSize = 16777215;
 
-    Http2.Writer writer = new Http2.Writer(new Buffer(), true);
+    FrameWriter writer = new FrameWriter(new Buffer(), true);
 
-    writer.applyAndAckSettings(new Settings().set(Settings.MAX_FRAME_SIZE, 0, newMaxFrameSize));
+    writer.applyAndAckSettings(new Settings().set(Settings.MAX_FRAME_SIZE, newMaxFrameSize));
 
     assertEquals(newMaxFrameSize, writer.maxDataLength());
     writer.frameHeader(0, newMaxFrameSize, Http2.TYPE_DATA, FLAG_NONE);
   }
 
   @Test public void streamIdHasReservedBit() throws IOException {
-    Http2.Writer writer = new Http2.Writer(new Buffer(), true);
+    FrameWriter writer = new FrameWriter(new Buffer(), true);
 
     try {
       int streamId = 3;
@@ -656,52 +648,50 @@ private Buffer literalHeaders(List<Header> sentHeaders) throws IOException {
 
   private Buffer sendHeaderFrames(boolean outFinished, List<Header> headers) throws IOException {
     Buffer out = new Buffer();
-    new Http2.Writer(out, true).headers(outFinished, expectedStreamId, headers);
+    new FrameWriter(out, true).headers(outFinished, expectedStreamId, headers);
     return out;
   }
 
   private Buffer sendPushPromiseFrames(int streamId, List<Header> headers) throws IOException {
     Buffer out = new Buffer();
-    new Http2.Writer(out, true).pushPromise(expectedStreamId, streamId, headers);
+    new FrameWriter(out, true).pushPromise(expectedStreamId, streamId, headers);
     return out;
   }
 
   private Buffer sendPingFrame(boolean ack, int payload1, int payload2) throws IOException {
     Buffer out = new Buffer();
-    new Http2.Writer(out, true).ping(ack, payload1, payload2);
+    new FrameWriter(out, true).ping(ack, payload1, payload2);
     return out;
   }
 
   private Buffer sendGoAway(int lastGoodStreamId, ErrorCode errorCode, byte[] debugData)
       throws IOException {
     Buffer out = new Buffer();
-    new Http2.Writer(out, true).goAway(lastGoodStreamId, errorCode, debugData);
+    new FrameWriter(out, true).goAway(lastGoodStreamId, errorCode, debugData);
     return out;
   }
 
   private Buffer sendDataFrame(Buffer data) throws IOException {
     Buffer out = new Buffer();
-    new Http2.Writer(out, true).dataFrame(expectedStreamId, FLAG_NONE, data,
+    new FrameWriter(out, true).dataFrame(expectedStreamId, FLAG_NONE, data,
         (int) data.size());
     return out;
   }
 
   private Buffer windowUpdate(long windowSizeIncrement) throws IOException {
     Buffer out = new Buffer();
-    new Http2.Writer(out, true).windowUpdate(expectedStreamId, windowSizeIncrement);
+    new FrameWriter(out, true).windowUpdate(expectedStreamId, windowSizeIncrement);
     return out;
   }
 
   private FrameReader.Handler assertHeaderBlock() {
     return new BaseTestHandler() {
-      @Override public void headers(boolean outFinished, boolean inFinished, int streamId,
-          int associatedStreamId, List<Header> headerBlock, HeadersMode headersMode) {
-        assertFalse(outFinished);
+      @Override public void headers(boolean inFinished, int streamId,
+          int associatedStreamId, List<Header> headerBlock) {
         assertFalse(inFinished);
         assertEquals(expectedStreamId, streamId);
         assertEquals(-1, associatedStreamId);
         assertEquals(headerEntries("foo", "barrr", "baz", "qux"), headerBlock);
-        assertEquals(HeadersMode.HTTP_20_HEADERS, headersMode);
       }
     };
   }
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/framed/HttpOverHttp2Test.java b/okhttp-tests/src/test/java/okhttp3/internal/framed/HttpOverHttp2Test.java
index c747f0b7a4..821186b908 100644
--- a/okhttp-tests/src/test/java/okhttp3/internal/framed/HttpOverHttp2Test.java
+++ b/okhttp-tests/src/test/java/okhttp3/internal/framed/HttpOverHttp2Test.java
@@ -15,23 +15,679 @@
  */
 package okhttp3.internal.framed;
 
+import java.io.IOException;
+import java.io.InputStream;
+import java.net.Authenticator;
+import java.net.HttpURLConnection;
+import java.net.SocketTimeoutException;
+import java.util.Arrays;
+import java.util.concurrent.CountDownLatch;
+import java.util.concurrent.ExecutorService;
+import java.util.concurrent.Executors;
+import javax.net.ssl.HostnameVerifier;
+import okhttp3.Cache;
 import okhttp3.Call;
+import okhttp3.Cookie;
+import okhttp3.Credentials;
 import okhttp3.Headers;
+import okhttp3.MediaType;
+import okhttp3.OkHttpClient;
 import okhttp3.Protocol;
+import okhttp3.RecordingCookieJar;
+import okhttp3.RecordingHostnameVerifier;
 import okhttp3.Request;
+import okhttp3.RequestBody;
 import okhttp3.Response;
+import okhttp3.internal.DoubleInetAddressDns;
+import okhttp3.internal.RecordingOkAuthenticator;
+import okhttp3.internal.SingleInetAddressDns;
+import okhttp3.internal.Util;
+import okhttp3.internal.tls.SslClient;
 import okhttp3.mockwebserver.MockResponse;
+import okhttp3.mockwebserver.MockWebServer;
 import okhttp3.mockwebserver.PushPromise;
 import okhttp3.mockwebserver.RecordedRequest;
+import okhttp3.mockwebserver.SocketPolicy;
+import okio.Buffer;
+import okio.BufferedSink;
+import okio.GzipSink;
+import okio.Okio;
+import org.junit.After;
+import org.junit.Before;
+import org.junit.Ignore;
+import org.junit.Rule;
 import org.junit.Test;
+import org.junit.rules.TemporaryFolder;
 
+import static java.util.concurrent.TimeUnit.MILLISECONDS;
+import static java.util.concurrent.TimeUnit.SECONDS;
+import static org.junit.Assert.assertArrayEquals;
 import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertNull;
+import static org.junit.Assert.fail;
 
-public class HttpOverHttp2Test extends HttpOverSpdyTest {
+/** Test how SPDY interacts with HTTP/2 features. */
+public final class HttpOverHttp2Test {
+  @Rule public final TemporaryFolder tempDir = new TemporaryFolder();
+  @Rule public final MockWebServer server = new MockWebServer();
 
-  public HttpOverHttp2Test() {
-    super(Protocol.HTTP_2);
-    this.hostHeader = ":authority";
+  private SslClient sslClient = SslClient.localhost();
+  private HostnameVerifier hostnameVerifier = new RecordingHostnameVerifier();
+  private OkHttpClient client;
+  private Cache cache;
+
+  @Before public void setUp() throws Exception {
+    server.useHttps(sslClient.socketFactory, false);
+    cache = new Cache(tempDir.getRoot(), Integer.MAX_VALUE);
+    client = new OkHttpClient.Builder()
+        .protocols(Arrays.asList(Protocol.HTTP_2, Protocol.HTTP_1_1))
+        .dns(new SingleInetAddressDns())
+        .sslSocketFactory(sslClient.socketFactory, sslClient.trustManager)
+        .hostnameVerifier(hostnameVerifier)
+        .build();
+  }
+
+  @After public void tearDown() throws Exception {
+    Authenticator.setDefault(null);
+  }
+
+  @Test public void get() throws Exception {
+    server.enqueue(new MockResponse()
+        .setBody("ABCDE")
+        .setStatus("HTTP/1.1 200 Sweet"));
+
+    Call call = client.newCall(new Request.Builder()
+        .url(server.url("/foo"))
+        .build());
+    Response response = call.execute();
+
+    assertEquals("ABCDE", response.body().string());
+    assertEquals(200, response.code());
+    assertEquals("Sweet", response.message());
+
+    RecordedRequest request = server.takeRequest();
+    assertEquals("GET /foo HTTP/1.1", request.getRequestLine());
+    assertEquals("https", request.getHeader(":scheme"));
+    assertEquals(server.getHostName() + ":" + server.getPort(), request.getHeader(":authority"));
+  }
+
+  @Test public void emptyResponse() throws IOException {
+    server.enqueue(new MockResponse());
+
+    Call call = client.newCall(new Request.Builder()
+        .url(server.url("/foo"))
+        .build());
+    Response response = call.execute();
+
+    assertEquals(-1, response.body().byteStream().read());
+    response.body().close();
+  }
+
+  @Test public void noDefaultContentLengthOnStreamingPost() throws Exception {
+    final byte[] postBytes = "FGHIJ".getBytes(Util.UTF_8);
+
+    server.enqueue(new MockResponse().setBody("ABCDE"));
+
+    Call call = client.newCall(new Request.Builder()
+        .url(server.url("/foo"))
+        .post(new RequestBody() {
+          @Override public MediaType contentType() {
+            return MediaType.parse("text/plain; charset=utf-8");
+          }
+
+          @Override public void writeTo(BufferedSink sink) throws IOException {
+            sink.write(postBytes);
+          }
+        })
+        .build());
+
+    Response response = call.execute();
+    assertEquals("ABCDE", response.body().string());
+
+    RecordedRequest request = server.takeRequest();
+    assertEquals("POST /foo HTTP/1.1", request.getRequestLine());
+    assertArrayEquals(postBytes, request.getBody().readByteArray());
+    assertNull(request.getHeader("Content-Length"));
+  }
+
+  @Test public void userSuppliedContentLengthHeader() throws Exception {
+    final byte[] postBytes = "FGHIJ".getBytes(Util.UTF_8);
+
+    server.enqueue(new MockResponse().setBody("ABCDE"));
+
+    Call call = client.newCall(new Request.Builder()
+        .url(server.url("/foo"))
+        .post(new RequestBody() {
+          @Override public MediaType contentType() {
+            return MediaType.parse("text/plain; charset=utf-8");
+          }
+
+          @Override public long contentLength() throws IOException {
+            return postBytes.length;
+          }
+
+          @Override public void writeTo(BufferedSink sink) throws IOException {
+            sink.write(postBytes);
+          }
+        })
+        .build());
+
+    Response response = call.execute();
+    assertEquals("ABCDE", response.body().string());
+
+    RecordedRequest request = server.takeRequest();
+    assertEquals("POST /foo HTTP/1.1", request.getRequestLine());
+    assertArrayEquals(postBytes, request.getBody().readByteArray());
+    assertEquals(postBytes.length, Integer.parseInt(request.getHeader("Content-Length")));
+  }
+
+  @Test public void closeAfterFlush() throws Exception {
+    final byte[] postBytes = "FGHIJ".getBytes(Util.UTF_8);
+
+    server.enqueue(new MockResponse().setBody("ABCDE"));
+
+    Call call = client.newCall(new Request.Builder()
+        .url(server.url("/foo"))
+        .post(new RequestBody() {
+          @Override public MediaType contentType() {
+            return MediaType.parse("text/plain; charset=utf-8");
+          }
+
+          @Override public long contentLength() throws IOException {
+            return postBytes.length;
+          }
+
+          @Override public void writeTo(BufferedSink sink) throws IOException {
+            sink.write(postBytes);  // push bytes into the stream's buffer
+            sink.flush(); // FramedConnection.writeData subject to write window
+            sink.close(); // FramedConnection.writeData empty frame
+          }
+        })
+        .build());
+
+    Response response = call.execute();
+    assertEquals("ABCDE", response.body().string());
+
+    RecordedRequest request = server.takeRequest();
+    assertEquals("POST /foo HTTP/1.1", request.getRequestLine());
+    assertArrayEquals(postBytes, request.getBody().readByteArray());
+    assertEquals(postBytes.length, Integer.parseInt(request.getHeader("Content-Length")));
+  }
+
+  @Test public void connectionReuse() throws Exception {
+    server.enqueue(new MockResponse().setBody("ABCDEF"));
+    server.enqueue(new MockResponse().setBody("GHIJKL"));
+
+    Call call1 = client.newCall(new Request.Builder()
+        .url(server.url("/r1"))
+        .build());
+    Call call2 = client.newCall(new Request.Builder()
+        .url(server.url("/r1"))
+        .build());
+    Response response1 = call1.execute();
+    Response response2 = call2.execute();
+
+    assertEquals("ABC", response1.body().source().readUtf8(3));
+    assertEquals("GHI", response2.body().source().readUtf8(3));
+    assertEquals("DEF", response1.body().source().readUtf8(3));
+    assertEquals("JKL", response2.body().source().readUtf8(3));
+    assertEquals(0, server.takeRequest().getSequenceNumber());
+    assertEquals(1, server.takeRequest().getSequenceNumber());
+  }
+
+  /** https://github.com/square/okhttp/issues/373 */
+  @Test @Ignore public void synchronousRequest() throws Exception {
+    server.enqueue(new MockResponse().setBody("A"));
+    server.enqueue(new MockResponse().setBody("A"));
+
+    ExecutorService executor = Executors.newCachedThreadPool();
+    CountDownLatch countDownLatch = new CountDownLatch(2);
+    executor.execute(new AsyncRequest("/r1", countDownLatch));
+    executor.execute(new AsyncRequest("/r2", countDownLatch));
+    countDownLatch.await();
+    assertEquals(0, server.takeRequest().getSequenceNumber());
+    assertEquals(1, server.takeRequest().getSequenceNumber());
+  }
+
+  @Test public void gzippedResponseBody() throws Exception {
+    server.enqueue(new MockResponse()
+        .addHeader("Content-Encoding: gzip")
+        .setBody(gzip("ABCABCABC")));
+
+    Call call = client.newCall(new Request.Builder()
+        .url(server.url("/r1"))
+        .build());
+
+    Response response = call.execute();
+    assertEquals("ABCABCABC", response.body().string());
+  }
+
+  @Test public void authenticate() throws Exception {
+    server.enqueue(new MockResponse()
+        .setResponseCode(HttpURLConnection.HTTP_UNAUTHORIZED)
+        .addHeader("www-authenticate: Basic realm=\"protected area\"")
+        .setBody("Please authenticate."));
+    server.enqueue(new MockResponse()
+        .setBody("Successful auth!"));
+
+    String credential = Credentials.basic("username", "password");
+    client = client.newBuilder()
+        .authenticator(new RecordingOkAuthenticator(credential))
+        .build();
+
+    Call call = client.newCall(new Request.Builder()
+        .url(server.url("/"))
+        .build());
+    Response response = call.execute();
+    assertEquals("Successful auth!", response.body().string());
+
+    RecordedRequest denied = server.takeRequest();
+    assertNull(denied.getHeader("Authorization"));
+    RecordedRequest accepted = server.takeRequest();
+    assertEquals("GET / HTTP/1.1", accepted.getRequestLine());
+    assertEquals(credential, accepted.getHeader("Authorization"));
+  }
+
+  @Test public void redirect() throws Exception {
+    server.enqueue(new MockResponse().setResponseCode(HttpURLConnection.HTTP_MOVED_TEMP)
+        .addHeader("Location: /foo")
+        .setBody("This page has moved!"));
+    server.enqueue(new MockResponse().setBody("This is the new location!"));
+
+    Call call = client.newCall(new Request.Builder()
+        .url(server.url("/"))
+        .build());
+
+    Response response = call.execute();
+    assertEquals("This is the new location!", response.body().string());
+
+    RecordedRequest request1 = server.takeRequest();
+    assertEquals("/", request1.getPath());
+    RecordedRequest request2 = server.takeRequest();
+    assertEquals("/foo", request2.getPath());
+  }
+
+  @Test public void readAfterLastByte() throws Exception {
+    server.enqueue(new MockResponse().setBody("ABC"));
+
+    Call call = client.newCall(new Request.Builder()
+        .url(server.url("/"))
+        .build());
+    Response response = call.execute();
+
+    InputStream in = response.body().byteStream();
+    assertEquals('A', in.read());
+    assertEquals('B', in.read());
+    assertEquals('C', in.read());
+    assertEquals(-1, in.read());
+    assertEquals(-1, in.read());
+  }
+
+  @Ignore // See https://github.com/square/okhttp/issues/578
+  @Test(timeout = 3000) public void readResponseHeaderTimeout() throws Exception {
+    server.enqueue(new MockResponse().setSocketPolicy(SocketPolicy.NO_RESPONSE));
+    server.enqueue(new MockResponse().setBody("A"));
+
+    client = client.newBuilder()
+        .readTimeout(1000, MILLISECONDS)
+        .build();
+
+    Call call = client.newCall(new Request.Builder()
+        .url(server.url("/"))
+        .build());
+    Response response = call.execute();
+    assertEquals("A", response.body().string());
+  }
+
+  /**
+   * Test to ensure we don't  throw a read timeout on responses that are progressing.  For this
+   * case, we take a 4KiB body and throttle it to 1KiB/second.  We set the read timeout to two
+   * seconds.  If our implementation is acting correctly, it will not throw, as it is progressing.
+   */
+  @Test public void readTimeoutMoreGranularThanBodySize() throws Exception {
+    char[] body = new char[4096]; // 4KiB to read.
+    Arrays.fill(body, 'y');
+    server.enqueue(new MockResponse().setBody(new String(body))
+        .throttleBody(1024, 1, SECONDS)); // Slow connection 1KiB/second.
+
+    client = client.newBuilder()
+        .readTimeout(2, SECONDS)
+        .build();
+
+    Call call = client.newCall(new Request.Builder()
+        .url(server.url("/"))
+        .build());
+
+    Response response = call.execute();
+    assertEquals(new String(body), response.body().string());
+  }
+
+  /**
+   * Test to ensure we throw a read timeout on responses that are progressing too slowly.  For this
+   * case, we take a 2KiB body and throttle it to 1KiB/second.  We set the read timeout to half a
+   * second.  If our implementation is acting correctly, it will throw, as a byte doesn't arrive in
+   * time.
+   */
+  @Test public void readTimeoutOnSlowConnection() throws Exception {
+    char[] body = new char[2048]; // 2KiB to read.
+    Arrays.fill(body, 'y');
+    server.enqueue(new MockResponse()
+        .setBody(new String(body))
+        .throttleBody(1024, 1, SECONDS)); // Slow connection 1KiB/second.
+
+    client = client.newBuilder()
+        .readTimeout(500, MILLISECONDS) // Half a second to read something.
+        .build();
+
+    Call call = client.newCall(new Request.Builder()
+        .url(server.url("/"))
+        .build());
+    Response response = call.execute();
+
+    try {
+      response.body().string();
+      fail("Should have timed out!");
+    } catch (SocketTimeoutException expected) {
+      assertEquals("timeout", expected.getMessage());
+    }
+  }
+
+  @Test public void connectionTimeout() throws Exception {
+    server.enqueue(new MockResponse()
+        .setBody("A")
+        .setBodyDelay(1, SECONDS));
+
+    OkHttpClient client1 = client.newBuilder()
+        .readTimeout(2000, MILLISECONDS)
+        .build();
+    Call call1 = client1
+        .newCall(new Request.Builder()
+        .url(server.url("/"))
+        .build());
+
+    OkHttpClient client2 = client.newBuilder()
+        .readTimeout(200, MILLISECONDS)
+        .build();
+    Call call2 = client2
+        .newCall(new Request.Builder()
+        .url(server.url("/"))
+        .build());
+
+    Response response1 = call1.execute();
+    assertEquals("A", response1.body().string());
+
+    try {
+      call2.execute();
+      fail();
+    } catch (IOException expected) {
+    }
+  }
+
+  @Test public void responsesAreCached() throws IOException {
+    client = client.newBuilder()
+        .cache(cache)
+        .build();
+
+    server.enqueue(new MockResponse()
+        .addHeader("cache-control: max-age=60")
+        .setBody("A"));
+
+    Call call1 = client.newCall(new Request.Builder()
+        .url(server.url("/"))
+        .build());
+    Response response1 = call1.execute();
+
+    assertEquals("A", response1.body().string());
+    assertEquals(1, cache.requestCount());
+    assertEquals(1, cache.networkCount());
+    assertEquals(0, cache.hitCount());
+
+    Call call2 = client.newCall(new Request.Builder()
+        .url(server.url("/"))
+        .build());
+    Response response2 = call2.execute();
+    assertEquals("A", response2.body().string());
+
+    Call call3 = client.newCall(new Request.Builder()
+        .url(server.url("/"))
+        .build());
+    Response response3 = call3.execute();
+    assertEquals("A", response3.body().string());
+
+    assertEquals(3, cache.requestCount());
+    assertEquals(1, cache.networkCount());
+    assertEquals(2, cache.hitCount());
+  }
+
+  @Test public void conditionalCache() throws IOException {
+    client = client.newBuilder()
+        .cache(cache)
+        .build();
+
+    server.enqueue(new MockResponse()
+        .addHeader("ETag: v1")
+        .setBody("A"));
+    server.enqueue(new MockResponse()
+        .setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
+
+    Call call1 = client.newCall(new Request.Builder()
+        .url(server.url("/"))
+        .build());
+    Response response1 = call1.execute();
+    assertEquals("A", response1.body().string());
+
+    assertEquals(1, cache.requestCount());
+    assertEquals(1, cache.networkCount());
+    assertEquals(0, cache.hitCount());
+
+    Call call2 = client.newCall(new Request.Builder()
+        .url(server.url("/"))
+        .build());
+    Response response2 = call2.execute();
+    assertEquals("A", response2.body().string());
+
+    assertEquals(2, cache.requestCount());
+    assertEquals(2, cache.networkCount());
+    assertEquals(1, cache.hitCount());
+  }
+
+  @Test public void responseCachedWithoutConsumingFullBody() throws IOException {
+    client = client.newBuilder()
+        .cache(cache)
+        .build();
+
+    server.enqueue(new MockResponse()
+        .addHeader("cache-control: max-age=60")
+        .setBody("ABCD"));
+    server.enqueue(new MockResponse()
+        .addHeader("cache-control: max-age=60")
+        .setBody("EFGH"));
+
+    Call call1 = client.newCall(new Request.Builder()
+        .url(server.url("/"))
+        .build());
+    Response response1 = call1.execute();
+    assertEquals("AB", response1.body().source().readUtf8(2));
+    response1.body().close();
+
+    Call call2 = client.newCall(new Request.Builder()
+        .url(server.url("/"))
+        .build());
+    Response response2 = call2.execute();
+    assertEquals("ABCD", response2.body().source().readUtf8());
+    response2.body().close();
+  }
+
+  @Test public void sendRequestCookies() throws Exception {
+    RecordingCookieJar cookieJar = new RecordingCookieJar();
+    Cookie requestCookie = new Cookie.Builder()
+        .name("a")
+        .value("b")
+        .domain(server.getHostName())
+        .build();
+    cookieJar.enqueueRequestCookies(requestCookie);
+    client = client.newBuilder()
+        .cookieJar(cookieJar)
+        .build();
+
+    server.enqueue(new MockResponse());
+    Call call = client.newCall(new Request.Builder()
+        .url(server.url("/"))
+        .build());
+    Response response = call.execute();
+    assertEquals("", response.body().string());
+
+    RecordedRequest request = server.takeRequest();
+    assertEquals("a=b", request.getHeader("Cookie"));
+  }
+
+  @Test public void receiveResponseCookies() throws Exception {
+    RecordingCookieJar cookieJar = new RecordingCookieJar();
+    client = client.newBuilder()
+        .cookieJar(cookieJar)
+        .build();
+
+    server.enqueue(new MockResponse()
+        .addHeader("set-cookie: a=b"));
+
+    Call call = client.newCall(new Request.Builder()
+        .url(server.url("/"))
+        .build());
+    Response response = call.execute();
+    assertEquals("", response.body().string());
+
+    cookieJar.assertResponseCookies("a=b; path=/");
+  }
+
+  /** https://github.com/square/okhttp/issues/1191 */
+  @Test public void cancelWithStreamNotCompleted() throws Exception {
+    server.enqueue(new MockResponse()
+        .setBody("abc"));
+    server.enqueue(new MockResponse()
+        .setBody("def"));
+
+    // Disconnect before the stream is created. A connection is still established!
+    Call call1 = client.newCall(new Request.Builder()
+        .url(server.url("/"))
+        .build());
+    call1.execute();
+    call1.cancel();
+
+    // That connection is pooled, and it works.
+    assertEquals(1, client.connectionPool().connectionCount());
+    Call call2 = client.newCall(new Request.Builder()
+        .url(server.url("/"))
+        .build());
+    Response response2 = call2.execute();
+    assertEquals("def", response2.body().string());
+    assertEquals(0, server.takeRequest().getSequenceNumber());
+  }
+
+  @Test public void recoverFromOneRefusedStreamReusesConnection() throws Exception {
+    server.enqueue(new MockResponse()
+        .setSocketPolicy(SocketPolicy.RESET_STREAM_AT_START)
+        .setHttp2ErrorCode(ErrorCode.REFUSED_STREAM.httpCode));
+    server.enqueue(new MockResponse()
+        .setBody("abc"));
+
+    Call call = client.newCall(new Request.Builder()
+        .url(server.url("/"))
+        .build());
+    Response response = call.execute();
+    assertEquals("abc", response.body().string());
+
+    assertEquals(0, server.takeRequest().getSequenceNumber()); // New connection.
+    assertEquals(1, server.takeRequest().getSequenceNumber()); // Reused connection.
+  }
+
+  @Test public void recoverFromOneInternalErrorRequiresNewConnection() throws Exception {
+    server.enqueue(new MockResponse()
+        .setSocketPolicy(SocketPolicy.RESET_STREAM_AT_START)
+        .setHttp2ErrorCode(ErrorCode.INTERNAL_ERROR.httpCode));
+    server.enqueue(new MockResponse()
+        .setBody("abc"));
+
+    client = client.newBuilder()
+        .dns(new DoubleInetAddressDns())
+        .build();
+
+    Call call = client.newCall(new Request.Builder()
+        .url(server.url("/"))
+        .build());
+    Response response = call.execute();
+    assertEquals("abc", response.body().string());
+
+    assertEquals(0, server.takeRequest().getSequenceNumber()); // New connection.
+    assertEquals(0, server.takeRequest().getSequenceNumber()); // New connection.
+  }
+
+  @Test public void recoverFromMultipleRefusedStreamsRequiresNewConnection() throws Exception {
+    server.enqueue(new MockResponse()
+        .setSocketPolicy(SocketPolicy.RESET_STREAM_AT_START)
+        .setHttp2ErrorCode(ErrorCode.REFUSED_STREAM.httpCode));
+    server.enqueue(new MockResponse()
+        .setSocketPolicy(SocketPolicy.RESET_STREAM_AT_START)
+        .setHttp2ErrorCode(ErrorCode.REFUSED_STREAM.httpCode));
+    server.enqueue(new MockResponse()
+        .setBody("abc"));
+
+    client = client.newBuilder()
+        .dns(new DoubleInetAddressDns())
+        .build();
+
+    Call call = client.newCall(new Request.Builder()
+        .url(server.url("/"))
+        .build());
+    Response response = call.execute();
+    assertEquals("abc", response.body().string());
+
+    assertEquals(0, server.takeRequest().getSequenceNumber()); // New connection.
+    assertEquals(1, server.takeRequest().getSequenceNumber()); // Reused connection.
+    assertEquals(0, server.takeRequest().getSequenceNumber()); // New connection.
+  }
+
+  @Test public void noRecoveryFromRefusedStreamWithRetryDisabled() throws Exception {
+    noRecoveryFromErrorWithRetryDisabled(ErrorCode.REFUSED_STREAM);
+  }
+
+  @Test public void noRecoveryFromInternalErrorWithRetryDisabled() throws Exception {
+    noRecoveryFromErrorWithRetryDisabled(ErrorCode.INTERNAL_ERROR);
+  }
+
+  private void noRecoveryFromErrorWithRetryDisabled(ErrorCode errorCode) throws Exception {
+    server.enqueue(new MockResponse()
+        .setSocketPolicy(SocketPolicy.RESET_STREAM_AT_START)
+        .setHttp2ErrorCode(errorCode.httpCode));
+    server.enqueue(new MockResponse()
+        .setBody("abc"));
+
+    client = client.newBuilder()
+        .retryOnConnectionFailure(false)
+        .build();
+
+    Call call = client.newCall(new Request.Builder()
+        .url(server.url("/"))
+        .build());
+    try {
+      call.execute();
+      fail();
+    } catch (StreamResetException expected) {
+      assertEquals(errorCode, expected.errorCode);
+    }
+  }
+
+  @Test public void nonAsciiResponseHeader() throws Exception {
+    server.enqueue(new MockResponse()
+        .addHeaderLenient("Alpha", "α")
+        .addHeaderLenient("β", "Beta"));
+
+    Call call = client.newCall(new Request.Builder()
+        .url(server.url("/"))
+        .build());
+    Response response = call.execute();
+
+    assertEquals("α", response.header("Alpha"));
+    assertEquals("Beta", response.header("β"));
   }
 
   @Test public void serverSendsPushPromise_GET() throws Exception {
@@ -54,7 +710,7 @@ public HttpOverHttp2Test() {
     RecordedRequest request = server.takeRequest();
     assertEquals("GET /foo HTTP/1.1", request.getRequestLine());
     assertEquals("https", request.getHeader(":scheme"));
-    assertEquals(server.getHostName() + ":" + server.getPort(), request.getHeader(hostHeader));
+    assertEquals(server.getHostName() + ":" + server.getPort(), request.getHeader(":authority"));
 
     RecordedRequest pushedRequest = server.takeRequest();
     assertEquals("GET /foo/bar HTTP/1.1", pushedRequest.getRequestLine());
@@ -80,7 +736,7 @@ public HttpOverHttp2Test() {
     RecordedRequest request = server.takeRequest();
     assertEquals("GET /foo HTTP/1.1", request.getRequestLine());
     assertEquals("https", request.getHeader(":scheme"));
-    assertEquals(server.getHostName() + ":" + server.getPort(), request.getHeader(hostHeader));
+    assertEquals(server.getHostName() + ":" + server.getPort(), request.getHeader(":authority"));
 
     RecordedRequest pushedRequest = server.takeRequest();
     assertEquals("HEAD /foo/bar HTTP/1.1", pushedRequest.getRequestLine());
@@ -93,7 +749,7 @@ public HttpOverHttp2Test() {
    */
   @Test public void settingsLimitsMaxConcurrentStreams() throws Exception {
     Settings settings = new Settings();
-    settings.set(Settings.MAX_CONCURRENT_STREAMS, 0, 2);
+    settings.set(Settings.MAX_CONCURRENT_STREAMS, 2);
 
     // Read & write a full request to confirm settings are accepted.
     server.enqueue(new MockResponse().withSettings(settings));
@@ -134,4 +790,35 @@ public HttpOverHttp2Test() {
     assertEquals(2, server.takeRequest().getSequenceNumber()); // Reuse settings connection.
     assertEquals(0, server.takeRequest().getSequenceNumber()); // New connection!
   }
+
+  public Buffer gzip(String bytes) throws IOException {
+    Buffer bytesOut = new Buffer();
+    BufferedSink sink = Okio.buffer(new GzipSink(bytesOut));
+    sink.writeUtf8(bytes);
+    sink.close();
+    return bytesOut;
+  }
+
+  class AsyncRequest implements Runnable {
+    String path;
+    CountDownLatch countDownLatch;
+
+    public AsyncRequest(String path, CountDownLatch countDownLatch) {
+      this.path = path;
+      this.countDownLatch = countDownLatch;
+    }
+
+    @Override public void run() {
+      try {
+        Call call = client.newCall(new Request.Builder()
+            .url(server.url(path))
+            .build());
+        Response response = call.execute();
+        assertEquals("A", response.body().string());
+        countDownLatch.countDown();
+      } catch (Exception e) {
+        throw new RuntimeException(e);
+      }
+    }
+  }
 }
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/framed/HttpOverSpdy3Test.java b/okhttp-tests/src/test/java/okhttp3/internal/framed/HttpOverSpdy3Test.java
deleted file mode 100644
index 6f7e793165..0000000000
--- a/okhttp-tests/src/test/java/okhttp3/internal/framed/HttpOverSpdy3Test.java
+++ /dev/null
@@ -1,25 +0,0 @@
-/*
- * Copyright (C) 2013 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.internal.framed;
-
-import okhttp3.Protocol;
-
-public class HttpOverSpdy3Test extends HttpOverSpdyTest {
-
-  public HttpOverSpdy3Test() {
-    super(Protocol.SPDY_3);
-  }
-}
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/framed/HttpOverSpdyTest.java b/okhttp-tests/src/test/java/okhttp3/internal/framed/HttpOverSpdyTest.java
deleted file mode 100644
index da09b4c91d..0000000000
--- a/okhttp-tests/src/test/java/okhttp3/internal/framed/HttpOverSpdyTest.java
+++ /dev/null
@@ -1,724 +0,0 @@
-/*
- * Copyright (C) 2013 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.internal.framed;
-
-import java.io.IOException;
-import java.io.InputStream;
-import java.net.Authenticator;
-import java.net.HttpURLConnection;
-import java.net.SocketTimeoutException;
-import java.util.Arrays;
-import java.util.concurrent.CountDownLatch;
-import java.util.concurrent.ExecutorService;
-import java.util.concurrent.Executors;
-import javax.net.ssl.HostnameVerifier;
-import okhttp3.Cache;
-import okhttp3.Call;
-import okhttp3.Cookie;
-import okhttp3.Credentials;
-import okhttp3.MediaType;
-import okhttp3.OkHttpClient;
-import okhttp3.Protocol;
-import okhttp3.RecordingCookieJar;
-import okhttp3.RecordingHostnameVerifier;
-import okhttp3.Request;
-import okhttp3.RequestBody;
-import okhttp3.Response;
-import okhttp3.internal.DoubleInetAddressDns;
-import okhttp3.internal.RecordingOkAuthenticator;
-import okhttp3.internal.SingleInetAddressDns;
-import okhttp3.internal.Util;
-import okhttp3.internal.tls.SslClient;
-import okhttp3.mockwebserver.MockResponse;
-import okhttp3.mockwebserver.MockWebServer;
-import okhttp3.mockwebserver.RecordedRequest;
-import okhttp3.mockwebserver.SocketPolicy;
-import okio.Buffer;
-import okio.BufferedSink;
-import okio.GzipSink;
-import okio.Okio;
-import org.junit.After;
-import org.junit.Before;
-import org.junit.Ignore;
-import org.junit.Rule;
-import org.junit.Test;
-import org.junit.rules.TemporaryFolder;
-
-import static java.util.concurrent.TimeUnit.MILLISECONDS;
-import static java.util.concurrent.TimeUnit.SECONDS;
-import static org.junit.Assert.assertArrayEquals;
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertNull;
-import static org.junit.Assert.fail;
-
-/** Test how SPDY interacts with HTTP features. */
-public abstract class HttpOverSpdyTest {
-  @Rule public final TemporaryFolder tempDir = new TemporaryFolder();
-  @Rule public final MockWebServer server = new MockWebServer();
-
-  /** Protocol to test, for example {@link Protocol#SPDY_3} */
-  private final Protocol protocol;
-  protected String hostHeader = ":host";
-
-  protected SslClient sslClient = SslClient.localhost();
-  protected HostnameVerifier hostnameVerifier = new RecordingHostnameVerifier();
-  protected OkHttpClient client;
-  protected Cache cache;
-
-  protected HttpOverSpdyTest(Protocol protocol) {
-    this.protocol = protocol;
-  }
-
-  @Before public void setUp() throws Exception {
-    server.useHttps(sslClient.socketFactory, false);
-    cache = new Cache(tempDir.getRoot(), Integer.MAX_VALUE);
-    client = new OkHttpClient.Builder()
-        .protocols(Arrays.asList(protocol, Protocol.HTTP_1_1))
-        .dns(new SingleInetAddressDns())
-        .sslSocketFactory(sslClient.socketFactory, sslClient.trustManager)
-        .hostnameVerifier(hostnameVerifier)
-        .build();
-  }
-
-  @After public void tearDown() throws Exception {
-    Authenticator.setDefault(null);
-  }
-
-  @Test public void get() throws Exception {
-    server.enqueue(new MockResponse()
-        .setBody("ABCDE")
-        .setStatus("HTTP/1.1 200 Sweet"));
-
-    Call call = client.newCall(new Request.Builder()
-        .url(server.url("/foo"))
-        .build());
-    Response response = call.execute();
-
-    assertEquals("ABCDE", response.body().string());
-    assertEquals(200, response.code());
-    assertEquals("Sweet", response.message());
-
-    RecordedRequest request = server.takeRequest();
-    assertEquals("GET /foo HTTP/1.1", request.getRequestLine());
-    assertEquals("https", request.getHeader(":scheme"));
-    assertEquals(server.getHostName() + ":" + server.getPort(), request.getHeader(hostHeader));
-  }
-
-  @Test public void emptyResponse() throws IOException {
-    server.enqueue(new MockResponse());
-
-    Call call = client.newCall(new Request.Builder()
-        .url(server.url("/foo"))
-        .build());
-    Response response = call.execute();
-
-    assertEquals(-1, response.body().byteStream().read());
-    response.body().close();
-  }
-
-  byte[] postBytes = "FGHIJ".getBytes(Util.UTF_8);
-
-  @Test public void noDefaultContentLengthOnStreamingPost() throws Exception {
-    server.enqueue(new MockResponse().setBody("ABCDE"));
-
-    Call call = client.newCall(new Request.Builder()
-        .url(server.url("/foo"))
-        .post(new RequestBody() {
-          @Override public MediaType contentType() {
-            return MediaType.parse("text/plain; charset=utf-8");
-          }
-
-          @Override public void writeTo(BufferedSink sink) throws IOException {
-            sink.write(postBytes);
-          }
-        })
-        .build());
-
-    Response response = call.execute();
-    assertEquals("ABCDE", response.body().string());
-
-    RecordedRequest request = server.takeRequest();
-    assertEquals("POST /foo HTTP/1.1", request.getRequestLine());
-    assertArrayEquals(postBytes, request.getBody().readByteArray());
-    assertNull(request.getHeader("Content-Length"));
-  }
-
-  @Test public void userSuppliedContentLengthHeader() throws Exception {
-    server.enqueue(new MockResponse().setBody("ABCDE"));
-
-    Call call = client.newCall(new Request.Builder()
-        .url(server.url("/foo"))
-        .post(new RequestBody() {
-          @Override public MediaType contentType() {
-            return MediaType.parse("text/plain; charset=utf-8");
-          }
-
-          @Override public long contentLength() throws IOException {
-            return postBytes.length;
-          }
-
-          @Override public void writeTo(BufferedSink sink) throws IOException {
-            sink.write(postBytes);
-          }
-        })
-        .build());
-
-    Response response = call.execute();
-    assertEquals("ABCDE", response.body().string());
-
-    RecordedRequest request = server.takeRequest();
-    assertEquals("POST /foo HTTP/1.1", request.getRequestLine());
-    assertArrayEquals(postBytes, request.getBody().readByteArray());
-    assertEquals(postBytes.length, Integer.parseInt(request.getHeader("Content-Length")));
-  }
-
-  @Test public void closeAfterFlush() throws Exception {
-    server.enqueue(new MockResponse().setBody("ABCDE"));
-
-    Call call = client.newCall(new Request.Builder()
-        .url(server.url("/foo"))
-        .post(new RequestBody() {
-          @Override public MediaType contentType() {
-            return MediaType.parse("text/plain; charset=utf-8");
-          }
-
-          @Override public long contentLength() throws IOException {
-            return postBytes.length;
-          }
-
-          @Override public void writeTo(BufferedSink sink) throws IOException {
-            sink.write(postBytes);  // push bytes into SpdyDataOutputStream.buffer
-            sink.flush(); // FramedConnection.writeData subject to write window
-            sink.close(); // FramedConnection.writeData empty frame
-          }
-        })
-        .build());
-
-    Response response = call.execute();
-    assertEquals("ABCDE", response.body().string());
-
-    RecordedRequest request = server.takeRequest();
-    assertEquals("POST /foo HTTP/1.1", request.getRequestLine());
-    assertArrayEquals(postBytes, request.getBody().readByteArray());
-    assertEquals(postBytes.length, Integer.parseInt(request.getHeader("Content-Length")));
-  }
-
-  @Test public void spdyConnectionReuse() throws Exception {
-    server.enqueue(new MockResponse().setBody("ABCDEF"));
-    server.enqueue(new MockResponse().setBody("GHIJKL"));
-
-    Call call1 = client.newCall(new Request.Builder()
-        .url(server.url("/r1"))
-        .build());
-    Call call2 = client.newCall(new Request.Builder()
-        .url(server.url("/r1"))
-        .build());
-    Response response1 = call1.execute();
-    Response response2 = call2.execute();
-
-    assertEquals("ABC", response1.body().source().readUtf8(3));
-    assertEquals("GHI", response2.body().source().readUtf8(3));
-    assertEquals("DEF", response1.body().source().readUtf8(3));
-    assertEquals("JKL", response2.body().source().readUtf8(3));
-    assertEquals(0, server.takeRequest().getSequenceNumber());
-    assertEquals(1, server.takeRequest().getSequenceNumber());
-  }
-
-  @Test @Ignore public void synchronousSpdyRequest() throws Exception {
-    server.enqueue(new MockResponse().setBody("A"));
-    server.enqueue(new MockResponse().setBody("A"));
-
-    ExecutorService executor = Executors.newCachedThreadPool();
-    CountDownLatch countDownLatch = new CountDownLatch(2);
-    executor.execute(new SpdyRequest("/r1", countDownLatch));
-    executor.execute(new SpdyRequest("/r2", countDownLatch));
-    countDownLatch.await();
-    assertEquals(0, server.takeRequest().getSequenceNumber());
-    assertEquals(1, server.takeRequest().getSequenceNumber());
-  }
-
-  @Test public void gzippedResponseBody() throws Exception {
-    server.enqueue(new MockResponse()
-        .addHeader("Content-Encoding: gzip")
-        .setBody(gzip("ABCABCABC")));
-
-    Call call = client.newCall(new Request.Builder()
-        .url(server.url("/r1"))
-        .build());
-
-    Response response = call.execute();
-    assertEquals("ABCABCABC", response.body().string());
-  }
-
-  @Test public void authenticate() throws Exception {
-    server.enqueue(new MockResponse()
-        .setResponseCode(HttpURLConnection.HTTP_UNAUTHORIZED)
-        .addHeader("www-authenticate: Basic realm=\"protected area\"")
-        .setBody("Please authenticate."));
-    server.enqueue(new MockResponse()
-        .setBody("Successful auth!"));
-
-    String credential = Credentials.basic("username", "password");
-    client = client.newBuilder()
-        .authenticator(new RecordingOkAuthenticator(credential))
-        .build();
-
-    Call call = client.newCall(new Request.Builder()
-        .url(server.url("/"))
-        .build());
-    Response response = call.execute();
-    assertEquals("Successful auth!", response.body().string());
-
-    RecordedRequest denied = server.takeRequest();
-    assertNull(denied.getHeader("Authorization"));
-    RecordedRequest accepted = server.takeRequest();
-    assertEquals("GET / HTTP/1.1", accepted.getRequestLine());
-    assertEquals(credential, accepted.getHeader("Authorization"));
-  }
-
-  @Test public void redirect() throws Exception {
-    server.enqueue(new MockResponse().setResponseCode(HttpURLConnection.HTTP_MOVED_TEMP)
-        .addHeader("Location: /foo")
-        .setBody("This page has moved!"));
-    server.enqueue(new MockResponse().setBody("This is the new location!"));
-
-    Call call = client.newCall(new Request.Builder()
-        .url(server.url("/"))
-        .build());
-
-    Response response = call.execute();
-    assertEquals("This is the new location!", response.body().string());
-
-    RecordedRequest request1 = server.takeRequest();
-    assertEquals("/", request1.getPath());
-    RecordedRequest request2 = server.takeRequest();
-    assertEquals("/foo", request2.getPath());
-  }
-
-  @Test public void readAfterLastByte() throws Exception {
-    server.enqueue(new MockResponse().setBody("ABC"));
-
-    Call call = client.newCall(new Request.Builder()
-        .url(server.url("/"))
-        .build());
-    Response response = call.execute();
-
-    InputStream in = response.body().byteStream();
-    assertEquals('A', in.read());
-    assertEquals('B', in.read());
-    assertEquals('C', in.read());
-    assertEquals(-1, in.read());
-    assertEquals(-1, in.read());
-  }
-
-  @Ignore // See https://github.com/square/okhttp/issues/578
-  @Test(timeout = 3000) public void readResponseHeaderTimeout() throws Exception {
-    server.enqueue(new MockResponse().setSocketPolicy(SocketPolicy.NO_RESPONSE));
-    server.enqueue(new MockResponse().setBody("A"));
-
-    client = client.newBuilder()
-        .readTimeout(1000, MILLISECONDS)
-        .build();
-
-    Call call = client.newCall(new Request.Builder()
-        .url(server.url("/"))
-        .build());
-    Response response = call.execute();
-    assertEquals("A", response.body().string());
-  }
-
-  /**
-   * Test to ensure we don't  throw a read timeout on responses that are progressing.  For this
-   * case, we take a 4KiB body and throttle it to 1KiB/second.  We set the read timeout to two
-   * seconds.  If our implementation is acting correctly, it will not throw, as it is progressing.
-   */
-  @Test public void readTimeoutMoreGranularThanBodySize() throws Exception {
-    char[] body = new char[4096]; // 4KiB to read.
-    Arrays.fill(body, 'y');
-    server.enqueue(new MockResponse().setBody(new String(body))
-        .throttleBody(1024, 1, SECONDS)); // Slow connection 1KiB/second.
-
-    client = client.newBuilder()
-        .readTimeout(2, SECONDS)
-        .build();
-
-    Call call = client.newCall(new Request.Builder()
-        .url(server.url("/"))
-        .build());
-
-    Response response = call.execute();
-    assertEquals(new String(body), response.body().string());
-  }
-
-  /**
-   * Test to ensure we throw a read timeout on responses that are progressing too slowly.  For this
-   * case, we take a 2KiB body and throttle it to 1KiB/second.  We set the read timeout to half a
-   * second.  If our implementation is acting correctly, it will throw, as a byte doesn't arrive in
-   * time.
-   */
-  @Test public void readTimeoutOnSlowConnection() throws Exception {
-    char[] body = new char[2048]; // 2KiB to read.
-    Arrays.fill(body, 'y');
-    server.enqueue(new MockResponse()
-        .setBody(new String(body))
-        .throttleBody(1024, 1, SECONDS)); // Slow connection 1KiB/second.
-
-    client = client.newBuilder()
-        .readTimeout(500, MILLISECONDS) // Half a second to read something.
-        .build();
-
-    Call call = client.newCall(new Request.Builder()
-        .url(server.url("/"))
-        .build());
-    Response response = call.execute();
-
-    try {
-      response.body().string();
-      fail("Should have timed out!");
-    } catch (SocketTimeoutException expected) {
-      assertEquals("timeout", expected.getMessage());
-    }
-  }
-
-  @Test public void spdyConnectionTimeout() throws Exception {
-    server.enqueue(new MockResponse()
-        .setBody("A")
-        .setBodyDelay(1, SECONDS));
-
-    OkHttpClient client1 = client.newBuilder()
-        .readTimeout(2000, MILLISECONDS)
-        .build();
-    Call call1 = client1
-        .newCall(new Request.Builder()
-        .url(server.url("/"))
-        .build());
-
-    OkHttpClient client2 = client.newBuilder()
-        .readTimeout(200, MILLISECONDS)
-        .build();
-    Call call2 = client2
-        .newCall(new Request.Builder()
-        .url(server.url("/"))
-        .build());
-
-    Response response1 = call1.execute();
-    assertEquals("A", response1.body().string());
-
-    try {
-      call2.execute();
-      fail();
-    } catch (IOException expected) {
-    }
-  }
-
-  @Test public void responsesAreCached() throws IOException {
-    client = client.newBuilder()
-        .cache(cache)
-        .build();
-
-    server.enqueue(new MockResponse()
-        .addHeader("cache-control: max-age=60")
-        .setBody("A"));
-
-    Call call1 = client.newCall(new Request.Builder()
-        .url(server.url("/"))
-        .build());
-    Response response1 = call1.execute();
-
-    assertEquals("A", response1.body().string());
-    assertEquals(1, cache.requestCount());
-    assertEquals(1, cache.networkCount());
-    assertEquals(0, cache.hitCount());
-
-    Call call2 = client.newCall(new Request.Builder()
-        .url(server.url("/"))
-        .build());
-    Response response2 = call2.execute();
-    assertEquals("A", response2.body().string());
-
-    Call call3 = client.newCall(new Request.Builder()
-        .url(server.url("/"))
-        .build());
-    Response response3 = call3.execute();
-    assertEquals("A", response3.body().string());
-
-    assertEquals(3, cache.requestCount());
-    assertEquals(1, cache.networkCount());
-    assertEquals(2, cache.hitCount());
-  }
-
-  @Test public void conditionalCache() throws IOException {
-    client = client.newBuilder()
-        .cache(cache)
-        .build();
-
-    server.enqueue(new MockResponse()
-        .addHeader("ETag: v1")
-        .setBody("A"));
-    server.enqueue(new MockResponse()
-        .setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
-
-    Call call1 = client.newCall(new Request.Builder()
-        .url(server.url("/"))
-        .build());
-    Response response1 = call1.execute();
-    assertEquals("A", response1.body().string());
-
-    assertEquals(1, cache.requestCount());
-    assertEquals(1, cache.networkCount());
-    assertEquals(0, cache.hitCount());
-
-    Call call2 = client.newCall(new Request.Builder()
-        .url(server.url("/"))
-        .build());
-    Response response2 = call2.execute();
-    assertEquals("A", response2.body().string());
-
-    assertEquals(2, cache.requestCount());
-    assertEquals(2, cache.networkCount());
-    assertEquals(1, cache.hitCount());
-  }
-
-  @Test public void responseCachedWithoutConsumingFullBody() throws IOException {
-    client = client.newBuilder()
-        .cache(cache)
-        .build();
-
-    server.enqueue(new MockResponse()
-        .addHeader("cache-control: max-age=60")
-        .setBody("ABCD"));
-    server.enqueue(new MockResponse()
-        .addHeader("cache-control: max-age=60")
-        .setBody("EFGH"));
-
-    Call call1 = client.newCall(new Request.Builder()
-        .url(server.url("/"))
-        .build());
-    Response response1 = call1.execute();
-    assertEquals("AB", response1.body().source().readUtf8(2));
-    response1.body().close();
-
-    Call call2 = client.newCall(new Request.Builder()
-        .url(server.url("/"))
-        .build());
-    Response response2 = call2.execute();
-    assertEquals("ABCD", response2.body().source().readUtf8());
-    response2.body().close();
-  }
-
-  @Test public void sendRequestCookies() throws Exception {
-    RecordingCookieJar cookieJar = new RecordingCookieJar();
-    Cookie requestCookie = new Cookie.Builder()
-        .name("a")
-        .value("b")
-        .domain(server.getHostName())
-        .build();
-    cookieJar.enqueueRequestCookies(requestCookie);
-    client = client.newBuilder()
-        .cookieJar(cookieJar)
-        .build();
-
-    server.enqueue(new MockResponse());
-    Call call = client.newCall(new Request.Builder()
-        .url(server.url("/"))
-        .build());
-    Response response = call.execute();
-    assertEquals("", response.body().string());
-
-    RecordedRequest request = server.takeRequest();
-    assertEquals("a=b", request.getHeader("Cookie"));
-  }
-
-  @Test public void receiveResponseCookies() throws Exception {
-    RecordingCookieJar cookieJar = new RecordingCookieJar();
-    client = client.newBuilder()
-        .cookieJar(cookieJar)
-        .build();
-
-    server.enqueue(new MockResponse()
-        .addHeader("set-cookie: a=b"));
-
-    Call call = client.newCall(new Request.Builder()
-        .url(server.url("/"))
-        .build());
-    Response response = call.execute();
-    assertEquals("", response.body().string());
-
-    cookieJar.assertResponseCookies("a=b; path=/");
-  }
-
-  /** https://github.com/square/okhttp/issues/1191 */
-  @Test public void cancelWithStreamNotCompleted() throws Exception {
-    server.enqueue(new MockResponse()
-        .setBody("abc"));
-    server.enqueue(new MockResponse()
-        .setBody("def"));
-
-    // Disconnect before the stream is created. A connection is still established!
-    Call call1 = client.newCall(new Request.Builder()
-        .url(server.url("/"))
-        .build());
-    call1.execute();
-    call1.cancel();
-
-    // That connection is pooled, and it works.
-    assertEquals(1, client.connectionPool().connectionCount());
-    Call call2 = client.newCall(new Request.Builder()
-        .url(server.url("/"))
-        .build());
-    Response response2 = call2.execute();
-    assertEquals("def", response2.body().string());
-    assertEquals(0, server.takeRequest().getSequenceNumber());
-  }
-
-  @Test public void recoverFromOneRefusedStreamReusesConnection() throws Exception {
-    server.enqueue(new MockResponse()
-        .setSocketPolicy(SocketPolicy.RESET_STREAM_AT_START)
-        .setHttp2ErrorCode(ErrorCode.REFUSED_STREAM.httpCode));
-    server.enqueue(new MockResponse()
-        .setBody("abc"));
-
-    Call call = client.newCall(new Request.Builder()
-        .url(server.url("/"))
-        .build());
-    Response response = call.execute();
-    assertEquals("abc", response.body().string());
-
-    assertEquals(0, server.takeRequest().getSequenceNumber()); // New connection.
-    assertEquals(1, server.takeRequest().getSequenceNumber()); // Reused connection.
-  }
-
-  @Test public void recoverFromOneInternalErrorRequiresNewConnection() throws Exception {
-    server.enqueue(new MockResponse()
-        .setSocketPolicy(SocketPolicy.RESET_STREAM_AT_START)
-        .setHttp2ErrorCode(ErrorCode.INTERNAL_ERROR.httpCode));
-    server.enqueue(new MockResponse()
-        .setBody("abc"));
-
-    client = client.newBuilder()
-        .dns(new DoubleInetAddressDns())
-        .build();
-
-    Call call = client.newCall(new Request.Builder()
-        .url(server.url("/"))
-        .build());
-    Response response = call.execute();
-    assertEquals("abc", response.body().string());
-
-    assertEquals(0, server.takeRequest().getSequenceNumber()); // New connection.
-    assertEquals(0, server.takeRequest().getSequenceNumber()); // New connection.
-  }
-
-  @Test public void recoverFromMultipleRefusedStreamsRequiresNewConnection() throws Exception {
-    server.enqueue(new MockResponse()
-        .setSocketPolicy(SocketPolicy.RESET_STREAM_AT_START)
-        .setHttp2ErrorCode(ErrorCode.REFUSED_STREAM.httpCode));
-    server.enqueue(new MockResponse()
-        .setSocketPolicy(SocketPolicy.RESET_STREAM_AT_START)
-        .setHttp2ErrorCode(ErrorCode.REFUSED_STREAM.httpCode));
-    server.enqueue(new MockResponse()
-        .setBody("abc"));
-
-    client = client.newBuilder()
-        .dns(new DoubleInetAddressDns())
-        .build();
-
-    Call call = client.newCall(new Request.Builder()
-        .url(server.url("/"))
-        .build());
-    Response response = call.execute();
-    assertEquals("abc", response.body().string());
-
-    assertEquals(0, server.takeRequest().getSequenceNumber()); // New connection.
-    assertEquals(1, server.takeRequest().getSequenceNumber()); // Reused connection.
-    assertEquals(0, server.takeRequest().getSequenceNumber()); // New connection.
-  }
-
-  @Test public void noRecoveryFromRefusedStreamWithRetryDisabled() throws Exception {
-    noRecoveryFromErrorWithRetryDisabled(ErrorCode.REFUSED_STREAM);
-  }
-
-  @Test public void noRecoveryFromInternalErrorWithRetryDisabled() throws Exception {
-    noRecoveryFromErrorWithRetryDisabled(ErrorCode.INTERNAL_ERROR);
-  }
-
-  private void noRecoveryFromErrorWithRetryDisabled(ErrorCode errorCode) throws Exception {
-    server.enqueue(new MockResponse()
-        .setSocketPolicy(SocketPolicy.RESET_STREAM_AT_START)
-        .setHttp2ErrorCode(errorCode.httpCode));
-    server.enqueue(new MockResponse()
-        .setBody("abc"));
-
-    client = client.newBuilder()
-        .retryOnConnectionFailure(false)
-        .build();
-
-    Call call = client.newCall(new Request.Builder()
-        .url(server.url("/"))
-        .build());
-    try {
-      call.execute();
-      fail();
-    } catch (StreamResetException expected) {
-      assertEquals(errorCode, expected.errorCode);
-    }
-  }
-
-  @Test public void nonAsciiResponseHeader() throws Exception {
-    server.enqueue(new MockResponse()
-        .addHeaderLenient("Alpha", "α")
-        .addHeaderLenient("β", "Beta"));
-
-    Call call = client.newCall(new Request.Builder()
-        .url(server.url("/"))
-        .build());
-    Response response = call.execute();
-
-    assertEquals("α", response.header("Alpha"));
-    assertEquals("Beta", response.header("β"));
-  }
-
-  public Buffer gzip(String bytes) throws IOException {
-    Buffer bytesOut = new Buffer();
-    BufferedSink sink = Okio.buffer(new GzipSink(bytesOut));
-    sink.writeUtf8(bytes);
-    sink.close();
-    return bytesOut;
-  }
-
-  class SpdyRequest implements Runnable {
-    String path;
-    CountDownLatch countDownLatch;
-
-    public SpdyRequest(String path, CountDownLatch countDownLatch) {
-      this.path = path;
-      this.countDownLatch = countDownLatch;
-    }
-
-    @Override public void run() {
-      try {
-        Call call = client.newCall(new Request.Builder()
-            .url(server.url(path))
-            .build());
-        Response response = call.execute();
-        assertEquals("A", response.body().string());
-        countDownLatch.countDown();
-      } catch (Exception e) {
-        throw new RuntimeException(e);
-      }
-    }
-  }
-}
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/framed/HuffmanTest.java b/okhttp-tests/src/test/java/okhttp3/internal/framed/HuffmanTest.java
index b85a1b35b7..0b9b60c12c 100644
--- a/okhttp-tests/src/test/java/okhttp3/internal/framed/HuffmanTest.java
+++ b/okhttp-tests/src/test/java/okhttp3/internal/framed/HuffmanTest.java
@@ -25,11 +25,8 @@
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertTrue;
 
-/**
- * Original version of this class was lifted from {@code com.twitter.hpack.HuffmanTest}.
- */
-public class HuffmanTest {
-
+/** Original version of this class was lifted from {@code com.twitter.hpack.HuffmanTest}. */
+public final class HuffmanTest {
   @Test public void roundTripForRequestAndResponse() throws IOException {
     String s = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789";
     for (int i = 0; i < s.length(); i++) {
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/framed/MockSpdyPeer.java b/okhttp-tests/src/test/java/okhttp3/internal/framed/MockHttp2Peer.java
similarity index 84%
rename from okhttp-tests/src/test/java/okhttp3/internal/framed/MockSpdyPeer.java
rename to okhttp-tests/src/test/java/okhttp3/internal/framed/MockHttp2Peer.java
index edc8f41c30..bc4450d675 100644
--- a/okhttp-tests/src/test/java/okhttp3/internal/framed/MockSpdyPeer.java
+++ b/okhttp-tests/src/test/java/okhttp3/internal/framed/MockHttp2Peer.java
@@ -38,29 +38,27 @@
 import okio.Okio;
 
 /** Replays prerecorded outgoing frames and records incoming frames. */
-public final class MockSpdyPeer implements Closeable {
-  private static final Logger logger = Logger.getLogger(MockSpdyPeer.class.getName());
+public final class MockHttp2Peer implements Closeable {
+  private static final Logger logger = Logger.getLogger(MockHttp2Peer.class.getName());
 
   private int frameCount = 0;
   private boolean client = false;
-  private Variant variant = new Spdy3();
   private final Buffer bytesOut = new Buffer();
-  private FrameWriter frameWriter = variant.newWriter(bytesOut, client);
+  private FrameWriter frameWriter = new FrameWriter(bytesOut, client);
   private final List<OutFrame> outFrames = new ArrayList<>();
   private final BlockingQueue<InFrame> inFrames = new LinkedBlockingQueue<>();
   private int port;
   private final ExecutorService executor = Executors.newSingleThreadExecutor(
-      Util.threadFactory("MockSpdyPeer", false));
+      Util.threadFactory("MockHttp2Peer", false));
   private ServerSocket serverSocket;
   private Socket socket;
 
-  public void setVariantAndClient(Variant variant, boolean client) {
-    if (this.variant.getProtocol() == variant.getProtocol() && this.client == client) {
+  public void setClient(boolean client) {
+    if (this.client == client) {
       return;
     }
     this.client = client;
-    this.variant = variant;
-    this.frameWriter = variant.newWriter(bytesOut, client);
+    this.frameWriter = new FrameWriter(bytesOut, client);
   }
 
   public void acceptFrame() {
@@ -82,15 +80,6 @@ public FrameWriter sendFrame() {
     return frameWriter;
   }
 
-  /**
-   * Sends a manually-constructed frame. This is useful to test frames that won't be generated
-   * naturally.
-   */
-  public void sendFrame(byte[] frame) throws IOException {
-    outFrames.add(new OutFrame(frameCount++, bytesOut.size(), false));
-    bytesOut.write(frame);
-  }
-
   /**
    * Shortens the last frame from its original length to {@code length}. This will cause the peer to
    * close the socket as soon as this frame has been written; otherwise the peer stays open until
@@ -126,8 +115,8 @@ public void play() throws IOException {
         try {
           readAndWriteFrames();
         } catch (IOException e) {
-          Util.closeQuietly(MockSpdyPeer.this);
-          logger.info(MockSpdyPeer.this + " done: " + e.getMessage());
+          Util.closeQuietly(MockHttp2Peer.this);
+          logger.info(MockHttp2Peer.this + " done: " + e.getMessage());
         }
       }
     });
@@ -147,7 +136,7 @@ private void readAndWriteFrames() throws IOException {
 
     OutputStream out = socket.getOutputStream();
     InputStream in = socket.getInputStream();
-    FrameReader reader = variant.newReader(Okio.buffer(Okio.source(in)), client);
+    FrameReader reader = new FrameReader(Okio.buffer(Okio.source(in)), client);
 
     Iterator<OutFrame> outFramesIterator = outFrames.iterator();
     byte[] outBytes = bytesOut.readByteArray();
@@ -199,7 +188,7 @@ public Socket openSocket() throws IOException {
   }
 
   @Override public String toString() {
-    return "MockSpdyPeer[" + port + "]";
+    return "MockHttp2Peer[" + port + "]";
   }
 
   private static class OutFrame {
@@ -228,7 +217,6 @@ private OutFrame(int sequence, long start, boolean truncated) {
     public List<Header> headerBlock;
     public byte[] data;
     public Settings settings;
-    public HeadersMode headersMode;
     public boolean ack;
     public int payload1;
     public int payload2;
@@ -240,33 +228,31 @@ public InFrame(int sequence, FrameReader reader) {
 
     @Override public void settings(boolean clearPrevious, Settings settings) {
       if (this.type != -1) throw new IllegalStateException();
-      this.type = Spdy3.TYPE_SETTINGS;
+      this.type = Http2.TYPE_SETTINGS;
       this.clearPrevious = clearPrevious;
       this.settings = settings;
     }
 
     @Override public void ackSettings() {
       if (this.type != -1) throw new IllegalStateException();
-      this.type = Spdy3.TYPE_SETTINGS;
+      this.type = Http2.TYPE_SETTINGS;
       this.ack = true;
     }
 
-    @Override public void headers(boolean outFinished, boolean inFinished, int streamId,
-        int associatedStreamId, List<Header> headerBlock, HeadersMode headersMode) {
+    @Override public void headers(boolean inFinished, int streamId,
+        int associatedStreamId, List<Header> headerBlock) {
       if (this.type != -1) throw new IllegalStateException();
-      this.type = Spdy3.TYPE_HEADERS;
-      this.outFinished = outFinished;
+      this.type = Http2.TYPE_HEADERS;
       this.inFinished = inFinished;
       this.streamId = streamId;
       this.associatedStreamId = associatedStreamId;
       this.headerBlock = headerBlock;
-      this.headersMode = headersMode;
     }
 
     @Override public void data(boolean inFinished, int streamId, BufferedSource source, int length)
         throws IOException {
       if (this.type != -1) throw new IllegalStateException();
-      this.type = Spdy3.TYPE_DATA;
+      this.type = Http2.TYPE_DATA;
       this.inFinished = inFinished;
       this.streamId = streamId;
       this.data = source.readByteString(length).toByteArray();
@@ -274,14 +260,14 @@ public InFrame(int sequence, FrameReader reader) {
 
     @Override public void rstStream(int streamId, ErrorCode errorCode) {
       if (this.type != -1) throw new IllegalStateException();
-      this.type = Spdy3.TYPE_RST_STREAM;
+      this.type = Http2.TYPE_RST_STREAM;
       this.streamId = streamId;
       this.errorCode = errorCode;
     }
 
     @Override public void ping(boolean ack, int payload1, int payload2) {
       if (this.type != -1) throw new IllegalStateException();
-      this.type = Spdy3.TYPE_PING;
+      this.type = Http2.TYPE_PING;
       this.ack = ack;
       this.payload1 = payload1;
       this.payload2 = payload2;
@@ -289,7 +275,7 @@ public InFrame(int sequence, FrameReader reader) {
 
     @Override public void goAway(int lastGoodStreamId, ErrorCode errorCode, ByteString debugData) {
       if (this.type != -1) throw new IllegalStateException();
-      this.type = Spdy3.TYPE_GOAWAY;
+      this.type = Http2.TYPE_GOAWAY;
       this.streamId = lastGoodStreamId;
       this.errorCode = errorCode;
       this.data = debugData.toByteArray();
@@ -297,7 +283,7 @@ public InFrame(int sequence, FrameReader reader) {
 
     @Override public void windowUpdate(int streamId, long windowSizeIncrement) {
       if (this.type != -1) throw new IllegalStateException();
-      this.type = Spdy3.TYPE_WINDOW_UPDATE;
+      this.type = Http2.TYPE_WINDOW_UPDATE;
       this.streamId = streamId;
       this.windowSizeIncrement = windowSizeIncrement;
     }
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/framed/SettingsTest.java b/okhttp-tests/src/test/java/okhttp3/internal/framed/SettingsTest.java
index 9eae7f89db..5f9683a381 100644
--- a/okhttp-tests/src/test/java/okhttp3/internal/framed/SettingsTest.java
+++ b/okhttp-tests/src/test/java/okhttp3/internal/framed/SettingsTest.java
@@ -18,159 +18,60 @@
 import org.junit.Test;
 
 import static okhttp3.internal.framed.Settings.DEFAULT_INITIAL_WINDOW_SIZE;
-import static okhttp3.internal.framed.Settings.DOWNLOAD_BANDWIDTH;
-import static okhttp3.internal.framed.Settings.DOWNLOAD_RETRANS_RATE;
 import static okhttp3.internal.framed.Settings.MAX_CONCURRENT_STREAMS;
-import static okhttp3.internal.framed.Settings.PERSISTED;
-import static okhttp3.internal.framed.Settings.PERSIST_VALUE;
-import static okhttp3.internal.framed.Settings.UPLOAD_BANDWIDTH;
 import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertFalse;
-import static org.junit.Assert.assertTrue;
 
 public final class SettingsTest {
   @Test public void unsetField() {
     Settings settings = new Settings();
-    assertEquals(-3, settings.getUploadBandwidth(-3));
+    assertEquals(-3, settings.getMaxConcurrentStreams(-3));
   }
 
   @Test public void setFields() {
     Settings settings = new Settings();
 
-    // WARNING: clash on flags between spdy/3 and HTTP/2!
-    assertEquals(-3, settings.getUploadBandwidth(-3));
-    assertEquals(-1, settings.getHeaderTableSize());
-    settings.set(UPLOAD_BANDWIDTH, 0, 42);
-    assertEquals(42, settings.getUploadBandwidth(-3));
-    settings.set(Settings.HEADER_TABLE_SIZE, 0, 8096);
+    settings.set(Settings.HEADER_TABLE_SIZE, 8096);
     assertEquals(8096, settings.getHeaderTableSize());
 
-    // WARNING: clash on flags between spdy/3 and HTTP/2!
     assertEquals(true, settings.getEnablePush(true));
-    settings.set(Settings.ENABLE_PUSH, 0, 1);
+    settings.set(Settings.ENABLE_PUSH, 1);
     assertEquals(true, settings.getEnablePush(false));
     settings.clear();
-    assertEquals(-3, settings.getDownloadBandwidth(-3));
-    settings.set(DOWNLOAD_BANDWIDTH, 0, 53);
-    assertEquals(53, settings.getDownloadBandwidth(-3));
-
-    assertEquals(-3, settings.getRoundTripTime(-3));
-    settings.set(Settings.ROUND_TRIP_TIME, 0, 64);
-    assertEquals(64, settings.getRoundTripTime(-3));
 
     assertEquals(-3, settings.getMaxConcurrentStreams(-3));
-    settings.set(MAX_CONCURRENT_STREAMS, 0, 75);
+    settings.set(MAX_CONCURRENT_STREAMS, 75);
     assertEquals(75, settings.getMaxConcurrentStreams(-3));
 
-    // WARNING: clash on flags between spdy/3 and HTTP/2!
-    assertEquals(-3, settings.getCurrentCwnd(-3));
-    settings.set(Settings.CURRENT_CWND, 0, 86);
-    assertEquals(86, settings.getCurrentCwnd(-3));
     settings.clear();
     assertEquals(16384, settings.getMaxFrameSize(16384));
-    settings.set(Settings.MAX_FRAME_SIZE, 0, 16777215);
+    settings.set(Settings.MAX_FRAME_SIZE, 16777215);
     assertEquals(16777215, settings.getMaxFrameSize(16384));
 
-    // WARNING: clash on flags between spdy/3 and HTTP/2!
-    assertEquals(-3, settings.getDownloadRetransRate(-3));
-    settings.set(DOWNLOAD_RETRANS_RATE, 0, 97);
-    assertEquals(97, settings.getDownloadRetransRate(-3));
-    settings.clear();
     assertEquals(-1, settings.getMaxHeaderListSize(-1));
-    settings.set(Settings.MAX_HEADER_LIST_SIZE, 0, 16777215);
+    settings.set(Settings.MAX_HEADER_LIST_SIZE, 16777215);
     assertEquals(16777215, settings.getMaxHeaderListSize(-1));
 
     assertEquals(DEFAULT_INITIAL_WINDOW_SIZE,
-        settings.getInitialWindowSize(DEFAULT_INITIAL_WINDOW_SIZE));
-    settings.set(Settings.INITIAL_WINDOW_SIZE, 0, 108);
-    assertEquals(108, settings.getInitialWindowSize(DEFAULT_INITIAL_WINDOW_SIZE));
-
-    assertEquals(-3, settings.getClientCertificateVectorSize(-3));
-    settings.set(Settings.CLIENT_CERTIFICATE_VECTOR_SIZE, 0, 117);
-    assertEquals(117, settings.getClientCertificateVectorSize(-3));
-  }
-
-  @Test public void isPersisted() {
-    Settings settings = new Settings();
-
-    // Initially false.
-    assertFalse(settings.isPersisted(Settings.ROUND_TRIP_TIME));
-
-    // Set no flags.
-    settings.set(Settings.ROUND_TRIP_TIME, 0, 0);
-    assertFalse(settings.isPersisted(Settings.ROUND_TRIP_TIME));
-
-    // Set the wrong flag.
-    settings.set(Settings.ROUND_TRIP_TIME, PERSIST_VALUE, 0);
-    assertFalse(settings.isPersisted(Settings.ROUND_TRIP_TIME));
-
-    // Set the right flag.
-    settings.set(Settings.ROUND_TRIP_TIME, PERSISTED, 0);
-    assertTrue(settings.isPersisted(Settings.ROUND_TRIP_TIME));
-
-    // Set multiple flags.
-    settings.set(Settings.ROUND_TRIP_TIME, PERSIST_VALUE | PERSISTED, 0);
-    assertTrue(settings.isPersisted(Settings.ROUND_TRIP_TIME));
-
-    // Clear the flag.
-    settings.set(Settings.ROUND_TRIP_TIME, PERSIST_VALUE, 0);
-    assertFalse(settings.isPersisted(Settings.ROUND_TRIP_TIME));
-
-    // Clear all flags.
-    settings.set(Settings.ROUND_TRIP_TIME, 0, 0);
-    assertFalse(settings.isPersisted(Settings.ROUND_TRIP_TIME));
-  }
-
-  @Test public void persistValue() {
-    Settings settings = new Settings();
-
-    // Initially false.
-    assertFalse(settings.persistValue(Settings.ROUND_TRIP_TIME));
-
-    // Set no flags.
-    settings.set(Settings.ROUND_TRIP_TIME, 0, 0);
-    assertFalse(settings.persistValue(Settings.ROUND_TRIP_TIME));
-
-    // Set the wrong flag.
-    settings.set(Settings.ROUND_TRIP_TIME, PERSISTED, 0);
-    assertFalse(settings.persistValue(Settings.ROUND_TRIP_TIME));
-
-    // Set the right flag.
-    settings.set(Settings.ROUND_TRIP_TIME, PERSIST_VALUE, 0);
-    assertTrue(settings.persistValue(Settings.ROUND_TRIP_TIME));
-
-    // Set multiple flags.
-    settings.set(Settings.ROUND_TRIP_TIME, PERSIST_VALUE | PERSISTED, 0);
-    assertTrue(settings.persistValue(Settings.ROUND_TRIP_TIME));
-
-    // Clear the flag.
-    settings.set(Settings.ROUND_TRIP_TIME, PERSISTED, 0);
-    assertFalse(settings.persistValue(Settings.ROUND_TRIP_TIME));
-
-    // Clear all flags.
-    settings.set(Settings.ROUND_TRIP_TIME, 0, 0);
-    assertFalse(settings.persistValue(Settings.ROUND_TRIP_TIME));
+        settings.getInitialWindowSize());
+    settings.set(Settings.INITIAL_WINDOW_SIZE, 108);
+    assertEquals(108, settings.getInitialWindowSize());
   }
 
   @Test public void merge() {
     Settings a = new Settings();
-    a.set(UPLOAD_BANDWIDTH, PERSIST_VALUE, 100);
-    a.set(DOWNLOAD_BANDWIDTH, PERSIST_VALUE, 200);
-    a.set(DOWNLOAD_RETRANS_RATE, 0, 300);
+    a.set(Settings.HEADER_TABLE_SIZE, 10000);
+    a.set(Settings.MAX_HEADER_LIST_SIZE, 20000);
+    a.set(Settings.INITIAL_WINDOW_SIZE, 30000);
 
     Settings b = new Settings();
-    b.set(DOWNLOAD_BANDWIDTH, 0, 400);
-    b.set(DOWNLOAD_RETRANS_RATE, PERSIST_VALUE, 500);
-    b.set(MAX_CONCURRENT_STREAMS, PERSIST_VALUE, 600);
+    b.set(Settings.MAX_HEADER_LIST_SIZE, 40000);
+    b.set(Settings.INITIAL_WINDOW_SIZE, 50000);
+    b.set(Settings.MAX_CONCURRENT_STREAMS, 60000);
 
     a.merge(b);
-    assertEquals(100, a.getUploadBandwidth(-1));
-    assertEquals(PERSIST_VALUE, a.flags(UPLOAD_BANDWIDTH));
-    assertEquals(400, a.getDownloadBandwidth(-1));
-    assertEquals(0, a.flags(DOWNLOAD_BANDWIDTH));
-    assertEquals(500, a.getDownloadRetransRate(-1));
-    assertEquals(PERSIST_VALUE, a.flags(DOWNLOAD_RETRANS_RATE));
-    assertEquals(600, a.getMaxConcurrentStreams(-1));
-    assertEquals(PERSIST_VALUE, a.flags(MAX_CONCURRENT_STREAMS));
+    assertEquals(10000, a.getHeaderTableSize());
+    assertEquals(40000, a.getMaxHeaderListSize(-1));
+    assertEquals(50000, a.getInitialWindowSize());
+    assertEquals(60000, a.getMaxConcurrentStreams(-1));
   }
 }
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/framed/Spdy3ConnectionTest.java b/okhttp-tests/src/test/java/okhttp3/internal/framed/Spdy3ConnectionTest.java
deleted file mode 100644
index 0cc86462a3..0000000000
--- a/okhttp-tests/src/test/java/okhttp3/internal/framed/Spdy3ConnectionTest.java
+++ /dev/null
@@ -1,1425 +0,0 @@
-/*
- * Copyright (C) 2011 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.internal.framed;
-
-import java.io.IOException;
-import java.io.InterruptedIOException;
-import java.net.Socket;
-import java.util.ArrayList;
-import java.util.Arrays;
-import java.util.List;
-import java.util.Random;
-import java.util.concurrent.CountDownLatch;
-import java.util.concurrent.TimeUnit;
-import java.util.concurrent.atomic.AtomicInteger;
-import okhttp3.internal.Util;
-import okio.AsyncTimeout;
-import okio.Buffer;
-import okio.BufferedSink;
-import okio.ByteString;
-import okio.Okio;
-import okio.Sink;
-import okio.Source;
-import org.junit.After;
-import org.junit.Test;
-
-import static okhttp3.TestUtil.headerEntries;
-import static okhttp3.internal.framed.ErrorCode.CANCEL;
-import static okhttp3.internal.framed.ErrorCode.INTERNAL_ERROR;
-import static okhttp3.internal.framed.ErrorCode.INVALID_STREAM;
-import static okhttp3.internal.framed.ErrorCode.PROTOCOL_ERROR;
-import static okhttp3.internal.framed.ErrorCode.REFUSED_STREAM;
-import static okhttp3.internal.framed.ErrorCode.STREAM_IN_USE;
-import static okhttp3.internal.framed.Settings.DEFAULT_INITIAL_WINDOW_SIZE;
-import static okhttp3.internal.framed.Settings.DOWNLOAD_BANDWIDTH;
-import static okhttp3.internal.framed.Settings.DOWNLOAD_RETRANS_RATE;
-import static okhttp3.internal.framed.Settings.INITIAL_WINDOW_SIZE;
-import static okhttp3.internal.framed.Settings.MAX_CONCURRENT_STREAMS;
-import static okhttp3.internal.framed.Settings.PERSIST_VALUE;
-import static okhttp3.internal.framed.Settings.UPLOAD_BANDWIDTH;
-import static okhttp3.internal.framed.Spdy3.TYPE_DATA;
-import static okhttp3.internal.framed.Spdy3.TYPE_GOAWAY;
-import static okhttp3.internal.framed.Spdy3.TYPE_HEADERS;
-import static okhttp3.internal.framed.Spdy3.TYPE_PING;
-import static okhttp3.internal.framed.Spdy3.TYPE_RST_STREAM;
-import static okhttp3.internal.framed.Spdy3.TYPE_WINDOW_UPDATE;
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertFalse;
-import static org.junit.Assert.assertTrue;
-import static org.junit.Assert.fail;
-
-public final class Spdy3ConnectionTest {
-  private static final Variant SPDY3 = new Spdy3();
-  private final MockSpdyPeer peer = new MockSpdyPeer();
-
-  @After public void tearDown() throws Exception {
-    peer.close();
-  }
-
-  @Test public void clientCreatesStreamAndServerReplies() throws Exception {
-    // write the mocking script
-    peer.acceptFrame(); // SYN_STREAM
-    peer.sendFrame()
-        .synReply(false, 1, headerEntries("a", "android"));
-    peer.sendFrame().data(true, 1, new Buffer().writeUtf8("robot"), 5);
-    peer.acceptFrame(); // DATA
-    peer.play();
-
-    // play it back
-    FramedConnection connection = connection(peer, SPDY3);
-    FramedStream stream = connection.newStream(headerEntries("b", "banana"), true, true);
-    assertEquals(headerEntries("a", "android"), stream.getResponseHeaders());
-    assertStreamData("robot", stream.getSource());
-    BufferedSink out = Okio.buffer(stream.getSink());
-    out.writeUtf8("c3po");
-    out.close();
-    assertEquals(0, connection.openStreamCount());
-
-    // verify the peer received what was expected
-    MockSpdyPeer.InFrame synStream = peer.takeFrame();
-    assertEquals(TYPE_HEADERS, synStream.type);
-    assertEquals(HeadersMode.SPDY_SYN_STREAM, synStream.headersMode);
-    assertFalse(synStream.inFinished);
-    assertFalse(synStream.outFinished);
-    assertEquals(1, synStream.streamId);
-    assertEquals(0, synStream.associatedStreamId);
-    assertEquals(headerEntries("b", "banana"), synStream.headerBlock);
-    MockSpdyPeer.InFrame requestData = peer.takeFrame();
-    assertTrue(Arrays.equals("c3po".getBytes("UTF-8"), requestData.data));
-  }
-
-  @Test public void headersOnlyStreamIsClosedAfterReplyHeaders() throws Exception {
-    peer.acceptFrame(); // SYN_STREAM
-    peer.sendFrame().synReply(false, 1, headerEntries("b", "banana"));
-    peer.acceptFrame(); // PING
-    peer.sendFrame().ping(true, 1, 0);
-    peer.play();
-
-    FramedConnection connection = connection(peer, SPDY3);
-    FramedStream stream = connection.newStream(headerEntries("a", "android"), false, false);
-    assertEquals(headerEntries("b", "banana"), stream.getResponseHeaders());
-    connection.ping().roundTripTime(); // Ensure that inFinished has been received.
-    assertEquals(0, connection.openStreamCount());
-  }
-
-  @Test public void clientCreatesStreamAndServerRepliesWithFin() throws Exception {
-    // write the mocking script
-    peer.acceptFrame(); // SYN_STREAM
-    peer.acceptFrame(); // PING
-    peer.sendFrame().synReply(true, 1, headerEntries("a", "android"));
-    peer.sendFrame().ping(true, 1, 0);
-    peer.play();
-
-    // play it back
-    FramedConnection connection = connection(peer, SPDY3);
-    connection.newStream(headerEntries("b", "banana"), false, true);
-    assertEquals(1, connection.openStreamCount());
-    connection.ping().roundTripTime(); // Ensure that the SYN_REPLY has been received.
-    assertEquals(0, connection.openStreamCount());
-
-    // verify the peer received what was expected
-    MockSpdyPeer.InFrame synStream = peer.takeFrame();
-    assertEquals(TYPE_HEADERS, synStream.type);
-    assertEquals(HeadersMode.SPDY_SYN_STREAM, synStream.headersMode);
-    MockSpdyPeer.InFrame ping = peer.takeFrame();
-    assertEquals(TYPE_PING, ping.type);
-  }
-
-  @Test public void serverCreatesStreamAndClientReplies() throws Exception {
-    final List<Header> pushHeaders = headerEntries(
-        ":scheme", "https",
-        ":host", "localhost:8888",
-        ":method", "GET",
-        ":path", "/index.html",
-        ":status", "200",
-        ":version", "HTTP/1.1",
-        "content-type", "text/html");
-    // write the mocking script
-    peer.sendFrame().synStream(false, false, 2, 0, pushHeaders);
-    peer.acceptFrame(); // SYN_REPLY
-    peer.play();
-
-    // play it back
-    final AtomicInteger receiveCount = new AtomicInteger();
-    FramedConnection.Listener handler = new FramedConnection.Listener() {
-      @Override public void onStream(FramedStream stream) throws IOException {
-        receiveCount.incrementAndGet();
-        assertEquals(pushHeaders, stream.getRequestHeaders());
-        assertEquals(null, stream.getErrorCode());
-        stream.reply(headerEntries("b", "banana"), true);
-      }
-    };
-    FramedConnection connection = new FramedConnection.Builder(true)
-        .socket(peer.openSocket())
-        .listener(handler)
-        .build();
-    connection.start(false);
-
-    // verify the peer received what was expected
-    MockSpdyPeer.InFrame reply = peer.takeFrame();
-    assertEquals(TYPE_HEADERS, reply.type);
-    assertEquals(HeadersMode.SPDY_REPLY, reply.headersMode);
-    assertFalse(reply.inFinished);
-    assertEquals(2, reply.streamId);
-    assertEquals(headerEntries("b", "banana"), reply.headerBlock);
-    assertEquals(1, receiveCount.get());
-  }
-
-  @Test public void replyWithNoData() throws Exception {
-    // write the mocking script
-    peer.sendFrame().synStream(false, false, 2, 0, headerEntries("a", "android"));
-    peer.acceptFrame(); // SYN_REPLY
-    peer.play();
-
-    // play it back
-    final AtomicInteger receiveCount = new AtomicInteger();
-    FramedConnection.Listener listener = new FramedConnection.Listener() {
-      @Override public void onStream(FramedStream stream) throws IOException {
-        stream.reply(headerEntries("b", "banana"), false);
-        receiveCount.incrementAndGet();
-      }
-    };
-
-    FramedConnection connection = connectionBuilder(peer, SPDY3)
-        .listener(listener)
-        .build();
-    connection.start(false);
-
-    // verify the peer received what was expected
-    MockSpdyPeer.InFrame reply = peer.takeFrame();
-    assertEquals(TYPE_HEADERS, reply.type);
-    assertTrue(reply.inFinished);
-    assertEquals(headerEntries("b", "banana"), reply.headerBlock);
-    assertEquals(1, receiveCount.get());
-    assertEquals(HeadersMode.SPDY_REPLY, reply.headersMode);
-  }
-
-  @Test public void serverPingsClient() throws Exception {
-    // write the mocking script
-    peer.sendFrame().ping(false, 2, 0);
-    peer.acceptFrame(); // PING
-    peer.play();
-
-    // play it back
-    connection(peer, SPDY3);
-
-    // verify the peer received what was expected
-    MockSpdyPeer.InFrame ping = peer.takeFrame();
-    assertEquals(0, ping.streamId);
-    assertEquals(2, ping.payload1);
-    assertEquals(0, ping.payload2); // ignored in spdy!
-    assertTrue(ping.ack);
-  }
-
-  @Test public void clientPingsServer() throws Exception {
-    // write the mocking script
-    peer.acceptFrame(); // PING
-    peer.sendFrame().ping(true, 1, 5); // payload2 ignored in spdy!
-    peer.play();
-
-    // play it back
-    FramedConnection connection = connection(peer, SPDY3);
-    Ping ping = connection.ping();
-    assertTrue(ping.roundTripTime() > 0);
-    assertTrue(ping.roundTripTime() < TimeUnit.SECONDS.toNanos(1));
-
-    // verify the peer received what was expected
-    MockSpdyPeer.InFrame pingFrame = peer.takeFrame();
-    assertEquals(TYPE_PING, pingFrame.type);
-    assertEquals(1, pingFrame.payload1);
-    assertEquals(0, pingFrame.payload2);
-    assertFalse(pingFrame.ack);
-  }
-
-  @Test public void unexpectedPingIsNotReturned() throws Exception {
-    // write the mocking script
-    peer.sendFrame().ping(false, 2, 0);
-    peer.acceptFrame(); // PING
-    peer.sendFrame().ping(true, 3, 0); // This ping will not be returned.
-    peer.sendFrame().ping(false, 4, 0);
-    peer.acceptFrame(); // PING
-    peer.play();
-
-    // play it back
-    connection(peer, SPDY3);
-
-    // verify the peer received what was expected
-    MockSpdyPeer.InFrame ping2 = peer.takeFrame();
-    assertEquals(2, ping2.payload1);
-    MockSpdyPeer.InFrame ping4 = peer.takeFrame();
-    assertEquals(4, ping4.payload1);
-  }
-
-  @Test public void serverSendsSettingsToClient() throws Exception {
-    // write the mocking script
-    final Settings settings = new Settings();
-    settings.set(MAX_CONCURRENT_STREAMS, PERSIST_VALUE, 10);
-    peer.sendFrame().settings(settings);
-    peer.sendFrame().ping(false, 2, 0);
-    peer.acceptFrame(); // PING
-    peer.play();
-
-    // play it back
-    final CountDownLatch maxConcurrentStreamsUpdated = new CountDownLatch(1);
-    final AtomicInteger maxConcurrentStreams = new AtomicInteger();
-    FramedConnection.Listener listener = new FramedConnection.Listener() {
-      @Override public void onStream(FramedStream stream) throws IOException {
-        throw new AssertionError();
-      }
-
-      @Override public void onSettings(FramedConnection connection) {
-        maxConcurrentStreams.set(connection.maxConcurrentStreams());
-        maxConcurrentStreamsUpdated.countDown();
-      }
-    };
-    FramedConnection connection = connectionBuilder(peer, SPDY3)
-        .listener(listener)
-        .build();
-    connection.start(false);
-
-    peer.takeFrame(); // Guarantees that the peer Settings frame has been processed.
-    synchronized (connection) {
-      assertEquals(10, connection.peerSettings.getMaxConcurrentStreams(-1));
-    }
-    maxConcurrentStreamsUpdated.await();
-    assertEquals(10, maxConcurrentStreams.get());
-  }
-
-  @Test public void multipleSettingsFramesAreMerged() throws Exception {
-    // write the mocking script
-    Settings settings1 = new Settings();
-    settings1.set(UPLOAD_BANDWIDTH, PERSIST_VALUE, 100);
-    settings1.set(DOWNLOAD_BANDWIDTH, PERSIST_VALUE, 200);
-    settings1.set(DOWNLOAD_RETRANS_RATE, 0, 300);
-    peer.sendFrame().settings(settings1);
-    Settings settings2 = new Settings();
-    settings2.set(DOWNLOAD_BANDWIDTH, 0, 400);
-    settings2.set(DOWNLOAD_RETRANS_RATE, PERSIST_VALUE, 500);
-    settings2.set(MAX_CONCURRENT_STREAMS, PERSIST_VALUE, 600);
-    peer.sendFrame().settings(settings2);
-    peer.sendFrame().ping(false, 2, 0);
-    peer.acceptFrame();
-    peer.play();
-
-    // play it back
-    FramedConnection connection = connection(peer, SPDY3);
-
-    peer.takeFrame(); // Guarantees that the Settings frame has been processed.
-    synchronized (connection) {
-      assertEquals(100, connection.peerSettings.getUploadBandwidth(-1));
-      assertEquals(PERSIST_VALUE, connection.peerSettings.flags(UPLOAD_BANDWIDTH));
-      assertEquals(400, connection.peerSettings.getDownloadBandwidth(-1));
-      assertEquals(0, connection.peerSettings.flags(DOWNLOAD_BANDWIDTH));
-      assertEquals(500, connection.peerSettings.getDownloadRetransRate(-1));
-      assertEquals(PERSIST_VALUE, connection.peerSettings.flags(DOWNLOAD_RETRANS_RATE));
-      assertEquals(600, connection.peerSettings.getMaxConcurrentStreams(-1));
-      assertEquals(PERSIST_VALUE, connection.peerSettings.flags(MAX_CONCURRENT_STREAMS));
-    }
-  }
-
-  @Test public void clearSettingsBeforeMerge() throws Exception {
-    // write the mocking script
-    Settings settings1 = new Settings();
-    settings1.set(UPLOAD_BANDWIDTH, PERSIST_VALUE, 100);
-    settings1.set(DOWNLOAD_BANDWIDTH, PERSIST_VALUE, 200);
-    settings1.set(DOWNLOAD_RETRANS_RATE, 0, 300);
-    peer.sendFrame().settings(settings1);
-    peer.sendFrame().ping(false, 2, 0);
-    peer.acceptFrame();
-    peer.play();
-
-    // play it back
-    FramedConnection connection = connection(peer, SPDY3);
-
-    peer.takeFrame(); // Guarantees that the Settings frame has been processed.
-
-    // fake a settings frame with clear flag set.
-    Settings settings2 = new Settings();
-    settings2.set(MAX_CONCURRENT_STREAMS, PERSIST_VALUE, 600);
-    connection.readerRunnable.settings(true, settings2);
-
-    synchronized (connection) {
-      assertEquals(-1, connection.peerSettings.getUploadBandwidth(-1));
-      assertEquals(-1, connection.peerSettings.getDownloadBandwidth(-1));
-      assertEquals(-1, connection.peerSettings.getDownloadRetransRate(-1));
-      assertEquals(600, connection.peerSettings.getMaxConcurrentStreams(-1));
-    }
-  }
-
-  @Test public void bogusDataFrameDoesNotDisruptConnection() throws Exception {
-    // write the mocking script
-    peer.sendFrame().data(true, 41, new Buffer().writeUtf8("bogus"), 5);
-    peer.acceptFrame(); // RST_STREAM
-    peer.sendFrame().ping(false, 2, 0);
-    peer.acceptFrame(); // PING
-    peer.play();
-
-    // play it back
-    connection(peer, SPDY3);
-
-    // verify the peer received what was expected
-    MockSpdyPeer.InFrame rstStream = peer.takeFrame();
-    assertEquals(TYPE_RST_STREAM, rstStream.type);
-    assertEquals(41, rstStream.streamId);
-    assertEquals(INVALID_STREAM, rstStream.errorCode);
-    MockSpdyPeer.InFrame ping = peer.takeFrame();
-    assertEquals(2, ping.payload1);
-  }
-
-  @Test public void bogusReplyFrameDoesNotDisruptConnection() throws Exception {
-    // write the mocking script
-    peer.sendFrame().synReply(false, 41, headerEntries("a", "android"));
-    peer.acceptFrame(); // RST_STREAM
-    peer.sendFrame().ping(false, 2, 0);
-    peer.acceptFrame(); // PING
-    peer.play();
-
-    // play it back
-    connection(peer, SPDY3);
-
-    // verify the peer received what was expected
-    MockSpdyPeer.InFrame rstStream = peer.takeFrame();
-    assertEquals(TYPE_RST_STREAM, rstStream.type);
-    assertEquals(41, rstStream.streamId);
-    assertEquals(INVALID_STREAM, rstStream.errorCode);
-    MockSpdyPeer.InFrame ping = peer.takeFrame();
-    assertEquals(2, ping.payload1);
-  }
-
-  @Test public void clientClosesClientOutputStream() throws Exception {
-    // write the mocking script
-    peer.acceptFrame(); // SYN_STREAM
-    peer.sendFrame().synReply(false, 1, headerEntries("b", "banana"));
-    peer.acceptFrame(); // TYPE_DATA
-    peer.acceptFrame(); // TYPE_DATA with FLAG_FIN
-    peer.acceptFrame(); // PING
-    peer.sendFrame().ping(true, 1, 0);
-    peer.play();
-
-    // play it back
-    FramedConnection connection = connection(peer, SPDY3);
-    FramedStream stream = connection.newStream(headerEntries("a", "android"), true, false);
-    BufferedSink out = Okio.buffer(stream.getSink());
-    out.writeUtf8("square");
-    out.flush();
-    assertEquals(1, connection.openStreamCount());
-    out.close();
-    try {
-      out.writeUtf8("round");
-      fail();
-    } catch (Exception expected) {
-      assertEquals("closed", expected.getMessage());
-    }
-    connection.ping().roundTripTime(); // Ensure that the SYN_REPLY has been received.
-    assertEquals(0, connection.openStreamCount());
-
-    // verify the peer received what was expected
-    MockSpdyPeer.InFrame synStream = peer.takeFrame();
-    assertEquals(TYPE_HEADERS, synStream.type);
-    assertEquals(HeadersMode.SPDY_SYN_STREAM, synStream.headersMode);
-    assertFalse(synStream.inFinished);
-    assertTrue(synStream.outFinished);
-    MockSpdyPeer.InFrame data = peer.takeFrame();
-    assertEquals(TYPE_DATA, data.type);
-    assertFalse(data.inFinished);
-    assertTrue(Arrays.equals("square".getBytes("UTF-8"), data.data));
-    MockSpdyPeer.InFrame fin = peer.takeFrame();
-    assertEquals(TYPE_DATA, fin.type);
-    assertTrue(fin.inFinished);
-    MockSpdyPeer.InFrame ping = peer.takeFrame();
-    assertEquals(TYPE_PING, ping.type);
-    assertEquals(1, ping.payload1);
-  }
-
-  @Test public void serverClosesClientOutputStream() throws Exception {
-    // write the mocking script
-    peer.acceptFrame(); // SYN_STREAM
-    peer.sendFrame().rstStream(1, CANCEL);
-    peer.acceptFrame(); // PING
-    peer.sendFrame().ping(true, 1, 0);
-    peer.play();
-
-    // play it back
-    FramedConnection connection = connection(peer, SPDY3);
-    FramedStream stream = connection.newStream(headerEntries("a", "android"), true, true);
-    BufferedSink out = Okio.buffer(stream.getSink());
-    connection.ping().roundTripTime(); // Ensure that the RST_CANCEL has been received.
-    try {
-      out.writeUtf8("square");
-      out.flush();
-      fail();
-    } catch (IOException expected) {
-      assertEquals("stream was reset: CANCEL", expected.getMessage());
-    }
-    try {
-      out.close();
-      fail();
-    } catch (IOException expected) {
-      // Close throws because buffered data wasn't flushed.
-    }
-    assertEquals(0, connection.openStreamCount());
-
-    // verify the peer received what was expected
-    MockSpdyPeer.InFrame synStream = peer.takeFrame();
-    assertEquals(TYPE_HEADERS, synStream.type);
-    assertEquals(HeadersMode.SPDY_SYN_STREAM, synStream.headersMode);
-    assertFalse(synStream.inFinished);
-    assertFalse(synStream.outFinished);
-    MockSpdyPeer.InFrame ping = peer.takeFrame();
-    assertEquals(TYPE_PING, ping.type);
-    assertEquals(1, ping.payload1);
-  }
-
-  /**
-   * Test that the client sends a RST_STREAM if doing so won't disrupt the output stream.
-   */
-  @Test public void clientClosesClientInputStream() throws Exception {
-    // write the mocking script
-    peer.acceptFrame(); // SYN_STREAM
-    peer.acceptFrame(); // RST_STREAM
-    peer.play();
-
-    // play it back
-    FramedConnection connection = connection(peer, SPDY3);
-    FramedStream stream = connection.newStream(headerEntries("a", "android"), false, true);
-    Source in = stream.getSource();
-    BufferedSink out = Okio.buffer(stream.getSink());
-    in.close();
-    try {
-      in.read(new Buffer(), 1);
-      fail();
-    } catch (IOException expected) {
-      assertEquals("stream closed", expected.getMessage());
-    }
-    try {
-      out.writeUtf8("a");
-      out.flush();
-      fail();
-    } catch (IOException expected) {
-      assertEquals("stream finished", expected.getMessage());
-    }
-    assertEquals(0, connection.openStreamCount());
-
-    // verify the peer received what was expected
-    MockSpdyPeer.InFrame synStream = peer.takeFrame();
-    assertEquals(TYPE_HEADERS, synStream.type);
-    assertEquals(HeadersMode.SPDY_SYN_STREAM, synStream.headersMode);
-    assertTrue(synStream.inFinished);
-    assertFalse(synStream.outFinished);
-    MockSpdyPeer.InFrame rstStream = peer.takeFrame();
-    assertEquals(TYPE_RST_STREAM, rstStream.type);
-    assertEquals(CANCEL, rstStream.errorCode);
-  }
-
-  /**
-   * Test that the client doesn't send a RST_STREAM if doing so will disrupt the output stream.
-   */
-  @Test public void clientClosesClientInputStreamIfOutputStreamIsClosed() throws Exception {
-    // write the mocking script
-    peer.acceptFrame(); // SYN_STREAM
-    peer.acceptFrame(); // DATA
-    peer.acceptFrame(); // DATA with FLAG_FIN
-    peer.acceptFrame(); // RST_STREAM
-    peer.play();
-
-    // play it back
-    FramedConnection connection = connection(peer, SPDY3);
-    FramedStream stream = connection.newStream(headerEntries("a", "android"), true, true);
-    Source source = stream.getSource();
-    BufferedSink out = Okio.buffer(stream.getSink());
-    source.close();
-    try {
-      source.read(new Buffer(), 1);
-      fail();
-    } catch (IOException expected) {
-      assertEquals("stream closed", expected.getMessage());
-    }
-    out.writeUtf8("square");
-    out.flush();
-    out.close();
-    assertEquals(0, connection.openStreamCount());
-
-    // verify the peer received what was expected
-    MockSpdyPeer.InFrame synStream = peer.takeFrame();
-    assertEquals(TYPE_HEADERS, synStream.type);
-    assertEquals(HeadersMode.SPDY_SYN_STREAM, synStream.headersMode);
-    assertFalse(synStream.inFinished);
-    assertFalse(synStream.outFinished);
-    MockSpdyPeer.InFrame data = peer.takeFrame();
-    assertEquals(TYPE_DATA, data.type);
-    assertTrue(Arrays.equals("square".getBytes("UTF-8"), data.data));
-    MockSpdyPeer.InFrame fin = peer.takeFrame();
-    assertEquals(TYPE_DATA, fin.type);
-    assertTrue(fin.inFinished);
-    assertFalse(fin.outFinished);
-    MockSpdyPeer.InFrame rstStream = peer.takeFrame();
-    assertEquals(TYPE_RST_STREAM, rstStream.type);
-    assertEquals(CANCEL, rstStream.errorCode);
-  }
-
-  @Test public void serverClosesClientInputStream() throws Exception {
-    // write the mocking script
-    peer.acceptFrame(); // SYN_STREAM
-    peer.sendFrame().synReply(false, 1, headerEntries("b", "banana"));
-    peer.sendFrame().data(true, 1, new Buffer().writeUtf8("square"), 6);
-    peer.acceptFrame(); // PING
-    peer.sendFrame().ping(true, 1, 0);
-    peer.play();
-
-    // play it back
-    FramedConnection connection = connection(peer, SPDY3);
-    FramedStream stream = connection.newStream(headerEntries("a", "android"), false, true);
-    Source source = stream.getSource();
-    assertStreamData("square", source);
-    connection.ping().roundTripTime(); // Ensure that inFinished has been received.
-    assertEquals(0, connection.openStreamCount());
-
-    // verify the peer received what was expected
-    MockSpdyPeer.InFrame synStream = peer.takeFrame();
-    assertEquals(TYPE_HEADERS, synStream.type);
-    assertEquals(HeadersMode.SPDY_SYN_STREAM, synStream.headersMode);
-    assertTrue(synStream.inFinished);
-    assertFalse(synStream.outFinished);
-  }
-
-  @Test public void remoteDoubleSynReply() throws Exception {
-    // write the mocking script
-    peer.acceptFrame(); // SYN_STREAM
-    peer.sendFrame().synReply(false, 1, headerEntries("a", "android"));
-    peer.acceptFrame(); // PING
-    peer.sendFrame().synReply(false, 1, headerEntries("b", "banana"));
-    peer.sendFrame().ping(true, 1, 0);
-    peer.acceptFrame(); // RST_STREAM
-    peer.play();
-
-    // play it back
-    FramedConnection connection = connection(peer, SPDY3);
-    FramedStream stream = connection.newStream(headerEntries("c", "cola"), true, true);
-    assertEquals(headerEntries("a", "android"), stream.getResponseHeaders());
-    connection.ping().roundTripTime(); // Ensure that the 2nd SYN REPLY has been received.
-    try {
-      stream.getSource().read(new Buffer(), 1);
-      fail();
-    } catch (IOException expected) {
-      assertEquals("stream was reset: STREAM_IN_USE", expected.getMessage());
-    }
-
-    // verify the peer received what was expected
-    MockSpdyPeer.InFrame synStream = peer.takeFrame();
-    assertEquals(TYPE_HEADERS, synStream.type);
-    assertEquals(HeadersMode.SPDY_SYN_STREAM, synStream.headersMode);
-    MockSpdyPeer.InFrame ping = peer.takeFrame();
-    assertEquals(TYPE_PING, ping.type);
-    MockSpdyPeer.InFrame rstStream = peer.takeFrame();
-    assertEquals(TYPE_RST_STREAM, rstStream.type);
-    assertEquals(1, rstStream.streamId);
-    assertEquals(STREAM_IN_USE, rstStream.errorCode);
-  }
-
-  @Test public void remoteDoubleSynStream() throws Exception {
-    // write the mocking script
-    peer.sendFrame().synStream(false, false, 2, 0, headerEntries("a", "android"));
-    peer.acceptFrame(); // SYN_REPLY
-    peer.sendFrame().synStream(false, false, 2, 0, headerEntries("b", "banana"));
-    peer.acceptFrame(); // RST_STREAM
-    peer.play();
-
-    // play it back
-    final AtomicInteger receiveCount = new AtomicInteger();
-    FramedConnection.Listener listener = new FramedConnection.Listener() {
-      @Override public void onStream(FramedStream stream) throws IOException {
-        receiveCount.incrementAndGet();
-        assertEquals(headerEntries("a", "android"), stream.getRequestHeaders());
-        assertEquals(null, stream.getErrorCode());
-        stream.reply(headerEntries("c", "cola"), true);
-      }
-    };
-    FramedConnection connection = new FramedConnection.Builder(true)
-        .socket(peer.openSocket())
-        .listener(listener)
-        .build();
-    connection.start(false);
-
-    // verify the peer received what was expected
-    MockSpdyPeer.InFrame reply = peer.takeFrame();
-    assertEquals(TYPE_HEADERS, reply.type);
-    assertEquals(HeadersMode.SPDY_REPLY, reply.headersMode);
-    MockSpdyPeer.InFrame rstStream = peer.takeFrame();
-    assertEquals(TYPE_RST_STREAM, rstStream.type);
-    assertEquals(2, rstStream.streamId);
-    assertEquals(PROTOCOL_ERROR, rstStream.errorCode);
-    assertEquals(1, receiveCount.intValue());
-  }
-
-  @Test public void remoteSendsDataAfterInFinished() throws Exception {
-    // write the mocking script
-    peer.acceptFrame(); // SYN_STREAM
-    peer.sendFrame().synReply(false, 1, headerEntries("a", "android"));
-    peer.sendFrame().data(true, 1, new Buffer().writeUtf8("robot"), 5);
-    peer.sendFrame().data(true, 1, new Buffer().writeUtf8("c3po"), 4); // Ignored.
-    peer.sendFrame().ping(false, 2, 0); // Ping just to make sure the stream was fastforwarded.
-    peer.acceptFrame(); // PING
-    peer.play();
-
-    // play it back
-    FramedConnection connection = connection(peer, SPDY3);
-    FramedStream stream = connection.newStream(headerEntries("b", "banana"), true, true);
-    assertEquals(headerEntries("a", "android"), stream.getResponseHeaders());
-    assertStreamData("robot", stream.getSource());
-
-    // verify the peer received what was expected
-    MockSpdyPeer.InFrame synStream = peer.takeFrame();
-    assertEquals(TYPE_HEADERS, synStream.type);
-    assertEquals(HeadersMode.SPDY_SYN_STREAM, synStream.headersMode);
-    MockSpdyPeer.InFrame ping = peer.takeFrame();
-    assertEquals(TYPE_PING, ping.type);
-    assertEquals(2, ping.payload1);
-  }
-
-  @Test public void clientDoesNotLimitFlowControl() throws Exception {
-    int dataLength = 64 * 1024 + 1;
-    // write the mocking script
-    peer.acceptFrame(); // SYN_STREAM
-    peer.sendFrame().synReply(false, 1, headerEntries("b", "banana"));
-    peer.sendFrame().data(false, 1, new Buffer().write(new byte[dataLength]), dataLength);
-    peer.sendFrame().ping(false, 2, 0); // Ping just to make sure the stream was fastforwarded.
-    peer.acceptFrame(); // PING
-    peer.play();
-
-    // play it back
-    FramedConnection connection = connection(peer, SPDY3);
-    FramedStream stream = connection.newStream(headerEntries("a", "android"), true, true);
-    assertEquals(headerEntries("b", "banana"), stream.getResponseHeaders());
-
-    // verify the peer received what was expected
-    MockSpdyPeer.InFrame synStream = peer.takeFrame();
-    assertEquals(TYPE_HEADERS, synStream.type);
-    assertEquals(HeadersMode.SPDY_SYN_STREAM, synStream.headersMode);
-    MockSpdyPeer.InFrame ping = peer.takeFrame();
-    assertEquals(TYPE_PING, ping.type);
-    assertEquals(2, ping.payload1);
-  }
-
-  @Test public void remoteSendsRefusedStreamBeforeReplyHeaders() throws Exception {
-    // write the mocking script
-    peer.acceptFrame(); // SYN_STREAM
-    peer.sendFrame().rstStream(1, REFUSED_STREAM);
-    peer.sendFrame().ping(false, 2, 0);
-    peer.acceptFrame(); // PING
-    peer.play();
-
-    // play it back
-    FramedConnection connection = connection(peer, SPDY3);
-    FramedStream stream = connection.newStream(headerEntries("a", "android"), true, true);
-    try {
-      stream.getResponseHeaders();
-      fail();
-    } catch (IOException expected) {
-      assertEquals("stream was reset: REFUSED_STREAM", expected.getMessage());
-    }
-    assertEquals(0, connection.openStreamCount());
-
-    // verify the peer received what was expected
-    MockSpdyPeer.InFrame synStream = peer.takeFrame();
-    assertEquals(TYPE_HEADERS, synStream.type);
-    assertEquals(HeadersMode.SPDY_SYN_STREAM, synStream.headersMode);
-    MockSpdyPeer.InFrame ping = peer.takeFrame();
-    assertEquals(TYPE_PING, ping.type);
-    assertEquals(2, ping.payload1);
-  }
-
-  @Test public void receiveGoAway() throws Exception {
-    peer.setVariantAndClient(SPDY3, false);
-
-    // write the mocking script
-    peer.acceptFrame(); // SYN_STREAM 1
-    peer.acceptFrame(); // SYN_STREAM 3
-    peer.acceptFrame(); // PING.
-    peer.sendFrame().goAway(1, PROTOCOL_ERROR, Util.EMPTY_BYTE_ARRAY);
-    peer.sendFrame().ping(true, 1, 0);
-    peer.acceptFrame(); // DATA STREAM 1
-    peer.play();
-
-    // play it back
-    FramedConnection connection = connection(peer, SPDY3);
-    FramedStream stream1 = connection.newStream(headerEntries("a", "android"), true, true);
-    FramedStream stream2 = connection.newStream(headerEntries("b", "banana"), true, true);
-    connection.ping().roundTripTime(); // Ensure the GO_AWAY that resets stream2 has been received.
-    BufferedSink sink1 = Okio.buffer(stream1.getSink());
-    BufferedSink sink2 = Okio.buffer(stream2.getSink());
-    sink1.writeUtf8("abc");
-    try {
-      sink2.writeUtf8("abc");
-      sink2.flush();
-      fail();
-    } catch (IOException expected) {
-      assertEquals("stream was reset: REFUSED_STREAM", expected.getMessage());
-    }
-    sink1.writeUtf8("def");
-    sink1.close();
-    try {
-      connection.newStream(headerEntries("c", "cola"), true, true);
-      fail();
-    } catch (IOException expected) {
-      assertEquals("shutdown", expected.getMessage());
-    }
-    assertTrue(stream1.isOpen());
-    assertFalse(stream2.isOpen());
-    assertEquals(1, connection.openStreamCount());
-
-    // verify the peer received what was expected
-    MockSpdyPeer.InFrame synStream1 = peer.takeFrame();
-    assertEquals(TYPE_HEADERS, synStream1.type);
-    MockSpdyPeer.InFrame synStream2 = peer.takeFrame();
-    assertEquals(TYPE_HEADERS, synStream2.type);
-    MockSpdyPeer.InFrame ping = peer.takeFrame();
-    assertEquals(TYPE_PING, ping.type);
-    MockSpdyPeer.InFrame data1 = peer.takeFrame();
-    assertEquals(TYPE_DATA, data1.type);
-    assertEquals(1, data1.streamId);
-    assertTrue(Arrays.equals("abcdef".getBytes("UTF-8"), data1.data));
-  }
-
-  @Test public void sendGoAway() throws Exception {
-    // write the mocking script
-    peer.acceptFrame(); // SYN_STREAM 1
-    peer.acceptFrame(); // GOAWAY
-    peer.acceptFrame(); // PING
-    peer.sendFrame().synStream(false, false, 2, 0, headerEntries("b", "b")); // Should be ignored!
-    peer.sendFrame().ping(true, 1, 0);
-    peer.play();
-
-    // play it back
-    FramedConnection connection = connection(peer, SPDY3);
-    connection.newStream(headerEntries("a", "android"), true, true);
-    Ping ping = connection.ping();
-    connection.shutdown(PROTOCOL_ERROR);
-    assertEquals(1, connection.openStreamCount());
-    ping.roundTripTime(); // Prevent the peer from exiting prematurely.
-
-    // verify the peer received what was expected
-    MockSpdyPeer.InFrame synStream1 = peer.takeFrame();
-    assertEquals(TYPE_HEADERS, synStream1.type);
-    MockSpdyPeer.InFrame pingFrame = peer.takeFrame();
-    assertEquals(TYPE_PING, pingFrame.type);
-    MockSpdyPeer.InFrame goaway = peer.takeFrame();
-    assertEquals(TYPE_GOAWAY, goaway.type);
-    assertEquals(0, goaway.streamId);
-    assertEquals(PROTOCOL_ERROR, goaway.errorCode);
-  }
-
-  @Test public void noPingsAfterShutdown() throws Exception {
-    // write the mocking script
-    peer.acceptFrame(); // GOAWAY
-    peer.play();
-
-    // play it back
-    FramedConnection connection = connection(peer, SPDY3);
-    connection.shutdown(INTERNAL_ERROR);
-    try {
-      connection.ping();
-      fail();
-    } catch (IOException expected) {
-      assertEquals("shutdown", expected.getMessage());
-    }
-
-    // verify the peer received what was expected
-    MockSpdyPeer.InFrame goaway = peer.takeFrame();
-    assertEquals(TYPE_GOAWAY, goaway.type);
-    assertEquals(INTERNAL_ERROR, goaway.errorCode);
-  }
-
-  @Test public void close() throws Exception {
-    // write the mocking script
-    peer.acceptFrame(); // SYN_STREAM
-    peer.acceptFrame(); // GOAWAY
-    peer.acceptFrame(); // RST_STREAM
-    peer.play();
-
-    // play it back
-    FramedConnection connection = connection(peer, SPDY3);
-    FramedStream stream = connection.newStream(headerEntries("a", "android"), true, true);
-    assertEquals(1, connection.openStreamCount());
-    connection.close();
-    assertEquals(0, connection.openStreamCount());
-    try {
-      connection.newStream(headerEntries("b", "banana"), true, true);
-      fail();
-    } catch (IOException expected) {
-      assertEquals("shutdown", expected.getMessage());
-    }
-    BufferedSink sink = Okio.buffer(stream.getSink());
-    try {
-      sink.writeByte(0);
-      sink.flush();
-      fail();
-    } catch (IOException expected) {
-      assertEquals("stream was reset: CANCEL", expected.getMessage());
-    }
-    try {
-      stream.getSource().read(new Buffer(), 1);
-      fail();
-    } catch (IOException expected) {
-      assertEquals("stream was reset: CANCEL", expected.getMessage());
-    }
-
-    // verify the peer received what was expected
-    MockSpdyPeer.InFrame synStream = peer.takeFrame();
-    assertEquals(TYPE_HEADERS, synStream.type);
-    assertEquals(HeadersMode.SPDY_SYN_STREAM, synStream.headersMode);
-    MockSpdyPeer.InFrame goaway = peer.takeFrame();
-    assertEquals(TYPE_GOAWAY, goaway.type);
-    MockSpdyPeer.InFrame rstStream = peer.takeFrame();
-    assertEquals(TYPE_RST_STREAM, rstStream.type);
-    assertEquals(1, rstStream.streamId);
-  }
-
-  @Test public void closeCancelsPings() throws Exception {
-    // write the mocking script
-    peer.acceptFrame(); // PING
-    peer.acceptFrame(); // GOAWAY
-    peer.play();
-
-    // play it back
-    FramedConnection connection = connection(peer, SPDY3);
-    Ping ping = connection.ping();
-    connection.close();
-    assertEquals(-1, ping.roundTripTime());
-  }
-
-  @Test public void getResponseHeadersTimesOut() throws Exception {
-    // write the mocking script
-    peer.acceptFrame(); // SYN_STREAM
-    peer.acceptFrame(); // RST_STREAM
-    peer.play();
-
-    // play it back
-    FramedConnection connection = connection(peer, SPDY3);
-    FramedStream stream = connection.newStream(headerEntries("b", "banana"), true, true);
-    stream.readTimeout().timeout(500, TimeUnit.MILLISECONDS);
-    long startNanos = System.nanoTime();
-    try {
-      stream.getResponseHeaders();
-      fail();
-    } catch (InterruptedIOException expected) {
-    }
-    long elapsedNanos = System.nanoTime() - startNanos;
-    awaitWatchdogIdle();
-    assertEquals(500d, TimeUnit.NANOSECONDS.toMillis(elapsedNanos), 200d /* 200ms delta */);
-    assertEquals(0, connection.openStreamCount());
-
-    // verify the peer received what was expected
-    assertEquals(TYPE_HEADERS, peer.takeFrame().type);
-    assertEquals(TYPE_RST_STREAM, peer.takeFrame().type);
-  }
-
-  @Test public void readTimesOut() throws Exception {
-    // write the mocking script
-    peer.acceptFrame(); // SYN_STREAM
-    peer.sendFrame().synReply(false, 1, headerEntries("a", "android"));
-    peer.acceptFrame(); // RST_STREAM
-    peer.play();
-
-    // play it back
-    FramedConnection connection = connection(peer, SPDY3);
-    FramedStream stream = connection.newStream(headerEntries("b", "banana"), true, true);
-    stream.readTimeout().timeout(500, TimeUnit.MILLISECONDS);
-    Source source = stream.getSource();
-    long startNanos = System.nanoTime();
-    try {
-      source.read(new Buffer(), 1);
-      fail();
-    } catch (InterruptedIOException expected) {
-    }
-    long elapsedNanos = System.nanoTime() - startNanos;
-    awaitWatchdogIdle();
-    assertEquals(500d, TimeUnit.NANOSECONDS.toMillis(elapsedNanos), 200d /* 200ms delta */);
-    assertEquals(0, connection.openStreamCount());
-
-    // verify the peer received what was expected
-    assertEquals(TYPE_HEADERS, peer.takeFrame().type);
-    assertEquals(TYPE_RST_STREAM, peer.takeFrame().type);
-  }
-
-  @Test public void writeTimesOutAwaitingStreamWindow() throws Exception {
-    // Set the peer's receive window to 5 bytes!
-    Settings peerSettings = new Settings().set(INITIAL_WINDOW_SIZE, PERSIST_VALUE, 5);
-
-    // write the mocking script
-    peer.sendFrame().settings(peerSettings);
-    peer.acceptFrame(); // PING
-    peer.sendFrame().ping(true, 1, 0);
-    peer.acceptFrame(); // SYN_STREAM
-    peer.sendFrame().synReply(false, 1, headerEntries("a", "android"));
-    peer.acceptFrame(); // DATA
-    peer.acceptFrame(); // RST_STREAM
-    peer.play();
-
-    // play it back
-    FramedConnection connection = connection(peer, SPDY3);
-    connection.ping().roundTripTime(); // Make sure settings have been received.
-    FramedStream stream = connection.newStream(headerEntries("b", "banana"), true, true);
-    Sink sink = stream.getSink();
-    sink.write(new Buffer().writeUtf8("abcde"), 5);
-    stream.writeTimeout().timeout(500, TimeUnit.MILLISECONDS);
-    long startNanos = System.nanoTime();
-    sink.write(new Buffer().writeUtf8("f"), 1);
-    try {
-      sink.flush(); // This will time out waiting on the write window.
-      fail();
-    } catch (InterruptedIOException expected) {
-    }
-    long elapsedNanos = System.nanoTime() - startNanos;
-    awaitWatchdogIdle();
-    assertEquals(500d, TimeUnit.NANOSECONDS.toMillis(elapsedNanos), 200d /* 200ms delta */);
-    assertEquals(0, connection.openStreamCount());
-
-    // verify the peer received what was expected
-    assertEquals(TYPE_PING, peer.takeFrame().type);
-    assertEquals(TYPE_HEADERS, peer.takeFrame().type);
-    assertEquals(TYPE_DATA, peer.takeFrame().type);
-    assertEquals(TYPE_RST_STREAM, peer.takeFrame().type);
-  }
-
-  @Test public void writeTimesOutAwaitingConnectionWindow() throws Exception {
-    // Set the peer's receive window to 5 bytes. Give the stream 5 bytes back, so only the
-    // connection-level window is applicable.
-    Settings peerSettings = new Settings().set(INITIAL_WINDOW_SIZE, PERSIST_VALUE, 5);
-
-    // write the mocking script
-    peer.sendFrame().settings(peerSettings);
-    peer.acceptFrame(); // SYN_STREAM
-    peer.sendFrame().synReply(false, 1, headerEntries("a", "android"));
-    peer.sendFrame().windowUpdate(1, 5);
-    peer.acceptFrame(); // PING
-    peer.sendFrame().ping(true, 1, 0);
-    peer.acceptFrame(); // DATA
-    peer.acceptFrame(); // RST_STREAM
-    peer.play();
-
-    // play it back
-    FramedConnection connection = connection(peer, SPDY3);
-    FramedStream stream = connection.newStream(headerEntries("b", "banana"), true, true);
-    connection.ping().roundTripTime(); // Make sure the window update has been received.
-    Sink sink = stream.getSink();
-    stream.writeTimeout().timeout(500, TimeUnit.MILLISECONDS);
-    sink.write(new Buffer().writeUtf8("abcdef"), 6);
-    long startNanos = System.nanoTime();
-    try {
-      sink.flush(); // This will time out waiting on the write window.
-      fail();
-    } catch (InterruptedIOException expected) {
-    }
-    long elapsedNanos = System.nanoTime() - startNanos;
-    awaitWatchdogIdle();
-    assertEquals(500d, TimeUnit.NANOSECONDS.toMillis(elapsedNanos), 200d /* 200ms delta */);
-    assertEquals(0, connection.openStreamCount());
-
-    // verify the peer received what was expected
-    assertEquals(TYPE_HEADERS, peer.takeFrame().type);
-    assertEquals(TYPE_PING, peer.takeFrame().type);
-    assertEquals(TYPE_DATA, peer.takeFrame().type);
-    assertEquals(TYPE_RST_STREAM, peer.takeFrame().type);
-  }
-
-  @Test public void outgoingWritesAreBatched() throws Exception {
-    // write the mocking script
-    peer.acceptFrame(); // SYN_STREAM
-    peer.sendFrame().synReply(false, 1, headerEntries("a", "android"));
-    peer.acceptFrame(); // DATA
-    peer.play();
-
-    // play it back
-    FramedConnection connection = connection(peer, SPDY3);
-    FramedStream stream = connection.newStream(headerEntries("b", "banana"), true, true);
-
-    // two outgoing writes
-    Sink sink = stream.getSink();
-    sink.write(new Buffer().writeUtf8("abcde"), 5);
-    sink.write(new Buffer().writeUtf8("fghij"), 5);
-    sink.close();
-
-    // verify the peer received one incoming frame
-    assertEquals(TYPE_HEADERS, peer.takeFrame().type);
-    MockSpdyPeer.InFrame data = peer.takeFrame();
-    assertEquals(TYPE_DATA, data.type);
-    assertTrue(Arrays.equals("abcdefghij".getBytes("UTF-8"), data.data));
-    assertTrue(data.inFinished);
-  }
-
-  @Test public void headers() throws Exception {
-    // write the mocking script
-    peer.acceptFrame(); // SYN_STREAM
-    peer.acceptFrame(); // PING
-    peer.sendFrame().synReply(false, 1, headerEntries("a", "android"));
-    peer.sendFrame().headers(1, headerEntries("c", "c3po"));
-    peer.sendFrame().ping(true, 1, 0);
-    peer.play();
-
-    // play it back
-    FramedConnection connection = connection(peer, SPDY3);
-    FramedStream stream = connection.newStream(headerEntries("b", "banana"), true, true);
-    connection.ping().roundTripTime(); // Ensure that the HEADERS has been received.
-    assertEquals(headerEntries("a", "android", "c", "c3po"), stream.getResponseHeaders());
-
-    // verify the peer received what was expected
-    MockSpdyPeer.InFrame synStream = peer.takeFrame();
-    assertEquals(TYPE_HEADERS, synStream.type);
-    assertEquals(HeadersMode.SPDY_SYN_STREAM, synStream.headersMode);
-    MockSpdyPeer.InFrame ping = peer.takeFrame();
-    assertEquals(TYPE_PING, ping.type);
-  }
-
-  @Test public void headersBeforeReply() throws Exception {
-    // write the mocking script
-    peer.acceptFrame(); // SYN_STREAM
-    peer.acceptFrame(); // PING
-    peer.sendFrame().headers(1, headerEntries("c", "c3po"));
-    peer.acceptFrame(); // RST_STREAM
-    peer.sendFrame().ping(true, 1, 0);
-    peer.play();
-
-    // play it back
-    FramedConnection connection = connection(peer, SPDY3);
-    FramedStream stream = connection.newStream(headerEntries("b", "banana"), true, true);
-    connection.ping().roundTripTime(); // Ensure that the HEADERS has been received.
-    try {
-      stream.getResponseHeaders();
-      fail();
-    } catch (IOException expected) {
-      assertEquals("stream was reset: PROTOCOL_ERROR", expected.getMessage());
-    }
-
-    // verify the peer received what was expected
-    MockSpdyPeer.InFrame synStream = peer.takeFrame();
-    assertEquals(TYPE_HEADERS, synStream.type);
-    assertEquals(HeadersMode.SPDY_SYN_STREAM, synStream.headersMode);
-    MockSpdyPeer.InFrame ping = peer.takeFrame();
-    assertEquals(TYPE_PING, ping.type);
-    MockSpdyPeer.InFrame rstStream = peer.takeFrame();
-    assertEquals(TYPE_RST_STREAM, rstStream.type);
-    assertEquals(PROTOCOL_ERROR, rstStream.errorCode);
-  }
-
-  @Test public void readSendsWindowUpdate() throws Exception {
-    peer.setVariantAndClient(SPDY3, false);
-
-    int windowSize = 100;
-    int windowUpdateThreshold = 50;
-
-    // Write the mocking script.
-    peer.acceptFrame(); // SYN_STREAM
-    peer.sendFrame().synReply(false, 1, headerEntries("a", "android"));
-    for (int i = 0; i < 3; i++) {
-      // Send frames of summing to size 50, which is windowUpdateThreshold.
-      peer.sendFrame().data(false, 1, data(24), 24);
-      peer.sendFrame().data(false, 1, data(25), 25);
-      peer.sendFrame().data(false, 1, data(1), 1);
-      peer.acceptFrame(); // connection WINDOW UPDATE
-      peer.acceptFrame(); // stream WINDOW UPDATE
-    }
-    peer.sendFrame().data(true, 1, data(0), 0);
-    peer.play();
-
-    // Play it back.
-    FramedConnection connection = connection(peer, SPDY3);
-    connection.okHttpSettings.set(INITIAL_WINDOW_SIZE, 0, windowSize);
-    FramedStream stream = connection.newStream(headerEntries("b", "banana"), false, true);
-    assertEquals(0, stream.unacknowledgedBytesRead);
-    assertEquals(headerEntries("a", "android"), stream.getResponseHeaders());
-    Source in = stream.getSource();
-    Buffer buffer = new Buffer();
-    buffer.writeAll(in);
-    assertEquals(-1, in.read(buffer, 1));
-    assertEquals(150, buffer.size());
-
-    MockSpdyPeer.InFrame synStream = peer.takeFrame();
-    assertEquals(TYPE_HEADERS, synStream.type);
-    for (int i = 0; i < 3; i++) {
-      List<Integer> windowUpdateStreamIds = new ArrayList<>(2);
-      for (int j = 0; j < 2; j++) {
-        MockSpdyPeer.InFrame windowUpdate = peer.takeFrame();
-        assertEquals(TYPE_WINDOW_UPDATE, windowUpdate.type);
-        windowUpdateStreamIds.add(windowUpdate.streamId);
-        assertEquals(windowUpdateThreshold, windowUpdate.windowSizeIncrement);
-      }
-      assertTrue(windowUpdateStreamIds.contains(0)); // connection
-      assertTrue(windowUpdateStreamIds.contains(1)); // stream
-    }
-  }
-
-  private Buffer data(int byteCount) {
-    return new Buffer().write(new byte[byteCount]);
-  }
-
-  @Test public void serverSendsEmptyDataClientDoesntSendWindowUpdate() throws Exception {
-    peer.setVariantAndClient(SPDY3, false);
-
-    // Write the mocking script.
-    peer.acceptFrame(); // SYN_STREAM
-    peer.sendFrame().synReply(false, 1, headerEntries("a", "android"));
-    peer.sendFrame().data(true, 1, data(0), 0);
-    peer.play();
-
-    // Play it back.
-    FramedConnection connection = connection(peer, SPDY3);
-    FramedStream client = connection.newStream(headerEntries("b", "banana"), false, true);
-    assertEquals(-1, client.getSource().read(new Buffer(), 1));
-
-    // Verify the peer received what was expected.
-    MockSpdyPeer.InFrame synStream = peer.takeFrame();
-    assertEquals(TYPE_HEADERS, synStream.type);
-    assertEquals(3, peer.frameCount());
-  }
-
-  @Test public void clientSendsEmptyDataServerDoesntSendWindowUpdate() throws Exception {
-    peer.setVariantAndClient(SPDY3, false);
-
-    // Write the mocking script.
-    peer.acceptFrame(); // SYN_STREAM
-    peer.acceptFrame(); // DATA
-    peer.sendFrame().synReply(false, 1, headerEntries("a", "android"));
-    peer.play();
-
-    // Play it back.
-    FramedConnection connection = connection(peer, SPDY3);
-    FramedStream client = connection.newStream(headerEntries("b", "banana"), true, true);
-    BufferedSink out = Okio.buffer(client.getSink());
-    out.write(Util.EMPTY_BYTE_ARRAY);
-    out.flush();
-    out.close();
-
-    // Verify the peer received what was expected.
-    assertEquals(TYPE_HEADERS, peer.takeFrame().type);
-    assertEquals(TYPE_DATA, peer.takeFrame().type);
-    assertEquals(3, peer.frameCount());
-  }
-
-  @Test public void testTruncatedDataFrame() throws Exception {
-    // write the mocking script
-    peer.acceptFrame(); // SYN_STREAM
-    peer.sendFrame().synReply(false, 1, headerEntries("a", "android"));
-    peer.sendFrame().data(false, 1, data(1024), 1024);
-    peer.truncateLastFrame(8 + 100);
-    peer.play();
-
-    // play it back
-    FramedConnection connection = connection(peer, SPDY3);
-    FramedStream stream = connection.newStream(headerEntries("b", "banana"), true, true);
-    assertEquals(headerEntries("a", "android"), stream.getResponseHeaders());
-    Source in = stream.getSource();
-    try {
-      Okio.buffer(in).readByteString(101);
-      fail();
-    } catch (IOException expected) {
-      assertEquals("stream was reset: PROTOCOL_ERROR", expected.getMessage());
-    }
-  }
-
-  @Test public void blockedStreamDoesntStarveNewStream() throws Exception {
-    int framesThatFillWindow = roundUp(DEFAULT_INITIAL_WINDOW_SIZE, peer.maxOutboundDataLength());
-
-    // Write the mocking script. This accepts more data frames than necessary!
-    peer.acceptFrame(); // SYN_STREAM on stream 1
-    for (int i = 0; i < framesThatFillWindow; i++) {
-      peer.acceptFrame(); // DATA on stream 1
-    }
-    peer.acceptFrame(); // SYN_STREAM on stream 2
-    peer.acceptFrame(); // DATA on stream 2
-    peer.play();
-
-    // Play it back.
-    FramedConnection connection = connection(peer, SPDY3);
-    FramedStream stream1 = connection.newStream(headerEntries("a", "apple"), true, true);
-    BufferedSink out1 = Okio.buffer(stream1.getSink());
-    out1.write(new byte[DEFAULT_INITIAL_WINDOW_SIZE]);
-    out1.flush();
-
-    // Check that we've filled the window for both the stream and also the connection.
-    assertEquals(0, connection.bytesLeftInWriteWindow);
-    assertEquals(0, connection.getStream(1).bytesLeftInWriteWindow);
-
-    // receiving a window update on the the connection will unblock new streams.
-    connection.readerRunnable.windowUpdate(0, 3);
-
-    assertEquals(3, connection.bytesLeftInWriteWindow);
-    assertEquals(0, connection.getStream(1).bytesLeftInWriteWindow);
-
-    // Another stream should be able to send data even though 1 is blocked.
-    FramedStream stream2 = connection.newStream(headerEntries("b", "banana"), true, true);
-    BufferedSink out2 = Okio.buffer(stream2.getSink());
-    out2.writeUtf8("foo");
-    out2.flush();
-
-    assertEquals(0, connection.bytesLeftInWriteWindow);
-    assertEquals(0, connection.getStream(1).bytesLeftInWriteWindow);
-    assertEquals(DEFAULT_INITIAL_WINDOW_SIZE - 3, connection.getStream(3).bytesLeftInWriteWindow);
-  }
-
-  /** https://github.com/square/okhttp/issues/333 */
-  @Test public void headerBlockHasTrailingCompressedBytes512() throws Exception {
-    // This specially-formatted frame has trailing deflated bytes after the name value block.
-    String frame = "gAMAAgAAAgkAAAABeLvjxqfCYgAAAAD//2IAAAAA//9iAAAAAP//YgQAAAD//2IAAAAA//9iAAAAAP/"
-        + "/YgAAAAD//2IEAAAA//9KBAAAAP//YgAAAAD//2IAAAAA//9iAAAAAP//sgEAAAD//2IAAAAA\n//9iBAAAAP//Y"
-        + "gIAAAD//2IGAAAA//9iAQAAAP//YgUAAAD//2IDAAAA//9iBwAAAP//4gAAAAD//+IEAAAA///iAgAAAP//4gYAA"
-        + "AD//+IBAAAA///iBQAAAP//4gMAAAD//+IHAAAA//8SAAAAAP//EgQAAAD//xICAAAA//8SBgAAAP//EgEAAAD//"
-        + "xIFAAAA//8SAwAAAP//EgcAAAD//5IAAAAA//+SBAAAAP//kgIAAAD//5IGAAAA//+SAQAAAP//kgUAAAD//5IDA"
-        + "AAA//+SBwAAAP//UgAAAAD//1IEAAAA//9SAgAAAP//UgYAAAD//1IBAAAA//9SBQAAAP//UgMAAAD//1IHAAAA/"
-        + "//SAAAAAP//0gQAAAD//9ICAAAA///SBgAAAP//0gEAAAD//9IFAAAA///SAwAAAP//0gcAAAD//zIAAAAA//8yB"
-        + "AAAAP//MgIAAAD//zIGAAAA//8yAQAAAP//MgUAAAD//zIDAAAA//8yBwAAAP//sgAAAAD//7IEAAAA//+yAgAAA"
-        + "P//sgYAAAD//w==";
-    headerBlockHasTrailingCompressedBytes(frame, 60);
-  }
-
-  @Test public void headerBlockHasTrailingCompressedBytes2048() throws Exception {
-    // This specially-formatted frame has trailing deflated bytes after the name value block.
-    String frame = "gAMAAgAAB/sAAAABeLvjxqfCAqYjRhAGJmxGxUQAAAAA//9KBAAAAP//SgQAAAD//0oEAAAA//9KBAA"
-        + "AAP//SgQAAAD//0oEAAAA//9KBAAAAP//SgQAAAD//0oEAAAA//9KBAAAAP//SgQAAAD//0oEAAAA//9KBAAAAP/"
-        + "/SgQAAAD//0oEAAAA//9KBAAAAP//SgQAAAD//0oEAAAA//9KBAAAAP//SgQAAAD//0oEAAAA//9KBAAAAP//SgQ"
-        + "AAAD//0oEAAAA//9KBAAAAP//SgQAAAD//0oEAAAA//9KBAAAAP//SgQAAAD//0oEAAAA//9KBAAAAP//SgQAAAD"
-        + "//0oEAAAA//9KBAAAAP//SgQAAAD//0oEAAAA//9KBAAAAP//SgQAAAD//0oEAAAA//9KBAAAAP//SgQAAAD//0o"
-        + "EAAAA//9KBAAAAP//SgQAAAD//0oEAAAA//9KBAAAAP//SgQAAAD//0oEAAAA//9KBAAAAP//SgQAAAD//0oEAAA"
-        + "A//9KBAAAAP//SgQAAAD//0oEAAAA//9KBAAAAP//SgQAAAD//0oEAAAA//9KBAAAAP//SgQAAAD//0oEAAAA//9"
-        + "KBAAAAP//SgQAAAD//0oEAAAA//9KBAAAAP//SgQAAAD//0oEAAAA//9KBAAAAP//SgQAAAD//0oEAAAA//9KBAA"
-        + "AAP//SgQAAAD//0oEAAAA//9KBAAAAP//SgQAAAD//0oEAAAA//9KBAAAAP//SgQAAAD//0oEAAAA//9KBAAAAP/"
-        + "/SgQAAAD//0oEAAAA//9KBAAAAP//SgQAAAD//0oEAAAA//9KBAAAAP//SgQAAAD//0oEAAAA//9KBAAAAP//SgQ"
-        + "AAAD//0oEAAAA//9KBAAAAP//SgQAAAD//0oEAAAA//9KBAAAAP//SgQAAAD//0oEAAAA//9KBAAAAP//SgQAAAD"
-        + "//0oEAAAA//9KBAAAAP//SgQAAAD//0oEAAAA//9KBAAAAP//SgQAAAD//0oEAAAA//9KBAAAAP//SgQAAAD//0o"
-        + "EAAAA//9KBAAAAP//SgQAAAD//0oEAAAA//9KBAAAAP//SgQAAAD//0oEAAAA//9KBAAAAP//SgQAAAD//0oEAAA"
-        + "A//9KBAAAAP//SgQAAAD//0oEAAAA//9KBAAAAP//SgQAAAD//0oEAAAA//9KBAAAAP//SgQAAAD//0oEAAAA//9"
-        + "KBAAAAP//SgQAAAD//0oEAAAA//9KBAAAAP//SgQAAAD//0oEAAAA//9KBAAAAP//SgQAAAD//0oEAAAA//9KBAA"
-        + "AAP//SgQAAAD//0oEAAAA//9KBAAAAP//SgQAAAD//0oEAAAA//9KBAAAAP//SgQAAAD//0oEAAAA//9KBAAAAP/"
-        + "/SgQAAAD//0oEAAAA//9KBAAAAP//SgQAAAD//0oEAAAA//9KBAAAAP//SgQAAAD//0oEAAAA//9KBAAAAP//SgQ"
-        + "AAAD//0oEAAAA//9KBAAAAP//SgQAAAD//0oEAAAA//9KBAAAAP//SgQAAAD//0oEAAAA//9KBAAAAP//SgQAAAD"
-        + "//0oEAAAA//9KBAAAAP//SgQAAAD//0oEAAAA//9KBAAAAP//SgQAAAD//0oEAAAA//9KBAAAAP//SgQAAAD//0o"
-        + "EAAAA//9KBAAAAP//SgQAAAD//0oEAAAA//9KBAAAAP//SgQAAAD//0oEAAAA//9KBAAAAP//SgQAAAD//0oEAAA"
-        + "A//9KBAAAAP//SgQAAAD//0oEAAAA//9KBAAAAP//SgQAAAD//0oEAAAA//9KBAAAAP//SgQAAAD//0oEAAAA//9"
-        + "KBAAAAP//SgQAAAD//0oEAAAA//9KBAAAAP//SgQAAAD//0oEAAAA//9KBAAAAP//SgQAAAD//0oEAAAA//9KBAA"
-        + "AAP//SgQAAAD//0oEAAAA//9KBAAAAP//SgQAAAD//0oEAAAA//9KBAAAAP//SgQAAAD//0oEAAAA//9KBAAAAP/"
-        + "/SgQAAAD//0oEAAAA//9KBAAAAP//SgQAAAD//0oEAAAA//9KBAAAAP//SgQAAAD//0oEAAAA//9KBAAAAP//SgQ"
-        + "AAAD//0oEAAAA//9KBAAAAP//SgQAAAD//0oEAAAA//9KBAAAAP//SgQAAAD//0oEAAAA//9KBAAAAP//SgQAAAD"
-        + "//0oEAAAA//9KBAAAAP//SgQAAAD//0oEAAAA//9KBAAAAP//SgQAAAD//0oEAAAA//9KBAAAAP//SgQAAAD//0o"
-        + "EAAAA//9KBAAAAP//SgQAAAD//0oEAAAA//9KBAAAAP//SgQAAAD//0oEAAAA//9KBAAAAP//SgQAAAD//0oEAAA"
-        + "A//9KBAAAAP//SgQAAAD//0oEAAAA//9KBAAAAP//SgQAAAD//0oEAAAA//9KBAAAAP//SgQAAAD//0oEAAAA//9"
-        + "KBAAAAP//SgQAAAD//0oEAAAA//9KBAAAAP//SgQAAAD//0oEAAAA//9KBAAAAP//SgQAAAD//0oEAAAA//9KBAA"
-        + "AAP//SgQAAAD//0oEAAAA//9KBAAAAP//SgQAAAD//0oEAAAA//9KBAAAAP//SgQAAAD//0oEAAAA//9KBAAAAP/"
-        + "/SgQAAAD//0oEAAAA//9KBAAAAP//SgQAAAD//0oEAAAA//9KBAAAAP//SgQAAAD//0oEAAAA//9KBAAAAP//SgQ"
-        + "AAAD//0oEAAAA//8=";
-    headerBlockHasTrailingCompressedBytes(frame, 289);
-  }
-
-  private void headerBlockHasTrailingCompressedBytes(String frame, int length) throws IOException {
-    // write the mocking script
-    peer.acceptFrame(); // SYN_STREAM
-    byte[] trailingCompressedBytes = ByteString.decodeBase64(frame).toByteArray();
-    trailingCompressedBytes[11] = 1; // Set SPDY/3 stream ID to 3.
-    peer.sendFrame(trailingCompressedBytes);
-    peer.sendFrame().data(true, 1, new Buffer().writeUtf8("robot"), 5);
-    peer.acceptFrame(); // DATA
-    peer.play();
-
-    // play it back
-    FramedConnection connection = connection(peer, SPDY3);
-    FramedStream stream = connection.newStream(headerEntries("b", "banana"), true, true);
-    assertEquals("a", stream.getResponseHeaders().get(0).name.utf8());
-    assertEquals(length, stream.getResponseHeaders().get(0).value.size());
-    assertStreamData("robot", stream.getSource());
-  }
-
-  @Test public void socketExceptionWhileWritingHeaders() throws Exception {
-    peer.acceptFrame(); // SYN_STREAM.
-    peer.play();
-
-    String longString = ByteString.of(randomBytes(2048)).base64();
-    Socket socket = peer.openSocket();
-    FramedConnection connection = new FramedConnection.Builder(true)
-        .socket(socket)
-        .protocol(SPDY3.getProtocol())
-        .build();
-    connection.start(false);
-    socket.shutdownOutput();
-    try {
-      connection.newStream(headerEntries("a", longString), false, true);
-      fail();
-    } catch (IOException expected) {
-    }
-    try {
-      connection.newStream(headerEntries("b", longString), false, true);
-      fail();
-    } catch (IOException expected) {
-    }
-  }
-
-  private byte[] randomBytes(int length) {
-    byte[] bytes = new byte[length];
-    new Random(0).nextBytes(bytes);
-    return bytes;
-  }
-
-  private FramedConnection connection(MockSpdyPeer peer, Variant variant) throws IOException {
-    FramedConnection connection = connectionBuilder(peer, variant).build();
-    connection.start(false);
-    return connection;
-  }
-
-  private FramedConnection.Builder connectionBuilder(MockSpdyPeer peer, Variant variant)
-      throws IOException {
-    return new FramedConnection.Builder(true)
-        .socket(peer.openSocket())
-        .protocol(variant.getProtocol());
-  }
-
-  private void assertStreamData(String expected, Source source) throws IOException {
-    String actual = Okio.buffer(source).readUtf8();
-    assertEquals(expected, actual);
-  }
-
-  /** Interrupts the current thread after {@code delayMillis}. */
-  private void interruptAfterDelay(final long delayMillis) {
-    final Thread toInterrupt = Thread.currentThread();
-    new Thread("interrupting cow") {
-      @Override public void run() {
-        try {
-          Thread.sleep(delayMillis);
-          toInterrupt.interrupt();
-        } catch (InterruptedException e) {
-          throw new AssertionError();
-        }
-      }
-    }.start();
-  }
-
-  /**
-   * Returns true when all work currently in progress by the watchdog have completed. This method
-   * creates more work for the watchdog and waits for that work to be executed. When it is, we know
-   * work that preceded this call is complete.
-   */
-  private void awaitWatchdogIdle() throws InterruptedException {
-    final CountDownLatch latch = new CountDownLatch(1);
-    AsyncTimeout watchdogJob = new AsyncTimeout() {
-      @Override protected void timedOut() {
-        latch.countDown();
-      }
-    };
-    watchdogJob.deadlineNanoTime(System.nanoTime()); // Due immediately!
-    watchdogJob.enter();
-    latch.await();
-  }
-
-  static int roundUp(int num, int divisor) {
-    return (num + divisor - 1) / divisor;
-  }
-}
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/framed/Spdy3Test.java b/okhttp-tests/src/test/java/okhttp3/internal/framed/Spdy3Test.java
deleted file mode 100644
index 953009ffc1..0000000000
--- a/okhttp-tests/src/test/java/okhttp3/internal/framed/Spdy3Test.java
+++ /dev/null
@@ -1,101 +0,0 @@
-/*
- * Copyright (C) 2014 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.internal.framed;
-
-import java.io.IOException;
-import okhttp3.internal.Util;
-import okio.Buffer;
-import okio.ByteString;
-import org.junit.Test;
-
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.fail;
-
-public class Spdy3Test {
-  static final int expectedStreamId = 15;
-
-  @Test public void tooLargeDataFrame() throws IOException {
-    try {
-      sendDataFrame(new Buffer().write(new byte[0x1000000]));
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertEquals("FRAME_TOO_LARGE max size is 16Mib: " + 0x1000000L, e.getMessage());
-    }
-  }
-
-  @Test public void badWindowSizeIncrement() throws IOException {
-    try {
-      windowUpdate(0);
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertEquals("windowSizeIncrement must be between 1 and 0x7fffffff: 0", e.getMessage());
-    }
-    try {
-      windowUpdate(0x80000000L);
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertEquals("windowSizeIncrement must be between 1 and 0x7fffffff: 2147483648",
-          e.getMessage());
-    }
-  }
-
-  @Test public void goAwayRoundTrip() throws IOException {
-    Buffer frame = new Buffer();
-
-    final ErrorCode expectedError = ErrorCode.PROTOCOL_ERROR;
-
-    // Compose the expected GOAWAY frame without debug data
-    // |C| Version(15bits) | Type(16bits) |
-    frame.writeInt(0x80000000 | (Spdy3.VERSION & 0x7fff) << 16 | Spdy3.TYPE_GOAWAY & 0xffff);
-    // | Flags (8)  |  Length (24 bits)   |
-    frame.writeInt(8); // no flags and length is 8.
-    frame.writeInt(expectedStreamId); // last good stream.
-    frame.writeInt(expectedError.spdyGoAwayCode);
-
-    // Check writer sends the same bytes.
-    assertEquals(frame, sendGoAway(expectedStreamId, expectedError, Util.EMPTY_BYTE_ARRAY));
-
-    // SPDY/3 does not send debug data, so bytes should be same!
-    assertEquals(frame, sendGoAway(expectedStreamId, expectedError, new byte[8]));
-
-    FrameReader fr = new Spdy3.Reader(frame, false);
-
-    fr.nextFrame(new BaseTestHandler() { // Consume the goAway frame.
-      @Override public void goAway(
-          int lastGoodStreamId, ErrorCode errorCode, ByteString debugData) {
-        assertEquals(expectedStreamId, lastGoodStreamId);
-        assertEquals(expectedError, errorCode);
-        assertEquals(0, debugData.size());
-      }
-    });
-  }
-
-  private void sendDataFrame(Buffer source) throws IOException {
-    Spdy3.Writer writer = new Spdy3.Writer(new Buffer(), true);
-    writer.sendDataFrame(expectedStreamId, 0, source, (int) source.size());
-  }
-
-  private void windowUpdate(long increment) throws IOException {
-    new Spdy3.Writer(new Buffer(), true).windowUpdate(expectedStreamId, increment);
-  }
-
-  private Buffer sendGoAway(int lastGoodStreamId, ErrorCode errorCode, byte[] debugData)
-      throws IOException {
-    Buffer out = new Buffer();
-    new Spdy3.Writer(out, true).goAway(lastGoodStreamId, errorCode, debugData);
-    return out;
-  }
-}
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/http/ExternalSpdyExample.java b/okhttp-tests/src/test/java/okhttp3/internal/http/ExternalSpdyExample.java
deleted file mode 100644
index c1598480ec..0000000000
--- a/okhttp-tests/src/test/java/okhttp3/internal/http/ExternalSpdyExample.java
+++ /dev/null
@@ -1,51 +0,0 @@
-/*
- * Copyright (C) 2009 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package okhttp3.internal.http;
-
-import okhttp3.Call;
-import okhttp3.OkHttpClient;
-import okhttp3.Protocol;
-import okhttp3.Request;
-import okhttp3.Response;
-import okhttp3.internal.Util;
-
-public final class ExternalSpdyExample {
-  public static void main(String[] args) throws Exception {
-    OkHttpClient client = new OkHttpClient.Builder()
-        .protocols(Util.immutableList(Protocol.SPDY_3, Protocol.HTTP_1_1))
-        .build();
-
-    Call call = client.newCall(new Request.Builder()
-        .url("https://www.google.ca/")
-        .build());
-
-    Response response = call.execute();
-    try {
-      System.out.println(response.code());
-      System.out.println("PROTOCOL " + response.protocol());
-
-      String line;
-      while ((line = response.body().source().readUtf8Line()) != null) {
-        System.out.println(line);
-      }
-    } finally {
-      response.body().close();
-    }
-
-    client.connectionPool().evictAll();
-  }
-}
diff --git a/okhttp-urlconnection/src/main/java/okhttp3/internal/SystemPropertiesConnectionPool.java b/okhttp-urlconnection/src/main/java/okhttp3/internal/SystemPropertiesConnectionPool.java
index e0c9523fb0..67610243cc 100644
--- a/okhttp-urlconnection/src/main/java/okhttp3/internal/SystemPropertiesConnectionPool.java
+++ b/okhttp-urlconnection/src/main/java/okhttp3/internal/SystemPropertiesConnectionPool.java
@@ -23,8 +23,8 @@
  * A shared connection pool that uses system properties for tuning parameters:
  *
  * <ul>
- *     <li>{@code http.keepAlive} true if HTTP and SPDY connections should be pooled at all. Default
- *         is true.
+ *     <li>{@code http.keepAlive} true if HTTP and HTTP/2 connections should be pooled at all.
+ *         Default is true.
  *     <li>{@code http.maxConnections} maximum number of idle connections to each to keep in the
  *         pool. Default is 5.
  *     <li>{@code http.keepAliveDuration} Time in milliseconds to keep the connection alive in the
diff --git a/okhttp/src/main/java/okhttp3/Connection.java b/okhttp/src/main/java/okhttp3/Connection.java
index de3c22d98b..d07e861d8f 100644
--- a/okhttp/src/main/java/okhttp3/Connection.java
+++ b/okhttp/src/main/java/okhttp3/Connection.java
@@ -19,7 +19,7 @@
 import java.net.Socket;
 
 /**
- * The sockets and streams of an HTTP, HTTPS, or HTTPS+SPDY connection. May be used for multiple
+ * The sockets and streams of an HTTP, HTTPS, or HTTPS+HTTP/2 connection. May be used for multiple
  * HTTP request/response exchanges. Connections may be direct to the origin server or via a proxy.
  *
  * <p>Typically instances of this class are created, connected and exercised automatically by the
@@ -37,8 +37,8 @@
  * <ul>
  *     <li>Server Name Indication (SNI) enables one IP address to negotiate secure connections for
  *         multiple domain names.
- *     <li>Application Layer Protocol Negotiation (ALPN) enables the HTTPS port (443) to be used for
- *         different HTTP and SPDY protocols.
+ *     <li>Application Layer Protocol Negotiation (ALPN) enables the HTTPS port (443) to be used to
+ *         negotiate HTTP/2.
  * </ul>
  *
  * <p>Unfortunately, older HTTPS servers refuse to connect when such options are presented. Rather
@@ -73,7 +73,7 @@
 
   /**
    * Returns the socket that this connection is using. Returns an {@linkplain
-   * javax.net.ssl.SSLSocket SSL socket} if this connection is HTTPS. If this is an HTTP/2 or SPDY
+   * javax.net.ssl.SSLSocket SSL socket} if this connection is HTTPS. If this is an HTTP/2
    * connection the socket may be shared by multiple concurrent calls.
    */
   Socket socket();
diff --git a/okhttp/src/main/java/okhttp3/ConnectionPool.java b/okhttp/src/main/java/okhttp3/ConnectionPool.java
index 2b4563c331..19ed7cab10 100644
--- a/okhttp/src/main/java/okhttp3/ConnectionPool.java
+++ b/okhttp/src/main/java/okhttp3/ConnectionPool.java
@@ -36,9 +36,9 @@
 import static okhttp3.internal.platform.Platform.WARN;
 
 /**
- * Manages reuse of HTTP and SPDY connections for reduced network latency. HTTP requests that share
- * the same {@link Address} may share a {@link Connection}. This class implements the policy of
- * which connections to keep open for future use.
+ * Manages reuse of HTTP and HTTP/2 connections for reduced network latency. HTTP requests that
+ * share the same {@link Address} may share a {@link Connection}. This class implements the policy
+ * of which connections to keep open for future use.
  */
 public final class ConnectionPool {
   /**
@@ -106,7 +106,7 @@ public synchronized int idleConnectionCount() {
 
   /**
    * Returns total number of connections in the pool. Note that prior to OkHttp 2.7 this included
-   * only idle connections and SPDY connections. Since OkHttp 2.7 this includes all connections,
+   * only idle connections and HTTP/2 connections. Since OkHttp 2.7 this includes all connections,
    * both active and inactive. Use {@link #idleConnectionCount()} to count connections not currently
    * in use.
    */
diff --git a/okhttp/src/main/java/okhttp3/OkHttpClient.java b/okhttp/src/main/java/okhttp3/OkHttpClient.java
index 5bbeed9c91..6b9ad460d9 100644
--- a/okhttp/src/main/java/okhttp3/OkHttpClient.java
+++ b/okhttp/src/main/java/okhttp3/OkHttpClient.java
@@ -23,6 +23,7 @@
 import java.security.KeyStore;
 import java.util.ArrayList;
 import java.util.Arrays;
+import java.util.Collections;
 import java.util.List;
 import java.util.concurrent.ExecutorService;
 import java.util.concurrent.TimeUnit;
@@ -116,7 +117,7 @@
  */
 public class OkHttpClient implements Cloneable, Call.Factory {
   private static final List<Protocol> DEFAULT_PROTOCOLS = Util.immutableList(
-      Protocol.HTTP_2, Protocol.SPDY_3, Protocol.HTTP_1_1);
+      Protocol.HTTP_2, Protocol.HTTP_1_1);
 
   private static final List<ConnectionSpec> DEFAULT_CONNECTION_SPECS = Util.immutableList(
       ConnectionSpec.MODERN_TLS, ConnectionSpec.COMPATIBLE_TLS, ConnectionSpec.CLEARTEXT);
@@ -753,14 +754,12 @@ public Builder dispatcher(Dispatcher dispatcher) {
      * Configure the protocols used by this client to communicate with remote servers. By default
      * this client will prefer the most efficient transport available, falling back to more
      * ubiquitous protocols. Applications should only call this method to avoid specific
-     * compatibility problems, such as web servers that behave incorrectly when SPDY is enabled.
+     * compatibility problems, such as web servers that behave incorrectly when HTTP/2 is enabled.
      *
      * <p>The following protocols are currently supported:
      *
      * <ul>
      *     <li><a href="http://www.w3.org/Protocols/rfc2616/rfc2616.html">http/1.1</a>
-     *     <li><a
-     *         href="http://www.chromium.org/spdy/spdy-protocol/spdy-protocol-draft3-1">spdy/3.1</a>
      *     <li><a href="http://tools.ietf.org/html/draft-ietf-httpbis-http2-17">h2</a>
      * </ul>
      *
@@ -779,7 +778,10 @@ public Builder dispatcher(Dispatcher dispatcher) {
      * Protocol#HTTP_1_1}. It must not contain null or {@link Protocol#HTTP_1_0}.
      */
     public Builder protocols(List<Protocol> protocols) {
-      protocols = Util.immutableList(protocols);
+      // Create a private copy of the list.
+      protocols = new ArrayList<>(protocols);
+
+      // Validate that the list has everything we require and nothing we forbid.
       if (!protocols.contains(Protocol.HTTP_1_1)) {
         throw new IllegalArgumentException("protocols doesn't contain http/1.1: " + protocols);
       }
@@ -789,7 +791,14 @@ public Builder protocols(List<Protocol> protocols) {
       if (protocols.contains(null)) {
         throw new IllegalArgumentException("protocols must not contain null");
       }
-      this.protocols = Util.immutableList(protocols);
+
+      // Remove protocols that we no longer support.
+      if (protocols.contains(Protocol.SPDY_3)) {
+        protocols.remove(Protocol.SPDY_3);
+      }
+
+      // Assign as an unmodifiable list. This is effectively immutable.
+      this.protocols = Collections.unmodifiableList(protocols);
       return this;
     }
 
diff --git a/okhttp/src/main/java/okhttp3/Protocol.java b/okhttp/src/main/java/okhttp3/Protocol.java
index eec1c1219c..88d15b9b6b 100644
--- a/okhttp/src/main/java/okhttp3/Protocol.java
+++ b/okhttp/src/main/java/okhttp3/Protocol.java
@@ -44,9 +44,9 @@
    * Chromium's binary-framed protocol that includes header compression, multiplexing multiple
    * requests on the same socket, and server-push. HTTP/1.1 semantics are layered on SPDY/3.
    *
-   * <p>This version of OkHttp implements SPDY 3 <a
-   * href="http://dev.chromium.org/spdy/spdy-protocol/spdy-protocol-draft3-1">draft 3.1</a>. Future
-   * releases of OkHttp may use this identifier for a newer draft of the SPDY spec.
+   * <p>Current versions of OkHttp do not support this protocol.
+   *
+   * @deprecated OkHttp has dropped support for SPDY. Prefer {@link #HTTP_2}.
    */
   SPDY_3("spdy/3.1"),
 
diff --git a/okhttp/src/main/java/okhttp3/internal/connection/RealConnection.java b/okhttp/src/main/java/okhttp3/internal/connection/RealConnection.java
index a5d5c24a6a..58cd04397b 100644
--- a/okhttp/src/main/java/okhttp3/internal/connection/RealConnection.java
+++ b/okhttp/src/main/java/okhttp3/internal/connection/RealConnection.java
@@ -201,12 +201,11 @@ private void establishProtocol(int readTimeout, int writeTimeout,
       socket = rawSocket;
     }
 
-    if (protocol == Protocol.SPDY_3 || protocol == Protocol.HTTP_2) {
+    if (protocol == Protocol.HTTP_2) {
       socket.setSoTimeout(0); // Framed connection timeouts are set per-stream.
 
       FramedConnection framedConnection = new FramedConnection.Builder(true)
           .socket(socket, route.address().url().host(), source, sink)
-          .protocol(protocol)
           .listener(this)
           .build();
       framedConnection.start();
@@ -405,7 +404,7 @@ public boolean isHealthy(boolean doExtensiveChecks) {
   }
 
   /**
-   * Returns true if this is a SPDY connection. Such connections can be used in multiple HTTP
+   * Returns true if this is an HTTP/2 connection. Such connections can be used in multiple HTTP
    * requests simultaneously.
    */
   public boolean isMultiplexed() {
@@ -416,7 +415,7 @@ public boolean isMultiplexed() {
     if (framedConnection == null) {
       return protocol != null ? protocol : Protocol.HTTP_1_1;
     } else {
-      return framedConnection.getProtocol();
+      return Protocol.HTTP_2;
     }
   }
 
diff --git a/okhttp/src/main/java/okhttp3/internal/connection/StreamAllocation.java b/okhttp/src/main/java/okhttp3/internal/connection/StreamAllocation.java
index 8294f5699c..2b598ceb00 100644
--- a/okhttp/src/main/java/okhttp3/internal/connection/StreamAllocation.java
+++ b/okhttp/src/main/java/okhttp3/internal/connection/StreamAllocation.java
@@ -42,7 +42,7 @@
  *     <li><strong>Streams:</strong> logical HTTP request/response pairs that are layered on
  *         connections. Each connection has its own allocation limit, which defines how many
  *         concurrent streams that connection can carry. HTTP/1.x connections can carry 1 stream
- *         at a time, SPDY and HTTP/2 typically carry multiple.
+ *         at a time, HTTP/2 typically carry multiple.
  *     <li><strong>Calls:</strong> a logical sequence of streams, typically an initial request and
  *         its follow up requests. We prefer to keep all streams of a single call on the same
  *         connection for better behavior and locality.
diff --git a/okhttp/src/main/java/okhttp3/internal/framed/ErrorCode.java b/okhttp/src/main/java/okhttp3/internal/framed/ErrorCode.java
index 1088f6736a..5aca74b88e 100644
--- a/okhttp/src/main/java/okhttp3/internal/framed/ErrorCode.java
+++ b/okhttp/src/main/java/okhttp3/internal/framed/ErrorCode.java
@@ -17,62 +17,23 @@
 
 // http://tools.ietf.org/html/draft-ietf-httpbis-http2-17#section-7
 public enum ErrorCode {
-  /** Not an error! For SPDY stream resets, prefer null over NO_ERROR. */
-  NO_ERROR(0, -1, 0),
+  /** Not an error! */
+  NO_ERROR(0),
 
-  PROTOCOL_ERROR(1, 1, 1),
+  PROTOCOL_ERROR(1),
 
-  /** A subtype of PROTOCOL_ERROR used by SPDY. */
-  INVALID_STREAM(1, 2, -1),
+  INTERNAL_ERROR(2),
 
-  /** A subtype of PROTOCOL_ERROR used by SPDY. */
-  UNSUPPORTED_VERSION(1, 4, -1),
+  FLOW_CONTROL_ERROR(3),
 
-  /** A subtype of PROTOCOL_ERROR used by SPDY. */
-  STREAM_IN_USE(1, 8, -1),
+  REFUSED_STREAM(7),
 
-  /** A subtype of PROTOCOL_ERROR used by SPDY. */
-  STREAM_ALREADY_CLOSED(1, 9, -1),
-
-  INTERNAL_ERROR(2, 6, 2),
-
-  FLOW_CONTROL_ERROR(3, 7, -1),
-
-  STREAM_CLOSED(5, -1, -1),
-
-  FRAME_TOO_LARGE(6, 11, -1),
-
-  REFUSED_STREAM(7, 3, -1),
-
-  CANCEL(8, 5, -1),
-
-  COMPRESSION_ERROR(9, -1, -1),
-
-  CONNECT_ERROR(10, -1, -1),
-
-  ENHANCE_YOUR_CALM(11, -1, -1),
-
-  INADEQUATE_SECURITY(12, -1, -1),
-
-  HTTP_1_1_REQUIRED(13, -1, -1),
-
-  INVALID_CREDENTIALS(-1, 10, -1);
+  CANCEL(8);
 
   public final int httpCode;
-  public final int spdyRstCode;
-  public final int spdyGoAwayCode;
 
-  ErrorCode(int httpCode, int spdyRstCode, int spdyGoAwayCode) {
+  ErrorCode(int httpCode) {
     this.httpCode = httpCode;
-    this.spdyRstCode = spdyRstCode;
-    this.spdyGoAwayCode = spdyGoAwayCode;
-  }
-
-  public static ErrorCode fromSpdy3Rst(int code) {
-    for (ErrorCode errorCode : ErrorCode.values()) {
-      if (errorCode.spdyRstCode == code) return errorCode;
-    }
-    return null;
   }
 
   public static ErrorCode fromHttp2(int code) {
@@ -81,11 +42,4 @@ public static ErrorCode fromHttp2(int code) {
     }
     return null;
   }
-
-  public static ErrorCode fromSpdyGoAway(int code) {
-    for (ErrorCode errorCode : ErrorCode.values()) {
-      if (errorCode.spdyGoAwayCode == code) return errorCode;
-    }
-    return null;
-  }
 }
diff --git a/okhttp/src/main/java/okhttp3/internal/framed/FrameLogger.java b/okhttp/src/main/java/okhttp3/internal/framed/FrameLogger.java
new file mode 100644
index 0000000000..20ef532c3e
--- /dev/null
+++ b/okhttp/src/main/java/okhttp3/internal/framed/FrameLogger.java
@@ -0,0 +1,146 @@
+/*
+ * Copyright (C) 2013 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.internal.framed;
+
+import static okhttp3.internal.Util.format;
+import static okhttp3.internal.framed.Http2.FLAG_ACK;
+import static okhttp3.internal.framed.Http2.FLAG_COMPRESSED;
+import static okhttp3.internal.framed.Http2.FLAG_END_HEADERS;
+import static okhttp3.internal.framed.Http2.FLAG_END_PUSH_PROMISE;
+import static okhttp3.internal.framed.Http2.FLAG_END_STREAM;
+import static okhttp3.internal.framed.Http2.FLAG_NONE;
+import static okhttp3.internal.framed.Http2.FLAG_PADDED;
+import static okhttp3.internal.framed.Http2.FLAG_PRIORITY;
+import static okhttp3.internal.framed.Http2.TYPE_DATA;
+import static okhttp3.internal.framed.Http2.TYPE_GOAWAY;
+import static okhttp3.internal.framed.Http2.TYPE_PING;
+import static okhttp3.internal.framed.Http2.TYPE_PRIORITY;
+import static okhttp3.internal.framed.Http2.TYPE_PUSH_PROMISE;
+import static okhttp3.internal.framed.Http2.TYPE_RST_STREAM;
+import static okhttp3.internal.framed.Http2.TYPE_SETTINGS;
+import static okhttp3.internal.framed.Http2.TYPE_WINDOW_UPDATE;
+
+/**
+ * Logs a human-readable representation of HTTP/2 frame headers.
+ *
+ * <p>The format is:
+ *
+ * <pre>
+ *   direction streamID length type flags
+ * </pre>
+ * Where direction is {@code <<} for inbound and {@code >>} for outbound.
+ *
+ * <p>For example, the following would indicate a HEAD request sent from the client.
+ * <pre>
+ * {@code
+ *   << 0x0000000f    12 HEADERS       END_HEADERS|END_STREAM
+ * }
+ * </pre>
+ */
+final class FrameLogger {
+  private FrameLogger() {
+  }
+
+  static String formatHeader(boolean inbound, int streamId, int length, byte type, byte flags) {
+    String formattedType = type < TYPES.length ? TYPES[type] : format("0x%02x", type);
+    String formattedFlags = formatFlags(type, flags);
+    return format("%s 0x%08x %5d %-13s %s", inbound ? "<<" : ">>", streamId, length,
+        formattedType, formattedFlags);
+  }
+
+  /**
+   * Looks up valid string representing flags from the table. Invalid combinations are represented
+   * in binary.
+   */
+  // Visible for testing.
+  static String formatFlags(byte type, byte flags) {
+    if (flags == 0) return "";
+    switch (type) { // Special case types that have 0 or 1 flag.
+      case TYPE_SETTINGS:
+      case TYPE_PING:
+        return flags == FLAG_ACK ? "ACK" : BINARY[flags];
+      case TYPE_PRIORITY:
+      case TYPE_RST_STREAM:
+      case TYPE_GOAWAY:
+      case TYPE_WINDOW_UPDATE:
+        return BINARY[flags];
+    }
+    String result = flags < FLAGS.length ? FLAGS[flags] : BINARY[flags];
+    // Special case types that have overlap flag values.
+    if (type == TYPE_PUSH_PROMISE && (flags & FLAG_END_PUSH_PROMISE) != 0) {
+      return result.replace("HEADERS", "PUSH_PROMISE"); // TODO: Avoid allocation.
+    } else if (type == TYPE_DATA && (flags & FLAG_COMPRESSED) != 0) {
+      return result.replace("PRIORITY", "COMPRESSED"); // TODO: Avoid allocation.
+    }
+    return result;
+  }
+
+  /** Lookup table for valid frame types. */
+  private static final String[] TYPES = new String[] {
+      "DATA",
+      "HEADERS",
+      "PRIORITY",
+      "RST_STREAM",
+      "SETTINGS",
+      "PUSH_PROMISE",
+      "PING",
+      "GOAWAY",
+      "WINDOW_UPDATE",
+      "CONTINUATION"
+  };
+
+  /**
+   * Lookup table for valid flags for DATA, HEADERS, CONTINUATION. Invalid combinations are
+   * represented in binary.
+   */
+  private static final String[] FLAGS = new String[0x40]; // Highest bit flag is 0x20.
+  private static final String[] BINARY = new String[256];
+
+  static {
+    for (int i = 0; i < BINARY.length; i++) {
+      BINARY[i] = format("%8s", Integer.toBinaryString(i)).replace(' ', '0');
+    }
+
+    FLAGS[FLAG_NONE] = "";
+    FLAGS[FLAG_END_STREAM] = "END_STREAM";
+
+    int[] prefixFlags = new int[] {FLAG_END_STREAM};
+
+    FLAGS[FLAG_PADDED] = "PADDED";
+    for (int prefixFlag : prefixFlags) {
+      FLAGS[prefixFlag | FLAG_PADDED] = FLAGS[prefixFlag] + "|PADDED";
+    }
+
+    FLAGS[FLAG_END_HEADERS] = "END_HEADERS"; // Same as END_PUSH_PROMISE.
+    FLAGS[FLAG_PRIORITY] = "PRIORITY"; // Same as FLAG_COMPRESSED.
+    FLAGS[FLAG_END_HEADERS | FLAG_PRIORITY] = "END_HEADERS|PRIORITY"; // Only valid on HEADERS.
+    int[] frameFlags = new int[] {
+        FLAG_END_HEADERS, FLAG_PRIORITY, FLAG_END_HEADERS | FLAG_PRIORITY
+    };
+
+    for (int frameFlag : frameFlags) {
+      for (int prefixFlag : prefixFlags) {
+        FLAGS[prefixFlag | frameFlag] = FLAGS[prefixFlag] + '|' + FLAGS[frameFlag];
+        FLAGS[prefixFlag | frameFlag | FLAG_PADDED]
+            = FLAGS[prefixFlag] + '|' + FLAGS[frameFlag] + "|PADDED";
+      }
+    }
+
+    for (int i = 0; i < FLAGS.length; i++) { // Fill in holes with binary representation.
+      if (FLAGS[i] == null) FLAGS[i] = BINARY[i];
+    }
+  }
+}
diff --git a/okhttp/src/main/java/okhttp3/internal/framed/FrameReader.java b/okhttp/src/main/java/okhttp3/internal/framed/FrameReader.java
index 741a568c0d..af5c4778e5 100644
--- a/okhttp/src/main/java/okhttp3/internal/framed/FrameReader.java
+++ b/okhttp/src/main/java/okhttp3/internal/framed/FrameReader.java
@@ -18,14 +18,386 @@
 import java.io.Closeable;
 import java.io.IOException;
 import java.util.List;
+import java.util.logging.Logger;
+import okio.Buffer;
 import okio.BufferedSource;
 import okio.ByteString;
+import okio.Source;
+import okio.Timeout;
 
-/** Reads transport frames for SPDY/3 or HTTP/2. */
-public interface FrameReader extends Closeable {
-  void readConnectionPreface() throws IOException;
+import static java.util.logging.Level.FINE;
+import static okhttp3.internal.Util.format;
+import static okhttp3.internal.framed.FrameLogger.formatHeader;
+import static okhttp3.internal.framed.Http2.CONNECTION_PREFACE;
+import static okhttp3.internal.framed.Http2.FLAG_ACK;
+import static okhttp3.internal.framed.Http2.FLAG_COMPRESSED;
+import static okhttp3.internal.framed.Http2.FLAG_END_HEADERS;
+import static okhttp3.internal.framed.Http2.FLAG_END_STREAM;
+import static okhttp3.internal.framed.Http2.FLAG_PADDED;
+import static okhttp3.internal.framed.Http2.FLAG_PRIORITY;
+import static okhttp3.internal.framed.Http2.INITIAL_MAX_FRAME_SIZE;
+import static okhttp3.internal.framed.Http2.TYPE_CONTINUATION;
+import static okhttp3.internal.framed.Http2.TYPE_DATA;
+import static okhttp3.internal.framed.Http2.TYPE_GOAWAY;
+import static okhttp3.internal.framed.Http2.TYPE_HEADERS;
+import static okhttp3.internal.framed.Http2.TYPE_PING;
+import static okhttp3.internal.framed.Http2.TYPE_PRIORITY;
+import static okhttp3.internal.framed.Http2.TYPE_PUSH_PROMISE;
+import static okhttp3.internal.framed.Http2.TYPE_RST_STREAM;
+import static okhttp3.internal.framed.Http2.TYPE_SETTINGS;
+import static okhttp3.internal.framed.Http2.TYPE_WINDOW_UPDATE;
+import static okhttp3.internal.framed.Http2.ioException;
+import static okio.ByteString.EMPTY;
 
-  boolean nextFrame(Handler handler) throws IOException;
+/**
+ * Reads transport frames for HTTP/2.
+ *
+ * <p>This implementation assumes we do not send an increased {@link Settings#getMaxFrameSize frame
+ * size setting} to the peer. Hence, we expect all frames to have a max length of {@link
+ * Http2#INITIAL_MAX_FRAME_SIZE}.
+ */
+final class FrameReader implements Closeable {
+  private static final Logger logger = Logger.getLogger(FrameLogger.class.getName());
+
+  private final BufferedSource source;
+  private final ContinuationSource continuation;
+  private final boolean client;
+
+  // Visible for testing.
+  final Hpack.Reader hpackReader;
+
+  /** Creates a frame reader with max header table size of 4096. */
+  public FrameReader(BufferedSource source, boolean client) {
+    this.source = source;
+    this.client = client;
+    this.continuation = new ContinuationSource(this.source);
+    this.hpackReader = new Hpack.Reader(4096, continuation);
+  }
+
+  public void readConnectionPreface() throws IOException {
+    if (client) return; // Nothing to read; servers doesn't send a connection preface!
+    ByteString connectionPreface = source.readByteString(CONNECTION_PREFACE.size());
+    if (logger.isLoggable(FINE)) logger.fine(format("<< CONNECTION %s", connectionPreface.hex()));
+    if (!CONNECTION_PREFACE.equals(connectionPreface)) {
+      throw ioException("Expected a connection header but was %s", connectionPreface.utf8());
+    }
+  }
+
+  public boolean nextFrame(Handler handler) throws IOException {
+    try {
+      source.require(9); // Frame header size
+    } catch (IOException e) {
+      return false; // This might be a normal socket close.
+    }
+
+      /*  0                   1                   2                   3
+       *  0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+       * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+       * |                 Length (24)                   |
+       * +---------------+---------------+---------------+
+       * |   Type (8)    |   Flags (8)   |
+       * +-+-+-----------+---------------+-------------------------------+
+       * |R|                 Stream Identifier (31)                      |
+       * +=+=============================================================+
+       * |                   Frame Payload (0...)                      ...
+       * +---------------------------------------------------------------+
+       */
+    int length = readMedium(source);
+    if (length < 0 || length > INITIAL_MAX_FRAME_SIZE) {
+      throw ioException("FRAME_SIZE_ERROR: %s", length);
+    }
+    byte type = (byte) (source.readByte() & 0xff);
+    byte flags = (byte) (source.readByte() & 0xff);
+    int streamId = (source.readInt() & 0x7fffffff); // Ignore reserved bit.
+    if (logger.isLoggable(FINE)) logger.fine(formatHeader(true, streamId, length, type, flags));
+
+    switch (type) {
+      case TYPE_DATA:
+        readData(handler, length, flags, streamId);
+        break;
+
+      case TYPE_HEADERS:
+        readHeaders(handler, length, flags, streamId);
+        break;
+
+      case TYPE_PRIORITY:
+        readPriority(handler, length, flags, streamId);
+        break;
+
+      case TYPE_RST_STREAM:
+        readRstStream(handler, length, flags, streamId);
+        break;
+
+      case TYPE_SETTINGS:
+        readSettings(handler, length, flags, streamId);
+        break;
+
+      case TYPE_PUSH_PROMISE:
+        readPushPromise(handler, length, flags, streamId);
+        break;
+
+      case TYPE_PING:
+        readPing(handler, length, flags, streamId);
+        break;
+
+      case TYPE_GOAWAY:
+        readGoAway(handler, length, flags, streamId);
+        break;
+
+      case TYPE_WINDOW_UPDATE:
+        readWindowUpdate(handler, length, flags, streamId);
+        break;
+
+      default:
+        // Implementations MUST discard frames that have unknown or unsupported types.
+        source.skip(length);
+    }
+    return true;
+  }
+
+  private void readHeaders(Handler handler, int length, byte flags, int streamId)
+      throws IOException {
+    if (streamId == 0) throw ioException("PROTOCOL_ERROR: TYPE_HEADERS streamId == 0");
+
+    boolean endStream = (flags & FLAG_END_STREAM) != 0;
+
+    short padding = (flags & FLAG_PADDED) != 0 ? (short) (source.readByte() & 0xff) : 0;
+
+    if ((flags & FLAG_PRIORITY) != 0) {
+      readPriority(handler, streamId);
+      length -= 5; // account for above read.
+    }
+
+    length = lengthWithoutPadding(length, flags, padding);
+
+    List<Header> headerBlock = readHeaderBlock(length, padding, flags, streamId);
+
+    handler.headers(endStream, streamId, -1, headerBlock);
+  }
+
+  private List<Header> readHeaderBlock(int length, short padding, byte flags, int streamId)
+      throws IOException {
+    continuation.length = continuation.left = length;
+    continuation.padding = padding;
+    continuation.flags = flags;
+    continuation.streamId = streamId;
+
+    // TODO: Concat multi-value headers with 0x0, except COOKIE, which uses 0x3B, 0x20.
+    // http://tools.ietf.org/html/draft-ietf-httpbis-http2-17#section-8.1.2.5
+    hpackReader.readHeaders();
+    return hpackReader.getAndResetHeaderList();
+  }
+
+  private void readData(Handler handler, int length, byte flags, int streamId)
+      throws IOException {
+    // TODO: checkState open or half-closed (local) or raise STREAM_CLOSED
+    boolean inFinished = (flags & FLAG_END_STREAM) != 0;
+    boolean gzipped = (flags & FLAG_COMPRESSED) != 0;
+    if (gzipped) {
+      throw ioException("PROTOCOL_ERROR: FLAG_COMPRESSED without SETTINGS_COMPRESS_DATA");
+    }
+
+    short padding = (flags & FLAG_PADDED) != 0 ? (short) (source.readByte() & 0xff) : 0;
+    length = lengthWithoutPadding(length, flags, padding);
+
+    handler.data(inFinished, streamId, source, length);
+    source.skip(padding);
+  }
+
+  private void readPriority(Handler handler, int length, byte flags, int streamId)
+      throws IOException {
+    if (length != 5) throw ioException("TYPE_PRIORITY length: %d != 5", length);
+    if (streamId == 0) throw ioException("TYPE_PRIORITY streamId == 0");
+    readPriority(handler, streamId);
+  }
+
+  private void readPriority(Handler handler, int streamId) throws IOException {
+    int w1 = source.readInt();
+    boolean exclusive = (w1 & 0x80000000) != 0;
+    int streamDependency = (w1 & 0x7fffffff);
+    int weight = (source.readByte() & 0xff) + 1;
+    handler.priority(streamId, streamDependency, weight, exclusive);
+  }
+
+  private void readRstStream(Handler handler, int length, byte flags, int streamId)
+      throws IOException {
+    if (length != 4) throw ioException("TYPE_RST_STREAM length: %d != 4", length);
+    if (streamId == 0) throw ioException("TYPE_RST_STREAM streamId == 0");
+    int errorCodeInt = source.readInt();
+    ErrorCode errorCode = ErrorCode.fromHttp2(errorCodeInt);
+    if (errorCode == null) {
+      throw ioException("TYPE_RST_STREAM unexpected error code: %d", errorCodeInt);
+    }
+    handler.rstStream(streamId, errorCode);
+  }
+
+  private void readSettings(Handler handler, int length, byte flags, int streamId)
+      throws IOException {
+    if (streamId != 0) throw ioException("TYPE_SETTINGS streamId != 0");
+    if ((flags & FLAG_ACK) != 0) {
+      if (length != 0) throw ioException("FRAME_SIZE_ERROR ack frame should be empty!");
+      handler.ackSettings();
+      return;
+    }
+
+    if (length % 6 != 0) throw ioException("TYPE_SETTINGS length %% 6 != 0: %s", length);
+    Settings settings = new Settings();
+    for (int i = 0; i < length; i += 6) {
+      short id = source.readShort();
+      int value = source.readInt();
+
+      switch (id) {
+        case 1: // SETTINGS_HEADER_TABLE_SIZE
+          break;
+        case 2: // SETTINGS_ENABLE_PUSH
+          if (value != 0 && value != 1) {
+            throw ioException("PROTOCOL_ERROR SETTINGS_ENABLE_PUSH != 0 or 1");
+          }
+          break;
+        case 3: // SETTINGS_MAX_CONCURRENT_STREAMS
+          id = 4; // Renumbered in draft 10.
+          break;
+        case 4: // SETTINGS_INITIAL_WINDOW_SIZE
+          id = 7; // Renumbered in draft 10.
+          if (value < 0) {
+            throw ioException("PROTOCOL_ERROR SETTINGS_INITIAL_WINDOW_SIZE > 2^31 - 1");
+          }
+          break;
+        case 5: // SETTINGS_MAX_FRAME_SIZE
+          if (value < INITIAL_MAX_FRAME_SIZE || value > 16777215) {
+            throw ioException("PROTOCOL_ERROR SETTINGS_MAX_FRAME_SIZE: %s", value);
+          }
+          break;
+        case 6: // SETTINGS_MAX_HEADER_LIST_SIZE
+          break; // Advisory only, so ignored.
+        default:
+          break; // Must ignore setting with unknown id.
+      }
+      settings.set(id, value);
+    }
+    handler.settings(false, settings);
+  }
+
+  private void readPushPromise(Handler handler, int length, byte flags, int streamId)
+      throws IOException {
+    if (streamId == 0) {
+      throw ioException("PROTOCOL_ERROR: TYPE_PUSH_PROMISE streamId == 0");
+    }
+    short padding = (flags & FLAG_PADDED) != 0 ? (short) (source.readByte() & 0xff) : 0;
+    int promisedStreamId = source.readInt() & 0x7fffffff;
+    length -= 4; // account for above read.
+    length = lengthWithoutPadding(length, flags, padding);
+    List<Header> headerBlock = readHeaderBlock(length, padding, flags, streamId);
+    handler.pushPromise(streamId, promisedStreamId, headerBlock);
+  }
+
+  private void readPing(Handler handler, int length, byte flags, int streamId)
+      throws IOException {
+    if (length != 8) throw ioException("TYPE_PING length != 8: %s", length);
+    if (streamId != 0) throw ioException("TYPE_PING streamId != 0");
+    int payload1 = source.readInt();
+    int payload2 = source.readInt();
+    boolean ack = (flags & FLAG_ACK) != 0;
+    handler.ping(ack, payload1, payload2);
+  }
+
+  private void readGoAway(Handler handler, int length, byte flags, int streamId)
+      throws IOException {
+    if (length < 8) throw ioException("TYPE_GOAWAY length < 8: %s", length);
+    if (streamId != 0) throw ioException("TYPE_GOAWAY streamId != 0");
+    int lastStreamId = source.readInt();
+    int errorCodeInt = source.readInt();
+    int opaqueDataLength = length - 8;
+    ErrorCode errorCode = ErrorCode.fromHttp2(errorCodeInt);
+    if (errorCode == null) {
+      throw ioException("TYPE_GOAWAY unexpected error code: %d", errorCodeInt);
+    }
+    ByteString debugData = EMPTY;
+    if (opaqueDataLength > 0) { // Must read debug data in order to not corrupt the connection.
+      debugData = source.readByteString(opaqueDataLength);
+    }
+    handler.goAway(lastStreamId, errorCode, debugData);
+  }
+
+  private void readWindowUpdate(Handler handler, int length, byte flags, int streamId)
+      throws IOException {
+    if (length != 4) throw ioException("TYPE_WINDOW_UPDATE length !=4: %s", length);
+    long increment = (source.readInt() & 0x7fffffffL);
+    if (increment == 0) throw ioException("windowSizeIncrement was 0", increment);
+    handler.windowUpdate(streamId, increment);
+  }
+
+  @Override public void close() throws IOException {
+    source.close();
+  }
+
+  /**
+   * Decompression of the header block occurs above the framing layer. This class lazily reads
+   * continuation frames as they are needed by {@link Hpack.Reader#readHeaders()}.
+   */
+  static final class ContinuationSource implements Source {
+    private final BufferedSource source;
+
+    int length;
+    byte flags;
+    int streamId;
+
+    int left;
+    short padding;
+
+    public ContinuationSource(BufferedSource source) {
+      this.source = source;
+    }
+
+    @Override public long read(Buffer sink, long byteCount) throws IOException {
+      while (left == 0) {
+        source.skip(padding);
+        padding = 0;
+        if ((flags & FLAG_END_HEADERS) != 0) return -1;
+        readContinuationHeader();
+        // TODO: test case for empty continuation header?
+      }
+
+      long read = source.read(sink, Math.min(byteCount, left));
+      if (read == -1) return -1;
+      left -= read;
+      return read;
+    }
+
+    @Override public Timeout timeout() {
+      return source.timeout();
+    }
+
+    @Override public void close() throws IOException {
+    }
+
+    private void readContinuationHeader() throws IOException {
+      int previousStreamId = streamId;
+
+      length = left = readMedium(source);
+      byte type = (byte) (source.readByte() & 0xff);
+      flags = (byte) (source.readByte() & 0xff);
+      if (logger.isLoggable(FINE)) logger.fine(formatHeader(true, streamId, length, type, flags));
+      streamId = (source.readInt() & 0x7fffffff);
+      if (type != TYPE_CONTINUATION) throw ioException("%s != TYPE_CONTINUATION", type);
+      if (streamId != previousStreamId) throw ioException("TYPE_CONTINUATION streamId changed");
+    }
+  }
+
+  static int readMedium(BufferedSource source) throws IOException {
+    return (source.readByte() & 0xff) << 16
+        | (source.readByte() & 0xff) << 8
+        | (source.readByte() & 0xff);
+  }
+
+  static int lengthWithoutPadding(int length, byte flags, short padding)
+      throws IOException {
+    if ((flags & FLAG_PADDED) != 0) length--; // Account for reading the padding length.
+    if (padding > length) {
+      throw ioException("PROTOCOL_ERROR padding %s > remaining length %s", padding, length);
+    }
+    return (short) (length - padding);
+  }
 
   interface Handler {
     void data(boolean inFinished, int streamId, BufferedSource source, int length)
@@ -33,16 +405,14 @@ void data(boolean inFinished, int streamId, BufferedSource source, int length)
 
     /**
      * Create or update incoming headers, creating the corresponding streams if necessary. Frames
-     * that trigger this are SPDY SYN_STREAM, HEADERS, and SYN_REPLY, and HTTP/2 HEADERS and
-     * PUSH_PROMISE.
+     * that trigger this are HEADERS and PUSH_PROMISE.
      *
-     * @param outFinished true if the receiver should not send further frames.
      * @param inFinished true if the sender will not send further frames.
      * @param streamId the stream owning these headers.
      * @param associatedStreamId the stream that triggered the sender to create this stream.
      */
-    void headers(boolean outFinished, boolean inFinished, int streamId, int associatedStreamId,
-        List<Header> headerBlock, HeadersMode headersMode);
+    void headers(boolean inFinished, int streamId, int associatedStreamId,
+        List<Header> headerBlock);
 
     void rstStream(int streamId, ErrorCode errorCode);
 
@@ -52,14 +422,9 @@ void headers(boolean outFinished, boolean inFinished, int streamId, int associat
     void ackSettings();
 
     /**
-     * Read a connection-level ping from the peer.  {@code ack} indicates this is a reply.  Payload
-     * parameters are different between SPDY/3 and HTTP/2.
-     *
-     * <p>In SPDY/3, only the first {@code payload1} parameter is set.  If the reader is a client,
-     * it is an unsigned even number. Likewise, a server will receive an odd number.
-     *
-     * <p>In HTTP/2, both {@code payload1} and {@code payload2} parameters are set. The data is
-     * opaque binary, and there are no rules on the content.
+     * Read a connection-level ping from the peer. {@code ack} indicates this is a reply. The data
+     * in {@code payload1} and {@code payload2} opaque binary, and there are no rules on the
+     * content.
      */
     void ping(boolean ack, int payload1, int payload2);
 
diff --git a/okhttp/src/main/java/okhttp3/internal/framed/FrameWriter.java b/okhttp/src/main/java/okhttp3/internal/framed/FrameWriter.java
index 69830c1701..366378c3cd 100644
--- a/okhttp/src/main/java/okhttp3/internal/framed/FrameWriter.java
+++ b/okhttp/src/main/java/okhttp3/internal/framed/FrameWriter.java
@@ -18,15 +18,74 @@
 import java.io.Closeable;
 import java.io.IOException;
 import java.util.List;
+import java.util.logging.Logger;
 import okio.Buffer;
+import okio.BufferedSink;
 
-/** Writes transport frames for SPDY/3 or HTTP/2. */
-public interface FrameWriter extends Closeable {
-  /** HTTP/2 only. */
-  void connectionPreface() throws IOException;
+import static java.util.logging.Level.FINE;
+import static okhttp3.internal.Util.format;
+import static okhttp3.internal.framed.FrameLogger.formatHeader;
+import static okhttp3.internal.framed.Http2.CONNECTION_PREFACE;
+import static okhttp3.internal.framed.Http2.FLAG_ACK;
+import static okhttp3.internal.framed.Http2.FLAG_END_HEADERS;
+import static okhttp3.internal.framed.Http2.FLAG_END_STREAM;
+import static okhttp3.internal.framed.Http2.FLAG_NONE;
+import static okhttp3.internal.framed.Http2.INITIAL_MAX_FRAME_SIZE;
+import static okhttp3.internal.framed.Http2.TYPE_CONTINUATION;
+import static okhttp3.internal.framed.Http2.TYPE_DATA;
+import static okhttp3.internal.framed.Http2.TYPE_GOAWAY;
+import static okhttp3.internal.framed.Http2.TYPE_HEADERS;
+import static okhttp3.internal.framed.Http2.TYPE_PING;
+import static okhttp3.internal.framed.Http2.TYPE_PUSH_PROMISE;
+import static okhttp3.internal.framed.Http2.TYPE_RST_STREAM;
+import static okhttp3.internal.framed.Http2.TYPE_SETTINGS;
+import static okhttp3.internal.framed.Http2.TYPE_WINDOW_UPDATE;
+import static okhttp3.internal.framed.Http2.illegalArgument;
+
+/** Writes transport frames for HTTP/2. */
+public final class FrameWriter implements Closeable {
+  private static final Logger logger = Logger.getLogger(FrameLogger.class.getName());
+
+  private final BufferedSink sink;
+  private final boolean client;
+  private final Buffer hpackBuffer;
+  private int maxFrameSize;
+  private boolean closed;
+
+  final Hpack.Writer hpackWriter;
+
+  public FrameWriter(BufferedSink sink, boolean client) {
+    this.sink = sink;
+    this.client = client;
+    this.hpackBuffer = new Buffer();
+    this.hpackWriter = new Hpack.Writer(hpackBuffer);
+    this.maxFrameSize = INITIAL_MAX_FRAME_SIZE;
+  }
+
+  public synchronized void connectionPreface() throws IOException {
+    if (closed) throw new IOException("closed");
+    if (!client) return; // Nothing to write; servers don't send connection headers!
+    if (logger.isLoggable(FINE)) {
+      logger.fine(format(">> CONNECTION %s", CONNECTION_PREFACE.hex()));
+    }
+    sink.write(CONNECTION_PREFACE.toByteArray());
+    sink.flush();
+  }
 
   /** Applies {@code peerSettings} and then sends a settings ACK. */
-  void applyAndAckSettings(Settings peerSettings) throws IOException;
+  public synchronized void applyAndAckSettings(Settings peerSettings) throws IOException {
+    if (closed) throw new IOException("closed");
+    this.maxFrameSize = peerSettings.getMaxFrameSize(maxFrameSize);
+    if (peerSettings.getHeaderTableSize() > -1) {
+      hpackWriter.setHeaderTableSizeSetting(peerSettings.getHeaderTableSize());
+    }
+    int length = 0;
+    byte type = TYPE_SETTINGS;
+    byte flags = FLAG_ACK;
+    int streamId = 0;
+    frameHeader(streamId, length, type, flags);
+    sink.flush();
+  }
 
   /**
    * HTTP/2 only. Send a push promise header block.
@@ -41,24 +100,62 @@
    * @param requestHeaders minimally includes {@code :method}, {@code :scheme}, {@code :authority},
    * and (@code :path}.
    */
-  void pushPromise(int streamId, int promisedStreamId, List<Header> requestHeaders)
-      throws IOException;
+  public synchronized void pushPromise(int streamId, int promisedStreamId,
+      List<Header> requestHeaders) throws IOException {
+    if (closed) throw new IOException("closed");
+    hpackWriter.writeHeaders(requestHeaders);
 
-  /** SPDY/3 only. */
-  void flush() throws IOException;
+    long byteCount = hpackBuffer.size();
+    int length = (int) Math.min(maxFrameSize - 4, byteCount);
+    byte type = TYPE_PUSH_PROMISE;
+    byte flags = byteCount == length ? FLAG_END_HEADERS : 0;
+    frameHeader(streamId, length + 4, type, flags);
+    sink.writeInt(promisedStreamId & 0x7fffffff);
+    sink.write(hpackBuffer, length);
 
-  void synStream(boolean outFinished, boolean inFinished, int streamId, int associatedStreamId,
-      List<Header> headerBlock) throws IOException;
+    if (byteCount > length) writeContinuationFrames(streamId, byteCount - length);
+  }
 
-  void synReply(boolean outFinished, int streamId, List<Header> headerBlock)
-      throws IOException;
+  public synchronized void flush() throws IOException {
+    if (closed) throw new IOException("closed");
+    sink.flush();
+  }
 
-  void headers(int streamId, List<Header> headerBlock) throws IOException;
+  public synchronized void synStream(boolean outFinished, int streamId,
+      int associatedStreamId, List<Header> headerBlock) throws IOException {
+    if (closed) throw new IOException("closed");
+    headers(outFinished, streamId, headerBlock);
+  }
 
-  void rstStream(int streamId, ErrorCode errorCode) throws IOException;
+  public synchronized void synReply(boolean outFinished, int streamId,
+      List<Header> headerBlock) throws IOException {
+    if (closed) throw new IOException("closed");
+    headers(outFinished, streamId, headerBlock);
+  }
+
+  public synchronized void headers(int streamId, List<Header> headerBlock)
+      throws IOException {
+    if (closed) throw new IOException("closed");
+    headers(false, streamId, headerBlock);
+  }
+
+  public synchronized void rstStream(int streamId, ErrorCode errorCode)
+      throws IOException {
+    if (closed) throw new IOException("closed");
+    if (errorCode.httpCode == -1) throw new IllegalArgumentException();
+
+    int length = 4;
+    byte type = TYPE_RST_STREAM;
+    byte flags = FLAG_NONE;
+    frameHeader(streamId, length, type, flags);
+    sink.writeInt(errorCode.httpCode);
+    sink.flush();
+  }
 
   /** The maximum size of bytes that may be sent in a single call to {@link #data}. */
-  int maxDataLength();
+  public int maxDataLength() {
+    return maxFrameSize;
+  }
 
   /**
    * {@code source.length} may be longer than the max length of the variant's data frame.
@@ -68,22 +165,59 @@ void synReply(boolean outFinished, int streamId, List<Header> headerBlock)
    * @param byteCount must be between 0 and the minimum of {code source.length} and {@link
    * #maxDataLength}.
    */
-  void data(boolean outFinished, int streamId, Buffer source, int byteCount) throws IOException;
+  public synchronized void data(boolean outFinished, int streamId, Buffer source, int byteCount)
+      throws IOException {
+    if (closed) throw new IOException("closed");
+    byte flags = FLAG_NONE;
+    if (outFinished) flags |= FLAG_END_STREAM;
+    dataFrame(streamId, flags, source, byteCount);
+  }
+
+  void dataFrame(int streamId, byte flags, Buffer buffer, int byteCount) throws IOException {
+    byte type = TYPE_DATA;
+    frameHeader(streamId, byteCount, type, flags);
+    if (byteCount > 0) {
+      sink.write(buffer, byteCount);
+    }
+  }
 
   /** Write okhttp's settings to the peer. */
-  void settings(Settings okHttpSettings) throws IOException;
+  public synchronized void settings(Settings settings) throws IOException {
+    if (closed) throw new IOException("closed");
+    int length = settings.size() * 6;
+    byte type = TYPE_SETTINGS;
+    byte flags = FLAG_NONE;
+    int streamId = 0;
+    frameHeader(streamId, length, type, flags);
+    for (int i = 0; i < Settings.COUNT; i++) {
+      if (!settings.isSet(i)) continue;
+      int id = i;
+      if (id == 4) {
+        id = 3; // SETTINGS_MAX_CONCURRENT_STREAMS renumbered.
+      } else if (id == 7) {
+        id = 4; // SETTINGS_INITIAL_WINDOW_SIZE renumbered.
+      }
+      sink.writeShort(id);
+      sink.writeInt(settings.get(i));
+    }
+    sink.flush();
+  }
 
   /**
-   * Send a connection-level ping to the peer.  {@code ack} indicates this is a reply.  Payload
-   * parameters are different between SPDY/3 and HTTP/2.
-   *
-   * <p>In SPDY/3, only the first {@code payload1} parameter is sent.  If the sender is a client, it
-   * is an unsigned odd number. Likewise, a server will send an even number.
-   *
-   * <p>In HTTP/2, both {@code payload1} and {@code payload2} parameters are sent.  The data is
-   * opaque binary, and there are no rules on the content.
+   * Send a connection-level ping to the peer. {@code ack} indicates this is a reply. The data in
+   * {@code payload1} and {@code payload2} opaque binary, and there are no rules on the content.
    */
-  void ping(boolean ack, int payload1, int payload2) throws IOException;
+  public synchronized void ping(boolean ack, int payload1, int payload2) throws IOException {
+    if (closed) throw new IOException("closed");
+    int length = 8;
+    byte type = TYPE_PING;
+    byte flags = ack ? FLAG_ACK : FLAG_NONE;
+    int streamId = 0;
+    frameHeader(streamId, length, type, flags);
+    sink.writeInt(payload1);
+    sink.writeInt(payload2);
+    sink.flush();
+  }
 
   /**
    * Tell the peer to stop creating streams and that we last processed {@code lastGoodStreamId}, or
@@ -93,11 +227,85 @@ void synReply(boolean outFinished, int streamId, List<Header> headerBlock)
    * @param errorCode reason for closing the connection.
    * @param debugData only valid for HTTP/2; opaque debug data to send.
    */
-  void goAway(int lastGoodStreamId, ErrorCode errorCode, byte[] debugData) throws IOException;
+  public synchronized void goAway(int lastGoodStreamId, ErrorCode errorCode, byte[] debugData)
+      throws IOException {
+    if (closed) throw new IOException("closed");
+    if (errorCode.httpCode == -1) throw illegalArgument("errorCode.httpCode == -1");
+    int length = 8 + debugData.length;
+    byte type = TYPE_GOAWAY;
+    byte flags = FLAG_NONE;
+    int streamId = 0;
+    frameHeader(streamId, length, type, flags);
+    sink.writeInt(lastGoodStreamId);
+    sink.writeInt(errorCode.httpCode);
+    if (debugData.length > 0) {
+      sink.write(debugData);
+    }
+    sink.flush();
+  }
 
   /**
    * Inform peer that an additional {@code windowSizeIncrement} bytes can be sent on {@code
    * streamId}, or the connection if {@code streamId} is zero.
    */
-  void windowUpdate(int streamId, long windowSizeIncrement) throws IOException;
+  public synchronized void windowUpdate(int streamId, long windowSizeIncrement) throws IOException {
+    if (closed) throw new IOException("closed");
+    if (windowSizeIncrement == 0 || windowSizeIncrement > 0x7fffffffL) {
+      throw illegalArgument("windowSizeIncrement == 0 || windowSizeIncrement > 0x7fffffffL: %s",
+          windowSizeIncrement);
+    }
+    int length = 4;
+    byte type = TYPE_WINDOW_UPDATE;
+    byte flags = FLAG_NONE;
+    frameHeader(streamId, length, type, flags);
+    sink.writeInt((int) windowSizeIncrement);
+    sink.flush();
+  }
+
+  public void frameHeader(int streamId, int length, byte type, byte flags) throws IOException {
+    if (logger.isLoggable(FINE)) logger.fine(formatHeader(false, streamId, length, type, flags));
+    if (length > maxFrameSize) {
+      throw illegalArgument("FRAME_SIZE_ERROR length > %d: %d", maxFrameSize, length);
+    }
+    if ((streamId & 0x80000000) != 0) throw illegalArgument("reserved bit set: %s", streamId);
+    writeMedium(sink, length);
+    sink.writeByte(type & 0xff);
+    sink.writeByte(flags & 0xff);
+    sink.writeInt(streamId & 0x7fffffff);
+  }
+
+  @Override public synchronized void close() throws IOException {
+    closed = true;
+    sink.close();
+  }
+
+  private static void writeMedium(BufferedSink sink, int i) throws IOException {
+    sink.writeByte((i >>> 16) & 0xff);
+    sink.writeByte((i >>> 8) & 0xff);
+    sink.writeByte(i & 0xff);
+  }
+
+  private void writeContinuationFrames(int streamId, long byteCount) throws IOException {
+    while (byteCount > 0) {
+      int length = (int) Math.min(maxFrameSize, byteCount);
+      byteCount -= length;
+      frameHeader(streamId, length, TYPE_CONTINUATION, byteCount == 0 ? FLAG_END_HEADERS : 0);
+      sink.write(hpackBuffer, length);
+    }
+  }
+
+  void headers(boolean outFinished, int streamId, List<Header> headerBlock) throws IOException {
+    if (closed) throw new IOException("closed");
+    hpackWriter.writeHeaders(headerBlock);
+
+    long byteCount = hpackBuffer.size();
+    int length = (int) Math.min(maxFrameSize, byteCount);
+    byte type = TYPE_HEADERS;
+    byte flags = byteCount == length ? FLAG_END_HEADERS : 0;
+    if (outFinished) flags |= FLAG_END_STREAM;
+    frameHeader(streamId, length, type, flags);
+    sink.write(hpackBuffer, length);
+
+    if (byteCount > length) writeContinuationFrames(streamId, byteCount - length);
+  }
 }
diff --git a/okhttp/src/main/java/okhttp3/internal/framed/FramedConnection.java b/okhttp/src/main/java/okhttp3/internal/framed/FramedConnection.java
index aa3a70c16e..8a6d56c2ab 100644
--- a/okhttp/src/main/java/okhttp3/internal/framed/FramedConnection.java
+++ b/okhttp/src/main/java/okhttp3/internal/framed/FramedConnection.java
@@ -48,7 +48,7 @@
  * data.
  *
  * <p>Many methods in this API are <strong>synchronous:</strong> the call is completed before the
- * method returns. This is typical for Java but atypical for SPDY. This is motivated by exception
+ * method returns. This is typical for Java but atypical for HTTP/2. This is motivated by exception
  * transparency: an IOException that was triggered by a certain caller can be caught and handled by
  * that caller.
  */
@@ -70,9 +70,6 @@
       Integer.MAX_VALUE, 60, TimeUnit.SECONDS, new SynchronousQueue<Runnable>(),
       Util.threadFactory("OkHttp FramedConnection", true));
 
-  /** The protocol variant, like {@link Spdy3}. */
-  final Protocol protocol;
-
   /** True if this peer initiated the connection. */
   final boolean client;
 
@@ -119,7 +116,6 @@
   final Settings peerSettings = new Settings();
 
   private boolean receivedInitialPeerSettings = false;
-  final Variant variant;
   final Socket socket;
   final FrameWriter frameWriter;
 
@@ -127,13 +123,12 @@
   final Reader readerRunnable;
 
   private FramedConnection(Builder builder) {
-    protocol = builder.protocol;
     pushObserver = builder.pushObserver;
     client = builder.client;
     listener = builder.listener;
     // http://tools.ietf.org/html/draft-ietf-httpbis-http2-17#section-5.1.1
     nextStreamId = builder.client ? 1 : 2;
-    if (builder.client && protocol == Protocol.HTTP_2) {
+    if (builder.client) {
       nextStreamId += 2; // In HTTP/2, 1 on client is reserved for Upgrade.
     }
 
@@ -144,36 +139,27 @@ private FramedConnection(Builder builder) {
     // thrashing window updates every 64KiB, yet small enough to avoid blowing
     // up the heap.
     if (builder.client) {
-      okHttpSettings.set(Settings.INITIAL_WINDOW_SIZE, 0, OKHTTP_CLIENT_WINDOW_SIZE);
+      okHttpSettings.set(Settings.INITIAL_WINDOW_SIZE, OKHTTP_CLIENT_WINDOW_SIZE);
     }
 
     hostname = builder.hostname;
 
-    if (protocol == Protocol.HTTP_2) {
-      variant = new Http2();
-      // Like newSingleThreadExecutor, except lazy creates the thread.
-      pushExecutor = new ThreadPoolExecutor(0, 1, 60, TimeUnit.SECONDS,
-          new LinkedBlockingQueue<Runnable>(),
-          Util.threadFactory(Util.format("OkHttp %s Push Observer", hostname), true));
-      // 1 less than SPDY http://tools.ietf.org/html/draft-ietf-httpbis-http2-17#section-6.9.2
-      peerSettings.set(Settings.INITIAL_WINDOW_SIZE, 0, 65535);
-      peerSettings.set(Settings.MAX_FRAME_SIZE, 0, Http2.INITIAL_MAX_FRAME_SIZE);
-    } else if (protocol == Protocol.SPDY_3) {
-      variant = new Spdy3();
-      pushExecutor = null;
-    } else {
-      throw new AssertionError(protocol);
-    }
-    bytesLeftInWriteWindow = peerSettings.getInitialWindowSize(DEFAULT_INITIAL_WINDOW_SIZE);
+    // Like newSingleThreadExecutor, except lazy creates the thread.
+    pushExecutor = new ThreadPoolExecutor(0, 1, 60, TimeUnit.SECONDS,
+        new LinkedBlockingQueue<Runnable>(),
+        Util.threadFactory(Util.format("OkHttp %s Push Observer", hostname), true));
+    peerSettings.set(Settings.INITIAL_WINDOW_SIZE, DEFAULT_INITIAL_WINDOW_SIZE);
+    peerSettings.set(Settings.MAX_FRAME_SIZE, Http2.INITIAL_MAX_FRAME_SIZE);
+    bytesLeftInWriteWindow = peerSettings.getInitialWindowSize();
     socket = builder.socket;
-    frameWriter = variant.newWriter(builder.sink, client);
+    frameWriter = new FrameWriter(builder.sink, client);
 
-    readerRunnable = new Reader(variant.newReader(builder.source, client));
+    readerRunnable = new Reader(new FrameReader(builder.source, client));
   }
 
   /** The protocol as selected using ALPN. */
   public Protocol getProtocol() {
-    return protocol;
+    return Protocol.HTTP_2;
   }
 
   /**
@@ -207,27 +193,22 @@ public synchronized int maxConcurrentStreams() {
   public FramedStream pushStream(int associatedStreamId, List<Header> requestHeaders, boolean out)
       throws IOException {
     if (client) throw new IllegalStateException("Client cannot push requests.");
-    if (protocol != Protocol.HTTP_2) throw new IllegalStateException("protocol != HTTP_2");
-    return newStream(associatedStreamId, requestHeaders, out, false);
+    return newStream(associatedStreamId, requestHeaders, out);
   }
 
   /**
    * Returns a new locally-initiated stream.
-   *
    * @param out true to create an output stream that we can use to send data to the remote peer.
    * Corresponds to {@code FLAG_FIN}.
-   * @param in true to create an input stream that the remote peer can use to send data to us.
-   * Corresponds to {@code FLAG_UNIDIRECTIONAL}.
    */
-  public FramedStream newStream(List<Header> requestHeaders, boolean out, boolean in)
-      throws IOException {
-    return newStream(0, requestHeaders, out, in);
+  public FramedStream newStream(List<Header> requestHeaders, boolean out) throws IOException {
+    return newStream(0, requestHeaders, out);
   }
 
-  private FramedStream newStream(int associatedStreamId, List<Header> requestHeaders, boolean out,
-      boolean in) throws IOException {
+  private FramedStream newStream(
+      int associatedStreamId, List<Header> requestHeaders, boolean out) throws IOException {
     boolean outFinished = !out;
-    boolean inFinished = !in;
+    boolean inFinished = false;
     boolean flushHeaders;
     FramedStream stream;
     int streamId;
@@ -246,8 +227,7 @@ private FramedStream newStream(int associatedStreamId, List<Header> requestHeade
         }
       }
       if (associatedStreamId == 0) {
-        frameWriter.synStream(outFinished, inFinished, streamId, associatedStreamId,
-            requestHeaders);
+        frameWriter.synStream(outFinished, streamId, associatedStreamId, requestHeaders);
       } else if (client) {
         throw new IllegalArgumentException("client streams shouldn't have associated stream IDs");
       } else { // HTTP/2 has a PUSH_PROMISE frame.
@@ -494,7 +474,7 @@ void start(boolean sendConnectionPreface) throws IOException {
     if (sendConnectionPreface) {
       frameWriter.connectionPreface();
       frameWriter.settings(okHttpSettings);
-      int windowSize = okHttpSettings.getInitialWindowSize(Settings.DEFAULT_INITIAL_WINDOW_SIZE);
+      int windowSize = okHttpSettings.getInitialWindowSize();
       if (windowSize != Settings.DEFAULT_INITIAL_WINDOW_SIZE) {
         frameWriter.windowUpdate(0, windowSize - Settings.DEFAULT_INITIAL_WINDOW_SIZE);
       }
@@ -521,7 +501,6 @@ public void setSettings(Settings settings) throws IOException {
     private BufferedSource source;
     private BufferedSink sink;
     private Listener listener = Listener.REFUSE_INCOMING_STREAMS;
-    private Protocol protocol = Protocol.SPDY_3;
     private PushObserver pushObserver = PushObserver.CANCEL;
     private boolean client;
 
@@ -552,11 +531,6 @@ public Builder listener(Listener listener) {
       return this;
     }
 
-    public Builder protocol(Protocol protocol) {
-      this.protocol = protocol;
-      return this;
-    }
-
     public Builder pushObserver(PushObserver pushObserver) {
       this.pushObserver = pushObserver;
       return this;
@@ -610,7 +584,7 @@ private Reader(FrameReader frameReader) {
       }
       FramedStream dataStream = getStream(streamId);
       if (dataStream == null) {
-        writeSynResetLater(streamId, ErrorCode.INVALID_STREAM);
+        writeSynResetLater(streamId, ErrorCode.PROTOCOL_ERROR);
         source.skip(length);
         return;
       }
@@ -620,8 +594,8 @@ private Reader(FrameReader frameReader) {
       }
     }
 
-    @Override public void headers(boolean outFinished, boolean inFinished, int streamId,
-        int associatedStreamId, List<Header> headerBlock, HeadersMode headersMode) {
+    @Override public void headers(boolean inFinished, int streamId, int associatedStreamId,
+        List<Header> headerBlock) {
       if (pushedStream(streamId)) {
         pushHeadersLater(streamId, headerBlock, inFinished);
         return;
@@ -634,12 +608,6 @@ private Reader(FrameReader frameReader) {
         stream = getStream(streamId);
 
         if (stream == null) {
-          // The headers claim to be for an existing stream, but we don't have one.
-          if (headersMode.failIfStreamAbsent()) {
-            writeSynResetLater(streamId, ErrorCode.INVALID_STREAM);
-            return;
-          }
-
           // If the stream ID is less than the last created ID, assume it's already closed.
           if (streamId <= lastGoodStreamId) return;
 
@@ -647,9 +615,8 @@ private Reader(FrameReader frameReader) {
           if (streamId % 2 == nextStreamId % 2) return;
 
           // Create a stream.
-          final FramedStream
-              newStream = new FramedStream(streamId, FramedConnection.this, outFinished,
-              inFinished, headerBlock);
+          final FramedStream newStream = new FramedStream(streamId, FramedConnection.this,
+              false, inFinished, headerBlock);
           lastGoodStreamId = streamId;
           streams.put(streamId, newStream);
           executor.execute(new NamedRunnable("OkHttp %s stream %d", hostname, streamId) {
@@ -669,15 +636,8 @@ private Reader(FrameReader frameReader) {
         }
       }
 
-      // The headers claim to be for a new stream, but we already have one.
-      if (headersMode.failIfStreamPresent()) {
-        stream.closeLater(ErrorCode.PROTOCOL_ERROR);
-        removeStream(streamId);
-        return;
-      }
-
       // Update an existing stream.
-      stream.receiveHeaders(headerBlock, headersMode);
+      stream.receiveHeaders(headerBlock);
       if (inFinished) stream.receiveFin();
     }
 
@@ -696,13 +656,11 @@ private Reader(FrameReader frameReader) {
       long delta = 0;
       FramedStream[] streamsToNotify = null;
       synchronized (FramedConnection.this) {
-        int priorWriteWindowSize = peerSettings.getInitialWindowSize(DEFAULT_INITIAL_WINDOW_SIZE);
+        int priorWriteWindowSize = peerSettings.getInitialWindowSize();
         if (clearPrevious) peerSettings.clear();
         peerSettings.merge(newSettings);
-        if (getProtocol() == Protocol.HTTP_2) {
-          applyAndAckSettings(newSettings);
-        }
-        int peerInitialWindowSize = peerSettings.getInitialWindowSize(DEFAULT_INITIAL_WINDOW_SIZE);
+        applyAndAckSettings(newSettings);
+        int peerInitialWindowSize = peerSettings.getInitialWindowSize();
         if (peerInitialWindowSize != -1 && peerInitialWindowSize != priorWriteWindowSize) {
           delta = peerInitialWindowSize - priorWriteWindowSize;
           if (!receivedInitialPeerSettings) {
@@ -809,7 +767,7 @@ public void pushPromise(int streamId, int promisedStreamId, List<Header> request
 
   /** Even, positive numbered streams are pushed streams in HTTP/2. */
   private boolean pushedStream(int streamId) {
-    return protocol == Protocol.HTTP_2 && streamId != 0 && (streamId & 1) == 0;
+    return streamId != 0 && (streamId & 1) == 0;
   }
 
   // Guarded by this.
diff --git a/okhttp/src/main/java/okhttp3/internal/framed/FramedStream.java b/okhttp/src/main/java/okhttp3/internal/framed/FramedStream.java
index d6ce15eeb6..78ebc0f387 100644
--- a/okhttp/src/main/java/okhttp3/internal/framed/FramedStream.java
+++ b/okhttp/src/main/java/okhttp3/internal/framed/FramedStream.java
@@ -28,8 +28,6 @@
 import okio.Source;
 import okio.Timeout;
 
-import static okhttp3.internal.framed.Settings.DEFAULT_INITIAL_WINDOW_SIZE;
-
 /** A logical bidirectional stream. */
 public final class FramedStream {
   // Internal state is guarded by this. No long-running or potentially
@@ -78,9 +76,9 @@
     this.id = id;
     this.connection = connection;
     this.bytesLeftInWriteWindow =
-        connection.peerSettings.getInitialWindowSize(DEFAULT_INITIAL_WINDOW_SIZE);
+        connection.peerSettings.getInitialWindowSize();
     this.source = new FramedDataSource(
-        connection.okHttpSettings.getInitialWindowSize(DEFAULT_INITIAL_WINDOW_SIZE));
+        connection.okHttpSettings.getInitialWindowSize());
     this.sink = new FramedDataSink();
     this.source.finished = inFinished;
     this.sink.finished = outFinished;
@@ -249,33 +247,22 @@ private boolean closeInternal(ErrorCode errorCode) {
     return true;
   }
 
-  void receiveHeaders(List<Header> headers, HeadersMode headersMode) {
+  void receiveHeaders(List<Header> headers) {
     assert (!Thread.holdsLock(FramedStream.this));
-    ErrorCode errorCode = null;
     boolean open = true;
     synchronized (this) {
       if (responseHeaders == null) {
-        if (headersMode.failIfHeadersAbsent()) {
-          errorCode = ErrorCode.PROTOCOL_ERROR;
-        } else {
-          responseHeaders = headers;
-          open = isOpen();
-          notifyAll();
-        }
+        responseHeaders = headers;
+        open = isOpen();
+        notifyAll();
       } else {
-        if (headersMode.failIfHeadersPresent()) {
-          errorCode = ErrorCode.STREAM_IN_USE;
-        } else {
-          List<Header> newHeaders = new ArrayList<>();
-          newHeaders.addAll(responseHeaders);
-          newHeaders.addAll(headers);
-          this.responseHeaders = newHeaders;
-        }
+        List<Header> newHeaders = new ArrayList<>();
+        newHeaders.addAll(responseHeaders);
+        newHeaders.addAll(headers);
+        this.responseHeaders = newHeaders;
       }
     }
-    if (errorCode != null) {
-      closeLater(errorCode);
-    } else if (!open) {
+    if (!open) {
       connection.removeStream(id);
     }
   }
@@ -349,7 +336,7 @@ private FramedDataSource(long maxByteCount) {
         // Flow control: notify the peer that we're ready for more data!
         unacknowledgedBytesRead += read;
         if (unacknowledgedBytesRead
-            >= connection.okHttpSettings.getInitialWindowSize(DEFAULT_INITIAL_WINDOW_SIZE) / 2) {
+            >= connection.okHttpSettings.getInitialWindowSize() / 2) {
           connection.writeWindowUpdateLater(id, unacknowledgedBytesRead);
           unacknowledgedBytesRead = 0;
         }
@@ -359,7 +346,7 @@ private FramedDataSource(long maxByteCount) {
       synchronized (connection) { // Multiple application threads may hit this section.
         connection.unacknowledgedBytesRead += read;
         if (connection.unacknowledgedBytesRead
-            >= connection.okHttpSettings.getInitialWindowSize(DEFAULT_INITIAL_WINDOW_SIZE) / 2) {
+            >= connection.okHttpSettings.getInitialWindowSize() / 2) {
           connection.writeWindowUpdateLater(0, connection.unacknowledgedBytesRead);
           connection.unacknowledgedBytesRead = 0;
         }
diff --git a/okhttp/src/main/java/okhttp3/internal/framed/Header.java b/okhttp/src/main/java/okhttp3/internal/framed/Header.java
index 866edc2591..49fbecfebf 100644
--- a/okhttp/src/main/java/okhttp3/internal/framed/Header.java
+++ b/okhttp/src/main/java/okhttp3/internal/framed/Header.java
@@ -20,14 +20,12 @@
 
 /** HTTP header: the name is an ASCII string, but the value can be UTF-8. */
 public final class Header {
-  // Special header names defined in the SPDY and HTTP/2 specs.
+  // Special header names defined in HTTP/2 spec.
   public static final ByteString RESPONSE_STATUS = ByteString.encodeUtf8(":status");
   public static final ByteString TARGET_METHOD = ByteString.encodeUtf8(":method");
   public static final ByteString TARGET_PATH = ByteString.encodeUtf8(":path");
   public static final ByteString TARGET_SCHEME = ByteString.encodeUtf8(":scheme");
-  public static final ByteString TARGET_AUTHORITY = ByteString.encodeUtf8(":authority"); // HTTP/2
-  public static final ByteString TARGET_HOST = ByteString.encodeUtf8(":host"); // spdy/3
-  public static final ByteString VERSION = ByteString.encodeUtf8(":version"); // spdy/3
+  public static final ByteString TARGET_AUTHORITY = ByteString.encodeUtf8(":authority");
 
   /** Name in case-insensitive ASCII encoding. */
   public final ByteString name;
diff --git a/okhttp/src/main/java/okhttp3/internal/framed/HeadersMode.java b/okhttp/src/main/java/okhttp3/internal/framed/HeadersMode.java
deleted file mode 100644
index bc851ed784..0000000000
--- a/okhttp/src/main/java/okhttp3/internal/framed/HeadersMode.java
+++ /dev/null
@@ -1,47 +0,0 @@
-/*
- * Copyright (C) 2013 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.internal.framed;
-
-public enum HeadersMode {
-  SPDY_SYN_STREAM,
-  SPDY_REPLY,
-  SPDY_HEADERS,
-  HTTP_20_HEADERS;
-
-  /** Returns true if it is an error these headers to create a new stream. */
-  public boolean failIfStreamAbsent() {
-    return this == SPDY_REPLY || this == SPDY_HEADERS;
-  }
-
-  /** Returns true if it is an error these headers to update an existing stream. */
-  public boolean failIfStreamPresent() {
-    return this == SPDY_SYN_STREAM;
-  }
-
-  /**
-   * Returns true if it is an error these headers to be the initial headers of a response.
-   */
-  public boolean failIfHeadersAbsent() {
-    return this == SPDY_HEADERS;
-  }
-
-  /**
-   * Returns true if it is an error these headers to be update existing headers of a response.
-   */
-  public boolean failIfHeadersPresent() {
-    return this == SPDY_REPLY;
-  }
-}
diff --git a/okhttp/src/main/java/okhttp3/internal/framed/Http2.java b/okhttp/src/main/java/okhttp3/internal/framed/Http2.java
index 56b1219ae0..c4332d0cab 100644
--- a/okhttp/src/main/java/okhttp3/internal/framed/Http2.java
+++ b/okhttp/src/main/java/okhttp3/internal/framed/Http2.java
@@ -16,36 +16,12 @@
 package okhttp3.internal.framed;
 
 import java.io.IOException;
-import java.util.List;
-import java.util.logging.Logger;
-import okhttp3.Protocol;
-import okio.Buffer;
-import okio.BufferedSink;
-import okio.BufferedSource;
 import okio.ByteString;
-import okio.Source;
-import okio.Timeout;
 
-import static java.util.logging.Level.FINE;
 import static okhttp3.internal.Util.format;
-import static okhttp3.internal.framed.Http2.FrameLogger.formatHeader;
-import static okio.ByteString.EMPTY;
 
-/**
- * Read and write HTTP/2 frames.
- *
- * <p>This implementation assumes we do not send an increased {@link Settings#getMaxFrameSize frame
- * size setting} to the peer. Hence, we expect all frames to have a max length of {@link
- * #INITIAL_MAX_FRAME_SIZE}. <p>http://tools.ietf.org/html/draft-ietf-httpbis-http2-17
- */
-public final class Http2 implements Variant {
-  private static final Logger logger = Logger.getLogger(FrameLogger.class.getName());
-
-  @Override public Protocol getProtocol() {
-    return Protocol.HTTP_2;
-  }
-
-  private static final ByteString CONNECTION_PREFACE
+public final class Http2 {
+  static final ByteString CONNECTION_PREFACE
       = ByteString.encodeUtf8("PRI * HTTP/2.0\r\n\r\nSM\r\n\r\n");
 
   /** The initial max frame size, applied independently writing to, or reading from the peer. */
@@ -71,702 +47,14 @@
   static final byte FLAG_PRIORITY = 0x20; // Used for headers.
   static final byte FLAG_COMPRESSED = 0x20; // Used for data.
 
-  /**
-   * Creates a frame reader with max header table size of 4096 and data frame compression disabled.
-   */
-  @Override public FrameReader newReader(BufferedSource source, boolean client) {
-    return new Reader(source, 4096, client);
-  }
-
-  @Override public FrameWriter newWriter(BufferedSink sink, boolean client) {
-    return new Writer(sink, client);
+  private Http2() {
   }
 
-  static final class Reader implements FrameReader {
-    private final BufferedSource source;
-    private final ContinuationSource continuation;
-    private final boolean client;
-
-    // Visible for testing.
-    final Hpack.Reader hpackReader;
-
-    Reader(BufferedSource source, int headerTableSize, boolean client) {
-      this.source = source;
-      this.client = client;
-      this.continuation = new ContinuationSource(this.source);
-      this.hpackReader = new Hpack.Reader(headerTableSize, continuation);
-    }
-
-    @Override public void readConnectionPreface() throws IOException {
-      if (client) return; // Nothing to read; servers doesn't send a connection preface!
-      ByteString connectionPreface = source.readByteString(CONNECTION_PREFACE.size());
-      if (logger.isLoggable(FINE)) logger.fine(format("<< CONNECTION %s", connectionPreface.hex()));
-      if (!CONNECTION_PREFACE.equals(connectionPreface)) {
-        throw ioException("Expected a connection header but was %s", connectionPreface.utf8());
-      }
-    }
-
-    @Override public boolean nextFrame(Handler handler) throws IOException {
-      try {
-        source.require(9); // Frame header size
-      } catch (IOException e) {
-        return false; // This might be a normal socket close.
-      }
-
-      /*  0                   1                   2                   3
-       *  0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
-       * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
-       * |                 Length (24)                   |
-       * +---------------+---------------+---------------+
-       * |   Type (8)    |   Flags (8)   |
-       * +-+-+-----------+---------------+-------------------------------+
-       * |R|                 Stream Identifier (31)                      |
-       * +=+=============================================================+
-       * |                   Frame Payload (0...)                      ...
-       * +---------------------------------------------------------------+
-       */
-      int length = readMedium(source);
-      if (length < 0 || length > INITIAL_MAX_FRAME_SIZE) {
-        throw ioException("FRAME_SIZE_ERROR: %s", length);
-      }
-      byte type = (byte) (source.readByte() & 0xff);
-      byte flags = (byte) (source.readByte() & 0xff);
-      int streamId = (source.readInt() & 0x7fffffff); // Ignore reserved bit.
-      if (logger.isLoggable(FINE)) logger.fine(formatHeader(true, streamId, length, type, flags));
-
-      switch (type) {
-        case TYPE_DATA:
-          readData(handler, length, flags, streamId);
-          break;
-
-        case TYPE_HEADERS:
-          readHeaders(handler, length, flags, streamId);
-          break;
-
-        case TYPE_PRIORITY:
-          readPriority(handler, length, flags, streamId);
-          break;
-
-        case TYPE_RST_STREAM:
-          readRstStream(handler, length, flags, streamId);
-          break;
-
-        case TYPE_SETTINGS:
-          readSettings(handler, length, flags, streamId);
-          break;
-
-        case TYPE_PUSH_PROMISE:
-          readPushPromise(handler, length, flags, streamId);
-          break;
-
-        case TYPE_PING:
-          readPing(handler, length, flags, streamId);
-          break;
-
-        case TYPE_GOAWAY:
-          readGoAway(handler, length, flags, streamId);
-          break;
-
-        case TYPE_WINDOW_UPDATE:
-          readWindowUpdate(handler, length, flags, streamId);
-          break;
-
-        default:
-          // Implementations MUST discard frames that have unknown or unsupported types.
-          source.skip(length);
-      }
-      return true;
-    }
-
-    private void readHeaders(Handler handler, int length, byte flags, int streamId)
-        throws IOException {
-      if (streamId == 0) throw ioException("PROTOCOL_ERROR: TYPE_HEADERS streamId == 0");
-
-      boolean endStream = (flags & FLAG_END_STREAM) != 0;
-
-      short padding = (flags & FLAG_PADDED) != 0 ? (short) (source.readByte() & 0xff) : 0;
-
-      if ((flags & FLAG_PRIORITY) != 0) {
-        readPriority(handler, streamId);
-        length -= 5; // account for above read.
-      }
-
-      length = lengthWithoutPadding(length, flags, padding);
-
-      List<Header> headerBlock = readHeaderBlock(length, padding, flags, streamId);
-
-      handler.headers(false, endStream, streamId, -1, headerBlock, HeadersMode.HTTP_20_HEADERS);
-    }
-
-    private List<Header> readHeaderBlock(int length, short padding, byte flags, int streamId)
-        throws IOException {
-      continuation.length = continuation.left = length;
-      continuation.padding = padding;
-      continuation.flags = flags;
-      continuation.streamId = streamId;
-
-      // TODO: Concat multi-value headers with 0x0, except COOKIE, which uses 0x3B, 0x20.
-      // http://tools.ietf.org/html/draft-ietf-httpbis-http2-17#section-8.1.2.5
-      hpackReader.readHeaders();
-      return hpackReader.getAndResetHeaderList();
-    }
-
-    private void readData(Handler handler, int length, byte flags, int streamId)
-        throws IOException {
-      // TODO: checkState open or half-closed (local) or raise STREAM_CLOSED
-      boolean inFinished = (flags & FLAG_END_STREAM) != 0;
-      boolean gzipped = (flags & FLAG_COMPRESSED) != 0;
-      if (gzipped) {
-        throw ioException("PROTOCOL_ERROR: FLAG_COMPRESSED without SETTINGS_COMPRESS_DATA");
-      }
-
-      short padding = (flags & FLAG_PADDED) != 0 ? (short) (source.readByte() & 0xff) : 0;
-      length = lengthWithoutPadding(length, flags, padding);
-
-      handler.data(inFinished, streamId, source, length);
-      source.skip(padding);
-    }
-
-    private void readPriority(Handler handler, int length, byte flags, int streamId)
-        throws IOException {
-      if (length != 5) throw ioException("TYPE_PRIORITY length: %d != 5", length);
-      if (streamId == 0) throw ioException("TYPE_PRIORITY streamId == 0");
-      readPriority(handler, streamId);
-    }
-
-    private void readPriority(Handler handler, int streamId) throws IOException {
-      int w1 = source.readInt();
-      boolean exclusive = (w1 & 0x80000000) != 0;
-      int streamDependency = (w1 & 0x7fffffff);
-      int weight = (source.readByte() & 0xff) + 1;
-      handler.priority(streamId, streamDependency, weight, exclusive);
-    }
-
-    private void readRstStream(Handler handler, int length, byte flags, int streamId)
-        throws IOException {
-      if (length != 4) throw ioException("TYPE_RST_STREAM length: %d != 4", length);
-      if (streamId == 0) throw ioException("TYPE_RST_STREAM streamId == 0");
-      int errorCodeInt = source.readInt();
-      ErrorCode errorCode = ErrorCode.fromHttp2(errorCodeInt);
-      if (errorCode == null) {
-        throw ioException("TYPE_RST_STREAM unexpected error code: %d", errorCodeInt);
-      }
-      handler.rstStream(streamId, errorCode);
-    }
-
-    private void readSettings(Handler handler, int length, byte flags, int streamId)
-        throws IOException {
-      if (streamId != 0) throw ioException("TYPE_SETTINGS streamId != 0");
-      if ((flags & FLAG_ACK) != 0) {
-        if (length != 0) throw ioException("FRAME_SIZE_ERROR ack frame should be empty!");
-        handler.ackSettings();
-        return;
-      }
-
-      if (length % 6 != 0) throw ioException("TYPE_SETTINGS length %% 6 != 0: %s", length);
-      Settings settings = new Settings();
-      for (int i = 0; i < length; i += 6) {
-        short id = source.readShort();
-        int value = source.readInt();
-
-        switch (id) {
-          case 1: // SETTINGS_HEADER_TABLE_SIZE
-            break;
-          case 2: // SETTINGS_ENABLE_PUSH
-            if (value != 0 && value != 1) {
-              throw ioException("PROTOCOL_ERROR SETTINGS_ENABLE_PUSH != 0 or 1");
-            }
-            break;
-          case 3: // SETTINGS_MAX_CONCURRENT_STREAMS
-            id = 4; // Renumbered in draft 10.
-            break;
-          case 4: // SETTINGS_INITIAL_WINDOW_SIZE
-            id = 7; // Renumbered in draft 10.
-            if (value < 0) {
-              throw ioException("PROTOCOL_ERROR SETTINGS_INITIAL_WINDOW_SIZE > 2^31 - 1");
-            }
-            break;
-          case 5: // SETTINGS_MAX_FRAME_SIZE
-            if (value < INITIAL_MAX_FRAME_SIZE || value > 16777215) {
-              throw ioException("PROTOCOL_ERROR SETTINGS_MAX_FRAME_SIZE: %s", value);
-            }
-            break;
-          case 6: // SETTINGS_MAX_HEADER_LIST_SIZE
-            break; // Advisory only, so ignored.
-          default:
-            break; // Must ignore setting with unknown id.
-        }
-        settings.set(id, 0, value);
-      }
-      handler.settings(false, settings);
-    }
-
-    private void readPushPromise(Handler handler, int length, byte flags, int streamId)
-        throws IOException {
-      if (streamId == 0) {
-        throw ioException("PROTOCOL_ERROR: TYPE_PUSH_PROMISE streamId == 0");
-      }
-      short padding = (flags & FLAG_PADDED) != 0 ? (short) (source.readByte() & 0xff) : 0;
-      int promisedStreamId = source.readInt() & 0x7fffffff;
-      length -= 4; // account for above read.
-      length = lengthWithoutPadding(length, flags, padding);
-      List<Header> headerBlock = readHeaderBlock(length, padding, flags, streamId);
-      handler.pushPromise(streamId, promisedStreamId, headerBlock);
-    }
-
-    private void readPing(Handler handler, int length, byte flags, int streamId)
-        throws IOException {
-      if (length != 8) throw ioException("TYPE_PING length != 8: %s", length);
-      if (streamId != 0) throw ioException("TYPE_PING streamId != 0");
-      int payload1 = source.readInt();
-      int payload2 = source.readInt();
-      boolean ack = (flags & FLAG_ACK) != 0;
-      handler.ping(ack, payload1, payload2);
-    }
-
-    private void readGoAway(Handler handler, int length, byte flags, int streamId)
-        throws IOException {
-      if (length < 8) throw ioException("TYPE_GOAWAY length < 8: %s", length);
-      if (streamId != 0) throw ioException("TYPE_GOAWAY streamId != 0");
-      int lastStreamId = source.readInt();
-      int errorCodeInt = source.readInt();
-      int opaqueDataLength = length - 8;
-      ErrorCode errorCode = ErrorCode.fromHttp2(errorCodeInt);
-      if (errorCode == null) {
-        throw ioException("TYPE_GOAWAY unexpected error code: %d", errorCodeInt);
-      }
-      ByteString debugData = EMPTY;
-      if (opaqueDataLength > 0) { // Must read debug data in order to not corrupt the connection.
-        debugData = source.readByteString(opaqueDataLength);
-      }
-      handler.goAway(lastStreamId, errorCode, debugData);
-    }
-
-    private void readWindowUpdate(Handler handler, int length, byte flags, int streamId)
-        throws IOException {
-      if (length != 4) throw ioException("TYPE_WINDOW_UPDATE length !=4: %s", length);
-      long increment = (source.readInt() & 0x7fffffffL);
-      if (increment == 0) throw ioException("windowSizeIncrement was 0", increment);
-      handler.windowUpdate(streamId, increment);
-    }
-
-    @Override public void close() throws IOException {
-      source.close();
-    }
-  }
-
-  static final class Writer implements FrameWriter {
-    private final BufferedSink sink;
-    private final boolean client;
-    private final Buffer hpackBuffer;
-    private int maxFrameSize;
-    private boolean closed;
-
-    final Hpack.Writer hpackWriter;
-
-    Writer(BufferedSink sink, boolean client) {
-      this.sink = sink;
-      this.client = client;
-      this.hpackBuffer = new Buffer();
-      this.hpackWriter = new Hpack.Writer(hpackBuffer);
-      this.maxFrameSize = INITIAL_MAX_FRAME_SIZE;
-    }
-
-    @Override public synchronized void flush() throws IOException {
-      if (closed) throw new IOException("closed");
-      sink.flush();
-    }
-
-    @Override public synchronized void applyAndAckSettings(Settings peerSettings)
-        throws IOException {
-      if (closed) throw new IOException("closed");
-      this.maxFrameSize = peerSettings.getMaxFrameSize(maxFrameSize);
-      if (peerSettings.getHeaderTableSize() > -1) {
-        hpackWriter.setHeaderTableSizeSetting(peerSettings.getHeaderTableSize());
-      }
-      int length = 0;
-      byte type = TYPE_SETTINGS;
-      byte flags = FLAG_ACK;
-      int streamId = 0;
-      frameHeader(streamId, length, type, flags);
-      sink.flush();
-    }
-
-    @Override public synchronized void connectionPreface() throws IOException {
-      if (closed) throw new IOException("closed");
-      if (!client) return; // Nothing to write; servers don't send connection headers!
-      if (logger.isLoggable(FINE)) {
-        logger.fine(format(">> CONNECTION %s", CONNECTION_PREFACE.hex()));
-      }
-      sink.write(CONNECTION_PREFACE.toByteArray());
-      sink.flush();
-    }
-
-    @Override public synchronized void synStream(boolean outFinished, boolean inFinished,
-        int streamId, int associatedStreamId, List<Header> headerBlock)
-        throws IOException {
-      if (inFinished) throw new UnsupportedOperationException();
-      if (closed) throw new IOException("closed");
-      headers(outFinished, streamId, headerBlock);
-    }
-
-    @Override public synchronized void synReply(boolean outFinished, int streamId,
-        List<Header> headerBlock) throws IOException {
-      if (closed) throw new IOException("closed");
-      headers(outFinished, streamId, headerBlock);
-    }
-
-    @Override public synchronized void headers(int streamId, List<Header> headerBlock)
-        throws IOException {
-      if (closed) throw new IOException("closed");
-      headers(false, streamId, headerBlock);
-    }
-
-    @Override public synchronized void pushPromise(int streamId, int promisedStreamId,
-        List<Header> requestHeaders) throws IOException {
-      if (closed) throw new IOException("closed");
-      hpackWriter.writeHeaders(requestHeaders);
-
-      long byteCount = hpackBuffer.size();
-      int length = (int) Math.min(maxFrameSize - 4, byteCount);
-      byte type = TYPE_PUSH_PROMISE;
-      byte flags = byteCount == length ? FLAG_END_HEADERS : 0;
-      frameHeader(streamId, length + 4, type, flags);
-      sink.writeInt(promisedStreamId & 0x7fffffff);
-      sink.write(hpackBuffer, length);
-
-      if (byteCount > length) writeContinuationFrames(streamId, byteCount - length);
-    }
-
-    void headers(boolean outFinished, int streamId, List<Header> headerBlock) throws IOException {
-      if (closed) throw new IOException("closed");
-      hpackWriter.writeHeaders(headerBlock);
-
-      long byteCount = hpackBuffer.size();
-      int length = (int) Math.min(maxFrameSize, byteCount);
-      byte type = TYPE_HEADERS;
-      byte flags = byteCount == length ? FLAG_END_HEADERS : 0;
-      if (outFinished) flags |= FLAG_END_STREAM;
-      frameHeader(streamId, length, type, flags);
-      sink.write(hpackBuffer, length);
-
-      if (byteCount > length) writeContinuationFrames(streamId, byteCount - length);
-    }
-
-    private void writeContinuationFrames(int streamId, long byteCount) throws IOException {
-      while (byteCount > 0) {
-        int length = (int) Math.min(maxFrameSize, byteCount);
-        byteCount -= length;
-        frameHeader(streamId, length, TYPE_CONTINUATION, byteCount == 0 ? FLAG_END_HEADERS : 0);
-        sink.write(hpackBuffer, length);
-      }
-    }
-
-    @Override public synchronized void rstStream(int streamId, ErrorCode errorCode)
-        throws IOException {
-      if (closed) throw new IOException("closed");
-      if (errorCode.httpCode == -1) throw new IllegalArgumentException();
-
-      int length = 4;
-      byte type = TYPE_RST_STREAM;
-      byte flags = FLAG_NONE;
-      frameHeader(streamId, length, type, flags);
-      sink.writeInt(errorCode.httpCode);
-      sink.flush();
-    }
-
-    @Override public int maxDataLength() {
-      return maxFrameSize;
-    }
-
-    @Override public synchronized void data(boolean outFinished, int streamId, Buffer source,
-        int byteCount) throws IOException {
-      if (closed) throw new IOException("closed");
-      byte flags = FLAG_NONE;
-      if (outFinished) flags |= FLAG_END_STREAM;
-      dataFrame(streamId, flags, source, byteCount);
-    }
-
-    void dataFrame(int streamId, byte flags, Buffer buffer, int byteCount) throws IOException {
-      byte type = TYPE_DATA;
-      frameHeader(streamId, byteCount, type, flags);
-      if (byteCount > 0) {
-        sink.write(buffer, byteCount);
-      }
-    }
-
-    @Override public synchronized void settings(Settings settings) throws IOException {
-      if (closed) throw new IOException("closed");
-      int length = settings.size() * 6;
-      byte type = TYPE_SETTINGS;
-      byte flags = FLAG_NONE;
-      int streamId = 0;
-      frameHeader(streamId, length, type, flags);
-      for (int i = 0; i < Settings.COUNT; i++) {
-        if (!settings.isSet(i)) continue;
-        int id = i;
-        if (id == 4) {
-          id = 3; // SETTINGS_MAX_CONCURRENT_STREAMS renumbered.
-        } else if (id == 7) {
-          id = 4; // SETTINGS_INITIAL_WINDOW_SIZE renumbered.
-        }
-        sink.writeShort(id);
-        sink.writeInt(settings.get(i));
-      }
-      sink.flush();
-    }
-
-    @Override public synchronized void ping(boolean ack, int payload1, int payload2)
-        throws IOException {
-      if (closed) throw new IOException("closed");
-      int length = 8;
-      byte type = TYPE_PING;
-      byte flags = ack ? FLAG_ACK : FLAG_NONE;
-      int streamId = 0;
-      frameHeader(streamId, length, type, flags);
-      sink.writeInt(payload1);
-      sink.writeInt(payload2);
-      sink.flush();
-    }
-
-    @Override public synchronized void goAway(int lastGoodStreamId, ErrorCode errorCode,
-        byte[] debugData) throws IOException {
-      if (closed) throw new IOException("closed");
-      if (errorCode.httpCode == -1) throw illegalArgument("errorCode.httpCode == -1");
-      int length = 8 + debugData.length;
-      byte type = TYPE_GOAWAY;
-      byte flags = FLAG_NONE;
-      int streamId = 0;
-      frameHeader(streamId, length, type, flags);
-      sink.writeInt(lastGoodStreamId);
-      sink.writeInt(errorCode.httpCode);
-      if (debugData.length > 0) {
-        sink.write(debugData);
-      }
-      sink.flush();
-    }
-
-    @Override public synchronized void windowUpdate(int streamId, long windowSizeIncrement)
-        throws IOException {
-      if (closed) throw new IOException("closed");
-      if (windowSizeIncrement == 0 || windowSizeIncrement > 0x7fffffffL) {
-        throw illegalArgument("windowSizeIncrement == 0 || windowSizeIncrement > 0x7fffffffL: %s",
-            windowSizeIncrement);
-      }
-      int length = 4;
-      byte type = TYPE_WINDOW_UPDATE;
-      byte flags = FLAG_NONE;
-      frameHeader(streamId, length, type, flags);
-      sink.writeInt((int) windowSizeIncrement);
-      sink.flush();
-    }
-
-    @Override public synchronized void close() throws IOException {
-      closed = true;
-      sink.close();
-    }
-
-    void frameHeader(int streamId, int length, byte type, byte flags) throws IOException {
-      if (logger.isLoggable(FINE)) logger.fine(formatHeader(false, streamId, length, type, flags));
-      if (length > maxFrameSize) {
-        throw illegalArgument("FRAME_SIZE_ERROR length > %d: %d", maxFrameSize, length);
-      }
-      if ((streamId & 0x80000000) != 0) throw illegalArgument("reserved bit set: %s", streamId);
-      writeMedium(sink, length);
-      sink.writeByte(type & 0xff);
-      sink.writeByte(flags & 0xff);
-      sink.writeInt(streamId & 0x7fffffff);
-    }
-  }
-
-  private static IllegalArgumentException illegalArgument(String message, Object... args) {
+  static IllegalArgumentException illegalArgument(String message, Object... args) {
     throw new IllegalArgumentException(format(message, args));
   }
 
-  private static IOException ioException(String message, Object... args) throws IOException {
+  static IOException ioException(String message, Object... args) throws IOException {
     throw new IOException(format(message, args));
   }
-
-  /**
-   * Decompression of the header block occurs above the framing layer. This class lazily reads
-   * continuation frames as they are needed by {@link Hpack.Reader#readHeaders()}.
-   */
-  static final class ContinuationSource implements Source {
-    private final BufferedSource source;
-
-    int length;
-    byte flags;
-    int streamId;
-
-    int left;
-    short padding;
-
-    public ContinuationSource(BufferedSource source) {
-      this.source = source;
-    }
-
-    @Override public long read(Buffer sink, long byteCount) throws IOException {
-      while (left == 0) {
-        source.skip(padding);
-        padding = 0;
-        if ((flags & FLAG_END_HEADERS) != 0) return -1;
-        readContinuationHeader();
-        // TODO: test case for empty continuation header?
-      }
-
-      long read = source.read(sink, Math.min(byteCount, left));
-      if (read == -1) return -1;
-      left -= read;
-      return read;
-    }
-
-    @Override public Timeout timeout() {
-      return source.timeout();
-    }
-
-    @Override public void close() throws IOException {
-    }
-
-    private void readContinuationHeader() throws IOException {
-      int previousStreamId = streamId;
-
-      length = left = readMedium(source);
-      byte type = (byte) (source.readByte() & 0xff);
-      flags = (byte) (source.readByte() & 0xff);
-      if (logger.isLoggable(FINE)) logger.fine(formatHeader(true, streamId, length, type, flags));
-      streamId = (source.readInt() & 0x7fffffff);
-      if (type != TYPE_CONTINUATION) throw ioException("%s != TYPE_CONTINUATION", type);
-      if (streamId != previousStreamId) throw ioException("TYPE_CONTINUATION streamId changed");
-    }
-  }
-
-  private static int lengthWithoutPadding(int length, byte flags, short padding)
-      throws IOException {
-    if ((flags & FLAG_PADDED) != 0) length--; // Account for reading the padding length.
-    if (padding > length) {
-      throw ioException("PROTOCOL_ERROR padding %s > remaining length %s", padding, length);
-    }
-    return (short) (length - padding);
-  }
-
-  /**
-   * Logs a human-readable representation of HTTP/2 frame headers.
-   *
-   * <p>The format is:
-   *
-   * <pre>
-   *   direction streamID length type flags
-   * </pre>
-   * Where direction is {@code <<} for inbound and {@code >>} for outbound.
-   *
-   * <p>For example, the following would indicate a HEAD request sent from the client.
-   * <pre>
-   * {@code
-   *   << 0x0000000f    12 HEADERS       END_HEADERS|END_STREAM
-   * }
-   * </pre>
-   */
-  static final class FrameLogger {
-
-    static String formatHeader(boolean inbound, int streamId, int length, byte type, byte flags) {
-      String formattedType = type < TYPES.length ? TYPES[type] : format("0x%02x", type);
-      String formattedFlags = formatFlags(type, flags);
-      return format("%s 0x%08x %5d %-13s %s", inbound ? "<<" : ">>", streamId, length,
-          formattedType, formattedFlags);
-    }
-
-    /**
-     * Looks up valid string representing flags from the table. Invalid combinations are represented
-     * in binary.
-     */
-    // Visible for testing.
-    static String formatFlags(byte type, byte flags) {
-      if (flags == 0) return "";
-      switch (type) { // Special case types that have 0 or 1 flag.
-        case TYPE_SETTINGS:
-        case TYPE_PING:
-          return flags == FLAG_ACK ? "ACK" : BINARY[flags];
-        case TYPE_PRIORITY:
-        case TYPE_RST_STREAM:
-        case TYPE_GOAWAY:
-        case TYPE_WINDOW_UPDATE:
-          return BINARY[flags];
-      }
-      String result = flags < FLAGS.length ? FLAGS[flags] : BINARY[flags];
-      // Special case types that have overlap flag values.
-      if (type == TYPE_PUSH_PROMISE && (flags & FLAG_END_PUSH_PROMISE) != 0) {
-        return result.replace("HEADERS", "PUSH_PROMISE"); // TODO: Avoid allocation.
-      } else if (type == TYPE_DATA && (flags & FLAG_COMPRESSED) != 0) {
-        return result.replace("PRIORITY", "COMPRESSED"); // TODO: Avoid allocation.
-      }
-      return result;
-    }
-
-    /** Lookup table for valid frame types. */
-    private static final String[] TYPES = new String[] {
-        "DATA",
-        "HEADERS",
-        "PRIORITY",
-        "RST_STREAM",
-        "SETTINGS",
-        "PUSH_PROMISE",
-        "PING",
-        "GOAWAY",
-        "WINDOW_UPDATE",
-        "CONTINUATION"
-    };
-
-    /**
-     * Lookup table for valid flags for DATA, HEADERS, CONTINUATION. Invalid combinations are
-     * represented in binary.
-     */
-    private static final String[] FLAGS = new String[0x40]; // Highest bit flag is 0x20.
-    private static final String[] BINARY = new String[256];
-
-    static {
-      for (int i = 0; i < BINARY.length; i++) {
-        BINARY[i] = format("%8s", Integer.toBinaryString(i)).replace(' ', '0');
-      }
-
-      FLAGS[FLAG_NONE] = "";
-      FLAGS[FLAG_END_STREAM] = "END_STREAM";
-
-      int[] prefixFlags = new int[] {FLAG_END_STREAM};
-
-      FLAGS[FLAG_PADDED] = "PADDED";
-      for (int prefixFlag : prefixFlags) {
-        FLAGS[prefixFlag | FLAG_PADDED] = FLAGS[prefixFlag] + "|PADDED";
-      }
-
-      FLAGS[FLAG_END_HEADERS] = "END_HEADERS"; // Same as END_PUSH_PROMISE.
-      FLAGS[FLAG_PRIORITY] = "PRIORITY"; // Same as FLAG_COMPRESSED.
-      FLAGS[FLAG_END_HEADERS | FLAG_PRIORITY] = "END_HEADERS|PRIORITY"; // Only valid on HEADERS.
-      int[] frameFlags =
-          new int[] {FLAG_END_HEADERS, FLAG_PRIORITY, FLAG_END_HEADERS | FLAG_PRIORITY};
-
-      for (int frameFlag : frameFlags) {
-        for (int prefixFlag : prefixFlags) {
-          FLAGS[prefixFlag | frameFlag] = FLAGS[prefixFlag] + '|' + FLAGS[frameFlag];
-          FLAGS[prefixFlag | frameFlag | FLAG_PADDED] =
-              FLAGS[prefixFlag] + '|' + FLAGS[frameFlag] + "|PADDED";
-        }
-      }
-
-      for (int i = 0; i < FLAGS.length; i++) { // Fill in holes with binary representation.
-        if (FLAGS[i] == null) FLAGS[i] = BINARY[i];
-      }
-    }
-  }
-
-  private static int readMedium(BufferedSource source) throws IOException {
-    return (source.readByte() & 0xff) << 16
-        | (source.readByte() & 0xff) << 8
-        | (source.readByte() & 0xff);
-  }
-
-  private static void writeMedium(BufferedSink sink, int i) throws IOException {
-    sink.writeByte((i >>> 16) & 0xff);
-    sink.writeByte((i >>> 8) & 0xff);
-    sink.writeByte(i & 0xff);
-  }
 }
diff --git a/okhttp/src/main/java/okhttp3/internal/framed/NameValueBlockReader.java b/okhttp/src/main/java/okhttp3/internal/framed/NameValueBlockReader.java
deleted file mode 100644
index 75cd9594f7..0000000000
--- a/okhttp/src/main/java/okhttp3/internal/framed/NameValueBlockReader.java
+++ /dev/null
@@ -1,117 +0,0 @@
-/*
- * Copyright (C) 2013 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.internal.framed;
-
-import java.io.IOException;
-import java.util.ArrayList;
-import java.util.List;
-import java.util.zip.DataFormatException;
-import java.util.zip.Inflater;
-import okio.Buffer;
-import okio.BufferedSource;
-import okio.ByteString;
-import okio.ForwardingSource;
-import okio.InflaterSource;
-import okio.Okio;
-import okio.Source;
-
-/**
- * Reads a SPDY/3 Name/Value header block. This class is made complicated by the requirement that
- * we're strict with which bytes we put in the compressed bytes buffer. We need to put all
- * compressed bytes into that buffer -- but no other bytes.
- */
-class NameValueBlockReader {
-  /** This source transforms compressed bytes into uncompressed bytes. */
-  private final InflaterSource inflaterSource;
-
-  /**
-   * How many compressed bytes must be read into inflaterSource before {@link #readNameValueBlock}
-   * returns.
-   */
-  private int compressedLimit;
-
-  /** This source holds inflated bytes. */
-  private final BufferedSource source;
-
-  public NameValueBlockReader(BufferedSource source) {
-    // Limit the inflater input stream to only those bytes in the Name/Value
-    // block. We cut the inflater off at its source because we can't predict the
-    // ratio of compressed bytes to uncompressed bytes.
-    Source throttleSource = new ForwardingSource(source) {
-      @Override public long read(Buffer sink, long byteCount) throws IOException {
-        if (compressedLimit == 0) return -1; // Out of data for the current block.
-        long read = super.read(sink, Math.min(byteCount, compressedLimit));
-        if (read == -1) return -1;
-        compressedLimit -= read;
-        return read;
-      }
-    };
-
-    // Subclass inflater to install a dictionary when it's needed.
-    Inflater inflater = new Inflater() {
-      @Override public int inflate(byte[] buffer, int offset, int count)
-          throws DataFormatException {
-        int result = super.inflate(buffer, offset, count);
-        if (result == 0 && needsDictionary()) {
-          setDictionary(Spdy3.DICTIONARY);
-          result = super.inflate(buffer, offset, count);
-        }
-        return result;
-      }
-    };
-
-    this.inflaterSource = new InflaterSource(throttleSource, inflater);
-    this.source = Okio.buffer(inflaterSource);
-  }
-
-  public List<Header> readNameValueBlock(int length) throws IOException {
-    this.compressedLimit += length;
-
-    int numberOfPairs = source.readInt();
-    if (numberOfPairs < 0) throw new IOException("numberOfPairs < 0: " + numberOfPairs);
-    if (numberOfPairs > 1024) throw new IOException("numberOfPairs > 1024: " + numberOfPairs);
-
-    List<Header> entries = new ArrayList<>(numberOfPairs);
-    for (int i = 0; i < numberOfPairs; i++) {
-      ByteString name = readByteString().toAsciiLowercase();
-      ByteString values = readByteString();
-      if (name.size() == 0) throw new IOException("name.size == 0");
-      entries.add(new Header(name, values));
-    }
-
-    doneReading();
-    return entries;
-  }
-
-  private ByteString readByteString() throws IOException {
-    int length = source.readInt();
-    return source.readByteString(length);
-  }
-
-  private void doneReading() throws IOException {
-    // Move any outstanding unread bytes into the inflater. One side-effect of
-    // deflate compression is that sometimes there are bytes remaining in the
-    // stream after we've consumed all of the content.
-    if (compressedLimit > 0) {
-      inflaterSource.refill();
-      if (compressedLimit != 0) throw new IOException("compressedLimit > 0: " + compressedLimit);
-    }
-  }
-
-  public void close() throws IOException {
-    source.close();
-  }
-}
diff --git a/okhttp/src/main/java/okhttp3/internal/framed/Settings.java b/okhttp/src/main/java/okhttp3/internal/framed/Settings.java
index f4eab01731..e09bdde65e 100644
--- a/okhttp/src/main/java/okhttp3/internal/framed/Settings.java
+++ b/okhttp/src/main/java/okhttp3/internal/framed/Settings.java
@@ -23,43 +23,23 @@
  */
 public final class Settings {
   /**
-   * From the SPDY/3 and HTTP/2 specs, the default initial window size for all streams is 64 KiB.
-   * (Chrome 25 uses 10 MiB).
+   * From the HTTP/2 specs, the default initial window size for all streams is 64 KiB. (Chrome 25
+   * uses 10 MiB).
    */
-  static final int DEFAULT_INITIAL_WINDOW_SIZE = 64 * 1024;
+  static final int DEFAULT_INITIAL_WINDOW_SIZE = 65535;
 
-  /** Peer request to clear durable settings. */
-  static final int FLAG_CLEAR_PREVIOUSLY_PERSISTED_SETTINGS = 0x1;
-
-  /** Sent by servers only. The peer requests this setting persisted for future connections. */
-  static final int PERSIST_VALUE = 0x1;
-  /** Sent by clients only. The client is reminding the server of a persisted value. */
-  static final int PERSISTED = 0x2;
-
-  /** spdy/3: Sender's estimate of max incoming kbps. */
-  static final int UPLOAD_BANDWIDTH = 1;
   /** HTTP/2: Size in bytes of the table used to decode the sender's header blocks. */
   static final int HEADER_TABLE_SIZE = 1;
-  /** spdy/3: Sender's estimate of max outgoing kbps. */
-  static final int DOWNLOAD_BANDWIDTH = 2;
   /** HTTP/2: The peer must not send a PUSH_PROMISE frame when this is 0. */
   static final int ENABLE_PUSH = 2;
-  /** spdy/3: Sender's estimate of millis between sending a request and receiving a response. */
-  static final int ROUND_TRIP_TIME = 3;
   /** Sender's maximum number of concurrent streams. */
   static final int MAX_CONCURRENT_STREAMS = 4;
-  /** spdy/3: Current CWND in Packets. */
-  static final int CURRENT_CWND = 5;
   /** HTTP/2: Size in bytes of the largest frame payload the sender will accept. */
   static final int MAX_FRAME_SIZE = 5;
-  /** spdy/3: Retransmission rate. Percentage */
-  static final int DOWNLOAD_RETRANS_RATE = 6;
   /** HTTP/2: Advisory only. Size in bytes of the largest header list the sender will accept. */
   static final int MAX_HEADER_LIST_SIZE = 6;
   /** Window size in bytes. */
   static final int INITIAL_WINDOW_SIZE = 7;
-  /** spdy/3: Size of the client certificate vector. Unsupported. */
-  static final int CLIENT_CERTIFICATE_VECTOR_SIZE = 8;
   /** Flow control options. */
   static final int FLOW_CONTROL_OPTIONS = 10;
 
@@ -72,38 +52,21 @@
   /** Bitfield of which flags that values. */
   private int set;
 
-  /** Bitfield of flags that have {@link #PERSIST_VALUE}. */
-  private int persistValue;
-
-  /** Bitfield of flags that have {@link #PERSISTED}. */
-  private int persisted;
-
   /** Flag values. */
   private final int[] values = new int[COUNT];
 
   void clear() {
-    set = persistValue = persisted = 0;
+    set = 0;
     Arrays.fill(values, 0);
   }
 
-  Settings set(int id, int idFlags, int value) {
+  Settings set(int id, int value) {
     if (id >= values.length) {
       return this; // Discard unknown settings.
     }
 
     int bit = 1 << id;
     set |= bit;
-    if ((idFlags & PERSIST_VALUE) != 0) {
-      persistValue |= bit;
-    } else {
-      persistValue &= ~bit;
-    }
-    if ((idFlags & PERSISTED) != 0) {
-      persisted |= bit;
-    } else {
-      persisted &= ~bit;
-    }
-
     values[id] = value;
     return this;
   }
@@ -119,113 +82,51 @@ int get(int id) {
     return values[id];
   }
 
-  /** Returns the flags for the setting {@code id}, or 0 if unset. */
-  int flags(int id) {
-    int result = 0;
-    if (isPersisted(id)) result |= Settings.PERSISTED;
-    if (persistValue(id)) result |= Settings.PERSIST_VALUE;
-    return result;
-  }
-
   /** Returns the number of settings that have values assigned. */
   int size() {
     return Integer.bitCount(set);
   }
 
-  /** spdy/3 only. */
-  int getUploadBandwidth(int defaultValue) {
-    int bit = 1 << UPLOAD_BANDWIDTH;
-    return (bit & set) != 0 ? values[UPLOAD_BANDWIDTH] : defaultValue;
-  }
-
-  /** HTTP/2 only. Returns -1 if unset. */
+  /** Returns -1 if unset. */
   int getHeaderTableSize() {
     int bit = 1 << HEADER_TABLE_SIZE;
     return (bit & set) != 0 ? values[HEADER_TABLE_SIZE] : -1;
   }
 
-  /** spdy/3 only. */
-  int getDownloadBandwidth(int defaultValue) {
-    int bit = 1 << DOWNLOAD_BANDWIDTH;
-    return (bit & set) != 0 ? values[DOWNLOAD_BANDWIDTH] : defaultValue;
-  }
-
-  /** HTTP/2 only. */
-  // TODO: honor this setting in HTTP/2.
+  // TODO: honor this setting.
   boolean getEnablePush(boolean defaultValue) {
     int bit = 1 << ENABLE_PUSH;
     return ((bit & set) != 0 ? values[ENABLE_PUSH] : defaultValue ? 1 : 0) == 1;
   }
 
-  /** spdy/3 only. */
-  int getRoundTripTime(int defaultValue) {
-    int bit = 1 << ROUND_TRIP_TIME;
-    return (bit & set) != 0 ? values[ROUND_TRIP_TIME] : defaultValue;
-  }
-
-  // TODO: honor this setting in spdy/3 and HTTP/2.
+  // TODO: honor this setting.
   int getMaxConcurrentStreams(int defaultValue) {
     int bit = 1 << MAX_CONCURRENT_STREAMS;
     return (bit & set) != 0 ? values[MAX_CONCURRENT_STREAMS] : defaultValue;
   }
 
-  /** spdy/3 only. */
-  int getCurrentCwnd(int defaultValue) {
-    int bit = 1 << CURRENT_CWND;
-    return (bit & set) != 0 ? values[CURRENT_CWND] : defaultValue;
-  }
-
-  /** HTTP/2 only. */
   int getMaxFrameSize(int defaultValue) {
     int bit = 1 << MAX_FRAME_SIZE;
     return (bit & set) != 0 ? values[MAX_FRAME_SIZE] : defaultValue;
   }
 
-  /** spdy/3 only. */
-  int getDownloadRetransRate(int defaultValue) {
-    int bit = 1 << DOWNLOAD_RETRANS_RATE;
-    return (bit & set) != 0 ? values[DOWNLOAD_RETRANS_RATE] : defaultValue;
-  }
-
-  /** HTTP/2 only. */
   int getMaxHeaderListSize(int defaultValue) {
     int bit = 1 << MAX_HEADER_LIST_SIZE;
     return (bit & set) != 0 ? values[MAX_HEADER_LIST_SIZE] : defaultValue;
   }
 
-  int getInitialWindowSize(int defaultValue) {
+  int getInitialWindowSize() {
     int bit = 1 << INITIAL_WINDOW_SIZE;
-    return (bit & set) != 0 ? values[INITIAL_WINDOW_SIZE] : defaultValue;
+    return (bit & set) != 0 ? values[INITIAL_WINDOW_SIZE] : DEFAULT_INITIAL_WINDOW_SIZE;
   }
 
-  /** spdy/3 only. */
-  int getClientCertificateVectorSize(int defaultValue) {
-    int bit = 1 << CLIENT_CERTIFICATE_VECTOR_SIZE;
-    return (bit & set) != 0 ? values[CLIENT_CERTIFICATE_VECTOR_SIZE] : defaultValue;
-  }
-
-  // TODO: honor this setting in spdy/3 and HTTP/2.
+  // TODO: honor this setting.
   boolean isFlowControlDisabled() {
     int bit = 1 << FLOW_CONTROL_OPTIONS;
     int value = (bit & set) != 0 ? values[FLOW_CONTROL_OPTIONS] : 0;
     return (value & FLOW_CONTROL_OPTIONS_DISABLED) != 0;
   }
 
-  /**
-   * Returns true if this user agent should use this setting in future spdy/3 connections to the
-   * same host.
-   */
-  boolean persistValue(int id) {
-    int bit = 1 << id;
-    return (persistValue & bit) != 0;
-  }
-
-  /** Returns true if this setting was persisted. */
-  boolean isPersisted(int id) {
-    int bit = 1 << id;
-    return (persisted & bit) != 0;
-  }
-
   /**
    * Writes {@code other} into this. If any setting is populated by this and {@code other}, the
    * value and flags from {@code other} will be kept.
@@ -233,7 +134,7 @@ boolean isPersisted(int id) {
   void merge(Settings other) {
     for (int i = 0; i < COUNT; i++) {
       if (!other.isSet(i)) continue;
-      set(i, other.flags(i), other.get(i));
+      set(i, other.get(i));
     }
   }
 }
diff --git a/okhttp/src/main/java/okhttp3/internal/framed/Spdy3.java b/okhttp/src/main/java/okhttp3/internal/framed/Spdy3.java
deleted file mode 100644
index c6ea5c8201..0000000000
--- a/okhttp/src/main/java/okhttp3/internal/framed/Spdy3.java
+++ /dev/null
@@ -1,491 +0,0 @@
-/*
- * Copyright (C) 2011 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.internal.framed;
-
-import java.io.IOException;
-import java.io.UnsupportedEncodingException;
-import java.net.ProtocolException;
-import java.util.List;
-import java.util.zip.Deflater;
-import okhttp3.Protocol;
-import okhttp3.internal.Util;
-import okio.Buffer;
-import okio.BufferedSink;
-import okio.BufferedSource;
-import okio.ByteString;
-import okio.DeflaterSink;
-import okio.Okio;
-
-/**
- * Read and write spdy/3.1 frames. http://www.chromium.org/spdy/spdy-protocol/spdy-protocol-draft3-1
- */
-public final class Spdy3 implements Variant {
-
-  @Override public Protocol getProtocol() {
-    return Protocol.SPDY_3;
-  }
-
-  static final int TYPE_DATA = 0x0;
-  static final int TYPE_SYN_STREAM = 0x1;
-  static final int TYPE_SYN_REPLY = 0x2;
-  static final int TYPE_RST_STREAM = 0x3;
-  static final int TYPE_SETTINGS = 0x4;
-  static final int TYPE_PING = 0x6;
-  static final int TYPE_GOAWAY = 0x7;
-  static final int TYPE_HEADERS = 0x8;
-  static final int TYPE_WINDOW_UPDATE = 0x9;
-
-  static final int FLAG_FIN = 0x1;
-  static final int FLAG_UNIDIRECTIONAL = 0x2;
-
-  static final int VERSION = 3;
-
-  static final byte[] DICTIONARY;
-
-  static {
-    try {
-      DICTIONARY = ("\u0000\u0000\u0000\u0007options\u0000\u0000\u0000\u0004hea"
-          + "d\u0000\u0000\u0000\u0004post\u0000\u0000\u0000\u0003put\u0000\u0000\u0000\u0006dele"
-          + "te\u0000\u0000\u0000\u0005trace\u0000\u0000\u0000\u0006accept\u0000\u0000\u0000"
-          + "\u000Eaccept-charset\u0000\u0000\u0000\u000Faccept-encoding\u0000\u0000\u0000\u000Fa"
-          + "ccept-language\u0000\u0000\u0000\raccept-ranges\u0000\u0000\u0000\u0003age\u0000"
-          + "\u0000\u0000\u0005allow\u0000\u0000\u0000\rauthorization\u0000\u0000\u0000\rcache-co"
-          + "ntrol\u0000\u0000\u0000\nconnection\u0000\u0000\u0000\fcontent-base\u0000\u0000"
-          + "\u0000\u0010content-encoding\u0000\u0000\u0000\u0010content-language\u0000\u0000"
-          + "\u0000\u000Econtent-length\u0000\u0000\u0000\u0010content-location\u0000\u0000\u0000"
-          + "\u000Bcontent-md5\u0000\u0000\u0000\rcontent-range\u0000\u0000\u0000\fcontent-type"
-          + "\u0000\u0000\u0000\u0004date\u0000\u0000\u0000\u0004etag\u0000\u0000\u0000\u0006expe"
-          + "ct\u0000\u0000\u0000\u0007expires\u0000\u0000\u0000\u0004from\u0000\u0000\u0000"
-          + "\u0004host\u0000\u0000\u0000\bif-match\u0000\u0000\u0000\u0011if-modified-since"
-          + "\u0000\u0000\u0000\rif-none-match\u0000\u0000\u0000\bif-range\u0000\u0000\u0000"
-          + "\u0013if-unmodified-since\u0000\u0000\u0000\rlast-modified\u0000\u0000\u0000\blocati"
-          + "on\u0000\u0000\u0000\fmax-forwards\u0000\u0000\u0000\u0006pragma\u0000\u0000\u0000"
-          + "\u0012proxy-authenticate\u0000\u0000\u0000\u0013proxy-authorization\u0000\u0000"
-          + "\u0000\u0005range\u0000\u0000\u0000\u0007referer\u0000\u0000\u0000\u000Bretry-after"
-          + "\u0000\u0000\u0000\u0006server\u0000\u0000\u0000\u0002te\u0000\u0000\u0000\u0007trai"
-          + "ler\u0000\u0000\u0000\u0011transfer-encoding\u0000\u0000\u0000\u0007upgrade\u0000"
-          + "\u0000\u0000\nuser-agent\u0000\u0000\u0000\u0004vary\u0000\u0000\u0000\u0003via"
-          + "\u0000\u0000\u0000\u0007warning\u0000\u0000\u0000\u0010www-authenticate\u0000\u0000"
-          + "\u0000\u0006method\u0000\u0000\u0000\u0003get\u0000\u0000\u0000\u0006status\u0000"
-          + "\u0000\u0000\u0006200 OK\u0000\u0000\u0000\u0007version\u0000\u0000\u0000\bHTTP/1.1"
-          + "\u0000\u0000\u0000\u0003url\u0000\u0000\u0000\u0006public\u0000\u0000\u0000\nset-coo"
-          + "kie\u0000\u0000\u0000\nkeep-alive\u0000\u0000\u0000\u0006origin100101201202205206300"
-          + "302303304305306307402405406407408409410411412413414415416417502504505203 Non-Authori"
-          + "tative Information204 No Content301 Moved Permanently400 Bad Request401 Unauthorized"
-          + "403 Forbidden404 Not Found500 Internal Server Error501 Not Implemented503 Service Un"
-          + "availableJan Feb Mar Apr May Jun Jul Aug Sept Oct Nov Dec 00:00:00 Mon, Tue, Wed, Th"
-          + "u, Fri, Sat, Sun, GMTchunked,text/html,image/png,image/jpg,image/gif,application/xml"
-          + ",application/xhtml+xml,text/plain,text/javascript,publicprivatemax-age=gzip,deflate,"
-          + "sdchcharset=utf-8charset=iso-8859-1,utf-,*,enq=0.").getBytes(Util.UTF_8.name());
-    } catch (UnsupportedEncodingException e) {
-      throw new AssertionError();
-    }
-  }
-
-  @Override public FrameReader newReader(BufferedSource source, boolean client) {
-    return new Reader(source, client);
-  }
-
-  @Override public FrameWriter newWriter(BufferedSink sink, boolean client) {
-    return new Writer(sink, client);
-  }
-
-  /** Read spdy/3 frames. */
-  static final class Reader implements FrameReader {
-    private final BufferedSource source;
-    private final boolean client;
-    private final NameValueBlockReader headerBlockReader;
-
-    Reader(BufferedSource source, boolean client) {
-      this.source = source;
-      this.headerBlockReader = new NameValueBlockReader(this.source);
-      this.client = client;
-    }
-
-    @Override public void readConnectionPreface() {
-    }
-
-    /**
-     * Send the next frame to {@code handler}. Returns true unless there are no more frames on the
-     * stream.
-     */
-    @Override public boolean nextFrame(Handler handler) throws IOException {
-      int w1;
-      int w2;
-      try {
-        w1 = source.readInt();
-        w2 = source.readInt();
-      } catch (IOException e) {
-        return false; // This might be a normal socket close.
-      }
-
-      boolean control = (w1 & 0x80000000) != 0;
-      int flags = (w2 & 0xff000000) >>> 24;
-      int length = (w2 & 0xffffff);
-
-      if (control) {
-        int version = (w1 & 0x7fff0000) >>> 16;
-        int type = (w1 & 0xffff);
-
-        if (version != 3) {
-          throw new ProtocolException("version != 3: " + version);
-        }
-
-        switch (type) {
-          case TYPE_SYN_STREAM:
-            readSynStream(handler, flags, length);
-            return true;
-
-          case TYPE_SYN_REPLY:
-            readSynReply(handler, flags, length);
-            return true;
-
-          case TYPE_RST_STREAM:
-            readRstStream(handler, flags, length);
-            return true;
-
-          case TYPE_SETTINGS:
-            readSettings(handler, flags, length);
-            return true;
-
-          case TYPE_PING:
-            readPing(handler, flags, length);
-            return true;
-
-          case TYPE_GOAWAY:
-            readGoAway(handler, flags, length);
-            return true;
-
-          case TYPE_HEADERS:
-            readHeaders(handler, flags, length);
-            return true;
-
-          case TYPE_WINDOW_UPDATE:
-            readWindowUpdate(handler, flags, length);
-            return true;
-
-          default:
-            source.skip(length);
-            return true;
-        }
-      } else {
-        int streamId = w1 & 0x7fffffff;
-        boolean inFinished = (flags & FLAG_FIN) != 0;
-        handler.data(inFinished, streamId, source, length);
-        return true;
-      }
-    }
-
-    private void readSynStream(Handler handler, int flags, int length) throws IOException {
-      int w1 = source.readInt();
-      int w2 = source.readInt();
-      int streamId = w1 & 0x7fffffff;
-      int associatedStreamId = w2 & 0x7fffffff;
-      source.readShort(); // int priority = (s3 & 0xe000) >>> 13; int slot = s3 & 0xff;
-      List<Header> headerBlock = headerBlockReader.readNameValueBlock(length - 10);
-
-      boolean inFinished = (flags & FLAG_FIN) != 0;
-      boolean outFinished = (flags & FLAG_UNIDIRECTIONAL) != 0;
-      handler.headers(outFinished, inFinished, streamId, associatedStreamId, headerBlock,
-          HeadersMode.SPDY_SYN_STREAM);
-    }
-
-    private void readSynReply(Handler handler, int flags, int length) throws IOException {
-      int w1 = source.readInt();
-      int streamId = w1 & 0x7fffffff;
-      List<Header> headerBlock = headerBlockReader.readNameValueBlock(length - 4);
-      boolean inFinished = (flags & FLAG_FIN) != 0;
-      handler.headers(false, inFinished, streamId, -1, headerBlock, HeadersMode.SPDY_REPLY);
-    }
-
-    private void readRstStream(Handler handler, int flags, int length) throws IOException {
-      if (length != 8) throw ioException("TYPE_RST_STREAM length: %d != 8", length);
-      int streamId = source.readInt() & 0x7fffffff;
-      int errorCodeInt = source.readInt();
-      ErrorCode errorCode = ErrorCode.fromSpdy3Rst(errorCodeInt);
-      if (errorCode == null) {
-        throw ioException("TYPE_RST_STREAM unexpected error code: %d", errorCodeInt);
-      }
-      handler.rstStream(streamId, errorCode);
-    }
-
-    private void readHeaders(Handler handler, int flags, int length) throws IOException {
-      int w1 = source.readInt();
-      int streamId = w1 & 0x7fffffff;
-      List<Header> headerBlock = headerBlockReader.readNameValueBlock(length - 4);
-      handler.headers(false, false, streamId, -1, headerBlock, HeadersMode.SPDY_HEADERS);
-    }
-
-    private void readWindowUpdate(Handler handler, int flags, int length) throws IOException {
-      if (length != 8) throw ioException("TYPE_WINDOW_UPDATE length: %d != 8", length);
-      int w1 = source.readInt();
-      int w2 = source.readInt();
-      int streamId = w1 & 0x7fffffff;
-      long increment = w2 & 0x7fffffff;
-      if (increment == 0) throw ioException("windowSizeIncrement was 0", increment);
-      handler.windowUpdate(streamId, increment);
-    }
-
-    private void readPing(Handler handler, int flags, int length) throws IOException {
-      if (length != 4) throw ioException("TYPE_PING length: %d != 4", length);
-      int id = source.readInt();
-      boolean ack = client == ((id & 1) == 1);
-      handler.ping(ack, id, 0);
-    }
-
-    private void readGoAway(Handler handler, int flags, int length) throws IOException {
-      if (length != 8) throw ioException("TYPE_GOAWAY length: %d != 8", length);
-      int lastGoodStreamId = source.readInt() & 0x7fffffff;
-      int errorCodeInt = source.readInt();
-      ErrorCode errorCode = ErrorCode.fromSpdyGoAway(errorCodeInt);
-      if (errorCode == null) {
-        throw ioException("TYPE_GOAWAY unexpected error code: %d", errorCodeInt);
-      }
-      handler.goAway(lastGoodStreamId, errorCode, ByteString.EMPTY);
-    }
-
-    private void readSettings(Handler handler, int flags, int length) throws IOException {
-      int numberOfEntries = source.readInt();
-      if (length != 4 + 8 * numberOfEntries) {
-        throw ioException("TYPE_SETTINGS length: %d != 4 + 8 * %d", length, numberOfEntries);
-      }
-      Settings settings = new Settings();
-      for (int i = 0; i < numberOfEntries; i++) {
-        int w1 = source.readInt();
-        int value = source.readInt();
-        int idFlags = (w1 & 0xff000000) >>> 24;
-        int id = w1 & 0xffffff;
-        settings.set(id, idFlags, value);
-      }
-      boolean clearPrevious = (flags & Settings.FLAG_CLEAR_PREVIOUSLY_PERSISTED_SETTINGS) != 0;
-      handler.settings(clearPrevious, settings);
-    }
-
-    private static IOException ioException(String message, Object... args) throws IOException {
-      throw new IOException(Util.format(message, args));
-    }
-
-    @Override public void close() throws IOException {
-      headerBlockReader.close();
-    }
-  }
-
-  /** Write spdy/3 frames. */
-  static final class Writer implements FrameWriter {
-    private final BufferedSink sink;
-    private final Buffer headerBlockBuffer;
-    private final BufferedSink headerBlockOut;
-    private final boolean client;
-    private boolean closed;
-
-    Writer(BufferedSink sink, boolean client) {
-      this.sink = sink;
-      this.client = client;
-
-      Deflater deflater = new Deflater();
-      deflater.setDictionary(DICTIONARY);
-      headerBlockBuffer = new Buffer();
-      headerBlockOut = Okio.buffer(new DeflaterSink(headerBlockBuffer, deflater));
-    }
-
-    @Override public void applyAndAckSettings(Settings peerSettings) {
-      // Do nothing: no ACK for SPDY/3 settings.
-    }
-
-    @Override
-    public void pushPromise(int streamId, int promisedStreamId, List<Header> requestHeaders)
-        throws IOException {
-      // Do nothing: no push promise for SPDY/3.
-    }
-
-    @Override public synchronized void connectionPreface() {
-      // Do nothing: no connection preface for SPDY/3.
-    }
-
-    @Override public synchronized void flush() throws IOException {
-      if (closed) throw new IOException("closed");
-      sink.flush();
-    }
-
-    @Override public synchronized void synStream(boolean outFinished, boolean inFinished,
-        int streamId, int associatedStreamId, List<Header> headerBlock)
-        throws IOException {
-      if (closed) throw new IOException("closed");
-      writeNameValueBlockToBuffer(headerBlock);
-      int length = (int) (10 + headerBlockBuffer.size());
-      int type = TYPE_SYN_STREAM;
-      int flags = (outFinished ? FLAG_FIN : 0) | (inFinished ? FLAG_UNIDIRECTIONAL : 0);
-
-      int unused = 0;
-      sink.writeInt(0x80000000 | (VERSION & 0x7fff) << 16 | type & 0xffff);
-      sink.writeInt((flags & 0xff) << 24 | length & 0xffffff);
-      sink.writeInt(streamId & 0x7fffffff);
-      sink.writeInt(associatedStreamId & 0x7fffffff);
-      sink.writeShort((unused & 0x7) << 13 | (unused & 0x1f) << 8 | (unused & 0xff));
-      sink.writeAll(headerBlockBuffer);
-      sink.flush();
-    }
-
-    @Override public synchronized void synReply(boolean outFinished, int streamId,
-        List<Header> headerBlock) throws IOException {
-      if (closed) throw new IOException("closed");
-      writeNameValueBlockToBuffer(headerBlock);
-      int type = TYPE_SYN_REPLY;
-      int flags = (outFinished ? FLAG_FIN : 0);
-      int length = (int) (headerBlockBuffer.size() + 4);
-
-      sink.writeInt(0x80000000 | (VERSION & 0x7fff) << 16 | type & 0xffff);
-      sink.writeInt((flags & 0xff) << 24 | length & 0xffffff);
-      sink.writeInt(streamId & 0x7fffffff);
-      sink.writeAll(headerBlockBuffer);
-      sink.flush();
-    }
-
-    @Override public synchronized void headers(int streamId, List<Header> headerBlock)
-        throws IOException {
-      if (closed) throw new IOException("closed");
-      writeNameValueBlockToBuffer(headerBlock);
-      int flags = 0;
-      int type = TYPE_HEADERS;
-      int length = (int) (headerBlockBuffer.size() + 4);
-
-      sink.writeInt(0x80000000 | (VERSION & 0x7fff) << 16 | type & 0xffff);
-      sink.writeInt((flags & 0xff) << 24 | length & 0xffffff);
-      sink.writeInt(streamId & 0x7fffffff);
-      sink.writeAll(headerBlockBuffer);
-    }
-
-    @Override public synchronized void rstStream(int streamId, ErrorCode errorCode)
-        throws IOException {
-      if (closed) throw new IOException("closed");
-      if (errorCode.spdyRstCode == -1) throw new IllegalArgumentException();
-      int flags = 0;
-      int type = TYPE_RST_STREAM;
-      int length = 8;
-      sink.writeInt(0x80000000 | (VERSION & 0x7fff) << 16 | type & 0xffff);
-      sink.writeInt((flags & 0xff) << 24 | length & 0xffffff);
-      sink.writeInt(streamId & 0x7fffffff);
-      sink.writeInt(errorCode.spdyRstCode);
-      sink.flush();
-    }
-
-    @Override public int maxDataLength() {
-      return 16383;
-    }
-
-    @Override public synchronized void data(boolean outFinished, int streamId, Buffer source,
-        int byteCount) throws IOException {
-      int flags = (outFinished ? FLAG_FIN : 0);
-      sendDataFrame(streamId, flags, source, byteCount);
-    }
-
-    void sendDataFrame(int streamId, int flags, Buffer buffer, int byteCount)
-        throws IOException {
-      if (closed) throw new IOException("closed");
-      if (byteCount > 0xffffffL) {
-        throw new IllegalArgumentException("FRAME_TOO_LARGE max size is 16Mib: " + byteCount);
-      }
-      sink.writeInt(streamId & 0x7fffffff);
-      sink.writeInt((flags & 0xff) << 24 | byteCount & 0xffffff);
-      if (byteCount > 0) {
-        sink.write(buffer, byteCount);
-      }
-    }
-
-    private void writeNameValueBlockToBuffer(List<Header> headerBlock) throws IOException {
-      headerBlockOut.writeInt(headerBlock.size());
-      for (int i = 0, size = headerBlock.size(); i < size; i++) {
-        ByteString name = headerBlock.get(i).name;
-        headerBlockOut.writeInt(name.size());
-        headerBlockOut.write(name);
-        ByteString value = headerBlock.get(i).value;
-        headerBlockOut.writeInt(value.size());
-        headerBlockOut.write(value);
-      }
-      headerBlockOut.flush();
-    }
-
-    @Override public synchronized void settings(Settings settings) throws IOException {
-      if (closed) throw new IOException("closed");
-      int type = TYPE_SETTINGS;
-      int flags = 0;
-      int size = settings.size();
-      int length = 4 + size * 8;
-      sink.writeInt(0x80000000 | (VERSION & 0x7fff) << 16 | type & 0xffff);
-      sink.writeInt((flags & 0xff) << 24 | length & 0xffffff);
-      sink.writeInt(size);
-      for (int i = 0; i <= Settings.COUNT; i++) {
-        if (!settings.isSet(i)) continue;
-        int settingsFlags = settings.flags(i);
-        sink.writeInt((settingsFlags & 0xff) << 24 | (i & 0xffffff));
-        sink.writeInt(settings.get(i));
-      }
-      sink.flush();
-    }
-
-    @Override public synchronized void ping(boolean reply, int payload1, int payload2)
-        throws IOException {
-      if (closed) throw new IOException("closed");
-      boolean payloadIsReply = client != ((payload1 & 1) == 1);
-      if (reply != payloadIsReply) throw new IllegalArgumentException("payload != reply");
-      int type = TYPE_PING;
-      int flags = 0;
-      int length = 4;
-      sink.writeInt(0x80000000 | (VERSION & 0x7fff) << 16 | type & 0xffff);
-      sink.writeInt((flags & 0xff) << 24 | length & 0xffffff);
-      sink.writeInt(payload1);
-      sink.flush();
-    }
-
-    @Override public synchronized void goAway(int lastGoodStreamId, ErrorCode errorCode,
-        byte[] ignored) throws IOException {
-      if (closed) throw new IOException("closed");
-      if (errorCode.spdyGoAwayCode == -1) {
-        throw new IllegalArgumentException("errorCode.spdyGoAwayCode == -1");
-      }
-      int type = TYPE_GOAWAY;
-      int flags = 0;
-      int length = 8;
-      sink.writeInt(0x80000000 | (VERSION & 0x7fff) << 16 | type & 0xffff);
-      sink.writeInt((flags & 0xff) << 24 | length & 0xffffff);
-      sink.writeInt(lastGoodStreamId);
-      sink.writeInt(errorCode.spdyGoAwayCode);
-      sink.flush();
-    }
-
-    @Override public synchronized void windowUpdate(int streamId, long increment)
-        throws IOException {
-      if (closed) throw new IOException("closed");
-      if (increment == 0 || increment > 0x7fffffffL) {
-        throw new IllegalArgumentException(
-            "windowSizeIncrement must be between 1 and 0x7fffffff: " + increment);
-      }
-      int type = TYPE_WINDOW_UPDATE;
-      int flags = 0;
-      int length = 8;
-      sink.writeInt(0x80000000 | (VERSION & 0x7fff) << 16 | type & 0xffff);
-      sink.writeInt((flags & 0xff) << 24 | length & 0xffffff);
-      sink.writeInt(streamId);
-      sink.writeInt((int) increment);
-      sink.flush();
-    }
-
-    @Override public synchronized void close() throws IOException {
-      closed = true;
-      Util.closeAll(sink, headerBlockOut);
-    }
-  }
-}
diff --git a/okhttp/src/main/java/okhttp3/internal/framed/Variant.java b/okhttp/src/main/java/okhttp3/internal/framed/Variant.java
deleted file mode 100644
index 4ff3794007..0000000000
--- a/okhttp/src/main/java/okhttp3/internal/framed/Variant.java
+++ /dev/null
@@ -1,37 +0,0 @@
-/*
- * Copyright (C) 2013 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.internal.framed;
-
-import okhttp3.Protocol;
-import okio.BufferedSink;
-import okio.BufferedSource;
-
-/** A version and dialect of the framed socket protocol. */
-public interface Variant {
-
-  /** The protocol as selected using ALPN. */
-  Protocol getProtocol();
-
-  /**
-   * @param client true if this is the HTTP client's reader, reading frames from a server.
-   */
-  FrameReader newReader(BufferedSource source, boolean client);
-
-  /**
-   * @param client true if this is the HTTP client's writer, writing frames to a server.
-   */
-  FrameWriter newWriter(BufferedSink sink, boolean client);
-}
diff --git a/okhttp/src/main/java/okhttp3/internal/http/Http2xStream.java b/okhttp/src/main/java/okhttp3/internal/http/Http2xStream.java
index ff1adcdbe1..082c2def81 100644
--- a/okhttp/src/main/java/okhttp3/internal/http/Http2xStream.java
+++ b/okhttp/src/main/java/okhttp3/internal/http/Http2xStream.java
@@ -18,10 +18,8 @@
 import java.io.IOException;
 import java.net.ProtocolException;
 import java.util.ArrayList;
-import java.util.LinkedHashSet;
 import java.util.List;
 import java.util.Locale;
-import java.util.Set;
 import java.util.concurrent.TimeUnit;
 import okhttp3.Headers;
 import okhttp3.OkHttpClient;
@@ -44,13 +42,11 @@
 
 import static okhttp3.internal.framed.Header.RESPONSE_STATUS;
 import static okhttp3.internal.framed.Header.TARGET_AUTHORITY;
-import static okhttp3.internal.framed.Header.TARGET_HOST;
 import static okhttp3.internal.framed.Header.TARGET_METHOD;
 import static okhttp3.internal.framed.Header.TARGET_PATH;
 import static okhttp3.internal.framed.Header.TARGET_SCHEME;
-import static okhttp3.internal.framed.Header.VERSION;
 
-/** An HTTP stream for HTTP/2 and SPDY. */
+/** An HTTP stream for HTTP/2. */
 public final class Http2xStream implements HttpStream {
   private static final ByteString CONNECTION = ByteString.encodeUtf8("connection");
   private static final ByteString HOST = ByteString.encodeUtf8("host");
@@ -61,26 +57,6 @@
   private static final ByteString ENCODING = ByteString.encodeUtf8("encoding");
   private static final ByteString UPGRADE = ByteString.encodeUtf8("upgrade");
 
-  /** See http://www.chromium.org/spdy/spdy-protocol/spdy-protocol-draft3-1#TOC-3.2.1-Request. */
-  private static final List<ByteString> SPDY_3_SKIPPED_REQUEST_HEADERS = Util.immutableList(
-      CONNECTION,
-      HOST,
-      KEEP_ALIVE,
-      PROXY_CONNECTION,
-      TRANSFER_ENCODING,
-      TARGET_METHOD,
-      TARGET_PATH,
-      TARGET_SCHEME,
-      TARGET_AUTHORITY,
-      TARGET_HOST,
-      VERSION);
-  private static final List<ByteString> SPDY_3_SKIPPED_RESPONSE_HEADERS = Util.immutableList(
-      CONNECTION,
-      HOST,
-      KEEP_ALIVE,
-      PROXY_CONNECTION,
-      TRANSFER_ENCODING);
-
   /** See http://tools.ietf.org/html/draft-ietf-httpbis-http2-09#section-8.1.3. */
   private static final List<ByteString> HTTP_2_SKIPPED_REQUEST_HEADERS = Util.immutableList(
       CONNECTION,
@@ -94,9 +70,7 @@
       TARGET_METHOD,
       TARGET_PATH,
       TARGET_SCHEME,
-      TARGET_AUTHORITY,
-      TARGET_HOST,
-      VERSION);
+      TARGET_AUTHORITY);
   private static final List<ByteString> HTTP_2_SKIPPED_RESPONSE_HEADERS = Util.immutableList(
       CONNECTION,
       HOST,
@@ -127,11 +101,8 @@ public Http2xStream(
     if (stream != null) return;
 
     boolean permitsRequestBody = HttpMethod.permitsRequestBody(request.method());
-    List<Header> requestHeaders = framedConnection.getProtocol() == Protocol.HTTP_2
-        ? http2HeadersList(request)
-        : spdy3HeadersList(request);
-    boolean hasResponseBody = true;
-    stream = framedConnection.newStream(requestHeaders, permitsRequestBody, hasResponseBody);
+    List<Header> requestHeaders = http2HeadersList(request);
+    stream = framedConnection.newStream(requestHeaders, permitsRequestBody);
     stream.readTimeout().timeout(client.readTimeoutMillis(), TimeUnit.MILLISECONDS);
     stream.writeTimeout().timeout(client.writeTimeoutMillis(), TimeUnit.MILLISECONDS);
   }
@@ -141,54 +112,7 @@ public Http2xStream(
   }
 
   @Override public Response.Builder readResponseHeaders() throws IOException {
-    return framedConnection.getProtocol() == Protocol.HTTP_2
-        ? readHttp2HeadersList(stream.getResponseHeaders())
-        : readSpdy3HeadersList(stream.getResponseHeaders());
-  }
-
-  /**
-   * Returns a list of alternating names and values containing a SPDY request. Names are all
-   * lowercase. No names are repeated. If any name has multiple values, they are concatenated using
-   * "\0" as a delimiter.
-   */
-  public static List<Header> spdy3HeadersList(Request request) {
-    Headers headers = request.headers();
-    List<Header> result = new ArrayList<>(headers.size() + 5);
-    result.add(new Header(TARGET_METHOD, request.method()));
-    result.add(new Header(TARGET_PATH, RequestLine.requestPath(request.url())));
-    result.add(new Header(VERSION, "HTTP/1.1"));
-    result.add(new Header(TARGET_HOST, Util.hostHeader(request.url(), false)));
-    result.add(new Header(TARGET_SCHEME, request.url().scheme()));
-
-    Set<ByteString> names = new LinkedHashSet<>();
-    for (int i = 0, size = headers.size(); i < size; i++) {
-      // header names must be lowercase.
-      ByteString name = ByteString.encodeUtf8(headers.name(i).toLowerCase(Locale.US));
-
-      // Drop headers that are forbidden when layering HTTP over SPDY.
-      if (SPDY_3_SKIPPED_REQUEST_HEADERS.contains(name)) continue;
-
-      // If we haven't seen this name before, add the pair to the end of the list...
-      String value = headers.value(i);
-      if (names.add(name)) {
-        result.add(new Header(name, value));
-        continue;
-      }
-
-      // ...otherwise concatenate the existing values and this value.
-      for (int j = 0; j < result.size(); j++) {
-        if (result.get(j).name.equals(name)) {
-          String concatenated = joinOnNull(result.get(j).value.utf8(), value);
-          result.set(j, new Header(name, concatenated));
-          break;
-        }
-      }
-    }
-    return result;
-  }
-
-  private static String joinOnNull(String first, String second) {
-    return new StringBuilder(first).append('\0').append(second).toString();
+    return readHttp2HeadersList(stream.getResponseHeaders());
   }
 
   public static List<Header> http2HeadersList(Request request) {
@@ -209,41 +133,6 @@ private static String joinOnNull(String first, String second) {
     return result;
   }
 
-  /** Returns headers for a name value block containing a SPDY response. */
-  public static Response.Builder readSpdy3HeadersList(List<Header> headerBlock) throws IOException {
-    String status = null;
-    String version = "HTTP/1.1";
-    Headers.Builder headersBuilder = new Headers.Builder();
-    for (int i = 0, size = headerBlock.size(); i < size; i++) {
-      ByteString name = headerBlock.get(i).name;
-
-      String values = headerBlock.get(i).value.utf8();
-      for (int start = 0; start < values.length(); ) {
-        int end = values.indexOf('\0', start);
-        if (end == -1) {
-          end = values.length();
-        }
-        String value = values.substring(start, end);
-        if (name.equals(RESPONSE_STATUS)) {
-          status = value;
-        } else if (name.equals(VERSION)) {
-          version = value;
-        } else if (!SPDY_3_SKIPPED_RESPONSE_HEADERS.contains(name)) {
-          Internal.instance.addLenient(headersBuilder, name.utf8(), value);
-        }
-        start = end + 1;
-      }
-    }
-    if (status == null) throw new ProtocolException("Expected ':status' header not present");
-
-    StatusLine statusLine = StatusLine.parse(version + " " + status);
-    return new Response.Builder()
-        .protocol(Protocol.SPDY_3)
-        .code(statusLine.code)
-        .message(statusLine.message)
-        .headers(headersBuilder.build());
-  }
-
   /** Returns headers for a name value block containing an HTTP/2 response. */
   public static Response.Builder readHttp2HeadersList(List<Header> headerBlock) throws IOException {
     String status = null;
diff --git a/okhttp/src/main/java/okhttp3/internal/http/RequestLine.java b/okhttp/src/main/java/okhttp3/internal/http/RequestLine.java
index c70a86934e..ecf0d7c2cc 100644
--- a/okhttp/src/main/java/okhttp3/internal/http/RequestLine.java
+++ b/okhttp/src/main/java/okhttp3/internal/http/RequestLine.java
@@ -27,7 +27,7 @@ private RequestLine() {
   /**
    * Returns the request status line, like "GET / HTTP/1.1". This is exposed to the application by
    * {@link HttpURLConnection#getHeaderFields}, so it needs to be set even if the transport is
-   * SPDY.
+   * HTTP/2.
    */
   static String get(Request request, Proxy.Type proxyType) {
     StringBuilder result = new StringBuilder();
diff --git a/okhttp/src/main/java/okhttp3/internal/platform/JdkWithJettyBootPlatform.java b/okhttp/src/main/java/okhttp3/internal/platform/JdkWithJettyBootPlatform.java
index 27947815d3..3d092b5cc2 100644
--- a/okhttp/src/main/java/okhttp3/internal/platform/JdkWithJettyBootPlatform.java
+++ b/okhttp/src/main/java/okhttp3/internal/platform/JdkWithJettyBootPlatform.java
@@ -69,7 +69,7 @@ public JdkWithJettyBootPlatform(Method putMethod, Method getMethod, Method remov
       JettyNegoProvider provider =
           (JettyNegoProvider) Proxy.getInvocationHandler(getMethod.invoke(null, socket));
       if (!provider.unsupported && provider.selected == null) {
-        Platform.get().log(INFO, "ALPN callback dropped: SPDY and HTTP/2 are disabled. "
+        Platform.get().log(INFO, "ALPN callback dropped: HTTP/2 is disabled. "
             + "Is alpn-boot on the boot class path?", null);
         return null;
       }
diff --git a/pom.xml b/pom.xml
index efcb446a4b..4a3f96b65e 100644
--- a/pom.xml
+++ b/pom.xml
@@ -15,7 +15,7 @@
   <packaging>pom</packaging>
 
   <name>OkHttp (Parent)</name>
-  <description>An HTTP+SPDY client for Android and Java applications</description>
+  <description>An HTTP+HTTP/2 client for Android and Java applications</description>
   <url>https://github.com/square/okhttp</url>
 
   <modules>
