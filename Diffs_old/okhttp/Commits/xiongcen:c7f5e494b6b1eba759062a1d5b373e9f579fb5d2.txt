diff --git a/okhttp/src/main/java/okhttp3/ConnectionPool.java b/okhttp/src/main/java/okhttp3/ConnectionPool.java
index dcbc0b441e..538798360a 100644
--- a/okhttp/src/main/java/okhttp3/ConnectionPool.java
+++ b/okhttp/src/main/java/okhttp3/ConnectionPool.java
@@ -118,9 +118,9 @@ RealConnection get(Address address, StreamAllocation streamAllocation) {
     assert (Thread.holdsLock(this));
     for (RealConnection connection : connections) {
       if (connection.allocations.size() < connection.allocationLimit
-          && address.equals(connection.route().address)
+          && address.equals(connection.route().address)// 根据url命中connection
           && !connection.noNewStreams) {
-        streamAllocation.acquire(connection);
+        streamAllocation.acquire(connection);// 将可用的连接放入
         return connection;
       }
     }
diff --git a/okhttp/src/main/java/okhttp3/internal/connection/RealConnection.java b/okhttp/src/main/java/okhttp3/internal/connection/RealConnection.java
index 547781d26f..5d986267bb 100644
--- a/okhttp/src/main/java/okhttp3/internal/connection/RealConnection.java
+++ b/okhttp/src/main/java/okhttp3/internal/connection/RealConnection.java
@@ -170,7 +170,9 @@ private void buildTunneledConnection(int connectTimeout, int readTimeout, int wr
   /** Does all the work necessary to build a full HTTP or HTTPS connection on a raw socket. */
   private void buildConnection(int connectTimeout, int readTimeout, int writeTimeout,
       ConnectionSpecSelector connectionSpecSelector) throws IOException {
+    // 连接socket
     connectSocket(connectTimeout, readTimeout);
+    // 根据HTTP协议版本做一些不同的事情
     establishProtocol(readTimeout, writeTimeout, connectionSpecSelector);
   }
 
@@ -190,6 +192,7 @@ private void connectSocket(int connectTimeout, int readTimeout) throws IOExcepti
       ce.initCause(e);
       throw ce;
     }
+    // 用Okio封装了socket的输入和输出流
     source = Okio.buffer(Okio.source(rawSocket));
     sink = Okio.buffer(Okio.sink(rawSocket));
   }
diff --git a/okhttp/src/main/java/okhttp3/internal/connection/StreamAllocation.java b/okhttp/src/main/java/okhttp3/internal/connection/StreamAllocation.java
index 73b2506f62..6450395ceb 100644
--- a/okhttp/src/main/java/okhttp3/internal/connection/StreamAllocation.java
+++ b/okhttp/src/main/java/okhttp3/internal/connection/StreamAllocation.java
@@ -107,6 +107,7 @@ public HttpCodec newStream(OkHttpClient client, boolean doExtensiveHealthChecks)
         resultConnection.socket().setSoTimeout(readTimeout);
         resultConnection.source.timeout().timeout(readTimeout, MILLISECONDS);
         resultConnection.sink.timeout().timeout(writeTimeout, MILLISECONDS);
+        // 构建HttpCodec
         resultCodec = new Http1Codec(
             client, this, resultConnection.source, resultConnection.sink);
       }
@@ -167,6 +168,7 @@ private RealConnection findConnection(int connectTimeout, int readTimeout, int w
       }
 
       // Attempt to get a connection from the pool.
+      // 从线程池中获取连接
       RealConnection pooledConnection = Internal.instance.get(connectionPool, address, this);
       if (pooledConnection != null) {
         this.connection = pooledConnection;
@@ -176,6 +178,7 @@ private RealConnection findConnection(int connectTimeout, int readTimeout, int w
       selectedRoute = route;
     }
 
+    // 如果selectedRoute为空，则选择下一条路由Route
     if (selectedRoute == null) {
       selectedRoute = routeSelector.next();
       synchronized (connectionPool) {
@@ -183,15 +186,18 @@ private RealConnection findConnection(int connectTimeout, int readTimeout, int w
         refusedStreamCount = 0;
       }
     }
+    // 以前面创建的route为参数新建一个RealConnection
     RealConnection newConnection = new RealConnection(selectedRoute);
 
     synchronized (connectionPool) {
       acquire(newConnection);
+      // 加入连接池
       Internal.instance.put(connectionPool, newConnection);
       this.connection = newConnection;
       if (canceled) throw new IOException("Canceled");
     }
 
+    // 调用RealConnection的connect()方法，实际上是buildConnection()构建连接。
     newConnection.connect(connectTimeout, readTimeout, writeTimeout, address.connectionSpecs(),
         connectionRetryEnabled);
     routeDatabase().connected(newConnection.route());
diff --git a/okhttp/src/main/java/okhttp3/internal/http1/Http1Codec.java b/okhttp/src/main/java/okhttp3/internal/http1/Http1Codec.java
index 3df3696e1f..94d49aa811 100644
--- a/okhttp/src/main/java/okhttp3/internal/http1/Http1Codec.java
+++ b/okhttp/src/main/java/okhttp3/internal/http1/Http1Codec.java
@@ -188,13 +188,15 @@ public void writeRequest(Headers headers, String requestLine) throws IOException
 
     try {
       while (true) {
+        // 1.从InputStream上读入一行数据
         StatusLine statusLine = StatusLine.parse(source.readUtf8LineStrict());
 
         Response.Builder responseBuilder = new Response.Builder()
             .protocol(statusLine.protocol)
             .code(statusLine.code)
             .message(statusLine.message)
-            .headers(readHeaders());
+                // 读取ResponseHeader
+                .headers(readHeaders());
 
         if (statusLine.code != HTTP_CONTINUE) {
           state = STATE_OPEN_RESPONSE_BODY;
