diff --git a/.travis.yml b/.travis.yml
index 1835d337fb..3173507916 100644
--- a/.travis.yml
+++ b/.travis.yml
@@ -1,9 +1,13 @@
 language: java
 
 jdk:
-  - oraclejdk7
   - oraclejdk8
 
+addons:
+  apt:
+    packages:
+      - oracle-java8-installer # Updates JDK 8 to the latest available.
+
 after_success:
   - .buildscript/deploy_snapshot.sh
 
diff --git a/CHANGELOG.md b/CHANGELOG.md
index b99f00f4e3..86e3bee13f 100644
--- a/CHANGELOG.md
+++ b/CHANGELOG.md
@@ -1,6 +1,177 @@
 Change Log
 ==========
 
+## Version 3.8.1
+
+_2017-06-18_
+
+ *  Fix: Recover gracefully from stale coalesced connections. We had a bug where
+    connection coalescing (introduced in OkHttp 3.7.0) and stale connection
+    recovery could interact to cause a `NoSuchElementException` crash in the
+    `RouteSelector`.
+
+
+## Version 3.8.0
+
+_2017-05-13_
+
+
+ *  **OkHttp now uses `@Nullable` to annotate all possibly-null values.** We've
+    added a compile-time dependency on the JSR 305 annotations. This is a
+    [provided][maven_provided] dependency and does not need to be included in
+    your build configuration, `.jar` file, or `.apk`. We use
+    `@ParametersAreNonnullByDefault` and all parameters and return types are
+    never null unless explicitly annotated `@Nullable`.
+
+ *  **Warning: this release is source-incompatible for Kotlin users.**
+    Nullability was previously ambiguous and lenient but now the compiler will
+    enforce strict null checks.
+
+ *  New: The response message is now non-null. This is the "Not Found" in the
+    status line "HTTP 404 Not Found". If you are building responses
+    programmatically (with `new Response.Builder()`) you must now always supply
+    a message. An empty string `""` is permitted. This value was never null on
+    responses returned by OkHttp itself, and it was an old mistake to permit
+    application code to omit a message.
+
+ *  The challenge's scheme and realm are now non-null. If you are calling
+    `new Challenge(scheme, realm)` you must provide non-null values. These were
+    never null in challenges created by OkHttp, but could have been null in
+    application code that creates challenges.
+
+ *  New: The `TlsVersion` of a `Handshake` is now non-null. If you are calling
+    `Handshake.get()` with a null TLS version, you must instead now provide a
+    non-null `TlsVersion`. Cache responses persisted prior to OkHttp 3.0 did not
+    store a TLS version; for these unknown values the handshake is defaulted to
+    `TlsVersion.SSL_3_0`.
+
+ *  New: Upgrade to Okio 1.13.0.
+
+     ```xml
+     <dependency>
+       <groupId>com.squareup.okio</groupId>
+       <artifactId>okio</artifactId>
+       <version>1.13.0</version>
+     </dependency>
+
+     com.squareup.okio:okio:1.13.0
+     ```
+
+ *  Fix: gracefully recover when Android 7.0's sockets throw an unexpected
+    `NullPointerException`.
+
+## Version 3.7.0
+
+_2017-04-15_
+
+ *  **OkHttp no longer recovers from TLS handshake failures by attempting a TLSv1 connection.**
+    The fallback was necessary for servers that implemented version negotiation incorrectly. Now
+    that 99.99% of servers do it right this fallback is obsolete.
+ *  Fix: Do not honor cookies set on a public domain. Previously a malicious site could inject
+    cookies on top-level domains like `co.uk` because our cookie parser didn't honor the [public
+    suffix][public_suffix] list. Alongside this fix is a new API, `HttpUrl.topPrivateDomain()`,
+    which returns the privately domain name if the URL has one.
+ *  Fix: Change `MediaType.charset()` to return null for unexpected charsets.
+ *  Fix: Don't skip cache invalidation if the invalidating response has no body.
+ *  Fix: Don't use a cryptographic random number generator for web sockets. Some Android devices
+    implement `SecureRandom` incorrectly!
+ *  Fix: Correctly canonicalize IPv6 addresses in `HttpUrl`. This prevented OkHttp from trusting
+    HTTPS certificates issued to certain IPv6 addresses.
+ *  Fix: Don't reuse connections after an unsuccessful `Expect: 100-continue`.
+ *  Fix: Handle either `TLS_` or `SSL_` prefixes for cipher suite names. This is necessary for
+    IBM JVMs that use the `SSL_` prefix exclusively.
+ *  Fix: Reject HTTP/2 data frames if the stream ID is 0.
+ *  New: Upgrade to Okio 1.12.0.
+
+     ```xml
+     <dependency>
+       <groupId>com.squareup.okio</groupId>
+       <artifactId>okio</artifactId>
+       <version>1.12.0</version>
+     </dependency>
+
+     com.squareup.okio:okio:1.12.0
+     ```
+
+ *  New: Connection coalescing. OkHttp may reuse HTTP/2 connections across calls that share an IP
+    address and HTTPS certificate, even if their domain names are different.
+ *  New: MockWebServer's `RecordedRequest` exposes the requested `HttpUrl` with `getRequestUrl()`.
+
+
+## Version 3.6.0
+
+_2017-01-29_
+
+ *  Fix: Don't crash with a "cache is closed" error when there is an error initializing the cache.
+ *  Fix: Calling `disconnect()` on a connecting `HttpUrlConnection` could cause it to retry in an
+    infinite loop! This regression was introduced in OkHttp 2.7.0.
+ *  Fix: Drop cookies that contain ASCII NULL and other bad characters. Previously such cookies
+    would cause OkHttp to crash when they were included in a request.
+ *  Fix: Release duplicated multiplexed connections. If we concurrently establish connections to an
+    HTTP/2 server, close all but the first connection.
+ *  Fix: Fail the HTTP/2 connection if first frame isn't `SETTINGS`.
+ *  Fix: Forbid spaces in header names.
+ *  Fix: Don't offer to do gzip if the request is partial.
+ *  Fix: MockWebServer is now usable with JUnit 5. That update [broke the rules][junit_5_rules].
+ *  New: Support `Expect: 100-continue` as a request header. Callers can use this header to
+    pessimistically hold off on transmitting a request body until a server gives the go-ahead.
+ *  New: Permit network interceptors to rewrite the host header for HTTP/2. This makes it possible
+    to do domain fronting.
+ *  New: charset support for `Credentials.basic()`.
+
+
+## Version 3.5.0
+
+_2016-11-30_
+
+ *  **Web Sockets are now a stable feature of OkHttp.** Since being introduced as a beta feature in
+    OkHttp 2.3 our web socket client has matured. Connect to a server's web socket with
+    `OkHttpClient.newWebSocket()`, send messages with `send()`, and receive messages with the
+    `WebSocketListener`.
+
+    The `okhttp-ws` submodule is no longer available and `okhttp-ws` artifacts from previous
+    releases of OkHttp are not compatible with OkHttp 3.5. When upgrading to the new package
+    please note that the `WebSocket` and `WebSocketCall` classes have been merged. Sending messages
+    is now asynchronous and they may be enqueued before the web socket is connected.
+
+ *  **OkHttp no longer attempts a direct connection if the system's HTTP proxy fails.** This
+    behavior was surprising because OkHttp was disregarding the user's specified configuration. If
+    you need to customize proxy fallback behavior, implement your own `java.net.ProxySelector`.
+
+ *  Fix: Support TLSv1.3 on devices that support it.
+
+ *  Fix: Share pooled connections across equivalent `OkHttpClient` instances. Previous releases had
+    a bug where a shared connection pool did not guarantee shared connections in some cases.
+ *  Fix: Prefer the server's response body on all conditional cache misses. Previously we would
+    return the cached response's body if it had a newer `Last-Modified` date.
+ *  Fix: Update the stored timestamp on conditional cache hits.
+ *  New: Optimized HTTP/2 request header encoding. More headers are HPACK-encoded and string
+    literals are now Huffman-encoded.
+ *  New: Expose `Part` headers and body in `Multipart`.
+ *  New: Make `ResponseBody.string()` and `ResponseBody.charStream()` BOM-aware. If your HTTP
+    response body begins with a [byte order mark][bom] it will be consumed and used to select a
+    charset for the remaining bytes. Most applications should not need a byte order mark.
+
+ *  New: Upgrade to Okio 1.11.0.
+
+     ```xml
+     <dependency>
+       <groupId>com.squareup.okio</groupId>
+       <artifactId>okio</artifactId>
+       <version>1.11.0</version>
+     </dependency>
+
+     com.squareup.okio:okio:1.11.0
+     ```
+
+ *  Fix: Avoid sending empty HTTP/2 data frames when there is no request body.
+ *  Fix: Add a leading `.` for better domain matching in `JavaNetCookieJar`.
+ *  Fix: Gracefully recover from HTTP/2 connection shutdowns at start of request.
+ *  Fix: Be lenient if a `MediaType`'s character set is `'single-quoted'`.
+ *  Fix: Allow horizontal tab characters in header values.
+ *  Fix: When parsing HTTP authentication headers permit challenge parameters in any order.
+
+
 ## Version 3.4.2
 
 _2016-11-03_
@@ -680,7 +851,7 @@ _2014-12-30_
  *  New: APIs to iterate and selectively clear the response cache.
  *  New: Support for SOCKS proxies.
  *  New: Support for `TLS_FALLBACK_SCSV`.
- *  New: Update HTTP/2 support to to `h2-16` and `hpack-10`.
+ *  New: Update HTTP/2 support to `h2-16` and `hpack-10`.
  *  New: APIs to prevent retrying non-idempotent requests.
  *  Fix: Drop NPN support. Going forward we support ALPN only.
  *  Fix: The hostname verifier is now strict. This is consistent with the hostname
@@ -1146,3 +1317,7 @@ Initial release.
  [major_versions]: http://jakewharton.com/java-interoperability-policy-for-major-version-updates/
  [nginx_959]: https://trac.nginx.org/nginx/ticket/959
  [okhttp_idling_resource]: https://github.com/JakeWharton/okhttp-idling-resource
+ [bom]: https://en.wikipedia.org/wiki/Byte_order_mark
+ [junit_5_rules]: http://junit.org/junit5/docs/current/user-guide/#migrating-from-junit4-rulesupport
+ [public_suffix]: https://publicsuffix.org/
+ [maven_provided]: https://maven.apache.org/guides/introduction/introduction-to-dependency-mechanism.html
diff --git a/README.md b/README.md
index 5b70072b86..1754c6d0c7 100644
--- a/README.md
+++ b/README.md
@@ -11,12 +11,12 @@ Download [the latest JAR][3] or grab via Maven:
 <dependency>
   <groupId>com.squareup.okhttp3</groupId>
   <artifactId>okhttp</artifactId>
-  <version>3.4.2</version>
+  <version>3.8.1</version>
 </dependency>
 ```
 or Gradle:
 ```groovy
-compile 'com.squareup.okhttp3:okhttp:3.4.2'
+compile 'com.squareup.okhttp3:okhttp:3.8.1'
 ```
 
 Snapshots of the development version are available in [Sonatype's `snapshots` repository][snap].
@@ -36,16 +36,24 @@ Download [the latest JAR][4] or grab via Maven:
 <dependency>
   <groupId>com.squareup.okhttp3</groupId>
   <artifactId>mockwebserver</artifactId>
-  <version>3.4.2</version>
+  <version>3.8.1</version>
   <scope>test</scope>
 </dependency>
 ```
 or Gradle:
 ```groovy
-testCompile 'com.squareup.okhttp3:mockwebserver:3.4.2'
+testCompile 'com.squareup.okhttp3:mockwebserver:3.8.1'
 ```
 
+ProGuard
+--------
 
+If you are using ProGuard you might need to add the following options:
+```
+-dontwarn okio.**
+-dontwarn javax.annotation.Nullable
+-dontwarn javax.annotation.ParametersAreNonnullByDefault
+```
 
 License
 -------
diff --git a/benchmarks/pom.xml b/benchmarks/pom.xml
index 0065b25634..80ed4470a0 100644
--- a/benchmarks/pom.xml
+++ b/benchmarks/pom.xml
@@ -6,7 +6,7 @@
   <parent>
     <groupId>com.squareup.okhttp3</groupId>
     <artifactId>parent</artifactId>
-    <version>3.5.0-SNAPSHOT</version>
+    <version>3.9.0-SNAPSHOT</version>
   </parent>
 
   <artifactId>benchmarks</artifactId>
diff --git a/benchmarks/src/main/java/okhttp3/benchmarks/ApacheHttpClient.java b/benchmarks/src/main/java/okhttp3/benchmarks/ApacheHttpClient.java
index a5c632fa0f..2fffd7cbf8 100644
--- a/benchmarks/src/main/java/okhttp3/benchmarks/ApacheHttpClient.java
+++ b/benchmarks/src/main/java/okhttp3/benchmarks/ApacheHttpClient.java
@@ -55,7 +55,7 @@
   class ApacheHttpClientRequest implements Runnable {
     private final HttpUrl url;
 
-    public ApacheHttpClientRequest(HttpUrl url) {
+    ApacheHttpClientRequest(HttpUrl url) {
       this.url = url;
     }
 
diff --git a/benchmarks/src/main/java/okhttp3/benchmarks/NettyHttpClient.java b/benchmarks/src/main/java/okhttp3/benchmarks/NettyHttpClient.java
index 01e6f6e257..cd7286d374 100644
--- a/benchmarks/src/main/java/okhttp3/benchmarks/NettyHttpClient.java
+++ b/benchmarks/src/main/java/okhttp3/benchmarks/NettyHttpClient.java
@@ -137,7 +137,7 @@ private void release(HttpChannel httpChannel) {
     int total;
     long start;
 
-    public HttpChannel(SocketChannel channel) {
+    HttpChannel(SocketChannel channel) {
       this.channel = channel;
     }
 
diff --git a/benchmarks/src/main/java/okhttp3/benchmarks/OkHttp.java b/benchmarks/src/main/java/okhttp3/benchmarks/OkHttp.java
index 7c90e5e6b5..7460aa66f6 100644
--- a/benchmarks/src/main/java/okhttp3/benchmarks/OkHttp.java
+++ b/benchmarks/src/main/java/okhttp3/benchmarks/OkHttp.java
@@ -61,7 +61,7 @@
   class OkHttpRequest implements Runnable {
     private final Call call;
 
-    public OkHttpRequest(Call call) {
+    OkHttpRequest(Call call) {
       this.call = call;
     }
 
diff --git a/benchmarks/src/main/java/okhttp3/benchmarks/UrlConnection.java b/benchmarks/src/main/java/okhttp3/benchmarks/UrlConnection.java
index f75d160835..560534c829 100644
--- a/benchmarks/src/main/java/okhttp3/benchmarks/UrlConnection.java
+++ b/benchmarks/src/main/java/okhttp3/benchmarks/UrlConnection.java
@@ -52,7 +52,7 @@
   static class UrlConnectionRequest implements Runnable {
     private final HttpUrl url;
 
-    public UrlConnectionRequest(HttpUrl url) {
+    UrlConnectionRequest(HttpUrl url) {
       this.url = url;
     }
 
diff --git a/checkstyle.xml b/checkstyle.xml
index e2660531c3..1e4d8e6d1d 100644
--- a/checkstyle.xml
+++ b/checkstyle.xml
@@ -1,7 +1,7 @@
 <?xml version="1.0"?>
 <!DOCTYPE module PUBLIC
-    "-//Puppy Crawl//DTD Check Configuration 1.2//EN"
-    "http://www.puppycrawl.com/dtds/configuration_1_2.dtd">
+    "-//Puppy Crawl//DTD Check Configuration 1.3//EN"
+    "http://www.puppycrawl.com/dtds/configuration_1_3.dtd">
 
 <module name="Checker">
   <module name="SuppressWarningsFilter"/>
@@ -121,7 +121,7 @@
     <!--module name="InnerAssignment"/-->
     <!--module name="MagicNumber"/-->
     <!--module name="MissingSwitchDefault"/-->
-    <module name="RedundantThrows"/>
+    <!--<module name="RedundantThrows"/>-->
     <module name="SimplifyBooleanExpression"/>
     <module name="SimplifyBooleanReturn"/>
 
diff --git a/mockwebserver/pom.xml b/mockwebserver/pom.xml
index 9f68096de5..00aae47aa4 100644
--- a/mockwebserver/pom.xml
+++ b/mockwebserver/pom.xml
@@ -6,7 +6,7 @@
   <parent>
     <groupId>com.squareup.okhttp3</groupId>
     <artifactId>parent</artifactId>
-    <version>3.5.0-SNAPSHOT</version>
+    <version>3.9.0-SNAPSHOT</version>
   </parent>
 
   <artifactId>mockwebserver</artifactId>
diff --git a/mockwebserver/src/main/java/okhttp3/internal/http2/Http2Server.java b/mockwebserver/src/main/java/okhttp3/internal/http2/Http2Server.java
index 9823d01343..643ab1eb4c 100644
--- a/mockwebserver/src/main/java/okhttp3/internal/http2/Http2Server.java
+++ b/mockwebserver/src/main/java/okhttp3/internal/http2/Http2Server.java
@@ -71,10 +71,10 @@ private void run() throws Exception {
             .build();
         connection.start();
       } catch (IOException e) {
-        logger.log(Level.INFO, "FramedServer connection failure: " + e);
+        logger.log(Level.INFO, "Http2Server connection failure: " + e);
         Util.closeQuietly(socket);
       } catch (Exception e) {
-        logger.log(Level.WARNING, "FramedServer unexpected failure", e);
+        logger.log(Level.WARNING, "Http2Server unexpected failure", e);
         Util.closeQuietly(socket);
       }
     }
@@ -90,7 +90,7 @@ private SSLSocket doSsl(Socket socket) throws IOException {
     return sslSocket;
   }
 
-  @Override public void onStream(final Http2Stream stream) throws IOException {
+  @Override public void onStream(Http2Stream stream) throws IOException {
     try {
       List<Header> requestHeaders = stream.getRequestHeaders();
       String path = null;
@@ -116,7 +116,7 @@ private SSLSocket doSsl(Socket socket) throws IOException {
         send404(stream, path);
       }
     } catch (IOException e) {
-      Platform.get().log(INFO, "Failure serving FramedStream: " + e.getMessage(), null);
+      Platform.get().log(INFO, "Failure serving Http2Stream: " + e.getMessage(), null);
     }
   }
 
@@ -126,7 +126,7 @@ private void send404(Http2Stream stream, String path) throws IOException {
         new Header(":version", "HTTP/1.1"),
         new Header("content-type", "text/plain")
     );
-    stream.reply(responseHeaders, true);
+    stream.sendResponseHeaders(responseHeaders, true);
     BufferedSink out = Okio.buffer(stream.getSink());
     out.writeUtf8("Not found: " + path);
     out.close();
@@ -138,7 +138,7 @@ private void serveDirectory(Http2Stream stream, File[] files) throws IOException
         new Header(":version", "HTTP/1.1"),
         new Header("content-type", "text/html; charset=UTF-8")
     );
-    stream.reply(responseHeaders, true);
+    stream.sendResponseHeaders(responseHeaders, true);
     BufferedSink out = Okio.buffer(stream.getSink());
     for (File file : files) {
       String target = file.isDirectory() ? (file.getName() + "/") : file.getName();
@@ -153,7 +153,7 @@ private void serveFile(Http2Stream stream, File file) throws IOException {
         new Header(":version", "HTTP/1.1"),
         new Header("content-type", contentType(file))
     );
-    stream.reply(responseHeaders, true);
+    stream.sendResponseHeaders(responseHeaders, true);
     Source source = Okio.source(file);
     try {
       BufferedSink out = Okio.buffer(stream.getSink());
@@ -177,7 +177,7 @@ private String contentType(File file) {
 
   public static void main(String... args) throws Exception {
     if (args.length != 1 || args[0].startsWith("-")) {
-      System.out.println("Usage: FramedServer <base directory>");
+      System.out.println("Usage: Http2Server <base directory>");
       return;
     }
 
diff --git a/mockwebserver/src/main/java/okhttp3/internal/tls/HeldCertificate.java b/mockwebserver/src/main/java/okhttp3/internal/tls/HeldCertificate.java
index a7fe81f0ef..eedfc2a094 100644
--- a/mockwebserver/src/main/java/okhttp3/internal/tls/HeldCertificate.java
+++ b/mockwebserver/src/main/java/okhttp3/internal/tls/HeldCertificate.java
@@ -22,14 +22,21 @@
 import java.security.SecureRandom;
 import java.security.Security;
 import java.security.cert.X509Certificate;
+import java.util.ArrayList;
 import java.util.Date;
+import java.util.List;
 import java.util.UUID;
 import javax.security.auth.x500.X500Principal;
+import org.bouncycastle.asn1.ASN1Encodable;
+import org.bouncycastle.asn1.DERSequence;
 import org.bouncycastle.asn1.x509.BasicConstraints;
+import org.bouncycastle.asn1.x509.GeneralName;
 import org.bouncycastle.asn1.x509.X509Extensions;
 import org.bouncycastle.jce.provider.BouncyCastleProvider;
 import org.bouncycastle.x509.X509V3CertificateGenerator;
 
+import static okhttp3.internal.Util.verifyAsIpAddress;
+
 /**
  * A certificate and its private key. This can be used on the server side by HTTPS servers, or on
  * the client side to verify those HTTPS servers. A held certificate can also be used to sign other
@@ -51,6 +58,7 @@ public HeldCertificate(X509Certificate certificate, KeyPair keyPair) {
 
     private final long duration = 1000L * 60 * 60 * 24; // One day.
     private String hostname;
+    private List<String> altNames = new ArrayList<>();
     private String serialNumber = "1";
     private KeyPair keyPair;
     private HeldCertificate issuedBy;
@@ -93,6 +101,15 @@ public Builder ca(int maxIntermediateCas) {
       return this;
     }
 
+    /**
+     * Adds a subject alternative name to the certificate. This is usually a hostname or IP address.
+     * If no subject alternative names are added that extension will not be used.
+     */
+    public Builder subjectAlternativeName(String altName) {
+      altNames.add(altName);
+      return this;
+    }
+
     public HeldCertificate build() throws GeneralSecurityException {
       // Subject, public & private keys for this certificate.
       KeyPair heldKeyPair = keyPair != null
@@ -129,6 +146,19 @@ public HeldCertificate build() throws GeneralSecurityException {
             new BasicConstraints(maxIntermediateCas));
       }
 
+      if (!altNames.isEmpty()) {
+        ASN1Encodable[] encodableAltNames = new ASN1Encodable[altNames.size()];
+        for (int i = 0, size = altNames.size(); i < size; i++) {
+          String altName = altNames.get(i);
+          int tag = verifyAsIpAddress(altName)
+              ? GeneralName.iPAddress
+              : GeneralName.dNSName;
+          encodableAltNames[i] = new GeneralName(tag, altName);
+        }
+        generator.addExtension(X509Extensions.SubjectAlternativeName, true,
+            new DERSequence(encodableAltNames));
+      }
+
       X509Certificate certificate = generator.generateX509Certificate(
           signedByKeyPair.getPrivate(), "BC");
       return new HeldCertificate(certificate, heldKeyPair);
diff --git a/mockwebserver/src/main/java/okhttp3/mockwebserver/MockWebServer.java b/mockwebserver/src/main/java/okhttp3/mockwebserver/MockWebServer.java
index 65a9885149..abbd79edb9 100644
--- a/mockwebserver/src/main/java/okhttp3/mockwebserver/MockWebServer.java
+++ b/mockwebserver/src/main/java/okhttp3/mockwebserver/MockWebServer.java
@@ -76,9 +76,7 @@
 import okio.Okio;
 import okio.Sink;
 import okio.Timeout;
-import org.junit.rules.TestRule;
-import org.junit.runner.Description;
-import org.junit.runners.model.Statement;
+import org.junit.rules.ExternalResource;
 
 import static okhttp3.internal.Util.closeQuietly;
 import static okhttp3.mockwebserver.SocketPolicy.DISCONNECT_AFTER_REQUEST;
@@ -86,6 +84,7 @@
 import static okhttp3.mockwebserver.SocketPolicy.DISCONNECT_AT_START;
 import static okhttp3.mockwebserver.SocketPolicy.DISCONNECT_DURING_REQUEST_BODY;
 import static okhttp3.mockwebserver.SocketPolicy.DISCONNECT_DURING_RESPONSE_BODY;
+import static okhttp3.mockwebserver.SocketPolicy.EXPECT_CONTINUE;
 import static okhttp3.mockwebserver.SocketPolicy.FAIL_HANDSHAKE;
 import static okhttp3.mockwebserver.SocketPolicy.NO_RESPONSE;
 import static okhttp3.mockwebserver.SocketPolicy.RESET_STREAM_AT_START;
@@ -97,7 +96,7 @@
  * A scriptable web server. Callers supply canned responses and the server replays them upon request
  * in sequence.
  */
-public final class MockWebServer implements TestRule, Closeable {
+public final class MockWebServer extends ExternalResource implements Closeable {
   static {
     Internal.initializeInstanceForTests();
   }
@@ -141,7 +140,7 @@
 
   private boolean started;
 
-  private synchronized void maybeStart() {
+  @Override protected synchronized void before() {
     if (started) return;
     try {
       start();
@@ -150,35 +149,18 @@ private synchronized void maybeStart() {
     }
   }
 
-  @Override public Statement apply(final Statement base, Description description) {
-    return new Statement() {
-      @Override public void evaluate() throws Throwable {
-        maybeStart();
-        try {
-          base.evaluate();
-        } finally {
-          try {
-            shutdown();
-          } catch (IOException e) {
-            logger.log(Level.WARNING, "MockWebServer shutdown failed", e);
-          }
-        }
-      }
-    };
-  }
-
   public int getPort() {
-    maybeStart();
+    before();
     return port;
   }
 
   public String getHostName() {
-    maybeStart();
+    before();
     return inetSocketAddress.getHostName();
   }
 
   public Proxy toProxyAddress() {
-    maybeStart();
+    before();
     InetSocketAddress address = new InetSocketAddress(inetSocketAddress.getAddress(), getPort());
     return new Proxy(Proxy.Type.HTTP, address);
   }
@@ -397,6 +379,14 @@ public synchronized void shutdown() throws IOException {
     }
   }
 
+  @Override protected synchronized void after() {
+    try {
+      shutdown();
+    } catch (IOException e) {
+      logger.log(Level.WARNING, "MockWebServer shutdown failed", e);
+    }
+  }
+
   private void serveConnection(final Socket raw) {
     executor.execute(new NamedRunnable("MockWebServer %s", raw.getRemoteSocketAddress()) {
       int sequenceNumber = 0;
@@ -448,10 +438,10 @@ public void processConnection() throws Exception {
         }
 
         if (protocol == Protocol.HTTP_2) {
-          FramedSocketHandler framedSocketListener = new FramedSocketHandler(socket, protocol);
+          Http2SocketHandler http2SocketHandler = new Http2SocketHandler(socket, protocol);
           Http2Connection connection = new Http2Connection.Builder(false)
               .socket(socket)
-              .listener(framedSocketListener)
+              .listener(http2SocketHandler)
               .build();
           connection.start();
           openConnections.add(connection);
@@ -590,7 +580,7 @@ private RecordedRequest readRequest(Socket socket, BufferedSource source, Buffer
     Headers.Builder headers = new Headers.Builder();
     long contentLength = -1;
     boolean chunked = false;
-    boolean expectContinue = false;
+    boolean readBody = true;
     String header;
     while ((header = source.readUtf8LineStrict()).length() != 0) {
       Internal.instance.addLenient(headers, header);
@@ -603,23 +593,26 @@ private RecordedRequest readRequest(Socket socket, BufferedSource source, Buffer
         chunked = true;
       }
       if (lowercaseHeader.startsWith("expect:")
-          && lowercaseHeader.substring(7).trim().equals("100-continue")) {
-        expectContinue = true;
+          && lowercaseHeader.substring(7).trim().equalsIgnoreCase("100-continue")) {
+        readBody = false;
       }
     }
 
-    if (expectContinue) {
+    if (!readBody && dispatcher.peek().getSocketPolicy() == EXPECT_CONTINUE) {
       sink.writeUtf8("HTTP/1.1 100 Continue\r\n");
       sink.writeUtf8("Content-Length: 0\r\n");
       sink.writeUtf8("\r\n");
       sink.flush();
+      readBody = true;
     }
 
     boolean hasBody = false;
     TruncatingBuffer requestBody = new TruncatingBuffer(bodyLimit);
     List<Integer> chunkSizes = new ArrayList<>();
     MockResponse policy = dispatcher.peek();
-    if (contentLength != -1) {
+    if (!readBody) {
+      // Don't read the body unless we've invited the client to send it.
+    } else if (contentLength != -1) {
       hasBody = contentLength > 0;
       throttledTransfer(policy, socket, source, Okio.buffer(requestBody), contentLength, true);
     } else if (chunked) {
@@ -676,17 +669,23 @@ private void handleWebSocketUpgrade(Socket socket, BufferedSource source, Buffer
     RealWebSocket webSocket = new RealWebSocket(fancyRequest,
         response.getWebSocketListener(), new SecureRandom());
     response.getWebSocketListener().onOpen(webSocket, fancyResponse);
-    webSocket.initReaderAndWriter(streams);
-    webSocket.loopReader();
-
-    // Even if messages are no longer being read we need to wait for the connection close signal.
+    String name = "MockWebServer WebSocket " + request.getPath();
+    webSocket.initReaderAndWriter(name, 0, streams);
     try {
-      connectionClose.await();
-    } catch (InterruptedException ignored) {
-    }
+      webSocket.loopReader();
+
+      // Even if messages are no longer being read we need to wait for the connection close signal.
+      try {
+        connectionClose.await();
+      } catch (InterruptedException ignored) {
+      }
 
-    closeQuietly(sink);
-    closeQuietly(source);
+    } catch (IOException e) {
+      webSocket.failWebSocket(e, null);
+    } finally {
+      closeQuietly(sink);
+      closeQuietly(source);
+    }
   }
 
   private void writeHttpResponse(Socket socket, BufferedSink sink, MockResponse response)
@@ -831,13 +830,13 @@ public void setDispatcher(Dispatcher dispatcher) {
     }
   }
 
-  /** Processes HTTP requests layered over framed protocols. */
-  private class FramedSocketHandler extends Http2Connection.Listener {
+  /** Processes HTTP requests layered over HTTP/2. */
+  private class Http2SocketHandler extends Http2Connection.Listener {
     private final Socket socket;
     private final Protocol protocol;
     private final AtomicInteger sequenceNumber = new AtomicInteger();
 
-    private FramedSocketHandler(Socket socket, Protocol protocol) {
+    private Http2SocketHandler(Socket socket, Protocol protocol) {
       this.socket = socket;
       this.protocol = protocol;
     }
@@ -857,12 +856,17 @@ private FramedSocketHandler(Socket socket, Protocol protocol) {
       RecordedRequest request = readRequest(stream);
       requestCount.incrementAndGet();
       requestQueue.add(request);
+
       MockResponse response;
       try {
         response = dispatcher.dispatch(request);
       } catch (InterruptedException e) {
         throw new AssertionError(e);
       }
+      if (response.getSocketPolicy() == DISCONNECT_AFTER_REQUEST) {
+        socket.close();
+        return;
+      }
       writeResponse(stream, response);
       if (logger.isLoggable(Level.INFO)) {
         logger.info(MockWebServer.this + " received request: " + request
@@ -880,6 +884,7 @@ private RecordedRequest readRequest(Http2Stream stream) throws IOException {
       Headers.Builder httpHeaders = new Headers.Builder();
       String method = "<:method omitted>";
       String path = "<:path omitted>";
+      boolean readBody = true;
       for (int i = 0, size = streamHeaders.size(); i < size; i++) {
         ByteString name = streamHeaders.get(i).name;
         String value = streamHeaders.get(i).value.utf8();
@@ -892,11 +897,23 @@ private RecordedRequest readRequest(Http2Stream stream) throws IOException {
         } else {
           throw new IllegalStateException();
         }
+        if (name.utf8().equals("expect") && value.equalsIgnoreCase("100-continue")) {
+          // Don't read the body unless we've invited the client to send it.
+          readBody = false;
+        }
+      }
+
+      if (!readBody && dispatcher.peek().getSocketPolicy() == EXPECT_CONTINUE) {
+        stream.sendResponseHeaders(Collections.singletonList(
+            new Header(Header.RESPONSE_STATUS, ByteString.encodeUtf8("100 Continue"))), true);
+        stream.getConnection().flush();
+        readBody = true;
       }
 
       Buffer body = new Buffer();
-      body.writeAll(stream.getSource());
-      body.close();
+      if (readBody) {
+        body.writeAll(stream.getSource());
+      }
 
       String requestLine = method + ' ' + path + " HTTP/1.1";
       List<Integer> chunkSizes = Collections.emptyList(); // No chunked encoding for HTTP/2.
@@ -927,7 +944,7 @@ private void writeResponse(Http2Stream stream, MockResponse response) throws IOE
 
       Buffer body = response.getBody();
       boolean closeStreamAfterHeaders = body != null || !response.getPushPromises().isEmpty();
-      stream.reply(http2Headers, closeStreamAfterHeaders);
+      stream.sendResponseHeaders(http2Headers, closeStreamAfterHeaders);
       pushPromises(stream, response.getPushPromises());
       if (body != null) {
         BufferedSink sink = Okio.buffer(stream.getSink());
diff --git a/mockwebserver/src/main/java/okhttp3/mockwebserver/RecordedRequest.java b/mockwebserver/src/main/java/okhttp3/mockwebserver/RecordedRequest.java
index aa847001a2..672d42bc76 100644
--- a/mockwebserver/src/main/java/okhttp3/mockwebserver/RecordedRequest.java
+++ b/mockwebserver/src/main/java/okhttp3/mockwebserver/RecordedRequest.java
@@ -20,6 +20,7 @@
 import java.util.List;
 import javax.net.ssl.SSLSocket;
 import okhttp3.Headers;
+import okhttp3.HttpUrl;
 import okhttp3.TlsVersion;
 import okio.Buffer;
 
@@ -34,6 +35,7 @@
   private final Buffer body;
   private final int sequenceNumber;
   private final TlsVersion tlsVersion;
+  private final HttpUrl requestUrl;
 
   public RecordedRequest(String requestLine, Headers headers, List<Integer> chunkSizes,
       long bodySize, Buffer body, int sequenceNumber, Socket socket) {
@@ -52,12 +54,22 @@ public RecordedRequest(String requestLine, Headers headers, List<Integer> chunkS
       int pathEnd = requestLine.indexOf(' ', methodEnd + 1);
       this.method = requestLine.substring(0, methodEnd);
       this.path = requestLine.substring(methodEnd + 1, pathEnd);
+
+      String scheme = socket instanceof SSLSocket ? "https" : "http";
+      String hostname = socket.getInetAddress().getHostName();
+      int port = socket.getLocalPort();
+      this.requestUrl = HttpUrl.parse(String.format("%s://%s:%s%s", scheme, hostname, port, path));
     } else {
+      this.requestUrl = null;
       this.method = null;
       this.path = null;
     }
   }
 
+  public HttpUrl getRequestUrl() {
+    return requestUrl;
+  }
+
   public String getRequestLine() {
     return requestLine;
   }
diff --git a/mockwebserver/src/main/java/okhttp3/mockwebserver/SocketPolicy.java b/mockwebserver/src/main/java/okhttp3/mockwebserver/SocketPolicy.java
index 153d3fd129..521c5a0e58 100644
--- a/mockwebserver/src/main/java/okhttp3/mockwebserver/SocketPolicy.java
+++ b/mockwebserver/src/main/java/okhttp3/mockwebserver/SocketPolicy.java
@@ -97,5 +97,12 @@
    * Fail HTTP/2 requests without processing them by sending an {@linkplain
    * MockResponse#getHttp2ErrorCode() HTTP/2 error code}.
    */
-  RESET_STREAM_AT_START
+  RESET_STREAM_AT_START,
+
+  /**
+   * Transmit a {@code HTTP/1.1 100 Continue} response before reading the HTTP request body.
+   * Typically this response is sent when a client makes a request with the header {@code
+   * Expect: 100-continue}.
+   */
+  EXPECT_CONTINUE
 }
diff --git a/mockwebserver/src/test/java/okhttp3/mockwebserver/MockWebServerTest.java b/mockwebserver/src/test/java/okhttp3/mockwebserver/MockWebServerTest.java
index b0a3ec06ee..13cefd60f0 100644
--- a/mockwebserver/src/test/java/okhttp3/mockwebserver/MockWebServerTest.java
+++ b/mockwebserver/src/test/java/okhttp3/mockwebserver/MockWebServerTest.java
@@ -33,6 +33,7 @@
 import java.util.concurrent.TimeUnit;
 import java.util.concurrent.atomic.AtomicBoolean;
 import okhttp3.Headers;
+import okhttp3.HttpUrl;
 import okhttp3.internal.Util;
 import org.junit.After;
 import org.junit.Rule;
@@ -405,4 +406,25 @@
     // Shutting down the server should unblock the dispatcher.
     server.shutdown();
   }
+
+  @Test public void requestUrlReconstructed() throws Exception {
+    server.enqueue(new MockResponse().setBody("hello world"));
+
+    URL url = server.url("/a/deep/path?key=foo%20bar").url();
+    HttpURLConnection connection = (HttpURLConnection) url.openConnection();
+    InputStream in = connection.getInputStream();
+    BufferedReader reader = new BufferedReader(new InputStreamReader(in));
+    assertEquals(HttpURLConnection.HTTP_OK, connection.getResponseCode());
+    assertEquals("hello world", reader.readLine());
+
+    RecordedRequest request = server.takeRequest();
+    assertEquals("GET /a/deep/path?key=foo%20bar HTTP/1.1", request.getRequestLine());
+
+    HttpUrl requestUrl = request.getRequestUrl();
+    assertEquals("http", requestUrl.scheme());
+    assertEquals(server.getHostName(), requestUrl.host());
+    assertEquals(server.getPort(), requestUrl.port());
+    assertEquals("/a/deep/path", requestUrl.encodedPath());
+    assertEquals("foo bar", requestUrl.queryParameter("key"));
+  }
 }
diff --git a/okcurl/pom.xml b/okcurl/pom.xml
index edc86849cf..85b6b55647 100644
--- a/okcurl/pom.xml
+++ b/okcurl/pom.xml
@@ -6,7 +6,7 @@
   <parent>
     <groupId>com.squareup.okhttp3</groupId>
     <artifactId>parent</artifactId>
-    <version>3.5.0-SNAPSHOT</version>
+    <version>3.9.0-SNAPSHOT</version>
   </parent>
 
   <artifactId>okcurl</artifactId>
diff --git a/okhttp-android-support/pom.xml b/okhttp-android-support/pom.xml
index 1485393521..ef5f02808f 100644
--- a/okhttp-android-support/pom.xml
+++ b/okhttp-android-support/pom.xml
@@ -6,7 +6,7 @@
   <parent>
     <groupId>com.squareup.okhttp3</groupId>
     <artifactId>parent</artifactId>
-    <version>3.5.0-SNAPSHOT</version>
+    <version>3.9.0-SNAPSHOT</version>
   </parent>
 
   <artifactId>okhttp-android-support</artifactId>
@@ -16,6 +16,11 @@
   </description>
 
   <dependencies>
+    <dependency>
+      <groupId>com.google.code.findbugs</groupId>
+      <artifactId>jsr305</artifactId>
+      <scope>provided</scope>
+    </dependency>
     <dependency>
       <groupId>${project.groupId}</groupId>
       <artifactId>okhttp-testing-support</artifactId>
diff --git a/okhttp-android-support/src/main/java/okhttp3/internal/huc/JavaApiConverter.java b/okhttp-android-support/src/main/java/okhttp3/internal/huc/JavaApiConverter.java
index b65d463b51..1dec85cdc0 100644
--- a/okhttp-android-support/src/main/java/okhttp3/internal/huc/JavaApiConverter.java
+++ b/okhttp-android-support/src/main/java/okhttp3/internal/huc/JavaApiConverter.java
@@ -42,6 +42,7 @@
 import okhttp3.RequestBody;
 import okhttp3.Response;
 import okhttp3.ResponseBody;
+import okhttp3.TlsVersion;
 import okhttp3.internal.Internal;
 import okhttp3.internal.JavaNetHeaders;
 import okhttp3.internal.Util;
@@ -133,7 +134,7 @@ public static Response createOkResponseForCachePut(URI uri, URLConnection urlCon
 
       String cipherSuiteString = httpsUrlConnection.getCipherSuite();
       CipherSuite cipherSuite = CipherSuite.forJavaName(cipherSuiteString);
-      Handshake handshake = Handshake.get(null, cipherSuite,
+      Handshake handshake = Handshake.get(TlsVersion.SSL_3_0, cipherSuite,
           nullSafeImmutableList(peerCertificates), nullSafeImmutableList(localCertificates));
       okResponseBuilder.handshake(handshake);
     }
@@ -260,7 +261,8 @@ static Response createOkResponseForCacheGet(Request request, CacheResponse javaR
 
       String cipherSuiteString = javaSecureCacheResponse.getCipherSuite();
       CipherSuite cipherSuite = CipherSuite.forJavaName(cipherSuiteString);
-      Handshake handshake = Handshake.get(null, cipherSuite, peerCertificates, localCertificates);
+      Handshake handshake = Handshake.get(
+          TlsVersion.SSL_3_0, cipherSuite, peerCertificates, localCertificates);
       okResponseBuilder.handshake(handshake);
     }
 
@@ -566,7 +568,7 @@ private static ResponseBody createOkBody(final URLConnection urlConnection) thro
     private final Request request;
     private final Response response;
 
-    public CacheHttpURLConnection(Response response) {
+    CacheHttpURLConnection(Response response) {
       super(response.request().url().url());
       this.request = response.request();
       this.response = response;
@@ -833,7 +835,7 @@ public void setDefaultUseCaches(boolean defaultUseCaches) {
   private static final class CacheHttpsURLConnection extends DelegatingHttpsURLConnection {
     private final CacheHttpURLConnection delegate;
 
-    public CacheHttpsURLConnection(CacheHttpURLConnection delegate) {
+    CacheHttpsURLConnection(CacheHttpURLConnection delegate) {
       super(delegate);
       this.delegate = delegate;
     }
diff --git a/okhttp-android-support/src/test/java/okhttp3/internal/huc/JavaApiConverterTest.java b/okhttp-android-support/src/test/java/okhttp3/internal/huc/JavaApiConverterTest.java
index 353931a072..c14d6d57f4 100644
--- a/okhttp-android-support/src/test/java/okhttp3/internal/huc/JavaApiConverterTest.java
+++ b/okhttp-android-support/src/test/java/okhttp3/internal/huc/JavaApiConverterTest.java
@@ -47,6 +47,7 @@
 import okhttp3.RequestBody;
 import okhttp3.Response;
 import okhttp3.ResponseBody;
+import okhttp3.TlsVersion;
 import okhttp3.internal.Internal;
 import okhttp3.internal.Util;
 import okhttp3.mockwebserver.MockWebServer;
@@ -464,7 +465,7 @@ private void assertHeadersContainsMapping(Map<String, List<String>> headers, Str
         .get()
         .url("https://secure/request")
         .build();
-    Handshake handshake = Handshake.get(null, CipherSuite.TLS_RSA_WITH_NULL_MD5,
+    Handshake handshake = Handshake.get(TlsVersion.SSL_3_0, CipherSuite.TLS_RSA_WITH_NULL_MD5,
         Arrays.<Certificate>asList(SERVER_CERT), Arrays.<Certificate>asList(LOCAL_CERT));
     Response okResponse = createArbitraryOkResponse(okRequest).newBuilder()
         .handshake(handshake)
@@ -554,7 +555,7 @@ private void assertHeadersContainsMapping(Map<String, List<String>> headers, Str
             .post(createRequestBody("RequestBody"))
             .build();
     ResponseBody responseBody = createResponseBody("ResponseBody");
-    Handshake handshake = Handshake.get(null, CipherSuite.TLS_RSA_WITH_NULL_MD5,
+    Handshake handshake = Handshake.get(TlsVersion.SSL_3_0, CipherSuite.TLS_RSA_WITH_NULL_MD5,
         Arrays.<Certificate>asList(SERVER_CERT), Arrays.<Certificate>asList(LOCAL_CERT));
     Response okResponse = createArbitraryOkResponse(okRequest).newBuilder()
         .protocol(Protocol.HTTP_1_1)
diff --git a/okhttp-apache/pom.xml b/okhttp-apache/pom.xml
index ed13f59fb2..5c35b8d6c9 100644
--- a/okhttp-apache/pom.xml
+++ b/okhttp-apache/pom.xml
@@ -6,7 +6,7 @@
   <parent>
     <groupId>com.squareup.okhttp3</groupId>
     <artifactId>parent</artifactId>
-    <version>3.5.0-SNAPSHOT</version>
+    <version>3.9.0-SNAPSHOT</version>
   </parent>
 
   <artifactId>okhttp-apache</artifactId>
diff --git a/okhttp-logging-interceptor/pom.xml b/okhttp-logging-interceptor/pom.xml
index 5f9d7862c8..1513f73b44 100644
--- a/okhttp-logging-interceptor/pom.xml
+++ b/okhttp-logging-interceptor/pom.xml
@@ -6,7 +6,7 @@
   <parent>
     <groupId>com.squareup.okhttp3</groupId>
     <artifactId>parent</artifactId>
-    <version>3.5.0-SNAPSHOT</version>
+    <version>3.9.0-SNAPSHOT</version>
   </parent>
 
   <artifactId>logging-interceptor</artifactId>
@@ -18,6 +18,11 @@
       <artifactId>okhttp</artifactId>
       <version>${project.version}</version>
     </dependency>
+    <dependency>
+      <groupId>com.google.code.findbugs</groupId>
+      <artifactId>jsr305</artifactId>
+      <scope>provided</scope>
+    </dependency>
 
     <dependency>
       <groupId>junit</groupId>
diff --git a/okhttp-logging-interceptor/src/main/java/okhttp3/logging/HttpLoggingInterceptor.java b/okhttp-logging-interceptor/src/main/java/okhttp3/logging/HttpLoggingInterceptor.java
index c5217b16c9..173d88caff 100644
--- a/okhttp-logging-interceptor/src/main/java/okhttp3/logging/HttpLoggingInterceptor.java
+++ b/okhttp-logging-interceptor/src/main/java/okhttp3/logging/HttpLoggingInterceptor.java
@@ -18,7 +18,6 @@
 import java.io.EOFException;
 import java.io.IOException;
 import java.nio.charset.Charset;
-import java.nio.charset.UnsupportedCharsetException;
 import java.util.concurrent.TimeUnit;
 import okhttp3.Connection;
 import okhttp3.Headers;
@@ -241,15 +240,7 @@ public Level getLevel() {
         Charset charset = UTF8;
         MediaType contentType = responseBody.contentType();
         if (contentType != null) {
-          try {
-            charset = contentType.charset(UTF8);
-          } catch (UnsupportedCharsetException e) {
-            logger.log("");
-            logger.log("Couldn't decode the response body; charset is likely malformed.");
-            logger.log("<-- END HTTP");
-
-            return response;
-          }
+          charset = contentType.charset(UTF8);
         }
 
         if (!isPlaintext(buffer)) {
diff --git a/okhttp-logging-interceptor/src/main/java/okhttp3/logging/package-info.java b/okhttp-logging-interceptor/src/main/java/okhttp3/logging/package-info.java
new file mode 100644
index 0000000000..39904701cf
--- /dev/null
+++ b/okhttp-logging-interceptor/src/main/java/okhttp3/logging/package-info.java
@@ -0,0 +1,3 @@
+/** An OkHttp interceptor which logs HTTP request and response data. */
+@javax.annotation.ParametersAreNonnullByDefault
+package okhttp3.logging;
diff --git a/okhttp-logging-interceptor/src/test/java/okhttp3/logging/HttpLoggingInterceptorTest.java b/okhttp-logging-interceptor/src/test/java/okhttp3/logging/HttpLoggingInterceptorTest.java
index caa6cd72bd..c631899fb3 100644
--- a/okhttp-logging-interceptor/src/test/java/okhttp3/logging/HttpLoggingInterceptorTest.java
+++ b/okhttp-logging-interceptor/src/test/java/okhttp3/logging/HttpLoggingInterceptorTest.java
@@ -563,7 +563,7 @@ private void bodyGetNoBody(int code) throws IOException {
 
     server.enqueue(new MockResponse()
         .setHeader("Content-Type", "text/html; charset=0")
-        .setBody("Ignore This"));
+        .setBody("Body with unknown charset"));
     Response response = client.newCall(request().build()).execute();
     response.body().close();
 
@@ -578,8 +578,8 @@ private void bodyGetNoBody(int code) throws IOException {
         .assertLogEqual("Content-Type: text/html; charset=0")
         .assertLogMatch("Content-Length: \\d+")
         .assertLogMatch("")
-        .assertLogEqual("Couldn't decode the response body; charset is likely malformed.")
-        .assertLogEqual("<-- END HTTP")
+        .assertLogEqual("Body with unknown charset")
+        .assertLogEqual("<-- END HTTP (25-byte body)")
         .assertNoMoreLogs();
 
     applicationLogs
@@ -589,8 +589,8 @@ private void bodyGetNoBody(int code) throws IOException {
         .assertLogEqual("Content-Type: text/html; charset=0")
         .assertLogMatch("Content-Length: \\d+")
         .assertLogEqual("")
-        .assertLogEqual("Couldn't decode the response body; charset is likely malformed.")
-        .assertLogEqual("<-- END HTTP")
+        .assertLogEqual("Body with unknown charset")
+        .assertLogEqual("<-- END HTTP (25-byte body)")
         .assertNoMoreLogs();
   }
 
diff --git a/okhttp-testing-support/pom.xml b/okhttp-testing-support/pom.xml
index 18f83cc3b6..f6a7c1f40d 100644
--- a/okhttp-testing-support/pom.xml
+++ b/okhttp-testing-support/pom.xml
@@ -6,7 +6,7 @@
   <parent>
     <groupId>com.squareup.okhttp3</groupId>
     <artifactId>parent</artifactId>
-    <version>3.5.0-SNAPSHOT</version>
+    <version>3.9.0-SNAPSHOT</version>
   </parent>
 
   <artifactId>okhttp-testing-support</artifactId>
@@ -23,5 +23,10 @@
       <artifactId>okhttp</artifactId>
       <version>${project.version}</version>
     </dependency>
+    <dependency>
+      <groupId>com.google.code.findbugs</groupId>
+      <artifactId>jsr305</artifactId>
+      <scope>provided</scope>
+    </dependency>
   </dependencies>
 </project>
diff --git a/okhttp-testing-support/src/main/java/okhttp3/FakeDns.java b/okhttp-testing-support/src/main/java/okhttp3/FakeDns.java
index f2edc75d66..e12ea9c622 100644
--- a/okhttp-testing-support/src/main/java/okhttp3/FakeDns.java
+++ b/okhttp-testing-support/src/main/java/okhttp3/FakeDns.java
@@ -19,39 +19,61 @@
 import java.net.UnknownHostException;
 import java.util.ArrayList;
 import java.util.Arrays;
-import java.util.Collections;
+import java.util.LinkedHashMap;
 import java.util.List;
+import java.util.Map;
 
 import static org.junit.Assert.assertEquals;
 
 public final class FakeDns implements Dns {
-  private List<String> requestedHosts = new ArrayList<>();
-  private List<InetAddress> addresses = Collections.emptyList();
+  private final Map<String, List<InetAddress>> hostAddresses = new LinkedHashMap<>();
+  private final List<String> requestedHosts = new ArrayList<>();
+  private int nextAddress = 100;
 
-  /** Sets the addresses to be returned by this fake DNS service. */
-  public FakeDns addresses(List<InetAddress> addresses) {
-    this.addresses = new ArrayList<>(addresses);
+  /** Sets the results for {@code hostname}. */
+  public FakeDns set(String hostname, List<InetAddress> addresses) {
+    hostAddresses.put(hostname, addresses);
     return this;
   }
 
-  /** Sets the service to throw when a hostname is requested. */
-  public FakeDns unknownHost() {
-    this.addresses = Collections.emptyList();
+  /** Clears the results for {@code hostname}. */
+  public FakeDns clear(String hostname) {
+    hostAddresses.remove(hostname);
     return this;
   }
 
-  public InetAddress address(int index) {
-    return addresses.get(index);
+  public InetAddress lookup(String hostname, int index) throws UnknownHostException {
+    return hostAddresses.get(hostname).get(index);
   }
 
   @Override public List<InetAddress> lookup(String hostname) throws UnknownHostException {
     requestedHosts.add(hostname);
-    if (addresses.isEmpty()) throw new UnknownHostException();
-    return addresses;
+
+    List<InetAddress> result = hostAddresses.get(hostname);
+    if (result != null) return result;
+
+    throw new UnknownHostException();
   }
 
   public void assertRequests(String... expectedHosts) {
     assertEquals(Arrays.asList(expectedHosts), requestedHosts);
     requestedHosts.clear();
   }
+
+  /** Allocates and returns {@code count} fake addresses like [255.0.0.100, 255.0.0.101]. */
+  public List<InetAddress> allocate(int count) {
+    try {
+      List<InetAddress> result = new ArrayList<>();
+      for (int i = 0; i < count; i++) {
+        if (nextAddress > 255) {
+          throw new AssertionError("too many addresses allocated");
+        }
+        result.add(InetAddress.getByAddress(
+            new byte[] {(byte) 255, (byte) 0, (byte) 0, (byte) nextAddress++}));
+      }
+      return result;
+    } catch (UnknownHostException e) {
+      throw new AssertionError();
+    }
+  }
 }
diff --git a/okhttp-tests/pom.xml b/okhttp-tests/pom.xml
index 4b3a04ac78..2ac6188ae8 100644
--- a/okhttp-tests/pom.xml
+++ b/okhttp-tests/pom.xml
@@ -6,7 +6,7 @@
   <parent>
     <groupId>com.squareup.okhttp3</groupId>
     <artifactId>parent</artifactId>
-    <version>3.5.0-SNAPSHOT</version>
+    <version>3.9.0-SNAPSHOT</version>
   </parent>
 
   <artifactId>okhttp-tests</artifactId>
@@ -17,6 +17,11 @@
       <groupId>com.squareup.okio</groupId>
       <artifactId>okio</artifactId>
     </dependency>
+    <dependency>
+      <groupId>com.google.code.findbugs</groupId>
+      <artifactId>jsr305</artifactId>
+      <scope>provided</scope>
+    </dependency>
     <dependency>
       <groupId>${project.groupId}</groupId>
       <artifactId>okhttp</artifactId>
diff --git a/okhttp-tests/src/test/java/okhttp3/AddressTest.java b/okhttp-tests/src/test/java/okhttp3/AddressTest.java
index 30e376be5b..ad07b78241 100644
--- a/okhttp-tests/src/test/java/okhttp3/AddressTest.java
+++ b/okhttp-tests/src/test/java/okhttp3/AddressTest.java
@@ -15,6 +15,7 @@
  */
 package okhttp3;
 
+import java.net.Proxy;
 import java.util.List;
 import javax.net.SocketFactory;
 import okhttp3.internal.Util;
@@ -48,4 +49,17 @@
         authenticator, null, protocols, connectionSpecs, new RecordingProxySelector());
     assertFalse(a.equals(b));
   }
+
+  @Test public void addressToString() throws Exception {
+    Address address = new Address("square.com", 80, dns, socketFactory, null, null, null,
+        authenticator, null, protocols, connectionSpecs, proxySelector);
+    assertEquals("Address{square.com:80, proxySelector=RecordingProxySelector}",
+        address.toString());
+  }
+
+  @Test public void addressWithProxyToString() throws Exception {
+    Address address = new Address("square.com", 80, dns, socketFactory, null, null, null,
+        authenticator, Proxy.NO_PROXY, protocols, connectionSpecs, proxySelector);
+    assertEquals("Address{square.com:80, proxy=" + Proxy.NO_PROXY + "}", address.toString());
+  }
 }
diff --git a/okhttp-tests/src/test/java/okhttp3/CacheControlTest.java b/okhttp-tests/src/test/java/okhttp3/CacheControlTest.java
index ef15052a93..356f96ab46 100644
--- a/okhttp-tests/src/test/java/okhttp3/CacheControlTest.java
+++ b/okhttp-tests/src/test/java/okhttp3/CacheControlTest.java
@@ -51,15 +51,18 @@
         .minFresh(3, TimeUnit.SECONDS)
         .onlyIfCached()
         .noTransform()
+        .immutable()
         .build();
     assertEquals("no-cache, no-store, max-age=1, max-stale=2, min-fresh=3, only-if-cached, "
-        + "no-transform", cacheControl.toString());
+        + "no-transform, immutable", cacheControl.toString());
     assertTrue(cacheControl.noCache());
     assertTrue(cacheControl.noStore());
     assertEquals(1, cacheControl.maxAgeSeconds());
     assertEquals(2, cacheControl.maxStaleSeconds());
     assertEquals(3, cacheControl.minFreshSeconds());
     assertTrue(cacheControl.onlyIfCached());
+    assertTrue(cacheControl.noTransform());
+    assertTrue(cacheControl.immutable());
 
     // These members are accessible to response headers only.
     assertEquals(-1, cacheControl.sMaxAgeSeconds());
@@ -121,6 +124,7 @@
     assertEquals(-1, cacheControl.minFreshSeconds());
     assertFalse(cacheControl.onlyIfCached());
     assertFalse(cacheControl.noTransform());
+    assertFalse(cacheControl.immutable());
     assertEquals(header, cacheControl.toString());
   }
 
diff --git a/okhttp-tests/src/test/java/okhttp3/CacheTest.java b/okhttp-tests/src/test/java/okhttp3/CacheTest.java
index 97a6c4a08b..09b480c647 100644
--- a/okhttp-tests/src/test/java/okhttp3/CacheTest.java
+++ b/okhttp-tests/src/test/java/okhttp3/CacheTest.java
@@ -19,15 +19,12 @@
 import java.io.File;
 import java.io.IOException;
 import java.net.CookieManager;
-import java.net.HttpCookie;
 import java.net.HttpURLConnection;
 import java.net.ResponseCache;
 import java.security.Principal;
 import java.security.cert.Certificate;
 import java.text.DateFormat;
 import java.text.SimpleDateFormat;
-import java.util.ArrayList;
-import java.util.Arrays;
 import java.util.Date;
 import java.util.Iterator;
 import java.util.List;
@@ -748,8 +745,8 @@ private void testClientPrematureDisconnect(TransferKind transferKind) throws IOE
   }
 
   private void testRequestMethod(String requestMethod, boolean expectCached) throws Exception {
-    // 1. seed the cache (potentially)
-    // 2. expect a cache hit or miss
+    // 1. Seed the cache (potentially).
+    // 2. Expect a cache hit or miss.
     server.enqueue(new MockResponse()
         .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS))
         .addHeader("X-Response-ID: 1"));
@@ -794,9 +791,9 @@ private RequestBody requestBodyOrNull(String requestMethod) {
   }
 
   private void testMethodInvalidates(String requestMethod) throws Exception {
-    // 1. seed the cache
-    // 2. invalidate it
-    // 3. expect a cache miss
+    // 1. Seed the cache.
+    // 2. Invalidate it.
+    // 3. Expect a cache miss.
     server.enqueue(new MockResponse()
         .setBody("A")
         .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS)));
@@ -820,9 +817,9 @@ private void testMethodInvalidates(String requestMethod) throws Exception {
   }
 
   @Test public void postInvalidatesCacheWithUncacheableResponse() throws Exception {
-    // 1. seed the cache
-    // 2. invalidate it with uncacheable response
-    // 3. expect a cache miss
+    // 1. Seed the cache.
+    // 2. Invalidate it with an uncacheable response.
+    // 3. Expect a cache miss.
     server.enqueue(new MockResponse()
         .setBody("A")
         .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS)));
@@ -846,6 +843,33 @@ private void testMethodInvalidates(String requestMethod) throws Exception {
     assertEquals("C", get(url).body().string());
   }
 
+  @Test public void putInvalidatesWithNoContentResponse() throws Exception {
+    // 1. Seed the cache.
+    // 2. Invalidate it.
+    // 3. Expect a cache miss.
+    server.enqueue(new MockResponse()
+        .setBody("A")
+        .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS)));
+    server.enqueue(new MockResponse()
+        .clearHeaders()
+        .setResponseCode(HttpURLConnection.HTTP_NO_CONTENT));
+    server.enqueue(new MockResponse()
+        .setBody("C"));
+
+    HttpUrl url = server.url("/");
+
+    assertEquals("A", get(url).body().string());
+
+    Request request = new Request.Builder()
+        .url(url)
+        .put(RequestBody.create(MediaType.parse("text/plain"), "foo"))
+        .build();
+    Response invalidate = client.newCall(request).execute();
+    assertEquals("", invalidate.body().string());
+
+    assertEquals("C", get(url).body().string());
+  }
+
   @Test public void etag() throws Exception {
     RecordedRequest conditionalRequest = assertConditionallyCached(new MockResponse()
         .addHeader("ETag: v1"));
@@ -911,8 +935,8 @@ private void testMethodInvalidates(String requestMethod) throws Exception {
   }
 
   @Test public void partialRangeResponsesDoNotCorruptCache() throws Exception {
-    // 1. request a range
-    // 2. request a full document, expecting a cache miss
+    // 1. Request a range.
+    // 2. Request a full document, expecting a cache miss.
     server.enqueue(new MockResponse()
         .setBody("AA")
         .setResponseCode(HttpURLConnection.HTTP_PARTIAL)
@@ -1820,14 +1844,6 @@ private RecordedRequest assertClientSuppliedCondition(MockResponse seed, String
     assertEquals("299 test danger", response2.header("Warning"));
   }
 
-  public void assertCookies(HttpUrl url, String... expectedCookies) throws Exception {
-    List<String> actualCookies = new ArrayList<>();
-    for (HttpCookie cookie : cookieManager.getCookieStore().get(url.uri())) {
-      actualCookies.add(cookie.toString());
-    }
-    assertEquals(Arrays.asList(expectedCookies), actualCookies);
-  }
-
   @Test public void doNotCachePartialResponse() throws Exception {
     assertNotCached(new MockResponse()
         .setResponseCode(HttpURLConnection.HTTP_PARTIAL)
@@ -2464,6 +2480,33 @@ private RecordedRequest assertConditionallyCached(MockResponse response) throws
     return server.takeRequest(); // conditional get
   }
 
+  @Test public void immutableIsCached() throws Exception {
+    server.enqueue(new MockResponse()
+        .addHeader("Cache-Control", "immutable")
+        .setBody("A"));
+    server.enqueue(new MockResponse()
+        .setBody("B"));
+
+    HttpUrl url = server.url("/");
+    assertEquals("A", get(url).body().string());
+    assertEquals("A", get(url).body().string());
+  }
+
+  @Test public void immutableIsCachedAfterMultipleCalls() throws Exception {
+    server.enqueue(new MockResponse()
+        .setBody("A"));
+    server.enqueue(new MockResponse()
+        .addHeader("Cache-Control", "immutable")
+        .setBody("B"));
+    server.enqueue(new MockResponse()
+        .setBody("C"));
+
+    HttpUrl url = server.url("/");
+    assertEquals("A", get(url).body().string());
+    assertEquals("B", get(url).body().string());
+    assertEquals("B", get(url).body().string());
+  }
+
   private void assertFullyCached(MockResponse response) throws Exception {
     server.enqueue(response.setBody("A"));
     server.enqueue(response.setBody("B"));
diff --git a/okhttp-tests/src/test/java/okhttp3/CallTest.java b/okhttp-tests/src/test/java/okhttp3/CallTest.java
index b0e6c99d2c..380707622e 100644
--- a/okhttp-tests/src/test/java/okhttp3/CallTest.java
+++ b/okhttp-tests/src/test/java/okhttp3/CallTest.java
@@ -63,6 +63,7 @@
 import okhttp3.internal.Version;
 import okhttp3.internal.http.RecordingProxySelector;
 import okhttp3.internal.io.InMemoryFileSystem;
+import okhttp3.internal.tls.HeldCertificate;
 import okhttp3.internal.tls.SslClient;
 import okhttp3.mockwebserver.Dispatcher;
 import okhttp3.mockwebserver.MockResponse;
@@ -93,7 +94,7 @@
 import static org.junit.Assert.fail;
 
 public final class CallTest {
-  @Rule public final TestRule timeout = new Timeout(30_000);
+  @Rule public final TestRule timeout = new Timeout(30_000, TimeUnit.MILLISECONDS);
   @Rule public final MockWebServer server = new MockWebServer();
   @Rule public final MockWebServer server2 = new MockWebServer();
   @Rule public final InMemoryFileSystem fileSystem = new InMemoryFileSystem();
@@ -999,6 +1000,11 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
     executeSynchronously("/").assertBody("retry success");
   }
 
+  @Test public void recoverWhenRetryOnConnectionFailureIsTrue_HTTP2() throws Exception {
+    enableProtocol(Protocol.HTTP_2);
+    recoverWhenRetryOnConnectionFailureIsTrue();
+  }
+
   @Test public void noRecoverWhenRetryOnConnectionFailureIsFalse() throws Exception {
     server.enqueue(new MockResponse().setBody("seed connection pool"));
     server.enqueue(new MockResponse().setSocketPolicy(SocketPolicy.DISCONNECT_AFTER_REQUEST));
@@ -1012,7 +1018,28 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
     executeSynchronously("/").assertBody("seed connection pool");
 
     // If this succeeds, too many requests were made.
-    executeSynchronously("/").assertFailure(IOException.class);
+    executeSynchronously("/")
+        .assertFailure(IOException.class)
+        .assertFailureMatches("stream was reset: CANCEL",
+            "unexpected end of stream on Connection.*"
+                + server.getHostName() + ":" + server.getPort() + ".*");
+  }
+
+  @Test public void recoverWhenRetryOnConnectionFailureIsFalse_HTTP2() throws Exception {
+    enableProtocol(Protocol.HTTP_2);
+    noRecoverWhenRetryOnConnectionFailureIsFalse();
+  }
+
+  @Test public void tlsHandshakeFailure_noFallbackByDefault() throws Exception {
+    server.useHttps(sslClient.socketFactory, false);
+    server.enqueue(new MockResponse().setSocketPolicy(SocketPolicy.FAIL_HANDSHAKE));
+    server.enqueue(new MockResponse().setBody("response that will never be received"));
+    RecordedResponse response = executeSynchronously("/");
+    response.assertFailure(
+            SSLProtocolException.class, // RI response to the FAIL_HANDSHAKE
+            SSLHandshakeException.class // Android's response to the FAIL_HANDSHAKE
+    );
+    assertFalse(client.connectionSpecs().contains(ConnectionSpec.COMPATIBLE_TLS));
   }
 
   @Test public void recoverFromTlsHandshakeFailure() throws Exception {
@@ -1023,6 +1050,8 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
     client = client.newBuilder()
         .hostnameVerifier(new RecordingHostnameVerifier())
         .dns(new SingleInetAddressDns())
+        // opt-in to fallback to COMPATIBLE_TLS
+        .connectionSpecs(Arrays.asList(ConnectionSpec.MODERN_TLS, ConnectionSpec.COMPATIBLE_TLS))
         .sslSocketFactory(suppressTlsFallbackClientSocketFactory(), sslClient.trustManager)
         .build();
 
@@ -1045,6 +1074,8 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
         new RecordingSSLSocketFactory(sslClient.socketFactory);
     client = client.newBuilder()
         .sslSocketFactory(clientSocketFactory, sslClient.trustManager)
+        // opt-in to fallback to COMPATIBLE_TLS
+        .connectionSpecs(Arrays.asList(ConnectionSpec.MODERN_TLS, ConnectionSpec.COMPATIBLE_TLS))
         .hostnameVerifier(new RecordingHostnameVerifier())
         .dns(new SingleInetAddressDns())
         .build();
@@ -1070,6 +1101,7 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
 
     client = client.newBuilder()
         .hostnameVerifier(new RecordingHostnameVerifier())
+        .connectionSpecs(Arrays.asList(ConnectionSpec.MODERN_TLS, ConnectionSpec.COMPATIBLE_TLS))
         .sslSocketFactory(suppressTlsFallbackClientSocketFactory(), sslClient.trustManager)
         .build();
 
@@ -1229,6 +1261,11 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
     assertEquals(0, post2.getSequenceNumber());
   }
 
+  @Test public void postBodyRetransmittedOnFailureRecovery_HTTP2() throws Exception {
+    enableProtocol(Protocol.HTTP_2);
+    postBodyRetransmittedOnFailureRecovery();
+  }
+
   @Test public void cacheHit() throws Exception {
     server.enqueue(new MockResponse()
         .addHeader("ETag: v1")
@@ -1481,7 +1518,7 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
     // Attempt conditional cache validation and a DNS miss.
     client.connectionPool().evictAll();
     client = client.newBuilder()
-        .dns(new FakeDns().unknownHost())
+        .dns(new FakeDns())
         .build();
     executeSynchronously("/").assertFailure(UnknownHostException.class);
   }
@@ -2091,6 +2128,33 @@ private InetSocketAddress startNullServer() throws IOException {
     executeSynchronously("/").assertBody("abcabcabc");
   }
 
+  @Test public void rangeHeaderPreventsAutomaticGzip() throws Exception {
+    Buffer gzippedBody = gzip("abcabcabc");
+
+    // Enqueue a gzipped response. Our request isn't expecting it, but that's okay.
+    server.enqueue(new MockResponse()
+        .setResponseCode(HttpURLConnection.HTTP_PARTIAL)
+        .setBody(gzippedBody)
+        .addHeader("Content-Encoding: gzip")
+        .addHeader("Content-Range: bytes 0-" + (gzippedBody.size() - 1)));
+
+    // Make a range request.
+    Request request = new Request.Builder()
+        .url(server.url("/"))
+        .header("Range", "bytes=0-")
+        .build();
+    Call call = client.newCall(request);
+
+    // The response is not decompressed.
+    Response response = call.execute();
+    assertEquals("gzip", response.header("Content-Encoding"));
+    assertEquals(gzippedBody.snapshot(), response.body().source().readByteString());
+
+    // The request did not offer gzip support.
+    RecordedRequest recordedRequest = server.takeRequest();
+    assertNull(recordedRequest.getHeader("Accept-Encoding"));
+  }
+
   @Test public void asyncResponseCanBeConsumedLater() throws Exception {
     server.enqueue(new MockResponse().setBody("abc"));
     server.enqueue(new MockResponse().setBody("def"));
@@ -2154,7 +2218,8 @@ private InetSocketAddress startNullServer() throws IOException {
   }
 
   @Test public void expect100ContinueNonEmptyRequestBody() throws Exception {
-    server.enqueue(new MockResponse());
+    server.enqueue(new MockResponse()
+        .setSocketPolicy(SocketPolicy.EXPECT_CONTINUE));
 
     Request request = new Request.Builder()
         .url(server.url("/"))
@@ -2183,6 +2248,124 @@ private InetSocketAddress startNullServer() throws IOException {
         .assertSuccessful();
   }
 
+  @Test public void expect100ContinueEmptyRequestBody_HTTP2() throws Exception {
+    enableProtocol(Protocol.HTTP_2);
+    expect100ContinueEmptyRequestBody();
+  }
+
+  @Test public void expect100ContinueTimesOutWithoutContinue() throws Exception {
+    server.enqueue(new MockResponse()
+        .setSocketPolicy(SocketPolicy.NO_RESPONSE));
+
+    client = client.newBuilder()
+        .readTimeout(500, TimeUnit.MILLISECONDS)
+        .build();
+
+    Request request = new Request.Builder()
+        .url(server.url("/"))
+        .header("Expect", "100-continue")
+        .post(RequestBody.create(MediaType.parse("text/plain"), "abc"))
+        .build();
+
+    Call call = client.newCall(request);
+    try {
+      call.execute();
+      fail();
+    } catch (SocketTimeoutException expected) {
+    }
+
+    RecordedRequest recordedRequest = server.takeRequest();
+    assertEquals("", recordedRequest.getBody().readUtf8());
+  }
+
+  @Test public void expect100ContinueTimesOutWithoutContinue_HTTP2() throws Exception {
+    enableProtocol(Protocol.HTTP_2);
+    expect100ContinueTimesOutWithoutContinue();
+  }
+
+  @Test public void serverRespondsWithUnsolicited100Continue() throws Exception {
+    server.enqueue(new MockResponse()
+        .setStatus("HTTP/1.1 100 Continue"));
+
+    Request request = new Request.Builder()
+        .url(server.url("/"))
+        .post(RequestBody.create(MediaType.parse("text/plain"), "abc"))
+        .build();
+
+    Call call = client.newCall(request);
+    Response response = call.execute();
+    assertEquals(100, response.code());
+    assertEquals("Continue", response.message());
+    assertEquals("", response.body().string());
+
+    RecordedRequest recordedRequest = server.takeRequest();
+    assertEquals("abc", recordedRequest.getBody().readUtf8());
+  }
+
+  @Test public void serverRespondsWithUnsolicited100Continue_HTTP2() throws Exception {
+    enableProtocol(Protocol.HTTP_2);
+    serverRespondsWithUnsolicited100Continue();
+  }
+
+  @Test public void successfulExpectContinuePermitsConnectionReuse() throws Exception {
+    server.enqueue(new MockResponse()
+        .setSocketPolicy(SocketPolicy.EXPECT_CONTINUE));
+    server.enqueue(new MockResponse());
+
+    executeSynchronously(new Request.Builder()
+        .url(server.url("/"))
+        .header("Expect", "100-continue")
+        .post(RequestBody.create(MediaType.parse("text/plain"), "abc"))
+        .build());
+    executeSynchronously(new Request.Builder()
+        .url(server.url("/"))
+        .build());
+
+    assertEquals(0, server.takeRequest().getSequenceNumber());
+    assertEquals(1, server.takeRequest().getSequenceNumber());
+  }
+
+  @Test public void successfulExpectContinuePermitsConnectionReuseWithHttp2() throws Exception {
+    enableProtocol(Protocol.HTTP_2);
+    successfulExpectContinuePermitsConnectionReuse();
+  }
+
+  @Test public void unsuccessfulExpectContinuePreventsConnectionReuse() throws Exception {
+    server.enqueue(new MockResponse());
+    server.enqueue(new MockResponse());
+
+    executeSynchronously(new Request.Builder()
+        .url(server.url("/"))
+        .header("Expect", "100-continue")
+        .post(RequestBody.create(MediaType.parse("text/plain"), "abc"))
+        .build());
+    executeSynchronously(new Request.Builder()
+        .url(server.url("/"))
+        .build());
+
+    assertEquals(0, server.takeRequest().getSequenceNumber());
+    assertEquals(0, server.takeRequest().getSequenceNumber());
+  }
+
+  @Test public void unsuccessfulExpectContinuePermitsConnectionReuseWithHttp2() throws Exception {
+    enableProtocol(Protocol.HTTP_2);
+
+    server.enqueue(new MockResponse());
+    server.enqueue(new MockResponse());
+
+    executeSynchronously(new Request.Builder()
+        .url(server.url("/"))
+        .header("Expect", "100-continue")
+        .post(RequestBody.create(MediaType.parse("text/plain"), "abc"))
+        .build());
+    executeSynchronously(new Request.Builder()
+        .url(server.url("/"))
+        .build());
+
+    assertEquals(0, server.takeRequest().getSequenceNumber());
+    assertEquals(1, server.takeRequest().getSequenceNumber());
+  }
+
   /** We forbid non-ASCII characters in outgoing request headers, but accept UTF-8. */
   @Test public void responseHeaderParsingIsLenient() throws Exception {
     Headers headers = new Headers.Builder()
@@ -2200,9 +2383,9 @@ private InetSocketAddress startNullServer() throws IOException {
   }
 
   @Test public void customDns() throws Exception {
-    // Configure a DNS that returns our MockWebServer for every hostname.
+    // Configure a DNS that returns our local MockWebServer for android.com.
     FakeDns dns = new FakeDns();
-    dns.addresses(Dns.SYSTEM.lookup(server.url("/").host()));
+    dns.set("android.com", Dns.SYSTEM.lookup(server.url("/").host()));
     client = client.newBuilder()
         .dns(dns)
         .build();
@@ -2215,6 +2398,23 @@ private InetSocketAddress startNullServer() throws IOException {
 
     dns.assertRequests("android.com");
   }
+  @Test public void dnsReturnsZeroIpAddresses() throws Exception {
+    // Configure a DNS that returns our local MockWebServer for android.com.
+    FakeDns dns = new FakeDns();
+    List<InetAddress> ipAddresses = new ArrayList<>();
+    dns.set("android.com", ipAddresses);
+    client = client.newBuilder()
+        .dns(dns)
+        .build();
+
+    server.enqueue(new MockResponse());
+    Request request = new Request.Builder()
+        .url(server.url("/").newBuilder().host("android.com").build())
+        .build();
+    executeSynchronously(request).assertFailure(dns + " returned no addresses for android.com");
+
+    dns.assertRequests("android.com");
+  }
 
   /** We had a bug where failed HTTP/2 calls could break the entire connection. */
   @Test public void failingCallsDoNotInterfereWithConnection() throws Exception {
@@ -2448,7 +2648,7 @@ private InetSocketAddress startNullServer() throws IOException {
     assertEquals("password", get.getHeader("Proxy-Authorization"));
   }
 
-  @Test public void interceptorGetsFramedProtocol() throws Exception {
+  @Test public void interceptorGetsHttp2() throws Exception {
     enableProtocol(Protocol.HTTP_2);
 
     // Capture the protocol as it is observed by the interceptor.
@@ -2501,6 +2701,46 @@ private InetSocketAddress startNullServer() throws IOException {
         .assertFailure("Unexpected status line:  HTTP/1.1 200 OK");
   }
 
+  @Test public void requestHeaderNameWithSpaceForbidden() throws Exception {
+    try {
+      new Request.Builder().addHeader("a b", "c");
+      fail();
+    } catch (IllegalArgumentException expected) {
+      assertEquals("Unexpected char 0x20 at 1 in header name: a b", expected.getMessage());
+    }
+  }
+
+  @Test public void requestHeaderNameWithTabForbidden() throws Exception {
+    try {
+      new Request.Builder().addHeader("a\tb", "c");
+      fail();
+    } catch (IllegalArgumentException expected) {
+      assertEquals("Unexpected char 0x09 at 1 in header name: a\tb", expected.getMessage());
+    }
+  }
+
+  @Test public void responseHeaderNameWithSpacePermitted() throws Exception {
+    server.enqueue(new MockResponse()
+        .clearHeaders()
+        .addHeader("content-length: 0")
+        .addHeaderLenient("a b", "c"));
+
+    Call call = client.newCall(new Request.Builder().url(server.url("/")).build());
+    Response response = call.execute();
+    assertEquals("c", response.header("a b"));
+  }
+
+  @Test public void responseHeaderNameWithTabPermitted() throws Exception {
+    server.enqueue(new MockResponse()
+        .clearHeaders()
+        .addHeader("content-length: 0")
+        .addHeaderLenient("a\tb", "c"));
+
+    Call call = client.newCall(new Request.Builder().url(server.url("/")).build());
+    Response response = call.execute();
+    assertEquals("c", response.header("a\tb"));
+  }
+
   @Test public void connectFails() throws Exception {
     server.shutdown();
 
@@ -2657,7 +2897,7 @@ private RequestBody requestBody(final boolean chunked, final long size, final in
       awaitGarbageCollection();
 
       String message = logHandler.take();
-      assertTrue(message.contains("WARNING: A connection to " + server.url("/") + " was leaked."
+      assertTrue(message.contains("A connection to " + server.url("/") + " was leaked."
           + " Did you forget to close a response body?"));
       assertTrue(message.contains("okhttp3.RealCall.execute("));
       assertTrue(message.contains("okhttp3.CallTest.leakedResponseBodyLogsStackTrace("));
@@ -2700,7 +2940,7 @@ private RequestBody requestBody(final boolean chunked, final long size, final in
       awaitGarbageCollection();
 
       String message = logHandler.take();
-      assertTrue(message.contains("WARNING: A connection to " + server.url("/") + " was leaked."
+      assertTrue(message.contains("A connection to " + server.url("/") + " was leaked."
           + " Did you forget to close a response body?"));
       assertTrue(message.contains("okhttp3.RealCall.enqueue("));
       assertTrue(message.contains("okhttp3.CallTest.asyncLeakedResponseBodyLogsStackTrace("));
@@ -2709,6 +2949,43 @@ private RequestBody requestBody(final boolean chunked, final long size, final in
     }
   }
 
+  @Test public void httpsWithIpAddress() throws Exception {
+    String localIpAddress = InetAddress.getLoopbackAddress().getHostAddress();
+
+    // Create a certificate with an IP address in the subject alt name.
+    HeldCertificate heldCertificate = new HeldCertificate.Builder()
+        .commonName("example.com")
+        .subjectAlternativeName(localIpAddress)
+        .build();
+    SslClient sslClient = new SslClient.Builder()
+        .certificateChain(heldCertificate.keyPair, heldCertificate.certificate)
+        .addTrustedCertificate(heldCertificate.certificate)
+        .build();
+
+    // Use that certificate on the server and trust it on the client.
+    server.useHttps(sslClient.socketFactory, false);
+    client = client.newBuilder()
+        .sslSocketFactory(sslClient.socketFactory, sslClient.trustManager)
+        .hostnameVerifier(new RecordingHostnameVerifier())
+        .protocols(Collections.singletonList(Protocol.HTTP_1_1))
+        .build();
+
+    // Make a request.
+    server.enqueue(new MockResponse());
+    HttpUrl url = server.url("/").newBuilder()
+        .host(localIpAddress)
+        .build();
+    Request request = new Request.Builder()
+        .url(url)
+        .build();
+    executeSynchronously(request)
+        .assertCode(200);
+
+    // Confirm that the IP address was used in the host header.
+    RecordedRequest recordedRequest = server.takeRequest();
+    assertEquals(localIpAddress + ":" + server.getPort(), recordedRequest.getHeader("Host"));
+  }
+
   private void makeFailingCall() {
     RequestBody requestBody = new RequestBody() {
       @Override public MediaType contentType() {
diff --git a/okhttp-tests/src/test/java/okhttp3/CertificateChainCleanerTest.java b/okhttp-tests/src/test/java/okhttp3/CertificateChainCleanerTest.java
index 64d741193d..3c5267bcc9 100644
--- a/okhttp-tests/src/test/java/okhttp3/CertificateChainCleanerTest.java
+++ b/okhttp-tests/src/test/java/okhttp3/CertificateChainCleanerTest.java
@@ -26,6 +26,7 @@
 import okhttp3.internal.platform.Platform;
 import okhttp3.internal.tls.CertificateChainCleaner;
 import okhttp3.internal.tls.HeldCertificate;
+import okhttp3.internal.tls.SslClient;
 import org.junit.Test;
 
 import static org.junit.Assert.assertEquals;
@@ -45,9 +46,8 @@
   }
 
   @Test public void equalsFromTrustManager() throws Exception {
-    Platform platform = Platform.get();
-    X509TrustManager x509TrustManager = platform.trustManager(
-        (SSLSocketFactory) SSLSocketFactory.getDefault());
+    SslClient client = new SslClient.Builder().build();
+    X509TrustManager x509TrustManager = client.trustManager;
     assertEquals(
         CertificateChainCleaner.get(x509TrustManager),
         CertificateChainCleaner.get(x509TrustManager));
diff --git a/okhttp-tests/src/test/java/okhttp3/CertificatePinnerTest.java b/okhttp-tests/src/test/java/okhttp3/CertificatePinnerTest.java
index 26207c5980..0745982fb2 100644
--- a/okhttp-tests/src/test/java/okhttp3/CertificatePinnerTest.java
+++ b/okhttp-tests/src/test/java/okhttp3/CertificatePinnerTest.java
@@ -275,4 +275,32 @@
     List<Pin> expectedPin = Arrays.asList(new Pin("σkhttp.com", certA1Sha256Pin));
     assertEquals(expectedPin, certificatePinner.findMatchingPins("xn--khttp-fde.com"));
   }
+
+  /** https://github.com/square/okhttp/issues/3324 */
+  @Test public void checkSubstringMatch() throws Exception {
+    CertificatePinner certificatePinner = new CertificatePinner.Builder()
+        .add("*.example.com", certA1Sha256Pin)
+        .build();
+
+    assertEquals(Collections.emptyList(),
+        certificatePinner.findMatchingPins("a.example.com.notexample.com"));
+    assertEquals(Collections.emptyList(),
+        certificatePinner.findMatchingPins("example.com.notexample.com"));
+    assertEquals(Collections.emptyList(),
+        certificatePinner.findMatchingPins("notexample.com"));
+    assertEquals(Collections.emptyList(),
+        certificatePinner.findMatchingPins("example.com"));
+    assertEquals(Collections.emptyList(),
+        certificatePinner.findMatchingPins("a.b.example.com"));
+    assertEquals(Collections.emptyList(),
+        certificatePinner.findMatchingPins("ple.com"));
+    assertEquals(Collections.emptyList(),
+        certificatePinner.findMatchingPins("com"));
+
+    Pin expectedPin = new Pin("*.example.com", certA1Sha256Pin);
+    assertEquals(Collections.singletonList(expectedPin),
+        certificatePinner.findMatchingPins("a.example.com"));
+    assertEquals(Collections.singletonList(expectedPin),
+        certificatePinner.findMatchingPins("example.example.com"));
+  }
 }
diff --git a/okhttp-tests/src/test/java/okhttp3/CipherSuiteTest.java b/okhttp-tests/src/test/java/okhttp3/CipherSuiteTest.java
index 683ef9be25..63b3023253 100644
--- a/okhttp-tests/src/test/java/okhttp3/CipherSuiteTest.java
+++ b/okhttp-tests/src/test/java/okhttp3/CipherSuiteTest.java
@@ -21,6 +21,7 @@
 import static okhttp3.CipherSuite.TLS_RSA_EXPORT_WITH_RC4_40_MD5;
 import static okhttp3.CipherSuite.TLS_RSA_WITH_AES_128_CBC_SHA256;
 import static okhttp3.CipherSuite.forJavaName;
+import static org.junit.Assert.assertArrayEquals;
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertNotEquals;
 import static org.junit.Assert.assertSame;
@@ -89,24 +90,131 @@
   }
 
   /**
-   * Legacy ciphers (whose javaName starts with "SSL_") are now considered different from the
-   * corresponding "TLS_" ciphers. In OkHttp 3.3.1, only 19 of those would have been valid; those 19
-   * would have been considered equal to the corresponding "TLS_" ciphers.
+   * On the Oracle JVM some older cipher suites have the "SSL_" prefix and others have the "TLS_"
+   * prefix. On the IBM JVM all cipher suites have the "SSL_" prefix.
+   *
+   * <p>Prior to OkHttp 3.3.1 we accepted either form and consider them equivalent. And since OkHttp
+   * 3.7.0 this is also true. But OkHttp 3.3.1 through 3.6.0 treated these as different.
    */
   @Test public void forJavaName_fromLegacyEnumName() {
     // These would have been considered equal in OkHttp 3.3.1, but now aren't.
-    assertNotEquals(
+    assertEquals(
         forJavaName("TLS_RSA_EXPORT_WITH_RC4_40_MD5"),
         forJavaName("SSL_RSA_EXPORT_WITH_RC4_40_MD5"));
-
-    // The SSL_ one of these would have been invalid in OkHttp 3.3.1; it now is valid and not equal.
-    assertNotEquals(
+    assertEquals(
         forJavaName("TLS_DH_RSA_EXPORT_WITH_DES40_CBC_SHA"),
         forJavaName("SSL_DH_RSA_EXPORT_WITH_DES40_CBC_SHA"));
-
-    // These would have not been valid in OkHttp 3.3.1, and now aren't equal.
-    assertNotEquals(
+    assertEquals(
         forJavaName("TLS_FAKE_NEW_CIPHER"),
         forJavaName("SSL_FAKE_NEW_CIPHER"));
   }
+
+  @Test public void applyIntersectionRetainsSslPrefixes() throws Exception {
+    FakeSslSocket socket = new FakeSslSocket();
+    socket.setEnabledProtocols(new String[] { "TLSv1" });
+    socket.setSupportedCipherSuites(new String[] { "SSL_A", "SSL_B", "SSL_C", "SSL_D", "SSL_E" });
+    socket.setEnabledCipherSuites(new String[] { "SSL_A", "SSL_B", "SSL_C" });
+
+    ConnectionSpec connectionSpec = new ConnectionSpec.Builder(true)
+        .tlsVersions(TlsVersion.TLS_1_0)
+        .cipherSuites("TLS_A", "TLS_C", "TLS_E")
+        .build();
+    connectionSpec.apply(socket, false);
+
+    assertArrayEquals(new String[] { "SSL_A", "SSL_C" }, socket.enabledCipherSuites);
+  }
+
+  @Test public void applyIntersectionRetainsTlsPrefixes() throws Exception {
+    FakeSslSocket socket = new FakeSslSocket();
+    socket.setEnabledProtocols(new String[] { "TLSv1" });
+    socket.setSupportedCipherSuites(new String[] { "TLS_A", "TLS_B", "TLS_C", "TLS_D", "TLS_E" });
+    socket.setEnabledCipherSuites(new String[] { "TLS_A", "TLS_B", "TLS_C" });
+
+    ConnectionSpec connectionSpec = new ConnectionSpec.Builder(true)
+        .tlsVersions(TlsVersion.TLS_1_0)
+        .cipherSuites("SSL_A", "SSL_C", "SSL_E")
+        .build();
+    connectionSpec.apply(socket, false);
+
+    assertArrayEquals(new String[] { "TLS_A", "TLS_C" }, socket.enabledCipherSuites);
+  }
+
+  @Test public void applyIntersectionAddsSslScsvForFallback() throws Exception {
+    FakeSslSocket socket = new FakeSslSocket();
+    socket.setEnabledProtocols(new String[] { "TLSv1" });
+    socket.setSupportedCipherSuites(new String[] { "SSL_A", "SSL_FALLBACK_SCSV" });
+    socket.setEnabledCipherSuites(new String[] { "SSL_A" });
+
+    ConnectionSpec connectionSpec = new ConnectionSpec.Builder(true)
+        .tlsVersions(TlsVersion.TLS_1_0)
+        .cipherSuites("SSL_A")
+        .build();
+    connectionSpec.apply(socket, true);
+
+    assertArrayEquals(new String[] { "SSL_A", "SSL_FALLBACK_SCSV" }, socket.enabledCipherSuites);
+  }
+
+  @Test public void applyIntersectionAddsTlsScsvForFallback() throws Exception {
+    FakeSslSocket socket = new FakeSslSocket();
+    socket.setEnabledProtocols(new String[] { "TLSv1" });
+    socket.setSupportedCipherSuites(new String[] { "TLS_A", "TLS_FALLBACK_SCSV" });
+    socket.setEnabledCipherSuites(new String[] { "TLS_A" });
+
+    ConnectionSpec connectionSpec = new ConnectionSpec.Builder(true)
+        .tlsVersions(TlsVersion.TLS_1_0)
+        .cipherSuites("TLS_A")
+        .build();
+    connectionSpec.apply(socket, true);
+
+    assertArrayEquals(new String[] { "TLS_A", "TLS_FALLBACK_SCSV" }, socket.enabledCipherSuites);
+  }
+
+  @Test public void applyIntersectionToProtocolVersion() throws Exception {
+    FakeSslSocket socket = new FakeSslSocket();
+    socket.setEnabledProtocols(new String[] { "TLSv1", "TLSv1.1", "TLSv1.2" });
+    socket.setSupportedCipherSuites(new String[] { "TLS_A" });
+    socket.setEnabledCipherSuites(new String[] { "TLS_A" });
+
+    ConnectionSpec connectionSpec = new ConnectionSpec.Builder(true)
+        .tlsVersions(TlsVersion.TLS_1_1, TlsVersion.TLS_1_2, TlsVersion.TLS_1_3)
+        .cipherSuites("TLS_A")
+        .build();
+    connectionSpec.apply(socket, false);
+
+    assertArrayEquals(new String[] { "TLSv1.1", "TLSv1.2" }, socket.enabledProtocols);
+  }
+
+  static final class FakeSslSocket extends DelegatingSSLSocket {
+    private String[] enabledProtocols;
+    private String[] supportedCipherSuites;
+    private String[] enabledCipherSuites;
+
+    FakeSslSocket() {
+      super(null);
+    }
+
+    @Override public String[] getEnabledProtocols() {
+      return enabledProtocols;
+    }
+
+    @Override public void setEnabledProtocols(String[] enabledProtocols) {
+      this.enabledProtocols = enabledProtocols;
+    }
+
+    @Override public String[] getSupportedCipherSuites() {
+      return supportedCipherSuites;
+    }
+
+    public void setSupportedCipherSuites(String[] supportedCipherSuites) {
+      this.supportedCipherSuites = supportedCipherSuites;
+    }
+
+    @Override public String[] getEnabledCipherSuites() {
+      return enabledCipherSuites;
+    }
+
+    @Override public void setEnabledCipherSuites(String[] enabledCipherSuites) {
+      this.enabledCipherSuites = enabledCipherSuites;
+    }
+  }
 }
diff --git a/okhttp-tests/src/test/java/okhttp3/ConnectionCoalescingTest.java b/okhttp-tests/src/test/java/okhttp3/ConnectionCoalescingTest.java
new file mode 100644
index 0000000000..5e3b25afdf
--- /dev/null
+++ b/okhttp-tests/src/test/java/okhttp3/ConnectionCoalescingTest.java
@@ -0,0 +1,320 @@
+/*
+ * Copyright (C) 2017 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3;
+
+import java.io.IOException;
+import java.net.InetAddress;
+import java.util.Arrays;
+import java.util.Collections;
+import java.util.List;
+import java.util.concurrent.atomic.AtomicReference;
+import javax.net.ssl.HostnameVerifier;
+import javax.net.ssl.SSLSession;
+import okhttp3.internal.tls.HeldCertificate;
+import okhttp3.internal.tls.SslClient;
+import okhttp3.mockwebserver.MockResponse;
+import okhttp3.mockwebserver.MockWebServer;
+import org.junit.Before;
+import org.junit.Ignore;
+import org.junit.Rule;
+import org.junit.Test;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.fail;
+
+public final class ConnectionCoalescingTest {
+  @Rule public final MockWebServer server = new MockWebServer();
+
+  private OkHttpClient client;
+
+  private HeldCertificate rootCa;
+  private HeldCertificate certificate;
+  private FakeDns dns = new FakeDns();
+  private HttpUrl url;
+  private List<InetAddress> serverIps;
+
+  @Before public void setUp() throws Exception {
+    rootCa = new HeldCertificate.Builder()
+        .serialNumber("1")
+        .ca(3)
+        .commonName("root")
+        .build();
+    certificate = new HeldCertificate.Builder()
+        .issuedBy(rootCa)
+        .serialNumber("2")
+        .commonName(server.getHostName())
+        .subjectAlternativeName(server.getHostName())
+        .subjectAlternativeName("san.com")
+        .subjectAlternativeName("*.wildcard.com")
+        .subjectAlternativeName("differentdns.com")
+        .build();
+
+    serverIps = Dns.SYSTEM.lookup(server.getHostName());
+
+    dns.set(server.getHostName(), serverIps);
+    dns.set("san.com", serverIps);
+    dns.set("nonsan.com", serverIps);
+    dns.set("www.wildcard.com", serverIps);
+    dns.set("differentdns.com", Collections.<InetAddress>emptyList());
+
+    SslClient sslClient = new SslClient.Builder()
+        .addTrustedCertificate(rootCa.certificate)
+        .build();
+
+    client = new OkHttpClient.Builder().dns(dns)
+        .sslSocketFactory(sslClient.socketFactory, sslClient.trustManager)
+        .build();
+
+    SslClient serverSslClient = new SslClient.Builder()
+        .certificateChain(certificate, rootCa)
+        .build();
+    server.useHttps(serverSslClient.socketFactory, false);
+
+    url = server.url("/robots.txt");
+  }
+
+  /**
+   * Test connecting to the main host then an alternative, although only subject alternative names
+   * are used if present no special consideration of common name.
+   */
+  @Test public void commonThenAlternative() throws Exception {
+    server.enqueue(new MockResponse().setResponseCode(200));
+    server.enqueue(new MockResponse().setResponseCode(200));
+
+    assert200Http2Response(execute(url), server.getHostName());
+
+    HttpUrl sanUrl = url.newBuilder().host("san.com").build();
+    assert200Http2Response(execute(sanUrl), "san.com");
+
+    assertEquals(1, client.connectionPool().connectionCount());
+  }
+
+  /**
+   * Test connecting to an alternative host then common name, although only subject alternative
+   * names are used if present no special consideration of common name.
+   */
+  @Test public void alternativeThenCommon() throws Exception {
+    server.enqueue(new MockResponse().setResponseCode(200));
+    server.enqueue(new MockResponse().setResponseCode(200));
+
+    HttpUrl sanUrl = url.newBuilder().host("san.com").build();
+    assert200Http2Response(execute(sanUrl), "san.com");
+
+    assert200Http2Response(execute(url), server.getHostName());
+
+    assertEquals(1, client.connectionPool().connectionCount());
+  }
+
+  /** Test a previously coalesced connection that's no longer healthy. */
+  @Test public void staleCoalescedConnection() throws Exception {
+    server.enqueue(new MockResponse().setResponseCode(200));
+    server.enqueue(new MockResponse().setResponseCode(200));
+
+    final AtomicReference<Connection> connection = new AtomicReference<>();
+    client = client.newBuilder()
+        .addNetworkInterceptor(new Interceptor() {
+          @Override public Response intercept(Chain chain) throws IOException {
+            connection.set(chain.connection());
+            return chain.proceed(chain.request());
+          }
+        })
+        .build();
+    dns.set("san.com", Dns.SYSTEM.lookup(server.getHostName()).subList(0, 1));
+
+    assert200Http2Response(execute(url), server.getHostName());
+
+    // Simulate a stale connection in the pool.
+    connection.get().socket().close();
+
+    HttpUrl sanUrl = url.newBuilder().host("san.com").build();
+    assert200Http2Response(execute(sanUrl), "san.com");
+
+    assertEquals(1, client.connectionPool().connectionCount());
+  }
+
+  /** If the existing connection matches a SAN but not a match for DNS then skip. */
+  @Test public void skipsWhenDnsDontMatch() throws Exception {
+    server.enqueue(new MockResponse().setResponseCode(200));
+
+    assert200Http2Response(execute(url), server.getHostName());
+
+    HttpUrl differentDnsUrl = url.newBuilder().host("differentdns.com").build();
+    try {
+      execute(differentDnsUrl);
+      fail("expected a failed attempt to connect");
+    } catch (IOException expected) {
+    }
+  }
+
+  /** Not in the certificate SAN. */
+  @Test public void skipsWhenNotSubjectAltName() throws Exception {
+    server.enqueue(new MockResponse().setResponseCode(200));
+
+    assert200Http2Response(execute(url), server.getHostName());
+
+    HttpUrl nonsanUrl = url.newBuilder().host("nonsan.com").build();
+
+    try {
+      execute(nonsanUrl);
+      fail("expected a failed attempt to connect");
+    } catch (IOException expected) {
+    }
+  }
+
+  /** Can still coalesce when pinning is used if pins match. */
+  @Test public void coalescesWhenCertificatePinsMatch() throws Exception {
+    CertificatePinner pinner = new CertificatePinner.Builder()
+        .add("san.com", "sha1/" + CertificatePinner.sha1(certificate.certificate).base64())
+        .build();
+    client = client.newBuilder().certificatePinner(pinner).build();
+
+    server.enqueue(new MockResponse().setResponseCode(200));
+    server.enqueue(new MockResponse().setResponseCode(200));
+
+    assert200Http2Response(execute(url), server.getHostName());
+
+    HttpUrl sanUrl = url.newBuilder().host("san.com").build();
+
+    assert200Http2Response(execute(sanUrl), "san.com");
+
+    assertEquals(1, client.connectionPool().connectionCount());
+  }
+
+  /** Certificate pinning used and not a match will avoid coalescing and try to connect. */
+  @Test public void skipsWhenCertificatePinningFails() throws Exception {
+    CertificatePinner pinner = new CertificatePinner.Builder()
+        .add("san.com", "sha1/afwiKY3RxoMmLkuRW1l7QsPZTJPwDS2pdDROQjXw8ig=")
+        .build();
+    client = client.newBuilder().certificatePinner(pinner).build();
+
+    server.enqueue(new MockResponse().setResponseCode(200));
+
+    assert200Http2Response(execute(url), server.getHostName());
+
+    HttpUrl sanUrl = url.newBuilder().host("san.com").build();
+
+    try {
+      execute(sanUrl);
+      fail("expected a failed attempt to connect");
+    } catch (IOException expected) {
+    }
+  }
+
+  /**
+   * Skips coalescing when hostname verifier is overridden since the intention of the hostname
+   * verification is a black box.
+   */
+  @Test public void skipsWhenHostnameVerifierUsed() throws Exception {
+    HostnameVerifier verifier = new HostnameVerifier() {
+      @Override public boolean verify(String s, SSLSession sslSession) {
+        return true;
+      }
+    };
+    client = client.newBuilder().hostnameVerifier(verifier).build();
+
+    server.enqueue(new MockResponse().setResponseCode(200));
+    server.enqueue(new MockResponse().setResponseCode(200));
+
+    assert200Http2Response(execute(url), server.getHostName());
+
+    HttpUrl sanUrl = url.newBuilder().host("san.com").build();
+
+    assert200Http2Response(execute(sanUrl), "san.com");
+
+    assertEquals(2, client.connectionPool().connectionCount());
+  }
+
+  /**
+   * Check we would use an existing connection to a later DNS result instead of connecting to the
+   * first DNS result for the first time.
+   */
+  @Test public void prefersExistingCompatible() throws Exception {
+    server.enqueue(new MockResponse().setResponseCode(200));
+    server.enqueue(new MockResponse().setResponseCode(200));
+
+    assert200Http2Response(execute(url), server.getHostName());
+
+    HttpUrl sanUrl = url.newBuilder().host("san.com").build();
+    dns.set("san.com",
+        Arrays.asList(InetAddress.getByAddress("san.com", new byte[] {0, 0, 0, 0}),
+            serverIps.get(0)));
+    assert200Http2Response(execute(sanUrl), "san.com");
+
+    assertEquals(1, client.connectionPool().connectionCount());
+  }
+
+  /** Check that wildcard SANs are supported. */
+  @Test public void commonThenWildcard() throws Exception {
+
+    server.enqueue(new MockResponse().setResponseCode(200));
+    server.enqueue(new MockResponse().setResponseCode(200));
+
+    assert200Http2Response(execute(url), server.getHostName());
+
+    HttpUrl sanUrl = url.newBuilder().host("www.wildcard.com").build();
+    assert200Http2Response(execute(sanUrl), "www.wildcard.com");
+
+    assertEquals(1, client.connectionPool().connectionCount());
+  }
+
+  /** Network interceptors check for changes to target. */
+  @Test public void worksWithNetworkInterceptors() throws Exception {
+    client = client.newBuilder().addNetworkInterceptor(new Interceptor() {
+      @Override public Response intercept(Chain chain) throws IOException {
+        return chain.proceed(chain.request());
+      }
+    }).build();
+
+    server.enqueue(new MockResponse().setResponseCode(200));
+    server.enqueue(new MockResponse().setResponseCode(200));
+
+    assert200Http2Response(execute(url), server.getHostName());
+
+    HttpUrl sanUrl = url.newBuilder().host("san.com").build();
+    assert200Http2Response(execute(sanUrl), "san.com");
+
+    assertEquals(1, client.connectionPool().connectionCount());
+  }
+
+  /** Run against public external sites, doesn't run by default. */
+  @Ignore
+  @Test public void coalescesConnectionsToRealSites() throws IOException {
+    client = new OkHttpClient();
+
+    assert200Http2Response(execute("https://graph.facebook.com/robots.txt"), "graph.facebook.com");
+    assert200Http2Response(execute("https://www.facebook.com/robots.txt"), "m.facebook.com");
+    assert200Http2Response(execute("https://fb.com/robots.txt"), "m.facebook.com");
+    assert200Http2Response(execute("https://messenger.com/robots.txt"), "messenger.com");
+    assert200Http2Response(execute("https://m.facebook.com/robots.txt"), "m.facebook.com");
+
+    assertEquals(3, client.connectionPool().connectionCount());
+  }
+
+  private Response execute(String url) throws IOException {
+    return execute(HttpUrl.parse(url));
+  }
+
+  private Response execute(HttpUrl url) throws IOException {
+    return client.newCall(new Request.Builder().url(url).build()).execute();
+  }
+
+  private void assert200Http2Response(Response response, String expectedHost) {
+    assertEquals(200, response.code());
+    assertEquals(expectedHost, response.request().url().host());
+    assertEquals(Protocol.HTTP_2, response.protocol());
+    response.body().close();
+  }
+}
diff --git a/okhttp-tests/src/test/java/okhttp3/ConnectionPoolTest.java b/okhttp-tests/src/test/java/okhttp3/ConnectionPoolTest.java
index 80346ba443..9ef1b146ca 100644
--- a/okhttp-tests/src/test/java/okhttp3/ConnectionPoolTest.java
+++ b/okhttp-tests/src/test/java/okhttp3/ConnectionPoolTest.java
@@ -54,27 +54,27 @@
     // Running at time 50, the pool returns that nothing can be evicted until time 150.
     assertEquals(100L, pool.cleanup(50L));
     assertEquals(1, pool.connectionCount());
-    assertFalse(c1.socket.isClosed());
+    assertFalse(c1.socket().isClosed());
 
     // Running at time 60, the pool returns that nothing can be evicted until time 150.
     assertEquals(90L, pool.cleanup(60L));
     assertEquals(1, pool.connectionCount());
-    assertFalse(c1.socket.isClosed());
+    assertFalse(c1.socket().isClosed());
 
     // Running at time 149, the pool returns that nothing can be evicted until time 150.
     assertEquals(1L, pool.cleanup(149L));
     assertEquals(1, pool.connectionCount());
-    assertFalse(c1.socket.isClosed());
+    assertFalse(c1.socket().isClosed());
 
     // Running at time 150, the pool evicts.
     assertEquals(0, pool.cleanup(150L));
     assertEquals(0, pool.connectionCount());
-    assertTrue(c1.socket.isClosed());
+    assertTrue(c1.socket().isClosed());
 
     // Running again, the pool reports that no further runs are necessary.
     assertEquals(-1, pool.cleanup(150L));
     assertEquals(0, pool.connectionCount());
-    assertTrue(c1.socket.isClosed());
+    assertTrue(c1.socket().isClosed());
   }
 
   @Test public void inUseConnectionsNotEvicted() throws Exception {
@@ -83,24 +83,25 @@
 
     RealConnection c1 = newConnection(pool, routeA1, 50L);
     synchronized (pool) {
-      StreamAllocation streamAllocation = new StreamAllocation(pool, addressA, null);
+      StreamAllocation streamAllocation = new StreamAllocation(pool, addressA, null,
+          EventListener.NONE, null);
       streamAllocation.acquire(c1);
     }
 
     // Running at time 50, the pool returns that nothing can be evicted until time 150.
     assertEquals(100L, pool.cleanup(50L));
     assertEquals(1, pool.connectionCount());
-    assertFalse(c1.socket.isClosed());
+    assertFalse(c1.socket().isClosed());
 
     // Running at time 60, the pool returns that nothing can be evicted until time 160.
     assertEquals(100L, pool.cleanup(60L));
     assertEquals(1, pool.connectionCount());
-    assertFalse(c1.socket.isClosed());
+    assertFalse(c1.socket().isClosed());
 
     // Running at time 160, the pool returns that nothing can be evicted until time 260.
     assertEquals(100L, pool.cleanup(160L));
     assertEquals(1, pool.connectionCount());
-    assertFalse(c1.socket.isClosed());
+    assertFalse(c1.socket().isClosed());
   }
 
   @Test public void cleanupPrioritizesEarliestEviction() throws Exception {
@@ -121,8 +122,8 @@
     // Running at time 150, the pool evicts c2.
     assertEquals(0L, pool.cleanup(150L));
     assertEquals(1, pool.connectionCount());
-    assertFalse(c1.socket.isClosed());
-    assertTrue(c2.socket.isClosed());
+    assertFalse(c1.socket().isClosed());
+    assertTrue(c2.socket().isClosed());
 
     // Running at time 150, the pool returns that nothing can be evicted until time 175.
     assertEquals(25L, pool.cleanup(150L));
@@ -131,8 +132,8 @@
     // Running at time 175, the pool evicts c1.
     assertEquals(0L, pool.cleanup(175L));
     assertEquals(0, pool.connectionCount());
-    assertTrue(c1.socket.isClosed());
-    assertTrue(c2.socket.isClosed());
+    assertTrue(c1.socket().isClosed());
+    assertTrue(c2.socket().isClosed());
   }
 
   @Test public void oldestConnectionsEvictedIfIdleLimitExceeded() throws Exception {
@@ -145,8 +146,8 @@
     // With 2 connections, there's no need to evict until the connections time out.
     assertEquals(50L, pool.cleanup(100L));
     assertEquals(2, pool.connectionCount());
-    assertFalse(c1.socket.isClosed());
-    assertFalse(c2.socket.isClosed());
+    assertFalse(c1.socket().isClosed());
+    assertFalse(c2.socket().isClosed());
 
     // Add a third connection
     RealConnection c3 = newConnection(pool, routeC1, 75L);
@@ -154,9 +155,9 @@
     // The third connection bounces the first.
     assertEquals(0L, pool.cleanup(100L));
     assertEquals(2, pool.connectionCount());
-    assertTrue(c1.socket.isClosed());
-    assertFalse(c2.socket.isClosed());
-    assertFalse(c3.socket.isClosed());
+    assertTrue(c1.socket().isClosed());
+    assertFalse(c2.socket().isClosed());
+    assertFalse(c3.socket().isClosed());
   }
 
   @Test public void leakedAllocation() throws Exception {
@@ -176,19 +177,18 @@
   /** Use a helper method so there's no hidden reference remaining on the stack. */
   private void allocateAndLeakAllocation(ConnectionPool pool, RealConnection connection) {
     synchronized (pool) {
-      StreamAllocation leak = new StreamAllocation(pool, connection.route().address(), null);
+      StreamAllocation leak = new StreamAllocation(pool, connection.route().address(), null,
+          EventListener.NONE, null);
       leak.acquire(connection);
     }
   }
 
   private RealConnection newConnection(ConnectionPool pool, Route route, long idleAtNanos) {
-    RealConnection connection = new RealConnection(route);
-    connection.idleAtNanos = idleAtNanos;
-    connection.socket = new Socket();
+    RealConnection result = RealConnection.testConnection(pool, route, new Socket(), idleAtNanos);
     synchronized (pool) {
-      pool.put(connection);
+      pool.put(result);
     }
-    return connection;
+    return result;
   }
 
   private Address newAddress(String name) {
diff --git a/okhttp-tests/src/test/java/okhttp3/CookieTest.java b/okhttp-tests/src/test/java/okhttp3/CookieTest.java
index bee549dc7d..da152db9c1 100644
--- a/okhttp-tests/src/test/java/okhttp3/CookieTest.java
+++ b/okhttp-tests/src/test/java/okhttp3/CookieTest.java
@@ -27,6 +27,7 @@
 
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertNotNull;
 import static org.junit.Assert.assertNull;
 import static org.junit.Assert.assertTrue;
 import static org.junit.Assert.fail;
@@ -50,6 +51,14 @@
     assertNull(Cookie.parse(url, "\r\t \n=b"));
   }
 
+  @Test public void spaceInName() throws Exception {
+    assertEquals("a b", Cookie.parse(url, "a b=cd").name());
+  }
+
+  @Test public void spaceInValue() throws Exception {
+    assertEquals("c d", Cookie.parse(url, "ab=c d").value());
+  }
+
   @Test public void trimLeadingAndTrailingWhitespaceFromName() throws Exception {
     assertEquals("a", Cookie.parse(url, " a=b").name());
     assertEquals("a", Cookie.parse(url, "a =b").name());
@@ -69,6 +78,23 @@
     assertEquals("b", Cookie.parse(url, "a=\r\t \nb\n\t \n").value());
   }
 
+  @Test public void invalidCharacters() throws Exception {
+    assertEquals(null, Cookie.parse(url, "a\u0000b=cd"));
+    assertEquals(null, Cookie.parse(url, "ab=c\u0000d"));
+    assertEquals(null, Cookie.parse(url, "a\u0001b=cd"));
+    assertEquals(null, Cookie.parse(url, "ab=c\u0001d"));
+    assertEquals(null, Cookie.parse(url, "a\u0009b=cd"));
+    assertEquals(null, Cookie.parse(url, "ab=c\u0009d"));
+    assertEquals(null, Cookie.parse(url, "a\u001fb=cd"));
+    assertEquals(null, Cookie.parse(url, "ab=c\u001fd"));
+    assertEquals(null, Cookie.parse(url, "a\u007fb=cd"));
+    assertEquals(null, Cookie.parse(url, "ab=c\u007fd"));
+    assertEquals(null, Cookie.parse(url, "a\u0080b=cd"));
+    assertEquals(null, Cookie.parse(url, "ab=c\u0080d"));
+    assertEquals(null, Cookie.parse(url, "a\u00ffb=cd"));
+    assertEquals(null, Cookie.parse(url, "ab=c\u00ffd"));
+  }
+
   @Test public void maxAge() throws Exception {
     assertEquals(51000L,
         Cookie.parse(50000L, url, "a=b; Max-Age=1").expiresAt());
@@ -241,6 +267,26 @@
     assertEquals("123.45.234.56", Cookie.parse(urlWithIp, "a=b; domain=123.45.234.56").domain());
   }
 
+  /**
+   * These public suffixes were selected by inspecting the publicsuffix.org list. It's possible they
+   * may change in the future. If this test begins to fail, please double check they are still
+   * present in the public suffix list.
+   */
+  @Test public void domainIsPublicSuffix() {
+    HttpUrl ascii = HttpUrl.parse("https://foo1.foo.bar.elb.amazonaws.com");
+    assertNotNull(Cookie.parse(ascii, "a=b; domain=foo.bar.elb.amazonaws.com"));
+    assertNull(Cookie.parse(ascii, "a=b; domain=bar.elb.amazonaws.com"));
+    assertNull(Cookie.parse(ascii, "a=b; domain=com"));
+
+    HttpUrl unicode = HttpUrl.parse("https://長.長.長崎.jp");
+    assertNotNull(Cookie.parse(unicode, "a=b; domain=長.長崎.jp"));
+    assertNull(Cookie.parse(unicode, "a=b; domain=長崎.jp"));
+
+    HttpUrl punycode = HttpUrl.parse("https://xn--ue5a.xn--ue5a.xn--8ltr62k.jp");
+    assertNotNull(Cookie.parse(punycode, "a=b; domain=xn--ue5a.xn--8ltr62k.jp"));
+    assertNull(Cookie.parse(punycode, "a=b; domain=xn--8ltr62k.jp"));
+  }
+
   @Test public void hostOnly() throws Exception {
     assertTrue(Cookie.parse(url, "a=b").hostOnly());
     assertFalse(Cookie.parse(url, "a=b; domain=example.com").hostOnly());
diff --git a/okhttp-tests/src/test/java/okhttp3/EventListenerTest.java b/okhttp-tests/src/test/java/okhttp3/EventListenerTest.java
new file mode 100644
index 0000000000..29b7fa4016
--- /dev/null
+++ b/okhttp-tests/src/test/java/okhttp3/EventListenerTest.java
@@ -0,0 +1,436 @@
+/*
+ * Copyright (C) 2017 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3;
+
+import java.io.IOException;
+import java.net.InetAddress;
+import java.net.UnknownHostException;
+import java.util.ArrayDeque;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.Collections;
+import java.util.Deque;
+import java.util.List;
+import okhttp3.internal.DoubleInetAddressDns;
+import okhttp3.internal.SingleInetAddressDns;
+import okhttp3.internal.tls.SslClient;
+import okhttp3.mockwebserver.MockResponse;
+import okhttp3.mockwebserver.MockWebServer;
+import okhttp3.mockwebserver.SocketPolicy;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertNotNull;
+import static org.junit.Assert.assertNull;
+import static org.junit.Assert.assertSame;
+import static org.junit.Assert.assertTrue;
+import static org.junit.Assert.fail;
+
+public final class EventListenerTest {
+  @Rule public final MockWebServer server = new MockWebServer();
+
+  private OkHttpClient client;
+  private final SingleInetAddressDns singleDns = new SingleInetAddressDns();
+  private final RecordingEventListener listener = new RecordingEventListener();
+  private final SslClient sslClient = SslClient.localhost();
+
+  @Before public void setUp() {
+    client = new OkHttpClient.Builder()
+        .dns(singleDns)
+        .eventListener(listener)
+        .build();
+  }
+
+  @Test public void successfulCallEventSequence() throws IOException {
+    server.enqueue(new MockResponse());
+
+    Call call = client.newCall(new Request.Builder()
+        .url(server.url("/"))
+        .build());
+    Response response = call.execute();
+    assertEquals(200, response.code());
+    response.body().close();
+
+    List<Class<?>> expectedEvents = Arrays.asList(DnsStart.class, DnsEnd.class);
+    assertEquals(expectedEvents, listener.recordedEventTypes());
+  }
+
+  @Test public void successfulHttpsCallEventSequence() throws IOException {
+    enableTls(false);
+    server.enqueue(new MockResponse());
+
+    Call call = client.newCall(new Request.Builder()
+        .url(server.url("/"))
+        .build());
+    Response response = call.execute();
+    assertEquals(200, response.code());
+    response.body().close();
+
+    List<Class<?>> expectedEvents = Arrays.asList(
+        DnsStart.class, DnsEnd.class,
+        SecureConnectStart.class, SecureConnectEnd.class);
+    assertEquals(expectedEvents, listener.recordedEventTypes());
+  }
+
+  @Test public void successfulDnsLookup() throws IOException {
+    server.enqueue(new MockResponse());
+
+    Call call = client.newCall(new Request.Builder()
+        .url(server.url("/"))
+        .build());
+    Response response = call.execute();
+    assertEquals(200, response.code());
+    response.body().close();
+
+    DnsStart dnsStart = listener.removeUpToEvent(DnsStart.class);
+    assertSame(call, dnsStart.call);
+    assertEquals("localhost", dnsStart.domainName);
+
+    DnsEnd dnsEnd = listener.removeUpToEvent(DnsEnd.class);
+    assertSame(call, dnsEnd.call);
+    assertEquals("localhost", dnsEnd.domainName);
+    assertEquals(1, dnsEnd.inetAddressList.size());
+    assertNull(dnsEnd.throwable);
+  }
+
+  @Test public void noDnsLookupOnPooledConnection() throws IOException {
+    server.enqueue(new MockResponse());
+    server.enqueue(new MockResponse());
+
+    // Seed the pool.
+    Call call1 = client.newCall(new Request.Builder()
+        .url(server.url("/"))
+        .build());
+    Response response1 = call1.execute();
+    assertEquals(200, response1.code());
+    response1.body().close();
+
+    listener.clearAllEvents();
+
+    Call call2 = client.newCall(new Request.Builder()
+        .url(server.url("/"))
+        .build());
+    Response response2 = call2.execute();
+    assertEquals(200, response2.code());
+    response2.body().close();
+
+    List<Class<?>> recordedEvents = listener.recordedEventTypes();
+    assertFalse(recordedEvents.contains(DnsStart.class));
+    assertFalse(recordedEvents.contains(DnsEnd.class));
+  }
+
+  @Test public void multipleDnsLookupsForSingleCall() throws IOException {
+    server.enqueue(new MockResponse()
+        .setResponseCode(301)
+        .setHeader("Location", "http://www.fakeurl:" + server.getPort()));
+    server.enqueue(new MockResponse());
+
+    FakeDns dns = new FakeDns();
+    dns.set("fakeurl", singleDns.lookup(server.getHostName()));
+    dns.set("www.fakeurl", singleDns.lookup(server.getHostName()));
+
+    client = client.newBuilder()
+        .dns(dns)
+        .build();
+
+    Call call = client.newCall(new Request.Builder()
+        .url("http://fakeurl:" + server.getPort())
+        .build());
+    Response response = call.execute();
+    assertEquals(200, response.code());
+    response.body().close();
+
+    listener.removeUpToEvent(DnsStart.class);
+    listener.removeUpToEvent(DnsEnd.class);
+    listener.removeUpToEvent(DnsStart.class);
+    listener.removeUpToEvent(DnsEnd.class);
+  }
+
+  @Test public void failedDnsLookup() {
+    client = client.newBuilder()
+        .dns(new FakeDns())
+        .build();
+    Call call = client.newCall(new Request.Builder()
+        .url("http://fakeurl/")
+        .build());
+    try {
+      call.execute();
+      fail();
+    } catch (IOException expected) {
+    }
+
+    listener.removeUpToEvent(DnsStart.class);
+
+    DnsEnd dnsEnd = listener.removeUpToEvent(DnsEnd.class);
+    assertSame(call, dnsEnd.call);
+    assertEquals("fakeurl", dnsEnd.domainName);
+    assertNull(dnsEnd.inetAddressList);
+    assertTrue(dnsEnd.throwable instanceof UnknownHostException);
+  }
+
+  @Test public void emptyDnsLookup() {
+    Dns emptyDns = new Dns() {
+      @Override public List<InetAddress> lookup(String hostname) throws UnknownHostException {
+        return Collections.emptyList();
+      }
+    };
+
+    client = client.newBuilder()
+        .dns(emptyDns)
+        .build();
+    Call call = client.newCall(new Request.Builder()
+        .url("http://fakeurl/")
+        .build());
+    try {
+      call.execute();
+      fail();
+    } catch (IOException expected) {
+    }
+
+    listener.removeUpToEvent(DnsStart.class);
+
+    DnsEnd dnsEnd = listener.removeUpToEvent(DnsEnd.class);
+    assertSame(call, dnsEnd.call);
+    assertEquals("fakeurl", dnsEnd.domainName);
+    assertNull(dnsEnd.inetAddressList);
+    assertTrue(dnsEnd.throwable instanceof UnknownHostException);
+  }
+
+  @Test public void successfulSecureConnect() throws IOException {
+    enableTls(false);
+    server.enqueue(new MockResponse());
+
+    Call call = client.newCall(new Request.Builder()
+        .url(server.url("/"))
+        .build());
+    Response response = call.execute();
+    assertEquals(200, response.code());
+    response.body().close();
+
+    SecureConnectStart secureStart = listener.removeUpToEvent(SecureConnectStart.class);
+    assertSame(call, secureStart.call);
+
+    SecureConnectEnd secureEnd = listener.removeUpToEvent(SecureConnectEnd.class);
+    assertSame(call, secureEnd.call);
+    assertNotNull(secureEnd.handshake);
+    assertNull(secureEnd.throwable);
+  }
+
+  @Test public void failedSecureConnect() {
+    enableTls(false);
+    server.enqueue(new MockResponse()
+        .setSocketPolicy(SocketPolicy.FAIL_HANDSHAKE));
+
+    Call call = client.newCall(new Request.Builder()
+        .url(server.url("/"))
+        .build());
+    try {
+      call.execute();
+      fail();
+    } catch (IOException expected) {
+    }
+
+    SecureConnectStart secureStart = listener.removeUpToEvent(SecureConnectStart.class);
+    assertSame(call, secureStart.call);
+
+    SecureConnectEnd secureEnd = listener.removeUpToEvent(SecureConnectEnd.class);
+    assertSame(call, secureEnd.call);
+    assertNull(secureEnd.handshake);
+    assertTrue(secureEnd.throwable instanceof IOException);
+  }
+
+  @Test public void secureConnectWithTunnel() throws IOException {
+    enableTls(true);
+    server.enqueue(new MockResponse()
+        .setSocketPolicy(SocketPolicy.UPGRADE_TO_SSL_AT_END));
+    server.enqueue(new MockResponse());
+
+    client = client.newBuilder()
+        .proxy(server.toProxyAddress())
+        .build();
+
+    Call call = client.newCall(new Request.Builder()
+        .url(server.url("/"))
+        .build());
+    Response response = call.execute();
+    assertEquals(200, response.code());
+    response.body().close();
+
+    SecureConnectStart secureStart = listener.removeUpToEvent(SecureConnectStart.class);
+    assertSame(call, secureStart.call);
+
+    SecureConnectEnd secureEnd = listener.removeUpToEvent(SecureConnectEnd.class);
+    assertSame(call, secureEnd.call);
+    assertNotNull(secureEnd.handshake);
+    assertNull(secureEnd.throwable);
+  }
+
+  @Test public void multipleSecureConnectsForSingleCall() throws IOException {
+    enableTls(false);
+    server.enqueue(new MockResponse()
+        .setSocketPolicy(SocketPolicy.FAIL_HANDSHAKE));
+    server.enqueue(new MockResponse());
+
+    client = client.newBuilder()
+        .dns(new DoubleInetAddressDns())
+        .build();
+
+    Call call = client.newCall(new Request.Builder()
+        .url(server.url("/"))
+        .build());
+    Response response = call.execute();
+    assertEquals(200, response.code());
+    response.body().close();
+
+    listener.removeUpToEvent(SecureConnectStart.class);
+    listener.removeUpToEvent(SecureConnectEnd.class);
+
+    listener.removeUpToEvent(SecureConnectStart.class);
+    listener.removeUpToEvent(SecureConnectEnd.class);
+  }
+
+  @Test public void noSecureConnectsOnPooledConnection() throws IOException {
+    enableTls(false);
+    server.enqueue(new MockResponse());
+    server.enqueue(new MockResponse());
+
+    client = client.newBuilder()
+        .dns(new DoubleInetAddressDns())
+        .build();
+
+    // Seed the pool.
+    Call call1 = client.newCall(new Request.Builder()
+        .url(server.url("/"))
+        .build());
+    Response response1 = call1.execute();
+    assertEquals(200, response1.code());
+    response1.body().close();
+
+    listener.clearAllEvents();
+
+    Call call2 = client.newCall(new Request.Builder()
+        .url(server.url("/"))
+        .build());
+    Response response2 = call2.execute();
+    assertEquals(200, response2.code());
+    response2.body().close();
+
+    List<Class<?>> recordedEvents = listener.recordedEventTypes();
+    assertFalse(recordedEvents.contains(SecureConnectStart.class));
+    assertFalse(recordedEvents.contains(SecureConnectEnd.class));
+  }
+
+  private void enableTls(boolean tunnelProxy) {
+    client = client.newBuilder()
+        .sslSocketFactory(sslClient.socketFactory, sslClient.trustManager)
+        .hostnameVerifier(new RecordingHostnameVerifier())
+        .build();
+    server.useHttps(sslClient.socketFactory, tunnelProxy);
+  }
+
+  static final class DnsStart {
+    final Call call;
+    final String domainName;
+
+    DnsStart(Call call, String domainName) {
+      this.call = call;
+      this.domainName = domainName;
+    }
+  }
+
+  static final class DnsEnd {
+    final Call call;
+    final String domainName;
+    final List<InetAddress> inetAddressList;
+    final Throwable throwable;
+
+    DnsEnd(Call call, String domainName, List<InetAddress> inetAddressList, Throwable throwable) {
+      this.call = call;
+      this.domainName = domainName;
+      this.inetAddressList = inetAddressList;
+      this.throwable = throwable;
+    }
+  }
+
+  static final class SecureConnectStart {
+    final Call call;
+
+    SecureConnectStart(Call call) {
+      this.call = call;
+    }
+  }
+
+  static final class SecureConnectEnd {
+    final Call call;
+    final Handshake handshake;
+    final Throwable throwable;
+
+    SecureConnectEnd(Call call, Handshake handshake, Throwable throwable) {
+      this.call = call;
+      this.handshake = handshake;
+      this.throwable = throwable;
+    }
+  }
+
+  static final class RecordingEventListener extends EventListener {
+    final Deque<Object> eventSequence = new ArrayDeque<>();
+
+    /**
+     * Removes recorded events up to (and including) an event is found whose class equals
+     * {@code eventClass} and returns it.
+     */
+    <T> T removeUpToEvent(Class<T> eventClass) {
+      Object event = eventSequence.poll();
+      while (event != null && !eventClass.isInstance(event)) {
+        event = eventSequence.poll();
+      }
+      if (event == null) throw new AssertionError();
+      return (T) event;
+    }
+
+    List<Class<?>> recordedEventTypes() {
+      List<Class<?>> eventTypes = new ArrayList<>();
+      for (Object event : eventSequence) {
+        eventTypes.add(event.getClass());
+      }
+      return eventTypes;
+    }
+
+    void clearAllEvents() {
+      eventSequence.clear();
+    }
+
+    @Override public void dnsStart(Call call, String domainName) {
+      eventSequence.offer(new DnsStart(call, domainName));
+    }
+
+    @Override public void dnsEnd(Call call, String domainName, List<InetAddress> inetAddressList,
+        Throwable throwable) {
+      eventSequence.offer(new DnsEnd(call, domainName, inetAddressList, throwable));
+    }
+
+    @Override public void secureConnectStart(Call call) {
+      eventSequence.offer(new SecureConnectStart(call));
+    }
+
+    @Override public void secureConnectEnd(Call call, Handshake handshake, Throwable throwable) {
+      eventSequence.offer(new SecureConnectEnd(call, handshake, throwable));
+    }
+  }
+}
diff --git a/okhttp-tests/src/test/java/okhttp3/HeadersTest.java b/okhttp-tests/src/test/java/okhttp3/HeadersTest.java
index 535dfcadd5..16ef3bef7d 100644
--- a/okhttp-tests/src/test/java/okhttp3/HeadersTest.java
+++ b/okhttp-tests/src/test/java/okhttp3/HeadersTest.java
@@ -56,6 +56,7 @@
         .url("http://square.com/")
         .header("Connection", "upgrade")
         .header("Upgrade", "websocket")
+        .header("Host", "square.com")
         .build();
     List<Header> expected = headerEntries(
         ":method", "GET",
diff --git a/okhttp-tests/src/test/java/okhttp3/HttpUrlTest.java b/okhttp-tests/src/test/java/okhttp3/HttpUrlTest.java
index 33f4952651..12aedc57a3 100644
--- a/okhttp-tests/src/test/java/okhttp3/HttpUrlTest.java
+++ b/okhttp-tests/src/test/java/okhttp3/HttpUrlTest.java
@@ -29,7 +29,6 @@
 
 import static java.util.Collections.singletonList;
 import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertNotNull;
 import static org.junit.Assert.assertNull;
 import static org.junit.Assert.fail;
 
@@ -129,9 +128,9 @@
     HttpUrl baseWithPasswordAndUsername = HttpUrl.parse("http://username:password@host/a/b#fragment");
     HttpUrl baseWithUsernameOnly = HttpUrl.parse("http://username@host/a/b#fragment");
     HttpUrl baseWithPasswordOnly = HttpUrl.parse("http://password@host/a/b#fragment");
-    assertEquals(HttpUrl.parse("http://host/..."), baseWithPasswordAndUsername.redact());
-    assertEquals(HttpUrl.parse("http://host/..."), baseWithUsernameOnly.redact());
-    assertEquals(HttpUrl.parse("http://host/..."), baseWithPasswordOnly.redact());
+    assertEquals("http://host/...", baseWithPasswordAndUsername.redact());
+    assertEquals("http://host/...", baseWithUsernameOnly.redact());
+    assertEquals("http://host/...", baseWithPasswordOnly.redact());
   }
 
   @Test public void resolveNoScheme() throws Exception {
@@ -161,6 +160,58 @@
     assertEquals(HttpUrl.parse("http://a/ht.tp//b/"), base.resolve("ht.tp//b/"));
   }
 
+  /** https://tools.ietf.org/html/rfc3986#section-5.4.1 */
+  @Test public void rfc3886NormalExamples() {
+    HttpUrl url = HttpUrl.parse("http://a/b/c/d;p?q");
+    assertEquals(null, url.resolve("g:h")); // No 'g:' scheme in HttpUrl.
+    assertEquals(HttpUrl.parse("http://a/b/c/g"), url.resolve("g"));
+    assertEquals(HttpUrl.parse("http://a/b/c/g"), url.resolve("./g"));
+    assertEquals(HttpUrl.parse("http://a/b/c/g/"), url.resolve("g/"));
+    assertEquals(HttpUrl.parse("http://a/g"), url.resolve("/g"));
+    assertEquals(HttpUrl.parse("http://g"), url.resolve("//g"));
+    assertEquals(HttpUrl.parse("http://a/b/c/d;p?y"), url.resolve("?y"));
+    assertEquals(HttpUrl.parse("http://a/b/c/g?y"), url.resolve("g?y"));
+    assertEquals(HttpUrl.parse("http://a/b/c/d;p?q#s"), url.resolve("#s"));
+    assertEquals(HttpUrl.parse("http://a/b/c/g#s"), url.resolve("g#s"));
+    assertEquals(HttpUrl.parse("http://a/b/c/g?y#s"), url.resolve("g?y#s"));
+    assertEquals(HttpUrl.parse("http://a/b/c/;x"), url.resolve(";x"));
+    assertEquals(HttpUrl.parse("http://a/b/c/g;x"), url.resolve("g;x"));
+    assertEquals(HttpUrl.parse("http://a/b/c/g;x?y#s"), url.resolve("g;x?y#s"));
+    assertEquals(HttpUrl.parse("http://a/b/c/d;p?q"), url.resolve(""));
+    assertEquals(HttpUrl.parse("http://a/b/c/"), url.resolve("."));
+    assertEquals(HttpUrl.parse("http://a/b/c/"), url.resolve("./"));
+    assertEquals(HttpUrl.parse("http://a/b/"), url.resolve(".."));
+    assertEquals(HttpUrl.parse("http://a/b/"), url.resolve("../"));
+    assertEquals(HttpUrl.parse("http://a/b/g"), url.resolve("../g"));
+    assertEquals(HttpUrl.parse("http://a/"), url.resolve("../.."));
+    assertEquals(HttpUrl.parse("http://a/"), url.resolve("../../"));
+    assertEquals(HttpUrl.parse("http://a/g"), url.resolve("../../g"));
+  }
+
+  /** https://tools.ietf.org/html/rfc3986#section-5.4.2 */
+  @Test public void rfc3886AbnormalExamples() {
+    HttpUrl url = HttpUrl.parse("http://a/b/c/d;p?q");
+    assertEquals(HttpUrl.parse("http://a/g"), url.resolve("../../../g"));
+    assertEquals(HttpUrl.parse("http://a/g"), url.resolve("../../../../g"));
+    assertEquals(HttpUrl.parse("http://a/g"), url.resolve("/./g"));
+    assertEquals(HttpUrl.parse("http://a/g"), url.resolve("/../g"));
+    assertEquals(HttpUrl.parse("http://a/b/c/g."), url.resolve("g."));
+    assertEquals(HttpUrl.parse("http://a/b/c/.g"), url.resolve(".g"));
+    assertEquals(HttpUrl.parse("http://a/b/c/g.."), url.resolve("g.."));
+    assertEquals(HttpUrl.parse("http://a/b/c/..g"), url.resolve("..g"));
+    assertEquals(HttpUrl.parse("http://a/b/g"), url.resolve("./../g"));
+    assertEquals(HttpUrl.parse("http://a/b/c/g/"), url.resolve("./g/."));
+    assertEquals(HttpUrl.parse("http://a/b/c/g/h"), url.resolve("g/./h"));
+    assertEquals(HttpUrl.parse("http://a/b/c/h"), url.resolve("g/../h"));
+    assertEquals(HttpUrl.parse("http://a/b/c/g;x=1/y"), url.resolve("g;x=1/./y"));
+    assertEquals(HttpUrl.parse("http://a/b/c/y"), url.resolve("g;x=1/../y"));
+    assertEquals(HttpUrl.parse("http://a/b/c/g?y/./x"), url.resolve("g?y/./x"));
+    assertEquals(HttpUrl.parse("http://a/b/c/g?y/../x"), url.resolve("g?y/../x"));
+    assertEquals(HttpUrl.parse("http://a/b/c/g#s/./x"), url.resolve("g#s/./x"));
+    assertEquals(HttpUrl.parse("http://a/b/c/g#s/../x"), url.resolve("g#s/../x"));
+    assertEquals(HttpUrl.parse("http://a/b/c/g"), url.resolve("http:g")); // "http:g" also okay.
+  }
+
   @Test public void parseAuthoritySlashCountDoesntMatter() throws Exception {
     assertEquals(HttpUrl.parse("http://host/path"), HttpUrl.parse("http:host/path"));
     assertEquals(HttpUrl.parse("http://host/path"), HttpUrl.parse("http:/host/path"));
@@ -375,11 +426,11 @@
     assertEquals(null, HttpUrl.parse("http://[1:]"));
     assertEquals(null, HttpUrl.parse("http://[1:::]"));
     assertEquals(null, HttpUrl.parse("http://[1:::1]"));
-    assertEquals(null, HttpUrl.parse("http://[00000:0000:0000:0000::0000:0000:0000:0001]"));
+    assertEquals(null, HttpUrl.parse("http://[0000:0000:0000:0000::0000:0000:0000:0001]"));
   }
 
   @Test public void hostIpv6AddressTooManyGroups() throws Exception {
-    assertEquals(null, HttpUrl.parse("http://[00000:0000:0000:0000:0000:0000:0000:0000:0001]"));
+    assertEquals(null, HttpUrl.parse("http://[0000:0000:0000:0000:0000:0000:0000:0000:0001]"));
   }
 
   @Test public void hostIpv6AddressTooMuchCompression() throws Exception {
@@ -440,9 +491,14 @@
     assertEquals("a::b:0:0:0", HttpUrl.parse("http://[a:0:0:0:b:0:0:0]/").host());
     assertEquals("::a:b:0:0:0", HttpUrl.parse("http://[0:0:0:a:b:0:0:0]/").host());
     assertEquals("::a:0:0:0:b", HttpUrl.parse("http://[0:0:0:a:0:0:0:b]/").host());
-    assertEquals("::a:b:c:d:e:f:1", HttpUrl.parse("http://[0:a:b:c:d:e:f:1]/").host());
-    assertEquals("a:b:c:d:e:f:1::", HttpUrl.parse("http://[a:b:c:d:e:f:1:0]/").host());
+    assertEquals("0:a:b:c:d:e:f:1", HttpUrl.parse("http://[0:a:b:c:d:e:f:1]/").host());
+    assertEquals("a:b:c:d:e:f:1:0", HttpUrl.parse("http://[a:b:c:d:e:f:1:0]/").host());
     assertEquals("ff01::101", HttpUrl.parse("http://[FF01:0:0:0:0:0:0:101]/").host());
+    assertEquals("2001:db8::1", HttpUrl.parse("http://[2001:db8::1]/").host());
+    assertEquals("2001:db8::2:1", HttpUrl.parse("http://[2001:db8:0:0:0:0:2:1]/").host());
+    assertEquals("2001:db8:0:1:1:1:1:1", HttpUrl.parse("http://[2001:db8:0:1:1:1:1:1]/").host());
+    assertEquals("2001:db8::1:0:0:1", HttpUrl.parse("http://[2001:db8:0:0:1:0:0:1]/").host());
+    assertEquals("2001:0:0:1::1", HttpUrl.parse("http://[2001:0:0:1:0:0:0:1]/").host());
     assertEquals("1::", HttpUrl.parse("http://[1:0:0:0:0:0:0:0]/").host());
     assertEquals("::1", HttpUrl.parse("http://[0:0:0:0:0:0:0:1]/").host());
     assertEquals("::", HttpUrl.parse("http://[0:0:0:0:0:0:0:0]/").host());
@@ -1436,4 +1492,19 @@
     assertEquals(null, url.fragment());
     assertEquals(null, url.encodedFragment());
   }
+
+  @Test public void topPrivateDomain() {
+    assertEquals("google.com", HttpUrl.parse("https://google.com").topPrivateDomain());
+    assertEquals("google.co.uk", HttpUrl.parse("https://adwords.google.co.uk").topPrivateDomain());
+    assertEquals("xn--ewv.xn--4pvxs.jp", HttpUrl.parse("https://栃.栃木.jp").topPrivateDomain());
+    assertEquals("xn--ewv.xn--4pvxs.jp",
+        HttpUrl.parse("https://xn--ewv.xn--4pvxs.jp").topPrivateDomain());
+
+    assertNull(HttpUrl.parse("https://co.uk").topPrivateDomain());
+    assertNull(HttpUrl.parse("https://square").topPrivateDomain());
+    assertNull(HttpUrl.parse("https://栃木.jp").topPrivateDomain());
+    assertNull(HttpUrl.parse("https://xn--4pvxs.jp").topPrivateDomain());
+    assertNull(HttpUrl.parse("https://localhost").topPrivateDomain());
+    assertNull(HttpUrl.parse("https://127.0.0.1").topPrivateDomain());
+  }
 }
diff --git a/okhttp-tests/src/test/java/okhttp3/InterceptorTest.java b/okhttp-tests/src/test/java/okhttp3/InterceptorTest.java
index dd72d07f74..7a4fc33630 100644
--- a/okhttp-tests/src/test/java/okhttp3/InterceptorTest.java
+++ b/okhttp-tests/src/test/java/okhttp3/InterceptorTest.java
@@ -655,6 +655,54 @@ private void interceptorThrowsRuntimeExceptionAsynchronous(boolean network) thro
     response.body().close();
   }
 
+  @Test public void applicationInterceptorResponseMustHaveBody() throws Exception {
+    server.enqueue(new MockResponse());
+
+    Interceptor interceptor = new Interceptor() {
+      @Override public Response intercept(Chain chain) throws IOException {
+        return chain.proceed(chain.request()).newBuilder().body(null).build();
+      }
+    };
+    client = client.newBuilder()
+        .addInterceptor(interceptor)
+        .build();
+
+    Request request = new Request.Builder()
+        .url(server.url("/"))
+        .build();
+    try {
+      client.newCall(request).execute();
+      fail();
+    } catch (IllegalStateException expected) {
+      assertEquals("interceptor " + interceptor + " returned a response with no body",
+          expected.getMessage());
+    }
+  }
+
+  @Test public void networkInterceptorResponseMustHaveBody() throws Exception {
+    server.enqueue(new MockResponse());
+
+    Interceptor interceptor = new Interceptor() {
+      @Override public Response intercept(Chain chain) throws IOException {
+        return chain.proceed(chain.request()).newBuilder().body(null).build();
+      }
+    };
+    client = client.newBuilder()
+        .addNetworkInterceptor(interceptor)
+        .build();
+
+    Request request = new Request.Builder()
+        .url(server.url("/"))
+        .build();
+    try {
+      client.newCall(request).execute();
+      fail();
+    } catch (IllegalStateException expected) {
+      assertEquals("interceptor " + interceptor + " returned a response with no body",
+          expected.getMessage());
+    }
+  }
+
   private RequestBody uppercase(final RequestBody original) {
     return new RequestBody() {
       @Override public MediaType contentType() {
diff --git a/okhttp-tests/src/test/java/okhttp3/MediaTypeTest.java b/okhttp-tests/src/test/java/okhttp3/MediaTypeTest.java
index 5e4a14f484..b2d3f396fa 100644
--- a/okhttp-tests/src/test/java/okhttp3/MediaTypeTest.java
+++ b/okhttp-tests/src/test/java/okhttp3/MediaTypeTest.java
@@ -17,15 +17,12 @@
 package okhttp3;
 
 import java.nio.charset.Charset;
-import java.nio.charset.IllegalCharsetNameException;
-import java.nio.charset.UnsupportedCharsetException;
 import okhttp3.internal.Util;
 import org.junit.Test;
 
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertNull;
 import static org.junit.Assert.assertTrue;
-import static org.junit.Assert.fail;
 
 /**
  * Test MediaType API and parsing.
@@ -123,29 +120,17 @@
   }
 
   @Test public void testMultipleCharsets() {
-    try {
-      MediaType.parse("text/plain; charset=utf-8; charset=utf-16");
-      fail();
-    } catch (IllegalArgumentException expected) {
-    }
+    assertNull(MediaType.parse("text/plain; charset=utf-8; charset=utf-16"));
   }
 
   @Test public void testIllegalCharsetName() {
     MediaType mediaType = MediaType.parse("text/plain; charset=\"!@#$%^&*()\"");
-    try {
-      mediaType.charset();
-      fail();
-    } catch (IllegalCharsetNameException expected) {
-    }
+    assertNull(mediaType.charset());
   }
 
   @Test public void testUnsupportedCharset() {
     MediaType mediaType = MediaType.parse("text/plain; charset=utf-wtf");
-    try {
-      mediaType.charset();
-      fail();
-    } catch (UnsupportedCharsetException expected) {
-    }
+    assertNull(mediaType.charset());
   }
 
   /**
@@ -159,20 +144,12 @@
 
   @Test public void testCharsetNameIsDoubleQuotedAndSingleQuoted() throws Exception {
     MediaType mediaType = MediaType.parse("text/plain;charset=\"'utf-8'\"");
-    try {
-      mediaType.charset();
-      fail();
-    } catch (IllegalCharsetNameException expected) {
-    }
+    assertNull(mediaType.charset());
   }
 
   @Test public void testCharsetNameIsDoubleQuotedSingleQuote() throws Exception {
     MediaType mediaType = MediaType.parse("text/plain;charset=\"'\"");
-    try {
-      mediaType.charset();
-      fail();
-    } catch (IllegalCharsetNameException expected) {
-    }
+    assertNull(mediaType.charset());
   }
 
   @Test public void testDefaultCharset() throws Exception {
@@ -189,7 +166,7 @@
     MediaType mediaType = MediaType.parse("text/plain;");
     assertEquals("text", mediaType.type());
     assertEquals("plain", mediaType.subtype());
-    assertEquals(null, mediaType.charset());
+    assertNull(mediaType.charset());
     assertEquals("text/plain;", mediaType.toString());
   }
 
diff --git a/okhttp-tests/src/test/java/okhttp3/OkHttpClientTest.java b/okhttp-tests/src/test/java/okhttp3/OkHttpClientTest.java
index 3cf5d900c3..5c13119e46 100644
--- a/okhttp-tests/src/test/java/okhttp3/OkHttpClientTest.java
+++ b/okhttp-tests/src/test/java/okhttp3/OkHttpClientTest.java
@@ -42,11 +42,12 @@
     ResponseCache.setDefault(DEFAULT_RESPONSE_CACHE);
   }
 
-  @Test public void timeoutDefaults() {
+  @Test public void durationDefaults() {
     OkHttpClient client = defaultClient();
     assertEquals(10_000, client.connectTimeoutMillis());
     assertEquals(10_000, client.readTimeoutMillis());
     assertEquals(10_000, client.writeTimeoutMillis());
+    assertEquals(0, client.pingIntervalMillis());
   }
 
   @Test public void timeoutValidRange() {
diff --git a/okhttp-tests/src/test/java/okhttp3/RecordedResponse.java b/okhttp-tests/src/test/java/okhttp3/RecordedResponse.java
index 3410775b6c..af750fadc3 100644
--- a/okhttp-tests/src/test/java/okhttp3/RecordedResponse.java
+++ b/okhttp-tests/src/test/java/okhttp3/RecordedResponse.java
@@ -143,8 +143,16 @@ public RecordedResponse cacheResponse() {
     return new RecordedResponse(cacheResponse.request(), cacheResponse, null, null, null);
   }
 
-  public RecordedResponse assertFailure(Class<?> exceptionClass) {
-    assertTrue(exceptionClass.isInstance(failure));
+  public RecordedResponse assertFailure(Class<?>... allowedExceptionTypes) {
+    boolean found = false;
+    for (Class expectedClass : allowedExceptionTypes) {
+      if (expectedClass.isInstance(failure)) {
+        found = true;
+        break;
+      }
+    }
+    assertTrue("Expected exception type among " + Arrays.toString(allowedExceptionTypes)
+            + ", got " + failure, found);
     return this;
   }
 
@@ -154,6 +162,14 @@ public RecordedResponse assertFailure(String... messages) {
     return this;
   }
 
+  public RecordedResponse assertFailureMatches(String... patterns) {
+    assertNotNull(failure);
+    for (String pattern : patterns) {
+      if (failure.getMessage().matches(pattern)) return this;
+    }
+    throw new AssertionError(failure.getMessage());
+  }
+
   public RecordedResponse assertSentRequestAtMillis(long minimum, long maximum) {
     assertDateInRange(minimum, response.sentRequestAtMillis(), maximum);
     return this;
diff --git a/okhttp-tests/src/test/java/okhttp3/RequestTest.java b/okhttp-tests/src/test/java/okhttp3/RequestTest.java
index bd6092b4a8..5c205d7031 100644
--- a/okhttp-tests/src/test/java/okhttp3/RequestTest.java
+++ b/okhttp-tests/src/test/java/okhttp3/RequestTest.java
@@ -156,8 +156,8 @@
 
   @Test public void headerAcceptsPermittedCharacters() throws Exception {
     Request.Builder builder = new Request.Builder();
-    builder.header("AZab09 ~", "AZab09 ~");
-    builder.addHeader("AZab09 ~", "AZab09 ~");
+    builder.header("AZab09~", "AZab09 ~");
+    builder.addHeader("AZab09~", "AZab09 ~");
   }
 
   @Test public void emptyNameForbidden() throws Exception {
diff --git a/okhttp-tests/src/test/java/okhttp3/ResponseTest.java b/okhttp-tests/src/test/java/okhttp3/ResponseTest.java
index 8977fdf441..5d77a02a26 100644
--- a/okhttp-tests/src/test/java/okhttp3/ResponseTest.java
+++ b/okhttp-tests/src/test/java/okhttp3/ResponseTest.java
@@ -95,6 +95,7 @@ private Response newResponse(ResponseBody responseBody) {
             .build())
         .protocol(Protocol.HTTP_1_1)
         .code(200)
+        .message("OK")
         .body(responseBody)
         .build();
   }
diff --git a/okhttp-tests/src/test/java/okhttp3/URLConnectionTest.java b/okhttp-tests/src/test/java/okhttp3/URLConnectionTest.java
index adbf091782..a566babadb 100644
--- a/okhttp-tests/src/test/java/okhttp3/URLConnectionTest.java
+++ b/okhttp-tests/src/test/java/okhttp3/URLConnectionTest.java
@@ -42,12 +42,14 @@
 import java.util.Arrays;
 import java.util.Collections;
 import java.util.EnumSet;
+import java.util.HashSet;
 import java.util.LinkedHashSet;
 import java.util.List;
 import java.util.Map;
 import java.util.Random;
 import java.util.Set;
 import java.util.concurrent.TimeUnit;
+import java.util.concurrent.atomic.AtomicReference;
 import java.util.zip.GZIPInputStream;
 import javax.net.ServerSocketFactory;
 import javax.net.SocketFactory;
@@ -55,6 +57,8 @@
 import javax.net.ssl.SSLContext;
 import javax.net.ssl.SSLException;
 import javax.net.ssl.SSLHandshakeException;
+import javax.net.ssl.SSLProtocolException;
+import javax.net.ssl.SSLSocket;
 import javax.net.ssl.SSLSocketFactory;
 import javax.net.ssl.TrustManager;
 import javax.net.ssl.TrustManagerFactory;
@@ -66,6 +70,7 @@
 import okhttp3.internal.SingleInetAddressDns;
 import okhttp3.internal.Util;
 import okhttp3.internal.Version;
+import okhttp3.internal.huc.OkHttpURLConnection;
 import okhttp3.internal.tls.SslClient;
 import okhttp3.mockwebserver.MockResponse;
 import okhttp3.mockwebserver.MockWebServer;
@@ -684,6 +689,7 @@ private void connectViaHttpsReusingConnections(boolean rebuildClient) throws Exc
 
     urlFactory.setClient(urlFactory.client().newBuilder()
         .hostnameVerifier(new RecordingHostnameVerifier())
+        .connectionSpecs(Arrays.asList(ConnectionSpec.MODERN_TLS, ConnectionSpec.COMPATIBLE_TLS))
         .sslSocketFactory(suppressTlsFallbackClientSocketFactory(), sslClient.trustManager)
         .build());
     connection = urlFactory.open(server.url("/foo").url());
@@ -705,6 +711,7 @@ private void connectViaHttpsReusingConnections(boolean rebuildClient) throws Exc
 
     urlFactory.setClient(urlFactory.client().newBuilder()
         .dns(new SingleInetAddressDns())
+        .connectionSpecs(Arrays.asList(ConnectionSpec.MODERN_TLS, ConnectionSpec.COMPATIBLE_TLS))
         .hostnameVerifier(new RecordingHostnameVerifier())
         .sslSocketFactory(suppressTlsFallbackClientSocketFactory(), sslClient.trustManager)
         .build());
@@ -1154,6 +1161,33 @@ private void initResponseCache() throws IOException {
     in.close();
   }
 
+  @Test public void disconnectDuringConnect_cookieJar() throws Exception {
+    final AtomicReference<HttpURLConnection> connectionHolder = new AtomicReference<>();
+    class DisconnectingCookieJar implements CookieJar {
+      @Override public void saveFromResponse(HttpUrl url, List<Cookie> cookies) { }
+      @Override
+      public List<Cookie> loadForRequest(HttpUrl url) {
+        connectionHolder.get().disconnect();
+        return Collections.emptyList();
+      }
+    }
+    OkHttpClient client = new okhttp3.OkHttpClient.Builder()
+            .cookieJar(new DisconnectingCookieJar())
+            .build();
+
+    URL url = server.url("path that should never be accessed").url();
+    HttpURLConnection connection = new OkHttpURLConnection(url, client);
+    connectionHolder.set(connection);
+    try {
+      connection.getInputStream();
+      fail("Connection should not be established");
+    } catch (IOException expected) {
+      assertEquals("Canceled", expected.getMessage());
+    } finally {
+      connection.disconnect();
+    }
+  }
+
   @Test public void disconnectBeforeConnect() throws IOException {
     server.enqueue(new MockResponse().setBody("A"));
 
@@ -3317,6 +3351,23 @@ private void zeroLengthPayload(String method)
     assertEquals(Long.toString(contentLength), request.getHeader("Content-Length"));
   }
 
+  @Test public void testNoSslFallback() throws Exception {
+    server.useHttps(sslClient.socketFactory, false /* tunnelProxy */);
+    server.enqueue(new MockResponse().setSocketPolicy(FAIL_HANDSHAKE));
+    server.enqueue(new MockResponse().setBody("Response that would have needed fallbacks"));
+
+    HttpsURLConnection connection = (HttpsURLConnection) server.url("/").url().openConnection();
+    connection.setSSLSocketFactory(sslClient.socketFactory);
+    try {
+      connection.getInputStream();
+      fail();
+    } catch (SSLProtocolException expected) {
+      // RI response to the FAIL_HANDSHAKE
+    } catch (SSLHandshakeException expected) {
+      // Android's response to the FAIL_HANDSHAKE
+    }
+  }
+
   /**
    * We had a bug where we attempted to gunzip responses that didn't have a body. This only came up
    * with 304s since that response code can include headers (like "Content-Encoding") without any
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/SocketRecorder.java b/okhttp-tests/src/test/java/okhttp3/internal/SocketRecorder.java
new file mode 100644
index 0000000000..ba3b84f91e
--- /dev/null
+++ b/okhttp-tests/src/test/java/okhttp3/internal/SocketRecorder.java
@@ -0,0 +1,206 @@
+/*
+ * Copyright (C) 2016 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.internal;
+
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.OutputStream;
+import java.lang.reflect.InvocationTargetException;
+import java.lang.reflect.Method;
+import java.net.Socket;
+import java.util.Deque;
+import java.util.concurrent.LinkedBlockingDeque;
+import javax.net.ssl.SSLSocket;
+import javax.net.ssl.SSLSocketFactory;
+import okhttp3.DelegatingSSLSocket;
+import okhttp3.DelegatingSSLSocketFactory;
+import okio.Buffer;
+import okio.ByteString;
+
+/** Records all bytes written and read from a socket and makes them available for inspection. */
+public final class SocketRecorder {
+  private final Deque<RecordedSocket> recordedSockets = new LinkedBlockingDeque<>();
+
+  /** Returns an SSLSocketFactory whose sockets will record all transmitted bytes. */
+  public SSLSocketFactory sslSocketFactory(SSLSocketFactory delegate) {
+    return new DelegatingSSLSocketFactory(delegate) {
+      @Override protected SSLSocket configureSocket(SSLSocket sslSocket) throws IOException {
+        RecordedSocket recordedSocket = new RecordedSocket();
+        recordedSockets.add(recordedSocket);
+        return new RecordingSSLSocket(sslSocket, recordedSocket);
+      }
+    };
+  }
+
+  public RecordedSocket takeSocket() {
+    return recordedSockets.remove();
+  }
+
+  /** A bidirectional transfer of unadulterated bytes over a socket. */
+  public static final class RecordedSocket {
+    private final Buffer bytesWritten = new Buffer();
+    private final Buffer bytesRead = new Buffer();
+
+    synchronized void byteWritten(int b) {
+      bytesWritten.writeByte(b);
+    }
+
+    synchronized void byteRead(int b) {
+      bytesRead.writeByte(b);
+    }
+
+    synchronized void bytesWritten(byte[] bytes, int offset, int length) {
+      bytesWritten.write(bytes, offset, length);
+    }
+
+    synchronized void bytesRead(byte[] bytes, int offset, int length) {
+      bytesRead.write(bytes, offset, length);
+    }
+
+    /** Returns all bytes that have been written to this socket. */
+    public synchronized ByteString bytesWritten() {
+      return bytesWritten.readByteString();
+    }
+
+    /** Returns all bytes that have been read from this socket. */
+    public synchronized ByteString bytesRead() {
+      return bytesRead.readByteString();
+    }
+  }
+
+  static final class RecordingInputStream extends InputStream {
+    private final Socket socket;
+    private final RecordedSocket recordedSocket;
+
+    RecordingInputStream(Socket socket, RecordedSocket recordedSocket) {
+      this.socket = socket;
+      this.recordedSocket = recordedSocket;
+    }
+
+    @Override public int read() throws IOException {
+      int b = socket.getInputStream().read();
+      if (b == -1) return -1;
+      recordedSocket.byteRead(b);
+      return b;
+    }
+
+    @Override public int read(byte[] b, int off, int len) throws IOException {
+      int read = socket.getInputStream().read(b, off, len);
+      if (read == -1) return -1;
+      recordedSocket.bytesRead(b, off, read);
+      return read;
+    }
+
+    @Override public void close() throws IOException {
+      socket.getInputStream().close();
+    }
+  }
+
+  static final class RecordingOutputStream extends OutputStream {
+    private final Socket socket;
+    private final RecordedSocket recordedSocket;
+
+    RecordingOutputStream(Socket socket, RecordedSocket recordedSocket) {
+      this.socket = socket;
+      this.recordedSocket = recordedSocket;
+    }
+
+    @Override public void write(int b) throws IOException {
+      socket.getOutputStream().write(b);
+      recordedSocket.byteWritten(b);
+    }
+
+    @Override public void write(byte[] b, int off, int len) throws IOException {
+      socket.getOutputStream().write(b, off, len);
+      recordedSocket.bytesWritten(b, off, len);
+    }
+
+    @Override public void close() throws IOException {
+      socket.getOutputStream().close();
+    }
+
+    @Override public void flush() throws IOException {
+      socket.getOutputStream().flush();
+    }
+  }
+
+  static final class RecordingSSLSocket extends DelegatingSSLSocket {
+    private final InputStream inputStream;
+    private final OutputStream outputStream;
+
+    RecordingSSLSocket(SSLSocket delegate, RecordedSocket recordedSocket) {
+      super(delegate);
+      inputStream = new RecordingInputStream(delegate, recordedSocket);
+      outputStream = new RecordingOutputStream(delegate, recordedSocket);
+    }
+
+    @Override public void startHandshake() throws IOException {
+      // Intercept the handshake to properly configure TLS extensions with Jetty ALPN. Jetty ALPN
+      // expects the real SSLSocket to be placed in the global map. Because we are wrapping the real
+      // SSLSocket, it confuses Jetty ALPN. This patches that up so things work as expected.
+      Class<?> alpn = null;
+      Class<?> provider = null;
+      try {
+        alpn = Class.forName("org.eclipse.jetty.alpn.ALPN");
+        provider = Class.forName("org.eclipse.jetty.alpn.ALPN$Provider");
+      } catch (ClassNotFoundException ignored) {
+      }
+
+      if (alpn == null || provider == null) {
+        // No Jetty, so nothing to worry about.
+        super.startHandshake();
+        return;
+      }
+
+      Object providerInstance = null;
+      Method putMethod = null;
+      try {
+        Method getMethod = alpn.getMethod("get", SSLSocket.class);
+        putMethod = alpn.getMethod("put", SSLSocket.class, provider);
+        providerInstance = getMethod.invoke(null, this);
+        if (providerInstance == null) {
+          // Jetty's on the classpath but TLS extensions weren't used.
+          super.startHandshake();
+          return;
+        }
+
+        // TLS extensions were used; replace with the real SSLSocket to make Jetty ALPN happy.
+        putMethod.invoke(null, delegate, providerInstance);
+        super.startHandshake();
+      } catch (NoSuchMethodException | IllegalAccessException | InvocationTargetException e) {
+        throw new AssertionError();
+      } finally {
+        // If we replaced the SSLSocket in the global map, we must put the original back for
+        // everything to work inside OkHttp.
+        if (providerInstance != null) {
+          try {
+            putMethod.invoke(null, this, providerInstance);
+          } catch (IllegalAccessException | InvocationTargetException e) {
+            throw new AssertionError();
+          }
+        }
+      }
+    }
+
+    @Override public InputStream getInputStream() throws IOException {
+      return inputStream;
+    }
+
+    @Override public OutputStream getOutputStream() throws IOException {
+      return outputStream;
+    }
+  }
+}
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/cache/DiskLruCacheTest.java b/okhttp-tests/src/test/java/okhttp3/internal/cache/DiskLruCacheTest.java
index d4ae88b84a..04ba57126b 100644
--- a/okhttp-tests/src/test/java/okhttp3/internal/cache/DiskLruCacheTest.java
+++ b/okhttp-tests/src/test/java/okhttp3/internal/cache/DiskLruCacheTest.java
@@ -33,6 +33,7 @@
 import okio.Source;
 import org.junit.After;
 import org.junit.Before;
+import org.junit.Ignore;
 import org.junit.Rule;
 import org.junit.Test;
 import org.junit.rules.TemporaryFolder;
@@ -93,6 +94,36 @@ private void createNewCacheWithSize(int maxSize) throws IOException {
     assertJournalEquals();
   }
 
+  @Test public void recoverFromInitializationFailure() throws IOException {
+    // Add an uncommitted entry. This will get detected on initialization, and the cache will
+    // attempt to delete the file. Do not explicitly close the cache here so the entry is left as
+    // incomplete.
+    DiskLruCache.Editor creator = cache.edit("k1");
+    BufferedSink sink = Okio.buffer(creator.newSink(0));
+    sink.writeUtf8("Hello");
+    sink.close();
+
+    // Simulate a severe filesystem failure on the first initialization.
+    fileSystem.setFaultyDelete(new File(cacheDir, "k1.0.tmp"), true);
+    fileSystem.setFaultyDelete(cacheDir, true);
+
+    cache = new DiskLruCache(fileSystem, cacheDir, appVersion, 2, Integer.MAX_VALUE, executor);
+    toClose.add(cache);
+
+    try {
+      cache.get("k1");
+      fail();
+    } catch (IOException expected) {
+    }
+
+    // Now let it operate normally.
+    fileSystem.setFaultyDelete(new File(cacheDir, "k1.0.tmp"), false);
+    fileSystem.setFaultyDelete(cacheDir, false);
+
+    DiskLruCache.Snapshot snapshot = cache.get("k1");
+    assertNull(snapshot);
+  }
+
   @Test public void validateKey() throws Exception {
     String key = null;
     try {
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/connection/RouteSelectorTest.java b/okhttp-tests/src/test/java/okhttp3/internal/connection/RouteSelectorTest.java
index 272186bffd..0f43e54da1 100644
--- a/okhttp-tests/src/test/java/okhttp3/internal/connection/RouteSelectorTest.java
+++ b/okhttp-tests/src/test/java/okhttp3/internal/connection/RouteSelectorTest.java
@@ -34,6 +34,7 @@
 import okhttp3.Address;
 import okhttp3.Authenticator;
 import okhttp3.ConnectionSpec;
+import okhttp3.EventListener;
 import okhttp3.FakeDns;
 import okhttp3.Protocol;
 import okhttp3.Route;
@@ -84,11 +85,12 @@
 
   @Test public void singleRoute() throws Exception {
     Address address = httpAddress();
-    RouteSelector routeSelector = new RouteSelector(address, routeDatabase);
+    RouteSelector routeSelector = new RouteSelector(address, routeDatabase, null,
+        EventListener.NONE);
 
     assertTrue(routeSelector.hasNext());
-    dns.addresses(makeFakeAddresses(255, 1));
-    assertRoute(routeSelector.next(), address, NO_PROXY, dns.address(0), uriPort);
+    dns.set(uriHost, dns.allocate(1));
+    assertRoute(routeSelector.next(), address, NO_PROXY, dns.lookup(uriHost, 0), uriPort);
     dns.assertRequests(uriHost);
 
     assertFalse(routeSelector.hasNext());
@@ -101,14 +103,15 @@
 
   @Test public void singleRouteReturnsFailedRoute() throws Exception {
     Address address = httpAddress();
-    RouteSelector routeSelector = new RouteSelector(address, routeDatabase);
+    RouteSelector routeSelector = new RouteSelector(address, routeDatabase, null,
+        EventListener.NONE);
 
     assertTrue(routeSelector.hasNext());
-    dns.addresses(makeFakeAddresses(255, 1));
+    dns.set(uriHost, dns.allocate(1));
     Route route = routeSelector.next();
     routeDatabase.failed(route);
-    routeSelector = new RouteSelector(address, routeDatabase);
-    assertRoute(routeSelector.next(), address, NO_PROXY, dns.address(0), uriPort);
+    routeSelector = new RouteSelector(address, routeDatabase, null, EventListener.NONE);
+    assertRoute(routeSelector.next(), address, NO_PROXY, dns.lookup(uriHost, 0), uriPort);
     assertFalse(routeSelector.hasNext());
     try {
       routeSelector.next();
@@ -120,12 +123,13 @@
   @Test public void explicitProxyTriesThatProxysAddressesOnly() throws Exception {
     Address address = new Address(uriHost, uriPort, dns, socketFactory, null, null, null,
         authenticator, proxyA, protocols, connectionSpecs, proxySelector);
-    RouteSelector routeSelector = new RouteSelector(address, routeDatabase);
+    RouteSelector routeSelector = new RouteSelector(address, routeDatabase, null,
+        EventListener.NONE);
 
     assertTrue(routeSelector.hasNext());
-    dns.addresses(makeFakeAddresses(255, 2));
-    assertRoute(routeSelector.next(), address, proxyA, dns.address(0), proxyAPort);
-    assertRoute(routeSelector.next(), address, proxyA, dns.address(1), proxyAPort);
+    dns.set(proxyAHost, dns.allocate(2));
+    assertRoute(routeSelector.next(), address, proxyA, dns.lookup(proxyAHost, 0), proxyAPort);
+    assertRoute(routeSelector.next(), address, proxyA, dns.lookup(proxyAHost, 1), proxyAPort);
 
     assertFalse(routeSelector.hasNext());
     dns.assertRequests(proxyAHost);
@@ -135,12 +139,13 @@
   @Test public void explicitDirectProxy() throws Exception {
     Address address = new Address(uriHost, uriPort, dns, socketFactory, null, null, null,
         authenticator, NO_PROXY, protocols, connectionSpecs, proxySelector);
-    RouteSelector routeSelector = new RouteSelector(address, routeDatabase);
+    RouteSelector routeSelector = new RouteSelector(address, routeDatabase, null,
+        EventListener.NONE);
 
     assertTrue(routeSelector.hasNext());
-    dns.addresses(makeFakeAddresses(255, 2));
-    assertRoute(routeSelector.next(), address, NO_PROXY, dns.address(0), uriPort);
-    assertRoute(routeSelector.next(), address, NO_PROXY, dns.address(1), uriPort);
+    dns.set(uriHost, dns.allocate(2));
+    assertRoute(routeSelector.next(), address, NO_PROXY, dns.lookup(uriHost, 0), uriPort);
+    assertRoute(routeSelector.next(), address, NO_PROXY, dns.lookup(uriHost, 1), uriPort);
 
     assertFalse(routeSelector.hasNext());
     dns.assertRequests(uriHost);
@@ -162,10 +167,11 @@
 
     Address address = new Address(uriHost, uriPort, dns, socketFactory, null, null, null,
         authenticator, null, protocols, connectionSpecs, nullProxySelector);
-    RouteSelector routeSelector = new RouteSelector(address, routeDatabase);
+    RouteSelector routeSelector = new RouteSelector(address, routeDatabase, null,
+        EventListener.NONE);
     assertTrue(routeSelector.hasNext());
-    dns.addresses(makeFakeAddresses(255, 1));
-    assertRoute(routeSelector.next(), address, NO_PROXY, dns.address(0), uriPort);
+    dns.set(uriHost, dns.allocate(1));
+    assertRoute(routeSelector.next(), address, NO_PROXY, dns.lookup(uriHost, 0), uriPort);
     dns.assertRequests(uriHost);
 
     assertFalse(routeSelector.hasNext());
@@ -173,12 +179,13 @@
 
   @Test public void proxySelectorReturnsNoProxies() throws Exception {
     Address address = httpAddress();
-    RouteSelector routeSelector = new RouteSelector(address, routeDatabase);
+    RouteSelector routeSelector = new RouteSelector(address, routeDatabase, null,
+        EventListener.NONE);
 
     assertTrue(routeSelector.hasNext());
-    dns.addresses(makeFakeAddresses(255, 2));
-    assertRoute(routeSelector.next(), address, NO_PROXY, dns.address(0), uriPort);
-    assertRoute(routeSelector.next(), address, NO_PROXY, dns.address(1), uriPort);
+    dns.set(uriHost, dns.allocate(2));
+    assertRoute(routeSelector.next(), address, NO_PROXY, dns.lookup(uriHost, 0), uriPort);
+    assertRoute(routeSelector.next(), address, NO_PROXY, dns.lookup(uriHost, 1), uriPort);
 
     assertFalse(routeSelector.hasNext());
     dns.assertRequests(uriHost);
@@ -190,20 +197,21 @@
 
     proxySelector.proxies.add(proxyA);
     proxySelector.proxies.add(proxyB);
-    RouteSelector routeSelector = new RouteSelector(address, routeDatabase);
+    RouteSelector routeSelector = new RouteSelector(address, routeDatabase, null,
+        EventListener.NONE);
     proxySelector.assertRequests(address.url().uri());
 
     // First try the IP addresses of the first proxy, in sequence.
     assertTrue(routeSelector.hasNext());
-    dns.addresses(makeFakeAddresses(255, 2));
-    assertRoute(routeSelector.next(), address, proxyA, dns.address(0), proxyAPort);
-    assertRoute(routeSelector.next(), address, proxyA, dns.address(1), proxyAPort);
+    dns.set(proxyAHost, dns.allocate(2));
+    assertRoute(routeSelector.next(), address, proxyA, dns.lookup(proxyAHost, 0), proxyAPort);
+    assertRoute(routeSelector.next(), address, proxyA, dns.lookup(proxyAHost, 1), proxyAPort);
     dns.assertRequests(proxyAHost);
 
     // Next try the IP address of the second proxy.
     assertTrue(routeSelector.hasNext());
-    dns.addresses(makeFakeAddresses(254, 1));
-    assertRoute(routeSelector.next(), address, proxyB, dns.address(0), proxyBPort);
+    dns.set(proxyBHost, dns.allocate(1));
+    assertRoute(routeSelector.next(), address, proxyB, dns.lookup(proxyBHost, 0), proxyBPort);
     dns.assertRequests(proxyBHost);
 
     // No more proxies to try.
@@ -214,13 +222,14 @@
     Address address = httpAddress();
 
     proxySelector.proxies.add(NO_PROXY);
-    RouteSelector routeSelector = new RouteSelector(address, routeDatabase);
+    RouteSelector routeSelector = new RouteSelector(address, routeDatabase, null,
+        EventListener.NONE);
     proxySelector.assertRequests(address.url().uri());
 
     // Only the origin server will be attempted.
     assertTrue(routeSelector.hasNext());
-    dns.addresses(makeFakeAddresses(255, 1));
-    assertRoute(routeSelector.next(), address, NO_PROXY, dns.address(0), uriPort);
+    dns.set(uriHost, dns.allocate(1));
+    assertRoute(routeSelector.next(), address, NO_PROXY, dns.lookup(uriHost, 0), uriPort);
     dns.assertRequests(uriHost);
 
     assertFalse(routeSelector.hasNext());
@@ -232,16 +241,17 @@
     proxySelector.proxies.add(proxyA);
     proxySelector.proxies.add(proxyB);
     proxySelector.proxies.add(proxyA);
-    RouteSelector routeSelector = new RouteSelector(address, routeDatabase);
+    RouteSelector routeSelector = new RouteSelector(address, routeDatabase, null,
+        EventListener.NONE);
     proxySelector.assertRequests(address.url().uri());
 
     assertTrue(routeSelector.hasNext());
-    dns.addresses(makeFakeAddresses(255, 1));
-    assertRoute(routeSelector.next(), address, proxyA, dns.address(0), proxyAPort);
+    dns.set(proxyAHost, dns.allocate(1));
+    assertRoute(routeSelector.next(), address, proxyA, dns.lookup(proxyAHost, 0), proxyAPort);
     dns.assertRequests(proxyAHost);
 
     assertTrue(routeSelector.hasNext());
-    dns.unknownHost();
+    dns.clear(proxyBHost);
     try {
       routeSelector.next();
       fail();
@@ -250,8 +260,8 @@
     dns.assertRequests(proxyBHost);
 
     assertTrue(routeSelector.hasNext());
-    dns.addresses(makeFakeAddresses(255, 1));
-    assertRoute(routeSelector.next(), address, proxyA, dns.address(0), proxyAPort);
+    dns.set(proxyAHost, dns.allocate(1));
+    assertRoute(routeSelector.next(), address, proxyA, dns.lookup(proxyAHost, 0), proxyAPort);
     dns.assertRequests(proxyAHost);
 
     assertFalse(routeSelector.hasNext());
@@ -261,19 +271,20 @@
     Address address = httpsAddress();
     proxySelector.proxies.add(proxyA);
     proxySelector.proxies.add(proxyB);
-    RouteSelector routeSelector = new RouteSelector(address, routeDatabase);
+    RouteSelector routeSelector = new RouteSelector(address, routeDatabase, null,
+        EventListener.NONE);
 
     // Proxy A
-    dns.addresses(makeFakeAddresses(255, 2));
-    assertRoute(routeSelector.next(), address, proxyA, dns.address(0), proxyAPort);
+    dns.set(proxyAHost, dns.allocate(2));
+    assertRoute(routeSelector.next(), address, proxyA, dns.lookup(proxyAHost, 0), proxyAPort);
     dns.assertRequests(proxyAHost);
-    assertRoute(routeSelector.next(), address, proxyA, dns.address(1), proxyAPort);
+    assertRoute(routeSelector.next(), address, proxyA, dns.lookup(proxyAHost, 1), proxyAPort);
 
     // Proxy B
-    dns.addresses(makeFakeAddresses(254, 2));
-    assertRoute(routeSelector.next(), address, proxyB, dns.address(0), proxyBPort);
+    dns.set(proxyBHost, dns.allocate(2));
+    assertRoute(routeSelector.next(), address, proxyB, dns.lookup(proxyBHost, 0), proxyBPort);
     dns.assertRequests(proxyBHost);
-    assertRoute(routeSelector.next(), address, proxyB, dns.address(1), proxyBPort);
+    assertRoute(routeSelector.next(), address, proxyB, dns.lookup(proxyBHost, 1), proxyBPort);
 
     // No more proxies to attempt.
     assertFalse(routeSelector.hasNext());
@@ -281,10 +292,11 @@
 
   @Test public void failedRoutesAreLast() throws Exception {
     Address address = httpsAddress();
-    RouteSelector routeSelector = new RouteSelector(address, routeDatabase);
+    RouteSelector routeSelector = new RouteSelector(address, routeDatabase, null,
+        EventListener.NONE);
 
     final int numberOfAddresses = 2;
-    dns.addresses(makeFakeAddresses(255, numberOfAddresses));
+    dns.set(uriHost, dns.allocate(numberOfAddresses));
 
     // Extract the regular sequence of routes from selector.
     List<Route> regularRoutes = new ArrayList<>();
@@ -297,7 +309,7 @@
     // Add first regular route as failed.
     routeDatabase.failed(regularRoutes.get(0));
     // Reset selector
-    routeSelector = new RouteSelector(address, routeDatabase);
+    routeSelector = new RouteSelector(address, routeDatabase, null, EventListener.NONE);
 
     List<Route> routesWithFailedRoute = new ArrayList<>();
     while (routeSelector.hasNext()) {
@@ -327,6 +339,12 @@
     assertEquals("127.0.0.1", RouteSelector.getHostString(socketAddress));
   }
 
+  @Test public void routeToString() throws Exception {
+    Route route = new Route(httpAddress(), Proxy.NO_PROXY,
+        InetSocketAddress.createUnresolved("host", 1234));
+    assertEquals("Route{host:1234}", route.toString());
+  }
+
   private void assertRoute(Route route, Address address, Proxy proxy, InetAddress socketAddress,
       int socketPort) {
     assertEquals(address, route.address());
@@ -345,17 +363,4 @@ private Address httpsAddress() {
     return new Address(uriHost, uriPort, dns, socketFactory, sslSocketFactory,
         hostnameVerifier, null, authenticator, null, protocols, connectionSpecs, proxySelector);
   }
-
-  private static List<InetAddress> makeFakeAddresses(int prefix, int count) {
-    try {
-      List<InetAddress> result = new ArrayList<>();
-      for (int i = 0; i < count; i++) {
-        result.add(InetAddress.getByAddress(
-            new byte[] {(byte) prefix, (byte) 0, (byte) 0, (byte) i}));
-      }
-      return result;
-    } catch (UnknownHostException e) {
-      throw new AssertionError();
-    }
-  }
 }
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/http/RecordingProxySelector.java b/okhttp-tests/src/test/java/okhttp3/internal/http/RecordingProxySelector.java
index 33a51500e0..bd4038d4a1 100644
--- a/okhttp-tests/src/test/java/okhttp3/internal/http/RecordingProxySelector.java
+++ b/okhttp-tests/src/test/java/okhttp3/internal/http/RecordingProxySelector.java
@@ -49,4 +49,8 @@ public void assertRequests(URI... expectedUris) {
         Util.format("%s %s:%d %s", uri, socketAddress.getHostName(), socketAddress.getPort(),
             ioe.getMessage()));
   }
+
+  @Override public String toString() {
+    return "RecordingProxySelector";
+  }
 }
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/http2/Http2ConnectionTest.java b/okhttp-tests/src/test/java/okhttp3/internal/http2/Http2ConnectionTest.java
index a782691f7d..c8af96913b 100644
--- a/okhttp-tests/src/test/java/okhttp3/internal/http2/Http2ConnectionTest.java
+++ b/okhttp-tests/src/test/java/okhttp3/internal/http2/Http2ConnectionTest.java
@@ -42,6 +42,7 @@
 import static okhttp3.TestUtil.headerEntries;
 import static okhttp3.TestUtil.repeat;
 import static okhttp3.internal.Util.EMPTY_BYTE_ARRAY;
+import static okhttp3.internal.http2.Http2Connection.Listener.REFUSE_INCOMING_STREAMS;
 import static okhttp3.internal.http2.Settings.DEFAULT_INITIAL_WINDOW_SIZE;
 import static okhttp3.internal.http2.Settings.ENABLE_PUSH;
 import static okhttp3.internal.http2.Settings.HEADER_TABLE_SIZE;
@@ -64,12 +65,14 @@
 
   @Test public void serverPingsClientHttp2() throws Exception {
     // write the mocking script
+    peer.sendFrame().settings(new Settings());
+    peer.acceptFrame(); // ACK
     peer.sendFrame().ping(false, 2, 3);
     peer.acceptFrame(); // PING
     peer.play();
 
     // play it back
-    connection(peer);
+    connect(peer);
 
     // verify the peer received what was expected
     InFrame ping = peer.takeFrame();
@@ -82,12 +85,14 @@
 
   @Test public void clientPingsServerHttp2() throws Exception {
     // write the mocking script
+    peer.sendFrame().settings(new Settings());
+    peer.acceptFrame(); // ACK
     peer.acceptFrame(); // PING
     peer.sendFrame().ping(true, 1, 5);
     peer.play();
 
     // play it back
-    Http2Connection connection = connection(peer);
+    Http2Connection connection = connect(peer);
     Ping ping = connection.ping();
     assertTrue(ping.roundTripTime() > 0);
     assertTrue(ping.roundTripTime() < TimeUnit.SECONDS.toNanos(1));
@@ -113,17 +118,13 @@
     peer.acceptFrame(); // HEADERS
     peer.play();
 
-    Http2Connection connection = connection(peer);
+    Http2Connection connection = connect(peer);
 
-    // Verify the peer received the ACK.
+    // Verify the peer received the second ACK.
     InFrame ackFrame = peer.takeFrame();
     assertEquals(Http2.TYPE_SETTINGS, ackFrame.type);
     assertEquals(0, ackFrame.streamId);
     assertTrue(ackFrame.ack);
-    ackFrame = peer.takeFrame();
-    assertEquals(Http2.TYPE_SETTINGS, ackFrame.type);
-    assertEquals(0, ackFrame.streamId);
-    assertTrue(ackFrame.ack);
 
     // This stream was created *after* the connection settings were adjusted.
     Http2Stream stream = connection.newStream(headerEntries("a", "android"), false);
@@ -139,7 +140,7 @@
     Settings settings = new Settings();
     settings.set(HEADER_TABLE_SIZE, 0);
 
-    Http2Connection connection = sendHttp2SettingsAndCheckForAck(client, settings);
+    Http2Connection connection = connectWithSettings(client, settings);
 
     // Verify the peer's settings were read and applied.
     assertEquals(0, connection.peerSettings.getHeaderTableSize());
@@ -153,7 +154,7 @@
     Settings settings = new Settings();
     settings.set(ENABLE_PUSH, 0); // The peer client disables push.
 
-    Http2Connection connection = sendHttp2SettingsAndCheckForAck(client, settings);
+    Http2Connection connection = connectWithSettings(client, settings);
 
     // verify the peer's settings were read and applied.
     assertFalse(connection.peerSettings.getEnablePush(true));
@@ -164,7 +165,7 @@
     Settings settings = new Settings();
     settings.set(MAX_FRAME_SIZE, newMaxFrameSize);
 
-    Http2Connection connection = sendHttp2SettingsAndCheckForAck(true, settings);
+    Http2Connection connection = connectWithSettings(true, settings);
 
     // verify the peer's settings were read and applied.
     assertEquals(newMaxFrameSize, connection.peerSettings.getMaxFrameSize(-1));
@@ -181,9 +182,9 @@
 
     // Write the mocking script.
     peer.sendFrame().settings(new Settings().set(INITIAL_WINDOW_SIZE, 0));
+    peer.acceptFrame(); // ACK
     peer.sendFrame().windowUpdate(0, 10); // Increase the connection window size.
-    peer.acceptFrame(); // PING or SETTINGS ACK
-    peer.acceptFrame(); // PING or SETTINGS ACK
+    peer.acceptFrame(); // PING
     peer.sendFrame().ping(true, 1, 0);
     peer.acceptFrame(); // HEADERS STREAM 3
     peer.sendFrame().windowUpdate(3, 5);
@@ -193,7 +194,7 @@
     peer.play();
 
     // Play it back.
-    Http2Connection connection = connection(peer);
+    Http2Connection connection = connect(peer);
     connection.ping().roundTripTime(); // Ensure the SETTINGS have been received.
     Http2Stream stream = connection.newStream(headerEntries("a", "android"), true);
     BufferedSink sink = Okio.buffer(stream.getSink());
@@ -201,8 +202,7 @@
     sink.flush();
 
     // Verify the peer received what was expected.
-    peer.takeFrame(); // PING or SETTINGS ACK
-    peer.takeFrame(); // PING or SETTINGS ACK
+    peer.takeFrame(); // PING
     InFrame headers = peer.takeFrame();
     assertEquals(Http2.TYPE_HEADERS, headers.type);
     InFrame data1 = peer.takeFrame();
@@ -217,6 +217,8 @@
 
   @Test public void receiveGoAwayHttp2() throws Exception {
     // write the mocking script
+    peer.sendFrame().settings(new Settings());
+    peer.acceptFrame(); // ACK
     peer.acceptFrame(); // SYN_STREAM 3
     peer.acceptFrame(); // SYN_STREAM 5
     peer.sendFrame().goAway(3, ErrorCode.PROTOCOL_ERROR, EMPTY_BYTE_ARRAY);
@@ -226,7 +228,7 @@
     peer.play();
 
     // play it back
-    Http2Connection connection = connection(peer);
+    Http2Connection connection = connect(peer);
     Http2Stream stream1 = connection.newStream(headerEntries("a", "android"), true);
     Http2Stream stream2 = connection.newStream(headerEntries("b", "banana"), true);
     connection.ping().roundTripTime(); // Ensure the GO_AWAY that resets stream2 has been received.
@@ -269,6 +271,8 @@
     int windowUpdateThreshold = 50;
 
     // Write the mocking script.
+    peer.sendFrame().settings(new Settings());
+    peer.acceptFrame(); // ACK
     peer.acceptFrame(); // SYN_STREAM
     peer.sendFrame().synReply(false, 3, headerEntries("a", "android"));
     for (int i = 0; i < 3; i++) {
@@ -283,11 +287,11 @@
     peer.play();
 
     // Play it back.
-    Http2Connection connection = connection(peer);
+    Http2Connection connection = connect(peer);
     connection.okHttpSettings.set(INITIAL_WINDOW_SIZE, windowSize);
     Http2Stream stream = connection.newStream(headerEntries("b", "banana"), false);
     assertEquals(0, stream.unacknowledgedBytesRead);
-    assertEquals(headerEntries("a", "android"), stream.getResponseHeaders());
+    assertEquals(headerEntries("a", "android"), stream.takeResponseHeaders());
     Source in = stream.getSource();
     Buffer buffer = new Buffer();
     buffer.writeAll(in);
@@ -311,31 +315,35 @@
 
   @Test public void serverSendsEmptyDataClientDoesntSendWindowUpdateHttp2() throws Exception {
     // Write the mocking script.
+    peer.sendFrame().settings(new Settings());
+    peer.acceptFrame(); // ACK
     peer.acceptFrame(); // SYN_STREAM
     peer.sendFrame().synReply(false, 3, headerEntries("a", "android"));
     peer.sendFrame().data(true, 3, data(0), 0);
     peer.play();
 
     // Play it back.
-    Http2Connection connection = connection(peer);
+    Http2Connection connection = connect(peer);
     Http2Stream client = connection.newStream(headerEntries("b", "banana"), false);
     assertEquals(-1, client.getSource().read(new Buffer(), 1));
 
     // Verify the peer received what was expected.
     InFrame synStream = peer.takeFrame();
     assertEquals(Http2.TYPE_HEADERS, synStream.type);
-    assertEquals(3, peer.frameCount());
+    assertEquals(5, peer.frameCount());
   }
 
   @Test public void clientSendsEmptyDataServerDoesntSendWindowUpdateHttp2() throws Exception {
     // Write the mocking script.
+    peer.sendFrame().settings(new Settings());
+    peer.acceptFrame(); // ACK
     peer.acceptFrame(); // SYN_STREAM
     peer.acceptFrame(); // DATA
     peer.sendFrame().synReply(false, 3, headerEntries("a", "android"));
     peer.play();
 
     // Play it back.
-    Http2Connection connection = connection(peer);
+    Http2Connection connection = connect(peer);
     Http2Stream client = connection.newStream(headerEntries("b", "banana"), true);
     BufferedSink out = Okio.buffer(client.getSink());
     out.write(EMPTY_BYTE_ARRAY);
@@ -345,7 +353,7 @@
     // Verify the peer received what was expected.
     assertEquals(Http2.TYPE_HEADERS, peer.takeFrame().type);
     assertEquals(Http2.TYPE_DATA, peer.takeFrame().type);
-    assertEquals(3, peer.frameCount());
+    assertEquals(5, peer.frameCount());
   }
 
   @Test public void maxFrameSizeHonored() throws Exception {
@@ -353,6 +361,8 @@
     Arrays.fill(buff, (byte) '*');
 
     // write the mocking script
+    peer.sendFrame().settings(new Settings());
+    peer.acceptFrame(); // ACK
     peer.acceptFrame(); // SYN_STREAM
     peer.sendFrame().synReply(false, 3, headerEntries("a", "android"));
     peer.acceptFrame(); // DATA
@@ -360,7 +370,7 @@
     peer.play();
 
     // play it back
-    Http2Connection connection = connection(peer);
+    Http2Connection connection = connect(peer);
     Http2Stream stream = connection.newStream(headerEntries("b", "banana"), true);
     BufferedSink out = Okio.buffer(stream.getSink());
     out.write(buff);
@@ -377,6 +387,8 @@
 
   @Test public void pushPromiseStream() throws Exception {
     // write the mocking script
+    peer.sendFrame().settings(new Settings());
+    peer.acceptFrame(); // ACK
     peer.acceptFrame(); // SYN_STREAM
     peer.sendFrame().synReply(false, 3, headerEntries("a", "android"));
     final List<Header> expectedRequestHeaders = Arrays.asList(
@@ -396,10 +408,7 @@
     RecordingPushObserver observer = new RecordingPushObserver();
 
     // play it back
-    Http2Connection connection = connectionBuilder(peer)
-        .pushObserver(observer)
-        .build();
-    connection.start(false);
+    Http2Connection connection = connect(peer, observer, REFUSE_INCOMING_STREAMS);
     Http2Stream client = connection.newStream(headerEntries("b", "banana"), false);
     assertEquals(-1, client.getSource().read(new Buffer(), 1));
 
@@ -412,6 +421,8 @@
 
   @Test public void doublePushPromise() throws Exception {
     // write the mocking script
+    peer.sendFrame().settings(new Settings());
+    peer.acceptFrame(); // ACK
     peer.sendFrame().pushPromise(3, 2, headerEntries("a", "android"));
     peer.acceptFrame(); // SYN_REPLY
     peer.sendFrame().pushPromise(3, 2, headerEntries("b", "banana"));
@@ -419,8 +430,7 @@
     peer.play();
 
     // play it back
-    Http2Connection connection = connectionBuilder(peer).build();
-    connection.start(false);
+    Http2Connection connection = connect(peer);
     connection.newStream(headerEntries("b", "banana"), false);
 
     // verify the peer received what was expected
@@ -430,6 +440,8 @@
 
   @Test public void pushPromiseStreamsAutomaticallyCancel() throws Exception {
     // write the mocking script
+    peer.sendFrame().settings(new Settings());
+    peer.acceptFrame(); // ACK
     peer.sendFrame().pushPromise(3, 2, Arrays.asList(
         new Header(Header.TARGET_METHOD, "GET"),
         new Header(Header.TARGET_SCHEME, "https"),
@@ -443,10 +455,7 @@
     peer.play();
 
     // play it back
-    Http2Connection connection = connectionBuilder(peer)
-        .pushObserver(PushObserver.CANCEL)
-        .build();
-    connection.start(false);
+    connect(peer, PushObserver.CANCEL, REFUSE_INCOMING_STREAMS);
 
     // verify the peer received what was expected
     InFrame rstStream = peer.takeFrame();
@@ -488,6 +497,8 @@
 
   @Test public void clientCreatesStreamAndServerReplies() throws Exception {
     // write the mocking script
+    peer.sendFrame().settings(new Settings());
+    peer.acceptFrame(); // ACK
     peer.acceptFrame(); // SYN_STREAM
     peer.acceptFrame(); // DATA
     peer.sendFrame().synReply(false, 3, headerEntries("a", "android"));
@@ -497,12 +508,12 @@
     peer.play();
 
     // play it back
-    Http2Connection connection = connection(peer);
+    Http2Connection connection = connect(peer);
     Http2Stream stream = connection.newStream(headerEntries("b", "banana"), true);
     BufferedSink out = Okio.buffer(stream.getSink());
     out.writeUtf8("c3po");
     out.close();
-    assertEquals(headerEntries("a", "android"), stream.getResponseHeaders());
+    assertEquals(headerEntries("a", "android"), stream.takeResponseHeaders());
     assertStreamData("robot", stream.getSource());
     connection.ping().roundTripTime();
     assertEquals(0, connection.openStreamCount());
@@ -520,6 +531,8 @@
 
   @Test public void clientCreatesStreamAndServerRepliesWithFin() throws Exception {
     // write the mocking script
+    peer.sendFrame().settings(new Settings());
+    peer.acceptFrame(); // ACK
     peer.acceptFrame(); // SYN_STREAM
     peer.acceptFrame(); // PING
     peer.sendFrame().synReply(true, 3, headerEntries("a", "android"));
@@ -527,7 +540,7 @@
     peer.play();
 
     // play it back
-    Http2Connection connection = connection(peer);
+    Http2Connection connection = connect(peer);
     connection.newStream(headerEntries("b", "banana"), false);
     assertEquals(1, connection.openStreamCount());
     connection.ping().roundTripTime(); // Ensure that the SYN_REPLY has been received.
@@ -542,12 +555,14 @@
 
   @Test public void serverPingsClient() throws Exception {
     // write the mocking script
+    peer.sendFrame().settings(new Settings());
+    peer.acceptFrame(); // ACK
     peer.sendFrame().ping(false, 2, 0);
     peer.acceptFrame(); // PING
     peer.play();
 
     // play it back
-    connection(peer);
+    connect(peer);
 
     // verify the peer received what was expected
     InFrame ping = peer.takeFrame();
@@ -559,12 +574,14 @@
 
   @Test public void clientPingsServer() throws Exception {
     // write the mocking script
+    peer.sendFrame().settings(new Settings());
+    peer.acceptFrame(); // ACK
     peer.acceptFrame(); // PING
     peer.sendFrame().ping(true, 1, 5);
     peer.play();
 
     // play it back
-    Http2Connection connection = connection(peer);
+    Http2Connection connection = connect(peer);
     Ping ping = connection.ping();
     assertTrue(ping.roundTripTime() > 0);
     assertTrue(ping.roundTripTime() < TimeUnit.SECONDS.toNanos(1));
@@ -579,6 +596,8 @@
 
   @Test public void unexpectedPingIsNotReturned() throws Exception {
     // write the mocking script
+    peer.sendFrame().settings(new Settings());
+    peer.acceptFrame(); // ACK
     peer.sendFrame().ping(false, 2, 0);
     peer.acceptFrame(); // PING
     peer.sendFrame().ping(true, 3, 0); // This ping will not be returned.
@@ -587,7 +606,7 @@
     peer.play();
 
     // play it back
-    connection(peer);
+    connect(peer);
 
     // verify the peer received what was expected
     InFrame ping2 = peer.takeFrame();
@@ -601,6 +620,7 @@
     final Settings settings = new Settings();
     settings.set(MAX_CONCURRENT_STREAMS, 10);
     peer.sendFrame().settings(settings);
+    peer.acceptFrame(); // ACK
     peer.sendFrame().ping(false, 2, 0);
     peer.acceptFrame(); // PING
     peer.play();
@@ -618,12 +638,8 @@
         maxConcurrentStreamsUpdated.countDown();
       }
     };
-    Http2Connection connection = connectionBuilder(peer)
-        .listener(listener)
-        .build();
-    connection.start(false);
+    Http2Connection connection = connect(peer, IGNORE, listener);
 
-    peer.takeFrame(); // Guarantees that the peer Settings frame has been processed.
     synchronized (connection) {
       assertEquals(10, connection.peerSettings.getMaxConcurrentStreams(-1));
     }
@@ -650,9 +666,8 @@
     peer.play();
 
     // play it back
-    Http2Connection connection = connection(peer);
+    Http2Connection connection = connect(peer);
 
-    assertEquals(Http2.TYPE_SETTINGS, peer.takeFrame().type);
     assertEquals(Http2.TYPE_SETTINGS, peer.takeFrame().type);
     assertEquals(Http2.TYPE_PING, peer.takeFrame().type);
     synchronized (connection) {
@@ -670,14 +685,13 @@
     settings1.set(INITIAL_WINDOW_SIZE, 20000);
     settings1.set(MAX_FRAME_SIZE, 30000);
     peer.sendFrame().settings(settings1);
+    peer.acceptFrame(); // ACK
     peer.sendFrame().ping(false, 2, 0);
     peer.acceptFrame();
     peer.play();
 
     // play it back
-    Http2Connection connection = connection(peer);
-
-    peer.takeFrame(); // Guarantees that the Settings frame has been processed.
+    Http2Connection connection = connect(peer);
 
     // fake a settings frame with clear flag set.
     Settings settings2 = new Settings();
@@ -694,6 +708,8 @@
 
   @Test public void bogusDataFrameDoesNotDisruptConnection() throws Exception {
     // write the mocking script
+    peer.sendFrame().settings(new Settings());
+    peer.acceptFrame(); // ACK
     peer.sendFrame().data(true, 41, new Buffer().writeUtf8("bogus"), 5);
     peer.acceptFrame(); // RST_STREAM
     peer.sendFrame().ping(false, 2, 0);
@@ -701,7 +717,7 @@
     peer.play();
 
     // play it back
-    connection(peer);
+    connect(peer);
 
     // verify the peer received what was expected
     InFrame rstStream = peer.takeFrame();
@@ -714,13 +730,15 @@
 
   @Test public void bogusReplySilentlyIgnored() throws Exception {
     // write the mocking script
+    peer.sendFrame().settings(new Settings());
+    peer.acceptFrame(); // ACK
     peer.sendFrame().synReply(false, 41, headerEntries("a", "android"));
     peer.sendFrame().ping(false, 2, 0);
     peer.acceptFrame(); // PING
     peer.play();
 
     // play it back
-    connection(peer);
+    connect(peer);
 
     // verify the peer received what was expected
     InFrame ping = peer.takeFrame();
@@ -729,6 +747,8 @@
 
   @Test public void serverClosesClientOutputStream() throws Exception {
     // write the mocking script
+    peer.sendFrame().settings(new Settings());
+    peer.acceptFrame(); // ACK
     peer.acceptFrame(); // SYN_STREAM
     peer.sendFrame().rstStream(3, ErrorCode.CANCEL);
     peer.acceptFrame(); // PING
@@ -736,7 +756,7 @@
     peer.play();
 
     // play it back
-    Http2Connection connection = connection(peer);
+    Http2Connection connection = connect(peer);
     Http2Stream stream = connection.newStream(headerEntries("a", "android"), true);
     BufferedSink out = Okio.buffer(stream.getSink());
     connection.ping().roundTripTime(); // Ensure that the RST_CANCEL has been received.
@@ -770,12 +790,14 @@
    */
   @Test public void clientClosesClientInputStream() throws Exception {
     // write the mocking script
+    peer.sendFrame().settings(new Settings());
+    peer.acceptFrame(); // ACK
     peer.acceptFrame(); // SYN_STREAM
     peer.acceptFrame(); // RST_STREAM
     peer.play();
 
     // play it back
-    Http2Connection connection = connection(peer);
+    Http2Connection connection = connect(peer);
     Http2Stream stream = connection.newStream(headerEntries("a", "android"), false);
     Source in = stream.getSource();
     BufferedSink out = Okio.buffer(stream.getSink());
@@ -810,6 +832,8 @@
    */
   @Test public void clientClosesClientInputStreamIfOutputStreamIsClosed() throws Exception {
     // write the mocking script
+    peer.sendFrame().settings(new Settings());
+    peer.acceptFrame(); // ACK
     peer.acceptFrame(); // SYN_STREAM
     peer.acceptFrame(); // DATA
     peer.acceptFrame(); // DATA with FLAG_FIN
@@ -817,7 +841,7 @@
     peer.play();
 
     // play it back
-    Http2Connection connection = connection(peer);
+    Http2Connection connection = connect(peer);
     Http2Stream stream = connection.newStream(headerEntries("a", "android"), true);
     Source source = stream.getSource();
     BufferedSink out = Okio.buffer(stream.getSink());
@@ -852,6 +876,8 @@
 
   @Test public void serverClosesClientInputStream() throws Exception {
     // write the mocking script
+    peer.sendFrame().settings(new Settings());
+    peer.acceptFrame(); // ACK
     peer.acceptFrame(); // SYN_STREAM
     peer.sendFrame().synReply(false, 3, headerEntries("b", "banana"));
     peer.sendFrame().data(true, 3, new Buffer().writeUtf8("square"), 6);
@@ -860,7 +886,7 @@
     peer.play();
 
     // play it back
-    Http2Connection connection = connection(peer);
+    Http2Connection connection = connect(peer);
     Http2Stream stream = connection.newStream(headerEntries("a", "android"), false);
     Source source = stream.getSource();
     assertStreamData("square", source);
@@ -876,6 +902,8 @@
 
   @Test public void remoteDoubleSynReply() throws Exception {
     // write the mocking script
+    peer.sendFrame().settings(new Settings());
+    peer.acceptFrame(); // ACK
     peer.acceptFrame(); // SYN_STREAM
     peer.sendFrame().synReply(false, 3, headerEntries("a", "android"));
     peer.acceptFrame(); // PING
@@ -884,9 +912,9 @@
     peer.play();
 
     // play it back
-    Http2Connection connection = connection(peer);
+    Http2Connection connection = connect(peer);
     Http2Stream stream = connection.newStream(headerEntries("c", "cola"), false);
-    assertEquals(headerEntries("a", "android"), stream.getResponseHeaders());
+    assertEquals(headerEntries("a", "android"), stream.takeResponseHeaders());
     connection.ping().roundTripTime(); // Ensure that the 2nd SYN REPLY has been received.
 
     // verify the peer received what was expected
@@ -898,6 +926,8 @@
 
   @Test public void remoteSendsDataAfterInFinished() throws Exception {
     // write the mocking script
+    peer.sendFrame().settings(new Settings());
+    peer.acceptFrame(); // ACK
     peer.acceptFrame(); // SYN_STREAM
     peer.sendFrame().synReply(false, 3, headerEntries("a", "android"));
     peer.sendFrame().data(true, 3, new Buffer().writeUtf8("robot"), 5);
@@ -908,9 +938,9 @@
     peer.play();
 
     // play it back
-    Http2Connection connection = connection(peer);
+    Http2Connection connection = connect(peer);
     Http2Stream stream = connection.newStream(headerEntries("b", "banana"), false);
-    assertEquals(headerEntries("a", "android"), stream.getResponseHeaders());
+    assertEquals(headerEntries("a", "android"), stream.takeResponseHeaders());
     assertStreamData("robot", stream.getSource());
 
     // verify the peer received what was expected
@@ -927,6 +957,8 @@
   @Test public void clientDoesNotLimitFlowControl() throws Exception {
     int dataLength = 16384;
     // write the mocking script
+    peer.sendFrame().settings(new Settings());
+    peer.acceptFrame(); // ACK
     peer.acceptFrame(); // SYN_STREAM
     peer.sendFrame().synReply(false, 3, headerEntries("b", "banana"));
     peer.sendFrame().data(false, 3, new Buffer().write(new byte[dataLength]), dataLength);
@@ -939,9 +971,9 @@
     peer.play();
 
     // play it back
-    Http2Connection connection = connection(peer);
+    Http2Connection connection = connect(peer);
     Http2Stream stream = connection.newStream(headerEntries("a", "android"), false);
-    assertEquals(headerEntries("b", "banana"), stream.getResponseHeaders());
+    assertEquals(headerEntries("b", "banana"), stream.takeResponseHeaders());
 
     // verify the peer received what was expected
     InFrame synStream = peer.takeFrame();
@@ -953,6 +985,8 @@
 
   @Test public void remoteSendsRefusedStreamBeforeReplyHeaders() throws Exception {
     // write the mocking script
+    peer.sendFrame().settings(new Settings());
+    peer.acceptFrame(); // ACK
     peer.acceptFrame(); // SYN_STREAM
     peer.sendFrame().rstStream(3, ErrorCode.REFUSED_STREAM);
     peer.sendFrame().ping(false, 2, 0);
@@ -960,10 +994,10 @@
     peer.play();
 
     // play it back
-    Http2Connection connection = connection(peer);
+    Http2Connection connection = connect(peer);
     Http2Stream stream = connection.newStream(headerEntries("a", "android"), false);
     try {
-      stream.getResponseHeaders();
+      stream.takeResponseHeaders();
       fail();
     } catch (IOException expected) {
       assertEquals("stream was reset: REFUSED_STREAM", expected.getMessage());
@@ -980,6 +1014,8 @@
 
   @Test public void receiveGoAway() throws Exception {
     // write the mocking script
+    peer.sendFrame().settings(new Settings());
+    peer.acceptFrame(); // ACK
     peer.acceptFrame(); // SYN_STREAM 1
     peer.acceptFrame(); // SYN_STREAM 3
     peer.acceptFrame(); // PING.
@@ -989,7 +1025,7 @@
     peer.play();
 
     // play it back
-    Http2Connection connection = connection(peer);
+    Http2Connection connection = connect(peer);
     Http2Stream stream1 = connection.newStream(headerEntries("a", "android"), true);
     Http2Stream stream2 = connection.newStream(headerEntries("b", "banana"), true);
     connection.ping().roundTripTime(); // Ensure the GO_AWAY that resets stream2 has been received.
@@ -1029,6 +1065,8 @@
 
   @Test public void sendGoAway() throws Exception {
     // write the mocking script
+    peer.sendFrame().settings(new Settings());
+    peer.acceptFrame(); // ACK
     peer.acceptFrame(); // SYN_STREAM 1
     peer.acceptFrame(); // GOAWAY
     peer.acceptFrame(); // PING
@@ -1037,7 +1075,7 @@
     peer.play();
 
     // play it back
-    Http2Connection connection = connection(peer);
+    Http2Connection connection = connect(peer);
     connection.newStream(headerEntries("a", "android"), false);
     Ping ping = connection.ping();
     connection.shutdown(ErrorCode.PROTOCOL_ERROR);
@@ -1057,11 +1095,13 @@
 
   @Test public void noPingsAfterShutdown() throws Exception {
     // write the mocking script
+    peer.sendFrame().settings(new Settings());
+    peer.acceptFrame(); // ACK
     peer.acceptFrame(); // GOAWAY
     peer.play();
 
     // play it back
-    Http2Connection connection = connection(peer);
+    Http2Connection connection = connect(peer);
     connection.shutdown(ErrorCode.INTERNAL_ERROR);
     try {
       connection.ping();
@@ -1077,13 +1117,15 @@
 
   @Test public void close() throws Exception {
     // write the mocking script
+    peer.sendFrame().settings(new Settings());
+    peer.acceptFrame(); // ACK
     peer.acceptFrame(); // SYN_STREAM
     peer.acceptFrame(); // GOAWAY
     peer.acceptFrame(); // RST_STREAM
     peer.play();
 
     // play it back
-    Http2Connection connection = connection(peer);
+    Http2Connection connection = connect(peer);
     Http2Stream stream = connection.newStream(headerEntries("a", "android"), false);
     assertEquals(1, connection.openStreamCount());
     connection.close();
@@ -1120,12 +1162,14 @@
 
   @Test public void closeCancelsPings() throws Exception {
     // write the mocking script
+    peer.sendFrame().settings(new Settings());
+    peer.acceptFrame(); // ACK
     peer.acceptFrame(); // PING
     peer.acceptFrame(); // GOAWAY
     peer.play();
 
     // play it back
-    Http2Connection connection = connection(peer);
+    Http2Connection connection = connect(peer);
     Ping ping = connection.ping();
     connection.close();
     assertEquals(-1, ping.roundTripTime());
@@ -1133,17 +1177,19 @@
 
   @Test public void getResponseHeadersTimesOut() throws Exception {
     // write the mocking script
+    peer.sendFrame().settings(new Settings());
+    peer.acceptFrame(); // ACK
     peer.acceptFrame(); // SYN_STREAM
     peer.acceptFrame(); // RST_STREAM
     peer.play();
 
     // play it back
-    Http2Connection connection = connection(peer);
+    Http2Connection connection = connect(peer);
     Http2Stream stream = connection.newStream(headerEntries("b", "banana"), false);
     stream.readTimeout().timeout(500, TimeUnit.MILLISECONDS);
     long startNanos = System.nanoTime();
     try {
-      stream.getResponseHeaders();
+      stream.takeResponseHeaders();
       fail();
     } catch (InterruptedIOException expected) {
     }
@@ -1159,13 +1205,15 @@
 
   @Test public void readTimesOut() throws Exception {
     // write the mocking script
+    peer.sendFrame().settings(new Settings());
+    peer.acceptFrame(); // ACK
     peer.acceptFrame(); // SYN_STREAM
     peer.sendFrame().synReply(false, 3, headerEntries("a", "android"));
     peer.acceptFrame(); // RST_STREAM
     peer.play();
 
     // play it back
-    Http2Connection connection = connection(peer);
+    Http2Connection connection = connect(peer);
     Http2Stream stream = connection.newStream(headerEntries("b", "banana"), false);
     stream.readTimeout().timeout(500, TimeUnit.MILLISECONDS);
     Source source = stream.getSource();
@@ -1190,9 +1238,9 @@
     Settings peerSettings = new Settings().set(INITIAL_WINDOW_SIZE, 5);
 
     // write the mocking script
-    peer.acceptFrame(); // PING
     peer.sendFrame().settings(peerSettings);
     peer.acceptFrame(); // ACK SETTINGS
+    peer.acceptFrame(); // PING
     peer.sendFrame().ping(true, 1, 0);
     peer.acceptFrame(); // SYN_STREAM
     peer.sendFrame().synReply(false, 3, headerEntries("a", "android"));
@@ -1201,7 +1249,7 @@
     peer.play();
 
     // play it back
-    Http2Connection connection = connection(peer);
+    Http2Connection connection = connect(peer);
     connection.ping().roundTripTime(); // Make sure settings have been received.
     Http2Stream stream = connection.newStream(headerEntries("b", "banana"), true);
     Sink sink = stream.getSink();
@@ -1221,7 +1269,6 @@
 
     // verify the peer received what was expected
     assertEquals(Http2.TYPE_PING, peer.takeFrame().type);
-    assertEquals(Http2.TYPE_SETTINGS, peer.takeFrame().type);
     assertEquals(Http2.TYPE_HEADERS, peer.takeFrame().type);
     assertEquals(Http2.TYPE_DATA, peer.takeFrame().type);
     assertEquals(Http2.TYPE_RST_STREAM, peer.takeFrame().type);
@@ -1233,9 +1280,9 @@
     Settings peerSettings = new Settings().set(INITIAL_WINDOW_SIZE, 5);
 
     // write the mocking script
-    peer.acceptFrame(); // PING
     peer.sendFrame().settings(peerSettings);
     peer.acceptFrame(); // ACK SETTINGS
+    peer.acceptFrame(); // PING
     peer.sendFrame().ping(true, 1, 0);
     peer.acceptFrame(); // SYN_STREAM
     peer.sendFrame().synReply(false, 3, headerEntries("a", "android"));
@@ -1247,7 +1294,7 @@
     peer.play();
 
     // play it back
-    Http2Connection connection = connection(peer);
+    Http2Connection connection = connect(peer);
     connection.ping().roundTripTime(); // Make sure settings have been acked.
     Http2Stream stream = connection.newStream(headerEntries("b", "banana"), true);
     connection.ping().roundTripTime(); // Make sure the window update has been received.
@@ -1267,7 +1314,6 @@
 
     // verify the peer received what was expected
     assertEquals(Http2.TYPE_PING, peer.takeFrame().type);
-    assertEquals(Http2.TYPE_SETTINGS, peer.takeFrame().type);
     assertEquals(Http2.TYPE_HEADERS, peer.takeFrame().type);
     assertEquals(Http2.TYPE_PING, peer.takeFrame().type);
     assertEquals(Http2.TYPE_DATA, peer.takeFrame().type);
@@ -1276,13 +1322,15 @@
 
   @Test public void outgoingWritesAreBatched() throws Exception {
     // write the mocking script
+    peer.sendFrame().settings(new Settings());
+    peer.acceptFrame(); // ACK
     peer.acceptFrame(); // SYN_STREAM
     peer.sendFrame().synReply(false, 3, headerEntries("a", "android"));
     peer.acceptFrame(); // DATA
     peer.play();
 
     // play it back
-    Http2Connection connection = connection(peer);
+    Http2Connection connection = connect(peer);
     Http2Stream stream = connection.newStream(headerEntries("b", "banana"), true);
 
     // two outgoing writes
@@ -1301,6 +1349,8 @@
 
   @Test public void headers() throws Exception {
     // write the mocking script
+    peer.sendFrame().settings(new Settings());
+    peer.acceptFrame(); // ACK
     peer.acceptFrame(); // SYN_STREAM
     peer.acceptFrame(); // PING
     peer.sendFrame().synReply(false, 3, headerEntries("a", "android"));
@@ -1309,10 +1359,11 @@
     peer.play();
 
     // play it back
-    Http2Connection connection = connection(peer);
+    Http2Connection connection = connect(peer);
     Http2Stream stream = connection.newStream(headerEntries("b", "banana"), true);
     connection.ping().roundTripTime(); // Ensure that the HEADERS has been received.
-    assertEquals(headerEntries("a", "android", "c", "c3po"), stream.getResponseHeaders());
+    assertEquals(Arrays.asList(new Header("a", "android"), null, new Header("c", "c3po")),
+        stream.takeResponseHeaders());
 
     // verify the peer received what was expected
     InFrame synStream = peer.takeFrame();
@@ -1321,11 +1372,37 @@
     assertEquals(Http2.TYPE_PING, ping.type);
   }
 
+  @Test public void readMultipleSetsOfResponseHeaders() throws Exception {
+    // write the mocking script
+    peer.sendFrame().settings(new Settings());
+    peer.acceptFrame(); // ACK
+    peer.acceptFrame(); // SYN_STREAM
+    peer.sendFrame().synReply(false, 3, headerEntries("a", "android"));
+    peer.acceptFrame(); // PING
+    peer.sendFrame().ping(true, 1, 0); // PING
+    peer.sendFrame().synReply(true, 3, headerEntries("c", "cola"));
+    peer.play();
+
+    // play it back
+    Http2Connection connection = connect(peer);
+    Http2Stream stream = connection.newStream(headerEntries("b", "banana"), true);
+    stream.getConnection().flush();
+    assertEquals(headerEntries("a", "android"), stream.takeResponseHeaders());
+    connection.ping().roundTripTime();
+    assertEquals(headerEntries("c", "cola"), stream.takeResponseHeaders());
+
+    // verify the peer received what was expected
+    assertEquals(Http2.TYPE_HEADERS, peer.takeFrame().type);
+    assertEquals(Http2.TYPE_PING, peer.takeFrame().type);
+  }
+
   @Test public void readSendsWindowUpdate() throws Exception {
     int windowSize = 100;
     int windowUpdateThreshold = 50;
 
     // Write the mocking script.
+    peer.sendFrame().settings(new Settings());
+    peer.acceptFrame(); // ACK
     peer.acceptFrame(); // SYN_STREAM
     peer.sendFrame().synReply(false, 3, headerEntries("a", "android"));
     for (int i = 0; i < 3; i++) {
@@ -1340,11 +1417,11 @@
     peer.play();
 
     // Play it back.
-    Http2Connection connection = connection(peer);
+    Http2Connection connection = connect(peer);
     connection.okHttpSettings.set(INITIAL_WINDOW_SIZE, windowSize);
     Http2Stream stream = connection.newStream(headerEntries("b", "banana"), false);
     assertEquals(0, stream.unacknowledgedBytesRead);
-    assertEquals(headerEntries("a", "android"), stream.getResponseHeaders());
+    assertEquals(headerEntries("a", "android"), stream.takeResponseHeaders());
     Source in = stream.getSource();
     Buffer buffer = new Buffer();
     buffer.writeAll(in);
@@ -1368,31 +1445,35 @@
 
   @Test public void serverSendsEmptyDataClientDoesntSendWindowUpdate() throws Exception {
     // Write the mocking script.
+    peer.sendFrame().settings(new Settings());
+    peer.acceptFrame(); // ACK
     peer.acceptFrame(); // SYN_STREAM
     peer.sendFrame().synReply(false, 3, headerEntries("a", "android"));
     peer.sendFrame().data(true, 3, data(0), 0);
     peer.play();
 
     // Play it back.
-    Http2Connection connection = connection(peer);
+    Http2Connection connection = connect(peer);
     Http2Stream client = connection.newStream(headerEntries("b", "banana"), false);
     assertEquals(-1, client.getSource().read(new Buffer(), 1));
 
     // Verify the peer received what was expected.
     InFrame synStream = peer.takeFrame();
     assertEquals(Http2.TYPE_HEADERS, synStream.type);
-    assertEquals(3, peer.frameCount());
+    assertEquals(5, peer.frameCount());
   }
 
   @Test public void clientSendsEmptyDataServerDoesntSendWindowUpdate() throws Exception {
     // Write the mocking script.
+    peer.sendFrame().settings(new Settings());
+    peer.acceptFrame(); // ACK
     peer.acceptFrame(); // SYN_STREAM
     peer.acceptFrame(); // DATA
     peer.sendFrame().synReply(false, 3, headerEntries("a", "android"));
     peer.play();
 
     // Play it back.
-    Http2Connection connection = connection(peer);
+    Http2Connection connection = connect(peer);
     Http2Stream client = connection.newStream(headerEntries("b", "banana"), true);
     BufferedSink out = Okio.buffer(client.getSink());
     out.write(Util.EMPTY_BYTE_ARRAY);
@@ -1402,11 +1483,13 @@
     // Verify the peer received what was expected.
     assertEquals(Http2.TYPE_HEADERS, peer.takeFrame().type);
     assertEquals(Http2.TYPE_DATA, peer.takeFrame().type);
-    assertEquals(3, peer.frameCount());
+    assertEquals(5, peer.frameCount());
   }
 
   @Test public void testTruncatedDataFrame() throws Exception {
     // write the mocking script
+    peer.sendFrame().settings(new Settings());
+    peer.acceptFrame(); // ACK
     peer.acceptFrame(); // SYN_STREAM
     peer.sendFrame().synReply(false, 3, headerEntries("a", "android"));
     peer.sendFrame().data(false, 3, data(1024), 1024);
@@ -1414,9 +1497,9 @@
     peer.play();
 
     // play it back
-    Http2Connection connection = connection(peer);
+    Http2Connection connection = connect(peer);
     Http2Stream stream = connection.newStream(headerEntries("b", "banana"), false);
-    assertEquals(headerEntries("a", "android"), stream.getResponseHeaders());
+    assertEquals(headerEntries("a", "android"), stream.takeResponseHeaders());
     Source in = stream.getSource();
     try {
       Okio.buffer(in).readByteString(101);
@@ -1430,6 +1513,8 @@
     int framesThatFillWindow = roundUp(DEFAULT_INITIAL_WINDOW_SIZE, peer.maxOutboundDataLength());
 
     // Write the mocking script. This accepts more data frames than necessary!
+    peer.sendFrame().settings(new Settings());
+    peer.acceptFrame(); // SETTINGS ACK
     peer.acceptFrame(); // SYN_STREAM on stream 1
     for (int i = 0; i < framesThatFillWindow; i++) {
       peer.acceptFrame(); // DATA on stream 1
@@ -1439,7 +1524,7 @@
     peer.play();
 
     // Play it back.
-    Http2Connection connection = connection(peer);
+    Http2Connection connection = connect(peer);
     Http2Stream stream1 = connection.newStream(headerEntries("a", "apple"), true);
     BufferedSink out1 = Okio.buffer(stream1.getSink());
     out1.write(new byte[DEFAULT_INITIAL_WINDOW_SIZE]);
@@ -1449,7 +1534,7 @@
     assertEquals(0, connection.bytesLeftInWriteWindow);
     assertEquals(0, connection.getStream(3).bytesLeftInWriteWindow);
 
-    // receiving a window update on the the connection will unblock new streams.
+    // receiving a window update on the connection will unblock new streams.
     connection.readerRunnable.windowUpdate(0, 3);
 
     assertEquals(3, connection.bytesLeftInWriteWindow);
@@ -1466,6 +1551,34 @@
     assertEquals(DEFAULT_INITIAL_WINDOW_SIZE - 3, connection.getStream(5).bytesLeftInWriteWindow);
   }
 
+  @Test public void remoteOmitsInitialSettings() throws Exception {
+    // Write the mocking script. Note no SETTINGS frame is sent or acknowledged.
+    peer.acceptFrame(); // SYN_STREAM
+    peer.sendFrame().synReply(false, 3, headerEntries("a", "android"));
+    peer.acceptFrame(); // GOAWAY
+    peer.play();
+
+    Http2Connection connection = new Http2Connection.Builder(true)
+        .socket(peer.openSocket())
+        .build();
+    connection.start(false);
+
+    Http2Stream stream = connection.newStream(headerEntries("b", "banana"), false);
+    try {
+      stream.takeResponseHeaders();
+      fail();
+    } catch (IOException expected) {
+      assertEquals("stream was reset: PROTOCOL_ERROR", expected.getMessage());
+    }
+
+    // verify the peer received what was expected
+    InFrame synStream = peer.takeFrame();
+    assertEquals(Http2.TYPE_HEADERS, synStream.type);
+    InFrame goaway = peer.takeFrame();
+    assertEquals(Http2.TYPE_GOAWAY, goaway.type);
+    assertEquals(ErrorCode.PROTOCOL_ERROR, goaway.errorCode);
+  }
+
   private Buffer data(int byteCount) {
     return new Buffer().write(new byte[byteCount]);
   }
@@ -1496,17 +1609,27 @@ static int roundUp(int num, int divisor) {
     return (num + divisor - 1) / divisor;
   }
 
-  private Http2Connection sendHttp2SettingsAndCheckForAck(boolean client, Settings settings)
-      throws IOException, InterruptedException {
+  private Http2Connection connectWithSettings(boolean client, Settings settings) throws Exception {
     peer.setClient(client);
     peer.sendFrame().settings(settings);
     peer.acceptFrame(); // ACK
-    peer.acceptFrame(); // PING
-    peer.sendFrame().ping(true, 1, 0);
     peer.play();
+    return connect(peer);
+  }
 
-    // play it back
-    Http2Connection connection = connection(peer);
+  private Http2Connection connect(MockHttp2Peer peer) throws Exception {
+    return connect(peer, IGNORE, REFUSE_INCOMING_STREAMS);
+  }
+
+  /** Builds a new connection to {@code peer} with settings acked. */
+  private Http2Connection connect(MockHttp2Peer peer, PushObserver pushObserver,
+      Http2Connection.Listener listener) throws Exception {
+    Http2Connection connection = new Http2Connection.Builder(true)
+        .socket(peer.openSocket())
+        .pushObserver(pushObserver)
+        .listener(listener)
+        .build();
+    connection.start(false);
 
     // verify the peer received the ACK
     InFrame ackFrame = peer.takeFrame();
@@ -1514,22 +1637,9 @@ private Http2Connection sendHttp2SettingsAndCheckForAck(boolean client, Settings
     assertEquals(0, ackFrame.streamId);
     assertTrue(ackFrame.ack);
 
-    connection.ping().roundTripTime(); // Ensure that settings have been applied before returning.
     return connection;
   }
 
-  private Http2Connection connection(MockHttp2Peer peer) throws IOException {
-    Http2Connection connection = connectionBuilder(peer).build();
-    connection.start(false);
-    return connection;
-  }
-
-  private Http2Connection.Builder connectionBuilder(MockHttp2Peer peer) throws IOException {
-    return new Http2Connection.Builder(true)
-        .socket(peer.openSocket())
-        .pushObserver(IGNORE);
-  }
-
   static final PushObserver IGNORE = new PushObserver() {
 
     @Override public boolean onRequest(int streamId, List<Header> requestHeaders) {
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/http2/Http2Test.java b/okhttp-tests/src/test/java/okhttp3/internal/http2/Http2Test.java
index 548dbe0207..24ec759c2d 100644
--- a/okhttp-tests/src/test/java/okhttp3/internal/http2/Http2Test.java
+++ b/okhttp-tests/src/test/java/okhttp3/internal/http2/Http2Test.java
@@ -52,7 +52,7 @@
     frame.writeInt(expectedStreamId);
     frame.writeInt(111111111); // custom data
 
-    reader.nextFrame(new BaseTestHandler()); // Should not callback.
+    reader.nextFrame(false, new BaseTestHandler()); // Should not callback.
   }
 
   @Test public void onlyOneLiteralHeadersFrame() throws IOException {
@@ -67,7 +67,7 @@
 
     assertEquals(frame, sendHeaderFrames(true, sentHeaders)); // Check writer sends the same bytes.
 
-    reader.nextFrame(new BaseTestHandler() {
+    reader.nextFrame(false, new BaseTestHandler() {
       @Override public void headers(boolean inFinished, int streamId,
           int associatedStreamId, List<Header> headerBlock) {
         assertTrue(inFinished);
@@ -90,7 +90,7 @@
     frame.writeByte(255); // Heaviest weight, zero-indexed.
     frame.writeAll(headerBytes);
 
-    reader.nextFrame(new BaseTestHandler() {
+    reader.nextFrame(false, new BaseTestHandler() {
       @Override public void priority(int streamId, int streamDependency, int weight,
           boolean exclusive) {
         assertEquals(0, streamDependency);
@@ -131,7 +131,7 @@
     assertEquals(frame, sendHeaderFrames(false, sentHeaders)); // Check writer sends the same bytes.
 
     // Reading the above frames should result in a concatenated headerBlock.
-    reader.nextFrame(new BaseTestHandler() {
+    reader.nextFrame(false, new BaseTestHandler() {
       @Override public void headers(boolean inFinished, int streamId,
           int associatedStreamId, List<Header> headerBlock) {
         assertFalse(inFinished);
@@ -163,7 +163,7 @@
 
     assertEquals(frame, sendPushPromiseFrames(expectedPromisedStreamId, pushPromise));
 
-    reader.nextFrame(new BaseTestHandler() {
+    reader.nextFrame(false, new BaseTestHandler() {
       @Override
       public void pushPromise(int streamId, int promisedStreamId, List<Header> headerBlock) {
         assertEquals(expectedStreamId, streamId);
@@ -199,7 +199,7 @@ public void pushPromise(int streamId, int promisedStreamId, List<Header> headerB
     assertEquals(frame, sendPushPromiseFrames(expectedPromisedStreamId, pushPromise));
 
     // Reading the above frames should result in a concatenated headerBlock.
-    reader.nextFrame(new BaseTestHandler() {
+    reader.nextFrame(false, new BaseTestHandler() {
       @Override
       public void pushPromise(int streamId, int promisedStreamId, List<Header> headerBlock) {
         assertEquals(expectedStreamId, streamId);
@@ -216,7 +216,7 @@ public void pushPromise(int streamId, int promisedStreamId, List<Header> headerB
     frame.writeInt(expectedStreamId & 0x7fffffff);
     frame.writeInt(ErrorCode.PROTOCOL_ERROR.httpCode);
 
-    reader.nextFrame(new BaseTestHandler() {
+    reader.nextFrame(false, new BaseTestHandler() {
       @Override public void rstStream(int streamId, ErrorCode errorCode) {
         assertEquals(expectedStreamId, streamId);
         assertEquals(ErrorCode.PROTOCOL_ERROR, errorCode);
@@ -236,7 +236,7 @@ public void pushPromise(int streamId, int promisedStreamId, List<Header> headerB
     frame.writeShort(2); // SETTINGS_ENABLE_PUSH
     frame.writeInt(0);
 
-    reader.nextFrame(new BaseTestHandler() {
+    reader.nextFrame(false, new BaseTestHandler() {
       @Override public void settings(boolean clearPrevious, Settings settings) {
         assertFalse(clearPrevious); // No clearPrevious in HTTP/2.
         assertEquals(reducedTableSizeBytes, settings.getHeaderTableSize());
@@ -254,7 +254,7 @@ public void pushPromise(int streamId, int promisedStreamId, List<Header> headerB
     frame.writeInt(2);
 
     try {
-      reader.nextFrame(new BaseTestHandler());
+      reader.nextFrame(false, new BaseTestHandler());
       fail();
     } catch (IOException e) {
       assertEquals("PROTOCOL_ERROR SETTINGS_ENABLE_PUSH != 0 or 1", e.getMessage());
@@ -270,7 +270,7 @@ public void pushPromise(int streamId, int promisedStreamId, List<Header> headerB
     frame.writeInt(1);
 
     final AtomicInteger settingValue = new AtomicInteger();
-    reader.nextFrame(new BaseTestHandler() {
+    reader.nextFrame(false, new BaseTestHandler() {
       @Override public void settings(boolean clearPrevious, Settings settings) {
         settingValue.set(settings.get(7));
       }
@@ -278,6 +278,21 @@ public void pushPromise(int streamId, int promisedStreamId, List<Header> headerB
     assertEquals(settingValue.intValue(), 1);
   }
 
+  @Test public void readSettingsFrameExperimentalId() throws IOException {
+    writeMedium(frame, 6); // 2 for the code and 4 for the value
+    frame.writeByte(Http2.TYPE_SETTINGS);
+    frame.writeByte(Http2.FLAG_NONE);
+    frame.writeInt(0); // Settings are always on the connection stream 0.
+    frame.write(ByteString.decodeHex("f000")); // Id reserved for experimental use.
+    frame.writeInt(1);
+
+    reader.nextFrame(false, new BaseTestHandler() {
+      @Override public void settings(boolean clearPrevious, Settings settings) {
+        // no-op
+      }
+    });
+  }
+
   @Test public void readSettingsFrameNegativeWindowSize() throws IOException {
     writeMedium(frame, 6); // 2 for the code and 4 for the value
     frame.writeByte(Http2.TYPE_SETTINGS);
@@ -287,7 +302,7 @@ public void pushPromise(int streamId, int promisedStreamId, List<Header> headerB
     frame.writeInt(Integer.MIN_VALUE);
 
     try {
-      reader.nextFrame(new BaseTestHandler());
+      reader.nextFrame(false, new BaseTestHandler());
       fail();
     } catch (IOException e) {
       assertEquals("PROTOCOL_ERROR SETTINGS_INITIAL_WINDOW_SIZE > 2^31 - 1", e.getMessage());
@@ -303,7 +318,7 @@ public void pushPromise(int streamId, int promisedStreamId, List<Header> headerB
     frame.writeInt(Integer.MIN_VALUE);
 
     try {
-      reader.nextFrame(new BaseTestHandler());
+      reader.nextFrame(false, new BaseTestHandler());
       fail();
     } catch (IOException e) {
       assertEquals("PROTOCOL_ERROR SETTINGS_MAX_FRAME_SIZE: -2147483648", e.getMessage());
@@ -319,7 +334,7 @@ public void pushPromise(int streamId, int promisedStreamId, List<Header> headerB
     frame.writeInt((int) Math.pow(2, 14) - 1);
 
     try {
-      reader.nextFrame(new BaseTestHandler());
+      reader.nextFrame(false, new BaseTestHandler());
       fail();
     } catch (IOException e) {
       assertEquals("PROTOCOL_ERROR SETTINGS_MAX_FRAME_SIZE: 16383", e.getMessage());
@@ -335,7 +350,7 @@ public void pushPromise(int streamId, int promisedStreamId, List<Header> headerB
     frame.writeInt((int) Math.pow(2, 24));
 
     try {
-      reader.nextFrame(new BaseTestHandler());
+      reader.nextFrame(false, new BaseTestHandler());
       fail();
     } catch (IOException e) {
       assertEquals("PROTOCOL_ERROR SETTINGS_MAX_FRAME_SIZE: 16777216", e.getMessage());
@@ -356,7 +371,7 @@ public void pushPromise(int streamId, int promisedStreamId, List<Header> headerB
     // Check writer sends the same bytes.
     assertEquals(frame, sendPingFrame(true, expectedPayload1, expectedPayload2));
 
-    reader.nextFrame(new BaseTestHandler() {
+    reader.nextFrame(false, new BaseTestHandler() {
       @Override public void ping(boolean ack, int payload1, int payload2) {
         assertTrue(ack);
         assertEquals(expectedPayload1, payload1);
@@ -378,7 +393,7 @@ public void pushPromise(int streamId, int promisedStreamId, List<Header> headerB
     // Check writer sends the same bytes.
     assertEquals(frame, sendDataFrame(new Buffer().write(expectedData)));
 
-    reader.nextFrame(new BaseTestHandler() {
+    reader.nextFrame(false, new BaseTestHandler() {
       @Override public void data(boolean inFinished, int streamId, BufferedSource source,
           int length) throws IOException {
         assertFalse(inFinished);
@@ -392,6 +407,23 @@ public void pushPromise(int streamId, int promisedStreamId, List<Header> headerB
     });
   }
 
+  @Test public void dataFrameNotAssociateWithStream() throws IOException {
+    byte[] payload = new byte[] {0x01, 0x02};
+
+    writeMedium(frame, payload.length);
+    frame.writeByte(Http2.TYPE_DATA);
+    frame.writeByte(Http2.FLAG_NONE);
+    frame.writeInt(0);
+    frame.write(payload);
+
+    try {
+      reader.nextFrame(false, new BaseTestHandler());
+      fail();
+    } catch (IOException e) {
+      assertEquals("PROTOCOL_ERROR: TYPE_DATA streamId == 0", e.getMessage());
+    }
+  }
+
   /** We do not send SETTINGS_COMPRESS_DATA = 1, nor want to. Let's make sure we error. */
   @Test public void compressedDataFrameWhenSettingDisabled() throws IOException {
     byte[] expectedData = new byte[Http2.INITIAL_MAX_FRAME_SIZE];
@@ -406,7 +438,7 @@ public void pushPromise(int streamId, int promisedStreamId, List<Header> headerB
     zipped.readAll(frame);
 
     try {
-      reader.nextFrame(new BaseTestHandler());
+      reader.nextFrame(false, new BaseTestHandler());
       fail();
     } catch (IOException e) {
       assertEquals("PROTOCOL_ERROR: FLAG_COMPRESSED without SETTINGS_COMPRESS_DATA",
@@ -431,7 +463,7 @@ public void pushPromise(int streamId, int promisedStreamId, List<Header> headerB
     frame.write(expectedData);
     frame.write(padding);
 
-    reader.nextFrame(assertData());
+    reader.nextFrame(false, assertData());
     assertTrue(frame.exhausted()); // Padding was skipped.
   }
 
@@ -447,7 +479,7 @@ public void pushPromise(int streamId, int promisedStreamId, List<Header> headerB
     frame.writeByte(0);
     frame.write(expectedData);
 
-    reader.nextFrame(assertData());
+    reader.nextFrame(false, assertData());
   }
 
   @Test public void readPaddedHeadersFrame() throws IOException {
@@ -464,7 +496,7 @@ public void pushPromise(int streamId, int promisedStreamId, List<Header> headerB
     frame.writeAll(headerBlock);
     frame.write(padding);
 
-    reader.nextFrame(assertHeaderBlock());
+    reader.nextFrame(false, assertHeaderBlock());
     assertTrue(frame.exhausted()); // Padding was skipped.
   }
 
@@ -477,7 +509,7 @@ public void pushPromise(int streamId, int promisedStreamId, List<Header> headerB
     frame.writeByte(0);
     frame.writeAll(headerBlock);
 
-    reader.nextFrame(assertHeaderBlock());
+    reader.nextFrame(false, assertHeaderBlock());
   }
 
   /** Headers are compressed, then framed. */
@@ -505,7 +537,7 @@ public void pushPromise(int streamId, int promisedStreamId, List<Header> headerB
     frame.writeInt(expectedStreamId & 0x7fffffff);
     frame.writeAll(headerBlock);
 
-    reader.nextFrame(assertHeaderBlock());
+    reader.nextFrame(false, assertHeaderBlock());
     assertTrue(frame.exhausted());
   }
 
@@ -530,7 +562,7 @@ public void pushPromise(int streamId, int promisedStreamId, List<Header> headerB
     // Check writer sends the same bytes.
     assertEquals(frame, windowUpdate(expectedWindowSizeIncrement));
 
-    reader.nextFrame(new BaseTestHandler() {
+    reader.nextFrame(false, new BaseTestHandler() {
       @Override public void windowUpdate(int streamId, long windowSizeIncrement) {
         assertEquals(expectedStreamId, streamId);
         assertEquals(expectedWindowSizeIncrement, windowSizeIncrement);
@@ -568,7 +600,7 @@ public void pushPromise(int streamId, int promisedStreamId, List<Header> headerB
     // Check writer sends the same bytes.
     assertEquals(frame, sendGoAway(expectedStreamId, expectedError, Util.EMPTY_BYTE_ARRAY));
 
-    reader.nextFrame(new BaseTestHandler() {
+    reader.nextFrame(false, new BaseTestHandler() {
       @Override public void goAway(
           int lastGoodStreamId, ErrorCode errorCode, ByteString debugData) {
         assertEquals(expectedStreamId, lastGoodStreamId);
@@ -594,7 +626,7 @@ public void pushPromise(int streamId, int promisedStreamId, List<Header> headerB
     // Check writer sends the same bytes.
     assertEquals(frame, sendGoAway(0, expectedError, expectedData.toByteArray()));
 
-    reader.nextFrame(new BaseTestHandler() {
+    reader.nextFrame(false, new BaseTestHandler() {
       @Override public void goAway(
           int lastGoodStreamId, ErrorCode errorCode, ByteString debugData) {
         assertEquals(0, lastGoodStreamId);
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/http2/HttpOverHttp2Test.java b/okhttp-tests/src/test/java/okhttp3/internal/http2/HttpOverHttp2Test.java
index 4c2e05844b..3ef429a957 100644
--- a/okhttp-tests/src/test/java/okhttp3/internal/http2/HttpOverHttp2Test.java
+++ b/okhttp-tests/src/test/java/okhttp3/internal/http2/HttpOverHttp2Test.java
@@ -20,7 +20,10 @@
 import java.net.Authenticator;
 import java.net.HttpURLConnection;
 import java.net.SocketTimeoutException;
+import java.util.ArrayList;
 import java.util.Arrays;
+import java.util.Collections;
+import java.util.List;
 import java.util.concurrent.CountDownLatch;
 import java.util.concurrent.ExecutorService;
 import java.util.concurrent.Executors;
@@ -39,19 +42,24 @@
 import okhttp3.Request;
 import okhttp3.RequestBody;
 import okhttp3.Response;
+import okhttp3.TestUtil;
 import okhttp3.internal.DoubleInetAddressDns;
 import okhttp3.internal.RecordingOkAuthenticator;
 import okhttp3.internal.SingleInetAddressDns;
+import okhttp3.internal.SocketRecorder;
 import okhttp3.internal.Util;
 import okhttp3.internal.connection.RealConnection;
 import okhttp3.internal.tls.SslClient;
+import okhttp3.mockwebserver.Dispatcher;
 import okhttp3.mockwebserver.MockResponse;
 import okhttp3.mockwebserver.MockWebServer;
 import okhttp3.mockwebserver.PushPromise;
+import okhttp3.mockwebserver.QueueDispatcher;
 import okhttp3.mockwebserver.RecordedRequest;
 import okhttp3.mockwebserver.SocketPolicy;
 import okio.Buffer;
 import okio.BufferedSink;
+import okio.BufferedSource;
 import okio.GzipSink;
 import okio.Okio;
 import org.junit.After;
@@ -67,6 +75,7 @@
 import static org.junit.Assert.assertArrayEquals;
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertNull;
+import static org.junit.Assert.assertTrue;
 import static org.junit.Assert.fail;
 
 /** Test how SPDY interacts with HTTP/2 features. */
@@ -202,8 +211,8 @@
 
           @Override public void writeTo(BufferedSink sink) throws IOException {
             sink.write(postBytes);  // push bytes into the stream's buffer
-            sink.flush(); // FramedConnection.writeData subject to write window
-            sink.close(); // FramedConnection.writeData empty frame
+            sink.flush(); // Http2Connection.writeData subject to write window
+            sink.close(); // Http2Connection.writeData empty frame
           }
         })
         .build());
@@ -331,8 +340,7 @@
     in.close();
   }
 
-  @Ignore // See https://github.com/square/okhttp/issues/578
-  @Test(timeout = 3000) public void readResponseHeaderTimeout() throws Exception {
+  @Test public void readResponseHeaderTimeout() throws Exception {
     server.enqueue(new MockResponse().setSocketPolicy(SocketPolicy.NO_RESPONSE));
     server.enqueue(new MockResponse().setBody("A"));
 
@@ -340,11 +348,27 @@
         .readTimeout(1000, MILLISECONDS)
         .build();
 
-    Call call = client.newCall(new Request.Builder()
+    // Make a call expecting a timeout reading the response headers.
+    Call call1 = client.newCall(new Request.Builder()
         .url(server.url("/"))
         .build());
-    Response response = call.execute();
-    assertEquals("A", response.body().string());
+    try {
+      call1.execute();
+      fail("Should have timed out!");
+    } catch (SocketTimeoutException expected) {
+      assertEquals("timeout", expected.getMessage());
+    }
+
+    // Confirm that a subsequent request on the same connection is not impacted.
+    Call call2 = client.newCall(new Request.Builder()
+        .url(server.url("/"))
+        .build());
+    Response response2 = call2.execute();
+    assertEquals("A", response2.body().string());
+
+    // Confirm that the connection was reused.
+    assertEquals(0, server.takeRequest().getSequenceNumber());
+    assertEquals(1, server.takeRequest().getSequenceNumber());
   }
 
   /**
@@ -377,27 +401,39 @@
    * time.
    */
   @Test public void readTimeoutOnSlowConnection() throws Exception {
-    char[] body = new char[2048]; // 2KiB to read.
-    Arrays.fill(body, 'y');
+    String body = TestUtil.repeat('y', 2048);
     server.enqueue(new MockResponse()
-        .setBody(new String(body))
+        .setBody(body)
         .throttleBody(1024, 1, SECONDS)); // Slow connection 1KiB/second.
+    server.enqueue(new MockResponse()
+        .setBody(body));
 
     client = client.newBuilder()
         .readTimeout(500, MILLISECONDS) // Half a second to read something.
         .build();
 
-    Call call = client.newCall(new Request.Builder()
+    // Make a call expecting a timeout reading the response body.
+    Call call1 = client.newCall(new Request.Builder()
         .url(server.url("/"))
         .build());
-    Response response = call.execute();
-
+    Response response1 = call1.execute();
     try {
-      response.body().string();
+      response1.body().string();
       fail("Should have timed out!");
     } catch (SocketTimeoutException expected) {
       assertEquals("timeout", expected.getMessage());
     }
+
+    // Confirm that a subsequent request on the same connection is not impacted.
+    Call call2 = client.newCall(new Request.Builder()
+        .url(server.url("/"))
+        .build());
+    Response response2 = call2.execute();
+    assertEquals(body, response2.body().string());
+
+    // Confirm that the connection was reused.
+    assertEquals(0, server.takeRequest().getSequenceNumber());
+    assertEquals(1, server.takeRequest().getSequenceNumber());
   }
 
   @Test public void connectionTimeout() throws Exception {
@@ -429,6 +465,10 @@
       fail();
     } catch (IOException expected) {
     }
+
+    // Confirm that the connection was reused.
+    assertEquals(0, server.takeRequest().getSequenceNumber());
+    assertEquals(1, server.takeRequest().getSequenceNumber());
   }
 
   @Test public void responsesAreCached() throws IOException {
@@ -760,6 +800,70 @@ private void noRecoveryFromErrorWithRetryDisabled(ErrorCode errorCode) throws Ex
     assertEquals("bar", pushedRequest.getHeader("foo"));
   }
 
+  @Test public void noDataFramesSentWithNullRequestBody() throws Exception {
+    server.enqueue(new MockResponse()
+        .setBody("ABC"));
+
+    SocketRecorder socketRecorder = new SocketRecorder();
+    client = client.newBuilder()
+        .sslSocketFactory(socketRecorder.sslSocketFactory(sslClient.socketFactory),
+            sslClient.trustManager)
+        .build();
+
+    Call call = client.newCall(new Request.Builder()
+        .url(server.url("/"))
+        .method("DELETE", null)
+        .build());
+    Response response = call.execute();
+    assertEquals("ABC", response.body().string());
+
+    // Replay the bytes written by the client to confirm no data frames were sent.
+    SocketRecorder.RecordedSocket recordedSocket = socketRecorder.takeSocket();
+    Buffer buffer = new Buffer();
+    buffer.write(recordedSocket.bytesWritten());
+
+    RecordingHandler handler = new RecordingHandler();
+    Http2Reader reader = new Http2Reader(buffer, false);
+    reader.readConnectionPreface(null);
+    while (reader.nextFrame(false, handler)) {
+    }
+
+    assertEquals(1, handler.headerFrameCount);
+    assertTrue(handler.dataFrames.isEmpty());
+  }
+
+  @Test public void emptyDataFrameSentWithEmptyBody() throws Exception {
+    server.enqueue(new MockResponse()
+        .setBody("ABC"));
+
+    SocketRecorder socketRecorder = new SocketRecorder();
+    client = client.newBuilder()
+        .sslSocketFactory(socketRecorder.sslSocketFactory(sslClient.socketFactory),
+            sslClient.trustManager)
+        .build();
+
+    Call call = client.newCall(new Request.Builder()
+        .url(server.url("/"))
+        .method("DELETE", Util.EMPTY_REQUEST)
+        .build());
+    Response response = call.execute();
+    assertEquals("ABC", response.body().string());
+
+    // Replay the bytes written by the client to confirm an empty data frame was sent.
+    SocketRecorder.RecordedSocket recordedSocket = socketRecorder.takeSocket();
+    Buffer buffer = new Buffer();
+    buffer.write(recordedSocket.bytesWritten());
+
+    RecordingHandler handler = new RecordingHandler();
+    Http2Reader reader = new Http2Reader(buffer, false);
+    reader.readConnectionPreface(null);
+    while (reader.nextFrame(false, handler)) {
+    }
+
+    assertEquals(1, handler.headerFrameCount);
+    assertEquals(Collections.singletonList(0), handler.dataFrames);
+  }
+
   /**
    * Push a setting that permits up to 2 concurrent streams, then make 3 concurrent requests and
    * confirm that the third concurrent request prepared a new connection.
@@ -874,6 +978,121 @@ private void noRecoveryFromErrorWithRetryDisabled(ErrorCode errorCode) throws Ex
     assertEquals(0, server.takeRequest().getSequenceNumber());
   }
 
+  /**
+   * We don't know if the connection will support HTTP/2 until after we've connected. When multiple
+   * connections are requested concurrently OkHttp will pessimistically connect multiple times, then
+   * close any unnecessary connections. This test confirms that behavior works as intended.
+   *
+   * <p>This test uses proxy tunnels to get a hook while a connection is being established.
+   */
+  @Test public void concurrentHttp2ConnectionsDeduplicated() throws Exception {
+    server.useHttps(sslClient.socketFactory, true);
+
+    // Force a fresh connection pool for the test.
+    client.connectionPool().evictAll();
+
+    final QueueDispatcher queueDispatcher = new QueueDispatcher();
+    queueDispatcher.enqueueResponse(new MockResponse()
+        .setSocketPolicy(SocketPolicy.UPGRADE_TO_SSL_AT_END)
+        .clearHeaders());
+    queueDispatcher.enqueueResponse(new MockResponse()
+        .setSocketPolicy(SocketPolicy.UPGRADE_TO_SSL_AT_END)
+        .clearHeaders());
+    queueDispatcher.enqueueResponse(new MockResponse()
+        .setBody("call2 response"));
+    queueDispatcher.enqueueResponse(new MockResponse()
+        .setBody("call1 response"));
+
+    // We use a re-entrant dispatcher to initiate one HTTPS connection while the other is in flight.
+    server.setDispatcher(new Dispatcher() {
+      int requestCount;
+
+      @Override public MockResponse dispatch(RecordedRequest request) throws InterruptedException {
+        MockResponse result = queueDispatcher.dispatch(request);
+
+        requestCount++;
+        if (requestCount == 1) {
+          // Before handling call1's CONNECT we do all of call2. This part re-entrant!
+          try {
+            Call call2 = client.newCall(new Request.Builder()
+                .url("https://android.com/call2")
+                .build());
+            Response response2 = call2.execute();
+            assertEquals("call2 response", response2.body().string());
+          } catch (IOException e) {
+            throw new RuntimeException(e);
+          }
+        }
+
+        return result;
+      }
+
+      @Override public MockResponse peek() {
+        return queueDispatcher.peek();
+      }
+
+      @Override public void shutdown() {
+        queueDispatcher.shutdown();
+      }
+    });
+
+    client = client.newBuilder()
+        .proxy(server.toProxyAddress())
+        .build();
+
+    Call call1 = client.newCall(new Request.Builder()
+        .url("https://android.com/call1")
+        .build());
+    Response response2 = call1.execute();
+    assertEquals("call1 response", response2.body().string());
+
+    RecordedRequest call1Connect = server.takeRequest();
+    assertEquals("CONNECT", call1Connect.getMethod());
+    assertEquals(0, call1Connect.getSequenceNumber());
+
+    RecordedRequest call2Connect = server.takeRequest();
+    assertEquals("CONNECT", call2Connect.getMethod());
+    assertEquals(0, call2Connect.getSequenceNumber());
+
+    RecordedRequest call2Get = server.takeRequest();
+    assertEquals("GET", call2Get.getMethod());
+    assertEquals("/call2", call2Get.getPath());
+    assertEquals(0, call2Get.getSequenceNumber());
+
+    RecordedRequest call1Get = server.takeRequest();
+    assertEquals("GET", call1Get.getMethod());
+    assertEquals("/call1", call1Get.getPath());
+    assertEquals(1, call1Get.getSequenceNumber());
+
+    assertEquals(1, client.connectionPool().connectionCount());
+  }
+
+  /** https://github.com/square/okhttp/issues/3103 */
+  @Test public void domainFronting() throws Exception {
+    client = client.newBuilder()
+        .addNetworkInterceptor(new Interceptor() {
+          @Override public Response intercept(Chain chain) throws IOException {
+            Request request = chain.request().newBuilder()
+                .header("Host", "privateobject.com")
+                .build();
+            return chain.proceed(request);
+          }
+        })
+        .build();
+
+    server.enqueue(new MockResponse());
+
+    Call call = client.newCall(new Request.Builder()
+        .url(server.url("/"))
+        .build());
+
+    Response response = call.execute();
+    assertEquals("", response.body().string());
+
+    RecordedRequest recordedRequest = server.takeRequest();
+    assertEquals("privateobject.com", recordedRequest.getHeader(":authority"));
+  }
+
   public Buffer gzip(String bytes) throws IOException {
     Buffer bytesOut = new Buffer();
     BufferedSink sink = Okio.buffer(new GzipSink(bytesOut));
@@ -904,4 +1123,28 @@ public AsyncRequest(String path, CountDownLatch countDownLatch) {
       }
     }
   }
+
+  static final class RecordingHandler extends BaseTestHandler {
+    int headerFrameCount;
+    final List<Integer> dataFrames = new ArrayList<>();
+
+    @Override public void settings(boolean clearPrevious, Settings settings) {
+    }
+
+    @Override public void ackSettings() {
+    }
+
+    @Override public void windowUpdate(int streamId, long windowSizeIncrement) {
+    }
+
+    @Override public void data(boolean inFinished, int streamId, BufferedSource source, int length)
+        throws IOException {
+      dataFrames.add(length);
+    }
+
+    @Override public void headers(boolean inFinished, int streamId, int associatedStreamId,
+        List<Header> headerBlock) {
+      headerFrameCount++;
+    }
+  }
 }
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/http2/MockHttp2Peer.java b/okhttp-tests/src/test/java/okhttp3/internal/http2/MockHttp2Peer.java
index 9a5b946f7f..fe5f82fd4a 100644
--- a/okhttp-tests/src/test/java/okhttp3/internal/http2/MockHttp2Peer.java
+++ b/okhttp-tests/src/test/java/okhttp3/internal/http2/MockHttp2Peer.java
@@ -171,7 +171,7 @@ private void readAndWriteFrames() throws IOException {
       } else {
         // read a frame
         InFrame inFrame = new InFrame(i, reader);
-        reader.nextFrame(inFrame);
+        reader.nextFrame(false, inFrame);
         inFrames.add(inFrame);
       }
     }
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/io/FaultyFileSystem.java b/okhttp-tests/src/test/java/okhttp3/internal/io/FaultyFileSystem.java
index 40aca93adb..bc0263d830 100644
--- a/okhttp-tests/src/test/java/okhttp3/internal/io/FaultyFileSystem.java
+++ b/okhttp-tests/src/test/java/okhttp3/internal/io/FaultyFileSystem.java
@@ -90,6 +90,7 @@ public void setFaultyRename(File file, boolean faulty) {
   }
 
   @Override public void deleteContents(File directory) throws IOException {
+    if (deleteFaults.contains(directory)) throw new IOException("boom!");
     delegate.deleteContents(directory);
   }
 
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/platform/OptionalMethodTest.java b/okhttp-tests/src/test/java/okhttp3/internal/platform/OptionalMethodTest.java
index 82ac18fc14..7e249bd61f 100644
--- a/okhttp-tests/src/test/java/okhttp3/internal/platform/OptionalMethodTest.java
+++ b/okhttp-tests/src/test/java/okhttp3/internal/platform/OptionalMethodTest.java
@@ -19,6 +19,7 @@
 
 import java.io.IOException;
 import java.lang.reflect.InvocationTargetException;
+import org.junit.Ignore;
 import org.junit.Test;
 
 import static org.junit.Assert.assertEquals;
@@ -299,6 +300,7 @@ public void invokeOptionalWithException() throws Exception {
   }
 
   @Test
+  @Ignore("Despite returning false for isSupported, invocation actually succeeds.")
   public void invokeOptionalNonPublic() throws Exception {
     SubClass2 subClass2 = new SubClass2();
     assertFalse(NON_PUBLIC.isSupported(subClass2));
@@ -309,9 +311,10 @@ public void invokeOptionalNonPublic() throws Exception {
       OptionalMethod<T> optionalMethod, T base, Object... args) throws Exception {
     try {
       optionalMethod.invoke(base, args);
-      fail();
     } catch (Error expected) {
+      return;
     }
+    fail();
   }
 
   private static <T> void assertIllegalArgumentExceptionOnInvoke(
@@ -327,9 +330,10 @@ public void invokeOptionalNonPublic() throws Exception {
       OptionalMethod<T> optionalMethod, T base, Object... args) throws Exception {
     try {
       optionalMethod.invokeOptional(base, args);
-      fail();
     } catch (Error expected) {
+      return;
     }
+    fail();
   }
 
   private static <T> void assertIllegalArgumentExceptionOnInvokeOptional(
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/publicsuffix/PublicSuffixDatabaseTest.java b/okhttp-tests/src/test/java/okhttp3/internal/publicsuffix/PublicSuffixDatabaseTest.java
new file mode 100644
index 0000000000..9e9ec71dd8
--- /dev/null
+++ b/okhttp-tests/src/test/java/okhttp3/internal/publicsuffix/PublicSuffixDatabaseTest.java
@@ -0,0 +1,285 @@
+/*
+ * Copyright (C) 2017 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.internal.publicsuffix;
+
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.InterruptedIOException;
+import okhttp3.internal.Util;
+import okio.Buffer;
+import okio.BufferedSource;
+import okio.GzipSource;
+import okio.Okio;
+import org.junit.Test;
+
+import static okhttp3.internal.publicsuffix.PublicSuffixDatabase.PUBLIC_SUFFIX_RESOURCE;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertNull;
+import static org.junit.Assert.assertTrue;
+import static org.junit.Assert.fail;
+
+public final class PublicSuffixDatabaseTest {
+  private final PublicSuffixDatabase publicSuffixDatabase = new PublicSuffixDatabase();
+
+  @Test public void longestMatchWins() {
+    Buffer buffer = new Buffer()
+        .writeUtf8("com\n")
+        .writeUtf8("my.square.com\n")
+        .writeUtf8("square.com\n");
+    publicSuffixDatabase.setListBytes(buffer.readByteArray(), new byte[]{});
+
+    assertEquals("example.com", publicSuffixDatabase.getEffectiveTldPlusOne("example.com"));
+    assertEquals("example.com", publicSuffixDatabase.getEffectiveTldPlusOne("foo.example.com"));
+    assertEquals("bar.square.com",
+        publicSuffixDatabase.getEffectiveTldPlusOne("foo.bar.square.com"));
+    assertEquals("foo.my.square.com",
+        publicSuffixDatabase.getEffectiveTldPlusOne("foo.my.square.com"));
+  }
+
+  @Test public void wildcardMatch() {
+    Buffer buffer = new Buffer()
+        .writeUtf8("*.square.com\n")
+        .writeUtf8("com\n")
+        .writeUtf8("example.com\n");
+    publicSuffixDatabase.setListBytes(buffer.readByteArray(), new byte[]{});
+
+    assertNull(publicSuffixDatabase.getEffectiveTldPlusOne("my.square.com"));
+    assertEquals("foo.my.square.com",
+        publicSuffixDatabase.getEffectiveTldPlusOne("foo.my.square.com"));
+    assertEquals("foo.my.square.com",
+        publicSuffixDatabase.getEffectiveTldPlusOne("bar.foo.my.square.com"));
+  }
+
+  @Test public void boundarySearches() {
+    Buffer buffer = new Buffer()
+        .writeUtf8("bbb\n")
+        .writeUtf8("ddd\n")
+        .writeUtf8("fff\n");
+    publicSuffixDatabase.setListBytes(buffer.readByteArray(), new byte[]{});
+
+    assertNull(publicSuffixDatabase.getEffectiveTldPlusOne("aaa"));
+    assertNull(publicSuffixDatabase.getEffectiveTldPlusOne("ggg"));
+    assertNull(publicSuffixDatabase.getEffectiveTldPlusOne("ccc"));
+    assertNull(publicSuffixDatabase.getEffectiveTldPlusOne("eee"));
+  }
+
+  @Test public void exceptionRule() {
+    Buffer exception = new Buffer()
+        .writeUtf8("my.square.jp\n");
+    Buffer buffer = new Buffer()
+        .writeUtf8("*.jp\n")
+        .writeUtf8("*.square.jp\n")
+        .writeUtf8("example.com\n")
+        .writeUtf8("square.com\n");
+    publicSuffixDatabase.setListBytes(buffer.readByteArray(), exception.readByteArray());
+
+    assertEquals("my.square.jp", publicSuffixDatabase.getEffectiveTldPlusOne("my.square.jp"));
+    assertEquals("my.square.jp", publicSuffixDatabase.getEffectiveTldPlusOne("foo.my.square.jp"));
+    assertNull(publicSuffixDatabase.getEffectiveTldPlusOne("my1.square.jp"));
+  }
+
+  @Test public void noEffectiveTldPlusOne() {
+    Buffer exception = new Buffer()
+        .writeUtf8("my.square.jp\n");
+    Buffer buffer = new Buffer()
+        .writeUtf8("*.jp\n")
+        .writeUtf8("*.square.jp\n")
+        .writeUtf8("example.com\n")
+        .writeUtf8("square.com\n");
+    publicSuffixDatabase.setListBytes(buffer.readByteArray(), exception.readByteArray());
+
+    assertNull(publicSuffixDatabase.getEffectiveTldPlusOne("example.com"));
+    assertNull(publicSuffixDatabase.getEffectiveTldPlusOne("foo.square.jp"));
+  }
+
+  @Test public void allPublicSuffixes() throws IOException {
+    InputStream resource = PublicSuffixDatabaseTest.class
+        .getResourceAsStream(PUBLIC_SUFFIX_RESOURCE);
+    BufferedSource source = Okio.buffer(new GzipSource(Okio.source(resource)));
+    int length = source.readInt();
+    Buffer buffer = new Buffer();
+    buffer.write(source, length);
+    resource.close();
+
+    while (!buffer.exhausted()) {
+      String publicSuffix = buffer.readUtf8LineStrict();
+      if (publicSuffix.contains("*")) {
+        // A wildcard rule, let's replace the wildcard with a value.
+        publicSuffix = publicSuffix.replaceAll("\\*", "square");
+      }
+      assertNull(publicSuffixDatabase.getEffectiveTldPlusOne(publicSuffix));
+
+      String test = "foobar." + publicSuffix;
+      assertEquals(test, publicSuffixDatabase.getEffectiveTldPlusOne(test));
+    }
+  }
+
+  @Test public void publicSuffixExceptions() throws IOException {
+    InputStream resource = PublicSuffixDatabaseTest.class
+        .getResourceAsStream(PUBLIC_SUFFIX_RESOURCE);
+    BufferedSource source = Okio.buffer(new GzipSource(Okio.source(resource)));
+    int length = source.readInt();
+    source.skip(length);
+
+    length = source.readInt();
+    Buffer buffer = new Buffer();
+    buffer.write(source, length);
+    resource.close();
+
+    while (!buffer.exhausted()) {
+      String exception = buffer.readUtf8LineStrict();
+      assertEquals(exception, publicSuffixDatabase.getEffectiveTldPlusOne(exception));
+
+      String test = "foobar." + exception;
+      assertEquals(exception, publicSuffixDatabase.getEffectiveTldPlusOne(test));
+    }
+  }
+
+  @Test public void threadIsInterruptedOnFirstRead() {
+    Thread.currentThread().interrupt();
+    try {
+      String result = publicSuffixDatabase.getEffectiveTldPlusOne("squareup.com");
+      assertEquals("squareup.com", result);
+    } finally {
+      assertTrue(Thread.interrupted());
+    }
+  }
+
+  /**
+   * These tests are provided by <a href="https://publicsuffix.org/list/">publicsuffix.org</a>.
+   */
+  @Test public void publicSuffixDotOrgTestCases() {
+    // Any copyright is dedicated to the Public Domain.
+    // https://creativecommons.org/publicdomain/zero/1.0/
+
+    // null input.
+    checkPublicSuffix(null, null);
+    // Mixed case.
+    checkPublicSuffix("COM", null);
+    checkPublicSuffix("example.COM", "example.com");
+    checkPublicSuffix("WwW.example.COM", "example.com");
+    // Leading dot.
+    checkPublicSuffix(".com", null);
+    checkPublicSuffix(".example", null);
+    checkPublicSuffix(".example.com", null);
+    checkPublicSuffix(".example.example", null);
+    // Unlisted TLD.
+    checkPublicSuffix("example", null);
+    checkPublicSuffix("example.example", "example.example");
+    checkPublicSuffix("b.example.example", "example.example");
+    checkPublicSuffix("a.b.example.example", "example.example");
+    // Listed, but non-Internet, TLD.
+    //checkPublicSuffix("local", null);
+    //checkPublicSuffix("example.local", null);
+    //checkPublicSuffix("b.example.local", null);
+    //checkPublicSuffix("a.b.example.local", null);
+    // TLD with only 1 rule.
+    checkPublicSuffix("biz", null);
+    checkPublicSuffix("domain.biz", "domain.biz");
+    checkPublicSuffix("b.domain.biz", "domain.biz");
+    checkPublicSuffix("a.b.domain.biz", "domain.biz");
+    // TLD with some 2-level rules.
+    checkPublicSuffix("com", null);
+    checkPublicSuffix("example.com", "example.com");
+    checkPublicSuffix("b.example.com", "example.com");
+    checkPublicSuffix("a.b.example.com", "example.com");
+    checkPublicSuffix("uk.com", null);
+    checkPublicSuffix("example.uk.com", "example.uk.com");
+    checkPublicSuffix("b.example.uk.com", "example.uk.com");
+    checkPublicSuffix("a.b.example.uk.com", "example.uk.com");
+    checkPublicSuffix("test.ac", "test.ac");
+    // TLD with only 1 (wildcard) rule.
+    checkPublicSuffix("mm", null);
+    checkPublicSuffix("c.mm", null);
+    checkPublicSuffix("b.c.mm", "b.c.mm");
+    checkPublicSuffix("a.b.c.mm", "b.c.mm");
+    // More complex TLD.
+    checkPublicSuffix("jp", null);
+    checkPublicSuffix("test.jp", "test.jp");
+    checkPublicSuffix("www.test.jp", "test.jp");
+    checkPublicSuffix("ac.jp", null);
+    checkPublicSuffix("test.ac.jp", "test.ac.jp");
+    checkPublicSuffix("www.test.ac.jp", "test.ac.jp");
+    checkPublicSuffix("kyoto.jp", null);
+    checkPublicSuffix("test.kyoto.jp", "test.kyoto.jp");
+    checkPublicSuffix("ide.kyoto.jp", null);
+    checkPublicSuffix("b.ide.kyoto.jp", "b.ide.kyoto.jp");
+    checkPublicSuffix("a.b.ide.kyoto.jp", "b.ide.kyoto.jp");
+    checkPublicSuffix("c.kobe.jp", null);
+    checkPublicSuffix("b.c.kobe.jp", "b.c.kobe.jp");
+    checkPublicSuffix("a.b.c.kobe.jp", "b.c.kobe.jp");
+    checkPublicSuffix("city.kobe.jp", "city.kobe.jp");
+    checkPublicSuffix("www.city.kobe.jp", "city.kobe.jp");
+    // TLD with a wildcard rule and exceptions.
+    checkPublicSuffix("ck", null);
+    checkPublicSuffix("test.ck", null);
+    checkPublicSuffix("b.test.ck", "b.test.ck");
+    checkPublicSuffix("a.b.test.ck", "b.test.ck");
+    checkPublicSuffix("www.ck", "www.ck");
+    checkPublicSuffix("www.www.ck", "www.ck");
+    // US K12.
+    checkPublicSuffix("us", null);
+    checkPublicSuffix("test.us", "test.us");
+    checkPublicSuffix("www.test.us", "test.us");
+    checkPublicSuffix("ak.us", null);
+    checkPublicSuffix("test.ak.us", "test.ak.us");
+    checkPublicSuffix("www.test.ak.us", "test.ak.us");
+    checkPublicSuffix("k12.ak.us", null);
+    checkPublicSuffix("test.k12.ak.us", "test.k12.ak.us");
+    checkPublicSuffix("www.test.k12.ak.us", "test.k12.ak.us");
+    // IDN labels.
+    checkPublicSuffix("食狮.com.cn", "食狮.com.cn");
+    checkPublicSuffix("食狮.公司.cn", "食狮.公司.cn");
+    checkPublicSuffix("www.食狮.公司.cn", "食狮.公司.cn");
+    checkPublicSuffix("shishi.公司.cn", "shishi.公司.cn");
+    checkPublicSuffix("公司.cn", null);
+    checkPublicSuffix("食狮.中国", "食狮.中国");
+    checkPublicSuffix("www.食狮.中国", "食狮.中国");
+    checkPublicSuffix("shishi.中国", "shishi.中国");
+    checkPublicSuffix("中国", null);
+    // Same as above, but punycoded.
+    checkPublicSuffix("xn--85x722f.com.cn", "xn--85x722f.com.cn");
+    checkPublicSuffix("xn--85x722f.xn--55qx5d.cn", "xn--85x722f.xn--55qx5d.cn");
+    checkPublicSuffix("www.xn--85x722f.xn--55qx5d.cn", "xn--85x722f.xn--55qx5d.cn");
+    checkPublicSuffix("shishi.xn--55qx5d.cn", "shishi.xn--55qx5d.cn");
+    checkPublicSuffix("xn--55qx5d.cn", null);
+    checkPublicSuffix("xn--85x722f.xn--fiqs8s", "xn--85x722f.xn--fiqs8s");
+    checkPublicSuffix("www.xn--85x722f.xn--fiqs8s", "xn--85x722f.xn--fiqs8s");
+    checkPublicSuffix("shishi.xn--fiqs8s", "shishi.xn--fiqs8s");
+    checkPublicSuffix("xn--fiqs8s", null);
+  }
+
+  private void checkPublicSuffix(String domain, String registrablePart) {
+    if (domain == null) {
+      try {
+        publicSuffixDatabase.getEffectiveTldPlusOne(null);
+        fail();
+      } catch (NullPointerException expected) {
+      }
+      return;
+    }
+
+    String canonicalDomain = Util.domainToAscii(domain);
+    if (canonicalDomain == null) return;
+
+    String result = publicSuffixDatabase.getEffectiveTldPlusOne(canonicalDomain);
+    if (registrablePart == null) {
+      assertNull(result);
+    } else {
+      assertEquals(Util.domainToAscii(registrablePart), result);
+    }
+  }
+}
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/tls/ClientAuthTest.java b/okhttp-tests/src/test/java/okhttp3/internal/tls/ClientAuthTest.java
index 6adbb51b69..2ec0d6494d 100644
--- a/okhttp-tests/src/test/java/okhttp3/internal/tls/ClientAuthTest.java
+++ b/okhttp-tests/src/test/java/okhttp3/internal/tls/ClientAuthTest.java
@@ -16,6 +16,7 @@
 package okhttp3.internal.tls;
 
 import java.io.IOException;
+import java.net.SocketException;
 import java.security.GeneralSecurityException;
 import javax.net.ssl.SSLHandshakeException;
 import javax.net.ssl.SSLSocket;
@@ -40,7 +41,7 @@
   @Rule public final MockWebServer server = new MockWebServer();
 
   public enum ClientAuth {
-    NONE, WANTS, NEEDS;
+    NONE, WANTS, NEEDS
   }
 
   private HeldCertificate serverRootCa;
@@ -51,7 +52,7 @@
   private HeldCertificate clientCert;
 
   @Before
-  public void initialise() throws GeneralSecurityException {
+  public void setUp() throws GeneralSecurityException {
     serverRootCa = new HeldCertificate.Builder()
         .serialNumber("1")
         .ca(3)
@@ -162,6 +163,8 @@ public void initialise() throws GeneralSecurityException {
       call.execute();
       fail();
     } catch (SSLHandshakeException expected) {
+    } catch (SocketException expected) {
+      // JDK 9
     }
   }
 
@@ -183,6 +186,8 @@ public void initialise() throws GeneralSecurityException {
       call.execute();
       fail();
     } catch (SSLHandshakeException expected) {
+    } catch (SocketException expected) {
+      // JDK 9
     }
   }
 
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/tls/DistinguishedNameParserTest.java b/okhttp-tests/src/test/java/okhttp3/internal/tls/DistinguishedNameParserTest.java
new file mode 100644
index 0000000000..09c22b8594
--- /dev/null
+++ b/okhttp-tests/src/test/java/okhttp3/internal/tls/DistinguishedNameParserTest.java
@@ -0,0 +1,134 @@
+/*
+ * Copyright (C) 2010 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.internal.tls;
+
+
+import javax.security.auth.x500.X500Principal;
+
+import org.junit.Test;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.fail;
+
+public final class DistinguishedNameParserTest {
+  @Test public void regularCases() {
+    assertCn("xxx", "ou=xxx,cn=xxx");
+    assertCn("yyy", "ou=xxx+cn=yyy,cn=zzz+cn=abc");
+    assertCn("a", "cn=a,cn=b");
+    assertCn("a   c", "cn=a   c,cn=b");
+    assertCn("Cc", "cn=Cc,cn=Bb,cn=Aa");
+    assertCn("imap.gmail.com", "cn=imap.gmail.com");
+    assertCn("c", "l=\"abcn=a,b\", cn=c");
+    assertCn("c", "l=\"abcn=a,b\", cn=c");
+    assertCn("c", "l=\"abcn=a,b\", cn= c");
+    assertCn("a b", "cn=a b");
+    assertCn("a b", "cn   =a b");
+    assertCn("a b", "Cn=a b");
+    assertCn("a b", "cN=a b");
+    assertCn("a b", "CN=a b");
+    assertCn("a#b", "cn=a#b");
+    assertCn("a", "cn=#130161");
+    assertCn("p", "l=q\t+cn=p");
+    assertCn("p", "l=q\n+cn=p");
+    assertCn("p", "l=q\n,cn=p");
+    assertCn("p", "l=,cn=p");
+    assertCn("\tp", "l=\tq\n,cn=\tp");
+  }
+
+  @Test public void emptyValues() {
+    assertCn(null, "");
+    assertCn(null, "ou=xxx");
+    assertCn("", "l=,cn=+cn=q");
+    assertCn("", "l=,cn=,cn=q");
+    assertCn(null, "l=,cn=");
+    assertCn("q", "l=,cn=q,cn=   ");
+    assertCn("q", "l=,cn=q  ,cn=   ");
+    assertCn(null, "l=,cn=\"\"");
+    assertCn("", "l=,cn=  ,cn=  ");
+    assertCn("", "l=,cn=,cn=  ,cn=  ");
+  }
+
+  @Test public void escapedChars() {
+    assertCn(",", "cn=\\,");
+    assertCn("#", "cn=\\#");
+    assertCn("+", "cn=\\+");
+    assertCn("\"", "cn=\\\"");
+    assertCn("\\", "cn=\\\\");
+    assertCn("<", "cn=\\<");
+    assertCn(">", "cn=\\>");
+    assertCn(";", "cn=\\;");
+    assertCn("+", "cn=\\+");
+    assertCn("+", "cn=\"\\+\"");
+    assertCn(",", "cn=\"\\,\"");
+    assertCn("a =", "cn= a =");
+    assertCn("=", "cn==");
+  }
+
+  @Test public void whitespace() {
+    assertCn("p", "cn= p");
+    assertCn("p", "cn=\np");
+    assertCn("\tp", "cn=\tp");
+  }
+
+  @Test public void withOid() {
+    assertCn("a", "2.5.4.3=a,ou=xxx");
+    assertCn("a", "2.5.4.3=\" a \",ou=xxx");
+    assertCn("b", "2.5.5.3=a,ou=xxx,cn=b");
+  }
+
+  @Test public void quotedStrings() {
+    assertCn("\" a ,=<>#;", "cn=\"\\\" a ,=<>#;\"");
+    assertCn("abc,def", "cn=abc\\,def");
+    assertCn("\" a ,=<>#;", "cn=\"\\\" a ,\\=<>\\#;\"");
+  }
+
+  @Test public void utf8() {
+    assertCn("\u004c\u0075\u010d\u0069\u0107", "cn=\"Lu\\C4\\8Di\\C4\\87\"");
+    assertCn("\u004c\u0075\u010d\u0069\u0107", "cn=Lu\\C4\\8Di\\C4\\87");
+    assertCn("\u004c\u0075\u010d\u0069\u0107", "cn=Lu\\C4\\8di\\c4\\87");
+    assertCn("\u004c\u0075\u010d\u0069\u0107", "cn=\"Lu\\C4\\8di\\c4\\87\"");
+    assertCn("\u004c\u0075\u010d\u0069\u0107", "cn=\u004c\u0075\u010d\u0069\u0107");
+    // \63=c
+    expectExceptionInPrincipal("\\63n=ab");
+    expectExceptionInPrincipal("cn=\\a");
+  }
+
+  @Test public void trailingWhitespace() {
+    assertCn("a  b", "ou=a, cn=  a  b  ,o=x");
+    assertCn("a  b", "cn=\"  a  b  \" ,o=x");
+    assertCn("a", "cn=a   ,cn=b");
+    assertCn("", "l=,cn=\"  \",cn=\"  \"");
+  }
+
+  /**
+   * @param expected the value of the first "cn=" argument in {@code dn},
+   *                 or null if none is expected
+   */
+  private void assertCn(String expected, String dn) {
+    X500Principal principal = new X500Principal(dn);
+    DistinguishedNameParser parser = new DistinguishedNameParser(principal);
+    assertEquals(dn, expected, parser.findMostSpecific("cn"));
+  }
+
+  private void expectExceptionInPrincipal(String dn) {
+    try {
+      new X500Principal(dn);
+      fail("Expected " + IllegalArgumentException.class.getName()
+          + " because of incorrect input name");
+    } catch (IllegalArgumentException expected) {
+    }
+  }
+}
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/ws/RealWebSocketTest.java b/okhttp-tests/src/test/java/okhttp3/internal/ws/RealWebSocketTest.java
index 8ffa80214b..f3564997f2 100644
--- a/okhttp-tests/src/test/java/okhttp3/internal/ws/RealWebSocketTest.java
+++ b/okhttp-tests/src/test/java/okhttp3/internal/ws/RealWebSocketTest.java
@@ -19,10 +19,10 @@
 import java.io.IOException;
 import java.net.ProtocolException;
 import java.util.Random;
+import java.util.concurrent.TimeUnit;
 import okhttp3.Protocol;
 import okhttp3.Request;
 import okhttp3.Response;
-import okio.BufferedSink;
 import okio.ByteString;
 import okio.Okio;
 import okio.Pipe;
@@ -31,6 +31,7 @@
 import org.junit.Ignore;
 import org.junit.Test;
 
+import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertFalse;
 import static org.junit.Assert.assertTrue;
 
@@ -39,273 +40,301 @@
   // zero effect on the behavior of the WebSocket API which is why tests are only written once
   // from the perspective of a single peer.
 
-  private RealWebSocket client;
-  private boolean clientConnectionCloseThrows;
-  private boolean clientConnectionClosed;
+  private final Random random = new Random(0);
   private final Pipe client2Server = new Pipe(1024L);
-  private final BufferedSink client2ServerSink = Okio.buffer(client2Server.sink());
-  private final WebSocketRecorder clientListener = new WebSocketRecorder("client");
-
-  private RealWebSocket server;
-  private boolean serverConnectionClosed;
   private final Pipe server2client = new Pipe(1024L);
-  private final BufferedSink server2clientSink = Okio.buffer(server2client.sink());
-  private final WebSocketRecorder serverListener = new WebSocketRecorder("server");
+
+  private TestStreams client = new TestStreams(true, server2client, client2Server);
+  private TestStreams server = new TestStreams(false, client2Server, server2client);
 
   @Before public void setUp() throws IOException {
-    Random random = new Random(0);
-    String url = "http://example.com/websocket";
-    final Response response = new Response.Builder()
-        .code(101)
-        .request(new Request.Builder().url(url).build())
-        .protocol(Protocol.HTTP_1_1)
-        .build();
-
-    client = new RealWebSocket(response.request(), clientListener, random);
-    client.initReaderAndWriter(new RealWebSocket.Streams(
-        true, Okio.buffer(server2client.source()), client2ServerSink) {
-      @Override public void close() throws IOException {
-        source.close();
-        sink.close();
-        if (clientConnectionClosed) {
-          throw new AssertionError("Already closed");
-        }
-        clientConnectionClosed = true;
-
-        if (clientConnectionCloseThrows) {
-          throw new RuntimeException("Oops!");
-        }
-      }
-    });
-
-    server = new RealWebSocket(response.request(), serverListener, random);
-    server.initReaderAndWriter(new RealWebSocket.Streams(
-        false, Okio.buffer(client2Server.source()), server2clientSink) {
-      @Override public void close() throws IOException {
-        source.close();
-        sink.close();
-        if (serverConnectionClosed) {
-          throw new AssertionError("Already closed");
-        }
-        serverConnectionClosed = true;
-      }
-    });
+    client.initWebSocket(random, 0);
+    server.initWebSocket(random, 0);
   }
 
-  @After public void tearDown() {
-    clientListener.assertExhausted();
-    serverListener.assertExhausted();
+  @After public void tearDown() throws Exception {
+    client.listener.assertExhausted();
+    server.listener.assertExhausted();
+    server.source.close();
+    client.source.close();
+    server.webSocket.tearDown();
+    client.webSocket.tearDown();
   }
 
   @Test public void close() throws IOException {
-    client.close(1000, "Hello!");
+    client.webSocket.close(1000, "Hello!");
     assertFalse(server.processNextFrame()); // This will trigger a close response.
-    serverListener.assertClosing(1000, "Hello!");
-    server.close(1000, "Goodbye!");
+    server.listener.assertClosing(1000, "Hello!");
+    server.webSocket.close(1000, "Goodbye!");
     assertFalse(client.processNextFrame());
-    clientListener.assertClosing(1000, "Goodbye!");
-    serverListener.assertClosed(1000, "Hello!");
-    clientListener.assertClosed(1000, "Goodbye!");
+    client.listener.assertClosing(1000, "Goodbye!");
+    server.listener.assertClosed(1000, "Hello!");
+    client.listener.assertClosed(1000, "Goodbye!");
   }
 
   @Test public void clientCloseThenMethodsReturnFalse() throws IOException {
-    client.close(1000, "Hello!");
+    client.webSocket.close(1000, "Hello!");
 
-    assertFalse(client.close(1000, "Hello!"));
-    assertFalse(client.send("Hello!"));
+    assertFalse(client.webSocket.close(1000, "Hello!"));
+    assertFalse(client.webSocket.send("Hello!"));
   }
 
   @Test public void afterSocketClosedPingFailsWebSocket() throws IOException {
     client2Server.source().close();
-    client.pong(ByteString.encodeUtf8("Ping!"));
-    clientListener.assertFailure(IOException.class, "source is closed");
+    client.webSocket.pong(ByteString.encodeUtf8("Ping!"));
+    client.listener.assertFailure(IOException.class, "source is closed");
 
-    assertFalse(client.send("Hello!"));
+    assertFalse(client.webSocket.send("Hello!"));
   }
 
   @Test public void socketClosedDuringMessageKillsWebSocket() throws IOException {
     client2Server.source().close();
 
-    assertTrue(client.send("Hello!"));
-    clientListener.assertFailure(IOException.class, "source is closed");
+    assertTrue(client.webSocket.send("Hello!"));
+    client.listener.assertFailure(IOException.class, "source is closed");
 
     // A failed write prevents further use of the WebSocket instance.
-    assertFalse(client.send("Hello!"));
-    assertFalse(client.pong(ByteString.encodeUtf8("Ping!")));
+    assertFalse(client.webSocket.send("Hello!"));
+    assertFalse(client.webSocket.pong(ByteString.encodeUtf8("Ping!")));
   }
 
   @Test public void serverCloseThenWritingPingSucceeds() throws IOException {
-    server.close(1000, "Hello!");
+    server.webSocket.close(1000, "Hello!");
     client.processNextFrame();
-    clientListener.assertClosing(1000, "Hello!");
+    client.listener.assertClosing(1000, "Hello!");
 
-    assertTrue(client.pong(ByteString.encodeUtf8("Pong?")));
+    assertTrue(client.webSocket.pong(ByteString.encodeUtf8("Pong?")));
   }
 
   @Test public void clientCanWriteMessagesAfterServerClose() throws IOException {
-    server.close(1000, "Hello!");
+    server.webSocket.close(1000, "Hello!");
     client.processNextFrame();
-    clientListener.assertClosing(1000, "Hello!");
+    client.listener.assertClosing(1000, "Hello!");
 
-    assertTrue(client.send("Hi!"));
+    assertTrue(client.webSocket.send("Hi!"));
     server.processNextFrame();
-    serverListener.assertTextMessage("Hi!");
+    server.listener.assertTextMessage("Hi!");
   }
 
   @Test public void serverCloseThenClientClose() throws IOException {
-    server.close(1000, "Hello!");
+    server.webSocket.close(1000, "Hello!");
     client.processNextFrame();
-    clientListener.assertClosing(1000, "Hello!");
-    assertTrue(client.close(1000, "Bye!"));
+    client.listener.assertClosing(1000, "Hello!");
+    assertTrue(client.webSocket.close(1000, "Bye!"));
   }
 
   @Test public void emptyCloseInitiatesShutdown() throws IOException {
-    server2clientSink.write(ByteString.decodeHex("8800")).emit(); // Close without code.
+    server.sink.write(ByteString.decodeHex("8800")).emit(); // Close without code.
     client.processNextFrame();
-    clientListener.assertClosing(1005, "");
+    client.listener.assertClosing(1005, "");
 
-    assertTrue(client.close(1000, "Bye!"));
+    assertTrue(client.webSocket.close(1000, "Bye!"));
     server.processNextFrame();
-    serverListener.assertClosing(1000, "Bye!");
+    server.listener.assertClosing(1000, "Bye!");
 
-    clientListener.assertClosed(1005, "");
+    client.listener.assertClosed(1005, "");
   }
 
   @Test public void clientCloseClosesConnection() throws IOException {
-    client.close(1000, "Hello!");
-    assertFalse(clientConnectionClosed);
+    client.webSocket.close(1000, "Hello!");
+    assertFalse(client.closed);
     server.processNextFrame(); // Read client closing, send server close.
-    serverListener.assertClosing(1000, "Hello!");
+    server.listener.assertClosing(1000, "Hello!");
 
-    server.close(1000, "Goodbye!");
+    server.webSocket.close(1000, "Goodbye!");
     client.processNextFrame(); // Read server closing, close connection.
-    assertTrue(clientConnectionClosed);
-    clientListener.assertClosing(1000, "Goodbye!");
+    assertTrue(client.closed);
+    client.listener.assertClosing(1000, "Goodbye!");
 
     // Server and client both finished closing, connection is closed.
-    serverListener.assertClosed(1000, "Hello!");
-    clientListener.assertClosed(1000, "Goodbye!");
+    server.listener.assertClosed(1000, "Hello!");
+    client.listener.assertClosed(1000, "Goodbye!");
   }
 
   @Test public void serverCloseClosesConnection() throws IOException {
-    server.close(1000, "Hello!");
+    server.webSocket.close(1000, "Hello!");
 
     client.processNextFrame(); // Read server close, send client close, close connection.
-    assertFalse(clientConnectionClosed);
-    clientListener.assertClosing(1000, "Hello!");
+    assertFalse(client.closed);
+    client.listener.assertClosing(1000, "Hello!");
 
-    client.close(1000, "Hello!");
+    client.webSocket.close(1000, "Hello!");
     server.processNextFrame();
-    serverListener.assertClosing(1000, "Hello!");
+    server.listener.assertClosing(1000, "Hello!");
 
-    clientListener.assertClosed(1000, "Hello!");
-    serverListener.assertClosed(1000, "Hello!");
+    client.listener.assertClosed(1000, "Hello!");
+    server.listener.assertClosed(1000, "Hello!");
   }
 
-  @Test public void clientAndServerCloseClosesConnection() throws IOException {
+  @Test public void clientAndServerCloseClosesConnection() throws Exception {
     // Send close from both sides at the same time.
-    server.close(1000, "Hello!");
+    server.webSocket.close(1000, "Hello!");
     client.processNextFrame(); // Read close, close connection close.
 
-    assertFalse(clientConnectionClosed);
-    client.close(1000, "Hi!");
+    assertFalse(client.closed);
+    client.webSocket.close(1000, "Hi!");
     server.processNextFrame();
 
-    clientListener.assertClosing(1000, "Hello!");
-    serverListener.assertClosing(1000, "Hi!");
-    clientListener.assertClosed(1000, "Hello!");
-    serverListener.assertClosed(1000, "Hi!");
-    assertTrue(clientConnectionClosed);
+    client.listener.assertClosing(1000, "Hello!");
+    server.listener.assertClosing(1000, "Hi!");
+    client.listener.assertClosed(1000, "Hello!");
+    server.listener.assertClosed(1000, "Hi!");
+    client.webSocket.awaitTermination(5, TimeUnit.SECONDS);
+    assertTrue(client.closed);
 
-    serverListener.assertExhausted(); // Client should not have sent second close.
-    clientListener.assertExhausted(); // Server should not have sent second close.
+    server.listener.assertExhausted(); // Client should not have sent second close.
+    client.listener.assertExhausted(); // Server should not have sent second close.
   }
 
   @Test public void serverCloseBreaksReadMessageLoop() throws IOException {
-    server.send("Hello!");
-    server.close(1000, "Bye!");
+    server.webSocket.send("Hello!");
+    server.webSocket.close(1000, "Bye!");
     assertTrue(client.processNextFrame());
-    clientListener.assertTextMessage("Hello!");
+    client.listener.assertTextMessage("Hello!");
     assertFalse(client.processNextFrame());
-    clientListener.assertClosing(1000, "Bye!");
+    client.listener.assertClosing(1000, "Bye!");
   }
 
   @Test public void protocolErrorBeforeCloseSendsFailure() throws IOException {
-    server2clientSink.write(ByteString.decodeHex("0a00")).emit(); // Invalid non-final ping frame.
+    server.sink.write(ByteString.decodeHex("0a00")).emit(); // Invalid non-final ping frame.
 
     client.processNextFrame(); // Detects error, send close, close connection.
-    assertTrue(clientConnectionClosed);
-    clientListener.assertFailure(ProtocolException.class, "Control frames must be final.");
+    assertTrue(client.closed);
+    client.listener.assertFailure(ProtocolException.class, "Control frames must be final.");
 
     server.processNextFrame();
-    serverListener.assertFailure(EOFException.class, null);
+    server.listener.assertFailure(EOFException.class);
   }
 
   @Test public void protocolErrorInCloseResponseClosesConnection() throws IOException {
-    client.close(1000, "Hello");
+    client.webSocket.close(1000, "Hello");
     server.processNextFrame();
-    assertFalse(clientConnectionClosed); // Not closed until close reply is received.
+    assertFalse(client.closed); // Not closed until close reply is received.
 
     // Manually write an invalid masked close frame.
-    server2clientSink.write(ByteString.decodeHex("888760b420bb635c68de0cd84f")).emit();
+    server.sink.write(ByteString.decodeHex("888760b420bb635c68de0cd84f")).emit();
 
     client.processNextFrame();// Detects error, disconnects immediately since close already sent.
-    assertTrue(clientConnectionClosed);
-    clientListener.assertFailure(
+    assertTrue(client.closed);
+    client.listener.assertFailure(
         ProtocolException.class, "Server-sent frames must not be masked.");
 
-    serverListener.assertClosing(1000, "Hello");
-    serverListener.assertExhausted(); // Client should not have sent second close.
+    server.listener.assertClosing(1000, "Hello");
+    server.listener.assertExhausted(); // Client should not have sent second close.
   }
 
   @Test public void protocolErrorAfterCloseDoesNotSendClose() throws IOException {
-    client.close(1000, "Hello!");
+    client.webSocket.close(1000, "Hello!");
     server.processNextFrame();
 
-    assertFalse(clientConnectionClosed); // Not closed until close reply is received.
-    server2clientSink.write(ByteString.decodeHex("0a00")).emit(); // Invalid non-final ping frame.
+    assertFalse(client.closed); // Not closed until close reply is received.
+    server.sink.write(ByteString.decodeHex("0a00")).emit(); // Invalid non-final ping frame.
 
     client.processNextFrame(); // Detects error, disconnects immediately since close already sent.
-    assertTrue(clientConnectionClosed);
-    clientListener.assertFailure(ProtocolException.class, "Control frames must be final.");
+    assertTrue(client.closed);
+    client.listener.assertFailure(ProtocolException.class, "Control frames must be final.");
 
-    serverListener.assertClosing(1000, "Hello!");
+    server.listener.assertClosing(1000, "Hello!");
 
-    serverListener.assertExhausted(); // Client should not have sent second close.
+    server.listener.assertExhausted(); // Client should not have sent second close.
   }
 
   @Test public void networkErrorReportedAsFailure() throws IOException {
-    server2clientSink.close();
+    server.sink.close();
     client.processNextFrame();
-    clientListener.assertFailure(EOFException.class, null);
+    client.listener.assertFailure(EOFException.class);
   }
 
   @Test public void closeThrowingFailsConnection() throws IOException {
     client2Server.source().close();
-    client.close(1000, null);
-    clientListener.assertFailure(IOException.class, "source is closed");
+    client.webSocket.close(1000, null);
+    client.listener.assertFailure(IOException.class, "source is closed");
   }
 
   @Ignore // TODO(jwilson): come up with a way to test unchecked exceptions on the writer thread.
   @Test public void closeMessageAndConnectionCloseThrowingDoesNotMaskOriginal() throws IOException {
-    client2ServerSink.close();
-    clientConnectionCloseThrows = true;
+    client.sink.close();
+    client.closeThrows = true;
 
-    client.close(1000, "Bye!");
-    clientListener.assertFailure(IOException.class, "failure");
-    assertTrue(clientConnectionClosed);
+    client.webSocket.close(1000, "Bye!");
+    client.listener.assertFailure(IOException.class, "failure");
+    assertTrue(client.closed);
   }
 
   @Ignore // TODO(jwilson): come up with a way to test unchecked exceptions on the writer thread.
   @Test public void peerConnectionCloseThrowingPropagates() throws IOException {
-    clientConnectionCloseThrows = true;
+    client.closeThrows = true;
 
-    server.close(1000, "Bye from Server!");
+    server.webSocket.close(1000, "Bye from Server!");
     client.processNextFrame();
-    clientListener.assertClosing(1000, "Bye from Server!");
+    client.listener.assertClosing(1000, "Bye from Server!");
 
-    client.close(1000, "Bye from Client!");
+    client.webSocket.close(1000, "Bye from Client!");
     server.processNextFrame();
-    serverListener.assertClosing(1000, "Bye from Client!");
+    server.listener.assertClosing(1000, "Bye from Client!");
+  }
+
+  @Test public void pingOnInterval() throws IOException {
+    long startNanos = System.nanoTime();
+    client.initWebSocket(random, 500);
+
+    server.processNextFrame(); // Ping.
+    client.processNextFrame(); // Pong.
+    long elapsedUntilPing1 = System.nanoTime() - startNanos;
+    assertEquals(500, TimeUnit.NANOSECONDS.toMillis(elapsedUntilPing1), 250d);
+
+    server.processNextFrame(); // Ping.
+    client.processNextFrame(); // Pong.
+    long elapsedUntilPing2 = System.nanoTime() - startNanos;
+    assertEquals(1000, TimeUnit.NANOSECONDS.toMillis(elapsedUntilPing2), 250d);
+
+    server.processNextFrame(); // Ping.
+    client.processNextFrame(); // Pong.
+    long elapsedUntilPing3 = System.nanoTime() - startNanos;
+    assertEquals(1500, TimeUnit.NANOSECONDS.toMillis(elapsedUntilPing3), 250d);
+  }
+
+  /** One peer's streams, listener, and web socket in the test. */
+  private static class TestStreams extends RealWebSocket.Streams {
+    private final String name;
+    private final WebSocketRecorder listener;
+    private RealWebSocket webSocket;
+    boolean closeThrows;
+    boolean closed;
+
+    public TestStreams(boolean client, Pipe source, Pipe sink) {
+      super(client, Okio.buffer(source.source()), Okio.buffer(sink.sink()));
+      this.name = client ? "client" : "server";
+      this.listener = new WebSocketRecorder(name);
+    }
+
+    public void initWebSocket(Random random, int pingIntervalMillis) throws IOException {
+      String url = "http://example.com/websocket";
+      Response response = new Response.Builder()
+          .code(101)
+          .message("OK")
+          .request(new Request.Builder().url(url).build())
+          .protocol(Protocol.HTTP_1_1)
+          .build();
+      webSocket = new RealWebSocket(response.request(), listener, random);
+      webSocket.initReaderAndWriter(name, pingIntervalMillis, this);
+    }
+
+    public boolean processNextFrame() throws IOException {
+      return webSocket.processNextFrame();
+    }
+
+    @Override public void close() throws IOException {
+      source.close();
+      sink.close();
+      if (closed) {
+        throw new AssertionError("Already closed");
+      }
+      closed = true;
+
+      if (closeThrows) {
+        throw new RuntimeException("Oops!");
+      }
+    }
   }
 }
diff --git a/okhttp-tests/src/test/java/okhttp3/WebSocketHttpTest.java b/okhttp-tests/src/test/java/okhttp3/internal/ws/WebSocketHttpTest.java
similarity index 65%
rename from okhttp-tests/src/test/java/okhttp3/WebSocketHttpTest.java
rename to okhttp-tests/src/test/java/okhttp3/internal/ws/WebSocketHttpTest.java
index d971c4b940..2d38049bf7 100644
--- a/okhttp-tests/src/test/java/okhttp3/WebSocketHttpTest.java
+++ b/okhttp-tests/src/test/java/okhttp3/internal/ws/WebSocketHttpTest.java
@@ -13,18 +13,25 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package okhttp3;
+package okhttp3.internal.ws;
 
+import java.io.EOFException;
 import java.io.IOException;
 import java.net.ProtocolException;
 import java.net.SocketTimeoutException;
 import java.util.Random;
 import java.util.concurrent.TimeUnit;
+import java.util.concurrent.atomic.AtomicInteger;
 import java.util.logging.Logger;
+import okhttp3.Interceptor;
+import okhttp3.OkHttpClient;
+import okhttp3.RecordingHostnameVerifier;
+import okhttp3.Request;
+import okhttp3.Response;
+import okhttp3.TestLogHandler;
+import okhttp3.WebSocket;
+import okhttp3.WebSocketListener;
 import okhttp3.internal.tls.SslClient;
-import okhttp3.internal.ws.RealWebSocket;
-import okhttp3.internal.ws.WebSocketProtocol;
-import okhttp3.internal.ws.WebSocketRecorder;
 import okhttp3.mockwebserver.Dispatcher;
 import okhttp3.mockwebserver.MockResponse;
 import okhttp3.mockwebserver.MockWebServer;
@@ -38,9 +45,12 @@
 import org.junit.Test;
 
 import static okhttp3.TestUtil.defaultClient;
+import static okhttp3.TestUtil.repeat;
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertFalse;
 import static org.junit.Assert.assertNotNull;
+import static org.junit.Assert.assertNull;
+import static org.junit.Assert.assertTrue;
 import static org.junit.Assert.fail;
 
 public final class WebSocketHttpTest {
@@ -85,7 +95,7 @@
     serverListener.assertOpen();
 
     webSocket.send(ByteString.encodeUtf8("Hello!"));
-    serverListener.assertBinaryMessage(new byte[] {'H', 'e', 'l', 'l', 'o', '!'});
+    serverListener.assertBinaryMessage(ByteString.of(new byte[] {'H', 'e', 'l', 'l', 'o', '!'}));
   }
 
   @Test public void nullStringThrows() throws IOException {
@@ -178,6 +188,7 @@
 
     server.send("Hello, WebSockets!");
     clientListener.assertFailure(e);
+    serverListener.assertFailure(EOFException.class);
     serverListener.assertExhausted();
   }
 
@@ -300,6 +311,128 @@
         "Expected 'Sec-WebSocket-Accept' header value 'ujmZX4KXZqjwy6vi1aQFH5p4Ygk=' but was 'magic'");
   }
 
+  @Test public void webSocketAndApplicationInterceptors() throws IOException {
+    final AtomicInteger interceptedCount = new AtomicInteger();
+
+    client = client.newBuilder()
+        .addInterceptor(new Interceptor() {
+          @Override public Response intercept(Chain chain) throws IOException {
+            assertNull(chain.request().body());
+            Response response = chain.proceed(chain.request());
+            assertEquals("Upgrade", response.header("Connection"));
+            assertTrue("", response.body().source().exhausted());
+            interceptedCount.incrementAndGet();
+            return response;
+          }
+        }).build();
+
+    webServer.enqueue(new MockResponse().withWebSocketUpgrade(serverListener));
+
+    WebSocket webSocket = newWebSocket();
+    clientListener.assertOpen();
+    assertEquals(1, interceptedCount.get());
+    webSocket.close(1000, null);
+
+    WebSocket server = serverListener.assertOpen();
+    server.close(1000, null);
+  }
+
+  @Test public void webSocketAndNetworkInterceptors() throws IOException {
+    client = client.newBuilder()
+        .addNetworkInterceptor(new Interceptor() {
+          @Override public Response intercept(Chain chain) throws IOException {
+            throw new AssertionError(); // Network interceptors don't execute.
+          }
+        }).build();
+
+    webServer.enqueue(new MockResponse().withWebSocketUpgrade(serverListener));
+
+    WebSocket webSocket = newWebSocket();
+    clientListener.assertOpen();
+    webSocket.close(1000, null);
+
+    WebSocket server = serverListener.assertOpen();
+    server.close(1000, null);
+  }
+
+  @Test public void overflowOutgoingQueue() throws IOException {
+    webServer.enqueue(new MockResponse().withWebSocketUpgrade(serverListener));
+
+    WebSocket webSocket = newWebSocket();
+    clientListener.assertOpen();
+
+    // Send messages until the client's outgoing buffer overflows!
+    ByteString message = ByteString.of(new byte[1024 * 1024]);
+    int messageCount = 0;
+    while (true) {
+      boolean success = webSocket.send(message);
+      if (!success) break;
+
+      messageCount++;
+      long queueSize = webSocket.queueSize();
+      assertTrue(queueSize >= 0 && queueSize <= messageCount * message.size());
+      assertTrue(messageCount < 32); // Expect to fail before enqueueing 32 MiB.
+    }
+
+    // Confirm all sent messages were received, followed by a client-initiated close.
+    WebSocket server = serverListener.assertOpen();
+    for (int i = 0; i < messageCount; i++) {
+      serverListener.assertBinaryMessage(message);
+    }
+    serverListener.assertClosing(1001, "");
+
+    // When the server acknowledges the close the connection shuts down gracefully.
+    server.close(1000, null);
+    clientListener.assertClosing(1000, "");
+    clientListener.assertClosed(1000, "");
+    serverListener.assertClosed(1001, "");
+  }
+
+  @Test public void closeReasonMaximumLength() throws IOException {
+    webServer.enqueue(new MockResponse().withWebSocketUpgrade(serverListener));
+
+    String clientReason = repeat('C', 123);
+    String serverReason = repeat('S', 123);
+
+    WebSocket webSocket = newWebSocket();
+    WebSocket server = serverListener.assertOpen();
+
+    clientListener.assertOpen();
+    webSocket.close(1000, clientReason);
+    serverListener.assertClosing(1000, clientReason);
+
+    server.close(1000, serverReason);
+    clientListener.assertClosing(1000, serverReason);
+    clientListener.assertClosed(1000, serverReason);
+
+    serverListener.assertClosed(1000, clientReason);
+  }
+
+  @Test public void closeReasonTooLong() throws IOException {
+    webServer.enqueue(new MockResponse().withWebSocketUpgrade(serverListener));
+
+    WebSocket webSocket = newWebSocket();
+    WebSocket server = serverListener.assertOpen();
+
+    clientListener.assertOpen();
+    String reason = repeat('X', 124);
+    try {
+      webSocket.close(1000, reason);
+      fail();
+    } catch (IllegalArgumentException expected) {
+      assertEquals("reason.size() > 123: " + reason, expected.getMessage());
+    }
+
+    webSocket.close(1000, null);
+    serverListener.assertClosing(1000, "");
+
+    server.close(1000, null);
+    clientListener.assertClosing(1000, "");
+    clientListener.assertClosed(1000, "");
+
+    serverListener.assertClosed(1000, "");
+  }
+
   @Test public void wsScheme() throws IOException {
     websocketScheme("ws");
   }
@@ -334,7 +467,7 @@
 
     WebSocket webSocket = newWebSocket();
 
-    clientListener.assertFailure(SocketTimeoutException.class, "timeout");
+    clientListener.assertFailure(SocketTimeoutException.class, "timeout", "Read timed out");
     assertFalse(webSocket.close(1000, null));
   }
 
@@ -356,7 +489,7 @@
     WebSocket webSocket = newWebSocket();
     clientListener.assertOpen();
 
-    clientListener.assertFailure(SocketTimeoutException.class, "timeout");
+    clientListener.assertFailure(SocketTimeoutException.class, "timeout", "Read timed out");
     assertFalse(webSocket.close(1000, null));
   }
 
@@ -374,6 +507,73 @@
     clientListener.assertTextMessage("abc");
   }
 
+  @Test public void clientPingsServerOnInterval() throws Exception {
+    client = client.newBuilder()
+        .pingInterval(500, TimeUnit.MILLISECONDS)
+        .build();
+
+    webServer.enqueue(new MockResponse().withWebSocketUpgrade(serverListener));
+    RealWebSocket webSocket = newWebSocket();
+
+    clientListener.assertOpen();
+    RealWebSocket server = (RealWebSocket) serverListener.assertOpen();
+
+    long startNanos = System.nanoTime();
+    while (webSocket.pongCount() < 3) {
+      Thread.sleep(50);
+    }
+
+    long elapsedUntilPong3 = System.nanoTime() - startNanos;
+    assertEquals(1500, TimeUnit.NANOSECONDS.toMillis(elapsedUntilPong3), 250d);
+
+    // The client pinged the server 3 times, and it has ponged back 3 times.
+    assertEquals(3, server.pingCount());
+    assertEquals(3, webSocket.pongCount());
+
+    // The server has never pinged the client.
+    assertEquals(0, server.pongCount());
+    assertEquals(0, webSocket.pingCount());
+  }
+
+  @Test public void clientDoesNotPingServerByDefault() throws Exception {
+    webServer.enqueue(new MockResponse().withWebSocketUpgrade(serverListener));
+    RealWebSocket webSocket = newWebSocket();
+
+    clientListener.assertOpen();
+    RealWebSocket server = (RealWebSocket) serverListener.assertOpen();
+
+    Thread.sleep(1000);
+
+    // No pings and no pongs.
+    assertEquals(0, server.pingCount());
+    assertEquals(0, webSocket.pongCount());
+    assertEquals(0, server.pongCount());
+    assertEquals(0, webSocket.pingCount());
+  }
+
+  /** https://github.com/square/okhttp/issues/2788 */
+  @Test public void clientCancelsIfCloseIsNotAcknowledged() throws Exception {
+    webServer.enqueue(new MockResponse().withWebSocketUpgrade(serverListener));
+    RealWebSocket webSocket = newWebSocket();
+
+    clientListener.assertOpen();
+    WebSocket server = serverListener.assertOpen();
+
+    // Initiate a close on the client, which will schedule a hard cancel in 500 ms.
+    long closeAtNanos = System.nanoTime();
+    webSocket.close(1000, "goodbye", 500);
+    serverListener.assertClosing(1000, "goodbye");
+
+    // Confirm that the hard cancel occurred after 500 ms.
+    clientListener.assertFailure();
+    long elapsedUntilFailure = System.nanoTime() - closeAtNanos;
+    assertEquals(500, TimeUnit.NANOSECONDS.toMillis(elapsedUntilFailure), 250d);
+
+    // Close the server and confirm it saw what we expected.
+    server.close(1000, null);
+    serverListener.assertClosed(1000, "goodbye");
+  }
+
   private MockResponse upgradeResponse(RecordedRequest request) {
     String key = request.getHeader("Sec-WebSocket-Key");
     return new MockResponse()
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/ws/WebSocketReaderTest.java b/okhttp-tests/src/test/java/okhttp3/internal/ws/WebSocketReaderTest.java
index 07ae188ac6..21cf06df5d 100644
--- a/okhttp-tests/src/test/java/okhttp3/internal/ws/WebSocketReaderTest.java
+++ b/okhttp-tests/src/test/java/okhttp3/internal/ws/WebSocketReaderTest.java
@@ -214,7 +214,7 @@
     byte[] bytes = binaryData(256);
     data.write(ByteString.decodeHex("827E0100")).write(bytes);
     clientReader.processNextFrame();
-    callback.assertBinaryMessage(bytes);
+    callback.assertBinaryMessage(ByteString.of(bytes));
   }
 
   @Test public void clientTwoFrameBinary() throws IOException {
@@ -222,7 +222,7 @@
     data.write(ByteString.decodeHex("0264")).write(bytes, 0, 100);
     data.write(ByteString.decodeHex("8064")).write(bytes, 100, 100);
     clientReader.processNextFrame();
-    callback.assertBinaryMessage(bytes);
+    callback.assertBinaryMessage(ByteString.of(bytes));
   }
 
   @Test public void twoFrameNotContinuation() throws IOException {
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/ws/WebSocketRecorder.java b/okhttp-tests/src/test/java/okhttp3/internal/ws/WebSocketRecorder.java
index 944ac48bb0..ec043d9f41 100644
--- a/okhttp-tests/src/test/java/okhttp3/internal/ws/WebSocketRecorder.java
+++ b/okhttp-tests/src/test/java/okhttp3/internal/ws/WebSocketRecorder.java
@@ -16,11 +16,12 @@
 package okhttp3.internal.ws;
 
 import java.io.IOException;
+import java.util.Arrays;
 import java.util.concurrent.BlockingQueue;
 import java.util.concurrent.LinkedBlockingQueue;
 import java.util.concurrent.TimeUnit;
-import okhttp3.WebSocket;
 import okhttp3.Response;
+import okhttp3.WebSocket;
 import okhttp3.WebSocketListener;
 import okhttp3.internal.Util;
 import okhttp3.internal.platform.Platform;
@@ -136,9 +137,9 @@ public void assertTextMessage(String payload) {
     assertEquals(new Message(payload), actual);
   }
 
-  public void assertBinaryMessage(byte[] payload) {
+  public void assertBinaryMessage(ByteString payload) {
     Object actual = nextEvent();
-    assertEquals(new Message(ByteString.of(payload)), actual);
+    assertEquals(new Message(payload), actual);
   }
 
   public void assertPing(ByteString payload) {
@@ -183,7 +184,7 @@ public void assertFailure(Throwable t) {
     assertSame(t, failure.t);
   }
 
-  public void assertFailure(Class<? extends IOException> cls, String message) {
+  public void assertFailure(Class<? extends IOException> cls, String... messages) {
     Object event = nextEvent();
     if (!(event instanceof Failure)) {
       throw new AssertionError("Expected Failure but was " + event);
@@ -191,7 +192,16 @@ public void assertFailure(Class<? extends IOException> cls, String message) {
     Failure failure = (Failure) event;
     assertNull(failure.response);
     assertEquals(cls, failure.t.getClass());
-    assertEquals(message, failure.t.getMessage());
+    if (messages.length > 0) {
+      assertTrue(failure.t.getMessage(), Arrays.asList(messages).contains(failure.t.getMessage()));
+    }
+  }
+
+  public void assertFailure() {
+    Object event = nextEvent();
+    if (!(event instanceof Failure)) {
+      throw new AssertionError("Expected Failure but was " + event);
+    }
   }
 
   public void assertFailure(int code, String body, Class<? extends IOException> cls, String message)
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/ws/WebSocketWriterTest.java b/okhttp-tests/src/test/java/okhttp3/internal/ws/WebSocketWriterTest.java
index bb4d43ec10..a303cc1052 100644
--- a/okhttp-tests/src/test/java/okhttp3/internal/ws/WebSocketWriterTest.java
+++ b/okhttp-tests/src/test/java/okhttp3/internal/ws/WebSocketWriterTest.java
@@ -31,6 +31,7 @@
 import org.junit.runner.Description;
 import org.junit.runners.model.Statement;
 
+import static okhttp3.TestUtil.repeat;
 import static okhttp3.internal.ws.WebSocketProtocol.OPCODE_BINARY;
 import static okhttp3.internal.ws.WebSocketProtocol.OPCODE_TEXT;
 import static okhttp3.internal.ws.WebSocketProtocol.PAYLOAD_BYTE_MAX;
@@ -263,7 +264,7 @@
   }
 
   @Test public void serverCloseWithCodeAndReason() throws IOException {
-    serverWriter.writeClose(1001, "Hello");
+    serverWriter.writeClose(1001, ByteString.encodeUtf8("Hello"));
     assertData("880703e948656c6c6f");
   }
 
@@ -278,18 +279,18 @@
   }
 
   @Test public void clientCloseWithCodeAndReason() throws IOException {
-    clientWriter.writeClose(1001, "Hello");
+    clientWriter.writeClose(1001, ByteString.encodeUtf8("Hello"));
     assertData("888760b420bb635d68de0cd84f");
   }
 
   @Test public void closeWithOnlyReasonThrows() throws IOException {
-    clientWriter.writeClose(0, "Hello");
+    clientWriter.writeClose(0, ByteString.encodeUtf8("Hello"));
     assertData("888760b420bb60b468de0cd84f");
   }
 
   @Test public void closeCodeOutOfRangeThrows() throws IOException {
     try {
-      clientWriter.writeClose(98724976, "Hello");
+      clientWriter.writeClose(98724976, ByteString.encodeUtf8("Hello"));
       fail();
     } catch (IllegalArgumentException e) {
       assertEquals("Code must be in range [1000,5000): 98724976", e.getMessage());
@@ -298,7 +299,7 @@
 
   @Test public void closeReservedThrows() throws IOException {
     try {
-      clientWriter.writeClose(1005, "Hello");
+      clientWriter.writeClose(1005, ByteString.encodeUtf8("Hello"));
       fail();
     } catch (IllegalArgumentException e) {
       assertEquals("Code 1005 is reserved and may not be used.", e.getMessage());
@@ -365,8 +366,8 @@
 
   @Test public void closeTooLongThrows() throws IOException {
     try {
-      String longString = ByteString.of(binaryData(75)).hex();
-      serverWriter.writeClose(1000, longString);
+      ByteString longReason = ByteString.encodeUtf8(repeat('X', 124));
+      serverWriter.writeClose(1000, longReason);
       fail();
     } catch (IllegalArgumentException e) {
       assertEquals("Payload size must be less than or equal to 125", e.getMessage());
diff --git a/okhttp-urlconnection/pom.xml b/okhttp-urlconnection/pom.xml
index bde049037c..64d479751f 100644
--- a/okhttp-urlconnection/pom.xml
+++ b/okhttp-urlconnection/pom.xml
@@ -6,13 +6,18 @@
   <parent>
     <groupId>com.squareup.okhttp3</groupId>
     <artifactId>parent</artifactId>
-    <version>3.5.0-SNAPSHOT</version>
+    <version>3.9.0-SNAPSHOT</version>
   </parent>
 
   <artifactId>okhttp-urlconnection</artifactId>
   <name>OkHttp URLConnection</name>
 
   <dependencies>
+    <dependency>
+      <groupId>com.google.code.findbugs</groupId>
+      <artifactId>jsr305</artifactId>
+      <scope>provided</scope>
+    </dependency>
     <dependency>
       <groupId>org.codehaus.mojo</groupId>
       <artifactId>animal-sniffer-annotations</artifactId>
diff --git a/okhttp-urlconnection/src/main/java/okhttp3/internal/huc/DelegatingHttpsURLConnection.java b/okhttp-urlconnection/src/main/java/okhttp3/internal/huc/DelegatingHttpsURLConnection.java
index 9dd7cfd0b1..a051bf2198 100644
--- a/okhttp-urlconnection/src/main/java/okhttp3/internal/huc/DelegatingHttpsURLConnection.java
+++ b/okhttp-urlconnection/src/main/java/okhttp3/internal/huc/DelegatingHttpsURLConnection.java
@@ -41,7 +41,7 @@
 abstract class DelegatingHttpsURLConnection extends HttpsURLConnection {
   private final HttpURLConnection delegate;
 
-  public DelegatingHttpsURLConnection(HttpURLConnection delegate) {
+  DelegatingHttpsURLConnection(HttpURLConnection delegate) {
     super(delegate.getURL());
     this.delegate = delegate;
   }
diff --git a/okhttp-urlconnection/src/main/java/okhttp3/internal/huc/OkHttpURLConnection.java b/okhttp-urlconnection/src/main/java/okhttp3/internal/huc/OkHttpURLConnection.java
index 461b1f1c48..344a61e446 100644
--- a/okhttp-urlconnection/src/main/java/okhttp3/internal/huc/OkHttpURLConnection.java
+++ b/okhttp-urlconnection/src/main/java/okhttp3/internal/huc/OkHttpURLConnection.java
@@ -568,7 +568,7 @@ private Response getResponse(boolean networkResponseOnError) throws IOException
       }
     };
 
-    public UnexpectedException(Throwable cause) {
+    UnexpectedException(Throwable cause) {
       super(cause);
     }
   }
diff --git a/okhttp/pom.xml b/okhttp/pom.xml
index 2e07de0875..e2a9a723bc 100644
--- a/okhttp/pom.xml
+++ b/okhttp/pom.xml
@@ -6,7 +6,7 @@
   <parent>
     <groupId>com.squareup.okhttp3</groupId>
     <artifactId>parent</artifactId>
-    <version>3.5.0-SNAPSHOT</version>
+    <version>3.9.0-SNAPSHOT</version>
   </parent>
 
   <artifactId>okhttp</artifactId>
@@ -22,6 +22,11 @@
       <artifactId>android</artifactId>
       <scope>provided</scope>
     </dependency>
+    <dependency>
+      <groupId>com.google.code.findbugs</groupId>
+      <artifactId>jsr305</artifactId>
+      <scope>provided</scope>
+    </dependency>
   </dependencies>
 
   <build>
diff --git a/okhttp/src/main/java/okhttp3/Address.java b/okhttp/src/main/java/okhttp3/Address.java
index 4fd97764a3..9df666ad78 100644
--- a/okhttp/src/main/java/okhttp3/Address.java
+++ b/okhttp/src/main/java/okhttp3/Address.java
@@ -18,6 +18,7 @@
 import java.net.Proxy;
 import java.net.ProxySelector;
 import java.util.List;
+import javax.annotation.Nullable;
 import javax.net.SocketFactory;
 import javax.net.ssl.HostnameVerifier;
 import javax.net.ssl.SSLSocketFactory;
@@ -42,15 +43,16 @@
   final List<Protocol> protocols;
   final List<ConnectionSpec> connectionSpecs;
   final ProxySelector proxySelector;
-  final Proxy proxy;
-  final SSLSocketFactory sslSocketFactory;
-  final HostnameVerifier hostnameVerifier;
-  final CertificatePinner certificatePinner;
+  final @Nullable Proxy proxy;
+  final @Nullable SSLSocketFactory sslSocketFactory;
+  final @Nullable HostnameVerifier hostnameVerifier;
+  final @Nullable CertificatePinner certificatePinner;
 
   public Address(String uriHost, int uriPort, Dns dns, SocketFactory socketFactory,
-      SSLSocketFactory sslSocketFactory, HostnameVerifier hostnameVerifier,
-      CertificatePinner certificatePinner, Authenticator proxyAuthenticator, Proxy proxy,
-      List<Protocol> protocols, List<ConnectionSpec> connectionSpecs, ProxySelector proxySelector) {
+      @Nullable SSLSocketFactory sslSocketFactory, @Nullable HostnameVerifier hostnameVerifier,
+      @Nullable CertificatePinner certificatePinner, Authenticator proxyAuthenticator,
+      @Nullable Proxy proxy, List<Protocol> protocols, List<ConnectionSpec> connectionSpecs,
+      ProxySelector proxySelector) {
     this.url = new HttpUrl.Builder()
         .scheme(sslSocketFactory != null ? "https" : "http")
         .host(uriHost)
@@ -130,40 +132,29 @@ public ProxySelector proxySelector() {
    * Returns this address's explicitly-specified HTTP proxy, or null to delegate to the {@linkplain
    * #proxySelector proxy selector}.
    */
-  public Proxy proxy() {
+  public @Nullable Proxy proxy() {
     return proxy;
   }
 
   /** Returns the SSL socket factory, or null if this is not an HTTPS address. */
-  public SSLSocketFactory sslSocketFactory() {
+  public @Nullable SSLSocketFactory sslSocketFactory() {
     return sslSocketFactory;
   }
 
   /** Returns the hostname verifier, or null if this is not an HTTPS address. */
-  public HostnameVerifier hostnameVerifier() {
+  public @Nullable HostnameVerifier hostnameVerifier() {
     return hostnameVerifier;
   }
 
   /** Returns this address's certificate pinner, or null if this is not an HTTPS address. */
-  public CertificatePinner certificatePinner() {
+  public @Nullable CertificatePinner certificatePinner() {
     return certificatePinner;
   }
 
-  @Override public boolean equals(Object other) {
-    if (other instanceof Address) {
-      Address that = (Address) other;
-      return this.url.equals(that.url)
-          && this.dns.equals(that.dns)
-          && this.proxyAuthenticator.equals(that.proxyAuthenticator)
-          && this.protocols.equals(that.protocols)
-          && this.connectionSpecs.equals(that.connectionSpecs)
-          && this.proxySelector.equals(that.proxySelector)
-          && equal(this.proxy, that.proxy)
-          && equal(this.sslSocketFactory, that.sslSocketFactory)
-          && equal(this.hostnameVerifier, that.hostnameVerifier)
-          && equal(this.certificatePinner, that.certificatePinner);
-    }
-    return false;
+  @Override public boolean equals(@Nullable Object other) {
+    return other instanceof Address
+        && url.equals(((Address) other).url)
+        && equalsNonHost((Address) other);
   }
 
   @Override public int hashCode() {
@@ -180,4 +171,32 @@ public CertificatePinner certificatePinner() {
     result = 31 * result + (certificatePinner != null ? certificatePinner.hashCode() : 0);
     return result;
   }
+
+  boolean equalsNonHost(Address that) {
+    return this.dns.equals(that.dns)
+        && this.proxyAuthenticator.equals(that.proxyAuthenticator)
+        && this.protocols.equals(that.protocols)
+        && this.connectionSpecs.equals(that.connectionSpecs)
+        && this.proxySelector.equals(that.proxySelector)
+        && equal(this.proxy, that.proxy)
+        && equal(this.sslSocketFactory, that.sslSocketFactory)
+        && equal(this.hostnameVerifier, that.hostnameVerifier)
+        && equal(this.certificatePinner, that.certificatePinner)
+        && this.url().port() == that.url().port();
+  }
+
+  @Override public String toString() {
+    StringBuilder result = new StringBuilder()
+        .append("Address{")
+        .append(url.host()).append(":").append(url.port());
+
+    if (proxy != null) {
+      result.append(", proxy=").append(proxy);
+    } else {
+      result.append(", proxySelector=").append(proxySelector);
+    }
+
+    result.append("}");
+    return result.toString();
+  }
 }
diff --git a/okhttp/src/main/java/okhttp3/Authenticator.java b/okhttp/src/main/java/okhttp3/Authenticator.java
index 3463690f7b..9e34bc9706 100644
--- a/okhttp/src/main/java/okhttp3/Authenticator.java
+++ b/okhttp/src/main/java/okhttp3/Authenticator.java
@@ -16,6 +16,7 @@
 package okhttp3;
 
 import java.io.IOException;
+import javax.annotation.Nullable;
 
 /**
  * Responds to an authentication challenge from either a remote web server or a proxy server.
@@ -23,10 +24,18 @@
  * an authorization header, or they may refuse the challenge by returning null. In this case the
  * unauthenticated response will be returned to the caller that triggered it.
  *
+ * <p>Implementations should check if the initial request already included an attempt to
+ * authenticate. If so it is likely that further attempts will not be useful and the authenticator
+ * should give up.
+ *
  * <p>When authentication is requested by an origin server, the response code is 401 and the
  * implementation should respond with a new request that sets the "Authorization" header.
  * <pre>   {@code
  *
+ *    if (response.request().header("Authorization") != null) {
+ *      return null; // Give up, we've already failed to authenticate.
+ *    }
+ *
  *    String credential = Credentials.basic(...)
  *    return response.request().newBuilder()
  *        .header("Authorization", credential)
@@ -37,6 +46,10 @@
  * implementation should respond with a new request that sets the "Proxy-Authorization" header.
  * <pre>   {@code
  *
+ *    if (response.request().header("Proxy-Authorization") != null) {
+ *      return null; // Give up, we've already failed to authenticate.
+ *    }
+ *
  *    String credential = Credentials.basic(...)
  *    return response.request().newBuilder()
  *        .header("Proxy-Authorization", credential)
@@ -58,5 +71,5 @@
    * Returns a request that includes a credential to satisfy an authentication challenge in {@code
    * response}. Returns null if the challenge cannot be satisfied.
    */
-  Request authenticate(Route route, Response response) throws IOException;
+  @Nullable Request authenticate(Route route, Response response) throws IOException;
 }
diff --git a/okhttp/src/main/java/okhttp3/Cache.java b/okhttp/src/main/java/okhttp3/Cache.java
index 6ed941b8f2..d43d91d257 100644
--- a/okhttp/src/main/java/okhttp3/Cache.java
+++ b/okhttp/src/main/java/okhttp3/Cache.java
@@ -28,6 +28,7 @@
 import java.util.Iterator;
 import java.util.List;
 import java.util.NoSuchElementException;
+import javax.annotation.Nullable;
 import okhttp3.internal.Util;
 import okhttp3.internal.cache.CacheRequest;
 import okhttp3.internal.cache.CacheStrategy;
@@ -186,7 +187,7 @@ public static String key(HttpUrl url) {
     return ByteString.encodeUtf8(url.toString()).md5().hex();
   }
 
-  Response get(Request request) {
+  @Nullable Response get(Request request) {
     String key = key(request.url());
     DiskLruCache.Snapshot snapshot;
     Entry entry;
@@ -217,7 +218,7 @@ Response get(Request request) {
     return response;
   }
 
-  CacheRequest put(Response response) {
+  @Nullable CacheRequest put(Response response) {
     String requestMethod = response.request().method();
 
     if (HttpMethod.invalidatesCache(response.request().method())) {
@@ -273,7 +274,7 @@ void update(Response cached, Response network) {
     }
   }
 
-  private void abortQuietly(DiskLruCache.Editor editor) {
+  private void abortQuietly(@Nullable DiskLruCache.Editor editor) {
     // Give up because the cache cannot be written.
     try {
       if (editor != null) {
@@ -327,7 +328,7 @@ public void evictAll() throws IOException {
     return new Iterator<String>() {
       final Iterator<DiskLruCache.Snapshot> delegate = cache.snapshots();
 
-      String nextUrl;
+      @Nullable String nextUrl;
       boolean canRemove;
 
       @Override public boolean hasNext() {
@@ -432,7 +433,7 @@ public synchronized int requestCount() {
     private Sink body;
     boolean done;
 
-    public CacheRequestImpl(final DiskLruCache.Editor editor) {
+    CacheRequestImpl(final DiskLruCache.Editor editor) {
       this.editor = editor;
       this.cacheOut = editor.newSink(ENTRY_BODY);
       this.body = new ForwardingSink(cacheOut) {
@@ -484,7 +485,7 @@ public CacheRequestImpl(final DiskLruCache.Editor editor) {
     private final int code;
     private final String message;
     private final Headers responseHeaders;
-    private final Handshake handshake;
+    private final @Nullable Handshake handshake;
     private final long sentRequestMillis;
     private final long receivedResponseMillis;
 
@@ -536,7 +537,7 @@ public CacheRequestImpl(final DiskLruCache.Editor editor) {
      * base64-encoded and appear each on their own line. A length of -1 is used to encode a null
      * array. The last line is optional. If present, it contains the TLS version.
      */
-    public Entry(Source in) throws IOException {
+    Entry(Source in) throws IOException {
       try {
         BufferedSource source = Okio.buffer(in);
         url = source.readUtf8LineStrict();
@@ -580,7 +581,7 @@ public Entry(Source in) throws IOException {
           List<Certificate> localCertificates = readCertificateList(source);
           TlsVersion tlsVersion = !source.exhausted()
               ? TlsVersion.forJavaName(source.readUtf8LineStrict())
-              : null;
+              : TlsVersion.SSL_3_0;
           handshake = Handshake.get(tlsVersion, cipherSuite, peerCertificates, localCertificates);
         } else {
           handshake = null;
@@ -590,7 +591,7 @@ public Entry(Source in) throws IOException {
       }
     }
 
-    public Entry(Response response) {
+    Entry(Response response) {
       this.url = response.request().url().toString();
       this.varyHeaders = HttpHeaders.varyHeaders(response);
       this.requestMethod = response.request().method();
@@ -644,11 +645,7 @@ public void writeTo(DiskLruCache.Editor editor) throws IOException {
             .writeByte('\n');
         writeCertList(sink, handshake.peerCertificates());
         writeCertList(sink, handshake.localCertificates());
-        // The handshake’s TLS version is null on HttpsURLConnection and on older cached responses.
-        if (handshake.tlsVersion() != null) {
-          sink.writeUtf8(handshake.tlsVersion().javaName())
-              .writeByte('\n');
-        }
+        sink.writeUtf8(handshake.tlsVersion().javaName()).writeByte('\n');
       }
       sink.close();
     }
@@ -736,10 +733,10 @@ static int readInt(BufferedSource source) throws IOException {
   private static class CacheResponseBody extends ResponseBody {
     final DiskLruCache.Snapshot snapshot;
     private final BufferedSource bodySource;
-    private final String contentType;
-    private final String contentLength;
+    private final @Nullable String contentType;
+    private final @Nullable String contentLength;
 
-    public CacheResponseBody(final DiskLruCache.Snapshot snapshot,
+    CacheResponseBody(final DiskLruCache.Snapshot snapshot,
         String contentType, String contentLength) {
       this.snapshot = snapshot;
       this.contentType = contentType;
diff --git a/okhttp/src/main/java/okhttp3/CacheControl.java b/okhttp/src/main/java/okhttp3/CacheControl.java
index 9dcdbd3c2e..58b17bf405 100644
--- a/okhttp/src/main/java/okhttp3/CacheControl.java
+++ b/okhttp/src/main/java/okhttp3/CacheControl.java
@@ -1,6 +1,7 @@
 package okhttp3;
 
 import java.util.concurrent.TimeUnit;
+import javax.annotation.Nullable;
 import okhttp3.internal.http.HttpHeaders;
 
 /**
@@ -38,12 +39,14 @@
   private final int minFreshSeconds;
   private final boolean onlyIfCached;
   private final boolean noTransform;
+  private final boolean immutable;
 
-  String headerValue; // Lazily computed, null if absent.
+  @Nullable String headerValue; // Lazily computed, null if absent.
 
   private CacheControl(boolean noCache, boolean noStore, int maxAgeSeconds, int sMaxAgeSeconds,
       boolean isPrivate, boolean isPublic, boolean mustRevalidate, int maxStaleSeconds,
-      int minFreshSeconds, boolean onlyIfCached, boolean noTransform, String headerValue) {
+      int minFreshSeconds, boolean onlyIfCached, boolean noTransform, boolean immutable,
+      @Nullable String headerValue) {
     this.noCache = noCache;
     this.noStore = noStore;
     this.maxAgeSeconds = maxAgeSeconds;
@@ -55,10 +58,11 @@ private CacheControl(boolean noCache, boolean noStore, int maxAgeSeconds, int sM
     this.minFreshSeconds = minFreshSeconds;
     this.onlyIfCached = onlyIfCached;
     this.noTransform = noTransform;
+    this.immutable = immutable;
     this.headerValue = headerValue;
   }
 
-  private CacheControl(Builder builder) {
+  CacheControl(Builder builder) {
     this.noCache = builder.noCache;
     this.noStore = builder.noStore;
     this.maxAgeSeconds = builder.maxAgeSeconds;
@@ -70,6 +74,7 @@ private CacheControl(Builder builder) {
     this.minFreshSeconds = builder.minFreshSeconds;
     this.onlyIfCached = builder.onlyIfCached;
     this.noTransform = builder.noTransform;
+    this.immutable = builder.immutable;
   }
 
   /**
@@ -137,6 +142,10 @@ public boolean noTransform() {
     return noTransform;
   }
 
+  public boolean immutable() {
+    return immutable;
+  }
+
   /**
    * Returns the cache directives of {@code headers}. This honors both Cache-Control and Pragma
    * headers if they are present.
@@ -153,6 +162,7 @@ public static CacheControl parse(Headers headers) {
     int minFreshSeconds = -1;
     boolean onlyIfCached = false;
     boolean noTransform = false;
+    boolean immutable = false;
 
     boolean canUseHeaderValue = true;
     String headerValue = null;
@@ -227,6 +237,8 @@ public static CacheControl parse(Headers headers) {
           onlyIfCached = true;
         } else if ("no-transform".equalsIgnoreCase(directive)) {
           noTransform = true;
+        } else if ("immutable".equalsIgnoreCase(directive)) {
+          immutable = true;
         }
       }
     }
@@ -235,7 +247,8 @@ public static CacheControl parse(Headers headers) {
       headerValue = null;
     }
     return new CacheControl(noCache, noStore, maxAgeSeconds, sMaxAgeSeconds, isPrivate, isPublic,
-        mustRevalidate, maxStaleSeconds, minFreshSeconds, onlyIfCached, noTransform, headerValue);
+        mustRevalidate, maxStaleSeconds, minFreshSeconds, onlyIfCached, noTransform, immutable,
+        headerValue);
   }
 
   @Override public String toString() {
@@ -256,6 +269,7 @@ private String headerValue() {
     if (minFreshSeconds != -1) result.append("min-fresh=").append(minFreshSeconds).append(", ");
     if (onlyIfCached) result.append("only-if-cached, ");
     if (noTransform) result.append("no-transform, ");
+    if (immutable) result.append("immutable, ");
     if (result.length() == 0) return "";
     result.delete(result.length() - 2, result.length());
     return result.toString();
@@ -270,6 +284,7 @@ private String headerValue() {
     int minFreshSeconds = -1;
     boolean onlyIfCached;
     boolean noTransform;
+    boolean immutable;
 
     /** Don't accept an unvalidated cached response. */
     public Builder noCache() {
@@ -347,6 +362,11 @@ public Builder noTransform() {
       return this;
     }
 
+    public Builder immutable() {
+      this.immutable = true;
+      return this;
+    }
+
     public CacheControl build() {
       return new CacheControl(this);
     }
diff --git a/okhttp/src/main/java/okhttp3/Call.java b/okhttp/src/main/java/okhttp3/Call.java
index fccf857c13..5b4669ad21 100644
--- a/okhttp/src/main/java/okhttp3/Call.java
+++ b/okhttp/src/main/java/okhttp3/Call.java
@@ -29,8 +29,21 @@
    * Invokes the request immediately, and blocks until the response can be processed or is in
    * error.
    *
+   * <p>To avoid leaking resources callers should close the {@link Response} which in turn will
+   * close the underlying {@link ResponseBody}.
+   *
+   * <pre>@{code
+   *
+   *   // ensure the response (and underlying response body) is closed
+   *   try (Response response = client.newCall(request).execute()) {
+   *     ...
+   *   }
+   *
+   * }</pre>
+   *
    * <p>The caller may read the response body with the response's {@link Response#body} method. To
-   * avoid leaking resources callers must {@linkplain ResponseBody close the response body}.
+   * avoid leaking resources callers must {@linkplain ResponseBody close the response body} or the
+   * Response.
    *
    * <p>Note that transport-layer success (receiving a HTTP response code, headers and body) does
    * not necessarily indicate application-layer success: {@code response} may still indicate an
diff --git a/okhttp/src/main/java/okhttp3/CertificatePinner.java b/okhttp/src/main/java/okhttp3/CertificatePinner.java
index 855907e2b3..1d8eb97750 100644
--- a/okhttp/src/main/java/okhttp3/CertificatePinner.java
+++ b/okhttp/src/main/java/okhttp3/CertificatePinner.java
@@ -23,6 +23,7 @@
 import java.util.LinkedHashSet;
 import java.util.List;
 import java.util.Set;
+import javax.annotation.Nullable;
 import javax.net.ssl.SSLPeerUnverifiedException;
 import okhttp3.internal.tls.CertificateChainCleaner;
 import okio.ByteString;
@@ -128,14 +129,14 @@
   public static final CertificatePinner DEFAULT = new Builder().build();
 
   private final Set<Pin> pins;
-  private final CertificateChainCleaner certificateChainCleaner;
+  private final @Nullable CertificateChainCleaner certificateChainCleaner;
 
-  private CertificatePinner(Set<Pin> pins, CertificateChainCleaner certificateChainCleaner) {
+  CertificatePinner(Set<Pin> pins, @Nullable CertificateChainCleaner certificateChainCleaner) {
     this.pins = pins;
     this.certificateChainCleaner = certificateChainCleaner;
   }
 
-  @Override public boolean equals(Object other) {
+  @Override public boolean equals(@Nullable Object other) {
     if (other == this) return true;
     return other instanceof CertificatePinner
         && (equal(certificateChainCleaner, ((CertificatePinner) other).certificateChainCleaner)
@@ -286,7 +287,8 @@ static ByteString sha256(X509Certificate x509Certificate) {
     boolean matches(String hostname) {
       if (pattern.startsWith(WILDCARD)) {
         int firstDot = hostname.indexOf('.');
-        return hostname.regionMatches(false, firstDot + 1, canonicalHostname, 0,
+        return (hostname.length() - firstDot - 1) == canonicalHostname.length()
+            && hostname.regionMatches(false, firstDot + 1, canonicalHostname, 0,
             canonicalHostname.length());
       }
 
diff --git a/okhttp/src/main/java/okhttp3/Challenge.java b/okhttp/src/main/java/okhttp3/Challenge.java
index f4bb369c45..196de325b8 100644
--- a/okhttp/src/main/java/okhttp3/Challenge.java
+++ b/okhttp/src/main/java/okhttp3/Challenge.java
@@ -15,7 +15,7 @@
  */
 package okhttp3;
 
-import okhttp3.internal.Util;
+import javax.annotation.Nullable;
 
 /** An RFC 2617 challenge. */
 public final class Challenge {
@@ -23,6 +23,8 @@
   private final String realm;
 
   public Challenge(String scheme, String realm) {
+    if (scheme == null) throw new NullPointerException("scheme == null");
+    if (realm == null) throw new NullPointerException("realm == null");
     this.scheme = scheme;
     this.realm = realm;
   }
@@ -37,16 +39,16 @@ public String realm() {
     return realm;
   }
 
-  @Override public boolean equals(Object o) {
-    return o instanceof Challenge
-        && Util.equal(scheme, ((Challenge) o).scheme)
-        && Util.equal(realm, ((Challenge) o).realm);
+  @Override public boolean equals(@Nullable Object other) {
+    return other instanceof Challenge
+        && ((Challenge) other).scheme.equals(scheme)
+        && ((Challenge) other).realm.equals(realm);
   }
 
   @Override public int hashCode() {
     int result = 29;
-    result = 31 * result + (realm != null ? realm.hashCode() : 0);
-    result = 31 * result + (scheme != null ? scheme.hashCode() : 0);
+    result = 31 * result + realm.hashCode();
+    result = 31 * result + scheme.hashCode();
     return result;
   }
 
diff --git a/okhttp/src/main/java/okhttp3/CipherSuite.java b/okhttp/src/main/java/okhttp3/CipherSuite.java
index a3acd52e2f..a71ddc5ed9 100644
--- a/okhttp/src/main/java/okhttp3/CipherSuite.java
+++ b/okhttp/src/main/java/okhttp3/CipherSuite.java
@@ -15,8 +15,12 @@
  */
 package okhttp3;
 
-import java.util.concurrent.ConcurrentHashMap;
-import java.util.concurrent.ConcurrentMap;
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.Comparator;
+import java.util.List;
+import java.util.Map;
+import java.util.TreeMap;
 
 /**
  * <a href="https://www.iana.org/assignments/tls-parameters/tls-parameters.xhtml">TLS cipher
@@ -31,11 +35,30 @@
  * from conscrypt, which lists the cipher suites supported by Android.
  */
 public final class CipherSuite {
+  /**
+   * Compares cipher suites names like "TLS_RSA_WITH_NULL_MD5" and "SSL_RSA_WITH_NULL_MD5", ignoring
+   * the "TLS_" or "SSL_" prefix which is not consistent across platforms. In particular some IBM
+   * JVMs use the "SSL_" prefix everywhere whereas Oracle JVMs mix "TLS_" and "SSL_".
+   */
+  static final Comparator<String> ORDER_BY_NAME = new Comparator<String>() {
+    @Override public int compare(String a, String b) {
+      for (int i = 4, limit = Math.min(a.length(), b.length()); i < limit; i++) {
+        char charA = a.charAt(i);
+        char charB = b.charAt(i);
+        if (charA != charB) return charA < charB ? -1 : 1;
+      }
+      int lengthA = a.length();
+      int lengthB = b.length();
+      if (lengthA != lengthB) return lengthA < lengthB ? -1 : 1;
+      return 0;
+    }
+  };
+
   /**
    * Holds interned instances. This needs to be above the of() calls below so that it's
-   * initialized by the time those parts of {@code <clinit>()} run.
+   * initialized by the time those parts of {@code <clinit>()} run. Guarded by CipherSuite.class.
    */
-  private static final ConcurrentMap<String, CipherSuite> INSTANCES = new ConcurrentHashMap<>();
+  private static final Map<String, CipherSuite> INSTANCES = new TreeMap<>(ORDER_BY_NAME);
 
   // Last updated 2016-07-03 using cipher suites from Android 24 and Java 9.
 
@@ -370,18 +393,25 @@
 
   /**
    * @param javaName the name used by Java APIs for this cipher suite. Different than the IANA name
-   * for older cipher suites because the prefix is {@code SSL_} instead of {@code TLS_}.
+   *     for older cipher suites because the prefix is {@code SSL_} instead of {@code TLS_}.
    */
-  public static CipherSuite forJavaName(String javaName) {
+  public static synchronized CipherSuite forJavaName(String javaName) {
     CipherSuite result = INSTANCES.get(javaName);
     if (result == null) {
-      CipherSuite sample = new CipherSuite(javaName);
-      CipherSuite canonical = INSTANCES.putIfAbsent(javaName, sample);
-      result = (canonical == null) ? sample : canonical;
+      result = new CipherSuite(javaName);
+      INSTANCES.put(javaName, result);
     }
     return result;
   }
 
+  static List<CipherSuite> forJavaNames(String... cipherSuites) {
+    List<CipherSuite> result = new ArrayList<>(cipherSuites.length);
+    for (String cipherSuite : cipherSuites) {
+      result.add(forJavaName(cipherSuite));
+    }
+    return Collections.unmodifiableList(result);
+  }
+
   private CipherSuite(String javaName) {
     if (javaName == null) {
       throw new NullPointerException();
@@ -391,7 +421,7 @@ private CipherSuite(String javaName) {
 
   /**
    * @param javaName the name used by Java APIs for this cipher suite. Different than the IANA name
-   * for older cipher suites because the prefix is {@code SSL_} instead of {@code TLS_}.
+   *     for older cipher suites because the prefix is {@code SSL_} instead of {@code TLS_}.
    * @param value the integer identifier for this cipher suite. (Documentation only.)
    */
   private static CipherSuite of(String javaName, int value) {
diff --git a/okhttp/src/main/java/okhttp3/Connection.java b/okhttp/src/main/java/okhttp3/Connection.java
index d07e861d8f..9fe9bbd889 100644
--- a/okhttp/src/main/java/okhttp3/Connection.java
+++ b/okhttp/src/main/java/okhttp3/Connection.java
@@ -17,6 +17,7 @@
 package okhttp3;
 
 import java.net.Socket;
+import javax.annotation.Nullable;
 
 /**
  * The sockets and streams of an HTTP, HTTPS, or HTTPS+HTTP/2 connection. May be used for multiple
@@ -82,7 +83,7 @@
    * Returns the TLS handshake used to establish this connection, or null if the connection is not
    * HTTPS.
    */
-  Handshake handshake();
+  @Nullable Handshake handshake();
 
   /**
    * Returns the protocol negotiated by this connection, or {@link Protocol#HTTP_1_1} if no protocol
diff --git a/okhttp/src/main/java/okhttp3/ConnectionPool.java b/okhttp/src/main/java/okhttp3/ConnectionPool.java
index dcbc0b441e..6e305ab7bd 100644
--- a/okhttp/src/main/java/okhttp3/ConnectionPool.java
+++ b/okhttp/src/main/java/okhttp3/ConnectionPool.java
@@ -17,6 +17,7 @@
 package okhttp3;
 
 import java.lang.ref.Reference;
+import java.net.Socket;
 import java.util.ArrayDeque;
 import java.util.ArrayList;
 import java.util.Deque;
@@ -26,6 +27,7 @@
 import java.util.concurrent.SynchronousQueue;
 import java.util.concurrent.ThreadPoolExecutor;
 import java.util.concurrent.TimeUnit;
+import javax.annotation.Nullable;
 import okhttp3.internal.Util;
 import okhttp3.internal.connection.RealConnection;
 import okhttp3.internal.connection.RouteDatabase;
@@ -113,13 +115,14 @@ public synchronized int connectionCount() {
     return connections.size();
   }
 
-  /** Returns a recycled connection to {@code address}, or null if no such connection exists. */
-  RealConnection get(Address address, StreamAllocation streamAllocation) {
+  /**
+   * Returns a recycled connection to {@code address}, or null if no such connection exists. The
+   * route is null if the address has not yet been routed.
+   */
+  @Nullable RealConnection get(Address address, StreamAllocation streamAllocation, Route route) {
     assert (Thread.holdsLock(this));
     for (RealConnection connection : connections) {
-      if (connection.allocations.size() < connection.allocationLimit
-          && address.equals(connection.route().address)
-          && !connection.noNewStreams) {
+      if (connection.isEligible(address, route)) {
         streamAllocation.acquire(connection);
         return connection;
       }
@@ -127,6 +130,22 @@ RealConnection get(Address address, StreamAllocation streamAllocation) {
     return null;
   }
 
+  /**
+   * Replaces the connection held by {@code streamAllocation} with a shared connection if possible.
+   * This recovers when multiple multiplexed connections are created concurrently.
+   */
+  @Nullable Socket deduplicate(Address address, StreamAllocation streamAllocation) {
+    assert (Thread.holdsLock(this));
+    for (RealConnection connection : connections) {
+      if (connection.isEligible(address, null)
+          && connection.isMultiplexed()
+          && connection != streamAllocation.connection()) {
+        return streamAllocation.releaseAndAcquire(connection);
+      }
+    }
+    return null;
+  }
+
   void put(RealConnection connection) {
     assert (Thread.holdsLock(this));
     if (!cleanupRunning) {
diff --git a/okhttp/src/main/java/okhttp3/ConnectionSpec.java b/okhttp/src/main/java/okhttp3/ConnectionSpec.java
index a229e2dd00..25b9ee328b 100644
--- a/okhttp/src/main/java/okhttp3/ConnectionSpec.java
+++ b/okhttp/src/main/java/okhttp3/ConnectionSpec.java
@@ -15,15 +15,16 @@
  */
 package okhttp3;
 
-import java.util.ArrayList;
 import java.util.Arrays;
-import java.util.Collections;
 import java.util.List;
+import javax.annotation.Nullable;
 import javax.net.ssl.SSLSocket;
+import okhttp3.internal.Util;
 
 import static okhttp3.internal.Util.concat;
 import static okhttp3.internal.Util.indexOf;
 import static okhttp3.internal.Util.intersect;
+import static okhttp3.internal.Util.nonEmptyIntersection;
 
 /**
  * Specifies configuration for the socket connection that HTTP traffic travels through. For {@code
@@ -80,12 +81,12 @@
   /** Unencrypted, unauthenticated connections for {@code http:} URLs. */
   public static final ConnectionSpec CLEARTEXT = new Builder(false).build();
 
-  private final boolean tls;
-  private final boolean supportsTlsExtensions;
-  private final String[] cipherSuites;
-  private final String[] tlsVersions;
+  final boolean tls;
+  final boolean supportsTlsExtensions;
+  final @Nullable String[] cipherSuites;
+  final @Nullable String[] tlsVersions;
 
-  private ConnectionSpec(Builder builder) {
+  ConnectionSpec(Builder builder) {
     this.tls = builder.tls;
     this.cipherSuites = builder.cipherSuites;
     this.tlsVersions = builder.tlsVersions;
@@ -97,31 +98,19 @@ public boolean isTls() {
   }
 
   /**
-   * Returns the cipher suites to use for a connection. Returns {@code null} if all of the SSL
-   * socket's enabled cipher suites should be used.
+   * Returns the cipher suites to use for a connection. Returns null if all of the SSL socket's
+   * enabled cipher suites should be used.
    */
-  public List<CipherSuite> cipherSuites() {
-    if (cipherSuites == null) return null;
-
-    List<CipherSuite> result = new ArrayList<>(cipherSuites.length);
-    for (String cipherSuite : cipherSuites) {
-      result.add(CipherSuite.forJavaName(cipherSuite));
-    }
-    return Collections.unmodifiableList(result);
+  public @Nullable List<CipherSuite> cipherSuites() {
+    return cipherSuites != null ? CipherSuite.forJavaNames(cipherSuites) : null;
   }
 
   /**
-   * Returns the TLS versions to use when negotiating a connection. Returns {@code null} if all of
-   * the SSL socket's enabled TLS versions should be used.
+   * Returns the TLS versions to use when negotiating a connection. Returns null if all of the SSL
+   * socket's enabled TLS versions should be used.
    */
-  public List<TlsVersion> tlsVersions() {
-    if (tlsVersions == null) return null;
-
-    List<TlsVersion> result = new ArrayList<>(tlsVersions.length);
-    for (String tlsVersion : tlsVersions) {
-      result.add(TlsVersion.forJavaName(tlsVersion));
-    }
-    return Collections.unmodifiableList(result);
+  public @Nullable List<TlsVersion> tlsVersions() {
+    return tlsVersions != null ? TlsVersion.forJavaNames(tlsVersions) : null;
   }
 
   public boolean supportsTlsExtensions() {
@@ -146,16 +135,20 @@ void apply(SSLSocket sslSocket, boolean isFallback) {
    */
   private ConnectionSpec supportedSpec(SSLSocket sslSocket, boolean isFallback) {
     String[] cipherSuitesIntersection = cipherSuites != null
-        ? intersect(String.class, cipherSuites, sslSocket.getEnabledCipherSuites())
+        ? intersect(CipherSuite.ORDER_BY_NAME, sslSocket.getEnabledCipherSuites(), cipherSuites)
         : sslSocket.getEnabledCipherSuites();
     String[] tlsVersionsIntersection = tlsVersions != null
-        ? intersect(String.class, tlsVersions, sslSocket.getEnabledProtocols())
+        ? intersect(Util.NATURAL_ORDER, sslSocket.getEnabledProtocols(), tlsVersions)
         : sslSocket.getEnabledProtocols();
 
     // In accordance with https://tools.ietf.org/html/draft-ietf-tls-downgrade-scsv-00
     // the SCSV cipher is added to signal that a protocol fallback has taken place.
-    if (isFallback && indexOf(sslSocket.getSupportedCipherSuites(), "TLS_FALLBACK_SCSV") != -1) {
-      cipherSuitesIntersection = concat(cipherSuitesIntersection, "TLS_FALLBACK_SCSV");
+    String[] supportedCipherSuites = sslSocket.getSupportedCipherSuites();
+    int indexOfFallbackScsv = indexOf(
+        CipherSuite.ORDER_BY_NAME, supportedCipherSuites, "TLS_FALLBACK_SCSV");
+    if (isFallback && indexOfFallbackScsv != -1) {
+      cipherSuitesIntersection = concat(
+          cipherSuitesIntersection, supportedCipherSuites[indexOfFallbackScsv]);
     }
 
     return new Builder(this)
@@ -180,37 +173,20 @@ public boolean isCompatible(SSLSocket socket) {
       return false;
     }
 
-    if (tlsVersions != null
-        && !nonEmptyIntersection(tlsVersions, socket.getEnabledProtocols())) {
+    if (tlsVersions != null && !nonEmptyIntersection(
+        Util.NATURAL_ORDER, tlsVersions, socket.getEnabledProtocols())) {
       return false;
     }
 
-    if (cipherSuites != null
-        && !nonEmptyIntersection(cipherSuites, socket.getEnabledCipherSuites())) {
+    if (cipherSuites != null && !nonEmptyIntersection(
+        CipherSuite.ORDER_BY_NAME, cipherSuites, socket.getEnabledCipherSuites())) {
       return false;
     }
 
     return true;
   }
 
-  /**
-   * An N*M intersection that terminates if any intersection is found. The sizes of both arguments
-   * are assumed to be so small, and the likelihood of an intersection so great, that it is not
-   * worth the CPU cost of sorting or the memory cost of hashing.
-   */
-  private static boolean nonEmptyIntersection(String[] a, String[] b) {
-    if (a == null || b == null || a.length == 0 || b.length == 0) {
-      return false;
-    }
-    for (String toFind : a) {
-      if (indexOf(b, toFind) != -1) {
-        return true;
-      }
-    }
-    return false;
-  }
-
-  @Override public boolean equals(Object other) {
+  @Override public boolean equals(@Nullable Object other) {
     if (!(other instanceof ConnectionSpec)) return false;
     if (other == this) return true;
 
@@ -251,10 +227,10 @@ private static boolean nonEmptyIntersection(String[] a, String[] b) {
   }
 
   public static final class Builder {
-    private boolean tls;
-    private String[] cipherSuites;
-    private String[] tlsVersions;
-    private boolean supportsTlsExtensions;
+    boolean tls;
+    @Nullable String[] cipherSuites;
+    @Nullable String[] tlsVersions;
+    boolean supportsTlsExtensions;
 
     Builder(boolean tls) {
       this.tls = tls;
diff --git a/okhttp/src/main/java/okhttp3/Cookie.java b/okhttp/src/main/java/okhttp3/Cookie.java
index df882c01ab..a20cac407d 100644
--- a/okhttp/src/main/java/okhttp3/Cookie.java
+++ b/okhttp/src/main/java/okhttp3/Cookie.java
@@ -24,12 +24,15 @@
 import java.util.Locale;
 import java.util.regex.Matcher;
 import java.util.regex.Pattern;
+import javax.annotation.Nullable;
 import okhttp3.internal.Util;
 import okhttp3.internal.http.HttpDate;
+import okhttp3.internal.publicsuffix.PublicSuffixDatabase;
 
 import static okhttp3.internal.Util.UTC;
 import static okhttp3.internal.Util.delimiterOffset;
 import static okhttp3.internal.Util.domainToAscii;
+import static okhttp3.internal.Util.indexOfControlOrNonAscii;
 import static okhttp3.internal.Util.trimSubstring;
 import static okhttp3.internal.Util.verifyAsIpAddress;
 
@@ -74,7 +77,7 @@ private Cookie(String name, String value, long expiresAt, String domain, String
     this.persistent = persistent;
   }
 
-  private Cookie(Builder builder) {
+  Cookie(Builder builder) {
     if (builder.name == null) throw new NullPointerException("builder.name == null");
     if (builder.value == null) throw new NullPointerException("builder.value == null");
     if (builder.domain == null) throw new NullPointerException("builder.domain == null");
@@ -169,7 +172,7 @@ public boolean secure() {
   public boolean matches(HttpUrl url) {
     boolean domainMatch = hostOnly
         ? url.host().equals(domain)
-        : domainMatch(url, domain);
+        : domainMatch(url.host(), domain);
     if (!domainMatch) return false;
 
     if (!pathMatch(url, path)) return false;
@@ -179,9 +182,7 @@ public boolean matches(HttpUrl url) {
     return true;
   }
 
-  private static boolean domainMatch(HttpUrl url, String domain) {
-    String urlHost = url.host();
-
+  private static boolean domainMatch(String urlHost, String domain) {
     if (urlHost.equals(domain)) {
       return true; // As in 'example.com' matching 'example.com'.
     }
@@ -214,11 +215,11 @@ private static boolean pathMatch(HttpUrl url, String path) {
    * Attempt to parse a {@code Set-Cookie} HTTP header value {@code setCookie} as a cookie. Returns
    * null if {@code setCookie} is not a well-formed cookie.
    */
-  public static Cookie parse(HttpUrl url, String setCookie) {
+  public static @Nullable Cookie parse(HttpUrl url, String setCookie) {
     return parse(System.currentTimeMillis(), url, setCookie);
   }
 
-  static Cookie parse(long currentTimeMillis, HttpUrl url, String setCookie) {
+  static @Nullable Cookie parse(long currentTimeMillis, HttpUrl url, String setCookie) {
     int pos = 0;
     int limit = setCookie.length();
     int cookiePairEnd = delimiterOffset(setCookie, pos, limit, ';');
@@ -227,9 +228,10 @@ static Cookie parse(long currentTimeMillis, HttpUrl url, String setCookie) {
     if (pairEqualsSign == cookiePairEnd) return null;
 
     String cookieName = trimSubstring(setCookie, pos, pairEqualsSign);
-    if (cookieName.isEmpty()) return null;
+    if (cookieName.isEmpty() || indexOfControlOrNonAscii(cookieName) != -1) return null;
 
     String cookieValue = trimSubstring(setCookie, pairEqualsSign + 1, cookiePairEnd);
+    if (indexOfControlOrNonAscii(cookieValue) != -1) return null;
 
     long expiresAt = HttpDate.MAX_DATE;
     long deltaSeconds = -1L;
@@ -297,12 +299,19 @@ static Cookie parse(long currentTimeMillis, HttpUrl url, String setCookie) {
     }
 
     // If the domain is present, it must domain match. Otherwise we have a host-only cookie.
+    String urlHost = url.host();
     if (domain == null) {
-      domain = url.host();
-    } else if (!domainMatch(url, domain)) {
+      domain = urlHost;
+    } else if (!domainMatch(urlHost, domain)) {
       return null; // No domain match? This is either incompetence or malice!
     }
 
+    // If the domain is a suffix of the url host, it must not be a public suffix.
+    if (urlHost.length() != domain.length()
+        && PublicSuffixDatabase.get().getEffectiveTldPlusOne(domain) == null) {
+      return null;
+    }
+
     // If the path is absent or didn't start with '/', use the default path. It's a string like
     // '/foo/bar' for a URL like 'http://example.com/foo/bar/baz'. It always starts with '/'.
     if (path == null || !path.startsWith("/")) {
@@ -573,7 +582,7 @@ String toString(boolean forObsoleteRfc2965) {
     return result.toString();
   }
 
-  @Override public boolean equals(Object other) {
+  @Override public boolean equals(@Nullable Object other) {
     if (!(other instanceof Cookie)) return false;
     Cookie that = (Cookie) other;
     return that.name.equals(name)
diff --git a/okhttp/src/main/java/okhttp3/CookieJar.java b/okhttp/src/main/java/okhttp3/CookieJar.java
index d2cdfce22a..bdb3cd552e 100644
--- a/okhttp/src/main/java/okhttp3/CookieJar.java
+++ b/okhttp/src/main/java/okhttp3/CookieJar.java
@@ -22,7 +22,7 @@
  * Provides <strong>policy</strong> and <strong>persistence</strong> for HTTP cookies.
  *
  * <p>As policy, implementations of this interface are responsible for selecting which cookies to
- * accept and which to reject. A reasonable policy is to reject all cookies, though that may be
+ * accept and which to reject. A reasonable policy is to reject all cookies, though that may
  * interfere with session-based authentication schemes that require cookies.
  *
  * <p>As persistence, implementations of this interface must also provide storage of cookies. Simple
diff --git a/okhttp/src/main/java/okhttp3/Credentials.java b/okhttp/src/main/java/okhttp3/Credentials.java
index 9be4e6a22f..c88c44e505 100644
--- a/okhttp/src/main/java/okhttp3/Credentials.java
+++ b/okhttp/src/main/java/okhttp3/Credentials.java
@@ -15,7 +15,7 @@
  */
 package okhttp3;
 
-import java.io.UnsupportedEncodingException;
+import java.nio.charset.Charset;
 import okio.ByteString;
 
 /** Factory for HTTP authorization credentials. */
@@ -25,13 +25,13 @@ private Credentials() {
 
   /** Returns an auth credential for the Basic scheme. */
   public static String basic(String userName, String password) {
-    try {
-      String usernameAndPassword = userName + ":" + password;
-      byte[] bytes = usernameAndPassword.getBytes("ISO-8859-1");
-      String encoded = ByteString.of(bytes).base64();
-      return "Basic " + encoded;
-    } catch (UnsupportedEncodingException e) {
-      throw new AssertionError();
-    }
+    return basic(userName, password, Charset.forName("ISO-8859-1"));
+  }
+
+  public static String basic(String userName, String password, Charset charset) {
+    String usernameAndPassword = userName + ":" + password;
+    byte[] bytes = usernameAndPassword.getBytes(charset);
+    String encoded = ByteString.of(bytes).base64();
+    return "Basic " + encoded;
   }
 }
diff --git a/okhttp/src/main/java/okhttp3/Dispatcher.java b/okhttp/src/main/java/okhttp3/Dispatcher.java
index d6f90bb3ac..43f5aa48e7 100644
--- a/okhttp/src/main/java/okhttp3/Dispatcher.java
+++ b/okhttp/src/main/java/okhttp3/Dispatcher.java
@@ -25,6 +25,7 @@
 import java.util.concurrent.SynchronousQueue;
 import java.util.concurrent.ThreadPoolExecutor;
 import java.util.concurrent.TimeUnit;
+import javax.annotation.Nullable;
 import okhttp3.RealCall.AsyncCall;
 import okhttp3.internal.Util;
 
@@ -38,10 +39,10 @@
 public final class Dispatcher {
   private int maxRequests = 64;
   private int maxRequestsPerHost = 5;
-  private Runnable idleCallback;
+  private @Nullable Runnable idleCallback;
 
   /** Executes calls. Created lazily. */
-  private ExecutorService executorService;
+  private @Nullable ExecutorService executorService;
 
   /** Ready async calls in the order they'll be run. */
   private final Deque<AsyncCall> readyAsyncCalls = new ArrayDeque<>();
@@ -119,7 +120,7 @@ public synchronized int getMaxRequestsPerHost() {
    * means that if you are doing synchronous calls the network layer will not truly be idle until
    * every returned {@link Response} has been closed.
    */
-  public synchronized void setIdleCallback(Runnable idleCallback) {
+  public synchronized void setIdleCallback(@Nullable Runnable idleCallback) {
     this.idleCallback = idleCallback;
   }
 
diff --git a/okhttp/src/main/java/okhttp3/EventListener.java b/okhttp/src/main/java/okhttp3/EventListener.java
new file mode 100644
index 0000000000..3c64409d38
--- /dev/null
+++ b/okhttp/src/main/java/okhttp3/EventListener.java
@@ -0,0 +1,141 @@
+/*
+ * Copyright (C) 2017 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3;
+
+import java.net.InetAddress;
+import java.util.List;
+import javax.annotation.Nullable;
+
+public abstract class EventListener {
+  public static final EventListener NONE = new EventListener() {
+  };
+
+  static EventListener.Factory factory(final EventListener listener) {
+    return new EventListener.Factory() {
+      public EventListener create(Call call) {
+        return listener;
+      }
+    };
+  }
+
+  public void fetchStart(Call call) {
+  }
+
+  /**
+   * Invoked just prior to a DNS lookup. See {@link Dns#lookup(String)}.
+   *
+   * <p>This can be invoked more than 1 time for a single {@link Call}. For example, if the response
+   * to the {@link Call#request()} is a redirect to a different host.
+   *
+   * <p>If the {@link Call} is able to reuse an existing pooled connection, this method will not be
+   * invoked. See {@link ConnectionPool}.
+   */
+  public void dnsStart(Call call, String domainName) {
+  }
+
+  /**
+   * Invoked immediately after a DNS lookup.
+   *
+   * <p>This method is always invoked after {@link #dnsStart(Call, String)}.
+   *
+   * <p>{@code inetAddressList} will be non-null and {@code throwable} will be null in the case of a
+   * successful DNS lookup.
+   *
+   * <p>{@code inetAddressList} will be null and {@code throwable} will be non-null in the case of a
+   * failed DNS lookup.
+   */
+  public void dnsEnd(Call call, String domainName, @Nullable List<InetAddress> inetAddressList,
+      @Nullable Throwable throwable) {
+  }
+
+  public void connectStart(Call call, InetAddress address, int port) {
+  }
+
+  /**
+   * Invoked just prior to initiating a TLS connection.
+   *
+   * <p>This method is invoked if the following conditions are met:
+   * <ul>
+   *   <li>The {@link Call#request()} requires TLS.</li>
+   *   <li>No existing connection from the {@link ConnectionPool} can be reused.</li>
+   * </ul>
+   *
+   * <p>This can be invoked more than 1 time for a single {@link Call}. For example, if the response
+   * to the {@link Call#request()} is a redirect to a different address, or a connection is retried.
+   */
+  public void secureConnectStart(Call call) {
+  }
+
+  /**
+   * Invoked immediately after a TLS connection was attempted.
+   *
+   * <p>This method is always invoked after {@link #secureConnectStart(Call)}.
+   *
+   * <p>{@code handshake} will be non-null and {@code throwable} will be null in the case of a
+   * successful TLS connection.
+   *
+   * <p>{@code handshake} will be null and {@code throwable} will be non-null in the case of a
+   * failed TLS connection attempt.
+   */
+  public void secureConnectEnd(Call call, @Nullable Handshake handshake,
+      @Nullable Throwable throwable) {
+  }
+
+  public void connectEnd(Call call,  InetAddress address, int port, String protocol,
+      Throwable throwable) {
+  }
+
+  public void requestHeadersStart(Call call) {
+  }
+
+  public void requestHeadersEnd(Call call, Throwable throwable) {
+  }
+
+  public void requestBodyStart(Call call) {
+  }
+
+  public void requestBodyEnd(Call call, Throwable throwable) {
+  }
+
+  public void responseHeadersStart(Call call) {
+  }
+
+  public void responseHeadersEnd(Call call, Throwable throwable) {
+  }
+
+  public void responseBodyStart(Call call) {
+  }
+
+  public void responseBodyEnd(Call call, Throwable throwable) {
+  }
+
+  public void fetchEnd(Call call, Throwable throwable) {
+  }
+
+  public interface Factory {
+    /**
+     * Creates an instance of the {@link EventListener} for a particular {@link Call}. The returned
+     * {@link EventListener} instance will be used during the lifecycle of the {@code call}.
+     *
+     * <p>This method is invoked after the {@code call} is created. See
+     * {@link OkHttpClient#newCall(Request)}.
+     *
+     * <p><strong>It is an error for implementations to issue any mutating operations on the
+     * {@code call} instance from this method.</strong>
+     */
+    EventListener create(Call call);
+  }
+}
diff --git a/okhttp/src/main/java/okhttp3/FormBody.java b/okhttp/src/main/java/okhttp3/FormBody.java
index 95181b1f76..1b8d51f070 100644
--- a/okhttp/src/main/java/okhttp3/FormBody.java
+++ b/okhttp/src/main/java/okhttp3/FormBody.java
@@ -18,6 +18,7 @@
 import java.io.IOException;
 import java.util.ArrayList;
 import java.util.List;
+import javax.annotation.Nullable;
 import okhttp3.internal.Util;
 import okio.Buffer;
 import okio.BufferedSink;
@@ -32,7 +33,7 @@
   private final List<String> encodedNames;
   private final List<String> encodedValues;
 
-  private FormBody(List<String> encodedNames, List<String> encodedValues) {
+  FormBody(List<String> encodedNames, List<String> encodedValues) {
     this.encodedNames = Util.immutableList(encodedNames);
     this.encodedValues = Util.immutableList(encodedValues);
   }
@@ -76,7 +77,7 @@ public String value(int index) {
    * to awkward operations like measuring the encoded length of header strings, or the
    * length-in-digits of an encoded integer.
    */
-  private long writeOrCountBytes(BufferedSink sink, boolean countBytes) {
+  private long writeOrCountBytes(@Nullable BufferedSink sink, boolean countBytes) {
     long byteCount = 0L;
 
     Buffer buffer;
diff --git a/okhttp/src/main/java/okhttp3/Handshake.java b/okhttp/src/main/java/okhttp3/Handshake.java
index d2c08be57e..59a5418b86 100644
--- a/okhttp/src/main/java/okhttp3/Handshake.java
+++ b/okhttp/src/main/java/okhttp3/Handshake.java
@@ -20,6 +20,7 @@
 import java.security.cert.X509Certificate;
 import java.util.Collections;
 import java.util.List;
+import javax.annotation.Nullable;
 import javax.net.ssl.SSLPeerUnverifiedException;
 import javax.net.ssl.SSLSession;
 import okhttp3.internal.Util;
@@ -74,14 +75,15 @@ public static Handshake get(SSLSession session) {
 
   public static Handshake get(TlsVersion tlsVersion, CipherSuite cipherSuite,
       List<Certificate> peerCertificates, List<Certificate> localCertificates) {
+    if (tlsVersion == null) throw new NullPointerException("tlsVersion == null");
     if (cipherSuite == null) throw new NullPointerException("cipherSuite == null");
     return new Handshake(tlsVersion, cipherSuite, Util.immutableList(peerCertificates),
         Util.immutableList(localCertificates));
   }
 
   /**
-   * Returns the TLS version used for this connection. May return null if the response was cached
-   * with a version of OkHttp prior to 3.0.
+   * Returns the TLS version used for this connection. This value wasn't tracked prior to OkHttp
+   * 3.0. For responses cached by preceding versions this returns {@link TlsVersion#SSL_3_0}.
    */
   public TlsVersion tlsVersion() {
     return tlsVersion;
@@ -98,7 +100,7 @@ public CipherSuite cipherSuite() {
   }
 
   /** Returns the remote peer's principle, or null if that peer is anonymous. */
-  public Principal peerPrincipal() {
+  public @Nullable Principal peerPrincipal() {
     return !peerCertificates.isEmpty()
         ? ((X509Certificate) peerCertificates.get(0)).getSubjectX500Principal()
         : null;
@@ -110,16 +112,16 @@ public Principal peerPrincipal() {
   }
 
   /** Returns the local principle, or null if this peer is anonymous. */
-  public Principal localPrincipal() {
+  public @Nullable Principal localPrincipal() {
     return !localCertificates.isEmpty()
         ? ((X509Certificate) localCertificates.get(0)).getSubjectX500Principal()
         : null;
   }
 
-  @Override public boolean equals(Object other) {
+  @Override public boolean equals(@Nullable Object other) {
     if (!(other instanceof Handshake)) return false;
     Handshake that = (Handshake) other;
-    return Util.equal(cipherSuite, that.cipherSuite)
+    return tlsVersion.equals(that.tlsVersion)
         && cipherSuite.equals(that.cipherSuite)
         && peerCertificates.equals(that.peerCertificates)
         && localCertificates.equals(that.localCertificates);
@@ -127,7 +129,7 @@ public Principal localPrincipal() {
 
   @Override public int hashCode() {
     int result = 17;
-    result = 31 * result + (tlsVersion != null ? tlsVersion.hashCode() : 0);
+    result = 31 * result + tlsVersion.hashCode();
     result = 31 * result + cipherSuite.hashCode();
     result = 31 * result + peerCertificates.hashCode();
     result = 31 * result + localCertificates.hashCode();
diff --git a/okhttp/src/main/java/okhttp3/Headers.java b/okhttp/src/main/java/okhttp3/Headers.java
index e6c7c359b5..18342c2f0d 100644
--- a/okhttp/src/main/java/okhttp3/Headers.java
+++ b/okhttp/src/main/java/okhttp3/Headers.java
@@ -27,6 +27,7 @@
 import java.util.Set;
 import java.util.TreeMap;
 import java.util.TreeSet;
+import javax.annotation.Nullable;
 import okhttp3.internal.Util;
 import okhttp3.internal.http.HttpDate;
 
@@ -49,7 +50,7 @@
 public final class Headers {
   private final String[] namesAndValues;
 
-  private Headers(Builder builder) {
+  Headers(Builder builder) {
     this.namesAndValues = builder.namesAndValues.toArray(new String[builder.namesAndValues.size()]);
   }
 
@@ -58,7 +59,7 @@ private Headers(String[] namesAndValues) {
   }
 
   /** Returns the last value corresponding to the specified field, or null. */
-  public String get(String name) {
+  public @Nullable String get(String name) {
     return get(namesAndValues, name);
   }
 
@@ -66,7 +67,7 @@ public String get(String name) {
    * Returns the last value corresponding to the specified field parsed as an HTTP date, or null if
    * either the field is absent or cannot be parsed as a date.
    */
-  public Date getDate(String name) {
+  public @Nullable Date getDate(String name) {
     String value = get(name);
     return value != null ? HttpDate.parse(value) : null;
   }
@@ -141,7 +142,7 @@ public Builder newBuilder() {
    * Applications that require semantically equal headers should convert them into a canonical form
    * before comparing them for equality.
    */
-  @Override public boolean equals(Object other) {
+  @Override public boolean equals(@Nullable Object other) {
     return other instanceof Headers
         && Arrays.equals(((Headers) other).namesAndValues, namesAndValues);
   }
@@ -237,7 +238,7 @@ public static Headers of(Map<String, String> headers) {
   }
 
   public static final class Builder {
-    private final List<String> namesAndValues = new ArrayList<>(20);
+    final List<String> namesAndValues = new ArrayList<>(20);
 
     /**
      * Add a header line without any validation. Only appropriate for headers from the remote peer
@@ -308,15 +309,15 @@ private void checkNameAndValue(String name, String value) {
       if (name.isEmpty()) throw new IllegalArgumentException("name is empty");
       for (int i = 0, length = name.length(); i < length; i++) {
         char c = name.charAt(i);
-        if (c <= '\u001f' || c >= '\u007f') {
+        if (c <= '\u0020' || c >= '\u007f') {
           throw new IllegalArgumentException(Util.format(
               "Unexpected char %#04x at %d in header name: %s", (int) c, i, name));
         }
       }
-      if (value == null) throw new NullPointerException("value == null");
+      if (value == null) throw new NullPointerException("value for name " + name + " == null");
       for (int i = 0, length = value.length(); i < length; i++) {
         char c = value.charAt(i);
-        if ((c <= '\u001f' && c != '\u0009' /* htab */) || c >= '\u007f') {
+        if ((c <= '\u001f' && c != '\t') || c >= '\u007f') {
           throw new IllegalArgumentException(Util.format(
               "Unexpected char %#04x at %d in %s value: %s", (int) c, i, name, value));
         }
diff --git a/okhttp/src/main/java/okhttp3/HttpUrl.java b/okhttp/src/main/java/okhttp3/HttpUrl.java
index deadf39ba0..555c4bd1ed 100644
--- a/okhttp/src/main/java/okhttp3/HttpUrl.java
+++ b/okhttp/src/main/java/okhttp3/HttpUrl.java
@@ -27,12 +27,15 @@
 import java.util.LinkedHashSet;
 import java.util.List;
 import java.util.Set;
+import javax.annotation.Nullable;
+import okhttp3.internal.publicsuffix.PublicSuffixDatabase;
 import okio.Buffer;
 
 import static okhttp3.internal.Util.delimiterOffset;
 import static okhttp3.internal.Util.domainToAscii;
 import static okhttp3.internal.Util.skipLeadingAsciiWhitespace;
 import static okhttp3.internal.Util.skipTrailingAsciiWhitespace;
+import static okhttp3.internal.Util.verifyAsIpAddress;
 
 /**
  * A uniform resource locator (URL) with a scheme of either {@code http} or {@code https}. Use this
@@ -296,7 +299,7 @@
   static final String FRAGMENT_ENCODE_SET_URI = " \"#<>\\^`{|}";
 
   /** Either "http" or "https". */
-  private final String scheme;
+  final String scheme;
 
   /** Decoded username. */
   private final String username;
@@ -305,10 +308,10 @@
   private final String password;
 
   /** Canonical hostname. */
-  private final String host;
+  final String host;
 
   /** Either 80, 443 or a user-specified port. In range [1..65535]. */
-  private final int port;
+  final int port;
 
   /**
    * A list of canonical path segments. This list always contains at least one element, which may be
@@ -322,15 +325,15 @@
    * non-empty, but never null. Values are null if the name has no corresponding '=' separator, or
    * empty, or non-empty.
    */
-  private final List<String> queryNamesAndValues;
+  private final @Nullable List<String> queryNamesAndValues;
 
   /** Decoded fragment. */
-  private final String fragment;
+  private final @Nullable String fragment;
 
   /** Canonical URL. */
   private final String url;
 
-  private HttpUrl(Builder builder) {
+  HttpUrl(Builder builder) {
     this.scheme = builder.scheme;
     this.username = percentDecode(builder.encodedUsername, false);
     this.password = percentDecode(builder.encodedPassword, false);
@@ -604,7 +607,7 @@ static void pathSegmentsToString(StringBuilder out, List<String> pathSegments) {
    *   <tr><td>{@code http://host/?a=apple&b}</td><td>{@code "a=apple&b"}</td></tr>
    * </table>
    */
-  public String encodedQuery() {
+  public @Nullable String encodedQuery() {
     if (queryNamesAndValues == null) return null; // No query.
     int queryStart = url.indexOf('?') + 1;
     int queryEnd = delimiterOffset(url, queryStart + 1, url.length(), '#');
@@ -664,7 +667,7 @@ static void namesAndValuesToQueryString(StringBuilder out, List<String> namesAnd
    *   <tr><td>{@code http://host/?a=apple&b}</td><td>{@code "a=apple&b"}</td></tr>
    * </table>
    */
-  public String query() {
+  public @Nullable String query() {
     if (queryNamesAndValues == null) return null; // No query.
     StringBuilder result = new StringBuilder();
     namesAndValuesToQueryString(result, queryNamesAndValues);
@@ -702,7 +705,7 @@ public int querySize() {
    *   <tr><td>{@code http://host/?a=apple&b}</td><td>{@code "apple"}</td></tr>
    * </table>
    */
-  public String queryParameter(String name) {
+  public @Nullable String queryParameter(String name) {
     if (queryNamesAndValues == null) return null;
     for (int i = 0, size = queryNamesAndValues.size(); i < size; i += 2) {
       if (name.equals(queryNamesAndValues.get(i))) {
@@ -819,7 +822,7 @@ public String queryParameterValue(int index) {
    *   <tr><td>{@code http://host/#abc|def}</td><td>{@code "abc|def"}</td></tr>
    * </table>
    */
-  public String encodedFragment() {
+  public @Nullable String encodedFragment() {
     if (fragment == null) return null;
     int fragmentStart = url.indexOf('#') + 1;
     return url.substring(fragmentStart);
@@ -837,26 +840,28 @@ public String encodedFragment() {
    *   <tr><td>{@code http://host/#abc|def}</td><td>{@code "abc|def"}</td></tr>
    * </table>
    */
-  public String fragment() {
+  public @Nullable String fragment() {
     return fragment;
   }
 
   /**
-   * Returns the HttpUrl with the username, password, path, query, and fragment stripped.
-   * Example: http://username:password@example.com/path returns http://example.com/...
+   * Returns a string with containing this URL with its username, password, query, and fragment
+   * stripped, and its path replaced with {@code /...}. For example, redacting {@code
+   * http://username:password@example.com/path} returns {@code http://example.com/...}.
    */
-  public HttpUrl redact() {
-    Builder builder = newBuilder("/...");
-    builder.username("");
-    builder.password("");
-    return builder.build();
+  public String redact() {
+    return newBuilder("/...")
+        .username("")
+        .password("")
+        .build()
+        .toString();
   }
 
   /**
    * Returns the URL that would be retrieved by following {@code link} from this URL, or null if
    * the resulting URL is not well-formed.
    */
-  public HttpUrl resolve(String link) {
+  public @Nullable HttpUrl resolve(String link) {
     Builder builder = newBuilder(link);
     return builder != null ? builder.build() : null;
   }
@@ -880,7 +885,7 @@ public Builder newBuilder() {
    * Returns a builder for the URL that would be retrieved by following {@code link} from this URL,
    * or null if the resulting URL is not well-formed.
    */
-  public Builder newBuilder(String link) {
+  public @Nullable Builder newBuilder(String link) {
     Builder builder = new Builder();
     Builder.ParseResult result = builder.parse(this, link);
     return result == Builder.ParseResult.SUCCESS ? builder : null;
@@ -890,7 +895,7 @@ public Builder newBuilder(String link) {
    * Returns a new {@code HttpUrl} representing {@code url} if it is a well-formed HTTP or HTTPS
    * URL, or null if it isn't.
    */
-  public static HttpUrl parse(String url) {
+  public static @Nullable HttpUrl parse(String url) {
     Builder builder = new Builder();
     Builder.ParseResult result = builder.parse(null, url);
     return result == Builder.ParseResult.SUCCESS ? builder.build() : null;
@@ -900,7 +905,7 @@ public static HttpUrl parse(String url) {
    * Returns an {@link HttpUrl} for {@code url} if its protocol is {@code http} or {@code https}, or
    * null if it has any other protocol.
    */
-  public static HttpUrl get(URL url) {
+  public static @Nullable HttpUrl get(URL url) {
     return parse(url.toString());
   }
 
@@ -927,12 +932,12 @@ static HttpUrl getChecked(String url) throws MalformedURLException, UnknownHostE
     }
   }
 
-  public static HttpUrl get(URI uri) {
+  public static @Nullable HttpUrl get(URI uri) {
     return parse(uri.toString());
   }
 
-  @Override public boolean equals(Object o) {
-    return o instanceof HttpUrl && ((HttpUrl) o).url.equals(url);
+  @Override public boolean equals(@Nullable Object other) {
+    return other instanceof HttpUrl && ((HttpUrl) other).url.equals(url);
   }
 
   @Override public int hashCode() {
@@ -943,15 +948,39 @@ public static HttpUrl get(URI uri) {
     return url;
   }
 
+  /**
+   * Returns the domain name of this URL's {@link #host()} that is one level beneath the public
+   * suffix by consulting the <a href="https://publicsuffix.org">public suffix list</a>. Returns
+   * null if this URL's {@link #host()} is an IP address or is considered a public suffix by the
+   * public suffix list.
+   *
+   * <p>In general this method <strong>should not</strong> be used to test whether a domain is valid
+   * or routable. Instead, DNS is the recommended source for that information.
+   *
+   * <p><table summary="">
+   *   <tr><th>URL</th><th>{@code topPrivateDomain()}</th></tr>
+   *   <tr><td>{@code http://google.com}</td><td>{@code "google.com"}</td></tr>
+   *   <tr><td>{@code http://adwords.google.co.uk}</td><td>{@code "google.co.uk"}</td></tr>
+   *   <tr><td>{@code http://square}</td><td>null</td></tr>
+   *   <tr><td>{@code http://co.uk}</td><td>null</td></tr>
+   *   <tr><td>{@code http://localhost}</td><td>null</td></tr>
+   *   <tr><td>{@code http://127.0.0.1}</td><td>null</td></tr>
+   * </table>
+   */
+  public @Nullable String topPrivateDomain() {
+    if (verifyAsIpAddress(host)) return null;
+    return PublicSuffixDatabase.get().getEffectiveTldPlusOne(host);
+  }
+
   public static final class Builder {
-    String scheme;
+    @Nullable String scheme;
     String encodedUsername = "";
     String encodedPassword = "";
-    String host;
+    @Nullable String host;
     int port = -1;
     final List<String> encodedPathSegments = new ArrayList<>();
-    List<String> encodedQueryNamesAndValues;
-    String encodedFragment;
+    @Nullable List<String> encodedQueryNamesAndValues;
+    @Nullable String encodedFragment;
 
     public Builder() {
       encodedPathSegments.add(""); // The default path is '/' which needs a trailing space.
@@ -1105,7 +1134,7 @@ public Builder encodedPath(String encodedPath) {
       return this;
     }
 
-    public Builder query(String query) {
+    public Builder query(@Nullable String query) {
       this.encodedQueryNamesAndValues = query != null
           ? queryStringToNamesAndValues(canonicalize(
           query, QUERY_ENCODE_SET, false, false, true, true))
@@ -1113,7 +1142,7 @@ public Builder query(String query) {
       return this;
     }
 
-    public Builder encodedQuery(String encodedQuery) {
+    public Builder encodedQuery(@Nullable String encodedQuery) {
       this.encodedQueryNamesAndValues = encodedQuery != null
           ? queryStringToNamesAndValues(
           canonicalize(encodedQuery, QUERY_ENCODE_SET, true, false, true, true))
@@ -1122,7 +1151,7 @@ public Builder encodedQuery(String encodedQuery) {
     }
 
     /** Encodes the query parameter using UTF-8 and adds it to this URL's query string. */
-    public Builder addQueryParameter(String name, String value) {
+    public Builder addQueryParameter(String name, @Nullable String value) {
       if (name == null) throw new NullPointerException("name == null");
       if (encodedQueryNamesAndValues == null) encodedQueryNamesAndValues = new ArrayList<>();
       encodedQueryNamesAndValues.add(
@@ -1134,7 +1163,7 @@ public Builder addQueryParameter(String name, String value) {
     }
 
     /** Adds the pre-encoded query parameter to this URL's query string. */
-    public Builder addEncodedQueryParameter(String encodedName, String encodedValue) {
+    public Builder addEncodedQueryParameter(String encodedName, @Nullable String encodedValue) {
       if (encodedName == null) throw new NullPointerException("encodedName == null");
       if (encodedQueryNamesAndValues == null) encodedQueryNamesAndValues = new ArrayList<>();
       encodedQueryNamesAndValues.add(
@@ -1145,13 +1174,13 @@ public Builder addEncodedQueryParameter(String encodedName, String encodedValue)
       return this;
     }
 
-    public Builder setQueryParameter(String name, String value) {
+    public Builder setQueryParameter(String name, @Nullable String value) {
       removeAllQueryParameters(name);
       addQueryParameter(name, value);
       return this;
     }
 
-    public Builder setEncodedQueryParameter(String encodedName, String encodedValue) {
+    public Builder setEncodedQueryParameter(String encodedName, @Nullable String encodedValue) {
       removeAllEncodedQueryParameters(encodedName);
       addEncodedQueryParameter(encodedName, encodedValue);
       return this;
@@ -1187,14 +1216,14 @@ private void removeAllCanonicalQueryParameters(String canonicalName) {
       }
     }
 
-    public Builder fragment(String fragment) {
+    public Builder fragment(@Nullable String fragment) {
       this.encodedFragment = fragment != null
           ? canonicalize(fragment, FRAGMENT_ENCODE_SET, false, false, false, false)
           : null;
       return this;
     }
 
-    public Builder encodedFragment(String encodedFragment) {
+    public Builder encodedFragment(@Nullable String encodedFragment) {
       this.encodedFragment = encodedFragment != null
           ? canonicalize(encodedFragment, FRAGMENT_ENCODE_SET, true, false, false, false)
           : null;
@@ -1285,7 +1314,7 @@ public HttpUrl build() {
       INVALID_HOST,
     }
 
-    ParseResult parse(HttpUrl base, String input) {
+    ParseResult parse(@Nullable HttpUrl base, String input) {
       int pos = skipLeadingAsciiWhitespace(input, 0, input.length());
       int limit = skipTrailingAsciiWhitespace(input, pos, input.length());
 
@@ -1570,7 +1599,7 @@ private static String canonicalizeHost(String input, int pos, int limit) {
     }
 
     /** Decodes an IPv6 address like 1111:2222:3333:4444:5555:6666:7777:8888 or ::1. */
-    private static InetAddress decodeIpv6(String input, int pos, int limit) {
+    private static @Nullable InetAddress decodeIpv6(String input, int pos, int limit) {
       byte[] address = new byte[16];
       int b = 0;
       int compress = -1;
@@ -1675,8 +1704,11 @@ private static boolean decodeIpv4Suffix(
       return true; // Success.
     }
 
+    /** Encodes an IPv6 address in canonical form according to RFC 5952. */
     private static String inet6AddressToAscii(byte[] address) {
       // Go through the address looking for the longest run of 0s. Each group is 2-bytes.
+      // A run must be longer than one group (section 4.2.2).
+      // If there are multiple equal runs, the first one must be used (section 4.2.3).
       int longestRunOffset = -1;
       int longestRunLength = 0;
       for (int i = 0; i < address.length; i += 2) {
@@ -1685,7 +1717,7 @@ private static String inet6AddressToAscii(byte[] address) {
           i += 2;
         }
         int currentRunLength = i - currentRunOffset;
-        if (currentRunLength > longestRunLength) {
+        if (currentRunLength > longestRunLength && currentRunLength >= 4) {
           longestRunOffset = currentRunOffset;
           longestRunLength = currentRunLength;
         }
diff --git a/okhttp/src/main/java/okhttp3/Interceptor.java b/okhttp/src/main/java/okhttp3/Interceptor.java
index c1f8840a3c..71e133e097 100644
--- a/okhttp/src/main/java/okhttp3/Interceptor.java
+++ b/okhttp/src/main/java/okhttp3/Interceptor.java
@@ -16,6 +16,7 @@
 package okhttp3;
 
 import java.io.IOException;
+import javax.annotation.Nullable;
 
 /**
  * Observes, modifies, and potentially short-circuits requests going out and the corresponding
@@ -30,6 +31,10 @@
 
     Response proceed(Request request) throws IOException;
 
-    Connection connection();
+    /**
+     * Returns the connection the request will be executed on. This is only available in the chains
+     * of network interceptors; for application interceptors this is always null.
+     */
+    @Nullable Connection connection();
   }
 }
diff --git a/okhttp/src/main/java/okhttp3/MediaType.java b/okhttp/src/main/java/okhttp3/MediaType.java
index 77b943e589..95194c5711 100644
--- a/okhttp/src/main/java/okhttp3/MediaType.java
+++ b/okhttp/src/main/java/okhttp3/MediaType.java
@@ -19,6 +19,7 @@
 import java.util.Locale;
 import java.util.regex.Matcher;
 import java.util.regex.Pattern;
+import javax.annotation.Nullable;
 
 /**
  * An <a href="http://tools.ietf.org/html/rfc2045">RFC 2045</a> Media Type, appropriate to describe
@@ -34,9 +35,9 @@
   private final String mediaType;
   private final String type;
   private final String subtype;
-  private final String charset;
+  private final @Nullable String charset;
 
-  private MediaType(String mediaType, String type, String subtype, String charset) {
+  private MediaType(String mediaType, String type, String subtype, @Nullable String charset) {
     this.mediaType = mediaType;
     this.type = type;
     this.subtype = subtype;
@@ -47,7 +48,7 @@ private MediaType(String mediaType, String type, String subtype, String charset)
    * Returns a media type for {@code string}, or null if {@code string} is not a well-formed media
    * type.
    */
-  public static MediaType parse(String string) {
+  public static @Nullable MediaType parse(String string) {
     Matcher typeSubtype = TYPE_SUBTYPE.matcher(string);
     if (!typeSubtype.lookingAt()) return null;
     String type = typeSubtype.group(1).toLowerCase(Locale.US);
@@ -73,7 +74,7 @@ public static MediaType parse(String string) {
         charsetParameter = parameter.group(3);
       }
       if (charset != null && !charsetParameter.equalsIgnoreCase(charset)) {
-        throw new IllegalArgumentException("Multiple different charsets: " + string);
+        return null; // Multiple different charsets!
       }
       charset = charsetParameter;
     }
@@ -99,16 +100,20 @@ public String subtype() {
   /**
    * Returns the charset of this media type, or null if this media type doesn't specify a charset.
    */
-  public Charset charset() {
-    return charset != null ? Charset.forName(charset) : null;
+  public @Nullable Charset charset() {
+    return charset(null);
   }
 
   /**
-   * Returns the charset of this media type, or {@code defaultValue} if this media type doesn't
-   * specify a charset.
+   * Returns the charset of this media type, or {@code defaultValue} if either this media type
+   * doesn't specify a charset, of it its charset is unsupported by the current runtime.
    */
-  public Charset charset(Charset defaultValue) {
-    return charset != null ? Charset.forName(charset) : defaultValue;
+  public @Nullable Charset charset(@Nullable Charset defaultValue) {
+    try {
+      return charset != null ? Charset.forName(charset) : defaultValue;
+    } catch (IllegalArgumentException e) {
+      return defaultValue; // This charset is invalid or unsupported. Give up.
+    }
   }
 
   /**
@@ -119,8 +124,8 @@ public Charset charset(Charset defaultValue) {
     return mediaType;
   }
 
-  @Override public boolean equals(Object o) {
-    return o instanceof MediaType && ((MediaType) o).mediaType.equals(mediaType);
+  @Override public boolean equals(@Nullable Object other) {
+    return other instanceof MediaType && ((MediaType) other).mediaType.equals(mediaType);
   }
 
   @Override public int hashCode() {
diff --git a/okhttp/src/main/java/okhttp3/MultipartBody.java b/okhttp/src/main/java/okhttp3/MultipartBody.java
index 3aa31f310d..09c1eaf2fe 100644
--- a/okhttp/src/main/java/okhttp3/MultipartBody.java
+++ b/okhttp/src/main/java/okhttp3/MultipartBody.java
@@ -19,6 +19,7 @@
 import java.util.ArrayList;
 import java.util.List;
 import java.util.UUID;
+import javax.annotation.Nullable;
 import okhttp3.internal.Util;
 import okio.Buffer;
 import okio.BufferedSink;
@@ -119,7 +120,8 @@ public Part part(int index) {
    * to awkward operations like measuring the encoded length of header strings, or the
    * length-in-digits of an encoded integer.
    */
-  private long writeOrCountBytes(BufferedSink sink, boolean countBytes) throws IOException {
+  private long writeOrCountBytes(
+      @Nullable BufferedSink sink, boolean countBytes) throws IOException {
     long byteCount = 0L;
 
     Buffer byteCountBuffer = null;
@@ -225,7 +227,7 @@ public static Part create(RequestBody body) {
       return create(null, body);
     }
 
-    public static Part create(Headers headers, RequestBody body) {
+    public static Part create(@Nullable Headers headers, RequestBody body) {
       if (body == null) {
         throw new NullPointerException("body == null");
       }
@@ -242,7 +244,7 @@ public static Part createFormData(String name, String value) {
       return createFormData(name, null, RequestBody.create(null, value));
     }
 
-    public static Part createFormData(String name, String filename, RequestBody body) {
+    public static Part createFormData(String name, @Nullable String filename, RequestBody body) {
       if (name == null) {
         throw new NullPointerException("name == null");
       }
@@ -257,15 +259,15 @@ public static Part createFormData(String name, String filename, RequestBody body
       return create(Headers.of("Content-Disposition", disposition.toString()), body);
     }
 
-    final Headers headers;
+    final @Nullable Headers headers;
     final RequestBody body;
 
-    private Part(Headers headers, RequestBody body) {
+    private Part(@Nullable Headers headers, RequestBody body) {
       this.headers = headers;
       this.body = body;
     }
 
-    public Headers headers() {
+    public @Nullable Headers headers() {
       return headers;
     }
 
@@ -308,7 +310,7 @@ public Builder addPart(RequestBody body) {
     }
 
     /** Add a part to the body. */
-    public Builder addPart(Headers headers, RequestBody body) {
+    public Builder addPart(@Nullable Headers headers, RequestBody body) {
       return addPart(Part.create(headers, body));
     }
 
@@ -318,7 +320,7 @@ public Builder addFormDataPart(String name, String value) {
     }
 
     /** Add a form data part to the body. */
-    public Builder addFormDataPart(String name, String filename, RequestBody body) {
+    public Builder addFormDataPart(String name, @Nullable String filename, RequestBody body) {
       return addPart(Part.createFormData(name, filename, body));
     }
 
diff --git a/okhttp/src/main/java/okhttp3/OkHttpClient.java b/okhttp/src/main/java/okhttp3/OkHttpClient.java
index a8ae6dcb15..d61ed5de2f 100644
--- a/okhttp/src/main/java/okhttp3/OkHttpClient.java
+++ b/okhttp/src/main/java/okhttp3/OkHttpClient.java
@@ -18,16 +18,18 @@
 import java.net.MalformedURLException;
 import java.net.Proxy;
 import java.net.ProxySelector;
+import java.net.Socket;
 import java.net.UnknownHostException;
 import java.security.GeneralSecurityException;
 import java.security.KeyStore;
-import java.security.SecureRandom;
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.Collections;
 import java.util.List;
+import java.util.Random;
 import java.util.concurrent.ExecutorService;
 import java.util.concurrent.TimeUnit;
+import javax.annotation.Nullable;
 import javax.net.SocketFactory;
 import javax.net.ssl.HostnameVerifier;
 import javax.net.ssl.SSLContext;
@@ -118,11 +120,11 @@
  * remain idle.
  */
 public class OkHttpClient implements Cloneable, Call.Factory, WebSocket.Factory {
-  private static final List<Protocol> DEFAULT_PROTOCOLS = Util.immutableList(
+  static final List<Protocol> DEFAULT_PROTOCOLS = Util.immutableList(
       Protocol.HTTP_2, Protocol.HTTP_1_1);
 
-  private static final List<ConnectionSpec> DEFAULT_CONNECTION_SPECS = Util.immutableList(
-      ConnectionSpec.MODERN_TLS, ConnectionSpec.COMPATIBLE_TLS, ConnectionSpec.CLEARTEXT);
+  static final List<ConnectionSpec> DEFAULT_CONNECTION_SPECS = Util.immutableList(
+      ConnectionSpec.MODERN_TLS, ConnectionSpec.CLEARTEXT);
 
   static {
     Internal.instance = new Internal() {
@@ -143,9 +145,18 @@
         return pool.connectionBecameIdle(connection);
       }
 
-      @Override public RealConnection get(
+      @Override public RealConnection get(ConnectionPool pool, Address address,
+          StreamAllocation streamAllocation, Route route) {
+        return pool.get(address, streamAllocation, route);
+      }
+
+      @Override public boolean equalsNonHost(Address a, Address b) {
+        return a.equalsNonHost(b);
+      }
+
+      @Override public Socket deduplicate(
           ConnectionPool pool, Address address, StreamAllocation streamAllocation) {
-        return pool.get(address, streamAllocation);
+        return pool.deduplicate(address, streamAllocation);
       }
 
       @Override public void put(ConnectionPool pool, RealConnection connection) {
@@ -156,6 +167,10 @@
         return connectionPool.routeDatabase;
       }
 
+      @Override public int code(Response.Builder responseBuilder) {
+        return responseBuilder.code;
+      }
+
       @Override
       public void apply(ConnectionSpec tlsConfiguration, SSLSocket sslSocket, boolean isFallback) {
         tlsConfiguration.apply(sslSocket, isFallback);
@@ -171,24 +186,25 @@ public void apply(ConnectionSpec tlsConfiguration, SSLSocket sslSocket, boolean
       }
 
       @Override public Call newWebSocketCall(OkHttpClient client, Request originalRequest) {
-        return new RealCall(client, originalRequest, true);
+        return RealCall.newRealCall(client, originalRequest, true);
       }
     };
   }
 
   final Dispatcher dispatcher;
-  final Proxy proxy;
+  final @Nullable Proxy proxy;
   final List<Protocol> protocols;
   final List<ConnectionSpec> connectionSpecs;
   final List<Interceptor> interceptors;
   final List<Interceptor> networkInterceptors;
+  final EventListener.Factory eventListenerFactory;
   final ProxySelector proxySelector;
   final CookieJar cookieJar;
-  final Cache cache;
-  final InternalCache internalCache;
+  final @Nullable Cache cache;
+  final @Nullable InternalCache internalCache;
   final SocketFactory socketFactory;
-  final SSLSocketFactory sslSocketFactory;
-  final CertificateChainCleaner certificateChainCleaner;
+  final @Nullable SSLSocketFactory sslSocketFactory;
+  final @Nullable CertificateChainCleaner certificateChainCleaner;
   final HostnameVerifier hostnameVerifier;
   final CertificatePinner certificatePinner;
   final Authenticator proxyAuthenticator;
@@ -201,18 +217,20 @@ public void apply(ConnectionSpec tlsConfiguration, SSLSocket sslSocket, boolean
   final int connectTimeout;
   final int readTimeout;
   final int writeTimeout;
+  final int pingInterval;
 
   public OkHttpClient() {
     this(new Builder());
   }
 
-  private OkHttpClient(Builder builder) {
+  OkHttpClient(Builder builder) {
     this.dispatcher = builder.dispatcher;
     this.proxy = builder.proxy;
     this.protocols = builder.protocols;
     this.connectionSpecs = builder.connectionSpecs;
     this.interceptors = Util.immutableList(builder.interceptors);
     this.networkInterceptors = Util.immutableList(builder.networkInterceptors);
+    this.eventListenerFactory = builder.eventListenerFactory;
     this.proxySelector = builder.proxySelector;
     this.cookieJar = builder.cookieJar;
     this.cache = builder.cache;
@@ -246,6 +264,7 @@ private OkHttpClient(Builder builder) {
     this.connectTimeout = builder.connectTimeout;
     this.readTimeout = builder.readTimeout;
     this.writeTimeout = builder.writeTimeout;
+    this.pingInterval = builder.pingInterval;
   }
 
   private X509TrustManager systemDefaultTrustManager() {
@@ -289,6 +308,11 @@ public int writeTimeoutMillis() {
     return writeTimeout;
   }
 
+  /** Web socket ping interval (in milliseconds). */
+  public int pingIntervalMillis() {
+    return pingInterval;
+  }
+
   public Proxy proxy() {
     return proxy;
   }
@@ -383,18 +407,22 @@ public Dispatcher dispatcher() {
     return networkInterceptors;
   }
 
+  public EventListener.Factory eventListenerFactory() {
+    return eventListenerFactory;
+  }
+
   /**
    * Prepares the {@code request} to be executed at some point in the future.
    */
   @Override public Call newCall(Request request) {
-    return new RealCall(this, request, false /* for web socket */);
+    return RealCall.newRealCall(this, request, false /* for web socket */);
   }
 
   /**
    * Uses {@code request} to connect a new web socket.
    */
   @Override public WebSocket newWebSocket(Request request, WebSocketListener listener) {
-    RealWebSocket webSocket = new RealWebSocket(request, listener, new SecureRandom());
+    RealWebSocket webSocket = new RealWebSocket(request, listener, new Random());
     webSocket.connect(this);
     return webSocket;
   }
@@ -405,18 +433,19 @@ public Builder newBuilder() {
 
   public static final class Builder {
     Dispatcher dispatcher;
-    Proxy proxy;
+    @Nullable Proxy proxy;
     List<Protocol> protocols;
     List<ConnectionSpec> connectionSpecs;
     final List<Interceptor> interceptors = new ArrayList<>();
     final List<Interceptor> networkInterceptors = new ArrayList<>();
+    EventListener.Factory eventListenerFactory;
     ProxySelector proxySelector;
     CookieJar cookieJar;
-    Cache cache;
-    InternalCache internalCache;
+    @Nullable Cache cache;
+    @Nullable InternalCache internalCache;
     SocketFactory socketFactory;
-    SSLSocketFactory sslSocketFactory;
-    CertificateChainCleaner certificateChainCleaner;
+    @Nullable SSLSocketFactory sslSocketFactory;
+    @Nullable CertificateChainCleaner certificateChainCleaner;
     HostnameVerifier hostnameVerifier;
     CertificatePinner certificatePinner;
     Authenticator proxyAuthenticator;
@@ -429,11 +458,13 @@ public Builder newBuilder() {
     int connectTimeout;
     int readTimeout;
     int writeTimeout;
+    int pingInterval;
 
     public Builder() {
       dispatcher = new Dispatcher();
       protocols = DEFAULT_PROTOCOLS;
       connectionSpecs = DEFAULT_CONNECTION_SPECS;
+      eventListenerFactory = EventListener.factory(EventListener.NONE);
       proxySelector = ProxySelector.getDefault();
       cookieJar = CookieJar.NO_COOKIES;
       socketFactory = SocketFactory.getDefault();
@@ -449,6 +480,7 @@ public Builder() {
       connectTimeout = 10_000;
       readTimeout = 10_000;
       writeTimeout = 10_000;
+      pingInterval = 0;
     }
 
     Builder(OkHttpClient okHttpClient) {
@@ -458,6 +490,7 @@ public Builder() {
       this.connectionSpecs = okHttpClient.connectionSpecs;
       this.interceptors.addAll(okHttpClient.interceptors);
       this.networkInterceptors.addAll(okHttpClient.networkInterceptors);
+      this.eventListenerFactory = okHttpClient.eventListenerFactory;
       this.proxySelector = okHttpClient.proxySelector;
       this.cookieJar = okHttpClient.cookieJar;
       this.internalCache = okHttpClient.internalCache;
@@ -477,6 +510,7 @@ public Builder() {
       this.connectTimeout = okHttpClient.connectTimeout;
       this.readTimeout = okHttpClient.readTimeout;
       this.writeTimeout = okHttpClient.writeTimeout;
+      this.pingInterval = okHttpClient.pingInterval;
     }
 
     /**
@@ -485,12 +519,7 @@ public Builder() {
      * milliseconds.
      */
     public Builder connectTimeout(long timeout, TimeUnit unit) {
-      if (timeout < 0) throw new IllegalArgumentException("timeout < 0");
-      if (unit == null) throw new NullPointerException("unit == null");
-      long millis = unit.toMillis(timeout);
-      if (millis > Integer.MAX_VALUE) throw new IllegalArgumentException("Timeout too large.");
-      if (millis == 0 && timeout > 0) throw new IllegalArgumentException("Timeout too small.");
-      connectTimeout = (int) millis;
+      connectTimeout = checkDuration("timeout", timeout, unit);
       return this;
     }
 
@@ -499,12 +528,7 @@ public Builder connectTimeout(long timeout, TimeUnit unit) {
      * values must be between 1 and {@link Integer#MAX_VALUE} when converted to milliseconds.
      */
     public Builder readTimeout(long timeout, TimeUnit unit) {
-      if (timeout < 0) throw new IllegalArgumentException("timeout < 0");
-      if (unit == null) throw new NullPointerException("unit == null");
-      long millis = unit.toMillis(timeout);
-      if (millis > Integer.MAX_VALUE) throw new IllegalArgumentException("Timeout too large.");
-      if (millis == 0 && timeout > 0) throw new IllegalArgumentException("Timeout too small.");
-      readTimeout = (int) millis;
+      readTimeout = checkDuration("timeout", timeout, unit);
       return this;
     }
 
@@ -513,21 +537,38 @@ public Builder readTimeout(long timeout, TimeUnit unit) {
      * values must be between 1 and {@link Integer#MAX_VALUE} when converted to milliseconds.
      */
     public Builder writeTimeout(long timeout, TimeUnit unit) {
-      if (timeout < 0) throw new IllegalArgumentException("timeout < 0");
-      if (unit == null) throw new NullPointerException("unit == null");
-      long millis = unit.toMillis(timeout);
-      if (millis > Integer.MAX_VALUE) throw new IllegalArgumentException("Timeout too large.");
-      if (millis == 0 && timeout > 0) throw new IllegalArgumentException("Timeout too small.");
-      writeTimeout = (int) millis;
+      writeTimeout = checkDuration("timeout", timeout, unit);
+      return this;
+    }
+
+    /**
+     * Sets the interval between web socket pings initiated by this client. Use this to
+     * automatically send web socket ping frames until either the web socket fails or it is closed.
+     * This keeps the connection alive and may detect connectivity failures early. No timeouts are
+     * enforced on the acknowledging pongs.
+     *
+     * <p>The default value of 0 disables client-initiated pings.
+     */
+    public Builder pingInterval(long interval, TimeUnit unit) {
+      pingInterval = checkDuration("interval", interval, unit);
       return this;
     }
 
+    private static int checkDuration(String name, long duration, TimeUnit unit) {
+      if (duration < 0) throw new IllegalArgumentException(name + " < 0");
+      if (unit == null) throw new NullPointerException("unit == null");
+      long millis = unit.toMillis(duration);
+      if (millis > Integer.MAX_VALUE) throw new IllegalArgumentException(name + " too large.");
+      if (millis == 0 && duration > 0) throw new IllegalArgumentException(name + " too small.");
+      return (int) millis;
+    }
+
     /**
      * Sets the HTTP proxy that will be used by connections created by this client. This takes
      * precedence over {@link #proxySelector}, which is only honored when this proxy is null (which
      * it is by default). To disable proxy use completely, call {@code setProxy(Proxy.NO_PROXY)}.
      */
-    public Builder proxy(Proxy proxy) {
+    public Builder proxy(@Nullable Proxy proxy) {
       this.proxy = proxy;
       return this;
     }
@@ -558,13 +599,13 @@ public Builder cookieJar(CookieJar cookieJar) {
     }
 
     /** Sets the response cache to be used to read and write cached responses. */
-    void setInternalCache(InternalCache internalCache) {
+    void setInternalCache(@Nullable InternalCache internalCache) {
       this.internalCache = internalCache;
       this.cache = null;
     }
 
     /** Sets the response cache to be used to read and write cached responses. */
-    public Builder cache(Cache cache) {
+    public Builder cache(@Nullable Cache cache) {
       this.cache = cache;
       this.internalCache = null;
       return this;
@@ -805,9 +846,7 @@ public Builder protocols(List<Protocol> protocols) {
       }
 
       // Remove protocols that we no longer support.
-      if (protocols.contains(Protocol.SPDY_3)) {
-        protocols.remove(Protocol.SPDY_3);
-      }
+      protocols.remove(Protocol.SPDY_3);
 
       // Assign as an unmodifiable list. This is effectively immutable.
       this.protocols = Collections.unmodifiableList(protocols);
@@ -847,6 +886,20 @@ public Builder addNetworkInterceptor(Interceptor interceptor) {
       return this;
     }
 
+    public Builder eventListener(EventListener eventListener) {
+      if (eventListener == null) throw new NullPointerException("eventListener == null");
+      this.eventListenerFactory = EventListener.factory(eventListener);
+      return this;
+    }
+
+    public Builder eventListenerFactory(EventListener.Factory eventListenerFactory) {
+      if (eventListenerFactory == null) {
+        throw new NullPointerException("eventListenerFactory == null");
+      }
+      this.eventListenerFactory = eventListenerFactory;
+      return this;
+    }
+
     public OkHttpClient build() {
       return new OkHttpClient(this);
     }
diff --git a/okhttp/src/main/java/okhttp3/RealCall.java b/okhttp/src/main/java/okhttp3/RealCall.java
index 3c027a2caf..d09c1b7d44 100644
--- a/okhttp/src/main/java/okhttp3/RealCall.java
+++ b/okhttp/src/main/java/okhttp3/RealCall.java
@@ -34,6 +34,12 @@
   final OkHttpClient client;
   final RetryAndFollowUpInterceptor retryAndFollowUpInterceptor;
 
+  /**
+   * There is a cycle between the {@link Call} and {@link EventListener} that makes this awkward.
+   * This will be set after we create the call instance then create the event listener instance.
+   */
+  private EventListener eventListener;
+
   /** The application's original request unadulterated by redirects or auth headers. */
   final Request originalRequest;
   final boolean forWebSocket;
@@ -41,13 +47,20 @@
   // Guarded by this.
   private boolean executed;
 
-  RealCall(OkHttpClient client, Request originalRequest, boolean forWebSocket) {
+  private RealCall(OkHttpClient client, Request originalRequest, boolean forWebSocket) {
     this.client = client;
     this.originalRequest = originalRequest;
     this.forWebSocket = forWebSocket;
     this.retryAndFollowUpInterceptor = new RetryAndFollowUpInterceptor(client, forWebSocket);
   }
 
+  static RealCall newRealCall(OkHttpClient client, Request originalRequest, boolean forWebSocket) {
+    // Safely publish the Call instance to the EventListener.
+    RealCall call = new RealCall(client, originalRequest, forWebSocket);
+    call.eventListener = client.eventListenerFactory().create(call);
+    return call;
+  }
+
   @Override public Request request() {
     return originalRequest;
   }
@@ -96,7 +109,7 @@ private void captureCallStackTrace() {
 
   @SuppressWarnings("CloneDoesntCallSuperClone") // We are a final type & this saves clearing state.
   @Override public RealCall clone() {
-    return new RealCall(client, originalRequest, forWebSocket);
+    return RealCall.newRealCall(client, originalRequest, forWebSocket);
   }
 
   StreamAllocation streamAllocation() {
@@ -158,7 +171,7 @@ String toLoggableString() {
   }
 
   String redactedUrl() {
-    return originalRequest.url().redact().toString();
+    return originalRequest.url().redact();
   }
 
   Response getResponseWithInterceptorChain() throws IOException {
@@ -175,7 +188,7 @@ Response getResponseWithInterceptorChain() throws IOException {
     interceptors.add(new CallServerInterceptor(forWebSocket));
 
     Interceptor.Chain chain = new RealInterceptorChain(
-        interceptors, null, null, null, 0, originalRequest);
+        interceptors, null, null, null, 0, originalRequest, this, eventListener);
     return chain.proceed(originalRequest);
   }
 }
diff --git a/okhttp/src/main/java/okhttp3/Request.java b/okhttp/src/main/java/okhttp3/Request.java
index 36aa6acfe7..cb88696260 100644
--- a/okhttp/src/main/java/okhttp3/Request.java
+++ b/okhttp/src/main/java/okhttp3/Request.java
@@ -17,6 +17,7 @@
 
 import java.net.URL;
 import java.util.List;
+import javax.annotation.Nullable;
 import okhttp3.internal.Util;
 import okhttp3.internal.http.HttpMethod;
 
@@ -28,7 +29,7 @@
   final HttpUrl url;
   final String method;
   final Headers headers;
-  final RequestBody body;
+  final @Nullable RequestBody body;
   final Object tag;
 
   private volatile CacheControl cacheControl; // Lazily initialized.
@@ -61,7 +62,7 @@ public String header(String name) {
     return headers.values(name);
   }
 
-  public RequestBody body() {
+  public @Nullable RequestBody body() {
     return body;
   }
 
@@ -131,7 +132,7 @@ public Builder url(HttpUrl url) {
     public Builder url(String url) {
       if (url == null) throw new NullPointerException("url == null");
 
-      // Silently replace websocket URLs with HTTP URLs.
+      // Silently replace web socket URLs with HTTP URLs.
       if (url.regionMatches(true, 0, "ws:", 0, 3)) {
         url = "http:" + url.substring(3);
       } else if (url.regionMatches(true, 0, "wss:", 0, 4)) {
@@ -211,7 +212,7 @@ public Builder post(RequestBody body) {
       return method("POST", body);
     }
 
-    public Builder delete(RequestBody body) {
+    public Builder delete(@Nullable RequestBody body) {
       return method("DELETE", body);
     }
 
@@ -227,7 +228,7 @@ public Builder patch(RequestBody body) {
       return method("PATCH", body);
     }
 
-    public Builder method(String method, RequestBody body) {
+    public Builder method(String method, @Nullable RequestBody body) {
       if (method == null) throw new NullPointerException("method == null");
       if (method.length() == 0) throw new IllegalArgumentException("method.length() == 0");
       if (body != null && !HttpMethod.permitsRequestBody(method)) {
diff --git a/okhttp/src/main/java/okhttp3/RequestBody.java b/okhttp/src/main/java/okhttp3/RequestBody.java
index 136cfdc4e3..3cb29477d3 100644
--- a/okhttp/src/main/java/okhttp3/RequestBody.java
+++ b/okhttp/src/main/java/okhttp3/RequestBody.java
@@ -18,6 +18,7 @@
 import java.io.File;
 import java.io.IOException;
 import java.nio.charset.Charset;
+import javax.annotation.Nullable;
 import okhttp3.internal.Util;
 import okio.BufferedSink;
 import okio.ByteString;
@@ -26,24 +27,24 @@
 
 public abstract class RequestBody {
   /** Returns the Content-Type header for this body. */
-  public abstract MediaType contentType();
+  public abstract @Nullable MediaType contentType();
 
   /**
-   * Returns the number of bytes that will be written to {@code out} in a call to {@link #writeTo},
+   * Returns the number of bytes that will be written to {@code sink} in a call to {@link #writeTo},
    * or -1 if that count is unknown.
    */
   public long contentLength() throws IOException {
     return -1;
   }
 
-  /** Writes the content of this request to {@code out}. */
+  /** Writes the content of this request to {@code sink}. */
   public abstract void writeTo(BufferedSink sink) throws IOException;
 
   /**
    * Returns a new request body that transmits {@code content}. If {@code contentType} is non-null
    * and lacks a charset, this will use UTF-8.
    */
-  public static RequestBody create(MediaType contentType, String content) {
+  public static RequestBody create(@Nullable MediaType contentType, String content) {
     Charset charset = Util.UTF_8;
     if (contentType != null) {
       charset = contentType.charset();
@@ -57,9 +58,10 @@ public static RequestBody create(MediaType contentType, String content) {
   }
 
   /** Returns a new request body that transmits {@code content}. */
-  public static RequestBody create(final MediaType contentType, final ByteString content) {
+  public static RequestBody create(
+      final @Nullable MediaType contentType, final ByteString content) {
     return new RequestBody() {
-      @Override public MediaType contentType() {
+      @Override public @Nullable MediaType contentType() {
         return contentType;
       }
 
@@ -74,17 +76,17 @@ public static RequestBody create(final MediaType contentType, final ByteString c
   }
 
   /** Returns a new request body that transmits {@code content}. */
-  public static RequestBody create(final MediaType contentType, final byte[] content) {
+  public static RequestBody create(final @Nullable MediaType contentType, final byte[] content) {
     return create(contentType, content, 0, content.length);
   }
 
   /** Returns a new request body that transmits {@code content}. */
-  public static RequestBody create(final MediaType contentType, final byte[] content,
+  public static RequestBody create(final @Nullable MediaType contentType, final byte[] content,
       final int offset, final int byteCount) {
     if (content == null) throw new NullPointerException("content == null");
     Util.checkOffsetAndCount(content.length, offset, byteCount);
     return new RequestBody() {
-      @Override public MediaType contentType() {
+      @Override public @Nullable MediaType contentType() {
         return contentType;
       }
 
@@ -99,11 +101,11 @@ public static RequestBody create(final MediaType contentType, final byte[] conte
   }
 
   /** Returns a new request body that transmits the content of {@code file}. */
-  public static RequestBody create(final MediaType contentType, final File file) {
+  public static RequestBody create(final @Nullable MediaType contentType, final File file) {
     if (file == null) throw new NullPointerException("content == null");
 
     return new RequestBody() {
-      @Override public MediaType contentType() {
+      @Override public @Nullable MediaType contentType() {
         return contentType;
       }
 
diff --git a/okhttp/src/main/java/okhttp3/Response.java b/okhttp/src/main/java/okhttp3/Response.java
index 810309b013..1e3ab454a5 100644
--- a/okhttp/src/main/java/okhttp3/Response.java
+++ b/okhttp/src/main/java/okhttp3/Response.java
@@ -19,6 +19,7 @@
 import java.io.IOException;
 import java.util.Collections;
 import java.util.List;
+import javax.annotation.Nullable;
 import okhttp3.internal.http.HttpHeaders;
 import okio.Buffer;
 import okio.BufferedSource;
@@ -44,12 +45,12 @@
   final Protocol protocol;
   final int code;
   final String message;
-  final Handshake handshake;
+  final @Nullable Handshake handshake;
   final Headers headers;
-  final ResponseBody body;
-  final Response networkResponse;
-  final Response cacheResponse;
-  final Response priorResponse;
+  final @Nullable ResponseBody body;
+  final @Nullable Response networkResponse;
+  final @Nullable Response cacheResponse;
+  final @Nullable Response priorResponse;
   final long sentRequestAtMillis;
   final long receivedResponseAtMillis;
 
@@ -105,7 +106,7 @@ public boolean isSuccessful() {
     return code >= 200 && code < 300;
   }
 
-  /** Returns the HTTP status message or null if it is unknown. */
+  /** Returns the HTTP status message. */
   public String message() {
     return message;
   }
@@ -122,11 +123,11 @@ public Handshake handshake() {
     return headers.values(name);
   }
 
-  public String header(String name) {
+  public @Nullable String header(String name) {
     return header(name, null);
   }
 
-  public String header(String name, String defaultValue) {
+  public @Nullable String header(String name, @Nullable String defaultValue) {
     String result = headers.get(name);
     return result != null ? result : defaultValue;
   }
@@ -172,7 +173,7 @@ public ResponseBody peekBody(long byteCount) throws IOException {
    * <p>This always returns null on responses returned from {@link #cacheResponse}, {@link
    * #networkResponse}, and {@link #priorResponse()}.
    */
-  public ResponseBody body() {
+  public @Nullable ResponseBody body() {
     return body;
   }
 
@@ -200,7 +201,7 @@ public boolean isRedirect() {
    * the network, such as when the response is fully cached. The body of the returned response
    * should not be read.
    */
-  public Response networkResponse() {
+  public @Nullable Response networkResponse() {
     return networkResponse;
   }
 
@@ -209,7 +210,7 @@ public Response networkResponse() {
    * cache. For conditional get requests the cache response and network response may both be
    * non-null. The body of the returned response should not be read.
    */
-  public Response cacheResponse() {
+  public @Nullable Response cacheResponse() {
     return cacheResponse;
   }
 
@@ -219,7 +220,7 @@ public Response cacheResponse() {
    * returned response should not be read because it has already been consumed by the redirecting
    * client.
    */
-  public Response priorResponse() {
+  public @Nullable Response priorResponse() {
     return priorResponse;
   }
 
@@ -268,8 +269,17 @@ public long receivedResponseAtMillis() {
     return receivedResponseAtMillis;
   }
 
-  /** Closes the response body. Equivalent to {@code body().close()}. */
+  /**
+   * Closes the response body. Equivalent to {@code body().close()}.
+   *
+   * <p>It is an error to close a response that is not eligible for a body. This includes the
+   * responses returned from {@link #cacheResponse}, {@link #networkResponse}, and {@link
+   * #priorResponse()}.
+   */
   @Override public void close() {
+    if (body == null) {
+      throw new IllegalStateException("response is not eligible for a body and must not be closed");
+    }
     body.close();
   }
 
@@ -290,7 +300,7 @@ public long receivedResponseAtMillis() {
     Protocol protocol;
     int code = -1;
     String message;
-    Handshake handshake;
+    @Nullable Handshake handshake;
     Headers.Builder headers;
     ResponseBody body;
     Response networkResponse;
@@ -338,7 +348,7 @@ public Builder message(String message) {
       return this;
     }
 
-    public Builder handshake(Handshake handshake) {
+    public Builder handshake(@Nullable Handshake handshake) {
       this.handshake = handshake;
       return this;
     }
@@ -372,18 +382,18 @@ public Builder headers(Headers headers) {
       return this;
     }
 
-    public Builder body(ResponseBody body) {
+    public Builder body(@Nullable ResponseBody body) {
       this.body = body;
       return this;
     }
 
-    public Builder networkResponse(Response networkResponse) {
+    public Builder networkResponse(@Nullable Response networkResponse) {
       if (networkResponse != null) checkSupportResponse("networkResponse", networkResponse);
       this.networkResponse = networkResponse;
       return this;
     }
 
-    public Builder cacheResponse(Response cacheResponse) {
+    public Builder cacheResponse(@Nullable Response cacheResponse) {
       if (cacheResponse != null) checkSupportResponse("cacheResponse", cacheResponse);
       this.cacheResponse = cacheResponse;
       return this;
@@ -401,7 +411,7 @@ private void checkSupportResponse(String name, Response response) {
       }
     }
 
-    public Builder priorResponse(Response priorResponse) {
+    public Builder priorResponse(@Nullable Response priorResponse) {
       if (priorResponse != null) checkPriorResponse(priorResponse);
       this.priorResponse = priorResponse;
       return this;
@@ -427,6 +437,7 @@ public Response build() {
       if (request == null) throw new IllegalStateException("request == null");
       if (protocol == null) throw new IllegalStateException("protocol == null");
       if (code < 0) throw new IllegalStateException("code < 0: " + code);
+      if (message == null) throw new IllegalStateException("message == null");
       return new Response(this);
     }
   }
diff --git a/okhttp/src/main/java/okhttp3/ResponseBody.java b/okhttp/src/main/java/okhttp3/ResponseBody.java
index 113d607746..17447f3d64 100644
--- a/okhttp/src/main/java/okhttp3/ResponseBody.java
+++ b/okhttp/src/main/java/okhttp3/ResponseBody.java
@@ -21,6 +21,7 @@
 import java.io.InputStreamReader;
 import java.io.Reader;
 import java.nio.charset.Charset;
+import javax.annotation.Nullable;
 import okhttp3.internal.Util;
 import okio.Buffer;
 import okio.BufferedSource;
@@ -102,7 +103,7 @@
   /** Multiple calls to {@link #charStream()} must return the same instance. */
   private Reader reader;
 
-  public abstract MediaType contentType();
+  public abstract @Nullable MediaType contentType();
 
   /**
    * Returns the number of bytes in that will returned by {@link #bytes}, or {@link #byteStream}, or
@@ -190,7 +191,7 @@ private Charset charset() {
    * Returns a new response body that transmits {@code content}. If {@code contentType} is non-null
    * and lacks a charset, this will use UTF-8.
    */
-  public static ResponseBody create(MediaType contentType, String content) {
+  public static ResponseBody create(@Nullable MediaType contentType, String content) {
     Charset charset = UTF_8;
     if (contentType != null) {
       charset = contentType.charset();
@@ -204,17 +205,17 @@ public static ResponseBody create(MediaType contentType, String content) {
   }
 
   /** Returns a new response body that transmits {@code content}. */
-  public static ResponseBody create(final MediaType contentType, byte[] content) {
+  public static ResponseBody create(final @Nullable MediaType contentType, byte[] content) {
     Buffer buffer = new Buffer().write(content);
     return create(contentType, content.length, buffer);
   }
 
   /** Returns a new response body that transmits {@code content}. */
-  public static ResponseBody create(
-      final MediaType contentType, final long contentLength, final BufferedSource content) {
+  public static ResponseBody create(final @Nullable MediaType contentType,
+      final long contentLength, final BufferedSource content) {
     if (content == null) throw new NullPointerException("source == null");
     return new ResponseBody() {
-      @Override public MediaType contentType() {
+      @Override public @Nullable MediaType contentType() {
         return contentType;
       }
 
@@ -235,7 +236,7 @@ public static ResponseBody create(
     private boolean closed;
     private Reader delegate;
 
-    private BomAwareReader(BufferedSource source, Charset charset) {
+    BomAwareReader(BufferedSource source, Charset charset) {
       this.source = source;
       this.charset = charset;
     }
diff --git a/okhttp/src/main/java/okhttp3/Route.java b/okhttp/src/main/java/okhttp3/Route.java
index 8aaa0f5b85..14158673ca 100644
--- a/okhttp/src/main/java/okhttp3/Route.java
+++ b/okhttp/src/main/java/okhttp3/Route.java
@@ -17,6 +17,7 @@
 
 import java.net.InetSocketAddress;
 import java.net.Proxy;
+import javax.annotation.Nullable;
 
 /**
  * The concrete route used by a connection to reach an abstract origin server. When creating a
@@ -79,14 +80,11 @@ public boolean requiresTunnel() {
     return address.sslSocketFactory != null && proxy.type() == Proxy.Type.HTTP;
   }
 
-  @Override public boolean equals(Object obj) {
-    if (obj instanceof Route) {
-      Route other = (Route) obj;
-      return address.equals(other.address)
-          && proxy.equals(other.proxy)
-          && inetSocketAddress.equals(other.inetSocketAddress);
-    }
-    return false;
+  @Override public boolean equals(@Nullable Object other) {
+    return other instanceof Route
+        && ((Route) other).address.equals(address)
+        && ((Route) other).proxy.equals(proxy)
+        && ((Route) other).inetSocketAddress.equals(inetSocketAddress);
   }
 
   @Override public int hashCode() {
@@ -96,4 +94,8 @@ public boolean requiresTunnel() {
     result = 31 * result + inetSocketAddress.hashCode();
     return result;
   }
+
+  @Override public String toString() {
+    return "Route{" + inetSocketAddress + "}";
+  }
 }
diff --git a/okhttp/src/main/java/okhttp3/TlsVersion.java b/okhttp/src/main/java/okhttp3/TlsVersion.java
index 391af88e3a..02cbeca3d1 100644
--- a/okhttp/src/main/java/okhttp3/TlsVersion.java
+++ b/okhttp/src/main/java/okhttp3/TlsVersion.java
@@ -15,6 +15,10 @@
  */
 package okhttp3;
 
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.List;
+
 /**
  * Versions of TLS that can be offered when negotiating a secure socket. See {@link
  * javax.net.ssl.SSLSocket#setEnabledProtocols}.
@@ -49,6 +53,14 @@ public static TlsVersion forJavaName(String javaName) {
     throw new IllegalArgumentException("Unexpected TLS version: " + javaName);
   }
 
+  static List<TlsVersion> forJavaNames(String... tlsVersions) {
+    List<TlsVersion> result = new ArrayList<>(tlsVersions.length);
+    for (String tlsVersion : tlsVersions) {
+      result.add(forJavaName(tlsVersion));
+    }
+    return Collections.unmodifiableList(result);
+  }
+
   public String javaName() {
     return javaName;
   }
diff --git a/okhttp/src/main/java/okhttp3/WebSocket.java b/okhttp/src/main/java/okhttp3/WebSocket.java
index 12457e535e..83b585c968 100644
--- a/okhttp/src/main/java/okhttp3/WebSocket.java
+++ b/okhttp/src/main/java/okhttp3/WebSocket.java
@@ -15,6 +15,7 @@
  */
 package okhttp3;
 
+import javax.annotation.Nullable;
 import okio.ByteString;
 
 /**
@@ -101,7 +102,7 @@
    * href="http://tools.ietf.org/html/rfc6455#section-7.4">Section 7.4 of RFC 6455</a> or {@code 0}.
    * @param reason Reason for shutting down or {@code null}.
    */
-  boolean close(int code, String reason);
+  boolean close(int code, @Nullable String reason);
 
   /**
    * Immediately and violently release resources held by this web socket, discarding any enqueued
@@ -110,6 +111,12 @@
   void cancel();
 
   interface Factory {
+    /**
+     * Creates a new web socket and immediately returns it. Creating a web socket initiates an
+     * asynchronous process to connect the socket. Once that succeeds or fails, {@code listener}
+     * will be notified. The caller must either close or cancel the returned web socket when it is
+     * no longer in use.
+     */
     WebSocket newWebSocket(Request request, WebSocketListener listener);
   }
 }
diff --git a/okhttp/src/main/java/okhttp3/internal/Internal.java b/okhttp/src/main/java/okhttp3/internal/Internal.java
index 2610a44516..1be96fd3e7 100644
--- a/okhttp/src/main/java/okhttp3/internal/Internal.java
+++ b/okhttp/src/main/java/okhttp3/internal/Internal.java
@@ -16,6 +16,7 @@
 package okhttp3.internal;
 
 import java.net.MalformedURLException;
+import java.net.Socket;
 import java.net.UnknownHostException;
 import javax.net.ssl.SSLSocket;
 import okhttp3.Address;
@@ -26,6 +27,8 @@
 import okhttp3.HttpUrl;
 import okhttp3.OkHttpClient;
 import okhttp3.Request;
+import okhttp3.Response;
+import okhttp3.Route;
 import okhttp3.internal.cache.InternalCache;
 import okhttp3.internal.connection.RealConnection;
 import okhttp3.internal.connection.RouteDatabase;
@@ -50,7 +53,12 @@ public static void initializeInstanceForTests() {
 
   public abstract void setCache(OkHttpClient.Builder builder, InternalCache internalCache);
 
-  public abstract RealConnection get(
+  public abstract RealConnection get(ConnectionPool pool, Address address,
+      StreamAllocation streamAllocation, Route route);
+
+  public abstract boolean equalsNonHost(Address a, Address b);
+
+  public abstract Socket deduplicate(
       ConnectionPool pool, Address address, StreamAllocation streamAllocation);
 
   public abstract void put(ConnectionPool pool, RealConnection connection);
@@ -59,6 +67,8 @@ public abstract RealConnection get(
 
   public abstract RouteDatabase routeDatabase(ConnectionPool connectionPool);
 
+  public abstract int code(Response.Builder responseBuilder);
+
   public abstract void apply(ConnectionSpec tlsConfiguration, SSLSocket sslSocket,
       boolean isFallback);
 
diff --git a/okhttp/src/main/java/okhttp3/internal/Util.java b/okhttp/src/main/java/okhttp3/internal/Util.java
index 28c0b79388..494e8ea73d 100644
--- a/okhttp/src/main/java/okhttp3/internal/Util.java
+++ b/okhttp/src/main/java/okhttp3/internal/Util.java
@@ -18,7 +18,6 @@
 import java.io.Closeable;
 import java.io.IOException;
 import java.io.InterruptedIOException;
-import java.lang.reflect.Array;
 import java.net.IDN;
 import java.net.ServerSocket;
 import java.net.Socket;
@@ -26,6 +25,7 @@
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.Collections;
+import java.util.Comparator;
 import java.util.List;
 import java.util.Locale;
 import java.util.TimeZone;
@@ -63,6 +63,12 @@
   /** GMT and UTC are equivalent for our purposes. */
   public static final TimeZone UTC = TimeZone.getTimeZone("GMT");
 
+  public static final Comparator<String> NATURAL_ORDER = new Comparator<String>() {
+    @Override public int compare(String a, String b) {
+      return a.compareTo(b);
+    }
+  };
+
   /**
    * Quick and dirty pattern to differentiate IP addresses from hostnames. This is an approximation
    * of Android's private InetAddress#isNumeric API.
@@ -198,30 +204,43 @@ public static ThreadFactory threadFactory(final String name, final boolean daemo
   }
 
   /**
-   * Returns an array containing containing only elements found in {@code first}  and also in {@code
+   * Returns an array containing only elements found in {@code first} and also in {@code
    * second}. The returned elements are in the same order as in {@code first}.
    */
   @SuppressWarnings("unchecked")
-  public static <T> T[] intersect(Class<T> arrayType, T[] first, T[] second) {
-    List<T> result = intersect(first, second);
-    return result.toArray((T[]) Array.newInstance(arrayType, result.size()));
+  public static String[] intersect(
+      Comparator<? super String> comparator, String[] first, String[] second) {
+    List<String> result = new ArrayList<>();
+    for (String a : first) {
+      for (String b : second) {
+        if (comparator.compare(a, b) == 0) {
+          result.add(a);
+          break;
+        }
+      }
+    }
+    return result.toArray(new String[result.size()]);
   }
 
   /**
-   * Returns a list containing containing only elements found in {@code first}  and also in {@code
-   * second}. The returned elements are in the same order as in {@code first}.
+   * Returns true if there is an element in {@code first} that is also in {@code second}. This
+   * method terminates if any intersection is found. The sizes of both arguments are assumed to be
+   * so small, and the likelihood of an intersection so great, that it is not worth the CPU cost of
+   * sorting or the memory cost of hashing.
    */
-  private static <T> List<T> intersect(T[] first, T[] second) {
-    List<T> result = new ArrayList<>();
-    for (T a : first) {
-      for (T b : second) {
-        if (a.equals(b)) {
-          result.add(b);
-          break;
+  public static boolean nonEmptyIntersection(
+      Comparator<String> comparator, String[] first, String[] second) {
+    if (first == null || second == null || first.length == 0 || second.length == 0) {
+      return false;
+    }
+    for (String a : first) {
+      for (String b : second) {
+        if (comparator.compare(a, b) == 0) {
+          return true;
         }
       }
     }
-    return result;
+    return false;
   }
 
   public static String hostHeader(HttpUrl url, boolean includeDefaultPort) {
@@ -259,9 +278,9 @@ public static boolean isAndroidGetsocknameError(AssertionError e) {
         && e.getMessage().contains("getsockname failed");
   }
 
-  public static <T> int indexOf(T[] array, T value) {
+  public static int indexOf(Comparator<String> comparator, String[] array, String value) {
     for (int i = 0, size = array.length; i < size; i++) {
-      if (equal(array[i], value)) return i;
+      if (comparator.compare(array[i], value) == 0) return i;
     }
     return -1;
   }
@@ -383,6 +402,21 @@ private static boolean containsInvalidHostnameAsciiCodes(String hostnameAscii) {
     return false;
   }
 
+  /**
+   * Returns the index of the first character in {@code input} that is either a control character
+   * (like {@code \u0000 or \n}) or a non-ASCII character. Returns -1 if {@code input} has no such
+   * characters.
+   */
+  public static int indexOfControlOrNonAscii(String input) {
+    for (int i = 0, length = input.length(); i < length; i++) {
+      char c = input.charAt(i);
+      if (c <= '\u001f' || c >= '\u007f') {
+        return i;
+      }
+    }
+    return -1;
+  }
+
   /** Returns true if {@code host} is not a host name and might be an IP address. */
   public static boolean verifyAsIpAddress(String host) {
     return VERIFY_AS_IP_ADDRESS.matcher(host).matches();
@@ -416,11 +450,4 @@ public static Charset bomAwareCharset(BufferedSource source, Charset charset) th
     }
     return charset;
   }
-
-  /** Re-throws {@code t} if it is a fatal exception which should not be handled. */
-  public static void throwIfFatal(Throwable t) {
-    if (t instanceof VirtualMachineError) throw (VirtualMachineError) t;
-    if (t instanceof ThreadDeath) throw (ThreadDeath) t;
-    if (t instanceof LinkageError) throw (LinkageError) t;
-  }
 }
diff --git a/okhttp/src/main/java/okhttp3/internal/cache/CacheInterceptor.java b/okhttp/src/main/java/okhttp3/internal/cache/CacheInterceptor.java
index 18d4fd9813..e4d7e2f1d6 100644
--- a/okhttp/src/main/java/okhttp3/internal/cache/CacheInterceptor.java
+++ b/okhttp/src/main/java/okhttp3/internal/cache/CacheInterceptor.java
@@ -125,38 +125,29 @@ public CacheInterceptor(InternalCache cache) {
         .networkResponse(stripBody(networkResponse))
         .build();
 
-    if (HttpHeaders.hasBody(response)) {
-      CacheRequest cacheRequest = maybeCache(response, networkResponse.request(), cache);
-      response = cacheWritingResponse(cacheRequest, response);
-    }
-
-    return response;
-  }
-
-  private static Response stripBody(Response response) {
-    return response != null && response.body() != null
-        ? response.newBuilder().body(null).build()
-        : response;
-  }
-
-  private CacheRequest maybeCache(Response userResponse, Request networkRequest,
-      InternalCache responseCache) throws IOException {
-    if (responseCache == null) return null;
+    if (cache != null) {
+      if (HttpHeaders.hasBody(response) && CacheStrategy.isCacheable(response, networkRequest)) {
+        // Offer this request to the cache.
+        CacheRequest cacheRequest = cache.put(response);
+        return cacheWritingResponse(cacheRequest, response);
+      }
 
-    // Should we cache this response for this request?
-    if (!CacheStrategy.isCacheable(userResponse, networkRequest)) {
       if (HttpMethod.invalidatesCache(networkRequest.method())) {
         try {
-          responseCache.remove(networkRequest);
+          cache.remove(networkRequest);
         } catch (IOException ignored) {
           // The cache cannot be written.
         }
       }
-      return null;
     }
 
-    // Offer this request to the cache.
-    return responseCache.put(userResponse);
+    return response;
+  }
+
+  private static Response stripBody(Response response) {
+    return response != null && response.body() != null
+        ? response.newBuilder().body(null).build()
+        : response;
   }
 
   /**
diff --git a/okhttp/src/main/java/okhttp3/internal/cache/CacheStrategy.java b/okhttp/src/main/java/okhttp3/internal/cache/CacheStrategy.java
index 93eacedef4..9b6cc1a375 100644
--- a/okhttp/src/main/java/okhttp3/internal/cache/CacheStrategy.java
+++ b/okhttp/src/main/java/okhttp3/internal/cache/CacheStrategy.java
@@ -16,6 +16,7 @@
 package okhttp3.internal.cache;
 
 import java.util.Date;
+import javax.annotation.Nullable;
 import okhttp3.CacheControl;
 import okhttp3.Headers;
 import okhttp3.Request;
@@ -48,12 +49,12 @@
  */
 public final class CacheStrategy {
   /** The request to send on the network, or null if this call doesn't use the network. */
-  public final Request networkRequest;
+  public final @Nullable Request networkRequest;
 
   /** The cached response to return or validate; or null if this call doesn't use a cache. */
-  public final Response cacheResponse;
+  public final @Nullable Response cacheResponse;
 
-  private CacheStrategy(Request networkRequest, Response cacheResponse) {
+  CacheStrategy(Request networkRequest, Response cacheResponse) {
     this.networkRequest = networkRequest;
     this.cacheResponse = cacheResponse;
   }
@@ -203,6 +204,11 @@ private CacheStrategy getCandidate() {
         return new CacheStrategy(request, null);
       }
 
+      CacheControl responseCaching = cacheResponse.cacheControl();
+      if (responseCaching.immutable()) {
+        return new CacheStrategy(null, cacheResponse);
+      }
+
       long ageMillis = cacheResponseAge();
       long freshMillis = computeFreshnessLifetime();
 
@@ -216,7 +222,6 @@ private CacheStrategy getCandidate() {
       }
 
       long maxStaleMillis = 0;
-      CacheControl responseCaching = cacheResponse.cacheControl();
       if (!responseCaching.mustRevalidate() && requestCaching.maxStaleSeconds() != -1) {
         maxStaleMillis = SECONDS.toMillis(requestCaching.maxStaleSeconds());
       }
diff --git a/okhttp/src/main/java/okhttp3/internal/cache/DiskLruCache.java b/okhttp/src/main/java/okhttp3/internal/cache/DiskLruCache.java
index 4d3ef616ab..c3fb740e28 100644
--- a/okhttp/src/main/java/okhttp3/internal/cache/DiskLruCache.java
+++ b/okhttp/src/main/java/okhttp3/internal/cache/DiskLruCache.java
@@ -32,6 +32,7 @@
 import java.util.concurrent.TimeUnit;
 import java.util.regex.Matcher;
 import java.util.regex.Pattern;
+import javax.annotation.Nullable;
 import okhttp3.internal.Util;
 import okhttp3.internal.io.FileSystem;
 import okhttp3.internal.platform.Platform;
@@ -136,25 +137,25 @@
      * it exists when the cache is opened.
      */
 
-  private final FileSystem fileSystem;
-  private final File directory;
+  final FileSystem fileSystem;
+  final File directory;
   private final File journalFile;
   private final File journalFileTmp;
   private final File journalFileBackup;
   private final int appVersion;
   private long maxSize;
-  private final int valueCount;
+  final int valueCount;
   private long size = 0;
-  private BufferedSink journalWriter;
-  private final LinkedHashMap<String, Entry> lruEntries = new LinkedHashMap<>(0, 0.75f, true);
-  private int redundantOpCount;
-  private boolean hasJournalErrors;
+  BufferedSink journalWriter;
+  final LinkedHashMap<String, Entry> lruEntries = new LinkedHashMap<>(0, 0.75f, true);
+  int redundantOpCount;
+  boolean hasJournalErrors;
 
   // Must be read and written when synchronized on 'this'.
-  private boolean initialized;
-  private boolean closed;
-  private boolean mostRecentTrimFailed;
-  private boolean mostRecentRebuildFailed;
+  boolean initialized;
+  boolean closed;
+  boolean mostRecentTrimFailed;
+  boolean mostRecentRebuildFailed;
 
   /**
    * To differentiate between old and current snapshots, each entry is given a sequence number each
@@ -231,7 +232,13 @@ public synchronized void initialize() throws IOException {
       } catch (IOException journalIsCorrupt) {
         Platform.get().log(WARN, "DiskLruCache " + directory + " is corrupt: "
             + journalIsCorrupt.getMessage() + ", removing", journalIsCorrupt);
+      }
+
+      // The cache is corrupted, attempt to delete the contents of the directory. This can throw and
+      // we'll let that propagate out as it likely means there is a severe filesystem problem.
+      try {
         delete();
+      } finally {
         closed = false;
       }
     }
@@ -381,7 +388,7 @@ private void processJournal() throws IOException {
    * Creates a new journal that omits redundant information. This replaces the current journal if it
    * exists.
    */
-  private synchronized void rebuildJournal() throws IOException {
+  synchronized void rebuildJournal() throws IOException {
     if (journalWriter != null) {
       journalWriter.close();
     }
@@ -448,11 +455,11 @@ public synchronized Snapshot get(String key) throws IOException {
   /**
    * Returns an editor for the entry named {@code key}, or null if another edit is in progress.
    */
-  public Editor edit(String key) throws IOException {
+  public @Nullable Editor edit(String key) throws IOException {
     return edit(key, ANY_SEQUENCE_NUMBER);
   }
 
-  private synchronized Editor edit(String key, long expectedSequenceNumber) throws IOException {
+  synchronized Editor edit(String key, long expectedSequenceNumber) throws IOException {
     initialize();
 
     checkNotClosed();
@@ -524,7 +531,7 @@ public synchronized long size() throws IOException {
     return size;
   }
 
-  private synchronized void completeEdit(Editor editor, boolean success) throws IOException {
+  synchronized void completeEdit(Editor editor, boolean success) throws IOException {
     Entry entry = editor.entry;
     if (entry.currentEditor != editor) {
       throw new IllegalStateException();
@@ -588,7 +595,7 @@ private synchronized void completeEdit(Editor editor, boolean success) throws IO
    * We only rebuild the journal when it will halve the size of the journal and eliminate at least
    * 2000 ops.
    */
-  private boolean journalRebuildRequired() {
+  boolean journalRebuildRequired() {
     final int redundantOpCompactThreshold = 2000;
     return redundantOpCount >= redundantOpCompactThreshold
         && redundantOpCount >= lruEntries.size();
@@ -612,7 +619,7 @@ public synchronized boolean remove(String key) throws IOException {
     return removed;
   }
 
-  private boolean removeEntry(Entry entry) throws IOException {
+  boolean removeEntry(Entry entry) throws IOException {
     if (entry.currentEditor != null) {
       entry.currentEditor.detach(); // Prevent the edit from completing normally.
     }
@@ -672,7 +679,7 @@ private synchronized void checkNotClosed() {
     closed = true;
   }
 
-  private void trimToSize() throws IOException {
+  void trimToSize() throws IOException {
     while (size > maxSize) {
       Entry toEvict = lruEntries.values().iterator().next();
       removeEntry(toEvict);
@@ -784,7 +791,7 @@ private void validateKey(String key) {
     private final Source[] sources;
     private final long[] lengths;
 
-    private Snapshot(String key, long sequenceNumber, Source[] sources, long[] lengths) {
+    Snapshot(String key, long sequenceNumber, Source[] sources, long[] lengths) {
       this.key = key;
       this.sequenceNumber = sequenceNumber;
       this.sources = sources;
@@ -799,7 +806,7 @@ public String key() {
      * Returns an editor for this snapshot's entry, or null if either the entry has changed since
      * this snapshot was created or if another edit is in progress.
      */
-    public Editor edit() throws IOException {
+    public @Nullable Editor edit() throws IOException {
       return DiskLruCache.this.edit(key, sequenceNumber);
     }
 
@@ -822,11 +829,11 @@ public void close() {
 
   /** Edits the values for an entry. */
   public final class Editor {
-    private final Entry entry;
-    private final boolean[] written;
+    final Entry entry;
+    final boolean[] written;
     private boolean done;
 
-    private Editor(Entry entry) {
+    Editor(Entry entry) {
       this.entry = entry;
       this.written = (entry.readable) ? null : new boolean[valueCount];
     }
@@ -948,23 +955,23 @@ public void abortUnlessCommitted() {
   }
 
   private final class Entry {
-    private final String key;
+    final String key;
 
     /** Lengths of this entry's files. */
-    private final long[] lengths;
-    private final File[] cleanFiles;
-    private final File[] dirtyFiles;
+    final long[] lengths;
+    final File[] cleanFiles;
+    final File[] dirtyFiles;
 
     /** True if this entry has ever been published. */
-    private boolean readable;
+    boolean readable;
 
     /** The ongoing edit or null if this entry is not being edited. */
-    private Editor currentEditor;
+    Editor currentEditor;
 
     /** The sequence number of the most recently committed edit to this entry. */
-    private long sequenceNumber;
+    long sequenceNumber;
 
-    private Entry(String key) {
+    Entry(String key) {
       this.key = key;
 
       lengths = new long[valueCount];
@@ -984,7 +991,7 @@ private Entry(String key) {
     }
 
     /** Set lengths using decimal numbers like "10123". */
-    private void setLengths(String[] strings) throws IOException {
+    void setLengths(String[] strings) throws IOException {
       if (strings.length != valueCount) {
         throw invalidLengths(strings);
       }
diff --git a/okhttp/src/main/java/okhttp3/internal/cache/FaultHidingSink.java b/okhttp/src/main/java/okhttp3/internal/cache/FaultHidingSink.java
index b10fddb956..561a30507e 100644
--- a/okhttp/src/main/java/okhttp3/internal/cache/FaultHidingSink.java
+++ b/okhttp/src/main/java/okhttp3/internal/cache/FaultHidingSink.java
@@ -24,7 +24,7 @@
 class FaultHidingSink extends ForwardingSink {
   private boolean hasErrors;
 
-  public FaultHidingSink(Sink delegate) {
+  FaultHidingSink(Sink delegate) {
     super(delegate);
   }
 
diff --git a/okhttp/src/main/java/okhttp3/internal/cache2/FileOperator.java b/okhttp/src/main/java/okhttp3/internal/cache2/FileOperator.java
index 70914226c3..b1326cddc9 100644
--- a/okhttp/src/main/java/okhttp3/internal/cache2/FileOperator.java
+++ b/okhttp/src/main/java/okhttp3/internal/cache2/FileOperator.java
@@ -41,7 +41,7 @@
   private final ByteBuffer byteBuffer = ByteBuffer.wrap(byteArray);
   private final FileChannel fileChannel;
 
-  public FileOperator(FileChannel fileChannel) {
+  FileOperator(FileChannel fileChannel) {
     this.fileChannel = fileChannel;
   }
 
diff --git a/okhttp/src/main/java/okhttp3/internal/cache2/Relay.java b/okhttp/src/main/java/okhttp3/internal/cache2/Relay.java
index b2db592d1e..5131e6cd16 100644
--- a/okhttp/src/main/java/okhttp3/internal/cache2/Relay.java
+++ b/okhttp/src/main/java/okhttp3/internal/cache2/Relay.java
@@ -61,28 +61,28 @@
    * <p>This is closed and assigned to null when the last source is closed and no further sources
    * are permitted.
    */
-  private RandomAccessFile file;
+  RandomAccessFile file;
 
   /** The thread that currently has access to upstream. Possibly null. Guarded by this. */
-  private Thread upstreamReader;
+  Thread upstreamReader;
 
   /**
    * Null once the file has a complete copy of the upstream bytes. Only the {@code upstreamReader}
    * thread may access this source.
    */
-  private Source upstream;
+  Source upstream;
 
   /**
    * A buffer for {@code upstreamReader} to use when pulling bytes from upstream. Only the {@code
    * upstreamReader} thread may access this buffer.
    */
-  private final Buffer upstreamBuffer = new Buffer();
+  final Buffer upstreamBuffer = new Buffer();
 
   /** The number of bytes consumed from {@link #upstream}. Guarded by this. */
-  private long upstreamPos;
+  long upstreamPos;
 
   /** True if there are no further bytes to read from {@code upstream}. Guarded by this. */
-  private boolean complete;
+  boolean complete;
 
   /** User-supplied additional data persisted with the source data. */
   private final ByteString metadata;
@@ -91,17 +91,17 @@
    * The most recently read bytes from {@link #upstream}. This is a suffix of {@link #file}. Guarded
    * by this.
    */
-  private final Buffer buffer = new Buffer();
+  final Buffer buffer = new Buffer();
 
   /** The maximum size of {@code buffer}. */
-  private final long bufferMaxSize;
+  final long bufferMaxSize;
 
   /**
    * Reference count of the number of active sources reading this stream. When decremented to 0
    * resources are released and all following calls to {@link #newSource} return null. Guarded by
    * this.
    */
-  private int sourceCount;
+  int sourceCount;
 
   private Relay(RandomAccessFile file, Source upstream, long upstreamPos, ByteString metadata,
       long bufferMaxSize) {
diff --git a/okhttp/src/main/java/okhttp3/internal/connection/RealConnection.java b/okhttp/src/main/java/okhttp3/internal/connection/RealConnection.java
index 547781d26f..1df7ae98b8 100644
--- a/okhttp/src/main/java/okhttp3/internal/connection/RealConnection.java
+++ b/okhttp/src/main/java/okhttp3/internal/connection/RealConnection.java
@@ -22,34 +22,44 @@
 import java.net.ProtocolException;
 import java.net.Proxy;
 import java.net.Socket;
+import java.net.SocketException;
 import java.net.SocketTimeoutException;
 import java.net.UnknownServiceException;
 import java.security.cert.X509Certificate;
 import java.util.ArrayList;
 import java.util.List;
 import java.util.concurrent.TimeUnit;
+import javax.annotation.Nullable;
 import javax.net.ssl.SSLPeerUnverifiedException;
 import javax.net.ssl.SSLSocket;
 import javax.net.ssl.SSLSocketFactory;
 import okhttp3.Address;
+import okhttp3.Call;
 import okhttp3.CertificatePinner;
 import okhttp3.Connection;
+import okhttp3.ConnectionPool;
 import okhttp3.ConnectionSpec;
+import okhttp3.EventListener;
 import okhttp3.Handshake;
 import okhttp3.HttpUrl;
+import okhttp3.OkHttpClient;
 import okhttp3.Protocol;
 import okhttp3.Request;
 import okhttp3.Response;
 import okhttp3.Route;
+import okhttp3.internal.Internal;
 import okhttp3.internal.Util;
 import okhttp3.internal.Version;
+import okhttp3.internal.http.HttpCodec;
 import okhttp3.internal.http.HttpHeaders;
 import okhttp3.internal.http1.Http1Codec;
 import okhttp3.internal.http2.ErrorCode;
+import okhttp3.internal.http2.Http2Codec;
 import okhttp3.internal.http2.Http2Connection;
 import okhttp3.internal.http2.Http2Stream;
 import okhttp3.internal.platform.Platform;
 import okhttp3.internal.tls.OkHostnameVerifier;
+import okhttp3.internal.ws.RealWebSocket;
 import okio.BufferedSink;
 import okio.BufferedSource;
 import okio.Okio;
@@ -61,8 +71,12 @@
 import static okhttp3.internal.Util.closeQuietly;
 
 public final class RealConnection extends Http2Connection.Listener implements Connection {
+  private static final String NPE_THROW_WITH_NULL = "throw with null exception";
+  private final ConnectionPool connectionPool;
   private final Route route;
 
+  // The fields below are initialized by connect() and never reassigned.
+
   /** The low-level TCP socket. */
   private Socket rawSocket;
 
@@ -70,27 +84,51 @@
    * The application layer socket. Either an {@link SSLSocket} layered over {@link #rawSocket}, or
    * {@link #rawSocket} itself if this connection does not use SSL.
    */
-  public Socket socket;
+  private Socket socket;
   private Handshake handshake;
   private Protocol protocol;
-  public volatile Http2Connection http2Connection;
+  private Http2Connection http2Connection;
+  private BufferedSource source;
+  private BufferedSink sink;
+
+  // The fields below track connection state and are guarded by connectionPool.
+
+  /** If true, no new streams can be created on this connection. Once true this is always true. */
+  public boolean noNewStreams;
+
   public int successCount;
-  public BufferedSource source;
-  public BufferedSink sink;
-  public int allocationLimit;
+
+  /**
+   * The maximum number of concurrent streams that can be carried by this connection. If {@code
+   * allocations.size() < allocationLimit} then new streams can be created on this connection.
+   */
+  public int allocationLimit = 1;
+
+  /** Current streams carried by this connection. */
   public final List<Reference<StreamAllocation>> allocations = new ArrayList<>();
-  public boolean noNewStreams;
+
+  /** Nanotime timestamp when {@code allocations.size()} reached zero. */
   public long idleAtNanos = Long.MAX_VALUE;
 
-  public RealConnection(Route route) {
+  public RealConnection(ConnectionPool connectionPool, Route route) {
+    this.connectionPool = connectionPool;
     this.route = route;
   }
 
+  public static RealConnection testConnection(
+      ConnectionPool connectionPool, Route route, Socket socket, long idleAtNanos) {
+    RealConnection result = new RealConnection(connectionPool, route);
+    result.socket = socket;
+    result.idleAtNanos = idleAtNanos;
+    return result;
+  }
+
   public void connect(int connectTimeout, int readTimeout, int writeTimeout,
-      List<ConnectionSpec> connectionSpecs, boolean connectionRetryEnabled) {
+      boolean connectionRetryEnabled, Call call, EventListener eventListener) {
     if (protocol != null) throw new IllegalStateException("already connected");
 
     RouteException routeException = null;
+    List<ConnectionSpec> connectionSpecs = route.address().connectionSpecs();
     ConnectionSpecSelector connectionSpecSelector = new ConnectionSpecSelector(connectionSpecs);
 
     if (route.address().sslSocketFactory() == null) {
@@ -105,14 +143,15 @@ public void connect(int connectTimeout, int readTimeout, int writeTimeout,
       }
     }
 
-    while (protocol == null) {
+    while (true) {
       try {
         if (route.requiresTunnel()) {
-          buildTunneledConnection(connectTimeout, readTimeout, writeTimeout,
-              connectionSpecSelector);
+          connectTunnel(connectTimeout, readTimeout, writeTimeout);
         } else {
-          buildConnection(connectTimeout, readTimeout, writeTimeout, connectionSpecSelector);
+          connectSocket(connectTimeout, readTimeout);
         }
+        establishProtocol(connectionSpecSelector, call, eventListener);
+        break;
       } catch (IOException e) {
         closeQuietly(socket);
         closeQuietly(rawSocket);
@@ -122,6 +161,7 @@ public void connect(int connectTimeout, int readTimeout, int writeTimeout,
         sink = null;
         handshake = null;
         protocol = null;
+        http2Connection = null;
 
         if (routeException == null) {
           routeException = new RouteException(e);
@@ -134,14 +174,20 @@ public void connect(int connectTimeout, int readTimeout, int writeTimeout,
         }
       }
     }
+
+    if (http2Connection != null) {
+      synchronized (connectionPool) {
+        allocationLimit = http2Connection.maxConcurrentStreams();
+      }
+    }
   }
 
   /**
    * Does all the work to build an HTTPS connection over a proxy tunnel. The catch here is that a
    * proxy server can issue an auth challenge and then close the connection.
    */
-  private void buildTunneledConnection(int connectTimeout, int readTimeout, int writeTimeout,
-      ConnectionSpecSelector connectionSpecSelector) throws IOException {
+  private void connectTunnel(int connectTimeout, int readTimeout, int writeTimeout)
+      throws IOException {
     Request tunnelRequest = createTunnelRequest();
     HttpUrl url = tunnelRequest.url();
     int attemptedConnections = 0;
@@ -163,17 +209,9 @@ private void buildTunneledConnection(int connectTimeout, int readTimeout, int wr
       sink = null;
       source = null;
     }
-
-    establishProtocol(readTimeout, writeTimeout, connectionSpecSelector);
   }
 
   /** Does all the work necessary to build a full HTTP or HTTPS connection on a raw socket. */
-  private void buildConnection(int connectTimeout, int readTimeout, int writeTimeout,
-      ConnectionSpecSelector connectionSpecSelector) throws IOException {
-    connectSocket(connectTimeout, readTimeout);
-    establishProtocol(readTimeout, writeTimeout, connectionSpecSelector);
-  }
-
   private void connectSocket(int connectTimeout, int readTimeout) throws IOException {
     Proxy proxy = route.proxy();
     Address address = route.address();
@@ -190,38 +228,49 @@ private void connectSocket(int connectTimeout, int readTimeout) throws IOExcepti
       ce.initCause(e);
       throw ce;
     }
-    source = Okio.buffer(Okio.source(rawSocket));
-    sink = Okio.buffer(Okio.sink(rawSocket));
+
+    // The following try/catch block is a pseudo hacky way to get around a crash on Android 7.0
+    // More details:
+    // https://github.com/square/okhttp/issues/3245
+    // https://android-review.googlesource.com/#/c/271775/
+    try {
+      source = Okio.buffer(Okio.source(rawSocket));
+      sink = Okio.buffer(Okio.sink(rawSocket));
+    } catch (NullPointerException npe) {
+      if (NPE_THROW_WITH_NULL.equals(npe.getMessage())) {
+        throw new IOException(npe);
+      }
+    }
   }
 
-  private void establishProtocol(int readTimeout, int writeTimeout,
-      ConnectionSpecSelector connectionSpecSelector) throws IOException {
-    if (route.address().sslSocketFactory() != null) {
-      connectTls(readTimeout, writeTimeout, connectionSpecSelector);
-    } else {
+  private void establishProtocol(ConnectionSpecSelector connectionSpecSelector, Call call,
+      EventListener eventListener) throws IOException {
+    if (route.address().sslSocketFactory() == null) {
       protocol = Protocol.HTTP_1_1;
       socket = rawSocket;
+      return;
     }
 
-    if (protocol == Protocol.HTTP_2) {
-      socket.setSoTimeout(0); // Framed connection timeouts are set per-stream.
+    eventListener.secureConnectStart(call);
+    try {
+      connectTls(connectionSpecSelector);
+    } catch (Exception e) {
+      eventListener.secureConnectEnd(call, null, e);
+      throw e;
+    }
+    eventListener.secureConnectEnd(call, handshake, null);
 
-      Http2Connection http2Connection = new Http2Connection.Builder(true)
+    if (protocol == Protocol.HTTP_2) {
+      socket.setSoTimeout(0); // HTTP/2 connection timeouts are set per-stream.
+      http2Connection = new Http2Connection.Builder(true)
           .socket(socket, route.address().url().host(), source, sink)
           .listener(this)
           .build();
       http2Connection.start();
-
-      // Only assign the framed connection once the preface has been sent successfully.
-      this.allocationLimit = http2Connection.maxConcurrentStreams();
-      this.http2Connection = http2Connection;
-    } else {
-      this.allocationLimit = 1;
     }
   }
 
-  private void connectTls(int readTimeout, int writeTimeout,
-      ConnectionSpecSelector connectionSpecSelector) throws IOException {
+  private void connectTls(ConnectionSpecSelector connectionSpecSelector) throws IOException {
     Address address = route.address();
     SSLSocketFactory sslSocketFactory = address.sslSocketFactory();
     boolean success = false;
@@ -294,7 +343,9 @@ private Request createTunnel(int readTimeout, int writeTimeout, Request tunnelRe
       sink.timeout().timeout(writeTimeout, MILLISECONDS);
       tunnelConnection.writeRequest(tunnelRequest.headers(), requestLine);
       tunnelConnection.finishRequest();
-      Response response = tunnelConnection.readResponse().request(tunnelRequest).build();
+      Response response = tunnelConnection.readResponseHeaders(false)
+          .request(tunnelRequest)
+          .build();
       // The response body from a CONNECT should be empty, but if it is not then we should consume
       // it before proceeding.
       long contentLength = HttpHeaders.contentLength(response);
@@ -341,11 +392,91 @@ private Request createTunnelRequest() {
     return new Request.Builder()
         .url(route.address().url())
         .header("Host", Util.hostHeader(route.address().url(), true))
-        .header("Proxy-Connection", "Keep-Alive")
-        .header("User-Agent", Version.userAgent()) // For HTTP/1.0 proxies like Squid.
+        .header("Proxy-Connection", "Keep-Alive") // For HTTP/1.0 proxies like Squid.
+        .header("User-Agent", Version.userAgent())
         .build();
   }
 
+  /**
+   * Returns true if this connection can carry a stream allocation to {@code address}. If non-null
+   * {@code route} is the resolved route for a connection.
+   */
+  public boolean isEligible(Address address, @Nullable Route route) {
+    // If this connection is not accepting new streams, we're done.
+    if (allocations.size() >= allocationLimit || noNewStreams) return false;
+
+    // If the non-host fields of the address don't overlap, we're done.
+    if (!Internal.instance.equalsNonHost(this.route.address(), address)) return false;
+
+    // If the host exactly matches, we're done: this connection can carry the address.
+    if (address.url().host().equals(this.route().address().url().host())) {
+      return true; // This connection is a perfect match.
+    }
+
+    // At this point we don't have a hostname match. But we still be able to carry the request if
+    // our connection coalescing requirements are met. See also:
+    // https://hpbn.co/optimizing-application-delivery/#eliminate-domain-sharding
+    // https://daniel.haxx.se/blog/2016/08/18/http2-connection-coalescing/
+
+    // 1. This connection must be HTTP/2.
+    if (http2Connection == null) return false;
+
+    // 2. The routes must share an IP address. This requires us to have a DNS address for both
+    // hosts, which only happens after route planning. We can't coalesce connections that use a
+    // proxy, since proxies don't tell us the origin server's IP address.
+    if (route == null) return false;
+    if (route.proxy().type() != Proxy.Type.DIRECT) return false;
+    if (this.route.proxy().type() != Proxy.Type.DIRECT) return false;
+    if (!this.route.socketAddress().equals(route.socketAddress())) return false;
+
+    // 3. This connection's server certificate's must cover the new host.
+    if (route.address().hostnameVerifier() != OkHostnameVerifier.INSTANCE) return false;
+    if (!supportsUrl(address.url())) return false;
+
+    // 4. Certificate pinning must match the host.
+    try {
+      address.certificatePinner().check(address.url().host(), handshake().peerCertificates());
+    } catch (SSLPeerUnverifiedException e) {
+      return false;
+    }
+
+    return true; // The caller's address can be carried by this connection.
+  }
+
+  public boolean supportsUrl(HttpUrl url) {
+    if (url.port() != route.address().url().port()) {
+      return false; // Port mismatch.
+    }
+
+    if (!url.host().equals(route.address().url().host())) {
+      // We have a host mismatch. But if the certificate matches, we're still good.
+      return handshake != null && OkHostnameVerifier.INSTANCE.verify(
+          url.host(), (X509Certificate) handshake.peerCertificates().get(0));
+    }
+
+    return true; // Success. The URL is supported.
+  }
+
+  public HttpCodec newCodec(
+      OkHttpClient client, StreamAllocation streamAllocation) throws SocketException {
+    if (http2Connection != null) {
+      return new Http2Codec(client, streamAllocation, http2Connection);
+    } else {
+      socket.setSoTimeout(client.readTimeoutMillis());
+      source.timeout().timeout(client.readTimeoutMillis(), MILLISECONDS);
+      sink.timeout().timeout(client.writeTimeoutMillis(), MILLISECONDS);
+      return new Http1Codec(client, streamAllocation, source, sink);
+    }
+  }
+
+  public RealWebSocket.Streams newWebSocketStreams(final StreamAllocation streamAllocation) {
+    return new RealWebSocket.Streams(true, source, sink) {
+      @Override public void close() throws IOException {
+        streamAllocation.streamFinished(true, streamAllocation.codec());
+      }
+    };
+  }
+
   @Override public Route route() {
     return route;
   }
@@ -398,7 +529,9 @@ public boolean isHealthy(boolean doExtensiveChecks) {
 
   /** When settings are received, adjust the allocation limit. */
   @Override public void onSettings(Http2Connection connection) {
-    allocationLimit = connection.maxConcurrentStreams();
+    synchronized (connectionPool) {
+      allocationLimit = connection.maxConcurrentStreams();
+    }
   }
 
   @Override public Handshake handshake() {
@@ -414,11 +547,7 @@ public boolean isMultiplexed() {
   }
 
   @Override public Protocol protocol() {
-    if (http2Connection == null) {
-      return protocol != null ? protocol : Protocol.HTTP_1_1;
-    } else {
-      return Protocol.HTTP_2;
-    }
+    return protocol;
   }
 
   @Override public String toString() {
diff --git a/okhttp/src/main/java/okhttp3/internal/connection/RouteDatabase.java b/okhttp/src/main/java/okhttp3/internal/connection/RouteDatabase.java
index 1cc3f311b9..d0c1a9d79e 100644
--- a/okhttp/src/main/java/okhttp3/internal/connection/RouteDatabase.java
+++ b/okhttp/src/main/java/okhttp3/internal/connection/RouteDatabase.java
@@ -33,7 +33,7 @@ public synchronized void failed(Route failedRoute) {
     failedRoutes.add(failedRoute);
   }
 
-  /** Records success connecting to {@code failedRoute}. */
+  /** Records success connecting to {@code route}. */
   public synchronized void connected(Route route) {
     failedRoutes.remove(route);
   }
diff --git a/okhttp/src/main/java/okhttp3/internal/connection/RouteSelector.java b/okhttp/src/main/java/okhttp3/internal/connection/RouteSelector.java
index 7e5d08d28b..ba1491c6e4 100644
--- a/okhttp/src/main/java/okhttp3/internal/connection/RouteSelector.java
+++ b/okhttp/src/main/java/okhttp3/internal/connection/RouteSelector.java
@@ -21,11 +21,14 @@
 import java.net.Proxy;
 import java.net.SocketAddress;
 import java.net.SocketException;
+import java.net.UnknownHostException;
 import java.util.ArrayList;
 import java.util.Collections;
 import java.util.List;
 import java.util.NoSuchElementException;
 import okhttp3.Address;
+import okhttp3.Call;
+import okhttp3.EventListener;
 import okhttp3.HttpUrl;
 import okhttp3.Route;
 import okhttp3.internal.Util;
@@ -37,6 +40,8 @@
 public final class RouteSelector {
   private final Address address;
   private final RouteDatabase routeDatabase;
+  private final Call call;
+  private final EventListener eventListener;
 
   /* The most recently attempted route. */
   private Proxy lastProxy;
@@ -53,9 +58,12 @@
   /* State for negotiating failed routes */
   private final List<Route> postponedRoutes = new ArrayList<>();
 
-  public RouteSelector(Address address, RouteDatabase routeDatabase) {
+  public RouteSelector(Address address, RouteDatabase routeDatabase, Call call,
+      EventListener eventListener) {
     this.address = address;
     this.routeDatabase = routeDatabase;
+    this.call = call;
+    this.eventListener = eventListener;
 
     resetNextProxy(address.url(), address.proxy());
   }
@@ -166,8 +174,25 @@ private void resetNextInetSocketAddress(Proxy proxy) throws IOException {
     if (proxy.type() == Proxy.Type.SOCKS) {
       inetSocketAddresses.add(InetSocketAddress.createUnresolved(socketHost, socketPort));
     } else {
+      eventListener.dnsStart(call, socketHost);
+
       // Try each address for best behavior in mixed IPv4/IPv6 environments.
-      List<InetAddress> addresses = address.dns().lookup(socketHost);
+      List<InetAddress> addresses;
+      try {
+        addresses = address.dns().lookup(socketHost);
+      } catch (Exception e) {
+        eventListener.dnsEnd(call, socketHost, null, e);
+        throw e;
+      }
+      if (addresses.isEmpty()) {
+        UnknownHostException exception = new UnknownHostException(
+            address.dns() + " returned no addresses for " + socketHost);
+        eventListener.dnsEnd(call, socketHost, null, exception);
+        throw exception;
+      }
+
+      eventListener.dnsEnd(call, socketHost, addresses, null);
+
       for (int i = 0, size = addresses.size(); i < size; i++) {
         InetAddress inetAddress = addresses.get(i);
         inetSocketAddresses.add(new InetSocketAddress(inetAddress, socketPort));
diff --git a/okhttp/src/main/java/okhttp3/internal/connection/StreamAllocation.java b/okhttp/src/main/java/okhttp3/internal/connection/StreamAllocation.java
index b78e3c54b1..ecca028c3c 100644
--- a/okhttp/src/main/java/okhttp3/internal/connection/StreamAllocation.java
+++ b/okhttp/src/main/java/okhttp3/internal/connection/StreamAllocation.java
@@ -18,20 +18,21 @@
 import java.io.IOException;
 import java.lang.ref.Reference;
 import java.lang.ref.WeakReference;
+import java.net.Socket;
 import okhttp3.Address;
+import okhttp3.Call;
 import okhttp3.ConnectionPool;
+import okhttp3.EventListener;
 import okhttp3.OkHttpClient;
 import okhttp3.Route;
 import okhttp3.internal.Internal;
 import okhttp3.internal.Util;
 import okhttp3.internal.http.HttpCodec;
-import okhttp3.internal.http1.Http1Codec;
-import okhttp3.internal.http2.ErrorCode;
-import okhttp3.internal.http2.Http2Codec;
 import okhttp3.internal.http2.ConnectionShutdownException;
+import okhttp3.internal.http2.ErrorCode;
 import okhttp3.internal.http2.StreamResetException;
 
-import static java.util.concurrent.TimeUnit.MILLISECONDS;
+import static okhttp3.internal.Util.closeQuietly;
 
 /**
  * This class coordinates the relationship between three entities:
@@ -74,6 +75,8 @@
   public final Address address;
   private Route route;
   private final ConnectionPool connectionPool;
+  private final Call call;
+  private final EventListener eventListener;
   private final Object callStackTrace;
 
   // State guarded by connectionPool.
@@ -84,10 +87,13 @@
   private boolean canceled;
   private HttpCodec codec;
 
-  public StreamAllocation(ConnectionPool connectionPool, Address address, Object callStackTrace) {
+  public StreamAllocation(ConnectionPool connectionPool, Address address, Call call,
+      EventListener eventListener, Object callStackTrace) {
     this.connectionPool = connectionPool;
     this.address = address;
-    this.routeSelector = new RouteSelector(address, routeDatabase());
+    this.call = call;
+    this.eventListener = eventListener;
+    this.routeSelector = new RouteSelector(address, routeDatabase(), call, eventListener);
     this.callStackTrace = callStackTrace;
   }
 
@@ -100,17 +106,7 @@ public HttpCodec newStream(OkHttpClient client, boolean doExtensiveHealthChecks)
     try {
       RealConnection resultConnection = findHealthyConnection(connectTimeout, readTimeout,
           writeTimeout, connectionRetryEnabled, doExtensiveHealthChecks);
-
-      HttpCodec resultCodec;
-      if (resultConnection.http2Connection != null) {
-        resultCodec = new Http2Codec(client, this, resultConnection.http2Connection);
-      } else {
-        resultConnection.socket().setSoTimeout(readTimeout);
-        resultConnection.source.timeout().timeout(readTimeout, MILLISECONDS);
-        resultConnection.sink.timeout().timeout(writeTimeout, MILLISECONDS);
-        resultCodec = new Http1Codec(
-            client, this, resultConnection.source, resultConnection.sink);
-      }
+      HttpCodec resultCodec = resultConnection.newCodec(client, this);
 
       synchronized (connectionPool) {
         codec = resultCodec;
@@ -162,45 +158,70 @@ private RealConnection findConnection(int connectTimeout, int readTimeout, int w
       if (codec != null) throw new IllegalStateException("codec != null");
       if (canceled) throw new IOException("Canceled");
 
+      // Attempt to use an already-allocated connection.
       RealConnection allocatedConnection = this.connection;
       if (allocatedConnection != null && !allocatedConnection.noNewStreams) {
         return allocatedConnection;
       }
 
       // Attempt to get a connection from the pool.
-      RealConnection pooledConnection = Internal.instance.get(connectionPool, address, this);
-      if (pooledConnection != null) {
-        this.connection = pooledConnection;
-        return pooledConnection;
+      Internal.instance.get(connectionPool, address, this, null);
+      if (connection != null) {
+        return connection;
       }
 
       selectedRoute = route;
     }
 
+    // If we need a route, make one. This is a blocking operation.
     if (selectedRoute == null) {
       selectedRoute = routeSelector.next();
-      synchronized (connectionPool) {
-        route = selectedRoute;
-        refusedStreamCount = 0;
-      }
     }
-    RealConnection newConnection = new RealConnection(selectedRoute);
 
+    RealConnection result;
     synchronized (connectionPool) {
-      acquire(newConnection);
-      Internal.instance.put(connectionPool, newConnection);
-      this.connection = newConnection;
       if (canceled) throw new IOException("Canceled");
+
+      // Now that we have an IP address, make another attempt at getting a connection from the pool.
+      // This could match due to connection coalescing.
+      Internal.instance.get(connectionPool, address, this, selectedRoute);
+      if (connection != null) {
+        route = selectedRoute;
+        return connection;
+      }
+
+      // Create a connection and assign it to this allocation immediately. This makes it possible
+      // for an asynchronous cancel() to interrupt the handshake we're about to do.
+      route = selectedRoute;
+      refusedStreamCount = 0;
+      result = new RealConnection(connectionPool, selectedRoute);
+      acquire(result);
     }
 
-    newConnection.connect(connectTimeout, readTimeout, writeTimeout, address.connectionSpecs(),
-        connectionRetryEnabled);
-    routeDatabase().connected(newConnection.route());
+    // Do TCP + TLS handshakes. This is a blocking operation.
+    result.connect(
+        connectTimeout, readTimeout, writeTimeout, connectionRetryEnabled, call, eventListener);
+    routeDatabase().connected(result.route());
+
+    Socket socket = null;
+    synchronized (connectionPool) {
+      // Pool the connection.
+      Internal.instance.put(connectionPool, result);
+
+      // If another multiplexed connection to the same address was created concurrently, then
+      // release this connection and acquire that one.
+      if (result.isMultiplexed()) {
+        socket = Internal.instance.deduplicate(connectionPool, address, this);
+        result = connection;
+      }
+    }
+    closeQuietly(socket);
 
-    return newConnection;
+    return result;
   }
 
   public void streamFinished(boolean noNewStreams, HttpCodec codec) {
+    Socket socket;
     synchronized (connectionPool) {
       if (codec == null || codec != this.codec) {
         throw new IllegalStateException("expected " + this.codec + " but was " + codec);
@@ -208,8 +229,9 @@ public void streamFinished(boolean noNewStreams, HttpCodec codec) {
       if (!noNewStreams) {
         connection.successCount++;
       }
+      socket = deallocate(noNewStreams, false, true);
     }
-    deallocate(noNewStreams, false, true);
+    closeQuietly(socket);
   }
 
   public HttpCodec codec() {
@@ -227,46 +249,55 @@ public synchronized RealConnection connection() {
   }
 
   public void release() {
-    deallocate(false, true, false);
+    Socket socket;
+    synchronized (connectionPool) {
+      socket = deallocate(false, true, false);
+    }
+    closeQuietly(socket);
   }
 
   /** Forbid new streams from being created on the connection that hosts this allocation. */
   public void noNewStreams() {
-    deallocate(true, false, false);
+    Socket socket;
+    synchronized (connectionPool) {
+      socket = deallocate(true, false, false);
+    }
+    closeQuietly(socket);
   }
 
   /**
    * Releases resources held by this allocation. If sufficient resources are allocated, the
-   * connection will be detached or closed.
+   * connection will be detached or closed. Callers must be synchronized on the connection pool.
+   *
+   * <p>Returns a closeable that the caller should pass to {@link Util#closeQuietly} upon completion
+   * of the synchronized block. (We don't do I/O while synchronized on the connection pool.)
    */
-  private void deallocate(boolean noNewStreams, boolean released, boolean streamFinished) {
-    RealConnection connectionToClose = null;
-    synchronized (connectionPool) {
-      if (streamFinished) {
-        this.codec = null;
-      }
-      if (released) {
-        this.released = true;
+  private Socket deallocate(boolean noNewStreams, boolean released, boolean streamFinished) {
+    assert (Thread.holdsLock(connectionPool));
+
+    if (streamFinished) {
+      this.codec = null;
+    }
+    if (released) {
+      this.released = true;
+    }
+    Socket socket = null;
+    if (connection != null) {
+      if (noNewStreams) {
+        connection.noNewStreams = true;
       }
-      if (connection != null) {
-        if (noNewStreams) {
-          connection.noNewStreams = true;
-        }
-        if (this.codec == null && (this.released || connection.noNewStreams)) {
-          release(connection);
-          if (connection.allocations.isEmpty()) {
-            connection.idleAtNanos = System.nanoTime();
-            if (Internal.instance.connectionBecameIdle(connectionPool, connection)) {
-              connectionToClose = connection;
-            }
+      if (this.codec == null && (this.released || connection.noNewStreams)) {
+        release(connection);
+        if (connection.allocations.isEmpty()) {
+          connection.idleAtNanos = System.nanoTime();
+          if (Internal.instance.connectionBecameIdle(connectionPool, connection)) {
+            socket = connection.socket();
           }
-          connection = null;
         }
+        connection = null;
       }
     }
-    if (connectionToClose != null) {
-      Util.closeQuietly(connectionToClose.socket());
-    }
+    return socket;
   }
 
   public void cancel() {
@@ -285,6 +316,7 @@ public void cancel() {
   }
 
   public void streamFailed(IOException e) {
+    Socket socket;
     boolean noNewStreams = false;
 
     synchronized (connectionPool) {
@@ -299,8 +331,8 @@ public void streamFailed(IOException e) {
           noNewStreams = true;
           route = null;
         }
-      } else if (connection != null && !connection.isMultiplexed()
-          || e instanceof ConnectionShutdownException) {
+      } else if (connection != null
+          && (!connection.isMultiplexed() || e instanceof ConnectionShutdownException)) {
         noNewStreams = true;
 
         // If this route hasn't completed a call, avoid it for new connections.
@@ -311,9 +343,10 @@ public void streamFailed(IOException e) {
           route = null;
         }
       }
+      socket = deallocate(noNewStreams, false, true);
     }
 
-    deallocate(noNewStreams, false, true);
+    closeQuietly(socket);
   }
 
   /**
@@ -322,6 +355,9 @@ public void streamFailed(IOException e) {
    */
   public void acquire(RealConnection connection) {
     assert (Thread.holdsLock(connectionPool));
+    if (this.connection != null) throw new IllegalStateException();
+
+    this.connection = connection;
     connection.allocations.add(new StreamAllocationReference(this, callStackTrace));
   }
 
@@ -337,12 +373,36 @@ private void release(RealConnection connection) {
     throw new IllegalStateException();
   }
 
+  /**
+   * Release the connection held by this connection and acquire {@code newConnection} instead. It is
+   * only safe to call this if the held connection is newly connected but duplicated by {@code
+   * newConnection}. Typically this occurs when concurrently connecting to an HTTP/2 webserver.
+   *
+   * <p>Returns a closeable that the caller should pass to {@link Util#closeQuietly} upon completion
+   * of the synchronized block. (We don't do I/O while synchronized on the connection pool.)
+   */
+  public Socket releaseAndAcquire(RealConnection newConnection) {
+    assert (Thread.holdsLock(connectionPool));
+    if (codec != null || connection.allocations.size() != 1) throw new IllegalStateException();
+
+    // Release the old connection.
+    Reference<StreamAllocation> onlyAllocation = connection.allocations.get(0);
+    Socket socket = deallocate(true, false, false);
+
+    // Acquire the new connection.
+    this.connection = newConnection;
+    newConnection.allocations.add(onlyAllocation);
+
+    return socket;
+  }
+
   public boolean hasMoreRoutes() {
     return route != null || routeSelector.hasNext();
   }
 
   @Override public String toString() {
-    return address.toString();
+    RealConnection connection = connection();
+    return connection != null ? connection.toString() : address.toString();
   }
 
   public static final class StreamAllocationReference extends WeakReference<StreamAllocation> {
diff --git a/okhttp/src/main/java/okhttp3/internal/http/BridgeInterceptor.java b/okhttp/src/main/java/okhttp3/internal/http/BridgeInterceptor.java
index f8a720ff8a..54b561da88 100644
--- a/okhttp/src/main/java/okhttp3/internal/http/BridgeInterceptor.java
+++ b/okhttp/src/main/java/okhttp3/internal/http/BridgeInterceptor.java
@@ -76,7 +76,7 @@ public BridgeInterceptor(CookieJar cookieJar) {
     // If we add an "Accept-Encoding: gzip" header field we're responsible for also decompressing
     // the transfer stream.
     boolean transparentGzip = false;
-    if (userRequest.header("Accept-Encoding") == null) {
+    if (userRequest.header("Accept-Encoding") == null && userRequest.header("Range") == null) {
       transparentGzip = true;
       requestBuilder.header("Accept-Encoding", "gzip");
     }
diff --git a/okhttp/src/main/java/okhttp3/internal/http/CallServerInterceptor.java b/okhttp/src/main/java/okhttp3/internal/http/CallServerInterceptor.java
index 6adbc28b56..3bc47183eb 100644
--- a/okhttp/src/main/java/okhttp3/internal/http/CallServerInterceptor.java
+++ b/okhttp/src/main/java/okhttp3/internal/http/CallServerInterceptor.java
@@ -21,6 +21,7 @@
 import okhttp3.Request;
 import okhttp3.Response;
 import okhttp3.internal.Util;
+import okhttp3.internal.connection.RealConnection;
 import okhttp3.internal.connection.StreamAllocation;
 import okio.BufferedSink;
 import okio.Okio;
@@ -35,23 +36,46 @@ public CallServerInterceptor(boolean forWebSocket) {
   }
 
   @Override public Response intercept(Chain chain) throws IOException {
-    HttpCodec httpCodec = ((RealInterceptorChain) chain).httpStream();
-    StreamAllocation streamAllocation = ((RealInterceptorChain) chain).streamAllocation();
-    Request request = chain.request();
+    RealInterceptorChain realChain = (RealInterceptorChain) chain;
+    HttpCodec httpCodec = realChain.httpStream();
+    StreamAllocation streamAllocation = realChain.streamAllocation();
+    RealConnection connection = (RealConnection) realChain.connection();
+    Request request = realChain.request();
 
     long sentRequestMillis = System.currentTimeMillis();
     httpCodec.writeRequestHeaders(request);
 
+    Response.Builder responseBuilder = null;
     if (HttpMethod.permitsRequestBody(request.method()) && request.body() != null) {
-      Sink requestBodyOut = httpCodec.createRequestBody(request, request.body().contentLength());
-      BufferedSink bufferedRequestBody = Okio.buffer(requestBodyOut);
-      request.body().writeTo(bufferedRequestBody);
-      bufferedRequestBody.close();
+      // If there's a "Expect: 100-continue" header on the request, wait for a "HTTP/1.1 100
+      // Continue" response before transmitting the request body. If we don't get that, return what
+      // we did get (such as a 4xx response) without ever transmitting the request body.
+      if ("100-continue".equalsIgnoreCase(request.header("Expect"))) {
+        httpCodec.flushRequest();
+        responseBuilder = httpCodec.readResponseHeaders(true);
+      }
+
+      if (responseBuilder == null) {
+        // Write the request body if the "Expect: 100-continue" expectation was met.
+        Sink requestBodyOut = httpCodec.createRequestBody(request, request.body().contentLength());
+        BufferedSink bufferedRequestBody = Okio.buffer(requestBodyOut);
+        request.body().writeTo(bufferedRequestBody);
+        bufferedRequestBody.close();
+      } else if (!connection.isMultiplexed()) {
+        // If the "Expect: 100-continue" expectation wasn't met, prevent the HTTP/1 connection from
+        // being reused. Otherwise we're still obligated to transmit the request body to leave the
+        // connection in a consistent state.
+        streamAllocation.noNewStreams();
+      }
     }
 
     httpCodec.finishRequest();
 
-    Response response = httpCodec.readResponseHeaders()
+    if (responseBuilder == null) {
+      responseBuilder = httpCodec.readResponseHeaders(false);
+    }
+
+    Response response = responseBuilder
         .request(request)
         .handshake(streamAllocation.connection().handshake())
         .sentRequestAtMillis(sentRequestMillis)
diff --git a/okhttp/src/main/java/okhttp3/internal/http/HttpCodec.java b/okhttp/src/main/java/okhttp3/internal/http/HttpCodec.java
index b227399e91..ad9759acce 100644
--- a/okhttp/src/main/java/okhttp3/internal/http/HttpCodec.java
+++ b/okhttp/src/main/java/okhttp3/internal/http/HttpCodec.java
@@ -37,10 +37,18 @@
   void writeRequestHeaders(Request request) throws IOException;
 
   /** Flush the request to the underlying socket. */
+  void flushRequest() throws IOException;
+
+  /** Flush the request to the underlying socket and signal no more bytes will be transmitted. */
   void finishRequest() throws IOException;
 
-  /** Read and return response headers. */
-  Response.Builder readResponseHeaders() throws IOException;
+  /**
+   * Parses bytes of a response header from an HTTP transport.
+   *
+   * @param expectContinue true to return null if this is an intermediate response with a "100"
+   *     response code. Otherwise this method never returns null.
+   */
+  Response.Builder readResponseHeaders(boolean expectContinue) throws IOException;
 
   /** Returns a stream that reads the response body. */
   ResponseBody openResponseBody(Response response) throws IOException;
diff --git a/okhttp/src/main/java/okhttp3/internal/http/RealInterceptorChain.java b/okhttp/src/main/java/okhttp3/internal/http/RealInterceptorChain.java
index d5326c64f5..77d2076997 100644
--- a/okhttp/src/main/java/okhttp3/internal/http/RealInterceptorChain.java
+++ b/okhttp/src/main/java/okhttp3/internal/http/RealInterceptorChain.java
@@ -17,11 +17,13 @@
 
 import java.io.IOException;
 import java.util.List;
+import okhttp3.Call;
 import okhttp3.Connection;
-import okhttp3.HttpUrl;
+import okhttp3.EventListener;
 import okhttp3.Interceptor;
 import okhttp3.Request;
 import okhttp3.Response;
+import okhttp3.internal.connection.RealConnection;
 import okhttp3.internal.connection.StreamAllocation;
 
 /**
@@ -32,19 +34,24 @@
   private final List<Interceptor> interceptors;
   private final StreamAllocation streamAllocation;
   private final HttpCodec httpCodec;
-  private final Connection connection;
+  private final RealConnection connection;
   private final int index;
   private final Request request;
+  private final Call call;
+  private final EventListener eventListener;
   private int calls;
 
   public RealInterceptorChain(List<Interceptor> interceptors, StreamAllocation streamAllocation,
-      HttpCodec httpCodec, Connection connection, int index, Request request) {
+      HttpCodec httpCodec, RealConnection connection, int index, Request request, Call call,
+      EventListener eventListener) {
     this.interceptors = interceptors;
     this.connection = connection;
     this.streamAllocation = streamAllocation;
     this.httpCodec = httpCodec;
     this.index = index;
     this.request = request;
+    this.call = call;
+    this.eventListener = eventListener;
   }
 
   @Override public Connection connection() {
@@ -59,6 +66,14 @@ public HttpCodec httpStream() {
     return httpCodec;
   }
 
+  public Call call() {
+    return call;
+  }
+
+  public EventListener eventListener() {
+    return eventListener;
+  }
+
   @Override public Request request() {
     return request;
   }
@@ -68,13 +83,13 @@ public HttpCodec httpStream() {
   }
 
   public Response proceed(Request request, StreamAllocation streamAllocation, HttpCodec httpCodec,
-      Connection connection) throws IOException {
+      RealConnection connection) throws IOException {
     if (index >= interceptors.size()) throw new AssertionError();
 
     calls++;
 
     // If we already have a stream, confirm that the incoming request will use it.
-    if (this.httpCodec != null && !sameConnection(request.url())) {
+    if (this.httpCodec != null && !this.connection.supportsUrl(request.url())) {
       throw new IllegalStateException("network interceptor " + interceptors.get(index - 1)
           + " must retain the same host and port");
     }
@@ -86,8 +101,8 @@ public Response proceed(Request request, StreamAllocation streamAllocation, Http
     }
 
     // Call the next interceptor in the chain.
-    RealInterceptorChain next = new RealInterceptorChain(
-        interceptors, streamAllocation, httpCodec, connection, index + 1, request);
+    RealInterceptorChain next = new RealInterceptorChain(interceptors, streamAllocation, httpCodec,
+        connection, index + 1, request, call, eventListener);
     Interceptor interceptor = interceptors.get(index);
     Response response = interceptor.intercept(next);
 
@@ -102,11 +117,11 @@ public Response proceed(Request request, StreamAllocation streamAllocation, Http
       throw new NullPointerException("interceptor " + interceptor + " returned null");
     }
 
-    return response;
-  }
+    if (response.body() == null) {
+      throw new IllegalStateException(
+          "interceptor " + interceptor + " returned a response with no body");
+    }
 
-  private boolean sameConnection(HttpUrl url) {
-    return url.host().equals(connection.route().address().url().host())
-        && url.port() == connection.route().address().url().port();
+    return response;
   }
 }
diff --git a/okhttp/src/main/java/okhttp3/internal/http/RetryAndFollowUpInterceptor.java b/okhttp/src/main/java/okhttp3/internal/http/RetryAndFollowUpInterceptor.java
index 792ddc9299..990be2a9af 100644
--- a/okhttp/src/main/java/okhttp3/internal/http/RetryAndFollowUpInterceptor.java
+++ b/okhttp/src/main/java/okhttp3/internal/http/RetryAndFollowUpInterceptor.java
@@ -27,8 +27,10 @@
 import javax.net.ssl.SSLPeerUnverifiedException;
 import javax.net.ssl.SSLSocketFactory;
 import okhttp3.Address;
+import okhttp3.Call;
 import okhttp3.CertificatePinner;
 import okhttp3.Connection;
+import okhttp3.EventListener;
 import okhttp3.HttpUrl;
 import okhttp3.Interceptor;
 import okhttp3.OkHttpClient;
@@ -102,9 +104,12 @@ public StreamAllocation streamAllocation() {
 
   @Override public Response intercept(Chain chain) throws IOException {
     Request request = chain.request();
+    RealInterceptorChain realChain = (RealInterceptorChain) chain;
+    Call call = realChain.call();
+    EventListener eventListener = realChain.eventListener();
 
-    streamAllocation = new StreamAllocation(
-        client.connectionPool(), createAddress(request.url()), callStackTrace);
+    streamAllocation = new StreamAllocation(client.connectionPool(), createAddress(request.url()),
+        call, eventListener, callStackTrace);
 
     int followUpCount = 0;
     Response priorResponse = null;
@@ -117,7 +122,7 @@ public StreamAllocation streamAllocation() {
       Response response = null;
       boolean releaseConnection = true;
       try {
-        response = ((RealInterceptorChain) chain).proceed(request, streamAllocation, null, null);
+        response = realChain.proceed(request, streamAllocation, null, null);
         releaseConnection = false;
       } catch (RouteException e) {
         // The attempt to connect via a route failed. The request will not have been sent.
@@ -172,8 +177,8 @@ public StreamAllocation streamAllocation() {
 
       if (!sameConnection(response, followUp.url())) {
         streamAllocation.release();
-        streamAllocation = new StreamAllocation(
-            client.connectionPool(), createAddress(followUp.url()), callStackTrace);
+        streamAllocation = new StreamAllocation(client.connectionPool(),
+            createAddress(followUp.url()), call, eventListener, callStackTrace);
       } else if (streamAllocation.codec() != null) {
         throw new IllegalStateException("Closing the body of " + response
             + " didn't close its backing stream. Bad interceptor?");
diff --git a/okhttp/src/main/java/okhttp3/internal/http1/Http1Codec.java b/okhttp/src/main/java/okhttp3/internal/http1/Http1Codec.java
index 3df3696e1f..4be3a32ccc 100644
--- a/okhttp/src/main/java/okhttp3/internal/http1/Http1Codec.java
+++ b/okhttp/src/main/java/okhttp3/internal/http1/Http1Codec.java
@@ -55,7 +55,7 @@
  *     <li>Open a sink to write the request body. Either {@linkplain #newFixedLengthSink
  *         fixed-length} or {@link #newChunkedSink chunked}.
  *     <li>Write to and then close that sink.
- *     <li>{@linkplain #readResponse Read response headers}.
+ *     <li>{@linkplain #readResponseHeaders Read response headers}.
  *     <li>Open a source to read the response body. Either {@linkplain #newFixedLengthSource
  *         fixed-length}, {@linkplain #newChunkedSource chunked} or {@linkplain
  *         #newUnknownLengthSource unknown length}.
@@ -76,13 +76,13 @@
   private static final int STATE_CLOSED = 6;
 
   /** The client that configures this stream. May be null for HTTPS proxy tunnels. */
-  private final OkHttpClient client;
+  final OkHttpClient client;
   /** The stream allocation that owns this stream. May be null for HTTPS proxy tunnels. */
-  private final StreamAllocation streamAllocation;
+  final StreamAllocation streamAllocation;
 
-  private final BufferedSource source;
-  private final BufferedSink sink;
-  private int state = STATE_IDLE;
+  final BufferedSource source;
+  final BufferedSink sink;
+  int state = STATE_IDLE;
 
   public Http1Codec(OkHttpClient client, StreamAllocation streamAllocation, BufferedSource source,
       BufferedSink sink) {
@@ -128,10 +128,6 @@ public Http1Codec(OkHttpClient client, StreamAllocation streamAllocation, Buffer
     writeRequest(request.headers(), requestLine);
   }
 
-  @Override public Response.Builder readResponseHeaders() throws IOException {
-    return readResponse();
-  }
-
   @Override public ResponseBody openResponseBody(Response response) throws IOException {
     Source source = getTransferStream(response);
     return new RealResponseBody(response.headers(), Okio.buffer(source));
@@ -162,6 +158,10 @@ public boolean isClosed() {
     return state == STATE_CLOSED;
   }
 
+  @Override public void flushRequest() throws IOException {
+    sink.flush();
+  }
+
   @Override public void finishRequest() throws IOException {
     sink.flush();
   }
@@ -180,27 +180,26 @@ public void writeRequest(Headers headers, String requestLine) throws IOException
     state = STATE_OPEN_REQUEST_BODY;
   }
 
-  /** Parses bytes of a response header from an HTTP transport. */
-  public Response.Builder readResponse() throws IOException {
+  @Override public Response.Builder readResponseHeaders(boolean expectContinue) throws IOException {
     if (state != STATE_OPEN_REQUEST_BODY && state != STATE_READ_RESPONSE_HEADERS) {
       throw new IllegalStateException("state: " + state);
     }
 
     try {
-      while (true) {
-        StatusLine statusLine = StatusLine.parse(source.readUtf8LineStrict());
-
-        Response.Builder responseBuilder = new Response.Builder()
-            .protocol(statusLine.protocol)
-            .code(statusLine.code)
-            .message(statusLine.message)
-            .headers(readHeaders());
-
-        if (statusLine.code != HTTP_CONTINUE) {
-          state = STATE_OPEN_RESPONSE_BODY;
-          return responseBuilder;
-        }
+      StatusLine statusLine = StatusLine.parse(source.readUtf8LineStrict());
+
+      Response.Builder responseBuilder = new Response.Builder()
+          .protocol(statusLine.protocol)
+          .code(statusLine.code)
+          .message(statusLine.message)
+          .headers(readHeaders());
+
+      if (expectContinue && statusLine.code == HTTP_CONTINUE) {
+        return null;
       }
+
+      state = STATE_OPEN_RESPONSE_BODY;
+      return responseBuilder;
     } catch (EOFException e) {
       // Provide more context if the server ends the stream before sending a response.
       IOException exception = new IOException("unexpected end of stream on " + streamAllocation);
@@ -256,7 +255,7 @@ public Source newUnknownLengthSource() throws IOException {
    * to the default configuration. Use this to avoid unexpected sharing of timeouts between pooled
    * connections.
    */
-  private void detachTimeout(ForwardingTimeout timeout) {
+  void detachTimeout(ForwardingTimeout timeout) {
     Timeout oldDelegate = timeout.delegate();
     timeout.setDelegate(Timeout.NONE);
     oldDelegate.clearDeadline();
@@ -269,7 +268,7 @@ private void detachTimeout(ForwardingTimeout timeout) {
     private boolean closed;
     private long bytesRemaining;
 
-    private FixedLengthSink(long bytesRemaining) {
+    FixedLengthSink(long bytesRemaining) {
       this.bytesRemaining = bytesRemaining;
     }
 
@@ -310,6 +309,9 @@ private FixedLengthSink(long bytesRemaining) {
     private final ForwardingTimeout timeout = new ForwardingTimeout(sink.timeout());
     private boolean closed;
 
+    ChunkedSink() {
+    }
+
     @Override public Timeout timeout() {
       return timeout;
     }
@@ -367,7 +369,7 @@ protected final void endOfInput(boolean reuseConnection) throws IOException {
   private class FixedLengthSource extends AbstractSource {
     private long bytesRemaining;
 
-    public FixedLengthSource(long length) throws IOException {
+    FixedLengthSource(long length) throws IOException {
       bytesRemaining = length;
       if (bytesRemaining == 0) {
         endOfInput(true);
@@ -468,6 +470,9 @@ private void readChunkSize() throws IOException {
   private class UnknownLengthSource extends AbstractSource {
     private boolean inputExhausted;
 
+    UnknownLengthSource() {
+    }
+
     @Override public long read(Buffer sink, long byteCount)
         throws IOException {
       if (byteCount < 0) throw new IllegalArgumentException("byteCount < 0: " + byteCount);
diff --git a/okhttp/src/main/java/okhttp3/internal/http2/Hpack.java b/okhttp/src/main/java/okhttp3/internal/http2/Hpack.java
index 3aeed262b4..a28698bf01 100644
--- a/okhttp/src/main/java/okhttp3/internal/http2/Hpack.java
+++ b/okhttp/src/main/java/okhttp3/internal/http2/Hpack.java
@@ -44,7 +44,7 @@
   private static final int PREFIX_6_BITS = 0x3f;
   private static final int PREFIX_7_BITS = 0x7f;
 
-  private static final Header[] STATIC_HEADER_TABLE = new Header[] {
+  static final Header[] STATIC_HEADER_TABLE = new Header[] {
       new Header(Header.TARGET_AUTHORITY, ""),
       new Header(Header.TARGET_METHOD, "GET"),
       new Header(Header.TARGET_METHOD, "POST"),
@@ -346,7 +346,7 @@ ByteString readByteString() throws IOException {
     }
   }
 
-  private static final Map<ByteString, Integer> NAME_TO_FIRST_INDEX = nameToFirstIndex();
+  static final Map<ByteString, Integer> NAME_TO_FIRST_INDEX = nameToFirstIndex();
 
   private static Map<ByteString, Integer> nameToFirstIndex() {
     Map<ByteString, Integer> result = new LinkedHashMap<>(STATIC_HEADER_TABLE.length);
@@ -587,7 +587,7 @@ private void adjustDynamicTableByteCount() {
    * An HTTP/2 response cannot contain uppercase header characters and must be treated as
    * malformed.
    */
-  private static ByteString checkLowercase(ByteString name) throws IOException {
+  static ByteString checkLowercase(ByteString name) throws IOException {
     for (int i = 0, length = name.size(); i < length; i++) {
       byte c = name.getByte(i);
       if (c >= 'A' && c <= 'Z') {
diff --git a/okhttp/src/main/java/okhttp3/internal/http2/Http2Codec.java b/okhttp/src/main/java/okhttp3/internal/http2/Http2Codec.java
index 0c8c959f86..0ed8be7b39 100644
--- a/okhttp/src/main/java/okhttp3/internal/http2/Http2Codec.java
+++ b/okhttp/src/main/java/okhttp3/internal/http2/Http2Codec.java
@@ -40,6 +40,7 @@
 import okio.Sink;
 import okio.Source;
 
+import static okhttp3.internal.http.StatusLine.HTTP_CONTINUE;
 import static okhttp3.internal.http2.Header.RESPONSE_STATUS;
 import static okhttp3.internal.http2.Header.TARGET_AUTHORITY;
 import static okhttp3.internal.http2.Header.TARGET_METHOD;
@@ -82,7 +83,7 @@
       UPGRADE);
 
   private final OkHttpClient client;
-  private final StreamAllocation streamAllocation;
+  final StreamAllocation streamAllocation;
   private final Http2Connection connection;
   private Http2Stream stream;
 
@@ -107,12 +108,21 @@ public Http2Codec(
     stream.writeTimeout().timeout(client.writeTimeoutMillis(), TimeUnit.MILLISECONDS);
   }
 
+  @Override public void flushRequest() throws IOException {
+    connection.flush();
+  }
+
   @Override public void finishRequest() throws IOException {
     stream.getSink().close();
   }
 
-  @Override public Response.Builder readResponseHeaders() throws IOException {
-    return readHttp2HeadersList(stream.getResponseHeaders());
+  @Override public Response.Builder readResponseHeaders(boolean expectContinue) throws IOException {
+    List<Header> headers = stream.takeResponseHeaders();
+    Response.Builder responseBuilder = readHttp2HeadersList(headers);
+    if (expectContinue && Internal.instance.code(responseBuilder) == HTTP_CONTINUE) {
+      return null;
+    }
+    return responseBuilder;
   }
 
   public static List<Header> http2HeadersList(Request request) {
@@ -120,7 +130,10 @@ public Http2Codec(
     List<Header> result = new ArrayList<>(headers.size() + 4);
     result.add(new Header(TARGET_METHOD, request.method()));
     result.add(new Header(TARGET_PATH, RequestLine.requestPath(request.url())));
-    result.add(new Header(TARGET_AUTHORITY, Util.hostHeader(request.url(), false))); // Optional.
+    String host = request.header("Host");
+    if (host != null) {
+      result.add(new Header(TARGET_AUTHORITY, host)); // Optional.
+    }
     result.add(new Header(TARGET_SCHEME, request.url().scheme()));
 
     for (int i = 0, size = headers.size(); i < size; i++) {
@@ -135,22 +148,31 @@ public Http2Codec(
 
   /** Returns headers for a name value block containing an HTTP/2 response. */
   public static Response.Builder readHttp2HeadersList(List<Header> headerBlock) throws IOException {
-    String status = null;
-
+    StatusLine statusLine = null;
     Headers.Builder headersBuilder = new Headers.Builder();
     for (int i = 0, size = headerBlock.size(); i < size; i++) {
-      ByteString name = headerBlock.get(i).name;
+      Header header = headerBlock.get(i);
+
+      // If there were multiple header blocks they will be delimited by nulls. Discard existing
+      // header blocks if the existing header block is a '100 Continue' intermediate response.
+      if (header == null) {
+        if (statusLine != null && statusLine.code == HTTP_CONTINUE) {
+          statusLine = null;
+          headersBuilder = new Headers.Builder();
+        }
+        continue;
+      }
 
-      String value = headerBlock.get(i).value.utf8();
+      ByteString name = header.name;
+      String value = header.value.utf8();
       if (name.equals(RESPONSE_STATUS)) {
-        status = value;
+        statusLine = StatusLine.parse("HTTP/1.1 " + value);
       } else if (!HTTP_2_SKIPPED_RESPONSE_HEADERS.contains(name)) {
         Internal.instance.addLenient(headersBuilder, name.utf8(), value);
       }
     }
-    if (status == null) throw new ProtocolException("Expected ':status' header not present");
+    if (statusLine == null) throw new ProtocolException("Expected ':status' header not present");
 
-    StatusLine statusLine = StatusLine.parse("HTTP/1.1 " + status);
     return new Response.Builder()
         .protocol(Protocol.HTTP_2)
         .code(statusLine.code)
@@ -168,7 +190,7 @@ public Http2Codec(
   }
 
   class StreamFinishingSource extends ForwardingSource {
-    public StreamFinishingSource(Source delegate) {
+    StreamFinishingSource(Source delegate) {
       super(delegate);
     }
 
diff --git a/okhttp/src/main/java/okhttp3/internal/http2/Http2Connection.java b/okhttp/src/main/java/okhttp3/internal/http2/Http2Connection.java
index 2ca5e0cbac..023a7ff35d 100644
--- a/okhttp/src/main/java/okhttp3/internal/http2/Http2Connection.java
+++ b/okhttp/src/main/java/okhttp3/internal/http2/Http2Connection.java
@@ -66,9 +66,9 @@
   // operations must synchronize on 'this' last. This ensures that we never
   // wait for a blocking operation while holding 'this'.
 
-  private static final ExecutorService executor = new ThreadPoolExecutor(0,
+  static final ExecutorService executor = new ThreadPoolExecutor(0,
       Integer.MAX_VALUE, 60, TimeUnit.SECONDS, new SynchronousQueue<Runnable>(),
-      Util.threadFactory("OkHttp FramedConnection", true));
+      Util.threadFactory("OkHttp Http2Connection", true));
 
   /** True if this peer initiated the connection. */
   final boolean client;
@@ -77,12 +77,12 @@
    * User code to run in response to incoming streams or settings. Calls to this are always invoked
    * on {@link #executor}.
    */
-  private final Listener listener;
-  private final Map<Integer, Http2Stream> streams = new LinkedHashMap<>();
-  private final String hostname;
-  private int lastGoodStreamId;
-  private int nextStreamId;
-  private boolean shutdown;
+  final Listener listener;
+  final Map<Integer, Http2Stream> streams = new LinkedHashMap<>();
+  final String hostname;
+  int lastGoodStreamId;
+  int nextStreamId;
+  boolean shutdown;
 
   /** Ensures push promise callbacks events are sent in order per stream. */
   private final ExecutorService pushExecutor;
@@ -90,7 +90,7 @@
   /** Lazily-created map of in-flight pings awaiting a response. Guarded by this. */
   private Map<Integer, Ping> pings;
   /** User code to run in response to push promise events. */
-  private final PushObserver pushObserver;
+  final PushObserver pushObserver;
   private int nextPingId;
 
   /**
@@ -115,14 +115,14 @@
   // TODO: MWS will need to guard on this setting before attempting to push.
   final Settings peerSettings = new Settings();
 
-  private boolean receivedInitialPeerSettings = false;
+  boolean receivedInitialPeerSettings = false;
   final Socket socket;
   final Http2Writer writer;
 
   // Visible for testing
   final ReaderRunnable readerRunnable;
 
-  private Http2Connection(Builder builder) {
+  Http2Connection(Builder builder) {
     pushObserver = builder.pushObserver;
     client = builder.client;
     listener = builder.listener;
@@ -346,7 +346,7 @@ public Ping ping() throws IOException {
     return ping;
   }
 
-  private void writePingLater(
+  void writePingLater(
       final boolean reply, final int payload1, final int payload2, final Ping ping) {
     executor.execute(new NamedRunnable("OkHttp %s ping %08x%08x",
         hostname, payload1, payload2) {
@@ -359,7 +359,7 @@ private void writePingLater(
     });
   }
 
-  private void writePing(boolean reply, int payload1, int payload2, Ping ping) throws IOException {
+  void writePing(boolean reply, int payload1, int payload2, Ping ping) throws IOException {
     synchronized (writer) {
       // Observe the sent time immediately before performing I/O.
       if (ping != null) ping.send();
@@ -367,7 +367,7 @@ private void writePing(boolean reply, int payload1, int payload2, Ping ping) thr
     }
   }
 
-  private synchronized Ping removePing(int id) {
+  synchronized Ping removePing(int id) {
     return pings != null ? pings.remove(id) : null;
   }
 
@@ -404,7 +404,7 @@ public void shutdown(ErrorCode statusCode) throws IOException {
     close(ErrorCode.NO_ERROR, ErrorCode.CANCEL);
   }
 
-  private void close(ErrorCode connectionCode, ErrorCode streamCode) throws IOException {
+  void close(ErrorCode connectionCode, ErrorCode streamCode) throws IOException {
     assert (!Thread.holdsLock(this));
     IOException thrown = null;
     try {
@@ -501,13 +501,13 @@ public synchronized boolean isShutdown() {
   }
 
   public static class Builder {
-    private Socket socket;
-    private String hostname;
-    private BufferedSource source;
-    private BufferedSink sink;
-    private Listener listener = Listener.REFUSE_INCOMING_STREAMS;
-    private PushObserver pushObserver = PushObserver.CANCEL;
-    private boolean client;
+    Socket socket;
+    String hostname;
+    BufferedSource source;
+    BufferedSink sink;
+    Listener listener = Listener.REFUSE_INCOMING_STREAMS;
+    PushObserver pushObserver = PushObserver.CANCEL;
+    boolean client;
 
     /**
      * @param client true if this peer initiated the connection; false if this peer accepted the
@@ -541,7 +541,7 @@ public Builder pushObserver(PushObserver pushObserver) {
       return this;
     }
 
-    public Http2Connection build() throws IOException {
+    public Http2Connection build() {
       return new Http2Connection(this);
     }
   }
@@ -553,7 +553,7 @@ public Http2Connection build() throws IOException {
   class ReaderRunnable extends NamedRunnable implements Http2Reader.Handler {
     final Http2Reader reader;
 
-    private ReaderRunnable(Http2Reader reader) {
+    ReaderRunnable(Http2Reader reader) {
       super("OkHttp %s", hostname);
       this.reader = reader;
     }
@@ -562,10 +562,8 @@ private ReaderRunnable(Http2Reader reader) {
       ErrorCode connectionErrorCode = ErrorCode.INTERNAL_ERROR;
       ErrorCode streamErrorCode = ErrorCode.INTERNAL_ERROR;
       try {
-        if (!client) {
-          reader.readConnectionPreface();
-        }
-        while (reader.nextFrame(this)) {
+        reader.readConnectionPreface(this);
+        while (reader.nextFrame(false, this)) {
         }
         connectionErrorCode = ErrorCode.NO_ERROR;
         streamErrorCode = ErrorCode.CANCEL;
@@ -629,7 +627,7 @@ private ReaderRunnable(Http2Reader reader) {
               try {
                 listener.onStream(newStream);
               } catch (IOException e) {
-                Platform.get().log(INFO, "FramedConnection.Listener failure for " + hostname, e);
+                Platform.get().log(INFO, "Http2Connection.Listener failure for " + hostname, e);
                 try {
                   newStream.close(ErrorCode.PROTOCOL_ERROR);
                 } catch (IOException ignored) {
@@ -771,14 +769,14 @@ public void pushPromise(int streamId, int promisedStreamId, List<Header> request
   }
 
   /** Even, positive numbered streams are pushed streams in HTTP/2. */
-  private boolean pushedStream(int streamId) {
+  boolean pushedStream(int streamId) {
     return streamId != 0 && (streamId & 1) == 0;
   }
 
   // Guarded by this.
-  private final Set<Integer> currentPushRequests = new LinkedHashSet<>();
+  final Set<Integer> currentPushRequests = new LinkedHashSet<>();
 
-  private void pushRequestLater(final int streamId, final List<Header> requestHeaders) {
+  void pushRequestLater(final int streamId, final List<Header> requestHeaders) {
     synchronized (this) {
       if (currentPushRequests.contains(streamId)) {
         writeSynResetLater(streamId, ErrorCode.PROTOCOL_ERROR);
@@ -802,7 +800,7 @@ private void pushRequestLater(final int streamId, final List<Header> requestHead
     });
   }
 
-  private void pushHeadersLater(final int streamId, final List<Header> requestHeaders,
+  void pushHeadersLater(final int streamId, final List<Header> requestHeaders,
       final boolean inFinished) {
     pushExecutor.execute(new NamedRunnable("OkHttp %s Push Headers[%s]", hostname, streamId) {
       @Override public void execute() {
@@ -824,7 +822,7 @@ private void pushHeadersLater(final int streamId, final List<Header> requestHead
    * Eagerly reads {@code byteCount} bytes from the source before launching a background task to
    * process the data.  This avoids corrupting the stream.
    */
-  private void pushDataLater(final int streamId, final BufferedSource source, final int byteCount,
+  void pushDataLater(final int streamId, final BufferedSource source, final int byteCount,
       final boolean inFinished) throws IOException {
     final Buffer buffer = new Buffer();
     source.require(byteCount); // Eagerly read the frame before firing client thread.
@@ -846,7 +844,7 @@ private void pushDataLater(final int streamId, final BufferedSource source, fina
     });
   }
 
-  private void pushResetLater(final int streamId, final ErrorCode errorCode) {
+  void pushResetLater(final int streamId, final ErrorCode errorCode) {
     pushExecutor.execute(new NamedRunnable("OkHttp %s Push Reset[%s]", hostname, streamId) {
       @Override public void execute() {
         pushObserver.onReset(streamId, errorCode);
@@ -867,8 +865,8 @@ private void pushResetLater(final int streamId, final ErrorCode errorCode) {
 
     /**
      * Handle a new stream from this connection's peer. Implementations should respond by either
-     * {@linkplain Http2Stream#reply replying to the stream} or {@linkplain Http2Stream#close
-     * closing it}. This response does not need to be synchronous.
+     * {@linkplain Http2Stream#sendResponseHeaders replying to the stream} or {@linkplain
+     * Http2Stream#close closing it}. This response does not need to be synchronous.
      */
     public abstract void onStream(Http2Stream stream) throws IOException;
 
diff --git a/okhttp/src/main/java/okhttp3/internal/http2/Http2Reader.java b/okhttp/src/main/java/okhttp3/internal/http2/Http2Reader.java
index a2d9e63678..2b093b3323 100644
--- a/okhttp/src/main/java/okhttp3/internal/http2/Http2Reader.java
+++ b/okhttp/src/main/java/okhttp3/internal/http2/Http2Reader.java
@@ -57,7 +57,7 @@
  * Http2#INITIAL_MAX_FRAME_SIZE}.
  */
 final class Http2Reader implements Closeable {
-  private static final Logger logger = Logger.getLogger(Http2.class.getName());
+  static final Logger logger = Logger.getLogger(Http2.class.getName());
 
   private final BufferedSource source;
   private final ContinuationSource continuation;
@@ -67,46 +67,55 @@
   final Hpack.Reader hpackReader;
 
   /** Creates a frame reader with max header table size of 4096. */
-  public Http2Reader(BufferedSource source, boolean client) {
+  Http2Reader(BufferedSource source, boolean client) {
     this.source = source;
     this.client = client;
     this.continuation = new ContinuationSource(this.source);
     this.hpackReader = new Hpack.Reader(4096, continuation);
   }
 
-  public void readConnectionPreface() throws IOException {
-    if (client) return; // Nothing to read; servers doesn't send a connection preface!
-    ByteString connectionPreface = source.readByteString(CONNECTION_PREFACE.size());
-    if (logger.isLoggable(FINE)) logger.fine(format("<< CONNECTION %s", connectionPreface.hex()));
-    if (!CONNECTION_PREFACE.equals(connectionPreface)) {
-      throw ioException("Expected a connection header but was %s", connectionPreface.utf8());
+  public void readConnectionPreface(Handler handler) throws IOException {
+    if (client) {
+      // The client reads the initial SETTINGS frame.
+      if (!nextFrame(true, handler)) {
+        throw ioException("Required SETTINGS preface not received");
+      }
+    } else {
+      // The server reads the CONNECTION_PREFACE byte string.
+      ByteString connectionPreface = source.readByteString(CONNECTION_PREFACE.size());
+      if (logger.isLoggable(FINE)) logger.fine(format("<< CONNECTION %s", connectionPreface.hex()));
+      if (!CONNECTION_PREFACE.equals(connectionPreface)) {
+        throw ioException("Expected a connection header but was %s", connectionPreface.utf8());
+      }
     }
   }
 
-  public boolean nextFrame(Handler handler) throws IOException {
+  public boolean nextFrame(boolean requireSettings, Handler handler) throws IOException {
     try {
       source.require(9); // Frame header size
     } catch (IOException e) {
       return false; // This might be a normal socket close.
     }
 
-      /*  0                   1                   2                   3
-       *  0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
-       * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
-       * |                 Length (24)                   |
-       * +---------------+---------------+---------------+
-       * |   Type (8)    |   Flags (8)   |
-       * +-+-+-----------+---------------+-------------------------------+
-       * |R|                 Stream Identifier (31)                      |
-       * +=+=============================================================+
-       * |                   Frame Payload (0...)                      ...
-       * +---------------------------------------------------------------+
-       */
+    //  0                   1                   2                   3
+    //  0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+    // +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+    // |                 Length (24)                   |
+    // +---------------+---------------+---------------+
+    // |   Type (8)    |   Flags (8)   |
+    // +-+-+-----------+---------------+-------------------------------+
+    // |R|                 Stream Identifier (31)                      |
+    // +=+=============================================================+
+    // |                   Frame Payload (0...)                      ...
+    // +---------------------------------------------------------------+
     int length = readMedium(source);
     if (length < 0 || length > INITIAL_MAX_FRAME_SIZE) {
       throw ioException("FRAME_SIZE_ERROR: %s", length);
     }
     byte type = (byte) (source.readByte() & 0xff);
+    if (requireSettings && type != TYPE_SETTINGS) {
+      throw ioException("Expected a SETTINGS frame but was %s", type);
+    }
     byte flags = (byte) (source.readByte() & 0xff);
     int streamId = (source.readInt() & 0x7fffffff); // Ignore reserved bit.
     if (logger.isLoggable(FINE)) logger.fine(frameLog(true, streamId, length, type, flags));
@@ -190,6 +199,8 @@ private void readHeaders(Handler handler, int length, byte flags, int streamId)
 
   private void readData(Handler handler, int length, byte flags, int streamId)
       throws IOException {
+    if (streamId == 0) throw ioException("PROTOCOL_ERROR: TYPE_DATA streamId == 0");
+
     // TODO: checkState open or half-closed (local) or raise STREAM_CLOSED
     boolean inFinished = (flags & FLAG_END_STREAM) != 0;
     boolean gzipped = (flags & FLAG_COMPRESSED) != 0;
@@ -345,7 +356,7 @@ private void readWindowUpdate(Handler handler, int length, byte flags, int strea
     int left;
     short padding;
 
-    public ContinuationSource(BufferedSource source) {
+    ContinuationSource(BufferedSource source) {
       this.source = source;
     }
 
diff --git a/okhttp/src/main/java/okhttp3/internal/http2/Http2Stream.java b/okhttp/src/main/java/okhttp3/internal/http2/Http2Stream.java
index 5997b21288..19ac954d7e 100644
--- a/okhttp/src/main/java/okhttp3/internal/http2/Http2Stream.java
+++ b/okhttp/src/main/java/okhttp3/internal/http2/Http2Stream.java
@@ -34,7 +34,7 @@
   // blocking operations are performed while the lock is held.
 
   /**
-   * The total number of bytes consumed by the application (with {@link FramedDataSource#read}), but
+   * The total number of bytes consumed by the application (with {@link FramingSource#read}), but
    * not yet acknowledged by sending a {@code WINDOW_UPDATE} frame on this stream.
    */
   // Visible for testing
@@ -48,26 +48,29 @@
   // guarded by this
   long bytesLeftInWriteWindow;
 
-  private final int id;
-  private final Http2Connection connection;
+  final int id;
+  final Http2Connection connection;
 
-  /** Headers sent by the stream initiator. Immutable and non null. */
+  /** Request headers. Immutable and non null. */
   private final List<Header> requestHeaders;
 
-  /** Headers sent in the stream reply. Null if reply is either not sent or not sent yet. */
+  /** Response headers yet to be {@linkplain #takeResponseHeaders taken}. */
   private List<Header> responseHeaders;
 
-  private final FramedDataSource source;
-  final FramedDataSink sink;
-  private final StreamTimeout readTimeout = new StreamTimeout();
-  private final StreamTimeout writeTimeout = new StreamTimeout();
+  /** True if response headers have been sent or received. */
+  private boolean hasResponseHeaders;
+
+  private final FramingSource source;
+  final FramingSink sink;
+  final StreamTimeout readTimeout = new StreamTimeout();
+  final StreamTimeout writeTimeout = new StreamTimeout();
 
   /**
    * The reason why this stream was abnormally closed. If there are multiple reasons to abnormally
    * close this stream (such as both peers closing it near-simultaneously) then this is the first
    * reason known to this peer.
    */
-  private ErrorCode errorCode = null;
+  ErrorCode errorCode = null;
 
   Http2Stream(int id, Http2Connection connection, boolean outFinished, boolean inFinished,
       List<Header> requestHeaders) {
@@ -77,9 +80,8 @@
     this.connection = connection;
     this.bytesLeftInWriteWindow =
         connection.peerSettings.getInitialWindowSize();
-    this.source = new FramedDataSource(
-        connection.okHttpSettings.getInitialWindowSize());
-    this.sink = new FramedDataSink();
+    this.source = new FramingSource(connection.okHttpSettings.getInitialWindowSize());
+    this.sink = new FramingSink();
     this.source.finished = inFinished;
     this.sink.finished = outFinished;
     this.requestHeaders = requestHeaders;
@@ -106,7 +108,7 @@ public synchronized boolean isOpen() {
     }
     if ((source.finished || source.closed)
         && (sink.finished || sink.closed)
-        && responseHeaders != null) {
+        && hasResponseHeaders) {
       return false;
     }
     return true;
@@ -127,10 +129,14 @@ public Http2Connection getConnection() {
   }
 
   /**
-   * Returns the stream's response headers, blocking if necessary if they have not been received
-   * yet.
+   * Removes and returns the stream's received response headers, blocking if necessary until headers
+   * have been received. If the returned list contains multiple blocks of headers the blocks will be
+   * delimited by 'null'.
    */
-  public synchronized List<Header> getResponseHeaders() throws IOException {
+  public synchronized List<Header> takeResponseHeaders() throws IOException {
+    if (!isLocallyInitiated()) {
+      throw new IllegalStateException("servers cannot read response headers");
+    }
     readTimeout.enter();
     try {
       while (responseHeaders == null && errorCode == null) {
@@ -139,7 +145,11 @@ public Http2Connection getConnection() {
     } finally {
       readTimeout.exitAndThrowIfTimedOut();
     }
-    if (responseHeaders != null) return responseHeaders;
+    List<Header> result = responseHeaders;
+    if (result != null) {
+      responseHeaders = null;
+      return result;
+    }
     throw new StreamResetException(errorCode);
   }
 
@@ -157,17 +167,14 @@ public synchronized ErrorCode getErrorCode() {
    * @param out true to create an output stream that we can use to send data to the remote peer.
    * Corresponds to {@code FLAG_FIN}.
    */
-  public void reply(List<Header> responseHeaders, boolean out) throws IOException {
+  public void sendResponseHeaders(List<Header> responseHeaders, boolean out) throws IOException {
     assert (!Thread.holdsLock(Http2Stream.this));
+    if (responseHeaders == null) {
+      throw new NullPointerException("responseHeaders == null");
+    }
     boolean outFinished = false;
     synchronized (this) {
-      if (responseHeaders == null) {
-        throw new NullPointerException("responseHeaders == null");
-      }
-      if (this.responseHeaders != null) {
-        throw new IllegalStateException("reply already sent");
-      }
-      this.responseHeaders = responseHeaders;
+      this.hasResponseHeaders = true;
       if (!out) {
         this.sink.finished = true;
         outFinished = true;
@@ -196,12 +203,12 @@ public Source getSource() {
   /**
    * Returns a sink that can be used to write data to the peer.
    *
-   * @throws IllegalStateException if this stream was initiated by the peer and a {@link #reply} has
-   * not yet been sent.
+   * @throws IllegalStateException if this stream was initiated by the peer and a {@link
+   * #sendResponseHeaders} has not yet been sent.
    */
   public Sink getSink() {
     synchronized (this) {
-      if (responseHeaders == null && !isLocallyInitiated()) {
+      if (!hasResponseHeaders && !isLocallyInitiated()) {
         throw new IllegalStateException("reply before requesting the sink");
       }
     }
@@ -251,6 +258,7 @@ void receiveHeaders(List<Header> headers) {
     assert (!Thread.holdsLock(Http2Stream.this));
     boolean open = true;
     synchronized (this) {
+      hasResponseHeaders = true;
       if (responseHeaders == null) {
         responseHeaders = headers;
         open = isOpen();
@@ -258,6 +266,7 @@ void receiveHeaders(List<Header> headers) {
       } else {
         List<Header> newHeaders = new ArrayList<>();
         newHeaders.addAll(responseHeaders);
+        newHeaders.add(null); // Delimit separate blocks of headers with null.
         newHeaders.addAll(headers);
         this.responseHeaders = newHeaders;
       }
@@ -297,31 +306,30 @@ synchronized void receiveRstStream(ErrorCode errorCode) {
    * synchronization to safely receive incoming data frames, it is not intended for use by multiple
    * readers.
    */
-  private final class FramedDataSource implements Source {
+  private final class FramingSource implements Source {
     /** Buffer to receive data from the network into. Only accessed by the reader thread. */
     private final Buffer receiveBuffer = new Buffer();
 
-    /** Buffer with readable data. Guarded by FramedStream.this. */
+    /** Buffer with readable data. Guarded by Http2Stream.this. */
     private final Buffer readBuffer = new Buffer();
 
     /** Maximum number of bytes to buffer before reporting a flow control error. */
     private final long maxByteCount;
 
     /** True if the caller has closed this stream. */
-    private boolean closed;
+    boolean closed;
 
     /**
      * True if either side has cleanly shut down this stream. We will receive no more bytes beyond
      * those already in the buffer.
      */
-    private boolean finished;
+    boolean finished;
 
-    private FramedDataSource(long maxByteCount) {
+    FramingSource(long maxByteCount) {
       this.maxByteCount = maxByteCount;
     }
 
-    @Override public long read(Buffer sink, long byteCount)
-        throws IOException {
+    @Override public long read(Buffer sink, long byteCount) throws IOException {
       if (byteCount < 0) throw new IllegalArgumentException("byteCount < 0: " + byteCount);
 
       long read;
@@ -430,7 +438,7 @@ private void checkNotClosed() throws IOException {
     }
   }
 
-  private void cancelStreamIfNecessary() throws IOException {
+  void cancelStreamIfNecessary() throws IOException {
     assert (!Thread.holdsLock(Http2Stream.this));
     boolean open;
     boolean cancel;
@@ -449,10 +457,8 @@ private void cancelStreamIfNecessary() throws IOException {
     }
   }
 
-  /**
-   * A sink that writes outgoing data frames of a stream. This class is not thread safe.
-   */
-  final class FramedDataSink implements Sink {
+  /** A sink that writes outgoing data frames of a stream. This class is not thread safe. */
+  final class FramingSink implements Sink {
     private static final long EMIT_BUFFER_SIZE = 16384;
 
     /**
@@ -461,18 +467,18 @@ private void cancelStreamIfNecessary() throws IOException {
      */
     private final Buffer sendBuffer = new Buffer();
 
-    private boolean closed;
+    boolean closed;
 
     /**
      * True if either side has cleanly shut down this stream. We shall send no more bytes.
      */
-    private boolean finished;
+    boolean finished;
 
     @Override public void write(Buffer source, long byteCount) throws IOException {
       assert (!Thread.holdsLock(Http2Stream.this));
       sendBuffer.write(source, byteCount);
       while (sendBuffer.size() >= EMIT_BUFFER_SIZE) {
-        emitDataFrame(false);
+        emitFrame(false);
       }
     }
 
@@ -480,7 +486,7 @@ private void cancelStreamIfNecessary() throws IOException {
      * Emit a single data frame to the connection. The frame's size be limited by this stream's
      * write window. This method will block until the write window is nonempty.
      */
-    private void emitDataFrame(boolean outFinished) throws IOException {
+    private void emitFrame(boolean outFinished) throws IOException {
       long toWrite;
       synchronized (Http2Stream.this) {
         writeTimeout.enter();
@@ -511,7 +517,7 @@ private void emitDataFrame(boolean outFinished) throws IOException {
         checkOutNotClosed();
       }
       while (sendBuffer.size() > 0) {
-        emitDataFrame(false);
+        emitFrame(false);
         connection.flush();
       }
     }
@@ -529,7 +535,7 @@ private void emitDataFrame(boolean outFinished) throws IOException {
         // Emit the remaining data, setting the END_STREAM flag on the last frame.
         if (sendBuffer.size() > 0) {
           while (sendBuffer.size() > 0) {
-            emitDataFrame(true);
+            emitFrame(true);
           }
         } else {
           // Send an empty frame just so we can set the END_STREAM flag.
@@ -552,7 +558,7 @@ void addBytesToWriteWindow(long delta) {
     if (delta > 0) Http2Stream.this.notifyAll();
   }
 
-  private void checkOutNotClosed() throws IOException {
+  void checkOutNotClosed() throws IOException {
     if (sink.closed) {
       throw new IOException("stream closed");
     } else if (sink.finished) {
@@ -566,7 +572,7 @@ private void checkOutNotClosed() throws IOException {
    * Like {@link #wait}, but throws an {@code InterruptedIOException} when interrupted instead of
    * the more awkward {@link InterruptedException}.
    */
-  private void waitForIo() throws InterruptedIOException {
+  void waitForIo() throws InterruptedIOException {
     try {
       wait();
     } catch (InterruptedException e) {
diff --git a/okhttp/src/main/java/okhttp3/internal/http2/Http2Writer.java b/okhttp/src/main/java/okhttp3/internal/http2/Http2Writer.java
index 7490b09ba0..5ef6bb9c4a 100644
--- a/okhttp/src/main/java/okhttp3/internal/http2/Http2Writer.java
+++ b/okhttp/src/main/java/okhttp3/internal/http2/Http2Writer.java
@@ -54,7 +54,7 @@
 
   final Hpack.Writer hpackWriter;
 
-  public Http2Writer(BufferedSink sink, boolean client) {
+  Http2Writer(BufferedSink sink, boolean client) {
     this.sink = sink;
     this.client = client;
     this.hpackBuffer = new Buffer();
diff --git a/okhttp/src/main/java/okhttp3/internal/http2/Huffman.java b/okhttp/src/main/java/okhttp3/internal/http2/Huffman.java
index 32582e9f40..7aa8024b72 100644
--- a/okhttp/src/main/java/okhttp3/internal/http2/Huffman.java
+++ b/okhttp/src/main/java/okhttp3/internal/http2/Huffman.java
@@ -196,13 +196,13 @@ private void addCode(int sym, int code, byte len) {
   private static final class Node {
 
     // Null if terminal.
-    private final Node[] children;
+    final Node[] children;
 
     // Terminal nodes have a symbol.
-    private final int symbol;
+    final int symbol;
 
     // Number of bits represented in the terminal node.
-    private final int terminalBits;
+    final int terminalBits;
 
     /** Construct an internal node. */
     Node() {
diff --git a/okhttp/src/main/java/okhttp3/internal/http2/Settings.java b/okhttp/src/main/java/okhttp3/internal/http2/Settings.java
index a43280c695..5b548de484 100644
--- a/okhttp/src/main/java/okhttp3/internal/http2/Settings.java
+++ b/okhttp/src/main/java/okhttp3/internal/http2/Settings.java
@@ -56,7 +56,7 @@ void clear() {
   }
 
   Settings set(int id, int value) {
-    if (id >= values.length) {
+    if (id < 0 || id >= values.length) {
       return this; // Discard unknown settings.
     }
 
@@ -94,7 +94,6 @@ boolean getEnablePush(boolean defaultValue) {
     return ((bit & set) != 0 ? values[ENABLE_PUSH] : defaultValue ? 1 : 0) == 1;
   }
 
-  // TODO: honor this setting.
   int getMaxConcurrentStreams(int defaultValue) {
     int bit = 1 << MAX_CONCURRENT_STREAMS;
     return (bit & set) != 0 ? values[MAX_CONCURRENT_STREAMS] : defaultValue;
diff --git a/okhttp/src/main/java/okhttp3/internal/platform/AndroidPlatform.java b/okhttp/src/main/java/okhttp3/internal/platform/AndroidPlatform.java
index c2cce4b0fb..31772c63f7 100644
--- a/okhttp/src/main/java/okhttp3/internal/platform/AndroidPlatform.java
+++ b/okhttp/src/main/java/okhttp3/internal/platform/AndroidPlatform.java
@@ -23,6 +23,7 @@
 import java.net.InetSocketAddress;
 import java.net.Socket;
 import java.security.cert.Certificate;
+import java.security.cert.TrustAnchor;
 import java.security.cert.X509Certificate;
 import java.util.List;
 import javax.net.ssl.SSLPeerUnverifiedException;
@@ -31,7 +32,9 @@
 import javax.net.ssl.X509TrustManager;
 import okhttp3.Protocol;
 import okhttp3.internal.Util;
+import okhttp3.internal.tls.BasicTrustRootIndex;
 import okhttp3.internal.tls.CertificateChainCleaner;
+import okhttp3.internal.tls.TrustRootIndex;
 
 /** Android 2.3 or better. */
 class AndroidPlatform extends Platform {
@@ -47,7 +50,7 @@
 
   private final CloseGuard closeGuard = CloseGuard.get();
 
-  public AndroidPlatform(Class<?> sslParametersClass, OptionalMethod<Socket> setUseSessionTickets,
+  AndroidPlatform(Class<?> sslParametersClass, OptionalMethod<Socket> setUseSessionTickets,
       OptionalMethod<Socket> setHostname, OptionalMethod<Socket> getAlpnSelectedProtocol,
       OptionalMethod<Socket> setAlpnProtocols) {
     this.sslParametersClass = sslParametersClass;
@@ -151,9 +154,7 @@ public AndroidPlatform(Class<?> sslParametersClass, OptionalMethod<Socket> setUs
       Class<?> networkPolicyClass = Class.forName("android.security.NetworkSecurityPolicy");
       Method getInstanceMethod = networkPolicyClass.getMethod("getInstance");
       Object networkSecurityPolicy = getInstanceMethod.invoke(null);
-      Method isCleartextTrafficPermittedMethod = networkPolicyClass
-          .getMethod("isCleartextTrafficPermitted", String.class);
-      return (boolean) isCleartextTrafficPermittedMethod.invoke(networkSecurityPolicy, hostname);
+      return api24IsCleartextTrafficPermitted(hostname, networkPolicyClass, networkSecurityPolicy);
     } catch (ClassNotFoundException | NoSuchMethodException e) {
       return super.isCleartextTrafficPermitted(hostname);
     } catch (IllegalAccessException | IllegalArgumentException | InvocationTargetException e) {
@@ -161,6 +162,28 @@ public AndroidPlatform(Class<?> sslParametersClass, OptionalMethod<Socket> setUs
     }
   }
 
+  private boolean api24IsCleartextTrafficPermitted(String hostname, Class<?> networkPolicyClass,
+      Object networkSecurityPolicy) throws InvocationTargetException, IllegalAccessException {
+    try {
+      Method isCleartextTrafficPermittedMethod = networkPolicyClass
+          .getMethod("isCleartextTrafficPermitted", String.class);
+      return (boolean) isCleartextTrafficPermittedMethod.invoke(networkSecurityPolicy, hostname);
+    } catch (NoSuchMethodException e) {
+      return api23IsCleartextTrafficPermitted(hostname, networkPolicyClass, networkSecurityPolicy);
+    }
+  }
+
+  private boolean api23IsCleartextTrafficPermitted(String hostname, Class<?> networkPolicyClass,
+      Object networkSecurityPolicy) throws InvocationTargetException, IllegalAccessException {
+    try {
+      Method isCleartextTrafficPermittedMethod = networkPolicyClass
+          .getMethod("isCleartextTrafficPermitted");
+      return (boolean) isCleartextTrafficPermittedMethod.invoke(networkSecurityPolicy);
+    } catch (NoSuchMethodException e) {
+      return super.isCleartextTrafficPermitted(hostname);
+    }
+  }
+
   public CertificateChainCleaner buildCertificateChainCleaner(X509TrustManager trustManager) {
     try {
       Class<?> extensionsClass = Class.forName("android.net.http.X509TrustManagerExtensions");
@@ -210,6 +233,21 @@ public static Platform buildIfSupported() {
     return null;
   }
 
+  @Override
+  public TrustRootIndex buildTrustRootIndex(X509TrustManager trustManager) {
+
+    try {
+      // From org.conscrypt.TrustManagerImpl, we want the method with this signature:
+      // private TrustAnchor findTrustAnchorByIssuerAndSignature(X509Certificate lastCert);
+      Method method = trustManager.getClass().getDeclaredMethod(
+              "findTrustAnchorByIssuerAndSignature", X509Certificate.class);
+      method.setAccessible(true);
+      return new AndroidTrustRootIndex(trustManager, method);
+    } catch (NoSuchMethodException e) {
+      return super.buildTrustRootIndex(trustManager);
+    }
+  }
+
   /**
    * X509TrustManagerExtensions was added to Android in API 17 (Android 4.2, released in late 2012).
    * This is the best way to get a clean chain on Android because it uses the same code as the TLS
@@ -307,4 +345,55 @@ static CloseGuard get() {
       return new CloseGuard(getMethod, openMethod, warnIfOpenMethod);
     }
   }
+
+  /**
+   * An index of trusted root certificates that exploits knowledge of Android implementation
+   * details. This class is potentially much faster to initialize than {@link BasicTrustRootIndex}
+   * because it doesn't need to load and index trusted CA certificates.
+   *
+   * <p>This class uses APIs added to Android in API 14 (Android 4.0, released October 2011). This
+   * class shouldn't be used in Android API 17 or better because those releases are better served by
+   * {@link AndroidPlatform.AndroidCertificateChainCleaner}.
+   */
+  static final class AndroidTrustRootIndex implements TrustRootIndex {
+    private final X509TrustManager trustManager;
+    private final Method findByIssuerAndSignatureMethod;
+
+    AndroidTrustRootIndex(X509TrustManager trustManager, Method findByIssuerAndSignatureMethod) {
+      this.findByIssuerAndSignatureMethod = findByIssuerAndSignatureMethod;
+      this.trustManager = trustManager;
+    }
+
+    @Override public X509Certificate findByIssuerAndSignature(X509Certificate cert) {
+      try {
+        TrustAnchor trustAnchor = (TrustAnchor) findByIssuerAndSignatureMethod.invoke(
+                trustManager, cert);
+        return trustAnchor != null
+                ? trustAnchor.getTrustedCert()
+                : null;
+      } catch (IllegalAccessException e) {
+        throw new AssertionError();
+      } catch (InvocationTargetException e) {
+        return null;
+      }
+    }
+
+    @Override
+    public boolean equals(Object obj) {
+      if (obj == this) {
+        return true;
+      }
+      if (!(obj instanceof AndroidTrustRootIndex)) {
+        return false;
+      }
+      AndroidTrustRootIndex that = (AndroidTrustRootIndex) obj;
+      return trustManager.equals(that.trustManager)
+              && findByIssuerAndSignatureMethod.equals(that.findByIssuerAndSignatureMethod);
+    }
+
+    @Override
+    public int hashCode() {
+      return trustManager.hashCode() + 31 * findByIssuerAndSignatureMethod.hashCode();
+    }
+  }
 }
diff --git a/okhttp/src/main/java/okhttp3/internal/platform/Jdk9Platform.java b/okhttp/src/main/java/okhttp3/internal/platform/Jdk9Platform.java
index 683e5c1cd4..19f444dd55 100644
--- a/okhttp/src/main/java/okhttp3/internal/platform/Jdk9Platform.java
+++ b/okhttp/src/main/java/okhttp3/internal/platform/Jdk9Platform.java
@@ -31,7 +31,7 @@
   final Method setProtocolMethod;
   final Method getProtocolMethod;
 
-  public Jdk9Platform(Method setProtocolMethod, Method getProtocolMethod) {
+  Jdk9Platform(Method setProtocolMethod, Method getProtocolMethod) {
     this.setProtocolMethod = setProtocolMethod;
     this.getProtocolMethod = getProtocolMethod;
   }
diff --git a/okhttp/src/main/java/okhttp3/internal/platform/JdkWithJettyBootPlatform.java b/okhttp/src/main/java/okhttp3/internal/platform/JdkWithJettyBootPlatform.java
index 3d092b5cc2..5dd11ee362 100644
--- a/okhttp/src/main/java/okhttp3/internal/platform/JdkWithJettyBootPlatform.java
+++ b/okhttp/src/main/java/okhttp3/internal/platform/JdkWithJettyBootPlatform.java
@@ -34,7 +34,7 @@
   private final Class<?> clientProviderClass;
   private final Class<?> serverProviderClass;
 
-  public JdkWithJettyBootPlatform(Method putMethod, Method getMethod, Method removeMethod,
+  JdkWithJettyBootPlatform(Method putMethod, Method getMethod, Method removeMethod,
       Class<?> clientProviderClass, Class<?> serverProviderClass) {
     this.putMethod = putMethod;
     this.getMethod = getMethod;
@@ -106,11 +106,11 @@ public static Platform buildIfSupported() {
     /** This peer's supported protocols. */
     private final List<String> protocols;
     /** Set when remote peer notifies ALPN is unsupported. */
-    private boolean unsupported;
+    boolean unsupported;
     /** The protocol the server selected. */
-    private String selected;
+    String selected;
 
-    public JettyNegoProvider(List<String> protocols) {
+    JettyNegoProvider(List<String> protocols) {
       this.protocols = protocols;
     }
 
diff --git a/okhttp/src/main/java/okhttp3/internal/platform/OptionalMethod.java b/okhttp/src/main/java/okhttp3/internal/platform/OptionalMethod.java
index b7b1717b0e..c26132fedb 100644
--- a/okhttp/src/main/java/okhttp3/internal/platform/OptionalMethod.java
+++ b/okhttp/src/main/java/okhttp3/internal/platform/OptionalMethod.java
@@ -42,7 +42,7 @@
    * @param methodName the name of the method
    * @param methodParams the method parameter types
    */
-  public OptionalMethod(Class<?> returnType, String methodName, Class... methodParams) {
+  OptionalMethod(Class<?> returnType, String methodName, Class... methodParams) {
     this.returnType = returnType;
     this.methodName = methodName;
     this.methodParams = methodParams;
diff --git a/okhttp/src/main/java/okhttp3/internal/platform/Platform.java b/okhttp/src/main/java/okhttp3/internal/platform/Platform.java
index 83c36fdd0f..7ff1c717c3 100644
--- a/okhttp/src/main/java/okhttp3/internal/platform/Platform.java
+++ b/okhttp/src/main/java/okhttp3/internal/platform/Platform.java
@@ -30,6 +30,7 @@
 import okhttp3.OkHttpClient;
 import okhttp3.Protocol;
 import okhttp3.internal.tls.BasicCertificateChainCleaner;
+import okhttp3.internal.tls.BasicTrustRootIndex;
 import okhttp3.internal.tls.CertificateChainCleaner;
 import okhttp3.internal.tls.TrustRootIndex;
 import okio.Buffer;
@@ -164,7 +165,7 @@ public void logCloseableLeak(String message, Object stackTrace) {
   }
 
   public CertificateChainCleaner buildCertificateChainCleaner(X509TrustManager trustManager) {
-    return new BasicCertificateChainCleaner(TrustRootIndex.get(trustManager));
+    return new BasicCertificateChainCleaner(buildTrustRootIndex(trustManager));
   }
 
   /** Attempt to match the host runtime to a capable Platform implementation. */
@@ -228,4 +229,8 @@ private static Platform findPlatform() {
 
     return null;
   }
+
+    public TrustRootIndex buildTrustRootIndex(X509TrustManager trustManager) {
+      return new BasicTrustRootIndex(trustManager.getAcceptedIssuers());
+    }
 }
diff --git a/okhttp/src/main/java/okhttp3/internal/publicsuffix/PublicSuffixDatabase.java b/okhttp/src/main/java/okhttp3/internal/publicsuffix/PublicSuffixDatabase.java
new file mode 100644
index 0000000000..75dafdd0a3
--- /dev/null
+++ b/okhttp/src/main/java/okhttp3/internal/publicsuffix/PublicSuffixDatabase.java
@@ -0,0 +1,340 @@
+/*
+ * Copyright (C) 2017 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.internal.publicsuffix;
+
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.InterruptedIOException;
+import java.net.IDN;
+import java.util.concurrent.CountDownLatch;
+import java.util.concurrent.atomic.AtomicBoolean;
+import okhttp3.internal.Util;
+import okhttp3.internal.platform.Platform;
+import okio.BufferedSource;
+import okio.GzipSource;
+import okio.Okio;
+
+import static okhttp3.internal.Util.closeQuietly;
+
+/**
+ * A database of public suffixes provided by
+ * <a href="https://publicsuffix.org/">publicsuffix.org</a>.
+ */
+public final class PublicSuffixDatabase {
+  public static final String PUBLIC_SUFFIX_RESOURCE = "publicsuffixes.gz";
+
+  private static final byte[] WILDCARD_LABEL = new byte[]{'*'};
+  private static final String[] EMPTY_RULE = new String[0];
+  private static final String[] PREVAILING_RULE = new String[]{"*"};
+
+  private static final byte EXCEPTION_MARKER = '!';
+
+  private static final PublicSuffixDatabase instance = new PublicSuffixDatabase();
+
+  /** True after we've attempted to read the list for the first time. */
+  private final AtomicBoolean listRead = new AtomicBoolean(false);
+
+  /** Used for concurrent threads reading the list for the first time. */
+  private final CountDownLatch readCompleteLatch = new CountDownLatch(1);
+
+  // The lists are held as a large array of UTF-8 bytes. This is to avoid allocating lots of strings
+  // that will likely never be used. Each rule is separated by '\n'. Please see the
+  // PublicSuffixListGenerator class for how these lists are generated.
+  // Guarded by this.
+  private byte[] publicSuffixListBytes;
+  private byte[] publicSuffixExceptionListBytes;
+
+  public static PublicSuffixDatabase get() {
+    return instance;
+  }
+
+  /**
+   * Returns the effective top-level domain plus one (eTLD+1) by referencing the public suffix list.
+   * Returns null if the domain is a public suffix.
+   *
+   * <p>Here are some examples: <pre>{@code
+   * assertEquals("google.com", getEffectiveTldPlusOne("google.com"));
+   * assertEquals("google.com", getEffectiveTldPlusOne("www.google.com"));
+   * assertNull(getEffectiveTldPlusOne("com"));
+   * }</pre>
+   *
+   * @param domain A canonicalized domain. An International Domain Name (IDN) should be punycode
+   *    encoded.
+   */
+  public String getEffectiveTldPlusOne(String domain) {
+    if (domain == null) throw new NullPointerException("domain == null");
+
+    // We use UTF-8 in the list so we need to convert to Unicode.
+    String unicodeDomain = IDN.toUnicode(domain);
+    String[] domainLabels = unicodeDomain.split("\\.");
+    String[] rule = findMatchingRule(domainLabels);
+    if (domainLabels.length == rule.length && rule[0].charAt(0) != EXCEPTION_MARKER) {
+      // The domain is a public suffix.
+      return null;
+    }
+
+    int firstLabelOffset;
+    if (rule[0].charAt(0) == EXCEPTION_MARKER) {
+      // Exception rules hold the effective TLD plus one.
+      firstLabelOffset = domainLabels.length - rule.length;
+    } else {
+      // Otherwise the rule is for a public suffix, so we must take one more label.
+      firstLabelOffset = domainLabels.length - (rule.length + 1);
+    }
+
+    StringBuilder effectiveTldPlusOne = new StringBuilder();
+    String[] punycodeLabels = domain.split("\\.");
+    for (int i = firstLabelOffset; i < punycodeLabels.length; i++) {
+      effectiveTldPlusOne.append(punycodeLabels[i]).append('.');
+    }
+    effectiveTldPlusOne.deleteCharAt(effectiveTldPlusOne.length() - 1);
+
+    return effectiveTldPlusOne.toString();
+  }
+
+  private String[] findMatchingRule(String[] domainLabels) {
+    if (!listRead.get() && listRead.compareAndSet(false, true)) {
+      readTheListUninterruptibly();
+    } else {
+      try {
+        readCompleteLatch.await();
+      } catch (InterruptedException ignored) {
+      }
+    }
+
+    synchronized (this) {
+      if (publicSuffixListBytes == null) {
+        throw new IllegalStateException("Unable to load " + PUBLIC_SUFFIX_RESOURCE + " resource "
+            + "from the classpath.");
+      }
+    }
+
+    // Break apart the domain into UTF-8 labels, i.e. foo.bar.com turns into [foo, bar, com].
+    byte[][] domainLabelsUtf8Bytes = new byte[domainLabels.length][];
+    for (int i = 0; i < domainLabels.length; i++) {
+      domainLabelsUtf8Bytes[i] = domainLabels[i].getBytes(Util.UTF_8);
+    }
+
+    // Start by looking for exact matches. We start at the leftmost label. For example, foo.bar.com
+    // will look like: [foo, bar, com], [bar, com], [com]. The longest matching rule wins.
+    String exactMatch = null;
+    for (int i = 0; i < domainLabelsUtf8Bytes.length; i++) {
+      String rule = binarySearchBytes(publicSuffixListBytes, domainLabelsUtf8Bytes, i);
+      if (rule != null) {
+        exactMatch = rule;
+        break;
+      }
+    }
+
+    // In theory, wildcard rules are not restricted to having the wildcard in the leftmost position.
+    // In practice, wildcards are always in the leftmost position. For now, this implementation
+    // cheats and does not attempt every possible permutation. Instead, it only considers wildcards
+    // in the leftmost position. We assert this fact when we generate the public suffix file. If
+    // this assertion ever fails we'll need to refactor this implementation.
+    String wildcardMatch = null;
+    if (domainLabelsUtf8Bytes.length > 1) {
+      byte[][] labelsWithWildcard = domainLabelsUtf8Bytes.clone();
+      for (int labelIndex = 0; labelIndex < labelsWithWildcard.length - 1; labelIndex++) {
+        labelsWithWildcard[labelIndex] = WILDCARD_LABEL;
+        String rule = binarySearchBytes(publicSuffixListBytes, labelsWithWildcard, labelIndex);
+        if (rule != null) {
+          wildcardMatch = rule;
+          break;
+        }
+      }
+    }
+
+    // Exception rules only apply to wildcard rules, so only try it if we matched a wildcard.
+    String exception = null;
+    if (wildcardMatch != null) {
+      for (int labelIndex = 0; labelIndex < domainLabelsUtf8Bytes.length - 1; labelIndex++) {
+        String rule = binarySearchBytes(
+            publicSuffixExceptionListBytes, domainLabelsUtf8Bytes, labelIndex);
+        if (rule != null) {
+          exception = rule;
+          break;
+        }
+      }
+    }
+
+    if (exception != null) {
+      // Signal we've identified an exception rule.
+      exception = "!" + exception;
+      return exception.split("\\.");
+    } else if (exactMatch == null && wildcardMatch == null) {
+      return PREVAILING_RULE;
+    }
+
+    String[] exactRuleLabels = exactMatch != null
+        ? exactMatch.split("\\.")
+        : EMPTY_RULE;
+
+    String[] wildcardRuleLabels = wildcardMatch != null
+        ? wildcardMatch.split("\\.")
+        : EMPTY_RULE;
+
+    return exactRuleLabels.length > wildcardRuleLabels.length
+        ? exactRuleLabels
+        : wildcardRuleLabels;
+  }
+
+  private static String binarySearchBytes(byte[] bytesToSearch, byte[][] labels, int labelIndex) {
+    int low = 0;
+    int high = bytesToSearch.length;
+    String match = null;
+    while (low < high) {
+      int mid = (low + high) / 2;
+      // Search for a '\n' that marks the start of a value. Don't go back past the start of the
+      // array.
+      while (mid > -1 && bytesToSearch[mid] != '\n') {
+        mid--;
+      }
+      mid++;
+
+      // Now look for the ending '\n'.
+      int end = 1;
+      while (bytesToSearch[mid + end] != '\n') {
+        end++;
+      }
+      int publicSuffixLength = (mid + end) - mid;
+
+      // Compare the bytes. Note that the file stores UTF-8 encoded bytes, so we must compare the
+      // unsigned bytes.
+      int compareResult;
+      int currentLabelIndex = labelIndex;
+      int currentLabelByteIndex = 0;
+      int publicSuffixByteIndex = 0;
+
+      boolean expectDot = false;
+      while (true) {
+        int byte0;
+        if (expectDot) {
+          byte0 = '.';
+          expectDot = false;
+        } else {
+          byte0 = labels[currentLabelIndex][currentLabelByteIndex] & 0xff;
+        }
+
+        int byte1 = bytesToSearch[mid + publicSuffixByteIndex] & 0xff;
+
+        compareResult = byte0 - byte1;
+        if (compareResult != 0) break;
+
+        publicSuffixByteIndex++;
+        currentLabelByteIndex++;
+        if (publicSuffixByteIndex == publicSuffixLength) break;
+
+        if (labels[currentLabelIndex].length == currentLabelByteIndex) {
+          // We've exhausted our current label. Either there are more labels to compare, in which
+          // case we expect a dot as the next character. Otherwise, we've checked all our labels.
+          if (currentLabelIndex == labels.length - 1) {
+            break;
+          } else {
+            currentLabelIndex++;
+            currentLabelByteIndex = -1;
+            expectDot = true;
+          }
+        }
+      }
+
+      if (compareResult < 0) {
+        high = mid - 1;
+      } else if (compareResult > 0) {
+        low = mid + end + 1;
+      } else {
+        // We found a match, but are the lengths equal?
+        int publicSuffixBytesLeft = publicSuffixLength - publicSuffixByteIndex;
+        int labelBytesLeft = labels[currentLabelIndex].length - currentLabelByteIndex;
+        for (int i = currentLabelIndex + 1; i < labels.length; i++) {
+          labelBytesLeft += labels[i].length;
+        }
+
+        if (labelBytesLeft < publicSuffixBytesLeft) {
+          high = mid - 1;
+        } else if (labelBytesLeft > publicSuffixBytesLeft) {
+          low = mid + end + 1;
+        } else {
+          // Found a match.
+          match = new String(bytesToSearch, mid, publicSuffixLength, Util.UTF_8);
+          break;
+        }
+      }
+    }
+    return match;
+  }
+
+  /**
+   * Reads the public suffix list treating the operation as uninterruptible. We always want to read
+   * the list otherwise we'll be left in a bad state. If the thread was interrupted prior to this
+   * operation, it will be re-interrupted after the list is read.
+   */
+  private void readTheListUninterruptibly() {
+    boolean interrupted = false;
+    try {
+      while (true) {
+        try {
+          readTheList();
+          return;
+        } catch (InterruptedIOException e) {
+          interrupted = true;
+        } catch (IOException e) {
+          Platform.get().log(Platform.WARN, "Failed to read public suffix list", e);
+          return;
+        }
+      }
+    } finally {
+      if (interrupted) {
+        Thread.currentThread().interrupt();
+      }
+    }
+  }
+
+  private void readTheList() throws IOException {
+    byte[] publicSuffixListBytes;
+    byte[] publicSuffixExceptionListBytes;
+
+    InputStream resource = PublicSuffixDatabase.class.getResourceAsStream(PUBLIC_SUFFIX_RESOURCE);
+    if (resource == null) return;
+
+    BufferedSource bufferedSource = Okio.buffer(new GzipSource(Okio.source(resource)));
+    try {
+      int totalBytes = bufferedSource.readInt();
+      publicSuffixListBytes = new byte[totalBytes];
+      bufferedSource.readFully(publicSuffixListBytes);
+
+      int totalExceptionBytes = bufferedSource.readInt();
+      publicSuffixExceptionListBytes = new byte[totalExceptionBytes];
+      bufferedSource.readFully(publicSuffixExceptionListBytes);
+    } finally {
+      closeQuietly(bufferedSource);
+    }
+
+    synchronized (this) {
+      this.publicSuffixListBytes = publicSuffixListBytes;
+      this.publicSuffixExceptionListBytes = publicSuffixExceptionListBytes;
+    }
+
+    readCompleteLatch.countDown();
+  }
+
+  /** Visible for testing. */
+  void setListBytes(byte[] publicSuffixListBytes, byte[] publicSuffixExceptionListBytes) {
+    this.publicSuffixListBytes = publicSuffixListBytes;
+    this.publicSuffixExceptionListBytes = publicSuffixExceptionListBytes;
+    listRead.set(true);
+    readCompleteLatch.countDown();
+  }
+}
diff --git a/okhttp/src/main/java/okhttp3/internal/tls/BasicTrustRootIndex.java b/okhttp/src/main/java/okhttp3/internal/tls/BasicTrustRootIndex.java
new file mode 100644
index 0000000000..cfd8923668
--- /dev/null
+++ b/okhttp/src/main/java/okhttp3/internal/tls/BasicTrustRootIndex.java
@@ -0,0 +1,70 @@
+/*
+ * Copyright (C) 2016 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.internal.tls;
+
+import java.security.PublicKey;
+import java.security.cert.X509Certificate;
+import java.util.LinkedHashMap;
+import java.util.LinkedHashSet;
+import java.util.Map;
+import java.util.Set;
+import javax.security.auth.x500.X500Principal;
+
+/** A simple index that of trusted root certificates that have been loaded into memory. */
+public final class BasicTrustRootIndex implements TrustRootIndex {
+  private final Map<X500Principal, Set<X509Certificate>> subjectToCaCerts;
+
+  public BasicTrustRootIndex(X509Certificate... caCerts) {
+    subjectToCaCerts = new LinkedHashMap<>();
+    for (X509Certificate caCert : caCerts) {
+      X500Principal subject = caCert.getSubjectX500Principal();
+      Set<X509Certificate> subjectCaCerts = subjectToCaCerts.get(subject);
+      if (subjectCaCerts == null) {
+        subjectCaCerts = new LinkedHashSet<>(1);
+        subjectToCaCerts.put(subject, subjectCaCerts);
+      }
+      subjectCaCerts.add(caCert);
+    }
+  }
+
+  @Override public X509Certificate findByIssuerAndSignature(X509Certificate cert) {
+    X500Principal issuer = cert.getIssuerX500Principal();
+    Set<X509Certificate> subjectCaCerts = subjectToCaCerts.get(issuer);
+    if (subjectCaCerts == null) return null;
+
+    for (X509Certificate caCert : subjectCaCerts) {
+      PublicKey publicKey = caCert.getPublicKey();
+      try {
+        cert.verify(publicKey);
+        return caCert;
+      } catch (Exception ignored) {
+      }
+    }
+
+    return null;
+  }
+
+  @Override public boolean equals(Object other) {
+    if (other == this) return true;
+    return other instanceof okhttp3.internal.tls.BasicTrustRootIndex
+        && ((okhttp3.internal.tls.BasicTrustRootIndex) other).subjectToCaCerts.equals(
+        subjectToCaCerts);
+  }
+
+  @Override public int hashCode() {
+    return subjectToCaCerts.hashCode();
+  }
+}
diff --git a/okhttp/src/main/java/okhttp3/internal/tls/CertificateChainCleaner.java b/okhttp/src/main/java/okhttp3/internal/tls/CertificateChainCleaner.java
index 3e69f23061..98060db27a 100644
--- a/okhttp/src/main/java/okhttp3/internal/tls/CertificateChainCleaner.java
+++ b/okhttp/src/main/java/okhttp3/internal/tls/CertificateChainCleaner.java
@@ -42,6 +42,6 @@ public static CertificateChainCleaner get(X509TrustManager trustManager) {
   }
 
   public static CertificateChainCleaner get(X509Certificate... caCerts) {
-    return new BasicCertificateChainCleaner(TrustRootIndex.get(caCerts));
+    return new BasicCertificateChainCleaner(new BasicTrustRootIndex(caCerts));
   }
 }
diff --git a/okhttp/src/main/java/okhttp3/internal/tls/DistinguishedNameParser.java b/okhttp/src/main/java/okhttp3/internal/tls/DistinguishedNameParser.java
index 616bca534a..cae8dfae76 100644
--- a/okhttp/src/main/java/okhttp3/internal/tls/DistinguishedNameParser.java
+++ b/okhttp/src/main/java/okhttp3/internal/tls/DistinguishedNameParser.java
@@ -35,7 +35,7 @@
   /** Distinguished name characters. */
   private char[] chars;
 
-  public DistinguishedNameParser(X500Principal principal) {
+  DistinguishedNameParser(X500Principal principal) {
     // RFC2253 is used to ensure we get attributes in the reverse
     // order of the underlying ASN.1 encoding, so that the most
     // significant values of repeated attributes occur first.
diff --git a/okhttp/src/main/java/okhttp3/internal/tls/OkHostnameVerifier.java b/okhttp/src/main/java/okhttp3/internal/tls/OkHostnameVerifier.java
index a85df784d7..7441abadad 100644
--- a/okhttp/src/main/java/okhttp3/internal/tls/OkHostnameVerifier.java
+++ b/okhttp/src/main/java/okhttp3/internal/tls/OkHostnameVerifier.java
@@ -139,7 +139,7 @@ private boolean verifyHostname(String hostname, X509Certificate certificate) {
    * @param pattern domain name pattern from certificate. May be a wildcard pattern such as {@code
    * *.android.com}.
    */
-  private boolean verifyHostname(String hostname, String pattern) {
+  public boolean verifyHostname(String hostname, String pattern) {
     // Basic sanity checks
     // Check length == 0 instead of .isEmpty() to support Java 5.
     if ((hostname == null) || (hostname.length() == 0) || (hostname.startsWith("."))
diff --git a/okhttp/src/main/java/okhttp3/internal/tls/TrustRootIndex.java b/okhttp/src/main/java/okhttp3/internal/tls/TrustRootIndex.java
index e42ad1b0fc..499f120e33 100644
--- a/okhttp/src/main/java/okhttp3/internal/tls/TrustRootIndex.java
+++ b/okhttp/src/main/java/okhttp3/internal/tls/TrustRootIndex.java
@@ -15,132 +15,9 @@
  */
 package okhttp3.internal.tls;
 
-import java.lang.reflect.InvocationTargetException;
-import java.lang.reflect.Method;
-import java.security.PublicKey;
-import java.security.cert.TrustAnchor;
 import java.security.cert.X509Certificate;
-import java.util.LinkedHashMap;
-import java.util.LinkedHashSet;
-import java.util.Map;
-import java.util.Set;
-import javax.net.ssl.X509TrustManager;
-import javax.security.auth.x500.X500Principal;
 
-public abstract class TrustRootIndex {
+public interface TrustRootIndex {
   /** Returns the trusted CA certificate that signed {@code cert}. */
-  public abstract X509Certificate findByIssuerAndSignature(X509Certificate cert);
-
-  public static TrustRootIndex get(X509TrustManager trustManager) {
-    try {
-      // From org.conscrypt.TrustManagerImpl, we want the method with this signature:
-      // private TrustAnchor findTrustAnchorByIssuerAndSignature(X509Certificate lastCert);
-      Method method = trustManager.getClass().getDeclaredMethod(
-          "findTrustAnchorByIssuerAndSignature", X509Certificate.class);
-      method.setAccessible(true);
-      return new AndroidTrustRootIndex(trustManager, method);
-    } catch (NoSuchMethodException e) {
-      return get(trustManager.getAcceptedIssuers());
-    }
-  }
-
-  public static TrustRootIndex get(X509Certificate... caCerts) {
-    return new BasicTrustRootIndex(caCerts);
-  }
-
-  /**
-   * An index of trusted root certificates that exploits knowledge of Android implementation
-   * details. This class is potentially much faster to initialize than {@link BasicTrustRootIndex}
-   * because it doesn't need to load and index trusted CA certificates.
-   *
-   * <p>This class uses APIs added to Android in API 14 (Android 4.0, released October 2011). This
-   * class shouldn't be used in Android API 17 or better because those releases are better served by
-   * {@link okhttp3.internal.AndroidPlatform.AndroidCertificateChainCleaner}.
-   */
-  static final class AndroidTrustRootIndex extends TrustRootIndex {
-    private final X509TrustManager trustManager;
-    private final Method findByIssuerAndSignatureMethod;
-
-    AndroidTrustRootIndex(X509TrustManager trustManager, Method findByIssuerAndSignatureMethod) {
-      this.findByIssuerAndSignatureMethod = findByIssuerAndSignatureMethod;
-      this.trustManager = trustManager;
-    }
-
-    @Override public X509Certificate findByIssuerAndSignature(X509Certificate cert) {
-      try {
-        TrustAnchor trustAnchor = (TrustAnchor) findByIssuerAndSignatureMethod.invoke(
-            trustManager, cert);
-        return trustAnchor != null
-            ? trustAnchor.getTrustedCert()
-            : null;
-      } catch (IllegalAccessException e) {
-        throw new AssertionError();
-      } catch (InvocationTargetException e) {
-        return null;
-      }
-    }
-
-    @Override
-    public boolean equals(Object obj) {
-      if (obj == this) {
-        return true;
-      }
-      if (!(obj instanceof AndroidTrustRootIndex)) {
-        return false;
-      }
-      AndroidTrustRootIndex that = (AndroidTrustRootIndex) obj;
-      return trustManager.equals(that.trustManager)
-              && findByIssuerAndSignatureMethod.equals(that.findByIssuerAndSignatureMethod);
-    }
-
-    @Override
-    public int hashCode() {
-      return trustManager.hashCode() + 31 * findByIssuerAndSignatureMethod.hashCode();
-    }
-  }
-
-  /** A simple index that of trusted root certificates that have been loaded into memory. */
-  static final class BasicTrustRootIndex extends TrustRootIndex {
-    private final Map<X500Principal, Set<X509Certificate>> subjectToCaCerts;
-
-    public BasicTrustRootIndex(X509Certificate... caCerts) {
-      subjectToCaCerts = new LinkedHashMap<>();
-      for (X509Certificate caCert : caCerts) {
-        X500Principal subject = caCert.getSubjectX500Principal();
-        Set<X509Certificate> subjectCaCerts = subjectToCaCerts.get(subject);
-        if (subjectCaCerts == null) {
-          subjectCaCerts = new LinkedHashSet<>(1);
-          subjectToCaCerts.put(subject, subjectCaCerts);
-        }
-        subjectCaCerts.add(caCert);
-      }
-    }
-
-    @Override public X509Certificate findByIssuerAndSignature(X509Certificate cert) {
-      X500Principal issuer = cert.getIssuerX500Principal();
-      Set<X509Certificate> subjectCaCerts = subjectToCaCerts.get(issuer);
-      if (subjectCaCerts == null) return null;
-
-      for (X509Certificate caCert : subjectCaCerts) {
-        PublicKey publicKey = caCert.getPublicKey();
-        try {
-          cert.verify(publicKey);
-          return caCert;
-        } catch (Exception ignored) {
-        }
-      }
-
-      return null;
-    }
-
-    @Override public boolean equals(Object other) {
-      if (other == this) return true;
-      return other instanceof BasicTrustRootIndex
-          && ((BasicTrustRootIndex) other).subjectToCaCerts.equals(subjectToCaCerts);
-    }
-
-    @Override public int hashCode() {
-      return subjectToCaCerts.hashCode();
-    }
-  }
+  X509Certificate findByIssuerAndSignature(X509Certificate cert);
 }
diff --git a/okhttp/src/main/java/okhttp3/internal/ws/RealWebSocket.java b/okhttp/src/main/java/okhttp3/internal/ws/RealWebSocket.java
index 861047568a..5e01f40413 100644
--- a/okhttp/src/main/java/okhttp3/internal/ws/RealWebSocket.java
+++ b/okhttp/src/main/java/okhttp3/internal/ws/RealWebSocket.java
@@ -22,9 +22,10 @@
 import java.util.Collections;
 import java.util.List;
 import java.util.Random;
-import java.util.concurrent.ExecutorService;
-import java.util.concurrent.SynchronousQueue;
-import java.util.concurrent.ThreadPoolExecutor;
+import java.util.concurrent.ScheduledExecutorService;
+import java.util.concurrent.ScheduledFuture;
+import java.util.concurrent.ScheduledThreadPoolExecutor;
+import java.util.concurrent.TimeUnit;
 import okhttp3.Call;
 import okhttp3.Callback;
 import okhttp3.OkHttpClient;
@@ -34,7 +35,6 @@
 import okhttp3.WebSocket;
 import okhttp3.WebSocketListener;
 import okhttp3.internal.Internal;
-import okhttp3.internal.NamedRunnable;
 import okhttp3.internal.Util;
 import okhttp3.internal.connection.StreamAllocation;
 import okio.BufferedSink;
@@ -42,9 +42,10 @@
 import okio.ByteString;
 import okio.Okio;
 
-import static java.util.concurrent.TimeUnit.SECONDS;
+import static java.util.concurrent.TimeUnit.MILLISECONDS;
 import static okhttp3.internal.Util.closeQuietly;
 import static okhttp3.internal.ws.WebSocketProtocol.CLOSE_CLIENT_GOING_AWAY;
+import static okhttp3.internal.ws.WebSocketProtocol.CLOSE_MESSAGE_MAX;
 import static okhttp3.internal.ws.WebSocketProtocol.OPCODE_BINARY;
 import static okhttp3.internal.ws.WebSocketProtocol.OPCODE_TEXT;
 import static okhttp3.internal.ws.WebSocketProtocol.validateCloseCode;
@@ -58,38 +59,36 @@
    */
   private static final long MAX_QUEUE_SIZE = 16 * 1024 * 1024; // 16 MiB.
 
-  /** A shared executor for all web sockets. */
-  private static final ExecutorService executor = new ThreadPoolExecutor(0,
-      Integer.MAX_VALUE, 60, SECONDS, new SynchronousQueue<Runnable>(),
-      Util.threadFactory("OkHttp WebSocket", true));
+  /**
+   * The maximum amount of time after the client calls {@link #close} to wait for a graceful
+   * shutdown. If the server doesn't respond the websocket will be canceled.
+   */
+  private static final long CANCEL_AFTER_CLOSE_MILLIS = 60 * 1000;
 
   /** The application's original request unadulterated by web socket headers. */
   private final Request originalRequest;
 
-  private final WebSocketListener listener;
+  final WebSocketListener listener;
   private final Random random;
   private final String key;
 
-  /** Non-null for client websockets. These can be canceled. */
+  /** Non-null for client web sockets. These can be canceled. */
   private Call call;
 
   /** This runnable processes the outgoing queues. Call {@link #runWriter()} to after enqueueing. */
-  private final NamedRunnable writerRunnable;
+  private final Runnable writerRunnable;
 
   /** Null until this web socket is connected. Only accessed by the reader thread. */
   private WebSocketReader reader;
 
   // All mutable web socket state is guarded by this.
 
-  /**
-   * True if {@link #writerRunnable} is active. Because writing is single-threaded we only enqueue
-   * it if it isn't already enqueued.
-   */
-  private boolean writerRunning;
-
   /** Null until this web socket is connected. Note that messages may be enqueued before that. */
   private WebSocketWriter writer;
 
+  /** Null until this web socket is connected. Used for writes, pings, and close timeouts. */
+  private ScheduledExecutorService executor;
+
   /**
    * The streams held by this web socket. This is non-null until all incoming messages have been
    * read and all outgoing messages have been written. It is closed when both reader and writer are
@@ -109,6 +108,12 @@
   /** True if we've enqueued a close frame. No further message frames will be enqueued. */
   private boolean enqueuedClose;
 
+  /**
+   * When executed this will cancel this websocket. This future itself should be canceled if that is
+   * unnecessary because the web socket is already closed or canceled.
+   */
+  private ScheduledFuture<?> cancelFuture;
+
   /** The close code from the peer, or -1 if this web socket has not yet read a close frame. */
   private int receivedCloseCode = -1;
 
@@ -118,6 +123,12 @@
   /** True if this web socket failed and the listener has been notified. */
   private boolean failed;
 
+  /** For testing. */
+  int pingCount;
+
+  /** For testing. */
+  int pongCount;
+
   public RealWebSocket(Request request, WebSocketListener listener, Random random) {
     if (!"GET".equals(request.method())) {
       throw new IllegalArgumentException("Request must be GET: " + request.method());
@@ -130,8 +141,8 @@ public RealWebSocket(Request request, WebSocketListener listener, Random random)
     random.nextBytes(nonce);
     this.key = ByteString.of(nonce).base64();
 
-    this.writerRunnable = new NamedRunnable("OkHttp WebSocket %s", request.url().redact()) {
-      @Override protected void execute() {
+    this.writerRunnable = new Runnable() {
+      @Override public void run() {
         try {
           while (writeOneFrame()) {
           }
@@ -158,7 +169,8 @@ public void connect(OkHttpClient client) {
     client = client.newBuilder()
         .protocols(ONLY_HTTP1)
         .build();
-    Request request = originalRequest.newBuilder()
+    final int pingIntervalMillis = client.pingIntervalMillis();
+    final Request request = originalRequest.newBuilder()
         .header("Upgrade", "websocket")
         .header("Connection", "Upgrade")
         .header("Sec-WebSocket-Key", key)
@@ -178,12 +190,13 @@ public void connect(OkHttpClient client) {
         // Promote the HTTP streams into web socket streams.
         StreamAllocation streamAllocation = Internal.instance.streamAllocation(call);
         streamAllocation.noNewStreams(); // Prevent connection pooling!
-        Streams streams = new ClientStreams(streamAllocation);
+        Streams streams = streamAllocation.connection().newWebSocketStreams(streamAllocation);
 
-        // Process all websocket messages.
+        // Process all web socket messages.
         try {
           listener.onOpen(RealWebSocket.this, response);
-          initReaderAndWriter(streams);
+          String name = "OkHttp WebSocket " + request.url().redact();
+          initReaderAndWriter(name, pingIntervalMillis, streams);
           streamAllocation.connection().socket().setSoTimeout(0);
           loopReader();
         } catch (Exception e) {
@@ -197,7 +210,7 @@ public void connect(OkHttpClient client) {
     });
   }
 
-  private void checkResponse(Response response) throws ProtocolException {
+  void checkResponse(Response response) throws ProtocolException {
     if (response.code() != 101) {
       throw new ProtocolException("Expected HTTP 101 response but was '"
           + response.code() + " " + response.message() + "'");
@@ -224,10 +237,16 @@ private void checkResponse(Response response) throws ProtocolException {
     }
   }
 
-  public void initReaderAndWriter(Streams streams) throws IOException {
+  public void initReaderAndWriter(
+      String name, long pingIntervalMillis, Streams streams) throws IOException {
     synchronized (this) {
       this.streams = streams;
       this.writer = new WebSocketWriter(streams.client, streams.sink, random);
+      this.executor = new ScheduledThreadPoolExecutor(1, Util.threadFactory(name, false));
+      if (pingIntervalMillis != 0) {
+        executor.scheduleAtFixedRate(
+            new PingRunnable(), pingIntervalMillis, pingIntervalMillis, MILLISECONDS);
+      }
       if (!messageAndCloseQueue.isEmpty()) {
         runWriter(); // Send messages that were enqueued before we were connected.
       }
@@ -258,6 +277,32 @@ boolean processNextFrame() throws IOException {
     }
   }
 
+  /**
+   * For testing: wait until the web socket's executor has terminated.
+   */
+  void awaitTermination(int timeout, TimeUnit timeUnit) throws InterruptedException {
+    executor.awaitTermination(timeout, timeUnit);
+  }
+
+  /**
+   * For testing: force this web socket to release its threads.
+   */
+  void tearDown() throws InterruptedException {
+    if (cancelFuture != null) {
+      cancelFuture.cancel(false);
+    }
+    executor.shutdown();
+    executor.awaitTermination(10, TimeUnit.SECONDS);
+  }
+
+  synchronized int pingCount() {
+    return pingCount;
+  }
+
+  synchronized int pongCount() {
+    return pongCount;
+  }
+
   @Override public void onReadMessage(String text) throws IOException {
     listener.onMessage(this, text);
   }
@@ -266,16 +311,18 @@ boolean processNextFrame() throws IOException {
     listener.onMessage(this, bytes);
   }
 
-  @Override public synchronized void onReadPing(final ByteString payload) {
+  @Override public synchronized void onReadPing(ByteString payload) {
     // Don't respond to pings after we've failed or sent the close frame.
     if (failed || (enqueuedClose && messageAndCloseQueue.isEmpty())) return;
 
     pongQueue.add(payload);
     runWriter();
+    pingCount++;
   }
 
-  @Override public void onReadPong(ByteString buffer) {
+  @Override public synchronized void onReadPong(ByteString buffer) {
     // This API doesn't expose pings.
+    pongCount++;
   }
 
   @Override public void onReadClose(int code, String reason) {
@@ -289,6 +336,8 @@ boolean processNextFrame() throws IOException {
       if (enqueuedClose && messageAndCloseQueue.isEmpty()) {
         toClose = this.streams;
         this.streams = null;
+        if (cancelFuture != null) cancelFuture.cancel(false);
+        this.executor.shutdown();
       }
     }
 
@@ -332,7 +381,7 @@ private synchronized boolean send(ByteString data, int formatOpcode) {
     return true;
   }
 
-  public synchronized boolean pong(ByteString payload) {
+  synchronized boolean pong(ByteString payload) {
     // Don't send pongs after we've failed or sent the close frame.
     if (failed || (enqueuedClose && messageAndCloseQueue.isEmpty())) return false;
 
@@ -341,9 +390,20 @@ public synchronized boolean pong(ByteString payload) {
     return true;
   }
 
-  @Override public synchronized boolean close(final int code, final String reason) {
+  @Override public boolean close(int code, String reason) {
+    return close(code, reason, CANCEL_AFTER_CLOSE_MILLIS);
+  }
+
+  synchronized boolean close(int code, String reason, long cancelAfterCloseMillis) {
     validateCloseCode(code);
-    // TODO(jwilson): confirm reason is well-formed. (<=123 bytes, etc.)
+
+    ByteString reasonBytes = null;
+    if (reason != null) {
+      reasonBytes = ByteString.encodeUtf8(reason);
+      if (reasonBytes.size() > CLOSE_MESSAGE_MAX) {
+        throw new IllegalArgumentException("reason.size() > " + CLOSE_MESSAGE_MAX + ": " + reason);
+      }
+    }
 
     if (failed || enqueuedClose) return false;
 
@@ -351,7 +411,7 @@ public synchronized boolean pong(ByteString payload) {
     enqueuedClose = true;
 
     // Enqueue the close frame.
-    messageAndCloseQueue.add(new Close(code, reason));
+    messageAndCloseQueue.add(new Close(code, reasonBytes, cancelAfterCloseMillis));
     runWriter();
     return true;
   }
@@ -359,8 +419,7 @@ public synchronized boolean pong(ByteString payload) {
   private void runWriter() {
     assert (Thread.holdsLock(this));
 
-    if (!writerRunning) {
-      writerRunning = true;
+    if (executor != null) {
       executor.execute(writerRunnable);
     }
   }
@@ -378,7 +437,7 @@ private void runWriter() {
    * <p>This method may only be invoked by the writer thread. There may be only thread invoking this
    * method at a time.
    */
-  private boolean writeOneFrame() throws IOException {
+  boolean writeOneFrame() throws IOException {
     WebSocketWriter writer;
     ByteString pong;
     Object messageOrClose = null;
@@ -388,16 +447,10 @@ private boolean writeOneFrame() throws IOException {
 
     synchronized (RealWebSocket.this) {
       if (failed) {
-        writerRunning = false;
         return false; // Failed web socket.
       }
 
       writer = this.writer;
-      if (writer == null) {
-        writerRunning = false;
-        return false; // Not yet connected.
-      }
-
       pong = pongQueue.poll();
       if (pong == null) {
         messageOrClose = messageAndCloseQueue.poll();
@@ -407,10 +460,13 @@ private boolean writeOneFrame() throws IOException {
           if (receivedCloseCode != -1) {
             streamsToClose = this.streams;
             this.streams = null;
+            this.executor.shutdown();
+          } else {
+            // When we request a graceful close also schedule a cancel of the websocket.
+            cancelFuture = executor.schedule(new CancelRunnable(),
+                ((Close) messageOrClose).cancelAfterCloseMillis, MILLISECONDS);
           }
-
         } else if (messageOrClose == null) {
-          writerRunning = false;
           return false; // The queue is exhausted.
         }
       }
@@ -449,13 +505,38 @@ private boolean writeOneFrame() throws IOException {
     }
   }
 
-  private void failWebSocket(Exception e, Response response) {
+  private final class PingRunnable implements Runnable {
+    PingRunnable() {
+    }
+
+    @Override public void run() {
+      writePingFrame();
+    }
+  }
+
+  void writePingFrame() {
+    WebSocketWriter writer;
+    synchronized (this) {
+      if (failed) return;
+      writer = this.writer;
+    }
+
+    try {
+      writer.writePing(ByteString.EMPTY);
+    } catch (IOException e) {
+      failWebSocket(e, null);
+    }
+  }
+
+  public void failWebSocket(Exception e, Response response) {
     Streams streamsToClose;
     synchronized (this) {
       if (failed) return; // Already failed.
       failed = true;
       streamsToClose = this.streams;
       this.streams = null;
+      if (cancelFuture != null) cancelFuture.cancel(false);
+      if (executor != null) executor.shutdown();
     }
 
     try {
@@ -469,7 +550,7 @@ private void failWebSocket(Exception e, Response response) {
     final int formatOpcode;
     final ByteString data;
 
-    public Message(int formatOpcode, ByteString data) {
+    Message(int formatOpcode, ByteString data) {
       this.formatOpcode = formatOpcode;
       this.data = data;
     }
@@ -477,18 +558,20 @@ public Message(int formatOpcode, ByteString data) {
 
   static final class Close {
     final int code;
-    final String reason;
+    final ByteString reason;
+    final long cancelAfterCloseMillis;
 
-    public Close(int code, String reason) {
+    Close(int code, ByteString reason, long cancelAfterCloseMillis) {
       this.code = code;
       this.reason = reason;
+      this.cancelAfterCloseMillis = cancelAfterCloseMillis;
     }
   }
 
   public abstract static class Streams implements Closeable {
-    final boolean client;
-    final BufferedSource source;
-    final BufferedSink sink;
+    public final boolean client;
+    public final BufferedSource source;
+    public final BufferedSink sink;
 
     public Streams(boolean client, BufferedSource source, BufferedSink sink) {
       this.client = client;
@@ -497,16 +580,9 @@ public Streams(boolean client, BufferedSource source, BufferedSink sink) {
     }
   }
 
-  static final class ClientStreams extends Streams {
-    private final StreamAllocation streamAllocation;
-
-    public ClientStreams(StreamAllocation streamAllocation) {
-      super(true, streamAllocation.connection().source, streamAllocation.connection().sink);
-      this.streamAllocation = streamAllocation;
-    }
-
-    @Override public void close() {
-      streamAllocation.streamFinished(true, streamAllocation.codec());
+  final class CancelRunnable implements Runnable {
+    @Override public void run() {
+      cancel();
     }
   }
 }
diff --git a/okhttp/src/main/java/okhttp3/internal/ws/WebSocketProtocol.java b/okhttp/src/main/java/okhttp3/internal/ws/WebSocketProtocol.java
index 8cd2bd2e72..5be61eea5f 100644
--- a/okhttp/src/main/java/okhttp3/internal/ws/WebSocketProtocol.java
+++ b/okhttp/src/main/java/okhttp3/internal/ws/WebSocketProtocol.java
@@ -74,6 +74,8 @@
    * special values {@link #PAYLOAD_SHORT} or {@link #PAYLOAD_LONG}.
    */
   static final long PAYLOAD_BYTE_MAX = 125L;
+  /** Maximum length of close message in bytes. */
+  static final long CLOSE_MESSAGE_MAX = PAYLOAD_BYTE_MAX - 2;
   /**
    * Value for {@link #B1_MASK_LENGTH} which indicates the next two bytes are the unsigned length.
    */
diff --git a/okhttp/src/main/java/okhttp3/internal/ws/WebSocketWriter.java b/okhttp/src/main/java/okhttp3/internal/ws/WebSocketWriter.java
index 237ec100f3..9c466d672d 100644
--- a/okhttp/src/main/java/okhttp3/internal/ws/WebSocketWriter.java
+++ b/okhttp/src/main/java/okhttp3/internal/ws/WebSocketWriter.java
@@ -33,8 +33,8 @@
 import static okhttp3.internal.ws.WebSocketProtocol.PAYLOAD_LONG;
 import static okhttp3.internal.ws.WebSocketProtocol.PAYLOAD_SHORT;
 import static okhttp3.internal.ws.WebSocketProtocol.PAYLOAD_SHORT_MAX;
-import static okhttp3.internal.ws.WebSocketProtocol.validateCloseCode;
 import static okhttp3.internal.ws.WebSocketProtocol.toggleMask;
+import static okhttp3.internal.ws.WebSocketProtocol.validateCloseCode;
 
 /**
  * An <a href="http://tools.ietf.org/html/rfc6455">RFC 6455</a>-compatible WebSocket frame writer.
@@ -94,7 +94,7 @@ void writePong(ByteString payload) throws IOException {
    * href="http://tools.ietf.org/html/rfc6455#section-7.4">Section 7.4 of RFC 6455</a> or {@code 0}.
    * @param reason Reason for shutting down or {@code null}.
    */
-  void writeClose(int code, String reason) throws IOException {
+  void writeClose(int code, ByteString reason) throws IOException {
     ByteString payload = ByteString.EMPTY;
     if (code != 0 || reason != null) {
       if (code != 0) {
@@ -103,7 +103,7 @@ void writeClose(int code, String reason) throws IOException {
       Buffer buffer = new Buffer();
       buffer.writeShort(code);
       if (reason != null) {
-        buffer.writeUtf8(reason);
+        buffer.write(reason);
       }
       payload = buffer.readByteString();
     }
diff --git a/okhttp/src/main/java/okhttp3/package-info.java b/okhttp/src/main/java/okhttp3/package-info.java
new file mode 100644
index 0000000000..a34c5bbf86
--- /dev/null
+++ b/okhttp/src/main/java/okhttp3/package-info.java
@@ -0,0 +1,3 @@
+/** An HTTP+HTTP/2 client for Android and Java applications. */
+@javax.annotation.ParametersAreNonnullByDefault
+package okhttp3;
diff --git a/okhttp/src/main/resources/okhttp3/internal/publicsuffix/publicsuffixes.gz b/okhttp/src/main/resources/okhttp3/internal/publicsuffix/publicsuffixes.gz
new file mode 100644
index 0000000000..3d9b2c9ccf
Binary files /dev/null and b/okhttp/src/main/resources/okhttp3/internal/publicsuffix/publicsuffixes.gz differ
diff --git a/okhttp/src/test/java/okhttp3/internal/publicsuffix/PublicSuffixListGenerator.java b/okhttp/src/test/java/okhttp3/internal/publicsuffix/PublicSuffixListGenerator.java
new file mode 100644
index 0000000000..50b1f8703a
--- /dev/null
+++ b/okhttp/src/test/java/okhttp3/internal/publicsuffix/PublicSuffixListGenerator.java
@@ -0,0 +1,124 @@
+/*
+ * Copyright (C) 2017 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.internal.publicsuffix;
+
+import java.io.File;
+import java.io.IOException;
+import java.util.SortedSet;
+import java.util.TreeSet;
+import okhttp3.OkHttpClient;
+import okhttp3.Request;
+import okhttp3.Response;
+import okio.BufferedSink;
+import okio.BufferedSource;
+import okio.ByteString;
+import okio.GzipSink;
+import okio.Okio;
+import okio.Sink;
+
+/**
+ * Downloads the public suffix list from https://publicsuffix.org/list/public_suffix_list.dat and
+ * transforms the file into an efficient format used by OkHttp.
+ *
+ * <p>The intent is to use this class to update the list periodically by manually running the main
+ * method. This should be run from the top-level okhttp directory.
+ *
+ * <p>The resulting file is used by {@link PublicSuffixDatabase}.
+ */
+public final class PublicSuffixListGenerator {
+  private static final String OKHTTP_RESOURCE_DIR = "okhttp" + File.separator + "src"
+      + File.separator + "main" + File.separator + "resources" + File.separator
+      + "okhttp3" + File.separator + "internal" + File.separator + "publicsuffix";
+
+  private static final ByteString EXCEPTION_RULE_MARKER = ByteString.encodeUtf8("!");
+  private static final String WILDCARD_CHAR = "*";
+
+  public static void main(String... args) throws IOException {
+    OkHttpClient client = new OkHttpClient.Builder().build();
+    Request request = new Request.Builder()
+        .url("https://publicsuffix.org/list/public_suffix_list.dat")
+        .build();
+    SortedSet<ByteString> sortedRules = new TreeSet<>();
+    SortedSet<ByteString> sortedExceptionRules = new TreeSet<>();
+    try (Response response = client.newCall(request).execute()) {
+      BufferedSource source = response.body().source();
+      int totalRuleBytes = 0;
+      int totalExceptionRuleBytes = 0;
+      while (!source.exhausted()) {
+        String line = source.readUtf8LineStrict();
+        if (line.trim().isEmpty() || line.startsWith("//")) continue;
+
+        if (line.contains(WILDCARD_CHAR)) {
+          assertWildcardRule(line);
+        }
+
+        ByteString rule = ByteString.encodeUtf8(line);
+        if (rule.startsWith(EXCEPTION_RULE_MARKER)) {
+          rule = rule.substring(1);
+          // We use '\n' for end of value.
+          totalExceptionRuleBytes += rule.size() + 1;
+          sortedExceptionRules.add(rule);
+        } else {
+          totalRuleBytes += rule.size() + 1; // We use '\n' for end of value.
+          sortedRules.add(rule);
+        }
+      }
+
+      File resources = new File(OKHTTP_RESOURCE_DIR);
+      if (!resources.mkdirs() && !resources.exists()) {
+        throw new RuntimeException("Unable to create resource directory!");
+      }
+
+      Sink fileSink = Okio.sink(new File(resources, PublicSuffixDatabase.PUBLIC_SUFFIX_RESOURCE));
+      try (BufferedSink sink = Okio.buffer(new GzipSink(fileSink))) {
+        sink.writeInt(totalRuleBytes);
+        for (ByteString domain : sortedRules) {
+          sink.write(domain).writeByte('\n');
+        }
+
+        sink.writeInt(totalExceptionRuleBytes);
+        for (ByteString domain : sortedExceptionRules) {
+          sink.write(domain).writeByte('\n');
+        }
+      }
+    }
+  }
+
+  /**
+   * These assertions ensure the {@link PublicSuffixDatabase} remains correct. The specification is
+   * very flexible regarding wildcard rules, but this flexibility is not something currently used
+   * in practice. To simplify the implementation, we've avoided implementing the flexible rules in
+   * favor of supporting what's actually used in practice. That means if these assertions ever fail,
+   * the implementation will need to be revisited to support a more flexible rule.
+   */
+  private static void assertWildcardRule(String rule) {
+    if (rule.indexOf(WILDCARD_CHAR) != 0) {
+      throw new RuntimeException("Wildcard Assertion Failure: " + rule + "\nA wildcard rule was "
+          + "added with a wildcard that is not in leftmost position! We'll need to change the "
+          + PublicSuffixDatabase.class.getName() + " to handle this.");
+    }
+    if (rule.indexOf(WILDCARD_CHAR, 1) != -1) {
+      throw new RuntimeException("Wildcard Assertion Failure: " + rule + "\nA wildcard rule was "
+          + "added with multiple wildcards! We'll need to change "
+          + PublicSuffixDatabase.class.getName() + " to handle this.");
+    }
+    if (rule.length() == 1) {
+      throw new RuntimeException("Wildcard Assertion Failure: " + rule + "\nA wildcard rule was "
+          + "added that wildcards the first level! We'll need to change the "
+          + PublicSuffixDatabase.class.getName() + " to handle this.");
+    }
+  }
+}
diff --git a/pom.xml b/pom.xml
index e1b638cb6c..c92a23be3c 100644
--- a/pom.xml
+++ b/pom.xml
@@ -11,7 +11,7 @@
 
   <groupId>com.squareup.okhttp3</groupId>
   <artifactId>parent</artifactId>
-  <version>3.5.0-SNAPSHOT</version>
+  <version>3.9.0-SNAPSHOT</version>
   <packaging>pom</packaging>
 
   <name>OkHttp (Parent)</name>
@@ -44,13 +44,13 @@
     <!-- ALPN library targeted to Java 7 -->
     <alpn.jdk7.version>7.1.2.v20141202</alpn.jdk7.version>
     <android.version>4.1.1.4</android.version>
-    <animal.sniffer.version>1.11</animal.sniffer.version>
+    <animal.sniffer.version>1.15</animal.sniffer.version>
     <apache.http.version>4.2.2</apache.http.version>
     <bouncycastle.version>1.50</bouncycastle.version>
     <guava.version>16.0</guava.version>
     <java.version>1.7</java.version>
     <moshi.version>1.1.0</moshi.version>
-    <okio.version>1.11.0</okio.version>
+    <okio.version>1.13.0</okio.version>
 
     <!-- Test Dependencies -->
     <junit.version>4.12</junit.version>
@@ -85,6 +85,12 @@
         <artifactId>okio</artifactId>
         <version>${okio.version}</version>
       </dependency>
+      <dependency>
+        <groupId>com.google.code.findbugs</groupId>
+        <artifactId>jsr305</artifactId>
+        <version>3.0.2</version>
+        <scope>provided</scope>
+      </dependency>
       <dependency>
         <groupId>junit</groupId>
         <artifactId>junit</artifactId>
@@ -129,11 +135,25 @@
         <plugin>
           <groupId>org.apache.maven.plugins</groupId>
           <artifactId>maven-compiler-plugin</artifactId>
-          <version>3.0</version>
+          <version>3.6.1</version>
           <configuration>
+            <compilerId>javac-with-errorprone</compilerId>
+            <forceJavacCompilerUse>true</forceJavacCompilerUse>
             <source>${java.version}</source>
             <target>${java.version}</target>
           </configuration>
+          <dependencies>
+            <dependency>
+              <groupId>org.codehaus.plexus</groupId>
+              <artifactId>plexus-compiler-javac-errorprone</artifactId>
+              <version>2.8.1</version>
+            </dependency>
+            <dependency>
+              <groupId>com.google.errorprone</groupId>
+              <artifactId>error_prone_core</artifactId>
+              <version>2.0.16</version>
+            </dependency>
+          </dependencies>
         </plugin>
 
         <plugin>
@@ -193,7 +213,14 @@
       <plugin>
         <groupId>org.apache.maven.plugins</groupId>
         <artifactId>maven-checkstyle-plugin</artifactId>
-        <version>2.12</version>
+        <version>2.17</version>
+        <dependencies>
+          <dependency>
+            <groupId>com.puppycrawl.tools</groupId>
+            <artifactId>checkstyle</artifactId>
+            <version>7.7</version>
+          </dependency>
+        </dependencies>
         <configuration>
           <failsOnError>true</failsOnError>
           <configLocation>checkstyle.xml</configLocation>
@@ -309,7 +336,7 @@
     <!-- ALPN Versions targeted for each Java 8 minor release -->
     <!-- Check versions with this page: -->
     <!-- http://www.eclipse.org/jetty/documentation/current/alpn-chapter.html#alpn-chapterchapterversions -->
-        <profile>
+    <profile>
       <id>alpn-when-jdk8_05</id>
       <activation>
         <jdk>1.8.0_05</jdk>
@@ -498,6 +525,32 @@
         <alpn.jdk8.version>8.1.9.v20160720</alpn.jdk8.version>
       </properties>
     </profile>
+    <profile>
+      <id>alpn-when-jdk8_112</id>
+      <activation>
+        <jdk>1.8.0_112</jdk>
+      </activation>
+      <properties>
+        <alpn.jdk8.version>8.1.9.v20160720</alpn.jdk8.version>
+      </properties>
+    </profile>
+    <profile>
+      <id>alpn-when-jdk8_121</id>
+      <activation>
+        <jdk>1.8.0_121</jdk>
+      </activation>
+      <properties>
+        <alpn.jdk8.version>8.1.11.v20170118</alpn.jdk8.version>
+      </properties>
+    </profile>
+    <profile>
+      <id>alpn-when-jdk8_131</id>
+      <activation>
+        <jdk>1.8.0_131</jdk>
+      </activation>
+      <properties>
+        <alpn.jdk8.version>8.1.11.v20170118</alpn.jdk8.version>
+      </properties>
+    </profile>
   </profiles>
 </project>
-
diff --git a/samples/crawler/pom.xml b/samples/crawler/pom.xml
index 8b91ca2dd7..ef746a07bf 100644
--- a/samples/crawler/pom.xml
+++ b/samples/crawler/pom.xml
@@ -6,7 +6,7 @@
   <parent>
     <groupId>com.squareup.okhttp3.sample</groupId>
     <artifactId>sample-parent</artifactId>
-    <version>3.5.0-SNAPSHOT</version>
+    <version>3.9.0-SNAPSHOT</version>
   </parent>
 
   <artifactId>crawler</artifactId>
diff --git a/samples/crawler/src/main/java/okhttp3/sample/Crawler.java b/samples/crawler/src/main/java/okhttp3/sample/Crawler.java
index c0964fdf8a..0818961703 100644
--- a/samples/crawler/src/main/java/okhttp3/sample/Crawler.java
+++ b/samples/crawler/src/main/java/okhttp3/sample/Crawler.java
@@ -72,10 +72,15 @@ private void drainQueue() throws Exception {
         continue;
       }
 
+      Thread currentThread = Thread.currentThread();
+      String originalName = currentThread.getName();
+      currentThread.setName("Crawler " + url.toString());
       try {
         fetch(url);
       } catch (IOException e) {
         System.out.printf("XXX: %s %s%n", url, e);
+      } finally {
+        currentThread.setName(originalName);
       }
     }
   }
@@ -114,7 +119,8 @@ public void fetch(HttpUrl url) throws IOException {
     for (Element element : document.select("a[href]")) {
       String href = element.attr("href");
       HttpUrl link = response.request().url().resolve(href);
-      if (link != null) queue.add(link);
+      if (link == null) continue; // URL is either invalid or its scheme isn't http/https.
+      queue.add(link.newBuilder().fragment(null).build());
     }
   }
 
diff --git a/samples/guide/pom.xml b/samples/guide/pom.xml
index 2d0c791c38..d8336f71bf 100644
--- a/samples/guide/pom.xml
+++ b/samples/guide/pom.xml
@@ -6,7 +6,7 @@
   <parent>
     <groupId>com.squareup.okhttp3.sample</groupId>
     <artifactId>sample-parent</artifactId>
-    <version>3.5.0-SNAPSHOT</version>
+    <version>3.9.0-SNAPSHOT</version>
   </parent>
 
   <artifactId>guide</artifactId>
diff --git a/samples/guide/src/main/java/okhttp3/recipes/Authenticate.java b/samples/guide/src/main/java/okhttp3/recipes/Authenticate.java
index 61eb27f2b1..4eb09d8f11 100644
--- a/samples/guide/src/main/java/okhttp3/recipes/Authenticate.java
+++ b/samples/guide/src/main/java/okhttp3/recipes/Authenticate.java
@@ -30,6 +30,10 @@ public Authenticate() {
     client = new OkHttpClient.Builder()
         .authenticator(new Authenticator() {
           @Override public Request authenticate(Route route, Response response) throws IOException {
+            if (response.request().header("Authorization") != null) {
+              return null; // Give up, we've already attempted to authenticate.
+            }
+
             System.out.println("Authenticating for response: " + response);
             System.out.println("Challenges: " + response.challenges());
             String credential = Credentials.basic("jesse", "password1");
diff --git a/samples/guide/src/main/java/okhttp3/recipes/CheckHandshake.java b/samples/guide/src/main/java/okhttp3/recipes/CheckHandshake.java
index 164e879079..befd80983c 100644
--- a/samples/guide/src/main/java/okhttp3/recipes/CheckHandshake.java
+++ b/samples/guide/src/main/java/okhttp3/recipes/CheckHandshake.java
@@ -28,7 +28,8 @@
 public final class CheckHandshake {
   /** Rejects otherwise-trusted certificates. */
   private static final Interceptor CHECK_HANDSHAKE_INTERCEPTOR = new Interceptor() {
-    Set<String> blacklist = Collections.singleton("sha1/DmxUShsZuNiqPQsX2Oi9uv2sCnw=");
+    Set<String> blacklist = Collections.singleton(
+        "sha256/afwiKY3RxoMmLkuRW1l7QsPZTJPwDS2pdDROQjXw8ig=");
 
     @Override public Response intercept(Chain chain) throws IOException {
       for (Certificate certificate : chain.connection().handshake().peerCertificates()) {
diff --git a/samples/guide/src/main/java/okhttp3/recipes/CustomCipherSuites.java b/samples/guide/src/main/java/okhttp3/recipes/CustomCipherSuites.java
new file mode 100644
index 0000000000..b568bdf01c
--- /dev/null
+++ b/samples/guide/src/main/java/okhttp3/recipes/CustomCipherSuites.java
@@ -0,0 +1,169 @@
+/*
+ * Copyright (C) 2017 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.recipes;
+
+import java.io.IOException;
+import java.net.InetAddress;
+import java.net.Socket;
+import java.security.GeneralSecurityException;
+import java.security.KeyManagementException;
+import java.security.KeyStore;
+import java.security.NoSuchAlgorithmException;
+import java.util.Arrays;
+import java.util.Collections;
+import java.util.List;
+import javax.net.ssl.SSLContext;
+import javax.net.ssl.SSLSocket;
+import javax.net.ssl.SSLSocketFactory;
+import javax.net.ssl.TrustManager;
+import javax.net.ssl.TrustManagerFactory;
+import javax.net.ssl.X509TrustManager;
+import okhttp3.CipherSuite;
+import okhttp3.ConnectionSpec;
+import okhttp3.OkHttpClient;
+import okhttp3.Request;
+import okhttp3.Response;
+
+public final class CustomCipherSuites {
+  private final OkHttpClient client;
+
+  public CustomCipherSuites() throws GeneralSecurityException {
+    // Configure cipher suites to demonstrate how to customize which cipher suites will be used for
+    // an OkHttp request. In order to be selected a cipher suite must be included in both OkHttp's
+    // connection spec and in the SSLSocket's enabled cipher suites array. Most applications should
+    // not customize the cipher suites list.
+    List<CipherSuite> customCipherSuites = Arrays.asList(
+        CipherSuite.TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256,
+        CipherSuite.TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256,
+        CipherSuite.TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384,
+        CipherSuite.TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384);
+    final ConnectionSpec spec = new ConnectionSpec.Builder(ConnectionSpec.MODERN_TLS)
+        .cipherSuites(customCipherSuites.toArray(new CipherSuite[0]))
+        .build();
+
+    X509TrustManager trustManager = defaultTrustManager();
+    SSLSocketFactory sslSocketFactory = defaultSslSocketFactory(trustManager);
+    SSLSocketFactory customSslSocketFactory = new DelegatingSSLSocketFactory(sslSocketFactory) {
+      @Override protected SSLSocket configureSocket(SSLSocket socket) throws IOException {
+        socket.setEnabledCipherSuites(javaNames(spec.cipherSuites()));
+        return socket;
+      }
+    };
+
+    client = new OkHttpClient.Builder()
+        .connectionSpecs(Collections.singletonList(spec))
+        .sslSocketFactory(customSslSocketFactory, trustManager)
+        .build();
+  }
+
+  /**
+   * Returns the VM's default SSL socket factory, using {@code trustManager} for trusted root
+   * certificates.
+   */
+  private SSLSocketFactory defaultSslSocketFactory(X509TrustManager trustManager)
+      throws NoSuchAlgorithmException, KeyManagementException {
+    SSLContext sslContext = SSLContext.getInstance("TLS");
+    sslContext.init(null, new TrustManager[] { trustManager }, null);
+
+    return sslContext.getSocketFactory();
+  }
+
+  /** Returns a trust manager that trusts the VM's default certificate authorities. */
+  private X509TrustManager defaultTrustManager() throws GeneralSecurityException {
+    TrustManagerFactory trustManagerFactory = TrustManagerFactory.getInstance(
+        TrustManagerFactory.getDefaultAlgorithm());
+    trustManagerFactory.init((KeyStore) null);
+    TrustManager[] trustManagers = trustManagerFactory.getTrustManagers();
+    if (trustManagers.length != 1 || !(trustManagers[0] instanceof X509TrustManager)) {
+      throw new IllegalStateException("Unexpected default trust managers:"
+          + Arrays.toString(trustManagers));
+    }
+    return (X509TrustManager) trustManagers[0];
+  }
+
+  private String[] javaNames(List<CipherSuite> cipherSuites) {
+    String[] result = new String[cipherSuites.size()];
+    for (int i = 0; i < result.length; i++) {
+      result[i] = cipherSuites.get(i).javaName();
+    }
+    return result;
+  }
+
+  /**
+   * An SSL socket factory that forwards all calls to a delegate. Override {@link #configureSocket}
+   * to customize a created socket before it is returned.
+   */
+  static class DelegatingSSLSocketFactory extends SSLSocketFactory {
+    protected final SSLSocketFactory delegate;
+
+    DelegatingSSLSocketFactory(SSLSocketFactory delegate) {
+      this.delegate = delegate;
+    }
+
+    @Override public String[] getDefaultCipherSuites() {
+      return delegate.getDefaultCipherSuites();
+    }
+
+    @Override public String[] getSupportedCipherSuites() {
+      return delegate.getSupportedCipherSuites();
+    }
+
+    @Override public Socket createSocket(
+        Socket socket, String host, int port, boolean autoClose) throws IOException {
+      return configureSocket((SSLSocket) delegate.createSocket(socket, host, port, autoClose));
+    }
+
+    @Override public Socket createSocket(String host, int port) throws IOException {
+      return configureSocket((SSLSocket) delegate.createSocket(host, port));
+    }
+
+    @Override public Socket createSocket(
+        String host, int port, InetAddress localHost, int localPort) throws IOException {
+      return configureSocket((SSLSocket) delegate.createSocket(host, port, localHost, localPort));
+    }
+
+    @Override public Socket createSocket(InetAddress host, int port) throws IOException {
+      return configureSocket((SSLSocket) delegate.createSocket(host, port));
+    }
+
+    @Override public Socket createSocket(
+        InetAddress address, int port, InetAddress localAddress, int localPort) throws IOException {
+      return configureSocket((SSLSocket) delegate.createSocket(
+          address, port, localAddress, localPort));
+    }
+
+    protected SSLSocket configureSocket(SSLSocket socket) throws IOException {
+      return socket;
+    }
+  }
+
+  public void run() throws Exception {
+    Request request = new Request.Builder()
+        .url("https://publicobject.com/helloworld.txt")
+        .build();
+
+    try (Response response = client.newCall(request).execute()) {
+      if (!response.isSuccessful()) throw new IOException("Unexpected code " + response);
+
+      System.out.println(response.handshake().cipherSuite());
+      System.out.println(response.body().string());
+    }
+  }
+
+  public static void main(String... args) throws Exception {
+    new CustomCipherSuites().run();
+  }
+}
diff --git a/samples/guide/src/main/java/okhttp3/recipes/PostStreamingWithPipe.java b/samples/guide/src/main/java/okhttp3/recipes/PostStreamingWithPipe.java
new file mode 100644
index 0000000000..b313ce0d1a
--- /dev/null
+++ b/samples/guide/src/main/java/okhttp3/recipes/PostStreamingWithPipe.java
@@ -0,0 +1,105 @@
+/*
+ * Copyright (C) 2017 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.recipes;
+
+import java.io.IOException;
+import okhttp3.MediaType;
+import okhttp3.OkHttpClient;
+import okhttp3.Request;
+import okhttp3.RequestBody;
+import okhttp3.Response;
+import okio.BufferedSink;
+import okio.Okio;
+import okio.Pipe;
+
+public final class PostStreamingWithPipe {
+  public static final MediaType MEDIA_TYPE_MARKDOWN
+      = MediaType.parse("text/x-markdown; charset=utf-8");
+
+  private final OkHttpClient client = new OkHttpClient();
+
+  public void run() throws Exception {
+    final PipeBody pipeBody = new PipeBody();
+
+    Request request = new Request.Builder()
+        .url("https://api.github.com/markdown/raw")
+        .post(pipeBody)
+        .build();
+
+    streamPrimesToSinkAsynchronously(pipeBody.sink());
+
+    try (Response response = client.newCall(request).execute()) {
+      if (!response.isSuccessful()) throw new IOException("Unexpected code " + response);
+
+      System.out.println(response.body().string());
+    }
+  }
+
+  private void streamPrimesToSinkAsynchronously(final BufferedSink sink) {
+    Thread thread = new Thread("writer") {
+      @Override public void run() {
+        try {
+          sink.writeUtf8("Numbers\n");
+          sink.writeUtf8("-------\n");
+          for (int i = 2; i <= 997; i++) {
+            System.out.println(i);
+            Thread.sleep(10);
+            sink.writeUtf8(String.format(" * %s = %s\n", i, factor(i)));
+          }
+          sink.close();
+        } catch (IOException | InterruptedException e) {
+          e.printStackTrace();
+        }
+      }
+
+      private String factor(int n) {
+        for (int i = 2; i < n; i++) {
+          int x = n / i;
+          if (x * i == n) return factor(x) + " × " + i;
+        }
+        return Integer.toString(n);
+      }
+    };
+
+    thread.start();
+  }
+
+  /**
+   * This request body makes it possible for another thread to stream data to the uploading request.
+   * This is potentially useful for posting live event streams like video capture. Callers should
+   * write to {@code sink()} and close it to complete the post.
+   */
+  static final class PipeBody extends RequestBody {
+    private final Pipe pipe = new Pipe(8192);
+    private final BufferedSink sink = Okio.buffer(pipe.sink());
+
+    public BufferedSink sink() {
+      return sink;
+    }
+
+    @Override public MediaType contentType() {
+      return MEDIA_TYPE_MARKDOWN;
+    }
+
+    @Override public void writeTo(BufferedSink sink) throws IOException {
+      sink.writeAll(pipe.source());
+    }
+  }
+
+  public static void main(String... args) throws Exception {
+    new PostStreamingWithPipe().run();
+  }
+}
diff --git a/samples/guide/src/main/java/okhttp3/recipes/Progress.java b/samples/guide/src/main/java/okhttp3/recipes/Progress.java
index f04de79340..30566908a1 100644
--- a/samples/guide/src/main/java/okhttp3/recipes/Progress.java
+++ b/samples/guide/src/main/java/okhttp3/recipes/Progress.java
@@ -72,7 +72,7 @@ public static void main(String... args) throws Exception {
     private final ProgressListener progressListener;
     private BufferedSource bufferedSource;
 
-    public ProgressResponseBody(ResponseBody responseBody, ProgressListener progressListener) {
+    ProgressResponseBody(ResponseBody responseBody, ProgressListener progressListener) {
       this.responseBody = responseBody;
       this.progressListener = progressListener;
     }
diff --git a/samples/pom.xml b/samples/pom.xml
index 1c0dc8b829..4f617d0d34 100644
--- a/samples/pom.xml
+++ b/samples/pom.xml
@@ -6,7 +6,7 @@
   <parent>
     <groupId>com.squareup.okhttp3</groupId>
     <artifactId>parent</artifactId>
-    <version>3.5.0-SNAPSHOT</version>
+    <version>3.9.0-SNAPSHOT</version>
   </parent>
 
   <groupId>com.squareup.okhttp3.sample</groupId>
diff --git a/samples/simple-client/pom.xml b/samples/simple-client/pom.xml
index c3330e4025..1f8f6507f3 100644
--- a/samples/simple-client/pom.xml
+++ b/samples/simple-client/pom.xml
@@ -6,7 +6,7 @@
   <parent>
     <groupId>com.squareup.okhttp3.sample</groupId>
     <artifactId>sample-parent</artifactId>
-    <version>3.5.0-SNAPSHOT</version>
+    <version>3.9.0-SNAPSHOT</version>
   </parent>
 
   <artifactId>simple-client</artifactId>
diff --git a/samples/slack/pom.xml b/samples/slack/pom.xml
index 2b4d58b769..d065531a84 100644
--- a/samples/slack/pom.xml
+++ b/samples/slack/pom.xml
@@ -6,7 +6,7 @@
   <parent>
     <groupId>com.squareup.okhttp3.sample</groupId>
     <artifactId>sample-parent</artifactId>
-    <version>3.5.0-SNAPSHOT</version>
+    <version>3.9.0-SNAPSHOT</version>
   </parent>
 
   <artifactId>slack</artifactId>
diff --git a/samples/slack/src/main/java/okhttp3/slack/SlackApi.java b/samples/slack/src/main/java/okhttp3/slack/SlackApi.java
index 7515a426e8..0ec0ef7a45 100644
--- a/samples/slack/src/main/java/okhttp3/slack/SlackApi.java
+++ b/samples/slack/src/main/java/okhttp3/slack/SlackApi.java
@@ -34,7 +34,7 @@
  * instance of this class may operate without a user, or on behalf of many users. Use the Slack API
  * dashboard to create a client ID and secret for this application.
  *
- * <p>You must configure your Slack API OAuth & Permissions page with a localhost URL like {@code
+ * <p>You must configure your Slack API OAuth and Permissions page with a localhost URL like {@code
  * http://localhost:53203/oauth/}, passing the same port to this class’ constructor.
  */
 public final class SlackApi {
diff --git a/samples/static-server/pom.xml b/samples/static-server/pom.xml
index ca52ac4b8a..26f091a3c9 100644
--- a/samples/static-server/pom.xml
+++ b/samples/static-server/pom.xml
@@ -6,7 +6,7 @@
   <parent>
     <groupId>com.squareup.okhttp3.sample</groupId>
     <artifactId>sample-parent</artifactId>
-    <version>3.5.0-SNAPSHOT</version>
+    <version>3.9.0-SNAPSHOT</version>
   </parent>
 
   <artifactId>static-server</artifactId>
diff --git a/website/index.html b/website/index.html
index ff9ec474b3..6f0df48a03 100644
--- a/website/index.html
+++ b/website/index.html
@@ -78,8 +78,9 @@ <h4>Get a URL</h4>
       .url(url)
       .build();
 
-  Response response = client.newCall(request).execute();
-  return response.body().string();
+  try (Response response = client.newCall(request).execute()) {
+    return response.body().string();
+  }
 }
 </pre>
             <h4>Post to a Server</h4>
@@ -97,8 +98,9 @@ <h4>Post to a Server</h4>
       .url(url)
       .post(body)
       .build();
-  Response response = client.newCall(request).execute();
-  return response.body().string();
+  try (Response response = client.newCall(request).execute()) {
+    return response.body().string();
+  }
 }
 </pre>
 
