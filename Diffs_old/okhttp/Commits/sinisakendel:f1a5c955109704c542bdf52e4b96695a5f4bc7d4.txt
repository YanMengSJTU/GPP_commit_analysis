diff --git a/mockwebserver/src/main/java/com/squareup/okhttp/mockwebserver/MockWebServer.java b/mockwebserver/src/main/java/com/squareup/okhttp/mockwebserver/MockWebServer.java
index 5f83a1fc5e..6c5f5f8960 100644
--- a/mockwebserver/src/main/java/com/squareup/okhttp/mockwebserver/MockWebServer.java
+++ b/mockwebserver/src/main/java/com/squareup/okhttp/mockwebserver/MockWebServer.java
@@ -40,7 +40,6 @@
 import java.net.Socket;
 import java.net.SocketException;
 import java.net.URL;
-import java.net.UnknownHostException;
 import java.security.SecureRandom;
 import java.security.cert.CertificateException;
 import java.security.cert.X509Certificate;
@@ -109,25 +108,24 @@
   private Dispatcher dispatcher = new QueueDispatcher();
 
   private int port = -1;
+  private InetAddress inetAddress;
   private boolean protocolNegotiationEnabled = true;
   private List<Protocol> protocols
       = Util.immutableList(Protocol.HTTP_2, Protocol.SPDY_3, Protocol.HTTP_1_1);
 
   public int getPort() {
-    if (port == -1) throw new IllegalStateException("Cannot retrieve port before calling play()");
+    if (port == -1) throw new IllegalStateException("Call play() before getPort()");
     return port;
   }
 
   public String getHostName() {
-    try {
-      return InetAddress.getLocalHost().getHostName();
-    } catch (UnknownHostException e) {
-      throw new AssertionError(e);
-    }
+    if (inetAddress == null) throw new IllegalStateException("Call play() before getHostName()");
+    return inetAddress.getHostName();
   }
 
   public Proxy toProxyAddress() {
-    return new Proxy(Proxy.Type.HTTP, new InetSocketAddress(getHostName(), getPort()));
+    if (inetAddress == null) throw new IllegalStateException("Call play() before toProxyAddress()");
+    return new Proxy(Proxy.Type.HTTP, new InetSocketAddress(inetAddress, getPort()));
   }
 
   /**
@@ -284,11 +282,12 @@ public void play() throws IOException {
   public void play(int port) throws IOException {
     if (executor != null) throw new IllegalStateException("play() already called");
     executor = Executors.newCachedThreadPool(Util.threadFactory("MockWebServer", false));
-    serverSocket = new ServerSocket(port);
+    inetAddress = InetAddress.getLocalHost();
+    serverSocket = new ServerSocket(port, 50, inetAddress);
     serverSocket.setReuseAddress(true);
 
     this.port = serverSocket.getLocalPort();
-    executor.execute(new NamedRunnable("MockWebServer %s", port) {
+    executor.execute(new NamedRunnable("MockWebServer %s", this.port) {
       @Override protected void execute() {
         try {
           acceptConnections();
@@ -332,8 +331,18 @@ private void acceptConnections() throws Exception {
   }
 
   public void shutdown() throws IOException {
-    if (serverSocket != null) {
-      serverSocket.close(); // Should cause acceptConnections() to break out.
+    if (serverSocket == null) return;
+
+    // Cause acceptConnections() to break out.
+    serverSocket.close();
+
+    // Await shutdown.
+    try {
+      if (!executor.awaitTermination(5, TimeUnit.SECONDS)) {
+        throw new IOException("Gave up waiting for executor to shut down");
+      }
+    } catch (InterruptedException e) {
+      throw new AssertionError();
     }
   }
 
@@ -440,7 +449,7 @@ private boolean processOneRequest(Socket socket, InputStream in, OutputStream ou
           socket.close();
           return false;
         }
-        writeResponse(out, response);
+        writeResponse(socket, out, response);
         if (response.getSocketPolicy() == SocketPolicy.DISCONNECT_AT_END) {
           in.close();
           out.close();
@@ -525,7 +534,7 @@ private RecordedRequest readRequest(Socket socket, InputStream in, OutputStream
     MockResponse throttlePolicy = dispatcher.peek();
     if (contentLength != -1) {
       hasBody = contentLength > 0;
-      throttledTransfer(throttlePolicy, in, requestBody, contentLength);
+      throttledTransfer(throttlePolicy, socket, in, requestBody, contentLength);
     } else if (chunked) {
       hasBody = true;
       while (true) {
@@ -535,7 +544,7 @@ private RecordedRequest readRequest(Socket socket, InputStream in, OutputStream
           break;
         }
         chunkSizes.add(chunkSize);
-        throttledTransfer(throttlePolicy, in, requestBody, chunkSize);
+        throttledTransfer(throttlePolicy, socket, in, requestBody, chunkSize);
         readEmptyLine(in);
       }
     }
@@ -559,7 +568,8 @@ private RecordedRequest readRequest(Socket socket, InputStream in, OutputStream
         requestBody.toByteArray(), sequenceNumber, socket);
   }
 
-  private void writeResponse(OutputStream out, MockResponse response) throws IOException {
+  private void writeResponse(Socket socket, OutputStream out, MockResponse response)
+      throws IOException {
     out.write((response.getStatus() + "\r\n").getBytes(Util.US_ASCII));
     List<String> headers = response.getHeaders();
     for (int i = 0, size = headers.size(); i < size; i++) {
@@ -571,7 +581,7 @@ private void writeResponse(OutputStream out, MockResponse response) throws IOExc
 
     InputStream in = response.getBodyStream();
     if (in == null) return;
-    throttledTransfer(response, in, out, Long.MAX_VALUE);
+    throttledTransfer(response, socket, in, out, Long.MAX_VALUE);
   }
 
   /**
@@ -579,13 +589,13 @@ private void writeResponse(OutputStream out, MockResponse response) throws IOExc
    * bytes have been transferred or {@code in} is exhausted. The transfer is
    * throttled according to {@code throttlePolicy}.
    */
-  private void throttledTransfer(MockResponse throttlePolicy, InputStream in, OutputStream out,
-      long limit) throws IOException {
+  private void throttledTransfer(MockResponse throttlePolicy, Socket socket, InputStream in,
+      OutputStream out, long limit) throws IOException {
     byte[] buffer = new byte[1024];
     int bytesPerPeriod = throttlePolicy.getThrottleBytesPerPeriod();
     long delayMs = throttlePolicy.getThrottleUnit().toMillis(throttlePolicy.getThrottlePeriod());
 
-    while (true) {
+    while (!socket.isClosed()) {
       for (int b = 0; b < bytesPerPeriod; ) {
         int toRead = (int) Math.min(Math.min(buffer.length, limit), bytesPerPeriod - b);
         int read = in.read(buffer, 0, toRead);
diff --git a/okhttp-tests/src/test/java/com/squareup/okhttp/CacheTest.java b/okhttp-tests/src/test/java/com/squareup/okhttp/CacheTest.java
index dcda4e99b8..f489cc9cdd 100644
--- a/okhttp-tests/src/test/java/com/squareup/okhttp/CacheTest.java
+++ b/okhttp-tests/src/test/java/com/squareup/okhttp/CacheTest.java
@@ -268,7 +268,8 @@ private void testResponseCaching(TransferKind transferKind) throws IOException {
   }
 
   @Test public void responseCachingAndRedirects() throws Exception {
-    server.enqueue(new MockResponse().addHeader("Last-Modified: " + formatDate(-1, TimeUnit.HOURS))
+    server.enqueue(new MockResponse()
+        .addHeader("Last-Modified: " + formatDate(-1, TimeUnit.HOURS))
         .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS))
         .setResponseCode(HttpURLConnection.HTTP_MOVED_PERM)
         .addHeader("Location: /foo"));
@@ -276,7 +277,8 @@ private void testResponseCaching(TransferKind transferKind) throws IOException {
         .addHeader("Last-Modified: " + formatDate(-1, TimeUnit.HOURS))
         .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS))
         .setBody("ABC"));
-    server.enqueue(new MockResponse().setBody("DEF"));
+    server.enqueue(new MockResponse()
+        .setBody("DEF"));
 
     Request request = new Request.Builder().url(server.getUrl("/")).build();
     Response response1 = client.newCall(request).execute();
@@ -291,7 +293,9 @@ private void testResponseCaching(TransferKind transferKind) throws IOException {
   }
 
   @Test public void redirectToCachedResult() throws Exception {
-    server.enqueue(new MockResponse().addHeader("Cache-Control: max-age=60").setBody("ABC"));
+    server.enqueue(new MockResponse()
+        .addHeader("Cache-Control: max-age=60")
+        .setBody("ABC"));
     server.enqueue(new MockResponse()
         .setResponseCode(HttpURLConnection.HTTP_MOVED_PERM)
         .addHeader("Location: /foo"));
@@ -332,7 +336,8 @@ private void testResponseCaching(TransferKind transferKind) throws IOException {
         .addHeader("Last-Modified: " + formatDate(-1, TimeUnit.HOURS))
         .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS))
         .setBody("ABC"));
-    server.enqueue(new MockResponse().setBody("DEF"));
+    server.enqueue(new MockResponse()
+        .setBody("DEF"));
 
     client.setSslSocketFactory(sslContext.getSocketFactory());
     client.setHostnameVerifier(NULL_HOSTNAME_VERIFIER);
@@ -365,7 +370,8 @@ private void testResponseCaching(TransferKind transferKind) throws IOException {
         .addHeader("Last-Modified: " + formatDate(-1, TimeUnit.HOURS))
         .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS))
         .setBody("ABC"));
-    server2.enqueue(new MockResponse().setBody("DEF"));
+    server2.enqueue(new MockResponse()
+        .setBody("DEF"));
 
     server.enqueue(new MockResponse()
         .addHeader("Last-Modified: " + formatDate(-1, TimeUnit.HOURS))
@@ -518,7 +524,8 @@ private void testClientPrematureDisconnect(TransferKind transferKind) throws IOE
         .addHeader("Last-Modified: " + formatDate(-105, TimeUnit.SECONDS))
         .addHeader("Date: " + formatDate(-5, TimeUnit.SECONDS))
         .setBody("A"));
-    server.enqueue(new MockResponse().setBody("B"));
+    server.enqueue(new MockResponse()
+        .setBody("B"));
 
     URL url = server.getUrl("/?foo=bar");
     assertEquals("A", get(url).body().string());
@@ -535,15 +542,18 @@ private void testClientPrematureDisconnect(TransferKind transferKind) throws IOE
   }
 
   @Test public void expirationDateInThePastWithNoLastModifiedHeader() throws Exception {
-    assertNotCached(new MockResponse().addHeader("Expires: " + formatDate(-1, TimeUnit.HOURS)));
+    assertNotCached(new MockResponse()
+        .addHeader("Expires: " + formatDate(-1, TimeUnit.HOURS)));
   }
 
   @Test public void expirationDateInTheFuture() throws Exception {
-    assertFullyCached(new MockResponse().addHeader("Expires: " + formatDate(1, TimeUnit.HOURS)));
+    assertFullyCached(new MockResponse()
+        .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS)));
   }
 
   @Test public void maxAgePreferredWithMaxAgeAndExpires() throws Exception {
-    assertFullyCached(new MockResponse().addHeader("Date: " + formatDate(0, TimeUnit.HOURS))
+    assertFullyCached(new MockResponse()
+        .addHeader("Date: " + formatDate(0, TimeUnit.HOURS))
         .addHeader("Expires: " + formatDate(-1, TimeUnit.HOURS))
         .addHeader("Cache-Control: max-age=60"));
   }
@@ -561,7 +571,8 @@ private void testClientPrematureDisconnect(TransferKind transferKind) throws IOE
   @Test public void maxAgeInThePastWithDateHeaderButNoLastModifiedHeader() throws Exception {
     // Chrome interprets max-age relative to the local clock. Both our cache
     // and Firefox both use the earlier of the local and server's clock.
-    assertNotCached(new MockResponse().addHeader("Date: " + formatDate(-120, TimeUnit.SECONDS))
+    assertNotCached(new MockResponse()
+        .addHeader("Date: " + formatDate(-120, TimeUnit.SECONDS))
         .addHeader("Cache-Control: max-age=60"));
   }
 
@@ -577,26 +588,28 @@ private void testClientPrematureDisconnect(TransferKind transferKind) throws IOE
   }
 
   @Test public void maxAgeWithLastModifiedButNoServedDate() throws Exception {
-    assertFullyCached(
-        new MockResponse().addHeader("Last-Modified: " + formatDate(-120, TimeUnit.SECONDS))
-            .addHeader("Cache-Control: max-age=60"));
+    assertFullyCached(new MockResponse()
+        .addHeader("Last-Modified: " + formatDate(-120, TimeUnit.SECONDS))
+        .addHeader("Cache-Control: max-age=60"));
   }
 
   @Test public void maxAgeInTheFutureWithDateAndLastModifiedHeaders() throws Exception {
-    assertFullyCached(
-        new MockResponse().addHeader("Last-Modified: " + formatDate(-120, TimeUnit.SECONDS))
-            .addHeader("Date: " + formatDate(0, TimeUnit.SECONDS))
-            .addHeader("Cache-Control: max-age=60"));
+    assertFullyCached(new MockResponse()
+        .addHeader("Last-Modified: " + formatDate(-120, TimeUnit.SECONDS))
+        .addHeader("Date: " + formatDate(0, TimeUnit.SECONDS))
+        .addHeader("Cache-Control: max-age=60"));
   }
 
   @Test public void maxAgePreferredOverLowerSharedMaxAge() throws Exception {
-    assertFullyCached(new MockResponse().addHeader("Date: " + formatDate(-2, TimeUnit.MINUTES))
+    assertFullyCached(new MockResponse()
+        .addHeader("Date: " + formatDate(-2, TimeUnit.MINUTES))
         .addHeader("Cache-Control: s-maxage=60")
         .addHeader("Cache-Control: max-age=180"));
   }
 
   @Test public void maxAgePreferredOverHigherMaxAge() throws Exception {
-    assertNotCached(new MockResponse().addHeader("Date: " + formatDate(-2, TimeUnit.MINUTES))
+    assertNotCached(new MockResponse()
+        .addHeader("Date: " + formatDate(-2, TimeUnit.MINUTES))
         .addHeader("Cache-Control: s-maxage=180")
         .addHeader("Cache-Control: max-age=60"));
   }
@@ -705,8 +718,9 @@ private void testMethodInvalidates(String requestMethod) throws Exception {
     // 1. seed the cache
     // 2. invalidate it with uncacheable response
     // 3. expect a cache miss
-    server.enqueue(
-        new MockResponse().setBody("A").addHeader("Expires: " + formatDate(1, TimeUnit.HOURS)));
+    server.enqueue(new MockResponse()
+        .setBody("A")
+        .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS)));
     server.enqueue(new MockResponse()
         .setBody("B")
         .setResponseCode(500));
@@ -728,8 +742,8 @@ private void testMethodInvalidates(String requestMethod) throws Exception {
   }
 
   @Test public void etag() throws Exception {
-    RecordedRequest conditionalRequest = assertConditionallyCached(
-        new MockResponse().addHeader("ETag: v1"));
+    RecordedRequest conditionalRequest = assertConditionallyCached(new MockResponse()
+        .addHeader("ETag: v1"));
     assertTrue(conditionalRequest.getHeaders().contains("If-None-Match: v1"));
   }
 
@@ -745,13 +759,15 @@ private void testMethodInvalidates(String requestMethod) throws Exception {
   }
 
   @Test public void etagAndExpirationDateInTheFuture() throws Exception {
-    assertFullyCached(new MockResponse().addHeader("ETag: v1")
+    assertFullyCached(new MockResponse()
+        .addHeader("ETag: v1")
         .addHeader("Last-Modified: " + formatDate(-2, TimeUnit.HOURS))
         .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS)));
   }
 
   @Test public void cacheControlNoCache() throws Exception {
-    assertNotCached(new MockResponse().addHeader("Cache-Control: no-cache"));
+    assertNotCached(new MockResponse()
+        .addHeader("Cache-Control: no-cache"));
   }
 
   @Test public void cacheControlNoCacheAndExpirationDateInTheFuture() throws Exception {
@@ -765,7 +781,8 @@ private void testMethodInvalidates(String requestMethod) throws Exception {
   }
 
   @Test public void pragmaNoCache() throws Exception {
-    assertNotCached(new MockResponse().addHeader("Pragma: no-cache"));
+    assertNotCached(new MockResponse()
+        .addHeader("Pragma: no-cache"));
   }
 
   @Test public void pragmaNoCacheAndExpirationDateInTheFuture() throws Exception {
@@ -779,11 +796,13 @@ private void testMethodInvalidates(String requestMethod) throws Exception {
   }
 
   @Test public void cacheControlNoStore() throws Exception {
-    assertNotCached(new MockResponse().addHeader("Cache-Control: no-store"));
+    assertNotCached(new MockResponse()
+        .addHeader("Cache-Control: no-store"));
   }
 
   @Test public void cacheControlNoStoreAndExpirationDateInTheFuture() throws Exception {
-    assertNotCached(new MockResponse().addHeader("Last-Modified: " + formatDate(-2, TimeUnit.HOURS))
+    assertNotCached(new MockResponse()
+        .addHeader("Last-Modified: " + formatDate(-2, TimeUnit.HOURS))
         .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS))
         .addHeader("Cache-Control: no-store"));
   }
@@ -796,7 +815,8 @@ private void testMethodInvalidates(String requestMethod) throws Exception {
         .setResponseCode(HttpURLConnection.HTTP_PARTIAL)
         .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS))
         .addHeader("Content-Range: bytes 1000-1001/2000"));
-    server.enqueue(new MockResponse().setBody("BB"));
+    server.enqueue(new MockResponse()
+        .setBody("BB"));
 
     URL url = server.getUrl("/");
 
@@ -825,16 +845,38 @@ private void testMethodInvalidates(String requestMethod) throws Exception {
     assertEquals("A", get(url).body().string());
   }
 
+  @Test public void clientSideNoStore() throws Exception {
+    server.enqueue(new MockResponse()
+        .addHeader("Cache-Control: max-age=60")
+        .setBody("A"));
+    server.enqueue(new MockResponse()
+        .addHeader("Cache-Control: max-age=60")
+        .setBody("B"));
+
+    Request request1 = new Request.Builder()
+        .url(server.getUrl("/"))
+        .cacheControl(new CacheControl.Builder().noStore().build())
+        .build();
+    Response response1 = client.newCall(request1).execute();
+    assertEquals("A", response1.body().string());
+
+    Request request2 = new Request.Builder()
+        .url(server.getUrl("/"))
+        .build();
+    Response response2 = client.newCall(request2).execute();
+    assertEquals("B", response2.body().string());
+  }
+
   @Test public void nonIdentityEncodingAndConditionalCache() throws Exception {
-    assertNonIdentityEncodingCached(
-        new MockResponse().addHeader("Last-Modified: " + formatDate(-2, TimeUnit.HOURS))
-            .addHeader("Expires: " + formatDate(-1, TimeUnit.HOURS)));
+    assertNonIdentityEncodingCached(new MockResponse()
+        .addHeader("Last-Modified: " + formatDate(-2, TimeUnit.HOURS))
+        .addHeader("Expires: " + formatDate(-1, TimeUnit.HOURS)));
   }
 
   @Test public void nonIdentityEncodingAndFullCache() throws Exception {
-    assertNonIdentityEncodingCached(
-        new MockResponse().addHeader("Last-Modified: " + formatDate(-2, TimeUnit.HOURS))
-            .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS)));
+    assertNonIdentityEncodingCached(new MockResponse()
+        .addHeader("Last-Modified: " + formatDate(-2, TimeUnit.HOURS))
+        .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS)));
   }
 
   private void assertNonIdentityEncodingCached(MockResponse response) throws Exception {
@@ -860,9 +902,11 @@ private void assertNonIdentityEncodingCached(MockResponse response) throws Excep
         .addHeader("Content-Encoding: gzip")
         .addHeader("Last-Modified: " + formatDate(-2, TimeUnit.HOURS))
         .addHeader("Expires: " + formatDate(-1, TimeUnit.HOURS)));
-    server.enqueue(new MockResponse().setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED)
+    server.enqueue(new MockResponse()
+        .setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED)
         .addHeader("Content-Encoding: gzip"));
-    server.enqueue(new MockResponse().setBody("DEFDEFDEF"));
+    server.enqueue(new MockResponse()
+        .setBody("DEFDEFDEF"));
 
     assertEquals("ABCABCABC", get(server.getUrl("/")).body().string());
     assertEquals("ABCABCABC", get(server.getUrl("/")).body().string());
@@ -876,7 +920,8 @@ private void assertNonIdentityEncodingCached(MockResponse response) throws Excep
         .addHeader("Content-Encoding: gzip")
         .addHeader("Vary: Accept-Encoding")
         .addHeader("Cache-Control: max-age=60"));
-    server.enqueue(new MockResponse().setBody("FAIL"));
+    server.enqueue(new MockResponse()
+        .setBody("FAIL"));
 
     assertEquals("ABCABCABC", get(server.getUrl("/")).body().string());
     assertEquals("ABCABCABC", get(server.getUrl("/")).body().string());
@@ -884,7 +929,8 @@ private void assertNonIdentityEncodingCached(MockResponse response) throws Excep
 
   @Test public void conditionalCacheHitIsNotDoublePooled() throws Exception {
     server.enqueue(new MockResponse()
-        .addHeader("ETag: v1").setBody("A"));
+        .addHeader("ETag: v1")
+        .setBody("A"));
     server.enqueue(new MockResponse()
         .clearHeaders()
         .setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
@@ -899,9 +945,9 @@ private void assertNonIdentityEncodingCached(MockResponse response) throws Excep
   }
 
   @Test public void expiresDateBeforeModifiedDate() throws Exception {
-    assertConditionallyCached(
-        new MockResponse().addHeader("Last-Modified: " + formatDate(-1, TimeUnit.HOURS))
-            .addHeader("Expires: " + formatDate(-2, TimeUnit.HOURS)));
+    assertConditionallyCached(new MockResponse()
+        .addHeader("Last-Modified: " + formatDate(-1, TimeUnit.HOURS))
+        .addHeader("Expires: " + formatDate(-2, TimeUnit.HOURS)));
   }
 
   @Test public void requestMaxAge() throws IOException {
@@ -910,7 +956,8 @@ private void assertNonIdentityEncodingCached(MockResponse response) throws Excep
         .addHeader("Last-Modified: " + formatDate(-2, TimeUnit.HOURS))
         .addHeader("Date: " + formatDate(-1, TimeUnit.MINUTES))
         .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS)));
-    server.enqueue(new MockResponse().setBody("B"));
+    server.enqueue(new MockResponse()
+        .setBody("B"));
 
     assertEquals("A", get(server.getUrl("/")).body().string());
 
@@ -927,7 +974,8 @@ private void assertNonIdentityEncodingCached(MockResponse response) throws Excep
         .setBody("A")
         .addHeader("Cache-Control: max-age=60")
         .addHeader("Date: " + formatDate(0, TimeUnit.MINUTES)));
-    server.enqueue(new MockResponse().setBody("B"));
+    server.enqueue(new MockResponse()
+        .setBody("B"));
 
     assertEquals("A", get(server.getUrl("/")).body().string());
 
@@ -958,12 +1006,34 @@ private void assertNonIdentityEncodingCached(MockResponse response) throws Excep
     assertEquals("110 HttpURLConnection \"Response is stale\"", response.header("Warning"));
   }
 
+  @Test public void requestMaxStaleDirectiveWithNoValue() throws IOException {
+    // Add a stale response to the cache.
+    server.enqueue(new MockResponse()
+        .setBody("A")
+        .addHeader("Cache-Control: max-age=120")
+        .addHeader("Date: " + formatDate(-4, TimeUnit.MINUTES)));
+    server.enqueue(new MockResponse()
+        .setBody("B"));
+
+    assertEquals("A", get(server.getUrl("/")).body().string());
+
+    // With max-stale, we'll return that stale response.
+    Request request = new Request.Builder()
+        .url(server.getUrl("/"))
+        .header("Cache-Control", "max-stale")
+        .build();
+    Response response = client.newCall(request).execute();
+    assertEquals("A", response.body().string());
+    assertEquals("110 HttpURLConnection \"Response is stale\"", response.header("Warning"));
+  }
+
   @Test public void requestMaxStaleNotHonoredWithMustRevalidate() throws IOException {
     server.enqueue(new MockResponse()
         .setBody("A")
         .addHeader("Cache-Control: max-age=120, must-revalidate")
         .addHeader("Date: " + formatDate(-4, TimeUnit.MINUTES)));
-    server.enqueue(new MockResponse().setBody("B"));
+    server.enqueue(new MockResponse()
+        .setBody("B"));
 
     assertEquals("A", get(server.getUrl("/")).body().string());
 
@@ -1173,40 +1243,8 @@ private RecordedRequest assertClientSuppliedCondition(MockResponse seed, String
     assertEquals("", response.body().string());
   }
 
-  @Test public void authorizationRequestHeaderPreventsCaching() throws Exception {
+  @Test public void authorizationRequestFullyCached() throws Exception {
     server.enqueue(new MockResponse()
-        .addHeader("Last-Modified: " + formatDate(-2, TimeUnit.MINUTES))
-        .addHeader("Cache-Control: max-age=60")
-        .setBody("A"));
-    server.enqueue(new MockResponse()
-        .setBody("B"));
-
-    URL url = server.getUrl("/");
-    Request request = new Request.Builder()
-        .url(url)
-        .header("Authorization", "password")
-        .build();
-    Response response = client.newCall(request).execute();
-    assertEquals("A", response.body().string());
-    assertEquals("B", get(url).body().string());
-  }
-
-  @Test public void authorizationResponseCachedWithSMaxAge() throws Exception {
-    assertAuthorizationRequestFullyCached(
-        new MockResponse().addHeader("Cache-Control: s-maxage=60"));
-  }
-
-  @Test public void authorizationResponseCachedWithPublic() throws Exception {
-    assertAuthorizationRequestFullyCached(new MockResponse().addHeader("Cache-Control: public"));
-  }
-
-  @Test public void authorizationResponseCachedWithMustRevalidate() throws Exception {
-    assertAuthorizationRequestFullyCached(
-        new MockResponse().addHeader("Cache-Control: must-revalidate"));
-  }
-
-  public void assertAuthorizationRequestFullyCached(MockResponse mockResponse) throws Exception {
-    server.enqueue(mockResponse
         .addHeader("Cache-Control: max-age=60")
         .setBody("A"));
     server.enqueue(new MockResponse()
@@ -1297,7 +1335,8 @@ public void assertAuthorizationRequestFullyCached(MockResponse mockResponse) thr
 
   @Test public void statisticsFullCacheHit() throws Exception {
     server.enqueue(new MockResponse()
-        .addHeader("Cache-Control: max-age=60").setBody("A"));
+        .addHeader("Cache-Control: max-age=60")
+        .setBody("A"));
 
     assertEquals("A", get(server.getUrl("/")).body().string());
     assertEquals(1, cache.getRequestCount());
@@ -1483,7 +1522,8 @@ public void assertAuthorizationRequestFullyCached(MockResponse mockResponse) thr
   }
 
   @Test public void varyMultipleFieldValuesWithMatch() throws Exception {
-    server.enqueue(new MockResponse().addHeader("Cache-Control: max-age=60")
+    server.enqueue(new MockResponse()
+        .addHeader("Cache-Control: max-age=60")
         .addHeader("Vary: Accept-Language")
         .setBody("A"));
     server.enqueue(new MockResponse()
@@ -1508,10 +1548,12 @@ public void assertAuthorizationRequestFullyCached(MockResponse mockResponse) thr
   }
 
   @Test public void varyMultipleFieldValuesWithNoMatch() throws Exception {
-    server.enqueue(new MockResponse().addHeader("Cache-Control: max-age=60")
+    server.enqueue(new MockResponse()
+        .addHeader("Cache-Control: max-age=60")
         .addHeader("Vary: Accept-Language")
         .setBody("A"));
-    server.enqueue(new MockResponse().setBody("B"));
+    server.enqueue(new MockResponse()
+        .setBody("B"));
 
     URL url = server.getUrl("/");
     Request request1 = new Request.Builder()
@@ -1532,8 +1574,10 @@ public void assertAuthorizationRequestFullyCached(MockResponse mockResponse) thr
   }
 
   @Test public void varyAsterisk() throws Exception {
-    server.enqueue(
-        new MockResponse().addHeader("Cache-Control: max-age=60").addHeader("Vary: *").setBody("A"));
+    server.enqueue( new MockResponse()
+        .addHeader("Cache-Control: max-age=60")
+        .addHeader("Vary: *")
+        .setBody("A"));
     server.enqueue(new MockResponse()
         .setBody("B"));
 
@@ -1611,7 +1655,8 @@ public void assertAuthorizationRequestFullyCached(MockResponse mockResponse) thr
         .addHeader("Last-Modified: " + formatDate(-1, TimeUnit.HOURS))
         .addHeader("Cache-Control: max-age=0")
         .setBody("A"));
-    server.enqueue(new MockResponse().addHeader("Transfer-Encoding: none")
+    server.enqueue(new MockResponse()
+        .addHeader("Transfer-Encoding: none")
         .setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
 
     Response response1 = get(server.getUrl("/"));
@@ -1668,7 +1713,8 @@ public void assertCookies(URL url, String... expectedCookies) throws Exception {
   }
 
   @Test public void cachePlusRange() throws Exception {
-    assertNotCached(new MockResponse().setResponseCode(HttpURLConnection.HTTP_PARTIAL)
+    assertNotCached(new MockResponse()
+        .setResponseCode(HttpURLConnection.HTTP_PARTIAL)
         .addHeader("Date: " + formatDate(0, TimeUnit.HOURS))
         .addHeader("Content-Range: bytes 100-100/200")
         .addHeader("Cache-Control: max-age=60"));
@@ -1826,6 +1872,20 @@ public void assertCookies(URL url, String... expectedCookies) throws Exception {
     assertEquals("foo", response.header("etag"));
   }
 
+  @Test public void evictAll() throws Exception {
+    server.enqueue(new MockResponse()
+        .addHeader("Cache-Control: max-age=60")
+        .setBody("A"));
+    server.enqueue(new MockResponse()
+        .setBody("B"));
+
+    URL url = server.getUrl("/");
+    assertEquals("A", get(url).body().string());
+    client.getCache().evictAll();
+    assertEquals(0, client.getCache().getSize());
+    assertEquals("B", get(url).body().string());
+  }
+
   private Response get(URL url) throws IOException {
     Request request = new Request.Builder()
         .url(url)
@@ -1872,9 +1932,11 @@ private RecordedRequest assertConditionallyCached(MockResponse response) throws
         .setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
 
     // scenario 2: condition fails
-    server.enqueue(response.setBody("B").setStatus("HTTP/1.1 200 B-OK"));
+    server.enqueue(response.setBody("B")
+        .setStatus("HTTP/1.1 200 B-OK"));
     server.enqueue(new MockResponse()
-        .setStatus("HTTP/1.1 200 C-OK").setBody("C"));
+        .setStatus("HTTP/1.1 200 C-OK")
+        .setBody("C"));
 
     URL valid = server.getUrl("/valid");
     Response response1 = get(valid);
diff --git a/okhttp-tests/src/test/java/com/squareup/okhttp/CallTest.java b/okhttp-tests/src/test/java/com/squareup/okhttp/CallTest.java
index ae924e42cd..bf2763e9c3 100644
--- a/okhttp-tests/src/test/java/com/squareup/okhttp/CallTest.java
+++ b/okhttp-tests/src/test/java/com/squareup/okhttp/CallTest.java
@@ -1079,8 +1079,10 @@
     server2.enqueue(new MockResponse().setBody("Page 2"));
     server2.play();
 
-    server.enqueue(new MockResponse().setResponseCode(401));
-    server.enqueue(new MockResponse().setResponseCode(302)
+    server.enqueue(new MockResponse()
+        .setResponseCode(401));
+    server.enqueue(new MockResponse()
+        .setResponseCode(302)
         .addHeader("Location: " + server2.getUrl("/b")));
     server.play();
 
@@ -1204,6 +1206,18 @@
     assertEquals(0, server.getRequestCount());
   }
 
+  @Test public void cancelTagImmediatelyAfterEnqueue() throws Exception {
+    server.play();
+    Call call = client.newCall(new Request.Builder()
+        .url(server.getUrl("/a"))
+        .tag("request")
+        .build());
+    call.enqueue(callback);
+    client.cancel("request");
+    assertEquals(0, server.getRequestCount());
+    callback.await(server.getUrl("/a")).assertFailure("Canceled");
+  }
+
   @Test public void cancelBeforeBodyIsRead() throws Exception {
     server.enqueue(new MockResponse().setBody("def").throttleBody(1, 750, TimeUnit.MILLISECONDS));
     server.play();
diff --git a/okhttp-tests/src/test/java/com/squareup/okhttp/DispatcherTest.java b/okhttp-tests/src/test/java/com/squareup/okhttp/DispatcherTest.java
index 68713b9ef2..3d7701f298 100644
--- a/okhttp-tests/src/test/java/com/squareup/okhttp/DispatcherTest.java
+++ b/okhttp-tests/src/test/java/com/squareup/okhttp/DispatcherTest.java
@@ -112,15 +112,6 @@
     executor.assertJobs("http://a/1");
   }
 
-  @Test public void cancelingReadyJobPreventsItFromStarting() throws Exception {
-    dispatcher.setMaxRequestsPerHost(1);
-    client.newCall(newRequest("http://a/1")).enqueue(callback);
-    client.newCall(newRequest("http://a/2", "tag1")).enqueue(callback);
-    dispatcher.cancel("tag1");
-    executor.finishJob("http://a/1");
-    executor.assertJobs();
-  }
-
   @Test public void cancelingRunningJobTakesNoEffectUntilJobFinishes() throws Exception {
     dispatcher.setMaxRequests(1);
     client.newCall(newRequest("http://a/1", "tag1")).enqueue(callback);
diff --git a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/DiskLruCacheTest.java b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/DiskLruCacheTest.java
new file mode 100644
index 0000000000..935a5af136
--- /dev/null
+++ b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/DiskLruCacheTest.java
@@ -0,0 +1,1139 @@
+/*
+ * Copyright (C) 2011 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.okhttp.internal;
+
+import java.io.BufferedReader;
+import java.io.File;
+import java.io.FileReader;
+import java.io.FileWriter;
+import java.io.IOException;
+import java.io.Reader;
+import java.io.StringWriter;
+import java.io.Writer;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.List;
+import okio.BufferedSink;
+import okio.BufferedSource;
+import okio.Okio;
+import okio.Source;
+import org.junit.After;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.rules.TemporaryFolder;
+
+import static com.squareup.okhttp.internal.DiskLruCache.JOURNAL_FILE;
+import static com.squareup.okhttp.internal.DiskLruCache.JOURNAL_FILE_BACKUP;
+import static com.squareup.okhttp.internal.DiskLruCache.MAGIC;
+import static com.squareup.okhttp.internal.DiskLruCache.VERSION_1;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertNull;
+import static org.junit.Assert.assertSame;
+import static org.junit.Assert.assertTrue;
+import static org.junit.Assert.fail;
+
+public final class DiskLruCacheTest {
+  private final int appVersion = 100;
+  private File cacheDir;
+  private File journalFile;
+  private File journalBkpFile;
+  private DiskLruCache cache;
+
+  @Rule public TemporaryFolder tempDir = new TemporaryFolder();
+
+  @Before public void setUp() throws Exception {
+    cacheDir = tempDir.newFolder("DiskLruCacheTest");
+    journalFile = new File(cacheDir, JOURNAL_FILE);
+    journalBkpFile = new File(cacheDir, JOURNAL_FILE_BACKUP);
+    for (File file : cacheDir.listFiles()) {
+      file.delete();
+    }
+    cache = DiskLruCache.open(cacheDir, appVersion, 2, Integer.MAX_VALUE);
+  }
+
+  @After public void tearDown() throws Exception {
+    cache.close();
+  }
+
+  @Test public void emptyCache() throws Exception {
+    cache.close();
+    assertJournalEquals();
+  }
+
+  @Test public void validateKey() throws Exception {
+    String key = null;
+    try {
+      key = "has_space ";
+      cache.edit(key);
+      fail("Exepcting an IllegalArgumentException as the key was invalid.");
+    } catch (IllegalArgumentException iae) {
+      assertEquals("keys must match regex [a-z0-9_-]{1,120}: \"" + key + "\"", iae.getMessage());
+    }
+    try {
+      key = "has_CR\r";
+      cache.edit(key);
+      fail("Exepcting an IllegalArgumentException as the key was invalid.");
+    } catch (IllegalArgumentException iae) {
+      assertEquals("keys must match regex [a-z0-9_-]{1,120}: \"" + key + "\"", iae.getMessage());
+    }
+    try {
+      key = "has_LF\n";
+      cache.edit(key);
+      fail("Exepcting an IllegalArgumentException as the key was invalid.");
+    } catch (IllegalArgumentException iae) {
+      assertEquals("keys must match regex [a-z0-9_-]{1,120}: \"" + key + "\"", iae.getMessage());
+    }
+    try {
+      key = "has_invalid/";
+      cache.edit(key);
+      fail("Exepcting an IllegalArgumentException as the key was invalid.");
+    } catch (IllegalArgumentException iae) {
+      assertEquals("keys must match regex [a-z0-9_-]{1,120}: \"" + key + "\"", iae.getMessage());
+    }
+    try {
+      key = "has_invalid\u2603";
+      cache.edit(key);
+      fail("Exepcting an IllegalArgumentException as the key was invalid.");
+    } catch (IllegalArgumentException iae) {
+      assertEquals("keys must match regex [a-z0-9_-]{1,120}: \"" + key + "\"", iae.getMessage());
+    }
+    try {
+      key = "this_is_way_too_long_this_is_way_too_long_this_is_way_too_long_"
+          + "this_is_way_too_long_this_is_way_too_long_this_is_way_too_long";
+      cache.edit(key);
+      fail("Exepcting an IllegalArgumentException as the key was too long.");
+    } catch (IllegalArgumentException iae) {
+      assertEquals("keys must match regex [a-z0-9_-]{1,120}: \"" + key + "\"", iae.getMessage());
+    }
+
+    // Test valid cases.
+
+    // Exactly 120.
+    key = "0123456789012345678901234567890123456789012345678901234567890123456789"
+        + "01234567890123456789012345678901234567890123456789";
+    cache.edit(key).abort();
+    // Contains all valid characters.
+    key = "abcdefghijklmnopqrstuvwxyz_0123456789";
+    cache.edit(key).abort();
+    // Contains dash.
+    key = "-20384573948576";
+    cache.edit(key).abort();
+  }
+
+  static class X<T> {
+    private T t;
+
+    public X(T t) {
+      this.t = t;
+    }
+  }
+
+  @Test public void writeAndReadEntry() throws Exception {
+    DiskLruCache.Editor creator = cache.edit("k1");
+    creator.set(0, "ABC");
+    creator.set(1, "DE");
+    assertNull(creator.getString(0));
+    assertNull(creator.newSource(0));
+    assertNull(creator.getString(1));
+    assertNull(creator.newSource(1));
+    creator.commit();
+
+    DiskLruCache.Snapshot snapshot = cache.get("k1");
+    assertEquals("ABC", snapshot.getString(0));
+    assertEquals(3, snapshot.getLength(0));
+    assertEquals("DE", snapshot.getString(1));
+    assertEquals(2, snapshot.getLength(1));
+  }
+
+  @Test public void readAndWriteEntryAcrossCacheOpenAndClose() throws Exception {
+    DiskLruCache.Editor creator = cache.edit("k1");
+    creator.set(0, "A");
+    creator.set(1, "B");
+    creator.commit();
+    cache.close();
+
+    cache = DiskLruCache.open(cacheDir, appVersion, 2, Integer.MAX_VALUE);
+    DiskLruCache.Snapshot snapshot = cache.get("k1");
+    assertEquals("A", snapshot.getString(0));
+    assertEquals(1, snapshot.getLength(0));
+    assertEquals("B", snapshot.getString(1));
+    assertEquals(1, snapshot.getLength(1));
+    snapshot.close();
+  }
+
+  @Test public void readAndWriteEntryWithoutProperClose() throws Exception {
+    DiskLruCache.Editor creator = cache.edit("k1");
+    creator.set(0, "A");
+    creator.set(1, "B");
+    creator.commit();
+
+    // Simulate a dirty close of 'cache' by opening the cache directory again.
+    DiskLruCache cache2 = DiskLruCache.open(cacheDir, appVersion, 2, Integer.MAX_VALUE);
+    DiskLruCache.Snapshot snapshot = cache2.get("k1");
+    assertEquals("A", snapshot.getString(0));
+    assertEquals(1, snapshot.getLength(0));
+    assertEquals("B", snapshot.getString(1));
+    assertEquals(1, snapshot.getLength(1));
+    snapshot.close();
+    cache2.close();
+  }
+
+  @Test public void journalWithEditAndPublish() throws Exception {
+    DiskLruCache.Editor creator = cache.edit("k1");
+    assertJournalEquals("DIRTY k1"); // DIRTY must always be flushed.
+    creator.set(0, "AB");
+    creator.set(1, "C");
+    creator.commit();
+    cache.close();
+    assertJournalEquals("DIRTY k1", "CLEAN k1 2 1");
+  }
+
+  @Test public void revertedNewFileIsRemoveInJournal() throws Exception {
+    DiskLruCache.Editor creator = cache.edit("k1");
+    assertJournalEquals("DIRTY k1"); // DIRTY must always be flushed.
+    creator.set(0, "AB");
+    creator.set(1, "C");
+    creator.abort();
+    cache.close();
+    assertJournalEquals("DIRTY k1", "REMOVE k1");
+  }
+
+  @Test public void unterminatedEditIsRevertedOnClose() throws Exception {
+    cache.edit("k1");
+    cache.close();
+    assertJournalEquals("DIRTY k1", "REMOVE k1");
+  }
+
+  @Test public void journalDoesNotIncludeReadOfYetUnpublishedValue() throws Exception {
+    DiskLruCache.Editor creator = cache.edit("k1");
+    assertNull(cache.get("k1"));
+    creator.set(0, "A");
+    creator.set(1, "BC");
+    creator.commit();
+    cache.close();
+    assertJournalEquals("DIRTY k1", "CLEAN k1 1 2");
+  }
+
+  @Test public void journalWithEditAndPublishAndRead() throws Exception {
+    DiskLruCache.Editor k1Creator = cache.edit("k1");
+    k1Creator.set(0, "AB");
+    k1Creator.set(1, "C");
+    k1Creator.commit();
+    DiskLruCache.Editor k2Creator = cache.edit("k2");
+    k2Creator.set(0, "DEF");
+    k2Creator.set(1, "G");
+    k2Creator.commit();
+    DiskLruCache.Snapshot k1Snapshot = cache.get("k1");
+    k1Snapshot.close();
+    cache.close();
+    assertJournalEquals("DIRTY k1", "CLEAN k1 2 1", "DIRTY k2", "CLEAN k2 3 1", "READ k1");
+  }
+
+  @Test public void cannotOperateOnEditAfterPublish() throws Exception {
+    DiskLruCache.Editor editor = cache.edit("k1");
+    editor.set(0, "A");
+    editor.set(1, "B");
+    editor.commit();
+    assertInoperable(editor);
+  }
+
+  @Test public void cannotOperateOnEditAfterRevert() throws Exception {
+    DiskLruCache.Editor editor = cache.edit("k1");
+    editor.set(0, "A");
+    editor.set(1, "B");
+    editor.abort();
+    assertInoperable(editor);
+  }
+
+  @Test public void explicitRemoveAppliedToDiskImmediately() throws Exception {
+    DiskLruCache.Editor editor = cache.edit("k1");
+    editor.set(0, "ABC");
+    editor.set(1, "B");
+    editor.commit();
+    File k1 = getCleanFile("k1", 0);
+    assertEquals("ABC", readFile(k1));
+    cache.remove("k1");
+    assertFalse(k1.exists());
+  }
+
+  @Test public void removePreventsActiveEditFromStoringAValue() throws Exception {
+    set("a", "a", "a");
+    DiskLruCache.Editor a = cache.edit("a");
+    a.set(0, "a1");
+    assertTrue(cache.remove("a"));
+    a.set(1, "a2");
+    a.commit();
+    assertAbsent("a");
+  }
+
+  /**
+   * Each read sees a snapshot of the file at the time read was called.
+   * This means that two reads of the same key can see different data.
+   */
+  @Test public void readAndWriteOverlapsMaintainConsistency() throws Exception {
+    DiskLruCache.Editor v1Creator = cache.edit("k1");
+    v1Creator.set(0, "AAaa");
+    v1Creator.set(1, "BBbb");
+    v1Creator.commit();
+
+    DiskLruCache.Snapshot snapshot1 = cache.get("k1");
+    BufferedSource inV1 = Okio.buffer(snapshot1.getSource(0));
+    assertEquals('A', inV1.readByte());
+    assertEquals('A', inV1.readByte());
+
+    DiskLruCache.Editor v1Updater = cache.edit("k1");
+    v1Updater.set(0, "CCcc");
+    v1Updater.set(1, "DDdd");
+    v1Updater.commit();
+
+    DiskLruCache.Snapshot snapshot2 = cache.get("k1");
+    assertEquals("CCcc", snapshot2.getString(0));
+    assertEquals(4, snapshot2.getLength(0));
+    assertEquals("DDdd", snapshot2.getString(1));
+    assertEquals(4, snapshot2.getLength(1));
+    snapshot2.close();
+
+    assertEquals('a', inV1.readByte());
+    assertEquals('a', inV1.readByte());
+    assertEquals("BBbb", snapshot1.getString(1));
+    assertEquals(4, snapshot1.getLength(1));
+    snapshot1.close();
+  }
+
+  @Test public void openWithDirtyKeyDeletesAllFilesForThatKey() throws Exception {
+    cache.close();
+    File cleanFile0 = getCleanFile("k1", 0);
+    File cleanFile1 = getCleanFile("k1", 1);
+    File dirtyFile0 = getDirtyFile("k1", 0);
+    File dirtyFile1 = getDirtyFile("k1", 1);
+    writeFile(cleanFile0, "A");
+    writeFile(cleanFile1, "B");
+    writeFile(dirtyFile0, "C");
+    writeFile(dirtyFile1, "D");
+    createJournal("CLEAN k1 1 1", "DIRTY   k1");
+    cache = DiskLruCache.open(cacheDir, appVersion, 2, Integer.MAX_VALUE);
+    assertFalse(cleanFile0.exists());
+    assertFalse(cleanFile1.exists());
+    assertFalse(dirtyFile0.exists());
+    assertFalse(dirtyFile1.exists());
+    assertNull(cache.get("k1"));
+  }
+
+  @Test public void openWithInvalidVersionClearsDirectory() throws Exception {
+    cache.close();
+    generateSomeGarbageFiles();
+    createJournalWithHeader(MAGIC, "0", "100", "2", "");
+    cache = DiskLruCache.open(cacheDir, appVersion, 2, Integer.MAX_VALUE);
+    assertGarbageFilesAllDeleted();
+  }
+
+  @Test public void openWithInvalidAppVersionClearsDirectory() throws Exception {
+    cache.close();
+    generateSomeGarbageFiles();
+    createJournalWithHeader(MAGIC, "1", "101", "2", "");
+    cache = DiskLruCache.open(cacheDir, appVersion, 2, Integer.MAX_VALUE);
+    assertGarbageFilesAllDeleted();
+  }
+
+  @Test public void openWithInvalidValueCountClearsDirectory() throws Exception {
+    cache.close();
+    generateSomeGarbageFiles();
+    createJournalWithHeader(MAGIC, "1", "100", "1", "");
+    cache = DiskLruCache.open(cacheDir, appVersion, 2, Integer.MAX_VALUE);
+    assertGarbageFilesAllDeleted();
+  }
+
+  @Test public void openWithInvalidBlankLineClearsDirectory() throws Exception {
+    cache.close();
+    generateSomeGarbageFiles();
+    createJournalWithHeader(MAGIC, "1", "100", "2", "x");
+    cache = DiskLruCache.open(cacheDir, appVersion, 2, Integer.MAX_VALUE);
+    assertGarbageFilesAllDeleted();
+  }
+
+  @Test public void openWithInvalidJournalLineClearsDirectory() throws Exception {
+    cache.close();
+    generateSomeGarbageFiles();
+    createJournal("CLEAN k1 1 1", "BOGUS");
+    cache = DiskLruCache.open(cacheDir, appVersion, 2, Integer.MAX_VALUE);
+    assertGarbageFilesAllDeleted();
+    assertNull(cache.get("k1"));
+  }
+
+  @Test public void openWithInvalidFileSizeClearsDirectory() throws Exception {
+    cache.close();
+    generateSomeGarbageFiles();
+    createJournal("CLEAN k1 0000x001 1");
+    cache = DiskLruCache.open(cacheDir, appVersion, 2, Integer.MAX_VALUE);
+    assertGarbageFilesAllDeleted();
+    assertNull(cache.get("k1"));
+  }
+
+  @Test public void openWithTruncatedLineDiscardsThatLine() throws Exception {
+    cache.close();
+    writeFile(getCleanFile("k1", 0), "A");
+    writeFile(getCleanFile("k1", 1), "B");
+    Writer writer = new FileWriter(journalFile);
+    writer.write(MAGIC + "\n" + VERSION_1 + "\n100\n2\n\nCLEAN k1 1 1"); // no trailing newline
+    writer.close();
+    cache = DiskLruCache.open(cacheDir, appVersion, 2, Integer.MAX_VALUE);
+    assertNull(cache.get("k1"));
+
+    // The journal is not corrupt when editing after a truncated line.
+    set("k1", "C", "D");
+    cache.close();
+    cache = DiskLruCache.open(cacheDir, appVersion, 2, Integer.MAX_VALUE);
+    assertValue("k1", "C", "D");
+  }
+
+  @Test public void openWithTooManyFileSizesClearsDirectory() throws Exception {
+    cache.close();
+    generateSomeGarbageFiles();
+    createJournal("CLEAN k1 1 1 1");
+    cache = DiskLruCache.open(cacheDir, appVersion, 2, Integer.MAX_VALUE);
+    assertGarbageFilesAllDeleted();
+    assertNull(cache.get("k1"));
+  }
+
+  @Test public void keyWithSpaceNotPermitted() throws Exception {
+    try {
+      cache.edit("my key");
+      fail();
+    } catch (IllegalArgumentException expected) {
+    }
+  }
+
+  @Test public void keyWithNewlineNotPermitted() throws Exception {
+    try {
+      cache.edit("my\nkey");
+      fail();
+    } catch (IllegalArgumentException expected) {
+    }
+  }
+
+  @Test public void keyWithCarriageReturnNotPermitted() throws Exception {
+    try {
+      cache.edit("my\rkey");
+      fail();
+    } catch (IllegalArgumentException expected) {
+    }
+  }
+
+  @Test public void nullKeyThrows() throws Exception {
+    try {
+      cache.edit(null);
+      fail();
+    } catch (NullPointerException expected) {
+    }
+  }
+
+  @Test public void createNewEntryWithTooFewValuesFails() throws Exception {
+    DiskLruCache.Editor creator = cache.edit("k1");
+    creator.set(1, "A");
+    try {
+      creator.commit();
+      fail();
+    } catch (IllegalStateException expected) {
+    }
+
+    assertFalse(getCleanFile("k1", 0).exists());
+    assertFalse(getCleanFile("k1", 1).exists());
+    assertFalse(getDirtyFile("k1", 0).exists());
+    assertFalse(getDirtyFile("k1", 1).exists());
+    assertNull(cache.get("k1"));
+
+    DiskLruCache.Editor creator2 = cache.edit("k1");
+    creator2.set(0, "B");
+    creator2.set(1, "C");
+    creator2.commit();
+  }
+
+  @Test public void revertWithTooFewValues() throws Exception {
+    DiskLruCache.Editor creator = cache.edit("k1");
+    creator.set(1, "A");
+    creator.abort();
+    assertFalse(getCleanFile("k1", 0).exists());
+    assertFalse(getCleanFile("k1", 1).exists());
+    assertFalse(getDirtyFile("k1", 0).exists());
+    assertFalse(getDirtyFile("k1", 1).exists());
+    assertNull(cache.get("k1"));
+  }
+
+  @Test public void updateExistingEntryWithTooFewValuesReusesPreviousValues() throws Exception {
+    DiskLruCache.Editor creator = cache.edit("k1");
+    creator.set(0, "A");
+    creator.set(1, "B");
+    creator.commit();
+
+    DiskLruCache.Editor updater = cache.edit("k1");
+    updater.set(0, "C");
+    updater.commit();
+
+    DiskLruCache.Snapshot snapshot = cache.get("k1");
+    assertEquals("C", snapshot.getString(0));
+    assertEquals(1, snapshot.getLength(0));
+    assertEquals("B", snapshot.getString(1));
+    assertEquals(1, snapshot.getLength(1));
+    snapshot.close();
+  }
+
+  @Test public void growMaxSize() throws Exception {
+    cache.close();
+    cache = DiskLruCache.open(cacheDir, appVersion, 2, 10);
+    set("a", "a", "aaa"); // size 4
+    set("b", "bb", "bbbb"); // size 6
+    cache.setMaxSize(20);
+    set("c", "c", "c"); // size 12
+    assertEquals(12, cache.size());
+  }
+
+  @Test public void shrinkMaxSizeEvicts() throws Exception {
+    cache.close();
+    cache = DiskLruCache.open(cacheDir, appVersion, 2, 20);
+    set("a", "a", "aaa"); // size 4
+    set("b", "bb", "bbbb"); // size 6
+    set("c", "c", "c"); // size 12
+    cache.setMaxSize(10);
+    assertEquals(1, cache.executorService.getQueue().size());
+    cache.executorService.purge();
+  }
+
+  @Test public void evictOnInsert() throws Exception {
+    cache.close();
+    cache = DiskLruCache.open(cacheDir, appVersion, 2, 10);
+
+    set("a", "a", "aaa"); // size 4
+    set("b", "bb", "bbbb"); // size 6
+    assertEquals(10, cache.size());
+
+    // Cause the size to grow to 12 should evict 'A'.
+    set("c", "c", "c");
+    cache.flush();
+    assertEquals(8, cache.size());
+    assertAbsent("a");
+    assertValue("b", "bb", "bbbb");
+    assertValue("c", "c", "c");
+
+    // Causing the size to grow to 10 should evict nothing.
+    set("d", "d", "d");
+    cache.flush();
+    assertEquals(10, cache.size());
+    assertAbsent("a");
+    assertValue("b", "bb", "bbbb");
+    assertValue("c", "c", "c");
+    assertValue("d", "d", "d");
+
+    // Causing the size to grow to 18 should evict 'B' and 'C'.
+    set("e", "eeee", "eeee");
+    cache.flush();
+    assertEquals(10, cache.size());
+    assertAbsent("a");
+    assertAbsent("b");
+    assertAbsent("c");
+    assertValue("d", "d", "d");
+    assertValue("e", "eeee", "eeee");
+  }
+
+  @Test public void evictOnUpdate() throws Exception {
+    cache.close();
+    cache = DiskLruCache.open(cacheDir, appVersion, 2, 10);
+
+    set("a", "a", "aa"); // size 3
+    set("b", "b", "bb"); // size 3
+    set("c", "c", "cc"); // size 3
+    assertEquals(9, cache.size());
+
+    // Causing the size to grow to 11 should evict 'A'.
+    set("b", "b", "bbbb");
+    cache.flush();
+    assertEquals(8, cache.size());
+    assertAbsent("a");
+    assertValue("b", "b", "bbbb");
+    assertValue("c", "c", "cc");
+  }
+
+  @Test public void evictionHonorsLruFromCurrentSession() throws Exception {
+    cache.close();
+    cache = DiskLruCache.open(cacheDir, appVersion, 2, 10);
+    set("a", "a", "a");
+    set("b", "b", "b");
+    set("c", "c", "c");
+    set("d", "d", "d");
+    set("e", "e", "e");
+    cache.get("b").close(); // 'B' is now least recently used.
+
+    // Causing the size to grow to 12 should evict 'A'.
+    set("f", "f", "f");
+    // Causing the size to grow to 12 should evict 'C'.
+    set("g", "g", "g");
+    cache.flush();
+    assertEquals(10, cache.size());
+    assertAbsent("a");
+    assertValue("b", "b", "b");
+    assertAbsent("c");
+    assertValue("d", "d", "d");
+    assertValue("e", "e", "e");
+    assertValue("f", "f", "f");
+  }
+
+  @Test public void evictionHonorsLruFromPreviousSession() throws Exception {
+    set("a", "a", "a");
+    set("b", "b", "b");
+    set("c", "c", "c");
+    set("d", "d", "d");
+    set("e", "e", "e");
+    set("f", "f", "f");
+    cache.get("b").close(); // 'B' is now least recently used.
+    assertEquals(12, cache.size());
+    cache.close();
+    cache = DiskLruCache.open(cacheDir, appVersion, 2, 10);
+
+    set("g", "g", "g");
+    cache.flush();
+    assertEquals(10, cache.size());
+    assertAbsent("a");
+    assertValue("b", "b", "b");
+    assertAbsent("c");
+    assertValue("d", "d", "d");
+    assertValue("e", "e", "e");
+    assertValue("f", "f", "f");
+    assertValue("g", "g", "g");
+  }
+
+  @Test public void cacheSingleEntryOfSizeGreaterThanMaxSize() throws Exception {
+    cache.close();
+    cache = DiskLruCache.open(cacheDir, appVersion, 2, 10);
+    set("a", "aaaaa", "aaaaaa"); // size=11
+    cache.flush();
+    assertAbsent("a");
+  }
+
+  @Test public void cacheSingleValueOfSizeGreaterThanMaxSize() throws Exception {
+    cache.close();
+    cache = DiskLruCache.open(cacheDir, appVersion, 2, 10);
+    set("a", "aaaaaaaaaaa", "a"); // size=12
+    cache.flush();
+    assertAbsent("a");
+  }
+
+  @Test public void constructorDoesNotAllowZeroCacheSize() throws Exception {
+    try {
+      DiskLruCache.open(cacheDir, appVersion, 2, 0);
+      fail();
+    } catch (IllegalArgumentException expected) {
+    }
+  }
+
+  @Test public void constructorDoesNotAllowZeroValuesPerEntry() throws Exception {
+    try {
+      DiskLruCache.open(cacheDir, appVersion, 0, 10);
+      fail();
+    } catch (IllegalArgumentException expected) {
+    }
+  }
+
+  @Test public void removeAbsentElement() throws Exception {
+    cache.remove("a");
+  }
+
+  @Test public void readingTheSameStreamMultipleTimes() throws Exception {
+    set("a", "a", "b");
+    DiskLruCache.Snapshot snapshot = cache.get("a");
+    assertSame(snapshot.getSource(0), snapshot.getSource(0));
+    snapshot.close();
+  }
+
+  @Test public void rebuildJournalOnRepeatedReads() throws Exception {
+    set("a", "a", "a");
+    set("b", "b", "b");
+    long lastJournalLength = 0;
+    while (true) {
+      long journalLength = journalFile.length();
+      assertValue("a", "a", "a");
+      assertValue("b", "b", "b");
+      if (journalLength < lastJournalLength) {
+        System.out
+            .printf("Journal compacted from %s bytes to %s bytes\n", lastJournalLength,
+                journalLength);
+        break; // Test passed!
+      }
+      lastJournalLength = journalLength;
+    }
+  }
+
+  @Test public void rebuildJournalOnRepeatedEdits() throws Exception {
+    long lastJournalLength = 0;
+    while (true) {
+      long journalLength = journalFile.length();
+      set("a", "a", "a");
+      set("b", "b", "b");
+      if (journalLength < lastJournalLength) {
+        System.out
+            .printf("Journal compacted from %s bytes to %s bytes\n", lastJournalLength,
+                journalLength);
+        break;
+      }
+      lastJournalLength = journalLength;
+    }
+
+    // Sanity check that a rebuilt journal behaves normally.
+    assertValue("a", "a", "a");
+    assertValue("b", "b", "b");
+  }
+
+  /** @see <a href="https://github.com/JakeWharton/DiskLruCache/issues/28">Issue #28</a> */
+  @Test public void rebuildJournalOnRepeatedReadsWithOpenAndClose() throws Exception {
+    set("a", "a", "a");
+    set("b", "b", "b");
+    long lastJournalLength = 0;
+    while (true) {
+      long journalLength = journalFile.length();
+      assertValue("a", "a", "a");
+      assertValue("b", "b", "b");
+      cache.close();
+      cache = DiskLruCache.open(cacheDir, appVersion, 2, Integer.MAX_VALUE);
+      if (journalLength < lastJournalLength) {
+        System.out
+            .printf("Journal compacted from %s bytes to %s bytes\n", lastJournalLength,
+                journalLength);
+        break; // Test passed!
+      }
+      lastJournalLength = journalLength;
+    }
+  }
+
+  /** @see <a href="https://github.com/JakeWharton/DiskLruCache/issues/28">Issue #28</a> */
+  @Test public void rebuildJournalOnRepeatedEditsWithOpenAndClose() throws Exception {
+    long lastJournalLength = 0;
+    while (true) {
+      long journalLength = journalFile.length();
+      set("a", "a", "a");
+      set("b", "b", "b");
+      cache.close();
+      cache = DiskLruCache.open(cacheDir, appVersion, 2, Integer.MAX_VALUE);
+      if (journalLength < lastJournalLength) {
+        System.out
+            .printf("Journal compacted from %s bytes to %s bytes\n", lastJournalLength,
+                journalLength);
+        break;
+      }
+      lastJournalLength = journalLength;
+    }
+  }
+
+  @Test public void restoreBackupFile() throws Exception {
+    DiskLruCache.Editor creator = cache.edit("k1");
+    creator.set(0, "ABC");
+    creator.set(1, "DE");
+    creator.commit();
+    cache.close();
+
+    assertTrue(journalFile.renameTo(journalBkpFile));
+    assertFalse(journalFile.exists());
+
+    cache = DiskLruCache.open(cacheDir, appVersion, 2, Integer.MAX_VALUE);
+
+    DiskLruCache.Snapshot snapshot = cache.get("k1");
+    assertEquals("ABC", snapshot.getString(0));
+    assertEquals(3, snapshot.getLength(0));
+    assertEquals("DE", snapshot.getString(1));
+    assertEquals(2, snapshot.getLength(1));
+
+    assertFalse(journalBkpFile.exists());
+    assertTrue(journalFile.exists());
+  }
+
+  @Test public void journalFileIsPreferredOverBackupFile() throws Exception {
+    DiskLruCache.Editor creator = cache.edit("k1");
+    creator.set(0, "ABC");
+    creator.set(1, "DE");
+    creator.commit();
+    cache.flush();
+
+    copyFile(journalFile, journalBkpFile);
+
+    creator = cache.edit("k2");
+    creator.set(0, "F");
+    creator.set(1, "GH");
+    creator.commit();
+    cache.close();
+
+    assertTrue(journalFile.exists());
+    assertTrue(journalBkpFile.exists());
+
+    cache = DiskLruCache.open(cacheDir, appVersion, 2, Integer.MAX_VALUE);
+
+    DiskLruCache.Snapshot snapshotA = cache.get("k1");
+    assertEquals("ABC", snapshotA.getString(0));
+    assertEquals(3, snapshotA.getLength(0));
+    assertEquals("DE", snapshotA.getString(1));
+    assertEquals(2, snapshotA.getLength(1));
+
+    DiskLruCache.Snapshot snapshotB = cache.get("k2");
+    assertEquals("F", snapshotB.getString(0));
+    assertEquals(1, snapshotB.getLength(0));
+    assertEquals("GH", snapshotB.getString(1));
+    assertEquals(2, snapshotB.getLength(1));
+
+    assertFalse(journalBkpFile.exists());
+    assertTrue(journalFile.exists());
+  }
+
+  @Test public void openCreatesDirectoryIfNecessary() throws Exception {
+    cache.close();
+    File dir = tempDir.newFolder("testOpenCreatesDirectoryIfNecessary");
+    cache = DiskLruCache.open(dir, appVersion, 2, Integer.MAX_VALUE);
+    set("a", "a", "a");
+    assertTrue(new File(dir, "a.0").exists());
+    assertTrue(new File(dir, "a.1").exists());
+    assertTrue(new File(dir, "journal").exists());
+  }
+
+  @Test public void fileDeletedExternally() throws Exception {
+    set("a", "a", "a");
+    getCleanFile("a", 1).delete();
+    assertNull(cache.get("a"));
+  }
+
+  @Test public void editSameVersion() throws Exception {
+    set("a", "a", "a");
+    DiskLruCache.Snapshot snapshot = cache.get("a");
+    DiskLruCache.Editor editor = snapshot.edit();
+    editor.set(1, "a2");
+    editor.commit();
+    assertValue("a", "a", "a2");
+  }
+
+  @Test public void editSnapshotAfterChangeAborted() throws Exception {
+    set("a", "a", "a");
+    DiskLruCache.Snapshot snapshot = cache.get("a");
+    DiskLruCache.Editor toAbort = snapshot.edit();
+    toAbort.set(0, "b");
+    toAbort.abort();
+    DiskLruCache.Editor editor = snapshot.edit();
+    editor.set(1, "a2");
+    editor.commit();
+    assertValue("a", "a", "a2");
+  }
+
+  @Test public void editSnapshotAfterChangeCommitted() throws Exception {
+    set("a", "a", "a");
+    DiskLruCache.Snapshot snapshot = cache.get("a");
+    DiskLruCache.Editor toAbort = snapshot.edit();
+    toAbort.set(0, "b");
+    toAbort.commit();
+    assertNull(snapshot.edit());
+  }
+
+  @Test public void editSinceEvicted() throws Exception {
+    cache.close();
+    cache = DiskLruCache.open(cacheDir, appVersion, 2, 10);
+    set("a", "aa", "aaa"); // size 5
+    DiskLruCache.Snapshot snapshot = cache.get("a");
+    set("b", "bb", "bbb"); // size 5
+    set("c", "cc", "ccc"); // size 5; will evict 'A'
+    cache.flush();
+    assertNull(snapshot.edit());
+  }
+
+  @Test public void editSinceEvictedAndRecreated() throws Exception {
+    cache.close();
+    cache = DiskLruCache.open(cacheDir, appVersion, 2, 10);
+    set("a", "aa", "aaa"); // size 5
+    DiskLruCache.Snapshot snapshot = cache.get("a");
+    set("b", "bb", "bbb"); // size 5
+    set("c", "cc", "ccc"); // size 5; will evict 'A'
+    set("a", "a", "aaaa"); // size 5; will evict 'B'
+    cache.flush();
+    assertNull(snapshot.edit());
+  }
+
+  /** @see <a href="https://github.com/JakeWharton/DiskLruCache/issues/2">Issue #2</a> */
+  @Test public void aggressiveClearingHandlesWrite() throws Exception {
+    tempDir.delete();
+    set("a", "a", "a");
+    assertValue("a", "a", "a");
+  }
+
+  /** @see <a href="https://github.com/JakeWharton/DiskLruCache/issues/2">Issue #2</a> */
+  @Test public void aggressiveClearingHandlesEdit() throws Exception {
+    set("a", "a", "a");
+    DiskLruCache.Editor a = cache.get("a").edit();
+    tempDir.delete();
+    a.set(1, "a2");
+    a.commit();
+  }
+
+  @Test public void removeHandlesMissingFile() throws Exception {
+    set("a", "a", "a");
+    getCleanFile("a", 0).delete();
+    cache.remove("a");
+  }
+
+  /** @see <a href="https://github.com/JakeWharton/DiskLruCache/issues/2">Issue #2</a> */
+  @Test public void aggressiveClearingHandlesPartialEdit() throws Exception {
+    set("a", "a", "a");
+    set("b", "b", "b");
+    DiskLruCache.Editor a = cache.get("a").edit();
+    a.set(0, "a1");
+    tempDir.delete();
+    a.set(1, "a2");
+    a.commit();
+    assertNull(cache.get("a"));
+  }
+
+  /** @see <a href="https://github.com/JakeWharton/DiskLruCache/issues/2">Issue #2</a> */
+  @Test public void aggressiveClearingHandlesRead() throws Exception {
+    tempDir.delete();
+    assertNull(cache.get("a"));
+  }
+
+  /**
+   * We had a long-lived bug where {@link DiskLruCache#trimToSize} could
+   * infinite loop if entries being edited required deletion for the operation
+   * to complete.
+   */
+  @Test public void trimToSizeWithActiveEdit() throws Exception {
+    set("a", "a1234", "a1234");
+    DiskLruCache.Editor a = cache.edit("a");
+    a.set(0, "a123");
+
+    cache.setMaxSize(8); // Smaller than the sum of active edits!
+    cache.flush(); // Force trimToSize().
+    assertEquals(0, cache.size());
+    assertNull(cache.get("a"));
+
+    // After the edit is completed, its entry is still gone.
+    a.set(1, "a1");
+    a.commit();
+    assertAbsent("a");
+    assertEquals(0, cache.size());
+  }
+
+  @Test public void evictAll() throws Exception {
+    set("a", "a", "a");
+    set("b", "b", "b");
+    cache.evictAll();
+    assertEquals(0, cache.size());
+    assertAbsent("a");
+    assertAbsent("b");
+  }
+
+  @Test public void evictAllWithPartialCreate() throws Exception {
+    DiskLruCache.Editor a = cache.edit("a");
+    a.set(0, "a1");
+    a.set(1, "a2");
+    cache.evictAll();
+    assertEquals(0, cache.size());
+    a.commit();
+    assertAbsent("a");
+  }
+
+  @Test public void evictAllWithPartialEditDoesNotStoreAValue() throws Exception {
+    set("a", "a", "a");
+    DiskLruCache.Editor a = cache.edit("a");
+    a.set(0, "a1");
+    a.set(1, "a2");
+    cache.evictAll();
+    assertEquals(0, cache.size());
+    a.commit();
+    assertAbsent("a");
+  }
+
+  @Test public void evictAllDoesntInterruptPartialRead() throws Exception {
+    set("a", "a", "a");
+    DiskLruCache.Snapshot a = cache.get("a");
+    assertEquals("a", a.getString(0));
+    cache.evictAll();
+    assertEquals(0, cache.size());
+    assertAbsent("a");
+    assertEquals("a", a.getString(1));
+    a.close();
+  }
+
+  @Test public void editSnapshotAfterEvictAllReturnsNullDueToStaleValue() throws Exception {
+    set("a", "a", "a");
+    DiskLruCache.Snapshot a = cache.get("a");
+    cache.evictAll();
+    assertEquals(0, cache.size());
+    assertAbsent("a");
+    assertNull(a.edit());
+    a.close();
+  }
+
+  private void assertJournalEquals(String... expectedBodyLines) throws Exception {
+    List<String> expectedLines = new ArrayList<>();
+    expectedLines.add(MAGIC);
+    expectedLines.add(VERSION_1);
+    expectedLines.add("100");
+    expectedLines.add("2");
+    expectedLines.add("");
+    expectedLines.addAll(Arrays.asList(expectedBodyLines));
+    assertEquals(expectedLines, readJournalLines());
+  }
+
+  private void createJournal(String... bodyLines) throws Exception {
+    createJournalWithHeader(MAGIC, VERSION_1, "100", "2", "", bodyLines);
+  }
+
+  private void createJournalWithHeader(String magic, String version, String appVersion,
+      String valueCount, String blank, String... bodyLines) throws Exception {
+    Writer writer = new FileWriter(journalFile);
+    writer.write(magic + "\n");
+    writer.write(version + "\n");
+    writer.write(appVersion + "\n");
+    writer.write(valueCount + "\n");
+    writer.write(blank + "\n");
+    for (String line : bodyLines) {
+      writer.write(line);
+      writer.write('\n');
+    }
+    writer.close();
+  }
+
+  private List<String> readJournalLines() throws Exception {
+    List<String> result = new ArrayList<>();
+    BufferedReader reader = new BufferedReader(new FileReader(journalFile));
+    String line;
+    while ((line = reader.readLine()) != null) {
+      result.add(line);
+    }
+    reader.close();
+    return result;
+  }
+
+  private File getCleanFile(String key, int index) {
+    return new File(cacheDir, key + "." + index);
+  }
+
+  private File getDirtyFile(String key, int index) {
+    return new File(cacheDir, key + "." + index + ".tmp");
+  }
+
+  private static String readFile(File file) throws Exception {
+    Reader reader = new FileReader(file);
+    StringWriter writer = new StringWriter();
+    char[] buffer = new char[1024];
+    int count;
+    while ((count = reader.read(buffer)) != -1) {
+      writer.write(buffer, 0, count);
+    }
+    reader.close();
+    return writer.toString();
+  }
+
+  public static void writeFile(File file, String content) throws Exception {
+    FileWriter writer = new FileWriter(file);
+    writer.write(content);
+    writer.close();
+  }
+
+  private static void assertInoperable(DiskLruCache.Editor editor) throws Exception {
+    try {
+      editor.getString(0);
+      fail();
+    } catch (IllegalStateException expected) {
+    }
+    try {
+      editor.set(0, "A");
+      fail();
+    } catch (IllegalStateException expected) {
+    }
+    try {
+      editor.newSource(0);
+      fail();
+    } catch (IllegalStateException expected) {
+    }
+    try {
+      editor.newSink(0);
+      fail();
+    } catch (IllegalStateException expected) {
+    }
+    try {
+      editor.commit();
+      fail();
+    } catch (IllegalStateException expected) {
+    }
+    try {
+      editor.abort();
+      fail();
+    } catch (IllegalStateException expected) {
+    }
+  }
+
+  private void generateSomeGarbageFiles() throws Exception {
+    File dir1 = new File(cacheDir, "dir1");
+    File dir2 = new File(dir1, "dir2");
+    writeFile(getCleanFile("g1", 0), "A");
+    writeFile(getCleanFile("g1", 1), "B");
+    writeFile(getCleanFile("g2", 0), "C");
+    writeFile(getCleanFile("g2", 1), "D");
+    writeFile(getCleanFile("g2", 1), "D");
+    writeFile(new File(cacheDir, "otherFile0"), "E");
+    dir1.mkdir();
+    dir2.mkdir();
+    writeFile(new File(dir2, "otherFile1"), "F");
+  }
+
+  private void assertGarbageFilesAllDeleted() throws Exception {
+    assertFalse((getCleanFile("g1", 0)).exists());
+    assertFalse((getCleanFile("g1", 1)).exists());
+    assertFalse((getCleanFile("g2", 0)).exists());
+    assertFalse((getCleanFile("g2", 1)).exists());
+    assertFalse((new File(cacheDir, "otherFile0")).exists());
+    assertFalse((new File(cacheDir, "dir1")).exists());
+  }
+
+  private void set(String key, String value0, String value1) throws Exception {
+    DiskLruCache.Editor editor = cache.edit(key);
+    editor.set(0, value0);
+    editor.set(1, value1);
+    editor.commit();
+  }
+
+  private void assertAbsent(String key) throws Exception {
+    DiskLruCache.Snapshot snapshot = cache.get(key);
+    if (snapshot != null) {
+      snapshot.close();
+      fail();
+    }
+    assertFalse((getCleanFile(key, 0)).exists());
+    assertFalse((getCleanFile(key, 1)).exists());
+    assertFalse((getDirtyFile(key, 0)).exists());
+    assertFalse((getDirtyFile(key, 1)).exists());
+  }
+
+  private void assertValue(String key, String value0, String value1) throws Exception {
+    DiskLruCache.Snapshot snapshot = cache.get(key);
+    assertEquals(value0, snapshot.getString(0));
+    assertEquals(value0.length(), snapshot.getLength(0));
+    assertEquals(value1, snapshot.getString(1));
+    assertEquals(value1.length(), snapshot.getLength(1));
+    assertTrue((getCleanFile(key, 0)).exists());
+    assertTrue((getCleanFile(key, 1)).exists());
+    snapshot.close();
+  }
+
+  private void copyFile(File from, File to) throws IOException {
+    Source source = Okio.source(from);
+    BufferedSink sink = Okio.buffer(Okio.sink(to));
+    sink.writeAll(source);
+    source.close();
+    sink.close();
+  }
+}
diff --git a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/HttpOverHttp20Draft14Test.java b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/HttpOverHttp20Draft14Test.java
index 261fb30f3b..5a9650e3d9 100644
--- a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/HttpOverHttp20Draft14Test.java
+++ b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/HttpOverHttp20Draft14Test.java
@@ -46,7 +46,8 @@ public HttpOverHttp20Draft14Test() {
     RecordedRequest request = server.takeRequest();
     assertEquals("GET /foo HTTP/1.1", request.getRequestLine());
     assertContains(request.getHeaders(), ":scheme: https");
-    assertContains(request.getHeaders(), hostHeader + ": " + hostName + ":" + server.getPort());
+    assertContains(request.getHeaders(), hostHeader + ": "
+        + server.getHostName() + ":" + server.getPort());
 
     RecordedRequest pushedRequest = server.takeRequest();
     assertEquals("GET /foo/bar HTTP/1.1", pushedRequest.getRequestLine());
@@ -68,7 +69,8 @@ public HttpOverHttp20Draft14Test() {
     RecordedRequest request = server.takeRequest();
     assertEquals("GET /foo HTTP/1.1", request.getRequestLine());
     assertContains(request.getHeaders(), ":scheme: https");
-    assertContains(request.getHeaders(), hostHeader + ": " + hostName + ":" + server.getPort());
+    assertContains(request.getHeaders(), hostHeader + ": "
+        + server.getHostName() + ":" + server.getPort());
 
     RecordedRequest pushedRequest = server.takeRequest();
     assertEquals("HEAD /foo/bar HTTP/1.1", pushedRequest.getRequestLine());
diff --git a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/HttpOverSpdyTest.java b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/HttpOverSpdyTest.java
index f65d141bca..04e101dd86 100644
--- a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/HttpOverSpdyTest.java
+++ b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/HttpOverSpdyTest.java
@@ -80,7 +80,6 @@ public boolean verify(String hostname, SSLSession session) {
 
   private static final SSLContext sslContext = SslContextBuilder.localhost();
   protected final MockWebServer server = new MockWebServer();
-  protected final String hostName = server.getHostName();
   protected final OkUrlFactory client = new OkUrlFactory(new OkHttpClient());
   protected HttpURLConnection connection;
   protected Cache cache;
@@ -113,7 +112,8 @@ public boolean verify(String hostname, SSLSession session) {
     RecordedRequest request = server.takeRequest();
     assertEquals("GET /foo HTTP/1.1", request.getRequestLine());
     assertContains(request.getHeaders(), ":scheme: https");
-    assertContains(request.getHeaders(), hostHeader + ": " + hostName + ":" + server.getPort());
+    assertContains(request.getHeaders(), hostHeader + ": "
+        + server.getHostName() + ":" + server.getPort());
   }
 
   @Test public void emptyResponse() throws IOException {
@@ -406,11 +406,12 @@ public boolean verify(String hostname, SSLSession session) {
   @Test public void acceptAndTransmitCookies() throws Exception {
     CookieManager cookieManager = new CookieManager();
     client.client().setCookieHandler(cookieManager);
-    server.enqueue(
-        new MockResponse().addHeader("set-cookie: c=oreo; domain=" + server.getCookieDomain())
-            .setBody("A"));
-    server.enqueue(new MockResponse().setBody("B"));
     server.play();
+    server.enqueue(new MockResponse()
+        .addHeader("set-cookie: c=oreo; domain=" + server.getCookieDomain())
+        .setBody("A"));
+    server.enqueue(new MockResponse()
+        .setBody("B"));
 
     URL url = server.getUrl("/");
     assertContent("A", client.open(url), Integer.MAX_VALUE);
diff --git a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/URLConnectionTest.java b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/URLConnectionTest.java
index 3671a7e76e..586e1add51 100644
--- a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/URLConnectionTest.java
+++ b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/URLConnectionTest.java
@@ -112,10 +112,8 @@
   private final OkUrlFactory client = new OkUrlFactory(new OkHttpClient());
   private HttpURLConnection connection;
   private Cache cache;
-  private String hostName;
 
   @Before public void setUp() throws Exception {
-    hostName = server.getHostName();
     server.setProtocolNegotiationEnabled(false);
   }
 
@@ -1892,8 +1890,8 @@ private void redirectToAnotherOriginServer(boolean https) throws Exception {
     assertContent("This is the first server again!", client.open(server.getUrl("/")));
     assertContent("This is the 2nd server, again!", client.open(server2.getUrl("/")));
 
-    String server1Host = hostName + ":" + server.getPort();
-    String server2Host = hostName + ":" + server2.getPort();
+    String server1Host = server.getHostName() + ":" + server.getPort();
+    String server2Host = server2.getHostName() + ":" + server2.getPort();
     assertContains(server.takeRequest().getHeaders(), "Host: " + server1Host);
     assertContains(server2.takeRequest().getHeaders(), "Host: " + server2Host);
     assertEquals("Expected connection reuse", 1, server.takeRequest().getSequenceNumber());
@@ -2173,8 +2171,10 @@ private void testRedirect(boolean temporary, String method) throws Exception {
     assertContent("DEF", client.open(url));
     assertContent("GHI", client.open(url));
 
-    assertEquals(Arrays.asList("verify " + hostName), hostnameVerifier.calls);
-    assertEquals(Arrays.asList("checkServerTrusted [CN=" + hostName + " 1]"), trustManager.calls);
+    assertEquals(Arrays.asList("verify " + server.getHostName()),
+        hostnameVerifier.calls);
+    assertEquals(Arrays.asList("checkServerTrusted [CN=" + server.getHostName() + " 1]"),
+        trustManager.calls);
   }
 
   @Test public void readTimeouts() throws IOException {
@@ -2203,7 +2203,7 @@ private void testRedirect(boolean temporary, String method) throws Exception {
   /** Confirm that an unacknowledged write times out. */
   @Test public void writeTimeouts() throws IOException {
     server.enqueue(new MockResponse()
-        .throttleBody(1, 3600, TimeUnit.SECONDS)); // Prevent the server from reading!
+        .throttleBody(1, 1, TimeUnit.SECONDS)); // Prevent the server from reading!
     server.play();
 
     client.client().setWriteTimeout(500, TimeUnit.MILLISECONDS);
@@ -2365,12 +2365,7 @@ private void testFlushAfterStreamTransmitted(TransferKind transferKind) throws I
   }
 
   @Test public void getHeadersThrows() throws IOException {
-    // Enqueue a response for every IP address held by localhost, because the route selector
-    // will try each in sequence.
-    // TODO: use the fake Dns implementation instead of a loop
-    for (InetAddress inetAddress : InetAddress.getAllByName(server.getHostName())) {
-      server.enqueue(new MockResponse().setSocketPolicy(DISCONNECT_AT_START));
-    }
+    server.enqueue(new MockResponse().setSocketPolicy(DISCONNECT_AT_START));
     server.play();
 
     connection = client.open(server.getUrl("/"));
@@ -3183,7 +3178,7 @@ void setBody(MockResponse response, String content, int chunkSize) throws IOExce
       @Override public HttpURLConnection connect(
           MockWebServer server, OkUrlFactory streamHandlerFactory, URL url)
           throws IOException {
-        System.setProperty("proxyHost", "localhost");
+        System.setProperty("proxyHost", server.getHostName());
         System.setProperty("proxyPort", Integer.toString(server.getPort()));
         return streamHandlerFactory.open(url);
       }
@@ -3193,7 +3188,7 @@ void setBody(MockResponse response, String content, int chunkSize) throws IOExce
       @Override public HttpURLConnection connect(
           MockWebServer server, OkUrlFactory streamHandlerFactory, URL url)
           throws IOException {
-        System.setProperty("http.proxyHost", "localhost");
+        System.setProperty("http.proxyHost", server.getHostName());
         System.setProperty("http.proxyPort", Integer.toString(server.getPort()));
         return streamHandlerFactory.open(url);
       }
@@ -3203,7 +3198,7 @@ void setBody(MockResponse response, String content, int chunkSize) throws IOExce
       @Override public HttpURLConnection connect(
           MockWebServer server, OkUrlFactory streamHandlerFactory, URL url)
           throws IOException {
-        System.setProperty("https.proxyHost", "localhost");
+        System.setProperty("https.proxyHost", server.getHostName());
         System.setProperty("https.proxyPort", Integer.toString(server.getPort()));
         return streamHandlerFactory.open(url);
       }
diff --git a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/spdy/MockSpdyPeer.java b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/spdy/MockSpdyPeer.java
index 3dac6d32fe..630a21881a 100644
--- a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/spdy/MockSpdyPeer.java
+++ b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/spdy/MockSpdyPeer.java
@@ -74,7 +74,7 @@ public int frameCount() {
   }
 
   public FrameWriter sendFrame() {
-    outFrames.add(new OutFrame(frameCount++, bytesOut.size(), Integer.MAX_VALUE));
+    outFrames.add(new OutFrame(frameCount++, bytesOut.size(), false));
     return frameWriter;
   }
 
@@ -83,17 +83,27 @@ public FrameWriter sendFrame() {
    * won't be generated naturally.
    */
   public void sendFrame(byte[] frame) throws IOException {
-    outFrames.add(new OutFrame(frameCount++, bytesOut.size(), Integer.MAX_VALUE));
+    outFrames.add(new OutFrame(frameCount++, bytesOut.size(), false));
     bytesOut.write(frame);
   }
 
   /**
-   * Sends a frame, truncated to {@code truncateToLength} bytes. This is only
-   * useful for testing error handling as the truncated frame will be
-   * malformed.
+   * Shortens the last frame from its original length to {@code length}. This
+   * will cause the peer to close the socket as soon as this frame has been
+   * written; otherwise the peer stays open until explicitly closed.
    */
-  public FrameWriter sendTruncatedFrame(int truncateToLength) {
-    outFrames.add(new OutFrame(frameCount++, bytesOut.size(), truncateToLength));
+  public FrameWriter truncateLastFrame(int length) {
+    OutFrame lastFrame = outFrames.remove(outFrames.size() - 1);
+    if (length >= bytesOut.size() - lastFrame.start) throw new IllegalArgumentException();
+
+    // Move everything from bytesOut into a new buffer.
+    Buffer fullBuffer = new Buffer();
+    bytesOut.read(fullBuffer, bytesOut.size());
+
+    // Copy back all but what we're truncating.
+    fullBuffer.read(bytesOut, lastFrame.start + length);
+
+    outFrames.add(new OutFrame(lastFrame.sequence, lastFrame.start, true));
     return frameWriter;
   }
 
@@ -136,18 +146,25 @@ private void readAndWriteFrames() throws IOException {
 
       if (nextOutFrame != null && nextOutFrame.sequence == i) {
         long start = nextOutFrame.start;
-        int truncateToLength = nextOutFrame.truncateToLength;
+        boolean truncated;
         long end;
         if (outFramesIterator.hasNext()) {
           nextOutFrame = outFramesIterator.next();
           end = nextOutFrame.start;
+          truncated = false;
         } else {
           end = outBytes.length;
+          truncated = nextOutFrame.truncated;
         }
 
-        // write a frame
-        int length = (int) Math.min(end - start, truncateToLength);
+        // Write a frame.
+        int length = (int) (end - start);
         out.write(outBytes, (int) start, length);
+
+        // If the last frame was truncated, immediately close the connection.
+        if (truncated) {
+          socket.close();
+        }
       } else {
         // read a frame
         InFrame inFrame = new InFrame(i, reader);
@@ -155,7 +172,6 @@ private void readAndWriteFrames() throws IOException {
         inFrames.add(inFrame);
       }
     }
-    Util.closeQuietly(socket);
   }
 
   public Socket openSocket() throws IOException {
@@ -179,12 +195,12 @@ public Socket openSocket() throws IOException {
   private static class OutFrame {
     private final int sequence;
     private final long start;
-    private final int truncateToLength;
+    private final boolean truncated;
 
-    private OutFrame(int sequence, long start, int truncateToLength) {
+    private OutFrame(int sequence, long start, boolean truncated) {
       this.sequence = sequence;
       this.start = start;
-      this.truncateToLength = truncateToLength;
+      this.truncated = truncated;
     }
   }
 
diff --git a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/spdy/Spdy3ConnectionTest.java b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/spdy/Spdy3ConnectionTest.java
index f8a42ebb29..640d9dbecb 100644
--- a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/spdy/Spdy3ConnectionTest.java
+++ b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/spdy/Spdy3ConnectionTest.java
@@ -1109,7 +1109,8 @@ private Buffer data(int byteCount) {
     // write the mocking script
     peer.acceptFrame(); // SYN_STREAM
     peer.sendFrame().synReply(false, 1, headerEntries("a", "android"));
-    peer.sendTruncatedFrame(8 + 100).data(false, 1, data(1024), 1024);
+    peer.sendFrame().data(false, 1, data(1024), 1024);
+    peer.truncateLastFrame(8 + 100);
     peer.play();
 
     // play it back
diff --git a/okhttp-urlconnection/src/test/java/com/squareup/okhttp/UrlConnectionCacheTest.java b/okhttp-urlconnection/src/test/java/com/squareup/okhttp/UrlConnectionCacheTest.java
index 2d6de3ebb8..e4c2f0181a 100644
--- a/okhttp-urlconnection/src/test/java/com/squareup/okhttp/UrlConnectionCacheTest.java
+++ b/okhttp-urlconnection/src/test/java/com/squareup/okhttp/UrlConnectionCacheTest.java
@@ -1098,36 +1098,8 @@ private RecordedRequest assertClientSuppliedCondition(MockResponse seed, String
     assertEquals("", readAscii(connection));
   }
 
-  @Test public void authorizationRequestHeaderPreventsCaching() throws Exception {
-    server.enqueue(
-        new MockResponse().addHeader("Last-Modified: " + formatDate(-2, TimeUnit.MINUTES))
-            .addHeader("Cache-Control: max-age=60")
-            .setBody("A"));
-    server.enqueue(new MockResponse().setBody("B"));
-
-    URL url = server.getUrl("/");
-    URLConnection connection = client.open(url);
-    connection.addRequestProperty("Authorization", "password");
-    assertEquals("A", readAscii(connection));
-    assertEquals("B", readAscii(client.open(url)));
-  }
-
-  @Test public void authorizationResponseCachedWithSMaxAge() throws Exception {
-    assertAuthorizationRequestFullyCached(
-        new MockResponse().addHeader("Cache-Control: s-maxage=60"));
-  }
-
-  @Test public void authorizationResponseCachedWithPublic() throws Exception {
-    assertAuthorizationRequestFullyCached(new MockResponse().addHeader("Cache-Control: public"));
-  }
-
-  @Test public void authorizationResponseCachedWithMustRevalidate() throws Exception {
-    assertAuthorizationRequestFullyCached(
-        new MockResponse().addHeader("Cache-Control: must-revalidate"));
-  }
-
-  public void assertAuthorizationRequestFullyCached(MockResponse response) throws Exception {
-    server.enqueue(response.addHeader("Cache-Control: max-age=60").setBody("A"));
+  @Test public void authorizationRequestFullyCached() throws Exception {
+    server.enqueue(new MockResponse().addHeader("Cache-Control: max-age=60").setBody("A"));
     server.enqueue(new MockResponse().setBody("B"));
 
     URL url = server.getUrl("/");
diff --git a/okhttp-urlconnection/src/test/java/com/squareup/okhttp/internal/huc/ResponseCacheTest.java b/okhttp-urlconnection/src/test/java/com/squareup/okhttp/internal/huc/ResponseCacheTest.java
index 5fc68d4f38..bf16b907dd 100644
--- a/okhttp-urlconnection/src/test/java/com/squareup/okhttp/internal/huc/ResponseCacheTest.java
+++ b/okhttp-urlconnection/src/test/java/com/squareup/okhttp/internal/huc/ResponseCacheTest.java
@@ -917,36 +917,8 @@ private RecordedRequest assertClientSuppliedCondition(MockResponse seed, String
     assertEquals("", readAscii(connection));
   }
 
-  @Test public void authorizationRequestHeaderPreventsCaching() throws Exception {
-    server.enqueue(
-        new MockResponse().addHeader("Last-Modified: " + formatDate(-2, TimeUnit.MINUTES))
-            .addHeader("Cache-Control: max-age=60")
-            .setBody("A"));
-    server.enqueue(new MockResponse().setBody("B"));
-
-    URL url = server.getUrl("/");
-    URLConnection connection = openConnection(url);
-    connection.addRequestProperty("Authorization", "password");
-    assertEquals("A", readAscii(connection));
-    assertEquals("B", readAscii(openConnection(url)));
-  }
-
-  @Test public void authorizationResponseCachedWithSMaxAge() throws Exception {
-    assertAuthorizationRequestFullyCached(
-        new MockResponse().addHeader("Cache-Control: s-maxage=60"));
-  }
-
-  @Test public void authorizationResponseCachedWithPublic() throws Exception {
-    assertAuthorizationRequestFullyCached(new MockResponse().addHeader("Cache-Control: public"));
-  }
-
-  @Test public void authorizationResponseCachedWithMustRevalidate() throws Exception {
-    assertAuthorizationRequestFullyCached(
-        new MockResponse().addHeader("Cache-Control: must-revalidate"));
-  }
-
-  public void assertAuthorizationRequestFullyCached(MockResponse response) throws Exception {
-    server.enqueue(response.addHeader("Cache-Control: max-age=60").setBody("A"));
+  @Test public void authorizationRequestFullyCached() throws Exception {
+    server.enqueue(new MockResponse().addHeader("Cache-Control: max-age=60").setBody("A"));
     server.enqueue(new MockResponse().setBody("B"));
 
     URL url = server.getUrl("/");
diff --git a/okhttp/src/main/java/com/squareup/okhttp/Cache.java b/okhttp/src/main/java/com/squareup/okhttp/Cache.java
index 373feb0313..c80e866cf6 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/Cache.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/Cache.java
@@ -251,6 +251,14 @@ public void delete() throws IOException {
     cache.delete();
   }
 
+  /**
+   * Deletes all values stored in the cache. In-flight writes to the cache will
+   * complete normally, but the corresponding responses will not be stored.
+   */
+  public void evictAll() throws IOException {
+    cache.evictAll();
+  }
+
   public synchronized int getWriteAbortCount() {
     return writeAbortCount;
   }
diff --git a/okhttp/src/main/java/com/squareup/okhttp/CacheControl.java b/okhttp/src/main/java/com/squareup/okhttp/CacheControl.java
index c19d77958b..774f785760 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/CacheControl.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/CacheControl.java
@@ -192,17 +192,17 @@ public static CacheControl parse(Headers headers) {
         } else if ("no-store".equalsIgnoreCase(directive)) {
           noStore = true;
         } else if ("max-age".equalsIgnoreCase(directive)) {
-          maxAgeSeconds = HeaderParser.parseSeconds(parameter);
+          maxAgeSeconds = HeaderParser.parseSeconds(parameter, -1);
         } else if ("s-maxage".equalsIgnoreCase(directive)) {
-          sMaxAgeSeconds = HeaderParser.parseSeconds(parameter);
+          sMaxAgeSeconds = HeaderParser.parseSeconds(parameter, -1);
         } else if ("public".equalsIgnoreCase(directive)) {
           isPublic = true;
         } else if ("must-revalidate".equalsIgnoreCase(directive)) {
           mustRevalidate = true;
         } else if ("max-stale".equalsIgnoreCase(directive)) {
-          maxStaleSeconds = HeaderParser.parseSeconds(parameter);
+          maxStaleSeconds = HeaderParser.parseSeconds(parameter, Integer.MAX_VALUE);
         } else if ("min-fresh".equalsIgnoreCase(directive)) {
-          minFreshSeconds = HeaderParser.parseSeconds(parameter);
+          minFreshSeconds = HeaderParser.parseSeconds(parameter, -1);
         } else if ("only-if-cached".equalsIgnoreCase(directive)) {
           onlyIfCached = true;
         } else if ("no-transform".equalsIgnoreCase(directive)) {
diff --git a/okhttp/src/main/java/com/squareup/okhttp/Call.java b/okhttp/src/main/java/com/squareup/okhttp/Call.java
index 900f8d5c99..8f934afc68 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/Call.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/Call.java
@@ -163,6 +163,10 @@ Object tag() {
       return request.tag();
     }
 
+    void cancel() {
+      Call.this.cancel();
+    }
+
     Call get() {
       return Call.this;
     }
diff --git a/okhttp/src/main/java/com/squareup/okhttp/Dispatcher.java b/okhttp/src/main/java/com/squareup/okhttp/Dispatcher.java
index 26d9054ef8..15ecac6635 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/Dispatcher.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/Dispatcher.java
@@ -113,8 +113,10 @@ synchronized void enqueue(AsyncCall call) {
 
   /** Cancel all calls with the tag {@code tag}. */
   public synchronized void cancel(Object tag) {
-    for (Iterator<AsyncCall> i = readyCalls.iterator(); i.hasNext(); ) {
-      if (Util.equal(tag, i.next().tag())) i.remove();
+    for (AsyncCall call : readyCalls) {
+      if (Util.equal(tag, call.tag())) {
+        call.cancel();
+      }
     }
 
     for (AsyncCall call : runningCalls) {
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/DiskLruCache.java b/okhttp/src/main/java/com/squareup/okhttp/internal/DiskLruCache.java
index ccaf3d9e99..a5e5e4fbd6 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/DiskLruCache.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/DiskLruCache.java
@@ -24,7 +24,6 @@
 import java.util.Arrays;
 import java.util.Iterator;
 import java.util.LinkedHashMap;
-import java.util.Map;
 import java.util.concurrent.LinkedBlockingQueue;
 import java.util.concurrent.ThreadPoolExecutor;
 import java.util.concurrent.TimeUnit;
@@ -90,7 +89,7 @@
   static final String MAGIC = "libcore.io.DiskLruCache";
   static final String VERSION_1 = "1";
   static final long ANY_SEQUENCE_NUMBER = -1;
-  static final Pattern LEGAL_KEY_PATTERN = Pattern.compile("[a-z0-9_-]{1,64}");
+  static final Pattern LEGAL_KEY_PATTERN = Pattern.compile("[a-z0-9_-]{1,120}");
   private static final String CLEAN = "CLEAN";
   private static final String DIRTY = "DIRTY";
   private static final String REMOVE = "REMOVE";
@@ -577,8 +576,9 @@ private boolean journalRebuildRequired() {
   }
 
   /**
-   * Drops the entry for {@code key} if it exists and can be removed. Entries
-   * actively being edited cannot be removed.
+   * Drops the entry for {@code key} if it exists and can be removed. If the
+   * entry for {@code key} is currently being edited, that edit will complete
+   * normally but its value will not be stored.
    *
    * @return true if an entry was removed.
    */
@@ -586,8 +586,13 @@ public synchronized boolean remove(String key) throws IOException {
     checkNotClosed();
     validateKey(key);
     Entry entry = lruEntries.get(key);
-    if (entry == null || entry.currentEditor != null) {
-      return false;
+    if (entry == null) return false;
+    return removeEntry(entry);
+  }
+
+  private boolean removeEntry(Entry entry) throws IOException {
+    if (entry.currentEditor != null) {
+      entry.currentEditor.hasErrors = true; // Prevent the edit from completing normally.
     }
 
     for (int i = 0; i < valueCount; i++) {
@@ -598,8 +603,8 @@ public synchronized boolean remove(String key) throws IOException {
     }
 
     redundantOpCount++;
-    journalWriter.writeUtf8(REMOVE).writeByte(' ').writeUtf8(key).writeByte('\n');
-    lruEntries.remove(key);
+    journalWriter.writeUtf8(REMOVE).writeByte(' ').writeUtf8(entry.key).writeByte('\n');
+    lruEntries.remove(entry.key);
 
     if (journalRebuildRequired()) {
       executorService.execute(cleanupRunnable);
@@ -632,8 +637,7 @@ public synchronized void close() throws IOException {
       return; // Already closed.
     }
     // Copying for safe iteration.
-    for (Object next : lruEntries.values().toArray()) {
-      Entry entry = (Entry) next;
+    for (Entry entry : lruEntries.values().toArray(new Entry[lruEntries.size()])) {
       if (entry.currentEditor != null) {
         entry.currentEditor.abort();
       }
@@ -645,8 +649,8 @@ public synchronized void close() throws IOException {
 
   private void trimToSize() throws IOException {
     while (size > maxSize) {
-      Map.Entry<String, Entry> toEvict = lruEntries.entrySet().iterator().next();
-      remove(toEvict.getKey());
+      Entry toEvict = lruEntries.values().iterator().next();
+      removeEntry(toEvict);
     }
   }
 
@@ -660,10 +664,22 @@ public void delete() throws IOException {
     Util.deleteContents(directory);
   }
 
+  /**
+   * Deletes all stored values from the cache. In-flight edits will complete
+   * normally but their values will not be stored.
+   */
+  public synchronized void evictAll() throws IOException {
+    // Copying for safe iteration.
+    for (Entry entry : lruEntries.values().toArray(new Entry[lruEntries.size()])) {
+      removeEntry(entry);
+    }
+  }
+
   private void validateKey(String key) {
     Matcher matcher = LEGAL_KEY_PATTERN.matcher(key);
     if (!matcher.matches()) {
-      throw new IllegalArgumentException("keys must match regex [a-z0-9_-]{1,64}: \"" + key + "\"");
+      throw new IllegalArgumentException(
+          "keys must match regex [a-z0-9_-]{1,120}: \"" + key + "\"");
     }
   }
 
@@ -822,13 +838,15 @@ public void set(int index, String value) throws IOException {
      * edit lock so another edit may be started on the same key.
      */
     public void commit() throws IOException {
-      if (hasErrors) {
-        completeEdit(this, false);
-        remove(entry.key); // The previous entry is stale.
-      } else {
-        completeEdit(this, true);
+      synchronized (DiskLruCache.this) {
+        if (hasErrors) {
+          completeEdit(this, false);
+          removeEntry(entry); // The previous entry is stale.
+        } else {
+          completeEdit(this, true);
+        }
+        committed = true;
       }
-      committed = true;
     }
 
     /**
@@ -836,14 +854,18 @@ public void commit() throws IOException {
      * started on the same key.
      */
     public void abort() throws IOException {
-      completeEdit(this, false);
+      synchronized (DiskLruCache.this) {
+        completeEdit(this, false);
+      }
     }
 
     public void abortUnlessCommitted() {
-      if (!committed) {
-        try {
-          abort();
-        } catch (IOException ignored) {
+      synchronized (DiskLruCache.this) {
+        if (!committed) {
+          try {
+            completeEdit(this, false);
+          } catch (IOException ignored) {
+          }
         }
       }
     }
@@ -857,7 +879,9 @@ public FaultHidingSink(Sink delegate) {
         try {
           super.write(source, byteCount);
         } catch (IOException e) {
-          hasErrors = true;
+          synchronized (DiskLruCache.this) {
+            hasErrors = true;
+          }
         }
       }
 
@@ -865,7 +889,9 @@ public FaultHidingSink(Sink delegate) {
         try {
           super.flush();
         } catch (IOException e) {
-          hasErrors = true;
+          synchronized (DiskLruCache.this) {
+            hasErrors = true;
+          }
         }
       }
 
@@ -873,7 +899,9 @@ public FaultHidingSink(Sink delegate) {
         try {
           super.close();
         } catch (IOException e) {
-          hasErrors = true;
+          synchronized (DiskLruCache.this) {
+            hasErrors = true;
+          }
         }
       }
     }
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/http/CacheStrategy.java b/okhttp/src/main/java/com/squareup/okhttp/internal/http/CacheStrategy.java
index 2363d53b63..70007dcb65 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/http/CacheStrategy.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/http/CacheStrategy.java
@@ -50,17 +50,10 @@ public static boolean isCacheable(Response response, Request request) {
       return false;
     }
 
-    // Responses to authorized requests aren't cacheable unless they include
-    // a 'public', 'must-revalidate' or 's-maxage' directive.
+    // A 'no-store' directive on request or response prevents the response from being cached.
     CacheControl responseCaching = response.cacheControl();
-    if (request.header("Authorization") != null
-        && !responseCaching.isPublic()
-        && !responseCaching.mustRevalidate()
-        && responseCaching.sMaxAgeSeconds() == -1) {
-      return false;
-    }
-
-    if (responseCaching.noStore()) {
+    CacheControl requestCaching = request.cacheControl();
+    if (responseCaching.noStore() || requestCaching.noStore()) {
       return false;
     }
 
@@ -124,7 +117,7 @@ public Factory(long nowMillis, Request request, Response cacheResponse) {
           } else if ("ETag".equalsIgnoreCase(fieldName)) {
             etag = value;
           } else if ("Age".equalsIgnoreCase(fieldName)) {
-            ageSeconds = HeaderParser.parseSeconds(value);
+            ageSeconds = HeaderParser.parseSeconds(value, -1);
           } else if (OkHeaders.SENT_MILLIS.equalsIgnoreCase(fieldName)) {
             sentRequestMillis = Long.parseLong(value);
           } else if (OkHeaders.RECEIVED_MILLIS.equalsIgnoreCase(fieldName)) {
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/http/HeaderParser.java b/okhttp/src/main/java/com/squareup/okhttp/internal/http/HeaderParser.java
index e9af13026c..55f82ada47 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/http/HeaderParser.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/http/HeaderParser.java
@@ -47,9 +47,9 @@ public static int skipWhitespace(String input, int pos) {
 
   /**
    * Returns {@code value} as a positive integer, or 0 if it is negative, or
-   * -1 if it cannot be parsed.
+   * {@code defaultValue} if it cannot be parsed.
    */
-  public static int parseSeconds(String value) {
+  public static int parseSeconds(String value, int defaultValue) {
     try {
       long seconds = Long.parseLong(value);
       if (seconds > Integer.MAX_VALUE) {
@@ -60,7 +60,7 @@ public static int parseSeconds(String value) {
         return (int) seconds;
       }
     } catch (NumberFormatException e) {
-      return -1;
+      return defaultValue;
     }
   }
 
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/http/RouteSelector.java b/okhttp/src/main/java/com/squareup/okhttp/internal/http/RouteSelector.java
index 719313bd1b..c5a24b564a 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/http/RouteSelector.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/http/RouteSelector.java
@@ -243,7 +243,7 @@ private void resetNextInetSocketAddress(Proxy proxy) throws UnknownHostException
     String socketHost;
     int socketPort;
     if (proxy.type() == Proxy.Type.DIRECT) {
-      socketHost = uri.getHost();
+      socketHost = address.getUriHost();
       socketPort = getEffectivePort(uri);
     } else {
       SocketAddress proxyAddress = proxy.address();
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/Settings.java b/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/Settings.java
index 8a6cbf398d..bb67b8311a 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/Settings.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/Settings.java
@@ -58,7 +58,7 @@
   static final int MAX_HEADER_LIST_SIZE = 6;
   /** Window size in bytes. */
   static final int INITIAL_WINDOW_SIZE = 7;
-  /** spdy/3: Window size in bytes. */
+  /** spdy/3: Size of the client certificate vector. Unsupported. */
   static final int CLIENT_CERTIFICATE_VECTOR_SIZE = 8;
   /** Flow control options. */
   static final int FLOW_CONTROL_OPTIONS = 10;
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/SpdyConnection.java b/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/SpdyConnection.java
index d3ebee2e31..458fb6db2b 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/SpdyConnection.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/SpdyConnection.java
@@ -695,7 +695,7 @@ private Reader() {
         }
       }
       if (streamsToNotify != null && delta != 0) {
-        for (SpdyStream stream : streams.values()) {
+        for (SpdyStream stream : streamsToNotify) {
           synchronized (stream) {
             stream.addBytesToWriteWindow(delta);
           }
