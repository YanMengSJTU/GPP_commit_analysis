diff --git a/okhttp-tests/src/test/java/okhttp3/CertificatePinnerTest.java b/okhttp-tests/src/test/java/okhttp3/CertificatePinnerTest.java
index b088f8c141..9442ddaf71 100644
--- a/okhttp-tests/src/test/java/okhttp3/CertificatePinnerTest.java
+++ b/okhttp-tests/src/test/java/okhttp3/CertificatePinnerTest.java
@@ -16,58 +16,50 @@
 package okhttp3;
 
 import java.security.GeneralSecurityException;
-import java.util.Set;
+import java.util.Arrays;
+import java.util.Collections;
+import java.util.List;
 import javax.net.ssl.SSLPeerUnverifiedException;
+import okhttp3.CertificatePinner.Pin;
 import okhttp3.internal.HeldCertificate;
-import okio.ByteString;
 import org.junit.Test;
 
-import static okhttp3.TestUtil.setOf;
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertFalse;
-import static org.junit.Assert.assertNull;
 import static org.junit.Assert.assertTrue;
 import static org.junit.Assert.fail;
 
 public final class CertificatePinnerTest {
   static HeldCertificate certA1;
-  static String certA1Pin;
-  static ByteString certA1PinBase64;
+  static String certA1Sha256Pin;
 
   static HeldCertificate certB1;
-  static String certB1Pin;
-  static ByteString certB1PinBase64;
+  static String certB1Sha256Pin;
 
   static HeldCertificate certC1;
-  static String certC1Pin;
+  static String certC1Sha256Pin;
 
   static {
     try {
       certA1 = new HeldCertificate.Builder()
           .serialNumber("100")
           .build();
-      certA1Pin = CertificatePinner.pin(certA1.certificate);
-      certA1PinBase64 = pinToBase64(certA1Pin);
+      certA1Sha256Pin = "sha256/" + CertificatePinner.sha256(certA1.certificate).base64();
 
       certB1 = new HeldCertificate.Builder()
           .serialNumber("200")
           .build();
-      certB1Pin = CertificatePinner.pin(certB1.certificate);
-      certB1PinBase64 = pinToBase64(certB1Pin);
+      certB1Sha256Pin = "sha256/" + CertificatePinner.sha256(certB1.certificate).base64();
 
       certC1 = new HeldCertificate.Builder()
           .serialNumber("300")
           .build();
-      certC1Pin = CertificatePinner.pin(certC1.certificate);
+      certC1Sha256Pin = "sha256/" + CertificatePinner.sha256(certC1.certificate).base64();
     } catch (GeneralSecurityException e) {
       throw new AssertionError(e);
     }
   }
 
-  static ByteString pinToBase64(String pin) {
-    return ByteString.decodeBase64(pin.substring("sha1/".length()));
-  }
-
   @Test public void malformedPin() throws Exception {
     CertificatePinner.Builder builder = new CertificatePinner.Builder();
     try {
@@ -100,14 +92,22 @@ static ByteString pinToBase64(String pin) {
         .build();
     String keypairBCertificate2Pin = CertificatePinner.pin(heldCertificateB2.certificate);
 
-    assertTrue(certA1Pin.equals(keypairACertificate2Pin));
-    assertTrue(certB1Pin.equals(keypairBCertificate2Pin));
-    assertFalse(certA1Pin.equals(certB1Pin));
+    assertTrue(certA1Sha256Pin.equals(keypairACertificate2Pin));
+    assertTrue(certB1Sha256Pin.equals(keypairBCertificate2Pin));
+    assertFalse(certA1Sha256Pin.equals(certB1Sha256Pin));
   }
 
   @Test public void successfulCheck() throws Exception {
     CertificatePinner certificatePinner = new CertificatePinner.Builder()
-        .add("example.com", certA1Pin)
+        .add("example.com", certA1Sha256Pin)
+        .build();
+
+    certificatePinner.check("example.com", certA1.certificate);
+  }
+
+  @Test public void successfulCheckSha1Pin() throws Exception {
+    CertificatePinner certificatePinner = new CertificatePinner.Builder()
+        .add("example.com", "sha1/" + CertificatePinner.sha1(certA1.certificate).base64())
         .build();
 
     certificatePinner.check("example.com", certA1.certificate);
@@ -115,7 +115,7 @@ static ByteString pinToBase64(String pin) {
 
   @Test public void successfulMatchAcceptsAnyMatchingCertificate() throws Exception {
     CertificatePinner certificatePinner = new CertificatePinner.Builder()
-        .add("example.com", certB1Pin)
+        .add("example.com", certB1Sha256Pin)
         .build();
 
     certificatePinner.check("example.com", certA1.certificate, certB1.certificate);
@@ -123,7 +123,7 @@ static ByteString pinToBase64(String pin) {
 
   @Test public void unsuccessfulCheck() throws Exception {
     CertificatePinner certificatePinner = new CertificatePinner.Builder()
-        .add("example.com", certA1Pin)
+        .add("example.com", certA1Sha256Pin)
         .build();
 
     try {
@@ -135,7 +135,7 @@ static ByteString pinToBase64(String pin) {
 
   @Test public void multipleCertificatesForOneHostname() throws Exception {
     CertificatePinner certificatePinner = new CertificatePinner.Builder()
-        .add("example.com", certA1Pin, certB1Pin)
+        .add("example.com", certA1Sha256Pin, certB1Sha256Pin)
         .build();
 
     certificatePinner.check("example.com", certA1.certificate);
@@ -144,8 +144,8 @@ static ByteString pinToBase64(String pin) {
 
   @Test public void multipleHostnamesForOneCertificate() throws Exception {
     CertificatePinner certificatePinner = new CertificatePinner.Builder()
-        .add("example.com", certA1Pin)
-        .add("www.example.com", certA1Pin)
+        .add("example.com", certA1Sha256Pin)
+        .add("www.example.com", certA1Sha256Pin)
         .build();
 
     certificatePinner.check("example.com", certA1.certificate);
@@ -159,7 +159,7 @@ static ByteString pinToBase64(String pin) {
 
   @Test public void successfulCheckForWildcardHostname() throws Exception {
     CertificatePinner certificatePinner = new CertificatePinner.Builder()
-        .add("*.example.com", certA1Pin)
+        .add("*.example.com", certA1Sha256Pin)
         .build();
 
     certificatePinner.check("a.example.com", certA1.certificate);
@@ -168,7 +168,7 @@ static ByteString pinToBase64(String pin) {
   @Test public void successfulMatchAcceptsAnyMatchingCertificateForWildcardHostname()
       throws Exception {
     CertificatePinner certificatePinner = new CertificatePinner.Builder()
-        .add("*.example.com", certB1Pin)
+        .add("*.example.com", certB1Sha256Pin)
         .build();
 
     certificatePinner.check("a.example.com", certA1.certificate, certB1.certificate);
@@ -176,7 +176,7 @@ static ByteString pinToBase64(String pin) {
 
   @Test public void unsuccessfulCheckForWildcardHostname() throws Exception {
     CertificatePinner certificatePinner = new CertificatePinner.Builder()
-        .add("*.example.com", certA1Pin)
+        .add("*.example.com", certA1Sha256Pin)
         .build();
 
     try {
@@ -188,7 +188,7 @@ static ByteString pinToBase64(String pin) {
 
   @Test public void multipleCertificatesForOneWildcardHostname() throws Exception {
     CertificatePinner certificatePinner = new CertificatePinner.Builder()
-        .add("*.example.com", certA1Pin, certB1Pin)
+        .add("*.example.com", certA1Sha256Pin, certB1Sha256Pin)
         .build();
 
     certificatePinner.check("a.example.com", certA1.certificate);
@@ -198,8 +198,8 @@ static ByteString pinToBase64(String pin) {
   @Test public void successfulCheckForOneHostnameWithWildcardAndDirectCertificate()
       throws Exception {
     CertificatePinner certificatePinner = new CertificatePinner.Builder()
-        .add("*.example.com", certA1Pin)
-        .add("a.example.com", certB1Pin)
+        .add("*.example.com", certA1Sha256Pin)
+        .add("a.example.com", certB1Sha256Pin)
         .build();
 
     certificatePinner.check("a.example.com", certA1.certificate);
@@ -209,8 +209,8 @@ static ByteString pinToBase64(String pin) {
   @Test public void unsuccessfulCheckForOneHostnameWithWildcardAndDirectCertificate()
       throws Exception {
     CertificatePinner certificatePinner = new CertificatePinner.Builder()
-        .add("*.example.com", certA1Pin)
-        .add("a.example.com", certB1Pin)
+        .add("*.example.com", certA1Sha256Pin)
+        .add("a.example.com", certB1Sha256Pin)
         .build();
 
     try {
@@ -222,35 +222,35 @@ static ByteString pinToBase64(String pin) {
 
   @Test public void successfulFindMatchingPins() {
     CertificatePinner certificatePinner = new CertificatePinner.Builder()
-        .add("first.com", certA1Pin, certB1Pin)
-        .add("second.com", certC1Pin)
+        .add("first.com", certA1Sha256Pin, certB1Sha256Pin)
+        .add("second.com", certC1Sha256Pin)
         .build();
 
-    Set<ByteString> expectedPins = setOf(certA1PinBase64, certB1PinBase64);
-    Set<ByteString> matchedPins = certificatePinner.findMatchingPins("first.com");
-
-    assertEquals(expectedPins, matchedPins);
+    List<Pin> expectedPins = Arrays.asList(
+        new Pin("first.com", certA1Sha256Pin),
+        new Pin("first.com", certB1Sha256Pin));
+    assertEquals(expectedPins, certificatePinner.findMatchingPins("first.com"));
   }
 
   @Test public void successfulFindMatchingPinsForWildcardAndDirectCertificates() {
     CertificatePinner certificatePinner = new CertificatePinner.Builder()
-        .add("*.example.com", certA1Pin)
-        .add("a.example.com", certB1Pin)
-        .add("b.example.com", certC1Pin)
+        .add("*.example.com", certA1Sha256Pin)
+        .add("a.example.com", certB1Sha256Pin)
+        .add("b.example.com", certC1Sha256Pin)
         .build();
 
-    Set<ByteString> expectedPins = setOf(certA1PinBase64, certB1PinBase64);
-    Set<ByteString> matchedPins = certificatePinner.findMatchingPins("a.example.com");
-
-    assertEquals(expectedPins, matchedPins);
+    List<Pin> expectedPins = Arrays.asList(
+        new Pin("*.example.com", certA1Sha256Pin),
+        new Pin("a.example.com", certB1Sha256Pin));
+    assertEquals(expectedPins, certificatePinner.findMatchingPins("a.example.com"));
   }
 
   @Test public void wildcardHostnameShouldNotMatchThroughDot() throws Exception {
     CertificatePinner certificatePinner = new CertificatePinner.Builder()
-        .add("*.example.com", certA1Pin)
+        .add("*.example.com", certA1Sha256Pin)
         .build();
 
-    assertNull(certificatePinner.findMatchingPins("example.com"));
-    assertNull(certificatePinner.findMatchingPins("a.b.example.com"));
+    assertEquals(Collections.emptyList(), certificatePinner.findMatchingPins("example.com"));
+    assertEquals(Collections.emptyList(), certificatePinner.findMatchingPins("a.b.example.com"));
   }
 }
diff --git a/okhttp/src/main/java/okhttp3/CertificatePinner.java b/okhttp/src/main/java/okhttp3/CertificatePinner.java
index e485c87f52..f7a1367649 100644
--- a/okhttp/src/main/java/okhttp3/CertificatePinner.java
+++ b/okhttp/src/main/java/okhttp3/CertificatePinner.java
@@ -17,30 +17,25 @@
 
 import java.security.cert.Certificate;
 import java.security.cert.X509Certificate;
+import java.util.ArrayList;
 import java.util.Arrays;
-import java.util.LinkedHashMap;
-import java.util.LinkedHashSet;
+import java.util.Collections;
 import java.util.List;
-import java.util.Map;
-import java.util.Set;
 import javax.net.ssl.SSLPeerUnverifiedException;
 import okhttp3.internal.Util;
 import okhttp3.internal.tls.CertificateChainCleaner;
 import okhttp3.internal.tls.TrustRootIndex;
 import okio.ByteString;
 
-import static java.util.Collections.unmodifiableSet;
-
 /**
  * Constrains which certificates are trusted. Pinning certificates defends against attacks on
  * certificate authorities. It also prevents connections through man-in-the-middle certificate
  * authorities either known or unknown to the application's user.
  *
  * <p>This class currently pins a certificate's Subject Public Key Info as described on <a
- * href="http://goo.gl/AIx3e5">Adam Langley's Weblog</a>. Pins are base-64 SHA-1 hashes, consistent
- * with the format Chromium uses for <a href="http://goo.gl/XDh6je">static certificates</a>. See
- * Chromium's <a href="http://goo.gl/4CCnGs">pinsets</a> for hostnames that are pinned in that
- * browser.
+ * href="http://goo.gl/AIx3e5">Adam Langley's Weblog</a>. Pins are either base64 SHA-256 hashes as
+ * in <a href="http://tools.ietf.org/html/rfc7469">HTTP Public Key Pinning (HPKP)</a> or SHA-1
+ * base64 hashes as in Chromium's <a href="http://goo.gl/XDh6je">static certificates</a>.
  *
  * <h3>Setting up Certificate Pinning</h3>
  *
@@ -54,7 +49,7 @@
  *
  *     String hostname = "publicobject.com";
  *     CertificatePinner certificatePinner = new CertificatePinner.Builder()
- *         .add(hostname, "sha1/AAAAAAAAAAAAAAAAAAAAAAAAAAA=")
+ *         .add(hostname, "sha256/AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA=")
  *         .build();
  *     OkHttpClient client = new OkHttpClient();
  *     client.setCertificatePinner(certificatePinner);
@@ -69,12 +64,12 @@
  *
  * javax.net.ssl.SSLPeerUnverifiedException: Certificate pinning failure!
  *   Peer certificate chain:
- *     sha1/DmxUShsZuNiqPQsX2Oi9uv2sCnw=: CN=publicobject.com, OU=PositiveSSL
- *     sha1/SXxoaOSEzPC6BgGmxAt/EAcsajw=: CN=COMODO RSA Domain Validation Secure Server CA
- *     sha1/blhOM3W9V/bVQhsWAcLYwPU6n24=: CN=COMODO RSA Certification Authority
- *     sha1/T5x9IXmcrQ7YuQxXnxoCmeeQ84c=: CN=AddTrust External CA Root
+ *     sha256/afwiKY3RxoMmLkuRW1l7QsPZTJPwDS2pdDROQjXw8ig=: CN=publicobject.com, OU=PositiveSSL
+ *     sha256/klO23nT2ehFDXCfx3eHTDRESMz3asj1muO+4aIdjiuY=: CN=COMODO RSA Secure Server CA
+ *     sha256/grX4Ta9HpZx6tSHkmCrvpApTQGo67CYDnvprLg5yRME=: CN=COMODO RSA Certification Authority
+ *     sha256/lCppFqbkrlJ3EcVFAkeip0+44VaoJUymbnOaEUk7tEU=: CN=AddTrust External CA Root
  *   Pinned certificates for publicobject.com:
- *     sha1/AAAAAAAAAAAAAAAAAAAAAAAAAAA=
+ *     sha256/AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA=
  *   at okhttp3.CertificatePinner.check(CertificatePinner.java)
  *   at okhttp3.Connection.upgradeToTls(Connection.java)
  *   at okhttp3.Connection.connect(Connection.java)
@@ -85,10 +80,10 @@
  * certificate pinner's configuration: <pre>   {@code
  *
  *     CertificatePinner certificatePinner = new CertificatePinner.Builder()
- *       .add("publicobject.com", "sha1/DmxUShsZuNiqPQsX2Oi9uv2sCnw=")
- *       .add("publicobject.com", "sha1/SXxoaOSEzPC6BgGmxAt/EAcsajw=")
- *       .add("publicobject.com", "sha1/blhOM3W9V/bVQhsWAcLYwPU6n24=")
- *       .add("publicobject.com", "sha1/T5x9IXmcrQ7YuQxXnxoCmeeQ84c=")
+ *       .add("publicobject.com", "sha256/afwiKY3RxoMmLkuRW1l7QsPZTJPwDS2pdDROQjXw8ig=")
+ *       .add("publicobject.com", "sha256/klO23nT2ehFDXCfx3eHTDRESMz3asj1muO+4aIdjiuY=")
+ *       .add("publicobject.com", "sha256/grX4Ta9HpZx6tSHkmCrvpApTQGo67CYDnvprLg5yRME=")
+ *       .add("publicobject.com", "sha256/lCppFqbkrlJ3EcVFAkeip0+44VaoJUymbnOaEUk7tEU=")
  *       .build();
  * }</pre>
  *
@@ -129,11 +124,11 @@
 public final class CertificatePinner {
   public static final CertificatePinner DEFAULT = new Builder().build();
 
-  private final Map<String, Set<ByteString>> hostnameToPins;
+  private final List<Pin> pins;
   private final TrustRootIndex trustRootIndex;
 
   private CertificatePinner(Builder builder) {
-    this.hostnameToPins = Util.immutableMap(builder.hostnameToPins);
+    this.pins = Util.immutableList(builder.pins);
     this.trustRootIndex = builder.trustRootIndex;
   }
 
@@ -147,31 +142,47 @@ private CertificatePinner(Builder builder) {
    */
   public void check(String hostname, List<Certificate> peerCertificates)
       throws SSLPeerUnverifiedException {
-    Set<ByteString> pins = findMatchingPins(hostname);
-
-    if (pins == null) return;
+    List<Pin> pins = findMatchingPins(hostname);
+    if (pins.isEmpty()) return;
 
     if (trustRootIndex != null) {
       peerCertificates = new CertificateChainCleaner(trustRootIndex).clean(peerCertificates);
     }
 
-    for (int i = 0, size = peerCertificates.size(); i < size; i++) {
-      X509Certificate x509Certificate = (X509Certificate) peerCertificates.get(i);
-      if (pins.contains(sha1(x509Certificate))) return; // Success!
+    for (int c = 0, certsSize = peerCertificates.size(); c < certsSize; c++) {
+      X509Certificate x509Certificate = (X509Certificate) peerCertificates.get(c);
+
+      // Lazily compute the hashes for each certificate.
+      ByteString sha1 = null;
+      ByteString sha256 = null;
+
+      for (int p = 0, pinsSize = pins.size(); p < pinsSize; p++) {
+        Pin pin = pins.get(p);
+        if (pin.hashAlgorithm.equals("sha256/")) {
+          if (sha256 == null) sha256 = sha256(x509Certificate);
+          if (pin.hash.equals(sha256)) return; // Success!
+        } else if (pin.hashAlgorithm.equals("sha1/")) {
+          if (sha1 == null) sha1 = sha1(x509Certificate);
+          if (pin.hash.equals(sha1)) return; // Success!
+        } else {
+          throw new AssertionError();
+        }
+      }
     }
 
     // If we couldn't find a matching pin, format a nice exception.
     StringBuilder message = new StringBuilder()
         .append("Certificate pinning failure!")
         .append("\n  Peer certificate chain:");
-    for (int i = 0, size = peerCertificates.size(); i < size; i++) {
-      X509Certificate x509Certificate = (X509Certificate) peerCertificates.get(i);
+    for (int c = 0, certsSize = peerCertificates.size(); c < certsSize; c++) {
+      X509Certificate x509Certificate = (X509Certificate) peerCertificates.get(c);
       message.append("\n    ").append(pin(x509Certificate))
           .append(": ").append(x509Certificate.getSubjectDN().getName());
     }
     message.append("\n  Pinned certificates for ").append(hostname).append(":");
-    for (ByteString pin : pins) {
-      message.append("\n    sha1/").append(pin.base64());
+    for (int p = 0, pinsSize = pins.size(); p < pinsSize; p++) {
+      Pin pin = pins.get(p);
+      message.append("\n    ").append(pin);
     }
     throw new SSLPeerUnverifiedException(message.toString());
   }
@@ -183,36 +194,18 @@ public void check(String hostname, Certificate... peerCertificates)
   }
 
   /**
-   * Returns list of matching certificates' pins for the hostname or {@code null} if hostname does
-   * not have pinned certificates.
+   * Returns list of matching certificates' pins for the hostname. Returns an empty list if the
+   * hostname does not have pinned certificates.
    */
-  Set<ByteString> findMatchingPins(String hostname) {
-    Set<ByteString> directPins = hostnameToPins.get(hostname);
-    Set<ByteString> wildcardPins = null;
-
-    int indexOfFirstDot = hostname.indexOf('.');
-    int indexOfLastDot = hostname.lastIndexOf('.');
-
-    // Skip hostnames with one dot symbol for wildcard pattern search
-    //   example.com   will  be skipped
-    //   a.example.com won't be skipped
-    if (indexOfFirstDot != indexOfLastDot) {
-      // a.example.com -> search for wildcard pattern *.example.com
-      wildcardPins = hostnameToPins.get("*." + hostname.substring(indexOfFirstDot + 1));
-    }
-
-    if (directPins == null && wildcardPins == null) return null;
-
-    if (directPins != null && wildcardPins != null) {
-      Set<ByteString> pins = new LinkedHashSet<>();
-      pins.addAll(directPins);
-      pins.addAll(wildcardPins);
-      return pins;
+  List<Pin> findMatchingPins(String hostname) {
+    List<Pin> result = Collections.emptyList();
+    for (Pin pin : pins) {
+      if (pin.matches(hostname)) {
+        if (result.isEmpty()) result = new ArrayList<>();
+        result.add(pin);
+      }
     }
-
-    if (directPins != null) return directPins;
-
-    return wildcardPins;
+    return result;
   }
 
   Builder newBuilder() {
@@ -220,31 +213,89 @@ Builder newBuilder() {
   }
 
   /**
-   * Returns the SHA-1 of {@code certificate}'s public key. This uses the mechanism Moxie
-   * Marlinspike describes in <a href="https://github.com/moxie0/AndroidPinning">Android
-   * Pinning</a>.
+   * Returns the SHA-256 of {@code certificate}'s public key.
+   *
+   * <p>In OkHttp 3.1.2 and earlier, this returned a SHA-1 hash of the public key. Both types are
+   * supported, but SHA-256 is preferred.
    */
   public static String pin(Certificate certificate) {
     if (!(certificate instanceof X509Certificate)) {
       throw new IllegalArgumentException("Certificate pinning requires X509 certificates");
     }
-    return "sha1/" + sha1((X509Certificate) certificate).base64();
+    return "sha256/" + sha256((X509Certificate) certificate).base64();
   }
 
-  private static ByteString sha1(X509Certificate x509Certificate) {
+  static ByteString sha1(X509Certificate x509Certificate) {
     return Util.sha1(ByteString.of(x509Certificate.getPublicKey().getEncoded()));
   }
 
+  static ByteString sha256(X509Certificate x509Certificate) {
+    return Util.sha256(ByteString.of(x509Certificate.getPublicKey().getEncoded()));
+  }
+
+  static final class Pin {
+    /** A hostname like {@code example.com} or a pattern like {@code *.example.com}. */
+    final String pattern;
+    /** Either {@code sha1/} or {@code sha256/}. */
+    final String hashAlgorithm;
+    /** The hash of the pinned certificate using {@link #hashAlgorithm}. */
+    final ByteString hash;
+
+    Pin(String pattern, String pin) {
+      this.pattern = pattern;
+      if (pin.startsWith("sha1/")) {
+        this.hashAlgorithm = "sha1/";
+        this.hash = ByteString.decodeBase64(pin.substring("sha1/".length()));
+      } else if (pin.startsWith("sha256/")) {
+        this.hashAlgorithm = "sha256/";
+        this.hash = ByteString.decodeBase64(pin.substring("sha256/".length()));
+      } else {
+        throw new IllegalArgumentException("pins must start with 'sha256/' or 'sha1/': " + pin);
+      }
+
+      if (this.hash == null) {
+        throw new IllegalArgumentException("pins must be base64: " + pin);
+      }
+    }
+
+    boolean matches(String hostname) {
+      if (pattern.equals(hostname)) return true;
+
+      int firstDot = hostname.indexOf('.');
+      return pattern.startsWith("*.")
+          && hostname.regionMatches(false, firstDot + 1, pattern, 2, pattern.length() - 2);
+    }
+
+    @Override public boolean equals(Object other) {
+      return other instanceof Pin
+          && pattern.equals(((Pin) other).pattern)
+          && hashAlgorithm.equals(((Pin) other).hashAlgorithm)
+          && hash.equals(((Pin) other).hash);
+    }
+
+    @Override public int hashCode() {
+      int result = 17;
+      result = 31 * result + pattern.hashCode();
+      result = 31 * result + hashAlgorithm.hashCode();
+      result = 31 * result + hash.hashCode();
+      return result;
+    }
+
+    @Override public String toString() {
+      return hashAlgorithm + hash.base64();
+    }
+  }
+
   /** Builds a configured certificate pinner. */
   public static final class Builder {
-    private final Map<String, Set<ByteString>> hostnameToPins = new LinkedHashMap<>();
+    private final List<Pin> pins = new ArrayList<>();
     private TrustRootIndex trustRootIndex;
 
     public Builder() {
     }
 
     Builder(CertificatePinner certificatePinner) {
-      this.hostnameToPins.putAll(certificatePinner.hostnameToPins);
+      this.pins.addAll(certificatePinner.pins);
       this.trustRootIndex = certificatePinner.trustRootIndex;
     }
 
@@ -254,30 +305,17 @@ public Builder trustRootIndex(TrustRootIndex trustRootIndex) {
     }
 
     /**
-     * Pins certificates for {@code hostname}.
+     * Pins certificates for {@code pattern}.
      *
-     * @param hostname lower-case host name or wildcard pattern such as {@code *.example.com}.
-     * @param pins SHA-1 hashes. Each pin is a SHA-1 hash of a certificate's Subject Public Key
-     * Info, base64-encoded and prefixed with {@code sha1/}.
+     * @param pattern lower-case host name or wildcard pattern such as {@code *.example.com}.
+     * @param pins SHA-256 or SHA-1 hashes. Each pin is a hash of a certificate's Subject Public Key
+     * Info, base64-encoded and prefixed with either {@code sha256/} or {@code sha1/}.
      */
-    public Builder add(String hostname, String... pins) {
-      if (hostname == null) throw new IllegalArgumentException("hostname == null");
-
-      Set<ByteString> hostPins = new LinkedHashSet<>();
-      Set<ByteString> previousPins = hostnameToPins.put(hostname, unmodifiableSet(hostPins));
-      if (previousPins != null) {
-        hostPins.addAll(previousPins);
-      }
+    public Builder add(String pattern, String... pins) {
+      if (pattern == null) throw new IllegalArgumentException("pattern == null");
 
       for (String pin : pins) {
-        if (!pin.startsWith("sha1/")) {
-          throw new IllegalArgumentException("pins must start with 'sha1/': " + pin);
-        }
-        ByteString decodedPin = ByteString.decodeBase64(pin.substring("sha1/".length()));
-        if (decodedPin == null) {
-          throw new IllegalArgumentException("pins must be base64: " + pin);
-        }
-        hostPins.add(decodedPin);
+        this.pins.add(new Pin(pattern, pin));
       }
 
       return this;
diff --git a/okhttp/src/main/java/okhttp3/internal/Util.java b/okhttp/src/main/java/okhttp3/internal/Util.java
index e9efad04c6..2e83d65945 100644
--- a/okhttp/src/main/java/okhttp3/internal/Util.java
+++ b/okhttp/src/main/java/okhttp3/internal/Util.java
@@ -223,6 +223,17 @@ public static ByteString sha1(ByteString s) {
     }
   }
 
+  /** Returns a SHA-256 hash of {@code s}. */
+  public static ByteString sha256(ByteString s) {
+    try {
+      MessageDigest messageDigest = MessageDigest.getInstance("SHA-256");
+      byte[] sha1Bytes = messageDigest.digest(s.toByteArray());
+      return ByteString.of(sha1Bytes);
+    } catch (NoSuchAlgorithmException e) {
+      throw new AssertionError(e);
+    }
+  }
+
   /** Returns an immutable copy of {@code list}. */
   public static <T> List<T> immutableList(List<T> list) {
     return Collections.unmodifiableList(new ArrayList<>(list));
diff --git a/samples/guide/src/main/java/okhttp3/recipes/CertificatePinning.java b/samples/guide/src/main/java/okhttp3/recipes/CertificatePinning.java
index b890be7577..0dbf7aaf9a 100644
--- a/samples/guide/src/main/java/okhttp3/recipes/CertificatePinning.java
+++ b/samples/guide/src/main/java/okhttp3/recipes/CertificatePinning.java
@@ -29,10 +29,10 @@ public CertificatePinning() {
     client = new OkHttpClient.Builder()
         .certificatePinner(
             new CertificatePinner.Builder()
-                .add("publicobject.com", "sha1/DmxUShsZuNiqPQsX2Oi9uv2sCnw=")
-                .add("publicobject.com", "sha1/SXxoaOSEzPC6BgGmxAt/EAcsajw=")
-                .add("publicobject.com", "sha1/blhOM3W9V/bVQhsWAcLYwPU6n24=")
-                .add("publicobject.com", "sha1/T5x9IXmcrQ7YuQxXnxoCmeeQ84c=")
+                .add("publicobject.com", "sha256/afwiKY3RxoMmLkuRW1l7QsPZTJPwDS2pdDROQjXw8ig=")
+                .add("publicobject.com", "sha256/klO23nT2ehFDXCfx3eHTDRESMz3asj1muO+4aIdjiuY=")
+                .add("publicobject.com", "sha256/grX4Ta9HpZx6tSHkmCrvpApTQGo67CYDnvprLg5yRME=")
+                .add("publicobject.com", "sha256/lCppFqbkrlJ3EcVFAkeip0+44VaoJUymbnOaEUk7tEU=")
                 .build())
         .build();
   }
