diff --git a/.gitmodules b/.gitmodules
new file mode 100644
index 0000000000..d29f0b1218
--- /dev/null
+++ b/.gitmodules
@@ -0,0 +1,3 @@
+[submodule "okhttp-hpacktests/src/test/resources/hpack-test-case"]
+	path = okhttp-hpacktests/src/test/resources/hpack-test-case
+	url = git://github.com/http2jp/hpack-test-case.git
diff --git a/.travis.yml b/.travis.yml
index bc088e91bd..5ad8e98259 100644
--- a/.travis.yml
+++ b/.travis.yml
@@ -8,3 +8,4 @@ before_install:
 
 jdk:
   - oraclejdk7
+  - oraclejdk8
diff --git a/CHANGELOG.md b/CHANGELOG.md
index ff15ef0c0b..e64155601c 100644
--- a/CHANGELOG.md
+++ b/CHANGELOG.md
@@ -1,6 +1,205 @@
 Change Log
 ==========
 
+## Version 2.0.0
+
+This release commits to a stable 2.0 API. Read the 2.0.0-RC1 changes for advice
+on upgrading from 1.x to 2.x.
+
+_2014-06-21_
+
+ *  **API Change**: Use `IOException` in `Callback.onFailure()`. This is
+    a source-incompatible change, and is different from OkHttp 2.0.0-RC2 which
+    used `Throwable`.
+ *  Fix: Fixed a caching bug where we weren't storing rewritten request headers
+    like `Accept-Encoding`.
+ *  Fix: Fixed bugs in handling the SPDY window size. This was stalling certain
+    large downloads
+ *  Update the language level to Java 7. (OkHttp requires Android 2.3+ or Java 7+.)
+
+## Version 2.0.0-RC2
+
+_2014-06-11_
+
+This update fixes problems in 2.0.0-RC1. Read the 2.0.0-RC1 changes for
+advice on upgrading from 1.x to 2.x.
+
+ *  Fix: Don't leak connections! There was a regression in 2.0.0-RC1 where
+    connections were neither closed nor pooled.
+ *  Fix: Revert builder-style return types from OkHttpClient's timeout methods
+    for binary compatibility with OkHttp 1.x.
+ *  Fix: Don't skip client stream 1 on SPDY/3.1. This fixes SPDY connectivity to
+    `https://google.com`, which doesn't follow the SPDY/3.1 spec!
+ *  Fix: Always configure NPN headers. This fixes connectivity to
+    `https://facebook.com` when SPDY and HTTP/2 are both disabled. Otherwise an
+    unexpected NPN response is received and OkHttp crashes.
+ *  Fix: Write continuation frames when HPACK data is larger than 16383 bytes.
+ *  Fix: Don't drop uncaught exceptions thrown in async calls.
+ *  Fix: Throw an exception eagerly when a request body is not legal. Previously
+    we ignored the problem at request-building time, only to crash later with a
+    `NullPointerException`.
+ *  Fix: Include a backwards-compatible `OkHttp-Response-Source` header with
+    `OkUrlFactory `responses.
+ *  Fix: Don't include a default User-Agent header in requests made with the Call
+    API. Requests made with OkUrlFactory will continue to have a default user
+    agent.
+ *  New: Guava-like API to create headers:
+
+    ```
+    Headers headers = Headers.of(name1, value1, name2, value2, ...).
+    ```
+
+ *  New: Make the content-type header optional for request bodies.
+ *  New: `Response.isSuccessful()` is a convenient API to check response codes.
+ *  New: The response body can now be read outside of the callback. Response
+    bodies must always be closed, otherwise they will leak connections!
+ *  New: APIs to create multipart request bodies (`MultipartBuilder`) and form
+    encoding bodies (`FormEncodingBuilder`).
+
+## Version 2.0.0-RC1
+
+_2014-05-23_
+
+OkHttp 2 is designed around a new API that is true to HTTP, with classes for
+requests, responses, headers, and calls. It uses modern Java patterns like
+immutability and chained builders. The API now offers asynchronous callbacks
+in addition to synchronous blocking calls.
+
+#### API Changes
+
+ *  **New Request and Response types,** each with their own builder. There's also
+    a `RequestBody` class to write the request body to the network and a
+    `ResponseBody` to read the response body from the network. The standalone
+    `Headers` class offers full access to the HTTP headers.
+
+ *  **Okio dependency added.** OkHttp now depends on
+    [Okio](https://github.com/square/okio), an I/O library that makes it easier
+    to access, store and process data. Using this library internally makes OkHttp
+    faster while consuming less memory. You can write a `RequestBody` as an Okio
+    `BufferedSink` and a `ResponseBody` as an Okio `BufferedSource`. Standard
+    `InputStream` and `OutputStream` access is also available.
+
+ *  **New Call and Callback types** execute requests and receive their
+    responses. Both types of calls can be canceled via the `Call` or the
+    `OkHttpClient`.
+
+ *  **URLConnection support has moved to the okhttp-urlconnection module.**
+    If you're upgrading from 1.x, this change will impact you. You will need to
+    add the `okhttp-urlconnection` module to your project and use the
+    `OkUrlFactory` to create new instances of `HttpURLConnection`:
+
+    ```
+    // OkHttp 1.x:
+    HttpURLConnection connection = client.open(url);
+
+    // OkHttp 2.x:
+    HttpURLConnection connection = new OkUrlFactory(client).open(url);
+    ```
+
+ *  **Custom caches are no longer supported.** In OkHttp 1.x it was possible to
+    define your own response cache with the `java.net.ResponseCache` and OkHttp's
+    `OkResponseCache` interfaces. Both of these APIs have been dropped. In
+    OkHttp 2 the built-in disk cache is the only supported response cache.
+
+ *  **HttpResponseCache has been renamed to Cache.** Install it with
+    `OkHttpClient.setCache(...)` instead of `OkHttpClient.setResponseCache(...)`.
+
+ *  **OkAuthenticator has been replaced with Authenticator.** This new
+    authenticator has access to the full incoming response and can respond with
+    whichever followup request is appropriate. The `Challenge` class is now a
+    top-level class and `Credential` is replaced with a utility class called
+    `Credentials`.
+
+ *  **OkHttpClient.getFollowProtocolRedirects() renamed to
+    getFollowSslRedirects()**. We reserve the word _protocol_ for the HTTP
+    version being used (HTTP/1.1, HTTP/2). The old name of this method was
+    misleading; it was always used to configure redirects between `https://` and
+    `http://` schemes.
+
+ *  **RouteDatabase is no longer public API.** OkHttp continues to track which
+    routes have failed but this is no exposed in the API.
+
+ *  **ResponseSource is gone.** This enum exposed whether a response came from
+    the cache, network, or both. OkHttp 2 offers more detail with raw access to
+    the cache and network responses in the new `Response` class.
+
+ *  **TunnelRequest is gone.** It specified how to connect to an HTTP proxy.
+    OkHttp 2 uses the new `Request` class for this.
+
+ *  **Dispatcher** is a new class to manages the queue of asynchronous calls. It
+    implements limits on total in-flight calls and in-flight calls per host.
+
+#### Implementation changes
+
+ * Support Android `TrafficStats` socket tagging.
+ * Drop authentication headers on redirect.
+ * Added support for compressed data frames.
+ * Process push promise callbacks in order.
+ * Update to http/2 draft 12.
+ * Update to HPACK draft 07.
+ * Add ALPN support. Maven will use ALPN on OpenJDK 8.
+ * Update NPN dependency to target `jdk7u60-b13` and `Oracle jdk7u55-b13`.
+ * Ensure SPDY variants support zero-length DELETE and POST.
+ * Prevent leaking a cache item's InputStreams when metadata read fails.
+ * Use a string to identify TLS versions in routes.
+ * Add frame logger for HTTP/2.
+ * Replacing `httpMinorVersion` with `Protocol`. Expose HTTP/1.0 as a potential protocol.
+ * Use `Protocol` to describe framing.
+ * Implement write timeouts for HTTP/1.1 streams.
+ * Avoid use of SPDY stream ID 1, as that's typically used for UPGRADE.
+ * Support OAuth in `Authenticator`.
+ * Permit a dangling semicolon in media type parsing.
+
+## Version 1.6.0
+
+_2014-05-23_
+
+ * Offer bridges to make it easier to migrate from OkHttp 1.x to OkHttp 2.0.
+   This adds `OkUrlFactory`, `Cache`, and `@Deprecated` annotations for APIs
+   dropped in 2.0.
+
+## Version 1.5.4
+
+_2014-04-14_
+
+ * Drop ALPN support in Android. There's a concurrency bug in all
+   currently-shipping versions.
+ * Support asynchronous disconnects by breaking the socket only. This should
+   prevent flakiness from multiple threads concurrently accessing a stream.
+
+## Version 1.5.3
+
+_2014-03-29_
+
+ * Fix bug where the Content-Length header was not always dropped when
+   following a redirect from a POST to a GET.
+ * Implement basic support for `Thread.interrupt()`. OkHttp now checks
+   for an interruption before doing a blocking call. If it is interrupted,
+   it throws an `InterruptedIOException`.
+
+## Version 1.5.2
+
+_2014-03-17_
+
+ * Fix bug where deleting a file that was absent from the `HttpResponseCache`
+   caused an IOException.
+ * Fix bug in HTTP/2 where our HPACK decoder wasn't emitting entries in
+   certain eviction scenarios, leading to dropped response headers.
+
+## Version 1.5.1
+
+_2014-03-11_
+
+ * Fix 1.5.0 regression where connections should not have been recycled.
+ * Fix 1.5.0 regression where transparent Gzip was broken by attempting to
+   recover from another I/O failure.
+ * Fix problems where spdy/3.1 headers may not have been compressed properly.
+ * Fix problems with spdy/3.1 and http/2 where the wrong window size was being
+   used.
+ * Fix 1.5.0 regression where conditional cache responses could corrupt the
+   connection pool.
+
+
 ## Version 1.5.0
 
 _2014-03-07_
diff --git a/README.md b/README.md
index cd3bd0241d..1f80f44afb 100644
--- a/README.md
+++ b/README.md
@@ -1,16 +1,12 @@
 OkHttp
 ======
 
-An HTTP & SPDY client for Android and Java applications.
-
-For more information please see [the website][1].
-
-
+An HTTP & SPDY client for Android and Java applications. For more information see [the website][1] and [the wiki][2].
 
 Download
 --------
 
-Download [the latest JAR][2] or grab via Maven:
+Download [the latest JAR][3] or grab via Maven:
 
 ```xml
 <dependency>
@@ -21,45 +17,6 @@ Download [the latest JAR][2] or grab via Maven:
 ```
 
 
-Building
---------
-
-OkHttp requires Java 7 to build and run tests. Runtime compatibility with Java 6 is enforced as
-part of the build to ensure compliance with Android and older versions of the JVM.
-
-
-
-Testing
--------
-
-### On the Desktop
-
-Run OkHttp tests on the desktop with Maven. Running SPDY tests on the desktop uses
-[Jetty-NPN][3] which requires OpenJDK 7+.
-
-```
-mvn clean test
-```
-
-### On a Device
-
-OkHttp's test suite creates an in-process HTTPS server. Prior to Android 2.3, SSL server sockets
-were broken, and so HTTPS tests will time out when run on such devices.
-
-Test on a USB-attached Android using [Vogar][4]. Unfortunately `dx` requires that you build with
-Java 6, otherwise the test class will be silently omitted from the `.dex` file.
-
-```
-mvn clean
-mvn package -DskipTests
-vogar \
-    --classpath ~/.m2/repository/org/bouncycastle/bcprov-jdk15on/1.48/bcprov-jdk15on-1.48.jar \
-    --classpath mockwebserver/target/mockwebserver-2.0.0-SNAPSHOT.jar \
-    --classpath okhttp-protocols/target/okhttp-protocols-2.0.0-SNAPSHOT.jar \
-    --classpath okhttp/target/okhttp-2.0.0-SNAPSHOT.jar \
-    okhttp/src/test
-```
-
 MockWebServer
 -------------
 
@@ -69,7 +26,7 @@ MockWebServer coupling with OkHttp is essential for proper testing of SPDY and H
 
 ### Download
 
-Download [the latest JAR][5] or grab via Maven:
+Download [the latest JAR][4] or grab via Maven:
 
 ```xml
 <dependency>
@@ -97,10 +54,7 @@ License
     limitations under the License.
 
 
-
-
  [1]: http://square.github.io/okhttp
- [2]: http://repository.sonatype.org/service/local/artifact/maven/redirect?r=central-proxy&g=com.squareup.okhttp&a=okhttp&v=LATEST
- [3]: http://wiki.eclipse.org/Jetty/Feature/NPN
- [4]: https://code.google.com/p/vogar/
- [5]: http://repository.sonatype.org/service/local/artifact/maven/redirect?r=central-proxy&g=com.squareup.okhttp&a=mockwebserver&v=LATEST
+ [2]: https://github.com/square/okhttp/wiki
+ [3]: http://repository.sonatype.org/service/local/artifact/maven/redirect?r=central-proxy&g=com.squareup.okhttp&a=okhttp&v=LATEST
+ [4]: http://repository.sonatype.org/service/local/artifact/maven/redirect?r=central-proxy&g=com.squareup.okhttp&a=mockwebserver&v=LATEST
diff --git a/benchmarks/pom.xml b/benchmarks/pom.xml
index 6425e64f10..0a48fbd00b 100644
--- a/benchmarks/pom.xml
+++ b/benchmarks/pom.xml
@@ -6,7 +6,7 @@
   <parent>
     <groupId>com.squareup.okhttp</groupId>
     <artifactId>parent</artifactId>
-    <version>2.0.0-SNAPSHOT</version>
+    <version>2.0.1-SNAPSHOT</version>
   </parent>
 
   <artifactId>benchmarks</artifactId>
@@ -29,6 +29,11 @@
       <artifactId>okhttp</artifactId>
       <version>${project.version}</version>
     </dependency>
+    <dependency>
+      <groupId>com.squareup.okhttp</groupId>
+      <artifactId>okhttp-urlconnection</artifactId>
+      <version>${project.version}</version>
+    </dependency>
     <dependency>
       <groupId>com.squareup.okhttp</groupId>
       <artifactId>mockwebserver</artifactId>
@@ -38,11 +43,6 @@
       <groupId>org.bouncycastle</groupId>
       <artifactId>bcprov-jdk15on</artifactId>
     </dependency>
-    <dependency>
-      <groupId>org.mortbay.jetty.npn</groupId>
-      <artifactId>npn-boot</artifactId>
-      <scope>provided</scope>
-    </dependency>
     <dependency>
       <groupId>org.apache.httpcomponents</groupId>
       <artifactId>httpclient</artifactId>
@@ -71,28 +71,70 @@
   </dependencies>
   <build>
     <plugins>
-    <plugin>
-      <groupId>org.codehaus.mojo</groupId>
-      <artifactId>exec-maven-plugin</artifactId>
-      <executions>
-        <execution>
-          <goals>
-            <goal>java</goal>
-          </goals>
-        </execution>
-      </executions>
-      <configuration>
-        <executable>java</executable>
-        <arguments>
-          <argument>-Xms512m</argument>
-          <argument>-Xmx512m</argument>
-          <commandlineArgs>-Xbootclasspath/p:${settings.localRepository}/org/mortbay/jetty/npn/npn-boot/${npn.version}/npn-boot-${npn.version}.jar</commandlineArgs>
-          <argument>-classpath</argument>
-          <classpath/>
-          <argument>com.squareup.okhttp.benchmarks.Benchmark</argument>
-        </arguments>
-      </configuration>
-    </plugin>
+      <plugin>
+        <groupId>org.codehaus.mojo</groupId>
+        <artifactId>exec-maven-plugin</artifactId>
+        <executions>
+          <execution>
+            <goals>
+              <goal>java</goal>
+            </goals>
+          </execution>
+        </executions>
+        <configuration>
+          <executable>java</executable>
+          <arguments>
+            <argument>-Xms512m</argument>
+            <argument>-Xmx512m</argument>
+            <commandlineArgs>-Xbootclasspath/p:${bootclasspath}</commandlineArgs>
+            <argument>-classpath</argument>
+            <classpath />
+            <argument>com.squareup.okhttp.benchmarks.Benchmark</argument>
+          </arguments>
+        </configuration>
+      </plugin>
     </plugins>
   </build>
+  <profiles>
+    <profile>
+      <id>npn-when-jdk7</id>
+      <activation>
+        <jdk>1.7</jdk>
+      </activation>
+      <dependencies>
+        <dependency>
+          <groupId>org.mortbay.jetty.npn</groupId>
+          <artifactId>npn-boot</artifactId>
+          <scope>provided</scope>
+        </dependency>
+      </dependencies>
+    </profile>
+    <profile>
+      <id>alpn-when-jdk8</id>
+      <activation>
+        <jdk>1.8</jdk>
+      </activation>
+      <dependencies>
+        <dependency>
+          <groupId>org.mortbay.jetty.alpn</groupId>
+          <artifactId>alpn-boot</artifactId>
+          <scope>provided</scope>
+        </dependency>
+      </dependencies>
+      <build>
+        <plugins>
+          <plugin>
+            <!-- Fails on caliper's ASM on OpenJDK 8. -->
+            <groupId>org.codehaus.mojo</groupId>
+            <artifactId>animal-sniffer-maven-plugin</artifactId>
+            <executions>
+              <execution>
+                <phase>none</phase>
+              </execution>
+            </executions>
+          </plugin>
+        </plugins>
+      </build>
+    </profile>
+  </profiles>
 </project>
diff --git a/benchmarks/src/main/java/com/squareup/okhttp/benchmarks/Benchmark.java b/benchmarks/src/main/java/com/squareup/okhttp/benchmarks/Benchmark.java
index 151128d6c0..7efa32e418 100644
--- a/benchmarks/src/main/java/com/squareup/okhttp/benchmarks/Benchmark.java
+++ b/benchmarks/src/main/java/com/squareup/okhttp/benchmarks/Benchmark.java
@@ -37,6 +37,7 @@
 import java.util.logging.Logger;
 import java.util.zip.GZIPOutputStream;
 import javax.net.ssl.SSLContext;
+import okio.Buffer;
 
 /**
  * This benchmark is fake, but may be useful for certain relative comparisons.
@@ -83,10 +84,10 @@
   int headerCount;
 
   /** Which ALPN/NPN protocols are in use. Only useful with TLS. */
-  List<Protocol> protocols = Arrays.asList(Protocol.HTTP_11);
+  List<Protocol> protocols = Arrays.asList(Protocol.HTTP_1_1);
 
   public static void main(String[] args) {
-    List<String> allArgs = new ArrayList<String>();
+    List<String> allArgs = new ArrayList<>();
     allArgs.add("--instrument");
     allArgs.add("arbitrary");
     allArgs.addAll(Arrays.asList(args));
@@ -140,7 +141,7 @@ public double run() throws Exception {
   }
 
   @Override public String toString() {
-    List<Object> modifiers = new ArrayList<Object>();
+    List<Object> modifiers = new ArrayList<>();
     if (tls) modifiers.add("tls");
     if (gzip) modifiers.add("gzip");
     if (chunked) modifiers.add("chunked");
@@ -164,8 +165,7 @@ private MockWebServer startServer() throws IOException {
     if (tls) {
       SSLContext sslContext = SslContextBuilder.localhost();
       server.useHttps(sslContext.getSocketFactory(), false);
-      server.setNpnEnabled(true);
-      server.setNpnProtocols(protocols);
+      server.setProtocols(protocols);
     }
 
     final MockResponse response = newResponse();
@@ -191,7 +191,7 @@ private MockResponse newResponse() throws IOException {
     }
 
     if (chunked) {
-      result.setChunkedBody(body, 1024);
+      result.setChunkedBody(new Buffer().write(body), 1024);
     } else {
       result.setBody(body);
     }
diff --git a/benchmarks/src/main/java/com/squareup/okhttp/benchmarks/NettyHttpClient.java b/benchmarks/src/main/java/com/squareup/okhttp/benchmarks/NettyHttpClient.java
index 9044d0a33c..5d8cec5291 100644
--- a/benchmarks/src/main/java/com/squareup/okhttp/benchmarks/NettyHttpClient.java
+++ b/benchmarks/src/main/java/com/squareup/okhttp/benchmarks/NettyHttpClient.java
@@ -53,8 +53,8 @@
   private static final boolean VERBOSE = false;
 
   // Guarded by this. Real apps need more capable connection management.
-  private final Deque<HttpChannel> freeChannels = new ArrayDeque<HttpChannel>();
-  private final Deque<URL> backlog = new ArrayDeque<URL>();
+  private final Deque<HttpChannel> freeChannels = new ArrayDeque<>();
+  private final Deque<URL> backlog = new ArrayDeque<>();
 
   private int totalChannels = 0;
   private int concurrencyLevel;
diff --git a/benchmarks/src/main/java/com/squareup/okhttp/benchmarks/OkHttp.java b/benchmarks/src/main/java/com/squareup/okhttp/benchmarks/OkHttp.java
index 03b9e3c6f1..3885ed7f53 100644
--- a/benchmarks/src/main/java/com/squareup/okhttp/benchmarks/OkHttp.java
+++ b/benchmarks/src/main/java/com/squareup/okhttp/benchmarks/OkHttp.java
@@ -16,6 +16,7 @@
 package com.squareup.okhttp.benchmarks;
 
 import com.squareup.okhttp.OkHttpClient;
+import com.squareup.okhttp.OkUrlFactory;
 import com.squareup.okhttp.internal.SslContextBuilder;
 import java.io.IOException;
 import java.net.HttpURLConnection;
@@ -63,7 +64,7 @@ public OkHttpRequest(URL url) {
     public void run() {
       long start = System.nanoTime();
       try {
-        HttpURLConnection urlConnection = client.open(url);
+        HttpURLConnection urlConnection = new OkUrlFactory(client).open(url);
         long total = readAllAndClose(urlConnection.getInputStream());
         long finish = System.nanoTime();
 
diff --git a/benchmarks/src/main/java/com/squareup/okhttp/benchmarks/OkHttpAsync.java b/benchmarks/src/main/java/com/squareup/okhttp/benchmarks/OkHttpAsync.java
index b7633b76aa..ab7849017c 100644
--- a/benchmarks/src/main/java/com/squareup/okhttp/benchmarks/OkHttpAsync.java
+++ b/benchmarks/src/main/java/com/squareup/okhttp/benchmarks/OkHttpAsync.java
@@ -15,11 +15,12 @@
  */
 package com.squareup.okhttp.benchmarks;
 
+import com.squareup.okhttp.Callback;
 import com.squareup.okhttp.Dispatcher;
-import com.squareup.okhttp.Failure;
 import com.squareup.okhttp.OkHttpClient;
 import com.squareup.okhttp.Request;
 import com.squareup.okhttp.Response;
+import com.squareup.okhttp.ResponseBody;
 import com.squareup.okhttp.internal.SslContextBuilder;
 import java.io.IOException;
 import java.net.URL;
@@ -38,7 +39,7 @@
   private final AtomicInteger requestsInFlight = new AtomicInteger();
 
   private OkHttpClient client;
-  private Response.Receiver receiver;
+  private Callback callback;
   private int concurrencyLevel;
   private int targetBacklog;
 
@@ -63,13 +64,13 @@
       client.setHostnameVerifier(hostnameVerifier);
     }
 
-    receiver = new Response.Receiver() {
-      @Override public void onFailure(Failure failure) {
-        System.out.println("Failed: " + failure.exception());
+    callback = new Callback() {
+      @Override public void onFailure(Request request, IOException e) {
+        System.out.println("Failed: " + e);
       }
 
-      @Override public boolean onResponse(Response response) throws IOException {
-        Response.Body body = response.body();
+      @Override public void onResponse(Response response) throws IOException {
+        ResponseBody body = response.body();
         long total = SynchronousHttpClient.readAllAndClose(body.byteStream());
         long finish = System.nanoTime();
         if (VERBOSE) {
@@ -78,14 +79,13 @@
               total, TimeUnit.NANOSECONDS.toMillis(finish - start));
         }
         requestsInFlight.decrementAndGet();
-        return true;
       }
     };
   }
 
   @Override public void enqueue(URL url) throws Exception {
     requestsInFlight.incrementAndGet();
-    client.enqueue(new Request.Builder().tag(System.nanoTime()).url(url).build(), receiver);
+    client.newCall(new Request.Builder().tag(System.nanoTime()).url(url).build()).enqueue(callback);
   }
 
   @Override public synchronized boolean acceptingJobs() {
diff --git a/benchmarks/src/main/java/com/squareup/okhttp/benchmarks/UrlConnection.java b/benchmarks/src/main/java/com/squareup/okhttp/benchmarks/UrlConnection.java
index 79abb69eeb..630ec91c54 100644
--- a/benchmarks/src/main/java/com/squareup/okhttp/benchmarks/UrlConnection.java
+++ b/benchmarks/src/main/java/com/squareup/okhttp/benchmarks/UrlConnection.java
@@ -16,7 +16,6 @@
 package com.squareup.okhttp.benchmarks;
 
 import com.squareup.okhttp.internal.SslContextBuilder;
-import com.squareup.okhttp.internal.http.HttpsURLConnectionImpl;
 import java.io.IOException;
 import java.io.InputStream;
 import java.net.HttpURLConnection;
@@ -24,6 +23,7 @@
 import java.util.concurrent.TimeUnit;
 import java.util.zip.GZIPInputStream;
 import javax.net.ssl.HostnameVerifier;
+import javax.net.ssl.HttpsURLConnection;
 import javax.net.ssl.SSLContext;
 import javax.net.ssl.SSLSession;
 import javax.net.ssl.SSLSocketFactory;
@@ -41,8 +41,8 @@
           return true;
         }
       };
-      HttpsURLConnectionImpl.setDefaultHostnameVerifier(hostnameVerifier);
-      HttpsURLConnectionImpl.setDefaultSSLSocketFactory(socketFactory);
+      HttpsURLConnection.setDefaultHostnameVerifier(hostnameVerifier);
+      HttpsURLConnection.setDefaultSSLSocketFactory(socketFactory);
     }
   }
 
diff --git a/checkstyle.xml b/checkstyle.xml
index 794af42b68..f725be3381 100644
--- a/checkstyle.xml
+++ b/checkstyle.xml
@@ -56,7 +56,9 @@
     <module name="IllegalImport"/>
     <!-- defaults to sun.* packages -->
     <module name="RedundantImport"/>
-    <module name="UnusedImports"/>
+    <module name="UnusedImports">
+      <property name="processJavadoc" value="true"/>
+    </module>
 
 
     <!-- Checks for Size Violations.                    -->
diff --git a/concurrency.md b/concurrency.md
deleted file mode 100644
index 0858133a31..0000000000
--- a/concurrency.md
+++ /dev/null
@@ -1,63 +0,0 @@
-# Concurrency in OkHttp
-
-The HttpURLConnection API is a blocking API. You make a blocking write to send a request, and a blocking read to receive the response.
-
-#### Blocking APIs
-
-Blocking APIs are convenient because you get top-to-bottom procedural code without indirection. Network calls work like regular method calls: ask for data and it is returned. If the request fails, you get a stacktrace right were the call was made.
-
-Blocking APIs may be inefficient because you hold a thread idle while waiting on the network. Threads are expensive because they have both a memory overhead and a context-switching overhead.
-
-#### Framed protocols
-
-Framed protocols like spdy/3 and http/2 don't lend themselves to blocking APIs. Each application-layer thread wants to do blocking I/O for a specific stream, but the streams are multiplexed on the socket. You can't just talk to the socket, you need to cooperate with the other application-layer threads that you're sharing it with.
-
-Framing rules make it impractical to implement spdy/3 or http/2 correctly on a single blocking thread. The flow-control features introduce feedback between reads and writes, requiring writes to acknowledge reads and reads to throttle writes.
-
-In OkHttp we expose a blocking API over a framed protocol. This document explains the code and policy that makes that work.
-
-## Threads
-
-#### Application's calling thread
-
-The application-layer must block on writing I/O. We can't return from a write until we've pushed its bytes onto the socket. Otherwise, if the write fails we are unable to deliver its IOException to the application. We would have told the application layer that the write succeeded, but it didn't!
-
-The application-layer can also do blocking reads. If the application asks to read and there's nothing available, we need to hold that thread until either the bytes arrive, the stream is closed, or a timeout elapses. If we get bytes but there's nobody asking for them, we buffer them. We don't consider bytes as delivered for flow control until they're consumed by the application.
-
-Consider an application streaming a video over http/2. Perhaps the user pauses the video and the application stops reading bytes from this stream. The buffer will fill up, and flow control prevents the server from sending more data on this stream. When the user unpauses her video the buffer drains, the read is acknowledged, and the server proceeds to stream data.
-
-#### Shared reader thread
-
-We can't rely on application threads to read data from the socket. Application threads are transient: sometimes they're reading and writing and sometimes they're off doing application-layer things. But the socket is permanent, and it needs constant attention: we dispatch all incoming frames so the connection is good-to-go when the application layer needs it.
-
-So we have a dedicated thread for every socket that just reads frames and dispatches them.
-
-The reader thread must never run application-layer code. Otherwise one slow stream can hold up the entire connection.
-
-Similarly, the reader thread must never block on writing because this can deadlock the connection. Consider a client and server that both violate this rule. If you get unlucky, they could fill up their TCP buffers (so that writes block) and then use their reader threads to write a frame. Nobody is reading on either end, and the buffers are never drained.
-
-#### Do-stuff-later pool
-
-Sometimes there's an action required like calling the application layer or responding to a ping, and the thread discovering the action is not the thread that should do the work. We enqueue a runnable on this executor and it gets handled by one of the executor's threads.
-
-## Locks
-
-We have 3 different things that we synchronize on.
-
-#### SpdyConnection
-
-This lock guards internal state of each connection. This lock is never held for blocking operations. That means that we acquire the lock, read or write a few fields and release the lock. No I/O and no application-layer callbacks.
-
-#### SpdyStream
-
-This lock guards the internal state of each stream. As above, it is never held for blocking operations. When we need to hold an application thread to block a read, we use wait/notify on this lock. This works because the lock is released while `wait()` is waiting.
-
-#### FrameWriter
-
-Socket writes are guarded by the FrameWriter. Only one stream can write at a time so that messages are not interleaved. Writes are either made by application-layer threads or the do-stuff-later pool.
-
-### Holding multiple locks
-
-You're allowed to take the SpdyConnection lock while holding the FrameWriter lock. But not vice-versa. Because taking the FrameWriter lock can block.
-
-This is necessary for bookkeeping when creating new streams. Correct framing requires that stream IDs are sequential on the socket, so we need to bundle assigning the ID with sending the `SYN_STREAM` frame.
diff --git a/deploy_website.sh b/deploy_website.sh
index bac2744198..24d0c72b46 100755
--- a/deploy_website.sh
+++ b/deploy_website.sh
@@ -26,10 +26,20 @@ rm -rf *
 # Copy website files from real repo
 cp -R ../website/* .
 
-# Download the latest javadoc
-curl -L "http://repository.sonatype.org/service/local/artifact/maven/redirect?r=central-proxy&g=$GROUP_ID&a=$ARTIFACT_ID&v=LATEST&c=javadoc" > javadoc.zip
-mkdir javadoc
-unzip javadoc.zip -d javadoc
+# Download the latest javadoc to directories like 'javadoc' or 'javadoc-urlconnection'.
+for DOCUMENTED_ARTIFACT in okhttp okhttp-urlconnection okhttp-apache
+do
+  curl -L "http://repository.sonatype.org/service/local/artifact/maven/redirect?r=central-proxy&g=$GROUP_ID&a=$DOCUMENTED_ARTIFACT&v=LATEST&c=javadoc" > javadoc.zip
+  JAVADOC_DIR="javadoc${DOCUMENTED_ARTIFACT//okhttp/}"
+  mkdir $JAVADOC_DIR
+  unzip javadoc.zip -d $JAVADOC_DIR
+  rm javadoc.zip
+done
+
+# Download the 1.6.0 javadoc to '1.x/javadoc'.
+curl -L "http://repository.sonatype.org/service/local/artifact/maven/redirect?r=central-proxy&g=$GROUP_ID&a=$ARTIFACT_ID&v=1.6.0&c=javadoc" > javadoc.zip
+mkdir -p 1.x/javadoc
+unzip javadoc.zip -d 1.x/javadoc
 rm javadoc.zip
 
 # Stage all files in git and create a commit
diff --git a/mockwebserver/pom.xml b/mockwebserver/pom.xml
index 9c7af9d6ed..1feb9d934b 100644
--- a/mockwebserver/pom.xml
+++ b/mockwebserver/pom.xml
@@ -6,7 +6,7 @@
   <parent>
     <groupId>com.squareup.okhttp</groupId>
     <artifactId>parent</artifactId>
-    <version>2.0.0-SNAPSHOT</version>
+    <version>2.0.1-SNAPSHOT</version>
   </parent>
 
   <artifactId>mockwebserver</artifactId>
@@ -22,15 +22,10 @@
       <groupId>org.bouncycastle</groupId>
       <artifactId>bcprov-jdk15on</artifactId>
     </dependency>
-    <dependency>
-      <groupId>org.mortbay.jetty.npn</groupId>
-      <artifactId>npn-boot</artifactId>
-      <optional>true</optional>
-    </dependency>
     <dependency>
       <groupId>junit</groupId>
       <artifactId>junit</artifactId>
-      <scope>test</scope>
+      <optional>true</optional>
     </dependency>
   </dependencies>
 
diff --git a/mockwebserver/src/main/java/com/squareup/okhttp/internal/spdy/SpdyServer.java b/mockwebserver/src/main/java/com/squareup/okhttp/internal/spdy/SpdyServer.java
index 098f3c93be..9689f27afd 100644
--- a/mockwebserver/src/main/java/com/squareup/okhttp/internal/spdy/SpdyServer.java
+++ b/mockwebserver/src/main/java/com/squareup/okhttp/internal/spdy/SpdyServer.java
@@ -17,28 +17,29 @@
 package com.squareup.okhttp.internal.spdy;
 
 import com.squareup.okhttp.Protocol;
+import com.squareup.okhttp.internal.Platform;
 import com.squareup.okhttp.internal.SslContextBuilder;
 import com.squareup.okhttp.internal.Util;
 import java.io.File;
-import java.io.FileInputStream;
 import java.io.IOException;
-import java.io.InputStream;
 import java.net.ServerSocket;
 import java.net.Socket;
-import java.util.Arrays;
 import java.util.List;
 import javax.net.ssl.SSLSocket;
 import javax.net.ssl.SSLSocketFactory;
 import okio.BufferedSink;
 import okio.Okio;
-import org.eclipse.jetty.npn.NextProtoNego;
+import okio.Source;
 
 import static com.squareup.okhttp.internal.Util.headerEntries;
 
-/** A basic SPDY server that serves the contents of a local directory. */
+/** A basic SPDY/HTTP_2 server that serves the contents of a local directory. */
 public final class SpdyServer implements IncomingStreamHandler {
+  private final List<Protocol> spdyProtocols = Util.immutableList(Protocol.HTTP_2, Protocol.SPDY_3);
+
   private final File baseDirectory;
   private SSLSocketFactory sslSocketFactory;
+  private Protocol protocol;
 
   public SpdyServer(File baseDirectory) {
     this.baseDirectory = baseDirectory;
@@ -57,7 +58,7 @@ private void run() throws Exception {
       if (sslSocketFactory != null) {
         socket = doSsl(socket);
       }
-      new SpdyConnection.Builder(false, socket).handler(this).build();
+      new SpdyConnection.Builder(false, socket).protocol(protocol).handler(this).build();
     }
   }
 
@@ -66,17 +67,13 @@ private Socket doSsl(Socket socket) throws IOException {
         (SSLSocket) sslSocketFactory.createSocket(socket, socket.getInetAddress().getHostAddress(),
             socket.getPort(), true);
     sslSocket.setUseClientMode(false);
-    NextProtoNego.put(sslSocket, new NextProtoNego.ServerProvider() {
-      @Override public void unsupported() {
-        System.out.println("UNSUPPORTED");
-      }
-      @Override public List<String> protocols() {
-        return Arrays.asList(Protocol.SPDY_3.name.utf8());
-      }
-      @Override public void protocolSelected(String protocol) {
-        System.out.println("PROTOCOL SELECTED: " + protocol);
-      }
-    });
+    Platform.get().setProtocols(sslSocket, spdyProtocols);
+    sslSocket.startHandshake();
+    String protocolString = Platform.get().getSelectedProtocol(sslSocket);
+    protocol = protocolString != null ? Protocol.get(protocolString) : null;
+    if (protocol == null || !spdyProtocols.contains(protocol)) {
+      throw new IllegalStateException("Protocol " + protocol + " unsupported");
+    }
     return sslSocket;
   }
 
@@ -128,20 +125,16 @@ private void serveDirectory(SpdyStream stream, String[] files) throws IOExceptio
   }
 
   private void serveFile(SpdyStream stream, File file) throws IOException {
-    byte[] buffer = new byte[8192];
     stream.reply(
         headerEntries(":status", "200", ":version", "HTTP/1.1", "content-type", contentType(file)),
         true);
-    InputStream in = new FileInputStream(file);
-    BufferedSink out = Okio.buffer(stream.getSink());
+    Source source = Okio.source(file);
     try {
-      int count;
-      while ((count = in.read(buffer)) != -1) {
-        out.write(buffer, 0, count);
-      }
+      BufferedSink out = Okio.buffer(stream.getSink());
+      out.writeAll(source);
+      out.close();
     } finally {
-      Util.closeQuietly(in);
-      Util.closeQuietly(out);
+      Util.closeQuietly(source);
     }
   }
 
diff --git a/mockwebserver/src/main/java/com/squareup/okhttp/mockwebserver/Dispatcher.java b/mockwebserver/src/main/java/com/squareup/okhttp/mockwebserver/Dispatcher.java
index ac6bac4a0b..b7de9b67d4 100644
--- a/mockwebserver/src/main/java/com/squareup/okhttp/mockwebserver/Dispatcher.java
+++ b/mockwebserver/src/main/java/com/squareup/okhttp/mockwebserver/Dispatcher.java
@@ -24,11 +24,18 @@
   public abstract MockResponse dispatch(RecordedRequest request) throws InterruptedException;
 
   /**
-   * Returns the socket policy of the next request.  Default implementation
-   * returns {@link SocketPolicy#KEEP_OPEN}. Mischievous implementations can
-   * return other values to test HTTP edge cases.
+   * Returns an early guess of the next response, used for policy on how an
+   * incoming request should be received. The default implementation returns an
+   * empty response. Mischievous implementations can return other values to test
+   * HTTP edge cases, such as unhappy socket policies or throttled request
+   * bodies.
    */
-  public SocketPolicy peekSocketPolicy() {
-    return SocketPolicy.KEEP_OPEN;
+  public MockResponse peek() {
+    return new MockResponse().setSocketPolicy(SocketPolicy.KEEP_OPEN);
+  }
+
+  /** @deprecated replaced with {@link #peek}. */
+  protected final SocketPolicy peekSocketPolicy() {
+    throw new UnsupportedOperationException("This API is obsolete. Override peek() instead!");
   }
 }
diff --git a/mockwebserver/src/main/java/com/squareup/okhttp/mockwebserver/MockResponse.java b/mockwebserver/src/main/java/com/squareup/okhttp/mockwebserver/MockResponse.java
index 7d8e066c34..350c6f65ac 100644
--- a/mockwebserver/src/main/java/com/squareup/okhttp/mockwebserver/MockResponse.java
+++ b/mockwebserver/src/main/java/com/squareup/okhttp/mockwebserver/MockResponse.java
@@ -15,26 +15,22 @@
  */
 package com.squareup.okhttp.mockwebserver;
 
-import com.squareup.okhttp.internal.Util;
-import java.io.ByteArrayInputStream;
-import java.io.ByteArrayOutputStream;
-import java.io.IOException;
 import java.io.InputStream;
-import java.io.UnsupportedEncodingException;
 import java.util.ArrayList;
 import java.util.Iterator;
 import java.util.List;
 import java.util.concurrent.TimeUnit;
+import okio.Buffer;
 
 /** A scripted response to be replayed by the mock web server. */
 public final class MockResponse implements Cloneable {
   private static final String CHUNKED_BODY_HEADER = "Transfer-encoding: chunked";
 
   private String status = "HTTP/1.1 200 OK";
-  private List<String> headers = new ArrayList<String>();
+  private List<String> headers = new ArrayList<>();
 
   /** The response body content, or null if {@code bodyStream} is set. */
-  private byte[] body;
+  private Buffer body;
   /** The response body content, or null if {@code body} is set. */
   private InputStream bodyStream;
 
@@ -46,18 +42,18 @@
 
   private int bodyDelayTimeMs = 0;
 
-  private List<PushPromise> promises = new ArrayList<PushPromise>();
+  private List<PushPromise> promises = new ArrayList<>();
 
   /** Creates a new mock response with an empty body. */
   public MockResponse() {
-    setBody(new byte[0]);
+    setBody(new Buffer());
   }
 
   @Override public MockResponse clone() {
     try {
       MockResponse result = (MockResponse) super.clone();
-      result.headers = new ArrayList<String>(headers);
-      result.promises = new ArrayList<PushPromise>(promises);
+      result.headers = new ArrayList<>(headers);
+      result.promises = new ArrayList<>(promises);
       return result;
     } catch (CloneNotSupportedException e) {
       throw new AssertionError();
@@ -132,18 +128,22 @@ public MockResponse removeHeader(String name) {
   }
 
   /** Returns the raw HTTP payload, or null if this response is streamed. */
-  public byte[] getBody() {
-    return body;
+  public Buffer getBody() {
+    return body != null ? body.clone() : null; // Defensive copy.
   }
 
   /** Returns an input stream containing the raw HTTP payload. */
   InputStream getBodyStream() {
-    return bodyStream != null ? bodyStream : new ByteArrayInputStream(body);
+    return bodyStream != null ? bodyStream : getBody().inputStream();
   }
 
   public MockResponse setBody(byte[] body) {
-    setHeader("Content-Length", body.length);
-    this.body = body;
+    return setBody(new Buffer().write(body));
+  }
+
+  public MockResponse setBody(Buffer body) {
+    setHeader("Content-Length", body.size());
+    this.body = body.clone(); // Defensive copy.
     this.bodyStream = null;
     return this;
   }
@@ -157,39 +157,29 @@ public MockResponse setBody(InputStream bodyStream, long bodyLength) {
 
   /** Sets the response body to the UTF-8 encoded bytes of {@code body}. */
   public MockResponse setBody(String body) {
-    try {
-      return setBody(body.getBytes("UTF-8"));
-    } catch (UnsupportedEncodingException e) {
-      throw new AssertionError();
-    }
+    return setBody(new Buffer().writeUtf8(body));
   }
 
   /**
    * Sets the response body to {@code body}, chunked every {@code maxChunkSize}
    * bytes.
    */
-  public MockResponse setChunkedBody(byte[] body, int maxChunkSize) {
+  public MockResponse setChunkedBody(Buffer body, int maxChunkSize) {
     removeHeader("Content-Length");
     headers.add(CHUNKED_BODY_HEADER);
 
-    try {
-      ByteArrayOutputStream bytesOut = new ByteArrayOutputStream();
-      int pos = 0;
-      while (pos < body.length) {
-        int chunkSize = Math.min(body.length - pos, maxChunkSize);
-        bytesOut.write(Integer.toHexString(chunkSize).getBytes(Util.US_ASCII));
-        bytesOut.write("\r\n".getBytes(Util.US_ASCII));
-        bytesOut.write(body, pos, chunkSize);
-        bytesOut.write("\r\n".getBytes(Util.US_ASCII));
-        pos += chunkSize;
-      }
-      bytesOut.write("0\r\n\r\n".getBytes(Util.US_ASCII)); // Last chunk + empty trailer + crlf.
-
-      this.body = bytesOut.toByteArray();
-      return this;
-    } catch (IOException e) {
-      throw new AssertionError(); // In-memory I/O doesn't throw IOExceptions.
+    Buffer bytesOut = new Buffer();
+    while (!body.exhausted()) {
+      long chunkSize = Math.min(body.size(), maxChunkSize);
+      bytesOut.writeUtf8(Long.toHexString(chunkSize));
+      bytesOut.writeUtf8("\r\n");
+      bytesOut.write(body, chunkSize);
+      bytesOut.writeUtf8("\r\n");
     }
+    bytesOut.writeUtf8("0\r\n\r\n"); // Last chunk + empty trailer + CRLF.
+
+    this.body = bytesOut;
+    return this;
   }
 
   /**
@@ -197,11 +187,7 @@ public MockResponse setChunkedBody(byte[] body, int maxChunkSize) {
    * every {@code maxChunkSize} bytes.
    */
   public MockResponse setChunkedBody(String body, int maxChunkSize) {
-    try {
-      return setChunkedBody(body.getBytes("UTF-8"), maxChunkSize);
-    } catch (UnsupportedEncodingException e) {
-      throw new AssertionError();
-    }
+    return setChunkedBody(new Buffer().writeUtf8(body), maxChunkSize);
   }
 
   public SocketPolicy getSocketPolicy() {
@@ -251,8 +237,9 @@ public int getBodyDelayTimeMs() {
   }
 
   /**
-   * When {@link MockWebServer#setNpnProtocols(java.util.List) protocols}
-   * include a SPDY variant, this attaches a pushed stream to this response.
+   * When {@link MockWebServer#setProtocols(java.util.List) protocols}
+   * include {@linkplain com.squareup.okhttp.Protocol#HTTP_2}, this attaches a
+   * pushed stream to this response.
    */
   public MockResponse withPush(PushPromise promise) {
     this.promises.add(promise);
diff --git a/mockwebserver/src/main/java/com/squareup/okhttp/mockwebserver/MockWebServer.java b/mockwebserver/src/main/java/com/squareup/okhttp/mockwebserver/MockWebServer.java
index a1edf0ac0b..a80d7d6dee 100644
--- a/mockwebserver/src/main/java/com/squareup/okhttp/mockwebserver/MockWebServer.java
+++ b/mockwebserver/src/main/java/com/squareup/okhttp/mockwebserver/MockWebServer.java
@@ -55,6 +55,7 @@
 import java.util.concurrent.ExecutorService;
 import java.util.concurrent.Executors;
 import java.util.concurrent.LinkedBlockingQueue;
+import java.util.concurrent.TimeUnit;
 import java.util.concurrent.atomic.AtomicInteger;
 import java.util.logging.Level;
 import java.util.logging.Logger;
@@ -63,9 +64,10 @@
 import javax.net.ssl.SSLSocketFactory;
 import javax.net.ssl.TrustManager;
 import javax.net.ssl.X509TrustManager;
+import okio.Buffer;
 import okio.BufferedSink;
+import okio.BufferedSource;
 import okio.ByteString;
-import okio.OkBuffer;
 import okio.Okio;
 
 import static com.squareup.okhttp.mockwebserver.SocketPolicy.DISCONNECT_AT_START;
@@ -93,13 +95,11 @@
 
   private static final Logger logger = Logger.getLogger(MockWebServer.class.getName());
 
-  private final BlockingQueue<RecordedRequest> requestQueue =
-      new LinkedBlockingQueue<RecordedRequest>();
+  private final BlockingQueue<RecordedRequest> requestQueue = new LinkedBlockingQueue<>();
 
   /** All map values are Boolean.TRUE. (Collections.newSetFromMap isn't available in Froyo) */
-  private final Map<Socket, Boolean> openClientSockets = new ConcurrentHashMap<Socket, Boolean>();
-  private final Map<SpdyConnection, Boolean> openSpdyConnections
-      = new ConcurrentHashMap<SpdyConnection, Boolean>();
+  private final Map<Socket, Boolean> openClientSockets = new ConcurrentHashMap<>();
+  private final Map<SpdyConnection, Boolean> openSpdyConnections = new ConcurrentHashMap<>();
   private final AtomicInteger requestCount = new AtomicInteger();
   private int bodyLimit = Integer.MAX_VALUE;
   private ServerSocket serverSocket;
@@ -109,8 +109,9 @@
   private Dispatcher dispatcher = new QueueDispatcher();
 
   private int port = -1;
-  private boolean npnEnabled = true;
-  private List<Protocol> npnProtocols = Protocol.HTTP2_SPDY3_AND_HTTP;
+  private boolean protocolNegotiationEnabled = true;
+  private List<Protocol> protocols
+      = Util.immutableList(Protocol.HTTP_2, Protocol.SPDY_3, Protocol.HTTP_1_1);
 
   public int getPort() {
     if (port == -1) throw new IllegalStateException("Cannot retrieve port before calling play()");
@@ -165,9 +166,19 @@ public void setBodyLimit(int maxBodyLength) {
    * Sets whether NPN is used on incoming HTTPS connections to negotiate a
    * protocol like HTTP/1.1 or SPDY/3. Call this method to disable NPN and
    * SPDY.
+   * @deprecated Use {@link #setProtocolNegotiationEnabled}.
    */
   public void setNpnEnabled(boolean npnEnabled) {
-    this.npnEnabled = npnEnabled;
+    this.protocolNegotiationEnabled = npnEnabled;
+  }
+
+  /**
+   * Sets whether ALPN or NPN is used on incoming HTTPS connections to
+   * negotiate a protocol like HTTP/1.1 or HTTP/2. Call this method to disable
+   * negotiation and restrict connections to HTTP/1.1.
+   */
+  public void setProtocolNegotiationEnabled(boolean protocolNegotiationEnabled) {
+    this.protocolNegotiationEnabled = protocolNegotiationEnabled;
   }
 
   /**
@@ -176,16 +187,29 @@ public void setNpnEnabled(boolean npnEnabled) {
    *
    * @param protocols the protocols to use, in order of preference. The list
    *     must contain "http/1.1". It must not contain null.
+   * @deprecated Use {@link #setProtocols(java.util.List)}.
    */
   public void setNpnProtocols(List<Protocol> protocols) {
+    setProtocols(protocols);
+  }
+
+  /**
+   * Indicates the protocols supported by NPN or ALPN on incoming HTTPS
+   * connections. This list is ignored when
+   * {@link #setProtocolNegotiationEnabled negotiation is disabled}.
+   *
+   * @param protocols the protocols to use, in order of preference. The list
+   *     must contain {@linkplain Protocol#HTTP_1_1}. It must not contain null.
+   */
+  public void setProtocols(List<Protocol> protocols) {
     protocols = Util.immutableList(protocols);
-    if (!protocols.contains(Protocol.HTTP_11)) {
+    if (!protocols.contains(Protocol.HTTP_1_1)) {
       throw new IllegalArgumentException("protocols doesn't contain http/1.1: " + protocols);
     }
     if (protocols.contains(null)) {
       throw new IllegalArgumentException("protocols must not contain null");
     }
-    this.npnProtocols = Util.immutableList(protocols);
+    this.protocols = protocols;
   }
 
   /**
@@ -200,12 +224,30 @@ public void useHttps(SSLSocketFactory sslSocketFactory, boolean tunnelProxy) {
 
   /**
    * Awaits the next HTTP request, removes it, and returns it. Callers should
-   * use this to verify the request was sent as intended.
+   * use this to verify the request was sent as intended. This method will block until the
+   * request is available, possibly forever.
+   *
+   * @return the head of the request queue
    */
   public RecordedRequest takeRequest() throws InterruptedException {
     return requestQueue.take();
   }
 
+  /**
+   * Awaits the next HTTP request (waiting up to the
+   * specified wait time if necessary), removes it, and returns it. Callers should
+   * use this to verify the request was sent as intended within the given time.
+   *
+   * @param timeout how long to wait before giving up, in units of
+  *        {@code unit}
+   * @param unit a {@code TimeUnit} determining how to interpret the
+   *        {@code timeout} parameter
+   * @return the head of the request queue
+   */
+  public RecordedRequest takeRequest(int timeout, TimeUnit unit) throws InterruptedException {
+    return requestQueue.poll(timeout, unit);
+  }
+
   /**
    * Returns the number of HTTP requests received thus far by this server. This
    * may exceed the number of HTTP connections when connection reuse is in
@@ -276,7 +318,7 @@ private void acceptConnections() throws Exception {
           } catch (SocketException e) {
             return;
           }
-          SocketPolicy socketPolicy = dispatcher.peekSocketPolicy();
+          SocketPolicy socketPolicy = dispatcher.peek().getSocketPolicy();
           if (socketPolicy == DISCONNECT_AT_START) {
             dispatchBookkeepingRequest(0, socket);
             socket.close();
@@ -308,13 +350,13 @@ private void serveConnection(final Socket raw) {
       }
 
       public void processConnection() throws Exception {
-        Protocol protocol = Protocol.HTTP_11;
+        Protocol protocol = Protocol.HTTP_1_1;
         Socket socket;
         if (sslSocketFactory != null) {
           if (tunnelProxy) {
             createTunnel();
           }
-          SocketPolicy socketPolicy = dispatcher.peekSocketPolicy();
+          SocketPolicy socketPolicy = dispatcher.peek().getSocketPolicy();
           if (socketPolicy == FAIL_HANDSHAKE) {
             dispatchBookkeepingRequest(sequenceNumber, raw);
             processHandshakeFailure(raw);
@@ -326,22 +368,24 @@ public void processConnection() throws Exception {
           sslSocket.setUseClientMode(false);
           openClientSockets.put(socket, true);
 
-          if (npnEnabled) {
-            Platform.get().setNpnProtocols(sslSocket, npnProtocols);
+          if (protocolNegotiationEnabled) {
+            Platform.get().setProtocols(sslSocket, protocols);
           }
 
           sslSocket.startHandshake();
 
-          if (npnEnabled) {
-            ByteString selectedProtocol = Platform.get().getNpnSelectedProtocol(sslSocket);
-            protocol = Protocol.find(selectedProtocol);
+          if (protocolNegotiationEnabled) {
+            String protocolString = Platform.get().getSelectedProtocol(sslSocket);
+            protocol = protocolString != null
+                ? Protocol.get(protocolString)
+                : Protocol.HTTP_1_1;
           }
           openClientSockets.remove(raw);
         } else {
           socket = raw;
         }
 
-        if (protocol.spdyVariant) {
+        if (protocol != Protocol.HTTP_1_1) {
           SpdySocketHandler spdySocketHandler = new SpdySocketHandler(socket, protocol);
           SpdyConnection spdyConnection = new SpdyConnection.Builder(false, socket)
               .protocol(protocol)
@@ -373,7 +417,7 @@ public void processConnection() throws Exception {
        */
       private void createTunnel() throws IOException, InterruptedException {
         while (true) {
-          SocketPolicy socketPolicy = dispatcher.peekSocketPolicy();
+          SocketPolicy socketPolicy = dispatcher.peek().getSocketPolicy();
           if (!processOneRequest(raw, raw.getInputStream(), raw.getOutputStream())) {
             throw new IllegalStateException("Tunnel without any CONNECT!");
           }
@@ -392,6 +436,10 @@ private boolean processOneRequest(Socket socket, InputStream in, OutputStream ou
         requestCount.incrementAndGet();
         requestQueue.add(request);
         MockResponse response = dispatcher.dispatch(request);
+        if (response.getSocketPolicy() == SocketPolicy.DISCONNECT_AFTER_REQUEST) {
+          socket.close();
+          return false;
+        }
         writeResponse(out, response);
         if (response.getSocketPolicy() == SocketPolicy.DISCONNECT_AT_END) {
           in.close();
@@ -414,9 +462,8 @@ private void processHandshakeFailure(Socket raw) throws Exception {
     SSLContext context = SSLContext.getInstance("TLS");
     context.init(null, new TrustManager[] { UNTRUSTED_TRUST_MANAGER }, new SecureRandom());
     SSLSocketFactory sslSocketFactory = context.getSocketFactory();
-    SSLSocket socket =
-        (SSLSocket) sslSocketFactory.createSocket(raw, raw.getInetAddress().getHostAddress(),
-            raw.getPort(), true);
+    SSLSocket socket = (SSLSocket) sslSocketFactory.createSocket(
+        raw, raw.getInetAddress().getHostAddress(), raw.getPort(), true);
     try {
       socket.startHandshake(); // we're testing a handshake failure
       throw new AssertionError();
@@ -444,7 +491,7 @@ private RecordedRequest readRequest(Socket socket, InputStream in, OutputStream
       return null; // no request because the stream is exhausted
     }
 
-    List<String> headers = new ArrayList<String>();
+    List<String> headers = new ArrayList<>();
     long contentLength = -1;
     boolean chunked = false;
     boolean expectContinue = false;
@@ -474,10 +521,11 @@ private RecordedRequest readRequest(Socket socket, InputStream in, OutputStream
 
     boolean hasBody = false;
     TruncatingOutputStream requestBody = new TruncatingOutputStream();
-    List<Integer> chunkSizes = new ArrayList<Integer>();
+    List<Integer> chunkSizes = new ArrayList<>();
+    MockResponse throttlePolicy = dispatcher.peek();
     if (contentLength != -1) {
-      hasBody = true;
-      transfer(contentLength, in, requestBody);
+      hasBody = contentLength > 0;
+      throttledTransfer(throttlePolicy, in, requestBody, contentLength);
     } else if (chunked) {
       hasBody = true;
       while (true) {
@@ -487,7 +535,7 @@ private RecordedRequest readRequest(Socket socket, InputStream in, OutputStream
           break;
         }
         chunkSizes.add(chunkSize);
-        transfer(chunkSize, in, requestBody);
+        throttledTransfer(throttlePolicy, in, requestBody, chunkSize);
         readEmptyLine(in);
       }
     }
@@ -523,22 +571,35 @@ private void writeResponse(OutputStream out, MockResponse response) throws IOExc
 
     InputStream in = response.getBodyStream();
     if (in == null) return;
+    throttledTransfer(response, in, out, Long.MAX_VALUE);
+  }
+
+  /**
+   * Transfer bytes from {@code in} to {@code out} until either {@code length}
+   * bytes have been transferred or {@code in} is exhausted. The transfer is
+   * throttled according to {@code throttlePolicy}.
+   */
+  private void throttledTransfer(MockResponse throttlePolicy, InputStream in, OutputStream out,
+      long limit) throws IOException {
+    byte[] buffer = new byte[1024];
+    int bytesPerPeriod = throttlePolicy.getThrottleBytesPerPeriod();
+    long delayMs = throttlePolicy.getThrottleUnit().toMillis(throttlePolicy.getThrottlePeriod());
 
-    // Stream data in MTU-sized increments, sleeping every bytesPerPeriod bytes.
-    byte[] buffer = new byte[1452];
     while (true) {
-      int bytesPerPeriod = response.getThrottleBytesPerPeriod();
       for (int b = 0; b < bytesPerPeriod; ) {
-        int read = in.read(buffer, 0, Math.min(buffer.length, bytesPerPeriod - b));
+        int toRead = (int) Math.min(Math.min(buffer.length, limit), bytesPerPeriod - b);
+        int read = in.read(buffer, 0, toRead);
         if (read == -1) return;
 
         out.write(buffer, 0, read);
         out.flush();
         b += read;
+        limit -= read;
+
+        if (limit == 0) return;
       }
 
       try {
-        long delayMs = response.getThrottleUnit().toMillis(response.getThrottlePeriod());
         if (delayMs != 0) Thread.sleep(delayMs);
       } catch (InterruptedException e) {
         throw new AssertionError();
@@ -546,20 +607,6 @@ private void writeResponse(OutputStream out, MockResponse response) throws IOExc
     }
   }
 
-  /**
-   * Transfer bytes from {@code in} to {@code out} until either {@code length}
-   * bytes have been transferred or {@code in} is exhausted.
-   */
-  private void transfer(long length, InputStream in, OutputStream out) throws IOException {
-    byte[] buffer = new byte[1024];
-    while (length > 0) {
-      int count = in.read(buffer, 0, (int) Math.min(buffer.length, length));
-      if (count == -1) return;
-      out.write(buffer, 0, count);
-      length -= count;
-    }
-  }
-
   /**
    * Returns the text from {@code in} until the next "\r\n", or null if {@code
    * in} is exhausted.
@@ -635,13 +682,13 @@ private SpdySocketHandler(Socket socket, Protocol protocol) {
       writeResponse(stream, response);
       if (logger.isLoggable(Level.INFO)) {
         logger.info("Received request: " + request + " and responded: " + response
-            + " protocol is " + protocol.name.utf8());
+            + " protocol is " + protocol.toString());
       }
     }
 
     private RecordedRequest readRequest(SpdyStream stream) throws IOException {
       List<Header> spdyHeaders = stream.getRequestHeaders();
-      List<String> httpHeaders = new ArrayList<String>();
+      List<String> httpHeaders = new ArrayList<>();
       String method = "<:method omitted>";
       String path = "<:path omitted>";
       String version = protocol == Protocol.SPDY_3 ? "<:version omitted>" : "HTTP/1.1";
@@ -659,25 +706,21 @@ private RecordedRequest readRequest(SpdyStream stream) throws IOException {
         }
       }
 
-      InputStream bodyIn = Okio.buffer(stream.getSource()).inputStream();
-      ByteArrayOutputStream bodyOut = new ByteArrayOutputStream();
-      byte[] buffer = new byte[8192];
-      int count;
-      while ((count = bodyIn.read(buffer)) != -1) {
-        bodyOut.write(buffer, 0, count);
-      }
+      BufferedSource bodyIn = Okio.buffer(stream.getSource());
+      byte[] bodyOut = bodyIn.readByteArray();
       bodyIn.close();
+
       String requestLine = method + ' ' + path + ' ' + version;
       List<Integer> chunkSizes = Collections.emptyList(); // No chunked encoding for SPDY.
-      return new RecordedRequest(requestLine, httpHeaders, chunkSizes, bodyOut.size(),
-          bodyOut.toByteArray(), sequenceNumber.getAndIncrement(), socket);
+      return new RecordedRequest(requestLine, httpHeaders, chunkSizes, bodyOut.length,
+          bodyOut, sequenceNumber.getAndIncrement(), socket);
     }
 
     private void writeResponse(SpdyStream stream, MockResponse response) throws IOException {
       if (response.getSocketPolicy() == SocketPolicy.NO_RESPONSE) {
         return;
       }
-      List<Header> spdyHeaders = new ArrayList<Header>();
+      List<Header> spdyHeaders = new ArrayList<>();
       String[] statusParts = response.getStatus().split(" ", 2);
       if (statusParts.length != 2) {
         throw new AssertionError("Unexpected status: " + response.getStatus());
@@ -696,10 +739,8 @@ private void writeResponse(SpdyStream stream, MockResponse response) throws IOEx
         }
         spdyHeaders.add(new Header(headerParts[0], headerParts[1]));
       }
-      OkBuffer body = new OkBuffer();
-      if (response.getBody() != null) {
-        body.write(response.getBody());
-      }
+      Buffer body = response.getBody();
+      if (body == null) body = new Buffer();
       boolean closeStreamAfterHeaders = body.size() > 0 || !response.getPushPromises().isEmpty();
       stream.reply(spdyHeaders, closeStreamAfterHeaders);
       pushPromises(stream, response.getPushPromises());
@@ -713,7 +754,7 @@ private void writeResponse(SpdyStream stream, MockResponse response) throws IOEx
         }
         BufferedSink sink = Okio.buffer(stream.getSink());
         if (response.getThrottleBytesPerPeriod() == Integer.MAX_VALUE) {
-          sink.write(body, body.size());
+          sink.writeAll(body);
           sink.flush();
         } else {
           while (body.size() > 0) {
@@ -736,7 +777,7 @@ private void writeResponse(SpdyStream stream, MockResponse response) throws IOEx
 
     private void pushPromises(SpdyStream stream, List<PushPromise> promises) throws IOException {
       for (PushPromise pushPromise : promises) {
-        List<Header> pushedHeaders = new ArrayList<Header>();
+        List<Header> pushedHeaders = new ArrayList<>();
         pushedHeaders.add(new Header(stream.getConnection().getProtocol() == Protocol.SPDY_3
             ? Header.TARGET_HOST
             : Header.TARGET_AUTHORITY, getUrl(pushPromise.getPath()).getHost()));
@@ -754,9 +795,9 @@ private void pushPromises(SpdyStream stream, List<PushPromise> promises) throws
         List<Integer> chunkSizes = Collections.emptyList(); // No chunked encoding for SPDY.
         requestQueue.add(new RecordedRequest(requestLine, pushPromise.getHeaders(), chunkSizes, 0,
             Util.EMPTY_BYTE_ARRAY, sequenceNumber.getAndIncrement(), socket));
-        byte[] pushedBody = pushPromise.getResponse().getBody();
+        Buffer pushedBody = pushPromise.getResponse().getBody();
         SpdyStream pushedStream =
-            stream.getConnection().pushStream(stream.getId(), pushedHeaders, pushedBody.length > 0);
+            stream.getConnection().pushStream(stream.getId(), pushedHeaders, pushedBody.size() > 0);
         writeResponse(pushedStream, pushPromise.getResponse());
       }
     }
diff --git a/mockwebserver/src/main/java/com/squareup/okhttp/mockwebserver/QueueDispatcher.java b/mockwebserver/src/main/java/com/squareup/okhttp/mockwebserver/QueueDispatcher.java
index 0f0cb280e6..c9c206c17c 100644
--- a/mockwebserver/src/main/java/com/squareup/okhttp/mockwebserver/QueueDispatcher.java
+++ b/mockwebserver/src/main/java/com/squareup/okhttp/mockwebserver/QueueDispatcher.java
@@ -24,8 +24,7 @@
  * by calling {@link #enqueueResponse(MockResponse)}.
  */
 public class QueueDispatcher extends Dispatcher {
-  protected final BlockingQueue<MockResponse> responseQueue
-      = new LinkedBlockingQueue<MockResponse>();
+  protected final BlockingQueue<MockResponse> responseQueue = new LinkedBlockingQueue<>();
   private MockResponse failFastResponse;
 
   @Override public MockResponse dispatch(RecordedRequest request) throws InterruptedException {
@@ -44,14 +43,11 @@
     return responseQueue.take();
   }
 
-  @Override public SocketPolicy peekSocketPolicy() {
+  @Override public MockResponse peek() {
     MockResponse peek = responseQueue.peek();
-    if (peek == null) {
-      return failFastResponse != null
-          ? failFastResponse.getSocketPolicy()
-          : SocketPolicy.KEEP_OPEN;
-    }
-    return peek.getSocketPolicy();
+    if (peek != null) return peek;
+    if (failFastResponse != null) return failFastResponse;
+    return super.peek();
   }
 
   public void enqueueResponse(MockResponse response) {
diff --git a/mockwebserver/src/main/java/com/squareup/okhttp/mockwebserver/RecordedRequest.java b/mockwebserver/src/main/java/com/squareup/okhttp/mockwebserver/RecordedRequest.java
index 58b5d107c9..2e49a26eff 100644
--- a/mockwebserver/src/main/java/com/squareup/okhttp/mockwebserver/RecordedRequest.java
+++ b/mockwebserver/src/main/java/com/squareup/okhttp/mockwebserver/RecordedRequest.java
@@ -91,7 +91,7 @@ public String getHeader(String name) {
 
   /** Returns the headers named {@code name}. */
   public List<String> getHeaders(String name) {
-    List<String> result = new ArrayList<String>();
+    List<String> result = new ArrayList<>();
     name += ":";
     for (int i = 0, size = headers.size(); i < size; i++) {
       String header = headers.get(i);
diff --git a/mockwebserver/src/main/java/com/squareup/okhttp/mockwebserver/SocketPolicy.java b/mockwebserver/src/main/java/com/squareup/okhttp/mockwebserver/SocketPolicy.java
index 76701c4c92..e2d5f28481 100644
--- a/mockwebserver/src/main/java/com/squareup/okhttp/mockwebserver/SocketPolicy.java
+++ b/mockwebserver/src/main/java/com/squareup/okhttp/mockwebserver/SocketPolicy.java
@@ -44,6 +44,12 @@
    */
   DISCONNECT_AT_START,
 
+  /**
+   * Close connection after reading the request but before writing the response.
+   * Use this to simulate late connection pool failures.
+   */
+  DISCONNECT_AFTER_REQUEST,
+
   /** Don't trust the client during the SSL handshake. */
   FAIL_HANDSHAKE,
 
diff --git a/mockwebserver/src/main/java/com/squareup/okhttp/mockwebserver/rule/MockWebServerRule.java b/mockwebserver/src/main/java/com/squareup/okhttp/mockwebserver/rule/MockWebServerRule.java
new file mode 100644
index 0000000000..05c94cf1f6
--- /dev/null
+++ b/mockwebserver/src/main/java/com/squareup/okhttp/mockwebserver/rule/MockWebServerRule.java
@@ -0,0 +1,82 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.okhttp.mockwebserver.rule;
+
+import com.squareup.okhttp.mockwebserver.MockResponse;
+import com.squareup.okhttp.mockwebserver.MockWebServer;
+import com.squareup.okhttp.mockwebserver.RecordedRequest;
+import java.io.IOException;
+import java.net.URL;
+import java.util.logging.Level;
+import java.util.logging.Logger;
+import org.junit.rules.ExternalResource;
+
+/**
+ * Allows you to use {@link MockWebServer} as a JUnit test rule.
+ *
+ * <p>This rule starts {@link MockWebServer} on an available port before your test runs, and shuts
+ * it down after it completes.
+ */
+public class MockWebServerRule extends ExternalResource {
+  private static final Logger logger = Logger.getLogger(MockWebServerRule.class.getName());
+
+  private final MockWebServer server = new MockWebServer();
+  private boolean started;
+
+  @Override protected void before() {
+    if (started) return;
+    started = true;
+    try {
+      server.play();
+    } catch (IOException e) {
+      throw new RuntimeException(e);
+    }
+  }
+
+  @Override protected void after() {
+    try {
+      server.shutdown();
+    } catch (IOException e) {
+      logger.log(Level.WARNING, "MockWebServer shutdown failed", e);
+    }
+  }
+
+  public int getPort() {
+    if (!started) before();
+    return server.getPort();
+  }
+
+  public int getRequestCount() {
+    return server.getRequestCount();
+  }
+
+  public void enqueue(MockResponse response) {
+    server.enqueue(response);
+  }
+
+  public RecordedRequest takeRequest() throws InterruptedException {
+    return server.takeRequest();
+  }
+
+  public URL getUrl(String path) {
+    return server.getUrl(path);
+  }
+
+  /** For any other functionality, use the {@linkplain MockWebServer} directly. */
+  public MockWebServer get() {
+    return server;
+  }
+}
diff --git a/mockwebserver/src/test/java/com/squareup/okhttp/mockwebserver/CustomDispatcherTest.java b/mockwebserver/src/test/java/com/squareup/okhttp/mockwebserver/CustomDispatcherTest.java
index 7b7e1125cc..efd34742c5 100644
--- a/mockwebserver/src/test/java/com/squareup/okhttp/mockwebserver/CustomDispatcherTest.java
+++ b/mockwebserver/src/test/java/com/squareup/okhttp/mockwebserver/CustomDispatcherTest.java
@@ -22,78 +22,78 @@
 import java.util.List;
 import java.util.concurrent.CountDownLatch;
 import java.util.concurrent.atomic.AtomicInteger;
-import junit.framework.TestCase;
+import org.junit.After;
+import org.junit.Test;
 
-public class CustomDispatcherTest extends TestCase {
+import static org.junit.Assert.assertEquals;
 
-    private MockWebServer mockWebServer = new MockWebServer();
+public class CustomDispatcherTest {
+  private MockWebServer mockWebServer = new MockWebServer();
 
-    @Override
-    public void tearDown() throws Exception {
-        mockWebServer.shutdown();
-    }
+  @After public void tearDown() throws Exception {
+    mockWebServer.shutdown();
+  }
 
-    public void testSimpleDispatch() throws Exception {
-        mockWebServer.play();
-        final List<RecordedRequest> requestsMade = new ArrayList<RecordedRequest>();
-        final Dispatcher dispatcher = new Dispatcher() {
-            @Override
-            public MockResponse dispatch(RecordedRequest request) throws InterruptedException {
-                requestsMade.add(request);
-                return new MockResponse();
-            }
-        };
-        assertEquals(0, requestsMade.size());
-        mockWebServer.setDispatcher(dispatcher);
-        final URL url = mockWebServer.getUrl("/");
-        final HttpURLConnection conn = (HttpURLConnection) url.openConnection();
-        conn.getResponseCode(); // Force the connection to hit the "server".
-        // Make sure our dispatcher got the request.
-        assertEquals(1, requestsMade.size());
-    }
+  @Test public void simpleDispatch() throws Exception {
+    mockWebServer.play();
+    final List<RecordedRequest> requestsMade = new ArrayList<>();
+    final Dispatcher dispatcher = new Dispatcher() {
+      @Override
+      public MockResponse dispatch(RecordedRequest request) throws InterruptedException {
+        requestsMade.add(request);
+        return new MockResponse();
+      }
+    };
+    assertEquals(0, requestsMade.size());
+    mockWebServer.setDispatcher(dispatcher);
+    final URL url = mockWebServer.getUrl("/");
+    final HttpURLConnection conn = (HttpURLConnection) url.openConnection();
+    conn.getResponseCode(); // Force the connection to hit the "server".
+    // Make sure our dispatcher got the request.
+    assertEquals(1, requestsMade.size());
+  }
 
-    public void testOutOfOrderResponses() throws Exception {
-        AtomicInteger firstResponseCode = new AtomicInteger();
-        AtomicInteger secondResponseCode = new AtomicInteger();
-        mockWebServer.play();
-        final String secondRequest = "/bar";
-        final String firstRequest = "/foo";
-        final CountDownLatch latch = new CountDownLatch(1);
-        final Dispatcher dispatcher = new Dispatcher() {
-            @Override
-            public MockResponse dispatch(RecordedRequest request) throws InterruptedException {
-                if (request.getPath().equals(firstRequest)) {
-                    latch.await();
-                }
-                return new MockResponse();
-            }
-        };
-        mockWebServer.setDispatcher(dispatcher);
-        final Thread startsFirst = buildRequestThread(firstRequest, firstResponseCode);
-        startsFirst.start();
-        final Thread endsFirst = buildRequestThread(secondRequest, secondResponseCode);
-        endsFirst.start();
-        endsFirst.join();
-        assertEquals(0, firstResponseCode.get()); // First response is still waiting.
-        assertEquals(200, secondResponseCode.get()); // Second response is done.
-        latch.countDown();
-        startsFirst.join();
-        assertEquals(200, firstResponseCode.get()); // And now it's done!
-        assertEquals(200, secondResponseCode.get()); // (Still done).
-    }
-
-    private Thread buildRequestThread(final String path, final AtomicInteger responseCode) {
-        return new Thread(new Runnable() {
-            @Override public void run() {
-                final URL url = mockWebServer.getUrl(path);
-                final HttpURLConnection conn;
-                try {
-                    conn = (HttpURLConnection) url.openConnection();
-                    responseCode.set(conn.getResponseCode()); // Force the connection to hit the "server".
-                } catch (IOException e) {
-                }
-            }
-        });
-    }
+  @Test public void outOfOrderResponses() throws Exception {
+    AtomicInteger firstResponseCode = new AtomicInteger();
+    AtomicInteger secondResponseCode = new AtomicInteger();
+    mockWebServer.play();
+    final String secondRequest = "/bar";
+    final String firstRequest = "/foo";
+    final CountDownLatch latch = new CountDownLatch(1);
+    final Dispatcher dispatcher = new Dispatcher() {
+      @Override
+      public MockResponse dispatch(RecordedRequest request) throws InterruptedException {
+        if (request.getPath().equals(firstRequest)) {
+          latch.await();
+        }
+        return new MockResponse();
+      }
+    };
+    mockWebServer.setDispatcher(dispatcher);
+    final Thread startsFirst = buildRequestThread(firstRequest, firstResponseCode);
+    startsFirst.start();
+    final Thread endsFirst = buildRequestThread(secondRequest, secondResponseCode);
+    endsFirst.start();
+    endsFirst.join();
+    assertEquals(0, firstResponseCode.get()); // First response is still waiting.
+    assertEquals(200, secondResponseCode.get()); // Second response is done.
+    latch.countDown();
+    startsFirst.join();
+    assertEquals(200, firstResponseCode.get()); // And now it's done!
+    assertEquals(200, secondResponseCode.get()); // (Still done).
+  }
 
+  private Thread buildRequestThread(final String path, final AtomicInteger responseCode) {
+    return new Thread(new Runnable() {
+      @Override public void run() {
+        final URL url = mockWebServer.getUrl(path);
+        final HttpURLConnection conn;
+        try {
+          conn = (HttpURLConnection) url.openConnection();
+          responseCode.set(conn.getResponseCode()); // Force the connection to hit the "server".
+        } catch (IOException e) {
+        }
+      }
+    });
+  }
 }
diff --git a/mockwebserver/src/test/java/com/squareup/okhttp/mockwebserver/MockWebServerTest.java b/mockwebserver/src/test/java/com/squareup/okhttp/mockwebserver/MockWebServerTest.java
index 98efc44971..2b1651f187 100644
--- a/mockwebserver/src/test/java/com/squareup/okhttp/mockwebserver/MockWebServerTest.java
+++ b/mockwebserver/src/test/java/com/squareup/okhttp/mockwebserver/MockWebServerTest.java
@@ -28,8 +28,11 @@
 import java.util.Arrays;
 import java.util.Collections;
 import java.util.List;
+import java.util.concurrent.TimeUnit;
 import junit.framework.TestCase;
 
+import static java.util.concurrent.TimeUnit.NANOSECONDS;
+
 public final class MockWebServerTest extends TestCase {
 
     private MockWebServer server = new MockWebServer();
@@ -286,4 +289,53 @@ public void testStreamingResponseBody() throws Exception {
 
         assertEquals(-1, responseBody.read()); // The body is exhausted.
     }
+
+    /**
+     * Throttle the request body by sleeping 500ms after every 3 bytes. With a
+     * 6-byte request, this should yield one sleep for a total delay of 500ms.
+     */
+    public void testThrottleRequest() throws Exception {
+        server.enqueue(new MockResponse()
+            .throttleBody(3, 500, TimeUnit.MILLISECONDS));
+        server.play();
+
+        long startNanos = System.nanoTime();
+        URLConnection connection = server.getUrl("/").openConnection();
+        connection.setDoOutput(true);
+        connection.getOutputStream().write("ABCDEF".getBytes("UTF-8"));
+        InputStream in = connection.getInputStream();
+        assertEquals(-1, in.read());
+        long elapsedNanos = System.nanoTime() - startNanos;
+        long elapsedMillis = NANOSECONDS.toMillis(elapsedNanos);
+
+        assertTrue(String.format("Request + Response: %sms", elapsedMillis), elapsedMillis >= 500);
+        assertTrue(String.format("Request + Response: %sms", elapsedMillis), elapsedMillis < 1000);
+    }
+
+    /**
+     * Throttle the response body by sleeping 500ms after every 3 bytes. With a
+     * 6-byte response, this should yield one sleep for a total delay of 500ms.
+     */
+    public void testThrottleResponse() throws Exception {
+        server.enqueue(new MockResponse()
+            .setBody("ABCDEF")
+            .throttleBody(3, 500, TimeUnit.MILLISECONDS));
+        server.play();
+
+        long startNanos = System.nanoTime();
+        URLConnection connection = server.getUrl("/").openConnection();
+        InputStream in = connection.getInputStream();
+        assertEquals('A', in.read());
+        assertEquals('B', in.read());
+        assertEquals('C', in.read());
+        assertEquals('D', in.read());
+        assertEquals('E', in.read());
+        assertEquals('F', in.read());
+        assertEquals(-1, in.read());
+        long elapsedNanos = System.nanoTime() - startNanos;
+        long elapsedMillis = NANOSECONDS.toMillis(elapsedNanos);
+
+        assertTrue(String.format("Request + Response: %sms", elapsedMillis), elapsedMillis >= 500);
+        assertTrue(String.format("Request + Response: %sms", elapsedMillis), elapsedMillis < 1000);
+    }
 }
diff --git a/mockwebserver/src/test/java/com/squareup/okhttp/mockwebserver/rule/MockWebServerRuleTest.java b/mockwebserver/src/test/java/com/squareup/okhttp/mockwebserver/rule/MockWebServerRuleTest.java
new file mode 100644
index 0000000000..43ceebc6bb
--- /dev/null
+++ b/mockwebserver/src/test/java/com/squareup/okhttp/mockwebserver/rule/MockWebServerRuleTest.java
@@ -0,0 +1,84 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.okhttp.mockwebserver.rule;
+
+import com.squareup.okhttp.mockwebserver.MockResponse;
+import java.io.BufferedReader;
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.InputStreamReader;
+import java.net.ConnectException;
+import java.net.HttpURLConnection;
+import java.net.URL;
+import org.junit.After;
+import org.junit.Test;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertNotEquals;
+import static org.junit.Assert.assertTrue;
+import static org.junit.Assert.fail;
+
+public class MockWebServerRuleTest {
+
+  private MockWebServerRule server = new MockWebServerRule();
+
+  @After public void tearDown() {
+    server.after();
+  }
+
+  @Test public void whenRuleCreatedPortIsAvailable() throws IOException {
+    assertTrue(server.getPort() > 0);
+  }
+
+  @Test public void differentRulesGetDifferentPorts() throws IOException {
+    assertNotEquals(server.getPort(), new MockWebServerRule().getPort());
+  }
+
+  @Test public void beforePlaysServer() throws Exception {
+    server.before();
+    assertEquals(server.getPort(), server.get().getPort());
+    server.getUrl("/").openConnection().connect();
+  }
+
+  @Test public void afterStopsServer() throws Exception {
+    server.before();
+    server.after();
+
+    try {
+      server.getUrl("/").openConnection().connect();
+      fail();
+    } catch (ConnectException e) {
+    }
+  }
+
+  @Test public void typicalUsage() throws Exception {
+    server.before(); // Implicitly called when @Rule.
+
+    server.enqueue(new MockResponse().setBody("hello world"));
+
+    URL url = server.getUrl("/aaa");
+    HttpURLConnection connection = (HttpURLConnection) url.openConnection();
+    InputStream in = connection.getInputStream();
+    BufferedReader reader = new BufferedReader(new InputStreamReader(in));
+    assertEquals("hello world", reader.readLine());
+
+    assertEquals(1, server.getRequestCount());
+    assertEquals("GET /aaa HTTP/1.1", server.takeRequest().getRequestLine());
+
+    server.after(); // Implicitly called when @Rule.
+  }
+}
+
diff --git a/okcurl/pom.xml b/okcurl/pom.xml
index af0ba2e212..a442c7a97b 100644
--- a/okcurl/pom.xml
+++ b/okcurl/pom.xml
@@ -6,7 +6,7 @@
   <parent>
     <groupId>com.squareup.okhttp</groupId>
     <artifactId>parent</artifactId>
-    <version>2.0.0-SNAPSHOT</version>
+    <version>2.0.1-SNAPSHOT</version>
   </parent>
 
   <artifactId>okcurl</artifactId>
diff --git a/okcurl/src/main/java/com/squareup/okhttp/curl/Main.java b/okcurl/src/main/java/com/squareup/okhttp/curl/Main.java
index 9a45f20730..fe676f2b0c 100644
--- a/okcurl/src/main/java/com/squareup/okhttp/curl/Main.java
+++ b/okcurl/src/main/java/com/squareup/okhttp/curl/Main.java
@@ -15,16 +15,18 @@
  */
 package com.squareup.okhttp.curl;
 
-import com.google.common.base.Function;
 import com.google.common.base.Joiner;
-import com.google.common.collect.Lists;
 import com.squareup.okhttp.ConnectionPool;
 import com.squareup.okhttp.Headers;
 import com.squareup.okhttp.MediaType;
 import com.squareup.okhttp.OkHttpClient;
 import com.squareup.okhttp.Protocol;
 import com.squareup.okhttp.Request;
+import com.squareup.okhttp.RequestBody;
 import com.squareup.okhttp.Response;
+import com.squareup.okhttp.internal.http.StatusLine;
+import com.squareup.okhttp.internal.spdy.Http20Draft14;
+
 import io.airlift.command.Arguments;
 import io.airlift.command.Command;
 import io.airlift.command.HelpOption;
@@ -34,13 +36,20 @@
 import java.io.InputStream;
 import java.security.cert.CertificateException;
 import java.security.cert.X509Certificate;
-import java.util.Arrays;
 import java.util.List;
 import java.util.Properties;
+import java.util.logging.ConsoleHandler;
+import java.util.logging.Level;
+import java.util.logging.LogRecord;
+import java.util.logging.Logger;
+import java.util.logging.SimpleFormatter;
+import javax.net.ssl.HostnameVerifier;
 import javax.net.ssl.SSLContext;
+import javax.net.ssl.SSLSession;
 import javax.net.ssl.SSLSocketFactory;
 import javax.net.ssl.TrustManager;
 import javax.net.ssl.X509TrustManager;
+import okio.Okio;
 
 import static java.util.concurrent.TimeUnit.SECONDS;
 
@@ -70,12 +79,7 @@ private static String versionString() {
   }
 
   private static String protocols() {
-    return Joiner.on(", ").join(Lists.transform(Arrays.asList(Protocol.values()),
-        new Function<Protocol, String>() {
-          @Override public String apply(Protocol protocol) {
-            return protocol.name.utf8();
-          }
-        }));
+    return Joiner.on(", ").join(Protocol.values());
   }
 
   @Option(name = { "-X", "--request" }, description = "Specify request command to use")
@@ -106,6 +110,9 @@ private static String protocols() {
   @Option(name = { "-i", "--include" }, description = "Include protocol headers in the output")
   public boolean showHeaders;
 
+  @Option(name = "--frames", description = "Log HTTP/2 frames to STDERR")
+  public boolean showHttp2Frames;
+
   @Option(name = { "-e", "--referer" }, description = "Referer URL")
   public String referer;
 
@@ -127,12 +134,16 @@ private static String protocols() {
       return;
     }
 
+    if (showHttp2Frames) {
+      enableHttp2FrameLogging();
+    }
+
     client = createClient();
     Request request = createRequest();
     try {
-      Response response = client.execute(request);
+      Response response = client.newCall(request).execute();
       if (showHeaders) {
-        System.out.println(response.statusLine());
+        System.out.println(StatusLine.get(response));
         Headers headers = response.headers();
         for (int i = 0, count = headers.size(); i < count; i++) {
           System.out.println(headers.name(i) + ": " + headers.value(i));
@@ -140,16 +151,9 @@ private static String protocols() {
         System.out.println();
       }
 
-      Response.Body body = response.body();
-      byte[] buffer = new byte[1024];
-      while (body.ready()) {
-        int c = body.byteStream().read(buffer);
-        if (c == -1) {
-          return;
-        }
-        System.out.write(buffer, 0, c);
-      }
-      body.close();
+      response.body().source().readAll(Okio.sink(System.out));
+      response.body().close();
+      System.out.flush();
     } catch (IOException e) {
       e.printStackTrace();
     } finally {
@@ -159,7 +163,7 @@ private static String protocols() {
 
   private OkHttpClient createClient() {
     OkHttpClient client = new OkHttpClient();
-    client.setFollowProtocolRedirects(followRedirects);
+    client.setFollowSslRedirects(followRedirects);
     if (connectTimeout != DEFAULT_TIMEOUT) {
       client.setConnectTimeout(connectTimeout, SECONDS);
     }
@@ -168,6 +172,7 @@ private OkHttpClient createClient() {
     }
     if (allowInsecure) {
       client.setSslSocketFactory(createInsecureSslSocketFactory());
+      client.setHostnameVerifier(createInsecureHostnameVerifier());
     }
     // If we don't set this reference, there's no way to clean shutdown persistent connections.
     client.setConnectionPool(ConnectionPool.getDefault());
@@ -184,7 +189,7 @@ private String getRequestMethod() {
     return "GET";
   }
 
-  private Request.Body getRequestBody() {
+  private RequestBody getRequestBody() {
     if (data == null) {
       return null;
     }
@@ -202,7 +207,7 @@ private String getRequestMethod() {
       }
     }
 
-    return Request.Body.create(MediaType.parse(mimeType), bodyData);
+    return RequestBody.create(MediaType.parse(mimeType), bodyData);
   }
 
   Request createRequest() {
@@ -251,4 +256,25 @@ private static SSLSocketFactory createInsecureSslSocketFactory() {
       throw new AssertionError(e);
     }
   }
+
+  private static HostnameVerifier createInsecureHostnameVerifier() {
+    return new HostnameVerifier() {
+      @Override public boolean verify(String s, SSLSession sslSession) {
+        return true;
+      }
+    };
+  }
+
+  private static void enableHttp2FrameLogging() {
+    Logger logger = Logger.getLogger(Http20Draft14.class.getName());
+    logger.setLevel(Level.FINE);
+    ConsoleHandler handler = new ConsoleHandler();
+    handler.setLevel(Level.FINE);
+    handler.setFormatter(new SimpleFormatter() {
+      @Override public String format(LogRecord record) {
+        return String.format("%s%n", record.getMessage());
+      }
+    });
+    logger.addHandler(handler);
+  }
 }
diff --git a/okcurl/src/test/java/com/squareup/okhttp/curl/MainTest.java b/okcurl/src/test/java/com/squareup/okhttp/curl/MainTest.java
index 6a5b97298b..ed6394d09e 100644
--- a/okcurl/src/test/java/com/squareup/okhttp/curl/MainTest.java
+++ b/okcurl/src/test/java/com/squareup/okhttp/curl/MainTest.java
@@ -16,8 +16,9 @@
 package com.squareup.okhttp.curl;
 
 import com.squareup.okhttp.Request;
+import com.squareup.okhttp.RequestBody;
 import java.io.IOException;
-import okio.OkBuffer;
+import okio.Buffer;
 import org.junit.Test;
 
 import static com.squareup.okhttp.curl.Main.fromArgs;
@@ -41,7 +42,7 @@
 
   @Test public void dataPost() {
     Request request = fromArgs("-d", "foo", "http://example.com").createRequest();
-    Request.Body body = request.body();
+    RequestBody body = request.body();
     assertEquals("POST", request.method());
     assertEquals("http://example.com", request.urlString());
     assertEquals("application/x-form-urlencoded; charset=utf-8", body.contentType().toString());
@@ -50,7 +51,7 @@
 
   @Test public void dataPut() {
     Request request = fromArgs("-d", "foo", "-X", "PUT", "http://example.com").createRequest();
-    Request.Body body = request.body();
+    RequestBody body = request.body();
     assertEquals("PUT", request.method());
     assertEquals("http://example.com", request.urlString());
     assertEquals("application/x-form-urlencoded; charset=utf-8", body.contentType().toString());
@@ -60,7 +61,7 @@
   @Test public void contentTypeHeader() {
     Request request = fromArgs("-d", "foo", "-H", "Content-Type: application/json",
         "http://example.com").createRequest();
-    Request.Body body = request.body();
+    RequestBody body = request.body();
     assertEquals("POST", request.method());
     assertEquals("http://example.com", request.urlString());
     assertEquals("application/json; charset=utf-8", body.contentType().toString());
@@ -83,12 +84,11 @@
     assertNull(request.body());
   }
 
-  private static String bodyAsString(Request.Body body) {
+  private static String bodyAsString(RequestBody body) {
     try {
-      OkBuffer buffer = new OkBuffer();
+      Buffer buffer = new Buffer();
       body.writeTo(buffer);
-      return new String(buffer.readByteString(buffer.size()).toByteArray(),
-          body.contentType().charset());
+      return buffer.readString(body.contentType().charset());
     } catch (IOException e) {
       throw new RuntimeException(e);
     }
diff --git a/okhttp-apache/pom.xml b/okhttp-apache/pom.xml
index 14eb349b8d..a5b8d5a447 100644
--- a/okhttp-apache/pom.xml
+++ b/okhttp-apache/pom.xml
@@ -6,7 +6,7 @@
   <parent>
     <groupId>com.squareup.okhttp</groupId>
     <artifactId>parent</artifactId>
-    <version>2.0.0-SNAPSHOT</version>
+    <version>2.0.1-SNAPSHOT</version>
   </parent>
 
   <artifactId>okhttp-apache</artifactId>
@@ -18,12 +18,6 @@
       <artifactId>okhttp</artifactId>
       <version>${project.version}</version>
     </dependency>
-    <dependency>
-      <groupId>com.squareup.okhttp</groupId>
-      <artifactId>mockwebserver</artifactId>
-      <version>${project.version}</version>
-      <scope>test</scope>
-    </dependency>
     <dependency>
       <groupId>org.apache.httpcomponents</groupId>
       <artifactId>httpclient</artifactId>
@@ -35,5 +29,27 @@
       <artifactId>junit</artifactId>
       <scope>test</scope>
     </dependency>
+    <dependency>
+      <groupId>com.squareup.okhttp</groupId>
+      <artifactId>mockwebserver</artifactId>
+      <version>${project.version}</version>
+      <scope>test</scope>
+    </dependency>
   </dependencies>
+
+  <build>
+    <plugins>
+      <plugin>
+        <groupId>org.apache.maven.plugins</groupId>
+        <artifactId>maven-javadoc-plugin</artifactId>
+        <configuration>
+          <links>
+            <link>http://square.github.io/okhttp/javadoc/</link>
+            <link>http://hc.apache.org/httpcomponents-client-4.3.x/httpclient/apidocs/</link>
+            <link>https://hc.apache.org/httpcomponents-core-4.3.x/httpcore/apidocs/</link>
+          </links>
+        </configuration>
+      </plugin>
+    </plugins>
+  </build>
 </project>
diff --git a/okhttp-apache/src/main/java/com/squareup/okhttp/apache/HttpEntityBody.java b/okhttp-apache/src/main/java/com/squareup/okhttp/apache/HttpEntityBody.java
new file mode 100644
index 0000000000..fd7884cd80
--- /dev/null
+++ b/okhttp-apache/src/main/java/com/squareup/okhttp/apache/HttpEntityBody.java
@@ -0,0 +1,41 @@
+package com.squareup.okhttp.apache;
+
+import com.squareup.okhttp.MediaType;
+import com.squareup.okhttp.RequestBody;
+import java.io.IOException;
+import okio.BufferedSink;
+import org.apache.http.HttpEntity;
+
+/** Adapts an {@link HttpEntity} to OkHttp's {@link RequestBody}. */
+final class HttpEntityBody extends RequestBody {
+  private static final MediaType DEFAULT_MEDIA_TYPE = MediaType.parse("application/octet-stream");
+
+  private final HttpEntity entity;
+  private final MediaType mediaType;
+
+  HttpEntityBody(HttpEntity entity, String contentTypeHeader) {
+    this.entity = entity;
+
+    if (contentTypeHeader != null) {
+      mediaType = MediaType.parse(contentTypeHeader);
+    } else if (entity.getContentType() != null) {
+      mediaType = MediaType.parse(entity.getContentType().getValue());
+    } else {
+      // Apache is forgiving and lets you skip specifying a content type with an entity. OkHttp is
+      // not forgiving so we fall back to a generic type if it's missing.
+      mediaType = DEFAULT_MEDIA_TYPE;
+    }
+  }
+
+  @Override public long contentLength() {
+    return entity.getContentLength();
+  }
+
+  @Override public MediaType contentType() {
+    return mediaType;
+  }
+
+  @Override public void writeTo(BufferedSink sink) throws IOException {
+    entity.writeTo(sink.outputStream());
+  }
+}
diff --git a/okhttp-apache/src/main/java/com/squareup/okhttp/apache/OkApacheClient.java b/okhttp-apache/src/main/java/com/squareup/okhttp/apache/OkApacheClient.java
index 2c40f9aa8c..3cdfadb2d1 100644
--- a/okhttp-apache/src/main/java/com/squareup/okhttp/apache/OkApacheClient.java
+++ b/okhttp-apache/src/main/java/com/squareup/okhttp/apache/OkApacheClient.java
@@ -1,13 +1,15 @@
 // Copyright 2013 Square, Inc.
 package com.squareup.okhttp.apache;
 
+import com.squareup.okhttp.Headers;
 import com.squareup.okhttp.OkHttpClient;
+import com.squareup.okhttp.Request;
+import com.squareup.okhttp.RequestBody;
+import com.squareup.okhttp.Response;
+import com.squareup.okhttp.ResponseBody;
 import java.io.IOException;
-import java.io.InputStream;
-import java.net.HttpURLConnection;
 import java.net.InetSocketAddress;
 import java.net.Proxy;
-import java.net.URL;
 import org.apache.http.Header;
 import org.apache.http.HttpEntity;
 import org.apache.http.HttpEntityEnclosingRequest;
@@ -21,7 +23,6 @@
 import org.apache.http.conn.ClientConnectionManager;
 import org.apache.http.conn.params.ConnRouteParams;
 import org.apache.http.entity.InputStreamEntity;
-import org.apache.http.message.BasicHeader;
 import org.apache.http.message.BasicHttpResponse;
 import org.apache.http.params.AbstractHttpParams;
 import org.apache.http.params.HttpParams;
@@ -37,8 +38,65 @@
  * API. This includes the keep-alive strategy, cookie store, credentials provider, route planner
  * and others.
  */
-public class OkApacheClient implements HttpClient {
-  protected final OkHttpClient client;
+public final class OkApacheClient implements HttpClient {
+  private static Request transformRequest(HttpRequest request) {
+    Request.Builder builder = new Request.Builder();
+
+    RequestLine requestLine = request.getRequestLine();
+    String method = requestLine.getMethod();
+    builder.url(requestLine.getUri());
+
+    String contentType = null;
+    for (Header header : request.getAllHeaders()) {
+      String name = header.getName();
+      if ("Content-Type".equals(name)) {
+        contentType = header.getValue();
+      } else {
+        builder.header(name, header.getValue());
+      }
+    }
+
+    RequestBody body = null;
+    if (request instanceof HttpEntityEnclosingRequest) {
+      HttpEntity entity = ((HttpEntityEnclosingRequest) request).getEntity();
+      if (entity != null) {
+        // Wrap the entity in a custom Body which takes care of the content, length, and type.
+        body = new HttpEntityBody(entity, contentType);
+
+        Header encoding = entity.getContentEncoding();
+        if (encoding != null) {
+          builder.header(encoding.getName(), encoding.getValue());
+        }
+      }
+    }
+    builder.method(method, body);
+
+    return builder.build();
+  }
+
+  private static HttpResponse transformResponse(Response response) {
+    int code = response.code();
+    String message = response.message();
+    BasicHttpResponse httpResponse = new BasicHttpResponse(HTTP_1_1, code, message);
+
+    ResponseBody body = response.body();
+    InputStreamEntity entity = new InputStreamEntity(body.byteStream(), body.contentLength());
+    httpResponse.setEntity(entity);
+
+    Headers headers = response.headers();
+    for (int i = 0; i < headers.size(); i++) {
+      String name = headers.name(i);
+      String value = headers.value(i);
+      httpResponse.addHeader(name, value);
+      if ("Content-Type".equalsIgnoreCase(name)) {
+        entity.setContentType(value);
+      } else if ("Content-Encoding".equalsIgnoreCase(name)) {
+        entity.setContentEncoding(value);
+      }
+    }
+
+    return httpResponse;
+  }
 
   private final HttpParams params = new AbstractHttpParams() {
     @Override public Object getParameter(String name) {
@@ -75,6 +133,8 @@
     }
   };
 
+  private final OkHttpClient client;
+
   public OkApacheClient() {
     this(new OkHttpClient());
   }
@@ -83,14 +143,6 @@ public OkApacheClient(OkHttpClient client) {
     this.client = client;
   }
 
-  /**
-   * Returns a new HttpURLConnection customized for this application. Subclasses should override
-   * this to customize the connection.
-   */
-  protected HttpURLConnection openConnection(URL url) {
-    return client.open(url);
-  }
-
   @Override public HttpParams getParams() {
     return params;
   }
@@ -114,66 +166,9 @@ protected HttpURLConnection openConnection(URL url) {
 
   @Override public HttpResponse execute(HttpHost host, HttpRequest request, HttpContext context)
       throws IOException {
-    // Prepare the request headers.
-    RequestLine requestLine = request.getRequestLine();
-    URL url = new URL(requestLine.getUri());
-    HttpURLConnection connection = openConnection(url);
-    connection.setRequestMethod(requestLine.getMethod());
-    for (Header header : request.getAllHeaders()) {
-      connection.addRequestProperty(header.getName(), header.getValue());
-    }
-
-    // Stream the request body.
-    if (request instanceof HttpEntityEnclosingRequest) {
-      HttpEntity entity = ((HttpEntityEnclosingRequest) request).getEntity();
-      if (entity != null) {
-        connection.setDoOutput(true);
-        Header type = entity.getContentType();
-        if (type != null) {
-          connection.addRequestProperty(type.getName(), type.getValue());
-        }
-        Header encoding = entity.getContentEncoding();
-        if (encoding != null) {
-          connection.addRequestProperty(encoding.getName(), encoding.getValue());
-        }
-        if (entity.isChunked() || entity.getContentLength() < 0) {
-          connection.setChunkedStreamingMode(0);
-        } else if (entity.getContentLength() <= 8192) {
-          // Buffer short, fixed-length request bodies. This costs memory, but permits the request
-          // to be transparently retried if there is a connection failure.
-          connection.addRequestProperty("Content-Length", Long.toString(entity.getContentLength()));
-        } else {
-          connection.setFixedLengthStreamingMode((int) entity.getContentLength());
-        }
-        entity.writeTo(connection.getOutputStream());
-      }
-    }
-
-    // Read the response headers.
-    int responseCode = connection.getResponseCode();
-    String message = connection.getResponseMessage();
-    BasicHttpResponse response = new BasicHttpResponse(HTTP_1_1, responseCode, message);
-    // Get the response body ready to stream.
-    InputStream responseBody =
-        responseCode < HttpURLConnection.HTTP_BAD_REQUEST ? connection.getInputStream()
-            : connection.getErrorStream();
-    InputStreamEntity entity = new InputStreamEntity(responseBody, connection.getContentLength());
-    for (int i = 0; true; i++) {
-      String name = connection.getHeaderFieldKey(i);
-      if (name == null) {
-        break;
-      }
-      BasicHeader header = new BasicHeader(name, connection.getHeaderField(i));
-      response.addHeader(header);
-      if (name.equalsIgnoreCase("Content-Type")) {
-          entity.setContentType(header);
-      } else if (name.equalsIgnoreCase("Content-Encoding")) {
-          entity.setContentEncoding(header);
-      }
-    }
-    response.setEntity(entity);
-
-    return response;
+    Request okRequest = transformRequest(request);
+    Response okResponse = client.newCall(okRequest).execute();
+    return transformResponse(okResponse);
   }
 
   @Override public <T> T execute(HttpUriRequest request, ResponseHandler<? extends T> handler)
diff --git a/okhttp-apache/src/test/java/com/squareup/okhttp/apache/OkApacheClientTest.java b/okhttp-apache/src/test/java/com/squareup/okhttp/apache/OkApacheClientTest.java
index 766e69c60e..0f1d092b8b 100644
--- a/okhttp-apache/src/test/java/com/squareup/okhttp/apache/OkApacheClientTest.java
+++ b/okhttp-apache/src/test/java/com/squareup/okhttp/apache/OkApacheClientTest.java
@@ -4,25 +4,27 @@
 import com.squareup.okhttp.mockwebserver.MockWebServer;
 import com.squareup.okhttp.mockwebserver.RecordedRequest;
 import java.io.ByteArrayInputStream;
-import java.io.ByteArrayOutputStream;
 import java.io.IOException;
 import java.io.InputStream;
-import java.io.OutputStreamWriter;
-import java.nio.charset.Charset;
 import java.util.Arrays;
 import java.util.zip.GZIPInputStream;
-import java.util.zip.GZIPOutputStream;
+import okio.Buffer;
+import okio.GzipSink;
+import okio.Okio;
 import org.apache.http.Header;
+import org.apache.http.HttpEntity;
 import org.apache.http.HttpResponse;
 import org.apache.http.client.methods.HttpGet;
 import org.apache.http.client.methods.HttpPost;
 import org.apache.http.entity.ByteArrayEntity;
 import org.apache.http.entity.InputStreamEntity;
+import org.apache.http.entity.StringEntity;
 import org.apache.http.util.EntityUtils;
 import org.junit.After;
 import org.junit.Before;
 import org.junit.Test;
 
+import static com.squareup.okhttp.internal.Util.UTF_8;
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertNotNull;
 import static org.junit.Assert.assertNull;
@@ -57,7 +59,7 @@
 
     HttpGet request = new HttpGet(server.getUrl("/").toURI());
     HttpResponse response = client.execute(request);
-    String actual = EntityUtils.toString(response.getEntity());
+    String actual = EntityUtils.toString(response.getEntity(), UTF_8);
     assertEquals("Hello, Redirect!", actual);
   }
 
@@ -87,18 +89,11 @@
     assertEquals("Baz", headers2[1].getValue());
   }
 
-  @Test public void noEntity() throws Exception {
-    server.enqueue(new MockResponse());
-
-    HttpPost post = new HttpPost(server.getUrl("/").toURI());
-    client.execute(post);
-  }
-
   @Test public void postByteEntity() throws Exception {
     server.enqueue(new MockResponse());
 
     final HttpPost post = new HttpPost(server.getUrl("/").toURI());
-    byte[] body = "Hello, world!".getBytes("UTF-8");
+    byte[] body = "Hello, world!".getBytes(UTF_8);
     post.setEntity(new ByteArrayEntity(body));
     client.execute(post);
 
@@ -111,7 +106,7 @@
     server.enqueue(new MockResponse());
 
     final HttpPost post = new HttpPost(server.getUrl("/").toURI());
-    byte[] body = "Hello, world!".getBytes("UTF-8");
+    byte[] body = "Hello, world!".getBytes(UTF_8);
     post.setEntity(new InputStreamEntity(new ByteArrayInputStream(body), body.length));
     client.execute(post);
 
@@ -120,6 +115,19 @@
     assertEquals(request.getHeader("Content-Length"), "13");
   }
 
+  @Test public void postOverrideContentType() throws Exception {
+    server.enqueue(new MockResponse());
+
+    HttpPost httpPost = new HttpPost();
+    httpPost.setURI(server.getUrl("/").toURI());
+    httpPost.addHeader("Content-Type", "application/xml");
+    httpPost.setEntity(new StringEntity("<yo/>"));
+    client.execute(httpPost);
+
+    RecordedRequest request = server.takeRequest();
+    assertEquals(request.getHeader("Content-Type"), "application/xml");
+  }
+
   @Test public void contentType() throws Exception {
     server.enqueue(new MockResponse().setBody("<html><body><h1>Hello, World!</h1></body></html>")
         .setHeader("Content-Type", "text/html"));
@@ -152,102 +160,93 @@
 
   @Test public void contentEncoding() throws Exception {
     String text = "{\"Message\": { \"text\": \"Hello, World!\" } }";
-    ByteArrayOutputStream bodyBytes = new ByteArrayOutputStream();
-    OutputStreamWriter body = new OutputStreamWriter(new GZIPOutputStream(bodyBytes),
-        Charset.forName("UTF-8"));
-    body.write(text);
-    body.close();
-    server.enqueue(new MockResponse().setBody(bodyBytes.toByteArray())
+    server.enqueue(new MockResponse().setBody(gzip(text))
         .setHeader("Content-Encoding", "gzip"));
 
-    byte[] tmp = new byte[32];
+    HttpGet request = new HttpGet(server.getUrl("/").toURI());
+    request.setHeader("Accept-encoding", "gzip"); // Not transparent gzip.
+    HttpResponse response = client.execute(request);
+    HttpEntity entity = response.getEntity();
 
-    HttpGet request1 = new HttpGet(server.getUrl("/").toURI());
-    request1.setHeader("Accept-encoding", "gzip"); // not transparent gzip
-    HttpResponse response1 = client.execute(request1);
-    Header[] headers1 = response1.getHeaders("Content-Encoding");
-    assertEquals(1, headers1.length);
-    assertEquals("gzip", headers1[0].getValue());
-    assertNotNull(response1.getEntity().getContentEncoding());
-    assertEquals("gzip", response1.getEntity().getContentEncoding().getValue());
-    InputStream content = new GZIPInputStream(response1.getEntity().getContent());
-    ByteArrayOutputStream rspBodyBytes = new ByteArrayOutputStream();
-    for (int len = content.read(tmp); len >= 0; len = content.read(tmp)) {
-      rspBodyBytes.write(tmp, 0, len);
-    }
-    String decodedContent = rspBodyBytes.toString("UTF-8");
-    assertEquals(text, decodedContent);
+    Header[] encodingHeaders = response.getHeaders("Content-Encoding");
+    assertEquals(1, encodingHeaders.length);
+    assertEquals("gzip", encodingHeaders[0].getValue());
+    assertNotNull(entity.getContentEncoding());
+    assertEquals("gzip", entity.getContentEncoding().getValue());
+
+    assertEquals(text, gunzip(entity));
   }
 
   @Test public void jsonGzipResponse() throws Exception {
     String text = "{\"Message\": { \"text\": \"Hello, World!\" } }";
-    ByteArrayOutputStream bodyBytes = new ByteArrayOutputStream();
-    OutputStreamWriter body = new OutputStreamWriter(new GZIPOutputStream(bodyBytes),
-        Charset.forName("UTF-8"));
-    body.write(text);
-    body.close();
-    server.enqueue(new MockResponse().setBody(bodyBytes.toByteArray())
+    server.enqueue(new MockResponse().setBody(gzip(text))
         .setHeader("Content-Encoding", "gzip")
         .setHeader("Content-Type", "application/json"));
 
-    byte[] tmp = new byte[32];
-
     HttpGet request1 = new HttpGet(server.getUrl("/").toURI());
-    request1.setHeader("Accept-encoding", "gzip"); // not transparent gzip
-    HttpResponse response1 = client.execute(request1);
-    Header[] headers1a = response1.getHeaders("Content-Encoding");
-    assertEquals(1, headers1a.length);
-    assertEquals("gzip", headers1a[0].getValue());
-    assertNotNull(response1.getEntity().getContentEncoding());
-    assertEquals("gzip", response1.getEntity().getContentEncoding().getValue());
-    Header[] headers1b = response1.getHeaders("Content-Type");
-    assertEquals(1, headers1b.length);
-    assertEquals("application/json", headers1b[0].getValue());
-    assertNotNull(response1.getEntity().getContentType());
-    assertEquals("application/json", response1.getEntity().getContentType().getValue());
-    InputStream content = new GZIPInputStream(response1.getEntity().getContent());
-    ByteArrayOutputStream rspBodyBytes = new ByteArrayOutputStream();
-    for (int len = content.read(tmp); len >= 0; len = content.read(tmp)) {
-      rspBodyBytes.write(tmp, 0, len);
-    }
-    String decodedContent = rspBodyBytes.toString("UTF-8");
-    assertEquals(text, decodedContent);
+    request1.setHeader("Accept-encoding", "gzip"); // Not transparent gzip.
+
+    HttpResponse response = client.execute(request1);
+    HttpEntity entity = response.getEntity();
+
+    Header[] encodingHeaders = response.getHeaders("Content-Encoding");
+    assertEquals(1, encodingHeaders.length);
+    assertEquals("gzip", encodingHeaders[0].getValue());
+    assertNotNull(entity.getContentEncoding());
+    assertEquals("gzip", entity.getContentEncoding().getValue());
+
+    Header[] typeHeaders = response.getHeaders("Content-Type");
+    assertEquals(1, typeHeaders.length);
+    assertEquals("application/json", typeHeaders[0].getValue());
+    assertNotNull(entity.getContentType());
+    assertEquals("application/json", entity.getContentType().getValue());
+
+    assertEquals(text, gunzip(entity));
   }
 
   @Test public void jsonTransparentGzipResponse() throws Exception {
     String text = "{\"Message\": { \"text\": \"Hello, World!\" } }";
-    ByteArrayOutputStream bodyBytes = new ByteArrayOutputStream();
-    OutputStreamWriter body = new OutputStreamWriter(new GZIPOutputStream(bodyBytes),
-        Charset.forName("UTF-8"));
-    body.write(text);
-    body.close();
-    server.enqueue(new MockResponse().setBody(bodyBytes.toByteArray())
+    server.enqueue(new MockResponse().setBody(gzip(text))
         .setHeader("Content-Encoding", "gzip")
         .setHeader("Content-Type", "application/json"));
 
-    byte[] tmp = new byte[32];
+    HttpGet request = new HttpGet(server.getUrl("/").toURI());
+    HttpResponse response = client.execute(request);
+    HttpEntity entity = response.getEntity();
 
-    HttpGet request1 = new HttpGet(server.getUrl("/").toURI());
-    // expecting transparent gzip response by not adding header "Accept-encoding: gzip"
-    HttpResponse response1 = client.execute(request1);
-    Header[] headers1a = response1.getHeaders("Content-Encoding");
-    assertEquals(0, headers1a.length);
-    assertNull(response1.getEntity().getContentEncoding());
-    // content length should also be absent
-    Header[] headers1b = response1.getHeaders("Content-Length");
-    assertEquals(0, headers1b.length);
-    assertTrue(response1.getEntity().getContentLength() < 0);
-    Header[] headers1c = response1.getHeaders("Content-Type");
-    assertEquals(1, headers1c.length);
-    assertEquals("application/json", headers1c[0].getValue());
-    assertNotNull(response1.getEntity().getContentType());
-    assertEquals("application/json", response1.getEntity().getContentType().getValue());
-    InputStream content = response1.getEntity().getContent();
-    ByteArrayOutputStream rspBodyBytes = new ByteArrayOutputStream();
-    for (int len = content.read(tmp); len >= 0; len = content.read(tmp)) {
-      rspBodyBytes.write(tmp, 0, len);
+    // Expecting transparent gzip response by not adding header "Accept-encoding: gzip"
+    Header[] encodingHeaders = response.getHeaders("Content-Encoding");
+    assertEquals(0, encodingHeaders.length);
+    assertNull(entity.getContentEncoding());
+
+    // Content length should be absent.
+    Header[] lengthHeaders = response.getHeaders("Content-Length");
+    assertEquals(0, lengthHeaders.length);
+    assertEquals(-1, entity.getContentLength());
+
+    Header[] typeHeaders = response.getHeaders("Content-Type");
+    assertEquals(1, typeHeaders.length);
+    assertEquals("application/json", typeHeaders[0].getValue());
+    assertNotNull(entity.getContentType());
+    assertEquals("application/json", entity.getContentType().getValue());
+
+    assertEquals(text, EntityUtils.toString(entity, UTF_8));
+  }
+
+  private static Buffer gzip(String body) throws IOException {
+    Buffer buffer = new Buffer();
+    Okio.buffer(new GzipSink(buffer)).writeUtf8(body).close();
+    return buffer;
+  }
+
+  private static String gunzip(HttpEntity body) throws IOException {
+    InputStream in = new GZIPInputStream(body.getContent());
+    Buffer buffer = new Buffer();
+    byte[] temp = new byte[1024];
+    int read;
+    while ((read = in.read(temp)) != -1) {
+      buffer.write(temp, 0, read);
     }
-    String decodedContent = rspBodyBytes.toString("UTF-8");
-    assertEquals(text, decodedContent);
+    return buffer.readUtf8();
   }
 }
diff --git a/okhttp-hpacktests/README.md b/okhttp-hpacktests/README.md
new file mode 100644
index 0000000000..f6b9049961
--- /dev/null
+++ b/okhttp-hpacktests/README.md
@@ -0,0 +1,22 @@
+OkHttp HPACK tests
+==================
+
+These tests use the [hpack-test-case][1] project to validate OkHttp's HPACK
+implementation.  The HPACK test cases are in a separate git submodule, so to
+initialize them, you must run:
+
+    git submodule init
+    git submodule update
+
+When new interop tests are available, you should update
+HpackDecodeInteropGoodTest#GOOD_INTEROP_TESTS with the directory name.
+
+TODO
+----
+
+ * Add maven goal to avoid manual call to git submodule init.
+ * Make hpack-test-case update itself from git, and run new tests.
+ * Add maven goal to generate stories and a pull request to hpack-test-case
+   to have others validate our output.
+
+[1]: https://github.com/http2jp/hpack-test-case 
diff --git a/okhttp-hpacktests/pom.xml b/okhttp-hpacktests/pom.xml
new file mode 100644
index 0000000000..0e8849076c
--- /dev/null
+++ b/okhttp-hpacktests/pom.xml
@@ -0,0 +1,57 @@
+<?xml version="1.0" encoding="UTF-8"?>
+
+<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
+  <modelVersion>4.0.0</modelVersion>
+
+  <parent>
+    <groupId>com.squareup.okhttp</groupId>
+    <artifactId>parent</artifactId>
+    <version>2.0.1-SNAPSHOT</version>
+  </parent>
+
+  <artifactId>okhttp-hpacktests</artifactId>
+  <name>OkHttp HPACK Tests</name>
+
+  <dependencies>
+    <dependency>
+      <groupId>com.squareup.okio</groupId>
+      <artifactId>okio</artifactId>
+    </dependency>
+    <dependency>
+      <groupId>com.squareup.okhttp</groupId>
+      <artifactId>okhttp</artifactId>
+      <version>${project.version}</version>
+    </dependency>
+    <dependency>
+      <groupId>junit</groupId>
+      <artifactId>junit</artifactId>
+      <scope>test</scope>
+    </dependency>
+    <dependency>
+      <groupId>com.squareup.okhttp</groupId>
+      <artifactId>mockwebserver</artifactId>
+      <version>${project.version}</version>
+      <scope>test</scope>
+    </dependency>
+    <!--  Gson: Java to Json conversion -->
+    <dependency>
+      <groupId>com.google.code.gson</groupId>
+      <artifactId>gson</artifactId>
+      <version>2.2.4</version>
+      <scope>compile</scope>
+    </dependency>
+  </dependencies>
+
+  <build>
+    <plugins>
+      <!-- Do not deploy this as an artifact to Maven central. -->
+      <plugin>
+        <groupId>org.apache.maven.plugins</groupId>
+        <artifactId>maven-deploy-plugin</artifactId>
+        <configuration>
+          <skip>true</skip>
+        </configuration>
+      </plugin>
+    </plugins>
+  </build>
+</project>
diff --git a/okhttp-hpacktests/src/test/java/com/squareup/okhttp/internal/spdy/HpackDecodeInteropBadTest.java b/okhttp-hpacktests/src/test/java/com/squareup/okhttp/internal/spdy/HpackDecodeInteropBadTest.java
new file mode 100644
index 0000000000..3e4850688d
--- /dev/null
+++ b/okhttp-hpacktests/src/test/java/com/squareup/okhttp/internal/spdy/HpackDecodeInteropBadTest.java
@@ -0,0 +1,54 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.okhttp.internal.spdy;
+
+import com.squareup.okhttp.internal.spdy.hpackjson.Story;
+import org.junit.Ignore;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.Parameterized;
+
+import java.util.Collection;
+
+/**
+ * Known bad tests for HPACK interop.
+ */
+// TODO: fix these tests (see if the input/test is legit, fix the implementation.)
+@Ignore
+@RunWith(Parameterized.class)
+public class HpackDecodeInteropBadTest extends HpackDecodeTestBase {
+
+  private static final String[] BAD_INTEROP_TESTS = {
+      "hyper-hpack",
+      "node-http2-protocol",
+      "raw-data",
+      "twitter-hpack"
+  };
+
+  public HpackDecodeInteropBadTest(Story story) {
+    super(story);
+  }
+
+  @Parameterized.Parameters(name="{0}")
+  public static Collection<Story[]> createStories() throws Exception {
+    return createStories(BAD_INTEROP_TESTS);
+  }
+
+  @Test
+  public void testGoodDecoderInterop() throws Exception {
+    testDecoder();
+  }
+}
diff --git a/okhttp-hpacktests/src/test/java/com/squareup/okhttp/internal/spdy/HpackDecodeInteropGoodTest.java b/okhttp-hpacktests/src/test/java/com/squareup/okhttp/internal/spdy/HpackDecodeInteropGoodTest.java
new file mode 100644
index 0000000000..55852b8b55
--- /dev/null
+++ b/okhttp-hpacktests/src/test/java/com/squareup/okhttp/internal/spdy/HpackDecodeInteropGoodTest.java
@@ -0,0 +1,59 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.okhttp.internal.spdy;
+
+import com.squareup.okhttp.internal.spdy.hpackjson.Story;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.Parameterized;
+
+import java.util.Collection;
+
+/**
+ * Known good tests for HPACK interop.
+ */
+@RunWith(Parameterized.class)
+public class HpackDecodeInteropGoodTest extends HpackDecodeTestBase {
+
+  // TODO: Filter on the json key for draft, which explains some of the failures.
+  private static final String[] GOOD_INTEROP_TESTS = {
+      "go-hpack",
+      "haskell-http2-linear",
+      "haskell-http2-linear-huffman",
+      "haskell-http2-naive",
+      "haskell-http2-naive-huffman",
+      "haskell-http2-static",
+      "haskell-http2-static-huffman",
+      "nghttp2",
+      "nghttp2-16384-4096",
+      "nghttp2-change-table-size",
+      "node-http2-hpack",
+  };
+
+  public HpackDecodeInteropGoodTest(Story story) {
+    super(story);
+  }
+
+  @Parameterized.Parameters(name="{0}")
+  public static Collection<Story[]> createStories() throws Exception {
+    return createStories(GOOD_INTEROP_TESTS);
+  }
+
+  @Test
+  public void testGoodDecoderInterop() throws Exception {
+    testDecoder();
+  }
+}
diff --git a/okhttp-hpacktests/src/test/java/com/squareup/okhttp/internal/spdy/HpackDecodeTestBase.java b/okhttp-hpacktests/src/test/java/com/squareup/okhttp/internal/spdy/HpackDecodeTestBase.java
new file mode 100644
index 0000000000..4d70830e24
--- /dev/null
+++ b/okhttp-hpacktests/src/test/java/com/squareup/okhttp/internal/spdy/HpackDecodeTestBase.java
@@ -0,0 +1,92 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.okhttp.internal.spdy;
+
+import com.squareup.okhttp.internal.spdy.hpackjson.Case;
+import com.squareup.okhttp.internal.spdy.hpackjson.HpackJsonUtil;
+import com.squareup.okhttp.internal.spdy.hpackjson.Story;
+import java.util.ArrayList;
+import java.util.Collection;
+import java.util.LinkedHashSet;
+import java.util.List;
+import okio.Buffer;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.fail;
+
+/**
+ * Tests Hpack implementation using https://github.com/http2jp/hpack-test-case/
+ */
+public class HpackDecodeTestBase {
+
+  /**
+   * Reads all stories in the folders provided, asserts if no story found.
+   */
+  protected static Collection<Story[]> createStories(String[] interopTests)
+      throws Exception {
+    List<Story[]> result = new ArrayList<>();
+    for (String interopTestName : interopTests) {
+      List<Story> stories = HpackJsonUtil.readStories(interopTestName);
+      if (stories.isEmpty()) {
+        fail("No stories for: " + interopTestName);
+      }
+      for (Story story : stories) {
+        result.add(new Story[] { story });
+      }
+    }
+    return result;
+  }
+
+  private final Buffer bytesIn = new Buffer();
+  private final HpackDraft09.Reader hpackReader = new HpackDraft09.Reader(4096, bytesIn);
+
+  private final Story story;
+
+  public HpackDecodeTestBase(Story story) {
+    this.story = story;
+  }
+
+  /**
+   * Expects wire to be set for all cases, and compares the decoder's output to
+   * expected headers.
+   */
+  protected void testDecoder() throws Exception {
+    testDecoder(story);
+  }
+
+  protected void testDecoder(Story story) throws Exception {
+    for (Case caze : story.getCases()) {
+      bytesIn.write(caze.getWire());
+      hpackReader.readHeaders();
+      assertSetEquals(String.format("seqno=%d", caze.getSeqno()), caze.getHeaders(),
+          hpackReader.getAndResetHeaderList());
+    }
+  }
+  /**
+   * Checks if {@code expected} and {@code observed} are equal when viewed as a
+   * set and headers are deduped.
+   *
+   * TODO: See if duped headers should be preserved on decode and verify.
+   */
+  private static void assertSetEquals(
+      String message, List<Header> expected, List<Header> observed) {
+    assertEquals(message, new LinkedHashSet<>(expected), new LinkedHashSet<>(observed));
+  }
+
+  protected Story getStory() {
+    return story;
+  }
+}
diff --git a/okhttp-hpacktests/src/test/java/com/squareup/okhttp/internal/spdy/HpackRoundTripTest.java b/okhttp-hpacktests/src/test/java/com/squareup/okhttp/internal/spdy/HpackRoundTripTest.java
new file mode 100644
index 0000000000..446f395184
--- /dev/null
+++ b/okhttp-hpacktests/src/test/java/com/squareup/okhttp/internal/spdy/HpackRoundTripTest.java
@@ -0,0 +1,63 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.okhttp.internal.spdy;
+
+import com.squareup.okhttp.internal.spdy.hpackjson.Case;
+import com.squareup.okhttp.internal.spdy.hpackjson.Story;
+import okio.Buffer;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.Parameterized;
+
+import java.util.Collection;
+
+/**
+ * Tests for round-tripping headers through hpack..
+ */
+// TODO: update hpack-test-case with the output of our encoder.
+// This test will hide complementary bugs in the encoder and decoder,
+// We should test that the encoder is producing responses that are
+// d]
+@RunWith(Parameterized.class)
+public class HpackRoundTripTest extends HpackDecodeTestBase {
+
+  private static final String[] RAW_DATA = { "raw-data" };
+
+  @Parameterized.Parameters(name="{0}")
+  public static Collection<Story[]> getStories() throws Exception {
+    return createStories(RAW_DATA);
+  }
+
+  private Buffer bytesOut = new Buffer();
+  private HpackDraft09.Writer hpackWriter = new HpackDraft09.Writer(bytesOut);
+
+  public HpackRoundTripTest(Story story) {
+    super(story);
+  }
+
+  @Test
+  public void testRoundTrip() throws Exception {
+    Story story = getStory().clone();
+    // Mutate cases in base class.
+    for (Case caze : story.getCases()) {
+      hpackWriter.writeHeaders(caze.getHeaders());
+      caze.setWire(bytesOut.readByteString());
+    }
+
+    testDecoder(story);
+  }
+
+}
diff --git a/okhttp-hpacktests/src/test/java/com/squareup/okhttp/internal/spdy/hpackjson/Case.java b/okhttp-hpacktests/src/test/java/com/squareup/okhttp/internal/spdy/hpackjson/Case.java
new file mode 100644
index 0000000000..d5d272872c
--- /dev/null
+++ b/okhttp-hpacktests/src/test/java/com/squareup/okhttp/internal/spdy/hpackjson/Case.java
@@ -0,0 +1,69 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.okhttp.internal.spdy.hpackjson;
+
+import com.squareup.okhttp.internal.spdy.Header;
+import okio.ByteString;
+
+import java.util.ArrayList;
+import java.util.LinkedHashMap;
+import java.util.List;
+import java.util.Map;
+
+/**
+ * Representation of an individual case (set of headers and wire format).
+ * There are many cases for a single story.  This class is used reflectively
+ * with Gson to parse stories.
+ */
+public class Case implements Cloneable {
+
+  private int seqno;
+  private String wire;
+  private List<Map<String, String>> headers;
+
+  public List<Header> getHeaders() {
+    List<Header> result = new ArrayList<>();
+    for (Map<String, String> inputHeader : headers) {
+      Map.Entry<String, String> entry = inputHeader.entrySet().iterator().next();
+      result.add(new Header(entry.getKey(), entry.getValue()));
+    }
+    return result;
+  }
+
+  public ByteString getWire() {
+    return ByteString.decodeHex(wire);
+  }
+
+  public int getSeqno() {
+    return seqno;
+  }
+
+  public void setWire(ByteString wire) {
+    this.wire = wire.hex();
+  }
+
+  @Override
+  protected Case clone() throws CloneNotSupportedException {
+    Case result = new Case();
+    result.seqno = seqno;
+    result.wire = wire;
+    result.headers = new ArrayList<>();
+    for (Map<String, String> header : headers) {
+      result.headers.add(new LinkedHashMap<String, String>(header));
+    }
+    return result;
+  }
+}
diff --git a/okhttp-hpacktests/src/test/java/com/squareup/okhttp/internal/spdy/hpackjson/HpackJsonUtil.java b/okhttp-hpacktests/src/test/java/com/squareup/okhttp/internal/spdy/hpackjson/HpackJsonUtil.java
new file mode 100644
index 0000000000..d0695446d5
--- /dev/null
+++ b/okhttp-hpacktests/src/test/java/com/squareup/okhttp/internal/spdy/hpackjson/HpackJsonUtil.java
@@ -0,0 +1,65 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.okhttp.internal.spdy.hpackjson;
+
+import com.google.gson.Gson;
+import com.google.gson.GsonBuilder;
+
+import java.io.InputStream;
+import java.io.InputStreamReader;
+import java.util.ArrayList;
+import java.util.List;
+
+/**
+ * Utilities for reading HPACK tests.
+ */
+public final class HpackJsonUtil {
+
+  private static final String STORY_RESOURCE_FORMAT =
+      "/hpack-test-case/%s/story_%02d.json";
+
+  private static final Gson GSON = new GsonBuilder().create();
+
+  private static Story readStory(InputStream jsonResource) throws Exception {
+    return GSON.fromJson(new InputStreamReader(jsonResource, "UTF-8"), Story.class);
+  }
+
+  /**
+   * Reads stories named "story_xx.json" from the folder provided.
+   */
+  public static List<Story> readStories(String testFolderName) throws Exception {
+    List<Story> result = new ArrayList<>();
+    int i = 0;
+    while (true) { // break after last test.
+      String storyResourceName = String.format(STORY_RESOURCE_FORMAT, testFolderName, i);
+      InputStream storyInputStream = HpackJsonUtil.class.getResourceAsStream(storyResourceName);
+      if (storyInputStream == null) {
+        break;
+      }
+      try {
+        Story story = readStory(storyInputStream);
+        story.setFileName(storyResourceName);
+        result.add(story);
+        i++;
+      } finally {
+        storyInputStream.close();
+      }
+    }
+    return result;
+  }
+
+  private HpackJsonUtil() { } // Utilities only.
+}
\ No newline at end of file
diff --git a/okhttp-hpacktests/src/test/java/com/squareup/okhttp/internal/spdy/hpackjson/Story.java b/okhttp-hpacktests/src/test/java/com/squareup/okhttp/internal/spdy/hpackjson/Story.java
new file mode 100644
index 0000000000..e7898cb826
--- /dev/null
+++ b/okhttp-hpacktests/src/test/java/com/squareup/okhttp/internal/spdy/hpackjson/Story.java
@@ -0,0 +1,61 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.okhttp.internal.spdy.hpackjson;
+
+import java.util.ArrayList;
+import java.util.List;
+
+/**
+ * Representation of one story, a set of request headers to encode or decode.
+ * This class is used reflectively with Gson to parse stories from files.
+ */
+public class Story implements Cloneable {
+
+  private transient String fileName;
+  private List<Case> cases;
+  private int draft;
+  private String description;
+
+  /**
+   * The filename is only used in the toString representation.
+   */
+  void setFileName(String fileName) {
+    this.fileName = fileName;
+  }
+
+  public List<Case> getCases() {
+    return cases;
+  }
+
+  @Override
+  public Story clone() throws CloneNotSupportedException {
+    Story story = new Story();
+    story.fileName = this.fileName;
+    story.cases = new ArrayList<>();
+    for (Case caze : cases) {
+      story.cases.add(caze.clone());
+    }
+    story.draft = draft;
+    story.description = description;
+    return story;
+  }
+
+  @Override
+  public String toString() {
+    // Used as the test name.
+    return fileName;
+  }
+}
diff --git a/okhttp-hpacktests/src/test/resources/hpack-test-case b/okhttp-hpacktests/src/test/resources/hpack-test-case
new file mode 160000
index 0000000000..a5652bc2bc
--- /dev/null
+++ b/okhttp-hpacktests/src/test/resources/hpack-test-case
@@ -0,0 +1 @@
+Subproject commit a5652bc2bc3d2a992f39446369fb004a72e881d4
diff --git a/okhttp-tests/pom.xml b/okhttp-tests/pom.xml
index 7c1573df01..7c3a601655 100644
--- a/okhttp-tests/pom.xml
+++ b/okhttp-tests/pom.xml
@@ -6,7 +6,7 @@
   <parent>
     <groupId>com.squareup.okhttp</groupId>
     <artifactId>parent</artifactId>
-    <version>2.0.0-SNAPSHOT</version>
+    <version>2.0.1-SNAPSHOT</version>
   </parent>
 
   <artifactId>okhttp-tests</artifactId>
@@ -16,7 +16,6 @@
     <dependency>
       <groupId>com.squareup.okio</groupId>
       <artifactId>okio</artifactId>
-      <version>${project.version}</version>
     </dependency>
     <dependency>
       <groupId>com.squareup.okhttp</groupId>
@@ -24,9 +23,9 @@
       <version>${project.version}</version>
     </dependency>
     <dependency>
-      <groupId>org.mortbay.jetty.npn</groupId>
-      <artifactId>npn-boot</artifactId>
-      <scope>provided</scope>
+      <groupId>com.squareup.okhttp</groupId>
+      <artifactId>okhttp-urlconnection</artifactId>
+      <version>${project.version}</version>
     </dependency>
 
     <dependency>
@@ -41,4 +40,17 @@
       <scope>test</scope>
     </dependency>
   </dependencies>
+
+  <build>
+    <plugins>
+      <!-- Do not deploy this as an artifact to Maven central. -->
+      <plugin>
+        <groupId>org.apache.maven.plugins</groupId>
+        <artifactId>maven-deploy-plugin</artifactId>
+        <configuration>
+          <skip>true</skip>
+        </configuration>
+      </plugin>
+    </plugins>
+  </build>
 </project>
diff --git a/okhttp-tests/src/test/java/com/squareup/okhttp/AbstractResponseCache.java b/okhttp-tests/src/test/java/com/squareup/okhttp/AbstractResponseCache.java
new file mode 100644
index 0000000000..2a59d22a02
--- /dev/null
+++ b/okhttp-tests/src/test/java/com/squareup/okhttp/AbstractResponseCache.java
@@ -0,0 +1,46 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.okhttp;
+
+import java.io.IOException;
+import java.net.CacheRequest;
+import java.net.CacheResponse;
+import java.net.ResponseCache;
+import java.net.URI;
+import java.net.URISyntaxException;
+import java.net.URL;
+import java.net.URLConnection;
+import java.util.List;
+import java.util.Map;
+
+public class AbstractResponseCache extends ResponseCache {
+  @Override public CacheResponse get(URI uri, String requestMethod,
+      Map<String, List<String>> requestHeaders) throws IOException {
+    return null;
+  }
+
+  @Override public CacheRequest put(URI uri, URLConnection connection) throws IOException {
+    return null;
+  }
+
+  public static URI toUri(URL serverUrl) {
+    try {
+      return serverUrl.toURI();
+    } catch (URISyntaxException e) {
+      throw new AssertionError(e);
+    }
+  }
+}
diff --git a/okhttp-tests/src/test/java/com/squareup/okhttp/AsyncApiTest.java b/okhttp-tests/src/test/java/com/squareup/okhttp/AsyncApiTest.java
deleted file mode 100644
index a3dcf5c332..0000000000
--- a/okhttp-tests/src/test/java/com/squareup/okhttp/AsyncApiTest.java
+++ /dev/null
@@ -1,371 +0,0 @@
-/*
- * Copyright (C) 2013 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.squareup.okhttp;
-
-import com.squareup.okhttp.internal.RecordingHostnameVerifier;
-import com.squareup.okhttp.internal.SslContextBuilder;
-import com.squareup.okhttp.mockwebserver.Dispatcher;
-import com.squareup.okhttp.mockwebserver.MockResponse;
-import com.squareup.okhttp.mockwebserver.MockWebServer;
-import com.squareup.okhttp.mockwebserver.RecordedRequest;
-import com.squareup.okhttp.mockwebserver.SocketPolicy;
-import java.io.File;
-import java.io.IOException;
-import java.io.InputStream;
-import java.net.HttpURLConnection;
-import java.util.UUID;
-import java.util.concurrent.CountDownLatch;
-import java.util.concurrent.atomic.AtomicReference;
-import javax.net.ssl.SSLContext;
-import org.junit.After;
-import org.junit.Before;
-import org.junit.Test;
-
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertNull;
-import static org.junit.Assert.assertTrue;
-
-public final class AsyncApiTest {
-  private MockWebServer server = new MockWebServer();
-  private OkHttpClient client = new OkHttpClient();
-  private RecordingReceiver receiver = new RecordingReceiver();
-
-  private static final SSLContext sslContext = SslContextBuilder.localhost();
-  private HttpResponseCache cache;
-
-  @Before public void setUp() throws Exception {
-    String tmp = System.getProperty("java.io.tmpdir");
-    File cacheDir = new File(tmp, "HttpCache-" + UUID.randomUUID());
-    cache = new HttpResponseCache(cacheDir, Integer.MAX_VALUE);
-  }
-
-  @After public void tearDown() throws Exception {
-    server.shutdown();
-    cache.delete();
-  }
-
-  @Test public void get() throws Exception {
-    server.enqueue(new MockResponse()
-        .setBody("abc")
-        .addHeader("Content-Type: text/plain"));
-    server.play();
-
-    Request request = new Request.Builder()
-        .url(server.getUrl("/"))
-        .header("User-Agent", "AsyncApiTest")
-        .build();
-    client.enqueue(request, receiver);
-
-    receiver.await(request.url())
-        .assertCode(200)
-        .assertContainsHeaders("Content-Type: text/plain")
-        .assertBody("abc");
-
-    assertTrue(server.takeRequest().getHeaders().contains("User-Agent: AsyncApiTest"));
-  }
-
-  @Test public void connectionPooling() throws Exception {
-    server.enqueue(new MockResponse().setBody("abc"));
-    server.enqueue(new MockResponse().setBody("def"));
-    server.enqueue(new MockResponse().setBody("ghi"));
-    server.play();
-
-    client.enqueue(new Request.Builder().url(server.getUrl("/a")).build(), receiver);
-    receiver.await(server.getUrl("/a")).assertBody("abc");
-
-    client.enqueue(new Request.Builder().url(server.getUrl("/b")).build(), receiver);
-    receiver.await(server.getUrl("/b")).assertBody("def");
-
-    client.enqueue(new Request.Builder().url(server.getUrl("/c")).build(), receiver);
-    receiver.await(server.getUrl("/c")).assertBody("ghi");
-
-    assertEquals(0, server.takeRequest().getSequenceNumber());
-    assertEquals(1, server.takeRequest().getSequenceNumber());
-    assertEquals(2, server.takeRequest().getSequenceNumber());
-  }
-
-  @Test public void tls() throws Exception {
-    server.useHttps(sslContext.getSocketFactory(), false);
-    server.enqueue(new MockResponse()
-        .setBody("abc")
-        .addHeader("Content-Type: text/plain"));
-    server.play();
-
-    client.setSslSocketFactory(sslContext.getSocketFactory());
-    client.setHostnameVerifier(new RecordingHostnameVerifier());
-
-    Request request = new Request.Builder()
-        .url(server.getUrl("/"))
-        .build();
-    client.enqueue(request, receiver);
-
-    receiver.await(request.url()).assertHandshake();
-  }
-
-  @Test public void recoverFromTlsHandshakeFailure() throws Exception {
-    server.useHttps(sslContext.getSocketFactory(), false);
-    server.enqueue(new MockResponse().setSocketPolicy(SocketPolicy.FAIL_HANDSHAKE));
-    server.enqueue(new MockResponse().setBody("abc"));
-    server.play();
-
-    client.setSslSocketFactory(sslContext.getSocketFactory());
-    client.setHostnameVerifier(new RecordingHostnameVerifier());
-
-    Request request = new Request.Builder()
-        .url(server.getUrl("/"))
-        .build();
-    client.enqueue(request, receiver);
-
-    receiver.await(request.url()).assertBody("abc");
-  }
-
-  @Test public void post() throws Exception {
-    server.enqueue(new MockResponse().setBody("abc"));
-    server.play();
-
-    Request request = new Request.Builder()
-        .url(server.getUrl("/"))
-        .post(Request.Body.create(MediaType.parse("text/plain"), "def"))
-        .build();
-    client.enqueue(request, receiver);
-
-    receiver.await(request.url())
-        .assertCode(200)
-        .assertBody("abc");
-
-    RecordedRequest recordedRequest = server.takeRequest();
-    assertEquals("def", recordedRequest.getUtf8Body());
-    assertEquals("3", recordedRequest.getHeader("Content-Length"));
-    assertEquals("text/plain; charset=utf-8", recordedRequest.getHeader("Content-Type"));
-  }
-
-  @Test public void cache() throws Exception {
-    server.enqueue(new MockResponse().setBody("A").addHeader("ETag: v1"));
-    server.enqueue(new MockResponse().setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
-    server.play();
-
-    client.setOkResponseCache(cache);
-
-    Request request1 = new Request.Builder()
-        .url(server.getUrl("/"))
-        .build();
-    client.enqueue(request1, receiver);
-    receiver.await(request1.url()).assertCode(200).assertBody("A");
-    assertNull(server.takeRequest().getHeader("If-None-Match"));
-
-    Request request2 = new Request.Builder()
-        .url(server.getUrl("/"))
-        .build();
-    client.enqueue(request2, receiver);
-    receiver.await(request2.url()).assertCode(200).assertBody("A");
-    assertEquals("v1", server.takeRequest().getHeader("If-None-Match"));
-  }
-
-  @Test public void redirect() throws Exception {
-    server.enqueue(new MockResponse()
-        .setResponseCode(301)
-        .addHeader("Location: /b")
-        .addHeader("Test", "Redirect from /a to /b")
-        .setBody("/a has moved!"));
-    server.enqueue(new MockResponse()
-        .setResponseCode(302)
-        .addHeader("Location: /c")
-        .addHeader("Test", "Redirect from /b to /c")
-        .setBody("/b has moved!"));
-    server.enqueue(new MockResponse().setBody("C"));
-    server.play();
-
-    Request request = new Request.Builder().url(server.getUrl("/a")).build();
-    client.enqueue(request, receiver);
-
-    receiver.await(server.getUrl("/c"))
-        .assertCode(200)
-        .assertBody("C")
-        .redirectedBy()
-        .assertCode(302)
-        .assertContainsHeaders("Test: Redirect from /b to /c")
-        .redirectedBy()
-        .assertCode(301)
-        .assertContainsHeaders("Test: Redirect from /a to /b");
-
-    assertEquals(0, server.takeRequest().getSequenceNumber()); // New connection.
-    assertEquals(1, server.takeRequest().getSequenceNumber()); // Connection reused.
-    assertEquals(2, server.takeRequest().getSequenceNumber()); // Connection reused again!
-  }
-
-  @Test public void redirectWithRedirectsDisabled() throws Exception {
-    client.setFollowProtocolRedirects(false);
-    server.enqueue(new MockResponse()
-        .setResponseCode(301)
-        .addHeader("Location: /b")
-        .addHeader("Test", "Redirect from /a to /b")
-        .setBody("/a has moved!"));
-    server.play();
-
-    Request request = new Request.Builder().url(server.getUrl("/a")).build();
-    client.enqueue(request, receiver);
-
-    receiver.await(server.getUrl("/a"))
-        .assertCode(301)
-        .assertBody("/a has moved!")
-        .assertContainsHeaders("Location: /b");
-  }
-
-  @Test public void follow20Redirects() throws Exception {
-    for (int i = 0; i < 20; i++) {
-      server.enqueue(new MockResponse()
-          .setResponseCode(301)
-          .addHeader("Location: /" + (i + 1))
-          .setBody("Redirecting to /" + (i + 1)));
-    }
-    server.enqueue(new MockResponse().setBody("Success!"));
-    server.play();
-
-    Request request = new Request.Builder().url(server.getUrl("/0")).build();
-    client.enqueue(request, receiver);
-    receiver.await(server.getUrl("/20"))
-        .assertCode(200)
-        .assertBody("Success!");
-  }
-
-  @Test public void doesNotFollow21Redirects() throws Exception {
-    for (int i = 0; i < 21; i++) {
-      server.enqueue(new MockResponse()
-          .setResponseCode(301)
-          .addHeader("Location: /" + (i + 1))
-          .setBody("Redirecting to /" + (i + 1)));
-    }
-    server.play();
-
-    Request request = new Request.Builder().url(server.getUrl("/0")).build();
-    client.enqueue(request, receiver);
-    receiver.await(server.getUrl("/20")).assertFailure("Too many redirects: 21");
-  }
-
-  @Test public void canceledBeforeResponseReadIsNeverDelivered() throws Exception {
-    client.getDispatcher().setMaxRequests(1); // Force requests to be executed serially.
-    server.setDispatcher(new Dispatcher() {
-      char nextResponse = 'A';
-      @Override public MockResponse dispatch(RecordedRequest request) {
-        client.cancel("request A");
-        return new MockResponse().setBody(Character.toString(nextResponse++));
-      }
-    });
-    server.play();
-
-    // Canceling a request after the server has received a request but before
-    // it has delivered the response. That request will never be received to the
-    // client.
-    Request requestA = new Request.Builder().url(server.getUrl("/a")).tag("request A").build();
-    client.enqueue(requestA, receiver);
-    assertEquals("/a", server.takeRequest().getPath());
-
-    // We then make a second request (not canceled) to make sure the receiver
-    // has nothing left to wait for.
-    Request requestB = new Request.Builder().url(server.getUrl("/b")).tag("request B").build();
-    client.enqueue(requestB, receiver);
-    assertEquals("/b", server.takeRequest().getPath());
-    receiver.await(requestB.url()).assertBody("B");
-
-    // At this point we know the receiver is ready: if it hasn't received 'A'
-    // yet it never will.
-    receiver.assertNoResponse(requestA.url());
-  }
-
-  @Test public void canceledAfterResponseIsDeliveredDoesNothing() throws Exception {
-    server.enqueue(new MockResponse().setBody("A"));
-    server.play();
-
-    final CountDownLatch latch = new CountDownLatch(1);
-    final AtomicReference<String> bodyRef = new AtomicReference<String>();
-
-    Request request = new Request.Builder().url(server.getUrl("/a")).tag("request A").build();
-    client.enqueue(request, new Response.Receiver() {
-      @Override public void onFailure(Failure failure) {
-        throw new AssertionError();
-      }
-
-      @Override public boolean onResponse(Response response) throws IOException {
-        client.cancel("request A");
-        bodyRef.set(response.body().string());
-        latch.countDown();
-        return true;
-      }
-    });
-
-    latch.await();
-    assertEquals("A", bodyRef.get());
-  }
-
-  @Test public void connectionReuseWhenResponseBodyConsumed() throws Exception {
-    server.enqueue(new MockResponse().setBody("abc"));
-    server.enqueue(new MockResponse().setBody("def"));
-    server.play();
-
-    Request request = new Request.Builder().url(server.getUrl("/a")).build();
-    client.enqueue(request, new Response.Receiver() {
-      @Override public void onFailure(Failure failure) {
-        throw new AssertionError();
-      }
-      @Override public boolean onResponse(Response response) throws IOException {
-        InputStream bytes = response.body().byteStream();
-        assertEquals('a', bytes.read());
-        assertEquals('b', bytes.read());
-        assertEquals('c', bytes.read());
-
-        // This request will share a connection with 'A' cause it's all done.
-        client.enqueue(new Request.Builder().url(server.getUrl("/b")).build(), receiver);
-        return true;
-      }
-    });
-
-    receiver.await(server.getUrl("/b")).assertCode(200).assertBody("def");
-    assertEquals(0, server.takeRequest().getSequenceNumber()); // New connection.
-    assertEquals(1, server.takeRequest().getSequenceNumber()); // Connection reuse!
-  }
-
-  @Test public void postBodyRetransmittedOnRedirect() throws Exception {
-    server.enqueue(new MockResponse()
-        .setResponseCode(302)
-        .addHeader("Location: /b")
-        .setBody("Moved to /b !"));
-    server.enqueue(new MockResponse()
-        .setBody("This is b."));
-    server.play();
-
-    Request request = new Request.Builder()
-        .url(server.getUrl("/"))
-        .post(Request.Body.create(MediaType.parse("text/plain"), "body!"))
-        .build();
-    client.enqueue(request, receiver);
-
-    receiver.await(server.getUrl("/b"))
-        .assertCode(200)
-        .assertBody("This is b.");
-
-    RecordedRequest request1 = server.takeRequest();
-    assertEquals("body!", request1.getUtf8Body());
-    assertEquals("5", request1.getHeader("Content-Length"));
-    assertEquals("text/plain; charset=utf-8", request1.getHeader("Content-Type"));
-    assertEquals(0, request1.getSequenceNumber());
-
-    RecordedRequest request2 = server.takeRequest();
-    assertEquals("body!", request2.getUtf8Body());
-    assertEquals("5", request2.getHeader("Content-Length"));
-    assertEquals("text/plain; charset=utf-8", request2.getHeader("Content-Type"));
-    assertEquals(1, request2.getSequenceNumber());
-  }
-}
diff --git a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/HttpResponseCacheTest.java b/okhttp-tests/src/test/java/com/squareup/okhttp/CacheTest.java
similarity index 81%
rename from okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/HttpResponseCacheTest.java
rename to okhttp-tests/src/test/java/com/squareup/okhttp/CacheTest.java
index 1380ff045a..b78a68e92d 100644
--- a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/HttpResponseCacheTest.java
+++ b/okhttp-tests/src/test/java/com/squareup/okhttp/CacheTest.java
@@ -14,34 +14,29 @@
  * limitations under the License.
  */
 
-package com.squareup.okhttp.internal.http;
-
-import com.squareup.okhttp.HttpResponseCache;
-import com.squareup.okhttp.OkHttpClient;
-import com.squareup.okhttp.OkResponseCache;
-import com.squareup.okhttp.Request;
-import com.squareup.okhttp.Response;
-import com.squareup.okhttp.ResponseSource;
+package com.squareup.okhttp;
+
 import com.squareup.okhttp.internal.SslContextBuilder;
 import com.squareup.okhttp.internal.Util;
 import com.squareup.okhttp.mockwebserver.MockResponse;
 import com.squareup.okhttp.mockwebserver.MockWebServer;
 import com.squareup.okhttp.mockwebserver.RecordedRequest;
+import com.squareup.okhttp.mockwebserver.rule.MockWebServerRule;
 import java.io.BufferedReader;
-import java.io.ByteArrayOutputStream;
 import java.io.File;
 import java.io.FileNotFoundException;
-import java.io.FileOutputStream;
 import java.io.IOException;
 import java.io.InputStream;
 import java.io.InputStreamReader;
 import java.io.OutputStream;
 import java.net.CacheRequest;
+import java.net.CacheResponse;
 import java.net.CookieHandler;
 import java.net.CookieManager;
 import java.net.HttpCookie;
 import java.net.HttpURLConnection;
 import java.net.ResponseCache;
+import java.net.URI;
 import java.net.URISyntaxException;
 import java.net.URL;
 import java.net.URLConnection;
@@ -55,20 +50,25 @@
 import java.util.Iterator;
 import java.util.List;
 import java.util.Locale;
+import java.util.Map;
 import java.util.TimeZone;
-import java.util.UUID;
 import java.util.concurrent.TimeUnit;
 import java.util.concurrent.atomic.AtomicBoolean;
 import java.util.concurrent.atomic.AtomicInteger;
 import java.util.concurrent.atomic.AtomicReference;
-import java.util.zip.GZIPOutputStream;
 import javax.net.ssl.HostnameVerifier;
 import javax.net.ssl.HttpsURLConnection;
 import javax.net.ssl.SSLContext;
 import javax.net.ssl.SSLSession;
+import okio.Buffer;
+import okio.BufferedSink;
+import okio.GzipSink;
+import okio.Okio;
 import org.junit.After;
 import org.junit.Before;
+import org.junit.Rule;
 import org.junit.Test;
+import org.junit.rules.TemporaryFolder;
 
 import static com.squareup.okhttp.mockwebserver.SocketPolicy.DISCONNECT_AT_END;
 import static org.junit.Assert.assertEquals;
@@ -80,10 +80,10 @@
 import static org.junit.Assert.fail;
 
 /**
- * Android's HttpResponseCacheTest. This tests both the {@link HttpResponseCache} implementation and
- * the behavior of {@link com.squareup.okhttp.OkResponseCache} classes generally.
+ * Android's HttpResponseCacheTest. This tests both {@link Cache} and handling
+ * of {@link ResponseCache}.
  */
-public final class HttpResponseCacheTest {
+public final class CacheTest {
   private static final HostnameVerifier NULL_HOSTNAME_VERIFIER = new HostnameVerifier() {
     @Override public boolean verify(String s, SSLSession sslSession) {
       return true;
@@ -92,44 +92,32 @@
 
   private static final SSLContext sslContext = SslContextBuilder.localhost();
 
-  private final OkHttpClient client = new OkHttpClient();
-  private MockWebServer server = new MockWebServer();
-  private MockWebServer server2 = new MockWebServer();
-  private HttpResponseCache cache;
+  @Rule public TemporaryFolder cacheRule = new TemporaryFolder();
+  @Rule public MockWebServerRule serverRule = new MockWebServerRule();
+  @Rule public MockWebServerRule server2Rule = new MockWebServerRule();
+
+  private final OkUrlFactory client = new OkUrlFactory(new OkHttpClient());
+  private MockWebServer server;
+  private MockWebServer server2;
+  private Cache cache;
   private final CookieManager cookieManager = new CookieManager();
 
   @Before public void setUp() throws Exception {
-    String tmp = System.getProperty("java.io.tmpdir");
-    File cacheDir = new File(tmp, "HttpCache-" + UUID.randomUUID());
-    cache = new HttpResponseCache(cacheDir, Integer.MAX_VALUE);
-    ResponseCache.setDefault(cache);
+    server = serverRule.get();
+    server.setProtocolNegotiationEnabled(false);
+    server2 = server2Rule.get();
+    cache = new Cache(cacheRule.getRoot(), Integer.MAX_VALUE);
+    client.client().setCache(cache);
     CookieHandler.setDefault(cookieManager);
-    server.setNpnEnabled(false);
   }
 
   @After public void tearDown() throws Exception {
-    server.shutdown();
-    server2.shutdown();
     ResponseCache.setDefault(null);
-    cache.delete();
     CookieHandler.setDefault(null);
   }
 
-  private HttpURLConnection openConnection(URL url) {
-    return client.open(url);
-  }
-
   @Test public void responseCacheAccessWithOkHttpMember() throws IOException {
-    ResponseCache.setDefault(null);
-    client.setResponseCache(cache);
-    assertSame(cache, client.getOkResponseCache());
-    assertNull(client.getResponseCache());
-  }
-
-  @Test public void responseCacheAccessWithGlobalDefault() throws IOException {
-    ResponseCache.setDefault(cache);
-    client.setResponseCache(null);
-    assertNull(client.getOkResponseCache());
+    assertSame(cache, client.client().getCache());
     assertNull(client.getResponseCache());
   }
 
@@ -173,23 +161,6 @@ private HttpURLConnection openConnection(URL url) {
     }
   }
 
-  /**
-   * Response code 407 should only come from proxy servers. Android's client
-   * throws if it is sent by an origin server.
-   */
-  @Test public void originServerSends407() throws Exception {
-    server.enqueue(new MockResponse().setResponseCode(407));
-    server.play();
-
-    URL url = server.getUrl("/");
-    HttpURLConnection conn = openConnection(url);
-    try {
-      conn.getResponseCode();
-      fail();
-    } catch (IOException expected) {
-    }
-  }
-
   @Test public void responseCaching_410() throws Exception {
     // the HTTP spec permits caching 410s, but the RI doesn't.
     assertCached(true, 410);
@@ -212,7 +183,7 @@ private void assertCached(boolean shouldPut, int responseCode) throws Exception
     server.play();
 
     URL url = server.getUrl("/");
-    HttpURLConnection conn = openConnection(url);
+    HttpURLConnection conn = client.open(url);
     assertEquals(responseCode, conn.getResponseCode());
 
     // exhaust the content stream
@@ -241,23 +212,27 @@ private void assertCached(boolean shouldPut, int responseCode) throws Exception
         .addHeader("Content-Type: text/plain")
         .addHeader("fgh: ijk")
         .setBody(body));
-    server.play();
 
-    client.setOkResponseCache(new AbstractOkResponseCache() {
-      @Override public CacheRequest put(Response response) throws IOException {
-        assertEquals(server.getUrl("/"), response.request().url());
-        assertEquals(200, response.code());
-        assertNull(response.body());
-        assertEquals("5", response.header("Content-Length"));
-        assertEquals("text/plain", response.header("Content-Type"));
-        assertEquals("ijk", response.header("fgh"));
+    client.setResponseCache(new AbstractResponseCache() {
+      @Override public CacheRequest put(URI uri, URLConnection connection) throws IOException {
+        HttpURLConnection httpURLConnection = (HttpURLConnection) connection;
+        assertEquals(server.getUrl("/"), uri.toURL());
+        assertEquals(200, httpURLConnection.getResponseCode());
+        try {
+          httpURLConnection.getInputStream();
+          fail();
+        } catch (UnsupportedOperationException expected) {
+        }
+        assertEquals("5", connection.getHeaderField("Content-Length"));
+        assertEquals("text/plain", connection.getHeaderField("Content-Type"));
+        assertEquals("ijk", connection.getHeaderField("fgh"));
         cacheCount.incrementAndGet();
         return null;
       }
     });
 
     URL url = server.getUrl("/");
-    HttpURLConnection connection = openConnection(url);
+    HttpURLConnection connection = client.open(url);
     assertEquals(body, readAscii(connection));
     assertEquals(1, cacheCount.get());
   }
@@ -265,8 +240,8 @@ private void assertCached(boolean shouldPut, int responseCode) throws Exception
   /** Don't explode if the cache returns a null body. http://b/3373699 */
   @Test public void responseCacheReturnsNullOutputStream() throws Exception {
     final AtomicBoolean aborted = new AtomicBoolean();
-    client.setOkResponseCache(new AbstractOkResponseCache() {
-      @Override public CacheRequest put(Response response) throws IOException {
+    client.setResponseCache(new AbstractResponseCache() {
+      @Override public CacheRequest put(URI uri, URLConnection connection) {
         return new CacheRequest() {
           @Override public void abort() {
             aborted.set(true);
@@ -280,7 +255,6 @@ private void assertCached(boolean shouldPut, int responseCode) throws Exception
     });
 
     server.enqueue(new MockResponse().setBody("abcdef"));
-    server.play();
 
     HttpURLConnection connection = client.open(server.getUrl("/"));
     assertEquals("abc", readAscii(connection, 3));
@@ -311,10 +285,9 @@ private void testResponseCaching(TransferKind transferKind) throws IOException {
             .setStatus("HTTP/1.1 200 Fantastic");
     transferKind.setBody(response, "I love puppies but hate spiders", 1);
     server.enqueue(response);
-    server.play();
 
     // Make sure that calling skip() doesn't omit bytes from the cache.
-    HttpURLConnection urlConnection = openConnection(server.getUrl("/"));
+    HttpURLConnection urlConnection = client.open(server.getUrl("/"));
     InputStream in = urlConnection.getInputStream();
     assertEquals("I love ", readAscii(urlConnection, "I love ".length()));
     reliableSkip(in, "puppies but hate ".length());
@@ -324,7 +297,7 @@ private void testResponseCaching(TransferKind transferKind) throws IOException {
     assertEquals(1, cache.getWriteSuccessCount());
     assertEquals(0, cache.getWriteAbortCount());
 
-    urlConnection = openConnection(server.getUrl("/")); // cached!
+    urlConnection = client.open(server.getUrl("/")); // cached!
     in = urlConnection.getInputStream();
     assertEquals("I love puppies but hate spiders",
         readAscii(urlConnection, "I love puppies but hate spiders".length()));
@@ -344,7 +317,6 @@ private void testResponseCaching(TransferKind transferKind) throws IOException {
     server.enqueue(new MockResponse().addHeader("Last-Modified: " + formatDate(-1, TimeUnit.HOURS))
         .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS))
         .setBody("ABC"));
-    server.play();
 
     HttpsURLConnection c1 = (HttpsURLConnection) client.open(server.getUrl("/"));
     c1.setSSLSocketFactory(sslContext.getSocketFactory());
@@ -383,12 +355,11 @@ private void testResponseCaching(TransferKind transferKind) throws IOException {
         .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS))
         .setBody("ABC"));
     server.enqueue(new MockResponse().setBody("DEF"));
-    server.play();
 
-    HttpURLConnection connection = openConnection(server.getUrl("/"));
+    HttpURLConnection connection = client.open(server.getUrl("/"));
     assertEquals("ABC", readAscii(connection));
 
-    connection = openConnection(server.getUrl("/")); // cached!
+    connection = client.open(server.getUrl("/")); // cached!
     assertEquals("ABC", readAscii(connection));
 
     assertEquals(4, cache.getRequestCount()); // 2 requests + 2 redirects
@@ -401,20 +372,19 @@ private void testResponseCaching(TransferKind transferKind) throws IOException {
     server.enqueue(new MockResponse().setResponseCode(HttpURLConnection.HTTP_MOVED_PERM)
         .addHeader("Location: /foo"));
     server.enqueue(new MockResponse().setBody("DEF"));
-    server.play();
 
-    assertEquals("ABC", readAscii(openConnection(server.getUrl("/foo"))));
+    assertEquals("ABC", readAscii(client.open(server.getUrl("/foo"))));
     RecordedRequest request1 = server.takeRequest();
     assertEquals("GET /foo HTTP/1.1", request1.getRequestLine());
     assertEquals(0, request1.getSequenceNumber());
 
-    assertEquals("ABC", readAscii(openConnection(server.getUrl("/bar"))));
+    assertEquals("ABC", readAscii(client.open(server.getUrl("/bar"))));
     RecordedRequest request2 = server.takeRequest();
     assertEquals("GET /bar HTTP/1.1", request2.getRequestLine());
     assertEquals(1, request2.getSequenceNumber());
 
     // an unrelated request should reuse the pooled connection
-    assertEquals("DEF", readAscii(openConnection(server.getUrl("/baz"))));
+    assertEquals("DEF", readAscii(client.open(server.getUrl("/baz"))));
     RecordedRequest request3 = server.takeRequest();
     assertEquals("GET /baz HTTP/1.1", request3.getRequestLine());
     assertEquals(2, request3.getSequenceNumber());
@@ -430,10 +400,9 @@ private void testResponseCaching(TransferKind transferKind) throws IOException {
         .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS))
         .setBody("ABC"));
     server.enqueue(new MockResponse().setBody("DEF"));
-    server.play();
 
-    client.setSslSocketFactory(sslContext.getSocketFactory());
-    client.setHostnameVerifier(NULL_HOSTNAME_VERIFIER);
+    client.client().setSslSocketFactory(sslContext.getSocketFactory());
+    client.client().setHostnameVerifier(NULL_HOSTNAME_VERIFIER);
 
     HttpsURLConnection connection1 = (HttpsURLConnection) client.open(server.getUrl("/"));
     assertEquals("ABC", readAscii(connection1));
@@ -463,16 +432,14 @@ private void testResponseCaching(TransferKind transferKind) throws IOException {
         .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS))
         .setBody("ABC"));
     server2.enqueue(new MockResponse().setBody("DEF"));
-    server2.play();
 
     server.enqueue(new MockResponse().addHeader("Last-Modified: " + formatDate(-1, TimeUnit.HOURS))
         .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS))
         .setResponseCode(HttpURLConnection.HTTP_MOVED_PERM)
         .addHeader("Location: " + server2.getUrl("/")));
-    server.play();
 
-    client.setSslSocketFactory(sslContext.getSocketFactory());
-    client.setHostnameVerifier(NULL_HOSTNAME_VERIFIER);
+    client.client().setSslSocketFactory(sslContext.getSocketFactory());
+    client.client().setHostnameVerifier(NULL_HOSTNAME_VERIFIER);
 
     HttpURLConnection connection1 = client.open(server.getUrl("/"));
     assertEquals("ABC", readAscii(connection1));
@@ -487,21 +454,21 @@ private void testResponseCaching(TransferKind transferKind) throws IOException {
 
   @Test public void responseCacheRequestHeaders() throws IOException, URISyntaxException {
     server.enqueue(new MockResponse().setBody("ABC"));
-    server.play();
 
-    final AtomicReference<Request> requestRef = new AtomicReference<Request>();
-    client.setOkResponseCache(new AbstractOkResponseCache() {
-      @Override public Response get(Request request) throws IOException {
-        requestRef.set(request);
+    final AtomicReference<Map<String, List<String>>> requestHeadersRef = new AtomicReference<>();
+    client.setResponseCache(new AbstractResponseCache() {
+      @Override public CacheResponse get(URI uri,
+          String requestMethod, Map<String, List<String>> requestHeaders) throws IOException {
+        requestHeadersRef.set(requestHeaders);
         return null;
       }
     });
 
     URL url = server.getUrl("/");
-    URLConnection urlConnection = openConnection(url);
+    URLConnection urlConnection = client.open(url);
     urlConnection.addRequestProperty("A", "android");
     readAscii(urlConnection);
-    assertEquals(Arrays.asList("android"), requestRef.get().headers("A"));
+    assertEquals(Arrays.asList("android"), requestHeadersRef.get().get("A"));
   }
 
   @Test public void serverDisconnectsPrematurelyWithContentLengthHeader() throws IOException {
@@ -523,10 +490,9 @@ private void testServerPrematureDisconnect(TransferKind transferKind) throws IOE
     transferKind.setBody(response, "ABCDE\nFGHIJKLMNOPQRSTUVWXYZ", 16);
     server.enqueue(truncateViolently(response, 16));
     server.enqueue(new MockResponse().setBody("Request #2"));
-    server.play();
 
     BufferedReader reader = new BufferedReader(
-        new InputStreamReader(openConnection(server.getUrl("/")).getInputStream()));
+        new InputStreamReader(client.open(server.getUrl("/")).getInputStream()));
     assertEquals("ABCDE", reader.readLine());
     try {
       reader.readLine();
@@ -538,7 +504,7 @@ private void testServerPrematureDisconnect(TransferKind transferKind) throws IOE
 
     assertEquals(1, cache.getWriteAbortCount());
     assertEquals(0, cache.getWriteSuccessCount());
-    URLConnection connection = openConnection(server.getUrl("/"));
+    URLConnection connection = client.open(server.getUrl("/"));
     assertEquals("Request #2", readAscii(connection));
     assertEquals(1, cache.getWriteAbortCount());
     assertEquals(1, cache.getWriteSuccessCount());
@@ -562,9 +528,8 @@ private void testClientPrematureDisconnect(TransferKind transferKind) throws IOE
     transferKind.setBody(response, "ABCDE\nFGHIJKLMNOPQRSTUVWXYZ", 1024);
     server.enqueue(response);
     server.enqueue(new MockResponse().setBody("Request #2"));
-    server.play();
 
-    URLConnection connection = openConnection(server.getUrl("/"));
+    URLConnection connection = client.open(server.getUrl("/"));
     InputStream in = connection.getInputStream();
     assertEquals("ABCDE", readAscii(connection, 5));
     in.close();
@@ -576,7 +541,7 @@ private void testClientPrematureDisconnect(TransferKind transferKind) throws IOE
 
     assertEquals(1, cache.getWriteAbortCount());
     assertEquals(0, cache.getWriteSuccessCount());
-    connection = openConnection(server.getUrl("/"));
+    connection = client.open(server.getUrl("/"));
     assertEquals("Request #2", readAscii(connection));
     assertEquals(1, cache.getWriteAbortCount());
     assertEquals(1, cache.getWriteSuccessCount());
@@ -591,11 +556,10 @@ private void testClientPrematureDisconnect(TransferKind transferKind) throws IOE
         new MockResponse().addHeader("Last-Modified: " + formatDate(-105, TimeUnit.SECONDS))
             .addHeader("Date: " + formatDate(-5, TimeUnit.SECONDS))
             .setBody("A"));
-    server.play();
 
     URL url = server.getUrl("/");
-    assertEquals("A", readAscii(openConnection(url)));
-    URLConnection connection = openConnection(url);
+    assertEquals("A", readAscii(client.open(url)));
+    URLConnection connection = client.open(url);
     assertEquals("A", readAscii(connection));
     assertNull(connection.getHeaderField("Warning"));
   }
@@ -621,10 +585,9 @@ private void testClientPrematureDisconnect(TransferKind transferKind) throws IOE
     server.enqueue(new MockResponse().addHeader("Last-Modified: " + formatDate(-105, TimeUnit.DAYS))
         .addHeader("Date: " + formatDate(-5, TimeUnit.DAYS))
         .setBody("A"));
-    server.play();
 
-    assertEquals("A", readAscii(openConnection(server.getUrl("/"))));
-    URLConnection connection = openConnection(server.getUrl("/"));
+    assertEquals("A", readAscii(client.open(server.getUrl("/"))));
+    URLConnection connection = client.open(server.getUrl("/"));
     assertEquals("A", readAscii(connection));
     assertEquals("113 HttpURLConnection \"Heuristic expiration\"",
         connection.getHeaderField("Warning"));
@@ -636,11 +599,10 @@ private void testClientPrematureDisconnect(TransferKind transferKind) throws IOE
             .addHeader("Date: " + formatDate(-5, TimeUnit.SECONDS))
             .setBody("A"));
     server.enqueue(new MockResponse().setBody("B"));
-    server.play();
 
     URL url = server.getUrl("/?foo=bar");
-    assertEquals("A", readAscii(openConnection(url)));
-    assertEquals("B", readAscii(openConnection(url)));
+    assertEquals("A", readAscii(client.open(url)));
+    assertEquals("B", readAscii(client.open(url)));
   }
 
   @Test public void expirationDateInThePastWithLastModifiedHeader() throws Exception {
@@ -753,16 +715,15 @@ private void testRequestMethod(String requestMethod, boolean expectCached) throw
     server.enqueue(new MockResponse().addHeader("Expires: " + formatDate(1, TimeUnit.HOURS))
         .addHeader("X-Response-ID: 1"));
     server.enqueue(new MockResponse().addHeader("X-Response-ID: 2"));
-    server.play();
 
     URL url = server.getUrl("/");
 
-    HttpURLConnection request1 = openConnection(url);
+    HttpURLConnection request1 = client.open(url);
     request1.setRequestMethod(requestMethod);
     addRequestBodyIfNecessary(requestMethod, request1);
     assertEquals("1", request1.getHeaderField("X-Response-ID"));
 
-    URLConnection request2 = openConnection(url);
+    URLConnection request2 = client.open(url);
     if (expectCached) {
       assertEquals("1", request2.getHeaderField("X-Response-ID"));
     } else {
@@ -790,18 +751,17 @@ private void testMethodInvalidates(String requestMethod) throws Exception {
         new MockResponse().setBody("A").addHeader("Expires: " + formatDate(1, TimeUnit.HOURS)));
     server.enqueue(new MockResponse().setBody("B"));
     server.enqueue(new MockResponse().setBody("C"));
-    server.play();
 
     URL url = server.getUrl("/");
 
-    assertEquals("A", readAscii(openConnection(url)));
+    assertEquals("A", readAscii(client.open(url)));
 
-    HttpURLConnection invalidate = openConnection(url);
+    HttpURLConnection invalidate = client.open(url);
     invalidate.setRequestMethod(requestMethod);
     addRequestBodyIfNecessary(requestMethod, invalidate);
     assertEquals("B", readAscii(invalidate));
 
-    assertEquals("C", readAscii(openConnection(url)));
+    assertEquals("C", readAscii(client.open(url)));
   }
 
   @Test public void postInvalidatesCacheWithUncacheableResponse() throws Exception {
@@ -812,18 +772,17 @@ private void testMethodInvalidates(String requestMethod) throws Exception {
         new MockResponse().setBody("A").addHeader("Expires: " + formatDate(1, TimeUnit.HOURS)));
     server.enqueue(new MockResponse().setBody("B").setResponseCode(500));
     server.enqueue(new MockResponse().setBody("C"));
-    server.play();
 
     URL url = server.getUrl("/");
 
-    assertEquals("A", readAscii(openConnection(url)));
+    assertEquals("A", readAscii(client.open(url)));
 
-    HttpURLConnection invalidate = openConnection(url);
+    HttpURLConnection invalidate = client.open(url);
     invalidate.setRequestMethod("POST");
     addRequestBodyIfNecessary("POST", invalidate);
     assertEquals("B", readAscii(invalidate));
 
-    assertEquals("C", readAscii(openConnection(url)));
+    assertEquals("C", readAscii(client.open(url)));
   }
 
   @Test public void etag() throws Exception {
@@ -895,15 +854,14 @@ private void testMethodInvalidates(String requestMethod) throws Exception {
         .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS))
         .addHeader("Content-Range: bytes 1000-1001/2000"));
     server.enqueue(new MockResponse().setBody("BB"));
-    server.play();
 
     URL url = server.getUrl("/");
 
-    URLConnection range = openConnection(url);
+    URLConnection range = client.open(url);
     range.addRequestProperty("Range", "bytes=1000-1001");
     assertEquals("AA", readAscii(range));
 
-    assertEquals("BB", readAscii(openConnection(url)));
+    assertEquals("BB", readAscii(client.open(url)));
   }
 
   @Test public void serverReturnsDocumentOlderThanCache() throws Exception {
@@ -912,12 +870,11 @@ private void testMethodInvalidates(String requestMethod) throws Exception {
         .addHeader("Expires: " + formatDate(-1, TimeUnit.HOURS)));
     server.enqueue(new MockResponse().setBody("B")
         .addHeader("Last-Modified: " + formatDate(-4, TimeUnit.HOURS)));
-    server.play();
 
     URL url = server.getUrl("/");
 
-    assertEquals("A", readAscii(openConnection(url)));
-    assertEquals("A", readAscii(openConnection(url)));
+    assertEquals("A", readAscii(client.open(url)));
+    assertEquals("A", readAscii(client.open(url)));
   }
 
   @Test public void nonIdentityEncodingAndConditionalCache() throws Exception {
@@ -934,23 +891,21 @@ private void testMethodInvalidates(String requestMethod) throws Exception {
 
   private void assertNonIdentityEncodingCached(MockResponse response) throws Exception {
     server.enqueue(
-        response.setBody(gzip("ABCABCABC".getBytes("UTF-8"))).addHeader("Content-Encoding: gzip"));
+        response.setBody(gzip("ABCABCABC")).addHeader("Content-Encoding: gzip"));
     server.enqueue(new MockResponse().setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
     server.enqueue(new MockResponse().setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
 
-    server.play();
-
     // At least three request/response pairs are required because after the first request is cached
     // a different execution path might be taken. Thus modifications to the cache applied during
     // the second request might not be visible until another request is performed.
-    assertEquals("ABCABCABC", readAscii(openConnection(server.getUrl("/"))));
-    assertEquals("ABCABCABC", readAscii(openConnection(server.getUrl("/"))));
-    assertEquals("ABCABCABC", readAscii(openConnection(server.getUrl("/"))));
+    assertEquals("ABCABCABC", readAscii(client.open(server.getUrl("/"))));
+    assertEquals("ABCABCABC", readAscii(client.open(server.getUrl("/"))));
+    assertEquals("ABCABCABC", readAscii(client.open(server.getUrl("/"))));
   }
 
   @Test public void notModifiedSpecifiesEncoding() throws Exception {
     server.enqueue(new MockResponse()
-        .setBody(gzip("ABCABCABC".getBytes("UTF-8")))
+        .setBody(gzip("ABCABCABC"))
         .addHeader("Content-Encoding: gzip")
         .addHeader("Last-Modified: " + formatDate(-2, TimeUnit.HOURS))
         .addHeader("Expires: " + formatDate(-1, TimeUnit.HOURS)));
@@ -960,10 +915,37 @@ private void assertNonIdentityEncodingCached(MockResponse response) throws Excep
     server.enqueue(new MockResponse()
         .setBody("DEFDEFDEF"));
 
-    server.play();
-    assertEquals("ABCABCABC", readAscii(openConnection(server.getUrl("/"))));
-    assertEquals("ABCABCABC", readAscii(openConnection(server.getUrl("/"))));
-    assertEquals("DEFDEFDEF", readAscii(openConnection(server.getUrl("/"))));
+    assertEquals("ABCABCABC", readAscii(client.open(server.getUrl("/"))));
+    assertEquals("ABCABCABC", readAscii(client.open(server.getUrl("/"))));
+    assertEquals("DEFDEFDEF", readAscii(client.open(server.getUrl("/"))));
+  }
+
+  /** https://github.com/square/okhttp/issues/947 */
+  @Test public void gzipAndVaryOnAcceptEncoding() throws Exception {
+    server.enqueue(new MockResponse()
+        .setBody(gzip("ABCABCABC"))
+        .addHeader("Content-Encoding: gzip")
+        .addHeader("Vary: Accept-Encoding")
+        .addHeader("Cache-Control: max-age=60"));
+    server.enqueue(new MockResponse().setBody("FAIL"));
+
+    assertEquals("ABCABCABC", readAscii(client.open(server.getUrl("/"))));
+    assertEquals("ABCABCABC", readAscii(client.open(server.getUrl("/"))));
+  }
+
+  @Test public void conditionalCacheHitIsNotDoublePooled() throws Exception {
+    server.enqueue(new MockResponse().addHeader("ETag: v1").setBody("A"));
+    server.enqueue(new MockResponse()
+        .clearHeaders()
+        .setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
+
+    ConnectionPool pool = ConnectionPool.getDefault();
+    pool.evictAll();
+    client.client().setConnectionPool(pool);
+
+    assertEquals("A", readAscii(client.open(server.getUrl("/"))));
+    assertEquals("A", readAscii(client.open(server.getUrl("/"))));
+    assertEquals(1, client.client().getConnectionPool().getConnectionCount());
   }
 
   @Test public void expiresDateBeforeModifiedDate() throws Exception {
@@ -979,10 +961,9 @@ private void assertNonIdentityEncodingCached(MockResponse response) throws Excep
         .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS)));
     server.enqueue(new MockResponse().setBody("B"));
 
-    server.play();
-    assertEquals("A", readAscii(openConnection(server.getUrl("/"))));
+    assertEquals("A", readAscii(client.open(server.getUrl("/"))));
 
-    URLConnection connection = openConnection(server.getUrl("/"));
+    URLConnection connection = client.open(server.getUrl("/"));
     connection.addRequestProperty("Cache-Control", "max-age=30");
     assertEquals("B", readAscii(connection));
   }
@@ -993,10 +974,9 @@ private void assertNonIdentityEncodingCached(MockResponse response) throws Excep
         .addHeader("Date: " + formatDate(0, TimeUnit.MINUTES)));
     server.enqueue(new MockResponse().setBody("B"));
 
-    server.play();
-    assertEquals("A", readAscii(openConnection(server.getUrl("/"))));
+    assertEquals("A", readAscii(client.open(server.getUrl("/"))));
 
-    URLConnection connection = openConnection(server.getUrl("/"));
+    URLConnection connection = client.open(server.getUrl("/"));
     connection.addRequestProperty("Cache-Control", "min-fresh=120");
     assertEquals("B", readAscii(connection));
   }
@@ -1007,10 +987,9 @@ private void assertNonIdentityEncodingCached(MockResponse response) throws Excep
         .addHeader("Date: " + formatDate(-4, TimeUnit.MINUTES)));
     server.enqueue(new MockResponse().setBody("B"));
 
-    server.play();
-    assertEquals("A", readAscii(openConnection(server.getUrl("/"))));
+    assertEquals("A", readAscii(client.open(server.getUrl("/"))));
 
-    URLConnection connection = openConnection(server.getUrl("/"));
+    URLConnection connection = client.open(server.getUrl("/"));
     connection.addRequestProperty("Cache-Control", "max-stale=180");
     assertEquals("A", readAscii(connection));
     assertEquals("110 HttpURLConnection \"Response is stale\"",
@@ -1023,19 +1002,17 @@ private void assertNonIdentityEncodingCached(MockResponse response) throws Excep
         .addHeader("Date: " + formatDate(-4, TimeUnit.MINUTES)));
     server.enqueue(new MockResponse().setBody("B"));
 
-    server.play();
-    assertEquals("A", readAscii(openConnection(server.getUrl("/"))));
+    assertEquals("A", readAscii(client.open(server.getUrl("/"))));
 
-    URLConnection connection = openConnection(server.getUrl("/"));
+    URLConnection connection = client.open(server.getUrl("/"));
     connection.addRequestProperty("Cache-Control", "max-stale=180");
     assertEquals("B", readAscii(connection));
   }
 
   @Test public void requestOnlyIfCachedWithNoResponseCached() throws IOException {
     // (no responses enqueued)
-    server.play();
 
-    HttpURLConnection connection = openConnection(server.getUrl("/"));
+    HttpURLConnection connection = client.open(server.getUrl("/"));
     connection.addRequestProperty("Cache-Control", "only-if-cached");
     assertGatewayTimeout(connection);
     assertEquals(1, cache.getRequestCount());
@@ -1047,10 +1024,9 @@ private void assertNonIdentityEncodingCached(MockResponse response) throws Excep
     server.enqueue(new MockResponse().setBody("A")
         .addHeader("Cache-Control: max-age=30")
         .addHeader("Date: " + formatDate(0, TimeUnit.MINUTES)));
-    server.play();
 
-    assertEquals("A", readAscii(openConnection(server.getUrl("/"))));
-    URLConnection connection = openConnection(server.getUrl("/"));
+    assertEquals("A", readAscii(client.open(server.getUrl("/"))));
+    URLConnection connection = client.open(server.getUrl("/"));
     connection.addRequestProperty("Cache-Control", "only-if-cached");
     assertEquals("A", readAscii(connection));
     assertEquals(2, cache.getRequestCount());
@@ -1062,10 +1038,9 @@ private void assertNonIdentityEncodingCached(MockResponse response) throws Excep
     server.enqueue(new MockResponse().setBody("A")
         .addHeader("Cache-Control: max-age=30")
         .addHeader("Date: " + formatDate(-1, TimeUnit.MINUTES)));
-    server.play();
 
-    assertEquals("A", readAscii(openConnection(server.getUrl("/"))));
-    HttpURLConnection connection = openConnection(server.getUrl("/"));
+    assertEquals("A", readAscii(client.open(server.getUrl("/"))));
+    HttpURLConnection connection = client.open(server.getUrl("/"));
     connection.addRequestProperty("Cache-Control", "only-if-cached");
     assertGatewayTimeout(connection);
     assertEquals(2, cache.getRequestCount());
@@ -1075,10 +1050,9 @@ private void assertNonIdentityEncodingCached(MockResponse response) throws Excep
 
   @Test public void requestOnlyIfCachedWithUnhelpfulResponseCached() throws IOException {
     server.enqueue(new MockResponse().setBody("A"));
-    server.play();
 
-    assertEquals("A", readAscii(openConnection(server.getUrl("/"))));
-    HttpURLConnection connection = openConnection(server.getUrl("/"));
+    assertEquals("A", readAscii(client.open(server.getUrl("/"))));
+    HttpURLConnection connection = client.open(server.getUrl("/"));
     connection.addRequestProperty("Cache-Control", "only-if-cached");
     assertGatewayTimeout(connection);
     assertEquals(2, cache.getRequestCount());
@@ -1093,11 +1067,10 @@ private void assertNonIdentityEncodingCached(MockResponse response) throws Excep
             .addHeader("Cache-Control: max-age=60")
             .setBody("A"));
     server.enqueue(new MockResponse().setBody("B"));
-    server.play();
 
     URL url = server.getUrl("/");
-    assertEquals("A", readAscii(openConnection(url)));
-    URLConnection connection = openConnection(url);
+    assertEquals("A", readAscii(client.open(url)));
+    URLConnection connection = client.open(url);
     connection.setRequestProperty("Cache-Control", "no-cache");
     assertEquals("B", readAscii(connection));
   }
@@ -1109,11 +1082,10 @@ private void assertNonIdentityEncodingCached(MockResponse response) throws Excep
             .addHeader("Cache-Control: max-age=60")
             .setBody("A"));
     server.enqueue(new MockResponse().setBody("B"));
-    server.play();
 
     URL url = server.getUrl("/");
-    assertEquals("A", readAscii(openConnection(url)));
-    URLConnection connection = openConnection(url);
+    assertEquals("A", readAscii(client.open(url)));
+    URLConnection connection = client.open(url);
     connection.setRequestProperty("Pragma", "no-cache");
     assertEquals("B", readAscii(connection));
   }
@@ -1144,12 +1116,11 @@ private RecordedRequest assertClientSuppliedCondition(MockResponse seed, String
       String conditionValue) throws Exception {
     server.enqueue(seed.setBody("A"));
     server.enqueue(new MockResponse().setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
-    server.play();
 
     URL url = server.getUrl("/");
-    assertEquals("A", readAscii(openConnection(url)));
+    assertEquals("A", readAscii(client.open(url)));
 
-    HttpURLConnection connection = openConnection(url);
+    HttpURLConnection connection = client.open(url);
     connection.addRequestProperty(conditionName, conditionValue);
     assertEquals(HttpURLConnection.HTTP_NOT_MODIFIED, connection.getResponseCode());
     assertEquals("", readAscii(connection));
@@ -1166,10 +1137,9 @@ private RecordedRequest assertClientSuppliedCondition(MockResponse seed, String
    */
   @Test public void setIfModifiedSince() throws Exception {
     server.enqueue(new MockResponse().setBody("A"));
-    server.play();
 
     URL url = server.getUrl("/");
-    URLConnection connection = openConnection(url);
+    URLConnection connection = client.open(url);
     connection.setIfModifiedSince(1393666200000L);
     assertEquals("A", readAscii(connection));
     RecordedRequest request = server.takeRequest();
@@ -1197,10 +1167,9 @@ private RecordedRequest assertClientSuppliedCondition(MockResponse seed, String
         .setBody("A"));
     server.enqueue(new MockResponse()
         .setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
-    server.play();
 
-    assertEquals("A", readAscii(openConnection(server.getUrl("/"))));
-    assertEquals("A", readAscii(openConnection(server.getUrl("/"))));
+    assertEquals("A", readAscii(client.open(server.getUrl("/"))));
+    assertEquals("A", readAscii(client.open(server.getUrl("/"))));
 
     // The first request has no conditions.
     RecordedRequest request1 = server.takeRequest();
@@ -1213,9 +1182,8 @@ private RecordedRequest assertClientSuppliedCondition(MockResponse seed, String
 
   @Test public void clientSuppliedConditionWithoutCachedResult() throws Exception {
     server.enqueue(new MockResponse().setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
-    server.play();
 
-    HttpURLConnection connection = openConnection(server.getUrl("/"));
+    HttpURLConnection connection = client.open(server.getUrl("/"));
     String clientIfModifiedSince = formatDate(-24, TimeUnit.HOURS);
     connection.addRequestProperty("If-Modified-Since", clientIfModifiedSince);
     assertEquals(HttpURLConnection.HTTP_NOT_MODIFIED, connection.getResponseCode());
@@ -1228,13 +1196,12 @@ private RecordedRequest assertClientSuppliedCondition(MockResponse seed, String
             .addHeader("Cache-Control: max-age=60")
             .setBody("A"));
     server.enqueue(new MockResponse().setBody("B"));
-    server.play();
 
     URL url = server.getUrl("/");
-    URLConnection connection = openConnection(url);
+    URLConnection connection = client.open(url);
     connection.addRequestProperty("Authorization", "password");
     assertEquals("A", readAscii(connection));
-    assertEquals("B", readAscii(openConnection(url)));
+    assertEquals("B", readAscii(client.open(url)));
   }
 
   @Test public void authorizationResponseCachedWithSMaxAge() throws Exception {
@@ -1254,13 +1221,12 @@ private RecordedRequest assertClientSuppliedCondition(MockResponse seed, String
   public void assertAuthorizationRequestFullyCached(MockResponse response) throws Exception {
     server.enqueue(response.addHeader("Cache-Control: max-age=60").setBody("A"));
     server.enqueue(new MockResponse().setBody("B"));
-    server.play();
 
     URL url = server.getUrl("/");
-    URLConnection connection = openConnection(url);
+    URLConnection connection = client.open(url);
     connection.addRequestProperty("Authorization", "password");
     assertEquals("A", readAscii(connection));
-    assertEquals("A", readAscii(openConnection(url)));
+    assertEquals("A", readAscii(client.open(url)));
   }
 
   @Test public void contentLocationDoesNotPopulateCache() throws Exception {
@@ -1268,46 +1234,43 @@ public void assertAuthorizationRequestFullyCached(MockResponse response) throws
         .addHeader("Content-Location: /bar")
         .setBody("A"));
     server.enqueue(new MockResponse().setBody("B"));
-    server.play();
 
-    assertEquals("A", readAscii(openConnection(server.getUrl("/foo"))));
-    assertEquals("B", readAscii(openConnection(server.getUrl("/bar"))));
+    assertEquals("A", readAscii(client.open(server.getUrl("/foo"))));
+    assertEquals("B", readAscii(client.open(server.getUrl("/bar"))));
   }
 
   @Test public void useCachesFalseDoesNotWriteToCache() throws Exception {
     server.enqueue(
         new MockResponse().addHeader("Cache-Control: max-age=60").setBody("A").setBody("A"));
     server.enqueue(new MockResponse().setBody("B"));
-    server.play();
 
-    URLConnection connection = openConnection(server.getUrl("/"));
+    URLConnection connection = client.open(server.getUrl("/"));
     connection.setUseCaches(false);
     assertEquals("A", readAscii(connection));
-    assertEquals("B", readAscii(openConnection(server.getUrl("/"))));
+    assertEquals("B", readAscii(client.open(server.getUrl("/"))));
   }
 
   @Test public void useCachesFalseDoesNotReadFromCache() throws Exception {
     server.enqueue(
         new MockResponse().addHeader("Cache-Control: max-age=60").setBody("A").setBody("A"));
     server.enqueue(new MockResponse().setBody("B"));
-    server.play();
 
-    assertEquals("A", readAscii(openConnection(server.getUrl("/"))));
-    URLConnection connection = openConnection(server.getUrl("/"));
+    assertEquals("A", readAscii(client.open(server.getUrl("/"))));
+    URLConnection connection = client.open(server.getUrl("/"));
     connection.setUseCaches(false);
     assertEquals("B", readAscii(connection));
   }
 
   @Test public void defaultUseCachesSetsInitialValueOnly() throws Exception {
     URL url = new URL("http://localhost/");
-    URLConnection c1 = openConnection(url);
-    URLConnection c2 = openConnection(url);
+    URLConnection c1 = client.open(url);
+    URLConnection c2 = client.open(url);
     assertTrue(c1.getDefaultUseCaches());
     c1.setDefaultUseCaches(false);
     try {
       assertTrue(c1.getUseCaches());
       assertTrue(c2.getUseCaches());
-      URLConnection c3 = openConnection(url);
+      URLConnection c3 = client.open(url);
       assertFalse(c3.getUseCaches());
     } finally {
       c1.setDefaultUseCaches(true);
@@ -1320,11 +1283,10 @@ public void assertAuthorizationRequestFullyCached(MockResponse response) throws
         .setBody("A"));
     server.enqueue(new MockResponse().setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
     server.enqueue(new MockResponse().setBody("B"));
-    server.play();
 
-    assertEquals("A", readAscii(openConnection(server.getUrl("/a"))));
-    assertEquals("A", readAscii(openConnection(server.getUrl("/a"))));
-    assertEquals("B", readAscii(openConnection(server.getUrl("/b"))));
+    assertEquals("A", readAscii(client.open(server.getUrl("/a"))));
+    assertEquals("A", readAscii(client.open(server.getUrl("/a"))));
+    assertEquals("B", readAscii(client.open(server.getUrl("/b"))));
 
     assertEquals(0, server.takeRequest().getSequenceNumber());
     assertEquals(1, server.takeRequest().getSequenceNumber());
@@ -1337,14 +1299,13 @@ public void assertAuthorizationRequestFullyCached(MockResponse response) throws
         .setBody("A"));
     server.enqueue(new MockResponse().setBody("B"));
     server.enqueue(new MockResponse().setBody("C"));
-    server.play();
 
-    assertEquals("A", readAscii(openConnection(server.getUrl("/"))));
+    assertEquals("A", readAscii(client.open(server.getUrl("/"))));
     assertEquals(1, cache.getRequestCount());
     assertEquals(1, cache.getNetworkCount());
     assertEquals(0, cache.getHitCount());
-    assertEquals("B", readAscii(openConnection(server.getUrl("/"))));
-    assertEquals("C", readAscii(openConnection(server.getUrl("/"))));
+    assertEquals("B", readAscii(client.open(server.getUrl("/"))));
+    assertEquals("C", readAscii(client.open(server.getUrl("/"))));
     assertEquals(3, cache.getRequestCount());
     assertEquals(3, cache.getNetworkCount());
     assertEquals(0, cache.getHitCount());
@@ -1356,14 +1317,13 @@ public void assertAuthorizationRequestFullyCached(MockResponse response) throws
         .setBody("A"));
     server.enqueue(new MockResponse().setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
     server.enqueue(new MockResponse().setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
-    server.play();
 
-    assertEquals("A", readAscii(openConnection(server.getUrl("/"))));
+    assertEquals("A", readAscii(client.open(server.getUrl("/"))));
     assertEquals(1, cache.getRequestCount());
     assertEquals(1, cache.getNetworkCount());
     assertEquals(0, cache.getHitCount());
-    assertEquals("A", readAscii(openConnection(server.getUrl("/"))));
-    assertEquals("A", readAscii(openConnection(server.getUrl("/"))));
+    assertEquals("A", readAscii(client.open(server.getUrl("/"))));
+    assertEquals("A", readAscii(client.open(server.getUrl("/"))));
     assertEquals(3, cache.getRequestCount());
     assertEquals(3, cache.getNetworkCount());
     assertEquals(2, cache.getHitCount());
@@ -1371,14 +1331,13 @@ public void assertAuthorizationRequestFullyCached(MockResponse response) throws
 
   @Test public void statisticsFullCacheHit() throws Exception {
     server.enqueue(new MockResponse().addHeader("Cache-Control: max-age=60").setBody("A"));
-    server.play();
 
-    assertEquals("A", readAscii(openConnection(server.getUrl("/"))));
+    assertEquals("A", readAscii(client.open(server.getUrl("/"))));
     assertEquals(1, cache.getRequestCount());
     assertEquals(1, cache.getNetworkCount());
     assertEquals(0, cache.getHitCount());
-    assertEquals("A", readAscii(openConnection(server.getUrl("/"))));
-    assertEquals("A", readAscii(openConnection(server.getUrl("/"))));
+    assertEquals("A", readAscii(client.open(server.getUrl("/"))));
+    assertEquals("A", readAscii(client.open(server.getUrl("/"))));
     assertEquals(3, cache.getRequestCount());
     assertEquals(1, cache.getNetworkCount());
     assertEquals(2, cache.getHitCount());
@@ -1389,14 +1348,13 @@ public void assertAuthorizationRequestFullyCached(MockResponse response) throws
         .addHeader("Vary: Accept-Language")
         .setBody("A"));
     server.enqueue(new MockResponse().setBody("B"));
-    server.play();
 
     URL url = server.getUrl("/");
-    HttpURLConnection frConnection = openConnection(url);
+    HttpURLConnection frConnection = client.open(url);
     frConnection.addRequestProperty("Accept-Language", "fr-CA");
     assertEquals("A", readAscii(frConnection));
 
-    HttpURLConnection enConnection = openConnection(url);
+    HttpURLConnection enConnection = client.open(url);
     enConnection.addRequestProperty("Accept-Language", "en-US");
     assertEquals("B", readAscii(enConnection));
   }
@@ -1406,13 +1364,12 @@ public void assertAuthorizationRequestFullyCached(MockResponse response) throws
         .addHeader("Vary: Accept-Language")
         .setBody("A"));
     server.enqueue(new MockResponse().setBody("B"));
-    server.play();
 
     URL url = server.getUrl("/");
-    URLConnection connection1 = openConnection(url);
+    URLConnection connection1 = client.open(url);
     connection1.addRequestProperty("Accept-Language", "fr-CA");
     assertEquals("A", readAscii(connection1));
-    URLConnection connection2 = openConnection(url);
+    URLConnection connection2 = client.open(url);
     connection2.addRequestProperty("Accept-Language", "fr-CA");
     assertEquals("A", readAscii(connection2));
   }
@@ -1422,10 +1379,9 @@ public void assertAuthorizationRequestFullyCached(MockResponse response) throws
         .addHeader("Vary: Foo")
         .setBody("A"));
     server.enqueue(new MockResponse().setBody("B"));
-    server.play();
 
-    assertEquals("A", readAscii(openConnection(server.getUrl("/"))));
-    assertEquals("A", readAscii(openConnection(server.getUrl("/"))));
+    assertEquals("A", readAscii(client.open(server.getUrl("/"))));
+    assertEquals("A", readAscii(client.open(server.getUrl("/"))));
   }
 
   @Test public void varyMatchesAddedRequestHeaderField() throws Exception {
@@ -1433,10 +1389,9 @@ public void assertAuthorizationRequestFullyCached(MockResponse response) throws
         .addHeader("Vary: Foo")
         .setBody("A"));
     server.enqueue(new MockResponse().setBody("B"));
-    server.play();
 
-    assertEquals("A", readAscii(openConnection(server.getUrl("/"))));
-    URLConnection fooConnection = openConnection(server.getUrl("/"));
+    assertEquals("A", readAscii(client.open(server.getUrl("/"))));
+    URLConnection fooConnection = client.open(server.getUrl("/"));
     fooConnection.addRequestProperty("Foo", "bar");
     assertEquals("B", readAscii(fooConnection));
   }
@@ -1446,12 +1401,11 @@ public void assertAuthorizationRequestFullyCached(MockResponse response) throws
         .addHeader("Vary: Foo")
         .setBody("A"));
     server.enqueue(new MockResponse().setBody("B"));
-    server.play();
 
-    URLConnection fooConnection = openConnection(server.getUrl("/"));
+    URLConnection fooConnection = client.open(server.getUrl("/"));
     fooConnection.addRequestProperty("Foo", "bar");
     assertEquals("A", readAscii(fooConnection));
-    assertEquals("B", readAscii(openConnection(server.getUrl("/"))));
+    assertEquals("B", readAscii(client.open(server.getUrl("/"))));
   }
 
   @Test public void varyFieldsAreCaseInsensitive() throws Exception {
@@ -1459,13 +1413,12 @@ public void assertAuthorizationRequestFullyCached(MockResponse response) throws
         .addHeader("Vary: ACCEPT-LANGUAGE")
         .setBody("A"));
     server.enqueue(new MockResponse().setBody("B"));
-    server.play();
 
     URL url = server.getUrl("/");
-    URLConnection connection1 = openConnection(url);
+    URLConnection connection1 = client.open(url);
     connection1.addRequestProperty("Accept-Language", "fr-CA");
     assertEquals("A", readAscii(connection1));
-    URLConnection connection2 = openConnection(url);
+    URLConnection connection2 = client.open(url);
     connection2.addRequestProperty("accept-language", "fr-CA");
     assertEquals("A", readAscii(connection2));
   }
@@ -1476,15 +1429,14 @@ public void assertAuthorizationRequestFullyCached(MockResponse response) throws
         .addHeader("Vary: Accept-Encoding")
         .setBody("A"));
     server.enqueue(new MockResponse().setBody("B"));
-    server.play();
 
     URL url = server.getUrl("/");
-    URLConnection connection1 = openConnection(url);
+    URLConnection connection1 = client.open(url);
     connection1.addRequestProperty("Accept-Language", "fr-CA");
     connection1.addRequestProperty("Accept-Charset", "UTF-8");
     connection1.addRequestProperty("Accept-Encoding", "identity");
     assertEquals("A", readAscii(connection1));
-    URLConnection connection2 = openConnection(url);
+    URLConnection connection2 = client.open(url);
     connection2.addRequestProperty("Accept-Language", "fr-CA");
     connection2.addRequestProperty("Accept-Charset", "UTF-8");
     connection2.addRequestProperty("Accept-Encoding", "identity");
@@ -1497,15 +1449,14 @@ public void assertAuthorizationRequestFullyCached(MockResponse response) throws
         .addHeader("Vary: Accept-Encoding")
         .setBody("A"));
     server.enqueue(new MockResponse().setBody("B"));
-    server.play();
 
     URL url = server.getUrl("/");
-    URLConnection frConnection = openConnection(url);
+    URLConnection frConnection = client.open(url);
     frConnection.addRequestProperty("Accept-Language", "fr-CA");
     frConnection.addRequestProperty("Accept-Charset", "UTF-8");
     frConnection.addRequestProperty("Accept-Encoding", "identity");
     assertEquals("A", readAscii(frConnection));
-    URLConnection enConnection = openConnection(url);
+    URLConnection enConnection = client.open(url);
     enConnection.addRequestProperty("Accept-Language", "en-CA");
     enConnection.addRequestProperty("Accept-Charset", "UTF-8");
     enConnection.addRequestProperty("Accept-Encoding", "identity");
@@ -1517,15 +1468,14 @@ public void assertAuthorizationRequestFullyCached(MockResponse response) throws
         .addHeader("Vary: Accept-Language")
         .setBody("A"));
     server.enqueue(new MockResponse().setBody("B"));
-    server.play();
 
     URL url = server.getUrl("/");
-    URLConnection connection1 = openConnection(url);
+    URLConnection connection1 = client.open(url);
     connection1.addRequestProperty("Accept-Language", "fr-CA, fr-FR");
     connection1.addRequestProperty("Accept-Language", "en-US");
     assertEquals("A", readAscii(connection1));
 
-    URLConnection connection2 = openConnection(url);
+    URLConnection connection2 = client.open(url);
     connection2.addRequestProperty("Accept-Language", "fr-CA, fr-FR");
     connection2.addRequestProperty("Accept-Language", "en-US");
     assertEquals("A", readAscii(connection2));
@@ -1536,15 +1486,14 @@ public void assertAuthorizationRequestFullyCached(MockResponse response) throws
         .addHeader("Vary: Accept-Language")
         .setBody("A"));
     server.enqueue(new MockResponse().setBody("B"));
-    server.play();
 
     URL url = server.getUrl("/");
-    URLConnection connection1 = openConnection(url);
+    URLConnection connection1 = client.open(url);
     connection1.addRequestProperty("Accept-Language", "fr-CA, fr-FR");
     connection1.addRequestProperty("Accept-Language", "en-US");
     assertEquals("A", readAscii(connection1));
 
-    URLConnection connection2 = openConnection(url);
+    URLConnection connection2 = client.open(url);
     connection2.addRequestProperty("Accept-Language", "fr-CA");
     connection2.addRequestProperty("Accept-Language", "en-US");
     assertEquals("B", readAscii(connection2));
@@ -1555,10 +1504,9 @@ public void assertAuthorizationRequestFullyCached(MockResponse response) throws
         .addHeader("Vary: *")
         .setBody("A"));
     server.enqueue(new MockResponse().setBody("B"));
-    server.play();
 
-    assertEquals("A", readAscii(openConnection(server.getUrl("/"))));
-    assertEquals("B", readAscii(openConnection(server.getUrl("/"))));
+    assertEquals("A", readAscii(client.open(server.getUrl("/"))));
+    assertEquals("B", readAscii(client.open(server.getUrl("/"))));
   }
 
   @Test public void varyAndHttps() throws Exception {
@@ -1567,7 +1515,6 @@ public void assertAuthorizationRequestFullyCached(MockResponse response) throws
         .addHeader("Vary: Accept-Language")
         .setBody("A"));
     server.enqueue(new MockResponse().setBody("B"));
-    server.play();
 
     URL url = server.getUrl("/");
     HttpsURLConnection connection1 = (HttpsURLConnection) client.open(url);
@@ -1592,12 +1539,11 @@ public void assertAuthorizationRequestFullyCached(MockResponse response) throws
     server.enqueue(new MockResponse().addHeader(
         "Set-Cookie: a=SECOND; domain=" + server.getCookieDomain() + ";")
         .setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
-    server.play();
 
     URL url = server.getUrl("/");
-    assertEquals("A", readAscii(openConnection(url)));
+    assertEquals("A", readAscii(client.open(url)));
     assertCookies(url, "a=FIRST");
-    assertEquals("A", readAscii(openConnection(url)));
+    assertEquals("A", readAscii(client.open(url)));
     assertCookies(url, "a=SECOND");
   }
 
@@ -1608,13 +1554,12 @@ public void assertAuthorizationRequestFullyCached(MockResponse response) throws
         .setBody("A"));
     server.enqueue(new MockResponse().addHeader("Allow: GET, HEAD, PUT")
         .setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
-    server.play();
 
-    URLConnection connection1 = openConnection(server.getUrl("/"));
+    URLConnection connection1 = client.open(server.getUrl("/"));
     assertEquals("A", readAscii(connection1));
     assertEquals("GET, HEAD", connection1.getHeaderField("Allow"));
 
-    URLConnection connection2 = openConnection(server.getUrl("/"));
+    URLConnection connection2 = client.open(server.getUrl("/"));
     assertEquals("A", readAscii(connection2));
     assertEquals("GET, HEAD, PUT", connection2.getHeaderField("Allow"));
   }
@@ -1626,13 +1571,12 @@ public void assertAuthorizationRequestFullyCached(MockResponse response) throws
         .setBody("A"));
     server.enqueue(new MockResponse().addHeader("Transfer-Encoding: none")
         .setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
-    server.play();
 
-    URLConnection connection1 = openConnection(server.getUrl("/"));
+    URLConnection connection1 = client.open(server.getUrl("/"));
     assertEquals("A", readAscii(connection1));
     assertEquals("identity", connection1.getHeaderField("Transfer-Encoding"));
 
-    URLConnection connection2 = openConnection(server.getUrl("/"));
+    URLConnection connection2 = client.open(server.getUrl("/"));
     assertEquals("A", readAscii(connection2));
     assertEquals("identity", connection2.getHeaderField("Transfer-Encoding"));
   }
@@ -1643,13 +1587,12 @@ public void assertAuthorizationRequestFullyCached(MockResponse response) throws
         .addHeader("Cache-Control: max-age=0")
         .setBody("A"));
     server.enqueue(new MockResponse().setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
-    server.play();
 
-    URLConnection connection1 = openConnection(server.getUrl("/"));
+    URLConnection connection1 = client.open(server.getUrl("/"));
     assertEquals("A", readAscii(connection1));
     assertEquals("199 test danger", connection1.getHeaderField("Warning"));
 
-    URLConnection connection2 = openConnection(server.getUrl("/"));
+    URLConnection connection2 = client.open(server.getUrl("/"));
     assertEquals("A", readAscii(connection2));
     assertEquals(null, connection2.getHeaderField("Warning"));
   }
@@ -1660,19 +1603,18 @@ public void assertAuthorizationRequestFullyCached(MockResponse response) throws
         .addHeader("Cache-Control: max-age=0")
         .setBody("A"));
     server.enqueue(new MockResponse().setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
-    server.play();
 
-    URLConnection connection1 = openConnection(server.getUrl("/"));
+    URLConnection connection1 = client.open(server.getUrl("/"));
     assertEquals("A", readAscii(connection1));
     assertEquals("299 test danger", connection1.getHeaderField("Warning"));
 
-    URLConnection connection2 = openConnection(server.getUrl("/"));
+    URLConnection connection2 = client.open(server.getUrl("/"));
     assertEquals("A", readAscii(connection2));
     assertEquals("299 test danger", connection2.getHeaderField("Warning"));
   }
 
   public void assertCookies(URL url, String... expectedCookies) throws Exception {
-    List<String> actualCookies = new ArrayList<String>();
+    List<String> actualCookies = new ArrayList<>();
     for (HttpCookie cookie : cookieManager.getCookieStore().get(url.toURI())) {
       actualCookies.add(cookie.toString());
     }
@@ -1694,21 +1636,20 @@ public void assertCookies(URL url, String... expectedCookies) throws Exception {
         .addHeader("Allow: GET, HEAD")
         .setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
     server.enqueue(new MockResponse().setBody("B"));
-    server.play();
 
     // cache miss; seed the cache
-    HttpURLConnection connection1 = openConnection(server.getUrl("/a"));
+    HttpURLConnection connection1 = client.open(server.getUrl("/a"));
     assertEquals("A", readAscii(connection1));
     assertEquals(null, connection1.getHeaderField("Allow"));
 
     // conditional cache hit; update the cache
-    HttpURLConnection connection2 = openConnection(server.getUrl("/a"));
+    HttpURLConnection connection2 = client.open(server.getUrl("/a"));
     assertEquals(HttpURLConnection.HTTP_OK, connection2.getResponseCode());
     assertEquals("A", readAscii(connection2));
     assertEquals("GET, HEAD", connection2.getHeaderField("Allow"));
 
     // full cache hit
-    HttpURLConnection connection3 = openConnection(server.getUrl("/a"));
+    HttpURLConnection connection3 = client.open(server.getUrl("/a"));
     assertEquals("A", readAscii(connection3));
     assertEquals("GET, HEAD", connection3.getHeaderField("Allow"));
 
@@ -1719,15 +1660,11 @@ public void assertCookies(URL url, String... expectedCookies) throws Exception {
     server.enqueue(new MockResponse().setBody("A")
         .addHeader("Cache-Control: max-age=30")
         .addHeader("Date: " + formatDate(0, TimeUnit.MINUTES)));
-    server.play();
 
-    assertEquals("A", readAscii(openConnection(server.getUrl("/"))));
-    URLConnection connection = openConnection(server.getUrl("/"));
+    assertEquals("A", readAscii(client.open(server.getUrl("/"))));
+    URLConnection connection = client.open(server.getUrl("/"));
     connection.addRequestProperty("Cache-Control", "only-if-cached");
     assertEquals("A", readAscii(connection));
-
-    String source = connection.getHeaderField(OkHeaders.RESPONSE_SOURCE);
-    assertEquals(ResponseSource.CACHE + " 200", source);
   }
 
   @Test public void responseSourceHeaderConditionalCacheFetched() throws IOException {
@@ -1737,14 +1674,10 @@ public void assertCookies(URL url, String... expectedCookies) throws Exception {
     server.enqueue(new MockResponse().setBody("B")
         .addHeader("Cache-Control: max-age=30")
         .addHeader("Date: " + formatDate(0, TimeUnit.MINUTES)));
-    server.play();
 
-    assertEquals("A", readAscii(openConnection(server.getUrl("/"))));
-    HttpURLConnection connection = openConnection(server.getUrl("/"));
+    assertEquals("A", readAscii(client.open(server.getUrl("/"))));
+    HttpURLConnection connection = client.open(server.getUrl("/"));
     assertEquals("B", readAscii(connection));
-
-    String source = connection.getHeaderField(OkHeaders.RESPONSE_SOURCE);
-    assertEquals(ResponseSource.CONDITIONAL_CACHE + " 200", source);
   }
 
   @Test public void responseSourceHeaderConditionalCacheNotFetched() throws IOException {
@@ -1752,25 +1685,17 @@ public void assertCookies(URL url, String... expectedCookies) throws Exception {
         .addHeader("Cache-Control: max-age=0")
         .addHeader("Date: " + formatDate(0, TimeUnit.MINUTES)));
     server.enqueue(new MockResponse().setResponseCode(304));
-    server.play();
 
-    assertEquals("A", readAscii(openConnection(server.getUrl("/"))));
-    HttpURLConnection connection = openConnection(server.getUrl("/"));
+    assertEquals("A", readAscii(client.open(server.getUrl("/"))));
+    HttpURLConnection connection = client.open(server.getUrl("/"));
     assertEquals("A", readAscii(connection));
-
-    String source = connection.getHeaderField(OkHeaders.RESPONSE_SOURCE);
-    assertEquals(ResponseSource.CONDITIONAL_CACHE + " 304", source);
   }
 
   @Test public void responseSourceHeaderFetched() throws IOException {
     server.enqueue(new MockResponse().setBody("A"));
-    server.play();
 
-    URLConnection connection = openConnection(server.getUrl("/"));
+    URLConnection connection = client.open(server.getUrl("/"));
     assertEquals("A", readAscii(connection));
-
-    String source = connection.getHeaderField(OkHeaders.RESPONSE_SOURCE);
-    assertEquals(ResponseSource.NETWORK + " 200", source);
   }
 
   @Test public void emptyResponseHeaderNameFromCacheIsLenient() throws Exception {
@@ -1778,7 +1703,7 @@ public void assertCookies(URL url, String... expectedCookies) throws Exception {
         .addHeader("Cache-Control: max-age=120")
         .addHeader(": A")
         .setBody("body"));
-    server.play();
+
     HttpURLConnection connection = client.open(server.getUrl("/"));
     assertEquals("A", connection.getHeaderField(""));
   }
@@ -1796,7 +1721,6 @@ public void assertCookies(URL url, String... expectedCookies) throws Exception {
     server.enqueue(new MockResponse()
         .clearHeaders()
         .setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
-    server.play();
 
     URL url = server.getUrl("/");
     String urlKey = Util.hash(url.toString());
@@ -1835,8 +1759,8 @@ public void assertCookies(URL url, String... expectedCookies) throws Exception {
     writeFile(cache.getDirectory(), urlKey + ".0", entryMetadata);
     writeFile(cache.getDirectory(), urlKey + ".1", entryBody);
     writeFile(cache.getDirectory(), "journal", journalBody);
-    cache = new HttpResponseCache(cache.getDirectory(), Integer.MAX_VALUE);
-    client.setOkResponseCache(cache);
+    cache = new Cache(cache.getDirectory(), Integer.MAX_VALUE);
+    client.client().setCache(cache);
 
     HttpURLConnection connection = client.open(url);
     assertEquals(entryBody, readAscii(connection));
@@ -1845,9 +1769,9 @@ public void assertCookies(URL url, String... expectedCookies) throws Exception {
   }
 
   private void writeFile(File directory, String file, String content) throws IOException {
-    OutputStream out = new FileOutputStream(new File(directory, file));
-    out.write(content.getBytes(Util.UTF_8));
-    out.close();
+    BufferedSink sink = Okio.buffer(Okio.sink(new File(directory, file)));
+    sink.writeUtf8(content);
+    sink.close();
   }
 
   /**
@@ -1878,11 +1802,10 @@ private void addRequestBodyIfNecessary(String requestMethod, HttpURLConnection i
   private void assertNotCached(MockResponse response) throws Exception {
     server.enqueue(response.setBody("A"));
     server.enqueue(new MockResponse().setBody("B"));
-    server.play();
 
     URL url = server.getUrl("/");
-    assertEquals("A", readAscii(openConnection(url)));
-    assertEquals("B", readAscii(openConnection(url)));
+    assertEquals("A", readAscii(client.open(url)));
+    assertEquals("B", readAscii(client.open(url)));
   }
 
   /** @return the request with the conditional get headers. */
@@ -1895,24 +1818,22 @@ private RecordedRequest assertConditionallyCached(MockResponse response) throws
     server.enqueue(response.setBody("B").setStatus("HTTP/1.1 200 B-OK"));
     server.enqueue(new MockResponse().setStatus("HTTP/1.1 200 C-OK").setBody("C"));
 
-    server.play();
-
     URL valid = server.getUrl("/valid");
-    HttpURLConnection connection1 = openConnection(valid);
+    HttpURLConnection connection1 = client.open(valid);
     assertEquals("A", readAscii(connection1));
     assertEquals(HttpURLConnection.HTTP_OK, connection1.getResponseCode());
     assertEquals("A-OK", connection1.getResponseMessage());
-    HttpURLConnection connection2 = openConnection(valid);
+    HttpURLConnection connection2 = client.open(valid);
     assertEquals("A", readAscii(connection2));
     assertEquals(HttpURLConnection.HTTP_OK, connection2.getResponseCode());
     assertEquals("A-OK", connection2.getResponseMessage());
 
     URL invalid = server.getUrl("/invalid");
-    HttpURLConnection connection3 = openConnection(invalid);
+    HttpURLConnection connection3 = client.open(invalid);
     assertEquals("B", readAscii(connection3));
     assertEquals(HttpURLConnection.HTTP_OK, connection3.getResponseCode());
     assertEquals("B-OK", connection3.getResponseMessage());
-    HttpURLConnection connection4 = openConnection(invalid);
+    HttpURLConnection connection4 = client.open(invalid);
     assertEquals("C", readAscii(connection4));
     assertEquals(HttpURLConnection.HTTP_OK, connection4.getResponseCode());
     assertEquals("C-OK", connection4.getResponseMessage());
@@ -1924,11 +1845,10 @@ private RecordedRequest assertConditionallyCached(MockResponse response) throws
   private void assertFullyCached(MockResponse response) throws Exception {
     server.enqueue(response.setBody("A"));
     server.enqueue(response.setBody("B"));
-    server.play();
 
     URL url = server.getUrl("/");
-    assertEquals("A", readAscii(openConnection(url)));
-    assertEquals("A", readAscii(openConnection(url)));
+    assertEquals("A", readAscii(client.open(url)));
+    assertEquals("A", readAscii(client.open(url)));
   }
 
   /**
@@ -1938,8 +1858,10 @@ private void assertFullyCached(MockResponse response) throws Exception {
    */
   private MockResponse truncateViolently(MockResponse response, int numBytesToKeep) {
     response.setSocketPolicy(DISCONNECT_AT_END);
-    List<String> headers = new ArrayList<String>(response.getHeaders());
-    response.setBody(Arrays.copyOfRange(response.getBody(), 0, numBytesToKeep));
+    List<String> headers = new ArrayList<>(response.getHeaders());
+    Buffer truncatedBody = new Buffer();
+    truncatedBody.write(response.getBody(), numBytesToKeep);
+    response.setBody(truncatedBody);
     response.getHeaders().clear();
     response.getHeaders().addAll(headers);
     return response;
@@ -1985,24 +1907,22 @@ private void assertGatewayTimeout(HttpURLConnection connection) throws IOExcepti
     }
     assertEquals(504, connection.getResponseCode());
     assertEquals(-1, connection.getErrorStream().read());
-    assertEquals(ResponseSource.NONE + " 504",
-        connection.getHeaderField(OkHeaders.RESPONSE_SOURCE));
   }
 
   enum TransferKind {
     CHUNKED() {
-      @Override void setBody(MockResponse response, byte[] content, int chunkSize)
+      @Override void setBody(MockResponse response, Buffer content, int chunkSize)
           throws IOException {
         response.setChunkedBody(content, chunkSize);
       }
     },
     FIXED_LENGTH() {
-      @Override void setBody(MockResponse response, byte[] content, int chunkSize) {
+      @Override void setBody(MockResponse response, Buffer content, int chunkSize) {
         response.setBody(content);
       }
     },
     END_OF_STREAM() {
-      @Override void setBody(MockResponse response, byte[] content, int chunkSize) {
+      @Override void setBody(MockResponse response, Buffer content, int chunkSize) {
         response.setBody(content);
         response.setSocketPolicy(DISCONNECT_AT_END);
         for (Iterator<String> h = response.getHeaders().iterator(); h.hasNext(); ) {
@@ -2014,10 +1934,10 @@ private void assertGatewayTimeout(HttpURLConnection connection) throws IOExcepti
       }
     };
 
-    abstract void setBody(MockResponse response, byte[] content, int chunkSize) throws IOException;
+    abstract void setBody(MockResponse response, Buffer content, int chunkSize) throws IOException;
 
     void setBody(MockResponse response, String content, int chunkSize) throws IOException {
-      setBody(response, content.getBytes("UTF-8"), chunkSize);
+      setBody(response, new Buffer().writeUtf8(content), chunkSize);
     }
   }
 
@@ -2026,34 +1946,11 @@ void setBody(MockResponse response, String content, int chunkSize) throws IOExce
   }
 
   /** Returns a gzipped copy of {@code bytes}. */
-  public byte[] gzip(byte[] bytes) throws IOException {
-    ByteArrayOutputStream bytesOut = new ByteArrayOutputStream();
-    OutputStream gzippedOut = new GZIPOutputStream(bytesOut);
-    gzippedOut.write(bytes);
-    gzippedOut.close();
-    return bytesOut.toByteArray();
-  }
-
-  static abstract class AbstractOkResponseCache implements OkResponseCache {
-    @Override public Response get(Request request) throws IOException {
-      return null;
-    }
-
-    @Override public CacheRequest put(Response response) throws IOException {
-      return null;
-    }
-
-    @Override public boolean maybeRemove(Request request) throws IOException {
-      return false;
-    }
-
-    @Override public void update(Response cached, Response network) throws IOException {
-    }
-
-    @Override public void trackConditionalCacheHit() {
-    }
-
-    @Override public void trackResponse(ResponseSource source) {
-    }
+  public Buffer gzip(String data) throws IOException {
+    Buffer result = new Buffer();
+    BufferedSink sink = Okio.buffer(new GzipSink(result));
+    sink.writeUtf8(data);
+    sink.close();
+    return result;
   }
 }
diff --git a/okhttp-tests/src/test/java/com/squareup/okhttp/CallTest.java b/okhttp-tests/src/test/java/com/squareup/okhttp/CallTest.java
new file mode 100644
index 0000000000..e53e315c04
--- /dev/null
+++ b/okhttp-tests/src/test/java/com/squareup/okhttp/CallTest.java
@@ -0,0 +1,1426 @@
+/*
+ * Copyright (C) 2013 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.okhttp;
+
+import com.squareup.okhttp.internal.RecordingHostnameVerifier;
+import com.squareup.okhttp.internal.RecordingOkAuthenticator;
+import com.squareup.okhttp.internal.SslContextBuilder;
+import com.squareup.okhttp.mockwebserver.Dispatcher;
+import com.squareup.okhttp.mockwebserver.MockResponse;
+import com.squareup.okhttp.mockwebserver.MockWebServer;
+import com.squareup.okhttp.mockwebserver.RecordedRequest;
+import com.squareup.okhttp.mockwebserver.SocketPolicy;
+import java.io.File;
+import java.io.IOException;
+import java.io.InputStream;
+import java.net.CookieManager;
+import java.net.HttpCookie;
+import java.net.HttpURLConnection;
+import java.net.URL;
+import java.util.Arrays;
+import java.util.Collection;
+import java.util.List;
+import java.util.UUID;
+import java.util.concurrent.BlockingQueue;
+import java.util.concurrent.Callable;
+import java.util.concurrent.CountDownLatch;
+import java.util.concurrent.ExecutorService;
+import java.util.concurrent.Executors;
+import java.util.concurrent.Future;
+import java.util.concurrent.SynchronousQueue;
+import java.util.concurrent.TimeUnit;
+import java.util.concurrent.atomic.AtomicBoolean;
+import java.util.concurrent.atomic.AtomicReference;
+import javax.net.ssl.SSLContext;
+import okio.Buffer;
+import okio.BufferedSink;
+import okio.BufferedSource;
+import okio.GzipSink;
+import okio.Okio;
+import org.junit.After;
+import org.junit.Before;
+import org.junit.Ignore;
+import org.junit.Test;
+
+import static java.lang.Thread.UncaughtExceptionHandler;
+import static java.net.CookiePolicy.ACCEPT_ORIGINAL_SERVER;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertNull;
+import static org.junit.Assert.assertTrue;
+import static org.junit.Assert.fail;
+
+public final class CallTest {
+  private MockWebServer server = new MockWebServer();
+  private MockWebServer server2 = new MockWebServer();
+  private OkHttpClient client = new OkHttpClient();
+  private RecordingCallback callback = new RecordingCallback();
+  private UncaughtExceptionHandler defaultUncaughtExceptionHandler;
+
+  private static final SSLContext sslContext = SslContextBuilder.localhost();
+  private Cache cache;
+
+  @Before public void setUp() throws Exception {
+    String tmp = System.getProperty("java.io.tmpdir");
+    File cacheDir = new File(tmp, "HttpCache-" + UUID.randomUUID());
+    cache = new Cache(cacheDir, Integer.MAX_VALUE);
+    defaultUncaughtExceptionHandler = Thread.getDefaultUncaughtExceptionHandler();
+  }
+
+  @After public void tearDown() throws Exception {
+    server.shutdown();
+    server2.shutdown();
+    cache.delete();
+    Thread.setDefaultUncaughtExceptionHandler(defaultUncaughtExceptionHandler);
+  }
+
+  @Test public void get() throws Exception {
+    server.enqueue(new MockResponse().setBody("abc").addHeader("Content-Type: text/plain"));
+    server.play();
+
+    Request request = new Request.Builder()
+        .url(server.getUrl("/"))
+        .header("User-Agent", "SyncApiTest")
+        .build();
+
+    executeSynchronously(request)
+        .assertCode(200)
+        .assertSuccessful()
+        .assertHeader("Content-Type", "text/plain")
+        .assertBody("abc");
+
+    RecordedRequest recordedRequest = server.takeRequest();
+    assertEquals("GET", recordedRequest.getMethod());
+    assertEquals("SyncApiTest", recordedRequest.getHeader("User-Agent"));
+    assertEquals(0, recordedRequest.getBody().length);
+    assertNull(recordedRequest.getHeader("Content-Length"));
+  }
+
+  @Test public void lazilyEvaluateRequestUrl() throws Exception {
+    server.enqueue(new MockResponse().setBody("abc"));
+    server.play();
+
+    Request request1 = new Request.Builder()
+        .url("foo://bar?baz")
+        .build();
+    Request request2 = request1.newBuilder()
+        .url(server.getUrl("/"))
+        .build();
+    executeSynchronously(request2)
+        .assertCode(200)
+        .assertSuccessful()
+        .assertBody("abc");
+  }
+
+  @Ignore // TODO(jwilson): fix.
+  @Test public void invalidScheme() throws Exception {
+    try {
+      Request request = new Request.Builder()
+          .url("ftp://hostname/path")
+          .build();
+      executeSynchronously(request);
+      fail();
+    } catch (IllegalArgumentException expected) {
+    }
+  }
+
+  @Test public void getReturns500() throws Exception {
+    server.enqueue(new MockResponse().setResponseCode(500));
+    server.play();
+
+    Request request = new Request.Builder()
+        .url(server.getUrl("/"))
+        .build();
+
+    executeSynchronously(request)
+        .assertCode(500)
+        .assertNotSuccessful();
+  }
+
+  @Test public void get_SPDY_3() throws Exception {
+    enableProtocol(Protocol.SPDY_3);
+    get();
+  }
+
+  @Test public void get_HTTP_2() throws Exception {
+    enableProtocol(Protocol.HTTP_2);
+    get();
+  }
+
+  @Test public void getWithRequestBody() throws Exception {
+    server.enqueue(new MockResponse());
+    server.play();
+
+    try {
+      new Request.Builder().method("GET", RequestBody.create(MediaType.parse("text/plain"), "abc"));
+      fail();
+    } catch (IllegalArgumentException expected) {
+    }
+  }
+
+  @Test public void head() throws Exception {
+    server.enqueue(new MockResponse().addHeader("Content-Type: text/plain"));
+    server.play();
+
+    Request request = new Request.Builder()
+        .url(server.getUrl("/"))
+        .head()
+        .header("User-Agent", "SyncApiTest")
+        .build();
+
+    executeSynchronously(request)
+        .assertCode(200)
+        .assertHeader("Content-Type", "text/plain");
+
+    RecordedRequest recordedRequest = server.takeRequest();
+    assertEquals("HEAD", recordedRequest.getMethod());
+    assertEquals("SyncApiTest", recordedRequest.getHeader("User-Agent"));
+    assertEquals(0, recordedRequest.getBody().length);
+    assertNull(recordedRequest.getHeader("Content-Length"));
+  }
+
+  @Test public void head_SPDY_3() throws Exception {
+    enableProtocol(Protocol.SPDY_3);
+    head();
+  }
+
+  @Test public void head_HTTP_2() throws Exception {
+    enableProtocol(Protocol.HTTP_2);
+    head();
+  }
+
+  @Test public void post() throws Exception {
+    server.enqueue(new MockResponse().setBody("abc"));
+    server.play();
+
+    Request request = new Request.Builder()
+        .url(server.getUrl("/"))
+        .post(RequestBody.create(MediaType.parse("text/plain"), "def"))
+        .build();
+
+    executeSynchronously(request)
+        .assertCode(200)
+        .assertBody("abc");
+
+    RecordedRequest recordedRequest = server.takeRequest();
+    assertEquals("POST", recordedRequest.getMethod());
+    assertEquals("def", recordedRequest.getUtf8Body());
+    assertEquals("3", recordedRequest.getHeader("Content-Length"));
+    assertEquals("text/plain; charset=utf-8", recordedRequest.getHeader("Content-Type"));
+  }
+
+  @Test public void post_SPDY_3() throws Exception {
+    enableProtocol(Protocol.SPDY_3);
+    post();
+  }
+
+  @Test public void post_HTTP_2() throws Exception {
+    enableProtocol(Protocol.HTTP_2);
+    post();
+  }
+
+  @Test public void postZeroLength() throws Exception {
+    server.enqueue(new MockResponse().setBody("abc"));
+    server.play();
+
+    Request request = new Request.Builder()
+        .url(server.getUrl("/"))
+        .method("POST", null)
+        .build();
+
+    executeSynchronously(request)
+        .assertCode(200)
+        .assertBody("abc");
+
+    RecordedRequest recordedRequest = server.takeRequest();
+    assertEquals("POST", recordedRequest.getMethod());
+    assertEquals(0, recordedRequest.getBody().length);
+    assertEquals("0", recordedRequest.getHeader("Content-Length"));
+    assertEquals(null, recordedRequest.getHeader("Content-Type"));
+  }
+
+  @Test public void postZeroLength_SPDY_3() throws Exception {
+    enableProtocol(Protocol.SPDY_3);
+    postZeroLength();
+  }
+
+  @Test public void postZerolength_HTTP_2() throws Exception {
+    enableProtocol(Protocol.HTTP_2);
+    postZeroLength();
+  }
+
+  @Test public void delete() throws Exception {
+    server.enqueue(new MockResponse().setBody("abc"));
+    server.play();
+
+    Request request = new Request.Builder()
+        .url(server.getUrl("/"))
+        .delete()
+        .build();
+
+    executeSynchronously(request)
+        .assertCode(200)
+        .assertBody("abc");
+
+    RecordedRequest recordedRequest = server.takeRequest();
+    assertEquals("DELETE", recordedRequest.getMethod());
+    assertEquals(0, recordedRequest.getBody().length);
+    assertEquals("0", recordedRequest.getHeader("Content-Length"));
+    assertEquals(null, recordedRequest.getHeader("Content-Type"));
+  }
+
+  @Test public void delete_SPDY_3() throws Exception {
+    enableProtocol(Protocol.SPDY_3);
+    delete();
+  }
+
+  @Test public void delete_HTTP_2() throws Exception {
+    enableProtocol(Protocol.HTTP_2);
+    delete();
+  }
+
+  @Test public void put() throws Exception {
+    server.enqueue(new MockResponse().setBody("abc"));
+    server.play();
+
+    Request request = new Request.Builder()
+        .url(server.getUrl("/"))
+        .put(RequestBody.create(MediaType.parse("text/plain"), "def"))
+        .build();
+
+    executeSynchronously(request)
+        .assertCode(200)
+        .assertBody("abc");
+
+    RecordedRequest recordedRequest = server.takeRequest();
+    assertEquals("PUT", recordedRequest.getMethod());
+    assertEquals("def", recordedRequest.getUtf8Body());
+    assertEquals("3", recordedRequest.getHeader("Content-Length"));
+    assertEquals("text/plain; charset=utf-8", recordedRequest.getHeader("Content-Type"));
+  }
+
+  @Test public void put_SPDY_3() throws Exception {
+    enableProtocol(Protocol.SPDY_3);
+    put();
+  }
+
+  @Test public void put_HTTP_2() throws Exception {
+    enableProtocol(Protocol.HTTP_2);
+    put();
+  }
+
+  @Test public void patch() throws Exception {
+    server.enqueue(new MockResponse().setBody("abc"));
+    server.play();
+
+    Request request = new Request.Builder()
+        .url(server.getUrl("/"))
+        .patch(RequestBody.create(MediaType.parse("text/plain"), "def"))
+        .build();
+
+    executeSynchronously(request)
+        .assertCode(200)
+        .assertBody("abc");
+
+    RecordedRequest recordedRequest = server.takeRequest();
+    assertEquals("PATCH", recordedRequest.getMethod());
+    assertEquals("def", recordedRequest.getUtf8Body());
+    assertEquals("3", recordedRequest.getHeader("Content-Length"));
+    assertEquals("text/plain; charset=utf-8", recordedRequest.getHeader("Content-Type"));
+  }
+
+  @Test public void patch_SPDY_3() throws Exception {
+    enableProtocol(Protocol.SPDY_3);
+    patch();
+  }
+
+  @Test public void patch_HTTP_2() throws Exception {
+    enableProtocol(Protocol.HTTP_2);
+    patch();
+  }
+
+  @Test public void unspecifiedRequestBodyContentTypeDoesNotGetDefault() throws Exception {
+    server.enqueue(new MockResponse());
+    server.play();
+
+    Request request = new Request.Builder()
+        .url(server.getUrl("/"))
+        .method("POST", RequestBody.create(null, "abc"))
+        .build();
+
+    executeSynchronously(request).assertCode(200);
+
+    RecordedRequest recordedRequest = server.takeRequest();
+    assertEquals(null, recordedRequest.getHeader("Content-Type"));
+    assertEquals("3", recordedRequest.getHeader("Content-Length"));
+    assertEquals("abc", recordedRequest.getUtf8Body());
+  }
+
+  @Test public void illegalToExecuteTwice() throws Exception {
+    server.enqueue(new MockResponse()
+        .setBody("abc")
+        .addHeader("Content-Type: text/plain"));
+    server.play();
+
+    Request request = new Request.Builder()
+        .url(server.getUrl("/"))
+        .header("User-Agent", "SyncApiTest")
+        .build();
+
+    Call call = client.newCall(request);
+    call.execute();
+
+    try {
+      call.execute();
+      fail();
+    } catch (IllegalStateException e){
+      assertEquals("Already Executed", e.getMessage());
+    }
+
+    try {
+      call.enqueue(callback);
+      fail();
+    } catch (IllegalStateException e){
+      assertEquals("Already Executed", e.getMessage());
+    }
+
+    assertTrue(server.takeRequest().getHeaders().contains("User-Agent: SyncApiTest"));
+  }
+
+  @Test public void illegalToExecuteTwice_Async() throws Exception {
+    server.enqueue(new MockResponse()
+        .setBody("abc")
+        .addHeader("Content-Type: text/plain"));
+    server.play();
+
+    Request request = new Request.Builder()
+        .url(server.getUrl("/"))
+        .header("User-Agent", "SyncApiTest")
+        .build();
+
+    Call call = client.newCall(request);
+    call.enqueue(callback);
+
+    try {
+      call.execute();
+      fail();
+    } catch (IllegalStateException e){
+      assertEquals("Already Executed", e.getMessage());
+    }
+
+    try {
+      call.enqueue(callback);
+      fail();
+    } catch (IllegalStateException e){
+      assertEquals("Already Executed", e.getMessage());
+    }
+
+    assertTrue(server.takeRequest().getHeaders().contains("User-Agent: SyncApiTest"));
+  }
+
+  @Test public void get_Async() throws Exception {
+    server.enqueue(new MockResponse()
+        .setBody("abc")
+        .addHeader("Content-Type: text/plain"));
+    server.play();
+
+    Request request = new Request.Builder()
+        .url(server.getUrl("/"))
+        .header("User-Agent", "AsyncApiTest")
+        .build();
+    client.newCall(request).enqueue(callback);
+
+    callback.await(request.url())
+        .assertCode(200)
+        .assertHeader("Content-Type", "text/plain")
+        .assertBody("abc");
+
+    assertTrue(server.takeRequest().getHeaders().contains("User-Agent: AsyncApiTest"));
+  }
+
+  @Test public void onResponseThrowsIsHandledByUncaughtExceptionHandler() throws Exception {
+    server.enqueue(new MockResponse());
+    server.play();
+
+    Request request = new Request.Builder()
+        .url(server.getUrl("/"))
+        .build();
+
+    final AtomicReference<Throwable> uncaughtExceptionRef = new AtomicReference<>();
+    final CountDownLatch latch = new CountDownLatch(1);
+
+    Thread.setDefaultUncaughtExceptionHandler(new UncaughtExceptionHandler() {
+      @Override public void uncaughtException(Thread thread, Throwable throwable) {
+        uncaughtExceptionRef.set(throwable);
+        latch.countDown();
+      }
+    });
+
+    client.newCall(request).enqueue(new Callback() {
+      @Override public void onFailure(Request request, IOException e) {
+        fail();
+      }
+
+      @Override public void onResponse(Response response) throws IOException {
+        throw new IOException("a");
+      }
+    });
+
+    latch.await();
+    Throwable uncaughtException = uncaughtExceptionRef.get();
+    assertEquals(RuntimeException.class, uncaughtException.getClass());
+    assertEquals(IOException.class, uncaughtException.getCause().getClass());
+    assertEquals("a", uncaughtException.getCause().getMessage());
+  }
+
+  @Test public void connectionPooling() throws Exception {
+    server.enqueue(new MockResponse().setBody("abc"));
+    server.enqueue(new MockResponse().setBody("def"));
+    server.enqueue(new MockResponse().setBody("ghi"));
+    server.play();
+
+    executeSynchronously(new Request.Builder().url(server.getUrl("/a")).build())
+        .assertBody("abc");
+
+    executeSynchronously(new Request.Builder().url(server.getUrl("/b")).build())
+        .assertBody("def");
+
+    executeSynchronously(new Request.Builder().url(server.getUrl("/c")).build())
+        .assertBody("ghi");
+
+    assertEquals(0, server.takeRequest().getSequenceNumber());
+    assertEquals(1, server.takeRequest().getSequenceNumber());
+    assertEquals(2, server.takeRequest().getSequenceNumber());
+  }
+
+  @Test public void connectionPooling_Async() throws Exception {
+    server.enqueue(new MockResponse().setBody("abc"));
+    server.enqueue(new MockResponse().setBody("def"));
+    server.enqueue(new MockResponse().setBody("ghi"));
+    server.play();
+
+    client.newCall(new Request.Builder().url(server.getUrl("/a")).build()).enqueue(callback);
+    callback.await(server.getUrl("/a")).assertBody("abc");
+
+    client.newCall(new Request.Builder().url(server.getUrl("/b")).build()).enqueue(callback);
+    callback.await(server.getUrl("/b")).assertBody("def");
+
+    client.newCall(new Request.Builder().url(server.getUrl("/c")).build()).enqueue(callback);
+    callback.await(server.getUrl("/c")).assertBody("ghi");
+
+    assertEquals(0, server.takeRequest().getSequenceNumber());
+    assertEquals(1, server.takeRequest().getSequenceNumber());
+    assertEquals(2, server.takeRequest().getSequenceNumber());
+  }
+
+  @Test public void connectionReuseWhenResponseBodyConsumed_Async() throws Exception {
+    server.enqueue(new MockResponse().setBody("abc"));
+    server.enqueue(new MockResponse().setBody("def"));
+    server.play();
+
+    Request request = new Request.Builder().url(server.getUrl("/a")).build();
+    client.newCall(request).enqueue(new Callback() {
+      @Override public void onFailure(Request request, IOException e) {
+        throw new AssertionError();
+      }
+
+      @Override public void onResponse(Response response) throws IOException {
+        InputStream bytes = response.body().byteStream();
+        assertEquals('a', bytes.read());
+        assertEquals('b', bytes.read());
+        assertEquals('c', bytes.read());
+
+        // This request will share a connection with 'A' cause it's all done.
+        client.newCall(new Request.Builder().url(server.getUrl("/b")).build()).enqueue(callback);
+      }
+    });
+
+    callback.await(server.getUrl("/b")).assertCode(200).assertBody("def");
+    assertEquals(0, server.takeRequest().getSequenceNumber()); // New connection.
+    assertEquals(1, server.takeRequest().getSequenceNumber()); // Connection reuse!
+  }
+
+  @Test public void timeoutsUpdatedOnReusedConnections() throws Exception {
+    server.enqueue(new MockResponse().setBody("abc"));
+    server.enqueue(new MockResponse().setBody("def").throttleBody(1, 750, TimeUnit.MILLISECONDS));
+    server.play();
+
+    // First request: time out after 1000ms.
+    client.setReadTimeout(1000, TimeUnit.MILLISECONDS);
+    executeSynchronously(new Request.Builder().url(server.getUrl("/a")).build()).assertBody("abc");
+
+    // Second request: time out after 250ms.
+    client.setReadTimeout(250, TimeUnit.MILLISECONDS);
+    Request request = new Request.Builder().url(server.getUrl("/b")).build();
+    Response response = client.newCall(request).execute();
+    BufferedSource bodySource = response.body().source();
+    assertEquals('d', bodySource.readByte());
+
+    // The second byte of this request will be delayed by 750ms so we should time out after 250ms.
+    long startNanos = System.nanoTime();
+    try {
+      bodySource.readByte();
+      fail();
+    } catch (IOException expected) {
+      // Timed out as expected.
+      long elapsedNanos = System.nanoTime() - startNanos;
+      long elapsedMillis = TimeUnit.NANOSECONDS.toMillis(elapsedNanos);
+      assertTrue(String.format("Timed out: %sms", elapsedMillis), elapsedMillis < 500);
+    }
+  }
+
+  @Test public void tls() throws Exception {
+    server.useHttps(sslContext.getSocketFactory(), false);
+    server.enqueue(new MockResponse()
+        .setBody("abc")
+        .addHeader("Content-Type: text/plain"));
+    server.play();
+
+    client.setSslSocketFactory(sslContext.getSocketFactory());
+    client.setHostnameVerifier(new RecordingHostnameVerifier());
+
+    executeSynchronously(new Request.Builder().url(server.getUrl("/")).build())
+        .assertHandshake();
+  }
+
+  @Test public void tls_Async() throws Exception {
+    server.useHttps(sslContext.getSocketFactory(), false);
+    server.enqueue(new MockResponse()
+        .setBody("abc")
+        .addHeader("Content-Type: text/plain"));
+    server.play();
+
+    client.setSslSocketFactory(sslContext.getSocketFactory());
+    client.setHostnameVerifier(new RecordingHostnameVerifier());
+
+    Request request = new Request.Builder()
+        .url(server.getUrl("/"))
+        .build();
+    client.newCall(request).enqueue(callback);
+
+    callback.await(request.url()).assertHandshake();
+  }
+
+  @Test public void recoverFromTlsHandshakeFailure() throws Exception {
+    server.useHttps(sslContext.getSocketFactory(), false);
+    server.enqueue(new MockResponse().setSocketPolicy(SocketPolicy.FAIL_HANDSHAKE));
+    server.enqueue(new MockResponse().setBody("abc"));
+    server.play();
+
+    client.setSslSocketFactory(sslContext.getSocketFactory());
+    client.setHostnameVerifier(new RecordingHostnameVerifier());
+
+    executeSynchronously(new Request.Builder().url(server.getUrl("/")).build())
+        .assertBody("abc");
+  }
+
+  @Test public void recoverFromTlsHandshakeFailure_Async() throws Exception {
+    server.useHttps(sslContext.getSocketFactory(), false);
+    server.enqueue(new MockResponse().setSocketPolicy(SocketPolicy.FAIL_HANDSHAKE));
+    server.enqueue(new MockResponse().setBody("abc"));
+    server.play();
+
+    client.setSslSocketFactory(sslContext.getSocketFactory());
+    client.setHostnameVerifier(new RecordingHostnameVerifier());
+
+    Request request = new Request.Builder()
+        .url(server.getUrl("/"))
+        .build();
+    client.newCall(request).enqueue(callback);
+
+    callback.await(request.url()).assertBody("abc");
+  }
+
+  @Test public void setFollowSslRedirectsFalse() throws Exception {
+    server.useHttps(sslContext.getSocketFactory(), false);
+    server.enqueue(new MockResponse()
+        .setResponseCode(301)
+        .addHeader("Location: http://square.com"));
+    server.play();
+
+    client.setFollowSslRedirects(false);
+    client.setSslSocketFactory(sslContext.getSocketFactory());
+    client.setHostnameVerifier(new RecordingHostnameVerifier());
+
+    Request request = new Request.Builder().url(server.getUrl("/")).build();
+    Response response = client.newCall(request).execute();
+    assertEquals(301, response.code());
+  }
+
+  @Test public void post_Async() throws Exception {
+    server.enqueue(new MockResponse().setBody("abc"));
+    server.play();
+
+    Request request = new Request.Builder()
+        .url(server.getUrl("/"))
+        .post(RequestBody.create(MediaType.parse("text/plain"), "def"))
+        .build();
+    client.newCall(request).enqueue(callback);
+
+    callback.await(request.url())
+        .assertCode(200)
+        .assertBody("abc");
+
+    RecordedRequest recordedRequest = server.takeRequest();
+    assertEquals("def", recordedRequest.getUtf8Body());
+    assertEquals("3", recordedRequest.getHeader("Content-Length"));
+    assertEquals("text/plain; charset=utf-8", recordedRequest.getHeader("Content-Type"));
+  }
+
+  @Test public void postBodyRetransmittedOnFailureRecovery() throws Exception {
+    server.enqueue(new MockResponse().setBody("abc"));
+    server.enqueue(new MockResponse().setSocketPolicy(SocketPolicy.DISCONNECT_AFTER_REQUEST));
+    server.enqueue(new MockResponse().setBody("def"));
+    server.play();
+
+    // Seed the connection pool so we have something that can fail.
+    Request request1 = new Request.Builder().url(server.getUrl("/")).build();
+    Response response1 = client.newCall(request1).execute();
+    assertEquals("abc", response1.body().string());
+
+    Request request2 = new Request.Builder()
+        .url(server.getUrl("/"))
+        .post(RequestBody.create(MediaType.parse("text/plain"), "body!"))
+        .build();
+    Response response2 = client.newCall(request2).execute();
+    assertEquals("def", response2.body().string());
+
+    RecordedRequest get = server.takeRequest();
+    assertEquals(0, get.getSequenceNumber());
+
+    RecordedRequest post1 = server.takeRequest();
+    assertEquals("body!", post1.getUtf8Body());
+    assertEquals(1, post1.getSequenceNumber());
+
+    RecordedRequest post2 = server.takeRequest();
+    assertEquals("body!", post2.getUtf8Body());
+    assertEquals(0, post2.getSequenceNumber());
+  }
+
+  @Test public void cacheHit() throws Exception {
+    server.enqueue(new MockResponse()
+        .addHeader("ETag: v1")
+        .addHeader("Cache-Control: max-age=60")
+        .addHeader("Vary: Accept-Charset")
+        .setBody("A"));
+    server.play();
+
+    client.setCache(cache);
+
+    // Store a response in the cache.
+    URL url = server.getUrl("/");
+    Request cacheStoreRequest = new Request.Builder()
+        .url(url)
+        .addHeader("Accept-Language", "fr-CA")
+        .addHeader("Accept-Charset", "UTF-8")
+        .build();
+    executeSynchronously(cacheStoreRequest)
+        .assertCode(200)
+        .assertBody("A");
+    assertNull(server.takeRequest().getHeader("If-None-Match"));
+
+    // Hit that stored response.
+    Request cacheHitRequest = new Request.Builder()
+        .url(url)
+        .addHeader("Accept-Language", "en-US") // Different, but Vary says it doesn't matter.
+        .addHeader("Accept-Charset", "UTF-8")
+        .build();
+    RecordedResponse cacheHit = executeSynchronously(cacheHitRequest);
+
+    // Check the merged response. The request is the application's original request.
+    cacheHit.assertCode(200)
+        .assertBody("A")
+        .assertHeader("ETag", "v1")
+        .assertRequestUrl(cacheStoreRequest.url())
+        .assertRequestHeader("Accept-Language", "en-US")
+        .assertRequestHeader("Accept-Charset", "UTF-8");
+
+    // Check the cached response. Its request contains only the saved Vary headers.
+    cacheHit.cacheResponse()
+        .assertCode(200)
+        .assertHeader("ETag", "v1")
+        .assertRequestMethod("GET")
+        .assertRequestUrl(cacheStoreRequest.url())
+        .assertRequestHeader("Accept-Language")
+        .assertRequestHeader("Accept-Charset", "UTF-8");
+
+    cacheHit.assertNoNetworkResponse();
+  }
+
+  @Test public void conditionalCacheHit() throws Exception {
+    server.enqueue(new MockResponse()
+        .addHeader("ETag: v1")
+        .addHeader("Vary: Accept-Charset")
+        .addHeader("Donut: a")
+        .setBody("A"));
+    server.enqueue(new MockResponse()
+        .clearHeaders()
+        .addHeader("Donut: b")
+        .setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
+    server.play();
+
+    client.setCache(cache);
+
+    // Store a response in the cache.
+    URL url = server.getUrl("/");
+    Request cacheStoreRequest = new Request.Builder()
+        .url(url)
+        .addHeader("Accept-Language", "fr-CA")
+        .addHeader("Accept-Charset", "UTF-8")
+        .build();
+    executeSynchronously(cacheStoreRequest)
+        .assertCode(200)
+        .assertHeader("Donut", "a")
+        .assertBody("A");
+    assertNull(server.takeRequest().getHeader("If-None-Match"));
+
+    // Hit that stored response.
+    Request cacheHitRequest = new Request.Builder()
+        .url(url)
+        .addHeader("Accept-Language", "en-US") // Different, but Vary says it doesn't matter.
+        .addHeader("Accept-Charset", "UTF-8")
+        .build();
+    RecordedResponse cacheHit = executeSynchronously(cacheHitRequest);
+    assertEquals("v1", server.takeRequest().getHeader("If-None-Match"));
+
+    // Check the merged response. The request is the application's original request.
+    cacheHit.assertCode(200)
+        .assertBody("A")
+        .assertHeader("Donut", "b")
+        .assertRequestUrl(cacheStoreRequest.url())
+        .assertRequestHeader("Accept-Language", "en-US")
+        .assertRequestHeader("Accept-Charset", "UTF-8")
+        .assertRequestHeader("If-None-Match"); // No If-None-Match on the user's request.
+
+    // Check the cached response. Its request contains only the saved Vary headers.
+    cacheHit.cacheResponse()
+        .assertCode(200)
+        .assertHeader("Donut", "a")
+        .assertHeader("ETag", "v1")
+        .assertRequestUrl(cacheStoreRequest.url())
+        .assertRequestHeader("Accept-Language") // No Vary on Accept-Language.
+        .assertRequestHeader("Accept-Charset", "UTF-8") // Because of Vary on Accept-Charset.
+        .assertRequestHeader("If-None-Match"); // This wasn't present in the original request.
+
+    // Check the network response. It has the caller's request, plus some caching headers.
+    cacheHit.networkResponse()
+        .assertCode(304)
+        .assertHeader("Donut", "b")
+        .assertRequestHeader("Accept-Language", "en-US")
+        .assertRequestHeader("Accept-Charset", "UTF-8")
+        .assertRequestHeader("If-None-Match", "v1"); // If-None-Match in the validation request.
+  }
+
+  @Test public void conditionalCacheHit_Async() throws Exception {
+    server.enqueue(new MockResponse().setBody("A").addHeader("ETag: v1"));
+    server.enqueue(new MockResponse()
+        .clearHeaders()
+        .setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
+    server.play();
+
+    client.setCache(cache);
+
+    Request request1 = new Request.Builder()
+        .url(server.getUrl("/"))
+        .build();
+    client.newCall(request1).enqueue(callback);
+    callback.await(request1.url()).assertCode(200).assertBody("A");
+    assertNull(server.takeRequest().getHeader("If-None-Match"));
+
+    Request request2 = new Request.Builder()
+        .url(server.getUrl("/"))
+        .build();
+    client.newCall(request2).enqueue(callback);
+    callback.await(request2.url()).assertCode(200).assertBody("A");
+    assertEquals("v1", server.takeRequest().getHeader("If-None-Match"));
+  }
+
+  @Test public void conditionalCacheMiss() throws Exception {
+    server.enqueue(new MockResponse()
+        .addHeader("ETag: v1")
+        .addHeader("Vary: Accept-Charset")
+        .addHeader("Donut: a")
+        .setBody("A"));
+    server.enqueue(new MockResponse()
+        .addHeader("Donut: b")
+        .setBody("B"));
+    server.play();
+
+    client.setCache(cache);
+
+    Request cacheStoreRequest = new Request.Builder()
+        .url(server.getUrl("/"))
+        .addHeader("Accept-Language", "fr-CA")
+        .addHeader("Accept-Charset", "UTF-8")
+        .build();
+    executeSynchronously(cacheStoreRequest)
+        .assertCode(200)
+        .assertBody("A");
+    assertNull(server.takeRequest().getHeader("If-None-Match"));
+
+    Request cacheMissRequest = new Request.Builder()
+        .url(server.getUrl("/"))
+        .addHeader("Accept-Language", "en-US") // Different, but Vary says it doesn't matter.
+        .addHeader("Accept-Charset", "UTF-8")
+        .build();
+    RecordedResponse cacheHit = executeSynchronously(cacheMissRequest);
+    assertEquals("v1", server.takeRequest().getHeader("If-None-Match"));
+
+    // Check the user response. It has the application's original request.
+    cacheHit.assertCode(200)
+        .assertBody("B")
+        .assertHeader("Donut", "b")
+        .assertRequestUrl(cacheStoreRequest.url());
+
+    // Check the cache response. Even though it's a miss, we used the cache.
+    cacheHit.cacheResponse()
+        .assertCode(200)
+        .assertHeader("Donut", "a")
+        .assertHeader("ETag", "v1")
+        .assertRequestUrl(cacheStoreRequest.url());
+
+    // Check the network response. It has the network request, plus caching headers.
+    cacheHit.networkResponse()
+        .assertCode(200)
+        .assertHeader("Donut", "b")
+        .assertRequestHeader("If-None-Match", "v1")  // If-None-Match in the validation request.
+        .assertRequestUrl(cacheStoreRequest.url());
+  }
+
+  @Test public void conditionalCacheMiss_Async() throws Exception {
+    server.enqueue(new MockResponse().setBody("A").addHeader("ETag: v1"));
+    server.enqueue(new MockResponse().setBody("B"));
+    server.play();
+
+    client.setCache(cache);
+
+    Request request1 = new Request.Builder()
+        .url(server.getUrl("/"))
+        .build();
+    client.newCall(request1).enqueue(callback);
+    callback.await(request1.url()).assertCode(200).assertBody("A");
+    assertNull(server.takeRequest().getHeader("If-None-Match"));
+
+    Request request2 = new Request.Builder()
+        .url(server.getUrl("/"))
+        .build();
+    client.newCall(request2).enqueue(callback);
+    callback.await(request2.url()).assertCode(200).assertBody("B");
+    assertEquals("v1", server.takeRequest().getHeader("If-None-Match"));
+  }
+
+  @Test public void onlyIfCachedReturns504WhenNotCached() throws Exception {
+    server.play();
+
+    Request request = new Request.Builder()
+        .url(server.getUrl("/"))
+        .header("Cache-Control", "only-if-cached")
+        .build();
+
+    executeSynchronously(request)
+        .assertCode(504)
+        .assertBody("")
+        .assertNoNetworkResponse()
+        .assertNoCacheResponse();
+  }
+
+  @Test public void redirect() throws Exception {
+    server.enqueue(new MockResponse()
+        .setResponseCode(301)
+        .addHeader("Location: /b")
+        .addHeader("Test", "Redirect from /a to /b")
+        .setBody("/a has moved!"));
+    server.enqueue(new MockResponse()
+        .setResponseCode(302)
+        .addHeader("Location: /c")
+        .addHeader("Test", "Redirect from /b to /c")
+        .setBody("/b has moved!"));
+    server.enqueue(new MockResponse().setBody("C"));
+    server.play();
+
+    executeSynchronously(new Request.Builder().url(server.getUrl("/a")).build())
+        .assertCode(200)
+        .assertBody("C")
+        .priorResponse()
+        .assertCode(302)
+        .assertHeader("Test", "Redirect from /b to /c")
+        .priorResponse()
+        .assertCode(301)
+        .assertHeader("Test", "Redirect from /a to /b");
+
+    assertEquals(0, server.takeRequest().getSequenceNumber()); // New connection.
+    assertEquals(1, server.takeRequest().getSequenceNumber()); // Connection reused.
+    assertEquals(2, server.takeRequest().getSequenceNumber()); // Connection reused again!
+  }
+
+  @Test public void postRedirectsToGet() throws Exception {
+    server.enqueue(new MockResponse()
+        .setResponseCode(HttpURLConnection.HTTP_MOVED_TEMP)
+        .addHeader("Location: /page2")
+        .setBody("This page has moved!"));
+    server.enqueue(new MockResponse().setBody("Page 2"));
+    server.play();
+
+    Response response = client.newCall(new Request.Builder()
+        .url(server.getUrl("/page1"))
+        .post(RequestBody.create(MediaType.parse("text/plain"), "Request Body"))
+        .build()).execute();
+    assertEquals("Page 2", response.body().string());
+
+    RecordedRequest page1 = server.takeRequest();
+    assertEquals("POST /page1 HTTP/1.1", page1.getRequestLine());
+    assertEquals("Request Body", page1.getUtf8Body());
+
+    RecordedRequest page2 = server.takeRequest();
+    assertEquals("GET /page2 HTTP/1.1", page2.getRequestLine());
+  }
+
+  @Test public void redirectsDoNotIncludeTooManyCookies() throws Exception {
+    server2.enqueue(new MockResponse().setBody("Page 2"));
+    server2.play();
+
+    server.enqueue(new MockResponse()
+        .setResponseCode(HttpURLConnection.HTTP_MOVED_TEMP)
+        .addHeader("Location: " + server2.getUrl("/")));
+    server.play();
+
+    CookieManager cookieManager = new CookieManager(null, ACCEPT_ORIGINAL_SERVER);
+    HttpCookie cookie = new HttpCookie("c", "cookie");
+    cookie.setDomain(server.getCookieDomain());
+    cookie.setPath("/");
+    String portList = Integer.toString(server.getPort());
+    cookie.setPortlist(portList);
+    cookieManager.getCookieStore().add(server.getUrl("/").toURI(), cookie);
+    client.setCookieHandler(cookieManager);
+
+    Response response = client.newCall(new Request.Builder()
+        .url(server.getUrl("/page1"))
+        .build()).execute();
+    assertEquals("Page 2", response.body().string());
+
+    RecordedRequest request1 = server.takeRequest();
+    assertContains(request1.getHeaders(), "Cookie: $Version=\"1\"; "
+        + "c=\"cookie\";$Path=\"/\";$Domain=\"" + server.getCookieDomain()
+        + "\";$Port=\"" + portList + "\"");
+
+    RecordedRequest request2 = server2.takeRequest();
+    assertContainsNoneMatching(request2.getHeaders(), "Cookie.*");
+  }
+
+  @Test public void redirectsDoNotIncludeTooManyAuthHeaders() throws Exception {
+    server2.enqueue(new MockResponse().setBody("Page 2"));
+    server2.play();
+
+    server.enqueue(new MockResponse().setResponseCode(401));
+    server.enqueue(new MockResponse().setResponseCode(302)
+        .addHeader("Location: " + server2.getUrl("/b")));
+    server.play();
+
+    client.setAuthenticator(new RecordingOkAuthenticator(Credentials.basic("jesse", "secret")));
+
+    Request request = new Request.Builder().url(server.getUrl("/a")).build();
+    Response response = client.newCall(request).execute();
+    assertEquals("Page 2", response.body().string());
+
+    RecordedRequest redirectRequest = server2.takeRequest();
+    assertContainsNoneMatching(redirectRequest.getHeaders(), "Authorization.*");
+    assertEquals("/b", redirectRequest.getPath());
+  }
+
+  @Test public void redirect_Async() throws Exception {
+    server.enqueue(new MockResponse()
+        .setResponseCode(301)
+        .addHeader("Location: /b")
+        .addHeader("Test", "Redirect from /a to /b")
+        .setBody("/a has moved!"));
+    server.enqueue(new MockResponse()
+        .setResponseCode(302)
+        .addHeader("Location: /c")
+        .addHeader("Test", "Redirect from /b to /c")
+        .setBody("/b has moved!"));
+    server.enqueue(new MockResponse().setBody("C"));
+    server.play();
+
+    Request request = new Request.Builder().url(server.getUrl("/a")).build();
+    client.newCall(request).enqueue(callback);
+
+    callback.await(server.getUrl("/c"))
+        .assertCode(200)
+        .assertBody("C")
+        .priorResponse()
+        .assertCode(302)
+        .assertHeader("Test", "Redirect from /b to /c")
+        .priorResponse()
+        .assertCode(301)
+        .assertHeader("Test", "Redirect from /a to /b");
+
+    assertEquals(0, server.takeRequest().getSequenceNumber()); // New connection.
+    assertEquals(1, server.takeRequest().getSequenceNumber()); // Connection reused.
+    assertEquals(2, server.takeRequest().getSequenceNumber()); // Connection reused again!
+  }
+
+  @Test public void follow20Redirects() throws Exception {
+    for (int i = 0; i < 20; i++) {
+      server.enqueue(new MockResponse()
+          .setResponseCode(301)
+          .addHeader("Location: /" + (i + 1))
+          .setBody("Redirecting to /" + (i + 1)));
+    }
+    server.enqueue(new MockResponse().setBody("Success!"));
+    server.play();
+
+    executeSynchronously(new Request.Builder().url(server.getUrl("/0")).build())
+        .assertCode(200)
+        .assertBody("Success!");
+  }
+
+  @Test public void follow20Redirects_Async() throws Exception {
+    for (int i = 0; i < 20; i++) {
+      server.enqueue(new MockResponse()
+          .setResponseCode(301)
+          .addHeader("Location: /" + (i + 1))
+          .setBody("Redirecting to /" + (i + 1)));
+    }
+    server.enqueue(new MockResponse().setBody("Success!"));
+    server.play();
+
+    Request request = new Request.Builder().url(server.getUrl("/0")).build();
+    client.newCall(request).enqueue(callback);
+    callback.await(server.getUrl("/20"))
+        .assertCode(200)
+        .assertBody("Success!");
+  }
+
+  @Test public void doesNotFollow21Redirects() throws Exception {
+    for (int i = 0; i < 21; i++) {
+      server.enqueue(new MockResponse()
+          .setResponseCode(301)
+          .addHeader("Location: /" + (i + 1))
+          .setBody("Redirecting to /" + (i + 1)));
+    }
+    server.play();
+
+    try {
+      client.newCall(new Request.Builder().url(server.getUrl("/0")).build()).execute();
+      fail();
+    } catch (IOException e) {
+      assertEquals("Too many redirects: 21", e.getMessage());
+    }
+  }
+
+  @Test public void doesNotFollow21Redirects_Async() throws Exception {
+    for (int i = 0; i < 21; i++) {
+      server.enqueue(new MockResponse()
+          .setResponseCode(301)
+          .addHeader("Location: /" + (i + 1))
+          .setBody("Redirecting to /" + (i + 1)));
+    }
+    server.play();
+
+    Request request = new Request.Builder().url(server.getUrl("/0")).build();
+    client.newCall(request).enqueue(callback);
+    callback.await(server.getUrl("/20")).assertFailure("Too many redirects: 21");
+  }
+
+  @Test public void canceledBeforeExecute() throws Exception {
+    server.play();
+
+    Call call = client.newCall(new Request.Builder().url(server.getUrl("/a")).build());
+    call.cancel();
+
+    try {
+      call.execute();
+      fail();
+    } catch (IOException e){
+    }
+    assertEquals(0, server.getRequestCount());
+  }
+
+  @Test public void cancelBeforeBodyIsRead() throws Exception {
+    server.enqueue(new MockResponse().setBody("def").throttleBody(1, 750, TimeUnit.MILLISECONDS));
+    server.play();
+
+    final Call call = client.newCall(new Request.Builder().url(server.getUrl("/a")).build());
+    ExecutorService executor = Executors.newSingleThreadExecutor();
+    Future<Response> result = executor.submit(new Callable<Response>() {
+      @Override public Response call() throws Exception {
+        return call.execute();
+      }
+    });
+
+    Thread.sleep(100); // wait for it to go in flight.
+
+    call.cancel();
+    try {
+      result.get().body().bytes();
+      fail();
+    } catch (IOException e) {
+    }
+    assertEquals(1, server.getRequestCount());
+  }
+
+  /**
+   * This test puts a request in front of one that is to be canceled, so that it is canceled before
+   * I/O takes place.
+   */
+  @Test public void canceledBeforeIOSignalsOnFailure() throws Exception {
+    client.getDispatcher().setMaxRequests(1); // Force requests to be executed serially.
+    server.setDispatcher(new Dispatcher() {
+      char nextResponse = 'A';
+
+      @Override public MockResponse dispatch(RecordedRequest request) {
+        client.cancel("request B");
+        return new MockResponse().setBody(Character.toString(nextResponse++));
+      }
+    });
+    server.play();
+
+    Request requestA = new Request.Builder().url(server.getUrl("/a")).tag("request A").build();
+    client.newCall(requestA).enqueue(callback);
+    assertEquals("/a", server.takeRequest().getPath());
+
+    Request requestB = new Request.Builder().url(server.getUrl("/b")).tag("request B").build();
+    client.newCall(requestB).enqueue(callback);
+    assertEquals("/b", server.takeRequest().getPath());
+
+    callback.await(requestA.url()).assertBody("A");
+    // At this point we know the callback is ready, and that it will receive a cancel failure.
+    callback.await(requestB.url()).assertFailure("Canceled");
+  }
+
+  @Test public void canceledBeforeIOSignalsOnFailure_HTTP_2() throws Exception {
+    enableProtocol(Protocol.HTTP_2);
+    canceledBeforeIOSignalsOnFailure();
+  }
+
+  @Test public void canceledBeforeIOSignalsOnFailure_SPDY_3() throws Exception {
+    enableProtocol(Protocol.SPDY_3);
+    canceledBeforeIOSignalsOnFailure();
+  }
+
+  @Test public void canceledBeforeResponseReadSignalsOnFailure() throws Exception {
+    server.play();
+    Request requestA = new Request.Builder().url(server.getUrl("/a")).tag("request A").build();
+    final Call call = client.newCall(requestA);
+    server.setDispatcher(new Dispatcher() {
+      @Override public MockResponse dispatch(RecordedRequest request) {
+        call.cancel();
+        return new MockResponse().setBody("A");
+      }
+    });
+
+    call.enqueue(callback);
+    assertEquals("/a", server.takeRequest().getPath());
+
+    callback.await(requestA.url()).assertFailure("Canceled");
+  }
+
+  @Test public void canceledBeforeResponseReadSignalsOnFailure_HTTP_2() throws Exception {
+    enableProtocol(Protocol.HTTP_2);
+    canceledBeforeResponseReadSignalsOnFailure();
+  }
+
+  @Test public void canceledBeforeResponseReadSignalsOnFailure_SPDY_3() throws Exception {
+    enableProtocol(Protocol.SPDY_3);
+    canceledBeforeResponseReadSignalsOnFailure();
+  }
+
+  /**
+   * There's a race condition where the cancel may apply after the stream has already been
+   * processed.
+   */
+  @Test public void canceledAfterResponseIsDeliveredBreaksStreamButSignalsOnce() throws Exception {
+    server.enqueue(new MockResponse().setBody("A"));
+    server.play();
+
+    final CountDownLatch latch = new CountDownLatch(1);
+    final AtomicReference<String> bodyRef = new AtomicReference<>();
+    final AtomicBoolean failureRef = new AtomicBoolean();
+
+    Request request = new Request.Builder().url(server.getUrl("/a")).tag("request A").build();
+    final Call call = client.newCall(request);
+    call.enqueue(new Callback() {
+      @Override public void onFailure(Request request, IOException e) {
+        failureRef.set(true);
+        latch.countDown();
+      }
+
+      @Override public void onResponse(Response response) throws IOException {
+        call.cancel();
+        try {
+          bodyRef.set(response.body().string());
+        } catch (IOException e) { // It is ok if this broke the stream.
+          bodyRef.set("A");
+          throw e; // We expect to not loop into onFailure in this case.
+        } finally {
+          latch.countDown();
+        }
+      }
+    });
+
+    latch.await();
+    assertEquals("A", bodyRef.get());
+    assertFalse(failureRef.get());
+  }
+
+  @Test public void canceledAfterResponseIsDeliveredBreaksStreamButSignalsOnce_HTTP_2()
+      throws Exception {
+    enableProtocol(Protocol.HTTP_2);
+    canceledAfterResponseIsDeliveredBreaksStreamButSignalsOnce();
+  }
+
+  @Test public void canceledAfterResponseIsDeliveredBreaksStreamButSignalsOnce_SPDY_3()
+      throws Exception {
+    enableProtocol(Protocol.SPDY_3);
+    canceledAfterResponseIsDeliveredBreaksStreamButSignalsOnce();
+  }
+
+  @Test public void gzip() throws Exception {
+    Buffer gzippedBody = gzip("abcabcabc");
+    String bodySize = Long.toString(gzippedBody.size());
+
+    server.enqueue(new MockResponse()
+        .setBody(gzippedBody)
+        .addHeader("Content-Encoding: gzip"));
+    server.play();
+
+    Request request = new Request.Builder()
+        .url(server.getUrl("/"))
+        .build();
+
+    // Confirm that the user request doesn't have Accept-Encoding, and the user
+    // response doesn't have a Content-Encoding or Content-Length.
+    RecordedResponse userResponse = executeSynchronously(request);
+    userResponse.assertCode(200)
+        .assertRequestHeader("Accept-Encoding")
+        .assertHeader("Content-Encoding")
+        .assertHeader("Content-Length")
+        .assertBody("abcabcabc");
+
+    // But the network request doesn't lie. OkHttp used gzip for this call.
+    userResponse.networkResponse()
+        .assertHeader("Content-Encoding", "gzip")
+        .assertHeader("Content-Length", bodySize)
+        .assertRequestHeader("Accept-Encoding", "gzip");
+  }
+
+  @Test public void asyncResponseCanBeConsumedLater() throws Exception {
+    server.enqueue(new MockResponse().setBody("abc"));
+    server.enqueue(new MockResponse().setBody("def"));
+    server.play();
+
+    Request request = new Request.Builder()
+        .url(server.getUrl("/"))
+        .header("User-Agent", "SyncApiTest")
+        .build();
+
+    final BlockingQueue<Response> responseRef = new SynchronousQueue<>();
+    client.newCall(request).enqueue(new Callback() {
+      @Override public void onFailure(Request request, IOException e) {
+        throw new AssertionError();
+      }
+
+      @Override public void onResponse(Response response) throws IOException {
+        try {
+          responseRef.put(response);
+        } catch (InterruptedException e) {
+          throw new AssertionError();
+        }
+      }
+    });
+
+    Response response = responseRef.take();
+    assertEquals(200, response.code());
+    assertEquals("abc", response.body().string());
+
+    // Make another request just to confirm that that connection can be reused...
+    executeSynchronously(new Request.Builder().url(server.getUrl("/")).build()).assertBody("def");
+    assertEquals(0, server.takeRequest().getSequenceNumber()); // New connection.
+    assertEquals(1, server.takeRequest().getSequenceNumber()); // Connection reused.
+
+    // ... even before we close the response body!
+    response.body().close();
+  }
+
+  @Test public void userAgentIsOmittedByDefault() throws Exception {
+    server.enqueue(new MockResponse());
+    server.play();
+
+    executeSynchronously(new Request.Builder().url(server.getUrl("/")).build());
+
+    RecordedRequest recordedRequest = server.takeRequest();
+    assertNull(recordedRequest.getHeader("User-Agent"));
+  }
+
+  @Test
+  public void setFollowRedirectsFalse() throws Exception {
+    server.enqueue(new MockResponse()
+        .setResponseCode(302)
+        .addHeader("Location: /b")
+        .setBody("A"));
+    server.enqueue(new MockResponse()
+        .setBody("B"));
+    server.play();
+
+    client.setFollowRedirects(false);
+    RecordedResponse recordedResponse = executeSynchronously(
+        new Request.Builder().url(server.getUrl("/a")).build());
+
+    recordedResponse
+        .assertBody("A")
+        .assertCode(302);
+  }
+
+  private RecordedResponse executeSynchronously(Request request) throws IOException {
+    Response response = client.newCall(request).execute();
+    return new RecordedResponse(request, response, response.body().string(), null);
+  }
+
+  /**
+   * Tests that use this will fail unless boot classpath is set. Ex. {@code
+   * -Xbootclasspath/p:/tmp/alpn-boot-8.0.0.v20140317}
+   */
+  private void enableProtocol(Protocol protocol) {
+    client.setSslSocketFactory(sslContext.getSocketFactory());
+    client.setHostnameVerifier(new RecordingHostnameVerifier());
+    client.setProtocols(Arrays.asList(protocol, Protocol.HTTP_1_1));
+    server.useHttps(sslContext.getSocketFactory(), false);
+    server.setProtocols(client.getProtocols());
+  }
+
+  private Buffer gzip(String data) throws IOException {
+    Buffer result = new Buffer();
+    BufferedSink sink = Okio.buffer(new GzipSink(result));
+    sink.writeUtf8(data);
+    sink.close();
+    return result;
+  }
+
+  private void assertContains(Collection<String> collection, String element) {
+    for (String c : collection) {
+      if (c != null && c.equalsIgnoreCase(element)) return;
+    }
+    fail("No " + element + " in " + collection);
+  }
+
+  private void assertContainsNoneMatching(List<String> headers, String pattern) {
+    for (String header : headers) {
+      if (header.matches(pattern)) {
+        fail("Header " + header + " matches " + pattern);
+      }
+    }
+  }
+}
diff --git a/okhttp-tests/src/test/java/com/squareup/okhttp/ConnectionPoolTest.java b/okhttp-tests/src/test/java/com/squareup/okhttp/ConnectionPoolTest.java
index f25e5a2bdb..147a7d41cb 100644
--- a/okhttp-tests/src/test/java/com/squareup/okhttp/ConnectionPoolTest.java
+++ b/okhttp-tests/src/test/java/com/squareup/okhttp/ConnectionPoolTest.java
@@ -18,19 +18,22 @@
 import com.squareup.okhttp.internal.RecordingHostnameVerifier;
 import com.squareup.okhttp.internal.SslContextBuilder;
 import com.squareup.okhttp.internal.Util;
-import com.squareup.okhttp.internal.http.HttpAuthenticator;
+import com.squareup.okhttp.internal.http.AuthenticatorAdapter;
 import com.squareup.okhttp.mockwebserver.MockWebServer;
 import java.io.IOException;
 import java.net.InetAddress;
 import java.net.InetSocketAddress;
 import java.net.Proxy;
 import java.util.Arrays;
+import javax.net.SocketFactory;
 import javax.net.ssl.SSLContext;
 import org.junit.After;
 import org.junit.Before;
 import org.junit.Test;
 
+import static com.squareup.okhttp.internal.http.RouteSelector.TLS_V1;
 import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
 import static org.junit.Assert.assertNotNull;
 import static org.junit.Assert.assertNull;
 import static org.junit.Assert.assertSame;
@@ -41,14 +44,15 @@
   private static final int KEEP_ALIVE_DURATION_MS = 5000;
   private static final SSLContext sslContext = SslContextBuilder.localhost();
 
-  private final MockWebServer spdyServer = new MockWebServer();
+  private MockWebServer spdyServer;
   private InetSocketAddress spdySocketAddress;
   private Address spdyAddress;
 
-  private final MockWebServer httpServer = new MockWebServer();
+  private MockWebServer httpServer;
   private Address httpAddress;
   private InetSocketAddress httpSocketAddress;
 
+  private ConnectionPool pool;
   private Connection httpA;
   private Connection httpB;
   private Connection httpC;
@@ -56,65 +60,94 @@
   private Connection httpE;
   private Connection spdyA;
 
+  private Object owner;
+
   @Before public void setUp() throws Exception {
+    setUp(2);
+  }
+
+  private void setUp(int poolSize) throws Exception {
+    SocketFactory socketFactory = SocketFactory.getDefault();
+
+    spdyServer = new MockWebServer();
+    httpServer = new MockWebServer();
     spdyServer.useHttps(sslContext.getSocketFactory(), false);
 
     httpServer.play();
-    httpAddress = new Address(httpServer.getHostName(), httpServer.getPort(), null, null,
-        HttpAuthenticator.SYSTEM_DEFAULT, null, Protocol.SPDY3_AND_HTTP11);
+    httpAddress = new Address(httpServer.getHostName(), httpServer.getPort(), socketFactory, null,
+        null, AuthenticatorAdapter.INSTANCE, null,
+        Util.immutableList(Protocol.SPDY_3, Protocol.HTTP_1_1));
     httpSocketAddress = new InetSocketAddress(InetAddress.getByName(httpServer.getHostName()),
         httpServer.getPort());
 
     spdyServer.play();
-    spdyAddress = new Address(spdyServer.getHostName(), spdyServer.getPort(),
+    spdyAddress = new Address(spdyServer.getHostName(), spdyServer.getPort(), socketFactory,
         sslContext.getSocketFactory(), new RecordingHostnameVerifier(),
-        HttpAuthenticator.SYSTEM_DEFAULT, null,Protocol.SPDY3_AND_HTTP11);
+        AuthenticatorAdapter.INSTANCE, null,
+        Util.immutableList(Protocol.SPDY_3, Protocol.HTTP_1_1));
     spdySocketAddress = new InetSocketAddress(InetAddress.getByName(spdyServer.getHostName()),
         spdyServer.getPort());
 
-    Route httpRoute = new Route(httpAddress, Proxy.NO_PROXY, httpSocketAddress, true);
-    Route spdyRoute = new Route(spdyAddress, Proxy.NO_PROXY, spdySocketAddress, true);
-    httpA = new Connection(null, httpRoute);
-    httpA.connect(200, 200, null);
-    httpB = new Connection(null, httpRoute);
-    httpB.connect(200, 200, null);
-    httpC = new Connection(null, httpRoute);
-    httpC.connect(200, 200, null);
-    httpD = new Connection(null, httpRoute);
-    httpD.connect(200, 200, null);
-    httpE = new Connection(null, httpRoute);
-    httpE.connect(200, 200, null);
-    spdyA = new Connection(null, spdyRoute);
-    spdyA.connect(20000, 20000, null);
+    Route httpRoute = new Route(httpAddress, Proxy.NO_PROXY, httpSocketAddress, TLS_V1);
+    Route spdyRoute = new Route(spdyAddress, Proxy.NO_PROXY, spdySocketAddress, TLS_V1);
+    pool = new ConnectionPool(poolSize, KEEP_ALIVE_DURATION_MS);
+    httpA = new Connection(pool, httpRoute);
+    httpA.connect(200, 200, 200, null);
+    httpB = new Connection(pool, httpRoute);
+    httpB.connect(200, 200, 200, null);
+    httpC = new Connection(pool, httpRoute);
+    httpC.connect(200, 200, 200, null);
+    httpD = new Connection(pool, httpRoute);
+    httpD.connect(200, 200, 200, null);
+    httpE = new Connection(pool, httpRoute);
+    httpE.connect(200, 200, 200, null);
+    spdyA = new Connection(pool, spdyRoute);
+    spdyA.connect(20000, 20000, 2000, null);
+
+    owner = new Object();
+    httpA.setOwner(owner);
+    httpB.setOwner(owner);
+    httpC.setOwner(owner);
+    httpD.setOwner(owner);
+    httpE.setOwner(owner);
   }
 
   @After public void tearDown() throws Exception {
     httpServer.shutdown();
     spdyServer.shutdown();
 
-    Util.closeQuietly(httpA);
-    Util.closeQuietly(httpB);
-    Util.closeQuietly(httpC);
-    Util.closeQuietly(httpD);
-    Util.closeQuietly(httpE);
-    Util.closeQuietly(spdyA);
+    Util.closeQuietly(httpA.getSocket());
+    Util.closeQuietly(httpB.getSocket());
+    Util.closeQuietly(httpC.getSocket());
+    Util.closeQuietly(httpD.getSocket());
+    Util.closeQuietly(httpE.getSocket());
+    Util.closeQuietly(spdyA.getSocket());
   }
 
-  @Test public void poolSingleHttpConnection() throws IOException {
-    ConnectionPool pool = new ConnectionPool(1, KEEP_ALIVE_DURATION_MS);
+  private void resetWithPoolSize(int poolSize) throws Exception {
+    tearDown();
+    setUp(poolSize);
+  }
+
+  @Test public void poolSingleHttpConnection() throws Exception {
+    resetWithPoolSize(1);
     Connection connection = pool.get(httpAddress);
     assertNull(connection);
 
     connection = new Connection(
-        null, new Route(httpAddress, Proxy.NO_PROXY, httpSocketAddress, true));
-    connection.connect(200, 200, null);
+        pool, new Route(httpAddress, Proxy.NO_PROXY, httpSocketAddress, TLS_V1));
+    connection.connect(200, 200, 200, null);
+    connection.setOwner(owner);
     assertEquals(0, pool.getConnectionCount());
+
     pool.recycle(connection);
+    assertNull(connection.getOwner());
     assertEquals(1, pool.getConnectionCount());
     assertEquals(1, pool.getHttpConnectionCount());
     assertEquals(0, pool.getSpdyConnectionCount());
 
     Connection recycledConnection = pool.get(httpAddress);
+    assertNull(connection.getOwner());
     assertEquals(connection, recycledConnection);
     assertTrue(recycledConnection.isAlive());
 
@@ -123,7 +156,6 @@
   }
 
   @Test public void poolPrefersMostRecentlyRecycled() throws Exception {
-    ConnectionPool pool = new ConnectionPool(2, KEEP_ALIVE_DURATION_MS);
     pool.recycle(httpA);
     pool.recycle(httpB);
     pool.recycle(httpC);
@@ -131,21 +163,18 @@
   }
 
   @Test public void getSpdyConnection() throws Exception {
-    ConnectionPool pool = new ConnectionPool(2, KEEP_ALIVE_DURATION_MS);
     pool.share(spdyA);
     assertSame(spdyA, pool.get(spdyAddress));
     assertPooled(pool, spdyA);
   }
 
   @Test public void getHttpConnection() throws Exception {
-    ConnectionPool pool = new ConnectionPool(2, KEEP_ALIVE_DURATION_MS);
     pool.recycle(httpA);
     assertSame(httpA, pool.get(httpAddress));
     assertPooled(pool);
   }
 
   @Test public void idleConnectionNotReturned() throws Exception {
-    ConnectionPool pool = new ConnectionPool(2, KEEP_ALIVE_DURATION_MS);
     pool.recycle(httpA);
     Thread.sleep(KEEP_ALIVE_DURATION_MS * 2);
     assertNull(pool.get(httpAddress));
@@ -153,7 +182,6 @@
   }
 
   @Test public void maxIdleConnectionLimitIsEnforced() throws Exception {
-    ConnectionPool pool = new ConnectionPool(2, KEEP_ALIVE_DURATION_MS);
     pool.recycle(httpA);
     pool.recycle(httpB);
     pool.recycle(httpC);
@@ -162,7 +190,6 @@
   }
 
   @Test public void expiredConnectionsAreEvicted() throws Exception {
-    ConnectionPool pool = new ConnectionPool(2, KEEP_ALIVE_DURATION_MS);
     pool.recycle(httpA);
     pool.recycle(httpB);
     Thread.sleep(2 * KEEP_ALIVE_DURATION_MS);
@@ -171,22 +198,19 @@
   }
 
   @Test public void nonAliveConnectionNotReturned() throws Exception {
-    ConnectionPool pool = new ConnectionPool(2, KEEP_ALIVE_DURATION_MS);
     pool.recycle(httpA);
-    httpA.close();
+    httpA.getSocket().close();
     assertNull(pool.get(httpAddress));
     assertPooled(pool);
   }
 
   @Test public void differentAddressConnectionNotReturned() throws Exception {
-    ConnectionPool pool = new ConnectionPool(2, KEEP_ALIVE_DURATION_MS);
     pool.recycle(httpA);
     assertNull(pool.get(spdyAddress));
     assertPooled(pool, httpA);
   }
 
   @Test public void gettingSpdyConnectionPromotesItToFrontOfQueue() throws Exception {
-    ConnectionPool pool = new ConnectionPool(2, KEEP_ALIVE_DURATION_MS);
     pool.share(spdyA);
     pool.recycle(httpA);
     assertPooled(pool, httpA, spdyA);
@@ -195,21 +219,18 @@
   }
 
   @Test public void gettingConnectionReturnsOldestFirst() throws Exception {
-    ConnectionPool pool = new ConnectionPool(2, KEEP_ALIVE_DURATION_MS);
     pool.recycle(httpA);
     pool.recycle(httpB);
     assertSame(httpA, pool.get(httpAddress));
   }
 
   @Test public void recyclingNonAliveConnectionClosesThatConnection() throws Exception {
-    ConnectionPool pool = new ConnectionPool(2, KEEP_ALIVE_DURATION_MS);
     httpA.getSocket().shutdownInput();
     pool.recycle(httpA); // Should close httpA.
     assertTrue(httpA.getSocket().isClosed());
   }
 
   @Test public void shareHttpConnectionFails() throws Exception {
-    ConnectionPool pool = new ConnectionPool(2, KEEP_ALIVE_DURATION_MS);
     try {
       pool.share(httpA);
       fail();
@@ -219,13 +240,11 @@
   }
 
   @Test public void recycleSpdyConnectionDoesNothing() throws Exception {
-    ConnectionPool pool = new ConnectionPool(2, KEEP_ALIVE_DURATION_MS);
     pool.recycle(spdyA);
     assertPooled(pool);
   }
 
   @Test public void validateIdleSpdyConnectionTimeout() throws Exception {
-    ConnectionPool pool = new ConnectionPool(2, KEEP_ALIVE_DURATION_MS);
     pool.share(spdyA);
     Thread.sleep((int) (KEEP_ALIVE_DURATION_MS * 0.7));
     assertNull(pool.get(httpAddress));
@@ -236,7 +255,6 @@
   }
 
   @Test public void validateIdleHttpConnectionTimeout() throws Exception {
-    ConnectionPool pool = new ConnectionPool(2, KEEP_ALIVE_DURATION_MS);
     pool.recycle(httpA);
     Thread.sleep((int) (KEEP_ALIVE_DURATION_MS * 0.7));
     assertNull(pool.get(spdyAddress));
@@ -247,8 +265,6 @@
   }
 
   @Test public void maxConnections() throws IOException, InterruptedException {
-    ConnectionPool pool = new ConnectionPool(2, KEEP_ALIVE_DURATION_MS);
-
     // Pool should be empty.
     assertEquals(0, pool.getConnectionCount());
 
@@ -280,6 +296,7 @@
 
     // http C should be removed from the pool.
     Connection recycledHttpConnection = pool.get(httpAddress);
+    recycledHttpConnection.setOwner(owner);
     assertNotNull(recycledHttpConnection);
     assertTrue(recycledHttpConnection.isAlive());
     assertEquals(1, pool.getConnectionCount());
@@ -344,7 +361,7 @@
     assertEquals(1, pool.getSpdyConnectionCount());
 
     // Kill http A.
-    Util.closeQuietly(httpA);
+    Util.closeQuietly(httpA.getSocket());
 
     // Force pool to run a clean up.
     assertNotNull(pool.get(spdyAddress));
@@ -366,10 +383,10 @@
     assertEquals(0, pool.getSpdyConnectionCount());
   }
 
-  @Test public void evictAllConnections() {
-    ConnectionPool pool = new ConnectionPool(10, KEEP_ALIVE_DURATION_MS);
+  @Test public void evictAllConnections() throws Exception {
+    resetWithPoolSize(10);
     pool.recycle(httpA);
-    Util.closeQuietly(httpA); // Include a closed connection in the pool.
+    Util.closeQuietly(httpA.getSocket()); // Include a closed connection in the pool.
     pool.recycle(httpB);
     pool.share(spdyA);
     int connectionCount = pool.getConnectionCount();
@@ -379,6 +396,26 @@
     assertEquals(0, pool.getConnectionCount());
   }
 
+  @Test public void closeIfOwnedBy() throws Exception {
+    httpA.closeIfOwnedBy(owner);
+    assertFalse(httpA.isAlive());
+    assertFalse(httpA.clearOwner());
+  }
+
+  @Test public void closeIfOwnedByDoesNothingIfNotOwner() throws Exception {
+    httpA.closeIfOwnedBy(new Object());
+    assertTrue(httpA.isAlive());
+    assertTrue(httpA.clearOwner());
+  }
+
+  @Test public void closeIfOwnedByFailsForSpdyConnections() throws Exception {
+    try {
+      spdyA.closeIfOwnedBy(owner);
+      fail();
+    } catch (IllegalStateException expected) {
+    }
+  }
+
   private void assertPooled(ConnectionPool pool, Connection... connections) throws Exception {
     assertEquals(Arrays.asList(connections), pool.getConnections());
   }
diff --git a/okhttp-tests/src/test/java/com/squareup/okhttp/DispatcherTest.java b/okhttp-tests/src/test/java/com/squareup/okhttp/DispatcherTest.java
index a42362fbff..68713b9ef2 100644
--- a/okhttp-tests/src/test/java/com/squareup/okhttp/DispatcherTest.java
+++ b/okhttp-tests/src/test/java/com/squareup/okhttp/DispatcherTest.java
@@ -1,5 +1,6 @@
 package com.squareup.okhttp;
 
+import com.squareup.okhttp.Call.AsyncCall;
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.Iterator;
@@ -14,7 +15,7 @@
 
 public final class DispatcherTest {
   RecordingExecutor executor = new RecordingExecutor();
-  RecordingReceiver receiver = new RecordingReceiver();
+  RecordingCallback callback = new RecordingCallback();
   Dispatcher dispatcher = new Dispatcher(executor);
   OkHttpClient client = new OkHttpClient().setDispatcher(dispatcher);
 
@@ -40,53 +41,53 @@
   }
 
   @Test public void enqueuedJobsRunImmediately() throws Exception {
-    client.enqueue(newRequest("http://a/1"), receiver);
+    client.newCall(newRequest("http://a/1")).enqueue(callback);
     executor.assertJobs("http://a/1");
   }
 
   @Test public void maxRequestsEnforced() throws Exception {
     dispatcher.setMaxRequests(3);
-    client.enqueue(newRequest("http://a/1"), receiver);
-    client.enqueue(newRequest("http://a/2"), receiver);
-    client.enqueue(newRequest("http://b/1"), receiver);
-    client.enqueue(newRequest("http://b/2"), receiver);
+    client.newCall(newRequest("http://a/1")).enqueue(callback);
+    client.newCall(newRequest("http://a/2")).enqueue(callback);
+    client.newCall(newRequest("http://b/1")).enqueue(callback);
+    client.newCall(newRequest("http://b/2")).enqueue(callback);
     executor.assertJobs("http://a/1", "http://a/2", "http://b/1");
   }
 
   @Test public void maxPerHostEnforced() throws Exception {
     dispatcher.setMaxRequestsPerHost(2);
-    client.enqueue(newRequest("http://a/1"), receiver);
-    client.enqueue(newRequest("http://a/2"), receiver);
-    client.enqueue(newRequest("http://a/3"), receiver);
+    client.newCall(newRequest("http://a/1")).enqueue(callback);
+    client.newCall(newRequest("http://a/2")).enqueue(callback);
+    client.newCall(newRequest("http://a/3")).enqueue(callback);
     executor.assertJobs("http://a/1", "http://a/2");
   }
 
   @Test public void increasingMaxRequestsPromotesJobsImmediately() throws Exception {
     dispatcher.setMaxRequests(2);
-    client.enqueue(newRequest("http://a/1"), receiver);
-    client.enqueue(newRequest("http://b/1"), receiver);
-    client.enqueue(newRequest("http://c/1"), receiver);
-    client.enqueue(newRequest("http://a/2"), receiver);
-    client.enqueue(newRequest("http://b/2"), receiver);
+    client.newCall(newRequest("http://a/1")).enqueue(callback);
+    client.newCall(newRequest("http://b/1")).enqueue(callback);
+    client.newCall(newRequest("http://c/1")).enqueue(callback);
+    client.newCall(newRequest("http://a/2")).enqueue(callback);
+    client.newCall(newRequest("http://b/2")).enqueue(callback);
     dispatcher.setMaxRequests(4);
     executor.assertJobs("http://a/1", "http://b/1", "http://c/1", "http://a/2");
   }
 
   @Test public void increasingMaxPerHostPromotesJobsImmediately() throws Exception {
     dispatcher.setMaxRequestsPerHost(2);
-    client.enqueue(newRequest("http://a/1"), receiver);
-    client.enqueue(newRequest("http://a/2"), receiver);
-    client.enqueue(newRequest("http://a/3"), receiver);
-    client.enqueue(newRequest("http://a/4"), receiver);
-    client.enqueue(newRequest("http://a/5"), receiver);
+    client.newCall(newRequest("http://a/1")).enqueue(callback);
+    client.newCall(newRequest("http://a/2")).enqueue(callback);
+    client.newCall(newRequest("http://a/3")).enqueue(callback);
+    client.newCall(newRequest("http://a/4")).enqueue(callback);
+    client.newCall(newRequest("http://a/5")).enqueue(callback);
     dispatcher.setMaxRequestsPerHost(4);
     executor.assertJobs("http://a/1", "http://a/2", "http://a/3", "http://a/4");
   }
 
   @Test public void oldJobFinishesNewJobCanRunDifferentHost() throws Exception {
     dispatcher.setMaxRequests(1);
-    client.enqueue(newRequest("http://a/1"), receiver);
-    client.enqueue(newRequest("http://b/1"), receiver);
+    client.newCall(newRequest("http://a/1")).enqueue(callback);
+    client.newCall(newRequest("http://b/1")).enqueue(callback);
     executor.finishJob("http://a/1");
     executor.assertJobs("http://b/1");
   }
@@ -94,27 +95,27 @@
   @Test public void oldJobFinishesNewJobWithSameHostStarts() throws Exception {
     dispatcher.setMaxRequests(2);
     dispatcher.setMaxRequestsPerHost(1);
-    client.enqueue(newRequest("http://a/1"), receiver);
-    client.enqueue(newRequest("http://b/1"), receiver);
-    client.enqueue(newRequest("http://b/2"), receiver);
-    client.enqueue(newRequest("http://a/2"), receiver);
+    client.newCall(newRequest("http://a/1")).enqueue(callback);
+    client.newCall(newRequest("http://b/1")).enqueue(callback);
+    client.newCall(newRequest("http://b/2")).enqueue(callback);
+    client.newCall(newRequest("http://a/2")).enqueue(callback);
     executor.finishJob("http://a/1");
     executor.assertJobs("http://b/1", "http://a/2");
   }
 
   @Test public void oldJobFinishesNewJobCantRunDueToHostLimit() throws Exception {
     dispatcher.setMaxRequestsPerHost(1);
-    client.enqueue(newRequest("http://a/1"), receiver);
-    client.enqueue(newRequest("http://b/1"), receiver);
-    client.enqueue(newRequest("http://a/2"), receiver);
+    client.newCall(newRequest("http://a/1")).enqueue(callback);
+    client.newCall(newRequest("http://b/1")).enqueue(callback);
+    client.newCall(newRequest("http://a/2")).enqueue(callback);
     executor.finishJob("http://b/1");
     executor.assertJobs("http://a/1");
   }
 
   @Test public void cancelingReadyJobPreventsItFromStarting() throws Exception {
     dispatcher.setMaxRequestsPerHost(1);
-    client.enqueue(newRequest("http://a/1"), receiver);
-    client.enqueue(newRequest("http://a/2", "tag1"), receiver);
+    client.newCall(newRequest("http://a/1")).enqueue(callback);
+    client.newCall(newRequest("http://a/2", "tag1")).enqueue(callback);
     dispatcher.cancel("tag1");
     executor.finishJob("http://a/1");
     executor.assertJobs();
@@ -122,8 +123,8 @@
 
   @Test public void cancelingRunningJobTakesNoEffectUntilJobFinishes() throws Exception {
     dispatcher.setMaxRequests(1);
-    client.enqueue(newRequest("http://a/1", "tag1"), receiver);
-    client.enqueue(newRequest("http://a/2"), receiver);
+    client.newCall(newRequest("http://a/1", "tag1")).enqueue(callback);
+    client.newCall(newRequest("http://a/2")).enqueue(callback);
     dispatcher.cancel("tag1");
     executor.assertJobs("http://a/1");
     executor.finishJob("http://a/1");
@@ -131,26 +132,26 @@
   }
 
   class RecordingExecutor extends AbstractExecutorService {
-    private List<Job> jobs = new ArrayList<Job>();
+    private List<AsyncCall> calls = new ArrayList<>();
 
     @Override public void execute(Runnable command) {
-      jobs.add((Job) command);
+      calls.add((AsyncCall) command);
     }
 
     public void assertJobs(String... expectedUrls) {
-      List<String> actualUrls = new ArrayList<String>();
-      for (Job job : jobs) {
-        actualUrls.add(job.request().urlString());
+      List<String> actualUrls = new ArrayList<>();
+      for (AsyncCall call : calls) {
+        actualUrls.add(call.request().urlString());
       }
       assertEquals(Arrays.asList(expectedUrls), actualUrls);
     }
 
     public void finishJob(String url) {
-      for (Iterator<Job> i = jobs.iterator(); i.hasNext(); ) {
-        Job job = i.next();
-        if (job.request().urlString().equals(url)) {
+      for (Iterator<AsyncCall> i = calls.iterator(); i.hasNext(); ) {
+        AsyncCall call = i.next();
+        if (call.request().urlString().equals(url)) {
           i.remove();
-          dispatcher.finished(job);
+          dispatcher.finished(call);
           return;
         }
       }
diff --git a/okhttp-tests/src/test/java/com/squareup/okhttp/FormEncodingBuilderTest.java b/okhttp-tests/src/test/java/com/squareup/okhttp/FormEncodingBuilderTest.java
new file mode 100644
index 0000000000..a9533bf783
--- /dev/null
+++ b/okhttp-tests/src/test/java/com/squareup/okhttp/FormEncodingBuilderTest.java
@@ -0,0 +1,67 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.okhttp;
+
+import okio.Buffer;
+import org.junit.Test;
+
+import static org.junit.Assert.assertEquals;
+
+public final class FormEncodingBuilderTest {
+  @Test public void urlEncoding() throws Exception {
+    RequestBody formEncoding = new FormEncodingBuilder()
+        .add("a&b", "c=d")
+        .add("space, the", "final frontier")
+        .build();
+
+    assertEquals("application/x-www-form-urlencoded", formEncoding.contentType().toString());
+
+    String expected = "a%26b=c%3Dd&space%2C+the=final+frontier";
+    assertEquals(expected.length(), formEncoding.contentLength());
+
+    Buffer out = new Buffer();
+    formEncoding.writeTo(out);
+    assertEquals(expected, out.readUtf8());
+  }
+
+  @Test public void encodedPair() throws Exception {
+    RequestBody formEncoding = new FormEncodingBuilder()
+        .add("sim", "ple")
+        .build();
+
+    String expected = "sim=ple";
+    assertEquals(expected.length(), formEncoding.contentLength());
+
+    Buffer buffer = new Buffer();
+    formEncoding.writeTo(buffer);
+    assertEquals(expected, buffer.readUtf8());
+  }
+
+  @Test public void encodeMultiplePairs() throws Exception {
+    RequestBody formEncoding = new FormEncodingBuilder()
+        .add("sim", "ple")
+        .add("hey", "there")
+        .add("help", "me")
+        .build();
+
+    String expected = "sim=ple&hey=there&help=me";
+    assertEquals(expected.length(), formEncoding.contentLength());
+
+    Buffer buffer = new Buffer();
+    formEncoding.writeTo(buffer);
+    assertEquals(expected, buffer.readUtf8());
+  }
+}
diff --git a/okhttp-tests/src/test/java/com/squareup/okhttp/MediaTypeTest.java b/okhttp-tests/src/test/java/com/squareup/okhttp/MediaTypeTest.java
index acbfdd5c16..25805957a5 100644
--- a/okhttp-tests/src/test/java/com/squareup/okhttp/MediaTypeTest.java
+++ b/okhttp-tests/src/test/java/com/squareup/okhttp/MediaTypeTest.java
@@ -54,6 +54,13 @@
     assertMediaType("text/plain; a=1; a=2; b=3");
     assertMediaType("text/plain; charset=utf-16");
     assertMediaType("text/plain; \t \n \r a=b");
+    assertMediaType("text/plain;");
+    assertMediaType("text/plain; ");
+    assertMediaType("text/plain; a=1;");
+    assertMediaType("text/plain; a=1; ");
+    assertMediaType("text/plain; a=1;; b=2");
+    assertMediaType("text/plain;;");
+    assertMediaType("text/plain; ;");
   }
 
   @Test public void testInvalidParse() throws Exception {
@@ -64,14 +71,10 @@
     assertInvalid("text/");
     assertInvalid("te<t/plain");
     assertInvalid("text/pl@in");
-    assertInvalid("text/plain;");
-    assertInvalid("text/plain; ");
     assertInvalid("text/plain; a");
     assertInvalid("text/plain; a=");
     assertInvalid("text/plain; a=@");
     assertInvalid("text/plain; a=\"@");
-    assertInvalid("text/plain; a=1;");
-    assertInvalid("text/plain; a=1; ");
     assertInvalid("text/plain; a=1; b");
     assertInvalid("text/plain; a=1; b=");
     assertInvalid("text/plain; a=\u2025");
@@ -104,6 +107,11 @@
     assertEquals("UTF-8", mediaType.charset().name());
   }
 
+  @Test public void testDuplicatedCharsets() {
+    MediaType mediaType = MediaType.parse("text/plain; charset=utf-8; charset=UTF-8");
+    assertEquals("UTF-8", mediaType.charset().name());
+  }
+
   @Test public void testMultipleCharsets() {
     try {
       MediaType.parse("text/plain; charset=utf-8; charset=utf-16");
@@ -140,6 +148,14 @@
     assertEquals("ISO-8859-1", charset.charset(Charset.forName("US-ASCII")).name());
   }
 
+  @Test public void testParseDanglingSemicolon() throws Exception {
+    MediaType mediaType = MediaType.parse("text/plain;");
+    assertEquals("text", mediaType.type());
+    assertEquals("plain", mediaType.subtype());
+    assertEquals(null, mediaType.charset());
+    assertEquals("text/plain;", mediaType.toString());
+  }
+
   private void assertMediaType(String string) {
     MediaType mediaType = MediaType.parse(string);
     assertEquals(string, mediaType.toString());
diff --git a/okhttp-tests/src/test/java/com/squareup/okhttp/MultipartBuilderTest.java b/okhttp-tests/src/test/java/com/squareup/okhttp/MultipartBuilderTest.java
new file mode 100644
index 0000000000..4159679c76
--- /dev/null
+++ b/okhttp-tests/src/test/java/com/squareup/okhttp/MultipartBuilderTest.java
@@ -0,0 +1,245 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.okhttp;
+
+import java.io.IOException;
+import okio.Buffer;
+import okio.BufferedSink;
+import org.junit.Test;
+
+import static com.squareup.okhttp.internal.Util.UTF_8;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.fail;
+
+public final class MultipartBuilderTest {
+  @Test(expected = IllegalStateException.class)
+  public void onePartRequired() throws Exception {
+    new MultipartBuilder().build();
+  }
+
+  @Test public void singlePart() throws Exception {
+    String expected = ""
+        + "--123\r\n"
+        + "Content-Length: 13\r\n"
+        + "\r\n"
+        + "Hello, World!\r\n"
+        + "--123--\r\n";
+
+    RequestBody requestBody = new MultipartBuilder("123")
+        .addPart(RequestBody.create(null, "Hello, World!"))
+        .build();
+
+    assertEquals("multipart/mixed; boundary=123", requestBody.contentType().toString());
+
+    Buffer buffer = new Buffer();
+    requestBody.writeTo(buffer);
+    assertEquals(53, requestBody.contentLength());
+    assertEquals(buffer.size(), requestBody.contentLength());
+    assertEquals(expected, buffer.readUtf8());
+  }
+
+  @Test public void threeParts() throws Exception {
+    String expected = ""
+        + "--123\r\n"
+        + "Content-Length: 5\r\n"
+        + "\r\n"
+        + "Quick\r\n"
+        + "--123\r\n"
+        + "Content-Length: 5\r\n"
+        + "\r\n"
+        + "Brown\r\n"
+        + "--123\r\n"
+        + "Content-Length: 3\r\n"
+        + "\r\n"
+        + "Fox\r\n"
+        + "--123--\r\n";
+
+    RequestBody requestBody = new MultipartBuilder("123")
+        .addPart(RequestBody.create(null, "Quick"))
+        .addPart(RequestBody.create(null, "Brown"))
+        .addPart(RequestBody.create(null, "Fox"))
+        .build();
+
+    assertEquals("multipart/mixed; boundary=123", requestBody.contentType().toString());
+
+    Buffer buffer = new Buffer();
+    requestBody.writeTo(buffer);
+    assertEquals(112, requestBody.contentLength());
+    assertEquals(buffer.size(), requestBody.contentLength());
+    assertEquals(expected, buffer.readUtf8());
+  }
+
+  @Test public void fieldAndTwoFiles() throws Exception {
+    String expected = ""
+        + "--AaB03x\r\n"
+        + "Content-Disposition: form-data; name=\"submit-name\"\r\n"
+        + "Content-Length: 5\r\n"
+        + "\r\n"
+        + "Larry\r\n"
+        + "--AaB03x\r\n"
+        + "Content-Disposition: form-data; name=\"files\"\r\n"
+        + "Content-Type: multipart/mixed; boundary=BbC04y\r\n"
+        + "Content-Length: 337\r\n"
+        + "\r\n"
+        + "--BbC04y\r\n"
+        + "Content-Disposition: file; filename=\"file1.txt\"\r\n"
+        + "Content-Type: text/plain; charset=utf-8\r\n"
+        + "Content-Length: 29\r\n"
+        + "\r\n"
+        + "... contents of file1.txt ...\r\n"
+        + "--BbC04y\r\n"
+        + "Content-Disposition: file; filename=\"file2.gif\"\r\n"
+        + "Content-Transfer-Encoding: binary\r\n"
+        + "Content-Type: image/gif\r\n"
+        + "Content-Length: 29\r\n"
+        + "\r\n"
+        + "... contents of file2.gif ...\r\n"
+        + "--BbC04y--\r\n"
+        + "\r\n"
+        + "--AaB03x--\r\n";
+
+    RequestBody requestBody = new MultipartBuilder("AaB03x")
+        .type(MultipartBuilder.FORM)
+        .addFormDataPart("submit-name", "Larry")
+        .addFormDataPart("files", null,
+            new MultipartBuilder("BbC04y")
+                .addPart(
+                    Headers.of("Content-Disposition", "file; filename=\"file1.txt\""),
+                    RequestBody.create(
+                        MediaType.parse("text/plain"), "... contents of file1.txt ..."))
+                .addPart(
+                    Headers.of(
+                        "Content-Disposition", "file; filename=\"file2.gif\"",
+                        "Content-Transfer-Encoding", "binary"),
+                    RequestBody.create(
+                        MediaType.parse("image/gif"),
+                        "... contents of file2.gif ...".getBytes(UTF_8)))
+                .build())
+        .build();
+
+    assertEquals("multipart/form-data; boundary=AaB03x", requestBody.contentType().toString());
+
+    Buffer buffer = new Buffer();
+    requestBody.writeTo(buffer);
+    assertEquals(568, requestBody.contentLength());
+    assertEquals(buffer.size(), requestBody.contentLength());
+    assertEquals(expected, buffer.readUtf8());
+  }
+
+  @Test public void stringEscapingIsWeird() throws Exception {
+    String expected = ""
+        + "--AaB03x\r\n"
+        + "Content-Disposition: form-data; name=\"field with spaces\"; filename=\"filename with spaces.txt\"\r\n"
+        + "Content-Type: text/plain; charset=utf-8\r\n"
+        + "Content-Length: 4\r\n"
+        + "\r\n"
+        + "okay\r\n"
+        + "--AaB03x\r\n"
+        + "Content-Disposition: form-data; name=\"field with %22\"\r\n"
+        + "Content-Length: 1\r\n"
+        + "\r\n"
+        + "\"\r\n"
+        + "--AaB03x\r\n"
+        + "Content-Disposition: form-data; name=\"field with %22\"\r\n"
+        + "Content-Length: 3\r\n"
+        + "\r\n"
+        + "%22\r\n"
+        + "--AaB03x\r\n"
+        + "Content-Disposition: form-data; name=\"field with \u0391\"\r\n"
+        + "Content-Length: 5\r\n"
+        + "\r\n"
+        + "Alpha\r\n"
+        + "--AaB03x--\r\n";
+
+    RequestBody requestBody = new MultipartBuilder("AaB03x")
+        .type(MultipartBuilder.FORM)
+        .addFormDataPart("field with spaces", "filename with spaces.txt",
+            RequestBody.create(MediaType.parse("text/plain; charset=utf-8"), "okay"))
+        .addFormDataPart("field with \"", "\"")
+        .addFormDataPart("field with %22", "%22")
+        .addFormDataPart("field with \u0391", "Alpha")
+        .build();
+
+    Buffer buffer = new Buffer();
+    requestBody.writeTo(buffer);
+    assertEquals(expected, buffer.readUtf8());
+  }
+
+  @Test public void streamingPartHasNoLength() throws Exception {
+    class StreamingBody extends RequestBody {
+      private final String body;
+
+      StreamingBody(String body) {
+        this.body = body;
+      }
+
+      @Override public MediaType contentType() {
+        return null;
+      }
+
+      @Override public void writeTo(BufferedSink sink) throws IOException {
+        sink.writeUtf8(body);
+      }
+    }
+
+    String expected = ""
+        + "--123\r\n"
+        + "Content-Length: 5\r\n"
+        + "\r\n"
+        + "Quick\r\n"
+        + "--123\r\n"
+        + "\r\n"
+        + "Brown\r\n"
+        + "--123\r\n"
+        + "Content-Length: 3\r\n"
+        + "\r\n"
+        + "Fox\r\n"
+        + "--123--\r\n";
+
+    RequestBody requestBody = new MultipartBuilder("123")
+        .addPart(RequestBody.create(null, "Quick"))
+        .addPart(new StreamingBody("Brown"))
+        .addPart(RequestBody.create(null, "Fox"))
+        .build();
+
+    assertEquals("multipart/mixed; boundary=123", requestBody.contentType().toString());
+
+    Buffer buffer = new Buffer();
+    requestBody.writeTo(buffer);
+    assertEquals(expected, buffer.readUtf8());
+    assertEquals(-1, requestBody.contentLength());
+  }
+
+  @Test public void contentTypeHeaderIsForbidden() throws Exception {
+    try {
+      new MultipartBuilder().addPart(
+          Headers.of("Content-Type", "text/plain"),
+          RequestBody.create(null, "Hello, World!"));
+      fail();
+    } catch (IllegalArgumentException expected) {
+    }
+  }
+
+  @Test public void contentLengthHeaderIsForbidden() throws Exception {
+    try {
+      new MultipartBuilder().addPart(
+          Headers.of("Content-Length", "13"),
+          RequestBody.create(null, "Hello, World!"));
+      fail();
+    } catch (IllegalArgumentException expected) {
+    }
+  }
+}
diff --git a/okhttp-tests/src/test/java/com/squareup/okhttp/OkHttpClientTest.java b/okhttp-tests/src/test/java/com/squareup/okhttp/OkHttpClientTest.java
new file mode 100644
index 0000000000..7ecd2a1ff1
--- /dev/null
+++ b/okhttp-tests/src/test/java/com/squareup/okhttp/OkHttpClientTest.java
@@ -0,0 +1,167 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.okhttp;
+
+import com.squareup.okhttp.internal.RecordingAuthenticator;
+import com.squareup.okhttp.internal.http.AuthenticatorAdapter;
+import com.squareup.okhttp.internal.http.RecordingProxySelector;
+import com.squareup.okhttp.internal.tls.OkHostnameVerifier;
+import java.io.IOException;
+import java.net.Authenticator;
+import java.net.CookieHandler;
+import java.net.CookieManager;
+import java.net.ProxySelector;
+import java.net.ResponseCache;
+import java.util.Arrays;
+import javax.net.SocketFactory;
+import org.junit.After;
+import org.junit.Test;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertNotNull;
+import static org.junit.Assert.assertNull;
+import static org.junit.Assert.assertSame;
+import static org.junit.Assert.assertTrue;
+
+public final class OkHttpClientTest {
+  private static final ProxySelector DEFAULT_PROXY_SELECTOR = ProxySelector.getDefault();
+  private static final CookieHandler DEFAULT_COOKIE_HANDLER = CookieManager.getDefault();
+  private static final ResponseCache DEFAULT_RESPONSE_CACHE = ResponseCache.getDefault();
+  private static final Authenticator DEFAULT_AUTHENTICATOR = null; // No Authenticator.getDefault().
+
+  @After public void tearDown() throws Exception {
+    ProxySelector.setDefault(DEFAULT_PROXY_SELECTOR);
+    CookieManager.setDefault(DEFAULT_COOKIE_HANDLER);
+    ResponseCache.setDefault(DEFAULT_RESPONSE_CACHE);
+    Authenticator.setDefault(DEFAULT_AUTHENTICATOR);
+  }
+
+  /** Confirm that {@code copyWithDefaults} gets expected constant values. */
+  @Test public void copyWithDefaultsWhenDefaultIsAConstant() throws Exception {
+    OkHttpClient client = new OkHttpClient().copyWithDefaults();
+    assertNull(client.internalCache());
+    assertEquals(0, client.getConnectTimeout());
+    assertEquals(0, client.getReadTimeout());
+    assertEquals(0, client.getWriteTimeout());
+    assertTrue(client.getFollowSslRedirects());
+    assertNull(client.getProxy());
+    assertEquals(Arrays.asList(Protocol.HTTP_2, Protocol.SPDY_3, Protocol.HTTP_1_1),
+        client.getProtocols());
+  }
+
+  /**
+   * Confirm that {@code copyWithDefaults} gets some default implementations
+   * from the core library.
+   */
+  @Test public void copyWithDefaultsWhenDefaultIsGlobal() throws Exception {
+    ProxySelector proxySelector = new RecordingProxySelector();
+    CookieManager cookieManager = new CookieManager();
+    Authenticator authenticator = new RecordingAuthenticator();
+    SocketFactory socketFactory = SocketFactory.getDefault(); // Global isn't configurable.
+    OkHostnameVerifier hostnameVerifier = OkHostnameVerifier.INSTANCE; // Global isn't configurable.
+
+    CookieManager.setDefault(cookieManager);
+    ProxySelector.setDefault(proxySelector);
+    Authenticator.setDefault(authenticator);
+
+    OkHttpClient client = new OkHttpClient().copyWithDefaults();
+
+    assertSame(proxySelector, client.getProxySelector());
+    assertSame(cookieManager, client.getCookieHandler());
+    assertSame(AuthenticatorAdapter.INSTANCE, client.getAuthenticator());
+    assertSame(socketFactory, client.getSocketFactory());
+    assertSame(hostnameVerifier, client.getHostnameVerifier());
+  }
+
+  /** There is no default cache. */
+  @Test public void copyWithDefaultsCacheIsNull() throws Exception {
+    OkHttpClient client = new OkHttpClient().copyWithDefaults();
+    assertNull(client.getCache());
+  }
+
+  @Test public void copyWithDefaultsDoesNotHonorGlobalResponseCache() throws Exception {
+    ResponseCache responseCache = new AbstractResponseCache();
+    ResponseCache.setDefault(responseCache);
+
+    OkHttpClient client = new OkHttpClient().copyWithDefaults();
+    assertNull(client.internalCache());
+  }
+
+  /**
+   * When copying the client, stateful things like the connection pool are
+   * shared across all clients.
+   */
+  @Test public void cloneSharesStatefulInstances() throws Exception {
+    OkHttpClient client = new OkHttpClient();
+
+    // Values should be non-null.
+    OkHttpClient a = client.clone().copyWithDefaults();
+    assertNotNull(a.routeDatabase());
+    assertNotNull(a.getDispatcher());
+    assertNotNull(a.getConnectionPool());
+    assertNotNull(a.getSslSocketFactory());
+
+    // Multiple clients share the instances.
+    OkHttpClient b = client.clone().copyWithDefaults();
+    assertSame(a.routeDatabase(), b.routeDatabase());
+    assertSame(a.getDispatcher(), b.getDispatcher());
+    assertSame(a.getConnectionPool(), b.getConnectionPool());
+    assertSame(a.getSslSocketFactory(), b.getSslSocketFactory());
+  }
+
+  /** We don't want to run user code inside of HttpEngine, etc. */
+  @Test public void copyWithDefaultsDoesNotReturnSubclass() throws Exception {
+    OkHttpClient subclass = new OkHttpClient() {};
+    OkHttpClient copy = subclass.copyWithDefaults();
+    assertEquals(OkHttpClient.class, copy.getClass());
+  }
+
+  @Test public void cloneReturnsSubclass() throws Exception {
+    OkHttpClient subclass = new OkHttpClient() {};
+    OkHttpClient clone = subclass.clone();
+    assertEquals(subclass.getClass(), clone.getClass());
+  }
+
+  /** Exercise a synchronous mocking case. */
+  @Test public void mock() throws Exception {
+    final Request request = new Request.Builder()
+        .url("http://example.com/")
+        .build();
+    final Response response = new Response.Builder()
+        .protocol(Protocol.HTTP_1_1)
+        .request(request)
+        .code(200)
+        .message("Alright")
+        .build();
+
+    OkHttpClient mockClient = new OkHttpClient() {
+      @Override public Call newCall(Request request) {
+        return new Call(this, request) {
+          @Override public Response execute() throws IOException {
+            return response;
+          }
+          @Override public void enqueue(Callback responseCallback) {
+          }
+          @Override public void cancel() {
+          }
+        };
+      }
+    };
+
+    Response actualResponse = mockClient.newCall(request).execute();
+    assertSame(response, actualResponse);
+  }
+}
diff --git a/okhttp-tests/src/test/java/com/squareup/okhttp/RecordedResponse.java b/okhttp-tests/src/test/java/com/squareup/okhttp/RecordedResponse.java
index 6628331a92..4140b3b2f4 100644
--- a/okhttp-tests/src/test/java/com/squareup/okhttp/RecordedResponse.java
+++ b/okhttp-tests/src/test/java/com/squareup/okhttp/RecordedResponse.java
@@ -15,14 +15,15 @@
  */
 package com.squareup.okhttp;
 
-import java.util.ArrayList;
+import java.io.IOException;
+import java.net.URL;
 import java.util.Arrays;
-import java.util.List;
 
 import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
 import static org.junit.Assert.assertNotNull;
 import static org.junit.Assert.assertNull;
-import static org.junit.Assert.fail;
+import static org.junit.Assert.assertTrue;
 
 /**
  * A received response or failure recorded by the response recorder.
@@ -31,29 +32,47 @@
   public final Request request;
   public final Response response;
   public final String body;
-  public final Failure failure;
+  public final IOException failure;
 
-  RecordedResponse(Request request, Response response, String body, Failure failure) {
+  RecordedResponse(Request request, Response response, String body, IOException failure) {
     this.request = request;
     this.response = response;
     this.body = body;
     this.failure = failure;
   }
 
+  public RecordedResponse assertRequestUrl(URL url) {
+    assertEquals(url, request.url());
+    return this;
+  }
+
+  public RecordedResponse assertRequestMethod(String method) {
+    assertEquals(method, request.method());
+    return this;
+  }
+
+  public RecordedResponse assertRequestHeader(String name, String... values) {
+    assertEquals(Arrays.asList(values), request.headers(name));
+    return this;
+  }
+
   public RecordedResponse assertCode(int expectedCode) {
     assertEquals(expectedCode, response.code());
     return this;
   }
 
-  public RecordedResponse assertContainsHeaders(String... expectedHeaders) {
-    List<String> actualHeaders = new ArrayList<String>();
-    Headers headers = response.headers();
-    for (int i = 0; i < headers.size(); i++) {
-      actualHeaders.add(headers.name(i) + ": " + headers.value(i));
-    }
-    if (!actualHeaders.containsAll(Arrays.asList(expectedHeaders))) {
-      fail("Expected: " + actualHeaders + "\nto contain: " + Arrays.toString(expectedHeaders));
-    }
+  public RecordedResponse assertSuccessful() {
+    assertTrue(response.isSuccessful());
+    return this;
+  }
+
+  public RecordedResponse assertNotSuccessful() {
+    assertFalse(response.isSuccessful());
+    return this;
+  }
+
+  public RecordedResponse assertHeader(String name, String... values) {
+    assertEquals(Arrays.asList(values), response.headers(name));
     return this;
   }
 
@@ -73,18 +92,52 @@ public RecordedResponse assertHandshake() {
   }
 
   /**
-   * Asserts that the current response was redirected and returns a new recorded
-   * response for the original request.
+   * Asserts that the current response was redirected and returns the prior
+   * response.
+   */
+  public RecordedResponse priorResponse() {
+    Response priorResponse = response.priorResponse();
+    assertNotNull(priorResponse);
+    assertNull(priorResponse.body());
+    return new RecordedResponse(priorResponse.request(), priorResponse, null, null);
+  }
+
+  /**
+   * Asserts that the current response used the network and returns the network
+   * response.
+   */
+  public RecordedResponse networkResponse() {
+    Response networkResponse = response.networkResponse();
+    assertNotNull(networkResponse);
+    assertNull(networkResponse.body());
+    return new RecordedResponse(networkResponse.request(), networkResponse, null, null);
+  }
+
+  /** Asserts that the current response didn't use the network. */
+  public RecordedResponse assertNoNetworkResponse() {
+    assertNull(response.networkResponse());
+    return this;
+  }
+
+  /** Asserts that the current response didn't use the cache. */
+  public RecordedResponse assertNoCacheResponse() {
+    assertNull(response.cacheResponse());
+    return this;
+  }
+
+  /**
+   * Asserts that the current response used the cache and returns the cache
+   * response.
    */
-  public RecordedResponse redirectedBy() {
-    Response redirectedBy = response.redirectedBy();
-    assertNotNull(redirectedBy);
-    assertNull(redirectedBy.body());
-    return new RecordedResponse(redirectedBy.request(), redirectedBy, null, null);
+  public RecordedResponse cacheResponse() {
+    Response cacheResponse = response.cacheResponse();
+    assertNotNull(cacheResponse);
+    assertNull(cacheResponse.body());
+    return new RecordedResponse(cacheResponse.request(), cacheResponse, null, null);
   }
 
   public void assertFailure(String message) {
     assertNotNull(failure);
-    assertEquals(message, failure.exception().getMessage());
+    assertEquals(message, failure.getMessage());
   }
 }
diff --git a/okhttp-tests/src/test/java/com/squareup/okhttp/RecordingReceiver.java b/okhttp-tests/src/test/java/com/squareup/okhttp/RecordingCallback.java
similarity index 61%
rename from okhttp-tests/src/test/java/com/squareup/okhttp/RecordingReceiver.java
rename to okhttp-tests/src/test/java/com/squareup/okhttp/RecordingCallback.java
index f5b54eede0..040c15652f 100644
--- a/okhttp-tests/src/test/java/com/squareup/okhttp/RecordingReceiver.java
+++ b/okhttp-tests/src/test/java/com/squareup/okhttp/RecordingCallback.java
@@ -15,55 +15,34 @@
  */
 package com.squareup.okhttp;
 
-import java.io.ByteArrayOutputStream;
 import java.io.IOException;
 import java.net.URL;
 import java.util.ArrayList;
-import java.util.LinkedHashMap;
+import java.util.Iterator;
 import java.util.List;
-import java.util.Map;
 import java.util.concurrent.TimeUnit;
+import okio.Buffer;
 
 /**
  * Records received HTTP responses so they can be later retrieved by tests.
  */
-public class RecordingReceiver implements Response.Receiver {
+public class RecordingCallback implements Callback {
   public static final long TIMEOUT_MILLIS = TimeUnit.SECONDS.toMillis(10);
 
-  private final Map<Response, ByteArrayOutputStream> inFlightResponses
-      = new LinkedHashMap<Response, ByteArrayOutputStream>();
-  private final List<RecordedResponse> responses = new ArrayList<RecordedResponse>();
+  private final List<RecordedResponse> responses = new ArrayList<>();
 
-  @Override public synchronized void onFailure(Failure failure) {
-    responses.add(new RecordedResponse(failure.request(), null, null, failure));
+  @Override public synchronized void onFailure(Request request, IOException e) {
+    responses.add(new RecordedResponse(request, null, null, e));
     notifyAll();
   }
 
-  @Override public synchronized boolean onResponse(Response response) throws IOException {
-    ByteArrayOutputStream out = inFlightResponses.get(response);
-    if (out == null) {
-      out = new ByteArrayOutputStream();
-      inFlightResponses.put(response, out);
-    }
-
-    byte[] buffer = new byte[1024];
-    Response.Body body = response.body();
-
-    while (body.ready()) {
-      int c = body.byteStream().read(buffer);
-
-      if (c == -1) {
-        inFlightResponses.remove(response);
-        responses.add(new RecordedResponse(
-            response.request(), response, out.toString("UTF-8"), null));
-        notifyAll();
-        return true;
-      }
-
-      out.write(buffer, 0, c);
-    }
+  @Override public synchronized void onResponse(Response response) throws IOException {
+    Buffer buffer = new Buffer();
+    ResponseBody body = response.body();
+    body.source().readAll(buffer);
 
-    return false;
+    responses.add(new RecordedResponse(response.request(), response, buffer.readUtf8(), null));
+    notifyAll();
   }
 
   /**
@@ -73,8 +52,10 @@
   public synchronized RecordedResponse await(URL url) throws Exception {
     long timeoutMillis = TimeUnit.NANOSECONDS.toMillis(System.nanoTime()) + TIMEOUT_MILLIS;
     while (true) {
-      for (RecordedResponse recordedResponse : responses) {
+      for (Iterator<RecordedResponse> i = responses.iterator(); i.hasNext(); ) {
+        RecordedResponse recordedResponse = i.next();
         if (recordedResponse.request.url().equals(url)) {
+          i.remove();
           return recordedResponse;
         }
       }
diff --git a/okhttp-tests/src/test/java/com/squareup/okhttp/RequestTest.java b/okhttp-tests/src/test/java/com/squareup/okhttp/RequestTest.java
index 08f304e3a4..00f1d05421 100644
--- a/okhttp-tests/src/test/java/com/squareup/okhttp/RequestTest.java
+++ b/okhttp-tests/src/test/java/com/squareup/okhttp/RequestTest.java
@@ -19,15 +19,19 @@
 import java.io.File;
 import java.io.FileWriter;
 import java.io.IOException;
-import okio.OkBuffer;
+import java.net.URI;
+import java.net.URL;
+
+import okio.Buffer;
 import org.junit.Test;
 
 import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertNull;
 
 public final class RequestTest {
   @Test public void string() throws Exception {
     MediaType contentType = MediaType.parse("text/plain; charset=utf-8");
-    Request.Body body = Request.Body.create(contentType, "abc".getBytes(Util.UTF_8));
+    RequestBody body = RequestBody.create(contentType, "abc".getBytes(Util.UTF_8));
     assertEquals(contentType, body.contentType());
     assertEquals(3, body.contentLength());
     assertEquals("616263", bodyToHex(body));
@@ -36,7 +40,7 @@
 
   @Test public void stringWithDefaultCharsetAdded() throws Exception {
     MediaType contentType = MediaType.parse("text/plain");
-    Request.Body body = Request.Body.create(contentType, "\u0800");
+    RequestBody body = RequestBody.create(contentType, "\u0800");
     assertEquals(MediaType.parse("text/plain; charset=utf-8"), body.contentType());
     assertEquals(3, body.contentLength());
     assertEquals("e0a080", bodyToHex(body));
@@ -44,7 +48,7 @@
 
   @Test public void stringWithNonDefaultCharsetSpecified() throws Exception {
     MediaType contentType = MediaType.parse("text/plain; charset=utf-16be");
-    Request.Body body = Request.Body.create(contentType, "\u0800");
+    RequestBody body = RequestBody.create(contentType, "\u0800");
     assertEquals(contentType, body.contentType());
     assertEquals(2, body.contentLength());
     assertEquals("0800", bodyToHex(body));
@@ -52,7 +56,7 @@
 
   @Test public void byteArray() throws Exception {
     MediaType contentType = MediaType.parse("text/plain");
-    Request.Body body = Request.Body.create(contentType, "abc".getBytes(Util.UTF_8));
+    RequestBody body = RequestBody.create(contentType, "abc".getBytes(Util.UTF_8));
     assertEquals(contentType, body.contentType());
     assertEquals(3, body.contentLength());
     assertEquals("616263", bodyToHex(body));
@@ -66,16 +70,52 @@
     writer.close();
 
     MediaType contentType = MediaType.parse("text/plain");
-    Request.Body body = Request.Body.create(contentType, file);
+    RequestBody body = RequestBody.create(contentType, file);
     assertEquals(contentType, body.contentType());
     assertEquals(3, body.contentLength());
     assertEquals("616263", bodyToHex(body));
     assertEquals("Retransmit body", "616263", bodyToHex(body));
   }
 
-  private String bodyToHex(Request.Body body) throws IOException {
-    OkBuffer buffer = new OkBuffer();
+  /** Common verbs used for apis such as GitHub, AWS, and Google Cloud. */
+  @Test public void crudVerbs() {
+    MediaType contentType = MediaType.parse("application/json");
+    RequestBody body = RequestBody.create(contentType, "{}");
+
+    Request get = new Request.Builder().url("http://localhost/api").get().build();
+    assertEquals("GET", get.method());
+    assertNull(get.body());
+
+    Request head = new Request.Builder().url("http://localhost/api").head().build();
+    assertEquals("HEAD", head.method());
+    assertNull(head.body());
+
+    Request delete = new Request.Builder().url("http://localhost/api").delete().build();
+    assertEquals("DELETE", delete.method());
+    assertNull(delete.body());
+
+    Request post = new Request.Builder().url("http://localhost/api").post(body).build();
+    assertEquals("POST", post.method());
+    assertEquals(body, post.body());
+
+    Request put = new Request.Builder().url("http://localhost/api").put(body).build();
+    assertEquals("PUT", put.method());
+    assertEquals(body, put.body());
+
+    Request patch = new Request.Builder().url("http://localhost/api").patch(body).build();
+    assertEquals("PATCH", patch.method());
+    assertEquals(body, patch.body());
+  }
+
+  @Test public void uninitializedURI() throws Exception {
+    Request request = new Request.Builder().url("http://localhost/api").build();
+    assertEquals(new URI("http://localhost/api"), request.uri());
+    assertEquals(new URL("http://localhost/api"), request.url());
+  }
+
+  private String bodyToHex(RequestBody body) throws IOException {
+    Buffer buffer = new Buffer();
     body.writeTo(buffer);
-    return buffer.readByteString(buffer.size()).hex();
+    return buffer.readByteString().hex();
   }
 }
diff --git a/okhttp-tests/src/test/java/com/squareup/okhttp/SyncApiTest.java b/okhttp-tests/src/test/java/com/squareup/okhttp/SyncApiTest.java
deleted file mode 100644
index ae3c7434f4..0000000000
--- a/okhttp-tests/src/test/java/com/squareup/okhttp/SyncApiTest.java
+++ /dev/null
@@ -1,268 +0,0 @@
-/*
- * Copyright (C) 2014 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.squareup.okhttp;
-
-import com.squareup.okhttp.internal.RecordingHostnameVerifier;
-import com.squareup.okhttp.internal.SslContextBuilder;
-import com.squareup.okhttp.mockwebserver.MockResponse;
-import com.squareup.okhttp.mockwebserver.MockWebServer;
-import com.squareup.okhttp.mockwebserver.RecordedRequest;
-import com.squareup.okhttp.mockwebserver.SocketPolicy;
-import java.io.File;
-import java.io.IOException;
-import java.net.HttpURLConnection;
-import java.util.UUID;
-import javax.net.ssl.SSLContext;
-import org.junit.After;
-import org.junit.Before;
-import org.junit.Test;
-
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertNull;
-import static org.junit.Assert.assertTrue;
-import static org.junit.Assert.fail;
-
-public final class SyncApiTest {
-  private MockWebServer server = new MockWebServer();
-  private OkHttpClient client = new OkHttpClient();
-
-  private static final SSLContext sslContext = SslContextBuilder.localhost();
-  private HttpResponseCache cache;
-
-  @Before public void setUp() throws Exception {
-    String tmp = System.getProperty("java.io.tmpdir");
-    File cacheDir = new File(tmp, "HttpCache-" + UUID.randomUUID());
-    cache = new HttpResponseCache(cacheDir, Integer.MAX_VALUE);
-  }
-
-  @After public void tearDown() throws Exception {
-    server.shutdown();
-    cache.delete();
-  }
-
-  @Test public void get() throws Exception {
-    server.enqueue(new MockResponse()
-        .setBody("abc")
-        .addHeader("Content-Type: text/plain"));
-    server.play();
-
-    Request request = new Request.Builder()
-        .url(server.getUrl("/"))
-        .header("User-Agent", "SyncApiTest")
-        .build();
-
-    onSuccess(request)
-        .assertCode(200)
-        .assertContainsHeaders("Content-Type: text/plain")
-        .assertBody("abc");
-
-    assertTrue(server.takeRequest().getHeaders().contains("User-Agent: SyncApiTest"));
-  }
-
-  @Test public void connectionPooling() throws Exception {
-    server.enqueue(new MockResponse().setBody("abc"));
-    server.enqueue(new MockResponse().setBody("def"));
-    server.enqueue(new MockResponse().setBody("ghi"));
-    server.play();
-
-    onSuccess(new Request.Builder().url(server.getUrl("/a")).build())
-        .assertBody("abc");
-
-    onSuccess(new Request.Builder().url(server.getUrl("/b")).build())
-        .assertBody("def");
-
-    onSuccess(new Request.Builder().url(server.getUrl("/c")).build())
-        .assertBody("ghi");
-
-    assertEquals(0, server.takeRequest().getSequenceNumber());
-    assertEquals(1, server.takeRequest().getSequenceNumber());
-    assertEquals(2, server.takeRequest().getSequenceNumber());
-  }
-
-  @Test public void tls() throws Exception {
-    server.useHttps(sslContext.getSocketFactory(), false);
-    server.enqueue(new MockResponse()
-        .setBody("abc")
-        .addHeader("Content-Type: text/plain"));
-    server.play();
-
-    client.setSslSocketFactory(sslContext.getSocketFactory());
-    client.setHostnameVerifier(new RecordingHostnameVerifier());
-
-    onSuccess(new Request.Builder().url(server.getUrl("/")).build())
-        .assertHandshake();
-  }
-
-  @Test public void recoverFromTlsHandshakeFailure() throws Exception {
-    server.useHttps(sslContext.getSocketFactory(), false);
-    server.enqueue(new MockResponse().setSocketPolicy(SocketPolicy.FAIL_HANDSHAKE));
-    server.enqueue(new MockResponse().setBody("abc"));
-    server.play();
-
-    client.setSslSocketFactory(sslContext.getSocketFactory());
-    client.setHostnameVerifier(new RecordingHostnameVerifier());
-
-    onSuccess(new Request.Builder().url(server.getUrl("/")).build())
-        .assertBody("abc");
-  }
-
-  @Test public void post() throws Exception {
-    server.enqueue(new MockResponse().setBody("abc"));
-    server.play();
-
-    Request request = new Request.Builder()
-        .url(server.getUrl("/"))
-        .post(Request.Body.create(MediaType.parse("text/plain"), "def"))
-        .build();
-
-    onSuccess(request)
-        .assertCode(200)
-        .assertBody("abc");
-
-    RecordedRequest recordedRequest = server.takeRequest();
-    assertEquals("def", recordedRequest.getUtf8Body());
-    assertEquals("3", recordedRequest.getHeader("Content-Length"));
-    assertEquals("text/plain; charset=utf-8", recordedRequest.getHeader("Content-Type"));
-  }
-
-  @Test public void cache() throws Exception {
-    server.enqueue(new MockResponse().setBody("A").addHeader("ETag: v1"));
-    server.enqueue(new MockResponse().setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
-    server.play();
-
-    client.setOkResponseCache(cache);
-
-    onSuccess(new Request.Builder().url(server.getUrl("/")).build())
-        .assertCode(200).assertBody("A");
-    assertNull(server.takeRequest().getHeader("If-None-Match"));
-
-    onSuccess(new Request.Builder().url(server.getUrl("/")).build())
-        .assertCode(200).assertBody("A");
-    assertEquals("v1", server.takeRequest().getHeader("If-None-Match"));
-  }
-
-  @Test public void redirect() throws Exception {
-    server.enqueue(new MockResponse()
-        .setResponseCode(301)
-        .addHeader("Location: /b")
-        .addHeader("Test", "Redirect from /a to /b")
-        .setBody("/a has moved!"));
-    server.enqueue(new MockResponse()
-        .setResponseCode(302)
-        .addHeader("Location: /c")
-        .addHeader("Test", "Redirect from /b to /c")
-        .setBody("/b has moved!"));
-    server.enqueue(new MockResponse().setBody("C"));
-    server.play();
-
-    onSuccess(new Request.Builder().url(server.getUrl("/a")).build())
-        .assertCode(200)
-        .assertBody("C")
-        .redirectedBy()
-        .assertCode(302)
-        .assertContainsHeaders("Test: Redirect from /b to /c")
-        .redirectedBy()
-        .assertCode(301)
-        .assertContainsHeaders("Test: Redirect from /a to /b");
-
-    assertEquals(0, server.takeRequest().getSequenceNumber()); // New connection.
-    assertEquals(1, server.takeRequest().getSequenceNumber()); // Connection reused.
-    assertEquals(2, server.takeRequest().getSequenceNumber()); // Connection reused again!
-  }
-
-  @Test public void redirectWithRedirectsDisabled() throws Exception {
-    client.setFollowProtocolRedirects(false);
-    server.enqueue(new MockResponse()
-        .setResponseCode(301)
-        .addHeader("Location: /b")
-        .addHeader("Test", "Redirect from /a to /b")
-        .setBody("/a has moved!"));
-    server.play();
-
-    onSuccess(new Request.Builder().url(server.getUrl("/a")).build())
-        .assertCode(301)
-        .assertBody("/a has moved!")
-        .assertContainsHeaders("Location: /b");
-  }
-
-  @Test public void follow20Redirects() throws Exception {
-    for (int i = 0; i < 20; i++) {
-      server.enqueue(new MockResponse()
-          .setResponseCode(301)
-          .addHeader("Location: /" + (i + 1))
-          .setBody("Redirecting to /" + (i + 1)));
-    }
-    server.enqueue(new MockResponse().setBody("Success!"));
-    server.play();
-
-    onSuccess(new Request.Builder().url(server.getUrl("/0")).build())
-        .assertCode(200)
-        .assertBody("Success!");
-  }
-
-  @Test public void doesNotFollow21Redirects() throws Exception {
-    for (int i = 0; i < 21; i++) {
-      server.enqueue(new MockResponse()
-          .setResponseCode(301)
-          .addHeader("Location: /" + (i + 1))
-          .setBody("Redirecting to /" + (i + 1)));
-    }
-    server.play();
-
-    try {
-      client.execute(new Request.Builder().url(server.getUrl("/0")).build());
-      fail();
-    } catch (IOException e) {
-      assertEquals("Too many redirects: 21", e.getMessage());
-    }
-  }
-
-  @Test public void postBodyRetransmittedOnRedirect() throws Exception {
-    server.enqueue(new MockResponse()
-        .setResponseCode(302)
-        .addHeader("Location: /b")
-        .setBody("Moved to /b !"));
-    server.enqueue(new MockResponse()
-        .setBody("This is b."));
-    server.play();
-
-    Request request = new Request.Builder()
-        .url(server.getUrl("/"))
-        .post(Request.Body.create(MediaType.parse("text/plain"), "body!"))
-        .build();
-
-    onSuccess(request)
-        .assertCode(200)
-        .assertBody("This is b.");
-
-    RecordedRequest request1 = server.takeRequest();
-    assertEquals("body!", request1.getUtf8Body());
-    assertEquals("5", request1.getHeader("Content-Length"));
-    assertEquals("text/plain; charset=utf-8", request1.getHeader("Content-Type"));
-    assertEquals(0, request1.getSequenceNumber());
-
-    RecordedRequest request2 = server.takeRequest();
-    assertEquals("body!", request2.getUtf8Body());
-    assertEquals("5", request2.getHeader("Content-Length"));
-    assertEquals("text/plain; charset=utf-8", request2.getHeader("Content-Type"));
-    assertEquals(1, request2.getSequenceNumber());
-  }
-
-  private RecordedResponse onSuccess(Request request) throws IOException {
-    Response response = client.execute(request);
-    return new RecordedResponse(request, response, response.body().string(), null);
-  }
-}
diff --git a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/BitArrayTest.java b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/BitArrayTest.java
deleted file mode 100644
index 7f80c3b949..0000000000
--- a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/BitArrayTest.java
+++ /dev/null
@@ -1,190 +0,0 @@
-/*
- * Copyright 2014 Square Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.squareup.okhttp.internal;
-
-import java.math.BigInteger;
-import org.junit.Test;
-
-import static java.util.Arrays.asList;
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertFalse;
-import static org.junit.Assert.assertTrue;
-import static org.junit.Assert.fail;
-
-public class BitArrayTest {
-
-  /** Lazy grow into a variable capacity bit set. */
-  @Test public void hpackUseCase() {
-    BitArray b = new BitArray.FixedCapacity();
-    for (int i = 0; i < 64; i++) {
-      b.set(i);
-    }
-    assertTrue(b.get(0));
-    assertTrue(b.get(1));
-    assertTrue(b.get(63));
-    try {
-      b.get(64);
-      fail();
-    } catch (IllegalArgumentException expected) {
-    }
-    b = ((BitArray.FixedCapacity) b).toVariableCapacity();
-    assertTrue(b.get(0));
-    assertTrue(b.get(1));
-    assertTrue(b.get(63));
-    assertFalse(b.get(64));
-    b.set(64);
-    assertTrue(b.get(64));
-  }
-
-  @Test public void setExpandsData_FixedCapacity() {
-    BitArray.FixedCapacity b = new BitArray.FixedCapacity();
-    b.set(63);
-    assertEquals(b.data, BigInteger.ZERO.setBit(63).longValue());
-  }
-
-  @Test public void toggleBit_FixedCapacity() {
-    BitArray.FixedCapacity b = new BitArray.FixedCapacity();
-    b.set(63);
-    b.toggle(63);
-    assertEquals(b.data, 0l);
-    b.toggle(1);
-    assertEquals(b.data, 2l);
-  }
-
-  @Test public void shiftLeft_FixedCapacity() {
-    BitArray.FixedCapacity b = new BitArray.FixedCapacity();
-    b.set(0);
-    b.shiftLeft(1);
-    assertEquals(b.data, 2l);
-  }
-
-  @Test public void multipleShifts_FixedCapacity() {
-    BitArray.FixedCapacity b = new BitArray.FixedCapacity();
-    b.set(10);
-    b.shiftLeft(2);
-    b.shiftLeft(2);
-    assertEquals(b.data, BigInteger.ZERO.setBit(10).shiftLeft(2).shiftLeft(2).longValue());
-  }
-
-  @Test public void clearBits_FixedCapacity() {
-    BitArray.FixedCapacity b = new BitArray.FixedCapacity();
-    b.set(1);
-    b.set(3);
-    b.set(5);
-    b.clear();
-    assertEquals(b.data, 0l);
-  }
-
-  @Test public void setExpandsData_VariableCapacity() {
-    BitArray.VariableCapacity b = new BitArray.VariableCapacity();
-    b.set(64);
-    assertEquals(asList(64), b.toIntegerList());
-  }
-
-  @Test public void toggleBit_VariableCapacity() {
-    BitArray.VariableCapacity b = new BitArray.VariableCapacity();
-    b.set(100);
-    b.toggle(100);
-    assertTrue(b.toIntegerList().isEmpty());
-    b.toggle(1);
-    assertEquals(asList(1), b.toIntegerList());
-  }
-
-  @Test public void shiftLeftExpandsData_VariableCapacity() {
-    BitArray.VariableCapacity b = new BitArray.VariableCapacity();
-    b.set(0);
-    b.shiftLeft(64);
-    assertEquals(asList(64), b.toIntegerList());
-  }
-
-  @Test public void shiftLeftFromZero_VariableCapacity() {
-    BitArray.VariableCapacity b = new BitArray.VariableCapacity();
-    b.set(0);
-    b.shiftLeft(1);
-    assertEquals(asList(1), b.toIntegerList());
-  }
-
-  @Test public void shiftLeftAcrossOffset_VariableCapacity() {
-    BitArray.VariableCapacity b = new BitArray.VariableCapacity();
-    b.set(63);
-    assertEquals(1, b.data.length);
-    b.shiftLeft(1);
-    assertEquals(asList(64), b.toIntegerList());
-    assertEquals(2, b.data.length);
-  }
-
-  @Test public void multipleShiftsLeftAcrossOffset_VariableCapacity() {
-    BitArray.VariableCapacity b = new BitArray.VariableCapacity();
-    b.set(1000);
-    b.shiftLeft(67);
-    assertEquals(asList(1067), b.toIntegerList());
-    b.shiftLeft(69);
-    assertEquals(asList(1136), b.toIntegerList());
-  }
-
-  @Test public void clearBits_VariableCapacity() {
-    BitArray.VariableCapacity b = new BitArray.VariableCapacity();
-    b.set(10);
-    b.set(100);
-    b.set(1000);
-    b.clear();
-    assertTrue(b.toIntegerList().isEmpty());
-  }
-
-  @Test public void bigIntegerSanityCheck_VariableCapacity() {
-    BitArray a = new BitArray.VariableCapacity();
-    BigInteger b = BigInteger.ZERO;
-
-    a.set(64);
-    b = b.setBit(64);
-    assertEquals(bigIntegerToString(b), a.toString());
-
-    a.set(1000000);
-    b = b.setBit(1000000);
-    assertEquals(bigIntegerToString(b), a.toString());
-
-    a.shiftLeft(100);
-    b = b.shiftLeft(100);
-    assertEquals(bigIntegerToString(b), a.toString());
-
-    a.set(0xF00D);
-    b = b.setBit(0xF00D);
-    a.set(0xBEEF);
-    b = b.setBit(0xBEEF);
-    a.set(0xDEAD);
-    b = b.setBit(0xDEAD);
-    assertEquals(bigIntegerToString(b), a.toString());
-
-    a.shiftLeft(0xB0B);
-    b = b.shiftLeft(0xB0B);
-    assertEquals(bigIntegerToString(b), a.toString());
-
-    a.toggle(64280);
-    b = b.clearBit(64280);
-    assertEquals(bigIntegerToString(b), a.toString());
-  }
-
-  private static String bigIntegerToString(BigInteger b) {
-    StringBuilder builder = new StringBuilder("{");
-    for (int i = 0, count = b.bitLength(); i < count; i++) {
-      if (b.testBit(i)) {
-        builder.append(i).append(',');
-      }
-    }
-    builder.setCharAt(builder.length() - 1, '}');
-    return builder.toString();
-  }
-}
diff --git a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/RecordingAuthenticator.java b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/RecordingAuthenticator.java
index 9eff91919a..292875bff6 100644
--- a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/RecordingAuthenticator.java
+++ b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/RecordingAuthenticator.java
@@ -24,7 +24,7 @@
   /** base64("username:password") */
   public static final String BASE_64_CREDENTIALS = "dXNlcm5hbWU6cGFzc3dvcmQ=";
 
-  public final List<String> calls = new ArrayList<String>();
+  public final List<String> calls = new ArrayList<>();
   public final PasswordAuthentication authentication;
 
   public RecordingAuthenticator(PasswordAuthentication authentication) {
@@ -36,23 +36,14 @@ public RecordingAuthenticator() {
   }
 
   @Override protected PasswordAuthentication getPasswordAuthentication() {
-    this.calls
-        .add("host="
-            + getRequestingHost()
-            + " port="
-            + getRequestingPort()
-            + " site="
-            + getRequestingSite()
-            + " url="
-            + getRequestingURL()
-            + " type="
-            + getRequestorType()
-            + " prompt="
-            + getRequestingPrompt()
-            + " protocol="
-            + getRequestingProtocol()
-            + " scheme="
-            + getRequestingScheme());
+    this.calls.add("host=" + getRequestingHost()
+        + " port=" + getRequestingPort()
+        + " site=" + getRequestingSite().getHostName()
+        + " url=" + getRequestingURL()
+        + " type=" + getRequestorType()
+        + " prompt=" + getRequestingPrompt()
+        + " protocol=" + getRequestingProtocol()
+        + " scheme=" + getRequestingScheme());
     return authentication;
   }
 }
diff --git a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/RecordingHostnameVerifier.java b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/RecordingHostnameVerifier.java
index b3e2369b79..c9d914f5f2 100644
--- a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/RecordingHostnameVerifier.java
+++ b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/RecordingHostnameVerifier.java
@@ -21,7 +21,7 @@
 import javax.net.ssl.SSLSession;
 
 public final class RecordingHostnameVerifier implements HostnameVerifier {
-  public final List<String> calls = new ArrayList<String>();
+  public final List<String> calls = new ArrayList<>();
 
   public boolean verify(String hostname, SSLSession session) {
     calls.add("verify " + hostname);
diff --git a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/RecordingOkAuthenticator.java b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/RecordingOkAuthenticator.java
index 636acbde11..f5b3617d9d 100644
--- a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/RecordingOkAuthenticator.java
+++ b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/RecordingOkAuthenticator.java
@@ -15,36 +15,45 @@
  */
 package com.squareup.okhttp.internal;
 
-import com.squareup.okhttp.OkAuthenticator;
-import java.io.IOException;
+import com.squareup.okhttp.Authenticator;
+import com.squareup.okhttp.Request;
+import com.squareup.okhttp.Response;
 import java.net.Proxy;
-import java.net.URL;
 import java.util.ArrayList;
 import java.util.List;
 
-public final class RecordingOkAuthenticator implements OkAuthenticator {
-  public final List<String> calls = new ArrayList<String>();
-  public final Credential credential;
+public final class RecordingOkAuthenticator implements Authenticator {
+  public final List<Response> responses = new ArrayList<>();
+  public final List<Proxy> proxies = new ArrayList<>();
+  public final String credential;
 
-  public RecordingOkAuthenticator(Credential credential) {
+  public RecordingOkAuthenticator(String credential) {
     this.credential = credential;
   }
 
-  @Override public Credential authenticate(Proxy proxy, URL url, List<Challenge> challenges)
-      throws IOException {
-    calls.add("authenticate"
-        + " proxy=" + proxy.type()
-        + " url=" + url
-        + " challenges=" + challenges);
-    return credential;
+  public Response onlyResponse() {
+    if (responses.size() != 1) throw new IllegalStateException();
+    return responses.get(0);
   }
 
-  @Override public Credential authenticateProxy(Proxy proxy, URL url, List<Challenge> challenges)
-      throws IOException {
-    calls.add("authenticateProxy"
-        + " proxy=" + proxy.type()
-        + " url=" + url
-        + " challenges=" + challenges);
-    return credential;
+  public Proxy onlyProxy() {
+    if (proxies.size() != 1) throw new IllegalStateException();
+    return proxies.get(0);
+  }
+
+  @Override public Request authenticate(Proxy proxy, Response response) {
+    responses.add(response);
+    proxies.add(proxy);
+    return response.request().newBuilder()
+        .addHeader("Authorization", credential)
+        .build();
+  }
+
+  @Override public Request authenticateProxy(Proxy proxy, Response response) {
+    responses.add(response);
+    proxies.add(proxy);
+    return response.request().newBuilder()
+        .addHeader("Proxy-Authorization", credential)
+        .build();
   }
 }
diff --git a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/CookiesTest.java b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/CookiesTest.java
index a44e6839f8..a738cde082 100644
--- a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/CookiesTest.java
+++ b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/CookiesTest.java
@@ -17,14 +17,10 @@
 package com.squareup.okhttp.internal.http;
 
 import com.squareup.okhttp.OkHttpClient;
+import com.squareup.okhttp.OkUrlFactory;
 import com.squareup.okhttp.mockwebserver.MockResponse;
 import com.squareup.okhttp.mockwebserver.MockWebServer;
 import com.squareup.okhttp.mockwebserver.RecordedRequest;
-
-import org.junit.After;
-import org.junit.Before;
-import org.junit.Test;
-
 import java.io.IOException;
 import java.net.CookieHandler;
 import java.net.CookieManager;
@@ -37,6 +33,9 @@
 import java.util.HashMap;
 import java.util.List;
 import java.util.Map;
+import org.junit.After;
+import org.junit.Before;
+import org.junit.Test;
 
 import static java.net.CookiePolicy.ACCEPT_ORIGINAL_SERVER;
 import static org.junit.Assert.assertEquals;
@@ -81,7 +80,7 @@ public void testNetscapeResponse() throws Exception {
     assertEquals(null, cookie.getComment());
     assertEquals(null, cookie.getCommentURL());
     assertEquals(false, cookie.getDiscard());
-    assertEquals(server.getCookieDomain(), cookie.getDomain());
+    assertTrue(server.getCookieDomain().equalsIgnoreCase(cookie.getDomain()));
     assertTrue(cookie.getMaxAge() > 100000000000L);
     assertEquals("/path", cookie.getPath());
     assertEquals(true, cookie.getSecure());
@@ -111,7 +110,7 @@ public void testNetscapeResponse() throws Exception {
     assertEquals("this cookie is delicious", cookie.getComment());
     assertEquals(null, cookie.getCommentURL());
     assertEquals(false, cookie.getDiscard());
-    assertEquals(server.getCookieDomain(), cookie.getDomain());
+    assertTrue(server.getCookieDomain().equalsIgnoreCase(cookie.getDomain()));
     assertEquals(60, cookie.getMaxAge());
     assertEquals("/path", cookie.getPath());
     assertEquals(true, cookie.getSecure());
@@ -144,7 +143,7 @@ public void testNetscapeResponse() throws Exception {
     assertEquals("this cookie is delicious", cookie.getComment());
     assertEquals("http://google.com/", cookie.getCommentURL());
     assertEquals(true, cookie.getDiscard());
-    assertEquals(server.getCookieDomain(), cookie.getDomain());
+    assertTrue(server.getCookieDomain().equalsIgnoreCase(cookie.getDomain()));
     assertEquals(60, cookie.getMaxAge());
     assertEquals("/path", cookie.getPath());
     assertEquals("80,443," + server.getPort(), cookie.getPortlist());
@@ -178,7 +177,7 @@ public void testNetscapeResponse() throws Exception {
     assertEquals("this cookie is delicious", cookie.getComment());
     assertEquals("http://google.com/", cookie.getCommentURL());
     assertEquals(true, cookie.getDiscard());
-    assertEquals(server.getCookieDomain(), cookie.getDomain());
+    assertTrue(server.getCookieDomain().equalsIgnoreCase(cookie.getDomain()));
     assertEquals(60, cookie.getMaxAge());
     assertEquals("/path", cookie.getPath());
     assertEquals("80,443," + server.getPort(), cookie.getPortlist());
@@ -253,13 +252,13 @@ public void testNetscapeResponse() throws Exception {
    * getRequestProperties}.
    */
   @Test public void testHeadersSentToCookieHandler() throws IOException, InterruptedException {
-    final Map<String, List<String>> cookieHandlerHeaders = new HashMap<String, List<String>>();
+    final Map<String, List<String>> cookieHandlerHeaders = new HashMap<>();
     CookieHandler.setDefault(new CookieManager() {
       @Override
       public Map<String, List<String>> get(URI uri,
           Map<String, List<String>> requestHeaders) throws IOException {
         cookieHandlerHeaders.putAll(requestHeaders);
-        Map<String, List<String>> result = new HashMap<String, List<String>>();
+        Map<String, List<String>> result = new HashMap<>();
         result.put("Cookie", Collections.singletonList("Bar=bar"));
         result.put("Cookie2", Collections.singletonList("Baz=baz"));
         result.put("Quux", Collections.singletonList("quux"));
@@ -270,7 +269,7 @@ public void testNetscapeResponse() throws Exception {
     server.enqueue(new MockResponse());
     server.play();
 
-    HttpURLConnection connection = client.open(server.getUrl("/"));
+    HttpURLConnection connection = new OkUrlFactory(client).open(server.getUrl("/"));
     assertEquals(Collections.<String, List<String>>emptyMap(),
         connection.getRequestProperties());
 
@@ -309,7 +308,7 @@ public void testNetscapeResponse() throws Exception {
     CookieHandler.setDefault(new CookieManager() {
       @Override public Map<String, List<String>> get(URI uri,
           Map<String, List<String>> requestHeaders) throws IOException {
-        Map<String, List<String>> result = new HashMap<String, List<String>>();
+        Map<String, List<String>> result = new HashMap<>();
         result.put("COOKIE", Collections.singletonList("Bar=bar"));
         result.put("cooKIE2", Collections.singletonList("Baz=baz"));
         return result;
@@ -342,7 +341,7 @@ private void assertContainsAll(Collection<String> collection, String... toFind)
   }
 
   private Map<String,List<String>> get(MockWebServer server, String path) throws Exception {
-    URLConnection connection = client.open(server.getUrl(path));
+    URLConnection connection = new OkUrlFactory(client).open(server.getUrl(path));
     Map<String, List<String>> headers = connection.getHeaderFields();
     connection.getInputStream().close();
     return headers;
diff --git a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/DisconnectTest.java b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/DisconnectTest.java
new file mode 100644
index 0000000000..345211fefb
--- /dev/null
+++ b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/DisconnectTest.java
@@ -0,0 +1,97 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.okhttp.internal.http;
+
+import com.squareup.okhttp.OkHttpClient;
+import com.squareup.okhttp.OkUrlFactory;
+import com.squareup.okhttp.mockwebserver.MockResponse;
+import com.squareup.okhttp.mockwebserver.MockWebServer;
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.OutputStream;
+import java.net.HttpURLConnection;
+import java.util.concurrent.TimeUnit;
+import org.junit.Test;
+
+import static org.junit.Assert.fail;
+
+public final class DisconnectTest {
+  private final MockWebServer server = new MockWebServer();
+  private final OkHttpClient client = new OkHttpClient();
+
+  @Test public void interruptWritingRequestBody() throws Exception {
+    int requestBodySize = 2 * 1024 * 1024; // 2 MiB
+
+    server.enqueue(new MockResponse()
+        .throttleBody(64 * 1024, 125, TimeUnit.MILLISECONDS)); // 500 Kbps
+    server.play();
+
+    HttpURLConnection connection = new OkUrlFactory(client).open(server.getUrl("/"));
+    disconnectLater(connection, 500);
+
+    connection.setDoOutput(true);
+    connection.setFixedLengthStreamingMode(requestBodySize);
+    OutputStream requestBody = connection.getOutputStream();
+    byte[] buffer = new byte[1024];
+    try {
+      for (int i = 0; i < requestBodySize; i += buffer.length) {
+        requestBody.write(buffer);
+        requestBody.flush();
+      }
+      fail("Expected connection to be closed");
+    } catch (IOException expected) {
+    }
+
+    connection.disconnect();
+  }
+
+  @Test public void interruptReadingResponseBody() throws Exception {
+    int responseBodySize = 2 * 1024 * 1024; // 2 MiB
+
+    server.enqueue(new MockResponse()
+        .setBody(new byte[responseBodySize])
+        .throttleBody(64 * 1024, 125, TimeUnit.MILLISECONDS)); // 500 Kbps
+    server.play();
+
+    HttpURLConnection connection = new OkUrlFactory(client).open(server.getUrl("/"));
+    disconnectLater(connection, 500);
+
+    InputStream responseBody = connection.getInputStream();
+    byte[] buffer = new byte[1024];
+    try {
+      while (responseBody.read(buffer) != -1) {
+      }
+      fail("Expected connection to be closed");
+    } catch (IOException expected) {
+    }
+
+    connection.disconnect();
+  }
+
+  private void disconnectLater(final HttpURLConnection connection, final int delayMillis) {
+    Thread interruptingCow = new Thread() {
+      @Override public void run() {
+        try {
+          sleep(delayMillis);
+          connection.disconnect();
+        } catch (InterruptedException e) {
+          throw new RuntimeException(e);
+        }
+      }
+    };
+    interruptingCow.start();
+  }
+}
diff --git a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/ExternalHttp2Example.java b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/ExternalHttp2Example.java
index 1c5198c696..a9d097fe91 100644
--- a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/ExternalHttp2Example.java
+++ b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/ExternalHttp2Example.java
@@ -17,7 +17,9 @@
 package com.squareup.okhttp.internal.http;
 
 import com.squareup.okhttp.OkHttpClient;
+import com.squareup.okhttp.OkUrlFactory;
 import com.squareup.okhttp.Protocol;
+import com.squareup.okhttp.internal.Util;
 import java.io.BufferedReader;
 import java.io.InputStreamReader;
 import java.net.URL;
@@ -30,9 +32,11 @@
 
 public final class ExternalHttp2Example {
   public static void main(String[] args) throws Exception {
-    URL url = new URL("https://http2.iijplus.jp/push/test1");
-    HttpsURLConnection connection = (HttpsURLConnection) new OkHttpClient()
-        .setProtocols(Protocol.HTTP2_AND_HTTP_11).open(url);
+    URL url = new URL("https://twitter.com");
+    OkHttpClient client = new OkHttpClient()
+        .setProtocols(Util.immutableList(Protocol.HTTP_2, Protocol.HTTP_1_1));
+    HttpsURLConnection connection = (HttpsURLConnection) new OkUrlFactory(client)
+        .open(url);
 
     connection.setHostnameVerifier(new HostnameVerifier() {
       @Override public boolean verify(String s, SSLSession sslSession) {
diff --git a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/ExternalSpdyExample.java b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/ExternalSpdyExample.java
index dab90c138f..7237583237 100644
--- a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/ExternalSpdyExample.java
+++ b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/ExternalSpdyExample.java
@@ -17,7 +17,9 @@
 package com.squareup.okhttp.internal.http;
 
 import com.squareup.okhttp.OkHttpClient;
+import com.squareup.okhttp.OkUrlFactory;
 import com.squareup.okhttp.Protocol;
+import com.squareup.okhttp.internal.Util;
 import java.io.BufferedReader;
 import java.io.InputStreamReader;
 import java.net.URL;
@@ -31,8 +33,10 @@
 public final class ExternalSpdyExample {
   public static void main(String[] args) throws Exception {
     URL url = new URL("https://www.google.ca/");
-    HttpsURLConnection connection = (HttpsURLConnection) new OkHttpClient()
-        .setProtocols(Protocol.SPDY3_AND_HTTP11).open(url);
+    OkHttpClient client = new OkHttpClient()
+        .setProtocols(Util.immutableList(Protocol.SPDY_3, Protocol.HTTP_1_1));
+    HttpsURLConnection connection = (HttpsURLConnection) new OkUrlFactory(client)
+        .open(url);
 
     connection.setHostnameVerifier(new HostnameVerifier() {
       @Override public boolean verify(String s, SSLSession sslSession) {
diff --git a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/HeadersTest.java b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/HeadersTest.java
index 80db747041..144ec78f46 100644
--- a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/HeadersTest.java
+++ b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/HeadersTest.java
@@ -27,6 +27,7 @@
 import static com.squareup.okhttp.internal.Util.headerEntries;
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertNull;
+import static org.junit.Assert.fail;
 
 public final class HeadersTest {
   @Test public void parseNameValueBlock() throws IOException {
@@ -40,12 +41,14 @@
         SpdyTransport.readNameValueBlock(headerBlock, Protocol.SPDY_3).request(request).build();
     Headers headers = response.headers();
     assertEquals(4, headers.size());
-    assertEquals("HTTP/1.1 200 OK", response.statusLine());
+    assertEquals(Protocol.SPDY_3, response.protocol());
+    assertEquals(200, response.code());
+    assertEquals("OK", response.message());
     assertEquals("no-cache, no-store", headers.get("cache-control"));
     assertEquals("Cookie2", headers.get("set-cookie"));
-    assertEquals(Protocol.SPDY_3.name.utf8(), headers.get(OkHeaders.SELECTED_PROTOCOL));
+    assertEquals(Protocol.SPDY_3.toString(), headers.get(OkHeaders.SELECTED_PROTOCOL));
     assertEquals(OkHeaders.SELECTED_PROTOCOL, headers.name(0));
-    assertEquals(Protocol.SPDY_3.name.utf8(), headers.value(0));
+    assertEquals(Protocol.SPDY_3.toString(), headers.value(0));
     assertEquals("cache-control", headers.name(1));
     assertEquals("no-cache, no-store", headers.value(1));
     assertEquals("set-cookie", headers.name(2));
@@ -67,7 +70,7 @@
     Headers headers = response.headers();
     assertEquals(1, headers.size());
     assertEquals(OkHeaders.SELECTED_PROTOCOL, headers.name(0));
-    assertEquals(Protocol.SPDY_3.name.utf8(), headers.value(0));
+    assertEquals(Protocol.SPDY_3.toString(), headers.value(0));
   }
 
   @Test public void readNameValueBlockDropsForbiddenHeadersHttp2() throws IOException {
@@ -81,7 +84,7 @@
     Headers headers = response.headers();
     assertEquals(1, headers.size());
     assertEquals(OkHeaders.SELECTED_PROTOCOL, headers.name(0));
-    assertEquals(Protocol.HTTP_2.name.utf8(), headers.value(0));
+    assertEquals(Protocol.HTTP_2.toString(), headers.value(0));
   }
 
   @Test public void toNameValueBlock() {
@@ -135,4 +138,57 @@
     assertEquals(expected,
         SpdyTransport.writeNameValueBlock(request, Protocol.HTTP_2, "HTTP/1.1"));
   }
+
+  @Test public void ofTrims() {
+    Headers headers = Headers.of("\t User-Agent \n", " \r OkHttp ");
+    assertEquals("User-Agent", headers.name(0));
+    assertEquals("OkHttp", headers.value(0));
+  }
+
+  @Test public void ofThrowsOddNumberOfHeaders() {
+    try {
+      Headers.of("User-Agent", "OkHttp", "Content-Length");
+      fail();
+    } catch (IllegalArgumentException expected) {
+    }
+  }
+
+  @Test public void ofThrowsOnNull() {
+    try {
+      Headers.of("User-Agent", null);
+      fail();
+    } catch (IllegalArgumentException expected) {
+    }
+  }
+
+  @Test public void ofThrowsOnEmptyName() {
+    try {
+      Headers.of("", "OkHttp");
+      fail();
+    } catch (IllegalArgumentException expected) {
+    }
+  }
+
+  @Test public void ofAcceptsEmptyValue() {
+    Headers headers = Headers.of("User-Agent", "");
+    assertEquals("", headers.value(0));
+  }
+
+  @Test public void ofMakesDefensiveCopy() {
+    String[] namesAndValues = {
+        "User-Agent",
+        "OkHttp"
+    };
+    Headers headers = Headers.of(namesAndValues);
+    namesAndValues[1] = "Chrome";
+    assertEquals("OkHttp", headers.value(0));
+  }
+
+  @Test public void ofRejectsNulChar() {
+    try {
+      Headers.of("User-Agent", "Square\u0000OkHttp");
+      fail();
+    } catch (IllegalArgumentException expected) {
+    }
+  }
 }
diff --git a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/HttpDateTest.java b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/HttpDateTest.java
new file mode 100644
index 0000000000..2181774f43
--- /dev/null
+++ b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/HttpDateTest.java
@@ -0,0 +1,91 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.okhttp.internal.http;
+
+import org.junit.After;
+import org.junit.Before;
+import org.junit.Test;
+
+import java.util.Date;
+import java.util.TimeZone;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertNull;
+
+public class HttpDateTest {
+
+  private TimeZone originalDefault;
+
+  @Before
+  public void setUp() throws Exception {
+    originalDefault = TimeZone.getDefault();
+    // The default timezone should affect none of these tests: HTTP specified GMT, so we set it to
+    // something else.
+    TimeZone.setDefault(TimeZone.getTimeZone("America/Los_Angeles"));
+  }
+
+  @After
+  public void tearDown() throws Exception {
+    TimeZone.setDefault(originalDefault);
+  }
+
+  @Test public void parseStandardFormats() throws Exception {
+    // RFC 822, updated by RFC 1123 with GMT.
+    assertEquals(0L, HttpDate.parse("Thu, 01 Jan 1970 00:00:00 GMT").getTime());
+    assertEquals(1402057830000L, HttpDate.parse("Fri, 06 Jun 2014 12:30:30 GMT").getTime());
+
+    // RFC 850, obsoleted by RFC 1036 with GMT.
+    assertEquals(0L, HttpDate.parse("Thursday, 01-Jan-70 00:00:00 GMT").getTime());
+    assertEquals(1402057830000L, HttpDate.parse("Friday, 06-Jun-14 12:30:30 GMT").getTime());
+
+    // ANSI C's asctime(): should use GMT, not platform default.
+    assertEquals(0L, HttpDate.parse("Thu Jan 1 00:00:00 1970").getTime());
+    assertEquals(1402057830000L, HttpDate.parse("Fri Jun 6 12:30:30 2014").getTime());
+  }
+
+  @Test public void format() throws Exception {
+    assertEquals("Thu, 01 Jan 1970 00:00:00 GMT", HttpDate.format(new Date(0)));
+    assertEquals("Fri, 06 Jun 2014 12:30:30 GMT", HttpDate.format(new Date(1402057830000L)));
+  }
+
+  @Test public void parseNonStandardStrings() throws Exception {
+    // RFC 822, updated by RFC 1123 with any TZ
+    assertEquals(3600000L, HttpDate.parse("Thu, 01 Jan 1970 00:00:00 GMT-01:00").getTime());
+    assertEquals(28800000L, HttpDate.parse("Thu, 01 Jan 1970 00:00:00 PST").getTime());
+    // Ignore trailing junk
+    assertEquals(0L, HttpDate.parse("Thu, 01 Jan 1970 00:00:00 GMT JUNK").getTime());
+    // Missing timezones treated as bad.
+    assertNull(HttpDate.parse("Thu, 01 Jan 1970 00:00:00"));
+    // Missing seconds treated as bad.
+    assertNull(HttpDate.parse("Thu, 01 Jan 1970 00:00 GMT"));
+    // Extra spaces treated as bad.
+    assertNull(HttpDate.parse("Thu,  01 Jan 1970 00:00 GMT"));
+    // Missing leading zero treated as bad.
+    assertNull(HttpDate.parse("Thu, 1 Jan 1970 00:00 GMT"));
+
+    // RFC 850, obsoleted by RFC 1036 with any TZ.
+    assertEquals(3600000L, HttpDate.parse("Thursday, 01-Jan-1970 00:00:00 GMT-01:00").getTime());
+    assertEquals(28800000L, HttpDate.parse("Thursday, 01-Jan-1970 00:00:00 PST").getTime());
+    // Ignore trailing junk
+    assertEquals(28800000L, HttpDate.parse("Thursday, 01-Jan-1970 00:00:00 PST JUNK").getTime());
+
+    // ANSI C's asctime() format
+    // This format ignores the timezone entirely even if it is present and uses GMT.
+    assertEquals(1402057830000L, HttpDate.parse("Fri Jun 6 12:30:30 2014 PST").getTime());
+    // Ignore trailing junk.
+    assertEquals(1402057830000L, HttpDate.parse("Fri Jun 6 12:30:30 2014 JUNK").getTime());
+  }
+}
diff --git a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/HttpOverHttp20Draft09Test.java b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/HttpOverHttp20Draft14Test.java
similarity index 96%
rename from okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/HttpOverHttp20Draft09Test.java
rename to okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/HttpOverHttp20Draft14Test.java
index 851a9c1f96..261fb30f3b 100644
--- a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/HttpOverHttp20Draft09Test.java
+++ b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/HttpOverHttp20Draft14Test.java
@@ -24,9 +24,9 @@
 
 import static org.junit.Assert.assertEquals;
 
-public class HttpOverHttp20Draft09Test extends HttpOverSpdyTest {
+public class HttpOverHttp20Draft14Test extends HttpOverSpdyTest {
 
-  public HttpOverHttp20Draft09Test() {
+  public HttpOverHttp20Draft14Test() {
     super(Protocol.HTTP_2);
     this.hostHeader = ":authority";
   }
diff --git a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/HttpOverSpdyTest.java b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/HttpOverSpdyTest.java
index c725a751a3..f65d141bca 100644
--- a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/HttpOverSpdyTest.java
+++ b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/HttpOverSpdyTest.java
@@ -15,8 +15,9 @@
  */
 package com.squareup.okhttp.internal.http;
 
-import com.squareup.okhttp.HttpResponseCache;
+import com.squareup.okhttp.Cache;
 import com.squareup.okhttp.OkHttpClient;
+import com.squareup.okhttp.OkUrlFactory;
 import com.squareup.okhttp.Protocol;
 import com.squareup.okhttp.internal.RecordingAuthenticator;
 import com.squareup.okhttp.internal.SslContextBuilder;
@@ -25,11 +26,9 @@
 import com.squareup.okhttp.mockwebserver.MockWebServer;
 import com.squareup.okhttp.mockwebserver.RecordedRequest;
 import com.squareup.okhttp.mockwebserver.SocketPolicy;
-import java.io.ByteArrayOutputStream;
 import java.io.File;
 import java.io.IOException;
 import java.io.InputStream;
-import java.io.OutputStream;
 import java.net.Authenticator;
 import java.net.CookieManager;
 import java.net.HttpURLConnection;
@@ -43,10 +42,13 @@
 import java.util.concurrent.CountDownLatch;
 import java.util.concurrent.ExecutorService;
 import java.util.concurrent.Executors;
-import java.util.zip.GZIPOutputStream;
 import javax.net.ssl.HostnameVerifier;
 import javax.net.ssl.SSLContext;
 import javax.net.ssl.SSLSession;
+import okio.Buffer;
+import okio.BufferedSink;
+import okio.GzipSink;
+import okio.Okio;
 import org.junit.After;
 import org.junit.Before;
 import org.junit.Ignore;
@@ -79,18 +81,18 @@ public boolean verify(String hostname, SSLSession session) {
   private static final SSLContext sslContext = SslContextBuilder.localhost();
   protected final MockWebServer server = new MockWebServer();
   protected final String hostName = server.getHostName();
-  protected final OkHttpClient client = new OkHttpClient();
+  protected final OkUrlFactory client = new OkUrlFactory(new OkHttpClient());
   protected HttpURLConnection connection;
-  protected HttpResponseCache cache;
+  protected Cache cache;
 
   @Before public void setUp() throws Exception {
     server.useHttps(sslContext.getSocketFactory(), false);
-    client.setProtocols(Arrays.asList(protocol, Protocol.HTTP_11));
-    client.setSslSocketFactory(sslContext.getSocketFactory());
-    client.setHostnameVerifier(NULL_HOSTNAME_VERIFIER);
+    client.client().setProtocols(Arrays.asList(protocol, Protocol.HTTP_1_1));
+    client.client().setSslSocketFactory(sslContext.getSocketFactory());
+    client.client().setHostnameVerifier(NULL_HOSTNAME_VERIFIER);
     String systemTmpDir = System.getProperty("java.io.tmpdir");
     File cacheDir = new File(systemTmpDir, "HttpCache-" + protocol + "-" + UUID.randomUUID());
-    cache = new HttpResponseCache(cacheDir, Integer.MAX_VALUE);
+    cache = new Cache(cacheDir, Integer.MAX_VALUE);
   }
 
   @After public void tearDown() throws Exception {
@@ -224,8 +226,9 @@ public boolean verify(String hostname, SSLSession session) {
   }
 
   @Test public void gzippedResponseBody() throws Exception {
-    server.enqueue(new MockResponse().addHeader("Content-Encoding: gzip")
-        .setBody(gzip("ABCABCABC".getBytes(Util.UTF_8))));
+    server.enqueue(new MockResponse()
+        .addHeader("Content-Encoding: gzip")
+        .setBody(gzip("ABCABCABC")));
     server.play();
     assertContent("ABCABCABC", client.open(server.getUrl("/r1")), Integer.MAX_VALUE);
   }
@@ -329,7 +332,7 @@ public boolean verify(String hostname, SSLSession session) {
       readAscii(connection.getInputStream(), Integer.MAX_VALUE);
       fail("Should have timed out!");
     } catch (IOException e){
-      assertEquals("Read timed out", e.getMessage());
+      assertEquals("timeout", e.getMessage());
     }
   }
 
@@ -349,7 +352,7 @@ public boolean verify(String hostname, SSLSession session) {
   }
 
   @Test public void responsesAreCached() throws IOException {
-    client.setOkResponseCache(cache);
+    client.client().setCache(cache);
 
     server.enqueue(new MockResponse().addHeader("cache-control: max-age=60").setBody("A"));
     server.play();
@@ -366,7 +369,7 @@ public boolean verify(String hostname, SSLSession session) {
   }
 
   @Test public void conditionalCache() throws IOException {
-    client.setOkResponseCache(cache);
+    client.client().setCache(cache);
 
     server.enqueue(new MockResponse().addHeader("ETag: v1").setBody("A"));
     server.enqueue(new MockResponse().setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
@@ -383,7 +386,7 @@ public boolean verify(String hostname, SSLSession session) {
   }
 
   @Test public void responseCachedWithoutConsumingFullBody() throws IOException {
-    client.setOkResponseCache(cache);
+    client.client().setCache(cache);
 
     server.enqueue(new MockResponse().addHeader("cache-control: max-age=60").setBody("ABCD"));
     server.enqueue(new MockResponse().addHeader("cache-control: max-age=60").setBody("EFGH"));
@@ -402,7 +405,7 @@ public boolean verify(String hostname, SSLSession session) {
 
   @Test public void acceptAndTransmitCookies() throws Exception {
     CookieManager cookieManager = new CookieManager();
-    client.setCookieHandler(cookieManager);
+    client.client().setCookieHandler(cookieManager);
     server.enqueue(
         new MockResponse().addHeader("set-cookie: c=oreo; domain=" + server.getCookieDomain())
             .setBody("A"));
@@ -453,12 +456,12 @@ private String readAscii(InputStream in, int count) throws IOException {
     return result.toString();
   }
 
-  public byte[] gzip(byte[] bytes) throws IOException {
-    ByteArrayOutputStream bytesOut = new ByteArrayOutputStream();
-    OutputStream gzippedOut = new GZIPOutputStream(bytesOut);
-    gzippedOut.write(bytes);
-    gzippedOut.close();
-    return bytesOut.toByteArray();
+  public Buffer gzip(String bytes) throws IOException {
+    Buffer bytesOut = new Buffer();
+    BufferedSink sink = Okio.buffer(new GzipSink(bytesOut));
+    sink.writeUtf8(bytes);
+    sink.close();
+    return bytesOut;
   }
 
   class SpdyRequest implements Runnable {
diff --git a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/RecordingProxySelector.java b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/RecordingProxySelector.java
new file mode 100644
index 0000000000..ed9cfa4ba9
--- /dev/null
+++ b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/RecordingProxySelector.java
@@ -0,0 +1,51 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.okhttp.internal.http;
+
+import java.io.IOException;
+import java.net.InetSocketAddress;
+import java.net.Proxy;
+import java.net.ProxySelector;
+import java.net.SocketAddress;
+import java.net.URI;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.List;
+
+import static org.junit.Assert.assertEquals;
+
+public final class RecordingProxySelector extends ProxySelector {
+  final List<URI> requestedUris = new ArrayList<>();
+  List<Proxy> proxies = new ArrayList<>();
+  final List<String> failures = new ArrayList<>();
+
+  @Override public List<Proxy> select(URI uri) {
+    requestedUris.add(uri);
+    return proxies;
+  }
+
+  public void assertRequests(URI... expectedUris) {
+    assertEquals(Arrays.asList(expectedUris), requestedUris);
+    requestedUris.clear();
+  }
+
+  @Override public void connectFailed(URI uri, SocketAddress sa, IOException ioe) {
+    InetSocketAddress socketAddress = (InetSocketAddress) sa;
+    failures.add(
+        String.format("%s %s:%d %s", uri, socketAddress.getHostName(), socketAddress.getPort(),
+            ioe.getMessage()));
+  }
+}
diff --git a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/ResponseCacheAdapterTest.java b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/ResponseCacheAdapterTest.java
deleted file mode 100644
index 9b880ef58b..0000000000
--- a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/ResponseCacheAdapterTest.java
+++ /dev/null
@@ -1,569 +0,0 @@
-/*
- * Copyright (C) 2014 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.squareup.okhttp.internal.http;
-
-import com.squareup.okhttp.OkHttpClient;
-import com.squareup.okhttp.internal.SslContextBuilder;
-import com.squareup.okhttp.mockwebserver.MockResponse;
-import com.squareup.okhttp.mockwebserver.MockWebServer;
-import com.squareup.okhttp.mockwebserver.RecordedRequest;
-
-import org.junit.After;
-import org.junit.Before;
-import org.junit.Test;
-
-import java.io.IOException;
-import java.net.CacheRequest;
-import java.net.CacheResponse;
-import java.net.HttpURLConnection;
-import java.net.ResponseCache;
-import java.net.URI;
-import java.net.URISyntaxException;
-import java.net.URL;
-import java.net.URLConnection;
-import java.util.Arrays;
-import java.util.Collections;
-import java.util.HashSet;
-import java.util.List;
-import java.util.Map;
-import java.util.Set;
-
-import javax.net.ssl.HostnameVerifier;
-import javax.net.ssl.HttpsURLConnection;
-import javax.net.ssl.SSLContext;
-import javax.net.ssl.SSLSession;
-
-import static org.junit.Assert.assertArrayEquals;
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertFalse;
-import static org.junit.Assert.assertNotNull;
-import static org.junit.Assert.assertNull;
-import static org.junit.Assert.assertTrue;
-import static org.junit.Assert.fail;
-
-/**
- * A white-box test for {@link ResponseCacheAdapter}. See also {@link ResponseCacheTest} for
- * black-box tests that check that {@link ResponseCache} classes are called correctly by OkHttp.
- */
-public class ResponseCacheAdapterTest {
-
-  private static final SSLContext sslContext = SslContextBuilder.localhost();
-  private static final HostnameVerifier NULL_HOSTNAME_VERIFIER = new HostnameVerifier() {
-    public boolean verify(String hostname, SSLSession session) {
-      return true;
-    }
-  };
-
-  private MockWebServer server;
-
-  private OkHttpClient client;
-
-  private HttpURLConnection connection;
-
-  @Before
-  public void setUp() throws Exception {
-    server = new MockWebServer();
-    client = new OkHttpClient();
-  }
-
-  @After
-  public void tearDown() throws Exception {
-    if (connection != null) {
-      connection.disconnect();
-    }
-    server.shutdown();
-  }
-
-  @Test public void get_allParameters() throws Exception {
-    final URL serverUrl = configureServer(new MockResponse());
-    assertEquals("http", serverUrl.getProtocol());
-
-    ResponseCache responseCache = new NoOpResponseCache() {
-      @Override
-      public CacheResponse get(URI uri, String method, Map<String, List<String>> headers) throws IOException {
-        assertEquals(toUri(serverUrl), uri);
-        assertEquals("GET", method);
-        assertTrue("Arbitrary standard header not present", headers.containsKey("User-Agent"));
-        assertEquals(Collections.singletonList("value1"), headers.get("key1"));
-        return null;
-      }
-    };
-    client.setResponseCache(responseCache);
-
-    connection = client.open(serverUrl);
-    connection.setRequestProperty("key1", "value1");
-
-    executeGet(connection);
-  }
-
-  @Test public void put_uriAndClass() throws Exception {
-    final URL serverUrl = configureServer(new MockResponse());
-
-    ResponseCache responseCache = new NoOpResponseCache() {
-      @Override
-      public CacheRequest put(URI uri, URLConnection urlConnection) throws IOException {
-        assertTrue(urlConnection instanceof HttpURLConnection);
-        assertFalse(urlConnection instanceof HttpsURLConnection);
-        assertEquals(toUri(serverUrl), uri);
-        assertEquals(serverUrl, urlConnection.getURL());
-        return null;
-      }
-    };
-    client.setResponseCache(responseCache);
-
-    connection = client.open(serverUrl);
-    executeGet(connection);
-  }
-
-  @Test public void put_requestHeadersPartlyUnavailable() throws Exception {
-    final URL serverUrl = configureServer(new MockResponse());
-
-    ResponseCache responseCache = new NoOpResponseCache() {
-      @Override
-      public CacheRequest put(URI uri, URLConnection urlConnection) throws IOException {
-        // This is to be compatible with OkHttp's HttpURLConnectionImpl and the RI.
-        try {
-          urlConnection.getRequestProperties();
-          fail();
-        } catch (UnsupportedOperationException expected) {
-        }
-
-        assertEquals("value", urlConnection.getRequestProperty("key"));
-
-        return null;
-      }
-    };
-    client.setResponseCache(responseCache);
-
-    connection = client.open(serverUrl);
-    connection.setRequestProperty("key", "value");
-
-    executeGet(connection);
-  }
-
-  @Test public void put_requestChangesForbidden() throws Exception {
-    final URL serverUrl = configureServer(new MockResponse());
-
-    ResponseCache responseCache = new NoOpResponseCache() {
-      @Override
-      public CacheRequest put(URI uri, URLConnection urlConnection) throws IOException {
-        HttpURLConnection httpUrlConnection = (HttpURLConnection) urlConnection;
-        // Check an arbitrary (not complete) set of methods that can be used to modify the
-        // request.
-        try {
-          httpUrlConnection.setRequestProperty("key", "value");
-          fail();
-        } catch (UnsupportedOperationException expected) {
-        }
-        try {
-          httpUrlConnection.setFixedLengthStreamingMode(1234);
-          fail();
-        } catch (UnsupportedOperationException expected) {
-        }
-        try {
-          httpUrlConnection.setRequestMethod("PUT");
-          fail();
-        } catch (UnsupportedOperationException expected) {
-        }
-        try {
-          httpUrlConnection.getHeaderFields().put("key", Collections.singletonList("value"));
-          fail();
-        } catch (UnsupportedOperationException expected) {
-        }
-        try {
-          httpUrlConnection.getOutputStream();
-          fail();
-        } catch (UnsupportedOperationException expected) {
-        }
-        return null;
-      }
-    };
-    client.setResponseCache(responseCache);
-
-    connection = client.open(serverUrl);
-
-    executeGet(connection);
-  }
-
-  @Test public void connectionChangesForbidden() throws Exception {
-    final URL serverUrl = configureServer(new MockResponse());
-
-    ResponseCache responseCache = new NoOpResponseCache() {
-      @Override
-      public CacheRequest put(URI uri, URLConnection urlConnection) throws IOException {
-        HttpURLConnection httpUrlConnection = (HttpURLConnection) urlConnection;
-        try {
-          httpUrlConnection.connect();
-          fail();
-        } catch (UnsupportedOperationException expected) {
-        }
-        try {
-          httpUrlConnection.disconnect();
-          fail();
-        } catch (UnsupportedOperationException expected) {
-        }
-        return null;
-      }
-    };
-    client.setResponseCache(responseCache);
-
-    connection = client.open(serverUrl);
-
-    executeGet(connection);
-  }
-
-  @Test public void put_responseChangesForbidden() throws Exception {
-    final URL serverUrl = configureServer(new MockResponse());
-
-    ResponseCache responseCache = new NoOpResponseCache() {
-      @Override
-      public CacheRequest put(URI uri, URLConnection urlConnection) throws IOException {
-        HttpURLConnection httpUrlConnection = (HttpURLConnection) urlConnection;
-        // Check an arbitrary (not complete) set of methods that can be used to access the response
-        // body.
-        try {
-          httpUrlConnection.getInputStream();
-          fail();
-        } catch (UnsupportedOperationException expected) {
-        }
-        try {
-          httpUrlConnection.getContent();
-          fail();
-        } catch (UnsupportedOperationException expected) {
-        }
-        try {
-          httpUrlConnection.setFixedLengthStreamingMode(1234);
-          fail();
-        } catch (UnsupportedOperationException expected) {
-        }
-        try {
-          httpUrlConnection.setRequestMethod("PUT");
-          fail();
-        } catch (UnsupportedOperationException expected) {
-        }
-        try {
-          urlConnection.getHeaderFields().put("key", Collections.singletonList("value"));
-          fail();
-        } catch (UnsupportedOperationException expected) {
-        }
-        return null;
-      }
-    };
-    client.setResponseCache(responseCache);
-
-    connection = client.open(serverUrl);
-
-    executeGet(connection);
-  }
-
-  @Test public void put_responseHeadersOk() throws Exception {
-    final String statusLine = "HTTP/1.1 200 Fantastic";
-    final URL serverUrl = configureServer(
-        new MockResponse()
-            .setStatus(statusLine)
-            .addHeader("A", "c")
-            .addHeader("B", "d")
-            .addHeader("A", "e"));
-
-    ResponseCache responseCache = new NoOpResponseCache() {
-      @Override
-      public CacheRequest put(URI uri, URLConnection urlConnection) throws IOException {
-        HttpURLConnection httpUrlConnection = (HttpURLConnection) urlConnection;
-        assertEquals(200, httpUrlConnection.getResponseCode());
-        assertEquals("Fantastic", httpUrlConnection.getResponseMessage());
-        assertEquals(0, urlConnection.getContentLength());
-
-        // Check retrieval by string key.
-        assertEquals(statusLine, httpUrlConnection.getHeaderField(null));
-        assertEquals("e", httpUrlConnection.getHeaderField("A"));
-        // The RI and OkHttp supports case-insensitive matching for this method.
-        assertEquals("e", httpUrlConnection.getHeaderField("a"));
-
-        // Check retrieval using a Map.
-        Map<String, List<String>> responseHeaders = httpUrlConnection.getHeaderFields();
-        assertEquals(Arrays.asList(statusLine), responseHeaders.get(null));
-        assertEquals(newSet("c", "e"), new HashSet<String>(responseHeaders.get("A")));
-        // OkHttp supports case-insensitive matching here. The RI does not.
-        assertEquals(newSet("c", "e"), new HashSet<String>(responseHeaders.get("a")));
-
-        // Check the Map iterator contains the expected mappings.
-        assertHeadersContainsMapping(responseHeaders, null, statusLine);
-        assertHeadersContainsMapping(responseHeaders, "A", "c", "e");
-        assertHeadersContainsMapping(responseHeaders, "B", "d");
-
-        // Check immutability of the headers Map.
-        try {
-          responseHeaders.put("N", Arrays.asList("o"));
-          fail("Modified an unmodifiable view.");
-        } catch (UnsupportedOperationException expected) {
-        }
-        try {
-          responseHeaders.get("A").add("f");
-          fail("Modified an unmodifiable view.");
-        } catch (UnsupportedOperationException expected) {
-        }
-
-        // Check retrieval of headers by index.
-        assertEquals(null, httpUrlConnection.getHeaderFieldKey(0));
-        assertEquals(statusLine, httpUrlConnection.getHeaderField(0));
-        // After header zero there may be additional entries provided at the beginning or end by the
-        // implementation. It's probably important that the relative ordering of the headers is
-        // preserved, particularly if there are multiple value for the same key.
-        int i = 1;
-        while (!httpUrlConnection.getHeaderFieldKey(i).equals("A")) {
-          i++;
-        }
-        // Check the ordering of the headers set by app code.
-        assertResponseHeaderAtIndex(httpUrlConnection, i++, "A", "c");
-        assertResponseHeaderAtIndex(httpUrlConnection, i++, "B", "d");
-        assertResponseHeaderAtIndex(httpUrlConnection, i++, "A", "e");
-        // There may be some additional headers provided by the implementation.
-        while (httpUrlConnection.getHeaderField(i) != null) {
-          assertNotNull(httpUrlConnection.getHeaderFieldKey(i));
-          i++;
-        }
-        // Confirm the correct behavior when the index is out-of-range.
-        assertNull(httpUrlConnection.getHeaderFieldKey(i));
-
-        return null;
-      }
-    };
-    client.setResponseCache(responseCache);
-
-    connection = client.open(serverUrl);
-
-    executeGet(connection);
-  }
-
-  private static void assertResponseHeaderAtIndex(HttpURLConnection httpUrlConnection, int headerIndex,
-      String expectedKey, String expectedValue) {
-    assertEquals(expectedKey, httpUrlConnection.getHeaderFieldKey(headerIndex));
-    assertEquals(expectedValue, httpUrlConnection.getHeaderField(headerIndex));
-
-  }
-
-  private void assertHeadersContainsMapping(Map<String, List<String>> headers, String expectedKey,
-      String... expectedValues) {
-    assertTrue(headers.containsKey(expectedKey));
-    assertEquals(newSet(expectedValues), new HashSet<String>(headers.get(expectedKey)));
-  }
-
-  @Test public void put_accessibleRequestInfo_GET() throws Exception {
-    final URL serverUrl = configureServer(new MockResponse());
-
-    ResponseCache responseCache = new NoOpResponseCache() {
-      @Override
-      public CacheRequest put(URI uri, URLConnection urlConnection) throws IOException {
-        // Status Line is treated as a special header by the Java APIs.
-        HttpURLConnection httpUrlConnection = (HttpURLConnection) urlConnection;
-        assertEquals("GET", httpUrlConnection.getRequestMethod());
-        assertTrue(httpUrlConnection.getDoInput());
-        assertFalse(httpUrlConnection.getDoOutput());
-
-        return null;
-      }
-    };
-    client.setResponseCache(responseCache);
-
-    connection = client.open(serverUrl);
-
-    executeGet(connection);
-  }
-
-  @Test public void put_accessibleRequestInfo_POST() throws Exception {
-    final URL serverUrl = configureServer(new MockResponse());
-
-    ResponseCache responseCache = new NoOpResponseCache() {
-      @Override
-      public CacheRequest put(URI uri, URLConnection urlConnection) throws IOException {
-        // Status Line is treated as a special header by the Java APIs.
-        HttpURLConnection httpUrlConnection = (HttpURLConnection) urlConnection;
-        assertEquals("POST", httpUrlConnection.getRequestMethod());
-        assertTrue(httpUrlConnection.getDoInput());
-        assertTrue(httpUrlConnection.getDoOutput());
-        return null;
-      }
-    };
-    client.setResponseCache(responseCache);
-
-    connection = client.open(serverUrl);
-
-    executePost(connection);
-  }
-
-  @Test public void get_https_allParameters() throws Exception {
-    final URL serverUrl = configureHttpsServer(new MockResponse());
-    assertEquals("https", serverUrl.getProtocol());
-
-    ResponseCache responseCache = new NoOpResponseCache() {
-      @Override
-      public CacheResponse get(URI uri, String method, Map<String, List<String>> headers) throws IOException {
-        assertEquals("https", uri.getScheme());
-        assertEquals(toUri(serverUrl), uri);
-        assertEquals("GET", method);
-        assertTrue("Arbitrary standard header not present", headers.containsKey("User-Agent"));
-        assertEquals(Collections.singletonList("value1"), headers.get("key1"));
-        return null;
-      }
-    };
-    client.setResponseCache(responseCache);
-    client.setSslSocketFactory(sslContext.getSocketFactory());
-    client.setHostnameVerifier(NULL_HOSTNAME_VERIFIER);
-
-    connection = client.open(serverUrl);
-    connection.setRequestProperty("key1", "value1");
-
-    executeGet(connection);
-  }
-
-  @Test public void put_https_uriAndClass() throws Exception {
-    final URL serverUrl = configureHttpsServer(new MockResponse());
-    assertEquals("https", serverUrl.getProtocol());
-
-    ResponseCache responseCache = new NoOpResponseCache() {
-      @Override
-      public CacheRequest put(URI uri, URLConnection urlConnection) throws IOException {
-        assertTrue(urlConnection instanceof HttpsURLConnection);
-        assertEquals(toUri(serverUrl), uri);
-        assertEquals(serverUrl, urlConnection.getURL());
-        return null;
-      }
-    };
-    client.setResponseCache(responseCache);
-    client.setSslSocketFactory(sslContext.getSocketFactory());
-    client.setHostnameVerifier(NULL_HOSTNAME_VERIFIER);
-
-    connection = client.open(serverUrl);
-    executeGet(connection);
-  }
-
-  @Test public void put_https_extraHttpsMethods() throws Exception {
-    final URL serverUrl = configureHttpsServer(new MockResponse());
-    assertEquals("https", serverUrl.getProtocol());
-
-    ResponseCache responseCache = new NoOpResponseCache() {
-      @Override
-      public CacheRequest put(URI uri, URLConnection urlConnection) throws IOException {
-        HttpsURLConnection cacheHttpsUrlConnection = (HttpsURLConnection) urlConnection;
-        HttpsURLConnection realHttpsUrlConnection = (HttpsURLConnection) connection;
-        assertEquals(realHttpsUrlConnection.getCipherSuite(),
-            cacheHttpsUrlConnection.getCipherSuite());
-        assertEquals(realHttpsUrlConnection.getPeerPrincipal(),
-            cacheHttpsUrlConnection.getPeerPrincipal());
-        assertArrayEquals(realHttpsUrlConnection.getLocalCertificates(),
-            cacheHttpsUrlConnection.getLocalCertificates());
-        assertArrayEquals(realHttpsUrlConnection.getServerCertificates(),
-            cacheHttpsUrlConnection.getServerCertificates());
-        assertEquals(realHttpsUrlConnection.getLocalPrincipal(),
-            cacheHttpsUrlConnection.getLocalPrincipal());
-        return null;
-      }
-    };
-    client.setResponseCache(responseCache);
-    client.setSslSocketFactory(sslContext.getSocketFactory());
-    client.setHostnameVerifier(NULL_HOSTNAME_VERIFIER);
-
-    connection = client.open(serverUrl);
-    executeGet(connection);
-
-    RecordedRequest recordedRequest = server.takeRequest();
-    recordedRequest.getSslProtocol();
-  }
-
-  @Test public void put_https_forbiddenFields() throws Exception {
-    final URL serverUrl = configureHttpsServer(new MockResponse());
-
-    ResponseCache responseCache = new NoOpResponseCache() {
-      @Override
-      public CacheRequest put(URI uri, URLConnection urlConnection) throws IOException {
-        HttpsURLConnection httpsUrlConnection = (HttpsURLConnection) urlConnection;
-        try {
-          httpsUrlConnection.getHostnameVerifier();
-          fail();
-        } catch (UnsupportedOperationException expected) {
-        }
-        try {
-          httpsUrlConnection.getSSLSocketFactory();
-          fail();
-        } catch (UnsupportedOperationException expected) {
-        }
-        return null;
-      }
-    };
-    client.setResponseCache(responseCache);
-    client.setSslSocketFactory(sslContext.getSocketFactory());
-    client.setHostnameVerifier(NULL_HOSTNAME_VERIFIER);
-
-    connection = client.open(serverUrl);
-    executeGet(connection);
-
-    RecordedRequest recordedRequest = server.takeRequest();
-    recordedRequest.getSslProtocol();
-  }
-
-  private void executeGet(HttpURLConnection connection) throws IOException {
-    connection.connect();
-    connection.getHeaderFields();
-    connection.disconnect();
-  }
-
-  private void executePost(HttpURLConnection connection) throws IOException {
-    connection.setDoOutput(true);
-    connection.connect();
-    connection.getOutputStream().write("Hello World".getBytes());
-    connection.disconnect();
-  }
-
-  private URL configureServer(MockResponse mockResponse) throws Exception {
-    server.enqueue(mockResponse);
-    server.play();
-    return server.getUrl("/");
-  }
-
-  private URL configureHttpsServer(MockResponse mockResponse) throws Exception {
-    server.useHttps(sslContext.getSocketFactory(), false /* tunnelProxy */);
-    server.enqueue(mockResponse);
-    server.play();
-    return server.getUrl("/");
-  }
-
-  private static class NoOpResponseCache extends ResponseCache {
-
-    @Override
-    public CacheResponse get(URI uri, String s, Map<String, List<String>> stringListMap)
-        throws IOException {
-      return null;
-    }
-
-    @Override
-    public CacheRequest put(URI uri, URLConnection urlConnection) throws IOException {
-      return null;
-    }
-  }
-
-  private static URI toUri(URL serverUrl) {
-    try {
-      return serverUrl.toURI();
-    } catch (URISyntaxException e) {
-      fail(e.getMessage());
-      return null;
-    }
-  }
-
-  private static Set<String> newSet(String... elements) {
-    return new HashSet<String>(Arrays.asList(elements));
-  }
-}
diff --git a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/RouteSelectorTest.java b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/RouteSelectorTest.java
index ea3dc57976..0284c6242e 100644
--- a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/RouteSelectorTest.java
+++ b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/RouteSelectorTest.java
@@ -16,31 +16,36 @@
 package com.squareup.okhttp.internal.http;
 
 import com.squareup.okhttp.Address;
+import com.squareup.okhttp.Authenticator;
 import com.squareup.okhttp.Connection;
 import com.squareup.okhttp.ConnectionPool;
-import com.squareup.okhttp.OkAuthenticator;
+import com.squareup.okhttp.HostResolver;
+import com.squareup.okhttp.OkHttpClient;
 import com.squareup.okhttp.Protocol;
-import com.squareup.okhttp.RouteDatabase;
-import com.squareup.okhttp.internal.Dns;
+import com.squareup.okhttp.Request;
+import com.squareup.okhttp.internal.Internal;
+import com.squareup.okhttp.internal.RouteDatabase;
 import com.squareup.okhttp.internal.SslContextBuilder;
 import java.io.IOException;
 import java.net.InetAddress;
 import java.net.InetSocketAddress;
 import java.net.Proxy;
-import java.net.ProxySelector;
-import java.net.SocketAddress;
-import java.net.URI;
 import java.net.UnknownHostException;
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.List;
 import java.util.NoSuchElementException;
+import javax.net.SocketFactory;
 import javax.net.ssl.HostnameVerifier;
+import javax.net.ssl.HttpsURLConnection;
 import javax.net.ssl.SSLContext;
 import javax.net.ssl.SSLHandshakeException;
 import javax.net.ssl.SSLSocketFactory;
+import org.junit.Before;
 import org.junit.Test;
 
+import static com.squareup.okhttp.internal.http.RouteSelector.SSL_V3;
+import static com.squareup.okhttp.internal.http.RouteSelector.TLS_V1;
 import static java.net.Proxy.NO_PROXY;
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertFalse;
@@ -56,81 +61,95 @@
   private static final String proxyBHost = "proxyB";
   private static final Proxy proxyB =
       new Proxy(Proxy.Type.HTTP, new InetSocketAddress(proxyBHost, proxyBPort));
-  private static final URI uri;
-  private static final String uriHost = "hostA";
-  private static final int uriPort = 80;
+  private String uriHost = "hostA";
+  private int uriPort = 1003;
 
-  private static final SSLContext sslContext = SslContextBuilder.localhost();
-  private static final SSLSocketFactory socketFactory = sslContext.getSocketFactory();
-  private static final HostnameVerifier hostnameVerifier;
-  private static final ConnectionPool pool;
+  private SocketFactory socketFactory;
+  private final SSLContext sslContext = SslContextBuilder.localhost();
+  private final SSLSocketFactory sslSocketFactory = sslContext.getSocketFactory();
+  private HostnameVerifier hostnameVerifier;
 
-  static {
-    try {
-      uri = new URI("http://" + uriHost + ":" + uriPort + "/path");
-      pool = ConnectionPool.getDefault();
-      hostnameVerifier = HttpsURLConnectionImpl.getDefaultHostnameVerifier();
-    } catch (Exception e) {
-      throw new AssertionError(e);
-    }
-  }
-
-  private final OkAuthenticator authenticator = HttpAuthenticator.SYSTEM_DEFAULT;
-  private final List<Protocol> protocols = Arrays.asList(Protocol.HTTP_11);
+  private final Authenticator authenticator = AuthenticatorAdapter.INSTANCE;
+  private final List<Protocol> protocols = Arrays.asList(Protocol.HTTP_1_1);
   private final FakeDns dns = new FakeDns();
-  private final FakeProxySelector proxySelector = new FakeProxySelector();
+  private final RecordingProxySelector proxySelector = new RecordingProxySelector();
+  private OkHttpClient client;
+  private RouteDatabase routeDatabase;
+  private Request httpRequest;
+  private Request httpsRequest;
+
+  @Before public void setUp() throws Exception {
+    socketFactory = SocketFactory.getDefault();
+    hostnameVerifier = HttpsURLConnection.getDefaultHostnameVerifier();
+
+    client = new OkHttpClient()
+        .setAuthenticator(authenticator)
+        .setProxySelector(proxySelector)
+        .setSocketFactory(socketFactory)
+        .setSslSocketFactory(sslSocketFactory)
+        .setHostnameVerifier(hostnameVerifier)
+        .setProtocols(protocols)
+        .setConnectionPool(ConnectionPool.getDefault())
+        .setHostResolver(dns);
+    routeDatabase = Internal.instance.routeDatabase(client);
+
+    httpRequest = new Request.Builder()
+        .url("http://" + uriHost + ":" + uriPort + "/path")
+        .build();
+    httpsRequest = new Request.Builder()
+        .url("https://" + uriHost + ":" + uriPort + "/path")
+        .build();
+  }
 
   @Test public void singleRoute() throws Exception {
-    Address address = new Address(uriHost, uriPort, null, null, authenticator, null, protocols);
-    RouteSelector routeSelector = new RouteSelector(address, uri, proxySelector, pool, dns,
-        new RouteDatabase());
+    Address address = httpAddress();
+    RouteSelector routeSelector = RouteSelector.get(httpRequest, client);
 
     assertTrue(routeSelector.hasNext());
     dns.inetAddresses = makeFakeAddresses(255, 1);
-    assertConnection(routeSelector.next("GET"), address, NO_PROXY, dns.inetAddresses[0], uriPort,
-        false);
+    assertConnection(routeSelector.nextUnconnected(), address, NO_PROXY, dns.inetAddresses[0],
+        uriPort, SSL_V3);
     dns.assertRequests(uriHost);
 
     assertFalse(routeSelector.hasNext());
     try {
-      routeSelector.next("GET");
+      routeSelector.nextUnconnected();
       fail();
     } catch (NoSuchElementException expected) {
     }
   }
 
   @Test public void singleRouteReturnsFailedRoute() throws Exception {
-    Address address = new Address(uriHost, uriPort, null, null, authenticator, null, protocols);
-    RouteSelector routeSelector = new RouteSelector(address, uri, proxySelector, pool, dns,
-        new RouteDatabase());
+    Address address = httpAddress();
+    RouteSelector routeSelector = RouteSelector.get(httpRequest, client);
 
     assertTrue(routeSelector.hasNext());
     dns.inetAddresses = makeFakeAddresses(255, 1);
-    Connection connection = routeSelector.next("GET");
-    RouteDatabase routeDatabase = new RouteDatabase();
+    Connection connection = routeSelector.nextUnconnected();
     routeDatabase.failed(connection.getRoute());
-    routeSelector = new RouteSelector(address, uri, proxySelector, pool, dns, routeDatabase);
-    assertConnection(routeSelector.next("GET"), address, NO_PROXY, dns.inetAddresses[0], uriPort,
-        false);
+    routeSelector = RouteSelector.get(httpRequest, client);
+    assertConnection(routeSelector.nextUnconnected(), address, NO_PROXY, dns.inetAddresses[0],
+        uriPort, SSL_V3);
     assertFalse(routeSelector.hasNext());
     try {
-      routeSelector.next("GET");
+      routeSelector.nextUnconnected();
       fail();
     } catch (NoSuchElementException expected) {
     }
   }
 
-  @Test public void explicitProxyTriesThatProxiesAddressesOnly() throws Exception {
-    Address address = new Address(uriHost, uriPort, null, null, authenticator, proxyA, protocols);
-    RouteSelector routeSelector = new RouteSelector(address, uri, proxySelector, pool, dns,
-        new RouteDatabase());
+  @Test public void explicitProxyTriesThatProxysAddressesOnly() throws Exception {
+    Address address = new Address(uriHost, uriPort, socketFactory, null, null, authenticator,
+        proxyA, protocols);
+    client.setProxy(proxyA);
+    RouteSelector routeSelector = RouteSelector.get(httpRequest, client);
 
     assertTrue(routeSelector.hasNext());
     dns.inetAddresses = makeFakeAddresses(255, 2);
-    assertConnection(routeSelector.next("GET"), address, proxyA, dns.inetAddresses[0], proxyAPort,
-        false);
-    assertConnection(routeSelector.next("GET"), address, proxyA, dns.inetAddresses[1], proxyAPort,
-        false);
+    assertConnection(routeSelector.nextUnconnected(), address, proxyA, dns.inetAddresses[0],
+        proxyAPort, SSL_V3);
+    assertConnection(routeSelector.nextUnconnected(), address, proxyA, dns.inetAddresses[1],
+        proxyAPort, SSL_V3);
 
     assertFalse(routeSelector.hasNext());
     dns.assertRequests(proxyAHost);
@@ -138,130 +157,125 @@
   }
 
   @Test public void explicitDirectProxy() throws Exception {
-    Address address = new Address(uriHost, uriPort, null, null, authenticator, NO_PROXY,
-        protocols);
-    RouteSelector routeSelector = new RouteSelector(address, uri, proxySelector, pool, dns,
-        new RouteDatabase());
+    Address address = new Address(uriHost, uriPort, socketFactory, null, null, authenticator,
+        NO_PROXY, protocols);
+    client.setProxy(NO_PROXY);
+    RouteSelector routeSelector = RouteSelector.get(httpRequest, client);
 
     assertTrue(routeSelector.hasNext());
     dns.inetAddresses = makeFakeAddresses(255, 2);
-    assertConnection(routeSelector.next("GET"), address, NO_PROXY, dns.inetAddresses[0], uriPort,
-        false);
-    assertConnection(routeSelector.next("GET"), address, NO_PROXY, dns.inetAddresses[1], uriPort,
-        false);
+    assertConnection(routeSelector.nextUnconnected(), address, NO_PROXY, dns.inetAddresses[0],
+        uriPort, SSL_V3);
+    assertConnection(routeSelector.nextUnconnected(), address, NO_PROXY, dns.inetAddresses[1],
+        uriPort, SSL_V3);
 
     assertFalse(routeSelector.hasNext());
-    dns.assertRequests(uri.getHost());
+    dns.assertRequests(uriHost);
     proxySelector.assertRequests(); // No proxy selector requests!
   }
 
   @Test public void proxySelectorReturnsNull() throws Exception {
-    Address address = new Address(uriHost, uriPort, null, null, authenticator, null, protocols);
+    Address address = httpAddress();
 
     proxySelector.proxies = null;
-    RouteSelector routeSelector = new RouteSelector(address, uri, proxySelector, pool, dns,
-        new RouteDatabase());
-    proxySelector.assertRequests(uri);
+    RouteSelector routeSelector = RouteSelector.get(httpRequest, client);
+    proxySelector.assertRequests(httpRequest.uri());
 
     assertTrue(routeSelector.hasNext());
     dns.inetAddresses = makeFakeAddresses(255, 1);
-    assertConnection(routeSelector.next("GET"), address, NO_PROXY, dns.inetAddresses[0], uriPort,
-        false);
+    assertConnection(routeSelector.nextUnconnected(), address, NO_PROXY, dns.inetAddresses[0],
+        uriPort, SSL_V3);
     dns.assertRequests(uriHost);
 
     assertFalse(routeSelector.hasNext());
   }
 
   @Test public void proxySelectorReturnsNoProxies() throws Exception {
-    Address address = new Address(uriHost, uriPort, null, null, authenticator, null, protocols);
-    RouteSelector routeSelector = new RouteSelector(address, uri, proxySelector, pool, dns,
-        new RouteDatabase());
+    Address address = httpAddress();
+    RouteSelector routeSelector = RouteSelector.get(httpRequest, client);
 
     assertTrue(routeSelector.hasNext());
     dns.inetAddresses = makeFakeAddresses(255, 2);
-    assertConnection(routeSelector.next("GET"), address, NO_PROXY, dns.inetAddresses[0], uriPort,
-        false);
-    assertConnection(routeSelector.next("GET"), address, NO_PROXY, dns.inetAddresses[1], uriPort,
-        false);
+    assertConnection(routeSelector.nextUnconnected(), address, NO_PROXY, dns.inetAddresses[0],
+        uriPort, SSL_V3);
+    assertConnection(routeSelector.nextUnconnected(), address, NO_PROXY, dns.inetAddresses[1],
+        uriPort, SSL_V3);
 
     assertFalse(routeSelector.hasNext());
-    dns.assertRequests(uri.getHost());
-    proxySelector.assertRequests(uri);
+    dns.assertRequests(uriHost);
+    proxySelector.assertRequests(httpRequest.uri());
   }
 
   @Test public void proxySelectorReturnsMultipleProxies() throws Exception {
-    Address address = new Address(uriHost, uriPort, null, null, authenticator, null, protocols);
+    Address address = httpAddress();
 
     proxySelector.proxies.add(proxyA);
     proxySelector.proxies.add(proxyB);
-    RouteSelector routeSelector = new RouteSelector(address, uri, proxySelector, pool, dns,
-        new RouteDatabase());
-    proxySelector.assertRequests(uri);
+    RouteSelector routeSelector = RouteSelector.get(httpRequest, client);
+    proxySelector.assertRequests(httpRequest.uri());
 
     // First try the IP addresses of the first proxy, in sequence.
     assertTrue(routeSelector.hasNext());
     dns.inetAddresses = makeFakeAddresses(255, 2);
-    assertConnection(routeSelector.next("GET"), address, proxyA, dns.inetAddresses[0], proxyAPort,
-        false);
-    assertConnection(routeSelector.next("GET"), address, proxyA, dns.inetAddresses[1], proxyAPort,
-        false);
+    assertConnection(routeSelector.nextUnconnected(), address, proxyA, dns.inetAddresses[0], proxyAPort,
+        SSL_V3);
+    assertConnection(routeSelector.nextUnconnected(), address, proxyA, dns.inetAddresses[1], proxyAPort,
+        SSL_V3);
     dns.assertRequests(proxyAHost);
 
     // Next try the IP address of the second proxy.
     assertTrue(routeSelector.hasNext());
     dns.inetAddresses = makeFakeAddresses(254, 1);
-    assertConnection(routeSelector.next("GET"), address, proxyB, dns.inetAddresses[0], proxyBPort,
-        false);
+    assertConnection(routeSelector.nextUnconnected(), address, proxyB, dns.inetAddresses[0], proxyBPort,
+        SSL_V3);
     dns.assertRequests(proxyBHost);
 
     // Finally try the only IP address of the origin server.
     assertTrue(routeSelector.hasNext());
     dns.inetAddresses = makeFakeAddresses(253, 1);
-    assertConnection(routeSelector.next("GET"), address, NO_PROXY, dns.inetAddresses[0], uriPort,
-        false);
+    assertConnection(routeSelector.nextUnconnected(), address, NO_PROXY, dns.inetAddresses[0], uriPort,
+        SSL_V3);
     dns.assertRequests(uriHost);
 
     assertFalse(routeSelector.hasNext());
   }
 
   @Test public void proxySelectorDirectConnectionsAreSkipped() throws Exception {
-    Address address = new Address(uriHost, uriPort, null, null, authenticator, null, protocols);
+    Address address = httpAddress();
 
     proxySelector.proxies.add(NO_PROXY);
-    RouteSelector routeSelector = new RouteSelector(address, uri, proxySelector, pool, dns,
-        new RouteDatabase());
-    proxySelector.assertRequests(uri);
+    RouteSelector routeSelector = RouteSelector.get(httpRequest, client);
+    proxySelector.assertRequests(httpRequest.uri());
 
     // Only the origin server will be attempted.
     assertTrue(routeSelector.hasNext());
     dns.inetAddresses = makeFakeAddresses(255, 1);
-    assertConnection(routeSelector.next("GET"), address, NO_PROXY, dns.inetAddresses[0], uriPort,
-        false);
+    assertConnection(routeSelector.nextUnconnected(), address, NO_PROXY, dns.inetAddresses[0], uriPort,
+        SSL_V3);
     dns.assertRequests(uriHost);
 
     assertFalse(routeSelector.hasNext());
   }
 
   @Test public void proxyDnsFailureContinuesToNextProxy() throws Exception {
-    Address address = new Address(uriHost, uriPort, null, null, authenticator, null, protocols);
+    Address address = httpAddress();
 
     proxySelector.proxies.add(proxyA);
     proxySelector.proxies.add(proxyB);
     proxySelector.proxies.add(proxyA);
-    RouteSelector routeSelector = new RouteSelector(address, uri, proxySelector, pool, dns,
-        new RouteDatabase());
-    proxySelector.assertRequests(uri);
+    RouteSelector routeSelector = RouteSelector.get(httpRequest, client);
+    proxySelector.assertRequests(httpRequest.uri());
 
     assertTrue(routeSelector.hasNext());
     dns.inetAddresses = makeFakeAddresses(255, 1);
-    assertConnection(routeSelector.next("GET"), address, proxyA, dns.inetAddresses[0], proxyAPort,
-        false);
+    assertConnection(routeSelector.nextUnconnected(), address, proxyA, dns.inetAddresses[0], proxyAPort,
+        SSL_V3);
     dns.assertRequests(proxyAHost);
 
     assertTrue(routeSelector.hasNext());
     dns.inetAddresses = null;
     try {
-      routeSelector.next("GET");
+      routeSelector.nextUnconnected();
       fail();
     } catch (UnknownHostException expected) {
     }
@@ -269,14 +283,14 @@
 
     assertTrue(routeSelector.hasNext());
     dns.inetAddresses = makeFakeAddresses(255, 1);
-    assertConnection(routeSelector.next("GET"), address, proxyA, dns.inetAddresses[0], proxyAPort,
-        false);
+    assertConnection(routeSelector.nextUnconnected(), address, proxyA, dns.inetAddresses[0], proxyAPort,
+        SSL_V3);
     dns.assertRequests(proxyAHost);
 
     assertTrue(routeSelector.hasNext());
     dns.inetAddresses = makeFakeAddresses(254, 1);
-    assertConnection(routeSelector.next("GET"), address, NO_PROXY, dns.inetAddresses[0], uriPort,
-        false);
+    assertConnection(routeSelector.nextUnconnected(), address, NO_PROXY, dns.inetAddresses[0], uriPort,
+        SSL_V3);
     dns.assertRequests(uriHost);
 
     assertFalse(routeSelector.hasNext());
@@ -284,93 +298,83 @@
 
   // https://github.com/square/okhttp/issues/442
   @Test public void nonSslErrorAddsAllTlsModesToFailedRoute() throws Exception {
-    Address address = new Address(uriHost, uriPort, socketFactory, hostnameVerifier, authenticator,
-        Proxy.NO_PROXY, protocols);
-    RouteDatabase routeDatabase = new RouteDatabase();
-    RouteSelector routeSelector = new RouteSelector(address, uri, proxySelector, pool, dns,
-        routeDatabase);
+    client.setProxy(Proxy.NO_PROXY);
+    RouteSelector routeSelector = RouteSelector.get(httpsRequest, client);
 
     dns.inetAddresses = makeFakeAddresses(255, 1);
-    Connection connection = routeSelector.next("GET");
+    Connection connection = routeSelector.nextUnconnected();
     routeSelector.connectFailed(connection, new IOException("Non SSL exception"));
     assertTrue(routeDatabase.failedRoutesCount() == 2);
     assertFalse(routeSelector.hasNext());
   }
 
   @Test public void sslErrorAddsOnlyFailedTlsModeToFailedRoute() throws Exception {
-    Address address = new Address(uriHost, uriPort, socketFactory, hostnameVerifier, authenticator,
-        Proxy.NO_PROXY, protocols);
-    RouteDatabase routeDatabase = new RouteDatabase();
-    RouteSelector routeSelector = new RouteSelector(address, uri, proxySelector, pool, dns,
-        routeDatabase);
+    client.setProxy(Proxy.NO_PROXY);
+    RouteSelector routeSelector = RouteSelector.get(httpsRequest, client);
 
     dns.inetAddresses = makeFakeAddresses(255, 1);
-    Connection connection = routeSelector.next("GET");
+    Connection connection = routeSelector.nextUnconnected();
     routeSelector.connectFailed(connection, new SSLHandshakeException("SSL exception"));
     assertTrue(routeDatabase.failedRoutesCount() == 1);
     assertTrue(routeSelector.hasNext());
   }
 
   @Test public void multipleProxiesMultipleInetAddressesMultipleTlsModes() throws Exception {
-    Address address = new Address(uriHost, uriPort, socketFactory, hostnameVerifier, authenticator,
-        null, protocols);
+    Address address = new Address(uriHost, uriPort, socketFactory, sslSocketFactory,
+        hostnameVerifier, authenticator, null, protocols);
     proxySelector.proxies.add(proxyA);
     proxySelector.proxies.add(proxyB);
-    RouteSelector routeSelector = new RouteSelector(address, uri, proxySelector, pool, dns,
-        new RouteDatabase());
+    RouteSelector routeSelector = RouteSelector.get(httpsRequest, client);
 
     // Proxy A
     dns.inetAddresses = makeFakeAddresses(255, 2);
-    assertConnection(routeSelector.next("GET"), address, proxyA, dns.inetAddresses[0], proxyAPort,
-        true);
+    assertConnection(routeSelector.nextUnconnected(), address, proxyA, dns.inetAddresses[0],
+        proxyAPort, TLS_V1);
     dns.assertRequests(proxyAHost);
-    assertConnection(routeSelector.next("GET"), address, proxyA, dns.inetAddresses[0], proxyAPort,
-        false);
-    assertConnection(routeSelector.next("GET"), address, proxyA, dns.inetAddresses[1], proxyAPort,
-        true);
-    assertConnection(routeSelector.next("GET"), address, proxyA, dns.inetAddresses[1], proxyAPort,
-        false);
+    assertConnection(routeSelector.nextUnconnected(), address, proxyA, dns.inetAddresses[0],
+        proxyAPort, SSL_V3);
+    assertConnection(routeSelector.nextUnconnected(), address, proxyA, dns.inetAddresses[1],
+        proxyAPort, TLS_V1);
+    assertConnection(routeSelector.nextUnconnected(), address, proxyA, dns.inetAddresses[1],
+        proxyAPort, SSL_V3);
 
     // Proxy B
     dns.inetAddresses = makeFakeAddresses(254, 2);
-    assertConnection(routeSelector.next("GET"), address, proxyB, dns.inetAddresses[0], proxyBPort,
-        true);
+    assertConnection(routeSelector.nextUnconnected(), address, proxyB, dns.inetAddresses[0],
+        proxyBPort, TLS_V1);
     dns.assertRequests(proxyBHost);
-    assertConnection(routeSelector.next("GET"), address, proxyB, dns.inetAddresses[0], proxyBPort,
-        false);
-    assertConnection(routeSelector.next("GET"), address, proxyB, dns.inetAddresses[1], proxyBPort,
-        true);
-    assertConnection(routeSelector.next("GET"), address, proxyB, dns.inetAddresses[1], proxyBPort,
-        false);
+    assertConnection(routeSelector.nextUnconnected(), address, proxyB, dns.inetAddresses[0],
+        proxyBPort, SSL_V3);
+    assertConnection(routeSelector.nextUnconnected(), address, proxyB, dns.inetAddresses[1],
+        proxyBPort, TLS_V1);
+    assertConnection(routeSelector.nextUnconnected(), address, proxyB, dns.inetAddresses[1],
+        proxyBPort, SSL_V3);
 
     // Origin
     dns.inetAddresses = makeFakeAddresses(253, 2);
-    assertConnection(routeSelector.next("GET"), address, NO_PROXY, dns.inetAddresses[0], uriPort,
-        true);
+    assertConnection(routeSelector.nextUnconnected(), address, NO_PROXY, dns.inetAddresses[0],
+        uriPort, TLS_V1);
     dns.assertRequests(uriHost);
-    assertConnection(routeSelector.next("GET"), address, NO_PROXY, dns.inetAddresses[0], uriPort,
-        false);
-    assertConnection(routeSelector.next("GET"), address, NO_PROXY, dns.inetAddresses[1], uriPort,
-        true);
-    assertConnection(routeSelector.next("GET"), address, NO_PROXY, dns.inetAddresses[1], uriPort,
-        false);
+    assertConnection(routeSelector.nextUnconnected(), address, NO_PROXY, dns.inetAddresses[0],
+        uriPort, SSL_V3);
+    assertConnection(routeSelector.nextUnconnected(), address, NO_PROXY, dns.inetAddresses[1],
+        uriPort, TLS_V1);
+    assertConnection(routeSelector.nextUnconnected(), address, NO_PROXY, dns.inetAddresses[1],
+        uriPort, SSL_V3);
 
     assertFalse(routeSelector.hasNext());
   }
 
   @Test public void failedRoutesAreLast() throws Exception {
-    Address address = new Address(uriHost, uriPort, socketFactory, hostnameVerifier, authenticator,
-        Proxy.NO_PROXY, protocols);
+    client.setProxy(Proxy.NO_PROXY);
+    RouteSelector routeSelector = RouteSelector.get(httpsRequest, client);
 
-    RouteDatabase routeDatabase = new RouteDatabase();
-    RouteSelector routeSelector = new RouteSelector(address, uri, proxySelector, pool, dns,
-        routeDatabase);
     dns.inetAddresses = makeFakeAddresses(255, 1);
 
     // Extract the regular sequence of routes from selector.
-    List<Connection> regularRoutes = new ArrayList<Connection>();
+    List<Connection> regularRoutes = new ArrayList<>();
     while (routeSelector.hasNext()) {
-      regularRoutes.add(routeSelector.next("GET"));
+      regularRoutes.add(routeSelector.nextUnconnected());
     }
 
     // Check that we do indeed have more than one route.
@@ -378,11 +382,11 @@
     // Add first regular route as failed.
     routeDatabase.failed(regularRoutes.get(0).getRoute());
     // Reset selector
-    routeSelector = new RouteSelector(address, uri, proxySelector, pool, dns, routeDatabase);
+    routeSelector = RouteSelector.get(httpsRequest, client);
 
-    List<Connection> routesWithFailedRoute = new ArrayList<Connection>();
+    List<Connection> routesWithFailedRoute = new ArrayList<>();
     while (routeSelector.hasNext()) {
-      routesWithFailedRoute.add(routeSelector.next("GET"));
+      routesWithFailedRoute.add(routeSelector.nextUnconnected());
     }
 
     assertEquals(regularRoutes.get(0).getRoute(),
@@ -391,12 +395,17 @@
   }
 
   private void assertConnection(Connection connection, Address address, Proxy proxy,
-      InetAddress socketAddress, int socketPort, boolean modernTls) {
+      InetAddress socketAddress, int socketPort, String tlsVersion) {
     assertEquals(address, connection.getRoute().getAddress());
     assertEquals(proxy, connection.getRoute().getProxy());
     assertEquals(socketAddress, connection.getRoute().getSocketAddress().getAddress());
     assertEquals(socketPort, connection.getRoute().getSocketAddress().getPort());
-    assertEquals(modernTls, connection.getRoute().isModernTls());
+    assertEquals(tlsVersion, connection.getRoute().getTlsVersion());
+  }
+
+  /** Returns an address that's without an SSL socket factory or hostname verifier. */
+  private Address httpAddress() {
+    return new Address(uriHost, uriPort, socketFactory, null, null, authenticator, null, protocols);
   }
 
   private static InetAddress[] makeFakeAddresses(int prefix, int count) {
@@ -412,8 +421,8 @@ private void assertConnection(Connection connection, Address address, Proxy prox
     }
   }
 
-  private static class FakeDns implements Dns {
-    List<String> requestedHosts = new ArrayList<String>();
+  private static class FakeDns implements HostResolver {
+    List<String> requestedHosts = new ArrayList<>();
     InetAddress[] inetAddresses;
 
     @Override public InetAddress[] getAllByName(String host) throws UnknownHostException {
@@ -427,27 +436,4 @@ public void assertRequests(String... expectedHosts) {
       requestedHosts.clear();
     }
   }
-
-  private static class FakeProxySelector extends ProxySelector {
-    List<URI> requestedUris = new ArrayList<URI>();
-    List<Proxy> proxies = new ArrayList<Proxy>();
-    List<String> failures = new ArrayList<String>();
-
-    @Override public List<Proxy> select(URI uri) {
-      requestedUris.add(uri);
-      return proxies;
-    }
-
-    public void assertRequests(URI... expectedUris) {
-      assertEquals(Arrays.asList(expectedUris), requestedUris);
-      requestedUris.clear();
-    }
-
-    @Override public void connectFailed(URI uri, SocketAddress sa, IOException ioe) {
-      InetSocketAddress socketAddress = (InetSocketAddress) sa;
-      failures.add(
-          String.format("%s %s:%d %s", uri, socketAddress.getHostName(), socketAddress.getPort(),
-              ioe.getMessage()));
-    }
-  }
 }
diff --git a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/StatusLineTest.java b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/StatusLineTest.java
index 885570a4db..f339f9ebe6 100644
--- a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/StatusLineTest.java
+++ b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/StatusLineTest.java
@@ -15,6 +15,7 @@
  */
 package com.squareup.okhttp.internal.http;
 
+import com.squareup.okhttp.Protocol;
 import java.io.IOException;
 import java.net.ProtocolException;
 import org.junit.Test;
@@ -27,19 +28,19 @@
     String message = "Temporary Redirect";
     int version = 1;
     int code = 200;
-    StatusLine statusLine = new StatusLine("HTTP/1." + version + " " + code + " " + message);
-    assertEquals(message, statusLine.message());
-    assertEquals(version, statusLine.httpMinorVersion());
-    assertEquals(code, statusLine.code());
+    StatusLine statusLine = StatusLine.parse("HTTP/1." + version + " " + code + " " + message);
+    assertEquals(message, statusLine.message);
+    assertEquals(Protocol.HTTP_1_1, statusLine.protocol);
+    assertEquals(code, statusLine.code);
   }
 
   @Test public void emptyMessage() throws IOException {
     int version = 1;
     int code = 503;
-    StatusLine statusLine = new StatusLine("HTTP/1." + version + " " + code + " ");
-    assertEquals("", statusLine.message());
-    assertEquals(version, statusLine.httpMinorVersion());
-    assertEquals(code, statusLine.code());
+    StatusLine statusLine = StatusLine.parse("HTTP/1." + version + " " + code + " ");
+    assertEquals("", statusLine.message);
+    assertEquals(Protocol.HTTP_1_1, statusLine.protocol);
+    assertEquals(code, statusLine.code);
   }
 
   /**
@@ -50,18 +51,18 @@
   @Test public void emptyMessageAndNoLeadingSpace() throws IOException {
     int version = 1;
     int code = 503;
-    StatusLine statusLine = new StatusLine("HTTP/1." + version + " " + code);
-    assertEquals("", statusLine.message());
-    assertEquals(version, statusLine.httpMinorVersion());
-    assertEquals(code, statusLine.code());
+    StatusLine statusLine = StatusLine.parse("HTTP/1." + version + " " + code);
+    assertEquals("", statusLine.message);
+    assertEquals(Protocol.HTTP_1_1, statusLine.protocol);
+    assertEquals(code, statusLine.code);
   }
 
   // https://github.com/square/okhttp/issues/386
   @Test public void shoutcast() throws IOException {
-    StatusLine statusLine = new StatusLine("ICY 200 OK");
-    assertEquals("OK", statusLine.message());
-    assertEquals(0, statusLine.httpMinorVersion());
-    assertEquals(200, statusLine.code());
+    StatusLine statusLine = StatusLine.parse("ICY 200 OK");
+    assertEquals("OK", statusLine.message);
+    assertEquals(Protocol.HTTP_1_0, statusLine.protocol);
+    assertEquals(200, statusLine.code);
   }
 
   @Test public void missingProtocol() throws IOException {
@@ -109,7 +110,7 @@
 
   private void assertInvalid(String statusLine) throws IOException {
     try {
-      new StatusLine(statusLine);
+      StatusLine.parse(statusLine);
       fail();
     } catch (ProtocolException expected) {
     }
diff --git a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/ThreadInterruptTest.java b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/ThreadInterruptTest.java
new file mode 100644
index 0000000000..6a64034b7c
--- /dev/null
+++ b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/ThreadInterruptTest.java
@@ -0,0 +1,98 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.okhttp.internal.http;
+
+import com.squareup.okhttp.OkHttpClient;
+import com.squareup.okhttp.OkUrlFactory;
+import com.squareup.okhttp.mockwebserver.MockResponse;
+import com.squareup.okhttp.mockwebserver.MockWebServer;
+import java.io.InputStream;
+import java.io.InterruptedIOException;
+import java.io.OutputStream;
+import java.net.HttpURLConnection;
+import java.util.concurrent.TimeUnit;
+import org.junit.Test;
+
+import static org.junit.Assert.fail;
+
+public final class ThreadInterruptTest {
+  private final MockWebServer server = new MockWebServer();
+  private final OkHttpClient client = new OkHttpClient();
+
+  @Test public void interruptWritingRequestBody() throws Exception {
+    int requestBodySize = 2 * 1024 * 1024; // 2 MiB
+
+    server.enqueue(new MockResponse()
+        .throttleBody(64 * 1024, 125, TimeUnit.MILLISECONDS)); // 500 Kbps
+    server.play();
+
+    interruptLater(500);
+
+    HttpURLConnection connection = new OkUrlFactory(client).open(server.getUrl("/"));
+    connection.setDoOutput(true);
+    connection.setFixedLengthStreamingMode(requestBodySize);
+    OutputStream requestBody = connection.getOutputStream();
+    byte[] buffer = new byte[1024];
+    try {
+      for (int i = 0; i < requestBodySize; i += buffer.length) {
+        requestBody.write(buffer);
+        requestBody.flush();
+      }
+      fail("Expected thread to be interrupted");
+    } catch (InterruptedIOException expected) {
+    }
+
+    connection.disconnect();
+  }
+
+  @Test public void interruptReadingResponseBody() throws Exception {
+    int responseBodySize = 2 * 1024 * 1024; // 2 MiB
+
+    server.enqueue(new MockResponse()
+        .setBody(new byte[responseBodySize])
+        .throttleBody(64 * 1024, 125, TimeUnit.MILLISECONDS)); // 500 Kbps
+    server.play();
+
+    interruptLater(500);
+
+    HttpURLConnection connection = new OkUrlFactory(client).open(server.getUrl("/"));
+    InputStream responseBody = connection.getInputStream();
+    byte[] buffer = new byte[1024];
+    try {
+      while (responseBody.read(buffer) != -1) {
+      }
+      fail("Expected thread to be interrupted");
+    } catch (InterruptedIOException expected) {
+    }
+
+    connection.disconnect();
+  }
+
+  private void interruptLater(final int delayMillis) {
+    final Thread toInterrupt = Thread.currentThread();
+    Thread interruptingCow = new Thread() {
+      @Override public void run() {
+        try {
+          sleep(delayMillis);
+          toInterrupt.interrupt();
+        } catch (InterruptedException e) {
+          throw new RuntimeException(e);
+        }
+      }
+    };
+    interruptingCow.start();
+  }
+}
diff --git a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/URLConnectionTest.java b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/URLConnectionTest.java
index 4e791ad898..260f09915d 100644
--- a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/URLConnectionTest.java
+++ b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/URLConnectionTest.java
@@ -16,26 +16,32 @@
 
 package com.squareup.okhttp.internal.http;
 
-import com.squareup.okhttp.HttpResponseCache;
-import com.squareup.okhttp.OkAuthenticator.Credential;
+import com.squareup.okhttp.AbstractResponseCache;
+import com.squareup.okhttp.Cache;
+import com.squareup.okhttp.Challenge;
+import com.squareup.okhttp.ConnectionPool;
+import com.squareup.okhttp.Credentials;
 import com.squareup.okhttp.OkHttpClient;
+import com.squareup.okhttp.OkUrlFactory;
 import com.squareup.okhttp.Protocol;
+import com.squareup.okhttp.Response;
+import com.squareup.okhttp.internal.Internal;
 import com.squareup.okhttp.internal.RecordingAuthenticator;
 import com.squareup.okhttp.internal.RecordingHostnameVerifier;
 import com.squareup.okhttp.internal.RecordingOkAuthenticator;
 import com.squareup.okhttp.internal.SslContextBuilder;
+import com.squareup.okhttp.internal.Util;
+import com.squareup.okhttp.internal.huc.CacheAdapter;
 import com.squareup.okhttp.mockwebserver.MockResponse;
 import com.squareup.okhttp.mockwebserver.MockWebServer;
 import com.squareup.okhttp.mockwebserver.RecordedRequest;
 import com.squareup.okhttp.mockwebserver.SocketPolicy;
-import java.io.ByteArrayOutputStream;
 import java.io.File;
 import java.io.IOException;
 import java.io.InputStream;
 import java.io.OutputStream;
 import java.net.Authenticator;
 import java.net.CacheRequest;
-import java.net.CacheResponse;
 import java.net.ConnectException;
 import java.net.HttpRetryException;
 import java.net.HttpURLConnection;
@@ -43,9 +49,8 @@
 import java.net.ProtocolException;
 import java.net.Proxy;
 import java.net.ProxySelector;
-import java.net.ResponseCache;
+import java.net.Socket;
 import java.net.SocketAddress;
-import java.net.SocketTimeoutException;
 import java.net.URI;
 import java.net.URL;
 import java.net.URLConnection;
@@ -62,9 +67,10 @@
 import java.util.Random;
 import java.util.Set;
 import java.util.UUID;
+import java.util.concurrent.TimeUnit;
 import java.util.concurrent.atomic.AtomicBoolean;
 import java.util.zip.GZIPInputStream;
-import java.util.zip.GZIPOutputStream;
+import javax.net.SocketFactory;
 import javax.net.ssl.HttpsURLConnection;
 import javax.net.ssl.SSLContext;
 import javax.net.ssl.SSLException;
@@ -72,6 +78,10 @@
 import javax.net.ssl.SSLSocketFactory;
 import javax.net.ssl.TrustManager;
 import javax.net.ssl.X509TrustManager;
+import okio.Buffer;
+import okio.BufferedSink;
+import okio.GzipSink;
+import okio.Okio;
 import org.junit.After;
 import org.junit.Before;
 import org.junit.Ignore;
@@ -100,20 +110,21 @@
   private MockWebServer server = new MockWebServer();
   private MockWebServer server2 = new MockWebServer();
 
-  private final OkHttpClient client = new OkHttpClient();
+  private final OkUrlFactory client = new OkUrlFactory(new OkHttpClient());
   private HttpURLConnection connection;
-  private HttpResponseCache cache;
+  private Cache cache;
   private String hostName;
 
   @Before public void setUp() throws Exception {
     hostName = server.getHostName();
-    server.setNpnEnabled(false);
+    server.setProtocolNegotiationEnabled(false);
   }
 
   @After public void tearDown() throws Exception {
     Authenticator.setDefault(null);
     System.clearProperty("proxyHost");
     System.clearProperty("proxyPort");
+    System.clearProperty("http.agent");
     System.clearProperty("http.proxyHost");
     System.clearProperty("http.proxyPort");
     System.clearProperty("https.proxyHost");
@@ -311,7 +322,7 @@ private void testRequestBodySurvivesRetries(TransferKind transferKind) throws Ex
     server2.play();
     FakeProxySelector proxySelector = new FakeProxySelector();
     proxySelector.proxies.add(server2.toProxyAddress());
-    client.setProxySelector(proxySelector);
+    client.client().setProxySelector(proxySelector);
     server2.shutdown();
 
     connection = client.open(server.getUrl("/def"));
@@ -522,8 +533,8 @@ private void doUpload(TransferKind uploadKind, WriteKind writeKind) throws Excep
     server.enqueue(new MockResponse().setBody("this response comes via HTTPS"));
     server.play();
 
-    client.setSslSocketFactory(sslContext.getSocketFactory());
-    client.setHostnameVerifier(new RecordingHostnameVerifier());
+    client.client().setSslSocketFactory(sslContext.getSocketFactory());
+    client.client().setHostnameVerifier(new RecordingHostnameVerifier());
     connection = client.open(server.getUrl("/foo"));
 
     assertContent("this response comes via HTTPS", connection);
@@ -537,8 +548,8 @@ private void doUpload(TransferKind uploadKind, WriteKind writeKind) throws Excep
     server.enqueue(new MockResponse());
     server.play();
 
-    client.setSslSocketFactory(sslContext.getSocketFactory());
-    client.setHostnameVerifier(new RecordingHostnameVerifier());
+    client.client().setSslSocketFactory(sslContext.getSocketFactory());
+    client.client().setHostnameVerifier(new RecordingHostnameVerifier());
 
     HttpsURLConnection httpsConnection = (HttpsURLConnection) client.open(server.getUrl("/foo"));
 
@@ -572,8 +583,8 @@ private void doUpload(TransferKind uploadKind, WriteKind writeKind) throws Excep
     SSLSocketFactory clientSocketFactory = sslContext.getSocketFactory();
     RecordingHostnameVerifier hostnameVerifier = new RecordingHostnameVerifier();
 
-    client.setSslSocketFactory(clientSocketFactory);
-    client.setHostnameVerifier(hostnameVerifier);
+    client.client().setSslSocketFactory(clientSocketFactory);
+    client.client().setHostnameVerifier(hostnameVerifier);
     connection = client.open(server.getUrl("/"));
     assertContent("this response comes via HTTPS", connection);
 
@@ -592,12 +603,12 @@ private void doUpload(TransferKind uploadKind, WriteKind writeKind) throws Excep
     server.play();
 
     // install a custom SSL socket factory so the server can be authorized
-    client.setSslSocketFactory(sslContext.getSocketFactory());
-    client.setHostnameVerifier(new RecordingHostnameVerifier());
+    client.client().setSslSocketFactory(sslContext.getSocketFactory());
+    client.client().setHostnameVerifier(new RecordingHostnameVerifier());
     HttpURLConnection connection1 = client.open(server.getUrl("/"));
     assertContent("this response comes via HTTPS", connection1);
 
-    client.setSslSocketFactory(null);
+    client.client().setSslSocketFactory(null);
     HttpURLConnection connection2 = client.open(server.getUrl("/"));
     try {
       readAscii(connection2.getInputStream(), Integer.MAX_VALUE);
@@ -612,8 +623,8 @@ private void doUpload(TransferKind uploadKind, WriteKind writeKind) throws Excep
     server.enqueue(new MockResponse().setBody("this response comes via SSL"));
     server.play();
 
-    client.setSslSocketFactory(sslContext.getSocketFactory());
-    client.setHostnameVerifier(new RecordingHostnameVerifier());
+    client.client().setSslSocketFactory(sslContext.getSocketFactory());
+    client.client().setHostnameVerifier(new RecordingHostnameVerifier());
     connection = client.open(server.getUrl("/foo"));
 
     assertContent("this response comes via SSL", connection);
@@ -636,17 +647,17 @@ private void doUpload(TransferKind uploadKind, WriteKind writeKind) throws Excep
     server.enqueue(new MockResponse().setBody("def"));
     server.play();
 
-    client.setSslSocketFactory(sslContext.getSocketFactory());
-    client.setHostnameVerifier(new RecordingHostnameVerifier());
+    client.client().setSslSocketFactory(sslContext.getSocketFactory());
+    client.client().setHostnameVerifier(new RecordingHostnameVerifier());
 
     assertContent("abc", client.open(server.getUrl("/")));
     assertContent("def", client.open(server.getUrl("/")));
 
     RecordedRequest request1 = server.takeRequest();
-    assertEquals("TLSv1", request1.getSslProtocol()); // OkHttp's current best TLS version.
+    assertTrue(request1.getSslProtocol().startsWith("TLSv1")); // v1.2 on OpenJDK 8.
 
     RecordedRequest request2 = server.takeRequest();
-    assertEquals("TLSv1", request2.getSslProtocol()); // OkHttp's current best TLS version.
+    assertTrue(request2.getSslProtocol().startsWith("TLSv1")); // v1.2 on OpenJDK 8.
   }
 
   /**
@@ -705,13 +716,55 @@ private void testConnectViaProxy(ProxyConfig proxyConfig) throws Exception {
     assertContent("abc", client.open(server.getUrl("/")));
   }
 
+  public void testConnectViaSocketFactory(boolean useHttps) throws IOException {
+    SocketFactory uselessSocketFactory = new SocketFactory() {
+      public Socket createSocket() { throw new IllegalArgumentException("useless"); }
+      public Socket createSocket(InetAddress host, int port) { return null; }
+      public Socket createSocket(InetAddress address, int port, InetAddress localAddress,
+          int localPort) { return null; }
+      public Socket createSocket(String host, int port) { return null; }
+      public Socket createSocket(String host, int port, InetAddress localHost, int localPort) {
+        return null;
+      }
+    };
+
+    if (useHttps) {
+      server.useHttps(sslContext.getSocketFactory(), false);
+      client.client().setSslSocketFactory(sslContext.getSocketFactory());
+      client.client().setHostnameVerifier(new RecordingHostnameVerifier());
+    }
+
+    server.enqueue(new MockResponse().setStatus("HTTP/1.1 200 OK"));
+    server.play();
+
+    client.client().setSocketFactory(uselessSocketFactory);
+    connection = client.open(server.getUrl("/"));
+    try {
+      connection.getResponseCode();
+      fail();
+    } catch (IllegalArgumentException expected) {
+    }
+
+    client.client().setSocketFactory(SocketFactory.getDefault());
+    connection = client.open(server.getUrl("/"));
+    assertEquals(200, connection.getResponseCode());
+  }
+
+  @Test public void connectHttpViaSocketFactory() throws Exception {
+    testConnectViaSocketFactory(false);
+  }
+
+  @Test public void connectHttpsViaSocketFactory() throws Exception {
+    testConnectViaSocketFactory(true);
+  }
+
   @Test public void contentDisagreesWithChunkedHeader() throws IOException {
     MockResponse mockResponse = new MockResponse();
     mockResponse.setChunkedBody("abc", 3);
-    ByteArrayOutputStream bytesOut = new ByteArrayOutputStream();
-    bytesOut.write(mockResponse.getBody());
-    bytesOut.write("\r\nYOU SHOULD NOT SEE THIS".getBytes("UTF-8"));
-    mockResponse.setBody(bytesOut.toByteArray());
+    Buffer buffer = new Buffer();
+    buffer.writeAll(mockResponse.getBody());
+    buffer.write("\r\nYOU SHOULD NOT SEE THIS".getBytes("UTF-8"));
+    mockResponse.setBody(buffer);
     mockResponse.clearHeaders();
     mockResponse.addHeader("Transfer-encoding: chunked");
 
@@ -736,8 +789,8 @@ private void testConnectViaDirectProxyToHttps(ProxyConfig proxyConfig) throws Ex
     server.play();
 
     URL url = server.getUrl("/foo");
-    client.setSslSocketFactory(sslContext.getSocketFactory());
-    client.setHostnameVerifier(new RecordingHostnameVerifier());
+    client.client().setSslSocketFactory(sslContext.getSocketFactory());
+    client.client().setHostnameVerifier(new RecordingHostnameVerifier());
     connection = proxyConfig.connect(server, client, url);
 
     assertContent("this response comes via HTTPS", connection);
@@ -776,8 +829,8 @@ private void testConnectViaHttpProxyToHttps(ProxyConfig proxyConfig) throws Exce
     server.play();
 
     URL url = new URL("https://android.com/foo");
-    client.setSslSocketFactory(sslContext.getSocketFactory());
-    client.setHostnameVerifier(hostnameVerifier);
+    client.client().setSslSocketFactory(sslContext.getSocketFactory());
+    client.client().setHostnameVerifier(hostnameVerifier);
     connection = proxyConfig.connect(server, client, url);
 
     assertContent("this response comes via a secure proxy", connection);
@@ -793,7 +846,7 @@ private void testConnectViaHttpProxyToHttps(ProxyConfig proxyConfig) throws Exce
     assertEquals(Arrays.asList("verify android.com"), hostnameVerifier.calls);
   }
 
-  /** Tolerate bad https proxy response when using HttpResponseCache. http://b/6754912 */
+  /** Tolerate bad https proxy response when using a cache. http://b/6754912 */
   @Test public void connectViaHttpProxyToHttpsUsingBadProxyAndHttpResponseCache() throws Exception {
     initResponseCache();
 
@@ -810,10 +863,10 @@ private void testConnectViaHttpProxyToHttps(ProxyConfig proxyConfig) throws Exce
       server.enqueue(response); // For the backwards-compatible SSLv3 retry
     }
     server.play();
-    client.setProxy(server.toProxyAddress());
+    client.client().setProxy(server.toProxyAddress());
 
     URL url = new URL("https://android.com/foo");
-    client.setSslSocketFactory(sslContext.getSocketFactory());
+    client.client().setSslSocketFactory(sslContext.getSocketFactory());
     connection = client.open(url);
 
     try {
@@ -834,8 +887,8 @@ private void testConnectViaHttpProxyToHttps(ProxyConfig proxyConfig) throws Exce
   private void initResponseCache() throws IOException {
     String tmp = System.getProperty("java.io.tmpdir");
     File cacheDir = new File(tmp, "HttpCache-" + UUID.randomUUID());
-    cache = new HttpResponseCache(cacheDir, Integer.MAX_VALUE);
-    client.setOkResponseCache(cache);
+    cache = new Cache(cacheDir, Integer.MAX_VALUE);
+    client.client().setCache(cache);
   }
 
   /** Test which headers are sent unencrypted to the HTTP proxy. */
@@ -848,11 +901,11 @@ private void initResponseCache() throws IOException {
         new MockResponse().setSocketPolicy(SocketPolicy.UPGRADE_TO_SSL_AT_END).clearHeaders());
     server.enqueue(new MockResponse().setBody("encrypted response from the origin server"));
     server.play();
-    client.setProxy(server.toProxyAddress());
+    client.client().setProxy(server.toProxyAddress());
 
     URL url = new URL("https://android.com/foo");
-    client.setSslSocketFactory(sslContext.getSocketFactory());
-    client.setHostnameVerifier(hostnameVerifier);
+    client.client().setSslSocketFactory(sslContext.getSocketFactory());
+    client.client().setHostnameVerifier(hostnameVerifier);
     connection = client.open(url);
     connection.addRequestProperty("Private", "Secret");
     connection.addRequestProperty("Proxy-Authorization", "bar");
@@ -880,11 +933,11 @@ private void initResponseCache() throws IOException {
         new MockResponse().setSocketPolicy(SocketPolicy.UPGRADE_TO_SSL_AT_END).clearHeaders());
     server.enqueue(new MockResponse().setBody("A"));
     server.play();
-    client.setProxy(server.toProxyAddress());
+    client.client().setProxy(server.toProxyAddress());
 
     URL url = new URL("https://android.com/foo");
-    client.setSslSocketFactory(sslContext.getSocketFactory());
-    client.setHostnameVerifier(new RecordingHostnameVerifier());
+    client.client().setSslSocketFactory(sslContext.getSocketFactory());
+    client.client().setHostnameVerifier(new RecordingHostnameVerifier());
     connection = client.open(url);
     assertContent("A", connection);
 
@@ -910,11 +963,11 @@ private void initResponseCache() throws IOException {
         new MockResponse().setSocketPolicy(SocketPolicy.UPGRADE_TO_SSL_AT_END).clearHeaders());
     server.enqueue(new MockResponse().setBody("this response comes via a proxy"));
     server.play();
-    client.setProxy(server.toProxyAddress());
+    client.client().setProxy(server.toProxyAddress());
 
     URL url = new URL("https://android.com/foo");
-    client.setSslSocketFactory(sslContext.getSocketFactory());
-    client.setHostnameVerifier(new RecordingHostnameVerifier());
+    client.client().setSslSocketFactory(sslContext.getSocketFactory());
+    client.client().setHostnameVerifier(new RecordingHostnameVerifier());
     connection = client.open(url);
     connection.setRequestProperty("Connection", "close");
 
@@ -931,17 +984,19 @@ private void initResponseCache() throws IOException {
     server.enqueue(new MockResponse().setBody("response 1"));
     server.enqueue(new MockResponse().setBody("response 2"));
     server.play();
-    client.setProxy(server.toProxyAddress());
+    client.client().setProxy(server.toProxyAddress());
 
     URL url = new URL("https://android.com/foo");
-    client.setSslSocketFactory(socketFactory);
-    client.setHostnameVerifier(hostnameVerifier);
+    client.client().setSslSocketFactory(socketFactory);
+    client.client().setHostnameVerifier(hostnameVerifier);
     assertContent("response 1", client.open(url));
     assertContent("response 2", client.open(url));
   }
 
   @Test public void disconnectedConnection() throws IOException {
-    server.enqueue(new MockResponse().setBody("ABCDEFGHIJKLMNOPQR"));
+    server.enqueue(new MockResponse()
+        .throttleBody(2, 100, TimeUnit.MILLISECONDS)
+        .setBody("ABCD"));
     server.play();
 
     connection = client.open(server.getUrl("/"));
@@ -949,6 +1004,10 @@ private void initResponseCache() throws IOException {
     assertEquals('A', (char) in.read());
     connection.disconnect();
     try {
+      // Reading 'B' may succeed if it's buffered.
+      in.read();
+
+      // But 'C' shouldn't be buffered (the response is throttled) and this should fail.
       in.read();
       fail("Expected a connection closed exception");
     } catch (IOException expected) {
@@ -1078,7 +1137,8 @@ private void testMarkAndReset(TransferKind transferKind) throws IOException {
    * imply a bug in the implementation.
    */
   @Test public void gzipEncodingEnabledByDefault() throws IOException, InterruptedException {
-    server.enqueue(new MockResponse().setBody(gzip("ABCABCABC".getBytes("UTF-8")))
+    server.enqueue(new MockResponse()
+        .setBody(gzip("ABCABCABC"))
         .addHeader("Content-Encoding: gzip"));
     server.play();
 
@@ -1092,7 +1152,7 @@ private void testMarkAndReset(TransferKind transferKind) throws IOException {
   }
 
   @Test public void clientConfiguredGzipContentEncoding() throws Exception {
-    byte[] bodyBytes = gzip("ABCDEFGHIJKLMNOPQRSTUVWXYZ".getBytes("UTF-8"));
+    Buffer bodyBytes = gzip("ABCDEFGHIJKLMNOPQRSTUVWXYZ");
     server.enqueue(new MockResponse()
         .setBody(bodyBytes)
         .addHeader("Content-Encoding: gzip"));
@@ -1102,7 +1162,7 @@ private void testMarkAndReset(TransferKind transferKind) throws IOException {
     connection.addRequestProperty("Accept-Encoding", "gzip");
     InputStream gunzippedIn = new GZIPInputStream(connection.getInputStream());
     assertEquals("ABCDEFGHIJKLMNOPQRSTUVWXYZ", readAscii(gunzippedIn, Integer.MAX_VALUE));
-    assertEquals(bodyBytes.length, connection.getContentLength());
+    assertEquals(bodyBytes.size(), connection.getContentLength());
 
     RecordedRequest request = server.takeRequest();
     assertContains(request.getHeaders(), "Accept-Encoding: gzip");
@@ -1148,13 +1208,13 @@ private void testClientConfiguredGzipContentEncodingAndConnectionReuse(TransferK
       SSLSocketFactory socketFactory = sslContext.getSocketFactory();
       RecordingHostnameVerifier hostnameVerifier = new RecordingHostnameVerifier();
       server.useHttps(socketFactory, false);
-      client.setSslSocketFactory(socketFactory);
-      client.setHostnameVerifier(hostnameVerifier);
+      client.client().setSslSocketFactory(socketFactory);
+      client.client().setHostnameVerifier(hostnameVerifier);
     }
 
     MockResponse responseOne = new MockResponse();
     responseOne.addHeader("Content-Encoding: gzip");
-    transferKind.setBody(responseOne, gzip("one (gzipped)".getBytes("UTF-8")), 5);
+    transferKind.setBody(responseOne, gzip("one (gzipped)"), 5);
     server.enqueue(responseOne);
     MockResponse responseTwo = new MockResponse();
     transferKind.setBody(responseTwo, "two (identity)", 5);
@@ -1172,6 +1232,41 @@ private void testClientConfiguredGzipContentEncodingAndConnectionReuse(TransferK
     assertEquals(1, server.takeRequest().getSequenceNumber());
   }
 
+  @Test public void transparentGzipWorksAfterExceptionRecovery() throws Exception {
+    server.enqueue(new MockResponse()
+        .setBody("a")
+        .setSocketPolicy(SHUTDOWN_INPUT_AT_END));
+    server.enqueue(new MockResponse()
+        .addHeader("Content-Encoding: gzip")
+        .setBody(gzip("b")));
+    server.play();
+
+    // Seed the pool with a bad connection.
+    assertContent("a", client.open(server.getUrl("/")));
+
+    // This connection will need to be recovered. When it is, transparent gzip should still work!
+    assertContent("b", client.open(server.getUrl("/")));
+
+    assertEquals(0, server.takeRequest().getSequenceNumber());
+    assertEquals(0, server.takeRequest().getSequenceNumber()); // Connection is not pooled.
+  }
+
+  @Test public void endOfStreamResponseIsNotPooled() throws Exception {
+    server.enqueue(new MockResponse()
+        .setBody("{}")
+        .clearHeaders()
+        .setSocketPolicy(DISCONNECT_AT_END));
+    server.play();
+
+    ConnectionPool pool = ConnectionPool.getDefault();
+    pool.evictAll();
+    client.client().setConnectionPool(pool);
+
+    HttpURLConnection connection = client.open(server.getUrl("/"));
+    assertContent("{}", connection);
+    assertEquals(0, client.client().getConnectionPool().getConnectionCount());
+  }
+
   @Test public void earlyDisconnectDoesntHarmPoolingWithChunkedEncoding() throws Exception {
     testEarlyDisconnectDoesntHarmPooling(TransferKind.CHUNKED);
   }
@@ -1194,11 +1289,13 @@ private void testEarlyDisconnectDoesntHarmPooling(TransferKind transferKind) thr
     HttpURLConnection connection1 = client.open(server.getUrl("/"));
     InputStream in1 = connection1.getInputStream();
     assertEquals("ABCDE", readAscii(in1, 5));
+    in1.close();
     connection1.disconnect();
 
     HttpURLConnection connection2 = client.open(server.getUrl("/"));
     InputStream in2 = connection2.getInputStream();
     assertEquals("LMNOP", readAscii(in2, 5));
+    in2.close();
     connection2.disconnect();
 
     assertEquals(0, server.takeRequest().getSequenceNumber());
@@ -1208,7 +1305,7 @@ private void testEarlyDisconnectDoesntHarmPooling(TransferKind transferKind) thr
   @Test public void streamDiscardingIsTimely() throws Exception {
     // This response takes at least a full second to serve: 10,000 bytes served 100 bytes at a time.
     server.enqueue(new MockResponse()
-        .setBody(new byte[10000])
+        .setBody(new Buffer().write(new byte[10000]))
         .throttleBody(100, 10, MILLISECONDS));
     server.enqueue(new MockResponse().setBody("A"));
     server.play();
@@ -1315,7 +1412,7 @@ private void testAuthenticateWithStreamingPost(StreamingMode streamingMode) thro
     String call = calls.get(0);
     assertTrue(call, call.contains("host=" + url.getHost()));
     assertTrue(call, call.contains("port=" + url.getPort()));
-    assertTrue(call, call.contains("site=" + InetAddress.getAllByName(url.getHost())[0]));
+    assertTrue(call, call.contains("site=" + url.getHost()));
     assertTrue(call, call.contains("url=" + url));
     assertTrue(call, call.contains("type=" + Authenticator.RequestorType.SERVER));
     assertTrue(call, call.contains("prompt=Bar"));
@@ -1330,7 +1427,7 @@ private void testAuthenticateWithStreamingPost(StreamingMode streamingMode) thro
     String call = calls.get(0);
     assertTrue(call, call.contains("host=" + url.getHost()));
     assertTrue(call, call.contains("port=" + url.getPort()));
-    assertTrue(call, call.contains("site=" + InetAddress.getAllByName(url.getHost())[0]));
+    assertTrue(call, call.contains("site=" + url.getHost()));
     assertTrue(call, call.contains("url=http://android.com"));
     assertTrue(call, call.contains("type=" + Authenticator.RequestorType.PROXY));
     assertTrue(call, call.contains("prompt=Bar"));
@@ -1350,7 +1447,7 @@ private void testAuthenticateWithStreamingPost(StreamingMode streamingMode) thro
     server.play();
 
     if (proxy) {
-      client.setProxy(server.toProxyAddress());
+      client.client().setProxy(server.toProxyAddress());
       connection = client.open(new URL("http://android.com"));
     } else {
       connection = client.open(server.getUrl("/"));
@@ -1501,8 +1598,8 @@ private void testSecureStreamingPost(StreamingMode streamingMode) throws Excepti
     server.enqueue(new MockResponse().setBody("Success!"));
     server.play();
 
-    client.setSslSocketFactory(sslContext.getSocketFactory());
-    client.setHostnameVerifier(new RecordingHostnameVerifier());
+    client.client().setSslSocketFactory(sslContext.getSocketFactory());
+    client.client().setHostnameVerifier(new RecordingHostnameVerifier());
     connection = client.open(server.getUrl("/"));
     connection.setDoOutput(true);
     byte[] requestBody = { 'A', 'B', 'C', 'D' };
@@ -1594,6 +1691,39 @@ private void testSecureStreamingPost(StreamingMode streamingMode) throws Excepti
     }
   }
 
+  /** https://code.google.com/p/android/issues/detail?id=74026 */
+  @Test public void authenticateWithGetAndTransparentGzip() throws Exception {
+    MockResponse pleaseAuthenticate = new MockResponse().setResponseCode(401)
+        .addHeader("WWW-Authenticate: Basic realm=\"protected area\"")
+        .setBody("Please authenticate.");
+    // fail auth three times...
+    server.enqueue(pleaseAuthenticate);
+    server.enqueue(pleaseAuthenticate);
+    server.enqueue(pleaseAuthenticate);
+    // ...then succeed the fourth time
+    MockResponse successfulResponse = new MockResponse()
+        .addHeader("Content-Encoding", "gzip")
+        .setBody(gzip("Successful auth!"));
+    server.enqueue(successfulResponse);
+    server.play();
+
+    Authenticator.setDefault(new RecordingAuthenticator());
+    connection = client.open(server.getUrl("/"));
+    assertEquals("Successful auth!", readAscii(connection.getInputStream(), Integer.MAX_VALUE));
+
+    // no authorization header for the first request...
+    RecordedRequest request = server.takeRequest();
+    assertContainsNoneMatching(request.getHeaders(), "Authorization: Basic .*");
+
+    // ...but the three requests that follow requests include an authorization header
+    for (int i = 0; i < 3; i++) {
+      request = server.takeRequest();
+      assertEquals("GET / HTTP/1.1", request.getRequestLine());
+      assertContains(request.getHeaders(),
+          "Authorization: Basic " + RecordingAuthenticator.BASE_64_CREDENTIALS);
+    }
+  }
+
   /** https://github.com/square/okhttp/issues/342 */
   @Test public void authenticateRealmUppercase() throws Exception {
     server.enqueue(new MockResponse().setResponseCode(401)
@@ -1648,8 +1778,8 @@ private void testRedirected(TransferKind transferKind, boolean reuse) throws Exc
     server.enqueue(new MockResponse().setBody("This is the new location!"));
     server.play();
 
-    client.setSslSocketFactory(sslContext.getSocketFactory());
-    client.setHostnameVerifier(new RecordingHostnameVerifier());
+    client.client().setSslSocketFactory(sslContext.getSocketFactory());
+    client.client().setHostnameVerifier(new RecordingHostnameVerifier());
     connection = client.open(server.getUrl("/"));
     assertEquals("This is the new location!",
         readAscii(connection.getInputStream(), Integer.MAX_VALUE));
@@ -1668,9 +1798,9 @@ private void testRedirected(TransferKind transferKind, boolean reuse) throws Exc
         .setBody("This page has moved!"));
     server.play();
 
-    client.setFollowProtocolRedirects(false);
-    client.setSslSocketFactory(sslContext.getSocketFactory());
-    client.setHostnameVerifier(new RecordingHostnameVerifier());
+    client.client().setFollowSslRedirects(false);
+    client.client().setSslSocketFactory(sslContext.getSocketFactory());
+    client.client().setHostnameVerifier(new RecordingHostnameVerifier());
     connection = client.open(server.getUrl("/"));
     assertEquals("This page has moved!", readAscii(connection.getInputStream(), Integer.MAX_VALUE));
   }
@@ -1681,7 +1811,7 @@ private void testRedirected(TransferKind transferKind, boolean reuse) throws Exc
         .setBody("This page has moved!"));
     server.play();
 
-    client.setFollowProtocolRedirects(false);
+    client.client().setFollowSslRedirects(false);
     connection = client.open(server.getUrl("/"));
     assertEquals("This page has moved!", readAscii(connection.getInputStream(), Integer.MAX_VALUE));
   }
@@ -1697,9 +1827,9 @@ private void testRedirected(TransferKind transferKind, boolean reuse) throws Exc
         .setBody("This page has moved!"));
     server.play();
 
-    client.setSslSocketFactory(sslContext.getSocketFactory());
-    client.setHostnameVerifier(new RecordingHostnameVerifier());
-    client.setFollowProtocolRedirects(true);
+    client.client().setSslSocketFactory(sslContext.getSocketFactory());
+    client.client().setHostnameVerifier(new RecordingHostnameVerifier());
+    client.client().setFollowSslRedirects(true);
     HttpsURLConnection connection = (HttpsURLConnection) client.open(server.getUrl("/"));
     assertContent("This is insecure HTTP!", connection);
     assertNull(connection.getCipherSuite());
@@ -1720,9 +1850,9 @@ private void testRedirected(TransferKind transferKind, boolean reuse) throws Exc
         .setBody("This page has moved!"));
     server.play();
 
-    client.setSslSocketFactory(sslContext.getSocketFactory());
-    client.setHostnameVerifier(new RecordingHostnameVerifier());
-    client.setFollowProtocolRedirects(true);
+    client.client().setSslSocketFactory(sslContext.getSocketFactory());
+    client.client().setHostnameVerifier(new RecordingHostnameVerifier());
+    client.client().setFollowSslRedirects(true);
     connection = client.open(server.getUrl("/"));
     assertContent("This is secure HTTPS!", connection);
     assertFalse(connection instanceof HttpsURLConnection);
@@ -1741,9 +1871,9 @@ private void redirectToAnotherOriginServer(boolean https) throws Exception {
     if (https) {
       server.useHttps(sslContext.getSocketFactory(), false);
       server2.useHttps(sslContext.getSocketFactory(), false);
-      server2.setNpnEnabled(false);
-      client.setSslSocketFactory(sslContext.getSocketFactory());
-      client.setHostnameVerifier(new RecordingHostnameVerifier());
+      server2.setProtocolNegotiationEnabled(false);
+      client.client().setSslSocketFactory(sslContext.getSocketFactory());
+      client.client().setHostnameVerifier(new RecordingHostnameVerifier());
     }
 
     server2.enqueue(new MockResponse().setBody("This is the 2nd server!"));
@@ -1774,18 +1904,18 @@ private void redirectToAnotherOriginServer(boolean https) throws Exception {
 
   @Test public void redirectWithProxySelector() throws Exception {
     final List<URI> proxySelectionRequests = new ArrayList<URI>();
-    client.setProxySelector(new ProxySelector() {
+    client.client().setProxySelector(new ProxySelector() {
       @Override public List<Proxy> select(URI uri) {
         proxySelectionRequests.add(uri);
         MockWebServer proxyServer = (uri.getPort() == server.getPort()) ? server : server2;
         return Arrays.asList(proxyServer.toProxyAddress());
       }
+
       @Override public void connectFailed(URI uri, SocketAddress address, IOException failure) {
         throw new AssertionError();
       }
     });
 
-    server2 = new MockWebServer();
     server2.enqueue(new MockResponse().setBody("This is the 2nd server!"));
     server2.play();
 
@@ -1802,24 +1932,51 @@ private void redirectToAnotherOriginServer(boolean https) throws Exception {
     server2.shutdown();
   }
 
+  @Test public void redirectWithAuthentication() throws Exception {
+    server2.enqueue(new MockResponse().setBody("Page 2"));
+    server2.play();
+
+    server.enqueue(new MockResponse().setResponseCode(401));
+    server.enqueue(new MockResponse().setResponseCode(302)
+        .addHeader("Location: " + server2.getUrl("/b")));
+    server.play();
+
+    client.client().setAuthenticator(
+        new RecordingOkAuthenticator(Credentials.basic("jesse", "secret")));
+    assertContent("Page 2", client.open(server.getUrl("/a")));
+
+    RecordedRequest redirectRequest = server2.takeRequest();
+    assertContainsNoneMatching(redirectRequest.getHeaders(), "Authorization.*");
+    assertEquals("/b", redirectRequest.getPath());
+  }
+
   @Test public void response300MultipleChoiceWithPost() throws Exception {
     // Chrome doesn't follow the redirect, but Firefox and the RI both do
-    testResponseRedirectedWithPost(HttpURLConnection.HTTP_MULT_CHOICE);
+    testResponseRedirectedWithPost(HttpURLConnection.HTTP_MULT_CHOICE, TransferKind.END_OF_STREAM);
   }
 
   @Test public void response301MovedPermanentlyWithPost() throws Exception {
-    testResponseRedirectedWithPost(HttpURLConnection.HTTP_MOVED_PERM);
+    testResponseRedirectedWithPost(HttpURLConnection.HTTP_MOVED_PERM, TransferKind.END_OF_STREAM);
   }
 
   @Test public void response302MovedTemporarilyWithPost() throws Exception {
-    testResponseRedirectedWithPost(HttpURLConnection.HTTP_MOVED_TEMP);
+    testResponseRedirectedWithPost(HttpURLConnection.HTTP_MOVED_TEMP, TransferKind.END_OF_STREAM);
   }
 
   @Test public void response303SeeOtherWithPost() throws Exception {
-    testResponseRedirectedWithPost(HttpURLConnection.HTTP_SEE_OTHER);
+    testResponseRedirectedWithPost(HttpURLConnection.HTTP_SEE_OTHER, TransferKind.END_OF_STREAM);
   }
 
-  private void testResponseRedirectedWithPost(int redirectCode) throws Exception {
+  @Test public void postRedirectToGetWithChunkedRequest() throws Exception {
+    testResponseRedirectedWithPost(HttpURLConnection.HTTP_MOVED_TEMP, TransferKind.CHUNKED);
+  }
+
+  @Test public void postRedirectToGetWithStreamedRequest() throws Exception {
+    testResponseRedirectedWithPost(HttpURLConnection.HTTP_MOVED_TEMP, TransferKind.FIXED_LENGTH);
+  }
+
+  private void testResponseRedirectedWithPost(int redirectCode, TransferKind transferKind)
+      throws Exception {
     server.enqueue(new MockResponse().setResponseCode(redirectCode)
         .addHeader("Location: /page2")
         .setBody("This page has moved!"));
@@ -1828,6 +1985,7 @@ private void testResponseRedirectedWithPost(int redirectCode) throws Exception {
 
     connection = client.open(server.getUrl("/page1"));
     connection.setDoOutput(true);
+    transferKind.setForRequest(connection, 4);
     byte[] requestBody = { 'A', 'B', 'C', 'D' };
     OutputStream outputStream = connection.getOutputStream();
     outputStream.write(requestBody);
@@ -1864,9 +2022,9 @@ private void testResponseRedirectedWithPost(int redirectCode) throws Exception {
 
     RecordedRequest page2 = server.takeRequest();
     assertEquals("GET /page2 HTTP/1.1", page2.getRequestLine());
-    assertContainsNoneMatching(page2.getHeaders(), "Content-Length");
-    assertContains(page2.getHeaders(), "Content-Type: text/plain; charset=utf-8");
-    assertContains(page2.getHeaders(), "Transfer-Encoding: identity");
+    assertContainsNoneMatching(page2.getHeaders(), "Content-Length.*");
+    assertContainsNoneMatching(page2.getHeaders(), "Content-Type.*");
+    assertContainsNoneMatching(page2.getHeaders(), "Transfer-Encoding.*");
   }
 
   @Test public void response305UseProxy() throws Exception {
@@ -1989,8 +2147,8 @@ private void test307Redirect(String method) throws Exception {
     SSLContext sc = SSLContext.getInstance("TLS");
     sc.init(null, new TrustManager[] { trustManager }, new java.security.SecureRandom());
 
-    client.setHostnameVerifier(hostnameVerifier);
-    client.setSslSocketFactory(sc.getSocketFactory());
+    client.client().setHostnameVerifier(hostnameVerifier);
+    client.client().setSslSocketFactory(sc.getSocketFactory());
     server.useHttps(sslContext.getSocketFactory(), false);
     server.enqueue(new MockResponse().setBody("ABC"));
     server.enqueue(new MockResponse().setBody("DEF"));
@@ -2025,7 +2183,26 @@ private void test307Redirect(String method) throws Exception {
     try {
       in.read(); // if Content-Length was accurate, this would return -1 immediately
       fail();
-    } catch (SocketTimeoutException expected) {
+    } catch (IOException expected) {
+    }
+  }
+
+  /** Confirm that an unacknowledged write times out. */
+  @Test public void writeTimeouts() throws IOException {
+    server.enqueue(new MockResponse()
+        .throttleBody(1, 3600, TimeUnit.SECONDS)); // Prevent the server from reading!
+    server.play();
+
+    client.client().setWriteTimeout(500, TimeUnit.MILLISECONDS);
+    connection = client.open(server.getUrl("/"));
+    connection.setDoOutput(true);
+    connection.setChunkedStreamingMode(0);
+    OutputStream out = connection.getOutputStream();
+    try {
+      byte[] data = new byte[1024 * 1024]; // 1 MiB.
+      out.write(data);
+      fail();
+    } catch (IOException expected) {
     }
   }
 
@@ -2121,7 +2298,7 @@ private void test307Redirect(String method) throws Exception {
   }
 
   @Test public void singleByteReadIsSigned() throws IOException {
-    server.enqueue(new MockResponse().setBody(new byte[] {-2, -1}));
+    server.enqueue(new MockResponse().setBody(new Buffer().writeByte(-2).writeByte(-1)));
     server.play();
 
     connection = client.open(server.getUrl("/"));
@@ -2238,12 +2415,7 @@ private void testFlushAfterStreamTransmitted(TransferKind transferKind) throws I
   /** Don't explode if the cache returns a null body. http://b/3373699 */
   @Test public void responseCacheReturnsNullOutputStream() throws Exception {
     final AtomicBoolean aborted = new AtomicBoolean();
-    client.setResponseCache(new ResponseCache() {
-      @Override public CacheResponse get(URI uri, String requestMethod,
-          Map<String, List<String>> requestHeaders) throws IOException {
-        return null;
-      }
-
+    Internal.instance.setCache(client.client(), new CacheAdapter(new AbstractResponseCache() {
       @Override public CacheRequest put(URI uri, URLConnection connection) throws IOException {
         return new CacheRequest() {
           @Override public void abort() {
@@ -2255,7 +2427,7 @@ private void testFlushAfterStreamTransmitted(TransferKind transferKind) throws I
           }
         };
       }
-    });
+    }));
 
     server.enqueue(new MockResponse().setBody("abcdef"));
     server.play();
@@ -2304,7 +2476,7 @@ private void testFlushAfterStreamTransmitted(TransferKind transferKind) throws I
       fail();
     } catch (NullPointerException expected) {
     }
-    assertNull(connection.getContent(new Class[] {getClass()}));
+    assertNull(connection.getContent(new Class[]{getClass()}));
   }
 
   @Test public void getOutputStreamOnGetFails() throws Exception {
@@ -2392,6 +2564,18 @@ private void testFlushAfterStreamTransmitted(TransferKind transferKind) throws I
     assertEquals("GET /?query HTTP/1.1", request.getRequestLine());
   }
 
+  @Test public void doOutputForMethodThatDoesntSupportOutput() throws Exception {
+    server.play();
+    connection = client.open(server.getUrl("/"));
+    connection.setRequestMethod("HEAD");
+    connection.setDoOutput(true);
+    try {
+      connection.connect();
+      fail();
+    } catch (IOException expected) {
+    }
+  }
+
   // http://code.google.com/p/android/issues/detail?id=20442
   @Test public void inputStreamAvailableWithChunkedEncoding() throws Exception {
     testInputStreamAvailable(TransferKind.CHUNKED);
@@ -2448,7 +2632,7 @@ private void testInputStreamAvailable(TransferKind transferKind) throws IOExcept
 
   private void reusedConnectionFailsWithPost(TransferKind transferKind, int requestSize)
       throws Exception {
-    server.enqueue(new MockResponse().setBody("A").setSocketPolicy(SHUTDOWN_INPUT_AT_END));
+    server.enqueue(new MockResponse().setBody("A").setSocketPolicy(DISCONNECT_AT_END));
     server.enqueue(new MockResponse().setBody("B"));
     server.enqueue(new MockResponse().setBody("C"));
     server.play();
@@ -2475,6 +2659,32 @@ private void reusedConnectionFailsWithPost(TransferKind transferKind, int reques
     assertEquals(Arrays.toString(requestBody), Arrays.toString(requestB.getBody()));
   }
 
+  @Test public void postBodyRetransmittedOnFailureRecovery() throws Exception {
+    server.enqueue(new MockResponse().setBody("abc"));
+    server.enqueue(new MockResponse().setSocketPolicy(SocketPolicy.DISCONNECT_AFTER_REQUEST));
+    server.enqueue(new MockResponse().setBody("def"));
+    server.play();
+
+    // Seed the connection pool so we have something that can fail.
+    assertContent("abc", client.open(server.getUrl("/")));
+
+    HttpURLConnection post = client.open(server.getUrl("/"));
+    post.setDoOutput(true);
+    post.getOutputStream().write("body!".getBytes(Util.UTF_8));
+    assertContent("def", post);
+
+    RecordedRequest get = server.takeRequest();
+    assertEquals(0, get.getSequenceNumber());
+
+    RecordedRequest post1 = server.takeRequest();
+    assertEquals("body!", post1.getUtf8Body());
+    assertEquals(1, post1.getSequenceNumber());
+
+    RecordedRequest post2 = server.takeRequest();
+    assertEquals("body!", post2.getUtf8Body());
+    assertEquals(0, post2.getSequenceNumber());
+  }
+
   @Test public void fullyBufferedPostIsTooShort() throws Exception {
     server.enqueue(new MockResponse().setBody("A"));
     server.play();
@@ -2584,7 +2794,7 @@ private void reusedConnectionFailsWithPost(TransferKind transferKind, int reques
     fail("TODO");
   }
 
-  @Test public void customAuthenticator() throws Exception {
+  @Test public void customBasicAuthenticator() throws Exception {
     MockResponse pleaseAuthenticate = new MockResponse().setResponseCode(401)
         .addHeader("WWW-Authenticate: Basic realm=\"protected area\"")
         .setBody("Please authenticate.");
@@ -2592,53 +2802,110 @@ private void reusedConnectionFailsWithPost(TransferKind transferKind, int reques
     server.enqueue(new MockResponse().setBody("A"));
     server.play();
 
-    Credential credential = Credential.basic("jesse", "peanutbutter");
+    String credential = Credentials.basic("jesse", "peanutbutter");
     RecordingOkAuthenticator authenticator = new RecordingOkAuthenticator(credential);
-    client.setAuthenticator(authenticator);
+    client.client().setAuthenticator(authenticator);
     assertContent("A", client.open(server.getUrl("/private")));
 
     assertContainsNoneMatching(server.takeRequest().getHeaders(), "Authorization: .*");
     assertContains(server.takeRequest().getHeaders(),
-        "Authorization: " + credential.getHeaderValue());
+        "Authorization: " + credential);
 
-    assertEquals(1, authenticator.calls.size());
-    String call = authenticator.calls.get(0);
-    assertTrue(call, call.contains("proxy=DIRECT"));
-    assertTrue(call, call.contains("url=" + server.getUrl("/private")));
-    assertTrue(call, call.contains("challenges=[Basic realm=\"protected area\"]"));
+    assertEquals(Proxy.NO_PROXY, authenticator.onlyProxy());
+    Response response = authenticator.onlyResponse();
+    assertEquals("/private", response.request().url().getPath());
+    assertEquals(Arrays.asList(new Challenge("Basic", "protected area")), response.challenges());
   }
+  
+  @Test public void customTokenAuthenticator() throws Exception {
+    MockResponse pleaseAuthenticate = new MockResponse().setResponseCode(401)
+            .addHeader("WWW-Authenticate: Bearer realm=\"oauthed\"")
+            .setBody("Please authenticate.");
+    server.enqueue(pleaseAuthenticate);
+    server.enqueue(new MockResponse().setBody("A"));
+    server.play();
 
-  @Test public void npnSetsProtocolHeader_SPDY_3() throws Exception {
-    npnSetsProtocolHeader(Protocol.SPDY_3);
+    RecordingOkAuthenticator authenticator = new RecordingOkAuthenticator("oauthed abc123");
+    client.client().setAuthenticator(authenticator);
+    assertContent("A", client.open(server.getUrl("/private")));
+
+    assertContainsNoneMatching(server.takeRequest().getHeaders(), "Authorization: .*");
+    assertContains(server.takeRequest().getHeaders(), "Authorization: oauthed abc123");
+
+    Response response = authenticator.onlyResponse();
+    assertEquals("/private", response.request().url().getPath());
+    assertEquals(Arrays.asList(new Challenge("Bearer", "oauthed")), response.challenges());
   }
 
-  @Test public void npnSetsProtocolHeader_HTTP_2() throws Exception {
-    npnSetsProtocolHeader(Protocol.HTTP_2);
+  @Test public void authenticateCallsTrackedAsRedirects() throws Exception {
+    server.enqueue(new MockResponse()
+        .setResponseCode(302)
+        .addHeader("Location: /b"));
+    server.enqueue(new MockResponse()
+        .setResponseCode(401)
+        .addHeader("WWW-Authenticate: Basic realm=\"protected area\""));
+    server.enqueue(new MockResponse().setBody("c"));
+    server.play();
+
+    RecordingOkAuthenticator authenticator = new RecordingOkAuthenticator(
+        Credentials.basic("jesse", "peanutbutter"));
+    client.client().setAuthenticator(authenticator);
+    assertContent("c", client.open(server.getUrl("/a")));
+
+    Response challengeResponse = authenticator.responses.get(0);
+    assertEquals("/b", challengeResponse.request().url().getPath());
+
+    Response redirectedBy = challengeResponse.priorResponse();
+    assertEquals("/a", redirectedBy.request().url().getPath());
+  }
+
+  @Test public void setsNegotiatedProtocolHeader_SPDY_3() throws Exception {
+    setsNegotiatedProtocolHeader(Protocol.SPDY_3);
+  }
+
+  @Test public void setsNegotiatedProtocolHeader_HTTP_2() throws Exception {
+    setsNegotiatedProtocolHeader(Protocol.HTTP_2);
   }
 
-  private void npnSetsProtocolHeader(Protocol protocol) throws IOException {
-    enableNpn(protocol);
+  private void setsNegotiatedProtocolHeader(Protocol protocol) throws IOException {
+    enableProtocol(protocol);
     server.enqueue(new MockResponse().setBody("A"));
     server.play();
-    client.setProtocols(Arrays.asList(Protocol.HTTP_11, protocol));
+    client.client().setProtocols(Arrays.asList(protocol, Protocol.HTTP_1_1));
     connection = client.open(server.getUrl("/"));
     List<String> protocolValues = connection.getHeaderFields().get(SELECTED_PROTOCOL);
-    assertEquals(Arrays.asList(protocol.name.utf8()), protocolValues);
+    assertEquals(Arrays.asList(protocol.toString()), protocolValues);
     assertContent("A", connection);
   }
 
+  @Test public void http10SelectedProtocol() throws Exception {
+    server.enqueue(new MockResponse().setStatus("HTTP/1.0 200 OK"));
+    server.play();
+    connection = client.open(server.getUrl("/"));
+    List<String> protocolValues = connection.getHeaderFields().get(SELECTED_PROTOCOL);
+    assertEquals(Arrays.asList("http/1.0"), protocolValues);
+  }
+
+  @Test public void http11SelectedProtocol() throws Exception {
+    server.enqueue(new MockResponse().setStatus("HTTP/1.1 200 OK"));
+    server.play();
+    connection = client.open(server.getUrl("/"));
+    List<String> protocolValues = connection.getHeaderFields().get(SELECTED_PROTOCOL);
+    assertEquals(Arrays.asList("http/1.1"), protocolValues);
+  }
+
   /** For example, empty Protobuf RPC messages end up as a zero-length POST. */
   @Test public void zeroLengthPost() throws IOException, InterruptedException {
     zeroLengthPayload("POST");
   }
 
   @Test public void zeroLengthPost_SPDY_3() throws Exception {
-    enableNpn(Protocol.SPDY_3);
+    enableProtocol(Protocol.SPDY_3);
     zeroLengthPost();
   }
 
   @Test public void zeroLengthPost_HTTP_2() throws Exception {
-    enableNpn(Protocol.HTTP_2);
+    enableProtocol(Protocol.HTTP_2);
     zeroLengthPost();
   }
 
@@ -2648,12 +2915,12 @@ private void npnSetsProtocolHeader(Protocol protocol) throws IOException {
   }
 
   @Test public void zeroLengthPut_SPDY_3() throws Exception {
-    enableNpn(Protocol.SPDY_3);
+    enableProtocol(Protocol.SPDY_3);
     zeroLengthPut();
   }
 
   @Test public void zeroLengthPut_HTTP_2() throws Exception {
-    enableNpn(Protocol.HTTP_2);
+    enableProtocol(Protocol.HTTP_2);
     zeroLengthPut();
   }
 
@@ -2673,16 +2940,31 @@ private void zeroLengthPayload(String method)
     assertEquals(0L, zeroLengthPayload.getBodySize());
   }
 
+  @Test public void unspecifiedRequestBodyContentTypeGetsDefault() throws Exception {
+    server.enqueue(new MockResponse());
+    server.play();
+
+    connection = client.open(server.getUrl("/"));
+    connection.setDoOutput(true);
+    connection.getOutputStream().write("abc".getBytes(UTF_8));
+    assertEquals(200, connection.getResponseCode());
+
+    RecordedRequest request = server.takeRequest();
+    assertEquals("application/x-www-form-urlencoded", request.getHeader("Content-Type"));
+    assertEquals("3", request.getHeader("Content-Length"));
+    assertEquals("abc", request.getUtf8Body());
+  }
+
   @Test public void setProtocols() throws Exception {
     server.enqueue(new MockResponse().setBody("A"));
     server.play();
-    client.setProtocols(Arrays.asList(Protocol.HTTP_11));
+    client.client().setProtocols(Arrays.asList(Protocol.HTTP_1_1));
     assertContent("A", client.open(server.getUrl("/")));
   }
 
   @Test public void setProtocolsWithoutHttp11() throws Exception {
     try {
-      client.setProtocols(Arrays.asList(Protocol.SPDY_3));
+      client.client().setProtocols(Arrays.asList(Protocol.SPDY_3));
       fail();
     } catch (IllegalArgumentException expected) {
     }
@@ -2690,7 +2972,7 @@ private void zeroLengthPayload(String method)
 
   @Test public void setProtocolsWithNull() throws Exception {
     try {
-      client.setProtocols(Arrays.asList(Protocol.HTTP_11, null));
+      client.client().setProtocols(Arrays.asList(Protocol.HTTP_1_1, null));
       fail();
     } catch (IllegalArgumentException expected) {
     }
@@ -2757,7 +3039,7 @@ private void zeroLengthPayload(String method)
         .setResponseCode(HttpURLConnection.HTTP_MOVED_TEMP)
         .addHeader("Location: /foo")
         .addHeader("Content-Encoding: gzip")
-        .setBody(gzip("Moved! Moved! Moved!".getBytes(UTF_8))));
+        .setBody(gzip("Moved! Moved! Moved!")));
     server.enqueue(new MockResponse().setBody("This is the new page!"));
     server.play();
 
@@ -2790,13 +3072,34 @@ private void zeroLengthPayload(String method)
     assertEquals("BODY", new String(request.getBody(), UTF_8));
   }
 
+  @Test public void userAgentPicksUpHttpAgentSystemProperty() throws Exception {
+    server.enqueue(new MockResponse().setBody("abc"));
+    server.play();
+
+    System.setProperty("http.agent", "foo");
+    assertContent("abc", client.open(server.getUrl("/")));
+
+    RecordedRequest request = server.takeRequest();
+    assertEquals("foo", request.getHeader("User-Agent"));
+  }
+
+  @Test public void userAgentDefaultsToJavaVersion() throws Exception {
+    server.enqueue(new MockResponse().setBody("abc"));
+    server.play();
+
+    assertContent("abc", client.open(server.getUrl("/")));
+
+    RecordedRequest request = server.takeRequest();
+    assertTrue(request.getHeader("User-Agent").startsWith("Java"));
+  }
+
   /** Returns a gzipped copy of {@code bytes}. */
-  public byte[] gzip(byte[] bytes) throws IOException {
-    ByteArrayOutputStream bytesOut = new ByteArrayOutputStream();
-    OutputStream gzippedOut = new GZIPOutputStream(bytesOut);
-    gzippedOut.write(bytes);
-    gzippedOut.close();
-    return bytesOut.toByteArray();
+  public Buffer gzip(String data) throws IOException {
+    Buffer result = new Buffer();
+    BufferedSink gzipSink = Okio.buffer(new GzipSink(result));
+    gzipSink.writeUtf8(data);
+    gzipSink.close();
+    return result;
   }
 
   /**
@@ -2831,7 +3134,7 @@ private void assertContainsNoneMatching(List<String> headers, String pattern) {
 
   enum TransferKind {
     CHUNKED() {
-      @Override void setBody(MockResponse response, byte[] content, int chunkSize)
+      @Override void setBody(MockResponse response, Buffer content, int chunkSize)
           throws IOException {
         response.setChunkedBody(content, chunkSize);
       }
@@ -2840,7 +3143,7 @@ private void assertContainsNoneMatching(List<String> headers, String pattern) {
       }
     },
     FIXED_LENGTH() {
-      @Override void setBody(MockResponse response, byte[] content, int chunkSize) {
+      @Override void setBody(MockResponse response, Buffer content, int chunkSize) {
         response.setBody(content);
       }
       @Override void setForRequest(HttpURLConnection connection, int contentLength) {
@@ -2848,7 +3151,7 @@ private void assertContainsNoneMatching(List<String> headers, String pattern) {
       }
     },
     END_OF_STREAM() {
-      @Override void setBody(MockResponse response, byte[] content, int chunkSize) {
+      @Override void setBody(MockResponse response, Buffer content, int chunkSize) {
         response.setBody(content);
         response.setSocketPolicy(DISCONNECT_AT_END);
         for (Iterator<String> h = response.getHeaders().iterator(); h.hasNext(); ) {
@@ -2862,60 +3165,66 @@ private void assertContainsNoneMatching(List<String> headers, String pattern) {
       }
     };
 
-    abstract void setBody(MockResponse response, byte[] content, int chunkSize) throws IOException;
+    abstract void setBody(MockResponse response, Buffer content, int chunkSize) throws IOException;
 
     abstract void setForRequest(HttpURLConnection connection, int contentLength);
 
     void setBody(MockResponse response, String content, int chunkSize) throws IOException {
-      setBody(response, content.getBytes("UTF-8"), chunkSize);
+      setBody(response, new Buffer().writeUtf8(content), chunkSize);
     }
   }
 
   enum ProxyConfig {
     NO_PROXY() {
-      @Override public HttpURLConnection connect(MockWebServer server, OkHttpClient client, URL url)
+      @Override public HttpURLConnection connect(
+          MockWebServer server, OkUrlFactory streamHandlerFactory, URL url)
           throws IOException {
-        client.setProxy(Proxy.NO_PROXY);
-        return client.open(url);
+        streamHandlerFactory.client().setProxy(Proxy.NO_PROXY);
+        return streamHandlerFactory.open(url);
       }
     },
 
     CREATE_ARG() {
-      @Override public HttpURLConnection connect(MockWebServer server, OkHttpClient client, URL url)
+      @Override public HttpURLConnection connect(
+          MockWebServer server, OkUrlFactory streamHandlerFactory, URL url)
           throws IOException {
-        client.setProxy(server.toProxyAddress());
-        return client.open(url);
+        streamHandlerFactory.client().setProxy(server.toProxyAddress());
+        return streamHandlerFactory.open(url);
       }
     },
 
     PROXY_SYSTEM_PROPERTY() {
-      @Override public HttpURLConnection connect(MockWebServer server, OkHttpClient client, URL url)
+      @Override public HttpURLConnection connect(
+          MockWebServer server, OkUrlFactory streamHandlerFactory, URL url)
           throws IOException {
         System.setProperty("proxyHost", "localhost");
         System.setProperty("proxyPort", Integer.toString(server.getPort()));
-        return client.open(url);
+        return streamHandlerFactory.open(url);
       }
     },
 
     HTTP_PROXY_SYSTEM_PROPERTY() {
-      @Override public HttpURLConnection connect(MockWebServer server, OkHttpClient client, URL url)
+      @Override public HttpURLConnection connect(
+          MockWebServer server, OkUrlFactory streamHandlerFactory, URL url)
           throws IOException {
         System.setProperty("http.proxyHost", "localhost");
         System.setProperty("http.proxyPort", Integer.toString(server.getPort()));
-        return client.open(url);
+        return streamHandlerFactory.open(url);
       }
     },
 
     HTTPS_PROXY_SYSTEM_PROPERTY() {
-      @Override public HttpURLConnection connect(MockWebServer server, OkHttpClient client, URL url)
+      @Override public HttpURLConnection connect(
+          MockWebServer server, OkUrlFactory streamHandlerFactory, URL url)
           throws IOException {
         System.setProperty("https.proxyHost", "localhost");
         System.setProperty("https.proxyPort", Integer.toString(server.getPort()));
-        return client.open(url);
+        return streamHandlerFactory.open(url);
       }
     };
 
-    public abstract HttpURLConnection connect(MockWebServer server, OkHttpClient client, URL url)
+    public abstract HttpURLConnection connect(
+        MockWebServer server, OkUrlFactory streamHandlerFactory, URL url)
         throws IOException;
   }
 
@@ -2960,14 +3269,14 @@ private String certificatesToString(X509Certificate[] certificates) {
 
   /**
    * Tests that use this will fail unless boot classpath is set. Ex. {@code
-   * -Xbootclasspath/p:/tmp/npn-boot-8.1.2.v20120308.jar}
+   * -Xbootclasspath/p:/tmp/alpn-boot-8.0.0.v20140317}
    */
-  private void enableNpn(Protocol protocol) {
-    client.setSslSocketFactory(sslContext.getSocketFactory());
-    client.setHostnameVerifier(new RecordingHostnameVerifier());
-    client.setProtocols(Arrays.asList(protocol, Protocol.HTTP_11));
+  private void enableProtocol(Protocol protocol) {
+    client.client().setSslSocketFactory(sslContext.getSocketFactory());
+    client.client().setHostnameVerifier(new RecordingHostnameVerifier());
+    client.client().setProtocols(Arrays.asList(protocol, Protocol.HTTP_1_1));
     server.useHttps(sslContext.getSocketFactory(), false);
-    server.setNpnEnabled(true);
-    server.setNpnProtocols(client.getProtocols());
+    server.setProtocolNegotiationEnabled(true);
+    server.setProtocols(client.client().getProtocols());
   }
 }
diff --git a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/URLEncodingTest.java b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/URLEncodingTest.java
index 6ca375691b..547f009b67 100644
--- a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/URLEncodingTest.java
+++ b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/URLEncodingTest.java
@@ -16,16 +16,17 @@
 
 package com.squareup.okhttp.internal.http;
 
+import com.squareup.okhttp.AbstractResponseCache;
 import com.squareup.okhttp.OkHttpClient;
+import com.squareup.okhttp.OkUrlFactory;
+import com.squareup.okhttp.internal.Internal;
+import com.squareup.okhttp.internal.huc.CacheAdapter;
 import java.io.IOException;
-import java.net.CacheRequest;
 import java.net.CacheResponse;
 import java.net.HttpURLConnection;
-import java.net.ResponseCache;
 import java.net.URI;
 import java.net.URISyntaxException;
 import java.net.URL;
-import java.net.URLConnection;
 import java.util.List;
 import java.util.Map;
 import java.util.concurrent.atomic.AtomicReference;
@@ -121,23 +122,19 @@ private void testUrlToUriMapping(String string, String asAuthority, String asFil
   }
 
   private URI backdoorUrlToUri(URL url) throws Exception {
-    final AtomicReference<URI> uriReference = new AtomicReference<URI>();
+    final AtomicReference<URI> uriReference = new AtomicReference<>();
 
     OkHttpClient client = new OkHttpClient();
-    client.setResponseCache(new ResponseCache() {
-      @Override public CacheRequest put(URI uri, URLConnection connection) throws IOException {
-        return null;
-      }
-
+    Internal.instance.setCache(client, new CacheAdapter(new AbstractResponseCache() {
       @Override public CacheResponse get(URI uri, String requestMethod,
           Map<String, List<String>> requestHeaders) throws IOException {
         uriReference.set(uri);
         throw new UnsupportedOperationException();
       }
-    });
+    }));
 
     try {
-      HttpURLConnection connection = client.open(url);
+      HttpURLConnection connection = new OkUrlFactory(client).open(url);
       connection.getResponseCode();
     } catch (Exception expected) {
       if (expected.getCause() instanceof URISyntaxException) {
diff --git a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/huc/CacheAdapterTest.java b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/huc/CacheAdapterTest.java
new file mode 100644
index 0000000000..270fb837ee
--- /dev/null
+++ b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/huc/CacheAdapterTest.java
@@ -0,0 +1,267 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.okhttp.internal.huc;
+
+import com.squareup.okhttp.AbstractResponseCache;
+import com.squareup.okhttp.OkHttpClient;
+import com.squareup.okhttp.OkUrlFactory;
+import com.squareup.okhttp.internal.Internal;
+import com.squareup.okhttp.internal.SslContextBuilder;
+import com.squareup.okhttp.mockwebserver.MockResponse;
+import com.squareup.okhttp.mockwebserver.MockWebServer;
+import java.io.IOException;
+import java.net.CacheRequest;
+import java.net.CacheResponse;
+import java.net.HttpURLConnection;
+import java.net.ResponseCache;
+import java.net.URI;
+import java.net.URL;
+import java.net.URLConnection;
+import java.util.Collections;
+import java.util.List;
+import java.util.Map;
+import javax.net.ssl.HostnameVerifier;
+import javax.net.ssl.HttpsURLConnection;
+import javax.net.ssl.SSLContext;
+import javax.net.ssl.SSLSession;
+import org.junit.After;
+import org.junit.Before;
+import org.junit.Test;
+
+import static org.junit.Assert.assertArrayEquals;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertTrue;
+
+/**
+ * A white-box test for {@link CacheAdapter}. See also:
+ * <ul>
+ *   <li>{@link ResponseCacheTest} for black-box tests that check that {@link ResponseCache}
+ *   classes are called correctly by OkHttp.</li>
+ *   <li>{@link JavaApiConverterTest} for tests that check Java API classes / OkHttp conversion
+ *   logic. </li>
+ * </ul>
+ */
+public class CacheAdapterTest {
+  private static final SSLContext sslContext = SslContextBuilder.localhost();
+  private static final HostnameVerifier NULL_HOSTNAME_VERIFIER = new HostnameVerifier() {
+    public boolean verify(String hostname, SSLSession session) {
+      return true;
+    }
+  };
+
+  private MockWebServer server;
+
+  private OkHttpClient client;
+
+  private HttpURLConnection connection;
+
+  @Before public void setUp() throws Exception {
+    server = new MockWebServer();
+    client = new OkHttpClient();
+  }
+
+  @After public void tearDown() throws Exception {
+    if (connection != null) {
+      connection.disconnect();
+    }
+    server.shutdown();
+  }
+
+  @Test public void get_httpGet() throws Exception {
+    final URL serverUrl = configureServer(new MockResponse());
+    assertEquals("http", serverUrl.getProtocol());
+
+    ResponseCache responseCache = new AbstractResponseCache() {
+      @Override
+      public CacheResponse get(URI uri, String method, Map<String, List<String>> headers) throws IOException {
+        assertEquals(toUri(serverUrl), uri);
+        assertEquals("GET", method);
+        assertTrue("Arbitrary standard header not present", headers.containsKey("User-Agent"));
+        assertEquals(Collections.singletonList("value1"), headers.get("key1"));
+        return null;
+      }
+    };
+    Internal.instance.setCache(client, new CacheAdapter(responseCache));
+
+    connection = new OkUrlFactory(client).open(serverUrl);
+    connection.setRequestProperty("key1", "value1");
+
+    executeGet(connection);
+  }
+
+  @Test public void get_httpsGet() throws Exception {
+    final URL serverUrl = configureHttpsServer(new MockResponse());
+    assertEquals("https", serverUrl.getProtocol());
+
+    ResponseCache responseCache = new AbstractResponseCache() {
+      @Override public CacheResponse get(URI uri, String method, Map<String, List<String>> headers)
+          throws IOException {
+        assertEquals("https", uri.getScheme());
+        assertEquals(toUri(serverUrl), uri);
+        assertEquals("GET", method);
+        assertTrue("Arbitrary standard header not present", headers.containsKey("User-Agent"));
+        assertEquals(Collections.singletonList("value1"), headers.get("key1"));
+        return null;
+      }
+    };
+    Internal.instance.setCache(client, new CacheAdapter(responseCache));
+    client.setSslSocketFactory(sslContext.getSocketFactory());
+    client.setHostnameVerifier(NULL_HOSTNAME_VERIFIER);
+
+    connection = new OkUrlFactory(client).open(serverUrl);
+    connection.setRequestProperty("key1", "value1");
+
+    executeGet(connection);
+  }
+
+  @Test public void put_httpGet() throws Exception {
+    final String statusLine = "HTTP/1.1 200 Fantastic";
+    final URL serverUrl = configureServer(
+        new MockResponse()
+            .setStatus(statusLine)
+            .addHeader("A", "c"));
+
+    ResponseCache responseCache = new AbstractResponseCache() {
+      @Override public CacheRequest put(URI uri, URLConnection connection) throws IOException {
+        assertTrue(connection instanceof HttpURLConnection);
+        assertFalse(connection instanceof HttpsURLConnection);
+
+        assertEquals(0, connection.getContentLength());
+
+        HttpURLConnection httpUrlConnection = (HttpURLConnection) connection;
+        assertEquals("GET", httpUrlConnection.getRequestMethod());
+        assertTrue(httpUrlConnection.getDoInput());
+        assertFalse(httpUrlConnection.getDoOutput());
+
+        assertEquals("Fantastic", httpUrlConnection.getResponseMessage());
+        assertEquals(toUri(serverUrl), uri);
+        assertEquals(serverUrl, connection.getURL());
+        assertEquals("value", connection.getRequestProperty("key"));
+
+        // Check retrieval by string key.
+        assertEquals(statusLine, httpUrlConnection.getHeaderField(null));
+        assertEquals("c", httpUrlConnection.getHeaderField("A"));
+        // The RI and OkHttp supports case-insensitive matching for this method.
+        assertEquals("c", httpUrlConnection.getHeaderField("a"));
+        return null;
+      }
+    };
+    Internal.instance.setCache(client, new CacheAdapter(responseCache));
+
+    connection = new OkUrlFactory(client).open(serverUrl);
+    connection.setRequestProperty("key", "value");
+    executeGet(connection);
+  }
+
+  @Test public void put_httpPost() throws Exception {
+    final String statusLine = "HTTP/1.1 200 Fantastic";
+    final URL serverUrl = configureServer(
+        new MockResponse()
+            .setStatus(statusLine)
+            .addHeader("A", "c"));
+
+    ResponseCache responseCache = new AbstractResponseCache() {
+      @Override public CacheRequest put(URI uri, URLConnection connection) throws IOException {
+        assertTrue(connection instanceof HttpURLConnection);
+        assertFalse(connection instanceof HttpsURLConnection);
+
+        assertEquals(0, connection.getContentLength());
+
+        HttpURLConnection httpUrlConnection = (HttpURLConnection) connection;
+        assertEquals("POST", httpUrlConnection.getRequestMethod());
+        assertTrue(httpUrlConnection.getDoInput());
+        assertTrue(httpUrlConnection.getDoOutput());
+
+        assertEquals("Fantastic", httpUrlConnection.getResponseMessage());
+        assertEquals(toUri(serverUrl), uri);
+        assertEquals(serverUrl, connection.getURL());
+        assertEquals("value", connection.getRequestProperty("key"));
+
+        // Check retrieval by string key.
+        assertEquals(statusLine, httpUrlConnection.getHeaderField(null));
+        assertEquals("c", httpUrlConnection.getHeaderField("A"));
+        // The RI and OkHttp supports case-insensitive matching for this method.
+        assertEquals("c", httpUrlConnection.getHeaderField("a"));
+        return null;
+      }
+    };
+    Internal.instance.setCache(client, new CacheAdapter(responseCache));
+
+    connection = new OkUrlFactory(client).open(serverUrl);
+
+    executePost(connection);
+  }
+
+  @Test public void put_httpsGet() throws Exception {
+    final URL serverUrl = configureHttpsServer(new MockResponse());
+    assertEquals("https", serverUrl.getProtocol());
+
+    ResponseCache responseCache = new AbstractResponseCache() {
+      @Override public CacheRequest put(URI uri, URLConnection connection) throws IOException {
+        assertTrue(connection instanceof HttpsURLConnection);
+        assertEquals(toUri(serverUrl), uri);
+        assertEquals(serverUrl, connection.getURL());
+
+        HttpsURLConnection cacheHttpsUrlConnection = (HttpsURLConnection) connection;
+        HttpsURLConnection realHttpsUrlConnection = (HttpsURLConnection) CacheAdapterTest.this.connection;
+        assertEquals(realHttpsUrlConnection.getCipherSuite(),
+            cacheHttpsUrlConnection.getCipherSuite());
+        assertEquals(realHttpsUrlConnection.getPeerPrincipal(),
+            cacheHttpsUrlConnection.getPeerPrincipal());
+        assertArrayEquals(realHttpsUrlConnection.getLocalCertificates(),
+            cacheHttpsUrlConnection.getLocalCertificates());
+        assertArrayEquals(realHttpsUrlConnection.getServerCertificates(),
+            cacheHttpsUrlConnection.getServerCertificates());
+        assertEquals(realHttpsUrlConnection.getLocalPrincipal(),
+            cacheHttpsUrlConnection.getLocalPrincipal());
+        return null;
+      }
+    };
+    Internal.instance.setCache(client, new CacheAdapter(responseCache));
+    client.setSslSocketFactory(sslContext.getSocketFactory());
+    client.setHostnameVerifier(NULL_HOSTNAME_VERIFIER);
+
+    connection = new OkUrlFactory(client).open(serverUrl);
+    executeGet(connection);
+  }
+
+  private void executeGet(HttpURLConnection connection) throws IOException {
+    connection.connect();
+    connection.getHeaderFields();
+    connection.disconnect();
+  }
+
+  private void executePost(HttpURLConnection connection) throws IOException {
+    connection.setDoOutput(true);
+    connection.connect();
+    connection.getOutputStream().write("Hello World".getBytes());
+    connection.disconnect();
+  }
+
+  private URL configureServer(MockResponse mockResponse) throws Exception {
+    server.enqueue(mockResponse);
+    server.play();
+    return server.getUrl("/");
+  }
+
+  private URL configureHttpsServer(MockResponse mockResponse) throws Exception {
+    server.useHttps(sslContext.getSocketFactory(), false /* tunnelProxy */);
+    server.enqueue(mockResponse);
+    server.play();
+    return server.getUrl("/");
+  }
+}
diff --git a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/huc/JavaApiConverterTest.java b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/huc/JavaApiConverterTest.java
new file mode 100644
index 0000000000..4a4befeb06
--- /dev/null
+++ b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/huc/JavaApiConverterTest.java
@@ -0,0 +1,807 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.squareup.okhttp.internal.huc;
+
+import com.squareup.okhttp.Handshake;
+import com.squareup.okhttp.Headers;
+import com.squareup.okhttp.MediaType;
+import com.squareup.okhttp.OkHttpClient;
+import com.squareup.okhttp.OkUrlFactory;
+import com.squareup.okhttp.Protocol;
+import com.squareup.okhttp.Request;
+import com.squareup.okhttp.RequestBody;
+import com.squareup.okhttp.Response;
+import com.squareup.okhttp.ResponseBody;
+import com.squareup.okhttp.internal.SslContextBuilder;
+import com.squareup.okhttp.internal.Util;
+import com.squareup.okhttp.mockwebserver.MockResponse;
+import com.squareup.okhttp.mockwebserver.MockWebServer;
+import java.io.ByteArrayInputStream;
+import java.io.ByteArrayOutputStream;
+import java.io.IOException;
+import java.io.InputStream;
+import java.net.CacheResponse;
+import java.net.HttpURLConnection;
+import java.net.SecureCacheResponse;
+import java.net.URI;
+import java.net.URL;
+import java.nio.charset.StandardCharsets;
+import java.security.Principal;
+import java.security.cert.Certificate;
+import java.security.cert.CertificateException;
+import java.security.cert.CertificateFactory;
+import java.security.cert.X509Certificate;
+import java.util.Arrays;
+import java.util.Collections;
+import java.util.HashMap;
+import java.util.LinkedHashSet;
+import java.util.List;
+import java.util.Map;
+import java.util.Set;
+import javax.net.ssl.HostnameVerifier;
+import javax.net.ssl.HttpsURLConnection;
+import javax.net.ssl.SSLContext;
+import javax.net.ssl.SSLPeerUnverifiedException;
+import javax.net.ssl.SSLSession;
+import okio.Buffer;
+import okio.BufferedSource;
+import org.junit.After;
+import org.junit.Before;
+import org.junit.Test;
+
+import static org.junit.Assert.assertArrayEquals;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertNotNull;
+import static org.junit.Assert.assertNull;
+import static org.junit.Assert.assertSame;
+import static org.junit.Assert.assertTrue;
+import static org.junit.Assert.fail;
+
+/**
+ * Tests for {@link JavaApiConverter}.
+ */
+public class JavaApiConverterTest {
+
+  // $ openssl req -x509 -nodes -days 36500 -subj '/CN=localhost' -config ./cert.cnf \
+  //     -newkey rsa:512 -out cert.pem
+  private static final X509Certificate LOCAL_CERT = certificate(""
+      + "-----BEGIN CERTIFICATE-----\n"
+      + "MIIBWDCCAQKgAwIBAgIJANS1EtICX2AZMA0GCSqGSIb3DQEBBQUAMBQxEjAQBgNV\n"
+      + "BAMTCWxvY2FsaG9zdDAgFw0xMjAxMDIxOTA4NThaGA8yMTExMTIwOTE5MDg1OFow\n"
+      + "FDESMBAGA1UEAxMJbG9jYWxob3N0MFwwDQYJKoZIhvcNAQEBBQADSwAwSAJBAPpt\n"
+      + "atK8r4/hf4hSIs0os/BSlQLbRBaK9AfBReM4QdAklcQqe6CHsStKfI8pp0zs7Ptg\n"
+      + "PmMdpbttL0O7mUboBC8CAwEAAaM1MDMwMQYDVR0RBCowKIIVbG9jYWxob3N0Lmxv\n"
+      + "Y2FsZG9tYWlugglsb2NhbGhvc3SHBH8AAAEwDQYJKoZIhvcNAQEFBQADQQD0ntfL\n"
+      + "DCzOCv9Ma6Lv5o5jcYWVxvBSTsnt22hsJpWD1K7iY9lbkLwl0ivn73pG2evsAn9G\n"
+      + "X8YKH52fnHsCrhSD\n"
+      + "-----END CERTIFICATE-----");
+
+  // openssl req -x509 -nodes -days 36500 -subj '/CN=*.0.0.1' -newkey rsa:512 -out cert.pem
+  private static final X509Certificate SERVER_CERT = certificate(""
+      + "-----BEGIN CERTIFICATE-----\n"
+      + "MIIBkjCCATygAwIBAgIJAMdemqOwd/BEMA0GCSqGSIb3DQEBBQUAMBIxEDAOBgNV\n"
+      + "BAMUByouMC4wLjEwIBcNMTAxMjIwMTY0NDI1WhgPMjExMDExMjYxNjQ0MjVaMBIx\n"
+      + "EDAOBgNVBAMUByouMC4wLjEwXDANBgkqhkiG9w0BAQEFAANLADBIAkEAqY8c9Qrt\n"
+      + "YPWCvb7lclI+aDHM6fgbJcHsS9Zg8nUOh5dWrS7AgeA25wyaokFl4plBbbHQe2j+\n"
+      + "cCjsRiJIcQo9HwIDAQABo3MwcTAdBgNVHQ4EFgQUJ436TZPJvwCBKklZZqIvt1Yt\n"
+      + "JjEwQgYDVR0jBDswOYAUJ436TZPJvwCBKklZZqIvt1YtJjGhFqQUMBIxEDAOBgNV\n"
+      + "BAMUByouMC4wLjGCCQDHXpqjsHfwRDAMBgNVHRMEBTADAQH/MA0GCSqGSIb3DQEB\n"
+      + "BQUAA0EAk9i88xdjWoewqvE+iMC9tD2obMchgFDaHH0ogxxiRaIKeEly3g0uGxIt\n"
+      + "fl2WRY8hb4x+zRrwsFaLEpdEvqcjOQ==\n"
+      + "-----END CERTIFICATE-----");
+
+  private static final SSLContext sslContext = SslContextBuilder.localhost();
+  private static final HostnameVerifier NULL_HOSTNAME_VERIFIER = new HostnameVerifier() {
+    public boolean verify(String hostname, SSLSession session) {
+      return true;
+    }
+  };
+
+  private MockWebServer server;
+
+  private OkHttpClient client;
+
+  private HttpURLConnection connection;
+
+  @Before public void setUp() throws Exception {
+    server = new MockWebServer();
+    client = new OkHttpClient();
+  }
+
+  @After public void tearDown() throws Exception {
+    if (connection != null) {
+      connection.disconnect();
+    }
+    server.shutdown();
+  }
+
+  @Test public void createOkResponse_fromOkHttpUrlConnection() throws Exception {
+    testCreateOkResponseInternal(new OkHttpURLConnectionFactory(client), false /* isSecure */);
+  }
+
+  @Test public void createOkResponse_fromJavaHttpUrlConnection() throws Exception {
+    testCreateOkResponseInternal(new JavaHttpURLConnectionFactory(), false /* isSecure */);
+  }
+
+  @Test public void createOkResponse_fromOkHttpsUrlConnection() throws Exception {
+    testCreateOkResponseInternal(new OkHttpURLConnectionFactory(client), true /* isSecure */);
+  }
+
+  @Test public void createOkResponse_fromJavaHttpsUrlConnection() throws Exception {
+    testCreateOkResponseInternal(new JavaHttpURLConnectionFactory(), true /* isSecure */);
+  }
+
+  private void testCreateOkResponseInternal(HttpURLConnectionFactory httpUrlConnectionFactory,
+      boolean isSecure) throws Exception {
+    String statusLine = "HTTP/1.1 200 Fantastic";
+    String body = "Nothing happens";
+    final URL serverUrl;
+    MockResponse mockResponse = new MockResponse()
+        .setStatus(statusLine)
+        .addHeader("xyzzy", "baz")
+        .setBody(body);
+    if (isSecure) {
+      serverUrl = configureHttpsServer(
+          mockResponse);
+
+      assertEquals("https", serverUrl.getProtocol());
+    } else {
+      serverUrl = configureServer(
+          mockResponse);
+      assertEquals("http", serverUrl.getProtocol());
+    }
+
+    connection = httpUrlConnectionFactory.open(serverUrl);
+    if (isSecure) {
+      HttpsURLConnection httpsUrlConnection = (HttpsURLConnection) connection;
+      httpsUrlConnection.setSSLSocketFactory(sslContext.getSocketFactory());
+      httpsUrlConnection.setHostnameVerifier(NULL_HOSTNAME_VERIFIER);
+    }
+    connection.setRequestProperty("snake", "bird");
+    connection.connect();
+    Response response = JavaApiConverter.createOkResponse(serverUrl.toURI(), connection);
+
+    // Check the response.request()
+    Request request = response.request();
+    assertEquals(isSecure, request.isHttps());
+    assertEquals(serverUrl.toURI(), request.uri());
+    assertNull(request.body());
+    Headers okRequestHeaders = request.headers();
+    // In Java the request headers are unavailable for a connected HttpURLConnection.
+    assertEquals(0, okRequestHeaders.size());
+    assertEquals("GET", request.method());
+
+    // Check the response
+    assertEquals(Protocol.HTTP_1_1, response.protocol());
+    assertEquals(200, response.code());
+    assertEquals("Fantastic", response.message());
+    Headers okResponseHeaders = response.headers();
+    assertEquals("baz", okResponseHeaders.get("xyzzy"));
+    if (isSecure) {
+      Handshake handshake = response.handshake();
+      assertNotNull(handshake);
+      HttpsURLConnection httpsURLConnection = (HttpsURLConnection) connection;
+      assertNotNullAndEquals(httpsURLConnection.getCipherSuite(), handshake.cipherSuite());
+      assertEquals(httpsURLConnection.getLocalPrincipal(), handshake.localPrincipal());
+      assertNotNullAndEquals(httpsURLConnection.getPeerPrincipal(), handshake.peerPrincipal());
+      assertNotNull(httpsURLConnection.getServerCertificates());
+      assertEquals(Arrays.asList(httpsURLConnection.getServerCertificates()),
+          handshake.peerCertificates());
+      assertNull(httpsURLConnection.getLocalCertificates());
+    } else {
+      assertNull(response.handshake());
+    }
+    assertEquals(body, response.body().string());
+  }
+
+  @Test public void createOkResponse_fromCacheResponse() throws Exception {
+    final String statusLine = "HTTP/1.1 200 Fantastic";
+    URI uri = new URI("http://foo/bar");
+    Request request = new Request.Builder().url(uri.toURL()).build();
+    CacheResponse cacheResponse = new CacheResponse() {
+      @Override
+      public Map<String, List<String>> getHeaders() throws IOException {
+        Map<String, List<String>> headers = new HashMap<>();
+        headers.put(null, Collections.singletonList(statusLine));
+        headers.put("xyzzy", Arrays.asList("bar", "baz"));
+        return headers;
+      }
+
+      @Override
+      public InputStream getBody() throws IOException {
+        return new ByteArrayInputStream("HelloWorld".getBytes(StandardCharsets.UTF_8));
+      }
+    };
+
+    Response response = JavaApiConverter.createOkResponse(request, cacheResponse);
+    assertSame(request, response.request());
+
+    assertEquals(Protocol.HTTP_1_1, response.protocol());
+    assertEquals(200, response.code());
+    assertEquals("Fantastic", response.message());
+    Headers okResponseHeaders = response.headers();
+    assertEquals("baz", okResponseHeaders.get("xyzzy"));
+    assertEquals("HelloWorld", response.body().string());
+    assertNull(response.handshake());
+  }
+
+  @Test public void createOkResponse_fromSecureCacheResponse() throws Exception {
+    final String statusLine = "HTTP/1.1 200 Fantastic";
+    final Principal localPrincipal = LOCAL_CERT.getSubjectX500Principal();
+    final List<Certificate> localCertificates = Arrays.<Certificate>asList(LOCAL_CERT);
+    final Principal serverPrincipal = SERVER_CERT.getSubjectX500Principal();
+    final List<Certificate> serverCertificates = Arrays.<Certificate>asList(SERVER_CERT);
+    URI uri = new URI("https://foo/bar");
+    Request request = new Request.Builder().url(uri.toURL()).build();
+    SecureCacheResponse cacheResponse = new SecureCacheResponse() {
+      @Override
+      public Map<String, List<String>> getHeaders() throws IOException {
+        Map<String, List<String>> headers = new HashMap<>();
+        headers.put(null, Collections.singletonList(statusLine));
+        headers.put("xyzzy", Arrays.asList("bar", "baz"));
+        return headers;
+      }
+
+      @Override
+      public InputStream getBody() throws IOException {
+        return new ByteArrayInputStream("HelloWorld".getBytes(StandardCharsets.UTF_8));
+      }
+
+      @Override
+      public String getCipherSuite() {
+        return "SuperSecure";
+      }
+
+      @Override
+      public List<Certificate> getLocalCertificateChain() {
+        return localCertificates;
+      }
+
+      @Override
+      public List<Certificate> getServerCertificateChain() throws SSLPeerUnverifiedException {
+        return serverCertificates;
+      }
+
+      @Override
+      public Principal getPeerPrincipal() throws SSLPeerUnverifiedException {
+        return serverPrincipal;
+      }
+
+      @Override
+      public Principal getLocalPrincipal() {
+        return localPrincipal;
+      }
+    };
+
+    Response response = JavaApiConverter.createOkResponse(request, cacheResponse);
+    assertSame(request, response.request());
+
+    assertEquals(Protocol.HTTP_1_1, response.protocol());
+    assertEquals(200, response.code());
+    assertEquals("Fantastic", response.message());
+    Headers okResponseHeaders = response.headers();
+    assertEquals("baz", okResponseHeaders.get("xyzzy"));
+    assertEquals("HelloWorld", response.body().string());
+
+    Handshake handshake = response.handshake();
+    assertNotNull(handshake);
+    assertNotNullAndEquals("SuperSecure", handshake.cipherSuite());
+    assertEquals(localPrincipal, handshake.localPrincipal());
+    assertEquals(serverPrincipal, handshake.peerPrincipal());
+    assertEquals(serverCertificates, handshake.peerCertificates());
+    assertEquals(localCertificates, handshake.localCertificates());
+  }
+
+  @Test public void createOkRequest_nullRequestHeaders() throws Exception {
+    URI uri = new URI("http://foo/bar");
+
+    Map<String,List<String>> javaRequestHeaders = null;
+    Request request = JavaApiConverter.createOkRequest(uri, "POST", javaRequestHeaders);
+    assertFalse(request.isHttps());
+    assertEquals(uri, request.uri());
+    assertNull(request.body());
+    Headers okRequestHeaders = request.headers();
+    assertEquals(0, okRequestHeaders.size());
+    assertEquals("POST", request.method());
+  }
+
+  @Test public void createOkRequest_nonNullRequestHeaders() throws Exception {
+    URI uri = new URI("https://foo/bar");
+
+    Map<String,List<String>> javaRequestHeaders = new HashMap<>();
+    javaRequestHeaders.put("Foo", Arrays.asList("Bar"));
+    Request request = JavaApiConverter.createOkRequest(uri, "POST", javaRequestHeaders);
+    assertTrue(request.isHttps());
+    assertEquals(uri, request.uri());
+    assertNull(request.body());
+    Headers okRequestHeaders = request.headers();
+    assertEquals(1, okRequestHeaders.size());
+    assertEquals("Bar", okRequestHeaders.get("Foo"));
+    assertEquals("POST", request.method());
+  }
+
+  // Older versions of OkHttp would store the "request line" as a header with a
+  // null key. To support the Android usecase where an old version of OkHttp uses
+  // a newer, Android-bundled, version of HttpResponseCache the null key must be
+  // explicitly ignored.
+  @Test public void createOkRequest_nullRequestHeaderKey() throws Exception {
+    URI uri = new URI("https://foo/bar");
+
+    Map<String,List<String>> javaRequestHeaders = new HashMap<>();
+    javaRequestHeaders.put(null, Arrays.asList("GET / HTTP 1.1"));
+    javaRequestHeaders.put("Foo", Arrays.asList("Bar"));
+    Request request = JavaApiConverter.createOkRequest(uri, "POST", javaRequestHeaders);
+    assertTrue(request.isHttps());
+    assertEquals(uri, request.uri());
+    assertNull(request.body());
+    Headers okRequestHeaders = request.headers();
+    assertEquals(1, okRequestHeaders.size());
+    assertEquals("Bar", okRequestHeaders.get("Foo"));
+    assertEquals("POST", request.method());
+  }
+
+  @Test public void createJavaUrlConnection_requestChangesForbidden() throws Exception {
+    Response okResponse = createArbitraryOkResponse();
+    HttpURLConnection httpUrlConnection = JavaApiConverter.createJavaUrlConnection(okResponse);
+    // Check an arbitrary (not complete) set of methods that can be used to modify the
+    // request.
+    try {
+      httpUrlConnection.setRequestProperty("key", "value");
+      fail();
+    } catch (UnsupportedOperationException expected) {
+    }
+    try {
+      httpUrlConnection.setFixedLengthStreamingMode(1234);
+      fail();
+    } catch (UnsupportedOperationException expected) {
+    }
+    try {
+      httpUrlConnection.setRequestMethod("PUT");
+      fail();
+    } catch (UnsupportedOperationException expected) {
+    }
+    try {
+      httpUrlConnection.getHeaderFields().put("key", Collections.singletonList("value"));
+      fail();
+    } catch (UnsupportedOperationException expected) {
+    }
+    try {
+      httpUrlConnection.getOutputStream();
+      fail();
+    } catch (UnsupportedOperationException expected) {
+    }
+  }
+
+  @Test public void createJavaUrlConnection_connectionChangesForbidden() throws Exception {
+    Response okResponse = createArbitraryOkResponse();
+    HttpURLConnection httpUrlConnection = JavaApiConverter.createJavaUrlConnection(okResponse);
+    try {
+      httpUrlConnection.connect();
+      fail();
+    } catch (UnsupportedOperationException expected) {
+    }
+    try {
+      httpUrlConnection.disconnect();
+      fail();
+    } catch (UnsupportedOperationException expected) {
+    }
+  }
+
+  @Test public void createJavaUrlConnection_responseChangesForbidden() throws Exception {
+    Response okResponse = createArbitraryOkResponse();
+    HttpURLConnection httpUrlConnection = JavaApiConverter.createJavaUrlConnection(okResponse);
+    // Check an arbitrary (not complete) set of methods that can be used to access the response
+    // body.
+    try {
+      httpUrlConnection.getInputStream();
+      fail();
+    } catch (UnsupportedOperationException expected) {
+    }
+    try {
+      httpUrlConnection.getContent();
+      fail();
+    } catch (UnsupportedOperationException expected) {
+    }
+    try {
+      httpUrlConnection.setFixedLengthStreamingMode(1234);
+      fail();
+    } catch (UnsupportedOperationException expected) {
+    }
+    try {
+      httpUrlConnection.setRequestMethod("PUT");
+      fail();
+    } catch (UnsupportedOperationException expected) {
+    }
+    try {
+      httpUrlConnection.getHeaderFields().put("key", Collections.singletonList("value"));
+      fail();
+    } catch (UnsupportedOperationException expected) {
+    }
+  }
+
+  @Test public void createJavaUrlConnection_responseHeadersOk() throws Exception {
+    ResponseBody responseBody = createResponseBody("BodyText");
+    Response okResponse = new Response.Builder()
+        .request(createArbitraryOkRequest())
+        .protocol(Protocol.HTTP_1_1)
+        .code(200)
+        .message("Fantastic")
+        .addHeader("A", "c")
+        .addHeader("B", "d")
+        .addHeader("A", "e")
+        .addHeader("Content-Length", Long.toString(responseBody.contentLength()))
+        .body(responseBody)
+        .build();
+
+    HttpURLConnection httpUrlConnection = JavaApiConverter.createJavaUrlConnection(okResponse);
+    assertEquals(200, httpUrlConnection.getResponseCode());
+    assertEquals("Fantastic", httpUrlConnection.getResponseMessage());
+    assertEquals(responseBody.contentLength(), httpUrlConnection.getContentLength());
+
+    // Check retrieval by string key.
+    assertEquals("HTTP/1.1 200 Fantastic", httpUrlConnection.getHeaderField(null));
+    assertEquals("e", httpUrlConnection.getHeaderField("A"));
+    // The RI and OkHttp supports case-insensitive matching for this method.
+    assertEquals("e", httpUrlConnection.getHeaderField("a"));
+
+    // Check retrieval using a Map.
+    Map<String, List<String>> responseHeaders = httpUrlConnection.getHeaderFields();
+    assertEquals(Arrays.asList("HTTP/1.1 200 Fantastic"), responseHeaders.get(null));
+    assertEquals(newSet("c", "e"), newSet(responseHeaders.get("A")));
+    // OkHttp supports case-insensitive matching here. The RI does not.
+    assertEquals(newSet("c", "e"), newSet(responseHeaders.get("a")));
+
+    // Check the Map iterator contains the expected mappings.
+    assertHeadersContainsMapping(responseHeaders, null, "HTTP/1.1 200 Fantastic");
+    assertHeadersContainsMapping(responseHeaders, "A", "c", "e");
+    assertHeadersContainsMapping(responseHeaders, "B", "d");
+
+    // Check immutability of the headers Map.
+    try {
+      responseHeaders.put("N", Arrays.asList("o"));
+      fail("Modified an unmodifiable view.");
+    } catch (UnsupportedOperationException expected) {
+    }
+    try {
+      responseHeaders.get("A").add("f");
+      fail("Modified an unmodifiable view.");
+    } catch (UnsupportedOperationException expected) {
+    }
+
+    // Check retrieval of headers by index.
+    assertEquals(null, httpUrlConnection.getHeaderFieldKey(0));
+    assertEquals("HTTP/1.1 200 Fantastic", httpUrlConnection.getHeaderField(0));
+    // After header zero there may be additional entries provided at the beginning or end by the
+    // implementation. It's probably important that the relative ordering of the headers is
+    // preserved, particularly if there are multiple value for the same key.
+    int i = 1;
+    while (!httpUrlConnection.getHeaderFieldKey(i).equals("A")) {
+      i++;
+    }
+    // Check the ordering of the headers set by app code.
+    assertResponseHeaderAtIndex(httpUrlConnection, i++, "A", "c");
+    assertResponseHeaderAtIndex(httpUrlConnection, i++, "B", "d");
+    assertResponseHeaderAtIndex(httpUrlConnection, i++, "A", "e");
+    // There may be some additional headers provided by the implementation.
+    while (httpUrlConnection.getHeaderField(i) != null) {
+      assertNotNull(httpUrlConnection.getHeaderFieldKey(i));
+      i++;
+    }
+    // Confirm the correct behavior when the index is out-of-range.
+    assertNull(httpUrlConnection.getHeaderFieldKey(i));
+  }
+
+  private static void assertResponseHeaderAtIndex(HttpURLConnection httpUrlConnection,
+      int headerIndex, String expectedKey, String expectedValue) {
+    assertEquals(expectedKey, httpUrlConnection.getHeaderFieldKey(headerIndex));
+    assertEquals(expectedValue, httpUrlConnection.getHeaderField(headerIndex));
+  }
+
+  private void assertHeadersContainsMapping(Map<String, List<String>> headers, String expectedKey,
+      String... expectedValues) {
+    assertTrue(headers.containsKey(expectedKey));
+    assertEquals(newSet(expectedValues), newSet(headers.get(expectedKey)));
+  }
+
+  @Test public void createJavaUrlConnection_accessibleRequestInfo_GET() throws Exception {
+    Request okRequest = createArbitraryOkRequest().newBuilder()
+        .get()
+        .build();
+    Response okResponse = createArbitraryOkResponse(okRequest);
+    HttpURLConnection httpUrlConnection = JavaApiConverter.createJavaUrlConnection(okResponse);
+
+    assertEquals("GET", httpUrlConnection.getRequestMethod());
+    assertTrue(httpUrlConnection.getDoInput());
+    assertFalse(httpUrlConnection.getDoOutput());
+  }
+
+  @Test public void createJavaUrlConnection_accessibleRequestInfo_POST() throws Exception {
+    Request okRequest = createArbitraryOkRequest().newBuilder()
+        .post(createRequestBody("PostBody"))
+        .build();
+    Response okResponse = createArbitraryOkResponse(okRequest);
+    HttpURLConnection httpUrlConnection = JavaApiConverter.createJavaUrlConnection(okResponse);
+
+    assertEquals("POST", httpUrlConnection.getRequestMethod());
+    assertTrue(httpUrlConnection.getDoInput());
+    assertTrue(httpUrlConnection.getDoOutput());
+  }
+
+  @Test public void createJavaUrlConnection_https_extraHttpsMethods() throws Exception {
+    Request okRequest = createArbitraryOkRequest().newBuilder()
+        .get()
+        .url("https://secure/request")
+        .build();
+    Handshake handshake = Handshake.get("SecureCipher", Arrays.<Certificate>asList(SERVER_CERT),
+        Arrays.<Certificate>asList(LOCAL_CERT));
+    Response okResponse = createArbitraryOkResponse(okRequest).newBuilder()
+        .handshake(handshake)
+        .build();
+    HttpsURLConnection httpsUrlConnection =
+        (HttpsURLConnection) JavaApiConverter.createJavaUrlConnection(okResponse);
+
+    assertEquals("SecureCipher", httpsUrlConnection.getCipherSuite());
+    assertEquals(SERVER_CERT.getSubjectX500Principal(), httpsUrlConnection.getPeerPrincipal());
+    assertArrayEquals(new Certificate[] { LOCAL_CERT }, httpsUrlConnection.getLocalCertificates());
+    assertArrayEquals(new Certificate[] { SERVER_CERT },
+        httpsUrlConnection.getServerCertificates());
+    assertEquals(LOCAL_CERT.getSubjectX500Principal(), httpsUrlConnection.getLocalPrincipal());
+  }
+
+  @Test public void createJavaUrlConnection_https_forbiddenFields() throws Exception {
+    Request okRequest = createArbitraryOkRequest().newBuilder()
+        .url("https://secure/request")
+        .build();
+    Response okResponse = createArbitraryOkResponse(okRequest);
+    HttpsURLConnection httpsUrlConnection =
+        (HttpsURLConnection) JavaApiConverter.createJavaUrlConnection(okResponse);
+
+    try {
+      httpsUrlConnection.getHostnameVerifier();
+      fail();
+    } catch (UnsupportedOperationException expected) {
+    }
+    try {
+      httpsUrlConnection.getSSLSocketFactory();
+      fail();
+    } catch (UnsupportedOperationException expected) {
+    }
+  }
+
+  @Test public void createJavaCacheResponse_httpGet() throws Exception {
+    Request okRequest =
+        createArbitraryOkRequest().newBuilder()
+            .url("http://insecure/request")
+            .get()
+            .build();
+    Response okResponse = createArbitraryOkResponse(okRequest).newBuilder()
+        .protocol(Protocol.HTTP_1_1)
+        .code(200)
+        .message("Fantastic")
+        .addHeader("key1", "value1_1")
+        .addHeader("key2", "value2")
+        .addHeader("key1", "value1_2")
+        .body(null)
+        .build();
+    CacheResponse javaCacheResponse = JavaApiConverter.createJavaCacheResponse(okResponse);
+    assertFalse(javaCacheResponse instanceof SecureCacheResponse);
+    Map<String, List<String>> javaHeaders = javaCacheResponse.getHeaders();
+    assertEquals(Arrays.asList("value1_1", "value1_2"), javaHeaders.get("key1"));
+    assertEquals(Arrays.asList("HTTP/1.1 200 Fantastic"), javaHeaders.get(null));
+    assertNull(javaCacheResponse.getBody());
+  }
+
+  @Test public void createJavaCacheResponse_httpPost() throws Exception {
+    Request okRequest =
+        createArbitraryOkRequest().newBuilder()
+            .url("http://insecure/request")
+            .post(createRequestBody("RequestBody"))
+            .build();
+    ResponseBody responseBody = createResponseBody("ResponseBody");
+    Response okResponse = createArbitraryOkResponse(okRequest).newBuilder()
+        .protocol(Protocol.HTTP_1_1)
+        .code(200)
+        .message("Fantastic")
+        .addHeader("key1", "value1_1")
+        .addHeader("key2", "value2")
+        .addHeader("key1", "value1_2")
+        .body(responseBody)
+        .build();
+    CacheResponse javaCacheResponse = JavaApiConverter.createJavaCacheResponse(okResponse);
+    assertFalse(javaCacheResponse instanceof SecureCacheResponse);
+    Map<String, List<String>> javaHeaders = javaCacheResponse.getHeaders();
+    assertEquals(Arrays.asList("value1_1", "value1_2"), javaHeaders.get("key1"));
+    assertEquals(Arrays.asList("HTTP/1.1 200 Fantastic"), javaHeaders.get(null));
+    assertEquals("ResponseBody", readAll(javaCacheResponse.getBody()));
+  }
+
+  @Test public void createJavaCacheResponse_httpsPost() throws Exception {
+    Request okRequest =
+        createArbitraryOkRequest().newBuilder()
+            .url("https://secure/request")
+            .post(createRequestBody("RequestBody") )
+            .build();
+    ResponseBody responseBody = createResponseBody("ResponseBody");
+    Handshake handshake = Handshake.get("SecureCipher", Arrays.<Certificate>asList(SERVER_CERT),
+        Arrays.<Certificate>asList(LOCAL_CERT));
+    Response okResponse = createArbitraryOkResponse(okRequest).newBuilder()
+        .protocol(Protocol.HTTP_1_1)
+        .code(200)
+        .message("Fantastic")
+        .addHeader("key1", "value1_1")
+        .addHeader("key2", "value2")
+        .addHeader("key1", "value1_2")
+        .body(responseBody)
+        .handshake(handshake)
+        .build();
+    SecureCacheResponse javaCacheResponse =
+        (SecureCacheResponse) JavaApiConverter.createJavaCacheResponse(okResponse);
+    Map<String, List<String>> javaHeaders = javaCacheResponse.getHeaders();
+    assertEquals(Arrays.asList("value1_1", "value1_2"), javaHeaders.get("key1"));
+    assertEquals(Arrays.asList("HTTP/1.1 200 Fantastic"), javaHeaders.get(null));
+    assertEquals("ResponseBody", readAll(javaCacheResponse.getBody()));
+    assertEquals(handshake.cipherSuite(), javaCacheResponse.getCipherSuite());
+    assertEquals(handshake.localCertificates(), javaCacheResponse.getLocalCertificateChain());
+    assertEquals(handshake.peerCertificates(), javaCacheResponse.getServerCertificateChain());
+    assertEquals(handshake.localPrincipal(), javaCacheResponse.getLocalPrincipal());
+    assertEquals(handshake.peerPrincipal(), javaCacheResponse.getPeerPrincipal());
+  }
+
+  @Test public void extractJavaHeaders() throws Exception {
+    Request okRequest = createArbitraryOkRequest().newBuilder()
+        .addHeader("key1", "value1_1")
+        .addHeader("key2", "value2")
+        .addHeader("key1", "value1_2")
+        .build();
+    Map<String, List<String>> javaHeaders = JavaApiConverter.extractJavaHeaders(okRequest);
+
+    assertEquals(Arrays.asList("value1_1", "value1_2"), javaHeaders.get("key1"));
+    assertEquals(Arrays.asList("value2"), javaHeaders.get("key2"));
+  }
+
+  @Test public void extractOkHeaders() {
+    Map<String, List<String>> javaResponseHeaders = new HashMap<>();
+    javaResponseHeaders.put(null, Arrays.asList("StatusLine"));
+    javaResponseHeaders.put("key1", Arrays.asList("value1_1", "value1_2"));
+    javaResponseHeaders.put("key2", Arrays.asList("value2"));
+
+    Headers okHeaders = JavaApiConverter.extractOkHeaders(javaResponseHeaders);
+    assertEquals(3, okHeaders.size()); // null entry should be stripped out
+    assertEquals(Arrays.asList("value1_1", "value1_2"), okHeaders.values("key1"));
+    assertEquals(Arrays.asList("value2"), okHeaders.values("key2"));
+  }
+
+  @Test public void extractStatusLine() {
+    Map<String, List<String>> javaResponseHeaders = new HashMap<>();
+    javaResponseHeaders.put(null, Arrays.asList("StatusLine"));
+    javaResponseHeaders.put("key1", Arrays.asList("value1_1", "value1_2"));
+    javaResponseHeaders.put("key2", Arrays.asList("value2"));
+    assertEquals("StatusLine", JavaApiConverter.extractStatusLine(javaResponseHeaders));
+
+    assertNull(JavaApiConverter.extractStatusLine(Collections.<String, List<String>>emptyMap()));
+  }
+
+  private URL configureServer(MockResponse mockResponse) throws Exception {
+    server.enqueue(mockResponse);
+    server.play();
+    return server.getUrl("/");
+  }
+
+  private URL configureHttpsServer(MockResponse mockResponse) throws Exception {
+    server.useHttps(sslContext.getSocketFactory(), false /* tunnelProxy */);
+    server.enqueue(mockResponse);
+    server.play();
+    return server.getUrl("/");
+  }
+
+  private static <T> void assertNotNullAndEquals(T expected, T actual) {
+    assertNotNull(actual);
+    assertEquals(expected, actual);
+  }
+
+  private interface HttpURLConnectionFactory {
+    public HttpURLConnection open(URL serverUrl) throws IOException;
+  }
+
+  private static class OkHttpURLConnectionFactory implements HttpURLConnectionFactory {
+    protected final OkHttpClient client;
+
+    private OkHttpURLConnectionFactory(OkHttpClient client) {
+      this.client = client;
+    }
+
+    @Override
+    public HttpURLConnection open(URL serverUrl) {
+      return new OkUrlFactory(client).open(serverUrl);
+    }
+  }
+
+  private static class JavaHttpURLConnectionFactory implements HttpURLConnectionFactory {
+    @Override
+    public HttpURLConnection open(URL serverUrl) throws IOException {
+      return (HttpURLConnection) serverUrl.openConnection();
+    }
+  }
+
+  private static X509Certificate certificate(String certificate) {
+    try {
+      return (X509Certificate) CertificateFactory.getInstance("X.509").generateCertificate(
+          new ByteArrayInputStream(certificate.getBytes(Util.UTF_8)));
+    } catch (CertificateException e) {
+      fail();
+      return null;
+    }
+  }
+
+  private static <T> Set<T> newSet(T... elements) {
+    return newSet(Arrays.asList(elements));
+  }
+
+  private static <T> Set<T> newSet(List<T> elements) {
+    return new LinkedHashSet<>(elements);
+  }
+
+  private static Request createArbitraryOkRequest() {
+    return new Request.Builder().url("http://arbitrary/url").build();
+  }
+
+  private static Response createArbitraryOkResponse(Request request) {
+    return new Response.Builder()
+        .request(request)
+        .protocol(Protocol.HTTP_1_1)
+        .code(200)
+        .message("Arbitrary")
+        .build();
+  }
+
+  private static Response createArbitraryOkResponse() {
+    return createArbitraryOkResponse(createArbitraryOkRequest());
+  }
+
+  private static RequestBody createRequestBody(String bodyText) {
+    return RequestBody.create(MediaType.parse("text/plain"), bodyText);
+  }
+
+  private static ResponseBody createResponseBody(String bodyText) {
+    final Buffer source = new Buffer().writeUtf8(bodyText);
+    final long contentLength = source.size();
+    return new ResponseBody() {
+      @Override public MediaType contentType() {
+        return MediaType.parse("text/plain; charset=utf-8");
+      }
+
+      @Override public long contentLength() {
+        return contentLength;
+      }
+
+      @Override public BufferedSource source() {
+        return source;
+      }
+    };
+  }
+
+  private String readAll(InputStream in) throws IOException {
+    ByteArrayOutputStream buffer = new ByteArrayOutputStream();
+    int value;
+    while ((value = in.read()) != -1) {
+      buffer.write(value);
+    }
+    in.close();
+    return buffer.toString("UTF-8");
+  }
+}
diff --git a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/ResponseCacheTest.java b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/huc/ResponseCacheTest.java
similarity index 93%
rename from okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/ResponseCacheTest.java
rename to okhttp-tests/src/test/java/com/squareup/okhttp/internal/huc/ResponseCacheTest.java
index 1cbd654560..21ad7f4991 100644
--- a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/ResponseCacheTest.java
+++ b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/huc/ResponseCacheTest.java
@@ -14,14 +14,18 @@
  * limitations under the License.
  */
 
-package com.squareup.okhttp.internal.http;
+package com.squareup.okhttp.internal.huc;
 
+import com.squareup.okhttp.AbstractResponseCache;
 import com.squareup.okhttp.OkHttpClient;
-import com.squareup.okhttp.ResponseSource;
+import com.squareup.okhttp.OkUrlFactory;
+import com.squareup.okhttp.internal.Internal;
 import com.squareup.okhttp.internal.SslContextBuilder;
+import com.squareup.okhttp.internal.http.HttpDate;
 import com.squareup.okhttp.mockwebserver.MockResponse;
 import com.squareup.okhttp.mockwebserver.MockWebServer;
 import com.squareup.okhttp.mockwebserver.RecordedRequest;
+import com.squareup.okhttp.mockwebserver.rule.MockWebServerRule;
 import java.io.BufferedReader;
 import java.io.ByteArrayInputStream;
 import java.io.ByteArrayOutputStream;
@@ -56,14 +60,18 @@
 import java.util.TimeZone;
 import java.util.concurrent.TimeUnit;
 import java.util.concurrent.atomic.AtomicReference;
-import java.util.zip.GZIPOutputStream;
 import javax.net.ssl.HostnameVerifier;
 import javax.net.ssl.HttpsURLConnection;
 import javax.net.ssl.SSLContext;
 import javax.net.ssl.SSLPeerUnverifiedException;
 import javax.net.ssl.SSLSession;
+import okio.Buffer;
+import okio.BufferedSink;
+import okio.GzipSink;
+import okio.Okio;
 import org.junit.After;
 import org.junit.Before;
+import org.junit.Rule;
 import org.junit.Test;
 
 import static com.squareup.okhttp.mockwebserver.SocketPolicy.DISCONNECT_AT_END;
@@ -71,15 +79,14 @@
 import static org.junit.Assert.assertFalse;
 import static org.junit.Assert.assertNotNull;
 import static org.junit.Assert.assertNull;
-import static org.junit.Assert.assertSame;
 import static org.junit.Assert.assertTrue;
 import static org.junit.Assert.fail;
 
 /**
- * Tests for interaction between OkHttp and the ResponseCache. This test is based on
- * {@link com.squareup.okhttp.internal.http.HttpResponseCacheTest}. Some tests for the
- * {@link com.squareup.okhttp.OkResponseCache} found in HttpResponseCacheTest provide
- * coverage for ResponseCache as well.
+ * Tests for interaction between OkHttp and the ResponseCache. This test is
+ * based on {@link com.squareup.okhttp.CacheTest}. Some tests for the {@link
+ * com.squareup.okhttp.internal.InternalCache} in CacheTest cover ResponseCache
+ * as well.
  */
 public final class ResponseCacheTest {
   private static final HostnameVerifier NULL_HOSTNAME_VERIFIER = new HostnameVerifier() {
@@ -90,43 +97,30 @@
 
   private static final SSLContext sslContext = SslContextBuilder.localhost();
 
+  @Rule public MockWebServerRule serverRule = new MockWebServerRule();
+  @Rule public MockWebServerRule server2Rule = new MockWebServerRule();
+
   private OkHttpClient client;
   private MockWebServer server;
   private MockWebServer server2;
   private ResponseCache cache;
 
   @Before public void setUp() throws Exception {
-    server =  new MockWebServer();
-    server.setNpnEnabled(false);
-    server2 =  new MockWebServer();
+    server = serverRule.get();
+    server.setProtocolNegotiationEnabled(false);
+    server2 = server2Rule.get();
 
     client = new OkHttpClient();
     cache = new InMemoryResponseCache();
-    ResponseCache.setDefault(cache);
+    Internal.instance.setCache(client, new CacheAdapter(cache));
   }
 
   @After public void tearDown() throws Exception {
-    server.shutdown();
-    server2.shutdown();
     CookieManager.setDefault(null);
   }
 
   private HttpURLConnection openConnection(URL url) {
-    return client.open(url);
-  }
-
-  @Test public void responseCacheAccessWithOkHttpMember() throws IOException {
-    ResponseCache.setDefault(null);
-    client.setResponseCache(cache);
-    assertSame(cache, client.getResponseCache());
-    assertTrue(client.getOkResponseCache() instanceof ResponseCacheAdapter);
-  }
-
-  @Test public void responseCacheAccessWithGlobalDefault() throws IOException {
-    ResponseCache.setDefault(cache);
-    client.setResponseCache(null);
-    assertNull(client.getOkResponseCache());
-    assertNull(client.getResponseCache());
+    return new OkUrlFactory(client).open(url);
   }
 
   @Test public void responseCachingAndInputStreamSkipWithFixedLength() throws IOException {
@@ -152,7 +146,6 @@ private void testResponseCaching(TransferKind transferKind) throws IOException {
             .setStatus("HTTP/1.1 200 Fantastic");
     transferKind.setBody(response, "I love puppies but hate spiders", 1);
     server.enqueue(response);
-    server.play();
 
     // Make sure that calling skip() doesn't omit bytes from the cache.
     HttpURLConnection urlConnection = openConnection(server.getUrl("/"));
@@ -179,7 +172,6 @@ private void testResponseCaching(TransferKind transferKind) throws IOException {
     server.enqueue(new MockResponse().addHeader("Last-Modified: " + formatDate(-1, TimeUnit.HOURS))
         .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS))
         .setBody("ABC"));
-    server.play();
 
     HttpsURLConnection c1 = (HttpsURLConnection) openConnection(server.getUrl("/"));
     c1.setSSLSocketFactory(sslContext.getSocketFactory());
@@ -209,9 +201,9 @@ private void testResponseCaching(TransferKind transferKind) throws IOException {
     server.useHttps(sslContext.getSocketFactory(), false);
     server.enqueue(new MockResponse().setBody("ABC"));
     server.enqueue(new MockResponse().setBody("DEF"));
-    server.play();
 
-    client.setResponseCache(new InsecureResponseCache(new InMemoryResponseCache()));
+    Internal.instance.setCache(client,
+        new CacheAdapter(new InsecureResponseCache(new InMemoryResponseCache())));
 
     HttpsURLConnection connection1 = (HttpsURLConnection) openConnection(server.getUrl("/"));
     connection1.setSSLSocketFactory(sslContext.getSocketFactory());
@@ -234,7 +226,6 @@ private void testResponseCaching(TransferKind transferKind) throws IOException {
         .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS))
         .setBody("ABC"));
     server.enqueue(new MockResponse().setBody("DEF"));
-    server.play();
 
     HttpURLConnection connection = openConnection(server.getUrl("/"));
     assertEquals("ABC", readAscii(connection));
@@ -248,7 +239,6 @@ private void testResponseCaching(TransferKind transferKind) throws IOException {
     server.enqueue(new MockResponse().setResponseCode(HttpURLConnection.HTTP_MOVED_PERM)
         .addHeader("Location: /foo"));
     server.enqueue(new MockResponse().setBody("DEF"));
-    server.play();
 
     assertEquals("ABC", readAscii(openConnection(server.getUrl("/foo"))));
     RecordedRequest request1 = server.takeRequest();
@@ -277,7 +267,6 @@ private void testResponseCaching(TransferKind transferKind) throws IOException {
         .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS))
         .setBody("ABC"));
     server.enqueue(new MockResponse().setBody("DEF"));
-    server.play();
 
     client.setSslSocketFactory(sslContext.getSocketFactory());
     client.setHostnameVerifier(NULL_HOSTNAME_VERIFIER);
@@ -308,13 +297,11 @@ private void testResponseCaching(TransferKind transferKind) throws IOException {
         .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS))
         .setBody("ABC"));
     server2.enqueue(new MockResponse().setBody("DEF"));
-    server2.play();
 
     server.enqueue(new MockResponse().addHeader("Last-Modified: " + formatDate(-1, TimeUnit.HOURS))
         .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS))
         .setResponseCode(HttpURLConnection.HTTP_MOVED_PERM)
         .addHeader("Location: " + server2.getUrl("/")));
-    server.play();
 
     client.setSslSocketFactory(sslContext.getSocketFactory());
     client.setHostnameVerifier(NULL_HOSTNAME_VERIFIER);
@@ -329,23 +316,16 @@ private void testResponseCaching(TransferKind transferKind) throws IOException {
 
   @Test public void responseCacheRequestHeaders() throws IOException, URISyntaxException {
     server.enqueue(new MockResponse().setBody("ABC"));
-    server.play();
 
     final AtomicReference<Map<String, List<String>>> requestHeadersRef =
         new AtomicReference<Map<String, List<String>>>();
-    client.setResponseCache(new ResponseCache() {
-      @Override
-      public CacheResponse get(URI uri, String requestMethod,
+    Internal.instance.setCache(client, new CacheAdapter(new AbstractResponseCache() {
+      @Override public CacheResponse get(URI uri, String requestMethod,
           Map<String, List<String>> requestHeaders) throws IOException {
         requestHeadersRef.set(requestHeaders);
         return null;
       }
-
-      @Override
-      public CacheRequest put(URI uri, URLConnection conn) throws IOException {
-        return null;
-      }
-    });
+    }));
 
     URL url = server.getUrl("/");
     URLConnection urlConnection = openConnection(url);
@@ -373,7 +353,6 @@ private void testServerPrematureDisconnect(TransferKind transferKind) throws IOE
     transferKind.setBody(response, "ABCDE\nFGHIJKLMNOPQRSTUVWXYZ", 16);
     server.enqueue(truncateViolently(response, 16));
     server.enqueue(new MockResponse().setBody("Request #2"));
-    server.play();
 
     BufferedReader reader = new BufferedReader(
         new InputStreamReader(openConnection(server.getUrl("/")).getInputStream()));
@@ -409,7 +388,6 @@ private void testClientPrematureDisconnect(TransferKind transferKind) throws IOE
     transferKind.setBody(response, "ABCDE\nFGHIJKLMNOPQRSTUVWXYZ", 1024);
     server.enqueue(response);
     server.enqueue(new MockResponse().setBody("Request #2"));
-    server.play();
 
     URLConnection connection = openConnection(server.getUrl("/"));
     InputStream in = connection.getInputStream();
@@ -434,7 +412,6 @@ private void testClientPrematureDisconnect(TransferKind transferKind) throws IOE
         new MockResponse().addHeader("Last-Modified: " + formatDate(-105, TimeUnit.SECONDS))
             .addHeader("Date: " + formatDate(-5, TimeUnit.SECONDS))
             .setBody("A"));
-    server.play();
 
     URL url = server.getUrl("/");
     assertEquals("A", readAscii(openConnection(url)));
@@ -464,7 +441,6 @@ private void testClientPrematureDisconnect(TransferKind transferKind) throws IOE
     server.enqueue(new MockResponse().addHeader("Last-Modified: " + formatDate(-105, TimeUnit.DAYS))
         .addHeader("Date: " + formatDate(-5, TimeUnit.DAYS))
         .setBody("A"));
-    server.play();
 
     assertEquals("A", readAscii(openConnection(server.getUrl("/"))));
     URLConnection connection = openConnection(server.getUrl("/"));
@@ -479,7 +455,6 @@ private void testClientPrematureDisconnect(TransferKind transferKind) throws IOE
             .addHeader("Date: " + formatDate(-5, TimeUnit.SECONDS))
             .setBody("A"));
     server.enqueue(new MockResponse().setBody("B"));
-    server.play();
 
     URL url = server.getUrl("/?foo=bar");
     assertEquals("A", readAscii(openConnection(url)));
@@ -582,7 +557,6 @@ private void testRequestMethod(String requestMethod, boolean expectCached) throw
     server.enqueue(new MockResponse().addHeader("Expires: " + formatDate(1, TimeUnit.HOURS))
         .addHeader("X-Response-ID: 1"));
     server.enqueue(new MockResponse().addHeader("X-Response-ID: 2"));
-    server.play();
 
     URL url = server.getUrl("/");
 
@@ -600,7 +574,7 @@ private void testRequestMethod(String requestMethod, boolean expectCached) throw
   }
 
   /**
-   * Equivalent to {@link HttpResponseCacheTest#postInvalidatesCacheWithUncacheableResponse()} but
+   * Equivalent to {@link com.squareup.okhttp.CacheTest#postInvalidatesCacheWithUncacheableResponse()} but
    * demonstrating that {@link ResponseCache} provides no mechanism for cache invalidation as the
    * result of locally-made requests. In reality invalidation could take place from other clients at
    * any time.
@@ -612,7 +586,6 @@ private void testRequestMethod(String requestMethod, boolean expectCached) throw
     server.enqueue(
         new MockResponse().setBody("A").addHeader("Expires: " + formatDate(1, TimeUnit.HOURS)));
     server.enqueue(new MockResponse().setBody("B").setResponseCode(500));
-    server.play();
 
     URL url = server.getUrl("/");
 
@@ -695,7 +668,6 @@ private void testRequestMethod(String requestMethod, boolean expectCached) throw
         .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS))
         .addHeader("Content-Range: bytes 1000-1001/2000"));
     server.enqueue(new MockResponse().setBody("BB"));
-    server.play();
 
     URL url = server.getUrl("/");
 
@@ -712,7 +684,6 @@ private void testRequestMethod(String requestMethod, boolean expectCached) throw
         .addHeader("Expires: " + formatDate(-1, TimeUnit.HOURS)));
     server.enqueue(new MockResponse().setBody("B")
         .addHeader("Last-Modified: " + formatDate(-4, TimeUnit.HOURS)));
-    server.play();
 
     URL url = server.getUrl("/");
 
@@ -734,12 +705,10 @@ private void testRequestMethod(String requestMethod, boolean expectCached) throw
 
   private void assertNonIdentityEncodingCached(MockResponse response) throws Exception {
     server.enqueue(
-        response.setBody(gzip("ABCABCABC".getBytes("UTF-8"))).addHeader("Content-Encoding: gzip"));
+        response.setBody(gzip("ABCABCABC")).addHeader("Content-Encoding: gzip"));
     server.enqueue(new MockResponse().setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
     server.enqueue(new MockResponse().setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
 
-    server.play();
-
     // At least three request/response pairs are required because after the first request is cached
     // a different execution path might be taken. Thus modifications to the cache applied during
     // the second request might not be visible until another request is performed.
@@ -750,7 +719,7 @@ private void assertNonIdentityEncodingCached(MockResponse response) throws Excep
 
   @Test public void notModifiedSpecifiesEncoding() throws Exception {
     server.enqueue(new MockResponse()
-        .setBody(gzip("ABCABCABC".getBytes("UTF-8")))
+        .setBody(gzip("ABCABCABC"))
         .addHeader("Content-Encoding: gzip")
         .addHeader("Last-Modified: " + formatDate(-2, TimeUnit.HOURS))
         .addHeader("Expires: " + formatDate(-1, TimeUnit.HOURS)));
@@ -760,7 +729,6 @@ private void assertNonIdentityEncodingCached(MockResponse response) throws Excep
     server.enqueue(new MockResponse()
         .setBody("DEFDEFDEF"));
 
-    server.play();
     assertEquals("ABCABCABC", readAscii(openConnection(server.getUrl("/"))));
     assertEquals("ABCABCABC", readAscii(openConnection(server.getUrl("/"))));
     assertEquals("DEFDEFDEF", readAscii(openConnection(server.getUrl("/"))));
@@ -779,7 +747,6 @@ private void assertNonIdentityEncodingCached(MockResponse response) throws Excep
         .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS)));
     server.enqueue(new MockResponse().setBody("B"));
 
-    server.play();
     assertEquals("A", readAscii(openConnection(server.getUrl("/"))));
 
     URLConnection connection = openConnection(server.getUrl("/"));
@@ -793,7 +760,6 @@ private void assertNonIdentityEncodingCached(MockResponse response) throws Excep
         .addHeader("Date: " + formatDate(0, TimeUnit.MINUTES)));
     server.enqueue(new MockResponse().setBody("B"));
 
-    server.play();
     assertEquals("A", readAscii(openConnection(server.getUrl("/"))));
 
     URLConnection connection = openConnection(server.getUrl("/"));
@@ -807,7 +773,6 @@ private void assertNonIdentityEncodingCached(MockResponse response) throws Excep
         .addHeader("Date: " + formatDate(-4, TimeUnit.MINUTES)));
     server.enqueue(new MockResponse().setBody("B"));
 
-    server.play();
     assertEquals("A", readAscii(openConnection(server.getUrl("/"))));
 
     URLConnection connection = openConnection(server.getUrl("/"));
@@ -823,7 +788,6 @@ private void assertNonIdentityEncodingCached(MockResponse response) throws Excep
         .addHeader("Date: " + formatDate(-4, TimeUnit.MINUTES)));
     server.enqueue(new MockResponse().setBody("B"));
 
-    server.play();
     assertEquals("A", readAscii(openConnection(server.getUrl("/"))));
 
     URLConnection connection = openConnection(server.getUrl("/"));
@@ -833,7 +797,6 @@ private void assertNonIdentityEncodingCached(MockResponse response) throws Excep
 
   @Test public void requestOnlyIfCachedWithNoResponseCached() throws IOException {
     // (no responses enqueued)
-    server.play();
 
     HttpURLConnection connection = openConnection(server.getUrl("/"));
     connection.addRequestProperty("Cache-Control", "only-if-cached");
@@ -844,7 +807,6 @@ private void assertNonIdentityEncodingCached(MockResponse response) throws Excep
     server.enqueue(new MockResponse().setBody("A")
         .addHeader("Cache-Control: max-age=30")
         .addHeader("Date: " + formatDate(0, TimeUnit.MINUTES)));
-    server.play();
 
     assertEquals("A", readAscii(openConnection(server.getUrl("/"))));
     URLConnection connection = openConnection(server.getUrl("/"));
@@ -856,7 +818,6 @@ private void assertNonIdentityEncodingCached(MockResponse response) throws Excep
     server.enqueue(new MockResponse().setBody("A")
         .addHeader("Cache-Control: max-age=30")
         .addHeader("Date: " + formatDate(-1, TimeUnit.MINUTES)));
-    server.play();
 
     assertEquals("A", readAscii(openConnection(server.getUrl("/"))));
     HttpURLConnection connection = openConnection(server.getUrl("/"));
@@ -866,7 +827,6 @@ private void assertNonIdentityEncodingCached(MockResponse response) throws Excep
 
   @Test public void requestOnlyIfCachedWithUnhelpfulResponseCached() throws IOException {
     server.enqueue(new MockResponse().setBody("A"));
-    server.play();
 
     assertEquals("A", readAscii(openConnection(server.getUrl("/"))));
     HttpURLConnection connection = openConnection(server.getUrl("/"));
@@ -881,7 +841,6 @@ private void assertNonIdentityEncodingCached(MockResponse response) throws Excep
             .addHeader("Cache-Control: max-age=60")
             .setBody("A"));
     server.enqueue(new MockResponse().setBody("B"));
-    server.play();
 
     URL url = server.getUrl("/");
     assertEquals("A", readAscii(openConnection(url)));
@@ -897,7 +856,6 @@ private void assertNonIdentityEncodingCached(MockResponse response) throws Excep
             .addHeader("Cache-Control: max-age=60")
             .setBody("A"));
     server.enqueue(new MockResponse().setBody("B"));
-    server.play();
 
     URL url = server.getUrl("/");
     assertEquals("A", readAscii(openConnection(url)));
@@ -932,7 +890,6 @@ private RecordedRequest assertClientSuppliedCondition(MockResponse seed, String
       String conditionValue) throws Exception {
     server.enqueue(seed.setBody("A"));
     server.enqueue(new MockResponse().setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
-    server.play();
 
     URL url = server.getUrl("/");
     assertEquals("A", readAscii(openConnection(url)));
@@ -949,19 +906,17 @@ private RecordedRequest assertClientSuppliedCondition(MockResponse seed, String
   @Test public void setIfModifiedSince() throws Exception {
     Date since = new Date();
     server.enqueue(new MockResponse().setBody("A"));
-    server.play();
 
     URL url = server.getUrl("/");
     URLConnection connection = openConnection(url);
     connection.setIfModifiedSince(since.getTime());
     assertEquals("A", readAscii(connection));
     RecordedRequest request = server.takeRequest();
-    assertTrue(request.getHeaders().contains("If-Modified-Since: " + formatDate(since)));
+    assertTrue(request.getHeaders().contains("If-Modified-Since: " + HttpDate.format(since)));
   }
 
   @Test public void clientSuppliedConditionWithoutCachedResult() throws Exception {
     server.enqueue(new MockResponse().setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
-    server.play();
 
     HttpURLConnection connection = openConnection(server.getUrl("/"));
     String clientIfModifiedSince = formatDate(-24, TimeUnit.HOURS);
@@ -976,7 +931,6 @@ private RecordedRequest assertClientSuppliedCondition(MockResponse seed, String
             .addHeader("Cache-Control: max-age=60")
             .setBody("A"));
     server.enqueue(new MockResponse().setBody("B"));
-    server.play();
 
     URL url = server.getUrl("/");
     URLConnection connection = openConnection(url);
@@ -1002,7 +956,6 @@ private RecordedRequest assertClientSuppliedCondition(MockResponse seed, String
   public void assertAuthorizationRequestFullyCached(MockResponse response) throws Exception {
     server.enqueue(response.addHeader("Cache-Control: max-age=60").setBody("A"));
     server.enqueue(new MockResponse().setBody("B"));
-    server.play();
 
     URL url = server.getUrl("/");
     URLConnection connection = openConnection(url);
@@ -1016,7 +969,6 @@ public void assertAuthorizationRequestFullyCached(MockResponse response) throws
         .addHeader("Content-Location: /bar")
         .setBody("A"));
     server.enqueue(new MockResponse().setBody("B"));
-    server.play();
 
     assertEquals("A", readAscii(openConnection(server.getUrl("/foo"))));
     assertEquals("B", readAscii(openConnection(server.getUrl("/bar"))));
@@ -1026,7 +978,6 @@ public void assertAuthorizationRequestFullyCached(MockResponse response) throws
     server.enqueue(
         new MockResponse().addHeader("Cache-Control: max-age=60").setBody("A").setBody("A"));
     server.enqueue(new MockResponse().setBody("B"));
-    server.play();
 
     URLConnection connection = openConnection(server.getUrl("/"));
     connection.setUseCaches(false);
@@ -1038,7 +989,6 @@ public void assertAuthorizationRequestFullyCached(MockResponse response) throws
     server.enqueue(
         new MockResponse().addHeader("Cache-Control: max-age=60").setBody("A").setBody("A"));
     server.enqueue(new MockResponse().setBody("B"));
-    server.play();
 
     assertEquals("A", readAscii(openConnection(server.getUrl("/"))));
     URLConnection connection = openConnection(server.getUrl("/"));
@@ -1068,7 +1018,6 @@ public void assertAuthorizationRequestFullyCached(MockResponse response) throws
         .setBody("A"));
     server.enqueue(new MockResponse().setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
     server.enqueue(new MockResponse().setBody("B"));
-    server.play();
 
     assertEquals("A", readAscii(openConnection(server.getUrl("/a"))));
     assertEquals("A", readAscii(openConnection(server.getUrl("/a"))));
@@ -1090,7 +1039,6 @@ public void assertAuthorizationRequestFullyCached(MockResponse response) throws
     server.enqueue(
         new MockResponse().addHeader("Cache-Control: max-age=60")
             .addHeader(InMemoryResponseCache.CACHE_VARIANT_HEADER, "B").setBody("B"));
-    server.play();
 
     URL url = server.getUrl("/");
     URLConnection connection1 = openConnection(url);
@@ -1121,7 +1069,6 @@ public void assertAuthorizationRequestFullyCached(MockResponse response) throws
     server.enqueue(new MockResponse().addHeader(
         "Set-Cookie: a=SECOND; domain=" + server.getCookieDomain() + ";")
         .setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
-    server.play();
 
     CookieManager cookieManager = new CookieManager();
     CookieManager.setDefault(cookieManager);
@@ -1140,7 +1087,6 @@ public void assertAuthorizationRequestFullyCached(MockResponse response) throws
         .setBody("A"));
     server.enqueue(new MockResponse().addHeader("Allow: GET, HEAD, PUT")
         .setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
-    server.play();
 
     URLConnection connection1 = openConnection(server.getUrl("/"));
     assertEquals("A", readAscii(connection1));
@@ -1158,7 +1104,6 @@ public void assertAuthorizationRequestFullyCached(MockResponse response) throws
         .setBody("A"));
     server.enqueue(new MockResponse().addHeader("Transfer-Encoding: none")
         .setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
-    server.play();
 
     URLConnection connection1 = openConnection(server.getUrl("/"));
     assertEquals("A", readAscii(connection1));
@@ -1175,7 +1120,6 @@ public void assertAuthorizationRequestFullyCached(MockResponse response) throws
         .addHeader("Cache-Control: max-age=0")
         .setBody("A"));
     server.enqueue(new MockResponse().setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
-    server.play();
 
     URLConnection connection1 = openConnection(server.getUrl("/"));
     assertEquals("A", readAscii(connection1));
@@ -1192,7 +1136,6 @@ public void assertAuthorizationRequestFullyCached(MockResponse response) throws
         .addHeader("Cache-Control: max-age=0")
         .setBody("A"));
     server.enqueue(new MockResponse().setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
-    server.play();
 
     URLConnection connection1 = openConnection(server.getUrl("/"));
     assertEquals("A", readAscii(connection1));
@@ -1220,7 +1163,7 @@ public void assertCookies(CookieManager cookieManager, URL url, String... expect
   }
 
   /**
-   * Equivalent to {@link HttpResponseCacheTest#conditionalHitUpdatesCache()}, except a Java
+   * Equivalent to {@link com.squareup.okhttp.CacheTest#conditionalHitUpdatesCache()}, except a Java
    * standard cache has no means to update the headers for an existing entry so the behavior is
    * different.
    */
@@ -1238,7 +1181,6 @@ public void assertCookies(CookieManager cookieManager, URL url, String... expect
     server.enqueue(new MockResponse().setBody("B").addHeader("Cache-Control: max-age=30"));
     // A response that should never be requested.
     server.enqueue(new MockResponse().setBody("C"));
-    server.play();
 
     // cache miss; seed the cache with an entry that will require a network hit to be sure it is
     // still valid
@@ -1267,15 +1209,11 @@ public void assertCookies(CookieManager cookieManager, URL url, String... expect
     server.enqueue(new MockResponse().setBody("A")
         .addHeader("Cache-Control: max-age=30")
         .addHeader("Date: " + formatDate(0, TimeUnit.MINUTES)));
-    server.play();
 
     assertEquals("A", readAscii(openConnection(server.getUrl("/"))));
     URLConnection connection = openConnection(server.getUrl("/"));
     connection.addRequestProperty("Cache-Control", "only-if-cached");
     assertEquals("A", readAscii(connection));
-
-    String source = connection.getHeaderField(OkHeaders.RESPONSE_SOURCE);
-    assertEquals(ResponseSource.CACHE + " 200", source);
   }
 
   @Test public void responseSourceHeaderConditionalCacheFetched() throws IOException {
@@ -1285,14 +1223,10 @@ public void assertCookies(CookieManager cookieManager, URL url, String... expect
     server.enqueue(new MockResponse().setBody("B")
         .addHeader("Cache-Control: max-age=30")
         .addHeader("Date: " + formatDate(0, TimeUnit.MINUTES)));
-    server.play();
 
     assertEquals("A", readAscii(openConnection(server.getUrl("/"))));
     HttpURLConnection connection = openConnection(server.getUrl("/"));
     assertEquals("B", readAscii(connection));
-
-    String source = connection.getHeaderField(OkHeaders.RESPONSE_SOURCE);
-    assertEquals(ResponseSource.CONDITIONAL_CACHE + " 200", source);
   }
 
   @Test public void responseSourceHeaderConditionalCacheNotFetched() throws IOException {
@@ -1300,25 +1234,17 @@ public void assertCookies(CookieManager cookieManager, URL url, String... expect
         .addHeader("Cache-Control: max-age=0")
         .addHeader("Date: " + formatDate(0, TimeUnit.MINUTES)));
     server.enqueue(new MockResponse().setResponseCode(304));
-    server.play();
 
     assertEquals("A", readAscii(openConnection(server.getUrl("/"))));
     HttpURLConnection connection = openConnection(server.getUrl("/"));
     assertEquals("A", readAscii(connection));
-
-    String source = connection.getHeaderField(OkHeaders.RESPONSE_SOURCE);
-    assertEquals(ResponseSource.CONDITIONAL_CACHE + " 304", source);
   }
 
   @Test public void responseSourceHeaderFetched() throws IOException {
     server.enqueue(new MockResponse().setBody("A"));
-    server.play();
 
     URLConnection connection = openConnection(server.getUrl("/"));
     assertEquals("A", readAscii(connection));
-
-    String source = connection.getHeaderField(OkHeaders.RESPONSE_SOURCE);
-    assertEquals(ResponseSource.NETWORK + " 200", source);
   }
 
   @Test public void emptyResponseHeaderNameFromCacheIsLenient() throws Exception {
@@ -1326,7 +1252,7 @@ public void assertCookies(CookieManager cookieManager, URL url, String... expect
         .addHeader("Cache-Control: max-age=120")
         .addHeader(": A")
         .setBody("body"));
-    server.play();
+
     HttpURLConnection connection = openConnection(server.getUrl("/"));
     assertEquals("A", connection.getHeaderField(""));
   }
@@ -1337,13 +1263,7 @@ public void assertCookies(CookieManager cookieManager, URL url, String... expect
    * future.
    */
   private String formatDate(long delta, TimeUnit timeUnit) {
-    return formatDate(new Date(System.currentTimeMillis() + timeUnit.toMillis(delta)));
-  }
-
-  private String formatDate(Date date) {
-    DateFormat rfc1123 = new SimpleDateFormat("EEE, dd MMM yyyy HH:mm:ss zzz", Locale.US);
-    rfc1123.setTimeZone(TimeZone.getTimeZone("GMT"));
-    return rfc1123.format(date);
+    return HttpDate.format(new Date(System.currentTimeMillis() + timeUnit.toMillis(delta)));
   }
 
   private void addRequestBodyIfNecessary(String requestMethod, HttpURLConnection invalidate)
@@ -1359,7 +1279,6 @@ private void addRequestBodyIfNecessary(String requestMethod, HttpURLConnection i
   private void assertNotCached(MockResponse response) throws Exception {
     server.enqueue(response.setBody("A"));
     server.enqueue(new MockResponse().setBody("B"));
-    server.play();
 
     URL url = server.getUrl("/");
     assertEquals("A", readAscii(openConnection(url)));
@@ -1376,8 +1295,6 @@ private RecordedRequest assertConditionallyCached(MockResponse response) throws
     server.enqueue(response.setBody("B").setStatus("HTTP/1.1 200 B-OK"));
     server.enqueue(new MockResponse().setStatus("HTTP/1.1 200 C-OK").setBody("C"));
 
-    server.play();
-
     URL valid = server.getUrl("/valid");
     HttpURLConnection connection1 = openConnection(valid);
     assertEquals("A", readAscii(connection1));
@@ -1405,7 +1322,6 @@ private RecordedRequest assertConditionallyCached(MockResponse response) throws
   private void assertFullyCached(MockResponse response) throws Exception {
     server.enqueue(response.setBody("A"));
     server.enqueue(response.setBody("B"));
-    server.play();
 
     URL url = server.getUrl("/");
     assertEquals("A", readAscii(openConnection(url)));
@@ -1420,7 +1336,9 @@ private void assertFullyCached(MockResponse response) throws Exception {
   private MockResponse truncateViolently(MockResponse response, int numBytesToKeep) {
     response.setSocketPolicy(DISCONNECT_AT_END);
     List<String> headers = new ArrayList<String>(response.getHeaders());
-    response.setBody(Arrays.copyOfRange(response.getBody(), 0, numBytesToKeep));
+    Buffer truncatedBody = new Buffer();
+    truncatedBody.write(response.getBody(), numBytesToKeep);
+    response.setBody(truncatedBody);
     response.getHeaders().clear();
     response.getHeaders().addAll(headers);
     return response;
@@ -1465,24 +1383,22 @@ private void assertGatewayTimeout(HttpURLConnection connection) throws IOExcepti
     }
     assertEquals(504, connection.getResponseCode());
     assertEquals(-1, connection.getErrorStream().read());
-    assertEquals(ResponseSource.NONE + " 504",
-        connection.getHeaderField(OkHeaders.RESPONSE_SOURCE));
   }
 
   enum TransferKind {
     CHUNKED() {
-      @Override void setBody(MockResponse response, byte[] content, int chunkSize)
+      @Override void setBody(MockResponse response, Buffer content, int chunkSize)
           throws IOException {
         response.setChunkedBody(content, chunkSize);
       }
     },
     FIXED_LENGTH() {
-      @Override void setBody(MockResponse response, byte[] content, int chunkSize) {
+      @Override void setBody(MockResponse response, Buffer content, int chunkSize) {
         response.setBody(content);
       }
     },
     END_OF_STREAM() {
-      @Override void setBody(MockResponse response, byte[] content, int chunkSize) {
+      @Override void setBody(MockResponse response, Buffer content, int chunkSize) {
         response.setBody(content);
         response.setSocketPolicy(DISCONNECT_AT_END);
         for (Iterator<String> h = response.getHeaders().iterator(); h.hasNext(); ) {
@@ -1494,10 +1410,10 @@ private void assertGatewayTimeout(HttpURLConnection connection) throws IOExcepti
       }
     };
 
-    abstract void setBody(MockResponse response, byte[] content, int chunkSize) throws IOException;
+    abstract void setBody(MockResponse response, Buffer content, int chunkSize) throws IOException;
 
     void setBody(MockResponse response, String content, int chunkSize) throws IOException {
-      setBody(response, content.getBytes("UTF-8"), chunkSize);
+      setBody(response, new Buffer().writeUtf8(content), chunkSize);
     }
   }
 
@@ -1506,12 +1422,12 @@ void setBody(MockResponse response, String content, int chunkSize) throws IOExce
   }
 
   /** Returns a gzipped copy of {@code bytes}. */
-  public byte[] gzip(byte[] bytes) throws IOException {
-    ByteArrayOutputStream bytesOut = new ByteArrayOutputStream();
-    OutputStream gzippedOut = new GZIPOutputStream(bytesOut);
-    gzippedOut.write(bytes);
-    gzippedOut.close();
-    return bytesOut.toByteArray();
+  public Buffer gzip(String data) throws IOException {
+    Buffer result = new Buffer();
+    BufferedSink sink = Okio.buffer(new GzipSink(result));
+    sink.writeUtf8(data);
+    sink.close();
+    return result;
   }
 
   private static class InsecureResponseCache extends ResponseCache {
diff --git a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/spdy/BaseTestHandler.java b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/spdy/BaseTestHandler.java
index 8f709220ed..d0b5e97ddb 100644
--- a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/spdy/BaseTestHandler.java
+++ b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/spdy/BaseTestHandler.java
@@ -30,7 +30,7 @@
 
   @Override
   public void headers(boolean outFinished, boolean inFinished, int streamId, int associatedStreamId,
-      int priority, List<Header> headerBlock, HeadersMode headersMode) {
+      List<Header> headerBlock, HeadersMode headersMode) {
     fail();
   }
 
@@ -58,7 +58,8 @@ public void headers(boolean outFinished, boolean inFinished, int streamId, int a
     fail();
   }
 
-  @Override public void priority(int streamId, int priority) {
+  @Override public void priority(int streamId, int streamDependency, int weight,
+      boolean exclusive) {
     fail();
   }
 
@@ -66,4 +67,9 @@ public void headers(boolean outFinished, boolean inFinished, int streamId, int a
   public void pushPromise(int streamId, int associatedStreamId, List<Header> headerBlock) {
     fail();
   }
+
+  @Override public void alternateService(int streamId, String origin, ByteString protocol,
+      String host, int port, long maxAge) {
+    fail();
+  }
 }
diff --git a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/spdy/HpackDraft05Test.java b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/spdy/HpackDraft05Test.java
deleted file mode 100644
index d86db867c8..0000000000
--- a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/spdy/HpackDraft05Test.java
+++ /dev/null
@@ -1,848 +0,0 @@
-/*
- * Copyright (C) 2013 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.squareup.okhttp.internal.spdy;
-
-import java.io.IOException;
-import java.util.Arrays;
-import java.util.List;
-import okio.ByteString;
-import okio.OkBuffer;
-import org.junit.Before;
-import org.junit.Test;
-
-import static com.squareup.okhttp.internal.Util.headerEntries;
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertFalse;
-import static org.junit.Assert.assertTrue;
-
-public class HpackDraft05Test {
-
-  private final OkBuffer bytesIn = new OkBuffer();
-  private HpackDraft05.Reader hpackReader;
-  private OkBuffer bytesOut = new OkBuffer();
-  private HpackDraft05.Writer hpackWriter;
-
-  @Before public void reset() {
-    hpackReader = newReader(bytesIn);
-    hpackWriter = new HpackDraft05.Writer(bytesOut);
-  }
-
-  /**
-   * Variable-length quantity special cases strings which are longer than 127
-   * bytes.  Values such as cookies can be 4KiB, and should be possible to send.
-   *
-   * <p> http://tools.ietf.org/html/draft-ietf-httpbis-header-compression-05#section-4.1.2
-   */
-  @Test public void largeHeaderValue() throws IOException {
-    char[] value = new char[4096];
-    Arrays.fill(value, '!');
-    List<Header> headerBlock = headerEntries("cookie", new String(value));
-
-    hpackWriter.writeHeaders(headerBlock);
-    bytesIn.write(bytesOut, bytesOut.size());
-    hpackReader.readHeaders();
-    hpackReader.emitReferenceSet();
-
-    assertEquals(0, hpackReader.headerCount);
-
-    assertEquals(headerBlock, hpackReader.getAndReset());
-  }
-
-  /**
-   * HPACK has a max header table size, which can be smaller than the max header message.
-   * Ensure the larger header content is not lost.
-   */
-  @Test public void tooLargeToHPackIsStillEmitted() throws IOException {
-    OkBuffer out = new OkBuffer();
-
-    out.writeByte(0x00); // Literal indexed
-    out.writeByte(0x0a); // Literal name (len = 10)
-    out.writeUtf8("custom-key");
-
-    out.writeByte(0x0d); // Literal value (len = 13)
-    out.writeUtf8("custom-header");
-
-    bytesIn.write(out, out.size());
-    hpackReader.maxHeaderTableByteCount(1);
-    hpackReader.readHeaders();
-    hpackReader.emitReferenceSet();
-
-    assertEquals(0, hpackReader.headerCount);
-
-    assertEquals(headerEntries("custom-key", "custom-header"), hpackReader.getAndReset());
-  }
-
-  /** Oldest entries are evicted to support newer ones. */
-  @Test public void testEviction() throws IOException {
-    OkBuffer out = new OkBuffer();
-
-    out.writeByte(0x00); // Literal indexed
-    out.writeByte(0x0a); // Literal name (len = 10)
-    out.writeUtf8("custom-foo");
-
-    out.writeByte(0x0d); // Literal value (len = 13)
-    out.writeUtf8("custom-header");
-
-    out.writeByte(0x00); // Literal indexed
-    out.writeByte(0x0a); // Literal name (len = 10)
-    out.writeUtf8("custom-bar");
-
-    out.writeByte(0x0d); // Literal value (len = 13)
-    out.writeUtf8("custom-header");
-
-    out.writeByte(0x00); // Literal indexed
-    out.writeByte(0x0a); // Literal name (len = 10)
-    out.writeUtf8("custom-baz");
-
-    out.writeByte(0x0d); // Literal value (len = 13)
-    out.writeUtf8("custom-header");
-
-    bytesIn.write(out, out.size());
-    // Set to only support 110 bytes (enough for 2 headers).
-    hpackReader.maxHeaderTableByteCount(110);
-    hpackReader.readHeaders();
-    hpackReader.emitReferenceSet();
-
-    assertEquals(2, hpackReader.headerCount);
-
-    Header entry = hpackReader.headerTable[headerTableLength() - 1];
-    checkEntry(entry, "custom-bar", "custom-header", 55);
-    assertHeaderReferenced(headerTableLength() - 1);
-
-    entry = hpackReader.headerTable[headerTableLength() - 2];
-    checkEntry(entry, "custom-baz", "custom-header", 55);
-    assertHeaderReferenced(headerTableLength() - 2);
-
-    // foo isn't here as it is no longer in the table.
-    // TODO: emit before eviction?
-    assertEquals(headerEntries("custom-bar", "custom-header", "custom-baz", "custom-header"),
-        hpackReader.getAndReset());
-
-    // Simulate receiving a small settings frame, that implies eviction.
-    hpackReader.maxHeaderTableByteCount(55);
-    assertEquals(1, hpackReader.headerCount);
-  }
-
-  /** Header table backing array is initially 8 long, let's ensure it grows. */
-  @Test public void dynamicallyGrowsBeyond64Entries() throws IOException {
-    OkBuffer out = new OkBuffer();
-
-    for (int i = 0; i < 256; i++) {
-      out.writeByte(0x00); // Literal indexed
-      out.writeByte(0x0a); // Literal name (len = 10)
-      out.writeUtf8("custom-foo");
-
-      out.writeByte(0x0d); // Literal value (len = 13)
-      out.writeUtf8("custom-header");
-    }
-
-    bytesIn.write(out, out.size());
-    hpackReader.maxHeaderTableByteCount(16384); // Lots of headers need more room!
-    hpackReader.readHeaders();
-    hpackReader.emitReferenceSet();
-
-    assertEquals(256, hpackReader.headerCount);
-    assertHeaderReferenced(headerTableLength() - 1);
-    assertHeaderReferenced(headerTableLength() - hpackReader.headerCount);
-  }
-
-  @Test public void huffmanDecodingSupported() throws IOException {
-    OkBuffer out = new OkBuffer();
-
-    out.writeByte(0x04); // == Literal indexed ==
-                         // Indexed name (idx = 4) -> :path
-    out.writeByte(0x8b); // Literal value Huffman encoded 11 bytes
-                         // decodes to www.example.com which is length 15
-    byte[] huffmanBytes = new byte[] {
-        (byte) 0xdb, (byte) 0x6d, (byte) 0x88, (byte) 0x3e,
-        (byte) 0x68, (byte) 0xd1, (byte) 0xcb, (byte) 0x12,
-        (byte) 0x25, (byte) 0xba, (byte) 0x7f};
-    out.write(huffmanBytes, 0, huffmanBytes.length);
-
-    bytesIn.write(out, out.size());
-    hpackReader.readHeaders();
-    hpackReader.emitReferenceSet();
-
-    assertEquals(1, hpackReader.headerCount);
-    assertEquals(52, hpackReader.headerTableByteCount);
-
-    Header entry = hpackReader.headerTable[headerTableLength() - 1];
-    checkEntry(entry, ":path", "www.example.com", 52);
-    assertHeaderReferenced(headerTableLength() - 1);
-  }
-
-  /**
-   * http://tools.ietf.org/html/draft-ietf-httpbis-header-compression-05#appendix-E.1.1
-   */
-  @Test public void readLiteralHeaderFieldWithIndexing() throws IOException {
-    OkBuffer out = new OkBuffer();
-
-    out.writeByte(0x00); // Literal indexed
-    out.writeByte(0x0a); // Literal name (len = 10)
-    out.writeUtf8("custom-key");
-
-    out.writeByte(0x0d); // Literal value (len = 13)
-    out.writeUtf8("custom-header");
-
-    bytesIn.write(out, out.size());
-    hpackReader.readHeaders();
-    hpackReader.emitReferenceSet();
-
-    assertEquals(1, hpackReader.headerCount);
-    assertEquals(55, hpackReader.headerTableByteCount);
-
-    Header entry = hpackReader.headerTable[headerTableLength() - 1];
-    checkEntry(entry, "custom-key", "custom-header", 55);
-    assertHeaderReferenced(headerTableLength() - 1);
-
-    assertEquals(headerEntries("custom-key", "custom-header"), hpackReader.getAndReset());
-  }
-
-  /**
-   * Literal Header Field without Indexing - New Name
-   */
-  @Test public void literalHeaderFieldWithoutIndexingNewName() throws IOException {
-    List<Header> headerBlock = headerEntries("custom-key", "custom-header");
-
-    OkBuffer expectedBytes = new OkBuffer();
-
-    expectedBytes.writeByte(0x40); // Not indexed
-    expectedBytes.writeByte(0x0a); // Literal name (len = 10)
-    expectedBytes.write("custom-key".getBytes(), 0, 10);
-
-    expectedBytes.writeByte(0x0d); // Literal value (len = 13)
-    expectedBytes.write("custom-header".getBytes(), 0, 13);
-
-    hpackWriter.writeHeaders(headerBlock);
-    assertEquals(expectedBytes, bytesOut);
-
-    bytesIn.write(bytesOut, bytesOut.size());
-    hpackReader.readHeaders();
-    hpackReader.emitReferenceSet();
-
-    assertEquals(0, hpackReader.headerCount);
-
-    assertEquals(headerBlock, hpackReader.getAndReset());
-  }
-
-  /**
-   * http://tools.ietf.org/html/draft-ietf-httpbis-header-compression-05#appendix-E.1.2
-   */
-  @Test public void literalHeaderFieldWithoutIndexingIndexedName() throws IOException {
-    List<Header> headerBlock = headerEntries(":path", "/sample/path");
-
-    OkBuffer expectedBytes = new OkBuffer();
-    expectedBytes.writeByte(0x44); // == Literal not indexed ==
-                                   // Indexed name (idx = 4) -> :path
-    expectedBytes.writeByte(0x0c); // Literal value (len = 12)
-    expectedBytes.write("/sample/path".getBytes(), 0, 12);
-
-    hpackWriter.writeHeaders(headerBlock);
-    assertEquals(expectedBytes, bytesOut);
-
-    bytesIn.write(bytesOut, bytesOut.size());
-    hpackReader.readHeaders();
-    hpackReader.emitReferenceSet();
-
-    assertEquals(0, hpackReader.headerCount);
-
-    assertEquals(headerBlock, hpackReader.getAndReset());
-  }
-
-  /**
-   * http://tools.ietf.org/html/draft-ietf-httpbis-header-compression-05#appendix-E.1.3
-   */
-  @Test public void readIndexedHeaderField() throws IOException {
-    bytesIn.writeByte(0x82); // == Indexed - Add ==
-                             // idx = 2 -> :method: GET
-
-    hpackReader.readHeaders();
-    hpackReader.emitReferenceSet();
-
-    assertEquals(1, hpackReader.headerCount);
-    assertEquals(42, hpackReader.headerTableByteCount);
-
-    Header entry = hpackReader.headerTable[headerTableLength() - 1];
-    checkEntry(entry, ":method", "GET", 42);
-    assertHeaderReferenced(headerTableLength() - 1);
-
-    assertEquals(headerEntries(":method", "GET"), hpackReader.getAndReset());
-  }
-
-  /**
-   * http://tools.ietf.org/html/draft-ietf-httpbis-header-compression-05#section-3.2.1
-   */
-  @Test public void toggleIndex() throws IOException {
-    // Static table entries are copied to the top of the reference set.
-    bytesIn.writeByte(0x82); // == Indexed - Add ==
-                             // idx = 2 -> :method: GET
-    // Specifying an index to an entry in the reference set removes it.
-    bytesIn.writeByte(0x81); // == Indexed - Remove ==
-                             // idx = 1 -> :method: GET
-
-    hpackReader.readHeaders();
-    hpackReader.emitReferenceSet();
-
-    assertEquals(1, hpackReader.headerCount);
-    assertEquals(42, hpackReader.headerTableByteCount);
-
-    Header entry = hpackReader.headerTable[headerTableLength() - 1];
-    checkEntry(entry, ":method", "GET", 42);
-    assertHeaderNotReferenced(headerTableLength() - 1);
-
-    assertTrue(hpackReader.getAndReset().isEmpty());
-  }
-
-  /**
-   * http://tools.ietf.org/html/draft-ietf-httpbis-header-compression-05#appendix-E.1.4
-   */
-  @Test public void readIndexedHeaderFieldFromStaticTableWithoutBuffering() throws IOException {
-    bytesIn.writeByte(0x82); // == Indexed - Add ==
-                             // idx = 2 -> :method: GET
-
-    hpackReader.maxHeaderTableByteCount(0); // SETTINGS_HEADER_TABLE_SIZE == 0
-    hpackReader.readHeaders();
-    hpackReader.emitReferenceSet();
-
-    // Not buffered in header table.
-    assertEquals(0, hpackReader.headerCount);
-
-    assertEquals(headerEntries(":method", "GET"), hpackReader.getAndReset());
-  }
-
-  /**
-   * http://tools.ietf.org/html/draft-ietf-httpbis-header-compression-05#appendix-E.2
-   */
-  @Test public void readRequestExamplesWithoutHuffman() throws IOException {
-    OkBuffer out = firstRequestWithoutHuffman();
-    bytesIn.write(out, out.size());
-    hpackReader.readHeaders();
-    hpackReader.emitReferenceSet();
-    checkReadFirstRequestWithoutHuffman();
-
-    out = secondRequestWithoutHuffman();
-    bytesIn.write(out, out.size());
-    hpackReader.readHeaders();
-    hpackReader.emitReferenceSet();
-    checkReadSecondRequestWithoutHuffman();
-
-    out = thirdRequestWithoutHuffman();
-    bytesIn.write(out, out.size());
-    hpackReader.readHeaders();
-    hpackReader.emitReferenceSet();
-    checkReadThirdRequestWithoutHuffman();
-  }
-
-  private OkBuffer firstRequestWithoutHuffman() {
-    OkBuffer out = new OkBuffer();
-
-    out.writeByte(0x82); // == Indexed - Add ==
-                         // idx = 2 -> :method: GET
-    out.writeByte(0x87); // == Indexed - Add ==
-                         // idx = 7 -> :scheme: http
-    out.writeByte(0x86); // == Indexed - Add ==
-                         // idx = 6 -> :path: /
-    out.writeByte(0x04); // == Literal indexed ==
-                         // Indexed name (idx = 4) -> :authority
-    out.writeByte(0x0f); // Literal value (len = 15)
-    out.writeUtf8("www.example.com");
-
-    return out;
-  }
-
-  private void checkReadFirstRequestWithoutHuffman() {
-    assertEquals(4, hpackReader.headerCount);
-
-    // [  1] (s =  57) :authority: www.example.com
-    Header entry = hpackReader.headerTable[headerTableLength() - 4];
-    checkEntry(entry, ":authority", "www.example.com", 57);
-    assertHeaderReferenced(headerTableLength() - 4);
-
-    // [  2] (s =  38) :path: /
-    entry = hpackReader.headerTable[headerTableLength() - 3];
-    checkEntry(entry, ":path", "/", 38);
-    assertHeaderReferenced(headerTableLength() - 3);
-
-    // [  3] (s =  43) :scheme: http
-    entry = hpackReader.headerTable[headerTableLength() - 2];
-    checkEntry(entry, ":scheme", "http", 43);
-    assertHeaderReferenced(headerTableLength() - 2);
-
-    // [  4] (s =  42) :method: GET
-    entry = hpackReader.headerTable[headerTableLength() - 1];
-    checkEntry(entry, ":method", "GET", 42);
-    assertHeaderReferenced(headerTableLength() - 1);
-
-    // Table size: 180
-    assertEquals(180, hpackReader.headerTableByteCount);
-
-    // Decoded header set:
-    assertEquals(headerEntries(
-        ":method", "GET",
-        ":scheme", "http",
-        ":path", "/",
-        ":authority", "www.example.com"), hpackReader.getAndReset());
-  }
-
-  private OkBuffer secondRequestWithoutHuffman() {
-    OkBuffer out = new OkBuffer();
-
-    out.writeByte(0x1b); // == Literal indexed ==
-                         // Indexed name (idx = 27) -> cache-control
-    out.writeByte(0x08); // Literal value (len = 8)
-    out.writeUtf8("no-cache");
-
-    return out;
-  }
-
-  private void checkReadSecondRequestWithoutHuffman() {
-    assertEquals(5, hpackReader.headerCount);
-
-    // [  1] (s =  53) cache-control: no-cache
-    Header entry = hpackReader.headerTable[headerTableLength() - 5];
-    checkEntry(entry, "cache-control", "no-cache", 53);
-    assertHeaderReferenced(headerTableLength() - 5);
-
-    // [  2] (s =  57) :authority: www.example.com
-    entry = hpackReader.headerTable[headerTableLength() - 4];
-    checkEntry(entry, ":authority", "www.example.com", 57);
-    assertHeaderReferenced(headerTableLength() - 4);
-
-    // [  3] (s =  38) :path: /
-    entry = hpackReader.headerTable[headerTableLength() - 3];
-    checkEntry(entry, ":path", "/", 38);
-    assertHeaderReferenced(headerTableLength() - 3);
-
-    // [  4] (s =  43) :scheme: http
-    entry = hpackReader.headerTable[headerTableLength() - 2];
-    checkEntry(entry, ":scheme", "http", 43);
-    assertHeaderReferenced(headerTableLength() - 2);
-
-    // [  5] (s =  42) :method: GET
-    entry = hpackReader.headerTable[headerTableLength() - 1];
-    checkEntry(entry, ":method", "GET", 42);
-    assertHeaderReferenced(headerTableLength() - 1);
-
-    // Table size: 233
-    assertEquals(233, hpackReader.headerTableByteCount);
-
-    // Decoded header set:
-    assertEquals(headerEntries(
-        ":method", "GET",
-        ":scheme", "http",
-        ":path", "/",
-        ":authority", "www.example.com",
-        "cache-control", "no-cache"), hpackReader.getAndReset());
-  }
-
-  private OkBuffer thirdRequestWithoutHuffman() {
-    OkBuffer out = new OkBuffer();
-
-    out.writeByte(0x80); // == Empty reference set ==
-    out.writeByte(0x85); // == Indexed - Add ==
-                         // idx = 5 -> :method: GET
-    out.writeByte(0x8c); // == Indexed - Add ==
-                         // idx = 12 -> :scheme: https
-    out.writeByte(0x8b); // == Indexed - Add ==
-                         // idx = 11 -> :path: /index.html
-    out.writeByte(0x84); // == Indexed - Add ==
-                         // idx = 4 -> :authority: www.example.com
-    out.writeByte(0x00); // Literal indexed
-    out.writeByte(0x0a); // Literal name (len = 10)
-    out.writeUtf8("custom-key");
-    out.writeByte(0x0c); // Literal value (len = 12)
-    out.writeUtf8("custom-value");
-
-    return out;
-  }
-
-  private void checkReadThirdRequestWithoutHuffman() {
-    assertEquals(8, hpackReader.headerCount);
-
-    // [  1] (s =  54) custom-key: custom-value
-    Header entry = hpackReader.headerTable[headerTableLength() - 8];
-    checkEntry(entry, "custom-key", "custom-value", 54);
-    assertHeaderReferenced(headerTableLength() - 8);
-
-    // [  2] (s =  48) :path: /index.html
-    entry = hpackReader.headerTable[headerTableLength() - 7];
-    checkEntry(entry, ":path", "/index.html", 48);
-    assertHeaderReferenced(headerTableLength() - 7);
-
-    // [  3] (s =  44) :scheme: https
-    entry = hpackReader.headerTable[headerTableLength() - 6];
-    checkEntry(entry, ":scheme", "https", 44);
-    assertHeaderReferenced(headerTableLength() - 6);
-
-    // [  4] (s =  53) cache-control: no-cache
-    entry = hpackReader.headerTable[headerTableLength() - 5];
-    checkEntry(entry, "cache-control", "no-cache", 53);
-    assertHeaderNotReferenced(headerTableLength() - 5);
-
-    // [  5] (s =  57) :authority: www.example.com
-    entry = hpackReader.headerTable[headerTableLength() - 4];
-    checkEntry(entry, ":authority", "www.example.com", 57);
-    assertHeaderReferenced(headerTableLength() - 4);
-
-    // [  6] (s =  38) :path: /
-    entry = hpackReader.headerTable[headerTableLength() - 3];
-    checkEntry(entry, ":path", "/", 38);
-    assertHeaderNotReferenced(headerTableLength() - 3);
-
-    // [  7] (s =  43) :scheme: http
-    entry = hpackReader.headerTable[headerTableLength() - 2];
-    checkEntry(entry, ":scheme", "http", 43);
-    assertHeaderNotReferenced(headerTableLength() - 2);
-
-    // [  8] (s =  42) :method: GET
-    entry = hpackReader.headerTable[headerTableLength() - 1];
-    checkEntry(entry, ":method", "GET", 42);
-    assertHeaderReferenced(headerTableLength() - 1);
-
-    // Table size: 379
-    assertEquals(379, hpackReader.headerTableByteCount);
-
-    // Decoded header set:
-    // TODO: order is not correct per docs, but then again, the spec doesn't require ordering.
-    assertEquals(headerEntries(
-        ":method", "GET",
-        ":authority", "www.example.com",
-        ":scheme", "https",
-        ":path", "/index.html",
-        "custom-key", "custom-value"), hpackReader.getAndReset());
-  }
-
-  /**
-   * http://tools.ietf.org/html/draft-ietf-httpbis-header-compression-05#appendix-E.3
-   */
-  @Test public void readRequestExamplesWithHuffman() throws IOException {
-    OkBuffer out = firstRequestWithHuffman();
-    bytesIn.write(out, out.size());
-    hpackReader.readHeaders();
-    hpackReader.emitReferenceSet();
-    checkReadFirstRequestWithHuffman();
-
-    out = secondRequestWithHuffman();
-    bytesIn.write(out, out.size());
-    hpackReader.readHeaders();
-    hpackReader.emitReferenceSet();
-    checkReadSecondRequestWithHuffman();
-
-    out = thirdRequestWithHuffman();
-    bytesIn.write(out, out.size());
-    hpackReader.readHeaders();
-    hpackReader.emitReferenceSet();
-    checkReadThirdRequestWithHuffman();
-  }
-
-  private OkBuffer firstRequestWithHuffman() {
-    OkBuffer out = new OkBuffer();
-
-    out.writeByte(0x82); // == Indexed - Add ==
-                         // idx = 2 -> :method: GET
-    out.writeByte(0x87); // == Indexed - Add ==
-                         // idx = 7 -> :scheme: http
-    out.writeByte(0x86); // == Indexed - Add ==
-                         // idx = 6 -> :path: /
-    out.writeByte(0x04); // == Literal indexed ==
-                         // Indexed name (idx = 4) -> :authority
-    out.writeByte(0x8b); // Literal value Huffman encoded 11 bytes
-                         // decodes to www.example.com which is length 15
-    byte[] huffmanBytes = new byte[] {
-        (byte) 0xdb, (byte) 0x6d, (byte) 0x88, (byte) 0x3e,
-        (byte) 0x68, (byte) 0xd1, (byte) 0xcb, (byte) 0x12,
-        (byte) 0x25, (byte) 0xba, (byte) 0x7f};
-    out.write(huffmanBytes, 0, huffmanBytes.length);
-
-    return out;
-  }
-
-  private void checkReadFirstRequestWithHuffman() {
-    assertEquals(4, hpackReader.headerCount);
-
-    // [  1] (s =  57) :authority: www.example.com
-    Header entry = hpackReader.headerTable[headerTableLength() - 4];
-    checkEntry(entry, ":authority", "www.example.com", 57);
-    assertHeaderReferenced(headerTableLength() - 4);
-
-    // [  2] (s =  38) :path: /
-    entry = hpackReader.headerTable[headerTableLength() - 3];
-    checkEntry(entry, ":path", "/", 38);
-    assertHeaderReferenced(headerTableLength() - 3);
-
-    // [  3] (s =  43) :scheme: http
-    entry = hpackReader.headerTable[headerTableLength() - 2];
-    checkEntry(entry, ":scheme", "http", 43);
-    assertHeaderReferenced(headerTableLength() - 2);
-
-    // [  4] (s =  42) :method: GET
-    entry = hpackReader.headerTable[headerTableLength() - 1];
-    checkEntry(entry, ":method", "GET", 42);
-    assertHeaderReferenced(headerTableLength() - 1);
-
-    // Table size: 180
-    assertEquals(180, hpackReader.headerTableByteCount);
-
-    // Decoded header set:
-    assertEquals(headerEntries(
-        ":method", "GET",
-        ":scheme", "http",
-        ":path", "/",
-        ":authority", "www.example.com"), hpackReader.getAndReset());
-  }
-
-  private OkBuffer secondRequestWithHuffman() {
-    OkBuffer out = new OkBuffer();
-
-    out.writeByte(0x1b); // == Literal indexed ==
-                         // Indexed name (idx = 27) -> cache-control
-    out.writeByte(0x86); // Literal value Huffman encoded 6 bytes
-                         // decodes to no-cache which is length 8
-    byte[] huffmanBytes = new byte[] {
-        (byte) 0x63, (byte) 0x65, (byte) 0x4a, (byte) 0x13,
-        (byte) 0x98, (byte) 0xff};
-    out.write(huffmanBytes, 0, huffmanBytes.length);
-
-    return out;
-  }
-
-  private void checkReadSecondRequestWithHuffman() {
-    assertEquals(5, hpackReader.headerCount);
-
-    // [  1] (s =  53) cache-control: no-cache
-    Header entry = hpackReader.headerTable[headerTableLength() - 5];
-    checkEntry(entry, "cache-control", "no-cache", 53);
-    assertHeaderReferenced(headerTableLength() - 5);
-
-    // [  2] (s =  57) :authority: www.example.com
-    entry = hpackReader.headerTable[headerTableLength() - 4];
-    checkEntry(entry, ":authority", "www.example.com", 57);
-    assertHeaderReferenced(headerTableLength() - 4);
-
-    // [  3] (s =  38) :path: /
-    entry = hpackReader.headerTable[headerTableLength() - 3];
-    checkEntry(entry, ":path", "/", 38);
-    assertHeaderReferenced(headerTableLength() - 3);
-
-    // [  4] (s =  43) :scheme: http
-    entry = hpackReader.headerTable[headerTableLength() - 2];
-    checkEntry(entry, ":scheme", "http", 43);
-    assertHeaderReferenced(headerTableLength() - 2);
-
-    // [  5] (s =  42) :method: GET
-    entry = hpackReader.headerTable[headerTableLength() - 1];
-    checkEntry(entry, ":method", "GET", 42);
-    assertHeaderReferenced(headerTableLength() - 1);
-
-    // Table size: 233
-    assertEquals(233, hpackReader.headerTableByteCount);
-
-    // Decoded header set:
-    assertEquals(headerEntries(
-        ":method", "GET",
-        ":scheme", "http",
-        ":path", "/",
-        ":authority", "www.example.com",
-        "cache-control", "no-cache"), hpackReader.getAndReset());
-  }
-
-  private OkBuffer thirdRequestWithHuffman() {
-    OkBuffer out = new OkBuffer();
-
-    out.writeByte(0x80); // == Empty reference set ==
-    out.writeByte(0x85); // == Indexed - Add ==
-                         // idx = 5 -> :method: GET
-    out.writeByte(0x8c); // == Indexed - Add ==
-                         // idx = 12 -> :scheme: https
-    out.writeByte(0x8b); // == Indexed - Add ==
-                         // idx = 11 -> :path: /index.html
-    out.writeByte(0x84); // == Indexed - Add ==
-                         // idx = 4 -> :authority: www.example.com
-    out.writeByte(0x00); // Literal indexed
-    out.writeByte(0x88); // Literal name Huffman encoded 8 bytes
-                         // decodes to custom-key which is length 10
-    byte[] huffmanBytes = new byte[] {
-        (byte) 0x4e, (byte) 0xb0, (byte) 0x8b, (byte) 0x74,
-        (byte) 0x97, (byte) 0x90, (byte) 0xfa, (byte) 0x7f};
-    out.write(huffmanBytes, 0, huffmanBytes.length);
-    out.writeByte(0x89); // Literal value Huffman encoded 6 bytes
-                         // decodes to custom-value which is length 12
-    huffmanBytes = new byte[] {
-        (byte) 0x4e, (byte) 0xb0, (byte) 0x8b, (byte) 0x74,
-        (byte) 0x97, (byte) 0x9a, (byte) 0x17, (byte) 0xa8,
-        (byte) 0xff};
-    out.write(huffmanBytes, 0, huffmanBytes.length);
-
-    return out;
-  }
-
-  private void checkReadThirdRequestWithHuffman() {
-    assertEquals(8, hpackReader.headerCount);
-
-    // [  1] (s =  54) custom-key: custom-value
-    Header entry = hpackReader.headerTable[headerTableLength() - 8];
-    checkEntry(entry, "custom-key", "custom-value", 54);
-    assertHeaderReferenced(headerTableLength() - 8);
-
-    // [  2] (s =  48) :path: /index.html
-    entry = hpackReader.headerTable[headerTableLength() - 7];
-    checkEntry(entry, ":path", "/index.html", 48);
-    assertHeaderReferenced(headerTableLength() - 7);
-
-    // [  3] (s =  44) :scheme: https
-    entry = hpackReader.headerTable[headerTableLength() - 6];
-    checkEntry(entry, ":scheme", "https", 44);
-    assertHeaderReferenced(headerTableLength() - 6);
-
-    // [  4] (s =  53) cache-control: no-cache
-    entry = hpackReader.headerTable[headerTableLength() - 5];
-    checkEntry(entry, "cache-control", "no-cache", 53);
-    assertHeaderNotReferenced(headerTableLength() - 5);
-
-    // [  5] (s =  57) :authority: www.example.com
-    entry = hpackReader.headerTable[headerTableLength() - 4];
-    checkEntry(entry, ":authority", "www.example.com", 57);
-    assertHeaderReferenced(headerTableLength() - 4);
-
-    // [  6] (s =  38) :path: /
-    entry = hpackReader.headerTable[headerTableLength() - 3];
-    checkEntry(entry, ":path", "/", 38);
-    assertHeaderNotReferenced(headerTableLength() - 3);
-
-    // [  7] (s =  43) :scheme: http
-    entry = hpackReader.headerTable[headerTableLength() - 2];
-    checkEntry(entry, ":scheme", "http", 43);
-    assertHeaderNotReferenced(headerTableLength() - 2);
-
-    // [  8] (s =  42) :method: GET
-    entry = hpackReader.headerTable[headerTableLength() - 1];
-    checkEntry(entry, ":method", "GET", 42);
-    assertHeaderReferenced(headerTableLength() - 1);
-
-    // Table size: 379
-    assertEquals(379, hpackReader.headerTableByteCount);
-
-    // Decoded header set:
-    // TODO: order is not correct per docs, but then again, the spec doesn't require ordering.
-    assertEquals(headerEntries(
-        ":method", "GET",
-        ":authority", "www.example.com",
-        ":scheme", "https",
-        ":path", "/index.html",
-        "custom-key", "custom-value"), hpackReader.getAndReset());
-  }
-
-  @Test public void readSingleByteInt() throws IOException {
-    assertEquals(10, newReader(byteStream()).readInt(10, 31));
-    assertEquals(10, newReader(byteStream()).readInt(0xe0 | 10, 31));
-  }
-
-  @Test public void readMultibyteInt() throws IOException {
-    assertEquals(1337, newReader(byteStream(154, 10)).readInt(31, 31));
-  }
-
-  @Test public void writeSingleByteInt() throws IOException {
-    hpackWriter.writeInt(10, 31, 0);
-    assertBytes(10);
-    hpackWriter.writeInt(10, 31, 0xe0);
-    assertBytes(0xe0 | 10);
-  }
-
-  @Test public void writeMultibyteInt() throws IOException {
-    hpackWriter.writeInt(1337, 31, 0);
-    assertBytes(31, 154, 10);
-    hpackWriter.writeInt(1337, 31, 0xe0);
-    assertBytes(0xe0 | 31, 154, 10);
-  }
-
-  @Test public void max31BitValue() throws IOException {
-    hpackWriter.writeInt(0x7fffffff, 31, 0);
-    assertBytes(31, 224, 255, 255, 255, 7);
-    assertEquals(0x7fffffff,
-        newReader(byteStream(224, 255, 255, 255, 7)).readInt(31, 31));
-  }
-
-  @Test public void prefixMask() throws IOException {
-    hpackWriter.writeInt(31, 31, 0);
-    assertBytes(31, 0);
-    assertEquals(31, newReader(byteStream(0)).readInt(31, 31));
-  }
-
-  @Test public void prefixMaskMinusOne() throws IOException {
-    hpackWriter.writeInt(30, 31, 0);
-    assertBytes(30);
-    assertEquals(31, newReader(byteStream(0)).readInt(31, 31));
-  }
-
-  @Test public void zero() throws IOException {
-    hpackWriter.writeInt(0, 31, 0);
-    assertBytes(0);
-    assertEquals(0, newReader(byteStream()).readInt(0, 31));
-  }
-
-  @Test public void headerName() throws IOException {
-    hpackWriter.writeByteString(ByteString.encodeUtf8("foo"));
-    assertBytes(3, 'f', 'o', 'o');
-    assertEquals("foo", newReader(byteStream(3, 'F', 'o', 'o')).readByteString(true).utf8());
-  }
-
-  @Test public void emptyHeaderName() throws IOException {
-    hpackWriter.writeByteString(ByteString.encodeUtf8(""));
-    assertBytes(0);
-    assertEquals(ByteString.EMPTY, newReader(byteStream(0)).readByteString(true));
-    assertEquals(ByteString.EMPTY, newReader(byteStream(0)).readByteString(false));
-  }
-
-  private HpackDraft05.Reader newReader(OkBuffer source) {
-    return new HpackDraft05.Reader(false, 4096, source);
-  }
-
-  private OkBuffer byteStream(int... bytes) {
-    return new OkBuffer().write(intArrayToByteArray(bytes));
-  }
-
-  private void checkEntry(Header entry, String name, String value, int size) {
-    assertEquals(name, entry.name.utf8());
-    assertEquals(value, entry.value.utf8());
-    assertEquals(size, entry.hpackSize);
-  }
-
-  private void assertBytes(int... bytes) {
-    ByteString expected = intArrayToByteArray(bytes);
-    ByteString actual = bytesOut.readByteString(bytesOut.size());
-    assertEquals(expected, actual);
-  }
-
-  private ByteString intArrayToByteArray(int[] bytes) {
-    byte[] data = new byte[bytes.length];
-    for (int i = 0; i < bytes.length; i++) {
-      data[i] = (byte) bytes[i];
-    }
-    return ByteString.of(data);
-  }
-
-  private void assertHeaderReferenced(int index) {
-    assertTrue(hpackReader.referencedHeaders.get(index));
-  }
-
-  private void assertHeaderNotReferenced(int index) {
-    assertFalse(hpackReader.referencedHeaders.get(index));
-  }
-
-  private int headerTableLength() {
-    return hpackReader.headerTable.length;
-  }
-}
diff --git a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/spdy/HpackDraft09Test.java b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/spdy/HpackDraft09Test.java
new file mode 100644
index 0000000000..2af2fef87c
--- /dev/null
+++ b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/spdy/HpackDraft09Test.java
@@ -0,0 +1,726 @@
+/*
+ * Copyright (C) 2013 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.okhttp.internal.spdy;
+
+import java.io.IOException;
+import java.util.Arrays;
+import java.util.List;
+import okio.Buffer;
+import okio.ByteString;
+import org.junit.Before;
+import org.junit.Test;
+
+import static com.squareup.okhttp.internal.Util.headerEntries;
+import static okio.ByteString.decodeHex;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.fail;
+
+public class HpackDraft09Test {
+
+  private final Buffer bytesIn = new Buffer();
+  private HpackDraft09.Reader hpackReader;
+  private Buffer bytesOut = new Buffer();
+  private HpackDraft09.Writer hpackWriter;
+
+  @Before public void reset() {
+    hpackReader = newReader(bytesIn);
+    hpackWriter = new HpackDraft09.Writer(bytesOut);
+  }
+
+  /**
+   * Variable-length quantity special cases strings which are longer than 127
+   * bytes.  Values such as cookies can be 4KiB, and should be possible to send.
+   *
+   * <p> http://tools.ietf.org/html/draft-ietf-httpbis-header-compression-09#section-6.1
+   */
+  @Test public void largeHeaderValue() throws IOException {
+    char[] value = new char[4096];
+    Arrays.fill(value, '!');
+    List<Header> headerBlock = headerEntries("cookie", new String(value));
+
+    hpackWriter.writeHeaders(headerBlock);
+    bytesIn.writeAll(bytesOut);
+    hpackReader.readHeaders();
+
+    assertEquals(0, hpackReader.headerCount);
+
+    assertEquals(headerBlock, hpackReader.getAndResetHeaderList());
+  }
+
+  /**
+   * HPACK has a max header table size, which can be smaller than the max header message.
+   * Ensure the larger header content is not lost.
+   */
+  @Test public void tooLargeToHPackIsStillEmitted() throws IOException {
+    bytesIn.writeByte(0x00); // Literal indexed
+    bytesIn.writeByte(0x0a); // Literal name (len = 10)
+    bytesIn.writeUtf8("custom-key");
+
+    bytesIn.writeByte(0x0d); // Literal value (len = 13)
+    bytesIn.writeUtf8("custom-header");
+
+    hpackReader.maxHeaderTableByteCountSetting(1);
+    hpackReader.readHeaders();
+
+    assertEquals(0, hpackReader.headerCount);
+
+    assertEquals(headerEntries("custom-key", "custom-header"), hpackReader.getAndResetHeaderList());
+  }
+
+  /** Oldest entries are evicted to support newer ones. */
+  @Test public void testEviction() throws IOException {
+    bytesIn.writeByte(0x40); // Literal indexed
+    bytesIn.writeByte(0x0a); // Literal name (len = 10)
+    bytesIn.writeUtf8("custom-foo");
+
+    bytesIn.writeByte(0x0d); // Literal value (len = 13)
+    bytesIn.writeUtf8("custom-header");
+
+    bytesIn.writeByte(0x40); // Literal indexed
+    bytesIn.writeByte(0x0a); // Literal name (len = 10)
+    bytesIn.writeUtf8("custom-bar");
+
+    bytesIn.writeByte(0x0d); // Literal value (len = 13)
+    bytesIn.writeUtf8("custom-header");
+
+    bytesIn.writeByte(0x40); // Literal indexed
+    bytesIn.writeByte(0x0a); // Literal name (len = 10)
+    bytesIn.writeUtf8("custom-baz");
+
+    bytesIn.writeByte(0x0d); // Literal value (len = 13)
+    bytesIn.writeUtf8("custom-header");
+
+    // Set to only support 110 bytes (enough for 2 headers).
+    hpackReader.maxHeaderTableByteCountSetting(110);
+    hpackReader.readHeaders();
+
+    assertEquals(2, hpackReader.headerCount);
+
+    Header entry = hpackReader.headerTable[headerTableLength() - 1];
+    checkEntry(entry, "custom-bar", "custom-header", 55);
+
+    entry = hpackReader.headerTable[headerTableLength() - 2];
+    checkEntry(entry, "custom-baz", "custom-header", 55);
+
+    // Once a header field is decoded and added to the reconstructed header
+    // list, it cannot be removed from it. Hence, foo is here.
+    assertEquals(
+        headerEntries(
+            "custom-foo", "custom-header",
+            "custom-bar", "custom-header",
+            "custom-baz", "custom-header"),
+        hpackReader.getAndResetHeaderList());
+
+    // Simulate receiving a small settings frame, that implies eviction.
+    hpackReader.maxHeaderTableByteCountSetting(55);
+    assertEquals(1, hpackReader.headerCount);
+  }
+
+  /** Header table backing array is initially 8 long, let's ensure it grows. */
+  @Test public void dynamicallyGrowsBeyond64Entries() throws IOException {
+    for (int i = 0; i < 256; i++) {
+      bytesIn.writeByte(0x40); // Literal indexed
+      bytesIn.writeByte(0x0a); // Literal name (len = 10)
+      bytesIn.writeUtf8("custom-foo");
+
+      bytesIn.writeByte(0x0d); // Literal value (len = 13)
+      bytesIn.writeUtf8("custom-header");
+    }
+
+    hpackReader.maxHeaderTableByteCountSetting(16384); // Lots of headers need more room!
+    hpackReader.readHeaders();
+
+    assertEquals(256, hpackReader.headerCount);
+  }
+
+  @Test public void huffmanDecodingSupported() throws IOException {
+    bytesIn.writeByte(0x44); // == Literal indexed ==
+                             // Indexed name (idx = 4) -> :path
+    bytesIn.writeByte(0x8c); // Literal value Huffman encoded 12 bytes
+                             // decodes to www.example.com which is length 15
+    bytesIn.write(decodeHex("f1e3c2e5f23a6ba0ab90f4ff"));
+
+    hpackReader.readHeaders();
+
+    assertEquals(1, hpackReader.headerCount);
+    assertEquals(52, hpackReader.headerTableByteCount);
+
+    Header entry = hpackReader.headerTable[headerTableLength() - 1];
+    checkEntry(entry, ":path", "www.example.com", 52);
+  }
+
+  /**
+   * http://tools.ietf.org/html/draft-ietf-httpbis-header-compression-09#appendix-D.2.1
+   */
+  @Test public void readLiteralHeaderFieldWithIndexing() throws IOException {
+    bytesIn.writeByte(0x40); // Literal indexed
+    bytesIn.writeByte(0x0a); // Literal name (len = 10)
+    bytesIn.writeUtf8("custom-key");
+
+    bytesIn.writeByte(0x0d); // Literal value (len = 13)
+    bytesIn.writeUtf8("custom-header");
+
+    hpackReader.readHeaders();
+
+    assertEquals(1, hpackReader.headerCount);
+    assertEquals(55, hpackReader.headerTableByteCount);
+
+    Header entry = hpackReader.headerTable[headerTableLength() - 1];
+    checkEntry(entry, "custom-key", "custom-header", 55);
+
+    assertEquals(headerEntries("custom-key", "custom-header"), hpackReader.getAndResetHeaderList());
+  }
+
+  /**
+   * https://tools.ietf.org/html/draft-ietf-httpbis-header-compression-09#appendix-D.2.2
+   */
+  @Test public void literalHeaderFieldWithoutIndexingIndexedName() throws IOException {
+    List<Header> headerBlock = headerEntries(":path", "/sample/path");
+
+    bytesIn.writeByte(0x04); // == Literal not indexed ==
+                             // Indexed name (idx = 4) -> :path
+    bytesIn.writeByte(0x0c); // Literal value (len = 12)
+    bytesIn.writeUtf8("/sample/path");
+
+    hpackWriter.writeHeaders(headerBlock);
+    assertEquals(bytesIn, bytesOut);
+
+    hpackReader.readHeaders();
+
+    assertEquals(0, hpackReader.headerCount);
+
+    assertEquals(headerBlock, hpackReader.getAndResetHeaderList());
+  }
+
+  @Test public void literalHeaderFieldWithoutIndexingNewName() throws IOException {
+    List<Header> headerBlock = headerEntries("custom-key", "custom-header");
+
+    bytesIn.writeByte(0x00); // Not indexed
+    bytesIn.writeByte(0x0a); // Literal name (len = 10)
+    bytesIn.writeUtf8("custom-key");
+
+    bytesIn.writeByte(0x0d); // Literal value (len = 13)
+    bytesIn.writeUtf8("custom-header");
+
+    hpackWriter.writeHeaders(headerBlock);
+    assertEquals(bytesIn, bytesOut);
+
+    hpackReader.readHeaders();
+
+    assertEquals(0, hpackReader.headerCount);
+
+    assertEquals(headerBlock, hpackReader.getAndResetHeaderList());
+  }
+
+  @Test public void literalHeaderFieldNeverIndexedIndexedName() throws IOException {
+    bytesIn.writeByte(0x14); // == Literal never indexed ==
+                             // Indexed name (idx = 4) -> :path
+    bytesIn.writeByte(0x0c); // Literal value (len = 12)
+    bytesIn.writeUtf8("/sample/path");
+
+    hpackReader.readHeaders();
+
+    assertEquals(0, hpackReader.headerCount);
+
+    assertEquals(headerEntries(":path", "/sample/path"), hpackReader.getAndResetHeaderList());
+  }
+
+  @Test public void literalHeaderFieldNeverIndexedNewName() throws IOException {
+    bytesIn.writeByte(0x10); // Never indexed
+    bytesIn.writeByte(0x0a); // Literal name (len = 10)
+    bytesIn.writeUtf8("custom-key");
+
+    bytesIn.writeByte(0x0d); // Literal value (len = 13)
+    bytesIn.writeUtf8("custom-header");
+
+    hpackReader.readHeaders();
+
+    assertEquals(0, hpackReader.headerCount);
+
+    assertEquals(headerEntries("custom-key", "custom-header"), hpackReader.getAndResetHeaderList());
+  }
+
+  @Test public void staticHeaderIsNotCopiedIntoTheIndexedTable() throws IOException {
+    bytesIn.writeByte(0x82); // == Indexed - Add ==
+                             // idx = 2 -> :method: GET
+
+    hpackReader.readHeaders();
+
+    assertEquals(0, hpackReader.headerCount);
+    assertEquals(0, hpackReader.headerTableByteCount);
+
+    assertEquals(null, hpackReader.headerTable[headerTableLength() - 1]);
+
+    assertEquals(headerEntries(":method", "GET"), hpackReader.getAndResetHeaderList());
+  }
+
+  // Example taken from twitter/hpack DecoderTest.testUnusedIndex
+  @Test public void readIndexedHeaderFieldIndex0() throws IOException {
+    bytesIn.writeByte(0x80); // == Indexed - Add idx = 0
+
+    try {
+      hpackReader.readHeaders();
+      fail();
+    } catch (IOException e) {
+      assertEquals("index == 0", e.getMessage());
+    }
+  }
+
+  // Example taken from twitter/hpack DecoderTest.testIllegalIndex
+  @Test public void readIndexedHeaderFieldTooLargeIndex() throws IOException {
+    bytesIn.writeShort(0xff00); // == Indexed - Add idx = 127
+
+    try {
+      hpackReader.readHeaders();
+      fail();
+    } catch (IOException e) {
+      assertEquals("Header index too large 127", e.getMessage());
+    }
+  }
+
+  // Example taken from twitter/hpack DecoderTest.testInsidiousIndex
+  @Test public void readIndexedHeaderFieldInsidiousIndex() throws IOException {
+    bytesIn.writeByte(0xff); // == Indexed - Add ==
+    bytesIn.write(decodeHex("8080808008")); // idx = -2147483521
+
+    try {
+      hpackReader.readHeaders();
+      fail();
+    } catch (IOException e) {
+      assertEquals("Header index too large -2147483521", e.getMessage());
+    }
+  }
+
+  // Example taken from twitter/hpack DecoderTest.testHeaderTableSizeUpdate
+  @Test public void minMaxHeaderTableSize() throws IOException {
+    bytesIn.writeByte(0x20);
+    hpackReader.readHeaders();
+
+    assertEquals(0, hpackReader.maxHeaderTableByteCount());
+
+    bytesIn.writeByte(0x3f); // encode size 4096
+    bytesIn.writeByte(0xe1);
+    bytesIn.writeByte(0x1f);
+    hpackReader.readHeaders();
+
+    assertEquals(4096, hpackReader.maxHeaderTableByteCount());
+  }
+
+  // Example taken from twitter/hpack DecoderTest.testIllegalHeaderTableSizeUpdate
+  @Test public void cannotSetTableSizeLargerThanSettingsValue() throws IOException {
+    bytesIn.writeByte(0x3f); // encode size 4097
+    bytesIn.writeByte(0xe2);
+    bytesIn.writeByte(0x1f);
+
+    try {
+      hpackReader.readHeaders();
+      fail();
+    } catch (IOException e) {
+      assertEquals("Invalid header table byte count 4097", e.getMessage());
+    }
+  }
+
+  // Example taken from twitter/hpack DecoderTest.testInsidiousMaxHeaderSize
+  @Test public void readHeaderTableStateChangeInsidiousMaxHeaderByteCount() throws IOException {
+    bytesIn.writeByte(0x3f);
+    bytesIn.write(decodeHex("e1ffffff07")); // count = -2147483648
+
+    try {
+      hpackReader.readHeaders();
+      fail();
+    } catch (IOException e) {
+      assertEquals("Invalid header table byte count -2147483648", e.getMessage());
+    }
+  }
+
+  /**
+   * https://tools.ietf.org/html/draft-ietf-httpbis-header-compression-09#appendix-D.2.4
+   */
+  @Test public void readIndexedHeaderFieldFromStaticTableWithoutBuffering() throws IOException {
+    bytesIn.writeByte(0x82); // == Indexed - Add ==
+                             // idx = 2 -> :method: GET
+
+    hpackReader.maxHeaderTableByteCountSetting(0); // SETTINGS_HEADER_TABLE_SIZE == 0
+    hpackReader.readHeaders();
+
+    // Not buffered in header table.
+    assertEquals(0, hpackReader.headerCount);
+
+    assertEquals(headerEntries(":method", "GET"), hpackReader.getAndResetHeaderList());
+  }
+
+  /**
+   * http://tools.ietf.org/html/draft-ietf-httpbis-header-compression-09#appendix-D.2
+   */
+  @Test public void readRequestExamplesWithoutHuffman() throws IOException {
+    firstRequestWithoutHuffman();
+    hpackReader.readHeaders();
+    checkReadFirstRequestWithoutHuffman();
+
+    secondRequestWithoutHuffman();
+    hpackReader.readHeaders();
+    checkReadSecondRequestWithoutHuffman();
+
+    thirdRequestWithoutHuffman();
+    hpackReader.readHeaders();
+    checkReadThirdRequestWithoutHuffman();
+  }
+
+  private void firstRequestWithoutHuffman() {
+    bytesIn.writeByte(0x82); // == Indexed - Add ==
+                             // idx = 2 -> :method: GET
+    bytesIn.writeByte(0x86); // == Indexed - Add ==
+                             // idx = 7 -> :scheme: http
+    bytesIn.writeByte(0x84); // == Indexed - Add ==
+                             // idx = 6 -> :path: /
+    bytesIn.writeByte(0x41); // == Literal indexed ==
+                             // Indexed name (idx = 4) -> :authority
+    bytesIn.writeByte(0x0f); // Literal value (len = 15)
+    bytesIn.writeUtf8("www.example.com");
+  }
+
+  private void checkReadFirstRequestWithoutHuffman() {
+    assertEquals(1, hpackReader.headerCount);
+
+    // [  1] (s =  57) :authority: www.example.com
+    Header entry = hpackReader.headerTable[headerTableLength() - 1];
+    checkEntry(entry, ":authority", "www.example.com", 57);
+
+    // Table size: 57
+    assertEquals(57, hpackReader.headerTableByteCount);
+
+    // Decoded header list:
+    assertEquals(headerEntries(
+        ":method", "GET",
+        ":scheme", "http",
+        ":path", "/",
+        ":authority", "www.example.com"), hpackReader.getAndResetHeaderList());
+  }
+
+  private void secondRequestWithoutHuffman() {
+    bytesIn.writeByte(0x82); // == Indexed - Add ==
+                             // idx = 2 -> :method: GET
+    bytesIn.writeByte(0x86); // == Indexed - Add ==
+                             // idx = 7 -> :scheme: http
+    bytesIn.writeByte(0x84); // == Indexed - Add ==
+                             // idx = 6 -> :path: /
+    bytesIn.writeByte(0xbe); // == Indexed - Add ==
+                             // Indexed name (idx = 62) -> :authority: www.example.com
+    bytesIn.writeByte(0x58); // == Literal indexed ==
+                             // Indexed name (idx = 24) -> cache-control
+    bytesIn.writeByte(0x08); // Literal value (len = 8)
+    bytesIn.writeUtf8("no-cache");
+  }
+
+  private void checkReadSecondRequestWithoutHuffman() {
+    assertEquals(2, hpackReader.headerCount);
+
+    // [  1] (s =  53) cache-control: no-cache
+    Header entry = hpackReader.headerTable[headerTableLength() - 2];
+    checkEntry(entry, "cache-control", "no-cache", 53);
+
+    // [  2] (s =  57) :authority: www.example.com
+    entry = hpackReader.headerTable[headerTableLength() - 1];
+    checkEntry(entry, ":authority", "www.example.com", 57);
+
+    // Table size: 110
+    assertEquals(110, hpackReader.headerTableByteCount);
+
+    // Decoded header list:
+    assertEquals(headerEntries(
+        ":method", "GET",
+        ":scheme", "http",
+        ":path", "/",
+        ":authority", "www.example.com",
+        "cache-control", "no-cache"), hpackReader.getAndResetHeaderList());
+  }
+
+  private void thirdRequestWithoutHuffman() {
+    bytesIn.writeByte(0x82); // == Indexed - Add ==
+                             // idx = 2 -> :method: GET
+    bytesIn.writeByte(0x87); // == Indexed - Add ==
+                             // idx = 7 -> :scheme: http
+    bytesIn.writeByte(0x85); // == Indexed - Add ==
+                             // idx = 5 -> :path: /index.html
+    bytesIn.writeByte(0xbf); // == Indexed - Add ==
+                             // Indexed name (idx = 63) -> :authority: www.example.com
+    bytesIn.writeByte(0x40); // Literal indexed
+    bytesIn.writeByte(0x0a); // Literal name (len = 10)
+    bytesIn.writeUtf8("custom-key");
+    bytesIn.writeByte(0x0c); // Literal value (len = 12)
+    bytesIn.writeUtf8("custom-value");
+  }
+
+  private void checkReadThirdRequestWithoutHuffman() {
+    assertEquals(3, hpackReader.headerCount);
+
+    // [  1] (s =  54) custom-key: custom-value
+    Header entry = hpackReader.headerTable[headerTableLength() - 3];
+    checkEntry(entry, "custom-key", "custom-value", 54);
+
+    // [  2] (s =  53) cache-control: no-cache
+    entry = hpackReader.headerTable[headerTableLength() - 2];
+    checkEntry(entry, "cache-control", "no-cache", 53);
+
+    // [  3] (s =  57) :authority: www.example.com
+    entry = hpackReader.headerTable[headerTableLength() - 1];
+    checkEntry(entry, ":authority", "www.example.com", 57);
+
+    // Table size: 164
+    assertEquals(164, hpackReader.headerTableByteCount);
+
+    // Decoded header list:
+    assertEquals(headerEntries(
+        ":method", "GET",
+        ":scheme", "https",
+        ":path", "/index.html",
+        ":authority", "www.example.com",
+        "custom-key", "custom-value"), hpackReader.getAndResetHeaderList());
+  }
+
+  /**
+   * http://tools.ietf.org/html/draft-ietf-httpbis-header-compression-09#appendix-D.4
+   */
+  @Test public void readRequestExamplesWithHuffman() throws IOException {
+    firstRequestWithHuffman();
+    hpackReader.readHeaders();
+    checkReadFirstRequestWithHuffman();
+
+    secondRequestWithHuffman();
+    hpackReader.readHeaders();
+    checkReadSecondRequestWithHuffman();
+
+    thirdRequestWithHuffman();
+    hpackReader.readHeaders();
+    checkReadThirdRequestWithHuffman();
+  }
+
+  private void firstRequestWithHuffman() {
+    bytesIn.writeByte(0x82); // == Indexed - Add ==
+                             // idx = 2 -> :method: GET
+    bytesIn.writeByte(0x86); // == Indexed - Add ==
+                             // idx = 6 -> :scheme: http
+    bytesIn.writeByte(0x84); // == Indexed - Add ==
+                             // idx = 4 -> :path: /
+    bytesIn.writeByte(0x41); // == Literal indexed ==
+                             // Indexed name (idx = 1) -> :authority
+    bytesIn.writeByte(0x8c); // Literal value Huffman encoded 12 bytes
+                             // decodes to www.example.com which is length 15
+    bytesIn.write(decodeHex("f1e3c2e5f23a6ba0ab90f4ff"));
+  }
+
+  private void checkReadFirstRequestWithHuffman() {
+    assertEquals(1, hpackReader.headerCount);
+
+    // [  1] (s =  57) :authority: www.example.com
+    Header entry = hpackReader.headerTable[headerTableLength() - 1];
+    checkEntry(entry, ":authority", "www.example.com", 57);
+
+    // Table size: 57
+    assertEquals(57, hpackReader.headerTableByteCount);
+
+    // Decoded header list:
+    assertEquals(headerEntries(
+        ":method", "GET",
+        ":scheme", "http",
+        ":path", "/",
+        ":authority", "www.example.com"), hpackReader.getAndResetHeaderList());
+  }
+
+  private void secondRequestWithHuffman() {
+    bytesIn.writeByte(0x82); // == Indexed - Add ==
+                             // idx = 2 -> :method: GET
+    bytesIn.writeByte(0x86); // == Indexed - Add ==
+                             // idx = 6 -> :scheme: http
+    bytesIn.writeByte(0x84); // == Indexed - Add ==
+                             // idx = 4 -> :path: /
+    bytesIn.writeByte(0xbe); // == Indexed - Add ==
+                             // idx = 62 -> :authority: www.example.com
+    bytesIn.writeByte(0x58); // == Literal indexed ==
+                             // Indexed name (idx = 24) -> cache-control
+    bytesIn.writeByte(0x86); // Literal value Huffman encoded 6 bytes
+                             // decodes to no-cache which is length 8
+    bytesIn.write(decodeHex("a8eb10649cbf"));
+  }
+
+  private void checkReadSecondRequestWithHuffman() {
+    assertEquals(2, hpackReader.headerCount);
+
+    // [  1] (s =  53) cache-control: no-cache
+    Header entry = hpackReader.headerTable[headerTableLength() - 2];
+    checkEntry(entry, "cache-control", "no-cache", 53);
+
+    // [  2] (s =  57) :authority: www.example.com
+    entry = hpackReader.headerTable[headerTableLength() - 1];
+    checkEntry(entry, ":authority", "www.example.com", 57);
+
+    // Table size: 110
+    assertEquals(110, hpackReader.headerTableByteCount);
+
+    // Decoded header list:
+    assertEquals(headerEntries(
+        ":method", "GET",
+        ":scheme", "http",
+        ":path", "/",
+        ":authority", "www.example.com",
+        "cache-control", "no-cache"), hpackReader.getAndResetHeaderList());
+  }
+
+  private void thirdRequestWithHuffman() {
+    bytesIn.writeByte(0x82); // == Indexed - Add ==
+                             // idx = 2 -> :method: GET
+    bytesIn.writeByte(0x87); // == Indexed - Add ==
+                             // idx = 7 -> :scheme: https
+    bytesIn.writeByte(0x85); // == Indexed - Add ==
+                             // idx = 5 -> :path: /index.html
+    bytesIn.writeByte(0xbf); // == Indexed - Add ==
+                             // idx = 63 -> :authority: www.example.com
+    bytesIn.writeByte(0x40); // Literal indexed
+    bytesIn.writeByte(0x88); // Literal name Huffman encoded 8 bytes
+                             // decodes to custom-key which is length 10
+    bytesIn.write(decodeHex("25a849e95ba97d7f"));
+    bytesIn.writeByte(0x89); // Literal value Huffman encoded 9 bytes
+                             // decodes to custom-value which is length 12
+    bytesIn.write(decodeHex("25a849e95bb8e8b4bf"));
+  }
+
+  private void checkReadThirdRequestWithHuffman() {
+    assertEquals(3, hpackReader.headerCount);
+
+    // [  1] (s =  54) custom-key: custom-value
+    Header entry = hpackReader.headerTable[headerTableLength() - 3];
+    checkEntry(entry, "custom-key", "custom-value", 54);
+
+    // [  2] (s =  53) cache-control: no-cache
+    entry = hpackReader.headerTable[headerTableLength() - 2];
+    checkEntry(entry, "cache-control", "no-cache", 53);
+
+    // [  3] (s =  57) :authority: www.example.com
+    entry = hpackReader.headerTable[headerTableLength() - 1];
+    checkEntry(entry, ":authority", "www.example.com", 57);
+
+    // Table size: 164
+    assertEquals(164, hpackReader.headerTableByteCount);
+
+    // Decoded header list:
+    assertEquals(headerEntries(
+        ":method", "GET",
+        ":scheme", "https",
+        ":path", "/index.html",
+        ":authority", "www.example.com",
+        "custom-key", "custom-value"), hpackReader.getAndResetHeaderList());
+  }
+
+  @Test public void readSingleByteInt() throws IOException {
+    assertEquals(10, newReader(byteStream()).readInt(10, 31));
+    assertEquals(10, newReader(byteStream()).readInt(0xe0 | 10, 31));
+  }
+
+  @Test public void readMultibyteInt() throws IOException {
+    assertEquals(1337, newReader(byteStream(154, 10)).readInt(31, 31));
+  }
+
+  @Test public void writeSingleByteInt() throws IOException {
+    hpackWriter.writeInt(10, 31, 0);
+    assertBytes(10);
+    hpackWriter.writeInt(10, 31, 0xe0);
+    assertBytes(0xe0 | 10);
+  }
+
+  @Test public void writeMultibyteInt() throws IOException {
+    hpackWriter.writeInt(1337, 31, 0);
+    assertBytes(31, 154, 10);
+    hpackWriter.writeInt(1337, 31, 0xe0);
+    assertBytes(0xe0 | 31, 154, 10);
+  }
+
+  @Test public void max31BitValue() throws IOException {
+    hpackWriter.writeInt(0x7fffffff, 31, 0);
+    assertBytes(31, 224, 255, 255, 255, 7);
+    assertEquals(0x7fffffff,
+        newReader(byteStream(224, 255, 255, 255, 7)).readInt(31, 31));
+  }
+
+  @Test public void prefixMask() throws IOException {
+    hpackWriter.writeInt(31, 31, 0);
+    assertBytes(31, 0);
+    assertEquals(31, newReader(byteStream(0)).readInt(31, 31));
+  }
+
+  @Test public void prefixMaskMinusOne() throws IOException {
+    hpackWriter.writeInt(30, 31, 0);
+    assertBytes(30);
+    assertEquals(31, newReader(byteStream(0)).readInt(31, 31));
+  }
+
+  @Test public void zero() throws IOException {
+    hpackWriter.writeInt(0, 31, 0);
+    assertBytes(0);
+    assertEquals(0, newReader(byteStream()).readInt(0, 31));
+  }
+
+  @Test public void lowercaseHeaderNameBeforeEmit() throws IOException {
+    hpackWriter.writeHeaders(Arrays.asList(new Header("FoO", "BaR")));
+    assertBytes(0, 3, 'f', 'o', 'o', 3, 'B', 'a', 'R');
+  }
+
+  @Test public void mixedCaseHeaderNameIsMalformed() throws IOException {
+    try {
+      newReader(byteStream(0, 3, 'F', 'o', 'o', 3, 'B', 'a', 'R')).readHeaders();
+      fail();
+    } catch (IOException e) {
+      assertEquals("PROTOCOL_ERROR response malformed: mixed case name: Foo", e.getMessage());
+    }
+  }
+
+  @Test public void emptyHeaderName() throws IOException {
+    hpackWriter.writeByteString(ByteString.encodeUtf8(""));
+    assertBytes(0);
+    assertEquals(ByteString.EMPTY, newReader(byteStream(0)).readByteString());
+  }
+
+  private HpackDraft09.Reader newReader(Buffer source) {
+    return new HpackDraft09.Reader(4096, source);
+  }
+
+  private Buffer byteStream(int... bytes) {
+    return new Buffer().write(intArrayToByteArray(bytes));
+  }
+
+  private void checkEntry(Header entry, String name, String value, int size) {
+    assertEquals(name, entry.name.utf8());
+    assertEquals(value, entry.value.utf8());
+    assertEquals(size, entry.hpackSize);
+  }
+
+  private void assertBytes(int... bytes) throws IOException {
+    ByteString expected = intArrayToByteArray(bytes);
+    ByteString actual = bytesOut.readByteString();
+    assertEquals(expected, actual);
+  }
+
+  private ByteString intArrayToByteArray(int[] bytes) {
+    byte[] data = new byte[bytes.length];
+    for (int i = 0; i < bytes.length; i++) {
+      data[i] = (byte) bytes[i];
+    }
+    return ByteString.of(data);
+  }
+
+  private int headerTableLength() {
+    return hpackReader.headerTable.length;
+  }
+}
diff --git a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/spdy/Http20Draft09Test.java b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/spdy/Http20Draft09Test.java
deleted file mode 100644
index 248ea094c5..0000000000
--- a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/spdy/Http20Draft09Test.java
+++ /dev/null
@@ -1,515 +0,0 @@
-/*
- * Copyright (C) 2013 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.squareup.okhttp.internal.spdy;
-
-import com.squareup.okhttp.internal.Util;
-import java.io.IOException;
-import java.util.Arrays;
-import java.util.List;
-import okio.BufferedSource;
-import okio.ByteString;
-import okio.OkBuffer;
-import org.junit.Test;
-
-import static com.squareup.okhttp.internal.Util.headerEntries;
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertFalse;
-import static org.junit.Assert.assertTrue;
-import static org.junit.Assert.fail;
-
-public class Http20Draft09Test {
-  static final int expectedStreamId = 15;
-
-  @Test public void unknownFrameTypeIgnored() throws IOException {
-    OkBuffer frame = new OkBuffer();
-
-    frame.writeShort(4); // has a 4-byte field
-    frame.writeByte(99); // type 99
-    frame.writeByte(0); // no flags
-    frame.writeInt(expectedStreamId);
-    frame.writeInt(111111111); // custom data
-
-    FrameReader fr = new Http20Draft09.Reader(frame, 4096, false);
-
-    // Consume the unknown frame.
-    fr.nextFrame(new BaseTestHandler());
-  }
-
-  @Test public void onlyOneLiteralHeadersFrame() throws IOException {
-    final List<Header> sentHeaders = headerEntries("name", "value");
-
-    OkBuffer frame = new OkBuffer();
-
-    // Write the headers frame, specifying no more frames are expected.
-    {
-      OkBuffer headerBytes = literalHeaders(sentHeaders);
-      frame.writeShort((int) headerBytes.size());
-      frame.writeByte(Http20Draft09.TYPE_HEADERS);
-      frame.writeByte(Http20Draft09.FLAG_END_HEADERS | Http20Draft09.FLAG_END_STREAM);
-      frame.writeInt(expectedStreamId & 0x7fffffff);
-      frame.write(headerBytes, headerBytes.size());
-    }
-
-    FrameReader fr = new Http20Draft09.Reader(frame, 4096, false);
-
-    // Consume the headers frame.
-    fr.nextFrame(new BaseTestHandler() {
-
-      @Override
-      public void headers(boolean outFinished, boolean inFinished, int streamId,
-          int associatedStreamId, int priority, List<Header> headerBlock,
-          HeadersMode headersMode) {
-        assertFalse(outFinished);
-        assertTrue(inFinished);
-        assertEquals(expectedStreamId, streamId);
-        assertEquals(-1, associatedStreamId);
-        assertEquals(-1, priority);
-        assertEquals(sentHeaders, headerBlock);
-        assertEquals(HeadersMode.HTTP_20_HEADERS, headersMode);
-      }
-    });
-  }
-
-  @Test public void headersWithPriority() throws IOException {
-    OkBuffer frame = new OkBuffer();
-
-    final List<Header> sentHeaders = headerEntries("name", "value");
-
-    { // Write the headers frame, specifying priority flag and value.
-      OkBuffer headerBytes = literalHeaders(sentHeaders);
-      frame.writeShort((int) (headerBytes.size() + 4));
-      frame.writeByte(Http20Draft09.TYPE_HEADERS);
-      frame.writeByte(Http20Draft09.FLAG_END_HEADERS | Http20Draft09.FLAG_PRIORITY);
-      frame.writeInt(expectedStreamId & 0x7fffffff);
-      frame.writeInt(0); // Highest priority is 0.
-      frame.write(headerBytes, headerBytes.size());
-    }
-
-    FrameReader fr = new Http20Draft09.Reader(frame, 4096, false);
-
-    // Consume the headers frame.
-    fr.nextFrame(new BaseTestHandler() {
-
-      @Override
-      public void headers(boolean outFinished, boolean inFinished, int streamId,
-          int associatedStreamId, int priority, List<Header> nameValueBlock,
-          HeadersMode headersMode) {
-        assertFalse(outFinished);
-        assertFalse(inFinished);
-        assertEquals(expectedStreamId, streamId);
-        assertEquals(-1, associatedStreamId);
-        assertEquals(0, priority);
-        assertEquals(sentHeaders, nameValueBlock);
-        assertEquals(HeadersMode.HTTP_20_HEADERS, headersMode);
-      }
-    });
-  }
-
-  /** Headers are compressed, then framed. */
-  @Test public void headersFrameThenContinuation() throws IOException {
-
-    OkBuffer frame = new OkBuffer();
-
-    // Decoding the first header will cross frame boundaries.
-    OkBuffer headerBlock = literalHeaders(headerEntries("foo", "barrr", "baz", "qux"));
-    { // Write the first headers frame.
-      frame.writeShort((int) (headerBlock.size() / 2));
-      frame.writeByte(Http20Draft09.TYPE_HEADERS);
-      frame.writeByte(0); // no flags
-      frame.writeInt(expectedStreamId & 0x7fffffff);
-      frame.write(headerBlock, headerBlock.size() / 2);
-    }
-
-    { // Write the continuation frame, specifying no more frames are expected.
-      frame.writeShort((int) headerBlock.size());
-      frame.writeByte(Http20Draft09.TYPE_CONTINUATION);
-      frame.writeByte(Http20Draft09.FLAG_END_HEADERS);
-      frame.writeInt(expectedStreamId & 0x7fffffff);
-      frame.write(headerBlock, headerBlock.size());
-    }
-
-    FrameReader fr = new Http20Draft09.Reader(frame, 4096, false);
-
-    // Reading the above frames should result in a concatenated headerBlock.
-    fr.nextFrame(new BaseTestHandler() {
-
-      @Override
-      public void headers(boolean outFinished, boolean inFinished, int streamId,
-          int associatedStreamId, int priority, List<Header> headerBlock,
-          HeadersMode headersMode) {
-        assertFalse(outFinished);
-        assertFalse(inFinished);
-        assertEquals(expectedStreamId, streamId);
-        assertEquals(-1, associatedStreamId);
-        assertEquals(-1, priority);
-        assertEquals(headerEntries("foo", "barrr", "baz", "qux"), headerBlock);
-        assertEquals(HeadersMode.HTTP_20_HEADERS, headersMode);
-      }
-    });
-  }
-
-  @Test public void pushPromise() throws IOException {
-    OkBuffer frame = new OkBuffer();
-
-    final int expectedPromisedStreamId = 11;
-
-    final List<Header> pushPromise = Arrays.asList(
-        new Header(Header.TARGET_METHOD, "GET"),
-        new Header(Header.TARGET_SCHEME, "https"),
-        new Header(Header.TARGET_AUTHORITY, "squareup.com"),
-        new Header(Header.TARGET_PATH, "/")
-    );
-
-    { // Write the push promise frame, specifying the associated stream ID.
-      OkBuffer headerBytes = literalHeaders(pushPromise);
-      frame.writeShort((int) (headerBytes.size() + 4));
-      frame.writeByte(Http20Draft09.TYPE_PUSH_PROMISE);
-      frame.writeByte(Http20Draft09.FLAG_END_PUSH_PROMISE);
-      frame.writeInt(expectedStreamId & 0x7fffffff);
-      frame.writeInt(expectedPromisedStreamId & 0x7fffffff);
-      frame.write(headerBytes, headerBytes.size());
-    }
-
-    FrameReader fr = new Http20Draft09.Reader(frame, 4096, false);
-
-    // Consume the headers frame.
-    fr.nextFrame(new BaseTestHandler() {
-      @Override
-      public void pushPromise(int streamId, int promisedStreamId, List<Header> headerBlock) {
-        assertEquals(expectedStreamId, streamId);
-        assertEquals(expectedPromisedStreamId, promisedStreamId);
-        assertEquals(pushPromise, headerBlock);
-      }
-    });
-  }
-
-  /** Headers are compressed, then framed. */
-  @Test public void pushPromiseThenContinuation() throws IOException {
-    OkBuffer frame = new OkBuffer();
-
-    final int expectedPromisedStreamId = 11;
-
-    final List<Header> pushPromise = Arrays.asList(
-        new Header(Header.TARGET_METHOD, "GET"),
-        new Header(Header.TARGET_SCHEME, "https"),
-        new Header(Header.TARGET_AUTHORITY, "squareup.com"),
-        new Header(Header.TARGET_PATH, "/")
-    );
-
-    // Decoding the first header will cross frame boundaries.
-    OkBuffer headerBlock = literalHeaders(pushPromise);
-    int firstFrameLength = (int) (headerBlock.size() - 1);
-    { // Write the first headers frame.
-      frame.writeShort(firstFrameLength + 4);
-      frame.writeByte(Http20Draft09.TYPE_PUSH_PROMISE);
-      frame.writeByte(0); // no flags
-      frame.writeInt(expectedStreamId & 0x7fffffff);
-      frame.writeInt(expectedPromisedStreamId & 0x7fffffff);
-      frame.write(headerBlock, firstFrameLength);
-    }
-
-    { // Write the continuation frame, specifying no more frames are expected.
-      frame.writeShort(1);
-      frame.writeByte(Http20Draft09.TYPE_CONTINUATION);
-      frame.writeByte(Http20Draft09.FLAG_END_HEADERS);
-      frame.writeInt(expectedStreamId & 0x7fffffff);
-      frame.write(headerBlock, 1);
-    }
-
-    FrameReader fr = new Http20Draft09.Reader(frame, 4096, false);
-
-    // Reading the above frames should result in a concatenated headerBlock.
-    fr.nextFrame(new BaseTestHandler() {
-      @Override
-      public void pushPromise(int streamId, int promisedStreamId, List<Header> headerBlock) {
-        assertEquals(expectedStreamId, streamId);
-        assertEquals(expectedPromisedStreamId, promisedStreamId);
-        assertEquals(pushPromise, headerBlock);
-      }
-    });
-  }
-
-  @Test public void readRstStreamFrame() throws IOException {
-    OkBuffer frame = new OkBuffer();
-
-    frame.writeShort(4);
-    frame.writeByte(Http20Draft09.TYPE_RST_STREAM);
-    frame.writeByte(0); // No flags
-    frame.writeInt(expectedStreamId & 0x7fffffff);
-    frame.writeInt(ErrorCode.COMPRESSION_ERROR.httpCode);
-
-    FrameReader fr = new Http20Draft09.Reader(frame, 4096, false);
-
-    // Consume the reset frame.
-    fr.nextFrame(new BaseTestHandler() {
-      @Override public void rstStream(int streamId, ErrorCode errorCode) {
-        assertEquals(expectedStreamId, streamId);
-        assertEquals(ErrorCode.COMPRESSION_ERROR, errorCode);
-      }
-    });
-  }
-
-  @Test public void readSettingsFrame() throws IOException {
-    OkBuffer frame = new OkBuffer();
-
-    final int reducedTableSizeBytes = 16;
-
-    frame.writeShort(16); // 2 settings * 4 bytes for the code and 4 for the value.
-    frame.writeByte(Http20Draft09.TYPE_SETTINGS);
-    frame.writeByte(0); // No flags
-    frame.writeInt(0 & 0x7fffffff); // Settings are always on the connection stream 0.
-    frame.writeInt(Settings.HEADER_TABLE_SIZE & 0xffffff);
-    frame.writeInt(reducedTableSizeBytes);
-    frame.writeInt(Settings.ENABLE_PUSH & 0xffffff);
-    frame.writeInt(0);
-
-    final Http20Draft09.Reader fr = new Http20Draft09.Reader(frame, 4096, false);
-
-    // Consume the settings frame.
-    fr.nextFrame(new BaseTestHandler() {
-      @Override public void settings(boolean clearPrevious, Settings settings) {
-        assertFalse(clearPrevious); // No clearPrevious in http/2.
-        assertEquals(reducedTableSizeBytes, settings.getHeaderTableSize());
-        assertEquals(false, settings.getEnablePush(true));
-      }
-    });
-  }
-
-  @Test public void pingRoundTrip() throws IOException {
-    OkBuffer frame = new OkBuffer();
-
-    final int expectedPayload1 = 7;
-    final int expectedPayload2 = 8;
-
-    // Compose the expected PING frame.
-    frame.writeShort(8); // length
-    frame.writeByte(Http20Draft09.TYPE_PING);
-    frame.writeByte(Http20Draft09.FLAG_ACK);
-    frame.writeInt(0); // connection-level
-    frame.writeInt(expectedPayload1);
-    frame.writeInt(expectedPayload2);
-
-    // Check writer sends the same bytes.
-    assertEquals(frame, sendPingFrame(true, expectedPayload1, expectedPayload2));
-
-    FrameReader fr = new Http20Draft09.Reader(frame, 4096, false);
-
-    fr.nextFrame(new BaseTestHandler() { // Consume the ping frame.
-      @Override public void ping(boolean ack, int payload1, int payload2) {
-        assertTrue(ack);
-        assertEquals(expectedPayload1, payload1);
-        assertEquals(expectedPayload2, payload2);
-      }
-    });
-  }
-
-  @Test public void maxLengthDataFrame() throws IOException {
-    OkBuffer frame = new OkBuffer();
-
-    final byte[] expectedData = new byte[16383];
-    Arrays.fill(expectedData, (byte) 2);
-
-    // Write the data frame.
-    frame.writeShort(expectedData.length);
-    frame.writeByte(Http20Draft09.TYPE_DATA);
-    frame.writeByte(0); // no flags
-    frame.writeInt(expectedStreamId & 0x7fffffff);
-    frame.write(expectedData);
-
-    // Check writer sends the same bytes.
-    assertEquals(frame, sendDataFrame(new OkBuffer().write(expectedData)));
-
-    FrameReader fr = new Http20Draft09.Reader(frame, 4096, false);
-
-    fr.nextFrame(new BaseTestHandler() {
-      @Override public void data(
-          boolean inFinished, int streamId, BufferedSource source, int length) throws IOException {
-        assertFalse(inFinished);
-        assertEquals(expectedStreamId, streamId);
-        assertEquals(16383, length);
-        ByteString data = source.readByteString(length);
-        for (byte b : data.toByteArray()){
-          assertEquals(2, b);
-        }
-      }
-    });
-  }
-
-  @Test public void tooLargeDataFrame() throws IOException {
-    try {
-      sendDataFrame(new OkBuffer().write(new byte[0x1000000]));
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertEquals("FRAME_SIZE_ERROR length > 16383: 16777216", e.getMessage());
-    }
-  }
-
-  @Test public void windowUpdateRoundTrip() throws IOException {
-    OkBuffer frame = new OkBuffer();
-
-    final long expectedWindowSizeIncrement = 0x7fffffff;
-
-    // Compose the expected window update frame.
-    frame.writeShort(4); // length
-    frame.writeByte(Http20Draft09.TYPE_WINDOW_UPDATE);
-    frame.writeByte(0); // No flags.
-    frame.writeInt(expectedStreamId);
-    frame.writeInt((int) expectedWindowSizeIncrement);
-
-    // Check writer sends the same bytes.
-    assertEquals(frame, windowUpdate(expectedWindowSizeIncrement));
-
-    FrameReader fr = new Http20Draft09.Reader(frame, 4096, false);
-
-    fr.nextFrame(new BaseTestHandler() { // Consume the window update frame.
-      @Override public void windowUpdate(int streamId, long windowSizeIncrement) {
-        assertEquals(expectedStreamId, streamId);
-        assertEquals(expectedWindowSizeIncrement, windowSizeIncrement);
-      }
-    });
-  }
-
-  @Test public void badWindowSizeIncrement() throws IOException {
-    try {
-      windowUpdate(0);
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertEquals("windowSizeIncrement == 0 || windowSizeIncrement > 0x7fffffffL: 0",
-          e.getMessage());
-    }
-    try {
-      windowUpdate(0x80000000L);
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertEquals("windowSizeIncrement == 0 || windowSizeIncrement > 0x7fffffffL: 2147483648",
-          e.getMessage());
-    }
-  }
-
-  @Test public void goAwayWithoutDebugDataRoundTrip() throws IOException {
-    OkBuffer frame = new OkBuffer();
-
-    final ErrorCode expectedError = ErrorCode.PROTOCOL_ERROR;
-
-    // Compose the expected GOAWAY frame without debug data.
-    frame.writeShort(8); // Without debug data there's only 2 32-bit fields.
-    frame.writeByte(Http20Draft09.TYPE_GOAWAY);
-    frame.writeByte(0); // no flags.
-    frame.writeInt(0); // connection-scope
-    frame.writeInt(expectedStreamId); // last good stream.
-    frame.writeInt(expectedError.httpCode);
-
-    // Check writer sends the same bytes.
-    assertEquals(frame, sendGoAway(expectedStreamId, expectedError, Util.EMPTY_BYTE_ARRAY));
-
-    FrameReader fr = new Http20Draft09.Reader(frame, 4096, false);
-
-    fr.nextFrame(new BaseTestHandler() { // Consume the go away frame.
-      @Override public void goAway(
-          int lastGoodStreamId, ErrorCode errorCode, ByteString debugData) {
-        assertEquals(expectedStreamId, lastGoodStreamId);
-        assertEquals(expectedError, errorCode);
-        assertEquals(0, debugData.size());
-      }
-    });
-  }
-
-  @Test public void goAwayWithDebugDataRoundTrip() throws IOException {
-    OkBuffer frame = new OkBuffer();
-
-    final ErrorCode expectedError = ErrorCode.PROTOCOL_ERROR;
-    final ByteString expectedData = ByteString.encodeUtf8("abcdefgh");
-
-    // Compose the expected GOAWAY frame without debug data.
-    frame.writeShort(8 + expectedData.size());
-    frame.writeByte(Http20Draft09.TYPE_GOAWAY);
-    frame.writeByte(0); // no flags.
-    frame.writeInt(0); // connection-scope
-    frame.writeInt(0); // never read any stream!
-    frame.writeInt(expectedError.httpCode);
-    frame.write(expectedData.toByteArray());
-
-    // Check writer sends the same bytes.
-    assertEquals(frame, sendGoAway(0, expectedError, expectedData.toByteArray()));
-
-    FrameReader fr = new Http20Draft09.Reader(frame, 4096, false);
-
-    fr.nextFrame(new BaseTestHandler() { // Consume the go away frame.
-      @Override public void goAway(
-          int lastGoodStreamId, ErrorCode errorCode, ByteString debugData) {
-        assertEquals(0, lastGoodStreamId);
-        assertEquals(expectedError, errorCode);
-        assertEquals(expectedData, debugData);
-      }
-    });
-  }
-
-  @Test public void frameSizeError() throws IOException {
-    Http20Draft09.Writer writer = new Http20Draft09.Writer(new OkBuffer(), true);
-
-    try {
-      writer.frameHeader(16384, Http20Draft09.TYPE_DATA, Http20Draft09.FLAG_NONE, 0);
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertEquals("FRAME_SIZE_ERROR length > 16383: 16384", e.getMessage());
-    }
-  }
-
-  @Test public void streamIdHasReservedBit() throws IOException {
-      Http20Draft09.Writer writer = new Http20Draft09.Writer(new OkBuffer(), true);
-
-      try {
-      int streamId = 3;
-      streamId |= 1L << 31; // set reserved bit
-      writer.frameHeader(16383, Http20Draft09.TYPE_DATA, Http20Draft09.FLAG_NONE, streamId);
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertEquals("reserved bit set: -2147483645", e.getMessage());
-    }
-  }
-
-  private OkBuffer literalHeaders(List<Header> sentHeaders) throws IOException {
-    OkBuffer out = new OkBuffer();
-    new HpackDraft05.Writer(out).writeHeaders(sentHeaders);
-    return out;
-  }
-
-  private OkBuffer sendPingFrame(boolean ack, int payload1, int payload2) throws IOException {
-    OkBuffer out = new OkBuffer();
-    new Http20Draft09.Writer(out, true).ping(ack, payload1, payload2);
-    return out;
-  }
-
-  private OkBuffer sendGoAway(int lastGoodStreamId, ErrorCode errorCode, byte[] debugData)
-      throws IOException {
-    OkBuffer out = new OkBuffer();
-    new Http20Draft09.Writer(out, true).goAway(lastGoodStreamId, errorCode, debugData);
-    return out;
-  }
-
-  private OkBuffer sendDataFrame(OkBuffer data) throws IOException {
-    OkBuffer out = new OkBuffer();
-    new Http20Draft09.Writer(out, true).dataFrame(expectedStreamId, Http20Draft09.FLAG_NONE, data,
-        (int) data.size());
-    return out;
-  }
-
-  private OkBuffer windowUpdate(long windowSizeIncrement) throws IOException {
-    OkBuffer out = new OkBuffer();
-    new Http20Draft09.Writer(out, true).windowUpdate(expectedStreamId, windowSizeIncrement);
-    return out;
-  }
-}
diff --git a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/spdy/Http20Draft14FrameLoggerTest.java b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/spdy/Http20Draft14FrameLoggerTest.java
new file mode 100644
index 0000000000..61dbf5b479
--- /dev/null
+++ b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/spdy/Http20Draft14FrameLoggerTest.java
@@ -0,0 +1,164 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.okhttp.internal.spdy;
+
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.List;
+import org.junit.Test;
+
+import static com.squareup.okhttp.internal.spdy.Http20Draft14.FLAG_ACK;
+import static com.squareup.okhttp.internal.spdy.Http20Draft14.FLAG_END_HEADERS;
+import static com.squareup.okhttp.internal.spdy.Http20Draft14.FLAG_END_STREAM;
+import static com.squareup.okhttp.internal.spdy.Http20Draft14.FLAG_NONE;
+import static com.squareup.okhttp.internal.spdy.Http20Draft14.FrameLogger.formatFlags;
+import static com.squareup.okhttp.internal.spdy.Http20Draft14.FrameLogger.formatHeader;
+import static com.squareup.okhttp.internal.spdy.Http20Draft14.TYPE_CONTINUATION;
+import static com.squareup.okhttp.internal.spdy.Http20Draft14.TYPE_DATA;
+import static com.squareup.okhttp.internal.spdy.Http20Draft14.TYPE_GOAWAY;
+import static com.squareup.okhttp.internal.spdy.Http20Draft14.TYPE_HEADERS;
+import static com.squareup.okhttp.internal.spdy.Http20Draft14.TYPE_PING;
+import static com.squareup.okhttp.internal.spdy.Http20Draft14.TYPE_PUSH_PROMISE;
+import static com.squareup.okhttp.internal.spdy.Http20Draft14.TYPE_SETTINGS;
+import static org.junit.Assert.assertEquals;
+
+public class Http20Draft14FrameLoggerTest {
+
+  /** Real stream traffic applied to the log format. */
+  @Test public void exampleStream() {
+    assertEquals(">> 0x00000000     5 SETTINGS      ",
+        formatHeader(false, 0, 5, TYPE_SETTINGS, FLAG_NONE));
+    assertEquals(">> 0x00000003   100 HEADERS       END_HEADERS",
+        formatHeader(false, 3, 100, TYPE_HEADERS, FLAG_END_HEADERS));
+    assertEquals(">> 0x00000003     0 DATA          END_STREAM",
+        formatHeader(false, 3, 0, TYPE_DATA, FLAG_END_STREAM));
+    assertEquals("<< 0x00000000    15 SETTINGS      ",
+        formatHeader(true, 0, 15, TYPE_SETTINGS, FLAG_NONE));
+    assertEquals(">> 0x00000000     0 SETTINGS      ACK",
+        formatHeader(false, 0, 0, TYPE_SETTINGS, FLAG_ACK));
+    assertEquals("<< 0x00000000     0 SETTINGS      ACK",
+        formatHeader(true, 0, 0, TYPE_SETTINGS, FLAG_ACK));
+    assertEquals("<< 0x00000003    22 HEADERS       END_HEADERS",
+        formatHeader(true, 3, 22, TYPE_HEADERS, FLAG_END_HEADERS));
+    assertEquals("<< 0x00000003   226 DATA          END_STREAM",
+        formatHeader(true, 3, 226, TYPE_DATA, FLAG_END_STREAM));
+    assertEquals(">> 0x00000000     8 GOAWAY        ",
+        formatHeader(false, 0, 8, TYPE_GOAWAY, FLAG_NONE));
+  }
+
+  @Test public void flagOverlapOn0x1() {
+    assertEquals("<< 0x00000000     0 SETTINGS      ACK",
+        formatHeader(true, 0, 0, TYPE_SETTINGS, (byte) 0x1));
+    assertEquals("<< 0x00000000     8 PING          ACK",
+        formatHeader(true, 0, 8, TYPE_PING, (byte) 0x1));
+    assertEquals("<< 0x00000003     0 HEADERS       END_STREAM",
+        formatHeader(true, 3, 0, TYPE_HEADERS, (byte) 0x1));
+    assertEquals("<< 0x00000003     0 DATA          END_STREAM",
+        formatHeader(true, 3, 0, TYPE_DATA, (byte) 0x1));
+  }
+
+  @Test public void flagOverlapOn0x4() {
+    assertEquals("<< 0x00000003 10000 HEADERS       END_HEADERS",
+        formatHeader(true, 3, 10000, TYPE_HEADERS, (byte) 0x4));
+    assertEquals("<< 0x00000003 10000 CONTINUATION  END_HEADERS",
+        formatHeader(true, 3, 10000, TYPE_CONTINUATION, (byte) 0x4));
+    assertEquals("<< 0x00000004 10000 PUSH_PROMISE  END_PUSH_PROMISE",
+        formatHeader(true, 4, 10000, TYPE_PUSH_PROMISE, (byte) 0x4));
+  }
+
+  @Test public void flagOverlapOn0x20() {
+    assertEquals("<< 0x00000003 10000 HEADERS       PRIORITY",
+        formatHeader(true, 3, 10000, TYPE_HEADERS, (byte) 0x20));
+    assertEquals("<< 0x00000003 10000 DATA          COMPRESSED",
+        formatHeader(true, 3, 10000, TYPE_DATA, (byte) 0x20));
+  }
+
+  /**
+   * Ensures that valid flag combinations appear visually correct, and invalid show in hex.  This
+   * also demonstrates how sparse the lookup table is.
+   */
+  @Test public void allFormattedFlagsWithValidBits() {
+    List<String> formattedFlags = new ArrayList<>(0x40); // Highest valid flag is 0x20.
+    for (byte i = 0; i < 0x40; i++) formattedFlags.add(formatFlags(TYPE_HEADERS, i));
+
+    assertEquals(Arrays.asList(
+        "",
+        "END_STREAM",
+        "00000010",
+        "00000011",
+        "END_HEADERS",
+        "END_STREAM|END_HEADERS",
+        "00000110",
+        "00000111",
+        "PADDED",
+        "END_STREAM|PADDED",
+        "00001010",
+        "00001011",
+        "00001100",
+        "END_STREAM|END_HEADERS|PADDED",
+        "00001110",
+        "00001111",
+        "00010000",
+        "00010001",
+        "00010010",
+        "00010011",
+        "00010100",
+        "00010101",
+        "00010110",
+        "00010111",
+        "00011000",
+        "00011001",
+        "00011010",
+        "00011011",
+        "00011100",
+        "00011101",
+        "00011110",
+        "00011111",
+        "PRIORITY",
+        "END_STREAM|PRIORITY",
+        "00100010",
+        "00100011",
+        "END_HEADERS|PRIORITY",
+        "END_STREAM|END_HEADERS|PRIORITY",
+        "00100110",
+        "00100111",
+        "00101000",
+        "END_STREAM|PRIORITY|PADDED",
+        "00101010",
+        "00101011",
+        "00101100",
+        "END_STREAM|END_HEADERS|PRIORITY|PADDED",
+        "00101110",
+        "00101111",
+        "00110000",
+        "00110001",
+        "00110010",
+        "00110011",
+        "00110100",
+        "00110101",
+        "00110110",
+        "00110111",
+        "00111000",
+        "00111001",
+        "00111010",
+        "00111011",
+        "00111100",
+        "00111101",
+        "00111110",
+        "00111111"
+    ), formattedFlags);
+  }
+}
diff --git a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/spdy/Http20Draft14Test.java b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/spdy/Http20Draft14Test.java
new file mode 100644
index 0000000000..9d1ad6c78f
--- /dev/null
+++ b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/spdy/Http20Draft14Test.java
@@ -0,0 +1,744 @@
+/*
+ * Copyright (C) 2013 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.okhttp.internal.spdy;
+
+import com.squareup.okhttp.internal.Util;
+import java.io.IOException;
+import java.util.Arrays;
+import java.util.List;
+import okio.Buffer;
+import okio.BufferedSink;
+import okio.BufferedSource;
+import okio.ByteString;
+import okio.GzipSink;
+import okio.Okio;
+import org.junit.Test;
+
+import static com.squareup.okhttp.internal.Util.headerEntries;
+import static com.squareup.okhttp.internal.spdy.Http20Draft14.FLAG_COMPRESSED;
+import static com.squareup.okhttp.internal.spdy.Http20Draft14.FLAG_END_HEADERS;
+import static com.squareup.okhttp.internal.spdy.Http20Draft14.FLAG_END_STREAM;
+import static com.squareup.okhttp.internal.spdy.Http20Draft14.FLAG_NONE;
+import static com.squareup.okhttp.internal.spdy.Http20Draft14.FLAG_PADDED;
+import static com.squareup.okhttp.internal.spdy.Http20Draft14.FLAG_PRIORITY;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertTrue;
+import static org.junit.Assert.fail;
+
+public class Http20Draft14Test {
+  final Buffer frame = new Buffer();
+  final FrameReader fr = new Http20Draft14.Reader(frame, 4096, false);
+  final int expectedStreamId = 15;
+
+  @Test public void unknownFrameTypeSkipped() throws IOException {
+    writeMedium(frame, 4); // has a 4-byte field
+    frame.writeByte(99); // type 99
+    frame.writeByte(Http20Draft14.FLAG_NONE);
+    frame.writeInt(expectedStreamId);
+    frame.writeInt(111111111); // custom data
+
+    fr.nextFrame(new BaseTestHandler()); // Should not callback.
+  }
+
+  @Test public void onlyOneLiteralHeadersFrame() throws IOException {
+    final List<Header> sentHeaders = headerEntries("name", "value");
+
+    Buffer headerBytes = literalHeaders(sentHeaders);
+    writeMedium(frame, (int) headerBytes.size());
+    frame.writeByte(Http20Draft14.TYPE_HEADERS);
+    frame.writeByte(FLAG_END_HEADERS | FLAG_END_STREAM);
+    frame.writeInt(expectedStreamId & 0x7fffffff);
+    frame.writeAll(headerBytes);
+
+    assertEquals(frame, sendHeaderFrames(true, sentHeaders)); // Check writer sends the same bytes.
+
+    fr.nextFrame(new BaseTestHandler() {
+      @Override
+      public void headers(boolean outFinished, boolean inFinished, int streamId,
+          int associatedStreamId, List<Header> headerBlock, HeadersMode headersMode) {
+        assertFalse(outFinished);
+        assertTrue(inFinished);
+        assertEquals(expectedStreamId, streamId);
+        assertEquals(-1, associatedStreamId);
+        assertEquals(sentHeaders, headerBlock);
+        assertEquals(HeadersMode.HTTP_20_HEADERS, headersMode);
+      }
+    });
+  }
+
+  @Test public void headersWithPriority() throws IOException {
+    final List<Header> sentHeaders = headerEntries("name", "value");
+
+    Buffer headerBytes = literalHeaders(sentHeaders);
+    writeMedium(frame, (int) (headerBytes.size() + 5));
+    frame.writeByte(Http20Draft14.TYPE_HEADERS);
+    frame.writeByte(FLAG_END_HEADERS | FLAG_PRIORITY);
+    frame.writeInt(expectedStreamId & 0x7fffffff);
+    frame.writeInt(0); // Independent stream.
+    frame.writeByte(255); // Heaviest weight, zero-indexed.
+    frame.writeAll(headerBytes);
+
+    fr.nextFrame(new BaseTestHandler() {
+      @Override public void priority(int streamId, int streamDependency, int weight,
+          boolean exclusive) {
+        assertEquals(0, streamDependency);
+        assertEquals(256, weight);
+        assertFalse(exclusive);
+      }
+
+      @Override public void headers(boolean outFinished, boolean inFinished, int streamId,
+          int associatedStreamId, List<Header> nameValueBlock,
+          HeadersMode headersMode) {
+        assertFalse(outFinished);
+        assertFalse(inFinished);
+        assertEquals(expectedStreamId, streamId);
+        assertEquals(-1, associatedStreamId);
+        assertEquals(sentHeaders, nameValueBlock);
+        assertEquals(HeadersMode.HTTP_20_HEADERS, headersMode);
+      }
+    });
+  }
+
+  /** Headers are compressed, then framed. */
+  @Test public void headersFrameThenContinuation() throws IOException {
+    final List<Header> sentHeaders = largeHeaders();
+
+    Buffer headerBlock = literalHeaders(sentHeaders);
+
+    // Write the first headers frame.
+    writeMedium(frame, Http20Draft14.INITIAL_MAX_FRAME_SIZE);
+    frame.writeByte(Http20Draft14.TYPE_HEADERS);
+    frame.writeByte(Http20Draft14.FLAG_NONE);
+    frame.writeInt(expectedStreamId & 0x7fffffff);
+    frame.write(headerBlock, Http20Draft14.INITIAL_MAX_FRAME_SIZE);
+
+    // Write the continuation frame, specifying no more frames are expected.
+    writeMedium(frame, (int) headerBlock.size());
+    frame.writeByte(Http20Draft14.TYPE_CONTINUATION);
+    frame.writeByte(FLAG_END_HEADERS);
+    frame.writeInt(expectedStreamId & 0x7fffffff);
+    frame.writeAll(headerBlock);
+
+    assertEquals(frame, sendHeaderFrames(false, sentHeaders)); // Check writer sends the same bytes.
+
+    // Reading the above frames should result in a concatenated headerBlock.
+    fr.nextFrame(new BaseTestHandler() {
+      @Override public void headers(boolean outFinished, boolean inFinished, int streamId,
+          int associatedStreamId, List<Header> headerBlock, HeadersMode headersMode) {
+        assertFalse(outFinished);
+        assertFalse(inFinished);
+        assertEquals(expectedStreamId, streamId);
+        assertEquals(-1, associatedStreamId);
+        assertEquals(sentHeaders, headerBlock);
+        assertEquals(HeadersMode.HTTP_20_HEADERS, headersMode);
+      }
+    });
+  }
+
+  @Test public void pushPromise() throws IOException {
+    final int expectedPromisedStreamId = 11;
+
+    final List<Header> pushPromise = Arrays.asList(
+        new Header(Header.TARGET_METHOD, "GET"),
+        new Header(Header.TARGET_SCHEME, "https"),
+        new Header(Header.TARGET_AUTHORITY, "squareup.com"),
+        new Header(Header.TARGET_PATH, "/")
+    );
+
+    // Write the push promise frame, specifying the associated stream ID.
+    Buffer headerBytes = literalHeaders(pushPromise);
+    writeMedium(frame, (int) (headerBytes.size() + 4));
+    frame.writeByte(Http20Draft14.TYPE_PUSH_PROMISE);
+    frame.writeByte(Http20Draft14.FLAG_END_PUSH_PROMISE);
+    frame.writeInt(expectedStreamId & 0x7fffffff);
+    frame.writeInt(expectedPromisedStreamId & 0x7fffffff);
+    frame.writeAll(headerBytes);
+
+    assertEquals(frame, sendPushPromiseFrames(expectedPromisedStreamId, pushPromise));
+
+    fr.nextFrame(new BaseTestHandler() {
+      @Override
+      public void pushPromise(int streamId, int promisedStreamId, List<Header> headerBlock) {
+        assertEquals(expectedStreamId, streamId);
+        assertEquals(expectedPromisedStreamId, promisedStreamId);
+        assertEquals(pushPromise, headerBlock);
+      }
+    });
+  }
+
+  /** Headers are compressed, then framed. */
+  @Test public void pushPromiseThenContinuation() throws IOException {
+    final int expectedPromisedStreamId = 11;
+    final List<Header> pushPromise = largeHeaders();
+
+    // Decoding the first header will cross frame boundaries.
+    Buffer headerBlock = literalHeaders(pushPromise);
+
+    // Write the first headers frame.
+    writeMedium(frame, Http20Draft14.INITIAL_MAX_FRAME_SIZE);
+    frame.writeByte(Http20Draft14.TYPE_PUSH_PROMISE);
+    frame.writeByte(Http20Draft14.FLAG_NONE);
+    frame.writeInt(expectedStreamId & 0x7fffffff);
+    frame.writeInt(expectedPromisedStreamId & 0x7fffffff);
+    frame.write(headerBlock, Http20Draft14.INITIAL_MAX_FRAME_SIZE - 4);
+
+    // Write the continuation frame, specifying no more frames are expected.
+    writeMedium(frame, (int) headerBlock.size());
+    frame.writeByte(Http20Draft14.TYPE_CONTINUATION);
+    frame.writeByte(FLAG_END_HEADERS);
+    frame.writeInt(expectedStreamId & 0x7fffffff);
+    frame.writeAll(headerBlock);
+
+    assertEquals(frame, sendPushPromiseFrames(expectedPromisedStreamId, pushPromise));
+
+    // Reading the above frames should result in a concatenated headerBlock.
+    fr.nextFrame(new BaseTestHandler() {
+      @Override
+      public void pushPromise(int streamId, int promisedStreamId, List<Header> headerBlock) {
+        assertEquals(expectedStreamId, streamId);
+        assertEquals(expectedPromisedStreamId, promisedStreamId);
+        assertEquals(pushPromise, headerBlock);
+      }
+    });
+  }
+
+  @Test public void readRstStreamFrame() throws IOException {
+    writeMedium(frame, 4);
+    frame.writeByte(Http20Draft14.TYPE_RST_STREAM);
+    frame.writeByte(Http20Draft14.FLAG_NONE);
+    frame.writeInt(expectedStreamId & 0x7fffffff);
+    frame.writeInt(ErrorCode.COMPRESSION_ERROR.httpCode);
+
+    fr.nextFrame(new BaseTestHandler() {
+      @Override public void rstStream(int streamId, ErrorCode errorCode) {
+        assertEquals(expectedStreamId, streamId);
+        assertEquals(ErrorCode.COMPRESSION_ERROR, errorCode);
+      }
+    });
+  }
+
+  @Test public void readSettingsFrame() throws IOException {
+    final int reducedTableSizeBytes = 16;
+
+    writeMedium(frame, 12); // 2 settings * 6 bytes (2 for the code and 4 for the value).
+    frame.writeByte(Http20Draft14.TYPE_SETTINGS);
+    frame.writeByte(Http20Draft14.FLAG_NONE);
+    frame.writeInt(0); // Settings are always on the connection stream 0.
+    frame.writeShort(1); // SETTINGS_HEADER_TABLE_SIZE
+    frame.writeInt(reducedTableSizeBytes);
+    frame.writeShort(2); // SETTINGS_ENABLE_PUSH
+    frame.writeInt(0);
+
+    fr.nextFrame(new BaseTestHandler() {
+      @Override public void settings(boolean clearPrevious, Settings settings) {
+        assertFalse(clearPrevious); // No clearPrevious in HTTP/2.
+        assertEquals(reducedTableSizeBytes, settings.getHeaderTableSize());
+        assertEquals(false, settings.getEnablePush(true));
+      }
+    });
+  }
+
+  @Test public void readSettingsFrameInvalidPushValue() throws IOException {
+    writeMedium(frame, 6); // 2 for the code and 4 for the value
+    frame.writeByte(Http20Draft14.TYPE_SETTINGS);
+    frame.writeByte(Http20Draft14.FLAG_NONE);
+    frame.writeInt(0); // Settings are always on the connection stream 0.
+    frame.writeShort(2);
+    frame.writeInt(2);
+
+    try {
+      fr.nextFrame(new BaseTestHandler());
+      fail();
+    } catch (IOException e) {
+      assertEquals("PROTOCOL_ERROR SETTINGS_ENABLE_PUSH != 0 or 1", e.getMessage());
+    }
+  }
+
+  @Test public void readSettingsFrameInvalidSettingId() throws IOException {
+    writeMedium(frame, 6); // 2 for the code and 4 for the value
+    frame.writeByte(Http20Draft14.TYPE_SETTINGS);
+    frame.writeByte(Http20Draft14.FLAG_NONE);
+    frame.writeInt(0); // Settings are always on the connection stream 0.
+    frame.writeShort(7); // old number for SETTINGS_INITIAL_WINDOW_SIZE
+    frame.writeInt(1);
+
+    try {
+      fr.nextFrame(new BaseTestHandler());
+      fail();
+    } catch (IOException e) {
+      assertEquals("PROTOCOL_ERROR invalid settings id: 7", e.getMessage());
+    }
+  }
+
+  @Test public void readSettingsFrameNegativeWindowSize() throws IOException {
+    writeMedium(frame, 6); // 2 for the code and 4 for the value
+    frame.writeByte(Http20Draft14.TYPE_SETTINGS);
+    frame.writeByte(Http20Draft14.FLAG_NONE);
+    frame.writeInt(0); // Settings are always on the connection stream 0.
+    frame.writeShort(4); // SETTINGS_INITIAL_WINDOW_SIZE
+    frame.writeInt(Integer.MIN_VALUE);
+
+    try {
+      fr.nextFrame(new BaseTestHandler());
+      fail();
+    } catch (IOException e) {
+      assertEquals("PROTOCOL_ERROR SETTINGS_INITIAL_WINDOW_SIZE > 2^31 - 1", e.getMessage());
+    }
+  }
+
+  @Test public void readSettingsFrameNegativeFrameLength() throws IOException {
+    writeMedium(frame, 6); // 2 for the code and 4 for the value
+    frame.writeByte(Http20Draft14.TYPE_SETTINGS);
+    frame.writeByte(Http20Draft14.FLAG_NONE);
+    frame.writeInt(0); // Settings are always on the connection stream 0.
+    frame.writeShort(5); // SETTINGS_MAX_FRAME_SIZE
+    frame.writeInt(Integer.MIN_VALUE);
+
+    try {
+      fr.nextFrame(new BaseTestHandler());
+      fail();
+    } catch (IOException e) {
+      assertEquals("PROTOCOL_ERROR SETTINGS_MAX_FRAME_SIZE: -2147483648", e.getMessage());
+    }
+  }
+
+  @Test public void readSettingsFrameTooShortFrameLength() throws IOException {
+    writeMedium(frame, 6); // 2 for the code and 4 for the value
+    frame.writeByte(Http20Draft14.TYPE_SETTINGS);
+    frame.writeByte(Http20Draft14.FLAG_NONE);
+    frame.writeInt(0); // Settings are always on the connection stream 0.
+    frame.writeShort(5); // SETTINGS_MAX_FRAME_SIZE
+    frame.writeInt((int) Math.pow(2, 14) - 1);
+
+    try {
+      fr.nextFrame(new BaseTestHandler());
+      fail();
+    } catch (IOException e) {
+      assertEquals("PROTOCOL_ERROR SETTINGS_MAX_FRAME_SIZE: 16383", e.getMessage());
+    }
+  }
+
+  @Test public void readSettingsFrameTooLongFrameLength() throws IOException {
+    writeMedium(frame, 6); // 2 for the code and 4 for the value
+    frame.writeByte(Http20Draft14.TYPE_SETTINGS);
+    frame.writeByte(Http20Draft14.FLAG_NONE);
+    frame.writeInt(0); // Settings are always on the connection stream 0.
+    frame.writeShort(5); // SETTINGS_MAX_FRAME_SIZE
+    frame.writeInt((int) Math.pow(2, 24));
+
+    try {
+      fr.nextFrame(new BaseTestHandler());
+      fail();
+    } catch (IOException e) {
+      assertEquals("PROTOCOL_ERROR SETTINGS_MAX_FRAME_SIZE: 16777216", e.getMessage());
+    }
+  }
+
+  @Test public void pingRoundTrip() throws IOException {
+    final int expectedPayload1 = 7;
+    final int expectedPayload2 = 8;
+
+    writeMedium(frame, 8); // length
+    frame.writeByte(Http20Draft14.TYPE_PING);
+    frame.writeByte(Http20Draft14.FLAG_ACK);
+    frame.writeInt(0); // connection-level
+    frame.writeInt(expectedPayload1);
+    frame.writeInt(expectedPayload2);
+
+    // Check writer sends the same bytes.
+    assertEquals(frame, sendPingFrame(true, expectedPayload1, expectedPayload2));
+
+    fr.nextFrame(new BaseTestHandler() {
+      @Override public void ping(boolean ack, int payload1, int payload2) {
+        assertTrue(ack);
+        assertEquals(expectedPayload1, payload1);
+        assertEquals(expectedPayload2, payload2);
+      }
+    });
+  }
+
+  @Test public void maxLengthDataFrame() throws IOException {
+    final byte[] expectedData = new byte[Http20Draft14.INITIAL_MAX_FRAME_SIZE];
+    Arrays.fill(expectedData, (byte) 2);
+
+    writeMedium(frame, expectedData.length);
+    frame.writeByte(Http20Draft14.TYPE_DATA);
+    frame.writeByte(Http20Draft14.FLAG_NONE);
+    frame.writeInt(expectedStreamId & 0x7fffffff);
+    frame.write(expectedData);
+
+    // Check writer sends the same bytes.
+    assertEquals(frame, sendDataFrame(new Buffer().write(expectedData)));
+
+    fr.nextFrame(new BaseTestHandler() {
+      @Override public void data(boolean inFinished, int streamId, BufferedSource source,
+          int length) throws IOException {
+        assertFalse(inFinished);
+        assertEquals(expectedStreamId, streamId);
+        assertEquals(Http20Draft14.INITIAL_MAX_FRAME_SIZE, length);
+        ByteString data = source.readByteString(length);
+        for (byte b : data.toByteArray()) {
+          assertEquals(2, b);
+        }
+      }
+    });
+  }
+
+  /** We do not send SETTINGS_COMPRESS_DATA = 1, nor want to. Let's make sure we error. */
+  @Test public void compressedDataFrameWhenSettingDisabled() throws IOException {
+    byte[] expectedData = new byte[Http20Draft14.INITIAL_MAX_FRAME_SIZE];
+    Arrays.fill(expectedData, (byte) 2);
+    Buffer zipped = gzip(expectedData);
+    int zippedSize = (int) zipped.size();
+
+    writeMedium(frame, zippedSize);
+    frame.writeByte(Http20Draft14.TYPE_DATA);
+    frame.writeByte(FLAG_COMPRESSED);
+    frame.writeInt(expectedStreamId & 0x7fffffff);
+    zipped.readAll(frame);
+
+    try {
+      fr.nextFrame(new BaseTestHandler());
+      fail();
+    } catch (IOException e) {
+      assertEquals("PROTOCOL_ERROR: FLAG_COMPRESSED without SETTINGS_COMPRESS_DATA",
+          e.getMessage());
+    }
+  }
+
+  @Test public void readPaddedDataFrame() throws IOException {
+    int dataLength = 1123;
+    byte[] expectedData = new byte[dataLength];
+    Arrays.fill(expectedData, (byte) 2);
+
+    int paddingLength = 254;
+    byte[] padding = new byte[paddingLength];
+    Arrays.fill(padding, (byte) 0);
+
+    writeMedium(frame, dataLength + paddingLength + 1);
+    frame.writeByte(Http20Draft14.TYPE_DATA);
+    frame.writeByte(FLAG_PADDED);
+    frame.writeInt(expectedStreamId & 0x7fffffff);
+    frame.writeByte(paddingLength);
+    frame.write(expectedData);
+    frame.write(padding);
+
+    fr.nextFrame(assertData());
+    assertTrue(frame.exhausted()); // Padding was skipped.
+  }
+
+  @Test public void readPaddedDataFrameZeroPadding() throws IOException {
+    int dataLength = 1123;
+    byte[] expectedData = new byte[dataLength];
+    Arrays.fill(expectedData, (byte) 2);
+
+    writeMedium(frame, dataLength + 1);
+    frame.writeByte(Http20Draft14.TYPE_DATA);
+    frame.writeByte(FLAG_PADDED);
+    frame.writeInt(expectedStreamId & 0x7fffffff);
+    frame.writeByte(0);
+    frame.write(expectedData);
+
+    fr.nextFrame(assertData());
+  }
+
+  @Test public void readPaddedHeadersFrame() throws IOException {
+    int paddingLength = 254;
+    byte[] padding = new byte[paddingLength];
+    Arrays.fill(padding, (byte) 0);
+
+    Buffer headerBlock = literalHeaders(headerEntries("foo", "barrr", "baz", "qux"));
+    writeMedium(frame, (int) headerBlock.size() + paddingLength + 1);
+    frame.writeByte(Http20Draft14.TYPE_HEADERS);
+    frame.writeByte(FLAG_END_HEADERS | FLAG_PADDED);
+    frame.writeInt(expectedStreamId & 0x7fffffff);
+    frame.writeByte(paddingLength);
+    frame.writeAll(headerBlock);
+    frame.write(padding);
+
+    fr.nextFrame(assertHeaderBlock());
+    assertTrue(frame.exhausted()); // Padding was skipped.
+  }
+
+  @Test public void readPaddedHeadersFrameZeroPadding() throws IOException {
+    Buffer headerBlock = literalHeaders(headerEntries("foo", "barrr", "baz", "qux"));
+    writeMedium(frame, (int) headerBlock.size() + 1);
+    frame.writeByte(Http20Draft14.TYPE_HEADERS);
+    frame.writeByte(FLAG_END_HEADERS | FLAG_PADDED);
+    frame.writeInt(expectedStreamId & 0x7fffffff);
+    frame.writeByte(0);
+    frame.writeAll(headerBlock);
+
+    fr.nextFrame(assertHeaderBlock());
+  }
+
+  /** Headers are compressed, then framed. */
+  @Test public void readPaddedHeadersFrameThenContinuation() throws IOException {
+    int paddingLength = 254;
+    byte[] padding = new byte[paddingLength];
+    Arrays.fill(padding, (byte) 0);
+
+    // Decoding the first header will cross frame boundaries.
+    Buffer headerBlock = literalHeaders(headerEntries("foo", "barrr", "baz", "qux"));
+
+    // Write the first headers frame.
+    writeMedium(frame, (int) (headerBlock.size() / 2) + paddingLength + 1);
+    frame.writeByte(Http20Draft14.TYPE_HEADERS);
+    frame.writeByte(FLAG_PADDED);
+    frame.writeInt(expectedStreamId & 0x7fffffff);
+    frame.writeByte(paddingLength);
+    frame.write(headerBlock, headerBlock.size() / 2);
+    frame.write(padding);
+
+    // Write the continuation frame, specifying no more frames are expected.
+    writeMedium(frame, (int) headerBlock.size());
+    frame.writeByte(Http20Draft14.TYPE_CONTINUATION);
+    frame.writeByte(FLAG_END_HEADERS);
+    frame.writeInt(expectedStreamId & 0x7fffffff);
+    frame.writeAll(headerBlock);
+
+    fr.nextFrame(assertHeaderBlock());
+    assertTrue(frame.exhausted());
+  }
+
+  @Test public void tooLargeDataFrame() throws IOException {
+    try {
+      sendDataFrame(new Buffer().write(new byte[0x1000000]));
+      fail();
+    } catch (IllegalArgumentException e) {
+      assertEquals("FRAME_SIZE_ERROR length > 16384: 16777216", e.getMessage());
+    }
+  }
+
+  @Test public void windowUpdateRoundTrip() throws IOException {
+    final long expectedWindowSizeIncrement = 0x7fffffff;
+
+    writeMedium(frame, 4); // length
+    frame.writeByte(Http20Draft14.TYPE_WINDOW_UPDATE);
+    frame.writeByte(Http20Draft14.FLAG_NONE);
+    frame.writeInt(expectedStreamId);
+    frame.writeInt((int) expectedWindowSizeIncrement);
+
+    // Check writer sends the same bytes.
+    assertEquals(frame, windowUpdate(expectedWindowSizeIncrement));
+
+    fr.nextFrame(new BaseTestHandler() {
+      @Override public void windowUpdate(int streamId, long windowSizeIncrement) {
+        assertEquals(expectedStreamId, streamId);
+        assertEquals(expectedWindowSizeIncrement, windowSizeIncrement);
+      }
+    });
+  }
+
+  @Test public void badWindowSizeIncrement() throws IOException {
+    try {
+      windowUpdate(0);
+      fail();
+    } catch (IllegalArgumentException e) {
+      assertEquals("windowSizeIncrement == 0 || windowSizeIncrement > 0x7fffffffL: 0",
+          e.getMessage());
+    }
+    try {
+      windowUpdate(0x80000000L);
+      fail();
+    } catch (IllegalArgumentException e) {
+      assertEquals("windowSizeIncrement == 0 || windowSizeIncrement > 0x7fffffffL: 2147483648",
+          e.getMessage());
+    }
+  }
+
+  @Test public void goAwayWithoutDebugDataRoundTrip() throws IOException {
+    final ErrorCode expectedError = ErrorCode.PROTOCOL_ERROR;
+
+    writeMedium(frame, 8); // Without debug data there's only 2 32-bit fields.
+    frame.writeByte(Http20Draft14.TYPE_GOAWAY);
+    frame.writeByte(Http20Draft14.FLAG_NONE);
+    frame.writeInt(0); // connection-scope
+    frame.writeInt(expectedStreamId); // last good stream.
+    frame.writeInt(expectedError.httpCode);
+
+    // Check writer sends the same bytes.
+    assertEquals(frame, sendGoAway(expectedStreamId, expectedError, Util.EMPTY_BYTE_ARRAY));
+
+    fr.nextFrame(new BaseTestHandler() {
+      @Override public void goAway(
+          int lastGoodStreamId, ErrorCode errorCode, ByteString debugData) {
+        assertEquals(expectedStreamId, lastGoodStreamId);
+        assertEquals(expectedError, errorCode);
+        assertEquals(0, debugData.size());
+      }
+    });
+  }
+
+  @Test public void goAwayWithDebugDataRoundTrip() throws IOException {
+    final ErrorCode expectedError = ErrorCode.PROTOCOL_ERROR;
+    final ByteString expectedData = ByteString.encodeUtf8("abcdefgh");
+
+    // Compose the expected GOAWAY frame without debug data.
+    writeMedium(frame, 8 + expectedData.size());
+    frame.writeByte(Http20Draft14.TYPE_GOAWAY);
+    frame.writeByte(Http20Draft14.FLAG_NONE);
+    frame.writeInt(0); // connection-scope
+    frame.writeInt(0); // never read any stream!
+    frame.writeInt(expectedError.httpCode);
+    frame.write(expectedData.toByteArray());
+
+    // Check writer sends the same bytes.
+    assertEquals(frame, sendGoAway(0, expectedError, expectedData.toByteArray()));
+
+    fr.nextFrame(new BaseTestHandler() {
+      @Override public void goAway(
+          int lastGoodStreamId, ErrorCode errorCode, ByteString debugData) {
+        assertEquals(0, lastGoodStreamId);
+        assertEquals(expectedError, errorCode);
+        assertEquals(expectedData, debugData);
+      }
+    });
+  }
+
+  @Test public void frameSizeError() throws IOException {
+    Http20Draft14.Writer writer = new Http20Draft14.Writer(new Buffer(), true);
+
+    try {
+      writer.frameHeader(0, 16777216, Http20Draft14.TYPE_DATA, FLAG_NONE);
+      fail();
+    } catch (IllegalArgumentException e) {
+      // TODO: real max is based on settings between 16384 and 16777215
+      assertEquals("FRAME_SIZE_ERROR length > 16384: 16777216", e.getMessage());
+    }
+  }
+
+  @Test public void ackSettingsAppliesMaxFrameSize() throws IOException {
+    int newMaxFrameSize = 16777215;
+
+    Http20Draft14.Writer writer = new Http20Draft14.Writer(new Buffer(), true);
+
+    writer.ackSettings(new Settings().set(Settings.MAX_FRAME_SIZE, 0, newMaxFrameSize));
+
+    assertEquals(newMaxFrameSize, writer.maxDataLength());
+    writer.frameHeader(0, newMaxFrameSize, Http20Draft14.TYPE_DATA, FLAG_NONE);
+  }
+
+  @Test public void streamIdHasReservedBit() throws IOException {
+    Http20Draft14.Writer writer = new Http20Draft14.Writer(new Buffer(), true);
+
+    try {
+      int streamId = 3;
+      streamId |= 1L << 31; // set reserved bit
+      writer.frameHeader(streamId, Http20Draft14.INITIAL_MAX_FRAME_SIZE, Http20Draft14.TYPE_DATA, FLAG_NONE);
+      fail();
+    } catch (IllegalArgumentException e) {
+      assertEquals("reserved bit set: -2147483645", e.getMessage());
+    }
+  }
+
+  private Buffer literalHeaders(List<Header> sentHeaders) throws IOException {
+    Buffer out = new Buffer();
+    new HpackDraft09.Writer(out).writeHeaders(sentHeaders);
+    return out;
+  }
+
+  private Buffer sendHeaderFrames(boolean outFinished, List<Header> headers) throws IOException {
+    Buffer out = new Buffer();
+    new Http20Draft14.Writer(out, true).headers(outFinished, expectedStreamId, headers);
+    return out;
+  }
+
+  private Buffer sendPushPromiseFrames(int streamId, List<Header> headers) throws IOException {
+    Buffer out = new Buffer();
+    new Http20Draft14.Writer(out, true).pushPromise(expectedStreamId, streamId, headers);
+    return out;
+  }
+
+  private Buffer sendPingFrame(boolean ack, int payload1, int payload2) throws IOException {
+    Buffer out = new Buffer();
+    new Http20Draft14.Writer(out, true).ping(ack, payload1, payload2);
+    return out;
+  }
+
+  private Buffer sendGoAway(int lastGoodStreamId, ErrorCode errorCode, byte[] debugData)
+      throws IOException {
+    Buffer out = new Buffer();
+    new Http20Draft14.Writer(out, true).goAway(lastGoodStreamId, errorCode, debugData);
+    return out;
+  }
+
+  private Buffer sendDataFrame(Buffer data) throws IOException {
+    Buffer out = new Buffer();
+    new Http20Draft14.Writer(out, true).dataFrame(expectedStreamId, FLAG_NONE, data,
+        (int) data.size());
+    return out;
+  }
+
+  private Buffer windowUpdate(long windowSizeIncrement) throws IOException {
+    Buffer out = new Buffer();
+    new Http20Draft14.Writer(out, true).windowUpdate(expectedStreamId, windowSizeIncrement);
+    return out;
+  }
+
+  private FrameReader.Handler assertHeaderBlock() {
+    return new BaseTestHandler() {
+      @Override public void headers(boolean outFinished, boolean inFinished, int streamId,
+          int associatedStreamId, List<Header> headerBlock, HeadersMode headersMode) {
+        assertFalse(outFinished);
+        assertFalse(inFinished);
+        assertEquals(expectedStreamId, streamId);
+        assertEquals(-1, associatedStreamId);
+        assertEquals(headerEntries("foo", "barrr", "baz", "qux"), headerBlock);
+        assertEquals(HeadersMode.HTTP_20_HEADERS, headersMode);
+      }
+    };
+  }
+
+  private FrameReader.Handler assertData() {
+    return new BaseTestHandler() {
+      @Override public void data(boolean inFinished, int streamId, BufferedSource source,
+          int length) throws IOException {
+        assertFalse(inFinished);
+        assertEquals(expectedStreamId, streamId);
+        assertEquals(1123, length);
+        ByteString data = source.readByteString(length);
+        for (byte b : data.toByteArray()) {
+          assertEquals(2, b);
+        }
+      }
+    };
+  }
+
+  private static Buffer gzip(byte[] data) throws IOException {
+    Buffer buffer = new Buffer();
+    Okio.buffer(new GzipSink(buffer)).write(data).close();
+    return buffer;
+  }
+
+  /** Create a sufficiently large header set to overflow Http20Draft12.INITIAL_MAX_FRAME_SIZE bytes. */
+  private static List<Header> largeHeaders() {
+    String[] nameValues = new String[32];
+    char[] chars = new char[512];
+    for (int i = 0; i < nameValues.length;) {
+      Arrays.fill(chars, (char) i);
+      nameValues[i++] = nameValues[i++] = String.valueOf(chars);
+    }
+    return headerEntries(nameValues);
+  }
+
+  private static void writeMedium(BufferedSink sink, int i) throws IOException {
+    sink.writeByte((i >>> 16) & 0xff);
+    sink.writeByte((i >>>  8) & 0xff);
+    sink.writeByte( i         & 0xff);
+  }
+}
diff --git a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/spdy/Http2ConnectionTest.java b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/spdy/Http2ConnectionTest.java
new file mode 100644
index 0000000000..4fc9c70c9d
--- /dev/null
+++ b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/spdy/Http2ConnectionTest.java
@@ -0,0 +1,521 @@
+/*
+ * Copyright (C) 2011 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.okhttp.internal.spdy;
+
+import com.squareup.okhttp.internal.Util;
+import java.io.IOException;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.List;
+import java.util.concurrent.TimeUnit;
+import okio.Buffer;
+import okio.BufferedSink;
+import okio.BufferedSource;
+import okio.Okio;
+import okio.Source;
+import org.junit.After;
+import org.junit.Test;
+
+import static com.squareup.okhttp.internal.Util.headerEntries;
+import static com.squareup.okhttp.internal.spdy.ErrorCode.CANCEL;
+import static com.squareup.okhttp.internal.spdy.ErrorCode.PROTOCOL_ERROR;
+import static com.squareup.okhttp.internal.spdy.Settings.DEFAULT_INITIAL_WINDOW_SIZE;
+import static com.squareup.okhttp.internal.spdy.Settings.PERSIST_VALUE;
+import static com.squareup.okhttp.internal.spdy.Spdy3.TYPE_DATA;
+import static com.squareup.okhttp.internal.spdy.Spdy3.TYPE_HEADERS;
+import static com.squareup.okhttp.internal.spdy.Spdy3.TYPE_PING;
+import static com.squareup.okhttp.internal.spdy.Spdy3.TYPE_RST_STREAM;
+import static com.squareup.okhttp.internal.spdy.Spdy3.TYPE_SETTINGS;
+import static com.squareup.okhttp.internal.spdy.Spdy3.TYPE_WINDOW_UPDATE;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertTrue;
+import static org.junit.Assert.fail;
+
+public final class Http2ConnectionTest {
+  private static final Variant HTTP_2 = new Http20Draft14();
+  private final MockSpdyPeer peer = new MockSpdyPeer();
+
+  @After public void tearDown() throws Exception {
+    peer.close();
+  }
+
+  @Test public void serverPingsClientHttp2() throws Exception {
+    peer.setVariantAndClient(HTTP_2, false);
+
+    // write the mocking script
+    peer.sendFrame().ping(false, 2, 3);
+    peer.acceptFrame(); // PING
+    peer.play();
+
+    // play it back
+    connection(peer, HTTP_2);
+
+    // verify the peer received what was expected
+    MockSpdyPeer.InFrame ping = peer.takeFrame();
+    assertEquals(TYPE_PING, ping.type);
+    assertEquals(0, ping.streamId);
+    assertEquals(2, ping.payload1);
+    assertEquals(3, ping.payload2);
+    assertTrue(ping.ack);
+  }
+
+  @Test public void clientPingsServerHttp2() throws Exception {
+    peer.setVariantAndClient(HTTP_2, false);
+
+    // write the mocking script
+    peer.acceptFrame(); // PING
+    peer.sendFrame().ping(true, 1, 5);
+    peer.play();
+
+    // play it back
+    SpdyConnection connection = connection(peer, HTTP_2);
+    Ping ping = connection.ping();
+    assertTrue(ping.roundTripTime() > 0);
+    assertTrue(ping.roundTripTime() < TimeUnit.SECONDS.toNanos(1));
+
+    // verify the peer received what was expected
+    MockSpdyPeer.InFrame pingFrame = peer.takeFrame();
+    assertEquals(0, pingFrame.streamId);
+    assertEquals(1, pingFrame.payload1);
+    assertEquals(0x4f4b6f6b, pingFrame.payload2); // connection.ping() sets this.
+    assertFalse(pingFrame.ack);
+  }
+
+  @Test public void peerHttp2ServerLowersInitialWindowSize() throws Exception {
+    peer.setVariantAndClient(HTTP_2, false);
+
+    Settings initial = new Settings();
+    initial.set(Settings.INITIAL_WINDOW_SIZE, PERSIST_VALUE, 1684);
+    Settings shouldntImpactConnection = new Settings();
+    shouldntImpactConnection.set(Settings.INITIAL_WINDOW_SIZE, PERSIST_VALUE, 3368);
+
+    peer.sendFrame().settings(initial);
+    peer.acceptFrame(); // ACK
+    peer.sendFrame().settings(shouldntImpactConnection);
+    peer.acceptFrame(); // ACK 2
+    peer.acceptFrame(); // HEADERS
+    peer.play();
+
+    SpdyConnection connection = connection(peer, HTTP_2);
+
+    // Default is 64KiB - 1.
+    assertEquals(65535, connection.peerSettings.getInitialWindowSize(-1));
+
+    // Verify the peer received the ACK.
+    MockSpdyPeer.InFrame ackFrame = peer.takeFrame();
+    assertEquals(TYPE_SETTINGS, ackFrame.type);
+    assertEquals(0, ackFrame.streamId);
+    assertTrue(ackFrame.ack);
+    ackFrame = peer.takeFrame();
+    assertEquals(TYPE_SETTINGS, ackFrame.type);
+    assertEquals(0, ackFrame.streamId);
+    assertTrue(ackFrame.ack);
+
+    // This stream was created *after* the connection settings were adjusted.
+    SpdyStream stream = connection.newStream(headerEntries("a", "android"), false, true);
+
+    assertEquals(3368, connection.peerSettings.getInitialWindowSize(DEFAULT_INITIAL_WINDOW_SIZE));
+    assertEquals(1684, connection.bytesLeftInWriteWindow); // initial wasn't affected.
+    // New Stream is has the most recent initial window size.
+    assertEquals(3368, stream.bytesLeftInWriteWindow);
+  }
+
+  @Test public void peerHttp2ServerZerosCompressionTable() throws Exception {
+    boolean client = false; // Peer is server, so we are client.
+    Settings settings = new Settings();
+    settings.set(Settings.HEADER_TABLE_SIZE, PERSIST_VALUE, 0);
+
+    SpdyConnection connection = sendHttp2SettingsAndCheckForAck(client, settings);
+
+    // verify the peer's settings were read and applied.
+    assertEquals(0, connection.peerSettings.getHeaderTableSize());
+    Http20Draft14.Reader frameReader = (Http20Draft14.Reader) connection.readerRunnable.frameReader;
+    assertEquals(0, frameReader.hpackReader.maxHeaderTableByteCount());
+    // TODO: when supported, check the frameWriter's compression table is unaffected.
+  }
+
+  @Test public void peerHttp2ClientDisablesPush() throws Exception {
+    boolean client = false; // Peer is client, so we are server.
+    Settings settings = new Settings();
+    settings.set(Settings.ENABLE_PUSH, 0, 0); // The peer client disables push.
+
+    SpdyConnection connection = sendHttp2SettingsAndCheckForAck(client, settings);
+
+    // verify the peer's settings were read and applied.
+    assertFalse(connection.peerSettings.getEnablePush(true));
+  }
+
+  @Test public void peerIncreasesMaxFrameSize() throws Exception {
+    int newMaxFrameSize = 0x4001;
+    Settings settings = new Settings();
+    settings.set(Settings.MAX_FRAME_SIZE, 0, newMaxFrameSize);
+
+    SpdyConnection connection = sendHttp2SettingsAndCheckForAck(true, settings);
+
+    // verify the peer's settings were read and applied.
+    assertEquals(newMaxFrameSize, connection.peerSettings.getMaxFrameSize(-1));
+    assertEquals(newMaxFrameSize, connection.frameWriter.maxDataLength());
+  }
+
+  @Test public void receiveGoAwayHttp2() throws Exception {
+    peer.setVariantAndClient(HTTP_2, false);
+
+    // write the mocking script
+    peer.acceptFrame(); // SYN_STREAM 3
+    peer.acceptFrame(); // SYN_STREAM 5
+    peer.sendFrame().goAway(3, PROTOCOL_ERROR, Util.EMPTY_BYTE_ARRAY);
+    peer.acceptFrame(); // PING
+    peer.sendFrame().ping(true, 1, 0);
+    peer.acceptFrame(); // DATA STREAM 3
+    peer.play();
+
+    // play it back
+    SpdyConnection connection = connection(peer, HTTP_2);
+    SpdyStream stream1 = connection.newStream(headerEntries("a", "android"), true, true);
+    SpdyStream stream2 = connection.newStream(headerEntries("b", "banana"), true, true);
+    connection.ping().roundTripTime(); // Ensure the GO_AWAY that resets stream2 has been received.
+    BufferedSink sink1 = Okio.buffer(stream1.getSink());
+    BufferedSink sink2 = Okio.buffer(stream2.getSink());
+    sink1.writeUtf8("abc");
+    try {
+      sink2.writeUtf8("abc");
+      sink2.flush();
+      fail();
+    } catch (IOException expected) {
+      assertEquals("stream was reset: REFUSED_STREAM", expected.getMessage());
+    }
+    sink1.writeUtf8("def");
+    sink1.close();
+    try {
+      connection.newStream(headerEntries("c", "cola"), true, true);
+      fail();
+    } catch (IOException expected) {
+      assertEquals("shutdown", expected.getMessage());
+    }
+    assertTrue(stream1.isOpen());
+    assertFalse(stream2.isOpen());
+    assertEquals(1, connection.openStreamCount());
+
+    // verify the peer received what was expected
+    MockSpdyPeer.InFrame synStream1 = peer.takeFrame();
+    assertEquals(TYPE_HEADERS, synStream1.type);
+    MockSpdyPeer.InFrame synStream2 = peer.takeFrame();
+    assertEquals(TYPE_HEADERS, synStream2.type);
+    MockSpdyPeer.InFrame ping = peer.takeFrame();
+    assertEquals(TYPE_PING, ping.type);
+    MockSpdyPeer.InFrame data1 = peer.takeFrame();
+    assertEquals(TYPE_DATA, data1.type);
+    assertEquals(3, data1.streamId);
+    assertTrue(Arrays.equals("abcdef".getBytes("UTF-8"), data1.data));
+  }
+
+  @Test public void readSendsWindowUpdateHttp2() throws Exception {
+    peer.setVariantAndClient(HTTP_2, false);
+
+    int windowSize = 100;
+    int windowUpdateThreshold = 50;
+
+    // Write the mocking script.
+    peer.acceptFrame(); // SYN_STREAM
+    peer.sendFrame().synReply(false, 3, headerEntries("a", "android"));
+    for (int i = 0; i < 3; i++) {
+      // Send frames of summing to size 50, which is windowUpdateThreshold.
+      peer.sendFrame().data(false, 3, data(24), 24);
+      peer.sendFrame().data(false, 3, data(25), 25);
+      peer.sendFrame().data(false, 3, data(1), 1);
+      peer.acceptFrame(); // connection WINDOW UPDATE
+      peer.acceptFrame(); // stream WINDOW UPDATE
+    }
+    peer.sendFrame().data(true, 3, data(0), 0);
+    peer.play();
+
+    // Play it back.
+    SpdyConnection connection = connection(peer, HTTP_2);
+    connection.okHttpSettings.set(Settings.INITIAL_WINDOW_SIZE, 0, windowSize);
+    SpdyStream stream = connection.newStream(headerEntries("b", "banana"), false, true);
+    assertEquals(0, stream.unacknowledgedBytesRead);
+    assertEquals(headerEntries("a", "android"), stream.getResponseHeaders());
+    Source in = stream.getSource();
+    Buffer buffer = new Buffer();
+    buffer.writeAll(in);
+    assertEquals(-1, in.read(buffer, 1));
+    assertEquals(150, buffer.size());
+
+    MockSpdyPeer.InFrame synStream = peer.takeFrame();
+    assertEquals(TYPE_HEADERS, synStream.type);
+    for (int i = 0; i < 3; i++) {
+      List<Integer> windowUpdateStreamIds = new ArrayList<>(2);
+      for (int j = 0; j < 2; j++) {
+        MockSpdyPeer.InFrame windowUpdate = peer.takeFrame();
+        assertEquals(TYPE_WINDOW_UPDATE, windowUpdate.type);
+        windowUpdateStreamIds.add(windowUpdate.streamId);
+        assertEquals(windowUpdateThreshold, windowUpdate.windowSizeIncrement);
+      }
+      assertTrue(windowUpdateStreamIds.contains(0)); // connection
+      assertTrue(windowUpdateStreamIds.contains(3)); // stream
+    }
+  }
+
+  private Buffer data(int byteCount) {
+    return new Buffer().write(new byte[byteCount]);
+  }
+
+  @Test public void serverSendsEmptyDataClientDoesntSendWindowUpdateHttp2() throws Exception {
+    peer.setVariantAndClient(HTTP_2, false);
+
+    // Write the mocking script.
+    peer.acceptFrame(); // SYN_STREAM
+    peer.sendFrame().synReply(false, 3, headerEntries("a", "android"));
+    peer.sendFrame().data(true, 3, data(0), 0);
+    peer.play();
+
+    // Play it back.
+    SpdyConnection connection = connection(peer, HTTP_2);
+    SpdyStream client = connection.newStream(headerEntries("b", "banana"), false, true);
+    assertEquals(-1, client.getSource().read(new Buffer(), 1));
+
+    // Verify the peer received what was expected.
+    MockSpdyPeer.InFrame synStream = peer.takeFrame();
+    assertEquals(TYPE_HEADERS, synStream.type);
+    assertEquals(3, peer.frameCount());
+  }
+
+  @Test public void clientSendsEmptyDataServerDoesntSendWindowUpdateHttp2() throws Exception {
+    peer.setVariantAndClient(HTTP_2, false);
+
+    // Write the mocking script.
+    peer.acceptFrame(); // SYN_STREAM
+    peer.acceptFrame(); // DATA
+    peer.sendFrame().synReply(false, 3, headerEntries("a", "android"));
+    peer.play();
+
+    // Play it back.
+    SpdyConnection connection = connection(peer, HTTP_2);
+    SpdyStream client = connection.newStream(headerEntries("b", "banana"), true, true);
+    BufferedSink out = Okio.buffer(client.getSink());
+    out.write(Util.EMPTY_BYTE_ARRAY);
+    out.flush();
+    out.close();
+
+    // Verify the peer received what was expected.
+    assertEquals(TYPE_HEADERS, peer.takeFrame().type);
+    assertEquals(TYPE_DATA, peer.takeFrame().type);
+    assertEquals(3, peer.frameCount());
+  }
+
+  @Test public void maxFrameSizeHonored() throws Exception {
+    peer.setVariantAndClient(HTTP_2, false);
+
+    byte[] buff = new byte[peer.maxOutboundDataLength() + 1];
+    Arrays.fill(buff, (byte) '*');
+
+    // write the mocking script
+    peer.acceptFrame(); // SYN_STREAM
+    peer.sendFrame().synReply(false, 3, headerEntries("a", "android"));
+    peer.acceptFrame(); // DATA
+    peer.acceptFrame(); // DATA
+    peer.play();
+
+    // play it back
+    SpdyConnection connection = connection(peer, HTTP_2);
+    SpdyStream stream = connection.newStream(headerEntries("b", "banana"), true, true);
+    BufferedSink out = Okio.buffer(stream.getSink());
+    out.write(buff);
+    out.flush();
+    out.close();
+
+    MockSpdyPeer.InFrame synStream = peer.takeFrame();
+    assertEquals(TYPE_HEADERS, synStream.type);
+    MockSpdyPeer.InFrame data = peer.takeFrame();
+    assertEquals(peer.maxOutboundDataLength(), data.data.length);
+    data = peer.takeFrame();
+    assertEquals(1, data.data.length);
+  }
+
+  @Test public void pushPromiseStream() throws Exception {
+    peer.setVariantAndClient(HTTP_2, false);
+
+    // write the mocking script
+    peer.acceptFrame(); // SYN_STREAM
+    peer.sendFrame().synReply(false, 3, headerEntries("a", "android"));
+    final List<Header> expectedRequestHeaders = Arrays.asList(
+        new Header(Header.TARGET_METHOD, "GET"),
+        new Header(Header.TARGET_SCHEME, "https"),
+        new Header(Header.TARGET_AUTHORITY, "squareup.com"),
+        new Header(Header.TARGET_PATH, "/cached")
+    );
+    peer.sendFrame().pushPromise(3, 2, expectedRequestHeaders);
+    final List<Header> expectedResponseHeaders = Arrays.asList(
+        new Header(Header.RESPONSE_STATUS, "200")
+    );
+    peer.sendFrame().synReply(true, 2, expectedResponseHeaders);
+    peer.sendFrame().data(true, 3, data(0), 0);
+    peer.play();
+
+    RecordingPushObserver observer = new RecordingPushObserver();
+
+    // play it back
+    SpdyConnection connection = connectionBuilder(peer, HTTP_2)
+        .pushObserver(observer).build();
+    SpdyStream client = connection.newStream(headerEntries("b", "banana"), false, true);
+    assertEquals(-1, client.getSource().read(new Buffer(), 1));
+
+    // verify the peer received what was expected
+    assertEquals(TYPE_HEADERS, peer.takeFrame().type);
+
+    assertEquals(expectedRequestHeaders, observer.takeEvent());
+    assertEquals(expectedResponseHeaders, observer.takeEvent());
+  }
+
+  @Test public void doublePushPromise() throws Exception {
+    peer.setVariantAndClient(HTTP_2, false);
+
+    // write the mocking script
+    peer.sendFrame().pushPromise(3, 2, headerEntries("a", "android"));
+    peer.acceptFrame(); // SYN_REPLY
+    peer.sendFrame().pushPromise(3, 2, headerEntries("b", "banana"));
+    peer.acceptFrame(); // RST_STREAM
+    peer.play();
+
+    // play it back
+    SpdyConnection connection = connectionBuilder(peer, HTTP_2).build();
+    connection.newStream(headerEntries("b", "banana"), false, true);
+
+    // verify the peer received what was expected
+    assertEquals(TYPE_HEADERS, peer.takeFrame().type);
+    assertEquals(PROTOCOL_ERROR, peer.takeFrame().errorCode);
+  }
+
+  @Test public void pushPromiseStreamsAutomaticallyCancel() throws Exception {
+    peer.setVariantAndClient(HTTP_2, false);
+
+    // write the mocking script
+    peer.sendFrame().pushPromise(3, 2, Arrays.asList(
+        new Header(Header.TARGET_METHOD, "GET"),
+        new Header(Header.TARGET_SCHEME, "https"),
+        new Header(Header.TARGET_AUTHORITY, "squareup.com"),
+        new Header(Header.TARGET_PATH, "/cached")
+    ));
+    peer.sendFrame().synReply(true, 2, Arrays.asList(
+        new Header(Header.RESPONSE_STATUS, "200")
+    ));
+    peer.acceptFrame(); // RST_STREAM
+    peer.play();
+
+    // play it back
+    connectionBuilder(peer, HTTP_2)
+        .pushObserver(PushObserver.CANCEL).build();
+
+    // verify the peer received what was expected
+    MockSpdyPeer.InFrame rstStream = peer.takeFrame();
+    assertEquals(TYPE_RST_STREAM, rstStream.type);
+    assertEquals(2, rstStream.streamId);
+    assertEquals(CANCEL, rstStream.errorCode);
+  }
+
+  private SpdyConnection sendHttp2SettingsAndCheckForAck(boolean client, Settings settings)
+      throws IOException, InterruptedException {
+    peer.setVariantAndClient(HTTP_2, client);
+    peer.sendFrame().settings(settings);
+    peer.acceptFrame(); // ACK
+    peer.acceptFrame(); // PING
+    peer.sendFrame().ping(true, 1, 0);
+    peer.play();
+
+    // play it back
+    SpdyConnection connection = connection(peer, HTTP_2);
+
+    // verify the peer received the ACK
+    MockSpdyPeer.InFrame ackFrame = peer.takeFrame();
+    assertEquals(TYPE_SETTINGS, ackFrame.type);
+    assertEquals(0, ackFrame.streamId);
+    assertTrue(ackFrame.ack);
+
+    connection.ping().roundTripTime(); // Ensure that settings have been applied before returning.
+    return connection;
+  }
+
+  private SpdyConnection connection(MockSpdyPeer peer, Variant variant) throws IOException {
+    return connectionBuilder(peer, variant).build();
+  }
+
+  private SpdyConnection.Builder connectionBuilder(MockSpdyPeer peer, Variant variant)
+      throws IOException {
+    return new SpdyConnection.Builder(true, peer.openSocket())
+        .pushObserver(IGNORE)
+        .protocol(variant.getProtocol());
+  }
+
+  static final PushObserver IGNORE = new PushObserver() {
+
+    @Override public boolean onRequest(int streamId, List<Header> requestHeaders) {
+      return false;
+    }
+
+    @Override public boolean onHeaders(int streamId, List<Header> responseHeaders, boolean last) {
+      return false;
+    }
+
+    @Override public boolean onData(int streamId, BufferedSource source, int byteCount,
+        boolean last) throws IOException {
+      source.skip(byteCount);
+      return false;
+    }
+
+    @Override public void onReset(int streamId, ErrorCode errorCode) {
+    }
+  };
+
+  private static class RecordingPushObserver implements PushObserver {
+    final List<Object> events = new ArrayList<>();
+
+    public synchronized Object takeEvent() throws InterruptedException {
+      while (events.isEmpty()) {
+        wait();
+      }
+      return events.remove(0);
+    }
+
+    @Override public synchronized boolean onRequest(int streamId, List<Header> requestHeaders) {
+      assertEquals(2, streamId);
+      events.add(requestHeaders);
+      notifyAll();
+      return false;
+    }
+
+    @Override public synchronized boolean onHeaders(
+        int streamId, List<Header> responseHeaders, boolean last) {
+      assertEquals(2, streamId);
+      assertTrue(last);
+      events.add(responseHeaders);
+      notifyAll();
+      return false;
+    }
+
+    @Override public synchronized boolean onData(
+        int streamId, BufferedSource source, int byteCount, boolean last) {
+      events.add(new AssertionError("onData"));
+      notifyAll();
+      return false;
+    }
+
+    @Override public synchronized void onReset(int streamId, ErrorCode errorCode) {
+      events.add(new AssertionError("onReset"));
+      notifyAll();
+    }
+  }
+}
diff --git a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/spdy/HuffmanTest.java b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/spdy/HuffmanTest.java
index 6206b7efbd..222d23e150 100644
--- a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/spdy/HuffmanTest.java
+++ b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/spdy/HuffmanTest.java
@@ -43,18 +43,13 @@
   }
 
   private void assertRoundTrip(byte[] buf) throws IOException {
-    assertRoundTrip(Huffman.Codec.REQUEST, buf);
-    assertRoundTrip(Huffman.Codec.RESPONSE, buf);
-  }
-
-  private static void assertRoundTrip(Huffman.Codec codec, byte[] buf) throws IOException {
     ByteArrayOutputStream baos = new ByteArrayOutputStream();
     DataOutputStream dos = new DataOutputStream(baos);
 
-    codec.encode(buf, dos);
-    assertEquals(baos.size(), codec.encodedLength(buf));
+    Huffman.get().encode(buf, dos);
+    assertEquals(baos.size(), Huffman.get().encodedLength(buf));
 
-    byte[] decodedBytes = codec.decode(baos.toByteArray());
+    byte[] decodedBytes = Huffman.get().decode(baos.toByteArray());
     assertTrue(Arrays.equals(buf, decodedBytes));
   }
 }
diff --git a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/spdy/MockSpdyPeer.java b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/spdy/MockSpdyPeer.java
index a44af612f4..3dac6d32fe 100644
--- a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/spdy/MockSpdyPeer.java
+++ b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/spdy/MockSpdyPeer.java
@@ -30,9 +30,9 @@
 import java.util.concurrent.ExecutorService;
 import java.util.concurrent.Executors;
 import java.util.concurrent.LinkedBlockingQueue;
+import okio.Buffer;
 import okio.BufferedSource;
 import okio.ByteString;
-import okio.OkBuffer;
 import okio.Okio;
 
 /** Replays prerecorded outgoing frames and records incoming frames. */
@@ -40,12 +40,12 @@
   private int frameCount = 0;
   private boolean client = false;
   private Variant variant = new Spdy3();
-  private final OkBuffer bytesOut = new OkBuffer();
+  private final Buffer bytesOut = new Buffer();
   private FrameWriter frameWriter = variant.newWriter(bytesOut, client);
-  private final List<OutFrame> outFrames = new ArrayList<OutFrame>();
-  private final BlockingQueue<InFrame> inFrames = new LinkedBlockingQueue<InFrame>();
+  private final List<OutFrame> outFrames = new ArrayList<>();
+  private final BlockingQueue<InFrame> inFrames = new LinkedBlockingQueue<>();
   private int port;
-  private final ExecutorService executor = Executors.newCachedThreadPool(
+  private final ExecutorService executor = Executors.newSingleThreadExecutor(
       Util.threadFactory("MockSpdyPeer", false));
   private ServerSocket serverSocket;
   private Socket socket;
@@ -63,6 +63,11 @@ public void acceptFrame() {
     frameCount++;
   }
 
+  /** Maximum length of an outbound data frame. */
+  public int maxOutboundDataLength() {
+    return frameWriter.maxDataLength();
+  }
+
   /** Count of frames sent or received. */
   public int frameCount() {
     return frameCount;
@@ -121,7 +126,7 @@ private void readAndWriteFrames() throws IOException {
     FrameReader reader = variant.newReader(Okio.buffer(Okio.source(in)), client);
 
     Iterator<OutFrame> outFramesIterator = outFrames.iterator();
-    byte[] outBytes = bytesOut.readByteString(bytesOut.size()).toByteArray();
+    byte[] outBytes = bytesOut.readByteArray();
     OutFrame nextOutFrame = null;
 
     for (int i = 0; i < frameCount; i++) {
@@ -192,7 +197,6 @@ private OutFrame(int sequence, long start, int truncateToLength) {
     public boolean inFinished;
     public int streamId;
     public int associatedStreamId;
-    public int priority;
     public ErrorCode errorCode;
     public long windowSizeIncrement;
     public List<Header> headerBlock;
@@ -222,15 +226,13 @@ public InFrame(int sequence, FrameReader reader) {
     }
 
     @Override public void headers(boolean outFinished, boolean inFinished, int streamId,
-        int associatedStreamId, int priority, List<Header> headerBlock,
-        HeadersMode headersMode) {
+        int associatedStreamId, List<Header> headerBlock, HeadersMode headersMode) {
       if (this.type != -1) throw new IllegalStateException();
       this.type = Spdy3.TYPE_HEADERS;
       this.outFinished = outFinished;
       this.inFinished = inFinished;
       this.streamId = streamId;
       this.associatedStreamId = associatedStreamId;
-      this.priority = priority;
       this.headerBlock = headerBlock;
       this.headersMode = headersMode;
     }
@@ -274,16 +276,22 @@ public InFrame(int sequence, FrameReader reader) {
       this.windowSizeIncrement = windowSizeIncrement;
     }
 
-    @Override public void priority(int streamId, int priority) {
+    @Override public void priority(int streamId, int streamDependency, int weight,
+        boolean exclusive) {
       throw new UnsupportedOperationException();
     }
 
     @Override
     public void pushPromise(int streamId, int associatedStreamId, List<Header> headerBlock) {
-      this.type = Http20Draft09.TYPE_PUSH_PROMISE;
+      this.type = Http20Draft14.TYPE_PUSH_PROMISE;
       this.streamId = streamId;
       this.associatedStreamId = associatedStreamId;
       this.headerBlock = headerBlock;
     }
+
+    @Override public void alternateService(int streamId, String origin, ByteString protocol,
+        String host, int port, long maxAge) {
+      throw new UnsupportedOperationException();
+    }
   }
 }
diff --git a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/spdy/SettingsTest.java b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/spdy/SettingsTest.java
index 44459b8c9a..f9f9efa32d 100644
--- a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/spdy/SettingsTest.java
+++ b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/spdy/SettingsTest.java
@@ -17,6 +17,7 @@
 
 import org.junit.Test;
 
+import static com.squareup.okhttp.internal.spdy.Settings.DEFAULT_INITIAL_WINDOW_SIZE;
 import static com.squareup.okhttp.internal.spdy.Settings.DOWNLOAD_BANDWIDTH;
 import static com.squareup.okhttp.internal.spdy.Settings.DOWNLOAD_RETRANS_RATE;
 import static com.squareup.okhttp.internal.spdy.Settings.MAX_CONCURRENT_STREAMS;
@@ -36,7 +37,7 @@
   @Test public void setFields() {
     Settings settings = new Settings();
 
-    // WARNING: clash on flags between spdy/3 and http/2!
+    // WARNING: clash on flags between spdy/3 and HTTP/2!
     assertEquals(-3, settings.getUploadBandwidth(-3));
     assertEquals(-1, settings.getHeaderTableSize());
     settings.set(UPLOAD_BANDWIDTH, 0, 42);
@@ -44,13 +45,14 @@
     settings.set(Settings.HEADER_TABLE_SIZE, 0, 8096);
     assertEquals(8096, settings.getHeaderTableSize());
 
-    // WARNING: clash on flags between spdy/3 and http/2!
-    assertEquals(-3, settings.getDownloadBandwidth(-3));
+    // WARNING: clash on flags between spdy/3 and HTTP/2!
     assertEquals(true, settings.getEnablePush(true));
+    settings.set(Settings.ENABLE_PUSH, 0, 1);
+    assertEquals(true, settings.getEnablePush(false));
+    settings.clear();
+    assertEquals(-3, settings.getDownloadBandwidth(-3));
     settings.set(DOWNLOAD_BANDWIDTH, 0, 53);
     assertEquals(53, settings.getDownloadBandwidth(-3));
-    settings.set(Settings.ENABLE_PUSH, 0, 0);
-    assertEquals(false, settings.getEnablePush(true));
 
     assertEquals(-3, settings.getRoundTripTime(-3));
     settings.set(Settings.ROUND_TRIP_TIME, 0, 64);
@@ -60,17 +62,28 @@
     settings.set(MAX_CONCURRENT_STREAMS, 0, 75);
     assertEquals(75, settings.getMaxConcurrentStreams(-3));
 
+    // WARNING: clash on flags between spdy/3 and HTTP/2!
     assertEquals(-3, settings.getCurrentCwnd(-3));
     settings.set(Settings.CURRENT_CWND, 0, 86);
     assertEquals(86, settings.getCurrentCwnd(-3));
+    settings.clear();
+    assertEquals(16384, settings.getMaxFrameSize(16384));
+    settings.set(Settings.MAX_FRAME_SIZE, 0, 16777215);
+    assertEquals(16777215, settings.getMaxFrameSize(16384));
 
+    // WARNING: clash on flags between spdy/3 and HTTP/2!
     assertEquals(-3, settings.getDownloadRetransRate(-3));
     settings.set(DOWNLOAD_RETRANS_RATE, 0, 97);
     assertEquals(97, settings.getDownloadRetransRate(-3));
+    settings.clear();
+    assertEquals(-1, settings.getMaxHeaderListSize(-1));
+    settings.set(Settings.MAX_HEADER_LIST_SIZE, 0, 16777215);
+    assertEquals(16777215, settings.getMaxHeaderListSize(-1));
 
-    assertEquals(-1, settings.getInitialWindowSize());
+    assertEquals(DEFAULT_INITIAL_WINDOW_SIZE,
+        settings.getInitialWindowSize(DEFAULT_INITIAL_WINDOW_SIZE));
     settings.set(Settings.INITIAL_WINDOW_SIZE, 0, 108);
-    assertEquals(108, settings.getInitialWindowSize());
+    assertEquals(108, settings.getInitialWindowSize(DEFAULT_INITIAL_WINDOW_SIZE));
 
     assertEquals(-3, settings.getClientCertificateVectorSize(-3));
     settings.set(Settings.CLIENT_CERTIFICATE_VECTOR_SIZE, 0, 117);
diff --git a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/spdy/SpdyConnectionTest.java b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/spdy/Spdy3ConnectionTest.java
similarity index 71%
rename from okhttp-tests/src/test/java/com/squareup/okhttp/internal/spdy/SpdyConnectionTest.java
rename to okhttp-tests/src/test/java/com/squareup/okhttp/internal/spdy/Spdy3ConnectionTest.java
index 64b81ced14..f8a42ebb29 100644
--- a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/spdy/SpdyConnectionTest.java
+++ b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/spdy/Spdy3ConnectionTest.java
@@ -23,11 +23,11 @@
 import java.util.List;
 import java.util.concurrent.TimeUnit;
 import java.util.concurrent.atomic.AtomicInteger;
+import okio.Buffer;
 import okio.BufferedSink;
-import okio.BufferedSource;
 import okio.ByteString;
-import okio.OkBuffer;
 import okio.Okio;
+import okio.Sink;
 import okio.Source;
 import org.junit.After;
 import org.junit.Test;
@@ -39,23 +39,21 @@
 import static com.squareup.okhttp.internal.spdy.ErrorCode.PROTOCOL_ERROR;
 import static com.squareup.okhttp.internal.spdy.ErrorCode.REFUSED_STREAM;
 import static com.squareup.okhttp.internal.spdy.ErrorCode.STREAM_IN_USE;
+import static com.squareup.okhttp.internal.spdy.Settings.DEFAULT_INITIAL_WINDOW_SIZE;
 import static com.squareup.okhttp.internal.spdy.Settings.PERSIST_VALUE;
 import static com.squareup.okhttp.internal.spdy.Spdy3.TYPE_DATA;
 import static com.squareup.okhttp.internal.spdy.Spdy3.TYPE_GOAWAY;
 import static com.squareup.okhttp.internal.spdy.Spdy3.TYPE_HEADERS;
 import static com.squareup.okhttp.internal.spdy.Spdy3.TYPE_PING;
 import static com.squareup.okhttp.internal.spdy.Spdy3.TYPE_RST_STREAM;
-import static com.squareup.okhttp.internal.spdy.Spdy3.TYPE_SETTINGS;
 import static com.squareup.okhttp.internal.spdy.Spdy3.TYPE_WINDOW_UPDATE;
-import static com.squareup.okhttp.internal.spdy.SpdyConnection.INITIAL_WINDOW_SIZE;
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertFalse;
 import static org.junit.Assert.assertTrue;
 import static org.junit.Assert.fail;
 
-public final class SpdyConnectionTest {
+public final class Spdy3ConnectionTest {
   private static final Variant SPDY3 = new Spdy3();
-  private static final Variant HTTP_20_DRAFT_09 = new Http20Draft09();
   private final MockSpdyPeer peer = new MockSpdyPeer();
 
   @After public void tearDown() throws Exception {
@@ -67,7 +65,7 @@
     peer.acceptFrame(); // SYN_STREAM
     peer.sendFrame()
         .synReply(false, 1, headerEntries("a", "android"));
-    peer.sendFrame().data(true, 1, new OkBuffer().writeUtf8("robot"));
+    peer.sendFrame().data(true, 1, new Buffer().writeUtf8("robot"), 5);
     peer.acceptFrame(); // DATA
     peer.play();
 
@@ -97,12 +95,15 @@
   @Test public void headersOnlyStreamIsClosedAfterReplyHeaders() throws Exception {
     peer.acceptFrame(); // SYN_STREAM
     peer.sendFrame().synReply(false, 1, headerEntries("b", "banana"));
+    peer.acceptFrame(); // PING
+    peer.sendFrame().ping(true, 1, 0);
     peer.play();
 
     SpdyConnection connection = connection(peer, SPDY3);
     SpdyStream stream = connection.newStream(headerEntries("a", "android"), false, false);
     assertEquals(1, connection.openStreamCount());
     assertEquals(headerEntries("b", "banana"), stream.getResponseHeaders());
+    connection.ping().roundTripTime(); // Ensure that inFinished has been received.
     assertEquals(0, connection.openStreamCount());
   }
 
@@ -139,7 +140,7 @@
         ":version", "HTTP/1.1",
         "content-type", "text/html");
     // write the mocking script
-    peer.sendFrame().synStream(false, false, 2, 0, 5, 129, pushHeaders);
+    peer.sendFrame().synStream(false, false, 2, 0, pushHeaders);
     peer.acceptFrame(); // SYN_REPLY
     peer.play();
 
@@ -150,7 +151,6 @@
         receiveCount.incrementAndGet();
         assertEquals(pushHeaders, stream.getRequestHeaders());
         assertEquals(null, stream.getErrorCode());
-        assertEquals(5, stream.getPriority());
         stream.reply(headerEntries("b", "banana"), true);
       }
     };
@@ -168,7 +168,7 @@
 
   @Test public void replyWithNoData() throws Exception {
     // write the mocking script
-    peer.sendFrame().synStream(false, false, 2, 0, 0, 0, headerEntries("a", "android"));
+    peer.sendFrame().synStream(false, false, 2, 0, headerEntries("a", "android"));
     peer.acceptFrame(); // SYN_REPLY
     peer.play();
 
@@ -209,26 +209,6 @@
     assertTrue(ping.ack);
   }
 
-  @Test public void serverPingsClientHttp2() throws Exception {
-    peer.setVariantAndClient(HTTP_20_DRAFT_09, false);
-
-    // write the mocking script
-    peer.sendFrame().ping(false, 2, 3);
-    peer.acceptFrame(); // PING
-    peer.play();
-
-    // play it back
-    connection(peer, HTTP_20_DRAFT_09);
-
-    // verify the peer received what was expected
-    MockSpdyPeer.InFrame ping = peer.takeFrame();
-    assertEquals(TYPE_PING, ping.type);
-    assertEquals(0, ping.streamId);
-    assertEquals(2, ping.payload1);
-    assertEquals(3, ping.payload2);
-    assertTrue(ping.ack);
-  }
-
   @Test public void clientPingsServer() throws Exception {
     // write the mocking script
     peer.acceptFrame(); // PING
@@ -249,64 +229,6 @@
     assertFalse(pingFrame.ack);
   }
 
-  @Test public void clientPingsServerHttp2() throws Exception {
-    peer.setVariantAndClient(HTTP_20_DRAFT_09, false);
-
-    // write the mocking script
-    peer.acceptFrame(); // PING
-    peer.sendFrame().ping(true, 1, 5);
-    peer.play();
-
-    // play it back
-    SpdyConnection connection = connection(peer, HTTP_20_DRAFT_09);
-    Ping ping = connection.ping();
-    assertTrue(ping.roundTripTime() > 0);
-    assertTrue(ping.roundTripTime() < TimeUnit.SECONDS.toNanos(1));
-
-    // verify the peer received what was expected
-    MockSpdyPeer.InFrame pingFrame = peer.takeFrame();
-    assertEquals(0, pingFrame.streamId);
-    assertEquals(1, pingFrame.payload1);
-    assertEquals(0x4f4b6f6b, pingFrame.payload2); // connection.ping() sets this.
-    assertFalse(pingFrame.ack);
-  }
-
-  @Test public void peerHttp2ServerLowersInitialWindowSize() throws Exception {
-    peer.setVariantAndClient(HTTP_20_DRAFT_09, false);
-
-    Settings initial = new Settings();
-    initial.set(Settings.INITIAL_WINDOW_SIZE, PERSIST_VALUE, 1684);
-    Settings shouldntImpactConnection = new Settings();
-    shouldntImpactConnection.set(Settings.INITIAL_WINDOW_SIZE, PERSIST_VALUE, 3368);
-
-    peer.sendFrame().settings(initial);
-    peer.acceptFrame(); // ACK
-    peer.sendFrame().settings(shouldntImpactConnection);
-    peer.acceptFrame(); // ACK 2
-    peer.acceptFrame(); // HEADERS
-    peer.play();
-
-    SpdyConnection connection = connection(peer, HTTP_20_DRAFT_09);
-
-    // verify the peer received the ACK
-    MockSpdyPeer.InFrame ackFrame = peer.takeFrame();
-    assertEquals(TYPE_SETTINGS, ackFrame.type);
-    assertEquals(0, ackFrame.streamId);
-    assertTrue(ackFrame.ack);
-    ackFrame = peer.takeFrame();
-    assertEquals(TYPE_SETTINGS, ackFrame.type);
-    assertEquals(0, ackFrame.streamId);
-    assertTrue(ackFrame.ack);
-
-    // This stream was created *after* the connection settings were adjusted.
-    SpdyStream stream = connection.newStream(headerEntries("a", "android"), false, true);
-
-    assertEquals(3368, connection.peerSettings.getInitialWindowSize());
-    assertEquals(1684, connection.bytesLeftInWriteWindow); // initial wasn't affected.
-    // New Stream is has the most recent initial window size.
-    assertEquals(3368, stream.bytesLeftInWriteWindow);
-  }
-
   @Test public void unexpectedPingIsNotReturned() throws Exception {
     // write the mocking script
     peer.sendFrame().ping(false, 2, 0);
@@ -326,35 +248,6 @@
     assertEquals(4, ping4.payload1);
   }
 
-  @Test public void peerHttp2ServerZerosCompressionTable() throws Exception {
-    boolean client = false; // Peer is server, so we are client.
-    Settings settings = new Settings();
-    settings.set(Settings.HEADER_TABLE_SIZE, PERSIST_VALUE, 0);
-
-    SpdyConnection connection = sendHttp2SettingsAndCheckForAck(client, settings);
-
-    // verify the peer's settings were read and applied.
-    synchronized (connection) {
-      assertEquals(0, connection.peerSettings.getHeaderTableSize());
-      Http20Draft09.Reader frameReader = (Http20Draft09.Reader) connection.frameReader;
-      assertEquals(0, frameReader.hpackReader.maxHeaderTableByteCount());
-      // TODO: when supported, check the frameWriter's compression table is unaffected.
-    }
-  }
-
-  @Test public void peerHttp2ClientDisablesPush() throws Exception {
-    boolean client = false; // Peer is client, so we are server.
-    Settings settings = new Settings();
-    settings.set(Settings.ENABLE_PUSH, 0, 0); // The peer client disables push.
-
-    SpdyConnection connection = sendHttp2SettingsAndCheckForAck(client, settings);
-
-    // verify the peer's settings were read and applied.
-    synchronized (connection) {
-      assertFalse(connection.peerSettings.getEnablePush(true));
-    }
-  }
-
   @Test public void serverSendsSettingsToClient() throws Exception {
     // write the mocking script
     Settings settings = new Settings();
@@ -405,9 +298,38 @@
     }
   }
 
+  @Test public void clearSettingsBeforeMerge() throws Exception {
+    // write the mocking script
+    Settings settings1 = new Settings();
+    settings1.set(Settings.UPLOAD_BANDWIDTH, PERSIST_VALUE, 100);
+    settings1.set(Settings.DOWNLOAD_BANDWIDTH, PERSIST_VALUE, 200);
+    settings1.set(Settings.DOWNLOAD_RETRANS_RATE, 0, 300);
+    peer.sendFrame().settings(settings1);
+    peer.sendFrame().ping(false, 2, 0);
+    peer.acceptFrame();
+    peer.play();
+
+    // play it back
+    SpdyConnection connection = connection(peer, SPDY3);
+
+    peer.takeFrame(); // Guarantees that the Settings frame has been processed.
+
+    // fake a settings frame with clear flag set.
+    Settings settings2 = new Settings();
+    settings2.set(Settings.MAX_CONCURRENT_STREAMS, PERSIST_VALUE, 600);
+    connection.readerRunnable.settings(true, settings2);
+
+    synchronized (connection) {
+      assertEquals(-1, connection.peerSettings.getUploadBandwidth(-1));
+      assertEquals(-1, connection.peerSettings.getDownloadBandwidth(-1));
+      assertEquals(-1, connection.peerSettings.getDownloadRetransRate(-1));
+      assertEquals(600, connection.peerSettings.getMaxConcurrentStreams(-1));
+    }
+  }
+
   @Test public void bogusDataFrameDoesNotDisruptConnection() throws Exception {
     // write the mocking script
-    peer.sendFrame().data(true, 41, new OkBuffer().writeUtf8("bogus"));
+    peer.sendFrame().data(true, 41, new Buffer().writeUtf8("bogus"), 5);
     peer.acceptFrame(); // RST_STREAM
     peer.sendFrame().ping(false, 2, 0);
     peer.acceptFrame(); // PING
@@ -546,7 +468,7 @@
     BufferedSink out = Okio.buffer(stream.getSink());
     in.close();
     try {
-      in.read(new OkBuffer(), 1);
+      in.read(new Buffer(), 1);
       fail();
     } catch (IOException expected) {
       assertEquals("stream closed", expected.getMessage());
@@ -590,7 +512,7 @@
     BufferedSink out = Okio.buffer(stream.getSink());
     source.close();
     try {
-      source.read(new OkBuffer(), 1);
+      source.read(new Buffer(), 1);
       fail();
     } catch (IOException expected) {
       assertEquals("stream closed", expected.getMessage());
@@ -622,7 +544,9 @@
     // write the mocking script
     peer.acceptFrame(); // SYN_STREAM
     peer.sendFrame().synReply(false, 1, headerEntries("b", "banana"));
-    peer.sendFrame().data(true, 1, new OkBuffer().writeUtf8("square"));
+    peer.sendFrame().data(true, 1, new Buffer().writeUtf8("square"), 6);
+    peer.acceptFrame(); // PING
+    peer.sendFrame().ping(true, 1, 0);
     peer.play();
 
     // play it back
@@ -630,6 +554,7 @@
     SpdyStream stream = connection.newStream(headerEntries("a", "android"), false, true);
     Source source = stream.getSource();
     assertStreamData("square", source);
+    connection.ping().roundTripTime(); // Ensure that inFinished has been received.
     assertEquals(0, connection.openStreamCount());
 
     // verify the peer received what was expected
@@ -656,7 +581,7 @@
     assertEquals(headerEntries("a", "android"), stream.getResponseHeaders());
     connection.ping().roundTripTime(); // Ensure that the 2nd SYN REPLY has been received.
     try {
-      stream.getSource().read(new OkBuffer(), 1);
+      stream.getSource().read(new Buffer(), 1);
       fail();
     } catch (IOException expected) {
       assertEquals("stream was reset: STREAM_IN_USE", expected.getMessage());
@@ -676,9 +601,9 @@
 
   @Test public void remoteDoubleSynStream() throws Exception {
     // write the mocking script
-    peer.sendFrame().synStream(false, false, 2, 0, 0, 0, headerEntries("a", "android"));
+    peer.sendFrame().synStream(false, false, 2, 0, headerEntries("a", "android"));
     peer.acceptFrame(); // SYN_REPLY
-    peer.sendFrame().synStream(false, false, 2, 0, 0, 0, headerEntries("b", "banana"));
+    peer.sendFrame().synStream(false, false, 2, 0, headerEntries("b", "banana"));
     peer.acceptFrame(); // RST_STREAM
     peer.play();
 
@@ -709,8 +634,8 @@
     // write the mocking script
     peer.acceptFrame(); // SYN_STREAM
     peer.sendFrame().synReply(false, 1, headerEntries("a", "android"));
-    peer.sendFrame().data(true, 1, new OkBuffer().writeUtf8("robot"));
-    peer.sendFrame().data(true, 1, new OkBuffer().writeUtf8("c3po")); // Ignored.
+    peer.sendFrame().data(true, 1, new Buffer().writeUtf8("robot"), 5);
+    peer.sendFrame().data(true, 1, new Buffer().writeUtf8("c3po"), 4); // Ignored.
     peer.sendFrame().ping(false, 2, 0); // Ping just to make sure the stream was fastforwarded.
     peer.acceptFrame(); // PING
     peer.play();
@@ -731,10 +656,11 @@
   }
 
   @Test public void clientDoesNotLimitFlowControl() throws Exception {
+    int dataLength = 64 * 1024 + 1;
     // write the mocking script
     peer.acceptFrame(); // SYN_STREAM
     peer.sendFrame().synReply(false, 1, headerEntries("b", "banana"));
-    peer.sendFrame().data(false, 1, new OkBuffer().write(new byte[64 * 1024 + 1]));
+    peer.sendFrame().data(false, 1, new Buffer().write(new byte[dataLength]), dataLength);
     peer.sendFrame().ping(false, 2, 0); // Ping just to make sure the stream was fastforwarded.
     peer.acceptFrame(); // PING
     peer.play();
@@ -783,15 +709,7 @@
 
 
   @Test public void receiveGoAway() throws Exception {
-    receiveGoAway(SPDY3);
-  }
-
-  @Test public void receiveGoAwayHttp2() throws Exception {
-    receiveGoAway(HTTP_20_DRAFT_09);
-  }
-
-  private void receiveGoAway(Variant variant) throws Exception {
-    peer.setVariantAndClient(variant, false);
+    peer.setVariantAndClient(SPDY3, false);
 
     // write the mocking script
     peer.acceptFrame(); // SYN_STREAM 1
@@ -803,10 +721,10 @@ private void receiveGoAway(Variant variant) throws Exception {
     peer.play();
 
     // play it back
-    SpdyConnection connection = connection(peer, variant);
+    SpdyConnection connection = connection(peer, SPDY3);
     SpdyStream stream1 = connection.newStream(headerEntries("a", "android"), true, true);
     SpdyStream stream2 = connection.newStream(headerEntries("b", "banana"), true, true);
-    connection.ping().roundTripTime(); // Ensure that the GO_AWAY has been received.
+    connection.ping().roundTripTime(); // Ensure the GO_AWAY that resets stream2 has been received.
     BufferedSink sink1 = Okio.buffer(stream1.getSink());
     BufferedSink sink2 = Okio.buffer(stream2.getSink());
     sink1.writeUtf8("abc");
@@ -825,6 +743,8 @@ private void receiveGoAway(Variant variant) throws Exception {
     } catch (IOException expected) {
       assertEquals("shutdown", expected.getMessage());
     }
+    assertTrue(stream1.isOpen());
+    assertFalse(stream2.isOpen());
     assertEquals(1, connection.openStreamCount());
 
     // verify the peer received what was expected
@@ -845,7 +765,7 @@ private void receiveGoAway(Variant variant) throws Exception {
     peer.acceptFrame(); // SYN_STREAM 1
     peer.acceptFrame(); // GOAWAY
     peer.acceptFrame(); // PING
-    peer.sendFrame().synStream(false, false, 2, 0, 0, 0, headerEntries("b", "b")); // Should be ignored!
+    peer.sendFrame().synStream(false, false, 2, 0, headerEntries("b", "b")); // Should be ignored!
     peer.sendFrame().ping(true, 1, 0);
     peer.play();
 
@@ -917,7 +837,7 @@ private void receiveGoAway(Variant variant) throws Exception {
       assertEquals("stream was reset: CANCEL", expected.getMessage());
     }
     try {
-      stream.getSource().read(new OkBuffer(), 1);
+      stream.getSource().read(new Buffer(), 1);
       fail();
     } catch (IOException expected) {
       assertEquals("stream was reset: CANCEL", expected.getMessage());
@@ -947,33 +867,94 @@ private void receiveGoAway(Variant variant) throws Exception {
     assertEquals(-1, ping.roundTripTime());
   }
 
-  @Test public void readTimeoutExpires() throws Exception {
+  @Test public void getResponseHeadersTimesOut() throws Exception {
+    // write the mocking script
+    peer.acceptFrame(); // SYN_STREAM
+    peer.acceptFrame(); // RST_STREAM
+    peer.play();
+
+    // play it back
+    SpdyConnection connection = connection(peer, SPDY3);
+    SpdyStream stream = connection.newStream(headerEntries("b", "banana"), true, true);
+    stream.readTimeout().timeout(500, TimeUnit.MILLISECONDS);
+    long startNanos = System.nanoTime();
+    try {
+      stream.getResponseHeaders();
+      fail();
+    } catch (InterruptedIOException expected) {
+    }
+    long elapsedNanos = System.nanoTime() - startNanos;
+    assertEquals(500d, TimeUnit.NANOSECONDS.toMillis(elapsedNanos), 200d /* 200ms delta */);
+    assertEquals(0, connection.openStreamCount());
+
+    // verify the peer received what was expected
+    assertEquals(TYPE_HEADERS, peer.takeFrame().type);
+    assertEquals(TYPE_RST_STREAM, peer.takeFrame().type);
+  }
+
+  @Test public void readTimesOut() throws Exception {
     // write the mocking script
     peer.acceptFrame(); // SYN_STREAM
     peer.sendFrame().synReply(false, 1, headerEntries("a", "android"));
+    peer.acceptFrame(); // RST_STREAM
+    peer.play();
+
+    // play it back
+    SpdyConnection connection = connection(peer, SPDY3);
+    SpdyStream stream = connection.newStream(headerEntries("b", "banana"), true, true);
+    stream.readTimeout().timeout(500, TimeUnit.MILLISECONDS);
+    Source source = stream.getSource();
+    long startNanos = System.nanoTime();
+    try {
+      source.read(new Buffer(), 1);
+      fail();
+    } catch (InterruptedIOException expected) {
+    }
+    long elapsedNanos = System.nanoTime() - startNanos;
+    assertEquals(500d, TimeUnit.NANOSECONDS.toMillis(elapsedNanos), 200d /* 200ms delta */);
+    assertEquals(0, connection.openStreamCount());
+
+    // verify the peer received what was expected
+    assertEquals(TYPE_HEADERS, peer.takeFrame().type);
+    assertEquals(TYPE_RST_STREAM, peer.takeFrame().type);
+  }
+
+  @Test public void writeTimesOutAwaitingStreamWindow() throws Exception {
+    // Set the peer's receive window to 5 bytes!
+    Settings peerSettings = new Settings().set(Settings.INITIAL_WINDOW_SIZE, PERSIST_VALUE, 5);
+
+    // write the mocking script
+    peer.sendFrame().settings(peerSettings);
     peer.acceptFrame(); // PING
     peer.sendFrame().ping(true, 1, 0);
+    peer.acceptFrame(); // SYN_STREAM
+    peer.sendFrame().synReply(false, 1, headerEntries("a", "android"));
+    peer.acceptFrame(); // DATA
+    peer.acceptFrame(); // RST_STREAM
     peer.play();
 
     // play it back
     SpdyConnection connection = connection(peer, SPDY3);
+    connection.ping().roundTripTime(); // Make sure settings have been received.
     SpdyStream stream = connection.newStream(headerEntries("b", "banana"), true, true);
-    stream.setReadTimeout(1000);
-    Source source = stream.getSource();
+    Sink sink = stream.getSink();
+    sink.write(new Buffer().writeUtf8("abcde"), 5);
+    stream.writeTimeout().timeout(500, TimeUnit.MILLISECONDS);
     long startNanos = System.nanoTime();
     try {
-      source.read(new OkBuffer(), 1);
+      sink.write(new Buffer().writeUtf8("f"), 1); // This will time out waiting on the write window.
       fail();
-    } catch (IOException expected) {
+    } catch (InterruptedIOException expected) {
     }
     long elapsedNanos = System.nanoTime() - startNanos;
-    assertEquals(1000d, TimeUnit.NANOSECONDS.toMillis(elapsedNanos), 200d /* 200ms delta */);
-    assertEquals(1, connection.openStreamCount());
-    connection.ping().roundTripTime(); // Prevent the peer from exiting prematurely.
+    assertEquals(500d, TimeUnit.NANOSECONDS.toMillis(elapsedNanos), 200d /* 200ms delta */);
+    assertEquals(0, connection.openStreamCount());
 
     // verify the peer received what was expected
-    MockSpdyPeer.InFrame synStream = peer.takeFrame();
-    assertEquals(TYPE_HEADERS, synStream.type);
+    assertEquals(TYPE_PING, peer.takeFrame().type);
+    assertEquals(TYPE_HEADERS, peer.takeFrame().type);
+    assertEquals(TYPE_DATA, peer.takeFrame().type);
+    assertEquals(TYPE_RST_STREAM, peer.takeFrame().type);
   }
 
   @Test public void headers() throws Exception {
@@ -1031,50 +1012,41 @@ private void receiveGoAway(Variant variant) throws Exception {
   }
 
   @Test public void readSendsWindowUpdate() throws Exception {
-    readSendsWindowUpdate(SPDY3);
-  }
-
-  @Test public void readSendsWindowUpdateHttp2() throws Exception {
-    readSendsWindowUpdate(HTTP_20_DRAFT_09);
-  }
+    peer.setVariantAndClient(SPDY3, false);
 
-  private void readSendsWindowUpdate(Variant variant)
-      throws IOException, InterruptedException {
-    peer.setVariantAndClient(variant, false);
-
-    int windowUpdateThreshold = INITIAL_WINDOW_SIZE / 2;
+    int windowSize = 100;
+    int windowUpdateThreshold = 50;
 
     // Write the mocking script.
     peer.acceptFrame(); // SYN_STREAM
     peer.sendFrame().synReply(false, 1, headerEntries("a", "android"));
     for (int i = 0; i < 3; i++) {
-      // Send frames summing to windowUpdateThreshold.
-      for (int sent = 0, count; sent < windowUpdateThreshold; sent += count) {
-        count = Math.min(variant.maxFrameSize(), windowUpdateThreshold - sent);
-        peer.sendFrame().data(false, 1, data(count));
-      }
+      // Send frames of summing to size 50, which is windowUpdateThreshold.
+      peer.sendFrame().data(false, 1, data(24), 24);
+      peer.sendFrame().data(false, 1, data(25), 25);
+      peer.sendFrame().data(false, 1, data(1), 1);
       peer.acceptFrame(); // connection WINDOW UPDATE
       peer.acceptFrame(); // stream WINDOW UPDATE
     }
-    peer.sendFrame().data(true, 1, data(0));
+    peer.sendFrame().data(true, 1, data(0), 0);
     peer.play();
 
     // Play it back.
-    SpdyConnection connection = connection(peer, variant);
+    SpdyConnection connection = connection(peer, SPDY3);
+    connection.okHttpSettings.set(Settings.INITIAL_WINDOW_SIZE, 0, windowSize);
     SpdyStream stream = connection.newStream(headerEntries("b", "banana"), false, true);
     assertEquals(0, stream.unacknowledgedBytesRead);
     assertEquals(headerEntries("a", "android"), stream.getResponseHeaders());
     Source in = stream.getSource();
-    OkBuffer buffer = new OkBuffer();
-    while (in.read(buffer, 1024) != -1) {
-      if (buffer.size() == 3 * windowUpdateThreshold) break;
-    }
+    Buffer buffer = new Buffer();
+    buffer.writeAll(in);
     assertEquals(-1, in.read(buffer, 1));
+    assertEquals(150, buffer.size());
 
     MockSpdyPeer.InFrame synStream = peer.takeFrame();
     assertEquals(TYPE_HEADERS, synStream.type);
     for (int i = 0; i < 3; i++) {
-      List<Integer> windowUpdateStreamIds = new ArrayList(2);
+      List<Integer> windowUpdateStreamIds = new ArrayList<>(2);
       for (int j = 0; j < 2; j++) {
         MockSpdyPeer.InFrame windowUpdate = peer.takeFrame();
         assertEquals(TYPE_WINDOW_UPDATE, windowUpdate.type);
@@ -1086,32 +1058,23 @@ private void readSendsWindowUpdate(Variant variant)
     }
   }
 
-  private OkBuffer data(int byteCount) {
-    return new OkBuffer().write(new byte[byteCount]);
+  private Buffer data(int byteCount) {
+    return new Buffer().write(new byte[byteCount]);
   }
 
   @Test public void serverSendsEmptyDataClientDoesntSendWindowUpdate() throws Exception {
-    serverSendsEmptyDataClientDoesntSendWindowUpdate(SPDY3);
-  }
-
-  @Test public void serverSendsEmptyDataClientDoesntSendWindowUpdateHttp2() throws Exception {
-    serverSendsEmptyDataClientDoesntSendWindowUpdate(HTTP_20_DRAFT_09);
-  }
-
-  private void serverSendsEmptyDataClientDoesntSendWindowUpdate(Variant variant)
-      throws IOException, InterruptedException {
-    peer.setVariantAndClient(variant, false);
+    peer.setVariantAndClient(SPDY3, false);
 
     // Write the mocking script.
     peer.acceptFrame(); // SYN_STREAM
     peer.sendFrame().synReply(false, 1, headerEntries("a", "android"));
-    peer.sendFrame().data(true, 1, data(0));
+    peer.sendFrame().data(true, 1, data(0), 0);
     peer.play();
 
     // Play it back.
-    SpdyConnection connection = connection(peer, variant);
+    SpdyConnection connection = connection(peer, SPDY3);
     SpdyStream client = connection.newStream(headerEntries("b", "banana"), false, true);
-    assertEquals(-1, client.getSource().read(new OkBuffer(), 1));
+    assertEquals(-1, client.getSource().read(new Buffer(), 1));
 
     // Verify the peer received what was expected.
     MockSpdyPeer.InFrame synStream = peer.takeFrame();
@@ -1120,16 +1083,7 @@ private void serverSendsEmptyDataClientDoesntSendWindowUpdate(Variant variant)
   }
 
   @Test public void clientSendsEmptyDataServerDoesntSendWindowUpdate() throws Exception {
-    clientSendsEmptyDataServerDoesntSendWindowUpdate(SPDY3);
-  }
-
-  @Test public void clientSendsEmptyDataServerDoesntSendWindowUpdateHttp2() throws Exception {
-    clientSendsEmptyDataServerDoesntSendWindowUpdate(HTTP_20_DRAFT_09);
-  }
-
-  private void clientSendsEmptyDataServerDoesntSendWindowUpdate(Variant variant)
-      throws IOException, InterruptedException {
-    peer.setVariantAndClient(variant, false);
+    peer.setVariantAndClient(SPDY3, false);
 
     // Write the mocking script.
     peer.acceptFrame(); // SYN_STREAM
@@ -1138,7 +1092,7 @@ private void clientSendsEmptyDataServerDoesntSendWindowUpdate(Variant variant)
     peer.play();
 
     // Play it back.
-    SpdyConnection connection = connection(peer, variant);
+    SpdyConnection connection = connection(peer, SPDY3);
     SpdyStream client = connection.newStream(headerEntries("b", "banana"), true, true);
     BufferedSink out = Okio.buffer(client.getSink());
     out.write(Util.EMPTY_BYTE_ARRAY);
@@ -1151,102 +1105,11 @@ private void clientSendsEmptyDataServerDoesntSendWindowUpdate(Variant variant)
     assertEquals(3, peer.frameCount());
   }
 
-  @Test public void writeAwaitsWindowUpdate() throws Exception {
-    int framesThatFillWindow = roundUp(INITIAL_WINDOW_SIZE, HTTP_20_DRAFT_09.maxFrameSize());
-
-    // Write the mocking script. This accepts more data frames than necessary!
-    peer.acceptFrame(); // SYN_STREAM
-    for (int i = 0; i < framesThatFillWindow; i++) {
-      peer.acceptFrame(); // DATA
-    }
-    peer.acceptFrame(); // DATA we won't be able to flush until a window update.
-    peer.play();
-
-    // Play it back.
-    SpdyConnection connection = connection(peer, SPDY3);
-    SpdyStream stream = connection.newStream(headerEntries("b", "banana"), true, true);
-    BufferedSink out = Okio.buffer(stream.getSink());
-    out.write(new byte[INITIAL_WINDOW_SIZE]);
-    out.flush();
-
-    // Check that we've filled the window for both the stream and also the connection.
-    assertEquals(0, connection.bytesLeftInWriteWindow);
-    assertEquals(0, connection.getStream(1).bytesLeftInWriteWindow);
-
-    out.writeByte('a');
-    assertFlushBlocks(out);
-
-    // receiving a window update on the connection isn't enough.
-    connection.readerRunnable.windowUpdate(0, 1);
-    assertFlushBlocks(out);
-
-    // receiving a window update on the stream will unblock the stream.
-    connection.readerRunnable.windowUpdate(1, 1);
-    out.flush();
-
-    // Verify the peer received what was expected.
-    MockSpdyPeer.InFrame synStream = peer.takeFrame();
-    assertEquals(TYPE_HEADERS, synStream.type);
-    for (int i = 0; i < framesThatFillWindow; i++) {
-      MockSpdyPeer.InFrame data = peer.takeFrame();
-      assertEquals(TYPE_DATA, data.type);
-    }
-  }
-
-  @Test public void initialSettingsWithWindowSizeAdjustsConnection() throws Exception {
-    int framesThatFillWindow = roundUp(INITIAL_WINDOW_SIZE, HTTP_20_DRAFT_09.maxFrameSize());
-
-    // Write the mocking script. This accepts more data frames than necessary!
-    peer.acceptFrame(); // SYN_STREAM
-    for (int i = 0; i < framesThatFillWindow; i++) {
-      peer.acceptFrame(); // DATA on stream 1
-    }
-    peer.acceptFrame(); // DATA on stream 2
-    peer.play();
-
-    // Play it back.
-    SpdyConnection connection = connection(peer, SPDY3);
-    SpdyStream stream = connection.newStream(headerEntries("a", "apple"), true, true);
-    BufferedSink out = Okio.buffer(stream.getSink());
-    out.write(new byte[INITIAL_WINDOW_SIZE]);
-    out.flush();
-
-    // write 1 more than the window size
-    out.writeByte('a');
-    assertFlushBlocks(out);
-
-    // Check that we've filled the window for both the stream and also the connection.
-    assertEquals(0, connection.bytesLeftInWriteWindow);
-    assertEquals(0, connection.getStream(1).bytesLeftInWriteWindow);
-
-    // Receiving a Settings with a larger window size will unblock the streams.
-    Settings initial = new Settings();
-    initial.set(Settings.INITIAL_WINDOW_SIZE, PERSIST_VALUE, INITIAL_WINDOW_SIZE + 1);
-    connection.readerRunnable.settings(false, initial);
-
-    assertEquals(1, connection.bytesLeftInWriteWindow);
-    assertEquals(1, connection.getStream(1).bytesLeftInWriteWindow);
-
-    // The stream should no longer be blocked.
-    out.flush();
-
-    assertEquals(0, connection.bytesLeftInWriteWindow);
-    assertEquals(0, connection.getStream(1).bytesLeftInWriteWindow);
-
-    // Settings after the initial do not affect the connection window size.
-    Settings next = new Settings();
-    next.set(Settings.INITIAL_WINDOW_SIZE, PERSIST_VALUE, INITIAL_WINDOW_SIZE + 2);
-    connection.readerRunnable.settings(false, next);
-
-    assertEquals(0, connection.bytesLeftInWriteWindow); // connection wasn't affected.
-    assertEquals(1, connection.getStream(1).bytesLeftInWriteWindow);
-  }
-
   @Test public void testTruncatedDataFrame() throws Exception {
     // write the mocking script
     peer.acceptFrame(); // SYN_STREAM
     peer.sendFrame().synReply(false, 1, headerEntries("a", "android"));
-    peer.sendTruncatedFrame(8 + 100).data(false, 1, data(1024));
+    peer.sendTruncatedFrame(8 + 100).data(false, 1, data(1024), 1024);
     peer.play();
 
     // play it back
@@ -1263,7 +1126,7 @@ private void clientSendsEmptyDataServerDoesntSendWindowUpdate(Variant variant)
   }
 
   @Test public void blockedStreamDoesntStarveNewStream() throws Exception {
-    int framesThatFillWindow = roundUp(INITIAL_WINDOW_SIZE, SPDY3.maxFrameSize());
+    int framesThatFillWindow = roundUp(DEFAULT_INITIAL_WINDOW_SIZE, peer.maxOutboundDataLength());
 
     // Write the mocking script. This accepts more data frames than necessary!
     peer.acceptFrame(); // SYN_STREAM on stream 1
@@ -1278,7 +1141,7 @@ private void clientSendsEmptyDataServerDoesntSendWindowUpdate(Variant variant)
     SpdyConnection connection = connection(peer, SPDY3);
     SpdyStream stream1 = connection.newStream(headerEntries("a", "apple"), true, true);
     BufferedSink out1 = Okio.buffer(stream1.getSink());
-    out1.write(new byte[INITIAL_WINDOW_SIZE]);
+    out1.write(new byte[DEFAULT_INITIAL_WINDOW_SIZE]);
     out1.flush();
 
     // Check that we've filled the window for both the stream and also the connection.
@@ -1299,36 +1162,7 @@ private void clientSendsEmptyDataServerDoesntSendWindowUpdate(Variant variant)
 
     assertEquals(0, connection.bytesLeftInWriteWindow);
     assertEquals(0, connection.getStream(1).bytesLeftInWriteWindow);
-    assertEquals(INITIAL_WINDOW_SIZE - 3, connection.getStream(3).bytesLeftInWriteWindow);
-  }
-
-  @Test public void maxFrameSizeHonored() throws Exception {
-    peer.setVariantAndClient(HTTP_20_DRAFT_09, false);
-
-    byte[] buff = new byte[HTTP_20_DRAFT_09.maxFrameSize() + 1];
-    Arrays.fill(buff, (byte) '*');
-
-    // write the mocking script
-    peer.acceptFrame(); // SYN_STREAM
-    peer.sendFrame().synReply(false, 1, headerEntries("a", "android"));
-    peer.acceptFrame(); // DATA 1
-    peer.acceptFrame(); // DATA 2
-    peer.play();
-
-    // play it back
-    SpdyConnection connection = connection(peer, HTTP_20_DRAFT_09);
-    SpdyStream stream = connection.newStream(headerEntries("b", "banana"), true, true);
-    BufferedSink out = Okio.buffer(stream.getSink());
-    out.write(buff);
-    out.flush();
-    out.close();
-
-    MockSpdyPeer.InFrame synStream = peer.takeFrame();
-    assertEquals(TYPE_HEADERS, synStream.type);
-    MockSpdyPeer.InFrame data = peer.takeFrame();
-    assertEquals(HTTP_20_DRAFT_09.maxFrameSize(), data.data.length);
-    data = peer.takeFrame();
-    assertEquals(1, data.data.length);
+    assertEquals(DEFAULT_INITIAL_WINDOW_SIZE - 3, connection.getStream(3).bytesLeftInWriteWindow);
   }
 
   /** https://github.com/square/okhttp/issues/333 */
@@ -1386,8 +1220,10 @@ private void clientSendsEmptyDataServerDoesntSendWindowUpdate(Variant variant)
   private void headerBlockHasTrailingCompressedBytes(String frame, int length) throws IOException {
     // write the mocking script
     peer.acceptFrame(); // SYN_STREAM
-    peer.sendFrame(ByteString.decodeBase64(frame).toByteArray());
-    peer.sendFrame().data(true, 1, new OkBuffer().writeUtf8("robot"));
+    byte[] trailingCompressedBytes = ByteString.decodeBase64(frame).toByteArray();
+    trailingCompressedBytes[11] = 1; // Set SPDY/3 stream ID to 3.
+    peer.sendFrame(trailingCompressedBytes);
+    peer.sendFrame().data(true, 1, new Buffer().writeUtf8("robot"), 5);
     peer.acceptFrame(); // DATA
     peer.play();
 
@@ -1399,131 +1235,6 @@ private void headerBlockHasTrailingCompressedBytes(String frame, int length) thr
     assertStreamData("robot", stream.getSource());
   }
 
-  @Test public void pushPromiseStream() throws Exception {
-    peer.setVariantAndClient(HTTP_20_DRAFT_09, false);
-
-    // write the mocking script
-    peer.acceptFrame(); // SYN_STREAM
-    peer.sendFrame().synReply(false, 1, headerEntries("a", "android"));
-    final List<Header> expectedRequestHeaders = Arrays.asList(
-        new Header(Header.TARGET_METHOD, "GET"),
-        new Header(Header.TARGET_SCHEME, "https"),
-        new Header(Header.TARGET_AUTHORITY, "squareup.com"),
-        new Header(Header.TARGET_PATH, "/cached")
-    );
-    peer.sendFrame().pushPromise(1, 2, expectedRequestHeaders);
-    final List<Header> expectedResponseHeaders = Arrays.asList(
-        new Header(Header.RESPONSE_STATUS, "200")
-    );
-    peer.sendFrame().synReply(true, 2, expectedResponseHeaders);
-    peer.sendFrame().data(true, 1, data(0));
-    peer.play();
-
-    final List events = new ArrayList();
-    PushObserver observer = new PushObserver() {
-
-      @Override public boolean onRequest(int streamId, List<Header> requestHeaders) {
-        assertEquals(2, streamId);
-        events.add(requestHeaders);
-        return false;
-      }
-
-      @Override public boolean onHeaders(int streamId, List<Header> responseHeaders, boolean last) {
-        assertEquals(2, streamId);
-        assertTrue(last);
-        events.add(responseHeaders);
-        return false;
-      }
-
-      @Override public boolean onData(int streamId, BufferedSource source, int byteCount,
-          boolean last) throws IOException {
-        events.add(new AssertionError("onData"));
-        return false;
-      }
-
-      @Override public void onReset(int streamId, ErrorCode errorCode) {
-        events.add(new AssertionError("onReset"));
-      }
-    };
-
-    // play it back
-    SpdyConnection connection = connectionBuilder(peer, HTTP_20_DRAFT_09)
-        .pushObserver(observer).build();
-    SpdyStream client = connection.newStream(headerEntries("b", "banana"), false, true);
-    assertEquals(-1, client.getSource().read(new OkBuffer(), 1));
-
-    // verify the peer received what was expected
-    assertEquals(TYPE_HEADERS, peer.takeFrame().type);
-
-    assertEquals(2, events.size());
-    assertEquals(expectedRequestHeaders, events.get(0));
-    assertEquals(expectedResponseHeaders, events.get(1));
-  }
-
-  @Test public void doublePushPromise() throws Exception {
-    peer.setVariantAndClient(HTTP_20_DRAFT_09, false);
-
-    // write the mocking script
-    peer.sendFrame().pushPromise(1,2, headerEntries("a", "android"));
-    peer.acceptFrame(); // SYN_REPLY
-    peer.sendFrame().pushPromise(1, 2, headerEntries("b", "banana"));
-    peer.acceptFrame(); // RST_STREAM
-    peer.play();
-
-    // play it back
-    SpdyConnection connection = connectionBuilder(peer, HTTP_20_DRAFT_09).build();
-    connection.newStream(headerEntries("b", "banana"), false, true);
-
-    // verify the peer received what was expected
-    assertEquals(TYPE_HEADERS, peer.takeFrame().type);
-    assertEquals(PROTOCOL_ERROR, peer.takeFrame().errorCode);
-  }
-
-  @Test public void pushPromiseStreamsAutomaticallyCancel() throws Exception {
-    peer.setVariantAndClient(HTTP_20_DRAFT_09, false);
-
-    // write the mocking script
-    peer.sendFrame().pushPromise(1, 2, Arrays.asList(
-        new Header(Header.TARGET_METHOD, "GET"),
-        new Header(Header.TARGET_SCHEME, "https"),
-        new Header(Header.TARGET_AUTHORITY, "squareup.com"),
-        new Header(Header.TARGET_PATH, "/cached")
-    ));
-    peer.sendFrame().synReply(true, 2, Arrays.asList(
-        new Header(Header.RESPONSE_STATUS, "200")
-    ));
-    peer.acceptFrame(); // RST_STREAM
-    peer.play();
-
-    // play it back
-    connectionBuilder(peer, HTTP_20_DRAFT_09)
-        .pushObserver(PushObserver.CANCEL).build();
-
-    // verify the peer received what was expected
-    MockSpdyPeer.InFrame rstStream = peer.takeFrame();
-    assertEquals(TYPE_RST_STREAM, rstStream.type);
-    assertEquals(2, rstStream.streamId);
-    assertEquals(CANCEL, rstStream.errorCode);
-  }
-
-  private SpdyConnection sendHttp2SettingsAndCheckForAck(boolean client, Settings settings)
-      throws IOException, InterruptedException {
-    peer.setVariantAndClient(HTTP_20_DRAFT_09, client);
-    peer.sendFrame().settings(settings);
-    peer.acceptFrame(); // ACK
-    peer.play();
-
-    // play it back
-    SpdyConnection connection = connection(peer, HTTP_20_DRAFT_09);
-
-    // verify the peer received the ACK
-    MockSpdyPeer.InFrame ackFrame = peer.takeFrame();
-    assertEquals(TYPE_SETTINGS, ackFrame.type);
-    assertEquals(0, ackFrame.streamId);
-    assertTrue(ackFrame.ack);
-    return connection;
-  }
-
   private SpdyConnection connection(MockSpdyPeer peer, Variant variant) throws IOException {
     return connectionBuilder(peer, variant).build();
   }
@@ -1531,15 +1242,11 @@ private SpdyConnection connection(MockSpdyPeer peer, Variant variant) throws IOE
   private SpdyConnection.Builder connectionBuilder(MockSpdyPeer peer, Variant variant)
       throws IOException {
     return new SpdyConnection.Builder(true, peer.openSocket())
-        .pushObserver(IGNORE)
         .protocol(variant.getProtocol());
   }
 
   private void assertStreamData(String expected, Source source) throws IOException {
-    OkBuffer buffer = new OkBuffer();
-    while (source.read(buffer, Long.MAX_VALUE) != -1) {
-    }
-    String actual = buffer.readUtf8(buffer.size());
+    String actual = Okio.buffer(source).readUtf8();
     assertEquals(expected, actual);
   }
 
@@ -1570,24 +1277,4 @@ private void interruptAfterDelay(final long delayMillis) {
   static int roundUp(int num, int divisor) {
     return (num + divisor - 1) / divisor;
   }
-
-  static final PushObserver IGNORE = new PushObserver() {
-
-    @Override public boolean onRequest(int streamId, List<Header> requestHeaders) {
-      return false;
-    }
-
-    @Override public boolean onHeaders(int streamId, List<Header> responseHeaders, boolean last) {
-      return false;
-    }
-
-    @Override public boolean onData(int streamId, BufferedSource source, int byteCount,
-        boolean last) throws IOException {
-      source.skip(byteCount);
-      return false;
-    }
-
-    @Override public void onReset(int streamId, ErrorCode errorCode) {
-    }
-  };
 }
diff --git a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/spdy/Spdy3Test.java b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/spdy/Spdy3Test.java
index 1904b908fc..c902773c9f 100644
--- a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/spdy/Spdy3Test.java
+++ b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/spdy/Spdy3Test.java
@@ -17,8 +17,8 @@
 
 import com.squareup.okhttp.internal.Util;
 import java.io.IOException;
+import okio.Buffer;
 import okio.ByteString;
-import okio.OkBuffer;
 import org.junit.Test;
 
 import static org.junit.Assert.assertEquals;
@@ -29,7 +29,7 @@
 
   @Test public void tooLargeDataFrame() throws IOException {
     try {
-      sendDataFrame(new OkBuffer().write(new byte[0x1000000]));
+      sendDataFrame(new Buffer().write(new byte[0x1000000]));
       fail();
     } catch (IllegalArgumentException e) {
       assertEquals("FRAME_TOO_LARGE max size is 16Mib: " + 0x1000000L, e.getMessage());
@@ -53,7 +53,7 @@
   }
 
   @Test public void goAwayRoundTrip() throws IOException {
-    OkBuffer frame = new OkBuffer();
+    Buffer frame = new Buffer();
 
     final ErrorCode expectedError = ErrorCode.PROTOCOL_ERROR;
 
@@ -83,18 +83,18 @@
     });
   }
 
-  private void sendDataFrame(OkBuffer source) throws IOException {
-    Spdy3.Writer writer = new Spdy3.Writer(new OkBuffer(), true);
+  private void sendDataFrame(Buffer source) throws IOException {
+    Spdy3.Writer writer = new Spdy3.Writer(new Buffer(), true);
     writer.sendDataFrame(expectedStreamId, 0, source, (int) source.size());
   }
 
   private void windowUpdate(long increment) throws IOException {
-    new Spdy3.Writer(new OkBuffer(), true).windowUpdate(expectedStreamId, increment);
+    new Spdy3.Writer(new Buffer(), true).windowUpdate(expectedStreamId, increment);
   }
 
-  private OkBuffer sendGoAway(int lastGoodStreamId, ErrorCode errorCode, byte[] debugData)
+  private Buffer sendGoAway(int lastGoodStreamId, ErrorCode errorCode, byte[] debugData)
       throws IOException {
-    OkBuffer out = new OkBuffer();
+    Buffer out = new Buffer();
     new Spdy3.Writer(out, true).goAway(lastGoodStreamId, errorCode, debugData);
     return out;
   }
diff --git a/okhttp-urlconnection/pom.xml b/okhttp-urlconnection/pom.xml
new file mode 100644
index 0000000000..dc743a9950
--- /dev/null
+++ b/okhttp-urlconnection/pom.xml
@@ -0,0 +1,49 @@
+<?xml version="1.0" encoding="UTF-8"?>
+
+<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
+  <modelVersion>4.0.0</modelVersion>
+
+  <parent>
+    <groupId>com.squareup.okhttp</groupId>
+    <artifactId>parent</artifactId>
+    <version>2.0.1-SNAPSHOT</version>
+  </parent>
+
+  <artifactId>okhttp-urlconnection</artifactId>
+  <name>OkHttp URLConnection</name>
+
+  <dependencies>
+    <dependency>
+      <groupId>com.squareup.okhttp</groupId>
+      <artifactId>okhttp</artifactId>
+      <version>${project.version}</version>
+    </dependency>
+
+    <dependency>
+      <groupId>junit</groupId>
+      <artifactId>junit</artifactId>
+      <scope>test</scope>
+    </dependency>
+    <dependency>
+      <groupId>com.squareup.okhttp</groupId>
+      <artifactId>mockwebserver</artifactId>
+      <version>${project.version}</version>
+      <scope>test</scope>
+    </dependency>
+  </dependencies>
+
+  <build>
+    <plugins>
+      <plugin>
+        <groupId>org.apache.maven.plugins</groupId>
+        <artifactId>maven-javadoc-plugin</artifactId>
+        <configuration>
+          <excludePackageNames>com.squareup.okhttp.internal.*</excludePackageNames>
+          <links>
+            <link>http://square.github.io/okhttp/javadoc/</link>
+          </links>
+        </configuration>
+      </plugin>
+    </plugins>
+  </build>
+</project>
diff --git a/okhttp-urlconnection/src/main/java/com/squareup/okhttp/OkUrlFactory.java b/okhttp-urlconnection/src/main/java/com/squareup/okhttp/OkUrlFactory.java
new file mode 100644
index 0000000000..2c5f95ff79
--- /dev/null
+++ b/okhttp-urlconnection/src/main/java/com/squareup/okhttp/OkUrlFactory.java
@@ -0,0 +1,103 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.okhttp;
+
+import com.squareup.okhttp.internal.InternalCache;
+import com.squareup.okhttp.internal.huc.CacheAdapter;
+import com.squareup.okhttp.internal.huc.HttpURLConnectionImpl;
+import com.squareup.okhttp.internal.huc.HttpsURLConnectionImpl;
+import java.net.HttpURLConnection;
+import java.net.Proxy;
+import java.net.ResponseCache;
+import java.net.URL;
+import java.net.URLConnection;
+import java.net.URLStreamHandler;
+import java.net.URLStreamHandlerFactory;
+
+public final class OkUrlFactory implements URLStreamHandlerFactory, Cloneable {
+  private final OkHttpClient client;
+
+  public OkUrlFactory(OkHttpClient client) {
+    this.client = client;
+  }
+
+  public OkHttpClient client() {
+    return client;
+  }
+
+  /** Sets the response cache to be used to read and write cached responses. */
+  OkUrlFactory setResponseCache(ResponseCache responseCache) {
+    client.setInternalCache(responseCache != null ? new CacheAdapter(responseCache) : null);
+    return this;
+  }
+
+  ResponseCache getResponseCache() {
+    InternalCache cache = client.internalCache();
+    return cache instanceof CacheAdapter ? ((CacheAdapter) cache).getDelegate() : null;
+  }
+
+  /**
+   * Returns a copy of this stream handler factory that includes a shallow copy
+   * of the internal {@linkplain OkHttpClient HTTP client}.
+   */
+  @Override public OkUrlFactory clone() {
+    return new OkUrlFactory(client.clone());
+  }
+
+  public HttpURLConnection open(URL url) {
+    return open(url, client.getProxy());
+  }
+
+  HttpURLConnection open(URL url, Proxy proxy) {
+    String protocol = url.getProtocol();
+    OkHttpClient copy = client.copyWithDefaults();
+    copy.setProxy(proxy);
+
+    if (protocol.equals("http")) return new HttpURLConnectionImpl(url, copy);
+    if (protocol.equals("https")) return new HttpsURLConnectionImpl(url, copy);
+    throw new IllegalArgumentException("Unexpected protocol: " + protocol);
+  }
+
+  /**
+   * Creates a URLStreamHandler as a {@link java.net.URL#setURLStreamHandlerFactory}.
+   *
+   * <p>This code configures OkHttp to handle all HTTP and HTTPS connections
+   * created with {@link java.net.URL#openConnection()}: <pre>   {@code
+   *
+   *   OkHttpClient okHttpClient = new OkHttpClient();
+   *   URL.setURLStreamHandlerFactory(new OkUrlFactory(okHttpClient));
+   * }</pre>
+   */
+  @Override public URLStreamHandler createURLStreamHandler(final String protocol) {
+    if (!protocol.equals("http") && !protocol.equals("https")) return null;
+
+    return new URLStreamHandler() {
+      @Override protected URLConnection openConnection(URL url) {
+        return open(url);
+      }
+
+      @Override protected URLConnection openConnection(URL url, Proxy proxy) {
+        return open(url, proxy);
+      }
+
+      @Override protected int getDefaultPort() {
+        if (protocol.equals("http")) return 80;
+        if (protocol.equals("https")) return 443;
+        throw new AssertionError();
+      }
+    };
+  }
+}
diff --git a/okhttp-urlconnection/src/main/java/com/squareup/okhttp/internal/huc/CacheAdapter.java b/okhttp-urlconnection/src/main/java/com/squareup/okhttp/internal/huc/CacheAdapter.java
new file mode 100644
index 0000000000..13a34c032b
--- /dev/null
+++ b/okhttp-urlconnection/src/main/java/com/squareup/okhttp/internal/huc/CacheAdapter.java
@@ -0,0 +1,105 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.okhttp.internal.huc;
+
+import com.squareup.okhttp.Request;
+import com.squareup.okhttp.Response;
+import com.squareup.okhttp.internal.InternalCache;
+import com.squareup.okhttp.internal.http.CacheRequest;
+import com.squareup.okhttp.internal.http.CacheStrategy;
+import java.io.IOException;
+import java.io.OutputStream;
+import java.net.CacheResponse;
+import java.net.HttpURLConnection;
+import java.net.ResponseCache;
+import java.net.URI;
+import java.util.List;
+import java.util.Map;
+import okio.Okio;
+import okio.Sink;
+
+/** Adapts {@link ResponseCache} to {@link InternalCache}. */
+public final class CacheAdapter implements InternalCache {
+  private final ResponseCache delegate;
+
+  public CacheAdapter(ResponseCache delegate) {
+    this.delegate = delegate;
+  }
+
+  public ResponseCache getDelegate() {
+    return delegate;
+  }
+
+  @Override public Response get(Request request) throws IOException {
+    CacheResponse javaResponse = getJavaCachedResponse(request);
+    if (javaResponse == null) {
+      return null;
+    }
+    return JavaApiConverter.createOkResponse(request, javaResponse);
+  }
+
+  @Override public CacheRequest put(Response response) throws IOException {
+    URI uri = response.request().uri();
+    HttpURLConnection connection = JavaApiConverter.createJavaUrlConnection(response);
+    final java.net.CacheRequest request = delegate.put(uri, connection);
+    if (request == null) {
+      return null;
+    }
+    return new CacheRequest() {
+      @Override public Sink body() throws IOException {
+        OutputStream body = request.getBody();
+        return body != null ? Okio.sink(body) : null;
+      }
+
+      @Override public void abort() {
+        request.abort();
+      }
+    };
+  }
+
+  @Override public void remove(Request request) throws IOException {
+    // This method is treated as optional and there is no obvious way of implementing it with
+    // ResponseCache. Removing items from the cache due to modifications made from this client is
+    // not essential given that modifications could be made from any other client. We have to assume
+    // that it's ok to keep using the cached data. Otherwise the server shouldn't declare it as
+    // cacheable or the client should be careful about caching it.
+  }
+
+  @Override public void update(Response cached, Response network) throws IOException {
+    // This method is treated as optional and there is no obvious way of implementing it with
+    // ResponseCache. Updating headers is useful if the server changes the metadata for a resource
+    // (e.g. max age) to extend or truncate the life of that resource in the cache. If the metadata
+    // is not updated the caching behavior may not be optimal, but will obey the metadata sent
+    // with the original cached response.
+  }
+
+  @Override public void trackConditionalCacheHit() {
+    // This method is optional.
+  }
+
+  @Override public void trackResponse(CacheStrategy cacheStrategy) {
+    // This method is optional.
+  }
+
+  /**
+   * Returns the {@link CacheResponse} from the delegate by converting the
+   * OkHttp {@link Request} into the arguments required by the {@link ResponseCache}.
+   */
+  private CacheResponse getJavaCachedResponse(Request request) throws IOException {
+    Map<String, List<String>> headers = JavaApiConverter.extractJavaHeaders(request);
+    return delegate.get(request.uri(), request.method(), headers);
+  }
+}
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/http/DelegatingHttpsURLConnection.java b/okhttp-urlconnection/src/main/java/com/squareup/okhttp/internal/huc/DelegatingHttpsURLConnection.java
similarity index 99%
rename from okhttp/src/main/java/com/squareup/okhttp/internal/http/DelegatingHttpsURLConnection.java
rename to okhttp-urlconnection/src/main/java/com/squareup/okhttp/internal/huc/DelegatingHttpsURLConnection.java
index fedf1152fa..631a2ae03d 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/http/DelegatingHttpsURLConnection.java
+++ b/okhttp-urlconnection/src/main/java/com/squareup/okhttp/internal/huc/DelegatingHttpsURLConnection.java
@@ -14,7 +14,7 @@
  *  See the License for the specific language governing permissions and
  *  limitations under the License.
  */
-package com.squareup.okhttp.internal.http;
+package com.squareup.okhttp.internal.huc;
 
 import com.squareup.okhttp.Handshake;
 import java.io.IOException;
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpURLConnectionImpl.java b/okhttp-urlconnection/src/main/java/com/squareup/okhttp/internal/huc/HttpURLConnectionImpl.java
similarity index 74%
rename from okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpURLConnectionImpl.java
rename to okhttp-urlconnection/src/main/java/com/squareup/okhttp/internal/huc/HttpURLConnectionImpl.java
index f1a37cbf43..85fa7f3b8c 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpURLConnectionImpl.java
+++ b/okhttp-urlconnection/src/main/java/com/squareup/okhttp/internal/huc/HttpURLConnectionImpl.java
@@ -15,7 +15,7 @@
  *  limitations under the License.
  */
 
-package com.squareup.okhttp.internal.http;
+package com.squareup.okhttp.internal.huc;
 
 import com.squareup.okhttp.Connection;
 import com.squareup.okhttp.Handshake;
@@ -25,8 +25,15 @@
 import com.squareup.okhttp.Request;
 import com.squareup.okhttp.Response;
 import com.squareup.okhttp.Route;
+import com.squareup.okhttp.internal.Internal;
 import com.squareup.okhttp.internal.Platform;
 import com.squareup.okhttp.internal.Util;
+import com.squareup.okhttp.internal.http.HttpDate;
+import com.squareup.okhttp.internal.http.HttpEngine;
+import com.squareup.okhttp.internal.http.HttpMethod;
+import com.squareup.okhttp.internal.http.OkHeaders;
+import com.squareup.okhttp.internal.http.RetryableSink;
+import com.squareup.okhttp.internal.http.StatusLine;
 import java.io.FileNotFoundException;
 import java.io.IOException;
 import java.io.InputStream;
@@ -46,12 +53,8 @@
 import java.util.Map;
 import java.util.concurrent.TimeUnit;
 import okio.BufferedSink;
-import okio.ByteString;
 import okio.Sink;
 
-import static com.squareup.okhttp.internal.Util.getEffectivePort;
-import static com.squareup.okhttp.internal.http.StatusLine.HTTP_TEMP_REDIRECT;
-
 /**
  * This implementation uses HttpEngine to send requests and receive responses.
  * This class may use multiple HttpEngines to follow redirects, authentication
@@ -66,12 +69,6 @@
  */
 public class HttpURLConnectionImpl extends HttpURLConnection {
 
-  /**
-   * How many redirects should we follow? Chrome follows 21; Firefox, curl,
-   * and wget follow 20; Safari follows 16; and HTTP/1.0 recommends 5.
-   */
-  public static final int MAX_REDIRECTS = 20;
-
   final OkHttpClient client;
 
   private Headers.Builder requestHeaders = new Headers.Builder();
@@ -81,6 +78,8 @@
   private int redirectionCount;
   protected IOException httpEngineFailure;
   protected HttpEngine httpEngine;
+  /** Lazily created (with synthetic headers) on first call to getHeaders(). */
+  private Headers responseHeaders;
 
   /**
    * The most recently attempted route. This will be null if we haven't sent a
@@ -109,9 +108,15 @@ public HttpURLConnectionImpl(URL url, OkHttpClient client) {
 
   @Override public final void disconnect() {
     // Calling disconnect() before a connection exists should have no effect.
-    if (httpEngine != null) {
-      httpEngine.close();
-    }
+    if (httpEngine == null) return;
+
+    httpEngine.disconnect();
+
+    // This doesn't close the stream because doing so would require all stream
+    // access to be synchronized. It's expected that the thread using the
+    // connection will close its streams directly. If it doesn't, the worst
+    // case is that the GzipSource's Inflater won't be released until it's
+    // finalized. (This logs a warning on Android.)
   }
 
   /**
@@ -130,13 +135,38 @@ public HttpURLConnectionImpl(URL url, OkHttpClient client) {
     }
   }
 
+  private Headers getHeaders() throws IOException {
+    if (responseHeaders == null) {
+      Response response = getResponse().getResponse();
+      Headers headers = response.headers();
+
+      responseHeaders = headers.newBuilder()
+          .add(Platform.get().getPrefix() + "-Response-Source", responseSourceHeader(response))
+          .build();
+    }
+    return responseHeaders;
+  }
+
+  private static String responseSourceHeader(Response response) {
+    if (response.networkResponse() == null) {
+      if (response.cacheResponse() == null) {
+        return "NONE";
+      }
+      return "CACHE " + response.code();
+    }
+    if (response.cacheResponse() == null) {
+      return "NETWORK " + response.code();
+    }
+    return "CONDITIONAL_CACHE " + response.networkResponse().code();
+  }
+
   /**
    * Returns the value of the field at {@code position}. Returns null if there
    * are fewer than {@code position} headers.
    */
   @Override public final String getHeaderField(int position) {
     try {
-      return getResponse().getResponse().headers().value(position);
+      return getHeaders().value(position);
     } catch (IOException e) {
       return null;
     }
@@ -149,8 +179,9 @@ public HttpURLConnectionImpl(URL url, OkHttpClient client) {
    */
   @Override public final String getHeaderField(String fieldName) {
     try {
-      Response response = getResponse().getResponse();
-      return fieldName == null ? response.statusLine() : response.headers().get(fieldName);
+      return fieldName == null
+          ? StatusLine.get(getResponse().getResponse()).toString()
+          : getHeaders().get(fieldName);
     } catch (IOException e) {
       return null;
     }
@@ -158,7 +189,7 @@ public HttpURLConnectionImpl(URL url, OkHttpClient client) {
 
   @Override public final String getHeaderFieldKey(int position) {
     try {
-      return getResponse().getResponse().headers().name(position);
+      return getHeaders().name(position);
     } catch (IOException e) {
       return null;
     }
@@ -166,8 +197,8 @@ public HttpURLConnectionImpl(URL url, OkHttpClient client) {
 
   @Override public final Map<String, List<String>> getHeaderFields() {
     try {
-      Response response = getResponse().getResponse();
-      return OkHeaders.toMultimap(response.headers(), response.statusLine());
+      return OkHeaders.toMultimap(getHeaders(),
+          StatusLine.get(getResponse().getResponse()).toString());
     } catch (IOException e) {
       return Collections.emptyMap();
     }
@@ -237,6 +268,11 @@ public HttpURLConnectionImpl(URL url, OkHttpClient client) {
     client.setConnectTimeout(timeoutMillis, TimeUnit.MILLISECONDS);
   }
 
+  @Override
+  public void setInstanceFollowRedirects(boolean followRedirects) {
+    client.setFollowRedirects(followRedirects);
+  }
+
   @Override public int getConnectTimeout() {
     return client.getConnectTimeout();
   }
@@ -267,7 +303,9 @@ private void initHttpEngine() throws IOException {
           throw new ProtocolException(method + " does not support writing");
         }
       }
-      httpEngine = newHttpEngine(method, null, null);
+      // If the user set content length to zero, we know there will not be a request body.
+      RetryableSink requestBody = doOutput && fixedContentLength == 0 ? Util.emptySink() : null;
+      httpEngine = newHttpEngine(method, null, requestBody, null);
     } catch (IOException e) {
       httpEngineFailure = e;
       throw e;
@@ -275,7 +313,7 @@ private void initHttpEngine() throws IOException {
   }
 
   private HttpEngine newHttpEngine(String method, Connection connection,
-      RetryableSink requestBody) {
+      RetryableSink requestBody, Response priorResponse) {
     Request.Builder builder = new Request.Builder()
         .url(getURL())
         .method(method, null /* No body; that's passed separately. */);
@@ -284,26 +322,42 @@ private HttpEngine newHttpEngine(String method, Connection connection,
       builder.addHeader(headers.name(i), headers.value(i));
     }
 
-    boolean bufferRequestBody;
-    if (fixedContentLength != -1) {
-      bufferRequestBody = false;
-      builder.header("Content-Length", Long.toString(fixedContentLength));
-    } else if (chunkLength > 0) {
-      bufferRequestBody = false;
-      builder.header("Transfer-Encoding", "chunked");
-    } else {
-      bufferRequestBody = true;
+    boolean bufferRequestBody = false;
+    if (HttpMethod.hasRequestBody(method)) {
+      // Specify how the request body is terminated.
+      if (fixedContentLength != -1) {
+        builder.header("Content-Length", Long.toString(fixedContentLength));
+      } else if (chunkLength > 0) {
+        builder.header("Transfer-Encoding", "chunked");
+      } else {
+        bufferRequestBody = true;
+      }
+
+      // Add a content type for the request body, if one isn't already present.
+      if (headers.get("Content-Type") == null) {
+        builder.header("Content-Type", "application/x-www-form-urlencoded");
+      }
+    }
+
+    if (headers.get("User-Agent") == null) {
+      builder.header("User-Agent", defaultUserAgent());
     }
 
     Request request = builder.build();
 
     // If we're currently not using caches, make sure the engine's client doesn't have one.
     OkHttpClient engineClient = client;
-    if (engineClient.getOkResponseCache() != null && !getUseCaches()) {
-      engineClient = client.clone().setOkResponseCache(null);
+    if (Internal.instance.internalCache(engineClient) != null && !getUseCaches()) {
+      engineClient = client.clone().setCache(null);
     }
 
-    return new HttpEngine(engineClient, request, bufferRequestBody, connection, null, requestBody);
+    return new HttpEngine(engineClient, request, bufferRequestBody, connection, null, requestBody,
+        priorResponse);
+  }
+
+  private String defaultUserAgent() {
+    String agent = System.getProperty("http.agent");
+    return agent != null ? agent : ("Java" + System.getProperty("java.version"));
   }
 
   /**
@@ -323,26 +377,27 @@ private HttpEngine getResponse() throws IOException {
         continue;
       }
 
-      Retry retry = processResponseHeaders();
-      if (retry == Retry.NONE) {
+      Response response = httpEngine.getResponse();
+      Request followUp = httpEngine.followUpRequest();
+
+      if (followUp == null) {
         httpEngine.releaseConnection();
         return httpEngine;
       }
 
+      if (response.isRedirect() && ++redirectionCount > HttpEngine.MAX_REDIRECTS) {
+        throw new ProtocolException("Too many redirects: " + redirectionCount);
+      }
+
       // The first request was insufficient. Prepare for another...
-      String retryMethod = method;
-      Sink requestBody = httpEngine.getRequestBody();
+      url = followUp.url();
+      requestHeaders = followUp.headers().newBuilder();
 
-      // Although RFC 2616 10.3.2 specifies that a HTTP_MOVED_PERM
-      // redirect should keep the same method, Chrome, Firefox and the
-      // RI all issue GETs when following any redirect.
-      int responseCode = httpEngine.getResponse().code();
-      if (responseCode == HTTP_MULT_CHOICE
-          || responseCode == HTTP_MOVED_PERM
-          || responseCode == HTTP_MOVED_TEMP
-          || responseCode == HTTP_SEE_OTHER) {
-        retryMethod = "GET";
-        requestHeaders.removeAll("Content-Length");
+      // Although RFC 2616 10.3.2 specifies that a HTTP_MOVED_PERM redirect
+      // should keep the same method, Chrome, Firefox and the RI all issue GETs
+      // when following any redirect.
+      Sink requestBody = httpEngine.getRequestBody();
+      if (!followUp.method().equals(method)) {
         requestBody = null;
       }
 
@@ -350,12 +405,13 @@ private HttpEngine getResponse() throws IOException {
         throw new HttpRetryException("Cannot retry streamed HTTP body", responseCode);
       }
 
-      if (retry == Retry.DIFFERENT_CONNECTION) {
+      if (!httpEngine.sameConnection(followUp.url())) {
         httpEngine.releaseConnection();
       }
 
       Connection connection = httpEngine.close();
-      httpEngine = newHttpEngine(retryMethod, connection, (RetryableSink) requestBody);
+      httpEngine = newHttpEngine(followUp.method(), connection, (RetryableSink) requestBody,
+          response);
     }
   }
 
@@ -389,78 +445,6 @@ private boolean execute(boolean readResponse) throws IOException {
     }
   }
 
-  enum Retry {
-    NONE,
-    SAME_CONNECTION,
-    DIFFERENT_CONNECTION
-  }
-
-  /**
-   * Returns the retry action to take for the current response headers. The
-   * headers, proxy and target URL for this connection may be adjusted to
-   * prepare for a follow up request.
-   */
-  private Retry processResponseHeaders() throws IOException {
-    Connection connection = httpEngine.getConnection();
-    Proxy selectedProxy = connection != null
-        ? connection.getRoute().getProxy()
-        : client.getProxy();
-    final int responseCode = getResponseCode();
-    switch (responseCode) {
-      case HTTP_PROXY_AUTH:
-        if (selectedProxy.type() != Proxy.Type.HTTP) {
-          throw new ProtocolException("Received HTTP_PROXY_AUTH (407) code while not using proxy");
-        }
-        // fall-through
-      case HTTP_UNAUTHORIZED:
-        Request successorRequest = HttpAuthenticator.processAuthHeader(client.getAuthenticator(),
-            httpEngine.getResponse(), selectedProxy);
-        if (successorRequest == null) return Retry.NONE;
-        requestHeaders = successorRequest.getHeaders().newBuilder();
-        return Retry.SAME_CONNECTION;
-
-      case HTTP_MULT_CHOICE:
-      case HTTP_MOVED_PERM:
-      case HTTP_MOVED_TEMP:
-      case HTTP_SEE_OTHER:
-      case HTTP_TEMP_REDIRECT:
-        if (!getInstanceFollowRedirects()) {
-          return Retry.NONE;
-        }
-        if (++redirectionCount > MAX_REDIRECTS) {
-          throw new ProtocolException("Too many redirects: " + redirectionCount);
-        }
-        if (responseCode == HTTP_TEMP_REDIRECT && !method.equals("GET") && !method.equals("HEAD")) {
-          // "If the 307 status code is received in response to a request other than GET or HEAD,
-          // the user agent MUST NOT automatically redirect the request"
-          return Retry.NONE;
-        }
-        String location = getHeaderField("Location");
-        if (location == null) {
-          return Retry.NONE;
-        }
-        URL previousUrl = url;
-        url = new URL(previousUrl, location);
-        if (!url.getProtocol().equals("https") && !url.getProtocol().equals("http")) {
-          return Retry.NONE; // Don't follow redirects to unsupported protocols.
-        }
-        boolean sameProtocol = previousUrl.getProtocol().equals(url.getProtocol());
-        if (!sameProtocol && !client.getFollowProtocolRedirects()) {
-          return Retry.NONE; // This client doesn't follow redirects across protocols.
-        }
-        boolean sameHost = previousUrl.getHost().equals(url.getHost());
-        boolean samePort = getEffectivePort(previousUrl) == getEffectivePort(url);
-        if (sameHost && samePort && sameProtocol) {
-          return Retry.SAME_CONNECTION;
-        } else {
-          return Retry.DIFFERENT_CONNECTION;
-        }
-
-      default:
-        return Retry.NONE;
-    }
-  }
-
   /**
    * Returns true if either:
    * <ul>
@@ -480,7 +464,7 @@ private Retry processResponseHeaders() throws IOException {
   }
 
   @Override public String getResponseMessage() throws IOException {
-    return getResponse().getResponse().statusMessage();
+    return getResponse().getResponse().message();
   }
 
   @Override public final int getResponseCode() throws IOException {
@@ -553,13 +537,13 @@ private Retry processResponseHeaders() throws IOException {
    * defined in {@link Protocol OkHttp's protocol enumeration}.
    */
   private void setProtocols(String protocolsString, boolean append) {
-    List<Protocol> protocolsList = new ArrayList<Protocol>();
+    List<Protocol> protocolsList = new ArrayList<>();
     if (append) {
       protocolsList.addAll(client.getProtocols());
     }
     for (String protocol : protocolsString.split(",", -1)) {
       try {
-        protocolsList.add(Protocol.find(ByteString.encodeUtf8(protocol)));
+        protocolsList.add(Protocol.get(protocol));
       } catch (IOException e) {
         throw new IllegalStateException(e);
       }
@@ -579,8 +563,7 @@ private void setProtocols(String protocolsString, boolean append) {
     setFixedLengthStreamingMode((long) contentLength);
   }
 
-  // @Override Don't override: this overload method doesn't exist prior to Java 1.7.
-  public void setFixedLengthStreamingMode(long contentLength) {
+  @Override public void setFixedLengthStreamingMode(long contentLength) {
     if (super.connected) throw new IllegalStateException("Already connected");
     if (chunkLength > 0) throw new IllegalStateException("Already in chunked mode");
     if (contentLength < 0) throw new IllegalArgumentException("contentLength < 0");
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpsURLConnectionImpl.java b/okhttp-urlconnection/src/main/java/com/squareup/okhttp/internal/huc/HttpsURLConnectionImpl.java
similarity index 98%
rename from okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpsURLConnectionImpl.java
rename to okhttp-urlconnection/src/main/java/com/squareup/okhttp/internal/huc/HttpsURLConnectionImpl.java
index 358ec95a1a..2aba0872a8 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpsURLConnectionImpl.java
+++ b/okhttp-urlconnection/src/main/java/com/squareup/okhttp/internal/huc/HttpsURLConnectionImpl.java
@@ -14,7 +14,7 @@
  *  See the License for the specific language governing permissions and
  *  limitations under the License.
  */
-package com.squareup.okhttp.internal.http;
+package com.squareup.okhttp.internal.huc;
 
 import com.squareup.okhttp.Handshake;
 import com.squareup.okhttp.OkHttpClient;
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/http/ResponseCacheAdapter.java b/okhttp-urlconnection/src/main/java/com/squareup/okhttp/internal/huc/JavaApiConverter.java
similarity index 54%
rename from okhttp/src/main/java/com/squareup/okhttp/internal/http/ResponseCacheAdapter.java
rename to okhttp-urlconnection/src/main/java/com/squareup/okhttp/internal/huc/JavaApiConverter.java
index 9d6eb22c60..1d2492246a 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/http/ResponseCacheAdapter.java
+++ b/okhttp-urlconnection/src/main/java/com/squareup/okhttp/internal/huc/JavaApiConverter.java
@@ -13,73 +13,120 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.squareup.okhttp.internal.http;
+package com.squareup.okhttp.internal.huc;
 
 import com.squareup.okhttp.Handshake;
 import com.squareup.okhttp.Headers;
 import com.squareup.okhttp.MediaType;
-import com.squareup.okhttp.OkResponseCache;
 import com.squareup.okhttp.Request;
 import com.squareup.okhttp.Response;
-import com.squareup.okhttp.ResponseSource;
+import com.squareup.okhttp.ResponseBody;
+import com.squareup.okhttp.internal.Util;
+import com.squareup.okhttp.internal.http.OkHeaders;
+import com.squareup.okhttp.internal.http.StatusLine;
 import java.io.IOException;
 import java.io.InputStream;
 import java.io.OutputStream;
-import java.net.CacheRequest;
 import java.net.CacheResponse;
 import java.net.HttpURLConnection;
 import java.net.ProtocolException;
-import java.net.ResponseCache;
 import java.net.SecureCacheResponse;
 import java.net.URI;
+import java.net.URLConnection;
+import java.security.Principal;
 import java.security.cert.Certificate;
 import java.util.Collections;
 import java.util.List;
 import java.util.Map;
 import javax.net.ssl.HostnameVerifier;
+import javax.net.ssl.HttpsURLConnection;
 import javax.net.ssl.SSLPeerUnverifiedException;
 import javax.net.ssl.SSLSocketFactory;
+import okio.BufferedSource;
+import okio.Okio;
 
 /**
- * An adapter from {@link ResponseCache} to {@link com.squareup.okhttp.OkResponseCache}. This class
- * enables OkHttp to continue supporting Java standard response cache implementations.
+ * Helper methods that convert between Java and OkHttp representations.
  */
-public class ResponseCacheAdapter implements OkResponseCache {
+public final class JavaApiConverter {
 
-  private final ResponseCache delegate;
-
-  public ResponseCacheAdapter(ResponseCache delegate) {
-    this.delegate = delegate;
+  private JavaApiConverter() {
   }
 
-  public ResponseCache getDelegate() {
-    return delegate;
-  }
+  /**
+   * Creates an OkHttp {@link Response} using the supplied {@link URI} and {@link URLConnection}
+   * to supply the data. The URLConnection is assumed to already be connected.
+   */
+  public static Response createOkResponse(URI uri, URLConnection urlConnection) throws IOException {
+    HttpURLConnection httpUrlConnection = (HttpURLConnection) urlConnection;
 
-  @Override
-  public Response get(Request request) throws IOException {
-    CacheResponse javaResponse = getJavaCachedResponse(request);
-    if (javaResponse == null) {
-      return null;
+    Response.Builder okResponseBuilder = new Response.Builder();
+
+    // Request: Create one from the URL connection.
+    // A connected HttpURLConnection does not permit access to request headers.
+    Map<String, List<String>> requestHeaders = null;
+    Request okRequest = createOkRequest(uri, httpUrlConnection.getRequestMethod(), requestHeaders);
+    okResponseBuilder.request(okRequest);
+
+    // Status line
+    StatusLine statusLine = StatusLine.parse(extractStatusLine(httpUrlConnection));
+    okResponseBuilder.protocol(statusLine.protocol);
+    okResponseBuilder.code(statusLine.code);
+    okResponseBuilder.message(statusLine.message);
+
+    // Response headers
+    Headers okHeaders = extractOkResponseHeaders(httpUrlConnection);
+    okResponseBuilder.headers(okHeaders);
+
+    // Response body
+    ResponseBody okBody = createOkBody(okHeaders, urlConnection.getInputStream());
+    okResponseBuilder.body(okBody);
+
+    // Handle SSL handshake information as needed.
+    if (httpUrlConnection instanceof HttpsURLConnection) {
+      HttpsURLConnection httpsUrlConnection = (HttpsURLConnection) httpUrlConnection;
+
+      Certificate[] peerCertificates;
+      try {
+        peerCertificates = httpsUrlConnection.getServerCertificates();
+      } catch (SSLPeerUnverifiedException e) {
+        peerCertificates = null;
+      }
+
+      Certificate[] localCertificates = httpsUrlConnection.getLocalCertificates();
+
+      Handshake handshake = Handshake.get(
+          httpsUrlConnection.getCipherSuite(), nullSafeImmutableList(peerCertificates),
+          nullSafeImmutableList(localCertificates));
+      okResponseBuilder.handshake(handshake);
     }
 
+    return okResponseBuilder.build();
+  }
+
+  /**
+   * Creates an OkHttp {@link Response} using the supplied {@link Request} and {@link CacheResponse}
+   * to supply the data.
+   */
+  static Response createOkResponse(Request request, CacheResponse javaResponse)
+      throws IOException {
     Response.Builder okResponseBuilder = new Response.Builder();
 
     // Request: Use the one provided.
     okResponseBuilder.request(request);
 
-    // Status Line: Java has this as one of the headers.
-    okResponseBuilder.statusLine(extractStatusLine(javaResponse));
+    // Status line: Java has this as one of the headers.
+    StatusLine statusLine = StatusLine.parse(extractStatusLine(javaResponse));
+    okResponseBuilder.protocol(statusLine.protocol);
+    okResponseBuilder.code(statusLine.code);
+    okResponseBuilder.message(statusLine.message);
 
     // Response headers
     Headers okHeaders = extractOkHeaders(javaResponse);
     okResponseBuilder.headers(okHeaders);
 
-    // Meta data: Defaulted
-    okResponseBuilder.setResponseSource(ResponseSource.CACHE);
-
     // Response body
-    Response.Body okBody = createOkBody(okHeaders, javaResponse.getBody());
+    ResponseBody okBody = createOkBody(okHeaders, javaResponse.getBody());
     okResponseBuilder.body(okBody);
 
     // Handle SSL handshake information as needed.
@@ -105,55 +152,104 @@ public Response get(Request request) throws IOException {
     return okResponseBuilder.build();
   }
 
-  @Override
-  public CacheRequest put(Response response) throws IOException {
-    URI uri = response.request().uri();
-    HttpURLConnection connection = createJavaUrlConnection(response);
-    return delegate.put(uri, connection);
-  }
-
-  @Override
-  public boolean maybeRemove(Request request) throws IOException {
-    // This method is treated as optional and there is no obvious way of implementing it with
-    // ResponseCache. Removing items from the cache due to modifications made from this client is
-    // not essential given that modifications could be made from any other client. We have to assume
-    // that it's ok to keep using the cached data. Otherwise the server shouldn't declare it as
-    // cacheable or the client should be careful about caching it.
-    return false;
-  }
-
-  @Override
-  public void update(Response cached, Response network) throws IOException {
-    // This method is treated as optional and there is no obvious way of implementing it with
-    // ResponseCache. Updating headers is useful if the server changes the metadata for a resource
-    // (e.g. max age) to extend or truncate the life of that resource in the cache. If the metadata
-    // is not updated the caching behavior may not be optimal, but will obey the metadata sent
-    // with the original cached response.
-  }
+  /**
+   * Creates an OkHttp {@link Request} from the supplied information.
+   *
+   * <p>This method allows a {@code null} value for {@code requestHeaders} for situations
+   * where a connection is already connected and access to the headers has been lost.
+   * See {@link java.net.HttpURLConnection#getRequestProperties()} for details.
+   */
+  public static Request createOkRequest(
+      URI uri, String requestMethod, Map<String, List<String>> requestHeaders) {
 
-  @Override
-  public void trackConditionalCacheHit() {
-    // This method is treated as optional.
-  }
+    Request.Builder builder = new Request.Builder()
+        .url(uri.toString())
+        .method(requestMethod, null);
 
-  @Override
-  public void trackResponse(ResponseSource source) {
-    // This method is treated as optional.
+    if (requestHeaders != null) {
+      Headers headers = extractOkHeaders(requestHeaders);
+      builder.headers(headers);
+    }
+    return builder.build();
   }
 
   /**
-   * Returns the {@link CacheResponse} from the delegate by converting the
-   * OkHttp {@link Request} into the arguments required by the {@link ResponseCache}.
+   * Creates a {@link java.net.CacheResponse} of the correct (sub)type using information
+   * gathered from the supplied {@link Response}.
    */
-  private CacheResponse getJavaCachedResponse(Request request) throws IOException {
-    Map<String, List<String>> headers = extractJavaHeaders(request);
-    return delegate.get(request.uri(), request.method(), headers);
+  public static CacheResponse createJavaCacheResponse(final Response response) {
+    final Headers headers = response.headers();
+    final ResponseBody body = response.body();
+    if (response.request().isHttps()) {
+      final Handshake handshake = response.handshake();
+      return new SecureCacheResponse() {
+        @Override
+        public String getCipherSuite() {
+          return handshake != null ? handshake.cipherSuite() : null;
+        }
+
+        @Override
+        public List<Certificate> getLocalCertificateChain() {
+          if (handshake == null) return null;
+          // Java requires null, not an empty list here.
+          List<Certificate> certificates = handshake.localCertificates();
+          return certificates.size() > 0 ? certificates : null;
+        }
+
+        @Override
+        public List<Certificate> getServerCertificateChain() throws SSLPeerUnverifiedException {
+          if (handshake == null) return null;
+          // Java requires null, not an empty list here.
+          List<Certificate> certificates = handshake.peerCertificates();
+          return certificates.size() > 0 ? certificates : null;
+        }
+
+        @Override
+        public Principal getPeerPrincipal() throws SSLPeerUnverifiedException {
+          if (handshake == null) return null;
+          return handshake.peerPrincipal();
+        }
+
+        @Override
+        public Principal getLocalPrincipal() {
+          if (handshake == null) return null;
+          return handshake.localPrincipal();
+        }
+
+        @Override
+        public Map<String, List<String>> getHeaders() throws IOException {
+          // Java requires that the entry with a null key be the status line.
+          return OkHeaders.toMultimap(headers, StatusLine.get(response).toString());
+        }
+
+        @Override
+        public InputStream getBody() throws IOException {
+          if (body == null) return null;
+          return body.byteStream();
+        }
+      };
+    } else {
+      return new CacheResponse() {
+        @Override
+        public Map<String, List<String>> getHeaders() throws IOException {
+          // Java requires that the entry with a null key be the status line.
+          return OkHeaders.toMultimap(headers, StatusLine.get(response).toString());
+        }
+
+        @Override
+        public InputStream getBody() throws IOException {
+          if (body == null) return null;
+          return body.byteStream();
+        }
+      };
+    }
   }
 
   /**
-   * Creates an {@link HttpURLConnection} of the correct subclass from the supplied OkHttp response.
+   * Creates an {@link java.net.HttpURLConnection} of the correct subclass from the supplied OkHttp
+   * {@link Response}.
    */
-  private static HttpURLConnection createJavaUrlConnection(Response okResponse) {
+  static HttpURLConnection createJavaUrlConnection(Response okResponse) {
     Request request = okResponse.request();
     // Create an object of the correct class in case the ResponseCache uses instanceof.
     if (request.isHttps()) {
@@ -164,20 +260,47 @@ private static HttpURLConnection createJavaUrlConnection(Response okResponse) {
   }
 
   /**
-   * Extracts OkHttp headers from the supplied {@link CacheResponse}. Only real headers are
-   * extracted. The status line entry (which has a null key) is discarded.
-   * See {@link #extractStatusLine(java.net.CacheResponse)}.
+   * Extracts an immutable request header map from the supplied {@link com.squareup.okhttp.Headers}.
+   */
+  static Map<String, List<String>> extractJavaHeaders(Request request) {
+    return OkHeaders.toMultimap(request.headers(), null);
+  }
+
+  /**
+   * Extracts OkHttp headers from the supplied {@link java.net.CacheResponse}. Only real headers are
+   * extracted. See {@link #extractStatusLine(java.net.CacheResponse)}.
    */
   private static Headers extractOkHeaders(CacheResponse javaResponse) throws IOException {
-    Map<String, List<String>> cachedHeaders = javaResponse.getHeaders();
+    Map<String, List<String>> javaResponseHeaders = javaResponse.getHeaders();
+    return extractOkHeaders(javaResponseHeaders);
+  }
+
+  /**
+   * Extracts OkHttp headers from the supplied {@link java.net.HttpURLConnection}. Only real headers
+   * are extracted. See {@link #extractStatusLine(java.net.HttpURLConnection)}.
+   */
+  private static Headers extractOkResponseHeaders(HttpURLConnection httpUrlConnection) {
+    Map<String, List<String>> javaResponseHeaders = httpUrlConnection.getHeaderFields();
+    return extractOkHeaders(javaResponseHeaders);
+  }
+
+  /**
+   * Extracts OkHttp headers from the supplied {@link Map}. Only real headers are
+   * extracted. Any entry (one with a {@code null} key) is discarded.
+   */
+  // @VisibleForTesting
+  static Headers extractOkHeaders(Map<String, List<String>> javaHeaders) {
     Headers.Builder okHeadersBuilder = new Headers.Builder();
-    for (Map.Entry<String, List<String>> cachedHeader : cachedHeaders.entrySet()) {
-      String name = cachedHeader.getKey();
+    for (Map.Entry<String, List<String>> javaHeader : javaHeaders.entrySet()) {
+      String name = javaHeader.getKey();
       if (name == null) {
-        // The Java API uses the null key to store the status line.
+        // The Java API uses the null key to store the status line in responses.
+        // Earlier versions of OkHttp would use the null key to store the "request line" in
+        // requests. e.g. "GET / HTTP 1.1". Although this is no longer the case it must be
+        // explicitly ignored because Headers.Builder does not support null keys.
         continue;
       }
-      for (String value : cachedHeader.getValue()) {
+      for (String value : javaHeader.getValue()) {
         okHeadersBuilder.add(name, value);
       }
     }
@@ -185,59 +308,58 @@ private static Headers extractOkHeaders(CacheResponse javaResponse) throws IOExc
   }
 
   /**
-   * Extracts the status line {@link CacheResponse} from the supplied Java API response. As per the
-   * spec, the status line is held as the header with the null key. Returns {@code null} if there is
-   * no status line.
+   * Extracts the status line from the supplied Java API {@link java.net.HttpURLConnection}.
+   * As per the spec, the status line is held as the header with the null key. Returns {@code null}
+   * if there is no status line.
+   */
+  private static String extractStatusLine(HttpURLConnection httpUrlConnection) {
+    // Java specifies that this will be be response header with a null key.
+    return httpUrlConnection.getHeaderField(null);
+  }
+
+  /**
+   * Extracts the status line from the supplied Java API {@link java.net.CacheResponse}.
+   * As per the spec, the status line is held as the header with the null key. Returns {@code null}
+   * if there is no status line.
    */
   private static String extractStatusLine(CacheResponse javaResponse) throws IOException {
-    List<String> values = javaResponse.getHeaders().get(null);
+    Map<String, List<String>> javaResponseHeaders = javaResponse.getHeaders();
+    return extractStatusLine(javaResponseHeaders);
+  }
+
+  // VisibleForTesting
+  static String extractStatusLine(Map<String, List<String>> javaResponseHeaders) {
+    List<String> values = javaResponseHeaders.get(null);
     if (values == null || values.size() == 0) {
       return null;
     }
     return values.get(0);
   }
 
-  /**
-   * Extracts an immutable header map from the supplied {@link Headers}.
-   */
-  private static Map<String, List<String>> extractJavaHeaders(Request request) {
-    return OkHeaders.toMultimap(request.headers(), null);
-  }
-
   /**
    * Creates an OkHttp Response.Body containing the supplied information.
    */
-  private static Response.Body createOkBody(final Headers okHeaders, final InputStream body) {
-    return new Response.Body() {
-
-      @Override
-      public boolean ready() throws IOException {
-        return true;
-      }
-
-      @Override
-      public MediaType contentType() {
+  private static ResponseBody createOkBody(final Headers okHeaders, InputStream body) {
+    final BufferedSource source = Okio.buffer(Okio.source(body));
+    return new ResponseBody() {
+      @Override public MediaType contentType() {
         String contentTypeHeader = okHeaders.get("Content-Type");
         return contentTypeHeader == null ? null : MediaType.parse(contentTypeHeader);
       }
-
-      @Override
-      public long contentLength() {
+      @Override public long contentLength() {
         return OkHeaders.contentLength(okHeaders);
       }
-
-      @Override
-      public InputStream byteStream() {
-        return body;
+      @Override public BufferedSource source() {
+        return source;
       }
     };
   }
 
   /**
-   * An {@link HttpURLConnection} that represents an HTTP request at the point where
+   * An {@link java.net.HttpURLConnection} that represents an HTTP request at the point where
    * the request has been made, and the response headers have been received, but the body content,
    * if present, has not been read yet. This intended to provide enough information for
-   * {@link ResponseCache} subclasses and no more.
+   * {@link java.net.ResponseCache} subclasses and no more.
    *
    * <p>Much of the method implementations are overrides to delegate to the OkHttp request and
    * response, or to deny access to information as a real HttpURLConnection would after connection.
@@ -353,19 +475,21 @@ public String getHeaderField(int position) {
         throw new IllegalArgumentException("Invalid header index: " + position);
       }
       if (position == 0) {
-        return response.statusLine();
+        return StatusLine.get(response).toString();
       }
       return response.headers().value(position - 1);
     }
 
     @Override
     public String getHeaderField(String fieldName) {
-      return fieldName == null ? response.statusLine() : response.headers().get(fieldName);
+      return fieldName == null
+          ? StatusLine.get(response).toString()
+          : response.headers().get(fieldName);
     }
 
     @Override
     public Map<String, List<String>> getHeaderFields() {
-      return OkHeaders.toMultimap(response.headers(), response.statusLine());
+      return OkHeaders.toMultimap(response.headers(), StatusLine.get(response).toString());
     }
 
     @Override
@@ -375,7 +499,7 @@ public int getResponseCode() throws IOException {
 
     @Override
     public String getResponseMessage() throws IOException {
-      return response.statusMessage();
+      return response.message();
     }
 
     @Override
@@ -554,4 +678,9 @@ private static RuntimeException throwRequestSslAccessException() {
   private static RuntimeException throwResponseBodyAccessException() {
     throw new UnsupportedOperationException("ResponseCache cannot access the response body.");
   }
+
+  private static <T> List<T> nullSafeImmutableList(T[] elements) {
+    return elements == null ? Collections.<T>emptyList() : Util.immutableList(elements);
+  }
+
 }
diff --git a/okhttp-urlconnection/src/test/java/com/squareup/okhttp/OkUrlFactoryTest.java b/okhttp-urlconnection/src/test/java/com/squareup/okhttp/OkUrlFactoryTest.java
new file mode 100644
index 0000000000..5a2d565bf1
--- /dev/null
+++ b/okhttp-urlconnection/src/test/java/com/squareup/okhttp/OkUrlFactoryTest.java
@@ -0,0 +1,165 @@
+package com.squareup.okhttp;
+
+import com.squareup.okhttp.mockwebserver.MockResponse;
+import com.squareup.okhttp.mockwebserver.MockWebServer;
+import com.squareup.okhttp.mockwebserver.rule.MockWebServerRule;
+import java.io.IOException;
+import java.net.HttpURLConnection;
+import java.text.DateFormat;
+import java.text.SimpleDateFormat;
+import java.util.Date;
+import java.util.Locale;
+import java.util.TimeZone;
+import java.util.concurrent.TimeUnit;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.rules.TemporaryFolder;
+
+import static java.nio.charset.StandardCharsets.US_ASCII;
+import static okio.Okio.buffer;
+import static okio.Okio.source;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.fail;
+
+public class OkUrlFactoryTest {
+  @Rule public MockWebServerRule serverRule = new MockWebServerRule();
+  @Rule public TemporaryFolder cacheFolder = new TemporaryFolder();
+
+  private MockWebServer server;
+  private OkUrlFactory factory;
+
+  @Before public void setUp() throws IOException {
+    server = serverRule.get();
+
+    OkHttpClient client = new OkHttpClient();
+    client.setCache(new Cache(cacheFolder.getRoot(), 10 * 1024 * 1024));
+    factory = new OkUrlFactory(client);
+  }
+
+  /**
+   * Response code 407 should only come from proxy servers. Android's client
+   * throws if it is sent by an origin server.
+   */
+  @Test public void originServerSends407() throws Exception {
+    server.enqueue(new MockResponse().setResponseCode(407));
+
+    HttpURLConnection conn = factory.open(server.getUrl("/"));
+    try {
+      conn.getResponseCode();
+      fail();
+    } catch (IOException ignored) {
+    }
+  }
+
+  @Test public void networkResponseSourceHeader() throws Exception {
+    server.enqueue(new MockResponse().setBody("Isla Sorna"));
+
+    HttpURLConnection connection = factory.open(server.getUrl("/"));
+    assertResponseHeader(connection, "NETWORK 200");
+    assertResponseBody(connection, "Isla Sorna");
+  }
+
+  @Test public void networkFailureResponseSourceHeader() throws Exception {
+    server.enqueue(new MockResponse().setResponseCode(404));
+
+    HttpURLConnection connection = factory.open(server.getUrl("/"));
+    assertResponseHeader(connection, "NETWORK 404");
+  }
+
+  @Test public void conditionalCacheHitResponseSourceHeaders() throws Exception {
+    server.enqueue(new MockResponse()
+        .addHeader("Last-Modified: " + formatDate(0, TimeUnit.SECONDS))
+        .addHeader("Cache-Control: max-age=0")
+        .setBody("Isla Nublar"));
+    server.enqueue(new MockResponse().setResponseCode(304));
+
+    HttpURLConnection connection1 = factory.open(server.getUrl("/"));
+    assertResponseHeader(connection1, "NETWORK 200");
+    assertResponseBody(connection1, "Isla Nublar");
+
+    HttpURLConnection connection2 = factory.open(server.getUrl("/"));
+    assertResponseHeader(connection2, "CONDITIONAL_CACHE 304");
+    assertResponseBody(connection2, "Isla Nublar");
+  }
+
+  @Test public void conditionalCacheMissResponseSourceHeaders() throws Exception {
+    server.enqueue(new MockResponse()
+        .addHeader("Last-Modified: " + formatDate(0, TimeUnit.SECONDS))
+        .addHeader("Cache-Control: max-age=0")
+        .setBody("Isla Nublar"));
+    server.enqueue(new MockResponse().setBody("Isla Sorna"));
+
+    HttpURLConnection connection1 = factory.open(server.getUrl("/"));
+    assertResponseHeader(connection1, "NETWORK 200");
+    assertResponseBody(connection1, "Isla Nublar");
+
+    HttpURLConnection connection2 = factory.open(server.getUrl("/"));
+    assertResponseHeader(connection2, "CONDITIONAL_CACHE 200");
+    assertResponseBody(connection2, "Isla Sorna");
+  }
+
+  @Test public void cacheResponseSourceHeaders() throws Exception {
+    server.enqueue(new MockResponse()
+        .addHeader("Expires: " + formatDate(2, TimeUnit.HOURS))
+        .setBody("Isla Nublar"));
+
+    HttpURLConnection connection1 = factory.open(server.getUrl("/"));
+    assertResponseHeader(connection1, "NETWORK 200");
+    assertResponseBody(connection1, "Isla Nublar");
+
+    HttpURLConnection connection2 = factory.open(server.getUrl("/"));
+    assertResponseHeader(connection2, "CACHE 200");
+    assertResponseBody(connection2, "Isla Nublar");
+  }
+
+  @Test public void noneResponseSourceHeaders() throws Exception {
+    server.enqueue(new MockResponse().setBody("Isla Nublar"));
+
+    HttpURLConnection connection1 = factory.open(server.getUrl("/"));
+    assertResponseHeader(connection1, "NETWORK 200");
+    assertResponseBody(connection1, "Isla Nublar");
+
+    HttpURLConnection connection2 = factory.open(server.getUrl("/"));
+    connection2.setRequestProperty("Cache-Control", "only-if-cached");
+    assertResponseHeader(connection2, "NONE");
+  }
+
+  @Test
+  public void setInstanceFollowRedirectsFalse() throws Exception {
+    server.enqueue(new MockResponse()
+        .setResponseCode(302)
+        .addHeader("Location: /b")
+        .setBody("A"));
+    server.enqueue(new MockResponse()
+        .setBody("B"));
+
+    HttpURLConnection connection = factory.open(server.getUrl("/a"));
+    connection.setInstanceFollowRedirects(false);
+    assertResponseBody(connection, "A");
+    assertResponseCode(connection, 302);
+  }
+
+  private void assertResponseBody(HttpURLConnection connection, String expected) throws Exception {
+    String actual = buffer(source(connection.getInputStream())).readString(US_ASCII);
+    assertEquals(expected, actual);
+  }
+
+  private void assertResponseHeader(HttpURLConnection connection, String expected) {
+    assertEquals(expected, connection.getHeaderField("OkHttp-Response-Source"));
+  }
+
+  private void assertResponseCode(HttpURLConnection connection, int expected) throws IOException {
+    assertEquals(expected, connection.getResponseCode());
+  }
+
+  private static String formatDate(long delta, TimeUnit timeUnit) {
+    return formatDate(new Date(System.currentTimeMillis() + timeUnit.toMillis(delta)));
+  }
+
+  private static String formatDate(Date date) {
+    DateFormat rfc1123 = new SimpleDateFormat("EEE, dd MMM yyyy HH:mm:ss zzz", Locale.US);
+    rfc1123.setTimeZone(TimeZone.getTimeZone("GMT"));
+    return rfc1123.format(date);
+  }
+}
diff --git a/okhttp/pom.xml b/okhttp/pom.xml
index 25e165f119..c98e5dbcaf 100644
--- a/okhttp/pom.xml
+++ b/okhttp/pom.xml
@@ -6,7 +6,7 @@
   <parent>
     <groupId>com.squareup.okhttp</groupId>
     <artifactId>parent</artifactId>
-    <version>2.0.0-SNAPSHOT</version>
+    <version>2.0.1-SNAPSHOT</version>
   </parent>
 
   <artifactId>okhttp</artifactId>
@@ -16,12 +16,6 @@
     <dependency>
       <groupId>com.squareup.okio</groupId>
       <artifactId>okio</artifactId>
-      <version>${project.version}</version>
-    </dependency>
-    <dependency>
-      <groupId>com.squareup.okhttp</groupId>
-      <artifactId>okhttp-protocols</artifactId>
-      <version>${project.version}</version>
     </dependency>
   </dependencies>
 
@@ -32,6 +26,9 @@
         <artifactId>maven-javadoc-plugin</artifactId>
         <configuration>
           <excludePackageNames>com.squareup.okhttp.internal:com.squareup.okhttp.internal.*</excludePackageNames>
+          <links>
+            <link>http://square.github.io/okio/</link>
+          </links>
         </configuration>
       </plugin>
     </plugins>
diff --git a/okhttp/src/main/java/com/squareup/okhttp/Address.java b/okhttp/src/main/java/com/squareup/okhttp/Address.java
index ebda2a64a5..80d59145dd 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/Address.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/Address.java
@@ -17,8 +17,8 @@
 
 import com.squareup.okhttp.internal.Util;
 import java.net.Proxy;
-import java.net.UnknownHostException;
 import java.util.List;
+import javax.net.SocketFactory;
 import javax.net.ssl.HostnameVerifier;
 import javax.net.ssl.SSLSocketFactory;
 
@@ -27,7 +27,7 @@
 /**
  * A specification for a connection to an origin server. For simple connections,
  * this is the server's hostname and port. If an explicit proxy is requested (or
- * {@link Proxy#NO_PROXY no proxy} is explicitly requested), this also includes
+ * {@linkplain Proxy#NO_PROXY no proxy} is explicitly requested), this also includes
  * that proxy information. For secure connections the address also includes the
  * SSL socket factory and hostname verifier.
  *
@@ -38,14 +38,15 @@
   final Proxy proxy;
   final String uriHost;
   final int uriPort;
+  final SocketFactory socketFactory;
   final SSLSocketFactory sslSocketFactory;
   final HostnameVerifier hostnameVerifier;
-  final OkAuthenticator authenticator;
+  final Authenticator authenticator;
   final List<Protocol> protocols;
 
-  public Address(String uriHost, int uriPort, SSLSocketFactory sslSocketFactory,
-      HostnameVerifier hostnameVerifier, OkAuthenticator authenticator, Proxy proxy,
-      List<Protocol> protocols) throws UnknownHostException {
+  public Address(String uriHost, int uriPort, SocketFactory socketFactory,
+      SSLSocketFactory sslSocketFactory, HostnameVerifier hostnameVerifier,
+      Authenticator authenticator, Proxy proxy, List<Protocol> protocols) {
     if (uriHost == null) throw new NullPointerException("uriHost == null");
     if (uriPort <= 0) throw new IllegalArgumentException("uriPort <= 0: " + uriPort);
     if (authenticator == null) throw new IllegalArgumentException("authenticator == null");
@@ -53,6 +54,7 @@ public Address(String uriHost, int uriPort, SSLSocketFactory sslSocketFactory,
     this.proxy = proxy;
     this.uriHost = uriHost;
     this.uriPort = uriPort;
+    this.socketFactory = socketFactory;
     this.sslSocketFactory = sslSocketFactory;
     this.hostnameVerifier = hostnameVerifier;
     this.authenticator = authenticator;
@@ -72,6 +74,11 @@ public int getUriPort() {
     return uriPort;
   }
 
+  /** Returns the socket factory for new connections. */
+  public SocketFactory getSocketFactory() {
+    return socketFactory;
+  }
+
   /**
    * Returns the SSL socket factory, or null if this is not an HTTPS
    * address.
@@ -88,18 +95,16 @@ public HostnameVerifier getHostnameVerifier() {
     return hostnameVerifier;
   }
 
-
   /**
    * Returns the client's authenticator. This method never returns null.
    */
-  public OkAuthenticator getAuthenticator() {
+  public Authenticator getAuthenticator() {
     return authenticator;
   }
 
   /**
    * Returns the protocols the client supports. This method always returns a
-   * non-null list that contains minimally
-   * {@link Protocol#HTTP_11}.
+   * non-null list that contains minimally {@link Protocol#HTTP_1_1}.
    */
   public List<Protocol> getProtocols() {
     return protocols;
@@ -133,7 +138,7 @@ public Proxy getProxy() {
     result = 31 * result + uriPort;
     result = 31 * result + (sslSocketFactory != null ? sslSocketFactory.hashCode() : 0);
     result = 31 * result + (hostnameVerifier != null ? hostnameVerifier.hashCode() : 0);
-    result = 31 * result + (authenticator != null ? authenticator.hashCode() : 0);
+    result = 31 * result + authenticator.hashCode();
     result = 31 * result + (proxy != null ? proxy.hashCode() : 0);
     result = 31 * result + protocols.hashCode();
     return result;
diff --git a/okhttp/src/main/java/com/squareup/okhttp/Authenticator.java b/okhttp/src/main/java/com/squareup/okhttp/Authenticator.java
new file mode 100644
index 0000000000..cb66dc6249
--- /dev/null
+++ b/okhttp/src/main/java/com/squareup/okhttp/Authenticator.java
@@ -0,0 +1,60 @@
+/*
+ * Copyright (C) 2013 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.okhttp;
+
+import java.io.IOException;
+import java.net.Proxy;
+
+/**
+ * Responds to authentication challenges from the remote web or proxy server.
+ */
+public interface Authenticator {
+  /**
+   * Returns a request that includes a credential to satisfy an authentication
+   * challenge in {@code response}. Returns null if the challenge cannot be
+   * satisfied. This method is called in response to an HTTP 401 unauthorized
+   * status code sent by the origin server.
+   *
+   * <p>Typical implementations will look up a credential and create a request
+   * derived from the initial request by setting the "Authorization" header.
+   * <pre>   {@code
+   *
+   *    String credential = Credentials.basic(...)
+   *    return response.request().newBuilder()
+   *        .header("Authorization", credential)
+   *        .build();
+   * }</pre>
+   */
+  Request authenticate(Proxy proxy, Response response) throws IOException;
+
+  /**
+   * Returns a request that includes a credential to satisfy an authentication
+   * challenge made by {@code response}. Returns null if the challenge cannot be
+   * satisfied. This method is called in response to an HTTP 407 unauthorized
+   * status code sent by the proxy server.
+   *
+   * <p>Typical implementations will look up a credential and create a request
+   * derived from the initial request by setting the "Proxy-Authorization"
+   * header. <pre>   {@code
+   *
+   *    String credential = Credentials.basic(...)
+   *    return response.request().newBuilder()
+   *        .header("Proxy-Authorization", credential)
+   *        .build();
+   * }</pre>
+   */
+  Request authenticateProxy(Proxy proxy, Response response) throws IOException;
+}
diff --git a/okhttp/src/main/java/com/squareup/okhttp/HttpResponseCache.java b/okhttp/src/main/java/com/squareup/okhttp/Cache.java
similarity index 72%
rename from okhttp/src/main/java/com/squareup/okhttp/HttpResponseCache.java
rename to okhttp/src/main/java/com/squareup/okhttp/Cache.java
index c6edf4b79d..373feb0313 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/HttpResponseCache.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/Cache.java
@@ -17,23 +17,16 @@
 package com.squareup.okhttp;
 
 import com.squareup.okhttp.internal.DiskLruCache;
+import com.squareup.okhttp.internal.InternalCache;
 import com.squareup.okhttp.internal.Util;
+import com.squareup.okhttp.internal.http.CacheRequest;
+import com.squareup.okhttp.internal.http.CacheStrategy;
 import com.squareup.okhttp.internal.http.HttpMethod;
-import java.io.BufferedWriter;
+import com.squareup.okhttp.internal.http.OkHeaders;
+import com.squareup.okhttp.internal.http.StatusLine;
 import java.io.ByteArrayInputStream;
 import java.io.File;
-import java.io.FilterInputStream;
-import java.io.FilterOutputStream;
 import java.io.IOException;
-import java.io.InputStream;
-import java.io.OutputStream;
-import java.io.OutputStreamWriter;
-import java.io.Writer;
-import java.net.CacheRequest;
-import java.net.CacheResponse;
-import java.net.ResponseCache;
-import java.net.URI;
-import java.net.URLConnection;
 import java.security.cert.Certificate;
 import java.security.cert.CertificateEncodingException;
 import java.security.cert.CertificateException;
@@ -41,12 +34,14 @@
 import java.util.ArrayList;
 import java.util.Collections;
 import java.util.List;
-import java.util.Map;
+import okio.BufferedSink;
 import okio.BufferedSource;
 import okio.ByteString;
+import okio.ForwardingSink;
+import okio.ForwardingSource;
 import okio.Okio;
-
-import static com.squareup.okhttp.internal.Util.UTF_8;
+import okio.Sink;
+import okio.Source;
 
 /**
  * Caches HTTP and HTTPS responses to the filesystem so they may be reused,
@@ -55,11 +50,11 @@
  * <h3>Cache Optimization</h3>
  * To measure cache effectiveness, this class tracks three statistics:
  * <ul>
- *     <li><strong>{@link #getRequestCount() Request Count:}</strong> the number
- *         of HTTP requests issued since this cache was created.
- *     <li><strong>{@link #getNetworkCount() Network Count:}</strong> the
+ *     <li><strong>{@linkplain #getRequestCount() Request Count:}</strong> the
+ *         number of HTTP requests issued since this cache was created.
+ *     <li><strong>{@linkplain #getNetworkCount() Network Count:}</strong> the
  *         number of those requests that required network use.
- *     <li><strong>{@link #getHitCount() Hit Count:}</strong> the number of
+ *     <li><strong>{@linkplain #getHitCount() Hit Count:}</strong> the number of
  *         those requests whose responses were served by the cache.
  * </ul>
  * Sometimes a request will result in a conditional cache hit. If the cache
@@ -105,13 +100,34 @@
  *         connection.addRequestProperty("Cache-Control", "max-stale=" + maxStale);
  * }</pre>
  */
-public final class HttpResponseCache extends ResponseCache implements OkResponseCache {
+public final class Cache {
   // TODO: add APIs to iterate the cache?
   private static final int VERSION = 201105;
   private static final int ENTRY_METADATA = 0;
   private static final int ENTRY_BODY = 1;
   private static final int ENTRY_COUNT = 2;
 
+  final InternalCache internalCache = new InternalCache() {
+    @Override public Response get(Request request) throws IOException {
+      return Cache.this.get(request);
+    }
+    @Override public CacheRequest put(Response response) throws IOException {
+      return Cache.this.put(response);
+    }
+    @Override public void remove(Request request) throws IOException {
+      Cache.this.remove(request);
+    }
+    @Override public void update(Response cached, Response network) throws IOException {
+      Cache.this.update(cached, network);
+    }
+    @Override public void trackConditionalCacheHit() {
+      Cache.this.trackConditionalCacheHit();
+    }
+    @Override public void trackResponse(CacheStrategy cacheStrategy) {
+      Cache.this.trackResponse(cacheStrategy);
+    }
+  };
+
   private final DiskLruCache cache;
 
   /* read and write statistics, all guarded by 'this' */
@@ -121,24 +137,15 @@
   private int hitCount;
   private int requestCount;
 
-  public HttpResponseCache(File directory, long maxSize) throws IOException {
+  public Cache(File directory, long maxSize) throws IOException {
     cache = DiskLruCache.open(directory, VERSION, ENTRY_COUNT, maxSize);
   }
 
-  @Override public CacheResponse get(URI uri, String s, Map<String, List<String>> stringListMap)
-      throws IOException {
-    throw new UnsupportedOperationException("This is not a general purpose response cache.");
+  private static String urlToKey(Request request) {
+    return Util.hash(request.urlString());
   }
 
-  @Override public CacheRequest put(URI uri, URLConnection urlConnection) throws IOException {
-    throw new UnsupportedOperationException("This is not a general purpose response cache.");
-  }
-
-  private static String urlToKey(Request requst) {
-    return Util.hash(requst.urlString());
-  }
-
-  @Override public Response get(Request request) {
+  Response get(Request request) {
     String key = urlToKey(request);
     DiskLruCache.Snapshot snapshot;
     Entry entry;
@@ -147,12 +154,18 @@ private static String urlToKey(Request requst) {
       if (snapshot == null) {
         return null;
       }
-      entry = new Entry(snapshot.getInputStream(ENTRY_METADATA));
     } catch (IOException e) {
       // Give up because the cache cannot be read.
       return null;
     }
 
+    try {
+      entry = new Entry(snapshot.getSource(ENTRY_METADATA));
+    } catch (IOException e) {
+      Util.closeQuietly(snapshot);
+      return null;
+    }
+
     Response response = entry.response(request, snapshot);
 
     if (!entry.matches(request, response)) {
@@ -163,10 +176,15 @@ private static String urlToKey(Request requst) {
     return response;
   }
 
-  @Override public CacheRequest put(Response response) throws IOException {
+  private CacheRequest put(Response response) throws IOException {
     String requestMethod = response.request().method();
 
-    if (maybeRemove(response.request())) {
+    if (HttpMethod.invalidatesCache(response.request().method())) {
+      try {
+        remove(response.request());
+      } catch (IOException ignored) {
+        // The cache cannot be written.
+      }
       return null;
     }
     if (!requestMethod.equals("GET")) {
@@ -176,7 +194,7 @@ private static String urlToKey(Request requst) {
       return null;
     }
 
-    if (response.hasVaryAll()) {
+    if (OkHeaders.hasVaryAll(response)) {
       return null;
     }
 
@@ -195,19 +213,11 @@ private static String urlToKey(Request requst) {
     }
   }
 
-  @Override public boolean maybeRemove(Request request) {
-    if (HttpMethod.invalidatesCache(request.method())) {
-      try {
-        cache.remove(urlToKey(request));
-      } catch (IOException ignored) {
-        // The cache cannot be written.
-      }
-      return true;
-    }
-    return false;
+  private void remove(Request request) throws IOException {
+    cache.remove(urlToKey(request));
   }
 
-  @Override public void update(Response cached, Response network) {
+  private void update(Response cached, Response network) {
     Entry entry = new Entry(network);
     DiskLruCache.Snapshot snapshot = ((CacheResponseBody) cached.body()).snapshot;
     DiskLruCache.Editor editor = null;
@@ -273,21 +283,20 @@ public boolean isClosed() {
     return cache.isClosed();
   }
 
-  @Override public synchronized void trackResponse(ResponseSource source) {
+  private synchronized void trackResponse(CacheStrategy cacheStrategy) {
     requestCount++;
 
-    switch (source) {
-      case CACHE:
-        hitCount++;
-        break;
-      case CONDITIONAL_CACHE:
-      case NETWORK:
-        networkCount++;
-        break;
+    if (cacheStrategy.networkRequest != null) {
+      // If this is a conditional request, we'll increment hitCount if/when it hits.
+      networkCount++;
+
+    } else if (cacheStrategy.cacheResponse != null) {
+      // This response uses the cache and not the network. That's a cache hit.
+      hitCount++;
     }
   }
 
-  @Override public synchronized void trackConditionalCacheHit() {
+  private synchronized void trackConditionalCacheHit() {
     hitCount++;
   }
 
@@ -303,18 +312,18 @@ public synchronized int getRequestCount() {
     return requestCount;
   }
 
-  private final class CacheRequestImpl extends CacheRequest {
+  private final class CacheRequestImpl implements CacheRequest {
     private final DiskLruCache.Editor editor;
-    private OutputStream cacheOut;
+    private Sink cacheOut;
     private boolean done;
-    private OutputStream body;
+    private Sink body;
 
     public CacheRequestImpl(final DiskLruCache.Editor editor) throws IOException {
       this.editor = editor;
-      this.cacheOut = editor.newOutputStream(ENTRY_BODY);
-      this.body = new FilterOutputStream(cacheOut) {
+      this.cacheOut = editor.newSink(ENTRY_BODY);
+      this.body = new ForwardingSink(cacheOut) {
         @Override public void close() throws IOException {
-          synchronized (HttpResponseCache.this) {
+          synchronized (Cache.this) {
             if (done) {
               return;
             }
@@ -324,17 +333,11 @@ public CacheRequestImpl(final DiskLruCache.Editor editor) throws IOException {
           super.close();
           editor.commit();
         }
-
-        @Override public void write(byte[] buffer, int offset, int length) throws IOException {
-          // Since we don't override "write(int oneByte)", we can write directly to "out"
-          // and avoid the inefficient implementation from the FilterOutputStream.
-          out.write(buffer, offset, length);
-        }
       };
     }
 
     @Override public void abort() {
-      synchronized (HttpResponseCache.this) {
+      synchronized (Cache.this) {
         if (done) {
           return;
         }
@@ -348,7 +351,7 @@ public CacheRequestImpl(final DiskLruCache.Editor editor) throws IOException {
       }
     }
 
-    @Override public OutputStream getBody() throws IOException {
+    @Override public Sink body() {
       return body;
     }
   }
@@ -357,7 +360,9 @@ public CacheRequestImpl(final DiskLruCache.Editor editor) throws IOException {
     private final String url;
     private final Headers varyHeaders;
     private final String requestMethod;
-    private final String statusLine;
+    private final Protocol protocol;
+    private final int code;
+    private final String message;
     private final Headers responseHeaders;
     private final Handshake handshake;
 
@@ -410,9 +415,9 @@ public CacheRequestImpl(final DiskLruCache.Editor editor) throws IOException {
      * certificates are also base64-encoded and appear each on their own
      * line. A length of -1 is used to encode a null array.
      */
-    public Entry(InputStream in) throws IOException {
+    public Entry(Source in) throws IOException {
       try {
-        BufferedSource source = Okio.buffer(Okio.source(in));
+        BufferedSource source = Okio.buffer(in);
         url = source.readUtf8LineStrict();
         requestMethod = source.readUtf8LineStrict();
         Headers.Builder varyHeadersBuilder = new Headers.Builder();
@@ -422,7 +427,10 @@ public Entry(InputStream in) throws IOException {
         }
         varyHeaders = varyHeadersBuilder.build();
 
-        statusLine = source.readUtf8LineStrict();
+        StatusLine statusLine = StatusLine.parse(source.readUtf8LineStrict());
+        protocol = statusLine.protocol;
+        code = statusLine.code;
+        message = statusLine.message;
         Headers.Builder responseHeadersBuilder = new Headers.Builder();
         int responseHeaderLineCount = readInt(source);
         for (int i = 0; i < responseHeaderLineCount; i++) {
@@ -449,37 +457,50 @@ public Entry(InputStream in) throws IOException {
 
     public Entry(Response response) {
       this.url = response.request().urlString();
-      this.varyHeaders = response.request().headers().getAll(response.getVaryFields());
+      this.varyHeaders = OkHeaders.varyHeaders(response);
       this.requestMethod = response.request().method();
-      this.statusLine = response.statusLine();
+      this.protocol = response.protocol();
+      this.code = response.code();
+      this.message = response.message();
       this.responseHeaders = response.headers();
       this.handshake = response.handshake();
     }
 
     public void writeTo(DiskLruCache.Editor editor) throws IOException {
-      OutputStream out = editor.newOutputStream(ENTRY_METADATA);
-      Writer writer = new BufferedWriter(new OutputStreamWriter(out, UTF_8));
-
-      writer.write(url + '\n');
-      writer.write(requestMethod + '\n');
-      writer.write(Integer.toString(varyHeaders.size()) + '\n');
+      BufferedSink sink = Okio.buffer(editor.newSink(ENTRY_METADATA));
+
+      sink.writeUtf8(url);
+      sink.writeByte('\n');
+      sink.writeUtf8(requestMethod);
+      sink.writeByte('\n');
+      sink.writeUtf8(Integer.toString(varyHeaders.size()));
+      sink.writeByte('\n');
       for (int i = 0; i < varyHeaders.size(); i++) {
-        writer.write(varyHeaders.name(i) + ": " + varyHeaders.value(i) + '\n');
+        sink.writeUtf8(varyHeaders.name(i));
+        sink.writeUtf8(": ");
+        sink.writeUtf8(varyHeaders.value(i));
+        sink.writeByte('\n');
       }
 
-      writer.write(statusLine + '\n');
-      writer.write(Integer.toString(responseHeaders.size()) + '\n');
+      sink.writeUtf8(new StatusLine(protocol, code, message).toString());
+      sink.writeByte('\n');
+      sink.writeUtf8(Integer.toString(responseHeaders.size()));
+      sink.writeByte('\n');
       for (int i = 0; i < responseHeaders.size(); i++) {
-        writer.write(responseHeaders.name(i) + ": " + responseHeaders.value(i) + '\n');
+        sink.writeUtf8(responseHeaders.name(i));
+        sink.writeUtf8(": ");
+        sink.writeUtf8(responseHeaders.value(i));
+        sink.writeByte('\n');
       }
 
       if (isHttps()) {
-        writer.write('\n');
-        writer.write(handshake.cipherSuite() + '\n');
-        writeCertArray(writer, handshake.peerCertificates());
-        writeCertArray(writer, handshake.localCertificates());
+        sink.writeByte('\n');
+        sink.writeUtf8(handshake.cipherSuite());
+        sink.writeByte('\n');
+        writeCertArray(sink, handshake.peerCertificates());
+        writeCertArray(sink, handshake.localCertificates());
       }
-      writer.close();
+      sink.close();
     }
 
     private boolean isHttps() {
@@ -492,7 +513,7 @@ private boolean isHttps() {
 
       try {
         CertificateFactory certificateFactory = CertificateFactory.getInstance("X.509");
-        List<Certificate> result = new ArrayList<Certificate>(length);
+        List<Certificate> result = new ArrayList<>(length);
         for (int i = 0; i < length; i++) {
           String line = source.readUtf8LineStrict();
           byte[] bytes = ByteString.decodeBase64(line).toByteArray();
@@ -504,13 +525,16 @@ private boolean isHttps() {
       }
     }
 
-    private void writeCertArray(Writer writer, List<Certificate> certificates) throws IOException {
+    private void writeCertArray(BufferedSink sink, List<Certificate> certificates)
+        throws IOException {
       try {
-        writer.write(Integer.toString(certificates.size()) + '\n');
+        sink.writeUtf8(Integer.toString(certificates.size()));
+        sink.writeByte('\n');
         for (int i = 0, size = certificates.size(); i < size; i++) {
           byte[] bytes = certificates.get(i).getEncoded();
           String line = ByteString.of(bytes).base64();
-          writer.write(line + '\n');
+          sink.writeUtf8(line);
+          sink.writeByte('\n');
         }
       } catch (CertificateEncodingException e) {
         throw new IOException(e.getMessage());
@@ -520,15 +544,22 @@ private void writeCertArray(Writer writer, List<Certificate> certificates) throw
     public boolean matches(Request request, Response response) {
       return url.equals(request.urlString())
           && requestMethod.equals(request.method())
-          && response.varyMatches(varyHeaders, request);
+          && OkHeaders.varyMatches(response, varyHeaders, request);
     }
 
     public Response response(Request request, DiskLruCache.Snapshot snapshot) {
       String contentType = responseHeaders.get("Content-Type");
       String contentLength = responseHeaders.get("Content-Length");
+      Request cacheRequest = new Request.Builder()
+          .url(url)
+          .method(requestMethod, null)
+          .headers(varyHeaders)
+          .build();
       return new Response.Builder()
-          .request(request)
-          .statusLine(statusLine)
+          .request(cacheRequest)
+          .protocol(protocol)
+          .code(code)
+          .message(message)
           .headers(responseHeaders)
           .body(new CacheResponseBody(snapshot, contentType, contentLength))
           .handshake(handshake)
@@ -545,9 +576,9 @@ private static int readInt(BufferedSource source) throws IOException {
     }
   }
 
-  private static class CacheResponseBody extends Response.Body {
+  private static class CacheResponseBody extends ResponseBody {
     private final DiskLruCache.Snapshot snapshot;
-    private final InputStream bodyIn;
+    private final BufferedSource bodySource;
     private final String contentType;
     private final String contentLength;
 
@@ -557,17 +588,13 @@ public CacheResponseBody(final DiskLruCache.Snapshot snapshot,
       this.contentType = contentType;
       this.contentLength = contentLength;
 
-      // This input stream closes the snapshot when the stream is closed.
-      this.bodyIn = new FilterInputStream(snapshot.getInputStream(ENTRY_BODY)) {
+      Source source = snapshot.getSource(ENTRY_BODY);
+      bodySource = Okio.buffer(new ForwardingSource(source) {
         @Override public void close() throws IOException {
           snapshot.close();
           super.close();
         }
-      };
-    }
-
-    @Override public boolean ready() throws IOException {
-      return true;
+      });
     }
 
     @Override public MediaType contentType() {
@@ -582,8 +609,8 @@ public CacheResponseBody(final DiskLruCache.Snapshot snapshot,
       }
     }
 
-    @Override public InputStream byteStream() {
-      return bodyIn;
+    @Override public BufferedSource source() {
+      return bodySource;
     }
   }
 }
diff --git a/okhttp/src/main/java/com/squareup/okhttp/Call.java b/okhttp/src/main/java/com/squareup/okhttp/Call.java
new file mode 100644
index 0000000000..db2cf61076
--- /dev/null
+++ b/okhttp/src/main/java/com/squareup/okhttp/Call.java
@@ -0,0 +1,263 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.okhttp;
+
+import com.squareup.okhttp.internal.NamedRunnable;
+import com.squareup.okhttp.internal.Util;
+import com.squareup.okhttp.internal.http.HttpEngine;
+import com.squareup.okhttp.internal.http.HttpMethod;
+import com.squareup.okhttp.internal.http.OkHeaders;
+import com.squareup.okhttp.internal.http.RetryableSink;
+import java.io.IOException;
+import java.net.ProtocolException;
+import okio.BufferedSink;
+import okio.BufferedSource;
+
+import static com.squareup.okhttp.internal.http.HttpEngine.MAX_REDIRECTS;
+
+/**
+ * A call is a request that has been prepared for execution. A call can be
+ * canceled. As this object represents a single request/response pair (stream),
+ * it cannot be executed twice.
+ */
+public class Call {
+  private final OkHttpClient client;
+  private int redirectionCount;
+
+  // Guarded by this.
+  private boolean executed;
+  volatile boolean canceled;
+
+  /** The request; possibly a consequence of redirects or auth headers. */
+  private Request request;
+  HttpEngine engine;
+
+  protected Call(OkHttpClient client, Request request) {
+    // Copy the client. Otherwise changes (socket factory, redirect policy,
+    // etc.) may incorrectly be reflected in the request when it is executed.
+    this.client = client.copyWithDefaults();
+    this.request = request;
+  }
+
+  /**
+   * Invokes the request immediately, and blocks until the response can be
+   * processed or is in error.
+   *
+   * <p>The caller may read the response body with the response's
+   * {@link Response#body} method.  To facilitate connection recycling, callers
+   * should always {@link ResponseBody#close() close the response body}.
+   *
+   * <p>Note that transport-layer success (receiving a HTTP response code,
+   * headers and body) does not necessarily indicate application-layer success:
+   * {@code response} may still indicate an unhappy HTTP response code like 404
+   * or 500.
+   *
+   * @throws IOException if the request could not be executed due to
+   *     cancellation, a connectivity problem or timeout. Because networks can
+   *     fail during an exchange, it is possible that the remote server
+   *     accepted the request before the failure.
+   *
+   * @throws IllegalStateException when the call has already been executed.
+   */
+  public Response execute() throws IOException {
+    synchronized (this) {
+      if (executed) throw new IllegalStateException("Already Executed");
+      executed = true;
+    }
+    Response result = getResponse();
+    engine.releaseConnection(); // Transfer ownership of the body to the caller.
+    if (result == null) throw new IOException("Canceled");
+    return result;
+  }
+
+  /**
+   * Schedules the request to be executed at some point in the future.
+   *
+   * <p>The {@link OkHttpClient#getDispatcher dispatcher} defines when the
+   * request will run: usually immediately unless there are several other
+   * requests currently being executed.
+   *
+   * <p>This client will later call back {@code responseCallback} with either
+   * an HTTP response or a failure exception. If you {@link #cancel} a request
+   * before it completes the callback will not be invoked.
+   *
+   * @throws IllegalStateException when the call has already been executed.
+   */
+  public void enqueue(Callback responseCallback) {
+    synchronized (this) {
+      if (executed) throw new IllegalStateException("Already Executed");
+      executed = true;
+    }
+    client.getDispatcher().enqueue(new AsyncCall(responseCallback));
+  }
+
+  /**
+   * Cancels the request, if possible. Requests that are already complete
+   * cannot be canceled.
+   */
+  public void cancel() {
+    canceled = true;
+    if (engine != null) engine.disconnect();
+  }
+
+  final class AsyncCall extends NamedRunnable {
+    private final Callback responseCallback;
+
+    private AsyncCall(Callback responseCallback) {
+      super("OkHttp %s", request.urlString());
+      this.responseCallback = responseCallback;
+    }
+
+    String host() {
+      return request.url().getHost();
+    }
+
+    Request request() {
+      return request;
+    }
+
+    Object tag() {
+      return request.tag();
+    }
+
+    Call get() {
+      return Call.this;
+    }
+
+    @Override protected void execute() {
+      boolean signalledCallback = false;
+      try {
+        Response response = getResponse();
+        if (canceled) {
+          signalledCallback = true;
+          responseCallback.onFailure(request, new IOException("Canceled"));
+        } else {
+          signalledCallback = true;
+          engine.releaseConnection();
+          responseCallback.onResponse(response);
+        }
+      } catch (IOException e) {
+        if (signalledCallback) throw new RuntimeException(e); // Do not signal the callback twice!
+        responseCallback.onFailure(request, e);
+      } finally {
+        client.getDispatcher().finished(this);
+      }
+    }
+  }
+
+  /**
+   * Performs the request and returns the response. May return null if this
+   * call was canceled.
+   */
+  private Response getResponse() throws IOException {
+    // Copy body metadata to the appropriate request headers.
+    RequestBody body = request.body();
+    RetryableSink requestBodyOut = null;
+    if (body != null) {
+      Request.Builder requestBuilder = request.newBuilder();
+
+      MediaType contentType = body.contentType();
+      if (contentType != null) {
+        requestBuilder.header("Content-Type", contentType.toString());
+      }
+
+      long contentLength = body.contentLength();
+      if (contentLength != -1) {
+        requestBuilder.header("Content-Length", Long.toString(contentLength));
+        requestBuilder.removeHeader("Transfer-Encoding");
+      } else {
+        requestBuilder.header("Transfer-Encoding", "chunked");
+        requestBuilder.removeHeader("Content-Length");
+      }
+
+      request = requestBuilder.build();
+    } else if (HttpMethod.hasRequestBody(request.method())) {
+      requestBodyOut = Util.emptySink();
+    }
+
+    // Create the initial HTTP engine. Retries and redirects need new engine for each attempt.
+    engine = new HttpEngine(client, request, false, null, null, requestBodyOut, null);
+
+    while (true) {
+      if (canceled) return null;
+
+      try {
+        engine.sendRequest();
+
+        if (request.body() != null) {
+          BufferedSink sink = engine.getBufferedRequestBody();
+          request.body().writeTo(sink);
+        }
+
+        engine.readResponse();
+      } catch (IOException e) {
+        HttpEngine retryEngine = engine.recover(e, null);
+        if (retryEngine != null) {
+          engine = retryEngine;
+          continue;
+        }
+
+        // Give up; recovery is not possible.
+        throw e;
+      }
+
+      Response response = engine.getResponse();
+      Request followUp = engine.followUpRequest();
+
+      if (followUp == null) {
+        engine.releaseConnection();
+        return response.newBuilder()
+            .body(new RealResponseBody(response, engine.getResponseBody()))
+            .build();
+      }
+
+      if (engine.getResponse().isRedirect() && ++redirectionCount > MAX_REDIRECTS) {
+        throw new ProtocolException("Too many redirects: " + redirectionCount);
+      }
+
+      if (!engine.sameConnection(followUp.url())) {
+        engine.releaseConnection();
+      }
+
+      Connection connection = engine.close();
+      request = followUp;
+      engine = new HttpEngine(client, request, false, connection, null, null, response);
+    }
+  }
+
+  private static class RealResponseBody extends ResponseBody {
+    private final Response response;
+    private final BufferedSource source;
+
+    RealResponseBody(Response response, BufferedSource source) {
+      this.response = response;
+      this.source = source;
+    }
+
+    @Override public MediaType contentType() {
+      String contentType = response.header("Content-Type");
+      return contentType != null ? MediaType.parse(contentType) : null;
+    }
+
+    @Override public long contentLength() {
+      return OkHeaders.contentLength(response);
+    }
+
+    @Override public BufferedSource source() {
+      return source;
+    }
+  }
+}
diff --git a/okhttp/src/main/java/com/squareup/okhttp/Callback.java b/okhttp/src/main/java/com/squareup/okhttp/Callback.java
new file mode 100644
index 0000000000..d86960fe05
--- /dev/null
+++ b/okhttp/src/main/java/com/squareup/okhttp/Callback.java
@@ -0,0 +1,42 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.okhttp;
+
+import java.io.IOException;
+
+public interface Callback {
+  /**
+   * Called when the request could not be executed due to cancellation, a
+   * connectivity problem or timeout. Because networks can fail during an
+   * exchange, it is possible that the remote server accepted the request
+   * before the failure.
+   */
+  void onFailure(Request request, IOException e);
+
+  /**
+   * Called when the HTTP response was successfully returned by the remote
+   * server. The callback may proceed to read the response body with {@link
+   * Response#body}. The response is still live until its response body is
+   * closed with {@code response.body().close()}. The recipient of the callback
+   * may even consume the response body on another thread.
+   *
+   * <p>Note that transport-layer success (receiving a HTTP response code,
+   * headers and body) does not necessarily indicate application-layer
+   * success: {@code response} may still indicate an unhappy HTTP response
+   * code like 404 or 500.
+   */
+  void onResponse(Response response) throws IOException;
+}
diff --git a/okhttp/src/main/java/com/squareup/okhttp/Challenge.java b/okhttp/src/main/java/com/squareup/okhttp/Challenge.java
new file mode 100644
index 0000000000..a1ef7145a0
--- /dev/null
+++ b/okhttp/src/main/java/com/squareup/okhttp/Challenge.java
@@ -0,0 +1,56 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.okhttp;
+
+import static com.squareup.okhttp.internal.Util.equal;
+
+/** An RFC 2617 challenge. */
+public final class Challenge {
+  private final String scheme;
+  private final String realm;
+
+  public Challenge(String scheme, String realm) {
+    this.scheme = scheme;
+    this.realm = realm;
+  }
+
+  /** Returns the authentication scheme, like {@code Basic}. */
+  public String getScheme() {
+    return scheme;
+  }
+
+  /** Returns the protection space. */
+  public String getRealm() {
+    return realm;
+  }
+
+  @Override public boolean equals(Object o) {
+    return o instanceof Challenge
+        && equal(scheme, ((Challenge) o).scheme)
+        && equal(realm, ((Challenge) o).realm);
+  }
+
+  @Override public int hashCode() {
+    int result = 29;
+    result = 31 * result + (realm != null ? realm.hashCode() : 0);
+    result = 31 * result + (scheme != null ? scheme.hashCode() : 0);
+    return result;
+  }
+
+  @Override public String toString() {
+    return scheme + " realm=\"" + realm + "\"";
+  }
+}
diff --git a/okhttp/src/main/java/com/squareup/okhttp/Connection.java b/okhttp/src/main/java/com/squareup/okhttp/Connection.java
index d9115a9662..42dc9b19ca 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/Connection.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/Connection.java
@@ -17,25 +17,21 @@
 package com.squareup.okhttp;
 
 import com.squareup.okhttp.internal.Platform;
-import com.squareup.okhttp.internal.http.HttpAuthenticator;
 import com.squareup.okhttp.internal.http.HttpConnection;
 import com.squareup.okhttp.internal.http.HttpEngine;
 import com.squareup.okhttp.internal.http.HttpTransport;
+import com.squareup.okhttp.internal.http.OkHeaders;
 import com.squareup.okhttp.internal.http.SpdyTransport;
+import com.squareup.okhttp.internal.http.Transport;
 import com.squareup.okhttp.internal.spdy.SpdyConnection;
-import java.io.Closeable;
 import java.io.IOException;
-import java.io.InputStream;
-import java.io.OutputStream;
 import java.net.Proxy;
 import java.net.Socket;
-import java.net.SocketTimeoutException;
+import java.net.URL;
 import javax.net.ssl.SSLSocket;
-import okio.BufferedSink;
-import okio.BufferedSource;
-import okio.ByteString;
-import okio.Okio;
 
+import static com.squareup.okhttp.internal.Util.getDefaultPort;
+import static com.squareup.okhttp.internal.Util.getEffectivePort;
 import static java.net.HttpURLConnection.HTTP_OK;
 import static java.net.HttpURLConnection.HTTP_PROXY_AUTH;
 
@@ -46,7 +42,7 @@
  *
  * <p>Typically instances of this class are created, connected and exercised
  * automatically by the HTTP client. Applications may use this class to monitor
- * HTTP connections as members of a {@link ConnectionPool connection pool}.
+ * HTTP connections as members of a {@linkplain ConnectionPool connection pool}.
  *
  * <p>Do not confuse this class with the misnamed {@code HttpURLConnection},
  * which isn't so much a connection as a single request/response exchange.
@@ -57,91 +53,185 @@
  * <ul>
  *   <li>Server Name Indication (SNI) enables one IP address to negotiate secure
  *       connections for multiple domain names.
- *   <li>Next Protocol Negotiation (NPN) enables the HTTPS port (443) to be used
- *       for both HTTP and SPDY protocols.
+ *   <li>Application Layer Protocol Negotiation (ALPN) enables the HTTPS port
+ *       (443) to be used for different HTTP and SPDY protocols.
  * </ul>
  * Unfortunately, older HTTPS servers refuse to connect when such options are
  * presented. Rather than avoiding these options entirely, this class allows a
  * connection to be attempted with modern options and then retried without them
  * should the attempt fail.
  */
-public final class Connection implements Closeable {
+public final class Connection {
   private final ConnectionPool pool;
   private final Route route;
 
   private Socket socket;
-  private InputStream in;
-  private OutputStream out;
-  private BufferedSource source;
-  private BufferedSink sink;
   private boolean connected = false;
   private HttpConnection httpConnection;
   private SpdyConnection spdyConnection;
-  private int httpMinorVersion = 1; // Assume HTTP/1.1
+  private Protocol protocol = Protocol.HTTP_1_1;
   private long idleStartTimeNs;
   private Handshake handshake;
   private int recycleCount;
 
+  /**
+   * The object that owns this connection. Null if it is shared (for SPDY),
+   * belongs to a pool, or has been discarded. Guarded by {@code pool}, which
+   * clears the owner when an incoming connection is recycled.
+   */
+  private Object owner;
+
   public Connection(ConnectionPool pool, Route route) {
     this.pool = pool;
     this.route = route;
   }
 
-  public void connect(int connectTimeout, int readTimeout, TunnelRequest tunnelRequest)
+  Object getOwner() {
+    synchronized (pool) {
+      return owner;
+    }
+  }
+
+  void setOwner(Object owner) {
+    if (isSpdy()) return; // SPDY connections are shared.
+    synchronized (pool) {
+      if (this.owner != null) throw new IllegalStateException("Connection already has an owner!");
+      this.owner = owner;
+    }
+  }
+
+  /**
+   * Attempts to clears the owner of this connection. Returns true if the owner
+   * was cleared and the connection can be pooled or reused. This will return
+   * false if the connection cannot be pooled or reused, such as if it was
+   * closed with {@link #closeIfOwnedBy}.
+   */
+  boolean clearOwner() {
+    synchronized (pool) {
+      if (owner == null) {
+        // No owner? Don't reuse this connection.
+        return false;
+      }
+
+      owner = null;
+      return true;
+    }
+  }
+
+  /**
+   * Closes this connection if it is currently owned by {@code owner}. This also
+   * strips the ownership of the connection so it cannot be pooled or reused.
+   */
+  void closeIfOwnedBy(Object owner) throws IOException {
+    if (isSpdy()) throw new IllegalStateException();
+    synchronized (pool) {
+      if (this.owner != owner) {
+        return; // Wrong owner. Perhaps a late disconnect?
+      }
+
+      this.owner = null; // Drop the owner so the connection won't be reused.
+    }
+
+    // Don't close() inside the synchronized block.
+    socket.close();
+  }
+
+  void connect(int connectTimeout, int readTimeout, int writeTimeout, Request tunnelRequest)
       throws IOException {
     if (connected) throw new IllegalStateException("already connected");
 
-    socket = (route.proxy.type() != Proxy.Type.HTTP) ? new Socket(route.proxy) : new Socket();
-    Platform.get().connectSocket(socket, route.inetSocketAddress, connectTimeout);
+    if (route.proxy.type() == Proxy.Type.DIRECT || route.proxy.type() == Proxy.Type.HTTP) {
+      socket = route.address.socketFactory.createSocket();
+    } else {
+      socket = new Socket(route.proxy);
+    }
+
     socket.setSoTimeout(readTimeout);
-    in = socket.getInputStream();
-    out = socket.getOutputStream();
+    Platform.get().connectSocket(socket, route.inetSocketAddress, connectTimeout);
 
     if (route.address.sslSocketFactory != null) {
-      upgradeToTls(tunnelRequest);
+      upgradeToTls(tunnelRequest, readTimeout, writeTimeout);
     } else {
-      initSourceAndSink();
-      httpConnection = new HttpConnection(pool, this, source, sink);
+      httpConnection = new HttpConnection(pool, this, socket);
     }
     connected = true;
   }
 
+  /**
+   * Connects this connection if it isn't already. This creates tunnels, shares
+   * the connection with the connection pool, and configures timeouts.
+   */
+  void connectAndSetOwner(OkHttpClient client, Object owner, Request request) throws IOException {
+    setOwner(owner);
+
+    if (!isConnected()) {
+      Request tunnelRequest = tunnelRequest(request);
+      connect(client.getConnectTimeout(), client.getReadTimeout(),
+          client.getWriteTimeout(), tunnelRequest);
+      if (isSpdy()) {
+        client.getConnectionPool().share(this);
+      }
+      client.routeDatabase().connected(getRoute());
+    }
+
+    setTimeouts(client.getReadTimeout(), client.getWriteTimeout());
+  }
+
+  /**
+   * Returns a request that creates a TLS tunnel via an HTTP proxy, or null if
+   * no tunnel is necessary. Everything in the tunnel request is sent
+   * unencrypted to the proxy server, so tunnels include only the minimum set of
+   * headers. This avoids sending potentially sensitive data like HTTP cookies
+   * to the proxy unencrypted.
+   */
+  private Request tunnelRequest(Request request) throws IOException {
+    if (!route.requiresTunnel()) return null;
+
+    String host = request.url().getHost();
+    int port = getEffectivePort(request.url());
+    String authority = (port == getDefaultPort("https")) ? host : (host + ":" + port);
+    Request.Builder result = new Request.Builder()
+        .url(new URL("https", host, port, "/"))
+        .header("Host", authority)
+        .header("Proxy-Connection", "Keep-Alive"); // For HTTP/1.0 proxies like Squid.
+
+    // Copy over the User-Agent header if it exists.
+    String userAgent = request.header("User-Agent");
+    if (userAgent != null) {
+      result.header("User-Agent", userAgent);
+    }
+
+    // Copy over the Proxy-Authorization header if it exists.
+    String proxyAuthorization = request.header("Proxy-Authorization");
+    if (proxyAuthorization != null) {
+      result.header("Proxy-Authorization", proxyAuthorization);
+    }
+
+    return result.build();
+  }
+
   /**
    * Create an {@code SSLSocket} and perform the TLS handshake and certificate
    * validation.
    */
-  private void upgradeToTls(TunnelRequest tunnelRequest) throws IOException {
+  private void upgradeToTls(Request tunnelRequest, int readTimeout, int writeTimeout)
+      throws IOException {
     Platform platform = Platform.get();
 
     // Make an SSL Tunnel on the first message pair of each SSL + proxy connection.
-    if (requiresTunnel()) {
-      makeTunnel(tunnelRequest);
+    if (tunnelRequest != null) {
+      makeTunnel(tunnelRequest, readTimeout, writeTimeout);
     }
 
     // Create the wrapper over connected socket.
     socket = route.address.sslSocketFactory
         .createSocket(socket, route.address.uriHost, route.address.uriPort, true /* autoClose */);
     SSLSocket sslSocket = (SSLSocket) socket;
-    if (route.modernTls) {
-      platform.enableTlsExtensions(sslSocket, route.address.uriHost);
-    } else {
-      platform.supportTlsIntolerantServer(sslSocket);
-    }
-
-    boolean useNpn = route.modernTls && (// Contains a spdy variant.
-        route.address.protocols.contains(Protocol.HTTP_2)
-     || route.address.protocols.contains(Protocol.SPDY_3)
-    );
+    platform.configureTls(sslSocket, route.address.uriHost, route.tlsVersion);
 
+    boolean useNpn = route.supportsNpn();
     if (useNpn) {
-      if (route.address.protocols.contains(Protocol.HTTP_2) // Contains both spdy variants.
-          && route.address.protocols.contains(Protocol.SPDY_3)) {
-        platform.setNpnProtocols(sslSocket, Protocol.HTTP2_SPDY3_AND_HTTP);
-      } else if (route.address.protocols.contains(Protocol.HTTP_2)) {
-        platform.setNpnProtocols(sslSocket, Protocol.HTTP2_AND_HTTP_11);
-      } else {
-        platform.setNpnProtocols(sslSocket, Protocol.SPDY3_AND_HTTP11);
-      }
+      platform.setProtocols(sslSocket, route.address.protocols);
     }
 
     // Force handshake. This can throw!
@@ -152,36 +242,28 @@ private void upgradeToTls(TunnelRequest tunnelRequest) throws IOException {
       throw new IOException("Hostname '" + route.address.uriHost + "' was not verified");
     }
 
-    out = sslSocket.getOutputStream();
-    in = sslSocket.getInputStream();
     handshake = Handshake.get(sslSocket.getSession());
-    initSourceAndSink();
 
-    ByteString maybeProtocol;
-    Protocol selectedProtocol = Protocol.HTTP_11;
-    if (useNpn && (maybeProtocol = platform.getNpnSelectedProtocol(sslSocket)) != null) {
-      selectedProtocol = Protocol.find(maybeProtocol); // Throws IOE on unknown.
+    String maybeProtocol;
+    if (useNpn && (maybeProtocol = platform.getSelectedProtocol(sslSocket)) != null) {
+      protocol = Protocol.get(maybeProtocol); // Throws IOE on unknown.
     }
 
-    if (selectedProtocol.spdyVariant) {
+    if (protocol == Protocol.SPDY_3 || protocol == Protocol.HTTP_2) {
       sslSocket.setSoTimeout(0); // SPDY timeouts are set per-stream.
-      spdyConnection = new SpdyConnection.Builder(route.address.getUriHost(), true, source, sink)
-          .protocol(selectedProtocol).build();
-      spdyConnection.sendConnectionHeader();
+      spdyConnection = new SpdyConnection.Builder(route.address.getUriHost(), true, socket)
+          .protocol(protocol).build();
+      spdyConnection.sendConnectionPreface();
     } else {
-      httpConnection = new HttpConnection(pool, this, source, sink);
+      httpConnection = new HttpConnection(pool, this, socket);
     }
   }
 
   /** Returns true if {@link #connect} has been attempted on this connection. */
-  public boolean isConnected() {
+  boolean isConnected() {
     return connected;
   }
 
-  @Override public void close() throws IOException {
-    socket.close();
-  }
-
   /** Returns the route used by this connection. */
   public Route getRoute() {
     return route;
@@ -196,7 +278,7 @@ public Socket getSocket() {
   }
 
   /** Returns true if this connection is alive. */
-  public boolean isAlive() {
+  boolean isAlive() {
     return !socket.isClosed() && !socket.isInputShutdown() && !socket.isOutputShutdown();
   }
 
@@ -205,38 +287,18 @@ public boolean isAlive() {
    * connection. This is more expensive and more accurate than {@link
    * #isAlive()}; callers should check {@link #isAlive()} first.
    */
-  public boolean isReadable() {
-    if (source == null) {
-      return true; // Optimistic.
-    }
-    if (isSpdy()) {
-      return true; // Optimistic. We can't test SPDY because its streams are in use.
-    }
-    try {
-      int readTimeout = socket.getSoTimeout();
-      try {
-        socket.setSoTimeout(1);
-        if (source.exhausted()) {
-          return false; // Stream is exhausted; socket is closed.
-        }
-        return true;
-      } finally {
-        socket.setSoTimeout(readTimeout);
-      }
-    } catch (SocketTimeoutException ignored) {
-      return true; // Read timed out; socket is good.
-    } catch (IOException e) {
-      return false; // Couldn't read; socket is closed.
-    }
+  boolean isReadable() {
+    if (httpConnection != null) return httpConnection.isReadable();
+    return true; // SPDY connections, and connections before connect() are both optimistic.
   }
 
-  public void resetIdleStartTime() {
+  void resetIdleStartTime() {
     if (spdyConnection != null) throw new IllegalStateException("spdyConnection != null");
     this.idleStartTimeNs = System.nanoTime();
   }
 
   /** Returns true if this connection is idle. */
-  public boolean isIdle() {
+  boolean isIdle() {
     return spdyConnection == null || spdyConnection.isIdle();
   }
 
@@ -244,7 +306,7 @@ public boolean isIdle() {
    * Returns true if this connection has been idle for longer than
    * {@code keepAliveDurationNs}.
    */
-  public boolean isExpired(long keepAliveDurationNs) {
+  boolean isExpired(long keepAliveDurationNs) {
     return getIdleStartTimeNs() < System.nanoTime() - keepAliveDurationNs;
   }
 
@@ -252,7 +314,7 @@ public boolean isExpired(long keepAliveDurationNs) {
    * Returns the time in ns when this connection became idle. Undefined if
    * this connection is not idle.
    */
-  public long getIdleStartTimeNs() {
+  long getIdleStartTimeNs() {
     return spdyConnection == null ? idleStartTimeNs : spdyConnection.getIdleStartTimeNs();
   }
 
@@ -261,7 +323,7 @@ public Handshake getHandshake() {
   }
 
   /** Returns the transport appropriate for this connection. */
-  public Object newTransport(HttpEngine httpEngine) throws IOException {
+  Transport newTransport(HttpEngine httpEngine) throws IOException {
     return (spdyConnection != null)
         ? new SpdyTransport(httpEngine, spdyConnection)
         : new HttpTransport(httpEngine, httpConnection);
@@ -271,38 +333,38 @@ public Object newTransport(HttpEngine httpEngine) throws IOException {
    * Returns true if this is a SPDY connection. Such connections can be used
    * in multiple HTTP requests simultaneously.
    */
-  public boolean isSpdy() {
+  boolean isSpdy() {
     return spdyConnection != null;
   }
 
   /**
-   * Returns the minor HTTP version that should be used for future requests on
-   * this connection. Either 0 for HTTP/1.0, or 1 for HTTP/1.1. The default
-   * value is 1 for new connections.
+   * Returns the protocol negotiated by this connection, or {@link
+   * Protocol#HTTP_1_1} if no protocol has been negotiated.
    */
-  public int getHttpMinorVersion() {
-    return httpMinorVersion;
-  }
-
-  public void setHttpMinorVersion(int httpMinorVersion) {
-    this.httpMinorVersion = httpMinorVersion;
+  public Protocol getProtocol() {
+    return protocol;
   }
 
   /**
-   * Returns true if the HTTP connection needs to tunnel one protocol over
-   * another, such as when using HTTPS through an HTTP proxy. When doing so,
-   * we must avoid buffering bytes intended for the higher-level protocol.
+   * Sets the protocol negotiated by this connection. Typically this is used
+   * when an HTTP/1.1 request is sent and an HTTP/1.0 response is received.
    */
-  public boolean requiresTunnel() {
-    return route.address.sslSocketFactory != null && route.proxy.type() == Proxy.Type.HTTP;
+  void setProtocol(Protocol protocol) {
+    if (protocol == null) throw new IllegalArgumentException("protocol == null");
+    this.protocol = protocol;
   }
 
-  public void updateReadTimeout(int newTimeout) throws IOException {
-    if (!connected) throw new IllegalStateException("updateReadTimeout - not connected");
-    socket.setSoTimeout(newTimeout);
+  void setTimeouts(int readTimeoutMillis, int writeTimeoutMillis) throws IOException {
+    if (!connected) throw new IllegalStateException("setTimeouts - not connected");
+
+    // Don't set timeouts on shared SPDY connections.
+    if (httpConnection != null) {
+      socket.setSoTimeout(readTimeoutMillis);
+      httpConnection.setTimeouts(readTimeoutMillis, writeTimeoutMillis);
+    }
   }
 
-  public void incrementRecycleCount() {
+  void incrementRecycleCount() {
     recycleCount++;
   }
 
@@ -310,7 +372,7 @@ public void incrementRecycleCount() {
    * Returns the number of times this connection has been returned to the
    * connection pool.
    */
-  public int recycleCount() {
+  int recycleCount() {
     return recycleCount;
   }
 
@@ -319,12 +381,12 @@ public int recycleCount() {
    * CONNECT request to create the proxy connection. This may need to be
    * retried if the proxy requires authorization.
    */
-  private void makeTunnel(TunnelRequest tunnelRequest) throws IOException {
-    BufferedSource tunnelSource = Okio.buffer(Okio.source(in));
-    BufferedSink tunnelSink = Okio.buffer(Okio.sink(out));
-    HttpConnection tunnelConnection = new HttpConnection(pool, this, tunnelSource, tunnelSink);
-    Request request = tunnelRequest.getRequest();
-    String requestLine = tunnelRequest.requestLine();
+  private void makeTunnel(Request request, int readTimeout, int writeTimeout)
+      throws IOException {
+    HttpConnection tunnelConnection = new HttpConnection(pool, this, socket);
+    tunnelConnection.setTimeouts(readTimeout, writeTimeout);
+    URL url = request.url();
+    String requestLine = "CONNECT " + url.getHost() + ":" + url.getPort() + " HTTP/1.1";
     while (true) {
       tunnelConnection.writeRequest(request.headers(), requestLine);
       tunnelConnection.flush();
@@ -335,13 +397,13 @@ private void makeTunnel(TunnelRequest tunnelRequest) throws IOException {
         case HTTP_OK:
           // Assume the server won't send a TLS ServerHello until we send a TLS ClientHello. If that
           // happens, then we will have buffered bytes that are needed by the SSLSocket!
-          if (tunnelSource.buffer().size() > 0) {
+          if (tunnelConnection.bufferSize() > 0) {
             throw new IOException("TLS tunnel buffered too many bytes!");
           }
           return;
 
         case HTTP_PROXY_AUTH:
-          request = HttpAuthenticator.processAuthHeader(
+          request = OkHeaders.processAuthHeader(
               route.address.authenticator, response, route.proxy);
           if (request != null) continue;
           throw new IOException("Failed to authenticate with proxy");
@@ -352,9 +414,4 @@ private void makeTunnel(TunnelRequest tunnelRequest) throws IOException {
       }
     }
   }
-
-  private void initSourceAndSink() throws IOException {
-    source = Okio.buffer(Okio.source(in));
-    sink = Okio.buffer(Okio.sink(out));
-  }
 }
diff --git a/okhttp/src/main/java/com/squareup/okhttp/ConnectionPool.java b/okhttp/src/main/java/com/squareup/okhttp/ConnectionPool.java
index 24ab543c11..b52c234e45 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/ConnectionPool.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/ConnectionPool.java
@@ -51,7 +51,7 @@
  * parameters do so before making HTTP connections, and that this class is
  * initialized lazily.
  */
-public class ConnectionPool {
+public final class ConnectionPool {
   private static final int MAX_CONNECTIONS_TO_CLEANUP = 2;
   private static final long DEFAULT_KEEP_ALIVE_DURATION_MS = 5 * 60 * 1000; // 5 min
 
@@ -76,7 +76,7 @@
   private final int maxIdleConnections;
   private final long keepAliveDurationNs;
 
-  private final LinkedList<Connection> connections = new LinkedList<Connection>();
+  private final LinkedList<Connection> connections = new LinkedList<>();
 
   /** We use a single background thread to cleanup expired connections. */
   private final ExecutorService executorService = new ThreadPoolExecutor(0, 1,
@@ -84,7 +84,7 @@
       Util.threadFactory("OkHttp ConnectionPool", true));
   private final Runnable connectionsCleanupRunnable = new Runnable() {
     @Override public void run() {
-      List<Connection> expiredConnections = new ArrayList<Connection>(MAX_CONNECTIONS_TO_CLEANUP);
+      List<Connection> expiredConnections = new ArrayList<>(MAX_CONNECTIONS_TO_CLEANUP);
       int idleConnectionCount = 0;
       synchronized (ConnectionPool.this) {
         for (ListIterator<Connection> i = connections.listIterator(connections.size());
@@ -110,7 +110,7 @@
         }
       }
       for (Connection expiredConnection : expiredConnections) {
-        Util.closeQuietly(expiredConnection);
+        Util.closeQuietly(expiredConnection.getSocket());
       }
     }
   };
@@ -127,7 +127,7 @@ public ConnectionPool(int maxIdleConnections, long keepAliveDurationMs) {
   List<Connection> getConnections() {
     waitForCleanupCallableToRun();
     synchronized (this) {
-      return new ArrayList<Connection>(connections);
+      return new ArrayList<>(connections);
     }
   }
 
@@ -189,7 +189,7 @@ public synchronized Connection get(Address address) {
         try {
           Platform.get().tagSocket(connection.getSocket());
         } catch (SocketException e) {
-          Util.closeQuietly(connection);
+          Util.closeQuietly(connection.getSocket());
           // When unable to tag, skip recycling and close
           Platform.get().logW("Unable to tagSocket(): " + e);
           continue;
@@ -213,13 +213,17 @@ public synchronized Connection get(Address address) {
    *
    * <p>It is an error to use {@code connection} after calling this method.
    */
-  public void recycle(Connection connection) {
+  void recycle(Connection connection) {
     if (connection.isSpdy()) {
       return;
     }
 
+    if (!connection.clearOwner()) {
+      return; // This connection isn't eligible for reuse.
+    }
+
     if (!connection.isAlive()) {
-      Util.closeQuietly(connection);
+      Util.closeQuietly(connection.getSocket());
       return;
     }
 
@@ -228,7 +232,7 @@ public void recycle(Connection connection) {
     } catch (SocketException e) {
       // When unable to remove tagging, skip recycling and close.
       Platform.get().logW("Unable to untagSocket(): " + e);
-      Util.closeQuietly(connection);
+      Util.closeQuietly(connection.getSocket());
       return;
     }
 
@@ -245,7 +249,7 @@ public void recycle(Connection connection) {
    * Shares the SPDY connection with the pool. Callers to this method may
    * continue to use {@code connection}.
    */
-  public void share(Connection connection) {
+  void share(Connection connection) {
     if (!connection.isSpdy()) throw new IllegalArgumentException();
     executorService.execute(connectionsCleanupRunnable);
     if (connection.isAlive()) {
@@ -259,12 +263,12 @@ public void share(Connection connection) {
   public void evictAll() {
     List<Connection> connections;
     synchronized (this) {
-      connections = new ArrayList<Connection>(this.connections);
+      connections = new ArrayList<>(this.connections);
       this.connections.clear();
     }
 
     for (int i = 0, size = connections.size(); i < size; i++) {
-      Util.closeQuietly(connections.get(i));
+      Util.closeQuietly(connections.get(i).getSocket());
     }
   }
 }
diff --git a/okhttp/src/main/java/com/squareup/okhttp/Credentials.java b/okhttp/src/main/java/com/squareup/okhttp/Credentials.java
new file mode 100644
index 0000000000..92c128f568
--- /dev/null
+++ b/okhttp/src/main/java/com/squareup/okhttp/Credentials.java
@@ -0,0 +1,37 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.okhttp;
+
+import java.io.UnsupportedEncodingException;
+import okio.ByteString;
+
+/** Factory for HTTP authorization credentials. */
+public final class Credentials {
+  private Credentials() {
+  }
+
+  /** Returns an auth credential for the Basic scheme. */
+  public static String basic(String userName, String password) {
+    try {
+      String usernameAndPassword = userName + ":" + password;
+      byte[] bytes = usernameAndPassword.getBytes("ISO-8859-1");
+      String encoded = ByteString.of(bytes).base64();
+      return "Basic " + encoded;
+    } catch (UnsupportedEncodingException e) {
+      throw new AssertionError();
+    }
+  }
+}
diff --git a/okhttp/src/main/java/com/squareup/okhttp/Dispatcher.java b/okhttp/src/main/java/com/squareup/okhttp/Dispatcher.java
index 58e06be40b..0e4644d5b7 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/Dispatcher.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/Dispatcher.java
@@ -15,7 +15,9 @@
  */
 package com.squareup.okhttp;
 
+import com.squareup.okhttp.Call.AsyncCall;
 import com.squareup.okhttp.internal.Util;
+import com.squareup.okhttp.internal.http.HttpEngine;
 import java.util.ArrayDeque;
 import java.util.Deque;
 import java.util.Iterator;
@@ -27,22 +29,22 @@
 /**
  * Policy on when async requests are executed.
  *
- * <p>Each dispatcher uses an {@link ExecutorService} to run jobs internally. If you
- * supply your own executor, it should be able to run {@link #getMaxRequests the
- * configured maximum} number of jobs concurrently.
+ * <p>Each dispatcher uses an {@link ExecutorService} to run calls internally. If you
+ * supply your own executor, it should be able to run {@linkplain #getMaxRequests the
+ * configured maximum} number of calls concurrently.
  */
 public final class Dispatcher {
   private int maxRequests = 64;
   private int maxRequestsPerHost = 5;
 
-  /** Executes jobs. Created lazily. */
+  /** Executes calls. Created lazily. */
   private ExecutorService executorService;
 
-  /** Ready jobs in the order they'll be run. */
-  private final Deque<Job> readyJobs = new ArrayDeque<Job>();
+  /** Ready calls in the order they'll be run. */
+  private final Deque<AsyncCall> readyCalls = new ArrayDeque<>();
 
-  /** Running jobs. Includes canceled jobs that haven't finished yet. */
-  private final Deque<Job> runningJobs = new ArrayDeque<Job>();
+  /** Running calls. Includes canceled calls that haven't finished yet. */
+  private final Deque<AsyncCall> runningCalls = new ArrayDeque<>();
 
   public Dispatcher(ExecutorService executorService) {
     this.executorService = executorService;
@@ -61,7 +63,7 @@ public synchronized ExecutorService getExecutorService() {
 
   /**
    * Set the maximum number of requests to execute concurrently. Above this
-   * requests queue in memory, waiting for the running jobs to complete.
+   * requests queue in memory, waiting for the running calls to complete.
    *
    * <p>If more than {@code maxRequests} requests are in flight when this is
    * invoked, those requests will remain in flight.
@@ -71,7 +73,7 @@ public synchronized void setMaxRequests(int maxRequests) {
       throw new IllegalArgumentException("max < 1: " + maxRequests);
     }
     this.maxRequests = maxRequests;
-    promoteJobs();
+    promoteCalls();
   }
 
   public synchronized int getMaxRequests() {
@@ -92,69 +94,65 @@ public synchronized void setMaxRequestsPerHost(int maxRequestsPerHost) {
       throw new IllegalArgumentException("max < 1: " + maxRequestsPerHost);
     }
     this.maxRequestsPerHost = maxRequestsPerHost;
-    promoteJobs();
+    promoteCalls();
   }
 
   public synchronized int getMaxRequestsPerHost() {
     return maxRequestsPerHost;
   }
 
-  synchronized void enqueue(OkHttpClient client, Request request, Response.Receiver receiver) {
-    // Copy the client. Otherwise changes (socket factory, redirect policy,
-    // etc.) may incorrectly be reflected in the request when it is executed.
-    client = client.copyWithDefaults();
-    Job job = new Job(this, client, request, receiver);
-
-    if (runningJobs.size() < maxRequests && runningJobsForHost(job) < maxRequestsPerHost) {
-      runningJobs.add(job);
-      getExecutorService().execute(job);
+  synchronized void enqueue(AsyncCall call) {
+    if (runningCalls.size() < maxRequests && runningCallsForHost(call) < maxRequestsPerHost) {
+      runningCalls.add(call);
+      getExecutorService().execute(call);
     } else {
-      readyJobs.add(job);
+      readyCalls.add(call);
     }
   }
 
-  /**
-   * Cancel all jobs with the tag {@code tag}. If a canceled job is running it
-   * may continue running until it reaches a safe point to finish.
-   */
+  /** Cancel all calls with the tag {@code tag}. */
   public synchronized void cancel(Object tag) {
-    for (Iterator<Job> i = readyJobs.iterator(); i.hasNext(); ) {
+    for (Iterator<AsyncCall> i = readyCalls.iterator(); i.hasNext(); ) {
       if (Util.equal(tag, i.next().tag())) i.remove();
     }
 
-    for (Job job : runningJobs) {
-      if (Util.equal(tag, job.tag())) job.canceled = true;
+    for (AsyncCall call : runningCalls) {
+      if (Util.equal(tag, call.tag())) {
+        call.get().canceled = true;
+        HttpEngine engine = call.get().engine;
+        if (engine != null) engine.disconnect();
+      }
     }
   }
 
-  /** Used by {@code Job#run} to signal completion. */
-  synchronized void finished(Job job) {
-    if (!runningJobs.remove(job)) throw new AssertionError("Job wasn't running!");
-    promoteJobs();
+  /** Used by {@code AsyncCall#run} to signal completion. */
+  synchronized void finished(AsyncCall call) {
+    if (!runningCalls.remove(call)) throw new AssertionError("AsyncCall wasn't running!");
+    promoteCalls();
   }
 
-  private void promoteJobs() {
-    if (runningJobs.size() >= maxRequests) return; // Already running max capacity.
-    if (readyJobs.isEmpty()) return; // No ready jobs to promote.
+  private void promoteCalls() {
+    if (runningCalls.size() >= maxRequests) return; // Already running max capacity.
+    if (readyCalls.isEmpty()) return; // No ready calls to promote.
 
-    for (Iterator<Job> i = readyJobs.iterator(); i.hasNext(); ) {
-      Job job = i.next();
+    for (Iterator<AsyncCall> i = readyCalls.iterator(); i.hasNext(); ) {
+      AsyncCall call = i.next();
 
-      if (runningJobsForHost(job) < maxRequestsPerHost) {
+      if (runningCallsForHost(call) < maxRequestsPerHost) {
         i.remove();
-        runningJobs.add(job);
-        getExecutorService().execute(job);
+        runningCalls.add(call);
+        getExecutorService().execute(call);
       }
 
-      if (runningJobs.size() >= maxRequests) return; // Reached max capacity.
+      if (runningCalls.size() >= maxRequests) return; // Reached max capacity.
     }
   }
 
-  /** Returns the number of running jobs that share a host with {@code job}. */
-  private int runningJobsForHost(Job job) {
+  /** Returns the number of running calls that share a host with {@code call}. */
+  private int runningCallsForHost(AsyncCall call) {
     int result = 0;
-    for (Job j : runningJobs) {
-      if (j.host().equals(job.host())) result++;
+    for (AsyncCall c : runningCalls) {
+      if (c.host().equals(call.host())) result++;
     }
     return result;
   }
diff --git a/okhttp/src/main/java/com/squareup/okhttp/Failure.java b/okhttp/src/main/java/com/squareup/okhttp/Failure.java
deleted file mode 100644
index 51ee2eae34..0000000000
--- a/okhttp/src/main/java/com/squareup/okhttp/Failure.java
+++ /dev/null
@@ -1,56 +0,0 @@
-/*
- * Copyright (C) 2013 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.squareup.okhttp;
-
-/**
- * A failure attempting to retrieve an HTTP response.
- */
-public final class Failure {
-  private final Request request;
-  private final Throwable exception;
-
-  private Failure(Builder builder) {
-    this.request = builder.request;
-    this.exception = builder.exception;
-  }
-
-  public Request request() {
-    return request;
-  }
-
-  public Throwable exception() {
-    return exception;
-  }
-
-  public static class Builder {
-    private Request request;
-    private Throwable exception;
-
-    public Builder request(Request request) {
-      this.request = request;
-      return this;
-    }
-
-    public Builder exception(Throwable exception) {
-      this.exception = exception;
-      return this;
-    }
-
-    public Failure build() {
-      return new Failure(this);
-    }
-  }
-}
diff --git a/okhttp/src/main/java/com/squareup/okhttp/FormEncodingBuilder.java b/okhttp/src/main/java/com/squareup/okhttp/FormEncodingBuilder.java
new file mode 100644
index 0000000000..891fbff005
--- /dev/null
+++ b/okhttp/src/main/java/com/squareup/okhttp/FormEncodingBuilder.java
@@ -0,0 +1,56 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.okhttp;
+
+import com.squareup.okhttp.internal.Util;
+import java.io.UnsupportedEncodingException;
+import java.net.URLEncoder;
+
+/**
+ * Fluent API to build <a href="http://www.w3.org/MarkUp/html-spec/html-spec_8.html#SEC8.2.1">HTML
+ * 2.0</a>-compliant form data.
+ */
+public final class FormEncodingBuilder {
+  private static final MediaType CONTENT_TYPE
+      = MediaType.parse("application/x-www-form-urlencoded");
+
+  private final StringBuilder content = new StringBuilder();
+
+  /** Add new key-value pair. */
+  public FormEncodingBuilder add(String name, String value) {
+    if (content.length() > 0) {
+      content.append('&');
+    }
+    try {
+      content.append(URLEncoder.encode(name, "UTF-8"))
+          .append('=')
+          .append(URLEncoder.encode(value, "UTF-8"));
+    } catch (UnsupportedEncodingException e) {
+      throw new AssertionError(e);
+    }
+    return this;
+  }
+
+  public RequestBody build() {
+    if (content.length() == 0) {
+      throw new IllegalStateException("Form encoded body must have at least one part.");
+    }
+
+    // Convert to bytes so RequestBody.create() doesn't add a charset to the content-type.
+    byte[] contentBytes = content.toString().getBytes(Util.UTF_8);
+    return RequestBody.create(CONTENT_TYPE, contentBytes);
+  }
+}
diff --git a/okhttp/src/main/java/com/squareup/okhttp/Headers.java b/okhttp/src/main/java/com/squareup/okhttp/Headers.java
index 1221aa4e09..f397616d64 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/Headers.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/Headers.java
@@ -17,9 +17,11 @@
 
 package com.squareup.okhttp;
 
+import com.squareup.okhttp.internal.http.HttpDate;
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.Collections;
+import java.util.Date;
 import java.util.List;
 import java.util.Set;
 import java.util.TreeSet;
@@ -49,9 +51,23 @@ private Headers(Builder builder) {
     this.namesAndValues = builder.namesAndValues.toArray(new String[builder.namesAndValues.size()]);
   }
 
+  private Headers(String[] namesAndValues) {
+    this.namesAndValues = namesAndValues;
+  }
+
   /** Returns the last value corresponding to the specified field, or null. */
-  public String get(String fieldName) {
-    return get(namesAndValues, fieldName);
+  public String get(String name) {
+    return get(namesAndValues, name);
+  }
+
+  /**
+   * Returns the last value corresponding to the specified field parsed as an
+   * HTTP date, or null if either the field is absent or cannot be parsed as a
+   * date.
+   */
+  public Date getDate(String name) {
+    String value = get(name);
+    return value != null ? HttpDate.parse(value) : null;
   }
 
   /** Returns the number of field values. */
@@ -61,11 +77,11 @@ public int size() {
 
   /** Returns the field at {@code position} or null if that is out of range. */
   public String name(int index) {
-    int fieldNameIndex = index * 2;
-    if (fieldNameIndex < 0 || fieldNameIndex >= namesAndValues.length) {
+    int nameIndex = index * 2;
+    if (nameIndex < 0 || nameIndex >= namesAndValues.length) {
       return null;
     }
-    return namesAndValues[fieldNameIndex];
+    return namesAndValues[nameIndex];
   }
 
   /** Returns the value at {@code index} or null if that is out of range. */
@@ -79,7 +95,7 @@ public String value(int index) {
 
   /** Returns an immutable case-insensitive set of header names. */
   public Set<String> names() {
-    TreeSet<String> result = new TreeSet<String>(String.CASE_INSENSITIVE_ORDER);
+    TreeSet<String> result = new TreeSet<>(String.CASE_INSENSITIVE_ORDER);
     for (int i = 0; i < size(); i++) {
       result.add(name(i));
     }
@@ -91,7 +107,7 @@ public String value(int index) {
     List<String> result = null;
     for (int i = 0; i < size(); i++) {
       if (name.equalsIgnoreCase(name(i))) {
-        if (result == null) result = new ArrayList<String>(2);
+        if (result == null) result = new ArrayList<>(2);
         result.add(value(i));
       }
     }
@@ -100,19 +116,6 @@ public String value(int index) {
         : Collections.<String>emptyList();
   }
 
-  /** @param fieldNames a case-insensitive set of HTTP header field names. */
-  // TODO: it is very weird to request a case-insensitive set as a parameter.
-  public Headers getAll(Set<String> fieldNames) {
-    Builder result = new Builder();
-    for (int i = 0; i < namesAndValues.length; i += 2) {
-      String fieldName = namesAndValues[i];
-      if (fieldNames.contains(fieldName)) {
-        result.add(fieldName, namesAndValues[i + 1]);
-      }
-    }
-    return result.build();
-  }
-
   public Builder newBuilder() {
     Builder result = new Builder();
     result.namesAndValues.addAll(Arrays.asList(namesAndValues));
@@ -127,20 +130,49 @@ public Builder newBuilder() {
     return result.toString();
   }
 
-  private static String get(String[] namesAndValues, String fieldName) {
+  private static String get(String[] namesAndValues, String name) {
     for (int i = namesAndValues.length - 2; i >= 0; i -= 2) {
-      if (fieldName.equalsIgnoreCase(namesAndValues[i])) {
+      if (name.equalsIgnoreCase(namesAndValues[i])) {
         return namesAndValues[i + 1];
       }
     }
     return null;
   }
 
+  /**
+   * Returns headers for the alternating header names and values. There must be
+   * an even number of arguments, and they must alternate between header names
+   * and values.
+   */
+  public static Headers of(String... namesAndValues) {
+    if (namesAndValues == null || namesAndValues.length % 2 != 0) {
+      throw new IllegalArgumentException("Expected alternating header names and values");
+    }
+
+    // Make a defensive copy and clean it up.
+    namesAndValues = namesAndValues.clone();
+    for (int i = 0; i < namesAndValues.length; i++) {
+      if (namesAndValues[i] == null) throw new IllegalArgumentException("Headers cannot be null");
+      namesAndValues[i] = namesAndValues[i].trim();
+    }
+
+    // Check for malformed headers.
+    for (int i = 0; i < namesAndValues.length; i += 2) {
+      String name = namesAndValues[i];
+      String value = namesAndValues[i + 1];
+      if (name.length() == 0 || name.indexOf('\0') != -1 || value.indexOf('\0') != -1) {
+        throw new IllegalArgumentException("Unexpected header: " + name + ": " + value);
+      }
+    }
+
+    return new Headers(namesAndValues);
+  }
+
   public static class Builder {
-    private final List<String> namesAndValues = new ArrayList<String>(20);
+    private final List<String> namesAndValues = new ArrayList<>(20);
 
     /** Add an header line containing a field name, a literal colon, and a value. */
-    public Builder addLine(String line) {
+    Builder addLine(String line) {
       int index = line.indexOf(":", 1);
       if (index != -1) {
         return addLenient(line.substring(0, index), line.substring(index + 1));
@@ -154,30 +186,31 @@ public Builder addLine(String line) {
     }
 
     /** Add a field with the specified value. */
-    public Builder add(String fieldName, String value) {
-      if (fieldName == null) throw new IllegalArgumentException("fieldname == null");
+    public Builder add(String name, String value) {
+      if (name == null) throw new IllegalArgumentException("name == null");
       if (value == null) throw new IllegalArgumentException("value == null");
-      if (fieldName.length() == 0 || fieldName.indexOf('\0') != -1 || value.indexOf('\0') != -1) {
-        throw new IllegalArgumentException("Unexpected header: " + fieldName + ": " + value);
+      if (name.length() == 0 || name.indexOf('\0') != -1 || value.indexOf('\0') != -1) {
+        throw new IllegalArgumentException("Unexpected header: " + name + ": " + value);
       }
-      return addLenient(fieldName, value);
+      return addLenient(name, value);
     }
 
     /**
      * Add a field with the specified value without any validation. Only
      * appropriate for headers from the remote peer.
      */
-    private Builder addLenient(String fieldName, String value) {
-      namesAndValues.add(fieldName);
+    private Builder addLenient(String name, String value) {
+      namesAndValues.add(name);
       namesAndValues.add(value.trim());
       return this;
     }
 
-    public Builder removeAll(String fieldName) {
+    public Builder removeAll(String name) {
       for (int i = 0; i < namesAndValues.size(); i += 2) {
-        if (fieldName.equalsIgnoreCase(namesAndValues.get(i))) {
-          namesAndValues.remove(i); // field name
+        if (name.equalsIgnoreCase(namesAndValues.get(i))) {
+          namesAndValues.remove(i); // name
           namesAndValues.remove(i); // value
+          i -= 2;
         }
       }
       return this;
@@ -187,16 +220,16 @@ public Builder removeAll(String fieldName) {
      * Set a field with the specified value. If the field is not found, it is
      * added. If the field is found, the existing values are replaced.
      */
-    public Builder set(String fieldName, String value) {
-      removeAll(fieldName);
-      add(fieldName, value);
+    public Builder set(String name, String value) {
+      removeAll(name);
+      add(name, value);
       return this;
     }
 
-    /** Equivalent to {@code build().get(fieldName)}, but potentially faster. */
-    public String get(String fieldName) {
+    /** Equivalent to {@code build().get(name)}, but potentially faster. */
+    public String get(String name) {
       for (int i = namesAndValues.size() - 2; i >= 0; i -= 2) {
-        if (fieldName.equalsIgnoreCase(namesAndValues.get(i))) {
+        if (name.equalsIgnoreCase(namesAndValues.get(i))) {
           return namesAndValues.get(i + 1);
         }
       }
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/Dns.java b/okhttp/src/main/java/com/squareup/okhttp/HostResolver.java
similarity index 90%
rename from okhttp/src/main/java/com/squareup/okhttp/internal/Dns.java
rename to okhttp/src/main/java/com/squareup/okhttp/HostResolver.java
index a89b293c08..c7a1edbaa6 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/Dns.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/HostResolver.java
@@ -13,7 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.squareup.okhttp.internal;
+package com.squareup.okhttp;
 
 import java.net.InetAddress;
 import java.net.UnknownHostException;
@@ -22,8 +22,8 @@
  * Domain name service. Prefer this over {@link InetAddress#getAllByName} to
  * make code more testable.
  */
-public interface Dns {
-  Dns DEFAULT = new Dns() {
+public interface HostResolver {
+  HostResolver DEFAULT = new HostResolver() {
     @Override public InetAddress[] getAllByName(String host) throws UnknownHostException {
       if (host == null) throw new UnknownHostException("host == null");
       return InetAddress.getAllByName(host);
diff --git a/okhttp/src/main/java/com/squareup/okhttp/Job.java b/okhttp/src/main/java/com/squareup/okhttp/Job.java
deleted file mode 100644
index 54dff42c8e..0000000000
--- a/okhttp/src/main/java/com/squareup/okhttp/Job.java
+++ /dev/null
@@ -1,273 +0,0 @@
-/*
- * Copyright (C) 2013 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.squareup.okhttp;
-
-import com.squareup.okhttp.internal.NamedRunnable;
-import com.squareup.okhttp.internal.http.HttpAuthenticator;
-import com.squareup.okhttp.internal.http.HttpEngine;
-import com.squareup.okhttp.internal.http.HttpURLConnectionImpl;
-import com.squareup.okhttp.internal.http.OkHeaders;
-import java.io.IOException;
-import java.io.InputStream;
-import java.net.ProtocolException;
-import java.net.Proxy;
-import java.net.URL;
-import okio.BufferedSink;
-import okio.Okio;
-import okio.Source;
-
-import static com.squareup.okhttp.internal.Util.getEffectivePort;
-import static com.squareup.okhttp.internal.http.HttpURLConnectionImpl.HTTP_MOVED_PERM;
-import static com.squareup.okhttp.internal.http.HttpURLConnectionImpl.HTTP_MOVED_TEMP;
-import static com.squareup.okhttp.internal.http.HttpURLConnectionImpl.HTTP_MULT_CHOICE;
-import static com.squareup.okhttp.internal.http.HttpURLConnectionImpl.HTTP_PROXY_AUTH;
-import static com.squareup.okhttp.internal.http.HttpURLConnectionImpl.HTTP_SEE_OTHER;
-import static com.squareup.okhttp.internal.http.HttpURLConnectionImpl.HTTP_UNAUTHORIZED;
-import static com.squareup.okhttp.internal.http.StatusLine.HTTP_TEMP_REDIRECT;
-
-final class Job extends NamedRunnable {
-  private final Dispatcher dispatcher;
-  private final OkHttpClient client;
-  private final Response.Receiver responseReceiver;
-  private int redirectionCount;
-
-  volatile boolean canceled;
-
-  /** The request; possibly a consequence of redirects or auth headers. */
-  private Request request;
-  HttpEngine engine;
-
-  public Job(Dispatcher dispatcher, OkHttpClient client, Request request,
-      Response.Receiver responseReceiver) {
-    super("OkHttp %s", request.urlString());
-    this.dispatcher = dispatcher;
-    this.client = client;
-    this.request = request;
-    this.responseReceiver = responseReceiver;
-  }
-
-  String host() {
-    return request.url().getHost();
-  }
-
-  Request request() {
-    return request;
-  }
-
-  Object tag() {
-    return request.tag();
-  }
-
-  @Override protected void execute() {
-    try {
-      Response response = getResponse();
-      if (response != null && !canceled) {
-        responseReceiver.onResponse(response);
-      }
-    } catch (IOException e) {
-      responseReceiver.onFailure(new Failure.Builder()
-          .request(request)
-          .exception(e)
-          .build());
-    } finally {
-      engine.close(); // Close the connection if it isn't already.
-      dispatcher.finished(this);
-    }
-  }
-
-  /**
-   * Performs the request and returns the response. May return null if this job
-   * was canceled.
-   */
-  Response getResponse() throws IOException {
-    Response redirectedBy = null;
-
-    // Copy body metadata to the appropriate request headers.
-    Request.Body body = request.body();
-    if (body != null) {
-      MediaType contentType = body.contentType();
-      if (contentType == null) throw new IllegalStateException("contentType == null");
-
-      Request.Builder requestBuilder = request.newBuilder();
-      requestBuilder.header("Content-Type", contentType.toString());
-
-      long contentLength = body.contentLength();
-      if (contentLength != -1) {
-        requestBuilder.header("Content-Length", Long.toString(contentLength));
-        requestBuilder.removeHeader("Transfer-Encoding");
-      } else {
-        requestBuilder.header("Transfer-Encoding", "chunked");
-        requestBuilder.removeHeader("Content-Length");
-      }
-
-      request = requestBuilder.build();
-    }
-
-    // Create the initial HTTP engine. Retries and redirects need new engine for each attempt.
-    engine = new HttpEngine(client, request, false, null, null, null);
-
-    while (true) {
-      if (canceled) return null;
-
-      try {
-        engine.sendRequest();
-
-        if (body != null) {
-          BufferedSink sink = Okio.buffer(engine.getRequestBody());
-          body.writeTo(sink);
-          sink.flush();
-        }
-
-        engine.readResponse();
-      } catch (IOException e) {
-        HttpEngine retryEngine = engine.recover(e);
-        if (retryEngine != null) {
-          engine = retryEngine;
-          continue;
-        }
-
-        // Give up; recovery is not possible.
-        throw e;
-      }
-
-      Response response = engine.getResponse();
-      Request redirect = processResponse(engine, response);
-
-      if (redirect == null) {
-        engine.releaseConnection();
-        return response.newBuilder()
-            // Cache body includes original content-length and content-type data.
-            .body(engine.responseSource().usesCache()
-                ? engine.getResponse().body()
-                : new RealResponseBody(response, engine.getResponseBody()))
-            .redirectedBy(redirectedBy)
-            .build();
-      }
-
-      if (!sameConnection(request, redirect)) {
-        engine.releaseConnection();
-      }
-
-      Connection connection = engine.close();
-      redirectedBy = response.newBuilder().redirectedBy(redirectedBy).build(); // Chained.
-      request = redirect;
-      engine = new HttpEngine(client, request, false, connection, null, null);
-    }
-  }
-
-  /**
-   * Figures out the HTTP request to make in response to receiving {@code
-   * response}. This will either add authentication headers or follow
-   * redirects. If a follow-up is either unnecessary or not applicable, this
-   * returns null.
-   */
-  private Request processResponse(HttpEngine engine, Response response) throws IOException {
-    Request request = response.request();
-    Proxy selectedProxy = engine.getRoute() != null
-        ? engine.getRoute().getProxy()
-        : client.getProxy();
-    int responseCode = response.code();
-
-    switch (responseCode) {
-      case HTTP_PROXY_AUTH:
-        if (selectedProxy.type() != Proxy.Type.HTTP) {
-          throw new ProtocolException("Received HTTP_PROXY_AUTH (407) code while not using proxy");
-        }
-        // fall-through
-      case HTTP_UNAUTHORIZED:
-        return HttpAuthenticator.processAuthHeader(
-            client.getAuthenticator(), response, selectedProxy);
-
-      case HTTP_MULT_CHOICE:
-      case HTTP_MOVED_PERM:
-      case HTTP_MOVED_TEMP:
-      case HTTP_SEE_OTHER:
-      case HTTP_TEMP_REDIRECT:
-        if (!client.getFollowProtocolRedirects()) {
-          return null; // This client has is configured to not follow redirects.
-        }
-
-        if (++redirectionCount > HttpURLConnectionImpl.MAX_REDIRECTS) {
-          throw new ProtocolException("Too many redirects: " + redirectionCount);
-        }
-
-        String method = request.method();
-        if (responseCode == HTTP_TEMP_REDIRECT && !method.equals("GET") && !method.equals("HEAD")) {
-          // "If the 307 status code is received in response to a request other than GET or HEAD,
-          // the user agent MUST NOT automatically redirect the request"
-          return null;
-        }
-
-        String location = response.header("Location");
-        if (location == null) {
-          return null;
-        }
-
-        URL url = new URL(request.url(), location);
-        if (!url.getProtocol().equals("https") && !url.getProtocol().equals("http")) {
-          return null; // Don't follow redirects to unsupported protocols.
-        }
-
-        return this.request.newBuilder().url(url).build();
-
-      default:
-        return null;
-    }
-  }
-
-  static boolean sameConnection(Request a, Request b) {
-    return a.url().getHost().equals(b.url().getHost())
-        && getEffectivePort(a.url()) == getEffectivePort(b.url())
-        && a.url().getProtocol().equals(b.url().getProtocol());
-  }
-
-  static class RealResponseBody extends Response.Body {
-    private final Response response;
-    private final Source source;
-
-    /** Multiple calls to {@link #byteStream} must return the same instance. */
-    private InputStream in;
-
-    RealResponseBody(Response response, Source source) {
-      this.response = response;
-      this.source = source;
-    }
-
-    @Override public boolean ready() throws IOException {
-      return true;
-    }
-
-    @Override public MediaType contentType() {
-      String contentType = response.header("Content-Type");
-      return contentType != null ? MediaType.parse(contentType) : null;
-    }
-
-    @Override public long contentLength() {
-      return OkHeaders.contentLength(response);
-    }
-
-    @Override public Source source() {
-      return source;
-    }
-
-    @Override public InputStream byteStream() {
-      InputStream result = in;
-      return result != null
-          ? result
-          : (in = Okio.buffer(source).inputStream());
-    }
-  }
-}
diff --git a/okhttp/src/main/java/com/squareup/okhttp/MediaType.java b/okhttp/src/main/java/com/squareup/okhttp/MediaType.java
index 2c09596ff7..4d2f1fcf44 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/MediaType.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/MediaType.java
@@ -29,7 +29,7 @@
   private static final String QUOTED = "\"([^\"]*)\"";
   private static final Pattern TYPE_SUBTYPE = Pattern.compile(TOKEN + "/" + TOKEN);
   private static final Pattern PARAMETER = Pattern.compile(
-      ";\\s*" + TOKEN + "=(?:" + TOKEN + "|" + QUOTED + ")");
+      ";\\s*(?:" + TOKEN + "=(?:" + TOKEN + "|" + QUOTED + "))?");
 
   private final String mediaType;
   private final String type;
@@ -61,10 +61,13 @@ public static MediaType parse(String string) {
 
       String name = parameter.group(1);
       if (name == null || !name.equalsIgnoreCase("charset")) continue;
-      if (charset != null) throw new IllegalArgumentException("Multiple charsets: " + string);
-      charset = parameter.group(2) != null
+      String charsetParameter = parameter.group(2) != null
           ? parameter.group(2)  // Value is a token.
           : parameter.group(3); // Value is a quoted string.
+      if (charset != null && !charsetParameter.equalsIgnoreCase(charset)) {
+        throw new IllegalArgumentException("Multiple different charsets: " + string);
+      }
+      charset = charsetParameter;
     }
 
     return new MediaType(string, type, subtype, charset);
diff --git a/okhttp/src/main/java/com/squareup/okhttp/MultipartBuilder.java b/okhttp/src/main/java/com/squareup/okhttp/MultipartBuilder.java
new file mode 100644
index 0000000000..e31d183951
--- /dev/null
+++ b/okhttp/src/main/java/com/squareup/okhttp/MultipartBuilder.java
@@ -0,0 +1,288 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.okhttp;
+
+import com.squareup.okhttp.internal.Util;
+import java.io.IOException;
+import java.util.ArrayList;
+import java.util.List;
+import java.util.UUID;
+import okio.Buffer;
+import okio.BufferedSink;
+import okio.ByteString;
+
+/**
+ * Fluent API to build <a href="http://www.ietf.org/rfc/rfc2387.txt">RFC
+ * 2387</a>-compliant request bodies.
+ */
+public final class MultipartBuilder {
+  /**
+   * The "mixed" subtype of "multipart" is intended for use when the body
+   * parts are independent and need to be bundled in a particular order. Any
+   * "multipart" subtypes that an implementation does not recognize must be
+   * treated as being of subtype "mixed".
+   */
+  public static final MediaType MIXED = MediaType.parse("multipart/mixed");
+
+  /**
+   * The "multipart/alternative" type is syntactically identical to
+   * "multipart/mixed", but the semantics are different. In particular, each
+   * of the body parts is an "alternative" version of the same information.
+   */
+  public static final MediaType ALTERNATIVE = MediaType.parse("multipart/alternative");
+
+  /**
+   * This type is syntactically identical to "multipart/mixed", but the
+   * semantics are different. In particular, in a digest, the default {@code
+   * Content-Type} value for a body part is changed from "text/plain" to
+   * "message/rfc822".
+   */
+  public static final MediaType DIGEST = MediaType.parse("multipart/digest");
+
+  /**
+   * This type is syntactically identical to "multipart/mixed", but the
+   * semantics are different. In particular, in a parallel entity, the order
+   * of body parts is not significant.
+   */
+  public static final MediaType PARALLEL = MediaType.parse("multipart/parallel");
+
+  /**
+   * The media-type multipart/form-data follows the rules of all multipart
+   * MIME data streams as outlined in RFC 2046. In forms, there are a series
+   * of fields to be supplied by the user who fills out the form. Each field
+   * has a name. Within a given form, the names are unique.
+   */
+  public static final MediaType FORM = MediaType.parse("multipart/form-data");
+
+  private static final byte[] COLONSPACE = { ':', ' ' };
+  private static final byte[] CRLF = { '\r', '\n' };
+  private static final byte[] DASHDASH = { '-', '-' };
+
+  private final ByteString boundary;
+  private MediaType type = MIXED;
+  private long length = 0;
+
+  // Parallel lists of nullable headings (boundary + headers) and non-null bodies.
+  private final List<Buffer> partHeadings = new ArrayList<>();
+  private final List<RequestBody> partBodies = new ArrayList<>();
+
+  /** Creates a new multipart builder that uses a random boundary token. */
+  public MultipartBuilder() {
+    this(UUID.randomUUID().toString());
+  }
+
+  /**
+   * Creates a new multipart builder that uses {@code boundary} to separate
+   * parts. Prefer the no-argument constructor to defend against injection
+   * attacks.
+   */
+  public MultipartBuilder(String boundary) {
+    this.boundary = ByteString.encodeUtf8(boundary);
+  }
+
+  /**
+   * Set the MIME type. Expected values for {@code type} are {@link #MIXED} (the
+   * default), {@link #ALTERNATIVE}, {@link #DIGEST}, {@link #PARALLEL} and
+   * {@link #FORM}.
+   */
+  public MultipartBuilder type(MediaType type) {
+    if (type == null) {
+      throw new NullPointerException("type == null");
+    }
+    if (!type.type().equals("multipart")) {
+      throw new IllegalArgumentException("multipart != " + type);
+    }
+    this.type = type;
+    return this;
+  }
+
+  /** Add a part to the body. */
+  public MultipartBuilder addPart(RequestBody body) {
+    return addPart(null, body);
+  }
+
+  /** Add a part to the body. */
+  public MultipartBuilder addPart(Headers headers, RequestBody body) {
+    if (body == null) {
+      throw new NullPointerException("body == null");
+    }
+    if (headers != null && headers.get("Content-Type") != null) {
+      throw new IllegalArgumentException("Unexpected header: Content-Type");
+    }
+    if (headers != null && headers.get("Content-Length") != null) {
+      throw new IllegalArgumentException("Unexpected header: Content-Length");
+    }
+
+    Buffer heading = createPartHeading(headers, body, partHeadings.isEmpty());
+    partHeadings.add(heading);
+    partBodies.add(body);
+
+    long bodyContentLength = body.contentLength();
+    if (bodyContentLength == -1) {
+      length = -1;
+    } else if (length != -1) {
+      length += heading.size() + bodyContentLength;
+    }
+
+    return this;
+  }
+
+  /**
+   * Appends a quoted-string to a StringBuilder.
+   *
+   * <p>RFC 2388 is rather vague about how one should escape special characters
+   * in form-data parameters, and as it turns out Firefox and Chrome actually
+   * do rather different things, and both say in their comments that they're
+   * not really sure what the right approach is. We go with Chrome's behavior
+   * (which also experimentally seems to match what IE does), but if you
+   * actually want to have a good chance of things working, please avoid
+   * double-quotes, newlines, percent signs, and the like in your field names.
+   */
+  private static StringBuilder appendQuotedString(StringBuilder target, String key) {
+    target.append('"');
+    for (int i = 0, len = key.length(); i < len; i++) {
+      char ch = key.charAt(i);
+      switch (ch) {
+        case '\n':
+          target.append("%0A");
+          break;
+        case '\r':
+          target.append("%0D");
+          break;
+        case '"':
+          target.append("%22");
+          break;
+        default:
+          target.append(ch);
+          break;
+      }
+    }
+    target.append('"');
+    return target;
+  }
+
+  /** Add a form data part to the body. */
+  public MultipartBuilder addFormDataPart(String name, String value) {
+    return addFormDataPart(name, null, RequestBody.create(null, value));
+  }
+
+  /** Add a form data part to the body. */
+  public MultipartBuilder addFormDataPart(String name, String filename, RequestBody value) {
+    if (name == null) {
+      throw new NullPointerException("name == null");
+    }
+    StringBuilder disposition = new StringBuilder("form-data; name=");
+    appendQuotedString(disposition, name);
+
+    if (filename != null) {
+      disposition.append("; filename=");
+      appendQuotedString(disposition, filename);
+    }
+
+    return addPart(Headers.of("Content-Disposition", disposition.toString()), value);
+  }
+
+  /** Creates a part "heading" from the boundary and any real or generated headers. */
+  private Buffer createPartHeading(Headers headers, RequestBody body, boolean isFirst) {
+    Buffer sink = new Buffer();
+
+    if (!isFirst) {
+      sink.write(CRLF);
+    }
+    sink.write(DASHDASH);
+    sink.write(boundary);
+    sink.write(CRLF);
+
+    if (headers != null) {
+      for (int i = 0; i < headers.size(); i++) {
+        sink.writeUtf8(headers.name(i))
+            .write(COLONSPACE)
+            .writeUtf8(headers.value(i))
+            .write(CRLF);
+      }
+    }
+
+    MediaType contentType = body.contentType();
+    if (contentType != null) {
+      sink.writeUtf8("Content-Type: ")
+          .writeUtf8(contentType.toString())
+          .write(CRLF);
+    }
+
+    long contentLength = body.contentLength();
+    if (contentLength != -1) {
+      sink.writeUtf8("Content-Length: ")
+          .writeUtf8(Long.toString(contentLength))
+          .write(CRLF);
+    }
+
+    sink.write(CRLF);
+
+    return sink;
+  }
+
+  /** Assemble the specified parts into a request body. */
+  public RequestBody build() {
+    if (partHeadings.isEmpty()) {
+      throw new IllegalStateException("Multipart body must have at least one part.");
+    }
+    return new MultipartRequestBody(type, boundary, partHeadings, partBodies, length);
+  }
+
+  private static final class MultipartRequestBody extends RequestBody {
+    private final ByteString boundary;
+    private final MediaType contentType;
+    private final List<Buffer> partHeadings;
+    private final List<RequestBody> partBodies;
+    private final long length;
+
+    public MultipartRequestBody(MediaType type, ByteString boundary, List<Buffer> partHeadings,
+        List<RequestBody> partBodies, long length) {
+      if (type == null) throw new NullPointerException("type == null");
+
+      this.boundary = boundary;
+      this.contentType = MediaType.parse(type + "; boundary=" + boundary.utf8());
+      this.partHeadings = Util.immutableList(partHeadings);
+      this.partBodies = Util.immutableList(partBodies);
+      if (length != -1) {
+        // Add the length of the final boundary.
+        length += CRLF.length + DASHDASH.length + boundary.size() + DASHDASH.length + CRLF.length;
+      }
+      this.length = length;
+    }
+
+    @Override public long contentLength() {
+      return length;
+    }
+
+    @Override public MediaType contentType() {
+      return contentType;
+    }
+
+    @Override public void writeTo(BufferedSink sink) throws IOException {
+      for (int i = 0, size = partHeadings.size(); i < size; i++) {
+        sink.writeAll(partHeadings.get(i).clone());
+        partBodies.get(i).writeTo(sink);
+      }
+
+      sink.write(CRLF);
+      sink.write(DASHDASH);
+      sink.write(boundary);
+      sink.write(DASHDASH);
+      sink.write(CRLF);
+    }
+  }
+}
diff --git a/okhttp/src/main/java/com/squareup/okhttp/OkAuthenticator.java b/okhttp/src/main/java/com/squareup/okhttp/OkAuthenticator.java
deleted file mode 100644
index e8ca5ea87c..0000000000
--- a/okhttp/src/main/java/com/squareup/okhttp/OkAuthenticator.java
+++ /dev/null
@@ -1,123 +0,0 @@
-/*
- * Copyright (C) 2013 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.squareup.okhttp;
-
-import java.io.IOException;
-import java.io.UnsupportedEncodingException;
-import java.net.Proxy;
-import java.net.URL;
-import java.util.List;
-import okio.ByteString;
-
-/**
- * Responds to authentication challenges from the remote web or proxy server by
- * returning credentials.
- */
-public interface OkAuthenticator {
-  /**
-   * Returns a credential that satisfies the authentication challenge made by
-   * {@code url}. Returns null if the challenge cannot be satisfied. This method
-   * is called in response to an HTTP 401 unauthorized status code sent by the
-   * origin server.
-   *
-   * @param challenges parsed "WWW-Authenticate" challenge headers from the HTTP
-   *     response.
-   */
-  Credential authenticate(Proxy proxy, URL url, List<Challenge> challenges) throws IOException;
-
-  /**
-   * Returns a credential that satisfies the authentication challenge made by
-   * {@code proxy}. Returns null if the challenge cannot be satisfied. This
-   * method is called in response to an HTTP 401 unauthorized status code sent
-   * by the proxy server.
-   *
-   * @param challenges parsed "Proxy-Authenticate" challenge headers from the
-   *     HTTP response.
-   */
-  Credential authenticateProxy(Proxy proxy, URL url, List<Challenge> challenges) throws IOException;
-
-  /** An RFC 2617 challenge. */
-  public final class Challenge {
-    private final String scheme;
-    private final String realm;
-
-    public Challenge(String scheme, String realm) {
-      this.scheme = scheme;
-      this.realm = realm;
-    }
-
-    /** Returns the authentication scheme, like {@code Basic}. */
-    public String getScheme() {
-      return scheme;
-    }
-
-    /** Returns the protection space. */
-    public String getRealm() {
-      return realm;
-    }
-
-    @Override public boolean equals(Object o) {
-      return o instanceof Challenge
-          && ((Challenge) o).scheme.equals(scheme)
-          && ((Challenge) o).realm.equals(realm);
-    }
-
-    @Override public int hashCode() {
-      return scheme.hashCode() + 31 * realm.hashCode();
-    }
-
-    @Override public String toString() {
-      return scheme + " realm=\"" + realm + "\"";
-    }
-  }
-
-  /** An RFC 2617 credential. */
-  public final class Credential {
-    private final String headerValue;
-
-    private Credential(String headerValue) {
-      this.headerValue = headerValue;
-    }
-
-    /** Returns an auth credential for the Basic scheme. */
-    public static Credential basic(String userName, String password) {
-      try {
-        String usernameAndPassword = userName + ":" + password;
-        byte[] bytes = usernameAndPassword.getBytes("ISO-8859-1");
-        String encoded = ByteString.of(bytes).base64();
-        return new Credential("Basic " + encoded);
-      } catch (UnsupportedEncodingException e) {
-        throw new AssertionError();
-      }
-    }
-
-    public String getHeaderValue() {
-      return headerValue;
-    }
-
-    @Override public boolean equals(Object o) {
-      return o instanceof Credential && ((Credential) o).headerValue.equals(headerValue);
-    }
-
-    @Override public int hashCode() {
-      return headerValue.hashCode();
-    }
-
-    @Override public String toString() {
-      return headerValue;
-    }
-  }
-}
diff --git a/okhttp/src/main/java/com/squareup/okhttp/OkHttpClient.java b/okhttp/src/main/java/com/squareup/okhttp/OkHttpClient.java
index e2fd6104a8..916062617f 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/OkHttpClient.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/OkHttpClient.java
@@ -15,33 +15,99 @@
  */
 package com.squareup.okhttp;
 
+import com.squareup.okhttp.internal.Internal;
+import com.squareup.okhttp.internal.InternalCache;
+import com.squareup.okhttp.internal.RouteDatabase;
 import com.squareup.okhttp.internal.Util;
-import com.squareup.okhttp.internal.http.HttpAuthenticator;
-import com.squareup.okhttp.internal.http.HttpURLConnectionImpl;
-import com.squareup.okhttp.internal.http.HttpsURLConnectionImpl;
-import com.squareup.okhttp.internal.http.ResponseCacheAdapter;
+import com.squareup.okhttp.internal.http.AuthenticatorAdapter;
+import com.squareup.okhttp.internal.http.HttpEngine;
+import com.squareup.okhttp.internal.http.Transport;
 import com.squareup.okhttp.internal.tls.OkHostnameVerifier;
 import java.io.IOException;
 import java.net.CookieHandler;
-import java.net.HttpURLConnection;
 import java.net.Proxy;
 import java.net.ProxySelector;
-import java.net.ResponseCache;
-import java.net.URL;
 import java.net.URLConnection;
-import java.net.URLStreamHandler;
-import java.net.URLStreamHandlerFactory;
 import java.security.GeneralSecurityException;
-import java.util.ArrayList;
 import java.util.List;
 import java.util.concurrent.TimeUnit;
+import javax.net.SocketFactory;
 import javax.net.ssl.HostnameVerifier;
 import javax.net.ssl.SSLContext;
 import javax.net.ssl.SSLSocketFactory;
-import okio.ByteString;
 
-/** Configures and creates HTTP connections. */
-public final class OkHttpClient implements URLStreamHandlerFactory, Cloneable {
+/**
+ * Configures and creates HTTP connections. Most applications can use a single
+ * OkHttpClient for all of their HTTP requests - benefiting from a shared
+ * response cache, thread pool, connection re-use, etc.
+ *
+ * <p>Instances of OkHttpClient are intended to be fully configured before they're
+ * shared - once shared they should be treated as immutable and can safely be used
+ * to concurrently open new connections. If required, threads can call
+ * {@link #clone()} to make a shallow copy of the OkHttpClient that can be
+ * safely modified with further configuration changes.
+ */
+public class OkHttpClient implements Cloneable {
+  static {
+    Internal.instance = new Internal() {
+      @Override public Transport newTransport(
+          Connection connection, HttpEngine httpEngine) throws IOException {
+        return connection.newTransport(httpEngine);
+      }
+
+      @Override public boolean clearOwner(Connection connection) {
+        return connection.clearOwner();
+      }
+
+      @Override public void closeIfOwnedBy(Connection connection, Object owner) throws IOException {
+        connection.closeIfOwnedBy(owner);
+      }
+
+      @Override public int recycleCount(Connection connection) {
+        return connection.recycleCount();
+      }
+
+      @Override public void setProtocol(Connection connection, Protocol protocol) {
+        connection.setProtocol(protocol);
+      }
+
+      @Override public void setOwner(Connection connection, HttpEngine httpEngine) {
+        connection.setOwner(httpEngine);
+      }
+
+      @Override public boolean isReadable(Connection pooled) {
+        return pooled.isReadable();
+      }
+
+      @Override public void addLine(Headers.Builder builder, String line) {
+        builder.addLine(line);
+      }
+
+      @Override public void setCache(OkHttpClient client, InternalCache internalCache) {
+        client.setInternalCache(internalCache);
+      }
+
+      @Override public InternalCache internalCache(OkHttpClient client) {
+        return client.internalCache();
+      }
+
+      @Override public void recycle(ConnectionPool pool, Connection connection) {
+        pool.recycle(connection);
+      }
+
+      @Override public RouteDatabase routeDatabase(OkHttpClient client) {
+        return client.routeDatabase();
+      }
+
+      @Override public void connectAndSetOwner(OkHttpClient client, Connection connection,
+          HttpEngine owner, Request request) throws IOException {
+        connection.connectAndSetOwner(client, owner, request);
+      }
+    };
+  }
+
+  /** Lazily-initialized. */
+  private static SSLSocketFactory defaultSslSocketFactory;
 
   private final RouteDatabase routeDatabase;
   private Dispatcher dispatcher;
@@ -49,41 +115,64 @@
   private List<Protocol> protocols;
   private ProxySelector proxySelector;
   private CookieHandler cookieHandler;
-  private OkResponseCache responseCache;
+
+  /** Non-null if this client is caching; possibly by {@code cache}. */
+  private InternalCache internalCache;
+  private Cache cache;
+
+  private SocketFactory socketFactory;
   private SSLSocketFactory sslSocketFactory;
   private HostnameVerifier hostnameVerifier;
-  private OkAuthenticator authenticator;
+  private Authenticator authenticator;
   private ConnectionPool connectionPool;
-  private boolean followProtocolRedirects = true;
+  private HostResolver hostResolver;
+  private boolean followSslRedirects = true;
+  private boolean followRedirects = true;
   private int connectTimeout;
   private int readTimeout;
+  private int writeTimeout;
 
   public OkHttpClient() {
     routeDatabase = new RouteDatabase();
     dispatcher = new Dispatcher();
   }
 
+  private OkHttpClient(OkHttpClient okHttpClient) {
+    this.routeDatabase = okHttpClient.routeDatabase();
+    this.dispatcher = okHttpClient.getDispatcher();
+    this.proxy = okHttpClient.getProxy();
+    this.protocols = okHttpClient.getProtocols();
+    this.proxySelector = okHttpClient.getProxySelector();
+    this.cookieHandler = okHttpClient.getCookieHandler();
+    this.cache = okHttpClient.getCache();
+    this.internalCache = cache != null ? cache.internalCache : okHttpClient.internalCache;
+    this.socketFactory = okHttpClient.getSocketFactory();
+    this.sslSocketFactory = okHttpClient.getSslSocketFactory();
+    this.hostnameVerifier = okHttpClient.getHostnameVerifier();
+    this.authenticator = okHttpClient.getAuthenticator();
+    this.connectionPool = okHttpClient.getConnectionPool();
+    this.followSslRedirects = okHttpClient.getFollowSslRedirects();
+    this.followRedirects = okHttpClient.getFollowRedirects();
+    this.connectTimeout = okHttpClient.getConnectTimeout();
+    this.readTimeout = okHttpClient.getReadTimeout();
+    this.writeTimeout = okHttpClient.getWriteTimeout();
+  }
+
   /**
    * Sets the default connect timeout for new connections. A value of 0 means no timeout.
    *
    * @see URLConnection#setConnectTimeout(int)
    */
-  public void setConnectTimeout(long timeout, TimeUnit unit) {
-    if (timeout < 0) {
-      throw new IllegalArgumentException("timeout < 0");
-    }
-    if (unit == null) {
-      throw new IllegalArgumentException("unit == null");
-    }
+  public final void setConnectTimeout(long timeout, TimeUnit unit) {
+    if (timeout < 0) throw new IllegalArgumentException("timeout < 0");
+    if (unit == null) throw new IllegalArgumentException("unit == null");
     long millis = unit.toMillis(timeout);
-    if (millis > Integer.MAX_VALUE) {
-      throw new IllegalArgumentException("Timeout too large.");
-    }
+    if (millis > Integer.MAX_VALUE) throw new IllegalArgumentException("Timeout too large.");
     connectTimeout = (int) millis;
   }
 
   /** Default connect timeout (in milliseconds). */
-  public int getConnectTimeout() {
+  public final int getConnectTimeout() {
     return connectTimeout;
   }
 
@@ -92,37 +181,47 @@ public int getConnectTimeout() {
    *
    * @see URLConnection#setReadTimeout(int)
    */
-  public void setReadTimeout(long timeout, TimeUnit unit) {
-    if (timeout < 0) {
-      throw new IllegalArgumentException("timeout < 0");
-    }
-    if (unit == null) {
-      throw new IllegalArgumentException("unit == null");
-    }
+  public final void setReadTimeout(long timeout, TimeUnit unit) {
+    if (timeout < 0) throw new IllegalArgumentException("timeout < 0");
+    if (unit == null) throw new IllegalArgumentException("unit == null");
     long millis = unit.toMillis(timeout);
-    if (millis > Integer.MAX_VALUE) {
-      throw new IllegalArgumentException("Timeout too large.");
-    }
+    if (millis > Integer.MAX_VALUE) throw new IllegalArgumentException("Timeout too large.");
     readTimeout = (int) millis;
   }
 
   /** Default read timeout (in milliseconds). */
-  public int getReadTimeout() {
+  public final int getReadTimeout() {
     return readTimeout;
   }
 
+  /**
+   * Sets the default write timeout for new connections. A value of 0 means no timeout.
+   */
+  public final void setWriteTimeout(long timeout, TimeUnit unit) {
+    if (timeout < 0) throw new IllegalArgumentException("timeout < 0");
+    if (unit == null) throw new IllegalArgumentException("unit == null");
+    long millis = unit.toMillis(timeout);
+    if (millis > Integer.MAX_VALUE) throw new IllegalArgumentException("Timeout too large.");
+    writeTimeout = (int) millis;
+  }
+
+  /** Default write timeout (in milliseconds). */
+  public final int getWriteTimeout() {
+    return writeTimeout;
+  }
+
   /**
    * Sets the HTTP proxy that will be used by connections created by this
    * client. This takes precedence over {@link #setProxySelector}, which is
    * only honored when this proxy is null (which it is by default). To disable
    * proxy use completely, call {@code setProxy(Proxy.NO_PROXY)}.
    */
-  public OkHttpClient setProxy(Proxy proxy) {
+  public final OkHttpClient setProxy(Proxy proxy) {
     this.proxy = proxy;
     return this;
   }
 
-  public Proxy getProxy() {
+  public final Proxy getProxy() {
     return proxy;
   }
 
@@ -135,12 +234,12 @@ public Proxy getProxy() {
    * <p>If unset, the {@link ProxySelector#getDefault() system-wide default}
    * proxy selector will be used.
    */
-  public OkHttpClient setProxySelector(ProxySelector proxySelector) {
+  public final OkHttpClient setProxySelector(ProxySelector proxySelector) {
     this.proxySelector = proxySelector;
     return this;
   }
 
-  public ProxySelector getProxySelector() {
+  public final ProxySelector getProxySelector() {
     return proxySelector;
   }
 
@@ -151,35 +250,48 @@ public ProxySelector getProxySelector() {
    * <p>If unset, the {@link CookieHandler#getDefault() system-wide default}
    * cookie handler will be used.
    */
-  public OkHttpClient setCookieHandler(CookieHandler cookieHandler) {
+  public final OkHttpClient setCookieHandler(CookieHandler cookieHandler) {
     this.cookieHandler = cookieHandler;
     return this;
   }
 
-  public CookieHandler getCookieHandler() {
+  public final CookieHandler getCookieHandler() {
     return cookieHandler;
   }
 
-  /**
-   * Sets the response cache to be used to read and write cached responses.
-   */
-  public OkHttpClient setResponseCache(ResponseCache responseCache) {
-    return setOkResponseCache(toOkResponseCache(responseCache));
+  /** Sets the response cache to be used to read and write cached responses. */
+  final void setInternalCache(InternalCache internalCache) {
+    this.internalCache = internalCache;
+    this.cache = null;
   }
 
-  public ResponseCache getResponseCache() {
-    return responseCache instanceof ResponseCacheAdapter
-        ? ((ResponseCacheAdapter) responseCache).getDelegate()
-        : null;
+  final InternalCache internalCache() {
+    return internalCache;
   }
 
-  public OkHttpClient setOkResponseCache(OkResponseCache responseCache) {
-    this.responseCache = responseCache;
+  public final OkHttpClient setCache(Cache cache) {
+    this.cache = cache;
+    this.internalCache = null;
+    return this;
+  }
+
+  public final Cache getCache() {
+    return cache;
+  }
+
+  /**
+   * Sets the socket factory used to create connections.
+   *
+   * <p>If unset, the {@link SocketFactory#getDefault() system-wide default}
+   * socket factory will be used.
+   */
+  public final OkHttpClient setSocketFactory(SocketFactory socketFactory) {
+    this.socketFactory = socketFactory;
     return this;
   }
 
-  public OkResponseCache getOkResponseCache() {
-    return responseCache;
+  public final SocketFactory getSocketFactory() {
+    return socketFactory;
   }
 
   /**
@@ -187,12 +299,12 @@ public OkResponseCache getOkResponseCache() {
    *
    * <p>If unset, a lazily created SSL socket factory will be used.
    */
-  public OkHttpClient setSslSocketFactory(SSLSocketFactory sslSocketFactory) {
+  public final OkHttpClient setSslSocketFactory(SSLSocketFactory sslSocketFactory) {
     this.sslSocketFactory = sslSocketFactory;
     return this;
   }
 
-  public SSLSocketFactory getSslSocketFactory() {
+  public final SSLSocketFactory getSslSocketFactory() {
     return sslSocketFactory;
   }
 
@@ -204,12 +316,12 @@ public SSLSocketFactory getSslSocketFactory() {
    * {@link javax.net.ssl.HttpsURLConnection#getDefaultHostnameVerifier()
    * system-wide default} hostname verifier will be used.
    */
-  public OkHttpClient setHostnameVerifier(HostnameVerifier hostnameVerifier) {
+  public final OkHttpClient setHostnameVerifier(HostnameVerifier hostnameVerifier) {
     this.hostnameVerifier = hostnameVerifier;
     return this;
   }
 
-  public HostnameVerifier getHostnameVerifier() {
+  public final HostnameVerifier getHostnameVerifier() {
     return hostnameVerifier;
   }
 
@@ -220,12 +332,12 @@ public HostnameVerifier getHostnameVerifier() {
    * <p>If unset, the {@link java.net.Authenticator#setDefault system-wide default}
    * authenticator will be used.
    */
-  public OkHttpClient setAuthenticator(OkAuthenticator authenticator) {
+  public final OkHttpClient setAuthenticator(Authenticator authenticator) {
     this.authenticator = authenticator;
     return this;
   }
 
-  public OkAuthenticator getAuthenticator() {
+  public final Authenticator getAuthenticator() {
     return authenticator;
   }
 
@@ -235,12 +347,12 @@ public OkAuthenticator getAuthenticator() {
    * <p>If unset, the {@link ConnectionPool#getDefault() system-wide
    * default} connection pool will be used.
    */
-  public OkHttpClient setConnectionPool(ConnectionPool connectionPool) {
+  public final OkHttpClient setConnectionPool(ConnectionPool connectionPool) {
     this.connectionPool = connectionPool;
     return this;
   }
 
-  public ConnectionPool getConnectionPool() {
+  public final ConnectionPool getConnectionPool() {
     return connectionPool;
   }
 
@@ -251,16 +363,30 @@ public ConnectionPool getConnectionPool() {
    * <p>If unset, protocol redirects will be followed. This is different than
    * the built-in {@code HttpURLConnection}'s default.
    */
-  public OkHttpClient setFollowProtocolRedirects(boolean followProtocolRedirects) {
-    this.followProtocolRedirects = followProtocolRedirects;
+  public final OkHttpClient setFollowSslRedirects(boolean followProtocolRedirects) {
+    this.followSslRedirects = followProtocolRedirects;
     return this;
   }
 
-  public boolean getFollowProtocolRedirects() {
-    return followProtocolRedirects;
+  public final boolean getFollowSslRedirects() {
+    return followSslRedirects;
+  }
+
+  /**
+   * Configure this client to follow redirects.
+   *
+   * <p>If unset, redirects will not be followed. This is the equivalent as the
+   * built-in {@code HttpURLConnection}'s default.
+   */
+  public final void setFollowRedirects(boolean followRedirects) {
+    this.followRedirects = followRedirects;
+  }
+
+  public final boolean getFollowRedirects() {
+    return followRedirects;
   }
 
-  public RouteDatabase getRoutesDatabase() {
+  final RouteDatabase routeDatabase() {
     return routeDatabase;
   }
 
@@ -268,35 +394,16 @@ public RouteDatabase getRoutesDatabase() {
    * Sets the dispatcher used to set policy and execute asynchronous requests.
    * Must not be null.
    */
-  public OkHttpClient setDispatcher(Dispatcher dispatcher) {
+  public final OkHttpClient setDispatcher(Dispatcher dispatcher) {
     if (dispatcher == null) throw new IllegalArgumentException("dispatcher == null");
     this.dispatcher = dispatcher;
     return this;
   }
 
-  public Dispatcher getDispatcher() {
+  public final Dispatcher getDispatcher() {
     return dispatcher;
   }
 
-  /**
-   * @deprecated OkHttp 1.5 enforces an enumeration of {@link Protocol
-   *     protocols} that can be selected. Please switch to {@link
-   *     #setProtocols(java.util.List)}.
-   */
-  @Deprecated
-  public OkHttpClient setTransports(List<String> transports) {
-    List<Protocol> protocols = new ArrayList<Protocol>(transports.size());
-    for (int i = 0, size = transports.size(); i < size; i++) {
-      try {
-        Protocol protocol = Protocol.find(ByteString.encodeUtf8(transports.get(i)));
-        protocols.add(protocol);
-      } catch (IOException e) {
-        throw new IllegalArgumentException(e);
-      }
-    }
-    return setProtocols(protocols);
-  }
-
   /**
    * Configure the protocols used by this client to communicate with remote
    * servers. By default this client will prefer the most efficient transport
@@ -308,26 +415,24 @@ public OkHttpClient setTransports(List<String> transports) {
    * <ul>
    *   <li><a href="http://www.w3.org/Protocols/rfc2616/rfc2616.html">http/1.1</a>
    *   <li><a href="http://www.chromium.org/spdy/spdy-protocol/spdy-protocol-draft3-1">spdy/3.1</a>
-   *   <li><a href="http://tools.ietf.org/html/draft-ietf-httpbis-http2-09">HTTP-draft-09/2.0</a>
+   *   <li><a href="http://tools.ietf.org/html/draft-ietf-httpbis-http2-14">h2-14</a>
    * </ul>
    *
    * <p><strong>This is an evolving set.</strong> Future releases may drop
-   * support for transitional protocols (like spdy/3.1), in favor of their
-   * successors (spdy/4 or http/2.0). The http/1.1 transport will never be
-   * dropped.
+   * support for transitional protocols (like h2-14), in favor of their
+   * successors (h2). The http/1.1 transport will never be dropped.
    *
    * <p>If multiple protocols are specified, <a
-   * href="https://technotes.googlecode.com/git/nextprotoneg.html">NPN</a> will
-   * be used to negotiate a transport. Future releases may use another mechanism
-   * (such as <a href="http://tools.ietf.org/html/draft-friedl-tls-applayerprotoneg-02">ALPN</a>)
-   * to negotiate a transport.
+   * href="https://technotes.googlecode.com/git/nextprotoneg.html">NPN</a> or
+   * <a href="http://tools.ietf.org/html/draft-ietf-tls-applayerprotoneg">ALPN</a>
+   * will be used to negotiate a transport.
    *
    * @param protocols the protocols to use, in order of preference. The list
-   *     must contain "http/1.1". It must not contain null.
+   *     must contain {@link Protocol#HTTP_1_1}. It must not contain null.
    */
-  public OkHttpClient setProtocols(List<Protocol> protocols) {
+  public final OkHttpClient setProtocols(List<Protocol> protocols) {
     protocols = Util.immutableList(protocols);
-    if (!protocols.contains(Protocol.HTTP_11)) {
+    if (!protocols.contains(Protocol.HTTP_1_1)) {
       throw new IllegalArgumentException("protocols doesn't contain http/1.1: " + protocols);
     }
     if (protocols.contains(null)) {
@@ -337,114 +442,53 @@ public OkHttpClient setProtocols(List<Protocol> protocols) {
     return this;
   }
 
-  /**
-   * @deprecated OkHttp 1.5 enforces an enumeration of {@link Protocol
-   *     protocols} that can be selected. Please switch to {@link
-   *     #getProtocols()}.
-   */
-  @Deprecated
-  public List<String> getTransports() {
-    List<String> transports = new ArrayList<String>(protocols.size());
-    for (int i = 0, size = protocols.size(); i < size; i++) {
-      transports.add(protocols.get(i).name.utf8());
-    }
-    return transports;
-  }
-
-  public List<Protocol> getProtocols() {
+  public final List<Protocol> getProtocols() {
     return protocols;
   }
 
-  /**
-   * Invokes {@code request} immediately, and blocks until the response can be
-   * processed or is in error.
-   *
-   * <p>The caller may read the response body with the response's
-   * {@link Response#body} method.  To facilitate connection recycling, callers
-   * should always {@link Response.Body#close() close the response body}.
-   *
-   * <p>Note that transport-layer success (receiving a HTTP response code,
-   * headers and body) does not necessarily indicate application-layer
-   * success: {@code response} may still indicate an unhappy HTTP response
-   * code like 404 or 500.
-   *
-   * <h3>Non-blocking responses</h3>
-   *
-   * <p>Receivers do not need to block while waiting for the response body to
-   * download. Instead, they can get called back as data arrives. Use {@link
-   * Response.Body#ready} to check if bytes should be read immediately. While
-   * there is data ready, read it.
-   *
-   * <p>The current implementation of {@link Response.Body#ready} always
-   * returns true when the underlying transport is HTTP/1. This results in
-   * blocking on that transport. For effective non-blocking your server must
-   * support {@link Protocol#SPDY_3} or {@link Protocol#HTTP_2}.
-   *
-   * @throws IOException when the request could not be executed due to a
-   * connectivity problem or timeout. Because networks can fail during an
-   * exchange, it is possible that the remote server accepted the request
-   * before the failure.
+  /*
+   * Sets the {@code HostResolver} that will be used by this client to resolve
+   * hostnames to IP addresses.
    */
-  public Response execute(Request request) throws IOException {
-    // Copy the client. Otherwise changes (socket factory, redirect policy,
-    // etc.) may incorrectly be reflected in the request when it is executed.
-    OkHttpClient client = copyWithDefaults();
-    Job job = new Job(dispatcher, client, request, null);
-    Response result = job.getResponse(); // Since we don't cancel, this won't be null.
-    job.engine.releaseConnection(); // Transfer ownership of the body to the caller.
-    return result;
+  public OkHttpClient setHostResolver(HostResolver hostResolver) {
+    this.hostResolver = hostResolver;
+    return this;
+  }
+
+  public HostResolver getHostResolver() {
+    return hostResolver;
   }
 
   /**
-   * Schedules {@code request} to be executed at some point in the future. The
-   * {@link #getDispatcher dispatcher} defines when the request will run:
-   * usually immediately unless there are several other requests currently being
-   * executed.
-   *
-   * <p>This client will later call back {@code responseReceiver} with either an
-   * HTTP response or a failure exception. If you {@link #cancel} a request
-   * before it completes the receiver will not be called back.
+   * Prepares the {@code request} to be executed at some point in the future.
    */
-  public void enqueue(Request request, Response.Receiver responseReceiver) {
-    dispatcher.enqueue(this, request, responseReceiver);
+  public Call newCall(Request request) {
+    return new Call(this, request);
   }
 
   /**
    * Cancels all scheduled tasks tagged with {@code tag}. Requests that are already
    * complete cannot be canceled.
    */
-  public void cancel(Object tag) {
-    dispatcher.cancel(tag);
-  }
-
-  public HttpURLConnection open(URL url) {
-    return open(url, proxy);
-  }
-
-  HttpURLConnection open(URL url, Proxy proxy) {
-    String protocol = url.getProtocol();
-    OkHttpClient copy = copyWithDefaults();
-    copy.proxy = proxy;
-
-    if (protocol.equals("http")) return new HttpURLConnectionImpl(url, copy);
-    if (protocol.equals("https")) return new HttpsURLConnectionImpl(url, copy);
-    throw new IllegalArgumentException("Unexpected protocol: " + protocol);
+  public OkHttpClient cancel(Object tag) {
+    getDispatcher().cancel(tag);
+    return this;
   }
 
   /**
    * Returns a shallow copy of this OkHttpClient that uses the system-wide
    * default for each field that hasn't been explicitly configured.
    */
-  OkHttpClient copyWithDefaults() {
-    OkHttpClient result = clone();
+  final OkHttpClient copyWithDefaults() {
+    OkHttpClient result = new OkHttpClient(this);
     if (result.proxySelector == null) {
       result.proxySelector = ProxySelector.getDefault();
     }
     if (result.cookieHandler == null) {
       result.cookieHandler = CookieHandler.getDefault();
     }
-    if (result.responseCache == null) {
-      result.responseCache = toOkResponseCache(ResponseCache.getDefault());
+    if (result.socketFactory == null) {
+      result.socketFactory = SocketFactory.getDefault();
     }
     if (result.sslSocketFactory == null) {
       result.sslSocketFactory = getDefaultSSLSocketFactory();
@@ -453,13 +497,16 @@ OkHttpClient copyWithDefaults() {
       result.hostnameVerifier = OkHostnameVerifier.INSTANCE;
     }
     if (result.authenticator == null) {
-      result.authenticator = HttpAuthenticator.SYSTEM_DEFAULT;
+      result.authenticator = AuthenticatorAdapter.INSTANCE;
     }
     if (result.connectionPool == null) {
       result.connectionPool = ConnectionPool.getDefault();
     }
     if (result.protocols == null) {
-      result.protocols = Protocol.HTTP2_SPDY3_AND_HTTP;
+      result.protocols = Util.immutableList(Protocol.HTTP_2, Protocol.SPDY_3, Protocol.HTTP_1_1);
+    }
+    if (result.hostResolver == null) {
+      result.hostResolver = HostResolver.DEFAULT;
     }
     return result;
   }
@@ -470,66 +517,30 @@ OkHttpClient copyWithDefaults() {
    * used the shared SSL context, when OkHttp enables NPN for its SPDY-related
    * stuff, it would also enable NPN for other usages, which might crash them
    * because NPN is enabled when it isn't expected to be.
-   * <p>
-   * This code avoids that by defaulting to an OkHttp created SSL context. The
-   * significant drawback of this approach is that apps that customize the
-   * global SSL context will lose these customizations.
+   *
+   * <p>This code avoids that by defaulting to an OkHttp-created SSL context.
+   * The drawback of this approach is that apps that customize the global SSL
+   * context will lose these customizations.
    */
   private synchronized SSLSocketFactory getDefaultSSLSocketFactory() {
-    if (sslSocketFactory == null) {
+    if (defaultSslSocketFactory == null) {
       try {
         SSLContext sslContext = SSLContext.getInstance("TLS");
         sslContext.init(null, null, null);
-        sslSocketFactory = sslContext.getSocketFactory();
+        defaultSslSocketFactory = sslContext.getSocketFactory();
       } catch (GeneralSecurityException e) {
         throw new AssertionError(); // The system has no TLS. Just give up.
       }
     }
-    return sslSocketFactory;
+    return defaultSslSocketFactory;
   }
 
   /** Returns a shallow copy of this OkHttpClient. */
-  @Override public OkHttpClient clone() {
+  @Override public final OkHttpClient clone() {
     try {
       return (OkHttpClient) super.clone();
     } catch (CloneNotSupportedException e) {
       throw new AssertionError();
     }
   }
-
-  private OkResponseCache toOkResponseCache(ResponseCache responseCache) {
-    return responseCache == null || responseCache instanceof OkResponseCache
-        ? (OkResponseCache) responseCache
-        : new ResponseCacheAdapter(responseCache);
-  }
-
-  /**
-   * Creates a URLStreamHandler as a {@link URL#setURLStreamHandlerFactory}.
-   *
-   * <p>This code configures OkHttp to handle all HTTP and HTTPS connections
-   * created with {@link URL#openConnection()}: <pre>   {@code
-   *
-   *   OkHttpClient okHttpClient = new OkHttpClient();
-   *   URL.setURLStreamHandlerFactory(okHttpClient);
-   * }</pre>
-   */
-  public URLStreamHandler createURLStreamHandler(final String protocol) {
-    if (!protocol.equals("http") && !protocol.equals("https")) return null;
-
-    return new URLStreamHandler() {
-      @Override protected URLConnection openConnection(URL url) {
-        return open(url);
-      }
-
-      @Override protected URLConnection openConnection(URL url, Proxy proxy) {
-        return open(url, proxy);
-      }
-
-      @Override protected int getDefaultPort() {
-        if (protocol.equals("http")) return 80;
-        if (protocol.equals("https")) return 443;
-        throw new AssertionError();
-      }
-    };
-  }
 }
diff --git a/okhttp/src/main/java/com/squareup/okhttp/Protocol.java b/okhttp/src/main/java/com/squareup/okhttp/Protocol.java
index e2d7ba9310..e514d44171 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/Protocol.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/Protocol.java
@@ -15,61 +15,86 @@
  */
 package com.squareup.okhttp;
 
-import com.squareup.okhttp.internal.Util;
 import java.io.IOException;
-import java.util.Arrays;
-import java.util.List;
-import okio.ByteString;
 
 /**
- * Contains protocols that OkHttp supports
- * <a href="http://tools.ietf.org/html/draft-agl-tls-nextprotoneg-04">NPN</a> or
- * <a href="http://tools.ietf.org/html/draft-ietf-tls-applayerprotoneg">ALPN</a> selection.
+ * Protocols that OkHttp implements for <a
+ * href="http://tools.ietf.org/html/draft-agl-tls-nextprotoneg-04">NPN</a> and
+ * <a href="http://tools.ietf.org/html/draft-ietf-tls-applayerprotoneg">ALPN</a>
+ * selection.
  *
- * <p>
  * <h3>Protocol vs Scheme</h3>
  * Despite its name, {@link java.net.URL#getProtocol()} returns the
- * {@link java.net.URI#getScheme() scheme} (http, https, etc.) of the URL, not
- * the protocol (http/1.1, spdy/3.1, etc.).  OkHttp uses the word protocol to
- * indicate how HTTP messages are framed.
+ * {@linkplain java.net.URI#getScheme() scheme} (http, https, etc.) of the URL, not
+ * the protocol (http/1.1, spdy/3.1, etc.). OkHttp uses the word <i>protocol</i>
+ * to identify how HTTP messages are framed.
  */
 public enum Protocol {
-  HTTP_2("HTTP-draft-09/2.0", true),
-  SPDY_3("spdy/3.1", true),
-  HTTP_11("http/1.1", false);
+  /**
+   * An obsolete plaintext framing that does not use persistent sockets by
+   * default.
+   */
+  HTTP_1_0("http/1.0"),
 
-  public static final List<Protocol> HTTP2_SPDY3_AND_HTTP =
-      Util.immutableList(Arrays.asList(HTTP_2, SPDY_3, HTTP_11));
-  public static final List<Protocol> SPDY3_AND_HTTP11 =
-      Util.immutableList(Arrays.asList(SPDY_3, HTTP_11));
-  public static final List<Protocol> HTTP2_AND_HTTP_11 =
-      Util.immutableList(Arrays.asList(HTTP_2, HTTP_11));
+  /**
+   * A plaintext framing that includes persistent connections.
+   *
+   * <p>This version of OkHttp implements <a
+   * href="http://www.ietf.org/rfc/rfc2616.txt">RFC 2616</a>, and tracks
+   * revisions to that spec.
+   */
+  HTTP_1_1("http/1.1"),
 
-  /** Identifier string used in NPN or ALPN selection. */
-  public final ByteString name;
+  /**
+   * Chromium's binary-framed protocol that includes header compression,
+   * multiplexing multiple requests on the same socket, and server-push.
+   * HTTP/1.1 semantics are layered on SPDY/3.
+   *
+   * <p>This version of OkHttp implements SPDY 3 <a
+   * href="http://dev.chromium.org/spdy/spdy-protocol/spdy-protocol-draft3-1">draft
+   * 3.1</a>. Future releases of OkHttp may use this identifier for a newer draft
+   * of the SPDY spec.
+   */
+  SPDY_3("spdy/3.1"),
 
   /**
-   * When true the protocol is binary framed and derived from SPDY.
+   * The IETF's binary-framed protocol that includes header compression,
+   * multiplexing multiple requests on the same socket, and server-push.
+   * HTTP/1.1 semantics are layered on HTTP/2.
    *
-   * @see com.squareup.okhttp.internal.spdy.Variant
+   * <p>This version of OkHttp implements HTTP/2 <a
+   * href="http://tools.ietf.org/html/draft-ietf-httpbis-http2-14">draft 12</a>
+   * with HPACK <a
+   * href="http://tools.ietf.org/html/draft-ietf-httpbis-header-compression-09">draft
+   * 6</a>. Future releases of OkHttp may use this identifier for a newer draft
+   * of these specs.
    */
-  public final boolean spdyVariant;
+  HTTP_2("h2-14");
+
+  private final String protocol;
+
+  Protocol(String protocol) {
+    this.protocol = protocol;
+  }
 
-  Protocol(String name, boolean spdyVariant) {
-    this.name = ByteString.encodeUtf8(name);
-    this.spdyVariant = spdyVariant;
+  /**
+   * Returns the protocol identified by {@code protocol}.
+   * @throws IOException if {@code protocol} is unknown.
+   */
+  public static Protocol get(String protocol) throws IOException {
+    // Unroll the loop over values() to save an allocation.
+    if (protocol.equals(HTTP_1_0.protocol)) return HTTP_1_0;
+    if (protocol.equals(HTTP_1_1.protocol)) return HTTP_1_1;
+    if (protocol.equals(HTTP_2.protocol)) return HTTP_2;
+    if (protocol.equals(SPDY_3.protocol)) return SPDY_3;
+    throw new IOException("Unexpected protocol: " + protocol);
   }
 
   /**
-   * Returns the protocol matching {@code input} or {@link #HTTP_11} is on
-   * {@code null}. Throws an {@link IOException} when {@code input} doesn't
-   * match the {@link #name} of a supported protocol.
+   * Returns the string used to identify this protocol for ALPN and NPN, like
+   * "http/1.1", "spdy/3.1" or "h2-14".
    */
-  public static Protocol find(ByteString input) throws IOException {
-    if (input == null) return HTTP_11;
-    for (Protocol protocol : values()) {
-      if (protocol.name.equals(input)) return protocol;
-    }
-    throw new IOException("Unexpected protocol: " + input.utf8());
+  @Override public String toString() {
+    return protocol;
   }
 }
diff --git a/okhttp/src/main/java/com/squareup/okhttp/Request.java b/okhttp/src/main/java/com/squareup/okhttp/Request.java
index 300dc17e57..b8f417ebe3 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/Request.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/Request.java
@@ -16,57 +16,58 @@
 package com.squareup.okhttp;
 
 import com.squareup.okhttp.internal.Platform;
-import com.squareup.okhttp.internal.Util;
-import java.io.File;
-import java.io.FileInputStream;
+import com.squareup.okhttp.internal.http.HttpMethod;
 import java.io.IOException;
-import java.io.InputStream;
-import java.io.UnsupportedEncodingException;
 import java.net.MalformedURLException;
 import java.net.URI;
 import java.net.URISyntaxException;
 import java.net.URL;
 import java.util.List;
-import okio.BufferedSink;
 
 /**
  * An HTTP request. Instances of this class are immutable if their {@link #body}
  * is null or itself immutable.
  */
 public final class Request {
-  private final URL url;
+  private final String urlString;
   private final String method;
   private final Headers headers;
-  private final Body body;
+  private final RequestBody body;
   private final Object tag;
 
-  private volatile ParsedHeaders parsedHeaders; // Lazily initialized.
+  private volatile URL url; // Lazily initialized.
   private volatile URI uri; // Lazily initialized.
   private volatile CacheControl cacheControl; // Lazily initialized.
 
   private Request(Builder builder) {
-    this.url = builder.url;
+    this.urlString = builder.urlString;
     this.method = builder.method;
     this.headers = builder.headers.build();
     this.body = builder.body;
     this.tag = builder.tag != null ? builder.tag : this;
+    this.url = builder.url;
   }
 
   public URL url() {
-    return url;
+    try {
+      URL result = url;
+      return result != null ? result : (url = new URL(urlString));
+    } catch (MalformedURLException e) {
+      throw new RuntimeException("Malformed URL: " + urlString, e);
+    }
   }
 
   public URI uri() throws IOException {
     try {
       URI result = uri;
-      return result != null ? result : (uri = Platform.get().toUriLenient(url));
+      return result != null ? result : (uri = Platform.get().toUriLenient(url()));
     } catch (URISyntaxException e) {
       throw new IOException(e.getMessage());
     }
   }
 
   public String urlString() {
-    return url.toString();
+    return urlString;
   }
 
   public String method() {
@@ -85,7 +86,7 @@ public String header(String name) {
     return headers.values(name);
   }
 
-  public Body body() {
+  public RequestBody body() {
     return body;
   }
 
@@ -97,23 +98,6 @@ public Builder newBuilder() {
     return new Builder(this);
   }
 
-  public Headers getHeaders() {
-    return headers;
-  }
-
-  public String getUserAgent() {
-    return parsedHeaders().userAgent;
-  }
-
-  public String getProxyAuthorization() {
-    return parsedHeaders().proxyAuthorization;
-  }
-
-  private ParsedHeaders parsedHeaders() {
-    ParsedHeaders result = parsedHeaders;
-    return result != null ? result : (parsedHeaders = new ParsedHeaders(headers));
-  }
-
   /**
    * Returns the cache control directives for this response. This is never null,
    * even if this response contains no {@code Cache-Control} header.
@@ -127,113 +111,22 @@ public boolean isHttps() {
     return url().getProtocol().equals("https");
   }
 
-  /** Parsed request headers, computed on-demand and cached. */
-  private static class ParsedHeaders {
-    private String userAgent;
-    private String proxyAuthorization;
-
-    public ParsedHeaders(Headers headers) {
-      for (int i = 0; i < headers.size(); i++) {
-        String fieldName = headers.name(i);
-        String value = headers.value(i);
-        if ("User-Agent".equalsIgnoreCase(fieldName)) {
-          userAgent = value;
-        } else if ("Proxy-Authorization".equalsIgnoreCase(fieldName)) {
-          proxyAuthorization = value;
-        }
-      }
-    }
-  }
-
-  public abstract static class Body {
-    /** Returns the Content-Type header for this body. */
-    public abstract MediaType contentType();
-
-    /**
-     * Returns the number of bytes that will be written to {@code out} in a call
-     * to {@link #writeTo}, or -1 if that count is unknown.
-     */
-    public long contentLength() {
-      return -1;
-    }
-
-    /** Writes the content of this request to {@code out}. */
-    public abstract void writeTo(BufferedSink sink) throws IOException;
-
-    /**
-     * Returns a new request body that transmits {@code content}. If {@code
-     * contentType} lacks a charset, this will use UTF-8.
-     */
-    public static Body create(MediaType contentType, String content) {
-      contentType = contentType.charset() != null
-          ? contentType
-          : MediaType.parse(contentType + "; charset=utf-8");
-      try {
-        byte[] bytes = content.getBytes(contentType.charset().name());
-        return create(contentType, bytes);
-      } catch (UnsupportedEncodingException e) {
-        throw new AssertionError();
-      }
-    }
-
-    /** Returns a new request body that transmits {@code content}. */
-    public static Body create(final MediaType contentType, final byte[] content) {
-      if (contentType == null) throw new NullPointerException("contentType == null");
-      if (content == null) throw new NullPointerException("content == null");
-
-      return new Body() {
-        @Override public MediaType contentType() {
-          return contentType;
-        }
-
-        @Override public long contentLength() {
-          return content.length;
-        }
-
-        @Override public void writeTo(BufferedSink sink) throws IOException {
-          sink.write(content);
-        }
-      };
-    }
-
-    /** Returns a new request body that transmits the content of {@code file}. */
-    public static Body create(final MediaType contentType, final File file) {
-      if (contentType == null) throw new NullPointerException("contentType == null");
-      if (file == null) throw new NullPointerException("content == null");
-
-      return new Body() {
-        @Override public MediaType contentType() {
-          return contentType;
-        }
-
-        @Override public long contentLength() {
-          return file.length();
-        }
-
-        @Override public void writeTo(BufferedSink sink) throws IOException {
-          long length = contentLength();
-          if (length == 0) return;
-
-          InputStream in = null;
-          try {
-            in = new FileInputStream(file);
-            byte[] buffer = new byte[(int) Math.min(8192, length)];
-            for (int c; (c = in.read(buffer)) != -1; ) {
-              sink.write(buffer, 0, c);
-            }
-          } finally {
-            Util.closeQuietly(in);
-          }
-        }
-      };
-    }
+  @Override public String toString() {
+    return "Request{method="
+        + method
+        + ", url="
+        + urlString
+        + ", tag="
+        + (tag != this ? tag : null)
+        + '}';
   }
 
   public static class Builder {
+    private String urlString;
     private URL url;
     private String method;
     private Headers.Builder headers;
-    private Body body;
+    private RequestBody body;
     private Object tag;
 
     public Builder() {
@@ -242,6 +135,7 @@ public Builder() {
     }
 
     private Builder(Request request) {
+      this.urlString = request.urlString;
       this.url = request.url;
       this.method = request.method;
       this.body = request.body;
@@ -250,16 +144,15 @@ private Builder(Request request) {
     }
 
     public Builder url(String url) {
-      try {
-        return url(new URL(url));
-      } catch (MalformedURLException e) {
-        throw new IllegalArgumentException("Malformed URL: " + url);
-      }
+      if (url == null) throw new IllegalArgumentException("url == null");
+      urlString = url;
+      return this;
     }
 
     public Builder url(URL url) {
       if (url == null) throw new IllegalArgumentException("url == null");
       this.url = url;
+      this.urlString = url.toString();
       return this;
     }
 
@@ -292,10 +185,6 @@ public Builder headers(Headers headers) {
       return this;
     }
 
-    public Builder setUserAgent(String userAgent) {
-      return header("User-Agent", userAgent);
-    }
-
     public Builder get() {
       return method("GET", null);
     }
@@ -304,18 +193,29 @@ public Builder head() {
       return method("HEAD", null);
     }
 
-    public Builder post(Body body) {
+    public Builder post(RequestBody body) {
       return method("POST", body);
     }
 
-    public Builder put(Body body) {
+    public Builder delete() {
+      return method("DELETE", null);
+    }
+
+    public Builder put(RequestBody body) {
       return method("PUT", body);
     }
 
-    public Builder method(String method, Body body) {
+    public Builder patch(RequestBody body) {
+      return method("PATCH", body);
+    }
+
+    public Builder method(String method, RequestBody body) {
       if (method == null || method.length() == 0) {
         throw new IllegalArgumentException("method == null || method.length() == 0");
       }
+      if (body != null && !HttpMethod.hasRequestBody(method)) {
+        throw new IllegalArgumentException("method " + method + " must not have a request body.");
+      }
       this.method = method;
       this.body = body;
       return this;
@@ -332,7 +232,7 @@ public Builder tag(Object tag) {
     }
 
     public Request build() {
-      if (url == null) throw new IllegalStateException("url == null");
+      if (urlString == null) throw new IllegalStateException("url == null");
       return new Request(this);
     }
   }
diff --git a/okhttp/src/main/java/com/squareup/okhttp/RequestBody.java b/okhttp/src/main/java/com/squareup/okhttp/RequestBody.java
new file mode 100644
index 0000000000..83203c3dbd
--- /dev/null
+++ b/okhttp/src/main/java/com/squareup/okhttp/RequestBody.java
@@ -0,0 +1,101 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.okhttp;
+
+import com.squareup.okhttp.internal.Util;
+import java.io.File;
+import java.io.IOException;
+import java.nio.charset.Charset;
+import okio.BufferedSink;
+import okio.Okio;
+import okio.Source;
+
+public abstract class RequestBody {
+  /** Returns the Content-Type header for this body. */
+  public abstract MediaType contentType();
+
+  /**
+   * Returns the number of bytes that will be written to {@code out} in a call
+   * to {@link #writeTo}, or -1 if that count is unknown.
+   */
+  public long contentLength() {
+    return -1;
+  }
+
+  /** Writes the content of this request to {@code out}. */
+  public abstract void writeTo(BufferedSink sink) throws IOException;
+
+  /**
+   * Returns a new request body that transmits {@code content}. If {@code
+   * contentType} is non-null and lacks a charset, this will use UTF-8.
+   */
+  public static RequestBody create(MediaType contentType, String content) {
+    Charset charset = Util.UTF_8;
+    if (contentType != null) {
+      charset = contentType.charset();
+      if (charset == null) {
+        charset = Util.UTF_8;
+        contentType = MediaType.parse(contentType + "; charset=utf-8");
+      }
+    }
+    byte[] bytes = content.getBytes(charset);
+    return create(contentType, bytes);
+  }
+
+  /** Returns a new request body that transmits {@code content}. */
+  public static RequestBody create(final MediaType contentType, final byte[] content) {
+    if (content == null) throw new NullPointerException("content == null");
+
+    return new RequestBody() {
+      @Override public MediaType contentType() {
+        return contentType;
+      }
+
+      @Override public long contentLength() {
+        return content.length;
+      }
+
+      @Override public void writeTo(BufferedSink sink) throws IOException {
+        sink.write(content);
+      }
+    };
+  }
+
+  /** Returns a new request body that transmits the content of {@code file}. */
+  public static RequestBody create(final MediaType contentType, final File file) {
+    if (file == null) throw new NullPointerException("content == null");
+
+    return new RequestBody() {
+      @Override public MediaType contentType() {
+        return contentType;
+      }
+
+      @Override public long contentLength() {
+        return file.length();
+      }
+
+      @Override public void writeTo(BufferedSink sink) throws IOException {
+        Source source = null;
+        try {
+          source = Okio.source(file);
+          sink.writeAll(source);
+        } finally {
+          Util.closeQuietly(source);
+        }
+      }
+    };
+  }
+}
diff --git a/okhttp/src/main/java/com/squareup/okhttp/Response.java b/okhttp/src/main/java/com/squareup/okhttp/Response.java
index 13f912420f..6a644333c6 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/Response.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/Response.java
@@ -15,28 +15,17 @@
  */
 package com.squareup.okhttp;
 
-import com.squareup.okhttp.internal.Util;
-import com.squareup.okhttp.internal.http.HttpDate;
 import com.squareup.okhttp.internal.http.OkHeaders;
-import com.squareup.okhttp.internal.http.StatusLine;
-import java.io.ByteArrayOutputStream;
-import java.io.Closeable;
-import java.io.IOException;
-import java.io.InputStream;
-import java.io.InputStreamReader;
-import java.io.Reader;
-import java.net.HttpURLConnection;
-import java.nio.charset.Charset;
 import java.util.Collections;
-import java.util.Date;
 import java.util.List;
-import java.util.Set;
-import java.util.TreeSet;
-import okio.Okio;
-import okio.Source;
 
-import static com.squareup.okhttp.internal.Util.UTF_8;
-import static com.squareup.okhttp.internal.Util.equal;
+import static com.squareup.okhttp.internal.http.StatusLine.HTTP_TEMP_REDIRECT;
+import static java.net.HttpURLConnection.HTTP_MOVED_PERM;
+import static java.net.HttpURLConnection.HTTP_MOVED_TEMP;
+import static java.net.HttpURLConnection.HTTP_MULT_CHOICE;
+import static java.net.HttpURLConnection.HTTP_PROXY_AUTH;
+import static java.net.HttpURLConnection.HTTP_SEE_OTHER;
+import static java.net.HttpURLConnection.HTTP_UNAUTHORIZED;
 
 /**
  * An HTTP response. Instances of this class are not immutable: the response
@@ -45,54 +34,70 @@
  */
 public final class Response {
   private final Request request;
-  private final StatusLine statusLine;
+  private final Protocol protocol;
+  private final int code;
+  private final String message;
   private final Handshake handshake;
   private final Headers headers;
-  private final Body body;
-  private final Response redirectedBy;
+  private final ResponseBody body;
+  private Response networkResponse;
+  private Response cacheResponse;
+  private final Response priorResponse;
 
-  private volatile ParsedHeaders parsedHeaders; // Lazily initialized.
   private volatile CacheControl cacheControl; // Lazily initialized.
 
   private Response(Builder builder) {
     this.request = builder.request;
-    this.statusLine = builder.statusLine;
+    this.protocol = builder.protocol;
+    this.code = builder.code;
+    this.message = builder.message;
     this.handshake = builder.handshake;
     this.headers = builder.headers.build();
     this.body = builder.body;
-    this.redirectedBy = builder.redirectedBy;
+    this.networkResponse = builder.networkResponse;
+    this.cacheResponse = builder.cacheResponse;
+    this.priorResponse = builder.priorResponse;
   }
 
   /**
-   * The wire-level request that initiated this HTTP response. This is usually
-   * <strong>not</strong> the same request instance provided to the HTTP client:
+   * The wire-level request that initiated this HTTP response. This is not
+   * necessarily the same request issued by the application:
    * <ul>
    *     <li>It may be transformed by the HTTP client. For example, the client
-   *         may have added its own {@code Content-Encoding} header to enable
-   *         response compression.
-   *     <li>It may be the request generated in response to an HTTP redirect.
-   *         In this case the request URL may be different than the initial
-   *         request URL.
+   *         may copy headers like {@code Content-Length} from the request body.
+   *     <li>It may be the request generated in response to an HTTP redirect or
+   *         authentication challenge. In this case the request URL may be
+   *         different than the initial request URL.
    * </ul>
    */
   public Request request() {
     return request;
   }
 
-  public String statusLine() {
-    return statusLine.getStatusLine();
+  /**
+   * Returns the HTTP protocol, such as {@link Protocol#HTTP_1_1} or {@link
+   * Protocol#HTTP_1_0}.
+   */
+  public Protocol protocol() {
+    return protocol;
   }
 
+  /** Returns the HTTP status code. */
   public int code() {
-    return statusLine.code();
+    return code;
   }
 
-  public String statusMessage() {
-    return statusLine.message();
+  /**
+   * Returns true if the code is in [200..300), which means the request was
+   * successfully received, understood, and accepted.
+   */
+  public boolean isSuccessful() {
+    return code >= 200 && code < 300;
   }
 
-  public int httpMinorVersion() {
-    return statusLine.httpMinorVersion();
+  /** Returns the HTTP status message or null if it is unknown. */
+  public String message() {
+    return message;
   }
 
   /**
@@ -120,7 +125,7 @@ public Headers headers() {
     return headers;
   }
 
-  public Body body() {
+  public ResponseBody body() {
     return body;
   }
 
@@ -128,154 +133,66 @@ public Builder newBuilder() {
     return new Builder(this);
   }
 
-  /**
-   * Returns the response for the HTTP redirect that triggered this response, or
-   * null if this response wasn't triggered by an automatic redirect. The body
-   * of the returned response should not be read because it has already been
-   * consumed by the redirecting client.
-   */
-  public Response redirectedBy() {
-    return redirectedBy;
-  }
-
-  // TODO: move out of public API
-  public Set<String> getVaryFields() {
-    return parsedHeaders().varyFields;
+  /** Returns true if this response redirects to another resource. */
+  public boolean isRedirect() {
+    switch (code) {
+      case HTTP_TEMP_REDIRECT:
+      case HTTP_MULT_CHOICE:
+      case HTTP_MOVED_PERM:
+      case HTTP_MOVED_TEMP:
+      case HTTP_SEE_OTHER:
+        return true;
+      default:
+        return false;
+    }
   }
 
   /**
-   * Returns true if a Vary header contains an asterisk. Such responses cannot
-   * be cached.
+   * Returns the raw response received from the network. Will be null if this
+   * response didn't use the network, such as when the response is fully cached.
+   * The body of the returned response should not be read.
    */
-  // TODO: move out of public API
-  public boolean hasVaryAll() {
-    return parsedHeaders().varyFields.contains("*");
+  public Response networkResponse() {
+    return networkResponse;
   }
 
   /**
-   * Returns true if none of the Vary headers on this response have changed
-   * between {@code cachedRequest} and {@code newRequest}.
+   * Returns the raw response received from the cache. Will be null if this
+   * response didn't use the cache. For conditional get requests the cache
+   * response and network response may both be non-null. The body of the
+   * returned response should not be read.
    */
-  // TODO: move out of public API
-  public boolean varyMatches(Headers varyHeaders, Request newRequest) {
-    for (String field : parsedHeaders().varyFields) {
-      if (!equal(varyHeaders.values(field), newRequest.headers(field))) return false;
-    }
-    return true;
+  public Response cacheResponse() {
+    return cacheResponse;
   }
 
   /**
-   * Returns true if this cached response should be used; false if the
-   * network response should be used.
+   * Returns the response for the HTTP redirect or authorization challenge that
+   * triggered this response, or null if this response wasn't triggered by an
+   * automatic retry. The body of the returned response should not be read
+   * because it has already been consumed by the redirecting client.
    */
-  // TODO: move out of public API
-  public boolean validate(Response network) {
-    if (network.code() == HttpURLConnection.HTTP_NOT_MODIFIED) {
-      return true;
-    }
-
-    // The HTTP spec says that if the network's response is older than our
-    // cached response, we may return the cache's response. Like Chrome (but
-    // unlike Firefox), this client prefers to return the newer response.
-    ParsedHeaders networkHeaders = network.parsedHeaders();
-    if (parsedHeaders().lastModified != null
-        && networkHeaders.lastModified != null
-        && networkHeaders.lastModified.getTime() < parsedHeaders().lastModified.getTime()) {
-      return true;
-    }
-
-    return false;
+  public Response priorResponse() {
+    return priorResponse;
   }
 
-  public abstract static class Body implements Closeable {
-    /** Multiple calls to {@link #charStream()} must return the same instance. */
-    private Reader reader;
-
-    /** Multiple calls to {@link #source()} must return the same instance. */
-    private Source source;
-
-    /**
-     * Returns true if further data from this response body should be read at
-     * this time. For asynchronous protocols like SPDY and HTTP/2, this will
-     * return false once all locally-available body bytes have been read.
-     *
-     * <p>Clients with many concurrent downloads can use this method to reduce
-     * the number of idle threads blocking on reads. See {@link
-     * Receiver#onResponse} for details.
-     */
-    // <h3>Body.ready() vs. InputStream.available()</h3>
-    // TODO: Can we fix response bodies to implement InputStream.available well?
-    // The deflater implementation is broken by default but we could do better.
-    public abstract boolean ready() throws IOException;
-
-    public abstract MediaType contentType();
-
-    /**
-     * Returns the number of bytes in that will returned by {@link #bytes}, or
-     * {@link #byteStream}, or -1 if unknown.
-     */
-    public abstract long contentLength();
-
-    public abstract InputStream byteStream();
-
-    // TODO: Source needs to be an API type for this to be public
-    public Source source() {
-      Source s = source;
-      return s != null ? s : (source = Okio.source(byteStream()));
-    }
-
-    public final byte[] bytes() throws IOException {
-      long contentLength = contentLength();
-      if (contentLength > Integer.MAX_VALUE) {
-        throw new IOException("Cannot buffer entire body for content length: " + contentLength);
-      }
-
-      if (contentLength != -1) {
-        byte[] content = new byte[(int) contentLength];
-        InputStream in = byteStream();
-        Util.readFully(in, content);
-        if (in.read() != -1) throw new IOException("Content-Length and stream length disagree");
-        return content;
-
-      } else {
-        ByteArrayOutputStream out = new ByteArrayOutputStream();
-        Util.copy(byteStream(), out);
-        return out.toByteArray();
-      }
-    }
-
-    /**
-     * Returns the response as a character stream decoded with the charset
-     * of the Content-Type header. If that header is either absent or lacks a
-     * charset, this will attempt to decode the response body as UTF-8.
-     */
-    public final Reader charStream() {
-      Reader r = reader;
-      return r != null ? r : (reader = new InputStreamReader(byteStream(), charset()));
-    }
-
-    /**
-     * Returns the response as a string decoded with the charset of the
-     * Content-Type header. If that header is either absent or lacks a charset,
-     * this will attempt to decode the response body as UTF-8.
-     */
-    public final String string() throws IOException {
-      return new String(bytes(), charset().name());
-    }
-
-    private Charset charset() {
-      MediaType contentType = contentType();
-      return contentType != null ? contentType.charset(UTF_8) : UTF_8;
-    }
-
-    @Override public void close() throws IOException {
-      byteStream().close();
+  /**
+   * Returns the authorization challenges appropriate for this response's code.
+   * If the response code is 401 unauthorized, this returns the
+   * "WWW-Authenticate" challenges. If the response code is 407 proxy
+   * unauthorized, this returns the "Proxy-Authenticate" challenges. Otherwise
+   * this returns an empty list of challenges.
+   */
+  public List<Challenge> challenges() {
+    String responseField;
+    if (code == HTTP_UNAUTHORIZED) {
+      responseField = "WWW-Authenticate";
+    } else if (code == HTTP_PROXY_AUTH) {
+      responseField = "Proxy-Authenticate";
+    } else {
+      return Collections.emptyList();
     }
-  }
-
-  private ParsedHeaders parsedHeaders() {
-    ParsedHeaders result = parsedHeaders;
-    return result != null ? result : (parsedHeaders = new ParsedHeaders(headers));
+    return OkHeaders.parseChallenges(headers(), responseField);
   }
 
   /**
@@ -287,81 +204,29 @@ public CacheControl cacheControl() {
     return result != null ? result : (cacheControl = CacheControl.parse(headers));
   }
 
-  /** Parsed response headers, computed on-demand and cached. */
-  private static class ParsedHeaders {
-    /** The last modified date of the response, if known. */
-    Date lastModified;
-
-    /** Case-insensitive set of field names. */
-    private Set<String> varyFields = Collections.emptySet();
-
-    private ParsedHeaders(Headers headers) {
-      for (int i = 0; i < headers.size(); i++) {
-        String fieldName = headers.name(i);
-        String value = headers.value(i);
-        if ("Last-Modified".equalsIgnoreCase(fieldName)) {
-          lastModified = HttpDate.parse(value);
-        } else if ("Vary".equalsIgnoreCase(fieldName)) {
-          // Replace the immutable empty set with something we can mutate.
-          if (varyFields.isEmpty()) {
-            varyFields = new TreeSet<String>(String.CASE_INSENSITIVE_ORDER);
-          }
-          for (String varyField : value.split(",")) {
-            varyFields.add(varyField.trim());
-          }
-        }
-      }
-    }
-  }
-
-  public interface Receiver {
-    /**
-     * Called when the request could not be executed due to a connectivity
-     * problem or timeout. Because networks can fail during an exchange, it is
-     * possible that the remote server accepted the request before the failure.
-     */
-    void onFailure(Failure failure);
-
-    /**
-     * Called when the HTTP response was successfully returned by the remote
-     * server. The receiver may proceed to read the response body with the
-     * response's {@link #body} method.
-     *
-     * <p>Note that transport-layer success (receiving a HTTP response code,
-     * headers and body) does not necessarily indicate application-layer
-     * success: {@code response} may still indicate an unhappy HTTP response
-     * code like 404 or 500.
-     *
-     * <h3>Non-blocking responses</h3>
-     *
-     * <p>Receivers do not need to block while waiting for the response body to
-     * download. Instead, they can get called back as data arrives. Use {@link
-     * Body#ready} to check if bytes should be read immediately. While there is
-     * data ready, read it. If there isn't, return false: receivers will be
-     * called back with {@code onResponse()} as additional data is downloaded.
-     *
-     * <p>Return true to indicate that the receiver has finished handling the
-     * response body. If the response body has unread data, it will be
-     * discarded.
-     *
-     * <p>When the response body has been fully consumed the returned value is
-     * undefined.
-     *
-     * <p>The current implementation of {@link Body#ready} always returns true
-     * when the underlying transport is HTTP/1. This results in blocking on that
-     * transport. For effective non-blocking your server must support SPDY or
-     * HTTP/2.
-     */
-    boolean onResponse(Response response) throws IOException;
+  @Override public String toString() {
+    return "Response{protocol="
+        + protocol
+        + ", code="
+        + code
+        + ", message="
+        + message
+        + ", url="
+        + request.urlString()
+        + '}';
   }
 
   public static class Builder {
     private Request request;
-    private StatusLine statusLine;
+    private Protocol protocol;
+    private int code = -1;
+    private String message;
     private Handshake handshake;
     private Headers.Builder headers;
-    private Body body;
-    private Response redirectedBy;
+    private ResponseBody body;
+    private Response networkResponse;
+    private Response cacheResponse;
+    private Response priorResponse;
 
     public Builder() {
       headers = new Headers.Builder();
@@ -369,11 +234,15 @@ public Builder() {
 
     private Builder(Response response) {
       this.request = response.request;
-      this.statusLine = response.statusLine;
+      this.protocol = response.protocol;
+      this.code = response.code;
+      this.message = response.message;
       this.handshake = response.handshake;
       this.headers = response.headers.newBuilder();
       this.body = response.body;
-      this.redirectedBy = response.redirectedBy;
+      this.networkResponse = response.networkResponse;
+      this.cacheResponse = response.cacheResponse;
+      this.priorResponse = response.priorResponse;
     }
 
     public Builder request(Request request) {
@@ -381,18 +250,19 @@ public Builder request(Request request) {
       return this;
     }
 
-    public Builder statusLine(StatusLine statusLine) {
-      if (statusLine == null) throw new IllegalArgumentException("statusLine == null");
-      this.statusLine = statusLine;
+    public Builder protocol(Protocol protocol) {
+      this.protocol = protocol;
       return this;
     }
 
-    public Builder statusLine(String statusLine) {
-      try {
-        return statusLine(new StatusLine(statusLine));
-      } catch (IOException e) {
-        throw new IllegalArgumentException(e);
-      }
+    public Builder code(int code) {
+      this.code = code;
+      return this;
+    }
+
+    public Builder message(String message) {
+      this.message = message;
+      return this;
     }
 
     public Builder handshake(Handshake handshake) {
@@ -429,24 +299,51 @@ public Builder headers(Headers headers) {
       return this;
     }
 
-    public Builder body(Body body) {
+    public Builder body(ResponseBody body) {
       this.body = body;
       return this;
     }
 
-    // TODO: move out of public API
-    public Builder setResponseSource(ResponseSource responseSource) {
-      return header(OkHeaders.RESPONSE_SOURCE, responseSource + " " + statusLine.code());
+    public Builder networkResponse(Response networkResponse) {
+      if (networkResponse != null) checkSupportResponse("networkResponse", networkResponse);
+      this.networkResponse = networkResponse;
+      return this;
     }
 
-    public Builder redirectedBy(Response redirectedBy) {
-      this.redirectedBy = redirectedBy;
+    public Builder cacheResponse(Response cacheResponse) {
+      if (cacheResponse != null) checkSupportResponse("cacheResponse", cacheResponse);
+      this.cacheResponse = cacheResponse;
       return this;
     }
 
+    private void checkSupportResponse(String name, Response response) {
+      if (response.body != null) {
+        throw new IllegalArgumentException(name + ".body != null");
+      } else if (response.networkResponse != null) {
+        throw new IllegalArgumentException(name + ".networkResponse != null");
+      } else if (response.cacheResponse != null) {
+        throw new IllegalArgumentException(name + ".cacheResponse != null");
+      } else if (response.priorResponse != null) {
+        throw new IllegalArgumentException(name + ".priorResponse != null");
+      }
+    }
+
+    public Builder priorResponse(Response priorResponse) {
+      if (priorResponse != null) checkPriorResponse(priorResponse);
+      this.priorResponse = priorResponse;
+      return this;
+    }
+
+    private void checkPriorResponse(Response response) {
+      if (response.body != null) {
+        throw new IllegalArgumentException("priorResponse.body != null");
+      }
+    }
+
     public Response build() {
       if (request == null) throw new IllegalStateException("request == null");
-      if (statusLine == null) throw new IllegalStateException("statusLine == null");
+      if (protocol == null) throw new IllegalStateException("protocol == null");
+      if (code < 0) throw new IllegalStateException("code < 0: " + code);
       return new Response(this);
     }
   }
diff --git a/okhttp/src/main/java/com/squareup/okhttp/ResponseBody.java b/okhttp/src/main/java/com/squareup/okhttp/ResponseBody.java
new file mode 100644
index 0000000000..e91238a0f2
--- /dev/null
+++ b/okhttp/src/main/java/com/squareup/okhttp/ResponseBody.java
@@ -0,0 +1,93 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.okhttp;
+
+import com.squareup.okhttp.internal.Util;
+import java.io.Closeable;
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.InputStreamReader;
+import java.io.Reader;
+import java.nio.charset.Charset;
+import okio.BufferedSource;
+
+import static com.squareup.okhttp.internal.Util.UTF_8;
+
+public abstract class ResponseBody implements Closeable {
+  /** Multiple calls to {@link #charStream()} must return the same instance. */
+  private Reader reader;
+
+  public abstract MediaType contentType();
+
+  /**
+   * Returns the number of bytes in that will returned by {@link #bytes}, or
+   * {@link #byteStream}, or -1 if unknown.
+   */
+  public abstract long contentLength();
+
+  public final InputStream byteStream() {
+    return source().inputStream();
+  }
+
+  public abstract BufferedSource source();
+
+  public final byte[] bytes() throws IOException {
+    long contentLength = contentLength();
+    if (contentLength > Integer.MAX_VALUE) {
+      throw new IOException("Cannot buffer entire body for content length: " + contentLength);
+    }
+
+    BufferedSource source = source();
+    byte[] bytes;
+    try {
+      bytes = source.readByteArray();
+    } finally {
+      Util.closeQuietly(source);
+    }
+    if (contentLength != -1 && contentLength != bytes.length) {
+      throw new IOException("Content-Length and stream length disagree");
+    }
+    return bytes;
+  }
+
+  /**
+   * Returns the response as a character stream decoded with the charset
+   * of the Content-Type header. If that header is either absent or lacks a
+   * charset, this will attempt to decode the response body as UTF-8.
+   */
+  public final Reader charStream() {
+    Reader r = reader;
+    return r != null ? r : (reader = new InputStreamReader(byteStream(), charset()));
+  }
+
+  /**
+   * Returns the response as a string decoded with the charset of the
+   * Content-Type header. If that header is either absent or lacks a charset,
+   * this will attempt to decode the response body as UTF-8.
+   */
+  public final String string() throws IOException {
+    return new String(bytes(), charset().name());
+  }
+
+  private Charset charset() {
+    MediaType contentType = contentType();
+    return contentType != null ? contentType.charset(UTF_8) : UTF_8;
+  }
+
+  @Override public void close() throws IOException {
+    source().close();
+  }
+}
diff --git a/okhttp/src/main/java/com/squareup/okhttp/ResponseSource.java b/okhttp/src/main/java/com/squareup/okhttp/ResponseSource.java
deleted file mode 100644
index 915fa58e68..0000000000
--- a/okhttp/src/main/java/com/squareup/okhttp/ResponseSource.java
+++ /dev/null
@@ -1,48 +0,0 @@
-/*
- * Copyright (C) 2011 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.squareup.okhttp;
-
-/** The source of an HTTP response. */
-public enum ResponseSource {
-
-  /** The response was returned from the local cache. */
-  CACHE,
-
-  /**
-   * The response is available in the cache but must be validated with the
-   * network. The cache result will be used if it is still valid; otherwise
-   * the network's response will be used.
-   */
-  CONDITIONAL_CACHE,
-
-  /** The response was returned from the network. */
-  NETWORK,
-
-  /**
-   * The request demanded a cached response that the cache couldn't satisfy.
-   * This yields a 504 (Gateway Timeout) response as specified by
-   * http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.9.4.
-   */
-  NONE;
-
-  public boolean requiresConnection() {
-    return this == CONDITIONAL_CACHE || this == NETWORK;
-  }
-
-  public boolean usesCache() {
-    return this == CACHE || this == CONDITIONAL_CACHE;
-  }
-}
diff --git a/okhttp/src/main/java/com/squareup/okhttp/Route.java b/okhttp/src/main/java/com/squareup/okhttp/Route.java
index a08a4699c5..b6c42f530d 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/Route.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/Route.java
@@ -15,6 +15,7 @@
  */
 package com.squareup.okhttp;
 
+import com.squareup.okhttp.internal.http.RouteSelector;
 import java.net.InetSocketAddress;
 import java.net.Proxy;
 
@@ -23,34 +24,34 @@
  * When creating a connection the client has many options:
  * <ul>
  *   <li><strong>HTTP proxy:</strong> a proxy server may be explicitly
- *       configured for the client. Otherwise the {@link java.net.ProxySelector
+ *       configured for the client. Otherwise the {@linkplain java.net.ProxySelector
  *       proxy selector} is used. It may return multiple proxies to attempt.
  *   <li><strong>IP address:</strong> whether connecting directly to an origin
  *       server or a proxy, opening a socket requires an IP address. The DNS
  *       server may return multiple IP addresses to attempt.
- *   <li><strong>Modern TLS:</strong> whether to include advanced TLS options
- *       when attempting a HTTPS connection.
+ *   <li><strong>TLS version:</strong> which TLS version to attempt with the
+ *       HTTPS connection.
  * </ul>
  * Each route is a specific selection of these options.
  */
-public class Route {
+public final class Route {
   final Address address;
   final Proxy proxy;
   final InetSocketAddress inetSocketAddress;
-  final boolean modernTls;
+  final String tlsVersion;
 
   public Route(Address address, Proxy proxy, InetSocketAddress inetSocketAddress,
-      boolean modernTls) {
+      String tlsVersion) {
     if (address == null) throw new NullPointerException("address == null");
     if (proxy == null) throw new NullPointerException("proxy == null");
     if (inetSocketAddress == null) throw new NullPointerException("inetSocketAddress == null");
+    if (tlsVersion == null) throw new NullPointerException("tlsVersion == null");
     this.address = address;
     this.proxy = proxy;
     this.inetSocketAddress = inetSocketAddress;
-    this.modernTls = modernTls;
+    this.tlsVersion = tlsVersion;
   }
 
-  /** Returns the {@link Address} of this route. */
   public Address getAddress() {
     return address;
   }
@@ -59,29 +60,40 @@ public Address getAddress() {
    * Returns the {@link Proxy} of this route.
    *
    * <strong>Warning:</strong> This may disagree with {@link Address#getProxy}
-   * is null. When the address's proxy is null, the proxy selector will be used.
+   * when it is null. When the address's proxy is null, the proxy selector is
+   * used.
    */
   public Proxy getProxy() {
     return proxy;
   }
 
-  /** Returns the {@link InetSocketAddress} of this route. */
   public InetSocketAddress getSocketAddress() {
     return inetSocketAddress;
   }
 
-  /** Returns true if this route uses modern TLS. */
-  public boolean isModernTls() {
-    return modernTls;
+  public String getTlsVersion() {
+    return tlsVersion;
+  }
+
+  boolean supportsNpn() {
+    return !tlsVersion.equals(RouteSelector.SSL_V3);
+  }
+
+  /**
+   * Returns true if this route tunnels HTTPS through an HTTP proxy. See <a
+   * href="http://www.ietf.org/rfc/rfc2817.txt">RFC 2817, Section 5.2</a>.
+   */
+  public boolean requiresTunnel() {
+    return address.sslSocketFactory != null && proxy.type() == Proxy.Type.HTTP;
   }
 
   @Override public boolean equals(Object obj) {
     if (obj instanceof Route) {
       Route other = (Route) obj;
-      return (address.equals(other.address)
+      return address.equals(other.address)
           && proxy.equals(other.proxy)
           && inetSocketAddress.equals(other.inetSocketAddress)
-          && modernTls == other.modernTls);
+          && tlsVersion.equals(other.tlsVersion);
     }
     return false;
   }
@@ -91,7 +103,7 @@ public boolean isModernTls() {
     result = 31 * result + address.hashCode();
     result = 31 * result + proxy.hashCode();
     result = 31 * result + inetSocketAddress.hashCode();
-    result = result + (modernTls ? (31 * result) : 0);
+    result = 31 * result + tlsVersion.hashCode();
     return result;
   }
 }
diff --git a/okhttp/src/main/java/com/squareup/okhttp/TunnelRequest.java b/okhttp/src/main/java/com/squareup/okhttp/TunnelRequest.java
deleted file mode 100644
index 3bcff5a8a5..0000000000
--- a/okhttp/src/main/java/com/squareup/okhttp/TunnelRequest.java
+++ /dev/null
@@ -1,80 +0,0 @@
-/*
- * Copyright (C) 2012 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.squareup.okhttp;
-
-import java.io.IOException;
-import java.net.URL;
-
-import static com.squareup.okhttp.internal.Util.getDefaultPort;
-
-/**
- * Routing and authentication information sent to an HTTP proxy to create a
- * HTTPS to an origin server. Everything in the tunnel request is sent
- * unencrypted to the proxy server.
- *
- * <p>See <a href="http://www.ietf.org/rfc/rfc2817.txt">RFC 2817, Section
- * 5.2</a>.
- */
-public final class TunnelRequest {
-  final String host;
-  final int port;
-  final String userAgent;
-  final String proxyAuthorization;
-
-  /**
-   * @param host the origin server's hostname. Not null.
-   * @param port the origin server's port, like 80 or 443.
-   * @param userAgent the client's user-agent. Not null.
-   * @param proxyAuthorization proxy authorization, or null if the proxy is
-   * used without an authorization header.
-   */
-  public TunnelRequest(String host, int port, String userAgent, String proxyAuthorization) {
-    if (host == null) throw new NullPointerException("host == null");
-    if (userAgent == null) throw new NullPointerException("userAgent == null");
-    this.host = host;
-    this.port = port;
-    this.userAgent = userAgent;
-    this.proxyAuthorization = proxyAuthorization;
-  }
-
-  String requestLine() {
-    return "CONNECT " + host + ":" + port + " HTTP/1.1";
-  }
-
-  /**
-   * If we're creating a TLS tunnel, send only the minimum set of headers.
-   * This avoids sending potentially sensitive data like HTTP cookies to
-   * the proxy unencrypted.
-   */
-  Request getRequest() throws IOException {
-    Request.Builder result = new Request.Builder()
-        .url(new URL("https", host, port, "/"));
-
-    // Always set Host and User-Agent.
-    result.header("Host", port == getDefaultPort("https") ? host : (host + ":" + port));
-    result.header("User-Agent", userAgent);
-
-    // Copy over the Proxy-Authorization header if it exists.
-    if (proxyAuthorization != null) {
-      result.header("Proxy-Authorization", proxyAuthorization);
-    }
-
-    // Always set the Proxy-Connection to Keep-Alive for the benefit of
-    // HTTP/1.0 proxies like Squid.
-    result.header("Proxy-Connection", "Keep-Alive");
-    return result.build();
-  }
-}
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/BitArray.java b/okhttp/src/main/java/com/squareup/okhttp/internal/BitArray.java
deleted file mode 100644
index c83f1dd50d..0000000000
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/BitArray.java
+++ /dev/null
@@ -1,177 +0,0 @@
-/*
- * Copyright 2014 Square Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.squareup.okhttp.internal;
-
-import java.util.ArrayList;
-import java.util.Arrays;
-import java.util.List;
-
-import static java.lang.String.format;
-
-/** A simple bitset which supports left shifting. */
-public interface BitArray {
-
-  void clear();
-
-  void set(int index);
-
-  void toggle(int index);
-
-  boolean get(int index);
-
-  void shiftLeft(int count);
-
-  /** Bit set that only supports settings bits 0 - 63. */
-  public final class FixedCapacity implements BitArray {
-    long data = 0x0000000000000000L;
-
-    @Override public void clear() {
-      data = 0x0000000000000000L;
-    }
-
-    @Override public void set(int index) {
-      data |= (1L << checkInput(index));
-    }
-
-    @Override public void toggle(int index) {
-      data ^= (1L << checkInput(index));
-    }
-
-    @Override public boolean get(int index) {
-      return ((data >> checkInput(index)) & 1L) == 1;
-    }
-
-    @Override public void shiftLeft(int count) {
-      data = data << checkInput(count);
-    }
-
-    @Override public String toString() {
-      return Long.toBinaryString(data);
-    }
-
-    public BitArray toVariableCapacity() {
-      return new VariableCapacity(this);
-    }
-
-    private static int checkInput(int index) {
-      if (index < 0 || index > 63) {
-        throw new IllegalArgumentException(format("input must be between 0 and 63: %s", index));
-      }
-      return index;
-    }
-  }
-
-  /** Bit set that grows as needed. */
-  public final class VariableCapacity implements BitArray {
-
-    long[] data;
-
-    // Start offset which allows for cheap shifting. Data is always kept on 64-bit bounds but we
-    // offset the outward facing index to support shifts without having to move the underlying bits.
-    private int start; // Valid values are [0..63]
-
-    public VariableCapacity() {
-      data = new long[1];
-    }
-
-    private VariableCapacity(FixedCapacity small) {
-      data = new long[] {small.data, 0};
-    }
-
-    private void growToSize(int size) {
-      long[] newData = new long[size];
-      if (data != null) {
-        System.arraycopy(data, 0, newData, 0, data.length);
-      }
-      data = newData;
-    }
-
-    private int offsetOf(int index) {
-      index += start;
-      int offset = index / 64;
-      if (offset > data.length - 1) {
-        growToSize(offset + 1);
-      }
-      return offset;
-    }
-
-    private int shiftOf(int index) {
-      return (index + start) % 64;
-    }
-
-    @Override public void clear() {
-      Arrays.fill(data, 0);
-    }
-
-    @Override public void set(int index) {
-      checkInput(index);
-      int offset = offsetOf(index);
-      data[offset] |= 1L << shiftOf(index);
-    }
-
-    @Override public void toggle(int index) {
-      checkInput(index);
-      int offset = offsetOf(index);
-      data[offset] ^= 1L << shiftOf(index);
-    }
-
-    @Override public boolean get(int index) {
-      checkInput(index);
-      int offset = offsetOf(index);
-      return (data[offset] & (1L << shiftOf(index))) != 0;
-    }
-
-    @Override public void shiftLeft(int count) {
-      start -= checkInput(count);
-      if (start < 0) {
-        int arrayShift = (start / -64) + 1;
-        long[] newData = new long[data.length + arrayShift];
-        System.arraycopy(data, 0, newData, arrayShift, data.length);
-        data = newData;
-        start = 64 + (start % 64);
-      }
-    }
-
-    @Override public String toString() {
-      StringBuilder builder = new StringBuilder("{");
-      List<Integer> ints = toIntegerList();
-      for (int i = 0, count = ints.size(); i < count; i++) {
-        if (i > 0) {
-          builder.append(',');
-        }
-        builder.append(ints.get(i));
-      }
-      return builder.append('}').toString();
-    }
-
-    List<Integer> toIntegerList() {
-      List<Integer> ints = new ArrayList<Integer>();
-      for (int i = 0, count = data.length * 64 - start; i < count; i++) {
-        if (get(i)) {
-          ints.add(i);
-        }
-      }
-      return ints;
-    }
-
-    private static int checkInput(int index) {
-      if (index < 0) {
-        throw new IllegalArgumentException(format("input must be a positive number: %s", index));
-      }
-      return index;
-    }
-  }
-}
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/DiskLruCache.java b/okhttp/src/main/java/com/squareup/okhttp/internal/DiskLruCache.java
index ba1f288d52..05e06f5959 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/DiskLruCache.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/DiskLruCache.java
@@ -19,13 +19,9 @@
 import java.io.Closeable;
 import java.io.EOFException;
 import java.io.File;
-import java.io.FileInputStream;
 import java.io.FileNotFoundException;
-import java.io.FileOutputStream;
-import java.io.FilterOutputStream;
 import java.io.IOException;
-import java.io.InputStream;
-import java.io.OutputStream;
+import java.util.Arrays;
 import java.util.Iterator;
 import java.util.LinkedHashMap;
 import java.util.Map;
@@ -34,10 +30,14 @@
 import java.util.concurrent.TimeUnit;
 import java.util.regex.Matcher;
 import java.util.regex.Pattern;
+import okio.Buffer;
 import okio.BufferedSink;
 import okio.BufferedSource;
-import okio.OkBuffer;
+import okio.ForwardingSink;
 import okio.Okio;
+import okio.Sink;
+import okio.Source;
+import okio.Timeout;
 
 /**
  * A cache that uses a bounded amount of space on a filesystem. Each cache
@@ -145,8 +145,7 @@
   private final int valueCount;
   private long size = 0;
   private BufferedSink journalWriter;
-  private final LinkedHashMap<String, Entry> lruEntries =
-      new LinkedHashMap<String, Entry>(0, 0.75f, true);
+  private final LinkedHashMap<String, Entry> lruEntries = new LinkedHashMap<>(0, 0.75f, true);
   private int redundantOpCount;
 
   /**
@@ -224,7 +223,7 @@ public static DiskLruCache open(File directory, int appVersion, int valueCount,
       try {
         cache.readJournal();
         cache.processJournal();
-        cache.journalWriter = Okio.buffer(Okio.sink(new FileOutputStream(cache.journalFile, true)));
+        cache.journalWriter = Okio.buffer(Okio.appendingSink(cache.journalFile));
         return cache;
       } catch (IOException journalIsCorrupt) {
         Platform.get().logW("DiskLruCache " + directory + " is corrupt: "
@@ -241,7 +240,7 @@ public static DiskLruCache open(File directory, int appVersion, int valueCount,
   }
 
   private void readJournal() throws IOException {
-    BufferedSource source = Okio.buffer(Okio.source(new FileInputStream(journalFile)));
+    BufferedSource source = Okio.buffer(Okio.source(journalFile));
     try {
       String magic = source.readUtf8LineStrict();
       String version = source.readUtf8LineStrict();
@@ -326,8 +325,8 @@ private void processJournal() throws IOException {
       } else {
         entry.currentEditor = null;
         for (int t = 0; t < valueCount; t++) {
-          deleteIfExists(entry.getCleanFile(t));
-          deleteIfExists(entry.getDirtyFile(t));
+          deleteIfExists(entry.cleanFiles[t]);
+          deleteIfExists(entry.dirtyFiles[t]);
         }
         i.remove();
       }
@@ -343,23 +342,24 @@ private synchronized void rebuildJournal() throws IOException {
       journalWriter.close();
     }
 
-    BufferedSink writer = Okio.buffer(Okio.sink(new FileOutputStream(journalFileTmp)));
+    BufferedSink writer = Okio.buffer(Okio.sink(journalFileTmp));
     try {
-      writer.writeUtf8(MAGIC);
-      writer.writeUtf8("\n");
-      writer.writeUtf8(VERSION_1);
-      writer.writeUtf8("\n");
-      writer.writeUtf8(Integer.toString(appVersion));
-      writer.writeUtf8("\n");
-      writer.writeUtf8(Integer.toString(valueCount));
-      writer.writeUtf8("\n");
-      writer.writeUtf8("\n");
+      writer.writeUtf8(MAGIC).writeByte('\n');
+      writer.writeUtf8(VERSION_1).writeByte('\n');
+      writer.writeUtf8(Integer.toString(appVersion)).writeByte('\n');
+      writer.writeUtf8(Integer.toString(valueCount)).writeByte('\n');
+      writer.writeByte('\n');
 
       for (Entry entry : lruEntries.values()) {
         if (entry.currentEditor != null) {
-          writer.writeUtf8(DIRTY + ' ' + entry.key + '\n');
+          writer.writeUtf8(DIRTY).writeByte(' ');
+          writer.writeUtf8(entry.key);
+          writer.writeByte('\n');
         } else {
-          writer.writeUtf8(CLEAN + ' ' + entry.key + entry.getLengths() + '\n');
+          writer.writeUtf8(CLEAN).writeByte(' ');
+          writer.writeUtf8(entry.key);
+          writer.writeUtf8(entry.getLengths());
+          writer.writeByte('\n');
         }
       }
     } finally {
@@ -372,12 +372,13 @@ private synchronized void rebuildJournal() throws IOException {
     renameTo(journalFileTmp, journalFile, false);
     journalFileBackup.delete();
 
-    journalWriter = Okio.buffer(Okio.sink(new FileOutputStream(journalFile, true)));
+    journalWriter = Okio.buffer(Okio.appendingSink(journalFile));
   }
 
   private static void deleteIfExists(File file) throws IOException {
-    if (file.exists() && !file.delete()) {
-      throw new IOException();
+    // If delete() fails, make sure it's because the file didn't exist!
+    if (!file.delete() && file.exists()) {
+      throw new IOException("failed to delete " + file);
     }
   }
 
@@ -410,16 +411,16 @@ public synchronized Snapshot get(String key) throws IOException {
     // Open all streams eagerly to guarantee that we see a single published
     // snapshot. If we opened streams lazily then the streams could come
     // from different edits.
-    InputStream[] ins = new InputStream[valueCount];
+    Source[] sources = new Source[valueCount];
     try {
       for (int i = 0; i < valueCount; i++) {
-        ins[i] = new FileInputStream(entry.getCleanFile(i));
+        sources[i] = Okio.source(entry.cleanFiles[i]);
       }
     } catch (FileNotFoundException e) {
       // A file must have been deleted manually!
       for (int i = 0; i < valueCount; i++) {
-        if (ins[i] != null) {
-          Util.closeQuietly(ins[i]);
+        if (sources[i] != null) {
+          Util.closeQuietly(sources[i]);
         } else {
           break;
         }
@@ -428,12 +429,12 @@ public synchronized Snapshot get(String key) throws IOException {
     }
 
     redundantOpCount++;
-    journalWriter.writeUtf8(READ + ' ' + key + '\n');
+    journalWriter.writeUtf8(READ).writeByte(' ').writeUtf8(key).writeByte('\n');
     if (journalRebuildRequired()) {
       executorService.execute(cleanupRunnable);
     }
 
-    return new Snapshot(key, entry.sequenceNumber, ins, entry.lengths);
+    return new Snapshot(key, entry.sequenceNumber, sources, entry.lengths);
   }
 
   /**
@@ -463,7 +464,7 @@ private synchronized Editor edit(String key, long expectedSequenceNumber) throws
     entry.currentEditor = editor;
 
     // Flush the journal before creating files to prevent file leaks.
-    journalWriter.writeUtf8(DIRTY + ' ' + key + '\n');
+    journalWriter.writeUtf8(DIRTY).writeByte(' ').writeUtf8(key).writeByte('\n');
     journalWriter.flush();
     return editor;
   }
@@ -477,7 +478,7 @@ public File getDirectory() {
    * Returns the maximum number of bytes that this cache should use to store
    * its data.
    */
-  public long getMaxSize() {
+  public synchronized long getMaxSize() {
     return maxSize;
   }
 
@@ -512,7 +513,7 @@ private synchronized void completeEdit(Editor editor, boolean success) throws IO
           editor.abort();
           throw new IllegalStateException("Newly created entry didn't create value for index " + i);
         }
-        if (!entry.getDirtyFile(i).exists()) {
+        if (!entry.dirtyFiles[i].exists()) {
           editor.abort();
           return;
         }
@@ -520,10 +521,10 @@ private synchronized void completeEdit(Editor editor, boolean success) throws IO
     }
 
     for (int i = 0; i < valueCount; i++) {
-      File dirty = entry.getDirtyFile(i);
+      File dirty = entry.dirtyFiles[i];
       if (success) {
         if (dirty.exists()) {
-          File clean = entry.getCleanFile(i);
+          File clean = entry.cleanFiles[i];
           dirty.renameTo(clean);
           long oldLength = entry.lengths[i];
           long newLength = clean.length();
@@ -539,13 +540,18 @@ private synchronized void completeEdit(Editor editor, boolean success) throws IO
     entry.currentEditor = null;
     if (entry.readable | success) {
       entry.readable = true;
-      journalWriter.writeUtf8(CLEAN + ' ' + entry.key + entry.getLengths() + '\n');
+      journalWriter.writeUtf8(CLEAN).writeByte(' ');
+      journalWriter.writeUtf8(entry.key);
+      journalWriter.writeUtf8(entry.getLengths());
+      journalWriter.writeByte('\n');
       if (success) {
         entry.sequenceNumber = nextSequenceNumber++;
       }
     } else {
       lruEntries.remove(entry.key);
-      journalWriter.writeUtf8(REMOVE + ' ' + entry.key + '\n');
+      journalWriter.writeUtf8(REMOVE).writeByte(' ');
+      journalWriter.writeUtf8(entry.key);
+      journalWriter.writeByte('\n');
     }
     journalWriter.flush();
 
@@ -579,16 +585,14 @@ public synchronized boolean remove(String key) throws IOException {
     }
 
     for (int i = 0; i < valueCount; i++) {
-      File file = entry.getCleanFile(i);
-      if (!file.delete()) {
-        throw new IOException("failed to delete " + file);
-      }
+      File file = entry.cleanFiles[i];
+      deleteIfExists(file);
       size -= entry.lengths[i];
       entry.lengths[i] = 0;
     }
 
     redundantOpCount++;
-    journalWriter.writeUtf8(REMOVE + ' ' + key + '\n');
+    journalWriter.writeUtf8(REMOVE).writeByte(' ').writeUtf8(key).writeByte('\n');
     lruEntries.remove(key);
 
     if (journalRebuildRequired()) {
@@ -657,22 +661,25 @@ private void validateKey(String key) {
     }
   }
 
-  private static String inputStreamToString(InputStream in) throws IOException {
-    OkBuffer buffer = Util.readFully(Okio.source(in));
-    return buffer.readUtf8(buffer.size());
+  private static String sourceToString(Source in) throws IOException {
+    try {
+      return Okio.buffer(in).readUtf8();
+    } finally {
+      Util.closeQuietly(in);
+    }
   }
 
   /** A snapshot of the values for an entry. */
   public final class Snapshot implements Closeable {
     private final String key;
     private final long sequenceNumber;
-    private final InputStream[] ins;
+    private final Source[] sources;
     private final long[] lengths;
 
-    private Snapshot(String key, long sequenceNumber, InputStream[] ins, long[] lengths) {
+    private Snapshot(String key, long sequenceNumber, Source[] sources, long[] lengths) {
       this.key = key;
       this.sequenceNumber = sequenceNumber;
-      this.ins = ins;
+      this.sources = sources;
       this.lengths = lengths;
     }
 
@@ -686,13 +693,13 @@ public Editor edit() throws IOException {
     }
 
     /** Returns the unbuffered stream with the value for {@code index}. */
-    public InputStream getInputStream(int index) {
-      return ins[index];
+    public Source getSource(int index) {
+      return sources[index];
     }
 
     /** Returns the string value for {@code index}. */
     public String getString(int index) throws IOException {
-      return inputStreamToString(getInputStream(index));
+      return sourceToString(getSource(index));
     }
 
     /** Returns the byte length of the value for {@code index}. */
@@ -701,17 +708,26 @@ public long getLength(int index) {
     }
 
     public void close() {
-      for (InputStream in : ins) {
+      for (Source in : sources) {
         Util.closeQuietly(in);
       }
     }
   }
 
-  private static final OutputStream NULL_OUTPUT_STREAM = new OutputStream() {
-    @Override
-    public void write(int b) throws IOException {
+  private static final Sink NULL_SINK = new Sink() {
+    @Override public void write(Buffer source, long byteCount) throws IOException {
       // Eat all writes silently. Nom nom.
     }
+
+    @Override public void flush() throws IOException {
+    }
+
+    @Override public Timeout timeout() {
+      return Timeout.NONE;
+    }
+
+    @Override public void close() throws IOException {
+    }
   };
 
   /** Edits the values for an entry. */
@@ -730,7 +746,7 @@ private Editor(Entry entry) {
      * Returns an unbuffered input stream to read the last committed value,
      * or null if no value has been committed.
      */
-    public InputStream newInputStream(int index) throws IOException {
+    public Source newSource(int index) throws IOException {
       synchronized (DiskLruCache.this) {
         if (entry.currentEditor != this) {
           throw new IllegalStateException();
@@ -739,7 +755,7 @@ public InputStream newInputStream(int index) throws IOException {
           return null;
         }
         try {
-          return new FileInputStream(entry.getCleanFile(index));
+          return Okio.source(entry.cleanFiles[index]);
         } catch (FileNotFoundException e) {
           return null;
         }
@@ -751,8 +767,8 @@ public InputStream newInputStream(int index) throws IOException {
      * has been committed.
      */
     public String getString(int index) throws IOException {
-      InputStream in = newInputStream(index);
-      return in != null ? inputStreamToString(in) : null;
+      Source source = newSource(index);
+      return source != null ? sourceToString(source) : null;
     }
 
     /**
@@ -762,7 +778,7 @@ public String getString(int index) throws IOException {
      * {@link #commit} is called. The returned output stream does not throw
      * IOExceptions.
      */
-    public OutputStream newOutputStream(int index) throws IOException {
+    public Sink newSink(int index) throws IOException {
       synchronized (DiskLruCache.this) {
         if (entry.currentEditor != this) {
           throw new IllegalStateException();
@@ -770,27 +786,27 @@ public OutputStream newOutputStream(int index) throws IOException {
         if (!entry.readable) {
           written[index] = true;
         }
-        File dirtyFile = entry.getDirtyFile(index);
-        FileOutputStream outputStream;
+        File dirtyFile = entry.dirtyFiles[index];
+        Sink sink;
         try {
-          outputStream = new FileOutputStream(dirtyFile);
+          sink = Okio.sink(dirtyFile);
         } catch (FileNotFoundException e) {
           // Attempt to recreate the cache directory.
           directory.mkdirs();
           try {
-            outputStream = new FileOutputStream(dirtyFile);
+            sink = Okio.sink(dirtyFile);
           } catch (FileNotFoundException e2) {
             // We are unable to recover. Silently eat the writes.
-            return NULL_OUTPUT_STREAM;
+            return NULL_SINK;
           }
         }
-        return new FaultHidingOutputStream(outputStream);
+        return new FaultHidingSink(sink);
       }
     }
 
     /** Sets the value at {@code index} to {@code value}. */
     public void set(int index, String value) throws IOException {
-      BufferedSink writer = Okio.buffer(Okio.sink(newOutputStream(index)));
+      BufferedSink writer = Okio.buffer(newSink(index));
       writer.writeUtf8(value);
       writer.close();
     }
@@ -826,38 +842,30 @@ public void abortUnlessCommitted() {
       }
     }
 
-    private class FaultHidingOutputStream extends FilterOutputStream {
-      private FaultHidingOutputStream(OutputStream out) {
-        super(out);
+    private class FaultHidingSink extends ForwardingSink {
+      public FaultHidingSink(Sink delegate) {
+        super(delegate);
       }
 
-      @Override public void write(int oneByte) {
+      @Override public void write(Buffer source, long byteCount) throws IOException {
         try {
-          out.write(oneByte);
+          super.write(source, byteCount);
         } catch (IOException e) {
           hasErrors = true;
         }
       }
 
-      @Override public void write(byte[] buffer, int offset, int length) {
+      @Override public void flush() throws IOException {
         try {
-          out.write(buffer, offset, length);
+          super.flush();
         } catch (IOException e) {
           hasErrors = true;
         }
       }
 
-      @Override public void close() {
+      @Override public void close() throws IOException {
         try {
-          out.close();
-        } catch (IOException e) {
-          hasErrors = true;
-        }
-      }
-
-      @Override public void flush() {
-        try {
-          out.flush();
+          super.close();
         } catch (IOException e) {
           hasErrors = true;
         }
@@ -870,6 +878,8 @@ private FaultHidingOutputStream(OutputStream out) {
 
     /** Lengths of this entry's files. */
     private final long[] lengths;
+    private final File[] cleanFiles;
+    private final File[] dirtyFiles;
 
     /** True if this entry has ever been published. */
     private boolean readable;
@@ -882,7 +892,21 @@ private FaultHidingOutputStream(OutputStream out) {
 
     private Entry(String key) {
       this.key = key;
-      this.lengths = new long[valueCount];
+
+      lengths = new long[valueCount];
+      cleanFiles = new File[valueCount];
+      dirtyFiles = new File[valueCount];
+
+      // The names are repetitive so re-use the same builder to avoid allocations.
+      StringBuilder fileBuilder = new StringBuilder(key).append('.');
+      int truncateTo = fileBuilder.length();
+      for (int i = 0; i < valueCount; i++) {
+        fileBuilder.append(i);
+        cleanFiles[i] = new File(directory, fileBuilder.toString());
+        fileBuilder.append(".tmp");
+        dirtyFiles[i] = new File(directory, fileBuilder.toString());
+        fileBuilder.setLength(truncateTo);
+      }
     }
 
     public String getLengths() throws IOException {
@@ -909,15 +933,7 @@ private void setLengths(String[] strings) throws IOException {
     }
 
     private IOException invalidLengths(String[] strings) throws IOException {
-      throw new IOException("unexpected journal line: " + java.util.Arrays.toString(strings));
-    }
-
-    public File getCleanFile(int i) {
-      return new File(directory, key + "." + i);
-    }
-
-    public File getDirtyFile(int i) {
-      return new File(directory, key + "." + i + ".tmp");
+      throw new IOException("unexpected journal line: " + Arrays.toString(strings));
     }
   }
 }
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/Internal.java b/okhttp/src/main/java/com/squareup/okhttp/internal/Internal.java
new file mode 100644
index 0000000000..a4d3a6229a
--- /dev/null
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/Internal.java
@@ -0,0 +1,63 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.okhttp.internal;
+
+import com.squareup.okhttp.Connection;
+import com.squareup.okhttp.ConnectionPool;
+import com.squareup.okhttp.Headers;
+import com.squareup.okhttp.OkHttpClient;
+import com.squareup.okhttp.Protocol;
+import com.squareup.okhttp.Request;
+import com.squareup.okhttp.internal.http.HttpEngine;
+import com.squareup.okhttp.internal.http.Transport;
+import java.io.IOException;
+
+/**
+ * Escalate internal APIs in {@code com.squareup.okhttp} so they can be used
+ * from OkHttp's implementation packages. The only implementation of this
+ * interface is in {@link com.squareup.okhttp.OkHttpClient}.
+ */
+public abstract class Internal {
+  public static Internal instance;
+
+  public abstract Transport newTransport(Connection connection, HttpEngine httpEngine)
+      throws IOException;
+
+  public abstract boolean clearOwner(Connection connection);
+
+  public abstract void closeIfOwnedBy(Connection connection, Object owner) throws IOException;
+
+  public abstract int recycleCount(Connection connection);
+
+  public abstract void setProtocol(Connection connection, Protocol protocol);
+
+  public abstract void setOwner(Connection connection, HttpEngine httpEngine);
+
+  public abstract boolean isReadable(Connection pooled);
+
+  public abstract void addLine(Headers.Builder builder, String line);
+
+  public abstract void setCache(OkHttpClient client, InternalCache internalCache);
+
+  public abstract InternalCache internalCache(OkHttpClient client);
+
+  public abstract void recycle(ConnectionPool pool, Connection connection);
+
+  public abstract RouteDatabase routeDatabase(OkHttpClient client);
+
+  public abstract void connectAndSetOwner(OkHttpClient client, Connection connection,
+      HttpEngine owner, Request request) throws IOException;
+}
diff --git a/okhttp/src/main/java/com/squareup/okhttp/OkResponseCache.java b/okhttp/src/main/java/com/squareup/okhttp/internal/InternalCache.java
similarity index 62%
rename from okhttp/src/main/java/com/squareup/okhttp/OkResponseCache.java
rename to okhttp/src/main/java/com/squareup/okhttp/internal/InternalCache.java
index 05460f5ada..4925358225 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/OkResponseCache.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/InternalCache.java
@@ -13,27 +13,28 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.squareup.okhttp;
+package com.squareup.okhttp.internal;
 
+import com.squareup.okhttp.Request;
+import com.squareup.okhttp.Response;
+import com.squareup.okhttp.internal.http.CacheRequest;
+import com.squareup.okhttp.internal.http.CacheStrategy;
 import java.io.IOException;
-import java.net.CacheRequest;
 
 /**
- * An extended response cache API. Unlike {@link java.net.ResponseCache}, this
- * interface supports conditional caching and statistics.
+ * OkHttp's internal cache interface. Applications shouldn't implement this:
+ * instead use {@link com.squareup.okhttp.Cache}.
  */
-public interface OkResponseCache {
+public interface InternalCache {
   Response get(Request request) throws IOException;
 
   CacheRequest put(Response response) throws IOException;
 
   /**
-   * Remove any cache entries for the supplied {@code uri}. Returns true if the
-   * supplied {@code requestMethod} potentially invalidates an entry in the
-   * cache.
+   * Remove any cache entries for the supplied {@code request}. This is invoked
+   * when the client invalidates the cache, such as when making POST requests.
    */
-  // TODO: this shouldn't return a boolean.
-  boolean maybeRemove(Request request) throws IOException;
+  void remove(Request request) throws IOException;
 
   /**
    * Handles a conditional request hit by updating the stored cache response
@@ -46,6 +47,6 @@
   /** Track an conditional GET that was satisfied by this cache. */
   void trackConditionalCacheHit();
 
-  /** Track an HTTP response being satisfied by {@code source}. */
-  void trackResponse(ResponseSource source);
+  /** Track an HTTP response being satisfied with {@code cacheStrategy}. */
+  void trackResponse(CacheStrategy cacheStrategy);
 }
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/Platform.java b/okhttp/src/main/java/com/squareup/okhttp/internal/Platform.java
index 1e7bc40c83..70ae3ee6d4 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/Platform.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/Platform.java
@@ -18,8 +18,6 @@
 
 import com.squareup.okhttp.Protocol;
 import java.io.IOException;
-import java.io.OutputStream;
-import java.lang.reflect.Constructor;
 import java.lang.reflect.InvocationHandler;
 import java.lang.reflect.InvocationTargetException;
 import java.lang.reflect.Method;
@@ -34,10 +32,8 @@
 import java.util.List;
 import java.util.logging.Level;
 import java.util.logging.Logger;
-import java.util.zip.Deflater;
-import java.util.zip.DeflaterOutputStream;
 import javax.net.ssl.SSLSocket;
-import okio.ByteString;
+import okio.Buffer;
 
 /**
  * Access to Platform-specific features necessary for SPDY and advanced TLS.
@@ -49,24 +45,21 @@
  *
  * <p>NPN (Next Protocol Negotiation) was developed for SPDY. It is widely
  * available and we support it on both Android (4.1+) and OpenJDK 7 (via the
- * Jetty NPN-boot library).
+ * Jetty Alpn-boot library). NPN is not yet available on OpenJDK 8.
  *
  * <p>ALPN (Application Layer Protocol Negotiation) is the successor to NPN. It
- * has some technical advantages over NPN. We support it on Android (4.4+) only.
+ * has some technical advantages over NPN. ALPN first arrived in Android 4.4,
+ * but that release suffers a <a href="http://goo.gl/y5izPP">concurrency bug</a>
+ * so we don't use it. ALPN is supported on OpenJDK 7 and 8 (via the Jetty
+ * ALPN-boot library).
  *
  * <p>On platforms that support both extensions, OkHttp will use both,
- * preferring ALPN's result. Future versions of OkHttp will drop support NPN.
- *
- * <h3>Deflater Sync Flush</h3>
- * SPDY header compression requires a recent version of {@code
- * DeflaterOutputStream} that is public API in Java 7 and callable via
- * reflection in Android 4.1+.
+ * preferring ALPN's result. Future versions of OkHttp will drop support for
+ * NPN.
  */
 public class Platform {
   private static final Platform PLATFORM = findPlatform();
 
-  private Constructor<DeflaterOutputStream> deflaterConstructor;
-
   public static Platform get() {
     return PLATFORM;
   }
@@ -91,31 +84,29 @@ public URI toUriLenient(URL url) throws URISyntaxException {
   }
 
   /**
-   * Attempt a TLS connection with useful extensions enabled. This mode
-   * supports more features, but is less likely to be compatible with older
-   * HTTPS servers.
-   */
-  public void enableTlsExtensions(SSLSocket socket, String uriHost) {
-  }
-
-  /**
-   * Attempt a secure connection with basic functionality to maximize
-   * compatibility. Currently this uses SSL 3.0.
+   * Configure the TLS connection to use {@code tlsVersion}. We also bundle
+   * certain extensions with certain versions. In particular, we enable Server
+   * Name Indication (SNI) and Next Protocol Negotiation (NPN) with TLSv1 on
+   * platforms that support them.
    */
-  public void supportTlsIntolerantServer(SSLSocket socket) {
-    socket.setEnabledProtocols(new String[] {"SSLv3"});
+  public void configureTls(SSLSocket socket, String uriHost, String tlsVersion) {
+    // We don't call setEnabledProtocols("TLSv1") on the assumption that that's
+    // the default. TODO: confirm this and support more TLS versions.
+    if (tlsVersion.equals("SSLv3")) {
+      socket.setEnabledProtocols(new String[] {"SSLv3"});
+    }
   }
 
   /** Returns the negotiated protocol, or null if no protocol was negotiated. */
-  public ByteString getNpnSelectedProtocol(SSLSocket socket) {
+  public String getSelectedProtocol(SSLSocket socket) {
     return null;
   }
 
   /**
    * Sets client-supported protocols on a socket to send to a server. The
-   * protocols are only sent if the socket implementation supports NPN.
+   * protocols are only sent if the socket implementation supports ALPN or NPN.
    */
-  public void setNpnProtocols(SSLSocket socket, List<Protocol> npnProtocols) {
+  public void setProtocols(SSLSocket socket, List<Protocol> protocols) {
   }
 
   public void connectSocket(Socket socket, InetSocketAddress address,
@@ -123,32 +114,6 @@ public void connectSocket(Socket socket, InetSocketAddress address,
     socket.connect(address, connectTimeout);
   }
 
-  /**
-   * Returns a deflater output stream that supports SYNC_FLUSH for SPDY name
-   * value blocks. This throws an {@link UnsupportedOperationException} on
-   * Java 6 and earlier where there is no built-in API to do SYNC_FLUSH.
-   */
-  public OutputStream newDeflaterOutputStream(OutputStream out, Deflater deflater,
-      boolean syncFlush) {
-    try {
-      Constructor<DeflaterOutputStream> constructor = deflaterConstructor;
-      if (constructor == null) {
-        constructor = deflaterConstructor = DeflaterOutputStream.class.getConstructor(
-            OutputStream.class, Deflater.class, boolean.class);
-      }
-      return constructor.newInstance(out, deflater, syncFlush);
-    } catch (NoSuchMethodException e) {
-      throw new UnsupportedOperationException("Cannot SPDY; no SYNC_FLUSH available");
-    } catch (InvocationTargetException e) {
-      throw e.getCause() instanceof RuntimeException ? (RuntimeException) e.getCause()
-          : new RuntimeException(e.getCause());
-    } catch (InstantiationException e) {
-      throw new RuntimeException(e);
-    } catch (IllegalAccessException e) {
-      throw new AssertionError();
-    }
-  }
-
   /** Attempt to match the host runtime to a capable Platform implementation. */
   private static Platform findPlatform() {
     // Attempt to find Android 2.3+ APIs.
@@ -167,45 +132,53 @@ private static Platform findPlatform() {
       setUseSessionTickets = openSslSocketClass.getMethod("setUseSessionTickets", boolean.class);
       setHostname = openSslSocketClass.getMethod("setHostname", String.class);
 
+      // Attempt to find Android 4.0+ APIs.
+      Method trafficStatsTagSocket = null;
+      Method trafficStatsUntagSocket = null;
+      try {
+        Class<?> trafficStats = Class.forName("android.net.TrafficStats");
+        trafficStatsTagSocket = trafficStats.getMethod("tagSocket", Socket.class);
+        trafficStatsUntagSocket = trafficStats.getMethod("untagSocket", Socket.class);
+      } catch (ClassNotFoundException ignored) {
+      } catch (NoSuchMethodException ignored) {
+      }
+
       // Attempt to find Android 4.1+ APIs.
       Method setNpnProtocols = null;
       Method getNpnSelectedProtocol = null;
-      Method setAlpnProtocols = null;
-      Method getAlpnSelectedProtocol = null;
       try {
         setNpnProtocols = openSslSocketClass.getMethod("setNpnProtocols", byte[].class);
         getNpnSelectedProtocol = openSslSocketClass.getMethod("getNpnSelectedProtocol");
-        try {
-          setAlpnProtocols = openSslSocketClass.getMethod("setAlpnProtocols", byte[].class);
-          getAlpnSelectedProtocol = openSslSocketClass.getMethod("getAlpnSelectedProtocol");
-        } catch (NoSuchMethodException ignored) {
-        }
       } catch (NoSuchMethodException ignored) {
       }
 
-      return new Android(openSslSocketClass, setUseSessionTickets, setHostname, setNpnProtocols,
-          getNpnSelectedProtocol, setAlpnProtocols, getAlpnSelectedProtocol);
+      return new Android(openSslSocketClass, setUseSessionTickets, setHostname,
+          trafficStatsTagSocket, trafficStatsUntagSocket, setNpnProtocols,
+          getNpnSelectedProtocol);
     } catch (ClassNotFoundException ignored) {
       // This isn't an Android runtime.
     } catch (NoSuchMethodException ignored) {
       // This isn't Android 2.3 or better.
     }
 
-    // Attempt to find the Jetty's NPN extension for OpenJDK.
-    try {
-      String npnClassName = "org.eclipse.jetty.npn.NextProtoNego";
-      Class<?> nextProtoNegoClass = Class.forName(npnClassName);
-      Class<?> providerClass = Class.forName(npnClassName + "$Provider");
-      Class<?> clientProviderClass = Class.forName(npnClassName + "$ClientProvider");
-      Class<?> serverProviderClass = Class.forName(npnClassName + "$ServerProvider");
-      Method putMethod = nextProtoNegoClass.getMethod("put", SSLSocket.class, providerClass);
-      Method getMethod = nextProtoNegoClass.getMethod("get", SSLSocket.class);
-      return new JdkWithJettyNpnPlatform(
+    try { // to find the Jetty's ALPN or NPN extension for OpenJDK.
+      String negoClassName = "org.eclipse.jetty.alpn.ALPN";
+      Class<?> negoClass;
+      try {
+        negoClass = Class.forName(negoClassName);
+      } catch (ClassNotFoundException ignored) { // ALPN isn't on the classpath.
+        negoClassName = "org.eclipse.jetty.npn.NextProtoNego";
+        negoClass = Class.forName(negoClassName);
+      }
+      Class<?> providerClass = Class.forName(negoClassName + "$Provider");
+      Class<?> clientProviderClass = Class.forName(negoClassName + "$ClientProvider");
+      Class<?> serverProviderClass = Class.forName(negoClassName + "$ServerProvider");
+      Method putMethod = negoClass.getMethod("put", SSLSocket.class, providerClass);
+      Method getMethod = negoClass.getMethod("get", SSLSocket.class);
+      return new JdkWithJettyBootPlatform(
           putMethod, getMethod, clientProviderClass, serverProviderClass);
-    } catch (ClassNotFoundException ignored) {
-      // NPN isn't on the classpath.
-    } catch (NoSuchMethodException ignored) {
-      // The NPN version isn't what we expect.
+    } catch (ClassNotFoundException ignored) { // NPN isn't on the classpath.
+    } catch (NoSuchMethodException ignored) { // The ALPN or NPN version isn't what we expect.
     }
 
     return new Platform();
@@ -221,25 +194,24 @@ private static Platform findPlatform() {
     private final Method setUseSessionTickets;
     private final Method setHostname;
 
+    // Non-null on Android 4.0+.
+    private final Method trafficStatsTagSocket;
+    private final Method trafficStatsUntagSocket;
+
     // Non-null on Android 4.1+.
     private final Method setNpnProtocols;
     private final Method getNpnSelectedProtocol;
 
-    // Non-null on Android 4.4+.
-    private final Method setAlpnProtocols;
-    private final Method getAlpnSelectedProtocol;
-
-    private Android(
-        Class<?> openSslSocketClass, Method setUseSessionTickets, Method setHostname,
-        Method setNpnProtocols, Method getNpnSelectedProtocol, Method setAlpnProtocols,
-        Method getAlpnSelectedProtocol) {
+    private Android(Class<?> openSslSocketClass, Method setUseSessionTickets, Method setHostname,
+        Method trafficStatsTagSocket, Method trafficStatsUntagSocket, Method setNpnProtocols,
+        Method getNpnSelectedProtocol) {
       this.openSslSocketClass = openSslSocketClass;
       this.setUseSessionTickets = setUseSessionTickets;
       this.setHostname = setHostname;
+      this.trafficStatsTagSocket = trafficStatsTagSocket;
+      this.trafficStatsUntagSocket = trafficStatsUntagSocket;
       this.setNpnProtocols = setNpnProtocols;
       this.getNpnSelectedProtocol = getNpnSelectedProtocol;
-      this.setAlpnProtocols = setAlpnProtocols;
-      this.getAlpnSelectedProtocol = getAlpnSelectedProtocol;
     }
 
     @Override public void connectSocket(Socket socket, InetSocketAddress address,
@@ -255,27 +227,26 @@ private Android(
       }
     }
 
-    @Override public void enableTlsExtensions(SSLSocket socket, String uriHost) {
-      super.enableTlsExtensions(socket, uriHost);
-      if (!openSslSocketClass.isInstance(socket)) return;
-      try {
-        setUseSessionTickets.invoke(socket, true);
-        setHostname.invoke(socket, uriHost);
-      } catch (InvocationTargetException e) {
-        throw new RuntimeException(e);
-      } catch (IllegalAccessException e) {
-        throw new AssertionError(e);
+    @Override public void configureTls(SSLSocket socket, String uriHost, String tlsVersion) {
+      super.configureTls(socket, uriHost, tlsVersion);
+
+      if (tlsVersion.equals("TLSv1") && openSslSocketClass.isInstance(socket)) {
+        try {
+          setUseSessionTickets.invoke(socket, true);
+          setHostname.invoke(socket, uriHost);
+        } catch (InvocationTargetException e) {
+          throw new RuntimeException(e);
+        } catch (IllegalAccessException e) {
+          throw new AssertionError(e);
+        }
       }
     }
 
-    @Override public void setNpnProtocols(SSLSocket socket, List<Protocol> npnProtocols) {
+    @Override public void setProtocols(SSLSocket socket, List<Protocol> protocols) {
       if (setNpnProtocols == null) return;
       if (!openSslSocketClass.isInstance(socket)) return;
       try {
-        Object[] parameters = { concatLengthPrefixed(npnProtocols) };
-        if (setAlpnProtocols != null) {
-          setAlpnProtocols.invoke(socket, parameters);
-        }
+        Object[] parameters = { concatLengthPrefixed(protocols) };
         setNpnProtocols.invoke(socket, parameters);
       } catch (IllegalAccessException e) {
         throw new AssertionError(e);
@@ -284,49 +255,73 @@ private Android(
       }
     }
 
-    @Override public ByteString getNpnSelectedProtocol(SSLSocket socket) {
+    @Override public String getSelectedProtocol(SSLSocket socket) {
       if (getNpnSelectedProtocol == null) return null;
       if (!openSslSocketClass.isInstance(socket)) return null;
       try {
-        if (getAlpnSelectedProtocol != null) {
-          // Prefer ALPN's result if it is present.
-          byte[] alpnResult = (byte[]) getAlpnSelectedProtocol.invoke(socket);
-          if (alpnResult != null) return ByteString.of(alpnResult);
-        }
         byte[] npnResult = (byte[]) getNpnSelectedProtocol.invoke(socket);
         if (npnResult == null) return null;
-        return ByteString.of(npnResult);
+        return new String(npnResult, Util.UTF_8);
       } catch (InvocationTargetException e) {
         throw new RuntimeException(e);
       } catch (IllegalAccessException e) {
         throw new AssertionError(e);
       }
     }
+
+    @Override public void tagSocket(Socket socket) throws SocketException {
+      if (trafficStatsTagSocket == null) return;
+
+      try {
+        trafficStatsTagSocket.invoke(null, socket);
+      } catch (IllegalAccessException e) {
+        throw new RuntimeException(e);
+      } catch (InvocationTargetException e) {
+        throw new RuntimeException(e);
+      }
+    }
+
+    @Override public void untagSocket(Socket socket) throws SocketException {
+      if (trafficStatsUntagSocket == null) return;
+
+      try {
+        trafficStatsUntagSocket.invoke(null, socket);
+      } catch (IllegalAccessException e) {
+        throw new RuntimeException(e);
+      } catch (InvocationTargetException e) {
+        throw new RuntimeException(e);
+      }
+    }
   }
 
-  /** OpenJDK 7 plus {@code org.mortbay.jetty.npn/npn-boot} on the boot class path. */
-  private static class JdkWithJettyNpnPlatform extends Platform {
+  /**
+   * OpenJDK 7+ with {@code org.mortbay.jetty.npn/npn-boot} or
+   * {@code org.mortbay.jetty.alpn/alpn-boot} in the boot class path.
+   */
+  private static class JdkWithJettyBootPlatform extends Platform {
     private final Method getMethod;
     private final Method putMethod;
     private final Class<?> clientProviderClass;
     private final Class<?> serverProviderClass;
 
-    public JdkWithJettyNpnPlatform(Method putMethod, Method getMethod, Class<?> clientProviderClass,
-        Class<?> serverProviderClass) {
+    public JdkWithJettyBootPlatform(Method putMethod, Method getMethod,
+        Class<?> clientProviderClass, Class<?> serverProviderClass) {
       this.putMethod = putMethod;
       this.getMethod = getMethod;
       this.clientProviderClass = clientProviderClass;
       this.serverProviderClass = serverProviderClass;
     }
 
-    @Override public void setNpnProtocols(SSLSocket socket, List<Protocol> npnProtocols) {
+    @Override public void setProtocols(SSLSocket socket, List<Protocol> protocols) {
       try {
-        List<String> names = new ArrayList<String>(npnProtocols.size());
-        for (int i = 0, size = npnProtocols.size(); i < size; i++) {
-          names.add(npnProtocols.get(i).name.utf8());
+        List<String> names = new ArrayList<>(protocols.size());
+        for (int i = 0, size = protocols.size(); i < size; i++) {
+          Protocol protocol = protocols.get(i);
+          if (protocol == Protocol.HTTP_1_0) continue; // No HTTP/1.0 for NPN or ALPN.
+          names.add(protocol.toString());
         }
         Object provider = Proxy.newProxyInstance(Platform.class.getClassLoader(),
-            new Class[] { clientProviderClass, serverProviderClass }, new JettyNpnProvider(names));
+            new Class[] { clientProviderClass, serverProviderClass }, new JettyNegoProvider(names));
         putMethod.invoke(null, socket, provider);
       } catch (InvocationTargetException e) {
         throw new AssertionError(e);
@@ -335,17 +330,17 @@ public JdkWithJettyNpnPlatform(Method putMethod, Method getMethod, Class<?> clie
       }
     }
 
-    @Override public ByteString getNpnSelectedProtocol(SSLSocket socket) {
+    @Override public String getSelectedProtocol(SSLSocket socket) {
       try {
-        JettyNpnProvider provider =
-            (JettyNpnProvider) Proxy.getInvocationHandler(getMethod.invoke(null, socket));
+        JettyNegoProvider provider =
+            (JettyNegoProvider) Proxy.getInvocationHandler(getMethod.invoke(null, socket));
         if (!provider.unsupported && provider.selected == null) {
           Logger logger = Logger.getLogger("com.squareup.okhttp.OkHttpClient");
-          logger.log(Level.INFO,
-              "NPN callback dropped so SPDY is disabled. Is npn-boot on the boot class path?");
+          logger.log(Level.INFO, "NPN/ALPN callback dropped: SPDY and HTTP/2 are disabled. "
+                  + "Is npn-boot or alpn-boot on the boot class path?");
           return null;
         }
-        return provider.unsupported ? null : ByteString.encodeUtf8(provider.selected);
+        return provider.unsupported ? null : provider.selected;
       } catch (InvocationTargetException e) {
         throw new AssertionError();
       } catch (IllegalAccessException e) {
@@ -355,18 +350,18 @@ public JdkWithJettyNpnPlatform(Method putMethod, Method getMethod, Class<?> clie
   }
 
   /**
-   * Handle the methods of NextProtoNego's ClientProvider and ServerProvider
+   * Handle the methods of NPN or ALPN's ClientProvider and ServerProvider
    * without a compile-time dependency on those interfaces.
    */
-  private static class JettyNpnProvider implements InvocationHandler {
+  private static class JettyNegoProvider implements InvocationHandler {
     /** This peer's supported protocols. */
     private final List<String> protocols;
-    /** Set when remote peer notifies NPN is unsupported. */
+    /** Set when remote peer notifies NPN or ALPN is unsupported. */
     private boolean unsupported;
-    /** The protocol the client selected. */
+    /** The protocol the client (NPN) or server (ALPN) selected. */
     private String selected;
 
-    public JettyNpnProvider(List<String> protocols) {
+    public JettyNegoProvider(List<String> protocols) {
       this.protocols = protocols;
     }
 
@@ -377,27 +372,25 @@ public JettyNpnProvider(List<String> protocols) {
         args = Util.EMPTY_STRING_ARRAY;
       }
       if (methodName.equals("supports") && boolean.class == returnType) {
-        return true; // Client supports NPN.
+        return true; // NPN or ALPN is supported.
       } else if (methodName.equals("unsupported") && void.class == returnType) {
-        this.unsupported = true; // Remote peer doesn't support NPN.
+        this.unsupported = true; // Peer doesn't support NPN or ALPN.
         return null;
       } else if (methodName.equals("protocols") && args.length == 0) {
-        return protocols; // Server advertises these protocols.
-      } else if (methodName.equals("selectProtocol") // Called when client.
-          && String.class == returnType
-          && args.length == 1
-          && (args[0] == null || args[0] instanceof List)) {
-        List<String> serverProtocols = (List) args[0];
-        // Pick the first protocol the server advertises and client knows.
-        for (int i = 0, size = serverProtocols.size(); i < size; i++) {
-          if (protocols.contains(serverProtocols.get(i))) {
-            return selected = serverProtocols.get(i);
+        return protocols; // Server (NPN) or Client (ALPN) advertises these protocols.
+      } else if ((methodName.equals("selectProtocol") || methodName.equals("select"))
+          && String.class == returnType && args.length == 1 && args[0] instanceof List) {
+        List<String> peerProtocols = (List) args[0];
+        // Pick the first known protocol the peer advertises.
+        for (int i = 0, size = peerProtocols.size(); i < size; i++) {
+          if (protocols.contains(peerProtocols.get(i))) {
+            return selected = peerProtocols.get(i);
           }
         }
-        // On no intersection, try client's first protocol.
-        return selected = protocols.get(0);
-      } else if (methodName.equals("protocolSelected") && args.length == 1) {
-        this.selected = (String) args[0]; // Client selected this protocol.
+        return selected = protocols.get(0); // On no intersection, try peer's first protocol.
+      } else if ((methodName.equals("protocolSelected") || methodName.equals("selected"))
+          && args.length == 1) {
+        this.selected = (String) args[0]; // Client (NPN) or Server (ALPN) selected this protocol.
         return null;
       } else {
         return method.invoke(this, args);
@@ -406,24 +399,17 @@ public JettyNpnProvider(List<String> protocols) {
   }
 
   /**
-   * Concatenation of 8-bit, length prefixed protocol names.
-   *
+   * Returns the concatenation of 8-bit, length prefixed protocol names.
    * http://tools.ietf.org/html/draft-agl-tls-nextprotoneg-04#page-4
    */
   static byte[] concatLengthPrefixed(List<Protocol> protocols) {
-    int size = 0;
-    for (Protocol protocol : protocols) {
-      size += protocol.name.size() + 1; // add a byte for 8-bit length prefix.
-    }
-    byte[] result = new byte[size];
-    int pos = 0;
-    for (Protocol protocol : protocols) {
-      int nameSize = protocol.name.size();
-      result[pos++] = (byte) nameSize;
-      // toByteArray allocates an array, but this is only called on new connections.
-      System.arraycopy(protocol.name.toByteArray(), 0, result, pos, nameSize);
-      pos += nameSize;
+    Buffer result = new Buffer();
+    for (int i = 0, size = protocols.size(); i < size; i++) {
+      Protocol protocol = protocols.get(i);
+      if (protocol == Protocol.HTTP_1_0) continue; // No HTTP/1.0 for NPN.
+      result.writeByte(protocol.toString().length());
+      result.writeUtf8(protocol.toString());
     }
-    return result;
+    return result.readByteArray();
   }
 }
diff --git a/okhttp/src/main/java/com/squareup/okhttp/RouteDatabase.java b/okhttp/src/main/java/com/squareup/okhttp/internal/RouteDatabase.java
similarity index 92%
rename from okhttp/src/main/java/com/squareup/okhttp/RouteDatabase.java
rename to okhttp/src/main/java/com/squareup/okhttp/internal/RouteDatabase.java
index 4177c0fb1b..52c211eb54 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/RouteDatabase.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/RouteDatabase.java
@@ -13,8 +13,9 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.squareup.okhttp;
+package com.squareup.okhttp.internal;
 
+import com.squareup.okhttp.Route;
 import java.util.LinkedHashSet;
 import java.util.Set;
 
@@ -26,7 +27,7 @@
  * preferred.
  */
 public final class RouteDatabase {
-  private final Set<Route> failedRoutes = new LinkedHashSet<Route>();
+  private final Set<Route> failedRoutes = new LinkedHashSet<>();
 
   /** Records a failure connecting to {@code failedRoute}. */
   public synchronized void failed(Route failedRoute) {
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/Util.java b/okhttp/src/main/java/com/squareup/okhttp/internal/Util.java
index 51e04e845c..64857d35fa 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/Util.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/Util.java
@@ -16,14 +16,11 @@
 
 package com.squareup.okhttp.internal;
 
+import com.squareup.okhttp.internal.http.RetryableSink;
 import com.squareup.okhttp.internal.spdy.Header;
-import java.io.ByteArrayInputStream;
 import java.io.Closeable;
-import java.io.EOFException;
 import java.io.File;
 import java.io.IOException;
-import java.io.InputStream;
-import java.io.OutputStream;
 import java.io.UnsupportedEncodingException;
 import java.net.ServerSocket;
 import java.net.Socket;
@@ -37,8 +34,8 @@
 import java.util.Collections;
 import java.util.List;
 import java.util.concurrent.ThreadFactory;
+import okio.Buffer;
 import okio.ByteString;
-import okio.OkBuffer;
 import okio.Source;
 
 import static java.util.concurrent.TimeUnit.NANOSECONDS;
@@ -47,7 +44,6 @@
 public final class Util {
   public static final byte[] EMPTY_BYTE_ARRAY = new byte[0];
   public static final String[] EMPTY_STRING_ARRAY = new String[0];
-  public static final InputStream EMPTY_INPUT_STREAM = new ByteArrayInputStream(EMPTY_BYTE_ARRAY);
 
   /** A cheap and type-safe constant for the US-ASCII Charset. */
   public static final Charset US_ASCII = Charset.forName("US-ASCII");
@@ -174,55 +170,11 @@ public static void deleteContents(File dir) throws IOException {
     }
   }
 
-  /**
-   * Fills 'dst' with bytes from 'in', throwing EOFException if insufficient bytes are available.
-   */
-  public static void readFully(InputStream in, byte[] dst) throws IOException {
-    readFully(in, dst, 0, dst.length);
-  }
-
-  /**
-   * Reads exactly 'byteCount' bytes from 'in' (into 'dst' at offset 'offset'), and throws
-   * EOFException if insufficient bytes are available.
-   *
-   * Used to implement {@link java.io.DataInputStream#readFully(byte[], int, int)}.
-   */
-  public static void readFully(InputStream in, byte[] dst, int offset, int byteCount)
-      throws IOException {
-    if (byteCount == 0) {
-      return;
-    }
-    if (in == null) {
-      throw new NullPointerException("in == null");
-    }
-    if (dst == null) {
-      throw new NullPointerException("dst == null");
-    }
-    checkOffsetAndCount(dst.length, offset, byteCount);
-    while (byteCount > 0) {
-      int bytesRead = in.read(dst, offset, byteCount);
-      if (bytesRead < 0) {
-        throw new EOFException();
-      }
-      offset += bytesRead;
-      byteCount -= bytesRead;
-    }
-  }
-
-  /** Returns the remainder of 'source' as a buffer, closing it when done. */
-  public static OkBuffer readFully(Source source) throws IOException {
-    OkBuffer result = new OkBuffer();
-    while (source.read(result, 2048) != -1) {
-    }
-    source.close();
-    return result;
-  }
-
   /** Reads until {@code in} is exhausted or the timeout has elapsed. */
   public static boolean skipAll(Source in, int timeoutMillis) throws IOException {
     // TODO: Implement deadlines everywhere so they can do this work.
     long startNanos = System.nanoTime();
-    OkBuffer skipBuffer = new OkBuffer();
+    Buffer skipBuffer = new Buffer();
     while (NANOSECONDS.toMillis(System.nanoTime() - startNanos) < timeoutMillis) {
       long read = in.read(skipBuffer, 2048);
       if (read == -1) return true; // Successfully exhausted the stream.
@@ -231,21 +183,6 @@ public static boolean skipAll(Source in, int timeoutMillis) throws IOException {
     return false; // Ran out of time.
   }
 
-  /**
-   * Copies all of the bytes from {@code in} to {@code out}. Neither stream is closed.
-   * Returns the total number of bytes transferred.
-   */
-  public static int copy(InputStream in, OutputStream out) throws IOException {
-    int total = 0;
-    byte[] buffer = new byte[8192];
-    int c;
-    while ((c = in.read(buffer)) != -1) {
-      total += c;
-      out.write(buffer, 0, c);
-    }
-    return total;
-  }
-
   /** Returns a 32 character string containing a hash of {@code s}. */
   public static String hash(String s) {
     try {
@@ -261,7 +198,7 @@ public static String hash(String s) {
 
   /** Returns an immutable copy of {@code list}. */
   public static <T> List<T> immutableList(List<T> list) {
-    return Collections.unmodifiableList(new ArrayList<T>(list));
+    return Collections.unmodifiableList(new ArrayList<>(list));
   }
 
   /** Returns an immutable list containing {@code elements}. */
@@ -280,10 +217,16 @@ public static ThreadFactory threadFactory(final String name, final boolean daemo
   }
 
   public static List<Header> headerEntries(String... elements) {
-    List<Header> result = new ArrayList<Header>(elements.length / 2);
+    List<Header> result = new ArrayList<>(elements.length / 2);
     for (int i = 0; i < elements.length; i += 2) {
       result.add(new Header(elements[i], elements[i + 1]));
     }
     return result;
   }
+
+  public static RetryableSink emptySink() {
+    return EMPTY_SINK;
+  }
+
+  private static final RetryableSink EMPTY_SINK = new RetryableSink(0);
 }
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/http/AuthenticatorAdapter.java b/okhttp/src/main/java/com/squareup/okhttp/internal/http/AuthenticatorAdapter.java
new file mode 100644
index 0000000000..a517ada7cc
--- /dev/null
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/http/AuthenticatorAdapter.java
@@ -0,0 +1,87 @@
+/*
+ * Copyright (C) 2013 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.okhttp.internal.http;
+
+import com.squareup.okhttp.Authenticator;
+import com.squareup.okhttp.Challenge;
+import com.squareup.okhttp.Credentials;
+import com.squareup.okhttp.Request;
+import com.squareup.okhttp.Response;
+import java.io.IOException;
+import java.net.Authenticator.RequestorType;
+import java.net.InetAddress;
+import java.net.InetSocketAddress;
+import java.net.PasswordAuthentication;
+import java.net.Proxy;
+import java.net.URL;
+import java.util.List;
+
+/** Adapts {@link java.net.Authenticator} to {@link com.squareup.okhttp.Authenticator}. */
+public final class AuthenticatorAdapter implements Authenticator {
+  /** Uses the global authenticator to get the password. */
+  public static final Authenticator INSTANCE = new AuthenticatorAdapter();
+
+  @Override public Request authenticate(Proxy proxy, Response response) throws IOException {
+    List<Challenge> challenges = response.challenges();
+    Request request = response.request();
+    URL url = request.url();
+    for (int i = 0, size = challenges.size(); i < size; i++) {
+      Challenge challenge = challenges.get(i);
+      if (!"Basic".equalsIgnoreCase(challenge.getScheme())) continue;
+
+      PasswordAuthentication auth = java.net.Authenticator.requestPasswordAuthentication(
+          url.getHost(), getConnectToInetAddress(proxy, url), url.getPort(), url.getProtocol(),
+          challenge.getRealm(), challenge.getScheme(), url, RequestorType.SERVER);
+      if (auth == null) continue;
+
+      String credential = Credentials.basic(auth.getUserName(), new String(auth.getPassword()));
+      return request.newBuilder()
+          .header("Authorization", credential)
+          .build();
+    }
+    return null;
+
+  }
+
+  @Override public Request authenticateProxy(Proxy proxy, Response response) throws IOException {
+    List<Challenge> challenges = response.challenges();
+    Request request = response.request();
+    URL url = request.url();
+    for (int i = 0, size = challenges.size(); i < size; i++) {
+      Challenge challenge = challenges.get(i);
+      if (!"Basic".equalsIgnoreCase(challenge.getScheme())) continue;
+
+      InetSocketAddress proxyAddress = (InetSocketAddress) proxy.address();
+      PasswordAuthentication auth = java.net.Authenticator.requestPasswordAuthentication(
+          proxyAddress.getHostName(), getConnectToInetAddress(proxy, url), proxyAddress.getPort(),
+          url.getProtocol(), challenge.getRealm(), challenge.getScheme(), url,
+          RequestorType.PROXY);
+      if (auth == null) continue;
+
+      String credential = Credentials.basic(auth.getUserName(), new String(auth.getPassword()));
+      return request.newBuilder()
+          .header("Proxy-Authorization", credential)
+          .build();
+    }
+    return null;
+  }
+
+  private InetAddress getConnectToInetAddress(Proxy proxy, URL url) throws IOException {
+    return (proxy != null && proxy.type() != Proxy.Type.DIRECT)
+        ? ((InetSocketAddress) proxy.address()).getAddress()
+        : InetAddress.getByName(url.getHost());
+  }
+}
diff --git a/okio/src/test/java/okio/OkBufferReadUtf8LineTest.java b/okhttp/src/main/java/com/squareup/okhttp/internal/http/CacheRequest.java
similarity index 76%
rename from okio/src/test/java/okio/OkBufferReadUtf8LineTest.java
rename to okhttp/src/main/java/com/squareup/okhttp/internal/http/CacheRequest.java
index ac3de728e8..b8153e4f07 100644
--- a/okio/src/test/java/okio/OkBufferReadUtf8LineTest.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/http/CacheRequest.java
@@ -13,10 +13,12 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package okio;
+package com.squareup.okhttp.internal.http;
 
-public final class OkBufferReadUtf8LineTest extends ReadUtf8LineTest {
-  @Override protected BufferedSource newSource(String s) {
-    return new OkBuffer().writeUtf8(s);
-  }
+import java.io.IOException;
+import okio.Sink;
+
+public interface CacheRequest {
+  Sink body() throws IOException;
+  void abort();
 }
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/http/CacheStrategy.java b/okhttp/src/main/java/com/squareup/okhttp/internal/http/CacheStrategy.java
index 7cc7e211df..ddf1b38ce1 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/http/CacheStrategy.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/http/CacheStrategy.java
@@ -1,16 +1,11 @@
 package com.squareup.okhttp.internal.http;
 
 import com.squareup.okhttp.CacheControl;
-import com.squareup.okhttp.MediaType;
 import com.squareup.okhttp.Request;
 import com.squareup.okhttp.Response;
-import com.squareup.okhttp.ResponseSource;
-import java.io.IOException;
-import java.io.InputStream;
 import java.net.HttpURLConnection;
 import java.util.Date;
 
-import static com.squareup.okhttp.internal.Util.EMPTY_INPUT_STREAM;
 import static java.util.concurrent.TimeUnit.SECONDS;
 
 /**
@@ -22,43 +17,19 @@
  * response (if the cached data is potentially stale).
  */
 public final class CacheStrategy {
-  private static final Response.Body EMPTY_BODY = new Response.Body() {
-    @Override public boolean ready() throws IOException {
-      return true;
-    }
-    @Override public MediaType contentType() {
-      return null;
-    }
-    @Override public long contentLength() {
-      return 0;
-    }
-    @Override public InputStream byteStream() {
-      return EMPTY_INPUT_STREAM;
-    }
-  };
-
-  private static final StatusLine GATEWAY_TIMEOUT_STATUS_LINE;
-  static {
-    try {
-      GATEWAY_TIMEOUT_STATUS_LINE = new StatusLine("HTTP/1.1 504 Gateway Timeout");
-    } catch (IOException e) {
-      throw new AssertionError();
-    }
-  }
+  /** The request to send on the network, or null if this call doesn't use the network. */
+  public final Request networkRequest;
 
-  public final Request request;
-  public final Response response;
-  public final ResponseSource source;
+  /** The cached response to return or validate; or null if this call doesn't use a cache. */
+  public final Response cacheResponse;
 
-  private CacheStrategy(
-      Request request, Response response, ResponseSource source) {
-    this.request = request;
-    this.response = response;
-    this.source = source;
+  private CacheStrategy(Request networkRequest, Response cacheResponse) {
+    this.networkRequest = networkRequest;
+    this.cacheResponse = cacheResponse;
   }
 
   /**
-   * Returns true if this response can be stored to later serve another
+   * Returns true if {@code response} can be stored to later serve another
    * request.
    */
   public static boolean isCacheable(Response response, Request request) {
@@ -164,15 +135,9 @@ public Factory(long nowMillis, Request request, Response cacheResponse) {
     public CacheStrategy get() {
       CacheStrategy candidate = getCandidate();
 
-      if (candidate.source != ResponseSource.CACHE && request.cacheControl().onlyIfCached()) {
-        // We're forbidden from using the network, but the cache is insufficient.
-        Response noneResponse = new Response.Builder()
-            .request(candidate.request)
-            .statusLine(GATEWAY_TIMEOUT_STATUS_LINE)
-            .setResponseSource(ResponseSource.NONE)
-            .body(EMPTY_BODY)
-            .build();
-        return new CacheStrategy(candidate.request, noneResponse, ResponseSource.NONE);
+      if (candidate.networkRequest != null && request.cacheControl().onlyIfCached()) {
+        // We're forbidden from using the network and the cache is insufficient.
+        return new CacheStrategy(null, null);
       }
 
       return candidate;
@@ -182,24 +147,24 @@ public CacheStrategy get() {
     private CacheStrategy getCandidate() {
       // No cached response.
       if (cacheResponse == null) {
-        return new CacheStrategy(request, cacheResponse, ResponseSource.NETWORK);
+        return new CacheStrategy(request, null);
       }
 
       // Drop the cached response if it's missing a required handshake.
       if (request.isHttps() && cacheResponse.handshake() == null) {
-        return new CacheStrategy(request, cacheResponse, ResponseSource.NETWORK);
+        return new CacheStrategy(request, null);
       }
 
       // If this response shouldn't have been stored, it should never be used
       // as a response source. This check should be redundant as long as the
       // persistence store is well-behaved and the rules are constant.
       if (!isCacheable(cacheResponse, request)) {
-        return new CacheStrategy(request, cacheResponse, ResponseSource.NETWORK);
+        return new CacheStrategy(request, null);
       }
 
       CacheControl requestCaching = request.cacheControl();
       if (requestCaching.noCache() || hasConditions(request)) {
-        return new CacheStrategy(request, cacheResponse, ResponseSource.NETWORK);
+        return new CacheStrategy(request, null);
       }
 
       long ageMillis = cacheResponseAge();
@@ -221,8 +186,7 @@ private CacheStrategy getCandidate() {
       }
 
       if (!responseCaching.noCache() && ageMillis + minFreshMillis < freshMillis + maxStaleMillis) {
-        Response.Builder builder = cacheResponse.newBuilder()
-            .setResponseSource(ResponseSource.CACHE); // Overwrite any stored response source.
+        Response.Builder builder = cacheResponse.newBuilder();
         if (ageMillis + minFreshMillis >= freshMillis) {
           builder.addHeader("Warning", "110 HttpURLConnection \"Response is stale\"");
         }
@@ -230,7 +194,7 @@ private CacheStrategy getCandidate() {
         if (ageMillis > oneDayMillis && isFreshnessLifetimeHeuristic()) {
           builder.addHeader("Warning", "113 HttpURLConnection \"Heuristic expiration\"");
         }
-        return new CacheStrategy(request, builder.build(), ResponseSource.CACHE);
+        return new CacheStrategy(null, builder.build());
       }
 
       Request.Builder conditionalRequestBuilder = request.newBuilder();
@@ -246,10 +210,9 @@ private CacheStrategy getCandidate() {
       }
 
       Request conditionalRequest = conditionalRequestBuilder.build();
-      ResponseSource responseSource = hasConditions(conditionalRequest)
-          ? ResponseSource.CONDITIONAL_CACHE
-          : ResponseSource.NETWORK;
-      return new CacheStrategy(conditionalRequest, cacheResponse, responseSource);
+      return hasConditions(conditionalRequest)
+          ? new CacheStrategy(conditionalRequest, cacheResponse)
+          : new CacheStrategy(conditionalRequest, null);
     }
 
     /**
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpAuthenticator.java b/okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpAuthenticator.java
deleted file mode 100644
index ce40a92c27..0000000000
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpAuthenticator.java
+++ /dev/null
@@ -1,167 +0,0 @@
-/*
- * Copyright (C) 2012 Square, Inc.
- * Copyright (C) 2011 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.squareup.okhttp.internal.http;
-
-import com.squareup.okhttp.Headers;
-import com.squareup.okhttp.OkAuthenticator;
-import com.squareup.okhttp.OkAuthenticator.Challenge;
-import com.squareup.okhttp.Request;
-import com.squareup.okhttp.Response;
-import java.io.IOException;
-import java.net.Authenticator;
-import java.net.InetAddress;
-import java.net.InetSocketAddress;
-import java.net.PasswordAuthentication;
-import java.net.Proxy;
-import java.net.URL;
-import java.util.ArrayList;
-import java.util.List;
-
-import static com.squareup.okhttp.OkAuthenticator.Credential;
-import static java.net.HttpURLConnection.HTTP_PROXY_AUTH;
-import static java.net.HttpURLConnection.HTTP_UNAUTHORIZED;
-
-/** Handles HTTP authentication headers from origin and proxy servers. */
-public final class HttpAuthenticator {
-  /** Uses the global authenticator to get the password. */
-  public static final OkAuthenticator SYSTEM_DEFAULT = new OkAuthenticator() {
-    @Override public Credential authenticate(
-        Proxy proxy, URL url, List<Challenge> challenges) throws IOException {
-      for (int i = 0, size = challenges.size(); i < size; i++) {
-        Challenge challenge = challenges.get(i);
-        if (!"Basic".equalsIgnoreCase(challenge.getScheme())) {
-          continue;
-        }
-
-        PasswordAuthentication auth = Authenticator.requestPasswordAuthentication(url.getHost(),
-            getConnectToInetAddress(proxy, url), url.getPort(), url.getProtocol(),
-            challenge.getRealm(), challenge.getScheme(), url, Authenticator.RequestorType.SERVER);
-        if (auth != null) {
-          return Credential.basic(auth.getUserName(), new String(auth.getPassword()));
-        }
-      }
-      return null;
-    }
-
-    @Override public Credential authenticateProxy(
-        Proxy proxy, URL url, List<Challenge> challenges) throws IOException {
-      for (int i = 0, size = challenges.size(); i < size; i++) {
-        Challenge challenge = challenges.get(i);
-        if (!"Basic".equalsIgnoreCase(challenge.getScheme())) {
-          continue;
-        }
-
-        InetSocketAddress proxyAddress = (InetSocketAddress) proxy.address();
-        PasswordAuthentication auth = Authenticator.requestPasswordAuthentication(
-            proxyAddress.getHostName(), getConnectToInetAddress(proxy, url), proxyAddress.getPort(),
-            url.getProtocol(), challenge.getRealm(), challenge.getScheme(), url,
-            Authenticator.RequestorType.PROXY);
-        if (auth != null) {
-          return Credential.basic(auth.getUserName(), new String(auth.getPassword()));
-        }
-      }
-      return null;
-    }
-
-    private InetAddress getConnectToInetAddress(Proxy proxy, URL url) throws IOException {
-      return (proxy != null && proxy.type() != Proxy.Type.DIRECT)
-          ? ((InetSocketAddress) proxy.address()).getAddress()
-          : InetAddress.getByName(url.getHost());
-    }
-  };
-
-  private HttpAuthenticator() {
-  }
-
-  /**
-   * React to a failed authorization response by looking up new credentials.
-   * Returns a request for a subsequent attempt, or null if no further attempts
-   * should be made.
-   */
-  public static Request processAuthHeader(
-      OkAuthenticator authenticator, Response response, Proxy proxy) throws IOException {
-    String responseField;
-    String requestField;
-    if (response.code() == HTTP_UNAUTHORIZED) {
-      responseField = "WWW-Authenticate";
-      requestField = "Authorization";
-    } else if (response.code() == HTTP_PROXY_AUTH) {
-      responseField = "Proxy-Authenticate";
-      requestField = "Proxy-Authorization";
-    } else {
-      throw new IllegalArgumentException(); // TODO: ProtocolException?
-    }
-    List<Challenge> challenges = parseChallenges(response.headers(), responseField);
-    if (challenges.isEmpty()) return null; // Could not find a challenge so end the request cycle.
-
-    Request request = response.request();
-    Credential credential = response.code() == HTTP_PROXY_AUTH
-        ? authenticator.authenticateProxy(proxy, request.url(), challenges)
-        : authenticator.authenticate(proxy, request.url(), challenges);
-    if (credential == null) return null; // Couldn't satisfy the challenge so end the request cycle.
-
-    // Add authorization credentials, bypassing the already-connected check.
-    return request.newBuilder().header(requestField, credential.getHeaderValue()).build();
-  }
-
-  /**
-   * Parse RFC 2617 challenges. This API is only interested in the scheme
-   * name and realm.
-   */
-  private static List<Challenge> parseChallenges(Headers responseHeaders,
-      String challengeHeader) {
-    // auth-scheme = token
-    // auth-param  = token "=" ( token | quoted-string )
-    // challenge   = auth-scheme 1*SP 1#auth-param
-    // realm       = "realm" "=" realm-value
-    // realm-value = quoted-string
-    List<Challenge> result = new ArrayList<Challenge>();
-    for (int h = 0; h < responseHeaders.size(); h++) {
-      if (!challengeHeader.equalsIgnoreCase(responseHeaders.name(h))) {
-        continue;
-      }
-      String value = responseHeaders.value(h);
-      int pos = 0;
-      while (pos < value.length()) {
-        int tokenStart = pos;
-        pos = HeaderParser.skipUntil(value, pos, " ");
-
-        String scheme = value.substring(tokenStart, pos).trim();
-        pos = HeaderParser.skipWhitespace(value, pos);
-
-        // TODO: This currently only handles schemes with a 'realm' parameter;
-        //       It needs to be fixed to handle any scheme and any parameters
-        //       http://code.google.com/p/android/issues/detail?id=11140
-
-        if (!value.regionMatches(true, pos, "realm=\"", 0, "realm=\"".length())) {
-          break; // Unexpected challenge parameter; give up!
-        }
-
-        pos += "realm=\"".length();
-        int realmStart = pos;
-        pos = HeaderParser.skipUntil(value, pos, "\"");
-        String realm = value.substring(realmStart, pos);
-        pos++; // Consume '"' close quote.
-        pos = HeaderParser.skipUntil(value, pos, ",");
-        pos++; // Consume ',' comma.
-        pos = HeaderParser.skipWhitespace(value, pos);
-        result.add(new Challenge(scheme, realm));
-      }
-    }
-    return result;
-  }
-}
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpConnection.java b/okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpConnection.java
index ea588f3649..b10dea0876 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpConnection.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpConnection.java
@@ -19,21 +19,21 @@
 import com.squareup.okhttp.Connection;
 import com.squareup.okhttp.ConnectionPool;
 import com.squareup.okhttp.Headers;
-import com.squareup.okhttp.Protocol;
 import com.squareup.okhttp.Response;
+import com.squareup.okhttp.internal.Internal;
 import com.squareup.okhttp.internal.Util;
 import java.io.IOException;
-import java.io.OutputStream;
-import java.net.CacheRequest;
 import java.net.ProtocolException;
 import java.net.Socket;
+import java.net.SocketTimeoutException;
+import java.util.concurrent.TimeUnit;
+import okio.Buffer;
 import okio.BufferedSink;
 import okio.BufferedSource;
-import okio.Deadline;
-import okio.OkBuffer;
 import okio.Okio;
 import okio.Sink;
 import okio.Source;
+import okio.Timeout;
 
 import static com.squareup.okhttp.internal.Util.checkOffsetAndCount;
 import static com.squareup.okhttp.internal.http.StatusLine.HTTP_CONTINUE;
@@ -72,18 +72,29 @@
 
   private final ConnectionPool pool;
   private final Connection connection;
+  private final Socket socket;
   private final BufferedSource source;
   private final BufferedSink sink;
 
   private int state = STATE_IDLE;
   private int onIdle = ON_IDLE_HOLD;
 
-  public HttpConnection(ConnectionPool pool, Connection connection, BufferedSource source,
-      BufferedSink sink) {
+  public HttpConnection(ConnectionPool pool, Connection connection, Socket socket)
+      throws IOException {
     this.pool = pool;
     this.connection = connection;
-    this.source = source;
-    this.sink = sink;
+    this.socket = socket;
+    this.source = Okio.buffer(Okio.source(socket));
+    this.sink = Okio.buffer(Okio.sink(socket));
+  }
+
+  public void setTimeouts(int readTimeoutMillis, int writeTimeoutMillis) {
+    if (readTimeoutMillis != 0) {
+      source.timeout().timeout(readTimeoutMillis, TimeUnit.MILLISECONDS);
+    }
+    if (writeTimeoutMillis != 0) {
+      sink.timeout().timeout(writeTimeoutMillis, TimeUnit.MILLISECONDS);
+    }
   }
 
   /**
@@ -96,7 +107,7 @@ public void poolOnIdle() {
     // If we're already idle, go to the pool immediately.
     if (state == STATE_IDLE) {
       onIdle = ON_IDLE_HOLD; // Set the on idle policy back to the default.
-      pool.recycle(connection);
+      Internal.instance.recycle(pool, connection);
     }
   }
 
@@ -110,7 +121,7 @@ public void closeOnIdle() throws IOException {
     // If we're already idle, close immediately.
     if (state == STATE_IDLE) {
       state = STATE_CLOSED;
-      connection.close();
+      connection.getSocket().close();
     }
   }
 
@@ -119,10 +130,39 @@ public boolean isClosed() {
     return state == STATE_CLOSED;
   }
 
+  public void closeIfOwnedBy(Object owner) throws IOException {
+    Internal.instance.closeIfOwnedBy(connection, owner);
+  }
+
   public void flush() throws IOException {
     sink.flush();
   }
 
+  /** Returns the number of buffered bytes immediately readable. */
+  public long bufferSize() {
+    return source.buffer().size();
+  }
+
+  /** Test for a stale socket. */
+  public boolean isReadable() {
+    try {
+      int readTimeout = socket.getSoTimeout();
+      try {
+        socket.setSoTimeout(1);
+        if (source.exhausted()) {
+          return false; // Stream is exhausted; socket is closed.
+        }
+        return true;
+      } finally {
+        socket.setSoTimeout(readTimeout);
+      }
+    } catch (SocketTimeoutException ignored) {
+      return true; // Read timed out; socket is good.
+    } catch (IOException e) {
+      return false; // Couldn't read; socket is closed.
+    }
+  }
+
   /** Returns bytes of a request header for sending on an HTTP transport. */
   public void writeRequest(Headers headers, String requestLine) throws IOException {
     if (state != STATE_IDLE) throw new IllegalStateException("state: " + state);
@@ -144,18 +184,19 @@ public void writeRequest(Headers headers, String requestLine) throws IOException
     }
 
     while (true) {
-      String statusLineString = source.readUtf8LineStrict();
-      StatusLine statusLine = new StatusLine(statusLineString);
+      StatusLine statusLine = StatusLine.parse(source.readUtf8LineStrict());
 
       Response.Builder responseBuilder = new Response.Builder()
-          .statusLine(statusLine)
-          .header(OkHeaders.SELECTED_PROTOCOL, Protocol.HTTP_11.name.utf8());
+          .protocol(statusLine.protocol)
+          .code(statusLine.code)
+          .message(statusLine.message);
 
       Headers.Builder headersBuilder = new Headers.Builder();
       readHeaders(headersBuilder);
+      headersBuilder.add(OkHeaders.SELECTED_PROTOCOL, statusLine.protocol.toString());
       responseBuilder.headers(headersBuilder.build());
 
-      if (statusLine.code() != HTTP_CONTINUE) {
+      if (statusLine.code != HTTP_CONTINUE) {
         state = STATE_OPEN_RESPONSE_BODY;
         return responseBuilder;
       }
@@ -166,7 +207,7 @@ public void writeRequest(Headers headers, String requestLine) throws IOException
   public void readHeaders(Headers.Builder builder) throws IOException {
     // parse the result headers until the first blank line
     for (String line; (line = source.readUtf8LineStrict()).length() != 0; ) {
-      builder.addLine(line);
+      Internal.instance.addLine(builder, line);
     }
   }
 
@@ -177,7 +218,6 @@ public void readHeaders(Headers.Builder builder) throws IOException {
    * that may never occur.
    */
   public boolean discard(Source in, int timeoutMillis) {
-    Socket socket = connection.getSocket();
     try {
       int socketTimeout = socket.getSoTimeout();
       socket.setSoTimeout(timeoutMillis);
@@ -246,11 +286,11 @@ private FixedLengthSink(long bytesRemaining) {
       this.bytesRemaining = bytesRemaining;
     }
 
-    @Override public Sink deadline(Deadline deadline) {
-      return this; // TODO: honor deadline.
+    @Override public Timeout timeout() {
+      return sink.timeout();
     }
 
-    @Override public void write(OkBuffer source, long byteCount) throws IOException {
+    @Override public void write(Buffer source, long byteCount) throws IOException {
       if (closed) throw new IllegalStateException("closed");
       checkOffsetAndCount(source.size(), 0, byteCount);
       if (byteCount > bytesRemaining) {
@@ -291,11 +331,11 @@ private FixedLengthSink(long bytesRemaining) {
 
     private boolean closed;
 
-    @Override public Sink deadline(Deadline deadline) {
-      return this; // TODO: honor deadline.
+    @Override public Timeout timeout() {
+      return sink.timeout();
     }
 
-    @Override public void write(OkBuffer source, long byteCount) throws IOException {
+    @Override public void write(Buffer source, long byteCount) throws IOException {
       if (closed) throw new IllegalStateException("closed");
       if (byteCount == 0) return;
 
@@ -331,12 +371,12 @@ private void writeHex(long i) throws IOException {
 
   private class AbstractSource {
     private final CacheRequest cacheRequest;
-    protected final OutputStream cacheBody;
+    protected final Sink cacheBody;
     protected boolean closed;
 
     AbstractSource(CacheRequest cacheRequest) throws IOException {
       // Some apps return a null body; for compatibility we treat that like a null cache request.
-      OutputStream cacheBody = cacheRequest != null ? cacheRequest.getBody() : null;
+      Sink cacheBody = cacheRequest != null ? cacheRequest.body() : null;
       if (cacheBody == null) {
         cacheRequest = null;
       }
@@ -346,9 +386,10 @@ private void writeHex(long i) throws IOException {
     }
 
     /** Copy the last {@code byteCount} bytes of {@code source} to the cache body. */
-    protected final void cacheWrite(OkBuffer source, long byteCount) throws IOException {
+    protected final void cacheWrite(Buffer source, long byteCount) throws IOException {
       if (cacheBody != null) {
-        Okio.copy(source, source.size() - byteCount, byteCount, cacheBody);
+        // TODO source.copyTo(cacheBody, byteCount);
+        cacheBody.write(source.clone(), byteCount);
       }
     }
 
@@ -356,7 +397,7 @@ protected final void cacheWrite(OkBuffer source, long byteCount) throws IOExcept
      * Closes the cache entry and makes the socket available for reuse. This
      * should be invoked when the end of the body has been reached.
      */
-    protected final void endOfInput() throws IOException {
+    protected final void endOfInput(boolean recyclable) throws IOException {
       if (state != STATE_READING_RESPONSE_BODY) throw new IllegalStateException("state: " + state);
 
       if (cacheRequest != null) {
@@ -364,12 +405,12 @@ protected final void endOfInput() throws IOException {
       }
 
       state = STATE_IDLE;
-      if (onIdle == ON_IDLE_POOL) {
+      if (recyclable && onIdle == ON_IDLE_POOL) {
         onIdle = ON_IDLE_HOLD; // Set the on idle policy back to the default.
-        pool.recycle(connection);
+        Internal.instance.recycle(pool, connection);
       } else if (onIdle == ON_IDLE_CLOSE) {
         state = STATE_CLOSED;
-        connection.close();
+        connection.getSocket().close();
       }
     }
 
@@ -389,7 +430,7 @@ protected final void unexpectedEndOfInput() {
       if (cacheRequest != null) {
         cacheRequest.abort();
       }
-      Util.closeQuietly(connection);
+      Util.closeQuietly(connection.getSocket());
       state = STATE_CLOSED;
     }
   }
@@ -402,11 +443,11 @@ public FixedLengthSource(CacheRequest cacheRequest, long length) throws IOExcept
       super(cacheRequest);
       bytesRemaining = length;
       if (bytesRemaining == 0) {
-        endOfInput();
+        endOfInput(true);
       }
     }
 
-    @Override public long read(OkBuffer sink, long byteCount)
+    @Override public long read(Buffer sink, long byteCount)
         throws IOException {
       if (byteCount < 0) throw new IllegalArgumentException("byteCount < 0: " + byteCount);
       if (closed) throw new IllegalStateException("closed");
@@ -421,14 +462,13 @@ public FixedLengthSource(CacheRequest cacheRequest, long length) throws IOExcept
       bytesRemaining -= read;
       cacheWrite(sink, read);
       if (bytesRemaining == 0) {
-        endOfInput();
+        endOfInput(true);
       }
       return read;
     }
 
-    @Override public Source deadline(Deadline deadline) {
-      source.deadline(deadline);
-      return this;
+    @Override public Timeout timeout() {
+      return source.timeout();
     }
 
     @Override public void close() throws IOException {
@@ -455,7 +495,7 @@ public FixedLengthSource(CacheRequest cacheRequest, long length) throws IOExcept
     }
 
     @Override public long read(
-        OkBuffer sink, long byteCount) throws IOException {
+        Buffer sink, long byteCount) throws IOException {
       if (byteCount < 0) throw new IllegalArgumentException("byteCount < 0: " + byteCount);
       if (closed) throw new IllegalStateException("closed");
       if (!hasMoreChunks) return -1;
@@ -495,13 +535,12 @@ private void readChunkSize() throws IOException {
         Headers.Builder trailersBuilder = new Headers.Builder();
         readHeaders(trailersBuilder);
         httpEngine.receiveHeaders(trailersBuilder.build());
-        endOfInput();
+        endOfInput(true);
       }
     }
 
-    @Override public Source deadline(Deadline deadline) {
-      source.deadline(deadline);
-      return this;
+    @Override public Timeout timeout() {
+      return source.timeout();
     }
 
     @Override public void close() throws IOException {
@@ -521,7 +560,7 @@ private void readChunkSize() throws IOException {
       super(cacheRequest);
     }
 
-    @Override public long read(OkBuffer sink, long byteCount)
+    @Override public long read(Buffer sink, long byteCount)
         throws IOException {
       if (byteCount < 0) throw new IllegalArgumentException("byteCount < 0: " + byteCount);
       if (closed) throw new IllegalStateException("closed");
@@ -530,16 +569,15 @@ private void readChunkSize() throws IOException {
       long read = source.read(sink, byteCount);
       if (read == -1) {
         inputExhausted = true;
-        endOfInput();
+        endOfInput(false);
         return -1;
       }
       cacheWrite(sink, read);
       return read;
     }
 
-    @Override public Source deadline(Deadline deadline) {
-      source.deadline(deadline);
-      return this;
+    @Override public Timeout timeout() {
+      return source.timeout();
     }
 
     @Override public void close() throws IOException {
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpDate.java b/okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpDate.java
index cdb697318b..27511b37ca 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpDate.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpDate.java
@@ -17,7 +17,7 @@
 package com.squareup.okhttp.internal.http;
 
 import java.text.DateFormat;
-import java.text.ParseException;
+import java.text.ParsePosition;
 import java.text.SimpleDateFormat;
 import java.util.Date;
 import java.util.Locale;
@@ -28,6 +28,8 @@
  */
 public final class HttpDate {
 
+  private static final TimeZone GMT = TimeZone.getTimeZone("GMT");
+
   /**
    * Most websites serve cookies in the blessed format. Eagerly create the parser to ensure such
    * cookies are on the fast path.
@@ -35,16 +37,21 @@
   private static final ThreadLocal<DateFormat> STANDARD_DATE_FORMAT =
       new ThreadLocal<DateFormat>() {
         @Override protected DateFormat initialValue() {
-          DateFormat rfc1123 = new SimpleDateFormat("EEE, dd MMM yyyy HH:mm:ss zzz", Locale.US);
-          rfc1123.setTimeZone(TimeZone.getTimeZone("GMT"));
+          // RFC 2616 specified: RFC 822, updated by RFC 1123 format with fixed GMT.
+          DateFormat rfc1123 = new SimpleDateFormat("EEE, dd MMM yyyy HH:mm:ss 'GMT'", Locale.US);
+          rfc1123.setLenient(false);
+          rfc1123.setTimeZone(GMT);
           return rfc1123;
         }
       };
 
   /** If we fail to parse a date in a non-standard format, try each of these formats in sequence. */
   private static final String[] BROWSER_COMPATIBLE_DATE_FORMAT_STRINGS = new String[] {
-      "EEEE, dd-MMM-yy HH:mm:ss zzz", // RFC 1036
-      "EEE MMM d HH:mm:ss yyyy", // ANSI C asctime()
+      // HTTP formats required by RFC2616 but with any timezone.
+      "EEE, dd MMM yyyy HH:mm:ss zzz", // RFC 822, updated by RFC 1123 with any TZ
+      "EEEE, dd-MMM-yy HH:mm:ss zzz", // RFC 850, obsoleted by RFC 1036 with any TZ.
+      "EEE MMM d HH:mm:ss yyyy", // ANSI C's asctime() format
+       // Alternative formats.
       "EEE, dd-MMM-yyyy HH:mm:ss z",
       "EEE, dd-MMM-yyyy HH-mm-ss z",
       "EEE, dd MMM yy HH:mm:ss z",
@@ -66,20 +73,36 @@
 
   /** Returns the date for {@code value}. Returns null if the value couldn't be parsed. */
   public static Date parse(String value) {
-    try {
-      return STANDARD_DATE_FORMAT.get().parse(value);
-    } catch (ParseException ignored) {
+    if (value.length() == 0) {
+      return null;
+    }
+
+    ParsePosition position = new ParsePosition(0);
+    Date result = STANDARD_DATE_FORMAT.get().parse(value, position);
+    if (position.getIndex() == value.length()) {
+      // STANDARD_DATE_FORMAT must match exactly; all text must be consumed, e.g. no ignored
+      // non-standard trailing "+01:00". Those cases are covered below.
+      return result;
     }
     synchronized (BROWSER_COMPATIBLE_DATE_FORMAT_STRINGS) {
       for (int i = 0, count = BROWSER_COMPATIBLE_DATE_FORMAT_STRINGS.length; i < count; i++) {
         DateFormat format = BROWSER_COMPATIBLE_DATE_FORMATS[i];
         if (format == null) {
           format = new SimpleDateFormat(BROWSER_COMPATIBLE_DATE_FORMAT_STRINGS[i], Locale.US);
+          // Set the timezone to use when interpreting formats that don't have a timezone. GMT is
+          // specified by RFC 2616.
+          format.setTimeZone(GMT);
           BROWSER_COMPATIBLE_DATE_FORMATS[i] = format;
         }
-        try {
-          return format.parse(value);
-        } catch (ParseException ignored) {
+        position.setIndex(0);
+        result = format.parse(value, position);
+        if (position.getIndex() != 0) {
+          // Something was parsed. It's possible the entire string was not consumed but we ignore
+          // that. If any of the BROWSER_COMPATIBLE_DATE_FORMAT_STRINGS ended in "'GMT'" we'd have
+          // to also check that position.getIndex() == value.length() otherwise parsing might have
+          // terminated early, ignoring things like "+01:00". Leaving this as != 0 means that any
+          // trailing junk is ignored.
+          return result;
         }
       }
     }
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpEngine.java b/okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpEngine.java
index 20bc3b78a4..cf3ba2eaa0 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpEngine.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpEngine.java
@@ -17,31 +17,32 @@
 
 package com.squareup.okhttp.internal.http;
 
-import com.squareup.okhttp.Address;
 import com.squareup.okhttp.Connection;
 import com.squareup.okhttp.Headers;
+import com.squareup.okhttp.MediaType;
 import com.squareup.okhttp.OkHttpClient;
-import com.squareup.okhttp.OkResponseCache;
+import com.squareup.okhttp.Protocol;
 import com.squareup.okhttp.Request;
 import com.squareup.okhttp.Response;
-import com.squareup.okhttp.ResponseSource;
+import com.squareup.okhttp.ResponseBody;
 import com.squareup.okhttp.Route;
-import com.squareup.okhttp.TunnelRequest;
-import com.squareup.okhttp.internal.Dns;
+import com.squareup.okhttp.internal.Internal;
+import com.squareup.okhttp.internal.InternalCache;
+import com.squareup.okhttp.internal.Util;
 import java.io.IOException;
 import java.io.InputStream;
-import java.net.CacheRequest;
 import java.net.CookieHandler;
 import java.net.ProtocolException;
+import java.net.Proxy;
 import java.net.URL;
-import java.net.UnknownHostException;
 import java.security.cert.CertificateException;
+import java.util.Date;
 import java.util.List;
 import java.util.Map;
-import javax.net.ssl.HostnameVerifier;
 import javax.net.ssl.SSLHandshakeException;
-import javax.net.ssl.SSLSocketFactory;
+import okio.Buffer;
 import okio.BufferedSink;
+import okio.BufferedSource;
 import okio.GzipSource;
 import okio.Okio;
 import okio.Sink;
@@ -51,8 +52,15 @@
 import static com.squareup.okhttp.internal.Util.getDefaultPort;
 import static com.squareup.okhttp.internal.Util.getEffectivePort;
 import static com.squareup.okhttp.internal.http.StatusLine.HTTP_CONTINUE;
+import static com.squareup.okhttp.internal.http.StatusLine.HTTP_TEMP_REDIRECT;
+import static java.net.HttpURLConnection.HTTP_MOVED_PERM;
+import static java.net.HttpURLConnection.HTTP_MOVED_TEMP;
+import static java.net.HttpURLConnection.HTTP_MULT_CHOICE;
 import static java.net.HttpURLConnection.HTTP_NOT_MODIFIED;
 import static java.net.HttpURLConnection.HTTP_NO_CONTENT;
+import static java.net.HttpURLConnection.HTTP_PROXY_AUTH;
+import static java.net.HttpURLConnection.HTTP_SEE_OTHER;
+import static java.net.HttpURLConnection.HTTP_UNAUTHORIZED;
 
 /**
  * Handles a single HTTP request/response pair. Each HTTP engine follows this
@@ -72,12 +80,31 @@
  * <p>The request and response may be served by the HTTP response cache, by the
  * network, or by both in the event of a conditional GET.
  */
-public class HttpEngine {
+public final class HttpEngine {
+  /**
+   * How many redirects should we follow? Chrome follows 21; Firefox, curl,
+   * and wget follow 20; Safari follows 16; and HTTP/1.0 recommends 5.
+   */
+  public static final int MAX_REDIRECTS = 20;
+
+  private static final ResponseBody EMPTY_BODY = new ResponseBody() {
+    @Override public MediaType contentType() {
+      return null;
+    }
+    @Override public long contentLength() {
+      return 0;
+    }
+    @Override public BufferedSource source() {
+      return new Buffer();
+    }
+  };
+
   final OkHttpClient client;
 
   private Connection connection;
   private RouteSelector routeSelector;
   private Route route;
+  private final Response priorResponse;
 
   private Transport transport;
 
@@ -98,28 +125,50 @@
    */
   public final boolean bufferRequestBody;
 
-  private Request request;
+  /**
+   * The original application-provided request. Never modified by OkHttp. When
+   * follow-up requests are necessary, they are derived from this request.
+   */
+  private final Request userRequest;
+
+  /**
+   * The request to send on the network, or null for no network request. This is
+   * derived from the user request, and customized to support OkHttp features
+   * like compression and caching.
+   */
+  private Request networkRequest;
+
+  /**
+   * The cached response, or null if the cache doesn't exist or cannot be used
+   * for this request. Conditional caching means this may be non-null even when
+   * the network request is non-null. Never modified by OkHttp.
+   */
+  private Response cacheResponse;
+
+  /**
+   * The response read from the network. Null if the network response hasn't
+   * been read yet, or if the network is not used. Never modified by OkHttp.
+   */
+  private Response networkResponse;
+
+  /**
+   * The user-visible response. This is derived from either the network
+   * response, cache response, or both. It is customized to support OkHttp
+   * features like compression and caching.
+   */
+  private Response userResponse;
+
   private Sink requestBodyOut;
   private BufferedSink bufferedRequestBody;
 
-  private ResponseSource responseSource;
-
   /** Null until a response is received from the network or the cache. */
-  private Response response;
   private Source responseTransferSource;
-  private Source responseBody;
+  private BufferedSource responseBody;
   private InputStream responseBodyBytes;
 
-  /**
-   * The cache response currently being validated on a conditional get. Null
-   * if the cached response doesn't exist or doesn't need validation. If the
-   * conditional get succeeds, these will be used for the response. If it fails,
-   * it will be set to null.
-   */
-  private Response validatingResponse;
-
   /** The cache request currently being populated from a network response. */
-  private CacheRequest cacheRequest;
+  private CacheRequest storeRequest;
+  private CacheStrategy cacheStrategy;
 
   /**
    * @param request the HTTP request without a body. The body must be
@@ -133,14 +182,22 @@
    *     recover from a failure.
    */
   public HttpEngine(OkHttpClient client, Request request, boolean bufferRequestBody,
-      Connection connection, RouteSelector routeSelector, RetryableSink requestBodyOut) {
+      Connection connection, RouteSelector routeSelector, RetryableSink requestBodyOut,
+      Response priorResponse) {
     this.client = client;
-    this.request = request;
+    this.userRequest = request;
     this.bufferRequestBody = bufferRequestBody;
     this.connection = connection;
     this.routeSelector = routeSelector;
-    this.route = connection != null ? connection.getRoute() : null;
     this.requestBodyOut = requestBodyOut;
+    this.priorResponse = priorResponse;
+
+    if (connection != null) {
+      Internal.instance.setOwner(connection, this);
+      this.route = connection.getRoute();
+    } else {
+      this.route = null;
+    }
   }
 
   /**
@@ -148,40 +205,37 @@ public HttpEngine(OkHttpClient client, Request request, boolean bufferRequestBod
    * source if necessary. Prepares the request headers and gets ready to start
    * writing the request body if it exists.
    */
-  public final void sendRequest() throws IOException {
-    if (responseSource != null) return; // Already sent.
+  public void sendRequest() throws IOException {
+    if (cacheStrategy != null) return; // Already sent.
     if (transport != null) throw new IllegalStateException();
 
-    prepareRawRequestHeaders();
-    OkResponseCache responseCache = client.getOkResponseCache();
+    Request request = networkRequest(userRequest);
 
-    Response cacheResponse = responseCache != null
+    InternalCache responseCache = Internal.instance.internalCache(client);
+    Response cacheCandidate = responseCache != null
         ? responseCache.get(request)
         : null;
+
     long now = System.currentTimeMillis();
-    CacheStrategy cacheStrategy = new CacheStrategy.Factory(now, request, cacheResponse).get();
-    responseSource = cacheStrategy.source;
-    request = cacheStrategy.request;
+    cacheStrategy = new CacheStrategy.Factory(now, request, cacheCandidate).get();
+    networkRequest = cacheStrategy.networkRequest;
+    cacheResponse = cacheStrategy.cacheResponse;
 
     if (responseCache != null) {
-      responseCache.trackResponse(responseSource);
-    }
-
-    if (responseSource != ResponseSource.NETWORK) {
-      validatingResponse = cacheStrategy.response;
+      responseCache.trackResponse(cacheStrategy);
     }
 
-    if (cacheResponse != null && !responseSource.usesCache()) {
-      closeQuietly(cacheResponse.body()); // We don't need this cached response. Close it.
+    if (cacheCandidate != null && cacheResponse == null) {
+      closeQuietly(cacheCandidate.body()); // The cache candidate wasn't applicable. Close it.
     }
 
-    if (responseSource.requiresConnection()) {
+    if (networkRequest != null) {
       // Open a connection unless we inherited one from a redirect.
       if (connection == null) {
-        connect();
+        connect(networkRequest);
       }
 
-      transport = (Transport) connection.newTransport(this);
+      transport = Internal.instance.newTransport(connection, this);
 
       // Create a request body if we don't have one already. We'll already have
       // one if we're retrying a failed POST.
@@ -190,57 +244,52 @@ public final void sendRequest() throws IOException {
       }
 
     } else {
-      // We're using a cached response. Recycle a connection we may have inherited from a redirect.
+      // We aren't using the network. Recycle a connection we may have inherited from a redirect.
       if (connection != null) {
-        client.getConnectionPool().recycle(connection);
+        Internal.instance.recycle(client.getConnectionPool(), connection);
         connection = null;
       }
 
-      // No need for the network! Promote the cached response immediately.
-      this.response = validatingResponse;
-      if (validatingResponse.body() != null) {
-        initContentStream(validatingResponse.body().source());
+      if (cacheResponse != null) {
+        // We have a valid cached response. Promote it to the user response immediately.
+        this.userResponse = cacheResponse.newBuilder()
+            .request(userRequest)
+            .priorResponse(stripBody(priorResponse))
+            .cacheResponse(stripBody(cacheResponse))
+            .build();
+      } else {
+        // We're forbidden from using the network, and the cache is insufficient.
+        this.userResponse = new Response.Builder()
+            .request(userRequest)
+            .priorResponse(stripBody(priorResponse))
+            .protocol(Protocol.HTTP_1_1)
+            .code(504)
+            .message("Unsatisfiable Request (only-if-cached)")
+            .body(EMPTY_BODY)
+            .build();
+      }
+
+      if (userResponse.body() != null) {
+        initContentStream(userResponse.body().source());
       }
     }
   }
 
-  private Response cacheableResponse() {
-    // Use an unreadable response body when offering the response to the cache.
-    // The cache isn't allowed to consume the response body bytes!
-    return response.newBuilder().body(null).build();
+  private static Response stripBody(Response response) {
+    return response != null && response.body() != null
+        ? response.newBuilder().body(null).build()
+        : response;
   }
 
   /** Connect to the origin server either directly or via a proxy. */
-  private void connect() throws IOException {
+  private void connect(Request request) throws IOException {
     if (connection != null) throw new IllegalStateException();
 
     if (routeSelector == null) {
-      String uriHost = request.url().getHost();
-      if (uriHost == null || uriHost.length() == 0) {
-        throw new UnknownHostException(request.url().toString());
-      }
-      SSLSocketFactory sslSocketFactory = null;
-      HostnameVerifier hostnameVerifier = null;
-      if (request.isHttps()) {
-        sslSocketFactory = client.getSslSocketFactory();
-        hostnameVerifier = client.getHostnameVerifier();
-      }
-      Address address = new Address(uriHost, getEffectivePort(request.url()), sslSocketFactory,
-          hostnameVerifier, client.getAuthenticator(), client.getProxy(), client.getProtocols());
-      routeSelector = new RouteSelector(address, request.uri(), client.getProxySelector(),
-          client.getConnectionPool(), Dns.DEFAULT, client.getRoutesDatabase());
-    }
-
-    connection = routeSelector.next(request.method());
-
-    if (!connection.isConnected()) {
-      connection.connect(client.getConnectTimeout(), client.getReadTimeout(), getTunnelConfig());
-      if (connection.isSpdy()) client.getConnectionPool().share(connection);
-      client.getRoutesDatabase().connected(connection.getRoute());
-    } else if (!connection.isSpdy()) {
-      connection.updateReadTimeout(client.getReadTimeout());
+      routeSelector = RouteSelector.get(request, client);
     }
 
+    connection = routeSelector.next(this);
     route = connection.getRoute();
   }
 
@@ -254,16 +303,17 @@ public void writingRequestHeaders() {
   }
 
   boolean hasRequestBody() {
-    return HttpMethod.hasRequestBody(request.method());
+    return HttpMethod.hasRequestBody(userRequest.method())
+        && !Util.emptySink().equals(requestBodyOut);
   }
 
   /** Returns the request body or null if this request doesn't have a body. */
-  public final Sink getRequestBody() {
-    if (responseSource == null) throw new IllegalStateException();
+  public Sink getRequestBody() {
+    if (cacheStrategy == null) throw new IllegalStateException();
     return requestBodyOut;
   }
 
-  public final BufferedSink getBufferedRequestBody() {
+  public BufferedSink getBufferedRequestBody() {
     BufferedSink result = bufferedRequestBody;
     if (result != null) return result;
     Sink requestBody = getRequestBody();
@@ -272,47 +322,44 @@ public final BufferedSink getBufferedRequestBody() {
         : null;
   }
 
-  public final boolean hasResponse() {
-    return response != null;
+  public boolean hasResponse() {
+    return userResponse != null;
   }
 
-  public final ResponseSource responseSource() {
-    return responseSource;
-  }
-
-  public final Request getRequest() {
-    return request;
+  public Request getRequest() {
+    return userRequest;
   }
 
   /** Returns the engine's response. */
   // TODO: the returned body will always be null.
-  public final Response getResponse() {
-    if (response == null) throw new IllegalStateException();
-    return response;
+  public Response getResponse() {
+    if (userResponse == null) throw new IllegalStateException();
+    return userResponse;
   }
 
-  public final Source getResponseBody() {
-    if (response == null) throw new IllegalStateException();
+  public BufferedSource getResponseBody() {
+    if (userResponse == null) throw new IllegalStateException();
     return responseBody;
   }
 
-  public final InputStream getResponseBodyBytes() {
+  public InputStream getResponseBodyBytes() {
     InputStream result = responseBodyBytes;
     return result != null
         ? result
         : (responseBodyBytes = Okio.buffer(getResponseBody()).inputStream());
   }
 
-  public final Connection getConnection() {
+  public Connection getConnection() {
     return connection;
   }
 
   /**
    * Report and attempt to recover from {@code e}. Returns a new HTTP engine
    * that should be used for the retry if {@code e} is recoverable, or null if
-   * the failure is permanent.
+   * the failure is permanent. Requests with a body can only be recovered if the
+   * body is buffered.
    */
-  public HttpEngine recover(IOException e) {
+  public HttpEngine recover(IOException e, Sink requestBodyOut) {
     if (routeSelector != null && connection != null) {
       routeSelector.connectFailed(connection, e);
     }
@@ -328,8 +375,12 @@ public HttpEngine recover(IOException e) {
     Connection connection = close();
 
     // For failure recovery, use the same route selector with a new connection.
-    return new HttpEngine(client, request, bufferRequestBody, connection, routeSelector,
-        (RetryableSink) requestBodyOut);
+    return new HttpEngine(client, userRequest, bufferRequestBody, connection, routeSelector,
+        (RetryableSink) requestBodyOut, priorResponse);
+  }
+
+  public HttpEngine recover(IOException e) {
+    return recover(e, requestBodyOut);
   }
 
   private boolean isRecoverable(IOException e) {
@@ -350,17 +401,23 @@ public Route getRoute() {
   }
 
   private void maybeCache() throws IOException {
-    OkResponseCache responseCache = client.getOkResponseCache();
+    InternalCache responseCache = Internal.instance.internalCache(client);
     if (responseCache == null) return;
 
     // Should we cache this response for this request?
-    if (!CacheStrategy.isCacheable(response, request)) {
-      responseCache.maybeRemove(request);
+    if (!CacheStrategy.isCacheable(userResponse, networkRequest)) {
+      if (HttpMethod.invalidatesCache(networkRequest.method())) {
+        try {
+          responseCache.remove(networkRequest);
+        } catch (IOException ignored) {
+          // The cache cannot be written.
+        }
+      }
       return;
     }
 
     // Offer this request to the cache.
-    cacheRequest = responseCache.put(cacheableResponse());
+    storeRequest = responseCache.put(stripBody(userResponse));
   }
 
   /**
@@ -368,18 +425,33 @@ private void maybeCache() throws IOException {
    * either exhausted or closed. If it is unneeded when this is called, it will
    * be released immediately.
    */
-  public final void releaseConnection() throws IOException {
-    if (transport != null) {
+  public void releaseConnection() throws IOException {
+    if (transport != null && connection != null) {
       transport.releaseConnectionOnIdle();
     }
     connection = null;
   }
 
+  /**
+   * Immediately closes the socket connection if it's currently held by this
+   * engine. Use this to interrupt an in-flight request from any thread. It's
+   * the caller's responsibility to close the request body and response body
+   * streams; otherwise resources may be leaked.
+   */
+  public void disconnect() {
+    if (transport != null) {
+      try {
+        transport.disconnect(this);
+      } catch (IOException ignored) {
+      }
+    }
+  }
+
   /**
    * Release any resources held by this engine. If a connection is still held by
    * this engine, it is returned.
    */
-  public final Connection close() {
+  public Connection close() {
     if (bufferedRequestBody != null) {
       // This also closes the wrapped requestBodyOut.
       closeQuietly(bufferedRequestBody);
@@ -389,7 +461,7 @@ public final Connection close() {
 
     // If this engine never achieved a response body, its connection cannot be reused.
     if (responseBody == null) {
-      closeQuietly(connection);
+      if (connection != null) closeQuietly(connection.getSocket()); // TODO: does this break SPDY?
       connection = null;
       return null;
     }
@@ -401,12 +473,17 @@ public final Connection close() {
     closeQuietly(responseBodyBytes);
 
     // Close the connection if it cannot be reused.
-    if (transport != null && !transport.canReuseConnection()) {
-      closeQuietly(connection);
+    if (transport != null && connection != null && !transport.canReuseConnection()) {
+      closeQuietly(connection.getSocket());
       connection = null;
       return null;
     }
 
+    // Prevent this engine from disconnecting a connection it no longer owns.
+    if (connection != null && !Internal.instance.clearOwner(connection)) {
+      connection = null;
+    }
+
     Connection result = connection;
     connection = null;
     return result;
@@ -430,14 +507,14 @@ public final Connection close() {
    */
   private void initContentStream(Source transferSource) throws IOException {
     responseTransferSource = transferSource;
-    if (transparentGzip && "gzip".equalsIgnoreCase(response.header("Content-Encoding"))) {
-      response = response.newBuilder()
+    if (transparentGzip && "gzip".equalsIgnoreCase(userResponse.header("Content-Encoding"))) {
+      userResponse = userResponse.newBuilder()
           .removeHeader("Content-Encoding")
           .removeHeader("Content-Length")
           .build();
-      responseBody = new GzipSource(transferSource);
+      responseBody = Okio.buffer(new GzipSource(transferSource));
     } else {
-      responseBody = transferSource;
+      responseBody = Okio.buffer(transferSource);
     }
   }
 
@@ -445,13 +522,13 @@ private void initContentStream(Source transferSource) throws IOException {
    * Returns true if the response must have a (possibly 0-length) body.
    * See RFC 2616 section 4.3.
    */
-  public final boolean hasResponseBody() {
+  public boolean hasResponseBody() {
     // HEAD requests never yield a body regardless of the response headers.
-    if (request.method().equals("HEAD")) {
+    if (userRequest.method().equals("HEAD")) {
       return false;
     }
 
-    int responseCode = response.code();
+    int responseCode = userResponse.code();
     if ((responseCode < HTTP_CONTINUE || responseCode >= 200)
         && responseCode != HTTP_NO_CONTENT
         && responseCode != HTTP_NOT_MODIFIED) {
@@ -461,8 +538,8 @@ public final boolean hasResponseBody() {
     // If the Content-Length or Transfer-Encoding headers disagree with the
     // response code, the response is malformed. For best compatibility, we
     // honor the headers.
-    if (OkHeaders.contentLength(response) != -1
-        || "chunked".equalsIgnoreCase(response.header("Transfer-Encoding"))) {
+    if (OkHeaders.contentLength(networkResponse) != -1
+        || "chunked".equalsIgnoreCase(networkResponse.header("Transfer-Encoding"))) {
       return true;
     }
 
@@ -475,18 +552,14 @@ public final boolean hasResponseBody() {
    * <p>This client doesn't specify a default {@code Accept} header because it
    * doesn't know what content types the application is interested in.
    */
-  private void prepareRawRequestHeaders() throws IOException {
+  private Request networkRequest(Request request) throws IOException {
     Request.Builder result = request.newBuilder();
 
-    if (request.getUserAgent() == null) {
-      result.setUserAgent(getDefaultUserAgent());
-    }
-
     if (request.header("Host") == null) {
       result.header("Host", hostHeader(request.url()));
     }
 
-    if ((connection == null || connection.getHttpMinorVersion() != 0)
+    if ((connection == null || connection.getProtocol() != Protocol.HTTP_1_0)
         && request.header("Connection") == null) {
       result.header("Connection", "Keep-Alive");
     }
@@ -496,10 +569,6 @@ private void prepareRawRequestHeaders() throws IOException {
       result.header("Accept-Encoding", "gzip");
     }
 
-    if (hasRequestBody() && request.header("Content-Type") == null) {
-      result.header("Content-Type", "application/x-www-form-urlencoded");
-    }
-
     CookieHandler cookieHandler = client.getCookieHandler();
     if (cookieHandler != null) {
       // Capture the request headers added so far so that they can be offered to the CookieHandler.
@@ -513,12 +582,7 @@ private void prepareRawRequestHeaders() throws IOException {
       OkHeaders.addCookies(result, cookies);
     }
 
-    request = result.build();
-  }
-
-  public static String getDefaultUserAgent() {
-    String agent = System.getProperty("http.agent");
-    return agent != null ? agent : ("Java" + System.getProperty("java.version"));
+    return result.build();
   }
 
   public static String hostHeader(URL url) {
@@ -531,10 +595,16 @@ public static String hostHeader(URL url) {
    * Flushes the remaining request header and body, parses the HTTP response
    * headers and starts reading the HTTP response body if it exists.
    */
-  public final void readResponse() throws IOException {
-    if (response != null) return;
-    if (responseSource == null) throw new IllegalStateException("call sendRequest() first!");
-    if (!responseSource.requiresConnection()) return;
+  public void readResponse() throws IOException {
+    if (userResponse != null) {
+      return; // Already ready.
+    }
+    if (networkRequest == null && cacheResponse == null) {
+      throw new IllegalStateException("call sendRequest() first!");
+    }
+    if (networkRequest == null) {
+      return; // No network response to read.
+    }
 
     // Flush the request body if there's data outstanding.
     if (bufferedRequestBody != null && bufferedRequestBody.buffer().size() > 0) {
@@ -542,14 +612,15 @@ public final void readResponse() throws IOException {
     }
 
     if (sentRequestMillis == -1) {
-      if (OkHeaders.contentLength(request) == -1 && requestBodyOut instanceof RetryableSink) {
+      if (OkHeaders.contentLength(networkRequest) == -1
+          && requestBodyOut instanceof RetryableSink) {
         // We might not learn the Content-Length until the request body has been buffered.
         long contentLength = ((RetryableSink) requestBodyOut).contentLength();
-        request = request.newBuilder()
+        networkRequest = networkRequest.newBuilder()
             .header("Content-Length", Long.toString(contentLength))
             .build();
       }
-      transport.writeRequestHeaders(request);
+      transport.writeRequestHeaders(networkRequest);
     }
 
     if (requestBodyOut != null) {
@@ -559,115 +630,204 @@ public final void readResponse() throws IOException {
       } else {
         requestBodyOut.close();
       }
-      if (requestBodyOut instanceof RetryableSink) {
+      if (requestBodyOut instanceof RetryableSink && !Util.emptySink().equals(requestBodyOut)) {
         transport.writeRequestBody((RetryableSink) requestBodyOut);
       }
     }
 
     transport.flushRequest();
 
-    response = transport.readResponseHeaders()
-        .request(request)
+    networkResponse = transport.readResponseHeaders()
+        .request(networkRequest)
         .handshake(connection.getHandshake())
         .header(OkHeaders.SENT_MILLIS, Long.toString(sentRequestMillis))
         .header(OkHeaders.RECEIVED_MILLIS, Long.toString(System.currentTimeMillis()))
-        .setResponseSource(responseSource)
         .build();
-    connection.setHttpMinorVersion(response.httpMinorVersion());
-    receiveHeaders(response.headers());
-
-    if (responseSource == ResponseSource.CONDITIONAL_CACHE) {
-      if (validatingResponse.validate(response)) {
+    Internal.instance.setProtocol(connection, networkResponse.protocol());
+    receiveHeaders(networkResponse.headers());
+
+    // If we have a cache response too, then we're doing a conditional get.
+    if (cacheResponse != null) {
+      if (validate(cacheResponse, networkResponse)) {
+        userResponse = cacheResponse.newBuilder()
+            .request(userRequest)
+            .priorResponse(stripBody(priorResponse))
+            .headers(combine(cacheResponse.headers(), networkResponse.headers()))
+            .cacheResponse(stripBody(cacheResponse))
+            .networkResponse(stripBody(networkResponse))
+            .build();
         transport.emptyTransferStream();
         releaseConnection();
-        response = combine(validatingResponse, response);
 
         // Update the cache after combining headers but before stripping the
         // Content-Encoding header (as performed by initContentStream()).
-        OkResponseCache responseCache = client.getOkResponseCache();
+        InternalCache responseCache = Internal.instance.internalCache(client);
         responseCache.trackConditionalCacheHit();
-        responseCache.update(validatingResponse, cacheableResponse());
+        responseCache.update(cacheResponse, stripBody(userResponse));
 
-        if (validatingResponse.body() != null) {
-          initContentStream(validatingResponse.body().source());
+        if (cacheResponse.body() != null) {
+          initContentStream(cacheResponse.body().source());
         }
         return;
       } else {
-        closeQuietly(validatingResponse.body());
+        closeQuietly(cacheResponse.body());
       }
     }
 
+    userResponse = networkResponse.newBuilder()
+        .request(userRequest)
+        .priorResponse(stripBody(priorResponse))
+        .cacheResponse(stripBody(cacheResponse))
+        .networkResponse(stripBody(networkResponse))
+        .build();
+
     if (!hasResponseBody()) {
       // Don't call initContentStream() when the response doesn't have any content.
-      responseTransferSource = transport.getTransferStream(cacheRequest);
-      responseBody = responseTransferSource;
+      responseTransferSource = transport.getTransferStream(storeRequest);
+      responseBody = Okio.buffer(responseTransferSource);
       return;
     }
 
     maybeCache();
-    initContentStream(transport.getTransferStream(cacheRequest));
+    initContentStream(transport.getTransferStream(storeRequest));
+  }
+
+  /**
+   * Returns true if {@code cached} should be used; false if {@code network}
+   * response should be used.
+   */
+  private static boolean validate(Response cached, Response network) {
+    if (network.code() == HTTP_NOT_MODIFIED) {
+      return true;
+    }
+
+    // The HTTP spec says that if the network's response is older than our
+    // cached response, we may return the cache's response. Like Chrome (but
+    // unlike Firefox), this client prefers to return the newer response.
+    Date lastModified = cached.headers().getDate("Last-Modified");
+    if (lastModified != null) {
+      Date networkLastModified = network.headers().getDate("Last-Modified");
+      if (networkLastModified != null
+          && networkLastModified.getTime() < lastModified.getTime()) {
+        return true;
+      }
+    }
+
+    return false;
   }
 
   /**
    * Combines cached headers with a network headers as defined by RFC 2616,
    * 13.5.3.
    */
-  private static Response combine(Response cached, Response network) throws IOException {
+  private static Headers combine(Headers cachedHeaders, Headers networkHeaders) throws IOException {
     Headers.Builder result = new Headers.Builder();
 
-    Headers cachedHeaders = cached.headers();
     for (int i = 0; i < cachedHeaders.size(); i++) {
       String fieldName = cachedHeaders.name(i);
       String value = cachedHeaders.value(i);
       if ("Warning".equals(fieldName) && value.startsWith("1")) {
         continue; // drop 100-level freshness warnings
       }
-      if (!isEndToEnd(fieldName) || network.header(fieldName) == null) {
+      if (!OkHeaders.isEndToEnd(fieldName) || networkHeaders.get(fieldName) == null) {
         result.add(fieldName, value);
       }
     }
 
-    Headers networkHeaders = network.headers();
     for (int i = 0; i < networkHeaders.size(); i++) {
       String fieldName = networkHeaders.name(i);
-      if (isEndToEnd(fieldName)) {
+      if (OkHeaders.isEndToEnd(fieldName)) {
         result.add(fieldName, networkHeaders.value(i));
       }
     }
 
-    return cached.newBuilder().headers(result.build()).build();
+    return result.build();
+  }
+
+  public void receiveHeaders(Headers headers) throws IOException {
+    CookieHandler cookieHandler = client.getCookieHandler();
+    if (cookieHandler != null) {
+      cookieHandler.put(userRequest.uri(), OkHeaders.toMultimap(headers, null));
+    }
   }
 
   /**
-   * Returns true if {@code fieldName} is an end-to-end HTTP header, as
-   * defined by RFC 2616, 13.5.1.
+   * Figures out the HTTP request to make in response to receiving this engine's
+   * response. This will either add authentication headers or follow redirects.
+   * If a follow-up is either unnecessary or not applicable, this returns null.
    */
-  private static boolean isEndToEnd(String fieldName) {
-    return !"Connection".equalsIgnoreCase(fieldName)
-        && !"Keep-Alive".equalsIgnoreCase(fieldName)
-        && !"Proxy-Authenticate".equalsIgnoreCase(fieldName)
-        && !"Proxy-Authorization".equalsIgnoreCase(fieldName)
-        && !"TE".equalsIgnoreCase(fieldName)
-        && !"Trailers".equalsIgnoreCase(fieldName)
-        && !"Transfer-Encoding".equalsIgnoreCase(fieldName)
-        && !"Upgrade".equalsIgnoreCase(fieldName);
-  }
+  public Request followUpRequest() throws IOException {
+    if (userResponse == null) throw new IllegalStateException();
+    Proxy selectedProxy = getRoute() != null
+        ? getRoute().getProxy()
+        : client.getProxy();
+    int responseCode = userResponse.code();
+
+    switch (responseCode) {
+      case HTTP_PROXY_AUTH:
+        if (selectedProxy.type() != Proxy.Type.HTTP) {
+          throw new ProtocolException("Received HTTP_PROXY_AUTH (407) code while not using proxy");
+        }
+        // fall-through
+      case HTTP_UNAUTHORIZED:
+        return OkHeaders.processAuthHeader(client.getAuthenticator(), userResponse, selectedProxy);
+
+      case HTTP_TEMP_REDIRECT:
+        // "If the 307 status code is received in response to a request other than GET or HEAD,
+        // the user agent MUST NOT automatically redirect the request"
+        if (!userRequest.method().equals("GET") && !userRequest.method().equals("HEAD")) {
+          return null;
+        }
+        // fall-through
+      case HTTP_MULT_CHOICE:
+      case HTTP_MOVED_PERM:
+      case HTTP_MOVED_TEMP:
+      case HTTP_SEE_OTHER:
+        // Does the client allow redirects?
+        if (!client.getFollowRedirects()) return null;
+
+        String location = userResponse.header("Location");
+        if (location == null) return null;
+        URL url = new URL(userRequest.url(), location);
+
+        // Don't follow redirects to unsupported protocols.
+        if (!url.getProtocol().equals("https") && !url.getProtocol().equals("http")) return null;
+
+        // If configured, don't follow redirects between SSL and non-SSL.
+        boolean sameProtocol = url.getProtocol().equals(userRequest.url().getProtocol());
+        if (!sameProtocol && !client.getFollowSslRedirects()) return null;
+
+        // Redirects don't include a request body.
+        Request.Builder requestBuilder = userRequest.newBuilder();
+        if (HttpMethod.hasRequestBody(userRequest.method())) {
+          requestBuilder.method("GET", null);
+          requestBuilder.removeHeader("Transfer-Encoding");
+          requestBuilder.removeHeader("Content-Length");
+          requestBuilder.removeHeader("Content-Type");
+        }
 
-  private TunnelRequest getTunnelConfig() {
-    if (!request.isHttps()) return null;
+        // When redirecting across hosts, drop all authentication headers. This
+        // is potentially annoying to the application layer since they have no
+        // way to retain them.
+        if (!sameConnection(url)) {
+          requestBuilder.removeHeader("Authorization");
+        }
 
-    String userAgent = request.getUserAgent();
-    if (userAgent == null) userAgent = getDefaultUserAgent();
+        return requestBuilder.url(url).build();
 
-    URL url = request.url();
-    return new TunnelRequest(url.getHost(), getEffectivePort(url), userAgent,
-        request.getProxyAuthorization());
+      default:
+        return null;
+    }
   }
 
-  public void receiveHeaders(Headers headers) throws IOException {
-    CookieHandler cookieHandler = client.getCookieHandler();
-    if (cookieHandler != null) {
-      cookieHandler.put(request.uri(), OkHeaders.toMultimap(headers, null));
-    }
+  /**
+   * Returns true if an HTTP request for {@code followUp} can reuse the
+   * connection used by this engine.
+   */
+  public boolean sameConnection(URL followUp) {
+    URL url = userRequest.url();
+    return url.getHost().equals(followUp.getHost())
+        && getEffectivePort(url) == getEffectivePort(followUp)
+        && url.getProtocol().equals(followUp.getProtocol());
   }
 }
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpMethod.java b/okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpMethod.java
index 1577d1018d..b9f839dd46 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpMethod.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpMethod.java
@@ -20,7 +20,7 @@
 import java.util.Set;
 
 public final class HttpMethod {
-  public static final Set<String> METHODS = new LinkedHashSet<String>(Arrays.asList(
+  public static final Set<String> METHODS = new LinkedHashSet<>(Arrays.asList(
       "OPTIONS", "GET", "HEAD", "POST", "PUT", "DELETE", "TRACE", "PATCH"));
 
   public static boolean invalidatesCache(String method) {
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpTransport.java b/okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpTransport.java
index a1b367f474..c61bf20b71 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpTransport.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpTransport.java
@@ -19,7 +19,6 @@
 import com.squareup.okhttp.Request;
 import com.squareup.okhttp.Response;
 import java.io.IOException;
-import java.net.CacheRequest;
 import okio.Sink;
 import okio.Source;
 
@@ -93,8 +92,8 @@ public void writeRequestHeaders(Request request) throws IOException {
     httpEngine.writingRequestHeaders();
     String requestLine = RequestLine.get(request,
         httpEngine.getConnection().getRoute().getProxy().type(),
-        httpEngine.getConnection().getHttpMinorVersion());
-    httpConnection.writeRequest(request.getHeaders(), requestLine);
+        httpEngine.getConnection().getProtocol());
+    httpConnection.writeRequest(request.headers(), requestLine);
   }
 
   @Override public Response.Builder readResponseHeaders() throws IOException {
@@ -150,4 +149,8 @@ public void writeRequestHeaders(Request request) throws IOException {
     // reference escapes.
     return httpConnection.newUnknownLengthSource(cacheRequest);
   }
+
+  @Override public void disconnect(HttpEngine engine) throws IOException {
+    httpConnection.closeIfOwnedBy(engine);
+  }
 }
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/http/OkHeaders.java b/okhttp/src/main/java/com/squareup/okhttp/internal/http/OkHeaders.java
index 456c9c7535..b09801b487 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/http/OkHeaders.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/http/OkHeaders.java
@@ -1,15 +1,24 @@
 package com.squareup.okhttp.internal.http;
 
+import com.squareup.okhttp.Authenticator;
+import com.squareup.okhttp.Challenge;
 import com.squareup.okhttp.Headers;
 import com.squareup.okhttp.Request;
 import com.squareup.okhttp.Response;
 import com.squareup.okhttp.internal.Platform;
+import java.io.IOException;
+import java.net.Proxy;
 import java.util.ArrayList;
 import java.util.Collections;
 import java.util.Comparator;
 import java.util.List;
 import java.util.Map;
+import java.util.Set;
 import java.util.TreeMap;
+import java.util.TreeSet;
+
+import static com.squareup.okhttp.internal.Util.equal;
+import static java.net.HttpURLConnection.HTTP_PROXY_AUTH;
 
 /** Headers and utilities for internal use by OkHttp. */
 public final class OkHeaders {
@@ -40,12 +49,6 @@
    */
   public static final String RECEIVED_MILLIS = PREFIX + "-Received-Millis";
 
-  /**
-   * Synthetic response header: the response source and status code like
-   * "CONDITIONAL_CACHE 304".
-   */
-  public static final String RESPONSE_SOURCE = PREFIX + "-Response-Source";
-
   /**
    * Synthetic response header: the selected
    * {@link com.squareup.okhttp.Protocol protocol} ("spdy/3.1", "http/1.1", etc).
@@ -83,12 +86,12 @@ private static long stringToLong(String s) {
    *     for responses. If non-null, this value is mapped to the null key.
    */
   public static Map<String, List<String>> toMultimap(Headers headers, String valueForNullKey) {
-    Map<String, List<String>> result = new TreeMap<String, List<String>>(FIELD_NAME_COMPARATOR);
+    Map<String, List<String>> result = new TreeMap<>(FIELD_NAME_COMPARATOR);
     for (int i = 0; i < headers.size(); i++) {
       String fieldName = headers.name(i);
       String value = headers.value(i);
 
-      List<String> allValues = new ArrayList<String>();
+      List<String> allValues = new ArrayList<>();
       List<String> otherValues = result.get(fieldName);
       if (otherValues != null) {
         allValues.addAll(otherValues);
@@ -125,4 +128,137 @@ private static String buildCookieHeader(List<String> cookies) {
     }
     return sb.toString();
   }
+
+  /**
+   * Returns true if none of the Vary headers have changed between {@code
+   * cachedRequest} and {@code newRequest}.
+   */
+  public static boolean varyMatches(
+      Response cachedResponse, Headers cachedRequest, Request newRequest) {
+    for (String field : varyFields(cachedResponse)) {
+      if (!equal(cachedRequest.values(field), newRequest.headers(field))) return false;
+    }
+    return true;
+  }
+
+  /**
+   * Returns true if a Vary header contains an asterisk. Such responses cannot
+   * be cached.
+   */
+  public static boolean hasVaryAll(Response response) {
+    return varyFields(response).contains("*");
+  }
+
+  private static Set<String> varyFields(Response response) {
+    Set<String> result = Collections.emptySet();
+    Headers headers = response.headers();
+    for (int i = 0; i < headers.size(); i++) {
+      if (!"Vary".equalsIgnoreCase(headers.name(i))) continue;
+
+      String value = headers.value(i);
+      if (result.isEmpty()) {
+        result = new TreeSet<>(String.CASE_INSENSITIVE_ORDER);
+      }
+      for (String varyField : value.split(",")) {
+        result.add(varyField.trim());
+      }
+    }
+    return result;
+  }
+
+  /**
+   * Returns the subset of the headers in {@code response}'s request that
+   * impact the content of response's body.
+   */
+  public static Headers varyHeaders(Response response) {
+    Set<String> varyFields = varyFields(response);
+    if (varyFields.isEmpty()) return new Headers.Builder().build();
+
+    // Use the request headers sent over the network, since that's what the
+    // response varies on. Otherwise OkHttp-supplied headers like
+    // "Accept-Encoding: gzip" may be lost.
+    Headers requestHeaders = response.networkResponse().request().headers();
+
+    Headers.Builder result = new Headers.Builder();
+    for (int i = 0; i < requestHeaders.size(); i++) {
+      String fieldName = requestHeaders.name(i);
+      if (varyFields.contains(fieldName)) {
+        result.add(fieldName, requestHeaders.value(i));
+      }
+    }
+    return result.build();
+  }
+
+  /**
+   * Returns true if {@code fieldName} is an end-to-end HTTP header, as
+   * defined by RFC 2616, 13.5.1.
+   */
+  static boolean isEndToEnd(String fieldName) {
+    return !"Connection".equalsIgnoreCase(fieldName)
+        && !"Keep-Alive".equalsIgnoreCase(fieldName)
+        && !"Proxy-Authenticate".equalsIgnoreCase(fieldName)
+        && !"Proxy-Authorization".equalsIgnoreCase(fieldName)
+        && !"TE".equalsIgnoreCase(fieldName)
+        && !"Trailers".equalsIgnoreCase(fieldName)
+        && !"Transfer-Encoding".equalsIgnoreCase(fieldName)
+        && !"Upgrade".equalsIgnoreCase(fieldName);
+  }
+
+  /**
+   * Parse RFC 2617 challenges. This API is only interested in the scheme
+   * name and realm.
+   */
+  public static List<Challenge> parseChallenges(Headers responseHeaders, String challengeHeader) {
+    // auth-scheme = token
+    // auth-param  = token "=" ( token | quoted-string )
+    // challenge   = auth-scheme 1*SP 1#auth-param
+    // realm       = "realm" "=" realm-value
+    // realm-value = quoted-string
+    List<Challenge> result = new ArrayList<>();
+    for (int h = 0; h < responseHeaders.size(); h++) {
+      if (!challengeHeader.equalsIgnoreCase(responseHeaders.name(h))) {
+        continue;
+      }
+      String value = responseHeaders.value(h);
+      int pos = 0;
+      while (pos < value.length()) {
+        int tokenStart = pos;
+        pos = HeaderParser.skipUntil(value, pos, " ");
+
+        String scheme = value.substring(tokenStart, pos).trim();
+        pos = HeaderParser.skipWhitespace(value, pos);
+
+        // TODO: This currently only handles schemes with a 'realm' parameter;
+        //       It needs to be fixed to handle any scheme and any parameters
+        //       http://code.google.com/p/android/issues/detail?id=11140
+
+        if (!value.regionMatches(true, pos, "realm=\"", 0, "realm=\"".length())) {
+          break; // Unexpected challenge parameter; give up!
+        }
+
+        pos += "realm=\"".length();
+        int realmStart = pos;
+        pos = HeaderParser.skipUntil(value, pos, "\"");
+        String realm = value.substring(realmStart, pos);
+        pos++; // Consume '"' close quote.
+        pos = HeaderParser.skipUntil(value, pos, ",");
+        pos++; // Consume ',' comma.
+        pos = HeaderParser.skipWhitespace(value, pos);
+        result.add(new Challenge(scheme, realm));
+      }
+    }
+    return result;
+  }
+
+  /**
+   * React to a failed authorization response by looking up new credentials.
+   * Returns a request for a subsequent attempt, or null if no further attempts
+   * should be made.
+   */
+  public static Request processAuthHeader(Authenticator authenticator, Response response,
+      Proxy proxy) throws IOException {
+    return response.code() == HTTP_PROXY_AUTH
+        ? authenticator.authenticateProxy(proxy, response)
+        : authenticator.authenticate(proxy, response);
+  }
 }
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/http/RequestLine.java b/okhttp/src/main/java/com/squareup/okhttp/internal/http/RequestLine.java
index c918df3c22..f764afd326 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/http/RequestLine.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/http/RequestLine.java
@@ -1,6 +1,8 @@
 package com.squareup.okhttp.internal.http;
 
+import com.squareup.okhttp.Protocol;
 import com.squareup.okhttp.Request;
+import java.net.HttpURLConnection;
 import java.net.Proxy;
 import java.net.URL;
 
@@ -10,13 +12,13 @@ private RequestLine() {
 
   /**
    * Returns the request status line, like "GET / HTTP/1.1". This is exposed
-   * to the application by {@link HttpURLConnectionImpl#getHeaderFields}, so
-   * it needs to be set even if the transport is SPDY.
+   * to the application by {@link HttpURLConnection#getHeaderFields}, so it
+   * needs to be set even if the transport is SPDY.
    */
-  static String get(Request request, Proxy.Type proxyType, int httpMinorVersion) {
+  static String get(Request request, Proxy.Type proxyType, Protocol protocol) {
     StringBuilder result = new StringBuilder();
     result.append(request.method());
-    result.append(" ");
+    result.append(' ');
 
     if (includeAuthorityInRequestLine(request, proxyType)) {
       result.append(request.url());
@@ -24,8 +26,8 @@ static String get(Request request, Proxy.Type proxyType, int httpMinorVersion) {
       result.append(requestPath(request.url()));
     }
 
-    result.append(" ");
-    result.append(version(httpMinorVersion));
+    result.append(' ');
+    result.append(version(protocol));
     return result.toString();
   }
 
@@ -49,7 +51,7 @@ public static String requestPath(URL url) {
     return pathAndQuery;
   }
 
-  public static String version(int httpMinorVersion) {
-    return httpMinorVersion == 1 ? "HTTP/1.1" : "HTTP/1.0";
+  public static String version(Protocol protocol) {
+    return protocol == Protocol.HTTP_1_0 ? "HTTP/1.0" : "HTTP/1.1";
   }
 }
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/http/RetryableSink.java b/okhttp/src/main/java/com/squareup/okhttp/internal/http/RetryableSink.java
index b8f53a3d84..af32e23adb 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/http/RetryableSink.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/http/RetryableSink.java
@@ -18,10 +18,10 @@
 
 import java.io.IOException;
 import java.net.ProtocolException;
+import okio.Buffer;
 import okio.BufferedSink;
-import okio.Deadline;
-import okio.OkBuffer;
 import okio.Sink;
+import okio.Timeout;
 
 import static com.squareup.okhttp.internal.Util.checkOffsetAndCount;
 
@@ -30,10 +30,10 @@
  * the post body to be transparently re-sent if the HTTP request must be
  * sent multiple times.
  */
-final class RetryableSink implements Sink {
+public final class RetryableSink implements Sink {
   private boolean closed;
   private final int limit;
-  private final OkBuffer content = new OkBuffer();
+  private final Buffer content = new Buffer();
 
   public RetryableSink(int limit) {
     this.limit = limit;
@@ -52,7 +52,7 @@ public RetryableSink() {
     }
   }
 
-  @Override public void write(OkBuffer source, long byteCount) throws IOException {
+  @Override public void write(Buffer source, long byteCount) throws IOException {
     if (closed) throw new IllegalStateException("closed");
     checkOffsetAndCount(source.size(), 0, byteCount);
     if (limit != -1 && content.size() > limit - byteCount) {
@@ -64,8 +64,8 @@ public RetryableSink() {
   @Override public void flush() throws IOException {
   }
 
-  @Override public Sink deadline(Deadline deadline) {
-    return this;
+  @Override public Timeout timeout() {
+    return Timeout.NONE;
   }
 
   public long contentLength() throws IOException {
@@ -74,6 +74,6 @@ public long contentLength() throws IOException {
 
   public void writeToSocket(BufferedSink socketOut) throws IOException {
     // Clone the content; otherwise we won't have data to retry.
-    socketOut.write(content.clone(), content.size());
+    socketOut.writeAll(content.clone());
   }
 }
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/http/RouteSelector.java b/okhttp/src/main/java/com/squareup/okhttp/internal/http/RouteSelector.java
index f935d5cd1f..50e19ef180 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/http/RouteSelector.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/http/RouteSelector.java
@@ -18,9 +18,12 @@
 import com.squareup.okhttp.Address;
 import com.squareup.okhttp.Connection;
 import com.squareup.okhttp.ConnectionPool;
+import com.squareup.okhttp.HostResolver;
+import com.squareup.okhttp.OkHttpClient;
+import com.squareup.okhttp.Request;
 import com.squareup.okhttp.Route;
-import com.squareup.okhttp.RouteDatabase;
-import com.squareup.okhttp.internal.Dns;
+import com.squareup.okhttp.internal.Internal;
+import com.squareup.okhttp.internal.RouteDatabase;
 import java.io.IOException;
 import java.net.InetAddress;
 import java.net.InetSocketAddress;
@@ -29,12 +32,14 @@
 import java.net.SocketAddress;
 import java.net.URI;
 import java.net.UnknownHostException;
+import java.util.ArrayList;
 import java.util.Iterator;
-import java.util.LinkedList;
 import java.util.List;
 import java.util.NoSuchElementException;
+import javax.net.ssl.HostnameVerifier;
 import javax.net.ssl.SSLHandshakeException;
 import javax.net.ssl.SSLProtocolException;
+import javax.net.ssl.SSLSocketFactory;
 
 import static com.squareup.okhttp.internal.Util.getEffectivePort;
 
@@ -44,19 +49,17 @@
  * recycled.
  */
 public final class RouteSelector {
-  /** Uses {@link com.squareup.okhttp.internal.Platform#enableTlsExtensions}. */
-  private static final int TLS_MODE_MODERN = 1;
-  /** Uses {@link com.squareup.okhttp.internal.Platform#supportTlsIntolerantServer}. */
-  private static final int TLS_MODE_COMPATIBLE = 0;
-  /** No TLS mode. */
-  private static final int TLS_MODE_NULL = -1;
+  public static final String TLS_V1 = "TLSv1";
+  public static final String SSL_V3 = "SSLv3";
 
   private final Address address;
   private final URI uri;
+  private final HostResolver hostResolver;
+  private final OkHttpClient client;
   private final ProxySelector proxySelector;
   private final ConnectionPool pool;
-  private final Dns dns;
   private final RouteDatabase routeDatabase;
+  private final Request request;
 
   /* The most recently attempted route. */
   private Proxy lastProxy;
@@ -72,47 +75,77 @@
   private int nextSocketAddressIndex;
   private int socketPort;
 
-  /* State for negotiating the next TLS configuration */
-  private int nextTlsMode = TLS_MODE_NULL;
+  /* TLS version to attempt with the connection. */
+  private String nextTlsVersion;
 
   /* State for negotiating failed routes */
-  private final List<Route> postponedRoutes;
+  private final List<Route> postponedRoutes = new ArrayList<>();
 
-  public RouteSelector(Address address, URI uri, ProxySelector proxySelector, ConnectionPool pool,
-      Dns dns, RouteDatabase routeDatabase) {
+  private RouteSelector(Address address, URI uri, OkHttpClient client, Request request) {
     this.address = address;
     this.uri = uri;
-    this.proxySelector = proxySelector;
-    this.pool = pool;
-    this.dns = dns;
-    this.routeDatabase = routeDatabase;
-    this.postponedRoutes = new LinkedList<Route>();
+    this.client = client;
+    this.proxySelector = client.getProxySelector();
+    this.pool = client.getConnectionPool();
+    this.routeDatabase = Internal.instance.routeDatabase(client);
+    this.hostResolver = client.getHostResolver();
+    this.request = request;
 
     resetNextProxy(uri, address.getProxy());
   }
 
+  public static RouteSelector get(Request request, OkHttpClient client) throws IOException {
+    String uriHost = request.url().getHost();
+    if (uriHost == null || uriHost.length() == 0) {
+      throw new UnknownHostException(request.url().toString());
+    }
+
+    SSLSocketFactory sslSocketFactory = null;
+    HostnameVerifier hostnameVerifier = null;
+    if (request.isHttps()) {
+      sslSocketFactory = client.getSslSocketFactory();
+      hostnameVerifier = client.getHostnameVerifier();
+    }
+
+    Address address = new Address(uriHost, getEffectivePort(request.url()),
+        client.getSocketFactory(), sslSocketFactory, hostnameVerifier, client.getAuthenticator(),
+        client.getProxy(), client.getProtocols());
+
+    return new RouteSelector(address, request.uri(), client, request);
+  }
+
   /**
    * Returns true if there's another route to attempt. Every address has at
    * least one route.
    */
   public boolean hasNext() {
-    return hasNextTlsMode() || hasNextInetSocketAddress() || hasNextProxy() || hasNextPostponed();
+    return hasNextTlsVersion()
+        || hasNextInetSocketAddress()
+        || hasNextProxy()
+        || hasNextPostponed();
+  }
+
+  /** Selects a route to attempt and connects it if it isn't already. */
+  public Connection next(HttpEngine owner) throws IOException {
+    Connection connection = nextUnconnected();
+    Internal.instance.connectAndSetOwner(client, connection, owner, request);
+    return connection;
   }
 
   /**
-   * Returns the next route address to attempt.
+   * Returns the next connection to attempt.
    *
    * @throws NoSuchElementException if there are no more routes to attempt.
    */
-  public Connection next(String method) throws IOException {
+  Connection nextUnconnected() throws IOException {
     // Always prefer pooled connections over new connections.
     for (Connection pooled; (pooled = pool.get(address)) != null; ) {
-      if (method.equals("GET") || pooled.isReadable()) return pooled;
-      pooled.close();
+      if (request.method().equals("GET") || Internal.instance.isReadable(pooled)) return pooled;
+      pooled.getSocket().close();
     }
 
     // Compute the next route to attempt.
-    if (!hasNextTlsMode()) {
+    if (!hasNextTlsVersion()) {
       if (!hasNextInetSocketAddress()) {
         if (!hasNextProxy()) {
           if (!hasNextPostponed()) {
@@ -124,16 +157,16 @@ public Connection next(String method) throws IOException {
         resetNextInetSocketAddress(lastProxy);
       }
       lastInetSocketAddress = nextInetSocketAddress();
-      resetNextTlsMode();
+      resetNextTlsVersion();
     }
 
-    boolean modernTls = nextTlsMode() == TLS_MODE_MODERN;
-    Route route = new Route(address, lastProxy, lastInetSocketAddress, modernTls);
+    String tlsVersion = nextTlsVersion();
+    Route route = new Route(address, lastProxy, lastInetSocketAddress, tlsVersion);
     if (routeDatabase.shouldPostpone(route)) {
       postponedRoutes.add(route);
       // We will only recurse in order to skip previously failed routes. They will be
       // tried last.
-      return next(method);
+      return nextUnconnected();
     }
 
     return new Connection(pool, route);
@@ -145,7 +178,7 @@ public Connection next(String method) throws IOException {
    */
   public void connectFailed(Connection connection, IOException failure) {
     // If this is a recycled connection, don't count its failure against the route.
-    if (connection.recycleCount() > 0) return;
+    if (Internal.instance.recycleCount(connection) > 0) return;
 
     Route failedRoute = connection.getRoute();
     if (failedRoute.getProxy().type() != Proxy.Type.DIRECT && proxySelector != null) {
@@ -158,12 +191,11 @@ public void connectFailed(Connection connection, IOException failure) {
     // If the previously returned route's problem was not related to TLS, and
     // the next route only changes the TLS mode, we shouldn't even attempt it.
     // This suppresses it in both this selector and also in the route database.
-    if (hasNextTlsMode()
-        && !(failure instanceof SSLHandshakeException)
-        && !(failure instanceof SSLProtocolException)) {
-      boolean modernTls = nextTlsMode() == TLS_MODE_MODERN;
-      Route routeToSuppress = new Route(address, lastProxy, lastInetSocketAddress, modernTls);
-      routeDatabase.failed(routeToSuppress);
+    if (!(failure instanceof SSLHandshakeException) && !(failure instanceof SSLProtocolException)) {
+      while (hasNextTlsVersion()) {
+        Route toSuppress = new Route(address, lastProxy, lastInetSocketAddress, nextTlsVersion());
+        routeDatabase.failed(toSuppress);
+      }
     }
   }
 
@@ -229,7 +261,7 @@ private void resetNextInetSocketAddress(Proxy proxy) throws UnknownHostException
     }
 
     // Try each address for best behavior in mixed IPv4/IPv6 environments.
-    socketAddresses = dns.getAllByName(socketHost);
+    socketAddresses = hostResolver.getAllByName(socketHost);
     nextSocketAddressIndex = 0;
   }
 
@@ -250,24 +282,29 @@ private InetSocketAddress nextInetSocketAddress() throws UnknownHostException {
     return result;
   }
 
-  /** Resets {@link #nextTlsMode} to the first option. */
-  private void resetNextTlsMode() {
-    nextTlsMode = (address.getSslSocketFactory() != null) ? TLS_MODE_MODERN : TLS_MODE_COMPATIBLE;
+  /**
+   * Resets {@link #nextTlsVersion} to the first option. For routes that don't
+   * use SSL, this returns {@link #SSL_V3} so that there is no SSL fallback.
+   */
+  private void resetNextTlsVersion() {
+    nextTlsVersion = (address.getSslSocketFactory() != null) ? TLS_V1 : SSL_V3;
   }
 
-  /** Returns true if there's another TLS mode to try. */
-  private boolean hasNextTlsMode() {
-    return nextTlsMode != TLS_MODE_NULL;
+  /** Returns true if there's another TLS version to try. */
+  private boolean hasNextTlsVersion() {
+    return nextTlsVersion != null;
   }
 
   /** Returns the next TLS mode to try. */
-  private int nextTlsMode() {
-    if (nextTlsMode == TLS_MODE_MODERN) {
-      nextTlsMode = TLS_MODE_COMPATIBLE;
-      return TLS_MODE_MODERN;
-    } else if (nextTlsMode == TLS_MODE_COMPATIBLE) {
-      nextTlsMode = TLS_MODE_NULL;  // So that hasNextTlsMode() returns false.
-      return TLS_MODE_COMPATIBLE;
+  private String nextTlsVersion() {
+    if (nextTlsVersion == null) {
+      throw new IllegalStateException("No next TLS version");
+    } else if (nextTlsVersion.equals(TLS_V1)) {
+      nextTlsVersion = SSL_V3;
+      return TLS_V1;
+    } else if (nextTlsVersion.equals(SSL_V3)) {
+      nextTlsVersion = null;  // So that hasNextTlsVersion() returns false.
+      return SSL_V3;
     } else {
       throw new AssertionError();
     }
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/http/SpdyTransport.java b/okhttp/src/main/java/com/squareup/okhttp/internal/http/SpdyTransport.java
index e775d347c6..e07d105dc2 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/http/SpdyTransport.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/http/SpdyTransport.java
@@ -26,20 +26,18 @@
 import com.squareup.okhttp.internal.spdy.SpdyConnection;
 import com.squareup.okhttp.internal.spdy.SpdyStream;
 import java.io.IOException;
-import java.io.OutputStream;
-import java.net.CacheRequest;
 import java.net.ProtocolException;
 import java.util.ArrayList;
 import java.util.LinkedHashSet;
 import java.util.List;
 import java.util.Locale;
 import java.util.Set;
+import java.util.concurrent.TimeUnit;
+import okio.Buffer;
 import okio.ByteString;
-import okio.Deadline;
-import okio.OkBuffer;
-import okio.Okio;
 import okio.Sink;
 import okio.Source;
+import okio.Timeout;
 
 import static com.squareup.okhttp.internal.spdy.Header.RESPONSE_STATUS;
 import static com.squareup.okhttp.internal.spdy.Header.TARGET_AUTHORITY;
@@ -90,11 +88,11 @@ public SpdyTransport(HttpEngine httpEngine, SpdyConnection spdyConnection) {
     httpEngine.writingRequestHeaders();
     boolean hasRequestBody = httpEngine.hasRequestBody();
     boolean hasResponseBody = true;
-    String version = RequestLine.version(httpEngine.getConnection().getHttpMinorVersion());
+    String version = RequestLine.version(httpEngine.getConnection().getProtocol());
     stream = spdyConnection.newStream(
         writeNameValueBlock(request, spdyConnection.getProtocol(), version), hasRequestBody,
         hasResponseBody);
-    stream.setReadTimeout(httpEngine.client.getReadTimeout());
+    stream.readTimeout().timeout(httpEngine.client.getReadTimeout(), TimeUnit.MILLISECONDS);
   }
 
   @Override public void writeRequestBody(RetryableSink requestBody) throws IOException {
@@ -117,8 +115,7 @@ public SpdyTransport(HttpEngine httpEngine, SpdyConnection spdyConnection) {
   public static List<Header> writeNameValueBlock(Request request, Protocol protocol,
       String version) {
     Headers headers = request.headers();
-    // TODO: make the known header names constants.
-    List<Header> result = new ArrayList<Header>(headers.size() + 10);
+    List<Header> result = new ArrayList<>(headers.size() + 10);
     result.add(new Header(TARGET_METHOD, request.method()));
     result.add(new Header(TARGET_PATH, RequestLine.requestPath(request.url())));
     String host = HttpEngine.hostHeader(request.url());
@@ -126,7 +123,7 @@ public SpdyTransport(HttpEngine httpEngine, SpdyConnection spdyConnection) {
       result.add(new Header(VERSION, version));
       result.add(new Header(TARGET_HOST, host));
     } else if (Protocol.HTTP_2 == protocol) {
-      result.add(new Header(TARGET_AUTHORITY, host));
+      result.add(new Header(TARGET_AUTHORITY, host)); // Optional in HTTP/2
     } else {
       throw new AssertionError();
     }
@@ -180,7 +177,7 @@ private static String joinOnNull(String first, String second) {
     String version = "HTTP/1.1"; // :version present only in spdy/3.
 
     Headers.Builder headersBuilder = new Headers.Builder();
-    headersBuilder.set(OkHeaders.SELECTED_PROTOCOL, protocol.name.utf8());
+    headersBuilder.set(OkHeaders.SELECTED_PROTOCOL, protocol.toString());
     for (int i = 0; i < headerBlock.size(); i++) {
       ByteString name = headerBlock.get(i).name;
       String values = headerBlock.get(i).value.utf8();
@@ -203,8 +200,11 @@ private static String joinOnNull(String first, String second) {
     if (status == null) throw new ProtocolException("Expected ':status' header not present");
     if (version == null) throw new ProtocolException("Expected ':version' header not present");
 
+    StatusLine statusLine = StatusLine.parse(version + " " + status);
     return new Response.Builder()
-        .statusLine(new StatusLine(version + " " + status))
+        .protocol(protocol)
+        .code(statusLine.code)
+        .message(statusLine.message)
         .headers(headersBuilder.build());
   }
 
@@ -219,6 +219,10 @@ private static String joinOnNull(String first, String second) {
   @Override public void releaseConnectionOnIdle() {
   }
 
+  @Override public void disconnect(HttpEngine engine) throws IOException {
+    stream.close(ErrorCode.CANCEL);
+  }
+
   @Override public boolean canReuseConnection() {
     return true; // TODO: spdyConnection.isClosed() ?
   }
@@ -239,7 +243,7 @@ private static boolean isProhibitedHeader(Protocol protocol, ByteString name) {
     private final SpdyStream stream;
     private final Source source;
     private final CacheRequest cacheRequest;
-    private final OutputStream cacheBody;
+    private final Sink cacheBody;
 
     private boolean inputExhausted;
     private boolean closed;
@@ -249,7 +253,7 @@ private static boolean isProhibitedHeader(Protocol protocol, ByteString name) {
       this.source = stream.getSource();
 
       // Some apps return a null body; for compatibility we treat that like a null cache request.
-      OutputStream cacheBody = cacheRequest != null ? cacheRequest.getBody() : null;
+      Sink cacheBody = cacheRequest != null ? cacheRequest.body() : null;
       if (cacheBody == null) {
         cacheRequest = null;
       }
@@ -258,13 +262,13 @@ private static boolean isProhibitedHeader(Protocol protocol, ByteString name) {
       this.cacheRequest = cacheRequest;
     }
 
-    @Override public long read(OkBuffer sink, long byteCount)
+    @Override public long read(Buffer buffer, long byteCount)
         throws IOException {
       if (byteCount < 0) throw new IllegalArgumentException("byteCount < 0: " + byteCount);
       if (closed) throw new IllegalStateException("closed");
       if (inputExhausted) return -1;
 
-      long read = source.read(sink, byteCount);
+      long read = source.read(buffer, byteCount);
       if (read == -1) {
         inputExhausted = true;
         if (cacheRequest != null) {
@@ -274,15 +278,15 @@ private static boolean isProhibitedHeader(Protocol protocol, ByteString name) {
       }
 
       if (cacheBody != null) {
-        Okio.copy(sink, sink.size() - read, read, cacheBody);
+        // TODO get buffer.copyTo(cacheBody, read);
+        cacheBody.write(buffer.clone(), read);
       }
 
       return read;
     }
 
-    @Override public Source deadline(Deadline deadline) {
-      source.deadline(deadline);
-      return this;
+    @Override public Timeout timeout() {
+      return source.timeout();
     }
 
     @Override public void close() throws IOException {
@@ -303,18 +307,15 @@ private static boolean isProhibitedHeader(Protocol protocol, ByteString name) {
     }
 
     private boolean discardStream() {
+      long oldTimeoutNanos = stream.readTimeout().timeoutNanos();
+      stream.readTimeout().timeout(DISCARD_STREAM_TIMEOUT_MILLIS, TimeUnit.MILLISECONDS);
       try {
-        long socketTimeout = stream.getReadTimeoutMillis();
-        stream.setReadTimeout(socketTimeout);
-        stream.setReadTimeout(DISCARD_STREAM_TIMEOUT_MILLIS);
-        try {
-          Util.skipAll(this, DISCARD_STREAM_TIMEOUT_MILLIS);
-          return true;
-        } finally {
-          stream.setReadTimeout(socketTimeout);
-        }
+        Util.skipAll(this, DISCARD_STREAM_TIMEOUT_MILLIS);
+        return true;
       } catch (IOException e) {
         return false;
+      } finally {
+        stream.readTimeout().timeout(oldTimeoutNanos, TimeUnit.NANOSECONDS);
       }
     }
   }
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/http/StatusLine.java b/okhttp/src/main/java/com/squareup/okhttp/internal/http/StatusLine.java
index d295891392..7416981277 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/http/StatusLine.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/http/StatusLine.java
@@ -1,38 +1,53 @@
 package com.squareup.okhttp.internal.http;
 
+import com.squareup.okhttp.Protocol;
+import com.squareup.okhttp.Response;
 import java.io.IOException;
 import java.net.ProtocolException;
 
+/** An HTTP response status line like "HTTP/1.1 200 OK". */
 public final class StatusLine {
   /** Numeric status code, 307: Temporary Redirect. */
   public static final int HTTP_TEMP_REDIRECT = 307;
   public static final int HTTP_CONTINUE = 100;
 
-  private final String statusLine;
-  private final int httpMinorVersion;
-  private final int responseCode;
-  private final String responseMessage;
+  public final Protocol protocol;
+  public final int code;
+  public final String message;
 
-  /** Sets the response status line (like "HTTP/1.0 200 OK"). */
-  public StatusLine(String statusLine) throws IOException {
+  public StatusLine(Protocol protocol, int code, String message) {
+    this.protocol = protocol;
+    this.code = code;
+    this.message = message;
+  }
+
+  public static StatusLine get(Response response) {
+    return new StatusLine(response.protocol(), response.code(), response.message());
+  }
+
+  public static StatusLine parse(String statusLine) throws IOException {
     // H T T P / 1 . 1   2 0 0   T e m p o r a r y   R e d i r e c t
     // 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0
 
     // Parse protocol like "HTTP/1.1" followed by a space.
     int codeStart;
-    int httpMinorVersion;
+    Protocol protocol;
     if (statusLine.startsWith("HTTP/1.")) {
       if (statusLine.length() < 9 || statusLine.charAt(8) != ' ') {
         throw new ProtocolException("Unexpected status line: " + statusLine);
       }
-      httpMinorVersion = statusLine.charAt(7) - '0';
+      int httpMinorVersion = statusLine.charAt(7) - '0';
       codeStart = 9;
-      if (httpMinorVersion < 0 || httpMinorVersion > 9) {
+      if (httpMinorVersion == 0) {
+        protocol = Protocol.HTTP_1_0;
+      } else if (httpMinorVersion == 1) {
+        protocol = Protocol.HTTP_1_1;
+      } else {
         throw new ProtocolException("Unexpected status line: " + statusLine);
       }
     } else if (statusLine.startsWith("ICY ")) {
       // Shoutcast uses ICY instead of "HTTP/1.0".
-      httpMinorVersion = 0;
+      protocol = Protocol.HTTP_1_0;
       codeStart = 4;
     } else {
       throw new ProtocolException("Unexpected status line: " + statusLine);
@@ -42,48 +57,33 @@ public StatusLine(String statusLine) throws IOException {
     if (statusLine.length() < codeStart + 3) {
       throw new ProtocolException("Unexpected status line: " + statusLine);
     }
-    int responseCode;
+    int code;
     try {
-      responseCode = Integer.parseInt(statusLine.substring(codeStart, codeStart + 3));
+      code = Integer.parseInt(statusLine.substring(codeStart, codeStart + 3));
     } catch (NumberFormatException e) {
       throw new ProtocolException("Unexpected status line: " + statusLine);
     }
 
     // Parse an optional response message like "OK" or "Not Modified". If it
     // exists, it is separated from the response code by a space.
-    String responseMessage = "";
+    String message = "";
     if (statusLine.length() > codeStart + 3) {
       if (statusLine.charAt(codeStart + 3) != ' ') {
         throw new ProtocolException("Unexpected status line: " + statusLine);
       }
-      responseMessage = statusLine.substring(codeStart + 4);
+      message = statusLine.substring(codeStart + 4);
     }
 
-    this.responseMessage = responseMessage;
-    this.responseCode = responseCode;
-    this.statusLine = statusLine;
-    this.httpMinorVersion = httpMinorVersion;
-  }
-
-  public String getStatusLine() {
-    return statusLine;
+    return new StatusLine(protocol, code, message);
   }
 
-  /**
-   * Returns the status line's HTTP minor version. This returns 0 for HTTP/1.0
-   * and 1 for HTTP/1.1. This returns 1 if the HTTP version is unknown.
-   */
-  public int httpMinorVersion() {
-    return httpMinorVersion != -1 ? httpMinorVersion : 1;
-  }
-
-  /** Returns the HTTP status code or -1 if it is unknown. */
-  public int code() {
-    return responseCode;
-  }
-
-  /** Returns the HTTP status message or null if it is unknown. */
-  public String message() {
-    return responseMessage;
+  @Override public String toString() {
+    StringBuilder result = new StringBuilder();
+    result.append(protocol == Protocol.HTTP_1_0 ? "HTTP/1.0" : "HTTP/1.1");
+    result.append(' ').append(code);
+    if (message != null) {
+      result.append(' ').append(message);
+    }
+    return result.toString();
   }
 }
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/http/Transport.java b/okhttp/src/main/java/com/squareup/okhttp/internal/http/Transport.java
index 94c90d48e4..05a398ab80 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/http/Transport.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/http/Transport.java
@@ -19,11 +19,10 @@
 import com.squareup.okhttp.Request;
 import com.squareup.okhttp.Response;
 import java.io.IOException;
-import java.net.CacheRequest;
 import okio.Sink;
 import okio.Source;
 
-interface Transport {
+public interface Transport {
   /**
    * The timeout to use while discarding a stream of input data. Since this is
    * used for connection reuse, this timeout should be significantly less than
@@ -76,6 +75,8 @@
    */
   void releaseConnectionOnIdle() throws IOException;
 
+  void disconnect(HttpEngine engine) throws IOException;
+
   /**
    * Returns true if the socket connection held by this transport can be reused
    * for a follow-up exchange.
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/ErrorCode.java b/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/ErrorCode.java
index 045677b5dd..d1031258bc 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/ErrorCode.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/ErrorCode.java
@@ -1,7 +1,21 @@
+/*
+ * Copyright (C) 2013 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 package com.squareup.okhttp.internal.spdy;
 
-// TODO: revisit for http/2 draft 9
-// http://tools.ietf.org/html/draft-ietf-httpbis-http2-09#section-7
+// http://tools.ietf.org/html/draft-ietf-httpbis-http2-14#section-7
 public enum ErrorCode {
   /** Not an error! For SPDY stream resets, prefer null over NO_ERROR. */
   NO_ERROR(0, -1, 0),
@@ -34,6 +48,12 @@
 
   COMPRESSION_ERROR(9, -1, -1),
 
+  CONNECT_ERROR(10, -1, -1),
+
+  ENHANCE_YOUR_CALM(11, -1, -1),
+
+  INADEQUATE_SECURITY(12, -1, -1),
+
   INVALID_CREDENTIALS(-1, 10, -1);
 
   public final int httpCode;
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/FrameReader.java b/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/FrameReader.java
index c87226a612..f9b3a66480 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/FrameReader.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/FrameReader.java
@@ -24,7 +24,7 @@
 
 /** Reads transport frames for SPDY/3 or HTTP/2. */
 public interface FrameReader extends Closeable {
-  void readConnectionHeader() throws IOException;
+  void readConnectionPreface() throws IOException;
   boolean nextFrame(Handler handler) throws IOException;
 
   public interface Handler {
@@ -40,13 +40,10 @@ void data(boolean inFinished, int streamId, BufferedSource source, int length)
      * @param inFinished true if the sender will not send further frames.
      * @param streamId the stream owning these headers.
      * @param associatedStreamId the stream that triggered the sender to create
-     * this stream.
-     * @param priority or -1 for no priority. For SPDY, priorities range from 0
-     * (highest) thru 7 (lowest). For HTTP/2, priorities range from 0
-     * (highest) thru 2^31-1 (lowest), defaulting to 2^30.
+     *     this stream.
      */
     void headers(boolean outFinished, boolean inFinished, int streamId, int associatedStreamId,
-        int priority, List<Header> headerBlock, HeadersMode headersMode);
+        List<Header> headerBlock, HeadersMode headersMode);
     void rstStream(int streamId, ErrorCode errorCode);
     void settings(boolean clearPrevious, Settings settings);
 
@@ -76,7 +73,7 @@ void headers(boolean outFinished, boolean inFinished, int streamId, int associat
      *     sending this message. If {@code lastGoodStreamId} is zero, the peer
      *     processed no frames.
      * @param errorCode reason for closing the connection.
-     * @param debugData only valid for http/2; opaque debug data to send.
+     * @param debugData only valid for HTTP/2; opaque debug data to send.
      */
     void goAway(int lastGoodStreamId, ErrorCode errorCode, ByteString debugData);
 
@@ -85,7 +82,18 @@ void headers(boolean outFinished, boolean inFinished, int streamId, int associat
      * sent on {@code streamId}, or the connection if {@code streamId} is zero.
      */
     void windowUpdate(int streamId, long windowSizeIncrement);
-    void priority(int streamId, int priority);
+
+    /**
+     * Called when reading a headers or priority frame. This may be used to
+     * change the stream's weight from the default (16) to a new value.
+     *
+     * @param streamId stream which has a priority change.
+     * @param streamDependency the stream ID this stream is dependent on.
+     * @param weight relative proportion of priority in [1..256].
+     * @param exclusive inserts this stream ID as the sole child of
+     *     {@code streamDependency}.
+     */
+    void priority(int streamId, int streamDependency, int weight, boolean exclusive);
 
     /**
      * HTTP/2 only. Receive a push promise header block.
@@ -93,8 +101,7 @@ void headers(boolean outFinished, boolean inFinished, int streamId, int associat
      * A push promise contains all the headers that pertain to a server-initiated
      * request, and a {@code promisedStreamId} to which response frames will be
      * delivered. Push promise frames are sent as a part of the response to
-     * {@code streamId}.  The {@code promisedStreamId} has a priority of one
-     * greater than {@code streamId}.
+     * {@code streamId}.
      *
      * @param streamId client-initiated stream ID.  Must be an odd number.
      * @param promisedStreamId server-initiated stream ID.  Must be an even
@@ -104,5 +111,27 @@ void headers(boolean outFinished, boolean inFinished, int streamId, int associat
      */
     void pushPromise(int streamId, int promisedStreamId, List<Header> requestHeaders)
         throws IOException;
+
+    /**
+     * HTTP/2 only. Expresses that resources for the connection or a client-
+     * initiated stream are available from a different network location or
+     * protocol configuration.
+     *
+     * <p>See <a href="https://tools.ietf.org/html/draft-ietf-httpbis-alt-svc-01">alt-svc</a>
+     *
+     * @param streamId when a client-initiated stream ID (odd number), the
+     *     origin of this alternate service is the origin of the stream. When
+     *     zero, the origin is specified in the {@code origin} parameter.
+     * @param origin when present, the
+     *     <a href="http://tools.ietf.org/html/rfc6454">origin</a> is typically
+     *     represented as a combination of scheme, host and port. When empty,
+     *     the origin is that of the {@code streamId}.
+     * @param protocol an ALPN protocol, such as {@code h2}.
+     * @param host an IP address or hostname.
+     * @param port the IP port associated with the service.
+     * @param maxAge time in seconds that this alternative is considered fresh.
+     */
+    void alternateService(int streamId, String origin, ByteString protocol, String host, int port,
+        long maxAge);
   }
 }
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/FrameWriter.java b/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/FrameWriter.java
index f96c2aa095..0f4b799366 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/FrameWriter.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/FrameWriter.java
@@ -19,13 +19,14 @@
 import java.io.Closeable;
 import java.io.IOException;
 import java.util.List;
-import okio.OkBuffer;
+import okio.Buffer;
 
 /** Writes transport frames for SPDY/3 or HTTP/2. */
 public interface FrameWriter extends Closeable {
   /** HTTP/2 only. */
-  void connectionHeader() throws IOException;
-  void ackSettings() throws IOException;
+  void connectionPreface() throws IOException;
+  /** Informs the peer that we've applied its latest settings. */
+  void ackSettings(Settings peerSettings) throws IOException;
 
   /**
    * HTTP/2 only. Send a push promise header block.
@@ -48,21 +49,24 @@ void pushPromise(int streamId, int promisedStreamId, List<Header> requestHeaders
   /** SPDY/3 only. */
   void flush() throws IOException;
   void synStream(boolean outFinished, boolean inFinished, int streamId, int associatedStreamId,
-      int priority, int slot, List<Header> headerBlock) throws IOException;
+      List<Header> headerBlock) throws IOException;
   void synReply(boolean outFinished, int streamId, List<Header> headerBlock)
       throws IOException;
   void headers(int streamId, List<Header> headerBlock) throws IOException;
   void rstStream(int streamId, ErrorCode errorCode) throws IOException;
 
+  /** The maximum size of bytes that may be sent in a single call to {@link #data}. */
+  int maxDataLength();
+
   /**
-   * {@code data.length} may be longer than the max length of the variant's data frame.
+   * {@code source.length} may be longer than the max length of the variant's data frame.
    * Implementations must send multiple frames as necessary.
    *
    * @param source the buffer to draw bytes from. May be null if byteCount is 0.
+   * @param byteCount must be between 0 and the minimum of {code source.length}
+   * and {@link #maxDataLength}.
    */
-  void data(boolean outFinished, int streamId, OkBuffer source, int byteCount) throws IOException;
-
-  void data(boolean outFinished, int streamId, OkBuffer source) throws IOException;
+  void data(boolean outFinished, int streamId, Buffer source, int byteCount) throws IOException;
 
   /** Write okhttp's settings to the peer. */
   void settings(Settings okHttpSettings) throws IOException;
@@ -87,7 +91,7 @@ void synReply(boolean outFinished, int streamId, List<Header> headerBlock)
    * @param lastGoodStreamId the last stream ID processed, or zero if no
    * streams were processed.
    * @param errorCode reason for closing the connection.
-   * @param debugData only valid for http/2; opaque debug data to send.
+   * @param debugData only valid for HTTP/2; opaque debug data to send.
    */
   void goAway(int lastGoodStreamId, ErrorCode errorCode, byte[] debugData) throws IOException;
 
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/Header.java b/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/Header.java
index 1e9b50312e..d14d13115d 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/Header.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/Header.java
@@ -9,7 +9,7 @@
   public static final ByteString TARGET_METHOD = ByteString.encodeUtf8(":method");
   public static final ByteString TARGET_PATH = ByteString.encodeUtf8(":path");
   public static final ByteString TARGET_SCHEME = ByteString.encodeUtf8(":scheme");
-  public static final ByteString TARGET_AUTHORITY = ByteString.encodeUtf8(":authority"); // http/2
+  public static final ByteString TARGET_AUTHORITY = ByteString.encodeUtf8(":authority"); // HTTP/2
   public static final ByteString TARGET_HOST = ByteString.encodeUtf8(":host"); // spdy/3
   public static final ByteString VERSION = ByteString.encodeUtf8(":version"); // spdy/3
 
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/HeadersMode.java b/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/HeadersMode.java
index e16e176a16..c06327acf4 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/HeadersMode.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/HeadersMode.java
@@ -15,7 +15,7 @@
  */
 package com.squareup.okhttp.internal.spdy;
 
-enum HeadersMode {
+public enum HeadersMode {
   SPDY_SYN_STREAM,
   SPDY_REPLY,
   SPDY_HEADERS,
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/HpackDraft05.java b/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/HpackDraft09.java
similarity index 63%
rename from okhttp/src/main/java/com/squareup/okhttp/internal/spdy/HpackDraft05.java
rename to okhttp/src/main/java/com/squareup/okhttp/internal/spdy/HpackDraft09.java
index f1257116df..91bdbf1c78 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/HpackDraft05.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/HpackDraft09.java
@@ -1,6 +1,20 @@
+/*
+ * Copyright (C) 2013 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 package com.squareup.okhttp.internal.spdy;
 
-import com.squareup.okhttp.internal.BitArray;
 import java.io.IOException;
 import java.util.ArrayList;
 import java.util.Arrays;
@@ -8,25 +22,26 @@
 import java.util.LinkedHashMap;
 import java.util.List;
 import java.util.Map;
+import okio.Buffer;
 import okio.BufferedSource;
 import okio.ByteString;
-import okio.OkBuffer;
 import okio.Okio;
 import okio.Source;
 
 /**
- * Read and write HPACK v05.
+ * Read and write HPACK v09.
  *
- * http://tools.ietf.org/html/draft-ietf-httpbis-header-compression-05
+ * http://tools.ietf.org/html/draft-ietf-httpbis-header-compression-09
  *
- * This implementation uses an array for the header table with a bitset for
- * references.  Dynamic entries are added to the array, starting in the last
- * position moving forward.  When the array fills, it is doubled.
+ * This implementation uses an array for the header table and a list for
+ * indexed entries.  Dynamic entries are added to the array, starting in the
+ * last position moving forward.  When the array fills, it is doubled.
  */
-final class HpackDraft05 {
+final class HpackDraft09 {
+  private static final int PREFIX_4_BITS = 0x0f;
+  private static final int PREFIX_5_BITS = 0x1f;
   private static final int PREFIX_6_BITS = 0x3f;
   private static final int PREFIX_7_BITS = 0x7f;
-  private static final int PREFIX_8_BITS = 0xff;
 
   private static final Header[] STATIC_HEADER_TABLE = new Header[] {
       new Header(Header.TARGET_AUTHORITY, ""),
@@ -37,13 +52,14 @@
       new Header(Header.TARGET_SCHEME, "http"),
       new Header(Header.TARGET_SCHEME, "https"),
       new Header(Header.RESPONSE_STATUS, "200"),
-      new Header(Header.RESPONSE_STATUS, "500"),
-      new Header(Header.RESPONSE_STATUS, "404"),
-      new Header(Header.RESPONSE_STATUS, "403"),
+      new Header(Header.RESPONSE_STATUS, "204"),
+      new Header(Header.RESPONSE_STATUS, "206"),
+      new Header(Header.RESPONSE_STATUS, "304"),
       new Header(Header.RESPONSE_STATUS, "400"),
-      new Header(Header.RESPONSE_STATUS, "401"),
+      new Header(Header.RESPONSE_STATUS, "404"),
+      new Header(Header.RESPONSE_STATUS, "500"),
       new Header("accept-charset", ""),
-      new Header("accept-encoding", ""),
+      new Header("accept-encoding", "gzip, deflate"),
       new Header("accept-language", ""),
       new Header("accept-ranges", ""),
       new Header("accept", ""),
@@ -91,40 +107,27 @@
       new Header("www-authenticate", "")
   };
 
-  private HpackDraft05() {
+  private HpackDraft09() {
   }
 
-  // http://tools.ietf.org/html/draft-ietf-httpbis-header-compression-05#section-4.1.2
+  // http://tools.ietf.org/html/draft-ietf-httpbis-header-compression-09#section-3.2
   static final class Reader {
-    private final Huffman.Codec huffmanCodec;
 
-    private final List<Header> emittedHeaders = new ArrayList<Header>();
+    private final List<Header> headerList = new ArrayList<>();
     private final BufferedSource source;
-    private int maxHeaderTableByteCount;
 
+    private int maxHeaderTableByteCountSetting;
+    private int maxHeaderTableByteCount;
     // Visible for testing.
     Header[] headerTable = new Header[8];
     // Array is populated back to front, so new entries always have lowest index.
     int nextHeaderIndex = headerTable.length - 1;
     int headerCount = 0;
-
-    /**
-     * Set bit positions indicate {@code headerTable[pos]} should be emitted.
-     */
-    // Using a BitArray as it has left-shift operator.
-    BitArray referencedHeaders = new BitArray.FixedCapacity();
-
-    /**
-     * Set bit positions indicate {@code STATIC_HEADER_TABLE[pos]} should be
-     * emitted.
-     */
-    // Using a long since the static table < 64 entries.
-    long referencedStaticHeaders = 0L;
     int headerTableByteCount = 0;
 
-    Reader(boolean client, int maxHeaderTableByteCount, Source source) {
-      this.huffmanCodec = client ? Huffman.Codec.RESPONSE : Huffman.Codec.REQUEST;
-      this.maxHeaderTableByteCount = maxHeaderTableByteCount;
+    Reader(int maxHeaderTableByteCountSetting, Source source) {
+      this.maxHeaderTableByteCountSetting = maxHeaderTableByteCountSetting;
+      this.maxHeaderTableByteCount = maxHeaderTableByteCountSetting;
       this.source = Okio.buffer(source);
     }
 
@@ -134,11 +137,18 @@ int maxHeaderTableByteCount() {
 
     /**
      * Called by the reader when the peer sent a new header table size setting.
-     * <p>
-     * Evicts entries or clears the table as needed.
+     * While this establishes the maximum header table size, the
+     * {@link #maxHeaderTableByteCount} set during processing may limit the
+     * table size to a smaller amount.
+     * <p> Evicts entries or clears the table as needed.
      */
-    void maxHeaderTableByteCount(int newMaxHeaderTableByteCount) {
-      this.maxHeaderTableByteCount = newMaxHeaderTableByteCount;
+    void maxHeaderTableByteCountSetting(int newMaxHeaderTableByteCountSetting) {
+      this.maxHeaderTableByteCountSetting = newMaxHeaderTableByteCountSetting;
+      this.maxHeaderTableByteCount = maxHeaderTableByteCountSetting;
+      adjustHeaderTableByteCount();
+    }
+
+    private void adjustHeaderTableByteCount() {
       if (maxHeaderTableByteCount < headerTableByteCount) {
         if (maxHeaderTableByteCount == 0) {
           clearHeaderTable();
@@ -149,7 +159,7 @@ void maxHeaderTableByteCount(int newMaxHeaderTableByteCount) {
     }
 
     private void clearHeaderTable() {
-      clearReferenceSet();
+      headerList.clear();
       Arrays.fill(headerTable, null);
       nextHeaderIndex = headerTable.length - 1;
       headerCount = 0;
@@ -167,7 +177,6 @@ private int evictToRecoverBytes(int bytesToRecover) {
           headerCount--;
           entriesToEvict++;
         }
-        referencedHeaders.shiftLeft(entriesToEvict);
         System.arraycopy(headerTable, nextHeaderIndex + 1, headerTable,
             nextHeaderIndex + 1 + entriesToEvict, headerCount);
         nextHeaderIndex += entriesToEvict;
@@ -176,74 +185,54 @@ private int evictToRecoverBytes(int bytesToRecover) {
     }
 
     /**
-     * Read {@code byteCount} bytes of headers from the source stream into the
-     * set of emitted headers.
+     * Read {@code byteCount} bytes of headers from the source stream. This
+     * implementation does not propagate the never indexed flag of a header.
      */
     void readHeaders() throws IOException {
       while (!source.exhausted()) {
         int b = source.readByte() & 0xff;
         if (b == 0x80) { // 10000000
-          clearReferenceSet();
+          throw new IOException("index == 0");
         } else if ((b & 0x80) == 0x80) { // 1NNNNNNN
           int index = readInt(b, PREFIX_7_BITS);
           readIndexedHeader(index - 1);
-        } else { // 0NNNNNNN
-          if (b == 0x40) { // 01000000
-            readLiteralHeaderWithoutIndexingNewName();
-          } else if ((b & 0x40) == 0x40) {  // 01NNNNNN
-            int index = readInt(b, PREFIX_6_BITS);
-            readLiteralHeaderWithoutIndexingIndexedName(index - 1);
-          } else if (b == 0) { // 00000000
-            readLiteralHeaderWithIncrementalIndexingNewName();
-          } else if ((b & 0xc0) == 0) { // 00NNNNNN
-            int index = readInt(b, PREFIX_6_BITS);
-            readLiteralHeaderWithIncrementalIndexingIndexedName(index - 1);
-          } else {
-            // TODO: we should throw something that we can coerce to a PROTOCOL_ERROR
-            throw new AssertionError("unhandled byte: " + Integer.toBinaryString(b));
+        } else if (b == 0x40) { // 01000000
+          readLiteralHeaderWithIncrementalIndexingNewName();
+        } else if ((b & 0x40) == 0x40) {  // 01NNNNNN
+          int index = readInt(b, PREFIX_6_BITS);
+          readLiteralHeaderWithIncrementalIndexingIndexedName(index - 1);
+        } else if ((b & 0x20) == 0x20) {  // 001NNNNN
+          maxHeaderTableByteCount = readInt(b, PREFIX_5_BITS);
+          if (maxHeaderTableByteCount < 0
+              || maxHeaderTableByteCount > maxHeaderTableByteCountSetting) {
+            throw new IOException("Invalid header table byte count " + maxHeaderTableByteCount);
           }
+          adjustHeaderTableByteCount();
+        } else if (b == 0x10 || b == 0) { // 000?0000 - Ignore never indexed bit.
+          readLiteralHeaderWithoutIndexingNewName();
+        } else { // 000?NNNN - Ignore never indexed bit.
+          int index = readInt(b, PREFIX_4_BITS);
+          readLiteralHeaderWithoutIndexingIndexedName(index - 1);
         }
       }
     }
 
-    private void clearReferenceSet() {
-      referencedStaticHeaders = 0L;
-      referencedHeaders.clear();
-    }
-
-    void emitReferenceSet() {
-      for (int i = 0; i < STATIC_HEADER_TABLE.length; ++i) {
-        if (((referencedStaticHeaders >> i) & 1L) == 1) {
-          emittedHeaders.add(STATIC_HEADER_TABLE[i]);
-        }
-      }
-      for (int i = headerTable.length - 1; i != nextHeaderIndex; --i) {
-        if (referencedHeaders.get(i)) {
-          emittedHeaders.add(headerTable[i]);
-        }
-      }
-    }
-
-    /**
-     * Returns all headers emitted since they were last cleared, then clears the
-     * emitted headers.
-     */
-    List<Header> getAndReset() {
-      List<Header> result = new ArrayList<Header>(emittedHeaders);
-      emittedHeaders.clear();
+    public List<Header> getAndResetHeaderList() {
+      List<Header> result = new ArrayList<>(headerList);
+      headerList.clear();
       return result;
     }
 
-    private void readIndexedHeader(int index) {
+    private void readIndexedHeader(int index) throws IOException {
       if (isStaticHeader(index)) {
-        if (maxHeaderTableByteCount == 0) {
-          referencedStaticHeaders |= (1L << (index - headerCount));
-        } else {
-          Header staticEntry = STATIC_HEADER_TABLE[index - headerCount];
-          insertIntoHeaderTable(-1, staticEntry);
-        }
+        Header staticEntry = STATIC_HEADER_TABLE[index];
+        headerList.add(staticEntry);
       } else {
-        referencedHeaders.toggle(headerTableIndex(index));
+        int headerTableIndex = headerTableIndex(index - STATIC_HEADER_TABLE.length);
+        if (headerTableIndex < 0 || headerTableIndex > headerTable.length - 1) {
+          throw new IOException("Header index too large " + (index + 1));
+        }
+        headerList.add(headerTable[headerTableIndex]);
       }
     }
 
@@ -254,43 +243,45 @@ private int headerTableIndex(int index) {
 
     private void readLiteralHeaderWithoutIndexingIndexedName(int index) throws IOException {
       ByteString name = getName(index);
-      ByteString value = readByteString(false);
-      emittedHeaders.add(new Header(name, value));
+      ByteString value = readByteString();
+      headerList.add(new Header(name, value));
     }
 
     private void readLiteralHeaderWithoutIndexingNewName() throws IOException {
-      ByteString name = readByteString(true);
-      ByteString value = readByteString(false);
-      emittedHeaders.add(new Header(name, value));
+      ByteString name = checkLowercase(readByteString());
+      ByteString value = readByteString();
+      headerList.add(new Header(name, value));
     }
 
     private void readLiteralHeaderWithIncrementalIndexingIndexedName(int nameIndex)
         throws IOException {
       ByteString name = getName(nameIndex);
-      ByteString value = readByteString(false);
+      ByteString value = readByteString();
       insertIntoHeaderTable(-1, new Header(name, value));
     }
 
     private void readLiteralHeaderWithIncrementalIndexingNewName() throws IOException {
-      ByteString name = readByteString(true);
-      ByteString value = readByteString(false);
+      ByteString name = checkLowercase(readByteString());
+      ByteString value = readByteString();
       insertIntoHeaderTable(-1, new Header(name, value));
     }
 
     private ByteString getName(int index) {
       if (isStaticHeader(index)) {
-        return STATIC_HEADER_TABLE[index - headerCount].name;
+        return STATIC_HEADER_TABLE[index].name;
       } else {
-        return headerTable[headerTableIndex(index)].name;
+        return headerTable[headerTableIndex(index - STATIC_HEADER_TABLE.length)].name;
       }
     }
 
     private boolean isStaticHeader(int index) {
-      return index >= headerCount;
+      return index >= 0 && index <= STATIC_HEADER_TABLE.length - 1;
     }
 
     /** index == -1 when new. */
     private void insertIntoHeaderTable(int index, Header entry) {
+      headerList.add(entry);
+
       int delta = entry.hpackSize;
       if (index != -1) { // Index -1 == new header.
         delta -= headerTable[headerTableIndex(index)].hpackSize;
@@ -299,8 +290,6 @@ private void insertIntoHeaderTable(int index, Header entry) {
       // if the new or replacement header is too big, drop all entries.
       if (delta > maxHeaderTableByteCount) {
         clearHeaderTable();
-        // emit the large header to the callback.
-        emittedHeaders.add(entry);
         return;
       }
 
@@ -308,24 +297,18 @@ private void insertIntoHeaderTable(int index, Header entry) {
       int bytesToRecover = (headerTableByteCount + delta) - maxHeaderTableByteCount;
       int entriesEvicted = evictToRecoverBytes(bytesToRecover);
 
-      if (index == -1) {
-        if (headerCount + 1 > headerTable.length) {
+      if (index == -1) { // Adding a value to the header table.
+        if (headerCount + 1 > headerTable.length) { // Need to grow the header table.
           Header[] doubled = new Header[headerTable.length * 2];
           System.arraycopy(headerTable, 0, doubled, headerTable.length, headerTable.length);
-          if (doubled.length == 64) {
-            referencedHeaders = ((BitArray.FixedCapacity) referencedHeaders).toVariableCapacity();
-          }
-          referencedHeaders.shiftLeft(headerTable.length);
           nextHeaderIndex = headerTable.length - 1;
           headerTable = doubled;
         }
         index = nextHeaderIndex--;
-        referencedHeaders.set(index);
         headerTable[index] = entry;
         headerCount++;
       } else { // Replace value at same position.
         index += headerTableIndex(index) + entriesEvicted;
-        referencedHeaders.set(index);
         headerTable[index] = entry;
       }
       headerTableByteCount += delta;
@@ -357,34 +340,24 @@ int readInt(int firstByte, int prefixMask) throws IOException {
       return result;
     }
 
-    /**
-     * Reads a potentially Huffman encoded string byte string. When
-     * {@code asciiLowercase} is true, bytes will be converted to lowercase.
-     */
-    ByteString readByteString(boolean asciiLowercase) throws IOException {
+    /** Reads a potentially Huffman encoded byte string. */
+    ByteString readByteString() throws IOException {
       int firstByte = readByte();
       boolean huffmanDecode = (firstByte & 0x80) == 0x80; // 1NNNNNNN
       int length = readInt(firstByte, PREFIX_7_BITS);
 
-      ByteString byteString = source.readByteString(length);
-
       if (huffmanDecode) {
-        byteString = huffmanCodec.decode(byteString); // TODO: streaming Huffman!
-      }
-
-      if (asciiLowercase) {
-        byteString = byteString.toAsciiLowercase();
+        return ByteString.of(Huffman.get().decode(source.readByteArray(length)));
+      } else {
+        return source.readByteString(length);
       }
-
-      return byteString;
     }
   }
 
   private static final Map<ByteString, Integer> NAME_TO_FIRST_INDEX = nameToFirstIndex();
 
   private static Map<ByteString, Integer> nameToFirstIndex() {
-    Map<ByteString, Integer> result =
-        new LinkedHashMap<ByteString, Integer>(STATIC_HEADER_TABLE.length);
+    Map<ByteString, Integer> result = new LinkedHashMap<>(STATIC_HEADER_TABLE.length);
     for (int i = 0; i < STATIC_HEADER_TABLE.length; i++) {
       if (!result.containsKey(STATIC_HEADER_TABLE[i].name)) {
         result.put(STATIC_HEADER_TABLE[i].name, i);
@@ -394,30 +367,32 @@ ByteString readByteString(boolean asciiLowercase) throws IOException {
   }
 
   static final class Writer {
-    private final OkBuffer out;
+    private final Buffer out;
 
-    Writer(OkBuffer out) {
+    Writer(Buffer out) {
       this.out = out;
     }
 
+    /** This does not use "never indexed" semantics for sensitive headers. */
+    // https://tools.ietf.org/html/draft-ietf-httpbis-header-compression-09#section-4.3.3
     void writeHeaders(List<Header> headerBlock) throws IOException {
       // TODO: implement index tracking
       for (int i = 0, size = headerBlock.size(); i < size; i++) {
-        ByteString name = headerBlock.get(i).name;
+        ByteString name = headerBlock.get(i).name.toAsciiLowercase();
         Integer staticIndex = NAME_TO_FIRST_INDEX.get(name);
         if (staticIndex != null) {
           // Literal Header Field without Indexing - Indexed Name.
-          writeInt(staticIndex + 1, PREFIX_6_BITS, 0x40);
+          writeInt(staticIndex + 1, PREFIX_4_BITS, 0);
           writeByteString(headerBlock.get(i).value);
         } else {
-          out.writeByte(0x40); // Literal Header without Indexing - New Name.
+          out.writeByte(0x00); // Literal Header without Indexing - New Name.
           writeByteString(name);
           writeByteString(headerBlock.get(i).value);
         }
       }
     }
 
-    // http://tools.ietf.org/html/draft-ietf-httpbis-header-compression-05#section-4.1.1
+    // http://tools.ietf.org/html/draft-ietf-httpbis-header-compression-09#section-4.1.1
     void writeInt(int value, int prefixMask, int bits) throws IOException {
       // Write the raw value for a single byte value.
       if (value < prefixMask) {
@@ -443,4 +418,18 @@ void writeByteString(ByteString data) throws IOException {
       out.write(data);
     }
   }
+
+  /**
+   * An HTTP/2 response cannot contain uppercase header characters and must
+   * be treated as malformed.
+   */
+  private static ByteString checkLowercase(ByteString name) throws IOException {
+    for (int i = 0, length = name.size(); i < length; i++) {
+      byte c = name.getByte(i);
+      if (c >= 'A' && c <= 'Z') {
+        throw new IOException("PROTOCOL_ERROR response malformed: mixed case name: " + name.utf8());
+      }
+    }
+    return name;
+  }
 }
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/Http20Draft09.java b/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/Http20Draft09.java
deleted file mode 100644
index a88b747ef1..0000000000
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/Http20Draft09.java
+++ /dev/null
@@ -1,544 +0,0 @@
-/*
- * Copyright (C) 2013 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.squareup.okhttp.internal.spdy;
-
-import com.squareup.okhttp.Protocol;
-import java.io.IOException;
-import java.util.List;
-import okio.BufferedSink;
-import okio.BufferedSource;
-import okio.ByteString;
-import okio.Deadline;
-import okio.OkBuffer;
-import okio.Source;
-
-/**
- * Read and write http/2 v09 frames.
- * http://tools.ietf.org/html/draft-ietf-httpbis-http2-09
- */
-public final class Http20Draft09 implements Variant {
-
-  @Override public Protocol getProtocol() {
-    return Protocol.HTTP_2;
-  }
-
-  private static final ByteString CONNECTION_HEADER
-      = ByteString.encodeUtf8("PRI * HTTP/2.0\r\n\r\nSM\r\n\r\n");
-
-  static final byte TYPE_DATA = 0x0;
-  static final byte TYPE_HEADERS = 0x1;
-  static final byte TYPE_PRIORITY = 0x2;
-  static final byte TYPE_RST_STREAM = 0x3;
-  static final byte TYPE_SETTINGS = 0x4;
-  static final byte TYPE_PUSH_PROMISE = 0x5;
-  static final byte TYPE_PING = 0x6;
-  static final byte TYPE_GOAWAY = 0x7;
-  static final byte TYPE_WINDOW_UPDATE = 0x9;
-  static final byte TYPE_CONTINUATION = 0xa;
-
-  static final byte FLAG_NONE = 0x0;
-  static final byte FLAG_ACK = 0x1;
-  static final byte FLAG_END_STREAM = 0x1;
-  static final byte FLAG_END_HEADERS = 0x4; // Used for headers and continuation.
-  static final byte FLAG_END_PUSH_PROMISE = 0x4;
-  static final byte FLAG_PRIORITY = 0x8;
-
-  @Override public FrameReader newReader(BufferedSource source, boolean client) {
-    return new Reader(source, 4096, client);
-  }
-
-  @Override public FrameWriter newWriter(BufferedSink sink, boolean client) {
-    return new Writer(sink, client);
-  }
-
-  @Override public int maxFrameSize() {
-    return 16383;
-  }
-
-  static final class Reader implements FrameReader {
-    private final BufferedSource source;
-    private final ContinuationSource continuation;
-    private final boolean client;
-
-    // Visible for testing.
-    final HpackDraft05.Reader hpackReader;
-
-    Reader(BufferedSource source, int headerTableSize, boolean client) {
-      this.source = source;
-      this.client = client;
-      this.continuation = new ContinuationSource(this.source);
-      this.hpackReader = new HpackDraft05.Reader(client, headerTableSize, continuation);
-    }
-
-    @Override public void readConnectionHeader() throws IOException {
-      if (client) return; // Nothing to read; servers don't send connection headers!
-      ByteString connectionHeader = source.readByteString(CONNECTION_HEADER.size());
-      if (!CONNECTION_HEADER.equals(connectionHeader)) {
-        throw ioException("Expected a connection header but was %s", connectionHeader.utf8());
-      }
-    }
-
-    @Override public boolean nextFrame(Handler handler) throws IOException {
-      int w1;
-      int w2;
-      try {
-        w1 = source.readInt();
-        w2 = source.readInt();
-      } catch (IOException e) {
-        return false; // This might be a normal socket close.
-      }
-
-      // boolean r = (w1 & 0xc0000000) != 0; // Reserved: Ignore first 2 bits.
-      short length = (short) ((w1 & 0x3fff0000) >> 16); // 14-bit unsigned == max 16383
-      byte type = (byte) ((w1 & 0xff00) >> 8);
-      byte flags = (byte) (w1 & 0xff);
-      // boolean r = (w2 & 0x80000000) != 0; // Reserved: Ignore first bit.
-      int streamId = (w2 & 0x7fffffff); // 31-bit opaque identifier.
-
-      switch (type) {
-        case TYPE_DATA:
-          readData(handler, length, flags, streamId);
-          break;
-
-        case TYPE_HEADERS:
-          readHeaders(handler, length, flags, streamId);
-          break;
-
-        case TYPE_PRIORITY:
-          readPriority(handler, length, flags, streamId);
-          break;
-
-        case TYPE_RST_STREAM:
-          readRstStream(handler, length, flags, streamId);
-          break;
-
-        case TYPE_SETTINGS:
-          readSettings(handler, length, flags, streamId);
-          break;
-
-        case TYPE_PUSH_PROMISE:
-          readPushPromise(handler, length, flags, streamId);
-          break;
-
-        case TYPE_PING:
-          readPing(handler, length, flags, streamId);
-          break;
-
-        case TYPE_GOAWAY:
-          readGoAway(handler, length, flags, streamId);
-          break;
-
-        case TYPE_WINDOW_UPDATE:
-          readWindowUpdate(handler, length, flags, streamId);
-          break;
-
-        default:
-          // Implementations MUST ignore frames of unsupported or unrecognized types.
-          source.skip(length);
-      }
-      return true;
-    }
-
-    private void readHeaders(Handler handler, short length, byte flags, int streamId)
-        throws IOException {
-      if (streamId == 0) throw ioException("PROTOCOL_ERROR: TYPE_HEADERS streamId == 0");
-
-      boolean endStream = (flags & FLAG_END_STREAM) != 0;
-
-      int priority = -1;
-      if ((flags & FLAG_PRIORITY) != 0) {
-        priority = source.readInt() & 0x7fffffff;
-        length -= 4; // account for above read.
-      }
-
-      List<Header> headerBlock = readHeaderBlock(length, flags, streamId);
-
-      handler.headers(false, endStream, streamId, -1, priority, headerBlock,
-          HeadersMode.HTTP_20_HEADERS);
-    }
-
-    private List<Header> readHeaderBlock(short length, byte flags, int streamId)
-        throws IOException {
-      continuation.length = continuation.left = length;
-      continuation.flags = flags;
-      continuation.streamId = streamId;
-
-      hpackReader.readHeaders();
-      hpackReader.emitReferenceSet();
-      // TODO: Concat multi-value headers with 0x0, except COOKIE, which uses 0x3B, 0x20.
-      // http://tools.ietf.org/html/draft-ietf-httpbis-http2-09#section-8.1.3
-      return hpackReader.getAndReset();
-    }
-
-    private void readData(Handler handler, short length, byte flags, int streamId)
-        throws IOException {
-      boolean inFinished = (flags & FLAG_END_STREAM) != 0;
-      // TODO: checkState open or half-closed (local) or raise STREAM_CLOSED
-      handler.data(inFinished, streamId, source, length);
-    }
-
-    private void readPriority(Handler handler, short length, byte flags, int streamId)
-        throws IOException {
-      if (length != 4) throw ioException("TYPE_PRIORITY length: %d != 4", length);
-      if (streamId == 0) throw ioException("TYPE_PRIORITY streamId == 0");
-      int w1 = source.readInt();
-      // boolean r = (w1 & 0x80000000) != 0; // Reserved.
-      int priority = (w1 & 0x7fffffff);
-      handler.priority(streamId, priority);
-    }
-
-    private void readRstStream(Handler handler, short length, byte flags, int streamId)
-        throws IOException {
-      if (length != 4) throw ioException("TYPE_RST_STREAM length: %d != 4", length);
-      if (streamId == 0) throw ioException("TYPE_RST_STREAM streamId == 0");
-      int errorCodeInt = source.readInt();
-      ErrorCode errorCode = ErrorCode.fromHttp2(errorCodeInt);
-      if (errorCode == null) {
-        throw ioException("TYPE_RST_STREAM unexpected error code: %d", errorCodeInt);
-      }
-      handler.rstStream(streamId, errorCode);
-    }
-
-    private void readSettings(Handler handler, short length, byte flags, int streamId)
-        throws IOException {
-      if (streamId != 0) throw ioException("TYPE_SETTINGS streamId != 0");
-      if ((flags & FLAG_ACK) != 0) {
-        if (length != 0) throw ioException("FRAME_SIZE_ERROR ack frame should be empty!");
-        handler.ackSettings();
-        return;
-      }
-
-      if (length % 8 != 0) throw ioException("TYPE_SETTINGS length %% 8 != 0: %s", length);
-      Settings settings = new Settings();
-      for (int i = 0; i < length; i += 8) {
-        int w1 = source.readInt();
-        int value = source.readInt();
-        // int r = (w1 & 0xff000000) >>> 24; // Reserved.
-        int id = w1 & 0xffffff;
-        settings.set(id, 0, value);
-      }
-      handler.settings(false, settings);
-      if (settings.getHeaderTableSize() >= 0) {
-        hpackReader.maxHeaderTableByteCount(settings.getHeaderTableSize());
-      }
-    }
-
-    private void readPushPromise(Handler handler, short length, byte flags, int streamId)
-        throws IOException {
-      if (streamId == 0) {
-        throw ioException("PROTOCOL_ERROR: TYPE_PUSH_PROMISE streamId == 0");
-      }
-      int promisedStreamId = source.readInt() & 0x7fffffff;
-      length -= 4; // account for above read.
-      List<Header> headerBlock = readHeaderBlock(length, flags, streamId);
-      handler.pushPromise(streamId, promisedStreamId, headerBlock);
-    }
-
-    private void readPing(Handler handler, short length, byte flags, int streamId)
-        throws IOException {
-      if (length != 8) throw ioException("TYPE_PING length != 8: %s", length);
-      if (streamId != 0) throw ioException("TYPE_PING streamId != 0");
-      int payload1 = source.readInt();
-      int payload2 = source.readInt();
-      boolean ack = (flags & FLAG_ACK) != 0;
-      handler.ping(ack, payload1, payload2);
-    }
-
-    private void readGoAway(Handler handler, short length, byte flags, int streamId)
-        throws IOException {
-      if (length < 8) throw ioException("TYPE_GOAWAY length < 8: %s", length);
-      if (streamId != 0) throw ioException("TYPE_GOAWAY streamId != 0");
-      int lastStreamId = source.readInt();
-      int errorCodeInt = source.readInt();
-      int opaqueDataLength = length - 8;
-      ErrorCode errorCode = ErrorCode.fromHttp2(errorCodeInt);
-      if (errorCode == null) {
-        throw ioException("TYPE_GOAWAY unexpected error code: %d", errorCodeInt);
-      }
-      ByteString debugData = ByteString.EMPTY;
-      if (opaqueDataLength > 0) { // Must read debug data in order to not corrupt the connection.
-        debugData = source.readByteString(opaqueDataLength);
-      }
-      handler.goAway(lastStreamId, errorCode, debugData);
-    }
-
-    private void readWindowUpdate(Handler handler, short length, byte flags, int streamId)
-        throws IOException {
-      if (length != 4) throw ioException("TYPE_WINDOW_UPDATE length !=4: %s", length);
-      long increment = (source.readInt() & 0x7fffffff);
-      if (increment == 0) throw ioException("windowSizeIncrement was 0", increment);
-      handler.windowUpdate(streamId, increment);
-    }
-
-    @Override public void close() throws IOException {
-      source.close();
-    }
-  }
-
-  static final class Writer implements FrameWriter {
-    private final BufferedSink sink;
-    private final boolean client;
-    private final OkBuffer hpackBuffer;
-    private final HpackDraft05.Writer hpackWriter;
-    private boolean closed;
-
-    Writer(BufferedSink sink, boolean client) {
-      this.sink = sink;
-      this.client = client;
-      this.hpackBuffer = new OkBuffer();
-      this.hpackWriter = new HpackDraft05.Writer(hpackBuffer);
-    }
-
-    @Override public synchronized void flush() throws IOException {
-      if (closed) throw new IOException("closed");
-      sink.flush();
-    }
-
-    @Override public synchronized void ackSettings() throws IOException {
-      if (closed) throw new IOException("closed");
-      int length = 0;
-      byte type = TYPE_SETTINGS;
-      byte flags = FLAG_ACK;
-      int streamId = 0;
-      frameHeader(length, type, flags, streamId);
-      sink.flush();
-    }
-
-    @Override public synchronized void connectionHeader() throws IOException {
-      if (closed) throw new IOException("closed");
-      if (!client) return; // Nothing to write; servers don't send connection headers!
-      sink.write(CONNECTION_HEADER.toByteArray());
-      sink.flush();
-    }
-
-    @Override public synchronized void synStream(boolean outFinished, boolean inFinished,
-        int streamId, int associatedStreamId, int priority, int slot, List<Header> headerBlock)
-        throws IOException {
-      if (inFinished) throw new UnsupportedOperationException();
-      if (closed) throw new IOException("closed");
-      headers(outFinished, streamId, priority, headerBlock);
-    }
-
-    @Override public synchronized void synReply(boolean outFinished, int streamId,
-        List<Header> headerBlock) throws IOException {
-      if (closed) throw new IOException("closed");
-      headers(outFinished, streamId, -1, headerBlock);
-    }
-
-    @Override public synchronized void headers(int streamId, List<Header> headerBlock)
-        throws IOException {
-      if (closed) throw new IOException("closed");
-      headers(false, streamId, -1, headerBlock);
-    }
-
-    @Override public synchronized void pushPromise(int streamId, int promisedStreamId,
-        List<Header> requestHeaders) throws IOException {
-      if (closed) throw new IOException("closed");
-      if (hpackBuffer.size() != 0) throw new IllegalStateException();
-      hpackWriter.writeHeaders(requestHeaders);
-
-      int length = (int) (4 + hpackBuffer.size());
-      byte type = TYPE_PUSH_PROMISE;
-      byte flags = FLAG_END_HEADERS;
-      frameHeader(length, type, flags, streamId); // TODO: CONTINUATION
-      sink.writeInt(promisedStreamId & 0x7fffffff);
-      sink.write(hpackBuffer, hpackBuffer.size());
-    }
-
-    private void headers(boolean outFinished, int streamId, int priority,
-        List<Header> headerBlock) throws IOException {
-      if (closed) throw new IOException("closed");
-      if (hpackBuffer.size() != 0) throw new IllegalStateException();
-      hpackWriter.writeHeaders(headerBlock);
-
-      int length = (int) hpackBuffer.size();
-      byte type = TYPE_HEADERS;
-      byte flags = FLAG_END_HEADERS;
-      if (outFinished) flags |= FLAG_END_STREAM;
-      if (priority != -1) flags |= FLAG_PRIORITY;
-      if (priority != -1) length += 4;
-      frameHeader(length, type, flags, streamId); // TODO: CONTINUATION
-      if (priority != -1) sink.writeInt(priority & 0x7fffffff);
-      sink.write(hpackBuffer, hpackBuffer.size());
-    }
-
-    @Override public synchronized void rstStream(int streamId, ErrorCode errorCode)
-        throws IOException {
-      if (closed) throw new IOException("closed");
-      if (errorCode.spdyRstCode == -1) throw new IllegalArgumentException();
-
-      int length = 4;
-      byte type = TYPE_RST_STREAM;
-      byte flags = FLAG_NONE;
-      frameHeader(length, type, flags, streamId);
-      sink.writeInt(errorCode.httpCode);
-      sink.flush();
-    }
-
-    @Override public synchronized void data(boolean outFinished, int streamId, OkBuffer source)
-        throws IOException {
-      data(outFinished, streamId, source, (int) source.size());
-    }
-
-    @Override public synchronized void data(boolean outFinished, int streamId, OkBuffer source,
-        int byteCount) throws IOException {
-      if (closed) throw new IOException("closed");
-      byte flags = FLAG_NONE;
-      if (outFinished) flags |= FLAG_END_STREAM;
-      dataFrame(streamId, flags, source, byteCount);
-    }
-
-    void dataFrame(int streamId, byte flags, OkBuffer buffer, int byteCount) throws IOException {
-      byte type = TYPE_DATA;
-      frameHeader(byteCount, type, flags, streamId);
-      if (byteCount > 0) {
-        sink.write(buffer, byteCount);
-      }
-    }
-
-    @Override public synchronized void settings(Settings settings) throws IOException {
-      if (closed) throw new IOException("closed");
-      int length = settings.size() * 8;
-      byte type = TYPE_SETTINGS;
-      byte flags = FLAG_NONE;
-      int streamId = 0;
-      frameHeader(length, type, flags, streamId);
-      for (int i = 0; i < Settings.COUNT; i++) {
-        if (!settings.isSet(i)) continue;
-        sink.writeInt(i & 0xffffff);
-        sink.writeInt(settings.get(i));
-      }
-      sink.flush();
-    }
-
-    @Override public synchronized void ping(boolean ack, int payload1, int payload2)
-        throws IOException {
-      if (closed) throw new IOException("closed");
-      int length = 8;
-      byte type = TYPE_PING;
-      byte flags = ack ? FLAG_ACK : FLAG_NONE;
-      int streamId = 0;
-      frameHeader(length, type, flags, streamId);
-      sink.writeInt(payload1);
-      sink.writeInt(payload2);
-      sink.flush();
-    }
-
-    @Override public synchronized void goAway(int lastGoodStreamId, ErrorCode errorCode,
-        byte[] debugData) throws IOException {
-      if (closed) throw new IOException("closed");
-      if (errorCode.httpCode == -1) throw illegalArgument("errorCode.httpCode == -1");
-      int length = 8 + debugData.length;
-      byte type = TYPE_GOAWAY;
-      byte flags = FLAG_NONE;
-      int streamId = 0;
-      frameHeader(length, type, flags, streamId);
-      sink.writeInt(lastGoodStreamId);
-      sink.writeInt(errorCode.httpCode);
-      if (debugData.length > 0) {
-        sink.write(debugData);
-      }
-      sink.flush();
-    }
-
-    @Override public synchronized void windowUpdate(int streamId, long windowSizeIncrement)
-        throws IOException {
-      if (closed) throw new IOException("closed");
-      if (windowSizeIncrement == 0 || windowSizeIncrement > 0x7fffffffL) {
-        throw illegalArgument("windowSizeIncrement == 0 || windowSizeIncrement > 0x7fffffffL: %s",
-            windowSizeIncrement);
-      }
-      int length = 4;
-      byte type = TYPE_WINDOW_UPDATE;
-      byte flags = FLAG_NONE;
-      frameHeader(length, type, flags, streamId);
-      sink.writeInt((int) windowSizeIncrement);
-      sink.flush();
-    }
-
-    @Override public synchronized void close() throws IOException {
-      closed = true;
-      sink.close();
-    }
-
-    void frameHeader(int length, byte type, byte flags, int streamId) throws IOException {
-      if (length > 16383) throw illegalArgument("FRAME_SIZE_ERROR length > 16383: %s", length);
-      if ((streamId & 0x80000000) != 0) throw illegalArgument("reserved bit set: %s", streamId);
-      sink.writeInt((length & 0x3fff) << 16 | (type & 0xff) << 8 | (flags & 0xff));
-      sink.writeInt(streamId & 0x7fffffff);
-    }
-  }
-
-  private static IllegalArgumentException illegalArgument(String message, Object... args) {
-    throw new IllegalArgumentException(String.format(message, args));
-  }
-
-  private static IOException ioException(String message, Object... args) throws IOException {
-    throw new IOException(String.format(message, args));
-  }
-
-  /**
-   * Decompression of the header block occurs above the framing layer. This
-   * class lazily reads continuation frames as they are needed by {@link
-   * HpackDraft05.Reader#readHeaders()}.
-   */
-  static final class ContinuationSource implements Source {
-    private final BufferedSource source;
-
-    int length;
-    byte flags;
-    int streamId;
-
-    int left;
-
-    public ContinuationSource(BufferedSource source) {
-      this.source = source;
-    }
-
-    @Override public long read(OkBuffer sink, long byteCount) throws IOException {
-      while (left == 0) {
-        if ((flags & FLAG_END_HEADERS) != 0) return -1;
-        readContinuationHeader();
-        // TODO: test case for empty continuation header?
-      }
-
-      long read = source.read(sink, Math.min(byteCount, left));
-      if (read == -1) return -1;
-      left -= read;
-      return read;
-    }
-
-    @Override public Source deadline(Deadline deadline) {
-      source.deadline(deadline);
-      return this;
-    }
-
-    @Override public void close() throws IOException {
-    }
-
-    private void readContinuationHeader() throws IOException {
-      int previousStreamId = streamId;
-      int w1 = source.readInt();
-      int w2 = source.readInt();
-      length = left = (short) ((w1 & 0x3fff0000) >> 16);
-      byte type = (byte) ((w1 & 0xff00) >> 8);
-      flags = (byte) (w1 & 0xff);
-      streamId = (w2 & 0x7fffffff);
-      if (type != TYPE_CONTINUATION) throw ioException("%s != TYPE_CONTINUATION", type);
-      if (streamId != previousStreamId) throw ioException("TYPE_CONTINUATION streamId changed");
-    }
-  }
-}
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/Http20Draft14.java b/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/Http20Draft14.java
new file mode 100644
index 0000000000..4ac76a6465
--- /dev/null
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/Http20Draft14.java
@@ -0,0 +1,773 @@
+/*
+ * Copyright (C) 2013 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.okhttp.internal.spdy;
+
+import com.squareup.okhttp.Protocol;
+import java.io.IOException;
+import java.util.List;
+import java.util.logging.Logger;
+import okio.Buffer;
+import okio.BufferedSink;
+import okio.BufferedSource;
+import okio.ByteString;
+import okio.Source;
+import okio.Timeout;
+
+import static com.squareup.okhttp.internal.spdy.Http20Draft14.FrameLogger.formatHeader;
+import static java.lang.String.format;
+import static java.util.logging.Level.FINE;
+import static okio.ByteString.EMPTY;
+
+/**
+ * Read and write HTTP/2 v14 frames.
+ * <p>
+ * This implementation assumes we do not send an increased
+ * {@link Settings#getMaxFrameSize frame size setting} to the peer. Hence, we
+ * expect all frames to have a max length of {@link #INITIAL_MAX_FRAME_SIZE}.
+ * <p>http://tools.ietf.org/html/draft-ietf-httpbis-http2-14
+ */
+public final class Http20Draft14 implements Variant {
+  private static final Logger logger = Logger.getLogger(Http20Draft14.class.getName());
+
+  @Override public Protocol getProtocol() {
+    return Protocol.HTTP_2;
+  }
+
+  private static final ByteString CONNECTION_PREFACE
+      = ByteString.encodeUtf8("PRI * HTTP/2.0\r\n\r\nSM\r\n\r\n");
+
+  /** The initial max frame size, applied independently writing to, or reading from the peer. */
+  static final int INITIAL_MAX_FRAME_SIZE = 0x4000; // 16384
+
+  static final byte TYPE_DATA = 0x0;
+  static final byte TYPE_HEADERS = 0x1;
+  static final byte TYPE_PRIORITY = 0x2;
+  static final byte TYPE_RST_STREAM = 0x3;
+  static final byte TYPE_SETTINGS = 0x4;
+  static final byte TYPE_PUSH_PROMISE = 0x5;
+  static final byte TYPE_PING = 0x6;
+  static final byte TYPE_GOAWAY = 0x7;
+  static final byte TYPE_WINDOW_UPDATE = 0x8;
+  static final byte TYPE_CONTINUATION = 0x9;
+
+  static final byte FLAG_NONE = 0x0;
+  static final byte FLAG_ACK = 0x1; // Used for settings and ping.
+  static final byte FLAG_END_STREAM = 0x1; // Used for headers and data.
+  static final byte FLAG_END_HEADERS = 0x4; // Used for headers and continuation.
+  static final byte FLAG_END_PUSH_PROMISE = 0x4;
+  static final byte FLAG_PADDED = 0x8; // Used for headers and data.
+  static final byte FLAG_PRIORITY = 0x20; // Used for headers.
+  static final byte FLAG_COMPRESSED = 0x20; // Used for data.
+
+  /**
+   * Creates a frame reader with max header table size of 4096 and data frame
+   * compression disabled.
+   */
+  @Override public FrameReader newReader(BufferedSource source, boolean client) {
+    return new Reader(source, 4096, client);
+  }
+
+  @Override public FrameWriter newWriter(BufferedSink sink, boolean client) {
+    return new Writer(sink, client);
+  }
+
+  static final class Reader implements FrameReader {
+    private final BufferedSource source;
+    private final ContinuationSource continuation;
+    private final boolean client;
+
+    // Visible for testing.
+    final HpackDraft09.Reader hpackReader;
+
+    Reader(BufferedSource source, int headerTableSize, boolean client) {
+      this.source = source;
+      this.client = client;
+      this.continuation = new ContinuationSource(this.source);
+      this.hpackReader = new HpackDraft09.Reader(headerTableSize, continuation);
+    }
+
+    @Override public void readConnectionPreface() throws IOException {
+      if (client) return; // Nothing to read; servers doesn't send a connection preface!
+      ByteString connectionPreface = source.readByteString(CONNECTION_PREFACE.size());
+      if (logger.isLoggable(FINE)) logger.fine(format("<< CONNECTION %s", connectionPreface.hex()));
+      if (!CONNECTION_PREFACE.equals(connectionPreface)) {
+        throw ioException("Expected a connection header but was %s", connectionPreface.utf8());
+      }
+    }
+
+    @Override public boolean nextFrame(Handler handler) throws IOException {
+      try {
+        source.require(9); // Frame header size
+      } catch (IOException e) {
+        return false; // This might be a normal socket close.
+      }
+
+      /*  0                   1                   2                   3
+       *  0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+       * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+       * |                 Length (24)                   |
+       * +---------------+---------------+---------------+
+       * |   Type (8)    |   Flags (8)   |
+       * +-+-+-----------+---------------+-------------------------------+
+       * |R|                 Stream Identifier (31)                      |
+       * +=+=============================================================+
+       * |                   Frame Payload (0...)                      ...
+       * +---------------------------------------------------------------+
+       */
+      int length = readMedium(source);
+      if (length < 0 || length > INITIAL_MAX_FRAME_SIZE) {
+        throw ioException("FRAME_SIZE_ERROR: %s", length);
+      }
+      byte type = (byte) (source.readByte() & 0xff);
+      byte flags = (byte) (source.readByte() & 0xff);
+      int streamId = (source.readInt() & 0x7fffffff); // Ignore reserved bit.
+      if (logger.isLoggable(FINE)) logger.fine(formatHeader(true, streamId, length, type, flags));
+
+      switch (type) {
+        case TYPE_DATA:
+          readData(handler, length, flags, streamId);
+          break;
+
+        case TYPE_HEADERS:
+          readHeaders(handler, length, flags, streamId);
+          break;
+
+        case TYPE_PRIORITY:
+          readPriority(handler, length, flags, streamId);
+          break;
+
+        case TYPE_RST_STREAM:
+          readRstStream(handler, length, flags, streamId);
+          break;
+
+        case TYPE_SETTINGS:
+          readSettings(handler, length, flags, streamId);
+          break;
+
+        case TYPE_PUSH_PROMISE:
+          readPushPromise(handler, length, flags, streamId);
+          break;
+
+        case TYPE_PING:
+          readPing(handler, length, flags, streamId);
+          break;
+
+        case TYPE_GOAWAY:
+          readGoAway(handler, length, flags, streamId);
+          break;
+
+        case TYPE_WINDOW_UPDATE:
+          readWindowUpdate(handler, length, flags, streamId);
+          break;
+
+        default:
+          // Implementations MUST discard frames that have unknown or unsupported types.
+          source.skip(length);
+      }
+      return true;
+    }
+
+    private void readHeaders(Handler handler, int length, byte flags, int streamId)
+        throws IOException {
+      if (streamId == 0) throw ioException("PROTOCOL_ERROR: TYPE_HEADERS streamId == 0");
+
+      boolean endStream = (flags & FLAG_END_STREAM) != 0;
+
+      short padding = (flags & FLAG_PADDED) != 0 ? (short) (source.readByte() & 0xff) : 0;
+
+      if ((flags & FLAG_PRIORITY) != 0) {
+        readPriority(handler, streamId);
+        length -= 5; // account for above read.
+      }
+
+      length = lengthWithoutPadding(length, flags, padding);
+
+      List<Header> headerBlock = readHeaderBlock(length, padding, flags, streamId);
+
+      handler.headers(false, endStream, streamId, -1, headerBlock, HeadersMode.HTTP_20_HEADERS);
+    }
+
+    private List<Header> readHeaderBlock(int length, short padding, byte flags, int streamId)
+        throws IOException {
+      continuation.length = continuation.left = length;
+      continuation.padding = padding;
+      continuation.flags = flags;
+      continuation.streamId = streamId;
+
+      // TODO: Concat multi-value headers with 0x0, except COOKIE, which uses 0x3B, 0x20.
+      // http://tools.ietf.org/html/draft-ietf-httpbis-http2-14#section-8.1.2.5
+      hpackReader.readHeaders();
+      return hpackReader.getAndResetHeaderList();
+    }
+
+    private void readData(Handler handler, int length, byte flags, int streamId)
+        throws IOException {
+      // TODO: checkState open or half-closed (local) or raise STREAM_CLOSED
+      boolean inFinished = (flags & FLAG_END_STREAM) != 0;
+      boolean gzipped = (flags & FLAG_COMPRESSED) != 0;
+      if (gzipped) {
+        throw ioException("PROTOCOL_ERROR: FLAG_COMPRESSED without SETTINGS_COMPRESS_DATA");
+      }
+
+      short padding = (flags & FLAG_PADDED) != 0 ? (short) (source.readByte() & 0xff) : 0;
+      length = lengthWithoutPadding(length, flags, padding);
+
+      handler.data(inFinished, streamId, source, length);
+      source.skip(padding);
+    }
+
+    private void readPriority(Handler handler, int length, byte flags, int streamId)
+        throws IOException {
+      if (length != 5) throw ioException("TYPE_PRIORITY length: %d != 5", length);
+      if (streamId == 0) throw ioException("TYPE_PRIORITY streamId == 0");
+      readPriority(handler, streamId);
+    }
+
+    private void readPriority(Handler handler, int streamId) throws IOException {
+      int w1 = source.readInt();
+      boolean exclusive = (w1 & 0x80000000) != 0;
+      int streamDependency = (w1 & 0x7fffffff);
+      int weight = (source.readByte() & 0xff) + 1;
+      handler.priority(streamId, streamDependency, weight, exclusive);
+    }
+
+    private void readRstStream(Handler handler, int length, byte flags, int streamId)
+        throws IOException {
+      if (length != 4) throw ioException("TYPE_RST_STREAM length: %d != 4", length);
+      if (streamId == 0) throw ioException("TYPE_RST_STREAM streamId == 0");
+      int errorCodeInt = source.readInt();
+      ErrorCode errorCode = ErrorCode.fromHttp2(errorCodeInt);
+      if (errorCode == null) {
+        throw ioException("TYPE_RST_STREAM unexpected error code: %d", errorCodeInt);
+      }
+      handler.rstStream(streamId, errorCode);
+    }
+
+    private void readSettings(Handler handler, int length, byte flags, int streamId)
+        throws IOException {
+      if (streamId != 0) throw ioException("TYPE_SETTINGS streamId != 0");
+      if ((flags & FLAG_ACK) != 0) {
+        if (length != 0) throw ioException("FRAME_SIZE_ERROR ack frame should be empty!");
+        handler.ackSettings();
+        return;
+      }
+
+      if (length % 6 != 0) throw ioException("TYPE_SETTINGS length %% 6 != 0: %s", length);
+      Settings settings = new Settings();
+      for (int i = 0; i < length; i += 6) {
+        short id = source.readShort();
+        int value = source.readInt();
+
+        switch (id) {
+          case 1: // SETTINGS_HEADER_TABLE_SIZE
+            break;
+          case 2: // SETTINGS_ENABLE_PUSH
+            if (value != 0 && value != 1) {
+              throw ioException("PROTOCOL_ERROR SETTINGS_ENABLE_PUSH != 0 or 1");
+            }
+            break;
+          case 3: // SETTINGS_MAX_CONCURRENT_STREAMS
+            id = 4; // Renumbered in draft 10.
+            break;
+          case 4: // SETTINGS_INITIAL_WINDOW_SIZE
+            id = 7; // Renumbered in draft 10.
+            if (value < 0) {
+              throw ioException("PROTOCOL_ERROR SETTINGS_INITIAL_WINDOW_SIZE > 2^31 - 1");
+            }
+            break;
+          case 5: // SETTINGS_MAX_FRAME_SIZE
+            if (value < INITIAL_MAX_FRAME_SIZE || value > 16777215) {
+              throw ioException("PROTOCOL_ERROR SETTINGS_MAX_FRAME_SIZE: %s", value);
+            }
+            break;
+          case 6: // SETTINGS_MAX_HEADER_LIST_SIZE
+            break; // Advisory only, so ignored.
+          default:
+            throw ioException("PROTOCOL_ERROR invalid settings id: %s", id);
+        }
+        settings.set(id, 0, value);
+      }
+      handler.settings(false, settings);
+      if (settings.getHeaderTableSize() >= 0) {
+        hpackReader.maxHeaderTableByteCountSetting(settings.getHeaderTableSize());
+      }
+    }
+
+    private void readPushPromise(Handler handler, int length, byte flags, int streamId)
+        throws IOException {
+      if (streamId == 0) {
+        throw ioException("PROTOCOL_ERROR: TYPE_PUSH_PROMISE streamId == 0");
+      }
+      short padding = (flags & FLAG_PADDED) != 0 ? (short) (source.readByte() & 0xff) : 0;
+      int promisedStreamId = source.readInt() & 0x7fffffff;
+      length -= 4; // account for above read.
+      length = lengthWithoutPadding(length, flags, padding);
+      List<Header> headerBlock = readHeaderBlock(length, padding, flags, streamId);
+      handler.pushPromise(streamId, promisedStreamId, headerBlock);
+    }
+
+    private void readPing(Handler handler, int length, byte flags, int streamId)
+        throws IOException {
+      if (length != 8) throw ioException("TYPE_PING length != 8: %s", length);
+      if (streamId != 0) throw ioException("TYPE_PING streamId != 0");
+      int payload1 = source.readInt();
+      int payload2 = source.readInt();
+      boolean ack = (flags & FLAG_ACK) != 0;
+      handler.ping(ack, payload1, payload2);
+    }
+
+    private void readGoAway(Handler handler, int length, byte flags, int streamId)
+        throws IOException {
+      if (length < 8) throw ioException("TYPE_GOAWAY length < 8: %s", length);
+      if (streamId != 0) throw ioException("TYPE_GOAWAY streamId != 0");
+      int lastStreamId = source.readInt();
+      int errorCodeInt = source.readInt();
+      int opaqueDataLength = length - 8;
+      ErrorCode errorCode = ErrorCode.fromHttp2(errorCodeInt);
+      if (errorCode == null) {
+        throw ioException("TYPE_GOAWAY unexpected error code: %d", errorCodeInt);
+      }
+      ByteString debugData = EMPTY;
+      if (opaqueDataLength > 0) { // Must read debug data in order to not corrupt the connection.
+        debugData = source.readByteString(opaqueDataLength);
+      }
+      handler.goAway(lastStreamId, errorCode, debugData);
+    }
+
+    private void readWindowUpdate(Handler handler, int length, byte flags, int streamId)
+        throws IOException {
+      if (length != 4) throw ioException("TYPE_WINDOW_UPDATE length !=4: %s", length);
+      long increment = (source.readInt() & 0x7fffffffL);
+      if (increment == 0) throw ioException("windowSizeIncrement was 0", increment);
+      handler.windowUpdate(streamId, increment);
+    }
+
+    @Override public void close() throws IOException {
+      source.close();
+    }
+  }
+
+  static final class Writer implements FrameWriter {
+    private final BufferedSink sink;
+    private final boolean client;
+    private final Buffer hpackBuffer;
+    private final HpackDraft09.Writer hpackWriter;
+    private int maxFrameSize;
+    private boolean closed;
+
+    Writer(BufferedSink sink, boolean client) {
+      this.sink = sink;
+      this.client = client;
+      this.hpackBuffer = new Buffer();
+      this.hpackWriter = new HpackDraft09.Writer(hpackBuffer);
+      this.maxFrameSize = INITIAL_MAX_FRAME_SIZE;
+    }
+
+    @Override public synchronized void flush() throws IOException {
+      if (closed) throw new IOException("closed");
+      sink.flush();
+    }
+
+    @Override public synchronized void ackSettings(Settings peerSettings) throws IOException {
+      if (closed) throw new IOException("closed");
+      this.maxFrameSize = peerSettings.getMaxFrameSize(maxFrameSize);
+      int length = 0;
+      byte type = TYPE_SETTINGS;
+      byte flags = FLAG_ACK;
+      int streamId = 0;
+      frameHeader(streamId, length, type, flags);
+      sink.flush();
+    }
+
+    @Override public synchronized void connectionPreface() throws IOException {
+      if (closed) throw new IOException("closed");
+      if (!client) return; // Nothing to write; servers don't send connection headers!
+      if (logger.isLoggable(FINE)) {
+        logger.fine(format(">> CONNECTION %s", CONNECTION_PREFACE.hex()));
+      }
+      sink.write(CONNECTION_PREFACE.toByteArray());
+      sink.flush();
+    }
+
+    @Override public synchronized void synStream(boolean outFinished, boolean inFinished,
+        int streamId, int associatedStreamId, List<Header> headerBlock)
+        throws IOException {
+      if (inFinished) throw new UnsupportedOperationException();
+      if (closed) throw new IOException("closed");
+      headers(outFinished, streamId, headerBlock);
+    }
+
+    @Override public synchronized void synReply(boolean outFinished, int streamId,
+        List<Header> headerBlock) throws IOException {
+      if (closed) throw new IOException("closed");
+      headers(outFinished, streamId, headerBlock);
+    }
+
+    @Override public synchronized void headers(int streamId, List<Header> headerBlock)
+        throws IOException {
+      if (closed) throw new IOException("closed");
+      headers(false, streamId, headerBlock);
+    }
+
+    @Override public synchronized void pushPromise(int streamId, int promisedStreamId,
+        List<Header> requestHeaders) throws IOException {
+      if (closed) throw new IOException("closed");
+      if (hpackBuffer.size() != 0) throw new IllegalStateException();
+      hpackWriter.writeHeaders(requestHeaders);
+
+      long byteCount = hpackBuffer.size();
+      int length = (int) Math.min(maxFrameSize - 4, byteCount);
+      byte type = TYPE_PUSH_PROMISE;
+      byte flags = byteCount == length ? FLAG_END_HEADERS : 0;
+      frameHeader(streamId, length + 4, type, flags);
+      sink.writeInt(promisedStreamId & 0x7fffffff);
+      sink.write(hpackBuffer, length);
+
+      if (byteCount > length) writeContinuationFrames(streamId, byteCount - length);
+    }
+
+    void headers(boolean outFinished, int streamId, List<Header> headerBlock) throws IOException {
+      if (closed) throw new IOException("closed");
+      if (hpackBuffer.size() != 0) throw new IllegalStateException();
+      hpackWriter.writeHeaders(headerBlock);
+
+      long byteCount = hpackBuffer.size();
+      int length = (int) Math.min(maxFrameSize, byteCount);
+      byte type = TYPE_HEADERS;
+      byte flags = byteCount == length ? FLAG_END_HEADERS : 0;
+      if (outFinished) flags |= FLAG_END_STREAM;
+      frameHeader(streamId, length, type, flags);
+      sink.write(hpackBuffer, length);
+
+      if (byteCount > length) writeContinuationFrames(streamId, byteCount - length);
+    }
+
+    private void writeContinuationFrames(int streamId, long byteCount) throws IOException {
+      while (byteCount > 0) {
+        int length = (int) Math.min(maxFrameSize, byteCount);
+        byteCount -= length;
+        frameHeader(streamId, length, TYPE_CONTINUATION, byteCount == 0 ? FLAG_END_HEADERS : 0);
+        sink.write(hpackBuffer, length);
+      }
+    }
+
+    @Override public synchronized void rstStream(int streamId, ErrorCode errorCode)
+        throws IOException {
+      if (closed) throw new IOException("closed");
+      if (errorCode.spdyRstCode == -1) throw new IllegalArgumentException();
+
+      int length = 4;
+      byte type = TYPE_RST_STREAM;
+      byte flags = FLAG_NONE;
+      frameHeader(streamId, length, type, flags);
+      sink.writeInt(errorCode.httpCode);
+      sink.flush();
+    }
+
+    @Override public int maxDataLength() {
+      return maxFrameSize;
+    }
+
+    @Override public synchronized void data(boolean outFinished, int streamId, Buffer source,
+        int byteCount) throws IOException {
+      if (closed) throw new IOException("closed");
+      byte flags = FLAG_NONE;
+      if (outFinished) flags |= FLAG_END_STREAM;
+      dataFrame(streamId, flags, source, byteCount);
+    }
+
+    void dataFrame(int streamId, byte flags, Buffer buffer, int byteCount) throws IOException {
+      byte type = TYPE_DATA;
+      frameHeader(streamId, byteCount, type, flags);
+      if (byteCount > 0) {
+        sink.write(buffer, byteCount);
+      }
+    }
+
+    @Override public synchronized void settings(Settings settings) throws IOException {
+      if (closed) throw new IOException("closed");
+      int length = settings.size() * 6;
+      byte type = TYPE_SETTINGS;
+      byte flags = FLAG_NONE;
+      int streamId = 0;
+      frameHeader(streamId, length, type, flags);
+      for (int i = 0; i < Settings.COUNT; i++) {
+        if (!settings.isSet(i)) continue;
+        int id = i;
+        if (id == 4) id = 3; // SETTINGS_MAX_CONCURRENT_STREAMS renumbered.
+        else if (id == 7) id = 4; // SETTINGS_INITIAL_WINDOW_SIZE renumbered.
+        sink.writeShort(id);
+        sink.writeInt(settings.get(i));
+      }
+      sink.flush();
+    }
+
+    @Override public synchronized void ping(boolean ack, int payload1, int payload2)
+        throws IOException {
+      if (closed) throw new IOException("closed");
+      int length = 8;
+      byte type = TYPE_PING;
+      byte flags = ack ? FLAG_ACK : FLAG_NONE;
+      int streamId = 0;
+      frameHeader(streamId, length, type, flags);
+      sink.writeInt(payload1);
+      sink.writeInt(payload2);
+      sink.flush();
+    }
+
+    @Override public synchronized void goAway(int lastGoodStreamId, ErrorCode errorCode,
+        byte[] debugData) throws IOException {
+      if (closed) throw new IOException("closed");
+      if (errorCode.httpCode == -1) throw illegalArgument("errorCode.httpCode == -1");
+      int length = 8 + debugData.length;
+      byte type = TYPE_GOAWAY;
+      byte flags = FLAG_NONE;
+      int streamId = 0;
+      frameHeader(streamId, length, type, flags);
+      sink.writeInt(lastGoodStreamId);
+      sink.writeInt(errorCode.httpCode);
+      if (debugData.length > 0) {
+        sink.write(debugData);
+      }
+      sink.flush();
+    }
+
+    @Override public synchronized void windowUpdate(int streamId, long windowSizeIncrement)
+        throws IOException {
+      if (closed) throw new IOException("closed");
+      if (windowSizeIncrement == 0 || windowSizeIncrement > 0x7fffffffL) {
+        throw illegalArgument("windowSizeIncrement == 0 || windowSizeIncrement > 0x7fffffffL: %s",
+            windowSizeIncrement);
+      }
+      int length = 4;
+      byte type = TYPE_WINDOW_UPDATE;
+      byte flags = FLAG_NONE;
+      frameHeader(streamId, length, type, flags);
+      sink.writeInt((int) windowSizeIncrement);
+      sink.flush();
+    }
+
+    @Override public synchronized void close() throws IOException {
+      closed = true;
+      sink.close();
+    }
+
+    void frameHeader(int streamId, int length, byte type, byte flags) throws IOException {
+      if (logger.isLoggable(FINE)) logger.fine(formatHeader(false, streamId, length, type, flags));
+      if (length > maxFrameSize) {
+        throw illegalArgument("FRAME_SIZE_ERROR length > %d: %d", maxFrameSize, length);
+      }
+      if ((streamId & 0x80000000) != 0) throw illegalArgument("reserved bit set: %s", streamId);
+      writeMedium(sink, length);
+      sink.writeByte(type & 0xff);
+      sink.writeByte(flags & 0xff);
+      sink.writeInt(streamId & 0x7fffffff);
+    }
+  }
+
+  private static IllegalArgumentException illegalArgument(String message, Object... args) {
+    throw new IllegalArgumentException(format(message, args));
+  }
+
+  private static IOException ioException(String message, Object... args) throws IOException {
+    throw new IOException(format(message, args));
+  }
+
+  /**
+   * Decompression of the header block occurs above the framing layer. This
+   * class lazily reads continuation frames as they are needed by {@link
+   * HpackDraft09.Reader#readHeaders()}.
+   */
+  static final class ContinuationSource implements Source {
+    private final BufferedSource source;
+
+    int length;
+    byte flags;
+    int streamId;
+
+    int left;
+    short padding;
+
+    public ContinuationSource(BufferedSource source) {
+      this.source = source;
+    }
+
+    @Override public long read(Buffer sink, long byteCount) throws IOException {
+      while (left == 0) {
+        source.skip(padding);
+        padding = 0;
+        if ((flags & FLAG_END_HEADERS) != 0) return -1;
+        readContinuationHeader();
+        // TODO: test case for empty continuation header?
+      }
+
+      long read = source.read(sink, Math.min(byteCount, left));
+      if (read == -1) return -1;
+      left -= read;
+      return read;
+    }
+
+    @Override public Timeout timeout() {
+      return source.timeout();
+    }
+
+    @Override public void close() throws IOException {
+    }
+
+    private void readContinuationHeader() throws IOException {
+      int previousStreamId = streamId;
+
+      length = left = readMedium(source);
+      byte type = (byte) (source.readByte() & 0xff);
+      flags = (byte) (source.readByte() & 0xff);
+      if (logger.isLoggable(FINE)) logger.fine(formatHeader(true, streamId, length, type, flags));
+      streamId = (source.readInt() & 0x7fffffff);
+      if (type != TYPE_CONTINUATION) throw ioException("%s != TYPE_CONTINUATION", type);
+      if (streamId != previousStreamId) throw ioException("TYPE_CONTINUATION streamId changed");
+    }
+  }
+
+  private static int lengthWithoutPadding(int length, byte flags, short padding)
+      throws IOException {
+    if ((flags & FLAG_PADDED) != 0) length--; // Account for reading the padding length.
+    if (padding > length) {
+      throw ioException("PROTOCOL_ERROR padding %s > remaining length %s", padding, length);
+    }
+    return (short) (length - padding);
+  }
+
+  /**
+   * Logs a human-readable representation of HTTP/2 frame headers.
+   *
+   * <p>The format is:
+   *
+   * <pre>
+   *   direction streamID length type flags
+   * </pre>
+   * Where direction is {@code <<} for inbound and {@code >>} for outbound.
+   *
+   * <p> For example, the following would indicate a HEAD request sent from
+   * the client.
+   * <pre>
+   * {@code
+   *   << 0x0000000f    12 HEADERS       END_HEADERS|END_STREAM
+   * }
+   * </pre>
+   */
+  static final class FrameLogger {
+
+    static String formatHeader(boolean inbound, int streamId, int length, byte type, byte flags) {
+      String formattedType = type < TYPES.length ? TYPES[type] : format("0x%02x", type);
+      String formattedFlags = formatFlags(type, flags);
+      return format("%s 0x%08x %5d %-13s %s", inbound ? "<<" : ">>", streamId, length,
+          formattedType, formattedFlags);
+    }
+
+    /**
+     * Looks up valid string representing flags from the table. Invalid
+     * combinations are represented in binary.
+     */
+    // Visible for testing.
+    static String formatFlags(byte type, byte flags) {
+      if (flags == 0) return "";
+      switch (type) { // Special case types that have 0 or 1 flag.
+        case TYPE_SETTINGS:
+        case TYPE_PING:
+          return flags == FLAG_ACK ? "ACK" : BINARY[flags];
+        case TYPE_PRIORITY:
+        case TYPE_RST_STREAM:
+        case TYPE_GOAWAY:
+        case TYPE_WINDOW_UPDATE:
+          return BINARY[flags];
+      }
+      String result = flags < FLAGS.length ? FLAGS[flags] : BINARY[flags];
+      // Special case types that have overlap flag values.
+      if (type == TYPE_PUSH_PROMISE && (flags & FLAG_END_PUSH_PROMISE) != 0) {
+        return result.replace("HEADERS", "PUSH_PROMISE"); // TODO: Avoid allocation.
+      } else if (type == TYPE_DATA && (flags & FLAG_COMPRESSED) != 0) {
+        return result.replace("PRIORITY", "COMPRESSED"); // TODO: Avoid allocation.
+      }
+      return result;
+    }
+
+    /** Lookup table for valid frame types. */
+    private static final String[] TYPES = new String[] {
+        "DATA",
+        "HEADERS",
+        "PRIORITY",
+        "RST_STREAM",
+        "SETTINGS",
+        "PUSH_PROMISE",
+        "PING",
+        "GOAWAY",
+        "WINDOW_UPDATE",
+        "CONTINUATION"
+    };
+
+    /**
+     * Lookup table for valid flags for DATA, HEADERS, CONTINUATION. Invalid
+     * combinations are represented in binary.
+     */
+    private static final String[] FLAGS = new String[0x40]; // Highest bit flag is 0x20.
+    private static final String[] BINARY = new String[256];
+
+    static {
+      for (int i = 0; i < BINARY.length; i++) {
+        BINARY[i] = format("%8s", Integer.toBinaryString(i)).replace(' ', '0');
+      }
+
+      FLAGS[FLAG_NONE] = "";
+      FLAGS[FLAG_END_STREAM] = "END_STREAM";
+
+      int[] prefixFlags = new int[] {FLAG_END_STREAM};
+
+      FLAGS[FLAG_PADDED] = "PADDED";
+      for (int prefixFlag : prefixFlags) {
+         FLAGS[prefixFlag | FLAG_PADDED] = FLAGS[prefixFlag] + "|PADDED";
+      }
+
+      FLAGS[FLAG_END_HEADERS] = "END_HEADERS"; // Same as END_PUSH_PROMISE.
+      FLAGS[FLAG_PRIORITY] = "PRIORITY"; // Same as FLAG_COMPRESSED.
+      FLAGS[FLAG_END_HEADERS | FLAG_PRIORITY] = "END_HEADERS|PRIORITY"; // Only valid on HEADERS.
+      int[] frameFlags =
+          new int[] {FLAG_END_HEADERS, FLAG_PRIORITY, FLAG_END_HEADERS | FLAG_PRIORITY};
+
+      for (int frameFlag : frameFlags) {
+        for (int prefixFlag : prefixFlags) {
+          FLAGS[prefixFlag | frameFlag] = FLAGS[prefixFlag] + '|' + FLAGS[frameFlag];
+          FLAGS[prefixFlag | frameFlag | FLAG_PADDED] =
+              FLAGS[prefixFlag] + '|' + FLAGS[frameFlag] + "|PADDED";
+        }
+      }
+
+      for (int i = 0; i < FLAGS.length; i++) { // Fill in holes with binary representation.
+        if (FLAGS[i] == null) FLAGS[i] = BINARY[i];
+      }
+    }
+  }
+
+  private static int readMedium(BufferedSource source) throws IOException {
+    return (source.readByte() & 0xff) << 16
+        |  (source.readByte() & 0xff) <<  8
+        |  (source.readByte() & 0xff);
+  }
+
+  private static void writeMedium(BufferedSink sink, int i) throws IOException {
+    sink.writeByte((i >>> 16) & 0xff);
+    sink.writeByte((i >>>  8) & 0xff);
+    sink.writeByte(i          & 0xff);
+  }
+}
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/Huffman.java b/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/Huffman.java
index 45d882f6e4..91cb59eff0 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/Huffman.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/Huffman.java
@@ -18,7 +18,6 @@
 import java.io.ByteArrayOutputStream;
 import java.io.IOException;
 import java.io.OutputStream;
-import okio.ByteString;
 
 /**
  * This class was originally composed from the following classes in
@@ -30,132 +29,165 @@
  * </ul>
  */
 class Huffman {
-  enum Codec {
-    REQUEST(REQUEST_CODES, REQUEST_CODE_LENGTHS),
-    RESPONSE(RESPONSE_CODES, RESPONSE_CODE_LENGTHS);
 
-    private final Node root = new Node();
-    private final int[] codes;
-    private final byte[] lengths;
+  // Appendix C: Huffman Codes
+  // http://tools.ietf.org/html/draft-ietf-httpbis-header-compression-09#appendix-C
+  private static final int[] CODES = {
+      0x1ff8, 0x7fffd8, 0xfffffe2, 0xfffffe3, 0xfffffe4, 0xfffffe5, 0xfffffe6, 0xfffffe7, 0xfffffe8,
+      0xffffea, 0x3ffffffc, 0xfffffe9, 0xfffffea, 0x3ffffffd, 0xfffffeb, 0xfffffec, 0xfffffed,
+      0xfffffee, 0xfffffef, 0xffffff0, 0xffffff1, 0xffffff2, 0x3ffffffe, 0xffffff3, 0xffffff4,
+      0xffffff5, 0xffffff6, 0xffffff7, 0xffffff8, 0xffffff9, 0xffffffa, 0xffffffb, 0x14, 0x3f8,
+      0x3f9, 0xffa, 0x1ff9, 0x15, 0xf8, 0x7fa, 0x3fa, 0x3fb, 0xf9, 0x7fb, 0xfa, 0x16, 0x17, 0x18,
+      0x0, 0x1, 0x2, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f, 0x5c, 0xfb, 0x7ffc, 0x20, 0xffb,
+      0x3fc, 0x1ffa, 0x21, 0x5d, 0x5e, 0x5f, 0x60, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68,
+      0x69, 0x6a, 0x6b, 0x6c, 0x6d, 0x6e, 0x6f, 0x70, 0x71, 0x72, 0xfc, 0x73, 0xfd, 0x1ffb, 0x7fff0,
+      0x1ffc, 0x3ffc, 0x22, 0x7ffd, 0x3, 0x23, 0x4, 0x24, 0x5, 0x25, 0x26, 0x27, 0x6, 0x74, 0x75,
+      0x28, 0x29, 0x2a, 0x7, 0x2b, 0x76, 0x2c, 0x8, 0x9, 0x2d, 0x77, 0x78, 0x79, 0x7a, 0x7b, 0x7ffe,
+      0x7fc, 0x3ffd, 0x1ffd, 0xffffffc, 0xfffe6, 0x3fffd2, 0xfffe7, 0xfffe8, 0x3fffd3, 0x3fffd4,
+      0x3fffd5, 0x7fffd9, 0x3fffd6, 0x7fffda, 0x7fffdb, 0x7fffdc, 0x7fffdd, 0x7fffde, 0xffffeb,
+      0x7fffdf, 0xffffec, 0xffffed, 0x3fffd7, 0x7fffe0, 0xffffee, 0x7fffe1, 0x7fffe2, 0x7fffe3,
+      0x7fffe4, 0x1fffdc, 0x3fffd8, 0x7fffe5, 0x3fffd9, 0x7fffe6, 0x7fffe7, 0xffffef, 0x3fffda,
+      0x1fffdd, 0xfffe9, 0x3fffdb, 0x3fffdc, 0x7fffe8, 0x7fffe9, 0x1fffde, 0x7fffea, 0x3fffdd,
+      0x3fffde, 0xfffff0, 0x1fffdf, 0x3fffdf, 0x7fffeb, 0x7fffec, 0x1fffe0, 0x1fffe1, 0x3fffe0,
+      0x1fffe2, 0x7fffed, 0x3fffe1, 0x7fffee, 0x7fffef, 0xfffea, 0x3fffe2, 0x3fffe3, 0x3fffe4,
+      0x7ffff0, 0x3fffe5, 0x3fffe6, 0x7ffff1, 0x3ffffe0, 0x3ffffe1, 0xfffeb, 0x7fff1, 0x3fffe7,
+      0x7ffff2, 0x3fffe8, 0x1ffffec, 0x3ffffe2, 0x3ffffe3, 0x3ffffe4, 0x7ffffde, 0x7ffffdf,
+      0x3ffffe5, 0xfffff1, 0x1ffffed, 0x7fff2, 0x1fffe3, 0x3ffffe6, 0x7ffffe0, 0x7ffffe1, 0x3ffffe7,
+      0x7ffffe2, 0xfffff2, 0x1fffe4, 0x1fffe5, 0x3ffffe8, 0x3ffffe9, 0xffffffd, 0x7ffffe3,
+      0x7ffffe4, 0x7ffffe5, 0xfffec, 0xfffff3, 0xfffed, 0x1fffe6, 0x3fffe9, 0x1fffe7, 0x1fffe8,
+      0x7ffff3, 0x3fffea, 0x3fffeb, 0x1ffffee, 0x1ffffef, 0xfffff4, 0xfffff5, 0x3ffffea, 0x7ffff4,
+      0x3ffffeb, 0x7ffffe6, 0x3ffffec, 0x3ffffed, 0x7ffffe7, 0x7ffffe8, 0x7ffffe9, 0x7ffffea,
+      0x7ffffeb, 0xffffffe, 0x7ffffec, 0x7ffffed, 0x7ffffee, 0x7ffffef, 0x7fffff0, 0x3ffffee
+  };
 
-    /**
-     * @param codes Index designates the symbol this code represents.
-     * @param lengths Index designates the symbol this code represents.
-     */
-    Codec(int[] codes, byte[] lengths) {
-      buildTree(codes, lengths);
-      this.codes = codes;
-      this.lengths = lengths;
-    }
+  private static final byte[] CODE_LENGTHS = {
+      13, 23, 28, 28, 28, 28, 28, 28, 28, 24, 30, 28, 28, 30, 28, 28, 28, 28, 28, 28, 28, 28, 30,
+      28, 28, 28, 28, 28, 28, 28, 28, 28, 6, 10, 10, 12, 13, 6, 8, 11, 10, 10, 8, 11, 8, 6, 6, 6, 5,
+      5, 5, 6, 6, 6, 6, 6, 6, 6, 7, 8, 15, 6, 12, 10, 13, 6, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
+      7, 7, 7, 7, 7, 7, 7, 7, 7, 8, 7, 8, 13, 19, 13, 14, 6, 15, 5, 6, 5, 6, 5, 6, 6, 6, 5, 7, 7, 6,
+      6, 6, 5, 6, 7, 6, 5, 5, 6, 7, 7, 7, 7, 7, 15, 11, 14, 13, 28, 20, 22, 20, 20, 22, 22, 22, 23,
+      22, 23, 23, 23, 23, 23, 24, 23, 24, 24, 22, 23, 24, 23, 23, 23, 23, 21, 22, 23, 22, 23, 23,
+      24, 22, 21, 20, 22, 22, 23, 23, 21, 23, 22, 22, 24, 21, 22, 23, 23, 21, 21, 22, 21, 23, 22,
+      23, 23, 20, 22, 22, 22, 23, 22, 22, 23, 26, 26, 20, 19, 22, 23, 22, 25, 26, 26, 26, 27, 27,
+      26, 24, 25, 19, 21, 26, 27, 27, 26, 27, 24, 21, 21, 26, 26, 28, 27, 27, 27, 20, 24, 20, 21,
+      22, 21, 21, 23, 22, 22, 25, 25, 24, 24, 26, 23, 26, 27, 26, 26, 27, 27, 27, 27, 27, 28, 27,
+      27, 27, 27, 27, 26
+  };
 
-    void encode(byte[] data, OutputStream out) throws IOException {
-      long current = 0;
-      int n = 0;
+  private static final Huffman INSTANCE = new Huffman();
 
-      for (int i = 0; i < data.length; i++) {
-        int b = data[i] & 0xFF;
-        int code = codes[b];
-        int nbits = lengths[b];
+  public static Huffman get() {
+    return INSTANCE;
+  }
 
-        current <<= nbits;
-        current |= code;
-        n += nbits;
+  private final Node root = new Node();
 
-        while (n >= 8) {
-          n -= 8;
-          out.write(((int) (current >> n)));
-        }
-      }
+  private Huffman() {
+    buildTree();
+  }
 
-      if (n > 0) {
-        current <<= (8 - n);
-        current |= (0xFF >>> n);
-        out.write((int) current);
-      }
-    }
+  void encode(byte[] data, OutputStream out) throws IOException {
+    long current = 0;
+    int n = 0;
+
+    for (int i = 0; i < data.length; i++) {
+      int b = data[i] & 0xFF;
+      int code = CODES[b];
+      int nbits = CODE_LENGTHS[b];
 
-    int encodedLength(byte[] bytes) {
-      long len = 0;
+      current <<= nbits;
+      current |= code;
+      n += nbits;
 
-      for (int i = 0; i < bytes.length; i++) {
-        int b = bytes[i] & 0xFF;
-        len += lengths[b];
+      while (n >= 8) {
+        n -= 8;
+        out.write(((int) (current >> n)));
       }
+    }
 
-      return (int) ((len + 7) >> 3);
+    if (n > 0) {
+      current <<= (8 - n);
+      current |= (0xFF >>> n);
+      out.write((int) current);
     }
+  }
+
+  int encodedLength(byte[] bytes) {
+    long len = 0;
 
-    ByteString decode(ByteString buf) throws IOException {
-      return ByteString.of(decode(buf.toByteArray()));
+    for (int i = 0; i < bytes.length; i++) {
+      int b = bytes[i] & 0xFF;
+      len += CODE_LENGTHS[b];
     }
 
-    byte[] decode(byte[] buf) throws IOException {
-      // FIXME
-      ByteArrayOutputStream baos = new ByteArrayOutputStream();
-      Node node = root;
-      int current = 0;
-      int nbits = 0;
-      for (int i = 0; i < buf.length; i++) {
-        int b = buf[i] & 0xFF;
-        current = (current << 8) | b;
-        nbits += 8;
-        while (nbits >= 8) {
-          int c = (current >>> (nbits - 8)) & 0xFF;
-          node = node.children[c];
-          if (node.children == null) {
-            // terminal node
-            baos.write(node.symbol);
-            nbits -= node.terminalBits;
-            node = root;
-          } else {
-            // non-terminal node
-            nbits -= 8;
-          }
-        }
-      }
+    return (int) ((len + 7) >> 3);
+  }
 
-      while (nbits > 0) {
-        int c = (current << (8 - nbits)) & 0xFF;
+  byte[] decode(byte[] buf) throws IOException {
+    ByteArrayOutputStream baos = new ByteArrayOutputStream();
+    Node node = root;
+    int current = 0;
+    int nbits = 0;
+    for (int i = 0; i < buf.length; i++) {
+      int b = buf[i] & 0xFF;
+      current = (current << 8) | b;
+      nbits += 8;
+      while (nbits >= 8) {
+        int c = (current >>> (nbits - 8)) & 0xFF;
         node = node.children[c];
-        if (node.children != null || node.terminalBits > nbits) {
-          break;
+        if (node.children == null) {
+          // terminal node
+          baos.write(node.symbol);
+          nbits -= node.terminalBits;
+          node = root;
+        } else {
+          // non-terminal node
+          nbits -= 8;
         }
-        baos.write(node.symbol);
-        nbits -= node.terminalBits;
-        node = root;
       }
-
-      return baos.toByteArray();
     }
 
-    private void buildTree(int[] codes, byte[] lengths) {
-      for (int i = 0; i < lengths.length; i++) {
-        addCode(i, codes[i], lengths[i]);
+    while (nbits > 0) {
+      int c = (current << (8 - nbits)) & 0xFF;
+      node = node.children[c];
+      if (node.children != null || node.terminalBits > nbits) {
+        break;
       }
+      baos.write(node.symbol);
+      nbits -= node.terminalBits;
+      node = root;
     }
 
-    private void addCode(int sym, int code, byte len) {
-      Node terminal = new Node(sym, len);
+    return baos.toByteArray();
+  }
 
-      Node current = root;
-      while (len > 8) {
-        len -= 8;
-        int i = ((code >>> len) & 0xFF);
-        if (current.children == null) {
-          throw new IllegalStateException("invalid dictionary: prefix not unique");
-        }
-        if (current.children[i] == null) {
-          current.children[i] = new Node();
-        }
-        current = current.children[i];
-      }
+  private void buildTree() {
+    for (int i = 0; i < CODE_LENGTHS.length; i++) {
+      addCode(i, CODES[i], CODE_LENGTHS[i]);
+    }
+  }
+
+  private void addCode(int sym, int code, byte len) {
+    Node terminal = new Node(sym, len);
 
-      int shift = 8 - len;
-      int start = (code << shift) & 0xFF;
-      int end = 1 << shift;
-      for (int i = start; i < start + end; i++) {
-        current.children[i] = terminal;
+    Node current = root;
+    while (len > 8) {
+      len -= 8;
+      int i = ((code >>> len) & 0xFF);
+      if (current.children == null) {
+        throw new IllegalStateException("invalid dictionary: prefix not unique");
       }
+      if (current.children[i] == null) {
+        current.children[i] = new Node();
+      }
+      current = current.children[i];
+    }
+
+    int shift = 8 - len;
+    int start = (code << shift) & 0xFF;
+    int end = 1 << shift;
+    for (int i = start; i < start + end; i++) {
+      current.children[i] = terminal;
     }
   }
 
@@ -190,95 +222,4 @@ private void addCode(int sym, int code, byte len) {
       this.terminalBits = b == 0 ? 8 : b;
     }
   }
-
-  // Appendix C: Huffman Codes For Requests
-  // http://tools.ietf.org/html/draft-ietf-httpbis-header-compression-05#appendix-C
-  private static final int[] REQUEST_CODES = {
-      0x7ffffba, 0x7ffffbb, 0x7ffffbc, 0x7ffffbd, 0x7ffffbe, 0x7ffffbf, 0x7ffffc0, 0x7ffffc1,
-      0x7ffffc2, 0x7ffffc3, 0x7ffffc4, 0x7ffffc5, 0x7ffffc6, 0x7ffffc7, 0x7ffffc8, 0x7ffffc9,
-      0x7ffffca, 0x7ffffcb, 0x7ffffcc, 0x7ffffcd, 0x7ffffce, 0x7ffffcf, 0x7ffffd0, 0x7ffffd1,
-      0x7ffffd2, 0x7ffffd3, 0x7ffffd4, 0x7ffffd5, 0x7ffffd6, 0x7ffffd7, 0x7ffffd8, 0x7ffffd9, 0xe8,
-      0xffc, 0x3ffa, 0x7ffc, 0x7ffd, 0x24, 0x6e, 0x7ffe, 0x7fa, 0x7fb, 0x3fa, 0x7fc, 0xe9, 0x25,
-      0x4, 0x0, 0x5, 0x6, 0x7, 0x26, 0x27, 0x28, 0x29, 0x2a, 0x2b, 0x2c, 0x1ec, 0xea, 0x3fffe, 0x2d,
-      0x1fffc, 0x1ed, 0x3ffb, 0x6f, 0xeb, 0xec, 0xed, 0xee, 0x70, 0x1ee, 0x1ef, 0x1f0, 0x1f1, 0x3fb,
-      0x1f2, 0xef, 0x1f3, 0x1f4, 0x1f5, 0x1f6, 0x1f7, 0xf0, 0xf1, 0x1f8, 0x1f9, 0x1fa, 0x1fb, 0x1fc,
-      0x3fc, 0x3ffc, 0x7ffffda, 0x1ffc, 0x3ffd, 0x2e, 0x7fffe, 0x8, 0x2f, 0x9, 0x30, 0x1, 0x31,
-      0x32, 0x33, 0xa, 0x71, 0x72, 0xb, 0x34, 0xc, 0xd, 0xe, 0xf2, 0xf, 0x10, 0x11, 0x35, 0x73,
-      0x36, 0xf3, 0xf4, 0xf5, 0x1fffd, 0x7fd, 0x1fffe, 0xffd, 0x7ffffdb, 0x7ffffdc, 0x7ffffdd,
-      0x7ffffde, 0x7ffffdf, 0x7ffffe0, 0x7ffffe1, 0x7ffffe2, 0x7ffffe3, 0x7ffffe4, 0x7ffffe5,
-      0x7ffffe6, 0x7ffffe7, 0x7ffffe8, 0x7ffffe9, 0x7ffffea, 0x7ffffeb, 0x7ffffec, 0x7ffffed,
-      0x7ffffee, 0x7ffffef, 0x7fffff0, 0x7fffff1, 0x7fffff2, 0x7fffff3, 0x7fffff4, 0x7fffff5,
-      0x7fffff6, 0x7fffff7, 0x7fffff8, 0x7fffff9, 0x7fffffa, 0x7fffffb, 0x7fffffc, 0x7fffffd,
-      0x7fffffe, 0x7ffffff, 0x3ffff80, 0x3ffff81, 0x3ffff82, 0x3ffff83, 0x3ffff84, 0x3ffff85,
-      0x3ffff86, 0x3ffff87, 0x3ffff88, 0x3ffff89, 0x3ffff8a, 0x3ffff8b, 0x3ffff8c, 0x3ffff8d,
-      0x3ffff8e, 0x3ffff8f, 0x3ffff90, 0x3ffff91, 0x3ffff92, 0x3ffff93, 0x3ffff94, 0x3ffff95,
-      0x3ffff96, 0x3ffff97, 0x3ffff98, 0x3ffff99, 0x3ffff9a, 0x3ffff9b, 0x3ffff9c, 0x3ffff9d,
-      0x3ffff9e, 0x3ffff9f, 0x3ffffa0, 0x3ffffa1, 0x3ffffa2, 0x3ffffa3, 0x3ffffa4, 0x3ffffa5,
-      0x3ffffa6, 0x3ffffa7, 0x3ffffa8, 0x3ffffa9, 0x3ffffaa, 0x3ffffab, 0x3ffffac, 0x3ffffad,
-      0x3ffffae, 0x3ffffaf, 0x3ffffb0, 0x3ffffb1, 0x3ffffb2, 0x3ffffb3, 0x3ffffb4, 0x3ffffb5,
-      0x3ffffb6, 0x3ffffb7, 0x3ffffb8, 0x3ffffb9, 0x3ffffba, 0x3ffffbb, 0x3ffffbc, 0x3ffffbd,
-      0x3ffffbe, 0x3ffffbf, 0x3ffffc0, 0x3ffffc1, 0x3ffffc2, 0x3ffffc3, 0x3ffffc4, 0x3ffffc5,
-      0x3ffffc6, 0x3ffffc7, 0x3ffffc8, 0x3ffffc9, 0x3ffffca, 0x3ffffcb, 0x3ffffcc, 0x3ffffcd,
-      0x3ffffce, 0x3ffffcf, 0x3ffffd0, 0x3ffffd1, 0x3ffffd2, 0x3ffffd3, 0x3ffffd4, 0x3ffffd5,
-      0x3ffffd6, 0x3ffffd7, 0x3ffffd8, 0x3ffffd9, 0x3ffffda, 0x3ffffdb
-  };
-
-  private static final byte[] REQUEST_CODE_LENGTHS = {
-      27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27,
-      27, 27, 27, 27, 27, 27, 27, 27, 27, 8, 12, 14, 15, 15, 6, 7, 15, 11, 11, 10, 11, 8, 6, 5, 4,
-      5, 5, 5, 6, 6, 6, 6, 6, 6, 6, 9, 8, 18, 6, 17, 9, 14, 7, 8, 8, 8, 8, 7, 9, 9, 9, 9, 10, 9, 8,
-      9, 9, 9, 9, 9, 8, 8, 9, 9, 9, 9, 9, 10, 14, 27, 13, 14, 6, 19, 5, 6, 5, 6, 4, 6, 6, 6, 5, 7,
-      7, 5, 6, 5, 5, 5, 8, 5, 5, 5, 6, 7, 6, 8, 8, 8, 17, 11, 17, 12, 27, 27, 27, 27, 27, 27, 27,
-      27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27,
-      27, 27, 27, 27, 27, 27, 27, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26,
-      26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26,
-      26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26,
-      26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26,
-      26, 26, 26, 26, 26, 26, 26
-  };
-
-  // Appendix D: Huffman Codes For Responses
-  // http://tools.ietf.org/html/draft-ietf-httpbis-header-compression-05#appendix-D
-  private static final int[] RESPONSE_CODES = {
-      0x1ffffbc, 0x1ffffbd, 0x1ffffbe, 0x1ffffbf, 0x1ffffc0, 0x1ffffc1, 0x1ffffc2, 0x1ffffc3,
-      0x1ffffc4, 0x1ffffc5, 0x1ffffc6, 0x1ffffc7, 0x1ffffc8, 0x1ffffc9, 0x1ffffca, 0x1ffffcb,
-      0x1ffffcc, 0x1ffffcd, 0x1ffffce, 0x1ffffcf, 0x1ffffd0, 0x1ffffd1, 0x1ffffd2, 0x1ffffd3,
-      0x1ffffd4, 0x1ffffd5, 0x1ffffd6, 0x1ffffd7, 0x1ffffd8, 0x1ffffd9, 0x1ffffda, 0x1ffffdb, 0x0,
-      0xffa, 0x6a, 0x1ffa, 0x3ffc, 0x1ec, 0x3f8, 0x1ffb, 0x1ed, 0x1ee, 0xffb, 0x7fa, 0x22, 0x23,
-      0x24, 0x6b, 0x1, 0x2, 0x3, 0x8, 0x9, 0xa, 0x25, 0x26, 0xb, 0xc, 0xd, 0x1ef, 0xfffa, 0x6c,
-      0x1ffc, 0xffc, 0xfffb, 0x6d, 0xea, 0xeb, 0xec, 0xed, 0xee, 0x27, 0x1f0, 0xef, 0xf0, 0x3f9,
-      0x1f1, 0x28, 0xf1, 0xf2, 0x1f2, 0x3fa, 0x1f3, 0x29, 0xe, 0x1f4, 0x1f5, 0xf3, 0x3fb, 0x1f6,
-      0x3fc, 0x7fb, 0x1ffd, 0x7fc, 0x7ffc, 0x1f7, 0x1fffe, 0xf, 0x6e, 0x2a, 0x2b, 0x10, 0x6f, 0x70,
-      0x71, 0x2c, 0x1f8, 0x1f9, 0x72, 0x2d, 0x2e, 0x2f, 0x30, 0x1fa, 0x31, 0x32, 0x33, 0x34, 0x73,
-      0xf4, 0x74, 0xf5, 0x1fb, 0xfffc, 0x3ffd, 0xfffd, 0xfffe, 0x1ffffdc, 0x1ffffdd, 0x1ffffde,
-      0x1ffffdf, 0x1ffffe0, 0x1ffffe1, 0x1ffffe2, 0x1ffffe3, 0x1ffffe4, 0x1ffffe5, 0x1ffffe6,
-      0x1ffffe7, 0x1ffffe8, 0x1ffffe9, 0x1ffffea, 0x1ffffeb, 0x1ffffec, 0x1ffffed, 0x1ffffee,
-      0x1ffffef, 0x1fffff0, 0x1fffff1, 0x1fffff2, 0x1fffff3, 0x1fffff4, 0x1fffff5, 0x1fffff6,
-      0x1fffff7, 0x1fffff8, 0x1fffff9, 0x1fffffa, 0x1fffffb, 0x1fffffc, 0x1fffffd, 0x1fffffe,
-      0x1ffffff, 0xffff80, 0xffff81, 0xffff82, 0xffff83, 0xffff84, 0xffff85, 0xffff86, 0xffff87,
-      0xffff88, 0xffff89, 0xffff8a, 0xffff8b, 0xffff8c, 0xffff8d, 0xffff8e, 0xffff8f, 0xffff90,
-      0xffff91, 0xffff92, 0xffff93, 0xffff94, 0xffff95, 0xffff96, 0xffff97, 0xffff98, 0xffff99,
-      0xffff9a, 0xffff9b, 0xffff9c, 0xffff9d, 0xffff9e, 0xffff9f, 0xffffa0, 0xffffa1, 0xffffa2,
-      0xffffa3, 0xffffa4, 0xffffa5, 0xffffa6, 0xffffa7, 0xffffa8, 0xffffa9, 0xffffaa, 0xffffab,
-      0xffffac, 0xffffad, 0xffffae, 0xffffaf, 0xffffb0, 0xffffb1, 0xffffb2, 0xffffb3, 0xffffb4,
-      0xffffb5, 0xffffb6, 0xffffb7, 0xffffb8, 0xffffb9, 0xffffba, 0xffffbb, 0xffffbc, 0xffffbd,
-      0xffffbe, 0xffffbf, 0xffffc0, 0xffffc1, 0xffffc2, 0xffffc3, 0xffffc4, 0xffffc5, 0xffffc6,
-      0xffffc7, 0xffffc8, 0xffffc9, 0xffffca, 0xffffcb, 0xffffcc, 0xffffcd, 0xffffce, 0xffffcf,
-      0xffffd0, 0xffffd1, 0xffffd2, 0xffffd3, 0xffffd4, 0xffffd5, 0xffffd6, 0xffffd7, 0xffffd8,
-      0xffffd9, 0xffffda, 0xffffdb, 0xffffdc
-  };
-
-  private static final byte[] RESPONSE_CODE_LENGTHS = {
-      25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25,
-      25, 25, 25, 25, 25, 25, 25, 25, 25, 4, 12, 7, 13, 14, 9, 10, 13, 9, 9, 12, 11, 6, 6, 6, 7, 4,
-      4, 4, 5, 5, 5, 6, 6, 5, 5, 5, 9, 16, 7, 13, 12, 16, 7, 8, 8, 8, 8, 8, 6, 9, 8, 8, 10, 9, 6, 8,
-      8, 9, 10, 9, 6, 5, 9, 9, 8, 10, 9, 10, 11, 13, 11, 15, 9, 17, 5, 7, 6, 6, 5, 7, 7, 7, 6, 9, 9,
-      7, 6, 6, 6, 6, 9, 6, 6, 6, 6, 7, 8, 7, 8, 9, 16, 14, 16, 16, 25, 25, 25, 25, 25, 25, 25, 25,
-      25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25,
-      25, 25, 25, 25, 25, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
-      24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
-      24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
-      24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
-      24, 24, 24, 24, 24, 24
-  };
 }
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/NameValueBlockReader.java b/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/NameValueBlockReader.java
index 293d817a19..6413f36345 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/NameValueBlockReader.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/NameValueBlockReader.java
@@ -1,3 +1,18 @@
+/*
+ * Copyright (C) 2013 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 package com.squareup.okhttp.internal.spdy;
 
 import java.io.IOException;
@@ -5,11 +20,11 @@
 import java.util.List;
 import java.util.zip.DataFormatException;
 import java.util.zip.Inflater;
+import okio.Buffer;
 import okio.BufferedSource;
 import okio.ByteString;
-import okio.Deadline;
+import okio.ForwardingSource;
 import okio.InflaterSource;
-import okio.OkBuffer;
 import okio.Okio;
 import okio.Source;
 
@@ -32,28 +47,18 @@
   /** This source holds inflated bytes. */
   private final BufferedSource source;
 
-  public NameValueBlockReader(final BufferedSource source) {
+  public NameValueBlockReader(BufferedSource source) {
     // Limit the inflater input stream to only those bytes in the Name/Value
     // block. We cut the inflater off at its source because we can't predict the
     // ratio of compressed bytes to uncompressed bytes.
-    Source throttleSource = new Source() {
-      @Override public long read(OkBuffer sink, long byteCount)
-          throws IOException {
+    Source throttleSource = new ForwardingSource(source) {
+      @Override public long read(Buffer sink, long byteCount) throws IOException {
         if (compressedLimit == 0) return -1; // Out of data for the current block.
-        long read = source.read(sink, Math.min(byteCount, compressedLimit));
+        long read = super.read(sink, Math.min(byteCount, compressedLimit));
         if (read == -1) return -1;
         compressedLimit -= read;
         return read;
       }
-
-      @Override public void close() throws IOException {
-        source.close();
-      }
-
-      @Override public Source deadline(Deadline deadline) {
-        source.deadline(deadline);
-        return this;
-      }
     };
 
     // Subclass inflater to install a dictionary when it's needed.
@@ -80,7 +85,7 @@ public NameValueBlockReader(final BufferedSource source) {
     if (numberOfPairs < 0) throw new IOException("numberOfPairs < 0: " + numberOfPairs);
     if (numberOfPairs > 1024) throw new IOException("numberOfPairs > 1024: " + numberOfPairs);
 
-    List<Header> entries = new ArrayList<Header>(numberOfPairs);
+    List<Header> entries = new ArrayList<>(numberOfPairs);
     for (int i = 0; i < numberOfPairs; i++) {
       ByteString name = readByteString().toAsciiLowercase();
       ByteString values = readByteString();
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/Ping.java b/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/Ping.java
index c585255780..06b0aefccf 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/Ping.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/Ping.java
@@ -49,7 +49,7 @@ void cancel() {
   /**
    * Returns the round trip time for this ping in nanoseconds, waiting for the
    * response to arrive if necessary. Returns -1 if the response was
-   * cancelled.
+   * canceled.
    */
   public long roundTripTime() throws InterruptedException {
     latch.await();
@@ -58,7 +58,7 @@ public long roundTripTime() throws InterruptedException {
 
   /**
    * Returns the round trip time for this ping in nanoseconds, or -1 if the
-   * response was cancelled, or -2 if the timeout elapsed before the round
+   * response was canceled, or -2 if the timeout elapsed before the round
    * trip completed.
    */
   public long roundTripTime(long timeout, TimeUnit unit) throws InterruptedException {
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/PushObserver.java b/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/PushObserver.java
index 8eecf6b848..cdb51f65a5 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/PushObserver.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/PushObserver.java
@@ -21,9 +21,19 @@
 
 /**
  * {@link com.squareup.okhttp.Protocol#HTTP_2 HTTP/2} only.
- * Processes server-initiated HTTP requests on the client.
+ * Processes server-initiated HTTP requests on the client. Implementations must
+ * quickly dispatch callbacks to avoid creating a bottleneck.
  *
- * <p>Use the stream ID to correlate response headers and data.
+ * <p>While {@link #onReset} may occur at any time, the following callbacks are
+ * expected in order, correlated by stream ID.
+ * <ul>
+ *   <li>{@link #onRequest}</li>
+ *   <li>{@link #onHeaders} (unless canceled)</li>
+ *   <li>{@link #onData} (optional sequence of data frames)</li>
+ * </ul>
+ *
+ * <p>As a stream ID is scoped to a single HTTP/2 connection, implementations
+ * which target multiple connections should expect repetition of stream IDs.
  *
  * <p>Return true to request cancellation of a pushed stream.  Note that this
  * does not guarantee future frames won't arrive on the stream ID.
@@ -60,7 +70,7 @@
   boolean onData(int streamId, BufferedSource source, int byteCount, boolean last)
       throws IOException;
 
-  /** Indicates the reason why this stream was cancelled. */
+  /** Indicates the reason why this stream was canceled. */
   void onReset(int streamId, ErrorCode errorCode);
 
   PushObserver CANCEL = new PushObserver() {
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/Settings.java b/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/Settings.java
index c05d6b174f..8a6cbf398d 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/Settings.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/Settings.java
@@ -21,7 +21,13 @@
  * Settings describe characteristics of the sending peer, which are used by the receiving peer.
  * Settings are {@link com.squareup.okhttp.internal.spdy.SpdyConnection connection} scoped.
  */
-final class Settings {
+public final class Settings {
+  /**
+   * From the SPDY/3 and HTTP/2 specs, the default initial window size for all
+   * streams is 64 KiB. (Chrome 25 uses 10 MiB).
+   */
+  static final int DEFAULT_INITIAL_WINDOW_SIZE = 64 * 1024;
+
   /** Peer request to clear durable settings. */
   static final int FLAG_CLEAR_PREVIOUSLY_PERSISTED_SETTINGS = 0x1;
 
@@ -32,11 +38,11 @@
 
   /** spdy/3: Sender's estimate of max incoming kbps. */
   static final int UPLOAD_BANDWIDTH = 1;
-  /** http/2: Size in bytes of the table used to decode the sender's header blocks. */
+  /** HTTP/2: Size in bytes of the table used to decode the sender's header blocks. */
   static final int HEADER_TABLE_SIZE = 1;
   /** spdy/3: Sender's estimate of max outgoing kbps. */
   static final int DOWNLOAD_BANDWIDTH = 2;
-  /** http/2: An endpoint must not send a PUSH_PROMISE frame when this is 0. */
+  /** HTTP/2: The peer must not send a PUSH_PROMISE frame when this is 0. */
   static final int ENABLE_PUSH = 2;
   /** spdy/3: Sender's estimate of millis between sending a request and receiving a response. */
   static final int ROUND_TRIP_TIME = 3;
@@ -44,8 +50,12 @@
   static final int MAX_CONCURRENT_STREAMS = 4;
   /** spdy/3: Current CWND in Packets. */
   static final int CURRENT_CWND = 5;
+  /** HTTP/2: Size in bytes of the largest frame payload the sender will accept. */
+  static final int MAX_FRAME_SIZE = 5;
   /** spdy/3: Retransmission rate. Percentage */
   static final int DOWNLOAD_RETRANS_RATE = 6;
+  /** HTTP/2: Advisory only. Size in bytes of the largest header list the sender will accept. */
+  static final int MAX_HEADER_LIST_SIZE = 6;
   /** Window size in bytes. */
   static final int INITIAL_WINDOW_SIZE = 7;
   /** spdy/3: Window size in bytes. */
@@ -128,7 +138,7 @@ int getUploadBandwidth(int defaultValue) {
     return (bit & set) != 0 ? values[UPLOAD_BANDWIDTH] : defaultValue;
   }
 
-  /** http/2 only. Returns -1 if unset. */
+  /** HTTP/2 only. Returns -1 if unset. */
   int getHeaderTableSize() {
     int bit = 1 << HEADER_TABLE_SIZE;
     return (bit & set) != 0 ? values[HEADER_TABLE_SIZE] : -1;
@@ -140,8 +150,8 @@ int getDownloadBandwidth(int defaultValue) {
     return (bit & set) != 0 ? values[DOWNLOAD_BANDWIDTH] : defaultValue;
   }
 
-  /** http/2 only. */
-  // TODO: honor this setting in http/2.
+  /** HTTP/2 only. */
+  // TODO: honor this setting in HTTP/2.
   boolean getEnablePush(boolean defaultValue) {
     int bit = 1 << ENABLE_PUSH;
     return ((bit & set) != 0 ? values[ENABLE_PUSH] : defaultValue ? 1 : 0) == 1;
@@ -153,7 +163,7 @@ int getRoundTripTime(int defaultValue) {
     return (bit & set) != 0 ? values[ROUND_TRIP_TIME] : defaultValue;
   }
 
-  // TODO: honor this setting in spdy/3 and http/2.
+  // TODO: honor this setting in spdy/3 and HTTP/2.
   int getMaxConcurrentStreams(int defaultValue) {
     int bit = 1 << MAX_CONCURRENT_STREAMS;
     return (bit & set) != 0 ? values[MAX_CONCURRENT_STREAMS] : defaultValue;
@@ -165,17 +175,27 @@ int getCurrentCwnd(int defaultValue) {
     return (bit & set) != 0 ? values[CURRENT_CWND] : defaultValue;
   }
 
+  /** HTTP/2 only. */
+  int getMaxFrameSize(int defaultValue) {
+    int bit = 1 << MAX_FRAME_SIZE;
+    return (bit & set) != 0 ? values[MAX_FRAME_SIZE] : defaultValue;
+  }
+
   /** spdy/3 only. */
   int getDownloadRetransRate(int defaultValue) {
     int bit = 1 << DOWNLOAD_RETRANS_RATE;
     return (bit & set) != 0 ? values[DOWNLOAD_RETRANS_RATE] : defaultValue;
   }
 
-  // TODO: honor this setting in http/2.
-  /** Returns -1 if unset. */
-  int getInitialWindowSize() {
+  /** HTTP/2 only. */
+  int getMaxHeaderListSize(int defaultValue) {
+    int bit = 1 << MAX_HEADER_LIST_SIZE;
+    return (bit & set) != 0 ? values[MAX_HEADER_LIST_SIZE] : defaultValue;
+  }
+
+  int getInitialWindowSize(int defaultValue) {
     int bit = 1 << INITIAL_WINDOW_SIZE;
-    return (bit & set) != 0 ? values[INITIAL_WINDOW_SIZE] : -1;
+    return (bit & set) != 0 ? values[INITIAL_WINDOW_SIZE] : defaultValue;
   }
 
   /** spdy/3 only. */
@@ -184,7 +204,7 @@ int getClientCertificateVectorSize(int defaultValue) {
     return (bit & set) != 0 ? values[CLIENT_CERTIFICATE_VECTOR_SIZE] : defaultValue;
   }
 
-  // TODO: honor this setting in spdy/3 and http/2.
+  // TODO: honor this setting in spdy/3 and HTTP/2.
   boolean isFlowControlDisabled() {
     int bit = 1 << FLOW_CONTROL_OPTIONS;
     int value = (bit & set) != 0 ? values[FLOW_CONTROL_OPTIONS] : 0;
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/Spdy3.java b/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/Spdy3.java
index a71bc6f5fc..c5cebe7c73 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/Spdy3.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/Spdy3.java
@@ -22,18 +22,18 @@
 import java.net.ProtocolException;
 import java.util.List;
 import java.util.zip.Deflater;
+import okio.Buffer;
 import okio.BufferedSink;
 import okio.BufferedSource;
 import okio.ByteString;
 import okio.DeflaterSink;
-import okio.OkBuffer;
 import okio.Okio;
 
 /**
  * Read and write spdy/3.1 frames.
  * http://www.chromium.org/spdy/spdy-protocol/spdy-protocol-draft3-1
  */
-final class Spdy3 implements Variant {
+public final class Spdy3 implements Variant {
 
   @Override public Protocol getProtocol() {
     return Protocol.SPDY_3;
@@ -103,10 +103,6 @@
     return new Writer(sink, client);
   }
 
-  @Override public int maxFrameSize() {
-    return 16383;
-  }
-
   /** Read spdy/3 frames. */
   static final class Reader implements FrameReader {
     private final BufferedSource source;
@@ -119,7 +115,7 @@
       this.client = client;
     }
 
-    @Override public void readConnectionHeader() {
+    @Override public void readConnectionPreface() {
     }
 
     /**
@@ -196,17 +192,15 @@
     private void readSynStream(Handler handler, int flags, int length) throws IOException {
       int w1 = source.readInt();
       int w2 = source.readInt();
-      int s3 = source.readShort();
       int streamId = w1 & 0x7fffffff;
       int associatedStreamId = w2 & 0x7fffffff;
-      int priority = (s3 & 0xe000) >>> 13;
-      // int slot = s3 & 0xff;
+      source.readShort(); // int priority = (s3 & 0xe000) >>> 13; int slot = s3 & 0xff;
       List<Header> headerBlock = headerBlockReader.readNameValueBlock(length - 10);
 
       boolean inFinished = (flags & FLAG_FIN) != 0;
       boolean outFinished = (flags & FLAG_UNIDIRECTIONAL) != 0;
-      handler.headers(outFinished, inFinished, streamId, associatedStreamId, priority,
-          headerBlock, HeadersMode.SPDY_SYN_STREAM);
+      handler.headers(outFinished, inFinished, streamId, associatedStreamId, headerBlock,
+          HeadersMode.SPDY_SYN_STREAM);
     }
 
     private void readSynReply(Handler handler, int flags, int length) throws IOException {
@@ -214,7 +208,7 @@ private void readSynReply(Handler handler, int flags, int length) throws IOExcep
       int streamId = w1 & 0x7fffffff;
       List<Header> headerBlock = headerBlockReader.readNameValueBlock(length - 4);
       boolean inFinished = (flags & FLAG_FIN) != 0;
-      handler.headers(false, inFinished, streamId, -1, -1, headerBlock, HeadersMode.SPDY_REPLY);
+      handler.headers(false, inFinished, streamId, -1, headerBlock, HeadersMode.SPDY_REPLY);
     }
 
     private void readRstStream(Handler handler, int flags, int length) throws IOException {
@@ -232,7 +226,7 @@ private void readHeaders(Handler handler, int flags, int length) throws IOExcept
       int w1 = source.readInt();
       int streamId = w1 & 0x7fffffff;
       List<Header> headerBlock = headerBlockReader.readNameValueBlock(length - 4);
-      handler.headers(false, false, streamId, -1, -1, headerBlock, HeadersMode.SPDY_HEADERS);
+      handler.headers(false, false, streamId, -1, headerBlock, HeadersMode.SPDY_HEADERS);
     }
 
     private void readWindowUpdate(Handler handler, int flags, int length) throws IOException {
@@ -292,7 +286,7 @@ private static IOException ioException(String message, Object... args) throws IO
   /** Write spdy/3 frames. */
   static final class Writer implements FrameWriter {
     private final BufferedSink sink;
-    private final OkBuffer headerBlockBuffer;
+    private final Buffer headerBlockBuffer;
     private final BufferedSink headerBlockOut;
     private final boolean client;
     private boolean closed;
@@ -303,11 +297,11 @@ private static IOException ioException(String message, Object... args) throws IO
 
       Deflater deflater = new Deflater();
       deflater.setDictionary(DICTIONARY);
-      headerBlockBuffer = new OkBuffer();
+      headerBlockBuffer = new Buffer();
       headerBlockOut = Okio.buffer(new DeflaterSink(headerBlockBuffer, deflater));
     }
 
-    @Override public void ackSettings() {
+    @Override public void ackSettings(Settings peerSettings) {
       // Do nothing: no ACK for SPDY/3 settings.
     }
 
@@ -317,8 +311,8 @@ public void pushPromise(int streamId, int promisedStreamId, List<Header> request
       // Do nothing: no push promise for SPDY/3.
     }
 
-    @Override public synchronized void connectionHeader() {
-      // Do nothing: no connection header for SPDY/3.
+    @Override public synchronized void connectionPreface() {
+      // Do nothing: no connection preface for SPDY/3.
     }
 
     @Override public synchronized void flush() throws IOException {
@@ -327,7 +321,7 @@ public void pushPromise(int streamId, int promisedStreamId, List<Header> request
     }
 
     @Override public synchronized void synStream(boolean outFinished, boolean inFinished,
-        int streamId, int associatedStreamId, int priority, int slot, List<Header> headerBlock)
+        int streamId, int associatedStreamId, List<Header> headerBlock)
         throws IOException {
       if (closed) throw new IOException("closed");
       writeNameValueBlockToBuffer(headerBlock);
@@ -340,8 +334,8 @@ public void pushPromise(int streamId, int promisedStreamId, List<Header> request
       sink.writeInt((flags & 0xff) << 24 | length & 0xffffff);
       sink.writeInt(streamId & 0x7fffffff);
       sink.writeInt(associatedStreamId & 0x7fffffff);
-      sink.writeShort((priority & 0x7) << 13 | (unused & 0x1f) << 8 | (slot & 0xff));
-      sink.write(headerBlockBuffer, headerBlockBuffer.size());
+      sink.writeShort((unused & 0x7) << 13 | (unused & 0x1f) << 8 | (unused & 0xff));
+      sink.writeAll(headerBlockBuffer);
       sink.flush();
     }
 
@@ -356,7 +350,7 @@ public void pushPromise(int streamId, int promisedStreamId, List<Header> request
       sink.writeInt(0x80000000 | (VERSION & 0x7fff) << 16 | type & 0xffff);
       sink.writeInt((flags & 0xff) << 24 | length & 0xffffff);
       sink.writeInt(streamId & 0x7fffffff);
-      sink.write(headerBlockBuffer, headerBlockBuffer.size());
+      sink.writeAll(headerBlockBuffer);
       sink.flush();
     }
 
@@ -371,7 +365,7 @@ public void pushPromise(int streamId, int promisedStreamId, List<Header> request
       sink.writeInt(0x80000000 | (VERSION & 0x7fff) << 16 | type & 0xffff);
       sink.writeInt((flags & 0xff) << 24 | length & 0xffffff);
       sink.writeInt(streamId & 0x7fffffff);
-      sink.write(headerBlockBuffer, headerBlockBuffer.size());
+      sink.writeAll(headerBlockBuffer);
     }
 
     @Override public synchronized void rstStream(int streamId, ErrorCode errorCode)
@@ -388,18 +382,17 @@ public void pushPromise(int streamId, int promisedStreamId, List<Header> request
       sink.flush();
     }
 
-    @Override public synchronized void data(boolean outFinished, int streamId, OkBuffer source)
-        throws IOException {
-      data(outFinished, streamId, source, (int) source.size());
+    @Override public int maxDataLength() {
+      return 16383;
     }
 
-    @Override public synchronized void data(boolean outFinished, int streamId, OkBuffer source,
+    @Override public synchronized void data(boolean outFinished, int streamId, Buffer source,
         int byteCount) throws IOException {
       int flags = (outFinished ? FLAG_FIN : 0);
       sendDataFrame(streamId, flags, source, byteCount);
     }
 
-    void sendDataFrame(int streamId, int flags, OkBuffer buffer, int byteCount)
+    void sendDataFrame(int streamId, int flags, Buffer buffer, int byteCount)
         throws IOException {
       if (closed) throw new IOException("closed");
       if (byteCount > 0xffffffL) {
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/SpdyConnection.java b/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/SpdyConnection.java
index fab8698a26..31719ff077 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/SpdyConnection.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/SpdyConnection.java
@@ -21,6 +21,7 @@
 import java.io.Closeable;
 import java.io.IOException;
 import java.io.InterruptedIOException;
+import java.net.InetSocketAddress;
 import java.net.Socket;
 import java.util.HashMap;
 import java.util.Iterator;
@@ -29,15 +30,17 @@
 import java.util.Map;
 import java.util.Set;
 import java.util.concurrent.ExecutorService;
+import java.util.concurrent.LinkedBlockingQueue;
 import java.util.concurrent.SynchronousQueue;
 import java.util.concurrent.ThreadPoolExecutor;
 import java.util.concurrent.TimeUnit;
-import okio.BufferedSink;
+import okio.Buffer;
 import okio.BufferedSource;
 import okio.ByteString;
-import okio.OkBuffer;
 import okio.Okio;
 
+import static com.squareup.okhttp.internal.spdy.Settings.DEFAULT_INITIAL_WINDOW_SIZE;
+
 /**
  * A socket connection to a remote peer. A connection hosts streams which can
  * send and receive data.
@@ -76,21 +79,22 @@
    * run on the callback executor.
    */
   private final IncomingStreamHandler handler;
-  private final Map<Integer, SpdyStream> streams = new HashMap<Integer, SpdyStream>();
+  private final Map<Integer, SpdyStream> streams = new HashMap<>();
   private final String hostName;
   private int lastGoodStreamId;
   private int nextStreamId;
   private boolean shutdown;
   private long idleStartTimeNs = System.nanoTime();
 
+  /** Ensures push promise callbacks events are sent in order per stream. */
+  private final ExecutorService pushExecutor;
+
   /** Lazily-created map of in-flight pings awaiting a response. Guarded by this. */
   private Map<Integer, Ping> pings;
   /** User code to run in response to push promise events. */
   private final PushObserver pushObserver;
   private int nextPingId;
 
-  static final int INITIAL_WINDOW_SIZE = 65535;
-
   /**
    * The total number of bytes consumed by the application, but not yet
    * acknowledged by sending a {@code WINDOW_UPDATE} frame on this connection.
@@ -107,30 +111,33 @@
 
   /** Settings we communicate to the peer. */
   // TODO: Do we want to dynamically adjust settings, or KISS and only set once?
-  final Settings okHttpSettings = new Settings()
-      .set(Settings.INITIAL_WINDOW_SIZE, 0, INITIAL_WINDOW_SIZE);
-      // TODO: implement stream limit
+  final Settings okHttpSettings = new Settings();
       // okHttpSettings.set(Settings.MAX_CONCURRENT_STREAMS, 0, max);
+  private static final int OKHTTP_CLIENT_WINDOW_SIZE = 16 * 1024 * 1024;
 
   /** Settings we receive from the peer. */
   // TODO: MWS will need to guard on this setting before attempting to push.
-  final Settings peerSettings = new Settings()
-      .set(Settings.INITIAL_WINDOW_SIZE, 0, INITIAL_WINDOW_SIZE);
+  final Settings peerSettings = new Settings();
 
   private boolean receivedInitialPeerSettings = false;
-  final FrameReader frameReader;
+  final Variant variant;
+  final Socket socket;
   final FrameWriter frameWriter;
-  final long maxFrameSize;
 
   // Visible for testing
   final Reader readerRunnable;
 
-  private SpdyConnection(Builder builder) {
+  private SpdyConnection(Builder builder) throws IOException {
     protocol = builder.protocol;
     pushObserver = builder.pushObserver;
     client = builder.client;
     handler = builder.handler;
+    // http://tools.ietf.org/html/draft-ietf-httpbis-http2-14#section-5.1.1
     nextStreamId = builder.client ? 1 : 2;
+    if (builder.client && protocol == Protocol.HTTP_2) {
+      nextStreamId += 2; // In HTTP/2, 1 on client is reserved for Upgrade.
+    }
+
     nextPingId = builder.client ? 1 : 2;
 
     // Flow control was designed more for servers, or proxies than edge clients.
@@ -138,23 +145,30 @@ private SpdyConnection(Builder builder) {
     // thrashing window updates every 64KiB, yet small enough to avoid blowing
     // up the heap.
     if (builder.client) {
-      okHttpSettings.set(Settings.INITIAL_WINDOW_SIZE, 0, 16 * 1024 * 1024);
+      okHttpSettings.set(Settings.INITIAL_WINDOW_SIZE, 0, OKHTTP_CLIENT_WINDOW_SIZE);
     }
 
     hostName = builder.hostName;
 
-    Variant variant;
     if (protocol == Protocol.HTTP_2) {
-      variant = new Http20Draft09();
+      variant = new Http20Draft14();
+      // Like newSingleThreadExecutor, except lazy creates the thread.
+      pushExecutor = new ThreadPoolExecutor(0, 1,
+          0L, TimeUnit.MILLISECONDS,
+          new LinkedBlockingQueue<Runnable>(),
+          Util.threadFactory(String.format("OkHttp %s Push Observer", hostName), true));
+      // 1 less than SPDY http://tools.ietf.org/html/draft-ietf-httpbis-http2-14#section-6.9.2
+      peerSettings.set(Settings.INITIAL_WINDOW_SIZE, 0, 65535);
+      peerSettings.set(Settings.MAX_FRAME_SIZE, 0, Http20Draft14.INITIAL_MAX_FRAME_SIZE);
     } else if (protocol == Protocol.SPDY_3) {
       variant = new Spdy3();
+      pushExecutor = null;
     } else {
       throw new AssertionError(protocol);
     }
-    bytesLeftInWriteWindow = peerSettings.getInitialWindowSize();
-    frameReader = variant.newReader(builder.source, client);
-    frameWriter = variant.newWriter(builder.sink, client);
-    maxFrameSize = variant.maxFrameSize();
+    bytesLeftInWriteWindow = peerSettings.getInitialWindowSize(DEFAULT_INITIAL_WINDOW_SIZE);
+    socket = builder.socket;
+    frameWriter = variant.newWriter(Okio.buffer(Okio.sink(builder.socket)), client);
 
     readerRunnable = new Reader();
     new Thread(readerRunnable).start(); // Not a daemon thread.
@@ -234,8 +248,6 @@ private SpdyStream newStream(int associatedStreamId, List<Header> requestHeaders
       boolean in) throws IOException {
     boolean outFinished = !out;
     boolean inFinished = !in;
-    int priority = -1; // TODO: permit the caller to specify a priority?
-    int slot = 0; // TODO: permit the caller to specify a slot?
     SpdyStream stream;
     int streamId;
 
@@ -246,14 +258,14 @@ private SpdyStream newStream(int associatedStreamId, List<Header> requestHeaders
         }
         streamId = nextStreamId;
         nextStreamId += 2;
-        stream = new SpdyStream(streamId, this, outFinished, inFinished, priority, requestHeaders);
+        stream = new SpdyStream(streamId, this, outFinished, inFinished, requestHeaders);
         if (stream.isOpen()) {
           streams.put(streamId, stream);
           setIdle(false);
         }
       }
       if (associatedStreamId == 0) {
-        frameWriter.synStream(outFinished, inFinished, streamId, associatedStreamId, priority, slot,
+        frameWriter.synStream(outFinished, inFinished, streamId, associatedStreamId,
             requestHeaders);
       } else if (client) {
         throw new IllegalArgumentException("client streams shouldn't have associated stream IDs");
@@ -289,7 +301,7 @@ void writeSynReply(int streamId, boolean outFinished, List<Header> alternating)
    * will not block.  The only use case for zero {@code byteCount} is closing
    * a flushed output stream.
    */
-  public void writeData(int streamId, boolean outFinished, OkBuffer buffer, long byteCount)
+  public void writeData(int streamId, boolean outFinished, Buffer buffer, long byteCount)
       throws IOException {
     if (byteCount == 0) { // Empty data frames are not flow-controlled.
       frameWriter.data(outFinished, streamId, buffer, 0);
@@ -307,7 +319,8 @@ public void writeData(int streamId, boolean outFinished, OkBuffer buffer, long b
           throw new InterruptedIOException();
         }
 
-        toWrite = (int) Math.min(Math.min(byteCount, bytesLeftInWriteWindow), maxFrameSize);
+        toWrite = (int) Math.min(byteCount, bytesLeftInWriteWindow);
+        toWrite = Math.min(toWrite, frameWriter.maxDataLength());
         bytesLeftInWriteWindow -= toWrite;
       }
 
@@ -364,7 +377,7 @@ public Ping ping() throws IOException {
       }
       pingId = nextPingId;
       nextPingId += 2;
-      if (pings == null) pings = new HashMap<Integer, Ping>();
+      if (pings == null) pings = new HashMap<>();
       pings.put(pingId, ping);
     }
     writePing(false, pingId, 0x4f4b6f6b /* ASCII "OKok" */, ping);
@@ -469,15 +482,18 @@ private void close(ErrorCode connectionCode, ErrorCode streamCode) throws IOExce
       }
     }
 
+    // Close the writer to release its resources (such as deflaters).
     try {
-      frameReader.close();
+      frameWriter.close();
     } catch (IOException e) {
-      thrown = e;
+      if (thrown == null) thrown = e;
     }
+
+    // Close the socket to break out the reader thread, which will clean up after itself.
     try {
-      frameWriter.close();
+      socket.close();
     } catch (IOException e) {
-      if (thrown == null) thrown = e;
+      thrown = e;
     }
 
     if (thrown != null) throw thrown;
@@ -487,34 +503,35 @@ private void close(ErrorCode connectionCode, ErrorCode streamCode) throws IOExce
    * Sends a connection header if the current variant requires it. This should
    * be called after {@link Builder#build} for all new connections.
    */
-  public void sendConnectionHeader() throws IOException {
-    frameWriter.connectionHeader();
+  public void sendConnectionPreface() throws IOException {
+    frameWriter.connectionPreface();
     frameWriter.settings(okHttpSettings);
+    int windowSize = okHttpSettings.getInitialWindowSize(Settings.DEFAULT_INITIAL_WINDOW_SIZE);
+    if (windowSize != Settings.DEFAULT_INITIAL_WINDOW_SIZE) {
+      frameWriter.windowUpdate(0, windowSize - Settings.DEFAULT_INITIAL_WINDOW_SIZE);
+    }
   }
 
   public static class Builder {
     private String hostName;
-    private BufferedSource source;
-    private BufferedSink sink;
+    private Socket socket;
     private IncomingStreamHandler handler = IncomingStreamHandler.REFUSE_INCOMING_STREAMS;
     private Protocol protocol = Protocol.SPDY_3;
     private PushObserver pushObserver = PushObserver.CANCEL;
     private boolean client;
 
     public Builder(boolean client, Socket socket) throws IOException {
-      this("", client, Okio.buffer(Okio.source(socket.getInputStream())),
-          Okio.buffer(Okio.sink(socket.getOutputStream())));
+      this(((InetSocketAddress) socket.getRemoteSocketAddress()).getHostName(), client, socket);
     }
 
     /**
      * @param client true if this peer initiated the connection; false if this
      *     peer accepted the connection.
      */
-    public Builder(String hostName, boolean client, BufferedSource source, BufferedSink sink) {
+    public Builder(String hostName, boolean client, Socket socket) throws IOException {
       this.hostName = hostName;
       this.client = client;
-      this.source = source;
-      this.sink = sink;
+      this.socket = socket;
     }
 
     public Builder handler(IncomingStreamHandler handler) {
@@ -532,7 +549,7 @@ public Builder pushObserver(PushObserver pushObserver) {
       return this;
     }
 
-    public SpdyConnection build() {
+    public SpdyConnection build() throws IOException {
       return new SpdyConnection(this);
     }
   }
@@ -542,6 +559,8 @@ public SpdyConnection build() {
    * write a frame, create an async task to do so.
    */
   class Reader extends NamedRunnable implements FrameReader.Handler {
+    FrameReader frameReader;
+
     private Reader() {
       super("OkHttp %s", hostName);
     }
@@ -550,8 +569,9 @@ private Reader() {
       ErrorCode connectionErrorCode = ErrorCode.INTERNAL_ERROR;
       ErrorCode streamErrorCode = ErrorCode.INTERNAL_ERROR;
       try {
+        frameReader = variant.newReader(Okio.buffer(Okio.source(socket)), client);
         if (!client) {
-          frameReader.readConnectionHeader();
+          frameReader.readConnectionPreface();
         }
         while (frameReader.nextFrame(this)) {
         }
@@ -565,6 +585,7 @@ private Reader() {
           close(connectionErrorCode, streamErrorCode);
         } catch (IOException ignored) {
         }
+        Util.closeQuietly(frameReader);
       }
     }
 
@@ -587,7 +608,7 @@ private Reader() {
     }
 
     @Override public void headers(boolean outFinished, boolean inFinished, int streamId,
-        int associatedStreamId, int priority, List<Header> headerBlock, HeadersMode headersMode) {
+        int associatedStreamId, List<Header> headerBlock, HeadersMode headersMode) {
       if (pushedStream(streamId)) {
         pushHeadersLater(streamId, headerBlock, inFinished);
         return;
@@ -614,7 +635,7 @@ private Reader() {
 
           // Create a stream.
           final SpdyStream newStream = new SpdyStream(streamId, SpdyConnection.this, outFinished,
-              inFinished, priority, headerBlock);
+              inFinished, headerBlock);
           lastGoodStreamId = streamId;
           streams.put(streamId, newStream);
           executor.submit(new NamedRunnable("OkHttp %s stream %d", hostName, streamId) {
@@ -657,16 +678,13 @@ private Reader() {
       long delta = 0;
       SpdyStream[] streamsToNotify = null;
       synchronized (SpdyConnection.this) {
-        int priorWriteWindowSize = peerSettings.getInitialWindowSize();
-        if (clearPrevious) {
-          peerSettings.clear();
-        } else {
-          peerSettings.merge(newSettings);
-        }
+        int priorWriteWindowSize = peerSettings.getInitialWindowSize(DEFAULT_INITIAL_WINDOW_SIZE);
+        if (clearPrevious) peerSettings.clear();
+        peerSettings.merge(newSettings);
         if (getProtocol() == Protocol.HTTP_2) {
-          ackSettingsLater();
+          ackSettingsLater(newSettings);
         }
-        int peerInitialWindowSize = peerSettings.getInitialWindowSize();
+        int peerInitialWindowSize = peerSettings.getInitialWindowSize(DEFAULT_INITIAL_WINDOW_SIZE);
         if (peerInitialWindowSize != -1 && peerInitialWindowSize != priorWriteWindowSize) {
           delta = peerInitialWindowSize - priorWriteWindowSize;
           if (!receivedInitialPeerSettings) {
@@ -687,11 +705,11 @@ private Reader() {
       }
     }
 
-    private void ackSettingsLater() {
+    private void ackSettingsLater(final Settings peerSettings) {
       executor.submit(new NamedRunnable("OkHttp %s ACK Settings", hostName) {
         @Override public void execute() {
           try {
-            frameWriter.ackSettings();
+            frameWriter.ackSettings(peerSettings);
           } catch (IOException ignored) {
           }
         }
@@ -749,7 +767,8 @@ private void ackSettingsLater() {
       }
     }
 
-    @Override public void priority(int streamId, int priority) {
+    @Override public void priority(int streamId, int streamDependency, int weight,
+        boolean exclusive) {
       // TODO: honor priority.
     }
 
@@ -757,6 +776,11 @@ private void ackSettingsLater() {
     public void pushPromise(int streamId, int promisedStreamId, List<Header> requestHeaders) {
       pushRequestLater(promisedStreamId, requestHeaders);
     }
+
+    @Override public void alternateService(int streamId, String origin, ByteString protocol,
+        String host, int port, long maxAge) {
+      // TODO: register alternate service.
+    }
   }
 
   /** Even, positive numbered streams are pushed streams in HTTP/2. */
@@ -765,7 +789,7 @@ private boolean pushedStream(int streamId) {
   }
 
   // Guarded by this.
-  private final Set<Integer> currentPushRequests = new LinkedHashSet<Integer>();
+  private final Set<Integer> currentPushRequests = new LinkedHashSet<>();
 
   private void pushRequestLater(final int streamId, final List<Header> requestHeaders) {
     synchronized (this) {
@@ -775,7 +799,7 @@ private void pushRequestLater(final int streamId, final List<Header> requestHead
       }
       currentPushRequests.add(streamId);
     }
-    executor.submit(new NamedRunnable("OkHttp %s Push Request[%s]", hostName, streamId) {
+    pushExecutor.submit(new NamedRunnable("OkHttp %s Push Request[%s]", hostName, streamId) {
       @Override public void execute() {
         boolean cancel = pushObserver.onRequest(streamId, requestHeaders);
         try {
@@ -793,7 +817,7 @@ private void pushRequestLater(final int streamId, final List<Header> requestHead
 
   private void pushHeadersLater(final int streamId, final List<Header> requestHeaders,
       final boolean inFinished) {
-    executor.submit(new NamedRunnable("OkHttp %s Push Headers[%s]", hostName, streamId) {
+    pushExecutor.submit(new NamedRunnable("OkHttp %s Push Headers[%s]", hostName, streamId) {
       @Override public void execute() {
         boolean cancel = pushObserver.onHeaders(streamId, requestHeaders, inFinished);
         try {
@@ -815,11 +839,11 @@ private void pushHeadersLater(final int streamId, final List<Header> requestHead
    */
   private void pushDataLater(final int streamId, final BufferedSource source, final int byteCount,
       final boolean inFinished) throws IOException {
-    final OkBuffer buffer = new OkBuffer();
+    final Buffer buffer = new Buffer();
     source.require(byteCount); // Eagerly read the frame before firing client thread.
     source.read(buffer, byteCount);
     if (buffer.size() != byteCount) throw new IOException(buffer.size() + " != " + byteCount);
-    executor.submit(new NamedRunnable("OkHttp %s Push Data[%s]", hostName, streamId) {
+    pushExecutor.submit(new NamedRunnable("OkHttp %s Push Data[%s]", hostName, streamId) {
       @Override public void execute() {
         try {
           boolean cancel = pushObserver.onData(streamId, buffer, byteCount, inFinished);
@@ -836,7 +860,7 @@ private void pushDataLater(final int streamId, final BufferedSource source, fina
   }
 
   private void pushResetLater(final int streamId, final ErrorCode errorCode) {
-    executor.submit(new NamedRunnable("OkHttp %s Push Reset[%s]", hostName, streamId) {
+    pushExecutor.submit(new NamedRunnable("OkHttp %s Push Reset[%s]", hostName, streamId) {
       @Override public void execute() {
         pushObserver.onReset(streamId, errorCode);
         synchronized (SpdyConnection.this) {
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/SpdyStream.java b/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/SpdyStream.java
index 4fea5e8d3e..331536d376 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/SpdyStream.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/SpdyStream.java
@@ -19,14 +19,16 @@
 import java.io.EOFException;
 import java.io.IOException;
 import java.io.InterruptedIOException;
-import java.net.SocketTimeoutException;
 import java.util.ArrayList;
 import java.util.List;
+import okio.AsyncTimeout;
+import okio.Buffer;
 import okio.BufferedSource;
-import okio.Deadline;
-import okio.OkBuffer;
 import okio.Sink;
 import okio.Source;
+import okio.Timeout;
+
+import static com.squareup.okhttp.internal.spdy.Settings.DEFAULT_INITIAL_WINDOW_SIZE;
 
 /** A logical bidirectional stream. */
 public final class SpdyStream {
@@ -51,7 +53,6 @@
 
   private final int id;
   private final SpdyConnection connection;
-  private final int priority;
   private long readTimeoutMillis = 0;
 
   /** Headers sent by the stream initiator. Immutable and non null. */
@@ -62,6 +63,8 @@
 
   private final SpdyDataSource source;
   final SpdyDataSink sink;
+  private final SpdyTimeout readTimeout = new SpdyTimeout();
+  private final SpdyTimeout writeTimeout = new SpdyTimeout();
 
   /**
    * The reason why this stream was abnormally closed. If there are multiple
@@ -71,17 +74,18 @@
   private ErrorCode errorCode = null;
 
   SpdyStream(int id, SpdyConnection connection, boolean outFinished, boolean inFinished,
-      int priority, List<Header> requestHeaders) {
+      List<Header> requestHeaders) {
     if (connection == null) throw new NullPointerException("connection == null");
     if (requestHeaders == null) throw new NullPointerException("requestHeaders == null");
     this.id = id;
     this.connection = connection;
-    this.bytesLeftInWriteWindow = connection.peerSettings.getInitialWindowSize();
-    this.source = new SpdyDataSource(connection.okHttpSettings.getInitialWindowSize());
+    this.bytesLeftInWriteWindow =
+        connection.peerSettings.getInitialWindowSize(DEFAULT_INITIAL_WINDOW_SIZE);
+    this.source = new SpdyDataSource(
+        connection.okHttpSettings.getInitialWindowSize(DEFAULT_INITIAL_WINDOW_SIZE));
     this.sink = new SpdyDataSink();
     this.source.finished = inFinished;
     this.sink.finished = outFinished;
-    this.priority = priority;
     this.requestHeaders = requestHeaders;
   }
 
@@ -130,33 +134,16 @@ public SpdyConnection getConnection() {
    * have not been received yet.
    */
   public synchronized List<Header> getResponseHeaders() throws IOException {
-    long remaining = 0;
-    long start = 0;
-    if (readTimeoutMillis != 0) {
-      start = (System.nanoTime() / 1000000);
-      remaining = readTimeoutMillis;
-    }
+    readTimeout.enter();
     try {
       while (responseHeaders == null && errorCode == null) {
-        if (readTimeoutMillis == 0) { // No timeout configured.
-          wait();
-        } else if (remaining > 0) {
-          wait(remaining);
-          remaining = start + readTimeoutMillis - (System.nanoTime() / 1000000);
-        } else {
-          throw new SocketTimeoutException("Read response header timeout. readTimeoutMillis: "
-                            + readTimeoutMillis);
-        }
+        waitForIo();
       }
-      if (responseHeaders != null) {
-        return responseHeaders;
-      }
-      throw new IOException("stream was reset: " + errorCode);
-    } catch (InterruptedException e) {
-      InterruptedIOException rethrow = new InterruptedIOException();
-      rethrow.initCause(e);
-      throw rethrow;
+    } finally {
+      readTimeout.exitAndThrowIfTimedOut();
     }
+    if (responseHeaders != null) return responseHeaders;
+    throw new IOException("stream was reset: " + errorCode);
   }
 
   /**
@@ -196,16 +183,12 @@ public void reply(List<Header> responseHeaders, boolean out) throws IOException
     }
   }
 
-  /**
-   * Sets the maximum time to wait on input stream reads before failing with a
-   * {@code SocketTimeoutException}, or {@code 0} to wait indefinitely.
-   */
-  public void setReadTimeout(long readTimeoutMillis) {
-    this.readTimeoutMillis = readTimeoutMillis;
+  public Timeout readTimeout() {
+    return readTimeout;
   }
 
-  public long getReadTimeoutMillis() {
-    return readTimeoutMillis;
+  public Timeout writeTimeout() {
+    return writeTimeout;
   }
 
   /** Returns a source that reads data from the peer. */
@@ -284,7 +267,7 @@ void receiveHeaders(List<Header> headers, HeadersMode headersMode) {
         if (headersMode.failIfHeadersPresent()) {
           errorCode = ErrorCode.STREAM_IN_USE;
         } else {
-          List<Header> newHeaders = new ArrayList<Header>();
+          List<Header> newHeaders = new ArrayList<>();
           newHeaders.addAll(responseHeaders);
           newHeaders.addAll(headers);
           this.responseHeaders = newHeaders;
@@ -323,10 +306,6 @@ synchronized void receiveRstStream(ErrorCode errorCode) {
     }
   }
 
-  int getPriority() {
-    return priority;
-  }
-
   /**
    * A source that reads the incoming data frames of a stream. Although this
    * class uses synchronization to safely receive incoming data frames, it is
@@ -334,10 +313,10 @@ int getPriority() {
    */
   private final class SpdyDataSource implements Source {
     /** Buffer to receive data from the network into. Only accessed by the reader thread. */
-    private final OkBuffer receiveBuffer = new OkBuffer();
+    private final Buffer receiveBuffer = new Buffer();
 
     /** Buffer with readable data. Guarded by SpdyStream.this. */
-    private final OkBuffer readBuffer = new OkBuffer();
+    private final Buffer readBuffer = new Buffer();
 
     /** Maximum number of bytes to buffer before reporting a flow control error. */
     private final long maxByteCount;
@@ -355,7 +334,7 @@ private SpdyDataSource(long maxByteCount) {
       this.maxByteCount = maxByteCount;
     }
 
-    @Override public long read(OkBuffer sink, long byteCount)
+    @Override public long read(Buffer sink, long byteCount)
         throws IOException {
       if (byteCount < 0) throw new IllegalArgumentException("byteCount < 0: " + byteCount);
 
@@ -370,7 +349,8 @@ private SpdyDataSource(long maxByteCount) {
 
         // Flow control: notify the peer that we're ready for more data!
         unacknowledgedBytesRead += read;
-        if (unacknowledgedBytesRead >= connection.peerSettings.getInitialWindowSize() / 2) {
+        if (unacknowledgedBytesRead
+            >= connection.okHttpSettings.getInitialWindowSize(DEFAULT_INITIAL_WINDOW_SIZE) / 2) {
           connection.writeWindowUpdateLater(id, unacknowledgedBytesRead);
           unacknowledgedBytesRead = 0;
         }
@@ -380,7 +360,7 @@ private SpdyDataSource(long maxByteCount) {
       synchronized (connection) { // Multiple application threads may hit this section.
         connection.unacknowledgedBytesRead += read;
         if (connection.unacknowledgedBytesRead
-            >= connection.peerSettings.getInitialWindowSize() / 2) {
+            >= connection.okHttpSettings.getInitialWindowSize(DEFAULT_INITIAL_WINDOW_SIZE) / 2) {
           connection.writeWindowUpdateLater(0, connection.unacknowledgedBytesRead);
           connection.unacknowledgedBytesRead = 0;
         }
@@ -389,31 +369,15 @@ private SpdyDataSource(long maxByteCount) {
       return read;
     }
 
-    /**
-     * Returns once the input stream is either readable or finished. Throws
-     * a {@link SocketTimeoutException} if the read timeout elapses before
-     * that happens.
-     */
+    /** Returns once the source is either readable or finished. */
     private void waitUntilReadable() throws IOException {
-      long start = 0;
-      long remaining = 0;
-      if (readTimeoutMillis != 0) {
-        start = (System.nanoTime() / 1000000);
-        remaining = readTimeoutMillis;
-      }
+      readTimeout.enter();
       try {
         while (readBuffer.size() == 0 && !finished && !closed && errorCode == null) {
-          if (readTimeoutMillis == 0) {
-            SpdyStream.this.wait();
-          } else if (remaining > 0) {
-            SpdyStream.this.wait(remaining);
-            remaining = start + readTimeoutMillis - (System.nanoTime() / 1000000);
-          } else {
-            throw new SocketTimeoutException("Read timed out");
-          }
+          waitForIo();
         }
-      } catch (InterruptedException e) {
-        throw new InterruptedIOException();
+      } finally {
+        readTimeout.exitAndThrowIfTimedOut();
       }
     }
 
@@ -449,7 +413,7 @@ void receive(BufferedSource in, long byteCount) throws IOException {
         // Move the received data to the read buffer to the reader can read it.
         synchronized (SpdyStream.this) {
           boolean wasEmpty = readBuffer.size() == 0;
-          readBuffer.write(receiveBuffer, receiveBuffer.size());
+          readBuffer.writeAll(receiveBuffer);
           if (wasEmpty) {
             SpdyStream.this.notifyAll();
           }
@@ -457,9 +421,8 @@ void receive(BufferedSource in, long byteCount) throws IOException {
       }
     }
 
-    @Override public Source deadline(Deadline deadline) {
-      // TODO: honor deadlines.
-      return this;
+    @Override public Timeout timeout() {
+      return readTimeout;
     }
 
     @Override public void close() throws IOException {
@@ -513,17 +476,18 @@ private void cancelStreamIfNecessary() throws IOException {
      */
     private boolean finished;
 
-    @Override public void write(OkBuffer source, long byteCount) throws IOException {
+    @Override public void write(Buffer source, long byteCount) throws IOException {
       assert (!Thread.holdsLock(SpdyStream.this));
       while (byteCount > 0) {
         long toWrite;
         synchronized (SpdyStream.this) {
+          writeTimeout.enter();
           try {
-            while (bytesLeftInWriteWindow <= 0) {
-              SpdyStream.this.wait(); // Wait until we receive a WINDOW_UPDATE.
+            while (bytesLeftInWriteWindow <= 0 && !finished && !closed && errorCode == null) {
+              waitForIo(); // Wait until we receive a WINDOW_UPDATE.
             }
-          } catch (InterruptedException e) {
-            throw new InterruptedIOException();
+          } finally {
+            writeTimeout.exitAndThrowIfTimedOut();
           }
 
           checkOutNotClosed(); // Kick out if the stream was reset or closed while waiting.
@@ -544,9 +508,8 @@ private void cancelStreamIfNecessary() throws IOException {
       connection.flush();
     }
 
-    @Override public Sink deadline(Deadline deadline) {
-      // TODO: honor deadlines.
-      return this;
+    @Override public Timeout timeout() {
+      return writeTimeout;
     }
 
     @Override public void close() throws IOException {
@@ -583,4 +546,31 @@ private void checkOutNotClosed() throws IOException {
       throw new IOException("stream was reset: " + errorCode);
     }
   }
+
+  /**
+   * Like {@link #wait}, but throws an {@code InterruptedIOException} when
+   * interrupted instead of the more awkward {@link InterruptedException}.
+   */
+  private void waitForIo() throws InterruptedIOException {
+    try {
+      wait();
+    } catch (InterruptedException e) {
+      throw new InterruptedIOException();
+    }
+  }
+
+  /**
+   * The Okio timeout watchdog will call {@link #timedOut} if the timeout is
+   * reached. In that case we close the stream (asynchronously) which will
+   * notify the waiting thread.
+   */
+  class SpdyTimeout extends AsyncTimeout {
+    @Override protected void timedOut() {
+      closeLater(ErrorCode.CANCEL);
+    }
+
+    public void exitAndThrowIfTimedOut() throws InterruptedIOException {
+      if (exit()) throw new InterruptedIOException("timeout");
+    }
+  }
 }
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/Variant.java b/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/Variant.java
index f8b14acbd0..2dd6a5207e 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/Variant.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/Variant.java
@@ -20,7 +20,7 @@
 import okio.BufferedSource;
 
 /** A version and dialect of the framed socket protocol. */
-interface Variant {
+public interface Variant {
 
   /** The protocol as selected using NPN or ALPN. */
   Protocol getProtocol();
@@ -34,6 +34,4 @@
    * @param client true if this is the HTTP client's writer, writing frames to a server.
    */
   FrameWriter newWriter(BufferedSink sink, boolean client);
-
-  int maxFrameSize();
 }
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/tls/OkHostnameVerifier.java b/okhttp/src/main/java/com/squareup/okhttp/internal/tls/OkHostnameVerifier.java
index a08773f6f6..0438f6617b 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/tls/OkHostnameVerifier.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/tls/OkHostnameVerifier.java
@@ -115,7 +115,7 @@ private boolean verifyHostName(String hostName, X509Certificate certificate) {
   }
 
   private List<String> getSubjectAltNames(X509Certificate certificate, int type) {
-    List<String> result = new ArrayList<String>();
+    List<String> result = new ArrayList<>();
     try {
       Collection<?> subjectAltNames = certificate.getSubjectAlternativeNames();
       if (subjectAltNames == null) {
@@ -179,10 +179,7 @@ public boolean verifyHostName(String hostName, String cn) {
     int suffixLength = cn.length() - (asterisk + 1);
     int suffixStart = hostName.length() - suffixLength;
     if (hostName.indexOf('.', asterisk) < suffixStart) {
-      // TODO: remove workaround for *.clients.google.com http://b/5426333
-      if (!hostName.endsWith(".clients.google.com")) {
-        return false; // wildcard '*' can't match a '.'
-      }
+      return false; // wildcard '*' can't match a '.'
     }
 
     if (!hostName.regionMatches(suffixStart, cn, asterisk + 1, suffixLength)) {
diff --git a/okio/pom.xml b/okio/pom.xml
deleted file mode 100644
index f1a33b5d66..0000000000
--- a/okio/pom.xml
+++ /dev/null
@@ -1,29 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-
-<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
-  <modelVersion>4.0.0</modelVersion>
-
-  <parent>
-    <groupId>com.squareup.okhttp</groupId>
-    <artifactId>parent</artifactId>
-    <version>2.0.0-SNAPSHOT</version>
-  </parent>
-
-  <groupId>com.squareup.okio</groupId>
-  <artifactId>okio</artifactId>
-  <name>Okio</name>
-
-  <dependencies>
-    <dependency>
-      <groupId>junit</groupId>
-      <artifactId>junit</artifactId>
-      <scope>test</scope>
-    </dependency>
-    <dependency>
-      <groupId>org.codehaus.mojo</groupId>
-      <artifactId>animal-sniffer-annotations</artifactId>
-      <version>1.10</version>
-      <optional>true</optional>
-    </dependency>
-  </dependencies>
-</project>
diff --git a/okio/src/main/java/okio/Base64.java b/okio/src/main/java/okio/Base64.java
deleted file mode 100644
index 087b28747a..0000000000
--- a/okio/src/main/java/okio/Base64.java
+++ /dev/null
@@ -1,148 +0,0 @@
-/*
- *  Licensed to the Apache Software Foundation (ASF) under one or more
- *  contributor license agreements.  See the NOTICE file distributed with
- *  this work for additional information regarding copyright ownership.
- *  The ASF licenses this file to You under the Apache License, Version 2.0
- *  (the "License"); you may not use this file except in compliance with
- *  the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License.
- */
-
-/**
- * @author Alexander Y. Kleymenov
- */
-
-package okio;
-
-import java.io.UnsupportedEncodingException;
-
-final class Base64 {
-  private Base64() {
-  }
-
-  public static byte[] decode(String in) {
-    // Ignore trailing '=' padding and whitespace from the input.
-    int limit = in.length();
-    for (; limit > 0; limit--) {
-      char c = in.charAt(limit - 1);
-      if (c != '=' && c != '\n' && c != '\r' && c != ' ' && c != '\t') {
-        break;
-      }
-    }
-
-    // If the input includes whitespace, this output array will be longer than necessary.
-    byte[] out = new byte[(int) (limit * 6L / 8L)];
-    int outCount = 0;
-    int inCount = 0;
-
-    int word = 0;
-    for (int pos = 0; pos < limit; pos++) {
-      char c = in.charAt(pos);
-
-      int bits;
-      if (c >= 'A' && c <= 'Z') {
-        // char ASCII value
-        //  A    65    0
-        //  Z    90    25 (ASCII - 65)
-        bits = c - 65;
-      } else if (c >= 'a' && c <= 'z') {
-        // char ASCII value
-        //  a    97    26
-        //  z    122   51 (ASCII - 71)
-        bits = c - 71;
-      } else if (c >= '0' && c <= '9') {
-        // char ASCII value
-        //  0    48    52
-        //  9    57    61 (ASCII + 4)
-        bits = c + 4;
-      } else if (c == '+') {
-        bits = 62;
-      } else if (c == '/') {
-        bits = 63;
-      } else if (c == '\n' || c == '\r' || c == ' ' || c == '\t') {
-        continue;
-      } else {
-        return null;
-      }
-
-      // Append this char's 6 bits to the word.
-      word = (word << 6) | (byte) bits;
-
-      // For every 4 chars of input, we accumulate 24 bits of output. Emit 3 bytes.
-      inCount++;
-      if (inCount % 4 == 0) {
-        out[outCount++] = (byte) (word >> 16);
-        out[outCount++] = (byte) (word >> 8);
-        out[outCount++] = (byte) word;
-      }
-    }
-
-    int lastWordChars = inCount % 4;
-    if (lastWordChars == 1) {
-      // We read 1 char followed by "===". But 6 bits is a truncated byte! Fail.
-      return null;
-    } else if (lastWordChars == 2) {
-      // We read 2 chars followed by "==". Emit 1 byte with 8 of those 12 bits.
-      word = word << 12;
-      out[outCount++] = (byte) (word >> 16);
-    } else if (lastWordChars == 3) {
-      // We read 3 chars, followed by "=". Emit 2 bytes for 16 of those 18 bits.
-      word = word << 6;
-      out[outCount++] = (byte) (word >> 16);
-      out[outCount++] = (byte) (word >> 8);
-    }
-
-    // If we sized our out array perfectly, we're done.
-    if (outCount == out.length) return out;
-
-    // Copy the decoded bytes to a new, right-sized array.
-    byte[] prefix = new byte[outCount];
-    System.arraycopy(out, 0, prefix, 0, outCount);
-    return prefix;
-  }
-
-  private static final byte[] MAP = new byte[] {
-      'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S',
-      'T', 'U', 'V', 'W', 'X', 'Y', 'Z', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l',
-      'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z', '0', '1', '2', '3', '4',
-      '5', '6', '7', '8', '9', '+', '/'
-  };
-
-  public static String encode(byte[] in) {
-    int length = (in.length + 2) * 4 / 3;
-    byte[] out = new byte[length];
-    int index = 0, end = in.length - in.length % 3;
-    for (int i = 0; i < end; i += 3) {
-      out[index++] = MAP[(in[i] & 0xff) >> 2];
-      out[index++] = MAP[((in[i] & 0x03) << 4) | ((in[i + 1] & 0xff) >> 4)];
-      out[index++] = MAP[((in[i + 1] & 0x0f) << 2) | ((in[i + 2] & 0xff) >> 6)];
-      out[index++] = MAP[(in[i + 2] & 0x3f)];
-    }
-    switch (in.length % 3) {
-      case 1:
-        out[index++] = MAP[(in[end] & 0xff) >> 2];
-        out[index++] = MAP[(in[end] & 0x03) << 4];
-        out[index++] = '=';
-        out[index++] = '=';
-        break;
-      case 2:
-        out[index++] = MAP[(in[end] & 0xff) >> 2];
-        out[index++] = MAP[((in[end] & 0x03) << 4) | ((in[end + 1] & 0xff) >> 4)];
-        out[index++] = MAP[((in[end + 1] & 0x0f) << 2)];
-        out[index++] = '=';
-        break;
-    }
-    try {
-      return new String(out, 0, index, "US-ASCII");
-    } catch (UnsupportedEncodingException e) {
-      throw new AssertionError(e);
-    }
-  }
-}
diff --git a/okio/src/main/java/okio/BufferedSink.java b/okio/src/main/java/okio/BufferedSink.java
deleted file mode 100644
index 3066011a0e..0000000000
--- a/okio/src/main/java/okio/BufferedSink.java
+++ /dev/null
@@ -1,72 +0,0 @@
-/*
- * Copyright (C) 2014 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okio;
-
-import java.io.IOException;
-import java.io.OutputStream;
-
-/**
- * A sink that keeps a buffer internally so that callers can do small writes
- * without a performance penalty.
- */
-public interface BufferedSink extends Sink {
-  /** Returns this sink's internal buffer. */
-  OkBuffer buffer();
-
-  BufferedSink write(ByteString byteString) throws IOException;
-
-  /**
-   * Like {@link OutputStream#write}, this writes a complete byte array to this
-   * sink.
-   */
-  BufferedSink write(byte[] source) throws IOException;
-
-  /**
-   * Like {@link OutputStream#write}, this writes {@code byteCount} bytes
-   * of {@code source}, starting at {@code offset}.
-   */
-  BufferedSink write(byte[] source, int offset, int byteCount) throws IOException;
-
-  /** Encodes {@code string} in UTF-8 and writes it to this sink. */
-  BufferedSink writeUtf8(String string) throws IOException;
-
-  /** Writes a byte to this sink. */
-  BufferedSink writeByte(int b) throws IOException;
-
-  /** Writes a big-endian short to this sink using two bytes. */
-  BufferedSink writeShort(int s) throws IOException;
-
-  /** Writes a little-endian short to this sink using two bytes. */
-  BufferedSink writeShortLe(int s) throws IOException;
-
-  /** Writes a big-endian int to this sink using four bytes. */
-  BufferedSink writeInt(int i) throws IOException;
-
-  /** Writes a little-endian int to this sink using four bytes. */
-  BufferedSink writeIntLe(int i) throws IOException;
-
-  /** Writes a big-endian long to this sink using eight bytes. */
-  BufferedSink writeLong(long v) throws IOException;
-
-  /** Writes a little-endian long to this sink using eight bytes. */
-  BufferedSink writeLongLe(long v) throws IOException;
-
-  /** Writes complete segments to this sink. Like {@link #flush}, but weaker. */
-  BufferedSink emitCompleteSegments() throws IOException;
-
-  /** Returns an output stream that writes to this sink. */
-  OutputStream outputStream();
-}
diff --git a/okio/src/main/java/okio/BufferedSource.java b/okio/src/main/java/okio/BufferedSource.java
deleted file mode 100644
index 2b48823cec..0000000000
--- a/okio/src/main/java/okio/BufferedSource.java
+++ /dev/null
@@ -1,114 +0,0 @@
-/*
- * Copyright (C) 2014 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okio;
-
-import java.io.IOException;
-import java.io.InputStream;
-
-/**
- * A source that keeps a buffer internally so that callers can do small reads
- * without a performance penalty. It also allows clients to read ahead,
- * buffering as much as necessary before consuming input.
- */
-public interface BufferedSource extends Source {
-  /** Returns this source's internal buffer. */
-  OkBuffer buffer();
-
-  /**
-   * Returns true if there are no more bytes in this source. This will block
-   * until there are bytes to read or the source is definitely exhausted.
-   */
-  boolean exhausted() throws IOException;
-
-  /**
-   * Returns when the buffer contains at least {@code byteCount} bytes. Throws
-   * an {@link java.io.EOFException} if the source is exhausted before the
-   * required bytes can be read.
-   */
-  void require(long byteCount) throws IOException;
-
-  /** Removes a byte from this source and returns it. */
-  byte readByte() throws IOException;
-
-  /** Removes two bytes from this source and returns a big-endian short. */
-  short readShort() throws IOException;
-
-  /** Removes two bytes from this source and returns a little-endian short. */
-  short readShortLe() throws IOException;
-
-  /** Removes four bytes from this source and returns a big-endian int. */
-  int readInt() throws IOException;
-
-  /** Removes four bytes from this source and returns a little-endian int. */
-  int readIntLe() throws IOException;
-
-  /** Removes eight bytes from this source and returns a big-endian long. */
-  long readLong() throws IOException;
-
-  /** Removes eight bytes from this source and returns a little-endian long. */
-  long readLongLe() throws IOException;
-
-  /**
-   * Reads and discards {@code byteCount} bytes from this source. Throws an
-   * {@link java.io.EOFException} if the source is exhausted before the
-   * requested bytes can be skipped.
-   */
-  void skip(long byteCount) throws IOException;
-
-  /** Removes {@code byteCount} bytes from this and returns them as a byte string. */
-  ByteString readByteString(long byteCount) throws IOException;
-
-  /**
-   * Removes {@code byteCount} bytes from this, decodes them as UTF-8 and
-   * returns the string.
-   */
-  String readUtf8(long byteCount) throws IOException;
-
-  /**
-   * Removes and returns characters up to but not including the next line break.
-   * A line break is either {@code "\n"} or {@code "\r\n"}; these characters are
-   * not included in the result.
-   *
-   * <p><strong>On the end of the stream this method returns null,</strong> just
-   * like {@link java.io.BufferedReader}. If the source doesn't end with a line
-   * break then an implicit line break is assumed. Null is returned once the
-   * source is exhausted. Use this for human-generated data, where a trailing
-   * line break is optional.
-   */
-  String readUtf8Line() throws IOException;
-
-  /**
-   * Removes and returns characters up to but not including the next line break.
-   * A line break is either {@code "\n"} or {@code "\r\n"}; these characters are
-   * not included in the result.
-   *
-   * <p><strong>On the end of the stream this method throws.</strong> Every call
-   * must consume either '\r\n' or '\n'. If these characters are absent in the
-   * stream, an {@link java.io.EOFException} is thrown. Use this for
-   * machine-generated data where a missing line break implies truncated input.
-   */
-  String readUtf8LineStrict() throws IOException;
-
-  /**
-   * Returns the index of {@code b} in the buffer, refilling it if necessary
-   * until it is found. This reads an unbounded number of bytes into the buffer.
-   * Returns -1 if the stream is exhausted before the requested byte is found.
-   */
-  long indexOf(byte b) throws IOException;
-
-  /** Returns an input stream that reads from this source. */
-  InputStream inputStream();
-}
diff --git a/okio/src/main/java/okio/ByteString.java b/okio/src/main/java/okio/ByteString.java
deleted file mode 100644
index 6853adb09b..0000000000
--- a/okio/src/main/java/okio/ByteString.java
+++ /dev/null
@@ -1,211 +0,0 @@
-/*
- * Copyright 2014 Square Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okio;
-
-import java.io.EOFException;
-import java.io.IOException;
-import java.io.InputStream;
-import java.io.OutputStream;
-import java.security.MessageDigest;
-import java.security.NoSuchAlgorithmException;
-import java.util.Arrays;
-
-/**
- * An immutable sequence of bytes.
- *
- * <p><strong>Full disclosure:</strong> this class provides untrusted input and
- * output streams with raw access to the underlying byte array. A hostile
- * stream implementation could keep a reference to the mutable byte string,
- * violating the immutable guarantee of this class. For this reason a byte
- * string's immutability guarantee cannot be relied upon for security in applets
- * and other environments that run both trusted and untrusted code in the same
- * process.
- */
-public final class ByteString {
-  private static final char[] HEX_DIGITS =
-      { '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f' };
-
-  /** A singleton empty {@code ByteString}. */
-  public static final ByteString EMPTY = ByteString.of();
-
-  final byte[] data;
-  private transient int hashCode; // Lazily computed; 0 if unknown.
-  private transient String utf8; // Lazily computed.
-
-  ByteString(byte[] data) {
-    this.data = data; // Trusted internal constructor doesn't clone data.
-  }
-
-  /**
-   * Returns a new byte string containing a clone of the bytes of {@code data}.
-   */
-  public static ByteString of(byte... data) {
-    return new ByteString(data.clone());
-  }
-
-  /** Returns a new byte string containing the {@code UTF-8} bytes of {@code s}. */
-  public static ByteString encodeUtf8(String s) {
-    ByteString byteString = new ByteString(s.getBytes(Util.UTF_8));
-    byteString.utf8 = s;
-    return byteString;
-  }
-
-  /** Constructs a new {@code String} by decoding the bytes as {@code UTF-8}. */
-  public String utf8() {
-    String result = utf8;
-    // We don't care if we double-allocate in racy code.
-    return result != null ? result : (utf8 = new String(data, Util.UTF_8));
-  }
-
-  /**
-   * Returns this byte string encoded as <a
-   * href="http://www.ietf.org/rfc/rfc2045.txt">Base64</a>. In violation of the
-   * RFC, the returned string does not wrap lines at 76 columns.
-   */
-  public String base64() {
-    return Base64.encode(data);
-  }
-
-  /**
-   * Decodes the Base64-encoded bytes and returns their value as a byte string.
-   * Returns null if {@code base64} is not a Base64-encoded sequence of bytes.
-   */
-  public static ByteString decodeBase64(String base64) {
-    byte[] decoded = Base64.decode(base64);
-    return decoded != null ? new ByteString(decoded) : null;
-  }
-
-  /** Returns this byte string encoded in hexadecimal. */
-  public String hex() {
-    char[] result = new char[data.length * 2];
-    int c = 0;
-    for (byte b : data) {
-      result[c++] = HEX_DIGITS[(b >> 4) & 0xf];
-      result[c++] = HEX_DIGITS[b & 0xf];
-    }
-    return new String(result);
-  }
-
-  /** Decodes the hex-encoded bytes and returns their value a byte string. */
-  public static ByteString decodeHex(String hex) {
-    if (hex.length() % 2 != 0) throw new IllegalArgumentException("Unexpected hex string: " + hex);
-
-    byte[] result = new byte[hex.length() / 2];
-    for (int i = 0; i < result.length; i++) {
-      int d1 = decodeHexDigit(hex.charAt(i * 2)) << 4;
-      int d2 = decodeHexDigit(hex.charAt(i * 2 + 1));
-      result[i] = (byte) (d1 + d2);
-    }
-    return of(result);
-  }
-
-  private static int decodeHexDigit(char c) {
-    if (c >= '0' && c <= '9') return c - '0';
-    if (c >= 'a' && c <= 'f') return c - 'a' + 10;
-    if (c >= 'A' && c <= 'F') return c - 'A' + 10;
-    throw new IllegalArgumentException("Unexpected hex digit: " + c);
-  }
-
-  /**
-   * Reads {@code count} bytes from {@code in} and returns the result.
-   *
-   * @throws java.io.EOFException if {@code in} has fewer than {@code count}
-   *     bytes to read.
-   */
-  public static ByteString read(InputStream in, int byteCount) throws IOException {
-    byte[] result = new byte[byteCount];
-    for (int offset = 0, read; offset < byteCount; offset += read) {
-      read = in.read(result, offset, byteCount - offset);
-      if (read == -1) throw new EOFException();
-    }
-    return new ByteString(result);
-  }
-
-  /**
-   * Returns a byte string equal to this byte string, but with the bytes 'A'
-   * through 'Z' replaced with the corresponding byte in 'a' through 'z'.
-   * Returns this byte string if it contains no bytes in 'A' through 'Z'.
-   */
-  public ByteString toAsciiLowercase() {
-    // Search for an uppercase character. If we don't find one, return this.
-    for (int i = 0; i < data.length; i++) {
-      byte c = data[i];
-      if (c < 'A' || c > 'Z') continue;
-
-      // If we reach this point, this string is not not lowercase. Create and
-      // return a new byte string.
-      byte[] lowercase = data.clone();
-      lowercase[i++] = (byte) (c - ('A' - 'a'));
-      for (; i < lowercase.length; i++) {
-        c = lowercase[i];
-        if (c < 'A' || c > 'Z') continue;
-        lowercase[i] = (byte) (c - ('A' - 'a'));
-      }
-      return new ByteString(lowercase);
-    }
-    return this;
-  }
-
-  /** Returns the byte at {@code pos}. */
-  public byte getByte(int pos) {
-    return data[pos];
-  }
-
-  /**
-   * Returns the number of bytes in this ByteString.
-   */
-  public int size() {
-    return data.length;
-  }
-
-  /**
-   * Returns a byte array containing a copy of the bytes in this {@code ByteString}.
-   */
-  public byte[] toByteArray() {
-    return data.clone();
-  }
-
-  /** Writes the contents of this byte string to {@code out}. */
-  public void write(OutputStream out) throws IOException {
-    out.write(data);
-  }
-
-  @Override public boolean equals(Object o) {
-    return o == this || o instanceof ByteString && Arrays.equals(((ByteString) o).data, data);
-  }
-
-  @Override public int hashCode() {
-    int result = hashCode;
-    return result != 0 ? result : (hashCode = Arrays.hashCode(data));
-  }
-
-  @Override public String toString() {
-    if (data.length == 0) {
-      return "ByteString[size=0]";
-    }
-
-    if (data.length <= 16) {
-      return String.format("ByteString[size=%s data=%s]", data.length, hex());
-    }
-
-    try {
-      return String.format("ByteString[size=%s md5=%s]", data.length,
-          ByteString.of(MessageDigest.getInstance("MD5").digest(data)).hex());
-    } catch (NoSuchAlgorithmException e) {
-      throw new AssertionError();
-    }
-  }
-}
diff --git a/okio/src/main/java/okio/Deadline.java b/okio/src/main/java/okio/Deadline.java
deleted file mode 100644
index 15a7c6d49f..0000000000
--- a/okio/src/main/java/okio/Deadline.java
+++ /dev/null
@@ -1,54 +0,0 @@
-/*
- * Copyright (C) 2014 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okio;
-
-import java.io.IOException;
-import java.util.concurrent.TimeUnit;
-
-/**
- * The time that a requested operation is due. If the deadline is reached before
- * the operation has completed, the operation should be aborted.
- */
-public class Deadline {
-  public static final Deadline NONE = new Deadline() {
-    @Override public Deadline start(long timeout, TimeUnit unit) {
-      throw new UnsupportedOperationException();
-    }
-
-    @Override public boolean reached() {
-      return false;
-    }
-  };
-
-  private long deadlineNanos;
-
-  public Deadline() {
-  }
-
-  public Deadline start(long timeout, TimeUnit unit) {
-    deadlineNanos = System.nanoTime() + unit.toNanos(timeout);
-    return this;
-  }
-
-  public boolean reached() {
-    return System.nanoTime() - deadlineNanos >= 0; // Subtract to avoid overflow!
-  }
-
-  public void throwIfReached() throws IOException {
-    // TODO: a more catchable exception type?
-    if (reached()) throw new IOException("Deadline reached");
-  }
-}
diff --git a/okio/src/main/java/okio/DeflaterSink.java b/okio/src/main/java/okio/DeflaterSink.java
deleted file mode 100644
index e3a7cab2a6..0000000000
--- a/okio/src/main/java/okio/DeflaterSink.java
+++ /dev/null
@@ -1,111 +0,0 @@
-/*
- * Copyright (C) 2014 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okio;
-
-import java.io.IOException;
-import java.util.zip.Deflater;
-import org.codehaus.mojo.animal_sniffer.IgnoreJRERequirement;
-
-import static okio.Util.checkOffsetAndCount;
-
-/**
- * A sink that uses <a href="http://tools.ietf.org/html/rfc1951">DEFLATE</a> to
- * compress data written to another source.
- *
- * <h3>Sync flush</h3>
- * Aggressive flushing of this stream may result in reduced compression. Each
- * call to {@link #flush} immediately compresses all currently-buffered data;
- * this early compression may be less effective than compression performed
- * without flushing.
- *
- * <p>This is equivalent to using {@link Deflater} with the sync flush option.
- * This class does not offer any partial flush mechanism. For best performance,
- * only call {@link #flush} when application behavior requires it.
- */
-public final class DeflaterSink implements Sink {
-  private final BufferedSink sink;
-  private final Deflater deflater;
-
-  public DeflaterSink(Sink sink, Deflater deflater) {
-    this.sink = Okio.buffer(sink);
-    this.deflater = deflater;
-  }
-
-  @Override public void write(OkBuffer source, long byteCount)
-      throws IOException {
-    checkOffsetAndCount(source.size, 0, byteCount);
-    while (byteCount > 0) {
-      // Share bytes from the head segment of 'source' with the deflater.
-      Segment head = source.head;
-      int toDeflate = (int) Math.min(byteCount, head.limit - head.pos);
-      deflater.setInput(head.data, head.pos, toDeflate);
-
-      // Deflate those bytes into sink.
-      deflate(false);
-
-      // Mark those bytes as read.
-      source.size -= toDeflate;
-      head.pos += toDeflate;
-      if (head.pos == head.limit) {
-        source.head = head.pop();
-        SegmentPool.INSTANCE.recycle(head);
-      }
-
-      byteCount -= toDeflate;
-    }
-  }
-
-  @IgnoreJRERequirement
-  private void deflate(boolean syncFlush) throws IOException {
-    OkBuffer buffer = sink.buffer();
-    while (true) {
-      Segment s = buffer.writableSegment(1);
-
-      // The 4-parameter overload of deflate() doesn't exist in the RI until
-      // Java 1.7, and is public (although with @hide) on Android since 2.3.
-      // The @hide tag means that this code won't compile against the Android
-      // 2.3 SDK, but it will run fine there.
-      int deflated = syncFlush
-          ? deflater.deflate(s.data, s.limit, Segment.SIZE - s.limit, Deflater.SYNC_FLUSH)
-          : deflater.deflate(s.data, s.limit, Segment.SIZE - s.limit);
-
-      if (deflated == 0) return;
-      s.limit += deflated;
-      buffer.size += deflated;
-      sink.emitCompleteSegments();
-    }
-  }
-
-  @Override public void flush() throws IOException {
-    deflate(true);
-    sink.flush();
-  }
-
-  @Override public void close() throws IOException {
-    deflater.finish();
-    deflate(false);
-    sink.close();
-  }
-
-  @Override public Sink deadline(Deadline deadline) {
-    sink.deadline(deadline);
-    return this;
-  }
-
-  @Override public String toString() {
-    return "DeflaterSink(" + sink + ")";
-  }
-}
diff --git a/okio/src/main/java/okio/GzipSource.java b/okio/src/main/java/okio/GzipSource.java
deleted file mode 100644
index eae3a16459..0000000000
--- a/okio/src/main/java/okio/GzipSource.java
+++ /dev/null
@@ -1,200 +0,0 @@
-/*
- * Copyright (C) 2014 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okio;
-
-import java.io.EOFException;
-import java.io.IOException;
-import java.util.zip.CRC32;
-import java.util.zip.Inflater;
-
-public final class GzipSource implements Source {
-  private static final byte FHCRC = 1;
-  private static final byte FEXTRA = 2;
-  private static final byte FNAME = 3;
-  private static final byte FCOMMENT = 4;
-
-  private static final byte SECTION_HEADER = 0;
-  private static final byte SECTION_BODY = 1;
-  private static final byte SECTION_TRAILER = 2;
-  private static final byte SECTION_DONE = 3;
-
-  /** The current section. Always progresses forward. */
-  private int section = SECTION_HEADER;
-
-  /**
-   * Our source should yield a GZIP header (which we consume directly), followed
-   * by deflated bytes (which we consume via an InflaterSource), followed by a
-   * GZIP trailer (which we also consume directly).
-   */
-  private final BufferedSource source;
-
-  /** The inflater used to decompress the deflated body. */
-  private final Inflater inflater;
-
-  /**
-   * The inflater source takes care of moving data between compressed source and
-   * decompressed sink buffers.
-   */
-  private final InflaterSource inflaterSource;
-
-  /** Checksum used to check both the GZIP header and decompressed body. */
-  private final CRC32 crc = new CRC32();
-
-  public GzipSource(Source source) throws IOException {
-    this.inflater = new Inflater(true);
-    this.source = Okio.buffer(source);
-    this.inflaterSource = new InflaterSource(this.source, inflater);
-  }
-
-  @Override public long read(OkBuffer sink, long byteCount) throws IOException {
-    if (byteCount < 0) throw new IllegalArgumentException("byteCount < 0: " + byteCount);
-    if (byteCount == 0) return 0;
-
-    // If we haven't consumed the header, we must consume it before anything else.
-    if (section == SECTION_HEADER) {
-      consumeHeader();
-      section = SECTION_BODY;
-    }
-
-    // Attempt to read at least a byte of the body. If we do, we're done.
-    if (section == SECTION_BODY) {
-      long offset = sink.size;
-      long result = inflaterSource.read(sink, byteCount);
-      if (result != -1) {
-        updateCrc(sink, offset, result);
-        return result;
-      }
-      section = SECTION_TRAILER;
-    }
-
-    // The body is exhausted; time to read the trailer. We always consume the
-    // trailer before returning a -1 exhausted result; that way if you read to
-    // the end of a GzipSource you guarantee that the CRC has been checked.
-    if (section == SECTION_TRAILER) {
-      consumeTrailer();
-      section = SECTION_DONE;
-
-      // Gzip streams self-terminate: they return -1 before their underlying
-      // source returns -1. Here we attempt to force the underlying stream to
-      // return -1 which may trigger it to release its resources. If it doesn't
-      // return -1, then our Gzip data finished prematurely!
-      if (!source.exhausted()) {
-        throw new IOException("gzip finished without exhausting source");
-      }
-    }
-
-    return -1;
-  }
-
-  private void consumeHeader() throws IOException {
-    // Read the 10-byte header. We peek at the flags byte first so we know if we
-    // need to CRC the entire header. Then we read the magic ID1ID2 sequence.
-    // We can skip everything else in the first 10 bytes.
-    // +---+---+---+---+---+---+---+---+---+---+
-    // |ID1|ID2|CM |FLG|     MTIME     |XFL|OS | (more-->)
-    // +---+---+---+---+---+---+---+---+---+---+
-    source.require(10);
-    byte flags = source.buffer().getByte(3);
-    boolean fhcrc = ((flags >> FHCRC) & 1) == 1;
-    if (fhcrc) updateCrc(source.buffer(), 0, 10);
-
-    short id1id2 = source.readShort();
-    checkEqual("ID1ID2", (short) 0x1f8b, id1id2);
-    source.skip(8);
-
-    // Skip optional extra fields.
-    // +---+---+=================================+
-    // | XLEN  |...XLEN bytes of "extra field"...| (more-->)
-    // +---+---+=================================+
-    if (((flags >> FEXTRA) & 1) == 1) {
-      source.require(2);
-      if (fhcrc) updateCrc(source.buffer(), 0, 2);
-      int xlen = source.buffer().readShortLe();
-      source.require(xlen);
-      if (fhcrc) updateCrc(source.buffer(), 0, xlen);
-      source.skip(xlen);
-    }
-
-    // Skip an optional 0-terminated name.
-    // +=========================================+
-    // |...original file name, zero-terminated...| (more-->)
-    // +=========================================+
-    if (((flags >> FNAME) & 1) == 1) {
-      long index = source.indexOf((byte) 0);
-      if (index == -1) throw new EOFException();
-      if (fhcrc) updateCrc(source.buffer(), 0, index + 1);
-      source.skip(index + 1);
-    }
-
-    // Skip an optional 0-terminated comment.
-    // +===================================+
-    // |...file comment, zero-terminated...| (more-->)
-    // +===================================+
-    if (((flags >> FCOMMENT) & 1) == 1) {
-      long index = source.indexOf((byte) 0);
-      if (index == -1) throw new EOFException();
-      if (fhcrc) updateCrc(source.buffer(), 0, index + 1);
-      source.skip(index + 1);
-    }
-
-    // Confirm the optional header CRC.
-    // +---+---+
-    // | CRC16 |
-    // +---+---+
-    if (fhcrc) {
-      checkEqual("FHCRC", source.readShortLe(), (short) crc.getValue());
-      crc.reset();
-    }
-  }
-
-  private void consumeTrailer() throws IOException {
-    // Read the eight-byte trailer. Confirm the body's CRC and size.
-    // +---+---+---+---+---+---+---+---+
-    // |     CRC32     |     ISIZE     |
-    // +---+---+---+---+---+---+---+---+
-    checkEqual("CRC", source.readIntLe(), (int) crc.getValue());
-    checkEqual("ISIZE", source.readIntLe(), inflater.getTotalOut());
-  }
-
-  @Override public Source deadline(Deadline deadline) {
-    source.deadline(deadline);
-    return this;
-  }
-
-  @Override public void close() throws IOException {
-    inflaterSource.close();
-  }
-
-  /** Updates the CRC with the given bytes. */
-  private void updateCrc(OkBuffer buffer, long offset, long byteCount) {
-    for (Segment s = buffer.head; byteCount > 0; s = s.next) {
-      int segmentByteCount = s.limit - s.pos;
-      if (offset < segmentByteCount) {
-        int toUpdate = (int) Math.min(byteCount, segmentByteCount - offset);
-        crc.update(s.data, (int) (s.pos + offset), toUpdate);
-        byteCount -= toUpdate;
-      }
-      offset -= segmentByteCount; // Track the offset of the current segment.
-    }
-  }
-
-  private void checkEqual(String name, int expected, int actual) throws IOException {
-    if (actual != expected) {
-      throw new IOException(String.format(
-          "%s: actual 0x%08x != expected 0x%08x", name, actual, expected));
-    }
-  }
-}
diff --git a/okio/src/main/java/okio/InflaterSource.java b/okio/src/main/java/okio/InflaterSource.java
deleted file mode 100644
index c86c9959a5..0000000000
--- a/okio/src/main/java/okio/InflaterSource.java
+++ /dev/null
@@ -1,124 +0,0 @@
-/*
- * Copyright (C) 2014 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okio;
-
-import java.io.EOFException;
-import java.io.IOException;
-import java.util.zip.DataFormatException;
-import java.util.zip.Inflater;
-
-/**
- * A source that uses <a href="http://tools.ietf.org/html/rfc1951">DEFLATE</a>
- * to decompress data read from another source.
- */
-public final class InflaterSource implements Source {
-  private final BufferedSource source;
-  private final Inflater inflater;
-
-  /**
-   * When we call Inflater.setInput(), the inflater keeps our byte array until
-   * it needs input again. This tracks how many bytes the inflater is currently
-   * holding on to.
-   */
-  private int bufferBytesHeldByInflater;
-  private boolean closed;
-
-  public InflaterSource(Source source, Inflater inflater) {
-    this(Okio.buffer(source), inflater);
-  }
-
-  /**
-   * This package-private constructor shares a buffer with its trusted caller.
-   * In general we can't share a BufferedSource because the inflater holds input
-   * bytes until they are inflated.
-   */
-  InflaterSource(BufferedSource source, Inflater inflater) {
-    if (source == null) throw new IllegalArgumentException("source == null");
-    if (inflater == null) throw new IllegalArgumentException("inflater == null");
-    this.source = source;
-    this.inflater = inflater;
-  }
-
-  @Override public long read(
-      OkBuffer sink, long byteCount) throws IOException {
-    if (byteCount < 0) throw new IllegalArgumentException("byteCount < 0: " + byteCount);
-    if (closed) throw new IllegalStateException("closed");
-    if (byteCount == 0) return 0;
-
-    while (true) {
-      boolean sourceExhausted = refill();
-
-      // Decompress the inflater's compressed data into the sink.
-      try {
-        Segment tail = sink.writableSegment(1);
-        int bytesInflated = inflater.inflate(tail.data, tail.limit, Segment.SIZE - tail.limit);
-        if (bytesInflated > 0) {
-          tail.limit += bytesInflated;
-          sink.size += bytesInflated;
-          return bytesInflated;
-        }
-        if (inflater.finished() || inflater.needsDictionary()) {
-          releaseInflatedBytes();
-          return -1;
-        }
-        if (sourceExhausted) throw new EOFException("source exhausted prematurely");
-      } catch (DataFormatException e) {
-        throw new IOException(e);
-      }
-    }
-  }
-
-  /**
-   * Refills the inflater with compressed data if it needs input. (And only if
-   * it needs input). Returns true if the inflater required input but the source
-   * was exhausted.
-   */
-  public boolean refill() throws IOException {
-    if (!inflater.needsInput()) return false;
-
-    releaseInflatedBytes();
-    if (inflater.getRemaining() != 0) throw new IllegalStateException("?"); // TODO: possible?
-
-    // If there are compressed bytes in the source, assign them to the inflater.
-    if (source.exhausted()) return true;
-
-    // Assign buffer bytes to the inflater.
-    Segment head = source.buffer().head;
-    bufferBytesHeldByInflater = head.limit - head.pos;
-    inflater.setInput(head.data, head.pos, bufferBytesHeldByInflater);
-    return false;
-  }
-
-  /** When the inflater has processed compressed data, remove it from the buffer. */
-  private void releaseInflatedBytes() throws IOException {
-    if (bufferBytesHeldByInflater == 0) return;
-    int toRelease = bufferBytesHeldByInflater - inflater.getRemaining();
-    bufferBytesHeldByInflater -= toRelease;
-    source.skip(toRelease);
-  }
-
-  @Override public Source deadline(Deadline deadline) {
-    source.deadline(deadline);
-    return this;
-  }
-
-  @Override public void close() throws IOException {
-    if (closed) return;
-    inflater.end();
-    closed = true;
-    source.close();
-  }
-}
diff --git a/okio/src/main/java/okio/OkBuffer.java b/okio/src/main/java/okio/OkBuffer.java
deleted file mode 100644
index c2d0d1917a..0000000000
--- a/okio/src/main/java/okio/OkBuffer.java
+++ /dev/null
@@ -1,746 +0,0 @@
-/*
- * Copyright (C) 2014 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okio;
-
-import java.io.EOFException;
-import java.io.IOException;
-import java.io.InputStream;
-import java.io.OutputStream;
-import java.security.MessageDigest;
-import java.security.NoSuchAlgorithmException;
-import java.util.ArrayList;
-import java.util.Collections;
-import java.util.List;
-
-import static okio.Util.UTF_8;
-import static okio.Util.checkOffsetAndCount;
-import static okio.Util.reverseBytesLong;
-
-/**
- * A collection of bytes in memory.
- *
- * <p><strong>Moving data from one OkBuffer to another is fast.</strong> Instead
- * of copying bytes from one place in memory to another, this class just changes
- * ownership of the underlying byte arrays.
- *
- * <p><strong>This buffer grows with your data.</strong> Just like ArrayList,
- * each OkBuffer starts small. It consumes only the memory it needs to.
- *
- * <p><strong>This buffer pools its byte arrays.</strong> When you allocate a
- * byte array in Java, the runtime must zero-fill the requested array before
- * returning it to you. Even if you're going to write over that space anyway.
- * This class avoids zero-fill and GC churn by pooling byte arrays.
- */
-public final class OkBuffer implements BufferedSource, BufferedSink, Cloneable {
-  Segment head;
-  long size;
-
-  public OkBuffer() {
-  }
-
-  /** Returns the number of bytes currently in this buffer. */
-  public long size() {
-    return size;
-  }
-
-  @Override public OkBuffer buffer() {
-    return this;
-  }
-
-  @Override public OutputStream outputStream() {
-    return new OutputStream() {
-      @Override public void write(int b) {
-        writeByte((byte) b);
-      }
-
-      @Override public void write(byte[] data, int offset, int byteCount) {
-        OkBuffer.this.write(data, offset, byteCount);
-      }
-
-      @Override public void flush() {
-      }
-
-      @Override public void close() {
-      }
-
-      @Override public String toString() {
-        return this + ".outputStream()";
-      }
-    };
-  }
-
-  @Override public OkBuffer emitCompleteSegments() {
-    return this; // Nowhere to emit to!
-  }
-
-  @Override public boolean exhausted() {
-    return size == 0;
-  }
-
-  @Override public void require(long byteCount) throws EOFException {
-    if (this.size < byteCount) throw new EOFException();
-  }
-
-  @Override public InputStream inputStream() {
-    return new InputStream() {
-      @Override public int read() {
-        return readByte() & 0xff;
-      }
-
-      @Override public int read(byte[] sink, int offset, int byteCount) {
-        return OkBuffer.this.read(sink, offset, byteCount);
-      }
-
-      @Override public int available() {
-        return (int) Math.min(size, Integer.MAX_VALUE);
-      }
-
-      @Override public void close() {
-      }
-
-      @Override public String toString() {
-        return OkBuffer.this + ".inputStream()";
-      }
-    };
-  }
-
-  /**
-   * Returns the number of bytes in segments that are not writable. This is the
-   * number of bytes that can be flushed immediately to an underlying sink
-   * without harming throughput.
-   */
-  public long completeSegmentByteCount() {
-    long result = size;
-    if (result == 0) return 0;
-
-    // Omit the tail if it's still writable.
-    Segment tail = head.prev;
-    if (tail.limit < Segment.SIZE) {
-      result -= tail.limit - tail.pos;
-    }
-
-    return result;
-  }
-
-  @Override public byte readByte() {
-    if (size == 0) throw new IllegalStateException("size == 0");
-
-    Segment segment = head;
-    int pos = segment.pos;
-    int limit = segment.limit;
-
-    byte[] data = segment.data;
-    byte b = data[pos++];
-    size -= 1;
-
-    if (pos == limit) {
-      head = segment.pop();
-      SegmentPool.INSTANCE.recycle(segment);
-    } else {
-      segment.pos = pos;
-    }
-
-    return b;
-  }
-
-  /** Returns the byte at {@code pos}. */
-  public byte getByte(long pos) {
-    checkOffsetAndCount(size, pos, 1);
-    for (Segment s = head; true; s = s.next) {
-      int segmentByteCount = s.limit - s.pos;
-      if (pos < segmentByteCount) return s.data[s.pos + (int) pos];
-      pos -= segmentByteCount;
-    }
-  }
-
-  @Override public short readShort() {
-    if (size < 2) throw new IllegalStateException("size < 2: " + size);
-
-    Segment segment = head;
-    int pos = segment.pos;
-    int limit = segment.limit;
-
-    // If the short is split across multiple segments, delegate to readByte().
-    if (limit - pos < 2) {
-      int s = (readByte() & 0xff) << 8
-          |   (readByte() & 0xff);
-      return (short) s;
-    }
-
-    byte[] data = segment.data;
-    int s = (data[pos++] & 0xff) << 8
-        |   (data[pos++] & 0xff);
-    size -= 2;
-
-    if (pos == limit) {
-      head = segment.pop();
-      SegmentPool.INSTANCE.recycle(segment);
-    } else {
-      segment.pos = pos;
-    }
-
-    return (short) s;
-  }
-
-  @Override public int readInt() {
-    if (size < 4) throw new IllegalStateException("size < 4: " + size);
-
-    Segment segment = head;
-    int pos = segment.pos;
-    int limit = segment.limit;
-
-    // If the int is split across multiple segments, delegate to readByte().
-    if (limit - pos < 4) {
-      return (readByte() & 0xff) << 24
-          |  (readByte() & 0xff) << 16
-          |  (readByte() & 0xff) <<  8
-          |  (readByte() & 0xff);
-    }
-
-    byte[] data = segment.data;
-    int i = (data[pos++] & 0xff) << 24
-        |   (data[pos++] & 0xff) << 16
-        |   (data[pos++] & 0xff) <<  8
-        |   (data[pos++] & 0xff);
-    size -= 4;
-
-    if (pos == limit) {
-      head = segment.pop();
-      SegmentPool.INSTANCE.recycle(segment);
-    } else {
-      segment.pos = pos;
-    }
-
-    return i;
-  }
-
-  @Override public long readLong() {
-    if (size < 8) throw new IllegalStateException("size < 8: " + size);
-
-    Segment segment = head;
-    int pos = segment.pos;
-    int limit = segment.limit;
-
-    // If the long is split across multiple segments, delegate to readInt().
-    if (limit - pos < 8) {
-      return (readInt() & 0xffffffffL) << 32
-          |  (readInt() & 0xffffffffL);
-    }
-
-    byte[] data = segment.data;
-    long v = (data[pos++] & 0xffL) << 56
-        |    (data[pos++] & 0xffL) << 48
-        |    (data[pos++] & 0xffL) << 40
-        |    (data[pos++] & 0xffL) << 32
-        |    (data[pos++] & 0xffL) << 24
-        |    (data[pos++] & 0xffL) << 16
-        |    (data[pos++] & 0xffL) <<  8
-        |    (data[pos++] & 0xffL);
-    size -= 8;
-
-    if (pos == limit) {
-      head = segment.pop();
-      SegmentPool.INSTANCE.recycle(segment);
-    } else {
-      segment.pos = pos;
-    }
-
-    return v;
-  }
-
-  @Override public short readShortLe() {
-    return Util.reverseBytesShort(readShort());
-  }
-
-  @Override public int readIntLe() {
-    return Util.reverseBytesInt(readInt());
-  }
-
-  @Override public long readLongLe() {
-    return Util.reverseBytesLong(readLong());
-  }
-
-  @Override public ByteString readByteString(long byteCount) {
-    return new ByteString(readBytes(byteCount));
-  }
-
-  @Override public String readUtf8(long byteCount) {
-    checkOffsetAndCount(this.size, 0, byteCount);
-    if (byteCount > Integer.MAX_VALUE) {
-      throw new IllegalArgumentException("byteCount > Integer.MAX_VALUE: " + byteCount);
-    }
-    if (byteCount == 0) return "";
-
-    Segment head = this.head;
-    if (head.pos + byteCount > head.limit) {
-      // If the string spans multiple segments, delegate to readBytes().
-      return new String(readBytes(byteCount), Util.UTF_8);
-    }
-
-    String result = new String(head.data, head.pos, (int) byteCount, UTF_8);
-    head.pos += byteCount;
-    this.size -= byteCount;
-
-    if (head.pos == head.limit) {
-      this.head = head.pop();
-      SegmentPool.INSTANCE.recycle(head);
-    }
-
-    return result;
-  }
-
-  @Override public String readUtf8Line() throws IOException {
-    long newline = indexOf((byte) '\n');
-
-    if (newline == -1) {
-      return size != 0 ? readUtf8(size) : null;
-    }
-
-    return readUtf8Line(newline);
-  }
-
-  @Override public String readUtf8LineStrict() throws IOException {
-    long newline = indexOf((byte) '\n');
-    if (newline == -1) throw new EOFException();
-    return readUtf8Line(newline);
-  }
-
-  String readUtf8Line(long newline) {
-    if (newline > 0 && getByte(newline - 1) == '\r') {
-      // Read everything until '\r\n', then skip the '\r\n'.
-      String result = readUtf8((newline - 1));
-      skip(2);
-      return result;
-
-    } else {
-      // Read everything until '\n', then skip the '\n'.
-      String result = readUtf8(newline);
-      skip(1);
-      return result;
-    }
-  }
-
-  private byte[] readBytes(long byteCount) {
-    checkOffsetAndCount(this.size, 0, byteCount);
-    if (byteCount > Integer.MAX_VALUE) {
-      throw new IllegalArgumentException("byteCount > Integer.MAX_VALUE: " + byteCount);
-    }
-
-    int offset = 0;
-    byte[] result = new byte[(int) byteCount];
-
-    while (offset < byteCount) {
-      int toCopy = (int) Math.min(byteCount - offset, head.limit - head.pos);
-      System.arraycopy(head.data, head.pos, result, offset, toCopy);
-
-      offset += toCopy;
-      head.pos += toCopy;
-
-      if (head.pos == head.limit) {
-        Segment toRecycle = head;
-        head = toRecycle.pop();
-        SegmentPool.INSTANCE.recycle(toRecycle);
-      }
-    }
-
-    this.size -= byteCount;
-    return result;
-  }
-
-  /** Like {@link InputStream#read}. */
-  int read(byte[] sink, int offset, int byteCount) {
-    if (byteCount == 0) return -1;
-
-    Segment s = this.head;
-    int toCopy = Math.min(byteCount, s.limit - s.pos);
-    System.arraycopy(s.data, s.pos, sink, offset, toCopy);
-
-    s.pos += toCopy;
-    this.size -= toCopy;
-
-    if (s.pos == s.limit) {
-      this.head = s.pop();
-      SegmentPool.INSTANCE.recycle(s);
-    }
-
-    return toCopy;
-  }
-
-  /**
-   * Discards all bytes in this buffer. Calling this method when you're done
-   * with a buffer will return its segments to the pool.
-   */
-  public void clear() {
-    skip(size);
-  }
-
-  /** Discards {@code byteCount} bytes from the head of this buffer. */
-  @Override public void skip(long byteCount) {
-    checkOffsetAndCount(this.size, 0, byteCount);
-
-    this.size -= byteCount;
-    while (byteCount > 0) {
-      int toSkip = (int) Math.min(byteCount, head.limit - head.pos);
-      byteCount -= toSkip;
-      head.pos += toSkip;
-
-      if (head.pos == head.limit) {
-        Segment toRecycle = head;
-        head = toRecycle.pop();
-        SegmentPool.INSTANCE.recycle(toRecycle);
-      }
-    }
-  }
-
-  @Override public OkBuffer write(ByteString byteString) {
-    return write(byteString.data, 0, byteString.data.length);
-  }
-
-  @Override public OkBuffer writeUtf8(String string) {
-    // TODO: inline UTF-8 encoding to save allocating a byte[]?
-    byte[] data = string.getBytes(Util.UTF_8);
-    return write(data, 0, data.length);
-  }
-
-  @Override public OkBuffer write(byte[] source) {
-    return write(source, 0, source.length);
-  }
-
-  @Override public OkBuffer write(byte[] source, int offset, int byteCount) {
-    int limit = offset + byteCount;
-    while (offset < limit) {
-      Segment tail = writableSegment(1);
-
-      int toCopy = Math.min(limit - offset, Segment.SIZE - tail.limit);
-      System.arraycopy(source, offset, tail.data, tail.limit, toCopy);
-
-      offset += toCopy;
-      tail.limit += toCopy;
-    }
-
-    this.size += byteCount;
-    return this;
-  }
-
-  @Override public OkBuffer writeByte(int b) {
-    Segment tail = writableSegment(1);
-    tail.data[tail.limit++] = (byte) b;
-    size += 1;
-    return this;
-  }
-
-  @Override public OkBuffer writeShort(int s) {
-    Segment tail = writableSegment(2);
-    byte[] data = tail.data;
-    int limit = tail.limit;
-    data[limit++] = (byte) ((s >>> 8) & 0xff);
-    data[limit++] = (byte)  (s        & 0xff);
-    tail.limit = limit;
-    size += 2;
-    return this;
-  }
-
-  @Override public BufferedSink writeShortLe(int s) {
-    return writeShort(Util.reverseBytesShort((short) s));
-  }
-
-  @Override public OkBuffer writeInt(int i) {
-    Segment tail = writableSegment(4);
-    byte[] data = tail.data;
-    int limit = tail.limit;
-    data[limit++] = (byte) ((i >>> 24) & 0xff);
-    data[limit++] = (byte) ((i >>> 16) & 0xff);
-    data[limit++] = (byte) ((i >>>  8) & 0xff);
-    data[limit++] = (byte)  (i         & 0xff);
-    tail.limit = limit;
-    size += 4;
-    return this;
-  }
-
-  @Override public BufferedSink writeIntLe(int i) {
-    return writeInt(Util.reverseBytesInt(i));
-  }
-
-  @Override public OkBuffer writeLong(long v) {
-    Segment tail = writableSegment(8);
-    byte[] data = tail.data;
-    int limit = tail.limit;
-    data[limit++] = (byte) ((v >>> 56L) & 0xff);
-    data[limit++] = (byte) ((v >>> 48L) & 0xff);
-    data[limit++] = (byte) ((v >>> 40L) & 0xff);
-    data[limit++] = (byte) ((v >>> 32L) & 0xff);
-    data[limit++] = (byte) ((v >>> 24L) & 0xff);
-    data[limit++] = (byte) ((v >>> 16L) & 0xff);
-    data[limit++] = (byte) ((v >>>  8L) & 0xff);
-    data[limit++] = (byte)  (v          & 0xff);
-    tail.limit = limit;
-    size += 8;
-    return this;
-  }
-
-  @Override public BufferedSink writeLongLe(long v) {
-    return writeLong(reverseBytesLong(v));
-  }
-
-  /**
-   * Returns a tail segment that we can write at least {@code minimumCapacity}
-   * bytes to, creating it if necessary.
-   */
-  Segment writableSegment(int minimumCapacity) {
-    if (minimumCapacity < 1 || minimumCapacity > Segment.SIZE) throw new IllegalArgumentException();
-
-    if (head == null) {
-      head = SegmentPool.INSTANCE.take(); // Acquire a first segment.
-      return head.next = head.prev = head;
-    }
-
-    Segment tail = head.prev;
-    if (tail.limit + minimumCapacity > Segment.SIZE) {
-      tail = tail.push(SegmentPool.INSTANCE.take()); // Append a new empty segment to fill up.
-    }
-    return tail;
-  }
-
-  @Override public void write(OkBuffer source, long byteCount) {
-    // Move bytes from the head of the source buffer to the tail of this buffer
-    // while balancing two conflicting goals: don't waste CPU and don't waste
-    // memory.
-    //
-    //
-    // Don't waste CPU (ie. don't copy data around).
-    //
-    // Copying large amounts of data is expensive. Instead, we prefer to
-    // reassign entire segments from one OkBuffer to the other.
-    //
-    //
-    // Don't waste memory.
-    //
-    // As an invariant, adjacent pairs of segments in an OkBuffer should be at
-    // least 50% full, except for the head segment and the tail segment.
-    //
-    // The head segment cannot maintain the invariant because the application is
-    // consuming bytes from this segment, decreasing its level.
-    //
-    // The tail segment cannot maintain the invariant because the application is
-    // producing bytes, which may require new nearly-empty tail segments to be
-    // appended.
-    //
-    //
-    // Moving segments between buffers
-    //
-    // When writing one buffer to another, we prefer to reassign entire segments
-    // over copying bytes into their most compact form. Suppose we have a buffer
-    // with these segment levels [91%, 61%]. If we append a buffer with a
-    // single [72%] segment, that yields [91%, 61%, 72%]. No bytes are copied.
-    //
-    // Or suppose we have a buffer with these segment levels: [100%, 2%], and we
-    // want to append it to a buffer with these segment levels [99%, 3%]. This
-    // operation will yield the following segments: [100%, 2%, 99%, 3%]. That
-    // is, we do not spend time copying bytes around to achieve more efficient
-    // memory use like [100%, 100%, 4%].
-    //
-    // When combining buffers, we will compact adjacent buffers when their
-    // combined level doesn't exceed 100%. For example, when we start with
-    // [100%, 40%] and append [30%, 80%], the result is [100%, 70%, 80%].
-    //
-    //
-    // Splitting segments
-    //
-    // Occasionally we write only part of a source buffer to a sink buffer. For
-    // example, given a sink [51%, 91%], we may want to write the first 30% of
-    // a source [92%, 82%] to it. To simplify, we first transform the source to
-    // an equivalent buffer [30%, 62%, 82%] and then move the head segment,
-    // yielding sink [51%, 91%, 30%] and source [62%, 82%].
-
-    if (source == this) {
-      throw new IllegalArgumentException("source == this");
-    }
-    checkOffsetAndCount(source.size, 0, byteCount);
-
-    while (byteCount > 0) {
-      // Is a prefix of the source's head segment all that we need to move?
-      if (byteCount < (source.head.limit - source.head.pos)) {
-        Segment tail = head != null ? head.prev : null;
-        if (tail == null || byteCount + (tail.limit - tail.pos) > Segment.SIZE) {
-          // We're going to need another segment. Split the source's head
-          // segment in two, then move the first of those two to this buffer.
-          source.head = source.head.split((int) byteCount);
-        } else {
-          // Our existing segments are sufficient. Move bytes from source's head to our tail.
-          source.head.writeTo(tail, (int) byteCount);
-          source.size -= byteCount;
-          this.size += byteCount;
-          return;
-        }
-      }
-
-      // Remove the source's head segment and append it to our tail.
-      Segment segmentToMove = source.head;
-      long movedByteCount = segmentToMove.limit - segmentToMove.pos;
-      source.head = segmentToMove.pop();
-      if (head == null) {
-        head = segmentToMove;
-        head.next = head.prev = head;
-      } else {
-        Segment tail = head.prev;
-        tail = tail.push(segmentToMove);
-        tail.compact();
-      }
-      source.size -= movedByteCount;
-      this.size += movedByteCount;
-      byteCount -= movedByteCount;
-    }
-  }
-
-  @Override public long read(OkBuffer sink, long byteCount) {
-    if (this.size == 0) return -1L;
-    if (byteCount > this.size) byteCount = this.size;
-    sink.write(this, byteCount);
-    return byteCount;
-  }
-
-  @Override public OkBuffer deadline(Deadline deadline) {
-    // All operations are in memory so this class doesn't need to honor deadlines.
-    return this;
-  }
-
-  @Override public long indexOf(byte b) {
-    return indexOf(b, 0);
-  }
-
-  /**
-   * Returns the index of {@code b} in this at or beyond {@code fromIndex}, or
-   * -1 if this buffer does not contain {@code b} in that range.
-   */
-  public long indexOf(byte b, long fromIndex) {
-    Segment s = head;
-    if (s == null) return -1L;
-    long offset = 0L;
-    do {
-      int segmentByteCount = s.limit - s.pos;
-      if (fromIndex > segmentByteCount) {
-        fromIndex -= segmentByteCount;
-      } else {
-        byte[] data = s.data;
-        for (long pos = s.pos + fromIndex, limit = s.limit; pos < limit; pos++) {
-          if (data[(int) pos] == b) return offset + pos - s.pos;
-        }
-        fromIndex = 0;
-      }
-      offset += segmentByteCount;
-      s = s.next;
-    } while (s != head);
-    return -1L;
-  }
-
-  @Override public void flush() {
-  }
-
-  @Override public void close() {
-  }
-
-  /** For testing. This returns the sizes of the segments in this buffer. */
-  List<Integer> segmentSizes() {
-    if (head == null) return Collections.emptyList();
-    List<Integer> result = new ArrayList<Integer>();
-    result.add(head.limit - head.pos);
-    for (Segment s = head.next; s != head; s = s.next) {
-      result.add(s.limit - s.pos);
-    }
-    return result;
-  }
-
-  @Override public boolean equals(Object o) {
-    if (!(o instanceof OkBuffer)) return false;
-    OkBuffer that = (OkBuffer) o;
-    if (size != that.size) return false;
-    if (size == 0) return true; // Both buffers are empty.
-
-    Segment sa = this.head;
-    Segment sb = that.head;
-    int posA = sa.pos;
-    int posB = sb.pos;
-
-    for (long pos = 0, count; pos < size; pos += count) {
-      count = Math.min(sa.limit - posA, sb.limit - posB);
-
-      for (int i = 0; i < count; i++) {
-        if (sa.data[posA++] != sb.data[posB++]) return false;
-      }
-
-      if (posA == sa.limit) {
-        sa = sa.next;
-        posA = sa.pos;
-      }
-
-      if (posB == sb.limit) {
-        sb = sb.next;
-        posB = sb.pos;
-      }
-    }
-
-    return true;
-  }
-
-  @Override public int hashCode() {
-    Segment s = head;
-    if (s == null) return 0;
-    int result = 1;
-    do {
-      for (int pos = s.pos, limit = s.limit; pos < limit; pos++) {
-        result = 31 * result + s.data[pos];
-      }
-      s = s.next;
-    } while (s != head);
-    return result;
-  }
-
-  @Override public String toString() {
-    if (size == 0) {
-      return "OkBuffer[size=0]";
-    }
-
-    if (size <= 16) {
-      ByteString data = clone().readByteString(size);
-      return String.format("OkBuffer[size=%s data=%s]", size, data.hex());
-    }
-
-    try {
-      MessageDigest md5 = MessageDigest.getInstance("MD5");
-      md5.update(head.data, head.pos, head.limit - head.pos);
-      for (Segment s = head.next; s != head; s = s.next) {
-        md5.update(s.data, s.pos, s.limit - s.pos);
-      }
-      return String.format("OkBuffer[size=%s md5=%s]",
-          size, ByteString.of(md5.digest()).hex());
-    } catch (NoSuchAlgorithmException e) {
-      throw new AssertionError();
-    }
-  }
-
-  /** Returns a deep copy of this buffer. */
-  @Override public OkBuffer clone() {
-    OkBuffer result = new OkBuffer();
-    if (size() == 0) return result;
-
-    result.write(head.data, head.pos, head.limit - head.pos);
-    for (Segment s = head.next; s != head; s = s.next) {
-      result.write(s.data, s.pos, s.limit - s.pos);
-    }
-
-    return result;
-  }
-}
diff --git a/okio/src/main/java/okio/Okio.java b/okio/src/main/java/okio/Okio.java
deleted file mode 100644
index 3a9b4f9f83..0000000000
--- a/okio/src/main/java/okio/Okio.java
+++ /dev/null
@@ -1,135 +0,0 @@
-/*
- * Copyright (C) 2014 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okio;
-
-import java.io.IOException;
-import java.io.InputStream;
-import java.io.OutputStream;
-
-import static okio.Util.checkOffsetAndCount;
-
-public final class Okio {
-  private Okio() {
-  }
-
-  public static BufferedSource buffer(Source source) {
-    return new RealBufferedSource(source);
-  }
-
-  public static BufferedSink buffer(Sink sink) {
-    return new RealBufferedSink(sink);
-  }
-
-  /** Copies bytes from {@code source} to {@code sink}. */
-  public static void copy(OkBuffer source, long offset, long byteCount, OutputStream sink)
-      throws IOException {
-    checkOffsetAndCount(source.size, offset, byteCount);
-
-    // Skip segments that we aren't copying from.
-    Segment s = source.head;
-    while (offset >= (s.limit - s.pos)) {
-      offset -= (s.limit - s.pos);
-      s = s.next;
-    }
-
-    // Copy from one segment at a time.
-    while (byteCount > 0) {
-      int pos = (int) (s.pos + offset);
-      int toWrite = (int) Math.min(s.limit - pos, byteCount);
-      sink.write(s.data, pos, toWrite);
-      byteCount -= toWrite;
-      offset = 0;
-    }
-  }
-
-  /** Returns a sink that writes to {@code out}. */
-  public static Sink sink(final OutputStream out) {
-    return new Sink() {
-      private Deadline deadline = Deadline.NONE;
-
-      @Override public void write(OkBuffer source, long byteCount)
-          throws IOException {
-        checkOffsetAndCount(source.size, 0, byteCount);
-        while (byteCount > 0) {
-          deadline.throwIfReached();
-          Segment head = source.head;
-          int toCopy = (int) Math.min(byteCount, head.limit - head.pos);
-          out.write(head.data, head.pos, toCopy);
-
-          head.pos += toCopy;
-          byteCount -= toCopy;
-          source.size -= toCopy;
-
-          if (head.pos == head.limit) {
-            source.head = head.pop();
-            SegmentPool.INSTANCE.recycle(head);
-          }
-        }
-      }
-
-      @Override public void flush() throws IOException {
-        out.flush();
-      }
-
-      @Override public void close() throws IOException {
-        out.close();
-      }
-
-      @Override public Sink deadline(Deadline deadline) {
-        if (deadline == null) throw new IllegalArgumentException("deadline == null");
-        this.deadline = deadline;
-        return this;
-      }
-
-      @Override public String toString() {
-        return "sink(" + out + ")";
-      }
-    };
-  }
-
-  /** Returns a source that reads from {@code in}. */
-  public static Source source(final InputStream in) {
-    return new Source() {
-      private Deadline deadline = Deadline.NONE;
-
-      @Override public long read(OkBuffer sink, long byteCount) throws IOException {
-        if (byteCount < 0) throw new IllegalArgumentException("byteCount < 0: " + byteCount);
-        deadline.throwIfReached();
-        Segment tail = sink.writableSegment(1);
-        int maxToCopy = (int) Math.min(byteCount, Segment.SIZE - tail.limit);
-        int bytesRead = in.read(tail.data, tail.limit, maxToCopy);
-        if (bytesRead == -1) return -1;
-        tail.limit += bytesRead;
-        sink.size += bytesRead;
-        return bytesRead;
-      }
-
-      @Override public void close() throws IOException {
-        in.close();
-      }
-
-      @Override public Source deadline(Deadline deadline) {
-        if (deadline == null) throw new IllegalArgumentException("deadline == null");
-        this.deadline = deadline;
-        return this;
-      }
-
-      @Override public String toString() {
-        return "source(" + in + ")";
-      }
-    };
-  }
-}
diff --git a/okio/src/main/java/okio/RealBufferedSink.java b/okio/src/main/java/okio/RealBufferedSink.java
deleted file mode 100644
index 74454c60ce..0000000000
--- a/okio/src/main/java/okio/RealBufferedSink.java
+++ /dev/null
@@ -1,191 +0,0 @@
-/*
- * Copyright (C) 2014 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okio;
-
-import java.io.IOException;
-import java.io.OutputStream;
-
-final class RealBufferedSink implements BufferedSink {
-  public final OkBuffer buffer;
-  public final Sink sink;
-  private boolean closed;
-
-  public RealBufferedSink(Sink sink, OkBuffer buffer) {
-    if (sink == null) throw new IllegalArgumentException("sink == null");
-    this.buffer = buffer;
-    this.sink = sink;
-  }
-
-  public RealBufferedSink(Sink sink) {
-    this(sink, new OkBuffer());
-  }
-
-  @Override public OkBuffer buffer() {
-    return buffer;
-  }
-
-  @Override public void write(OkBuffer source, long byteCount)
-      throws IOException {
-    if (closed) throw new IllegalStateException("closed");
-    buffer.write(source, byteCount);
-    emitCompleteSegments();
-  }
-
-  @Override public BufferedSink write(ByteString byteString) throws IOException {
-    if (closed) throw new IllegalStateException("closed");
-    buffer.write(byteString);
-    return emitCompleteSegments();
-  }
-
-  @Override public BufferedSink writeUtf8(String string) throws IOException {
-    if (closed) throw new IllegalStateException("closed");
-    buffer.writeUtf8(string);
-    return emitCompleteSegments();
-  }
-
-  @Override public BufferedSink write(byte[] source) throws IOException {
-    if (closed) throw new IllegalStateException("closed");
-    buffer.write(source);
-    return emitCompleteSegments();
-  }
-
-  @Override public BufferedSink write(byte[] source, int offset, int byteCount) throws IOException {
-    if (closed) throw new IllegalStateException("closed");
-    buffer.write(source, offset, byteCount);
-    return emitCompleteSegments();
-  }
-
-  @Override public BufferedSink writeByte(int b) throws IOException {
-    if (closed) throw new IllegalStateException("closed");
-    buffer.writeByte(b);
-    return emitCompleteSegments();
-  }
-
-  @Override public BufferedSink writeShort(int s) throws IOException {
-    if (closed) throw new IllegalStateException("closed");
-    buffer.writeShort(s);
-    return emitCompleteSegments();
-  }
-
-  @Override public BufferedSink writeShortLe(int s) throws IOException {
-    if (closed) throw new IllegalStateException("closed");
-    buffer.writeShortLe(s);
-    return emitCompleteSegments();
-  }
-
-  @Override public BufferedSink writeInt(int i) throws IOException {
-    if (closed) throw new IllegalStateException("closed");
-    buffer.writeInt(i);
-    return emitCompleteSegments();
-  }
-
-  @Override public BufferedSink writeIntLe(int i) throws IOException {
-    if (closed) throw new IllegalStateException("closed");
-    buffer.writeIntLe(i);
-    return emitCompleteSegments();
-  }
-
-  @Override public BufferedSink writeLong(long v) throws IOException {
-    if (closed) throw new IllegalStateException("closed");
-    buffer.writeLong(v);
-    return emitCompleteSegments();
-  }
-
-  @Override public BufferedSink writeLongLe(long v) throws IOException {
-    if (closed) throw new IllegalStateException("closed");
-    buffer.writeLongLe(v);
-    return emitCompleteSegments();
-  }
-
-  @Override public BufferedSink emitCompleteSegments() throws IOException {
-    if (closed) throw new IllegalStateException("closed");
-    long byteCount = buffer.completeSegmentByteCount();
-    if (byteCount > 0) sink.write(buffer, byteCount);
-    return this;
-  }
-
-  @Override public OutputStream outputStream() {
-    return new OutputStream() {
-      @Override public void write(int b) throws IOException {
-        if (closed) throw new IOException("closed");
-        buffer.writeByte((byte) b);
-        emitCompleteSegments();
-      }
-
-      @Override public void write(byte[] data, int offset, int byteCount) throws IOException {
-        if (closed) throw new IOException("closed");
-        buffer.write(data, offset, byteCount);
-        emitCompleteSegments();
-      }
-
-      @Override public void flush() throws IOException {
-        // For backwards compatibility, a flush() on a closed stream is a no-op.
-        if (!closed) {
-          RealBufferedSink.this.flush();
-        }
-      }
-
-      @Override public void close() throws IOException {
-        RealBufferedSink.this.close();
-      }
-
-      @Override public String toString() {
-        return RealBufferedSink.this + ".outputStream()";
-      }
-    };
-  }
-
-  @Override public void flush() throws IOException {
-    if (closed) throw new IllegalStateException("closed");
-    if (buffer.size > 0) {
-      sink.write(buffer, buffer.size);
-    }
-    sink.flush();
-  }
-
-  @Override public void close() throws IOException {
-    if (closed) return;
-
-    // Emit buffered data to the underlying sink. If this fails, we still need
-    // to close the sink; otherwise we risk leaking resources.
-    Throwable thrown = null;
-    try {
-      if (buffer.size > 0) {
-        sink.write(buffer, buffer.size);
-      }
-    } catch (Throwable e) {
-      thrown = e;
-    }
-
-    try {
-      sink.close();
-    } catch (Throwable e) {
-      if (thrown == null) thrown = e;
-    }
-    closed = true;
-
-    if (thrown != null) Util.sneakyRethrow(thrown);
-  }
-
-  @Override public Sink deadline(Deadline deadline) {
-    sink.deadline(deadline);
-    return this;
-  }
-
-  @Override public String toString() {
-    return "buffer(" + sink + ")";
-  }
-}
diff --git a/okio/src/main/java/okio/RealBufferedSource.java b/okio/src/main/java/okio/RealBufferedSource.java
deleted file mode 100644
index 0189d0f7f7..0000000000
--- a/okio/src/main/java/okio/RealBufferedSource.java
+++ /dev/null
@@ -1,205 +0,0 @@
-/*
- * Copyright (C) 2014 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okio;
-
-import java.io.EOFException;
-import java.io.IOException;
-import java.io.InputStream;
-
-import static okio.Util.checkOffsetAndCount;
-
-final class RealBufferedSource implements BufferedSource {
-  public final OkBuffer buffer;
-  public final Source source;
-  private boolean closed;
-
-  public RealBufferedSource(Source source, OkBuffer buffer) {
-    if (source == null) throw new IllegalArgumentException("source == null");
-    this.buffer = buffer;
-    this.source = source;
-  }
-
-  public RealBufferedSource(Source source) {
-    this(source, new OkBuffer());
-  }
-
-  @Override public OkBuffer buffer() {
-    return buffer;
-  }
-
-  @Override public long read(OkBuffer sink, long byteCount) throws IOException {
-    if (byteCount < 0) throw new IllegalArgumentException("byteCount < 0: " + byteCount);
-    if (closed) throw new IllegalStateException("closed");
-
-    if (buffer.size == 0) {
-      long read = source.read(buffer, Segment.SIZE);
-      if (read == -1) return -1;
-    }
-
-    long toRead = Math.min(byteCount, buffer.size);
-    return buffer.read(sink, toRead);
-  }
-
-  @Override public boolean exhausted() throws IOException {
-    if (closed) throw new IllegalStateException("closed");
-    return buffer.exhausted() && source.read(buffer, Segment.SIZE) == -1;
-  }
-
-  @Override public void require(long byteCount) throws IOException {
-    if (closed) throw new IllegalStateException("closed");
-    while (buffer.size < byteCount) {
-      if (source.read(buffer, Segment.SIZE) == -1) throw new EOFException();
-    }
-  }
-
-  @Override public byte readByte() throws IOException {
-    require(1);
-    return buffer.readByte();
-  }
-
-  @Override public ByteString readByteString(long byteCount) throws IOException {
-    require(byteCount);
-    return buffer.readByteString(byteCount);
-  }
-
-  @Override public String readUtf8(long byteCount) throws IOException {
-    require(byteCount);
-    return buffer.readUtf8(byteCount);
-  }
-
-  @Override public String readUtf8Line() throws IOException {
-    long newline = indexOf((byte) '\n');
-
-    if (newline == -1) {
-      return buffer.size != 0 ? readUtf8(buffer.size) : null;
-    }
-
-    return buffer.readUtf8Line(newline);
-  }
-
-  @Override public String readUtf8LineStrict() throws IOException {
-    long newline = indexOf((byte) '\n');
-    if (newline == -1L) throw new EOFException();
-    return buffer.readUtf8Line(newline);
-  }
-
-  @Override public short readShort() throws IOException {
-    require(2);
-    return buffer.readShort();
-  }
-
-  @Override public short readShortLe() throws IOException {
-    require(2);
-    return buffer.readShortLe();
-  }
-
-  @Override public int readInt() throws IOException {
-    require(4);
-    return buffer.readInt();
-  }
-
-  @Override public int readIntLe() throws IOException {
-    require(4);
-    return buffer.readIntLe();
-  }
-
-  @Override public long readLong() throws IOException {
-    require(8);
-    return buffer.readLong();
-  }
-
-  @Override public long readLongLe() throws IOException {
-    require(8);
-    return buffer.readLongLe();
-  }
-
-  @Override public void skip(long byteCount) throws IOException {
-    if (closed) throw new IllegalStateException("closed");
-    while (byteCount > 0) {
-      if (buffer.size == 0 && source.read(buffer, Segment.SIZE) == -1) {
-        throw new EOFException();
-      }
-      long toSkip = Math.min(byteCount, buffer.size());
-      buffer.skip(toSkip);
-      byteCount -= toSkip;
-    }
-  }
-
-  @Override public long indexOf(byte b) throws IOException {
-    if (closed) throw new IllegalStateException("closed");
-    long start = 0;
-    long index;
-    while ((index = buffer.indexOf(b, start)) == -1) {
-      start = buffer.size;
-      if (source.read(buffer, Segment.SIZE) == -1) return -1L;
-    }
-    return index;
-  }
-
-  @Override public InputStream inputStream() {
-    return new InputStream() {
-      @Override public int read() throws IOException {
-        if (closed) throw new IOException("closed");
-        if (buffer.size == 0) {
-          long count = source.read(buffer, Segment.SIZE);
-          if (count == -1) return -1;
-        }
-        return buffer.readByte() & 0xff;
-      }
-
-      @Override public int read(byte[] data, int offset, int byteCount) throws IOException {
-        if (closed) throw new IOException("closed");
-        checkOffsetAndCount(data.length, offset, byteCount);
-
-        if (buffer.size == 0) {
-          long count = source.read(buffer, Segment.SIZE);
-          if (count == -1) return -1;
-        }
-
-        return buffer.read(data, offset, byteCount);
-      }
-
-      @Override public int available() throws IOException {
-        if (closed) throw new IOException("closed");
-        return (int) Math.min(buffer.size, Integer.MAX_VALUE);
-      }
-
-      @Override public void close() throws IOException {
-        RealBufferedSource.this.close();
-      }
-
-      @Override public String toString() {
-        return RealBufferedSource.this + ".inputStream()";
-      }
-    };
-  }
-
-  @Override public Source deadline(Deadline deadline) {
-    source.deadline(deadline);
-    return this;
-  }
-
-  @Override public void close() throws IOException {
-    if (closed) return;
-    closed = true;
-    source.close();
-    buffer.clear();
-  }
-
-  @Override public String toString() {
-    return "buffer(" + source + ")";
-  }
-}
diff --git a/okio/src/main/java/okio/Segment.java b/okio/src/main/java/okio/Segment.java
deleted file mode 100644
index 77dbee186d..0000000000
--- a/okio/src/main/java/okio/Segment.java
+++ /dev/null
@@ -1,135 +0,0 @@
-/*
- * Copyright (C) 2014 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okio;
-
-/**
- * A segment of an OkBuffer.
- *
- * <p>Each segment in an OkBuffer is a circularly-linked list node referencing
- * the following and preceding segments in the buffer.
- *
- * <p>Each segment in the pool is a singly-linked list node referencing the rest
- * of segments in the pool.
- */
-final class Segment {
-  /** The size of all segments in bytes. */
-  // TODO: Using fixed-size segments makes pooling easier. But it harms memory
-  //       efficiency and encourages copying. Try variable sized segments?
-  // TODO: Is 2 KiB a good default segment size?
-  static final int SIZE = 2048;
-
-  final byte[] data = new byte[SIZE];
-
-  /** The next byte of application data byte to read in this segment. */
-  int pos;
-
-  /** The first byte of available data ready to be written to. */
-  int limit;
-
-  /** Next segment in a linked or circularly-linked list. */
-  Segment next;
-
-  /** Previous segment in a circularly-linked list. */
-  Segment prev;
-
-  /**
-   * Removes this segment of a circularly-linked list and returns its successor.
-   * Returns null if the list is now empty.
-   */
-  public Segment pop() {
-    Segment result = next != this ? next : null;
-    prev.next = next;
-    next.prev = prev;
-    next = null;
-    prev = null;
-    return result;
-  }
-
-  /**
-   * Appends {@code segment} after this segment in the circularly-linked list.
-   * Returns the pushed segment.
-   */
-  public Segment push(Segment segment) {
-    segment.prev = this;
-    segment.next = next;
-    next.prev = segment;
-    next = segment;
-    return segment;
-  }
-
-  /**
-   * Splits this head of a circularly-linked list into two segments. The first
-   * segment contains the data in {@code [pos..pos+byteCount)}. The second
-   * segment contains the data in {@code [pos+byteCount..limit)}. This can be
-   * useful when moving partial segments from one OkBuffer to another.
-   *
-   * <p>Returns the new head of the circularly-linked list.
-   */
-  public Segment split(int byteCount) {
-    int aSize = byteCount;
-    int bSize = (limit - pos) - byteCount;
-    if (aSize <= 0 || bSize <= 0) throw new IllegalArgumentException();
-
-    // Which side of the split is larger? We want to copy as few bytes as possible.
-    if (aSize < bSize) {
-      // Create a segment of size 'aSize' before this segment.
-      Segment before = SegmentPool.INSTANCE.take();
-      System.arraycopy(data, pos, before.data, before.pos, aSize);
-      pos += aSize;
-      before.limit += aSize;
-      prev.push(before);
-      return before;
-    } else {
-      // Create a new segment of size 'bSize' after this segment.
-      Segment after = SegmentPool.INSTANCE.take();
-      System.arraycopy(data, pos + aSize, after.data, after.pos, bSize);
-      limit -= bSize;
-      after.limit += bSize;
-      push(after);
-      return this;
-    }
-  }
-
-  /**
-   * Call this when the tail and its predecessor may both be less than half
-   * full. This will copy data so that segments can be recycled.
-   */
-  public void compact() {
-    if (prev == this) throw new IllegalStateException();
-    if ((prev.limit - prev.pos) + (limit - pos) > SIZE) return; // Cannot compact.
-    writeTo(prev, limit - pos);
-    pop();
-    SegmentPool.INSTANCE.recycle(this);
-  }
-
-  /** Moves {@code byteCount} bytes from {@code sink} to this segment. */
-  // TODO: if sink has fewer bytes than this, it may be cheaper to reverse the
-  //       direction of the copy and swap the segments!
-  public void writeTo(Segment sink, int byteCount) {
-    if (byteCount + (sink.limit - sink.pos) > SIZE) throw new IllegalArgumentException();
-
-    if (sink.limit + byteCount > SIZE) {
-      // We can't fit byteCount bytes at the sink's current position. Compact sink first.
-      System.arraycopy(sink.data, sink.pos, sink.data, 0, sink.limit - sink.pos);
-      sink.limit -= sink.pos;
-      sink.pos = 0;
-    }
-
-    System.arraycopy(data, pos, sink.data, sink.limit, byteCount);
-    sink.limit += byteCount;
-    pos += byteCount;
-  }
-}
diff --git a/okio/src/main/java/okio/SegmentPool.java b/okio/src/main/java/okio/SegmentPool.java
deleted file mode 100644
index c132f244b6..0000000000
--- a/okio/src/main/java/okio/SegmentPool.java
+++ /dev/null
@@ -1,61 +0,0 @@
-/*
- * Copyright (C) 2014 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okio;
-
-/**
- * A collection of unused segments, necessary to avoid GC churn and zero-fill.
- * This pool is a thread-safe static singleton.
- */
-final class SegmentPool {
-  static final SegmentPool INSTANCE = new SegmentPool();
-
-  /** The maximum number of bytes to pool. */
-  // TODO: Is 64 KiB a good maximum size? Do we ever have that many idle segments?
-  static final long MAX_SIZE = 64 * 1024; // 64 KiB.
-
-  /** Singly-linked list of segments. */
-  private Segment next;
-
-  /** Total bytes in this pool. */
-  long byteCount;
-
-  private SegmentPool() {
-  }
-
-  Segment take() {
-    synchronized (this) {
-      if (next != null) {
-        Segment result = next;
-        next = result.next;
-        result.next = null;
-        byteCount -= Segment.SIZE;
-        return result;
-      }
-    }
-    return new Segment(); // Pool is empty. Don't zero-fill while holding a lock.
-  }
-
-  void recycle(Segment segment) {
-    if (segment.next != null || segment.prev != null) throw new IllegalArgumentException();
-    synchronized (this) {
-      if (byteCount + Segment.SIZE > MAX_SIZE) return; // Pool is full.
-      byteCount += Segment.SIZE;
-      segment.next = next;
-      segment.pos = segment.limit = 0;
-      next = segment;
-    }
-  }
-}
diff --git a/okio/src/main/java/okio/Sink.java b/okio/src/main/java/okio/Sink.java
deleted file mode 100644
index 402aa0fc3f..0000000000
--- a/okio/src/main/java/okio/Sink.java
+++ /dev/null
@@ -1,69 +0,0 @@
-/*
- * Copyright (C) 2014 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okio;
-
-import java.io.Closeable;
-import java.io.IOException;
-
-/**
- * Receives a stream of bytes. Use this interface to write data wherever it's
- * needed: to the network, storage, or a buffer in memory. Sinks may be layered
- * to transform received data, such as to compress, encrypt, throttle, or add
- * protocol framing.
- *
- * <p>Most application code shouldn't operate on a sink directly, but rather
- * {@link BufferedSink} which is both more efficient and more convenient. Use
- * {@link Okio#buffer(Sink)} to wrap any sink with a buffer.
- *
- * <p>Sinks are easy to test: just use an {@link OkBuffer} in your tests, and
- * read from it to confirm it received the data that was expected.
- *
- * <h3>Comparison with OutputStream</h3>
- * This interface is functionally equivalent to {@link java.io.OutputStream}.
- *
- * <p>{@code OutputStream} requires multiple layers when emitted data is
- * heterogeneous: a {@code DataOutputStream} for primitive values, a {@code
- * BufferedOutputStream} for buffering, and {@code OutputStreamWriter} for
- * charset encoding. This class uses {@code BufferedSink} for all of the above.
- *
- * <p>Sink is also easier to layer: there is no {@link
- * java.io.OutputStream#write(int) single-byte write} method that is awkward to
- * implement efficiently.
- *
- * <h3>Interop with OutputStream</h3>
- * Use {@link Okio#sink} to adapt an {@code OutputStream} to a sink. Use {@link
- * BufferedSink#outputStream} to adapt a sink to an {@code OutputStream}.
- */
-public interface Sink extends Closeable {
-  /** Removes {@code byteCount} bytes from {@code source} and appends them to this. */
-  void write(OkBuffer source, long byteCount) throws IOException;
-
-  /** Pushes all buffered bytes to their final destination. */
-  void flush() throws IOException;
-
-  /**
-   * Sets the deadline for all operations on this sink.
-   * @return this sink.
-   */
-  Sink deadline(Deadline deadline);
-
-  /**
-   * Pushes all buffered bytes to their final destination and releases the
-   * resources held by this sink. It is an error to write a closed sink. It is
-   * safe to close a sink more than once.
-   */
-  @Override void close() throws IOException;
-}
diff --git a/okio/src/main/java/okio/Source.java b/okio/src/main/java/okio/Source.java
deleted file mode 100644
index d402beed39..0000000000
--- a/okio/src/main/java/okio/Source.java
+++ /dev/null
@@ -1,81 +0,0 @@
-/*
- * Copyright (C) 2014 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okio;
-
-import java.io.Closeable;
-import java.io.IOException;
-
-/**
- * Supplies a stream of bytes. Use this interface to read data from wherever
- * it's located: from the network, storage, or a buffer in memory. Sources may
- * be layered to transform supplied data, such as to decompress, decrypt, or
- * remove protocol framing.
- *
- * <p>Most applications shouldn't operate on a source directly, but rather
- * {@link BufferedSource} which is both more efficient and more convenient. Use
- * {@link Okio#buffer(Source)} to wrap any source with a buffer.
- *
- * <p>Sources are easy to test: just use an {@link OkBuffer} in your tests, and
- * fill it with the data your application is to read.
- *
- * <h3>Comparison with InputStream</h3>
- * This interface is functionally equivalent to {@link java.io.InputStream}.
- *
- * <p>{@code InputStream} requires multiple layers when consumed data is
- * heterogeneous: a {@code DataOutputStream} for primitive values, a {@code
- * BufferedInputStream} for buffering, and {@code InputStreamReader} for
- * strings. This class uses {@code BufferedSource} for all of the above.
- *
- * <p>Source avoids the impossible-to-implement {@link
- * java.io.InputStream#available available()} method. Instead callers specify
- * how many bytes they {@link BufferedSource#require require}.
- *
- * <p>Source omits the unsafe-to-compose {@link java.io.InputStream#mark mark
- * and reset} state that's tracked by {@code InputStream}; callers instead just
- * buffer what they need.
- *
- * <p>When implementing a source, you need not worry about the {@link
- * java.io.InputStream#read single-byte read} method that is awkward to
- * implement efficiently and that returns one of 257 possible values.
- *
- * <p>And source has a stronger {@code skip} method: {@link BufferedSource#skip}
- * won't return prematurely.
- *
- * <h3>Interop with InputStream</h3>
- * Use {@link Okio#source} to adapt an {@code InputStream} to a source. Use
- * {@link BufferedSource#inputStream} to adapt a source to an {@code
- * InputStream}.
- */
-public interface Source extends Closeable {
-  /**
-   * Removes at least 1, and up to {@code byteCount} bytes from this and appends
-   * them to {@code sink}. Returns the number of bytes read, or -1 if this
-   * source is exhausted.
-   */
-  long read(OkBuffer sink, long byteCount) throws IOException;
-
-  /**
-   * Sets the deadline for all operations on this source.
-   * @return this source.
-   */
-  Source deadline(Deadline deadline);
-
-  /**
-   * Closes this source and releases the resources held by this source. It is an
-   * error to read a closed source. It is safe to close a source more than once.
-   */
-  @Override void close() throws IOException;
-}
diff --git a/okio/src/main/java/okio/Util.java b/okio/src/main/java/okio/Util.java
deleted file mode 100644
index 4759488657..0000000000
--- a/okio/src/main/java/okio/Util.java
+++ /dev/null
@@ -1,71 +0,0 @@
-/*
- * Copyright (C) 2014 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okio;
-
-import java.nio.charset.Charset;
-
-final class Util {
-  /** A cheap and type-safe constant for the UTF-8 Charset. */
-  public static final Charset UTF_8 = Charset.forName("UTF-8");
-
-  private Util() {
-  }
-
-  public static void checkOffsetAndCount(long arrayLength, long offset, long count) {
-    if ((offset | count) < 0 || offset > arrayLength || arrayLength - offset < count) {
-      throw new ArrayIndexOutOfBoundsException();
-    }
-  }
-
-  public static short reverseBytesShort(short s) {
-    int i = s & 0xffff;
-    int reversed = (i & 0xff00) >>> 8
-        |          (i & 0x00ff)  << 8;
-    return (short) reversed;
-  }
-
-  public static int reverseBytesInt(int i) {
-    return (i & 0xff000000) >>> 24
-        |  (i & 0x00ff0000) >>>  8
-        |  (i & 0x0000ff00)  <<  8
-        |  (i & 0x000000ff)  << 24;
-  }
-
-  public static long reverseBytesLong(long v) {
-    return (v & 0xff00000000000000L) >>> 56
-        |  (v & 0x00ff000000000000L) >>> 40
-        |  (v & 0x0000ff0000000000L) >>> 24
-        |  (v & 0x000000ff00000000L) >>>  8
-        |  (v & 0x00000000ff000000L)  <<  8
-        |  (v & 0x0000000000ff0000L)  << 24
-        |  (v & 0x000000000000ff00L)  << 40
-        |  (v & 0x00000000000000ffL)  << 56;
-  }
-
-  /**
-   * Throws {@code t}, even if the declared throws clause doesn't permit it.
-   * This is a terrible – but terribly convenient – hack that makes it easy to
-   * catch and rethrow exceptions after cleanup. See Java Puzzlers #43.
-   */
-  public static void sneakyRethrow(Throwable t) {
-    Util.<Error>sneakyThrow2(t);
-  }
-
-  @SuppressWarnings("unchecked")
-  private static <T extends Throwable> void sneakyThrow2(Throwable t) throws T {
-    throw (T) t;
-  }
-}
diff --git a/okio/src/test/java/okio/ByteStringTest.java b/okio/src/test/java/okio/ByteStringTest.java
deleted file mode 100644
index 16b8e2d518..0000000000
--- a/okio/src/test/java/okio/ByteStringTest.java
+++ /dev/null
@@ -1,182 +0,0 @@
-/*
- * Copyright 2014 Square Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okio;
-
-import java.io.ByteArrayInputStream;
-import java.io.ByteArrayOutputStream;
-import java.io.InputStream;
-import java.util.Arrays;
-import org.junit.Test;
-
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertFalse;
-import static org.junit.Assert.assertSame;
-import static org.junit.Assert.assertTrue;
-import static org.junit.Assert.fail;
-
-public class ByteStringTest {
-
-  @Test public void getByte() throws Exception {
-    ByteString byteString = ByteString.decodeHex("ab12");
-    assertEquals(-85, byteString.getByte(0));
-    assertEquals(18, byteString.getByte(1));
-  }
-
-  @Test public void getByteOutOfBounds() throws Exception {
-    ByteString byteString = ByteString.decodeHex("ab12");
-    try {
-      byteString.getByte(2);
-      fail();
-    } catch (IndexOutOfBoundsException expected) {
-    }
-  }
-
-  @Test public void equals() throws Exception {
-    ByteString byteString = ByteString.decodeHex("000102");
-    assertTrue(byteString.equals(byteString));
-    assertTrue(byteString.equals(ByteString.decodeHex("000102")));
-    assertTrue(ByteString.of().equals(ByteString.EMPTY));
-    assertTrue(ByteString.EMPTY.equals(ByteString.of()));
-    assertFalse(byteString.equals(new Object()));
-    assertFalse(byteString.equals(ByteString.decodeHex("000201")));
-  }
-
-  private final String bronzeHorseman = "На берегу пустынных волн";
-
-  @Test public void utf8() throws Exception {
-    ByteString byteString = ByteString.encodeUtf8(bronzeHorseman);
-    assertByteArraysEquals(byteString.toByteArray(), bronzeHorseman.getBytes(Util.UTF_8));
-    assertTrue(byteString.equals(ByteString.of(bronzeHorseman.getBytes(Util.UTF_8))));
-    assertEquals(byteString.utf8(), bronzeHorseman);
-  }
-
-  @Test public void testHashCode() throws Exception {
-    ByteString byteString = ByteString.decodeHex("0102");
-    assertEquals(byteString.hashCode(), byteString.hashCode());
-    assertEquals(byteString.hashCode(), ByteString.decodeHex("0102").hashCode());
-  }
-
-  @Test public void read() throws Exception {
-    InputStream in = new ByteArrayInputStream("abc".getBytes(Util.UTF_8));
-    assertEquals(ByteString.decodeHex("6162"), ByteString.read(in, 2));
-    assertEquals(ByteString.decodeHex("63"), ByteString.read(in, 1));
-    assertEquals(ByteString.of(), ByteString.read(in, 0));
-  }
-
-  @Test public void readLowerCase() throws Exception {
-    InputStream in = new ByteArrayInputStream("ABC".getBytes(Util.UTF_8));
-    assertEquals(ByteString.encodeUtf8("ab"), ByteString.read(in, 2).toAsciiLowercase());
-    assertEquals(ByteString.encodeUtf8("c"), ByteString.read(in, 1).toAsciiLowercase());
-    assertEquals(ByteString.EMPTY, ByteString.read(in, 0).toAsciiLowercase());
-  }
-
-  @Test public void toAsciiLowerCaseNoUppercase() throws Exception {
-    ByteString s = ByteString.encodeUtf8("a1_+");
-    assertSame(s, s.toAsciiLowercase());
-  }
-
-  @Test public void toAsciiAllUppercase() throws Exception {
-    assertEquals(ByteString.encodeUtf8("ab"), ByteString.encodeUtf8("AB").toAsciiLowercase());
-  }
-
-  @Test public void toAsciiStartsLowercaseEndsUppercase() throws Exception {
-    assertEquals(ByteString.encodeUtf8("abcd"), ByteString.encodeUtf8("abCD").toAsciiLowercase());
-  }
-
-  @Test public void write() throws Exception {
-    ByteArrayOutputStream out = new ByteArrayOutputStream();
-    ByteString.decodeHex("616263").write(out);
-    assertByteArraysEquals(new byte[] { 0x61, 0x62, 0x63 }, out.toByteArray());
-  }
-
-  @Test public void encodeBase64() {
-    assertEquals("", ByteString.encodeUtf8("").base64());
-    assertEquals("AA==", ByteString.encodeUtf8("\u0000").base64());
-    assertEquals("AAA=", ByteString.encodeUtf8("\u0000\u0000").base64());
-    assertEquals("AAAA", ByteString.encodeUtf8("\u0000\u0000\u0000").base64());
-    assertEquals("V2UncmUgZ29ubmEgbWFrZSBhIGZvcnR1bmUgd2l0aCB0aGlzIHBsYWNlLg==",
-        ByteString.encodeUtf8("We're gonna make a fortune with this place.").base64());
-  }
-
-  @Test public void ignoreUnnecessaryPadding() {
-    assertEquals("", ByteString.decodeBase64("====").utf8());
-    assertEquals("\u0000\u0000\u0000", ByteString.decodeBase64("AAAA====").utf8());
-  }
-
-  @Test public void decodeBase64() {
-    assertEquals("", ByteString.decodeBase64("").utf8());
-    assertEquals(null, ByteString.decodeBase64("/===")); // Can't do anything with 6 bits!
-    assertEquals(ByteString.decodeHex("ff"), ByteString.decodeBase64("//=="));
-    assertEquals(ByteString.decodeHex("ffff"), ByteString.decodeBase64("///="));
-    assertEquals(ByteString.decodeHex("ffffff"), ByteString.decodeBase64("////"));
-    assertEquals(ByteString.decodeHex("ffffffffffff"), ByteString.decodeBase64("////////"));
-    assertEquals("What's to be scared about? It's just a little hiccup in the power...",
-        ByteString.decodeBase64("V2hhdCdzIHRvIGJlIHNjYXJlZCBhYm91dD8gSXQncyBqdXN0IGEgbGl0dGxlIGhpY2"
-            + "N1cCBpbiB0aGUgcG93ZXIuLi4=").utf8());
-  }
-
-  @Test public void decodeBase64WithWhitespace() {
-    assertEquals("\u0000\u0000\u0000", ByteString.decodeBase64(" AA AA ").utf8());
-    assertEquals("\u0000\u0000\u0000", ByteString.decodeBase64(" AA A\r\nA ").utf8());
-    assertEquals("\u0000\u0000\u0000", ByteString.decodeBase64("AA AA").utf8());
-    assertEquals("\u0000\u0000\u0000", ByteString.decodeBase64(" AA AA ").utf8());
-    assertEquals("\u0000\u0000\u0000", ByteString.decodeBase64(" AA A\r\nA ").utf8());
-    assertEquals("\u0000\u0000\u0000", ByteString.decodeBase64("A    AAA").utf8());
-    assertEquals("", ByteString.decodeBase64("    ").utf8());
-  }
-
-  @Test public void encodeHex() throws Exception {
-    assertEquals("000102", ByteString.of((byte) 0x0, (byte) 0x1, (byte) 0x2).hex());
-  }
-
-  @Test public void decodeHex() throws Exception {
-    assertEquals(ByteString.of((byte) 0x0, (byte) 0x1, (byte) 0x2), ByteString.decodeHex("000102"));
-  }
-
-  @Test public void decodeHexOddNumberOfChars() throws Exception {
-    try {
-      ByteString.decodeHex("aaa");
-      fail();
-    } catch (IllegalArgumentException expected) {
-    }
-  }
-
-  @Test public void decodeHexInvalidChar() throws Exception {
-    try {
-      ByteString.decodeHex("a\u0000");
-      fail();
-    } catch (IllegalArgumentException expected) {
-    }
-  }
-
-  @Test public void toStringOnEmptyByteString() {
-    assertEquals("ByteString[size=0]", ByteString.of().toString());
-  }
-
-  @Test public void toStringOnSmallByteStringIncludesContents() {
-    assertEquals("ByteString[size=16 data=a1b2c3d4e5f61a2b3c4d5e6f10203040]",
-        ByteString.decodeHex("a1b2c3d4e5f61a2b3c4d5e6f10203040").toString());
-  }
-
-  @Test public void toStringOnLargeByteStringIncludesMd5() {
-    assertEquals("ByteString[size=17 md5=2c9728a2138b2f25e9f89f99bdccf8db]",
-        ByteString.encodeUtf8("12345678901234567").toString());
-  }
-
-  private static void assertByteArraysEquals(byte[] a, byte[] b) {
-    assertEquals(Arrays.toString(a), Arrays.toString(b));
-  }
-}
diff --git a/okio/src/test/java/okio/DeflaterSinkTest.java b/okio/src/test/java/okio/DeflaterSinkTest.java
deleted file mode 100644
index 025215b063..0000000000
--- a/okio/src/test/java/okio/DeflaterSinkTest.java
+++ /dev/null
@@ -1,107 +0,0 @@
-/*
- * Copyright (C) 2014 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okio;
-
-import java.io.IOException;
-import java.io.InputStream;
-import java.util.Arrays;
-import java.util.Random;
-import java.util.zip.Deflater;
-import java.util.zip.Inflater;
-import java.util.zip.InflaterInputStream;
-import org.junit.Test;
-
-import static org.junit.Assert.assertEquals;
-
-public final class DeflaterSinkTest {
-  @Test public void deflateWithClose() throws Exception {
-    OkBuffer data = new OkBuffer();
-    String original = "They're moving in herds. They do move in herds.";
-    data.writeUtf8(original);
-    OkBuffer sink = new OkBuffer();
-    DeflaterSink deflaterSink = new DeflaterSink(sink, new Deflater());
-    deflaterSink.write(data, data.size());
-    deflaterSink.close();
-    OkBuffer inflated = inflate(sink);
-    assertEquals(original, inflated.readUtf8(inflated.size()));
-  }
-
-  @Test public void deflateWithSyncFlush() throws Exception {
-    String original = "Yes, yes, yes. That's why we're taking extreme precautions.";
-    OkBuffer data = new OkBuffer();
-    data.writeUtf8(original);
-    OkBuffer sink = new OkBuffer();
-    DeflaterSink deflaterSink = new DeflaterSink(sink, new Deflater());
-    deflaterSink.write(data, data.size());
-    deflaterSink.flush();
-    OkBuffer inflated = inflate(sink);
-    assertEquals(original, inflated.readUtf8(inflated.size()));
-  }
-
-  @Test public void deflateWellCompressed() throws IOException {
-    String original = repeat('a', 1024 * 1024);
-    OkBuffer data = new OkBuffer();
-    data.writeUtf8(original);
-    OkBuffer sink = new OkBuffer();
-    DeflaterSink deflaterSink = new DeflaterSink(sink, new Deflater());
-    deflaterSink.write(data, data.size());
-    deflaterSink.close();
-    OkBuffer inflated = inflate(sink);
-    assertEquals(original, inflated.readUtf8(inflated.size()));
-  }
-
-  @Test public void deflatePoorlyCompressed() throws IOException {
-    ByteString original = randomBytes(1024 * 1024);
-    OkBuffer data = new OkBuffer();
-    data.write(original);
-    OkBuffer sink = new OkBuffer();
-    DeflaterSink deflaterSink = new DeflaterSink(sink, new Deflater());
-    deflaterSink.write(data, data.size());
-    deflaterSink.close();
-    OkBuffer inflated = inflate(sink);
-    assertEquals(original, inflated.readByteString(inflated.size()));
-  }
-
-  /**
-   * Uses streaming decompression to inflate {@code deflated}. The input must
-   * either be finished or have a trailing sync flush.
-   */
-  private OkBuffer inflate(OkBuffer deflated) throws IOException {
-    InputStream deflatedIn = deflated.inputStream();
-    Inflater inflater = new Inflater();
-    InputStream inflatedIn = new InflaterInputStream(deflatedIn, inflater);
-    OkBuffer result = new OkBuffer();
-    byte[] buffer = new byte[8192];
-    while (!inflater.needsInput() || deflated.size() > 0 || deflatedIn.available() > 0) {
-      int count = inflatedIn.read(buffer, 0, buffer.length);
-      result.write(buffer, 0, count);
-    }
-    return result;
-  }
-
-  private ByteString randomBytes(int length) {
-    Random random = new Random(0);
-    byte[] randomBytes = new byte[length];
-    random.nextBytes(randomBytes);
-    return ByteString.of(randomBytes);
-  }
-
-  private String repeat(char c, int count) {
-    char[] array = new char[count];
-    Arrays.fill(array, c);
-    return new String(array);
-  }
-}
diff --git a/okio/src/test/java/okio/GzipSourceTest.java b/okio/src/test/java/okio/GzipSourceTest.java
deleted file mode 100644
index f14b99963c..0000000000
--- a/okio/src/test/java/okio/GzipSourceTest.java
+++ /dev/null
@@ -1,234 +0,0 @@
-/*
- * Copyright (C) 2014 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okio;
-
-import java.io.IOException;
-import java.util.zip.CRC32;
-import org.junit.Test;
-
-import static okio.Util.UTF_8;
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertFalse;
-import static org.junit.Assert.assertTrue;
-import static org.junit.Assert.fail;
-
-public class GzipSourceTest {
-
-  @Test public void gunzip() throws Exception {
-    OkBuffer gzipped = new OkBuffer();
-    gzipped.write(gzipHeader);
-    gzipped.write(deflated);
-    gzipped.write(gzipTrailer);
-    assertGzipped(gzipped);
-  }
-
-  @Test public void gunzip_withHCRC() throws Exception {
-    CRC32 hcrc = new CRC32();
-    ByteString gzipHeader = gzipHeaderWithFlags((byte) 0x02);
-    hcrc.update(gzipHeader.toByteArray());
-
-    OkBuffer gzipped = new OkBuffer();
-    gzipped.write(gzipHeader);
-    gzipped.writeShort(Util.reverseBytesShort((short) hcrc.getValue())); // little endian
-    gzipped.write(deflated);
-    gzipped.write(gzipTrailer);
-    assertGzipped(gzipped);
-  }
-
-  @Test public void gunzip_withExtra() throws Exception {
-    OkBuffer gzipped = new OkBuffer();
-    gzipped.write(gzipHeaderWithFlags((byte) 0x04));
-    gzipped.writeShort(Util.reverseBytesShort((short) 7)); // little endian extra length
-    gzipped.write("blubber".getBytes(UTF_8), 0, 7);
-    gzipped.write(deflated);
-    gzipped.write(gzipTrailer);
-    assertGzipped(gzipped);
-  }
-
-  @Test public void gunzip_withName() throws Exception {
-    OkBuffer gzipped = new OkBuffer();
-    gzipped.write(gzipHeaderWithFlags((byte) 0x08));
-    gzipped.write("foo.txt".getBytes(UTF_8), 0, 7);
-    gzipped.writeByte(0); // zero-terminated
-    gzipped.write(deflated);
-    gzipped.write(gzipTrailer);
-    assertGzipped(gzipped);
-  }
-
-  @Test public void gunzip_withComment() throws Exception {
-    OkBuffer gzipped = new OkBuffer();
-    gzipped.write(gzipHeaderWithFlags((byte) 0x10));
-    gzipped.write("rubbish".getBytes(UTF_8), 0, 7);
-    gzipped.writeByte(0); // zero-terminated
-    gzipped.write(deflated);
-    gzipped.write(gzipTrailer);
-    assertGzipped(gzipped);
-  }
-
-  /**
-   * For portability, it is a good idea to export the gzipped bytes and try running gzip.  Ex.
-   * {@code echo gzipped | base64 --decode | gzip -l -v}
-   */
-  @Test public void gunzip_withAll() throws Exception {
-    OkBuffer gzipped = new OkBuffer();
-    gzipped.write(gzipHeaderWithFlags((byte) 0x1c));
-    gzipped.writeShort(Util.reverseBytesShort((short) 7)); // little endian extra length
-    gzipped.write("blubber".getBytes(UTF_8), 0, 7);
-    gzipped.write("foo.txt".getBytes(UTF_8), 0, 7);
-    gzipped.writeByte(0); // zero-terminated
-    gzipped.write("rubbish".getBytes(UTF_8), 0, 7);
-    gzipped.writeByte(0); // zero-terminated
-    gzipped.write(deflated);
-    gzipped.write(gzipTrailer);
-    assertGzipped(gzipped);
-  }
-
-  private void assertGzipped(OkBuffer gzipped) throws IOException {
-    OkBuffer gunzipped = gunzip(gzipped);
-    assertEquals("It's a UNIX system! I know this!", gunzipped.readUtf8(gunzipped.size()));
-  }
-
-  /**
-   * Note that you cannot test this with old versions of gzip, as they interpret flag bit 1 as
-   * CONTINUATION, not HCRC. For example, this is the case with the default gzip on osx.
-   */
-  @Test public void gunzipWhenHeaderCRCIncorrect() throws Exception {
-    OkBuffer gzipped = new OkBuffer();
-    gzipped.write(gzipHeaderWithFlags((byte) 0x02));
-    gzipped.writeShort((short) 0); // wrong HCRC!
-    gzipped.write(deflated);
-    gzipped.write(gzipTrailer);
-
-    try {
-      gunzip(gzipped);
-      fail();
-    } catch (IOException e) {
-      assertEquals("FHCRC: actual 0x0000261d != expected 0x00000000", e.getMessage());
-    }
-  }
-
-  @Test public void gunzipWhenCRCIncorrect() throws Exception {
-    OkBuffer gzipped = new OkBuffer();
-    gzipped.write(gzipHeader);
-    gzipped.write(deflated);
-    gzipped.writeInt(Util.reverseBytesInt(0x1234567)); // wrong CRC
-    gzipped.write(gzipTrailer.toByteArray(), 3, 4);
-
-    try {
-      gunzip(gzipped);
-      fail();
-    } catch (IOException e) {
-      assertEquals("CRC: actual 0x37ad8f8d != expected 0x01234567", e.getMessage());
-    }
-  }
-
-  @Test public void gunzipWhenLengthIncorrect() throws Exception {
-    OkBuffer gzipped = new OkBuffer();
-    gzipped.write(gzipHeader);
-    gzipped.write(deflated);
-    gzipped.write(gzipTrailer.toByteArray(), 0, 4);
-    gzipped.writeInt(Util.reverseBytesInt(0x123456)); // wrong length
-
-    try {
-      gunzip(gzipped);
-      fail();
-    } catch (IOException e) {
-      assertEquals("ISIZE: actual 0x00000020 != expected 0x00123456", e.getMessage());
-    }
-  }
-
-  @Test public void gunzipExhaustsSource() throws Exception {
-    OkBuffer gzippedSource = new OkBuffer()
-        .write(ByteString.decodeHex("1f8b08000000000000004b4c4a0600c241243503000000")); // 'abc'
-
-    ExhaustableSource exhaustableSource = new ExhaustableSource(gzippedSource);
-    BufferedSource gunzippedSource = Okio.buffer(new GzipSource(exhaustableSource));
-
-    assertEquals('a', gunzippedSource.readByte());
-    assertEquals('b', gunzippedSource.readByte());
-    assertEquals('c', gunzippedSource.readByte());
-    assertFalse(exhaustableSource.exhausted);
-    assertEquals(-1, gunzippedSource.read(new OkBuffer(), 1));
-    assertTrue(exhaustableSource.exhausted);
-  }
-
-  @Test public void gunzipThrowsIfSourceIsNotExhausted() throws Exception {
-    OkBuffer gzippedSource = new OkBuffer()
-        .write(ByteString.decodeHex("1f8b08000000000000004b4c4a0600c241243503000000")); // 'abc'
-    gzippedSource.writeByte('d'); // This byte shouldn't be here!
-
-    BufferedSource gunzippedSource = Okio.buffer(new GzipSource(gzippedSource));
-
-    assertEquals('a', gunzippedSource.readByte());
-    assertEquals('b', gunzippedSource.readByte());
-    assertEquals('c', gunzippedSource.readByte());
-    try {
-      gunzippedSource.readByte();
-      fail();
-    } catch (IOException expected) {
-    }
-  }
-
-  private ByteString gzipHeaderWithFlags(byte flags) {
-    byte[] result = gzipHeader.toByteArray();
-    result[3] = flags;
-    return ByteString.of(result);
-  }
-
-  private final ByteString gzipHeader = ByteString.decodeHex("1f8b0800000000000000");
-
-  // Deflated "It's a UNIX system! I know this!"
-  private final ByteString deflated = ByteString.decodeHex(
-      "f32c512f56485408f5f38c5028ae2c2e49cd5554f054c8cecb2f5728c9c82c560400");
-
-  private final ByteString gzipTrailer = ByteString.decodeHex(""
-      + "8d8fad37" // Checksum of deflated.
-      + "20000000" // 32 in little endian.
-  );
-
-  private OkBuffer gunzip(OkBuffer gzipped) throws IOException {
-    OkBuffer result = new OkBuffer();
-    GzipSource source = new GzipSource(gzipped);
-    while (source.read(result, Integer.MAX_VALUE) != -1) {
-    }
-    return result;
-  }
-
-  /** This source keeps track of whether its read have returned -1. */
-  static class ExhaustableSource implements Source {
-    private final Source source;
-    private boolean exhausted;
-
-    ExhaustableSource(Source source) {
-      this.source = source;
-    }
-
-    @Override public long read(OkBuffer sink, long byteCount) throws IOException {
-      long result = source.read(sink, byteCount);
-      if (result == -1) exhausted = true;
-      return result;
-    }
-
-    @Override public Source deadline(Deadline deadline) {
-      source.deadline(deadline);
-      return this;
-    }
-
-    @Override public void close() throws IOException {
-      source.close();
-    }
-  }
-}
diff --git a/okio/src/test/java/okio/InflaterSourceTest.java b/okio/src/test/java/okio/InflaterSourceTest.java
deleted file mode 100644
index e6f2bc6536..0000000000
--- a/okio/src/test/java/okio/InflaterSourceTest.java
+++ /dev/null
@@ -1,115 +0,0 @@
-/*
- * Copyright (C) 2014 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okio;
-
-import java.io.EOFException;
-import java.io.IOException;
-import java.util.Arrays;
-import java.util.Random;
-import java.util.zip.DeflaterOutputStream;
-import java.util.zip.Inflater;
-import org.junit.Test;
-
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.fail;
-
-public final class InflaterSourceTest {
-  @Test public void inflate() throws Exception {
-    OkBuffer deflated = decodeBase64("eJxzz09RyEjNKVAoLdZRKE9VL0pVyMxTKMlIVchIzEspVshPU0jNS8/MS00tK"
-        + "tYDAF6CD5s=");
-    OkBuffer inflated = inflate(deflated);
-    assertEquals("God help us, we're in the hands of engineers.", readUtf8(inflated));
-  }
-
-  @Test public void inflateTruncated() throws Exception {
-    OkBuffer deflated = decodeBase64("eJxzz09RyEjNKVAoLdZRKE9VL0pVyMxTKMlIVchIzEspVshPU0jNS8/MS00tK"
-        + "tYDAF6CDw==");
-    try {
-      inflate(deflated);
-      fail();
-    } catch (EOFException expected) {
-    }
-  }
-
-  @Test public void inflateWellCompressed() throws Exception {
-    OkBuffer deflated = decodeBase64("eJztwTEBAAAAwqCs61/CEL5AAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
-        + "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
-        + "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
-        + "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
-        + "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
-        + "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
-        + "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
-        + "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
-        + "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
-        + "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
-        + "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
-        + "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
-        + "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
-        + "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
-        + "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
-        + "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAB8B"
-        + "tFeWvE=\n");
-    String original = repeat('a', 1024 * 1024);
-    OkBuffer inflated = inflate(deflated);
-    assertEquals(original, readUtf8(inflated));
-  }
-
-  @Test public void inflatePoorlyCompressed() throws Exception {
-    ByteString original = randomBytes(1024 * 1024);
-    OkBuffer deflated = deflate(original);
-    OkBuffer inflated = inflate(deflated);
-    assertEquals(original, inflated.readByteString(inflated.size()));
-  }
-
-  private OkBuffer decodeBase64(String s) {
-    return new OkBuffer().write(ByteString.decodeBase64(s));
-  }
-
-  private String readUtf8(OkBuffer buffer) {
-    return buffer.readUtf8(buffer.size());
-  }
-
-  /** Use DeflaterOutputStream to deflate source. */
-  private OkBuffer deflate(ByteString source) throws IOException {
-    OkBuffer result = new OkBuffer();
-    Sink sink = Okio.sink(new DeflaterOutputStream(result.outputStream()));
-    sink.write(new OkBuffer().write(source), source.size());
-    sink.close();
-    return result;
-  }
-
-  /** Returns a new buffer containing the inflated contents of {@code deflated}. */
-  private OkBuffer inflate(OkBuffer deflated) throws IOException {
-    OkBuffer result = new OkBuffer();
-    InflaterSource source = new InflaterSource(deflated, new Inflater());
-    while (source.read(result, Integer.MAX_VALUE) != -1) {
-    }
-    return result;
-  }
-
-  private ByteString randomBytes(int length) {
-    Random random = new Random(0);
-    byte[] randomBytes = new byte[length];
-    random.nextBytes(randomBytes);
-    return ByteString.of(randomBytes);
-  }
-
-  private String repeat(char c, int count) {
-    char[] array = new char[count];
-    Arrays.fill(array, c);
-    return new String(array);
-  }
-}
diff --git a/okio/src/test/java/okio/OkBufferTest.java b/okio/src/test/java/okio/OkBufferTest.java
deleted file mode 100644
index f69613a182..0000000000
--- a/okio/src/test/java/okio/OkBufferTest.java
+++ /dev/null
@@ -1,682 +0,0 @@
-/*
- * Copyright (C) 2014 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okio;
-
-import java.util.Arrays;
-import java.util.List;
-import java.util.Random;
-import org.junit.Test;
-
-import static java.util.Arrays.asList;
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertFalse;
-import static org.junit.Assert.assertTrue;
-import static org.junit.Assert.fail;
-
-public final class OkBufferTest {
-  @Test public void readAndWriteUtf8() throws Exception {
-    OkBuffer buffer = new OkBuffer();
-    buffer.writeUtf8("ab");
-    assertEquals(2, buffer.size());
-    buffer.writeUtf8("cdef");
-    assertEquals(6, buffer.size());
-    assertEquals("abcd", buffer.readUtf8(4));
-    assertEquals(2, buffer.size());
-    assertEquals("ef", buffer.readUtf8(2));
-    assertEquals(0, buffer.size());
-    try {
-      buffer.readUtf8(1);
-      fail();
-    } catch (ArrayIndexOutOfBoundsException expected) {
-    }
-  }
-
-  @Test public void completeSegmentByteCountOnEmptyBuffer() throws Exception {
-    OkBuffer buffer = new OkBuffer();
-    assertEquals(0, buffer.completeSegmentByteCount());
-  }
-
-  @Test public void completeSegmentByteCountOnBufferWithFullSegments() throws Exception {
-    OkBuffer buffer = new OkBuffer();
-    buffer.writeUtf8(repeat('a', Segment.SIZE * 4));
-    assertEquals(Segment.SIZE * 4, buffer.completeSegmentByteCount());
-  }
-
-  @Test public void completeSegmentByteCountOnBufferWithIncompleteTailSegment() throws Exception {
-    OkBuffer buffer = new OkBuffer();
-    buffer.writeUtf8(repeat('a', Segment.SIZE * 4 - 10));
-    assertEquals(Segment.SIZE * 3, buffer.completeSegmentByteCount());
-  }
-
-  @Test public void readUtf8SpansSegments() throws Exception {
-    OkBuffer buffer = new OkBuffer();
-    buffer.writeUtf8(repeat('a', Segment.SIZE * 2));
-    buffer.readUtf8(Segment.SIZE - 1);
-    assertEquals("aa", buffer.readUtf8(2));
-  }
-
-  @Test public void readUtf8EntireBuffer() throws Exception {
-    OkBuffer buffer = new OkBuffer();
-    buffer.writeUtf8(repeat('a', Segment.SIZE));
-    assertEquals(repeat('a', Segment.SIZE), buffer.readUtf8(Segment.SIZE));
-  }
-
-  @Test public void toStringOnEmptyBuffer() throws Exception {
-    OkBuffer buffer = new OkBuffer();
-    assertEquals("OkBuffer[size=0]", buffer.toString());
-  }
-
-  @Test public void toStringOnSmallBufferIncludesContents() throws Exception {
-    OkBuffer buffer = new OkBuffer();
-    buffer.write(ByteString.decodeHex("a1b2c3d4e5f61a2b3c4d5e6f10203040"));
-    assertEquals("OkBuffer[size=16 data=a1b2c3d4e5f61a2b3c4d5e6f10203040]", buffer.toString());
-  }
-
-  @Test public void toStringOnLargeBufferIncludesMd5() throws Exception {
-    OkBuffer buffer = new OkBuffer();
-    buffer.write(ByteString.encodeUtf8("12345678901234567"));
-    assertEquals("OkBuffer[size=17 md5=2c9728a2138b2f25e9f89f99bdccf8db]", buffer.toString());
-  }
-
-  @Test public void toStringOnMultipleSegmentBuffer() throws Exception {
-    OkBuffer buffer = new OkBuffer();
-    buffer.writeUtf8(repeat('a', 6144));
-    assertEquals("OkBuffer[size=6144 md5=d890021f28522533c1cc1b9b1f83ce73]", buffer.toString());
-  }
-
-  @Test public void multipleSegmentBuffers() throws Exception {
-    OkBuffer buffer = new OkBuffer();
-    buffer.writeUtf8(repeat('a',  1000));
-    buffer.writeUtf8(repeat('b', 2500));
-    buffer.writeUtf8(repeat('c', 5000));
-    buffer.writeUtf8(repeat('d', 10000));
-    buffer.writeUtf8(repeat('e', 25000));
-    buffer.writeUtf8(repeat('f', 50000));
-
-    assertEquals(repeat('a', 999), buffer.readUtf8(999)); // a...a
-    assertEquals("a" + repeat('b', 2500) + "c", buffer.readUtf8(2502)); // ab...bc
-    assertEquals(repeat('c', 4998), buffer.readUtf8(4998)); // c...c
-    assertEquals("c" + repeat('d', 10000) + "e", buffer.readUtf8(10002)); // cd...de
-    assertEquals(repeat('e', 24998), buffer.readUtf8(24998)); // e...e
-    assertEquals("e" + repeat('f', 50000), buffer.readUtf8(50001)); // ef...f
-    assertEquals(0, buffer.size());
-  }
-
-  @Test public void fillAndDrainPool() throws Exception {
-    OkBuffer buffer = new OkBuffer();
-
-    // Take 2 * MAX_SIZE segments. This will drain the pool, even if other tests filled it.
-    buffer.write(new byte[(int) SegmentPool.MAX_SIZE]);
-    buffer.write(new byte[(int) SegmentPool.MAX_SIZE]);
-    assertEquals(0, SegmentPool.INSTANCE.byteCount);
-
-    // Recycle MAX_SIZE segments. They're all in the pool.
-    buffer.readByteString(SegmentPool.MAX_SIZE);
-    assertEquals(SegmentPool.MAX_SIZE, SegmentPool.INSTANCE.byteCount);
-
-    // Recycle MAX_SIZE more segments. The pool is full so they get garbage collected.
-    buffer.readByteString(SegmentPool.MAX_SIZE);
-    assertEquals(SegmentPool.MAX_SIZE, SegmentPool.INSTANCE.byteCount);
-
-    // Take MAX_SIZE segments to drain the pool.
-    buffer.write(new byte[(int) SegmentPool.MAX_SIZE]);
-    assertEquals(0, SegmentPool.INSTANCE.byteCount);
-
-    // Take MAX_SIZE more segments. The pool is drained so these will need to be allocated.
-    buffer.write(new byte[(int) SegmentPool.MAX_SIZE]);
-    assertEquals(0, SegmentPool.INSTANCE.byteCount);
-  }
-
-  @Test public void moveBytesBetweenBuffersShareSegment() throws Exception {
-    int size = (Segment.SIZE / 2) - 1;
-    List<Integer> segmentSizes = moveBytesBetweenBuffers(repeat('a', size), repeat('b', size));
-    assertEquals(asList(size * 2), segmentSizes);
-  }
-
-  @Test public void moveBytesBetweenBuffersReassignSegment() throws Exception {
-    int size = (Segment.SIZE / 2) + 1;
-    List<Integer> segmentSizes = moveBytesBetweenBuffers(repeat('a', size), repeat('b', size));
-    assertEquals(asList(size, size), segmentSizes);
-  }
-
-  @Test public void moveBytesBetweenBuffersMultipleSegments() throws Exception {
-    int size = 3 * Segment.SIZE + 1;
-    List<Integer> segmentSizes = moveBytesBetweenBuffers(repeat('a', size), repeat('b', size));
-    assertEquals(asList(Segment.SIZE, Segment.SIZE, Segment.SIZE, 1,
-        Segment.SIZE, Segment.SIZE, Segment.SIZE, 1), segmentSizes);
-  }
-
-  private List<Integer> moveBytesBetweenBuffers(String... contents) {
-    StringBuilder expected = new StringBuilder();
-    OkBuffer buffer = new OkBuffer();
-    for (String s : contents) {
-      OkBuffer source = new OkBuffer();
-      source.writeUtf8(s);
-      buffer.write(source, source.size());
-      expected.append(s);
-    }
-    List<Integer> segmentSizes = buffer.segmentSizes();
-    assertEquals(expected.toString(), buffer.readUtf8(expected.length()));
-    return segmentSizes;
-  }
-
-  /** The big part of source's first segment is being moved. */
-  @Test public void writeSplitSourceBufferLeft() throws Exception {
-    int writeSize = Segment.SIZE / 2 + 1;
-
-    OkBuffer sink = new OkBuffer();
-    sink.writeUtf8(repeat('b', Segment.SIZE - 10));
-
-    OkBuffer source = new OkBuffer();
-    source.writeUtf8(repeat('a', Segment.SIZE * 2));
-    sink.write(source, writeSize);
-
-    assertEquals(asList(Segment.SIZE - 10, writeSize), sink.segmentSizes());
-    assertEquals(asList(Segment.SIZE - writeSize, Segment.SIZE), source.segmentSizes());
-  }
-
-  /** The big part of source's first segment is staying put. */
-  @Test public void writeSplitSourceBufferRight() throws Exception {
-    int writeSize = Segment.SIZE / 2 - 1;
-
-    OkBuffer sink = new OkBuffer();
-    sink.writeUtf8(repeat('b', Segment.SIZE - 10));
-
-    OkBuffer source = new OkBuffer();
-    source.writeUtf8(repeat('a', Segment.SIZE * 2));
-    sink.write(source, writeSize);
-
-    assertEquals(asList(Segment.SIZE - 10, writeSize), sink.segmentSizes());
-    assertEquals(asList(Segment.SIZE - writeSize, Segment.SIZE), source.segmentSizes());
-  }
-
-  @Test public void writePrefixDoesntSplit() throws Exception {
-    OkBuffer sink = new OkBuffer();
-    sink.writeUtf8(repeat('b', 10));
-
-    OkBuffer source = new OkBuffer();
-    source.writeUtf8(repeat('a', Segment.SIZE * 2));
-    sink.write(source, 20);
-
-    assertEquals(asList(30), sink.segmentSizes());
-    assertEquals(asList(Segment.SIZE - 20, Segment.SIZE), source.segmentSizes());
-    assertEquals(30, sink.size());
-    assertEquals(Segment.SIZE * 2 - 20, source.size());
-  }
-
-  @Test public void writePrefixDoesntSplitButRequiresCompact() throws Exception {
-    OkBuffer sink = new OkBuffer();
-    sink.writeUtf8(repeat('b', Segment.SIZE - 10)); // limit = size - 10
-    sink.readUtf8(Segment.SIZE - 20); // pos = size = 20
-
-    OkBuffer source = new OkBuffer();
-    source.writeUtf8(repeat('a', Segment.SIZE * 2));
-    sink.write(source, 20);
-
-    assertEquals(asList(30), sink.segmentSizes());
-    assertEquals(asList(Segment.SIZE - 20, Segment.SIZE), source.segmentSizes());
-    assertEquals(30, sink.size());
-    assertEquals(Segment.SIZE * 2 - 20, source.size());
-  }
-
-  @Test public void readExhaustedSource() throws Exception {
-    OkBuffer sink = new OkBuffer();
-    sink.writeUtf8(repeat('a', 10));
-
-    OkBuffer source = new OkBuffer();
-
-    assertEquals(-1, source.read(sink, 10));
-    assertEquals(10, sink.size());
-    assertEquals(0, source.size());
-  }
-
-  @Test public void readZeroBytesFromSource() throws Exception {
-    OkBuffer sink = new OkBuffer();
-    sink.writeUtf8(repeat('a', 10));
-
-    OkBuffer source = new OkBuffer();
-
-    // Either 0 or -1 is reasonable here. For consistency with Android's
-    // ByteArrayInputStream we return 0.
-    assertEquals(-1, source.read(sink, 0));
-    assertEquals(10, sink.size());
-    assertEquals(0, source.size());
-  }
-
-  @Test public void moveAllRequestedBytesWithRead() throws Exception {
-    OkBuffer sink = new OkBuffer();
-    sink.writeUtf8(repeat('a', 10));
-
-    OkBuffer source = new OkBuffer();
-    source.writeUtf8(repeat('b', 15));
-
-    assertEquals(10, source.read(sink, 10));
-    assertEquals(20, sink.size());
-    assertEquals(5, source.size());
-    assertEquals(repeat('a', 10) + repeat('b', 10), sink.readUtf8(20));
-  }
-
-  @Test public void moveFewerThanRequestedBytesWithRead() throws Exception {
-    OkBuffer sink = new OkBuffer();
-    sink.writeUtf8(repeat('a', 10));
-
-    OkBuffer source = new OkBuffer();
-    source.writeUtf8(repeat('b', 20));
-
-    assertEquals(20, source.read(sink, 25));
-    assertEquals(30, sink.size());
-    assertEquals(0, source.size());
-    assertEquals(repeat('a', 10) + repeat('b', 20), sink.readUtf8(30));
-  }
-
-  @Test public void indexOf() throws Exception {
-    OkBuffer buffer = new OkBuffer();
-
-    // The segment is empty.
-    assertEquals(-1, buffer.indexOf((byte) 'a'));
-
-    // The segment has one value.
-    buffer.writeUtf8("a"); // a
-    assertEquals(0, buffer.indexOf((byte) 'a'));
-    assertEquals(-1, buffer.indexOf((byte) 'b'));
-
-    // The segment has lots of data.
-    buffer.writeUtf8(repeat('b', Segment.SIZE - 2)); // ab...b
-    assertEquals(0, buffer.indexOf((byte) 'a'));
-    assertEquals(1, buffer.indexOf((byte) 'b'));
-    assertEquals(-1, buffer.indexOf((byte) 'c'));
-
-    // The segment doesn't start at 0, it starts at 2.
-    buffer.readUtf8(2); // b...b
-    assertEquals(-1, buffer.indexOf((byte) 'a'));
-    assertEquals(0, buffer.indexOf((byte) 'b'));
-    assertEquals(-1, buffer.indexOf((byte) 'c'));
-
-    // The segment is full.
-    buffer.writeUtf8("c"); // b...bc
-    assertEquals(-1, buffer.indexOf((byte) 'a'));
-    assertEquals(0, buffer.indexOf((byte) 'b'));
-    assertEquals(Segment.SIZE - 3, buffer.indexOf((byte) 'c'));
-
-    // The segment doesn't start at 2, it starts at 4.
-    buffer.readUtf8(2); // b...bc
-    assertEquals(-1, buffer.indexOf((byte) 'a'));
-    assertEquals(0, buffer.indexOf((byte) 'b'));
-    assertEquals(Segment.SIZE - 5, buffer.indexOf((byte) 'c'));
-
-    // Two segments.
-    buffer.writeUtf8("d"); // b...bcd, d is in the 2nd segment.
-    assertEquals(asList(Segment.SIZE - 4, 1), buffer.segmentSizes());
-    assertEquals(Segment.SIZE - 4, buffer.indexOf((byte) 'd'));
-    assertEquals(-1, buffer.indexOf((byte) 'e'));
-  }
-
-  @Test public void indexOfWithOffset() throws Exception {
-    OkBuffer buffer = new OkBuffer();
-    int halfSegment = Segment.SIZE / 2;
-    buffer.writeUtf8(repeat('a', halfSegment));
-    buffer.writeUtf8(repeat('b', halfSegment));
-    buffer.writeUtf8(repeat('c', halfSegment));
-    buffer.writeUtf8(repeat('d', halfSegment));
-    assertEquals(0, buffer.indexOf((byte) 'a', 0));
-    assertEquals(halfSegment - 1, buffer.indexOf((byte) 'a', halfSegment - 1));
-    assertEquals(halfSegment, buffer.indexOf((byte) 'b', halfSegment - 1));
-    assertEquals(halfSegment * 2, buffer.indexOf((byte) 'c', halfSegment - 1));
-    assertEquals(halfSegment * 3, buffer.indexOf((byte) 'd', halfSegment - 1));
-    assertEquals(halfSegment * 3, buffer.indexOf((byte) 'd', halfSegment * 2));
-    assertEquals(halfSegment * 3, buffer.indexOf((byte) 'd', halfSegment * 3));
-    assertEquals(halfSegment * 4 - 1, buffer.indexOf((byte) 'd', halfSegment * 4 - 1));
-  }
-
-  @Test public void writeBytes() throws Exception {
-    OkBuffer data = new OkBuffer();
-    data.writeByte(0xab);
-    data.writeByte(0xcd);
-    assertEquals("OkBuffer[size=2 data=abcd]", data.toString());
-  }
-
-  @Test public void writeLastByteInSegment() throws Exception {
-    OkBuffer data = new OkBuffer();
-    data.writeUtf8(repeat('a', Segment.SIZE - 1));
-    data.writeByte(0x20);
-    data.writeByte(0x21);
-    assertEquals(asList(Segment.SIZE, 1), data.segmentSizes());
-    assertEquals(repeat('a', Segment.SIZE - 1), data.readUtf8(Segment.SIZE - 1));
-    assertEquals("OkBuffer[size=2 data=2021]", data.toString());
-  }
-
-  @Test public void writeShort() throws Exception {
-    OkBuffer data = new OkBuffer();
-    data.writeShort(0xabcd);
-    data.writeShort(0x4321);
-    assertEquals("OkBuffer[size=4 data=abcd4321]", data.toString());
-  }
-
-  @Test public void writeShortLe() throws Exception {
-    OkBuffer data = new OkBuffer();
-    data.writeShortLe(0xabcd);
-    data.writeShortLe(0x4321);
-    assertEquals("OkBuffer[size=4 data=cdab2143]", data.toString());
-  }
-
-  @Test public void writeInt() throws Exception {
-    OkBuffer data = new OkBuffer();
-    data.writeInt(0xabcdef01);
-    data.writeInt(0x87654321);
-    assertEquals("OkBuffer[size=8 data=abcdef0187654321]", data.toString());
-  }
-
-  @Test public void writeLastIntegerInSegment() throws Exception {
-    OkBuffer data = new OkBuffer();
-    data.writeUtf8(repeat('a', Segment.SIZE - 4));
-    data.writeInt(0xabcdef01);
-    data.writeInt(0x87654321);
-    assertEquals(asList(Segment.SIZE, 4), data.segmentSizes());
-    assertEquals(repeat('a', Segment.SIZE - 4), data.readUtf8(Segment.SIZE - 4));
-    assertEquals("OkBuffer[size=8 data=abcdef0187654321]", data.toString());
-  }
-
-  @Test public void writeIntegerDoesntQuiteFitInSegment() throws Exception {
-    OkBuffer data = new OkBuffer();
-    data.writeUtf8(repeat('a', Segment.SIZE - 3));
-    data.writeInt(0xabcdef01);
-    data.writeInt(0x87654321);
-    assertEquals(asList(Segment.SIZE - 3, 8), data.segmentSizes());
-    assertEquals(repeat('a', Segment.SIZE - 3), data.readUtf8(Segment.SIZE - 3));
-    assertEquals("OkBuffer[size=8 data=abcdef0187654321]", data.toString());
-  }
-
-  @Test public void writeIntLe() throws Exception {
-    OkBuffer data = new OkBuffer();
-    data.writeIntLe(0xabcdef01);
-    data.writeIntLe(0x87654321);
-    assertEquals("OkBuffer[size=8 data=01efcdab21436587]", data.toString());
-  }
-
-  @Test public void writeLong() throws Exception {
-    OkBuffer data = new OkBuffer();
-    data.writeLong(0xabcdef0187654321L);
-    data.writeLong(0xcafebabeb0b15c00L);
-    assertEquals("OkBuffer[size=16 data=abcdef0187654321cafebabeb0b15c00]", data.toString());
-  }
-
-  @Test public void writeLongLe() throws Exception {
-    OkBuffer data = new OkBuffer();
-    data.writeLongLe(0xabcdef0187654321L);
-    data.writeLongLe(0xcafebabeb0b15c00L);
-    assertEquals("OkBuffer[size=16 data=2143658701efcdab005cb1b0bebafeca]", data.toString());
-  }
-
-  @Test public void readByte() throws Exception {
-    OkBuffer data = new OkBuffer();
-    data.write(new byte[] { (byte) 0xab, (byte) 0xcd });
-    assertEquals(0xab, data.readByte() & 0xff);
-    assertEquals(0xcd, data.readByte() & 0xff);
-    assertEquals(0, data.size());
-  }
-
-  @Test public void readShort() throws Exception {
-    OkBuffer data = new OkBuffer();
-    data.write(new byte[] {
-        (byte) 0xab, (byte) 0xcd, (byte) 0xef, (byte) 0x01
-    });
-    assertEquals((short) 0xabcd, data.readShort());
-    assertEquals((short) 0xef01, data.readShort());
-    assertEquals(0, data.size());
-  }
-
-  @Test public void readShortLe() throws Exception {
-    OkBuffer data = new OkBuffer();
-    data.write(new byte[] {
-        (byte) 0xab, (byte) 0xcd, (byte) 0xef, (byte) 0x10
-    });
-    assertEquals((short) 0xcdab, data.readShortLe());
-    assertEquals((short) 0x10ef, data.readShortLe());
-    assertEquals(0, data.size());
-  }
-
-  @Test public void readShortSplitAcrossMultipleSegments() throws Exception {
-    OkBuffer data = new OkBuffer();
-    data.writeUtf8(repeat('a', Segment.SIZE - 1));
-    data.write(new byte[] { (byte) 0xab, (byte) 0xcd });
-    data.readUtf8(Segment.SIZE - 1);
-    assertEquals((short) 0xabcd, data.readShort());
-    assertEquals(0, data.size());
-  }
-
-  @Test public void readInt() throws Exception {
-    OkBuffer data = new OkBuffer();
-    data.write(new byte[] {
-        (byte) 0xab, (byte) 0xcd, (byte) 0xef, (byte) 0x01,
-        (byte) 0x87, (byte) 0x65, (byte) 0x43, (byte) 0x21
-    });
-    assertEquals(0xabcdef01, data.readInt());
-    assertEquals(0x87654321, data.readInt());
-    assertEquals(0, data.size());
-  }
-
-  @Test public void readIntLe() throws Exception {
-    OkBuffer data = new OkBuffer();
-    data.write(new byte[] {
-        (byte) 0xab, (byte) 0xcd, (byte) 0xef, (byte) 0x10,
-        (byte) 0x87, (byte) 0x65, (byte) 0x43, (byte) 0x21
-    });
-    assertEquals(0x10efcdab, data.readIntLe());
-    assertEquals(0x21436587, data.readIntLe());
-    assertEquals(0, data.size());
-  }
-
-  @Test public void readIntSplitAcrossMultipleSegments() throws Exception {
-    OkBuffer data = new OkBuffer();
-    data.writeUtf8(repeat('a', Segment.SIZE - 3));
-    data.write(new byte[] {
-        (byte) 0xab, (byte) 0xcd, (byte) 0xef, (byte) 0x01
-    });
-    data.readUtf8(Segment.SIZE - 3);
-    assertEquals(0xabcdef01, data.readInt());
-    assertEquals(0, data.size());
-  }
-
-  @Test public void readLong() throws Exception {
-    OkBuffer data = new OkBuffer();
-    data.write(new byte[] {
-        (byte) 0xab, (byte) 0xcd, (byte) 0xef, (byte) 0x10,
-        (byte) 0x87, (byte) 0x65, (byte) 0x43, (byte) 0x21,
-        (byte) 0x36, (byte) 0x47, (byte) 0x58, (byte) 0x69,
-        (byte) 0x12, (byte) 0x23, (byte) 0x34, (byte) 0x45
-    });
-    assertEquals(0xabcdef1087654321L, data.readLong());
-    assertEquals(0x3647586912233445L, data.readLong());
-    assertEquals(0, data.size());
-  }
-
-  @Test public void readLongLe() throws Exception {
-    OkBuffer data = new OkBuffer();
-    data.write(new byte[] {
-        (byte) 0xab, (byte) 0xcd, (byte) 0xef, (byte) 0x10,
-        (byte) 0x87, (byte) 0x65, (byte) 0x43, (byte) 0x21,
-        (byte) 0x36, (byte) 0x47, (byte) 0x58, (byte) 0x69,
-        (byte) 0x12, (byte) 0x23, (byte) 0x34, (byte) 0x45
-    });
-    assertEquals(0x2143658710efcdabL, data.readLongLe());
-    assertEquals(0x4534231269584736L, data.readLongLe());
-    assertEquals(0, data.size());
-  }
-
-  @Test public void readLongSplitAcrossMultipleSegments() throws Exception {
-    OkBuffer data = new OkBuffer();
-    data.writeUtf8(repeat('a', Segment.SIZE - 7));
-    data.write(new byte[] {
-        (byte) 0xab, (byte) 0xcd, (byte) 0xef, (byte) 0x01,
-        (byte) 0x87, (byte) 0x65, (byte) 0x43, (byte) 0x21,
-    });
-    data.readUtf8(Segment.SIZE - 7);
-    assertEquals(0xabcdef0187654321L, data.readLong());
-    assertEquals(0, data.size());
-  }
-
-  @Test public void byteAt() throws Exception {
-    OkBuffer buffer = new OkBuffer();
-    buffer.writeUtf8("a");
-    buffer.writeUtf8(repeat('b', Segment.SIZE));
-    buffer.writeUtf8("c");
-    assertEquals('a', buffer.getByte(0));
-    assertEquals('a', buffer.getByte(0)); // getByte doesn't mutate!
-    assertEquals('c', buffer.getByte(buffer.size - 1));
-    assertEquals('b', buffer.getByte(buffer.size - 2));
-    assertEquals('b', buffer.getByte(buffer.size - 3));
-  }
-
-  @Test public void getByteOfEmptyBuffer() throws Exception {
-    OkBuffer buffer = new OkBuffer();
-    try {
-      buffer.getByte(0);
-      fail();
-    } catch (IndexOutOfBoundsException expected) {
-    }
-  }
-
-  @Test public void skip() throws Exception {
-    OkBuffer buffer = new OkBuffer();
-    buffer.writeUtf8("a");
-    buffer.writeUtf8(repeat('b', Segment.SIZE));
-    buffer.writeUtf8("c");
-    buffer.skip(1);
-    assertEquals('b', buffer.readByte() & 0xff);
-    buffer.skip(Segment.SIZE - 2);
-    assertEquals('b', buffer.readByte() & 0xff);
-    buffer.skip(1);
-    assertEquals(0, buffer.size());
-  }
-
-  @Test public void testWritePrefixToEmptyBuffer() {
-    OkBuffer sink = new OkBuffer();
-    OkBuffer source = new OkBuffer();
-    source.writeUtf8("abcd");
-    sink.write(source, 2);
-    assertEquals("ab", sink.readUtf8(2));
-  }
-
-  @Test public void cloneDoesNotObserveWritesToOriginal() throws Exception {
-    OkBuffer original = new OkBuffer();
-    OkBuffer clone = original.clone();
-    original.writeUtf8("abc");
-    assertEquals(0, clone.size());
-  }
-
-  @Test public void cloneDoesNotObserveReadsFromOriginal() throws Exception {
-    OkBuffer original = new OkBuffer();
-    original.writeUtf8("abc");
-    OkBuffer clone = original.clone();
-    assertEquals("abc", original.readUtf8(3));
-    assertEquals(3, clone.size());
-    assertEquals("ab", clone.readUtf8(2));
-  }
-
-  @Test public void originalDoesNotObserveWritesToClone() throws Exception {
-    OkBuffer original = new OkBuffer();
-    OkBuffer clone = original.clone();
-    clone.writeUtf8("abc");
-    assertEquals(0, original.size());
-  }
-
-  @Test public void originalDoesNotObserveReadsFromClone() throws Exception {
-    OkBuffer original = new OkBuffer();
-    original.writeUtf8("abc");
-    OkBuffer clone = original.clone();
-    assertEquals("abc", clone.readUtf8(3));
-    assertEquals(3, original.size());
-    assertEquals("ab", original.readUtf8(2));
-  }
-
-  @Test public void cloneMultipleSegments() throws Exception {
-    OkBuffer original = new OkBuffer();
-    original.writeUtf8(repeat('a', Segment.SIZE * 3));
-    OkBuffer clone = original.clone();
-    original.writeUtf8(repeat('b', Segment.SIZE * 3));
-    clone.writeUtf8(repeat('c', Segment.SIZE * 3));
-
-    assertEquals(repeat('a', Segment.SIZE * 3) + repeat('b', Segment.SIZE * 3),
-        original.readUtf8(Segment.SIZE * 6));
-    assertEquals(repeat('a', Segment.SIZE * 3) + repeat('c', Segment.SIZE * 3),
-        clone.readUtf8(Segment.SIZE * 6));
-  }
-
-  @Test public void testEqualsAndHashCodeEmpty() throws Exception {
-    OkBuffer a = new OkBuffer();
-    OkBuffer b = new OkBuffer();
-    assertTrue(a.equals(b));
-    assertTrue(a.hashCode() == b.hashCode());
-  }
-
-  @Test public void testEqualsAndHashCode() throws Exception {
-    OkBuffer a = new OkBuffer().writeUtf8("dog");
-    OkBuffer b = new OkBuffer().writeUtf8("hotdog");
-    assertFalse(a.equals(b));
-    assertFalse(a.hashCode() == b.hashCode());
-
-    b.readUtf8(3); // Leaves b containing 'dog'.
-    assertTrue(a.equals(b));
-    assertTrue(a.hashCode() == b.hashCode());
-  }
-
-  @Test public void testEqualsAndHashCodeSpanningSegments() throws Exception {
-    byte[] data = new byte[1024 * 1024];
-    Random dice = new Random(0);
-    dice.nextBytes(data);
-
-    OkBuffer a = bufferWithRandomSegmentLayout(dice, data);
-    OkBuffer b = bufferWithRandomSegmentLayout(dice, data);
-    assertTrue(a.equals(b));
-    assertTrue(a.hashCode() == b.hashCode());
-
-    data[data.length / 2]++; // Change a single byte.
-    OkBuffer c = bufferWithRandomSegmentLayout(dice, data);
-    assertFalse(a.equals(c));
-    assertFalse(a.hashCode() == c.hashCode());
-  }
-
-  /**
-   * Returns a new buffer containing the data in {@code data}, and a segment
-   * layout determined by {@code dice}.
-   */
-  private OkBuffer bufferWithRandomSegmentLayout(Random dice, byte[] data) {
-    OkBuffer result = new OkBuffer();
-
-    // Writing to result directly will yield packed segments. Instead, write to
-    // other buffers, then write those buffers to result.
-    for (int pos = 0, byteCount; pos < data.length; pos += byteCount) {
-      byteCount = (Segment.SIZE / 2) + dice.nextInt(Segment.SIZE / 2);
-      if (byteCount > data.length - pos) byteCount = data.length - pos;
-      int offset = dice.nextInt(Segment.SIZE - byteCount);
-
-      OkBuffer segment = new OkBuffer();
-      segment.write(new byte[offset]);
-      segment.write(data, pos, byteCount);
-      segment.skip(offset);
-
-      result.write(segment, byteCount);
-    }
-
-    return result;
-  }
-
-  private String repeat(char c, int count) {
-    char[] array = new char[count];
-    Arrays.fill(array, c);
-    return new String(array);
-  }
-}
diff --git a/okio/src/test/java/okio/OkioTest.java b/okio/src/test/java/okio/OkioTest.java
deleted file mode 100644
index e56979fe4e..0000000000
--- a/okio/src/test/java/okio/OkioTest.java
+++ /dev/null
@@ -1,81 +0,0 @@
-/*
- * Copyright (C) 2014 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okio;
-
-import java.io.ByteArrayInputStream;
-import java.io.ByteArrayOutputStream;
-import java.io.InputStream;
-import java.util.Arrays;
-import org.junit.Test;
-
-import static okio.Util.UTF_8;
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.fail;
-
-public final class OkioTest {
-  @Test public void sinkFromOutputStream() throws Exception {
-    OkBuffer data = new OkBuffer();
-    data.writeUtf8("a");
-    data.writeUtf8(repeat('b', 9998));
-    data.writeUtf8("c");
-
-    ByteArrayOutputStream out = new ByteArrayOutputStream();
-    Sink sink = Okio.sink(out);
-    sink.write(data, 3);
-    assertEquals("abb", out.toString("UTF-8"));
-    sink.write(data, data.size());
-    assertEquals("a" + repeat('b', 9998) + "c", out.toString("UTF-8"));
-  }
-
-  @Test public void sourceFromInputStream() throws Exception {
-    InputStream in = new ByteArrayInputStream(
-        ("a" + repeat('b', Segment.SIZE * 2) + "c").getBytes(UTF_8));
-
-    // Source: ab...bc
-    Source source = Okio.source(in);
-    OkBuffer sink = new OkBuffer();
-
-    // Source: b...bc. Sink: abb.
-    assertEquals(3, source.read(sink, 3));
-    assertEquals("abb", sink.readUtf8(3));
-
-    // Source: b...bc. Sink: b...b.
-    assertEquals(Segment.SIZE, source.read(sink, 20000));
-    assertEquals(repeat('b', Segment.SIZE), sink.readUtf8(sink.size()));
-
-    // Source: b...bc. Sink: b...bc.
-    assertEquals(Segment.SIZE - 1, source.read(sink, 20000));
-    assertEquals(repeat('b', Segment.SIZE - 2) + "c", sink.readUtf8(sink.size()));
-
-    // Source and sink are empty.
-    assertEquals(-1, source.read(sink, 1));
-  }
-
-  @Test public void sourceFromInputStreamBounds() throws Exception {
-    Source source = Okio.source(new ByteArrayInputStream(new byte[100]));
-    try {
-      source.read(new OkBuffer(), -1);
-      fail();
-    } catch (IllegalArgumentException expected) {
-    }
-  }
-
-  private String repeat(char c, int count) {
-    char[] array = new char[count];
-    Arrays.fill(array, c);
-    return new String(array);
-  }
-}
diff --git a/okio/src/test/java/okio/ReadUtf8LineTest.java b/okio/src/test/java/okio/ReadUtf8LineTest.java
deleted file mode 100644
index 79b4c8abda..0000000000
--- a/okio/src/test/java/okio/ReadUtf8LineTest.java
+++ /dev/null
@@ -1,68 +0,0 @@
-/*
- * Copyright (C) 2014 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okio;
-
-import java.io.EOFException;
-import java.io.IOException;
-import org.junit.Test;
-
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertTrue;
-import static org.junit.Assert.fail;
-
-public abstract class ReadUtf8LineTest {
-  protected abstract BufferedSource newSource(String s);
-
-  @Test public void readLines() throws IOException {
-    BufferedSource source = newSource("abc\ndef\n");
-    assertEquals("abc", source.readUtf8LineStrict());
-    assertEquals("def", source.readUtf8LineStrict());
-    try {
-      source.readUtf8LineStrict();
-      fail();
-    } catch (EOFException expected) {
-    }
-  }
-
-  @Test public void emptyLines() throws IOException {
-    BufferedSource source = newSource("\n\n\n");
-    assertEquals("", source.readUtf8LineStrict());
-    assertEquals("", source.readUtf8LineStrict());
-    assertEquals("", source.readUtf8LineStrict());
-    assertTrue(source.exhausted());
-  }
-
-  @Test public void crDroppedPrecedingLf() throws IOException {
-    BufferedSource source = newSource("abc\r\ndef\r\nghi\rjkl\r\n");
-    assertEquals("abc", source.readUtf8LineStrict());
-    assertEquals("def", source.readUtf8LineStrict());
-    assertEquals("ghi\rjkl", source.readUtf8LineStrict());
-  }
-
-  @Test public void bufferedReaderCompatible() throws IOException {
-    BufferedSource source = newSource("abc\ndef");
-    assertEquals("abc", source.readUtf8Line());
-    assertEquals("def", source.readUtf8Line());
-    assertEquals(null, source.readUtf8Line());
-  }
-
-  @Test public void bufferedReaderCompatibleWithTrailingNewline() throws IOException {
-    BufferedSource source = newSource("abc\ndef\n");
-    assertEquals("abc", source.readUtf8Line());
-    assertEquals("def", source.readUtf8Line());
-    assertEquals(null, source.readUtf8Line());
-  }
-}
diff --git a/okio/src/test/java/okio/RealBufferedSinkTest.java b/okio/src/test/java/okio/RealBufferedSinkTest.java
deleted file mode 100644
index 67d3a803da..0000000000
--- a/okio/src/test/java/okio/RealBufferedSinkTest.java
+++ /dev/null
@@ -1,258 +0,0 @@
-/*
- * Copyright (C) 2014 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okio;
-
-import java.io.IOException;
-import java.io.OutputStream;
-import java.util.ArrayList;
-import java.util.Arrays;
-import java.util.LinkedHashMap;
-import java.util.List;
-import java.util.Map;
-import org.junit.Test;
-
-import static okio.Util.UTF_8;
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.fail;
-
-public final class RealBufferedSinkTest {
-  @Test public void outputStreamFromSink() throws Exception {
-    OkBuffer sink = new OkBuffer();
-    OutputStream out = new RealBufferedSink(sink).outputStream();
-    out.write('a');
-    out.write(repeat('b', 9998).getBytes(UTF_8));
-    out.write('c');
-    out.flush();
-    assertEquals("a" + repeat('b', 9998) + "c", sink.readUtf8(10000));
-  }
-
-  @Test public void outputStreamFromSinkBounds() throws Exception {
-    OkBuffer sink = new OkBuffer();
-    OutputStream out = new RealBufferedSink(sink).outputStream();
-    try {
-      out.write(new byte[100], 50, 51);
-      fail();
-    } catch (ArrayIndexOutOfBoundsException expected) {
-    }
-  }
-
-  @Test public void bufferedSinkEmitsTailWhenItIsComplete() throws IOException {
-    OkBuffer sink = new OkBuffer();
-    BufferedSink bufferedSink = new RealBufferedSink(sink);
-    bufferedSink.writeUtf8(repeat('a', Segment.SIZE - 1));
-    assertEquals(0, sink.size());
-    bufferedSink.writeByte(0);
-    assertEquals(Segment.SIZE, sink.size());
-    assertEquals(0, bufferedSink.buffer().size());
-  }
-
-  @Test public void bufferedSinkEmitZero() throws IOException {
-    OkBuffer sink = new OkBuffer();
-    BufferedSink bufferedSink = new RealBufferedSink(sink);
-    bufferedSink.writeUtf8("");
-    assertEquals(0, sink.size());
-  }
-
-  @Test public void bufferedSinkEmitMultipleSegments() throws IOException {
-    OkBuffer sink = new OkBuffer();
-    BufferedSink bufferedSink = new RealBufferedSink(sink);
-    bufferedSink.writeUtf8(repeat('a', Segment.SIZE * 4 - 1));
-    assertEquals(Segment.SIZE * 3, sink.size());
-    assertEquals(Segment.SIZE - 1, bufferedSink.buffer().size());
-  }
-
-  @Test public void bufferedSinkFlush() throws IOException {
-    OkBuffer sink = new OkBuffer();
-    BufferedSink bufferedSink = new RealBufferedSink(sink);
-    bufferedSink.writeByte('a');
-    assertEquals(0, sink.size());
-    bufferedSink.flush();
-    assertEquals(0, bufferedSink.buffer().size());
-    assertEquals(1, sink.size());
-  }
-
-  @Test public void bytesEmittedToSinkWithFlush() throws Exception {
-    OkBuffer sink = new OkBuffer();
-    BufferedSink bufferedSink = new RealBufferedSink(sink);
-    bufferedSink.writeUtf8("abc");
-    bufferedSink.flush();
-    assertEquals(3, sink.size());
-  }
-
-  @Test public void bytesNotEmittedToSinkWithoutFlush() throws Exception {
-    OkBuffer sink = new OkBuffer();
-    BufferedSink bufferedSink = new RealBufferedSink(sink);
-    bufferedSink.writeUtf8("abc");
-    assertEquals(0, sink.size());
-  }
-
-  @Test public void completeSegmentsEmitted() throws Exception {
-    OkBuffer sink = new OkBuffer();
-    BufferedSink bufferedSink = new RealBufferedSink(sink);
-    bufferedSink.writeUtf8(repeat('a', Segment.SIZE * 3));
-    assertEquals(Segment.SIZE * 3, sink.size());
-  }
-
-  @Test public void incompleteSegmentsNotEmitted() throws Exception {
-    OkBuffer sink = new OkBuffer();
-    BufferedSink bufferedSink = new RealBufferedSink(sink);
-    bufferedSink.writeUtf8(repeat('a', Segment.SIZE * 3 - 1));
-    assertEquals(Segment.SIZE * 2, sink.size());
-  }
-
-  @Test public void closeEmitsBufferedBytes() throws IOException {
-    OkBuffer sink = new OkBuffer();
-    BufferedSink bufferedSink = new RealBufferedSink(sink);
-    bufferedSink.writeByte('a');
-    bufferedSink.close();
-    assertEquals('a', sink.readByte());
-  }
-
-  @Test public void closeWithExceptionWhenWriting() throws IOException {
-    MockSink mockSink = new MockSink();
-    mockSink.scheduleThrow(0, new IOException());
-    BufferedSink bufferedSink = new RealBufferedSink(mockSink);
-    bufferedSink.writeByte('a');
-    try {
-      bufferedSink.close();
-      fail();
-    } catch (IOException expected) {
-    }
-    mockSink.assertLog("write(OkBuffer[size=1 data=61], 1)", "close()");
-  }
-
-  @Test public void closeWithExceptionWhenClosing() throws IOException {
-    MockSink mockSink = new MockSink();
-    mockSink.scheduleThrow(1, new IOException());
-    BufferedSink bufferedSink = new RealBufferedSink(mockSink);
-    bufferedSink.writeByte('a');
-    try {
-      bufferedSink.close();
-      fail();
-    } catch (IOException expected) {
-    }
-    mockSink.assertLog("write(OkBuffer[size=1 data=61], 1)", "close()");
-  }
-
-  @Test public void closeWithExceptionWhenWritingAndClosing() throws IOException {
-    MockSink mockSink = new MockSink();
-    mockSink.scheduleThrow(0, new IOException("first"));
-    mockSink.scheduleThrow(1, new IOException("second"));
-    BufferedSink bufferedSink = new RealBufferedSink(mockSink);
-    bufferedSink.writeByte('a');
-    try {
-      bufferedSink.close();
-      fail();
-    } catch (IOException expected) {
-      assertEquals("first", expected.getMessage());
-    }
-    mockSink.assertLog("write(OkBuffer[size=1 data=61], 1)", "close()");
-  }
-
-  @Test public void operationsAfterClose() throws IOException {
-    MockSink mockSink = new MockSink();
-    BufferedSink bufferedSink = new RealBufferedSink(mockSink);
-    bufferedSink.writeByte('a');
-    bufferedSink.close();
-
-    // Test a sample set of methods.
-    try {
-      bufferedSink.writeByte('a');
-      fail();
-    } catch (IllegalStateException expected) {
-    }
-
-    try {
-      bufferedSink.write(new byte[10]);
-      fail();
-    } catch (IllegalStateException expected) {
-    }
-
-    try {
-      bufferedSink.emitCompleteSegments();
-      fail();
-    } catch (IllegalStateException expected) {
-    }
-
-    try {
-      bufferedSink.flush();
-      fail();
-    } catch (IllegalStateException expected) {
-    }
-
-    // Test a sample set of methods on the OutputStream.
-    OutputStream os = bufferedSink.outputStream();
-    try {
-      os.write('a');
-      fail();
-    } catch (IOException expected) {
-    }
-
-    try {
-      os.write(new byte[10]);
-      fail();
-    } catch (IOException expected) {
-    }
-
-    // Permitted
-    os.flush();
-  }
-
-  private String repeat(char c, int count) {
-    char[] array = new char[count];
-    Arrays.fill(array, c);
-    return new String(array);
-  }
-
-  /** A scriptable sink. Like Mockito, but worse and requiring less configuration. */
-  private static class MockSink implements Sink {
-    private final List<String> log = new ArrayList<String>();
-    private final Map<Integer, IOException> callThrows = new LinkedHashMap<Integer, IOException>();
-
-    public void assertLog(String... messages) {
-      assertEquals(Arrays.asList(messages), log);
-    }
-
-    public void scheduleThrow(int call, IOException e) {
-      callThrows.put(call, e);
-    }
-
-    private void throwIfScheduled() throws IOException {
-      IOException exception = callThrows.get(log.size() - 1);
-      if (exception != null) throw exception;
-    }
-
-    @Override public void write(OkBuffer source, long byteCount) throws IOException {
-      log.add("write(" + source + ", " + byteCount + ")");
-      throwIfScheduled();
-    }
-
-    @Override public void flush() throws IOException {
-      log.add("flush()");
-      throwIfScheduled();
-    }
-
-    @Override public Sink deadline(Deadline deadline) {
-      log.add("deadline()");
-      return this;
-    }
-
-    @Override public void close() throws IOException {
-      log.add("close()");
-      throwIfScheduled();
-    }
-  }
-}
diff --git a/okio/src/test/java/okio/RealBufferedSourceReadUtf8LineTest.java b/okio/src/test/java/okio/RealBufferedSourceReadUtf8LineTest.java
deleted file mode 100644
index 8793640b10..0000000000
--- a/okio/src/test/java/okio/RealBufferedSourceReadUtf8LineTest.java
+++ /dev/null
@@ -1,41 +0,0 @@
-/*
- * Copyright (C) 2014 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okio;
-
-import java.io.IOException;
-
-public final class RealBufferedSourceReadUtf8LineTest extends ReadUtf8LineTest {
-  /** Returns a buffered source that gets bytes of {@code data} one at a time. */
-  @Override protected BufferedSource newSource(String s) {
-    final OkBuffer buffer = new OkBuffer().writeUtf8(s);
-
-    Source slowSource = new Source() {
-      @Override public long read(OkBuffer sink, long byteCount) throws IOException {
-        return buffer.read(sink, Math.min(1, byteCount));
-      }
-
-      @Override public Source deadline(Deadline deadline) {
-        throw new UnsupportedOperationException();
-      }
-
-      @Override public void close() throws IOException {
-        throw new UnsupportedOperationException();
-      }
-    };
-
-    return Okio.buffer(slowSource);
-  }
-}
diff --git a/okio/src/test/java/okio/RealBufferedSourceTest.java b/okio/src/test/java/okio/RealBufferedSourceTest.java
deleted file mode 100644
index a77eaf2805..0000000000
--- a/okio/src/test/java/okio/RealBufferedSourceTest.java
+++ /dev/null
@@ -1,208 +0,0 @@
-/*
- * Copyright (C) 2014 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okio;
-
-import java.io.EOFException;
-import java.io.IOException;
-import java.io.InputStream;
-import java.util.Arrays;
-import org.junit.Test;
-
-import static okio.Util.UTF_8;
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.fail;
-
-public final class RealBufferedSourceTest {
-  @Test public void inputStreamFromSource() throws Exception {
-    OkBuffer source = new OkBuffer();
-    source.writeUtf8("a");
-    source.writeUtf8(repeat('b', Segment.SIZE));
-    source.writeUtf8("c");
-
-    InputStream in = new RealBufferedSource(source).inputStream();
-    assertEquals(0, in.available());
-    assertEquals(Segment.SIZE + 2, source.size());
-
-    // Reading one byte buffers a full segment.
-    assertEquals('a', in.read());
-    assertEquals(Segment.SIZE - 1, in.available());
-    assertEquals(2, source.size());
-
-    // Reading as much as possible reads the rest of that buffered segment.
-    byte[] data = new byte[Segment.SIZE * 2];
-    assertEquals(Segment.SIZE - 1, in.read(data, 0, data.length));
-    assertEquals(repeat('b', Segment.SIZE - 1), new String(data, 0, Segment.SIZE - 1, UTF_8));
-    assertEquals(2, source.size());
-
-    // Continuing to read buffers the next segment.
-    assertEquals('b', in.read());
-    assertEquals(1, in.available());
-    assertEquals(0, source.size());
-
-    // Continuing to read reads from the buffer.
-    assertEquals('c', in.read());
-    assertEquals(0, in.available());
-    assertEquals(0, source.size());
-
-    // Once we've exhausted the source, we're done.
-    assertEquals(-1, in.read());
-    assertEquals(0, source.size());
-  }
-
-  @Test public void inputStreamFromSourceBounds() throws IOException {
-    OkBuffer source = new OkBuffer();
-    source.writeUtf8(repeat('a', 100));
-    InputStream in = new RealBufferedSource(source).inputStream();
-    try {
-      in.read(new byte[100], 50, 51);
-      fail();
-    } catch (ArrayIndexOutOfBoundsException expected) {
-    }
-  }
-
-  @Test public void requireTracksBufferFirst() throws Exception {
-    OkBuffer source = new OkBuffer();
-    source.writeUtf8("bb");
-
-    BufferedSource bufferedSource = new RealBufferedSource(source);
-    bufferedSource.buffer().writeUtf8("aa");
-
-    bufferedSource.require(2);
-    assertEquals(2, bufferedSource.buffer().size());
-    assertEquals(2, source.size());
-  }
-
-  @Test public void requireIncludesBufferBytes() throws Exception {
-    OkBuffer source = new OkBuffer();
-    source.writeUtf8("b");
-
-    BufferedSource bufferedSource = new RealBufferedSource(source);
-    bufferedSource.buffer().writeUtf8("a");
-
-    bufferedSource.require(2);
-    assertEquals("ab", bufferedSource.buffer().readUtf8(2));
-  }
-
-  @Test public void requireInsufficientData() throws Exception {
-    OkBuffer source = new OkBuffer();
-    source.writeUtf8("a");
-
-    BufferedSource bufferedSource = new RealBufferedSource(source);
-
-    try {
-      bufferedSource.require(2);
-      fail();
-    } catch (EOFException expected) {
-    }
-  }
-
-  @Test public void requireReadsOneSegmentAtATime() throws Exception {
-    OkBuffer source = new OkBuffer();
-    source.writeUtf8(repeat('a', Segment.SIZE));
-    source.writeUtf8(repeat('b', Segment.SIZE));
-
-    BufferedSource bufferedSource = new RealBufferedSource(source);
-
-    bufferedSource.require(2);
-    assertEquals(Segment.SIZE, source.size());
-    assertEquals(Segment.SIZE, bufferedSource.buffer().size());
-  }
-
-  @Test public void skipInsufficientData() throws Exception {
-    OkBuffer source = new OkBuffer();
-    source.writeUtf8("a");
-
-    BufferedSource bufferedSource = new RealBufferedSource(source);
-    try {
-      bufferedSource.skip(2);
-      fail();
-    } catch (EOFException expected) {
-    }
-  }
-
-  @Test public void skipReadsOneSegmentAtATime() throws Exception {
-    OkBuffer source = new OkBuffer();
-    source.writeUtf8(repeat('a', Segment.SIZE));
-    source.writeUtf8(repeat('b', Segment.SIZE));
-    BufferedSource bufferedSource = new RealBufferedSource(source);
-    bufferedSource.skip(2);
-    assertEquals(Segment.SIZE, source.size());
-    assertEquals(Segment.SIZE - 2, bufferedSource.buffer().size());
-  }
-
-  @Test public void skipTracksBufferFirst() throws Exception {
-    OkBuffer source = new OkBuffer();
-    source.writeUtf8("bb");
-
-    BufferedSource bufferedSource = new RealBufferedSource(source);
-    bufferedSource.buffer().writeUtf8("aa");
-
-    bufferedSource.skip(2);
-    assertEquals(0, bufferedSource.buffer().size());
-    assertEquals(2, source.size());
-  }
-
-  @Test public void operationsAfterClose() throws IOException {
-    OkBuffer source = new OkBuffer();
-    BufferedSource bufferedSource = new RealBufferedSource(source);
-    bufferedSource.close();
-
-    // Test a sample set of methods.
-    try {
-      bufferedSource.indexOf((byte) 1);
-      fail();
-    } catch (IllegalStateException expected) {
-    }
-
-    try {
-      bufferedSource.skip(1);
-      fail();
-    } catch (IllegalStateException expected) {
-    }
-
-    try {
-      bufferedSource.readByte();
-      fail();
-    } catch (IllegalStateException expected) {
-    }
-
-    try {
-      bufferedSource.readByteString(10);
-      fail();
-    } catch (IllegalStateException expected) {
-    }
-
-    // Test a sample set of methods on the InputStream.
-    InputStream is = bufferedSource.inputStream();
-    try {
-      is.read();
-      fail();
-    } catch (IOException expected) {
-    }
-
-    try {
-      is.read(new byte[10]);
-      fail();
-    } catch (IOException expected) {
-    }
-  }
-
-  private String repeat(char c, int count) {
-    char[] array = new char[count];
-    Arrays.fill(array, c);
-    return new String(array);
-  }
-}
diff --git a/pom.xml b/pom.xml
index c534a1d3ff..392779f27e 100644
--- a/pom.xml
+++ b/pom.xml
@@ -11,7 +11,7 @@
 
   <groupId>com.squareup.okhttp</groupId>
   <artifactId>parent</artifactId>
-  <version>2.0.0-SNAPSHOT</version>
+  <version>2.0.1-SNAPSHOT</version>
   <packaging>pom</packaging>
 
   <name>OkHttp (Parent)</name>
@@ -21,9 +21,10 @@
   <modules>
     <module>okhttp</module>
     <module>okhttp-apache</module>
+    <module>okhttp-hpacktests</module>
     <module>okhttp-tests</module>
+    <module>okhttp-urlconnection</module>
     <module>okcurl</module>
-    <module>okio</module>
     <module>mockwebserver</module>
     <module>samples</module>
     <module>benchmarks</module>
@@ -33,9 +34,13 @@
     <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
 
     <!-- Compilation -->
-    <java.version>1.6</java.version>
-    <npn.version>8.1.2.v20120308</npn.version>
-    <bouncycastle.version>1.48</bouncycastle.version>
+    <java.version>1.7</java.version>
+    <okio.version>1.0.1</okio.version>
+    <!-- Targetted to jdk7u60-b13; Oracle jdk7u55-b13. -->
+    <npn.version>1.1.7.v20140316</npn.version>
+    <!-- Targetted to OpenJDK 8 b132 -->
+    <alpn.version>8.0.0.v20140317</alpn.version>
+    <bouncycastle.version>1.50</bouncycastle.version>
     <gson.version>2.2.3</gson.version>
     <apache.http.version>4.2.2</apache.http.version>
     <airlift.version>0.6</airlift.version>
@@ -67,15 +72,25 @@
   <dependencyManagement>
     <dependencies>
       <dependency>
-        <groupId>org.mortbay.jetty.npn</groupId>
-        <artifactId>npn-boot</artifactId>
-        <version>${npn.version}</version>
+        <groupId>com.squareup.okio</groupId>
+        <artifactId>okio</artifactId>
+        <version>${okio.version}</version>
       </dependency>
       <dependency>
         <groupId>junit</groupId>
         <artifactId>junit</artifactId>
         <version>${junit.version}</version>
       </dependency>
+      <dependency>
+        <groupId>org.mortbay.jetty.npn</groupId>
+        <artifactId>npn-boot</artifactId>
+        <version>${npn.version}</version>
+      </dependency>
+      <dependency>
+        <groupId>org.mortbay.jetty.alpn</groupId>
+        <artifactId>alpn-boot</artifactId>
+        <version>${alpn.version}</version>
+      </dependency>
       <dependency>
         <groupId>org.bouncycastle</groupId>
         <artifactId>bcprov-jdk15on</artifactId>
@@ -120,15 +135,12 @@
         <plugin>
           <groupId>org.apache.maven.plugins</groupId>
           <artifactId>maven-surefire-plugin</artifactId>
-          <version>2.16</version>
-          <configuration>
-            <argLine>-Xbootclasspath/p:${settings.localRepository}/org/mortbay/jetty/npn/npn-boot/${npn.version}/npn-boot-${npn.version}.jar</argLine>
-          </configuration>
+          <version>2.17</version>
           <dependencies>
             <dependency>
               <groupId>org.apache.maven.surefire</groupId>
               <artifactId>surefire-junit47</artifactId>
-              <version>2.16</version>
+              <version>2.17</version>
             </dependency>
           </dependencies>
         </plugin>
@@ -179,7 +191,7 @@
       <plugin>
         <groupId>org.codehaus.mojo</groupId>
         <artifactId>animal-sniffer-maven-plugin</artifactId>
-        <version>1.10</version>
+        <version>1.11</version>
         <executions>
           <execution>
             <phase>test</phase>
@@ -198,5 +210,66 @@
       </plugin>
     </plugins>
   </build>
+
+  <profiles>
+    <profile>
+      <id>npn-when-jdk7</id>
+      <activation>
+        <jdk>1.7</jdk>
+      </activation>
+      <properties>
+        <bootclasspathPrefix>${settings.localRepository}/org/mortbay/jetty/npn/npn-boot/${npn.version}/npn-boot-${npn.version}.jar</bootclasspathPrefix>
+      </properties>
+      <build>
+        <pluginManagement>
+          <plugins>
+            <plugin>
+              <groupId>org.apache.maven.plugins</groupId>
+              <artifactId>maven-surefire-plugin</artifactId>
+              <configuration>
+                <argLine>-Xbootclasspath/p:${bootclasspathPrefix}</argLine>
+              </configuration>
+              <dependencies>
+                <dependency>
+                  <groupId>org.mortbay.jetty.npn</groupId>
+                  <artifactId>npn-boot</artifactId>
+                  <version>${npn.version}</version>
+                </dependency>
+              </dependencies>
+            </plugin>
+          </plugins>
+        </pluginManagement>
+      </build>
+    </profile>
+    <profile>
+      <id>alpn-when-jdk8</id>
+      <activation>
+        <jdk>1.8</jdk>
+      </activation>
+      <properties>
+        <bootclasspathPrefix>${settings.localRepository}/org/mortbay/jetty/alpn/alpn-boot/${alpn.version}/alpn-boot-${alpn.version}.jar</bootclasspathPrefix>
+      </properties>
+      <build>
+        <pluginManagement>
+          <plugins>
+            <plugin>
+              <groupId>org.apache.maven.plugins</groupId>
+              <artifactId>maven-surefire-plugin</artifactId>
+              <configuration>
+                <argLine>-Xbootclasspath/p:${bootclasspathPrefix}</argLine>
+              </configuration>
+              <dependencies>
+                <dependency>
+                  <groupId>org.mortbay.jetty.alpn</groupId>
+                  <artifactId>alpn-boot</artifactId>
+                  <version>${alpn.version}</version>
+                </dependency>
+              </dependencies>
+            </plugin>
+          </plugins>
+        </pluginManagement>
+      </build>
+    </profile>
+  </profiles>
 </project>
 
diff --git a/samples/crawler/pom.xml b/samples/crawler/pom.xml
new file mode 100644
index 0000000000..0af4e32ebd
--- /dev/null
+++ b/samples/crawler/pom.xml
@@ -0,0 +1,27 @@
+<?xml version="1.0" encoding="UTF-8"?>
+
+<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
+  <modelVersion>4.0.0</modelVersion>
+
+  <parent>
+    <groupId>com.squareup.okhttp.sample</groupId>
+    <artifactId>sample-parent</artifactId>
+    <version>2.0.1-SNAPSHOT</version>
+  </parent>
+
+  <artifactId>crawler</artifactId>
+  <name>Sample: Crawler</name>
+
+  <dependencies>
+    <dependency>
+      <groupId>com.squareup.okhttp</groupId>
+      <artifactId>okhttp</artifactId>
+      <version>${project.version}</version>
+    </dependency>
+    <dependency>
+      <groupId>org.jsoup</groupId>
+      <artifactId>jsoup</artifactId>
+      <version>1.7.3</version>
+    </dependency>
+  </dependencies>
+</project>
diff --git a/samples/crawler/src/main/java/com/squareup/okhttp/sample/Crawler.java b/samples/crawler/src/main/java/com/squareup/okhttp/sample/Crawler.java
new file mode 100644
index 0000000000..24383fe47e
--- /dev/null
+++ b/samples/crawler/src/main/java/com/squareup/okhttp/sample/Crawler.java
@@ -0,0 +1,132 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.okhttp.sample;
+
+import com.squareup.okhttp.Cache;
+import com.squareup.okhttp.OkHttpClient;
+import com.squareup.okhttp.Request;
+import com.squareup.okhttp.Response;
+import java.io.File;
+import java.io.IOException;
+import java.net.MalformedURLException;
+import java.net.URL;
+import java.util.Collections;
+import java.util.LinkedHashSet;
+import java.util.Set;
+import java.util.concurrent.ExecutorService;
+import java.util.concurrent.Executors;
+import java.util.concurrent.LinkedBlockingQueue;
+import org.jsoup.Jsoup;
+import org.jsoup.nodes.Document;
+import org.jsoup.nodes.Element;
+
+/**
+ * Fetches HTML from a requested URL, follows the links, and repeats.
+ */
+public final class Crawler {
+  private final OkHttpClient client;
+  private final Set<URL> fetchedUrls = Collections.synchronizedSet(new LinkedHashSet<URL>());
+  private final LinkedBlockingQueue<URL> queue = new LinkedBlockingQueue<>();
+
+  public Crawler(OkHttpClient client) {
+    this.client = client;
+  }
+
+  private void parallelDrainQueue(int threadCount) {
+    ExecutorService executor = Executors.newFixedThreadPool(threadCount);
+    for (int i = 0; i < threadCount; i++) {
+      executor.execute(new Runnable() {
+        @Override public void run() {
+          try {
+            drainQueue();
+          } catch (Exception e) {
+            e.printStackTrace();
+          }
+        }
+      });
+    }
+    executor.shutdown();
+  }
+
+  private void drainQueue() throws Exception {
+    for (URL url; (url = queue.take()) != null; ) {
+      if (!fetchedUrls.add(url)) {
+        continue;
+      }
+
+      try {
+        fetch(url);
+      } catch (IOException e) {
+        System.out.printf("XXX: %s %s%n", url, e);
+      }
+    }
+  }
+
+  public void fetch(URL url) throws IOException {
+    Request request = new Request.Builder()
+        .url(url)
+        .build();
+    Response response = client.newCall(request).execute();
+    String responseSource = response.networkResponse() != null
+        ? ("(network: " + response.networkResponse().code() + ")")
+        : "(cache)";
+    int responseCode = response.code();
+
+    System.out.printf("%03d: %s %s%n", responseCode, url, responseSource);
+
+    String contentType = response.header("Content-Type");
+    if (responseCode != 200 || contentType == null) {
+      response.body().close();
+      return;
+    }
+
+    Document document = Jsoup.parse(response.body().string(), url.toString());
+    for (Element element : document.select("a[href]")) {
+      String href = element.attr("href");
+      URL link = parseUrl(url, href);
+      if (link != null) queue.add(link);
+    }
+  }
+
+  private URL parseUrl(URL url, String href) {
+    try {
+      URL result = new URL(url, href);
+      return result.getProtocol().equals("http") || result.getProtocol().equals("https")
+          ? result
+          : null;
+    } catch (MalformedURLException e) {
+      return null;
+    }
+  }
+
+  public static void main(String[] args) throws IOException {
+    if (args.length != 2) {
+      System.out.println("Usage: Crawler <cache dir> <root>");
+      return;
+    }
+
+    int threadCount = 20;
+    long cacheByteCount = 1024L * 1024L * 100L;
+
+    OkHttpClient client = new OkHttpClient();
+    Cache cache = new Cache(new File(args[0]), cacheByteCount);
+    client.setCache(cache);
+
+    Crawler crawler = new Crawler(client);
+    crawler.queue.add(new URL(args[1]));
+    crawler.parallelDrainQueue(threadCount);
+  }
+}
diff --git a/samples/guide/pom.xml b/samples/guide/pom.xml
index 61e58756a1..c257c16363 100644
--- a/samples/guide/pom.xml
+++ b/samples/guide/pom.xml
@@ -6,7 +6,7 @@
   <parent>
     <groupId>com.squareup.okhttp.sample</groupId>
     <artifactId>sample-parent</artifactId>
-    <version>2.0.0-SNAPSHOT</version>
+    <version>2.0.1-SNAPSHOT</version>
   </parent>
 
   <artifactId>guide</artifactId>
@@ -18,5 +18,9 @@
       <artifactId>okhttp</artifactId>
       <version>${project.version}</version>
     </dependency>
+    <dependency>
+      <groupId>com.google.code.gson</groupId>
+      <artifactId>gson</artifactId>
+    </dependency>
   </dependencies>
 </project>
diff --git a/samples/guide/src/main/java/com/squareup/okhttp/guide/GetExample.java b/samples/guide/src/main/java/com/squareup/okhttp/guide/GetExample.java
index b5427c5806..aa2f200e40 100644
--- a/samples/guide/src/main/java/com/squareup/okhttp/guide/GetExample.java
+++ b/samples/guide/src/main/java/com/squareup/okhttp/guide/GetExample.java
@@ -1,43 +1,25 @@
 package com.squareup.okhttp.guide;
 
 import com.squareup.okhttp.OkHttpClient;
-import java.io.ByteArrayOutputStream;
+import com.squareup.okhttp.Request;
+import com.squareup.okhttp.Response;
 import java.io.IOException;
-import java.io.InputStream;
-import java.net.HttpURLConnection;
-import java.net.URL;
 
 public class GetExample {
   OkHttpClient client = new OkHttpClient();
 
-  void run() throws IOException {
-    String result = get(new URL("https://raw.github.com/square/okhttp/master/README.md"));
-    System.out.println(result);
-  }
-
-  String get(URL url) throws IOException {
-    HttpURLConnection connection = client.open(url);
-    InputStream in = null;
-    try {
-      // Read the response.
-      in = connection.getInputStream();
-      byte[] response = readFully(in);
-      return new String(response, "UTF-8");
-    } finally {
-      if (in != null) in.close();
-    }
-  }
+  String run(String url) throws IOException {
+    Request request = new Request.Builder()
+        .url(url)
+        .build();
 
-  byte[] readFully(InputStream in) throws IOException {
-    ByteArrayOutputStream out = new ByteArrayOutputStream();
-    byte[] buffer = new byte[1024];
-    for (int count; (count = in.read(buffer)) != -1; ) {
-      out.write(buffer, 0, count);
-    }
-    return out.toByteArray();
+    Response response = client.newCall(request).execute();
+    return response.body().string();
   }
 
   public static void main(String[] args) throws IOException {
-    new GetExample().run();
+    GetExample example = new GetExample();
+    String response = example.run("https://raw.github.com/square/okhttp/master/README.md");
+    System.out.println(response);
   }
 }
diff --git a/samples/guide/src/main/java/com/squareup/okhttp/guide/PostExample.java b/samples/guide/src/main/java/com/squareup/okhttp/guide/PostExample.java
index 309ab70211..5de644c7d7 100644
--- a/samples/guide/src/main/java/com/squareup/okhttp/guide/PostExample.java
+++ b/samples/guide/src/main/java/com/squareup/okhttp/guide/PostExample.java
@@ -1,51 +1,26 @@
 package com.squareup.okhttp.guide;
 
+import com.squareup.okhttp.MediaType;
 import com.squareup.okhttp.OkHttpClient;
-import java.io.BufferedReader;
+import com.squareup.okhttp.Request;
+import com.squareup.okhttp.RequestBody;
+import com.squareup.okhttp.Response;
 import java.io.IOException;
-import java.io.InputStream;
-import java.io.InputStreamReader;
-import java.io.OutputStream;
-import java.net.HttpURLConnection;
-import java.net.URL;
 
 public class PostExample {
-  OkHttpClient client = new OkHttpClient();
-
-  void run() throws IOException {
-    byte[] body = bowlingJson("Jesse", "Jake").getBytes("UTF-8");
-    String result = post(new URL("http://www.roundsapp.com/post"), body);
-    System.out.println(result);
-  }
+  public static final MediaType JSON
+      = MediaType.parse("application/json; charset=utf-8");
 
-  String post(URL url, byte[] body) throws IOException {
-    HttpURLConnection connection = client.open(url);
-    OutputStream out = null;
-    InputStream in = null;
-    try {
-      // Write the request.
-      connection.setRequestMethod("POST");
-      out = connection.getOutputStream();
-      out.write(body);
-      out.close();
-
-      // Read the response.
-      if (connection.getResponseCode() != HttpURLConnection.HTTP_OK) {
-        throw new IOException("Unexpected HTTP response: "
-            + connection.getResponseCode() + " " + connection.getResponseMessage());
-      }
-      in = connection.getInputStream();
-      return readFirstLine(in);
-    } finally {
-      // Clean up.
-      if (out != null) out.close();
-      if (in != null) in.close();
-    }
-  }
+  OkHttpClient client = new OkHttpClient();
 
-  String readFirstLine(InputStream in) throws IOException {
-    BufferedReader reader = new BufferedReader(new InputStreamReader(in, "UTF-8"));
-    return reader.readLine();
+  String post(String url, String json) throws IOException {
+    RequestBody body = RequestBody.create(JSON, json);
+    Request request = new Request.Builder()
+        .url(url)
+        .post(body)
+        .build();
+    Response response = client.newCall(request).execute();
+    return response.body().string();
   }
 
   String bowlingJson(String player1, String player2) {
@@ -61,6 +36,9 @@ String bowlingJson(String player1, String player2) {
   }
 
   public static void main(String[] args) throws IOException {
-    new PostExample().run();
+    PostExample example = new PostExample();
+    String json = example.bowlingJson("Jesse", "Jake");
+    String response = example.post("http://www.roundsapp.com/post", json);
+    System.out.println(response);
   }
 }
diff --git a/samples/guide/src/main/java/com/squareup/okhttp/recipes/AccessHeaders.java b/samples/guide/src/main/java/com/squareup/okhttp/recipes/AccessHeaders.java
new file mode 100644
index 0000000000..9fe9d1ab67
--- /dev/null
+++ b/samples/guide/src/main/java/com/squareup/okhttp/recipes/AccessHeaders.java
@@ -0,0 +1,45 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.okhttp.recipes;
+
+import com.squareup.okhttp.OkHttpClient;
+import com.squareup.okhttp.Request;
+import com.squareup.okhttp.Response;
+import java.io.IOException;
+
+public final class AccessHeaders {
+  private final OkHttpClient client = new OkHttpClient();
+
+  public void run() throws Exception {
+    Request request = new Request.Builder()
+        .url("https://api.github.com/repos/square/okhttp/issues")
+        .header("User-Agent", "OkHttp Headers.java")
+        .addHeader("Accept", "application/json; q=0.5")
+        .addHeader("Accept", "application/vnd.github.v3+json")
+        .build();
+
+    Response response = client.newCall(request).execute();
+    if (!response.isSuccessful()) throw new IOException("Unexpected code " + response);
+
+    System.out.println("Server: " + response.header("Server"));
+    System.out.println("Date: " + response.header("Date"));
+    System.out.println("Vary: " + response.headers("Vary"));
+  }
+
+  public static void main(String... args) throws Exception {
+    new AccessHeaders().run();
+  }
+}
diff --git a/samples/guide/src/main/java/com/squareup/okhttp/recipes/AsynchronousGet.java b/samples/guide/src/main/java/com/squareup/okhttp/recipes/AsynchronousGet.java
new file mode 100644
index 0000000000..1667c59ee2
--- /dev/null
+++ b/samples/guide/src/main/java/com/squareup/okhttp/recipes/AsynchronousGet.java
@@ -0,0 +1,54 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.okhttp.recipes;
+
+import com.squareup.okhttp.Callback;
+import com.squareup.okhttp.Headers;
+import com.squareup.okhttp.OkHttpClient;
+import com.squareup.okhttp.Request;
+import com.squareup.okhttp.Response;
+import java.io.IOException;
+
+public final class AsynchronousGet {
+  private final OkHttpClient client = new OkHttpClient();
+
+  public void run() throws Exception {
+    Request request = new Request.Builder()
+        .url("http://publicobject.com/helloworld.txt")
+        .build();
+
+    client.newCall(request).enqueue(new Callback() {
+      @Override public void onFailure(Request request, IOException e) {
+        e.printStackTrace();
+      }
+
+      @Override public void onResponse(Response response) throws IOException {
+        if (!response.isSuccessful()) throw new IOException("Unexpected code " + response);
+
+        Headers responseHeaders = response.headers();
+        for (int i = 0; i < responseHeaders.size(); i++) {
+          System.out.println(responseHeaders.name(i) + ": " + responseHeaders.value(i));
+        }
+
+        System.out.println(response.body().string());
+      }
+    });
+  }
+
+  public static void main(String... args) throws Exception {
+    new AsynchronousGet().run();
+  }
+}
diff --git a/samples/guide/src/main/java/com/squareup/okhttp/recipes/Authenticate.java b/samples/guide/src/main/java/com/squareup/okhttp/recipes/Authenticate.java
new file mode 100644
index 0000000000..44581aed33
--- /dev/null
+++ b/samples/guide/src/main/java/com/squareup/okhttp/recipes/Authenticate.java
@@ -0,0 +1,58 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.okhttp.recipes;
+
+import com.squareup.okhttp.Authenticator;
+import com.squareup.okhttp.Credentials;
+import com.squareup.okhttp.OkHttpClient;
+import com.squareup.okhttp.Request;
+import com.squareup.okhttp.Response;
+import java.io.IOException;
+import java.net.Proxy;
+
+public final class Authenticate {
+  private final OkHttpClient client = new OkHttpClient();
+
+  public void run() throws Exception {
+    client.setAuthenticator(new Authenticator() {
+      @Override public Request authenticate(Proxy proxy, Response response) {
+        System.out.println("Authenticating for response: " + response);
+        System.out.println("Challenges: " + response.challenges());
+        String credential = Credentials.basic("jesse", "password1");
+        return response.request().newBuilder()
+            .header("Authorization", credential)
+            .build();
+      }
+
+      @Override public Request authenticateProxy(Proxy proxy, Response response) {
+        return null; // Null indicates no attempt to authenticate.
+      }
+    });
+
+    Request request = new Request.Builder()
+        .url("http://publicobject.com/secrets/hellosecret.txt")
+        .build();
+
+    Response response = client.newCall(request).execute();
+    if (!response.isSuccessful()) throw new IOException("Unexpected code " + response);
+
+    System.out.println(response.body().string());
+  }
+
+  public static void main(String... args) throws Exception {
+    new Authenticate().run();
+  }
+}
diff --git a/samples/guide/src/main/java/com/squareup/okhttp/recipes/CacheResponse.java b/samples/guide/src/main/java/com/squareup/okhttp/recipes/CacheResponse.java
new file mode 100644
index 0000000000..3335ebe668
--- /dev/null
+++ b/samples/guide/src/main/java/com/squareup/okhttp/recipes/CacheResponse.java
@@ -0,0 +1,63 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.okhttp.recipes;
+
+import com.squareup.okhttp.Cache;
+import com.squareup.okhttp.OkHttpClient;
+import com.squareup.okhttp.Request;
+import com.squareup.okhttp.Response;
+import java.io.File;
+import java.io.IOException;
+
+public final class CacheResponse {
+  private final OkHttpClient client;
+
+  public CacheResponse(File cacheDirectory) throws Exception {
+    int cacheSize = 10 * 1024 * 1024; // 10 MiB
+    Cache cache = new Cache(cacheDirectory, cacheSize);
+
+    client = new OkHttpClient();
+    client.setCache(cache);
+  }
+
+  public void run() throws Exception {
+    Request request = new Request.Builder()
+        .url("http://publicobject.com/helloworld.txt")
+        .build();
+
+    Response response1 = client.newCall(request).execute();
+    if (!response1.isSuccessful()) throw new IOException("Unexpected code " + response1);
+
+    String response1Body = response1.body().string();
+    System.out.println("Response 1 response:          " + response1);
+    System.out.println("Response 1 cache response:    " + response1.cacheResponse());
+    System.out.println("Response 1 network response:  " + response1.networkResponse());
+
+    Response response2 = client.newCall(request).execute();
+    if (!response2.isSuccessful()) throw new IOException("Unexpected code " + response2);
+
+    String response2Body = response2.body().string();
+    System.out.println("Response 2 response:          " + response2);
+    System.out.println("Response 2 cache response:    " + response2.cacheResponse());
+    System.out.println("Response 2 network response:  " + response2.networkResponse());
+
+    System.out.println("Response 2 equals Response 1? " + response1Body.equals(response2Body));
+  }
+
+  public static void main(String... args) throws Exception {
+    new CacheResponse(new File("CacheResponse.tmp")).run();
+  }
+}
diff --git a/samples/guide/src/main/java/com/squareup/okhttp/recipes/CancelCall.java b/samples/guide/src/main/java/com/squareup/okhttp/recipes/CancelCall.java
new file mode 100644
index 0000000000..9f8d37305c
--- /dev/null
+++ b/samples/guide/src/main/java/com/squareup/okhttp/recipes/CancelCall.java
@@ -0,0 +1,62 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.okhttp.recipes;
+
+import com.squareup.okhttp.Call;
+import com.squareup.okhttp.OkHttpClient;
+import com.squareup.okhttp.Request;
+import com.squareup.okhttp.Response;
+import java.io.IOException;
+import java.util.concurrent.Executors;
+import java.util.concurrent.ScheduledExecutorService;
+import java.util.concurrent.TimeUnit;
+
+public class CancelCall {
+  private final ScheduledExecutorService executor = Executors.newScheduledThreadPool(1);
+  private final OkHttpClient client = new OkHttpClient();
+
+  public void run() throws Exception {
+    Request request = new Request.Builder()
+        .url("http://httpbin.org/delay/2") // This URL is served with a 2 second delay.
+        .build();
+
+    final long startNanos = System.nanoTime();
+    final Call call = client.newCall(request);
+
+    // Schedule a job to cancel the call in 1 second.
+    executor.schedule(new Runnable() {
+      @Override public void run() {
+        System.out.printf("%.2f Canceling call.%n", (System.nanoTime() - startNanos) / 1e9f);
+        call.cancel();
+        System.out.printf("%.2f Canceled call.%n", (System.nanoTime() - startNanos) / 1e9f);
+      }
+    }, 1, TimeUnit.SECONDS);
+
+    try {
+      System.out.printf("%.2f Executing call.%n", (System.nanoTime() - startNanos) / 1e9f);
+      Response response = call.execute();
+      System.out.printf("%.2f Call was expected to fail, but completed: %s%n",
+          (System.nanoTime() - startNanos) / 1e9f, response);
+    } catch (IOException e) {
+      System.out.printf("%.2f Call failed as expected: %s%n",
+          (System.nanoTime() - startNanos) / 1e9f, e);
+    }
+  }
+
+  public static void main(String... args) throws Exception {
+    new CancelCall().run();
+  }
+}
diff --git a/samples/guide/src/main/java/com/squareup/okhttp/recipes/ConfigureTimeouts.java b/samples/guide/src/main/java/com/squareup/okhttp/recipes/ConfigureTimeouts.java
new file mode 100644
index 0000000000..f358a4564f
--- /dev/null
+++ b/samples/guide/src/main/java/com/squareup/okhttp/recipes/ConfigureTimeouts.java
@@ -0,0 +1,45 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.okhttp.recipes;
+
+import com.squareup.okhttp.OkHttpClient;
+import com.squareup.okhttp.Request;
+import com.squareup.okhttp.Response;
+import java.util.concurrent.TimeUnit;
+
+public final class ConfigureTimeouts {
+  private final OkHttpClient client;
+
+  public ConfigureTimeouts() throws Exception {
+    client = new OkHttpClient();
+    client.setConnectTimeout(10, TimeUnit.SECONDS);
+    client.setWriteTimeout(10, TimeUnit.SECONDS);
+    client.setReadTimeout(30, TimeUnit.SECONDS);
+  }
+
+  public void run() throws Exception {
+    Request request = new Request.Builder()
+        .url("http://httpbin.org/delay/2") // This URL is served with a 2 second delay.
+        .build();
+
+    Response response = client.newCall(request).execute();
+    System.out.println("Response completed: " + response);
+  }
+
+  public static void main(String... args) throws Exception {
+    new ConfigureTimeouts().run();
+  }
+}
diff --git a/samples/guide/src/main/java/com/squareup/okhttp/recipes/ParseResponseWithGson.java b/samples/guide/src/main/java/com/squareup/okhttp/recipes/ParseResponseWithGson.java
new file mode 100644
index 0000000000..cf63f0d4b1
--- /dev/null
+++ b/samples/guide/src/main/java/com/squareup/okhttp/recipes/ParseResponseWithGson.java
@@ -0,0 +1,54 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.okhttp.recipes;
+
+import com.google.gson.Gson;
+import com.squareup.okhttp.OkHttpClient;
+import com.squareup.okhttp.Request;
+import com.squareup.okhttp.Response;
+import java.io.IOException;
+import java.util.Map;
+
+public final class ParseResponseWithGson {
+  private final OkHttpClient client = new OkHttpClient();
+  private final Gson gson = new Gson();
+
+  public void run() throws Exception {
+    Request request = new Request.Builder()
+        .url("https://api.github.com/gists/c2a7c39532239ff261be")
+        .build();
+    Response response = client.newCall(request).execute();
+    if (!response.isSuccessful()) throw new IOException("Unexpected code " + response);
+
+    Gist gist = gson.fromJson(response.body().charStream(), Gist.class);
+    for (Map.Entry<String, GistFile> entry : gist.files.entrySet()) {
+      System.out.println(entry.getKey());
+      System.out.println(entry.getValue().content);
+    }
+  }
+
+  static class Gist {
+    Map<String, GistFile> files;
+  }
+
+  static class GistFile {
+    String content;
+  }
+
+  public static void main(String... args) throws Exception {
+    new ParseResponseWithGson().run();
+  }
+}
diff --git a/samples/guide/src/main/java/com/squareup/okhttp/recipes/PerCallSettings.java b/samples/guide/src/main/java/com/squareup/okhttp/recipes/PerCallSettings.java
new file mode 100644
index 0000000000..af4956e17f
--- /dev/null
+++ b/samples/guide/src/main/java/com/squareup/okhttp/recipes/PerCallSettings.java
@@ -0,0 +1,56 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.okhttp.recipes;
+
+import com.squareup.okhttp.OkHttpClient;
+import com.squareup.okhttp.Request;
+import com.squareup.okhttp.Response;
+import java.io.IOException;
+import java.util.concurrent.TimeUnit;
+
+public final class PerCallSettings {
+  private final OkHttpClient client = new OkHttpClient();
+
+  public void run() throws Exception {
+    Request request = new Request.Builder()
+        .url("http://httpbin.org/delay/1") // This URL is served with a 1 second delay.
+        .build();
+
+    try {
+      OkHttpClient cloned = client.clone(); // Clone to make a customized OkHttp for this request.
+      cloned.setReadTimeout(500, TimeUnit.MILLISECONDS);
+
+      Response response = cloned.newCall(request).execute();
+      System.out.println("Response 1 succeeded: " + response);
+    } catch (IOException e) {
+      System.out.println("Response 1 failed: " + e);
+    }
+
+    try {
+      OkHttpClient cloned = client.clone(); // Clone to make a customized OkHttp for this request.
+      cloned.setReadTimeout(3000, TimeUnit.MILLISECONDS);
+
+      Response response = cloned.newCall(request).execute();
+      System.out.println("Response 2 succeeded: " + response);
+    } catch (IOException e) {
+      System.out.println("Response 2 failed: " + e);
+    }
+  }
+
+  public static void main(String... args) throws Exception {
+    new PerCallSettings().run();
+  }
+}
diff --git a/samples/guide/src/main/java/com/squareup/okhttp/recipes/PostFile.java b/samples/guide/src/main/java/com/squareup/okhttp/recipes/PostFile.java
new file mode 100644
index 0000000000..a0d98df45f
--- /dev/null
+++ b/samples/guide/src/main/java/com/squareup/okhttp/recipes/PostFile.java
@@ -0,0 +1,49 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.okhttp.recipes;
+
+import com.squareup.okhttp.MediaType;
+import com.squareup.okhttp.OkHttpClient;
+import com.squareup.okhttp.Request;
+import com.squareup.okhttp.RequestBody;
+import com.squareup.okhttp.Response;
+import java.io.File;
+import java.io.IOException;
+
+public final class PostFile {
+  public static final MediaType MEDIA_TYPE_MARKDOWN
+      = MediaType.parse("text/x-markdown; charset=utf-8");
+
+  private final OkHttpClient client = new OkHttpClient();
+
+  public void run() throws Exception {
+    File file = new File("README.md");
+
+    Request request = new Request.Builder()
+        .url("https://api.github.com/markdown/raw")
+        .post(RequestBody.create(MEDIA_TYPE_MARKDOWN, file))
+        .build();
+
+    Response response = client.newCall(request).execute();
+    if (!response.isSuccessful()) throw new IOException("Unexpected code " + response);
+
+    System.out.println(response.body().string());
+  }
+
+  public static void main(String... args) throws Exception {
+    new PostFile().run();
+  }
+}
diff --git a/samples/guide/src/main/java/com/squareup/okhttp/recipes/PostForm.java b/samples/guide/src/main/java/com/squareup/okhttp/recipes/PostForm.java
new file mode 100644
index 0000000000..30054f1905
--- /dev/null
+++ b/samples/guide/src/main/java/com/squareup/okhttp/recipes/PostForm.java
@@ -0,0 +1,46 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.okhttp.recipes;
+
+import com.squareup.okhttp.FormEncodingBuilder;
+import com.squareup.okhttp.OkHttpClient;
+import com.squareup.okhttp.Request;
+import com.squareup.okhttp.RequestBody;
+import com.squareup.okhttp.Response;
+import java.io.IOException;
+
+public final class PostForm {
+  private final OkHttpClient client = new OkHttpClient();
+
+  public void run() throws Exception {
+    RequestBody formBody = new FormEncodingBuilder()
+        .add("search", "Jurassic Park")
+        .build();
+    Request request = new Request.Builder()
+        .url("https://en.wikipedia.org/w/index.php")
+        .post(formBody)
+        .build();
+
+    Response response = client.newCall(request).execute();
+    if (!response.isSuccessful()) throw new IOException("Unexpected code " + response);
+
+    System.out.println(response.body().string());
+  }
+
+  public static void main(String... args) throws Exception {
+    new PostForm().run();
+  }
+}
diff --git a/samples/guide/src/main/java/com/squareup/okhttp/recipes/PostMultipart.java b/samples/guide/src/main/java/com/squareup/okhttp/recipes/PostMultipart.java
new file mode 100644
index 0000000000..8e5334aa39
--- /dev/null
+++ b/samples/guide/src/main/java/com/squareup/okhttp/recipes/PostMultipart.java
@@ -0,0 +1,62 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.okhttp.recipes;
+
+import com.squareup.okhttp.MediaType;
+import com.squareup.okhttp.MultipartBuilder;
+import com.squareup.okhttp.OkHttpClient;
+import com.squareup.okhttp.Request;
+import com.squareup.okhttp.RequestBody;
+import com.squareup.okhttp.Response;
+import java.io.File;
+import java.io.IOException;
+
+public final class PostMultipart {
+  /**
+   * The imgur client ID for OkHttp recipes. If you're using imgur for anything
+   * other than running these examples, please request your own client ID!
+   *   https://api.imgur.com/oauth2
+   */
+  private static final String IMGUR_CLIENT_ID = "9199fdef135c122";
+  private static final MediaType MEDIA_TYPE_PNG = MediaType.parse("image/png");
+
+  private final OkHttpClient client = new OkHttpClient();
+
+  public void run() throws Exception {
+    // Use the imgur image upload API as documented at https://api.imgur.com/endpoints/image
+    RequestBody requestBody = new MultipartBuilder()
+        .type(MultipartBuilder.FORM)
+        .addFormDataPart("title", "Square Logo")
+        .addFormDataPart("image", null,
+            RequestBody.create(MEDIA_TYPE_PNG, new File("website/static/logo-square.png")))
+        .build();
+
+    Request request = new Request.Builder()
+        .header("Authorization", "Client-ID " + IMGUR_CLIENT_ID)
+        .url("https://api.imgur.com/3/image")
+        .post(requestBody)
+        .build();
+
+    Response response = client.newCall(request).execute();
+    if (!response.isSuccessful()) throw new IOException("Unexpected code " + response);
+
+    System.out.println(response.body().string());
+  }
+
+  public static void main(String... args) throws Exception {
+    new PostMultipart().run();
+  }
+}
diff --git a/samples/guide/src/main/java/com/squareup/okhttp/recipes/PostStreaming.java b/samples/guide/src/main/java/com/squareup/okhttp/recipes/PostStreaming.java
new file mode 100644
index 0000000000..500344c7e9
--- /dev/null
+++ b/samples/guide/src/main/java/com/squareup/okhttp/recipes/PostStreaming.java
@@ -0,0 +1,69 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.okhttp.recipes;
+
+import com.squareup.okhttp.MediaType;
+import com.squareup.okhttp.OkHttpClient;
+import com.squareup.okhttp.Request;
+import com.squareup.okhttp.RequestBody;
+import com.squareup.okhttp.Response;
+import java.io.IOException;
+import okio.BufferedSink;
+
+public final class PostStreaming {
+  public static final MediaType MEDIA_TYPE_MARKDOWN
+      = MediaType.parse("text/x-markdown; charset=utf-8");
+
+  private final OkHttpClient client = new OkHttpClient();
+
+  public void run() throws Exception {
+    RequestBody requestBody = new RequestBody() {
+      @Override public MediaType contentType() {
+        return MEDIA_TYPE_MARKDOWN;
+      }
+
+      @Override public void writeTo(BufferedSink sink) throws IOException {
+        sink.writeUtf8("Numbers\n");
+        sink.writeUtf8("-------\n");
+        for (int i = 2; i <= 997; i++) {
+          sink.writeUtf8(String.format(" * %s = %s\n", i, factor(i)));
+        }
+      }
+
+      private String factor(int n) {
+        for (int i = 2; i < n; i++) {
+          int x = n / i;
+          if (x * i == n) return factor(x) + " × " + i;
+        }
+        return Integer.toString(n);
+      }
+    };
+
+    Request request = new Request.Builder()
+        .url("https://api.github.com/markdown/raw")
+        .post(requestBody)
+        .build();
+
+    Response response = client.newCall(request).execute();
+    if (!response.isSuccessful()) throw new IOException("Unexpected code " + response);
+
+    System.out.println(response.body().string());
+  }
+
+  public static void main(String... args) throws Exception {
+    new PostStreaming().run();
+  }
+}
diff --git a/samples/guide/src/main/java/com/squareup/okhttp/recipes/PostString.java b/samples/guide/src/main/java/com/squareup/okhttp/recipes/PostString.java
new file mode 100644
index 0000000000..943636abb5
--- /dev/null
+++ b/samples/guide/src/main/java/com/squareup/okhttp/recipes/PostString.java
@@ -0,0 +1,54 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.okhttp.recipes;
+
+import com.squareup.okhttp.MediaType;
+import com.squareup.okhttp.OkHttpClient;
+import com.squareup.okhttp.Request;
+import com.squareup.okhttp.RequestBody;
+import com.squareup.okhttp.Response;
+import java.io.IOException;
+
+public final class PostString {
+  public static final MediaType MEDIA_TYPE_MARKDOWN
+      = MediaType.parse("text/x-markdown; charset=utf-8");
+
+  private final OkHttpClient client = new OkHttpClient();
+
+  public void run() throws Exception {
+    String postBody = ""
+        + "Releases\n"
+        + "--------\n"
+        + "\n"
+        + " * _1.0_ May 6, 2013\n"
+        + " * _1.1_ June 15, 2013\n"
+        + " * _1.2_ August 11, 2013\n";
+
+    Request request = new Request.Builder()
+        .url("https://api.github.com/markdown/raw")
+        .post(RequestBody.create(MEDIA_TYPE_MARKDOWN, postBody))
+        .build();
+
+    Response response = client.newCall(request).execute();
+    if (!response.isSuccessful()) throw new IOException("Unexpected code " + response);
+
+    System.out.println(response.body().string());
+  }
+
+  public static void main(String... args) throws Exception {
+    new PostString().run();
+  }
+}
diff --git a/samples/guide/src/main/java/com/squareup/okhttp/recipes/SynchronousGet.java b/samples/guide/src/main/java/com/squareup/okhttp/recipes/SynchronousGet.java
new file mode 100644
index 0000000000..3c1ad20842
--- /dev/null
+++ b/samples/guide/src/main/java/com/squareup/okhttp/recipes/SynchronousGet.java
@@ -0,0 +1,46 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.okhttp.recipes;
+
+import com.squareup.okhttp.Headers;
+import com.squareup.okhttp.OkHttpClient;
+import com.squareup.okhttp.Request;
+import com.squareup.okhttp.Response;
+import java.io.IOException;
+
+public final class SynchronousGet {
+  private final OkHttpClient client = new OkHttpClient();
+
+  public void run() throws Exception {
+    Request request = new Request.Builder()
+        .url("http://publicobject.com/helloworld.txt")
+        .build();
+
+    Response response = client.newCall(request).execute();
+    if (!response.isSuccessful()) throw new IOException("Unexpected code " + response);
+
+    Headers responseHeaders = response.headers();
+    for (int i = 0; i < responseHeaders.size(); i++) {
+      System.out.println(responseHeaders.name(i) + ": " + responseHeaders.value(i));
+    }
+
+    System.out.println(response.body().string());
+  }
+
+  public static void main(String... args) throws Exception {
+    new SynchronousGet().run();
+  }
+}
diff --git a/samples/pom.xml b/samples/pom.xml
index b212e99d99..7a41400d90 100644
--- a/samples/pom.xml
+++ b/samples/pom.xml
@@ -6,7 +6,7 @@
   <parent>
     <groupId>com.squareup.okhttp</groupId>
     <artifactId>parent</artifactId>
-    <version>2.0.0-SNAPSHOT</version>
+    <version>2.0.1-SNAPSHOT</version>
   </parent>
 
   <groupId>com.squareup.okhttp.sample</groupId>
@@ -16,6 +16,7 @@
 
   <modules>
     <module>guide</module>
+    <module>crawler</module>
     <module>simple-client</module>
     <module>static-server</module>
   </modules>
diff --git a/samples/simple-client/pom.xml b/samples/simple-client/pom.xml
index 93657e2f2f..484f9d2642 100644
--- a/samples/simple-client/pom.xml
+++ b/samples/simple-client/pom.xml
@@ -6,7 +6,7 @@
   <parent>
     <groupId>com.squareup.okhttp.sample</groupId>
     <artifactId>sample-parent</artifactId>
-    <version>2.0.0-SNAPSHOT</version>
+    <version>2.0.1-SNAPSHOT</version>
   </parent>
 
   <artifactId>simple-client</artifactId>
diff --git a/samples/simple-client/src/main/java/com/squareup/okhttp/sample/OkHttpContributors.java b/samples/simple-client/src/main/java/com/squareup/okhttp/sample/OkHttpContributors.java
index c6424e2dec..e616d41d51 100644
--- a/samples/simple-client/src/main/java/com/squareup/okhttp/sample/OkHttpContributors.java
+++ b/samples/simple-client/src/main/java/com/squareup/okhttp/sample/OkHttpContributors.java
@@ -3,10 +3,9 @@
 import com.google.gson.Gson;
 import com.google.gson.reflect.TypeToken;
 import com.squareup.okhttp.OkHttpClient;
-import java.io.InputStream;
-import java.io.InputStreamReader;
-import java.net.HttpURLConnection;
-import java.net.URL;
+import com.squareup.okhttp.Request;
+import com.squareup.okhttp.Response;
+import java.io.Reader;
 import java.util.Collections;
 import java.util.Comparator;
 import java.util.List;
@@ -27,12 +26,16 @@ public static void main(String... args) throws Exception {
     OkHttpClient client = new OkHttpClient();
 
     // Create request for remote resource.
-    HttpURLConnection connection = client.open(new URL(ENDPOINT));
-    InputStream is = connection.getInputStream();
-    InputStreamReader isr = new InputStreamReader(is);
+    Request request = new Request.Builder()
+        .url(ENDPOINT)
+        .build();
+
+    // Execute the request and retrieve the response.
+    Response response = client.newCall(request).execute();
 
     // Deserialize HTTP response to concrete type.
-    List<Contributor> contributors = GSON.fromJson(isr, CONTRIBUTORS.getType());
+    Reader body = response.body().charStream();
+    List<Contributor> contributors = GSON.fromJson(body, CONTRIBUTORS.getType());
 
     // Sort list by the most contributions.
     Collections.sort(contributors, new Comparator<Contributor>() {
diff --git a/samples/static-server/pom.xml b/samples/static-server/pom.xml
index 70188c725c..b9f3db6f2b 100644
--- a/samples/static-server/pom.xml
+++ b/samples/static-server/pom.xml
@@ -6,7 +6,7 @@
   <parent>
     <groupId>com.squareup.okhttp.sample</groupId>
     <artifactId>sample-parent</artifactId>
-    <version>2.0.0-SNAPSHOT</version>
+    <version>2.0.1-SNAPSHOT</version>
   </parent>
 
   <artifactId>static-server</artifactId>
diff --git a/samples/static-server/src/main/java/com/squareup/okhttp/sample/SampleServer.java b/samples/static-server/src/main/java/com/squareup/okhttp/sample/SampleServer.java
index cb0e24e37a..c7a479ec18 100644
--- a/samples/static-server/src/main/java/com/squareup/okhttp/sample/SampleServer.java
+++ b/samples/static-server/src/main/java/com/squareup/okhttp/sample/SampleServer.java
@@ -16,6 +16,8 @@
 import javax.net.ssl.KeyManagerFactory;
 import javax.net.ssl.SSLContext;
 import javax.net.ssl.TrustManagerFactory;
+import okio.Buffer;
+import okio.Okio;
 
 public class SampleServer extends Dispatcher {
   private final SSLContext sslContext;
@@ -82,9 +84,9 @@ private MockResponse fileToResponse(String path, File file) throws IOException {
         .addHeader("content-type: " + contentType(path));
   }
 
-  private byte[] fileToBytes(File file) throws IOException {
-    byte[] result = new byte[(int) file.length()];
-    Util.readFully(new FileInputStream(file), result);
+  private Buffer fileToBytes(File file) throws IOException {
+    Buffer result = new Buffer();
+    result.writeAll(Okio.source(file));
     return result;
   }
 
diff --git a/website/index.html b/website/index.html
index 9ed87bb821..fcb9ad72f9 100644
--- a/website/index.html
+++ b/website/index.html
@@ -43,7 +43,7 @@ <h2>An <strong>HTTP &amp; SPDY</strong> client for Android and Java applications
         <div class="row">
           <div class="span9">
             <h3 id="overview">Overview</h3>
-            <p>HTTP is the way modern applications network. It’s how we exchange data & media.
+            <p>HTTP is the way modern applications network. It’s how we exchange data &amp; media.
                 Doing HTTP efficiently makes your stuff load faster and saves bandwidth.</p>
 
             <p>OkHttp is an HTTP client that’s efficient by default:</p>
@@ -57,78 +57,62 @@ <h3 id="overview">Overview</h3>
             <p>OkHttp perseveres when the network is troublesome: it will silently recover from
                 common connection problems. If your service has multiple IP addresses OkHttp will
                 attempt alternate addresses if the first connect fails. This is necessary for IPv4+IPv6
-                and for services hosted in redundant data centers. OkHttp also recovers from problematic
-                proxy servers and failed SSL handshakes.</p>
+                and for services hosted in redundant data centers. OkHttp initiates new connections
+                with modern TLS features (SNI, ALPN), and falls back to SSLv3 if the handshake
+                fails.</p>
 
-            <p>You can try OkHttp without rewriting your network code. The core module implements
-                the familiar <code>java.net.HttpURLConnection</code> API. And the optional
-                okhttp-apache module implements the Apache <code>HttpClient</code> API.</p>
+            <p>Using OkHttp is easy. Its 2.0 API is designed with fluent builders and
+                immutability. It supports both synchronous blocking calls and async calls with
+                callbacks.</p>
 
-            <p>OkHttp supports Android 2.2 and above. For Java, the minimum requirement is 1.5.</p>
+            <p>You can try out OkHttp without rewriting your network code. The
+                <code>okhttp-urlconnection</code> module implements the familiar
+                <code>java.net.HttpURLConnection</code> API and the <code>okhttp-apache</code>
+                module implements the Apache <code>HttpClient</code> API.</p>
+
+            <p>OkHttp supports Android 2.3 and above. For Java, the minimum requirement is 1.7.</p>
 
             <h3 id="examples">Examples</h3>
             <h4>Get a URL</h4>
             <p>This program downloads a URL and print its contents as a string. <a href="https://raw.github.com/square/okhttp/master/samples/guide/src/main/java/com/squareup/okhttp/guide/GetExample.java">Full source</a>.
 <pre class="prettyprint">
-    OkHttpClient client = new OkHttpClient();
-
-    String get(URL url) throws IOException {
-      HttpURLConnection connection = client.open(url);
-      InputStream in = null;
-      try {
-        // Read the response.
-        in = connection.getInputStream();
-        byte[] response = readFully(in);
-        return new String(response, "UTF-8");
-      } finally {
-        if (in != null) in.close();
-      }
-    }
+OkHttpClient client = new OkHttpClient();
+
+String run(String url) throws IOException {
+  Request request = new Request.Builder()
+      .url(url)
+      .build();
+
+  Response response = client.newCall(request).execute();
+  return response.body().string();
+}
 </pre>
             <h4>Post to a Server</h4>
             <p>This program posts data to a service. <a href="https://raw.github.com/square/okhttp/master/samples/guide/src/main/java/com/squareup/okhttp/guide/PostExample.java">Full source</a>.
 
 <pre class="prettyprint">
-    OkHttpClient client = new OkHttpClient();
-
-    String post(URL url, byte[] body) throws IOException {
-      HttpURLConnection connection = client.open(url);
-      OutputStream out = null;
-      InputStream in = null;
-      try {
-        // Write the request.
-        connection.setRequestMethod("POST");
-        out = connection.getOutputStream();
-        out.write(body);
-        out.close();
-
-        // Read the response.
-        if (connection.getResponseCode() != HttpURLConnection.HTTP_OK) {
-          throw new IOException("Unexpected HTTP response: "
-              + connection.getResponseCode() + " " + connection.getResponseMessage());
-        }
-        in = connection.getInputStream();
-        return readFirstLine(in);
-      } finally {
-        // Clean up.
-        if (out != null) out.close();
-        if (in != null) in.close();
-      }
-    }
+public static final MediaType JSON
+    = MediaType.parse("application/json; charset=utf-8");
+
+OkHttpClient client = new OkHttpClient();
+
+String post(String url, String json) throws IOException {
+  RequestBody body = RequestBody.create(JSON, json);
+  Request request = new Request.Builder()
+      .url(url)
+      .post(body)
+      .build();
+  Response response = client.newCall(request).execute();
+  return response.body().string();
+}
 </pre>
 
-                <!--
-                TODO
-                Error Handling
-                Authentication
-                Cookies
-                Response Caching
-                Captive Gateways
-                -->
-
             <h3 id="download">Download</h3>
-            <p><a href="http://repository.sonatype.org/service/local/artifact/maven/redirect?r=central-proxy&g=com.squareup.okhttp&a=okhttp&c=jar-with-dependencies&v=LATEST" class="dl version-href">&darr; <span class="version-tag">Latest</span> JAR</a></p>
-            <p>The source code to the OkHttp, its samples, and this website is <a href="http://github.com/square/okhttp">available on GitHub</a>.</p>
+            <p><a href="http://repository.sonatype.org/service/local/artifact/maven/redirect?r=central-proxy&g=com.squareup.okhttp&a=okhttp&v=LATEST" class="dl version-href">&darr; <span class="version-tag">Latest</span> JAR</a></p>
+            <p>You'll also need <a href="http://github.com/square/okio">Okio</a>, which OkHttp
+                uses for fast I/O and resizable buffers. Download the
+                <a href="http://repository.sonatype.org/service/local/artifact/maven/redirect?r=central-proxy&g=com.squareup.okio&a=okio&v=LATEST">latest JAR</a>.
+            <p>The source code to OkHttp, its samples, and this website is <a href="http://github.com/square/okhttp">available on GitHub</a>.</p>
 
             <h4>Maven</h4>
             <pre class="prettyprint">&lt;dependency>
@@ -143,7 +127,7 @@ <h3 id="contributing">Contributing</h3>
             <p>Before your code can be accepted into the project you must also sign the <a href="http://squ.re/sign-the-cla">Individual Contributor License Agreement (CLA)</a>.</p>
 
             <h3 id="license">License</h3>
-            <pre>Copyright 2013 Square, Inc.
+            <pre>Copyright 2014 Square, Inc.
 
 Licensed under the Apache License, Version 2.0 (the "License");
 you may not use this file except in compliance with the License.
@@ -167,6 +151,7 @@ <h3 id="license">License</h3>
                 <li><a href="#license">License</a></li>
               </ul>
               <ul class="nav nav-pills nav-stacked secondary">
+                <li><a href="https://github.com/square/okhttp/wiki">Wiki</a></li>
                 <li><a href="javadoc/index.html">Javadoc</a></li>
                 <li><a href="http://stackoverflow.com/questions/tagged/okhttp?sort=active">StackOverflow</a></li>
               </ul>
