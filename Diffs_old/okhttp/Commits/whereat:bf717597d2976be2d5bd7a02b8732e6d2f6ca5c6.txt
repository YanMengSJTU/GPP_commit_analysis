diff --git a/okhttp-tests/pom.xml b/okhttp-tests/pom.xml
index 59383f4c59..32719350e2 100644
--- a/okhttp-tests/pom.xml
+++ b/okhttp-tests/pom.xml
@@ -50,6 +50,13 @@
       <artifactId>gson</artifactId>
       <scope>test</scope>
     </dependency>
+    <dependency>
+      <groupId>org.mockito</groupId>
+      <artifactId>mockito-all</artifactId>
+      <version>1.9.5</version>
+      <scope>test</scope>
+    </dependency>
+
   </dependencies>
 
   <build>
diff --git a/okhttp-tests/src/test/java/okhttp3/HPKHeaderTest.java b/okhttp-tests/src/test/java/okhttp3/HPKHeaderTest.java
new file mode 100644
index 0000000000..aefa0a2de2
--- /dev/null
+++ b/okhttp-tests/src/test/java/okhttp3/HPKHeaderTest.java
@@ -0,0 +1,141 @@
+package okhttp3;
+
+import okhttp3.internal.framed.Header;
+import okhttp3.internal.http.HeaderException;
+import org.joda.time.DateTime;
+import org.junit.Test;
+
+import static org.junit.Assert.*;
+
+/**
+ * Created by rmaalej on 2/5/16.
+ */
+public class HPKHeaderTest {
+    public static final String PUBLIC_KEY_PINS = "Public-Key-Pins";
+    public static final int MAX_AGE = 5184000;
+    public static final int ONE_SECOND_MILLIS = 1000;
+    private String pinOne = "cUPcTAZWKaASuYWhhneDttWpY3oBAkE3h2+soZS7sWs=";
+    private String pinTwo = "M8HztCzM3elUxkcjR2S5P4hhyBNf6lHkmjAHKhpGPWE=";
+
+    private int maxAge = MAX_AGE;
+    private String reportURI = "https://www.example.net/hpkp-report";
+    private boolean isSubdomainsIncluded = true;
+
+    private String fullHPKPHeader = "pin-sha256=\"cUPcTAZWKaASuYWhhneDttWpY3oBAkE3h2+soZS7sWs=\"; pin-sha256=\"M8HztCzM3elUxkcjR2S5P4hhyBNf6lHkmjAHKhpGPWE=\"; max-age=5184000; includeSubdomains; report-uri=\"https://www.example.net/hpkp-report\"";
+    private String shortHPKPHeader = "pin-sha256=\"cUPcTAZWKaASuYWhhneDttWpY3oBAkE3h2+soZS7sWs=\"; pin-sha256=\"M8HztCzM3elUxkcjR2S5P4hhyBNf6lHkmjAHKhpGPWE=\"; max-age=5184000";
+    private String emptyPinsHPKPHeader = "max-age=5184000";
+
+    @Test public void testSuccessfullCreationFromAllValues() throws HeaderException {
+        HPKPHeader hpkHeader = HPKPHeader.fromHeader(new Header(PUBLIC_KEY_PINS, getFullHPKPHeader()));
+        assertTrue(PUBLIC_KEY_PINS.equals(hpkHeader.getName()));
+        assertTrue(hpkHeader.getMaxAge() == MAX_AGE);
+        assertTrue(hpkHeader.isSubdomainsIncluded());
+        assertTrue("https://www.example.net/hpkp-report".equals(hpkHeader.getReportURI()));
+        assertTrue(hpkHeader.getPins().size() == 2);
+        assertTrue(hpkHeader.getPins().contains(pinOne));
+        assertTrue(hpkHeader.getPins().contains(pinTwo));
+    }
+
+    @Test public void testSuccessfullCreationFromMandatoryValues() throws HeaderException {
+        HPKPHeader hpkHeader = HPKPHeader.fromHeader(new Header(PUBLIC_KEY_PINS, getShortHPKPHeader()));
+        assertTrue(PUBLIC_KEY_PINS.equals(hpkHeader.getName()));
+        assertTrue(hpkHeader.getMaxAge() == MAX_AGE);
+        assertFalse(hpkHeader.isSubdomainsIncluded());
+        assertNull(hpkHeader.getReportURI());
+        assertTrue(hpkHeader.getPins().size() == 2);
+        assertTrue(hpkHeader.getPins().contains(pinOne));
+        assertTrue(hpkHeader.getPins().contains(pinTwo));
+    }
+
+    @Test public void testSuccessfullCreationWithExpirationDate() throws HeaderException {
+        long nowInMillis = DateTime.now().getMillis() +  (MAX_AGE * ONE_SECOND_MILLIS);
+        HPKPHeader hpkHeader = HPKPHeader.fromHeader(new Header(PUBLIC_KEY_PINS, getShortHPKPHeader()));
+        long expirationDateUpperLimitInMillis = DateTime.now().getMillis() +  (MAX_AGE * ONE_SECOND_MILLIS);
+        assertTrue(PUBLIC_KEY_PINS.equals(hpkHeader.getName()));
+        assertTrue(hpkHeader.getMaxAge() == MAX_AGE);
+        assertFalse(hpkHeader.isSubdomainsIncluded());
+        assertNull(hpkHeader.getReportURI());
+        assertTrue(hpkHeader.getPins().size() == 2);
+        assertTrue(hpkHeader.getPins().contains(pinOne));
+        assertTrue(hpkHeader.getPins().contains(pinTwo));
+        // It's an interval since there are some processing that has to be done to create the header
+        assertTrue(hpkHeader.getExpirationDateFromEpoch() >= nowInMillis);
+        assertTrue(hpkHeader.getExpirationDateFromEpoch() <= expirationDateUpperLimitInMillis);
+    }
+
+    @Test public void SuccessfullCreationCaseInsensitiveForPinDirective() throws HeaderException {
+        String shortHeader = getShortHPKPHeader().replace("pin", "PiN");
+        HPKPHeader hpkpHeader = HPKPHeader.fromHeader(new Header(PUBLIC_KEY_PINS, shortHeader));
+        assertTrue(PUBLIC_KEY_PINS.equals(hpkpHeader.getName()));
+        assertTrue(hpkpHeader.getMaxAge() == MAX_AGE);
+        assertFalse(hpkpHeader.isSubdomainsIncluded());
+        assertNull(hpkpHeader.getReportURI());
+        assertTrue(hpkpHeader.getPins().size() == 2);
+        assertTrue(hpkpHeader.getPins().contains(pinOne));
+        assertTrue(hpkpHeader.getPins().contains(pinTwo));
+
+    }
+
+    @Test public void testUnsuccessfulCreationFromNullHeader() {
+        try {
+            HPKPHeader.fromHeader(null);
+            fail("Should have thrown IllegalArgumentException");
+        } catch (HeaderException expected) {
+        }
+    }
+
+    @Test public void testUnsuccessfulCreationFromEmptyHeader() {
+        try {
+            HPKPHeader.fromHeader(new Header(PUBLIC_KEY_PINS, ""));
+            fail("Should have thrown IllegalArgumentException");
+        } catch (HeaderException expected) {
+        }
+    }
+
+    @Test public void testUnsuccessfulCreationFromInvalidHeader() {
+        try {
+            HPKPHeader.fromHeader(new Header(PUBLIC_KEY_PINS, "invalid header"));
+            fail("Should have thrown IllegalArgumentException");
+        } catch (HeaderException expected) {
+        }
+    }
+
+    @Test public void testUnsuccessfulCreationFromEmptyPinList() {
+        try {
+            HPKPHeader.fromHeader(new Header(PUBLIC_KEY_PINS, emptyPinsHPKPHeader));
+            fail("Should have thrown IllegalArgumentException");
+        } catch (HeaderException expected) {
+        }
+    }
+
+    @Test public void testGetFullHPKPHeader() {
+        assertTrue(fullHPKPHeader.equals(getFullHPKPHeader()));
+    }
+
+    @Test public void testGetShortHPKPHeader() {
+        assertTrue(shortHPKPHeader.equals(getShortHPKPHeader()));
+    }
+
+    @Test public void testHeaderEquality() throws HeaderException {
+        HPKPHeader httpHeader1 = HPKPHeader.fromHeader(new Header(PUBLIC_KEY_PINS, "pin-sha256=\"cUPcTAZWKaASuYWhhneDttWpY3oBAkE3h2+soZS7sWs=\"; pin-sha256=\"M8HztCzM3elUxkcjR2S5P4hhyBNf6lHkmjAHKhpGPWE=\"; max-age=5184000; includeSubdomains; report-uri=\"https://www.example.net/hpkp-report\""));
+        HPKPHeader httpHeader2 = HPKPHeader.fromHeader(new Header(PUBLIC_KEY_PINS, "pin-sha256=\"M8HztCzM3elUxkcjR2S5P4hhyBNf6lHkmjAHKhpGPWE=\"; pin-sha256=\"cUPcTAZWKaASuYWhhneDttWpY3oBAkE3h2+soZS7sWs=\"; max-age=5184000; includeSubdomains; report-uri=\"https://www.example.net/hpkp-report\""));
+
+        assertTrue(httpHeader1.equals(httpHeader2));
+        assertTrue(httpHeader1.hashCode() == httpHeader2.hashCode());
+    }
+
+    private String getFullHPKPHeader() {
+        StringBuilder sb = new StringBuilder(getShortHPKPHeader());
+        sb.append("; ").append(isSubdomainsIncluded ? "includeSubdomains;" : "");
+        sb.append(" ").append("report-uri=\"").append(reportURI).append("\"");
+        return sb.toString();
+    }
+
+    private String getShortHPKPHeader() {
+        StringBuilder sb = new StringBuilder();
+        sb.append("pin-sha256=\"").append(pinOne).append("\";")
+        .append(" ").append("pin-sha256=\"").append(pinTwo).append("\";")
+        .append(" ").append("max-age=").append(maxAge);
+        return sb.toString();
+    }
+}
diff --git a/okhttp-tests/src/test/java/okhttp3/HPKPinStoreTest.java b/okhttp-tests/src/test/java/okhttp3/HPKPinStoreTest.java
new file mode 100644
index 0000000000..1957803be7
--- /dev/null
+++ b/okhttp-tests/src/test/java/okhttp3/HPKPinStoreTest.java
@@ -0,0 +1,280 @@
+package okhttp3;
+
+import okhttp3.internal.HeldCertificate;
+import okhttp3.internal.framed.Header;
+import okhttp3.internal.http.HeaderException;
+import okio.ByteString;
+import org.junit.Before;
+import org.junit.Test;
+
+import java.security.GeneralSecurityException;
+import java.util.HashSet;
+import java.util.LinkedHashSet;
+import java.util.Set;
+
+import static org.junit.Assert.fail;
+
+/**
+ * Created by rmaalej on 2/5/16.
+ */
+public class HPKPinStoreTest {
+    public static final String PUBLIC_KEY_PINS = "Public-Key-Pins";
+    private String pinOne = "cUPcTAZWKaASuYWhhneDttWpY3oBAkE3h2+soZS7sWs=";
+    private String pinTwo = "M8HztCzM3elUxkcjR2S5P4hhyBNf6lHkmjAHKhpGPWE=";
+    private HeldCertificate certA1;
+    private String certA1Pin;
+    private ByteString certA1PinBase64;
+
+    private HeldCertificate certA2;
+    private String certA2Pin;
+    private ByteString certA2PinBase64;
+
+    @Before
+    public void setup() {
+        try {
+            certA1 = new HeldCertificate.Builder()
+                    .serialNumber("100")
+                    .build();
+            certA1Pin = HPKPinner.pinCertificate(certA1.certificate);
+            certA1PinBase64 = ByteString.decodeBase64(certA1Pin);
+
+            certA2 = new HeldCertificate.Builder()
+                    .serialNumber("200")
+                    .build();
+            certA2Pin = HPKPinner.pinCertificate(certA2.certificate);
+            certA2PinBase64 = ByteString.decodeBase64(certA2Pin);
+        } catch (GeneralSecurityException e) {
+            throw new AssertionError(e);
+        }
+    }
+
+    @Test
+    public void testSuccessfullAddNonExistingHeader() throws HeaderException {
+        String hostname = "www.google.com";
+        Header httpHeader = buildHeader(certA1Pin);
+        HPKPHeader hpkHeader = HPKPHeader.fromHeader(httpHeader);
+        HPKPinStore hpkPinStore = new HPKPinStore();
+        hpkPinStore.add(hostname, hpkHeader);
+
+        org.junit.Assert.assertTrue(hpkPinStore.getHeaders().size() == 1);
+        org.junit.Assert.assertTrue(hpkPinStore.getHeaders().iterator().next().equals(hpkHeader));
+    }
+
+    @Test public void testEvictExistingHeaderOnMaxAgeZero() throws HeaderException {
+        String hostname = "www.google.com";
+        Header httpHeader = buildHeader(certA1Pin);
+        HPKPHeader hpkHeader = HPKPHeader.fromHeader(httpHeader);
+        HPKPinStore hpkPinStore = new HPKPinStore();
+        hpkPinStore.add(hostname, hpkHeader);
+
+        HPKPHeader hpkHeaderExpired = hpkHeader.builder().maxAge(0).build();
+        hpkPinStore.add(hostname, hpkHeaderExpired);
+
+        org.junit.Assert.assertTrue(hpkPinStore.getHeaders().size() == 0);
+    }
+
+    @Test public void testUpdateHeaderMaxAgeValue() throws HeaderException {
+        String hostname = "www.google.com";
+        Header httpHeader = buildHeader(certA1Pin);
+        HPKPHeader hpkHeader = HPKPHeader.fromHeader(httpHeader);
+        HPKPinStore hpkPinStore = new HPKPinStore();
+        hpkPinStore.add(hostname, hpkHeader);
+
+        HPKPHeader hpkHeaderUpdated = hpkHeader.builder().maxAge(5000).build();
+        hpkPinStore.add(hostname, hpkHeaderUpdated);
+
+        org.junit.Assert.assertTrue(hpkPinStore.getHeaders().size() == 1);
+        org.junit.Assert.assertTrue(hpkHeaderUpdated.equals(hpkPinStore.getHeaders().iterator().next()));
+    }
+
+    @Test public void testUpdateHeaderSubdomainsIncludedValue() throws HeaderException {
+        String hostname = "www.google.com";
+        Header httpHeader = buildHeader(certA1Pin);
+        HPKPHeader hpkHeader = HPKPHeader.fromHeader(httpHeader);
+        HPKPinStore hpkPinStore = new HPKPinStore();
+        hpkPinStore.add(hostname, hpkHeader);
+
+        HPKPHeader hpkHeaderUpdated = hpkHeader.builder().includeSubdomains(!hpkHeader.isSubdomainsIncluded()).build();
+        hpkPinStore.add(hostname, hpkHeaderUpdated);
+
+        org.junit.Assert.assertTrue(hpkPinStore.getHeaders().size() == 1);
+        org.junit.Assert.assertTrue(hpkHeaderUpdated.equals(hpkPinStore.getHeaders().iterator().next()));
+    }
+
+    @Test public void testUpdateHeaderReportURIValue() throws HeaderException {
+        String hostname = "www.google.com";
+        Header httpHeader = buildHeader(certA1Pin);
+        HPKPHeader hpkHeader = HPKPHeader.fromHeader(httpHeader);
+        HPKPinStore hpkPinStore = new HPKPinStore();
+        hpkPinStore.add(hostname, hpkHeader);
+
+        HPKPHeader hpkHeaderUpdated = hpkHeader.builder().reportURI(hpkHeader.getReportURI()+"updated").build();
+        hpkPinStore.add(hostname, hpkHeaderUpdated);
+
+        org.junit.Assert.assertTrue(hpkPinStore.getHeaders().size() == 1);
+        org.junit.Assert.assertTrue(hpkHeaderUpdated.equals(hpkPinStore.getHeaders().iterator().next()));
+    }
+
+    @Test public void testUpdateHeaderReportURIToNonNullValue() throws HeaderException {
+        String hostname = "www.google.com";
+        Header httpHeader = buildHeader(certA1Pin);
+        HPKPHeader hpkHeader = HPKPHeader.fromHeader(httpHeader);
+        HPKPinStore hpkPinStore = new HPKPinStore();
+        hpkPinStore.add(hostname, hpkHeader.builder().reportURI(null).build());
+
+        HPKPHeader hpkHeaderUpdated = hpkHeader.builder().reportURI(hpkHeader.getReportURI()+"updated").build();
+        hpkPinStore.add(hostname, hpkHeaderUpdated);
+
+        org.junit.Assert.assertTrue(hpkPinStore.getHeaders().size() == 1);
+        org.junit.Assert.assertTrue(hpkHeaderUpdated.equals(hpkPinStore.getHeaders().iterator().next()));
+    }
+
+    @Test public void testUnsuccessfullAddHeaderWithEmptyPinList() throws HeaderException {
+        HPKPinStore hpkPinStore = new HPKPinStore();
+        String hostname = "www.google.com";
+
+        Header httpHeader = buildHeader(certA1Pin);
+
+        HPKPHeader hpkHeader = HPKPHeader.fromHeader(httpHeader);
+        HPKPHeader hpkHeaderWithEmpty = hpkHeader.builder().pins(new HashSet()).build();
+
+        try {
+            hpkPinStore.add(hostname, hpkHeaderWithEmpty);
+            fail("Should have thrown IllegalArgumentException");
+        } catch (IllegalArgumentException expected) {
+
+        }
+    }
+
+    @Test public void testUnsuccessfullUpdateOnChangedPinList() throws HeaderException {
+        HPKPinStore hpkPinStore = new HPKPinStore();
+        String hostname = "www.google.com";
+
+        Header httpHeader = buildHeader(certA1Pin);
+
+        HPKPHeader hpkHeader = HPKPHeader.fromHeader(httpHeader);
+        hpkPinStore.add(hostname, hpkHeader);
+
+        Set<String> pins = new LinkedHashSet<>();
+        pins.add(pinOne);
+        pins.add(pinTwo);
+        HPKPHeader hpkHeaderUpdated = hpkHeader.builder().pins(pins).build();
+        hpkPinStore.add(hostname, hpkHeaderUpdated);
+
+        org.junit.Assert.assertTrue(hpkPinStore.getHeaders().size() == 1);
+        org.junit.Assert.assertTrue(hpkHeader.equals(hpkPinStore.getHeaders().iterator().next()));
+    }
+
+    @Test public void testSuccessfullFindPinningInformationForDomain() throws HeaderException {
+        String hostname = "www.google.com";
+        Header httpHeader = buildHeader(certA1Pin);
+        HPKPHeader hpkHeader = HPKPHeader.fromHeader(httpHeader);
+
+        HPKPinStore hpkPinStore = new HPKPinStore();
+        hpkPinStore.add(hostname, hpkHeader);
+
+        HPKPHeader result = hpkPinStore.findPinningInformation(hostname);
+        org.junit.Assert.assertNotNull(result);
+        org.junit.Assert.assertTrue(result.equals(hpkHeader));
+    }
+
+    @Test public void testSuccessfullFindPinningInformationForDomainWithoutSubdomainsIncluded() throws HeaderException {
+        String hostname = "www.google.com";
+        Header httpHeader = buildHeader(certA1Pin);
+        HPKPHeader hpkHeader = HPKPHeader.fromHeader(httpHeader).builder().includeSubdomains(false).build();
+
+        HPKPinStore hpkPinStore = new HPKPinStore();
+        hpkPinStore.add(hostname, hpkHeader);
+
+        HPKPHeader result = hpkPinStore.findPinningInformation(hostname);
+        org.junit.Assert.assertNotNull(result);
+        org.junit.Assert.assertTrue(result.equals(hpkHeader));
+    }
+
+    @Test public void testUnsuccessfullFindPinningInformationForExpired() throws InterruptedException, HeaderException {
+        String hostname = "www.google.com";
+        Header httpHeader = buildHeader(certA1Pin);
+        HPKPHeader hpkHeader = HPKPHeader.fromHeader(httpHeader).builder().maxAge(1).build();
+        HPKPinStore hpkPinStore = new HPKPinStore();
+        hpkPinStore.add(hostname, hpkHeader);
+        Thread.sleep(3000);
+        HPKPHeader result = hpkPinStore.findPinningInformation(hostname);
+        org.junit.Assert.assertNull(result);
+    }
+
+    @Test public void testSuccessfullFindPinningInformationForSubdomainsIfIncluded() throws HeaderException {
+        String hostname = "www.example.net";
+        Header httpHeader = buildHeader(certA1Pin);
+        HPKPHeader hpkHeader = HPKPHeader.fromHeader(httpHeader);
+        HPKPinStore hpkPinStore = new HPKPinStore();
+        hpkPinStore.add(hostname, hpkHeader);
+
+        HPKPHeader result = hpkPinStore.findPinningInformation("demo.example.net");
+        org.junit.Assert.assertNotNull(result);
+        org.junit.Assert.assertTrue(result.equals(hpkHeader));
+    }
+
+    @Test public void testUnSuccessfullFindPinningInformationForSubdomainsIfNotIncluded() throws HeaderException {
+        String hostname = "www.example.net";
+        Header httpHeader = buildHeader(certA1Pin);
+        HPKPHeader hpkHeader = HPKPHeader.fromHeader(httpHeader).builder().includeSubdomains(false).build();
+        HPKPinStore hpkPinStore = new HPKPinStore();
+        hpkPinStore.add(hostname, hpkHeader);
+
+        HPKPHeader result = hpkPinStore.findPinningInformation("demo.example.net");
+        org.junit.Assert.assertNull(result);
+    }
+
+    @Test public void testSuccessfullFindPinningInformationForLongSubdomains() throws HeaderException {
+        String hostname = "www.example.net";
+        Header httpHeader = buildHeader(certA1Pin);
+        HPKPHeader hpkHeader = HPKPHeader.fromHeader(httpHeader);
+        HPKPinStore hpkPinStore = new HPKPinStore();
+        hpkPinStore.add(hostname, hpkHeader);
+
+        HPKPHeader result = hpkPinStore.findPinningInformation("app.demo.example.net");
+        org.junit.Assert.assertNotNull(result);
+        org.junit.Assert.assertTrue(result.equals(hpkHeader));
+    }
+
+    @Test public void testSuccessfulFindPinningInformationForSubdomainIfaParentDomainIsPresentAsWellWithoutSubdomainDirective() throws HeaderException {
+        HPKPinStore hpkPinStore = new HPKPinStore();
+
+        String parentDomain = "www.example.net";
+        Header httpHeader = buildHeader(certA1Pin);
+        HPKPHeader hpkHeader = HPKPHeader.fromHeader(httpHeader).builder().includeSubdomains(false).build();
+        hpkPinStore.add(parentDomain, hpkHeader);
+
+        String subdomain = "demo.example.net";
+        Header httpHeaderSubdomain = buildHeader(certA2Pin);
+        HPKPHeader hpkHeaderSubdomain = HPKPHeader.fromHeader(httpHeaderSubdomain).builder().includeSubdomains(false).build();
+        hpkPinStore.add(subdomain, hpkHeaderSubdomain);
+
+        HPKPHeader result = hpkPinStore.findPinningInformation(subdomain);
+        org.junit.Assert.assertNotNull(result);
+        org.junit.Assert.assertTrue(result.equals(hpkHeaderSubdomain));
+    }
+
+    @Test public void testSuccessfulFindPinningInformationForSubdomainIfaParentDomainIsPresentAsWellWithSubdomainDirective() throws HeaderException {
+        HPKPinStore hpkPinStore = new HPKPinStore();
+
+        String parentDomain = "www.example.net";
+        Header httpHeader = buildHeader(certA1Pin);
+        HPKPHeader hpkHeader = HPKPHeader.fromHeader(httpHeader);
+        hpkPinStore.add(parentDomain, hpkHeader);
+
+        String subdomain = "demo.example.net";
+        Header httpHeaderSubdomain = buildHeader(certA2Pin);
+        HPKPHeader hpkHeaderSubdomain = HPKPHeader.fromHeader(httpHeaderSubdomain).builder().includeSubdomains(false).build();
+        hpkPinStore.add(subdomain, hpkHeaderSubdomain);
+
+        HPKPHeader result = hpkPinStore.findPinningInformation(subdomain);
+        org.junit.Assert.assertNotNull(result);
+        org.junit.Assert.assertTrue(result.equals(hpkHeaderSubdomain));
+    }
+
+    private Header buildHeader(String pin) {
+        String headerString = "pin-sha256=\"%s\"; max-age=5184000; includeSubdomains; report-uri=\"https://www.example.net/hpkp-report\"";
+        return new Header(PUBLIC_KEY_PINS, String.format(headerString, pin));
+    }
+}
diff --git a/okhttp-tests/src/test/java/okhttp3/HPKPinnerTest.java b/okhttp-tests/src/test/java/okhttp3/HPKPinnerTest.java
new file mode 100644
index 0000000000..b9c6a65e7a
--- /dev/null
+++ b/okhttp-tests/src/test/java/okhttp3/HPKPinnerTest.java
@@ -0,0 +1,111 @@
+package okhttp3;
+
+import okhttp3.internal.HeldCertificate;
+import okhttp3.internal.framed.Header;
+import okhttp3.internal.http.HeaderException;
+import okio.ByteString;
+import org.junit.Before;
+import org.junit.Test;
+
+import javax.net.ssl.SSLPeerUnverifiedException;
+import java.security.GeneralSecurityException;
+
+import static org.junit.Assert.fail;
+
+/**
+ * Created by rmaalej on 2/5/16.
+ */
+public class HPKPinnerTest {
+    public static final String PUBLIC_KEY_PINS_HEADER_NAME = "Public-Key-Pins";
+    String headerString = "pin-sha256=\"%s\"; max-age=5184; includeSubdomains; report-uri=\"https://www.example.net/hpkp-report\"";
+    private HPKPinner hpkPinner;
+
+    static HeldCertificate certA1;
+    static String certA1Pin;
+    static ByteString certA1PinBase64;
+    static HeldCertificate certB1;
+    static String certB1Pin;
+    static ByteString certB1PinBase64;
+
+    static HeldCertificate certC1;
+    static String certC1Pin;
+
+    @Before
+    public void setup() {
+        hpkPinner = new HPKPinner(new HPKPinStore());
+
+        try {
+            certA1 = new HeldCertificate.Builder()
+                    .serialNumber("100")
+                    .build();
+            certA1Pin = HPKPinner.pinCertificate(certA1.certificate);
+            certA1PinBase64 = ByteString.decodeBase64(certA1Pin);
+
+            certB1 = new HeldCertificate.Builder()
+                    .serialNumber("200")
+                    .build();
+            certB1Pin = HPKPinner.pinCertificate(certB1.certificate);
+            certB1PinBase64 = ByteString.decodeBase64(certB1Pin);
+
+            certC1 = new HeldCertificate.Builder()
+                    .serialNumber("300")
+                    .build();
+            certC1Pin = HPKPinner.pinCertificate(certC1.certificate);
+        } catch (GeneralSecurityException e) {
+            throw new AssertionError(e);
+        }
+    }
+
+    @Test public void testSuccessfullPinningForKnownDomain() throws HeaderException {
+        String hostname = "www.example.net";
+        Response response = new Response.Builder()
+                .request(new Request.Builder().url("http://www.example.net").build())
+                .protocol(Protocol.HTTP_1_1)
+                .code(200)
+                .addHeader(PUBLIC_KEY_PINS_HEADER_NAME, buildHeader(certA1Pin)).build();
+
+        try {
+            hpkPinner.pinHost(hostname, response, certA1.certificate);
+        } catch (SSLPeerUnverifiedException notExpected) {
+            fail("Exception should not be raised here");
+        }
+    }
+
+    @Test public void testUnsuccessfullPinningForUntrustedPins() throws HeaderException {
+        String hostname = "demo.example.net";
+
+        Response response = new Response.Builder()
+                .request(new Request.Builder().url("http://demo.example.net").build())
+                .protocol(Protocol.HTTP_1_1)
+                .code(200)
+                .addHeader(PUBLIC_KEY_PINS_HEADER_NAME, buildHeader(certA1Pin)).build();
+        try {
+            hpkPinner.pinHost(hostname, response, certB1.certificate);
+            fail("Should have thrown an exception here");
+        } catch (SSLPeerUnverifiedException notExpected) {}
+    }
+
+    @Test public void testUnsuccessfullPinningForUntrustedHostPretendingToBeAKnownHost() {
+        String hostname = "demo.example.net";
+
+        Response response = new Response.Builder()
+                .request(new Request.Builder().url("http://demo.example.net").build())
+                .protocol(Protocol.HTTP_1_1)
+                .code(200)
+                .addHeader(PUBLIC_KEY_PINS_HEADER_NAME, buildHeader(certA1Pin)).build();
+
+        Response untrustedResponse = new Response.Builder()
+                .request(new Request.Builder().url("http://demo.example.net").build())
+                .protocol(Protocol.HTTP_1_1)
+                .code(200).build();
+        try {
+            hpkPinner.pinHost(hostname, response, certA1.certificate);
+            hpkPinner.pinHost(hostname, untrustedResponse, certB1.certificate);
+            fail("Should have thrown an exception here");
+        } catch (SSLPeerUnverifiedException notExpected) {}
+    }
+
+    private String buildHeader(String pin) {
+        return String.format(headerString, pin);
+    }
+}
diff --git a/okhttp-tests/src/test/java/okhttp3/URLConnectionTest.java b/okhttp-tests/src/test/java/okhttp3/URLConnectionTest.java
index 5a68c7aade..2566fb1890 100644
--- a/okhttp-tests/src/test/java/okhttp3/URLConnectionTest.java
+++ b/okhttp-tests/src/test/java/okhttp3/URLConnectionTest.java
@@ -57,15 +57,9 @@
 import javax.net.ssl.SSLSocketFactory;
 import javax.net.ssl.TrustManager;
 import javax.net.ssl.X509TrustManager;
-import okhttp3.internal.DoubleInetAddressDns;
-import okhttp3.internal.Internal;
-import okhttp3.internal.Platform;
-import okhttp3.internal.RecordingAuthenticator;
-import okhttp3.internal.RecordingOkAuthenticator;
-import okhttp3.internal.SingleInetAddressDns;
-import okhttp3.internal.SslContextBuilder;
-import okhttp3.internal.Util;
-import okhttp3.internal.Version;
+
+import okhttp3.internal.*;
+import okhttp3.internal.framed.Header;
 import okhttp3.mockwebserver.MockResponse;
 import okhttp3.mockwebserver.MockWebServer;
 import okhttp3.mockwebserver.RecordedRequest;
@@ -534,6 +528,22 @@ private void doUpload(TransferKind uploadKind, WriteKind writeKind) throws Excep
     assertEquals("GET /foo HTTP/1.1", request.getRequestLine());
   }
 
+  @Test public void connectViaHttpsAndValidateHPKOnFirstUse() throws Exception {
+    server.useHttps(sslContext.getSocketFactory(), false);
+    server.enqueue(new MockResponse().setBody("this response comes via HTTPS"));
+
+    urlFactory.setClient(urlFactory.client().newBuilder()
+            .sslSocketFactory(sslContext.getSocketFactory())
+            .hostnameVerifier(new RecordingHostnameVerifier())
+            .build());
+    connection = urlFactory.open(server.url("/foo").url());
+
+    assertContent("this response comes via HTTPS", connection);
+
+    RecordedRequest request = server.takeRequest();
+    assertEquals("GET /foo HTTP/1.1", request.getRequestLine());
+  }
+
   @Test public void inspectHandshakeThroughoutRequestLifecycle() throws Exception {
     server.useHttps(sslContext.getSocketFactory(), false);
     server.enqueue(new MockResponse());
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/tls/HPKPTest.java b/okhttp-tests/src/test/java/okhttp3/internal/tls/HPKPTest.java
new file mode 100644
index 0000000000..cdcc4d233f
--- /dev/null
+++ b/okhttp-tests/src/test/java/okhttp3/internal/tls/HPKPTest.java
@@ -0,0 +1,132 @@
+package okhttp3.internal.tls;
+
+import okhttp3.*;
+import okhttp3.internal.HeldCertificate;
+import okhttp3.internal.SslContextBuilder;
+import okhttp3.mockwebserver.MockResponse;
+import okhttp3.mockwebserver.MockWebServer;
+import org.junit.Assert;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import org.mockito.Mock;
+
+import javax.net.ssl.SSLContext;
+import javax.net.ssl.SSLPeerUnverifiedException;
+import javax.net.ssl.TrustManager;
+import java.security.GeneralSecurityException;
+import java.security.cert.Certificate;
+import java.util.List;
+
+import static okhttp3.TestUtil.defaultClient;
+import static org.junit.Assert.fail;
+
+/**
+ * Created by rmaalej on 2/9/16.
+ */
+public class HPKPTest {
+    @Rule public final MockWebServer server = new MockWebServer();
+    private OkHttpClient client;
+    private SSLContext sslContext;
+    private HeldCertificate certA1;
+    private String certA1Pin;
+
+    @Before
+    public void setup() throws GeneralSecurityException {
+        client = defaultClient();
+        sslContext = SslContextBuilder.localhost();
+        certA1 = new HeldCertificate.Builder()
+                .serialNumber("100")
+                .build();
+        certA1Pin = HPKPinner.pinCertificate(certA1.certificate);
+    }
+
+    @Test public void testIgnorePinningOnFirstUseOnNonSecureConnection() throws Exception {
+        String pin = "qNS1RuLIIxRR4bdjfPSP9vBr9HU8u01IoWzrbpHOMuI=";
+
+        HttpUrl urlWithIpAddress = url(server, "/path/foo");
+        server.enqueue(new MockResponse().addHeader("Public-Key-Pins: " +
+                "pin-sha256=\""+pin+"\"; " +
+                "max-age=300; " +
+                "includeSubDomains "));
+        get(urlWithIpAddress, client);
+
+        HPKPHeader hpkpHeader = client.hpkPinStore().findPinningInformation(server.getHostName());
+
+        Assert.assertNull(hpkpHeader);
+    }
+
+    @Test public void testSuccessfullPinningOnFirstUseOnSecureConnection() throws Exception {
+        enableTlsForTrustedServer();
+
+        List<Certificate> serverCertificates = getServerCertificates(server, client);
+        String pin = HPKPinner.pinCertificate(serverCertificates.get(0));
+
+        HttpUrl url = url(server, "/path/foo");
+        server.enqueue(new MockResponse().addHeader("Public-Key-Pins: " +
+                "pin-sha256=\"" + pin + "\"; " +
+                "max-age=300; " +
+                "includeSubDomains "));
+        get(url, client);
+
+        HPKPHeader hpkpHeader = client.hpkPinStore().findPinningInformation(server.getHostName());
+
+        Assert.assertNotNull(hpkpHeader);
+        Assert.assertTrue(hpkpHeader.getPins().contains(pin));
+    }
+
+    @Test public void testAbortConnectionOnManInTheMiddleAttackWithoutHPKPHeader() throws Exception {
+        enableTlsForTrustedServer();
+
+        List<Certificate> serverCertificates = getServerCertificates(server, client);
+        String pin = HPKPinner.pinCertificate(serverCertificates.get(0));
+
+        HttpUrl url = url(server, "/path/foo");
+        server.enqueue(new MockResponse().addHeader("Public-Key-Pins: " +
+                "pin-sha256=\"" + pin + "\"; " +
+                "max-age=300; " +
+                "includeSubDomains "));
+        get(url, client);
+
+        HttpUrl url2 = url(server, "/path/foo/2");
+        server.enqueue(new MockResponse());
+        try {
+            get(url2, client);
+            fail("An exception is expected here");
+        } catch (SSLPeerUnverifiedException expected) {
+
+        }
+    }
+
+    private void enableTlsForTrustedServer() {
+        client = client.newBuilder().sslSocketFactory(sslContext.getSocketFactory())
+                .hostnameVerifier(new RecordingHostnameVerifier()).build();
+        server.useHttps(sslContext.getSocketFactory(), false);
+    }
+
+    private HttpUrl url(MockWebServer server, String path) throws Exception {
+        return server.url(path).newBuilder()
+                .host(server.getHostName())
+                .build();
+    }
+
+    private void get(HttpUrl url, OkHttpClient client) throws Exception {
+        Call call = client.newCall(new Request.Builder().url(url).build());
+        Response response = call.execute();
+        response.body().close();
+    }
+
+    private List<Certificate> getServerCertificates(MockWebServer server, OkHttpClient client) throws Exception {
+        List<Certificate> serverCertificates = null;
+        HttpUrl urlWithIpAddress = url(server, "/");
+
+        server.enqueue(new MockResponse());
+
+        Call call = client.newCall(new Request.Builder().url(urlWithIpAddress).build());
+        Response response = call.execute();
+        serverCertificates = response.handshake().peerCertificates();
+        response.body().close();
+
+        return serverCertificates;
+    }
+}
diff --git a/okhttp/pom.xml b/okhttp/pom.xml
index 8629395db6..077fe8a9ec 100644
--- a/okhttp/pom.xml
+++ b/okhttp/pom.xml
@@ -22,6 +22,16 @@
       <artifactId>android</artifactId>
       <scope>provided</scope>
     </dependency>
+    <dependency>
+      <groupId>org.apache.commons</groupId>
+      <artifactId>commons-lang3</artifactId>
+      <version>3.4</version>
+    </dependency>
+    <dependency>
+      <groupId>joda-time</groupId>
+      <artifactId>joda-time</artifactId>
+      <version>2.9.2</version>
+    </dependency>
   </dependencies>
 
   <build>
diff --git a/okhttp/src/main/java/okhttp3/HPKPHeader.java b/okhttp/src/main/java/okhttp3/HPKPHeader.java
new file mode 100644
index 0000000000..df66410624
--- /dev/null
+++ b/okhttp/src/main/java/okhttp3/HPKPHeader.java
@@ -0,0 +1,217 @@
+package okhttp3;
+
+import okhttp3.internal.framed.Header;
+import okhttp3.internal.http.HeaderException;
+import okio.ByteString;
+import org.apache.commons.lang3.math.NumberUtils;
+import org.joda.time.DateTime;
+
+import java.util.Collections;
+import java.util.HashSet;
+import java.util.LinkedHashSet;
+import java.util.Set;
+
+/**
+ * Created by rmaalej on 2/5/16.
+ */
+public class HPKPHeader {
+    private static final String PUBLIC_KEY_PINS_REPORT_ONLY = "Public-Key-Pins-Report-Only";
+    private static final String PUBLIC_KEY_PINS = "Public-Key-Pins";
+    private static final String MAX_AGE_PREFIX = "max-age=";
+    private static final String PIN_SHA256_PREFIX = "pin-sha256=\"";
+    private static final String REPORT_URI_PREFIX = "report-uri=\"";
+    private final String headerName;
+    private final int maxAge;
+    private final long expirationDateFromEpoch;
+    private final boolean subdomainsIncluded;
+    private final String reportURI;
+    private final Set<String> pins;
+
+    public static HPKPHeader fromHeader(Header header) throws HeaderException {
+        if (null == header) {
+            throw new HeaderException("Header cannot be null");
+        }
+        if (null == header.value || header.value.utf8().isEmpty()) {
+            throw new HeaderException("Header value cannot be null or empty");
+        }
+        if (null == header.name || header.name.utf8().isEmpty()) {
+            throw new HeaderException("Header name cannot be null or empty");
+        }
+        if (PUBLIC_KEY_PINS.equals(header.name.utf8())
+                && !header.value.utf8().contains(MAX_AGE_PREFIX)) {
+            throw new HeaderException("Missing max-age directive (See RFC 7469).");
+        }
+
+        boolean includeSubdomains = false;
+        String reportURI = null;
+        int maxAge = 0;
+        long expirationDateFromEpoch = 0;
+        Set<String> pins = new LinkedHashSet<>();
+        String[] headerPairValuesArray = header.value.utf8().split(";");
+
+        for (String headerPairValue : headerPairValuesArray) {
+            String headerPairValueTrimmed = headerPairValue.trim();
+            // pin-sha256 directive is case insensitive1
+            if (headerPairValueTrimmed.toLowerCase().startsWith(PIN_SHA256_PREFIX)) {
+                // -1 to handle "; at the end of the string
+                String pinValue = headerPairValueTrimmed.substring(PIN_SHA256_PREFIX.length(),
+                        headerPairValueTrimmed.length() - 1);
+                if (!isBase64(pinValue)) {
+                    throw new HeaderException(
+                            String.format("pin %s is not a valid base64 string", pinValue));
+                } else {
+                    pins.add(pinValue);
+                }
+            } else if (headerPairValueTrimmed.startsWith(MAX_AGE_PREFIX)) {
+                String maxAgeValue = headerPairValueTrimmed.substring(MAX_AGE_PREFIX.length(),
+                        headerPairValueTrimmed.length());
+
+                if (!NumberUtils.isNumber(maxAgeValue)) {
+                    throw new HeaderException(
+                            String.format("max-age %s is not a valid number", maxAgeValue));
+                }
+                maxAge = Integer.parseInt(maxAgeValue);
+                expirationDateFromEpoch = getExpirationDateFromEpoch(maxAge);
+            } else if (headerPairValueTrimmed.startsWith(REPORT_URI_PREFIX)) {
+                // -1 to handle "; at the end of the string
+                reportURI = headerPairValueTrimmed.substring(REPORT_URI_PREFIX.length(),
+                        headerPairValueTrimmed.length() - 1);
+
+            } else if (headerPairValueTrimmed.contains("includeSubdomains")) {
+                includeSubdomains = true;
+            }
+        }
+
+        if (pins.isEmpty()) {
+            throw new HeaderException("Pins list cannot be empty");
+        }
+
+        return new HPKPHeader(header.name.utf8(), maxAge, includeSubdomains,
+                reportURI, pins, expirationDateFromEpoch);
+    }
+
+    private HPKPHeader(String headerName, int maxAge, boolean subdomainsIncluded,
+                       String reportURI, Set<String> pins, long expirationDateFromEpoch) {
+        this.headerName = headerName;
+        this.maxAge = maxAge;
+        this.subdomainsIncluded = subdomainsIncluded;
+        this.reportURI = reportURI;
+        this.pins = new HashSet<>();
+        this.pins.addAll(pins);
+        this.expirationDateFromEpoch = expirationDateFromEpoch;
+    }
+
+    private HPKPHeader(Builder builder) {
+        this.headerName = builder.headerName;
+        this.maxAge = builder.maxAge;
+        this.subdomainsIncluded = builder.includeSubdomains;
+        this.reportURI = builder.reportURI;
+        this.pins = builder.pins;
+        this.expirationDateFromEpoch = builder.expirationDateFromEpoch;
+    }
+
+    public Builder builder() {
+        return new Builder(this);
+    }
+
+    public long getExpirationDateFromEpoch() { return this.expirationDateFromEpoch; }
+
+    private static long getExpirationDateFromEpoch(int maxAge) {
+        return DateTime.now().getMillis() + (maxAge * 1000);
+    }
+
+    public int getMaxAge() {
+        return maxAge;
+    }
+
+    public boolean isSubdomainsIncluded() {
+        return subdomainsIncluded;
+    }
+
+    public String getReportURI() {
+        return reportURI;
+    }
+
+    public Set<String> getPins() { return Collections.unmodifiableSet(pins); }
+
+    public String getName() {
+        return headerName;
+    }
+
+    private static boolean isBase64(String value) {
+        ByteString decodedPin = ByteString.decodeBase64(value);
+        if (decodedPin == null) {
+            return false;
+        }
+        return true;
+    }
+
+    public static final class Builder {
+        private Set<String> pins = new HashSet<>();
+        private String headerName;
+        private int maxAge;
+        private long expirationDateFromEpoch;
+        private boolean includeSubdomains = false;
+        private String reportURI = null;
+
+        public Builder(HPKPHeader hpkHeader) {
+            this.headerName = hpkHeader.headerName;
+            this.includeSubdomains = hpkHeader.subdomainsIncluded;
+            this.maxAge = hpkHeader.maxAge;
+            this.pins.addAll(hpkHeader.getPins());
+            this.expirationDateFromEpoch = hpkHeader.expirationDateFromEpoch;
+            this.reportURI = hpkHeader.reportURI;
+        }
+
+        public Builder includeSubdomains(boolean includeSubdomains) {
+            this.includeSubdomains = includeSubdomains;
+            return this;
+        }
+
+        public Builder reportURI(String reportURI) {
+            this.reportURI = reportURI;
+            return this;
+        }
+
+        public Builder maxAge(int value) {
+            this.maxAge = value;
+            this.expirationDateFromEpoch = getExpirationDateFromEpoch(value);
+            return this;
+        }
+
+        public Builder pins(Set<String> pins) {
+            this.pins.clear();
+            this.pins.addAll(pins);
+            return this;
+        }
+
+        public HPKPHeader build() {
+            return new HPKPHeader(this);
+        }
+    }
+
+    @Override
+    public boolean equals(Object o) {
+        if (this == o) return true;
+        if (o == null || getClass() != o.getClass()) return false;
+
+        HPKPHeader that = (HPKPHeader) o;
+        if (!headerName.equals(that.headerName)) return false;
+        if (maxAge != that.maxAge) return false;
+        if (subdomainsIncluded != that.subdomainsIncluded) return false;
+        if (reportURI != null ? !reportURI.equals(that.reportURI) : that.reportURI != null) {
+            return false;
+        }
+        return pins.size() == that.pins.size() && pins.containsAll(that.pins);
+    }
+
+    @Override
+    public int hashCode() {
+        int result = maxAge;
+        result = 31 * result + headerName.hashCode();
+        result = 31 * result + (subdomainsIncluded ? 1 : 0);
+        result = 31 * result + (reportURI != null ? reportURI.hashCode() : 0);
+        result = 31 * result + pins.hashCode();
+        return result;
+    }
+}
diff --git a/okhttp/src/main/java/okhttp3/HPKPinStore.java b/okhttp/src/main/java/okhttp3/HPKPinStore.java
new file mode 100644
index 0000000000..c317641d8e
--- /dev/null
+++ b/okhttp/src/main/java/okhttp3/HPKPinStore.java
@@ -0,0 +1,122 @@
+package okhttp3;
+
+import org.joda.time.DateTime;
+
+import java.util.Collection;
+import java.util.Collections;
+import java.util.Map;
+import java.util.concurrent.ConcurrentHashMap;
+
+/**
+ * Created by rmaalej on 2/5/16.
+ */
+public final class HPKPinStore {
+
+    private final Map<String, HPKPHeader> hostHeaders = new ConcurrentHashMap<>();
+
+    public HPKPinStore() { }
+
+    public void add(String hostname, HPKPHeader hpkHeader) {
+        if (null == hpkHeader) {
+            throw new IllegalArgumentException("HPKPHeader cannot be null");
+        }
+        if (hpkHeader.getPins().isEmpty()) {
+            throw new IllegalArgumentException("HPKPHeader pins list cannot be empty");
+        }
+
+        String sanitizedHostname = sanitizeHostname(hostname);
+
+        if (hpkHeader.getMaxAge() == 0) {
+            hostHeaders.remove(sanitizedHostname);
+            return;
+        }
+
+        HPKPHeader oldValue = hostHeaders.put(sanitizedHostname, hpkHeader);
+        if (null != oldValue) {
+            // revert only if both headers don't contain the same list of pins
+            if (shouldRevert(oldValue, hpkHeader)) {
+                hostHeaders.put(sanitizedHostname, oldValue);
+            }
+        }
+    }
+
+    private boolean shouldRevert(HPKPHeader oldHeader, HPKPHeader newHeader) {
+        if (oldHeader.getMaxAge() != newHeader.getMaxAge()
+                && !arePinsDifferent(oldHeader, newHeader)) {
+            return false;
+        }
+        if (oldHeader.isSubdomainsIncluded() != newHeader.isSubdomainsIncluded()
+                && !arePinsDifferent(oldHeader, newHeader)) {
+            return false;
+        }
+        if (!equalsString(oldHeader.getReportURI(), newHeader.getReportURI())
+                && !arePinsDifferent(oldHeader, newHeader)) {
+            return false;
+        }
+        return true;
+    }
+
+    private boolean arePinsDifferent(HPKPHeader oldHeader, HPKPHeader newHeader) {
+        if (oldHeader.getPins().size() == newHeader.getPins().size()
+                && oldHeader.getPins().containsAll(newHeader.getPins())) {
+            return false;
+        }
+        return true;
+    }
+
+    public HPKPHeader findPinningInformation(String hostname) {
+        long nowInMillis = DateTime.now().getMillis();
+        HPKPHeader result = null;
+        int offset = 0;
+        String[] hostnameSegments = sanitizeHostname(hostname).split("\\.");
+
+        while (null == result && offset < hostnameSegments.length) {
+            String hostnameToSearch = getHostnameToSearch(hostnameSegments, offset);
+            result = hostHeaders.get(hostnameToSearch);
+            offset ++;
+        }
+
+        /*
+         * Subdomain pin information are only returned if there is
+         * no direct match and a parent domain has includeSubdomains directive
+         * for offset > 1, a ping is returned only if includeSubdomains directive is present
+         */
+        if (null != result && !result.isSubdomainsIncluded() && offset > 1) {
+            return null;
+        }
+
+        // check the max age, if expired returns null
+        if (null != result && nowInMillis > result.getExpirationDateFromEpoch()) {
+            return null;
+        }
+        return result;
+    }
+
+    private String sanitizeHostname(String hostname) {
+        return hostname.replace("www.", "");
+    }
+
+    private boolean equalsString(String str1, String str2) {
+        if (str1 == str2) {
+            return true;
+        }
+        if (str1 == null) {
+            return str2.equals(str1);
+        }
+        return str1.equals(str2);
+    }
+
+    private String getHostnameToSearch(String[] hostnameSegments, int offset) {
+        StringBuilder sb = new StringBuilder();
+        for (int index = offset; index < hostnameSegments.length; index ++) {
+            sb.append(hostnameSegments[index]).append(".");
+        }
+        // remove trailing .
+        sb.deleteCharAt(sb.length() - 1);
+        return sb.toString();
+    }
+
+    public Collection<HPKPHeader> getHeaders() {
+        return Collections.unmodifiableCollection(hostHeaders.values());
+    }
+}
diff --git a/okhttp/src/main/java/okhttp3/HPKPinner.java b/okhttp/src/main/java/okhttp3/HPKPinner.java
new file mode 100644
index 0000000000..8d2ec51c69
--- /dev/null
+++ b/okhttp/src/main/java/okhttp3/HPKPinner.java
@@ -0,0 +1,79 @@
+package okhttp3;
+
+import okhttp3.internal.Util;
+import okhttp3.internal.framed.Header;
+import okhttp3.internal.http.HeaderException;
+import okio.ByteString;
+import org.apache.commons.lang3.StringUtils;
+
+import javax.net.ssl.SSLPeerUnverifiedException;
+import java.security.cert.Certificate;
+
+/**
+ * Created by rmaalej on 2/5/16.
+ */
+public final class HPKPinner {
+    public static final String PUBLIC_KEY_PINS_HEADER_NAME = "Public-Key-Pins";
+
+    private final HPKPinStore hpkPinStore;
+
+    public HPKPinner(HPKPinStore hpkPinStore) {
+        this.hpkPinStore = hpkPinStore;
+    }
+
+    public void pinHost(String hostname, Response response, Certificate... certificates)
+            throws SSLPeerUnverifiedException {
+
+        HPKPHeader receivedHeaderForHost;
+        HPKPHeader existingHeaderForHost = hpkPinStore.findPinningInformation(hostname);
+        String hpkHeaderValue = response.header(PUBLIC_KEY_PINS_HEADER_NAME);
+
+        // existing host, should perform pin validation
+        if(null != existingHeaderForHost) {
+            try {
+                receivedHeaderForHost = HPKPHeader.fromHeader(new Header(PUBLIC_KEY_PINS_HEADER_NAME, hpkHeaderValue));
+                hpkPinStore.add(hostname, receivedHeaderForHost);
+                pin(existingHeaderForHost, certificates);
+            } catch (Exception e) {
+                throw new SSLPeerUnverifiedException("HPK Pinning has failed.");
+            }
+        } else {
+            // add the host if it's a valid hpk pin
+            try {
+                receivedHeaderForHost = HPKPHeader.fromHeader(new Header(PUBLIC_KEY_PINS_HEADER_NAME, hpkHeaderValue));
+                pin(receivedHeaderForHost, certificates);
+                hpkPinStore.add(hostname, receivedHeaderForHost);
+            } catch (SSLPeerUnverifiedException ssle) {
+                // Pins associated with this host don't match the certificates returned by this host
+                throw ssle;
+            } catch(Exception ex) {
+                // Received invalid HPK header, should log this somewhere,
+                // ignoring the header as per the RFC7469, section 2.3.1
+            }
+        }
+    }
+
+    private void pin(HPKPHeader hPKPHeader, Certificate... certificates)
+            throws SSLPeerUnverifiedException {
+
+        for (Certificate cert : certificates) {
+            String hexHash = pinCertificate(cert);
+            if (hPKPHeader.getPins().contains(hexHash)) {
+                return;
+            }
+        }
+
+        throw new SSLPeerUnverifiedException("HPK Pinning has failed.");
+    }
+
+    public static String pinCertificate(java.security.cert.Certificate certificate) {
+        if (!(certificate instanceof java.security.cert.X509Certificate)) {
+            throw new IllegalArgumentException("HPK pinning requires X509 certificates");
+        }
+        return sha256((java.security.cert.X509Certificate) certificate).base64();
+    }
+
+    private static ByteString sha256(java.security.cert.X509Certificate x509Certificate) {
+        return Util.sha256(ByteString.of(x509Certificate.getPublicKey().getEncoded()));
+    }
+}
diff --git a/okhttp/src/main/java/okhttp3/OkHttpClient.java b/okhttp/src/main/java/okhttp3/OkHttpClient.java
index 85fe409a2b..fa056244aa 100644
--- a/okhttp/src/main/java/okhttp3/OkHttpClient.java
+++ b/okhttp/src/main/java/okhttp3/OkHttpClient.java
@@ -136,6 +136,8 @@ public void apply(ConnectionSpec tlsConfiguration, SSLSocket sslSocket, boolean
   final CertificateAuthorityCouncil certificateAuthorityCouncil;
   final HostnameVerifier hostnameVerifier;
   final CertificatePinner certificatePinner;
+  final HPKPinStore hpkPinStore;
+  final HPKPinner hpkPinner;
   final Authenticator proxyAuthenticator;
   final Authenticator authenticator;
   final ConnectionPool connectionPool;
@@ -195,6 +197,8 @@ private OkHttpClient(Builder builder) {
       this.certificateAuthorityCouncil = builder.certificateAuthorityCouncil;
       this.certificatePinner = builder.certificatePinner;
     }
+    this.hpkPinner = builder.hpkPinner;
+    this.hpkPinStore = builder.hpkPinStore;
     this.hostnameVerifier = builder.hostnameVerifier;
     this.proxyAuthenticator = builder.proxyAuthenticator;
     this.authenticator = builder.authenticator;
@@ -263,6 +267,10 @@ public CertificatePinner certificatePinner() {
     return certificatePinner;
   }
 
+  public HPKPinStore hpkPinStore() { return hpkPinStore; }
+
+  public HPKPinner hpkPinner() { return hpkPinner; }
+
   public Authenticator authenticator() {
     return authenticator;
   }
@@ -344,6 +352,7 @@ public Builder newBuilder() {
     CertificateAuthorityCouncil certificateAuthorityCouncil;
     HostnameVerifier hostnameVerifier;
     CertificatePinner certificatePinner;
+    HPKPinStore hpkPinStore;
     Authenticator proxyAuthenticator;
     Authenticator authenticator;
     ConnectionPool connectionPool;
@@ -354,6 +363,7 @@ public Builder newBuilder() {
     int connectTimeout;
     int readTimeout;
     int writeTimeout;
+    HPKPinner hpkPinner;
 
     public Builder() {
       dispatcher = new Dispatcher();
@@ -364,6 +374,9 @@ public Builder() {
       socketFactory = SocketFactory.getDefault();
       hostnameVerifier = OkHostnameVerifier.INSTANCE;
       certificatePinner = CertificatePinner.DEFAULT;
+      hpkPinStore = new HPKPinStore();
+      hpkPinner = new HPKPinner(hpkPinStore);
+
       proxyAuthenticator = Authenticator.NONE;
       authenticator = Authenticator.NONE;
       connectionPool = new ConnectionPool();
@@ -392,6 +405,8 @@ public Builder() {
       this.certificateAuthorityCouncil = okHttpClient.certificateAuthorityCouncil;
       this.hostnameVerifier = okHttpClient.hostnameVerifier;
       this.certificatePinner = okHttpClient.certificatePinner;
+      this.hpkPinStore = okHttpClient.hpkPinStore;
+      this.hpkPinner = okHttpClient.hpkPinner;
       this.proxyAuthenticator = okHttpClient.proxyAuthenticator;
       this.authenticator = okHttpClient.authenticator;
       this.connectionPool = okHttpClient.connectionPool;
diff --git a/okhttp/src/main/java/okhttp3/internal/Util.java b/okhttp/src/main/java/okhttp3/internal/Util.java
index e9efad04c6..3046807074 100644
--- a/okhttp/src/main/java/okhttp3/internal/Util.java
+++ b/okhttp/src/main/java/okhttp3/internal/Util.java
@@ -223,6 +223,17 @@ public static ByteString sha1(ByteString s) {
     }
   }
 
+  /** Returns a SHA-256 hash of {@code s}. */
+  public static ByteString sha256(ByteString s) {
+    try {
+      MessageDigest messageDigest = MessageDigest.getInstance("SHA-256");
+      byte[] sha256Bytes = messageDigest.digest(s.toByteArray());
+      return ByteString.of(sha256Bytes);
+    } catch (NoSuchAlgorithmException e) {
+      throw new AssertionError(e);
+    }
+  }
+
   /** Returns an immutable copy of {@code list}. */
   public static <T> List<T> immutableList(List<T> list) {
     return Collections.unmodifiableList(new ArrayList<>(list));
diff --git a/okhttp/src/main/java/okhttp3/internal/http/HeaderException.java b/okhttp/src/main/java/okhttp3/internal/http/HeaderException.java
new file mode 100644
index 0000000000..c2fd69e831
--- /dev/null
+++ b/okhttp/src/main/java/okhttp3/internal/http/HeaderException.java
@@ -0,0 +1,22 @@
+package okhttp3.internal.http;
+
+/**
+ * Created by rmaalej on 2/9/16.
+ */
+public class HeaderException extends Exception {
+
+    public HeaderException(String message) {
+        super(message);
+    }
+
+    public HeaderException(String message, Throwable cause) {
+        super(message, cause);
+    }
+
+    public HeaderException(Throwable cause) {
+        super(cause);
+    }
+
+    public HeaderException() {
+    }
+}
diff --git a/okhttp/src/main/java/okhttp3/internal/http/HttpEngine.java b/okhttp/src/main/java/okhttp3/internal/http/HttpEngine.java
index 621d2d85ba..3903531031 100644
--- a/okhttp/src/main/java/okhttp3/internal/http/HttpEngine.java
+++ b/okhttp/src/main/java/okhttp3/internal/http/HttpEngine.java
@@ -20,25 +20,27 @@
 import java.io.IOException;
 import java.net.ProtocolException;
 import java.net.Proxy;
+import java.security.cert.Certificate;
 import java.util.Date;
-import java.util.List;
 import javax.net.ssl.HostnameVerifier;
 import javax.net.ssl.SSLSocketFactory;
-import okhttp3.Address;
-import okhttp3.CertificatePinner;
+
+import java.util.List;
+import okhttp3.OkHttpClient;
+import okhttp3.Request;
+import okhttp3.ResponseBody;
+import okhttp3.Response;
+import okhttp3.MediaType;
+import okhttp3.Headers;
 import okhttp3.Connection;
 import okhttp3.Cookie;
 import okhttp3.CookieJar;
-import okhttp3.Headers;
-import okhttp3.HttpUrl;
 import okhttp3.Interceptor;
-import okhttp3.MediaType;
-import okhttp3.OkHttpClient;
+import okhttp3.Address;
 import okhttp3.Protocol;
-import okhttp3.Request;
-import okhttp3.Response;
-import okhttp3.ResponseBody;
 import okhttp3.Route;
+import okhttp3.HttpUrl;
+import okhttp3.CertificatePinner;
 import okhttp3.internal.Internal;
 import okhttp3.internal.InternalCache;
 import okhttp3.internal.Version;
@@ -708,6 +710,14 @@ public void readResponse() throws IOException {
 
       Response response = readNetworkResponse();
 
+      // Verify HPK only if it's over Secure connection
+      if (request.isHttps()) {
+        String hostname = streamAllocation.connection().route().address().url().host();
+        Certificate[] peerCertificates = (Certificate[])
+                streamAllocation.connection().handshake().peerCertificates().toArray();
+        client.hpkPinner().pinHost(hostname, response, peerCertificates);
+      }
+
       int code = response.code();
       if ((code == 204 || code == 205) && response.body().contentLength() > 0) {
         throw new ProtocolException(
