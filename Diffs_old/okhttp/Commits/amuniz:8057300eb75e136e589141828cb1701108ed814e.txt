diff --git a/okhttp-android-support/src/main/java/okhttp3/internal/huc/CacheAdapter.java b/okhttp-android-support/src/main/java/okhttp3/internal/huc/CacheAdapter.java
index 65d6197fcb..5bca95b937 100644
--- a/okhttp-android-support/src/main/java/okhttp3/internal/huc/CacheAdapter.java
+++ b/okhttp-android-support/src/main/java/okhttp3/internal/huc/CacheAdapter.java
@@ -78,7 +78,7 @@ public ResponseCache getDelegate() {
     // cacheable or the client should be careful about caching it.
   }
 
-  @Override public void update(Response cached, Response network) throws IOException {
+  @Override public void update(Response cached, Response network) {
     // This method is treated as optional and there is no obvious way of implementing it with
     // ResponseCache. Updating headers is useful if the server changes the metadata for a resource
     // (e.g. max age) to extend or truncate the life of that resource in the cache. If the metadata
diff --git a/okhttp-apache/src/main/java/okhttp3/apache/OkApacheClient.java b/okhttp-apache/src/main/java/okhttp3/apache/OkApacheClient.java
index a1af89f867..c95bd710c2 100644
--- a/okhttp-apache/src/main/java/okhttp3/apache/OkApacheClient.java
+++ b/okhttp-apache/src/main/java/okhttp3/apache/OkApacheClient.java
@@ -74,7 +74,7 @@ private static Request transformRequest(HttpRequest request) {
     return builder.build();
   }
 
-  private static HttpResponse transformResponse(Response response) throws IOException {
+  private static HttpResponse transformResponse(Response response) {
     int code = response.code();
     String message = response.message();
     BasicHttpResponse httpResponse = new BasicHttpResponse(HTTP_1_1, code, message);
diff --git a/okhttp-logging-interceptor/src/main/java/okhttp3/logging/HttpLoggingInterceptor.java b/okhttp-logging-interceptor/src/main/java/okhttp3/logging/HttpLoggingInterceptor.java
index cf9c686fdf..061aa787f8 100644
--- a/okhttp-logging-interceptor/src/main/java/okhttp3/logging/HttpLoggingInterceptor.java
+++ b/okhttp-logging-interceptor/src/main/java/okhttp3/logging/HttpLoggingInterceptor.java
@@ -274,7 +274,7 @@ public Level getLevel() {
    * Returns true if the body in question probably contains human readable text. Uses a small sample
    * of code points to detect unicode control characters commonly used in binary file signatures.
    */
-  static boolean isPlaintext(Buffer buffer) throws EOFException {
+  static boolean isPlaintext(Buffer buffer) {
     try {
       Buffer prefix = new Buffer();
       long byteCount = buffer.size() < 64 ? buffer.size() : 64;
diff --git a/okhttp-tests/src/test/java/okhttp3/DelegatingSocketFactory.java b/okhttp-tests/src/test/java/okhttp3/DelegatingSocketFactory.java
index d21f37a31a..33ac2f4e1a 100644
--- a/okhttp-tests/src/test/java/okhttp3/DelegatingSocketFactory.java
+++ b/okhttp-tests/src/test/java/okhttp3/DelegatingSocketFactory.java
@@ -18,7 +18,6 @@
 import java.io.IOException;
 import java.net.InetAddress;
 import java.net.Socket;
-import java.net.UnknownHostException;
 import javax.net.SocketFactory;
 
 /**
@@ -26,41 +25,35 @@
  * overriding {@link #configureSocket(java.net.Socket)}.
  */
 public class DelegatingSocketFactory extends SocketFactory {
-
   private final SocketFactory delegate;
 
   public DelegatingSocketFactory(SocketFactory delegate) {
     this.delegate = delegate;
   }
 
-  @Override
-  public Socket createSocket() throws IOException {
+  @Override public Socket createSocket() throws IOException {
     Socket socket = delegate.createSocket();
     return configureSocket(socket);
   }
 
-  @Override
-  public Socket createSocket(String host, int port) throws IOException, UnknownHostException {
+  @Override public Socket createSocket(String host, int port) throws IOException {
     Socket socket = delegate.createSocket(host, port);
     return configureSocket(socket);
   }
 
-  @Override
-  public Socket createSocket(String host, int port, InetAddress localAddress, int localPort)
-      throws IOException, UnknownHostException {
+  @Override public Socket createSocket(String host, int port, InetAddress localAddress,
+      int localPort) throws IOException {
     Socket socket = delegate.createSocket(host, port, localAddress, localPort);
     return configureSocket(socket);
   }
 
-  @Override
-  public Socket createSocket(InetAddress host, int port) throws IOException {
+  @Override public Socket createSocket(InetAddress host, int port) throws IOException {
     Socket socket = delegate.createSocket(host, port);
     return configureSocket(socket);
   }
 
-  @Override
-  public Socket createSocket(InetAddress host, int port, InetAddress localAddress, int localPort)
-      throws IOException {
+  @Override public Socket createSocket(InetAddress host, int port, InetAddress localAddress,
+      int localPort) throws IOException {
     Socket socket = delegate.createSocket(host, port, localAddress, localPort);
     return configureSocket(socket);
   }
diff --git a/okhttp-tests/src/test/java/okhttp3/FallbackTestClientSocketFactory.java b/okhttp-tests/src/test/java/okhttp3/FallbackTestClientSocketFactory.java
index eb9aaaa2d3..d829566e20 100644
--- a/okhttp-tests/src/test/java/okhttp3/FallbackTestClientSocketFactory.java
+++ b/okhttp-tests/src/test/java/okhttp3/FallbackTestClientSocketFactory.java
@@ -49,7 +49,7 @@ public TlsFallbackScsvDisabledSSLSocket(SSLSocket socket) {
     }
 
     @Override public void setEnabledCipherSuites(String[] suites) {
-      List<String> enabledCipherSuites = new ArrayList<String>(suites.length);
+      List<String> enabledCipherSuites = new ArrayList<>(suites.length);
       for (String suite : suites) {
         if (!suite.equals(TLS_FALLBACK_SCSV)) {
           enabledCipherSuites.add(suite);
diff --git a/okhttp-tests/src/test/java/okhttp3/URLConnectionTest.java b/okhttp-tests/src/test/java/okhttp3/URLConnectionTest.java
index 2abdacdf92..bc653ff2b2 100644
--- a/okhttp-tests/src/test/java/okhttp3/URLConnectionTest.java
+++ b/okhttp-tests/src/test/java/okhttp3/URLConnectionTest.java
@@ -2094,7 +2094,7 @@ private void redirectToAnotherOriginServer(boolean https) throws Exception {
   }
 
   @Test public void redirectWithProxySelector() throws Exception {
-    final List<URI> proxySelectionRequests = new ArrayList<URI>();
+    final List<URI> proxySelectionRequests = new ArrayList<>();
     urlFactory.setClient(urlFactory.client().newBuilder()
         .proxySelector(new ProxySelector() {
           @Override public List<Proxy> select(URI uri) {
@@ -3680,7 +3680,7 @@ public abstract HttpURLConnection connect(
   }
 
   private static class RecordingTrustManager implements X509TrustManager {
-    private final List<String> calls = new ArrayList<String>();
+    private final List<String> calls = new ArrayList<>();
     private final X509TrustManager delegate;
 
     public RecordingTrustManager(X509TrustManager delegate) {
@@ -3702,7 +3702,7 @@ public void checkServerTrusted(X509Certificate[] chain, String authType)
     }
 
     private String certificatesToString(X509Certificate[] certificates) {
-      List<String> result = new ArrayList<String>();
+      List<String> result = new ArrayList<>();
       for (X509Certificate certificate : certificates) {
         result.add(certificate.getSubjectDN() + " " + certificate.getSerialNumber());
       }
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/io/PipeTest.java b/okhttp-tests/src/test/java/okhttp3/internal/io/PipeTest.java
deleted file mode 100644
index 9ff1ccd239..0000000000
--- a/okhttp-tests/src/test/java/okhttp3/internal/io/PipeTest.java
+++ /dev/null
@@ -1,414 +0,0 @@
-/*
- * Copyright (C) 2016 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.internal.io;
-
-import java.io.IOException;
-import java.io.InterruptedIOException;
-import java.util.Random;
-import java.util.concurrent.Callable;
-import java.util.concurrent.Executors;
-import java.util.concurrent.Future;
-import java.util.concurrent.ScheduledExecutorService;
-import java.util.concurrent.TimeUnit;
-import okio.Buffer;
-import okio.ByteString;
-import okio.HashingSink;
-import okio.Source;
-import org.junit.After;
-import org.junit.Test;
-
-import static junit.framework.TestCase.fail;
-import static org.junit.Assert.assertEquals;
-
-public final class PipeTest {
-  final ScheduledExecutorService executorService = Executors.newScheduledThreadPool(2);
-
-  @After public void tearDown() throws Exception {
-    executorService.shutdown();
-  }
-
-  @Test public void test() throws Exception {
-    Pipe pipe = new Pipe(6);
-    pipe.sink.write(new Buffer().writeUtf8("abc"), 3L);
-
-    Source source = pipe.source;
-    Buffer readBuffer = new Buffer();
-    assertEquals(3L, source.read(readBuffer, 6L));
-    assertEquals("abc", readBuffer.readUtf8());
-
-    pipe.sink.close();
-    assertEquals(-1L, source.read(readBuffer, 6L));
-
-    source.close();
-  }
-
-  /**
-   * A producer writes the first 16 MiB of bytes generated by {@code new Random(0)} to a sink, and a
-   * consumer consumes them. Both compute hashes of their data to confirm that they're as expected.
-   */
-  @Test public void largeDataset() throws Exception {
-    final Pipe pipe = new Pipe(1000L); // An awkward size to force producer/consumer exchange.
-    final long totalBytes = 16L * 1024L * 1024L;
-    ByteString expectedHash = ByteString.decodeHex("7c3b224bea749086babe079360cf29f98d88262d");
-
-    // Write data to the sink.
-    Future<ByteString> sinkHash = executorService.submit(new Callable<ByteString>() {
-      @Override public ByteString call() throws Exception {
-        HashingSink hashingSink = HashingSink.sha1(pipe.sink);
-        Random random = new Random(0);
-        byte[] data = new byte[8192];
-
-        Buffer buffer = new Buffer();
-        for (long i = 0L; i < totalBytes; i += data.length) {
-          random.nextBytes(data);
-          buffer.write(data);
-          hashingSink.write(buffer, buffer.size());
-        }
-
-        hashingSink.close();
-        return hashingSink.hash();
-      }
-    });
-
-    // Read data from the source.
-    Future<ByteString> sourceHash = executorService.submit(new Callable<ByteString>() {
-      @Override public ByteString call() throws Exception {
-        Buffer blackhole = new Buffer();
-        HashingSink hashingSink = HashingSink.sha1(blackhole);
-
-        Buffer buffer = new Buffer();
-        while (pipe.source.read(buffer, Long.MAX_VALUE) != -1) {
-          hashingSink.write(buffer, buffer.size());
-          blackhole.clear();
-        }
-
-        pipe.source.close();
-        return hashingSink.hash();
-      }
-    });
-
-    assertEquals(expectedHash, sinkHash.get());
-    assertEquals(expectedHash, sourceHash.get());
-  }
-
-  @Test public void sinkTimeout() throws Exception {
-    Pipe pipe = new Pipe(3);
-    pipe.sink.timeout().timeout(1000, TimeUnit.MILLISECONDS);
-    pipe.sink.write(new Buffer().writeUtf8("abc"), 3L);
-    double start = now();
-    try {
-      pipe.sink.write(new Buffer().writeUtf8("def"), 3L);
-      fail();
-    } catch (InterruptedIOException expected) {
-      assertEquals("timeout", expected.getMessage());
-    }
-    assertElapsed(1000.0, start);
-
-    Buffer readBuffer = new Buffer();
-    assertEquals(3L, pipe.source.read(readBuffer, 6L));
-    assertEquals("abc", readBuffer.readUtf8());
-  }
-
-  @Test public void sourceTimeout() throws Exception {
-    Pipe pipe = new Pipe(3L);
-    pipe.source.timeout().timeout(1000, TimeUnit.MILLISECONDS);
-    double start = now();
-    Buffer readBuffer = new Buffer();
-    try {
-      pipe.source.read(readBuffer, 6L);
-      fail();
-    } catch (InterruptedIOException expected) {
-      assertEquals("timeout", expected.getMessage());
-    }
-    assertElapsed(1000.0, start);
-    assertEquals(0, readBuffer.size());
-  }
-
-  /**
-   * The writer is writing 12 bytes as fast as it can to a 3 byte buffer. The reader alternates
-   * sleeping 1000 ms, then reading 3 bytes. That should make for an approximate timeline like
-   * this:
-   *
-   *    0: writer writes 'abc', blocks 0: reader sleeps until 1000
-   * 1000: reader reads 'abc', sleeps until 2000
-   * 1000: writer writes 'def', blocks
-   * 2000: reader reads 'def', sleeps until 3000
-   * 2000: writer writes 'ghi', blocks
-   * 3000: reader reads 'ghi', sleeps until 4000
-   * 3000: writer writes 'jkl', returns
-   * 24000: reader reads 'jkl', returns
-   *
-   * Because the writer is writing to a buffer, it finishes before the reader does.
-   */
-  @Test public void sinkBlocksOnSlowReader() throws Exception {
-    final Pipe pipe = new Pipe(3L);
-    executorService.execute(new Runnable() {
-      @Override public void run() {
-        try {
-          Buffer buffer = new Buffer();
-          Thread.sleep(1000L);
-          assertEquals(3, pipe.source.read(buffer, Long.MAX_VALUE));
-          assertEquals("abc", buffer.readUtf8());
-          Thread.sleep(1000L);
-          assertEquals(3, pipe.source.read(buffer, Long.MAX_VALUE));
-          assertEquals("def", buffer.readUtf8());
-          Thread.sleep(1000L);
-          assertEquals(3, pipe.source.read(buffer, Long.MAX_VALUE));
-          assertEquals("ghi", buffer.readUtf8());
-          Thread.sleep(1000L);
-          assertEquals(3, pipe.source.read(buffer, Long.MAX_VALUE));
-          assertEquals("jkl", buffer.readUtf8());
-        } catch (IOException | InterruptedException e) {
-          throw new AssertionError();
-        }
-      }
-    });
-
-    double start = now();
-    pipe.sink.write(new Buffer().writeUtf8("abcdefghijkl"), 12);
-    assertElapsed(3000.0, start);
-  }
-
-  @Test public void sinkWriteFailsByClosedReader() throws Exception {
-    final Pipe pipe = new Pipe(3L);
-    executorService.schedule(new Runnable() {
-      @Override public void run() {
-        try {
-          pipe.source.close();
-        } catch (IOException e) {
-          throw new AssertionError();
-        }
-      }
-    }, 1000, TimeUnit.MILLISECONDS);
-
-    double start = now();
-    try {
-      pipe.sink.write(new Buffer().writeUtf8("abcdef"), 6);
-      fail();
-    } catch (IOException expected) {
-      assertEquals("source is closed", expected.getMessage());
-      assertElapsed(1000.0, start);
-    }
-  }
-
-  @Test public void sinkFlushWaitsForReaderToReadEverything() throws Exception {
-    final Buffer readBuffer = new Buffer();
-    final Pipe pipe = new Pipe(100L);
-    executorService.execute(new Runnable() {
-      @Override public void run() {
-        try {
-          Thread.sleep(1000);
-          pipe.source.read(readBuffer, 3);
-          Thread.sleep(1000);
-          pipe.source.read(readBuffer, 3);
-        } catch (InterruptedException | IOException e) {
-          throw new AssertionError(e);
-        }
-      }
-    });
-
-    double start = now();
-    pipe.sink.write(new Buffer().writeUtf8("abcdef"), 6);
-    pipe.sink.flush();
-    assertElapsed(2000.0, start);
-    assertEquals("abcdef", readBuffer.readUtf8());
-  }
-
-  @Test public void sinkFlushFailsIfReaderIsClosedBeforeAllDataIsRead() throws Exception {
-    final Pipe pipe = new Pipe(100L);
-    executorService.execute(new Runnable() {
-      @Override public void run() {
-        try {
-          Thread.sleep(1000);
-          pipe.source.read(new Buffer(), 3);
-          Thread.sleep(1000);
-          pipe.source.close();
-        } catch (InterruptedException | IOException e) {
-          throw new AssertionError(e);
-        }
-      }
-    });
-
-    double start = now();
-    pipe.sink.write(new Buffer().writeUtf8("abcdef"), 6);
-    try {
-      pipe.sink.flush();
-      fail();
-    } catch (IOException expected) {
-      assertEquals("source is closed", expected.getMessage());
-      assertElapsed(2000.0, start);
-    }
-  }
-
-  @Test public void sinkCloseFailsIfReaderIsClosedBeforeAllDataIsRead() throws Exception {
-    final Pipe pipe = new Pipe(100L);
-    executorService.execute(new Runnable() {
-      @Override public void run() {
-        try {
-          Thread.sleep(1000);
-          pipe.source.read(new Buffer(), 3);
-          Thread.sleep(1000);
-          pipe.source.close();
-        } catch (InterruptedException | IOException e) {
-          throw new AssertionError(e);
-        }
-      }
-    });
-
-    double start = now();
-    pipe.sink.write(new Buffer().writeUtf8("abcdef"), 6);
-    try {
-      pipe.sink.close();
-      fail();
-    } catch (IOException expected) {
-      assertEquals("source is closed", expected.getMessage());
-      assertElapsed(2000.0, start);
-    }
-
-    try {
-      pipe.sink.flush();
-      fail();
-    } catch (IllegalStateException expected) {
-      assertEquals("closed", expected.getMessage());
-    }
-  }
-
-  @Test public void sinkClose() throws Exception {
-    Pipe pipe = new Pipe(100L);
-    pipe.sink.close();
-    try {
-      pipe.sink.write(new Buffer().writeUtf8("abc"), 3);
-      fail();
-    } catch (IllegalStateException expected) {
-      assertEquals("closed", expected.getMessage());
-    }
-    try {
-      pipe.sink.flush();
-      fail();
-    } catch (IllegalStateException expected) {
-      assertEquals("closed", expected.getMessage());
-    }
-  }
-
-  @Test public void sinkMultipleClose() throws Exception {
-    Pipe pipe = new Pipe(100L);
-    pipe.sink.close();
-    pipe.sink.close();
-  }
-
-  @Test public void sourceClose() throws Exception {
-    Pipe pipe = new Pipe(100L);
-    pipe.source.close();
-    try {
-      pipe.source.read(new Buffer(), 3);
-      fail();
-    } catch (IllegalStateException expected) {
-      assertEquals("closed", expected.getMessage());
-    }
-  }
-
-  @Test public void sourceMultipleClose() throws Exception {
-    Pipe pipe = new Pipe(100L);
-    pipe.source.close();
-    pipe.source.close();
-  }
-
-  @Test public void sourceReadUnblockedByClosedSink() throws Exception {
-    final Pipe pipe = new Pipe(3L);
-    executorService.schedule(new Runnable() {
-      @Override public void run() {
-        try {
-          pipe.sink.close();
-        } catch (IOException e) {
-          throw new AssertionError();
-        }
-      }
-    }, 1000, TimeUnit.MILLISECONDS);
-
-    double start = now();
-    Buffer readBuffer = new Buffer();
-    assertEquals(-1, pipe.source.read(readBuffer, Long.MAX_VALUE));
-    assertEquals(0, readBuffer.size());
-    assertElapsed(1000.0, start);
-  }
-
-  /**
-   * The writer has 12 bytes to write. It alternates sleeping 1000 ms, then writing 3 bytes. The
-   * reader is reading as fast as it can. That should make for an approximate timeline like this:
-   *
-   *    0: writer sleeps until 1000
-   *    0: reader blocks
-   * 1000: writer writes 'abc', sleeps until 2000
-   * 1000: reader reads 'abc'
-   * 2000: writer writes 'def', sleeps until 3000
-   * 2000: reader reads 'def'
-   * 3000: writer writes 'ghi', sleeps until 4000
-   * 3000: reader reads 'ghi'
-   * 4000: writer writes 'jkl', returns
-   * 4000: reader reads 'jkl', returns
-   */
-  @Test public void sourceBlocksOnSlowWriter() throws Exception {
-    final Pipe pipe = new Pipe(100L);
-    executorService.execute(new Runnable() {
-      @Override public void run() {
-        try {
-          Thread.sleep(1000L);
-          pipe.sink.write(new Buffer().writeUtf8("abc"), 3);
-          Thread.sleep(1000L);
-          pipe.sink.write(new Buffer().writeUtf8("def"), 3);
-          Thread.sleep(1000L);
-          pipe.sink.write(new Buffer().writeUtf8("ghi"), 3);
-          Thread.sleep(1000L);
-          pipe.sink.write(new Buffer().writeUtf8("jkl"), 3);
-        } catch (IOException | InterruptedException e) {
-          throw new AssertionError();
-        }
-      }
-    });
-
-    double start = now();
-    Buffer readBuffer = new Buffer();
-
-    assertEquals(3, pipe.source.read(readBuffer, Long.MAX_VALUE));
-    assertEquals("abc", readBuffer.readUtf8());
-    assertElapsed(1000.0, start);
-
-    assertEquals(3, pipe.source.read(readBuffer, Long.MAX_VALUE));
-    assertEquals("def", readBuffer.readUtf8());
-    assertElapsed(2000.0, start);
-
-    assertEquals(3, pipe.source.read(readBuffer, Long.MAX_VALUE));
-    assertEquals("ghi", readBuffer.readUtf8());
-    assertElapsed(3000.0, start);
-
-    assertEquals(3, pipe.source.read(readBuffer, Long.MAX_VALUE));
-    assertEquals("jkl", readBuffer.readUtf8());
-    assertElapsed(4000.0, start);
-  }
-
-  /** Returns the nanotime in milliseconds as a double for measuring timeouts. */
-  private double now() {
-    return System.nanoTime() / 1000000.0d;
-  }
-
-  /**
-   * Fails the test unless the time from start until now is duration, accepting differences in
-   * -50..+450 milliseconds.
-   */
-  private void assertElapsed(double duration, double start) {
-    assertEquals(duration, now() - start - 200d, 250.0);
-  }
-}
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/io/WaitUntilNotifiedTest.java b/okhttp-tests/src/test/java/okhttp3/internal/io/WaitUntilNotifiedTest.java
deleted file mode 100644
index d2e8dfbffc..0000000000
--- a/okhttp-tests/src/test/java/okhttp3/internal/io/WaitUntilNotifiedTest.java
+++ /dev/null
@@ -1,147 +0,0 @@
-/*
- * Copyright (C) 2016 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.internal.io;
-
-import java.io.InterruptedIOException;
-import java.util.concurrent.Executors;
-import java.util.concurrent.ScheduledExecutorService;
-import java.util.concurrent.TimeUnit;
-import okio.Timeout;
-import org.junit.After;
-import org.junit.Test;
-
-import static junit.framework.TestCase.fail;
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertFalse;
-
-public final class WaitUntilNotifiedTest {
-  final ScheduledExecutorService executorService = Executors.newScheduledThreadPool(0);
-
-  @After public void tearDown() throws Exception {
-    executorService.shutdown();
-  }
-
-  @Test public synchronized void notified() throws Exception {
-    Timeout timeout = new Timeout();
-    timeout.timeout(5000, TimeUnit.MILLISECONDS);
-
-    double start = now();
-    executorService.schedule(new Runnable() {
-      @Override public void run() {
-        synchronized (WaitUntilNotifiedTest.this) {
-          WaitUntilNotifiedTest.this.notify();
-        }
-      }
-    }, 1000, TimeUnit.MILLISECONDS);
-
-    Pipe.waitUntilNotified(this, timeout);
-    assertElapsed(1000.0, start);
-  }
-
-  @Test public synchronized void timeout() throws Exception {
-    Timeout timeout = new Timeout();
-    timeout.timeout(1000, TimeUnit.MILLISECONDS);
-    double start = now();
-    try {
-      Pipe.waitUntilNotified(this, timeout);
-      fail();
-    } catch (InterruptedIOException expected) {
-      assertEquals("timeout", expected.getMessage());
-    }
-    assertElapsed(1000.0, start);
-  }
-
-  @Test public synchronized void deadline() throws Exception {
-    Timeout timeout = new Timeout();
-    timeout.deadline(1000, TimeUnit.MILLISECONDS);
-    double start = now();
-    try {
-      Pipe.waitUntilNotified(this, timeout);
-      fail();
-    } catch (InterruptedIOException expected) {
-      assertEquals("timeout", expected.getMessage());
-    }
-    assertElapsed(1000.0, start);
-  }
-
-  @Test public synchronized void deadlineBeforeTimeout() throws Exception {
-    Timeout timeout = new Timeout();
-    timeout.timeout(5000, TimeUnit.MILLISECONDS);
-    timeout.deadline(1000, TimeUnit.MILLISECONDS);
-    double start = now();
-    try {
-      Pipe.waitUntilNotified(this, timeout);
-      fail();
-    } catch (InterruptedIOException expected) {
-      assertEquals("timeout", expected.getMessage());
-    }
-    assertElapsed(1000.0, start);
-  }
-
-  @Test public synchronized void timeoutBeforeDeadline() throws Exception {
-    Timeout timeout = new Timeout();
-    timeout.timeout(1000, TimeUnit.MILLISECONDS);
-    timeout.deadline(5000, TimeUnit.MILLISECONDS);
-    double start = now();
-    try {
-      Pipe.waitUntilNotified(this, timeout);
-      fail();
-    } catch (InterruptedIOException expected) {
-      assertEquals("timeout", expected.getMessage());
-    }
-    assertElapsed(1000.0, start);
-  }
-
-  @Test public synchronized void deadlineAlreadyReached() throws Exception {
-    Timeout timeout = new Timeout();
-    timeout.deadlineNanoTime(System.nanoTime());
-    double start = now();
-    try {
-      Pipe.waitUntilNotified(this, timeout);
-      fail();
-    } catch (InterruptedIOException expected) {
-      assertEquals("timeout", expected.getMessage());
-    }
-    assertElapsed(0.0, start);
-  }
-
-  @Test public synchronized void threadInterrupted() throws Exception {
-    Timeout timeout = new Timeout();
-    double start = now();
-    Thread.currentThread().interrupt();
-    try {
-      Pipe.waitUntilNotified(this, timeout);
-      fail();
-    } catch (InterruptedIOException expected) {
-      assertEquals("interrupted", expected.getMessage());
-      assertFalse(Thread.interrupted());
-    }
-    assertElapsed(0.0, start);
-  }
-
-  /** Returns the nanotime in milliseconds as a double for measuring timeouts. */
-  private double now() {
-    return System.nanoTime() / 1000000.0d;
-  }
-
-  /**
-   * Fails the test unless the time from start until now is duration, accepting differences in
-   * -50..+450 milliseconds.
-   */
-  private void assertElapsed(double duration, double start) {
-    assertEquals(duration, now() - start - 200d, 250.0);
-  }
-}
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/platform/OptionalMethodTest.java b/okhttp-tests/src/test/java/okhttp3/internal/platform/OptionalMethodTest.java
index e6c51fad62..82ac18fc14 100644
--- a/okhttp-tests/src/test/java/okhttp3/internal/platform/OptionalMethodTest.java
+++ b/okhttp-tests/src/test/java/okhttp3/internal/platform/OptionalMethodTest.java
@@ -75,32 +75,32 @@ protected void nonPublic() {
   }
 
   private final static OptionalMethod<BaseClass> STRING_METHOD_RETURNS_ANY =
-      new OptionalMethod<BaseClass>(null, "stringMethod");
+      new OptionalMethod<>(null, "stringMethod");
   private final static OptionalMethod<BaseClass> STRING_METHOD_RETURNS_STRING =
-      new OptionalMethod<BaseClass>(String.class, "stringMethod");
+      new OptionalMethod<>(String.class, "stringMethod");
   private final static OptionalMethod<BaseClass> STRING_METHOD_RETURNS_INT =
-      new OptionalMethod<BaseClass>(Integer.TYPE, "stringMethod");
+      new OptionalMethod<>(Integer.TYPE, "stringMethod");
   private final static OptionalMethod<BaseClass> VOID_METHOD_RETURNS_ANY =
-      new OptionalMethod<BaseClass>(null, "voidMethod");
+      new OptionalMethod<>(null, "voidMethod");
   private final static OptionalMethod<BaseClass> VOID_METHOD_RETURNS_VOID =
-      new OptionalMethod<BaseClass>(Void.TYPE, "voidMethod");
+      new OptionalMethod<>(Void.TYPE, "voidMethod");
   private final static OptionalMethod<BaseClass> SUBCLASS_METHOD_RETURNS_ANY =
-      new OptionalMethod<BaseClass>(null, "subclassMethod");
+      new OptionalMethod<>(null, "subclassMethod");
   private final static OptionalMethod<BaseClass> SUBCLASS_METHOD_RETURNS_STRING =
-      new OptionalMethod<BaseClass>(String.class, "subclassMethod");
+      new OptionalMethod<>(String.class, "subclassMethod");
   private final static OptionalMethod<BaseClass> SUBCLASS_METHOD_RETURNS_INT =
-      new OptionalMethod<BaseClass>(Integer.TYPE, "subclassMethod");
+      new OptionalMethod<>(Integer.TYPE, "subclassMethod");
   private final static OptionalMethod<BaseClass> METHOD_WITH_ARGS_WRONG_PARAMS =
-      new OptionalMethod<BaseClass>(null, "methodWithArgs", Integer.class);
+      new OptionalMethod<>(null, "methodWithArgs", Integer.class);
   private final static OptionalMethod<BaseClass> METHOD_WITH_ARGS_CORRECT_PARAMS =
-      new OptionalMethod<BaseClass>(null, "methodWithArgs", String.class);
+      new OptionalMethod<>(null, "methodWithArgs", String.class);
 
   private final static OptionalMethod<BaseClass> THROWS_EXCEPTION =
-      new OptionalMethod<BaseClass>(null, "throwsException");
+      new OptionalMethod<>(null, "throwsException");
   private final static OptionalMethod<BaseClass> THROWS_RUNTIME_EXCEPTION =
-      new OptionalMethod<BaseClass>(null, "throwsRuntimeException");
+      new OptionalMethod<>(null, "throwsRuntimeException");
   private final static OptionalMethod<BaseClass> NON_PUBLIC =
-      new OptionalMethod<BaseClass>(null, "nonPublic");
+      new OptionalMethod<>(null, "nonPublic");
 
   @Test
   public void isSupported() throws Exception {
diff --git a/okhttp-urlconnection/src/main/java/okhttp3/internal/huc/OkHttpURLConnection.java b/okhttp-urlconnection/src/main/java/okhttp3/internal/huc/OkHttpURLConnection.java
index a7632c814b..b67ea730bb 100644
--- a/okhttp-urlconnection/src/main/java/okhttp3/internal/huc/OkHttpURLConnection.java
+++ b/okhttp-urlconnection/src/main/java/okhttp3/internal/huc/OkHttpURLConnection.java
@@ -593,8 +593,6 @@ private void setProtocols(String protocolsString, boolean append) {
       @Override public Response intercept(Chain chain) throws IOException {
         try {
           return chain.proceed(chain.request());
-        } catch (IOException e) {
-          throw e;
         } catch (Error | RuntimeException e) {
           throw new UnexpectedException(e);
         }
diff --git a/okhttp-urlconnection/src/main/java/okhttp3/internal/huc/OutputStreamRequestBody.java b/okhttp-urlconnection/src/main/java/okhttp3/internal/huc/OutputStreamRequestBody.java
index e71252c047..6f4e8ef9e9 100644
--- a/okhttp-urlconnection/src/main/java/okhttp3/internal/huc/OutputStreamRequestBody.java
+++ b/okhttp-urlconnection/src/main/java/okhttp3/internal/huc/OutputStreamRequestBody.java
@@ -16,8 +16,10 @@
 package okhttp3.internal.huc;
 
 import java.io.IOException;
+import java.io.InterruptedIOException;
 import java.io.OutputStream;
 import java.net.ProtocolException;
+import java.net.SocketTimeoutException;
 import okhttp3.MediaType;
 import okhttp3.Request;
 import okhttp3.RequestBody;
@@ -58,7 +60,11 @@ protected void initOutputStream(final BufferedSink sink, final long expectedCont
         }
 
         bytesReceived += byteCount;
-        sink.write(source, offset, byteCount);
+        try {
+          sink.write(source, offset, byteCount);
+        } catch (InterruptedIOException e) {
+          throw new SocketTimeoutException(e.getMessage());
+        }
       }
 
       @Override public void flush() throws IOException {
diff --git a/okhttp-urlconnection/src/main/java/okhttp3/internal/huc/StreamedRequestBody.java b/okhttp-urlconnection/src/main/java/okhttp3/internal/huc/StreamedRequestBody.java
index eb5a1c73de..201ab09b66 100644
--- a/okhttp-urlconnection/src/main/java/okhttp3/internal/huc/StreamedRequestBody.java
+++ b/okhttp-urlconnection/src/main/java/okhttp3/internal/huc/StreamedRequestBody.java
@@ -17,10 +17,10 @@
 
 import java.io.IOException;
 import okhttp3.internal.http.UnrepeatableRequestBody;
-import okhttp3.internal.io.Pipe;
 import okio.Buffer;
 import okio.BufferedSink;
 import okio.Okio;
+import okio.Pipe;
 
 /**
  * This request body streams bytes from an application thread to an OkHttp dispatcher thread via a
@@ -30,12 +30,12 @@
   private final Pipe pipe = new Pipe(8192);
 
   StreamedRequestBody(long expectedContentLength) {
-    initOutputStream(Okio.buffer(pipe.sink), expectedContentLength);
+    initOutputStream(Okio.buffer(pipe.sink()), expectedContentLength);
   }
 
   @Override public void writeTo(BufferedSink sink) throws IOException {
     Buffer buffer = new Buffer();
-    while (pipe.source.read(buffer, 8192) != -1L) {
+    while (pipe.source().read(buffer, 8192) != -1L) {
       sink.write(buffer, buffer.size());
     }
   }
diff --git a/okhttp-urlconnection/src/test/java/okhttp3/internal/huc/URLEncodingTest.java b/okhttp-urlconnection/src/test/java/okhttp3/internal/huc/URLEncodingTest.java
index b93d87682a..ec0de83e52 100644
--- a/okhttp-urlconnection/src/test/java/okhttp3/internal/huc/URLEncodingTest.java
+++ b/okhttp-urlconnection/src/test/java/okhttp3/internal/huc/URLEncodingTest.java
@@ -137,7 +137,7 @@ private URI backdoorUrlToUri(URL url) throws Exception {
       @Override public void remove(Request request) throws IOException {
       }
 
-      @Override public void update(Response cached, Response network) throws IOException {
+      @Override public void update(Response cached, Response network) {
       }
 
       @Override public void trackConditionalCacheHit() {
diff --git a/okhttp/src/main/java/okhttp3/Cache.java b/okhttp/src/main/java/okhttp3/Cache.java
index d70ac43205..2f8a9c2405 100644
--- a/okhttp/src/main/java/okhttp3/Cache.java
+++ b/okhttp/src/main/java/okhttp3/Cache.java
@@ -152,7 +152,7 @@
       Cache.this.remove(request);
     }
 
-    @Override public void update(Response cached, Response network) throws IOException {
+    @Override public void update(Response cached, Response network) {
       Cache.this.update(cached, network);
     }
 
@@ -217,7 +217,7 @@ Response get(Request request) {
     return response;
   }
 
-  private CacheRequest put(Response response) throws IOException {
+  private CacheRequest put(Response response) {
     String requestMethod = response.request().method();
 
     if (HttpMethod.invalidatesCache(response.request().method())) {
@@ -432,7 +432,7 @@ public synchronized int requestCount() {
     private boolean done;
     private Sink body;
 
-    public CacheRequestImpl(final DiskLruCache.Editor editor) throws IOException {
+    public CacheRequestImpl(final DiskLruCache.Editor editor) {
       this.editor = editor;
       this.cacheOut = editor.newSink(ENTRY_BODY);
       this.body = new ForwardingSink(cacheOut) {
diff --git a/okhttp/src/main/java/okhttp3/CipherSuite.java b/okhttp/src/main/java/okhttp3/CipherSuite.java
index ef51db32ce..3b7cc1f489 100644
--- a/okhttp/src/main/java/okhttp3/CipherSuite.java
+++ b/okhttp/src/main/java/okhttp3/CipherSuite.java
@@ -359,7 +359,6 @@
   // public static final CipherSuite TLS_ECDHE_ECDSA_WITH_AES_256_CCM = of("TLS_ECDHE_ECDSA_WITH_AES_256_CCM", 0xc0ad, 7251, MAX_VALUE, MAX_VALUE);
   // public static final CipherSuite TLS_ECDHE_ECDSA_WITH_AES_128_CCM_8 = of("TLS_ECDHE_ECDSA_WITH_AES_128_CCM_8", 0xc0ae, 7251, MAX_VALUE, MAX_VALUE);
   // public static final CipherSuite TLS_ECDHE_ECDSA_WITH_AES_256_CCM_8 = of("TLS_ECDHE_ECDSA_WITH_AES_256_CCM_8", 0xc0af, 7251, MAX_VALUE, MAX_VALUE);
-  ;
 
   final String javaName;
 
diff --git a/okhttp/src/main/java/okhttp3/internal/Util.java b/okhttp/src/main/java/okhttp3/internal/Util.java
index 0d72116405..a80f482362 100644
--- a/okhttp/src/main/java/okhttp3/internal/Util.java
+++ b/okhttp/src/main/java/okhttp3/internal/Util.java
@@ -29,10 +29,8 @@
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.Collections;
-import java.util.LinkedHashMap;
 import java.util.List;
 import java.util.Locale;
-import java.util.Map;
 import java.util.TimeZone;
 import java.util.concurrent.ThreadFactory;
 import java.util.concurrent.TimeUnit;
@@ -244,11 +242,6 @@ public static ByteString sha256(ByteString s) {
     return Collections.unmodifiableList(Arrays.asList(elements.clone()));
   }
 
-  /** Returns an immutable copy of {@code map}. */
-  public static <K, V> Map<K, V> immutableMap(Map<K, V> map) {
-    return Collections.unmodifiableMap(new LinkedHashMap<>(map));
-  }
-
   public static ThreadFactory threadFactory(final String name, final boolean daemon) {
     return new ThreadFactory() {
       @Override public Thread newThread(Runnable runnable) {
diff --git a/okhttp/src/main/java/okhttp3/internal/cache/CacheInterceptor.java b/okhttp/src/main/java/okhttp3/internal/cache/CacheInterceptor.java
index 424db32b3a..6ec47ed64e 100644
--- a/okhttp/src/main/java/okhttp3/internal/cache/CacheInterceptor.java
+++ b/okhttp/src/main/java/okhttp3/internal/cache/CacheInterceptor.java
@@ -258,7 +258,7 @@ private static boolean validate(Response cached, Response network) {
   }
 
   /** Combines cached headers with a network headers as defined by RFC 2616, 13.5.3. */
-  private static Headers combine(Headers cachedHeaders, Headers networkHeaders) throws IOException {
+  private static Headers combine(Headers cachedHeaders, Headers networkHeaders) {
     Headers.Builder result = new Headers.Builder();
 
     for (int i = 0, size = cachedHeaders.size(); i < size; i++) {
diff --git a/okhttp/src/main/java/okhttp3/internal/cache/DiskLruCache.java b/okhttp/src/main/java/okhttp3/internal/cache/DiskLruCache.java
index 4165d9e746..8b7b7f2a02 100644
--- a/okhttp/src/main/java/okhttp3/internal/cache/DiskLruCache.java
+++ b/okhttp/src/main/java/okhttp3/internal/cache/DiskLruCache.java
@@ -872,7 +872,7 @@ void detach() {
      * Returns an unbuffered input stream to read the last committed value, or null if no value has
      * been committed.
      */
-    public Source newSource(int index) throws IOException {
+    public Source newSource(int index) {
       synchronized (DiskLruCache.this) {
         if (done) {
           throw new IllegalStateException();
@@ -893,7 +893,7 @@ public Source newSource(int index) throws IOException {
      * output stream encounters errors when writing to the filesystem, this edit will be aborted
      * when {@link #commit} is called. The returned output stream does not throw IOExceptions.
      */
-    public Sink newSink(int index) throws IOException {
+    public Sink newSink(int index) {
       synchronized (DiskLruCache.this) {
         if (done) {
           throw new IllegalStateException();
diff --git a/okhttp/src/main/java/okhttp3/internal/cache/InternalCache.java b/okhttp/src/main/java/okhttp3/internal/cache/InternalCache.java
index e68edbf6e7..6c70465b59 100644
--- a/okhttp/src/main/java/okhttp3/internal/cache/InternalCache.java
+++ b/okhttp/src/main/java/okhttp3/internal/cache/InternalCache.java
@@ -39,7 +39,7 @@
    * {@code network}. The cached response body is not updated. If the stored response has changed
    * since {@code cached} was returned, this does nothing.
    */
-  void update(Response cached, Response network) throws IOException;
+  void update(Response cached, Response network);
 
   /** Track an conditional GET that was satisfied by this cache. */
   void trackConditionalCacheHit();
diff --git a/okhttp/src/main/java/okhttp3/internal/connection/RealConnection.java b/okhttp/src/main/java/okhttp3/internal/connection/RealConnection.java
index c21931b602..e2d99431e8 100644
--- a/okhttp/src/main/java/okhttp3/internal/connection/RealConnection.java
+++ b/okhttp/src/main/java/okhttp3/internal/connection/RealConnection.java
@@ -145,7 +145,7 @@ private void buildTunneledConnection(int connectTimeout, int readTimeout, int wr
         throw new ProtocolException("Too many tunnel connections attempted: " + maxAttempts);
       }
 
-      connectSocket(connectTimeout, readTimeout, writeTimeout, connectionSpecSelector);
+      connectSocket(connectTimeout, readTimeout);
       tunnelRequest = createTunnel(readTimeout, writeTimeout, tunnelRequest, url);
 
       if (tunnelRequest == null) break; // Tunnel successfully created.
@@ -164,12 +164,11 @@ private void buildTunneledConnection(int connectTimeout, int readTimeout, int wr
   /** Does all the work necessary to build a full HTTP or HTTPS connection on a raw socket. */
   private void buildConnection(int connectTimeout, int readTimeout, int writeTimeout,
       ConnectionSpecSelector connectionSpecSelector) throws IOException {
-    connectSocket(connectTimeout, readTimeout, writeTimeout, connectionSpecSelector);
+    connectSocket(connectTimeout, readTimeout);
     establishProtocol(readTimeout, writeTimeout, connectionSpecSelector);
   }
 
-  private void connectSocket(int connectTimeout, int readTimeout, int writeTimeout,
-      ConnectionSpecSelector connectionSpecSelector) throws IOException {
+  private void connectSocket(int connectTimeout, int readTimeout) throws IOException {
     Proxy proxy = route.proxy();
     Address address = route.address();
 
@@ -331,7 +330,7 @@ private Request createTunnel(int readTimeout, int writeTimeout, Request tunnelRe
    * is sent unencrypted to the proxy server, so tunnels include only the minimum set of headers.
    * This avoids sending potentially sensitive data like HTTP cookies to the proxy unencrypted.
    */
-  private Request createTunnelRequest() throws IOException {
+  private Request createTunnelRequest() {
     return new Request.Builder()
         .url(route.address().url())
         .header("Host", Util.hostHeader(route.address().url(), true))
@@ -340,11 +339,6 @@ private Request createTunnelRequest() throws IOException {
         .build();
   }
 
-  /** Returns true if {@link #connect} has been attempted on this connection. */
-  boolean isConnected() {
-    return protocol != null;
-  }
-
   @Override public Route route() {
     return route;
   }
diff --git a/okhttp/src/main/java/okhttp3/internal/connection/StreamAllocation.java b/okhttp/src/main/java/okhttp3/internal/connection/StreamAllocation.java
index 92d421b661..8294f5699c 100644
--- a/okhttp/src/main/java/okhttp3/internal/connection/StreamAllocation.java
+++ b/okhttp/src/main/java/okhttp3/internal/connection/StreamAllocation.java
@@ -88,8 +88,7 @@ public StreamAllocation(ConnectionPool connectionPool, Address address) {
     this.routeSelector = new RouteSelector(address, routeDatabase());
   }
 
-  public HttpStream newStream(OkHttpClient client, boolean doExtensiveHealthChecks)
-      throws IOException {
+  public HttpStream newStream(OkHttpClient client, boolean doExtensiveHealthChecks) {
     int connectTimeout = client.connectTimeoutMillis();
     int readTimeout = client.readTimeoutMillis();
     int writeTimeout = client.writeTimeoutMillis();
diff --git a/okhttp/src/main/java/okhttp3/internal/framed/ErrorCode.java b/okhttp/src/main/java/okhttp3/internal/framed/ErrorCode.java
index 1142319d7e..1088f6736a 100644
--- a/okhttp/src/main/java/okhttp3/internal/framed/ErrorCode.java
+++ b/okhttp/src/main/java/okhttp3/internal/framed/ErrorCode.java
@@ -62,7 +62,7 @@
   public final int spdyRstCode;
   public final int spdyGoAwayCode;
 
-  private ErrorCode(int httpCode, int spdyRstCode, int spdyGoAwayCode) {
+  ErrorCode(int httpCode, int spdyRstCode, int spdyGoAwayCode) {
     this.httpCode = httpCode;
     this.spdyRstCode = spdyRstCode;
     this.spdyGoAwayCode = spdyGoAwayCode;
diff --git a/okhttp/src/main/java/okhttp3/internal/framed/FramedConnection.java b/okhttp/src/main/java/okhttp3/internal/framed/FramedConnection.java
index 3bdd7b351b..68f354c7e1 100644
--- a/okhttp/src/main/java/okhttp3/internal/framed/FramedConnection.java
+++ b/okhttp/src/main/java/okhttp3/internal/framed/FramedConnection.java
@@ -126,7 +126,7 @@
   // Visible for testing
   final Reader readerRunnable;
 
-  private FramedConnection(Builder builder) throws IOException {
+  private FramedConnection(Builder builder) {
     protocol = builder.protocol;
     pushObserver = builder.pushObserver;
     client = builder.client;
@@ -529,7 +529,7 @@ public void setSettings(Settings settings) throws IOException {
      * @param client true if this peer initiated the connection; false if this peer accepted the
      * connection.
      */
-    public Builder(boolean client) throws IOException {
+    public Builder(boolean client) {
       this.client = client;
     }
 
diff --git a/okhttp/src/main/java/okhttp3/internal/framed/Hpack.java b/okhttp/src/main/java/okhttp3/internal/framed/Hpack.java
index 793f7b93a7..f159cd62dc 100644
--- a/okhttp/src/main/java/okhttp3/internal/framed/Hpack.java
+++ b/okhttp/src/main/java/okhttp3/internal/framed/Hpack.java
@@ -371,8 +371,7 @@ ByteString readByteString() throws IOException {
     private static final int SETTINGS_HEADER_TABLE_SIZE = 4096;
 
     private final Buffer out;
-    private final Map<ByteString, Integer> headerStringToDynamicIndex =
-        new LinkedHashMap<ByteString, Integer>();
+    private final Map<ByteString, Integer> headerStringToDynamicIndex = new LinkedHashMap<>();
 
     private int headerTableSizeSetting;
     private int maxDynamicTableByteCount;
@@ -494,7 +493,7 @@ void writeHeaders(List<Header> headerBlock) throws IOException {
     }
 
     // http://tools.ietf.org/html/draft-ietf-httpbis-header-compression-12#section-4.1.1
-    void writeInt(int value, int prefixMask, int bits) throws IOException {
+    void writeInt(int value, int prefixMask, int bits) {
       // Write the raw value for a single byte value.
       if (value < prefixMask) {
         out.writeByte(bits | value);
diff --git a/okhttp/src/main/java/okhttp3/internal/framed/Huffman.java b/okhttp/src/main/java/okhttp3/internal/framed/Huffman.java
index 0c7f3012a7..ac6ac49a90 100644
--- a/okhttp/src/main/java/okhttp3/internal/framed/Huffman.java
+++ b/okhttp/src/main/java/okhttp3/internal/framed/Huffman.java
@@ -124,7 +124,7 @@ int encodedLength(byte[] bytes) {
     return (int) ((len + 7) >> 3);
   }
 
-  byte[] decode(byte[] buf) throws IOException {
+  byte[] decode(byte[] buf) {
     ByteArrayOutputStream baos = new ByteArrayOutputStream();
     Node node = root;
     int current = 0;
diff --git a/okhttp/src/main/java/okhttp3/internal/http/Http1xStream.java b/okhttp/src/main/java/okhttp3/internal/http/Http1xStream.java
index e29a91a191..2ca436a30b 100644
--- a/okhttp/src/main/java/okhttp3/internal/http/Http1xStream.java
+++ b/okhttp/src/main/java/okhttp3/internal/http/Http1xStream.java
@@ -87,7 +87,7 @@ public Http1xStream(OkHttpClient client, StreamAllocation streamAllocation, Buff
     this.sink = sink;
   }
 
-  @Override public Sink createRequestBody(Request request, long contentLength) throws IOException {
+  @Override public Sink createRequestBody(Request request, long contentLength) {
     if ("chunked".equalsIgnoreCase(request.header("Transfer-Encoding"))) {
       // Stream a request body of unknown length.
       return newChunkedSink();
diff --git a/okhttp/src/main/java/okhttp3/internal/http/Http2xStream.java b/okhttp/src/main/java/okhttp3/internal/http/Http2xStream.java
index fc989f0584..ff1adcdbe1 100644
--- a/okhttp/src/main/java/okhttp3/internal/http/Http2xStream.java
+++ b/okhttp/src/main/java/okhttp3/internal/http/Http2xStream.java
@@ -119,7 +119,7 @@ public Http2xStream(
     this.framedConnection = framedConnection;
   }
 
-  @Override public Sink createRequestBody(Request request, long contentLength) throws IOException {
+  @Override public Sink createRequestBody(Request request, long contentLength) {
     return stream.getSink();
   }
 
diff --git a/okhttp/src/main/java/okhttp3/internal/http/HttpHeaders.java b/okhttp/src/main/java/okhttp3/internal/http/HttpHeaders.java
index 5207c996b9..6c68bf9fec 100644
--- a/okhttp/src/main/java/okhttp3/internal/http/HttpHeaders.java
+++ b/okhttp/src/main/java/okhttp3/internal/http/HttpHeaders.java
@@ -38,10 +38,6 @@
   private HttpHeaders() {
   }
 
-  public static long contentLength(Request request) {
-    return contentLength(request.headers());
-  }
-
   public static long contentLength(Response response) {
     return contentLength(response.headers());
   }
diff --git a/okhttp/src/main/java/okhttp3/internal/http/HttpStream.java b/okhttp/src/main/java/okhttp3/internal/http/HttpStream.java
index 3829a7a05a..8db5a162bc 100644
--- a/okhttp/src/main/java/okhttp3/internal/http/HttpStream.java
+++ b/okhttp/src/main/java/okhttp3/internal/http/HttpStream.java
@@ -30,7 +30,7 @@
   int DISCARD_STREAM_TIMEOUT_MILLIS = 100;
 
   /** Returns an output stream where the request body can be streamed. */
-  Sink createRequestBody(Request request, long contentLength) throws IOException;
+  Sink createRequestBody(Request request, long contentLength);
 
   /** This should update the HTTP engine's sentRequestMillis field. */
   void writeRequestHeaders(Request request) throws IOException;
diff --git a/okhttp/src/main/java/okhttp3/internal/io/Pipe.java b/okhttp/src/main/java/okhttp3/internal/io/Pipe.java
deleted file mode 100644
index 82ba9048ad..0000000000
--- a/okhttp/src/main/java/okhttp3/internal/io/Pipe.java
+++ /dev/null
@@ -1,182 +0,0 @@
-/*
- * Copyright (C) 2016 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.internal.io;
-
-import java.io.IOException;
-import java.net.SocketTimeoutException;
-import okio.Buffer;
-import okio.Sink;
-import okio.Source;
-import okio.Timeout;
-
-/**
- * A source and a sink that are attached. The sink's output is the source's input. Typically each
- * is accessed by its own thread: a producer thread writes data to the sink and a consumer thread
- * reads data from the source.
- *
- * <p>This class uses a buffer to decouple source and sink. This buffer has a user-specified maximum
- * size. When a producer thread outruns its consumer the buffer fills up and eventually writes to
- * the sink will block until the consumer has caught up. Symmetrically, if a consumer outruns its
- * producer reads block until there is data to be read. Limits on the amount of time spent waiting
- * for the other party can be configured with {@linkplain Timeout timeouts} on the source and the
- * sink.
- *
- * <p>When the sink is closed, source reads will continue to complete normally until the buffer has
- * been exhausted. At that point reads will return -1, indicating the end of the stream. But if the
- * source is closed first, writes to the sink will immediately fail with an {@link IOException}.
- */
-public final class Pipe {
-  final long maxBufferSize;
-  final Buffer buffer = new Buffer();
-  boolean sinkClosed;
-  boolean sourceClosed;
-  public final Sink sink = new PipeSink();
-  public final Source source = new PipeSource();
-
-  public Pipe(long maxBufferSize) {
-    if (maxBufferSize < 1L) {
-      throw new IllegalArgumentException("maxBufferSize < 1: " + maxBufferSize);
-    }
-    this.maxBufferSize = maxBufferSize;
-  }
-
-  final class PipeSink implements Sink {
-    final Timeout timeout = new Timeout();
-
-    @Override public void write(Buffer source, long byteCount) throws IOException {
-      synchronized (buffer) {
-        if (sinkClosed) throw new IllegalStateException("closed");
-
-        while (byteCount > 0) {
-          if (sourceClosed) throw new IOException("source is closed");
-
-          long bufferSpaceAvailable = maxBufferSize - buffer.size();
-          if (bufferSpaceAvailable == 0) {
-            waitUntilNotified(buffer, timeout); // Wait until the source drains the buffer.
-            continue;
-          }
-
-          long bytesToWrite = Math.min(bufferSpaceAvailable, byteCount);
-          buffer.write(source, bytesToWrite);
-          byteCount -= bytesToWrite;
-          buffer.notifyAll(); // Notify the source that it can resume reading.
-        }
-      }
-    }
-
-    @Override public void flush() throws IOException {
-      synchronized (buffer) {
-        if (sinkClosed) throw new IllegalStateException("closed");
-
-        while (buffer.size() > 0) {
-          if (sourceClosed) throw new IOException("source is closed");
-          waitUntilNotified(buffer, timeout);
-        }
-      }
-    }
-
-    @Override public void close() throws IOException {
-      synchronized (buffer) {
-        if (sinkClosed) return;
-        try {
-          flush();
-        } finally {
-          sinkClosed = true;
-          buffer.notifyAll(); // Notify the source that no more bytes are coming.
-        }
-      }
-    }
-
-    @Override public Timeout timeout() {
-      return timeout;
-    }
-  }
-
-  final class PipeSource implements Source {
-    final Timeout timeout = new Timeout();
-
-    @Override public long read(Buffer sink, long byteCount) throws IOException {
-      synchronized (buffer) {
-        if (sourceClosed) throw new IllegalStateException("closed");
-
-        while (buffer.size() == 0) {
-          if (sinkClosed) return -1L;
-          waitUntilNotified(buffer, timeout); // Wait until the sink fills the buffer.
-        }
-
-        long result = buffer.read(sink, byteCount);
-        buffer.notifyAll(); // Notify the sink that it can resume writing.
-        return result;
-      }
-    }
-
-    @Override public void close() throws IOException {
-      synchronized (buffer) {
-        sourceClosed = true;
-        buffer.notifyAll(); // Notify the sink that no more bytes are desired.
-      }
-    }
-
-    @Override public Timeout timeout() {
-      return timeout;
-    }
-  }
-
-  /**
-   * Waits on {@code monitor} until it is notified. Throws {@link SocketTimeoutException} if either
-   * the thread is interrupted or if {@code timeout} elapses before {@code monitor} is notified. The
-   * caller must be synchronized on {@code monitor}.
-   */
-  static void waitUntilNotified(Object monitor, Timeout timeout) throws IOException {
-    try {
-      boolean hasDeadline = timeout.hasDeadline();
-      long timeoutNanos = timeout.timeoutNanos();
-
-      if (!hasDeadline && timeoutNanos == 0L) {
-        monitor.wait(); // There is no timeout: wait forever.
-        return;
-      }
-
-      // Compute how long we'll wait.
-      long waitNanos;
-      long start = System.nanoTime();
-      if (hasDeadline && timeoutNanos != 0) {
-        long deadlineNanos = timeout.deadlineNanoTime() - start;
-        waitNanos = Math.min(timeoutNanos, deadlineNanos);
-      } else if (hasDeadline) {
-        waitNanos = timeout.deadlineNanoTime() - start;
-      } else {
-        waitNanos = timeoutNanos;
-      }
-
-      // Attempt to wait that long. This will break out early if the monitor is notified.
-      long elapsedNanos = 0L;
-      if (waitNanos > 0L) {
-        long waitMillis = waitNanos / 1000000L;
-        monitor.wait(waitMillis, (int) (waitNanos - waitMillis * 1000000L));
-        elapsedNanos = System.nanoTime() - start;
-      }
-
-      // Throw if the timeout elapsed before the monitor was notified.
-      if (elapsedNanos >= waitNanos) {
-        throw new SocketTimeoutException("timeout");
-      }
-    } catch (InterruptedException e) {
-      throw new SocketTimeoutException("interrupted");
-    }
-  }
-}
-
diff --git a/pom.xml b/pom.xml
index e7d44fb216..8cbf639f3a 100644
--- a/pom.xml
+++ b/pom.xml
@@ -53,7 +53,7 @@
     <guava.version>16.0</guava.version>
     <java.version>1.7</java.version>
     <moshi.version>1.1.0</moshi.version>
-    <okio.version>1.8.0</okio.version>
+    <okio.version>1.9.0</okio.version>
 
     <!-- Test Dependencies -->
     <junit.version>4.12</junit.version>
