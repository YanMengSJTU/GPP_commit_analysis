diff --git a/CHANGELOG.md b/CHANGELOG.md
index 71a504176d..820c4fc534 100644
--- a/CHANGELOG.md
+++ b/CHANGELOG.md
@@ -1,7 +1,64 @@
 Change Log
 ==========
 
-## VERSION 2.2.0
+## Version 2.3.0
+
+_2015-03-16_
+
+ *  **HTTP/2 support.** We've done interop testing and haven't seen any
+    problems. HTTP/2 support has been a big effort and we're particularly
+    thankful to Adrian Cole who has helped us to reach this milestone.
+
+ *  **RC4 cipher suites are no longer supported by default.** To connect to
+    old, obsolete servers relying on these cipher suites, you must create a
+    custom `ConnectionSpec`.
+
+ *  **Beta WebSockets support.**. The `okhttp-ws` subproject offers a new
+    websockets client. Please try it out! When it's ready we intend to include
+    it with the core OkHttp library.
+
+ *  **Okio updated to 1.3.0.**
+
+    ```
+    <dependency>
+      <groupId>com.squareup.okio</groupId>
+      <artifactId>okio</artifactId>
+      <version>1.3.0</version>
+    </dependency>
+    ```
+
+ *  **Fix: improve parallelism of async requests.** OkHttp's Dispatcher had a
+    misconfigured `ExecutorService` that limited the number of worker threads.
+    If you're using `Call.enqueue()` this update should significantly improve
+    request concurrency.
+
+ *  **Fix: Lazily initialize the response cache.** This avoids strict mode
+    warnings when initializing OkHttp on Androidâ€˜s main thread.
+
+ *  **Fix: Disable ALPN on Android 4.4.** That release of the feature was
+    unstable and prone to native crashes in the underlying OpenSSL code.
+ *  Fix: Don't send both `If-None-Match` and `If-Modified-Since` cache headers
+    when both are applicable.
+ *  Fix: Fail early when a port is out of range.
+ *  Fix: Offer `Content-Length` headers for multipart request bodies.
+ *  Fix: Throw `UnknownServiceException` if a cleartext connection is attempted
+    when explicitly forbidden.
+ *  Fix: Throw a `SSLPeerUnverifiedException` when host verification fails.
+ *  Fix: MockWebServer explicitly closes sockets. (On some Android releases,
+    closing the input stream and output stream of a socket is not sufficient.
+ *  Fix: Buffer outgoing HTTP/2 frames to limit how many outgoing frames are
+    created.
+ *  Fix: Avoid crashing when cache writing fails due to a full disk.
+ *  Fix: Improve caching of private responses.
+ *  Fix: Update cache-by-default response codes.
+ *  Fix: Reused `Request.Builder` instances no longer hold stale URL fields.
+ *  New: ConnectionSpec can now be configured to use the SSL socket's default
+    cipher suites. To use, set the cipher suites to `null`.
+ *  New: Support `DELETE` with a request body.
+ *  New: `Headers.of(Map)` creates headers from a Map.
+
+
+## Version 2.2.0
 
 _2014-12-30_
 
@@ -43,7 +100,7 @@ _2014-12-30_
  *  Fix: Resurrect http/2 frame logging.
  *  Fix: Limit to 20 authorization attempts.
 
-## VERSION 2.1.0
+## Version 2.1.0
 
 _2014-11-11_
 
@@ -51,7 +108,7 @@ _2014-11-11_
  *  Fix: Don't crash when mixing authorization challenges with upload retries.
 
 
-## VERSION 2.1.0-RC1
+## Version 2.1.0-RC1
 
 _2014-11-04_
 
diff --git a/README.md b/README.md
index 0e239589a1..9f996347de 100644
--- a/README.md
+++ b/README.md
@@ -11,12 +11,12 @@ Download [the latest JAR][3] or grab via Maven:
 <dependency>
   <groupId>com.squareup.okhttp</groupId>
   <artifactId>okhttp</artifactId>
-  <version>2.2.0</version>
+  <version>2.3.0</version>
 </dependency>
 ```
 or Gradle:
 ```groovy
-compile 'com.squareup.okhttp:okhttp:2.2.0'
+compile 'com.squareup.okhttp:okhttp:2.3.0'
 ```
 
 Snapshots of the development version are available in [Sonatype's `snapshots` repository][snap].
@@ -36,13 +36,13 @@ Download [the latest JAR][4] or grab via Maven:
 <dependency>
   <groupId>com.squareup.okhttp</groupId>
   <artifactId>mockwebserver</artifactId>
-  <version>2.2.0</version>
+  <version>2.3.0</version>
   <scope>test</scope>
 </dependency>
 ```
 or Gradle:
 ```groovy
-testCompile 'com.squareup.okhttp:mockwebserver:2.2.0'
+testCompile 'com.squareup.okhttp:mockwebserver:2.3.0'
 ```
 
 
diff --git a/benchmarks/pom.xml b/benchmarks/pom.xml
index 4fde956949..3a5fccd851 100644
--- a/benchmarks/pom.xml
+++ b/benchmarks/pom.xml
@@ -6,7 +6,7 @@
   <parent>
     <groupId>com.squareup.okhttp</groupId>
     <artifactId>parent</artifactId>
-    <version>2.3.0-SNAPSHOT</version>
+    <version>2.4.0-SNAPSHOT</version>
   </parent>
 
   <artifactId>benchmarks</artifactId>
diff --git a/mockwebserver/README.md b/mockwebserver/README.md
index c72966826c..eb698c35b2 100644
--- a/mockwebserver/README.md
+++ b/mockwebserver/README.md
@@ -116,6 +116,26 @@ assertEquals("{}", request.getUtf8Body());
 By default MockWebServer uses a queue to specify a series of responses. Use a
 Dispatcher to handle requests using another policy. One natural policy is to
 dispatch on the request path.
+You can, for example, filter the request instead of using `server.enqueue()`.
+
+```java
+final Dispatcher dispatcher = new Dispatcher() {
+
+    @Override
+    public MockResponse dispatch(RecordedRequest request) throws InterruptedException {
+
+        if (request.getPath().equals("/v1/login/auth/")){
+            return new MockResponse().setResponseCode(200));
+        } else if (request.getPath().equals("v1/check/version/")){
+            return new MockResponse().setResponseCode(200).setBody("version=9");
+        } else if (request.getPath().equals("/v1/profile/info")) {
+            return new MockResponse().setResponseCode(200).setBody("{\\\"info\\\":{\\\"name\":\"Lucas Albuquerque\",\"age\":\"21\",\"gender\":\"male\"}}");
+        }
+        return new MockResponse().setResponseCode(404);
+    }
+};
+server.setDispatcher(dispatcher);
+```
 
 
 ### Download
diff --git a/mockwebserver/pom.xml b/mockwebserver/pom.xml
index ae3abb5c66..86d250338c 100644
--- a/mockwebserver/pom.xml
+++ b/mockwebserver/pom.xml
@@ -6,7 +6,7 @@
   <parent>
     <groupId>com.squareup.okhttp</groupId>
     <artifactId>parent</artifactId>
-    <version>2.3.0-SNAPSHOT</version>
+    <version>2.4.0-SNAPSHOT</version>
   </parent>
 
   <artifactId>mockwebserver</artifactId>
@@ -18,6 +18,11 @@
       <artifactId>okhttp</artifactId>
       <version>${project.version}</version>
     </dependency>
+    <dependency>
+      <groupId>com.squareup.okhttp</groupId>
+      <artifactId>okhttp-ws</artifactId>
+      <version>${project.version}</version>
+    </dependency>
     <dependency>
       <groupId>org.bouncycastle</groupId>
       <artifactId>bcprov-jdk15on</artifactId>
diff --git a/mockwebserver/src/main/java/com/squareup/okhttp/internal/SslContextBuilder.java b/mockwebserver/src/main/java/com/squareup/okhttp/internal/SslContextBuilder.java
index 3d61d73b05..546d66036e 100644
--- a/mockwebserver/src/main/java/com/squareup/okhttp/internal/SslContextBuilder.java
+++ b/mockwebserver/src/main/java/com/squareup/okhttp/internal/SslContextBuilder.java
@@ -68,7 +68,7 @@ public SslContextBuilder(String hostName) {
   public static synchronized SSLContext localhost() {
     if (localhost == null) {
       try {
-        localhost = new SslContextBuilder(InetAddress.getByName(null).getHostName()).build();
+        localhost = new SslContextBuilder(InetAddress.getByName("localhost").getHostName()).build();
       } catch (GeneralSecurityException e) {
         throw new RuntimeException(e);
       } catch (UnknownHostException e) {
diff --git a/mockwebserver/src/main/java/com/squareup/okhttp/internal/spdy/SpdyServer.java b/mockwebserver/src/main/java/com/squareup/okhttp/internal/spdy/SpdyServer.java
index fb21a088d0..8e93b470f4 100644
--- a/mockwebserver/src/main/java/com/squareup/okhttp/internal/spdy/SpdyServer.java
+++ b/mockwebserver/src/main/java/com/squareup/okhttp/internal/spdy/SpdyServer.java
@@ -22,10 +22,13 @@
 import com.squareup.okhttp.internal.Util;
 import java.io.File;
 import java.io.IOException;
+import java.net.ProtocolException;
 import java.net.ServerSocket;
 import java.net.Socket;
 import java.util.Arrays;
 import java.util.List;
+import java.util.logging.Level;
+import java.util.logging.Logger;
 import javax.net.ssl.SSLSocket;
 import javax.net.ssl.SSLSocketFactory;
 import okio.BufferedSink;
@@ -34,17 +37,15 @@
 
 /** A basic SPDY/HTTP_2 server that serves the contents of a local directory. */
 public final class SpdyServer implements IncomingStreamHandler {
+  static final Logger logger = Logger.getLogger(SpdyServer.class.getName());
+
   private final List<Protocol> spdyProtocols = Util.immutableList(Protocol.HTTP_2, Protocol.SPDY_3);
 
   private final File baseDirectory;
-  private SSLSocketFactory sslSocketFactory;
-  private Protocol protocol;
+  private final SSLSocketFactory sslSocketFactory;
 
-  public SpdyServer(File baseDirectory) {
+  public SpdyServer(File baseDirectory, SSLSocketFactory sslSocketFactory) {
     this.baseDirectory = baseDirectory;
-  }
-
-  public void useHttps(SSLSocketFactory sslSocketFactory) {
     this.sslSocketFactory = sslSocketFactory;
   }
 
@@ -53,52 +54,67 @@ private void run() throws Exception {
     serverSocket.setReuseAddress(true);
 
     while (true) {
-      Socket socket = serverSocket.accept();
-      if (sslSocketFactory != null) {
-        socket = doSsl(socket);
+      Socket socket = null;
+      try {
+        socket = serverSocket.accept();
+
+        SSLSocket sslSocket = doSsl(socket);
+        String protocolString = Platform.get().getSelectedProtocol(sslSocket);
+        Protocol protocol = protocolString != null ? Protocol.get(protocolString) : null;
+        if (protocol == null || !spdyProtocols.contains(protocol)) {
+          throw new ProtocolException("Protocol " + protocol + " unsupported");
+        }
+        SpdyConnection spdyConnection = new SpdyConnection.Builder(false, sslSocket)
+            .protocol(protocol)
+            .handler(this)
+            .build();
+        spdyConnection.sendConnectionPreface();
+      } catch (IOException e) {
+        logger.log(Level.INFO, "SpdyServer connection failure: " + e);
+        Util.closeQuietly(socket);
+      } catch (Exception e) {
+        logger.log(Level.WARNING, "SpdyServer unexpected failure", e);
+        Util.closeQuietly(socket);
       }
-      new SpdyConnection.Builder(false, socket).protocol(protocol).handler(this).build();
     }
   }
 
-  private Socket doSsl(Socket socket) throws IOException {
-    SSLSocket sslSocket =
-        (SSLSocket) sslSocketFactory.createSocket(socket, socket.getInetAddress().getHostAddress(),
-            socket.getPort(), true);
+  private SSLSocket doSsl(Socket socket) throws IOException {
+    SSLSocket sslSocket = (SSLSocket) sslSocketFactory.createSocket(
+        socket, socket.getInetAddress().getHostAddress(), socket.getPort(), true);
     sslSocket.setUseClientMode(false);
     Platform.get().configureTlsExtensions(sslSocket, null, spdyProtocols);
     sslSocket.startHandshake();
-    String protocolString = Platform.get().getSelectedProtocol(sslSocket);
-    protocol = protocolString != null ? Protocol.get(protocolString) : null;
-    if (protocol == null || !spdyProtocols.contains(protocol)) {
-      throw new IllegalStateException("Protocol " + protocol + " unsupported");
-    }
     return sslSocket;
   }
 
   @Override public void receive(final SpdyStream stream) throws IOException {
-    List<Header> requestHeaders = stream.getRequestHeaders();
-    String path = null;
-    for (int i = 0, size = requestHeaders.size(); i < size; i++) {
-      if (requestHeaders.get(i).name.equals(Header.TARGET_PATH)) {
-        path = requestHeaders.get(i).value.utf8();
-        break;
+    try {
+      List<Header> requestHeaders = stream.getRequestHeaders();
+      String path = null;
+      for (int i = 0, size = requestHeaders.size(); i < size; i++) {
+        if (requestHeaders.get(i).name.equals(Header.TARGET_PATH)) {
+          path = requestHeaders.get(i).value.utf8();
+          break;
+        }
       }
-    }
 
-    if (path == null) {
-      // TODO: send bad request error
-      throw new AssertionError();
-    }
+      if (path == null) {
+        // TODO: send bad request error
+        throw new AssertionError();
+      }
 
-    File file = new File(baseDirectory + path);
+      File file = new File(baseDirectory + path);
 
-    if (file.isDirectory()) {
-      serveDirectory(stream, file.list());
-    } else if (file.exists()) {
-      serveFile(stream, file);
-    } else {
-      send404(stream, path);
+      if (file.isDirectory()) {
+        serveDirectory(stream, file.listFiles());
+      } else if (file.exists()) {
+        serveFile(stream, file);
+      } else {
+        send404(stream, path);
+      }
+    } catch (IOException e) {
+      System.out.println(e.getMessage());
     }
   }
 
@@ -114,7 +130,7 @@ private void send404(SpdyStream stream, String path) throws IOException {
     out.close();
   }
 
-  private void serveDirectory(SpdyStream stream, String[] files) throws IOException {
+  private void serveDirectory(SpdyStream stream, File[] files) throws IOException {
     List<Header> responseHeaders = Arrays.asList(
         new Header(":status", "200"),
         new Header(":version", "HTTP/1.1"),
@@ -122,8 +138,9 @@ private void serveDirectory(SpdyStream stream, String[] files) throws IOExceptio
     );
     stream.reply(responseHeaders, true);
     BufferedSink out = Okio.buffer(stream.getSink());
-    for (String file : files) {
-      out.writeUtf8("<a href='" + file + "'>" + file + "</a><br>");
+    for (File file : files) {
+      String target = file.isDirectory() ? (file.getName() + "/") : file.getName();
+      out.writeUtf8("<a href='" + target + "'>" + target + "</a><br>");
     }
     out.close();
   }
@@ -146,7 +163,14 @@ private void serveFile(SpdyStream stream, File file) throws IOException {
   }
 
   private String contentType(File file) {
-    return file.getName().endsWith(".html") ? "text/html" : "text/plain";
+    if (file.getName().endsWith(".css")) return "text/css";
+    if (file.getName().endsWith(".gif")) return "image/gif";
+    if (file.getName().endsWith(".html")) return "text/html";
+    if (file.getName().endsWith(".jpeg")) return "image/jpeg";
+    if (file.getName().endsWith(".jpg")) return "image/jpeg";
+    if (file.getName().endsWith(".js")) return "application/javascript";
+    if (file.getName().endsWith(".png")) return "image/png";
+    return "text/plain";
   }
 
   public static void main(String... args) throws Exception {
@@ -155,8 +179,8 @@ public static void main(String... args) throws Exception {
       return;
     }
 
-    SpdyServer server = new SpdyServer(new File(args[0]));
-    server.useHttps(SslContextBuilder.localhost().getSocketFactory());
+    SpdyServer server = new SpdyServer(new File(args[0]),
+        SslContextBuilder.localhost().getSocketFactory());
     server.run();
   }
 }
diff --git a/mockwebserver/src/main/java/com/squareup/okhttp/mockwebserver/MockResponse.java b/mockwebserver/src/main/java/com/squareup/okhttp/mockwebserver/MockResponse.java
index 8f0ee2c50f..09dda5634b 100644
--- a/mockwebserver/src/main/java/com/squareup/okhttp/mockwebserver/MockResponse.java
+++ b/mockwebserver/src/main/java/com/squareup/okhttp/mockwebserver/MockResponse.java
@@ -16,7 +16,7 @@
 package com.squareup.okhttp.mockwebserver;
 
 import com.squareup.okhttp.Headers;
-import com.squareup.okhttp.internal.ws.WebSocketListener;
+import com.squareup.okhttp.ws.WebSocketListener;
 import java.util.ArrayList;
 import java.util.List;
 import java.util.concurrent.TimeUnit;
@@ -153,7 +153,7 @@ public MockResponse setChunkedBody(Buffer body, int maxChunkSize) {
     Buffer bytesOut = new Buffer();
     while (!body.exhausted()) {
       long chunkSize = Math.min(body.size(), maxChunkSize);
-      bytesOut.writeUtf8(Long.toHexString(chunkSize));
+      bytesOut.writeHexadecimalUnsignedLong(chunkSize);
       bytesOut.writeUtf8("\r\n");
       bytesOut.write(body, chunkSize);
       bytesOut.writeUtf8("\r\n");
diff --git a/mockwebserver/src/main/java/com/squareup/okhttp/mockwebserver/MockWebServer.java b/mockwebserver/src/main/java/com/squareup/okhttp/mockwebserver/MockWebServer.java
index 39fbf6fd84..259cf3e36a 100644
--- a/mockwebserver/src/main/java/com/squareup/okhttp/mockwebserver/MockWebServer.java
+++ b/mockwebserver/src/main/java/com/squareup/okhttp/mockwebserver/MockWebServer.java
@@ -30,8 +30,8 @@
 import com.squareup.okhttp.internal.spdy.SpdyConnection;
 import com.squareup.okhttp.internal.spdy.SpdyStream;
 import com.squareup.okhttp.internal.ws.RealWebSocket;
-import com.squareup.okhttp.internal.ws.WebSocketListener;
 import com.squareup.okhttp.internal.ws.WebSocketProtocol;
+import com.squareup.okhttp.ws.WebSocketListener;
 import java.io.IOException;
 import java.net.InetAddress;
 import java.net.InetSocketAddress;
@@ -56,7 +56,9 @@
 import java.util.concurrent.CountDownLatch;
 import java.util.concurrent.ExecutorService;
 import java.util.concurrent.Executors;
+import java.util.concurrent.LinkedBlockingDeque;
 import java.util.concurrent.LinkedBlockingQueue;
+import java.util.concurrent.ThreadPoolExecutor;
 import java.util.concurrent.TimeUnit;
 import java.util.concurrent.atomic.AtomicInteger;
 import java.util.logging.Level;
@@ -77,6 +79,7 @@
 
 import static com.squareup.okhttp.mockwebserver.SocketPolicy.DISCONNECT_AT_START;
 import static com.squareup.okhttp.mockwebserver.SocketPolicy.FAIL_HANDSHAKE;
+import static java.util.concurrent.TimeUnit.SECONDS;
 
 /**
  * A scriptable web server. Callers supply canned responses and the server
@@ -362,6 +365,8 @@ private void acceptConnections() throws Exception {
   }
 
   public void shutdown() throws IOException {
+    if (serverSocket == null) throw new IllegalStateException("shutdown() before start()");
+
     // Cause acceptConnections() to break out.
     serverSocket.close();
 
@@ -472,8 +477,8 @@ private void createTunnel() throws IOException, InterruptedException {
       }
 
       /**
-       * Reads a request and writes its response. Returns true if a request was
-       * processed.
+       * Reads a request and writes its response. Returns true if further calls should be attempted
+       * on the socket.
        */
       private boolean processOneRequest(Socket socket, BufferedSource source, BufferedSink sink)
           throws IOException, InterruptedException {
@@ -503,21 +508,19 @@ private boolean processOneRequest(Socket socket, BufferedSource source, Buffered
           writeHttpResponse(socket, sink, response);
         }
 
+        if (logger.isLoggable(Level.INFO)) {
+          logger.info(MockWebServer.this + " received request: " + request
+              + " and responded: " + response);
+        }
+
         if (response.getSocketPolicy() == SocketPolicy.DISCONNECT_AT_END) {
-          source.close();
-          sink.close();
-          // Workaround for bug on Android: closing the input/output streams should close an
-          // SSLSocket but does not. https://code.google.com/p/android/issues/detail?id=97564
           socket.close();
+          return false;
         } else if (response.getSocketPolicy() == SocketPolicy.SHUTDOWN_INPUT_AT_END) {
           socket.shutdownInput();
         } else if (response.getSocketPolicy() == SocketPolicy.SHUTDOWN_OUTPUT_AT_END) {
           socket.shutdownOutput();
         }
-        if (logger.isLoggable(Level.INFO)) {
-          logger.info(
-              MockWebServer.this + " received request: " + request + " and responded: " + response);
-        }
 
         sequenceNumber++;
         return true;
@@ -636,9 +639,15 @@ private void handleWebSocketUpgrade(Socket socket, BufferedSource source, Buffer
 
     final WebSocketListener listener = response.getWebSocketListener();
     final CountDownLatch connectionClose = new CountDownLatch(1);
+
+    ThreadPoolExecutor replyExecutor =
+        new ThreadPoolExecutor(1, 1, 1, SECONDS, new LinkedBlockingDeque<Runnable>(),
+            Util.threadFactory(String.format("MockWebServer %s WebSocket", request.getPath()),
+                true));
+    replyExecutor.allowCoreThreadTimeOut(true);
     final RealWebSocket webSocket =
-        new RealWebSocket(false, source, sink, new SecureRandom(), listener,
-            request.getPath()) {
+        new RealWebSocket(false /* is server */, source, sink, new SecureRandom(), replyExecutor,
+            listener, request.getPath()) {
           @Override protected void closeConnection() throws IOException {
             connectionClose.countDown();
           }
diff --git a/mockwebserver/src/test/java/com/squareup/okhttp/mockwebserver/MockWebServerTest.java b/mockwebserver/src/test/java/com/squareup/okhttp/mockwebserver/MockWebServerTest.java
index 388dbf64f5..a3816d2db4 100644
--- a/mockwebserver/src/test/java/com/squareup/okhttp/mockwebserver/MockWebServerTest.java
+++ b/mockwebserver/src/test/java/com/squareup/okhttp/mockwebserver/MockWebServerTest.java
@@ -264,4 +264,19 @@
     }
     return headerList;
   }
+
+  @Test public void shutdownWithoutStart() throws IOException {
+    MockWebServer server = new MockWebServer();
+    try {
+      server.shutdown();
+      fail();
+    } catch (IllegalStateException expected) {
+    }
+  }
+
+  @Test public void shutdownWithoutEnqueue() throws IOException {
+    MockWebServer server = new MockWebServer();
+    server.start();
+    server.shutdown();
+  }
 }
diff --git a/okcurl/pom.xml b/okcurl/pom.xml
index 047983440b..467c170489 100644
--- a/okcurl/pom.xml
+++ b/okcurl/pom.xml
@@ -6,7 +6,7 @@
   <parent>
     <groupId>com.squareup.okhttp</groupId>
     <artifactId>parent</artifactId>
-    <version>2.3.0-SNAPSHOT</version>
+    <version>2.4.0-SNAPSHOT</version>
   </parent>
 
   <artifactId>okcurl</artifactId>
diff --git a/okcurl/src/main/java/com/squareup/okhttp/curl/Main.java b/okcurl/src/main/java/com/squareup/okhttp/curl/Main.java
index e1054c9b1d..c6a85e1732 100644
--- a/okcurl/src/main/java/com/squareup/okhttp/curl/Main.java
+++ b/okcurl/src/main/java/com/squareup/okhttp/curl/Main.java
@@ -25,7 +25,7 @@
 import com.squareup.okhttp.RequestBody;
 import com.squareup.okhttp.Response;
 import com.squareup.okhttp.internal.http.StatusLine;
-import com.squareup.okhttp.internal.spdy.Http20Draft16;
+import com.squareup.okhttp.internal.spdy.Http2;
 
 import io.airlift.command.Arguments;
 import io.airlift.command.Command;
@@ -49,7 +49,9 @@
 import javax.net.ssl.SSLSocketFactory;
 import javax.net.ssl.TrustManager;
 import javax.net.ssl.X509TrustManager;
+import okio.BufferedSource;
 import okio.Okio;
+import okio.Sink;
 
 import static java.util.concurrent.TimeUnit.SECONDS;
 
@@ -151,9 +153,15 @@ private static String protocols() {
         System.out.println();
       }
 
-      response.body().source().readAll(Okio.sink(System.out));
+      // Stream the response to the System.out as it is returned from the server.
+      Sink out = Okio.sink(System.out);
+      BufferedSource source = response.body().source();
+      while (!source.exhausted()) {
+        out.write(source.buffer(), source.buffer().size());
+        out.flush();
+      }
+
       response.body().close();
-      System.out.flush();
     } catch (IOException e) {
       e.printStackTrace();
     } finally {
@@ -266,7 +274,7 @@ private static HostnameVerifier createInsecureHostnameVerifier() {
   }
 
   private static void enableHttp2FrameLogging() {
-    Logger logger = Logger.getLogger(Http20Draft16.class.getName() + "$FrameLogger");
+    Logger logger = Logger.getLogger(Http2.class.getName() + "$FrameLogger");
     logger.setLevel(Level.FINE);
     ConsoleHandler handler = new ConsoleHandler();
     handler.setLevel(Level.FINE);
diff --git a/okhttp-android-support/pom.xml b/okhttp-android-support/pom.xml
index f00d51ad92..74f15fcf05 100644
--- a/okhttp-android-support/pom.xml
+++ b/okhttp-android-support/pom.xml
@@ -6,7 +6,7 @@
   <parent>
     <groupId>com.squareup.okhttp</groupId>
     <artifactId>parent</artifactId>
-    <version>2.3.0-SNAPSHOT</version>
+    <version>2.4.0-SNAPSHOT</version>
   </parent>
 
   <artifactId>okhttp-android-support</artifactId>
diff --git a/okhttp-android-support/src/main/java/com/squareup/okhttp/internal/huc/JavaApiConverter.java b/okhttp-android-support/src/main/java/com/squareup/okhttp/internal/huc/JavaApiConverter.java
index 603a559980..06d44d203c 100644
--- a/okhttp-android-support/src/main/java/com/squareup/okhttp/internal/huc/JavaApiConverter.java
+++ b/okhttp-android-support/src/main/java/com/squareup/okhttp/internal/huc/JavaApiConverter.java
@@ -338,8 +338,8 @@ private static String extractStatusLine(HttpURLConnection httpUrlConnection) {
 
   /**
    * Extracts the status line from the supplied Java API {@link java.net.CacheResponse}.
-   * As per the spec, the status line is held as the header with the null key. Returns {@code null}
-   * if there is no status line.
+   * As per the spec, the status line is held as the header with the null key. Throws a
+   * {@link ProtocolException} if there is no status line.
    */
   private static String extractStatusLine(CacheResponse javaResponse) throws IOException {
     Map<String, List<String>> javaResponseHeaders = javaResponse.getHeaders();
@@ -347,10 +347,14 @@ private static String extractStatusLine(CacheResponse javaResponse) throws IOExc
   }
 
   // VisibleForTesting
-  static String extractStatusLine(Map<String, List<String>> javaResponseHeaders) {
+  static String extractStatusLine(Map<String, List<String>> javaResponseHeaders)
+      throws ProtocolException {
     List<String> values = javaResponseHeaders.get(null);
     if (values == null || values.size() == 0) {
-      return null;
+      // The status line is missing. This suggests a badly behaving cache.
+      throw new ProtocolException(
+          "CacheResponse is missing a \'null\' header containing the status line. Headers="
+          + javaResponseHeaders);
     }
     return values.get(0);
   }
diff --git a/okhttp-android-support/src/test/java/com/squareup/okhttp/internal/huc/JavaApiConverterTest.java b/okhttp-android-support/src/test/java/com/squareup/okhttp/internal/huc/JavaApiConverterTest.java
index d5dfcd8557..7766da3b84 100644
--- a/okhttp-android-support/src/test/java/com/squareup/okhttp/internal/huc/JavaApiConverterTest.java
+++ b/okhttp-android-support/src/test/java/com/squareup/okhttp/internal/huc/JavaApiConverterTest.java
@@ -233,6 +233,30 @@ private void testCreateOkResponseInternal(HttpURLConnectionFactory httpUrlConnec
     assertNull(response.handshake());
   }
 
+  /** Test for https://code.google.com/p/android/issues/detail?id=160522 */
+  @Test public void createOkResponse_fromCacheResponseWithMissingStatusLine() throws Exception {
+    URI uri = new URI("http://foo/bar");
+    Request request = new Request.Builder().url(uri.toURL()).build();
+    CacheResponse cacheResponse = new CacheResponse() {
+      @Override public Map<String, List<String>> getHeaders() throws IOException {
+        Map<String, List<String>> headers = new HashMap<>();
+        // Headers is deliberately missing an entry with a null key.
+        headers.put("xyzzy", Arrays.asList("bar", "baz"));
+        return headers;
+      }
+
+      @Override public InputStream getBody() throws IOException {
+        return null; // Should never be called
+      }
+    };
+
+    try {
+      JavaApiConverter.createOkResponse(request, cacheResponse);
+      fail();
+    } catch (IOException expected) {
+    }
+  }
+
   @Test public void createOkResponse_fromSecureCacheResponse() throws Exception {
     final String statusLine = "HTTP/1.1 200 Fantastic";
     final Principal localPrincipal = LOCAL_CERT.getSubjectX500Principal();
@@ -669,15 +693,18 @@ private void assertHeadersContainsMapping(Map<String, List<String>> headers, Str
     assertEquals(Arrays.asList("value2"), okHeaders.values("key2"));
   }
 
-  @Test public void extractStatusLine() {
+  @Test public void extractStatusLine() throws Exception {
     Map<String, List<String>> javaResponseHeaders = new HashMap<>();
     javaResponseHeaders.put(null, Arrays.asList("StatusLine"));
     javaResponseHeaders.put("key1", Arrays.asList("value1_1", "value1_2"));
     javaResponseHeaders.put("key2", Arrays.asList("value2"));
     assertEquals("StatusLine", JavaApiConverter.extractStatusLine(javaResponseHeaders));
 
-    assertNull(
-        JavaApiConverter.extractStatusLine(Collections.<String, List<String>>emptyMap()));
+    try {
+      JavaApiConverter.extractStatusLine(Collections.<String, List<String>>emptyMap());
+      fail();
+    } catch (IOException expected) {
+    }
   }
 
   private URL configureServer(MockResponse mockResponse) throws Exception {
diff --git a/okhttp-android-support/src/test/java/com/squareup/okhttp/internal/huc/ResponseCacheTest.java b/okhttp-android-support/src/test/java/com/squareup/okhttp/internal/huc/ResponseCacheTest.java
index 3c91fb5851..18956a3611 100644
--- a/okhttp-android-support/src/test/java/com/squareup/okhttp/internal/huc/ResponseCacheTest.java
+++ b/okhttp-android-support/src/test/java/com/squareup/okhttp/internal/huc/ResponseCacheTest.java
@@ -40,12 +40,14 @@
 import java.net.CookieManager;
 import java.net.HttpCookie;
 import java.net.HttpURLConnection;
+import java.net.ProtocolException;
 import java.net.ResponseCache;
 import java.net.SecureCacheResponse;
 import java.net.URI;
 import java.net.URISyntaxException;
 import java.net.URL;
 import java.net.URLConnection;
+import java.nio.charset.StandardCharsets;
 import java.security.Principal;
 import java.security.cert.Certificate;
 import java.util.ArrayList;
@@ -1303,6 +1305,48 @@ public void assertCookies(CookieManager cookieManager, URL url, String... expect
     assertFalse(aborted.get()); // The best behavior is ambiguous, but RI 6 doesn't abort here
   }
 
+  /**
+   * Fail if a badly-behaved cache returns a null status line header.
+   * https://code.google.com/p/android/issues/detail?id=160522
+   */
+  @Test public void responseCacheReturnsNullStatusLine() throws Exception {
+    String cachedContentString = "Hello";
+    final byte[] cachedContent = cachedContentString.getBytes(StandardCharsets.US_ASCII);
+
+    Internal.instance.setCache(client, new CacheAdapter(new AbstractResponseCache() {
+      @Override
+      public CacheResponse get(URI uri, String requestMethod,
+          Map<String, List<String>> requestHeaders)
+          throws IOException {
+        return new CacheResponse() {
+          @Override public Map<String, List<String>> getHeaders() throws IOException {
+            String contentType = "text/plain";
+            Map<String, List<String>> headers = new HashMap<>();
+            headers.put("Content-Length", Arrays.asList(Integer.toString(cachedContent.length)));
+            headers.put("Content-Type", Arrays.asList(contentType));
+            headers.put("Expires", Arrays.asList(formatDate(-1, TimeUnit.HOURS)));
+            headers.put("Cache-Control", Arrays.asList("max-age=60"));
+            // Crucially, the header with a null key is missing, which renders the cache response
+            // unusable because OkHttp only caches responses with cacheable response codes.
+            return headers;
+          }
+
+          @Override public InputStream getBody() throws IOException {
+            return new ByteArrayInputStream(cachedContent);
+          }
+        };
+      }
+    }));
+    HttpURLConnection connection = openConnection(server.getUrl("/"));
+    // If there was no status line from the cache an exception will be thrown. No network request
+    // should be made.
+    try {
+      connection.getResponseCode();
+      fail();
+    } catch (ProtocolException expected) {
+    }
+  }
+
   /**
    * @param delta the offset from the current date to use. Negative
    * values yield dates in the past; positive values yield dates in the
diff --git a/okhttp-apache/pom.xml b/okhttp-apache/pom.xml
index 4031304958..2eafbad443 100644
--- a/okhttp-apache/pom.xml
+++ b/okhttp-apache/pom.xml
@@ -6,7 +6,7 @@
   <parent>
     <groupId>com.squareup.okhttp</groupId>
     <artifactId>parent</artifactId>
-    <version>2.3.0-SNAPSHOT</version>
+    <version>2.4.0-SNAPSHOT</version>
   </parent>
 
   <artifactId>okhttp-apache</artifactId>
diff --git a/okhttp-hpacktests/pom.xml b/okhttp-hpacktests/pom.xml
index 70a59f2ad6..6ae44d5ce6 100644
--- a/okhttp-hpacktests/pom.xml
+++ b/okhttp-hpacktests/pom.xml
@@ -6,7 +6,7 @@
   <parent>
     <groupId>com.squareup.okhttp</groupId>
     <artifactId>parent</artifactId>
-    <version>2.2.0-SNAPSHOT</version>
+    <version>2.3.0-SNAPSHOT</version>
   </parent>
 
   <artifactId>okhttp-hpacktests</artifactId>
diff --git a/okhttp-hpacktests/src/test/java/com/squareup/okhttp/internal/spdy/HpackDecodeTestBase.java b/okhttp-hpacktests/src/test/java/com/squareup/okhttp/internal/spdy/HpackDecodeTestBase.java
index 1bd9b006f2..e26b66963a 100644
--- a/okhttp-hpacktests/src/test/java/com/squareup/okhttp/internal/spdy/HpackDecodeTestBase.java
+++ b/okhttp-hpacktests/src/test/java/com/squareup/okhttp/internal/spdy/HpackDecodeTestBase.java
@@ -51,7 +51,7 @@
   }
 
   private final Buffer bytesIn = new Buffer();
-  private final HpackDraft10.Reader hpackReader = new HpackDraft10.Reader(4096, bytesIn);
+  private final Hpack.Reader hpackReader = new Hpack.Reader(4096, bytesIn);
 
   private final Story story;
 
diff --git a/okhttp-hpacktests/src/test/java/com/squareup/okhttp/internal/spdy/HpackRoundTripTest.java b/okhttp-hpacktests/src/test/java/com/squareup/okhttp/internal/spdy/HpackRoundTripTest.java
index a78dab5abf..44916724e2 100644
--- a/okhttp-hpacktests/src/test/java/com/squareup/okhttp/internal/spdy/HpackRoundTripTest.java
+++ b/okhttp-hpacktests/src/test/java/com/squareup/okhttp/internal/spdy/HpackRoundTripTest.java
@@ -42,7 +42,7 @@
   }
 
   private Buffer bytesOut = new Buffer();
-  private HpackDraft10.Writer hpackWriter = new HpackDraft10.Writer(bytesOut);
+  private Hpack.Writer hpackWriter = new Hpack.Writer(bytesOut);
 
   public HpackRoundTripTest(Story story) {
     super(story);
diff --git a/okhttp-hpacktests/src/test/java/com/squareup/okhttp/internal/spdy/hpackjson/HpackJsonUtil.java b/okhttp-hpacktests/src/test/java/com/squareup/okhttp/internal/spdy/hpackjson/HpackJsonUtil.java
index 9d721abc96..f64302410c 100644
--- a/okhttp-hpacktests/src/test/java/com/squareup/okhttp/internal/spdy/hpackjson/HpackJsonUtil.java
+++ b/okhttp-hpacktests/src/test/java/com/squareup/okhttp/internal/spdy/hpackjson/HpackJsonUtil.java
@@ -31,7 +31,8 @@
  * Utilities for reading HPACK tests.
  */
 public final class HpackJsonUtil {
-  private static final int CURRENT_DRAFT = 9;
+  /** Earliest draft that is code-compatible with latest. */
+  private static final int BASE_DRAFT = 9;
 
   private static final String STORY_RESOURCE_FORMAT = "/hpack-test-case/%s/story_%02d.json";
 
@@ -49,7 +50,7 @@ private static Story readStory(InputStream jsonResource) throws IOException {
       if (path.isDirectory() && Arrays.asList(path.list()).contains("story_00.json")) {
         try {
           Story firstStory = readStory(new FileInputStream(new File(path, "story_00.json")));
-          if (firstStory.getDraft() == CURRENT_DRAFT) {
+          if (firstStory.getDraft() >= BASE_DRAFT) {
             storyNames.add(path.getName());
           }
         } catch (IOException ignored) {
diff --git a/okhttp-tests/pom.xml b/okhttp-tests/pom.xml
index face99dad8..e3a99660ec 100644
--- a/okhttp-tests/pom.xml
+++ b/okhttp-tests/pom.xml
@@ -6,7 +6,7 @@
   <parent>
     <groupId>com.squareup.okhttp</groupId>
     <artifactId>parent</artifactId>
-    <version>2.3.0-SNAPSHOT</version>
+    <version>2.4.0-SNAPSHOT</version>
   </parent>
 
   <artifactId>okhttp-tests</artifactId>
diff --git a/okhttp-tests/src/test/java/com/squareup/okhttp/CallTest.java b/okhttp-tests/src/test/java/com/squareup/okhttp/CallTest.java
index 78e84a4a3f..19003e2922 100644
--- a/okhttp-tests/src/test/java/com/squareup/okhttp/CallTest.java
+++ b/okhttp-tests/src/test/java/com/squareup/okhttp/CallTest.java
@@ -33,8 +33,8 @@
 import java.net.CookieManager;
 import java.net.HttpCookie;
 import java.net.HttpURLConnection;
-import java.net.UnknownServiceException;
 import java.net.URL;
+import java.net.UnknownServiceException;
 import java.security.cert.Certificate;
 import java.util.ArrayList;
 import java.util.Arrays;
@@ -154,6 +154,15 @@
     }
   }
 
+  @Test public void invalidPort() throws Exception {
+    Request request = new Request.Builder()
+        .url("http://localhost:65536/")
+        .build();
+    client.newCall(request).enqueue(callback);
+    callback.await(request.url())
+        .assertFailure("No route to localhost:65536; port is out of range");
+  }
+
   @Test public void getReturns500() throws Exception {
     server.enqueue(new MockResponse().setResponseCode(500));
 
@@ -389,6 +398,23 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
     delete();
   }
 
+  @Test public void deleteWithRequestBody() throws Exception {
+    server.enqueue(new MockResponse().setBody("abc"));
+
+    Request request = new Request.Builder()
+        .url(server.getUrl("/"))
+        .method("DELETE", RequestBody.create(MediaType.parse("text/plain"), "def"))
+        .build();
+
+    executeSynchronously(request)
+        .assertCode(200)
+        .assertBody("abc");
+
+    RecordedRequest recordedRequest = server.takeRequest();
+    assertEquals("DELETE", recordedRequest.getMethod());
+    assertEquals("def", recordedRequest.getBody().readUtf8());
+  }
+
   @Test public void put() throws Exception {
     server.enqueue(new MockResponse().setBody("abc"));
 
diff --git a/okhttp-tests/src/test/java/com/squareup/okhttp/InterceptorTest.java b/okhttp-tests/src/test/java/com/squareup/okhttp/InterceptorTest.java
index d186f4af2a..2546c8cb61 100644
--- a/okhttp-tests/src/test/java/com/squareup/okhttp/InterceptorTest.java
+++ b/okhttp-tests/src/test/java/com/squareup/okhttp/InterceptorTest.java
@@ -23,6 +23,11 @@
 import java.util.Arrays;
 import java.util.List;
 import java.util.Locale;
+import java.util.concurrent.BlockingQueue;
+import java.util.concurrent.LinkedBlockingQueue;
+import java.util.concurrent.SynchronousQueue;
+import java.util.concurrent.ThreadPoolExecutor;
+import java.util.concurrent.TimeUnit;
 import okio.Buffer;
 import okio.BufferedSink;
 import okio.ForwardingSink;
@@ -430,6 +435,97 @@ private void asyncInterceptors(List<Interceptor> interceptors) throws Exception
     callbackB.await(requestB.url()).assertBody("b");
   }
 
+  @Test public void applicationkInterceptorThrowsRuntimeExceptionSynchronous() throws Exception {
+    interceptorThrowsRuntimeExceptionSynchronous(client.interceptors());
+  }
+
+  @Test public void networkInterceptorThrowsRuntimeExceptionSynchronous() throws Exception {
+    interceptorThrowsRuntimeExceptionSynchronous(client.networkInterceptors());
+  }
+
+  /**
+   * When an interceptor throws an unexpected exception, synchronous callers can catch it and deal
+   * with it.
+   *
+   * TODO(jwilson): test that resources are not leaked when this happens.
+   */
+  private void interceptorThrowsRuntimeExceptionSynchronous(
+      List<Interceptor> interceptors) throws Exception {
+    interceptors.add(new Interceptor() {
+      @Override public Response intercept(Chain chain) throws IOException {
+        throw new RuntimeException("boom!");
+      }
+    });
+
+    Request request = new Request.Builder()
+        .url(server.getUrl("/"))
+        .build();
+
+    try {
+      client.newCall(request).execute();
+      fail();
+    } catch (RuntimeException expected) {
+      assertEquals("boom!", expected.getMessage());
+    }
+  }
+
+  @Test public void applicationInterceptorThrowsRuntimeExceptionAsynchronous() throws Exception {
+    interceptorThrowsRuntimeExceptionAsynchronous(client.interceptors());
+  }
+
+  @Test public void networkInterceptorThrowsRuntimeExceptionAsynchronous() throws Exception {
+    interceptorThrowsRuntimeExceptionAsynchronous(client.networkInterceptors());
+  }
+
+  @Test public void networkInterceptorModifiedRequestIsReturned() throws IOException {
+    server.enqueue(new MockResponse());
+
+    Interceptor modifyHeaderInterceptor = new Interceptor() {
+      @Override public Response intercept(Chain chain) throws IOException {
+        return chain.proceed(chain.request().newBuilder()
+          .header("User-Agent", "intercepted request")
+          .build());
+      }
+    };
+
+    client.networkInterceptors().add(modifyHeaderInterceptor);
+
+    Request request = new Request.Builder()
+        .url(server.getUrl("/"))
+        .header("User-Agent", "user request")
+        .build();
+
+    Response response = client.newCall(request).execute();
+    assertNotNull(response.request().header("User-Agent"));
+    assertEquals("user request", response.request().header("User-Agent"));
+    assertEquals("intercepted request", response.networkResponse().request().header("User-Agent"));
+  }
+
+  /**
+   * When an interceptor throws an unexpected exception, asynchronous callers are left hanging. The
+   * exception goes to the uncaught exception handler.
+   *
+   * TODO(jwilson): test that resources are not leaked when this happens.
+   */
+  private void interceptorThrowsRuntimeExceptionAsynchronous(
+        List<Interceptor> interceptors) throws Exception {
+    interceptors.add(new Interceptor() {
+      @Override public Response intercept(Chain chain) throws IOException {
+        throw new RuntimeException("boom!");
+      }
+    });
+
+    ExceptionCatchingExecutor executor = new ExceptionCatchingExecutor();
+    client.setDispatcher(new Dispatcher(executor));
+
+    Request request = new Request.Builder()
+        .url(server.getUrl("/"))
+        .build();
+    client.newCall(request).enqueue(callback);
+
+    assertEquals("boom!", executor.takeException().getMessage());
+  }
+
   private RequestBody uppercase(final RequestBody original) {
     return new RequestBody() {
       @Override public MediaType contentType() {
@@ -480,4 +576,29 @@ private Buffer gzip(String data) throws IOException {
     sink.close();
     return result;
   }
+
+  /** Catches exceptions that are otherwise headed for the uncaught exception handler. */
+  private static class ExceptionCatchingExecutor extends ThreadPoolExecutor {
+    private final BlockingQueue<Exception> exceptions = new LinkedBlockingQueue<>();
+
+    public ExceptionCatchingExecutor() {
+      super(1, 1, 0, TimeUnit.SECONDS, new SynchronousQueue<Runnable>());
+    }
+
+    @Override public void execute(final Runnable runnable) {
+      super.execute(new Runnable() {
+        @Override public void run() {
+          try {
+            runnable.run();
+          } catch (Exception e) {
+            exceptions.add(e);
+          }
+        }
+      });
+    }
+
+    public Exception takeException() throws InterruptedException {
+      return exceptions.take();
+    }
+  }
 }
diff --git a/okhttp-tests/src/test/java/com/squareup/okhttp/MultipartBuilderTest.java b/okhttp-tests/src/test/java/com/squareup/okhttp/MultipartBuilderTest.java
index 0e12470afb..4159679c76 100644
--- a/okhttp-tests/src/test/java/com/squareup/okhttp/MultipartBuilderTest.java
+++ b/okhttp-tests/src/test/java/com/squareup/okhttp/MultipartBuilderTest.java
@@ -46,7 +46,8 @@ public void onePartRequired() throws Exception {
 
     Buffer buffer = new Buffer();
     requestBody.writeTo(buffer);
-    assertEquals(-1L, requestBody.contentLength());
+    assertEquals(53, requestBody.contentLength());
+    assertEquals(buffer.size(), requestBody.contentLength());
     assertEquals(expected, buffer.readUtf8());
   }
 
@@ -76,7 +77,8 @@ public void onePartRequired() throws Exception {
 
     Buffer buffer = new Buffer();
     requestBody.writeTo(buffer);
-    assertEquals(-1L, requestBody.contentLength());
+    assertEquals(112, requestBody.contentLength());
+    assertEquals(buffer.size(), requestBody.contentLength());
     assertEquals(expected, buffer.readUtf8());
   }
 
@@ -90,6 +92,7 @@ public void onePartRequired() throws Exception {
         + "--AaB03x\r\n"
         + "Content-Disposition: form-data; name=\"files\"\r\n"
         + "Content-Type: multipart/mixed; boundary=BbC04y\r\n"
+        + "Content-Length: 337\r\n"
         + "\r\n"
         + "--BbC04y\r\n"
         + "Content-Disposition: file; filename=\"file1.txt\"\r\n"
@@ -131,7 +134,8 @@ public void onePartRequired() throws Exception {
 
     Buffer buffer = new Buffer();
     requestBody.writeTo(buffer);
-    assertEquals(-1L, requestBody.contentLength());
+    assertEquals(568, requestBody.contentLength());
+    assertEquals(buffer.size(), requestBody.contentLength());
     assertEquals(expected, buffer.readUtf8());
   }
 
diff --git a/okhttp-tests/src/test/java/com/squareup/okhttp/OkHttpClientTest.java b/okhttp-tests/src/test/java/com/squareup/okhttp/OkHttpClientTest.java
index 1fdaf1b912..aae429507f 100644
--- a/okhttp-tests/src/test/java/com/squareup/okhttp/OkHttpClientTest.java
+++ b/okhttp-tests/src/test/java/com/squareup/okhttp/OkHttpClientTest.java
@@ -146,6 +146,15 @@
     assertNull(client.internalCache());
   }
 
+  @Test public void clonedInterceptorsListsAreIndependent() throws Exception {
+    OkHttpClient original = new OkHttpClient();
+    OkHttpClient clone = original.clone();
+    clone.interceptors().add(null);
+    clone.networkInterceptors().add(null);
+    assertEquals(0, original.interceptors().size());
+    assertEquals(0, original.networkInterceptors().size());
+  }
+
   /**
    * When copying the client, stateful things like the connection pool are
    * shared across all clients.
@@ -168,49 +177,6 @@
     assertSame(a.getSslSocketFactory(), b.getSslSocketFactory());
   }
 
-  /** We don't want to run user code inside of HttpEngine, etc. */
-  @Test public void copyWithDefaultsDoesNotReturnSubclass() throws Exception {
-    OkHttpClient subclass = new OkHttpClient() {};
-    OkHttpClient copy = subclass.copyWithDefaults();
-    assertEquals(OkHttpClient.class, copy.getClass());
-  }
-
-  @Test public void cloneReturnsSubclass() throws Exception {
-    OkHttpClient subclass = new OkHttpClient() {};
-    OkHttpClient clone = subclass.clone();
-    assertEquals(subclass.getClass(), clone.getClass());
-  }
-
-  /** Exercise a synchronous mocking case. */
-  @Test public void mock() throws Exception {
-    final Request request = new Request.Builder()
-        .url("http://example.com/")
-        .build();
-    final Response response = new Response.Builder()
-        .protocol(Protocol.HTTP_1_1)
-        .request(request)
-        .code(200)
-        .message("Alright")
-        .build();
-
-    OkHttpClient mockClient = new OkHttpClient() {
-      @Override public Call newCall(Request request) {
-        return new Call(this, request) {
-          @Override public Response execute() throws IOException {
-            return response;
-          }
-          @Override public void enqueue(Callback responseCallback) {
-          }
-          @Override public void cancel() {
-          }
-        };
-      }
-    };
-
-    Response actualResponse = mockClient.newCall(request).execute();
-    assertSame(response, actualResponse);
-  }
-
   @Test public void setProtocolsRejectsHttp10() throws Exception {
     OkHttpClient client = new OkHttpClient();
     try {
diff --git a/okhttp-tests/src/test/java/com/squareup/okhttp/RecordedResponse.java b/okhttp-tests/src/test/java/com/squareup/okhttp/RecordedResponse.java
index fdb1404df6..129fecf145 100644
--- a/okhttp-tests/src/test/java/com/squareup/okhttp/RecordedResponse.java
+++ b/okhttp-tests/src/test/java/com/squareup/okhttp/RecordedResponse.java
@@ -15,7 +15,7 @@
  */
 package com.squareup.okhttp;
 
-import com.squareup.okhttp.internal.ws.WebSocket;
+import com.squareup.okhttp.ws.WebSocket;
 import java.io.IOException;
 import java.net.URL;
 import java.util.Arrays;
diff --git a/okhttp-tests/src/test/java/com/squareup/okhttp/RequestTest.java b/okhttp-tests/src/test/java/com/squareup/okhttp/RequestTest.java
index 8a74d1b6e8..a1249e5903 100644
--- a/okhttp-tests/src/test/java/com/squareup/okhttp/RequestTest.java
+++ b/okhttp-tests/src/test/java/com/squareup/okhttp/RequestTest.java
@@ -64,6 +64,15 @@
     assertEquals("Retransmit body", "616263", bodyToHex(body));
   }
 
+  @Test public void byteArrayRange() throws Exception {
+    MediaType contentType = MediaType.parse("text/plain");
+    RequestBody body = RequestBody.create(contentType, ".abcd".getBytes(Util.UTF_8), 1, 3);
+    assertEquals(contentType, body.contentType());
+    assertEquals(3, body.contentLength());
+    assertEquals("616263", bodyToHex(body));
+    assertEquals("Retransmit body", "616263", bodyToHex(body));
+  }
+
   @Test public void file() throws Exception {
     File file = File.createTempFile("RequestTest", "tmp");
     FileWriter writer = new FileWriter(file);
@@ -114,6 +123,18 @@
     assertEquals(new URL("http://localhost/api"), request.url());
   }
 
+  @Test public void newBuilderUrlResetsUrl() throws Exception {
+    Request requestWithoutCache = new Request.Builder().url("http://localhost/api").build();
+    Request builtRequestWithoutCache = requestWithoutCache.newBuilder().url("http://localhost/api/foo").build();
+    assertEquals(new URL("http://localhost/api/foo"), builtRequestWithoutCache.url());
+
+    Request requestWithCache = new Request.Builder().url("http://localhost/api").build();
+    // cache url object
+    requestWithCache.url();
+    Request builtRequestWithCache = requestWithCache.newBuilder().url("http://localhost/api/foo").build();
+    assertEquals(new URL("http://localhost/api/foo"), builtRequestWithCache.url());
+  }
+
   @Test public void cacheControl() throws Exception {
     Request request = new Request.Builder()
         .cacheControl(new CacheControl.Builder().noCache().build())
diff --git a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/DiskLruCacheTest.java b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/DiskLruCacheTest.java
index 7326a0da22..c996d202dd 100644
--- a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/DiskLruCacheTest.java
+++ b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/DiskLruCacheTest.java
@@ -15,14 +15,9 @@
  */
 package com.squareup.okhttp.internal;
 
-import java.io.BufferedReader;
+import com.squareup.okhttp.internal.io.FileSystem;
 import java.io.File;
-import java.io.FileReader;
-import java.io.FileWriter;
 import java.io.IOException;
-import java.io.Reader;
-import java.io.StringWriter;
-import java.io.Writer;
 import java.util.ArrayDeque;
 import java.util.ArrayList;
 import java.util.Arrays;
@@ -57,6 +52,7 @@
   @Rule public final TemporaryFolder tempDir = new TemporaryFolder();
   @Rule public final Timeout timeout = new Timeout(30 * 1000);
 
+  private final FaultyFileSystem fileSystem = new FaultyFileSystem(FileSystem.SYSTEM);
   private final int appVersion = 100;
   private File cacheDir;
   private File journalFile;
@@ -71,7 +67,7 @@ private void createNewCache() throws IOException {
   }
 
   private void createNewCacheWithSize(int maxSize) throws IOException {
-    cache = new DiskLruCache(cacheDir, appVersion, 2, maxSize, executor);
+    cache = new DiskLruCache(fileSystem, cacheDir, appVersion, 2, maxSize, executor);
     synchronized (cache) {
       cache.initialize();
     }
@@ -272,7 +268,7 @@ private void createNewCacheWithSize(int maxSize) throws IOException {
     File k1 = getCleanFile("k1", 0);
     assertEquals("ABC", readFile(k1));
     cache.remove("k1");
-    assertFalse(k1.exists());
+    assertFalse(fileSystem.exists(k1));
   }
 
   @Test public void removePreventsActiveEditFromStoringAValue() throws Exception {
@@ -328,10 +324,10 @@ private void createNewCacheWithSize(int maxSize) throws IOException {
     writeFile(dirtyFile1, "D");
     createJournal("CLEAN k1 1 1", "DIRTY   k1");
     createNewCache();
-    assertFalse(cleanFile0.exists());
-    assertFalse(cleanFile1.exists());
-    assertFalse(dirtyFile0.exists());
-    assertFalse(dirtyFile1.exists());
+    assertFalse(fileSystem.exists(cleanFile0));
+    assertFalse(fileSystem.exists(cleanFile1));
+    assertFalse(fileSystem.exists(dirtyFile0));
+    assertFalse(fileSystem.exists(dirtyFile1));
     assertNull(cache.get("k1"));
   }
 
@@ -389,9 +385,10 @@ private void createNewCacheWithSize(int maxSize) throws IOException {
     cache.close();
     writeFile(getCleanFile("k1", 0), "A");
     writeFile(getCleanFile("k1", 1), "B");
-    Writer writer = new FileWriter(journalFile);
-    writer.write(MAGIC + "\n" + VERSION_1 + "\n100\n2\n\nCLEAN k1 1 1"); // no trailing newline
-    writer.close();
+
+    BufferedSink sink = Okio.buffer(fileSystem.sink(journalFile));
+    sink.writeUtf8(MAGIC + "\n" + VERSION_1 + "\n100\n2\n\nCLEAN k1 1 1"); // no trailing newline
+    sink.close();
     createNewCache();
     assertNull(cache.get("k1"));
 
@@ -453,10 +450,10 @@ private void createNewCacheWithSize(int maxSize) throws IOException {
     } catch (IllegalStateException expected) {
     }
 
-    assertFalse(getCleanFile("k1", 0).exists());
-    assertFalse(getCleanFile("k1", 1).exists());
-    assertFalse(getDirtyFile("k1", 0).exists());
-    assertFalse(getDirtyFile("k1", 1).exists());
+    assertFalse(fileSystem.exists(getCleanFile("k1", 0)));
+    assertFalse(fileSystem.exists(getCleanFile("k1", 1)));
+    assertFalse(fileSystem.exists(getDirtyFile("k1", 0)));
+    assertFalse(fileSystem.exists(getDirtyFile("k1", 1)));
     assertNull(cache.get("k1"));
 
     DiskLruCache.Editor creator2 = cache.edit("k1");
@@ -469,10 +466,10 @@ private void createNewCacheWithSize(int maxSize) throws IOException {
     DiskLruCache.Editor creator = cache.edit("k1");
     setString(creator, 1, "A");
     creator.abort();
-    assertFalse(getCleanFile("k1", 0).exists());
-    assertFalse(getCleanFile("k1", 1).exists());
-    assertFalse(getDirtyFile("k1", 0).exists());
-    assertFalse(getDirtyFile("k1", 1).exists());
+    assertFalse(fileSystem.exists(getCleanFile("k1", 0)));
+    assertFalse(fileSystem.exists(getCleanFile("k1", 1)));
+    assertFalse(fileSystem.exists(getDirtyFile("k1", 0)));
+    assertFalse(fileSystem.exists(getDirtyFile("k1", 1)));
     assertNull(cache.get("k1"));
   }
 
@@ -632,7 +629,7 @@ private void createNewCacheWithSize(int maxSize) throws IOException {
 
   @Test public void constructorDoesNotAllowZeroCacheSize() throws Exception {
     try {
-      DiskLruCache.create(cacheDir, appVersion, 2, 0);
+      DiskLruCache.create(fileSystem, cacheDir, appVersion, 2, 0);
       fail();
     } catch (IllegalArgumentException expected) {
     }
@@ -640,7 +637,7 @@ private void createNewCacheWithSize(int maxSize) throws IOException {
 
   @Test public void constructorDoesNotAllowZeroValuesPerEntry() throws Exception {
     try {
-      DiskLruCache.create(cacheDir, appVersion, 0, 10);
+      DiskLruCache.create(fileSystem, cacheDir, appVersion, 0, 10);
       fail();
     } catch (IllegalArgumentException expected) {
     }
@@ -707,8 +704,8 @@ private void createNewCacheWithSize(int maxSize) throws IOException {
     creator.commit();
     cache.close();
 
-    assertTrue(journalFile.renameTo(journalBkpFile));
-    assertFalse(journalFile.exists());
+    fileSystem.rename(journalFile, journalBkpFile);
+    assertFalse(fileSystem.exists(journalFile));
 
     createNewCache();
 
@@ -716,8 +713,8 @@ private void createNewCacheWithSize(int maxSize) throws IOException {
     assertSnapshotValue(snapshot, 0, "ABC");
     assertSnapshotValue(snapshot, 1, "DE");
 
-    assertFalse(journalBkpFile.exists());
-    assertTrue(journalFile.exists());
+    assertFalse(fileSystem.exists(journalBkpFile));
+    assertTrue(fileSystem.exists(journalFile));
   }
 
   @Test public void journalFileIsPreferredOverBackupFile() throws Exception {
@@ -735,8 +732,8 @@ private void createNewCacheWithSize(int maxSize) throws IOException {
     creator.commit();
     cache.close();
 
-    assertTrue(journalFile.exists());
-    assertTrue(journalBkpFile.exists());
+    assertTrue(fileSystem.exists(journalFile));
+    assertTrue(fileSystem.exists(journalBkpFile));
 
     createNewCache();
 
@@ -748,23 +745,23 @@ private void createNewCacheWithSize(int maxSize) throws IOException {
     assertSnapshotValue(snapshotB, 0, "F");
     assertSnapshotValue(snapshotB, 1, "GH");
 
-    assertFalse(journalBkpFile.exists());
-    assertTrue(journalFile.exists());
+    assertFalse(fileSystem.exists(journalBkpFile));
+    assertTrue(fileSystem.exists(journalFile));
   }
 
   @Test public void openCreatesDirectoryIfNecessary() throws Exception {
     cache.close();
     File dir = tempDir.newFolder("testOpenCreatesDirectoryIfNecessary");
-    cache = DiskLruCache.create(dir, appVersion, 2, Integer.MAX_VALUE);
+    cache = DiskLruCache.create(fileSystem, dir, appVersion, 2, Integer.MAX_VALUE);
     set("a", "a", "a");
-    assertTrue(new File(dir, "a.0").exists());
-    assertTrue(new File(dir, "a.1").exists());
-    assertTrue(new File(dir, "journal").exists());
+    assertTrue(fileSystem.exists(new File(dir, "a.0")));
+    assertTrue(fileSystem.exists(new File(dir, "a.1")));
+    assertTrue(fileSystem.exists(new File(dir, "journal")));
   }
 
   @Test public void fileDeletedExternally() throws Exception {
     set("a", "a", "a");
-    getCleanFile("a", 1).delete();
+    fileSystem.delete(getCleanFile("a", 1));
     assertNull(cache.get("a"));
   }
 
@@ -823,7 +820,7 @@ private void createNewCacheWithSize(int maxSize) throws IOException {
 
   /** @see <a href="https://github.com/JakeWharton/DiskLruCache/issues/2">Issue #2</a> */
   @Test public void aggressiveClearingHandlesWrite() throws Exception {
-    tempDir.delete();
+    fileSystem.deleteContents(tempDir.getRoot());
     set("a", "a", "a");
     assertValue("a", "a", "a");
   }
@@ -832,7 +829,7 @@ private void createNewCacheWithSize(int maxSize) throws IOException {
   @Test public void aggressiveClearingHandlesEdit() throws Exception {
     set("a", "a", "a");
     DiskLruCache.Editor a = cache.get("a").edit();
-    tempDir.delete();
+    fileSystem.deleteContents(tempDir.getRoot());
     setString(a, 1, "a2");
     a.commit();
   }
@@ -849,7 +846,7 @@ private void createNewCacheWithSize(int maxSize) throws IOException {
     set("b", "b", "b");
     DiskLruCache.Editor a = cache.get("a").edit();
     setString(a, 0, "a1");
-    tempDir.delete();
+    fileSystem.deleteContents(tempDir.getRoot());
     setString(a, 1, "a2");
     a.commit();
     assertNull(cache.get("a"));
@@ -857,7 +854,7 @@ private void createNewCacheWithSize(int maxSize) throws IOException {
 
   /** @see <a href="https://github.com/JakeWharton/DiskLruCache/issues/2">Issue #2</a> */
   @Test public void aggressiveClearingHandlesRead() throws Exception {
-    tempDir.delete();
+    fileSystem.deleteContents(tempDir.getRoot());
     assertNull(cache.get("a"));
   }
 
@@ -1064,7 +1061,7 @@ private void createNewCacheWithSize(int maxSize) throws IOException {
 
   @Test public void isClosed_uninitializedCache() throws Exception {
     // Create an uninitialized cache.
-    cache = new DiskLruCache(cacheDir, appVersion, 2, Integer.MAX_VALUE, executor);
+    cache = new DiskLruCache(fileSystem, cacheDir, appVersion, 2, Integer.MAX_VALUE, executor);
     toClose.add(cache);
 
     assertFalse(cache.isClosed());
@@ -1072,6 +1069,95 @@ private void createNewCacheWithSize(int maxSize) throws IOException {
     assertTrue(cache.isClosed());
   }
 
+  @Test public void journalWriteFailsDuringEdit() throws Exception {
+    set("a", "a", "a");
+    set("b", "b", "b");
+
+    // We can't begin the edit if writing 'DIRTY' fails.
+    fileSystem.setFaulty(journalFile, true);
+    assertNull(cache.edit("c"));
+
+    // Once the journal has a failure, subsequent writes aren't permitted.
+    fileSystem.setFaulty(journalFile, false);
+    assertNull(cache.edit("d"));
+
+    // Confirm that the fault didn't corrupt entries stored before the fault was introduced.
+    cache.close();
+    cache = new DiskLruCache(fileSystem, cacheDir, appVersion, 2, Integer.MAX_VALUE, executor);
+    assertValue("a", "a", "a");
+    assertValue("b", "b", "b");
+    assertAbsent("c");
+    assertAbsent("d");
+  }
+
+  /**
+   * We had a bug where the cache was left in an inconsistent state after a journal write failed.
+   * https://github.com/square/okhttp/issues/1211
+   */
+  @Test public void journalWriteFailsDuringEditorCommit() throws Exception {
+    set("a", "a", "a");
+    set("b", "b", "b");
+
+    // Create an entry that fails to write to the journal during commit.
+    DiskLruCache.Editor editor = cache.edit("c");
+    setString(editor, 0, "c");
+    setString(editor, 1, "c");
+    fileSystem.setFaulty(journalFile, true);
+    editor.commit();
+
+    // Once the journal has a failure, subsequent writes aren't permitted.
+    fileSystem.setFaulty(journalFile, false);
+    assertNull(cache.edit("d"));
+
+    // Confirm that the fault didn't corrupt entries stored before the fault was introduced.
+    cache.close();
+    cache = new DiskLruCache(fileSystem, cacheDir, appVersion, 2, Integer.MAX_VALUE, executor);
+    assertValue("a", "a", "a");
+    assertValue("b", "b", "b");
+    assertAbsent("c");
+    assertAbsent("d");
+  }
+
+  @Test public void journalWriteFailsDuringEditorAbort() throws Exception {
+    set("a", "a", "a");
+    set("b", "b", "b");
+
+    // Create an entry that fails to write to the journal during abort.
+    DiskLruCache.Editor editor = cache.edit("c");
+    setString(editor, 0, "c");
+    setString(editor, 1, "c");
+    fileSystem.setFaulty(journalFile, true);
+    editor.abort();
+
+    // Once the journal has a failure, subsequent writes aren't permitted.
+    fileSystem.setFaulty(journalFile, false);
+    assertNull(cache.edit("d"));
+
+    // Confirm that the fault didn't corrupt entries stored before the fault was introduced.
+    cache.close();
+    cache = new DiskLruCache(fileSystem, cacheDir, appVersion, 2, Integer.MAX_VALUE, executor);
+    assertValue("a", "a", "a");
+    assertValue("b", "b", "b");
+    assertAbsent("c");
+    assertAbsent("d");
+  }
+
+  @Test public void journalWriteFailsDuringRemove() throws Exception {
+    set("a", "a", "a");
+    set("b", "b", "b");
+
+    // Remove, but the journal write will fail.
+    fileSystem.setFaulty(journalFile, true);
+    assertTrue(cache.remove("a"));
+
+    // Confirm that the entry was still removed.
+    fileSystem.setFaulty(journalFile, false);
+    cache.close();
+    cache = new DiskLruCache(fileSystem, cacheDir, appVersion, 2, Integer.MAX_VALUE, executor);
+    assertAbsent("a");
+    assertValue("b", "b", "b");
+  }
+
   private void assertJournalEquals(String... expectedBodyLines) throws Exception {
     List<String> expectedLines = new ArrayList<>();
     expectedLines.add(MAGIC);
@@ -1089,27 +1175,26 @@ private void createJournal(String... bodyLines) throws Exception {
 
   private void createJournalWithHeader(String magic, String version, String appVersion,
       String valueCount, String blank, String... bodyLines) throws Exception {
-    Writer writer = new FileWriter(journalFile);
-    writer.write(magic + "\n");
-    writer.write(version + "\n");
-    writer.write(appVersion + "\n");
-    writer.write(valueCount + "\n");
-    writer.write(blank + "\n");
+    BufferedSink sink = Okio.buffer(fileSystem.sink(journalFile));
+    sink.writeUtf8(magic + "\n");
+    sink.writeUtf8(version + "\n");
+    sink.writeUtf8(appVersion + "\n");
+    sink.writeUtf8(valueCount + "\n");
+    sink.writeUtf8(blank + "\n");
     for (String line : bodyLines) {
-      writer.write(line);
-      writer.write('\n');
+      sink.writeUtf8(line);
+      sink.writeUtf8("\n");
     }
-    writer.close();
+    sink.close();
   }
 
   private List<String> readJournalLines() throws Exception {
     List<String> result = new ArrayList<>();
-    BufferedReader reader = new BufferedReader(new FileReader(journalFile));
-    String line;
-    while ((line = reader.readLine()) != null) {
+    BufferedSource source = Okio.buffer(fileSystem.source(journalFile));
+    for (String line; (line = source.readUtf8Line()) != null; ) {
       result.add(line);
     }
-    reader.close();
+    source.close();
     return result;
   }
 
@@ -1121,22 +1206,17 @@ private File getDirtyFile(String key, int index) {
     return new File(cacheDir, key + "." + index + ".tmp");
   }
 
-  private static String readFile(File file) throws Exception {
-    Reader reader = new FileReader(file);
-    StringWriter writer = new StringWriter();
-    char[] buffer = new char[1024];
-    int count;
-    while ((count = reader.read(buffer)) != -1) {
-      writer.write(buffer, 0, count);
-    }
-    reader.close();
-    return writer.toString();
+  private String readFile(File file) throws Exception {
+    BufferedSource source = Okio.buffer(fileSystem.source(file));
+    String result = source.readUtf8();
+    source.close();
+    return result;
   }
 
-  public static void writeFile(File file, String content) throws Exception {
-    FileWriter writer = new FileWriter(file);
-    writer.write(content);
-    writer.close();
+  public void writeFile(File file, String content) throws Exception {
+    BufferedSink sink = Okio.buffer(fileSystem.sink(file));
+    sink.writeUtf8(content);
+    sink.close();
   }
 
   private static void assertInoperable(DiskLruCache.Editor editor) throws Exception {
@@ -1176,18 +1256,16 @@ private void generateSomeGarbageFiles() throws Exception {
     writeFile(getCleanFile("g2", 1), "D");
     writeFile(getCleanFile("g2", 1), "D");
     writeFile(new File(cacheDir, "otherFile0"), "E");
-    dir1.mkdir();
-    dir2.mkdir();
     writeFile(new File(dir2, "otherFile1"), "F");
   }
 
   private void assertGarbageFilesAllDeleted() throws Exception {
-    assertFalse(getCleanFile("g1", 0).exists());
-    assertFalse(getCleanFile("g1", 1).exists());
-    assertFalse(getCleanFile("g2", 0).exists());
-    assertFalse(getCleanFile("g2", 1).exists());
-    assertFalse(new File(cacheDir, "otherFile0").exists());
-    assertFalse(new File(cacheDir, "dir1").exists());
+    assertFalse(fileSystem.exists(getCleanFile("g1", 0)));
+    assertFalse(fileSystem.exists(getCleanFile("g1", 1)));
+    assertFalse(fileSystem.exists(getCleanFile("g2", 0)));
+    assertFalse(fileSystem.exists(getCleanFile("g2", 1)));
+    assertFalse(fileSystem.exists(new File(cacheDir, "otherFile0")));
+    assertFalse(fileSystem.exists(new File(cacheDir, "dir1")));
   }
 
   private void set(String key, String value0, String value1) throws Exception {
@@ -1209,18 +1287,18 @@ private void assertAbsent(String key) throws Exception {
       snapshot.close();
       fail();
     }
-    assertFalse(getCleanFile(key, 0).exists());
-    assertFalse(getCleanFile(key, 1).exists());
-    assertFalse(getDirtyFile(key, 0).exists());
-    assertFalse(getDirtyFile(key, 1).exists());
+    assertFalse(fileSystem.exists(getCleanFile(key, 0)));
+    assertFalse(fileSystem.exists(getCleanFile(key, 1)));
+    assertFalse(fileSystem.exists(getDirtyFile(key, 0)));
+    assertFalse(fileSystem.exists(getDirtyFile(key, 1)));
   }
 
   private void assertValue(String key, String value0, String value1) throws Exception {
     DiskLruCache.Snapshot snapshot = cache.get(key);
     assertSnapshotValue(snapshot, 0, value0);
     assertSnapshotValue(snapshot, 1, value1);
-    assertTrue(getCleanFile(key, 0).exists());
-    assertTrue(getCleanFile(key, 1).exists());
+    assertTrue(fileSystem.exists(getCleanFile(key, 0)));
+    assertTrue(fileSystem.exists(getCleanFile(key, 1)));
     snapshot.close();
   }
 
@@ -1235,8 +1313,8 @@ private String sourceAsString(Source source) throws IOException {
   }
 
   private void copyFile(File from, File to) throws IOException {
-    Source source = Okio.source(from);
-    BufferedSink sink = Okio.buffer(Okio.sink(to));
+    Source source = fileSystem.source(from);
+    BufferedSink sink = Okio.buffer(fileSystem.sink(to));
     sink.writeAll(source);
     source.close();
     sink.close();
diff --git a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/FaultyFileSystem.java b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/FaultyFileSystem.java
new file mode 100644
index 0000000000..537f361c38
--- /dev/null
+++ b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/FaultyFileSystem.java
@@ -0,0 +1,90 @@
+/*
+ * Copyright (C) 2011 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.okhttp.internal;
+
+import com.squareup.okhttp.internal.io.FileSystem;
+import java.io.File;
+import java.io.FileNotFoundException;
+import java.io.IOException;
+import java.util.LinkedHashSet;
+import java.util.Set;
+import okio.Buffer;
+import okio.ForwardingSink;
+import okio.Sink;
+import okio.Source;
+
+public final class FaultyFileSystem implements FileSystem {
+  private final FileSystem delegate;
+  private final Set<File> writeFaults = new LinkedHashSet<>();
+
+  public FaultyFileSystem(FileSystem delegate) {
+    this.delegate = delegate;
+  }
+
+  public void setFaulty(File file, boolean faulty) {
+    if (faulty) {
+      writeFaults.add(file);
+    } else {
+      writeFaults.remove(file);
+    }
+  }
+
+  @Override public Source source(File file) throws FileNotFoundException {
+    return delegate.source(file);
+  }
+
+  @Override public Sink sink(File file) throws FileNotFoundException {
+    return new FaultySink(delegate.sink(file), file);
+  }
+
+  @Override public Sink appendingSink(File file) throws FileNotFoundException {
+    return new FaultySink(delegate.appendingSink(file), file);
+  }
+
+  @Override public void delete(File file) throws IOException {
+    delegate.delete(file);
+  }
+
+  @Override public boolean exists(File file) throws IOException {
+    return delegate.exists(file);
+  }
+
+  @Override public long size(File file) {
+    return delegate.size(file);
+  }
+
+  @Override public void rename(File from, File to) throws IOException {
+    delegate.rename(from, to);
+  }
+
+  @Override public void deleteContents(File directory) throws IOException {
+    delegate.deleteContents(directory);
+  }
+
+  private class FaultySink extends ForwardingSink {
+    private final File file;
+
+    public FaultySink(Sink delegate, File file) {
+      super(delegate);
+      this.file = file;
+    }
+
+    @Override public void write(Buffer source, long byteCount) throws IOException {
+      if (writeFaults.contains(file)) throw new IOException("boom!");
+      super.write(source, byteCount);
+    }
+  }
+}
diff --git a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/HttpOverHttp20Draft16Test.java b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/HttpOverHttp2Test.java
similarity index 96%
rename from okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/HttpOverHttp20Draft16Test.java
rename to okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/HttpOverHttp2Test.java
index 7659110e9c..91ba56cef3 100644
--- a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/HttpOverHttp20Draft16Test.java
+++ b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/HttpOverHttp2Test.java
@@ -24,9 +24,9 @@
 
 import static org.junit.Assert.assertEquals;
 
-public class HttpOverHttp20Draft16Test extends HttpOverSpdyTest {
+public class HttpOverHttp2Test extends HttpOverSpdyTest {
 
-  public HttpOverHttp20Draft16Test() {
+  public HttpOverHttp2Test() {
     super(Protocol.HTTP_2);
     this.hostHeader = ":authority";
   }
diff --git a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/URLConnectionTest.java b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/URLConnectionTest.java
index 330929b332..b9c6793328 100644
--- a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/URLConnectionTest.java
+++ b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/URLConnectionTest.java
@@ -1075,6 +1075,28 @@ private void testMarkAndReset(TransferKind transferKind) throws IOException {
     }
   }
 
+  @Test public void malformedChunkSize() throws IOException {
+    server.enqueue(new MockResponse().setBody("5:x\r\nABCDE\r\n0\r\n\r\n")
+        .clearHeaders()
+        .addHeader("Transfer-encoding: chunked"));
+
+    URLConnection connection = client.open(server.getUrl("/"));
+    try {
+      readAscii(connection.getInputStream(), Integer.MAX_VALUE);
+      fail();
+    } catch (IOException e) {
+    }
+  }
+
+  @Test public void extensionAfterChunkSize() throws IOException {
+    server.enqueue(new MockResponse().setBody("5;x\r\nABCDE\r\n0\r\n\r\n")
+        .clearHeaders()
+        .addHeader("Transfer-encoding: chunked"));
+
+    HttpURLConnection connection = client.open(server.getUrl("/"));
+    assertContent("ABCDE", connection);
+  }
+
   @Test public void missingChunkBody() throws IOException {
     server.enqueue(new MockResponse().setBody("5")
         .clearHeaders()
@@ -2548,7 +2570,6 @@ private void testInputStreamAvailable(TransferKind transferKind) throws IOExcept
     reusedConnectionFailsWithPost(TransferKind.END_OF_STREAM, 1024);
   }
 
-  // This test is ignored because we don't (yet) reliably recover for large request bodies.
   @Test public void postFailsWithBufferedRequestForLargeRequest() throws Exception {
     reusedConnectionFailsWithPost(TransferKind.END_OF_STREAM, 16384);
   }
@@ -2581,14 +2602,24 @@ private void reusedConnectionFailsWithPost(TransferKind transferKind, int reques
     byte[] requestBody = new byte[requestSize];
     new Random(0).nextBytes(requestBody);
 
-    connection = client.open(server.getUrl("/b"));
-    connection.setRequestMethod("POST");
-    transferKind.setForRequest(connection, requestBody.length);
-    for (int i = 0; i < requestBody.length; i += 1024) {
-      connection.getOutputStream().write(requestBody, i, 1024);
+    for (int j = 0; j < 2; j++) {
+      try {
+        connection = client.open(server.getUrl("/b"));
+        connection.setRequestMethod("POST");
+        transferKind.setForRequest(connection, requestBody.length);
+        for (int i = 0; i < requestBody.length; i += 1024) {
+          connection.getOutputStream().write(requestBody, i, 1024);
+        }
+        connection.getOutputStream().close();
+        assertContent("B", connection);
+        break;
+      } catch (IOException socketException) {
+        // If there's a socket exception, this must have a streamed request body.
+        assertEquals(0, j);
+        assertTrue(transferKind == TransferKind.CHUNKED
+            || transferKind == TransferKind.FIXED_LENGTH);
+      }
     }
-    connection.getOutputStream().close();
-    assertContent("B", connection);
 
     RecordedRequest requestA = server.takeRequest();
     assertEquals("/a", requestA.getPath());
diff --git a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/io/InMemoryFileSystem.java b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/io/InMemoryFileSystem.java
new file mode 100644
index 0000000000..3a043cbd1f
--- /dev/null
+++ b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/io/InMemoryFileSystem.java
@@ -0,0 +1,75 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.okhttp.internal.io;
+
+import java.io.File;
+import java.io.FileNotFoundException;
+import java.io.IOException;
+import java.util.Iterator;
+import java.util.LinkedHashMap;
+import java.util.Map;
+import okio.Buffer;
+import okio.Sink;
+import okio.Source;
+
+/** A simple file system where all files are held in memory. Not safe for concurrent use. */
+public final class InMemoryFileSystem implements FileSystem {
+  private final Map<File, Buffer> files = new LinkedHashMap<>();
+
+  @Override public Source source(File file) throws FileNotFoundException {
+    Buffer result = files.get(file);
+    if (result == null) throw new FileNotFoundException();
+    return result.clone();
+  }
+
+  @Override public Sink sink(File file) throws FileNotFoundException {
+    Buffer result = new Buffer();
+    files.put(file, result);
+    return result;
+  }
+
+  @Override public Sink appendingSink(File file) throws FileNotFoundException {
+    Buffer result = files.get(file);
+    return result != null ? result : sink(file);
+  }
+
+  @Override public void delete(File file) throws IOException {
+    files.remove(file);
+  }
+
+  @Override public boolean exists(File file) throws IOException {
+    return files.containsKey(file);
+  }
+
+  @Override public long size(File file) {
+    Buffer buffer = files.get(file);
+    return buffer != null ? buffer.size() : 0L;
+  }
+
+  @Override public void rename(File from, File to) throws IOException {
+    Buffer buffer = files.remove(from);
+    if (buffer == null) throw new FileNotFoundException();
+    files.put(to, buffer);
+  }
+
+  @Override public void deleteContents(File directory) throws IOException {
+    String prefix = directory.toString() + "/";
+    for (Iterator<File> i = files.keySet().iterator(); i.hasNext(); ) {
+      File file = i.next();
+      if (file.toString().startsWith(prefix)) i.remove();
+    }
+  }
+}
diff --git a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/spdy/HpackDraft10Test.java b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/spdy/HpackTest.java
similarity index 98%
rename from okhttp-tests/src/test/java/com/squareup/okhttp/internal/spdy/HpackDraft10Test.java
rename to okhttp-tests/src/test/java/com/squareup/okhttp/internal/spdy/HpackTest.java
index b886a43fdd..1dcbc0192f 100644
--- a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/spdy/HpackDraft10Test.java
+++ b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/spdy/HpackTest.java
@@ -28,23 +28,23 @@
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.fail;
 
-public class HpackDraft10Test {
+public class HpackTest {
 
   private final Buffer bytesIn = new Buffer();
-  private HpackDraft10.Reader hpackReader;
+  private Hpack.Reader hpackReader;
   private Buffer bytesOut = new Buffer();
-  private HpackDraft10.Writer hpackWriter;
+  private Hpack.Writer hpackWriter;
 
   @Before public void reset() {
     hpackReader = newReader(bytesIn);
-    hpackWriter = new HpackDraft10.Writer(bytesOut);
+    hpackWriter = new Hpack.Writer(bytesOut);
   }
 
   /**
    * Variable-length quantity special cases strings which are longer than 127
    * bytes.  Values such as cookies can be 4KiB, and should be possible to send.
    *
-   * <p> http://tools.ietf.org/html/draft-ietf-httpbis-header-compression-10#section-5.2
+   * <p> http://tools.ietf.org/html/draft-ietf-httpbis-header-compression-12#section-5.2
    */
   @Test public void largeHeaderValue() throws IOException {
     char[] value = new char[4096];
@@ -163,7 +163,7 @@
   }
 
   /**
-   * http://tools.ietf.org/html/draft-ietf-httpbis-header-compression-10#appendix-C.2.1
+   * http://tools.ietf.org/html/draft-ietf-httpbis-header-compression-12#appendix-C.2.1
    */
   @Test public void readLiteralHeaderFieldWithIndexing() throws IOException {
     bytesIn.writeByte(0x40); // Literal indexed
@@ -185,7 +185,7 @@
   }
 
   /**
-   * http://tools.ietf.org/html/draft-ietf-httpbis-header-compression-10#appendix-C.2.2
+   * http://tools.ietf.org/html/draft-ietf-httpbis-header-compression-12#appendix-C.2.2
    */
   @Test public void literalHeaderFieldWithoutIndexingIndexedName() throws IOException {
     List<Header> headerBlock = headerEntries(":path", "/sample/path");
@@ -347,7 +347,7 @@
   }
 
   /**
-   * http://tools.ietf.org/html/draft-ietf-httpbis-header-compression-10#appendix-C.2.4
+   * http://tools.ietf.org/html/draft-ietf-httpbis-header-compression-12#appendix-C.2.4
    */
   @Test public void readIndexedHeaderFieldFromStaticTableWithoutBuffering() throws IOException {
     bytesIn.writeByte(0x82); // == Indexed - Add ==
@@ -363,7 +363,7 @@
   }
 
   /**
-   * http://tools.ietf.org/html/draft-ietf-httpbis-header-compression-10#appendix-C.2
+   * http://tools.ietf.org/html/draft-ietf-httpbis-header-compression-12#appendix-C.2
    */
   @Test public void readRequestExamplesWithoutHuffman() throws IOException {
     firstRequestWithoutHuffman();
@@ -492,7 +492,7 @@ private void checkReadThirdRequestWithoutHuffman() {
   }
 
   /**
-   * http://tools.ietf.org/html/draft-ietf-httpbis-header-compression-10#appendix-C.4
+   * http://tools.ietf.org/html/draft-ietf-httpbis-header-compression-12#appendix-C.4
    */
   @Test public void readRequestExamplesWithHuffman() throws IOException {
     firstRequestWithHuffman();
@@ -692,8 +692,8 @@ private void checkReadThirdRequestWithHuffman() {
     assertEquals(ByteString.EMPTY, newReader(byteStream(0)).readByteString());
   }
 
-  private HpackDraft10.Reader newReader(Buffer source) {
-    return new HpackDraft10.Reader(4096, source);
+  private Hpack.Reader newReader(Buffer source) {
+    return new Hpack.Reader(4096, source);
   }
 
   private Buffer byteStream(int... bytes) {
diff --git a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/spdy/Http2ConnectionTest.java b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/spdy/Http2ConnectionTest.java
index 13c91d1620..a13fa53c08 100644
--- a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/spdy/Http2ConnectionTest.java
+++ b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/spdy/Http2ConnectionTest.java
@@ -46,7 +46,7 @@
 import static org.junit.Assert.fail;
 
 public final class Http2ConnectionTest {
-  private static final Variant HTTP_2 = new Http20Draft16();
+  private static final Variant HTTP_2 = new Http2();
   private final MockSpdyPeer peer = new MockSpdyPeer();
 
   @After public void tearDown() throws Exception {
@@ -143,7 +143,7 @@
 
     // verify the peer's settings were read and applied.
     assertEquals(0, connection.peerSettings.getHeaderTableSize());
-    Http20Draft16.Reader frameReader = (Http20Draft16.Reader) connection.readerRunnable.frameReader;
+    Http2.Reader frameReader = (Http2.Reader) connection.readerRunnable.frameReader;
     assertEquals(0, frameReader.hpackReader.maxDynamicTableByteCount());
     // TODO: when supported, check the frameWriter's compression table is unaffected.
   }
diff --git a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/spdy/Http20Draft16FrameLoggerTest.java b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/spdy/Http2FrameLoggerTest.java
similarity index 82%
rename from okhttp-tests/src/test/java/com/squareup/okhttp/internal/spdy/Http20Draft16FrameLoggerTest.java
rename to okhttp-tests/src/test/java/com/squareup/okhttp/internal/spdy/Http2FrameLoggerTest.java
index 992611f5eb..0a0a9da8ab 100644
--- a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/spdy/Http20Draft16FrameLoggerTest.java
+++ b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/spdy/Http2FrameLoggerTest.java
@@ -20,22 +20,22 @@
 import java.util.List;
 import org.junit.Test;
 
-import static com.squareup.okhttp.internal.spdy.Http20Draft16.FLAG_ACK;
-import static com.squareup.okhttp.internal.spdy.Http20Draft16.FLAG_END_HEADERS;
-import static com.squareup.okhttp.internal.spdy.Http20Draft16.FLAG_END_STREAM;
-import static com.squareup.okhttp.internal.spdy.Http20Draft16.FLAG_NONE;
-import static com.squareup.okhttp.internal.spdy.Http20Draft16.FrameLogger.formatFlags;
-import static com.squareup.okhttp.internal.spdy.Http20Draft16.FrameLogger.formatHeader;
-import static com.squareup.okhttp.internal.spdy.Http20Draft16.TYPE_CONTINUATION;
-import static com.squareup.okhttp.internal.spdy.Http20Draft16.TYPE_DATA;
-import static com.squareup.okhttp.internal.spdy.Http20Draft16.TYPE_GOAWAY;
-import static com.squareup.okhttp.internal.spdy.Http20Draft16.TYPE_HEADERS;
-import static com.squareup.okhttp.internal.spdy.Http20Draft16.TYPE_PING;
-import static com.squareup.okhttp.internal.spdy.Http20Draft16.TYPE_PUSH_PROMISE;
-import static com.squareup.okhttp.internal.spdy.Http20Draft16.TYPE_SETTINGS;
+import static com.squareup.okhttp.internal.spdy.Http2.FLAG_ACK;
+import static com.squareup.okhttp.internal.spdy.Http2.FLAG_END_HEADERS;
+import static com.squareup.okhttp.internal.spdy.Http2.FLAG_END_STREAM;
+import static com.squareup.okhttp.internal.spdy.Http2.FLAG_NONE;
+import static com.squareup.okhttp.internal.spdy.Http2.FrameLogger.formatFlags;
+import static com.squareup.okhttp.internal.spdy.Http2.FrameLogger.formatHeader;
+import static com.squareup.okhttp.internal.spdy.Http2.TYPE_CONTINUATION;
+import static com.squareup.okhttp.internal.spdy.Http2.TYPE_DATA;
+import static com.squareup.okhttp.internal.spdy.Http2.TYPE_GOAWAY;
+import static com.squareup.okhttp.internal.spdy.Http2.TYPE_HEADERS;
+import static com.squareup.okhttp.internal.spdy.Http2.TYPE_PING;
+import static com.squareup.okhttp.internal.spdy.Http2.TYPE_PUSH_PROMISE;
+import static com.squareup.okhttp.internal.spdy.Http2.TYPE_SETTINGS;
 import static org.junit.Assert.assertEquals;
 
-public class Http20Draft16FrameLoggerTest {
+public class Http2FrameLoggerTest {
 
   /** Real stream traffic applied to the log format. */
   @Test public void exampleStream() {
diff --git a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/spdy/Http20Draft16Test.java b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/spdy/Http2Test.java
similarity index 84%
rename from okhttp-tests/src/test/java/com/squareup/okhttp/internal/spdy/Http20Draft16Test.java
rename to okhttp-tests/src/test/java/com/squareup/okhttp/internal/spdy/Http2Test.java
index acf3f1c2f0..331514d623 100644
--- a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/spdy/Http20Draft16Test.java
+++ b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/spdy/Http2Test.java
@@ -28,26 +28,26 @@
 import org.junit.Test;
 
 import static com.squareup.okhttp.TestUtil.headerEntries;
-import static com.squareup.okhttp.internal.spdy.Http20Draft16.FLAG_COMPRESSED;
-import static com.squareup.okhttp.internal.spdy.Http20Draft16.FLAG_END_HEADERS;
-import static com.squareup.okhttp.internal.spdy.Http20Draft16.FLAG_END_STREAM;
-import static com.squareup.okhttp.internal.spdy.Http20Draft16.FLAG_NONE;
-import static com.squareup.okhttp.internal.spdy.Http20Draft16.FLAG_PADDED;
-import static com.squareup.okhttp.internal.spdy.Http20Draft16.FLAG_PRIORITY;
+import static com.squareup.okhttp.internal.spdy.Http2.FLAG_COMPRESSED;
+import static com.squareup.okhttp.internal.spdy.Http2.FLAG_END_HEADERS;
+import static com.squareup.okhttp.internal.spdy.Http2.FLAG_END_STREAM;
+import static com.squareup.okhttp.internal.spdy.Http2.FLAG_NONE;
+import static com.squareup.okhttp.internal.spdy.Http2.FLAG_PADDED;
+import static com.squareup.okhttp.internal.spdy.Http2.FLAG_PRIORITY;
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertFalse;
 import static org.junit.Assert.assertTrue;
 import static org.junit.Assert.fail;
 
-public class Http20Draft16Test {
+public class Http2Test {
   final Buffer frame = new Buffer();
-  final FrameReader fr = new Http20Draft16.Reader(frame, 4096, false);
+  final FrameReader fr = new Http2.Reader(frame, 4096, false);
   final int expectedStreamId = 15;
 
   @Test public void unknownFrameTypeSkipped() throws IOException {
     writeMedium(frame, 4); // has a 4-byte field
     frame.writeByte(99); // type 99
-    frame.writeByte(Http20Draft16.FLAG_NONE);
+    frame.writeByte(Http2.FLAG_NONE);
     frame.writeInt(expectedStreamId);
     frame.writeInt(111111111); // custom data
 
@@ -59,7 +59,7 @@
 
     Buffer headerBytes = literalHeaders(sentHeaders);
     writeMedium(frame, (int) headerBytes.size());
-    frame.writeByte(Http20Draft16.TYPE_HEADERS);
+    frame.writeByte(Http2.TYPE_HEADERS);
     frame.writeByte(FLAG_END_HEADERS | FLAG_END_STREAM);
     frame.writeInt(expectedStreamId & 0x7fffffff);
     frame.writeAll(headerBytes);
@@ -85,7 +85,7 @@ public void headers(boolean outFinished, boolean inFinished, int streamId,
 
     Buffer headerBytes = literalHeaders(sentHeaders);
     writeMedium(frame, (int) (headerBytes.size() + 5));
-    frame.writeByte(Http20Draft16.TYPE_HEADERS);
+    frame.writeByte(Http2.TYPE_HEADERS);
     frame.writeByte(FLAG_END_HEADERS | FLAG_PRIORITY);
     frame.writeInt(expectedStreamId & 0x7fffffff);
     frame.writeInt(0); // Independent stream.
@@ -120,15 +120,15 @@ public void headers(boolean outFinished, boolean inFinished, int streamId,
     Buffer headerBlock = literalHeaders(sentHeaders);
 
     // Write the first headers frame.
-    writeMedium(frame, Http20Draft16.INITIAL_MAX_FRAME_SIZE);
-    frame.writeByte(Http20Draft16.TYPE_HEADERS);
-    frame.writeByte(Http20Draft16.FLAG_NONE);
+    writeMedium(frame, Http2.INITIAL_MAX_FRAME_SIZE);
+    frame.writeByte(Http2.TYPE_HEADERS);
+    frame.writeByte(Http2.FLAG_NONE);
     frame.writeInt(expectedStreamId & 0x7fffffff);
-    frame.write(headerBlock, Http20Draft16.INITIAL_MAX_FRAME_SIZE);
+    frame.write(headerBlock, Http2.INITIAL_MAX_FRAME_SIZE);
 
     // Write the continuation frame, specifying no more frames are expected.
     writeMedium(frame, (int) headerBlock.size());
-    frame.writeByte(Http20Draft16.TYPE_CONTINUATION);
+    frame.writeByte(Http2.TYPE_CONTINUATION);
     frame.writeByte(FLAG_END_HEADERS);
     frame.writeInt(expectedStreamId & 0x7fffffff);
     frame.writeAll(headerBlock);
@@ -162,8 +162,8 @@ public void headers(boolean outFinished, boolean inFinished, int streamId,
     // Write the push promise frame, specifying the associated stream ID.
     Buffer headerBytes = literalHeaders(pushPromise);
     writeMedium(frame, (int) (headerBytes.size() + 4));
-    frame.writeByte(Http20Draft16.TYPE_PUSH_PROMISE);
-    frame.writeByte(Http20Draft16.FLAG_END_PUSH_PROMISE);
+    frame.writeByte(Http2.TYPE_PUSH_PROMISE);
+    frame.writeByte(Http2.FLAG_END_PUSH_PROMISE);
     frame.writeInt(expectedStreamId & 0x7fffffff);
     frame.writeInt(expectedPromisedStreamId & 0x7fffffff);
     frame.writeAll(headerBytes);
@@ -189,16 +189,16 @@ public void pushPromise(int streamId, int promisedStreamId, List<Header> headerB
     Buffer headerBlock = literalHeaders(pushPromise);
 
     // Write the first headers frame.
-    writeMedium(frame, Http20Draft16.INITIAL_MAX_FRAME_SIZE);
-    frame.writeByte(Http20Draft16.TYPE_PUSH_PROMISE);
-    frame.writeByte(Http20Draft16.FLAG_NONE);
+    writeMedium(frame, Http2.INITIAL_MAX_FRAME_SIZE);
+    frame.writeByte(Http2.TYPE_PUSH_PROMISE);
+    frame.writeByte(Http2.FLAG_NONE);
     frame.writeInt(expectedStreamId & 0x7fffffff);
     frame.writeInt(expectedPromisedStreamId & 0x7fffffff);
-    frame.write(headerBlock, Http20Draft16.INITIAL_MAX_FRAME_SIZE - 4);
+    frame.write(headerBlock, Http2.INITIAL_MAX_FRAME_SIZE - 4);
 
     // Write the continuation frame, specifying no more frames are expected.
     writeMedium(frame, (int) headerBlock.size());
-    frame.writeByte(Http20Draft16.TYPE_CONTINUATION);
+    frame.writeByte(Http2.TYPE_CONTINUATION);
     frame.writeByte(FLAG_END_HEADERS);
     frame.writeInt(expectedStreamId & 0x7fffffff);
     frame.writeAll(headerBlock);
@@ -218,8 +218,8 @@ public void pushPromise(int streamId, int promisedStreamId, List<Header> headerB
 
   @Test public void readRstStreamFrame() throws IOException {
     writeMedium(frame, 4);
-    frame.writeByte(Http20Draft16.TYPE_RST_STREAM);
-    frame.writeByte(Http20Draft16.FLAG_NONE);
+    frame.writeByte(Http2.TYPE_RST_STREAM);
+    frame.writeByte(Http2.FLAG_NONE);
     frame.writeInt(expectedStreamId & 0x7fffffff);
     frame.writeInt(ErrorCode.COMPRESSION_ERROR.httpCode);
 
@@ -235,8 +235,8 @@ public void pushPromise(int streamId, int promisedStreamId, List<Header> headerB
     final int reducedTableSizeBytes = 16;
 
     writeMedium(frame, 12); // 2 settings * 6 bytes (2 for the code and 4 for the value).
-    frame.writeByte(Http20Draft16.TYPE_SETTINGS);
-    frame.writeByte(Http20Draft16.FLAG_NONE);
+    frame.writeByte(Http2.TYPE_SETTINGS);
+    frame.writeByte(Http2.FLAG_NONE);
     frame.writeInt(0); // Settings are always on the connection stream 0.
     frame.writeShort(1); // SETTINGS_HEADER_TABLE_SIZE
     frame.writeInt(reducedTableSizeBytes);
@@ -254,8 +254,8 @@ public void pushPromise(int streamId, int promisedStreamId, List<Header> headerB
 
   @Test public void readSettingsFrameInvalidPushValue() throws IOException {
     writeMedium(frame, 6); // 2 for the code and 4 for the value
-    frame.writeByte(Http20Draft16.TYPE_SETTINGS);
-    frame.writeByte(Http20Draft16.FLAG_NONE);
+    frame.writeByte(Http2.TYPE_SETTINGS);
+    frame.writeByte(Http2.FLAG_NONE);
     frame.writeInt(0); // Settings are always on the connection stream 0.
     frame.writeShort(2);
     frame.writeInt(2);
@@ -270,8 +270,8 @@ public void pushPromise(int streamId, int promisedStreamId, List<Header> headerB
 
   @Test public void readSettingsFrameInvalidSettingId() throws IOException {
     writeMedium(frame, 6); // 2 for the code and 4 for the value
-    frame.writeByte(Http20Draft16.TYPE_SETTINGS);
-    frame.writeByte(Http20Draft16.FLAG_NONE);
+    frame.writeByte(Http2.TYPE_SETTINGS);
+    frame.writeByte(Http2.FLAG_NONE);
     frame.writeInt(0); // Settings are always on the connection stream 0.
     frame.writeShort(7); // old number for SETTINGS_INITIAL_WINDOW_SIZE
     frame.writeInt(1);
@@ -286,8 +286,8 @@ public void pushPromise(int streamId, int promisedStreamId, List<Header> headerB
 
   @Test public void readSettingsFrameNegativeWindowSize() throws IOException {
     writeMedium(frame, 6); // 2 for the code and 4 for the value
-    frame.writeByte(Http20Draft16.TYPE_SETTINGS);
-    frame.writeByte(Http20Draft16.FLAG_NONE);
+    frame.writeByte(Http2.TYPE_SETTINGS);
+    frame.writeByte(Http2.FLAG_NONE);
     frame.writeInt(0); // Settings are always on the connection stream 0.
     frame.writeShort(4); // SETTINGS_INITIAL_WINDOW_SIZE
     frame.writeInt(Integer.MIN_VALUE);
@@ -302,8 +302,8 @@ public void pushPromise(int streamId, int promisedStreamId, List<Header> headerB
 
   @Test public void readSettingsFrameNegativeFrameLength() throws IOException {
     writeMedium(frame, 6); // 2 for the code and 4 for the value
-    frame.writeByte(Http20Draft16.TYPE_SETTINGS);
-    frame.writeByte(Http20Draft16.FLAG_NONE);
+    frame.writeByte(Http2.TYPE_SETTINGS);
+    frame.writeByte(Http2.FLAG_NONE);
     frame.writeInt(0); // Settings are always on the connection stream 0.
     frame.writeShort(5); // SETTINGS_MAX_FRAME_SIZE
     frame.writeInt(Integer.MIN_VALUE);
@@ -318,8 +318,8 @@ public void pushPromise(int streamId, int promisedStreamId, List<Header> headerB
 
   @Test public void readSettingsFrameTooShortFrameLength() throws IOException {
     writeMedium(frame, 6); // 2 for the code and 4 for the value
-    frame.writeByte(Http20Draft16.TYPE_SETTINGS);
-    frame.writeByte(Http20Draft16.FLAG_NONE);
+    frame.writeByte(Http2.TYPE_SETTINGS);
+    frame.writeByte(Http2.FLAG_NONE);
     frame.writeInt(0); // Settings are always on the connection stream 0.
     frame.writeShort(5); // SETTINGS_MAX_FRAME_SIZE
     frame.writeInt((int) Math.pow(2, 14) - 1);
@@ -334,8 +334,8 @@ public void pushPromise(int streamId, int promisedStreamId, List<Header> headerB
 
   @Test public void readSettingsFrameTooLongFrameLength() throws IOException {
     writeMedium(frame, 6); // 2 for the code and 4 for the value
-    frame.writeByte(Http20Draft16.TYPE_SETTINGS);
-    frame.writeByte(Http20Draft16.FLAG_NONE);
+    frame.writeByte(Http2.TYPE_SETTINGS);
+    frame.writeByte(Http2.FLAG_NONE);
     frame.writeInt(0); // Settings are always on the connection stream 0.
     frame.writeShort(5); // SETTINGS_MAX_FRAME_SIZE
     frame.writeInt((int) Math.pow(2, 24));
@@ -353,8 +353,8 @@ public void pushPromise(int streamId, int promisedStreamId, List<Header> headerB
     final int expectedPayload2 = 8;
 
     writeMedium(frame, 8); // length
-    frame.writeByte(Http20Draft16.TYPE_PING);
-    frame.writeByte(Http20Draft16.FLAG_ACK);
+    frame.writeByte(Http2.TYPE_PING);
+    frame.writeByte(Http2.FLAG_ACK);
     frame.writeInt(0); // connection-level
     frame.writeInt(expectedPayload1);
     frame.writeInt(expectedPayload2);
@@ -372,12 +372,12 @@ public void pushPromise(int streamId, int promisedStreamId, List<Header> headerB
   }
 
   @Test public void maxLengthDataFrame() throws IOException {
-    final byte[] expectedData = new byte[Http20Draft16.INITIAL_MAX_FRAME_SIZE];
+    final byte[] expectedData = new byte[Http2.INITIAL_MAX_FRAME_SIZE];
     Arrays.fill(expectedData, (byte) 2);
 
     writeMedium(frame, expectedData.length);
-    frame.writeByte(Http20Draft16.TYPE_DATA);
-    frame.writeByte(Http20Draft16.FLAG_NONE);
+    frame.writeByte(Http2.TYPE_DATA);
+    frame.writeByte(Http2.FLAG_NONE);
     frame.writeInt(expectedStreamId & 0x7fffffff);
     frame.write(expectedData);
 
@@ -389,7 +389,7 @@ public void pushPromise(int streamId, int promisedStreamId, List<Header> headerB
           int length) throws IOException {
         assertFalse(inFinished);
         assertEquals(expectedStreamId, streamId);
-        assertEquals(Http20Draft16.INITIAL_MAX_FRAME_SIZE, length);
+        assertEquals(Http2.INITIAL_MAX_FRAME_SIZE, length);
         ByteString data = source.readByteString(length);
         for (byte b : data.toByteArray()) {
           assertEquals(2, b);
@@ -400,13 +400,13 @@ public void pushPromise(int streamId, int promisedStreamId, List<Header> headerB
 
   /** We do not send SETTINGS_COMPRESS_DATA = 1, nor want to. Let's make sure we error. */
   @Test public void compressedDataFrameWhenSettingDisabled() throws IOException {
-    byte[] expectedData = new byte[Http20Draft16.INITIAL_MAX_FRAME_SIZE];
+    byte[] expectedData = new byte[Http2.INITIAL_MAX_FRAME_SIZE];
     Arrays.fill(expectedData, (byte) 2);
     Buffer zipped = gzip(expectedData);
     int zippedSize = (int) zipped.size();
 
     writeMedium(frame, zippedSize);
-    frame.writeByte(Http20Draft16.TYPE_DATA);
+    frame.writeByte(Http2.TYPE_DATA);
     frame.writeByte(FLAG_COMPRESSED);
     frame.writeInt(expectedStreamId & 0x7fffffff);
     zipped.readAll(frame);
@@ -430,7 +430,7 @@ public void pushPromise(int streamId, int promisedStreamId, List<Header> headerB
     Arrays.fill(padding, (byte) 0);
 
     writeMedium(frame, dataLength + paddingLength + 1);
-    frame.writeByte(Http20Draft16.TYPE_DATA);
+    frame.writeByte(Http2.TYPE_DATA);
     frame.writeByte(FLAG_PADDED);
     frame.writeInt(expectedStreamId & 0x7fffffff);
     frame.writeByte(paddingLength);
@@ -447,7 +447,7 @@ public void pushPromise(int streamId, int promisedStreamId, List<Header> headerB
     Arrays.fill(expectedData, (byte) 2);
 
     writeMedium(frame, dataLength + 1);
-    frame.writeByte(Http20Draft16.TYPE_DATA);
+    frame.writeByte(Http2.TYPE_DATA);
     frame.writeByte(FLAG_PADDED);
     frame.writeInt(expectedStreamId & 0x7fffffff);
     frame.writeByte(0);
@@ -463,7 +463,7 @@ public void pushPromise(int streamId, int promisedStreamId, List<Header> headerB
 
     Buffer headerBlock = literalHeaders(headerEntries("foo", "barrr", "baz", "qux"));
     writeMedium(frame, (int) headerBlock.size() + paddingLength + 1);
-    frame.writeByte(Http20Draft16.TYPE_HEADERS);
+    frame.writeByte(Http2.TYPE_HEADERS);
     frame.writeByte(FLAG_END_HEADERS | FLAG_PADDED);
     frame.writeInt(expectedStreamId & 0x7fffffff);
     frame.writeByte(paddingLength);
@@ -477,7 +477,7 @@ public void pushPromise(int streamId, int promisedStreamId, List<Header> headerB
   @Test public void readPaddedHeadersFrameZeroPadding() throws IOException {
     Buffer headerBlock = literalHeaders(headerEntries("foo", "barrr", "baz", "qux"));
     writeMedium(frame, (int) headerBlock.size() + 1);
-    frame.writeByte(Http20Draft16.TYPE_HEADERS);
+    frame.writeByte(Http2.TYPE_HEADERS);
     frame.writeByte(FLAG_END_HEADERS | FLAG_PADDED);
     frame.writeInt(expectedStreamId & 0x7fffffff);
     frame.writeByte(0);
@@ -497,7 +497,7 @@ public void pushPromise(int streamId, int promisedStreamId, List<Header> headerB
 
     // Write the first headers frame.
     writeMedium(frame, (int) (headerBlock.size() / 2) + paddingLength + 1);
-    frame.writeByte(Http20Draft16.TYPE_HEADERS);
+    frame.writeByte(Http2.TYPE_HEADERS);
     frame.writeByte(FLAG_PADDED);
     frame.writeInt(expectedStreamId & 0x7fffffff);
     frame.writeByte(paddingLength);
@@ -506,7 +506,7 @@ public void pushPromise(int streamId, int promisedStreamId, List<Header> headerB
 
     // Write the continuation frame, specifying no more frames are expected.
     writeMedium(frame, (int) headerBlock.size());
-    frame.writeByte(Http20Draft16.TYPE_CONTINUATION);
+    frame.writeByte(Http2.TYPE_CONTINUATION);
     frame.writeByte(FLAG_END_HEADERS);
     frame.writeInt(expectedStreamId & 0x7fffffff);
     frame.writeAll(headerBlock);
@@ -528,8 +528,8 @@ public void pushPromise(int streamId, int promisedStreamId, List<Header> headerB
     final long expectedWindowSizeIncrement = 0x7fffffff;
 
     writeMedium(frame, 4); // length
-    frame.writeByte(Http20Draft16.TYPE_WINDOW_UPDATE);
-    frame.writeByte(Http20Draft16.FLAG_NONE);
+    frame.writeByte(Http2.TYPE_WINDOW_UPDATE);
+    frame.writeByte(Http2.FLAG_NONE);
     frame.writeInt(expectedStreamId);
     frame.writeInt((int) expectedWindowSizeIncrement);
 
@@ -565,8 +565,8 @@ public void pushPromise(int streamId, int promisedStreamId, List<Header> headerB
     final ErrorCode expectedError = ErrorCode.PROTOCOL_ERROR;
 
     writeMedium(frame, 8); // Without debug data there's only 2 32-bit fields.
-    frame.writeByte(Http20Draft16.TYPE_GOAWAY);
-    frame.writeByte(Http20Draft16.FLAG_NONE);
+    frame.writeByte(Http2.TYPE_GOAWAY);
+    frame.writeByte(Http2.FLAG_NONE);
     frame.writeInt(0); // connection-scope
     frame.writeInt(expectedStreamId); // last good stream.
     frame.writeInt(expectedError.httpCode);
@@ -590,8 +590,8 @@ public void pushPromise(int streamId, int promisedStreamId, List<Header> headerB
 
     // Compose the expected GOAWAY frame without debug data.
     writeMedium(frame, 8 + expectedData.size());
-    frame.writeByte(Http20Draft16.TYPE_GOAWAY);
-    frame.writeByte(Http20Draft16.FLAG_NONE);
+    frame.writeByte(Http2.TYPE_GOAWAY);
+    frame.writeByte(Http2.FLAG_NONE);
     frame.writeInt(0); // connection-scope
     frame.writeInt(0); // never read any stream!
     frame.writeInt(expectedError.httpCode);
@@ -611,10 +611,10 @@ public void pushPromise(int streamId, int promisedStreamId, List<Header> headerB
   }
 
   @Test public void frameSizeError() throws IOException {
-    Http20Draft16.Writer writer = new Http20Draft16.Writer(new Buffer(), true);
+    Http2.Writer writer = new Http2.Writer(new Buffer(), true);
 
     try {
-      writer.frameHeader(0, 16777216, Http20Draft16.TYPE_DATA, FLAG_NONE);
+      writer.frameHeader(0, 16777216, Http2.TYPE_DATA, FLAG_NONE);
       fail();
     } catch (IllegalArgumentException e) {
       // TODO: real max is based on settings between 16384 and 16777215
@@ -625,21 +625,21 @@ public void pushPromise(int streamId, int promisedStreamId, List<Header> headerB
   @Test public void ackSettingsAppliesMaxFrameSize() throws IOException {
     int newMaxFrameSize = 16777215;
 
-    Http20Draft16.Writer writer = new Http20Draft16.Writer(new Buffer(), true);
+    Http2.Writer writer = new Http2.Writer(new Buffer(), true);
 
     writer.ackSettings(new Settings().set(Settings.MAX_FRAME_SIZE, 0, newMaxFrameSize));
 
     assertEquals(newMaxFrameSize, writer.maxDataLength());
-    writer.frameHeader(0, newMaxFrameSize, Http20Draft16.TYPE_DATA, FLAG_NONE);
+    writer.frameHeader(0, newMaxFrameSize, Http2.TYPE_DATA, FLAG_NONE);
   }
 
   @Test public void streamIdHasReservedBit() throws IOException {
-    Http20Draft16.Writer writer = new Http20Draft16.Writer(new Buffer(), true);
+    Http2.Writer writer = new Http2.Writer(new Buffer(), true);
 
     try {
       int streamId = 3;
       streamId |= 1L << 31; // set reserved bit
-      writer.frameHeader(streamId, Http20Draft16.INITIAL_MAX_FRAME_SIZE, Http20Draft16.TYPE_DATA, FLAG_NONE);
+      writer.frameHeader(streamId, Http2.INITIAL_MAX_FRAME_SIZE, Http2.TYPE_DATA, FLAG_NONE);
       fail();
     } catch (IllegalArgumentException e) {
       assertEquals("reserved bit set: -2147483645", e.getMessage());
@@ -648,45 +648,45 @@ public void pushPromise(int streamId, int promisedStreamId, List<Header> headerB
 
   private Buffer literalHeaders(List<Header> sentHeaders) throws IOException {
     Buffer out = new Buffer();
-    new HpackDraft10.Writer(out).writeHeaders(sentHeaders);
+    new Hpack.Writer(out).writeHeaders(sentHeaders);
     return out;
   }
 
   private Buffer sendHeaderFrames(boolean outFinished, List<Header> headers) throws IOException {
     Buffer out = new Buffer();
-    new Http20Draft16.Writer(out, true).headers(outFinished, expectedStreamId, headers);
+    new Http2.Writer(out, true).headers(outFinished, expectedStreamId, headers);
     return out;
   }
 
   private Buffer sendPushPromiseFrames(int streamId, List<Header> headers) throws IOException {
     Buffer out = new Buffer();
-    new Http20Draft16.Writer(out, true).pushPromise(expectedStreamId, streamId, headers);
+    new Http2.Writer(out, true).pushPromise(expectedStreamId, streamId, headers);
     return out;
   }
 
   private Buffer sendPingFrame(boolean ack, int payload1, int payload2) throws IOException {
     Buffer out = new Buffer();
-    new Http20Draft16.Writer(out, true).ping(ack, payload1, payload2);
+    new Http2.Writer(out, true).ping(ack, payload1, payload2);
     return out;
   }
 
   private Buffer sendGoAway(int lastGoodStreamId, ErrorCode errorCode, byte[] debugData)
       throws IOException {
     Buffer out = new Buffer();
-    new Http20Draft16.Writer(out, true).goAway(lastGoodStreamId, errorCode, debugData);
+    new Http2.Writer(out, true).goAway(lastGoodStreamId, errorCode, debugData);
     return out;
   }
 
   private Buffer sendDataFrame(Buffer data) throws IOException {
     Buffer out = new Buffer();
-    new Http20Draft16.Writer(out, true).dataFrame(expectedStreamId, FLAG_NONE, data,
+    new Http2.Writer(out, true).dataFrame(expectedStreamId, FLAG_NONE, data,
         (int) data.size());
     return out;
   }
 
   private Buffer windowUpdate(long windowSizeIncrement) throws IOException {
     Buffer out = new Buffer();
-    new Http20Draft16.Writer(out, true).windowUpdate(expectedStreamId, windowSizeIncrement);
+    new Http2.Writer(out, true).windowUpdate(expectedStreamId, windowSizeIncrement);
     return out;
   }
 
diff --git a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/spdy/MockSpdyPeer.java b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/spdy/MockSpdyPeer.java
index fd6da2b0c9..bc5499cd47 100644
--- a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/spdy/MockSpdyPeer.java
+++ b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/spdy/MockSpdyPeer.java
@@ -299,7 +299,7 @@ public InFrame(int sequence, FrameReader reader) {
 
     @Override
     public void pushPromise(int streamId, int associatedStreamId, List<Header> headerBlock) {
-      this.type = Http20Draft16.TYPE_PUSH_PROMISE;
+      this.type = Http2.TYPE_PUSH_PROMISE;
       this.streamId = streamId;
       this.associatedStreamId = associatedStreamId;
       this.headerBlock = headerBlock;
diff --git a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/spdy/Spdy3ConnectionTest.java b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/spdy/Spdy3ConnectionTest.java
index 110412ec2e..eb53e35ee6 100644
--- a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/spdy/Spdy3ConnectionTest.java
+++ b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/spdy/Spdy3ConnectionTest.java
@@ -21,8 +21,10 @@
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.List;
+import java.util.concurrent.CountDownLatch;
 import java.util.concurrent.TimeUnit;
 import java.util.concurrent.atomic.AtomicInteger;
+import okio.AsyncTimeout;
 import okio.Buffer;
 import okio.BufferedSink;
 import okio.ByteString;
@@ -884,6 +886,7 @@
     } catch (InterruptedIOException expected) {
     }
     long elapsedNanos = System.nanoTime() - startNanos;
+    awaitWatchdogIdle();
     assertEquals(500d, TimeUnit.NANOSECONDS.toMillis(elapsedNanos), 200d /* 200ms delta */);
     assertEquals(0, connection.openStreamCount());
 
@@ -911,6 +914,7 @@
     } catch (InterruptedIOException expected) {
     }
     long elapsedNanos = System.nanoTime() - startNanos;
+    awaitWatchdogIdle();
     assertEquals(500d, TimeUnit.NANOSECONDS.toMillis(elapsedNanos), 200d /* 200ms delta */);
     assertEquals(0, connection.openStreamCount());
 
@@ -941,12 +945,14 @@
     sink.write(new Buffer().writeUtf8("abcde"), 5);
     stream.writeTimeout().timeout(500, TimeUnit.MILLISECONDS);
     long startNanos = System.nanoTime();
+    sink.write(new Buffer().writeUtf8("f"), 1);
     try {
-      sink.write(new Buffer().writeUtf8("f"), 1); // This will time out waiting on the write window.
+      sink.flush(); // This will time out waiting on the write window.
       fail();
     } catch (InterruptedIOException expected) {
     }
     long elapsedNanos = System.nanoTime() - startNanos;
+    awaitWatchdogIdle();
     assertEquals(500d, TimeUnit.NANOSECONDS.toMillis(elapsedNanos), 200d /* 200ms delta */);
     assertEquals(0, connection.openStreamCount());
 
@@ -957,6 +963,31 @@
     assertEquals(TYPE_RST_STREAM, peer.takeFrame().type);
   }
 
+  @Test public void outgoingWritesAreBatched() throws Exception {
+    // write the mocking script
+    peer.acceptFrame(); // SYN_STREAM
+    peer.sendFrame().synReply(false, 1, headerEntries("a", "android"));
+    peer.acceptFrame(); // DATA
+    peer.play();
+
+    // play it back
+    SpdyConnection connection = connection(peer, SPDY3);
+    SpdyStream stream = connection.newStream(headerEntries("b", "banana"), true, true);
+
+    // two outgoing writes
+    Sink sink = stream.getSink();
+    sink.write(new Buffer().writeUtf8("abcde"), 5);
+    sink.write(new Buffer().writeUtf8("fghij"), 5);
+    sink.close();
+
+    // verify the peer received one incoming frame
+    assertEquals(TYPE_HEADERS, peer.takeFrame().type);
+    MockSpdyPeer.InFrame data = peer.takeFrame();
+    assertEquals(TYPE_DATA, data.type);
+    assertTrue(Arrays.equals("abcdefghij".getBytes("UTF-8"), data.data));
+    assertTrue(data.inFinished);
+  }
+
   @Test public void headers() throws Exception {
     // write the mocking script
     peer.acceptFrame(); // SYN_STREAM
@@ -1275,6 +1306,23 @@ private void interruptAfterDelay(final long delayMillis) {
     }.start();
   }
 
+  /**
+   * Returns true when all work currently in progress by the watchdog have completed. This method
+   * creates more work for the watchdog and waits for that work to be executed. When it is, we know
+   * work that preceded this call is complete.
+   */
+  private void awaitWatchdogIdle() throws InterruptedException {
+    final CountDownLatch latch = new CountDownLatch(1);
+    AsyncTimeout watchdogJob = new AsyncTimeout() {
+      @Override protected void timedOut() {
+        latch.countDown();
+      }
+    };
+    watchdogJob.deadlineNanoTime(System.nanoTime()); // Due immediately!
+    watchdogJob.enter();
+    latch.await();
+  }
+
   static int roundUp(int num, int divisor) {
     return (num + divisor - 1) / divisor;
   }
diff --git a/okhttp-urlconnection/pom.xml b/okhttp-urlconnection/pom.xml
index 7c5a2bc9d7..66e6e06e29 100644
--- a/okhttp-urlconnection/pom.xml
+++ b/okhttp-urlconnection/pom.xml
@@ -6,7 +6,7 @@
   <parent>
     <groupId>com.squareup.okhttp</groupId>
     <artifactId>parent</artifactId>
-    <version>2.3.0-SNAPSHOT</version>
+    <version>2.4.0-SNAPSHOT</version>
   </parent>
 
   <artifactId>okhttp-urlconnection</artifactId>
diff --git a/okhttp-ws-tests/pom.xml b/okhttp-ws-tests/pom.xml
new file mode 100644
index 0000000000..424f4a56e1
--- /dev/null
+++ b/okhttp-ws-tests/pom.xml
@@ -0,0 +1,47 @@
+<?xml version="1.0" encoding="UTF-8"?>
+
+<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
+  <modelVersion>4.0.0</modelVersion>
+
+  <parent>
+    <groupId>com.squareup.okhttp</groupId>
+    <artifactId>parent</artifactId>
+    <version>2.4.0-SNAPSHOT</version>
+  </parent>
+
+  <artifactId>okhttp-ws-tests</artifactId>
+  <name>OkHttp Web Socket Tests</name>
+
+  <dependencies>
+    <dependency>
+      <groupId>com.squareup.okhttp</groupId>
+      <artifactId>okhttp-ws</artifactId>
+      <version>${project.version}</version>
+    </dependency>
+
+    <dependency>
+      <groupId>junit</groupId>
+      <artifactId>junit</artifactId>
+      <scope>test</scope>
+    </dependency>
+    <dependency>
+      <groupId>com.squareup.okhttp</groupId>
+      <artifactId>mockwebserver</artifactId>
+      <version>${project.version}</version>
+      <scope>test</scope>
+    </dependency>
+  </dependencies>
+
+  <build>
+    <plugins>
+      <!-- Do not deploy this as an artifact to Maven central. -->
+      <plugin>
+        <groupId>org.apache.maven.plugins</groupId>
+        <artifactId>maven-deploy-plugin</artifactId>
+        <configuration>
+          <skip>true</skip>
+        </configuration>
+      </plugin>
+    </plugins>
+  </build>
+</project>
diff --git a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/ws/RealWebSocketTest.java b/okhttp-ws-tests/src/test/java/com/squareup/okhttp/internal/ws/RealWebSocketTest.java
similarity index 83%
rename from okhttp-tests/src/test/java/com/squareup/okhttp/internal/ws/RealWebSocketTest.java
rename to okhttp-ws-tests/src/test/java/com/squareup/okhttp/internal/ws/RealWebSocketTest.java
index 7e7f05a2c8..857f00c2fb 100644
--- a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/ws/RealWebSocketTest.java
+++ b/okhttp-ws-tests/src/test/java/com/squareup/okhttp/internal/ws/RealWebSocketTest.java
@@ -15,9 +15,11 @@
  */
 package com.squareup.okhttp.internal.ws;
 
+import com.squareup.okhttp.ws.WebSocketRecorder;
 import java.io.IOException;
 import java.net.ProtocolException;
 import java.util.Random;
+import java.util.concurrent.Executor;
 import okio.Buffer;
 import okio.BufferedSink;
 import okio.ByteString;
@@ -25,19 +27,20 @@
 import org.junit.Before;
 import org.junit.Test;
 
-import static com.squareup.okhttp.internal.ws.WebSocket.PayloadType.BINARY;
-import static com.squareup.okhttp.internal.ws.WebSocket.PayloadType.TEXT;
+import static com.squareup.okhttp.ws.WebSocket.PayloadType.BINARY;
+import static com.squareup.okhttp.ws.WebSocket.PayloadType.TEXT;
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertFalse;
 import static org.junit.Assert.assertTrue;
 import static org.junit.Assert.fail;
 
 public final class RealWebSocketTest {
-  // NOTE: Types are named 'client' and 'server' for cognitive simplicity. This differentiation has
+  // NOTE: Fields are named 'client' and 'server' for cognitive simplicity. This differentiation has
   // zero effect on the behavior of the WebSocket API which is why tests are only written once
   // from the perspective of a single peer.
 
   private RealWebSocket client;
+  private boolean clientConnectionCloseThrows;
   private boolean clientConnectionClosed;
   private final Buffer client2Server = new Buffer();
   private final WebSocketRecorder clientListener = new WebSocketRecorder();
@@ -48,15 +51,25 @@
 
   @Before public void setUp() {
     Random random = new Random(0);
+    String url = "http://example.com/websocket";
 
-    client = new RealWebSocket(true, server2client, client2Server, random, clientListener,
-        "http://example.com/websocket") {
+    Executor synchronousExecutor = new Executor() {
+      @Override public void execute(Runnable command) {
+        command.run();
+      }
+    };
+
+    client = new RealWebSocket(true, server2client, client2Server, random, synchronousExecutor,
+        clientListener, url) {
       @Override protected void closeConnection() throws IOException {
         clientConnectionClosed = true;
+        if (clientConnectionCloseThrows) {
+          throw new IOException("Oops!");
+        }
       }
     };
-    server = new RealWebSocket(false, client2Server, server2client, random, serverListener,
-        "http://example.com/websocket") {
+    server = new RealWebSocket(false, client2Server, server2client, random, synchronousExecutor,
+        serverListener, url) {
       @Override protected void closeConnection() throws IOException {
       }
     };
@@ -96,16 +109,14 @@
     sink.close();
     server.readMessage();
     serverListener.assertTextMessage("Hello!");
-    Thread.sleep(1000); // Wait for pong to be written.
     client.readMessage();
     clientListener.assertPong(new Buffer().writeUtf8("Pong?"));
   }
 
   @Test public void pingWritesPong() throws IOException, InterruptedException {
     client.sendPing(new Buffer().writeUtf8("Hello!"));
-    server.readMessage(); // Read the ping, enqueue the pong.
-    Thread.sleep(1000); // Wait for pong to be written.
-    client.readMessage();
+    server.readMessage(); // Read the ping, write the pong.
+    client.readMessage(); // Read the pong.
     clientListener.assertPong(new Buffer().writeUtf8("Hello!"));
   }
 
@@ -130,25 +141,25 @@
       client.sendPing(new Buffer().writeUtf8("Pong?"));
       fail();
     } catch (IllegalStateException e) {
-      assertEquals("Closed", e.getMessage());
+      assertEquals("closed", e.getMessage());
     }
     try {
       client.close(1000, "Hello!");
       fail();
     } catch (IllegalStateException e) {
-      assertEquals("Closed", e.getMessage());
+      assertEquals("closed", e.getMessage());
     }
     try {
       client.sendMessage(TEXT, new Buffer().writeUtf8("Hello!"));
       fail();
     } catch (IllegalStateException e) {
-      assertEquals("Closed", e.getMessage());
+      assertEquals("closed", e.getMessage());
     }
     try {
       client.newMessageSink(TEXT);
       fail();
     } catch (IllegalStateException e) {
-      assertEquals("Closed", e.getMessage());
+      assertEquals("closed", e.getMessage());
     }
   }
 
@@ -161,19 +172,19 @@
       client.sendPing(new Buffer().writeUtf8("Pong?"));
       fail();
     } catch (IOException e) {
-      assertEquals("Closed", e.getMessage());
+      assertEquals("closed", e.getMessage());
     }
     try {
       client.sendMessage(TEXT, new Buffer().writeUtf8("Hi!"));
       fail();
     } catch (IOException e) {
-      assertEquals("Closed", e.getMessage());
+      assertEquals("closed", e.getMessage());
     }
     try {
       client.close(1000, "Bye!");
       fail();
     } catch (IOException e) {
-      assertEquals("Closed", e.getMessage());
+      assertEquals("closed", e.getMessage());
     }
   }
 
@@ -190,20 +201,20 @@
       sink.writeUtf8("lo!").emit(); // No writing to the underlying sink.
       fail();
     } catch (IOException e) {
-      assertEquals("Closed", e.getMessage());
+      assertEquals("closed", e.getMessage());
       sink.buffer().clear();
     }
     try {
       sink.flush(); // No flushing.
       fail();
     } catch (IOException e) {
-      assertEquals("Closed", e.getMessage());
+      assertEquals("closed", e.getMessage());
     }
     try {
       sink.close(); // No closing because this requires writing a frame.
       fail();
     } catch (IOException e) {
-      assertEquals("Closed", e.getMessage());
+      assertEquals("closed", e.getMessage());
     }
   }
 
@@ -277,4 +288,16 @@
     server.readMessage();
     serverListener.assertClose(1000, "Hello!");
   }
+
+  @Test public void peerConnectionCloseThrowingDoesNotPropagate() throws IOException {
+    clientConnectionCloseThrows = true;
+
+    server.close(1000, "Bye!");
+    client.readMessage();
+    clientListener.assertClose(1000, "Bye!");
+    assertTrue(clientConnectionClosed);
+
+    server.readMessage();
+    serverListener.assertClose(1000, "Bye!");
+  }
 }
diff --git a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/ws/WebSocketReaderTest.java b/okhttp-ws-tests/src/test/java/com/squareup/okhttp/internal/ws/WebSocketReaderTest.java
similarity index 91%
rename from okhttp-tests/src/test/java/com/squareup/okhttp/internal/ws/WebSocketReaderTest.java
rename to okhttp-ws-tests/src/test/java/com/squareup/okhttp/internal/ws/WebSocketReaderTest.java
index 2f9dda8bee..1674511a43 100644
--- a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/ws/WebSocketReaderTest.java
+++ b/okhttp-ws-tests/src/test/java/com/squareup/okhttp/internal/ws/WebSocketReaderTest.java
@@ -15,6 +15,7 @@
  */
 package com.squareup.okhttp.internal.ws;
 
+import com.squareup.okhttp.ws.WebSocketRecorder;
 import java.io.EOFException;
 import java.io.IOException;
 import java.net.ProtocolException;
@@ -26,13 +27,13 @@
 import org.junit.After;
 import org.junit.Test;
 
-import static com.squareup.okhttp.internal.ws.WebSocket.PayloadType;
-import static com.squareup.okhttp.internal.ws.WebSocketRecorder.MessageDelegate;
+import static com.squareup.okhttp.ws.WebSocket.PayloadType;
+import static com.squareup.okhttp.ws.WebSocketRecorder.MessageDelegate;
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertNotNull;
 import static org.junit.Assert.fail;
 
-public class WebSocketReaderTest {
+public final class WebSocketReaderTest {
   private final Buffer data = new Buffer();
   private final WebSocketRecorder callback = new WebSocketRecorder();
   private final Random random = new Random(0);
@@ -123,6 +124,28 @@
     callback.assertTextMessage("Hello");
   }
 
+  @Test public void clientFramePayloadShort() throws IOException {
+    data.write(ByteString.decodeHex("817E000548656c6c6f")); // Hello
+    clientReader.processNextFrame();
+    callback.assertTextMessage("Hello");
+  }
+
+  @Test public void clientFramePayloadLong() throws IOException {
+    data.write(ByteString.decodeHex("817f000000000000000548656c6c6f")); // Hello
+    clientReader.processNextFrame();
+    callback.assertTextMessage("Hello");
+  }
+
+  @Test public void clientFramePayloadTooLongThrows() throws IOException {
+    data.write(ByteString.decodeHex("817f8000000000000000"));
+    try {
+      clientReader.processNextFrame();
+      fail();
+    } catch (ProtocolException e) {
+      assertEquals("Frame length 0x8000000000000000 > 0x7FFFFFFFFFFFFFFF", e.getMessage());
+    }
+  }
+
   @Test public void serverHelloTwoChunks() throws IOException {
     data.write(ByteString.decodeHex("818537fa213d7f9f4d")); // Hel
 
diff --git a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/ws/WebSocketWriterTest.java b/okhttp-ws-tests/src/test/java/com/squareup/okhttp/internal/ws/WebSocketWriterTest.java
similarity index 97%
rename from okhttp-tests/src/test/java/com/squareup/okhttp/internal/ws/WebSocketWriterTest.java
rename to okhttp-ws-tests/src/test/java/com/squareup/okhttp/internal/ws/WebSocketWriterTest.java
index 141d9ca4a3..d31687bb25 100644
--- a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/ws/WebSocketWriterTest.java
+++ b/okhttp-ws-tests/src/test/java/com/squareup/okhttp/internal/ws/WebSocketWriterTest.java
@@ -25,13 +25,13 @@
 import org.junit.After;
 import org.junit.Test;
 
-import static com.squareup.okhttp.internal.ws.WebSocket.PayloadType.BINARY;
-import static com.squareup.okhttp.internal.ws.WebSocket.PayloadType.TEXT;
+import static com.squareup.okhttp.ws.WebSocket.PayloadType.BINARY;
+import static com.squareup.okhttp.ws.WebSocket.PayloadType.TEXT;
 import static com.squareup.okhttp.internal.ws.WebSocketProtocol.toggleMask;
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.fail;
 
-public class WebSocketWriterTest {
+public final class WebSocketWriterTest {
   private final Buffer data = new Buffer();
   private final Random random = new Random(0);
 
@@ -100,9 +100,9 @@
   }
 
   @Test public void serverSendBinaryShort() throws IOException {
-    byte[] payload = binaryData(1000);
+    byte[] payload = binaryData(0xffff);
     serverWriter.sendMessage(BINARY, new Buffer().write(payload));
-    assertData("827e03e8");
+    assertData("827effff");
     assertData(payload);
   }
 
diff --git a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/ws/WebSocketCallTest.java b/okhttp-ws-tests/src/test/java/com/squareup/okhttp/ws/WebSocketCallTest.java
similarity index 91%
rename from okhttp-tests/src/test/java/com/squareup/okhttp/internal/ws/WebSocketCallTest.java
rename to okhttp-ws-tests/src/test/java/com/squareup/okhttp/ws/WebSocketCallTest.java
index 705b0357f2..63d21cb73f 100644
--- a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/ws/WebSocketCallTest.java
+++ b/okhttp-ws-tests/src/test/java/com/squareup/okhttp/ws/WebSocketCallTest.java
@@ -13,10 +13,9 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.squareup.okhttp.internal.ws;
+package com.squareup.okhttp.ws;
 
 import com.squareup.okhttp.OkHttpClient;
-import com.squareup.okhttp.RecordedResponse;
 import com.squareup.okhttp.Request;
 import com.squareup.okhttp.Response;
 import com.squareup.okhttp.mockwebserver.MockResponse;
@@ -34,7 +33,7 @@
 import org.junit.Rule;
 import org.junit.Test;
 
-import static com.squareup.okhttp.internal.ws.WebSocket.PayloadType.TEXT;
+import static com.squareup.okhttp.ws.WebSocket.PayloadType.TEXT;
 
 public final class WebSocketCallTest {
   @Rule public final MockWebServerRule server = new MockWebServerRule();
@@ -51,7 +50,7 @@
     WebSocketListener serverListener = new EmptyWebSocketListener();
     server.enqueue(new MockResponse().withWebSocketUpgrade(serverListener));
 
-    WebSocket webSocket = awaitCall().webSocket;
+    WebSocket webSocket = awaitWebSocket();
     webSocket.sendPing(new Buffer().writeUtf8("Hello, WebSockets!"));
     listener.assertPong(new Buffer().writeUtf8("Hello, WebSockets!"));
   }
@@ -60,7 +59,7 @@
     WebSocketRecorder serverListener = new WebSocketRecorder();
     server.enqueue(new MockResponse().withWebSocketUpgrade(serverListener));
 
-    WebSocket webSocket = awaitCall().webSocket;
+    WebSocket webSocket = awaitWebSocket();
     webSocket.sendMessage(TEXT, new Buffer().writeUtf8("Hello, WebSockets!"));
     serverListener.assertTextMessage("Hello, WebSockets!");
   }
@@ -74,7 +73,7 @@
     };
     server.enqueue(new MockResponse().withWebSocketUpgrade(serverListener));
 
-    awaitCall();
+    awaitWebSocket();
     listener.assertTextMessage("Hello, WebSockets!");
   }
 
@@ -82,7 +81,7 @@
     WebSocketRecorder serverListener = new WebSocketRecorder();
     server.enqueue(new MockResponse().withWebSocketUpgrade(serverListener));
 
-    WebSocket webSocket = awaitCall().webSocket;
+    WebSocket webSocket = awaitWebSocket();
     BufferedSink sink = webSocket.newMessageSink(TEXT);
     sink.writeUtf8("Hello, ").flush();
     sink.writeUtf8("WebSockets!").flush();
@@ -103,19 +102,19 @@
     };
     server.enqueue(new MockResponse().withWebSocketUpgrade(serverListener));
 
-    awaitCall();
+    awaitWebSocket();
     listener.assertTextMessage("Hello, WebSockets!");
   }
 
   @Test public void okButNotOk() {
     server.enqueue(new MockResponse());
-    awaitCall();
+    awaitWebSocket();
     listener.assertFailure(ProtocolException.class, "Expected HTTP 101 response but was '200 OK'");
   }
 
   @Test public void notFound() {
     server.enqueue(new MockResponse().setStatus("HTTP/1.1 404 Not Found"));
-    awaitCall();
+    awaitWebSocket();
     listener.assertFailure(ProtocolException.class,
         "Expected HTTP 101 response but was '404 Not Found'");
   }
@@ -125,7 +124,7 @@
         .setResponseCode(101)
         .setHeader("Upgrade", "websocket")
         .setHeader("Sec-WebSocket-Accept", "ujmZX4KXZqjwy6vi1aQFH5p4Ygk="));
-    awaitCall();
+    awaitWebSocket();
     listener.assertFailure(ProtocolException.class,
         "Expected 'Connection' header value 'Upgrade' but was 'null'");
   }
@@ -135,7 +134,7 @@
         .setHeader("Upgrade", "websocket")
         .setHeader("Connection", "Downgrade")
         .setHeader("Sec-WebSocket-Accept", "ujmZX4KXZqjwy6vi1aQFH5p4Ygk="));
-    awaitCall();
+    awaitWebSocket();
     listener.assertFailure(ProtocolException.class,
         "Expected 'Connection' header value 'Upgrade' but was 'Downgrade'");
   }
@@ -145,7 +144,7 @@
         .setResponseCode(101)
         .setHeader("Connection", "Upgrade")
         .setHeader("Sec-WebSocket-Accept", "ujmZX4KXZqjwy6vi1aQFH5p4Ygk="));
-    awaitCall();
+    awaitWebSocket();
     listener.assertFailure(ProtocolException.class,
         "Expected 'Upgrade' header value 'websocket' but was 'null'");
   }
@@ -156,7 +155,7 @@
         .setHeader("Connection", "Upgrade")
         .setHeader("Upgrade", "Pepsi")
         .setHeader("Sec-WebSocket-Accept", "ujmZX4KXZqjwy6vi1aQFH5p4Ygk="));
-    awaitCall();
+    awaitWebSocket();
     listener.assertFailure(ProtocolException.class,
         "Expected 'Upgrade' header value 'websocket' but was 'Pepsi'");
   }
@@ -166,7 +165,7 @@
         .setResponseCode(101)
         .setHeader("Connection", "Upgrade")
         .setHeader("Upgrade", "websocket"));
-    awaitCall();
+    awaitWebSocket();
     listener.assertFailure(ProtocolException.class,
         "Expected 'Sec-WebSocket-Accept' header value 'ujmZX4KXZqjwy6vi1aQFH5p4Ygk=' but was 'null'");
   }
@@ -177,12 +176,12 @@
         .setHeader("Connection", "Upgrade")
         .setHeader("Upgrade", "websocket")
         .setHeader("Sec-WebSocket-Accept", "magic"));
-    awaitCall();
+    awaitWebSocket();
     listener.assertFailure(ProtocolException.class,
         "Expected 'Sec-WebSocket-Accept' header value 'ujmZX4KXZqjwy6vi1aQFH5p4Ygk=' but was 'magic'");
   }
 
-  private RecordedResponse awaitCall() {
+  private WebSocket awaitWebSocket() {
     Request request = new Request.Builder().get().url(server.getUrl("/")).build();
     WebSocketCall call = new WebSocketCall(client, request, random);
 
@@ -219,16 +218,14 @@ private RecordedResponse awaitCall() {
     });
 
     try {
-      latch.await(10, TimeUnit.SECONDS);
+      if (!latch.await(10, TimeUnit.SECONDS)) {
+        throw new AssertionError("Timed out.");
+      }
     } catch (InterruptedException e) {
       throw new AssertionError(e);
     }
-    if (latch.getCount() > 0) {
-      throw new AssertionError("Timed out.");
-    }
 
-    return new RecordedResponse(request, responseRef.get(), webSocketRef.get(), null,
-        failureRef.get());
+    return webSocketRef.get();
   }
 
   private static class EmptyWebSocketListener implements WebSocketListener {
diff --git a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/ws/WebSocketRecorder.java b/okhttp-ws-tests/src/test/java/com/squareup/okhttp/ws/WebSocketRecorder.java
similarity index 92%
rename from okhttp-tests/src/test/java/com/squareup/okhttp/internal/ws/WebSocketRecorder.java
rename to okhttp-ws-tests/src/test/java/com/squareup/okhttp/ws/WebSocketRecorder.java
index 05b8480485..551cd91660 100644
--- a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/ws/WebSocketRecorder.java
+++ b/okhttp-ws-tests/src/test/java/com/squareup/okhttp/ws/WebSocketRecorder.java
@@ -13,10 +13,11 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.squareup.okhttp.internal.ws;
+package com.squareup.okhttp.ws;
 
 import com.squareup.okhttp.Request;
 import com.squareup.okhttp.Response;
+import com.squareup.okhttp.internal.ws.WebSocketReader;
 import java.io.IOException;
 import java.util.concurrent.BlockingQueue;
 import java.util.concurrent.LinkedBlockingQueue;
@@ -24,13 +25,13 @@
 import okio.Buffer;
 import okio.BufferedSource;
 
-import static com.squareup.okhttp.internal.ws.WebSocket.PayloadType.BINARY;
-import static com.squareup.okhttp.internal.ws.WebSocket.PayloadType.TEXT;
+import static com.squareup.okhttp.ws.WebSocket.PayloadType.BINARY;
+import static com.squareup.okhttp.ws.WebSocket.PayloadType.TEXT;
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertNotNull;
 import static org.junit.Assert.assertTrue;
 
-final class WebSocketRecorder implements WebSocketReader.FrameCallback, WebSocketListener {
+public final class WebSocketRecorder implements WebSocketReader.FrameCallback, WebSocketListener {
   public interface MessageDelegate {
     void onMessage(BufferedSource payload, WebSocket.PayloadType type) throws IOException;
   }
@@ -77,7 +78,11 @@ public void setNextMessageDelegate(MessageDelegate delegate) {
 
   private Object nextEvent() {
     try {
-      return events.poll(10, TimeUnit.SECONDS);
+      Object event = events.poll(10, TimeUnit.SECONDS);
+      if (event == null) {
+        throw new AssertionError("Timed out.");
+      }
+      return event;
     } catch (InterruptedException e) {
       throw new AssertionError(e);
     }
diff --git a/okhttp-ws/README.md b/okhttp-ws/README.md
new file mode 100644
index 0000000000..054ea91fbf
--- /dev/null
+++ b/okhttp-ws/README.md
@@ -0,0 +1,22 @@
+OkHttp Web Sockets
+==================
+
+RFC6455-compliant web socket implementation.
+
+Create a `WebSocketCall` with a `Request` and an `OkHttpClient` instance.
+```java
+WebSocketCall call = WebSocketCall.create(client, request);
+```
+
+A `WebSocketListener` will notify of the initial connection, server-sent messages, and any failures
+on the connection.
+
+Start the web socket by calling `enqueue` on `WebSocketCall` with the `WebSocketListener`.
+```java
+call.enqueue(new WebSocketListener() {
+  // ...
+});
+```
+
+*Note: This module's API should be considered experimental and may be subject to breaking changes
+in future releases.*
diff --git a/okhttp-ws/pom.xml b/okhttp-ws/pom.xml
new file mode 100644
index 0000000000..ae34464dd3
--- /dev/null
+++ b/okhttp-ws/pom.xml
@@ -0,0 +1,37 @@
+<?xml version="1.0" encoding="UTF-8"?>
+
+<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
+  <modelVersion>4.0.0</modelVersion>
+
+  <parent>
+    <groupId>com.squareup.okhttp</groupId>
+    <artifactId>parent</artifactId>
+    <version>2.4.0-SNAPSHOT</version>
+  </parent>
+
+  <artifactId>okhttp-ws</artifactId>
+  <name>OkHttp Web Sockets</name>
+
+  <dependencies>
+    <dependency>
+      <groupId>com.squareup.okhttp</groupId>
+      <artifactId>okhttp</artifactId>
+      <version>${project.version}</version>
+    </dependency>
+  </dependencies>
+
+  <build>
+    <plugins>
+      <plugin>
+        <groupId>org.apache.maven.plugins</groupId>
+        <artifactId>maven-javadoc-plugin</artifactId>
+        <configuration>
+          <excludePackageNames>com.squareup.okhttp.internal.*</excludePackageNames>
+          <links>
+            <link>http://square.github.io/okhttp/javadoc/</link>
+          </links>
+        </configuration>
+      </plugin>
+    </plugins>
+  </build>
+</project>
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/ws/RealWebSocket.java b/okhttp-ws/src/main/java/com/squareup/okhttp/internal/ws/RealWebSocket.java
similarity index 77%
rename from okhttp/src/main/java/com/squareup/okhttp/internal/ws/RealWebSocket.java
rename to okhttp-ws/src/main/java/com/squareup/okhttp/internal/ws/RealWebSocket.java
index a926ebccf2..a647ac7040 100755
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/ws/RealWebSocket.java
+++ b/okhttp-ws/src/main/java/com/squareup/okhttp/internal/ws/RealWebSocket.java
@@ -16,18 +16,17 @@
 package com.squareup.okhttp.internal.ws;
 
 import com.squareup.okhttp.internal.NamedRunnable;
-import com.squareup.okhttp.internal.Util;
+import com.squareup.okhttp.ws.WebSocket;
+import com.squareup.okhttp.ws.WebSocketListener;
 import java.io.IOException;
 import java.net.ProtocolException;
 import java.util.Random;
-import java.util.concurrent.LinkedBlockingDeque;
-import java.util.concurrent.ThreadPoolExecutor;
+import java.util.concurrent.Executor;
 import okio.Buffer;
 import okio.BufferedSink;
 import okio.BufferedSource;
 
 import static com.squareup.okhttp.internal.ws.WebSocketReader.FrameCallback;
-import static java.util.concurrent.TimeUnit.SECONDS;
 
 public abstract class RealWebSocket implements WebSocket {
   /** A close code which indicates that the peer encountered a protocol exception. */
@@ -45,15 +44,9 @@
   private final Object closeLock = new Object();
 
   public RealWebSocket(boolean isClient, BufferedSource source, BufferedSink sink, Random random,
-      final WebSocketListener listener, final String url) {
+      final Executor replyExecutor, final WebSocketListener listener, final String url) {
     this.listener = listener;
 
-    // Pings come in on the reader thread. This executor contends with callers for writing pongs.
-    final ThreadPoolExecutor pongExecutor = new ThreadPoolExecutor(1, 1, 1, SECONDS,
-        new LinkedBlockingDeque<Runnable>(),
-        Util.threadFactory(String.format("OkHttp %s WebSocket", url), true));
-    pongExecutor.allowCoreThreadTimeOut(true);
-
     writer = new WebSocketWriter(isClient, sink, random);
     reader = new WebSocketReader(isClient, source, new FrameCallback() {
       @Override public void onMessage(BufferedSource source, PayloadType type) throws IOException {
@@ -61,7 +54,7 @@ public RealWebSocket(boolean isClient, BufferedSource source, BufferedSink sink,
       }
 
       @Override public void onPing(final Buffer buffer) {
-        pongExecutor.execute(new NamedRunnable("OkHttp %s WebSocket Pong", url) {
+        replyExecutor.execute(new NamedRunnable("OkHttp %s WebSocket Pong Reply", url) {
           @Override protected void execute() {
             try {
               writer.writePong(buffer);
@@ -75,8 +68,12 @@ public RealWebSocket(boolean isClient, BufferedSource source, BufferedSink sink,
         listener.onPong(buffer);
       }
 
-      @Override public void onClose(int code, String reason) throws IOException {
-        peerClose(code, reason);
+      @Override public void onClose(final int code, final String reason) {
+        replyExecutor.execute(new NamedRunnable("OkHttp %s WebSocket Close Reply", url) {
+          @Override protected void execute() {
+            peerClose(code, reason);
+          }
+        });
       }
     });
   }
@@ -96,28 +93,28 @@ public boolean readMessage() {
   }
 
   @Override public BufferedSink newMessageSink(PayloadType type) {
-    if (writerSentClose) throw new IllegalStateException("Closed");
+    if (writerSentClose) throw new IllegalStateException("closed");
     return writer.newMessageSink(type);
   }
 
   @Override public void sendMessage(PayloadType type, Buffer payload) throws IOException {
-    if (writerSentClose) throw new IllegalStateException("Closed");
+    if (writerSentClose) throw new IllegalStateException("closed");
     writer.sendMessage(type, payload);
   }
 
   @Override public void sendPing(Buffer payload) throws IOException {
-    if (writerSentClose) throw new IllegalStateException("Closed");
+    if (writerSentClose) throw new IllegalStateException("closed");
     writer.writePing(payload);
   }
 
   /** Send an unsolicited pong with the specified payload. */
   public void sendPong(Buffer payload) throws IOException {
-    if (writerSentClose) throw new IllegalStateException("Closed");
+    if (writerSentClose) throw new IllegalStateException("closed");
     writer.writePong(payload);
   }
 
   @Override public void close(int code, String reason) throws IOException {
-    if (writerSentClose) throw new IllegalStateException("Closed");
+    if (writerSentClose) throw new IllegalStateException("closed");
 
     boolean closeConnection;
     synchronized (closeLock) {
@@ -134,8 +131,8 @@ public void sendPong(Buffer payload) throws IOException {
     }
   }
 
-  /** Called on the reader thread when a close frame is encountered. */
-  private void peerClose(int code, String reason) throws IOException {
+  /** Replies and closes this web socket when a close frame is read from the peer. */
+  private void peerClose(int code, String reason) {
     boolean writeCloseResponse;
     synchronized (closeLock) {
       readerSentClose = true;
@@ -145,11 +142,16 @@ private void peerClose(int code, String reason) throws IOException {
     }
 
     if (writeCloseResponse) {
-      // The reader thread will read no more frames so use it to send the response.
-      writer.writeClose(code, reason);
+      try {
+        writer.writeClose(code, reason);
+      } catch (IOException ignored) {
+      }
     }
 
-    closeConnection();
+    try {
+      closeConnection();
+    } catch (IOException ignored) {
+    }
 
     listener.onClose(code, reason);
   }
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/ws/WebSocketProtocol.java b/okhttp-ws/src/main/java/com/squareup/okhttp/internal/ws/WebSocketProtocol.java
similarity index 93%
rename from okhttp/src/main/java/com/squareup/okhttp/internal/ws/WebSocketProtocol.java
rename to okhttp-ws/src/main/java/com/squareup/okhttp/internal/ws/WebSocketProtocol.java
index c9888b2ccd..9e31be1784 100755
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/ws/WebSocketProtocol.java
+++ b/okhttp-ws/src/main/java/com/squareup/okhttp/internal/ws/WebSocketProtocol.java
@@ -72,9 +72,14 @@
    * {@link #PAYLOAD_SHORT} or {@link #PAYLOAD_LONG}.
    */
   static final int PAYLOAD_MAX = 125;
-  /** Value for {@link #B1_MASK_LENGTH} which indicates the next two bytes are the length. */
+  /**
+   * Value for {@link #B1_MASK_LENGTH} which indicates the next two bytes are the unsigned length.
+   */
   static final int PAYLOAD_SHORT = 126;
-  /** Value for {@link #B1_MASK_LENGTH} which indicates the next eight bytes are the length. */
+  /**
+   * Value for {@link #B1_MASK_LENGTH} which indicates the next eight bytes are the unsigned
+   * length.
+   */
   static final int PAYLOAD_LONG = 127;
 
   static void toggleMask(byte[] buffer, long byteCount, byte[] key, long frameBytesRead) {
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/ws/WebSocketReader.java b/okhttp-ws/src/main/java/com/squareup/okhttp/internal/ws/WebSocketReader.java
similarity index 94%
rename from okhttp/src/main/java/com/squareup/okhttp/internal/ws/WebSocketReader.java
rename to okhttp-ws/src/main/java/com/squareup/okhttp/internal/ws/WebSocketReader.java
index 294854a973..ee4e482f62 100755
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/ws/WebSocketReader.java
+++ b/okhttp-ws/src/main/java/com/squareup/okhttp/internal/ws/WebSocketReader.java
@@ -24,7 +24,7 @@
 import okio.Source;
 import okio.Timeout;
 
-import static com.squareup.okhttp.internal.ws.WebSocket.PayloadType;
+import static com.squareup.okhttp.ws.WebSocket.PayloadType;
 import static com.squareup.okhttp.internal.ws.WebSocketProtocol.B0_FLAG_FIN;
 import static com.squareup.okhttp.internal.ws.WebSocketProtocol.B0_FLAG_RSV1;
 import static com.squareup.okhttp.internal.ws.WebSocketProtocol.B0_FLAG_RSV2;
@@ -53,7 +53,7 @@
     void onMessage(BufferedSource source, PayloadType type) throws IOException;
     void onPing(Buffer buffer);
     void onPong(Buffer buffer);
-    void onClose(int code, String reason) throws IOException;
+    void onClose(int code, String reason);
   }
 
   private final boolean isClient;
@@ -77,8 +77,8 @@
   private final byte[] maskBuffer = new byte[2048];
 
   public WebSocketReader(boolean isClient, BufferedSource source, FrameCallback frameCallback) {
-    if (source == null) throw new NullPointerException("source");
-    if (frameCallback == null) throw new NullPointerException("frameCallback");
+    if (source == null) throw new NullPointerException("source == null");
+    if (frameCallback == null) throw new NullPointerException("frameCallback == null");
     this.isClient = isClient;
     this.source = source;
     this.frameCallback = frameCallback;
@@ -103,7 +103,7 @@ public void processNextFrame() throws IOException {
   }
 
   private void readHeader() throws IOException {
-    if (closed) throw new IOException("Closed");
+    if (closed) throw new IOException("closed");
 
     int b0 = source.readByte() & 0xff;
 
@@ -135,9 +135,13 @@ private void readHeader() throws IOException {
     // Get frame length, optionally reading from follow-up bytes if indicated by special values.
     frameLength = b1 & B1_MASK_LENGTH;
     if (frameLength == PAYLOAD_SHORT) {
-      frameLength = source.readShort();
+      frameLength = source.readShort() & 0xffffL; // Value is unsigned.
     } else if (frameLength == PAYLOAD_LONG) {
       frameLength = source.readLong();
+      if (frameLength < 0) {
+        throw new ProtocolException(
+            "Frame length 0x" + Long.toHexString(frameLength) + " > 0x7FFFFFFFFFFFFFFF");
+      }
     }
     frameBytesRead = 0;
 
@@ -230,8 +234,8 @@ private void readUntilNonControlFrame() throws IOException {
    */
   private final class FramedMessageSource implements Source {
     @Override public long read(Buffer sink, long byteCount) throws IOException {
-      if (closed) throw new IOException("Closed");
-      if (messageClosed) throw new IllegalStateException("Closed");
+      if (closed) throw new IOException("closed");
+      if (messageClosed) throw new IllegalStateException("closed");
 
       if (frameBytesRead == frameLength) {
         if (isFinalFrame) return -1; // We are exhausted and have no continuations.
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/ws/WebSocketWriter.java b/okhttp-ws/src/main/java/com/squareup/okhttp/internal/ws/WebSocketWriter.java
similarity index 95%
rename from okhttp/src/main/java/com/squareup/okhttp/internal/ws/WebSocketWriter.java
rename to okhttp-ws/src/main/java/com/squareup/okhttp/internal/ws/WebSocketWriter.java
index 16d269bbcd..74bd083269 100755
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/ws/WebSocketWriter.java
+++ b/okhttp-ws/src/main/java/com/squareup/okhttp/internal/ws/WebSocketWriter.java
@@ -24,7 +24,7 @@
 import okio.Sink;
 import okio.Timeout;
 
-import static com.squareup.okhttp.internal.ws.WebSocket.PayloadType;
+import static com.squareup.okhttp.ws.WebSocket.PayloadType;
 import static com.squareup.okhttp.internal.ws.WebSocketProtocol.B0_FLAG_FIN;
 import static com.squareup.okhttp.internal.ws.WebSocketProtocol.B1_FLAG_MASK;
 import static com.squareup.okhttp.internal.ws.WebSocketProtocol.OPCODE_BINARY;
@@ -62,8 +62,8 @@
   private final byte[] maskBuffer;
 
   public WebSocketWriter(boolean isClient, BufferedSink sink, Random random) {
-    if (sink == null) throw new NullPointerException("sink");
-    if (random == null) throw new NullPointerException("random");
+    if (sink == null) throw new NullPointerException("sink == null");
+    if (random == null) throw new NullPointerException("random == null");
     this.isClient = isClient;
     this.sink = sink;
     this.random = random;
@@ -117,7 +117,7 @@ public void writeClose(int code, String reason) throws IOException {
   }
 
   private void writeControlFrame(int opcode, Buffer payload) throws IOException {
-    if (closed) throw new IOException("Closed");
+    if (closed) throw new IOException("closed");
 
     int length = 0;
     if (payload != null) {
@@ -184,7 +184,7 @@ public void sendMessage(PayloadType type, Buffer payload) throws IOException {
 
   private void writeFrame(PayloadType payloadType, Buffer source, long byteCount,
       boolean isFirstFrame, boolean isFinal) throws IOException {
-    if (closed) throw new IOException("Closed");
+    if (closed) throw new IOException("closed");
 
     int opcode = OPCODE_CONTINUATION;
     if (isFirstFrame) {
@@ -215,7 +215,7 @@ private void writeFrame(PayloadType payloadType, Buffer source, long byteCount,
       if (byteCount <= PAYLOAD_MAX) {
         b1 |= (int) byteCount;
         sink.writeByte(b1);
-      } else if (byteCount <= Short.MAX_VALUE) {
+      } else if (byteCount <= 0xffffL) { // Unsigned short.
         b1 |= PAYLOAD_SHORT;
         sink.writeByte(b1);
         sink.writeShort((int) byteCount);
@@ -258,7 +258,7 @@ private void writeAllMasked(BufferedSource source, long byteCount) throws IOExce
     }
 
     @Override public void flush() throws IOException {
-      if (closed) throw new IOException("Closed");
+      if (closed) throw new IOException("closed");
 
       synchronized (sink) {
         sink.flush();
@@ -271,7 +271,7 @@ private void writeAllMasked(BufferedSource source, long byteCount) throws IOExce
 
     @SuppressWarnings("PointlessBitwiseExpression")
     @Override public void close() throws IOException {
-      if (closed) throw new IOException("Closed");
+      if (closed) throw new IOException("closed");
 
       int length = 0;
 
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/ws/WebSocket.java b/okhttp-ws/src/main/java/com/squareup/okhttp/ws/WebSocket.java
similarity index 97%
rename from okhttp/src/main/java/com/squareup/okhttp/internal/ws/WebSocket.java
rename to okhttp-ws/src/main/java/com/squareup/okhttp/ws/WebSocket.java
index 3be790d010..4cf2f42d6f 100755
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/ws/WebSocket.java
+++ b/okhttp-ws/src/main/java/com/squareup/okhttp/ws/WebSocket.java
@@ -13,13 +13,12 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.squareup.okhttp.internal.ws;
+package com.squareup.okhttp.ws;
 
 import java.io.IOException;
 import okio.Buffer;
 import okio.BufferedSink;
 
-// TODO move to public API!
 /** Blocking interface to connect and write to a web socket. */
 public interface WebSocket {
   /** The format of a message payload. */
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/ws/WebSocketCall.java b/okhttp-ws/src/main/java/com/squareup/okhttp/ws/WebSocketCall.java
similarity index 83%
rename from okhttp/src/main/java/com/squareup/okhttp/internal/ws/WebSocketCall.java
rename to okhttp-ws/src/main/java/com/squareup/okhttp/ws/WebSocketCall.java
index 9147e5bed7..422167cee3 100755
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/ws/WebSocketCall.java
+++ b/okhttp-ws/src/main/java/com/squareup/okhttp/ws/WebSocketCall.java
@@ -13,7 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.squareup.okhttp.internal.ws;
+package com.squareup.okhttp.ws;
 
 import com.squareup.okhttp.Call;
 import com.squareup.okhttp.Callback;
@@ -24,25 +24,29 @@
 import com.squareup.okhttp.internal.Internal;
 import com.squareup.okhttp.internal.NamedRunnable;
 import com.squareup.okhttp.internal.Util;
+import com.squareup.okhttp.internal.ws.RealWebSocket;
+import com.squareup.okhttp.internal.ws.WebSocketProtocol;
 import java.io.IOException;
 import java.net.ProtocolException;
 import java.net.Socket;
 import java.security.SecureRandom;
 import java.util.Collections;
 import java.util.Random;
+import java.util.concurrent.Executor;
+import java.util.concurrent.LinkedBlockingDeque;
+import java.util.concurrent.ThreadPoolExecutor;
 import okio.BufferedSink;
 import okio.BufferedSource;
 import okio.ByteString;
 import okio.Okio;
 
-// TODO move to public API!
-public class WebSocketCall {
+import static java.util.concurrent.TimeUnit.SECONDS;
+
+public final class WebSocketCall {
   /**
    * Prepares the {@code request} to create a web socket at some point in the future.
-   * <p>
-   * TODO Move to OkHttpClient as non-static once web sockets are finalized!
    */
-  public static WebSocketCall newWebSocketCall(OkHttpClient client, Request request) {
+  public static WebSocketCall create(OkHttpClient client, Request request) {
     return new WebSocketCall(client, request);
   }
 
@@ -51,7 +55,7 @@ public static WebSocketCall newWebSocketCall(OkHttpClient client, Request reques
   private final Random random;
   private final String key;
 
-  protected WebSocketCall(OkHttpClient client, Request request) {
+  WebSocketCall(OkHttpClient client, Request request) {
     this(client, request, new SecureRandom());
   }
 
@@ -175,7 +179,7 @@ private void createWebSocket(Response response, WebSocketListener listener)
     BufferedSink sink = Okio.buffer(Okio.sink(socket));
 
     final RealWebSocket webSocket =
-        new ConnectionWebSocket(response, connection, source, sink, random, listener);
+        ConnectionWebSocket.create(response, connection, source, sink, random, listener);
 
     // Start a dedicated thread for reading the web socket.
     new Thread(new NamedRunnable("OkHttp WebSocket reader %s", request.urlString()) {
@@ -193,11 +197,23 @@ private void createWebSocket(Response response, WebSocketListener listener)
 
   // Keep static so that the WebSocketCall instance can be garbage collected.
   private static class ConnectionWebSocket extends RealWebSocket {
+    static RealWebSocket create(Response response, Connection connection, BufferedSource source,
+        BufferedSink sink, Random random, WebSocketListener listener) {
+      String url = response.request().urlString();
+      ThreadPoolExecutor replyExecutor =
+          new ThreadPoolExecutor(1, 1, 1, SECONDS, new LinkedBlockingDeque<Runnable>(),
+              Util.threadFactory(String.format("OkHttp %s WebSocket", url), true));
+      replyExecutor.allowCoreThreadTimeOut(true);
+
+      return new ConnectionWebSocket(connection, source, sink, random, replyExecutor, listener,
+          url);
+    }
+
     private final Connection connection;
 
-    public ConnectionWebSocket(Response response, Connection connection, BufferedSource source,
-        BufferedSink sink, Random random, WebSocketListener listener) {
-      super(true /* is client */, source, sink, random, listener, response.request().urlString());
+    private ConnectionWebSocket(Connection connection, BufferedSource source, BufferedSink sink,
+        Random random, Executor replyExecutor, WebSocketListener listener, String url) {
+      super(true /* is client */, source, sink, random, replyExecutor, listener, url);
       this.connection = connection;
     }
 
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/ws/WebSocketListener.java b/okhttp-ws/src/main/java/com/squareup/okhttp/ws/WebSocketListener.java
similarity index 84%
rename from okhttp/src/main/java/com/squareup/okhttp/internal/ws/WebSocketListener.java
rename to okhttp-ws/src/main/java/com/squareup/okhttp/ws/WebSocketListener.java
index 84f7cc0d78..a113eed244 100755
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/ws/WebSocketListener.java
+++ b/okhttp-ws/src/main/java/com/squareup/okhttp/ws/WebSocketListener.java
@@ -13,7 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.squareup.okhttp.internal.ws;
+package com.squareup.okhttp.ws;
 
 import com.squareup.okhttp.Request;
 import com.squareup.okhttp.Response;
@@ -21,9 +21,8 @@
 import okio.Buffer;
 import okio.BufferedSource;
 
-import static com.squareup.okhttp.internal.ws.WebSocket.PayloadType;
+import static com.squareup.okhttp.ws.WebSocket.PayloadType;
 
-// TODO move to public API!
 /** Listener for server-initiated messages on a connected {@link WebSocket}. */
 public interface WebSocketListener {
   void onOpen(WebSocket webSocket, Request request, Response response) throws IOException;
@@ -31,6 +30,10 @@
   /**
    * Called when a server message is received. The {@code type} indicates whether the
    * {@code payload} should be interpreted as UTF-8 text or binary data.
+   *
+   * <p>Implementations <strong>must</strong> call {@code source.close()} before returning. This
+   * indicates completion of parsing the message payload and will consume any remaining bytes in
+   * the message.
    */
   void onMessage(BufferedSource payload, PayloadType type) throws IOException;
 
@@ -45,7 +48,7 @@
    * from a call to {@link WebSocket#close(int, String) close()} or as an unprompted
    * message from the server.
    *
-   * @param code The <a href="http://tools.ietf.org/html/rfc6455#section-7.4.1>RFC-compliant</a>
+   * @param code The <a href="http://tools.ietf.org/html/rfc6455#section-7.4.1">RFC-compliant</a>
    * status code.
    * @param reason Reason for close or an empty string.
    */
diff --git a/okhttp/pom.xml b/okhttp/pom.xml
index bfa5464e7a..02ef3d7850 100644
--- a/okhttp/pom.xml
+++ b/okhttp/pom.xml
@@ -6,7 +6,7 @@
   <parent>
     <groupId>com.squareup.okhttp</groupId>
     <artifactId>parent</artifactId>
-    <version>2.3.0-SNAPSHOT</version>
+    <version>2.4.0-SNAPSHOT</version>
   </parent>
 
   <artifactId>okhttp</artifactId>
diff --git a/okhttp/src/main/java/com/squareup/okhttp/Cache.java b/okhttp/src/main/java/com/squareup/okhttp/Cache.java
index 0e51fdd487..bcd46810f4 100755
--- a/okhttp/src/main/java/com/squareup/okhttp/Cache.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/Cache.java
@@ -24,7 +24,7 @@
 import com.squareup.okhttp.internal.http.HttpMethod;
 import com.squareup.okhttp.internal.http.OkHeaders;
 import com.squareup.okhttp.internal.http.StatusLine;
-import java.io.ByteArrayInputStream;
+import com.squareup.okhttp.internal.io.FileSystem;
 import java.io.File;
 import java.io.IOException;
 import java.security.cert.Certificate;
@@ -36,6 +36,7 @@
 import java.util.Iterator;
 import java.util.List;
 import java.util.NoSuchElementException;
+import okio.Buffer;
 import okio.BufferedSink;
 import okio.BufferedSource;
 import okio.ByteString;
@@ -46,61 +47,86 @@
 import okio.Source;
 
 /**
- * Caches HTTP and HTTPS responses to the filesystem so they may be reused,
- * saving time and bandwidth.
+ * Caches HTTP and HTTPS responses to the filesystem so they may be reused, saving time and
+ * bandwidth.
  *
  * <h3>Cache Optimization</h3>
  * To measure cache effectiveness, this class tracks three statistics:
  * <ul>
- *     <li><strong>{@linkplain #getRequestCount() Request Count:}</strong> the
- *         number of HTTP requests issued since this cache was created.
- *     <li><strong>{@linkplain #getNetworkCount() Network Count:}</strong> the
- *         number of those requests that required network use.
- *     <li><strong>{@linkplain #getHitCount() Hit Count:}</strong> the number of
- *         those requests whose responses were served by the cache.
+ *   <li><strong>{@linkplain #getRequestCount() Request Count:}</strong> the number of HTTP
+ *     requests issued since this cache was created.
+ *   <li><strong>{@linkplain #getNetworkCount() Network Count:}</strong> the number of those
+ *     requests that required network use.
+ *   <li><strong>{@linkplain #getHitCount() Hit Count:}</strong> the number of those requests whose
+ *     responses were served by the cache.
  * </ul>
- * Sometimes a request will result in a conditional cache hit. If the cache
- * contains a stale copy of the response, the client will issue a conditional
- * {@code GET}. The server will then send either the updated response if it has
- * changed, or a short 'not modified' response if the client's copy is still
- * valid. Such responses increment both the network count and hit count.
  *
- * <p>The best way to improve the cache hit rate is by configuring the web
- * server to return cacheable responses. Although this client honors all <a
- * href="http://www.ietf.org/rfc/rfc2616.txt">HTTP/1.1 (RFC 2068)</a> cache
- * headers, it doesn't cache partial responses.
+ * Sometimes a request will result in a conditional cache hit. If the cache contains a stale copy of
+ * the response, the client will issue a conditional {@code GET}. The server will then send either
+ * the updated response if it has changed, or a short 'not modified' response if the client's copy
+ * is still valid. Such responses increment both the network count and hit count.
+ *
+ * <p>The best way to improve the cache hit rate is by configuring the web server to return
+ * cacheable responses. Although this client honors all <a
+ * href="http://tools.ietf.org/html/rfc7234">HTTP/1.1 (RFC 7234)</a> cache headers, it doesn't cache
+ * partial responses.
  *
  * <h3>Force a Network Response</h3>
- * In some situations, such as after a user clicks a 'refresh' button, it may be
- * necessary to skip the cache, and fetch data directly from the server. To force
- * a full refresh, add the {@code no-cache} directive: <pre>   {@code
- *         connection.addRequestProperty("Cache-Control", "no-cache");
+ * In some situations, such as after a user clicks a 'refresh' button, it may be necessary to skip
+ * the cache, and fetch data directly from the server. To force a full refresh, add the {@code
+ * no-cache} directive: <pre>   {@code
+ *
+ *   Request request = new Request.Builder()
+ *       .cacheControl(new CacheControl.Builder().noCache().build())
+ *       .url("http://publicobject.com/helloworld.txt")
+ *       .build();
  * }</pre>
- * If it is only necessary to force a cached response to be validated by the
- * server, use the more efficient {@code max-age=0} instead: <pre>   {@code
- *         connection.addRequestProperty("Cache-Control", "max-age=0");
+ *
+ * If it is only necessary to force a cached response to be validated by the server, use the more
+ * efficient {@code max-age=0} directive instead: <pre>   {@code
+ *
+ *   Request request = new Request.Builder()
+ *       .cacheControl(new CacheControl.Builder()
+ *           .maxAge(0, TimeUnit.SECONDS)
+ *           .build())
+ *       .url("http://publicobject.com/helloworld.txt")
+ *       .build();
  * }</pre>
  *
  * <h3>Force a Cache Response</h3>
- * Sometimes you'll want to show resources if they are available immediately,
- * but not otherwise. This can be used so your application can show
- * <i>something</i> while waiting for the latest data to be downloaded. To
- * restrict a request to locally-cached resources, add the {@code
+ * Sometimes you'll want to show resources if they are available immediately, but not otherwise.
+ * This can be used so your application can show <i>something</i> while waiting for the latest data
+ * to be downloaded. To restrict a request to locally-cached resources, add the {@code
  * only-if-cached} directive: <pre>   {@code
- *     try {
- *         connection.addRequestProperty("Cache-Control", "only-if-cached");
- *         InputStream cached = connection.getInputStream();
- *         // the resource was cached! show it
- *     } catch (FileNotFoundException e) {
- *         // the resource was not cached
+ *
+ *     Request request = new Request.Builder()
+ *         .cacheControl(new CacheControl.Builder()
+ *             .onlyIfCached()
+ *             .build())
+ *         .url("http://publicobject.com/helloworld.txt")
+ *         .build();
+ *     Response forceCacheResponse = client.newCall(request).execute();
+ *     if (forceCacheResponse.code() != 504) {
+ *       // The resource was cached! Show it.
+ *     } else {
+ *       // The resource was not cached.
  *     }
  * }</pre>
- * This technique works even better in situations where a stale response is
- * better than no response. To permit stale cached responses, use the {@code
- * max-stale} directive with the maximum staleness in seconds: <pre>   {@code
- *         int maxStale = 60 * 60 * 24 * 28; // tolerate 4-weeks stale
- *         connection.addRequestProperty("Cache-Control", "max-stale=" + maxStale);
+ * This technique works even better in situations where a stale response is better than no response.
+ * To permit stale cached responses, use the {@code max-stale} directive with the maximum staleness
+ * in seconds: <pre>   {@code
+ *
+ *   Request request = new Request.Builder()
+ *       .cacheControl(new CacheControl.Builder()
+ *           .maxStale(365, TimeUnit.DAYS)
+ *           .build())
+ *       .url("http://publicobject.com/helloworld.txt")
+ *       .build();
  * }</pre>
+ *
+ * <p>The {@link CacheControl} class can configure request caching directives and parse response
+ * caching directives. It even offers convenient constants {@link CacheControl#FORCE_NETWORK} and
+ * {@link CacheControl#FORCE_CACHE} that address the use cases above.
  */
 public final class Cache {
   private static final int VERSION = 201105;
@@ -139,7 +165,7 @@
   private int requestCount;
 
   public Cache(File directory, long maxSize) {
-    cache = DiskLruCache.create(directory, VERSION, ENTRY_COUNT, maxSize);
+    cache = DiskLruCache.create(FileSystem.SYSTEM, directory, VERSION, ENTRY_COUNT, maxSize);
   }
 
   private static String urlToKey(Request request) {
@@ -534,7 +560,7 @@ public void writeTo(DiskLruCache.Editor editor) throws IOException {
       sink.writeByte('\n');
       sink.writeUtf8(requestMethod);
       sink.writeByte('\n');
-      sink.writeUtf8(Integer.toString(varyHeaders.size()));
+      sink.writeDecimalLong(varyHeaders.size());
       sink.writeByte('\n');
       for (int i = 0, size = varyHeaders.size(); i < size; i++) {
         sink.writeUtf8(varyHeaders.name(i));
@@ -545,7 +571,7 @@ public void writeTo(DiskLruCache.Editor editor) throws IOException {
 
       sink.writeUtf8(new StatusLine(protocol, code, message).toString());
       sink.writeByte('\n');
-      sink.writeUtf8(Integer.toString(responseHeaders.size()));
+      sink.writeDecimalLong(responseHeaders.size());
       sink.writeByte('\n');
       for (int i = 0, size = responseHeaders.size(); i < size; i++) {
         sink.writeUtf8(responseHeaders.name(i));
@@ -558,8 +584,8 @@ public void writeTo(DiskLruCache.Editor editor) throws IOException {
         sink.writeByte('\n');
         sink.writeUtf8(handshake.cipherSuite());
         sink.writeByte('\n');
-        writeCertArray(sink, handshake.peerCertificates());
-        writeCertArray(sink, handshake.localCertificates());
+        writeCertList(sink, handshake.peerCertificates());
+        writeCertList(sink, handshake.localCertificates());
       }
       sink.close();
     }
@@ -577,8 +603,9 @@ private boolean isHttps() {
         List<Certificate> result = new ArrayList<Certificate>(length);
         for (int i = 0; i < length; i++) {
           String line = source.readUtf8LineStrict();
-          byte[] bytes = ByteString.decodeBase64(line).toByteArray();
-          result.add(certificateFactory.generateCertificate(new ByteArrayInputStream(bytes)));
+          Buffer bytes = new Buffer();
+          bytes.write(ByteString.decodeBase64(line));
+          result.add(certificateFactory.generateCertificate(bytes.inputStream()));
         }
         return result;
       } catch (CertificateException e) {
@@ -586,10 +613,10 @@ private boolean isHttps() {
       }
     }
 
-    private void writeCertArray(BufferedSink sink, List<Certificate> certificates)
+    private void writeCertList(BufferedSink sink, List<Certificate> certificates)
         throws IOException {
       try {
-        sink.writeUtf8(Integer.toString(certificates.size()));
+        sink.writeDecimalLong(certificates.size());
         sink.writeByte('\n');
         for (int i = 0, size = certificates.size(); i < size; i++) {
           byte[] bytes = certificates.get(i).getEncoded();
@@ -629,11 +656,15 @@ public Response response(Request request, DiskLruCache.Snapshot snapshot) {
   }
 
   private static int readInt(BufferedSource source) throws IOException {
-    String line = source.readUtf8LineStrict();
     try {
-      return Integer.parseInt(line);
+      long result = source.readDecimalLong();
+      String line = source.readUtf8LineStrict();
+      if (result < 0 || result > Integer.MAX_VALUE || !line.isEmpty()) {
+        throw new IOException("expected an int but was \"" + result + line + "\"");
+      }
+      return (int) result;
     } catch (NumberFormatException e) {
-      throw new IOException("Expected an integer but was \"" + line + "\"");
+      throw new IOException(e.getMessage());
     }
   }
 
diff --git a/okhttp/src/main/java/com/squareup/okhttp/Call.java b/okhttp/src/main/java/com/squareup/okhttp/Call.java
index c4742c2799..107c37c1ad 100755
--- a/okhttp/src/main/java/com/squareup/okhttp/Call.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/Call.java
@@ -31,7 +31,7 @@
  * canceled. As this object represents a single request/response pair (stream),
  * it cannot be executed twice.
  */
-public class Call {
+public final class Call {
   private final OkHttpClient client;
 
   // Guarded by this.
@@ -42,7 +42,7 @@
   Request originalRequest;
   HttpEngine engine;
 
-  protected Call(OkHttpClient client, Request originalRequest) {
+  Call(OkHttpClient client, Request originalRequest) {
     // Copy the client. Otherwise changes (socket factory, redirect policy,
     // etc.) may incorrectly be reflected in the request when it is executed.
     this.client = client.copyWithDefaults();
diff --git a/okhttp/src/main/java/com/squareup/okhttp/ConnectionSpec.java b/okhttp/src/main/java/com/squareup/okhttp/ConnectionSpec.java
index 65f48ae44d..e22746a2a5 100755
--- a/okhttp/src/main/java/com/squareup/okhttp/ConnectionSpec.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/ConnectionSpec.java
@@ -32,26 +32,26 @@
   public static final ConnectionSpec MODERN_TLS = new Builder(true)
       .cipherSuites(
           // This is a subset of the cipher suites supported in Chrome 37, current as of 2014-10-5.
-          // All of these suites are available on Android L; earlier releases support a subset of
+          // All of these suites are available on Android 5.0; earlier releases support a subset of
           // these suites. https://github.com/square/okhttp/issues/330
           CipherSuite.TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256,
           CipherSuite.TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256,
           CipherSuite.TLS_DHE_RSA_WITH_AES_128_GCM_SHA256,
+
+          // Note that the following cipher suites are all on HTTP/2's bad cipher suites list. We'll
+          // continue to include them until better suites are commonly available. For example, none
+          // of the better cipher suites listed above shipped with Android 4.4 or Java 7.
           CipherSuite.TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA,
           CipherSuite.TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA,
           CipherSuite.TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA,
           CipherSuite.TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA,
-          CipherSuite.TLS_ECDHE_ECDSA_WITH_RC4_128_SHA,
-          CipherSuite.TLS_ECDHE_RSA_WITH_RC4_128_SHA,
           CipherSuite.TLS_DHE_RSA_WITH_AES_128_CBC_SHA,
           CipherSuite.TLS_DHE_DSS_WITH_AES_128_CBC_SHA,
           CipherSuite.TLS_DHE_RSA_WITH_AES_256_CBC_SHA,
           CipherSuite.TLS_RSA_WITH_AES_128_GCM_SHA256,
           CipherSuite.TLS_RSA_WITH_AES_128_CBC_SHA,
           CipherSuite.TLS_RSA_WITH_AES_256_CBC_SHA,
-          CipherSuite.TLS_RSA_WITH_3DES_EDE_CBC_SHA,
-          CipherSuite.TLS_RSA_WITH_RC4_128_SHA,
-          CipherSuite.TLS_RSA_WITH_RC4_128_MD5
+          CipherSuite.TLS_RSA_WITH_3DES_EDE_CBC_SHA
       )
       .tlsVersions(TlsVersion.TLS_1_2, TlsVersion.TLS_1_1, TlsVersion.TLS_1_0)
       .supportsTlsExtensions(true)
diff --git a/okhttp/src/main/java/com/squareup/okhttp/MultipartBuilder.java b/okhttp/src/main/java/com/squareup/okhttp/MultipartBuilder.java
index fdd746d07b..9ff3f7a6ba 100755
--- a/okhttp/src/main/java/com/squareup/okhttp/MultipartBuilder.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/MultipartBuilder.java
@@ -20,6 +20,7 @@
 import java.util.ArrayList;
 import java.util.List;
 import java.util.UUID;
+import okio.Buffer;
 import okio.BufferedSink;
 import okio.ByteString;
 
@@ -197,6 +198,7 @@ public RequestBody build() {
     private final MediaType contentType;
     private final List<Headers> partHeaders;
     private final List<RequestBody> partBodies;
+    private long contentLength = -1L;
 
     public MultipartRequestBody(MediaType type, ByteString boundary, List<Headers> partHeaders,
         List<RequestBody> partBodies) {
@@ -213,10 +215,25 @@ public MultipartRequestBody(MediaType type, ByteString boundary, List<Headers> p
     }
 
     @Override public long contentLength() throws IOException {
-      return -1L;
+      long result = contentLength;
+      if (result != -1L) return result;
+      return contentLength = writeOrCountBytes(null, true);
     }
 
-    @Override public void writeTo(BufferedSink sink) throws IOException {
+    /**
+     * Either writes this request to {@code sink} or measures its content length. We have one method
+     * do double-duty to make sure the counting and content are consistent, particularly when it
+     * comes to awkward operations like measuring the encoded length of header strings, or the
+     * length-in-digits of an encoded integer.
+     */
+    private long writeOrCountBytes(BufferedSink sink, boolean countBytes) throws IOException {
+      long byteCount = 0L;
+
+      Buffer byteCountBuffer = null;
+      if (countBytes) {
+        sink = byteCountBuffer = new Buffer();
+      }
+
       for (int p = 0, partCount = partHeaders.size(); p < partCount; p++) {
         Headers headers = partHeaders.get(p);
         RequestBody body = partBodies.get(p);
@@ -244,12 +261,22 @@ public MultipartRequestBody(MediaType type, ByteString boundary, List<Headers> p
         long contentLength = body.contentLength();
         if (contentLength != -1) {
           sink.writeUtf8("Content-Length: ")
-              .writeUtf8(Long.toString(contentLength))
+              .writeDecimalLong(contentLength)
               .write(CRLF);
+        } else if (countBytes) {
+          // We can't measure the body's size without the sizes of its components.
+          byteCountBuffer.clear();
+          return -1L;
         }
 
         sink.write(CRLF);
-        partBodies.get(p).writeTo(sink);
+
+        if (countBytes) {
+          byteCount += contentLength;
+        } else {
+          partBodies.get(p).writeTo(sink);
+        }
+
         sink.write(CRLF);
       }
 
@@ -257,6 +284,17 @@ public MultipartRequestBody(MediaType type, ByteString boundary, List<Headers> p
       sink.write(boundary);
       sink.write(DASHDASH);
       sink.write(CRLF);
+
+      if (countBytes) {
+        byteCount += byteCountBuffer.size();
+        byteCountBuffer.clear();
+      }
+
+      return byteCount;
+    }
+
+    @Override public void writeTo(BufferedSink sink) throws IOException {
+      writeOrCountBytes(sink, false);
     }
   }
 }
diff --git a/okhttp/src/main/java/com/squareup/okhttp/OkHttpClient.java b/okhttp/src/main/java/com/squareup/okhttp/OkHttpClient.java
index 6671d14691..5743cc3c8b 100755
--- a/okhttp/src/main/java/com/squareup/okhttp/OkHttpClient.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/OkHttpClient.java
@@ -49,7 +49,7 @@
  * {@link #clone()} to make a shallow copy of the OkHttpClient that can be
  * safely modified with further configuration changes.
  */
-public class OkHttpClient implements Cloneable {
+public final class OkHttpClient implements Cloneable {
   private static final List<Protocol> DEFAULT_PROTOCOLS = Util.immutableList(
       Protocol.HTTP_2, Protocol.SPDY_3, Protocol.HTTP_1_1);
 
@@ -208,7 +208,7 @@ private OkHttpClient(OkHttpClient okHttpClient) {
    * be between 1 and {@link Integer#MAX_VALUE} when converted to milliseconds.
    * @see URLConnection#setConnectTimeout(int)
    */
-  public final void setConnectTimeout(long timeout, TimeUnit unit) {
+  public void setConnectTimeout(long timeout, TimeUnit unit) {
     if (timeout < 0) throw new IllegalArgumentException("timeout < 0");
     if (unit == null) throw new IllegalArgumentException("unit == null");
     long millis = unit.toMillis(timeout);
@@ -218,7 +218,7 @@ public final void setConnectTimeout(long timeout, TimeUnit unit) {
   }
 
   /** Default connect timeout (in milliseconds). */
-  public final int getConnectTimeout() {
+  public int getConnectTimeout() {
     return connectTimeout;
   }
 
@@ -228,7 +228,7 @@ public final int getConnectTimeout() {
    * be between 1 and {@link Integer#MAX_VALUE} when converted to milliseconds.
    * @see URLConnection#setReadTimeout(int)
    */
-  public final void setReadTimeout(long timeout, TimeUnit unit) {
+  public void setReadTimeout(long timeout, TimeUnit unit) {
     if (timeout < 0) throw new IllegalArgumentException("timeout < 0");
     if (unit == null) throw new IllegalArgumentException("unit == null");
     long millis = unit.toMillis(timeout);
@@ -238,7 +238,7 @@ public final void setReadTimeout(long timeout, TimeUnit unit) {
   }
 
   /** Default read timeout (in milliseconds). */
-  public final int getReadTimeout() {
+  public int getReadTimeout() {
     return readTimeout;
   }
 
@@ -247,7 +247,7 @@ public final int getReadTimeout() {
    * Sets the default write timeout for new connections. A value of 0 means no timeout, otherwise values must
    * be between 1 and {@link Integer#MAX_VALUE} when converted to milliseconds.
    */
-  public final void setWriteTimeout(long timeout, TimeUnit unit) {
+  public void setWriteTimeout(long timeout, TimeUnit unit) {
     if (timeout < 0) throw new IllegalArgumentException("timeout < 0");
     if (unit == null) throw new IllegalArgumentException("unit == null");
     long millis = unit.toMillis(timeout);
@@ -257,7 +257,7 @@ public final void setWriteTimeout(long timeout, TimeUnit unit) {
   }
 
   /** Default write timeout (in milliseconds). */
-  public final int getWriteTimeout() {
+  public int getWriteTimeout() {
     return writeTimeout;
   }
 
@@ -267,12 +267,12 @@ public final int getWriteTimeout() {
    * only honored when this proxy is null (which it is by default). To disable
    * proxy use completely, call {@code setProxy(Proxy.NO_PROXY)}.
    */
-  public final OkHttpClient setProxy(Proxy proxy) {
+  public OkHttpClient setProxy(Proxy proxy) {
     this.proxy = proxy;
     return this;
   }
 
-  public final Proxy getProxy() {
+  public Proxy getProxy() {
     return proxy;
   }
 
@@ -285,12 +285,12 @@ public final Proxy getProxy() {
    * <p>If unset, the {@link ProxySelector#getDefault() system-wide default}
    * proxy selector will be used.
    */
-  public final OkHttpClient setProxySelector(ProxySelector proxySelector) {
+  public OkHttpClient setProxySelector(ProxySelector proxySelector) {
     this.proxySelector = proxySelector;
     return this;
   }
 
-  public final ProxySelector getProxySelector() {
+  public ProxySelector getProxySelector() {
     return proxySelector;
   }
 
@@ -301,32 +301,32 @@ public final ProxySelector getProxySelector() {
    * <p>If unset, the {@link CookieHandler#getDefault() system-wide default}
    * cookie handler will be used.
    */
-  public final OkHttpClient setCookieHandler(CookieHandler cookieHandler) {
+  public OkHttpClient setCookieHandler(CookieHandler cookieHandler) {
     this.cookieHandler = cookieHandler;
     return this;
   }
 
-  public final CookieHandler getCookieHandler() {
+  public CookieHandler getCookieHandler() {
     return cookieHandler;
   }
 
   /** Sets the response cache to be used to read and write cached responses. */
-  final void setInternalCache(InternalCache internalCache) {
+  void setInternalCache(InternalCache internalCache) {
     this.internalCache = internalCache;
     this.cache = null;
   }
 
-  final InternalCache internalCache() {
+  InternalCache internalCache() {
     return internalCache;
   }
 
-  public final OkHttpClient setCache(Cache cache) {
+  public OkHttpClient setCache(Cache cache) {
     this.cache = cache;
     this.internalCache = null;
     return this;
   }
 
-  public final Cache getCache() {
+  public Cache getCache() {
     return cache;
   }
 
@@ -336,12 +336,12 @@ public final Cache getCache() {
    * <p>If unset, the {@link SocketFactory#getDefault() system-wide default}
    * socket factory will be used.
    */
-  public final OkHttpClient setSocketFactory(SocketFactory socketFactory) {
+  public OkHttpClient setSocketFactory(SocketFactory socketFactory) {
     this.socketFactory = socketFactory;
     return this;
   }
 
-  public final SocketFactory getSocketFactory() {
+  public SocketFactory getSocketFactory() {
     return socketFactory;
   }
 
@@ -350,12 +350,12 @@ public final SocketFactory getSocketFactory() {
    *
    * <p>If unset, a lazily created SSL socket factory will be used.
    */
-  public final OkHttpClient setSslSocketFactory(SSLSocketFactory sslSocketFactory) {
+  public OkHttpClient setSslSocketFactory(SSLSocketFactory sslSocketFactory) {
     this.sslSocketFactory = sslSocketFactory;
     return this;
   }
 
-  public final SSLSocketFactory getSslSocketFactory() {
+  public SSLSocketFactory getSslSocketFactory() {
     return sslSocketFactory;
   }
 
@@ -365,12 +365,12 @@ public final SSLSocketFactory getSslSocketFactory() {
    *
    * <p>If unset, a default hostname verifier will be used.
    */
-  public final OkHttpClient setHostnameVerifier(HostnameVerifier hostnameVerifier) {
+  public OkHttpClient setHostnameVerifier(HostnameVerifier hostnameVerifier) {
     this.hostnameVerifier = hostnameVerifier;
     return this;
   }
 
-  public final HostnameVerifier getHostnameVerifier() {
+  public HostnameVerifier getHostnameVerifier() {
     return hostnameVerifier;
   }
 
@@ -380,12 +380,12 @@ public final HostnameVerifier getHostnameVerifier() {
    * SSL socket factory} to establish trust. Pinning certificates avoids the
    * need to trust certificate authorities.
    */
-  public final OkHttpClient setCertificatePinner(CertificatePinner certificatePinner) {
+  public OkHttpClient setCertificatePinner(CertificatePinner certificatePinner) {
     this.certificatePinner = certificatePinner;
     return this;
   }
 
-  public final CertificatePinner getCertificatePinner() {
+  public CertificatePinner getCertificatePinner() {
     return certificatePinner;
   }
 
@@ -396,12 +396,12 @@ public final CertificatePinner getCertificatePinner() {
    * <p>If unset, the {@link java.net.Authenticator#setDefault system-wide default}
    * authenticator will be used.
    */
-  public final OkHttpClient setAuthenticator(Authenticator authenticator) {
+  public OkHttpClient setAuthenticator(Authenticator authenticator) {
     this.authenticator = authenticator;
     return this;
   }
 
-  public final Authenticator getAuthenticator() {
+  public Authenticator getAuthenticator() {
     return authenticator;
   }
 
@@ -411,12 +411,12 @@ public final Authenticator getAuthenticator() {
    * <p>If unset, the {@link ConnectionPool#getDefault() system-wide
    * default} connection pool will be used.
    */
-  public final OkHttpClient setConnectionPool(ConnectionPool connectionPool) {
+  public OkHttpClient setConnectionPool(ConnectionPool connectionPool) {
     this.connectionPool = connectionPool;
     return this;
   }
 
-  public final ConnectionPool getConnectionPool() {
+  public ConnectionPool getConnectionPool() {
     return connectionPool;
   }
 
@@ -427,21 +427,21 @@ public final ConnectionPool getConnectionPool() {
    * <p>If unset, protocol redirects will be followed. This is different than
    * the built-in {@code HttpURLConnection}'s default.
    */
-  public final OkHttpClient setFollowSslRedirects(boolean followProtocolRedirects) {
+  public OkHttpClient setFollowSslRedirects(boolean followProtocolRedirects) {
     this.followSslRedirects = followProtocolRedirects;
     return this;
   }
 
-  public final boolean getFollowSslRedirects() {
+  public boolean getFollowSslRedirects() {
     return followSslRedirects;
   }
 
   /** Configure this client to follow redirects. If unset, redirects be followed. */
-  public final void setFollowRedirects(boolean followRedirects) {
+  public void setFollowRedirects(boolean followRedirects) {
     this.followRedirects = followRedirects;
   }
 
-  public final boolean getFollowRedirects() {
+  public boolean getFollowRedirects() {
     return followRedirects;
   }
 
@@ -463,15 +463,15 @@ public final boolean getFollowRedirects() {
    * Set this to false to avoid retrying requests when doing so is destructive. In this case the
    * calling application should do its own recovery of connectivity failures.
    */
-  public final void setRetryOnConnectionFailure(boolean retryOnConnectionFailure) {
+  public void setRetryOnConnectionFailure(boolean retryOnConnectionFailure) {
     this.retryOnConnectionFailure = retryOnConnectionFailure;
   }
 
-  public final boolean getRetryOnConnectionFailure() {
+  public boolean getRetryOnConnectionFailure() {
     return retryOnConnectionFailure;
   }
 
-  final RouteDatabase routeDatabase() {
+  RouteDatabase routeDatabase() {
     return routeDatabase;
   }
 
@@ -479,13 +479,13 @@ final RouteDatabase routeDatabase() {
    * Sets the dispatcher used to set policy and execute asynchronous requests.
    * Must not be null.
    */
-  public final OkHttpClient setDispatcher(Dispatcher dispatcher) {
+  public OkHttpClient setDispatcher(Dispatcher dispatcher) {
     if (dispatcher == null) throw new IllegalArgumentException("dispatcher == null");
     this.dispatcher = dispatcher;
     return this;
   }
 
-  public final Dispatcher getDispatcher() {
+  public Dispatcher getDispatcher() {
     return dispatcher;
   }
 
@@ -500,12 +500,12 @@ public final Dispatcher getDispatcher() {
    * <ul>
    *   <li><a href="http://www.w3.org/Protocols/rfc2616/rfc2616.html">http/1.1</a>
    *   <li><a href="http://www.chromium.org/spdy/spdy-protocol/spdy-protocol-draft3-1">spdy/3.1</a>
-   *   <li><a href="http://tools.ietf.org/html/draft-ietf-httpbis-http2-16">h2-16</a>
+   *   <li><a href="http://tools.ietf.org/html/draft-ietf-httpbis-http2-17">h2</a>
    * </ul>
    *
-   * <p><strong>This is an evolving set.</strong> Future releases may drop
-   * support for transitional protocols (like h2-16), in favor of their
-   * successors (h2). The http/1.1 transport will never be dropped.
+   * <p><strong>This is an evolving set.</strong> Future releases include
+   * support for transitional protocols. The http/1.1 transport will never be
+   * dropped.
    *
    * <p>If multiple protocols are specified, <a
    * href="http://tools.ietf.org/html/draft-ietf-tls-applayerprotoneg">ALPN</a>
@@ -519,7 +519,7 @@ public final Dispatcher getDispatcher() {
    *     must contain {@link Protocol#HTTP_1_1}. It must not contain null or
    *     {@link Protocol#HTTP_1_0}.
    */
-  public final OkHttpClient setProtocols(List<Protocol> protocols) {
+  public OkHttpClient setProtocols(List<Protocol> protocols) {
     protocols = Util.immutableList(protocols);
     if (!protocols.contains(Protocol.HTTP_1_1)) {
       throw new IllegalArgumentException("protocols doesn't contain http/1.1: " + protocols);
@@ -534,16 +534,16 @@ public final OkHttpClient setProtocols(List<Protocol> protocols) {
     return this;
   }
 
-  public final List<Protocol> getProtocols() {
+  public List<Protocol> getProtocols() {
     return protocols;
   }
 
-  public final OkHttpClient setConnectionSpecs(List<ConnectionSpec> connectionSpecs) {
+  public OkHttpClient setConnectionSpecs(List<ConnectionSpec> connectionSpecs) {
     this.connectionSpecs = Util.immutableList(connectionSpecs);
     return this;
   }
 
-  public final List<ConnectionSpec> getConnectionSpecs() {
+  public List<ConnectionSpec> getConnectionSpecs() {
     return connectionSpecs;
   }
 
@@ -585,7 +585,7 @@ public OkHttpClient cancel(Object tag) {
    * Returns a shallow copy of this OkHttpClient that uses the system-wide
    * default for each field that hasn't been explicitly configured.
    */
-  final OkHttpClient copyWithDefaults() {
+  OkHttpClient copyWithDefaults() {
     OkHttpClient result = new OkHttpClient(this);
     if (result.proxySelector == null) {
       result.proxySelector = ProxySelector.getDefault();
@@ -648,11 +648,7 @@ private synchronized SSLSocketFactory getDefaultSSLSocketFactory() {
   }
 
   /** Returns a shallow copy of this OkHttpClient. */
-  @Override public final OkHttpClient clone() {
-    try {
-      return (OkHttpClient) super.clone();
-    } catch (CloneNotSupportedException e) {
-      throw new AssertionError();
-    }
+  @Override public OkHttpClient clone() {
+    return new OkHttpClient(this);
   }
 }
diff --git a/okhttp/src/main/java/com/squareup/okhttp/Protocol.java b/okhttp/src/main/java/com/squareup/okhttp/Protocol.java
index 03093df041..6b02098133 100755
--- a/okhttp/src/main/java/com/squareup/okhttp/Protocol.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/Protocol.java
@@ -61,19 +61,12 @@
    * multiplexing multiple requests on the same socket, and server-push.
    * HTTP/1.1 semantics are layered on HTTP/2.
    *
-   * <p>This version of OkHttp implements HTTP/2 <a
-   * href="http://tools.ietf.org/html/draft-ietf-httpbis-http2-16">draft 16</a>
-   * with HPACK <a
-   * href="http://tools.ietf.org/html/draft-ietf-httpbis-header-compression-10">draft
-   * 10</a>. Future releases of OkHttp may use this identifier for a newer draft
-   * of these specs.
-   *
    * <p>HTTP/2 requires deployments of HTTP/2 that use TLS 1.2 support
    * {@linkplain com.squareup.okhttp.CipherSuite#TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256}
    * , present in Java 8+ and Android 5+. Servers that enforce this may send an
    * exception message including the string {@code INADEQUATE_SECURITY}.
    */
-  HTTP_2("h2-16");
+  HTTP_2("h2");
 
   private final String protocol;
 
@@ -96,7 +89,7 @@ public static Protocol get(String protocol) throws IOException {
 
   /**
    * Returns the string used to identify this protocol for ALPN, like
-   * "http/1.1", "spdy/3.1" or "h2-16".
+   * "http/1.1", "spdy/3.1" or "h2".
    */
   @Override public String toString() {
     return protocol;
diff --git a/okhttp/src/main/java/com/squareup/okhttp/Request.java b/okhttp/src/main/java/com/squareup/okhttp/Request.java
index c40ada31ae..098ee9b91a 100755
--- a/okhttp/src/main/java/com/squareup/okhttp/Request.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/Request.java
@@ -146,7 +146,8 @@ private Builder(Request request) {
 
     public Builder url(String url) {
       if (url == null) throw new IllegalArgumentException("url == null");
-      urlString = url;
+      this.urlString = url;
+      this.url = null;
       return this;
     }
 
diff --git a/okhttp/src/main/java/com/squareup/okhttp/RequestBody.java b/okhttp/src/main/java/com/squareup/okhttp/RequestBody.java
index 5d7483767e..19ee211136 100755
--- a/okhttp/src/main/java/com/squareup/okhttp/RequestBody.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/RequestBody.java
@@ -57,19 +57,25 @@ public static RequestBody create(MediaType contentType, String content) {
 
   /** Returns a new request body that transmits {@code content}. */
   public static RequestBody create(final MediaType contentType, final byte[] content) {
-    if (content == null) throw new NullPointerException("content == null");
+    return create(contentType, content, 0, content.length);
+  }
 
+  /** Returns a new request body that transmits {@code content}. */
+  public static RequestBody create(final MediaType contentType, final byte[] content,
+      final int offset, final int byteCount) {
+    if (content == null) throw new NullPointerException("content == null");
+    Util.checkOffsetAndCount(content.length, offset, byteCount);
     return new RequestBody() {
       @Override public MediaType contentType() {
         return contentType;
       }
 
       @Override public long contentLength() {
-        return content.length;
+        return byteCount;
       }
 
       @Override public void writeTo(BufferedSink sink) throws IOException {
-        sink.write(content);
+        sink.write(content, offset, byteCount);
       }
     };
   }
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/DiskLruCache.java b/okhttp/src/main/java/com/squareup/okhttp/internal/DiskLruCache.java
index 7956a238f2..0e06703b8c 100755
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/DiskLruCache.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/DiskLruCache.java
@@ -16,6 +16,7 @@
 
 package com.squareup.okhttp.internal;
 
+import com.squareup.okhttp.internal.io.FileSystem;
 import java.io.Closeable;
 import java.io.EOFException;
 import java.io.File;
@@ -35,7 +36,6 @@
 import okio.Buffer;
 import okio.BufferedSink;
 import okio.BufferedSource;
-import okio.ForwardingSink;
 import okio.Okio;
 import okio.Sink;
 import okio.Source;
@@ -138,6 +138,7 @@
      * it exists when the cache is opened.
      */
 
+  private final FileSystem fileSystem;
   private final File directory;
   private final File journalFile;
   private final File journalFileTmp;
@@ -149,6 +150,7 @@
   private BufferedSink journalWriter;
   private final LinkedHashMap<String, Entry> lruEntries = new LinkedHashMap<String, Entry>(0, 0.75f, true);
   private int redundantOpCount;
+  private boolean hasJournalErrors;
 
   // Must be read and written when synchronized on 'this'.
   private boolean initialized;
@@ -182,7 +184,9 @@ public void run() {
     }
   };
 
-  DiskLruCache(File directory, int appVersion, int valueCount, long maxSize, Executor executor) {
+  DiskLruCache(FileSystem fileSystem, File directory, int appVersion, int valueCount, long maxSize,
+      Executor executor) {
+    this.fileSystem = fileSystem;
     this.directory = directory;
     this.appVersion = appVersion;
     this.journalFile = new File(directory, JOURNAL_FILE);
@@ -202,17 +206,17 @@ void initialize() throws IOException {
     }
 
     // If a bkp file exists, use it instead.
-    if (journalFileBackup.exists()) {
+    if (fileSystem.exists(journalFileBackup)) {
       // If journal file also exists just delete backup file.
-      if (journalFile.exists()) {
-        journalFileBackup.delete();
+      if (fileSystem.exists(journalFile)) {
+        fileSystem.delete(journalFileBackup);
       } else {
-        renameTo(journalFileBackup, journalFile, false);
+        fileSystem.rename(journalFileBackup, journalFile);
       }
     }
 
     // Prefer to pick up where we left off.
-    if (journalFile.exists()) {
+    if (fileSystem.exists(journalFile)) {
       try {
         readJournal();
         processJournal();
@@ -226,7 +230,6 @@ void initialize() throws IOException {
       }
     }
 
-    directory.mkdirs();
     rebuildJournal();
 
     initialized = true;
@@ -240,7 +243,8 @@ void initialize() throws IOException {
    * @param valueCount the number of values per cache entry. Must be positive.
    * @param maxSize the maximum number of bytes this cache should use to store
    */
-  public static DiskLruCache create(File directory, int appVersion, int valueCount, long maxSize) {
+  public static DiskLruCache create(FileSystem fileSystem, File directory, int appVersion,
+      int valueCount, long maxSize) {
     if (maxSize <= 0) {
       throw new IllegalArgumentException("maxSize <= 0");
     }
@@ -252,11 +256,11 @@ public static DiskLruCache create(File directory, int appVersion, int valueCount
     Executor executor = new ThreadPoolExecutor(0, 1, 60L, TimeUnit.SECONDS,
         new LinkedBlockingQueue<Runnable>(), Util.threadFactory("OkHttp DiskLruCache", true));
 
-    return new DiskLruCache(directory, appVersion, valueCount, maxSize, executor);
+    return new DiskLruCache(fileSystem, directory, appVersion, valueCount, maxSize, executor);
   }
 
   private void readJournal() throws IOException {
-    BufferedSource source = Okio.buffer(Okio.source(journalFile));
+    BufferedSource source = Okio.buffer(fileSystem.source(journalFile));
     try {
       String magic = source.readUtf8LineStrict();
       String version = source.readUtf8LineStrict();
@@ -287,13 +291,24 @@ private void readJournal() throws IOException {
       if (!source.exhausted()) {
         rebuildJournal();
       } else {
-        journalWriter = Okio.buffer(Okio.appendingSink(journalFile));
+        journalWriter = newJournalWriter();
       }
     } finally {
       Util.closeQuietly(source);
     }
   }
 
+  private BufferedSink newJournalWriter() throws FileNotFoundException {
+    Sink fileSink = fileSystem.appendingSink(journalFile);
+    Sink faultHidingSink = new FaultHidingSink(fileSink) {
+      @Override protected void onException(IOException e) {
+        assert (Thread.holdsLock(DiskLruCache.this));
+        hasJournalErrors = true;
+      }
+    };
+    return Okio.buffer(faultHidingSink);
+  }
+
   private void readJournalLine(String line) throws IOException {
     int firstSpace = line.indexOf(' ');
     if (firstSpace == -1) {
@@ -338,7 +353,7 @@ private void readJournalLine(String line) throws IOException {
    * cache. Dirty entries are assumed to be inconsistent and will be deleted.
    */
   private void processJournal() throws IOException {
-    deleteIfExists(journalFileTmp);
+    fileSystem.delete(journalFileTmp);
     for (Iterator<Entry> i = lruEntries.values().iterator(); i.hasNext(); ) {
       Entry entry = i.next();
       if (entry.currentEditor == null) {
@@ -348,8 +363,8 @@ private void processJournal() throws IOException {
       } else {
         entry.currentEditor = null;
         for (int t = 0; t < valueCount; t++) {
-          deleteIfExists(entry.cleanFiles[t]);
-          deleteIfExists(entry.dirtyFiles[t]);
+          fileSystem.delete(entry.cleanFiles[t]);
+          fileSystem.delete(entry.dirtyFiles[t]);
         }
         i.remove();
       }
@@ -365,12 +380,12 @@ private synchronized void rebuildJournal() throws IOException {
       journalWriter.close();
     }
 
-    BufferedSink writer = Okio.buffer(Okio.sink(journalFileTmp));
+    BufferedSink writer = Okio.buffer(fileSystem.sink(journalFileTmp));
     try {
       writer.writeUtf8(MAGIC).writeByte('\n');
       writer.writeUtf8(VERSION_1).writeByte('\n');
-      writer.writeUtf8(Integer.toString(appVersion)).writeByte('\n');
-      writer.writeUtf8(Integer.toString(valueCount)).writeByte('\n');
+      writer.writeDecimalLong(appVersion).writeByte('\n');
+      writer.writeDecimalLong(valueCount).writeByte('\n');
       writer.writeByte('\n');
 
       for (Entry entry : lruEntries.values()) {
@@ -389,29 +404,14 @@ private synchronized void rebuildJournal() throws IOException {
       writer.close();
     }
 
-    if (journalFile.exists()) {
-      renameTo(journalFile, journalFileBackup, true);
+    if (fileSystem.exists(journalFile)) {
+      fileSystem.rename(journalFile, journalFileBackup);
     }
-    renameTo(journalFileTmp, journalFile, false);
-    journalFileBackup.delete();
+    fileSystem.rename(journalFileTmp, journalFile);
+    fileSystem.delete(journalFileBackup);
 
-    journalWriter = Okio.buffer(Okio.appendingSink(journalFile));
-  }
-
-  private static void deleteIfExists(File file) throws IOException {
-    // If delete() fails, make sure it's because the file didn't exist!
-    if (!file.delete() && file.exists()) {
-      throw new IOException("failed to delete " + file);
-    }
-  }
-
-  private static void renameTo(File from, File to, boolean deleteDestination) throws IOException {
-    if (deleteDestination) {
-      deleteIfExists(to);
-    }
-    if (!from.renameTo(to)) {
-      throw new IOException();
-    }
+    journalWriter = newJournalWriter();
+    hasJournalErrors = false;
   }
 
   /**
@@ -457,19 +457,24 @@ private synchronized Editor edit(String key, long expectedSequenceNumber) throws
         || entry.sequenceNumber != expectedSequenceNumber)) {
       return null; // Snapshot is stale.
     }
-    if (entry == null) {
-      entry = new Entry(key);
-      lruEntries.put(key, entry);
-    } else if (entry.currentEditor != null) {
+    if (entry != null && entry.currentEditor != null) {
       return null; // Another edit is in progress.
     }
 
-    Editor editor = new Editor(entry);
-    entry.currentEditor = editor;
-
     // Flush the journal before creating files to prevent file leaks.
     journalWriter.writeUtf8(DIRTY).writeByte(' ').writeUtf8(key).writeByte('\n');
     journalWriter.flush();
+
+    if (hasJournalErrors) {
+      return null; // Don't edit; the journal can't be written.
+    }
+
+    if (entry == null) {
+      entry = new Entry(key);
+      lruEntries.put(key, entry);
+    }
+    Editor editor = new Editor(entry);
+    entry.currentEditor = editor;
     return editor;
   }
 
@@ -520,7 +525,7 @@ private synchronized void completeEdit(Editor editor, boolean success) throws IO
           editor.abort();
           throw new IllegalStateException("Newly created entry didn't create value for index " + i);
         }
-        if (!entry.dirtyFiles[i].exists()) {
+        if (!fileSystem.exists(entry.dirtyFiles[i])) {
           editor.abort();
           return;
         }
@@ -530,16 +535,16 @@ private synchronized void completeEdit(Editor editor, boolean success) throws IO
     for (int i = 0; i < valueCount; i++) {
       File dirty = entry.dirtyFiles[i];
       if (success) {
-        if (dirty.exists()) {
+        if (fileSystem.exists(dirty)) {
           File clean = entry.cleanFiles[i];
-          dirty.renameTo(clean);
+          fileSystem.rename(dirty, clean);
           long oldLength = entry.lengths[i];
-          long newLength = clean.length();
+          long newLength = fileSystem.size(clean);
           entry.lengths[i] = newLength;
           size = size - oldLength + newLength;
         }
       } else {
-        deleteIfExists(dirty);
+        fileSystem.delete(dirty);
       }
     }
 
@@ -600,8 +605,7 @@ private boolean removeEntry(Entry entry) throws IOException {
     }
 
     for (int i = 0; i < valueCount; i++) {
-      File file = entry.cleanFiles[i];
-      deleteIfExists(file);
+      fileSystem.delete(entry.cleanFiles[i]);
       size -= entry.lengths[i];
       entry.lengths[i] = 0;
     }
@@ -669,7 +673,7 @@ private void trimToSize() throws IOException {
    */
   public void delete() throws IOException {
     close();
-    Util.deleteContents(directory);
+    fileSystem.deleteContents(directory);
   }
 
   /**
@@ -844,7 +848,7 @@ public Source newSource(int index) throws IOException {
           return null;
         }
         try {
-          return Okio.source(entry.cleanFiles[index]);
+          return fileSystem.source(entry.cleanFiles[index]);
         } catch (FileNotFoundException e) {
           return null;
         }
@@ -869,18 +873,17 @@ public Sink newSink(int index) throws IOException {
         File dirtyFile = entry.dirtyFiles[index];
         Sink sink;
         try {
-          sink = Okio.sink(dirtyFile);
+          sink = fileSystem.sink(dirtyFile);
         } catch (FileNotFoundException e) {
-          // Attempt to recreate the cache directory.
-          directory.mkdirs();
-          try {
-            sink = Okio.sink(dirtyFile);
-          } catch (FileNotFoundException e2) {
-            // We are unable to recover. Silently eat the writes.
-            return NULL_SINK;
-          }
+          return NULL_SINK;
         }
-        return new FaultHidingSink(sink);
+        return new FaultHidingSink(sink) {
+          @Override protected void onException(IOException e) {
+            synchronized (DiskLruCache.this) {
+              hasErrors = true;
+            }
+          }
+        };
       }
     }
 
@@ -920,42 +923,6 @@ public void abortUnlessCommitted() {
         }
       }
     }
-
-    private class FaultHidingSink extends ForwardingSink {
-      public FaultHidingSink(Sink delegate) {
-        super(delegate);
-      }
-
-      @Override public void write(Buffer source, long byteCount) throws IOException {
-        try {
-          super.write(source, byteCount);
-        } catch (IOException e) {
-          synchronized (DiskLruCache.this) {
-            hasErrors = true;
-          }
-        }
-      }
-
-      @Override public void flush() throws IOException {
-        try {
-          super.flush();
-        } catch (IOException e) {
-          synchronized (DiskLruCache.this) {
-            hasErrors = true;
-          }
-        }
-      }
-
-      @Override public void close() throws IOException {
-        try {
-          super.close();
-        } catch (IOException e) {
-          synchronized (DiskLruCache.this) {
-            hasErrors = true;
-          }
-        }
-      }
-    }
   }
 
   private final class Entry {
@@ -1012,7 +979,7 @@ private void setLengths(String[] strings) throws IOException {
     /** Append space-prefixed lengths to {@code writer}. */
     void writeLengths(BufferedSink writer) throws IOException {
       for (long length : lengths) {
-        writer.writeByte(' ').writeUtf8(Long.toString(length));
+        writer.writeByte(' ').writeDecimalLong(length);
       }
     }
 
@@ -1032,7 +999,7 @@ Snapshot snapshot() {
       long[] lengths = this.lengths.clone(); // Defensive copy since these can be zeroed out.
       try {
         for (int i = 0; i < valueCount; i++) {
-          sources[i] = Okio.source(cleanFiles[i]);
+          sources[i] = fileSystem.source(cleanFiles[i]);
         }
         return new Snapshot(key, sequenceNumber, sources, lengths);
       } catch (FileNotFoundException e) {
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/FaultHidingSink.java b/okhttp/src/main/java/com/squareup/okhttp/internal/FaultHidingSink.java
new file mode 100644
index 0000000000..91e990db8d
--- /dev/null
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/FaultHidingSink.java
@@ -0,0 +1,51 @@
+package com.squareup.okhttp.internal;
+
+import java.io.IOException;
+import okio.Buffer;
+import okio.ForwardingSink;
+import okio.Sink;
+
+/** A sink that never throws IOExceptions, even if the underlying sink does. */
+class FaultHidingSink extends ForwardingSink {
+  private boolean hasErrors;
+
+  public FaultHidingSink(Sink delegate) {
+    super(delegate);
+  }
+
+  @Override public void write(Buffer source, long byteCount) throws IOException {
+    if (hasErrors) {
+      source.skip(byteCount);
+      return;
+    }
+    try {
+      super.write(source, byteCount);
+    } catch (IOException e) {
+      hasErrors = true;
+      onException(e);
+    }
+  }
+
+  @Override public void flush() throws IOException {
+    if (hasErrors) return;
+    try {
+      super.flush();
+    } catch (IOException e) {
+      hasErrors = true;
+      onException(e);
+    }
+  }
+
+  @Override public void close() throws IOException {
+    if (hasErrors) return;
+    try {
+      super.close();
+    } catch (IOException e) {
+      hasErrors = true;
+      onException(e);
+    }
+  }
+
+  protected void onException(IOException e) {
+  }
+}
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/Platform.java b/okhttp/src/main/java/com/squareup/okhttp/internal/Platform.java
index 0ab865ddd9..a30d783f57 100755
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/Platform.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/Platform.java
@@ -38,15 +38,22 @@
 import static com.squareup.okhttp.internal.Internal.logger;
 
 /**
- * Access to Platform-specific features necessary for SPDY and advanced TLS.
- * This includes Server Name Indication (SNI) and session tickets.
+ * Access to platform-specific features.
  *
- * <h3>ALPN</h3>
- * This class uses TLS extension ALPN to negotiate the upgrade from HTTP/1.1
- * (the default protocol to use with TLS on port 443) to either SPDY or HTTP/2.
+ * <h3>Server name indication (SNI)</h3>
+ * Supported on Android 2.3+.
  *
- * <p>ALPN (Application Layer Protocol Negotiation) first arrived in Android 4.4,
- * ALPN is supported on OpenJDK 7 and 8 (via the Jetty ALPN-boot library).
+ * <h3>Session Tickets</h3>
+ * Supported on Android 2.3+.
+ *
+ * <h3>Android Traffic Stats (Socket Tagging)</h3>
+ * Supported on Android 4.0+.
+ *
+ * <h3>ALPN (Application Layer Protocol Negotiation)</h3>
+ * Supported on Android 5.0+. The APIs were present in Android 4.4, but that implementation was
+ * unstable.
+ *
+ * Supported on OpenJDK 7 and 8 (via the JettyALPN-boot library).
  */
 public class Platform {
   private static final Platform PLATFORM = findPlatform();
@@ -107,28 +114,44 @@ private static Platform findPlatform() {
     try {
       try {
         Class.forName("com.android.org.conscrypt.OpenSSLSocketImpl");
-      } catch (ClassNotFoundException ignored) {
+      } catch (ClassNotFoundException e) {
         // Older platform before being unbundled.
         Class.forName("org.apache.harmony.xnet.provider.jsse.OpenSSLSocketImpl");
       }
 
-      // Attempt to find Android 4.0+ APIs.
+      OptionalMethod<Socket> setUseSessionTickets
+          = new OptionalMethod<>(null, "setUseSessionTickets", boolean.class);
+      OptionalMethod<Socket> setHostname
+          = new OptionalMethod<>(null, "setHostname", String.class);
       Method trafficStatsTagSocket = null;
       Method trafficStatsUntagSocket = null;
+      OptionalMethod<Socket> getAlpnSelectedProtocol = null;
+      OptionalMethod<Socket> setAlpnProtocols = null;
+
+      // Attempt to find Android 4.0+ APIs.
       try {
         Class<?> trafficStats = Class.forName("android.net.TrafficStats");
         trafficStatsTagSocket = trafficStats.getMethod("tagSocket", Socket.class);
         trafficStatsUntagSocket = trafficStats.getMethod("untagSocket", Socket.class);
-      } catch (ClassNotFoundException ignored) {
-      } catch (NoSuchMethodException ignored) {
+
+        // Attempt to find Android 5.0+ APIs.
+        try {
+          Class.forName("android.net.Network"); // Arbitrary class added in Android 5.0.
+          getAlpnSelectedProtocol = new OptionalMethod<>(byte[].class, "getAlpnSelectedProtocol");
+          setAlpnProtocols = new OptionalMethod<>(null, "setAlpnProtocols", byte[].class);
+        } catch (ClassNotFoundException ignored) {
+        }
+      } catch (ClassNotFoundException | NoSuchMethodException ignored) {
       }
 
-      return new Android(trafficStatsTagSocket, trafficStatsUntagSocket);
+      return new Android(setUseSessionTickets, setHostname, trafficStatsTagSocket,
+          trafficStatsUntagSocket, getAlpnSelectedProtocol, setAlpnProtocols);
     } catch (ClassNotFoundException ignored) {
       // This isn't an Android runtime.
     }
 
-    try { // to find the Jetty's ALPN extension for OpenJDK.
+    // Find Jetty's ALPN extension for OpenJDK.
+    try {
       String negoClassName = "org.eclipse.jetty.alpn.ALPN";
       Class<?> negoClass = Class.forName(negoClassName);
       Class<?> providerClass = Class.forName(negoClassName + "$Provider");
@@ -139,39 +162,34 @@ private static Platform findPlatform() {
       Method removeMethod = negoClass.getMethod("remove", SSLSocket.class);
       return new JdkWithJettyBootPlatform(
           putMethod, getMethod, removeMethod, clientProviderClass, serverProviderClass);
-    } catch (ClassNotFoundException ignored) {
-    } catch (NoSuchMethodException ignored) { // The ALPN version isn't what we expect.
+    } catch (ClassNotFoundException | NoSuchMethodException ignored) {
     }
 
     return new Platform();
   }
 
-  /**
-   * Android 2.3 or better. Version 2.3 supports TLS session tickets and server
-   * name indication (SNI). Versions 4.4 supports ALPN.
-   */
+  /** Android 2.3 or better. */
   private static class Android extends Platform {
-
-    // setUseSessionTickets(boolean)
-    private static final OptionalMethod<Socket> SET_USE_SESSION_TICKETS =
-        new OptionalMethod<Socket>(null, "setUseSessionTickets", Boolean.TYPE);
-    // setHostname(String)
-    private static final OptionalMethod<Socket> SET_HOSTNAME =
-        new OptionalMethod<Socket>(null, "setHostname", String.class);
-    // byte[] getAlpnSelectedProtocol()
-    private static final OptionalMethod<Socket> GET_ALPN_SELECTED_PROTOCOL =
-        new OptionalMethod<Socket>(byte[].class, "getAlpnSelectedProtocol");
-    // setAlpnSelectedProtocol(byte[])
-    private static final OptionalMethod<Socket> SET_ALPN_PROTOCOLS =
-        new OptionalMethod<Socket>(null, "setAlpnProtocols", byte[].class);
+    private final OptionalMethod<Socket> setUseSessionTickets;
+    private final OptionalMethod<Socket> setHostname;
 
     // Non-null on Android 4.0+.
     private final Method trafficStatsTagSocket;
     private final Method trafficStatsUntagSocket;
 
-    private Android(Method trafficStatsTagSocket, Method trafficStatsUntagSocket) {
+    // Non-null on Android 5.0+.
+    private final OptionalMethod<Socket> getAlpnSelectedProtocol;
+    private final OptionalMethod<Socket> setAlpnProtocols;
+
+    public Android(OptionalMethod<Socket> setUseSessionTickets, OptionalMethod<Socket> setHostname,
+        Method trafficStatsTagSocket, Method trafficStatsUntagSocket,
+        OptionalMethod<Socket> getAlpnSelectedProtocol, OptionalMethod<Socket> setAlpnProtocols) {
+      this.setUseSessionTickets = setUseSessionTickets;
+      this.setHostname = setHostname;
       this.trafficStatsTagSocket = trafficStatsTagSocket;
       this.trafficStatsUntagSocket = trafficStatsUntagSocket;
+      this.getAlpnSelectedProtocol = getAlpnSelectedProtocol;
+      this.setAlpnProtocols = setAlpnProtocols;
     }
 
     @Override public void connectSocket(Socket socket, InetSocketAddress address,
@@ -191,32 +209,23 @@ private Android(Method trafficStatsTagSocket, Method trafficStatsUntagSocket) {
         SSLSocket sslSocket, String hostname, List<Protocol> protocols) {
       // Enable SNI and session tickets.
       if (hostname != null) {
-        SET_USE_SESSION_TICKETS.invokeOptionalWithoutCheckedException(sslSocket, true);
-        SET_HOSTNAME.invokeOptionalWithoutCheckedException(sslSocket, hostname);
+        setUseSessionTickets.invokeOptionalWithoutCheckedException(sslSocket, true);
+        setHostname.invokeOptionalWithoutCheckedException(sslSocket, hostname);
       }
 
       // Enable ALPN.
-      boolean alpnSupported = SET_ALPN_PROTOCOLS.isSupported(sslSocket);
-      if (!alpnSupported) {
-        return;
+      if (setAlpnProtocols != null && setAlpnProtocols.isSupported(sslSocket)) {
+        Object[] parameters = { concatLengthPrefixed(protocols) };
+        setAlpnProtocols.invokeWithoutCheckedException(sslSocket, parameters);
       }
-
-      Object[] parameters = { concatLengthPrefixed(protocols) };
-      SET_ALPN_PROTOCOLS.invokeWithoutCheckedException(sslSocket, parameters);
     }
 
-	@Override public String getSelectedProtocol(SSLSocket socket) {
-      boolean alpnSupported = GET_ALPN_SELECTED_PROTOCOL.isSupported(socket);
-      if (!alpnSupported) {
-        return null;
-      }
+    @Override public String getSelectedProtocol(SSLSocket socket) {
+      if (getAlpnSelectedProtocol == null) return null;
+      if (!getAlpnSelectedProtocol.isSupported(socket)) return null;
 
-      byte[] alpnResult =
-          (byte[]) GET_ALPN_SELECTED_PROTOCOL.invokeWithoutCheckedException(socket);
-      if (alpnResult != null) {
-        return new String(alpnResult, Util.UTF_8);
-      }
-      return null;
+      byte[] alpnResult = (byte[]) getAlpnSelectedProtocol.invokeWithoutCheckedException(socket);
+      return alpnResult != null ? new String(alpnResult, Util.UTF_8) : null;
     }
 
     @Override public void tagSocket(Socket socket) throws SocketException {
@@ -275,9 +284,7 @@ public JdkWithJettyBootPlatform(Method putMethod, Method getMethod, Method remov
         Object provider = Proxy.newProxyInstance(Platform.class.getClassLoader(),
             new Class[] { clientProviderClass, serverProviderClass }, new JettyNegoProvider(names));
         putMethod.invoke(null, sslSocket, provider);
-      } catch (InvocationTargetException e) {
-        throw new AssertionError(e);
-      } catch (IllegalAccessException e) {
+      } catch (InvocationTargetException | IllegalAccessException e) {
         throw new AssertionError(e);
       }
     }
@@ -285,9 +292,7 @@ public JdkWithJettyBootPlatform(Method putMethod, Method getMethod, Method remov
     @Override public void afterHandshake(SSLSocket sslSocket) {
       try {
         removeMethod.invoke(null, sslSocket);
-      } catch (IllegalAccessException ignored) {
-        throw new AssertionError();
-      } catch (InvocationTargetException ignored) {
+      } catch (IllegalAccessException | InvocationTargetException ignored) {
         throw new AssertionError();
       }
     }
@@ -302,9 +307,7 @@ public JdkWithJettyBootPlatform(Method putMethod, Method getMethod, Method remov
           return null;
         }
         return provider.unsupported ? null : provider.selected;
-      } catch (InvocationTargetException e) {
-        throw new AssertionError();
-      } catch (IllegalAccessException e) {
+      } catch (InvocationTargetException | IllegalAccessException e) {
         throw new AssertionError();
       }
     }
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/Util.java b/okhttp/src/main/java/com/squareup/okhttp/internal/Util.java
index 89f2d4160d..ec2fe9deb7 100755
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/Util.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/Util.java
@@ -17,7 +17,6 @@
 package com.squareup.okhttp.internal;
 
 import java.io.Closeable;
-import java.io.File;
 import java.io.IOException;
 import java.io.InterruptedIOException;
 import java.io.UnsupportedEncodingException;
@@ -149,25 +148,6 @@ public static void closeAll(Closeable a, Closeable b) throws IOException {
     throw new AssertionError(thrown);
   }
 
-  /**
-   * Deletes the contents of {@code dir}. Throws an IOException if any file
-   * could not be deleted, or if {@code dir} is not a readable directory.
-   */
-  public static void deleteContents(File dir) throws IOException {
-    File[] files = dir.listFiles();
-    if (files == null) {
-      throw new IOException("not a readable directory: " + dir);
-    }
-    for (File file : files) {
-      if (file.isDirectory()) {
-        deleteContents(file);
-      }
-      if (!file.delete()) {
-        throw new IOException("failed to delete file: " + file);
-      }
-    }
-  }
-
   /**
    * Attempts to exhaust {@code source}, returning true if successful. This is useful when reading
    * a complete source is helpful, such as when doing so completes a cache body or frees a socket
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpConnection.java b/okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpConnection.java
index d4743d2772..6bf1802c07 100755
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpConnection.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpConnection.java
@@ -22,6 +22,7 @@
 import com.squareup.okhttp.Response;
 import com.squareup.okhttp.internal.Internal;
 import com.squareup.okhttp.internal.Util;
+import java.io.EOFException;
 import java.io.IOException;
 import java.net.ProtocolException;
 import java.net.Socket;
@@ -184,23 +185,31 @@ public void writeRequest(Headers headers, String requestLine) throws IOException
       throw new IllegalStateException("state: " + state);
     }
 
-    while (true) {
-      StatusLine statusLine = StatusLine.parse(source.readUtf8LineStrict());
-
-      Response.Builder responseBuilder = new Response.Builder()
-          .protocol(statusLine.protocol)
-          .code(statusLine.code)
-          .message(statusLine.message);
-
-      Headers.Builder headersBuilder = new Headers.Builder();
-      readHeaders(headersBuilder);
-      headersBuilder.add(OkHeaders.SELECTED_PROTOCOL, statusLine.protocol.toString());
-      responseBuilder.headers(headersBuilder.build());
-
-      if (statusLine.code != HTTP_CONTINUE) {
-        state = STATE_OPEN_RESPONSE_BODY;
-        return responseBuilder;
+    try {
+      while (true) {
+        StatusLine statusLine = StatusLine.parse(source.readUtf8LineStrict());
+
+        Response.Builder responseBuilder = new Response.Builder()
+            .protocol(statusLine.protocol)
+            .code(statusLine.code)
+            .message(statusLine.message);
+
+        Headers.Builder headersBuilder = new Headers.Builder();
+        readHeaders(headersBuilder);
+        headersBuilder.add(OkHeaders.SELECTED_PROTOCOL, statusLine.protocol.toString());
+        responseBuilder.headers(headersBuilder.build());
+
+        if (statusLine.code != HTTP_CONTINUE) {
+          state = STATE_OPEN_RESPONSE_BODY;
+          return responseBuilder;
+        }
       }
+    } catch (EOFException e) {
+      // Provide more context if the server ends the stream before sending a response.
+      IOException exception = new IOException("unexpected end of stream on " + connection
+          + " (recycle count=" + Internal.instance.recycleCount(connection) + ")");
+      exception.initCause(e);
+      throw exception;
     }
   }
 
@@ -285,21 +294,12 @@ private FixedLengthSink(long bytesRemaining) {
     }
   }
 
-  private static final byte[] CRLF = { '\r', '\n' };
-  private static final byte[] HEX_DIGITS = {
-      '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f'
-  };
-  private static final byte[] FINAL_CHUNK = { '0', '\r', '\n', '\r', '\n' };
-
   /**
    * An HTTP body with alternating chunk sizes and chunk bodies. It is the
    * caller's responsibility to buffer chunks; typically by using a buffered
    * sink with this sink.
    */
   private final class ChunkedSink implements Sink {
-    /** Scratch space for up to 16 hex digits, and then a constant CRLF. */
-    private final byte[] hex = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, '\r', '\n' };
-
     private boolean closed;
 
     @Override public Timeout timeout() {
@@ -310,9 +310,10 @@ private FixedLengthSink(long bytesRemaining) {
       if (closed) throw new IllegalStateException("closed");
       if (byteCount == 0) return;
 
-      writeHex(byteCount);
+      sink.writeHexadecimalUnsignedLong(byteCount);
+      sink.writeUtf8("\r\n");
       sink.write(source, byteCount);
-      sink.write(CRLF);
+      sink.writeUtf8("\r\n");
     }
 
     @Override public synchronized void flush() throws IOException {
@@ -323,21 +324,9 @@ private FixedLengthSink(long bytesRemaining) {
     @Override public synchronized void close() throws IOException {
       if (closed) return;
       closed = true;
-      sink.write(FINAL_CHUNK);
+      sink.writeUtf8("0\r\n\r\n");
       state = STATE_READ_RESPONSE_HEADERS;
     }
-
-    /**
-     * Equivalent to, but cheaper than writing Long.toHexString().getBytes()
-     * followed by CRLF.
-     */
-    private void writeHex(long i) throws IOException {
-      int cursor = 16;
-      do {
-        hex[--cursor] = HEX_DIGITS[((int) (i & 0xf))];
-      } while ((i >>>= 4) != 0);
-      sink.write(hex, cursor, hex.length - cursor);
-    }
   }
 
   private abstract class AbstractSource implements Source {
@@ -425,8 +414,8 @@ public FixedLengthSource(long length) throws IOException {
 
   /** An HTTP body with alternating chunk sizes and chunk bodies. */
   private class ChunkedSource extends AbstractSource {
-    private static final int NO_CHUNK_YET = -1;
-    private int bytesRemainingInChunk = NO_CHUNK_YET;
+    private static final long NO_CHUNK_YET = -1L;
+    private long bytesRemainingInChunk = NO_CHUNK_YET;
     private boolean hasMoreChunks = true;
     private final HttpEngine httpEngine;
 
@@ -458,17 +447,17 @@ private void readChunkSize() throws IOException {
       if (bytesRemainingInChunk != NO_CHUNK_YET) {
         source.readUtf8LineStrict();
       }
-      String chunkSizeString = source.readUtf8LineStrict();
-      int index = chunkSizeString.indexOf(";");
-      if (index != -1) {
-        chunkSizeString = chunkSizeString.substring(0, index);
-      }
       try {
-        bytesRemainingInChunk = Integer.parseInt(chunkSizeString.trim(), 16);
+        bytesRemainingInChunk = source.readHexadecimalUnsignedLong();
+        String extensions = source.readUtf8LineStrict().trim();
+        if (bytesRemainingInChunk < 0 || (!extensions.isEmpty() && !extensions.startsWith(";"))) {
+          throw new ProtocolException("expected chunk size and optional extensions but was \""
+              + bytesRemainingInChunk + extensions + "\"");
+        }
       } catch (NumberFormatException e) {
-        throw new ProtocolException("Expected a hex chunk size but was " + chunkSizeString);
+        throw new ProtocolException(e.getMessage());
       }
-      if (bytesRemainingInChunk == 0) {
+      if (bytesRemainingInChunk == 0L) {
         hasMoreChunks = false;
         Headers.Builder trailersBuilder = new Headers.Builder();
         readHeaders(trailersBuilder);
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpEngine.java b/okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpEngine.java
index d3ddef239c..09d27b0722 100755
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpEngine.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpEngine.java
@@ -812,6 +812,9 @@ public void readResponse() throws IOException {
 
       transport.writeRequestHeaders(request);
 
+      //Update the networkRequest with the possibly updated interceptor request.
+      networkRequest = request;
+
       if (permitsRequestBody() && request.body() != null) {
         Sink requestBodyOut = transport.createRequestBody(request, request.body().contentLength());
         BufferedSink bufferedRequestBody = Okio.buffer(requestBodyOut);
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/http/RouteSelector.java b/okhttp/src/main/java/com/squareup/okhttp/internal/http/RouteSelector.java
index 6b444559a4..eb2a63e89a 100755
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/http/RouteSelector.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/http/RouteSelector.java
@@ -30,7 +30,6 @@
 import java.net.SocketAddress;
 import java.net.SocketException;
 import java.net.URI;
-import java.net.UnknownHostException;
 import java.net.UnknownServiceException;
 import java.util.ArrayList;
 import java.util.Collections;
@@ -196,7 +195,7 @@ private Proxy nextProxy() throws IOException {
   }
 
   /** Prepares the socket addresses to attempt for the current proxy or host. */
-  private void resetNextInetSocketAddress(Proxy proxy) throws UnknownHostException {
+  private void resetNextInetSocketAddress(Proxy proxy) throws IOException {
     // Clear the addresses. Necessary if getAllByName() below throws!
     inetSocketAddresses = new ArrayList<InetSocketAddress>();
 
@@ -216,6 +215,11 @@ private void resetNextInetSocketAddress(Proxy proxy) throws UnknownHostException
       socketPort = proxySocketAddress.getPort();
     }
 
+    if (socketPort < 1 || socketPort > 65535) {
+      throw new SocketException("No route to " + socketHost + ":" + socketPort
+          + "; port is out of range");
+    }
+
     // Try each address for best behavior in mixed IPv4/IPv6 environments.
     for (InetAddress inetAddress : network.resolveInetAddresses(socketHost)) {
       inetSocketAddresses.add(new InetSocketAddress(inetAddress, socketPort));
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/io/FileSystem.java b/okhttp/src/main/java/com/squareup/okhttp/internal/io/FileSystem.java
new file mode 100644
index 0000000000..74245997a5
--- /dev/null
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/io/FileSystem.java
@@ -0,0 +1,137 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.okhttp.internal.io;
+
+import java.io.File;
+import java.io.FileNotFoundException;
+import java.io.IOException;
+import okio.Okio;
+import okio.Sink;
+import okio.Source;
+
+/**
+ * Access to read and write files on a hierarchical data store. Most callers should use the {@link
+ * #SYSTEM} implementation, which uses the host machine's local file system. Alternate
+ * implementations may be used to inject faults (for testing) or to transform stored data (to add
+ * encryption, for example).
+ *
+ * <p>All operations on a file system are racy. For example, guarding a call to {@link #source}
+ * with {@link #exists} does not guarantee that {@link FileNotFoundException} will not be thrown.
+ * The file may be moved between the two calls!
+ *
+ * <p>This interface is less ambitious than {@link java.nio.file.FileSystem} introduced in Java 7.
+ * It lacks important features like file watching, metadata, permissions, and disk space
+ * information. In exchange for these limitations, this interface is easier to implement and works
+ * on all versions of Java and Android.
+ */
+public interface FileSystem {
+  /** The host machine's local file system. */
+  FileSystem SYSTEM = new FileSystem() {
+    @Override public Source source(File file) throws FileNotFoundException {
+      return Okio.source(file);
+    }
+
+    @Override public Sink sink(File file) throws FileNotFoundException {
+      try {
+        return Okio.sink(file);
+      } catch (FileNotFoundException e) {
+        // Maybe the parent directory doesn't exist? Try creating it first.
+        file.getParentFile().mkdirs();
+        return Okio.sink(file);
+      }
+    }
+
+    @Override public Sink appendingSink(File file) throws FileNotFoundException {
+      try {
+        return Okio.appendingSink(file);
+      } catch (FileNotFoundException e) {
+        // Maybe the parent directory doesn't exist? Try creating it first.
+        file.getParentFile().mkdirs();
+        return Okio.appendingSink(file);
+      }
+    }
+
+    @Override public void delete(File file) throws IOException {
+      // If delete() fails, make sure it's because the file didn't exist!
+      if (!file.delete() && file.exists()) {
+        throw new IOException("failed to delete " + file);
+      }
+    }
+
+    @Override public boolean exists(File file) throws IOException {
+      return file.exists();
+    }
+
+    @Override public long size(File file) {
+      return file.length();
+    }
+
+    @Override public void rename(File from, File to) throws IOException {
+      delete(to);
+      if (!from.renameTo(to)) {
+        throw new IOException("failed to rename " + from + " to " + to);
+      }
+    }
+
+    @Override public void deleteContents(File directory) throws IOException {
+      File[] files = directory.listFiles();
+      if (files == null) {
+        throw new IOException("not a readable directory: " + directory);
+      }
+      for (File file : files) {
+        if (file.isDirectory()) {
+          deleteContents(file);
+        }
+        if (!file.delete()) {
+          throw new IOException("failed to delete " + file);
+        }
+      }
+    }
+  };
+
+  /** Reads from {@code file}. */
+  Source source(File file) throws FileNotFoundException;
+
+  /**
+   * Writes to {@code file}, discarding any data already present. Creates parent directories if
+   * necessary.
+   */
+  Sink sink(File file) throws FileNotFoundException;
+
+  /**
+   * Writes to {@code file}, appending if data is already present. Creates parent directories if
+   * necessary.
+   */
+  Sink appendingSink(File file) throws FileNotFoundException;
+
+  /** Deletes {@code file} if it exists. Throws if the file exists and cannot be deleted. */
+  void delete(File file) throws IOException;
+
+  /** Returns true if {@code file} exists on the file system. */
+  boolean exists(File file) throws IOException;
+
+  /** Returns the number of bytes stored in {@code file}, or 0 if it does not exist. */
+  long size(File file);
+
+  /** Renames {@code from} to {@code to}. Throws if the file cannot be renamed. */
+  void rename(File from, File to) throws IOException;
+
+  /**
+   * Recursively delete the contents of {@code directory}. Throws an IOException if any file could
+   * not be deleted, or if {@code dir} is not a readable directory.
+   */
+  void deleteContents(File directory) throws IOException;
+}
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/ErrorCode.java b/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/ErrorCode.java
index b5f46b8bee..701de92d64 100755
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/ErrorCode.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/ErrorCode.java
@@ -15,7 +15,7 @@
  */
 package com.squareup.okhttp.internal.spdy;
 
-// http://tools.ietf.org/html/draft-ietf-httpbis-http2-16#section-7
+// http://tools.ietf.org/html/draft-ietf-httpbis-http2-17#section-7
 public enum ErrorCode {
   /** Not an error! For SPDY stream resets, prefer null over NO_ERROR. */
   NO_ERROR(0, -1, 0),
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/HpackDraft10.java b/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/Hpack.java
similarity index 99%
rename from okhttp/src/main/java/com/squareup/okhttp/internal/spdy/HpackDraft10.java
rename to okhttp/src/main/java/com/squareup/okhttp/internal/spdy/Hpack.java
index a8a0d4dbdb..3612c6f6d9 100755
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/HpackDraft10.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/Hpack.java
@@ -31,13 +31,13 @@
 /**
  * Read and write HPACK v10.
  *
- * http://tools.ietf.org/html/draft-ietf-httpbis-header-compression-10
+ * http://tools.ietf.org/html/draft-ietf-httpbis-header-compression-12
  *
  * This implementation uses an array for the dynamic table and a list for
  * indexed entries.  Dynamic entries are added to the array, starting in the
  * last position moving forward.  When the array fills, it is doubled.
  */
-final class HpackDraft10 {
+final class Hpack {
   private static final int PREFIX_4_BITS = 0x0f;
   private static final int PREFIX_5_BITS = 0x1f;
   private static final int PREFIX_6_BITS = 0x3f;
@@ -107,10 +107,10 @@
       new Header("www-authenticate", "")
   };
 
-  private HpackDraft10() {
+  private Hpack() {
   }
 
-  // http://tools.ietf.org/html/draft-ietf-httpbis-header-compression-10#section-3.1
+  // http://tools.ietf.org/html/draft-ietf-httpbis-header-compression-12#section-3.1
   static final class Reader {
 
     private final List<Header> headerList = new ArrayList<Header>();
@@ -374,7 +374,7 @@ ByteString readByteString() throws IOException {
     }
 
     /** This does not use "never indexed" semantics for sensitive headers. */
-    // http://tools.ietf.org/html/draft-ietf-httpbis-header-compression-10#section-6.2.3
+    // http://tools.ietf.org/html/draft-ietf-httpbis-header-compression-12#section-6.2.3
     void writeHeaders(List<Header> headerBlock) throws IOException {
       // TODO: implement index tracking
       for (int i = 0, size = headerBlock.size(); i < size; i++) {
@@ -392,7 +392,7 @@ void writeHeaders(List<Header> headerBlock) throws IOException {
       }
     }
 
-    // http://tools.ietf.org/html/draft-ietf-httpbis-header-compression-10#section-4.1.1
+    // http://tools.ietf.org/html/draft-ietf-httpbis-header-compression-12#section-4.1.1
     void writeInt(int value, int prefixMask, int bits) throws IOException {
       // Write the raw value for a single byte value.
       if (value < prefixMask) {
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/Http20Draft16.java b/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/Http2.java
similarity index 98%
rename from okhttp/src/main/java/com/squareup/okhttp/internal/spdy/Http20Draft16.java
rename to okhttp/src/main/java/com/squareup/okhttp/internal/spdy/Http2.java
index 3b6095ce0a..34b0df48fc 100755
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/Http20Draft16.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/Http2.java
@@ -26,20 +26,20 @@
 import okio.Source;
 import okio.Timeout;
 
-import static com.squareup.okhttp.internal.spdy.Http20Draft16.FrameLogger.formatHeader;
+import static com.squareup.okhttp.internal.spdy.Http2.FrameLogger.formatHeader;
 import static java.lang.String.format;
 import static java.util.logging.Level.FINE;
 import static okio.ByteString.EMPTY;
 
 /**
- * Read and write HTTP/2 v16 frames.
+ * Read and write HTTP/2 frames.
  * <p>
  * This implementation assumes we do not send an increased
  * {@link Settings#getMaxFrameSize frame size setting} to the peer. Hence, we
  * expect all frames to have a max length of {@link #INITIAL_MAX_FRAME_SIZE}.
- * <p>http://tools.ietf.org/html/draft-ietf-httpbis-http2-16
+ * <p>http://tools.ietf.org/html/draft-ietf-httpbis-http2-17
  */
-public final class Http20Draft16 implements Variant {
+public final class Http2 implements Variant {
   private static final Logger logger = Logger.getLogger(FrameLogger.class.getName());
 
   @Override public Protocol getProtocol() {
@@ -90,13 +90,13 @@
     private final boolean client;
 
     // Visible for testing.
-    final HpackDraft10.Reader hpackReader;
+    final Hpack.Reader hpackReader;
 
     Reader(BufferedSource source, int headerTableSize, boolean client) {
       this.source = source;
       this.client = client;
       this.continuation = new ContinuationSource(this.source);
-      this.hpackReader = new HpackDraft10.Reader(headerTableSize, continuation);
+      this.hpackReader = new Hpack.Reader(headerTableSize, continuation);
     }
 
     @Override public void readConnectionPreface() throws IOException {
@@ -208,7 +208,7 @@ private void readHeaders(Handler handler, int length, byte flags, int streamId)
       continuation.streamId = streamId;
 
       // TODO: Concat multi-value headers with 0x0, except COOKIE, which uses 0x3B, 0x20.
-      // http://tools.ietf.org/html/draft-ietf-httpbis-http2-16#section-8.1.2.5
+      // http://tools.ietf.org/html/draft-ietf-httpbis-http2-17#section-8.1.2.5
       hpackReader.readHeaders();
       return hpackReader.getAndResetHeaderList();
     }
@@ -364,7 +364,7 @@ private void readWindowUpdate(Handler handler, int length, byte flags, int strea
     private final BufferedSink sink;
     private final boolean client;
     private final Buffer hpackBuffer;
-    private final HpackDraft10.Writer hpackWriter;
+    private final Hpack.Writer hpackWriter;
     private int maxFrameSize;
     private boolean closed;
 
@@ -372,7 +372,7 @@ private void readWindowUpdate(Handler handler, int length, byte flags, int strea
       this.sink = sink;
       this.client = client;
       this.hpackBuffer = new Buffer();
-      this.hpackWriter = new HpackDraft10.Writer(hpackBuffer);
+      this.hpackWriter = new Hpack.Writer(hpackBuffer);
       this.maxFrameSize = INITIAL_MAX_FRAME_SIZE;
     }
 
@@ -589,7 +589,7 @@ private static IOException ioException(String message, Object... args) throws IO
   /**
    * Decompression of the header block occurs above the framing layer. This
    * class lazily reads continuation frames as they are needed by {@link
-   * HpackDraft10.Reader#readHeaders()}.
+   * Hpack.Reader#readHeaders()}.
    */
   static final class ContinuationSource implements Source {
     private final BufferedSource source;
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/Huffman.java b/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/Huffman.java
index 298087bf21..06d5243d7e 100755
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/Huffman.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/Huffman.java
@@ -31,7 +31,7 @@
 class Huffman {
 
   // Appendix C: Huffman Codes
-  // http://tools.ietf.org/html/draft-ietf-httpbis-header-compression-10#appendix-B
+  // http://tools.ietf.org/html/draft-ietf-httpbis-header-compression-12#appendix-B
   private static final int[] CODES = {
       0x1ff8, 0x7fffd8, 0xfffffe2, 0xfffffe3, 0xfffffe4, 0xfffffe5, 0xfffffe6, 0xfffffe7, 0xfffffe8,
       0xffffea, 0x3ffffffc, 0xfffffe9, 0xfffffea, 0x3ffffffd, 0xfffffeb, 0xfffffec, 0xfffffed,
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/SpdyConnection.java b/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/SpdyConnection.java
index ca594e2881..ee3f288c91 100755
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/SpdyConnection.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/SpdyConnection.java
@@ -131,7 +131,7 @@ private SpdyConnection(Builder builder) throws IOException {
     pushObserver = builder.pushObserver;
     client = builder.client;
     handler = builder.handler;
-    // http://tools.ietf.org/html/draft-ietf-httpbis-http2-16#section-5.1.1
+    // http://tools.ietf.org/html/draft-ietf-httpbis-http2-17#section-5.1.1
     nextStreamId = builder.client ? 1 : 2;
     if (builder.client && protocol == Protocol.HTTP_2) {
       nextStreamId += 2; // In HTTP/2, 1 on client is reserved for Upgrade.
@@ -150,14 +150,14 @@ private SpdyConnection(Builder builder) throws IOException {
     hostName = builder.hostName;
 
     if (protocol == Protocol.HTTP_2) {
-      variant = new Http20Draft16();
+      variant = new Http2();
       // Like newSingleThreadExecutor, except lazy creates the thread.
       pushExecutor = new ThreadPoolExecutor(0, 1, 60, TimeUnit.SECONDS,
           new LinkedBlockingQueue<Runnable>(),
           Util.threadFactory(String.format("OkHttp %s Push Observer", hostName), true));
-      // 1 less than SPDY http://tools.ietf.org/html/draft-ietf-httpbis-http2-16#section-6.9.2
+      // 1 less than SPDY http://tools.ietf.org/html/draft-ietf-httpbis-http2-17#section-6.9.2
       peerSettings.set(Settings.INITIAL_WINDOW_SIZE, 0, 65535);
-      peerSettings.set(Settings.MAX_FRAME_SIZE, 0, Http20Draft16.INITIAL_MAX_FRAME_SIZE);
+      peerSettings.set(Settings.MAX_FRAME_SIZE, 0, Http2.INITIAL_MAX_FRAME_SIZE);
     } else if (protocol == Protocol.SPDY_3) {
       variant = new Spdy3();
       pushExecutor = null;
@@ -352,7 +352,7 @@ void writeSynReset(int streamId, ErrorCode statusCode) throws IOException {
   }
 
   void writeWindowUpdateLater(final int streamId, final long unacknowledgedBytesRead) {
-    executor.submit(new NamedRunnable("OkHttp Window Update %s stream %d", hostName, streamId) {
+    executor.execute(new NamedRunnable("OkHttp Window Update %s stream %d", hostName, streamId) {
       @Override public void execute() {
         try {
           frameWriter.windowUpdate(streamId, unacknowledgedBytesRead);
@@ -384,7 +384,7 @@ public Ping ping() throws IOException {
 
   private void writePingLater(
       final boolean reply, final int payload1, final int payload2, final Ping ping) {
-    executor.submit(new NamedRunnable("OkHttp %s ping %08x%08x",
+    executor.execute(new NamedRunnable("OkHttp %s ping %08x%08x",
         hostName, payload1, payload2) {
       @Override public void execute() {
         try {
@@ -636,7 +636,7 @@ private Reader() {
               inFinished, headerBlock);
           lastGoodStreamId = streamId;
           streams.put(streamId, newStream);
-          executor.submit(new NamedRunnable("OkHttp %s stream %d", hostName, streamId) {
+          executor.execute(new NamedRunnable("OkHttp %s stream %d", hostName, streamId) {
             @Override public void execute() {
               try {
                 handler.receive(newStream);
@@ -704,7 +704,7 @@ private Reader() {
     }
 
     private void ackSettingsLater(final Settings peerSettings) {
-      executor.submit(new NamedRunnable("OkHttp %s ACK Settings", hostName) {
+      executor.execute(new NamedRunnable("OkHttp %s ACK Settings", hostName) {
         @Override public void execute() {
           try {
             frameWriter.ackSettings(peerSettings);
@@ -798,7 +798,7 @@ private void pushRequestLater(final int streamId, final List<Header> requestHead
       }
       currentPushRequests.add(streamId);
     }
-    pushExecutor.submit(new NamedRunnable("OkHttp %s Push Request[%s]", hostName, streamId) {
+    pushExecutor.execute(new NamedRunnable("OkHttp %s Push Request[%s]", hostName, streamId) {
       @Override public void execute() {
         boolean cancel = pushObserver.onRequest(streamId, requestHeaders);
         try {
@@ -816,7 +816,7 @@ private void pushRequestLater(final int streamId, final List<Header> requestHead
 
   private void pushHeadersLater(final int streamId, final List<Header> requestHeaders,
       final boolean inFinished) {
-    pushExecutor.submit(new NamedRunnable("OkHttp %s Push Headers[%s]", hostName, streamId) {
+    pushExecutor.execute(new NamedRunnable("OkHttp %s Push Headers[%s]", hostName, streamId) {
       @Override public void execute() {
         boolean cancel = pushObserver.onHeaders(streamId, requestHeaders, inFinished);
         try {
@@ -842,7 +842,7 @@ private void pushDataLater(final int streamId, final BufferedSource source, fina
     source.require(byteCount); // Eagerly read the frame before firing client thread.
     source.read(buffer, byteCount);
     if (buffer.size() != byteCount) throw new IOException(buffer.size() + " != " + byteCount);
-    pushExecutor.submit(new NamedRunnable("OkHttp %s Push Data[%s]", hostName, streamId) {
+    pushExecutor.execute(new NamedRunnable("OkHttp %s Push Data[%s]", hostName, streamId) {
       @Override public void execute() {
         try {
           boolean cancel = pushObserver.onData(streamId, buffer, byteCount, inFinished);
@@ -859,7 +859,7 @@ private void pushDataLater(final int streamId, final BufferedSource source, fina
   }
 
   private void pushResetLater(final int streamId, final ErrorCode errorCode) {
-    pushExecutor.submit(new NamedRunnable("OkHttp %s Push Reset[%s]", hostName, streamId) {
+    pushExecutor.execute(new NamedRunnable("OkHttp %s Push Reset[%s]", hostName, streamId) {
       @Override public void execute() {
         pushObserver.onReset(streamId, errorCode);
         synchronized (SpdyConnection.this) {
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/SpdyStream.java b/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/SpdyStream.java
index 1074a42067..82917ed71f 100755
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/SpdyStream.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/SpdyStream.java
@@ -53,7 +53,6 @@
 
   private final int id;
   private final SpdyConnection connection;
-  private long readTimeoutMillis = 0;
 
   /** Headers sent by the stream initiator. Immutable and non null. */
   private final List<Header> requestHeaders;
@@ -468,6 +467,14 @@ private void cancelStreamIfNecessary() throws IOException {
    * thread safe.
    */
   final class SpdyDataSink implements Sink {
+    private static final long EMIT_BUFFER_SIZE = 16384;
+
+    /**
+     * Buffer of outgoing data. This batches writes of small writes into this sink as larges
+     * frames written to the outgoing connection. Batching saves the (small) framing overhead.
+     */
+    private final Buffer sendBuffer = new Buffer();
+
     private boolean closed;
 
     /**
@@ -478,26 +485,34 @@ private void cancelStreamIfNecessary() throws IOException {
 
     @Override public void write(Buffer source, long byteCount) throws IOException {
       assert (!Thread.holdsLock(SpdyStream.this));
-      while (byteCount > 0) {
-        long toWrite;
-        synchronized (SpdyStream.this) {
-          writeTimeout.enter();
-          try {
-            while (bytesLeftInWriteWindow <= 0 && !finished && !closed && errorCode == null) {
-              waitForIo(); // Wait until we receive a WINDOW_UPDATE.
-            }
-          } finally {
-            writeTimeout.exitAndThrowIfTimedOut();
-          }
+      sendBuffer.write(source, byteCount);
+      while (sendBuffer.size() >= EMIT_BUFFER_SIZE) {
+        emitDataFrame(false);
+      }
+    }
 
-          checkOutNotClosed(); // Kick out if the stream was reset or closed while waiting.
-          toWrite = Math.min(bytesLeftInWriteWindow, byteCount);
-          bytesLeftInWriteWindow -= toWrite;
+    /**
+     * Emit a single data frame to the connection. The frame's size be limited by this stream's
+     * write window. This method will block until the write window is nonempty.
+     */
+    private void emitDataFrame(boolean outFinished) throws IOException {
+      long toWrite;
+      synchronized (SpdyStream.this) {
+        writeTimeout.enter();
+        try {
+          while (bytesLeftInWriteWindow <= 0 && !finished && !closed && errorCode == null) {
+            waitForIo(); // Wait until we receive a WINDOW_UPDATE.
+          }
+        } finally {
+          writeTimeout.exitAndThrowIfTimedOut();
         }
 
-        byteCount -= toWrite;
-        connection.writeData(id, false, source, toWrite);
+        checkOutNotClosed(); // Kick out if the stream was reset or closed while waiting.
+        toWrite = Math.min(bytesLeftInWriteWindow, sendBuffer.size());
+        bytesLeftInWriteWindow -= toWrite;
       }
+
+      connection.writeData(id, outFinished && toWrite == sendBuffer.size(), sendBuffer, toWrite);
     }
 
     @Override public void flush() throws IOException {
@@ -505,6 +520,9 @@ private void cancelStreamIfNecessary() throws IOException {
       synchronized (SpdyStream.this) {
         checkOutNotClosed();
       }
+      while (sendBuffer.size() > 0) {
+        emitDataFrame(false);
+      }
       connection.flush();
     }
 
@@ -518,7 +536,15 @@ private void cancelStreamIfNecessary() throws IOException {
         if (closed) return;
       }
       if (!sink.finished) {
-        connection.writeData(id, true, null, 0);
+        // Emit the remaining data, setting the END_STREAM flag on the last frame.
+        if (sendBuffer.size() > 0) {
+          while (sendBuffer.size() > 0) {
+            emitDataFrame(true);
+          }
+        } else {
+          // Send an empty frame just so we can set the END_STREAM flag.
+          connection.writeData(id, true, null, 0);
+        }
       }
       synchronized (SpdyStream.this) {
         closed = true;
diff --git a/pom.xml b/pom.xml
index 99f508638d..7c641fdbfd 100644
--- a/pom.xml
+++ b/pom.xml
@@ -11,7 +11,7 @@
 
   <groupId>com.squareup.okhttp</groupId>
   <artifactId>parent</artifactId>
-  <version>2.3.0-SNAPSHOT</version>
+  <version>2.4.0-SNAPSHOT</version>
   <packaging>pom</packaging>
 
   <name>OkHttp (Parent)</name>
@@ -20,10 +20,16 @@
 
   <modules>
     <module>okhttp</module>
-    <module>okhttp-apache</module>
     <module>okhttp-tests</module>
-    <module>okhttp-urlconnection</module>
+
     <module>okhttp-android-support</module>
+
+    <module>okhttp-apache</module>
+    <module>okhttp-urlconnection</module>
+
+    <module>okhttp-ws</module>
+    <module>okhttp-ws-tests</module>
+
     <module>okcurl</module>
     <module>mockwebserver</module>
     
@@ -35,7 +41,8 @@
 
     <!-- Compilation -->
     <java.version>1.6</java.version>
-    <okio.version>1.2.0</okio.version>
+    <okio.version>1.3.0</okio.version>
+
     <!-- ALPN library targeted to Java 7 -->
     <alpn.jdk7.version>7.1.2.v20141202</alpn.jdk7.version>
     <!-- ALPN library targeted to Java 8 update 25. -->
diff --git a/samples/crawler/pom.xml b/samples/crawler/pom.xml
index 2be2bab302..59f51d38ed 100644
--- a/samples/crawler/pom.xml
+++ b/samples/crawler/pom.xml
@@ -6,7 +6,7 @@
   <parent>
     <groupId>com.squareup.okhttp.sample</groupId>
     <artifactId>sample-parent</artifactId>
-    <version>2.3.0-SNAPSHOT</version>
+    <version>2.4.0-SNAPSHOT</version>
   </parent>
 
   <artifactId>crawler</artifactId>
diff --git a/samples/crawler/src/main/java/com/squareup/okhttp/sample/Crawler.java b/samples/crawler/src/main/java/com/squareup/okhttp/sample/Crawler.java
index 24383fe47e..21d11c7c31 100644
--- a/samples/crawler/src/main/java/com/squareup/okhttp/sample/Crawler.java
+++ b/samples/crawler/src/main/java/com/squareup/okhttp/sample/Crawler.java
@@ -19,6 +19,7 @@
 import com.squareup.okhttp.OkHttpClient;
 import com.squareup.okhttp.Request;
 import com.squareup.okhttp.Response;
+import com.squareup.okhttp.internal.NamedRunnable;
 import java.io.File;
 import java.io.IOException;
 import java.net.MalformedURLException;
@@ -26,9 +27,11 @@
 import java.util.Collections;
 import java.util.LinkedHashSet;
 import java.util.Set;
+import java.util.concurrent.ConcurrentHashMap;
 import java.util.concurrent.ExecutorService;
 import java.util.concurrent.Executors;
 import java.util.concurrent.LinkedBlockingQueue;
+import java.util.concurrent.atomic.AtomicInteger;
 import org.jsoup.Jsoup;
 import org.jsoup.nodes.Document;
 import org.jsoup.nodes.Element;
@@ -40,6 +43,7 @@
   private final OkHttpClient client;
   private final Set<URL> fetchedUrls = Collections.synchronizedSet(new LinkedHashSet<URL>());
   private final LinkedBlockingQueue<URL> queue = new LinkedBlockingQueue<>();
+  private final ConcurrentHashMap<String, AtomicInteger> hostnames = new ConcurrentHashMap<>();
 
   public Crawler(OkHttpClient client) {
     this.client = client;
@@ -48,8 +52,8 @@ public Crawler(OkHttpClient client) {
   private void parallelDrainQueue(int threadCount) {
     ExecutorService executor = Executors.newFixedThreadPool(threadCount);
     for (int i = 0; i < threadCount; i++) {
-      executor.execute(new Runnable() {
-        @Override public void run() {
+      executor.execute(new NamedRunnable("Crawler %s", i) {
+        @Override protected void execute() {
           try {
             drainQueue();
           } catch (Exception e) {
@@ -76,12 +80,18 @@ private void drainQueue() throws Exception {
   }
 
   public void fetch(URL url) throws IOException {
+    // Skip hosts that we've visited many times.
+    AtomicInteger hostnameCount = new AtomicInteger();
+    AtomicInteger previous = hostnames.putIfAbsent(url.getHost(), hostnameCount);
+    if (previous != null) hostnameCount = previous;
+    if (hostnameCount.incrementAndGet() > 100) return;
+
     Request request = new Request.Builder()
         .url(url)
         .build();
     Response response = client.newCall(request).execute();
     String responseSource = response.networkResponse() != null
-        ? ("(network: " + response.networkResponse().code() + ")")
+        ? ("(network: " + response.networkResponse().code() + " over " + response.protocol() + ")")
         : "(cache)";
     int responseCode = response.code();
 
@@ -96,7 +106,7 @@ public void fetch(URL url) throws IOException {
     Document document = Jsoup.parse(response.body().string(), url.toString());
     for (Element element : document.select("a[href]")) {
       String href = element.attr("href");
-      URL link = parseUrl(url, href);
+      URL link = parseUrl(response.request().url(), href);
       if (link != null) queue.add(link);
     }
   }
diff --git a/samples/guide/pom.xml b/samples/guide/pom.xml
index 1cc1b6a5ee..299b065afe 100644
--- a/samples/guide/pom.xml
+++ b/samples/guide/pom.xml
@@ -6,7 +6,7 @@
   <parent>
     <groupId>com.squareup.okhttp.sample</groupId>
     <artifactId>sample-parent</artifactId>
-    <version>2.3.0-SNAPSHOT</version>
+    <version>2.4.0-SNAPSHOT</version>
   </parent>
 
   <artifactId>guide</artifactId>
@@ -18,6 +18,11 @@
       <artifactId>okhttp</artifactId>
       <version>${project.version}</version>
     </dependency>
+    <dependency>
+      <groupId>com.squareup.okhttp</groupId>
+      <artifactId>okhttp-ws</artifactId>
+      <version>${project.version}</version>
+    </dependency>
     <dependency>
       <groupId>com.google.code.gson</groupId>
       <artifactId>gson</artifactId>
diff --git a/samples/guide/src/main/java/com/squareup/okhttp/recipes/CustomTrust.java b/samples/guide/src/main/java/com/squareup/okhttp/recipes/CustomTrust.java
new file mode 100644
index 0000000000..f99dc627a9
--- /dev/null
+++ b/samples/guide/src/main/java/com/squareup/okhttp/recipes/CustomTrust.java
@@ -0,0 +1,206 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.okhttp.recipes;
+
+import com.squareup.okhttp.CertificatePinner;
+import com.squareup.okhttp.Headers;
+import com.squareup.okhttp.OkHttpClient;
+import com.squareup.okhttp.Request;
+import com.squareup.okhttp.Response;
+import java.io.IOException;
+import java.io.InputStream;
+import java.security.GeneralSecurityException;
+import java.security.KeyStore;
+import java.security.SecureRandom;
+import java.security.cert.Certificate;
+import java.security.cert.CertificateFactory;
+import java.util.Collection;
+import javax.net.ssl.KeyManagerFactory;
+import javax.net.ssl.SSLContext;
+import javax.net.ssl.TrustManagerFactory;
+import okio.Buffer;
+
+public final class CustomTrust {
+  private final OkHttpClient client;
+
+  public CustomTrust() {
+    client = new OkHttpClient();
+    SSLContext sslContext = sslContextForTrustedCertificates(trustedCertificatesInputStream());
+    client.setSslSocketFactory(sslContext.getSocketFactory());
+  }
+
+  public void run() throws Exception {
+    Request request = new Request.Builder()
+        .url("https://publicobject.com/helloworld.txt")
+        .build();
+
+    Response response = client.newCall(request).execute();
+    if (!response.isSuccessful()) throw new IOException("Unexpected code " + response);
+
+    Headers responseHeaders = response.headers();
+    for (int i = 0; i < responseHeaders.size(); i++) {
+      System.out.println(responseHeaders.name(i) + ": " + responseHeaders.value(i));
+    }
+
+    System.out.println(response.body().string());
+  }
+
+  /**
+   * Returns an input stream containing one or more certificate PEM files. This implementation just
+   * embeds the PEM files in Java strings; most applications will instead read this from a resource
+   * file that gets bundled with the application.
+   */
+  private InputStream trustedCertificatesInputStream() {
+    // PEM files for root certificates of Comodo and Entrust. These two CAs are sufficient to view
+    // https://publicobject.com (Comodo) and https://squareup.com (Entrust). But they aren't
+    // sufficient to connect to most HTTPS sites including https://godaddy.com and https://visa.com.
+    // Typically developers will need to get a PEM file from their organization's TLS administrator.
+    String comodoRsaCertificationAuthority = ""
+        + "-----BEGIN CERTIFICATE-----\n"
+        + "MIIF2DCCA8CgAwIBAgIQTKr5yttjb+Af907YWwOGnTANBgkqhkiG9w0BAQwFADCB\n"
+        + "hTELMAkGA1UEBhMCR0IxGzAZBgNVBAgTEkdyZWF0ZXIgTWFuY2hlc3RlcjEQMA4G\n"
+        + "A1UEBxMHU2FsZm9yZDEaMBgGA1UEChMRQ09NT0RPIENBIExpbWl0ZWQxKzApBgNV\n"
+        + "BAMTIkNPTU9ETyBSU0EgQ2VydGlmaWNhdGlvbiBBdXRob3JpdHkwHhcNMTAwMTE5\n"
+        + "MDAwMDAwWhcNMzgwMTE4MjM1OTU5WjCBhTELMAkGA1UEBhMCR0IxGzAZBgNVBAgT\n"
+        + "EkdyZWF0ZXIgTWFuY2hlc3RlcjEQMA4GA1UEBxMHU2FsZm9yZDEaMBgGA1UEChMR\n"
+        + "Q09NT0RPIENBIExpbWl0ZWQxKzApBgNVBAMTIkNPTU9ETyBSU0EgQ2VydGlmaWNh\n"
+        + "dGlvbiBBdXRob3JpdHkwggIiMA0GCSqGSIb3DQEBAQUAA4ICDwAwggIKAoICAQCR\n"
+        + "6FSS0gpWsawNJN3Fz0RndJkrN6N9I3AAcbxT38T6KhKPS38QVr2fcHK3YX/JSw8X\n"
+        + "pz3jsARh7v8Rl8f0hj4K+j5c+ZPmNHrZFGvnnLOFoIJ6dq9xkNfs/Q36nGz637CC\n"
+        + "9BR++b7Epi9Pf5l/tfxnQ3K9DADWietrLNPtj5gcFKt+5eNu/Nio5JIk2kNrYrhV\n"
+        + "/erBvGy2i/MOjZrkm2xpmfh4SDBF1a3hDTxFYPwyllEnvGfDyi62a+pGx8cgoLEf\n"
+        + "Zd5ICLqkTqnyg0Y3hOvozIFIQ2dOciqbXL1MGyiKXCJ7tKuY2e7gUYPDCUZObT6Z\n"
+        + "+pUX2nwzV0E8jVHtC7ZcryxjGt9XyD+86V3Em69FmeKjWiS0uqlWPc9vqv9JWL7w\n"
+        + "qP/0uK3pN/u6uPQLOvnoQ0IeidiEyxPx2bvhiWC4jChWrBQdnArncevPDt09qZah\n"
+        + "SL0896+1DSJMwBGB7FY79tOi4lu3sgQiUpWAk2nojkxl8ZEDLXB0AuqLZxUpaVIC\n"
+        + "u9ffUGpVRr+goyhhf3DQw6KqLCGqR84onAZFdr+CGCe01a60y1Dma/RMhnEw6abf\n"
+        + "Fobg2P9A3fvQQoh/ozM6LlweQRGBY84YcWsr7KaKtzFcOmpH4MN5WdYgGq/yapiq\n"
+        + "crxXStJLnbsQ/LBMQeXtHT1eKJ2czL+zUdqnR+WEUwIDAQABo0IwQDAdBgNVHQ4E\n"
+        + "FgQUu69+Aj36pvE8hI6t7jiY7NkyMtQwDgYDVR0PAQH/BAQDAgEGMA8GA1UdEwEB\n"
+        + "/wQFMAMBAf8wDQYJKoZIhvcNAQEMBQADggIBAArx1UaEt65Ru2yyTUEUAJNMnMvl\n"
+        + "wFTPoCWOAvn9sKIN9SCYPBMtrFaisNZ+EZLpLrqeLppysb0ZRGxhNaKatBYSaVqM\n"
+        + "4dc+pBroLwP0rmEdEBsqpIt6xf4FpuHA1sj+nq6PK7o9mfjYcwlYRm6mnPTXJ9OV\n"
+        + "2jeDchzTc+CiR5kDOF3VSXkAKRzH7JsgHAckaVd4sjn8OoSgtZx8jb8uk2Intzna\n"
+        + "FxiuvTwJaP+EmzzV1gsD41eeFPfR60/IvYcjt7ZJQ3mFXLrrkguhxuhoqEwWsRqZ\n"
+        + "CuhTLJK7oQkYdQxlqHvLI7cawiiFwxv/0Cti76R7CZGYZ4wUAc1oBmpjIXUDgIiK\n"
+        + "boHGhfKppC3n9KUkEEeDys30jXlYsQab5xoq2Z0B15R97QNKyvDb6KkBPvVWmcke\n"
+        + "jkk9u+UJueBPSZI9FoJAzMxZxuY67RIuaTxslbH9qh17f4a+Hg4yRvv7E491f0yL\n"
+        + "S0Zj/gA0QHDBw7mh3aZw4gSzQbzpgJHqZJx64SIDqZxubw5lT2yHh17zbqD5daWb\n"
+        + "QOhTsiedSrnAdyGN/4fy3ryM7xfft0kL0fJuMAsaDk527RH89elWsn2/x20Kk4yl\n"
+        + "0MC2Hb46TpSi125sC8KKfPog88Tk5c0NqMuRkrF8hey1FGlmDoLnzc7ILaZRfyHB\n"
+        + "NVOFBkpdn627G190\n"
+        + "-----END CERTIFICATE-----\n";
+    String entrustRootCertificateAuthority = ""
+        + "-----BEGIN CERTIFICATE-----\n"
+        + "MIIEkTCCA3mgAwIBAgIERWtQVDANBgkqhkiG9w0BAQUFADCBsDELMAkGA1UEBhMC\n"
+        + "VVMxFjAUBgNVBAoTDUVudHJ1c3QsIEluYy4xOTA3BgNVBAsTMHd3dy5lbnRydXN0\n"
+        + "Lm5ldC9DUFMgaXMgaW5jb3Jwb3JhdGVkIGJ5IHJlZmVyZW5jZTEfMB0GA1UECxMW\n"
+        + "KGMpIDIwMDYgRW50cnVzdCwgSW5jLjEtMCsGA1UEAxMkRW50cnVzdCBSb290IENl\n"
+        + "cnRpZmljYXRpb24gQXV0aG9yaXR5MB4XDTA2MTEyNzIwMjM0MloXDTI2MTEyNzIw\n"
+        + "NTM0MlowgbAxCzAJBgNVBAYTAlVTMRYwFAYDVQQKEw1FbnRydXN0LCBJbmMuMTkw\n"
+        + "NwYDVQQLEzB3d3cuZW50cnVzdC5uZXQvQ1BTIGlzIGluY29ycG9yYXRlZCBieSBy\n"
+        + "ZWZlcmVuY2UxHzAdBgNVBAsTFihjKSAyMDA2IEVudHJ1c3QsIEluYy4xLTArBgNV\n"
+        + "BAMTJEVudHJ1c3QgUm9vdCBDZXJ0aWZpY2F0aW9uIEF1dGhvcml0eTCCASIwDQYJ\n"
+        + "KoZIhvcNAQEBBQADggEPADCCAQoCggEBALaVtkNC+sZtKm9I35RMOVcF7sN5EUFo\n"
+        + "Nu3s/poBj6E4KPz3EEZmLk0eGrEaTsbRwJWIsMn/MYszA9u3g3s+IIRe7bJWKKf4\n"
+        + "4LlAcTfFy0cOlypowCKVYhXbR9n10Cv/gkvJrT7eTNuQgFA/CYqEAOwwCj0Yzfv9\n"
+        + "KlmaI5UXLEWeH25DeW0MXJj+SKfFI0dcXv1u5x609mhF0YaDW6KKjbHjKYD+JXGI\n"
+        + "rb68j6xSlkuqUY3kEzEZ6E5Nn9uss2rVvDlUccp6en+Q3X0dgNmBu1kmwhH+5pPi\n"
+        + "94DkZfs0Nw4pgHBNrziGLp5/V6+eF67rHMsoIV+2HNjnogQi+dPa2MsCAwEAAaOB\n"
+        + "sDCBrTAOBgNVHQ8BAf8EBAMCAQYwDwYDVR0TAQH/BAUwAwEB/zArBgNVHRAEJDAi\n"
+        + "gA8yMDA2MTEyNzIwMjM0MlqBDzIwMjYxMTI3MjA1MzQyWjAfBgNVHSMEGDAWgBRo\n"
+        + "kORnpKZTgMeGZqTx90tD+4S9bTAdBgNVHQ4EFgQUaJDkZ6SmU4DHhmak8fdLQ/uE\n"
+        + "vW0wHQYJKoZIhvZ9B0EABBAwDhsIVjcuMTo0LjADAgSQMA0GCSqGSIb3DQEBBQUA\n"
+        + "A4IBAQCT1DCw1wMgKtD5Y+iRDAUgqV8ZyntyTtSx29CW+1RaGSwMCPeyvIWonX9t\n"
+        + "O1KzKtvn1ISMY/YPyyYBkVBs9F8U4pN0wBOeMDpQ47RgxRzwIkSNcUesyBrJ6Zua\n"
+        + "AGAT/3B+XxFNSRuzFVJ7yVTav52Vr2ua2J7p8eRDjeIRRDq/r72DQnNSi6q7pynP\n"
+        + "9WQcCk3RvKqsnyrQ/39/2n3qse0wJcGE2jTSW3iDVuycNsMm4hH2Z0kdkquM++v/\n"
+        + "eu6FSqdQgPCnXEqULl8FmTxSQeDNtGPPAUO6nIPcj2A781q0tHuu2guQOHXvgR1m\n"
+        + "0vdXcDazv/wor3ElhVsT/h5/WrQ8\n"
+        + "-----END CERTIFICATE-----\n";
+    return new Buffer()
+        .writeUtf8(comodoRsaCertificationAuthority)
+        .writeUtf8(entrustRootCertificateAuthority)
+        .inputStream();
+  }
+
+  /**
+   * Returns a SSL context that trusts {@code certificates} and none other. HTTPS services whose
+   * certificates have not been signed by these certificates will fail with a {@code
+   * SSLHandshakeException}.
+   *
+   * <p>This can be used to replace the host platform's built-in trusted certificates with a custom
+   * set. This is useful in development where certificate authority-trusted certificates aren't
+   * available. Or in production, to avoid reliance on third-party certificate authorities.
+   *
+   * <p>See also {@link CertificatePinner}, which can limit trusted certificates while still using
+   * the host platform's built-in trust store.
+   *
+   * <h3>Warning: Customizing Trusted Certificates is Dangerous!</h3>
+   * Relying on your own trusted certificates limits your server team's ability to update their TLS
+   * certificates. By installing a specific set of trusted certificates, you take on additional
+   * operational complexity and limit your ability to migrate between certificate authorities. Do
+   * not use custom trusted certificates in production without the blessing of your server's TLS
+   * administrator.
+   */
+  public SSLContext sslContextForTrustedCertificates(InputStream in) {
+    try {
+      CertificateFactory certificateFactory = CertificateFactory.getInstance("X.509");
+      Collection<? extends Certificate> certificates = certificateFactory.generateCertificates(in);
+      if (certificates.isEmpty()) {
+        throw new IllegalArgumentException("expected non-empty set of trusted certificates");
+      }
+
+      // Put the certificates a key store.
+      char[] password = "password".toCharArray(); // Any password will work.
+      KeyStore keyStore = newEmptyKeyStore(password);
+      int index = 0;
+      for (Certificate certificate : certificates) {
+        String certificateAlias = Integer.toString(index++);
+        keyStore.setCertificateEntry(certificateAlias, certificate);
+      }
+
+      // Wrap it up in an SSL context.
+      KeyManagerFactory keyManagerFactory = KeyManagerFactory.getInstance(
+          KeyManagerFactory.getDefaultAlgorithm());
+      keyManagerFactory.init(keyStore, password);
+      TrustManagerFactory trustManagerFactory = TrustManagerFactory.getInstance(
+          TrustManagerFactory.getDefaultAlgorithm());
+      trustManagerFactory.init(keyStore);
+      SSLContext sslContext = SSLContext.getInstance("TLS");
+      sslContext.init(keyManagerFactory.getKeyManagers(), trustManagerFactory.getTrustManagers(),
+          new SecureRandom());
+      return sslContext;
+    } catch (GeneralSecurityException e) {
+      throw new RuntimeException(e);
+    }
+  }
+
+  private KeyStore newEmptyKeyStore(char[] password) throws GeneralSecurityException {
+    try {
+      KeyStore keyStore = KeyStore.getInstance(KeyStore.getDefaultType());
+      InputStream in = null; // By convention, 'null' creates an empty key store.
+      keyStore.load(in, password);
+      return keyStore;
+    } catch (IOException e) {
+      throw new AssertionError(e);
+    }
+  }
+
+  public static void main(String... args) throws Exception {
+    new CustomTrust().run();
+  }
+}
diff --git a/samples/guide/src/main/java/com/squareup/okhttp/recipes/Progress.java b/samples/guide/src/main/java/com/squareup/okhttp/recipes/Progress.java
new file mode 100644
index 0000000000..9d329fa16e
--- /dev/null
+++ b/samples/guide/src/main/java/com/squareup/okhttp/recipes/Progress.java
@@ -0,0 +1,111 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.okhttp.recipes;
+
+import com.squareup.okhttp.Interceptor;
+import com.squareup.okhttp.MediaType;
+import com.squareup.okhttp.OkHttpClient;
+import com.squareup.okhttp.Response;
+import com.squareup.okhttp.ResponseBody;
+import com.squareup.okhttp.Request;
+import java.io.IOException;
+import okio.Buffer;
+import okio.BufferedSource;
+import okio.ForwardingSource;
+import okio.Okio;
+import okio.Source;
+
+public final class Progress {
+
+  private final OkHttpClient client = new OkHttpClient();
+
+  public void run() throws Exception {
+    Request request = new Request.Builder()
+        .url("https://publicobject.com/helloworld.txt")
+        .build();
+
+    final ProgressListener progressListener = new ProgressListener() {
+      @Override public void update(long bytesRead, long contentLength, boolean done) {
+        System.out.println(bytesRead);
+        System.out.println(contentLength);
+        System.out.println(done);
+        System.out.format("%d%% done\n", (100 * bytesRead) / contentLength);
+      }
+    };
+
+    client.networkInterceptors().add(new Interceptor() {
+      @Override public Response intercept(Chain chain) throws IOException {
+        Response originalResponse = chain.proceed(chain.request());
+        return originalResponse.newBuilder()
+            .body(new ProgressResponseBody(originalResponse.body(), progressListener))
+            .build();
+        }
+    });
+
+    Response response = client.newCall(request).execute();
+    if (!response.isSuccessful()) throw new IOException("Unexpected code " + response);
+
+    System.out.println(response.body().string());
+  }
+
+  public static void main(String... args) throws Exception {
+    new Progress().run();
+  }
+
+  private static class ProgressResponseBody extends ResponseBody {
+
+    private final ResponseBody responseBody;
+    private final ProgressListener progressListener;
+    private BufferedSource bufferedSource;
+
+    public ProgressResponseBody(ResponseBody responseBody, ProgressListener progressListener) {
+      this.responseBody = responseBody;
+      this.progressListener = progressListener;
+    }
+
+    @Override public MediaType contentType() {
+      return responseBody.contentType();
+    }
+
+    @Override public long contentLength() throws IOException {
+      return responseBody.contentLength();
+    }
+
+    @Override public BufferedSource source() throws IOException {
+      if (bufferedSource == null) {
+        bufferedSource = Okio.buffer(source(responseBody.source()));
+      }
+      return bufferedSource;
+    }
+
+    private Source source(Source source) {
+      return new ForwardingSource(source) {
+        long totalBytesRead = 0L;
+        @Override public long read(Buffer sink, long byteCount) throws IOException {
+          long bytesRead = super.read(sink, byteCount);
+          // read() returns the number of bytes read, or -1 if this source is exhausted.
+          totalBytesRead += bytesRead != -1 ? bytesRead : 0;
+          progressListener.update(totalBytesRead, responseBody.contentLength(), bytesRead == -1);
+          return bytesRead;
+        }
+      };
+    }
+  }
+
+  interface ProgressListener {
+    void update(long bytesRead, long contentLength, boolean done);
+  }
+}
diff --git a/samples/guide/src/main/java/com/squareup/okhttp/recipes/WebSocketEcho.java b/samples/guide/src/main/java/com/squareup/okhttp/recipes/WebSocketEcho.java
index 738191a9be..dfe3b90c7b 100644
--- a/samples/guide/src/main/java/com/squareup/okhttp/recipes/WebSocketEcho.java
+++ b/samples/guide/src/main/java/com/squareup/okhttp/recipes/WebSocketEcho.java
@@ -3,20 +3,17 @@
 import com.squareup.okhttp.OkHttpClient;
 import com.squareup.okhttp.Request;
 import com.squareup.okhttp.Response;
-import com.squareup.okhttp.internal.ws.WebSocket;
-import com.squareup.okhttp.internal.ws.WebSocketCall;
-import com.squareup.okhttp.internal.ws.WebSocketListener;
+import com.squareup.okhttp.ws.WebSocket;
+import com.squareup.okhttp.ws.WebSocketCall;
+import com.squareup.okhttp.ws.WebSocketListener;
 import java.io.IOException;
 import okio.Buffer;
 import okio.BufferedSource;
 
-import static com.squareup.okhttp.internal.ws.WebSocket.PayloadType;
-import static com.squareup.okhttp.internal.ws.WebSocket.PayloadType.BINARY;
-import static com.squareup.okhttp.internal.ws.WebSocket.PayloadType.TEXT;
+import static com.squareup.okhttp.ws.WebSocket.PayloadType;
+import static com.squareup.okhttp.ws.WebSocket.PayloadType.BINARY;
+import static com.squareup.okhttp.ws.WebSocket.PayloadType.TEXT;
 
-/**
- * WARNING: This recipe is for an API that is not final and subject to change at any time!
- */
 public final class WebSocketEcho implements WebSocketListener {
   private void run() throws IOException {
     OkHttpClient client = new OkHttpClient();
@@ -24,7 +21,7 @@ private void run() throws IOException {
     Request request = new Request.Builder()
         .url("ws://echo.websocket.org")
         .build();
-    WebSocketCall.newWebSocketCall(client, request).enqueue(this);
+    WebSocketCall.create(client, request).enqueue(this);
 
     // Trigger shutdown of the dispatcher's executor so this process can exit cleanly.
     client.getDispatcher().getExecutorService().shutdown();
diff --git a/samples/pom.xml b/samples/pom.xml
index 6991fa9165..83b45a98e1 100644
--- a/samples/pom.xml
+++ b/samples/pom.xml
@@ -6,7 +6,7 @@
   <parent>
     <groupId>com.squareup.okhttp</groupId>
     <artifactId>parent</artifactId>
-    <version>2.3.0-SNAPSHOT</version>
+    <version>2.4.0-SNAPSHOT</version>
   </parent>
 
   <groupId>com.squareup.okhttp.sample</groupId>
diff --git a/samples/simple-client/pom.xml b/samples/simple-client/pom.xml
index 3ebf058230..e3cb146fbd 100644
--- a/samples/simple-client/pom.xml
+++ b/samples/simple-client/pom.xml
@@ -6,7 +6,7 @@
   <parent>
     <groupId>com.squareup.okhttp.sample</groupId>
     <artifactId>sample-parent</artifactId>
-    <version>2.3.0-SNAPSHOT</version>
+    <version>2.4.0-SNAPSHOT</version>
   </parent>
 
   <artifactId>simple-client</artifactId>
diff --git a/samples/static-server/pom.xml b/samples/static-server/pom.xml
index e3dc358364..9771c9e7da 100644
--- a/samples/static-server/pom.xml
+++ b/samples/static-server/pom.xml
@@ -6,7 +6,7 @@
   <parent>
     <groupId>com.squareup.okhttp.sample</groupId>
     <artifactId>sample-parent</artifactId>
-    <version>2.3.0-SNAPSHOT</version>
+    <version>2.4.0-SNAPSHOT</version>
   </parent>
 
   <artifactId>static-server</artifactId>
