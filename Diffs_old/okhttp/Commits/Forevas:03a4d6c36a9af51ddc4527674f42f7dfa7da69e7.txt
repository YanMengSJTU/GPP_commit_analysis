diff --git a/CHANGELOG.md b/CHANGELOG.md
index b99f00f4e3..0165564107 100644
--- a/CHANGELOG.md
+++ b/CHANGELOG.md
@@ -1,6 +1,58 @@
 Change Log
 ==========
 
+## Version 3.5.0
+
+_2016-11-30_
+
+ *  **Web Sockets are now a stable feature of OkHttp.** Since being introduced as a beta feature in
+    OkHttp 2.3 our web socket client has matured. Connect to a server's web socket with
+    `OkHttpClient.newWebSocket()`, send messages with `send()`, and receive messages with the
+    `WebSocketListener`.
+
+    The `okhttp-ws` submodule is no longer available and `okhttp-ws` artifacts from previous
+    releases of OkHttp are not compatible with OkHttp 3.5. When upgrading to the new package
+    please note that the `WebSocket` and `WebSocketCall` classes have been merged. Sending messages
+    is now asynchronous and they may be enqueued before the web socket is connected.
+
+ *  **OkHttp no longer attempts a direct connection if the system's HTTP proxy fails.** This
+    behavior was surprising because OkHttp was disregarding the user's specified configuration. If
+    you need to customize proxy fallback behavior, implement your own `java.net.ProxySelector`.
+
+ *  Fix: Support TLSv1.3 on devices that support it.
+
+ *  Fix: Share pooled connections across equivalent `OkHttpClient` instances. Previous releases had
+    a bug where a shared connection pool did not guarantee shared connections in some cases.
+ *  Fix: Prefer the server's response body on all conditional cache misses. Previously we would
+    return the cached response's body if it had a newer `Last-Modified` date.
+ *  Fix: Update the stored timestamp on conditional cache hits.
+ *  New: Optimized HTTP/2 request header encoding. More headers are HPACK-encoded and string
+    literals are now Huffman-encoded.
+ *  New: Expose `Part` headers and body in `Multipart`.
+ *  New: Make `ResponseBody.string()` and `ResponseBody.charStream()` BOM-aware. If your HTTP
+    response body begins with a [byte order mark][bom] it will be consumed and used to select a
+    charset for the remaining bytes. Most applications should not not need a byte order mark.
+
+ *  New: Upgrade to Okio 1.11.0.
+
+     ```xml
+     <dependency>
+       <groupId>com.squareup.okio</groupId>
+       <artifactId>okio</artifactId>
+       <version>1.11.0</version>
+     </dependency>
+
+     com.squareup.okio:okio:1.11.0
+     ```
+
+ *  Fix: Avoid sending empty HTTP/2 data frames when there is no request body.
+ *  Fix: Add a leading `.` for better domain matching in `JavaNetCookieJar`.
+ *  Fix: Gracefully recover from HTTP/2 connection shutdowns at start of request.
+ *  Fix: Be lenient if a `MediaType`'s character set is `'single-quoted'`.
+ *  Fix: Allow horizontal tab characters in header values.
+ *  Fix: When parsing HTTP authentication headers permit challenge parameters in any order.
+
+
 ## Version 3.4.2
 
 _2016-11-03_
@@ -1146,3 +1198,4 @@ Initial release.
  [major_versions]: http://jakewharton.com/java-interoperability-policy-for-major-version-updates/
  [nginx_959]: https://trac.nginx.org/nginx/ticket/959
  [okhttp_idling_resource]: https://github.com/JakeWharton/okhttp-idling-resource
+ [bom]: https://en.wikipedia.org/wiki/Byte_order_mark
diff --git a/README.md b/README.md
index 5b70072b86..298b139f42 100644
--- a/README.md
+++ b/README.md
@@ -11,12 +11,12 @@ Download [the latest JAR][3] or grab via Maven:
 <dependency>
   <groupId>com.squareup.okhttp3</groupId>
   <artifactId>okhttp</artifactId>
-  <version>3.4.2</version>
+  <version>3.5.0</version>
 </dependency>
 ```
 or Gradle:
 ```groovy
-compile 'com.squareup.okhttp3:okhttp:3.4.2'
+compile 'com.squareup.okhttp3:okhttp:3.5.0'
 ```
 
 Snapshots of the development version are available in [Sonatype's `snapshots` repository][snap].
@@ -36,13 +36,13 @@ Download [the latest JAR][4] or grab via Maven:
 <dependency>
   <groupId>com.squareup.okhttp3</groupId>
   <artifactId>mockwebserver</artifactId>
-  <version>3.4.2</version>
+  <version>3.5.0</version>
   <scope>test</scope>
 </dependency>
 ```
 or Gradle:
 ```groovy
-testCompile 'com.squareup.okhttp3:mockwebserver:3.4.2'
+testCompile 'com.squareup.okhttp3:mockwebserver:3.5.0'
 ```
 
 
diff --git a/benchmarks/pom.xml b/benchmarks/pom.xml
index 0065b25634..e6067ec658 100644
--- a/benchmarks/pom.xml
+++ b/benchmarks/pom.xml
@@ -6,7 +6,7 @@
   <parent>
     <groupId>com.squareup.okhttp3</groupId>
     <artifactId>parent</artifactId>
-    <version>3.5.0-SNAPSHOT</version>
+    <version>3.6.0-SNAPSHOT</version>
   </parent>
 
   <artifactId>benchmarks</artifactId>
diff --git a/mockwebserver/pom.xml b/mockwebserver/pom.xml
index 9f68096de5..12f9cf46a9 100644
--- a/mockwebserver/pom.xml
+++ b/mockwebserver/pom.xml
@@ -6,7 +6,7 @@
   <parent>
     <groupId>com.squareup.okhttp3</groupId>
     <artifactId>parent</artifactId>
-    <version>3.5.0-SNAPSHOT</version>
+    <version>3.6.0-SNAPSHOT</version>
   </parent>
 
   <artifactId>mockwebserver</artifactId>
diff --git a/mockwebserver/src/main/java/okhttp3/internal/tls/HeldCertificate.java b/mockwebserver/src/main/java/okhttp3/internal/tls/HeldCertificate.java
index a7fe81f0ef..eedfc2a094 100644
--- a/mockwebserver/src/main/java/okhttp3/internal/tls/HeldCertificate.java
+++ b/mockwebserver/src/main/java/okhttp3/internal/tls/HeldCertificate.java
@@ -22,14 +22,21 @@
 import java.security.SecureRandom;
 import java.security.Security;
 import java.security.cert.X509Certificate;
+import java.util.ArrayList;
 import java.util.Date;
+import java.util.List;
 import java.util.UUID;
 import javax.security.auth.x500.X500Principal;
+import org.bouncycastle.asn1.ASN1Encodable;
+import org.bouncycastle.asn1.DERSequence;
 import org.bouncycastle.asn1.x509.BasicConstraints;
+import org.bouncycastle.asn1.x509.GeneralName;
 import org.bouncycastle.asn1.x509.X509Extensions;
 import org.bouncycastle.jce.provider.BouncyCastleProvider;
 import org.bouncycastle.x509.X509V3CertificateGenerator;
 
+import static okhttp3.internal.Util.verifyAsIpAddress;
+
 /**
  * A certificate and its private key. This can be used on the server side by HTTPS servers, or on
  * the client side to verify those HTTPS servers. A held certificate can also be used to sign other
@@ -51,6 +58,7 @@ public HeldCertificate(X509Certificate certificate, KeyPair keyPair) {
 
     private final long duration = 1000L * 60 * 60 * 24; // One day.
     private String hostname;
+    private List<String> altNames = new ArrayList<>();
     private String serialNumber = "1";
     private KeyPair keyPair;
     private HeldCertificate issuedBy;
@@ -93,6 +101,15 @@ public Builder ca(int maxIntermediateCas) {
       return this;
     }
 
+    /**
+     * Adds a subject alternative name to the certificate. This is usually a hostname or IP address.
+     * If no subject alternative names are added that extension will not be used.
+     */
+    public Builder subjectAlternativeName(String altName) {
+      altNames.add(altName);
+      return this;
+    }
+
     public HeldCertificate build() throws GeneralSecurityException {
       // Subject, public & private keys for this certificate.
       KeyPair heldKeyPair = keyPair != null
@@ -129,6 +146,19 @@ public HeldCertificate build() throws GeneralSecurityException {
             new BasicConstraints(maxIntermediateCas));
       }
 
+      if (!altNames.isEmpty()) {
+        ASN1Encodable[] encodableAltNames = new ASN1Encodable[altNames.size()];
+        for (int i = 0, size = altNames.size(); i < size; i++) {
+          String altName = altNames.get(i);
+          int tag = verifyAsIpAddress(altName)
+              ? GeneralName.iPAddress
+              : GeneralName.dNSName;
+          encodableAltNames[i] = new GeneralName(tag, altName);
+        }
+        generator.addExtension(X509Extensions.SubjectAlternativeName, true,
+            new DERSequence(encodableAltNames));
+      }
+
       X509Certificate certificate = generator.generateX509Certificate(
           signedByKeyPair.getPrivate(), "BC");
       return new HeldCertificate(certificate, heldKeyPair);
diff --git a/mockwebserver/src/main/java/okhttp3/mockwebserver/MockWebServer.java b/mockwebserver/src/main/java/okhttp3/mockwebserver/MockWebServer.java
index 65a9885149..76ee2fbec0 100644
--- a/mockwebserver/src/main/java/okhttp3/mockwebserver/MockWebServer.java
+++ b/mockwebserver/src/main/java/okhttp3/mockwebserver/MockWebServer.java
@@ -676,7 +676,8 @@ private void handleWebSocketUpgrade(Socket socket, BufferedSource source, Buffer
     RealWebSocket webSocket = new RealWebSocket(fancyRequest,
         response.getWebSocketListener(), new SecureRandom());
     response.getWebSocketListener().onOpen(webSocket, fancyResponse);
-    webSocket.initReaderAndWriter(streams);
+    String name = "MockWebServer WebSocket " + request.getPath();
+    webSocket.initReaderAndWriter(name, 0, streams);
     webSocket.loopReader();
 
     // Even if messages are no longer being read we need to wait for the connection close signal.
diff --git a/okcurl/pom.xml b/okcurl/pom.xml
index edc86849cf..f2fccf897b 100644
--- a/okcurl/pom.xml
+++ b/okcurl/pom.xml
@@ -6,7 +6,7 @@
   <parent>
     <groupId>com.squareup.okhttp3</groupId>
     <artifactId>parent</artifactId>
-    <version>3.5.0-SNAPSHOT</version>
+    <version>3.6.0-SNAPSHOT</version>
   </parent>
 
   <artifactId>okcurl</artifactId>
diff --git a/okhttp-android-support/pom.xml b/okhttp-android-support/pom.xml
index 1485393521..7ac8a4d245 100644
--- a/okhttp-android-support/pom.xml
+++ b/okhttp-android-support/pom.xml
@@ -6,7 +6,7 @@
   <parent>
     <groupId>com.squareup.okhttp3</groupId>
     <artifactId>parent</artifactId>
-    <version>3.5.0-SNAPSHOT</version>
+    <version>3.6.0-SNAPSHOT</version>
   </parent>
 
   <artifactId>okhttp-android-support</artifactId>
diff --git a/okhttp-apache/pom.xml b/okhttp-apache/pom.xml
index ed13f59fb2..4c1de9241f 100644
--- a/okhttp-apache/pom.xml
+++ b/okhttp-apache/pom.xml
@@ -6,7 +6,7 @@
   <parent>
     <groupId>com.squareup.okhttp3</groupId>
     <artifactId>parent</artifactId>
-    <version>3.5.0-SNAPSHOT</version>
+    <version>3.6.0-SNAPSHOT</version>
   </parent>
 
   <artifactId>okhttp-apache</artifactId>
diff --git a/okhttp-logging-interceptor/pom.xml b/okhttp-logging-interceptor/pom.xml
index 5f9d7862c8..bec052a7ae 100644
--- a/okhttp-logging-interceptor/pom.xml
+++ b/okhttp-logging-interceptor/pom.xml
@@ -6,7 +6,7 @@
   <parent>
     <groupId>com.squareup.okhttp3</groupId>
     <artifactId>parent</artifactId>
-    <version>3.5.0-SNAPSHOT</version>
+    <version>3.6.0-SNAPSHOT</version>
   </parent>
 
   <artifactId>logging-interceptor</artifactId>
diff --git a/okhttp-testing-support/pom.xml b/okhttp-testing-support/pom.xml
index 18f83cc3b6..a7e166bb13 100644
--- a/okhttp-testing-support/pom.xml
+++ b/okhttp-testing-support/pom.xml
@@ -6,7 +6,7 @@
   <parent>
     <groupId>com.squareup.okhttp3</groupId>
     <artifactId>parent</artifactId>
-    <version>3.5.0-SNAPSHOT</version>
+    <version>3.6.0-SNAPSHOT</version>
   </parent>
 
   <artifactId>okhttp-testing-support</artifactId>
diff --git a/okhttp-tests/pom.xml b/okhttp-tests/pom.xml
index 4b3a04ac78..215eb4c07d 100644
--- a/okhttp-tests/pom.xml
+++ b/okhttp-tests/pom.xml
@@ -6,7 +6,7 @@
   <parent>
     <groupId>com.squareup.okhttp3</groupId>
     <artifactId>parent</artifactId>
-    <version>3.5.0-SNAPSHOT</version>
+    <version>3.6.0-SNAPSHOT</version>
   </parent>
 
   <artifactId>okhttp-tests</artifactId>
diff --git a/okhttp-tests/src/test/java/okhttp3/AddressTest.java b/okhttp-tests/src/test/java/okhttp3/AddressTest.java
index 30e376be5b..ad07b78241 100644
--- a/okhttp-tests/src/test/java/okhttp3/AddressTest.java
+++ b/okhttp-tests/src/test/java/okhttp3/AddressTest.java
@@ -15,6 +15,7 @@
  */
 package okhttp3;
 
+import java.net.Proxy;
 import java.util.List;
 import javax.net.SocketFactory;
 import okhttp3.internal.Util;
@@ -48,4 +49,17 @@
         authenticator, null, protocols, connectionSpecs, new RecordingProxySelector());
     assertFalse(a.equals(b));
   }
+
+  @Test public void addressToString() throws Exception {
+    Address address = new Address("square.com", 80, dns, socketFactory, null, null, null,
+        authenticator, null, protocols, connectionSpecs, proxySelector);
+    assertEquals("Address{square.com:80, proxySelector=RecordingProxySelector}",
+        address.toString());
+  }
+
+  @Test public void addressWithProxyToString() throws Exception {
+    Address address = new Address("square.com", 80, dns, socketFactory, null, null, null,
+        authenticator, Proxy.NO_PROXY, protocols, connectionSpecs, proxySelector);
+    assertEquals("Address{square.com:80, proxy=" + Proxy.NO_PROXY + "}", address.toString());
+  }
 }
diff --git a/okhttp-tests/src/test/java/okhttp3/CacheTest.java b/okhttp-tests/src/test/java/okhttp3/CacheTest.java
index 97a6c4a08b..8f6bbbd628 100644
--- a/okhttp-tests/src/test/java/okhttp3/CacheTest.java
+++ b/okhttp-tests/src/test/java/okhttp3/CacheTest.java
@@ -19,15 +19,12 @@
 import java.io.File;
 import java.io.IOException;
 import java.net.CookieManager;
-import java.net.HttpCookie;
 import java.net.HttpURLConnection;
 import java.net.ResponseCache;
 import java.security.Principal;
 import java.security.cert.Certificate;
 import java.text.DateFormat;
 import java.text.SimpleDateFormat;
-import java.util.ArrayList;
-import java.util.Arrays;
 import java.util.Date;
 import java.util.Iterator;
 import java.util.List;
@@ -1820,14 +1817,6 @@ private RecordedRequest assertClientSuppliedCondition(MockResponse seed, String
     assertEquals("299 test danger", response2.header("Warning"));
   }
 
-  public void assertCookies(HttpUrl url, String... expectedCookies) throws Exception {
-    List<String> actualCookies = new ArrayList<>();
-    for (HttpCookie cookie : cookieManager.getCookieStore().get(url.uri())) {
-      actualCookies.add(cookie.toString());
-    }
-    assertEquals(Arrays.asList(expectedCookies), actualCookies);
-  }
-
   @Test public void doNotCachePartialResponse() throws Exception {
     assertNotCached(new MockResponse()
         .setResponseCode(HttpURLConnection.HTTP_PARTIAL)
diff --git a/okhttp-tests/src/test/java/okhttp3/CallTest.java b/okhttp-tests/src/test/java/okhttp3/CallTest.java
index b0e6c99d2c..9f508842b3 100644
--- a/okhttp-tests/src/test/java/okhttp3/CallTest.java
+++ b/okhttp-tests/src/test/java/okhttp3/CallTest.java
@@ -63,6 +63,7 @@
 import okhttp3.internal.Version;
 import okhttp3.internal.http.RecordingProxySelector;
 import okhttp3.internal.io.InMemoryFileSystem;
+import okhttp3.internal.tls.HeldCertificate;
 import okhttp3.internal.tls.SslClient;
 import okhttp3.mockwebserver.Dispatcher;
 import okhttp3.mockwebserver.MockResponse;
@@ -1012,7 +1013,10 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
     executeSynchronously("/").assertBody("seed connection pool");
 
     // If this succeeds, too many requests were made.
-    executeSynchronously("/").assertFailure(IOException.class);
+    executeSynchronously("/")
+        .assertFailure(IOException.class)
+        .assertFailureMatches("unexpected end of stream on Connection.*"
+            + server.getHostName() + ":" + server.getPort() + ".*");
   }
 
   @Test public void recoverFromTlsHandshakeFailure() throws Exception {
@@ -2091,6 +2095,33 @@ private InetSocketAddress startNullServer() throws IOException {
     executeSynchronously("/").assertBody("abcabcabc");
   }
 
+  @Test public void rangeHeaderPreventsAutomaticGzip() throws Exception {
+    Buffer gzippedBody = gzip("abcabcabc");
+
+    // Enqueue a gzipped response. Our request isn't expecting it, but that's okay.
+    server.enqueue(new MockResponse()
+        .setResponseCode(HttpURLConnection.HTTP_PARTIAL)
+        .setBody(gzippedBody)
+        .addHeader("Content-Encoding: gzip")
+        .addHeader("Content-Range: bytes 0-" + (gzippedBody.size() - 1)));
+
+    // Make a range request.
+    Request request = new Request.Builder()
+        .url(server.url("/"))
+        .header("Range", "bytes=0-")
+        .build();
+    Call call = client.newCall(request);
+
+    // The response is not decompressed.
+    Response response = call.execute();
+    assertEquals("gzip", response.header("Content-Encoding"));
+    assertEquals(gzippedBody.snapshot(), response.body().source().readByteString());
+
+    // The request did not offer gzip support.
+    RecordedRequest recordedRequest = server.takeRequest();
+    assertNull(recordedRequest.getHeader("Accept-Encoding"));
+  }
+
   @Test public void asyncResponseCanBeConsumedLater() throws Exception {
     server.enqueue(new MockResponse().setBody("abc"));
     server.enqueue(new MockResponse().setBody("def"));
@@ -2501,6 +2532,46 @@ private InetSocketAddress startNullServer() throws IOException {
         .assertFailure("Unexpected status line:  HTTP/1.1 200 OK");
   }
 
+  @Test public void requestHeaderNameWithSpaceForbidden() throws Exception {
+    try {
+      new Request.Builder().addHeader("a b", "c");
+      fail();
+    } catch (IllegalArgumentException expected) {
+      assertEquals("Unexpected char 0x20 at 1 in header name: a b", expected.getMessage());
+    }
+  }
+
+  @Test public void requestHeaderNameWithTabForbidden() throws Exception {
+    try {
+      new Request.Builder().addHeader("a\tb", "c");
+      fail();
+    } catch (IllegalArgumentException expected) {
+      assertEquals("Unexpected char 0x09 at 1 in header name: a\tb", expected.getMessage());
+    }
+  }
+
+  @Test public void responseHeaderNameWithSpacePermitted() throws Exception {
+    server.enqueue(new MockResponse()
+        .clearHeaders()
+        .addHeader("content-length: 0")
+        .addHeaderLenient("a b", "c"));
+
+    Call call = client.newCall(new Request.Builder().url(server.url("/")).build());
+    Response response = call.execute();
+    assertEquals("c", response.header("a b"));
+  }
+
+  @Test public void responseHeaderNameWithTabPermitted() throws Exception {
+    server.enqueue(new MockResponse()
+        .clearHeaders()
+        .addHeader("content-length: 0")
+        .addHeaderLenient("a\tb", "c"));
+
+    Call call = client.newCall(new Request.Builder().url(server.url("/")).build());
+    Response response = call.execute();
+    assertEquals("c", response.header("a\tb"));
+  }
+
   @Test public void connectFails() throws Exception {
     server.shutdown();
 
@@ -2709,6 +2780,43 @@ private RequestBody requestBody(final boolean chunked, final long size, final in
     }
   }
 
+  @Test public void httpsWithIpAddress() throws Exception {
+    String localIpAddress = InetAddress.getLoopbackAddress().getHostAddress();
+
+    // Create a certificate with an IP address in the subject alt name.
+    HeldCertificate heldCertificate = new HeldCertificate.Builder()
+        .commonName("example.com")
+        .subjectAlternativeName(localIpAddress)
+        .build();
+    SslClient sslClient = new SslClient.Builder()
+        .certificateChain(heldCertificate.keyPair, heldCertificate.certificate)
+        .addTrustedCertificate(heldCertificate.certificate)
+        .build();
+
+    // Use that certificate on the server and trust it on the client.
+    server.useHttps(sslClient.socketFactory, false);
+    client = client.newBuilder()
+        .sslSocketFactory(sslClient.socketFactory, sslClient.trustManager)
+        .hostnameVerifier(new RecordingHostnameVerifier())
+        .protocols(Collections.singletonList(Protocol.HTTP_1_1))
+        .build();
+
+    // Make a request.
+    server.enqueue(new MockResponse());
+    HttpUrl url = server.url("/").newBuilder()
+        .host(localIpAddress)
+        .build();
+    Request request = new Request.Builder()
+        .url(url)
+        .build();
+    executeSynchronously(request)
+        .assertCode(200);
+
+    // Confirm that the IP address was used in the host header.
+    RecordedRequest recordedRequest = server.takeRequest();
+    assertEquals(localIpAddress + ":" + server.getPort(), recordedRequest.getHeader("Host"));
+  }
+
   private void makeFailingCall() {
     RequestBody requestBody = new RequestBody() {
       @Override public MediaType contentType() {
diff --git a/okhttp-tests/src/test/java/okhttp3/HttpUrlTest.java b/okhttp-tests/src/test/java/okhttp3/HttpUrlTest.java
index 33f4952651..3d5eb7cfd8 100644
--- a/okhttp-tests/src/test/java/okhttp3/HttpUrlTest.java
+++ b/okhttp-tests/src/test/java/okhttp3/HttpUrlTest.java
@@ -29,7 +29,6 @@
 
 import static java.util.Collections.singletonList;
 import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertNotNull;
 import static org.junit.Assert.assertNull;
 import static org.junit.Assert.fail;
 
@@ -129,9 +128,9 @@
     HttpUrl baseWithPasswordAndUsername = HttpUrl.parse("http://username:password@host/a/b#fragment");
     HttpUrl baseWithUsernameOnly = HttpUrl.parse("http://username@host/a/b#fragment");
     HttpUrl baseWithPasswordOnly = HttpUrl.parse("http://password@host/a/b#fragment");
-    assertEquals(HttpUrl.parse("http://host/..."), baseWithPasswordAndUsername.redact());
-    assertEquals(HttpUrl.parse("http://host/..."), baseWithUsernameOnly.redact());
-    assertEquals(HttpUrl.parse("http://host/..."), baseWithPasswordOnly.redact());
+    assertEquals("http://host/...", baseWithPasswordAndUsername.redact());
+    assertEquals("http://host/...", baseWithUsernameOnly.redact());
+    assertEquals("http://host/...", baseWithPasswordOnly.redact());
   }
 
   @Test public void resolveNoScheme() throws Exception {
diff --git a/okhttp-tests/src/test/java/okhttp3/OkHttpClientTest.java b/okhttp-tests/src/test/java/okhttp3/OkHttpClientTest.java
index 3cf5d900c3..5c13119e46 100644
--- a/okhttp-tests/src/test/java/okhttp3/OkHttpClientTest.java
+++ b/okhttp-tests/src/test/java/okhttp3/OkHttpClientTest.java
@@ -42,11 +42,12 @@
     ResponseCache.setDefault(DEFAULT_RESPONSE_CACHE);
   }
 
-  @Test public void timeoutDefaults() {
+  @Test public void durationDefaults() {
     OkHttpClient client = defaultClient();
     assertEquals(10_000, client.connectTimeoutMillis());
     assertEquals(10_000, client.readTimeoutMillis());
     assertEquals(10_000, client.writeTimeoutMillis());
+    assertEquals(0, client.pingIntervalMillis());
   }
 
   @Test public void timeoutValidRange() {
diff --git a/okhttp-tests/src/test/java/okhttp3/RecordedResponse.java b/okhttp-tests/src/test/java/okhttp3/RecordedResponse.java
index 3410775b6c..460ab66846 100644
--- a/okhttp-tests/src/test/java/okhttp3/RecordedResponse.java
+++ b/okhttp-tests/src/test/java/okhttp3/RecordedResponse.java
@@ -154,6 +154,12 @@ public RecordedResponse assertFailure(String... messages) {
     return this;
   }
 
+  public RecordedResponse assertFailureMatches(String pattern) {
+    assertNotNull(failure);
+    assertTrue(failure.getMessage(), failure.getMessage().matches(pattern));
+    return this;
+  }
+
   public RecordedResponse assertSentRequestAtMillis(long minimum, long maximum) {
     assertDateInRange(minimum, response.sentRequestAtMillis(), maximum);
     return this;
diff --git a/okhttp-tests/src/test/java/okhttp3/RequestTest.java b/okhttp-tests/src/test/java/okhttp3/RequestTest.java
index bd6092b4a8..5c205d7031 100644
--- a/okhttp-tests/src/test/java/okhttp3/RequestTest.java
+++ b/okhttp-tests/src/test/java/okhttp3/RequestTest.java
@@ -156,8 +156,8 @@
 
   @Test public void headerAcceptsPermittedCharacters() throws Exception {
     Request.Builder builder = new Request.Builder();
-    builder.header("AZab09 ~", "AZab09 ~");
-    builder.addHeader("AZab09 ~", "AZab09 ~");
+    builder.header("AZab09~", "AZab09 ~");
+    builder.addHeader("AZab09~", "AZab09 ~");
   }
 
   @Test public void emptyNameForbidden() throws Exception {
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/connection/RouteSelectorTest.java b/okhttp-tests/src/test/java/okhttp3/internal/connection/RouteSelectorTest.java
index 272186bffd..cecd9daa8f 100644
--- a/okhttp-tests/src/test/java/okhttp3/internal/connection/RouteSelectorTest.java
+++ b/okhttp-tests/src/test/java/okhttp3/internal/connection/RouteSelectorTest.java
@@ -327,6 +327,12 @@
     assertEquals("127.0.0.1", RouteSelector.getHostString(socketAddress));
   }
 
+  @Test public void routeToString() throws Exception {
+    Route route = new Route(httpAddress(), Proxy.NO_PROXY,
+        InetSocketAddress.createUnresolved("host", 1234));
+    assertEquals("Route{host:1234}", route.toString());
+  }
+
   private void assertRoute(Route route, Address address, Proxy proxy, InetAddress socketAddress,
       int socketPort) {
     assertEquals(address, route.address());
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/http/RecordingProxySelector.java b/okhttp-tests/src/test/java/okhttp3/internal/http/RecordingProxySelector.java
index 33a51500e0..bd4038d4a1 100644
--- a/okhttp-tests/src/test/java/okhttp3/internal/http/RecordingProxySelector.java
+++ b/okhttp-tests/src/test/java/okhttp3/internal/http/RecordingProxySelector.java
@@ -49,4 +49,8 @@ public void assertRequests(URI... expectedUris) {
         Util.format("%s %s:%d %s", uri, socketAddress.getHostName(), socketAddress.getPort(),
             ioe.getMessage()));
   }
+
+  @Override public String toString() {
+    return "RecordingProxySelector";
+  }
 }
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/http2/Http2ConnectionTest.java b/okhttp-tests/src/test/java/okhttp3/internal/http2/Http2ConnectionTest.java
index a782691f7d..37bec5e529 100644
--- a/okhttp-tests/src/test/java/okhttp3/internal/http2/Http2ConnectionTest.java
+++ b/okhttp-tests/src/test/java/okhttp3/internal/http2/Http2ConnectionTest.java
@@ -42,6 +42,7 @@
 import static okhttp3.TestUtil.headerEntries;
 import static okhttp3.TestUtil.repeat;
 import static okhttp3.internal.Util.EMPTY_BYTE_ARRAY;
+import static okhttp3.internal.http2.Http2Connection.Listener.REFUSE_INCOMING_STREAMS;
 import static okhttp3.internal.http2.Settings.DEFAULT_INITIAL_WINDOW_SIZE;
 import static okhttp3.internal.http2.Settings.ENABLE_PUSH;
 import static okhttp3.internal.http2.Settings.HEADER_TABLE_SIZE;
@@ -64,12 +65,14 @@
 
   @Test public void serverPingsClientHttp2() throws Exception {
     // write the mocking script
+    peer.sendFrame().settings(new Settings());
+    peer.acceptFrame(); // ACK
     peer.sendFrame().ping(false, 2, 3);
     peer.acceptFrame(); // PING
     peer.play();
 
     // play it back
-    connection(peer);
+    connect(peer);
 
     // verify the peer received what was expected
     InFrame ping = peer.takeFrame();
@@ -82,12 +85,14 @@
 
   @Test public void clientPingsServerHttp2() throws Exception {
     // write the mocking script
+    peer.sendFrame().settings(new Settings());
+    peer.acceptFrame(); // ACK
     peer.acceptFrame(); // PING
     peer.sendFrame().ping(true, 1, 5);
     peer.play();
 
     // play it back
-    Http2Connection connection = connection(peer);
+    Http2Connection connection = connect(peer);
     Ping ping = connection.ping();
     assertTrue(ping.roundTripTime() > 0);
     assertTrue(ping.roundTripTime() < TimeUnit.SECONDS.toNanos(1));
@@ -113,17 +118,13 @@
     peer.acceptFrame(); // HEADERS
     peer.play();
 
-    Http2Connection connection = connection(peer);
+    Http2Connection connection = connect(peer);
 
-    // Verify the peer received the ACK.
+    // Verify the peer received the second ACK.
     InFrame ackFrame = peer.takeFrame();
     assertEquals(Http2.TYPE_SETTINGS, ackFrame.type);
     assertEquals(0, ackFrame.streamId);
     assertTrue(ackFrame.ack);
-    ackFrame = peer.takeFrame();
-    assertEquals(Http2.TYPE_SETTINGS, ackFrame.type);
-    assertEquals(0, ackFrame.streamId);
-    assertTrue(ackFrame.ack);
 
     // This stream was created *after* the connection settings were adjusted.
     Http2Stream stream = connection.newStream(headerEntries("a", "android"), false);
@@ -139,7 +140,7 @@
     Settings settings = new Settings();
     settings.set(HEADER_TABLE_SIZE, 0);
 
-    Http2Connection connection = sendHttp2SettingsAndCheckForAck(client, settings);
+    Http2Connection connection = connectWithSettings(client, settings);
 
     // Verify the peer's settings were read and applied.
     assertEquals(0, connection.peerSettings.getHeaderTableSize());
@@ -153,7 +154,7 @@
     Settings settings = new Settings();
     settings.set(ENABLE_PUSH, 0); // The peer client disables push.
 
-    Http2Connection connection = sendHttp2SettingsAndCheckForAck(client, settings);
+    Http2Connection connection = connectWithSettings(client, settings);
 
     // verify the peer's settings were read and applied.
     assertFalse(connection.peerSettings.getEnablePush(true));
@@ -164,7 +165,7 @@
     Settings settings = new Settings();
     settings.set(MAX_FRAME_SIZE, newMaxFrameSize);
 
-    Http2Connection connection = sendHttp2SettingsAndCheckForAck(true, settings);
+    Http2Connection connection = connectWithSettings(true, settings);
 
     // verify the peer's settings were read and applied.
     assertEquals(newMaxFrameSize, connection.peerSettings.getMaxFrameSize(-1));
@@ -181,9 +182,9 @@
 
     // Write the mocking script.
     peer.sendFrame().settings(new Settings().set(INITIAL_WINDOW_SIZE, 0));
+    peer.acceptFrame(); // ACK
     peer.sendFrame().windowUpdate(0, 10); // Increase the connection window size.
-    peer.acceptFrame(); // PING or SETTINGS ACK
-    peer.acceptFrame(); // PING or SETTINGS ACK
+    peer.acceptFrame(); // PING
     peer.sendFrame().ping(true, 1, 0);
     peer.acceptFrame(); // HEADERS STREAM 3
     peer.sendFrame().windowUpdate(3, 5);
@@ -193,7 +194,7 @@
     peer.play();
 
     // Play it back.
-    Http2Connection connection = connection(peer);
+    Http2Connection connection = connect(peer);
     connection.ping().roundTripTime(); // Ensure the SETTINGS have been received.
     Http2Stream stream = connection.newStream(headerEntries("a", "android"), true);
     BufferedSink sink = Okio.buffer(stream.getSink());
@@ -201,8 +202,7 @@
     sink.flush();
 
     // Verify the peer received what was expected.
-    peer.takeFrame(); // PING or SETTINGS ACK
-    peer.takeFrame(); // PING or SETTINGS ACK
+    peer.takeFrame(); // PING
     InFrame headers = peer.takeFrame();
     assertEquals(Http2.TYPE_HEADERS, headers.type);
     InFrame data1 = peer.takeFrame();
@@ -217,6 +217,8 @@
 
   @Test public void receiveGoAwayHttp2() throws Exception {
     // write the mocking script
+    peer.sendFrame().settings(new Settings());
+    peer.acceptFrame(); // ACK
     peer.acceptFrame(); // SYN_STREAM 3
     peer.acceptFrame(); // SYN_STREAM 5
     peer.sendFrame().goAway(3, ErrorCode.PROTOCOL_ERROR, EMPTY_BYTE_ARRAY);
@@ -226,7 +228,7 @@
     peer.play();
 
     // play it back
-    Http2Connection connection = connection(peer);
+    Http2Connection connection = connect(peer);
     Http2Stream stream1 = connection.newStream(headerEntries("a", "android"), true);
     Http2Stream stream2 = connection.newStream(headerEntries("b", "banana"), true);
     connection.ping().roundTripTime(); // Ensure the GO_AWAY that resets stream2 has been received.
@@ -269,6 +271,8 @@
     int windowUpdateThreshold = 50;
 
     // Write the mocking script.
+    peer.sendFrame().settings(new Settings());
+    peer.acceptFrame(); // ACK
     peer.acceptFrame(); // SYN_STREAM
     peer.sendFrame().synReply(false, 3, headerEntries("a", "android"));
     for (int i = 0; i < 3; i++) {
@@ -283,7 +287,7 @@
     peer.play();
 
     // Play it back.
-    Http2Connection connection = connection(peer);
+    Http2Connection connection = connect(peer);
     connection.okHttpSettings.set(INITIAL_WINDOW_SIZE, windowSize);
     Http2Stream stream = connection.newStream(headerEntries("b", "banana"), false);
     assertEquals(0, stream.unacknowledgedBytesRead);
@@ -311,31 +315,35 @@
 
   @Test public void serverSendsEmptyDataClientDoesntSendWindowUpdateHttp2() throws Exception {
     // Write the mocking script.
+    peer.sendFrame().settings(new Settings());
+    peer.acceptFrame(); // ACK
     peer.acceptFrame(); // SYN_STREAM
     peer.sendFrame().synReply(false, 3, headerEntries("a", "android"));
     peer.sendFrame().data(true, 3, data(0), 0);
     peer.play();
 
     // Play it back.
-    Http2Connection connection = connection(peer);
+    Http2Connection connection = connect(peer);
     Http2Stream client = connection.newStream(headerEntries("b", "banana"), false);
     assertEquals(-1, client.getSource().read(new Buffer(), 1));
 
     // Verify the peer received what was expected.
     InFrame synStream = peer.takeFrame();
     assertEquals(Http2.TYPE_HEADERS, synStream.type);
-    assertEquals(3, peer.frameCount());
+    assertEquals(5, peer.frameCount());
   }
 
   @Test public void clientSendsEmptyDataServerDoesntSendWindowUpdateHttp2() throws Exception {
     // Write the mocking script.
+    peer.sendFrame().settings(new Settings());
+    peer.acceptFrame(); // ACK
     peer.acceptFrame(); // SYN_STREAM
     peer.acceptFrame(); // DATA
     peer.sendFrame().synReply(false, 3, headerEntries("a", "android"));
     peer.play();
 
     // Play it back.
-    Http2Connection connection = connection(peer);
+    Http2Connection connection = connect(peer);
     Http2Stream client = connection.newStream(headerEntries("b", "banana"), true);
     BufferedSink out = Okio.buffer(client.getSink());
     out.write(EMPTY_BYTE_ARRAY);
@@ -345,7 +353,7 @@
     // Verify the peer received what was expected.
     assertEquals(Http2.TYPE_HEADERS, peer.takeFrame().type);
     assertEquals(Http2.TYPE_DATA, peer.takeFrame().type);
-    assertEquals(3, peer.frameCount());
+    assertEquals(5, peer.frameCount());
   }
 
   @Test public void maxFrameSizeHonored() throws Exception {
@@ -353,6 +361,8 @@
     Arrays.fill(buff, (byte) '*');
 
     // write the mocking script
+    peer.sendFrame().settings(new Settings());
+    peer.acceptFrame(); // ACK
     peer.acceptFrame(); // SYN_STREAM
     peer.sendFrame().synReply(false, 3, headerEntries("a", "android"));
     peer.acceptFrame(); // DATA
@@ -360,7 +370,7 @@
     peer.play();
 
     // play it back
-    Http2Connection connection = connection(peer);
+    Http2Connection connection = connect(peer);
     Http2Stream stream = connection.newStream(headerEntries("b", "banana"), true);
     BufferedSink out = Okio.buffer(stream.getSink());
     out.write(buff);
@@ -377,6 +387,8 @@
 
   @Test public void pushPromiseStream() throws Exception {
     // write the mocking script
+    peer.sendFrame().settings(new Settings());
+    peer.acceptFrame(); // ACK
     peer.acceptFrame(); // SYN_STREAM
     peer.sendFrame().synReply(false, 3, headerEntries("a", "android"));
     final List<Header> expectedRequestHeaders = Arrays.asList(
@@ -396,10 +408,7 @@
     RecordingPushObserver observer = new RecordingPushObserver();
 
     // play it back
-    Http2Connection connection = connectionBuilder(peer)
-        .pushObserver(observer)
-        .build();
-    connection.start(false);
+    Http2Connection connection = connect(peer, observer, REFUSE_INCOMING_STREAMS);
     Http2Stream client = connection.newStream(headerEntries("b", "banana"), false);
     assertEquals(-1, client.getSource().read(new Buffer(), 1));
 
@@ -412,6 +421,8 @@
 
   @Test public void doublePushPromise() throws Exception {
     // write the mocking script
+    peer.sendFrame().settings(new Settings());
+    peer.acceptFrame(); // ACK
     peer.sendFrame().pushPromise(3, 2, headerEntries("a", "android"));
     peer.acceptFrame(); // SYN_REPLY
     peer.sendFrame().pushPromise(3, 2, headerEntries("b", "banana"));
@@ -419,8 +430,7 @@
     peer.play();
 
     // play it back
-    Http2Connection connection = connectionBuilder(peer).build();
-    connection.start(false);
+    Http2Connection connection = connect(peer);
     connection.newStream(headerEntries("b", "banana"), false);
 
     // verify the peer received what was expected
@@ -430,6 +440,8 @@
 
   @Test public void pushPromiseStreamsAutomaticallyCancel() throws Exception {
     // write the mocking script
+    peer.sendFrame().settings(new Settings());
+    peer.acceptFrame(); // ACK
     peer.sendFrame().pushPromise(3, 2, Arrays.asList(
         new Header(Header.TARGET_METHOD, "GET"),
         new Header(Header.TARGET_SCHEME, "https"),
@@ -443,10 +455,7 @@
     peer.play();
 
     // play it back
-    Http2Connection connection = connectionBuilder(peer)
-        .pushObserver(PushObserver.CANCEL)
-        .build();
-    connection.start(false);
+    connect(peer, PushObserver.CANCEL, REFUSE_INCOMING_STREAMS);
 
     // verify the peer received what was expected
     InFrame rstStream = peer.takeFrame();
@@ -488,6 +497,8 @@
 
   @Test public void clientCreatesStreamAndServerReplies() throws Exception {
     // write the mocking script
+    peer.sendFrame().settings(new Settings());
+    peer.acceptFrame(); // ACK
     peer.acceptFrame(); // SYN_STREAM
     peer.acceptFrame(); // DATA
     peer.sendFrame().synReply(false, 3, headerEntries("a", "android"));
@@ -497,7 +508,7 @@
     peer.play();
 
     // play it back
-    Http2Connection connection = connection(peer);
+    Http2Connection connection = connect(peer);
     Http2Stream stream = connection.newStream(headerEntries("b", "banana"), true);
     BufferedSink out = Okio.buffer(stream.getSink());
     out.writeUtf8("c3po");
@@ -520,6 +531,8 @@
 
   @Test public void clientCreatesStreamAndServerRepliesWithFin() throws Exception {
     // write the mocking script
+    peer.sendFrame().settings(new Settings());
+    peer.acceptFrame(); // ACK
     peer.acceptFrame(); // SYN_STREAM
     peer.acceptFrame(); // PING
     peer.sendFrame().synReply(true, 3, headerEntries("a", "android"));
@@ -527,7 +540,7 @@
     peer.play();
 
     // play it back
-    Http2Connection connection = connection(peer);
+    Http2Connection connection = connect(peer);
     connection.newStream(headerEntries("b", "banana"), false);
     assertEquals(1, connection.openStreamCount());
     connection.ping().roundTripTime(); // Ensure that the SYN_REPLY has been received.
@@ -542,12 +555,14 @@
 
   @Test public void serverPingsClient() throws Exception {
     // write the mocking script
+    peer.sendFrame().settings(new Settings());
+    peer.acceptFrame(); // ACK
     peer.sendFrame().ping(false, 2, 0);
     peer.acceptFrame(); // PING
     peer.play();
 
     // play it back
-    connection(peer);
+    connect(peer);
 
     // verify the peer received what was expected
     InFrame ping = peer.takeFrame();
@@ -559,12 +574,14 @@
 
   @Test public void clientPingsServer() throws Exception {
     // write the mocking script
+    peer.sendFrame().settings(new Settings());
+    peer.acceptFrame(); // ACK
     peer.acceptFrame(); // PING
     peer.sendFrame().ping(true, 1, 5);
     peer.play();
 
     // play it back
-    Http2Connection connection = connection(peer);
+    Http2Connection connection = connect(peer);
     Ping ping = connection.ping();
     assertTrue(ping.roundTripTime() > 0);
     assertTrue(ping.roundTripTime() < TimeUnit.SECONDS.toNanos(1));
@@ -579,6 +596,8 @@
 
   @Test public void unexpectedPingIsNotReturned() throws Exception {
     // write the mocking script
+    peer.sendFrame().settings(new Settings());
+    peer.acceptFrame(); // ACK
     peer.sendFrame().ping(false, 2, 0);
     peer.acceptFrame(); // PING
     peer.sendFrame().ping(true, 3, 0); // This ping will not be returned.
@@ -587,7 +606,7 @@
     peer.play();
 
     // play it back
-    connection(peer);
+    connect(peer);
 
     // verify the peer received what was expected
     InFrame ping2 = peer.takeFrame();
@@ -601,6 +620,7 @@
     final Settings settings = new Settings();
     settings.set(MAX_CONCURRENT_STREAMS, 10);
     peer.sendFrame().settings(settings);
+    peer.acceptFrame(); // ACK
     peer.sendFrame().ping(false, 2, 0);
     peer.acceptFrame(); // PING
     peer.play();
@@ -618,12 +638,8 @@
         maxConcurrentStreamsUpdated.countDown();
       }
     };
-    Http2Connection connection = connectionBuilder(peer)
-        .listener(listener)
-        .build();
-    connection.start(false);
+    Http2Connection connection = connect(peer, IGNORE, listener);
 
-    peer.takeFrame(); // Guarantees that the peer Settings frame has been processed.
     synchronized (connection) {
       assertEquals(10, connection.peerSettings.getMaxConcurrentStreams(-1));
     }
@@ -650,9 +666,8 @@
     peer.play();
 
     // play it back
-    Http2Connection connection = connection(peer);
+    Http2Connection connection = connect(peer);
 
-    assertEquals(Http2.TYPE_SETTINGS, peer.takeFrame().type);
     assertEquals(Http2.TYPE_SETTINGS, peer.takeFrame().type);
     assertEquals(Http2.TYPE_PING, peer.takeFrame().type);
     synchronized (connection) {
@@ -670,14 +685,13 @@
     settings1.set(INITIAL_WINDOW_SIZE, 20000);
     settings1.set(MAX_FRAME_SIZE, 30000);
     peer.sendFrame().settings(settings1);
+    peer.acceptFrame(); // ACK
     peer.sendFrame().ping(false, 2, 0);
     peer.acceptFrame();
     peer.play();
 
     // play it back
-    Http2Connection connection = connection(peer);
-
-    peer.takeFrame(); // Guarantees that the Settings frame has been processed.
+    Http2Connection connection = connect(peer);
 
     // fake a settings frame with clear flag set.
     Settings settings2 = new Settings();
@@ -694,6 +708,8 @@
 
   @Test public void bogusDataFrameDoesNotDisruptConnection() throws Exception {
     // write the mocking script
+    peer.sendFrame().settings(new Settings());
+    peer.acceptFrame(); // ACK
     peer.sendFrame().data(true, 41, new Buffer().writeUtf8("bogus"), 5);
     peer.acceptFrame(); // RST_STREAM
     peer.sendFrame().ping(false, 2, 0);
@@ -701,7 +717,7 @@
     peer.play();
 
     // play it back
-    connection(peer);
+    connect(peer);
 
     // verify the peer received what was expected
     InFrame rstStream = peer.takeFrame();
@@ -714,13 +730,15 @@
 
   @Test public void bogusReplySilentlyIgnored() throws Exception {
     // write the mocking script
+    peer.sendFrame().settings(new Settings());
+    peer.acceptFrame(); // ACK
     peer.sendFrame().synReply(false, 41, headerEntries("a", "android"));
     peer.sendFrame().ping(false, 2, 0);
     peer.acceptFrame(); // PING
     peer.play();
 
     // play it back
-    connection(peer);
+    connect(peer);
 
     // verify the peer received what was expected
     InFrame ping = peer.takeFrame();
@@ -729,6 +747,8 @@
 
   @Test public void serverClosesClientOutputStream() throws Exception {
     // write the mocking script
+    peer.sendFrame().settings(new Settings());
+    peer.acceptFrame(); // ACK
     peer.acceptFrame(); // SYN_STREAM
     peer.sendFrame().rstStream(3, ErrorCode.CANCEL);
     peer.acceptFrame(); // PING
@@ -736,7 +756,7 @@
     peer.play();
 
     // play it back
-    Http2Connection connection = connection(peer);
+    Http2Connection connection = connect(peer);
     Http2Stream stream = connection.newStream(headerEntries("a", "android"), true);
     BufferedSink out = Okio.buffer(stream.getSink());
     connection.ping().roundTripTime(); // Ensure that the RST_CANCEL has been received.
@@ -770,12 +790,14 @@
    */
   @Test public void clientClosesClientInputStream() throws Exception {
     // write the mocking script
+    peer.sendFrame().settings(new Settings());
+    peer.acceptFrame(); // ACK
     peer.acceptFrame(); // SYN_STREAM
     peer.acceptFrame(); // RST_STREAM
     peer.play();
 
     // play it back
-    Http2Connection connection = connection(peer);
+    Http2Connection connection = connect(peer);
     Http2Stream stream = connection.newStream(headerEntries("a", "android"), false);
     Source in = stream.getSource();
     BufferedSink out = Okio.buffer(stream.getSink());
@@ -810,6 +832,8 @@
    */
   @Test public void clientClosesClientInputStreamIfOutputStreamIsClosed() throws Exception {
     // write the mocking script
+    peer.sendFrame().settings(new Settings());
+    peer.acceptFrame(); // ACK
     peer.acceptFrame(); // SYN_STREAM
     peer.acceptFrame(); // DATA
     peer.acceptFrame(); // DATA with FLAG_FIN
@@ -817,7 +841,7 @@
     peer.play();
 
     // play it back
-    Http2Connection connection = connection(peer);
+    Http2Connection connection = connect(peer);
     Http2Stream stream = connection.newStream(headerEntries("a", "android"), true);
     Source source = stream.getSource();
     BufferedSink out = Okio.buffer(stream.getSink());
@@ -852,6 +876,8 @@
 
   @Test public void serverClosesClientInputStream() throws Exception {
     // write the mocking script
+    peer.sendFrame().settings(new Settings());
+    peer.acceptFrame(); // ACK
     peer.acceptFrame(); // SYN_STREAM
     peer.sendFrame().synReply(false, 3, headerEntries("b", "banana"));
     peer.sendFrame().data(true, 3, new Buffer().writeUtf8("square"), 6);
@@ -860,7 +886,7 @@
     peer.play();
 
     // play it back
-    Http2Connection connection = connection(peer);
+    Http2Connection connection = connect(peer);
     Http2Stream stream = connection.newStream(headerEntries("a", "android"), false);
     Source source = stream.getSource();
     assertStreamData("square", source);
@@ -876,6 +902,8 @@
 
   @Test public void remoteDoubleSynReply() throws Exception {
     // write the mocking script
+    peer.sendFrame().settings(new Settings());
+    peer.acceptFrame(); // ACK
     peer.acceptFrame(); // SYN_STREAM
     peer.sendFrame().synReply(false, 3, headerEntries("a", "android"));
     peer.acceptFrame(); // PING
@@ -884,7 +912,7 @@
     peer.play();
 
     // play it back
-    Http2Connection connection = connection(peer);
+    Http2Connection connection = connect(peer);
     Http2Stream stream = connection.newStream(headerEntries("c", "cola"), false);
     assertEquals(headerEntries("a", "android"), stream.getResponseHeaders());
     connection.ping().roundTripTime(); // Ensure that the 2nd SYN REPLY has been received.
@@ -898,6 +926,8 @@
 
   @Test public void remoteSendsDataAfterInFinished() throws Exception {
     // write the mocking script
+    peer.sendFrame().settings(new Settings());
+    peer.acceptFrame(); // ACK
     peer.acceptFrame(); // SYN_STREAM
     peer.sendFrame().synReply(false, 3, headerEntries("a", "android"));
     peer.sendFrame().data(true, 3, new Buffer().writeUtf8("robot"), 5);
@@ -908,7 +938,7 @@
     peer.play();
 
     // play it back
-    Http2Connection connection = connection(peer);
+    Http2Connection connection = connect(peer);
     Http2Stream stream = connection.newStream(headerEntries("b", "banana"), false);
     assertEquals(headerEntries("a", "android"), stream.getResponseHeaders());
     assertStreamData("robot", stream.getSource());
@@ -927,6 +957,8 @@
   @Test public void clientDoesNotLimitFlowControl() throws Exception {
     int dataLength = 16384;
     // write the mocking script
+    peer.sendFrame().settings(new Settings());
+    peer.acceptFrame(); // ACK
     peer.acceptFrame(); // SYN_STREAM
     peer.sendFrame().synReply(false, 3, headerEntries("b", "banana"));
     peer.sendFrame().data(false, 3, new Buffer().write(new byte[dataLength]), dataLength);
@@ -939,7 +971,7 @@
     peer.play();
 
     // play it back
-    Http2Connection connection = connection(peer);
+    Http2Connection connection = connect(peer);
     Http2Stream stream = connection.newStream(headerEntries("a", "android"), false);
     assertEquals(headerEntries("b", "banana"), stream.getResponseHeaders());
 
@@ -953,6 +985,8 @@
 
   @Test public void remoteSendsRefusedStreamBeforeReplyHeaders() throws Exception {
     // write the mocking script
+    peer.sendFrame().settings(new Settings());
+    peer.acceptFrame(); // ACK
     peer.acceptFrame(); // SYN_STREAM
     peer.sendFrame().rstStream(3, ErrorCode.REFUSED_STREAM);
     peer.sendFrame().ping(false, 2, 0);
@@ -960,7 +994,7 @@
     peer.play();
 
     // play it back
-    Http2Connection connection = connection(peer);
+    Http2Connection connection = connect(peer);
     Http2Stream stream = connection.newStream(headerEntries("a", "android"), false);
     try {
       stream.getResponseHeaders();
@@ -980,6 +1014,8 @@
 
   @Test public void receiveGoAway() throws Exception {
     // write the mocking script
+    peer.sendFrame().settings(new Settings());
+    peer.acceptFrame(); // ACK
     peer.acceptFrame(); // SYN_STREAM 1
     peer.acceptFrame(); // SYN_STREAM 3
     peer.acceptFrame(); // PING.
@@ -989,7 +1025,7 @@
     peer.play();
 
     // play it back
-    Http2Connection connection = connection(peer);
+    Http2Connection connection = connect(peer);
     Http2Stream stream1 = connection.newStream(headerEntries("a", "android"), true);
     Http2Stream stream2 = connection.newStream(headerEntries("b", "banana"), true);
     connection.ping().roundTripTime(); // Ensure the GO_AWAY that resets stream2 has been received.
@@ -1029,6 +1065,8 @@
 
   @Test public void sendGoAway() throws Exception {
     // write the mocking script
+    peer.sendFrame().settings(new Settings());
+    peer.acceptFrame(); // ACK
     peer.acceptFrame(); // SYN_STREAM 1
     peer.acceptFrame(); // GOAWAY
     peer.acceptFrame(); // PING
@@ -1037,7 +1075,7 @@
     peer.play();
 
     // play it back
-    Http2Connection connection = connection(peer);
+    Http2Connection connection = connect(peer);
     connection.newStream(headerEntries("a", "android"), false);
     Ping ping = connection.ping();
     connection.shutdown(ErrorCode.PROTOCOL_ERROR);
@@ -1057,11 +1095,13 @@
 
   @Test public void noPingsAfterShutdown() throws Exception {
     // write the mocking script
+    peer.sendFrame().settings(new Settings());
+    peer.acceptFrame(); // ACK
     peer.acceptFrame(); // GOAWAY
     peer.play();
 
     // play it back
-    Http2Connection connection = connection(peer);
+    Http2Connection connection = connect(peer);
     connection.shutdown(ErrorCode.INTERNAL_ERROR);
     try {
       connection.ping();
@@ -1077,13 +1117,15 @@
 
   @Test public void close() throws Exception {
     // write the mocking script
+    peer.sendFrame().settings(new Settings());
+    peer.acceptFrame(); // ACK
     peer.acceptFrame(); // SYN_STREAM
     peer.acceptFrame(); // GOAWAY
     peer.acceptFrame(); // RST_STREAM
     peer.play();
 
     // play it back
-    Http2Connection connection = connection(peer);
+    Http2Connection connection = connect(peer);
     Http2Stream stream = connection.newStream(headerEntries("a", "android"), false);
     assertEquals(1, connection.openStreamCount());
     connection.close();
@@ -1120,12 +1162,14 @@
 
   @Test public void closeCancelsPings() throws Exception {
     // write the mocking script
+    peer.sendFrame().settings(new Settings());
+    peer.acceptFrame(); // ACK
     peer.acceptFrame(); // PING
     peer.acceptFrame(); // GOAWAY
     peer.play();
 
     // play it back
-    Http2Connection connection = connection(peer);
+    Http2Connection connection = connect(peer);
     Ping ping = connection.ping();
     connection.close();
     assertEquals(-1, ping.roundTripTime());
@@ -1133,12 +1177,14 @@
 
   @Test public void getResponseHeadersTimesOut() throws Exception {
     // write the mocking script
+    peer.sendFrame().settings(new Settings());
+    peer.acceptFrame(); // ACK
     peer.acceptFrame(); // SYN_STREAM
     peer.acceptFrame(); // RST_STREAM
     peer.play();
 
     // play it back
-    Http2Connection connection = connection(peer);
+    Http2Connection connection = connect(peer);
     Http2Stream stream = connection.newStream(headerEntries("b", "banana"), false);
     stream.readTimeout().timeout(500, TimeUnit.MILLISECONDS);
     long startNanos = System.nanoTime();
@@ -1159,13 +1205,15 @@
 
   @Test public void readTimesOut() throws Exception {
     // write the mocking script
+    peer.sendFrame().settings(new Settings());
+    peer.acceptFrame(); // ACK
     peer.acceptFrame(); // SYN_STREAM
     peer.sendFrame().synReply(false, 3, headerEntries("a", "android"));
     peer.acceptFrame(); // RST_STREAM
     peer.play();
 
     // play it back
-    Http2Connection connection = connection(peer);
+    Http2Connection connection = connect(peer);
     Http2Stream stream = connection.newStream(headerEntries("b", "banana"), false);
     stream.readTimeout().timeout(500, TimeUnit.MILLISECONDS);
     Source source = stream.getSource();
@@ -1190,9 +1238,9 @@
     Settings peerSettings = new Settings().set(INITIAL_WINDOW_SIZE, 5);
 
     // write the mocking script
-    peer.acceptFrame(); // PING
     peer.sendFrame().settings(peerSettings);
     peer.acceptFrame(); // ACK SETTINGS
+    peer.acceptFrame(); // PING
     peer.sendFrame().ping(true, 1, 0);
     peer.acceptFrame(); // SYN_STREAM
     peer.sendFrame().synReply(false, 3, headerEntries("a", "android"));
@@ -1201,7 +1249,7 @@
     peer.play();
 
     // play it back
-    Http2Connection connection = connection(peer);
+    Http2Connection connection = connect(peer);
     connection.ping().roundTripTime(); // Make sure settings have been received.
     Http2Stream stream = connection.newStream(headerEntries("b", "banana"), true);
     Sink sink = stream.getSink();
@@ -1221,7 +1269,6 @@
 
     // verify the peer received what was expected
     assertEquals(Http2.TYPE_PING, peer.takeFrame().type);
-    assertEquals(Http2.TYPE_SETTINGS, peer.takeFrame().type);
     assertEquals(Http2.TYPE_HEADERS, peer.takeFrame().type);
     assertEquals(Http2.TYPE_DATA, peer.takeFrame().type);
     assertEquals(Http2.TYPE_RST_STREAM, peer.takeFrame().type);
@@ -1233,9 +1280,9 @@
     Settings peerSettings = new Settings().set(INITIAL_WINDOW_SIZE, 5);
 
     // write the mocking script
-    peer.acceptFrame(); // PING
     peer.sendFrame().settings(peerSettings);
     peer.acceptFrame(); // ACK SETTINGS
+    peer.acceptFrame(); // PING
     peer.sendFrame().ping(true, 1, 0);
     peer.acceptFrame(); // SYN_STREAM
     peer.sendFrame().synReply(false, 3, headerEntries("a", "android"));
@@ -1247,7 +1294,7 @@
     peer.play();
 
     // play it back
-    Http2Connection connection = connection(peer);
+    Http2Connection connection = connect(peer);
     connection.ping().roundTripTime(); // Make sure settings have been acked.
     Http2Stream stream = connection.newStream(headerEntries("b", "banana"), true);
     connection.ping().roundTripTime(); // Make sure the window update has been received.
@@ -1267,7 +1314,6 @@
 
     // verify the peer received what was expected
     assertEquals(Http2.TYPE_PING, peer.takeFrame().type);
-    assertEquals(Http2.TYPE_SETTINGS, peer.takeFrame().type);
     assertEquals(Http2.TYPE_HEADERS, peer.takeFrame().type);
     assertEquals(Http2.TYPE_PING, peer.takeFrame().type);
     assertEquals(Http2.TYPE_DATA, peer.takeFrame().type);
@@ -1276,13 +1322,15 @@
 
   @Test public void outgoingWritesAreBatched() throws Exception {
     // write the mocking script
+    peer.sendFrame().settings(new Settings());
+    peer.acceptFrame(); // ACK
     peer.acceptFrame(); // SYN_STREAM
     peer.sendFrame().synReply(false, 3, headerEntries("a", "android"));
     peer.acceptFrame(); // DATA
     peer.play();
 
     // play it back
-    Http2Connection connection = connection(peer);
+    Http2Connection connection = connect(peer);
     Http2Stream stream = connection.newStream(headerEntries("b", "banana"), true);
 
     // two outgoing writes
@@ -1301,6 +1349,8 @@
 
   @Test public void headers() throws Exception {
     // write the mocking script
+    peer.sendFrame().settings(new Settings());
+    peer.acceptFrame(); // ACK
     peer.acceptFrame(); // SYN_STREAM
     peer.acceptFrame(); // PING
     peer.sendFrame().synReply(false, 3, headerEntries("a", "android"));
@@ -1309,7 +1359,7 @@
     peer.play();
 
     // play it back
-    Http2Connection connection = connection(peer);
+    Http2Connection connection = connect(peer);
     Http2Stream stream = connection.newStream(headerEntries("b", "banana"), true);
     connection.ping().roundTripTime(); // Ensure that the HEADERS has been received.
     assertEquals(headerEntries("a", "android", "c", "c3po"), stream.getResponseHeaders());
@@ -1326,6 +1376,8 @@
     int windowUpdateThreshold = 50;
 
     // Write the mocking script.
+    peer.sendFrame().settings(new Settings());
+    peer.acceptFrame(); // ACK
     peer.acceptFrame(); // SYN_STREAM
     peer.sendFrame().synReply(false, 3, headerEntries("a", "android"));
     for (int i = 0; i < 3; i++) {
@@ -1340,7 +1392,7 @@
     peer.play();
 
     // Play it back.
-    Http2Connection connection = connection(peer);
+    Http2Connection connection = connect(peer);
     connection.okHttpSettings.set(INITIAL_WINDOW_SIZE, windowSize);
     Http2Stream stream = connection.newStream(headerEntries("b", "banana"), false);
     assertEquals(0, stream.unacknowledgedBytesRead);
@@ -1368,31 +1420,35 @@
 
   @Test public void serverSendsEmptyDataClientDoesntSendWindowUpdate() throws Exception {
     // Write the mocking script.
+    peer.sendFrame().settings(new Settings());
+    peer.acceptFrame(); // ACK
     peer.acceptFrame(); // SYN_STREAM
     peer.sendFrame().synReply(false, 3, headerEntries("a", "android"));
     peer.sendFrame().data(true, 3, data(0), 0);
     peer.play();
 
     // Play it back.
-    Http2Connection connection = connection(peer);
+    Http2Connection connection = connect(peer);
     Http2Stream client = connection.newStream(headerEntries("b", "banana"), false);
     assertEquals(-1, client.getSource().read(new Buffer(), 1));
 
     // Verify the peer received what was expected.
     InFrame synStream = peer.takeFrame();
     assertEquals(Http2.TYPE_HEADERS, synStream.type);
-    assertEquals(3, peer.frameCount());
+    assertEquals(5, peer.frameCount());
   }
 
   @Test public void clientSendsEmptyDataServerDoesntSendWindowUpdate() throws Exception {
     // Write the mocking script.
+    peer.sendFrame().settings(new Settings());
+    peer.acceptFrame(); // ACK
     peer.acceptFrame(); // SYN_STREAM
     peer.acceptFrame(); // DATA
     peer.sendFrame().synReply(false, 3, headerEntries("a", "android"));
     peer.play();
 
     // Play it back.
-    Http2Connection connection = connection(peer);
+    Http2Connection connection = connect(peer);
     Http2Stream client = connection.newStream(headerEntries("b", "banana"), true);
     BufferedSink out = Okio.buffer(client.getSink());
     out.write(Util.EMPTY_BYTE_ARRAY);
@@ -1402,11 +1458,13 @@
     // Verify the peer received what was expected.
     assertEquals(Http2.TYPE_HEADERS, peer.takeFrame().type);
     assertEquals(Http2.TYPE_DATA, peer.takeFrame().type);
-    assertEquals(3, peer.frameCount());
+    assertEquals(5, peer.frameCount());
   }
 
   @Test public void testTruncatedDataFrame() throws Exception {
     // write the mocking script
+    peer.sendFrame().settings(new Settings());
+    peer.acceptFrame(); // ACK
     peer.acceptFrame(); // SYN_STREAM
     peer.sendFrame().synReply(false, 3, headerEntries("a", "android"));
     peer.sendFrame().data(false, 3, data(1024), 1024);
@@ -1414,7 +1472,7 @@
     peer.play();
 
     // play it back
-    Http2Connection connection = connection(peer);
+    Http2Connection connection = connect(peer);
     Http2Stream stream = connection.newStream(headerEntries("b", "banana"), false);
     assertEquals(headerEntries("a", "android"), stream.getResponseHeaders());
     Source in = stream.getSource();
@@ -1430,6 +1488,8 @@
     int framesThatFillWindow = roundUp(DEFAULT_INITIAL_WINDOW_SIZE, peer.maxOutboundDataLength());
 
     // Write the mocking script. This accepts more data frames than necessary!
+    peer.sendFrame().settings(new Settings());
+    peer.acceptFrame(); // SETTINGS ACK
     peer.acceptFrame(); // SYN_STREAM on stream 1
     for (int i = 0; i < framesThatFillWindow; i++) {
       peer.acceptFrame(); // DATA on stream 1
@@ -1439,7 +1499,7 @@
     peer.play();
 
     // Play it back.
-    Http2Connection connection = connection(peer);
+    Http2Connection connection = connect(peer);
     Http2Stream stream1 = connection.newStream(headerEntries("a", "apple"), true);
     BufferedSink out1 = Okio.buffer(stream1.getSink());
     out1.write(new byte[DEFAULT_INITIAL_WINDOW_SIZE]);
@@ -1466,6 +1526,34 @@
     assertEquals(DEFAULT_INITIAL_WINDOW_SIZE - 3, connection.getStream(5).bytesLeftInWriteWindow);
   }
 
+  @Test public void remoteOmitsInitialSettings() throws Exception {
+    // Write the mocking script. Note no SETTINGS frame is sent or acknowledged.
+    peer.acceptFrame(); // SYN_STREAM
+    peer.sendFrame().synReply(false, 3, headerEntries("a", "android"));
+    peer.acceptFrame(); // GOAWAY
+    peer.play();
+
+    Http2Connection connection = new Http2Connection.Builder(true)
+        .socket(peer.openSocket())
+        .build();
+    connection.start(false);
+
+    Http2Stream stream = connection.newStream(headerEntries("b", "banana"), false);
+    try {
+      stream.getResponseHeaders();
+      fail();
+    } catch (IOException expected) {
+      assertEquals("stream was reset: PROTOCOL_ERROR", expected.getMessage());
+    }
+
+    // verify the peer received what was expected
+    InFrame synStream = peer.takeFrame();
+    assertEquals(Http2.TYPE_HEADERS, synStream.type);
+    InFrame goaway = peer.takeFrame();
+    assertEquals(Http2.TYPE_GOAWAY, goaway.type);
+    assertEquals(ErrorCode.PROTOCOL_ERROR, goaway.errorCode);
+  }
+
   private Buffer data(int byteCount) {
     return new Buffer().write(new byte[byteCount]);
   }
@@ -1496,17 +1584,27 @@ static int roundUp(int num, int divisor) {
     return (num + divisor - 1) / divisor;
   }
 
-  private Http2Connection sendHttp2SettingsAndCheckForAck(boolean client, Settings settings)
-      throws IOException, InterruptedException {
+  private Http2Connection connectWithSettings(boolean client, Settings settings) throws Exception {
     peer.setClient(client);
     peer.sendFrame().settings(settings);
     peer.acceptFrame(); // ACK
-    peer.acceptFrame(); // PING
-    peer.sendFrame().ping(true, 1, 0);
     peer.play();
+    return connect(peer);
+  }
 
-    // play it back
-    Http2Connection connection = connection(peer);
+  private Http2Connection connect(MockHttp2Peer peer) throws Exception {
+    return connect(peer, IGNORE, REFUSE_INCOMING_STREAMS);
+  }
+
+  /** Builds a new connection to {@code peer} with settings acked. */
+  private Http2Connection connect(MockHttp2Peer peer, PushObserver pushObserver,
+      Http2Connection.Listener listener) throws Exception {
+    Http2Connection connection = new Http2Connection.Builder(true)
+        .socket(peer.openSocket())
+        .pushObserver(pushObserver)
+        .listener(listener)
+        .build();
+    connection.start(false);
 
     // verify the peer received the ACK
     InFrame ackFrame = peer.takeFrame();
@@ -1514,22 +1612,9 @@ private Http2Connection sendHttp2SettingsAndCheckForAck(boolean client, Settings
     assertEquals(0, ackFrame.streamId);
     assertTrue(ackFrame.ack);
 
-    connection.ping().roundTripTime(); // Ensure that settings have been applied before returning.
     return connection;
   }
 
-  private Http2Connection connection(MockHttp2Peer peer) throws IOException {
-    Http2Connection connection = connectionBuilder(peer).build();
-    connection.start(false);
-    return connection;
-  }
-
-  private Http2Connection.Builder connectionBuilder(MockHttp2Peer peer) throws IOException {
-    return new Http2Connection.Builder(true)
-        .socket(peer.openSocket())
-        .pushObserver(IGNORE);
-  }
-
   static final PushObserver IGNORE = new PushObserver() {
 
     @Override public boolean onRequest(int streamId, List<Header> requestHeaders) {
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/http2/Http2Test.java b/okhttp-tests/src/test/java/okhttp3/internal/http2/Http2Test.java
index 548dbe0207..e435a09e5b 100644
--- a/okhttp-tests/src/test/java/okhttp3/internal/http2/Http2Test.java
+++ b/okhttp-tests/src/test/java/okhttp3/internal/http2/Http2Test.java
@@ -52,7 +52,7 @@
     frame.writeInt(expectedStreamId);
     frame.writeInt(111111111); // custom data
 
-    reader.nextFrame(new BaseTestHandler()); // Should not callback.
+    reader.nextFrame(false, new BaseTestHandler()); // Should not callback.
   }
 
   @Test public void onlyOneLiteralHeadersFrame() throws IOException {
@@ -67,7 +67,7 @@
 
     assertEquals(frame, sendHeaderFrames(true, sentHeaders)); // Check writer sends the same bytes.
 
-    reader.nextFrame(new BaseTestHandler() {
+    reader.nextFrame(false, new BaseTestHandler() {
       @Override public void headers(boolean inFinished, int streamId,
           int associatedStreamId, List<Header> headerBlock) {
         assertTrue(inFinished);
@@ -90,7 +90,7 @@
     frame.writeByte(255); // Heaviest weight, zero-indexed.
     frame.writeAll(headerBytes);
 
-    reader.nextFrame(new BaseTestHandler() {
+    reader.nextFrame(false, new BaseTestHandler() {
       @Override public void priority(int streamId, int streamDependency, int weight,
           boolean exclusive) {
         assertEquals(0, streamDependency);
@@ -131,7 +131,7 @@
     assertEquals(frame, sendHeaderFrames(false, sentHeaders)); // Check writer sends the same bytes.
 
     // Reading the above frames should result in a concatenated headerBlock.
-    reader.nextFrame(new BaseTestHandler() {
+    reader.nextFrame(false, new BaseTestHandler() {
       @Override public void headers(boolean inFinished, int streamId,
           int associatedStreamId, List<Header> headerBlock) {
         assertFalse(inFinished);
@@ -163,7 +163,7 @@
 
     assertEquals(frame, sendPushPromiseFrames(expectedPromisedStreamId, pushPromise));
 
-    reader.nextFrame(new BaseTestHandler() {
+    reader.nextFrame(false, new BaseTestHandler() {
       @Override
       public void pushPromise(int streamId, int promisedStreamId, List<Header> headerBlock) {
         assertEquals(expectedStreamId, streamId);
@@ -199,7 +199,7 @@ public void pushPromise(int streamId, int promisedStreamId, List<Header> headerB
     assertEquals(frame, sendPushPromiseFrames(expectedPromisedStreamId, pushPromise));
 
     // Reading the above frames should result in a concatenated headerBlock.
-    reader.nextFrame(new BaseTestHandler() {
+    reader.nextFrame(false, new BaseTestHandler() {
       @Override
       public void pushPromise(int streamId, int promisedStreamId, List<Header> headerBlock) {
         assertEquals(expectedStreamId, streamId);
@@ -216,7 +216,7 @@ public void pushPromise(int streamId, int promisedStreamId, List<Header> headerB
     frame.writeInt(expectedStreamId & 0x7fffffff);
     frame.writeInt(ErrorCode.PROTOCOL_ERROR.httpCode);
 
-    reader.nextFrame(new BaseTestHandler() {
+    reader.nextFrame(false, new BaseTestHandler() {
       @Override public void rstStream(int streamId, ErrorCode errorCode) {
         assertEquals(expectedStreamId, streamId);
         assertEquals(ErrorCode.PROTOCOL_ERROR, errorCode);
@@ -236,7 +236,7 @@ public void pushPromise(int streamId, int promisedStreamId, List<Header> headerB
     frame.writeShort(2); // SETTINGS_ENABLE_PUSH
     frame.writeInt(0);
 
-    reader.nextFrame(new BaseTestHandler() {
+    reader.nextFrame(false, new BaseTestHandler() {
       @Override public void settings(boolean clearPrevious, Settings settings) {
         assertFalse(clearPrevious); // No clearPrevious in HTTP/2.
         assertEquals(reducedTableSizeBytes, settings.getHeaderTableSize());
@@ -254,7 +254,7 @@ public void pushPromise(int streamId, int promisedStreamId, List<Header> headerB
     frame.writeInt(2);
 
     try {
-      reader.nextFrame(new BaseTestHandler());
+      reader.nextFrame(false, new BaseTestHandler());
       fail();
     } catch (IOException e) {
       assertEquals("PROTOCOL_ERROR SETTINGS_ENABLE_PUSH != 0 or 1", e.getMessage());
@@ -270,7 +270,7 @@ public void pushPromise(int streamId, int promisedStreamId, List<Header> headerB
     frame.writeInt(1);
 
     final AtomicInteger settingValue = new AtomicInteger();
-    reader.nextFrame(new BaseTestHandler() {
+    reader.nextFrame(false, new BaseTestHandler() {
       @Override public void settings(boolean clearPrevious, Settings settings) {
         settingValue.set(settings.get(7));
       }
@@ -287,7 +287,7 @@ public void pushPromise(int streamId, int promisedStreamId, List<Header> headerB
     frame.writeInt(Integer.MIN_VALUE);
 
     try {
-      reader.nextFrame(new BaseTestHandler());
+      reader.nextFrame(false, new BaseTestHandler());
       fail();
     } catch (IOException e) {
       assertEquals("PROTOCOL_ERROR SETTINGS_INITIAL_WINDOW_SIZE > 2^31 - 1", e.getMessage());
@@ -303,7 +303,7 @@ public void pushPromise(int streamId, int promisedStreamId, List<Header> headerB
     frame.writeInt(Integer.MIN_VALUE);
 
     try {
-      reader.nextFrame(new BaseTestHandler());
+      reader.nextFrame(false, new BaseTestHandler());
       fail();
     } catch (IOException e) {
       assertEquals("PROTOCOL_ERROR SETTINGS_MAX_FRAME_SIZE: -2147483648", e.getMessage());
@@ -319,7 +319,7 @@ public void pushPromise(int streamId, int promisedStreamId, List<Header> headerB
     frame.writeInt((int) Math.pow(2, 14) - 1);
 
     try {
-      reader.nextFrame(new BaseTestHandler());
+      reader.nextFrame(false, new BaseTestHandler());
       fail();
     } catch (IOException e) {
       assertEquals("PROTOCOL_ERROR SETTINGS_MAX_FRAME_SIZE: 16383", e.getMessage());
@@ -335,7 +335,7 @@ public void pushPromise(int streamId, int promisedStreamId, List<Header> headerB
     frame.writeInt((int) Math.pow(2, 24));
 
     try {
-      reader.nextFrame(new BaseTestHandler());
+      reader.nextFrame(false, new BaseTestHandler());
       fail();
     } catch (IOException e) {
       assertEquals("PROTOCOL_ERROR SETTINGS_MAX_FRAME_SIZE: 16777216", e.getMessage());
@@ -356,7 +356,7 @@ public void pushPromise(int streamId, int promisedStreamId, List<Header> headerB
     // Check writer sends the same bytes.
     assertEquals(frame, sendPingFrame(true, expectedPayload1, expectedPayload2));
 
-    reader.nextFrame(new BaseTestHandler() {
+    reader.nextFrame(false, new BaseTestHandler() {
       @Override public void ping(boolean ack, int payload1, int payload2) {
         assertTrue(ack);
         assertEquals(expectedPayload1, payload1);
@@ -378,7 +378,7 @@ public void pushPromise(int streamId, int promisedStreamId, List<Header> headerB
     // Check writer sends the same bytes.
     assertEquals(frame, sendDataFrame(new Buffer().write(expectedData)));
 
-    reader.nextFrame(new BaseTestHandler() {
+    reader.nextFrame(false, new BaseTestHandler() {
       @Override public void data(boolean inFinished, int streamId, BufferedSource source,
           int length) throws IOException {
         assertFalse(inFinished);
@@ -406,7 +406,7 @@ public void pushPromise(int streamId, int promisedStreamId, List<Header> headerB
     zipped.readAll(frame);
 
     try {
-      reader.nextFrame(new BaseTestHandler());
+      reader.nextFrame(false, new BaseTestHandler());
       fail();
     } catch (IOException e) {
       assertEquals("PROTOCOL_ERROR: FLAG_COMPRESSED without SETTINGS_COMPRESS_DATA",
@@ -431,7 +431,7 @@ public void pushPromise(int streamId, int promisedStreamId, List<Header> headerB
     frame.write(expectedData);
     frame.write(padding);
 
-    reader.nextFrame(assertData());
+    reader.nextFrame(false, assertData());
     assertTrue(frame.exhausted()); // Padding was skipped.
   }
 
@@ -447,7 +447,7 @@ public void pushPromise(int streamId, int promisedStreamId, List<Header> headerB
     frame.writeByte(0);
     frame.write(expectedData);
 
-    reader.nextFrame(assertData());
+    reader.nextFrame(false, assertData());
   }
 
   @Test public void readPaddedHeadersFrame() throws IOException {
@@ -464,7 +464,7 @@ public void pushPromise(int streamId, int promisedStreamId, List<Header> headerB
     frame.writeAll(headerBlock);
     frame.write(padding);
 
-    reader.nextFrame(assertHeaderBlock());
+    reader.nextFrame(false, assertHeaderBlock());
     assertTrue(frame.exhausted()); // Padding was skipped.
   }
 
@@ -477,7 +477,7 @@ public void pushPromise(int streamId, int promisedStreamId, List<Header> headerB
     frame.writeByte(0);
     frame.writeAll(headerBlock);
 
-    reader.nextFrame(assertHeaderBlock());
+    reader.nextFrame(false, assertHeaderBlock());
   }
 
   /** Headers are compressed, then framed. */
@@ -505,7 +505,7 @@ public void pushPromise(int streamId, int promisedStreamId, List<Header> headerB
     frame.writeInt(expectedStreamId & 0x7fffffff);
     frame.writeAll(headerBlock);
 
-    reader.nextFrame(assertHeaderBlock());
+    reader.nextFrame(false, assertHeaderBlock());
     assertTrue(frame.exhausted());
   }
 
@@ -530,7 +530,7 @@ public void pushPromise(int streamId, int promisedStreamId, List<Header> headerB
     // Check writer sends the same bytes.
     assertEquals(frame, windowUpdate(expectedWindowSizeIncrement));
 
-    reader.nextFrame(new BaseTestHandler() {
+    reader.nextFrame(false, new BaseTestHandler() {
       @Override public void windowUpdate(int streamId, long windowSizeIncrement) {
         assertEquals(expectedStreamId, streamId);
         assertEquals(expectedWindowSizeIncrement, windowSizeIncrement);
@@ -568,7 +568,7 @@ public void pushPromise(int streamId, int promisedStreamId, List<Header> headerB
     // Check writer sends the same bytes.
     assertEquals(frame, sendGoAway(expectedStreamId, expectedError, Util.EMPTY_BYTE_ARRAY));
 
-    reader.nextFrame(new BaseTestHandler() {
+    reader.nextFrame(false, new BaseTestHandler() {
       @Override public void goAway(
           int lastGoodStreamId, ErrorCode errorCode, ByteString debugData) {
         assertEquals(expectedStreamId, lastGoodStreamId);
@@ -594,7 +594,7 @@ public void pushPromise(int streamId, int promisedStreamId, List<Header> headerB
     // Check writer sends the same bytes.
     assertEquals(frame, sendGoAway(0, expectedError, expectedData.toByteArray()));
 
-    reader.nextFrame(new BaseTestHandler() {
+    reader.nextFrame(false, new BaseTestHandler() {
       @Override public void goAway(
           int lastGoodStreamId, ErrorCode errorCode, ByteString debugData) {
         assertEquals(0, lastGoodStreamId);
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/http2/MockHttp2Peer.java b/okhttp-tests/src/test/java/okhttp3/internal/http2/MockHttp2Peer.java
index 9a5b946f7f..fe5f82fd4a 100644
--- a/okhttp-tests/src/test/java/okhttp3/internal/http2/MockHttp2Peer.java
+++ b/okhttp-tests/src/test/java/okhttp3/internal/http2/MockHttp2Peer.java
@@ -171,7 +171,7 @@ private void readAndWriteFrames() throws IOException {
       } else {
         // read a frame
         InFrame inFrame = new InFrame(i, reader);
-        reader.nextFrame(inFrame);
+        reader.nextFrame(false, inFrame);
         inFrames.add(inFrame);
       }
     }
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/tls/ClientAuthTest.java b/okhttp-tests/src/test/java/okhttp3/internal/tls/ClientAuthTest.java
index 6adbb51b69..3de1adba1d 100644
--- a/okhttp-tests/src/test/java/okhttp3/internal/tls/ClientAuthTest.java
+++ b/okhttp-tests/src/test/java/okhttp3/internal/tls/ClientAuthTest.java
@@ -40,7 +40,7 @@
   @Rule public final MockWebServer server = new MockWebServer();
 
   public enum ClientAuth {
-    NONE, WANTS, NEEDS;
+    NONE, WANTS, NEEDS
   }
 
   private HeldCertificate serverRootCa;
@@ -51,7 +51,7 @@
   private HeldCertificate clientCert;
 
   @Before
-  public void initialise() throws GeneralSecurityException {
+  public void setUp() throws GeneralSecurityException {
     serverRootCa = new HeldCertificate.Builder()
         .serialNumber("1")
         .ca(3)
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/ws/RealWebSocketTest.java b/okhttp-tests/src/test/java/okhttp3/internal/ws/RealWebSocketTest.java
index 8ffa80214b..f91fafd63b 100644
--- a/okhttp-tests/src/test/java/okhttp3/internal/ws/RealWebSocketTest.java
+++ b/okhttp-tests/src/test/java/okhttp3/internal/ws/RealWebSocketTest.java
@@ -19,10 +19,10 @@
 import java.io.IOException;
 import java.net.ProtocolException;
 import java.util.Random;
+import java.util.concurrent.TimeUnit;
 import okhttp3.Protocol;
 import okhttp3.Request;
 import okhttp3.Response;
-import okio.BufferedSink;
 import okio.ByteString;
 import okio.Okio;
 import okio.Pipe;
@@ -31,6 +31,7 @@
 import org.junit.Ignore;
 import org.junit.Test;
 
+import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertFalse;
 import static org.junit.Assert.assertTrue;
 
@@ -39,273 +40,296 @@
   // zero effect on the behavior of the WebSocket API which is why tests are only written once
   // from the perspective of a single peer.
 
-  private RealWebSocket client;
-  private boolean clientConnectionCloseThrows;
-  private boolean clientConnectionClosed;
+  private final Random random = new Random(0);
   private final Pipe client2Server = new Pipe(1024L);
-  private final BufferedSink client2ServerSink = Okio.buffer(client2Server.sink());
-  private final WebSocketRecorder clientListener = new WebSocketRecorder("client");
-
-  private RealWebSocket server;
-  private boolean serverConnectionClosed;
   private final Pipe server2client = new Pipe(1024L);
-  private final BufferedSink server2clientSink = Okio.buffer(server2client.sink());
-  private final WebSocketRecorder serverListener = new WebSocketRecorder("server");
+
+  private TestStreams client = new TestStreams(true, server2client, client2Server);
+  private TestStreams server = new TestStreams(false, client2Server, server2client);
 
   @Before public void setUp() throws IOException {
-    Random random = new Random(0);
-    String url = "http://example.com/websocket";
-    final Response response = new Response.Builder()
-        .code(101)
-        .request(new Request.Builder().url(url).build())
-        .protocol(Protocol.HTTP_1_1)
-        .build();
-
-    client = new RealWebSocket(response.request(), clientListener, random);
-    client.initReaderAndWriter(new RealWebSocket.Streams(
-        true, Okio.buffer(server2client.source()), client2ServerSink) {
-      @Override public void close() throws IOException {
-        source.close();
-        sink.close();
-        if (clientConnectionClosed) {
-          throw new AssertionError("Already closed");
-        }
-        clientConnectionClosed = true;
-
-        if (clientConnectionCloseThrows) {
-          throw new RuntimeException("Oops!");
-        }
-      }
-    });
-
-    server = new RealWebSocket(response.request(), serverListener, random);
-    server.initReaderAndWriter(new RealWebSocket.Streams(
-        false, Okio.buffer(client2Server.source()), server2clientSink) {
-      @Override public void close() throws IOException {
-        source.close();
-        sink.close();
-        if (serverConnectionClosed) {
-          throw new AssertionError("Already closed");
-        }
-        serverConnectionClosed = true;
-      }
-    });
+    client.initWebSocket(random, 0);
+    server.initWebSocket(random, 0);
   }
 
   @After public void tearDown() {
-    clientListener.assertExhausted();
-    serverListener.assertExhausted();
+    client.listener.assertExhausted();
+    server.listener.assertExhausted();
   }
 
   @Test public void close() throws IOException {
-    client.close(1000, "Hello!");
+    client.webSocket.close(1000, "Hello!");
     assertFalse(server.processNextFrame()); // This will trigger a close response.
-    serverListener.assertClosing(1000, "Hello!");
-    server.close(1000, "Goodbye!");
+    server.listener.assertClosing(1000, "Hello!");
+    server.webSocket.close(1000, "Goodbye!");
     assertFalse(client.processNextFrame());
-    clientListener.assertClosing(1000, "Goodbye!");
-    serverListener.assertClosed(1000, "Hello!");
-    clientListener.assertClosed(1000, "Goodbye!");
+    client.listener.assertClosing(1000, "Goodbye!");
+    server.listener.assertClosed(1000, "Hello!");
+    client.listener.assertClosed(1000, "Goodbye!");
   }
 
   @Test public void clientCloseThenMethodsReturnFalse() throws IOException {
-    client.close(1000, "Hello!");
+    client.webSocket.close(1000, "Hello!");
 
-    assertFalse(client.close(1000, "Hello!"));
-    assertFalse(client.send("Hello!"));
+    assertFalse(client.webSocket.close(1000, "Hello!"));
+    assertFalse(client.webSocket.send("Hello!"));
   }
 
   @Test public void afterSocketClosedPingFailsWebSocket() throws IOException {
     client2Server.source().close();
-    client.pong(ByteString.encodeUtf8("Ping!"));
-    clientListener.assertFailure(IOException.class, "source is closed");
+    client.webSocket.pong(ByteString.encodeUtf8("Ping!"));
+    client.listener.assertFailure(IOException.class, "source is closed");
 
-    assertFalse(client.send("Hello!"));
+    assertFalse(client.webSocket.send("Hello!"));
   }
 
   @Test public void socketClosedDuringMessageKillsWebSocket() throws IOException {
     client2Server.source().close();
 
-    assertTrue(client.send("Hello!"));
-    clientListener.assertFailure(IOException.class, "source is closed");
+    assertTrue(client.webSocket.send("Hello!"));
+    client.listener.assertFailure(IOException.class, "source is closed");
 
     // A failed write prevents further use of the WebSocket instance.
-    assertFalse(client.send("Hello!"));
-    assertFalse(client.pong(ByteString.encodeUtf8("Ping!")));
+    assertFalse(client.webSocket.send("Hello!"));
+    assertFalse(client.webSocket.pong(ByteString.encodeUtf8("Ping!")));
   }
 
   @Test public void serverCloseThenWritingPingSucceeds() throws IOException {
-    server.close(1000, "Hello!");
+    server.webSocket.close(1000, "Hello!");
     client.processNextFrame();
-    clientListener.assertClosing(1000, "Hello!");
+    client.listener.assertClosing(1000, "Hello!");
 
-    assertTrue(client.pong(ByteString.encodeUtf8("Pong?")));
+    assertTrue(client.webSocket.pong(ByteString.encodeUtf8("Pong?")));
   }
 
   @Test public void clientCanWriteMessagesAfterServerClose() throws IOException {
-    server.close(1000, "Hello!");
+    server.webSocket.close(1000, "Hello!");
     client.processNextFrame();
-    clientListener.assertClosing(1000, "Hello!");
+    client.listener.assertClosing(1000, "Hello!");
 
-    assertTrue(client.send("Hi!"));
+    assertTrue(client.webSocket.send("Hi!"));
     server.processNextFrame();
-    serverListener.assertTextMessage("Hi!");
+    server.listener.assertTextMessage("Hi!");
   }
 
   @Test public void serverCloseThenClientClose() throws IOException {
-    server.close(1000, "Hello!");
+    server.webSocket.close(1000, "Hello!");
     client.processNextFrame();
-    clientListener.assertClosing(1000, "Hello!");
-    assertTrue(client.close(1000, "Bye!"));
+    client.listener.assertClosing(1000, "Hello!");
+    assertTrue(client.webSocket.close(1000, "Bye!"));
   }
 
   @Test public void emptyCloseInitiatesShutdown() throws IOException {
-    server2clientSink.write(ByteString.decodeHex("8800")).emit(); // Close without code.
+    server.sink.write(ByteString.decodeHex("8800")).emit(); // Close without code.
     client.processNextFrame();
-    clientListener.assertClosing(1005, "");
+    client.listener.assertClosing(1005, "");
 
-    assertTrue(client.close(1000, "Bye!"));
+    assertTrue(client.webSocket.close(1000, "Bye!"));
     server.processNextFrame();
-    serverListener.assertClosing(1000, "Bye!");
+    server.listener.assertClosing(1000, "Bye!");
 
-    clientListener.assertClosed(1005, "");
+    client.listener.assertClosed(1005, "");
   }
 
   @Test public void clientCloseClosesConnection() throws IOException {
-    client.close(1000, "Hello!");
-    assertFalse(clientConnectionClosed);
+    client.webSocket.close(1000, "Hello!");
+    assertFalse(client.closed);
     server.processNextFrame(); // Read client closing, send server close.
-    serverListener.assertClosing(1000, "Hello!");
+    server.listener.assertClosing(1000, "Hello!");
 
-    server.close(1000, "Goodbye!");
+    server.webSocket.close(1000, "Goodbye!");
     client.processNextFrame(); // Read server closing, close connection.
-    assertTrue(clientConnectionClosed);
-    clientListener.assertClosing(1000, "Goodbye!");
+    assertTrue(client.closed);
+    client.listener.assertClosing(1000, "Goodbye!");
 
     // Server and client both finished closing, connection is closed.
-    serverListener.assertClosed(1000, "Hello!");
-    clientListener.assertClosed(1000, "Goodbye!");
+    server.listener.assertClosed(1000, "Hello!");
+    client.listener.assertClosed(1000, "Goodbye!");
   }
 
   @Test public void serverCloseClosesConnection() throws IOException {
-    server.close(1000, "Hello!");
+    server.webSocket.close(1000, "Hello!");
 
     client.processNextFrame(); // Read server close, send client close, close connection.
-    assertFalse(clientConnectionClosed);
-    clientListener.assertClosing(1000, "Hello!");
+    assertFalse(client.closed);
+    client.listener.assertClosing(1000, "Hello!");
 
-    client.close(1000, "Hello!");
+    client.webSocket.close(1000, "Hello!");
     server.processNextFrame();
-    serverListener.assertClosing(1000, "Hello!");
+    server.listener.assertClosing(1000, "Hello!");
 
-    clientListener.assertClosed(1000, "Hello!");
-    serverListener.assertClosed(1000, "Hello!");
+    client.listener.assertClosed(1000, "Hello!");
+    server.listener.assertClosed(1000, "Hello!");
   }
 
-  @Test public void clientAndServerCloseClosesConnection() throws IOException {
+  @Test public void clientAndServerCloseClosesConnection() throws Exception {
     // Send close from both sides at the same time.
-    server.close(1000, "Hello!");
+    server.webSocket.close(1000, "Hello!");
     client.processNextFrame(); // Read close, close connection close.
 
-    assertFalse(clientConnectionClosed);
-    client.close(1000, "Hi!");
+    assertFalse(client.closed);
+    client.webSocket.close(1000, "Hi!");
     server.processNextFrame();
 
-    clientListener.assertClosing(1000, "Hello!");
-    serverListener.assertClosing(1000, "Hi!");
-    clientListener.assertClosed(1000, "Hello!");
-    serverListener.assertClosed(1000, "Hi!");
-    assertTrue(clientConnectionClosed);
+    client.listener.assertClosing(1000, "Hello!");
+    server.listener.assertClosing(1000, "Hi!");
+    client.listener.assertClosed(1000, "Hello!");
+    server.listener.assertClosed(1000, "Hi!");
+    client.webSocket.awaitTermination(5, TimeUnit.SECONDS);
+    assertTrue(client.closed);
 
-    serverListener.assertExhausted(); // Client should not have sent second close.
-    clientListener.assertExhausted(); // Server should not have sent second close.
+    server.listener.assertExhausted(); // Client should not have sent second close.
+    client.listener.assertExhausted(); // Server should not have sent second close.
   }
 
   @Test public void serverCloseBreaksReadMessageLoop() throws IOException {
-    server.send("Hello!");
-    server.close(1000, "Bye!");
+    server.webSocket.send("Hello!");
+    server.webSocket.close(1000, "Bye!");
     assertTrue(client.processNextFrame());
-    clientListener.assertTextMessage("Hello!");
+    client.listener.assertTextMessage("Hello!");
     assertFalse(client.processNextFrame());
-    clientListener.assertClosing(1000, "Bye!");
+    client.listener.assertClosing(1000, "Bye!");
   }
 
   @Test public void protocolErrorBeforeCloseSendsFailure() throws IOException {
-    server2clientSink.write(ByteString.decodeHex("0a00")).emit(); // Invalid non-final ping frame.
+    server.sink.write(ByteString.decodeHex("0a00")).emit(); // Invalid non-final ping frame.
 
     client.processNextFrame(); // Detects error, send close, close connection.
-    assertTrue(clientConnectionClosed);
-    clientListener.assertFailure(ProtocolException.class, "Control frames must be final.");
+    assertTrue(client.closed);
+    client.listener.assertFailure(ProtocolException.class, "Control frames must be final.");
 
     server.processNextFrame();
-    serverListener.assertFailure(EOFException.class, null);
+    server.listener.assertFailure(EOFException.class, null);
   }
 
   @Test public void protocolErrorInCloseResponseClosesConnection() throws IOException {
-    client.close(1000, "Hello");
+    client.webSocket.close(1000, "Hello");
     server.processNextFrame();
-    assertFalse(clientConnectionClosed); // Not closed until close reply is received.
+    assertFalse(client.closed); // Not closed until close reply is received.
 
     // Manually write an invalid masked close frame.
-    server2clientSink.write(ByteString.decodeHex("888760b420bb635c68de0cd84f")).emit();
+    server.sink.write(ByteString.decodeHex("888760b420bb635c68de0cd84f")).emit();
 
     client.processNextFrame();// Detects error, disconnects immediately since close already sent.
-    assertTrue(clientConnectionClosed);
-    clientListener.assertFailure(
+    assertTrue(client.closed);
+    client.listener.assertFailure(
         ProtocolException.class, "Server-sent frames must not be masked.");
 
-    serverListener.assertClosing(1000, "Hello");
-    serverListener.assertExhausted(); // Client should not have sent second close.
+    server.listener.assertClosing(1000, "Hello");
+    server.listener.assertExhausted(); // Client should not have sent second close.
   }
 
   @Test public void protocolErrorAfterCloseDoesNotSendClose() throws IOException {
-    client.close(1000, "Hello!");
+    client.webSocket.close(1000, "Hello!");
     server.processNextFrame();
 
-    assertFalse(clientConnectionClosed); // Not closed until close reply is received.
-    server2clientSink.write(ByteString.decodeHex("0a00")).emit(); // Invalid non-final ping frame.
+    assertFalse(client.closed); // Not closed until close reply is received.
+    server.sink.write(ByteString.decodeHex("0a00")).emit(); // Invalid non-final ping frame.
 
     client.processNextFrame(); // Detects error, disconnects immediately since close already sent.
-    assertTrue(clientConnectionClosed);
-    clientListener.assertFailure(ProtocolException.class, "Control frames must be final.");
+    assertTrue(client.closed);
+    client.listener.assertFailure(ProtocolException.class, "Control frames must be final.");
 
-    serverListener.assertClosing(1000, "Hello!");
+    server.listener.assertClosing(1000, "Hello!");
 
-    serverListener.assertExhausted(); // Client should not have sent second close.
+    server.listener.assertExhausted(); // Client should not have sent second close.
   }
 
   @Test public void networkErrorReportedAsFailure() throws IOException {
-    server2clientSink.close();
+    server.sink.close();
     client.processNextFrame();
-    clientListener.assertFailure(EOFException.class, null);
+    client.listener.assertFailure(EOFException.class, null);
   }
 
   @Test public void closeThrowingFailsConnection() throws IOException {
     client2Server.source().close();
-    client.close(1000, null);
-    clientListener.assertFailure(IOException.class, "source is closed");
+    client.webSocket.close(1000, null);
+    client.listener.assertFailure(IOException.class, "source is closed");
   }
 
   @Ignore // TODO(jwilson): come up with a way to test unchecked exceptions on the writer thread.
   @Test public void closeMessageAndConnectionCloseThrowingDoesNotMaskOriginal() throws IOException {
-    client2ServerSink.close();
-    clientConnectionCloseThrows = true;
+    client.sink.close();
+    client.closeThrows = true;
 
-    client.close(1000, "Bye!");
-    clientListener.assertFailure(IOException.class, "failure");
-    assertTrue(clientConnectionClosed);
+    client.webSocket.close(1000, "Bye!");
+    client.listener.assertFailure(IOException.class, "failure");
+    assertTrue(client.closed);
   }
 
   @Ignore // TODO(jwilson): come up with a way to test unchecked exceptions on the writer thread.
   @Test public void peerConnectionCloseThrowingPropagates() throws IOException {
-    clientConnectionCloseThrows = true;
+    client.closeThrows = true;
 
-    server.close(1000, "Bye from Server!");
+    server.webSocket.close(1000, "Bye from Server!");
     client.processNextFrame();
-    clientListener.assertClosing(1000, "Bye from Server!");
+    client.listener.assertClosing(1000, "Bye from Server!");
 
-    client.close(1000, "Bye from Client!");
+    client.webSocket.close(1000, "Bye from Client!");
     server.processNextFrame();
-    serverListener.assertClosing(1000, "Bye from Client!");
+    server.listener.assertClosing(1000, "Bye from Client!");
+  }
+
+  @Test public void pingOnInterval() throws IOException {
+    long startNanos = System.nanoTime();
+    client.initWebSocket(random, 500);
+
+    server.processNextFrame(); // Ping.
+    client.processNextFrame(); // Pong.
+    long elapsedUntilPing1 = System.nanoTime() - startNanos;
+    assertEquals(500, TimeUnit.NANOSECONDS.toMillis(elapsedUntilPing1), 250d);
+
+    server.processNextFrame(); // Ping.
+    client.processNextFrame(); // Pong.
+    long elapsedUntilPing2 = System.nanoTime() - startNanos;
+    assertEquals(1000, TimeUnit.NANOSECONDS.toMillis(elapsedUntilPing2), 250d);
+
+    server.processNextFrame(); // Ping.
+    client.processNextFrame(); // Pong.
+    long elapsedUntilPing3 = System.nanoTime() - startNanos;
+    assertEquals(1500, TimeUnit.NANOSECONDS.toMillis(elapsedUntilPing3), 250d);
+  }
+
+  /** One peer's streams, listener, and web socket in the test. */
+  private static class TestStreams extends RealWebSocket.Streams {
+    private final String name;
+    private final WebSocketRecorder listener;
+    private RealWebSocket webSocket;
+    boolean closeThrows;
+    boolean closed;
+
+    public TestStreams(boolean client, Pipe source, Pipe sink) {
+      super(client, Okio.buffer(source.source()), Okio.buffer(sink.sink()));
+      this.name = client ? "client" : "server";
+      this.listener = new WebSocketRecorder(name);
+    }
+
+    public void initWebSocket(Random random, int pingIntervalMillis) throws IOException {
+      String url = "http://example.com/websocket";
+      Response response = new Response.Builder()
+          .code(101)
+          .request(new Request.Builder().url(url).build())
+          .protocol(Protocol.HTTP_1_1)
+          .build();
+      webSocket = new RealWebSocket(response.request(), listener, random);
+      webSocket.initReaderAndWriter(name, pingIntervalMillis, this);
+    }
+
+    public boolean processNextFrame() throws IOException {
+      return webSocket.processNextFrame();
+    }
+
+    @Override public void close() throws IOException {
+      source.close();
+      sink.close();
+      if (closed) {
+        throw new AssertionError("Already closed");
+      }
+      closed = true;
+
+      if (closeThrows) {
+        throw new RuntimeException("Oops!");
+      }
+    }
   }
 }
diff --git a/okhttp-tests/src/test/java/okhttp3/WebSocketHttpTest.java b/okhttp-tests/src/test/java/okhttp3/internal/ws/WebSocketHttpTest.java
similarity index 66%
rename from okhttp-tests/src/test/java/okhttp3/WebSocketHttpTest.java
rename to okhttp-tests/src/test/java/okhttp3/internal/ws/WebSocketHttpTest.java
index d971c4b940..eaff205fd8 100644
--- a/okhttp-tests/src/test/java/okhttp3/WebSocketHttpTest.java
+++ b/okhttp-tests/src/test/java/okhttp3/internal/ws/WebSocketHttpTest.java
@@ -13,18 +13,24 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package okhttp3;
+package okhttp3.internal.ws;
 
 import java.io.IOException;
 import java.net.ProtocolException;
 import java.net.SocketTimeoutException;
 import java.util.Random;
 import java.util.concurrent.TimeUnit;
+import java.util.concurrent.atomic.AtomicInteger;
 import java.util.logging.Logger;
+import okhttp3.Interceptor;
+import okhttp3.OkHttpClient;
+import okhttp3.RecordingHostnameVerifier;
+import okhttp3.Request;
+import okhttp3.Response;
+import okhttp3.TestLogHandler;
+import okhttp3.WebSocket;
+import okhttp3.WebSocketListener;
 import okhttp3.internal.tls.SslClient;
-import okhttp3.internal.ws.RealWebSocket;
-import okhttp3.internal.ws.WebSocketProtocol;
-import okhttp3.internal.ws.WebSocketRecorder;
 import okhttp3.mockwebserver.Dispatcher;
 import okhttp3.mockwebserver.MockResponse;
 import okhttp3.mockwebserver.MockWebServer;
@@ -38,9 +44,12 @@
 import org.junit.Test;
 
 import static okhttp3.TestUtil.defaultClient;
+import static okhttp3.TestUtil.repeat;
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertFalse;
 import static org.junit.Assert.assertNotNull;
+import static org.junit.Assert.assertNull;
+import static org.junit.Assert.assertTrue;
 import static org.junit.Assert.fail;
 
 public final class WebSocketHttpTest {
@@ -85,7 +94,7 @@
     serverListener.assertOpen();
 
     webSocket.send(ByteString.encodeUtf8("Hello!"));
-    serverListener.assertBinaryMessage(new byte[] {'H', 'e', 'l', 'l', 'o', '!'});
+    serverListener.assertBinaryMessage(ByteString.of(new byte[] {'H', 'e', 'l', 'l', 'o', '!'}));
   }
 
   @Test public void nullStringThrows() throws IOException {
@@ -300,6 +309,128 @@
         "Expected 'Sec-WebSocket-Accept' header value 'ujmZX4KXZqjwy6vi1aQFH5p4Ygk=' but was 'magic'");
   }
 
+  @Test public void webSocketAndApplicationInterceptors() throws IOException {
+    final AtomicInteger interceptedCount = new AtomicInteger();
+
+    client = client.newBuilder()
+        .addInterceptor(new Interceptor() {
+          @Override public Response intercept(Chain chain) throws IOException {
+            assertNull(chain.request().body());
+            Response response = chain.proceed(chain.request());
+            assertEquals("Upgrade", response.header("Connection"));
+            assertTrue("", response.body().source().exhausted());
+            interceptedCount.incrementAndGet();
+            return response;
+          }
+        }).build();
+
+    webServer.enqueue(new MockResponse().withWebSocketUpgrade(serverListener));
+
+    WebSocket webSocket = newWebSocket();
+    clientListener.assertOpen();
+    assertEquals(1, interceptedCount.get());
+    webSocket.close(1000, null);
+
+    WebSocket server = serverListener.assertOpen();
+    server.close(1000, null);
+  }
+
+  @Test public void webSocketAndNetworkInterceptors() throws IOException {
+    client = client.newBuilder()
+        .addNetworkInterceptor(new Interceptor() {
+          @Override public Response intercept(Chain chain) throws IOException {
+            throw new AssertionError(); // Network interceptors don't execute.
+          }
+        }).build();
+
+    webServer.enqueue(new MockResponse().withWebSocketUpgrade(serverListener));
+
+    WebSocket webSocket = newWebSocket();
+    clientListener.assertOpen();
+    webSocket.close(1000, null);
+
+    WebSocket server = serverListener.assertOpen();
+    server.close(1000, null);
+  }
+
+  @Test public void overflowOutgoingQueue() throws IOException {
+    webServer.enqueue(new MockResponse().withWebSocketUpgrade(serverListener));
+
+    WebSocket webSocket = newWebSocket();
+    clientListener.assertOpen();
+
+    // Send messages until the client's outgoing buffer overflows!
+    ByteString message = ByteString.of(new byte[1024 * 1024]);
+    int messageCount = 0;
+    while (true) {
+      boolean success = webSocket.send(message);
+      if (!success) break;
+
+      messageCount++;
+      long queueSize = webSocket.queueSize();
+      assertTrue(queueSize >= 0 && queueSize <= messageCount * message.size());
+      assertTrue(messageCount < 32); // Expect to fail before enqueueing 32 MiB.
+    }
+
+    // Confirm all sent messages were received, followed by a client-initiated close.
+    WebSocket server = serverListener.assertOpen();
+    for (int i = 0; i < messageCount; i++) {
+      serverListener.assertBinaryMessage(message);
+    }
+    serverListener.assertClosing(1001, "");
+
+    // When the server acknowledges the close the connection shuts down gracefully.
+    server.close(1000, null);
+    clientListener.assertClosing(1000, "");
+    clientListener.assertClosed(1000, "");
+    serverListener.assertClosed(1001, "");
+  }
+
+  @Test public void closeReasonMaximumLength() throws IOException {
+    webServer.enqueue(new MockResponse().withWebSocketUpgrade(serverListener));
+
+    String clientReason = repeat('C', 123);
+    String serverReason = repeat('S', 123);
+
+    WebSocket webSocket = newWebSocket();
+    WebSocket server = serverListener.assertOpen();
+
+    clientListener.assertOpen();
+    webSocket.close(1000, clientReason);
+    serverListener.assertClosing(1000, clientReason);
+
+    server.close(1000, serverReason);
+    clientListener.assertClosing(1000, serverReason);
+    clientListener.assertClosed(1000, serverReason);
+
+    serverListener.assertClosed(1000, clientReason);
+  }
+
+  @Test public void closeReasonTooLong() throws IOException {
+    webServer.enqueue(new MockResponse().withWebSocketUpgrade(serverListener));
+
+    WebSocket webSocket = newWebSocket();
+    WebSocket server = serverListener.assertOpen();
+
+    clientListener.assertOpen();
+    String reason = repeat('X', 124);
+    try {
+      webSocket.close(1000, reason);
+      fail();
+    } catch (IllegalArgumentException expected) {
+      assertEquals("reason.size() > 123: " + reason, expected.getMessage());
+    }
+
+    webSocket.close(1000, null);
+    serverListener.assertClosing(1000, "");
+
+    server.close(1000, null);
+    clientListener.assertClosing(1000, "");
+    clientListener.assertClosed(1000, "");
+
+    serverListener.assertClosed(1000, "");
+  }
+
   @Test public void wsScheme() throws IOException {
     websocketScheme("ws");
   }
@@ -374,6 +505,73 @@
     clientListener.assertTextMessage("abc");
   }
 
+  @Test public void clientPingsServerOnInterval() throws Exception {
+    client = client.newBuilder()
+        .pingInterval(500, TimeUnit.MILLISECONDS)
+        .build();
+
+    webServer.enqueue(new MockResponse().withWebSocketUpgrade(serverListener));
+    RealWebSocket webSocket = newWebSocket();
+
+    clientListener.assertOpen();
+    RealWebSocket server = (RealWebSocket) serverListener.assertOpen();
+
+    long startNanos = System.nanoTime();
+    while (webSocket.pongCount() < 3) {
+      Thread.sleep(50);
+    }
+
+    long elapsedUntilPong3 = System.nanoTime() - startNanos;
+    assertEquals(1500, TimeUnit.NANOSECONDS.toMillis(elapsedUntilPong3), 250d);
+
+    // The client pinged the server 3 times, and it has ponged back 3 times.
+    assertEquals(3, server.pingCount());
+    assertEquals(3, webSocket.pongCount());
+
+    // The server has never pinged the client.
+    assertEquals(0, server.pongCount());
+    assertEquals(0, webSocket.pingCount());
+  }
+
+  @Test public void clientDoesNotPingServerByDefault() throws Exception {
+    webServer.enqueue(new MockResponse().withWebSocketUpgrade(serverListener));
+    RealWebSocket webSocket = newWebSocket();
+
+    clientListener.assertOpen();
+    RealWebSocket server = (RealWebSocket) serverListener.assertOpen();
+
+    Thread.sleep(1000);
+
+    // No pings and no pongs.
+    assertEquals(0, server.pingCount());
+    assertEquals(0, webSocket.pongCount());
+    assertEquals(0, server.pongCount());
+    assertEquals(0, webSocket.pingCount());
+  }
+
+  /** https://github.com/square/okhttp/issues/2788 */
+  @Test public void clientCancelsIfCloseIsNotAcknowledged() throws Exception {
+    webServer.enqueue(new MockResponse().withWebSocketUpgrade(serverListener));
+    RealWebSocket webSocket = newWebSocket();
+
+    clientListener.assertOpen();
+    WebSocket server = serverListener.assertOpen();
+
+    // Initiate a close on the client, which will schedule a hard cancel in 500 ms.
+    long closeAtNanos = System.nanoTime();
+    webSocket.close(1000, "goodbye", 500);
+    serverListener.assertClosing(1000, "goodbye");
+
+    // Confirm that the hard cancel occurred after 500 ms.
+    clientListener.assertFailure();
+    long elapsedUntilFailure = System.nanoTime() - closeAtNanos;
+    assertEquals(500, TimeUnit.NANOSECONDS.toMillis(elapsedUntilFailure), 250d);
+
+    // Close the server and confirm it saw what we expected.
+    server.close(1000, null);
+    serverListener.assertClosed(1000, "goodbye");
+  }
+
   private MockResponse upgradeResponse(RecordedRequest request) {
     String key = request.getHeader("Sec-WebSocket-Key");
     return new MockResponse()
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/ws/WebSocketReaderTest.java b/okhttp-tests/src/test/java/okhttp3/internal/ws/WebSocketReaderTest.java
index 07ae188ac6..21cf06df5d 100644
--- a/okhttp-tests/src/test/java/okhttp3/internal/ws/WebSocketReaderTest.java
+++ b/okhttp-tests/src/test/java/okhttp3/internal/ws/WebSocketReaderTest.java
@@ -214,7 +214,7 @@
     byte[] bytes = binaryData(256);
     data.write(ByteString.decodeHex("827E0100")).write(bytes);
     clientReader.processNextFrame();
-    callback.assertBinaryMessage(bytes);
+    callback.assertBinaryMessage(ByteString.of(bytes));
   }
 
   @Test public void clientTwoFrameBinary() throws IOException {
@@ -222,7 +222,7 @@
     data.write(ByteString.decodeHex("0264")).write(bytes, 0, 100);
     data.write(ByteString.decodeHex("8064")).write(bytes, 100, 100);
     clientReader.processNextFrame();
-    callback.assertBinaryMessage(bytes);
+    callback.assertBinaryMessage(ByteString.of(bytes));
   }
 
   @Test public void twoFrameNotContinuation() throws IOException {
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/ws/WebSocketRecorder.java b/okhttp-tests/src/test/java/okhttp3/internal/ws/WebSocketRecorder.java
index 944ac48bb0..ac5626ce57 100644
--- a/okhttp-tests/src/test/java/okhttp3/internal/ws/WebSocketRecorder.java
+++ b/okhttp-tests/src/test/java/okhttp3/internal/ws/WebSocketRecorder.java
@@ -19,8 +19,8 @@
 import java.util.concurrent.BlockingQueue;
 import java.util.concurrent.LinkedBlockingQueue;
 import java.util.concurrent.TimeUnit;
-import okhttp3.WebSocket;
 import okhttp3.Response;
+import okhttp3.WebSocket;
 import okhttp3.WebSocketListener;
 import okhttp3.internal.Util;
 import okhttp3.internal.platform.Platform;
@@ -136,9 +136,9 @@ public void assertTextMessage(String payload) {
     assertEquals(new Message(payload), actual);
   }
 
-  public void assertBinaryMessage(byte[] payload) {
+  public void assertBinaryMessage(ByteString payload) {
     Object actual = nextEvent();
-    assertEquals(new Message(ByteString.of(payload)), actual);
+    assertEquals(new Message(payload), actual);
   }
 
   public void assertPing(ByteString payload) {
@@ -194,6 +194,13 @@ public void assertFailure(Class<? extends IOException> cls, String message) {
     assertEquals(message, failure.t.getMessage());
   }
 
+  public void assertFailure() {
+    Object event = nextEvent();
+    if (!(event instanceof Failure)) {
+      throw new AssertionError("Expected Failure but was " + event);
+    }
+  }
+
   public void assertFailure(int code, String body, Class<? extends IOException> cls, String message)
       throws IOException {
     Object event = nextEvent();
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/ws/WebSocketWriterTest.java b/okhttp-tests/src/test/java/okhttp3/internal/ws/WebSocketWriterTest.java
index bb4d43ec10..a303cc1052 100644
--- a/okhttp-tests/src/test/java/okhttp3/internal/ws/WebSocketWriterTest.java
+++ b/okhttp-tests/src/test/java/okhttp3/internal/ws/WebSocketWriterTest.java
@@ -31,6 +31,7 @@
 import org.junit.runner.Description;
 import org.junit.runners.model.Statement;
 
+import static okhttp3.TestUtil.repeat;
 import static okhttp3.internal.ws.WebSocketProtocol.OPCODE_BINARY;
 import static okhttp3.internal.ws.WebSocketProtocol.OPCODE_TEXT;
 import static okhttp3.internal.ws.WebSocketProtocol.PAYLOAD_BYTE_MAX;
@@ -263,7 +264,7 @@
   }
 
   @Test public void serverCloseWithCodeAndReason() throws IOException {
-    serverWriter.writeClose(1001, "Hello");
+    serverWriter.writeClose(1001, ByteString.encodeUtf8("Hello"));
     assertData("880703e948656c6c6f");
   }
 
@@ -278,18 +279,18 @@
   }
 
   @Test public void clientCloseWithCodeAndReason() throws IOException {
-    clientWriter.writeClose(1001, "Hello");
+    clientWriter.writeClose(1001, ByteString.encodeUtf8("Hello"));
     assertData("888760b420bb635d68de0cd84f");
   }
 
   @Test public void closeWithOnlyReasonThrows() throws IOException {
-    clientWriter.writeClose(0, "Hello");
+    clientWriter.writeClose(0, ByteString.encodeUtf8("Hello"));
     assertData("888760b420bb60b468de0cd84f");
   }
 
   @Test public void closeCodeOutOfRangeThrows() throws IOException {
     try {
-      clientWriter.writeClose(98724976, "Hello");
+      clientWriter.writeClose(98724976, ByteString.encodeUtf8("Hello"));
       fail();
     } catch (IllegalArgumentException e) {
       assertEquals("Code must be in range [1000,5000): 98724976", e.getMessage());
@@ -298,7 +299,7 @@
 
   @Test public void closeReservedThrows() throws IOException {
     try {
-      clientWriter.writeClose(1005, "Hello");
+      clientWriter.writeClose(1005, ByteString.encodeUtf8("Hello"));
       fail();
     } catch (IllegalArgumentException e) {
       assertEquals("Code 1005 is reserved and may not be used.", e.getMessage());
@@ -365,8 +366,8 @@
 
   @Test public void closeTooLongThrows() throws IOException {
     try {
-      String longString = ByteString.of(binaryData(75)).hex();
-      serverWriter.writeClose(1000, longString);
+      ByteString longReason = ByteString.encodeUtf8(repeat('X', 124));
+      serverWriter.writeClose(1000, longReason);
       fail();
     } catch (IllegalArgumentException e) {
       assertEquals("Payload size must be less than or equal to 125", e.getMessage());
diff --git a/okhttp-urlconnection/pom.xml b/okhttp-urlconnection/pom.xml
index bde049037c..34c265c24c 100644
--- a/okhttp-urlconnection/pom.xml
+++ b/okhttp-urlconnection/pom.xml
@@ -6,7 +6,7 @@
   <parent>
     <groupId>com.squareup.okhttp3</groupId>
     <artifactId>parent</artifactId>
-    <version>3.5.0-SNAPSHOT</version>
+    <version>3.6.0-SNAPSHOT</version>
   </parent>
 
   <artifactId>okhttp-urlconnection</artifactId>
diff --git a/okhttp/pom.xml b/okhttp/pom.xml
index 2e07de0875..a3e5aaa134 100644
--- a/okhttp/pom.xml
+++ b/okhttp/pom.xml
@@ -6,7 +6,7 @@
   <parent>
     <groupId>com.squareup.okhttp3</groupId>
     <artifactId>parent</artifactId>
-    <version>3.5.0-SNAPSHOT</version>
+    <version>3.6.0-SNAPSHOT</version>
   </parent>
 
   <artifactId>okhttp</artifactId>
diff --git a/okhttp/src/main/java/okhttp3/Address.java b/okhttp/src/main/java/okhttp3/Address.java
index 4fd97764a3..8aef1932a5 100644
--- a/okhttp/src/main/java/okhttp3/Address.java
+++ b/okhttp/src/main/java/okhttp3/Address.java
@@ -180,4 +180,19 @@ public CertificatePinner certificatePinner() {
     result = 31 * result + (certificatePinner != null ? certificatePinner.hashCode() : 0);
     return result;
   }
+
+  @Override public String toString() {
+    StringBuilder result = new StringBuilder()
+        .append("Address{")
+        .append(url.host()).append(":").append(url.port());
+
+    if (proxy != null) {
+      result.append(", proxy=").append(proxy);
+    } else {
+      result.append(", proxySelector=").append(proxySelector);
+    }
+
+    result.append("}");
+    return result.toString();
+  }
 }
diff --git a/okhttp/src/main/java/okhttp3/CacheControl.java b/okhttp/src/main/java/okhttp3/CacheControl.java
index 9dcdbd3c2e..39972c4bfb 100644
--- a/okhttp/src/main/java/okhttp3/CacheControl.java
+++ b/okhttp/src/main/java/okhttp3/CacheControl.java
@@ -58,7 +58,7 @@ private CacheControl(boolean noCache, boolean noStore, int maxAgeSeconds, int sM
     this.headerValue = headerValue;
   }
 
-  private CacheControl(Builder builder) {
+  CacheControl(Builder builder) {
     this.noCache = builder.noCache;
     this.noStore = builder.noStore;
     this.maxAgeSeconds = builder.maxAgeSeconds;
diff --git a/okhttp/src/main/java/okhttp3/CertificatePinner.java b/okhttp/src/main/java/okhttp3/CertificatePinner.java
index 855907e2b3..722521a70c 100644
--- a/okhttp/src/main/java/okhttp3/CertificatePinner.java
+++ b/okhttp/src/main/java/okhttp3/CertificatePinner.java
@@ -130,7 +130,7 @@
   private final Set<Pin> pins;
   private final CertificateChainCleaner certificateChainCleaner;
 
-  private CertificatePinner(Set<Pin> pins, CertificateChainCleaner certificateChainCleaner) {
+  CertificatePinner(Set<Pin> pins, CertificateChainCleaner certificateChainCleaner) {
     this.pins = pins;
     this.certificateChainCleaner = certificateChainCleaner;
   }
diff --git a/okhttp/src/main/java/okhttp3/ConnectionSpec.java b/okhttp/src/main/java/okhttp3/ConnectionSpec.java
index a229e2dd00..11fd12c3ea 100644
--- a/okhttp/src/main/java/okhttp3/ConnectionSpec.java
+++ b/okhttp/src/main/java/okhttp3/ConnectionSpec.java
@@ -80,12 +80,12 @@
   /** Unencrypted, unauthenticated connections for {@code http:} URLs. */
   public static final ConnectionSpec CLEARTEXT = new Builder(false).build();
 
-  private final boolean tls;
-  private final boolean supportsTlsExtensions;
-  private final String[] cipherSuites;
-  private final String[] tlsVersions;
+  final boolean tls;
+  final boolean supportsTlsExtensions;
+  final String[] cipherSuites;
+  final String[] tlsVersions;
 
-  private ConnectionSpec(Builder builder) {
+  ConnectionSpec(Builder builder) {
     this.tls = builder.tls;
     this.cipherSuites = builder.cipherSuites;
     this.tlsVersions = builder.tlsVersions;
@@ -251,10 +251,10 @@ private static boolean nonEmptyIntersection(String[] a, String[] b) {
   }
 
   public static final class Builder {
-    private boolean tls;
-    private String[] cipherSuites;
-    private String[] tlsVersions;
-    private boolean supportsTlsExtensions;
+    boolean tls;
+    String[] cipherSuites;
+    String[] tlsVersions;
+    boolean supportsTlsExtensions;
 
     Builder(boolean tls) {
       this.tls = tls;
diff --git a/okhttp/src/main/java/okhttp3/Cookie.java b/okhttp/src/main/java/okhttp3/Cookie.java
index df882c01ab..066c6e1471 100644
--- a/okhttp/src/main/java/okhttp3/Cookie.java
+++ b/okhttp/src/main/java/okhttp3/Cookie.java
@@ -74,7 +74,7 @@ private Cookie(String name, String value, long expiresAt, String domain, String
     this.persistent = persistent;
   }
 
-  private Cookie(Builder builder) {
+  Cookie(Builder builder) {
     if (builder.name == null) throw new NullPointerException("builder.name == null");
     if (builder.value == null) throw new NullPointerException("builder.value == null");
     if (builder.domain == null) throw new NullPointerException("builder.domain == null");
diff --git a/okhttp/src/main/java/okhttp3/FormBody.java b/okhttp/src/main/java/okhttp3/FormBody.java
index 95181b1f76..87ebb49f81 100644
--- a/okhttp/src/main/java/okhttp3/FormBody.java
+++ b/okhttp/src/main/java/okhttp3/FormBody.java
@@ -32,7 +32,7 @@
   private final List<String> encodedNames;
   private final List<String> encodedValues;
 
-  private FormBody(List<String> encodedNames, List<String> encodedValues) {
+  FormBody(List<String> encodedNames, List<String> encodedValues) {
     this.encodedNames = Util.immutableList(encodedNames);
     this.encodedValues = Util.immutableList(encodedValues);
   }
diff --git a/okhttp/src/main/java/okhttp3/Headers.java b/okhttp/src/main/java/okhttp3/Headers.java
index e6c7c359b5..5bdacfbd45 100644
--- a/okhttp/src/main/java/okhttp3/Headers.java
+++ b/okhttp/src/main/java/okhttp3/Headers.java
@@ -49,7 +49,7 @@
 public final class Headers {
   private final String[] namesAndValues;
 
-  private Headers(Builder builder) {
+  Headers(Builder builder) {
     this.namesAndValues = builder.namesAndValues.toArray(new String[builder.namesAndValues.size()]);
   }
 
@@ -237,7 +237,7 @@ public static Headers of(Map<String, String> headers) {
   }
 
   public static final class Builder {
-    private final List<String> namesAndValues = new ArrayList<>(20);
+    final List<String> namesAndValues = new ArrayList<>(20);
 
     /**
      * Add a header line without any validation. Only appropriate for headers from the remote peer
@@ -308,7 +308,7 @@ private void checkNameAndValue(String name, String value) {
       if (name.isEmpty()) throw new IllegalArgumentException("name is empty");
       for (int i = 0, length = name.length(); i < length; i++) {
         char c = name.charAt(i);
-        if (c <= '\u001f' || c >= '\u007f') {
+        if (c <= '\u0020' || c >= '\u007f') {
           throw new IllegalArgumentException(Util.format(
               "Unexpected char %#04x at %d in header name: %s", (int) c, i, name));
         }
diff --git a/okhttp/src/main/java/okhttp3/HttpUrl.java b/okhttp/src/main/java/okhttp3/HttpUrl.java
index deadf39ba0..6b37d5630d 100644
--- a/okhttp/src/main/java/okhttp3/HttpUrl.java
+++ b/okhttp/src/main/java/okhttp3/HttpUrl.java
@@ -296,7 +296,7 @@
   static final String FRAGMENT_ENCODE_SET_URI = " \"#<>\\^`{|}";
 
   /** Either "http" or "https". */
-  private final String scheme;
+  final String scheme;
 
   /** Decoded username. */
   private final String username;
@@ -305,10 +305,10 @@
   private final String password;
 
   /** Canonical hostname. */
-  private final String host;
+  final String host;
 
   /** Either 80, 443 or a user-specified port. In range [1..65535]. */
-  private final int port;
+  final int port;
 
   /**
    * A list of canonical path segments. This list always contains at least one element, which may be
@@ -330,7 +330,7 @@
   /** Canonical URL. */
   private final String url;
 
-  private HttpUrl(Builder builder) {
+  HttpUrl(Builder builder) {
     this.scheme = builder.scheme;
     this.username = percentDecode(builder.encodedUsername, false);
     this.password = percentDecode(builder.encodedPassword, false);
@@ -842,14 +842,16 @@ public String fragment() {
   }
 
   /**
-   * Returns the HttpUrl with the username, password, path, query, and fragment stripped.
-   * Example: http://username:password@example.com/path returns http://example.com/...
+   * Returns a string with containing this URL with its username, password, query, and fragment
+   * stripped, and its path replaced with {@code /...}. For example, redacting {@code
+   * http://username:password@example.com/path} returns {@code http://example.com/...}.
    */
-  public HttpUrl redact() {
-    Builder builder = newBuilder("/...");
-    builder.username("");
-    builder.password("");
-    return builder.build();
+  public String redact() {
+    return newBuilder("/...")
+        .username("")
+        .password("")
+        .build()
+        .toString();
   }
 
   /**
diff --git a/okhttp/src/main/java/okhttp3/OkHttpClient.java b/okhttp/src/main/java/okhttp3/OkHttpClient.java
index a8ae6dcb15..d55351e841 100644
--- a/okhttp/src/main/java/okhttp3/OkHttpClient.java
+++ b/okhttp/src/main/java/okhttp3/OkHttpClient.java
@@ -118,10 +118,10 @@
  * remain idle.
  */
 public class OkHttpClient implements Cloneable, Call.Factory, WebSocket.Factory {
-  private static final List<Protocol> DEFAULT_PROTOCOLS = Util.immutableList(
+  static final List<Protocol> DEFAULT_PROTOCOLS = Util.immutableList(
       Protocol.HTTP_2, Protocol.HTTP_1_1);
 
-  private static final List<ConnectionSpec> DEFAULT_CONNECTION_SPECS = Util.immutableList(
+  static final List<ConnectionSpec> DEFAULT_CONNECTION_SPECS = Util.immutableList(
       ConnectionSpec.MODERN_TLS, ConnectionSpec.COMPATIBLE_TLS, ConnectionSpec.CLEARTEXT);
 
   static {
@@ -201,12 +201,13 @@ public void apply(ConnectionSpec tlsConfiguration, SSLSocket sslSocket, boolean
   final int connectTimeout;
   final int readTimeout;
   final int writeTimeout;
+  final int pingInterval;
 
   public OkHttpClient() {
     this(new Builder());
   }
 
-  private OkHttpClient(Builder builder) {
+  OkHttpClient(Builder builder) {
     this.dispatcher = builder.dispatcher;
     this.proxy = builder.proxy;
     this.protocols = builder.protocols;
@@ -246,6 +247,7 @@ private OkHttpClient(Builder builder) {
     this.connectTimeout = builder.connectTimeout;
     this.readTimeout = builder.readTimeout;
     this.writeTimeout = builder.writeTimeout;
+    this.pingInterval = builder.pingInterval;
   }
 
   private X509TrustManager systemDefaultTrustManager() {
@@ -289,6 +291,11 @@ public int writeTimeoutMillis() {
     return writeTimeout;
   }
 
+  /** Web socket ping interval (in milliseconds). */
+  public int pingIntervalMillis() {
+    return pingInterval;
+  }
+
   public Proxy proxy() {
     return proxy;
   }
@@ -429,6 +436,7 @@ public Builder newBuilder() {
     int connectTimeout;
     int readTimeout;
     int writeTimeout;
+    int pingInterval;
 
     public Builder() {
       dispatcher = new Dispatcher();
@@ -449,6 +457,7 @@ public Builder() {
       connectTimeout = 10_000;
       readTimeout = 10_000;
       writeTimeout = 10_000;
+      pingInterval = 0;
     }
 
     Builder(OkHttpClient okHttpClient) {
@@ -477,6 +486,7 @@ public Builder() {
       this.connectTimeout = okHttpClient.connectTimeout;
       this.readTimeout = okHttpClient.readTimeout;
       this.writeTimeout = okHttpClient.writeTimeout;
+      this.pingInterval = okHttpClient.pingInterval;
     }
 
     /**
@@ -485,12 +495,7 @@ public Builder() {
      * milliseconds.
      */
     public Builder connectTimeout(long timeout, TimeUnit unit) {
-      if (timeout < 0) throw new IllegalArgumentException("timeout < 0");
-      if (unit == null) throw new NullPointerException("unit == null");
-      long millis = unit.toMillis(timeout);
-      if (millis > Integer.MAX_VALUE) throw new IllegalArgumentException("Timeout too large.");
-      if (millis == 0 && timeout > 0) throw new IllegalArgumentException("Timeout too small.");
-      connectTimeout = (int) millis;
+      connectTimeout = checkDuration("timeout", timeout, unit);
       return this;
     }
 
@@ -499,12 +504,7 @@ public Builder connectTimeout(long timeout, TimeUnit unit) {
      * values must be between 1 and {@link Integer#MAX_VALUE} when converted to milliseconds.
      */
     public Builder readTimeout(long timeout, TimeUnit unit) {
-      if (timeout < 0) throw new IllegalArgumentException("timeout < 0");
-      if (unit == null) throw new NullPointerException("unit == null");
-      long millis = unit.toMillis(timeout);
-      if (millis > Integer.MAX_VALUE) throw new IllegalArgumentException("Timeout too large.");
-      if (millis == 0 && timeout > 0) throw new IllegalArgumentException("Timeout too small.");
-      readTimeout = (int) millis;
+      readTimeout = checkDuration("timeout", timeout, unit);
       return this;
     }
 
@@ -513,15 +513,32 @@ public Builder readTimeout(long timeout, TimeUnit unit) {
      * values must be between 1 and {@link Integer#MAX_VALUE} when converted to milliseconds.
      */
     public Builder writeTimeout(long timeout, TimeUnit unit) {
-      if (timeout < 0) throw new IllegalArgumentException("timeout < 0");
-      if (unit == null) throw new NullPointerException("unit == null");
-      long millis = unit.toMillis(timeout);
-      if (millis > Integer.MAX_VALUE) throw new IllegalArgumentException("Timeout too large.");
-      if (millis == 0 && timeout > 0) throw new IllegalArgumentException("Timeout too small.");
-      writeTimeout = (int) millis;
+      writeTimeout = checkDuration("timeout", timeout, unit);
+      return this;
+    }
+
+    /**
+     * Sets the interval between web socket pings initiated by this client. Use this to
+     * automatically send web socket ping frames until either the web socket fails or it is closed.
+     * This keeps the connection alive and may detect connectivity failures early. No timeouts are
+     * enforced on the acknowledging pongs.
+     *
+     * <p>The default value of 0 disables client-initiated pings.
+     */
+    public Builder pingInterval(long interval, TimeUnit unit) {
+      pingInterval = checkDuration("interval", interval, unit);
       return this;
     }
 
+    private static int checkDuration(String name, long duration, TimeUnit unit) {
+      if (duration < 0) throw new IllegalArgumentException(name + " < 0");
+      if (unit == null) throw new NullPointerException("unit == null");
+      long millis = unit.toMillis(duration);
+      if (millis > Integer.MAX_VALUE) throw new IllegalArgumentException(name + " too large.");
+      if (millis == 0 && duration > 0) throw new IllegalArgumentException(name + " too small.");
+      return (int) millis;
+    }
+
     /**
      * Sets the HTTP proxy that will be used by connections created by this client. This takes
      * precedence over {@link #proxySelector}, which is only honored when this proxy is null (which
diff --git a/okhttp/src/main/java/okhttp3/RealCall.java b/okhttp/src/main/java/okhttp3/RealCall.java
index 3c027a2caf..ab3ddb088f 100644
--- a/okhttp/src/main/java/okhttp3/RealCall.java
+++ b/okhttp/src/main/java/okhttp3/RealCall.java
@@ -158,7 +158,7 @@ String toLoggableString() {
   }
 
   String redactedUrl() {
-    return originalRequest.url().redact().toString();
+    return originalRequest.url().redact();
   }
 
   Response getResponseWithInterceptorChain() throws IOException {
diff --git a/okhttp/src/main/java/okhttp3/Request.java b/okhttp/src/main/java/okhttp3/Request.java
index 36aa6acfe7..f4b0f6dba4 100644
--- a/okhttp/src/main/java/okhttp3/Request.java
+++ b/okhttp/src/main/java/okhttp3/Request.java
@@ -131,7 +131,7 @@ public Builder url(HttpUrl url) {
     public Builder url(String url) {
       if (url == null) throw new NullPointerException("url == null");
 
-      // Silently replace websocket URLs with HTTP URLs.
+      // Silently replace web socket URLs with HTTP URLs.
       if (url.regionMatches(true, 0, "ws:", 0, 3)) {
         url = "http:" + url.substring(3);
       } else if (url.regionMatches(true, 0, "wss:", 0, 4)) {
diff --git a/okhttp/src/main/java/okhttp3/ResponseBody.java b/okhttp/src/main/java/okhttp3/ResponseBody.java
index 113d607746..c00e90f961 100644
--- a/okhttp/src/main/java/okhttp3/ResponseBody.java
+++ b/okhttp/src/main/java/okhttp3/ResponseBody.java
@@ -235,7 +235,7 @@ public static ResponseBody create(
     private boolean closed;
     private Reader delegate;
 
-    private BomAwareReader(BufferedSource source, Charset charset) {
+    BomAwareReader(BufferedSource source, Charset charset) {
       this.source = source;
       this.charset = charset;
     }
diff --git a/okhttp/src/main/java/okhttp3/Route.java b/okhttp/src/main/java/okhttp3/Route.java
index 8aaa0f5b85..7c7e9635e8 100644
--- a/okhttp/src/main/java/okhttp3/Route.java
+++ b/okhttp/src/main/java/okhttp3/Route.java
@@ -96,4 +96,8 @@ public boolean requiresTunnel() {
     result = 31 * result + inetSocketAddress.hashCode();
     return result;
   }
+
+  @Override public String toString() {
+    return "Route{" + inetSocketAddress + "}";
+  }
 }
diff --git a/okhttp/src/main/java/okhttp3/internal/cache/CacheStrategy.java b/okhttp/src/main/java/okhttp3/internal/cache/CacheStrategy.java
index 93eacedef4..dae556bb98 100644
--- a/okhttp/src/main/java/okhttp3/internal/cache/CacheStrategy.java
+++ b/okhttp/src/main/java/okhttp3/internal/cache/CacheStrategy.java
@@ -53,7 +53,7 @@
   /** The cached response to return or validate; or null if this call doesn't use a cache. */
   public final Response cacheResponse;
 
-  private CacheStrategy(Request networkRequest, Response cacheResponse) {
+  CacheStrategy(Request networkRequest, Response cacheResponse) {
     this.networkRequest = networkRequest;
     this.cacheResponse = cacheResponse;
   }
diff --git a/okhttp/src/main/java/okhttp3/internal/cache/DiskLruCache.java b/okhttp/src/main/java/okhttp3/internal/cache/DiskLruCache.java
index 4d3ef616ab..19c2321414 100644
--- a/okhttp/src/main/java/okhttp3/internal/cache/DiskLruCache.java
+++ b/okhttp/src/main/java/okhttp3/internal/cache/DiskLruCache.java
@@ -136,25 +136,25 @@
      * it exists when the cache is opened.
      */
 
-  private final FileSystem fileSystem;
-  private final File directory;
+  final FileSystem fileSystem;
+  final File directory;
   private final File journalFile;
   private final File journalFileTmp;
   private final File journalFileBackup;
   private final int appVersion;
   private long maxSize;
-  private final int valueCount;
+  final int valueCount;
   private long size = 0;
-  private BufferedSink journalWriter;
-  private final LinkedHashMap<String, Entry> lruEntries = new LinkedHashMap<>(0, 0.75f, true);
-  private int redundantOpCount;
-  private boolean hasJournalErrors;
+  BufferedSink journalWriter;
+  final LinkedHashMap<String, Entry> lruEntries = new LinkedHashMap<>(0, 0.75f, true);
+  int redundantOpCount;
+  boolean hasJournalErrors;
 
   // Must be read and written when synchronized on 'this'.
-  private boolean initialized;
-  private boolean closed;
-  private boolean mostRecentTrimFailed;
-  private boolean mostRecentRebuildFailed;
+  boolean initialized;
+  boolean closed;
+  boolean mostRecentTrimFailed;
+  boolean mostRecentRebuildFailed;
 
   /**
    * To differentiate between old and current snapshots, each entry is given a sequence number each
@@ -381,7 +381,7 @@ private void processJournal() throws IOException {
    * Creates a new journal that omits redundant information. This replaces the current journal if it
    * exists.
    */
-  private synchronized void rebuildJournal() throws IOException {
+  synchronized void rebuildJournal() throws IOException {
     if (journalWriter != null) {
       journalWriter.close();
     }
@@ -452,7 +452,7 @@ public Editor edit(String key) throws IOException {
     return edit(key, ANY_SEQUENCE_NUMBER);
   }
 
-  private synchronized Editor edit(String key, long expectedSequenceNumber) throws IOException {
+  synchronized Editor edit(String key, long expectedSequenceNumber) throws IOException {
     initialize();
 
     checkNotClosed();
@@ -524,7 +524,7 @@ public synchronized long size() throws IOException {
     return size;
   }
 
-  private synchronized void completeEdit(Editor editor, boolean success) throws IOException {
+  synchronized void completeEdit(Editor editor, boolean success) throws IOException {
     Entry entry = editor.entry;
     if (entry.currentEditor != editor) {
       throw new IllegalStateException();
@@ -588,7 +588,7 @@ private synchronized void completeEdit(Editor editor, boolean success) throws IO
    * We only rebuild the journal when it will halve the size of the journal and eliminate at least
    * 2000 ops.
    */
-  private boolean journalRebuildRequired() {
+  boolean journalRebuildRequired() {
     final int redundantOpCompactThreshold = 2000;
     return redundantOpCount >= redundantOpCompactThreshold
         && redundantOpCount >= lruEntries.size();
@@ -612,7 +612,7 @@ public synchronized boolean remove(String key) throws IOException {
     return removed;
   }
 
-  private boolean removeEntry(Entry entry) throws IOException {
+  boolean removeEntry(Entry entry) throws IOException {
     if (entry.currentEditor != null) {
       entry.currentEditor.detach(); // Prevent the edit from completing normally.
     }
@@ -672,7 +672,7 @@ private synchronized void checkNotClosed() {
     closed = true;
   }
 
-  private void trimToSize() throws IOException {
+  void trimToSize() throws IOException {
     while (size > maxSize) {
       Entry toEvict = lruEntries.values().iterator().next();
       removeEntry(toEvict);
@@ -784,7 +784,7 @@ private void validateKey(String key) {
     private final Source[] sources;
     private final long[] lengths;
 
-    private Snapshot(String key, long sequenceNumber, Source[] sources, long[] lengths) {
+    Snapshot(String key, long sequenceNumber, Source[] sources, long[] lengths) {
       this.key = key;
       this.sequenceNumber = sequenceNumber;
       this.sources = sources;
@@ -822,11 +822,11 @@ public void close() {
 
   /** Edits the values for an entry. */
   public final class Editor {
-    private final Entry entry;
-    private final boolean[] written;
+    final Entry entry;
+    final boolean[] written;
     private boolean done;
 
-    private Editor(Entry entry) {
+    Editor(Entry entry) {
       this.entry = entry;
       this.written = (entry.readable) ? null : new boolean[valueCount];
     }
@@ -948,23 +948,23 @@ public void abortUnlessCommitted() {
   }
 
   private final class Entry {
-    private final String key;
+    final String key;
 
     /** Lengths of this entry's files. */
-    private final long[] lengths;
-    private final File[] cleanFiles;
-    private final File[] dirtyFiles;
+    final long[] lengths;
+    final File[] cleanFiles;
+    final File[] dirtyFiles;
 
     /** True if this entry has ever been published. */
-    private boolean readable;
+    boolean readable;
 
     /** The ongoing edit or null if this entry is not being edited. */
-    private Editor currentEditor;
+    Editor currentEditor;
 
     /** The sequence number of the most recently committed edit to this entry. */
-    private long sequenceNumber;
+    long sequenceNumber;
 
-    private Entry(String key) {
+    Entry(String key) {
       this.key = key;
 
       lengths = new long[valueCount];
@@ -984,7 +984,7 @@ private Entry(String key) {
     }
 
     /** Set lengths using decimal numbers like "10123". */
-    private void setLengths(String[] strings) throws IOException {
+    void setLengths(String[] strings) throws IOException {
       if (strings.length != valueCount) {
         throw invalidLengths(strings);
       }
diff --git a/okhttp/src/main/java/okhttp3/internal/cache2/Relay.java b/okhttp/src/main/java/okhttp3/internal/cache2/Relay.java
index b2db592d1e..5131e6cd16 100644
--- a/okhttp/src/main/java/okhttp3/internal/cache2/Relay.java
+++ b/okhttp/src/main/java/okhttp3/internal/cache2/Relay.java
@@ -61,28 +61,28 @@
    * <p>This is closed and assigned to null when the last source is closed and no further sources
    * are permitted.
    */
-  private RandomAccessFile file;
+  RandomAccessFile file;
 
   /** The thread that currently has access to upstream. Possibly null. Guarded by this. */
-  private Thread upstreamReader;
+  Thread upstreamReader;
 
   /**
    * Null once the file has a complete copy of the upstream bytes. Only the {@code upstreamReader}
    * thread may access this source.
    */
-  private Source upstream;
+  Source upstream;
 
   /**
    * A buffer for {@code upstreamReader} to use when pulling bytes from upstream. Only the {@code
    * upstreamReader} thread may access this buffer.
    */
-  private final Buffer upstreamBuffer = new Buffer();
+  final Buffer upstreamBuffer = new Buffer();
 
   /** The number of bytes consumed from {@link #upstream}. Guarded by this. */
-  private long upstreamPos;
+  long upstreamPos;
 
   /** True if there are no further bytes to read from {@code upstream}. Guarded by this. */
-  private boolean complete;
+  boolean complete;
 
   /** User-supplied additional data persisted with the source data. */
   private final ByteString metadata;
@@ -91,17 +91,17 @@
    * The most recently read bytes from {@link #upstream}. This is a suffix of {@link #file}. Guarded
    * by this.
    */
-  private final Buffer buffer = new Buffer();
+  final Buffer buffer = new Buffer();
 
   /** The maximum size of {@code buffer}. */
-  private final long bufferMaxSize;
+  final long bufferMaxSize;
 
   /**
    * Reference count of the number of active sources reading this stream. When decremented to 0
    * resources are released and all following calls to {@link #newSource} return null. Guarded by
    * this.
    */
-  private int sourceCount;
+  int sourceCount;
 
   private Relay(RandomAccessFile file, Source upstream, long upstreamPos, ByteString metadata,
       long bufferMaxSize) {
diff --git a/okhttp/src/main/java/okhttp3/internal/connection/StreamAllocation.java b/okhttp/src/main/java/okhttp3/internal/connection/StreamAllocation.java
index b78e3c54b1..a2213dfc9b 100644
--- a/okhttp/src/main/java/okhttp3/internal/connection/StreamAllocation.java
+++ b/okhttp/src/main/java/okhttp3/internal/connection/StreamAllocation.java
@@ -26,9 +26,9 @@
 import okhttp3.internal.Util;
 import okhttp3.internal.http.HttpCodec;
 import okhttp3.internal.http1.Http1Codec;
+import okhttp3.internal.http2.ConnectionShutdownException;
 import okhttp3.internal.http2.ErrorCode;
 import okhttp3.internal.http2.Http2Codec;
-import okhttp3.internal.http2.ConnectionShutdownException;
 import okhttp3.internal.http2.StreamResetException;
 
 import static java.util.concurrent.TimeUnit.MILLISECONDS;
@@ -342,7 +342,8 @@ public boolean hasMoreRoutes() {
   }
 
   @Override public String toString() {
-    return address.toString();
+    RealConnection connection = connection();
+    return connection != null ? connection.toString() : address.toString();
   }
 
   public static final class StreamAllocationReference extends WeakReference<StreamAllocation> {
diff --git a/okhttp/src/main/java/okhttp3/internal/http/BridgeInterceptor.java b/okhttp/src/main/java/okhttp3/internal/http/BridgeInterceptor.java
index f8a720ff8a..54b561da88 100644
--- a/okhttp/src/main/java/okhttp3/internal/http/BridgeInterceptor.java
+++ b/okhttp/src/main/java/okhttp3/internal/http/BridgeInterceptor.java
@@ -76,7 +76,7 @@ public BridgeInterceptor(CookieJar cookieJar) {
     // If we add an "Accept-Encoding: gzip" header field we're responsible for also decompressing
     // the transfer stream.
     boolean transparentGzip = false;
-    if (userRequest.header("Accept-Encoding") == null) {
+    if (userRequest.header("Accept-Encoding") == null && userRequest.header("Range") == null) {
       transparentGzip = true;
       requestBuilder.header("Accept-Encoding", "gzip");
     }
diff --git a/okhttp/src/main/java/okhttp3/internal/http1/Http1Codec.java b/okhttp/src/main/java/okhttp3/internal/http1/Http1Codec.java
index 3df3696e1f..dc2dd1791e 100644
--- a/okhttp/src/main/java/okhttp3/internal/http1/Http1Codec.java
+++ b/okhttp/src/main/java/okhttp3/internal/http1/Http1Codec.java
@@ -76,13 +76,13 @@
   private static final int STATE_CLOSED = 6;
 
   /** The client that configures this stream. May be null for HTTPS proxy tunnels. */
-  private final OkHttpClient client;
+  final OkHttpClient client;
   /** The stream allocation that owns this stream. May be null for HTTPS proxy tunnels. */
-  private final StreamAllocation streamAllocation;
+  final StreamAllocation streamAllocation;
 
-  private final BufferedSource source;
-  private final BufferedSink sink;
-  private int state = STATE_IDLE;
+  final BufferedSource source;
+  final BufferedSink sink;
+  int state = STATE_IDLE;
 
   public Http1Codec(OkHttpClient client, StreamAllocation streamAllocation, BufferedSource source,
       BufferedSink sink) {
@@ -256,7 +256,7 @@ public Source newUnknownLengthSource() throws IOException {
    * to the default configuration. Use this to avoid unexpected sharing of timeouts between pooled
    * connections.
    */
-  private void detachTimeout(ForwardingTimeout timeout) {
+  void detachTimeout(ForwardingTimeout timeout) {
     Timeout oldDelegate = timeout.delegate();
     timeout.setDelegate(Timeout.NONE);
     oldDelegate.clearDeadline();
@@ -269,7 +269,7 @@ private void detachTimeout(ForwardingTimeout timeout) {
     private boolean closed;
     private long bytesRemaining;
 
-    private FixedLengthSink(long bytesRemaining) {
+    FixedLengthSink(long bytesRemaining) {
       this.bytesRemaining = bytesRemaining;
     }
 
@@ -310,6 +310,9 @@ private FixedLengthSink(long bytesRemaining) {
     private final ForwardingTimeout timeout = new ForwardingTimeout(sink.timeout());
     private boolean closed;
 
+    ChunkedSink() {
+    }
+
     @Override public Timeout timeout() {
       return timeout;
     }
@@ -468,6 +471,9 @@ private void readChunkSize() throws IOException {
   private class UnknownLengthSource extends AbstractSource {
     private boolean inputExhausted;
 
+    UnknownLengthSource() {
+    }
+
     @Override public long read(Buffer sink, long byteCount)
         throws IOException {
       if (byteCount < 0) throw new IllegalArgumentException("byteCount < 0: " + byteCount);
diff --git a/okhttp/src/main/java/okhttp3/internal/http2/Hpack.java b/okhttp/src/main/java/okhttp3/internal/http2/Hpack.java
index 3aeed262b4..a28698bf01 100644
--- a/okhttp/src/main/java/okhttp3/internal/http2/Hpack.java
+++ b/okhttp/src/main/java/okhttp3/internal/http2/Hpack.java
@@ -44,7 +44,7 @@
   private static final int PREFIX_6_BITS = 0x3f;
   private static final int PREFIX_7_BITS = 0x7f;
 
-  private static final Header[] STATIC_HEADER_TABLE = new Header[] {
+  static final Header[] STATIC_HEADER_TABLE = new Header[] {
       new Header(Header.TARGET_AUTHORITY, ""),
       new Header(Header.TARGET_METHOD, "GET"),
       new Header(Header.TARGET_METHOD, "POST"),
@@ -346,7 +346,7 @@ ByteString readByteString() throws IOException {
     }
   }
 
-  private static final Map<ByteString, Integer> NAME_TO_FIRST_INDEX = nameToFirstIndex();
+  static final Map<ByteString, Integer> NAME_TO_FIRST_INDEX = nameToFirstIndex();
 
   private static Map<ByteString, Integer> nameToFirstIndex() {
     Map<ByteString, Integer> result = new LinkedHashMap<>(STATIC_HEADER_TABLE.length);
@@ -587,7 +587,7 @@ private void adjustDynamicTableByteCount() {
    * An HTTP/2 response cannot contain uppercase header characters and must be treated as
    * malformed.
    */
-  private static ByteString checkLowercase(ByteString name) throws IOException {
+  static ByteString checkLowercase(ByteString name) throws IOException {
     for (int i = 0, length = name.size(); i < length; i++) {
       byte c = name.getByte(i);
       if (c >= 'A' && c <= 'Z') {
diff --git a/okhttp/src/main/java/okhttp3/internal/http2/Http2Codec.java b/okhttp/src/main/java/okhttp3/internal/http2/Http2Codec.java
index 0c8c959f86..abd4b5ef3c 100644
--- a/okhttp/src/main/java/okhttp3/internal/http2/Http2Codec.java
+++ b/okhttp/src/main/java/okhttp3/internal/http2/Http2Codec.java
@@ -82,7 +82,7 @@
       UPGRADE);
 
   private final OkHttpClient client;
-  private final StreamAllocation streamAllocation;
+  final StreamAllocation streamAllocation;
   private final Http2Connection connection;
   private Http2Stream stream;
 
diff --git a/okhttp/src/main/java/okhttp3/internal/http2/Http2Connection.java b/okhttp/src/main/java/okhttp3/internal/http2/Http2Connection.java
index 2ca5e0cbac..d79c1b3b28 100644
--- a/okhttp/src/main/java/okhttp3/internal/http2/Http2Connection.java
+++ b/okhttp/src/main/java/okhttp3/internal/http2/Http2Connection.java
@@ -66,7 +66,7 @@
   // operations must synchronize on 'this' last. This ensures that we never
   // wait for a blocking operation while holding 'this'.
 
-  private static final ExecutorService executor = new ThreadPoolExecutor(0,
+  static final ExecutorService executor = new ThreadPoolExecutor(0,
       Integer.MAX_VALUE, 60, TimeUnit.SECONDS, new SynchronousQueue<Runnable>(),
       Util.threadFactory("OkHttp FramedConnection", true));
 
@@ -77,12 +77,12 @@
    * User code to run in response to incoming streams or settings. Calls to this are always invoked
    * on {@link #executor}.
    */
-  private final Listener listener;
-  private final Map<Integer, Http2Stream> streams = new LinkedHashMap<>();
-  private final String hostname;
-  private int lastGoodStreamId;
-  private int nextStreamId;
-  private boolean shutdown;
+  final Listener listener;
+  final Map<Integer, Http2Stream> streams = new LinkedHashMap<>();
+  final String hostname;
+  int lastGoodStreamId;
+  int nextStreamId;
+  boolean shutdown;
 
   /** Ensures push promise callbacks events are sent in order per stream. */
   private final ExecutorService pushExecutor;
@@ -90,7 +90,7 @@
   /** Lazily-created map of in-flight pings awaiting a response. Guarded by this. */
   private Map<Integer, Ping> pings;
   /** User code to run in response to push promise events. */
-  private final PushObserver pushObserver;
+  final PushObserver pushObserver;
   private int nextPingId;
 
   /**
@@ -115,14 +115,14 @@
   // TODO: MWS will need to guard on this setting before attempting to push.
   final Settings peerSettings = new Settings();
 
-  private boolean receivedInitialPeerSettings = false;
+  boolean receivedInitialPeerSettings = false;
   final Socket socket;
   final Http2Writer writer;
 
   // Visible for testing
   final ReaderRunnable readerRunnable;
 
-  private Http2Connection(Builder builder) {
+  Http2Connection(Builder builder) {
     pushObserver = builder.pushObserver;
     client = builder.client;
     listener = builder.listener;
@@ -346,7 +346,7 @@ public Ping ping() throws IOException {
     return ping;
   }
 
-  private void writePingLater(
+  void writePingLater(
       final boolean reply, final int payload1, final int payload2, final Ping ping) {
     executor.execute(new NamedRunnable("OkHttp %s ping %08x%08x",
         hostname, payload1, payload2) {
@@ -359,7 +359,7 @@ private void writePingLater(
     });
   }
 
-  private void writePing(boolean reply, int payload1, int payload2, Ping ping) throws IOException {
+  void writePing(boolean reply, int payload1, int payload2, Ping ping) throws IOException {
     synchronized (writer) {
       // Observe the sent time immediately before performing I/O.
       if (ping != null) ping.send();
@@ -367,7 +367,7 @@ private void writePing(boolean reply, int payload1, int payload2, Ping ping) thr
     }
   }
 
-  private synchronized Ping removePing(int id) {
+  synchronized Ping removePing(int id) {
     return pings != null ? pings.remove(id) : null;
   }
 
@@ -404,7 +404,7 @@ public void shutdown(ErrorCode statusCode) throws IOException {
     close(ErrorCode.NO_ERROR, ErrorCode.CANCEL);
   }
 
-  private void close(ErrorCode connectionCode, ErrorCode streamCode) throws IOException {
+  void close(ErrorCode connectionCode, ErrorCode streamCode) throws IOException {
     assert (!Thread.holdsLock(this));
     IOException thrown = null;
     try {
@@ -501,13 +501,13 @@ public synchronized boolean isShutdown() {
   }
 
   public static class Builder {
-    private Socket socket;
-    private String hostname;
-    private BufferedSource source;
-    private BufferedSink sink;
-    private Listener listener = Listener.REFUSE_INCOMING_STREAMS;
-    private PushObserver pushObserver = PushObserver.CANCEL;
-    private boolean client;
+    Socket socket;
+    String hostname;
+    BufferedSource source;
+    BufferedSink sink;
+    Listener listener = Listener.REFUSE_INCOMING_STREAMS;
+    PushObserver pushObserver = PushObserver.CANCEL;
+    boolean client;
 
     /**
      * @param client true if this peer initiated the connection; false if this peer accepted the
@@ -553,7 +553,7 @@ public Http2Connection build() throws IOException {
   class ReaderRunnable extends NamedRunnable implements Http2Reader.Handler {
     final Http2Reader reader;
 
-    private ReaderRunnable(Http2Reader reader) {
+    ReaderRunnable(Http2Reader reader) {
       super("OkHttp %s", hostname);
       this.reader = reader;
     }
@@ -562,10 +562,8 @@ private ReaderRunnable(Http2Reader reader) {
       ErrorCode connectionErrorCode = ErrorCode.INTERNAL_ERROR;
       ErrorCode streamErrorCode = ErrorCode.INTERNAL_ERROR;
       try {
-        if (!client) {
-          reader.readConnectionPreface();
-        }
-        while (reader.nextFrame(this)) {
+        reader.readConnectionPreface(this);
+        while (reader.nextFrame(false, this)) {
         }
         connectionErrorCode = ErrorCode.NO_ERROR;
         streamErrorCode = ErrorCode.CANCEL;
@@ -771,14 +769,14 @@ public void pushPromise(int streamId, int promisedStreamId, List<Header> request
   }
 
   /** Even, positive numbered streams are pushed streams in HTTP/2. */
-  private boolean pushedStream(int streamId) {
+  boolean pushedStream(int streamId) {
     return streamId != 0 && (streamId & 1) == 0;
   }
 
   // Guarded by this.
-  private final Set<Integer> currentPushRequests = new LinkedHashSet<>();
+  final Set<Integer> currentPushRequests = new LinkedHashSet<>();
 
-  private void pushRequestLater(final int streamId, final List<Header> requestHeaders) {
+  void pushRequestLater(final int streamId, final List<Header> requestHeaders) {
     synchronized (this) {
       if (currentPushRequests.contains(streamId)) {
         writeSynResetLater(streamId, ErrorCode.PROTOCOL_ERROR);
@@ -802,7 +800,7 @@ private void pushRequestLater(final int streamId, final List<Header> requestHead
     });
   }
 
-  private void pushHeadersLater(final int streamId, final List<Header> requestHeaders,
+  void pushHeadersLater(final int streamId, final List<Header> requestHeaders,
       final boolean inFinished) {
     pushExecutor.execute(new NamedRunnable("OkHttp %s Push Headers[%s]", hostname, streamId) {
       @Override public void execute() {
@@ -824,7 +822,7 @@ private void pushHeadersLater(final int streamId, final List<Header> requestHead
    * Eagerly reads {@code byteCount} bytes from the source before launching a background task to
    * process the data.  This avoids corrupting the stream.
    */
-  private void pushDataLater(final int streamId, final BufferedSource source, final int byteCount,
+  void pushDataLater(final int streamId, final BufferedSource source, final int byteCount,
       final boolean inFinished) throws IOException {
     final Buffer buffer = new Buffer();
     source.require(byteCount); // Eagerly read the frame before firing client thread.
@@ -846,7 +844,7 @@ private void pushDataLater(final int streamId, final BufferedSource source, fina
     });
   }
 
-  private void pushResetLater(final int streamId, final ErrorCode errorCode) {
+  void pushResetLater(final int streamId, final ErrorCode errorCode) {
     pushExecutor.execute(new NamedRunnable("OkHttp %s Push Reset[%s]", hostname, streamId) {
       @Override public void execute() {
         pushObserver.onReset(streamId, errorCode);
diff --git a/okhttp/src/main/java/okhttp3/internal/http2/Http2Reader.java b/okhttp/src/main/java/okhttp3/internal/http2/Http2Reader.java
index a2d9e63678..2200756dca 100644
--- a/okhttp/src/main/java/okhttp3/internal/http2/Http2Reader.java
+++ b/okhttp/src/main/java/okhttp3/internal/http2/Http2Reader.java
@@ -57,7 +57,7 @@
  * Http2#INITIAL_MAX_FRAME_SIZE}.
  */
 final class Http2Reader implements Closeable {
-  private static final Logger logger = Logger.getLogger(Http2.class.getName());
+  static final Logger logger = Logger.getLogger(Http2.class.getName());
 
   private final BufferedSource source;
   private final ContinuationSource continuation;
@@ -74,39 +74,48 @@ public Http2Reader(BufferedSource source, boolean client) {
     this.hpackReader = new Hpack.Reader(4096, continuation);
   }
 
-  public void readConnectionPreface() throws IOException {
-    if (client) return; // Nothing to read; servers doesn't send a connection preface!
-    ByteString connectionPreface = source.readByteString(CONNECTION_PREFACE.size());
-    if (logger.isLoggable(FINE)) logger.fine(format("<< CONNECTION %s", connectionPreface.hex()));
-    if (!CONNECTION_PREFACE.equals(connectionPreface)) {
-      throw ioException("Expected a connection header but was %s", connectionPreface.utf8());
+  public void readConnectionPreface(Handler handler) throws IOException {
+    if (client) {
+      // The client reads the initial SETTINGS frame.
+      if (!nextFrame(true, handler)) {
+        throw ioException("Required SETTINGS preface not received");
+      }
+    } else {
+      // The server reads the CONNECTION_PREFACE byte string.
+      ByteString connectionPreface = source.readByteString(CONNECTION_PREFACE.size());
+      if (logger.isLoggable(FINE)) logger.fine(format("<< CONNECTION %s", connectionPreface.hex()));
+      if (!CONNECTION_PREFACE.equals(connectionPreface)) {
+        throw ioException("Expected a connection header but was %s", connectionPreface.utf8());
+      }
     }
   }
 
-  public boolean nextFrame(Handler handler) throws IOException {
+  public boolean nextFrame(boolean requireSettings, Handler handler) throws IOException {
     try {
       source.require(9); // Frame header size
     } catch (IOException e) {
       return false; // This might be a normal socket close.
     }
 
-      /*  0                   1                   2                   3
-       *  0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
-       * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
-       * |                 Length (24)                   |
-       * +---------------+---------------+---------------+
-       * |   Type (8)    |   Flags (8)   |
-       * +-+-+-----------+---------------+-------------------------------+
-       * |R|                 Stream Identifier (31)                      |
-       * +=+=============================================================+
-       * |                   Frame Payload (0...)                      ...
-       * +---------------------------------------------------------------+
-       */
+    //  0                   1                   2                   3
+    //  0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+    // +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+    // |                 Length (24)                   |
+    // +---------------+---------------+---------------+
+    // |   Type (8)    |   Flags (8)   |
+    // +-+-+-----------+---------------+-------------------------------+
+    // |R|                 Stream Identifier (31)                      |
+    // +=+=============================================================+
+    // |                   Frame Payload (0...)                      ...
+    // +---------------------------------------------------------------+
     int length = readMedium(source);
     if (length < 0 || length > INITIAL_MAX_FRAME_SIZE) {
       throw ioException("FRAME_SIZE_ERROR: %s", length);
     }
     byte type = (byte) (source.readByte() & 0xff);
+    if (requireSettings && type != TYPE_SETTINGS) {
+      throw ioException("Expected a SETTINGS frame but was %s", type);
+    }
     byte flags = (byte) (source.readByte() & 0xff);
     int streamId = (source.readInt() & 0x7fffffff); // Ignore reserved bit.
     if (logger.isLoggable(FINE)) logger.fine(frameLog(true, streamId, length, type, flags));
diff --git a/okhttp/src/main/java/okhttp3/internal/http2/Http2Stream.java b/okhttp/src/main/java/okhttp3/internal/http2/Http2Stream.java
index 5997b21288..3d036860a2 100644
--- a/okhttp/src/main/java/okhttp3/internal/http2/Http2Stream.java
+++ b/okhttp/src/main/java/okhttp3/internal/http2/Http2Stream.java
@@ -48,8 +48,8 @@
   // guarded by this
   long bytesLeftInWriteWindow;
 
-  private final int id;
-  private final Http2Connection connection;
+  final int id;
+  final Http2Connection connection;
 
   /** Headers sent by the stream initiator. Immutable and non null. */
   private final List<Header> requestHeaders;
@@ -59,15 +59,15 @@
 
   private final FramedDataSource source;
   final FramedDataSink sink;
-  private final StreamTimeout readTimeout = new StreamTimeout();
-  private final StreamTimeout writeTimeout = new StreamTimeout();
+  final StreamTimeout readTimeout = new StreamTimeout();
+  final StreamTimeout writeTimeout = new StreamTimeout();
 
   /**
    * The reason why this stream was abnormally closed. If there are multiple reasons to abnormally
    * close this stream (such as both peers closing it near-simultaneously) then this is the first
    * reason known to this peer.
    */
-  private ErrorCode errorCode = null;
+  ErrorCode errorCode = null;
 
   Http2Stream(int id, Http2Connection connection, boolean outFinished, boolean inFinished,
       List<Header> requestHeaders) {
@@ -308,15 +308,15 @@ synchronized void receiveRstStream(ErrorCode errorCode) {
     private final long maxByteCount;
 
     /** True if the caller has closed this stream. */
-    private boolean closed;
+    boolean closed;
 
     /**
      * True if either side has cleanly shut down this stream. We will receive no more bytes beyond
      * those already in the buffer.
      */
-    private boolean finished;
+    boolean finished;
 
-    private FramedDataSource(long maxByteCount) {
+    FramedDataSource(long maxByteCount) {
       this.maxByteCount = maxByteCount;
     }
 
@@ -430,7 +430,7 @@ private void checkNotClosed() throws IOException {
     }
   }
 
-  private void cancelStreamIfNecessary() throws IOException {
+  void cancelStreamIfNecessary() throws IOException {
     assert (!Thread.holdsLock(Http2Stream.this));
     boolean open;
     boolean cancel;
@@ -461,12 +461,12 @@ private void cancelStreamIfNecessary() throws IOException {
      */
     private final Buffer sendBuffer = new Buffer();
 
-    private boolean closed;
+    boolean closed;
 
     /**
      * True if either side has cleanly shut down this stream. We shall send no more bytes.
      */
-    private boolean finished;
+    boolean finished;
 
     @Override public void write(Buffer source, long byteCount) throws IOException {
       assert (!Thread.holdsLock(Http2Stream.this));
@@ -552,7 +552,7 @@ void addBytesToWriteWindow(long delta) {
     if (delta > 0) Http2Stream.this.notifyAll();
   }
 
-  private void checkOutNotClosed() throws IOException {
+  void checkOutNotClosed() throws IOException {
     if (sink.closed) {
       throw new IOException("stream closed");
     } else if (sink.finished) {
@@ -566,7 +566,7 @@ private void checkOutNotClosed() throws IOException {
    * Like {@link #wait}, but throws an {@code InterruptedIOException} when interrupted instead of
    * the more awkward {@link InterruptedException}.
    */
-  private void waitForIo() throws InterruptedIOException {
+  void waitForIo() throws InterruptedIOException {
     try {
       wait();
     } catch (InterruptedException e) {
diff --git a/okhttp/src/main/java/okhttp3/internal/http2/Huffman.java b/okhttp/src/main/java/okhttp3/internal/http2/Huffman.java
index 32582e9f40..7aa8024b72 100644
--- a/okhttp/src/main/java/okhttp3/internal/http2/Huffman.java
+++ b/okhttp/src/main/java/okhttp3/internal/http2/Huffman.java
@@ -196,13 +196,13 @@ private void addCode(int sym, int code, byte len) {
   private static final class Node {
 
     // Null if terminal.
-    private final Node[] children;
+    final Node[] children;
 
     // Terminal nodes have a symbol.
-    private final int symbol;
+    final int symbol;
 
     // Number of bits represented in the terminal node.
-    private final int terminalBits;
+    final int terminalBits;
 
     /** Construct an internal node. */
     Node() {
diff --git a/okhttp/src/main/java/okhttp3/internal/platform/JdkWithJettyBootPlatform.java b/okhttp/src/main/java/okhttp3/internal/platform/JdkWithJettyBootPlatform.java
index 3d092b5cc2..6821bdf497 100644
--- a/okhttp/src/main/java/okhttp3/internal/platform/JdkWithJettyBootPlatform.java
+++ b/okhttp/src/main/java/okhttp3/internal/platform/JdkWithJettyBootPlatform.java
@@ -106,9 +106,9 @@ public static Platform buildIfSupported() {
     /** This peer's supported protocols. */
     private final List<String> protocols;
     /** Set when remote peer notifies ALPN is unsupported. */
-    private boolean unsupported;
+    boolean unsupported;
     /** The protocol the server selected. */
-    private String selected;
+    String selected;
 
     public JettyNegoProvider(List<String> protocols) {
       this.protocols = protocols;
diff --git a/okhttp/src/main/java/okhttp3/internal/ws/RealWebSocket.java b/okhttp/src/main/java/okhttp3/internal/ws/RealWebSocket.java
index 861047568a..9ac84f0e29 100644
--- a/okhttp/src/main/java/okhttp3/internal/ws/RealWebSocket.java
+++ b/okhttp/src/main/java/okhttp3/internal/ws/RealWebSocket.java
@@ -22,9 +22,10 @@
 import java.util.Collections;
 import java.util.List;
 import java.util.Random;
-import java.util.concurrent.ExecutorService;
-import java.util.concurrent.SynchronousQueue;
-import java.util.concurrent.ThreadPoolExecutor;
+import java.util.concurrent.ScheduledExecutorService;
+import java.util.concurrent.ScheduledFuture;
+import java.util.concurrent.ScheduledThreadPoolExecutor;
+import java.util.concurrent.TimeUnit;
 import okhttp3.Call;
 import okhttp3.Callback;
 import okhttp3.OkHttpClient;
@@ -34,7 +35,6 @@
 import okhttp3.WebSocket;
 import okhttp3.WebSocketListener;
 import okhttp3.internal.Internal;
-import okhttp3.internal.NamedRunnable;
 import okhttp3.internal.Util;
 import okhttp3.internal.connection.StreamAllocation;
 import okio.BufferedSink;
@@ -42,9 +42,10 @@
 import okio.ByteString;
 import okio.Okio;
 
-import static java.util.concurrent.TimeUnit.SECONDS;
+import static java.util.concurrent.TimeUnit.MILLISECONDS;
 import static okhttp3.internal.Util.closeQuietly;
 import static okhttp3.internal.ws.WebSocketProtocol.CLOSE_CLIENT_GOING_AWAY;
+import static okhttp3.internal.ws.WebSocketProtocol.CLOSE_MESSAGE_MAX;
 import static okhttp3.internal.ws.WebSocketProtocol.OPCODE_BINARY;
 import static okhttp3.internal.ws.WebSocketProtocol.OPCODE_TEXT;
 import static okhttp3.internal.ws.WebSocketProtocol.validateCloseCode;
@@ -58,38 +59,36 @@
    */
   private static final long MAX_QUEUE_SIZE = 16 * 1024 * 1024; // 16 MiB.
 
-  /** A shared executor for all web sockets. */
-  private static final ExecutorService executor = new ThreadPoolExecutor(0,
-      Integer.MAX_VALUE, 60, SECONDS, new SynchronousQueue<Runnable>(),
-      Util.threadFactory("OkHttp WebSocket", true));
+  /**
+   * The maximum amount of time after the client calls {@link #close} to wait for a graceful
+   * shutdown. If the server doesn't respond the websocket will be canceled.
+   */
+  private static final long CANCEL_AFTER_CLOSE_MILLIS = 60 * 1000;
 
   /** The application's original request unadulterated by web socket headers. */
   private final Request originalRequest;
 
-  private final WebSocketListener listener;
+  final WebSocketListener listener;
   private final Random random;
   private final String key;
 
-  /** Non-null for client websockets. These can be canceled. */
+  /** Non-null for client web sockets. These can be canceled. */
   private Call call;
 
   /** This runnable processes the outgoing queues. Call {@link #runWriter()} to after enqueueing. */
-  private final NamedRunnable writerRunnable;
+  private final Runnable writerRunnable;
 
   /** Null until this web socket is connected. Only accessed by the reader thread. */
   private WebSocketReader reader;
 
   // All mutable web socket state is guarded by this.
 
-  /**
-   * True if {@link #writerRunnable} is active. Because writing is single-threaded we only enqueue
-   * it if it isn't already enqueued.
-   */
-  private boolean writerRunning;
-
   /** Null until this web socket is connected. Note that messages may be enqueued before that. */
   private WebSocketWriter writer;
 
+  /** Null until this web socket is connected. Used for writes, pings, and close timeouts. */
+  private ScheduledExecutorService executor;
+
   /**
    * The streams held by this web socket. This is non-null until all incoming messages have been
    * read and all outgoing messages have been written. It is closed when both reader and writer are
@@ -109,6 +108,12 @@
   /** True if we've enqueued a close frame. No further message frames will be enqueued. */
   private boolean enqueuedClose;
 
+  /**
+   * When executed this will cancel this websocket. This future itself should be canceled if that is
+   * unnecessary because the web socket is already closed or canceled.
+   */
+  private ScheduledFuture<?> cancelFuture;
+
   /** The close code from the peer, or -1 if this web socket has not yet read a close frame. */
   private int receivedCloseCode = -1;
 
@@ -118,6 +123,12 @@
   /** True if this web socket failed and the listener has been notified. */
   private boolean failed;
 
+  /** For testing. */
+  int pingCount;
+
+  /** For testing. */
+  int pongCount;
+
   public RealWebSocket(Request request, WebSocketListener listener, Random random) {
     if (!"GET".equals(request.method())) {
       throw new IllegalArgumentException("Request must be GET: " + request.method());
@@ -130,8 +141,8 @@ public RealWebSocket(Request request, WebSocketListener listener, Random random)
     random.nextBytes(nonce);
     this.key = ByteString.of(nonce).base64();
 
-    this.writerRunnable = new NamedRunnable("OkHttp WebSocket %s", request.url().redact()) {
-      @Override protected void execute() {
+    this.writerRunnable = new Runnable() {
+      @Override public void run() {
         try {
           while (writeOneFrame()) {
           }
@@ -158,7 +169,8 @@ public void connect(OkHttpClient client) {
     client = client.newBuilder()
         .protocols(ONLY_HTTP1)
         .build();
-    Request request = originalRequest.newBuilder()
+    final int pingIntervalMillis = client.pingIntervalMillis();
+    final Request request = originalRequest.newBuilder()
         .header("Upgrade", "websocket")
         .header("Connection", "Upgrade")
         .header("Sec-WebSocket-Key", key)
@@ -180,10 +192,11 @@ public void connect(OkHttpClient client) {
         streamAllocation.noNewStreams(); // Prevent connection pooling!
         Streams streams = new ClientStreams(streamAllocation);
 
-        // Process all websocket messages.
+        // Process all web socket messages.
         try {
           listener.onOpen(RealWebSocket.this, response);
-          initReaderAndWriter(streams);
+          String name = "OkHttp WebSocket " + request.url().redact();
+          initReaderAndWriter(name, pingIntervalMillis, streams);
           streamAllocation.connection().socket().setSoTimeout(0);
           loopReader();
         } catch (Exception e) {
@@ -197,7 +210,7 @@ public void connect(OkHttpClient client) {
     });
   }
 
-  private void checkResponse(Response response) throws ProtocolException {
+  void checkResponse(Response response) throws ProtocolException {
     if (response.code() != 101) {
       throw new ProtocolException("Expected HTTP 101 response but was '"
           + response.code() + " " + response.message() + "'");
@@ -224,10 +237,16 @@ private void checkResponse(Response response) throws ProtocolException {
     }
   }
 
-  public void initReaderAndWriter(Streams streams) throws IOException {
+  public void initReaderAndWriter(
+      String name, long pingIntervalMillis, Streams streams) throws IOException {
     synchronized (this) {
       this.streams = streams;
       this.writer = new WebSocketWriter(streams.client, streams.sink, random);
+      this.executor = new ScheduledThreadPoolExecutor(1, Util.threadFactory(name, false));
+      if (pingIntervalMillis != 0) {
+        executor.scheduleAtFixedRate(
+            new PingRunnable(), pingIntervalMillis, pingIntervalMillis, MILLISECONDS);
+      }
       if (!messageAndCloseQueue.isEmpty()) {
         runWriter(); // Send messages that were enqueued before we were connected.
       }
@@ -258,6 +277,21 @@ boolean processNextFrame() throws IOException {
     }
   }
 
+  /**
+   * For testing: wait until the web socket's executor has terminated.
+   */
+  void awaitTermination(int timeout, TimeUnit timeUnit) throws InterruptedException {
+    executor.awaitTermination(timeout, timeUnit);
+  }
+
+  synchronized int pingCount() {
+    return pingCount;
+  }
+
+  synchronized int pongCount() {
+    return pongCount;
+  }
+
   @Override public void onReadMessage(String text) throws IOException {
     listener.onMessage(this, text);
   }
@@ -266,16 +300,18 @@ boolean processNextFrame() throws IOException {
     listener.onMessage(this, bytes);
   }
 
-  @Override public synchronized void onReadPing(final ByteString payload) {
+  @Override public synchronized void onReadPing(ByteString payload) {
     // Don't respond to pings after we've failed or sent the close frame.
     if (failed || (enqueuedClose && messageAndCloseQueue.isEmpty())) return;
 
     pongQueue.add(payload);
     runWriter();
+    pingCount++;
   }
 
-  @Override public void onReadPong(ByteString buffer) {
+  @Override public synchronized void onReadPong(ByteString buffer) {
     // This API doesn't expose pings.
+    pongCount++;
   }
 
   @Override public void onReadClose(int code, String reason) {
@@ -289,6 +325,8 @@ boolean processNextFrame() throws IOException {
       if (enqueuedClose && messageAndCloseQueue.isEmpty()) {
         toClose = this.streams;
         this.streams = null;
+        if (cancelFuture != null) cancelFuture.cancel(false);
+        this.executor.shutdown();
       }
     }
 
@@ -332,7 +370,7 @@ private synchronized boolean send(ByteString data, int formatOpcode) {
     return true;
   }
 
-  public synchronized boolean pong(ByteString payload) {
+  synchronized boolean pong(ByteString payload) {
     // Don't send pongs after we've failed or sent the close frame.
     if (failed || (enqueuedClose && messageAndCloseQueue.isEmpty())) return false;
 
@@ -341,9 +379,20 @@ public synchronized boolean pong(ByteString payload) {
     return true;
   }
 
-  @Override public synchronized boolean close(final int code, final String reason) {
+  @Override public boolean close(int code, String reason) {
+    return close(code, reason, CANCEL_AFTER_CLOSE_MILLIS);
+  }
+
+  synchronized boolean close(int code, String reason, long cancelAfterCloseMillis) {
     validateCloseCode(code);
-    // TODO(jwilson): confirm reason is well-formed. (<=123 bytes, etc.)
+
+    ByteString reasonBytes = null;
+    if (reason != null) {
+      reasonBytes = ByteString.encodeUtf8(reason);
+      if (reasonBytes.size() > CLOSE_MESSAGE_MAX) {
+        throw new IllegalArgumentException("reason.size() > " + CLOSE_MESSAGE_MAX + ": " + reason);
+      }
+    }
 
     if (failed || enqueuedClose) return false;
 
@@ -351,7 +400,7 @@ public synchronized boolean pong(ByteString payload) {
     enqueuedClose = true;
 
     // Enqueue the close frame.
-    messageAndCloseQueue.add(new Close(code, reason));
+    messageAndCloseQueue.add(new Close(code, reasonBytes, cancelAfterCloseMillis));
     runWriter();
     return true;
   }
@@ -359,8 +408,7 @@ public synchronized boolean pong(ByteString payload) {
   private void runWriter() {
     assert (Thread.holdsLock(this));
 
-    if (!writerRunning) {
-      writerRunning = true;
+    if (executor != null) {
       executor.execute(writerRunnable);
     }
   }
@@ -378,7 +426,7 @@ private void runWriter() {
    * <p>This method may only be invoked by the writer thread. There may be only thread invoking this
    * method at a time.
    */
-  private boolean writeOneFrame() throws IOException {
+  boolean writeOneFrame() throws IOException {
     WebSocketWriter writer;
     ByteString pong;
     Object messageOrClose = null;
@@ -388,16 +436,10 @@ private boolean writeOneFrame() throws IOException {
 
     synchronized (RealWebSocket.this) {
       if (failed) {
-        writerRunning = false;
         return false; // Failed web socket.
       }
 
       writer = this.writer;
-      if (writer == null) {
-        writerRunning = false;
-        return false; // Not yet connected.
-      }
-
       pong = pongQueue.poll();
       if (pong == null) {
         messageOrClose = messageAndCloseQueue.poll();
@@ -407,10 +449,13 @@ private boolean writeOneFrame() throws IOException {
           if (receivedCloseCode != -1) {
             streamsToClose = this.streams;
             this.streams = null;
+            this.executor.shutdown();
+          } else {
+            // When we request a graceful close also schedule a cancel of the websocket.
+            cancelFuture = executor.schedule(new CancelRunnable(),
+                ((Close) messageOrClose).cancelAfterCloseMillis, MILLISECONDS);
           }
-
         } else if (messageOrClose == null) {
-          writerRunning = false;
           return false; // The queue is exhausted.
         }
       }
@@ -449,13 +494,35 @@ private boolean writeOneFrame() throws IOException {
     }
   }
 
-  private void failWebSocket(Exception e, Response response) {
+  private final class PingRunnable implements Runnable {
+    @Override public void run() {
+      writePingFrame();
+    }
+  }
+
+  private void writePingFrame() {
+    WebSocketWriter writer;
+    synchronized (this) {
+      if (failed) return;
+      writer = this.writer;
+    }
+
+    try {
+      writer.writePing(ByteString.EMPTY);
+    } catch (IOException e) {
+      failWebSocket(e, null);
+    }
+  }
+
+  void failWebSocket(Exception e, Response response) {
     Streams streamsToClose;
     synchronized (this) {
       if (failed) return; // Already failed.
       failed = true;
       streamsToClose = this.streams;
       this.streams = null;
+      if (cancelFuture != null) cancelFuture.cancel(false);
+      if (executor != null) executor.shutdown();
     }
 
     try {
@@ -469,7 +536,7 @@ private void failWebSocket(Exception e, Response response) {
     final int formatOpcode;
     final ByteString data;
 
-    public Message(int formatOpcode, ByteString data) {
+    Message(int formatOpcode, ByteString data) {
       this.formatOpcode = formatOpcode;
       this.data = data;
     }
@@ -477,18 +544,20 @@ public Message(int formatOpcode, ByteString data) {
 
   static final class Close {
     final int code;
-    final String reason;
+    final ByteString reason;
+    final long cancelAfterCloseMillis;
 
-    public Close(int code, String reason) {
+    Close(int code, ByteString reason, long cancelAfterCloseMillis) {
       this.code = code;
       this.reason = reason;
+      this.cancelAfterCloseMillis = cancelAfterCloseMillis;
     }
   }
 
   public abstract static class Streams implements Closeable {
-    final boolean client;
-    final BufferedSource source;
-    final BufferedSink sink;
+    public final boolean client;
+    public final BufferedSource source;
+    public final BufferedSink sink;
 
     public Streams(boolean client, BufferedSource source, BufferedSink sink) {
       this.client = client;
@@ -500,7 +569,7 @@ public Streams(boolean client, BufferedSource source, BufferedSink sink) {
   static final class ClientStreams extends Streams {
     private final StreamAllocation streamAllocation;
 
-    public ClientStreams(StreamAllocation streamAllocation) {
+    ClientStreams(StreamAllocation streamAllocation) {
       super(true, streamAllocation.connection().source, streamAllocation.connection().sink);
       this.streamAllocation = streamAllocation;
     }
@@ -509,4 +578,10 @@ public ClientStreams(StreamAllocation streamAllocation) {
       streamAllocation.streamFinished(true, streamAllocation.codec());
     }
   }
+
+  final class CancelRunnable implements Runnable {
+    @Override public void run() {
+      cancel();
+    }
+  }
 }
diff --git a/okhttp/src/main/java/okhttp3/internal/ws/WebSocketProtocol.java b/okhttp/src/main/java/okhttp3/internal/ws/WebSocketProtocol.java
index 8cd2bd2e72..5be61eea5f 100644
--- a/okhttp/src/main/java/okhttp3/internal/ws/WebSocketProtocol.java
+++ b/okhttp/src/main/java/okhttp3/internal/ws/WebSocketProtocol.java
@@ -74,6 +74,8 @@
    * special values {@link #PAYLOAD_SHORT} or {@link #PAYLOAD_LONG}.
    */
   static final long PAYLOAD_BYTE_MAX = 125L;
+  /** Maximum length of close message in bytes. */
+  static final long CLOSE_MESSAGE_MAX = PAYLOAD_BYTE_MAX - 2;
   /**
    * Value for {@link #B1_MASK_LENGTH} which indicates the next two bytes are the unsigned length.
    */
diff --git a/okhttp/src/main/java/okhttp3/internal/ws/WebSocketWriter.java b/okhttp/src/main/java/okhttp3/internal/ws/WebSocketWriter.java
index 237ec100f3..9c466d672d 100644
--- a/okhttp/src/main/java/okhttp3/internal/ws/WebSocketWriter.java
+++ b/okhttp/src/main/java/okhttp3/internal/ws/WebSocketWriter.java
@@ -33,8 +33,8 @@
 import static okhttp3.internal.ws.WebSocketProtocol.PAYLOAD_LONG;
 import static okhttp3.internal.ws.WebSocketProtocol.PAYLOAD_SHORT;
 import static okhttp3.internal.ws.WebSocketProtocol.PAYLOAD_SHORT_MAX;
-import static okhttp3.internal.ws.WebSocketProtocol.validateCloseCode;
 import static okhttp3.internal.ws.WebSocketProtocol.toggleMask;
+import static okhttp3.internal.ws.WebSocketProtocol.validateCloseCode;
 
 /**
  * An <a href="http://tools.ietf.org/html/rfc6455">RFC 6455</a>-compatible WebSocket frame writer.
@@ -94,7 +94,7 @@ void writePong(ByteString payload) throws IOException {
    * href="http://tools.ietf.org/html/rfc6455#section-7.4">Section 7.4 of RFC 6455</a> or {@code 0}.
    * @param reason Reason for shutting down or {@code null}.
    */
-  void writeClose(int code, String reason) throws IOException {
+  void writeClose(int code, ByteString reason) throws IOException {
     ByteString payload = ByteString.EMPTY;
     if (code != 0 || reason != null) {
       if (code != 0) {
@@ -103,7 +103,7 @@ void writeClose(int code, String reason) throws IOException {
       Buffer buffer = new Buffer();
       buffer.writeShort(code);
       if (reason != null) {
-        buffer.writeUtf8(reason);
+        buffer.write(reason);
       }
       payload = buffer.readByteString();
     }
diff --git a/pom.xml b/pom.xml
index e1b638cb6c..bda83e1ade 100644
--- a/pom.xml
+++ b/pom.xml
@@ -11,7 +11,7 @@
 
   <groupId>com.squareup.okhttp3</groupId>
   <artifactId>parent</artifactId>
-  <version>3.5.0-SNAPSHOT</version>
+  <version>3.6.0-SNAPSHOT</version>
   <packaging>pom</packaging>
 
   <name>OkHttp (Parent)</name>
diff --git a/samples/crawler/pom.xml b/samples/crawler/pom.xml
index 8b91ca2dd7..7587628005 100644
--- a/samples/crawler/pom.xml
+++ b/samples/crawler/pom.xml
@@ -6,7 +6,7 @@
   <parent>
     <groupId>com.squareup.okhttp3.sample</groupId>
     <artifactId>sample-parent</artifactId>
-    <version>3.5.0-SNAPSHOT</version>
+    <version>3.6.0-SNAPSHOT</version>
   </parent>
 
   <artifactId>crawler</artifactId>
diff --git a/samples/guide/pom.xml b/samples/guide/pom.xml
index 2d0c791c38..4b55e5325c 100644
--- a/samples/guide/pom.xml
+++ b/samples/guide/pom.xml
@@ -6,7 +6,7 @@
   <parent>
     <groupId>com.squareup.okhttp3.sample</groupId>
     <artifactId>sample-parent</artifactId>
-    <version>3.5.0-SNAPSHOT</version>
+    <version>3.6.0-SNAPSHOT</version>
   </parent>
 
   <artifactId>guide</artifactId>
diff --git a/samples/pom.xml b/samples/pom.xml
index 1c0dc8b829..d88108480b 100644
--- a/samples/pom.xml
+++ b/samples/pom.xml
@@ -6,7 +6,7 @@
   <parent>
     <groupId>com.squareup.okhttp3</groupId>
     <artifactId>parent</artifactId>
-    <version>3.5.0-SNAPSHOT</version>
+    <version>3.6.0-SNAPSHOT</version>
   </parent>
 
   <groupId>com.squareup.okhttp3.sample</groupId>
diff --git a/samples/simple-client/pom.xml b/samples/simple-client/pom.xml
index c3330e4025..b5f4cb46fb 100644
--- a/samples/simple-client/pom.xml
+++ b/samples/simple-client/pom.xml
@@ -6,7 +6,7 @@
   <parent>
     <groupId>com.squareup.okhttp3.sample</groupId>
     <artifactId>sample-parent</artifactId>
-    <version>3.5.0-SNAPSHOT</version>
+    <version>3.6.0-SNAPSHOT</version>
   </parent>
 
   <artifactId>simple-client</artifactId>
diff --git a/samples/slack/pom.xml b/samples/slack/pom.xml
index 2b4d58b769..06d78916a1 100644
--- a/samples/slack/pom.xml
+++ b/samples/slack/pom.xml
@@ -6,7 +6,7 @@
   <parent>
     <groupId>com.squareup.okhttp3.sample</groupId>
     <artifactId>sample-parent</artifactId>
-    <version>3.5.0-SNAPSHOT</version>
+    <version>3.6.0-SNAPSHOT</version>
   </parent>
 
   <artifactId>slack</artifactId>
diff --git a/samples/slack/src/main/java/okhttp3/slack/SlackApi.java b/samples/slack/src/main/java/okhttp3/slack/SlackApi.java
index 7515a426e8..0ec0ef7a45 100644
--- a/samples/slack/src/main/java/okhttp3/slack/SlackApi.java
+++ b/samples/slack/src/main/java/okhttp3/slack/SlackApi.java
@@ -34,7 +34,7 @@
  * instance of this class may operate without a user, or on behalf of many users. Use the Slack API
  * dashboard to create a client ID and secret for this application.
  *
- * <p>You must configure your Slack API OAuth & Permissions page with a localhost URL like {@code
+ * <p>You must configure your Slack API OAuth and Permissions page with a localhost URL like {@code
  * http://localhost:53203/oauth/}, passing the same port to this class’ constructor.
  */
 public final class SlackApi {
diff --git a/samples/static-server/pom.xml b/samples/static-server/pom.xml
index ca52ac4b8a..3d86d04ca5 100644
--- a/samples/static-server/pom.xml
+++ b/samples/static-server/pom.xml
@@ -6,7 +6,7 @@
   <parent>
     <groupId>com.squareup.okhttp3.sample</groupId>
     <artifactId>sample-parent</artifactId>
-    <version>3.5.0-SNAPSHOT</version>
+    <version>3.6.0-SNAPSHOT</version>
   </parent>
 
   <artifactId>static-server</artifactId>
