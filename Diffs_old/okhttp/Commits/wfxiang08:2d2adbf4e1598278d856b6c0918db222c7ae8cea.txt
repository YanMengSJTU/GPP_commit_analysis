diff --git a/okhttp-tests/src/test/java/okhttp3/CallTest.java b/okhttp-tests/src/test/java/okhttp3/CallTest.java
index 950d9406ef..0db3d4e5be 100644
--- a/okhttp-tests/src/test/java/okhttp3/CallTest.java
+++ b/okhttp-tests/src/test/java/okhttp3/CallTest.java
@@ -27,6 +27,7 @@
 import java.net.ProtocolException;
 import java.net.Proxy;
 import java.net.ServerSocket;
+import java.net.UnknownHostException;
 import java.net.UnknownServiceException;
 import java.security.cert.Certificate;
 import java.util.ArrayList;
@@ -1399,6 +1400,37 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
         .assertNoCacheResponse();
   }
 
+  @Test public void networkDropsOnConditionalGet() throws IOException {
+    client = client.newBuilder()
+        .cache(cache)
+        .build();
+
+    // Seed the cache.
+    server.enqueue(new MockResponse()
+        .addHeader("ETag: v1")
+        .setBody("A"));
+    Request cacheStoreRequest = new Request.Builder()
+        .url(server.url("/"))
+        .build();
+    executeSynchronously(cacheStoreRequest)
+        .assertCode(200)
+        .assertBody("A");
+
+    // Attempt conditional cache validation and a DNS miss.
+    client.connectionPool().evictAll();
+    client = client.newBuilder()
+        .dns(new FakeDns().unknownHost())
+        .build();
+    Request conditionalGetRequest = new Request.Builder()
+        .url(server.url("/"))
+        .build();
+    try {
+      executeSynchronously(conditionalGetRequest);
+      fail();
+    } catch (UnknownHostException expected) {
+    }
+  }
+
   @Test public void redirect() throws Exception {
     server.enqueue(new MockResponse()
         .setResponseCode(301)
diff --git a/okhttp/src/main/java/okhttp3/internal/http/HttpEngine.java b/okhttp/src/main/java/okhttp3/internal/http/HttpEngine.java
index 20e976a9ca..a352bb64c8 100644
--- a/okhttp/src/main/java/okhttp3/internal/http/HttpEngine.java
+++ b/okhttp/src/main/java/okhttp3/internal/http/HttpEngine.java
@@ -211,15 +211,37 @@ public void sendRequest() throws RequestException, RouteException, IOException {
       closeQuietly(cacheCandidate.body()); // The cache candidate wasn't applicable. Close it.
     }
 
-    if (networkRequest != null) {
+    // If we're forbidden from using the network and the cache is insufficient, fail.
+    if (networkRequest == null && cacheResponse == null) {
+      userResponse = new Response.Builder()
+          .request(userRequest)
+          .priorResponse(stripBody(priorResponse))
+          .protocol(Protocol.HTTP_1_1)
+          .code(504)
+          .message("Unsatisfiable Request (only-if-cached)")
+          .body(EMPTY_BODY)
+          .build();
+      return;
+    }
+
+    // If we don't need the network, we're done.
+    if (networkRequest == null) {
+      userResponse = cacheResponse.newBuilder()
+          .request(userRequest)
+          .priorResponse(stripBody(priorResponse))
+          .cacheResponse(stripBody(cacheResponse))
+          .build();
+      userResponse = unzip(userResponse);
+      return;
+    }
+
+    // We need the network to satisfy this request. Possibly for validating a conditional GET.
+    boolean success = false;
+    try {
       httpStream = connect();
       httpStream.setHttpEngine(this);
 
-      // If the caller's control flow writes the request body, we need to create that stream
-      // immediately. And that means we need to immediately write the request headers, so we can
-      // start streaming the request body. (We may already have a request body if we're retrying a
-      // failed POST.)
-      if (callerWritesRequestBody && permitsRequestBody(networkRequest) && requestBodyOut == null) {
+      if (writeRequestHeadersEagerly()) {
         long contentLength = OkHeaders.contentLength(request);
         if (bufferRequestBody) {
           if (contentLength > Integer.MAX_VALUE) {
@@ -232,9 +254,8 @@ public void sendRequest() throws RequestException, RouteException, IOException {
             httpStream.writeRequestHeaders(networkRequest);
             requestBodyOut = new RetryableSink((int) contentLength);
           } else {
-            // Buffer a request body of an unknown length. Don't write request
-            // headers until the entire body is ready; otherwise we can't set the
-            // Content-Length header correctly.
+            // Buffer a request body of an unknown length. Don't write request headers until the
+            // entire body is ready; otherwise we can't set the Content-Length header correctly.
             requestBodyOut = new RetryableSink();
           }
         } else {
@@ -242,30 +263,27 @@ public void sendRequest() throws RequestException, RouteException, IOException {
           requestBodyOut = httpStream.createRequestBody(networkRequest, contentLength);
         }
       }
-    } else {
-      if (cacheResponse != null) {
-        // We have a valid cached response. Promote it to the user response immediately.
-        this.userResponse = cacheResponse.newBuilder()
-            .request(userRequest)
-            .priorResponse(stripBody(priorResponse))
-            .cacheResponse(stripBody(cacheResponse))
-            .build();
-      } else {
-        // We're forbidden from using the network, and the cache is insufficient.
-        this.userResponse = new Response.Builder()
-            .request(userRequest)
-            .priorResponse(stripBody(priorResponse))
-            .protocol(Protocol.HTTP_1_1)
-            .code(504)
-            .message("Unsatisfiable Request (only-if-cached)")
-            .body(EMPTY_BODY)
-            .build();
+      success = true;
+    } finally {
+      // If we're crashing on I/O or otherwise, don't leak the cache body.
+      if (!success && cacheCandidate != null) {
+        closeQuietly(cacheCandidate.body());
       }
-
-      userResponse = unzip(userResponse);
     }
   }
 
+  /**
+   * If the caller's control flow writes the request body, we need to create that stream
+   * immediately. And that means we need to immediately write the request headers, so we can
+   * start streaming the request body. (We may already have a request body if we're retrying a
+   * failed POST.)
+   */
+  private boolean writeRequestHeadersEagerly() {
+    return callerWritesRequestBody
+        && permitsRequestBody(networkRequest)
+        && requestBodyOut == null;
+  }
+
   private HttpStream connect() throws RouteException, RequestException, IOException {
     boolean doExtensiveHealthChecks = !networkRequest.method().equals("GET");
     return streamAllocation.newStream(client.connectTimeoutMillis(),
