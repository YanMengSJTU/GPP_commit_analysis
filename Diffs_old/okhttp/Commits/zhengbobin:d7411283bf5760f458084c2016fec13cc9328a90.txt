diff --git a/.circleci/config.yml b/.circleci/config.yml
index 6d377608e7..bb042a7910 100644
--- a/.circleci/config.yml
+++ b/.circleci/config.yml
@@ -154,6 +154,21 @@ jobs:
       - runtests:
           platform: jdk9
 
+  testjdk12:
+    docker:
+      # best source of JDK 12 for now
+      - image: circleci/dynamodb:12.0.1-jdk
+
+    environment:
+      JVM_OPTS: -Xmx1g
+      TERM: dumb
+
+    steps:
+      - checkout
+
+      - runtests:
+          platform: jdk9
+
   testconscrypt:
     docker:
       - image: circleci/openjdk:11.0.3-jdk-stretch
@@ -187,11 +202,15 @@ workflows:
             branches:
               only: master
       - testjdk8alpn:
+          filters:
+            branches:
+              only: master
+      - testjdk11:
           filters:
             branches:
               ignore:
                 - gh-pages
-      - testjdk11:
+      - testjdk12:
           filters:
             branches:
               only: master
@@ -220,6 +239,9 @@ workflows:
       - testjdk11:
           requires:
             - compile
+      - testjdk12:
+          requires:
+            - compile
       - testconscrypt:
           requires:
             - compile
diff --git a/.gitignore b/.gitignore
index 2989c1ec8e..b541aaa994 100644
--- a/.gitignore
+++ b/.gitignore
@@ -27,7 +27,7 @@ obj
 .DS_Store
 
 # Special Mkdocs files
-docs/api
+docs/4.x
 docs/changelog.md
 docs/contributing.md
 docs/index.md
diff --git a/.travis.yml b/.travis.yml
index 4164354f0c..143348a630 100644
--- a/.travis.yml
+++ b/.travis.yml
@@ -1,10 +1,16 @@
 language: java
 
+dist: trusty
+
 jdk:
   - oraclejdk8
 
+# avoid ./gradlew assemble default which builds docs
+install:
+ - ./gradlew jar --parallel
+
 script:
- - ./gradlew check
+ - ./gradlew test --parallel
 
 after_success:
   - .buildscript/deploy_snapshot.sh
diff --git a/CHANGELOG.md b/CHANGELOG.md
index 1e9275cb12..9d841de09c 100644
--- a/CHANGELOG.md
+++ b/CHANGELOG.md
@@ -1,15 +1,83 @@
 Change Log
 ==========
 
+## Version 4.1.0
+
+_2019-08-12_
+
+ [brotli]: https://github.com/google/brotli
+
+ *  **OkHttp's new okhttp-brotli module implements Brotli compression.** Install the interceptor to
+    enable [Brotli compression][brotli], which compresses 5-20% smaller than gzip.
+
+    ```
+    val client = OkHttpClient.Builder()
+        .addInterceptor(BrotliInterceptor)
+        .build()
+    ```
+
+    This artifact has a dependency on Google's Brotli decoder (95 KiB).
+
+ *  New: `EventListener.proxySelectStart()`, `proxySelectEnd()` events give visibility into the
+    proxy selection process.
+ *  New: `Response.byteString()` reads the entire response into memory as a byte string.
+ *  New: `OkHttpClient.x509TrustManager` accessor.
+ *  New: Permit [new WebSocket response codes][iana_websocket]: 1012 (Service Restart), 1013 (Try
+    Again Later), and 1014 (invalid response from the upstream).
+ *  New: Build with Kotlin 1.3.41, BouncyCastle 1.62, and Conscrypt 2.2.1.
+ *  Fix: Recover gracefully when a a coalesced connection immediately goes unhealthy.
+ *  Fix: Defer the `SecurityException` when looking up the default proxy selector.
+ *  Fix: Don't use brackets formatting IPv6 host names in MockWebServer.
+ *  Fix: Don't permit cache iterators to remove entries that are being written.
+
+
+## Version 4.0.1
+
+_2019-07-10_
+
+ *  Fix: Tolerate null-hostile lists in public API. Lists created with `List.of(...)` don't like it
+    when you call `contains(null)` on them!
+ *  Fix: Retain binary-compatibility in `okhttp3.internal.HttpHeaders.hasBody()`. Some unscrupulous
+    coders call this and we don't want their users to suffer.
+
+
+## Version 4.0.0
+
+_2019-06-26_
+
+**This release upgrades OkHttp to Kotlin.** We tried our best to make fast and safe to upgrade
+from OkHttp 3.x. We wrote an [upgrade guide][upgrading_to_okhttp_4] to help with the migration and a
+[blog post][okhttp4_blog_post] to explain it.
+
+ *  Fix: Target Java 8 bytecode for Java and Kotlin.
+
+
+## Version 4.0.0-RC3
+
+_2019-06-24_
+
+ *  Fix: Retain binary-compatibility in `okhttp3.internal.HttpMethod`. Naughty third party SDKs
+    import this and we want to ease upgrades for their users.
+
+
+## Version 4.0.0-RC2
+
+_2019-06-21_
+
+ *  New: Require Kotlin 1.3.40.
+ *  New: Change the Kotlin API from `File.toRequestBody()` to `File.asRequestBody()` and
+    `BufferedSource.toResponseBody()` to `BufferedSource.asResponseBody()`. If the returned value
+    is a view of what created it, we use _as_.
+ *  Fix: Permit response codes of zero for compatibility with OkHttp 3.x.
+ *  Fix: Change the return type of `MockWebServer.takeRequest()` to be nullable.
+ *  Fix: Make `Call.clone()` public to Kotlin callers.
+
+
 ## Version 4.0.0-RC1
 
 _2019-06-03_
 
-**OkHttp 4 upgrades OkHttp to Kotlin.** This is the first stable preview of OkHttp 4. Use it to find
-bugs or performance regressions before the final 4.0.0 release.
-
-We tried our best to make it fast and safe to upgrade from OkHttp 3.x.
-[We even wrote a guide][upgrading_to_okhttp_4] to help you with it!
+ *  First stable preview of OkHttp 4.
 
 
 ## Version 3.14.2
@@ -1773,7 +1841,7 @@ Initial release.
 
  [brick]: https://noncombatant.org/2015/05/01/about-http-public-key-pinning/
  [webdav]: https://tools.ietf.org/html/rfc4918
- [major_versions]: http://jakewharton.com/java-interoperability-policy-for-major-version-updates/
+ [major_versions]: https://jakewharton.com/java-interoperability-policy-for-major-version-updates/
  [nginx_959]: https://trac.nginx.org/nginx/ticket/959
  [okhttp_idling_resource]: https://github.com/JakeWharton/okhttp-idling-resource
  [bom]: https://en.wikipedia.org/wiki/Byte_order_mark
@@ -1784,10 +1852,12 @@ Initial release.
  [conscrypt]: https://github.com/google/conscrypt/
  [conscrypt_dependency]: https://github.com/google/conscrypt/#download
  [https_server_sample]: https://github.com/square/okhttp/blob/master/samples/guide/src/main/java/okhttp3/recipes/HttpsServer.java
- [require_android_5]: https://medium.com/square-corner-blog/okhttp-3-13-requires-android-5-818bb78d07ce
+ [require_android_5]: https://cashapp.github.io/2019-02-05/okhttp-3-13-requires-android-5
  [obsolete_apache_client]: https://gist.github.com/swankjesse/09721f72039e3a46cf50f94323deb82d
  [obsolete_url_factory]: https://gist.github.com/swankjesse/dd91c0a8854e1559b00f5fc9c7bfae70
- [tls_configuration_history]: http://square.github.io/okhttp/tls_configuration_history/
+ [tls_configuration_history]: https://square.github.io/okhttp/tls_configuration_history/
  [grpc_http2]: https://github.com/grpc/grpc/blob/master/doc/PROTOCOL-HTTP2.md
- [upgrading_to_okhttp_4]: http://square.github.io/okhttp/upgrading_to_okhttp_4/
- [interceptors]: http://square.github.io/okhttp/interceptors/
+ [upgrading_to_okhttp_4]: https://square.github.io/okhttp/upgrading_to_okhttp_4/
+ [interceptors]: https://square.github.io/okhttp/interceptors/
+ [okhttp4_blog_post]: https://cashapp.github.io/2019-06-26/okhttp-4-goes-kotlin
+ [iana_websocket]: https://www.iana.org/assignments/websocket/websocket.txt
diff --git a/README.md b/README.md
index 999455282f..bb34cd2a31 100644
--- a/README.md
+++ b/README.md
@@ -74,7 +74,7 @@ Requirements
 
 OkHttp works on Android 5.0+ (API level 21+) and on Java 8+.
 
-OkHttp has one library dependency on [Okio][okio], a small library for high-performance I/O.
+OkHttp depends on [Okio][okio] for high-performance I/O and the [Kotlin standard library][kotlin]. Both are small libraries with strong backwards-compatibility.
 
 We highly recommend you keep OkHttp up-to-date. As with auto-updating web browsers, staying current
 with HTTPS clients is an important defense against potential security problems. [We
@@ -100,7 +100,7 @@ Releases
 Our [change log][changelog] has release history.
 
 ```kotlin
-implementation("com.squareup.okhttp3:okhttp:3.14.2")
+implementation("com.squareup.okhttp3:okhttp:4.1.0")
 ```
 
 Snapshot builds are [available][snap].
@@ -120,7 +120,7 @@ MockWebServer
 OkHttp includes a library for testing HTTP, HTTPS, and HTTP/2 clients.
 
 ```kotlin
-testImplementation("com.squareup.okhttp3:mockwebserver:3.14.2")
+testImplementation("com.squareup.okhttp3:mockwebserver:4.1.0")
 ```
 
 
@@ -146,6 +146,7 @@ limitations under the License.
  [changelog]: http://square.github.io/okhttp/changelog/
  [conscrypt]: https://github.com/google/conscrypt/
  [get_example]: https://raw.github.com/square/okhttp/master/samples/guide/src/main/java/okhttp3/guide/GetExample.java
+ [kotlin]: https://kotlinlang.org/
  [okhttp3_pro]: https://github.com/square/okhttp/blob/master/okhttp/src/main/resources/META-INF/proguard/okhttp3.pro
  [okhttp_312x]: https://github.com/square/okhttp/tree/okhttp_3.12.x
  [okhttp]: https://square.github.io/okhttp/
diff --git a/android-test/build.gradle b/android-test/build.gradle
new file mode 100644
index 0000000000..995d5bef1f
--- /dev/null
+++ b/android-test/build.gradle
@@ -0,0 +1,39 @@
+apply plugin: 'com.android.library'
+apply plugin: 'org.jetbrains.kotlin.android'
+
+repositories {
+  jcenter {
+    // Required for a dependency of Android lint.
+    content {
+      includeGroup 'org.jetbrains.trove4j'
+    }
+  }
+}
+
+android {
+  compileOptions {
+    sourceCompatibility JavaVersion.VERSION_1_8
+    targetCompatibility JavaVersion.VERSION_1_8
+  }
+
+  compileSdkVersion 29
+
+  defaultConfig {
+    minSdkVersion 21
+    targetSdkVersion 29
+    versionCode 1
+    versionName "1.0"
+
+    testInstrumentationRunner "android.support.test.runner.AndroidJUnitRunner"
+  }
+}
+
+dependencies {
+  implementation "org.jetbrains.kotlin:kotlin-stdlib-jdk8:${versions.kotlin}"
+  implementation project(':okhttp')
+  testImplementation 'junit:junit:4.12'
+  androidTestImplementation project(':mockwebserver')
+  androidTestImplementation project(':okhttp-tls')
+  androidTestImplementation 'com.android.support.test:runner:1.0.2'
+  androidTestImplementation 'com.android.support.test.espresso:espresso-core:3.0.2'
+}
diff --git a/android-test/settings.gradle b/android-test/settings.gradle
new file mode 100644
index 0000000000..fa80fbee19
--- /dev/null
+++ b/android-test/settings.gradle
@@ -0,0 +1 @@
+project.name = 'android-test'
\ No newline at end of file
diff --git a/android-test/src/androidTest/java/okhttp/android/test/OkHttpTest.kt b/android-test/src/androidTest/java/okhttp/android/test/OkHttpTest.kt
new file mode 100644
index 0000000000..9af2d997c4
--- /dev/null
+++ b/android-test/src/androidTest/java/okhttp/android/test/OkHttpTest.kt
@@ -0,0 +1,208 @@
+/*
+ * Copyright (C) 2019 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp.android.test
+
+import android.os.Build
+import android.support.test.runner.AndroidJUnit4
+import okhttp3.Call
+import okhttp3.CertificatePinner
+import okhttp3.Connection
+import okhttp3.EventListener
+import okhttp3.OkHttpClient
+import okhttp3.Protocol
+import okhttp3.Request
+import okhttp3.TlsVersion
+import okhttp3.mockwebserver.MockResponse
+import okhttp3.mockwebserver.MockWebServer
+import okhttp3.tls.internal.TlsUtil.localhost
+import org.junit.After
+import org.junit.Assert.assertEquals
+import org.junit.Assert.assertTrue
+import org.junit.Assert.fail
+import org.junit.Assume.assumeNoException
+import org.junit.Assume.assumeTrue
+import org.junit.Before
+import org.junit.Rule
+import org.junit.Test
+import org.junit.runner.RunWith
+import java.net.InetAddress
+import java.net.UnknownHostException
+import javax.net.ssl.SSLPeerUnverifiedException
+
+/**
+ * Run with "./gradlew :android-test:connectedCheck" and make sure ANDROID_SDK_ROOT is set.
+ */
+@RunWith(AndroidJUnit4::class)
+class OkHttpTest {
+  private lateinit var client: OkHttpClient
+
+  @JvmField
+  @Rule
+  val server = MockWebServer()
+  private val handshakeCertificates = localhost()
+
+  @Before
+  fun createClient() {
+    client = OkHttpClient.Builder()
+        .build()
+  }
+
+  @After
+  fun cleanup() {
+    client.dispatcher.executorService.shutdownNow()
+  }
+
+  @Test
+  fun testRequest() {
+    assumeNetwork()
+
+    val request = Request.Builder().url("https://api.twitter.com/robots.txt").build()
+
+    val response = client.newCall(request).execute()
+
+    response.use {
+      assertEquals(200, response.code)
+    }
+  }
+
+  @Test
+  fun testRequestUsesAndroidConscrypt() {
+    assumeNetwork()
+
+    val request = Request.Builder().url("https://facebook.com/robots.txt").build()
+
+    var socketClass: String? = null
+
+    val client2 = client.newBuilder()
+        .eventListener(object : EventListener() {
+          override fun connectionAcquired(call: Call, connection: Connection) {
+            socketClass = connection.socket().javaClass.name
+          }
+        })
+        .build()
+
+    val response = client2.newCall(request).execute()
+
+    response.use {
+      assertEquals(Protocol.HTTP_2, response.protocol)
+      if (Build.VERSION.SDK_INT >= 29) {
+        assertEquals(TlsVersion.TLS_1_3, response.handshake?.tlsVersion)
+      } else {
+        assertEquals(TlsVersion.TLS_1_2, response.handshake?.tlsVersion)
+      }
+      assertEquals(200, response.code)
+      assertTrue(socketClass?.startsWith("com.android.org.conscrypt.") == true)
+    }
+  }
+
+  @Test
+  fun testHttpRequestNotBlockedOnLegacyAndroid() {
+    assumeTrue(Build.VERSION.SDK_INT < 23)
+
+    val request = Request.Builder().url("http://squareup.com/robots.txt").build()
+
+    val response = client.newCall(request).execute()
+
+    response.use {
+      assertEquals(200, response.code)
+    }
+  }
+
+  @Test
+  fun testHttpRequestBlocked() {
+    assumeTrue(Build.VERSION.SDK_INT >= 23)
+
+    val request = Request.Builder().url("http://squareup.com/robots.txt").build()
+
+    try {
+      client.newCall(request).execute()
+      fail("expected cleartext blocking")
+    } catch (_: java.net.UnknownServiceException) {
+    }
+  }
+
+  @Test
+  fun testMockWebserverRequest() {
+    enableTls()
+
+    server.enqueue(MockResponse().setBody("abc"))
+
+    val request = Request.Builder().url(server.url("/")).build()
+
+    val response = client.newCall(request).execute()
+
+    response.use {
+      assertEquals(200, response.code)
+    }
+  }
+
+  @Test
+  fun testCertificatePinningFailure() {
+    enableTls()
+
+    val certificatePinner = CertificatePinner.Builder()
+        .add(server.hostName, "sha256/AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA=")
+        .build()
+    client = client.newBuilder().certificatePinner(certificatePinner).build()
+
+    server.enqueue(MockResponse().setBody("abc"))
+
+    val request = Request.Builder().url(server.url("/")).build()
+
+    try {
+      client.newCall(request).execute()
+      fail()
+    } catch (_: SSLPeerUnverifiedException) {
+    }
+  }
+
+  @Test
+  fun testCertificatePinningSuccess() {
+    enableTls()
+
+    val certificatePinner = CertificatePinner.Builder()
+        .add(server.hostName,
+            CertificatePinner.pin(handshakeCertificates.trustManager.acceptedIssuers[0]))
+        .build()
+    client = client.newBuilder().certificatePinner(certificatePinner).build()
+
+    server.enqueue(MockResponse().setBody("abc"))
+
+    val request = Request.Builder().url(server.url("/")).build()
+
+    val response = client.newCall(request).execute()
+
+    response.use {
+      assertEquals(200, response.code)
+    }
+  }
+
+  private fun enableTls() {
+    client = client.newBuilder()
+        .sslSocketFactory(
+            handshakeCertificates.sslSocketFactory(), handshakeCertificates.trustManager)
+        .build()
+    server.useHttps(handshakeCertificates.sslSocketFactory(), false)
+  }
+
+  private fun assumeNetwork() {
+    try {
+      InetAddress.getByName("www.google.com")
+    } catch (uhe: UnknownHostException) {
+      assumeNoException(uhe)
+    }
+  }
+}
diff --git a/android-test/src/main/AndroidManifest.xml b/android-test/src/main/AndroidManifest.xml
new file mode 100644
index 0000000000..b1a394fecc
--- /dev/null
+++ b/android-test/src/main/AndroidManifest.xml
@@ -0,0 +1,4 @@
+<manifest xmlns:android="http://schemas.android.com/apk/res/android"
+    package="okhttp.android.test">
+  <uses-permission android:name="android.permission.INTERNET" />
+</manifest>
diff --git a/android-test/src/main/res/values/strings.xml b/android-test/src/main/res/values/strings.xml
new file mode 100644
index 0000000000..3f2b0bb232
--- /dev/null
+++ b/android-test/src/main/res/values/strings.xml
@@ -0,0 +1,3 @@
+<resources>
+  <string name="app_name">android-test</string>
+</resources>
diff --git a/android-test/src/main/res/xml/network_security_config.xml b/android-test/src/main/res/xml/network_security_config.xml
new file mode 100644
index 0000000000..786dddecc7
--- /dev/null
+++ b/android-test/src/main/res/xml/network_security_config.xml
@@ -0,0 +1,5 @@
+<?xml version="1.0" encoding="utf-8"?>
+<network-security-config>
+  <base-config cleartextTrafficPermitted="false">
+  </base-config>
+</network-security-config>
\ No newline at end of file
diff --git a/build.gradle b/build.gradle
index 82d2087687..a1fb6a0740 100644
--- a/build.gradle
+++ b/build.gradle
@@ -2,31 +2,33 @@ import net.ltgt.gradle.errorprone.CheckSeverity
 
 buildscript {
   ext.versions = [
-      'airline': '2.6.0',
       'android': '4.1.1.4',
       'animalSniffer': '1.17',
       'assertj': '3.11.0',
-      'bouncycastle': '1.60',
+      'bouncycastle': '1.62',
+      'brotli': '0.1.2',
       'checkstyle': '8.15',
-      'conscrypt': '2.1.0',
+      'conscrypt': '2.2.1',
       'findbugs': '3.0.2',
       'guava': '27.0.1-jre',
       'java': '1.8',
       'jnrUnixsocket': '0.22',
       'jsoup': '1.11.3',
       'junit': '4.12',
-      'kotlin': '1.3.40',
+      'kotlin': '1.3.41',
       'moshi': '1.8.0',
       'okio': '2.2.2',
-      'ktlint': '0.31.0'
+      'ktlint': '0.31.0',
+      'picocli': '4.0.1'
   ]
 
   ext.deps = [
-      'airline': "com.github.rvesse:airline:${versions.airline}",
+      'picocli': "info.picocli:picocli:${versions.picocli}",
       'android': "com.google.android:android:${versions.android}",
       'animalSniffer': "org.codehaus.mojo:animal-sniffer-annotations:${versions.animalSniffer}",
       'assertj': "org.assertj:assertj-core:${versions.assertj}",
       'bouncycastle': "org.bouncycastle:bcprov-jdk15on:${versions.bouncycastle}",
+      'brotli': "org.brotli:dec:${versions.brotli}",
       'conscrypt': "org.conscrypt:conscrypt-openjdk-uber:${versions.conscrypt}",
       'guava': "com.google.guava:guava:${versions.guava}",
       'jnrUnixsocket': "com.github.jnr:jnr-unixsocket:${versions.jnrUnixsocket}",
@@ -45,11 +47,13 @@ buildscript {
     classpath "org.jetbrains.kotlin:kotlin-gradle-plugin:${versions.kotlin}"
     classpath "org.jetbrains.dokka:dokka-gradle-plugin:0.9.18"
     classpath 'com.diffplug.spotless:spotless-plugin-gradle:3.21.1'
+    classpath 'com.android.tools.build:gradle:3.4.2'
   }
 
   repositories {
     mavenCentral()
     gradlePluginPortal()
+    google()
   }
 }
 
@@ -68,6 +72,7 @@ allprojects {
     maven {
       url 'https://dl.bintray.com/kotlin/dokka'
     }
+    google()
   }
 
   task downloadDependencies() {
@@ -79,6 +84,9 @@ allprojects {
 }
 
 subprojects { project ->
+  if (project.name == 'android-test')
+    return
+
   apply plugin: 'java'
   apply plugin: 'java-library'
   apply plugin: 'org.jetbrains.kotlin.platform.jvm'
@@ -115,12 +123,19 @@ subprojects { project ->
     }
   }
 
+  tasks.withType(org.jetbrains.kotlin.gradle.tasks.KotlinCompile).configureEach {
+    kotlinOptions {
+      jvmTarget = "1.8"
+    }
+  }
+
   def platform = System.getProperty("okhttp.platform", "jdk8")
 
   test {
     jvmArgs += "-Dlistener=okhttp3.testing.InstallUncaughtExceptionHandlerListener"
     jvmArgs += "-Dokhttp.platform=$platform"
 
+    maxParallelForks Runtime.runtime.availableProcessors() * 2
     testLogging {
       exceptionFormat = 'full'
     }
@@ -149,10 +164,13 @@ subprojects { project ->
     errorprone 'com.google.errorprone:error_prone_core:2.3.3'
   }
   tasks.withType(JavaCompile).configureEach {
+    sourceCompatibility = JavaVersion.VERSION_1_8
+    targetCompatibility = JavaVersion.VERSION_1_8
+
     options.errorprone {
       check("MissingFail", CheckSeverity.ERROR)
       check("MissingOverride", CheckSeverity.ERROR)
-      enabled = JavaVersion.current() < JavaVersion.VERSION_11
+      enabled = JavaVersion.current() < JavaVersion.VERSION_12
     }
   }
 
@@ -171,8 +189,8 @@ subprojects { project ->
         includes = ['Module.md']
       }
       externalDocumentationLink {
-        url = new URL("https://square.github.io/okio/2.x/okio/jvm/index.html")
-        packageListUrl = new URL("https://square.github.io/okio/2.x/okio/jvm/package-list")
+        url = new URL("https://square.github.io/okio/2.x/okio/")
+        packageListUrl = new URL("https://square.github.io/okio/2.x/okio/package-list")
       }
     }
   }
@@ -220,7 +238,7 @@ def alpnBootVersionForPatchVersion(String javaVersion, int patchVersion) {
       return '8.1.11.v20170118'
     case 161..181:
       return '8.1.12.v20180117'
-    case 191..212:
+    case 191..222:
       return '8.1.13.v20181017'
     default:
       throw new IllegalStateException("Unexpected Java version: ${javaVersion}")
diff --git a/deploy_website.sh b/deploy_website.sh
index eaa6e560bf..202321d658 100755
--- a/deploy_website.sh
+++ b/deploy_website.sh
@@ -41,6 +41,7 @@ mkdocs gh-deploy
 # Restore Javadocs from 1.x, 2.x, and 3.x.
 git checkout gh-pages
 git cherry-pick bb229b9dcc9a21a73edbf8d936bea88f52e0a3ff
+git cherry-pick c695732f1d4aea103b826876c077fbfea630e244
 git push
 
 # Delete our temp folder
diff --git a/docs/calls.md b/docs/calls.md
index 2ffa0a4130..38b7c25cd6 100644
--- a/docs/calls.md
+++ b/docs/calls.md
@@ -2,11 +2,11 @@
 
 The HTTP client’s job is to accept your request and produce its response. This is simple in theory but it gets tricky in practice.
 
-## [Requests](http://square.github.io/okhttp/api/okhttp/okhttp3/-request/)
+## [Requests](http://square.github.io/okhttp/4.x/okhttp/okhttp3/-request/)
 
 Each HTTP request contains a URL, a method (like `GET` or `POST`), and a list of headers. Requests may also contain a body: a data stream of a specific content type.
 
-## [Responses](http://square.github.io/okhttp/api/okhttp/okhttp3/-response/)
+## [Responses](http://square.github.io/okhttp/4.x/okhttp/okhttp3/-response/)
 
 The response answers the request with a code (like 200 for success or 404 for not found), headers, and its own optional body.
 
@@ -28,20 +28,20 @@ If a conditional GET was successful, responses from the network and cache are me
 
 When your requested URL has moved, the webserver will return a response code like `302` to indicate the document’s new URL. OkHttp will follow the redirect to retrieve a final response.
 
-If the response issues an authorization challenge, OkHttp will ask the [`Authenticator`](http://square.github.io/okhttp/api/okhttp/okhttp3/-authenticator/) (if one is configured) to satisfy the challenge. If the authenticator supplies a credential, the request is retried with that credential included.
+If the response issues an authorization challenge, OkHttp will ask the [`Authenticator`](http://square.github.io/okhttp/4.x/okhttp/okhttp3/-authenticator/) (if one is configured) to satisfy the challenge. If the authenticator supplies a credential, the request is retried with that credential included.
 
 ## Retrying Requests
 
 Sometimes connections fail: either a pooled connection was stale and disconnected, or the webserver itself couldn’t be reached. OkHttp will retry the request with a different route if one is available.
 
-## [Calls](http://square.github.io/okhttp/api/okhttp/okhttp3/-call/)
+## [Calls](http://square.github.io/okhttp/4.x/okhttp/okhttp3/-call/)
 
 With rewrites, redirects, follow-ups and retries, your simple request may yield many requests and responses. OkHttp uses `Call` to model the task of satisfying your request through however many intermediate requests and responses are necessary. Typically this isn’t many! But it’s comforting to know that your code will continue to work if your URLs are redirected or if you failover to an alternate IP address.
 
 Calls are executed in one of two ways:
 
  * **Synchronous:** your thread blocks until the response is readable.
- * **Asynchronous:** you enqueue the request on any thread, and get [called back](http://square.github.io/okhttp/api/okhttp/okhttp3/-callback/) on another thread when the response is readable.
+ * **Asynchronous:** you enqueue the request on any thread, and get [called back](http://square.github.io/okhttp/4.x/okhttp/okhttp3/-callback/) on another thread when the response is readable.
 
 Calls can be canceled from any thread. This will fail the call if it hasn’t yet completed! Code that is writing the request body or reading the response body will suffer an `IOException` when its call is canceled.
 
@@ -49,4 +49,4 @@ Calls can be canceled from any thread. This will fail the call if it hasn’t ye
 
 For synchronous calls, you bring your own thread and are responsible for managing how many simultaneous requests you make. Too many simultaneous connections wastes resources; too few harms latency.
 
-For asynchronous calls, [`Dispatcher`](http://square.github.io/okhttp/api/okhttp/okhttp3/-dispatcher/) implements policy for maximum simultaneous requests. You can set maximums per-webserver (default is 5), and overall (default is 64).
+For asynchronous calls, [`Dispatcher`](http://square.github.io/okhttp/4.x/okhttp/okhttp3/-dispatcher/) implements policy for maximum simultaneous requests. You can set maximums per-webserver (default is 5), and overall (default is 64).
diff --git a/docs/code_of_conduct.md b/docs/code_of_conduct.md
new file mode 100644
index 0000000000..6a97690c5c
--- /dev/null
+++ b/docs/code_of_conduct.md
@@ -0,0 +1,102 @@
+Open Source Code of Conduct
+===========================
+
+At Square, we are committed to contributing to the open source community and simplifying the process
+of releasing and managing open source software. We’ve seen incredible support and enthusiasm from
+thousands of people who have already contributed to our projects — and we want to ensure our community
+continues to be truly open for everyone.
+
+This code of conduct outlines our expectations for participants, as well as steps to reporting
+unacceptable behavior. We are committed to providing a welcoming and inspiring community for all and
+expect our code of conduct to be honored.
+
+Square’s open source community strives to:
+
+ * **Be open**: We invite anyone to participate in any aspect of our projects. Our community is
+   open, and any responsibility can be carried by a contributor who demonstrates the required
+   capacity and competence.
+
+ * **Be considerate**: People use our work, and we depend on the work of others. Consider users and
+   colleagues before taking action. For example, changes to code, infrastructure, policy, and
+   documentation may negatively impact others.
+
+ * **Be respectful**: We expect people to work together to resolve conflict, assume good intentions,
+   and act with empathy. Do not turn disagreements into personal attacks.
+
+ * **Be collaborative**: Collaboration reduces redundancy and improves the quality of our work. We
+   strive for transparency within our open source community, and we work closely with upstream
+   developers and others in the free software community to coordinate our efforts.
+
+ * **Be pragmatic**: Questions are encouraged and should be asked early in the process to avoid
+   problems later. Be thoughtful and considerate when seeking out the appropriate forum for your
+   questions. Those who are asked should be responsive and helpful.
+
+ * **Step down considerately**: Members of every project come and go. When somebody leaves or
+   disengages from the project, they should make it known and take the proper steps to ensure that
+   others can pick up where they left off.
+
+This code is not exhaustive or complete. It serves to distill our common understanding of a
+collaborative, shared environment, and goals. We expect it to be followed in spirit as much as in
+the letter.
+
+Diversity Statement
+-------------------
+
+We encourage everyone to participate and are committed to building a community for all. Although we
+may not be able to satisfy everyone, we all agree that everyone is equal.
+
+Whenever a participant has made a mistake, we expect them to take responsibility for it. If someone
+has been harmed or offended, it is our responsibility to listen carefully and respectfully, and do
+our best to right the wrong.
+
+Although this list cannot be exhaustive, we explicitly honor diversity in age, culture, ethnicity,
+gender identity or expression, language, national origin, political beliefs, profession, race,
+religion, sexual orientation, socioeconomic status, and technical ability. We will not tolerate
+discrimination based on any of the protected characteristics above, including participants with
+disabilities.
+
+Reporting Issues
+----------------
+
+If you experience or witness unacceptable behavior — or have any other concerns — please report it by
+emailing [codeofconduct@squareup.com][codeofconduct_at]. For more details, please see our Reporting
+Guidelines below.
+
+Thanks
+------
+
+Some of the ideas and wording for the statements and guidelines above were based on work by the
+[Twitter][twitter_coc], [Ubuntu][ubuntu_coc], [GDC][gdc_coc], and [Django][django_coc] communities.
+We are thankful for their work.
+
+Reporting Guide
+---------------
+
+If you experience or witness unacceptable behavior — or have any other concerns — please report it by
+emailing [codeofconduct@squareup.com][codeofconduct_at]. All reports will be handled with
+discretion.
+
+In your report please include:
+
+ * Your contact information.
+ * Names (real, nicknames, or pseudonyms) of any individuals involved. If there are additional
+   witnesses, please include them as well.
+ * Your account of what occurred, and if you believe the incident is ongoing. If there is a publicly
+   available record (e.g. a mailing list archive or a public IRC logger), please include a link.
+ * Any additional information that may be helpful.
+
+After filing a report, a representative from the Square Code of Conduct committee will contact you
+personally. The committee will then review the incident, follow up with any additional questions,
+and make a decision as to how to respond.
+
+Anyone asked to stop unacceptable behavior is expected to comply immediately. If an individual
+engages in unacceptable behavior, the Square Code of Conduct committee may take any action they deem
+appropriate, up to and including a permanent ban from all of Square spaces without warning.
+
+
+[codeofconduct_at]: mailto:codeofconduct@squareup.com
+[twitter_coc]: https://github.com/twitter/code-of-conduct/blob/master/code-of-conduct.md
+[ubuntu_coc]: https://ubuntu.com/community/code-of-conduct
+[gdc_coc]: https://www.gdconf.com/code-of-conduct
+[django_coc]: https://www.djangoproject.com/conduct/reporting/
+
diff --git a/docs/connections.md b/docs/connections.md
index 57576979a0..5c2f525883 100644
--- a/docs/connections.md
+++ b/docs/connections.md
@@ -3,7 +3,7 @@ Connections
 
 Although you provide only the URL, OkHttp plans its connection to your webserver using three types: URL, Address, and Route.
 
-#### [URLs](http://square.github.io/okhttp/api/okhttp/okhttp3/-http-url/)
+#### [URLs](http://square.github.io/okhttp/4.x/okhttp/okhttp3/-http-url/)
 
 URLs (like `https://github.com/square/okhttp`) are fundamental to HTTP and the Internet. In addition to being a universal, decentralized naming scheme for everything on the web, they also specify how to access web resources.
 
@@ -14,21 +14,21 @@ URLs are abstract:
 
 They're also concrete: each URL identifies a specific path (like `/square/okhttp`) and query (like `?q=sharks&lang=en`). Each webserver hosts many URLs.
 
-#### [Addresses](http://square.github.io/okhttp/api/okhttp/okhttp3/-address/)
+#### [Addresses](http://square.github.io/okhttp/4.x/okhttp/okhttp3/-address/)
 
 Addresses specify a webserver (like `github.com`) and all of the **static** configuration necessary to connect to that server: the port number, HTTPS settings, and preferred network protocols (like HTTP/2 or SPDY).
 
-URLs that share the same address may also share the same underlying TCP socket connection. Sharing a connection has substantial performance benefits: lower latency, higher throughput (due to [TCP slow start](http://www.igvita.com/2011/10/20/faster-web-vs-tcp-slow-start/)) and conserved battery. OkHttp uses a [ConnectionPool](http://square.github.io/okhttp/api/okhttp/okhttp3/-connection-pool/) that automatically reuses HTTP/1.x connections and multiplexes HTTP/2 and SPDY connections.
+URLs that share the same address may also share the same underlying TCP socket connection. Sharing a connection has substantial performance benefits: lower latency, higher throughput (due to [TCP slow start](http://www.igvita.com/2011/10/20/faster-web-vs-tcp-slow-start/)) and conserved battery. OkHttp uses a [ConnectionPool](http://square.github.io/okhttp/4.x/okhttp/okhttp3/-connection-pool/) that automatically reuses HTTP/1.x connections and multiplexes HTTP/2 and SPDY connections.
 
-In OkHttp some fields of the address come from the URL (scheme, hostname, port) and the rest come from the [OkHttpClient](http://square.github.io/okhttp/api/okhttp/okhttp3/-ok-http-client/).
+In OkHttp some fields of the address come from the URL (scheme, hostname, port) and the rest come from the [OkHttpClient](http://square.github.io/okhttp/4.x/okhttp/okhttp3/-ok-http-client/).
 
-#### [Routes](http://square.github.io/okhttp/api/okhttp/okhttp3/-route/)
+#### [Routes](http://square.github.io/okhttp/4.x/okhttp/okhttp3/-route/)
 
 Routes supply the **dynamic** information necessary to actually connect to a webserver. This is the specific IP address to attempt (as discovered by a DNS query), the exact proxy server to use (if a [ProxySelector](http://developer.android.com/reference/java/net/ProxySelector.html) is in use), and which version of TLS to negotiate (for HTTPS connections).
 
 There may be many routes for a single address. For example, a webserver that is hosted in multiple datacenters may yield multiple IP addresses in its DNS response.
 
-#### [Connections](http://square.github.io/okhttp/api/okhttp/okhttp3/-connection/)
+#### [Connections](http://square.github.io/okhttp/4.x/okhttp/okhttp3/-connection/)
 
 When you request a URL with OkHttp, here's what it does:
 
diff --git a/docs/https.md b/docs/https.md
index 7aad7b142d..142b7c3d9c 100644
--- a/docs/https.md
+++ b/docs/https.md
@@ -6,9 +6,9 @@ OkHttp attempts to balance two competing concerns:
  * **Connectivity** to as many hosts as possible. That includes advanced hosts that run the latest versions of [boringssl](https://boringssl.googlesource.com/boringssl/) and less out of date hosts running older versions of [OpenSSL](https://www.openssl.org/).
  * **Security** of the connection. This includes verification of the remote webserver with certificates and the privacy of data exchanged with strong ciphers.
 
-When negotiating a connection to an HTTPS server, OkHttp needs to know which [TLS versions](http://square.github.io/okhttp/api/okhttp/okhttp3/-tls-version/) and [cipher suites](http://square.github.io/okhttp/api/okhttp/okhttp3/-cipher-suite/) to offer. A client that wants to maximize connectivity would include obsolete TLS versions and weak-by-design cipher suites. A strict client that wants to maximize security would be limited to only the latest TLS version and strongest cipher suites.
+When negotiating a connection to an HTTPS server, OkHttp needs to know which [TLS versions](http://square.github.io/okhttp/4.x/okhttp/okhttp3/-tls-version/) and [cipher suites](http://square.github.io/okhttp/4.x/okhttp/okhttp3/-cipher-suite/) to offer. A client that wants to maximize connectivity would include obsolete TLS versions and weak-by-design cipher suites. A strict client that wants to maximize security would be limited to only the latest TLS version and strongest cipher suites.
 
-Specific security vs. connectivity decisions are implemented by [ConnectionSpec](http://square.github.io/okhttp/api/okhttp/okhttp3/-connection-spec/). OkHttp includes four built-in connection specs:
+Specific security vs. connectivity decisions are implemented by [ConnectionSpec](http://square.github.io/okhttp/4.x/okhttp/okhttp3/-connection-spec/). OkHttp includes four built-in connection specs:
 
  * `RESTRICTED_TLS` is a secure configuration, intended to meet stricter compliance requirements.
  * `MODERN_TLS` is a secure configuration that connects to modern HTTPS servers.
@@ -47,7 +47,7 @@ OkHttpClient client = new OkHttpClient.Builder()
 
 By default, OkHttp trusts the certificate authorities of the host platform. This strategy maximizes connectivity, but it is subject to certificate authority attacks such as the [2011 DigiNotar attack](http://www.computerworld.com/article/2510951/cybercrime-hacking/hackers-spied-on-300-000-iranians-using-fake-google-certificate.html). It also assumes your HTTPS servers’ certificates are signed by a certificate authority.
 
-Use [CertificatePinner](http://square.github.io/okhttp/api/okhttp/okhttp3/-certificate-pinner/) to restrict which certificates and certificate authorities are trusted. Certificate pinning increases security, but limits your server team’s abilities to update their TLS certificates. **Do not use certificate pinning without the blessing of your server’s TLS administrator!**
+Use [CertificatePinner](http://square.github.io/okhttp/4.x/okhttp/okhttp3/-certificate-pinner/) to restrict which certificates and certificate authorities are trusted. Certificate pinning increases security, but limits your server team’s abilities to update their TLS certificates. **Do not use certificate pinning without the blessing of your server’s TLS administrator!**
 
 ```java
   public CertificatePinning() {
diff --git a/docs/images/disable_advanced_profiling@2x.png b/docs/images/disable_advanced_profiling@2x.png
new file mode 100644
index 0000000000..672fb514b5
Binary files /dev/null and b/docs/images/disable_advanced_profiling@2x.png differ
diff --git a/docs/interceptors.md b/docs/interceptors.md
index 24ef5c5014..b3d759e9d0 100644
--- a/docs/interceptors.md
+++ b/docs/interceptors.md
@@ -23,7 +23,7 @@ class LoggingInterceptor implements Interceptor {
 }
 ```
 
-A call to `chain.proceed(request)` is a critical part of each interceptor’s implementation. This simple-looking method is where all the HTTP work happens, producing a response to satisfy the request.
+A call to `chain.proceed(request)` is a critical part of each interceptor’s implementation. This simple-looking method is where all the HTTP work happens, producing a response to satisfy the request. If `chain.proceed(request)` is being called more than once previous response bodies must be closed.
 
 Interceptors can be chained. Suppose you have both a compressing interceptor and a checksumming interceptor: you'll need to decide whether data is compressed and then checksummed, or checksummed and then compressed. OkHttp uses lists to track interceptors, and interceptors are called in order.
 
diff --git a/docs/recipes.md b/docs/recipes.md
index 5cd0f44055..c9bb42a6e3 100644
--- a/docs/recipes.md
+++ b/docs/recipes.md
@@ -343,7 +343,7 @@ Response caching uses HTTP headers for all configuration. You can add request he
     System.out.println("Response 2 equals Response 1? " + response1Body.equals(response2Body));
   }
 ```
-To prevent a response from using the cache, use [`CacheControl.FORCE_NETWORK`](http://square.github.io/okhttp/api/okhttp/okhttp3/-cache-control/-f-o-r-c-e_-n-e-t-w-o-r-k/). To prevent it from using the network, use [`CacheControl.FORCE_CACHE`](http://square.github.io/okhttp/api/okhttp/okhttp3/-cache-control/-f-o-r-c-e_-c-a-c-h-e/). Be warned: if you use `FORCE_CACHE` and the response requires the network, OkHttp will return a `504 Unsatisfiable Request` response.
+To prevent a response from using the cache, use [`CacheControl.FORCE_NETWORK`](http://square.github.io/okhttp/4.x/okhttp/okhttp3/-cache-control/-f-o-r-c-e_-n-e-t-w-o-r-k/). To prevent it from using the network, use [`CacheControl.FORCE_CACHE`](http://square.github.io/okhttp/4.x/okhttp/okhttp3/-cache-control/-f-o-r-c-e_-c-a-c-h-e/). Be warned: if you use `FORCE_CACHE` and the response requires the network, OkHttp will return a `504 Unsatisfiable Request` response.
 
 #### [Canceling a Call](https://github.com/square/okhttp/blob/master/samples/guide/src/main/java/okhttp3/recipes/CancelCall.java)
 
diff --git a/docs/upgrading_to_okhttp_4.md b/docs/upgrading_to_okhttp_4.md
index ca21692d15..0d3c53917e 100644
--- a/docs/upgrading_to_okhttp_4.md
+++ b/docs/upgrading_to_okhttp_4.md
@@ -2,16 +2,16 @@ Upgrading to OkHttp 4
 =====================
 
 OkHttp 4.x upgrades our implementation language from Java to Kotlin and keeps everything else the
-same. We've chosen Kotlin because it gives us powerful new capabilities while integrating closely
+same. We’ve chosen Kotlin because it gives us powerful new capabilities while integrating closely
 with Java.
 
-We spent a lot of time and energy on retaining strict compatibility with OkHttp 3.x. We're even
+We spent a lot of time and energy on retaining strict compatibility with OkHttp 3.x. We’re even
 keeping the package name the same: `okhttp3`!
 
-There are three kinds of compatibility we're tracking:
+There are three kinds of compatibility we’re tracking:
 
  * **Binary compatibility** is the ability to compile a program against OkHttp 3.x, and then to run
-   it against OkHttp 4.x. We're using the excellent [japicmp][japicmp] library via its
+   it against OkHttp 4.x. We’re using the excellent [japicmp][japicmp] library via its
    [Gradle plugin][japicmp_gradle] to enforce binary compatibility.
 
  * **Java source compatibility** is the ability to upgrade Java uses of OkHttp 3.x to 4.x without
@@ -20,39 +20,41 @@ There are three kinds of compatibility we're tracking:
  * **Kotlin source compatibility** is the ability to upgrade Kotlin uses of OkHttp 3.x to 4.x
    without changing `.kt` files.
 
-With one exception, OkHttp 4.x is both binary- and Java source-compatible with OkHttp 3.x. You can
-use an OkHttp 4.x .jar file with applications or libraries built for OkHttp 3.x. (The exception?
-`OkHttpClient` makes more things `final`.)
+With a few small exceptions (below), OkHttp 4.x is both binary- and Java source-compatible with
+OkHttp 3.x. You can use an OkHttp 4.x .jar file with applications or libraries built for OkHttp 3.x.
 
 OkHttp is **not** source-compatible for Kotlin callers, but upgrading should be automatic thanks to
-Kotlin's powerful deprecation features. Most developers should be able to use IntelliJ's _Code
+Kotlin’s powerful deprecation features. Most developers should be able to use IntelliJ’s _Code
 Cleanup_ for a safe and fast upgrade.
 
-For example, when we upgraded Square's Kotlin and Java codebases to OkHttp 4.x we had these
-problems:
-
- * Single Abstract Method (SAM) conversions required us to replace lambdas with objects for Kotlin
-   callers.
-
- * OkHttp 4.x's new `RequestBody.create()` overload conflicted with an overload in one of our
-   subclasses. The compiler caught this!
-
-We expect most projects to have similarly trivial problems with the upgrade, if any. This guide
-walks through all of the changes and how to address them.
-
 
 Backwards-Incompatible Changes
 ------------------------------
 
+#### OkHttpClient final methods
+
 `OkHttpClient` has 26 accessors like `interceptors()` and `writeTimeoutMillis()` that were non-final
 in OkHttp 3.x and are final in 4.x. These were made non-final for use with mocking frameworks like
-[Mockito][mockito]. We believe subtyping `OkHttpClient` is the wrong way to test with OkHttp.
+[Mockito][mockito]. We believe subtyping `OkHttpClient` is the wrong way to test with OkHttp. If
+you must, mock `Call.Factory` which is the interface that `OkHttpClient` implements.
+
+#### Internal API changes
 
 The `okhttp3.internal` package is not a published API and we change it frequently without warning.
-Depending on code in this package is bad and will cause you problems with any upgrade. But the 4.x
+Depending on code in this package is bad and will cause you problems with any upgrade! But the 4.x
 will be particularly painful to naughty developers that import from this package! We changed a lot
 to take advantage of sweet Kotlin features.
 
+#### Credentials.basic()
+
+The username and password parameters to `Credentials.basic()` are now non-null strings. In OkHttp
+3.x, null would yield a username or password of "null".
+
+#### HttpUrl.queryParameterValues()
+
+The return type of `HttpUrl.queryParameterValues()` is `List<String?>`. Lists that may contain null
+are uncommon and Kotlin callers may have incorrectly assigned the result to `List<String>`.
+
 
 Code Cleanup
 ------------
@@ -61,63 +63,15 @@ IntelliJ and Android Studio offer a **Code Cleanup** feature that will automatic
 deprecated APIs with their replacements. Access this feature from the _Search Anywhere_ dialog
 (double-press shift) or under the _Analyze_ menu.
 
-The deprecation replacements that Code Cleanup possible are included in OkHttp 4.0. We will remove
-them in a future update to OkHttp, so if you're skipping releases you should upgrade to OkHttp 4.0
+We’ve included deprecated APIs in OkHttp 4.0 because they make migration easy. We will remove them
+in a future release! If you’re skipping releases, it’ll be much easier if you upgrade to OkHttp 4.0
 as an intermediate step.
 
+#### Vars and Vals
 
-SAM Conversions
----------------
-
-When you use Java APIs from Kotlin you can operate on Java interfaces as if they were Kotlin
-lambdas. The [feature][kotlin_sam] is available for interfaces that define a Single Abstract Method
-(SAM).
-
-But when you use Kotlin APIs from Kotlin there's no automatic conversion. Code that used SAM lambdas
-with OkHttp 3.x: must use `object :` with OkHttp 4.x:
-
-Kotlin calling OkHttp 3.x:
-
-```kotlin
-val client = OkHttpClient.Builder()
-    .dns { hostname -> InetAddress.getAllByName(hostname).toList() }
-    .build()
-```
-
-Kotlin calling OkHttp 4.x:
-
-```kotlin
-val client = OkHttpClient.Builder()
-    .dns(object : Dns {
-      override fun lookup(hostname: String) =
-          InetAddress.getAllByName(hostname).toList()
-    })
-    .build()
-```
-
-SAM conversion impacts these APIs:
-
- * Authenticator
- * Dispatcher.setIdleCallback(Runnable)
- * Dns
- * EventListener.Factory
- * HttpLoggingInterceptor.Logger
- * LoggingEventListener.Factory
- * OkHttpClient.Builder.hostnameVerifier(HostnameVerifier)
-
-JetBrains [is working on][kotlin_sams] SAM conversions of Kotlin interfaces. Expect it in a future
-release of the Kotlin language.
-
-
-Vars and Vals
--------------
-
-Java doesn't have language support for properties so developers make do with getters and setters.
+Java doesn’t have language support for properties so developers make do with getters and setters.
 Kotlin does have properties and we take advantage of them in OkHttp.
 
-We recommend using _Code Cleanup_ to fix these; it'll use `@Deprecated` to find replacements and fix
-them automatically.
-
  * **Address**: certificatePinner, connectionSpecs, dns, hostnameVerifier, protocols, proxy,
    proxyAuthenticator, proxySelector, socketFactory, sslSocketFactory, url
  * **Cache**: directory
@@ -155,11 +109,14 @@ them automatically.
  * **Route**: address, proxy, socketAddress
  * **TlsVersion**: javaName
 
+#### Renamed Functions
 
-Extension Functions
--------------------
+* **Headers.of()**: for symmetry with `listOf()`, `setOf()`, etc., we’ve replaced
+  `Headers.of(String...)` with `headersOf(vararg String)`.
 
-_Code Cleanup_ will fix these too:
+#### Extension Functions
+
+We’ve migrated from static functions to extension functions where we think they fit.
 
 | Java                                | Kotlin                          |
 | :---------------------------------- | :------------------------------ |
@@ -183,24 +140,47 @@ _Code Cleanup_ will fix these too:
 | ResponseBody.create(String)         | String.toResponseBody()         |
 
 
-headersOf()
------------
+SAM Conversions
+---------------
 
-For symmetry with `listOf()`, `setOf()`, etc., we've replaced `Headers.of(String...)` with
-`headersOf(vararg String)`.
+When you use Java APIs from Kotlin you can operate on Java interfaces as if they were Kotlin
+lambdas. The [feature][java_sams] is available for interfaces that define a Single Abstract Method
+(SAM).
 
+But when you use Kotlin APIs from Kotlin there’s no automatic conversion. Code that used SAM lambdas
+with OkHttp 3.x: must use `object :` with OkHttp 4.x:
 
-queryParameterValues()
-----------------------
+Kotlin calling OkHttp 3.x:
 
-The return type of `HttpUrl.queryParameterValues()` is `List<String?>`. Lists that may contain
-null are uncommon and Kotlin callers may have incorrectly assigned the result to `List<String>`.
+```kotlin
+val client = OkHttpClient.Builder()
+    .dns { hostname -> InetAddress.getAllByName(hostname).toList() }
+    .build()
+```
 
+Kotlin calling OkHttp 4.x:
 
-[japicmp]: https://github.com/siom79/japicmp
-[japicmp_gradle]: https://github.com/melix/japicmp-gradle-plugin
-[mockito]: https://site.mockito.org/
-[kotlin_sam]: https://kotlinlang.org/docs/reference/java-interop.html#sam-conversions
+```kotlin
+val client = OkHttpClient.Builder()
+    .dns(object : Dns {
+      override fun lookup(hostname: String) =
+          InetAddress.getAllByName(hostname).toList()
+    })
+    .build()
+```
+
+SAM conversion impacts these APIs:
+
+ * Authenticator
+ * Dispatcher.setIdleCallback(Runnable)
+ * Dns
+ * EventListener.Factory
+ * HttpLoggingInterceptor.Logger
+ * LoggingEventListener.Factory
+ * OkHttpClient.Builder.hostnameVerifier(HostnameVerifier)
+
+JetBrains [is working on][kotlin_sams] SAM conversions of Kotlin interfaces. Expect it in a future
+release of the Kotlin language.
 
 
 Companion Imports
@@ -230,6 +210,16 @@ sed -i "" \
 ```
 
 
+Advanced Profiling
+------------------
+
+Android Studio’s Advanced Profiling feature rewrites OkHttp bytecode for instrumentation.
+Unfortunately it crashes on OkHttp 4.x’s bytecode. Until [Google’s bug][advanced_profiling_bug] is
+fixed you must disable advanced profiling in Android Studio.
+
+![Disable Advanced Profiling](images/disable_advanced_profiling@2x.png)
+
+
 R8 / ProGuard
 -------------
 
@@ -238,11 +228,52 @@ R8 and ProGuard are both code optimizers for `.class` files.
 R8 is the [default optimizer][r8] in Android Studio 3.4 and newer. It works well with all
 releases of OkHttp.
 
-ProGuard was the previous default. We're [tracking problems][proguard_problems] with interactions
-between ProGuard, OkHttp 4.x, and Kotlin-originated `.class` files. Make sure you're on the latest
-release if you're using ProGuard,
+ProGuard was the previous default. We’re [tracking problems][proguard_problems] with interactions
+between ProGuard, OkHttp 4.x, and Kotlin-originated `.class` files. Make sure you’re on the latest
+release if you’re using ProGuard,
+
+
+Gradle
+------
+
+OkHttp 4’s minimum requirements are Java 8+ and Android 5+. These requirements were
+[first introduced][require_android_5] with OkHttp 3.13.
+
+Here’s what you need in `build.gradle` to target Java 8 byte code for Kotlin, Java, and Android
+plugins respectively.
+
+```
+compileKotlin {
+  kotlinOptions {
+    jvmTarget = "1.8"
+  }
+}
+compileTestKotlin {
+  kotlinOptions {
+    jvmTarget = "1.8"
+  }
+}
+
+compileJava {
+  sourceCompatibility = JavaVersion.VERSION_1_8
+  targetCompatibility = JavaVersion.VERSION_1_8
+}
+
+android {
+  compileOptions {
+    sourceCompatibility JavaVersion.VERSION_1_8
+    targetCompatibility JavaVersion.VERSION_1_8
+  }
+}
+```
 
 
- [kotlin_sams]: https://discuss.kotlinlang.org/t/new-type-inference-in-kotlin-1-3-0-rc-190/9914/2
+ [advanced_profiling_bug]: https://issuetracker.google.com/issues/135141615
+ [japicmp]: https://github.com/siom79/japicmp
+ [japicmp_gradle]: https://github.com/melix/japicmp-gradle-plugin
+ [java_sams]: https://kotlinlang.org/docs/reference/java-interop.html#sam-conversions
+ [kotlin_sams]: https://youtrack.jetbrains.com/issue/KT-11129
+ [mockito]: https://site.mockito.org/
  [proguard_problems]: https://github.com/square/okhttp/issues/5167
+ [require_android_5]: https://cashapp.github.io/2019-02-05/okhttp-3-13-requires-android-5
  [r8]: https://developer.android.com/studio/releases#r8-default
diff --git a/gradle.properties b/gradle.properties
index 7c006bc8bb..1a261d695b 100644
--- a/gradle.properties
+++ b/gradle.properties
@@ -1,7 +1,7 @@
 org.gradle.jvmargs='-Dfile.encoding=UTF-8'
 
 GROUP=com.squareup.okhttp3
-VERSION_NAME=4.0.0-SNAPSHOT
+VERSION_NAME=4.2.0-SNAPSHOT
 
 POM_URL=https://github.com/square/okhttp
 POM_SCM_URL=https://github.com/square/okhttp
diff --git a/gradle/wrapper/gradle-wrapper.properties b/gradle/wrapper/gradle-wrapper.properties
index ed5aaee4f8..e0c4de36dd 100644
--- a/gradle/wrapper/gradle-wrapper.properties
+++ b/gradle/wrapper/gradle-wrapper.properties
@@ -1,5 +1,5 @@
 distributionBase=GRADLE_USER_HOME
 distributionPath=wrapper/dists
-distributionUrl=https\://services.gradle.org/distributions/gradle-5.4-all.zip
+distributionUrl=https\://services.gradle.org/distributions/gradle-5.5-all.zip
 zipStoreBase=GRADLE_USER_HOME
 zipStorePath=wrapper/dists
diff --git a/gradlew b/gradlew
index b0d6d0ab5d..8e25e6c19d 100755
--- a/gradlew
+++ b/gradlew
@@ -7,7 +7,7 @@
 # you may not use this file except in compliance with the License.
 # You may obtain a copy of the License at
 #
-#      http://www.apache.org/licenses/LICENSE-2.0
+#      https://www.apache.org/licenses/LICENSE-2.0
 #
 # Unless required by applicable law or agreed to in writing, software
 # distributed under the License is distributed on an "AS IS" BASIS,
diff --git a/gradlew.bat b/gradlew.bat
index 15e1ee37a7..24467a141f 100644
--- a/gradlew.bat
+++ b/gradlew.bat
@@ -5,7 +5,7 @@
 @rem you may not use this file except in compliance with the License.
 @rem You may obtain a copy of the License at
 @rem
-@rem      http://www.apache.org/licenses/LICENSE-2.0
+@rem      https://www.apache.org/licenses/LICENSE-2.0
 @rem
 @rem Unless required by applicable law or agreed to in writing, software
 @rem distributed under the License is distributed on an "AS IS" BASIS,
diff --git a/mkdocs.yml b/mkdocs.yml
index 12960b1db0..f54d97518b 100644
--- a/mkdocs.yml
+++ b/mkdocs.yml
@@ -9,6 +9,7 @@ copyright: 'Copyright &copy; 2019 Square, Inc.'
 
 theme:
   name: 'material'
+  favicon: images/icon-square.png
   logo: images/icon-square.png
   palette:
     primary: 'teal'
@@ -45,13 +46,13 @@ nav:
   - 'Works with OkHttp': works_with_okhttp.md
   - 'Stack Overflow ⏏': https://stackoverflow.com/questions/tagged/okhttp?sort=active
   - '4.x API':
-    - 'okhttp': api/okhttp/okhttp3/index.md
-    - 'dnsoverhttps': api/okhttp-dnsoverhttps/okhttp3.dnsoverhttps/index.md
-    - 'logging-interceptor': api/okhttp-logging-interceptor/okhttp3.logging/index.md
-    - 'sse': api/okhttp-sse/okhttp3.sse/index.md
-    - 'tls': api/okhttp-tls/okhttp3.tls/index.md
-    - 'urlconnection': api/okhttp-urlconnection/okhttp3/index.md
-    - 'mockwebserver': api/mockwebserver/okhttp3.mockwebserver/index.md
+    - 'okhttp': 4.x/okhttp/okhttp3/index.md
+    - 'dnsoverhttps': 4.x/okhttp-dnsoverhttps/okhttp3.dnsoverhttps/index.md
+    - 'logging-interceptor': 4.x/okhttp-logging-interceptor/okhttp3.logging/index.md
+    - 'sse': 4.x/okhttp-sse/okhttp3.sse/index.md
+    - 'tls': 4.x/okhttp-tls/okhttp3.tls/index.md
+    - 'urlconnection': 4.x/okhttp-urlconnection/okhttp3/index.md
+    - 'mockwebserver': 4.x/mockwebserver/okhttp3.mockwebserver/index.md
   - '3.x API':
     - 'okhttp ⏏': https://square.github.io/okhttp/3.x/okhttp/
     - 'dnsoverhttps ⏏': https://square.github.io/okhttp/3.x/okhttp-dnsoverhttps/
@@ -63,4 +64,5 @@ nav:
   - 'Change Log': changelog.md
   - 'Upgrading to OkHttp 4': upgrading_to_okhttp_4.md
   - 'Contributing': contributing.md
+  - 'Code of Conduct': code_of_conduct.md
 
diff --git a/mockwebserver/README.md b/mockwebserver/README.md
index 4dd382a2e1..cac8c1cc0d 100644
--- a/mockwebserver/README.md
+++ b/mockwebserver/README.md
@@ -142,7 +142,7 @@ server.setDispatcher(dispatcher);
 ### Download
 
 ```kotlin
-testImplementation("com.squareup.okhttp3:mockwebserver:3.14.2")
+testImplementation("com.squareup.okhttp3:mockwebserver:4.1.0")
 ```
 
 ### License
diff --git a/mockwebserver/build.gradle b/mockwebserver/build.gradle
index 78644e9270..d48d2ed554 100644
--- a/mockwebserver/build.gradle
+++ b/mockwebserver/build.gradle
@@ -18,7 +18,7 @@ dependencies {
 
 afterEvaluate { project ->
   project.tasks.dokka {
-    outputDirectory = "$rootDir/docs/api"
+    outputDirectory = "$rootDir/docs/4.x"
     outputFormat = 'gfm'
   }
 }
diff --git a/mockwebserver/src/main/java/okhttp3/mockwebserver/MockWebServer.kt b/mockwebserver/src/main/java/okhttp3/mockwebserver/MockWebServer.kt
index 63a286b92b..14f69c51e0 100644
--- a/mockwebserver/src/main/java/okhttp3/mockwebserver/MockWebServer.kt
+++ b/mockwebserver/src/main/java/okhttp3/mockwebserver/MockWebServer.kt
@@ -329,7 +329,7 @@ class MockWebServer : ExternalResource(), Closeable {
    * @return the head of the request queue
    */
   @Throws(InterruptedException::class)
-  fun takeRequest(timeout: Long, unit: TimeUnit): RecordedRequest = requestQueue.poll(timeout, unit)
+  fun takeRequest(timeout: Long, unit: TimeUnit): RecordedRequest? = requestQueue.poll(timeout, unit)
 
   @JvmName("-deprecated_requestCount")
   @Deprecated(
diff --git a/mockwebserver/src/main/java/okhttp3/mockwebserver/RecordedRequest.kt b/mockwebserver/src/main/java/okhttp3/mockwebserver/RecordedRequest.kt
index 5c175d42d7..9b34b23203 100644
--- a/mockwebserver/src/main/java/okhttp3/mockwebserver/RecordedRequest.kt
+++ b/mockwebserver/src/main/java/okhttp3/mockwebserver/RecordedRequest.kt
@@ -101,7 +101,11 @@ class RecordedRequest(
       val inetAddress = socket.localAddress
 
       var hostname = inetAddress.hostName
-      if (inetAddress is Inet6Address) {
+      if (inetAddress is Inet6Address && hostname.contains(':')) {
+        // hostname is likely some form representing the IPv6 bytes
+        // 2001:0db8:85a3:0000:0000:8a2e:0370:7334
+        // 2001:db8:85a3::8a2e:370:7334
+        // ::1
         hostname = "[$hostname]"
       }
 
diff --git a/mockwebserver/src/test/java/okhttp3/mockwebserver/MockWebServerTest.java b/mockwebserver/src/test/java/okhttp3/mockwebserver/MockWebServerTest.java
index ceea8b934a..2f09a8201e 100644
--- a/mockwebserver/src/test/java/okhttp3/mockwebserver/MockWebServerTest.java
+++ b/mockwebserver/src/test/java/okhttp3/mockwebserver/MockWebServerTest.java
@@ -27,6 +27,7 @@
 import java.net.SocketTimeoutException;
 import java.net.URL;
 import java.net.URLConnection;
+import java.nio.charset.StandardCharsets;
 import java.util.ArrayList;
 import java.util.List;
 import java.util.concurrent.TimeUnit;
@@ -48,6 +49,7 @@
 
 import static java.nio.charset.StandardCharsets.UTF_8;
 import static java.util.Arrays.asList;
+import static java.util.concurrent.TimeUnit.MILLISECONDS;
 import static java.util.concurrent.TimeUnit.NANOSECONDS;
 import static java.util.concurrent.TimeUnit.SECONDS;
 import static okhttp3.tls.internal.TlsUtil.localhost;
@@ -56,6 +58,7 @@
 import static org.junit.Assert.fail;
 import static org.junit.Assume.assumeFalse;
 
+@SuppressWarnings({"ArraysAsListWithZeroOrOneArgument", "deprecation"})
 public final class MockWebServerTest {
   @Rule public final MockWebServer server = new MockWebServer();
 
@@ -133,13 +136,16 @@
     HttpURLConnection connection = (HttpURLConnection) url.openConnection();
     connection.setRequestProperty("Accept-Language", "en-US");
     InputStream in = connection.getInputStream();
-    BufferedReader reader = new BufferedReader(new InputStreamReader(in));
+    BufferedReader reader = new BufferedReader(new InputStreamReader(in, UTF_8));
     assertThat(connection.getResponseCode()).isEqualTo(HttpURLConnection.HTTP_OK);
     assertThat(reader.readLine()).isEqualTo("hello world");
 
     RecordedRequest request = server.takeRequest();
     assertThat(request.getRequestLine()).isEqualTo("GET / HTTP/1.1");
     assertThat(request.getHeader("Accept-Language")).isEqualTo("en-US");
+
+    // Server has no more requests.
+    assertThat(server.takeRequest(100, MILLISECONDS)).isNull();
   }
 
   @Test public void redirect() throws Exception {
@@ -151,7 +157,7 @@
 
     URLConnection connection = server.url("/").url().openConnection();
     InputStream in = connection.getInputStream();
-    BufferedReader reader = new BufferedReader(new InputStreamReader(in));
+    BufferedReader reader = new BufferedReader(new InputStreamReader(in, UTF_8));
     assertThat(reader.readLine()).isEqualTo("This is the new location!");
 
     RecordedRequest first = server.takeRequest();
@@ -175,7 +181,7 @@
 
     URLConnection connection = server.url("/").url().openConnection();
     InputStream in = connection.getInputStream();
-    BufferedReader reader = new BufferedReader(new InputStreamReader(in));
+    BufferedReader reader = new BufferedReader(new InputStreamReader(in, UTF_8));
     assertThat(reader.readLine()).isEqualTo("enqueued in the background");
   }
 
@@ -373,15 +379,15 @@
     server.shutdown();
   }
 
-  @Test public void portImplicitlyStarts() throws IOException {
+  @Test public void portImplicitlyStarts() {
     assertThat(server.getPort()).isGreaterThan(0);
   }
 
-  @Test public void hostnameImplicitlyStarts() throws IOException {
+  @Test public void hostnameImplicitlyStarts() {
     assertThat(server.getHostName()).isNotNull();
   }
 
-  @Test public void toProxyAddressImplicitlyStarts() throws IOException {
+  @Test public void toProxyAddressImplicitlyStarts() {
     assertThat(server.toProxyAddress()).isNotNull();
   }
 
@@ -430,7 +436,7 @@
     URL url = server.url("/a/deep/path?key=foo%20bar").url();
     HttpURLConnection connection = (HttpURLConnection) url.openConnection();
     InputStream in = connection.getInputStream();
-    BufferedReader reader = new BufferedReader(new InputStreamReader(in));
+    BufferedReader reader = new BufferedReader(new InputStreamReader(in, UTF_8));
     assertThat(connection.getResponseCode()).isEqualTo(HttpURLConnection.HTTP_OK);
     assertThat(reader.readLine()).isEqualTo("hello world");
 
@@ -474,7 +480,7 @@
     connection.getOutputStream().write("request".getBytes(UTF_8));
 
     InputStream in = connection.getInputStream();
-    BufferedReader reader = new BufferedReader(new InputStreamReader(in));
+    BufferedReader reader = new BufferedReader(new InputStreamReader(in, UTF_8));
     assertThat(reader.readLine()).isEqualTo("response");
 
     RecordedRequest request = server.takeRequest();
@@ -522,7 +528,8 @@
     connection.setHostnameVerifier(new RecordingHostnameVerifier());
 
     assertThat(connection.getResponseCode()).isEqualTo(HttpURLConnection.HTTP_OK);
-    BufferedReader reader = new BufferedReader(new InputStreamReader(connection.getInputStream()));
+    BufferedReader reader =
+        new BufferedReader(new InputStreamReader(connection.getInputStream(), UTF_8));
     assertThat(reader.readLine()).isEqualTo("abc");
 
     RecordedRequest request = server.takeRequest();
diff --git a/mockwebserver/src/test/java/okhttp3/mockwebserver/RecordedRequestTest.java b/mockwebserver/src/test/java/okhttp3/mockwebserver/RecordedRequestTest.java
index 4d498406a8..5e9bb82d75 100644
--- a/mockwebserver/src/test/java/okhttp3/mockwebserver/RecordedRequestTest.java
+++ b/mockwebserver/src/test/java/okhttp3/mockwebserver/RecordedRequestTest.java
@@ -16,7 +16,6 @@
 
 package okhttp3.mockwebserver;
 
-import java.net.Inet4Address;
 import java.net.InetAddress;
 import java.net.Socket;
 import java.net.UnknownHostException;
@@ -30,24 +29,22 @@
 
 import static org.assertj.core.api.Assertions.assertThat;
 
+@SuppressWarnings("ConstantConditions")
 public class RecordedRequestTest {
-  Headers headers = Util.EMPTY_HEADERS;
+  private Headers headers = Util.EMPTY_HEADERS;
 
-  private class FakeSocket extends Socket {
+  private static class FakeSocket extends Socket {
     private final InetAddress localAddress;
     private final int remotePort;
     private final InetAddress remoteAddress;
     private final int localPort;
 
-    private FakeSocket(int localPort) {
-      this(Inet4Address.getLoopbackAddress(), localPort);
-    }
-
     private FakeSocket(InetAddress inetAddress, int localPort) {
       this(inetAddress, localPort, inetAddress, 1234);
     }
 
-    private FakeSocket(InetAddress localAddress, int localPort, InetAddress remoteAddress, int remotePort) {
+    private FakeSocket(InetAddress localAddress, int localPort, InetAddress remoteAddress,
+        int remotePort) {
       this.localAddress = localAddress;
       this.localPort = localPort;
       this.remoteAddress = remoteAddress;
@@ -75,7 +72,7 @@ private FakeSocket(InetAddress localAddress, int localPort, InetAddress remoteAd
 
   @Test public void testIPv4() throws UnknownHostException {
     Socket socket =
-        new FakeSocket(InetAddress.getByAddress("127.0.0.1", new byte[] { 127, 0, 0, 1 }), 80);
+        new FakeSocket(InetAddress.getByAddress("127.0.0.1", new byte[] {127, 0, 0, 1}), 80);
 
     RecordedRequest request = new RecordedRequest("GET / HTTP/1.1", headers,
         Collections.emptyList(), 0, new Buffer(), 0, socket);
@@ -85,7 +82,7 @@ private FakeSocket(InetAddress localAddress, int localPort, InetAddress remoteAd
 
   @Test public void testIpv6() throws UnknownHostException {
     Socket socket = new FakeSocket(InetAddress.getByAddress("::1",
-        new byte[] { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1 }), 80);
+        new byte[] {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1}), 80);
 
     RecordedRequest request = new RecordedRequest("GET / HTTP/1.1", headers,
         Collections.emptyList(), 0, new Buffer(), 0, socket);
@@ -95,11 +92,31 @@ private FakeSocket(InetAddress localAddress, int localPort, InetAddress remoteAd
 
   @Test public void testUsesLocal() throws UnknownHostException {
     Socket socket =
-        new FakeSocket(InetAddress.getByAddress("127.0.0.1", new byte[] { 127, 0, 0, 1 }), 80);
+        new FakeSocket(InetAddress.getByAddress("127.0.0.1", new byte[] {127, 0, 0, 1}), 80);
 
     RecordedRequest request = new RecordedRequest("GET / HTTP/1.1", headers,
         Collections.emptyList(), 0, new Buffer(), 0, socket);
 
     assertThat(request.getRequestUrl().toString()).isEqualTo("http://127.0.0.1/");
   }
+
+  @Test public void testLocalhostIpv6() throws UnknownHostException {
+    Socket socket = new FakeSocket(InetAddress.getByAddress("localhost",
+        new byte[] {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1}), 80);
+
+    RecordedRequest request = new RecordedRequest("GET / HTTP/1.1", headers,
+        Collections.emptyList(), 0, new Buffer(), 0, socket);
+
+    assertThat(request.getRequestUrl().toString()).isEqualTo("http://localhost/");
+  }
+
+  @Test public void testLocalhostIpv4() throws UnknownHostException {
+    Socket socket =
+        new FakeSocket(InetAddress.getByAddress("localhost", new byte[] {127, 0, 0, 1}), 80);
+
+    RecordedRequest request = new RecordedRequest("GET / HTTP/1.1", headers,
+        Collections.emptyList(), 0, new Buffer(), 0, socket);
+
+    assertThat(request.getRequestUrl().toString()).isEqualTo("http://localhost/");
+  }
 }
diff --git a/mockwebserver/src/test/java/okhttp3/mockwebserver/internal/http2/Http2Server.java b/mockwebserver/src/test/java/okhttp3/mockwebserver/internal/http2/Http2Server.java
index f3fabec885..160159d98e 100644
--- a/mockwebserver/src/test/java/okhttp3/mockwebserver/internal/http2/Http2Server.java
+++ b/mockwebserver/src/test/java/okhttp3/mockwebserver/internal/http2/Http2Server.java
@@ -76,10 +76,14 @@ private void run() throws Exception {
         connection.start();
       } catch (IOException e) {
         logger.log(Level.INFO, "Http2Server connection failure: " + e);
-        closeQuietly(socket);
+        if (socket != null) {
+          closeQuietly(socket);
+        }
       } catch (Exception e) {
         logger.log(Level.WARNING, "Http2Server unexpected failure", e);
-        closeQuietly(socket);
+        if (socket != null) {
+          closeQuietly(socket);
+        }
       }
     }
   }
diff --git a/okcurl/build.gradle b/okcurl/build.gradle
index 54ebfabf50..990860e3e2 100644
--- a/okcurl/build.gradle
+++ b/okcurl/build.gradle
@@ -25,7 +25,7 @@ task copyResourcesTemplates(type: Copy) {
 dependencies {
   api project(':okhttp')
   api project(':okhttp-logging-interceptor')
-  implementation deps.airline
+  implementation deps.picocli
   implementation deps.guava
 
   testImplementation project(':okhttp-testing-support')
diff --git a/okcurl/okcurl b/okcurl/okcurl
new file mode 100755
index 0000000000..72d5ac525a
--- /dev/null
+++ b/okcurl/okcurl
@@ -0,0 +1,5 @@
+#!/bin/sh -e
+
+../gradlew -q --console plain installDist
+
+./build/install/okcurl/bin/okcurl "$@"
diff --git a/okcurl/src/main/java/okhttp3/curl/Main.kt b/okcurl/src/main/java/okhttp3/curl/Main.kt
index a1f05299f7..9a8f323d52 100644
--- a/okcurl/src/main/java/okhttp3/curl/Main.kt
+++ b/okcurl/src/main/java/okhttp3/curl/Main.kt
@@ -15,11 +15,6 @@
  */
 package okhttp3.curl
 
-import com.github.rvesse.airline.HelpOption
-import com.github.rvesse.airline.SingleCommand
-import com.github.rvesse.airline.annotations.Arguments
-import com.github.rvesse.airline.annotations.Command
-import com.github.rvesse.airline.annotations.Option
 import okhttp3.MediaType
 import okhttp3.MediaType.Companion.toMediaTypeOrNull
 import okhttp3.OkHttpClient
@@ -34,6 +29,11 @@ import okhttp3.internal.platform.Platform
 import okhttp3.logging.HttpLoggingInterceptor
 import okhttp3.logging.LoggingEventListener
 import okio.sink
+import picocli.CommandLine
+import picocli.CommandLine.Command
+import picocli.CommandLine.IVersionProvider
+import picocli.CommandLine.Option
+import picocli.CommandLine.Parameters
 import java.io.IOException
 import java.security.cert.X509Certificate
 import java.util.Properties
@@ -43,75 +43,68 @@ import java.util.logging.Level
 import java.util.logging.LogRecord
 import java.util.logging.Logger
 import java.util.logging.SimpleFormatter
-import javax.inject.Inject
 import javax.net.ssl.HostnameVerifier
 import javax.net.ssl.SSLSocketFactory
 import javax.net.ssl.TrustManager
 import javax.net.ssl.X509TrustManager
+import kotlin.system.exitProcess
 
-@Command(name = NAME, description = "A curl for the next-generation web.")
+@Command(name = NAME, description = ["A curl for the next-generation web."],
+    mixinStandardHelpOptions = true, versionProvider = Main.VersionProvider::class)
 class Main : Runnable {
-  @Inject
-  var help: HelpOption<Main>? = null
-
-  @Option(name = ["-X", "--request"], description = "Specify request command to use")
+  @Option(names = ["-X", "--request"], description = ["Specify request command to use"])
   var method: String? = null
 
-  @Option(name = ["-d", "--data"], description = "HTTP POST data")
+  @Option(names = ["-d", "--data"], description = ["HTTP POST data"])
   var data: String? = null
 
-  @Option(name = ["-H", "--header"], description = "Custom header to pass to server")
+  @Option(names = ["-H", "--header"], description = ["Custom header to pass to server"])
   var headers: MutableList<String>? = null
 
-  @Option(name = ["-A", "--user-agent"], description = "User-Agent to send to server")
+  @Option(names = ["-A", "--user-agent"], description = ["User-Agent to send to server"])
   var userAgent = NAME + "/" + versionString()
 
-  @Option(name = ["--connect-timeout"],
-      description = "Maximum time allowed for connection (seconds)")
+  @Option(names = ["--connect-timeout"],
+      description = ["Maximum time allowed for connection (seconds)"])
   var connectTimeout = DEFAULT_TIMEOUT
 
-  @Option(name = ["--read-timeout"],
-      description = "Maximum time allowed for reading data (seconds)")
+  @Option(names = ["--read-timeout"],
+      description = ["Maximum time allowed for reading data (seconds)"])
   var readTimeout = DEFAULT_TIMEOUT
 
-  @Option(name = ["--call-timeout"],
-      description = "Maximum time allowed for the entire call (seconds)")
+  @Option(names = ["--call-timeout"],
+      description = ["Maximum time allowed for the entire call (seconds)"])
   var callTimeout = DEFAULT_TIMEOUT
 
-  @Option(name = ["-L", "--location"], description = "Follow redirects")
+  @Option(names = ["-L", "--location"], description = ["Follow redirects"])
   var followRedirects: Boolean = false
 
-  @Option(name = ["-k", "--insecure"], description = "Allow connections to SSL sites without certs")
+  @Option(names = ["-k", "--insecure"], description = ["Allow connections to SSL sites without certs"])
   var allowInsecure: Boolean = false
 
-  @Option(name = ["-i", "--include"], description = "Include protocol headers in the output")
+  @Option(names = ["-i", "--include"], description = ["Include protocol headers in the output"])
   var showHeaders: Boolean = false
 
-  @Option(name = ["--frames"], description = "Log HTTP/2 frames to STDERR")
+  @Option(names = ["--frames"], description = ["Log HTTP/2 frames to STDERR"])
   var showHttp2Frames: Boolean = false
 
-  @Option(name = ["-e", "--referer"], description = "Referer URL")
+  @Option(names = ["-e", "--referer"], description = ["Referer URL"])
   var referer: String? = null
 
-  @Option(name = ["-V", "--version"], description = "Show version number and quit")
-  var version: Boolean = false
-
-  @Option(name = ["-v", "--verbose"], description = "Makes $NAME verbose during the operation")
+  @Option(names = ["-v", "--verbose"], description = ["Makes $NAME verbose during the operation"])
   var verbose: Boolean = false
 
-  @Arguments(title = ["url"], description = "Remote resource URL")
+  @Option(names = ["--completionScript"], hidden = true)
+  var completionScript: Boolean = false
+
+  @Parameters(paramLabel = "url", description = ["Remote resource URL"])
   var url: String? = null
 
   private lateinit var client: OkHttpClient
 
   override fun run() {
-    if (help?.showHelpIfRequested() == true) {
-      return
-    }
-
-    if (version) {
-      println(NAME + " " + versionString())
-      println("Protocols: " + protocols())
+    if (completionScript) {
+      println(picocli.AutoComplete.bash("okcurl", CommandLine(Main())))
       return
     }
 
@@ -122,11 +115,6 @@ class Main : Runnable {
     client = createClient()
     val request = createRequest()
 
-    if (request == null) {
-      help?.showHelp()
-      return
-    }
-
     try {
       val response = client.newCall(request).execute()
       if (showHeaders) {
@@ -183,13 +171,12 @@ class Main : Runnable {
     return builder.build()
   }
 
-  fun createRequest(): Request? {
+  public fun createRequest(): Request {
     val request = Request.Builder()
 
-    val requestUrl = url ?: return null
     val requestMethod = method ?: if (data != null) "POST" else "GET"
 
-    request.url(requestUrl)
+    request.url(url!!)
 
     data?.let {
       request.method(requestMethod, it.toRequestBody(mediaType()))
@@ -224,6 +211,17 @@ class Main : Runnable {
 
   private fun close() {
     client.connectionPool.evictAll() // Close any persistent connections.
+    client.dispatcher.executorService.shutdownNow()
+  }
+
+  class VersionProvider : IVersionProvider {
+    override fun getVersion(): Array<String> {
+      return arrayOf(
+          "$NAME ${versionString()}",
+          "Protocols: ${Protocol.values().joinToString(", ")}",
+          "Platform: ${Platform.get()::class.java.simpleName}"
+      )
+    }
   }
 
   companion object {
@@ -231,16 +229,12 @@ class Main : Runnable {
     internal const val DEFAULT_TIMEOUT = -1
     private var frameLogger: Logger? = null
 
-    @JvmStatic
-    fun fromArgs(vararg args: String): Main =
-        SingleCommand.singleCommand(Main::class.java).parse(*args)
-
     @JvmStatic
     fun main(args: Array<String>) {
-      Main.fromArgs(*args).run()
+      exitProcess(CommandLine(Main()).execute(*args))
     }
 
-    private fun versionString(): String {
+    private fun versionString(): String? {
       val prop = Properties()
       Main::class.java.getResourceAsStream("/okcurl-version.properties").use {
         prop.load(it)
@@ -248,8 +242,6 @@ class Main : Runnable {
       return prop.getProperty("version", "dev")
     }
 
-    private fun protocols() = Protocol.values().joinToString(", ")
-
     private fun createInsecureTrustManager(): X509TrustManager = object : X509TrustManager {
       override fun checkClientTrusted(chain: Array<X509Certificate>, authType: String) {}
 
diff --git a/okcurl/src/test/java/okhttp3/curl/MainTest.java b/okcurl/src/test/java/okhttp3/curl/MainTest.java
index 6277c93f8a..4eecbc938f 100644
--- a/okcurl/src/test/java/okhttp3/curl/MainTest.java
+++ b/okcurl/src/test/java/okhttp3/curl/MainTest.java
@@ -20,11 +20,15 @@
 import okhttp3.RequestBody;
 import okio.Buffer;
 import org.junit.Test;
+import picocli.CommandLine;
 
-import static okhttp3.curl.Main.fromArgs;
 import static org.assertj.core.api.Assertions.assertThat;
 
 public class MainTest {
+  public static Main fromArgs(String... args) {
+    return CommandLine.populateCommand(new Main(), args);
+  }
+
   @Test public void simple() {
     Request request = fromArgs("http://example.com").createRequest();
     assertThat(request.method()).isEqualTo("GET");
diff --git a/okhttp-brotli/README.md b/okhttp-brotli/README.md
new file mode 100644
index 0000000000..4f8e802fd2
--- /dev/null
+++ b/okhttp-brotli/README.md
@@ -0,0 +1,4 @@
+OkHttp Brotli Implementation
+============================
+
+This module is an implementation of Brotli compression.
diff --git a/okhttp-brotli/build.gradle b/okhttp-brotli/build.gradle
new file mode 100644
index 0000000000..c04a996383
--- /dev/null
+++ b/okhttp-brotli/build.gradle
@@ -0,0 +1,19 @@
+apply plugin: 'com.vanniktech.maven.publish'
+
+jar {
+  manifest {
+    attributes('Automatic-Module-Name': 'okhttp3.brotli')
+  }
+}
+
+dependencies {
+  api project(':okhttp')
+  api deps.brotli
+  compileOnly deps.jsr305
+
+  testImplementation project(':okhttp-testing-support')
+  testImplementation project(':mockwebserver')
+  testImplementation deps.conscrypt
+  testImplementation deps.junit
+  testImplementation deps.assertj
+}
diff --git a/okhttp-brotli/gradle.properties b/okhttp-brotli/gradle.properties
new file mode 100644
index 0000000000..dc6217c482
--- /dev/null
+++ b/okhttp-brotli/gradle.properties
@@ -0,0 +1,3 @@
+POM_ARTIFACT_ID=okhttp-brotli
+POM_NAME=okhttp-brotli
+POM_PACKAGING=jar
diff --git a/okhttp-brotli/src/main/java/okhttp3/brotli/BrotliInterceptor.kt b/okhttp-brotli/src/main/java/okhttp3/brotli/BrotliInterceptor.kt
new file mode 100644
index 0000000000..ab4e18220e
--- /dev/null
+++ b/okhttp-brotli/src/main/java/okhttp3/brotli/BrotliInterceptor.kt
@@ -0,0 +1,64 @@
+/*
+ * Copyright (C) 2019 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.brotli
+
+import okhttp3.Interceptor
+import okhttp3.Response
+import okhttp3.ResponseBody.Companion.asResponseBody
+import okio.GzipSource
+import okio.buffer
+import okio.source
+import org.brotli.dec.BrotliInputStream
+
+/**
+ * Transparent Brotli response support.
+ *
+ * Adds Accept-Encoding: br to request and checks (and strips) for Content-Encoding: br in
+ * responses.  n.b. this replaces the transparent gzip compression in BridgeInterceptor.
+ */
+object BrotliInterceptor : Interceptor {
+  override fun intercept(chain: Interceptor.Chain): Response =
+      if (chain.request().header("Accept-Encoding") == null) {
+        val request = chain.request().newBuilder()
+            .header("Accept-Encoding", "br,gzip")
+            .build()
+
+        val response = chain.proceed(request)
+
+        uncompress(response)
+      } else {
+        chain.proceed(chain.request())
+      }
+
+  internal fun uncompress(response: Response): Response {
+    val body = response.body ?: return response
+    val encoding = response.header("Content-Encoding") ?: return response
+
+    val decompressedSource = when {
+      encoding.equals("br", ignoreCase = true) ->
+        BrotliInputStream(body.source().inputStream()).source().buffer()
+      encoding.equals("gzip", ignoreCase = true) ->
+        GzipSource(body.source()).buffer()
+      else -> return response
+    }
+
+    return response.newBuilder()
+        .removeHeader("Content-Encoding")
+        .removeHeader("Content-Length")
+        .body(decompressedSource.asResponseBody(body.contentType(), -1))
+        .build()
+  }
+}
diff --git a/okhttp-brotli/src/test/java/okhttp3/brotli/BrotliInterceptorJavaApiTest.java b/okhttp-brotli/src/test/java/okhttp3/brotli/BrotliInterceptorJavaApiTest.java
new file mode 100644
index 0000000000..9b0efd0b11
--- /dev/null
+++ b/okhttp-brotli/src/test/java/okhttp3/brotli/BrotliInterceptorJavaApiTest.java
@@ -0,0 +1,26 @@
+/*
+ * Copyright (C) 2019 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.brotli;
+
+import org.junit.Ignore;
+import org.junit.Test;
+
+public class BrotliInterceptorJavaApiTest {
+  @Test @Ignore
+  public void testApi() {
+    BrotliInterceptor.INSTANCE.intercept(null);
+  }
+}
diff --git a/okhttp-brotli/src/test/java/okhttp3/brotli/BrotliInterceptorTest.kt b/okhttp-brotli/src/test/java/okhttp3/brotli/BrotliInterceptorTest.kt
new file mode 100644
index 0000000000..c4e16e6b9d
--- /dev/null
+++ b/okhttp-brotli/src/test/java/okhttp3/brotli/BrotliInterceptorTest.kt
@@ -0,0 +1,112 @@
+/*
+ * Copyright (C) 2019 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.brotli
+
+import okhttp3.MediaType.Companion.toMediaType
+import okhttp3.Protocol
+import okhttp3.Request
+import okhttp3.Response
+import okhttp3.ResponseBody.Companion.toResponseBody
+import okio.ByteString
+import okio.ByteString.Companion.decodeHex
+import okio.ByteString.Companion.encodeUtf8
+import org.assertj.core.api.Assertions.assertThat
+import org.junit.Assert.fail
+import org.junit.Test
+import java.io.IOException
+
+class BrotliInterceptorTest {
+  @Test
+  fun testUncompressBrotli() {
+    val s =
+        "1bce00009c05ceb9f028d14e416230f718960a537b0922d2f7b6adef56532c08dff44551516690131494db" +
+            "6021c7e3616c82c1bc2416abb919aaa06e8d30d82cc2981c2f5c900bfb8ee29d5c03deb1c0dacff80e" +
+            "abe82ba64ed250a497162006824684db917963ecebe041b352a3e62d629cc97b95cac24265b175171e" +
+            "5cb384cd0912aeb5b5dd9555f2dd1a9b20688201"
+
+    val response = response("https://httpbin.org/brotli", s.decodeHex()) {
+      header("Content-Encoding", "br")
+    }
+
+    val uncompressed = BrotliInterceptor.uncompress(response)
+
+    val responseString = uncompressed.body?.string()
+    assertThat(responseString).contains("\"brotli\": true,")
+    assertThat(responseString).contains("\"Accept-Encoding\": \"br\"")
+  }
+
+  @Test
+  fun testUncompressGzip() {
+    val s =
+        "1f8b0800968f215d02ff558ec10e82301044ef7c45b3e75269d0c478e340e4a426e007086c4a636c9bb65e" +
+            "24fcbb5b484c3cec61deccecee9c3106eaa39dc3114e2cfa377296d8848f117d20369324500d03ba98" +
+            "d766b0a3368a0ce83d4f55581b14696c88894f31ba5e1b61bdfa79f7803eaf149a35619f29b3db0b29" +
+            "8abcbd54b7b6b97640c965bbfec238d9f4109ceb6edb01d66ba54d6247296441531e445970f627215b" +
+            "b22f1017320dd5000000"
+
+    val response = response("https://httpbin.org/gzip", s.decodeHex()) {
+      header("Content-Encoding", "gzip")
+    }
+
+    val uncompressed = BrotliInterceptor.uncompress(response)
+
+    val responseString = uncompressed.body?.string()
+    assertThat(responseString).contains("\"gzipped\": true,")
+    assertThat(responseString).contains("\"Accept-Encoding\": \"br,gzip\"")
+  }
+
+  @Test
+  fun testNoUncompress() {
+    val response = response("https://httpbin.org/brotli", "XXXX".encodeUtf8())
+
+    val same = BrotliInterceptor.uncompress(response)
+
+    val responseString = same.body?.string()
+    assertThat(responseString).isEqualTo("XXXX")
+  }
+
+  @Test
+  fun testFailsUncompress() {
+    val response = response("https://httpbin.org/brotli", "bb919aaa06e8".decodeHex()) {
+      header("Content-Encoding", "br")
+    }
+
+    try {
+      val failingResponse = BrotliInterceptor.uncompress(response)
+      failingResponse.body?.string()
+
+      fail("expected uncompress error")
+    } catch (ioe: IOException) {
+      assertThat(ioe).hasMessage("Brotli stream decoding failed")
+      assertThat(ioe.cause?.javaClass?.simpleName).isEqualTo("BrotliRuntimeException")
+    }
+  }
+
+  private fun response(
+    url: String,
+    bodyHex: ByteString,
+    fn: Response.Builder.() -> Unit = {}
+  ): Response {
+    return Response.Builder()
+        .body(bodyHex.toResponseBody("text/plain".toMediaType()))
+        .code(200)
+        .message("OK")
+        .request(Request.Builder().url(url).build())
+        .protocol(Protocol.HTTP_2)
+        .apply(fn)
+        .build()
+  }
+}
diff --git a/okhttp-brotli/src/test/java/okhttp3/brotli/BrotliTestMain.kt b/okhttp-brotli/src/test/java/okhttp3/brotli/BrotliTestMain.kt
new file mode 100644
index 0000000000..bfae423ee1
--- /dev/null
+++ b/okhttp-brotli/src/test/java/okhttp3/brotli/BrotliTestMain.kt
@@ -0,0 +1,36 @@
+/*
+ * Copyright (C) 2019 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.brotli
+
+import okhttp3.OkHttpClient
+import okhttp3.Request
+
+fun main() {
+  val client = OkHttpClient.Builder()
+      .addInterceptor(BrotliInterceptor)
+      .build()
+
+  sendRequest("https://httpbin.org/brotli", client)
+  sendRequest("https://httpbin.org/gzip", client)
+}
+
+private fun sendRequest(url: String, client: OkHttpClient) {
+  val req = Request.Builder().url(url).build()
+
+  client.newCall(req).execute().use {
+    println(it.body?.string())
+  }
+}
\ No newline at end of file
diff --git a/okhttp-dnsoverhttps/README.md b/okhttp-dnsoverhttps/README.md
index 5aea64e7e2..b5ef1c9075 100644
--- a/okhttp-dnsoverhttps/README.md
+++ b/okhttp-dnsoverhttps/README.md
@@ -7,5 +7,5 @@ API is not considered stable and may change at any time.
 ### Download
 
 ```kotlin
-testImplementation("com.squareup.okhttp3:okhttp-dnsoverhttps:3.14.2")
+testImplementation("com.squareup.okhttp3:okhttp-dnsoverhttps:4.1.0")
 ```
diff --git a/okhttp-dnsoverhttps/build.gradle b/okhttp-dnsoverhttps/build.gradle
index be16589de1..16fb4c80fb 100644
--- a/okhttp-dnsoverhttps/build.gradle
+++ b/okhttp-dnsoverhttps/build.gradle
@@ -19,7 +19,7 @@ dependencies {
 
 afterEvaluate { project ->
   project.tasks.dokka {
-    outputDirectory = "$rootDir/docs/api"
+    outputDirectory = "$rootDir/docs/4.x"
     outputFormat = 'gfm'
   }
 }
diff --git a/okhttp-dnsoverhttps/src/main/java/okhttp3/dnsoverhttps/DnsRecordCodec.kt b/okhttp-dnsoverhttps/src/main/java/okhttp3/dnsoverhttps/DnsRecordCodec.kt
index c7b42184d3..ebf0d4a592 100644
--- a/okhttp-dnsoverhttps/src/main/java/okhttp3/dnsoverhttps/DnsRecordCodec.kt
+++ b/okhttp-dnsoverhttps/src/main/java/okhttp3/dnsoverhttps/DnsRecordCodec.kt
@@ -92,7 +92,7 @@ object DnsRecordCodec {
 
       val type = buf.readShort().toInt() and 0xffff
       buf.readShort() // class
-      val ttl = buf.readInt().toLong() and 0xffffffffL // ttl
+      @Suppress("UNUSED_VARIABLE") val ttl = buf.readInt().toLong() and 0xffffffffL // ttl
       val length = buf.readShort().toInt() and 0xffff
 
       if (type == TYPE_A || type == TYPE_AAAA) {
diff --git a/okhttp-logging-interceptor/README.md b/okhttp-logging-interceptor/README.md
index 690a290879..5b0a740030 100644
--- a/okhttp-logging-interceptor/README.md
+++ b/okhttp-logging-interceptor/README.md
@@ -37,7 +37,7 @@ Download
 --------
 
 ```kotlin
-implementation("com.squareup.okhttp3:logging-interceptor:3.14.2")
+implementation("com.squareup.okhttp3:logging-interceptor:4.1.0")
 ```
 
 
diff --git a/okhttp-logging-interceptor/build.gradle b/okhttp-logging-interceptor/build.gradle
index b96034803e..b9d5410558 100644
--- a/okhttp-logging-interceptor/build.gradle
+++ b/okhttp-logging-interceptor/build.gradle
@@ -21,7 +21,7 @@ dependencies {
 
 afterEvaluate { project ->
   project.tasks.dokka {
-    outputDirectory = "$rootDir/docs/api"
+    outputDirectory = "$rootDir/docs/4.x"
     outputFormat = 'gfm'
   }
 }
diff --git a/okhttp-logging-interceptor/src/main/java/okhttp3/logging/LoggingEventListener.kt b/okhttp-logging-interceptor/src/main/java/okhttp3/logging/LoggingEventListener.kt
index 3e47250999..35024ed219 100644
--- a/okhttp-logging-interceptor/src/main/java/okhttp3/logging/LoggingEventListener.kt
+++ b/okhttp-logging-interceptor/src/main/java/okhttp3/logging/LoggingEventListener.kt
@@ -19,6 +19,7 @@ import okhttp3.Call
 import okhttp3.Connection
 import okhttp3.EventListener
 import okhttp3.Handshake
+import okhttp3.HttpUrl
 import okhttp3.OkHttpClient
 import okhttp3.Protocol
 import okhttp3.Request
@@ -47,6 +48,14 @@ class LoggingEventListener private constructor(
     logWithTime("callStart: ${call.request()}")
   }
 
+  override fun proxySelectStart(call: Call, url: HttpUrl) {
+    logWithTime("proxySelectStart: $url")
+  }
+
+  override fun proxySelectEnd(call: Call, url: HttpUrl, proxies: List<Proxy>) {
+    logWithTime("proxySelectEnd: $proxies")
+  }
+
   override fun dnsStart(call: Call, domainName: String) {
     logWithTime("dnsStart: $domainName")
   }
diff --git a/okhttp-logging-interceptor/src/test/java/okhttp3/logging/HttpLoggingInterceptorTest.java b/okhttp-logging-interceptor/src/test/java/okhttp3/logging/HttpLoggingInterceptorTest.java
index c6fb0e8860..e9a7bce269 100644
--- a/okhttp-logging-interceptor/src/test/java/okhttp3/logging/HttpLoggingInterceptorTest.java
+++ b/okhttp-logging-interceptor/src/test/java/okhttp3/logging/HttpLoggingInterceptorTest.java
@@ -25,7 +25,7 @@
 import okhttp3.HttpUrl;
 import okhttp3.MediaType;
 import okhttp3.OkHttpClient;
-import okhttp3.PlatformRule;
+import okhttp3.testing.PlatformRule;
 import okhttp3.Protocol;
 import okhttp3.RecordingHostnameVerifier;
 import okhttp3.Request;
diff --git a/okhttp-logging-interceptor/src/test/java/okhttp3/logging/LoggingEventListenerTest.java b/okhttp-logging-interceptor/src/test/java/okhttp3/logging/LoggingEventListenerTest.java
index 52e3625356..97690f5997 100644
--- a/okhttp-logging-interceptor/src/test/java/okhttp3/logging/LoggingEventListenerTest.java
+++ b/okhttp-logging-interceptor/src/test/java/okhttp3/logging/LoggingEventListenerTest.java
@@ -20,7 +20,7 @@
 import okhttp3.HttpUrl;
 import okhttp3.MediaType;
 import okhttp3.OkHttpClient;
-import okhttp3.PlatformRule;
+import okhttp3.testing.PlatformRule;
 import okhttp3.Request;
 import okhttp3.RequestBody;
 import okhttp3.Response;
@@ -74,6 +74,8 @@ public void get() throws Exception {
 
     logRecorder
         .assertLogMatch("callStart: Request\\{method=GET, url=" + url + "\\}")
+        .assertLogMatch("proxySelectStart: " + url)
+        .assertLogMatch("proxySelectEnd: \\[DIRECT\\]")
         .assertLogMatch("dnsStart: " + url.host())
         .assertLogMatch("dnsEnd: \\[.+\\]")
         .assertLogMatch("connectStart: " + url.host() + "/.+ DIRECT")
@@ -105,6 +107,8 @@ public void post() throws IOException {
 
     logRecorder
         .assertLogMatch("callStart: Request\\{method=POST, url=" + url + "\\}")
+        .assertLogMatch("proxySelectStart: " + url)
+        .assertLogMatch("proxySelectEnd: \\[DIRECT\\]")
         .assertLogMatch("dnsStart: " + url.host())
         .assertLogMatch("dnsEnd: \\[.+\\]")
         .assertLogMatch("connectStart: " + url.host() + "/.+ DIRECT")
@@ -145,6 +149,8 @@ public void secureGet() throws Exception {
 
     logRecorder
         .assertLogMatch("callStart: Request\\{method=GET, url=" + url + "\\}")
+        .assertLogMatch("proxySelectStart: " + url)
+        .assertLogMatch("proxySelectEnd: \\[DIRECT\\]")
         .assertLogMatch("dnsStart: " + url.host())
         .assertLogMatch("dnsEnd: \\[.+\\]")
         .assertLogMatch("connectStart: " + url.host() + "/.+ DIRECT")
@@ -188,6 +194,8 @@ public void dnsFail() throws IOException {
 
     logRecorder
         .assertLogMatch("callStart: Request\\{method=GET, url=" + url + "\\}")
+        .assertLogMatch("proxySelectStart: " + url)
+        .assertLogMatch("proxySelectEnd: \\[DIRECT\\]")
         .assertLogMatch("dnsStart: " + url.host())
         .assertLogMatch("callFailed: java.net.UnknownHostException: reason")
         .assertNoMoreLogs();
@@ -208,6 +216,8 @@ public void connectFail() {
 
     logRecorder
         .assertLogMatch("callStart: Request\\{method=GET, url=" + url + "\\}")
+        .assertLogMatch("proxySelectStart: " + url)
+        .assertLogMatch("proxySelectEnd: \\[DIRECT\\]")
         .assertLogMatch("dnsStart: " + url.host())
         .assertLogMatch("dnsEnd: \\[.+\\]")
         .assertLogMatch("connectStart: " + url.host() + "/.+ DIRECT")
diff --git a/okhttp-sse/README.md b/okhttp-sse/README.md
index d8f570a19f..aa1fdf9726 100644
--- a/okhttp-sse/README.md
+++ b/okhttp-sse/README.md
@@ -7,5 +7,5 @@ API is not considered stable and may change at any time.
 ### Download
 
 ```kotlin
-testImplementation("com.squareup.okhttp3:okhttp-sse:3.14.2")
+testImplementation("com.squareup.okhttp3:okhttp-sse:4.1.0")
 ```
diff --git a/okhttp-sse/build.gradle b/okhttp-sse/build.gradle
index 594eb2c1de..db2745599c 100644
--- a/okhttp-sse/build.gradle
+++ b/okhttp-sse/build.gradle
@@ -20,7 +20,7 @@ dependencies {
 
 afterEvaluate { project ->
   project.tasks.dokka {
-    outputDirectory = "$rootDir/docs/api"
+    outputDirectory = "$rootDir/docs/4.x"
     outputFormat = 'gfm'
   }
 }
diff --git a/okhttp-testing-support/src/main/java/okhttp3/ClientRuleEventListener.kt b/okhttp-testing-support/src/main/java/okhttp3/ClientRuleEventListener.kt
new file mode 100644
index 0000000000..28444acdb2
--- /dev/null
+++ b/okhttp-testing-support/src/main/java/okhttp3/ClientRuleEventListener.kt
@@ -0,0 +1,143 @@
+/*
+ * Copyright (C) 2018 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3
+
+import java.io.IOException
+import java.net.InetAddress
+import java.net.InetSocketAddress
+import java.net.Proxy
+import java.util.concurrent.TimeUnit
+
+class ClientRuleEventListener(var logger: (String) -> Unit) : EventListener(),
+    EventListener.Factory {
+  private var startNs: Long = 0
+
+  override fun create(call: Call): EventListener = this
+
+  override fun callStart(call: Call) {
+    startNs = System.nanoTime()
+
+    logWithTime("callStart: ${call.request()}")
+  }
+
+  override fun proxySelectStart(call: Call, url: HttpUrl) {
+    logWithTime("proxySelectStart: $url")
+  }
+
+  override fun proxySelectEnd(call: Call, url: HttpUrl, proxies: List<Proxy>) {
+    logWithTime("proxySelectEnd: $proxies")
+  }
+
+  override fun dnsStart(call: Call, domainName: String) {
+    logWithTime("dnsStart: $domainName")
+  }
+
+  override fun dnsEnd(call: Call, domainName: String, inetAddressList: List<InetAddress>) {
+    logWithTime("dnsEnd: $inetAddressList")
+  }
+
+  override fun connectStart(call: Call, inetSocketAddress: InetSocketAddress, proxy: Proxy) {
+    logWithTime("connectStart: $inetSocketAddress $proxy")
+  }
+
+  override fun secureConnectStart(call: Call) {
+    logWithTime("secureConnectStart")
+  }
+
+  override fun secureConnectEnd(call: Call, handshake: Handshake?) {
+    logWithTime("secureConnectEnd: $handshake")
+  }
+
+  override fun connectEnd(
+    call: Call,
+    inetSocketAddress: InetSocketAddress,
+    proxy: Proxy,
+    protocol: Protocol?
+  ) {
+    logWithTime("connectEnd: $protocol")
+  }
+
+  override fun connectFailed(
+    call: Call,
+    inetSocketAddress: InetSocketAddress,
+    proxy: Proxy,
+    protocol: Protocol?,
+    ioe: IOException
+  ) {
+    logWithTime("connectFailed: $protocol $ioe")
+  }
+
+  override fun connectionAcquired(call: Call, connection: Connection) {
+    logWithTime("connectionAcquired: $connection")
+  }
+
+  override fun connectionReleased(call: Call, connection: Connection) {
+    logWithTime("connectionReleased")
+  }
+
+  override fun requestHeadersStart(call: Call) {
+    logWithTime("requestHeadersStart")
+  }
+
+  override fun requestHeadersEnd(call: Call, request: Request) {
+    logWithTime("requestHeadersEnd")
+  }
+
+  override fun requestBodyStart(call: Call) {
+    logWithTime("requestBodyStart")
+  }
+
+  override fun requestBodyEnd(call: Call, byteCount: Long) {
+    logWithTime("requestBodyEnd: byteCount=$byteCount")
+  }
+
+  override fun requestFailed(call: Call, ioe: IOException) {
+    logWithTime("requestFailed: $ioe")
+  }
+
+  override fun responseHeadersStart(call: Call) {
+    logWithTime("responseHeadersStart")
+  }
+
+  override fun responseHeadersEnd(call: Call, response: Response) {
+    logWithTime("responseHeadersEnd: $response")
+  }
+
+  override fun responseBodyStart(call: Call) {
+    logWithTime("responseBodyStart")
+  }
+
+  override fun responseBodyEnd(call: Call, byteCount: Long) {
+    logWithTime("responseBodyEnd: byteCount=$byteCount")
+  }
+
+  override fun responseFailed(call: Call, ioe: IOException) {
+    logWithTime("responseFailed: $ioe")
+  }
+
+  override fun callEnd(call: Call) {
+    logWithTime("callEnd")
+  }
+
+  override fun callFailed(call: Call, ioe: IOException) {
+    logWithTime("callFailed: $ioe")
+  }
+
+  private fun logWithTime(message: String) {
+    val timeMs = TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - startNs)
+    logger.invoke("[$timeMs ms] $message")
+  }
+}
diff --git a/okhttp-testing-support/src/main/java/okhttp3/OkHttpClientTestRule.kt b/okhttp-testing-support/src/main/java/okhttp3/OkHttpClientTestRule.kt
index 90e067b8a8..6d3484807e 100644
--- a/okhttp-testing-support/src/main/java/okhttp3/OkHttpClientTestRule.kt
+++ b/okhttp-testing-support/src/main/java/okhttp3/OkHttpClientTestRule.kt
@@ -15,6 +15,7 @@
  */
 package okhttp3
 
+import okhttp3.testing.Flaky
 import org.assertj.core.api.Assertions.assertThat
 import org.junit.rules.TestRule
 import org.junit.runner.Description
@@ -24,6 +25,7 @@ import java.util.concurrent.ConcurrentLinkedDeque
 
 /** Apply this rule to tests that need an OkHttpClient instance. */
 class OkHttpClientTestRule : TestRule {
+  private val clientEventsList = mutableListOf<String>()
   private var prototype: OkHttpClient? = null
 
   /**
@@ -40,13 +42,21 @@ class OkHttpClientTestRule : TestRule {
   }
 
   fun newClientBuilder(): OkHttpClient.Builder {
-    return checkNotNull(prototype) { "don't create clients in test initialization!" }.newBuilder()
+    return checkNotNull(prototype) { "don't create clients in test initialization!" }
+        .newBuilder()
+        .eventListener(ClientRuleEventListener { addEvent(it) })
+  }
+
+  @Synchronized private fun addEvent(it: String) {
+    clientEventsList.add(it)
   }
 
   fun ensureAllConnectionsReleased() {
-    val connectionPool = prototype!!.connectionPool
-    connectionPool.evictAll()
-    assertThat(connectionPool.idleConnectionCount()).isEqualTo(0)
+    prototype?.let {
+      val connectionPool = it.connectionPool
+      connectionPool.evictAll()
+      assertThat(connectionPool.connectionCount()).isEqualTo(0)
+    }
   }
 
   override fun apply(base: Statement, description: Description): Statement {
@@ -55,6 +65,10 @@ class OkHttpClientTestRule : TestRule {
         acquireClient()
         try {
           base.evaluate()
+          logEventsIfFlaky(description)
+        } catch (t: Throwable) {
+          logEvents()
+          throw t
         } finally {
           ensureAllConnectionsReleased()
           releaseClient()
@@ -62,18 +76,49 @@ class OkHttpClientTestRule : TestRule {
       }
 
       private fun acquireClient() {
-        prototype = prototypes.poll() ?: OkHttpClient.Builder()
-            .dns(SINGLE_INET_ADDRESS_DNS) // Prevent unexpected fallback addresses.
-            .build()
+        prototype = prototypes.poll() ?: freshClient()
       }
 
       private fun releaseClient() {
-        prototypes.push(prototype)
-        prototype = null
+        prototype?.let {
+          prototypes.push(it)
+          prototype = null
+        }
       }
     }
   }
 
+  private fun logEventsIfFlaky(description: Description) {
+    if (isTestFlaky(description)) {
+      logEvents()
+    }
+  }
+
+  private fun isTestFlaky(description: Description): Boolean {
+    return description.annotations.any { it.annotationClass == Flaky::class } ||
+        description.testClass.annotations.any { it.annotationClass == Flaky::class }
+  }
+
+  @Synchronized private fun logEvents() {
+    // Will be ineffective if test overrides the listener
+    println("Events (${clientEventsList.size})")
+
+    for (e in clientEventsList) {
+      println(e)
+    }
+  }
+
+  /**
+   * Called if a test is known to be leaky.
+   */
+  fun abandonClient() {
+    prototype?.let {
+      prototype = null
+      it.dispatcher.executorService.shutdownNow()
+      it.connectionPool.evictAll()
+    }
+  }
+
   companion object {
     /**
      * Quick and dirty pool of OkHttpClient instances. Each has its own independent dispatcher and
@@ -92,5 +137,11 @@ class OkHttpClientTestRule : TestRule {
         return listOf(addresses[0])
       }
     }
+
+    private fun freshClient(): OkHttpClient {
+      return OkHttpClient.Builder()
+          .dns(SINGLE_INET_ADDRESS_DNS) // Prevent unexpected fallback addresses.
+          .build()
+    }
   }
 }
diff --git a/okhttp-testing-support/src/main/java/okhttp3/testing/Flaky.kt b/okhttp-testing-support/src/main/java/okhttp3/testing/Flaky.kt
new file mode 100644
index 0000000000..f3b04d8809
--- /dev/null
+++ b/okhttp-testing-support/src/main/java/okhttp3/testing/Flaky.kt
@@ -0,0 +1,24 @@
+/*
+ * Copyright (C) 2019 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.testing
+
+@Target(AnnotationTarget.CLASS, AnnotationTarget.FUNCTION)
+@Retention(AnnotationRetention.RUNTIME)
+/**
+ * Annotation marking a test as flaky, and requires extra logging and linking against
+ * a known github issue.  This does not ignore the failure.
+ */
+annotation class Flaky
diff --git a/okhttp-testing-support/src/main/java/okhttp3/PlatformRule.kt b/okhttp-testing-support/src/main/java/okhttp3/testing/PlatformRule.kt
similarity index 63%
rename from okhttp-testing-support/src/main/java/okhttp3/PlatformRule.kt
rename to okhttp-testing-support/src/main/java/okhttp3/testing/PlatformRule.kt
index 359de2c688..be02136094 100644
--- a/okhttp-testing-support/src/main/java/okhttp3/PlatformRule.kt
+++ b/okhttp-testing-support/src/main/java/okhttp3/testing/PlatformRule.kt
@@ -13,18 +13,27 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package okhttp3
+package okhttp3.testing
 
 import okhttp3.internal.platform.ConscryptPlatform
 import okhttp3.internal.platform.Jdk8WithJettyBootPlatform
 import okhttp3.internal.platform.Jdk9Platform
 import okhttp3.internal.platform.Platform
 import org.conscrypt.Conscrypt
+import org.hamcrest.BaseMatcher
+import org.hamcrest.CoreMatchers
 import org.hamcrest.CoreMatchers.equalTo
 import org.hamcrest.CoreMatchers.not
+import org.hamcrest.Description
+import org.hamcrest.Matcher
+import org.hamcrest.StringDescription
+import org.hamcrest.TypeSafeMatcher
+import org.junit.Assert
 import org.junit.Assume.assumeThat
 import org.junit.Assume.assumeTrue
-import org.junit.rules.ExternalResource
+import org.junit.AssumptionViolatedException
+import org.junit.rules.TestRule
+import org.junit.runners.model.Statement
 import java.security.Security
 
 /**
@@ -37,8 +46,34 @@ import java.security.Security
 open class PlatformRule @JvmOverloads constructor(
   val requiredPlatformName: String? = null,
   val platform: Platform? = null
-) : ExternalResource() {
-  override fun before() {
+) : TestRule {
+  private val versionChecks = mutableListOf<Pair<Matcher<out Any>, Matcher<out Any>>>()
+
+  override fun apply(base: Statement, description: org.junit.runner.Description): Statement {
+    return object : Statement() {
+      @Throws(Throwable::class)
+      override fun evaluate() {
+        var failed = false
+        try {
+          setupPlatform()
+
+          base.evaluate()
+        } catch (e: AssumptionViolatedException) {
+          throw e
+        } catch (e: Throwable) {
+          failed = true
+          rethrowIfNotExpected(e)
+        } finally {
+          resetPlatform()
+        }
+        if (!failed) {
+          failIfExpected()
+        }
+      }
+    }
+  }
+
+  fun setupPlatform() {
     if (requiredPlatformName != null) {
       assumeThat(getPlatformSystemProperty(), equalTo(requiredPlatformName))
     }
@@ -50,12 +85,72 @@ open class PlatformRule @JvmOverloads constructor(
     }
   }
 
-  override fun after() {
+  fun resetPlatform() {
     if (platform != null) {
       Platform.resetForTests()
     }
   }
 
+  fun expectFailureOnConscryptPlatform() {
+    expectFailure(platformMatches(CONSCRYPT_PROPERTY))
+  }
+
+  fun expectFailureFromJdkVersion(majorVersion: Int) {
+    expectFailure(fromMajor(majorVersion))
+  }
+
+  private fun expectFailure(
+    versionMatcher: Matcher<out Any>,
+    failureMatcher: Matcher<out Any> = CoreMatchers.anything()
+  ) {
+    versionChecks.add(Pair(versionMatcher, failureMatcher))
+  }
+
+  fun platformMatches(platform: String): Matcher<Any> = object : BaseMatcher<Any>() {
+    override fun describeTo(description: Description) {
+      description.appendText(platform)
+    }
+
+    override fun matches(item: Any?): Boolean {
+      return getPlatformSystemProperty() == platform
+    }
+  }
+
+  fun fromMajor(version: Int): Matcher<PlatformVersion> {
+    return object : TypeSafeMatcher<PlatformVersion>() {
+      override fun describeTo(description: org.hamcrest.Description) {
+        description.appendText("JDK with version from $version")
+      }
+
+      override fun matchesSafely(item: PlatformVersion): Boolean {
+        return item.majorVersion >= version
+      }
+    }
+  }
+
+  fun rethrowIfNotExpected(e: Throwable) {
+    versionChecks.forEach { (versionMatcher, failureMatcher) ->
+      if (versionMatcher.matches(PlatformVersion) && failureMatcher.matches(e)) {
+        return
+      }
+    }
+
+    throw e
+  }
+
+  fun failIfExpected() {
+    versionChecks.forEach { (versionMatcher, failureMatcher) ->
+      if (versionMatcher.matches(PlatformVersion)) {
+        val description = StringDescription()
+        versionMatcher.describeTo(description)
+        description.appendText(" expected to fail with exception that ")
+        failureMatcher.describeTo(description)
+
+        Assert.fail(description.toString())
+      }
+    }
+  }
+
   fun isConscrypt() = getPlatformSystemProperty() == CONSCRYPT_PROPERTY
 
   fun isJdk9() = getPlatformSystemProperty() == JDK9_PROPERTY
@@ -148,7 +243,8 @@ open class PlatformRule @JvmOverloads constructor(
 
     @JvmStatic
     fun getPlatformSystemProperty(): String {
-      var property: String? = System.getProperty(PROPERTY_NAME)
+      var property: String? = System.getProperty(
+          PROPERTY_NAME)
 
       if (property == null) {
         property = when (Platform.get()) {
diff --git a/okhttp-testing-support/src/main/java/okhttp3/testing/PlatformVersion.kt b/okhttp-testing-support/src/main/java/okhttp3/testing/PlatformVersion.kt
new file mode 100644
index 0000000000..17870a7ba7
--- /dev/null
+++ b/okhttp-testing-support/src/main/java/okhttp3/testing/PlatformVersion.kt
@@ -0,0 +1,29 @@
+/*
+ * Copyright (C) 2019 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.testing
+
+object PlatformVersion {
+  val majorVersion: Int by lazy {
+    when (val jvmSpecVersion = getJvmSpecVersion()) {
+      "1.8" -> 8
+      else -> jvmSpecVersion.toInt()
+    }
+  }
+
+  fun getJvmSpecVersion(): String {
+    return System.getProperty("java.specification.version", "unknown")
+  }
+}
\ No newline at end of file
diff --git a/okhttp/src/test/java/okhttp3/PlatformRuleTest.kt b/okhttp-testing-support/src/test/kotlin/okhttp3/testing/PlatformRuleTest.kt
similarity index 76%
rename from okhttp/src/test/java/okhttp3/PlatformRuleTest.kt
rename to okhttp-testing-support/src/test/kotlin/okhttp3/testing/PlatformRuleTest.kt
index 2c61838d8a..5fe531cd00 100644
--- a/okhttp/src/test/java/okhttp3/PlatformRuleTest.kt
+++ b/okhttp-testing-support/src/test/kotlin/okhttp3/testing/PlatformRuleTest.kt
@@ -13,7 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package okhttp3
+package okhttp3.testing
 
 import okhttp3.internal.platform.Platform
 import org.junit.Rule
@@ -32,4 +32,19 @@ class PlatformRuleTest {
     println(PlatformRule.getPlatformSystemProperty())
     println(Platform.get().javaClass.simpleName)
   }
+  @Test
+  fun testGreenCase() {
+  }
+
+  @Test
+  fun testGreenCaseFailingOnLater() {
+    platform.expectFailureFromJdkVersion(PlatformVersion.majorVersion + 1)
+  }
+
+  @Test
+  fun failureCase() {
+    platform.expectFailureFromJdkVersion(PlatformVersion.majorVersion)
+
+    check(false)
+  }
 }
\ No newline at end of file
diff --git a/okhttp-tls/README.md b/okhttp-tls/README.md
index ecd6de0a11..66809a0dd9 100644
--- a/okhttp-tls/README.md
+++ b/okhttp-tls/README.md
@@ -227,10 +227,10 @@ Download
 --------
 
 ```kotlin
-implementation("com.squareup.okhttp3:okhttp-tls:3.14.2")
+implementation("com.squareup.okhttp3:okhttp-tls:4.1.0")
 ```
 
- [held_certificate]: http://square.github.io/okhttp/api/okhttp-tls/okhttp3.tls/-held-certificate/
- [held_certificate_builder]: http://square.github.io/okhttp/api/okhttp-tls/okhttp3.tls/-held-certificate/-builder/
- [handshake_certificates]: http://square.github.io/okhttp/api/okhttp-tls/okhttp3.tls/-handshake-certificates/
- [handshake_certificates_builder]: http://square.github.io/okhttp/api/okhttp-tls/okhttp3.tls/-handshake-certificates/-builder/
+ [held_certificate]: http://square.github.io/okhttp/4.x/okhttp-tls/okhttp3.tls/-held-certificate/
+ [held_certificate_builder]: http://square.github.io/okhttp/4.x/okhttp-tls/okhttp3.tls/-held-certificate/-builder/
+ [handshake_certificates]: http://square.github.io/okhttp/4.x/okhttp-tls/okhttp3.tls/-handshake-certificates/
+ [handshake_certificates_builder]: http://square.github.io/okhttp/4.x/okhttp-tls/okhttp3.tls/-handshake-certificates/-builder/
diff --git a/okhttp-tls/build.gradle b/okhttp-tls/build.gradle
index a0d9194d64..011d8c0abc 100644
--- a/okhttp-tls/build.gradle
+++ b/okhttp-tls/build.gradle
@@ -20,7 +20,7 @@ dependencies {
 
 afterEvaluate { project ->
   project.tasks.dokka {
-    outputDirectory = "$rootDir/docs/api"
+    outputDirectory = "$rootDir/docs/4.x"
     outputFormat = 'gfm'
   }
 }
diff --git a/okhttp-tls/src/test/java/okhttp3/tls/HandshakeCertificatesTest.java b/okhttp-tls/src/test/java/okhttp3/tls/HandshakeCertificatesTest.java
index 81b5db61da..96b876cb94 100644
--- a/okhttp-tls/src/test/java/okhttp3/tls/HandshakeCertificatesTest.java
+++ b/okhttp-tls/src/test/java/okhttp3/tls/HandshakeCertificatesTest.java
@@ -164,8 +164,12 @@ private InetSocketAddress startTlsServer() throws IOException {
         sslSocket.startHandshake();
         return Handshake.get(sslSocket.getSession());
       } finally {
-        closeQuietly(rawSocket);
-        closeQuietly(sslSocket);
+        if (rawSocket != null) {
+          closeQuietly(rawSocket);
+        }
+        if (sslSocket != null) {
+          closeQuietly(sslSocket);
+        }
       }
     });
   }
@@ -183,7 +187,9 @@ private InetSocketAddress startTlsServer() throws IOException {
         return Handshake.get(sslSocket.getSession());
       } finally {
         closeQuietly(rawSocket);
-        closeQuietly(sslSocket);
+        if (sslSocket != null) {
+          closeQuietly(sslSocket);
+        }
       }
     });
   }
diff --git a/okhttp-urlconnection/README.md b/okhttp-urlconnection/README.md
index 1a2234c30b..8b4395f064 100644
--- a/okhttp-urlconnection/README.md
+++ b/okhttp-urlconnection/README.md
@@ -6,5 +6,5 @@ This module integrates OkHttp with `Authenticator` and `CookieHandler` from `jav
 ### Download
 
 ```kotlin
-testImplementation("com.squareup.okhttp3:okhttp-urlconnection:3.14.2")
+testImplementation("com.squareup.okhttp3:okhttp-urlconnection:4.1.0")
 ```
diff --git a/okhttp-urlconnection/build.gradle b/okhttp-urlconnection/build.gradle
index e94507e0cc..8a197bdcd3 100644
--- a/okhttp-urlconnection/build.gradle
+++ b/okhttp-urlconnection/build.gradle
@@ -21,7 +21,7 @@ dependencies {
 
 afterEvaluate { project ->
   project.tasks.dokka {
-    outputDirectory = "$rootDir/docs/api"
+    outputDirectory = "$rootDir/docs/4.x"
     outputFormat = 'gfm'
   }
 }
diff --git a/okhttp/build.gradle b/okhttp/build.gradle
index dd2a7702cc..a03f3d8ec3 100644
--- a/okhttp/build.gradle
+++ b/okhttp/build.gradle
@@ -43,7 +43,7 @@ dependencies {
 
 afterEvaluate { project ->
   project.tasks.dokka {
-    outputDirectory = "$rootDir/docs/api"
+    outputDirectory = "$rootDir/docs/4.x"
     outputFormat = 'gfm'
   }
 }
diff --git a/okhttp/src/main/java/okhttp3/CertificatePinner.kt b/okhttp/src/main/java/okhttp3/CertificatePinner.kt
index bd46897d2e..29e3f9ddaf 100644
--- a/okhttp/src/main/java/okhttp3/CertificatePinner.kt
+++ b/okhttp/src/main/java/okhttp3/CertificatePinner.kt
@@ -123,6 +123,7 @@ import javax.net.ssl.SSLPeerUnverifiedException
  * [rfc_7469]: http://tools.ietf.org/html/rfc7469
  * [static_certificates]: http://goo.gl/XDh6je
  */
+@Suppress("NAME_SHADOWING")
 class CertificatePinner internal constructor(
   private val pins: Set<Pin>,
   private val certificateChainCleaner: CertificateChainCleaner?
diff --git a/okhttp/src/main/java/okhttp3/ConnectionSpec.kt b/okhttp/src/main/java/okhttp3/ConnectionSpec.kt
index a9b54f00e9..7804b0d98d 100644
--- a/okhttp/src/main/java/okhttp3/ConnectionSpec.kt
+++ b/okhttp/src/main/java/okhttp3/ConnectionSpec.kt
@@ -168,13 +168,12 @@ class ConnectionSpec internal constructor(
     if (other !is ConnectionSpec) return false
     if (other === this) return true
 
-    val that = other as ConnectionSpec?
-    if (this.isTls != that!!.isTls) return false
+    if (this.isTls != other.isTls) return false
 
     if (isTls) {
-      if (!Arrays.equals(this.cipherSuitesAsString, that.cipherSuitesAsString)) return false
-      if (!Arrays.equals(this.tlsVersionsAsString, that.tlsVersionsAsString)) return false
-      if (this.supportsTlsExtensions != that.supportsTlsExtensions) return false
+      if (!Arrays.equals(this.cipherSuitesAsString, other.cipherSuitesAsString)) return false
+      if (!Arrays.equals(this.tlsVersionsAsString, other.tlsVersionsAsString)) return false
+      if (this.supportsTlsExtensions != other.supportsTlsExtensions) return false
     }
 
     return true
@@ -183,8 +182,8 @@ class ConnectionSpec internal constructor(
   override fun hashCode(): Int {
     var result = 17
     if (isTls) {
-      result = 31 * result + cipherSuitesAsString!!.contentHashCode()
-      result = 31 * result + tlsVersionsAsString!!.contentHashCode()
+      result = 31 * result + (cipherSuitesAsString?.contentHashCode() ?: 0)
+      result = 31 * result + (tlsVersionsAsString?.contentHashCode() ?: 0)
       result = 31 * result + if (supportsTlsExtensions) 0 else 1
     }
     return result
@@ -269,6 +268,7 @@ class ConnectionSpec internal constructor(
     )
   }
 
+  @Suppress("DEPRECATION")
   companion object {
     // Most secure but generally supported list.
     private val RESTRICTED_CIPHER_SUITES = arrayOf(
diff --git a/okhttp/src/main/java/okhttp3/Cookie.kt b/okhttp/src/main/java/okhttp3/Cookie.kt
index 6d86410cf6..3a16bb64f9 100644
--- a/okhttp/src/main/java/okhttp3/Cookie.kt
+++ b/okhttp/src/main/java/okhttp3/Cookie.kt
@@ -24,6 +24,7 @@ import okhttp3.internal.indexOfControlOrNonAscii
 import okhttp3.internal.publicsuffix.PublicSuffixDatabase
 import okhttp3.internal.toCanonicalHost
 import okhttp3.internal.trimSubstring
+import org.codehaus.mojo.animal_sniffer.IgnoreJRERequirement
 import java.util.Calendar
 import java.util.Collections
 import java.util.Date
@@ -39,6 +40,7 @@ import java.util.regex.Pattern
  *
  * [chromium_extension]: https://code.google.com/p/chromium/issues/detail?id=232693
  */
+@Suppress("NAME_SHADOWING")
 class Cookie private constructor(
   /** Returns a non-empty string with this cookie's name. */
   @get:JvmName("name") val name: String,
@@ -124,6 +126,7 @@ class Cookie private constructor(
         other.hostOnly == hostOnly
   }
 
+  @IgnoreJRERequirement // As of AGP 3.4.1, D8 desugars API 24 hashCode methods.
   override fun hashCode(): Int {
     var result = 17
     result = 31 * result + name.hashCode()
@@ -323,6 +326,7 @@ class Cookie private constructor(
     }
   }
 
+  @Suppress("NAME_SHADOWING")
   companion object {
     private val YEAR_PATTERN = Pattern.compile("(\\d{2,4})[^\\d]*")
     private val MONTH_PATTERN =
diff --git a/okhttp/src/main/java/okhttp3/EventListener.kt b/okhttp/src/main/java/okhttp3/EventListener.kt
index 1953953437..f52fa00af2 100644
--- a/okhttp/src/main/java/okhttp3/EventListener.kt
+++ b/okhttp/src/main/java/okhttp3/EventListener.kt
@@ -60,6 +60,42 @@ abstract class EventListener {
   ) {
   }
 
+  /**
+   * Invoked prior to a proxy selection.
+   *
+   * This will be invoked for route selection regardless of whether the client
+   * is configured with a single proxy, a proxy selector, or neither.
+   *
+   * @param url a URL with only the scheme, hostname, and port specified.
+   */
+  open fun proxySelectStart(
+    call: Call,
+    url: HttpUrl
+  ) {
+  }
+
+  /**
+   * Invoked after proxy selection.
+   *
+   * Note that the list of proxies is never null, but it may be a list containing
+   * only [Proxy.NO_PROXY]. This comes up in several situations:
+   *
+   * * If neither a proxy nor proxy selector is configured.
+   * * If the proxy is configured explicitly as [Proxy.NO_PROXY].
+   * * If the proxy selector returns only [Proxy.NO_PROXY].
+   * * If the proxy selector returns an empty list or null.
+   *
+   * Otherwise it lists the proxies in the order they will be attempted.
+   *
+   * @param url a URL with only the scheme, hostname, and port specified.
+   */
+  open fun proxySelectEnd(
+    call: Call,
+    url: HttpUrl,
+    proxies: List<@JvmSuppressWildcards Proxy>
+  ) {
+  }
+
   /**
    * Invoked just prior to a DNS lookup. See [Dns.lookup].
    *
diff --git a/okhttp/src/main/java/okhttp3/Headers.kt b/okhttp/src/main/java/okhttp3/Headers.kt
index 6193b39abd..40b52296c9 100644
--- a/okhttp/src/main/java/okhttp3/Headers.kt
+++ b/okhttp/src/main/java/okhttp3/Headers.kt
@@ -46,6 +46,7 @@ import java.util.TreeSet
  *
  * Instances of this class are immutable. Use [Builder] to create instances.
  */
+@Suppress("NAME_SHADOWING")
 class Headers private constructor(
   private val namesAndValues: Array<String>
 ) : Iterable<Pair<String, String>> {
diff --git a/okhttp/src/main/java/okhttp3/MultipartBody.kt b/okhttp/src/main/java/okhttp3/MultipartBody.kt
index fce2c2b513..abf62fbe59 100644
--- a/okhttp/src/main/java/okhttp3/MultipartBody.kt
+++ b/okhttp/src/main/java/okhttp3/MultipartBody.kt
@@ -29,6 +29,7 @@ import java.util.UUID
  *
  * [rfc_2387]: http://www.ietf.org/rfc/rfc2387.txt
  */
+@Suppress("NAME_SHADOWING")
 class MultipartBody internal constructor(
   private val boundaryByteString: ByteString,
   @get:JvmName("type") val type: MediaType,
diff --git a/okhttp/src/main/java/okhttp3/OkHttpClient.kt b/okhttp/src/main/java/okhttp3/OkHttpClient.kt
index a80f756fb7..009f303cf9 100644
--- a/okhttp/src/main/java/okhttp3/OkHttpClient.kt
+++ b/okhttp/src/main/java/okhttp3/OkHttpClient.kt
@@ -160,7 +160,12 @@ open class OkHttpClient internal constructor(
 
   @get:JvmName("proxy") val proxy: Proxy? = builder.proxy
 
-  @get:JvmName("proxySelector") val proxySelector: ProxySelector = builder.proxySelector
+  @get:JvmName("proxySelector") val proxySelector: ProxySelector =
+      when {
+        // Avoid possible SecurityException from ProxySelector.getDefault
+        builder.proxy != null -> NullProxySelector()
+        else -> builder.proxySelector ?: ProxySelector.getDefault() ?: NullProxySelector()
+      }
 
   @get:JvmName("proxyAuthenticator") val proxyAuthenticator: Authenticator =
       builder.proxyAuthenticator
@@ -172,6 +177,8 @@ open class OkHttpClient internal constructor(
   @get:JvmName("sslSocketFactory") val sslSocketFactory: SSLSocketFactory
     get() = sslSocketFactoryOrNull ?: throw IllegalStateException("CLEARTEXT-only client")
 
+  @get:JvmName("x509TrustManager") val x509TrustManager: X509TrustManager?
+
   @get:JvmName("connectionSpecs") val connectionSpecs: List<ConnectionSpec> =
       builder.connectionSpecs
 
@@ -207,11 +214,12 @@ open class OkHttpClient internal constructor(
     if (builder.sslSocketFactoryOrNull != null || connectionSpecs.none { it.isTls }) {
       this.sslSocketFactoryOrNull = builder.sslSocketFactoryOrNull
       this.certificateChainCleaner = builder.certificateChainCleaner
+      this.x509TrustManager = builder.x509TrustManagerOrNull
     } else {
-      val trustManager = Platform.get().platformTrustManager()
-      Platform.get().configureTrustManager(trustManager)
-      this.sslSocketFactoryOrNull = newSslSocketFactory(trustManager)
-      this.certificateChainCleaner = CertificateChainCleaner.get(trustManager)
+      this.x509TrustManager = Platform.get().platformTrustManager()
+      Platform.get().configureTrustManager(x509TrustManager)
+      this.sslSocketFactoryOrNull = newSslSocketFactory(x509TrustManager!!)
+      this.certificateChainCleaner = CertificateChainCleaner.get(x509TrustManager!!)
     }
 
     if (sslSocketFactoryOrNull != null) {
@@ -439,10 +447,11 @@ open class OkHttpClient internal constructor(
     internal var cache: Cache? = null
     internal var dns: Dns = Dns.SYSTEM
     internal var proxy: Proxy? = null
-    internal var proxySelector: ProxySelector = ProxySelector.getDefault() ?: NullProxySelector()
+    internal var proxySelector: ProxySelector? = null
     internal var proxyAuthenticator: Authenticator = Authenticator.NONE
     internal var socketFactory: SocketFactory = SocketFactory.getDefault()
     internal var sslSocketFactoryOrNull: SSLSocketFactory? = null
+    internal var x509TrustManagerOrNull: X509TrustManager? = null
     internal var connectionSpecs: List<ConnectionSpec> = DEFAULT_CONNECTION_SPECS
     internal var protocols: List<Protocol> = DEFAULT_PROTOCOLS
     internal var hostnameVerifier: HostnameVerifier = OkHostnameVerifier
@@ -472,6 +481,7 @@ open class OkHttpClient internal constructor(
       this.proxyAuthenticator = okHttpClient.proxyAuthenticator
       this.socketFactory = okHttpClient.socketFactory
       this.sslSocketFactoryOrNull = okHttpClient.sslSocketFactoryOrNull
+      this.x509TrustManagerOrNull = okHttpClient.x509TrustManager
       this.connectionSpecs = okHttpClient.connectionSpecs
       this.protocols = okHttpClient.protocols
       this.hostnameVerifier = okHttpClient.hostnameVerifier
@@ -716,6 +726,7 @@ open class OkHttpClient internal constructor(
     ) = apply {
       this.sslSocketFactoryOrNull = sslSocketFactory
       this.certificateChainCleaner = CertificateChainCleaner.get(trustManager)
+      this.x509TrustManagerOrNull = trustManager
     }
 
     fun connectionSpecs(connectionSpecs: List<ConnectionSpec>) = apply {
@@ -767,7 +778,7 @@ open class OkHttpClient internal constructor(
       require(Protocol.HTTP_1_0 !in protocolsCopy) {
         "protocols must not contain http/1.0: $protocolsCopy"
       }
-      require(null !in (protocols as List<Protocol?>)) {
+      require(null !in (protocolsCopy as List<Protocol?>)) {
         "protocols must not contain null"
       }
 
diff --git a/okhttp/src/main/java/okhttp3/Response.kt b/okhttp/src/main/java/okhttp3/Response.kt
index a38a746bf4..9456f93dc6 100644
--- a/okhttp/src/main/java/okhttp3/Response.kt
+++ b/okhttp/src/main/java/okhttp3/Response.kt
@@ -433,7 +433,7 @@ class Response internal constructor(
     }
 
     open fun build(): Response {
-      check(code > 0) { "code < 0: $code" }
+      check(code >= 0) { "code < 0: $code" }
       return Response(
           checkNotNull(request) { "request == null" },
           checkNotNull(protocol) { "protocol == null" },
diff --git a/okhttp/src/main/java/okhttp3/ResponseBody.kt b/okhttp/src/main/java/okhttp3/ResponseBody.kt
index 1650cc109d..04731370d1 100644
--- a/okhttp/src/main/java/okhttp3/ResponseBody.kt
+++ b/okhttp/src/main/java/okhttp3/ResponseBody.kt
@@ -121,16 +121,31 @@ abstract class ResponseBody : Closeable {
    * possibility for your response.
    */
   @Throws(IOException::class)
-  fun bytes(): ByteArray {
+  fun bytes() = consumeSource(BufferedSource::readByteArray) { it.size }
+
+  /**
+   * Returns the response as a [ByteString].
+   *
+   * This method loads entire response body into memory. If the response body is very large this
+   * may trigger an [OutOfMemoryError]. Prefer to stream the response body if this is a
+   * possibility for your response.
+   */
+  @Throws(IOException::class)
+  fun byteString() = consumeSource(BufferedSource::readByteString) { it.size }
+
+  private inline fun <T : Any> consumeSource(
+    consumer: (BufferedSource) -> T,
+    sizeMapper: (T) -> Int
+  ): T {
     val contentLength = contentLength()
-    if (contentLength > Integer.MAX_VALUE) {
+    if (contentLength > Int.MAX_VALUE) {
       throw IOException("Cannot buffer entire body for content length: $contentLength")
     }
 
-    val bytes: ByteArray = source().use(BufferedSource::readByteArray)
-    if (contentLength != -1L && contentLength != bytes.size.toLong()) {
-      throw IOException(
-          "Content-Length ($contentLength) and stream length (${bytes.size}) disagree")
+    val bytes = source().use(consumer)
+    val size = sizeMapper(bytes)
+    if (contentLength != -1L && contentLength != size.toLong()) {
+      throw IOException("Content-Length ($contentLength) and stream length ($size) disagree")
     }
     return bytes
   }
diff --git a/okhttp/src/main/java/okhttp3/internal/Util.kt b/okhttp/src/main/java/okhttp3/internal/Util.kt
index 8ae9bc23ae..bd37b1e633 100644
--- a/okhttp/src/main/java/okhttp3/internal/Util.kt
+++ b/okhttp/src/main/java/okhttp3/internal/Util.kt
@@ -474,7 +474,7 @@ fun <K, V> Map<K, V>.toImmutableMap(): Map<K, V> {
   }
 }
 
-/** Closes this, ignoring any checked exceptions. Does nothing if this is null. */
+/** Closes this, ignoring any checked exceptions. */
 fun Closeable.closeQuietly() {
   try {
     close()
@@ -484,7 +484,7 @@ fun Closeable.closeQuietly() {
   }
 }
 
-/** Closes this, ignoring any checked exceptions. Does nothing if this is null. */
+/** Closes this, ignoring any checked exceptions. */
 fun Socket.closeQuietly() {
   try {
     close()
@@ -496,7 +496,7 @@ fun Socket.closeQuietly() {
   }
 }
 
-/** Closes this, ignoring any checked exceptions. Does nothing if this is null. */
+/** Closes this, ignoring any checked exceptions.  */
 fun ServerSocket.closeQuietly() {
   try {
     close()
diff --git a/okhttp/src/main/java/okhttp3/internal/cache/DiskLruCache.kt b/okhttp/src/main/java/okhttp3/internal/cache/DiskLruCache.kt
index 15803c95de..b9d028b094 100644
--- a/okhttp/src/main/java/okhttp3/internal/cache/DiskLruCache.kt
+++ b/okhttp/src/main/java/okhttp3/internal/cache/DiskLruCache.kt
@@ -706,6 +706,8 @@ class DiskLruCache internal constructor(
 
           while (delegate.hasNext()) {
             val entry = delegate.next()
+            if (entry == null || !entry.readable) continue // Entry during edit
+
             val snapshot = entry.snapshot() ?: continue
             // Evicted since we copied the entries.
             nextSnapshot = snapshot
diff --git a/okhttp/src/main/java/okhttp3/internal/connection/ExchangeFinder.kt b/okhttp/src/main/java/okhttp3/internal/connection/ExchangeFinder.kt
index 448a67dffd..122e8f5c8d 100644
--- a/okhttp/src/main/java/okhttp3/internal/connection/ExchangeFinder.kt
+++ b/okhttp/src/main/java/okhttp3/internal/connection/ExchangeFinder.kt
@@ -254,6 +254,10 @@ class ExchangeFinder(
         result!!.noNewExchanges = true
         socket = result!!.socket()
         result = transmitter.connection
+
+        // It's possible for us to obtain a coalesced connection that is immediately unhealthy. In
+        // that case we will retry the route we just successfully connected with.
+        nextRouteToTry = selectedRoute
       } else {
         connectionPool.put(result!!)
         transmitter.acquireConnectionNoEvents(result!!)
diff --git a/okhttp/src/main/java/okhttp3/internal/connection/RealConnectionPool.kt b/okhttp/src/main/java/okhttp3/internal/connection/RealConnectionPool.kt
index d18559bb75..8dc3c57bce 100644
--- a/okhttp/src/main/java/okhttp3/internal/connection/RealConnectionPool.kt
+++ b/okhttp/src/main/java/okhttp3/internal/connection/RealConnectionPool.kt
@@ -21,10 +21,10 @@ import okhttp3.ConnectionPool
 import okhttp3.Route
 import okhttp3.internal.closeQuietly
 import okhttp3.internal.connection.Transmitter.TransmitterReference
+import okhttp3.internal.lockAndWaitNanos
 import okhttp3.internal.notifyAll
 import okhttp3.internal.platform.Platform
 import okhttp3.internal.threadFactory
-import okhttp3.internal.lockAndWaitNanos
 import java.io.IOException
 import java.net.Proxy
 import java.util.ArrayDeque
@@ -47,7 +47,9 @@ class RealConnectionPool(
         if (waitNanos == -1L) return
         try {
           this@RealConnectionPool.lockAndWaitNanos(waitNanos)
-        } catch (_: InterruptedException) {
+        } catch (ie: InterruptedException) {
+          // Will cause the thread to exit unless other connections are created!
+          evictAll()
         }
       }
     }
diff --git a/okhttp/src/main/java/okhttp3/internal/connection/RouteSelector.kt b/okhttp/src/main/java/okhttp3/internal/connection/RouteSelector.kt
index 395951364a..a1db48a79f 100644
--- a/okhttp/src/main/java/okhttp3/internal/connection/RouteSelector.kt
+++ b/okhttp/src/main/java/okhttp3/internal/connection/RouteSelector.kt
@@ -94,6 +94,7 @@ class RouteSelector(
 
   /** Prepares the proxy servers to try. */
   private fun resetNextProxy(url: HttpUrl, proxy: Proxy?) {
+    eventListener.proxySelectStart(call, url)
     proxies = if (proxy != null) {
       // If the user specifies a proxy, try that and only that.
       listOf(proxy)
@@ -107,6 +108,7 @@ class RouteSelector(
       }
     }
     nextProxyIndex = 0
+    eventListener.proxySelectEnd(call, url, proxies)
   }
 
   /** Returns true if there's another proxy to try. */
diff --git a/okhttp/src/main/java/okhttp3/internal/http/HttpHeaders.kt b/okhttp/src/main/java/okhttp3/internal/http/HttpHeaders.kt
index 5f1b787c8f..b9cf66e682 100644
--- a/okhttp/src/main/java/okhttp3/internal/http/HttpHeaders.kt
+++ b/okhttp/src/main/java/okhttp3/internal/http/HttpHeaders.kt
@@ -14,6 +14,7 @@
  * limitations under the License.
  */
 @file:JvmName("HttpHeaders")
+
 package okhttp3.internal.http
 
 import okhttp3.Challenge
@@ -232,3 +233,11 @@ fun Response.promisesBody(): Boolean {
 
   return false
 }
+
+@Deprecated(
+    message = "No longer supported",
+    level = DeprecationLevel.ERROR,
+    replaceWith = ReplaceWith(expression = "response.promisesBody()"))
+fun hasBody(response: Response): Boolean {
+  return response.promisesBody()
+}
diff --git a/okhttp/src/main/java/okhttp3/internal/http/HttpMethod.kt b/okhttp/src/main/java/okhttp3/internal/http/HttpMethod.kt
index 7998f6650f..a031cf3f5b 100644
--- a/okhttp/src/main/java/okhttp3/internal/http/HttpMethod.kt
+++ b/okhttp/src/main/java/okhttp3/internal/http/HttpMethod.kt
@@ -22,12 +22,14 @@ object HttpMethod {
       method == "DELETE" ||
       method == "MOVE") // WebDAV
 
+  @JvmStatic // Despite being 'internal', this method is called by popular 3rd party SDKs.
   fun requiresRequestBody(method: String): Boolean = (method == "POST" ||
       method == "PUT" ||
       method == "PATCH" ||
       method == "PROPPATCH" || // WebDAV
       method == "REPORT") // CalDAV/CardDAV (defined in WebDAV Versioning)
 
+  @JvmStatic // Despite being 'internal', this method is called by popular 3rd party SDKs.
   fun permitsRequestBody(method: String): Boolean = !(method == "GET" || method == "HEAD")
 
   fun redirectsWithBody(method: String): Boolean =
diff --git a/okhttp/src/main/java/okhttp3/internal/http2/Hpack.kt b/okhttp/src/main/java/okhttp3/internal/http2/Hpack.kt
index c56a2156fd..292db0bba2 100644
--- a/okhttp/src/main/java/okhttp3/internal/http2/Hpack.kt
+++ b/okhttp/src/main/java/okhttp3/internal/http2/Hpack.kt
@@ -40,6 +40,7 @@ import java.util.LinkedHashMap
  * entries are added to the array, starting in the last position moving forward. When the array
  * fills, it is doubled.
  */
+@Suppress("NAME_SHADOWING")
 object Hpack {
   private const val PREFIX_4_BITS = 0x0f
   private const val PREFIX_5_BITS = 0x1f
diff --git a/okhttp/src/main/java/okhttp3/internal/http2/Http2Connection.kt b/okhttp/src/main/java/okhttp3/internal/http2/Http2Connection.kt
index 0cded18e24..663b6f4038 100644
--- a/okhttp/src/main/java/okhttp3/internal/http2/Http2Connection.kt
+++ b/okhttp/src/main/java/okhttp3/internal/http2/Http2Connection.kt
@@ -58,6 +58,7 @@ import java.util.concurrent.TimeUnit.MILLISECONDS
  * This is typical for Java but atypical for HTTP/2. This is motivated by exception transparency:
  * an [IOException] that was triggered by a certain caller can be caught and handled by that caller.
  */
+@Suppress("NAME_SHADOWING")
 class Http2Connection internal constructor(builder: Builder) : Closeable {
 
   // Internal state of this connection is guarded by 'this'. No blocking operations may be
@@ -700,11 +701,11 @@ class Http2Connection internal constructor(builder: Builder) : Closeable {
     }
 
     override fun ping(
-      reply: Boolean,
+      ack: Boolean,
       payload1: Int,
       payload2: Int
     ) {
-      if (reply) {
+      if (ack) {
         synchronized(this@Http2Connection) {
           awaitingPong = false
           this@Http2Connection.notifyAll()
diff --git a/okhttp/src/main/java/okhttp3/internal/http2/Http2Stream.kt b/okhttp/src/main/java/okhttp3/internal/http2/Http2Stream.kt
index 4be10de903..045150fed3 100644
--- a/okhttp/src/main/java/okhttp3/internal/http2/Http2Stream.kt
+++ b/okhttp/src/main/java/okhttp3/internal/http2/Http2Stream.kt
@@ -33,6 +33,7 @@ import java.net.SocketTimeoutException
 import java.util.ArrayDeque
 
 /** A logical bidirectional stream. */
+@Suppress("NAME_SHADOWING")
 class Http2Stream internal constructor(
   val id: Int,
   val connection: Http2Connection,
diff --git a/okhttp/src/main/java/okhttp3/internal/http2/Http2Writer.kt b/okhttp/src/main/java/okhttp3/internal/http2/Http2Writer.kt
index 1b636e986a..64221e7667 100644
--- a/okhttp/src/main/java/okhttp3/internal/http2/Http2Writer.kt
+++ b/okhttp/src/main/java/okhttp3/internal/http2/Http2Writer.kt
@@ -41,6 +41,7 @@ import java.util.logging.Level.FINE
 import java.util.logging.Logger
 
 /** Writes HTTP/2 transport frames. */
+@Suppress("NAME_SHADOWING")
 class Http2Writer(
   private val sink: BufferedSink,
   private val client: Boolean
diff --git a/okhttp/src/main/java/okhttp3/internal/tls/OkHostnameVerifier.kt b/okhttp/src/main/java/okhttp3/internal/tls/OkHostnameVerifier.kt
index f6c3afcb34..df3ee9b1c4 100644
--- a/okhttp/src/main/java/okhttp3/internal/tls/OkHostnameVerifier.kt
+++ b/okhttp/src/main/java/okhttp3/internal/tls/OkHostnameVerifier.kt
@@ -29,6 +29,7 @@ import javax.net.ssl.SSLSession
  *
  * [rfc_2818]: http://www.ietf.org/rfc/rfc2818.txt
  */
+@Suppress("NAME_SHADOWING")
 object OkHostnameVerifier : HostnameVerifier {
   private const val ALT_DNS_NAME = 2
   private const val ALT_IPA_NAME = 7
diff --git a/okhttp/src/main/java/okhttp3/internal/ws/WebSocketProtocol.kt b/okhttp/src/main/java/okhttp3/internal/ws/WebSocketProtocol.kt
index 5da8abcc50..58bdda788d 100644
--- a/okhttp/src/main/java/okhttp3/internal/ws/WebSocketProtocol.kt
+++ b/okhttp/src/main/java/okhttp3/internal/ws/WebSocketProtocol.kt
@@ -122,7 +122,7 @@ object WebSocketProtocol {
   fun closeCodeExceptionMessage(code: Int): String? {
     return if (code < 1000 || code >= 5000) {
       "Code must be in range [1000,5000): $code"
-    } else if (code in 1004..1006 || code in 1012..2999) {
+    } else if (code in 1004..1006 || code in 1015..2999) {
       "Code $code is reserved and may not be used."
     } else {
       null
diff --git a/okhttp/src/test/java/okhttp3/CallKotlinTest.kt b/okhttp/src/test/java/okhttp3/CallKotlinTest.kt
index 5ca735b357..df7e3f2f89 100644
--- a/okhttp/src/test/java/okhttp3/CallKotlinTest.kt
+++ b/okhttp/src/test/java/okhttp3/CallKotlinTest.kt
@@ -17,6 +17,7 @@ package okhttp3
 
 import okhttp3.mockwebserver.MockResponse
 import okhttp3.mockwebserver.MockWebServer
+import okhttp3.testing.PlatformRule
 import org.assertj.core.api.Assertions.assertThat
 import org.junit.Before
 import org.junit.Rule
diff --git a/okhttp/src/test/java/okhttp3/CallTest.java b/okhttp/src/test/java/okhttp3/CallTest.java
index 1989bab164..2d95ed4dbd 100644
--- a/okhttp/src/test/java/okhttp3/CallTest.java
+++ b/okhttp/src/test/java/okhttp3/CallTest.java
@@ -71,6 +71,7 @@
 import okhttp3.mockwebserver.QueueDispatcher;
 import okhttp3.mockwebserver.RecordedRequest;
 import okhttp3.mockwebserver.SocketPolicy;
+import okhttp3.testing.PlatformRule;
 import okhttp3.tls.HandshakeCertificates;
 import okhttp3.tls.HeldCertificate;
 import okio.Buffer;
@@ -92,7 +93,6 @@
 import static okhttp3.CipherSuite.TLS_DH_anon_WITH_AES_128_GCM_SHA256;
 import static okhttp3.TestUtil.awaitGarbageCollection;
 import static okhttp3.internal.Internal.addHeaderLenient;
-import static okhttp3.internal.platform.PlatformTest.getJvmSpecVersion;
 import static okhttp3.tls.internal.TlsUtil.localhost;
 import static org.assertj.core.api.Assertions.assertThat;
 import static org.assertj.core.data.Offset.offset;
@@ -1316,7 +1316,6 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
 
     // The _anon_ suites became unsupported in "1.8.0_201" and "11.0.2".
     assumeFalse(System.getProperty("java.version", "unknown").matches("1\\.8\\.0_1\\d\\d"));
-    assumeFalse(System.getProperty("java.version", "unknown").matches("11"));
 
     server.enqueue(new MockResponse());
 
@@ -1397,8 +1396,7 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
   }
 
   @Test public void matchingPinnedCertificate() throws Exception {
-    // TODO https://github.com/square/okhttp/issues/4703
-    assumeFalse(getJvmSpecVersion().equals("11"));
+    // Fails on 11.0.1 https://github.com/square/okhttp/issues/4703
 
     enableTls();
     server.enqueue(new MockResponse());
diff --git a/okhttp/src/test/java/okhttp3/CertificatePinnerKotlinTest.kt b/okhttp/src/test/java/okhttp3/CertificatePinnerKotlinTest.kt
index 2ecf967259..8de9cea1de 100644
--- a/okhttp/src/test/java/okhttp3/CertificatePinnerKotlinTest.kt
+++ b/okhttp/src/test/java/okhttp3/CertificatePinnerKotlinTest.kt
@@ -29,7 +29,7 @@ class CertificatePinnerKotlinTest {
         .add("example.com", "sha1/" + certA1.certificate.toSha1ByteString().base64())
         .build()
 
-    certificatePinner.check("example.com", certA1.certificate)
+    certificatePinner.check("example.com", listOf(certA1.certificate))
   }
 
   @Test fun successfulFindMatchingPins() {
diff --git a/okhttp/src/test/java/okhttp3/ConnectionCoalescingTest.java b/okhttp/src/test/java/okhttp3/ConnectionCoalescingTest.java
index 3d4aa6c4c4..0895bbe11c 100644
--- a/okhttp/src/test/java/okhttp3/ConnectionCoalescingTest.java
+++ b/okhttp/src/test/java/okhttp3/ConnectionCoalescingTest.java
@@ -21,15 +21,16 @@
 import java.net.Proxy;
 import java.util.Collections;
 import java.util.List;
+import java.util.concurrent.CountDownLatch;
 import java.util.concurrent.atomic.AtomicInteger;
 import java.util.concurrent.atomic.AtomicReference;
 import javax.net.ssl.HostnameVerifier;
 import okhttp3.mockwebserver.MockResponse;
 import okhttp3.mockwebserver.MockWebServer;
+import okhttp3.testing.PlatformRule;
 import okhttp3.tls.HandshakeCertificates;
 import okhttp3.tls.HeldCertificate;
 import org.junit.Before;
-import org.junit.Ignore;
 import org.junit.Rule;
 import org.junit.Test;
 
@@ -51,7 +52,6 @@
   private List<InetAddress> serverIps;
 
   @Before public void setUp() throws Exception {
-    platform.assumeNotConscrypt();
     platform.assumeHttp2Support();
 
     rootCa = new HeldCertificate.Builder()
@@ -152,6 +152,107 @@
     assertThat(client.connectionPool().connectionCount()).isEqualTo(1);
   }
 
+  /**
+   * This is an extraordinary test case. Here's what it's trying to simulate.
+   * - 2 requests happen concurrently to a host that can be coalesced onto a single connection.
+   * - Both request discover no existing connection. They both make a connection.
+   * - The first request "wins the race".
+   * - The second request discovers it "lost the race" and closes the connection it just opened.
+   * - The second request uses the coalesced connection from request1.
+   * - The coalesced connection is violently closed after servicing the first request.
+   * - The second request discovers the coalesced connection is unhealthy just after acquiring it.
+   */
+  @Test public void coalescedConnectionDestroyedAfterAcquire() throws Exception {
+    server.enqueue(new MockResponse().setResponseCode(200));
+    server.enqueue(new MockResponse().setResponseCode(200));
+
+    dns.set("san.com", Dns.SYSTEM.lookup(server.getHostName()).subList(0, 1));
+    HttpUrl sanUrl = url.newBuilder().host("san.com").build();
+
+    CountDownLatch latch1 = new CountDownLatch(1);
+    CountDownLatch latch2 = new CountDownLatch(1);
+    CountDownLatch latch3 = new CountDownLatch(1);
+    CountDownLatch latch4 = new CountDownLatch(1);
+    EventListener listener1 = new EventListener() {
+      @Override public void connectStart(Call call, InetSocketAddress inetSocketAddress,
+          Proxy proxy) {
+        try {
+          // Wait for request2 to guarantee we make 2 separate connections to the server.
+          latch1.await();
+        } catch (InterruptedException e) {
+          throw new AssertionError(e);
+        }
+      }
+
+      @Override public void connectionAcquired(Call call, Connection connection) {
+        // We have the connection and it's in the pool. Let request2 proceed to make a connection.
+        latch2.countDown();
+      }
+    };
+
+    EventListener request2Listener = new EventListener() {
+      @Override public void connectStart(Call call, InetSocketAddress inetSocketAddress,
+          Proxy proxy) {
+        // Let request1 proceed to make a connection.
+        latch1.countDown();
+        try {
+          // Wait until request1 makes the connection and puts it in the connection pool.
+          latch2.await();
+        } catch (InterruptedException e) {
+          throw new AssertionError(e);
+        }
+      }
+
+      @Override public void connectionAcquired(Call call, Connection connection) {
+        // We obtained the coalesced connection. Let request1 violently destroy it.
+        latch3.countDown();
+        try {
+          latch4.await();
+        } catch (InterruptedException e) {
+          throw new AssertionError(e);
+        }
+      }
+    };
+
+    // Get a reference to the connection so we can violently destroy it.
+    AtomicReference<Connection> connection = new AtomicReference<>();
+    OkHttpClient client1 = client.newBuilder()
+        .addNetworkInterceptor(chain -> {
+          connection.set(chain.connection());
+          return chain.proceed(chain.request());
+        })
+        .eventListener(listener1)
+        .build();
+
+    Request request = new Request.Builder().url(sanUrl).build();
+    Call call1 = client1.newCall(request);
+    call1.enqueue(new Callback() {
+      @Override public void onResponse(Call call, Response response) throws IOException {
+        try {
+          // Wait until request2 acquires the connection before we destroy it violently.
+          latch3.await();
+        } catch (InterruptedException e) {
+          throw new AssertionError(e);
+        }
+        assert200Http2Response(response, "san.com");
+        connection.get().socket().close();
+        latch4.countDown();
+      }
+
+      @Override public void onFailure(Call call, IOException e) {
+        fail();
+      }
+    });
+
+    OkHttpClient client2 = client.newBuilder()
+        .eventListener(request2Listener)
+        .build();
+    Call call2 = client2.newCall(request);
+    Response response = call2.execute();
+
+    assert200Http2Response(response, "san.com");
+  }
+
   /** If the existing connection matches a SAN but not a match for DNS then skip. */
   @Test public void skipsWhenDnsDontMatch() throws Exception {
     server.enqueue(new MockResponse().setResponseCode(200));
@@ -302,24 +403,6 @@
     assertThat(client.connectionPool().connectionCount()).isEqualTo(1);
   }
 
-  /** Run against public external sites, doesn't run by default. */
-  @Ignore
-  @Test public void coalescesConnectionsToRealSites() throws IOException {
-    client = new OkHttpClient();
-
-    assert200Http2Response(execute("https://graph.facebook.com/robots.txt"), "graph.facebook.com");
-    assert200Http2Response(execute("https://www.facebook.com/robots.txt"), "m.facebook.com");
-    assert200Http2Response(execute("https://fb.com/robots.txt"), "m.facebook.com");
-    assert200Http2Response(execute("https://messenger.com/robots.txt"), "messenger.com");
-    assert200Http2Response(execute("https://m.facebook.com/robots.txt"), "m.facebook.com");
-
-    assertThat(client.connectionPool().connectionCount()).isEqualTo(3);
-  }
-
-  private Response execute(String url) throws IOException {
-    return execute(HttpUrl.get(url));
-  }
-
   private Response execute(HttpUrl url) throws IOException {
     return client.newCall(new Request.Builder().url(url).build()).execute();
   }
diff --git a/okhttp/src/test/java/okhttp3/ConnectionReuseTest.java b/okhttp/src/test/java/okhttp3/ConnectionReuseTest.java
index f66172e41f..a3445d7813 100644
--- a/okhttp/src/test/java/okhttp3/ConnectionReuseTest.java
+++ b/okhttp/src/test/java/okhttp3/ConnectionReuseTest.java
@@ -22,6 +22,7 @@
 import okhttp3.mockwebserver.MockResponse;
 import okhttp3.mockwebserver.MockWebServer;
 import okhttp3.mockwebserver.SocketPolicy;
+import okhttp3.testing.PlatformRule;
 import okhttp3.tls.HandshakeCertificates;
 import org.junit.Before;
 import org.junit.Rule;
diff --git a/okhttp/src/test/java/okhttp3/ConnectionSpecTest.java b/okhttp/src/test/java/okhttp3/ConnectionSpecTest.java
index 7c066e28ca..6663416032 100644
--- a/okhttp/src/test/java/okhttp3/ConnectionSpecTest.java
+++ b/okhttp/src/test/java/okhttp3/ConnectionSpecTest.java
@@ -21,6 +21,7 @@
 import java.util.concurrent.CopyOnWriteArraySet;
 import javax.net.ssl.SSLSocket;
 import javax.net.ssl.SSLSocketFactory;
+import okhttp3.testing.PlatformRule;
 import org.junit.Rule;
 import org.junit.Test;
 
@@ -283,6 +284,8 @@
     assertThat(set.add(ConnectionSpec.CLEARTEXT)).isTrue();
     assertThat(set.add(allTlsVersions)).isTrue();
     assertThat(set.add(allCipherSuites)).isTrue();
+    allCipherSuites.hashCode();
+    assertThat(allCipherSuites.equals(null)).isFalse();
 
     assertThat(set.remove(ConnectionSpec.MODERN_TLS)).isTrue();
     assertThat(set.remove(ConnectionSpec.COMPATIBLE_TLS)).isTrue();
@@ -290,6 +293,8 @@
     assertThat(set.remove(allTlsVersions)).isTrue();
     assertThat(set.remove(allCipherSuites)).isTrue();
     assertThat(set).isEmpty();
+    allTlsVersions.hashCode();
+    assertThat(allTlsVersions.equals(null)).isFalse();
   }
 
   @Test public void allEnabledToString() throws Exception {
diff --git a/okhttp/src/test/java/okhttp3/ConscryptTest.kt b/okhttp/src/test/java/okhttp3/ConscryptTest.kt
index 8c7a45e8c3..547e822cd1 100644
--- a/okhttp/src/test/java/okhttp3/ConscryptTest.kt
+++ b/okhttp/src/test/java/okhttp3/ConscryptTest.kt
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2014 Square, Inc.
+ * Copyright (C) 2018 Square, Inc.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -17,13 +17,14 @@ package okhttp3
 
 import okhttp3.internal.platform.ConscryptPlatform
 import okhttp3.internal.platform.Platform
+import okhttp3.testing.PlatformRule
 import org.assertj.core.api.Assertions.assertThat
 import org.conscrypt.Conscrypt
-import org.junit.After
 import org.junit.Assert.assertFalse
 import org.junit.Assert.assertTrue
 import org.junit.Assume
 import org.junit.Before
+import org.junit.Ignore
 import org.junit.Rule
 import org.junit.Test
 import java.net.InetAddress
@@ -35,17 +36,17 @@ class ConscryptTest {
   @Rule public val platform = PlatformRule.conscrypt()
 
   @JvmField @Rule val clientTestRule = OkHttpClientTestRule()
+
   private lateinit var client: OkHttpClient
 
-  @Before
-  fun setUp() {
+  @Before fun setUp() {
+    platform.assumeConscrypt()
     client = clientTestRule.newClient()
-    assertThat(Conscrypt.isConscrypt(Platform.get().platformTrustManager())).isTrue()
   }
 
-  @After
-  fun tearDown() {
-    clientTestRule.ensureAllConnectionsReleased()
+  @Test
+  fun testTrustManager() {
+    assertThat(Conscrypt.isConscrypt(Platform.get().platformTrustManager())).isTrue()
   }
 
   private fun assumeNetwork() {
@@ -57,29 +58,31 @@ class ConscryptTest {
   }
 
   @Test
+  @Ignore
   fun testMozilla() {
     assumeNetwork()
 
     val request = Request.Builder().url("https://mozilla.org/robots.txt").build()
 
-    val response = client.newCall(request).execute()
-
-    assertThat(response.protocol).isEqualTo(Protocol.HTTP_2)
-    assertThat(response.handshake!!.tlsVersion).isEqualTo(TlsVersion.TLS_1_3)
+    client.newCall(request).execute().use {
+      assertThat(it.protocol).isEqualTo(Protocol.HTTP_2)
+      assertThat(it.handshake!!.tlsVersion).isEqualTo(TlsVersion.TLS_1_3)
+    }
   }
 
   @Test
+  @Ignore
   fun testGoogle() {
     assumeNetwork()
 
     val request = Request.Builder().url("https://google.com/robots.txt").build()
 
-    val response = client.newCall(request).execute()
-
-    assertThat(response.protocol).isEqualTo(Protocol.HTTP_2)
-    if (response.handshake!!.tlsVersion != TlsVersion.TLS_1_3) {
-      System.err.println("Flaky TLSv1.3 with google")
-//    assertThat(response.handshake()!!.tlsVersion).isEqualTo(TlsVersion.TLS_1_3)
+    client.newCall(request).execute().use {
+      assertThat(it.protocol).isEqualTo(Protocol.HTTP_2)
+      if (it.handshake!!.tlsVersion != TlsVersion.TLS_1_3) {
+        System.err.println("Flaky TLSv1.3 with google")
+//    assertThat(it.handshake()!!.tlsVersion).isEqualTo(TlsVersion.TLS_1_3)
+      }
     }
   }
 
@@ -91,12 +94,14 @@ class ConscryptTest {
 
   @Test
   fun testVersion() {
+    val version = Conscrypt.version()
+
     assertTrue(ConscryptPlatform.atLeastVersion(1, 4, 9))
-    assertTrue(ConscryptPlatform.atLeastVersion(2))
-    assertTrue(ConscryptPlatform.atLeastVersion(2, 1))
-    assertTrue(ConscryptPlatform.atLeastVersion(2, 1, 0))
-    assertFalse(ConscryptPlatform.atLeastVersion(2, 1, 1))
-    assertFalse(ConscryptPlatform.atLeastVersion(2, 2))
-    assertFalse(ConscryptPlatform.atLeastVersion(9))
+    assertTrue(ConscryptPlatform.atLeastVersion(version.major()))
+    assertTrue(ConscryptPlatform.atLeastVersion(version.major(), version.minor()))
+    assertTrue(ConscryptPlatform.atLeastVersion(version.major(), version.minor(), version.patch()))
+    assertFalse(ConscryptPlatform.atLeastVersion(version.major(), version.minor(), version.patch() + 1))
+    assertFalse(ConscryptPlatform.atLeastVersion(version.major(), version.minor() + 1))
+    assertFalse(ConscryptPlatform.atLeastVersion(version.major() + 1))
   }
 }
diff --git a/okhttp/src/test/java/okhttp3/DuplexTest.java b/okhttp/src/test/java/okhttp3/DuplexTest.java
index 2dc4bcaee0..c5c64caf4e 100644
--- a/okhttp/src/test/java/okhttp3/DuplexTest.java
+++ b/okhttp/src/test/java/okhttp3/DuplexTest.java
@@ -27,6 +27,7 @@
 import okhttp3.mockwebserver.MockWebServer;
 import okhttp3.mockwebserver.SocketPolicy;
 import okhttp3.mockwebserver.internal.duplex.MockDuplexResponseBody;
+import okhttp3.testing.PlatformRule;
 import okhttp3.tls.HandshakeCertificates;
 import okio.BufferedSink;
 import okio.BufferedSource;
@@ -241,7 +242,7 @@
     mockDuplexResponseBody.awaitSuccess();
 
     assertThat(listener.recordedEventTypes()).containsExactly(
-        "CallStart", "DnsStart", "DnsEnd", "ConnectStart",
+        "CallStart", "ProxySelectStart", "ProxySelectEnd", "DnsStart", "DnsEnd", "ConnectStart",
         "SecureConnectStart", "SecureConnectEnd", "ConnectEnd", "ConnectionAcquired",
         "RequestHeadersStart", "RequestHeadersEnd", "RequestBodyStart", "ResponseHeadersStart",
         "ResponseHeadersEnd", "ResponseBodyStart", "ResponseBodyEnd", "RequestBodyEnd",
@@ -341,7 +342,7 @@
     mockDuplexResponseBody.awaitSuccess();
 
     assertThat(listener.recordedEventTypes()).containsExactly(
-        "CallStart", "DnsStart", "DnsEnd", "ConnectStart",
+        "CallStart", "ProxySelectStart", "ProxySelectEnd", "DnsStart", "DnsEnd", "ConnectStart",
         "SecureConnectStart", "SecureConnectEnd", "ConnectEnd", "ConnectionAcquired",
         "RequestHeadersStart", "RequestHeadersEnd", "RequestBodyStart", "ResponseHeadersStart",
         "ResponseHeadersEnd", "ResponseBodyStart", "ResponseBodyEnd", "RequestHeadersStart",
diff --git a/okhttp/src/test/java/okhttp3/EventListenerTest.java b/okhttp/src/test/java/okhttp3/EventListenerTest.java
index 8cdffca101..915a6ffe81 100644
--- a/okhttp/src/test/java/okhttp3/EventListenerTest.java
+++ b/okhttp/src/test/java/okhttp3/EventListenerTest.java
@@ -48,6 +48,7 @@
 import okhttp3.mockwebserver.MockResponse;
 import okhttp3.mockwebserver.MockWebServer;
 import okhttp3.mockwebserver.SocketPolicy;
+import okhttp3.testing.PlatformRule;
 import okhttp3.tls.HandshakeCertificates;
 import okio.Buffer;
 import okio.BufferedSink;
@@ -111,7 +112,8 @@
     assertThat(response.body().string()).isEqualTo("abc");
     response.body().close();
 
-    assertThat(listener.recordedEventTypes()).containsExactly("CallStart", "DnsStart", "DnsEnd",
+    assertThat(listener.recordedEventTypes()).containsExactly("CallStart",
+        "ProxySelectStart", "ProxySelectEnd", "DnsStart", "DnsEnd",
         "ConnectStart", "ConnectEnd", "ConnectionAcquired", "RequestHeadersStart",
         "RequestHeadersEnd", "ResponseHeadersStart", "ResponseHeadersEnd", "ResponseBodyStart",
         "ResponseBodyEnd", "ConnectionReleased", "CallEnd");
@@ -141,7 +143,8 @@
 
     completionLatch.await();
 
-    assertThat(listener.recordedEventTypes()).containsExactly("CallStart", "DnsStart", "DnsEnd",
+    assertThat(listener.recordedEventTypes()).containsExactly("CallStart",
+        "ProxySelectStart", "ProxySelectEnd", "DnsStart", "DnsEnd",
         "ConnectStart", "ConnectEnd", "ConnectionAcquired", "RequestHeadersStart",
         "RequestHeadersEnd", "ResponseHeadersStart", "ResponseHeadersEnd", "ResponseBodyStart",
         "ResponseBodyEnd", "ConnectionReleased", "CallEnd");
@@ -162,7 +165,8 @@
       assertThat(expected.getMessage()).isIn("timeout", "Read timed out");
     }
 
-    assertThat(listener.recordedEventTypes()).containsExactly("CallStart", "DnsStart", "DnsEnd",
+    assertThat(listener.recordedEventTypes()).containsExactly("CallStart",
+        "ProxySelectStart", "ProxySelectEnd", "DnsStart", "DnsEnd",
         "ConnectStart", "ConnectEnd", "ConnectionAcquired", "RequestHeadersStart",
         "RequestHeadersEnd", "ResponseHeadersStart", "ResponseFailed", "ConnectionReleased",
         "CallFailed");
@@ -190,7 +194,8 @@
       assertThat(expected.getMessage()).isEqualTo("unexpected end of stream");
     }
 
-    assertThat(listener.recordedEventTypes()).containsExactly("CallStart", "DnsStart", "DnsEnd",
+    assertThat(listener.recordedEventTypes()).containsExactly("CallStart",
+        "ProxySelectStart", "ProxySelectEnd", "DnsStart", "DnsEnd",
         "ConnectStart", "ConnectEnd", "ConnectionAcquired", "RequestHeadersStart",
         "RequestHeadersEnd", "ResponseHeadersStart", "ResponseHeadersEnd", "ResponseBodyStart",
         "ResponseFailed", "ConnectionReleased", "CallFailed");
@@ -210,7 +215,8 @@
       assertThat(expected.getMessage()).isEqualTo("Canceled");
     }
 
-    assertThat(listener.recordedEventTypes()).containsExactly("CallStart", "CallFailed");
+    assertThat(listener.recordedEventTypes())
+        .containsExactly("CallStart", "ProxySelectStart", "ProxySelectEnd", "CallFailed");
   }
 
   private void assertSuccessfulEventOrder(Matcher<Response> responseMatcher) throws IOException {
@@ -225,7 +231,8 @@ private void assertSuccessfulEventOrder(Matcher<Response> responseMatcher) throw
     assumeThat(response, responseMatcher);
 
     assertThat(listener.recordedEventTypes()).containsExactly(
-        "CallStart", "DnsStart", "DnsEnd", "ConnectStart",
+        "CallStart", "ProxySelectStart", "ProxySelectEnd",
+        "DnsStart", "DnsEnd", "ConnectStart",
         "SecureConnectStart", "SecureConnectEnd", "ConnectEnd", "ConnectionAcquired",
         "RequestHeadersStart", "RequestHeadersEnd", "ResponseHeadersStart", "ResponseHeadersEnd",
         "ResponseBodyStart", "ResponseBodyEnd", "ConnectionReleased", "CallEnd");
@@ -249,7 +256,8 @@ private void assertSuccessfulEventOrder(Matcher<Response> responseMatcher) throw
     Response response = call.execute();
     response.close();
 
-    assertThat(listener.recordedEventTypes()).containsExactly("CallStart", "ConnectionAcquired",
+    assertThat(listener.recordedEventTypes()).containsExactly("CallStart",
+        "ProxySelectStart", "ProxySelectEnd", "ConnectionAcquired",
         "RequestHeadersStart", "RequestHeadersEnd", "ResponseHeadersStart", "ResponseHeadersEnd",
         "ResponseBodyStart", "ResponseBodyEnd", "ConnectionReleased", "CallEnd");
   }
@@ -910,7 +918,8 @@ private void responseBodyFail(Protocol expectedProtocol) throws IOException {
     Response response = call.execute();
     response.body().close();
 
-    assertThat(listener.recordedEventTypes()).containsExactly("CallStart", "DnsStart", "DnsEnd",
+    assertThat(listener.recordedEventTypes()).containsExactly("CallStart",
+        "ProxySelectStart", "ProxySelectEnd", "DnsStart", "DnsEnd",
         "ConnectStart", "ConnectEnd", "ConnectionAcquired", "RequestHeadersStart",
         "RequestHeadersEnd", "ResponseHeadersStart", "ResponseHeadersEnd", "ResponseBodyStart",
         "ResponseBodyEnd", "ConnectionReleased", "CallEnd");
@@ -927,7 +936,8 @@ private void responseBodyFail(Protocol expectedProtocol) throws IOException {
     Response response = call.execute();
     response.body().close();
 
-    assertThat(listener.recordedEventTypes()).containsExactly("CallStart", "DnsStart", "DnsEnd",
+    assertThat(listener.recordedEventTypes()).containsExactly("CallStart",
+        "ProxySelectStart", "ProxySelectEnd", "DnsStart", "DnsEnd",
         "ConnectStart", "ConnectEnd", "ConnectionAcquired", "RequestHeadersStart",
         "RequestHeadersEnd", "ResponseHeadersStart", "ResponseHeadersEnd", "ResponseBodyStart",
         "ResponseBodyEnd", "ConnectionReleased", "CallEnd");
@@ -945,7 +955,8 @@ private void responseBodyFail(Protocol expectedProtocol) throws IOException {
     Response response = call.execute();
     response.body().close();
 
-    assertThat(listener.recordedEventTypes()).containsExactly("CallStart", "DnsStart", "DnsEnd",
+    assertThat(listener.recordedEventTypes()).containsExactly("CallStart",
+        "ProxySelectStart", "ProxySelectEnd", "DnsStart", "DnsEnd",
         "ConnectStart", "ConnectEnd", "ConnectionAcquired", "RequestHeadersStart",
         "RequestHeadersEnd", "ResponseHeadersStart", "ResponseHeadersEnd", "ResponseBodyStart",
         "ResponseBodyEnd", "ConnectionReleased", "CallEnd");
@@ -1067,7 +1078,7 @@ private void writeChunk(BufferedSink sink) throws IOException {
     }
 
     assertThat(listener.recordedEventTypes()).containsExactly(
-        "CallStart", "DnsStart", "DnsEnd", "ConnectStart",
+        "CallStart", "ProxySelectStart", "ProxySelectEnd", "DnsStart", "DnsEnd", "ConnectStart",
         "ConnectEnd", "ConnectionAcquired", "RequestHeadersStart", "RequestHeadersEnd",
         "RequestBodyStart", "RequestFailed", "ConnectionReleased", "CallFailed");
   }
@@ -1128,7 +1139,8 @@ private void writeChunk(BufferedSink sink) throws IOException {
     assertThat(response.body().string()).isEqualTo("abc");
     response.body().close();
 
-    assertThat(listener.recordedEventTypes()).containsExactly("CallStart", "DnsStart", "DnsEnd",
+    assertThat(listener.recordedEventTypes()).containsExactly("CallStart",
+        "ProxySelectStart", "ProxySelectEnd", "DnsStart", "DnsEnd",
         "ConnectStart", "ConnectEnd", "ConnectionAcquired", "RequestHeadersStart",
         "RequestHeadersEnd", "ResponseHeadersStart", "ResponseHeadersEnd", "ResponseBodyStart",
         "ResponseBodyEnd", "ConnectionReleased", "CallEnd");
@@ -1168,7 +1180,8 @@ private void enableTlsWithTunnel(boolean tunnelProxy) {
     Call call = client.newCall(new Request.Builder().url(server.url("/")).build());
     call.execute();
 
-    assertThat(listener.recordedEventTypes()).containsExactly("CallStart", "DnsStart", "DnsEnd",
+    assertThat(listener.recordedEventTypes()).containsExactly("CallStart",
+        "ProxySelectStart", "ProxySelectEnd", "DnsStart", "DnsEnd",
         "ConnectStart", "ConnectEnd", "ConnectionAcquired", "RequestHeadersStart",
         "RequestHeadersEnd", "ResponseHeadersStart", "ResponseHeadersEnd", "ResponseBodyStart",
         "ResponseBodyEnd", "RequestHeadersStart", "RequestHeadersEnd", "ResponseHeadersStart",
@@ -1188,10 +1201,12 @@ public void redirectUsingNewConnectionEventSequence() throws IOException {
     Call call = client.newCall(new Request.Builder().url(server.url("/")).build());
     call.execute();
 
-    assertThat(listener.recordedEventTypes()).containsExactly("CallStart", "DnsStart", "DnsEnd",
+    assertThat(listener.recordedEventTypes()).containsExactly("CallStart",
+        "ProxySelectStart", "ProxySelectEnd", "DnsStart", "DnsEnd",
         "ConnectStart", "ConnectEnd", "ConnectionAcquired", "RequestHeadersStart",
         "RequestHeadersEnd", "ResponseHeadersStart", "ResponseHeadersEnd", "ResponseBodyStart",
-        "ResponseBodyEnd", "ConnectionReleased", "DnsStart", "DnsEnd", "ConnectStart", "ConnectEnd",
+        "ResponseBodyEnd", "ConnectionReleased", "ProxySelectStart", "ProxySelectEnd",
+        "DnsStart", "DnsEnd", "ConnectStart", "ConnectEnd",
         "ConnectionAcquired", "RequestHeadersStart", "RequestHeadersEnd", "ResponseHeadersStart",
         "ResponseHeadersEnd", "ResponseBodyStart", "ResponseBodyEnd", "ConnectionReleased",
         "CallEnd");
@@ -1214,7 +1229,8 @@ public void redirectUsingNewConnectionEventSequence() throws IOException {
     Response response = call.execute();
     assertThat(response.body().string()).isEqualTo("b");
 
-    assertThat(listener.recordedEventTypes()).containsExactly("CallStart", "DnsStart", "DnsEnd",
+    assertThat(listener.recordedEventTypes()).containsExactly("CallStart",
+        "ProxySelectStart", "ProxySelectEnd", "DnsStart", "DnsEnd",
         "ConnectStart", "ConnectEnd", "ConnectionAcquired", "RequestHeadersStart",
         "RequestHeadersEnd", "ResponseHeadersStart", "ResponseHeadersEnd", "ResponseBodyStart",
         "ResponseBodyEnd", "RequestHeadersStart", "RequestHeadersEnd", "ResponseHeadersStart",
@@ -1258,7 +1274,7 @@ public void redirectUsingNewConnectionEventSequence() throws IOException {
     call.execute();
 
     assertThat(listener.recordedEventTypes()).containsExactly(
-        "CallStart", "DnsStart", "DnsEnd", "ConnectStart",
+        "CallStart", "ProxySelectStart", "ProxySelectEnd", "DnsStart", "DnsEnd", "ConnectStart",
         "ConnectEnd", "ConnectionAcquired", "RequestHeadersStart", "RequestHeadersEnd",
         "ResponseHeadersStart", "RequestBodyStart", "RequestBodyEnd", "ResponseHeadersEnd",
         "ResponseBodyStart", "ResponseBodyEnd", "ConnectionReleased", "CallEnd");
diff --git a/okhttp/src/test/java/okhttp3/HeadersTest.java b/okhttp/src/test/java/okhttp3/HeadersTest.java
index 38756be337..4e10c46c12 100644
--- a/okhttp/src/test/java/okhttp3/HeadersTest.java
+++ b/okhttp/src/test/java/okhttp3/HeadersTest.java
@@ -39,7 +39,7 @@
 import static org.junit.Assert.fail;
 
 public final class HeadersTest {
-  @Test public void readNameValueBlockDropsForbiddenHeadersHttp2() throws IOException {
+  @Test public void readNameValueBlockDropsForbiddenHeadersHttp2() {
     Headers headerBlock = Headers.of(
         ":status", "200 OK",
         ":version", "HTTP/1.1",
diff --git a/okhttp/src/test/java/okhttp3/InterceptorTest.java b/okhttp/src/test/java/okhttp3/InterceptorTest.java
index 77c9a7811d..5428f06acd 100644
--- a/okhttp/src/test/java/okhttp3/InterceptorTest.java
+++ b/okhttp/src/test/java/okhttp3/InterceptorTest.java
@@ -16,6 +16,7 @@
 package okhttp3;
 
 import java.io.IOException;
+import java.net.InetAddress;
 import java.net.ServerSocket;
 import java.net.Socket;
 import java.net.SocketTimeoutException;
@@ -684,7 +685,8 @@ private void interceptorThrowsRuntimeExceptionAsynchronous(boolean network) thro
       return chain.proceed(chain.request());
     };
 
-    ServerSocket serverSocket = new ServerSocket(0, 1);
+    InetAddress localhost = InetAddress.getLoopbackAddress();
+    ServerSocket serverSocket = new ServerSocket(0, 1, localhost);
     // Fill backlog queue with this request so subsequent requests will be blocked.
     new Socket().connect(serverSocket.getLocalSocketAddress());
 
diff --git a/okhttp/src/test/java/okhttp3/KotlinSourceModernTest.kt b/okhttp/src/test/java/okhttp3/KotlinSourceModernTest.kt
index 816471967e..36d1da59b5 100644
--- a/okhttp/src/test/java/okhttp3/KotlinSourceModernTest.kt
+++ b/okhttp/src/test/java/okhttp3/KotlinSourceModernTest.kt
@@ -90,7 +90,8 @@ import javax.net.ssl.X509TrustManager
     "UNUSED_VARIABLE",
     "VARIABLE_WITH_REDUNDANT_INITIALIZER",
     "RedundantLambdaArrow",
-    "RedundantExplicitType"
+    "RedundantExplicitType",
+    "IMPLICIT_NOTHING_AS_TYPE_PARAMETER"
 )
 class KotlinSourceModernTest {
   @Test @Ignore
@@ -256,7 +257,6 @@ class KotlinSourceModernTest {
     builder = builder.allEnabledTlsVersions()
     builder = builder.tlsVersions(TlsVersion.TLS_1_3)
     builder = builder.tlsVersions("", "")
-    builder = builder.supportsTlsExtensions(false)
     val connectionSpec: ConnectionSpec = builder.build()
   }
 
@@ -480,7 +480,6 @@ class KotlinSourceModernTest {
     interceptor = HttpLoggingInterceptor(HttpLoggingInterceptor.Logger.DEFAULT)
     interceptor.redactHeader("")
     interceptor.level = HttpLoggingInterceptor.Level.BASIC
-    interceptor.setLevel(HttpLoggingInterceptor.Level.BASIC)
     var level: HttpLoggingInterceptor.Level = interceptor.level
     interceptor.intercept(newInterceptorChain())
   }
@@ -735,8 +734,8 @@ class KotlinSourceModernTest {
     mockWebServer.noClientAuth()
     mockWebServer.requestClientAuth()
     mockWebServer.requireClientAuth()
-    var request: RecordedRequest = mockWebServer.takeRequest()
-    request = mockWebServer.takeRequest(0L, TimeUnit.SECONDS)
+    val request: RecordedRequest = mockWebServer.takeRequest()
+    val nullableRequest: RecordedRequest? = mockWebServer.takeRequest(0L, TimeUnit.SECONDS)
     var requestCount: Int = mockWebServer.requestCount
     mockWebServer.enqueue(MockResponse())
     mockWebServer.start()
diff --git a/okhttp/src/test/java/okhttp3/OkHttpClientTest.java b/okhttp/src/test/java/okhttp3/OkHttpClientTest.java
index 59747ee7ae..1e4c4b84c4 100644
--- a/okhttp/src/test/java/okhttp3/OkHttpClientTest.java
+++ b/okhttp/src/test/java/okhttp3/OkHttpClientTest.java
@@ -17,10 +17,15 @@
 
 import java.net.CookieHandler;
 import java.net.CookieManager;
+import java.net.Proxy;
 import java.net.ProxySelector;
 import java.net.ResponseCache;
+import java.util.AbstractList;
+import java.util.ArrayList;
+import java.util.List;
 import java.util.concurrent.TimeUnit;
 import javax.net.ssl.SSLSocketFactory;
+import okhttp3.internal.proxy.NullProxySelector;
 import okhttp3.mockwebserver.MockResponse;
 import okhttp3.mockwebserver.MockWebServer;
 import org.junit.After;
@@ -29,6 +34,7 @@
 
 import static java.util.Arrays.asList;
 import static org.assertj.core.api.Assertions.assertThat;
+import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.fail;
 
 public final class OkHttpClientTest {
@@ -113,12 +119,14 @@
     assertThat(a.dispatcher()).isNotNull();
     assertThat(a.connectionPool()).isNotNull();
     assertThat(a.sslSocketFactory()).isNotNull();
+    assertThat(a.x509TrustManager()).isNotNull();
 
     // Multiple clients share the instances.
     OkHttpClient b = client.newBuilder().build();
     assertThat(b.dispatcher()).isSameAs(a.dispatcher());
     assertThat(b.connectionPool()).isSameAs(a.connectionPool());
     assertThat(b.sslSocketFactory()).isSameAs(a.sslSocketFactory());
+    assertThat(b.x509TrustManager()).isSameAs(a.x509TrustManager());
   }
 
   @Test public void setProtocolsRejectsHttp10() throws Exception {
@@ -239,4 +247,58 @@
     } catch (IllegalStateException expected) {
     }
   }
+
+  @Test public void nullHostileProtocolList() {
+    List<Protocol> nullHostileProtocols = new AbstractList<Protocol>() {
+      @Override public boolean contains(Object o) {
+        if (o == null) throw new NullPointerException();
+        return super.contains(o);
+      }
+
+      @Override public int indexOf(Object o) {
+        if (o == null) throw new NullPointerException();
+        return super.indexOf(o);
+      }
+
+      @Override public Protocol get(int index) {
+        if (index != 0) throw new IndexOutOfBoundsException();
+        return Protocol.HTTP_1_1;
+      }
+
+      @Override public int size() {
+        return 1;
+      }
+    };
+
+    OkHttpClient client = new OkHttpClient.Builder()
+        .protocols(nullHostileProtocols)
+        .build();
+    assertEquals(asList(Protocol.HTTP_1_1), client.protocols());
+  }
+
+  @Test public void nullProtocolInList() {
+    List<Protocol> protocols = new ArrayList<>();
+    protocols.add(Protocol.HTTP_1_1);
+    protocols.add(null);
+    try {
+      new OkHttpClient.Builder().protocols(protocols);
+      fail();
+    } catch (IllegalArgumentException expected) {
+      assertThat(expected.getMessage()).isEqualTo(("protocols must not contain null"));
+    }
+  }
+
+  @Test public void testProxyDefaults() {
+    OkHttpClient client = new OkHttpClient.Builder().build();
+    assertThat(client.proxy()).isNull();
+    assertThat(client.proxySelector()).isNotInstanceOf(NullProxySelector.class);
+
+    client = new OkHttpClient.Builder().proxy(Proxy.NO_PROXY).build();
+    assertThat(client.proxy()).isSameAs(Proxy.NO_PROXY);
+    assertThat(client.proxySelector()).isInstanceOf(NullProxySelector.class);
+
+    client = new OkHttpClient.Builder().proxySelector(new FakeProxySelector()).build();
+    assertThat(client.proxy()).isNull();
+    assertThat(client.proxySelector()).isInstanceOf(FakeProxySelector.class);
+  }
 }
diff --git a/okhttp/src/test/java/okhttp3/PublicInternalApiTest.java b/okhttp/src/test/java/okhttp3/PublicInternalApiTest.java
new file mode 100644
index 0000000000..7421931867
--- /dev/null
+++ b/okhttp/src/test/java/okhttp3/PublicInternalApiTest.java
@@ -0,0 +1,45 @@
+/*
+ * Copyright (C) 2019 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3;
+
+import okhttp3.internal.http.HttpHeaders;
+import okhttp3.internal.http.HttpMethod;
+import org.junit.Test;
+
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertTrue;
+
+@SuppressWarnings("ALL") public class PublicInternalApiTest {
+  @Test public void permitsRequestBody() {
+    assertTrue(HttpMethod.permitsRequestBody("POST"));
+    assertFalse(HttpMethod.permitsRequestBody("GET"));
+  }
+
+  @Test public void requiresRequestBody() {
+    assertTrue(HttpMethod.requiresRequestBody("PUT"));
+    assertFalse(HttpMethod.requiresRequestBody("GET"));
+  }
+
+  @Test public void hasBody() {
+    Request request = new Request.Builder().url("http://example.com").build();
+    Response response = new Response.Builder().code(200)
+        .message("OK")
+        .request(request)
+        .protocol(Protocol.HTTP_2)
+        .build();
+    assertTrue(HttpHeaders.hasBody(response));
+  }
+}
diff --git a/okhttp/src/test/java/okhttp3/RecordingEventListener.java b/okhttp/src/test/java/okhttp3/RecordingEventListener.java
index 47d3be7a14..dd2b5d68c9 100644
--- a/okhttp/src/test/java/okhttp3/RecordingEventListener.java
+++ b/okhttp/src/test/java/okhttp3/RecordingEventListener.java
@@ -81,6 +81,15 @@ private void logEvent(CallEvent e) {
     eventSequence.offer(e);
   }
 
+  @Override public void proxySelectStart(Call call, HttpUrl url) {
+    logEvent(new ProxySelectStart(call, url));
+  }
+
+  @Override public void proxySelectEnd(Call call, HttpUrl url,
+      List<Proxy> proxies) {
+    logEvent(new ProxySelectEnd(call, url, proxies));
+  }
+
   @Override public void dnsStart(Call call, String domainName) {
     logEvent(new DnsStart(call, domainName));
   }
@@ -208,6 +217,24 @@ public String getName() {
     }
   }
 
+  static final class ProxySelectStart extends CallEvent {
+    final HttpUrl url;
+
+    ProxySelectStart(Call call, HttpUrl url) {
+      super(call, url);
+      this.url = url;
+    }
+  }
+
+  static final class ProxySelectEnd extends CallEvent {
+    final HttpUrl url;
+
+    ProxySelectEnd(Call call, HttpUrl url, List<Proxy> proxies) {
+      super(call, url, proxies);
+      this.url = url;
+    }
+  }
+
   static final class DnsStart extends CallEvent {
     final String domainName;
 
diff --git a/okhttp/src/test/java/okhttp3/ResponseBodyTest.java b/okhttp/src/test/java/okhttp3/ResponseBodyTest.java
index b994bd3c0d..2ff9851268 100644
--- a/okhttp/src/test/java/okhttp3/ResponseBodyTest.java
+++ b/okhttp/src/test/java/okhttp3/ResponseBodyTest.java
@@ -330,6 +330,89 @@
     }
   }
 
+  @Test public void byteStringEmpty() throws IOException {
+    ResponseBody body = body("");
+    assertThat(body.byteString()).isEqualTo(ByteString.EMPTY);
+  }
+
+  @Test public void byteStringSeesBom() throws IOException {
+    ResponseBody body = body("efbbbf68656c6c6f");
+    ByteString actual = body.byteString();
+    ByteString expected = ByteString.decodeHex("efbbbf68656c6c6f");
+    assertThat(actual).isEqualTo(expected);
+  }
+
+  @Test public void byteStringClosesUnderlyingSource() throws IOException {
+    final AtomicBoolean closed = new AtomicBoolean();
+    ResponseBody body = new ResponseBody() {
+      @Override public MediaType contentType() {
+        return null;
+      }
+
+      @Override public long contentLength() {
+        return 5;
+      }
+
+      @Override public BufferedSource source() {
+        Buffer source = new Buffer().writeUtf8("hello");
+        return Okio.buffer(new ForwardingSource(source) {
+          @Override public void close() throws IOException {
+            closed.set(true);
+            super.close();
+          }
+        });
+      }
+    };
+    assertThat(body.byteString().size()).isEqualTo(5);
+    assertThat(closed.get()).isTrue();
+  }
+
+  @Test public void byteStringThrowsWhenLengthsDisagree() {
+    ResponseBody body = new ResponseBody() {
+      @Override public MediaType contentType() {
+        return null;
+      }
+
+      @Override public long contentLength() {
+        return 10;
+      }
+
+      @Override public BufferedSource source() {
+        return new Buffer().writeUtf8("hello");
+      }
+    };
+    try {
+      body.byteString();
+      fail();
+    } catch (IOException e) {
+      assertThat(e.getMessage()).isEqualTo(
+          "Content-Length (10) and stream length (5) disagree");
+    }
+  }
+
+  @Test public void byteStringThrowsMoreThanIntMaxValue() {
+    ResponseBody body = new ResponseBody() {
+      @Override public MediaType contentType() {
+        return null;
+      }
+
+      @Override public long contentLength() {
+        return Integer.MAX_VALUE + 1L;
+      }
+
+      @Override public BufferedSource source() {
+        throw new AssertionError();
+      }
+    };
+    try {
+      body.byteString();
+      fail();
+    } catch (IOException e) {
+      assertThat(e.getMessage()).isEqualTo(
+          "Cannot buffer entire body for content length: 2147483648");
+    }
+  }
+
   @Test public void byteStreamEmpty() throws IOException {
     ResponseBody body = body("");
     InputStream bytes = body.byteStream();
diff --git a/okhttp/src/test/java/okhttp3/ResponseTest.java b/okhttp/src/test/java/okhttp3/ResponseTest.java
index 5854712302..3fca5712a7 100644
--- a/okhttp/src/test/java/okhttp3/ResponseTest.java
+++ b/okhttp/src/test/java/okhttp3/ResponseTest.java
@@ -24,6 +24,7 @@
 import org.junit.Test;
 
 import static org.assertj.core.api.Assertions.assertThat;
+import static org.assertj.core.api.Assertions.assertThatThrownBy;
 import static org.junit.Assert.fail;
 
 public final class ResponseTest {
@@ -61,6 +62,16 @@
     assertThat(p2.string()).isEqualTo("ab");
   }
 
+  @Test public void negativeStatusCodeThrowsIllegalStateException() {
+    assertThatThrownBy(() -> newResponse(responseBody("set status code -1"), -1))
+        .isInstanceOf(IllegalStateException.class);
+  }
+
+  @Test public void zeroStatusCodeIsValid() {
+    Response response = newResponse(responseBody("set status code 0"), 0);
+    assertThat(response.code()).isEqualTo(0);
+  }
+
   /**
    * Returns a new response body that refuses to be read once it has been closed. This is true of
    * most {@link BufferedSource} instances, but not of {@link Buffer}.
@@ -89,12 +100,16 @@ private ResponseBody responseBody(String content) {
   }
 
   private Response newResponse(ResponseBody responseBody) {
+    return newResponse(responseBody, 200);
+  }
+
+  private Response newResponse(ResponseBody responseBody, int code) {
     return new Response.Builder()
         .request(new Request.Builder()
             .url("https://example.com/")
             .build())
         .protocol(Protocol.HTTP_1_1)
-        .code(200)
+        .code(code)
         .message("OK")
         .body(responseBody)
         .build();
diff --git a/okhttp/src/test/java/okhttp3/URLConnectionTest.java b/okhttp/src/test/java/okhttp3/URLConnectionTest.java
index d0d26ca6cd..656122295c 100644
--- a/okhttp/src/test/java/okhttp3/URLConnectionTest.java
+++ b/okhttp/src/test/java/okhttp3/URLConnectionTest.java
@@ -68,6 +68,8 @@
 import okhttp3.mockwebserver.MockWebServer;
 import okhttp3.mockwebserver.RecordedRequest;
 import okhttp3.mockwebserver.SocketPolicy;
+import okhttp3.testing.Flaky;
+import okhttp3.testing.PlatformRule;
 import okhttp3.tls.HandshakeCertificates;
 import okio.Buffer;
 import okio.BufferedSink;
@@ -684,7 +686,10 @@ private void connectViaHttpsReusingConnections(boolean rebuildClient) throws Exc
    *
    * http://code.google.com/p/android/issues/detail?id=13178
    */
+  @Flaky
   @Test public void connectViaHttpsToUntrustedServer() throws Exception {
+    // Flaky https://github.com/square/okhttp/issues/5222
+
     server.useHttps(handshakeCertificates.sslSocketFactory(), false);
     server.enqueue(new MockResponse()); // unused
 
@@ -692,7 +697,10 @@ private void connectViaHttpsReusingConnections(boolean rebuildClient) throws Exc
       getResponse(newRequest("/foo"));
       fail();
     } catch (SSLHandshakeException expected) {
-      assertThat(expected.getCause()).isInstanceOf(CertificateException.class);
+      // Allow conscrypt to fail in different ways
+      if (!platform.isConscrypt()) {
+        assertThat(expected.getCause()).isInstanceOf(CertificateException.class);
+      }
     }
     assertThat(server.getRequestCount()).isEqualTo(0);
   }
diff --git a/okhttp/src/test/java/okhttp3/WholeOperationTimeoutTest.java b/okhttp/src/test/java/okhttp3/WholeOperationTimeoutTest.java
index 3e175f8174..bf8b54343a 100644
--- a/okhttp/src/test/java/okhttp3/WholeOperationTimeoutTest.java
+++ b/okhttp/src/test/java/okhttp3/WholeOperationTimeoutTest.java
@@ -23,6 +23,7 @@
 import java.util.concurrent.atomic.AtomicReference;
 import okhttp3.mockwebserver.MockResponse;
 import okhttp3.mockwebserver.MockWebServer;
+import okhttp3.testing.Flaky;
 import okio.BufferedSink;
 import org.junit.Before;
 import org.junit.Rule;
@@ -286,7 +287,10 @@ public void timeoutFollowingRedirectOnNewConnection() throws Exception {
     }
   }
 
+  @Flaky
   @Test public void noTimeout() throws Exception {
+    // Flaky https://github.com/square/okhttp/issues/5304
+
     server.enqueue(new MockResponse()
         .setHeadersDelay(250, TimeUnit.MILLISECONDS)
         .setBody(BIG_ENOUGH_BODY));
@@ -297,7 +301,7 @@ public void timeoutFollowingRedirectOnNewConnection() throws Exception {
         .build();
 
     Call call = client.newCall(request);
-    call.timeout().timeout(1000, TimeUnit.MILLISECONDS);
+    call.timeout().timeout(2000, TimeUnit.MILLISECONDS);
     Response response = call.execute();
     Thread.sleep(250);
     response.body().source().readUtf8();
diff --git a/okhttp/src/test/java/okhttp3/internal/cache/DiskLruCacheTest.java b/okhttp/src/test/java/okhttp3/internal/cache/DiskLruCacheTest.java
index 8a4754649b..a37395f27b 100644
--- a/okhttp/src/test/java/okhttp3/internal/cache/DiskLruCacheTest.java
+++ b/okhttp/src/test/java/okhttp3/internal/cache/DiskLruCacheTest.java
@@ -1643,6 +1643,25 @@ private void createNewCacheWithSize(int maxSize) throws IOException {
     assertAbsent("k1");
   }
 
+  @Test public void dontRemoveUnfinishedEntryWhenCreatingSnapshot() throws Exception {
+    DiskLruCache.Editor creator = cache.edit("k1");
+    setString(creator, 0, "ABC");
+    setString(creator, 1, "DE");
+
+    assertThat(creator.newSource(0)).isNull();
+    assertThat(creator.newSource(1)).isNull();
+
+    Iterator<DiskLruCache.Snapshot> snapshotWhileEditing = cache.snapshots();
+    assertThat(snapshotWhileEditing.hasNext()).isFalse(); // entry still is being created/edited
+    creator.commit();
+
+    Iterator<DiskLruCache.Snapshot> snapshotAfterCommit = cache.snapshots();
+
+    assertThat(snapshotAfterCommit.hasNext())
+        .withFailMessage("Entry has been removed during creation.")
+        .isTrue();
+  }
+
   private void assertJournalEquals(String... expectedBodyLines) throws Exception {
     List<String> expectedLines = new ArrayList<>();
     expectedLines.add(MAGIC);
diff --git a/okhttp/src/test/java/okhttp3/internal/connection/ConnectionPoolTest.java b/okhttp/src/test/java/okhttp3/internal/connection/ConnectionPoolTest.java
index c756b09056..e9908f89f2 100644
--- a/okhttp/src/test/java/okhttp3/internal/connection/ConnectionPoolTest.java
+++ b/okhttp/src/test/java/okhttp3/internal/connection/ConnectionPoolTest.java
@@ -179,6 +179,27 @@
     assertThat(c1.getNoNewExchanges()).isTrue();
   }
 
+  @Test public void interruptStopsThread() throws Exception {
+    RealConnectionPool pool = new RealConnectionPool(2, 100L, TimeUnit.NANOSECONDS);
+    RealConnection c1 = newConnection(pool, routeA1, Long.MAX_VALUE);
+
+    assertThat(pool.getCleanupRunning()).isTrue();
+
+    Thread.sleep(100);
+
+    Thread[] threads = new Thread[Thread.activeCount() * 2];
+    Thread.enumerate(threads);
+    for (Thread t: threads) {
+      if (t != null && t.getName().equals("OkHttp ConnectionPool")) {
+        t.interrupt();
+      }
+    }
+
+    Thread.sleep(100);
+
+    assertThat(pool.getCleanupRunning()).isFalse();
+  }
+
   /** Use a helper method so there's no hidden reference remaining on the stack. */
   private void allocateAndLeakAllocation(ConnectionPool pool, RealConnection connection) {
     synchronized (RealConnectionPool.Companion.get(pool)) {
diff --git a/okhttp/src/test/java/okhttp3/internal/http2/HttpOverHttp2Test.java b/okhttp/src/test/java/okhttp3/internal/http2/HttpOverHttp2Test.java
index a543accf42..0ed99bff2f 100644
--- a/okhttp/src/test/java/okhttp3/internal/http2/HttpOverHttp2Test.java
+++ b/okhttp/src/test/java/okhttp3/internal/http2/HttpOverHttp2Test.java
@@ -44,7 +44,6 @@
 import okhttp3.MediaType;
 import okhttp3.OkHttpClient;
 import okhttp3.OkHttpClientTestRule;
-import okhttp3.PlatformRule;
 import okhttp3.Protocol;
 import okhttp3.RecordingCookieJar;
 import okhttp3.RecordingHostnameVerifier;
@@ -64,18 +63,21 @@
 import okhttp3.mockwebserver.QueueDispatcher;
 import okhttp3.mockwebserver.RecordedRequest;
 import okhttp3.mockwebserver.SocketPolicy;
+import okhttp3.testing.Flaky;
+import okhttp3.testing.PlatformRule;
 import okhttp3.tls.HandshakeCertificates;
 import okio.Buffer;
 import okio.BufferedSink;
 import okio.GzipSink;
 import okio.Okio;
-import org.jetbrains.annotations.NotNull;
 import org.junit.After;
 import org.junit.Before;
 import org.junit.Ignore;
 import org.junit.Rule;
 import org.junit.Test;
+import org.junit.rules.RuleChain;
 import org.junit.rules.TemporaryFolder;
+import org.junit.rules.TestRule;
 import org.junit.rules.Timeout;
 import org.junit.runner.RunWith;
 import org.junit.runners.Parameterized;
@@ -95,7 +97,11 @@
 
 /** Test how HTTP/2 interacts with HTTP features. */
 @RunWith(Parameterized.class)
+@Flaky
 public final class HttpOverHttp2Test {
+  // Flaky https://github.com/square/okhttp/issues/4632
+  // Flaky https://github.com/square/okhttp/issues/4633
+
   private static final Logger http2Logger = Logger.getLogger(Http2.class.getName());
   private static final HandshakeCertificates handshakeCertificates = localhost();
 
@@ -104,11 +110,12 @@
     return asList(Protocol.H2_PRIOR_KNOWLEDGE, Protocol.HTTP_2);
   }
 
-  @Rule public final PlatformRule platform = new PlatformRule();
+  private PlatformRule platform = new PlatformRule();
+  @Rule public final TestRule chain =
+      RuleChain.outerRule(platform).around(new Timeout(5, SECONDS));
   @Rule public final TemporaryFolder tempDir = new TemporaryFolder();
   @Rule public final MockWebServer server = new MockWebServer();
   @Rule public final OkHttpClientTestRule clientTestRule = new OkHttpClientTestRule();
-  @Rule public final Timeout timeout = new Timeout(5, SECONDS);
 
   private OkHttpClient client;
   private Cache cache;
@@ -596,16 +603,16 @@ private void waitForDataFrames(int dataLength) throws Exception {
         .build();
     Call call1 = client1
         .newCall(new Request.Builder()
-        .url(server.url("/"))
-        .build());
+            .url(server.url("/"))
+            .build());
 
     OkHttpClient client2 = client.newBuilder()
         .readTimeout(200, MILLISECONDS)
         .build();
     Call call2 = client2
         .newCall(new Request.Builder()
-        .url(server.url("/"))
-        .build());
+            .url(server.url("/"))
+            .build());
 
     Response response1 = call1.execute();
     assertThat(response1.body().string()).isEqualTo("A");
@@ -900,26 +907,26 @@ private void waitForDataFrames(int dataLength) throws Exception {
     QueueDispatcher dispatcher =
         new RespondAfterCancelDispatcher(responseDequeuedLatches, requestCanceledLatches);
     dispatcher.enqueueResponse(new MockResponse()
-            .setBodyDelay(10, TimeUnit.SECONDS)
-            .setBody("abc"));
+        .setBodyDelay(10, TimeUnit.SECONDS)
+        .setBody("abc"));
     dispatcher.enqueueResponse(new MockResponse()
-            .setBodyDelay(10, TimeUnit.SECONDS)
-            .setBody("def"));
+        .setBodyDelay(10, TimeUnit.SECONDS)
+        .setBody("def"));
     dispatcher.enqueueResponse(new MockResponse()
-            .setBody("ghi"));
+        .setBody("ghi"));
     server.setDispatcher(dispatcher);
 
     client = client.newBuilder()
-            .dns(new DoubleInetAddressDns())
-            .build();
+        .dns(new DoubleInetAddressDns())
+        .build();
 
     callAndCancel(0, responseDequeuedLatches.get(0), requestCanceledLatches.get(0));
     callAndCancel(1, responseDequeuedLatches.get(1), requestCanceledLatches.get(1));
 
     // Make a third request to ensure the connection is reused.
     Call call = client.newCall(new Request.Builder()
-            .url(server.url("/"))
-            .build());
+        .url(server.url("/"))
+        .build());
     Response response = call.execute();
     assertThat(response.body().string()).isEqualTo("ghi");
     assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(2);
@@ -1224,7 +1231,13 @@ private void noRecoveryFromErrorWithRetryDisabled(ErrorCode errorCode) throws Ex
         (long) 1);
   }
 
+  @Flaky
   @Test public void missingPongsFailsConnection() throws Exception {
+    if (protocol == Protocol.HTTP_2) {
+      // https://github.com/square/okhttp/issues/5221
+      platform.expectFailureFromJdkVersion(12);
+    }
+
     // Ping every 500 ms, starting at 500 ms.
     client = client.newBuilder()
         .readTimeout(10, TimeUnit.SECONDS) // Confirm we fail before the read timeout.
@@ -1261,7 +1274,7 @@ private void noRecoveryFromErrorWithRetryDisabled(ErrorCode errorCode) throws Ex
   }
 
   private String firstFrame(List<String> logs, String type) {
-    for (String log: logs) {
+    for (String log : logs) {
       if (log.contains(type)) {
         return log;
       }
@@ -1271,7 +1284,7 @@ private String firstFrame(List<String> logs, String type) {
 
   private int countFrames(List<String> logs, String message) {
     int result = 0;
-    for (String log: logs) {
+    for (String log : logs) {
       if (log.equals(message)) {
         result++;
       }
@@ -1397,7 +1410,9 @@ private int countFrames(List<String> logs, String message) {
     assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(0);
   }
 
+  @Flaky
   @Test public void responseHeadersAfterGoaway() throws Exception {
+    // Flaky https://github.com/square/okhttp/issues/4836
     server.enqueue(new MockResponse()
         .setHeadersDelay(1, SECONDS)
         .setBody("ABC"));
@@ -1410,6 +1425,7 @@ private int countFrames(List<String> logs, String message) {
       @Override public void onResponse(Call call, Response response) throws IOException {
         bodies.add(response.body().string());
       }
+
       @Override public void onFailure(Call call, IOException e) {
         System.out.println(e);
       }
@@ -1586,12 +1602,12 @@ public void shutdownAfterLateCoalescing() throws Exception {
     client = client.newBuilder().eventListener(new EventListener() {
       int callCount;
 
-      @Override public void connectionAcquired(@NotNull Call call, @NotNull Connection connection) {
+      @Override public void connectionAcquired(Call call, Connection connection) {
         try {
           if (callCount++ == 1) {
             server.shutdown();
           }
-        } catch(IOException e) {
+        } catch (IOException e) {
           fail();
         }
       }
diff --git a/okhttp/src/test/java/okhttp3/internal/http2/MockHttp2Peer.java b/okhttp/src/test/java/okhttp3/internal/http2/MockHttp2Peer.java
index ec26954acb..a773bf1948 100644
--- a/okhttp/src/test/java/okhttp3/internal/http2/MockHttp2Peer.java
+++ b/okhttp/src/test/java/okhttp3/internal/http2/MockHttp2Peer.java
@@ -183,8 +183,12 @@ public Socket openSocket() throws IOException {
 
   @Override public synchronized void close() throws IOException {
     executor.shutdown();
-    closeQuietly(socket);
-    closeQuietly(serverSocket);
+    if (socket != null) {
+      closeQuietly(socket);
+    }
+    if (serverSocket != null) {
+      closeQuietly(serverSocket);
+    }
   }
 
   @Override public String toString() {
diff --git a/okhttp/src/test/java/okhttp3/internal/platform/Jdk8WithJettyBootPlatformTest.java b/okhttp/src/test/java/okhttp3/internal/platform/Jdk8WithJettyBootPlatformTest.java
index b971a1f0b1..e738f07814 100644
--- a/okhttp/src/test/java/okhttp3/internal/platform/Jdk8WithJettyBootPlatformTest.java
+++ b/okhttp/src/test/java/okhttp3/internal/platform/Jdk8WithJettyBootPlatformTest.java
@@ -15,7 +15,7 @@
  */
 package okhttp3.internal.platform;
 
-import okhttp3.PlatformRule;
+import okhttp3.testing.PlatformRule;
 import org.junit.Rule;
 import org.junit.Test;
 
diff --git a/okhttp/src/test/java/okhttp3/internal/platform/Jdk9PlatformTest.java b/okhttp/src/test/java/okhttp3/internal/platform/Jdk9PlatformTest.java
index 8fe522978a..12e085e18c 100644
--- a/okhttp/src/test/java/okhttp3/internal/platform/Jdk9PlatformTest.java
+++ b/okhttp/src/test/java/okhttp3/internal/platform/Jdk9PlatformTest.java
@@ -16,7 +16,7 @@
 package okhttp3.internal.platform;
 
 import java.lang.reflect.Method;
-import okhttp3.PlatformRule;
+import okhttp3.testing.PlatformRule;
 import org.junit.Rule;
 import org.junit.Test;
 
diff --git a/okhttp/src/test/java/okhttp3/internal/platform/PlatformTest.java b/okhttp/src/test/java/okhttp3/internal/platform/PlatformTest.java
index fe399a1f16..f2dc6ef4c9 100644
--- a/okhttp/src/test/java/okhttp3/internal/platform/PlatformTest.java
+++ b/okhttp/src/test/java/okhttp3/internal/platform/PlatformTest.java
@@ -15,7 +15,7 @@
  */
 package okhttp3.internal.platform;
 
-import okhttp3.PlatformRule;
+import okhttp3.testing.PlatformRule;
 import org.junit.Rule;
 import org.junit.Test;
 
diff --git a/okhttp/src/test/java/okhttp3/internal/tls/CertificatePinnerChainValidationTest.java b/okhttp/src/test/java/okhttp3/internal/tls/CertificatePinnerChainValidationTest.java
index 771225bfa1..b9223ff838 100644
--- a/okhttp/src/test/java/okhttp3/internal/tls/CertificatePinnerChainValidationTest.java
+++ b/okhttp/src/test/java/okhttp3/internal/tls/CertificatePinnerChainValidationTest.java
@@ -31,7 +31,6 @@
 import okhttp3.CertificatePinner;
 import okhttp3.OkHttpClient;
 import okhttp3.OkHttpClientTestRule;
-import okhttp3.PlatformRule;
 import okhttp3.RecordingHostnameVerifier;
 import okhttp3.Request;
 import okhttp3.Response;
@@ -39,17 +38,16 @@
 import okhttp3.mockwebserver.MockResponse;
 import okhttp3.mockwebserver.MockWebServer;
 import okhttp3.mockwebserver.SocketPolicy;
+import okhttp3.testing.PlatformRule;
 import okhttp3.tls.HandshakeCertificates;
 import okhttp3.tls.HeldCertificate;
 import org.junit.Rule;
 import org.junit.Test;
 
-import static okhttp3.internal.platform.PlatformTest.getJvmSpecVersion;
 import static okhttp3.tls.internal.TlsUtil.newKeyManager;
 import static okhttp3.tls.internal.TlsUtil.newTrustManager;
 import static org.assertj.core.api.Assertions.assertThat;
 import static org.junit.Assert.fail;
-import static org.junit.Assume.assumeFalse;
 
 public final class CertificatePinnerChainValidationTest {
   @Rule public final PlatformRule platform = new PlatformRule();
@@ -59,8 +57,7 @@
 
   /** The pinner should pull the root certificate from the trust manager. */
   @Test public void pinRootNotPresentInChain() throws Exception {
-    // TODO https://github.com/square/okhttp/issues/4703
-    assumeFalse(getJvmSpecVersion().equals("11"));
+    // Fails on 11.0.1 https://github.com/square/okhttp/issues/4703
 
     HeldCertificate rootCa = new HeldCertificate.Builder()
         .serialNumber(1L)
@@ -119,8 +116,7 @@
 
   /** The pinner should accept an intermediate from the server's chain. */
   @Test public void pinIntermediatePresentInChain() throws Exception {
-    // TODO https://github.com/square/okhttp/issues/4703
-    assumeFalse(getJvmSpecVersion().equals("11"));
+    // Fails on 11.0.1 https://github.com/square/okhttp/issues/4703
 
     HeldCertificate rootCa = new HeldCertificate.Builder()
         .serialNumber(1L)
@@ -184,7 +180,7 @@
 
   @Test public void unrelatedPinnedLeafCertificateInChain() throws Exception {
     // https://github.com/square/okhttp/issues/4729
-    assumeFalse(getJvmSpecVersion().matches("1[123]"));
+    platform.expectFailureOnConscryptPlatform();
 
     // Start with a trusted root CA certificate.
     HeldCertificate rootCa = new HeldCertificate.Builder()
@@ -262,7 +258,7 @@
 
   @Test public void unrelatedPinnedIntermediateCertificateInChain() throws Exception {
     // https://github.com/square/okhttp/issues/4729
-    assumeFalse(getJvmSpecVersion().matches("1[123]"));
+    platform.expectFailureOnConscryptPlatform();
 
     // Start with two root CA certificates, one is good and the other is compromised.
     HeldCertificate rootCa = new HeldCertificate.Builder()
@@ -353,7 +349,7 @@ private SSLSocketFactory newServerSocketFactory(HeldCertificate heldCertificate,
     X509KeyManager x509KeyManager = newKeyManager(keystoreType, heldCertificate, intermediates);
     X509TrustManager trustManager = newTrustManager(keystoreType, Collections.emptyList());
     SSLContext sslContext = Platform.get().newSSLContext();
-    sslContext.init(new KeyManager[] { x509KeyManager }, new TrustManager[] { trustManager },
+    sslContext.init(new KeyManager[] {x509KeyManager}, new TrustManager[] {trustManager},
         new SecureRandom());
     return sslContext.getSocketFactory();
   }
diff --git a/okhttp/src/test/java/okhttp3/internal/tls/ClientAuthTest.java b/okhttp/src/test/java/okhttp3/internal/tls/ClientAuthTest.java
index e9e2f19c10..9b121a9185 100644
--- a/okhttp/src/test/java/okhttp3/internal/tls/ClientAuthTest.java
+++ b/okhttp/src/test/java/okhttp3/internal/tls/ClientAuthTest.java
@@ -32,11 +32,12 @@
 import okhttp3.Call;
 import okhttp3.OkHttpClient;
 import okhttp3.OkHttpClientTestRule;
-import okhttp3.PlatformRule;
 import okhttp3.Request;
 import okhttp3.Response;
 import okhttp3.mockwebserver.MockResponse;
 import okhttp3.mockwebserver.MockWebServer;
+import okhttp3.testing.PlatformRule;
+import okhttp3.testing.PlatformVersion;
 import okhttp3.tls.HandshakeCertificates;
 import okhttp3.tls.HeldCertificate;
 import org.junit.Before;
@@ -44,13 +45,11 @@
 import org.junit.Test;
 
 import static java.util.Arrays.asList;
-import static okhttp3.PlatformRule.getPlatformSystemProperty;
-import static okhttp3.internal.platform.PlatformTest.getJvmSpecVersion;
+import static okhttp3.testing.PlatformRule.getPlatformSystemProperty;
 import static okhttp3.tls.internal.TlsUtil.newKeyManager;
 import static okhttp3.tls.internal.TlsUtil.newTrustManager;
 import static org.assertj.core.api.Assertions.assertThat;
 import static org.junit.Assert.fail;
-import static org.junit.Assume.assumeFalse;
 
 public final class ClientAuthTest {
   @Rule public final PlatformRule platform = new PlatformRule();
@@ -66,8 +65,6 @@
 
   @Before
   public void setUp() {
-    platform.assumeNotConscrypt();
-
     serverRootCa = new HeldCertificate.Builder()
         .serialNumber(1L)
         .certificateAuthority(1)
@@ -182,9 +179,8 @@ public void setUp() {
   }
 
   @Test public void missingClientAuthFailsForNeeds() throws Exception {
-    // TODO https://github.com/square/okhttp/issues/4598
+    // Fails with 11.0.1 https://github.com/square/okhttp/issues/4598
     // StreamReset stream was reset: PROT...
-    assumeFalse(getJvmSpecVersion().equals("11"));
 
     OkHttpClient client = buildClient(null, clientIntermediateCa.certificate());
 
@@ -200,10 +196,10 @@ public void setUp() {
       fail();
     } catch (SSLHandshakeException expected) {
     } catch (SSLException expected) {
-      String jvmVersion = System.getProperty("java.specification.version");
-      assertThat(jvmVersion).matches("1[123]");
+      assertThat(PlatformVersion.INSTANCE.getMajorVersion()).isGreaterThanOrEqualTo(11);
     } catch (SocketException expected) {
-      assertThat(getPlatformSystemProperty()).isEqualTo("jdk9");
+      assertThat(getPlatformSystemProperty()).isIn(PlatformRule.JDK9_PROPERTY,
+          PlatformRule.CONSCRYPT_PROPERTY);
     }
   }
 
@@ -232,9 +228,8 @@ public void setUp() {
   }
 
   @Test public void invalidClientAuthFails() throws Throwable {
-    // TODO https://github.com/square/okhttp/issues/4598
+    // Fails with https://github.com/square/okhttp/issues/4598
     // StreamReset stream was reset: PROT...
-    assumeFalse(getJvmSpecVersion().matches("1[123]"));
 
     HeldCertificate clientCert2 = new HeldCertificate.Builder()
         .serialNumber(4L)
@@ -256,10 +251,10 @@ public void setUp() {
     } catch (SSLHandshakeException expected) {
     } catch (SSLException expected) {
       // javax.net.ssl.SSLException: readRecord
-      String jvmVersion = System.getProperty("java.specification.version");
-      assertThat(jvmVersion).matches("1[123]");
+      assertThat(PlatformVersion.INSTANCE.getMajorVersion()).isGreaterThanOrEqualTo(11);
     } catch (SocketException expected) {
-      assertThat(getPlatformSystemProperty()).isEqualTo("jdk9");
+      assertThat(getPlatformSystemProperty()).isIn(PlatformRule.JDK9_PROPERTY,
+          PlatformRule.CONSCRYPT_PROPERTY);
     }
   }
 
diff --git a/okhttp/src/test/java/okhttp3/internal/ws/WebSocketHttpTest.java b/okhttp/src/test/java/okhttp3/internal/ws/WebSocketHttpTest.java
index ad966506bd..6d09aa1509 100644
--- a/okhttp/src/test/java/okhttp3/internal/ws/WebSocketHttpTest.java
+++ b/okhttp/src/test/java/okhttp3/internal/ws/WebSocketHttpTest.java
@@ -41,6 +41,7 @@
 import okhttp3.mockwebserver.MockWebServer;
 import okhttp3.mockwebserver.RecordedRequest;
 import okhttp3.mockwebserver.SocketPolicy;
+import okhttp3.testing.Flaky;
 import okhttp3.tls.HandshakeCertificates;
 import okio.Buffer;
 import okio.ByteString;
@@ -57,7 +58,11 @@
 import static org.assertj.core.data.Offset.offset;
 import static org.junit.Assert.fail;
 
+@Flaky
 public final class WebSocketHttpTest {
+  // Flaky https://github.com/square/okhttp/issues/4515
+  // Flaky https://github.com/square/okhttp/issues/4953
+
   @Rule public final MockWebServer webServer = new MockWebServer();
   @Rule public final OkHttpClientTestRule clientTestRule = new OkHttpClientTestRule();
 
@@ -84,6 +89,7 @@
     clientListener.assertExhausted();
 
     // TODO: assert all connections are released once leaks are fixed
+    clientTestRule.abandonClient();
   }
 
   @Test public void textMessage() {
@@ -248,8 +254,8 @@
     server.close(1001, "bye");
     clientListener.assertClosed(1001, "bye");
     clientListener.assertExhausted();
-    serverListener.assertClosing(1000,  "");
-    serverListener.assertClosed(1000,  "");
+    serverListener.assertClosing(1000, "");
+    serverListener.assertClosed(1000, "");
     serverListener.assertExhausted();
   }
 
@@ -578,8 +584,8 @@
     }
 
     long elapsedUntilPong3 = System.nanoTime() - startNanos;
-    assertThat((double) TimeUnit.NANOSECONDS.toMillis(elapsedUntilPong3)).isCloseTo((double) 1500, offset(
-        250d));
+    assertThat(TimeUnit.NANOSECONDS.toMillis(elapsedUntilPong3))
+        .isCloseTo(1500L, offset(250L));
 
     // The client pinged the server 3 times, and it has ponged back 3 times.
     assertThat(webSocket.sentPingCount()).isEqualTo(3);
@@ -643,8 +649,8 @@
     latch.countDown();
 
     long elapsedUntilFailure = System.nanoTime() - openAtNanos;
-    assertThat((double) TimeUnit.NANOSECONDS.toMillis(elapsedUntilFailure)).isCloseTo((double) 1000, offset(
-        250d));
+    assertThat(TimeUnit.NANOSECONDS.toMillis(elapsedUntilFailure))
+        .isCloseTo(1000L, offset(250L));
   }
 
   /** https://github.com/square/okhttp/issues/2788 */
@@ -663,8 +669,8 @@
     // Confirm that the hard cancel occurred after 500 ms.
     clientListener.assertFailure();
     long elapsedUntilFailure = System.nanoTime() - closeAtNanos;
-    assertThat((double) TimeUnit.NANOSECONDS.toMillis(elapsedUntilFailure)).isCloseTo((double) 500, offset(
-        250d));
+    assertThat(TimeUnit.NANOSECONDS.toMillis(elapsedUntilFailure))
+        .isCloseTo(500L, offset(250L));
 
     // Close the server and confirm it saw what we expected.
     server.close(1000, null);
diff --git a/okhttp/src/test/java/okhttp3/internal/ws/WebSocketReaderTest.java b/okhttp/src/test/java/okhttp3/internal/ws/WebSocketReaderTest.java
index efe061cee1..02995e30df 100644
--- a/okhttp/src/test/java/okhttp3/internal/ws/WebSocketReaderTest.java
+++ b/okhttp/src/test/java/okhttp3/internal/ws/WebSocketReaderTest.java
@@ -298,7 +298,7 @@
     data.write(ByteString.decodeHex("880203ec")); // Close with code 1004
     data.write(ByteString.decodeHex("880203ed")); // Close with code 1005
     data.write(ByteString.decodeHex("880203ee")); // Close with code 1006
-    for (int i = 1012; i <= 2999; i++) {
+    for (int i = 1015; i <= 2999; i++) {
       data.write(ByteString.decodeHex(
           "8802" + Util.format("%04X", i))); // Close with code 'i'
     }
@@ -312,7 +312,7 @@
         assertThat(e.getMessage()).matches("Code \\d+ is reserved and may not be used.");
       }
     }
-    assertThat(count).isEqualTo(1991);
+    assertThat(count).isEqualTo(1988);
   }
 
   private byte[] binaryData(int length) {
diff --git a/samples/crawler/build.gradle b/samples/crawler/build.gradle
index d9f72bd9c2..7bcfa55a08 100644
--- a/samples/crawler/build.gradle
+++ b/samples/crawler/build.gradle
@@ -2,3 +2,7 @@ dependencies {
   implementation project(':okhttp')
   implementation deps.jsoup
 }
+
+tasks.withType(JavaCompile) {
+  options.warnings = false
+}
\ No newline at end of file
diff --git a/samples/guide/README.md b/samples/guide/README.md
new file mode 100644
index 0000000000..43787700f1
--- /dev/null
+++ b/samples/guide/README.md
@@ -0,0 +1,2 @@
+Samples
+=======
diff --git a/samples/guide/build.gradle b/samples/guide/build.gradle
index 7f2ef89506..f7864f3c93 100644
--- a/samples/guide/build.gradle
+++ b/samples/guide/build.gradle
@@ -4,3 +4,7 @@ dependencies {
   implementation project(':okhttp-tls')
   implementation deps.moshi
 }
+
+tasks.withType(JavaCompile) {
+  options.warnings = false
+}
diff --git a/samples/guide/docs/images/logo-square.png b/samples/guide/docs/images/logo-square.png
new file mode 100644
index 0000000000..788b301adb
Binary files /dev/null and b/samples/guide/docs/images/logo-square.png differ
diff --git a/samples/guide/src/main/java/okhttp3/recipes/PostMultipart.java b/samples/guide/src/main/java/okhttp3/recipes/PostMultipart.java
index b13a0533ba..aa7ea2974f 100644
--- a/samples/guide/src/main/java/okhttp3/recipes/PostMultipart.java
+++ b/samples/guide/src/main/java/okhttp3/recipes/PostMultipart.java
@@ -40,7 +40,9 @@ public void run() throws Exception {
         .setType(MultipartBody.FORM)
         .addFormDataPart("title", "Square Logo")
         .addFormDataPart("image", "logo-square.png",
-            RequestBody.create(new File("website/static/logo-square.png"), MEDIA_TYPE_PNG))
+            RequestBody.create(
+                new File("docs/images/logo-square.png"),
+                MEDIA_TYPE_PNG))
         .build();
 
     Request request = new Request.Builder()
diff --git a/samples/guide/src/main/java/okhttp3/recipes/PrintEvents.java b/samples/guide/src/main/java/okhttp3/recipes/PrintEvents.java
index 6c9f71279f..8111761dbf 100644
--- a/samples/guide/src/main/java/okhttp3/recipes/PrintEvents.java
+++ b/samples/guide/src/main/java/okhttp3/recipes/PrintEvents.java
@@ -26,6 +26,7 @@
 import okhttp3.Connection;
 import okhttp3.EventListener;
 import okhttp3.Handshake;
+import okhttp3.HttpUrl;
 import okhttp3.OkHttpClient;
 import okhttp3.Protocol;
 import okhttp3.Request;
@@ -97,6 +98,14 @@ private void printEvent(String name) {
       System.out.printf("%04d %.3f %s%n", callId, elapsedNanos / 1000000000d, name);
     }
 
+    @Override public void proxySelectStart(Call call, HttpUrl url) {
+      printEvent("proxySelectStart");
+    }
+
+    @Override public void proxySelectEnd(Call call, HttpUrl url, List<Proxy> proxies) {
+      printEvent("proxySelectEnd");
+    }
+
     @Override public void callStart(Call call) {
       printEvent("callStart");
     }
diff --git a/samples/guide/src/main/java/okhttp3/recipes/PrintEventsNonConcurrent.java b/samples/guide/src/main/java/okhttp3/recipes/PrintEventsNonConcurrent.java
index c88895b794..ea0b1fb619 100644
--- a/samples/guide/src/main/java/okhttp3/recipes/PrintEventsNonConcurrent.java
+++ b/samples/guide/src/main/java/okhttp3/recipes/PrintEventsNonConcurrent.java
@@ -24,6 +24,7 @@
 import okhttp3.Connection;
 import okhttp3.EventListener;
 import okhttp3.Handshake;
+import okhttp3.HttpUrl;
 import okhttp3.OkHttpClient;
 import okhttp3.Protocol;
 import okhttp3.Request;
@@ -76,6 +77,14 @@ private void printEvent(String name) {
       printEvent("callStart");
     }
 
+    @Override public void proxySelectStart(Call call, HttpUrl url) {
+      printEvent("proxySelectStart");
+    }
+
+    @Override public void proxySelectEnd(Call call, HttpUrl url, List<Proxy> proxies) {
+      printEvent("proxySelectEnd");
+    }
+
     @Override public void dnsStart(Call call, String domainName) {
       printEvent("dnsStart");
     }
diff --git a/samples/guide/src/main/java/okhttp3/recipes/WebSocketEcho.java b/samples/guide/src/main/java/okhttp3/recipes/WebSocketEcho.java
index 288fadb7ce..f0407db87f 100644
--- a/samples/guide/src/main/java/okhttp3/recipes/WebSocketEcho.java
+++ b/samples/guide/src/main/java/okhttp3/recipes/WebSocketEcho.java
@@ -1,10 +1,10 @@
 package okhttp3.recipes;
 
 import java.util.concurrent.TimeUnit;
-import okhttp3.WebSocket;
 import okhttp3.OkHttpClient;
 import okhttp3.Request;
 import okhttp3.Response;
+import okhttp3.WebSocket;
 import okhttp3.WebSocketListener;
 import okio.ByteString;
 
diff --git a/samples/guide/src/test/kotlin/okhttp3/AllMainsTest.kt b/samples/guide/src/test/kotlin/okhttp3/AllMainsTest.kt
new file mode 100644
index 0000000000..21c932c464
--- /dev/null
+++ b/samples/guide/src/test/kotlin/okhttp3/AllMainsTest.kt
@@ -0,0 +1,67 @@
+/*
+ * Copyright (C) 2019 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3
+
+import org.junit.Ignore
+import org.junit.Test
+import org.junit.runner.RunWith
+import org.junit.runners.Parameterized
+import java.io.File
+import java.lang.reflect.InvocationTargetException
+
+@RunWith(Parameterized::class)
+@Ignore
+class AllMainsTest(val className: String) {
+  @Test
+  fun runMain() {
+    val mainMethod = Class.forName(className).methods.find { it.name == "main" }
+    try {
+      mainMethod?.invoke(null, arrayOf<String>())
+    } catch (ite: InvocationTargetException) {
+      if (!expectedFailure(className, ite.cause!!)) {
+        throw ite.cause!!
+      }
+    }
+  }
+
+  private fun expectedFailure(className: String, cause: Throwable): Boolean {
+    return when (className) {
+      "okhttp3.recipes.CheckHandshake" -> true // by design
+      "okhttp3.recipes.RequestBodyCompression" -> true // expired token
+      else -> false
+    }
+  }
+
+  companion object {
+    private val prefix = if (File("samples").exists()) "" else "../../"
+
+    @JvmStatic
+    @Parameterized.Parameters(name = "{0}")
+    fun data(): List<String> {
+      val mainFiles = mainFiles()
+      return mainFiles.map {
+        it.path.substring("$prefix/samples/guide/src/main/java".length, it.path.length - 5)
+            .replace('/', '.')
+      }.sorted()
+    }
+
+    private fun mainFiles(): List<File> {
+      return File("$prefix/samples/guide/src/main/java/okhttp3").listFiles()?.flatMap {
+        it?.listFiles()?.toList().orEmpty()
+      }.orEmpty()
+    }
+  }
+}
diff --git a/samples/static-server/build.gradle b/samples/static-server/build.gradle
index 1b1bb519c6..7b03c052c1 100644
--- a/samples/static-server/build.gradle
+++ b/samples/static-server/build.gradle
@@ -1,5 +1,9 @@
 apply plugin: 'com.github.johnrengelman.shadow'
 
+tasks.withType(JavaCompile) {
+  options.warnings = false
+}
+
 jar {
   manifest {
     attributes 'Main-Class': 'okhttp3.sample.SampleServer'
diff --git a/settings.gradle b/settings.gradle
index 367bee6364..8b742d82cb 100644
--- a/settings.gradle
+++ b/settings.gradle
@@ -1,6 +1,16 @@
+rootProject.name = 'okhttp-parent'
+
 include ':mockwebserver'
+
+if (properties.containsKey('android.injected.invoked.from.ide') ||
+        System.getenv('ANDROID_SDK_ROOT') != null) {
+  // Currently incompatible with Intellij, use with Android Studio and from CLI with explicit flag
+  include ':android-test'
+}
+
 include ':okcurl'
 include ':okhttp'
+include ':okhttp-brotli'
 include ':okhttp-dnsoverhttps'
 include ':okhttp-hpacktests'
 include ':okhttp-logging-interceptor'
