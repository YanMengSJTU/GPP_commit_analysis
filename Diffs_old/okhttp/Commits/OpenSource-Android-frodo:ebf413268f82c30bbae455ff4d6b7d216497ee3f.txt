diff --git a/okhttp/src/main/java/com/squareup/okhttp/ConnectionPool.java b/okhttp/src/main/java/com/squareup/okhttp/ConnectionPool.java
index ba664ea992..62efff80c6 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/ConnectionPool.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/ConnectionPool.java
@@ -18,6 +18,7 @@
 
 import com.squareup.okhttp.internal.Platform;
 import com.squareup.okhttp.internal.Util;
+
 import java.net.SocketException;
 import java.util.ArrayList;
 import java.util.LinkedList;
@@ -33,305 +34,339 @@
  * requests that share the same {@link com.squareup.okhttp.Address} may share a
  * {@link com.squareup.okhttp.Connection}. This class implements the policy of
  * which connections to keep open for future use.
- *
+ * <p/>
  * <p>The {@link #getDefault() system-wide default} uses system properties for
  * tuning parameters:
  * <ul>
- *     <li>{@code http.keepAlive} true if HTTP and SPDY connections should be
- *         pooled at all. Default is true.
- *     <li>{@code http.maxConnections} maximum number of idle connections to
- *         each to keep in the pool. Default is 5.
- *     <li>{@code http.keepAliveDuration} Time in milliseconds to keep the
- *         connection alive in the pool before closing it. Default is 5 minutes.
- *         This property isn't used by {@code HttpURLConnection}.
+ * <li>{@code http.keepAlive} true if HTTP and SPDY connections should be
+ * pooled at all. Default is true.
+ * <li>{@code http.maxConnections} maximum number of idle connections to
+ * each to keep in the pool. Default is 5.
+ * <li>{@code http.keepAliveDuration} Time in milliseconds to keep the
+ * connection alive in the pool before closing it. Default is 5 minutes.
+ * This property isn't used by {@code HttpURLConnection}.
  * </ul>
- *
+ * <p/>
  * <p>The default instance <i>doesn't</i> adjust its configuration as system
  * properties are changed. This assumes that the applications that set these
  * parameters do so before making HTTP connections, and that this class is
  * initialized lazily.
  */
 public final class ConnectionPool {
-  private static final long DEFAULT_KEEP_ALIVE_DURATION_MS = 5 * 60 * 1000; // 5 min
-
-  private static final ConnectionPool systemDefault;
-
-  static {
-    String keepAlive = System.getProperty("http.keepAlive");
-    String keepAliveDuration = System.getProperty("http.keepAliveDuration");
-    String maxIdleConnections = System.getProperty("http.maxConnections");
-    long keepAliveDurationMs = keepAliveDuration != null ? Long.parseLong(keepAliveDuration)
-        : DEFAULT_KEEP_ALIVE_DURATION_MS;
-    if (keepAlive != null && !Boolean.parseBoolean(keepAlive)) {
-      systemDefault = new ConnectionPool(0, keepAliveDurationMs);
-    } else if (maxIdleConnections != null) {
-      systemDefault = new ConnectionPool(Integer.parseInt(maxIdleConnections), keepAliveDurationMs);
-    } else {
-      systemDefault = new ConnectionPool(5, keepAliveDurationMs);
-    }
-  }
-
-  /** The maximum number of idle connections for each address. */
-  private final int maxIdleConnections;
-  private final long keepAliveDurationNs;
-
-  private final LinkedList<Connection> connections = new LinkedList<>();
-
-  /**
-   * A background thread is used to cleanup expired connections. There will be, at most, a single
-   * thread running per connection pool.
-   *
-   * <p>A {@link ThreadPoolExecutor} is used and not a
-   * {@link java.util.concurrent.ScheduledThreadPoolExecutor}; ScheduledThreadPoolExecutors do not
-   * shrink. This executor shrinks the thread pool after a period of inactivity, and starts threads
-   * as needed. Delays are instead handled by the {@link #connectionsCleanupRunnable}. It is
-   * important that the {@link #connectionsCleanupRunnable} stops eventually, otherwise it will pin
-   * the thread, and thus the connection pool, in memory.
-   */
-  private Executor executor = new ThreadPoolExecutor(
-      0 /* corePoolSize */, 1 /* maximumPoolSize */, 60L /* keepAliveTime */, TimeUnit.SECONDS,
-      new LinkedBlockingQueue<Runnable>(), Util.threadFactory("OkHttp ConnectionPool", true));
-
-  private final Runnable connectionsCleanupRunnable = new Runnable() {
-    @Override public void run() {
-      runCleanupUntilPoolIsEmpty();
-    }
-  };
-
-  public ConnectionPool(int maxIdleConnections, long keepAliveDurationMs) {
-    this.maxIdleConnections = maxIdleConnections;
-    this.keepAliveDurationNs = keepAliveDurationMs * 1000 * 1000;
-  }
-
-  public static ConnectionPool getDefault() {
-    return systemDefault;
-  }
-
-  /** Returns total number of connections in the pool. */
-  public synchronized int getConnectionCount() {
-    return connections.size();
-  }
-
-  /** @deprecated Use {@link #getMultiplexedConnectionCount()}. */
-  @Deprecated
-  public synchronized int getSpdyConnectionCount() {
-    return getMultiplexedConnectionCount();
-  }
-
-  /** Returns total number of multiplexed connections in the pool. */
-  public synchronized int getMultiplexedConnectionCount() {
-    int total = 0;
-    for (Connection connection : connections) {
-      if (connection.isSpdy()) total++;
-    }
-    return total;
-  }
-
-  /** Returns total number of http connections in the pool. */
-  public synchronized int getHttpConnectionCount() {
-    return connections.size() - getMultiplexedConnectionCount();
-  }
-
-  /** Returns a recycled connection to {@code address}, or null if no such connection exists. */
-  public synchronized Connection get(Address address) {
-    Connection foundConnection = null;
-    for (ListIterator<Connection> i = connections.listIterator(connections.size());
-        i.hasPrevious(); ) {
-      Connection connection = i.previous();
-      if (!connection.getRoute().getAddress().equals(address)
-          || !connection.isAlive()
-          || System.nanoTime() - connection.getIdleStartTimeNs() >= keepAliveDurationNs) {
-        continue;
-      }
-      i.remove();
-      if (!connection.isSpdy()) {
-        try {
-          Platform.get().tagSocket(connection.getSocket());
-        } catch (SocketException e) {
-          Util.closeQuietly(connection.getSocket());
-          // When unable to tag, skip recycling and close
-          Platform.get().logW("Unable to tagSocket(): " + e);
-          continue;
+    private static final long DEFAULT_KEEP_ALIVE_DURATION_MS = 5 * 60 * 1000; // 5 min
+
+    private static final ConnectionPool systemDefault;
+
+    static {
+        String keepAlive = System.getProperty("http.keepAlive");
+        String keepAliveDuration = System.getProperty("http.keepAliveDuration");
+        String maxIdleConnections = System.getProperty("http.maxConnections");
+        long keepAliveDurationMs = keepAliveDuration != null ? Long.parseLong(keepAliveDuration)
+                : DEFAULT_KEEP_ALIVE_DURATION_MS;
+        if (keepAlive != null && !Boolean.parseBoolean(keepAlive)) {
+            systemDefault = new ConnectionPool(0, keepAliveDurationMs);
+        } else if (maxIdleConnections != null) {
+            systemDefault = new ConnectionPool(Integer.parseInt(maxIdleConnections), keepAliveDurationMs);
+        } else {
+            systemDefault = new ConnectionPool(5, keepAliveDurationMs);
         }
-      }
-      foundConnection = connection;
-      break;
     }
 
-    if (foundConnection != null && foundConnection.isSpdy()) {
-      connections.addFirst(foundConnection); // Add it back after iteration.
+    /**
+     * The maximum number of idle connections for each address.
+     */
+    private final int maxIdleConnections;
+    private final long keepAliveDurationNs;
+
+    private final LinkedList<Connection> connections = new LinkedList<>();
+
+    /**
+     * A background thread is used to cleanup expired connections. There will be, at most, a single
+     * thread running per connection pool.
+     * <p/>
+     * <p>A {@link ThreadPoolExecutor} is used and not a
+     * {@link java.util.concurrent.ScheduledThreadPoolExecutor}; ScheduledThreadPoolExecutors do not
+     * shrink. This executor shrinks the thread pool after a period of inactivity, and starts threads
+     * as needed. Delays are instead handled by the {@link #connectionsCleanupRunnable}. It is
+     * important that the {@link #connectionsCleanupRunnable} stops eventually, otherwise it will pin
+     * the thread, and thus the connection pool, in memory.
+     */
+    private Executor executor = new ThreadPoolExecutor(
+            0 /* corePoolSize */, 1 /* maximumPoolSize */, 60L /* keepAliveTime */, TimeUnit.SECONDS,
+            new LinkedBlockingQueue<Runnable>(), Util.threadFactory("OkHttp ConnectionPool", true));
+
+    private final Runnable connectionsCleanupRunnable = new Runnable() {
+        @Override
+        public void run() {
+            runCleanupUntilPoolIsEmpty();
+        }
+    };
+
+    public ConnectionPool(int maxIdleConnections, long keepAliveDurationMs) {
+        this.maxIdleConnections = maxIdleConnections;
+        this.keepAliveDurationNs = keepAliveDurationMs * 1000 * 1000;
     }
 
-    return foundConnection;
-  }
-
-  /**
-   * Gives {@code connection} to the pool. The pool may store the connection,
-   * or close it, as its policy describes.
-   *
-   * <p>It is an error to use {@code connection} after calling this method.
-   */
-  void recycle(Connection connection) {
-    if (connection.isSpdy()) {
-      return;
+    public static ConnectionPool getDefault() {
+        return systemDefault;
     }
 
-    if (!connection.clearOwner()) {
-      return; // This connection isn't eligible for reuse.
+    /**
+     * Returns total number of connections in the pool.
+     */
+    public synchronized int getConnectionCount() {
+        return connections.size();
     }
 
-    if (!connection.isAlive()) {
-      Util.closeQuietly(connection.getSocket());
-      return;
+    /**
+     * @deprecated Use {@link #getMultiplexedConnectionCount()}.
+     */
+    @Deprecated
+    public synchronized int getSpdyConnectionCount() {
+        return getMultiplexedConnectionCount();
     }
 
-    try {
-      Platform.get().untagSocket(connection.getSocket());
-    } catch (SocketException e) {
-      // When unable to remove tagging, skip recycling and close.
-      Platform.get().logW("Unable to untagSocket(): " + e);
-      Util.closeQuietly(connection.getSocket());
-      return;
+    /**
+     * Returns total number of multiplexed connections in the pool.
+     */
+    public synchronized int getMultiplexedConnectionCount() {
+        int total = 0;
+        for (Connection connection : connections) {
+            if (connection.isSpdy()) {
+                total++;
+            }
+        }
+        return total;
     }
 
-    synchronized (this) {
-      addConnection(connection);
-      connection.incrementRecycleCount();
-      connection.resetIdleStartTime();
+    /**
+     * Returns total number of http connections in the pool.
+     */
+    public synchronized int getHttpConnectionCount() {
+        return connections.size() - getMultiplexedConnectionCount();
     }
-  }
-
-  private void addConnection(Connection connection) {
-    boolean empty = connections.isEmpty();
-    connections.addFirst(connection);
-    if (empty) {
-      executor.execute(connectionsCleanupRunnable);
-    } else {
-      notifyAll();
+
+    /**
+     * Returns a recycled connection to {@code address}, or null if no such connection exists.
+     */
+    // 返回一个循环使用的Connection
+    public synchronized Connection get(Address address) {
+        Connection foundConnection = null;
+        for (ListIterator<Connection> i = connections.listIterator(connections.size());
+             i.hasPrevious(); ) {
+            Connection connection = i.previous();
+            if (!connection.getRoute().getAddress().equals(address)
+                    || !connection.isAlive()
+                    || System.nanoTime() - connection.getIdleStartTimeNs() >= keepAliveDurationNs) {
+                continue;
+            }
+            i.remove();
+            // 如果不是spdy连接。
+            if (!connection.isSpdy()) {
+                try {
+                    // 通过反射 -- 这是Android平台下的适配 主要是反射到“android.net.TrafficStats.Socket.class”，
+                    // 在这下边会有tagSocket和untagSocket方法，如果想了解详细的情况，建议再对照Platform这个类仔细研究一下
+                    //  // Non-null on Android 4.0+.
+                    //  private final Method trafficStatsTagSocket;
+                    //  private final Method trafficStatsUntagSocket;
+                    Platform.get().tagSocket(connection.getSocket());
+                } catch (SocketException e) {
+                    Util.closeQuietly(connection.getSocket());
+                    // When unable to tag, skip recycling and close
+                    Platform.get().logW("Unable to tagSocket(): " + e);
+                    continue;
+                }
+            }
+            // 命中可循环使用Connection
+            foundConnection = connection;
+            break;
+        }
+
+        // 这里针对SPDY的Connection的重用，添加到队列头部
+        if (foundConnection != null && foundConnection.isSpdy()) {
+            connections.addFirst(foundConnection); // Add it back after iteration.
+        }
+
+        return foundConnection;
     }
-  }
-
-  /**
-   * Shares the SPDY connection with the pool. Callers to this method may
-   * continue to use {@code connection}.
-   */
-  void share(Connection connection) {
-    if (!connection.isSpdy()) throw new IllegalArgumentException();
-    if (!connection.isAlive()) return;
-    synchronized (this) {
-      addConnection(connection);
+
+    /**
+     * Gives {@code connection} to the pool. The pool may store the connection,
+     * or close it, as its policy describes.
+     * <p/>
+     * <p>It is an error to use {@code connection} after calling this method.
+     */
+    void recycle(Connection connection) {
+        if (connection.isSpdy()) {
+            return;
+        }
+
+        if (!connection.clearOwner()) {
+            return; // This connection isn't eligible for reuse.
+        }
+
+        if (!connection.isAlive()) {
+            Util.closeQuietly(connection.getSocket());
+            return;
+        }
+
+        try {
+            Platform.get().untagSocket(connection.getSocket());
+        } catch (SocketException e) {
+            // When unable to remove tagging, skip recycling and close.
+            Platform.get().logW("Unable to untagSocket(): " + e);
+            Util.closeQuietly(connection.getSocket());
+            return;
+        }
+
+        synchronized(this) {
+            addConnection(connection);
+            connection.incrementRecycleCount();
+            connection.resetIdleStartTime();
+        }
     }
-  }
-
-  /** Close and remove all connections in the pool. */
-  public void evictAll() {
-    List<Connection> toEvict;
-    synchronized (this) {
-      toEvict = new ArrayList<>(connections);
-      connections.clear();
-      notifyAll();
+
+    private void addConnection(Connection connection) {
+        boolean empty = connections.isEmpty();
+        connections.addFirst(connection);
+        if (empty) {
+            executor.execute(connectionsCleanupRunnable);
+        } else {
+            notifyAll();
+        }
     }
 
-    for (int i = 0, size = toEvict.size(); i < size; i++) {
-      Util.closeQuietly(toEvict.get(i).getSocket());
+    /**
+     * Shares the SPDY connection with the pool. Callers to this method may
+     * continue to use {@code connection}.
+     */
+    void share(Connection connection) {
+        if (!connection.isSpdy()) {
+            throw new IllegalArgumentException();
+        }
+        if (!connection.isAlive()) {
+            return;
+        }
+        synchronized(this) {
+            addConnection(connection);
+        }
     }
-  }
 
-  private void runCleanupUntilPoolIsEmpty() {
-    while (true) {
-      if (!performCleanup()) return; // Halt cleanup.
+    /**
+     * Close and remove all connections in the pool.
+     */
+    public void evictAll() {
+        List<Connection> toEvict;
+        synchronized(this) {
+            toEvict = new ArrayList<>(connections);
+            connections.clear();
+            notifyAll();
+        }
+
+        for (int i = 0, size = toEvict.size(); i < size; i++) {
+            Util.closeQuietly(toEvict.get(i).getSocket());
+        }
     }
-  }
-
-  /**
-   * Attempts to make forward progress on connection eviction. There are three possible outcomes:
-   *
-   * <h3>The pool is empty.</h3>
-   * In this case, this method returns false and the eviction job should exit because there are no
-   * further cleanup tasks coming. (If additional connections are added to the pool, another cleanup
-   * job must be enqueued.)
-   *
-   * <h3>Connections were evicted.</h3>
-   * At least one connections was eligible for immediate eviction and was evicted. The method
-   * returns true and cleanup should continue.
-   *
-   * <h3>We waited to evict.</h3>
-   * None of the pooled connections were eligible for immediate eviction. Instead, we waited until
-   * either a connection became eligible for eviction, or the connections list changed. In either
-   * case, the method returns true and cleanup should continue.
-   */
-  // VisibleForTesting
-  boolean performCleanup() {
-    List<Connection> evictableConnections;
-
-    synchronized (this) {
-      if (connections.isEmpty()) return false; // Halt cleanup.
-
-      evictableConnections = new ArrayList<>();
-      int idleConnectionCount = 0;
-      long now = System.nanoTime();
-      long nanosUntilNextEviction = keepAliveDurationNs;
-
-      // Collect connections eligible for immediate eviction.
-      for (ListIterator<Connection> i = connections.listIterator(connections.size());
-          i.hasPrevious(); ) {
-        Connection connection = i.previous();
-        long nanosUntilEviction = connection.getIdleStartTimeNs() + keepAliveDurationNs - now;
-        if (nanosUntilEviction <= 0 || !connection.isAlive()) {
-          i.remove();
-          evictableConnections.add(connection);
-        } else if (connection.isIdle()) {
-          idleConnectionCount++;
-          nanosUntilNextEviction = Math.min(nanosUntilNextEviction, nanosUntilEviction);
+
+    private void runCleanupUntilPoolIsEmpty() {
+        while (true) {
+            if (!performCleanup()) {
+                return; // Halt cleanup.
+            }
         }
-      }
-
-      // If the pool has too many idle connections, gather more! Oldest to newest.
-      for (ListIterator<Connection> i = connections.listIterator(connections.size());
-          i.hasPrevious() && idleConnectionCount > maxIdleConnections; ) {
-        Connection connection = i.previous();
-        if (connection.isIdle()) {
-          evictableConnections.add(connection);
-          i.remove();
-          --idleConnectionCount;
+    }
+
+    /**
+     * Attempts to make forward progress on connection eviction. There are three possible outcomes:
+     * <p/>
+     * <h3>The pool is empty.</h3>
+     * In this case, this method returns false and the eviction job should exit because there are no
+     * further cleanup tasks coming. (If additional connections are added to the pool, another cleanup
+     * job must be enqueued.)
+     * <p/>
+     * <h3>Connections were evicted.</h3>
+     * At least one connections was eligible for immediate eviction and was evicted. The method
+     * returns true and cleanup should continue.
+     * <p/>
+     * <h3>We waited to evict.</h3>
+     * None of the pooled connections were eligible for immediate eviction. Instead, we waited until
+     * either a connection became eligible for eviction, or the connections list changed. In either
+     * case, the method returns true and cleanup should continue.
+     */
+    // VisibleForTesting
+    boolean performCleanup() {
+        List<Connection> evictableConnections;
+
+        synchronized(this) {
+            if (connections.isEmpty()) {
+                return false; // Halt cleanup.
+            }
+
+            evictableConnections = new ArrayList<>();
+            int idleConnectionCount = 0;
+            long now = System.nanoTime();
+            long nanosUntilNextEviction = keepAliveDurationNs;
+
+            // Collect connections eligible for immediate eviction.
+            for (ListIterator<Connection> i = connections.listIterator(connections.size());
+                 i.hasPrevious(); ) {
+                Connection connection = i.previous();
+                long nanosUntilEviction = connection.getIdleStartTimeNs() + keepAliveDurationNs - now;
+                if (nanosUntilEviction <= 0 || !connection.isAlive()) {
+                    i.remove();
+                    evictableConnections.add(connection);
+                } else if (connection.isIdle()) {
+                    idleConnectionCount++;
+                    nanosUntilNextEviction = Math.min(nanosUntilNextEviction, nanosUntilEviction);
+                }
+            }
+
+            // If the pool has too many idle connections, gather more! Oldest to newest.
+            for (ListIterator<Connection> i = connections.listIterator(connections.size());
+                 i.hasPrevious() && idleConnectionCount > maxIdleConnections; ) {
+                Connection connection = i.previous();
+                if (connection.isIdle()) {
+                    evictableConnections.add(connection);
+                    i.remove();
+                    --idleConnectionCount;
+                }
+            }
+
+            // If there's nothing to evict, wait. (This will be interrupted if connections are added.)
+            if (evictableConnections.isEmpty()) {
+                try {
+                    long millisUntilNextEviction = nanosUntilNextEviction / (1000 * 1000);
+                    long remainderNanos = nanosUntilNextEviction - millisUntilNextEviction * (1000 * 1000);
+                    this.wait(millisUntilNextEviction, (int) remainderNanos);
+                    return true; // Cleanup continues.
+                } catch (InterruptedException ignored) {
+                }
+            }
         }
-      }
 
-      // If there's nothing to evict, wait. (This will be interrupted if connections are added.)
-      if (evictableConnections.isEmpty()) {
-        try {
-          long millisUntilNextEviction = nanosUntilNextEviction / (1000 * 1000);
-          long remainderNanos = nanosUntilNextEviction - millisUntilNextEviction * (1000 * 1000);
-          this.wait(millisUntilNextEviction, (int) remainderNanos);
-          return true; // Cleanup continues.
-        } catch (InterruptedException ignored) {
+        // Actually do the eviction. Note that we avoid synchronized() when closing sockets.
+        for (int i = 0, size = evictableConnections.size(); i < size; i++) {
+            Connection expiredConnection = evictableConnections.get(i);
+            Util.closeQuietly(expiredConnection.getSocket());
         }
-      }
+
+        return true; // Cleanup continues.
     }
 
-    // Actually do the eviction. Note that we avoid synchronized() when closing sockets.
-    for (int i = 0, size = evictableConnections.size(); i < size; i++) {
-      Connection expiredConnection = evictableConnections.get(i);
-      Util.closeQuietly(expiredConnection.getSocket());
+    /**
+     * Replace the default {@link Executor} with a different one. Only use in tests.
+     */
+    // VisibleForTesting
+    void replaceCleanupExecutorForTests(Executor cleanupExecutor) {
+        this.executor = cleanupExecutor;
     }
 
-    return true; // Cleanup continues.
-  }
-
-  /**
-   * Replace the default {@link Executor} with a different one. Only use in tests.
-   */
-  // VisibleForTesting
-  void replaceCleanupExecutorForTests(Executor cleanupExecutor) {
-    this.executor = cleanupExecutor;
-  }
-
-  /**
-   * Returns a snapshot of the connections in this pool, ordered from newest to
-   * oldest. Only use in tests.
-   */
-  // VisibleForTesting
-  synchronized List<Connection> getConnections() {
-    return new ArrayList<>(connections);
-  }
+    /**
+     * Returns a snapshot of the connections in this pool, ordered from newest to
+     * oldest. Only use in tests.
+     */
+    // VisibleForTesting
+    synchronized List<Connection> getConnections() {
+        return new ArrayList<>(connections);
+    }
 }
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpEngine.java b/okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpEngine.java
index 82c91d3e43..78a8cc9f27 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpEngine.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpEngine.java
@@ -33,6 +33,7 @@
 import com.squareup.okhttp.internal.Internal;
 import com.squareup.okhttp.internal.InternalCache;
 import com.squareup.okhttp.internal.Util;
+
 import java.io.IOException;
 import java.io.InterruptedIOException;
 import java.net.CookieHandler;
@@ -44,10 +45,12 @@
 import java.util.Date;
 import java.util.List;
 import java.util.Map;
+
 import javax.net.ssl.HostnameVerifier;
 import javax.net.ssl.SSLHandshakeException;
 import javax.net.ssl.SSLPeerUnverifiedException;
 import javax.net.ssl.SSLSocketFactory;
+
 import okio.Buffer;
 import okio.BufferedSink;
 import okio.BufferedSource;
@@ -87,986 +90,1049 @@
  * All responses have a response body input stream, though in some
  * instances this stream is empty.
  * </ol>
- *
+ * <p/>
  * <p>The request and response may be served by the HTTP response cache, by the
  * network, or by both in the event of a conditional GET.
  */
 public final class HttpEngine {
-  /**
-   * How many redirects and auth challenges should we attempt? Chrome follows 21 redirects; Firefox,
-   * curl, and wget follow 20; Safari follows 16; and HTTP/1.0 recommends 5.
-   */
-  public static final int MAX_FOLLOW_UPS = 20;
-
-  private static final ResponseBody EMPTY_BODY = new ResponseBody() {
-    @Override public MediaType contentType() {
-      return null;
-    }
-    @Override public long contentLength() {
-      return 0;
-    }
-    @Override public BufferedSource source() {
-      return new Buffer();
-    }
-  };
-
-  final OkHttpClient client;
-
-  private Connection connection;
-  private Address address;
-  private RouteSelector routeSelector;
-  private Route route;
-  private final Response priorResponse;
-
-  private Transport transport;
-
-  /** The time when the request headers were written, or -1 if they haven't been written yet. */
-  long sentRequestMillis = -1;
-
-  /**
-   * True if this client added an "Accept-Encoding: gzip" header field and is
-   * therefore responsible for also decompressing the transfer stream.
-   */
-  private boolean transparentGzip;
-
-  /**
-   * True if the request body must be completely buffered before transmission;
-   * false if it can be streamed. Buffering has two advantages: we don't need
-   * the content-length in advance and we can retransmit if necessary. The
-   * upside of streaming is that we can save memory.
-   */
-  public final boolean bufferRequestBody;
-
-  /**
-   * The original application-provided request. Never modified by OkHttp. When
-   * follow-up requests are necessary, they are derived from this request.
-   */
-  private final Request userRequest;
-
-  /**
-   * The request to send on the network, or null for no network request. This is
-   * derived from the user request, and customized to support OkHttp features
-   * like compression and caching.
-   */
-  private Request networkRequest;
-
-  /**
-   * The cached response, or null if the cache doesn't exist or cannot be used
-   * for this request. Conditional caching means this may be non-null even when
-   * the network request is non-null. Never modified by OkHttp.
-   */
-  private Response cacheResponse;
-
-  /**
-   * The user-visible response. This is derived from either the network
-   * response, cache response, or both. It is customized to support OkHttp
-   * features like compression and caching.
-   */
-  private Response userResponse;
-
-  private Sink requestBodyOut;
-  private BufferedSink bufferedRequestBody;
-  private final boolean callerWritesRequestBody;
-  private final boolean forWebSocket;
-
-  /** The cache request currently being populated from a network response. */
-  private CacheRequest storeRequest;
-  private CacheStrategy cacheStrategy;
-
-  /**
-   * @param request the HTTP request without a body. The body must be written via the engine's
-   *     request body stream.
-   * @param callerWritesRequestBody true for the {@code HttpURLConnection}-style interaction
-   *     model where control flow is returned to the calling application to write the request body
-   *     before the response body is readable.
-   * @param connection the connection used for an intermediate response immediately prior to this
-   *     request/response pair, such as a same-host redirect. This engine assumes ownership of the
-   *     connection and must release it when it is unneeded.
-   * @param routeSelector the route selector used for a failed attempt immediately preceding this
-   */
-  public HttpEngine(OkHttpClient client, Request request, boolean bufferRequestBody,
-      boolean callerWritesRequestBody, boolean forWebSocket, Connection connection,
-      RouteSelector routeSelector, RetryableSink requestBodyOut, Response priorResponse) {
-    this.client = client;
-    this.userRequest = request;
-    this.bufferRequestBody = bufferRequestBody;
-    this.callerWritesRequestBody = callerWritesRequestBody;
-    this.forWebSocket = forWebSocket;
-    this.connection = connection;
-    this.routeSelector = routeSelector;
-    this.requestBodyOut = requestBodyOut;
-    this.priorResponse = priorResponse;
-
-    if (connection != null) {
-      Internal.instance.setOwner(connection, this);
-      this.route = connection.getRoute();
-    } else {
-      this.route = null;
-    }
-  }
-
-  /**
-   * Figures out what the response source will be, and opens a socket to that
-   * source if necessary. Prepares the request headers and gets ready to start
-   * writing the request body if it exists.
-   */
-  public void sendRequest() throws IOException {
-    if (cacheStrategy != null) return; // Already sent.
-    if (transport != null) throw new IllegalStateException();
-
-    Request request = networkRequest(userRequest);
-
-    InternalCache responseCache = Internal.instance.internalCache(client);
-    Response cacheCandidate = responseCache != null
-        ? responseCache.get(request)
-        : null;
-
-    long now = System.currentTimeMillis();
-    cacheStrategy = new CacheStrategy.Factory(now, request, cacheCandidate).get();
-    networkRequest = cacheStrategy.networkRequest;
-    cacheResponse = cacheStrategy.cacheResponse;
-
-    if (responseCache != null) {
-      responseCache.trackResponse(cacheStrategy);
-    }
+    /**
+     * How many redirects and auth challenges should we attempt? Chrome follows 21 redirects; Firefox,
+     * curl, and wget follow 20; Safari follows 16; and HTTP/1.0 recommends 5.
+     */
+    public static final int MAX_FOLLOW_UPS = 20;
+
+    private static final ResponseBody EMPTY_BODY = new ResponseBody() {
+        @Override
+        public MediaType contentType() {
+            return null;
+        }
 
-    if (cacheCandidate != null && cacheResponse == null) {
-      closeQuietly(cacheCandidate.body()); // The cache candidate wasn't applicable. Close it.
-    }
+        @Override
+        public long contentLength() {
+            return 0;
+        }
 
-    if (networkRequest != null) {
-      // Open a connection unless we inherited one from a redirect.
-      if (connection == null) {
-        connect();
-      }
-
-      transport = Internal.instance.newTransport(connection, this);
-
-      // If the caller's control flow writes the request body, we need to create that stream
-      // immediately. And that means we need to immediately write the request headers, so we can
-      // start streaming the request body. (We may already have a request body if we're retrying a
-      // failed POST.)
-      if (callerWritesRequestBody && permitsRequestBody() && requestBodyOut == null) {
-        long contentLength = OkHeaders.contentLength(request);
-        if (bufferRequestBody) {
-          if (contentLength > Integer.MAX_VALUE) {
-            throw new IllegalStateException("Use setFixedLengthStreamingMode() or "
-                + "setChunkedStreamingMode() for requests larger than 2 GiB.");
-          }
-
-          if (contentLength != -1) {
-            // Buffer a request body of a known length.
-            transport.writeRequestHeaders(networkRequest);
-            requestBodyOut = new RetryableSink((int) contentLength);
-          } else {
-            // Buffer a request body of an unknown length. Don't write request
-            // headers until the entire body is ready; otherwise we can't set the
-            // Content-Length header correctly.
-            requestBodyOut = new RetryableSink();
-          }
-        } else {
-          transport.writeRequestHeaders(networkRequest);
-          requestBodyOut = transport.createRequestBody(networkRequest, contentLength);
+        @Override
+        public BufferedSource source() {
+            return new Buffer();
         }
-      }
+    };
 
-    } else {
-      // We aren't using the network. Recycle a connection we may have inherited from a redirect.
-      if (connection != null) {
-        Internal.instance.recycle(client.getConnectionPool(), connection);
-        connection = null;
-      }
-
-      if (cacheResponse != null) {
-        // We have a valid cached response. Promote it to the user response immediately.
-        this.userResponse = cacheResponse.newBuilder()
-            .request(userRequest)
-            .priorResponse(stripBody(priorResponse))
-            .cacheResponse(stripBody(cacheResponse))
-            .build();
-      } else {
-        // We're forbidden from using the network, and the cache is insufficient.
-        this.userResponse = new Response.Builder()
-            .request(userRequest)
-            .priorResponse(stripBody(priorResponse))
-            .protocol(Protocol.HTTP_1_1)
-            .code(504)
-            .message("Unsatisfiable Request (only-if-cached)")
-            .body(EMPTY_BODY)
-            .build();
-      }
-
-      userResponse = unzip(userResponse);
+    final OkHttpClient client;
+
+    private Connection connection;
+    private Address address;
+    private RouteSelector routeSelector;
+    private Route route;
+    private final Response priorResponse;
+
+    private Transport transport;
+
+    /**
+     * The time when the request headers were written, or -1 if they haven't been written yet.
+     */
+    long sentRequestMillis = -1;
+
+    /**
+     * True if this client added an "Accept-Encoding: gzip" header field and is
+     * therefore responsible for also decompressing the transfer stream.
+     */
+    private boolean transparentGzip;
+
+    /**
+     * True if the request body must be completely buffered before transmission;
+     * false if it can be streamed. Buffering has two advantages: we don't need
+     * the content-length in advance and we can retransmit if necessary. The
+     * upside of streaming is that we can save memory.
+     */
+    public final boolean bufferRequestBody;
+
+    /**
+     * The original application-provided request. Never modified by OkHttp. When
+     * follow-up requests are necessary, they are derived from this request.
+     */
+    private final Request userRequest;
+
+    /**
+     * The request to send on the network, or null for no network request. This is
+     * derived from the user request, and customized to support OkHttp features
+     * like compression and caching.
+     */
+    private Request networkRequest;
+
+    /**
+     * The cached response, or null if the cache doesn't exist or cannot be used
+     * for this request. Conditional caching means this may be non-null even when
+     * the network request is non-null. Never modified by OkHttp.
+     */
+    private Response cacheResponse;
+
+    /**
+     * The user-visible response. This is derived from either the network
+     * response, cache response, or both. It is customized to support OkHttp
+     * features like compression and caching.
+     */
+    private Response userResponse;
+
+    private Sink requestBodyOut;
+    private BufferedSink bufferedRequestBody;
+    private final boolean callerWritesRequestBody;
+    private final boolean forWebSocket;
+
+    /**
+     * The cache request currently being populated from a network response.
+     */
+    private CacheRequest storeRequest;
+    private CacheStrategy cacheStrategy;
+
+    /**
+     * @param request                 the HTTP request without a body. The body must be written via the engine's
+     *                                request body stream.
+     * @param callerWritesRequestBody true for the {@code HttpURLConnection}-style interaction
+     *                                model where control flow is returned to the calling application to write the
+     *                                request body
+     *                                before the response body is readable.
+     * @param connection              the connection used for an intermediate response immediately prior to this
+     *                                request/response pair, such as a same-host redirect. This engine assumes
+     *                                ownership of the
+     *                                connection and must release it when it is unneeded.
+     * @param routeSelector           the route selector used for a failed attempt immediately preceding this
+     */
+    public HttpEngine(OkHttpClient client, Request request, boolean bufferRequestBody,
+                      boolean callerWritesRequestBody, boolean forWebSocket, Connection connection,
+                      RouteSelector routeSelector, RetryableSink requestBodyOut, Response priorResponse) {
+        this.client = client;
+        this.userRequest = request;
+        this.bufferRequestBody = bufferRequestBody;
+        this.callerWritesRequestBody = callerWritesRequestBody;
+        this.forWebSocket = forWebSocket;
+        this.connection = connection;
+        this.routeSelector = routeSelector;
+        this.requestBodyOut = requestBodyOut;
+        this.priorResponse = priorResponse;
+
+        if (connection != null) {
+            Internal.instance.setOwner(connection, this);
+            this.route = connection.getRoute();
+        } else {
+            this.route = null;
+        }
     }
-  }
-
-  private static Response stripBody(Response response) {
-    return response != null && response.body() != null
-        ? response.newBuilder().body(null).build()
-        : response;
-  }
 
-  /** Connect to the origin server either directly or via a proxy. */
-  private void connect() throws IOException {
-    if (connection != null) throw new IllegalStateException();
-
-    if (routeSelector == null) {
-      address = createAddress(client, networkRequest);
-      routeSelector = RouteSelector.get(address, networkRequest, client);
-    }
+    /**
+     * Figures out what the response source will be, and opens a socket to that
+     * source if necessary. Prepares the request headers and gets ready to start
+     * writing the request body if it exists.
+     */
+    public void sendRequest() throws IOException {
+        if (cacheStrategy != null) {
+            return; // Already sent.
+        }
+        if (transport != null) {
+            throw new IllegalStateException();
+        }
 
-    connection = nextConnection();
-    route = connection.getRoute();
-  }
-
-  /**
-   * Returns the next connection to attempt.
-   *
-   * @throws java.util.NoSuchElementException if there are no more routes to attempt.
-   */
-  private Connection nextConnection() throws IOException {
-    Connection connection = createNextConnection();
-    Internal.instance.connectAndSetOwner(client, connection, this, networkRequest);
-    return connection;
-  }
-
-  private Connection createNextConnection() throws IOException {
-    ConnectionPool pool = client.getConnectionPool();
-
-    // Always prefer pooled connections over new connections.
-    for (Connection pooled; (pooled = pool.get(address)) != null; ) {
-      if (networkRequest.method().equals("GET") || Internal.instance.isReadable(pooled)) {
-        return pooled;
-      }
-      pooled.getSocket().close();
-    }
-    Route route = routeSelector.next();
-    return new Connection(pool, route);
-  }
-
-  /**
-   * Called immediately before the transport transmits HTTP request headers.
-   * This is used to observe the sent time should the request be cached.
-   */
-  public void writingRequestHeaders() {
-    if (sentRequestMillis != -1) throw new IllegalStateException();
-    sentRequestMillis = System.currentTimeMillis();
-  }
-
-  boolean permitsRequestBody() {
-    return HttpMethod.permitsRequestBody(userRequest.method());
-  }
-
-  /** Returns the request body or null if this request doesn't have a body. */
-  public Sink getRequestBody() {
-    if (cacheStrategy == null) throw new IllegalStateException();
-    return requestBodyOut;
-  }
-
-  public BufferedSink getBufferedRequestBody() {
-    BufferedSink result = bufferedRequestBody;
-    if (result != null) return result;
-    Sink requestBody = getRequestBody();
-    return requestBody != null
-        ? (bufferedRequestBody = Okio.buffer(requestBody))
-        : null;
-  }
-
-  public boolean hasResponse() {
-    return userResponse != null;
-  }
-
-  public Request getRequest() {
-    return userRequest;
-  }
-
-  /** Returns the engine's response. */
-  // TODO: the returned body will always be null.
-  public Response getResponse() {
-    if (userResponse == null) throw new IllegalStateException();
-    return userResponse;
-  }
-
-  public Connection getConnection() {
-    return connection;
-  }
-
-  /**
-   * Report and attempt to recover from {@code e}. Returns a new HTTP engine
-   * that should be used for the retry if {@code e} is recoverable, or null if
-   * the failure is permanent. Requests with a body can only be recovered if the
-   * body is buffered.
-   */
-  public HttpEngine recover(IOException e, Sink requestBodyOut) {
-    if (routeSelector != null && connection != null) {
-      connectFailed(routeSelector, e);
-    }
+        //填充默认的请求头部和事务。
+        Request request = networkRequest(userRequest);
 
-    boolean canRetryRequestBody = requestBodyOut == null || requestBodyOut instanceof RetryableSink;
-    if (routeSelector == null && connection == null // No connection.
-        || routeSelector != null && !routeSelector.hasNext() // No more routes to attempt.
-        || !isRecoverable(e)
-        || !canRetryRequestBody) {
-      return null;
-    }
+        //下面一行很重要,这个方法会去获取client中的Cache。同时Cache在初始化的时候会去读取缓存目录中关于曾经请求过的所有信息。
+        InternalCache responseCache = Internal.instance.internalCache(client);
+        Response cacheCandidate = responseCache != null ? responseCache.get(request) : null;
 
-    Connection connection = close();
+        long now = System.currentTimeMillis();
+        //缓存策略中的各种配置的封装
+        cacheStrategy = new CacheStrategy.Factory(now, request, cacheCandidate).get();
+        networkRequest = cacheStrategy.networkRequest;
+        cacheResponse = cacheStrategy.cacheResponse;
 
-    // For failure recovery, use the same route selector with a new connection.
-    return new HttpEngine(client, userRequest, bufferRequestBody, callerWritesRequestBody,
-        forWebSocket, connection, routeSelector, (RetryableSink) requestBodyOut, priorResponse);
-  }
+        if (responseCache != null) {
+            //记录当前请求是来至网络还是命中了缓存
+            responseCache.trackResponse(cacheStrategy);
+        }
 
-  private void connectFailed(RouteSelector routeSelector, IOException e) {
-    // If this is a recycled connection, don't count its failure against the route.
-    if (Internal.instance.recycleCount(connection) > 0) return;
-    Route failedRoute = connection.getRoute();
-    routeSelector.connectFailed(failedRoute, e);
-  }
+        if (cacheCandidate != null && cacheResponse == null) {
+            closeQuietly(cacheCandidate.body()); // The cache candidate wasn't applicable. Close it.
+        }
 
-  public HttpEngine recover(IOException e) {
-    return recover(e, requestBodyOut);
-  }
+        if (networkRequest != null) {
+            // Open a connection unless we inherited one from a redirect.
+            if (connection == null) {
+                //连接到服务器、重定向服务器或者通过一个代理Connect to the origin server either directly or via a proxy.
+                connect();
+            }
+
+            //通过Connection创建一个SpdyTransport或者HttpTransport
+            transport = Internal.instance.newTransport(connection, this);
+
+            // If the caller's control flow writes the request body, we need to create that stream
+            // immediately. And that means we need to immediately write the request headers, so we can
+            // start streaming the request body. (We may already have a request body if we're retrying a
+            // failed POST.)
+            if (callerWritesRequestBody && permitsRequestBody() && requestBodyOut == null) {
+                long contentLength = OkHeaders.contentLength(request);
+                if (bufferRequestBody) {
+                    if (contentLength > Integer.MAX_VALUE) {
+                        throw new IllegalStateException("Use setFixedLengthStreamingMode() or "
+                                + "setChunkedStreamingMode() for requests larger than 2 GiB.");
+                    }
+
+                    if (contentLength != -1) {
+                        // Buffer a request body of a known length.
+                        transport.writeRequestHeaders(networkRequest);
+                        requestBodyOut = new RetryableSink((int) contentLength);
+                    } else {
+                        // Buffer a request body of an unknown length. Don't write request
+                        // headers until the entire body is ready; otherwise we can't set the
+                        // Content-Length header correctly.
+                        requestBodyOut = new RetryableSink();
+                    }
+                } else {
+                    transport.writeRequestHeaders(networkRequest);
+                    requestBodyOut = transport.createRequestBody(networkRequest, contentLength);
+                }
+            }
 
-  private boolean isRecoverable(IOException e) {
-    // If the application has opted-out of recovery, don't recover.
-    if (!client.getRetryOnConnectionFailure()) {
-      return false;
+        } else {
+            // We aren't using the network. Recycle a connection we may have inherited from a redirect.
+            if (connection != null) {
+                Internal.instance.recycle(client.getConnectionPool(), connection);
+                connection = null;
+            }
+
+            if (cacheResponse != null) {
+                // We have a valid cached response. Promote it to the user response immediately.
+                this.userResponse = cacheResponse.newBuilder()
+                        .request(userRequest)
+                        .priorResponse(stripBody(priorResponse))
+                        .cacheResponse(stripBody(cacheResponse))
+                        .build();
+            } else {
+                // We're forbidden from using the network, and the cache is insufficient.
+                this.userResponse = new Response.Builder()
+                        .request(userRequest)
+                        .priorResponse(stripBody(priorResponse))
+                        .protocol(Protocol.HTTP_1_1)
+                        .code(504)
+                        .message("Unsatisfiable Request (only-if-cached)")
+                        .body(EMPTY_BODY)
+                        .build();
+            }
+
+            userResponse = unzip(userResponse);
+        }
     }
 
-    // If the problem was a CertificateException from the X509TrustManager,
-    // do not retry, we didn't have an abrupt server-initiated exception.
-    if (e instanceof SSLPeerUnverifiedException
-        || (e instanceof SSLHandshakeException && e.getCause() instanceof CertificateException)) {
-      return false;
+    private static Response stripBody(Response response) {
+        return response != null && response.body() != null
+                ? response.newBuilder().body(null).build()
+                : response;
     }
 
-    // If there was a protocol problem, don't recover.
-    if (e instanceof ProtocolException) {
-      return false;
+    /**
+     * Connect to the origin server either directly or via a proxy.
+     */
+    private void connect() throws IOException {
+        if (connection != null) {
+            throw new IllegalStateException();
+        }
+
+        if (routeSelector == null) {
+            address = createAddress(client, networkRequest);
+            routeSelector = RouteSelector.get(address, networkRequest, client);
+        }
+
+        connection = nextConnection();
+        route = connection.getRoute();
     }
 
-    // If there was an interruption or timeout, don't recover.
-    if (e instanceof InterruptedIOException) {
-      return false;
+    /**
+     * Returns the next connection to attempt.
+     *
+     * @throws java.util.NoSuchElementException if there are no more routes to attempt.
+     */
+    private Connection nextConnection() throws IOException {
+        Connection connection = createNextConnection();
+        Internal.instance.connectAndSetOwner(client, connection, this, networkRequest);
+        return connection;
     }
 
-    return true;
-  }
-
-  /**
-   * Returns the route used to retrieve the response. Null if we haven't
-   * connected yet, or if no connection was necessary.
-   */
-  public Route getRoute() {
-    return route;
-  }
-
-  private void maybeCache() throws IOException {
-    InternalCache responseCache = Internal.instance.internalCache(client);
-    if (responseCache == null) return;
-
-    // Should we cache this response for this request?
-    if (!CacheStrategy.isCacheable(userResponse, networkRequest)) {
-      if (HttpMethod.invalidatesCache(networkRequest.method())) {
-        try {
-          responseCache.remove(networkRequest);
-        } catch (IOException ignored) {
-          // The cache cannot be written.
+    private Connection createNextConnection() throws IOException {
+        ConnectionPool pool = client.getConnectionPool();
+
+        // Always prefer pooled connections over new connections.
+        for (Connection pooled; (pooled = pool.get(address)) != null; ) {
+            if (networkRequest.method().equals("GET") || Internal.instance.isReadable(pooled)) {
+                return pooled;
+            }
+            pooled.getSocket().close();
         }
-      }
-      return;
+        Route route = routeSelector.next();
+        return new Connection(pool, route);
     }
 
-    // Offer this request to the cache.
-    storeRequest = responseCache.put(stripBody(userResponse));
-  }
-
-  /**
-   * Configure the socket connection to be either pooled or closed when it is
-   * either exhausted or closed. If it is unneeded when this is called, it will
-   * be released immediately.
-   */
-  public void releaseConnection() throws IOException {
-    if (transport != null && connection != null) {
-      transport.releaseConnectionOnIdle();
-    }
-    connection = null;
-  }
-
-  /**
-   * Immediately closes the socket connection if it's currently held by this
-   * engine. Use this to interrupt an in-flight request from any thread. It's
-   * the caller's responsibility to close the request body and response body
-   * streams; otherwise resources may be leaked.
-   */
-  public void disconnect() {
-    if (transport != null) {
-      try {
-        transport.disconnect(this);
-      } catch (IOException ignored) {
-      }
-    }
-  }
-
-  /**
-   * Release any resources held by this engine. If a connection is still held by
-   * this engine, it is returned.
-   */
-  public Connection close() {
-    if (bufferedRequestBody != null) {
-      // This also closes the wrapped requestBodyOut.
-      closeQuietly(bufferedRequestBody);
-    } else if (requestBodyOut != null) {
-      closeQuietly(requestBodyOut);
+    /**
+     * Called immediately before the transport transmits HTTP request headers.
+     * This is used to observe the sent time should the request be cached.
+     */
+    public void writingRequestHeaders() {
+        if (sentRequestMillis != -1) {
+            throw new IllegalStateException();
+        }
+        sentRequestMillis = System.currentTimeMillis();
     }
 
-    // If this engine never achieved a response body, its connection cannot be reused.
-    if (userResponse == null) {
-      if (connection != null) closeQuietly(connection.getSocket()); // TODO: does this break SPDY?
-      connection = null;
-      return null;
+    boolean permitsRequestBody() {
+        return HttpMethod.permitsRequestBody(userRequest.method());
     }
 
-    // Close the response body. This will recycle the connection if it is eligible.
-    closeQuietly(userResponse.body());
-
-    // Close the connection if it cannot be reused.
-    if (transport != null && connection != null && !transport.canReuseConnection()) {
-      closeQuietly(connection.getSocket());
-      connection = null;
-      return null;
+    /**
+     * Returns the request body or null if this request doesn't have a body.
+     */
+    public Sink getRequestBody() {
+        if (cacheStrategy == null) {
+            throw new IllegalStateException();
+        }
+        return requestBodyOut;
     }
 
-    // Prevent this engine from disconnecting a connection it no longer owns.
-    if (connection != null && !Internal.instance.clearOwner(connection)) {
-      connection = null;
+    public BufferedSink getBufferedRequestBody() {
+        BufferedSink result = bufferedRequestBody;
+        if (result != null) {
+            return result;
+        }
+        Sink requestBody = getRequestBody();
+        return requestBody != null
+                ? (bufferedRequestBody = Okio.buffer(requestBody))
+                : null;
     }
 
-    Connection result = connection;
-    connection = null;
-    return result;
-  }
-
-  /**
-   * Returns a new response that does gzip decompression on {@code response}, if transparent gzip
-   * was both offered by OkHttp and used by the origin server.
-   *
-   * <p>In addition to decompression, this will also strip the corresponding headers. We strip the
-   * Content-Encoding header to prevent the application from attempting to double decompress. We
-   * strip the Content-Length header because it is the length of the compressed content, but the
-   * application is only interested in the length of the uncompressed content.
-   *
-   * <p>This method should only be used for non-empty response bodies. Response codes like "304 Not
-   * Modified" can include "Content-Encoding: gzip" without a response body and we will crash if we
-   * attempt to decompress the zero-byte source.
-   */
-  private Response unzip(final Response response) throws IOException {
-    if (!transparentGzip || !"gzip".equalsIgnoreCase(userResponse.header("Content-Encoding"))) {
-      return response;
+    public boolean hasResponse() {
+        return userResponse != null;
     }
 
-    if (response.body() == null) {
-      return response;
+    public Request getRequest() {
+        return userRequest;
     }
 
-    GzipSource responseBody = new GzipSource(response.body().source());
-    Headers strippedHeaders = response.headers().newBuilder()
-        .removeAll("Content-Encoding")
-        .removeAll("Content-Length")
-        .build();
-    return response.newBuilder()
-        .headers(strippedHeaders)
-        .body(new RealResponseBody(strippedHeaders, Okio.buffer(responseBody)))
-        .build();
-  }
-
-  /**
-   * Returns true if the response must have a (possibly 0-length) body.
-   * See RFC 2616 section 4.3.
-   */
-  public static boolean hasBody(Response response) {
-    // HEAD requests never yield a body regardless of the response headers.
-    if (response.request().method().equals("HEAD")) {
-      return false;
+    /**
+     * Returns the engine's response.
+     */
+    // TODO: the returned body will always be null.
+    public Response getResponse() {
+        if (userResponse == null) {
+            throw new IllegalStateException();
+        }
+        return userResponse;
     }
 
-    int responseCode = response.code();
-    if ((responseCode < HTTP_CONTINUE || responseCode >= 200)
-        && responseCode != HTTP_NO_CONTENT
-        && responseCode != HTTP_NOT_MODIFIED) {
-      return true;
+    public Connection getConnection() {
+        return connection;
     }
 
-    // If the Content-Length or Transfer-Encoding headers disagree with the
-    // response code, the response is malformed. For best compatibility, we
-    // honor the headers.
-    if (OkHeaders.contentLength(response) != -1
-        || "chunked".equalsIgnoreCase(response.header("Transfer-Encoding"))) {
-      return true;
-    }
+    /**
+     * Report and attempt to recover from {@code e}. Returns a new HTTP engine
+     * that should be used for the retry if {@code e} is recoverable, or null if
+     * the failure is permanent. Requests with a body can only be recovered if the
+     * body is buffered.
+     */
+    public HttpEngine recover(IOException e, Sink requestBodyOut) {
+        if (routeSelector != null && connection != null) {
+            connectFailed(routeSelector, e);
+        }
 
-    return false;
-  }
+        boolean canRetryRequestBody = requestBodyOut == null || requestBodyOut instanceof RetryableSink;
+        if (routeSelector == null && connection == null // No connection.
+                || routeSelector != null && !routeSelector.hasNext() // No more routes to attempt.
+                || !isRecoverable(e)
+                || !canRetryRequestBody) {
+            return null;
+        }
 
-  /**
-   * Populates request with defaults and cookies.
-   *
-   * <p>This client doesn't specify a default {@code Accept} header because it
-   * doesn't know what content types the application is interested in.
-   */
-  private Request networkRequest(Request request) throws IOException {
-    Request.Builder result = request.newBuilder();
+        Connection connection = close();
 
-    if (request.header("Host") == null) {
-      result.header("Host", hostHeader(request.url()));
+        // For failure recovery, use the same route selector with a new connection.
+        return new HttpEngine(client, userRequest, bufferRequestBody, callerWritesRequestBody,
+                forWebSocket, connection, routeSelector, (RetryableSink) requestBodyOut, priorResponse);
     }
 
-    if ((connection == null || connection.getProtocol() != Protocol.HTTP_1_0)
-        && request.header("Connection") == null) {
-      result.header("Connection", "Keep-Alive");
+    private void connectFailed(RouteSelector routeSelector, IOException e) {
+        // If this is a recycled connection, don't count its failure against the route.
+        if (Internal.instance.recycleCount(connection) > 0) {
+            return;
+        }
+        Route failedRoute = connection.getRoute();
+        routeSelector.connectFailed(failedRoute, e);
     }
 
-    if (request.header("Accept-Encoding") == null) {
-      transparentGzip = true;
-      result.header("Accept-Encoding", "gzip");
+    public HttpEngine recover(IOException e) {
+        return recover(e, requestBodyOut);
     }
 
-    CookieHandler cookieHandler = client.getCookieHandler();
-    if (cookieHandler != null) {
-      // Capture the request headers added so far so that they can be offered to the CookieHandler.
-      // This is mostly to stay close to the RI; it is unlikely any of the headers above would
-      // affect cookie choice besides "Host".
-      Map<String, List<String>> headers = OkHeaders.toMultimap(result.build().headers(), null);
+    private boolean isRecoverable(IOException e) {
+        // If the application has opted-out of recovery, don't recover.
+        if (!client.getRetryOnConnectionFailure()) {
+            return false;
+        }
 
-      Map<String, List<String>> cookies = cookieHandler.get(request.uri(), headers);
+        // If the problem was a CertificateException from the X509TrustManager,
+        // do not retry, we didn't have an abrupt server-initiated exception.
+        if (e instanceof SSLPeerUnverifiedException
+                || (e instanceof SSLHandshakeException && e.getCause() instanceof CertificateException)) {
+            return false;
+        }
 
-      // Add any new cookies to the request.
-      OkHeaders.addCookies(result, cookies);
-    }
+        // If there was a protocol problem, don't recover.
+        if (e instanceof ProtocolException) {
+            return false;
+        }
+
+        // If there was an interruption or timeout, don't recover.
+        if (e instanceof InterruptedIOException) {
+            return false;
+        }
 
-    if (request.header("User-Agent") == null) {
-      result.header("User-Agent", /*Version.userAgent()*/"");
+        return true;
     }
 
-    return result.build();
-  }
-
-  public static String hostHeader(URL url) {
-    return getEffectivePort(url) != getDefaultPort(url.getProtocol())
-        ? url.getHost() + ":" + url.getPort()
-        : url.getHost();
-  }
-
-  /**
-   * Flushes the remaining request header and body, parses the HTTP response
-   * headers and starts reading the HTTP response body if it exists.
-   */
-  public void readResponse() throws IOException {
-    if (userResponse != null) {
-      return; // Already ready.
+    /**
+     * Returns the route used to retrieve the response. Null if we haven't
+     * connected yet, or if no connection was necessary.
+     */
+    public Route getRoute() {
+        return route;
     }
-    if (networkRequest == null && cacheResponse == null) {
-      throw new IllegalStateException("call sendRequest() first!");
+
+    private void maybeCache() throws IOException {
+        InternalCache responseCache = Internal.instance.internalCache(client);
+        if (responseCache == null) {
+            return;
+        }
+
+        // Should we cache this response for this request?
+        if (!CacheStrategy.isCacheable(userResponse, networkRequest)) {
+            if (HttpMethod.invalidatesCache(networkRequest.method())) {
+                try {
+                    responseCache.remove(networkRequest);
+                } catch (IOException ignored) {
+                    // The cache cannot be written.
+                }
+            }
+            return;
+        }
+
+        // Offer this request to the cache.
+        storeRequest = responseCache.put(stripBody(userResponse));
     }
-    if (networkRequest == null) {
-      return; // No network response to read.
+
+    /**
+     * Configure the socket connection to be either pooled or closed when it is
+     * either exhausted or closed. If it is unneeded when this is called, it will
+     * be released immediately.
+     */
+    public void releaseConnection() throws IOException {
+        if (transport != null && connection != null) {
+            transport.releaseConnectionOnIdle();
+        }
+        connection = null;
     }
 
-    Response networkResponse;
-
-    if (forWebSocket) {
-      transport.writeRequestHeaders(networkRequest);
-      networkResponse = readNetworkResponse();
-
-    } else if (!callerWritesRequestBody) {
-      networkResponse = new NetworkInterceptorChain(0, networkRequest).proceed(networkRequest);
-
-    } else {
-      // Emit the request body's buffer so that everything is in requestBodyOut.
-      if (bufferedRequestBody != null && bufferedRequestBody.buffer().size() > 0) {
-        bufferedRequestBody.emit();
-      }
-
-      // Emit the request headers if we haven't yet. We might have just learned the Content-Length.
-      if (sentRequestMillis == -1) {
-        if (OkHeaders.contentLength(networkRequest) == -1
-            && requestBodyOut instanceof RetryableSink) {
-          long contentLength = ((RetryableSink) requestBodyOut).contentLength();
-          networkRequest = networkRequest.newBuilder()
-              .header("Content-Length", Long.toString(contentLength))
-              .build();
+    /**
+     * Immediately closes the socket connection if it's currently held by this
+     * engine. Use this to interrupt an in-flight request from any thread. It's
+     * the caller's responsibility to close the request body and response body
+     * streams; otherwise resources may be leaked.
+     */
+    public void disconnect() {
+        if (transport != null) {
+            try {
+                transport.disconnect(this);
+            } catch (IOException ignored) {
+            }
         }
-        transport.writeRequestHeaders(networkRequest);
-      }
+    }
 
-      // Write the request body to the socket.
-      if (requestBodyOut != null) {
+    /**
+     * Release any resources held by this engine. If a connection is still held by
+     * this engine, it is returned.
+     */
+    public Connection close() {
         if (bufferedRequestBody != null) {
-          // This also closes the wrapped requestBodyOut.
-          bufferedRequestBody.close();
-        } else {
-          requestBodyOut.close();
+            // This also closes the wrapped requestBodyOut.
+            closeQuietly(bufferedRequestBody);
+        } else if (requestBodyOut != null) {
+            closeQuietly(requestBodyOut);
         }
-        if (requestBodyOut instanceof RetryableSink) {
-          transport.writeRequestBody((RetryableSink) requestBodyOut);
+
+        // If this engine never achieved a response body, its connection cannot be reused.
+        if (userResponse == null) {
+            if (connection != null) {
+                closeQuietly(connection.getSocket()); // TODO: does this break SPDY?
+            }
+            connection = null;
+            return null;
         }
-      }
 
-      networkResponse = readNetworkResponse();
-    }
+        // Close the response body. This will recycle the connection if it is eligible.
+        closeQuietly(userResponse.body());
 
-    receiveHeaders(networkResponse.headers());
-
-    // If we have a cache response too, then we're doing a conditional get.
-    if (cacheResponse != null) {
-      if (validate(cacheResponse, networkResponse)) {
-        userResponse = cacheResponse.newBuilder()
-            .request(userRequest)
-            .priorResponse(stripBody(priorResponse))
-            .headers(combine(cacheResponse.headers(), networkResponse.headers()))
-            .cacheResponse(stripBody(cacheResponse))
-            .networkResponse(stripBody(networkResponse))
-            .build();
-        networkResponse.body().close();
-        releaseConnection();
-
-        // Update the cache after combining headers but before stripping the
-        // Content-Encoding header (as performed by initContentStream()).
-        InternalCache responseCache = Internal.instance.internalCache(client);
-        responseCache.trackConditionalCacheHit();
-        responseCache.update(cacheResponse, stripBody(userResponse));
-        userResponse = unzip(userResponse);
-        return;
-      } else {
-        closeQuietly(cacheResponse.body());
-      }
-    }
+        // Close the connection if it cannot be reused.
+        if (transport != null && connection != null && !transport.canReuseConnection()) {
+            closeQuietly(connection.getSocket());
+            connection = null;
+            return null;
+        }
 
-    userResponse = networkResponse.newBuilder()
-        .request(userRequest)
-        .priorResponse(stripBody(priorResponse))
-        .cacheResponse(stripBody(cacheResponse))
-        .networkResponse(stripBody(networkResponse))
-        .build();
+        // Prevent this engine from disconnecting a connection it no longer owns.
+        if (connection != null && !Internal.instance.clearOwner(connection)) {
+            connection = null;
+        }
 
-    if (hasBody(userResponse)) {
-      maybeCache();
-      userResponse = unzip(cacheWritingResponse(storeRequest, userResponse));
+        Connection result = connection;
+        connection = null;
+        return result;
     }
-  }
 
-  class NetworkInterceptorChain implements Interceptor.Chain {
-    private final int index;
-    private final Request request;
-    private int calls;
+    /**
+     * Returns a new response that does gzip decompression on {@code response}, if transparent gzip
+     * was both offered by OkHttp and used by the origin server.
+     * <p/>
+     * <p>In addition to decompression, this will also strip the corresponding headers. We strip the
+     * Content-Encoding header to prevent the application from attempting to double decompress. We
+     * strip the Content-Length header because it is the length of the compressed content, but the
+     * application is only interested in the length of the uncompressed content.
+     * <p/>
+     * <p>This method should only be used for non-empty response bodies. Response codes like "304 Not
+     * Modified" can include "Content-Encoding: gzip" without a response body and we will crash if we
+     * attempt to decompress the zero-byte source.
+     */
+    private Response unzip(final Response response) throws IOException {
+        if (!transparentGzip || !"gzip".equalsIgnoreCase(userResponse.header("Content-Encoding"))) {
+            return response;
+        }
 
-    NetworkInterceptorChain(int index, Request request) {
-      this.index = index;
-      this.request = request;
-    }
+        if (response.body() == null) {
+            return response;
+        }
 
-    @Override public Connection connection() {
-      return connection;
+        GzipSource responseBody = new GzipSource(response.body().source());
+        Headers strippedHeaders = response.headers().newBuilder()
+                .removeAll("Content-Encoding")
+                .removeAll("Content-Length")
+                .build();
+        return response.newBuilder()
+                .headers(strippedHeaders)
+                .body(new RealResponseBody(strippedHeaders, Okio.buffer(responseBody)))
+                .build();
     }
 
-    @Override public Request request() {
-      return request;
-    }
+    /**
+     * Returns true if the response must have a (possibly 0-length) body.
+     * See RFC 2616 section 4.3.
+     */
+    public static boolean hasBody(Response response) {
+        // HEAD requests never yield a body regardless of the response headers.
+        if (response.request().method().equals("HEAD")) {
+            return false;
+        }
+
+        int responseCode = response.code();
+        if ((responseCode < HTTP_CONTINUE || responseCode >= 200)
+                && responseCode != HTTP_NO_CONTENT
+                && responseCode != HTTP_NOT_MODIFIED) {
+            return true;
+        }
 
-    @Override public Response proceed(Request request) throws IOException {
-      calls++;
+        // If the Content-Length or Transfer-Encoding headers disagree with the
+        // response code, the response is malformed. For best compatibility, we
+        // honor the headers.
+        if (OkHeaders.contentLength(response) != -1
+                || "chunked".equalsIgnoreCase(response.header("Transfer-Encoding"))) {
+            return true;
+        }
 
-      if (index > 0) {
-        Interceptor caller = client.networkInterceptors().get(index - 1);
-        Address address = connection().getRoute().getAddress();
+        return false;
+    }
 
-        // Confirm that the interceptor uses the connection we've already prepared.
-        if (!request.url().getHost().equals(address.getUriHost())
-            || getEffectivePort(request.url()) != address.getUriPort()) {
-          throw new IllegalStateException("network interceptor " + caller
-              + " must retain the same host and port");
+    /**
+     * Populates request with defaults and cookies.
+     * <p/>
+     * <p>This client doesn't specify a default {@code Accept} header because it
+     * doesn't know what content types the application is interested in.
+     */
+    private Request networkRequest(Request request) throws IOException {
+        Request.Builder result = request.newBuilder();
+
+        if (request.header("Host") == null) {
+            result.header("Host", hostHeader(request.url()));
         }
 
-        // Confirm that this is the interceptor's first call to chain.proceed().
-        if (calls > 1) {
-          throw new IllegalStateException("network interceptor " + caller
-              + " must call proceed() exactly once");
+        if ((connection == null || connection.getProtocol() != Protocol.HTTP_1_0)
+                && request.header("Connection") == null) {
+            result.header("Connection", "Keep-Alive");
         }
-      }
-
-      if (index < client.networkInterceptors().size()) {
-        // There's another interceptor in the chain. Call that.
-        NetworkInterceptorChain chain = new NetworkInterceptorChain(index + 1, request);
-        Interceptor interceptor = client.networkInterceptors().get(index);
-        Response interceptedResponse = interceptor.intercept(chain);
-
-        // Confirm that the interceptor made the required call to chain.proceed().
-        if (chain.calls != 1) {
-          throw new IllegalStateException("network interceptor " + interceptor
-              + " must call proceed() exactly once");
+
+        if (request.header("Accept-Encoding") == null) {
+            transparentGzip = true;
+            result.header("Accept-Encoding", "gzip");
         }
 
-        return interceptedResponse;
-      }
+        CookieHandler cookieHandler = client.getCookieHandler();
+        if (cookieHandler != null) {
+            // Capture the request headers added so far so that they can be offered to the CookieHandler.
+            // This is mostly to stay close to the RI; it is unlikely any of the headers above would
+            // affect cookie choice besides "Host".
+            Map<String, List<String>> headers = OkHeaders.toMultimap(result.build().headers(), null);
 
-      transport.writeRequestHeaders(request);
+            Map<String, List<String>> cookies = cookieHandler.get(request.uri(), headers);
+
+            // Add any new cookies to the request.
+            OkHeaders.addCookies(result, cookies);
+        }
 
-      if (permitsRequestBody() && request.body() != null) {
-        Sink requestBodyOut = transport.createRequestBody(request, request.body().contentLength());
-        BufferedSink bufferedRequestBody = Okio.buffer(requestBodyOut);
-        request.body().writeTo(bufferedRequestBody);
-        bufferedRequestBody.close();
-      }
+        if (request.header("User-Agent") == null) {
+            result.header("User-Agent", /*Version.userAgent()*/"");
+        }
 
-      return readNetworkResponse();
+        return result.build();
     }
-  }
-
-  private Response readNetworkResponse() throws IOException {
-    transport.finishRequest();
-
-    Response networkResponse = transport.readResponseHeaders()
-        .request(networkRequest)
-        .handshake(connection.getHandshake())
-        .header(OkHeaders.SENT_MILLIS, Long.toString(sentRequestMillis))
-        .header(OkHeaders.RECEIVED_MILLIS, Long.toString(System.currentTimeMillis()))
-        .build();
-
-    if (!forWebSocket) {
-      networkResponse = networkResponse.newBuilder()
-          .body(transport.openResponseBody(networkResponse))
-          .build();
+
+    public static String hostHeader(URL url) {
+        return getEffectivePort(url) != getDefaultPort(url.getProtocol())
+                ? url.getHost() + ":" + url.getPort()
+                : url.getHost();
     }
 
-    Internal.instance.setProtocol(connection, networkResponse.protocol());
-    return networkResponse;
-  }
-
-  /**
-   * Returns a new source that writes bytes to {@code cacheRequest} as they are read by the source
-   * consumer. This is careful to discard bytes left over when the stream is closed; otherwise we
-   * may never exhaust the source stream and therefore not complete the cached response.
-   */
-  private Response cacheWritingResponse(final CacheRequest cacheRequest, Response response)
-      throws IOException {
-    // Some apps return a null body; for compatibility we treat that like a null cache request.
-    if (cacheRequest == null) return response;
-    Sink cacheBodyUnbuffered = cacheRequest.body();
-    if (cacheBodyUnbuffered == null) return response;
-
-    final BufferedSource source = response.body().source();
-    final BufferedSink cacheBody = Okio.buffer(cacheBodyUnbuffered);
-
-    Source cacheWritingSource = new Source() {
-      boolean cacheRequestClosed;
-
-      @Override public long read(Buffer sink, long byteCount) throws IOException {
-        long bytesRead;
-        try {
-          bytesRead = source.read(sink, byteCount);
-        } catch (IOException e) {
-          if (!cacheRequestClosed) {
-            cacheRequestClosed = true;
-            cacheRequest.abort(); // Failed to write a complete cache response.
-          }
-          throw e;
+    /**
+     * Flushes the remaining request header and body, parses the HTTP response
+     * headers and starts reading the HTTP response body if it exists.
+     */
+    public void readResponse() throws IOException {
+        if (userResponse != null) {
+            return; // Already ready.
         }
-
-        if (bytesRead == -1) {
-          if (!cacheRequestClosed) {
-            cacheRequestClosed = true;
-            cacheBody.close(); // The cache response is complete!
-          }
-          return -1;
+        if (networkRequest == null && cacheResponse == null) {
+            throw new IllegalStateException("call sendRequest() first!");
+        }
+        if (networkRequest == null) {
+            return; // No network response to read.
         }
 
-        sink.copyTo(cacheBody.buffer(), sink.size() - bytesRead, bytesRead);
-        cacheBody.emitCompleteSegments();
-        return bytesRead;
-      }
+        Response networkResponse;
 
-      @Override public Timeout timeout() {
-        return source.timeout();
-      }
+        if (forWebSocket) {
+            transport.writeRequestHeaders(networkRequest);
+            networkResponse = readNetworkResponse();
+        } else if (!callerWritesRequestBody) {
+            //这里主要是看当前的请求body，其实真正请求是在这里发生的。
+            // 在readNetworkResponse()方法中执行transport.finishRequest()
+            // 这里可以看一下该方法内部会调用到HttpConnection.flush()方法
+            networkResponse = new NetworkInterceptorChain(0, networkRequest).proceed(networkRequest);
+        } else {
+            // Emit the request body's buffer so that everything is in requestBodyOut.
+            if (bufferedRequestBody != null && bufferedRequestBody.buffer().size() > 0) {
+                bufferedRequestBody.emit();
+            }
+
+            // Emit the request headers if we haven't yet. We might have just learned the Content-Length.
+            if (sentRequestMillis == -1) {
+                if (OkHeaders.contentLength(networkRequest) == -1
+                        && requestBodyOut instanceof RetryableSink) {
+                    long contentLength = ((RetryableSink) requestBodyOut).contentLength();
+                    networkRequest = networkRequest.newBuilder()
+                            .header("Content-Length", Long.toString(contentLength))
+                            .build();
+                }
+                transport.writeRequestHeaders(networkRequest);
+            }
+
+            // Write the request body to the socket.
+            if (requestBodyOut != null) {
+                if (bufferedRequestBody != null) {
+                    // This also closes the wrapped requestBodyOut.
+                    bufferedRequestBody.close();
+                } else {
+                    requestBodyOut.close();
+                }
+                if (requestBodyOut instanceof RetryableSink) {
+                    transport.writeRequestBody((RetryableSink) requestBodyOut);
+                }
+            }
+
+            networkResponse = readNetworkResponse();
+        }
 
-      @Override public void close() throws IOException {
-        if (!cacheRequestClosed
-            && !Util.discard(this, Transport.DISCARD_STREAM_TIMEOUT_MILLIS, MILLISECONDS)) {
-          cacheRequestClosed = true;
-          cacheRequest.abort();
+        receiveHeaders(networkResponse.headers());
+
+        // If we have a cache response too, then we're doing a conditional get.
+        if (cacheResponse != null) {
+            if (validate(cacheResponse, networkResponse)) {
+                userResponse = cacheResponse.newBuilder()
+                        .request(userRequest)
+                        .priorResponse(stripBody(priorResponse))
+                        .headers(combine(cacheResponse.headers(), networkResponse.headers()))
+                        .cacheResponse(stripBody(cacheResponse))
+                        .networkResponse(stripBody(networkResponse))
+                        .build();
+                networkResponse.body().close();
+                releaseConnection();
+
+                // Update the cache after combining headers but before stripping the
+                // Content-Encoding header (as performed by initContentStream()).
+                InternalCache responseCache = Internal.instance.internalCache(client);
+                responseCache.trackConditionalCacheHit();
+                responseCache.update(cacheResponse, stripBody(userResponse));
+                userResponse = unzip(userResponse);
+                return;
+            } else {
+                closeQuietly(cacheResponse.body());
+            }
         }
-        source.close();
-      }
-    };
 
-    return response.newBuilder()
-        .body(new RealResponseBody(response.headers(), Okio.buffer(cacheWritingSource)))
-        .build();
-  }
-
-  /**
-   * Returns true if {@code cached} should be used; false if {@code network}
-   * response should be used.
-   */
-  private static boolean validate(Response cached, Response network) {
-    if (network.code() == HTTP_NOT_MODIFIED) {
-      return true;
+        userResponse = networkResponse.newBuilder()
+                .request(userRequest)
+                .priorResponse(stripBody(priorResponse))
+                .cacheResponse(stripBody(cacheResponse))
+                .networkResponse(stripBody(networkResponse))
+                .build();
+
+        //发起缓存的地方
+        if (hasBody(userResponse)) {
+            maybeCache();
+            userResponse = unzip(cacheWritingResponse(storeRequest, userResponse));
+        }
     }
 
-    // The HTTP spec says that if the network's response is older than our
-    // cached response, we may return the cache's response. Like Chrome (but
-    // unlike Firefox), this client prefers to return the newer response.
-    Date lastModified = cached.headers().getDate("Last-Modified");
-    if (lastModified != null) {
-      Date networkLastModified = network.headers().getDate("Last-Modified");
-      if (networkLastModified != null
-          && networkLastModified.getTime() < lastModified.getTime()) {
-        return true;
-      }
-    }
+    class NetworkInterceptorChain implements Interceptor.Chain {
+        private final int index;
+        private final Request request;
+        private int calls;
+
+        NetworkInterceptorChain(int index, Request request) {
+            this.index = index;
+            this.request = request;
+        }
+
+        @Override
+        public Connection connection() {
+            return connection;
+        }
+
+        @Override
+        public Request request() {
+            return request;
+        }
 
-    return false;
-  }
-
-  /**
-   * Combines cached headers with a network headers as defined by RFC 2616,
-   * 13.5.3.
-   */
-  private static Headers combine(Headers cachedHeaders, Headers networkHeaders) throws IOException {
-    Headers.Builder result = new Headers.Builder();
-
-    for (int i = 0, size = cachedHeaders.size(); i < size; i++) {
-      String fieldName = cachedHeaders.name(i);
-      String value = cachedHeaders.value(i);
-      if ("Warning".equalsIgnoreCase(fieldName) && value.startsWith("1")) {
-        continue; // Drop 100-level freshness warnings.
-      }
-      if (!OkHeaders.isEndToEnd(fieldName) || networkHeaders.get(fieldName) == null) {
-        result.add(fieldName, value);
-      }
+        @Override
+        public Response proceed(Request request) throws IOException {
+            calls++;
+
+            if (index > 0) {
+                Interceptor caller = client.networkInterceptors().get(index - 1);
+                Address address = connection().getRoute().getAddress();
+
+                // Confirm that the interceptor uses the connection we've already prepared.
+                if (!request.url().getHost().equals(address.getUriHost())
+                        || getEffectivePort(request.url()) != address.getUriPort()) {
+                    throw new IllegalStateException("network interceptor " + caller
+                            + " must retain the same host and port");
+                }
+
+                // Confirm that this is the interceptor's first call to chain.proceed().
+                if (calls > 1) {
+                    throw new IllegalStateException("network interceptor " + caller
+                            + " must call proceed() exactly once");
+                }
+            }
+
+            if (index < client.networkInterceptors().size()) {
+                // There's another interceptor in the chain. Call that.
+                NetworkInterceptorChain chain = new NetworkInterceptorChain(index + 1, request);
+                Interceptor interceptor = client.networkInterceptors().get(index);
+                Response interceptedResponse = interceptor.intercept(chain);
+
+                // Confirm that the interceptor made the required call to chain.proceed().
+                if (chain.calls != 1) {
+                    throw new IllegalStateException("network interceptor " + interceptor
+                            + " must call proceed() exactly once");
+                }
+
+                return interceptedResponse;
+            }
+
+            transport.writeRequestHeaders(request);
+
+            if (permitsRequestBody() && request.body() != null) {
+                Sink requestBodyOut = transport.createRequestBody(request, request.body().contentLength());
+                BufferedSink bufferedRequestBody = Okio.buffer(requestBodyOut);
+                request.body().writeTo(bufferedRequestBody);
+                bufferedRequestBody.close();
+            }
+
+            return readNetworkResponse();
+        }
     }
 
-    for (int i = 0, size = networkHeaders.size(); i < size; i++) {
-      String fieldName = networkHeaders.name(i);
-      if ("Content-Length".equalsIgnoreCase(fieldName)) {
-        continue; // Ignore content-length headers of validating responses.
-      }
-      if (OkHeaders.isEndToEnd(fieldName)) {
-        result.add(fieldName, networkHeaders.value(i));
-      }
+    private Response readNetworkResponse() throws IOException {
+        transport.finishRequest();
+
+        Response networkResponse = transport.readResponseHeaders()
+                .request(networkRequest)
+                .handshake(connection.getHandshake())
+                .header(OkHeaders.SENT_MILLIS, Long.toString(sentRequestMillis))
+                .header(OkHeaders.RECEIVED_MILLIS, Long.toString(System.currentTimeMillis()))
+                .build();
+
+        if (!forWebSocket) {
+            networkResponse = networkResponse.newBuilder()
+                    .body(transport.openResponseBody(networkResponse))
+                    .build();
+        }
+
+        Internal.instance.setProtocol(connection, networkResponse.protocol());
+        return networkResponse;
     }
 
-    return result.build();
-  }
+    /**
+     * Returns a new source that writes bytes to {@code cacheRequest} as they are read by the source
+     * consumer. This is careful to discard bytes left over when the stream is closed; otherwise we
+     * may never exhaust the source stream and therefore not complete the cached response.
+     */
+    private Response cacheWritingResponse(final CacheRequest cacheRequest, Response response)
+            throws IOException {
+        // Some apps return a null body; for compatibility we treat that like a null cache request.
+        if (cacheRequest == null) {
+            return response;
+        }
+        Sink cacheBodyUnbuffered = cacheRequest.body();
+        if (cacheBodyUnbuffered == null) {
+            return response;
+        }
 
-  public void receiveHeaders(Headers headers) throws IOException {
-    CookieHandler cookieHandler = client.getCookieHandler();
-    if (cookieHandler != null) {
-      cookieHandler.put(userRequest.uri(), OkHeaders.toMultimap(headers, null));
+        final BufferedSource source = response.body().source();
+        final BufferedSink cacheBody = Okio.buffer(cacheBodyUnbuffered);
+
+        Source cacheWritingSource = new Source() {
+            boolean cacheRequestClosed;
+
+            @Override
+            public long read(Buffer sink, long byteCount) throws IOException {
+                long bytesRead;
+                try {
+                    bytesRead = source.read(sink, byteCount);
+                } catch (IOException e) {
+                    if (!cacheRequestClosed) {
+                        cacheRequestClosed = true;
+                        cacheRequest.abort(); // Failed to write a complete cache response.
+                    }
+                    throw e;
+                }
+
+                if (bytesRead == -1) {
+                    if (!cacheRequestClosed) {
+                        cacheRequestClosed = true;
+                        cacheBody.close(); // The cache response is complete!
+                    }
+                    return -1;
+                }
+
+                sink.copyTo(cacheBody.buffer(), sink.size() - bytesRead, bytesRead);
+                cacheBody.emitCompleteSegments();
+                return bytesRead;
+            }
+
+            @Override
+            public Timeout timeout() {
+                return source.timeout();
+            }
+
+            @Override
+            public void close() throws IOException {
+                if (!cacheRequestClosed
+                        && !Util.discard(this, Transport.DISCARD_STREAM_TIMEOUT_MILLIS, MILLISECONDS)) {
+                    cacheRequestClosed = true;
+                    cacheRequest.abort();
+                }
+                source.close();
+            }
+        };
+
+        return response.newBuilder()
+                .body(new RealResponseBody(response.headers(), Okio.buffer(cacheWritingSource)))
+                .build();
     }
-  }
-
-  /**
-   * Figures out the HTTP request to make in response to receiving this engine's
-   * response. This will either add authentication headers or follow redirects.
-   * If a follow-up is either unnecessary or not applicable, this returns null.
-   */
-  public Request followUpRequest() throws IOException {
-    if (userResponse == null) throw new IllegalStateException();
-    Proxy selectedProxy = getRoute() != null
-        ? getRoute().getProxy()
-        : client.getProxy();
-    int responseCode = userResponse.code();
-
-    switch (responseCode) {
-      case HTTP_PROXY_AUTH:
-        if (selectedProxy.type() != Proxy.Type.HTTP) {
-          throw new ProtocolException("Received HTTP_PROXY_AUTH (407) code while not using proxy");
+
+    /**
+     * Returns true if {@code cached} should be used; false if {@code network}
+     * response should be used.
+     */
+    private static boolean validate(Response cached, Response network) {
+        if (network.code() == HTTP_NOT_MODIFIED) {
+            return true;
         }
-        // fall-through
-      case HTTP_UNAUTHORIZED:
-        return OkHeaders.processAuthHeader(client.getAuthenticator(), userResponse, selectedProxy);
-
-      case HTTP_PERM_REDIRECT:
-      case HTTP_TEMP_REDIRECT:
-        // "If the 307 or 308 status code is received in response to a request other than GET
-        // or HEAD, the user agent MUST NOT automatically redirect the request"
-        if (!userRequest.method().equals("GET") && !userRequest.method().equals("HEAD")) {
-            return null;
+
+        // The HTTP spec says that if the network's response is older than our
+        // cached response, we may return the cache's response. Like Chrome (but
+        // unlike Firefox), this client prefers to return the newer response.
+        Date lastModified = cached.headers().getDate("Last-Modified");
+        if (lastModified != null) {
+            Date networkLastModified = network.headers().getDate("Last-Modified");
+            if (networkLastModified != null
+                    && networkLastModified.getTime() < lastModified.getTime()) {
+                return true;
+            }
         }
-        // fall-through
-      case HTTP_MULT_CHOICE:
-      case HTTP_MOVED_PERM:
-      case HTTP_MOVED_TEMP:
-      case HTTP_SEE_OTHER:
-        // Does the client allow redirects?
-        if (!client.getFollowRedirects()) return null;
-
-        String location = userResponse.header("Location");
-        if (location == null) return null;
-        URL url = new URL(userRequest.url(), location);
-
-        // Don't follow redirects to unsupported protocols.
-        if (!url.getProtocol().equals("https") && !url.getProtocol().equals("http")) return null;
-
-        // If configured, don't follow redirects between SSL and non-SSL.
-        boolean sameProtocol = url.getProtocol().equals(userRequest.url().getProtocol());
-        if (!sameProtocol && !client.getFollowSslRedirects()) return null;
-
-        // Redirects don't include a request body.
-        Request.Builder requestBuilder = userRequest.newBuilder();
-        if (HttpMethod.permitsRequestBody(userRequest.method())) {
-          requestBuilder.method("GET", null);
-          requestBuilder.removeHeader("Transfer-Encoding");
-          requestBuilder.removeHeader("Content-Length");
-          requestBuilder.removeHeader("Content-Type");
+
+        return false;
+    }
+
+    /**
+     * Combines cached headers with a network headers as defined by RFC 2616,
+     * 13.5.3.
+     */
+    private static Headers combine(Headers cachedHeaders, Headers networkHeaders) throws IOException {
+        Headers.Builder result = new Headers.Builder();
+
+        for (int i = 0, size = cachedHeaders.size(); i < size; i++) {
+            String fieldName = cachedHeaders.name(i);
+            String value = cachedHeaders.value(i);
+            if ("Warning".equalsIgnoreCase(fieldName) && value.startsWith("1")) {
+                continue; // Drop 100-level freshness warnings.
+            }
+            if (!OkHeaders.isEndToEnd(fieldName) || networkHeaders.get(fieldName) == null) {
+                result.add(fieldName, value);
+            }
         }
 
-        // When redirecting across hosts, drop all authentication headers. This
-        // is potentially annoying to the application layer since they have no
-        // way to retain them.
-        if (!sameConnection(url)) {
-          requestBuilder.removeHeader("Authorization");
+        for (int i = 0, size = networkHeaders.size(); i < size; i++) {
+            String fieldName = networkHeaders.name(i);
+            if ("Content-Length".equalsIgnoreCase(fieldName)) {
+                continue; // Ignore content-length headers of validating responses.
+            }
+            if (OkHeaders.isEndToEnd(fieldName)) {
+                result.add(fieldName, networkHeaders.value(i));
+            }
         }
 
-        return requestBuilder.url(url).build();
+        return result.build();
+    }
 
-      default:
-        return null;
+    public void receiveHeaders(Headers headers) throws IOException {
+        CookieHandler cookieHandler = client.getCookieHandler();
+        if (cookieHandler != null) {
+            cookieHandler.put(userRequest.uri(), OkHeaders.toMultimap(headers, null));
+        }
     }
-  }
-
-  /**
-   * Returns true if an HTTP request for {@code followUp} can reuse the
-   * connection used by this engine.
-   */
-  public boolean sameConnection(URL followUp) {
-    URL url = userRequest.url();
-    return url.getHost().equals(followUp.getHost())
-        && getEffectivePort(url) == getEffectivePort(followUp)
-        && url.getProtocol().equals(followUp.getProtocol());
-  }
-
-  private static Address createAddress(OkHttpClient client, Request request)
-      throws UnknownHostException {
-    String uriHost = request.url().getHost();
-    if (uriHost == null || uriHost.length() == 0) {
-      throw new UnknownHostException(request.url().toString());
+
+    /**
+     * Figures out the HTTP request to make in response to receiving this engine's
+     * response. This will either add authentication headers or follow redirects.
+     * If a follow-up is either unnecessary or not applicable, this returns null.
+     */
+    public Request followUpRequest() throws IOException {
+        if (userResponse == null) {
+            throw new IllegalStateException();
+        }
+        Proxy selectedProxy = getRoute() != null
+                ? getRoute().getProxy()
+                : client.getProxy();
+        int responseCode = userResponse.code();
+
+        switch (responseCode) {
+            case HTTP_PROXY_AUTH:
+                if (selectedProxy.type() != Proxy.Type.HTTP) {
+                    throw new ProtocolException("Received HTTP_PROXY_AUTH (407) code while not using proxy");
+                }
+                // fall-through
+            case HTTP_UNAUTHORIZED:
+                return OkHeaders.processAuthHeader(client.getAuthenticator(), userResponse, selectedProxy);
+
+            case HTTP_PERM_REDIRECT:
+            case HTTP_TEMP_REDIRECT:
+                // "If the 307 or 308 status code is received in response to a request other than GET
+                // or HEAD, the user agent MUST NOT automatically redirect the request"
+                if (!userRequest.method().equals("GET") && !userRequest.method().equals("HEAD")) {
+                    return null;
+                }
+                // fall-through
+            case HTTP_MULT_CHOICE:
+            case HTTP_MOVED_PERM:
+            case HTTP_MOVED_TEMP:
+            case HTTP_SEE_OTHER:
+                // Does the client allow redirects?
+                if (!client.getFollowRedirects()) {
+                    return null;
+                }
+
+                String location = userResponse.header("Location");
+                if (location == null) {
+                    return null;
+                }
+                URL url = new URL(userRequest.url(), location);
+
+                // Don't follow redirects to unsupported protocols.
+                if (!url.getProtocol().equals("https") && !url.getProtocol().equals("http")) {
+                    return null;
+                }
+
+                // If configured, don't follow redirects between SSL and non-SSL.
+                boolean sameProtocol = url.getProtocol().equals(userRequest.url().getProtocol());
+                if (!sameProtocol && !client.getFollowSslRedirects()) {
+                    return null;
+                }
+
+                // Redirects don't include a request body.
+                Request.Builder requestBuilder = userRequest.newBuilder();
+                if (HttpMethod.permitsRequestBody(userRequest.method())) {
+                    requestBuilder.method("GET", null);
+                    requestBuilder.removeHeader("Transfer-Encoding");
+                    requestBuilder.removeHeader("Content-Length");
+                    requestBuilder.removeHeader("Content-Type");
+                }
+
+                // When redirecting across hosts, drop all authentication headers. This
+                // is potentially annoying to the application layer since they have no
+                // way to retain them.
+                if (!sameConnection(url)) {
+                    requestBuilder.removeHeader("Authorization");
+                }
+
+                return requestBuilder.url(url).build();
+
+            default:
+                return null;
+        }
     }
 
-    SSLSocketFactory sslSocketFactory = null;
-    HostnameVerifier hostnameVerifier = null;
-    CertificatePinner certificatePinner = null;
-    if (request.isHttps()) {
-      sslSocketFactory = client.getSslSocketFactory();
-      hostnameVerifier = client.getHostnameVerifier();
-      certificatePinner = client.getCertificatePinner();
+    /**
+     * Returns true if an HTTP request for {@code followUp} can reuse the
+     * connection used by this engine.
+     */
+    public boolean sameConnection(URL followUp) {
+        URL url = userRequest.url();
+        return url.getHost().equals(followUp.getHost())
+                && getEffectivePort(url) == getEffectivePort(followUp)
+                && url.getProtocol().equals(followUp.getProtocol());
     }
 
-    return new Address(uriHost, getEffectivePort(request.url()),
-        client.getSocketFactory(), sslSocketFactory, hostnameVerifier, certificatePinner,
-        client.getAuthenticator(), client.getProxy(), client.getProtocols(),
-        client.getConnectionSpecs(), client.getProxySelector());
-  }
+    private static Address createAddress(OkHttpClient client, Request request)
+            throws UnknownHostException {
+        String uriHost = request.url().getHost();
+        if (uriHost == null || uriHost.length() == 0) {
+            throw new UnknownHostException(request.url().toString());
+        }
+
+        SSLSocketFactory sslSocketFactory = null;
+        HostnameVerifier hostnameVerifier = null;
+        CertificatePinner certificatePinner = null;
+        if (request.isHttps()) {
+            sslSocketFactory = client.getSslSocketFactory();
+            hostnameVerifier = client.getHostnameVerifier();
+            certificatePinner = client.getCertificatePinner();
+        }
+
+        return new Address(uriHost, getEffectivePort(request.url()),
+                client.getSocketFactory(), sslSocketFactory, hostnameVerifier, certificatePinner,
+                client.getAuthenticator(), client.getProxy(), client.getProtocols(),
+                client.getConnectionSpecs(), client.getProxySelector());
+    }
 }
