diff --git a/mockwebserver/src/main/java/com/squareup/okhttp/mockwebserver/MockResponse.java b/mockwebserver/src/main/java/com/squareup/okhttp/mockwebserver/MockResponse.java
index 8f0ee2c50f..e894e6639d 100644
--- a/mockwebserver/src/main/java/com/squareup/okhttp/mockwebserver/MockResponse.java
+++ b/mockwebserver/src/main/java/com/squareup/okhttp/mockwebserver/MockResponse.java
@@ -17,6 +17,8 @@
 
 import com.squareup.okhttp.Headers;
 import com.squareup.okhttp.internal.ws.WebSocketListener;
+
+import java.nio.charset.Charset;
 import java.util.ArrayList;
 import java.util.List;
 import java.util.concurrent.TimeUnit;
@@ -24,7 +26,7 @@
 
 /** A scripted response to be replayed by the mock web server. */
 public final class MockResponse implements Cloneable {
-  private static final String CHUNKED_BODY_HEADER = "Transfer-encoding: chunked";
+  private static final String CHUNKED_BODY_HEADER = "transfer-encoding: chunked";
 
   private String status = "HTTP/1.1 200 OK";
   private Headers.Builder headers = new Headers.Builder();
@@ -164,6 +166,26 @@ public MockResponse setChunkedBody(Buffer body, int maxChunkSize) {
     return this;
   }
 
+    /**
+     * Provide a list of chunks to be streamed back to the client.
+     *
+     * @param chunks
+     * @return
+     */
+  public MockResponse setChunkedBody(List<String> chunks) {
+    removeHeader("Content-Length");
+    headers.add(CHUNKED_BODY_HEADER);
+      Buffer bytesOut = new Buffer();
+    for (String s : chunks) {
+        bytesOut.writeUtf8(Integer.toHexString(s.getBytes(Charset.forName("UTF-8")).length));
+        bytesOut.writeUtf8("\r\n");
+        bytesOut.writeUtf8(s);
+        bytesOut.writeUtf8("\r\n");
+    }
+      this.body = bytesOut;
+    return this;
+  }
+
   /**
    * Sets the response body to the UTF-8 encoded bytes of {@code body}, chunked
    * every {@code maxChunkSize} bytes.
diff --git a/mockwebserver/src/main/java/com/squareup/okhttp/mockwebserver/MockWebServer.java b/mockwebserver/src/main/java/com/squareup/okhttp/mockwebserver/MockWebServer.java
index 39fbf6fd84..4156527ef4 100644
--- a/mockwebserver/src/main/java/com/squareup/okhttp/mockwebserver/MockWebServer.java
+++ b/mockwebserver/src/main/java/com/squareup/okhttp/mockwebserver/MockWebServer.java
@@ -701,8 +701,48 @@ private void writeHttpResponse(Socket socket, BufferedSink sink, MockResponse re
 
     Buffer body = response.getBody();
     if (body == null) return;
-    sleepIfDelayed(response);
-    throttledTransfer(response, socket, body, sink, Long.MAX_VALUE);
+    if (response.getSocketPolicy() == SocketPolicy.STREAM_REPEAT_FINAL_CHUNK) {
+      // In this case, we are assuming that the body has been set as per
+      // MockResponse#setChunkedBody(List<String>), otherwise this will not go so well
+      String[] chunks = body.readUtf8().split("\r\n");
+      if (chunks.length % 2 != 0) {
+        logger.info("Chunked Body has non-even length [" + chunks.length + "] - "
+            + "adding \\r\\n as the last bit of data");
+        String[] tmp = chunks;
+        chunks = new String[chunks.length + 1];
+        System.arraycopy(tmp, 0, chunks, 0, tmp.length);
+        chunks[chunks.length - 2] = "2";
+        chunks[chunks.length - 1] = "\r\n";
+      }
+
+      for (int i = 0; i < chunks.length - 1; i += 2) {
+        try {
+          Long.parseLong(chunks[i]);
+        } catch (NumberFormatException e) {
+          throw new IOException("Chunked body badly formatted - "
+              + "expected first element in pair to be chunk length", e);
+        }
+        sleepIfDelayed(response);
+        throttledTransfer(response,
+            socket,
+            new Buffer().writeUtf8(chunks[i] + "\r\n" + chunks[i + 1] + "\r\n"),
+            sink,
+            Long.MAX_VALUE);
+      }
+
+      while (!socket.isClosed()) {
+        sleepIfDelayed(response);
+        throttledTransfer(response,
+            socket,
+            new Buffer().writeUtf8(chunks[chunks.length - 2]
+                + "\r\n" + chunks[chunks.length - 1] + "\r\n"),
+            sink,
+            Long.MAX_VALUE);
+      }
+    } else {
+      sleepIfDelayed(response);
+      throttledTransfer(response, socket, body, sink, Long.MAX_VALUE);
+    }
   }
 
   private void sleepIfDelayed(MockResponse response) {
diff --git a/mockwebserver/src/main/java/com/squareup/okhttp/mockwebserver/SocketPolicy.java b/mockwebserver/src/main/java/com/squareup/okhttp/mockwebserver/SocketPolicy.java
index e2d5f28481..bf56b2435b 100644
--- a/mockwebserver/src/main/java/com/squareup/okhttp/mockwebserver/SocketPolicy.java
+++ b/mockwebserver/src/main/java/com/squareup/okhttp/mockwebserver/SocketPolicy.java
@@ -65,6 +65,18 @@
    */
   SHUTDOWN_OUTPUT_AT_END,
 
+  /**
+   * Response body should be split into chunks based on {@code \r\n}, and each chunk should be
+   * streamed individually back to the server, with
+   * {@link MockResponse#setBodyDelay(long, java.util.concurrent.TimeUnit)} between each
+   * transmission.
+   * <p>
+   * This policy means that the final chunk will be re-sent constantly until the socket is
+   * closed.
+   * </p>
+   */
+  STREAM_REPEAT_FINAL_CHUNK,
+
   /**
    * Don't response to the request but keep the socket open. For testing
    * read response header timeout issue.
diff --git a/mockwebserver/src/test/java/com/squareup/okhttp/mockwebserver/MockWebServerTest.java b/mockwebserver/src/test/java/com/squareup/okhttp/mockwebserver/MockWebServerTest.java
index 388dbf64f5..55035e7125 100644
--- a/mockwebserver/src/test/java/com/squareup/okhttp/mockwebserver/MockWebServerTest.java
+++ b/mockwebserver/src/test/java/com/squareup/okhttp/mockwebserver/MockWebServerTest.java
@@ -255,6 +255,22 @@
     assertTrue(String.format("Request + Response: %sms", elapsedMillis), elapsedMillis <= 1100);
   }
 
+  @Test public void streamResponseReaptingFinalChunk() throws IOException, InterruptedException {
+    server.enqueue(new MockResponse()
+        .setSocketPolicy(SocketPolicy.STREAM_REPEAT_FINAL_CHUNK)
+        .setChunkedBody(Arrays.asList("{\"name\":\"stuff\"}", ""))
+        .setBodyDelay(100, TimeUnit.MILLISECONDS));
+
+    URLConnection connection = server.getUrl("/").openConnection();
+    InputStream in = connection.getInputStream();
+    BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(in));
+    String s = bufferedReader.readLine();
+    assertEquals("{\"name\":\"stuff\"}", s);
+    assertEquals("", bufferedReader.readLine());
+    assertEquals("", bufferedReader.readLine());
+    in.close();
+  }
+
   private List<String> headersToList(MockResponse response) {
     Headers headers = response.getHeaders();
     int size = headers.size();
