diff --git a/okhttp-tests/src/test/java/okhttp3/internal/http2/BaseTestHandler.java b/okhttp-tests/src/test/java/okhttp3/internal/http2/BaseTestHandler.java
index 38e3d44a9d..b0b552b937 100644
--- a/okhttp-tests/src/test/java/okhttp3/internal/http2/BaseTestHandler.java
+++ b/okhttp-tests/src/test/java/okhttp3/internal/http2/BaseTestHandler.java
@@ -17,21 +17,19 @@
 
 import java.io.IOException;
 import java.util.List;
-
-import okhttp3.StatisticsData;
 import okio.BufferedSource;
 import okio.ByteString;
 
 import static org.junit.Assert.fail;
 
 class BaseTestHandler implements Http2Reader.Handler {
-  @Override public void data(boolean inFinished, int streamId, BufferedSource source, int length, StatisticsData statsData)
+  @Override public void data(boolean inFinished, int streamId, BufferedSource source, int length)
       throws IOException {
     fail();
   }
 
   @Override public void headers(boolean inFinished, int streamId, int associatedStreamId,
-      List<Header> headerBlock, StatisticsData statsData) {
+      List<Header> headerBlock) {
     fail();
   }
 
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/http2/Http2Test.java b/okhttp-tests/src/test/java/okhttp3/internal/http2/Http2Test.java
index 4792824713..b1df905a4f 100644
--- a/okhttp-tests/src/test/java/okhttp3/internal/http2/Http2Test.java
+++ b/okhttp-tests/src/test/java/okhttp3/internal/http2/Http2Test.java
@@ -19,8 +19,6 @@
 import java.util.Arrays;
 import java.util.List;
 import java.util.concurrent.atomic.AtomicInteger;
-
-import okhttp3.StatisticsData;
 import okhttp3.internal.Util;
 import okio.Buffer;
 import okio.BufferedSink;
@@ -71,7 +69,7 @@
 
     reader.nextFrame(false, new BaseTestHandler() {
       @Override public void headers(boolean inFinished, int streamId,
-          int associatedStreamId, List<Header> headerBlock, StatisticsData statsData) {
+          int associatedStreamId, List<Header> headerBlock) {
         assertTrue(inFinished);
         assertEquals(expectedStreamId, streamId);
         assertEquals(-1, associatedStreamId);
@@ -101,7 +99,7 @@
       }
 
       @Override public void headers(boolean inFinished, int streamId,
-          int associatedStreamId, List<Header> nameValueBlock, StatisticsData statsData) {
+          int associatedStreamId, List<Header> nameValueBlock) {
         assertFalse(inFinished);
         assertEquals(expectedStreamId, streamId);
         assertEquals(-1, associatedStreamId);
@@ -135,7 +133,7 @@
     // Reading the above frames should result in a concatenated headerBlock.
     reader.nextFrame(false, new BaseTestHandler() {
       @Override public void headers(boolean inFinished, int streamId,
-          int associatedStreamId, List<Header> headerBlock, StatisticsData statsData) {
+          int associatedStreamId, List<Header> headerBlock) {
         assertFalse(inFinished);
         assertEquals(expectedStreamId, streamId);
         assertEquals(-1, associatedStreamId);
@@ -382,7 +380,7 @@ public void pushPromise(int streamId, int promisedStreamId, List<Header> headerB
 
     reader.nextFrame(false, new BaseTestHandler() {
       @Override public void data(boolean inFinished, int streamId, BufferedSource source,
-          int length, StatisticsData statsData) throws IOException {
+          int length) throws IOException {
         assertFalse(inFinished);
         assertEquals(expectedStreamId, streamId);
         assertEquals(Http2.INITIAL_MAX_FRAME_SIZE, length);
@@ -706,7 +704,7 @@ private Buffer windowUpdate(long windowSizeIncrement) throws IOException {
   private Http2Reader.Handler assertHeaderBlock() {
     return new BaseTestHandler() {
       @Override public void headers(boolean inFinished, int streamId,
-          int associatedStreamId, List<Header> headerBlock, StatisticsData statsData) {
+          int associatedStreamId, List<Header> headerBlock) {
         assertFalse(inFinished);
         assertEquals(expectedStreamId, streamId);
         assertEquals(-1, associatedStreamId);
@@ -718,7 +716,7 @@ private Buffer windowUpdate(long windowSizeIncrement) throws IOException {
   private Http2Reader.Handler assertData() {
     return new BaseTestHandler() {
       @Override public void data(boolean inFinished, int streamId, BufferedSource source,
-          int length, StatisticsData statsData) throws IOException {
+          int length) throws IOException {
         assertFalse(inFinished);
         assertEquals(expectedStreamId, streamId);
         assertEquals(1123, length);
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/http2/HttpOverHttp2Test.java b/okhttp-tests/src/test/java/okhttp3/internal/http2/HttpOverHttp2Test.java
index f87b9c17c9..3ef429a957 100644
--- a/okhttp-tests/src/test/java/okhttp3/internal/http2/HttpOverHttp2Test.java
+++ b/okhttp-tests/src/test/java/okhttp3/internal/http2/HttpOverHttp2Test.java
@@ -42,7 +42,6 @@
 import okhttp3.Request;
 import okhttp3.RequestBody;
 import okhttp3.Response;
-import okhttp3.StatisticsData;
 import okhttp3.TestUtil;
 import okhttp3.internal.DoubleInetAddressDns;
 import okhttp3.internal.RecordingOkAuthenticator;
@@ -1138,13 +1137,13 @@ public AsyncRequest(String path, CountDownLatch countDownLatch) {
     @Override public void windowUpdate(int streamId, long windowSizeIncrement) {
     }
 
-    @Override public void data(boolean inFinished, int streamId, BufferedSource source, int length, StatisticsData statsData)
+    @Override public void data(boolean inFinished, int streamId, BufferedSource source, int length)
         throws IOException {
       dataFrames.add(length);
     }
 
     @Override public void headers(boolean inFinished, int streamId, int associatedStreamId,
-        List<Header> headerBlock, StatisticsData statsData) {
+        List<Header> headerBlock) {
       headerFrameCount++;
     }
   }
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/http2/MockHttp2Peer.java b/okhttp-tests/src/test/java/okhttp3/internal/http2/MockHttp2Peer.java
index b7c5a6a0c4..fe5f82fd4a 100644
--- a/okhttp-tests/src/test/java/okhttp3/internal/http2/MockHttp2Peer.java
+++ b/okhttp-tests/src/test/java/okhttp3/internal/http2/MockHttp2Peer.java
@@ -31,8 +31,6 @@
 import java.util.concurrent.Executors;
 import java.util.concurrent.LinkedBlockingQueue;
 import java.util.logging.Logger;
-
-import okhttp3.StatisticsData;
 import okhttp3.internal.Util;
 import okio.Buffer;
 import okio.BufferedSource;
@@ -242,7 +240,7 @@ public InFrame(int sequence, Http2Reader reader) {
     }
 
     @Override public void headers(boolean inFinished, int streamId,
-        int associatedStreamId, List<Header> headerBlock, StatisticsData statsData) {
+        int associatedStreamId, List<Header> headerBlock) {
       if (this.type != -1) throw new IllegalStateException();
       this.type = Http2.TYPE_HEADERS;
       this.inFinished = inFinished;
@@ -251,7 +249,7 @@ public InFrame(int sequence, Http2Reader reader) {
       this.headerBlock = headerBlock;
     }
 
-    @Override public void data(boolean inFinished, int streamId, BufferedSource source, int length, StatisticsData statsData)
+    @Override public void data(boolean inFinished, int streamId, BufferedSource source, int length)
         throws IOException {
       if (this.type != -1) throw new IllegalStateException();
       this.type = Http2.TYPE_DATA;
diff --git a/okhttp/src/main/java/okhttp3/Request.java b/okhttp/src/main/java/okhttp3/Request.java
index 648dc4384a..f4b0f6dba4 100644
--- a/okhttp/src/main/java/okhttp3/Request.java
+++ b/okhttp/src/main/java/okhttp3/Request.java
@@ -30,7 +30,6 @@
   final Headers headers;
   final RequestBody body;
   final Object tag;
-  final StatisticsObserver observer;
 
   private volatile CacheControl cacheControl; // Lazily initialized.
 
@@ -40,7 +39,6 @@
     this.headers = builder.headers.build();
     this.body = builder.body;
     this.tag = builder.tag != null ? builder.tag : this;
-    this.observer = builder.observer;
   }
 
   public HttpUrl url() {
@@ -71,8 +69,6 @@ public Object tag() {
     return tag;
   }
 
-  public StatisticsObserver observer() { return observer; }
-
   public Builder newBuilder() {
     return new Builder(this);
   }
@@ -106,7 +102,6 @@ public boolean isHttps() {
     Headers.Builder headers;
     RequestBody body;
     Object tag;
-    StatisticsObserver observer;
 
     public Builder() {
       this.method = "GET";
@@ -118,7 +113,6 @@ public Builder() {
       this.method = request.method;
       this.body = request.body;
       this.tag = request.tag;
-      this.observer = request.observer;
       this.headers = request.headers.newBuilder();
     }
 
@@ -256,11 +250,6 @@ public Builder tag(Object tag) {
       return this;
     }
 
-    public Builder observer(StatisticsObserver observer) {
-      this.observer = observer;
-      return this;
-    }
-
     public Request build() {
       if (url == null) throw new IllegalStateException("url == null");
       return new Request(this);
diff --git a/okhttp/src/main/java/okhttp3/Response.java b/okhttp/src/main/java/okhttp3/Response.java
index 1da079a34f..810309b013 100644
--- a/okhttp/src/main/java/okhttp3/Response.java
+++ b/okhttp/src/main/java/okhttp3/Response.java
@@ -68,12 +68,6 @@
     this.priorResponse = builder.priorResponse;
     this.sentRequestAtMillis = builder.sentRequestAtMillis;
     this.receivedResponseAtMillis = builder.receivedResponseAtMillis;
-
-    if (builder.statsData != null) {
-      builder.statsData.response = this;
-      if (builder.statsData.request == null)
-        builder.statsData.request = this.request;
-    }
   }
 
   /**
@@ -304,7 +298,6 @@ public long receivedResponseAtMillis() {
     Response priorResponse;
     long sentRequestAtMillis;
     long receivedResponseAtMillis;
-    StatisticsData statsData;
 
     public Builder() {
       headers = new Headers.Builder();
@@ -430,11 +423,6 @@ public Builder receivedResponseAtMillis(long receivedResponseAtMillis) {
       return this;
     }
 
-    public Builder statisticsData(StatisticsData statsData) {
-      this.statsData = statsData;
-      return this;
-    }
-
     public Response build() {
       if (request == null) throw new IllegalStateException("request == null");
       if (protocol == null) throw new IllegalStateException("protocol == null");
diff --git a/okhttp/src/main/java/okhttp3/StatisticsData.java b/okhttp/src/main/java/okhttp3/StatisticsData.java
deleted file mode 100644
index da28cf9dc3..0000000000
--- a/okhttp/src/main/java/okhttp3/StatisticsData.java
+++ /dev/null
@@ -1,117 +0,0 @@
-package okhttp3;
-
-public class StatisticsData {
-
-  // All timestamps are in milliseconds since the epoch as returned by System.currentTimeMillis()
-  // It is possible for the DNS query timestamps to be populated without the connect timestamps.
-  // In this case, either connection coalescing of different hostnames to the same IP address was used,
-  // or there was a race between two threads in establishing the connection.
-
-  // Connection establishment
-  public long initiateDNSQueryAtMillis;
-  public long finishDNSQueryAtMillis;
-  public long initiateConnectAtMillis;
-  public long finishConnectAtMillis;
-
-  // Request and Response times. May be zero on abort.
-  public long initiateSendAtMillis;
-  public long finishSendAtMillis;
-  public long receivedHeadersAtMillis;
-  public long receivedBodyAtMillis;
-
-  public long abortAtMillis;        // zero on success
-
-  public long byteCountHeadersSent;
-  public long byteCountBodySent;
-
-  public long byteCountHeadersReceived;
-  public long byteCountBodyReceived;
-
-  public Request request;
-  public Response response;
-
-  public boolean isNewConnection = false;
-  public boolean reported = false;
-
-  public void mergeHeaderStats(StatisticsData otherData) {
-    
-    if (initiateDNSQueryAtMillis == 0)
-      initiateDNSQueryAtMillis = otherData.initiateDNSQueryAtMillis;
-
-    if (initiateConnectAtMillis == 0)
-      initiateConnectAtMillis = otherData.initiateConnectAtMillis;
-
-    if (finishConnectAtMillis == 0)
-      finishConnectAtMillis = otherData.finishConnectAtMillis;
-
-    if (initiateSendAtMillis == 0)
-      initiateSendAtMillis = otherData.initiateSendAtMillis;
-
-    if (finishSendAtMillis == 0)
-      finishSendAtMillis = otherData.finishSendAtMillis;
-
-    if (receivedHeadersAtMillis == 0)
-      receivedHeadersAtMillis = otherData.receivedHeadersAtMillis;
-
-    if (abortAtMillis == 0)
-      abortAtMillis = otherData.abortAtMillis;
-
-    byteCountHeadersSent += otherData.byteCountHeadersSent;
-    byteCountBodySent += otherData.byteCountBodySent;
-
-    byteCountHeadersReceived += otherData.byteCountHeadersReceived;
-
-    if (request == null)
-      request = otherData.request;
-
-    // Response generally isn't populated until the very end, but just in case...
-    if (response == null)
-      response = otherData.response;
-  }
-
-  public void mergeDataStats(StatisticsData otherData) {
-
-    if (otherData.receivedBodyAtMillis != 0)  // Always take the latest
-      receivedBodyAtMillis = otherData.receivedBodyAtMillis;
-
-    if (abortAtMillis == 0)
-      abortAtMillis = otherData.abortAtMillis;
-
-    byteCountBodyReceived += otherData.byteCountBodyReceived;
-  }
-
-  public void reportCompleted(StatisticsObserver observer) {
-    if ( ! reported) {
-      reported = true;
-      if (observer != null)
-        observer.streamCompletion(this);
-    }
-  }
-
-  public void reportAborted(StatisticsObserver observer) {
-    reportAborted(observer, System.currentTimeMillis());
-  }
-
-  public void reportAborted(StatisticsObserver observer, long abortTime) {
-    if ( ! reported) {
-      reported = true;
-      this.abortAtMillis = abortTime;
-      if (observer != null)
-        observer.streamCompletion(this);
-    }
-  }
-
-  public static StatisticsData allocateForReceivedHeaders(long frameRecvTime, long byteCountHeaders) {
-    StatisticsData statsData = new StatisticsData();
-    statsData.receivedHeadersAtMillis = frameRecvTime;
-    statsData.byteCountHeadersReceived = byteCountHeaders;
-    return statsData;
-  }
-
-  public static StatisticsData allocateForReceivedData(long frameRecvTime, long byteCountBody) {
-    StatisticsData statsData = new StatisticsData();
-    statsData.receivedBodyAtMillis = frameRecvTime;
-    statsData.byteCountBodyReceived = byteCountBody;
-    return statsData;
-  }
-}
diff --git a/okhttp/src/main/java/okhttp3/StatisticsObserver.java b/okhttp/src/main/java/okhttp3/StatisticsObserver.java
deleted file mode 100644
index b63272e436..0000000000
--- a/okhttp/src/main/java/okhttp3/StatisticsObserver.java
+++ /dev/null
@@ -1,7 +0,0 @@
-package okhttp3;
-
-public interface StatisticsObserver {
-
-  // Whenever a stream completes, regardless of success or failure.
-  void streamCompletion(StatisticsData statsData);
-}
diff --git a/okhttp/src/main/java/okhttp3/internal/connection/RealConnection.java b/okhttp/src/main/java/okhttp3/internal/connection/RealConnection.java
index 9d5a9de13e..c6ee1ff8bd 100644
--- a/okhttp/src/main/java/okhttp3/internal/connection/RealConnection.java
+++ b/okhttp/src/main/java/okhttp3/internal/connection/RealConnection.java
@@ -44,7 +44,6 @@
 import okhttp3.Request;
 import okhttp3.Response;
 import okhttp3.Route;
-import okhttp3.StatisticsData;
 import okhttp3.internal.Internal;
 import okhttp3.internal.Util;
 import okhttp3.internal.Version;
@@ -121,8 +120,7 @@ public static RealConnection testConnection(
   }
 
   public void connect(
-      int connectTimeout, int readTimeout, int writeTimeout, boolean connectionRetryEnabled,
-      StatisticsData statsData) {
+      int connectTimeout, int readTimeout, int writeTimeout, boolean connectionRetryEnabled) {
     if (protocol != null) throw new IllegalStateException("already connected");
 
     RouteException routeException = null;
@@ -144,7 +142,7 @@ public void connect(
     while (true) {
       try {
         if (route.requiresTunnel()) {
-          connectTunnel(connectTimeout, readTimeout, writeTimeout, statsData);
+          connectTunnel(connectTimeout, readTimeout, writeTimeout);
         } else {
           connectSocket(connectTimeout, readTimeout);
         }
@@ -184,7 +182,7 @@ public void connect(
    * Does all the work to build an HTTPS connection over a proxy tunnel. The catch here is that a
    * proxy server can issue an auth challenge and then close the connection.
    */
-  private void connectTunnel(int connectTimeout, int readTimeout, int writeTimeout, StatisticsData statsData)
+  private void connectTunnel(int connectTimeout, int readTimeout, int writeTimeout)
       throws IOException {
     Request tunnelRequest = createTunnelRequest();
     HttpUrl url = tunnelRequest.url();
@@ -196,7 +194,7 @@ private void connectTunnel(int connectTimeout, int readTimeout, int writeTimeout
       }
 
       connectSocket(connectTimeout, readTimeout);
-      tunnelRequest = createTunnel(readTimeout, writeTimeout, tunnelRequest, url, statsData);
+      tunnelRequest = createTunnel(readTimeout, writeTimeout, tunnelRequest, url);
 
       if (tunnelRequest == null) break; // Tunnel successfully created.
 
@@ -313,11 +311,11 @@ private void connectTls(ConnectionSpecSelector connectionSpecSelector) throws IO
    * the proxy connection. This may need to be retried if the proxy requires authorization.
    */
   private Request createTunnel(int readTimeout, int writeTimeout, Request tunnelRequest,
-      HttpUrl url, StatisticsData statsData) throws IOException {
+      HttpUrl url) throws IOException {
     // Make an SSL Tunnel on the first message pair of each SSL + proxy connection.
     String requestLine = "CONNECT " + Util.hostHeader(url, true) + " HTTP/1.1";
     while (true) {
-      Http1Codec tunnelConnection = new Http1Codec(null, null, source, sink, statsData);
+      Http1Codec tunnelConnection = new Http1Codec(null, null, source, sink);
       source.timeout().timeout(readTimeout, MILLISECONDS);
       sink.timeout().timeout(writeTimeout, MILLISECONDS);
       tunnelConnection.writeRequest(tunnelRequest.headers(), requestLine);
@@ -444,7 +442,7 @@ public HttpCodec newCodec(
       socket.setSoTimeout(client.readTimeoutMillis());
       source.timeout().timeout(client.readTimeoutMillis(), MILLISECONDS);
       sink.timeout().timeout(client.writeTimeoutMillis(), MILLISECONDS);
-      return new Http1Codec(client, streamAllocation, source, sink, streamAllocation.statisticsData());
+      return new Http1Codec(client, streamAllocation, source, sink);
     }
   }
 
diff --git a/okhttp/src/main/java/okhttp3/internal/connection/StreamAllocation.java b/okhttp/src/main/java/okhttp3/internal/connection/StreamAllocation.java
index 5671483e63..211181961f 100644
--- a/okhttp/src/main/java/okhttp3/internal/connection/StreamAllocation.java
+++ b/okhttp/src/main/java/okhttp3/internal/connection/StreamAllocation.java
@@ -23,7 +23,6 @@
 import okhttp3.ConnectionPool;
 import okhttp3.OkHttpClient;
 import okhttp3.Route;
-import okhttp3.StatisticsData;
 import okhttp3.internal.Internal;
 import okhttp3.internal.Util;
 import okhttp3.internal.http.HttpCodec;
@@ -83,14 +82,12 @@
   private boolean released;
   private boolean canceled;
   private HttpCodec codec;
-  private StatisticsData statsData;
 
   public StreamAllocation(ConnectionPool connectionPool, Address address, Object callStackTrace) {
     this.connectionPool = connectionPool;
     this.address = address;
     this.routeSelector = new RouteSelector(address, routeDatabase());
     this.callStackTrace = callStackTrace;
-    statsData = new StatisticsData();
   }
 
   public HttpCodec newStream(OkHttpClient client, boolean doExtensiveHealthChecks) {
@@ -113,10 +110,6 @@ public HttpCodec newStream(OkHttpClient client, boolean doExtensiveHealthChecks)
     }
   }
 
-  public StatisticsData statisticsData() { return statsData; }
-
-  public void resetStatistics() { statsData = new StatisticsData(); }
-
   /**
    * Finds a connection and returns it if it is healthy. If it is unhealthy the process is repeated
    * until a healthy connection is found.
@@ -173,15 +166,11 @@ private RealConnection findConnection(int connectTimeout, int readTimeout, int w
       selectedRoute = route;
     }
 
-    statsData.initiateDNSQueryAtMillis = System.currentTimeMillis();
-
     // If we need a route, make one. This is a blocking operation.
     if (selectedRoute == null) {
       selectedRoute = routeSelector.next();
     }
 
-    statsData.finishDNSQueryAtMillis = System.currentTimeMillis();
-
     RealConnection result;
     synchronized (connectionPool) {
       if (canceled) throw new IOException("Canceled");
@@ -199,12 +188,9 @@ private RealConnection findConnection(int connectTimeout, int readTimeout, int w
       acquire(result);
     }
 
-    statsData.initiateConnectAtMillis = statsData.finishDNSQueryAtMillis;
     // Do TCP + TLS handshakes. This is a blocking operation.
-    result.connect(connectTimeout, readTimeout, writeTimeout, connectionRetryEnabled, statsData);
+    result.connect(connectTimeout, readTimeout, writeTimeout, connectionRetryEnabled);
     routeDatabase().connected(result.route());
-    statsData.finishConnectAtMillis = System.currentTimeMillis();
-    statsData.isNewConnection = true;
 
     Socket socket = null;
     synchronized (connectionPool) {
diff --git a/okhttp/src/main/java/okhttp3/internal/http/CallServerInterceptor.java b/okhttp/src/main/java/okhttp3/internal/http/CallServerInterceptor.java
index 0d5cfdc118..3bc47183eb 100644
--- a/okhttp/src/main/java/okhttp3/internal/http/CallServerInterceptor.java
+++ b/okhttp/src/main/java/okhttp3/internal/http/CallServerInterceptor.java
@@ -80,7 +80,6 @@ public CallServerInterceptor(boolean forWebSocket) {
         .handshake(streamAllocation.connection().handshake())
         .sentRequestAtMillis(sentRequestMillis)
         .receivedResponseAtMillis(System.currentTimeMillis())
-        .statisticsData(httpCodec.statisticsData())
         .build();
 
     int code = response.code();
diff --git a/okhttp/src/main/java/okhttp3/internal/http/HttpCodec.java b/okhttp/src/main/java/okhttp3/internal/http/HttpCodec.java
index 9cad87a018..ad9759acce 100644
--- a/okhttp/src/main/java/okhttp3/internal/http/HttpCodec.java
+++ b/okhttp/src/main/java/okhttp3/internal/http/HttpCodec.java
@@ -19,7 +19,6 @@
 import okhttp3.Request;
 import okhttp3.Response;
 import okhttp3.ResponseBody;
-import okhttp3.StatisticsData;
 import okio.Sink;
 
 /** Encodes HTTP requests and decodes HTTP responses. */
@@ -59,7 +58,4 @@
    * That may happen later by the connection pool thread.
    */
   void cancel();
-
-  /** Returns the statistics data allocated for this codec. */
-  StatisticsData statisticsData();
 }
diff --git a/okhttp/src/main/java/okhttp3/internal/http/RealInterceptorChain.java b/okhttp/src/main/java/okhttp3/internal/http/RealInterceptorChain.java
index b7911d4de6..398f29d661 100644
--- a/okhttp/src/main/java/okhttp3/internal/http/RealInterceptorChain.java
+++ b/okhttp/src/main/java/okhttp3/internal/http/RealInterceptorChain.java
@@ -89,19 +89,7 @@ public Response proceed(Request request, StreamAllocation streamAllocation, Http
     RealInterceptorChain next = new RealInterceptorChain(
         interceptors, streamAllocation, httpCodec, connection, index + 1, request);
     Interceptor interceptor = interceptors.get(index);
-
-    if (streamAllocation != null && streamAllocation.statisticsData() != null)
-      streamAllocation.statisticsData().request = request;
-
-    Response response;
-    boolean succeeded = false;
-    try {
-      response = interceptor.intercept(next);
-      succeeded = true;
-    } finally {
-      if ( ! succeeded && streamAllocation != null && streamAllocation.statisticsData() != null)
-        streamAllocation.statisticsData().reportAborted(request.observer());
-    }
+    Response response = interceptor.intercept(next);
 
     // Confirm that the next interceptor made its required call to chain.proceed().
     if (httpCodec != null && index + 1 < interceptors.size() && next.calls != 1) {
diff --git a/okhttp/src/main/java/okhttp3/internal/http/RetryAndFollowUpInterceptor.java b/okhttp/src/main/java/okhttp3/internal/http/RetryAndFollowUpInterceptor.java
index 2de4a16896..792ddc9299 100644
--- a/okhttp/src/main/java/okhttp3/internal/http/RetryAndFollowUpInterceptor.java
+++ b/okhttp/src/main/java/okhttp3/internal/http/RetryAndFollowUpInterceptor.java
@@ -177,9 +177,6 @@ public StreamAllocation streamAllocation() {
       } else if (streamAllocation.codec() != null) {
         throw new IllegalStateException("Closing the body of " + response
             + " didn't close its backing stream. Bad interceptor?");
-      } else {
-        // We're starting a new request on the same stream. Reset statistics.
-        streamAllocation.resetStatistics();
       }
 
       request = followUp;
diff --git a/okhttp/src/main/java/okhttp3/internal/http1/Http1Codec.java b/okhttp/src/main/java/okhttp3/internal/http1/Http1Codec.java
index 2ff1cff015..625c173bf3 100644
--- a/okhttp/src/main/java/okhttp3/internal/http1/Http1Codec.java
+++ b/okhttp/src/main/java/okhttp3/internal/http1/Http1Codec.java
@@ -24,8 +24,6 @@
 import okhttp3.Request;
 import okhttp3.Response;
 import okhttp3.ResponseBody;
-import okhttp3.StatisticsData;
-import okhttp3.StatisticsObserver;
 import okhttp3.internal.Internal;
 import okhttp3.internal.Util;
 import okhttp3.internal.connection.RealConnection;
@@ -85,18 +83,13 @@
   final BufferedSource source;
   final BufferedSink sink;
   int state = STATE_IDLE;
-  final StatisticsData statsData;
-  StatisticsObserver observer;
 
   public Http1Codec(OkHttpClient client, StreamAllocation streamAllocation, BufferedSource source,
-      BufferedSink sink, StatisticsData statsData) {
+      BufferedSink sink) {
     this.client = client;
     this.streamAllocation = streamAllocation;
     this.source = source;
     this.sink = sink;
-    if (statsData == null) // shouldn't be, but maybe from test code.
-      statsData = new StatisticsData();
-    this.statsData = statsData;
   }
 
   @Override public Sink createRequestBody(Request request, long contentLength) {
@@ -119,11 +112,6 @@ public Http1Codec(OkHttpClient client, StreamAllocation streamAllocation, Buffer
     if (connection != null) connection.cancel();
   }
 
-  @Override
-  public StatisticsData statisticsData() {
-    return statsData;
-  }
-
   /**
    * Prepares the HTTP headers and sends them to the server.
    *
@@ -135,7 +123,6 @@ public StatisticsData statisticsData() {
    * header field receives the proper value.
    */
   @Override public void writeRequestHeaders(Request request) throws IOException {
-    observer = request.observer();
     String requestLine = RequestLine.get(
         request, streamAllocation.connection().route().proxy().type());
     writeRequest(request.headers(), requestLine);
@@ -177,14 +164,11 @@ public boolean isClosed() {
 
   @Override public void finishRequest() throws IOException {
     sink.flush();
-    statsData.finishSendAtMillis = System.currentTimeMillis();
   }
 
   /** Returns bytes of a request header for sending on an HTTP transport. */
   public void writeRequest(Headers headers, String requestLine) throws IOException {
     if (state != STATE_IDLE) throw new IllegalStateException("state: " + state);
-    long origSize = sink.buffer().size();
-    statsData.initiateSendAtMillis = System.currentTimeMillis();
     sink.writeUtf8(requestLine).writeUtf8("\r\n");
     for (int i = 0, size = headers.size(); i < size; i++) {
       sink.writeUtf8(headers.name(i))
@@ -193,10 +177,6 @@ public void writeRequest(Headers headers, String requestLine) throws IOException
           .writeUtf8("\r\n");
     }
     sink.writeUtf8("\r\n");
-    long newSize = sink.buffer().size();
-    long len = newSize - origSize;
-    if (len > 0)
-      statsData.byteCountHeadersSent += len;
     state = STATE_OPEN_REQUEST_BODY;
   }
 
@@ -206,13 +186,7 @@ public void writeRequest(Headers headers, String requestLine) throws IOException
     }
 
     try {
-      long origSize = source.buffer().size();
       StatusLine statusLine = StatusLine.parse(source.readUtf8LineStrict());
-      statsData.receivedHeadersAtMillis = System.currentTimeMillis();
-      long newSize = source.buffer().size();
-      long len = newSize - origSize;
-      if (len > 0)
-        statsData.byteCountHeadersReceived += len;
 
       Response.Builder responseBuilder = new Response.Builder()
           .protocol(statusLine.protocol)
@@ -237,15 +211,10 @@ public void writeRequest(Headers headers, String requestLine) throws IOException
   /** Reads headers or trailers. */
   public Headers readHeaders() throws IOException {
     Headers.Builder headers = new Headers.Builder();
-    long origSize = source.buffer().size();
     // parse the result headers until the first blank line
     for (String line; (line = source.readUtf8LineStrict()).length() != 0; ) {
       Internal.instance.addLenient(headers, line);
     }
-    long newSize = source.buffer().size();
-    long len = newSize - origSize;
-    if (len > 0)
-      statsData.byteCountHeadersReceived += len;
     return headers.build();
   }
 
@@ -316,7 +285,6 @@ void detachTimeout(ForwardingTimeout timeout) {
       }
       sink.write(source, byteCount);
       bytesRemaining -= byteCount;
-      statsData.byteCountBodySent += byteCount; // only track what we've actually written.
     }
 
     @Override public void flush() throws IOException {
@@ -352,18 +320,10 @@ void detachTimeout(ForwardingTimeout timeout) {
       if (closed) throw new IllegalStateException("closed");
       if (byteCount == 0) return;
 
-      long origSize = sink.buffer().size();
       sink.writeHexadecimalUnsignedLong(byteCount);
-      long newSize = sink.buffer().size();
-      long len = newSize - origSize;
-      if (len > 0)
-        statsData.byteCountBodySent += len;
-
       sink.writeUtf8("\r\n");
       sink.write(source, byteCount);
       sink.writeUtf8("\r\n");
-
-      statsData.byteCountBodySent += byteCount + 4;
     }
 
     @Override public synchronized void flush() throws IOException {
@@ -398,18 +358,10 @@ protected final void endOfInput(boolean reuseConnection) throws IOException {
 
       detachTimeout(timeout);
 
-      long now = System.currentTimeMillis();
-      if (reuseConnection)
-        statsData.receivedBodyAtMillis = now;
-      else
-        statsData.abortAtMillis = now;
-
       state = STATE_CLOSED;
       if (streamAllocation != null) {
         streamAllocation.streamFinished(!reuseConnection, Http1Codec.this);
       }
-
-      statsData.reportCompleted(observer);
     }
   }
 
@@ -435,8 +387,6 @@ public FixedLengthSource(long length) throws IOException {
         throw new ProtocolException("unexpected end of stream");
       }
 
-      statsData.byteCountBodyReceived += read;
-
       bytesRemaining -= read;
       if (bytesRemaining == 0) {
         endOfInput(true);
@@ -481,9 +431,6 @@ public FixedLengthSource(long length) throws IOException {
         endOfInput(false); // The server didn't supply the promised chunk length.
         throw new ProtocolException("unexpected end of stream");
       }
-
-      statsData.byteCountBodyReceived += read;
-
       bytesRemainingInChunk -= read;
       return read;
     }
@@ -538,7 +485,6 @@ private void readChunkSize() throws IOException {
         endOfInput(true);
         return -1;
       }
-      statsData.byteCountBodyReceived += read;
       return read;
     }
 
diff --git a/okhttp/src/main/java/okhttp3/internal/http2/Hpack.java b/okhttp/src/main/java/okhttp3/internal/http2/Hpack.java
index 768876b689..a28698bf01 100644
--- a/okhttp/src/main/java/okhttp3/internal/http2/Hpack.java
+++ b/okhttp/src/main/java/okhttp3/internal/http2/Hpack.java
@@ -114,14 +114,12 @@ private Hpack() {
   // http://tools.ietf.org/html/draft-ietf-httpbis-header-compression-12#section-3.1
   static final class Reader {
 
-    private List<Header> headerList = new ArrayList<>();
+    private final List<Header> headerList = new ArrayList<>();
     private final BufferedSource source;
 
     private final int headerTableSizeSetting;
     private int maxDynamicTableByteCount;
 
-    private long totalBytesRead;
-
     // Visible for testing.
     Header[] dynamicTable = new Header[8];
     // Array is populated back to front, so new entries always have lowest index.
@@ -139,8 +137,6 @@ private Hpack() {
       this.source = Okio.buffer(source);
     }
 
-    long totalBytesRead() { return totalBytesRead; }
-
     int maxDynamicTableByteCount() {
       return maxDynamicTableByteCount;
     }
@@ -186,7 +182,7 @@ private int evictToRecoverBytes(int bytesToRecover) {
      */
     void readHeaders() throws IOException {
       while (!source.exhausted()) {
-        int b = readByte();
+        int b = source.readByte() & 0xff;
         if (b == 0x80) { // 10000000
           throw new IOException("index == 0");
         } else if ((b & 0x80) == 0x80) { // 1NNNNNNN
@@ -214,9 +210,8 @@ void readHeaders() throws IOException {
     }
 
     public List<Header> getAndResetHeaderList() {
-      List<Header> result = headerList;
-      headerList = new ArrayList<>();
-      totalBytesRead = 0;
+      List<Header> result = new ArrayList<>(headerList);
+      headerList.clear();
       return result;
     }
 
@@ -312,9 +307,7 @@ private void insertIntoDynamicTable(int index, Header entry) {
     }
 
     private int readByte() throws IOException {
-      int b = source.readByte() & 0xff;
-      totalBytesRead += 1;
-      return b;
+      return source.readByte() & 0xff;
     }
 
     int readInt(int firstByte, int prefixMask) throws IOException {
@@ -345,15 +338,11 @@ ByteString readByteString() throws IOException {
       boolean huffmanDecode = (firstByte & 0x80) == 0x80; // 1NNNNNNN
       int length = readInt(firstByte, PREFIX_7_BITS);
 
-      ByteString bs;
-
       if (huffmanDecode) {
-        bs = ByteString.of(Huffman.get().decode(source.readByteArray(length)));
+        return ByteString.of(Huffman.get().decode(source.readByteArray(length)));
       } else {
-        bs = source.readByteString(length);
+        return source.readByteString(length);
       }
-      totalBytesRead += length;
-      return bs;
     }
   }
 
diff --git a/okhttp/src/main/java/okhttp3/internal/http2/Http2Codec.java b/okhttp/src/main/java/okhttp3/internal/http2/Http2Codec.java
index e7911e8be9..61680d565e 100644
--- a/okhttp/src/main/java/okhttp3/internal/http2/Http2Codec.java
+++ b/okhttp/src/main/java/okhttp3/internal/http2/Http2Codec.java
@@ -27,7 +27,6 @@
 import okhttp3.Request;
 import okhttp3.Response;
 import okhttp3.ResponseBody;
-import okhttp3.StatisticsData;
 import okhttp3.internal.Internal;
 import okhttp3.internal.Util;
 import okhttp3.internal.connection.StreamAllocation;
@@ -87,14 +86,12 @@
   final StreamAllocation streamAllocation;
   private final Http2Connection connection;
   private Http2Stream stream;
-  private StatisticsData statsData;
 
   public Http2Codec(
       OkHttpClient client, StreamAllocation streamAllocation, Http2Connection connection) {
     this.client = client;
     this.streamAllocation = streamAllocation;
     this.connection = connection;
-    this.statsData = streamAllocation.statisticsData();
   }
 
   @Override public Sink createRequestBody(Request request, long contentLength) {
@@ -106,7 +103,7 @@ public Http2Codec(
 
     boolean hasRequestBody = request.body() != null;
     List<Header> requestHeaders = http2HeadersList(request);
-    stream = connection.newStream(requestHeaders, hasRequestBody, statsData, request.observer());
+    stream = connection.newStream(requestHeaders, hasRequestBody);
     stream.readTimeout().timeout(client.readTimeoutMillis(), TimeUnit.MILLISECONDS);
     stream.writeTimeout().timeout(client.writeTimeoutMillis(), TimeUnit.MILLISECONDS);
   }
@@ -117,7 +114,6 @@ public Http2Codec(
 
   @Override public void finishRequest() throws IOException {
     stream.getSink().close();
-    statsData.finishSendAtMillis = System.currentTimeMillis();
   }
 
   @Override public Response.Builder readResponseHeaders(boolean expectContinue) throws IOException {
@@ -193,11 +189,6 @@ public Http2Codec(
     if (stream != null) stream.closeLater(ErrorCode.CANCEL);
   }
 
-  @Override
-  public StatisticsData statisticsData() {
-    return statsData;
-  }
-
   class StreamFinishingSource extends ForwardingSource {
     public StreamFinishingSource(Source delegate) {
       super(delegate);
diff --git a/okhttp/src/main/java/okhttp3/internal/http2/Http2Connection.java b/okhttp/src/main/java/okhttp3/internal/http2/Http2Connection.java
index 7b02551ca3..fc89d0f10b 100644
--- a/okhttp/src/main/java/okhttp3/internal/http2/Http2Connection.java
+++ b/okhttp/src/main/java/okhttp3/internal/http2/Http2Connection.java
@@ -31,8 +31,6 @@
 import java.util.concurrent.ThreadPoolExecutor;
 import java.util.concurrent.TimeUnit;
 import okhttp3.Protocol;
-import okhttp3.StatisticsData;
-import okhttp3.StatisticsObserver;
 import okhttp3.internal.NamedRunnable;
 import okhttp3.internal.Util;
 import okhttp3.internal.platform.Platform;
@@ -195,7 +193,7 @@ public synchronized int maxConcurrentStreams() {
   public Http2Stream pushStream(int associatedStreamId, List<Header> requestHeaders, boolean out)
       throws IOException {
     if (client) throw new IllegalStateException("Client cannot push requests.");
-    return newStream(associatedStreamId, requestHeaders, out, new StatisticsData(), null);
+    return newStream(associatedStreamId, requestHeaders, out);
   }
 
   /**
@@ -203,16 +201,12 @@ public Http2Stream pushStream(int associatedStreamId, List<Header> requestHeader
    * @param out true to create an output stream that we can use to send data to the remote peer.
    * Corresponds to {@code FLAG_FIN}.
    */
-  Http2Stream newStream(List<Header> requestHeaders, boolean out) throws IOException {
-    return newStream(requestHeaders, out, new StatisticsData(), null);
-  }
-
-  public Http2Stream newStream(List<Header> requestHeaders, boolean out, StatisticsData statsData, StatisticsObserver observer) throws IOException {
-    return newStream(0, requestHeaders, out, statsData, observer);
+  public Http2Stream newStream(List<Header> requestHeaders, boolean out) throws IOException {
+    return newStream(0, requestHeaders, out);
   }
 
   private Http2Stream newStream(
-      int associatedStreamId, List<Header> requestHeaders, boolean out, StatisticsData statsData, StatisticsObserver observer) throws IOException {
+      int associatedStreamId, List<Header> requestHeaders, boolean out) throws IOException {
     boolean outFinished = !out;
     boolean inFinished = false;
     boolean flushHeaders;
@@ -226,18 +220,18 @@ private Http2Stream newStream(
         }
         streamId = nextStreamId;
         nextStreamId += 2;
-        stream = new Http2Stream(streamId, this, outFinished, inFinished, requestHeaders, statsData, observer);
+        stream = new Http2Stream(streamId, this, outFinished, inFinished, requestHeaders);
         flushHeaders = !out || bytesLeftInWriteWindow == 0L || stream.bytesLeftInWriteWindow == 0L;
         if (stream.isOpen()) {
           streams.put(streamId, stream);
         }
       }
       if (associatedStreamId == 0) {
-        writer.synStream(outFinished, streamId, associatedStreamId, requestHeaders, statsData);
+        writer.synStream(outFinished, streamId, associatedStreamId, requestHeaders);
       } else if (client) {
         throw new IllegalArgumentException("client streams shouldn't have associated stream IDs");
       } else { // HTTP/2 has a PUSH_PROMISE frame.
-        writer.pushPromise(associatedStreamId, streamId, requestHeaders, statsData);
+        writer.pushPromise(associatedStreamId, streamId, requestHeaders);
       }
     }
 
@@ -248,9 +242,9 @@ private Http2Stream newStream(
     return stream;
   }
 
-  void writeSynReply(int streamId, boolean outFinished, List<Header> alternating, StatisticsData statsData)
+  void writeSynReply(int streamId, boolean outFinished, List<Header> alternating)
       throws IOException {
-    writer.synReply(outFinished, streamId, alternating, statsData);
+    writer.synReply(outFinished, streamId, alternating);
   }
 
   /**
@@ -265,10 +259,10 @@ void writeSynReply(int streamId, boolean outFinished, List<Header> alternating,
    * <p>Zero {@code byteCount} writes are not subject to flow control and will not block. The only
    * use case for zero {@code byteCount} is closing a flushed output stream.
    */
-  public void writeData(int streamId, boolean outFinished, Buffer buffer, long byteCount, StatisticsData statsData)
+  public void writeData(int streamId, boolean outFinished, Buffer buffer, long byteCount)
       throws IOException {
     if (byteCount == 0) { // Empty data frames are not flow-controlled.
-      writer.data(outFinished, streamId, buffer, 0, statsData);
+      writer.data(outFinished, streamId, buffer, 0);
       return;
     }
 
@@ -294,7 +288,7 @@ public void writeData(int streamId, boolean outFinished, Buffer buffer, long byt
       }
 
       byteCount -= toWrite;
-      writer.data(outFinished && byteCount == 0, streamId, buffer, toWrite, statsData);
+      writer.data(outFinished && byteCount == 0, streamId, buffer, toWrite);
     }
   }
 
@@ -514,7 +508,6 @@ public synchronized boolean isShutdown() {
     Listener listener = Listener.REFUSE_INCOMING_STREAMS;
     PushObserver pushObserver = PushObserver.CANCEL;
     boolean client;
-    StatisticsData statsData;
 
     /**
      * @param client true if this peer initiated the connection; false if this peer accepted the
@@ -548,11 +541,6 @@ public Builder pushObserver(PushObserver pushObserver) {
       return this;
     }
 
-    public Builder statisticsData(StatisticsData statsData) {
-      this.statsData = statsData;
-      return this;
-    }
-
     public Http2Connection build() throws IOException {
       return new Http2Connection(this);
     }
@@ -591,7 +579,7 @@ public Http2Connection build() throws IOException {
       }
     }
 
-    @Override public void data(boolean inFinished, int streamId, BufferedSource source, int length, StatisticsData statsData)
+    @Override public void data(boolean inFinished, int streamId, BufferedSource source, int length)
         throws IOException {
       if (pushedStream(streamId)) {
         pushDataLater(streamId, source, length, inFinished);
@@ -603,7 +591,6 @@ public Http2Connection build() throws IOException {
         source.skip(length);
         return;
       }
-      dataStream.mergeDataStats(statsData);
       dataStream.receiveData(source, length);
       if (inFinished) {
         dataStream.receiveFin();
@@ -611,7 +598,7 @@ public Http2Connection build() throws IOException {
     }
 
     @Override public void headers(boolean inFinished, int streamId, int associatedStreamId,
-        List<Header> headerBlock, StatisticsData statsData) {
+        List<Header> headerBlock) {
       if (pushedStream(streamId)) {
         pushHeadersLater(streamId, headerBlock, inFinished);
         return;
@@ -632,7 +619,7 @@ public Http2Connection build() throws IOException {
 
           // Create a stream.
           final Http2Stream newStream = new Http2Stream(streamId, Http2Connection.this,
-              false, inFinished, headerBlock, statsData, null);
+              false, inFinished, headerBlock);
           lastGoodStreamId = streamId;
           streams.put(streamId, newStream);
           executor.execute(new NamedRunnable("OkHttp %s stream %d", hostname, streamId) {
@@ -653,7 +640,6 @@ public Http2Connection build() throws IOException {
       }
 
       // Update an existing stream.
-      stream.mergeHeaderStats(statsData);
       stream.receiveHeaders(headerBlock);
       if (inFinished) stream.receiveFin();
     }
diff --git a/okhttp/src/main/java/okhttp3/internal/http2/Http2Reader.java b/okhttp/src/main/java/okhttp3/internal/http2/Http2Reader.java
index 686a59fb03..c6fd4ccdac 100644
--- a/okhttp/src/main/java/okhttp3/internal/http2/Http2Reader.java
+++ b/okhttp/src/main/java/okhttp3/internal/http2/Http2Reader.java
@@ -19,8 +19,6 @@
 import java.io.IOException;
 import java.util.List;
 import java.util.logging.Logger;
-
-import okhttp3.StatisticsData;
 import okio.Buffer;
 import okio.BufferedSource;
 import okio.ByteString;
@@ -65,10 +63,6 @@
   private final ContinuationSource continuation;
   private final boolean client;
 
-  private long totalBytesRead;
-  private long frameInitialTBR;
-  private long frameRecvTime;
-
   // Visible for testing.
   final Hpack.Reader hpackReader;
 
@@ -80,9 +74,6 @@ public Http2Reader(BufferedSource source, boolean client) {
     this.hpackReader = new Hpack.Reader(4096, continuation);
   }
 
-  public long totalBytesRead() { return totalBytesRead; }
-  public long frameBytesRead() { return totalBytesRead - frameInitialTBR; }
-
   public void readConnectionPreface(Handler handler) throws IOException {
     if (client) {
       // The client reads the initial SETTINGS frame.
@@ -92,7 +83,6 @@ public void readConnectionPreface(Handler handler) throws IOException {
     } else {
       // The server reads the CONNECTION_PREFACE byte string.
       ByteString connectionPreface = source.readByteString(CONNECTION_PREFACE.size());
-      totalBytesRead += CONNECTION_PREFACE.size();
       if (logger.isLoggable(FINE)) logger.fine(format("<< CONNECTION %s", connectionPreface.hex()));
       if (!CONNECTION_PREFACE.equals(connectionPreface)) {
         throw ioException("Expected a connection header but was %s", connectionPreface.utf8());
@@ -107,8 +97,6 @@ public boolean nextFrame(boolean requireSettings, Handler handler) throws IOExce
       return false; // This might be a normal socket close.
     }
 
-    frameInitialTBR = totalBytesRead;
-
     //  0                   1                   2                   3
     //  0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
     // +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
@@ -121,19 +109,15 @@ public boolean nextFrame(boolean requireSettings, Handler handler) throws IOExce
     // |                   Frame Payload (0...)                      ...
     // +---------------------------------------------------------------+
     int length = readMedium(source);
-    frameRecvTime = System.currentTimeMillis();
     if (length < 0 || length > INITIAL_MAX_FRAME_SIZE) {
       throw ioException("FRAME_SIZE_ERROR: %s", length);
     }
     byte type = (byte) (source.readByte() & 0xff);
-    totalBytesRead += 1;
     if (requireSettings && type != TYPE_SETTINGS) {
       throw ioException("Expected a SETTINGS frame but was %s", type);
     }
     byte flags = (byte) (source.readByte() & 0xff);
-    totalBytesRead += 1;
     int streamId = (source.readInt() & 0x7fffffff); // Ignore reserved bit.
-    totalBytesRead += 4;
     if (logger.isLoggable(FINE)) logger.fine(frameLog(true, streamId, length, type, flags));
 
     switch (type) {
@@ -186,12 +170,7 @@ private void readHeaders(Handler handler, int length, byte flags, int streamId)
 
     boolean endStream = (flags & FLAG_END_STREAM) != 0;
 
-    short padding = 0;
-
-    if ((flags & FLAG_PADDED) != 0) {
-      padding = (short) (source.readByte() & 0xff);
-      totalBytesRead += 1;
-    }
+    short padding = (flags & FLAG_PADDED) != 0 ? (short) (source.readByte() & 0xff) : 0;
 
     if ((flags & FLAG_PRIORITY) != 0) {
       readPriority(handler, streamId);
@@ -202,8 +181,7 @@ private void readHeaders(Handler handler, int length, byte flags, int streamId)
 
     List<Header> headerBlock = readHeaderBlock(length, padding, flags, streamId);
 
-    handler.headers(endStream, streamId, -1, headerBlock,
-      StatisticsData.allocateForReceivedHeaders(frameRecvTime, frameBytesRead()));
+    handler.headers(endStream, streamId, -1, headerBlock);
   }
 
   private List<Header> readHeaderBlock(int length, short padding, byte flags, int streamId)
@@ -216,7 +194,6 @@ private void readHeaders(Handler handler, int length, byte flags, int streamId)
     // TODO: Concat multi-value headers with 0x0, except COOKIE, which uses 0x3B, 0x20.
     // http://tools.ietf.org/html/draft-ietf-httpbis-http2-17#section-8.1.2.5
     hpackReader.readHeaders();
-    totalBytesRead += hpackReader.totalBytesRead();
     return hpackReader.getAndResetHeaderList();
   }
 
@@ -231,16 +208,10 @@ private void readData(Handler handler, int length, byte flags, int streamId)
       throw ioException("PROTOCOL_ERROR: FLAG_COMPRESSED without SETTINGS_COMPRESS_DATA");
     }
 
-    short padding = 0;
-    if ((flags & FLAG_PADDED) != 0) {
-      padding = (short) (source.readByte() & 0xff);
-      totalBytesRead += 1;
-    }
-
+    short padding = (flags & FLAG_PADDED) != 0 ? (short) (source.readByte() & 0xff) : 0;
     length = lengthWithoutPadding(length, flags, padding);
 
-    handler.data(inFinished, streamId, source, length,
-      StatisticsData.allocateForReceivedData(frameRecvTime, frameBytesRead()));
+    handler.data(inFinished, streamId, source, length);
     source.skip(padding);
   }
 
@@ -253,11 +224,9 @@ private void readPriority(Handler handler, int length, byte flags, int streamId)
 
   private void readPriority(Handler handler, int streamId) throws IOException {
     int w1 = source.readInt();
-    totalBytesRead += 4;
     boolean exclusive = (w1 & 0x80000000) != 0;
     int streamDependency = (w1 & 0x7fffffff);
     int weight = (source.readByte() & 0xff) + 1;
-    totalBytesRead += 1;
     handler.priority(streamId, streamDependency, weight, exclusive);
   }
 
@@ -266,7 +235,6 @@ private void readRstStream(Handler handler, int length, byte flags, int streamId
     if (length != 4) throw ioException("TYPE_RST_STREAM length: %d != 4", length);
     if (streamId == 0) throw ioException("TYPE_RST_STREAM streamId == 0");
     int errorCodeInt = source.readInt();
-    totalBytesRead += 4;
     ErrorCode errorCode = ErrorCode.fromHttp2(errorCodeInt);
     if (errorCode == null) {
       throw ioException("TYPE_RST_STREAM unexpected error code: %d", errorCodeInt);
@@ -287,9 +255,7 @@ private void readSettings(Handler handler, int length, byte flags, int streamId)
     Settings settings = new Settings();
     for (int i = 0; i < length; i += 6) {
       short id = source.readShort();
-      totalBytesRead += 2;
       int value = source.readInt();
-      totalBytesRead += 4;
 
       switch (id) {
         case 1: // SETTINGS_HEADER_TABLE_SIZE
@@ -328,13 +294,8 @@ private void readPushPromise(Handler handler, int length, byte flags, int stream
     if (streamId == 0) {
       throw ioException("PROTOCOL_ERROR: TYPE_PUSH_PROMISE streamId == 0");
     }
-    short padding = 0;
-    if ((flags & FLAG_PADDED) != 0) {
-      padding = (short) (source.readByte() & 0xff);
-      totalBytesRead += 1;
-    }
+    short padding = (flags & FLAG_PADDED) != 0 ? (short) (source.readByte() & 0xff) : 0;
     int promisedStreamId = source.readInt() & 0x7fffffff;
-    totalBytesRead += 4;
     length -= 4; // account for above read.
     length = lengthWithoutPadding(length, flags, padding);
     List<Header> headerBlock = readHeaderBlock(length, padding, flags, streamId);
@@ -346,9 +307,7 @@ private void readPing(Handler handler, int length, byte flags, int streamId)
     if (length != 8) throw ioException("TYPE_PING length != 8: %s", length);
     if (streamId != 0) throw ioException("TYPE_PING streamId != 0");
     int payload1 = source.readInt();
-    totalBytesRead += 4;
     int payload2 = source.readInt();
-    totalBytesRead += 4;
     boolean ack = (flags & FLAG_ACK) != 0;
     handler.ping(ack, payload1, payload2);
   }
@@ -358,9 +317,7 @@ private void readGoAway(Handler handler, int length, byte flags, int streamId)
     if (length < 8) throw ioException("TYPE_GOAWAY length < 8: %s", length);
     if (streamId != 0) throw ioException("TYPE_GOAWAY streamId != 0");
     int lastStreamId = source.readInt();
-    totalBytesRead += 4;
     int errorCodeInt = source.readInt();
-    totalBytesRead += 4;
     int opaqueDataLength = length - 8;
     ErrorCode errorCode = ErrorCode.fromHttp2(errorCodeInt);
     if (errorCode == null) {
@@ -369,7 +326,6 @@ private void readGoAway(Handler handler, int length, byte flags, int streamId)
     ByteString debugData = EMPTY;
     if (opaqueDataLength > 0) { // Must read debug data in order to not corrupt the connection.
       debugData = source.readByteString(opaqueDataLength);
-      totalBytesRead += opaqueDataLength;
     }
     handler.goAway(lastStreamId, errorCode, debugData);
   }
@@ -378,7 +334,6 @@ private void readWindowUpdate(Handler handler, int length, byte flags, int strea
       throws IOException {
     if (length != 4) throw ioException("TYPE_WINDOW_UPDATE length !=4: %s", length);
     long increment = (source.readInt() & 0x7fffffffL);
-    totalBytesRead += 4;
     if (increment == 0) throw ioException("windowSizeIncrement was 0", increment);
     handler.windowUpdate(streamId, increment);
   }
@@ -414,9 +369,7 @@ public ContinuationSource(BufferedSource source) {
         // TODO: test case for empty continuation header?
       }
 
-      final long amt = Math.min(byteCount, left);
-      long read = source.read(sink, amt);
-      // We track the number of bytes read from the Hpack.Reader
+      long read = source.read(sink, Math.min(byteCount, left));
       if (read == -1) return -1;
       left -= read;
       return read;
@@ -458,7 +411,7 @@ static int lengthWithoutPadding(int length, byte flags, short padding)
   }
 
   interface Handler {
-    void data(boolean inFinished, int streamId, BufferedSource source, int length, StatisticsData statsData)
+    void data(boolean inFinished, int streamId, BufferedSource source, int length)
         throws IOException;
 
     /**
@@ -470,7 +423,7 @@ void data(boolean inFinished, int streamId, BufferedSource source, int length, S
      * @param associatedStreamId the stream that triggered the sender to create this stream.
      */
     void headers(boolean inFinished, int streamId, int associatedStreamId,
-        List<Header> headerBlock, StatisticsData statsData);
+        List<Header> headerBlock);
 
     void rstStream(int streamId, ErrorCode errorCode);
 
diff --git a/okhttp/src/main/java/okhttp3/internal/http2/Http2Stream.java b/okhttp/src/main/java/okhttp3/internal/http2/Http2Stream.java
index 4fbe00a112..19ac954d7e 100644
--- a/okhttp/src/main/java/okhttp3/internal/http2/Http2Stream.java
+++ b/okhttp/src/main/java/okhttp3/internal/http2/Http2Stream.java
@@ -21,8 +21,6 @@
 import java.net.SocketTimeoutException;
 import java.util.ArrayList;
 import java.util.List;
-import okhttp3.StatisticsData;
-import okhttp3.StatisticsObserver;
 import okio.AsyncTimeout;
 import okio.Buffer;
 import okio.BufferedSource;
@@ -67,9 +65,6 @@
   final StreamTimeout readTimeout = new StreamTimeout();
   final StreamTimeout writeTimeout = new StreamTimeout();
 
-  private StatisticsObserver observer;
-  private final StatisticsData statsData; // This instance is shared across several objects.
-
   /**
    * The reason why this stream was abnormally closed. If there are multiple reasons to abnormally
    * close this stream (such as both peers closing it near-simultaneously) then this is the first
@@ -78,7 +73,7 @@
   ErrorCode errorCode = null;
 
   Http2Stream(int id, Http2Connection connection, boolean outFinished, boolean inFinished,
-      List<Header> requestHeaders, StatisticsData statsData, StatisticsObserver observer) {
+      List<Header> requestHeaders) {
     if (connection == null) throw new NullPointerException("connection == null");
     if (requestHeaders == null) throw new NullPointerException("requestHeaders == null");
     this.id = id;
@@ -90,22 +85,12 @@
     this.source.finished = inFinished;
     this.sink.finished = outFinished;
     this.requestHeaders = requestHeaders;
-    this.observer = observer;
-    this.statsData = statsData;
   }
 
   public int getId() {
     return id;
   }
 
-  public void mergeHeaderStats(StatisticsData otherData) {
-    statsData.mergeHeaderStats(otherData);
-  }
-
-  public void mergeDataStats(StatisticsData otherData) {
-    statsData.mergeDataStats(otherData);
-  }
-
   /**
    * Returns true if this stream is open. A stream is open until either:
    *
@@ -195,7 +180,7 @@ public void sendResponseHeaders(List<Header> responseHeaders, boolean out) throw
         outFinished = true;
       }
     }
-    connection.writeSynReply(id, outFinished, responseHeaders, statsData);
+    connection.writeSynReply(id, outFinished, responseHeaders);
 
     if (outFinished) {
       connection.flush();
@@ -307,8 +292,6 @@ void receiveFin() {
     if (!open) {
       connection.removeStream(id);
     }
-
-    statsData.reportCompleted(observer);
   }
 
   synchronized void receiveRstStream(ErrorCode errorCode) {
@@ -419,10 +402,9 @@ void receive(BufferedSource in, long byteCount) throws IOException {
         // Fill the receive buffer without holding any locks.
         long read = in.read(receiveBuffer, byteCount);
         if (read == -1) throw new EOFException();
-        statsData.byteCountBodyReceived += read;
         byteCount -= read;
 
-        // Move the received data to the read buffer so the reader can read it.
+        // Move the received data to the read buffer to the reader can read it.
         synchronized (Http2Stream.this) {
           boolean wasEmpty = readBuffer.size() == 0;
           readBuffer.writeAll(receiveBuffer);
@@ -523,7 +505,7 @@ private void emitFrame(boolean outFinished) throws IOException {
 
       writeTimeout.enter();
       try {
-        connection.writeData(id, outFinished && toWrite == sendBuffer.size(), sendBuffer, toWrite, statsData);
+        connection.writeData(id, outFinished && toWrite == sendBuffer.size(), sendBuffer, toWrite);
       } finally {
         writeTimeout.exitAndThrowIfTimedOut();
       }
@@ -557,7 +539,7 @@ private void emitFrame(boolean outFinished) throws IOException {
           }
         } else {
           // Send an empty frame just so we can set the END_STREAM flag.
-          connection.writeData(id, true, null, 0, statsData);
+          connection.writeData(id, true, null, 0);
         }
       }
       synchronized (Http2Stream.this) {
diff --git a/okhttp/src/main/java/okhttp3/internal/http2/Http2Writer.java b/okhttp/src/main/java/okhttp3/internal/http2/Http2Writer.java
index d8415cfc16..7490b09ba0 100644
--- a/okhttp/src/main/java/okhttp3/internal/http2/Http2Writer.java
+++ b/okhttp/src/main/java/okhttp3/internal/http2/Http2Writer.java
@@ -19,7 +19,6 @@
 import java.io.IOException;
 import java.util.List;
 import java.util.logging.Logger;
-import okhttp3.StatisticsData;
 import okio.Buffer;
 import okio.BufferedSink;
 
@@ -101,12 +100,8 @@ public synchronized void applyAndAckSettings(Settings peerSettings) throws IOExc
    * @param requestHeaders minimally includes {@code :method}, {@code :scheme}, {@code :authority},
    * and {@code :path}.
    */
-  void pushPromise(int streamId, int promisedStreamId, List<Header> requestHeaders) throws IOException {
-    pushPromise(streamId, promisedStreamId, requestHeaders, new StatisticsData());
-  }
-
   public synchronized void pushPromise(int streamId, int promisedStreamId,
-      List<Header> requestHeaders, StatisticsData statsData) throws IOException {
+      List<Header> requestHeaders) throws IOException {
     if (closed) throw new IOException("closed");
     hpackWriter.writeHeaders(requestHeaders);
 
@@ -117,10 +112,8 @@ public synchronized void pushPromise(int streamId, int promisedStreamId,
     frameHeader(streamId, length + 4, type, flags);
     sink.writeInt(promisedStreamId & 0x7fffffff);
     sink.write(hpackBuffer, length);
-    statsData.byteCountHeadersSent = 9 + 4 + length; // 9 = framing data. 4 = promised id. length = headers.
 
-    if (byteCount > length) writeContinuationFrames(streamId, byteCount - length, statsData);
-    statsData.finishSendAtMillis = System.currentTimeMillis();
+    if (byteCount > length) writeContinuationFrames(streamId, byteCount - length);
   }
 
   public synchronized void flush() throws IOException {
@@ -128,35 +121,22 @@ public synchronized void flush() throws IOException {
     sink.flush();
   }
 
-  void synStream(boolean outFinished, int streamId,
-      int associatedStreamId, List<Header> headerBlock) throws IOException {
-    synStream(outFinished, streamId, associatedStreamId, headerBlock, new StatisticsData());
-  }
-
   public synchronized void synStream(boolean outFinished, int streamId,
-      int associatedStreamId, List<Header> headerBlock, StatisticsData statsData) throws IOException {
+      int associatedStreamId, List<Header> headerBlock) throws IOException {
     if (closed) throw new IOException("closed");
-    headers(outFinished, streamId, headerBlock, statsData);
-  }
-
-  void synReply(boolean outFinished, int streamId, List<Header> headerBlock) throws IOException {
-    synReply(outFinished, streamId, headerBlock, new StatisticsData());
+    headers(outFinished, streamId, headerBlock);
   }
 
   public synchronized void synReply(boolean outFinished, int streamId,
-      List<Header> headerBlock, StatisticsData statsData) throws IOException {
-    if (closed) throw new IOException("closed");
-    headers(outFinished, streamId, headerBlock, statsData);
-  }
-
-  synchronized void headers(int streamId, List<Header> headerBlock) throws IOException {
+      List<Header> headerBlock) throws IOException {
     if (closed) throw new IOException("closed");
-    headers(false, streamId, headerBlock, new StatisticsData());
+    headers(outFinished, streamId, headerBlock);
   }
 
-  public synchronized void headers(int streamId, List<Header> headerBlock, StatisticsData statsData) throws IOException {
+  public synchronized void headers(int streamId, List<Header> headerBlock)
+      throws IOException {
     if (closed) throw new IOException("closed");
-    headers(false, streamId, headerBlock, statsData);
+    headers(false, streamId, headerBlock);
   }
 
   public synchronized void rstStream(int streamId, ErrorCode errorCode)
@@ -185,28 +165,19 @@ public int maxDataLength() {
    * @param byteCount must be between 0 and the minimum of {@code source.length} and {@link
    * #maxDataLength}.
    */
-  void data(boolean outFinished, int streamId, Buffer source, int byteCount) throws IOException {
-    data(outFinished, streamId, source, byteCount, new StatisticsData());
-  }
-
-  public synchronized void data(boolean outFinished, int streamId, Buffer source, int byteCount, StatisticsData statsData)
+  public synchronized void data(boolean outFinished, int streamId, Buffer source, int byteCount)
       throws IOException {
     if (closed) throw new IOException("closed");
     byte flags = FLAG_NONE;
     if (outFinished) flags |= FLAG_END_STREAM;
-    dataFrame(streamId, flags, source, byteCount, statsData);
+    dataFrame(streamId, flags, source, byteCount);
   }
 
   void dataFrame(int streamId, byte flags, Buffer buffer, int byteCount) throws IOException {
-    dataFrame(streamId, flags, buffer, byteCount, new StatisticsData());
-  }
-
-  void dataFrame(int streamId, byte flags, Buffer buffer, int byteCount, StatisticsData statsData) throws IOException {
     byte type = TYPE_DATA;
     frameHeader(streamId, byteCount, type, flags);
     if (byteCount > 0) {
       sink.write(buffer, byteCount);
-      statsData.byteCountBodySent += byteCount;
     }
   }
 
@@ -314,21 +285,16 @@ private static void writeMedium(BufferedSink sink, int i) throws IOException {
     sink.writeByte(i & 0xff);
   }
 
-  private void writeContinuationFrames(int streamId, long byteCount, StatisticsData statsData) throws IOException {
+  private void writeContinuationFrames(int streamId, long byteCount) throws IOException {
     while (byteCount > 0) {
       int length = (int) Math.min(maxFrameSize, byteCount);
       byteCount -= length;
       frameHeader(streamId, length, TYPE_CONTINUATION, byteCount == 0 ? FLAG_END_HEADERS : 0);
       sink.write(hpackBuffer, length);
-      statsData.byteCountHeadersSent += length + 9; // 9 for the frame header.
     }
   }
 
   void headers(boolean outFinished, int streamId, List<Header> headerBlock) throws IOException {
-    headers(outFinished, streamId, headerBlock, new StatisticsData());
-  }
-
-  void headers(boolean outFinished, int streamId, List<Header> headerBlock, StatisticsData statsData) throws IOException {
     if (closed) throw new IOException("closed");
     hpackWriter.writeHeaders(headerBlock);
 
@@ -337,13 +303,9 @@ void headers(boolean outFinished, int streamId, List<Header> headerBlock, Statis
     byte type = TYPE_HEADERS;
     byte flags = byteCount == length ? FLAG_END_HEADERS : 0;
     if (outFinished) flags |= FLAG_END_STREAM;
-    statsData.initiateSendAtMillis = System.currentTimeMillis();
     frameHeader(streamId, length, type, flags);
     sink.write(hpackBuffer, length);
-    statsData.byteCountHeadersSent += length + 9; // 9 for the frame header.
 
-    if (byteCount > length) writeContinuationFrames(streamId, byteCount - length, statsData);
-    if (outFinished)
-      statsData.finishSendAtMillis = System.currentTimeMillis();
+    if (byteCount > length) writeContinuationFrames(streamId, byteCount - length);
   }
 }
