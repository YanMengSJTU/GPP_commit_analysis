diff --git a/README.md b/README.md
index 4cb0f5613b..0e239589a1 100644
--- a/README.md
+++ b/README.md
@@ -11,12 +11,12 @@ Download [the latest JAR][3] or grab via Maven:
 <dependency>
   <groupId>com.squareup.okhttp</groupId>
   <artifactId>okhttp</artifactId>
-  <version>2.1.0</version>
+  <version>2.2.0</version>
 </dependency>
 ```
 or Gradle:
 ```groovy
-compile 'com.squareup.okhttp:okhttp:2.1.0'
+compile 'com.squareup.okhttp:okhttp:2.2.0'
 ```
 
 Snapshots of the development version are available in [Sonatype's `snapshots` repository][snap].
@@ -36,13 +36,13 @@ Download [the latest JAR][4] or grab via Maven:
 <dependency>
   <groupId>com.squareup.okhttp</groupId>
   <artifactId>mockwebserver</artifactId>
-  <version>2.1.0</version>
+  <version>2.2.0</version>
   <scope>test</scope>
 </dependency>
 ```
 or Gradle:
 ```groovy
-testCompile 'com.squareup.okhttp:mockwebserver:2.1.0'
+testCompile 'com.squareup.okhttp:mockwebserver:2.2.0'
 ```
 
 
diff --git a/benchmarks/src/main/java/com/squareup/okhttp/benchmarks/Benchmark.java b/benchmarks/src/main/java/com/squareup/okhttp/benchmarks/Benchmark.java
index 0ae5127ac5..7f0073cc7d 100644
--- a/benchmarks/src/main/java/com/squareup/okhttp/benchmarks/Benchmark.java
+++ b/benchmarks/src/main/java/com/squareup/okhttp/benchmarks/Benchmark.java
@@ -24,9 +24,7 @@
 import com.squareup.okhttp.mockwebserver.MockResponse;
 import com.squareup.okhttp.mockwebserver.MockWebServer;
 import com.squareup.okhttp.mockwebserver.RecordedRequest;
-import java.io.ByteArrayOutputStream;
 import java.io.IOException;
-import java.io.OutputStream;
 import java.net.URL;
 import java.util.ArrayList;
 import java.util.Arrays;
@@ -35,9 +33,9 @@
 import java.util.concurrent.TimeUnit;
 import java.util.logging.Level;
 import java.util.logging.Logger;
-import java.util.zip.GZIPOutputStream;
 import javax.net.ssl.SSLContext;
 import okio.Buffer;
+import okio.GzipSink;
 
 /**
  * This benchmark is fake, but may be useful for certain relative comparisons.
@@ -175,23 +173,28 @@ private MockWebServer startServer() throws IOException {
       }
     });
 
-    server.play();
+    server.start();
     return server;
   }
 
   private MockResponse newResponse() throws IOException {
-    byte[] body = new byte[bodyByteCount];
-    random.nextBytes(body);
+    byte[] bytes = new byte[bodyByteCount];
+    random.nextBytes(bytes);
+    Buffer body = new Buffer().write(bytes);
 
     MockResponse result = new MockResponse();
 
     if (gzip) {
-      body = gzip(body);
+      Buffer gzipBody = new Buffer();
+      GzipSink gzipSink = new GzipSink(gzipBody);
+      gzipSink.write(body, body.size());
+      gzipSink.close();
+      body = gzipBody;
       result.addHeader("Content-Encoding: gzip");
     }
 
     if (chunked) {
-      result.setChunkedBody(new Buffer().write(body), 1024);
+      result.setChunkedBody(body, 1024);
     } else {
       result.setBody(body);
     }
@@ -211,13 +214,4 @@ private String randomString(int length) {
     }
     return new String(result);
   }
-
-  /** Returns a gzipped copy of {@code bytes}. */
-  private byte[] gzip(byte[] bytes) throws IOException {
-    ByteArrayOutputStream bytesOut = new ByteArrayOutputStream();
-    OutputStream gzippedOut = new GZIPOutputStream(bytesOut);
-    gzippedOut.write(bytes);
-    gzippedOut.close();
-    return bytesOut.toByteArray();
-  }
 }
diff --git a/mockwebserver/README.md b/mockwebserver/README.md
index 9596ec1639..c72966826c 100644
--- a/mockwebserver/README.md
+++ b/mockwebserver/README.md
@@ -39,7 +39,7 @@ public void test() throws Exception {
   server.enqueue(new MockResponse().setBody("yo dog"));
 
   // Start the server.
-  server.play();
+  server.start();
 
   // Ask the server for its URL. You'll need this to make HTTP requests.
   URL baseUrl = server.getUrl("/v1/chat/");
diff --git a/mockwebserver/pom.xml b/mockwebserver/pom.xml
index b710a1e115..ae3abb5c66 100644
--- a/mockwebserver/pom.xml
+++ b/mockwebserver/pom.xml
@@ -31,6 +31,16 @@
 
   <build>
     <plugins>
+      <plugin>
+        <groupId>org.apache.maven.plugins</groupId>
+        <artifactId>maven-javadoc-plugin</artifactId>
+        <configuration>
+          <links>
+            <link>http://square.github.io/okhttp/javadoc/</link>
+            <link>http://square.github.io/okio/</link>
+          </links>
+        </configuration>
+      </plugin>
       <plugin>
         <groupId>org.apache.maven.plugins</groupId>
         <artifactId>maven-assembly-plugin</artifactId>
diff --git a/mockwebserver/src/main/java/com/squareup/okhttp/mockwebserver/Dispatcher.java b/mockwebserver/src/main/java/com/squareup/okhttp/mockwebserver/Dispatcher.java
index b7de9b67d4..4e1e0e70f6 100644
--- a/mockwebserver/src/main/java/com/squareup/okhttp/mockwebserver/Dispatcher.java
+++ b/mockwebserver/src/main/java/com/squareup/okhttp/mockwebserver/Dispatcher.java
@@ -33,9 +33,4 @@
   public MockResponse peek() {
     return new MockResponse().setSocketPolicy(SocketPolicy.KEEP_OPEN);
   }
-
-  /** @deprecated replaced with {@link #peek}. */
-  protected final SocketPolicy peekSocketPolicy() {
-    throw new UnsupportedOperationException("This API is obsolete. Override peek() instead!");
-  }
 }
diff --git a/mockwebserver/src/main/java/com/squareup/okhttp/mockwebserver/MockResponse.java b/mockwebserver/src/main/java/com/squareup/okhttp/mockwebserver/MockResponse.java
index 350c6f65ac..8f0ee2c50f 100644
--- a/mockwebserver/src/main/java/com/squareup/okhttp/mockwebserver/MockResponse.java
+++ b/mockwebserver/src/main/java/com/squareup/okhttp/mockwebserver/MockResponse.java
@@ -15,9 +15,9 @@
  */
 package com.squareup.okhttp.mockwebserver;
 
-import java.io.InputStream;
+import com.squareup.okhttp.Headers;
+import com.squareup.okhttp.internal.ws.WebSocketListener;
 import java.util.ArrayList;
-import java.util.Iterator;
 import java.util.List;
 import java.util.concurrent.TimeUnit;
 import okio.Buffer;
@@ -27,32 +27,31 @@
   private static final String CHUNKED_BODY_HEADER = "Transfer-encoding: chunked";
 
   private String status = "HTTP/1.1 200 OK";
-  private List<String> headers = new ArrayList<>();
+  private Headers.Builder headers = new Headers.Builder();
 
-  /** The response body content, or null if {@code bodyStream} is set. */
   private Buffer body;
-  /** The response body content, or null if {@code body} is set. */
-  private InputStream bodyStream;
 
-  private int throttleBytesPerPeriod = Integer.MAX_VALUE;
-  private long throttlePeriod = 1;
-  private TimeUnit throttleUnit = TimeUnit.SECONDS;
+  private long throttleBytesPerPeriod = Long.MAX_VALUE;
+  private long throttlePeriodAmount = 1;
+  private TimeUnit throttlePeriodUnit = TimeUnit.SECONDS;
 
   private SocketPolicy socketPolicy = SocketPolicy.KEEP_OPEN;
 
-  private int bodyDelayTimeMs = 0;
+  private long bodyDelayAmount = 0;
+  private TimeUnit bodyDelayUnit = TimeUnit.MILLISECONDS;
 
   private List<PushPromise> promises = new ArrayList<>();
+  private WebSocketListener webSocketListener;
 
   /** Creates a new mock response with an empty body. */
   public MockResponse() {
-    setBody(new Buffer());
+    setHeader("Content-Length", 0);
   }
 
   @Override public MockResponse clone() {
     try {
       MockResponse result = (MockResponse) super.clone();
-      result.headers = new ArrayList<>(headers);
+      result.headers = headers.build().newBuilder();
       result.promises = new ArrayList<>(promises);
       return result;
     } catch (CloneNotSupportedException e) {
@@ -66,8 +65,7 @@ public String getStatus() {
   }
 
   public MockResponse setResponseCode(int code) {
-    this.status = "HTTP/1.1 " + code + " OK";
-    return this;
+    return setStatus("HTTP/1.1 " + code + " OK");
   }
 
   public MockResponse setStatus(String status) {
@@ -76,8 +74,8 @@ public MockResponse setStatus(String status) {
   }
 
   /** Returns the HTTP headers, such as "Content-Length: 0". */
-  public List<String> getHeaders() {
-    return headers;
+  public Headers getHeaders() {
+    return headers.build();
   }
 
   /**
@@ -85,7 +83,7 @@ public MockResponse setStatus(String status) {
    * "Transfer-encoding" headers that were added by default.
    */
   public MockResponse clearHeaders() {
-    headers.clear();
+    headers = new Headers.Builder();
     return this;
   }
 
@@ -103,7 +101,8 @@ public MockResponse addHeader(String header) {
    * headers with the same name.
    */
   public MockResponse addHeader(String name, Object value) {
-    return addHeader(name + ": " + String.valueOf(value));
+    headers.add(name, String.valueOf(value));
+    return this;
   }
 
   /**
@@ -115,43 +114,26 @@ public MockResponse setHeader(String name, Object value) {
     return addHeader(name, value);
   }
 
+  /** Replaces all headers with those specified in {@code headers}. */
+  public MockResponse setHeaders(Headers headers) {
+    this.headers = headers.newBuilder();
+    return this;
+  }
+
   /** Removes all headers named {@code name}. */
   public MockResponse removeHeader(String name) {
-    name += ":";
-    for (Iterator<String> i = headers.iterator(); i.hasNext(); ) {
-      String header = i.next();
-      if (name.regionMatches(true, 0, header, 0, name.length())) {
-        i.remove();
-      }
-    }
+    headers.removeAll(name);
     return this;
   }
 
-  /** Returns the raw HTTP payload, or null if this response is streamed. */
+  /** Returns a copy of the raw HTTP payload. */
   public Buffer getBody() {
-    return body != null ? body.clone() : null; // Defensive copy.
-  }
-
-  /** Returns an input stream containing the raw HTTP payload. */
-  InputStream getBodyStream() {
-    return bodyStream != null ? bodyStream : getBody().inputStream();
-  }
-
-  public MockResponse setBody(byte[] body) {
-    return setBody(new Buffer().write(body));
+    return body != null ? body.clone() : null;
   }
 
   public MockResponse setBody(Buffer body) {
     setHeader("Content-Length", body.size());
     this.body = body.clone(); // Defensive copy.
-    this.bodyStream = null;
-    return this;
-  }
-
-  public MockResponse setBody(InputStream bodyStream, long bodyLength) {
-    setHeader("Content-Length", bodyLength);
-    this.body = null;
-    this.bodyStream = bodyStream;
     return this;
   }
 
@@ -204,36 +186,33 @@ public MockResponse setSocketPolicy(SocketPolicy socketPolicy) {
    * series of {@code bytesPerPeriod} bytes are written. Use this to simulate
    * network behavior.
    */
-  public MockResponse throttleBody(int bytesPerPeriod, long period, TimeUnit unit) {
+  public MockResponse throttleBody(long bytesPerPeriod, long period, TimeUnit unit) {
     this.throttleBytesPerPeriod = bytesPerPeriod;
-    this.throttlePeriod = period;
-    this.throttleUnit = unit;
+    this.throttlePeriodAmount = period;
+    this.throttlePeriodUnit = unit;
     return this;
   }
 
-  public int getThrottleBytesPerPeriod() {
+  public long getThrottleBytesPerPeriod() {
     return throttleBytesPerPeriod;
   }
 
-  public long getThrottlePeriod() {
-    return throttlePeriod;
-  }
-
-  public TimeUnit getThrottleUnit() {
-    return throttleUnit;
+  public long getThrottlePeriod(TimeUnit unit) {
+    return unit.convert(throttlePeriodAmount, throttlePeriodUnit);
   }
 
   /**
    * Set the delayed time of the response body to {@code delay}. This applies to the
    * response body only; response headers are not affected.
    */
-  public MockResponse setBodyDelayTimeMs(int delay) {
-    bodyDelayTimeMs = delay;
+  public MockResponse setBodyDelay(long delay, TimeUnit unit) {
+    bodyDelayAmount = delay;
+    bodyDelayUnit = unit;
     return this;
   }
 
-  public int getBodyDelayTimeMs() {
-    return bodyDelayTimeMs;
+  public long getBodyDelay(TimeUnit unit) {
+    return unit.convert(bodyDelayAmount, bodyDelayUnit);
   }
 
   /**
@@ -251,6 +230,23 @@ public MockResponse withPush(PushPromise promise) {
     return promises;
   }
 
+  /**
+   * Attempts to perform a web socket upgrade on the connection. This will overwrite any previously
+   * set status or body.
+   */
+  public MockResponse withWebSocketUpgrade(WebSocketListener listener) {
+    setStatus("HTTP/1.1 101 Switching Protocols");
+    setHeader("Connection", "Upgrade");
+    setHeader("Upgrade", "websocket");
+    body = null;
+    webSocketListener = listener;
+    return this;
+  }
+
+  public WebSocketListener getWebSocketListener() {
+    return webSocketListener;
+  }
+
   @Override public String toString() {
     return status;
   }
diff --git a/mockwebserver/src/main/java/com/squareup/okhttp/mockwebserver/MockWebServer.java b/mockwebserver/src/main/java/com/squareup/okhttp/mockwebserver/MockWebServer.java
index 7e07204760..39fbf6fd84 100644
--- a/mockwebserver/src/main/java/com/squareup/okhttp/mockwebserver/MockWebServer.java
+++ b/mockwebserver/src/main/java/com/squareup/okhttp/mockwebserver/MockWebServer.java
@@ -17,7 +17,10 @@
 
 package com.squareup.okhttp.mockwebserver;
 
+import com.squareup.okhttp.Headers;
 import com.squareup.okhttp.Protocol;
+import com.squareup.okhttp.Request;
+import com.squareup.okhttp.Response;
 import com.squareup.okhttp.internal.NamedRunnable;
 import com.squareup.okhttp.internal.Platform;
 import com.squareup.okhttp.internal.Util;
@@ -26,12 +29,10 @@
 import com.squareup.okhttp.internal.spdy.IncomingStreamHandler;
 import com.squareup.okhttp.internal.spdy.SpdyConnection;
 import com.squareup.okhttp.internal.spdy.SpdyStream;
-import java.io.BufferedInputStream;
-import java.io.BufferedOutputStream;
-import java.io.ByteArrayOutputStream;
+import com.squareup.okhttp.internal.ws.RealWebSocket;
+import com.squareup.okhttp.internal.ws.WebSocketListener;
+import com.squareup.okhttp.internal.ws.WebSocketProtocol;
 import java.io.IOException;
-import java.io.InputStream;
-import java.io.OutputStream;
 import java.net.InetAddress;
 import java.net.InetSocketAddress;
 import java.net.MalformedURLException;
@@ -52,6 +53,7 @@
 import java.util.Set;
 import java.util.concurrent.BlockingQueue;
 import java.util.concurrent.ConcurrentHashMap;
+import java.util.concurrent.CountDownLatch;
 import java.util.concurrent.ExecutorService;
 import java.util.concurrent.Executors;
 import java.util.concurrent.LinkedBlockingQueue;
@@ -70,6 +72,8 @@
 import okio.BufferedSource;
 import okio.ByteString;
 import okio.Okio;
+import okio.Sink;
+import okio.Timeout;
 
 import static com.squareup.okhttp.mockwebserver.SocketPolicy.DISCONNECT_AT_START;
 import static com.squareup.okhttp.mockwebserver.SocketPolicy.FAIL_HANDSHAKE;
@@ -103,7 +107,7 @@
   private final Set<SpdyConnection> openSpdyConnections =
       Collections.newSetFromMap(new ConcurrentHashMap<SpdyConnection, Boolean>());
   private final AtomicInteger requestCount = new AtomicInteger();
-  private int bodyLimit = Integer.MAX_VALUE;
+  private long bodyLimit = Long.MAX_VALUE;
   private ServerSocketFactory serverSocketFactory = ServerSocketFactory.getDefault();
   private ServerSocket serverSocket;
   private SSLSocketFactory sslSocketFactory;
@@ -112,7 +116,7 @@
   private Dispatcher dispatcher = new QueueDispatcher();
 
   private int port = -1;
-  private InetAddress inetAddress;
+  private InetSocketAddress inetSocketAddress;
   private boolean protocolNegotiationEnabled = true;
   private List<Protocol> protocols
       = Util.immutableList(Protocol.HTTP_2, Protocol.SPDY_3, Protocol.HTTP_1_1);
@@ -123,18 +127,23 @@ public void setServerSocketFactory(ServerSocketFactory serverSocketFactory) {
   }
 
   public int getPort() {
-    if (port == -1) throw new IllegalStateException("Call play() before getPort()");
+    if (port == -1) throw new IllegalStateException("Call start() before getPort()");
     return port;
   }
 
   public String getHostName() {
-    if (inetAddress == null) throw new IllegalStateException("Call play() before getHostName()");
-    return inetAddress.getHostName();
+    if (inetSocketAddress == null) {
+      throw new IllegalStateException("Call start() before getHostName()");
+    }
+    return inetSocketAddress.getHostName();
   }
 
   public Proxy toProxyAddress() {
-    if (inetAddress == null) throw new IllegalStateException("Call play() before toProxyAddress()");
-    return new Proxy(Proxy.Type.HTTP, new InetSocketAddress(inetAddress, getPort()));
+    if (inetSocketAddress == null) {
+      throw new IllegalStateException("Call start() before toProxyAddress()");
+    }
+    InetSocketAddress address = new InetSocketAddress(inetSocketAddress.getAddress(), getPort());
+    return new Proxy(Proxy.Type.HTTP, address);
   }
 
   /**
@@ -165,7 +174,7 @@ public String getCookieDomain() {
    * Sets the number of bytes of the POST body to keep in memory to the given
    * limit.
    */
-  public void setBodyLimit(int maxBodyLength) {
+  public void setBodyLimit(long maxBodyLength) {
     this.bodyLimit = maxBodyLength;
   }
 
@@ -229,7 +238,7 @@ public RecordedRequest takeRequest() throws InterruptedException {
    *        {@code timeout} parameter
    * @return the head of the request queue
    */
-  public RecordedRequest takeRequest(int timeout, TimeUnit unit) throws InterruptedException {
+  public RecordedRequest takeRequest(long timeout, TimeUnit unit) throws InterruptedException {
     return requestQueue.poll(timeout, unit);
   }
 
@@ -254,28 +263,61 @@ public void enqueue(MockResponse response) {
     ((QueueDispatcher) dispatcher).enqueueResponse(response.clone());
   }
 
-  /** Equivalent to {@code play(0)}. */
+  /** @deprecated Use {@link #start()}. */
   public void play() throws IOException {
-    play(0);
+    start();
+  }
+
+  /** @deprecated Use {@link #start(int)}. */
+  public void play(int port) throws IOException {
+    start(port);
+  }
+
+  /** Equivalent to {@code start(0)}. */
+  public void start() throws IOException {
+    start(0);
   }
 
   /**
-   * Starts the server, serves all enqueued requests, and shuts the server down.
+   * Starts the server on the loopback interface for the given port.
    *
    * @param port the port to listen to, or 0 for any available port. Automated
    *     tests should always use port 0 to avoid flakiness when a specific port
    *     is unavailable.
    */
-  public void play(int port) throws IOException {
-    if (executor != null) throw new IllegalStateException("play() already called");
+  public void start(int port) throws IOException {
+    start(InetAddress.getByName("localhost"), port);
+  }
+
+  /**
+   * Starts the server on the given address and port.
+   *
+   * @param inetAddress the address to create the server socket on
+   *
+   * @param port the port to listen to, or 0 for any available port. Automated
+   *     tests should always use port 0 to avoid flakiness when a specific port
+   *     is unavailable.
+   */
+  public void start(InetAddress inetAddress, int port) throws IOException {
+    start(new InetSocketAddress(inetAddress, port));
+  }
+
+  /**
+   * Starts the server and binds to the given socket address.
+   *
+   * @param inetSocketAddress the socket address to bind the server on
+   */
+  private void start(InetSocketAddress inetSocketAddress) throws IOException {
+    if (executor != null) throw new IllegalStateException("start() already called");
     executor = Executors.newCachedThreadPool(Util.threadFactory("MockWebServer", false));
-    inetAddress = InetAddress.getByName(null);
+    this.inetSocketAddress = inetSocketAddress;
     serverSocket = serverSocketFactory.createServerSocket();
-    serverSocket.setReuseAddress(port != 0); // Reuse the port if the port number was specified.
-    serverSocket.bind(new InetSocketAddress(inetAddress, port), 50);
+    // Reuse if the user specified a port
+    serverSocket.setReuseAddress(inetSocketAddress.getPort() != 0);
+    serverSocket.bind(inetSocketAddress, 50);
 
-    this.port = serverSocket.getLocalPort();
-    executor.execute(new NamedRunnable("MockWebServer %s", this.port) {
+    port = serverSocket.getLocalPort();
+    executor.execute(new NamedRunnable("MockWebServer %s", port) {
       @Override protected void execute() {
         try {
           logger.info(MockWebServer.this + " starting to accept connections");
@@ -341,11 +383,11 @@ private void serveConnection(final Socket raw) {
         try {
           processConnection();
         } catch (IOException e) {
-          logger.info(MockWebServer.this + " connection from "
-              + raw.getInetAddress() + " failed: " + e);
+          logger.info(
+              MockWebServer.this + " connection from " + raw.getInetAddress() + " failed: " + e);
         } catch (Exception e) {
-          logger.log(Level.SEVERE, MockWebServer.this + " connection from "
-              + raw.getInetAddress() + " crashed", e);
+          logger.log(Level.SEVERE,
+              MockWebServer.this + " connection from " + raw.getInetAddress() + " crashed", e);
         }
       }
 
@@ -362,8 +404,8 @@ public void processConnection() throws Exception {
             processHandshakeFailure(raw);
             return;
           }
-          socket = sslSocketFactory.createSocket(
-              raw, raw.getInetAddress().getHostAddress(), raw.getPort(), true);
+          socket = sslSocketFactory.createSocket(raw, raw.getInetAddress().getHostAddress(),
+              raw.getPort(), true);
           SSLSocket sslSocket = (SSLSocket) socket;
           sslSocket.setUseClientMode(false);
           openClientSockets.add(socket);
@@ -376,9 +418,7 @@ public void processConnection() throws Exception {
 
           if (protocolNegotiationEnabled) {
             String protocolString = Platform.get().getSelectedProtocol(sslSocket);
-            protocol = protocolString != null
-                ? Protocol.get(protocolString)
-                : Protocol.HTTP_1_1;
+            protocol = protocolString != null ? Protocol.get(protocolString) : Protocol.HTTP_1_1;
           }
           openClientSockets.remove(raw);
         } else {
@@ -387,27 +427,30 @@ public void processConnection() throws Exception {
 
         if (protocol != Protocol.HTTP_1_1) {
           SpdySocketHandler spdySocketHandler = new SpdySocketHandler(socket, protocol);
-          SpdyConnection spdyConnection = new SpdyConnection.Builder(false, socket)
-              .protocol(protocol)
-              .handler(spdySocketHandler).build();
+          SpdyConnection spdyConnection =
+              new SpdyConnection.Builder(false, socket).protocol(protocol)
+                  .handler(spdySocketHandler)
+                  .build();
           openSpdyConnections.add(spdyConnection);
           openClientSockets.remove(socket);
           return;
         }
 
-        InputStream in = new BufferedInputStream(socket.getInputStream());
-        OutputStream out = new BufferedOutputStream(socket.getOutputStream());
+        BufferedSource source = Okio.buffer(Okio.source(socket));
+        BufferedSink sink = Okio.buffer(Okio.sink(socket));
 
-        while (processOneRequest(socket, in, out)) {
+        while (processOneRequest(socket, source, sink)) {
         }
 
         if (sequenceNumber == 0) {
-          logger.warning(MockWebServer.this + " connection from " + raw.getInetAddress()
+          logger.warning(MockWebServer.this
+              + " connection from "
+              + raw.getInetAddress()
               + " didn't make a request");
         }
 
-        in.close();
-        out.close();
+        source.close();
+        sink.close();
         socket.close();
         openClientSockets.remove(socket);
       }
@@ -417,9 +460,11 @@ public void processConnection() throws Exception {
        * dispatched.
        */
       private void createTunnel() throws IOException, InterruptedException {
+        BufferedSource source = Okio.buffer(Okio.source(raw));
+        BufferedSink sink = Okio.buffer(Okio.sink(raw));
         while (true) {
           SocketPolicy socketPolicy = dispatcher.peek().getSocketPolicy();
-          if (!processOneRequest(raw, raw.getInputStream(), raw.getOutputStream())) {
+          if (!processOneRequest(raw, source, sink)) {
             throw new IllegalStateException("Tunnel without any CONNECT!");
           }
           if (socketPolicy == SocketPolicy.UPGRADE_TO_SSL_AT_END) return;
@@ -430,12 +475,14 @@ private void createTunnel() throws IOException, InterruptedException {
        * Reads a request and writes its response. Returns true if a request was
        * processed.
        */
-      private boolean processOneRequest(Socket socket, InputStream in, OutputStream out)
+      private boolean processOneRequest(Socket socket, BufferedSource source, BufferedSink sink)
           throws IOException, InterruptedException {
-        RecordedRequest request = readRequest(socket, in, out, sequenceNumber);
+        RecordedRequest request = readRequest(socket, source, sink, sequenceNumber);
         if (request == null) return false;
+
         requestCount.incrementAndGet();
         requestQueue.add(request);
+
         MockResponse response = dispatcher.dispatch(request);
         if (response.getSocketPolicy() == SocketPolicy.DISCONNECT_AFTER_REQUEST) {
           socket.close();
@@ -443,22 +490,35 @@ private boolean processOneRequest(Socket socket, InputStream in, OutputStream ou
         }
         if (response.getSocketPolicy() == SocketPolicy.NO_RESPONSE) {
           // This read should block until the socket is closed. (Because nobody is writing.)
-          if (in.read() == -1) return false;
+          if (source.exhausted()) return false;
           throw new ProtocolException("unexpected data");
         }
-        writeResponse(socket, out, response);
+
+        boolean requestWantsWebSockets = "Upgrade".equalsIgnoreCase(request.getHeader("Connection"))
+            && "websocket".equalsIgnoreCase(request.getHeader("Upgrade"));
+        boolean responseWantsWebSockets = response.getWebSocketListener() != null;
+        if (requestWantsWebSockets && responseWantsWebSockets) {
+          handleWebSocketUpgrade(socket, source, sink, request, response);
+        } else {
+          writeHttpResponse(socket, sink, response);
+        }
+
         if (response.getSocketPolicy() == SocketPolicy.DISCONNECT_AT_END) {
-          in.close();
-          out.close();
+          source.close();
+          sink.close();
+          // Workaround for bug on Android: closing the input/output streams should close an
+          // SSLSocket but does not. https://code.google.com/p/android/issues/detail?id=97564
+          socket.close();
         } else if (response.getSocketPolicy() == SocketPolicy.SHUTDOWN_INPUT_AT_END) {
           socket.shutdownInput();
         } else if (response.getSocketPolicy() == SocketPolicy.SHUTDOWN_OUTPUT_AT_END) {
           socket.shutdownOutput();
         }
         if (logger.isLoggable(Level.INFO)) {
-          logger.info(MockWebServer.this + " received request: " + request
-              + " and responded: " + response);
+          logger.info(
+              MockWebServer.this + " received request: " + request + " and responded: " + response);
         }
+
         sequenceNumber++;
         return true;
       }
@@ -486,11 +546,11 @@ private void dispatchBookkeepingRequest(int sequenceNumber, Socket socket)
   }
 
   /** @param sequenceNumber the index of this request on this connection. */
-  private RecordedRequest readRequest(Socket socket, InputStream in, OutputStream out,
+  private RecordedRequest readRequest(Socket socket, BufferedSource source, BufferedSink sink,
       int sequenceNumber) throws IOException {
     String request;
     try {
-      request = readAsciiUntilCrlf(in);
+      request = source.readUtf8LineStrict();
     } catch (IOException streamIsClosed) {
       return null; // no request because we closed the stream
     }
@@ -498,12 +558,12 @@ private RecordedRequest readRequest(Socket socket, InputStream in, OutputStream
       return null; // no request because the stream is exhausted
     }
 
-    List<String> headers = new ArrayList<>();
+    Headers.Builder headers = new Headers.Builder();
     long contentLength = -1;
     boolean chunked = false;
     boolean expectContinue = false;
     String header;
-    while ((header = readAsciiUntilCrlf(in)).length() != 0) {
+    while ((header = source.readUtf8LineStrict()).length() != 0) {
       headers.add(header);
       String lowercaseHeader = header.toLowerCase(Locale.US);
       if (contentLength == -1 && lowercaseHeader.startsWith("content-length:")) {
@@ -520,30 +580,30 @@ private RecordedRequest readRequest(Socket socket, InputStream in, OutputStream
     }
 
     if (expectContinue) {
-      out.write(("HTTP/1.1 100 Continue\r\n").getBytes(Util.US_ASCII));
-      out.write(("Content-Length: 0\r\n").getBytes(Util.US_ASCII));
-      out.write(("\r\n").getBytes(Util.US_ASCII));
-      out.flush();
+      sink.writeUtf8("HTTP/1.1 100 Continue\r\n");
+      sink.writeUtf8("Content-Length: 0\r\n");
+      sink.writeUtf8("\r\n");
+      sink.flush();
     }
 
     boolean hasBody = false;
-    TruncatingOutputStream requestBody = new TruncatingOutputStream();
+    TruncatingBuffer requestBody = new TruncatingBuffer(bodyLimit);
     List<Integer> chunkSizes = new ArrayList<>();
     MockResponse throttlePolicy = dispatcher.peek();
     if (contentLength != -1) {
       hasBody = contentLength > 0;
-      throttledTransfer(throttlePolicy, socket, in, requestBody, contentLength);
+      throttledTransfer(throttlePolicy, socket, source, Okio.buffer(requestBody), contentLength);
     } else if (chunked) {
       hasBody = true;
       while (true) {
-        int chunkSize = Integer.parseInt(readAsciiUntilCrlf(in).trim(), 16);
+        int chunkSize = Integer.parseInt(source.readUtf8LineStrict().trim(), 16);
         if (chunkSize == 0) {
-          readEmptyLine(in);
+          readEmptyLine(source);
           break;
         }
         chunkSizes.add(chunkSize);
-        throttledTransfer(throttlePolicy, socket, in, requestBody, chunkSize);
-        readEmptyLine(in);
+        throttledTransfer(throttlePolicy, socket, source, Okio.buffer(requestBody), chunkSize);
+        readEmptyLine(source);
       }
     }
 
@@ -562,31 +622,94 @@ private RecordedRequest readRequest(Socket socket, InputStream in, OutputStream
       throw new UnsupportedOperationException("Unexpected method: " + request);
     }
 
-    return new RecordedRequest(request, headers, chunkSizes, requestBody.numBytesReceived,
-        requestBody.toByteArray(), sequenceNumber, socket);
+    return new RecordedRequest(request, headers.build(), chunkSizes, requestBody.receivedByteCount,
+        requestBody.buffer, sequenceNumber, socket);
   }
 
-  private void writeResponse(Socket socket, OutputStream out, MockResponse response)
+  private void handleWebSocketUpgrade(Socket socket, BufferedSource source, BufferedSink sink,
+      RecordedRequest request, MockResponse response) throws IOException {
+    String key = request.getHeader("Sec-WebSocket-Key");
+    String acceptKey = Util.shaBase64(key + WebSocketProtocol.ACCEPT_MAGIC);
+    response.setHeader("Sec-WebSocket-Accept", acceptKey);
+
+    writeHttpResponse(socket, sink, response);
+
+    final WebSocketListener listener = response.getWebSocketListener();
+    final CountDownLatch connectionClose = new CountDownLatch(1);
+    final RealWebSocket webSocket =
+        new RealWebSocket(false, source, sink, new SecureRandom(), listener,
+            request.getPath()) {
+          @Override protected void closeConnection() throws IOException {
+            connectionClose.countDown();
+          }
+        };
+
+    // Adapt the request and response into our Request and Response domain model.
+    final Request fancyRequest = new Request.Builder()
+        .get().url(request.getPath())
+        .headers(request.getHeaders())
+        .build();
+    final Response fancyResponse = new Response.Builder()
+        .code(Integer.parseInt(response.getStatus().split(" ")[1]))
+        .message(response.getStatus().split(" ", 3)[2])
+        .headers(response.getHeaders())
+        .request(fancyRequest)
+        .protocol(Protocol.HTTP_1_1)
+        .build();
+
+    // The callback might act synchronously. Give it its own thread.
+    new Thread(new Runnable() {
+      @Override public void run() {
+        try {
+          listener.onOpen(webSocket, fancyRequest, fancyResponse);
+        } catch (IOException e) {
+          // TODO try to write close frame?
+          connectionClose.countDown();
+        }
+      }
+    }, "MockWebServer WebSocket Writer " + request.getPath()).start();
+
+    // Use this thread to continuously read messages.
+    while (webSocket.readMessage()) {
+    }
+
+    // Even if messages are no longer being read we need to wait for the connection close signal.
+    try {
+      connectionClose.await();
+    } catch (InterruptedException e) {
+      throw new RuntimeException(e);
+    }
+
+    Util.closeQuietly(sink);
+    Util.closeQuietly(source);
+  }
+
+  private void writeHttpResponse(Socket socket, BufferedSink sink, MockResponse response)
       throws IOException {
-    out.write((response.getStatus() + "\r\n").getBytes(Util.US_ASCII));
-    List<String> headers = response.getHeaders();
+    sink.writeUtf8(response.getStatus());
+    sink.writeUtf8("\r\n");
+
+    Headers headers = response.getHeaders();
     for (int i = 0, size = headers.size(); i < size; i++) {
-      String header = headers.get(i);
-      out.write((header + "\r\n").getBytes(Util.US_ASCII));
+      sink.writeUtf8(headers.name(i));
+      sink.writeUtf8(": ");
+      sink.writeUtf8(headers.value(i));
+      sink.writeUtf8("\r\n");
     }
-    out.write(("\r\n").getBytes(Util.US_ASCII));
-    out.flush();
+    sink.writeUtf8("\r\n");
+    sink.flush();
 
-    InputStream in = response.getBodyStream();
-    if (in == null) return;
+    Buffer body = response.getBody();
+    if (body == null) return;
     sleepIfDelayed(response);
-    throttledTransfer(response, socket, in, out, Long.MAX_VALUE);
+    throttledTransfer(response, socket, body, sink, Long.MAX_VALUE);
   }
 
   private void sleepIfDelayed(MockResponse response) {
-    if (response.getBodyDelayTimeMs() != 0) {
+    long delayMs = response.getBodyDelay(TimeUnit.MILLISECONDS);
+    if (delayMs != 0) {
       try {
-        Thread.sleep(response.getBodyDelayTimeMs());
+        Thread.sleep(delayMs);
       } catch (InterruptedException e) {
         throw new AssertionError(e);
       }
@@ -594,59 +717,44 @@ private void sleepIfDelayed(MockResponse response) {
   }
 
   /**
-   * Transfer bytes from {@code in} to {@code out} until either {@code length}
-   * bytes have been transferred or {@code in} is exhausted. The transfer is
+   * Transfer bytes from {@code source} to {@code sink} until either {@code byteCount}
+   * bytes have been transferred or {@code source} is exhausted. The transfer is
    * throttled according to {@code throttlePolicy}.
    */
-  private void throttledTransfer(MockResponse throttlePolicy, Socket socket, InputStream in,
-      OutputStream out, long limit) throws IOException {
-    byte[] buffer = new byte[1024];
-    int bytesPerPeriod = throttlePolicy.getThrottleBytesPerPeriod();
-    long delayMs = throttlePolicy.getThrottleUnit().toMillis(throttlePolicy.getThrottlePeriod());
+  private void throttledTransfer(MockResponse throttlePolicy, Socket socket, BufferedSource source,
+      BufferedSink sink, long byteCount) throws IOException {
+    if (byteCount == 0) return;
+
+    Buffer buffer = new Buffer();
+    long bytesPerPeriod = throttlePolicy.getThrottleBytesPerPeriod();
+    long periodDelayMs = throttlePolicy.getThrottlePeriod(TimeUnit.MILLISECONDS);
 
     while (!socket.isClosed()) {
       for (int b = 0; b < bytesPerPeriod; ) {
-        int toRead = (int) Math.min(Math.min(buffer.length, limit), bytesPerPeriod - b);
-        int read = in.read(buffer, 0, toRead);
+        long toRead = Math.min(Math.min(2048, byteCount), bytesPerPeriod - b);
+        long read = source.read(buffer, toRead);
         if (read == -1) return;
 
-        out.write(buffer, 0, read);
-        out.flush();
+        sink.write(buffer, read);
+        sink.flush();
         b += read;
-        limit -= read;
+        byteCount -= read;
 
-        if (limit == 0) return;
+        if (byteCount == 0) return;
       }
 
-      try {
-        if (delayMs != 0) Thread.sleep(delayMs);
-      } catch (InterruptedException e) {
-        throw new AssertionError();
-      }
-    }
-  }
-
-  /**
-   * Returns the text from {@code in} until the next "\r\n", or null if {@code
-   * in} is exhausted.
-   */
-  private String readAsciiUntilCrlf(InputStream in) throws IOException {
-    StringBuilder builder = new StringBuilder();
-    while (true) {
-      int c = in.read();
-      if (c == '\n' && builder.length() > 0 && builder.charAt(builder.length() - 1) == '\r') {
-        builder.deleteCharAt(builder.length() - 1);
-        return builder.toString();
-      } else if (c == -1) {
-        return builder.toString();
-      } else {
-        builder.append((char) c);
+      if (periodDelayMs != 0) {
+        try {
+          Thread.sleep(periodDelayMs);
+        } catch (InterruptedException e) {
+          throw new AssertionError();
+        }
       }
     }
   }
 
-  private void readEmptyLine(InputStream in) throws IOException {
-    String line = readAsciiUntilCrlf(in);
+  private void readEmptyLine(BufferedSource source) throws IOException {
+    String line = source.readUtf8LineStrict();
     if (line.length() != 0) throw new IllegalStateException("Expected empty but was: " + line);
   }
 
@@ -665,20 +773,37 @@ public void setDispatcher(Dispatcher dispatcher) {
     return "MockWebServer[" + port + "]";
   }
 
-  /** An output stream that drops data after bodyLimit bytes. */
-  private class TruncatingOutputStream extends ByteArrayOutputStream {
-    private long numBytesReceived = 0;
+  /** A buffer wrapper that drops data after {@code bodyLimit} bytes. */
+  private static class TruncatingBuffer implements Sink {
+    private final Buffer buffer = new Buffer();
+    private long remainingByteCount;
+    private long receivedByteCount;
 
-    @Override public void write(byte[] buffer, int offset, int len) {
-      numBytesReceived += len;
-      super.write(buffer, offset, Math.min(len, bodyLimit - count));
+    TruncatingBuffer(long bodyLimit) {
+      remainingByteCount = bodyLimit;
     }
 
-    @Override public void write(int oneByte) {
-      numBytesReceived++;
-      if (count < bodyLimit) {
-        super.write(oneByte);
+    @Override public void write(Buffer source, long byteCount) throws IOException {
+      long toRead = Math.min(remainingByteCount, byteCount);
+      if (toRead > 0) {
+        source.read(buffer, toRead);
+      }
+      long toSkip = byteCount - toRead;
+      if (toSkip > 0) {
+        source.skip(toSkip);
       }
+      remainingByteCount -= toRead;
+      receivedByteCount += byteCount;
+    }
+
+    @Override public void flush() throws IOException {
+    }
+
+    @Override public Timeout timeout() {
+      return Timeout.NONE;
+    }
+
+    @Override public void close() throws IOException {
     }
   }
 
@@ -711,7 +836,7 @@ private SpdySocketHandler(Socket socket, Protocol protocol) {
 
     private RecordedRequest readRequest(SpdyStream stream) throws IOException {
       List<Header> spdyHeaders = stream.getRequestHeaders();
-      List<String> httpHeaders = new ArrayList<>();
+      Headers.Builder httpHeaders = new Headers.Builder();
       String method = "<:method omitted>";
       String path = "<:path omitted>";
       String version = protocol == Protocol.SPDY_3 ? "<:version omitted>" : "HTTP/1.1";
@@ -725,18 +850,18 @@ private RecordedRequest readRequest(SpdyStream stream) throws IOException {
         } else if (name.equals(Header.VERSION)) {
           version = value;
         } else {
-          httpHeaders.add(name.utf8() + ": " + value);
+          httpHeaders.add(name.utf8(), value);
         }
       }
 
-      BufferedSource bodyIn = Okio.buffer(stream.getSource());
-      byte[] bodyOut = bodyIn.readByteArray();
-      bodyIn.close();
+      Buffer body = new Buffer();
+      body.writeAll(stream.getSource());
+      body.close();
 
       String requestLine = method + ' ' + path + ' ' + version;
       List<Integer> chunkSizes = Collections.emptyList(); // No chunked encoding for SPDY.
-      return new RecordedRequest(requestLine, httpHeaders, chunkSizes, bodyOut.length,
-          bodyOut, sequenceNumber.getAndIncrement(), socket);
+      return new RecordedRequest(requestLine, httpHeaders.build(), chunkSizes, body.size(), body,
+          sequenceNumber.getAndIncrement(), socket);
     }
 
     private void writeResponse(SpdyStream stream, MockResponse response) throws IOException {
@@ -753,45 +878,19 @@ private void writeResponse(SpdyStream stream, MockResponse response) throws IOEx
       if (protocol == Protocol.SPDY_3) {
         spdyHeaders.add(new Header(Header.VERSION, statusParts[0]));
       }
-      List<String> headers = response.getHeaders();
+      Headers headers = response.getHeaders();
       for (int i = 0, size = headers.size(); i < size; i++) {
-        String header = headers.get(i);
-        String[] headerParts = header.split(":", 2);
-        if (headerParts.length != 2) {
-          throw new AssertionError("Unexpected header: " + header);
-        }
-        spdyHeaders.add(new Header(headerParts[0], headerParts[1]));
+        spdyHeaders.add(new Header(headers.name(i), headers.value(i)));
       }
+
       Buffer body = response.getBody();
-      if (body == null) body = new Buffer();
-      boolean closeStreamAfterHeaders = body.size() > 0 || !response.getPushPromises().isEmpty();
+      boolean closeStreamAfterHeaders = body != null || !response.getPushPromises().isEmpty();
       stream.reply(spdyHeaders, closeStreamAfterHeaders);
       pushPromises(stream, response.getPushPromises());
-      if (body.size() > 0) {
-        if (response.getBodyDelayTimeMs() != 0) {
-          try {
-            Thread.sleep(response.getBodyDelayTimeMs());
-          } catch (InterruptedException e) {
-            throw new AssertionError(e);
-          }
-        }
+      if (body != null) {
         BufferedSink sink = Okio.buffer(stream.getSink());
-        if (response.getThrottleBytesPerPeriod() == Integer.MAX_VALUE) {
-          sink.writeAll(body);
-          sink.flush();
-        } else {
-          while (body.size() > 0) {
-            long toWrite = Math.min(body.size(), response.getThrottleBytesPerPeriod());
-            sink.write(body, toWrite);
-            sink.flush();
-            try {
-              long delayMs = response.getThrottleUnit().toMillis(response.getThrottlePeriod());
-              if (delayMs != 0) Thread.sleep(delayMs);
-            } catch (InterruptedException e) {
-              throw new AssertionError();
-            }
-          }
-        }
+        sleepIfDelayed(response);
+        throttledTransfer(response, socket, body, sink, bodyLimit);
         sink.close();
       } else if (closeStreamAfterHeaders) {
         stream.close(ErrorCode.NO_ERROR);
@@ -806,21 +905,17 @@ private void pushPromises(SpdyStream stream, List<PushPromise> promises) throws
             : Header.TARGET_AUTHORITY, getUrl(pushPromise.getPath()).getHost()));
         pushedHeaders.add(new Header(Header.TARGET_METHOD, pushPromise.getMethod()));
         pushedHeaders.add(new Header(Header.TARGET_PATH, pushPromise.getPath()));
-        for (int i = 0, size = pushPromise.getHeaders().size(); i < size; i++) {
-          String header = pushPromise.getHeaders().get(i);
-          String[] headerParts = header.split(":", 2);
-          if (headerParts.length != 2) {
-            throw new AssertionError("Unexpected header: " + header);
-          }
-          pushedHeaders.add(new Header(headerParts[0], headerParts[1].trim()));
+        Headers pushPromiseHeaders = pushPromise.getHeaders();
+        for (int i = 0, size = pushPromiseHeaders.size(); i < size; i++) {
+          pushedHeaders.add(new Header(pushPromiseHeaders.name(i), pushPromiseHeaders.value(i)));
         }
         String requestLine = pushPromise.getMethod() + ' ' + pushPromise.getPath() + " HTTP/1.1";
         List<Integer> chunkSizes = Collections.emptyList(); // No chunked encoding for SPDY.
         requestQueue.add(new RecordedRequest(requestLine, pushPromise.getHeaders(), chunkSizes, 0,
-            Util.EMPTY_BYTE_ARRAY, sequenceNumber.getAndIncrement(), socket));
-        Buffer pushedBody = pushPromise.getResponse().getBody();
+            new Buffer(), sequenceNumber.getAndIncrement(), socket));
+        boolean hasBody = pushPromise.getResponse().getBody() != null;
         SpdyStream pushedStream =
-            stream.getConnection().pushStream(stream.getId(), pushedHeaders, pushedBody.size() > 0);
+            stream.getConnection().pushStream(stream.getId(), pushedHeaders, hasBody);
         writeResponse(pushedStream, pushPromise.getResponse());
       }
     }
diff --git a/mockwebserver/src/main/java/com/squareup/okhttp/mockwebserver/PushPromise.java b/mockwebserver/src/main/java/com/squareup/okhttp/mockwebserver/PushPromise.java
index d9dd01978b..649b4ee73a 100644
--- a/mockwebserver/src/main/java/com/squareup/okhttp/mockwebserver/PushPromise.java
+++ b/mockwebserver/src/main/java/com/squareup/okhttp/mockwebserver/PushPromise.java
@@ -15,16 +15,16 @@
  */
 package com.squareup.okhttp.mockwebserver;
 
-import java.util.List;
+import com.squareup.okhttp.Headers;
 
 /** An HTTP request initiated by the server. */
 public final class PushPromise {
   private final String method;
   private final String path;
-  private final List<String> headers;
+  private final Headers headers;
   private final MockResponse response;
 
-  public PushPromise(String method, String path, List<String> headers, MockResponse response) {
+  public PushPromise(String method, String path, Headers headers, MockResponse response) {
     this.method = method;
     this.path = path;
     this.headers = headers;
@@ -39,7 +39,7 @@ public String getPath() {
     return path;
   }
 
-  public List<String> getHeaders() {
+  public Headers getHeaders() {
     return headers;
   }
 
diff --git a/mockwebserver/src/main/java/com/squareup/okhttp/mockwebserver/RecordedRequest.java b/mockwebserver/src/main/java/com/squareup/okhttp/mockwebserver/RecordedRequest.java
index a62c62d2b0..99d4d273b2 100644
--- a/mockwebserver/src/main/java/com/squareup/okhttp/mockwebserver/RecordedRequest.java
+++ b/mockwebserver/src/main/java/com/squareup/okhttp/mockwebserver/RecordedRequest.java
@@ -16,28 +16,27 @@
 
 package com.squareup.okhttp.mockwebserver;
 
+import com.squareup.okhttp.Headers;
 import com.squareup.okhttp.TlsVersion;
-import com.squareup.okhttp.internal.Internal;
-import java.io.UnsupportedEncodingException;
 import java.net.Socket;
-import java.util.ArrayList;
 import java.util.List;
 import javax.net.ssl.SSLSocket;
+import okio.Buffer;
 
 /** An HTTP request that came into the mock web server. */
 public final class RecordedRequest {
   private final String requestLine;
   private final String method;
   private final String path;
-  private final List<String> headers;
+  private final Headers headers;
   private final List<Integer> chunkSizes;
   private final long bodySize;
-  private final byte[] body;
+  private final Buffer body;
   private final int sequenceNumber;
   private final TlsVersion tlsVersion;
 
-  public RecordedRequest(String requestLine, List<String> headers, List<Integer> chunkSizes,
-      long bodySize, byte[] body, int sequenceNumber, Socket socket) {
+  public RecordedRequest(String requestLine, Headers headers, List<Integer> chunkSizes,
+      long bodySize, Buffer body, int sequenceNumber, Socket socket) {
     this.requestLine = requestLine;
     this.headers = headers;
     this.chunkSizes = chunkSizes;
@@ -45,7 +44,7 @@ public RecordedRequest(String requestLine, List<String> headers, List<Integer> c
     this.body = body;
     this.sequenceNumber = sequenceNumber;
     this.tlsVersion = socket instanceof SSLSocket
-        ? Internal.instance.tlsVersionForJavaName(((SSLSocket) socket).getSession().getProtocol())
+        ? TlsVersion.forJavaName(((SSLSocket) socket).getSession().getProtocol())
         : null;
 
     if (requestLine != null) {
@@ -72,36 +71,14 @@ public String getPath() {
   }
 
   /** Returns all headers. */
-  public List<String> getHeaders() {
+  public Headers getHeaders() {
     return headers;
   }
 
-  /**
-   * Returns the first header named {@code name}, or null if no such header
-   * exists.
-   */
+  /** Returns the first header named {@code name}, or null if no such header exists. */
   public String getHeader(String name) {
-    name += ":";
-    for (int i = 0, size = headers.size(); i < size; i++) {
-      String header = headers.get(i);
-      if (name.regionMatches(true, 0, header, 0, name.length())) {
-        return header.substring(name.length()).trim();
-      }
-    }
-    return null;
-  }
-
-  /** Returns the headers named {@code name}. */
-  public List<String> getHeaders(String name) {
-    List<String> result = new ArrayList<>();
-    name += ":";
-    for (int i = 0, size = headers.size(); i < size; i++) {
-      String header = headers.get(i);
-      if (name.regionMatches(true, 0, header, 0, name.length())) {
-        result.add(header.substring(name.length()).trim());
-      }
-    }
-    return result;
+    List<String> values = headers.values(name);
+    return values.isEmpty() ? null : values.get(0);
   }
 
   /**
@@ -121,17 +98,13 @@ public long getBodySize() {
   }
 
   /** Returns the body of this POST request. This may be truncated. */
-  public byte[] getBody() {
+  public Buffer getBody() {
     return body;
   }
 
-  /** Returns the body of this POST request decoded as a UTF-8 string. */
+  /** @deprecated Use {@link #getBody() getBody().readUtf8()}. */
   public String getUtf8Body() {
-    try {
-      return new String(body, "UTF-8");
-    } catch (UnsupportedEncodingException e) {
-      throw new AssertionError();
-    }
+    return getBody().readUtf8();
   }
 
   /**
@@ -143,11 +116,6 @@ public int getSequenceNumber() {
     return sequenceNumber;
   }
 
-  /** @deprecated Use {@link #getTlsVersion()}. */
-  public String getSslProtocol() {
-    return tlsVersion != null ? tlsVersion.name() : null;
-  }
-
   /** Returns the connection's TLS version or null if the connection doesn't use SSL. */
   public TlsVersion getTlsVersion() {
     return tlsVersion;
diff --git a/mockwebserver/src/main/java/com/squareup/okhttp/mockwebserver/rule/MockWebServerRule.java b/mockwebserver/src/main/java/com/squareup/okhttp/mockwebserver/rule/MockWebServerRule.java
index 05c94cf1f6..01df8e219a 100644
--- a/mockwebserver/src/main/java/com/squareup/okhttp/mockwebserver/rule/MockWebServerRule.java
+++ b/mockwebserver/src/main/java/com/squareup/okhttp/mockwebserver/rule/MockWebServerRule.java
@@ -40,7 +40,7 @@
     if (started) return;
     started = true;
     try {
-      server.play();
+      server.start();
     } catch (IOException e) {
       throw new RuntimeException(e);
     }
@@ -54,6 +54,11 @@
     }
   }
 
+  public String getHostName() {
+    if (!started) before();
+    return server.getHostName();
+  }
+
   public int getPort() {
     if (!started) before();
     return server.getPort();
diff --git a/mockwebserver/src/test/java/com/squareup/okhttp/mockwebserver/CustomDispatcherTest.java b/mockwebserver/src/test/java/com/squareup/okhttp/mockwebserver/CustomDispatcherTest.java
index efd34742c5..1c8c8206c9 100644
--- a/mockwebserver/src/test/java/com/squareup/okhttp/mockwebserver/CustomDispatcherTest.java
+++ b/mockwebserver/src/test/java/com/squareup/okhttp/mockwebserver/CustomDispatcherTest.java
@@ -35,7 +35,7 @@
   }
 
   @Test public void simpleDispatch() throws Exception {
-    mockWebServer.play();
+    mockWebServer.start();
     final List<RecordedRequest> requestsMade = new ArrayList<>();
     final Dispatcher dispatcher = new Dispatcher() {
       @Override
@@ -56,7 +56,7 @@ public MockResponse dispatch(RecordedRequest request) throws InterruptedExceptio
   @Test public void outOfOrderResponses() throws Exception {
     AtomicInteger firstResponseCode = new AtomicInteger();
     AtomicInteger secondResponseCode = new AtomicInteger();
-    mockWebServer.play();
+    mockWebServer.start();
     final String secondRequest = "/bar";
     final String firstRequest = "/foo";
     final CountDownLatch latch = new CountDownLatch(1);
diff --git a/mockwebserver/src/test/java/com/squareup/okhttp/mockwebserver/MockWebServerTest.java b/mockwebserver/src/test/java/com/squareup/okhttp/mockwebserver/MockWebServerTest.java
index 7c45150ee7..388dbf64f5 100644
--- a/mockwebserver/src/test/java/com/squareup/okhttp/mockwebserver/MockWebServerTest.java
+++ b/mockwebserver/src/test/java/com/squareup/okhttp/mockwebserver/MockWebServerTest.java
@@ -15,9 +15,9 @@
  */
 package com.squareup.okhttp.mockwebserver;
 
+import com.squareup.okhttp.Headers;
 import com.squareup.okhttp.mockwebserver.rule.MockWebServerRule;
 import java.io.BufferedReader;
-import java.io.ByteArrayInputStream;
 import java.io.IOException;
 import java.io.InputStream;
 import java.io.InputStreamReader;
@@ -25,14 +25,15 @@
 import java.net.SocketTimeoutException;
 import java.net.URL;
 import java.net.URLConnection;
+import java.util.ArrayList;
 import java.util.Arrays;
-import java.util.Collections;
 import java.util.List;
 import java.util.concurrent.TimeUnit;
 import org.junit.Rule;
 import org.junit.Test;
 
 import static java.util.concurrent.TimeUnit.NANOSECONDS;
+import static java.util.concurrent.TimeUnit.SECONDS;
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertTrue;
 import static org.junit.Assert.fail;
@@ -40,41 +41,16 @@
 public final class MockWebServerTest {
   @Rule public final MockWebServerRule server = new MockWebServerRule();
 
-  @Test public void recordedRequestAccessors() {
-    List<String> headers = Arrays.asList(
-        "User-Agent: okhttp",
-        "Cookie: s=square",
-        "Cookie: a=android",
-        "X-Whitespace:  left",
-        "X-Whitespace:right  ",
-        "X-Whitespace:  both  "
-    );
-    List<Integer> chunkSizes = Collections.emptyList();
-    byte[] body = {'A', 'B', 'C'};
-    String requestLine = "GET / HTTP/1.1";
-    RecordedRequest request = new RecordedRequest(
-        requestLine, headers, chunkSizes, body.length, body, 0, null);
-    assertEquals("s=square", request.getHeader("cookie"));
-    assertEquals(Arrays.asList("s=square", "a=android"), request.getHeaders("cookie"));
-    assertEquals("left", request.getHeader("x-whitespace"));
-    assertEquals(Arrays.asList("left", "right", "both"), request.getHeaders("x-whitespace"));
-    assertEquals("ABC", request.getUtf8Body());
-  }
-
   @Test public void defaultMockResponse() {
     MockResponse response = new MockResponse();
-    assertEquals(Arrays.asList("Content-Length: 0"), response.getHeaders());
+    assertEquals(Arrays.asList("Content-Length: 0"), headersToList(response));
     assertEquals("HTTP/1.1 200 OK", response.getStatus());
   }
 
   @Test public void setBodyAdjustsHeaders() throws IOException {
     MockResponse response = new MockResponse().setBody("ABC");
-    assertEquals(Arrays.asList("Content-Length: 3"), response.getHeaders());
-    InputStream in = response.getBodyStream();
-    assertEquals('A', in.read());
-    assertEquals('B', in.read());
-    assertEquals('C', in.read());
-    assertEquals(-1, in.read());
+    assertEquals(Arrays.asList("Content-Length: 3"), headersToList(response));
+    assertEquals("ABC", response.getBody().readUtf8());
     assertEquals("HTTP/1.1 200 OK", response.getStatus());
   }
 
@@ -83,7 +59,7 @@
         .clearHeaders()
         .addHeader("Cookie: s=square")
         .addHeader("Cookie", "a=android");
-    assertEquals(Arrays.asList("Cookie: s=square", "Cookie: a=android"), response.getHeaders());
+    assertEquals(Arrays.asList("Cookie: s=square", "Cookie: a=android"), headersToList(response));
   }
 
   @Test public void mockResponseSetHeader() {
@@ -93,62 +69,7 @@
         .addHeader("Cookie: a=android")
         .addHeader("Cookies: delicious");
     response.setHeader("cookie", "r=robot");
-    assertEquals(Arrays.asList("Cookies: delicious", "cookie: r=robot"), response.getHeaders());
-  }
-
-  /**
-   * Clients who adhere to <a
-   * href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec8.html#sec8.2.3">100
-   * Status</a> expect the server to send an interim response with status code
-   * 100 before they send their payload.
-   *
-   * <h4>Note</h4>
-   *
-   * JRE 6 only passes this test if
-   * {@code -Dsun.net.http.allowRestrictedHeaders=true} is set.
-   */
-  @Test public void expect100ContinueWithBody() throws Exception {
-    server.enqueue(new MockResponse());
-
-    URL url = server.getUrl("/");
-    HttpURLConnection connection = (HttpURLConnection) url.openConnection();
-    connection.setRequestMethod("PUT");
-    connection.setAllowUserInteraction(false);
-    connection.setRequestProperty("Expect", "100-continue");
-    connection.setDoOutput(true);
-    connection.getOutputStream().write("hello".getBytes());
-    assertEquals(HttpURLConnection.HTTP_OK, connection.getResponseCode());
-
-    assertEquals(server.getRequestCount(), 1);
-    RecordedRequest request = server.takeRequest();
-    assertEquals(request.getRequestLine(), "PUT / HTTP/1.1");
-    assertEquals("5", request.getHeader("Content-Length"));
-    assertEquals(5, request.getBodySize());
-    assertEquals("hello", new String(request.getBody()));
-    // below fails on JRE 6 unless -Dsun.net.http.allowRestrictedHeaders=true is set
-    assertEquals("100-continue", request.getHeader("Expect"));
-  }
-
-  @Test public void expect100ContinueWithNoBody() throws Exception {
-    server.enqueue(new MockResponse());
-
-    URL url = server.getUrl("/");
-    HttpURLConnection connection = (HttpURLConnection) url.openConnection();
-    connection.setRequestMethod("PUT");
-    connection.setAllowUserInteraction(false);
-    connection.setRequestProperty("Expect", "100-continue");
-    connection.setRequestProperty("Content-Length", "0");
-    connection.setDoOutput(true);
-    connection.setFixedLengthStreamingMode(0);
-    assertEquals(HttpURLConnection.HTTP_OK, connection.getResponseCode());
-
-    assertEquals(server.getRequestCount(), 1);
-    RecordedRequest request = server.takeRequest();
-    assertEquals(request.getRequestLine(), "PUT / HTTP/1.1");
-    assertEquals("0", request.getHeader("Content-Length"));
-    assertEquals(0, request.getBodySize());
-    // below fails on JRE 6 unless -Dsun.net.http.allowRestrictedHeaders=true is set
-    assertEquals("100-continue", request.getHeader("Expect"));
+    assertEquals(Arrays.asList("Cookies: delicious", "cookie: r=robot"), headersToList(response));
   }
 
   @Test public void regularResponse() throws Exception {
@@ -164,7 +85,7 @@
 
     RecordedRequest request = server.takeRequest();
     assertEquals("GET / HTTP/1.1", request.getRequestLine());
-    assertTrue(request.getHeaders().contains("Accept-Language: en-US"));
+    assertEquals("en-US", request.getHeader("Accept-Language"));
   }
 
   @Test public void redirect() throws Exception {
@@ -262,18 +183,6 @@
     server.getUrl("/b").openConnection().getInputStream(); // Should succeed.
   }
 
-  @Test public void streamingResponseBody() throws Exception {
-    InputStream responseBody = new ByteArrayInputStream("ABC".getBytes("UTF-8"));
-    server.enqueue(new MockResponse().setBody(responseBody, 3));
-
-    InputStream in = server.getUrl("/").openConnection().getInputStream();
-    assertEquals('A', in.read());
-    assertEquals('B', in.read());
-    assertEquals('C', in.read());
-
-    assertEquals(-1, responseBody.read()); // The body is exhausted.
-  }
-
   /**
    * Throttle the request body by sleeping 500ms after every 3 bytes. With a
    * 6-byte request, this should yield one sleep for a total delay of 500ms.
@@ -322,12 +231,12 @@
   }
 
   /**
-   * Delay the response body by sleeping 1000ms.
+   * Delay the response body by sleeping 1s.
    */
   @Test public void delayResponse() throws IOException {
     server.enqueue(new MockResponse()
         .setBody("ABCDEF")
-        .setBodyDelayTimeMs(1000));
+        .setBodyDelay(1, SECONDS));
 
     long startNanos = System.nanoTime();
     URLConnection connection = server.getUrl("/").openConnection();
@@ -345,4 +254,14 @@
     assertTrue(String.format("Request + Response: %sms", elapsedMillis), elapsedMillis >= 1000);
     assertTrue(String.format("Request + Response: %sms", elapsedMillis), elapsedMillis <= 1100);
   }
+
+  private List<String> headersToList(MockResponse response) {
+    Headers headers = response.getHeaders();
+    int size = headers.size();
+    List<String> headerList = new ArrayList<>(size);
+    for (int i = 0; i < size; i++) {
+      headerList.add(headers.name(i) + ": " + headers.value(i));
+    }
+    return headerList;
+  }
 }
diff --git a/okhttp-android-support/pom.xml b/okhttp-android-support/pom.xml
new file mode 100644
index 0000000000..f00d51ad92
--- /dev/null
+++ b/okhttp-android-support/pom.xml
@@ -0,0 +1,50 @@
+<?xml version="1.0" encoding="UTF-8"?>
+
+<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
+  <modelVersion>4.0.0</modelVersion>
+
+  <parent>
+    <groupId>com.squareup.okhttp</groupId>
+    <artifactId>parent</artifactId>
+    <version>2.3.0-SNAPSHOT</version>
+  </parent>
+
+  <artifactId>okhttp-android-support</artifactId>
+  <name>OkHttp Android Platform Support</name>
+  <description>Classes to support the Android platform's use of OkHttp (not required for most developers).</description>
+
+  <dependencies>
+    <dependency>
+      <groupId>com.squareup.okhttp</groupId>
+      <artifactId>okhttp-urlconnection</artifactId>
+      <version>${project.version}</version>
+    </dependency>
+ 
+    <dependency>
+      <groupId>junit</groupId>
+      <artifactId>junit</artifactId>
+      <scope>test</scope>
+    </dependency>
+    <dependency>
+      <groupId>com.squareup.okhttp</groupId>
+      <artifactId>mockwebserver</artifactId>
+      <version>${project.version}</version>
+      <scope>test</scope>
+    </dependency>
+  </dependencies>
+
+  <build>
+    <plugins>
+      <plugin>
+        <groupId>org.apache.maven.plugins</groupId>
+        <artifactId>maven-javadoc-plugin</artifactId>
+        <configuration>
+          <excludePackageNames>com.squareup.okhttp.internal.*</excludePackageNames>
+          <links>
+            <link>http://square.github.io/okhttp/javadoc/</link>
+          </links>
+        </configuration>
+      </plugin>
+    </plugins>
+  </build>
+</project>
diff --git a/okhttp-android-support/src/main/java/com/squareup/okhttp/AndroidInternal.java b/okhttp-android-support/src/main/java/com/squareup/okhttp/AndroidInternal.java
new file mode 100644
index 0000000000..eeaf55473f
--- /dev/null
+++ b/okhttp-android-support/src/main/java/com/squareup/okhttp/AndroidInternal.java
@@ -0,0 +1,45 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.okhttp;
+
+import com.squareup.okhttp.internal.huc.CacheAdapter;
+
+import java.net.ResponseCache;
+
+/**
+ * Back doors to enable the use of OkHttp within the Android platform libraries. OkHttp is used to
+ * provide the default {@link java.net.HttpURLConnection} / {@link javax.net.ssl.HttpsURLConnection}
+ * implementation including support for a custom {@link ResponseCache}.
+ */
+public class AndroidInternal {
+
+  private AndroidInternal() {
+  }
+
+  /** Sets the response cache to be used to read and write cached responses. */
+  public static void setResponseCache(OkUrlFactory okUrlFactory, ResponseCache responseCache) {
+    OkHttpClient client = okUrlFactory.client();
+    if (responseCache instanceof OkCacheContainer) {
+      // Avoid adding layers of wrappers. Rather than wrap the ResponseCache in yet another layer to
+      // make the ResponseCache look like an InternalCache, we can unwrap the Cache instead.
+      // This means that Cache stats will be correctly updated.
+      OkCacheContainer okCacheContainer = (OkCacheContainer) responseCache;
+      client.setCache(okCacheContainer.getCache());
+    } else {
+      client.setInternalCache(responseCache != null ? new CacheAdapter(responseCache) : null);
+    }
+  }
+}
diff --git a/okhttp-android-support/src/main/java/com/squareup/okhttp/AndroidShimResponseCache.java b/okhttp-android-support/src/main/java/com/squareup/okhttp/AndroidShimResponseCache.java
new file mode 100644
index 0000000000..488d3d6cd2
--- /dev/null
+++ b/okhttp-android-support/src/main/java/com/squareup/okhttp/AndroidShimResponseCache.java
@@ -0,0 +1,145 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.okhttp;
+
+import com.squareup.okhttp.internal.huc.JavaApiConverter;
+
+import java.io.File;
+import java.io.IOException;
+import java.net.CacheRequest;
+import java.net.CacheResponse;
+import java.net.ResponseCache;
+import java.net.URI;
+import java.net.URLConnection;
+import java.util.List;
+import java.util.Map;
+
+/**
+ * A class provided for use by Android so that it can continue supporting a {@link ResponseCache}
+ * with stats.
+ */
+public class AndroidShimResponseCache extends ResponseCache {
+
+  private final Cache delegate;
+
+  private AndroidShimResponseCache(Cache delegate) {
+    this.delegate = delegate;
+  }
+
+  public static AndroidShimResponseCache create(File directory, long maxSize) throws IOException {
+    Cache cache = new Cache(directory, maxSize);
+    return new AndroidShimResponseCache(cache);
+  }
+
+  public boolean isEquivalent(File directory, long maxSize) {
+    Cache installedCache = getCache();
+    return (installedCache.getDirectory().equals(directory)
+        && installedCache.getMaxSize() == maxSize
+        && !installedCache.isClosed());
+  }
+
+  public Cache getCache() {
+    return delegate;
+  }
+
+  @Override public CacheResponse get(URI uri, String requestMethod,
+      Map<String, List<String>> requestHeaders) throws IOException {
+    Request okRequest = JavaApiConverter.createOkRequest(uri, requestMethod, requestHeaders);
+    Response okResponse = delegate.internalCache.get(okRequest);
+    if (okResponse == null) {
+      return null;
+    }
+    return JavaApiConverter.createJavaCacheResponse(okResponse);
+  }
+
+  @Override public CacheRequest put(URI uri, URLConnection urlConnection) throws IOException {
+    Response okResponse = JavaApiConverter.createOkResponse(uri, urlConnection);
+    com.squareup.okhttp.internal.http.CacheRequest okCacheRequest =
+        delegate.internalCache.put(okResponse);
+    if (okCacheRequest == null) {
+      return null;
+    }
+    return JavaApiConverter.createJavaCacheRequest(okCacheRequest);
+  }
+
+  /**
+   * Returns the number of bytes currently being used to store the values in
+   * this cache. This may be greater than the {@link #maxSize} if a background
+   * deletion is pending.
+   */
+  public long size() throws IOException {
+    return delegate.getSize();
+  }
+
+  /**
+   * Returns the maximum number of bytes that this cache should use to store
+   * its data.
+   */
+  public long maxSize() {
+    return delegate.getMaxSize();
+  }
+
+  /**
+   * Force buffered operations to the filesystem. This ensures that responses
+   * written to the cache will be available the next time the cache is opened,
+   * even if this process is killed.
+   */
+  public void flush() throws IOException {
+    delegate.flush();
+  }
+
+  /**
+   * Returns the number of HTTP requests that required the network to either
+   * supply a response or validate a locally cached response.
+   */
+  public int getNetworkCount() {
+    return delegate.getNetworkCount();
+  }
+
+  /**
+   * Returns the number of HTTP requests whose response was provided by the
+   * cache. This may include conditional {@code GET} requests that were
+   * validated over the network.
+   */
+  public int getHitCount() {
+    return delegate.getHitCount();
+  }
+
+  /**
+   * Returns the total number of HTTP requests that were made. This includes
+   * both client requests and requests that were made on the client's behalf
+   * to handle a redirects and retries.
+   */
+  public int getRequestCount() {
+    return delegate.getRequestCount();
+  }
+
+  /**
+   * Uninstalls the cache and releases any active resources. Stored contents
+   * will remain on the filesystem.
+   */
+  public void close() throws IOException {
+    delegate.close();
+  }
+
+  /**
+   * Uninstalls the cache and deletes all of its stored contents.
+   */
+  public void delete() throws IOException {
+    delegate.delete();
+  }
+
+}
diff --git a/okhttp-android-support/src/main/java/com/squareup/okhttp/OkCacheContainer.java b/okhttp-android-support/src/main/java/com/squareup/okhttp/OkCacheContainer.java
new file mode 100644
index 0000000000..d7b62e3ae1
--- /dev/null
+++ b/okhttp-android-support/src/main/java/com/squareup/okhttp/OkCacheContainer.java
@@ -0,0 +1,24 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.okhttp;
+
+/**
+ * An interface that allows OkHttp to detect that a {@link java.net.ResponseCache} contains a
+ * {@link Cache}.
+ */
+public interface OkCacheContainer {
+  Cache getCache();
+}
diff --git a/okhttp-urlconnection/src/main/java/com/squareup/okhttp/internal/huc/CacheAdapter.java b/okhttp-android-support/src/main/java/com/squareup/okhttp/internal/huc/CacheAdapter.java
similarity index 100%
rename from okhttp-urlconnection/src/main/java/com/squareup/okhttp/internal/huc/CacheAdapter.java
rename to okhttp-android-support/src/main/java/com/squareup/okhttp/internal/huc/CacheAdapter.java
diff --git a/okhttp-urlconnection/src/main/java/com/squareup/okhttp/internal/huc/JavaApiConverter.java b/okhttp-android-support/src/main/java/com/squareup/okhttp/internal/huc/JavaApiConverter.java
similarity index 90%
rename from okhttp-urlconnection/src/main/java/com/squareup/okhttp/internal/huc/JavaApiConverter.java
rename to okhttp-android-support/src/main/java/com/squareup/okhttp/internal/huc/JavaApiConverter.java
index 1d2492246a..603a559980 100644
--- a/okhttp-urlconnection/src/main/java/com/squareup/okhttp/internal/huc/JavaApiConverter.java
+++ b/okhttp-android-support/src/main/java/com/squareup/okhttp/internal/huc/JavaApiConverter.java
@@ -22,6 +22,7 @@
 import com.squareup.okhttp.Response;
 import com.squareup.okhttp.ResponseBody;
 import com.squareup.okhttp.internal.Util;
+import com.squareup.okhttp.internal.http.CacheRequest;
 import com.squareup.okhttp.internal.http.OkHeaders;
 import com.squareup.okhttp.internal.http.StatusLine;
 import java.io.IOException;
@@ -44,6 +45,7 @@
 import javax.net.ssl.SSLSocketFactory;
 import okio.BufferedSource;
 import okio.Okio;
+import okio.Sink;
 
 /**
  * Helper methods that convert between Java and OkHttp representations.
@@ -79,7 +81,7 @@ public static Response createOkResponse(URI uri, URLConnection urlConnection) th
     okResponseBuilder.headers(okHeaders);
 
     // Response body
-    ResponseBody okBody = createOkBody(okHeaders, urlConnection.getInputStream());
+    ResponseBody okBody = createOkBody(urlConnection);
     okResponseBuilder.body(okBody);
 
     // Handle SSL handshake information as needed.
@@ -126,7 +128,7 @@ static Response createOkResponse(Request request, CacheResponse javaResponse)
     okResponseBuilder.headers(okHeaders);
 
     // Response body
-    ResponseBody okBody = createOkBody(okHeaders, javaResponse.getBody());
+    ResponseBody okBody = createOkBody(okHeaders, javaResponse);
     okResponseBuilder.body(okBody);
 
     // Handle SSL handshake information as needed.
@@ -245,6 +247,23 @@ public InputStream getBody() throws IOException {
     }
   }
 
+  public static java.net.CacheRequest createJavaCacheRequest(final CacheRequest okCacheRequest) {
+    return new java.net.CacheRequest() {
+      @Override
+      public void abort() {
+        okCacheRequest.abort();
+      }
+      @Override
+      public OutputStream getBody() throws IOException {
+        Sink body = okCacheRequest.body();
+        if (body == null) {
+          return null;
+        }
+        return Okio.buffer(body).outputStream();
+      }
+    };
+  }
+
   /**
    * Creates an {@link java.net.HttpURLConnection} of the correct subclass from the supplied OkHttp
    * {@link Response}.
@@ -339,18 +358,55 @@ static String extractStatusLine(Map<String, List<String>> javaResponseHeaders) {
   /**
    * Creates an OkHttp Response.Body containing the supplied information.
    */
-  private static ResponseBody createOkBody(final Headers okHeaders, InputStream body) {
-    final BufferedSource source = Okio.buffer(Okio.source(body));
+  private static ResponseBody createOkBody(final Headers okHeaders,
+      final CacheResponse cacheResponse) {
     return new ResponseBody() {
-      @Override public MediaType contentType() {
+      private BufferedSource body;
+
+      @Override
+      public MediaType contentType() {
         String contentTypeHeader = okHeaders.get("Content-Type");
         return contentTypeHeader == null ? null : MediaType.parse(contentTypeHeader);
       }
-      @Override public long contentLength() {
+
+      @Override
+      public long contentLength() {
         return OkHeaders.contentLength(okHeaders);
       }
-      @Override public BufferedSource source() {
-        return source;
+      @Override public BufferedSource source() throws IOException {
+        if (body == null) {
+          InputStream is = cacheResponse.getBody();
+          body = Okio.buffer(Okio.source(is));
+        }
+        return body;
+      }
+    };
+  }
+
+  /**
+   * Creates an OkHttp Response.Body containing the supplied information.
+   */
+  private static ResponseBody createOkBody(final URLConnection urlConnection) {
+    if (!urlConnection.getDoInput()) {
+      return null;
+    }
+    return new ResponseBody() {
+      private BufferedSource body;
+
+      @Override public MediaType contentType() {
+        String contentTypeHeader = urlConnection.getContentType();
+        return contentTypeHeader == null ? null : MediaType.parse(contentTypeHeader);
+      }
+      @Override public long contentLength() {
+        String s = urlConnection.getHeaderField("Content-Length");
+        return stringToLong(s);
+      }
+      @Override public BufferedSource source() throws IOException {
+        if (body == null) {
+          InputStream is = urlConnection.getInputStream();
+          body = Okio.buffer(Okio.source(is));
+        }
+        return body;
       }
     };
   }
@@ -376,7 +432,9 @@ public CacheHttpURLConnection(Response response) {
 
       // Configure URLConnection inherited fields.
       this.connected = true;
-      this.doOutput = response.body() == null;
+      this.doOutput = request.body() != null;
+      this.doInput = true;
+      this.useCaches = true;
 
       // Configure HttpUrlConnection inherited fields.
       this.method = request.method();
@@ -567,7 +625,7 @@ public void setDoInput(boolean doInput) {
 
     @Override
     public boolean getDoInput() {
-      return true;
+      return doInput;
     }
 
     @Override
@@ -577,7 +635,7 @@ public void setDoOutput(boolean doOutput) {
 
     @Override
     public boolean getDoOutput() {
-      return request.body() != null;
+      return doOutput;
     }
 
     @Override
@@ -607,7 +665,7 @@ public void setIfModifiedSince(long ifModifiedSince) {
 
     @Override
     public long getIfModifiedSince() {
-      return 0;
+      return stringToLong(request.headers().get("If-Modified-Since"));
     }
 
     @Override
@@ -683,4 +741,12 @@ private static RuntimeException throwResponseBodyAccessException() {
     return elements == null ? Collections.<T>emptyList() : Util.immutableList(elements);
   }
 
+  private static long stringToLong(String s) {
+    if (s == null) return -1;
+    try {
+      return Long.parseLong(s);
+    } catch (NumberFormatException e) {
+      return -1;
+    }
+  }
 }
diff --git a/okhttp-urlconnection/src/test/java/com/squareup/okhttp/AbstractResponseCache.java b/okhttp-android-support/src/test/java/com/squareup/okhttp/AbstractResponseCache.java
similarity index 100%
rename from okhttp-urlconnection/src/test/java/com/squareup/okhttp/AbstractResponseCache.java
rename to okhttp-android-support/src/test/java/com/squareup/okhttp/AbstractResponseCache.java
diff --git a/okhttp-android-support/src/test/java/com/squareup/okhttp/android/HttpResponseCache.java b/okhttp-android-support/src/test/java/com/squareup/okhttp/android/HttpResponseCache.java
new file mode 100644
index 0000000000..30d965c2b7
--- /dev/null
+++ b/okhttp-android-support/src/test/java/com/squareup/okhttp/android/HttpResponseCache.java
@@ -0,0 +1,191 @@
+/*
+ * Copyright (C) 2011 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.squareup.okhttp.android;
+
+import com.squareup.okhttp.Cache;
+import com.squareup.okhttp.AndroidShimResponseCache;
+import com.squareup.okhttp.OkCacheContainer;
+
+import java.io.Closeable;
+import java.io.File;
+import java.io.IOException;
+import java.net.CacheRequest;
+import java.net.CacheResponse;
+import java.net.ResponseCache;
+import java.net.URI;
+import java.net.URLConnection;
+import java.util.List;
+import java.util.Map;
+
+/**
+ * A copy of android.net.http.HttpResponseCache taken from AOSP. Android need to keep this code
+ * working somehow. Dependencies on com.squareup.okhttp are com.android.okhttp on Android.
+ */
+/* <p>This class exists in okhttp-android-support to help keep the API as it always has been on
+ * Android. The public API cannot be changed. This class delegates to
+ * {@link com.squareup.okhttp.AndroidShimResponseCache}, a class that exists in a package that
+ * enables it to interact with non-public OkHttp classes.
+ */
+public final class HttpResponseCache extends ResponseCache implements Closeable, OkCacheContainer {
+
+  private AndroidShimResponseCache shimResponseCache;
+
+  private HttpResponseCache(AndroidShimResponseCache shimResponseCache) {
+    this.shimResponseCache = shimResponseCache;
+  }
+
+  /**
+   * Returns the currently-installed {@code HttpResponseCache}, or null if
+   * there is no cache installed or it is not a {@code HttpResponseCache}.
+   */
+  public static HttpResponseCache getInstalled() {
+    ResponseCache installed = ResponseCache.getDefault();
+    if (installed instanceof HttpResponseCache) {
+      return (HttpResponseCache) installed;
+    }
+    return null;
+  }
+
+  /**
+   * Creates a new HTTP response cache and sets it as the system default cache.
+   *
+   * @param directory the directory to hold cache data.
+   * @param maxSize the maximum size of the cache in bytes.
+   * @return the newly-installed cache
+   * @throws java.io.IOException if {@code directory} cannot be used for this cache.
+   *     Most applications should respond to this exception by logging a
+   *     warning.
+   */
+  public static synchronized HttpResponseCache install(File directory, long maxSize) throws
+      IOException {
+    ResponseCache installed = ResponseCache.getDefault();
+
+    if (installed instanceof HttpResponseCache) {
+      HttpResponseCache installedResponseCache = (HttpResponseCache) installed;
+      // don't close and reopen if an equivalent cache is already installed
+      AndroidShimResponseCache trueResponseCache = installedResponseCache.shimResponseCache;
+      if (trueResponseCache.isEquivalent(directory, maxSize)) {
+        return installedResponseCache;
+      } else {
+        // The HttpResponseCache that owns this object is about to be replaced.
+        trueResponseCache.close();
+      }
+    }
+
+    AndroidShimResponseCache trueResponseCache =
+        AndroidShimResponseCache.create(directory, maxSize);
+    HttpResponseCache newResponseCache = new HttpResponseCache(trueResponseCache);
+    ResponseCache.setDefault(newResponseCache);
+    return newResponseCache;
+  }
+
+  @Override public CacheResponse get(URI uri, String requestMethod,
+      Map<String, List<String>> requestHeaders) throws IOException {
+    return shimResponseCache.get(uri, requestMethod, requestHeaders);
+  }
+
+  @Override public CacheRequest put(URI uri, URLConnection urlConnection) throws IOException {
+    return shimResponseCache.put(uri, urlConnection);
+  }
+
+  /**
+   * Returns the number of bytes currently being used to store the values in
+   * this cache. This may be greater than the {@link #maxSize} if a background
+   * deletion is pending.
+   */
+  public long size() {
+    try {
+      return shimResponseCache.size();
+    } catch (IOException e) {
+      // This can occur if the cache failed to lazily initialize. Return -1 to mean "unknown".
+      return -1;
+    }
+  }
+
+  /**
+   * Returns the maximum number of bytes that this cache should use to store
+   * its data.
+   */
+  public long maxSize() {
+    return shimResponseCache.maxSize();
+  }
+
+  /**
+   * Force buffered operations to the filesystem. This ensures that responses
+   * written to the cache will be available the next time the cache is opened,
+   * even if this process is killed.
+   */
+  public void flush() {
+    try {
+      shimResponseCache.flush();
+    } catch (IOException ignored) {
+    }
+  }
+
+  /**
+   * Returns the number of HTTP requests that required the network to either
+   * supply a response or validate a locally cached response.
+   */
+  public int getNetworkCount() {
+    return shimResponseCache.getNetworkCount();
+  }
+
+  /**
+   * Returns the number of HTTP requests whose response was provided by the
+   * cache. This may include conditional {@code GET} requests that were
+   * validated over the network.
+   */
+  public int getHitCount() {
+    return shimResponseCache.getHitCount();
+  }
+
+  /**
+   * Returns the total number of HTTP requests that were made. This includes
+   * both client requests and requests that were made on the client's behalf
+   * to handle a redirects and retries.
+   */
+  public int getRequestCount() {
+    return shimResponseCache.getRequestCount();
+  }
+
+  /**
+   * Uninstalls the cache and releases any active resources. Stored contents
+   * will remain on the filesystem.
+   */
+  @Override public void close() throws IOException {
+    if (ResponseCache.getDefault() == this) {
+      ResponseCache.setDefault(null);
+    }
+    shimResponseCache.close();
+  }
+
+  /**
+   * Uninstalls the cache and deletes all of its stored contents.
+   */
+  public void delete() throws IOException {
+    if (ResponseCache.getDefault() == this) {
+      ResponseCache.setDefault(null);
+    }
+    shimResponseCache.delete();
+  }
+
+  @Override
+  public Cache getCache() {
+    return shimResponseCache.getCache();
+  }
+
+}
diff --git a/okhttp-android-support/src/test/java/com/squareup/okhttp/android/HttpResponseCacheTest.java b/okhttp-android-support/src/test/java/com/squareup/okhttp/android/HttpResponseCacheTest.java
new file mode 100644
index 0000000000..c349790453
--- /dev/null
+++ b/okhttp-android-support/src/test/java/com/squareup/okhttp/android/HttpResponseCacheTest.java
@@ -0,0 +1,181 @@
+/*
+ * Copyright (C) 2011 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.squareup.okhttp.android;
+
+import com.squareup.okhttp.AndroidInternal;
+import com.squareup.okhttp.OkHttpClient;
+import com.squareup.okhttp.OkUrlFactory;
+import com.squareup.okhttp.mockwebserver.MockResponse;
+import com.squareup.okhttp.mockwebserver.MockWebServer;
+import com.squareup.okhttp.mockwebserver.rule.MockWebServerRule;
+
+import org.junit.After;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.rules.TemporaryFolder;
+
+import java.io.File;
+import java.io.InputStream;
+import java.net.CacheRequest;
+import java.net.CacheResponse;
+import java.net.ResponseCache;
+import java.net.URI;
+import java.net.URL;
+import java.net.URLConnection;
+import java.util.List;
+import java.util.Map;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertNotNull;
+import static org.junit.Assert.assertNotSame;
+import static org.junit.Assert.assertNull;
+import static org.junit.Assert.assertSame;
+import static org.junit.Assert.fail;
+
+/**
+ * A port of Android's android.net.http.HttpResponseCacheTest to JUnit4.
+ */
+public final class HttpResponseCacheTest {
+
+  @Rule public TemporaryFolder cacheRule = new TemporaryFolder();
+  @Rule public MockWebServerRule serverRule = new MockWebServerRule();
+
+  private File cacheDir;
+  private MockWebServer server;
+  private OkUrlFactory client;
+
+  @Before public void setUp() throws Exception {
+    server = serverRule.get();
+    cacheDir = cacheRule.getRoot();
+    client = new OkUrlFactory(new OkHttpClient());
+  }
+
+  @After public void tearDown() throws Exception {
+    ResponseCache.setDefault(null);
+  }
+
+  @Test public void install() throws Exception {
+    HttpResponseCache installed = HttpResponseCache.install(cacheDir, 10 * 1024 * 1024);
+    assertNotNull(installed);
+    assertSame(installed, ResponseCache.getDefault());
+    assertSame(installed, HttpResponseCache.getDefault());
+  }
+
+  @Test public void secondEquivalentInstallDoesNothing() throws Exception {
+    HttpResponseCache first = HttpResponseCache.install(cacheDir, 10 * 1024 * 1024);
+    HttpResponseCache another = HttpResponseCache.install(cacheDir, 10 * 1024 * 1024);
+    assertSame(first, another);
+  }
+
+  @Test public void installClosesPreviouslyInstalled() throws Exception {
+    HttpResponseCache first = HttpResponseCache.install(cacheDir, 10 * 1024 * 1024);
+    initializeCache(first);
+
+    HttpResponseCache another = HttpResponseCache.install(cacheDir, 8 * 1024 * 1024);
+    initializeCache(another);
+
+    assertNotSame(first, another);
+    try {
+      first.flush();
+      fail();
+    } catch (IllegalStateException expected) {
+    }
+  }
+
+  @Test public void getInstalledWithWrongTypeInstalled() {
+    ResponseCache.setDefault(new ResponseCache() {
+      @Override
+      public CacheResponse get(URI uri, String requestMethod,
+          Map<String, List<String>> requestHeaders) {
+        return null;
+      }
+
+      @Override
+      public CacheRequest put(URI uri, URLConnection connection) {
+        return null;
+      }
+    });
+    assertNull(HttpResponseCache.getInstalled());
+  }
+
+  @Test public void closeCloses() throws Exception {
+    HttpResponseCache cache = HttpResponseCache.install(cacheDir, 10 * 1024 * 1024);
+    initializeCache(cache);
+
+    cache.close();
+    try {
+      cache.flush();
+      fail();
+    } catch (IllegalStateException expected) {
+    }
+  }
+
+  @Test public void closeUninstalls() throws Exception {
+    HttpResponseCache cache = HttpResponseCache.install(cacheDir, 10 * 1024 * 1024);
+    cache.close();
+    assertNull(ResponseCache.getDefault());
+  }
+
+  @Test public void deleteUninstalls() throws Exception {
+    HttpResponseCache cache = HttpResponseCache.install(cacheDir, 10 * 1024 * 1024);
+    cache.delete();
+    assertNull(ResponseCache.getDefault());
+  }
+
+  /**
+   * Make sure that statistics tracking are wired all the way through the
+   * wrapper class. http://code.google.com/p/android/issues/detail?id=25418
+   */
+  @Test public void statisticsTracking() throws Exception {
+    HttpResponseCache cache = HttpResponseCache.install(cacheDir, 10 * 1024 * 1024);
+
+    server.enqueue(new MockResponse()
+        .addHeader("Cache-Control: max-age=60")
+        .setBody("A"));
+
+    URLConnection c1 = openUrl(server.getUrl("/"));
+
+    InputStream inputStream = c1.getInputStream();
+    assertEquals('A', inputStream.read());
+    inputStream.close();
+    assertEquals(1, cache.getRequestCount());
+    assertEquals(1, cache.getNetworkCount());
+    assertEquals(0, cache.getHitCount());
+
+    URLConnection c2 = openUrl(server.getUrl("/"));
+    assertEquals('A', c2.getInputStream().read());
+
+    URLConnection c3 = openUrl(server.getUrl("/"));
+    assertEquals('A', c3.getInputStream().read());
+    assertEquals(3, cache.getRequestCount());
+    assertEquals(1, cache.getNetworkCount());
+    assertEquals(2, cache.getHitCount());
+  }
+
+  // This mimics the Android HttpHandler, which is found in the com.squareup.okhttp package.
+  private URLConnection openUrl(URL url) {
+    ResponseCache responseCache = ResponseCache.getDefault();
+    AndroidInternal.setResponseCache(client, responseCache);
+    return client.open(url);
+  }
+
+  private void initializeCache(HttpResponseCache cache) {
+    // Ensure the cache is initialized, otherwise various methods are no-ops.
+    cache.size();
+  }
+}
diff --git a/okhttp-urlconnection/src/test/java/com/squareup/okhttp/internal/huc/CacheAdapterTest.java b/okhttp-android-support/src/test/java/com/squareup/okhttp/internal/huc/CacheAdapterTest.java
similarity index 96%
rename from okhttp-urlconnection/src/test/java/com/squareup/okhttp/internal/huc/CacheAdapterTest.java
rename to okhttp-android-support/src/test/java/com/squareup/okhttp/internal/huc/CacheAdapterTest.java
index 270fb837ee..4cca79e5e3 100644
--- a/okhttp-urlconnection/src/test/java/com/squareup/okhttp/internal/huc/CacheAdapterTest.java
+++ b/okhttp-android-support/src/test/java/com/squareup/okhttp/internal/huc/CacheAdapterTest.java
@@ -30,6 +30,7 @@
 import java.net.URI;
 import java.net.URL;
 import java.net.URLConnection;
+import java.nio.charset.StandardCharsets;
 import java.util.Collections;
 import java.util.List;
 import java.util.Map;
@@ -41,6 +42,8 @@
 import org.junit.Before;
 import org.junit.Test;
 
+import okio.Buffer;
+
 import static org.junit.Assert.assertArrayEquals;
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertFalse;
@@ -130,17 +133,19 @@ public CacheResponse get(URI uri, String method, Map<String, List<String>> heade
 
   @Test public void put_httpGet() throws Exception {
     final String statusLine = "HTTP/1.1 200 Fantastic";
+    final byte[] response = "ResponseString".getBytes(StandardCharsets.UTF_8);
     final URL serverUrl = configureServer(
         new MockResponse()
             .setStatus(statusLine)
-            .addHeader("A", "c"));
+            .addHeader("A", "c")
+            .setBody(new Buffer().write(response)));
 
     ResponseCache responseCache = new AbstractResponseCache() {
       @Override public CacheRequest put(URI uri, URLConnection connection) throws IOException {
         assertTrue(connection instanceof HttpURLConnection);
         assertFalse(connection instanceof HttpsURLConnection);
 
-        assertEquals(0, connection.getContentLength());
+        assertEquals(response.length, connection.getContentLength());
 
         HttpURLConnection httpUrlConnection = (HttpURLConnection) connection;
         assertEquals("GET", httpUrlConnection.getRequestMethod());
@@ -254,14 +259,14 @@ private void executePost(HttpURLConnection connection) throws IOException {
 
   private URL configureServer(MockResponse mockResponse) throws Exception {
     server.enqueue(mockResponse);
-    server.play();
+    server.start();
     return server.getUrl("/");
   }
 
   private URL configureHttpsServer(MockResponse mockResponse) throws Exception {
     server.useHttps(sslContext.getSocketFactory(), false /* tunnelProxy */);
     server.enqueue(mockResponse);
-    server.play();
+    server.start();
     return server.getUrl("/");
   }
 }
diff --git a/okhttp-urlconnection/src/test/java/com/squareup/okhttp/internal/huc/JavaApiConverterTest.java b/okhttp-android-support/src/test/java/com/squareup/okhttp/internal/huc/JavaApiConverterTest.java
similarity index 99%
rename from okhttp-urlconnection/src/test/java/com/squareup/okhttp/internal/huc/JavaApiConverterTest.java
rename to okhttp-android-support/src/test/java/com/squareup/okhttp/internal/huc/JavaApiConverterTest.java
index 92fb7afd61..d5dfcd8557 100644
--- a/okhttp-urlconnection/src/test/java/com/squareup/okhttp/internal/huc/JavaApiConverterTest.java
+++ b/okhttp-android-support/src/test/java/com/squareup/okhttp/internal/huc/JavaApiConverterTest.java
@@ -676,7 +676,8 @@ private void assertHeadersContainsMapping(Map<String, List<String>> headers, Str
     javaResponseHeaders.put("key2", Arrays.asList("value2"));
     assertEquals("StatusLine", JavaApiConverter.extractStatusLine(javaResponseHeaders));
 
-    assertNull(JavaApiConverter.extractStatusLine(Collections.<String, List<String>>emptyMap()));
+    assertNull(
+        JavaApiConverter.extractStatusLine(Collections.<String, List<String>>emptyMap()));
   }
 
   private URL configureServer(MockResponse mockResponse) throws Exception {
diff --git a/okhttp-urlconnection/src/test/java/com/squareup/okhttp/internal/huc/ResponseCacheTest.java b/okhttp-android-support/src/test/java/com/squareup/okhttp/internal/huc/ResponseCacheTest.java
similarity index 96%
rename from okhttp-urlconnection/src/test/java/com/squareup/okhttp/internal/huc/ResponseCacheTest.java
rename to okhttp-android-support/src/test/java/com/squareup/okhttp/internal/huc/ResponseCacheTest.java
index e3b2c79793..3c91fb5851 100644
--- a/okhttp-urlconnection/src/test/java/com/squareup/okhttp/internal/huc/ResponseCacheTest.java
+++ b/okhttp-android-support/src/test/java/com/squareup/okhttp/internal/huc/ResponseCacheTest.java
@@ -17,6 +17,7 @@
 package com.squareup.okhttp.internal.huc;
 
 import com.squareup.okhttp.AbstractResponseCache;
+import com.squareup.okhttp.Headers;
 import com.squareup.okhttp.OkHttpClient;
 import com.squareup.okhttp.OkUrlFactory;
 import com.squareup.okhttp.internal.Internal;
@@ -51,7 +52,6 @@
 import java.util.Arrays;
 import java.util.Date;
 import java.util.HashMap;
-import java.util.Iterator;
 import java.util.List;
 import java.util.Map;
 import java.util.concurrent.TimeUnit;
@@ -160,6 +160,31 @@ private void testResponseCaching(TransferKind transferKind) throws IOException {
     in.close();
   }
 
+  @Test public void responseCachingWithoutBody() throws IOException {
+    MockResponse response =
+        new MockResponse().addHeader("Last-Modified: " + formatDate(-1, TimeUnit.HOURS))
+            .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS))
+            .setStatus("HTTP/1.1 200 Fantastic");
+    server.enqueue(response);
+
+    // Make sure that calling skip() doesn't omit bytes from the cache.
+    HttpURLConnection urlConnection = openConnection(server.getUrl("/"));
+    assertEquals(200, urlConnection.getResponseCode());
+    assertEquals("Fantastic", urlConnection.getResponseMessage());
+    assertTrue(urlConnection.getDoInput());
+    InputStream is = urlConnection.getInputStream();
+    assertEquals(-1, is.read());
+    is.close();
+
+    urlConnection = openConnection(server.getUrl("/")); // cached!
+    assertTrue(urlConnection.getDoInput());
+    InputStream cachedIs = urlConnection.getInputStream();
+    assertEquals(-1, cachedIs.read());
+    cachedIs.close();
+    assertEquals(200, urlConnection.getResponseCode());
+    assertEquals("Fantastic", urlConnection.getResponseMessage());
+  }
+
   @Test public void secureResponseCaching() throws IOException {
     server.useHttps(sslContext.getSocketFactory(), false);
     server.enqueue(new MockResponse().addHeader("Last-Modified: " + formatDate(-1, TimeUnit.HOURS))
@@ -421,8 +446,7 @@ private void testClientPrematureDisconnect(TransferKind transferKind) throws IOE
     RecordedRequest conditionalRequest = assertConditionallyCached(
         new MockResponse().addHeader("Last-Modified: " + lastModifiedDate)
             .addHeader("Date: " + formatDate(-15, TimeUnit.SECONDS)));
-    List<String> headers = conditionalRequest.getHeaders();
-    assertTrue(headers.contains("If-Modified-Since: " + lastModifiedDate));
+    assertEquals(lastModifiedDate, conditionalRequest.getHeader("If-Modified-Since"));
   }
 
   @Test public void defaultExpirationDateFullyCachedForMoreThan24Hours() throws Exception {
@@ -458,8 +482,7 @@ private void testClientPrematureDisconnect(TransferKind transferKind) throws IOE
     RecordedRequest conditionalRequest = assertConditionallyCached(
         new MockResponse().addHeader("Last-Modified: " + lastModifiedDate)
             .addHeader("Expires: " + formatDate(-1, TimeUnit.HOURS)));
-    List<String> headers = conditionalRequest.getHeaders();
-    assertTrue(headers.contains("If-Modified-Since: " + lastModifiedDate));
+    assertEquals(lastModifiedDate, conditionalRequest.getHeader("If-Modified-Since"));
   }
 
   @Test public void expirationDateInThePastWithNoLastModifiedHeader() throws Exception {
@@ -482,8 +505,7 @@ private void testClientPrematureDisconnect(TransferKind transferKind) throws IOE
         new MockResponse().addHeader("Date: " + formatDate(-120, TimeUnit.SECONDS))
             .addHeader("Last-Modified: " + lastModifiedDate)
             .addHeader("Cache-Control: max-age=60"));
-    List<String> headers = conditionalRequest.getHeaders();
-    assertTrue(headers.contains("If-Modified-Since: " + lastModifiedDate));
+    assertEquals(lastModifiedDate, conditionalRequest.getHeader("If-Modified-Since"));
   }
 
   @Test public void maxAgeInThePastWithDateHeaderButNoLastModifiedHeader() throws Exception {
@@ -595,7 +617,7 @@ private void testRequestMethod(String requestMethod, boolean expectCached) throw
   @Test public void etag() throws Exception {
     RecordedRequest conditionalRequest =
         assertConditionallyCached(new MockResponse().addHeader("ETag: v1"));
-    assertTrue(conditionalRequest.getHeaders().contains("If-None-Match: v1"));
+    assertEquals("v1", conditionalRequest.getHeader("If-None-Match"));
   }
 
   @Test public void etagAndExpirationDateInThePast() throws Exception {
@@ -604,9 +626,8 @@ private void testRequestMethod(String requestMethod, boolean expectCached) throw
         new MockResponse().addHeader("ETag: v1")
             .addHeader("Last-Modified: " + lastModifiedDate)
             .addHeader("Expires: " + formatDate(-1, TimeUnit.HOURS)));
-    List<String> headers = conditionalRequest.getHeaders();
-    assertTrue(headers.contains("If-None-Match: v1"));
-    assertTrue(headers.contains("If-Modified-Since: " + lastModifiedDate));
+    assertEquals("v1", conditionalRequest.getHeader("If-None-Match"));
+    assertNull(conditionalRequest.getHeader("If-Modified-Since"));
   }
 
   @Test public void etagAndExpirationDateInTheFuture() throws Exception {
@@ -625,8 +646,7 @@ private void testRequestMethod(String requestMethod, boolean expectCached) throw
         new MockResponse().addHeader("Last-Modified: " + lastModifiedDate)
             .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS))
             .addHeader("Cache-Control: no-cache"));
-    List<String> headers = conditionalRequest.getHeaders();
-    assertTrue(headers.contains("If-Modified-Since: " + lastModifiedDate));
+    assertEquals(lastModifiedDate, conditionalRequest.getHeader("If-Modified-Since"));
   }
 
   @Test public void pragmaNoCache() throws Exception {
@@ -639,8 +659,7 @@ private void testRequestMethod(String requestMethod, boolean expectCached) throw
         new MockResponse().addHeader("Last-Modified: " + lastModifiedDate)
             .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS))
             .addHeader("Pragma: no-cache"));
-    List<String> headers = conditionalRequest.getHeaders();
-    assertTrue(headers.contains("If-Modified-Since: " + lastModifiedDate));
+    assertEquals(lastModifiedDate, conditionalRequest.getHeader("If-Modified-Since"));
   }
 
   @Test public void cacheControlNoStore() throws Exception {
@@ -863,9 +882,8 @@ private void assertNonIdentityEncodingCached(MockResponse response) throws Excep
     String ifModifiedSinceDate = formatDate(-24, TimeUnit.HOURS);
     RecordedRequest request =
         assertClientSuppliedCondition(response, "If-Modified-Since", ifModifiedSinceDate);
-    List<String> headers = request.getHeaders();
-    assertTrue(headers.contains("If-Modified-Since: " + ifModifiedSinceDate));
-    assertFalse(headers.contains("If-None-Match: v3"));
+    assertEquals(ifModifiedSinceDate, request.getHeader("If-Modified-Since"));
+    assertNull(request.getHeader("If-None-Match"));
   }
 
   @Test public void clientSuppliedIfNoneMatchSinceWithCachedResult() throws Exception {
@@ -874,9 +892,8 @@ private void assertNonIdentityEncodingCached(MockResponse response) throws Excep
         .addHeader("Date: " + formatDate(-2, TimeUnit.MINUTES))
         .addHeader("Cache-Control: max-age=0");
     RecordedRequest request = assertClientSuppliedCondition(response, "If-None-Match", "v1");
-    List<String> headers = request.getHeaders();
-    assertTrue(headers.contains("If-None-Match: v1"));
-    assertFalse(headers.contains("If-Modified-Since: " + lastModifiedDate));
+    assertEquals("v1", request.getHeader("If-None-Match"));
+    assertNull(request.getHeader("If-Modified-Since"));
   }
 
   private RecordedRequest assertClientSuppliedCondition(MockResponse seed, String conditionName,
@@ -905,7 +922,7 @@ private RecordedRequest assertClientSuppliedCondition(MockResponse seed, String
     connection.setIfModifiedSince(since.getTime());
     assertEquals("A", readAscii(connection));
     RecordedRequest request = server.takeRequest();
-    assertTrue(request.getHeaders().contains("If-Modified-Since: " + HttpDate.format(since)));
+    assertEquals(HttpDate.format(since), request.getHeader("If-Modified-Since"));
   }
 
   @Test public void clientSuppliedConditionWithoutCachedResult() throws Exception {
@@ -1212,9 +1229,11 @@ public void assertCookies(CookieManager cookieManager, URL url, String... expect
   }
 
   @Test public void emptyResponseHeaderNameFromCacheIsLenient() throws Exception {
+    Headers.Builder headers = new Headers.Builder()
+        .add("Cache-Control: max-age=120");
+    Internal.instance.addLenient(headers, ": A");
     server.enqueue(new MockResponse()
-        .addHeader("Cache-Control: max-age=120")
-        .addHeader(": A")
+        .setHeaders(headers.build())
         .setBody("body"));
 
     HttpURLConnection connection = openConnection(server.getUrl("/"));
@@ -1362,12 +1381,11 @@ private void assertFullyCached(MockResponse response) throws Exception {
    */
   private MockResponse truncateViolently(MockResponse response, int numBytesToKeep) {
     response.setSocketPolicy(DISCONNECT_AT_END);
-    List<String> headers = new ArrayList<>(response.getHeaders());
+    Headers headers = response.getHeaders();
     Buffer truncatedBody = new Buffer();
     truncatedBody.write(response.getBody(), numBytesToKeep);
     response.setBody(truncatedBody);
-    response.getHeaders().clear();
-    response.getHeaders().addAll(headers);
+    response.setHeaders(headers);
     return response;
   }
 
@@ -1428,12 +1446,7 @@ private void assertGatewayTimeout(HttpURLConnection connection) throws IOExcepti
       @Override void setBody(MockResponse response, Buffer content, int chunkSize) {
         response.setBody(content);
         response.setSocketPolicy(DISCONNECT_AT_END);
-        for (Iterator<String> h = response.getHeaders().iterator(); h.hasNext(); ) {
-          if (h.next().startsWith("Content-Length:")) {
-            h.remove();
-            break;
-          }
-        }
+        response.removeHeader("Content-Length");
       }
     };
 
diff --git a/okhttp-apache/src/main/java/com/squareup/okhttp/apache/OkApacheClient.java b/okhttp-apache/src/main/java/com/squareup/okhttp/apache/OkApacheClient.java
index e1b1dd9cbc..602a2c8297 100644
--- a/okhttp-apache/src/main/java/com/squareup/okhttp/apache/OkApacheClient.java
+++ b/okhttp-apache/src/main/java/com/squareup/okhttp/apache/OkApacheClient.java
@@ -74,7 +74,7 @@ private static Request transformRequest(HttpRequest request) {
     return builder.build();
   }
 
-  private static HttpResponse transformResponse(Response response) {
+  private static HttpResponse transformResponse(Response response) throws IOException {
     int code = response.code();
     String message = response.message();
     BasicHttpResponse httpResponse = new BasicHttpResponse(HTTP_1_1, code, message);
diff --git a/okhttp-apache/src/test/java/com/squareup/okhttp/apache/OkApacheClientTest.java b/okhttp-apache/src/test/java/com/squareup/okhttp/apache/OkApacheClientTest.java
index 0f1d092b8b..ca47c0131a 100644
--- a/okhttp-apache/src/test/java/com/squareup/okhttp/apache/OkApacheClientTest.java
+++ b/okhttp-apache/src/test/java/com/squareup/okhttp/apache/OkApacheClientTest.java
@@ -6,7 +6,6 @@
 import java.io.ByteArrayInputStream;
 import java.io.IOException;
 import java.io.InputStream;
-import java.util.Arrays;
 import java.util.zip.GZIPInputStream;
 import okio.Buffer;
 import okio.GzipSink;
@@ -28,7 +27,6 @@
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertNotNull;
 import static org.junit.Assert.assertNull;
-import static org.junit.Assert.assertTrue;
 
 public class OkApacheClientTest {
   private MockWebServer server;
@@ -37,7 +35,7 @@
   @Before public void setUp() throws IOException {
     client = new OkApacheClient();
     server = new MockWebServer();
-    server.play();
+    server.start();
   }
 
   @After public void tearDown() throws IOException {
@@ -98,7 +96,7 @@
     client.execute(post);
 
     RecordedRequest request = server.takeRequest();
-    assertTrue(Arrays.equals(body, request.getBody()));
+    assertEquals("Hello, world!", request.getBody().readUtf8());
     assertEquals(request.getHeader("Content-Length"), "13");
   }
 
@@ -111,7 +109,7 @@
     client.execute(post);
 
     RecordedRequest request = server.takeRequest();
-    assertTrue(Arrays.equals(body, request.getBody()));
+    assertEquals("Hello, world!", request.getBody().readUtf8());
     assertEquals(request.getHeader("Content-Length"), "13");
   }
 
diff --git a/okhttp-tests/src/test/java/com/squareup/okhttp/CacheControlTest.java b/okhttp-tests/src/test/java/com/squareup/okhttp/CacheControlTest.java
index 7962ef3226..5d1376737e 100644
--- a/okhttp-tests/src/test/java/com/squareup/okhttp/CacheControlTest.java
+++ b/okhttp-tests/src/test/java/com/squareup/okhttp/CacheControlTest.java
@@ -20,6 +20,8 @@
 
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertNull;
+import static org.junit.Assert.assertSame;
 import static org.junit.Assert.assertTrue;
 import static org.junit.Assert.fail;
 
@@ -31,6 +33,7 @@
     assertFalse(cacheControl.noStore());
     assertEquals(-1, cacheControl.maxAgeSeconds());
     assertEquals(-1, cacheControl.sMaxAgeSeconds());
+    assertFalse(cacheControl.isPrivate());
     assertFalse(cacheControl.isPublic());
     assertFalse(cacheControl.mustRevalidate());
     assertEquals(-1, cacheControl.maxStaleSeconds());
@@ -60,6 +63,7 @@
 
     // These members are accessible to response headers only.
     assertEquals(-1, cacheControl.sMaxAgeSeconds());
+    assertFalse(cacheControl.isPrivate());
     assertFalse(cacheControl.isPublic());
     assertFalse(cacheControl.mustRevalidate());
   }
@@ -81,7 +85,7 @@
   }
 
   @Test public void parse() throws Exception {
-    String header = "no-cache, no-store, max-age=1, s-maxage=2, public, must-revalidate, "
+    String header = "no-cache, no-store, max-age=1, s-maxage=2, private, public, must-revalidate, "
         + "max-stale=3, min-fresh=4, only-if-cached, no-transform";
     CacheControl cacheControl = CacheControl.parse(new Headers.Builder()
         .set("Cache-Control", header)
@@ -90,6 +94,7 @@
     assertTrue(cacheControl.noStore());
     assertEquals(1, cacheControl.maxAgeSeconds());
     assertEquals(2, cacheControl.sMaxAgeSeconds());
+    assertTrue(cacheControl.isPrivate());
     assertTrue(cacheControl.isPublic());
     assertTrue(cacheControl.mustRevalidate());
     assertEquals(3, cacheControl.maxStaleSeconds());
@@ -99,6 +104,70 @@
     assertEquals(header, cacheControl.toString());
   }
 
+  @Test public void parseIgnoreCacheControlExtensions() throws Exception {
+    // Example from http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.9.6
+    String header = "private, community=\"UCI\"";
+    CacheControl cacheControl = CacheControl.parse(new Headers.Builder()
+        .set("Cache-Control", header)
+        .build());
+    assertFalse(cacheControl.noCache());
+    assertFalse(cacheControl.noStore());
+    assertEquals(-1, cacheControl.maxAgeSeconds());
+    assertEquals(-1, cacheControl.sMaxAgeSeconds());
+    assertTrue(cacheControl.isPrivate());
+    assertFalse(cacheControl.isPublic());
+    assertFalse(cacheControl.mustRevalidate());
+    assertEquals(-1, cacheControl.maxStaleSeconds());
+    assertEquals(-1, cacheControl.minFreshSeconds());
+    assertFalse(cacheControl.onlyIfCached());
+    assertFalse(cacheControl.noTransform());
+    assertEquals(header, cacheControl.toString());
+  }
+
+  @Test public void parseCacheControlAndPragmaAreCombined() {
+    Headers headers =
+        Headers.of("Cache-Control", "max-age=12", "Pragma", "must-revalidate", "Pragma", "public");
+    CacheControl cacheControl = CacheControl.parse(headers);
+    assertEquals("max-age=12, public, must-revalidate", cacheControl.toString());
+  }
+
+  @SuppressWarnings("RedundantStringConstructorCall") // Testing instance equality.
+  @Test public void parseCacheControlHeaderValueIsRetained() {
+    String value = new String("max-age=12");
+    Headers headers = Headers.of("Cache-Control", value);
+    CacheControl cacheControl = CacheControl.parse(headers);
+    assertSame(value, cacheControl.toString());
+  }
+
+  @Test public void parseCacheControlHeaderValueInvalidatedByPragma() {
+    Headers headers = Headers.of("Cache-Control", "max-age=12", "Pragma", "must-revalidate");
+    CacheControl cacheControl = CacheControl.parse(headers);
+    assertNull(cacheControl.headerValue);
+  }
+
+  @Test public void parseCacheControlHeaderValueInvalidatedByTwoValues() {
+    Headers headers = Headers.of("Cache-Control", "max-age=12", "Cache-Control", "must-revalidate");
+    CacheControl cacheControl = CacheControl.parse(headers);
+    assertNull(cacheControl.headerValue);
+  }
+
+  @Test public void parsePragmaHeaderValueIsNotRetained() {
+    Headers headers = Headers.of("Pragma", "must-revalidate");
+    CacheControl cacheControl = CacheControl.parse(headers);
+    assertNull(cacheControl.headerValue);
+  }
+
+  @Test public void computedHeaderValueIsCached() {
+    CacheControl cacheControl = new CacheControl.Builder()
+        .maxAge(2, TimeUnit.DAYS)
+        .build();
+    assertNull(cacheControl.headerValue);
+    assertEquals("max-age=172800", cacheControl.toString());
+    assertEquals("max-age=172800", cacheControl.headerValue);
+    cacheControl.headerValue = "Hi";
+    assertEquals("Hi", cacheControl.toString());
+  }
+
   @Test public void timeDurationTruncatedToMaxValue() throws Exception {
     CacheControl cacheControl = new CacheControl.Builder()
         .maxAge(365 * 100, TimeUnit.DAYS) // Longer than Integer.MAX_VALUE seconds.
diff --git a/okhttp-tests/src/test/java/com/squareup/okhttp/CacheTest.java b/okhttp-tests/src/test/java/com/squareup/okhttp/CacheTest.java
index 8f117f0ec5..af0f506755 100644
--- a/okhttp-tests/src/test/java/com/squareup/okhttp/CacheTest.java
+++ b/okhttp-tests/src/test/java/com/squareup/okhttp/CacheTest.java
@@ -16,6 +16,7 @@
 
 package com.squareup.okhttp;
 
+import com.squareup.okhttp.internal.Internal;
 import com.squareup.okhttp.internal.SslContextBuilder;
 import com.squareup.okhttp.internal.Util;
 import com.squareup.okhttp.mockwebserver.MockResponse;
@@ -112,41 +113,50 @@
     // assertCached(false, 100);
     assertCached(false, 101);
     assertCached(false, 102);
-    assertCached(true, 200);
+    assertCached(true,  200);
     assertCached(false, 201);
     assertCached(false, 202);
-    assertCached(true, 203);
-    assertCached(false, 204);
+    assertCached(true,  203);
+    assertCached(true,  204);
     assertCached(false, 205);
-    assertCached(false, 206); // we don't cache partial responses
+    assertCached(false, 206); //Electing to not cache partial responses
     assertCached(false, 207);
-    assertCached(true, 300);
-    assertCached(true, 301);
-    assertCached(true, 302);
+    assertCached(true,  300);
+    assertCached(true,  301);
+    assertCached(true,  302);
     assertCached(false, 303);
     assertCached(false, 304);
     assertCached(false, 305);
     assertCached(false, 306);
-    assertCached(true, 307);
-    assertCached(true, 308);
-    for (int i = 400; i <= 406; ++i) {
-      assertCached(false, i);
-    }
-    // (See test_responseCaching_407.)
+    assertCached(true,  307);
+    assertCached(true,  308);
+    assertCached(false, 400);
+    assertCached(false, 401);
+    assertCached(false, 402);
+    assertCached(false, 403);
+    assertCached(true,  404);
+    assertCached(true,  405);
+    assertCached(false, 406);
     assertCached(false, 408);
     assertCached(false, 409);
-    // (See test_responseCaching_410.)
-    for (int i = 411; i <= 418; ++i) {
-      assertCached(false, i);
-    }
-    for (int i = 500; i <= 506; ++i) {
-      assertCached(false, i);
-    }
-  }
-
-  @Test public void responseCaching_410() throws Exception {
     // the HTTP spec permits caching 410s, but the RI doesn't.
-    assertCached(true, 410);
+    assertCached(true,  410);
+    assertCached(false, 411);
+    assertCached(false, 412);
+    assertCached(false, 413);
+    assertCached(true,  414);
+    assertCached(false, 415);
+    assertCached(false, 416);
+    assertCached(false, 417);
+    assertCached(false, 418);
+
+    assertCached(false, 500);
+    assertCached(true,  501);
+    assertCached(false, 502);
+    assertCached(false, 503);
+    assertCached(false, 504);
+    assertCached(false, 505);
+    assertCached(false, 506);
   }
 
   private void assertCached(boolean shouldPut, int responseCode) throws Exception {
@@ -163,7 +173,7 @@ private void assertCached(boolean shouldPut, int responseCode) throws Exception
       mockResponse.addHeader("WWW-Authenticate: Basic realm=\"protected area\"");
     }
     server.enqueue(mockResponse);
-    server.play();
+    server.start();
 
     Request request = new Request.Builder()
         .url(server.getUrl("/"))
@@ -561,8 +571,7 @@ private void testClientPrematureDisconnect(TransferKind transferKind) throws IOE
     RecordedRequest conditionalRequest = assertConditionallyCached(new MockResponse()
         .addHeader("Last-Modified: " + lastModifiedDate)
         .addHeader("Date: " + formatDate(-15, TimeUnit.SECONDS)));
-    List<String> headers = conditionalRequest.getHeaders();
-    assertTrue(headers.contains("If-Modified-Since: " + lastModifiedDate));
+    assertEquals(lastModifiedDate, conditionalRequest.getHeader("If-Modified-Since"));
   }
 
   @Test public void defaultExpirationDateFullyCachedForMoreThan24Hours() throws Exception {
@@ -599,8 +608,7 @@ private void testClientPrematureDisconnect(TransferKind transferKind) throws IOE
     RecordedRequest conditionalRequest = assertConditionallyCached(new MockResponse()
         .addHeader("Last-Modified: " + lastModifiedDate)
         .addHeader("Expires: " + formatDate(-1, TimeUnit.HOURS)));
-    List<String> headers = conditionalRequest.getHeaders();
-    assertTrue(headers.contains("If-Modified-Since: " + lastModifiedDate));
+    assertEquals(lastModifiedDate, conditionalRequest.getHeader("If-Modified-Since"));
   }
 
   @Test public void expirationDateInThePastWithNoLastModifiedHeader() throws Exception {
@@ -626,8 +634,7 @@ private void testClientPrematureDisconnect(TransferKind transferKind) throws IOE
         .addHeader("Date: " + formatDate(-120, TimeUnit.SECONDS))
         .addHeader("Last-Modified: " + lastModifiedDate)
         .addHeader("Cache-Control: max-age=60"));
-    List<String> headers = conditionalRequest.getHeaders();
-    assertTrue(headers.contains("If-Modified-Since: " + lastModifiedDate));
+    assertEquals(lastModifiedDate, conditionalRequest.getHeader("If-Modified-Since"));
   }
 
   @Test public void maxAgeInThePastWithDateHeaderButNoLastModifiedHeader() throws Exception {
@@ -808,18 +815,18 @@ private void testMethodInvalidates(String requestMethod) throws Exception {
   @Test public void etag() throws Exception {
     RecordedRequest conditionalRequest = assertConditionallyCached(new MockResponse()
         .addHeader("ETag: v1"));
-    assertTrue(conditionalRequest.getHeaders().contains("If-None-Match: v1"));
+    assertEquals("v1", conditionalRequest.getHeader("If-None-Match"));
   }
 
+  /** If both If-Modified-Since and If-None-Match conditions apply, send only If-None-Match. */
   @Test public void etagAndExpirationDateInThePast() throws Exception {
     String lastModifiedDate = formatDate(-2, TimeUnit.HOURS);
     RecordedRequest conditionalRequest = assertConditionallyCached(new MockResponse()
         .addHeader("ETag: v1")
         .addHeader("Last-Modified: " + lastModifiedDate)
         .addHeader("Expires: " + formatDate(-1, TimeUnit.HOURS)));
-    List<String> headers = conditionalRequest.getHeaders();
-    assertTrue(headers.contains("If-None-Match: v1"));
-    assertTrue(headers.contains("If-Modified-Since: " + lastModifiedDate));
+    assertEquals("v1", conditionalRequest.getHeader("If-None-Match"));
+    assertNull(conditionalRequest.getHeader("If-Modified-Since"));
   }
 
   @Test public void etagAndExpirationDateInTheFuture() throws Exception {
@@ -840,8 +847,7 @@ private void testMethodInvalidates(String requestMethod) throws Exception {
         .addHeader("Last-Modified: " + lastModifiedDate)
         .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS))
         .addHeader("Cache-Control: no-cache"));
-    List<String> headers = conditionalRequest.getHeaders();
-    assertTrue(headers.contains("If-Modified-Since: " + lastModifiedDate));
+    assertEquals(lastModifiedDate, conditionalRequest.getHeader("If-Modified-Since"));
   }
 
   @Test public void pragmaNoCache() throws Exception {
@@ -855,8 +861,7 @@ private void testMethodInvalidates(String requestMethod) throws Exception {
         .addHeader("Last-Modified: " + lastModifiedDate)
         .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS))
         .addHeader("Pragma: no-cache"));
-    List<String> headers = conditionalRequest.getHeaders();
-    assertTrue(headers.contains("If-Modified-Since: " + lastModifiedDate));
+    assertEquals(lastModifiedDate, conditionalRequest.getHeader("If-Modified-Since"));
   }
 
   @Test public void cacheControlNoStore() throws Exception {
@@ -1223,9 +1228,8 @@ private void assertNonIdentityEncodingCached(MockResponse response) throws Excep
     String ifModifiedSinceDate = formatDate(-24, TimeUnit.HOURS);
     RecordedRequest request =
         assertClientSuppliedCondition(response, "If-Modified-Since", ifModifiedSinceDate);
-    List<String> headers = request.getHeaders();
-    assertTrue(headers.contains("If-Modified-Since: " + ifModifiedSinceDate));
-    assertFalse(headers.contains("If-None-Match: v3"));
+    assertEquals(ifModifiedSinceDate, request.getHeader("If-Modified-Since"));
+    assertNull(request.getHeader("If-None-Match"));
   }
 
   @Test public void clientSuppliedIfNoneMatchSinceWithCachedResult() throws Exception {
@@ -1235,9 +1239,8 @@ private void assertNonIdentityEncodingCached(MockResponse response) throws Excep
         .addHeader("Date: " + formatDate(-2, TimeUnit.MINUTES))
         .addHeader("Cache-Control: max-age=0");
     RecordedRequest request = assertClientSuppliedCondition(response, "If-None-Match", "v1");
-    List<String> headers = request.getHeaders();
-    assertTrue(headers.contains("If-None-Match: v1"));
-    assertFalse(headers.contains("If-Modified-Since: " + lastModifiedDate));
+    assertEquals("v1", request.getHeader("If-None-Match"));
+    assertNull(request.getHeader("If-Modified-Since"));
   }
 
   private RecordedRequest assertClientSuppliedCondition(MockResponse seed, String conditionName,
@@ -1776,12 +1779,12 @@ public void assertCookies(URL url, String... expectedCookies) throws Exception {
     assertEquals(Arrays.asList(expectedCookies), actualCookies);
   }
 
-  @Test public void cachePlusRange() throws Exception {
+  @Test public void doNotCachePartialResponse() throws Exception  {
     assertNotCached(new MockResponse()
-        .setResponseCode(HttpURLConnection.HTTP_PARTIAL)
-        .addHeader("Date: " + formatDate(0, TimeUnit.HOURS))
-        .addHeader("Content-Range: bytes 100-100/200")
-        .addHeader("Cache-Control: max-age=60"));
+            .setResponseCode(HttpURLConnection.HTTP_PARTIAL)
+            .addHeader("Date: " + formatDate(0, TimeUnit.HOURS))
+            .addHeader("Content-Range: bytes 100-100/200")
+            .addHeader("Cache-Control: max-age=60"));
   }
 
   @Test public void conditionalHitUpdatesCache() throws Exception {
@@ -1867,9 +1870,11 @@ public void assertCookies(URL url, String... expectedCookies) throws Exception {
   }
 
   @Test public void emptyResponseHeaderNameFromCacheIsLenient() throws Exception {
+    Headers.Builder headers = new Headers.Builder()
+        .add("Cache-Control: max-age=120");
+    Internal.instance.addLenient(headers, ": A");
     server.enqueue(new MockResponse()
-        .addHeader("Cache-Control: max-age=120")
-        .addHeader(": A")
+        .setHeaders(headers.build())
         .setBody("body"));
 
     Response response = get(server.getUrl("/"));
@@ -2126,6 +2131,7 @@ private Response get(URL url) throws IOException {
     return client.newCall(request).execute();
   }
 
+
   private void writeFile(File directory, String file, String content) throws IOException {
     BufferedSink sink = Okio.buffer(Okio.sink(new File(directory, file)));
     sink.writeUtf8(content);
@@ -2211,12 +2217,11 @@ private void assertFullyCached(MockResponse response) throws Exception {
    */
   private MockResponse truncateViolently(MockResponse response, int numBytesToKeep) {
     response.setSocketPolicy(DISCONNECT_AT_END);
-    List<String> headers = new ArrayList<>(response.getHeaders());
+    Headers headers = response.getHeaders();
     Buffer truncatedBody = new Buffer();
     truncatedBody.write(response.getBody(), numBytesToKeep);
     response.setBody(truncatedBody);
-    response.getHeaders().clear();
-    response.getHeaders().addAll(headers);
+    response.setHeaders(headers);
     return response;
   }
 
@@ -2236,12 +2241,7 @@ private MockResponse truncateViolently(MockResponse response, int numBytesToKeep
       @Override void setBody(MockResponse response, Buffer content, int chunkSize) {
         response.setBody(content);
         response.setSocketPolicy(DISCONNECT_AT_END);
-        for (Iterator<String> h = response.getHeaders().iterator(); h.hasNext(); ) {
-          if (h.next().startsWith("Content-Length:")) {
-            h.remove();
-            break;
-          }
-        }
+        response.removeHeader("Content-Length");
       }
     };
 
diff --git a/okhttp-tests/src/test/java/com/squareup/okhttp/CallTest.java b/okhttp-tests/src/test/java/com/squareup/okhttp/CallTest.java
index 7cd24fa705..78e84a4a3f 100644
--- a/okhttp-tests/src/test/java/com/squareup/okhttp/CallTest.java
+++ b/okhttp-tests/src/test/java/com/squareup/okhttp/CallTest.java
@@ -21,26 +21,25 @@
 import com.squareup.okhttp.internal.RecordingOkAuthenticator;
 import com.squareup.okhttp.internal.SingleInetAddressNetwork;
 import com.squareup.okhttp.internal.SslContextBuilder;
+import com.squareup.okhttp.internal.Version;
 import com.squareup.okhttp.mockwebserver.Dispatcher;
 import com.squareup.okhttp.mockwebserver.MockResponse;
 import com.squareup.okhttp.mockwebserver.RecordedRequest;
 import com.squareup.okhttp.mockwebserver.SocketPolicy;
 import com.squareup.okhttp.mockwebserver.rule.MockWebServerRule;
-import java.io.File;
 import java.io.IOException;
 import java.io.InputStream;
 import java.io.InterruptedIOException;
 import java.net.CookieManager;
 import java.net.HttpCookie;
 import java.net.HttpURLConnection;
-import java.net.SocketException;
+import java.net.UnknownServiceException;
 import java.net.URL;
 import java.security.cert.Certificate;
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.Collection;
 import java.util.List;
-import java.util.UUID;
 import java.util.concurrent.BlockingQueue;
 import java.util.concurrent.Callable;
 import java.util.concurrent.CountDownLatch;
@@ -67,6 +66,7 @@
 import org.junit.Ignore;
 import org.junit.Rule;
 import org.junit.Test;
+import org.junit.rules.TemporaryFolder;
 import org.junit.rules.TestRule;
 import org.junit.rules.Timeout;
 
@@ -82,10 +82,11 @@
 public final class CallTest {
   private static final SSLContext sslContext = SslContextBuilder.localhost();
 
-  @Rule public TestRule timeout = new Timeout(30_000);
+  @Rule public final TemporaryFolder tempDir = new TemporaryFolder();
+  @Rule public final TestRule timeout = new Timeout(30_000);
 
-  @Rule public MockWebServerRule server = new MockWebServerRule();
-  @Rule public MockWebServerRule server2 = new MockWebServerRule();
+  @Rule public final MockWebServerRule server = new MockWebServerRule();
+  @Rule public final MockWebServerRule server2 = new MockWebServerRule();
   private OkHttpClient client = new OkHttpClient();
   private RecordingCallback callback = new RecordingCallback();
   private TestLogHandler logHandler = new TestLogHandler();
@@ -96,9 +97,7 @@
     callback = new RecordingCallback();
     logHandler = new TestLogHandler();
 
-    String tmp = System.getProperty("java.io.tmpdir");
-    File cacheDir = new File(tmp, "HttpCache-" + UUID.randomUUID());
-    cache = new Cache(cacheDir, Integer.MAX_VALUE);
+    cache = new Cache(tempDir.getRoot(), Integer.MAX_VALUE);
     logger.addHandler(logHandler);
   }
 
@@ -124,7 +123,7 @@
     RecordedRequest recordedRequest = server.takeRequest();
     assertEquals("GET", recordedRequest.getMethod());
     assertEquals("SyncApiTest", recordedRequest.getHeader("User-Agent"));
-    assertEquals(0, recordedRequest.getBody().length);
+    assertEquals(0, recordedRequest.getBody().size());
     assertNull(recordedRequest.getHeader("Content-Length"));
   }
 
@@ -203,7 +202,7 @@
     RecordedRequest recordedRequest = server.takeRequest();
     assertEquals("HEAD", recordedRequest.getMethod());
     assertEquals("SyncApiTest", recordedRequest.getHeader("User-Agent"));
-    assertEquals(0, recordedRequest.getBody().length);
+    assertEquals(0, recordedRequest.getBody().size());
     assertNull(recordedRequest.getHeader("Content-Length"));
   }
 
@@ -231,7 +230,7 @@
 
     RecordedRequest recordedRequest = server.takeRequest();
     assertEquals("POST", recordedRequest.getMethod());
-    assertEquals("def", recordedRequest.getUtf8Body());
+    assertEquals("def", recordedRequest.getBody().readUtf8());
     assertEquals("3", recordedRequest.getHeader("Content-Length"));
     assertEquals("text/plain; charset=utf-8", recordedRequest.getHeader("Content-Type"));
   }
@@ -260,7 +259,7 @@
 
     RecordedRequest recordedRequest = server.takeRequest();
     assertEquals("POST", recordedRequest.getMethod());
-    assertEquals(0, recordedRequest.getBody().length);
+    assertEquals(0, recordedRequest.getBody().size());
     assertEquals("0", recordedRequest.getHeader("Content-Length"));
     assertEquals(null, recordedRequest.getHeader("Content-Type"));
   }
@@ -321,12 +320,12 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
 
     RecordedRequest recordedRequest1 = server.takeRequest();
     assertEquals("POST", recordedRequest1.getMethod());
-    assertEquals(body, recordedRequest1.getUtf8Body());
+    assertEquals(body, recordedRequest1.getBody().readUtf8());
     assertNull(recordedRequest1.getHeader("Authorization"));
 
     RecordedRequest recordedRequest2 = server.takeRequest();
     assertEquals("POST", recordedRequest2.getMethod());
-    assertEquals(body, recordedRequest2.getUtf8Body());
+    assertEquals(body, recordedRequest2.getBody().readUtf8());
     assertEquals(credential, recordedRequest2.getHeader("Authorization"));
   }
 
@@ -375,7 +374,7 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
 
     RecordedRequest recordedRequest = server.takeRequest();
     assertEquals("DELETE", recordedRequest.getMethod());
-    assertEquals(0, recordedRequest.getBody().length);
+    assertEquals(0, recordedRequest.getBody().size());
     assertEquals("0", recordedRequest.getHeader("Content-Length"));
     assertEquals(null, recordedRequest.getHeader("Content-Type"));
   }
@@ -404,7 +403,7 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
 
     RecordedRequest recordedRequest = server.takeRequest();
     assertEquals("PUT", recordedRequest.getMethod());
-    assertEquals("def", recordedRequest.getUtf8Body());
+    assertEquals("def", recordedRequest.getBody().readUtf8());
     assertEquals("3", recordedRequest.getHeader("Content-Length"));
     assertEquals("text/plain; charset=utf-8", recordedRequest.getHeader("Content-Type"));
   }
@@ -433,7 +432,7 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
 
     RecordedRequest recordedRequest = server.takeRequest();
     assertEquals("PATCH", recordedRequest.getMethod());
-    assertEquals("def", recordedRequest.getUtf8Body());
+    assertEquals("def", recordedRequest.getBody().readUtf8());
     assertEquals("3", recordedRequest.getHeader("Content-Length"));
     assertEquals("text/plain; charset=utf-8", recordedRequest.getHeader("Content-Type"));
   }
@@ -461,7 +460,7 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
     RecordedRequest recordedRequest = server.takeRequest();
     assertEquals(null, recordedRequest.getHeader("Content-Type"));
     assertEquals("3", recordedRequest.getHeader("Content-Length"));
-    assertEquals("abc", recordedRequest.getUtf8Body());
+    assertEquals("abc", recordedRequest.getBody().readUtf8());
   }
 
   @Test public void illegalToExecuteTwice() throws Exception {
@@ -491,7 +490,7 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
       assertEquals("Already Executed", e.getMessage());
     }
 
-    assertTrue(server.takeRequest().getHeaders().contains("User-Agent: SyncApiTest"));
+    assertEquals("SyncApiTest", server.takeRequest().getHeader("User-Agent"));
   }
 
   @Test public void illegalToExecuteTwice_Async() throws Exception {
@@ -521,7 +520,7 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
       assertEquals("Already Executed", e.getMessage());
     }
 
-    assertTrue(server.takeRequest().getHeaders().contains("User-Agent: SyncApiTest"));
+    assertEquals("SyncApiTest", server.takeRequest().getHeader("User-Agent"));
   }
 
   @Test public void get_Async() throws Exception {
@@ -540,7 +539,7 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
         .assertHeader("Content-Type", "text/plain")
         .assertBody("abc");
 
-    assertTrue(server.takeRequest().getHeaders().contains("User-Agent: AsyncApiTest"));
+    assertEquals("AsyncApiTest", server.takeRequest().getHeader("User-Agent"));
   }
 
   @Test public void exceptionThrownByOnResponseIsRedactedAndLogged() throws Exception {
@@ -816,8 +815,8 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
 
   @Test public void cleartextCallsFailWhenCleartextIsDisabled() throws Exception {
     // Configure the client with only TLS configurations. No cleartext!
-    client.setConnectionSpecs(Arrays.asList(
-        ConnectionSpec.MODERN_TLS, ConnectionSpec.COMPATIBLE_TLS));
+    client.setConnectionSpecs(
+        Arrays.asList(ConnectionSpec.MODERN_TLS, ConnectionSpec.COMPATIBLE_TLS));
 
     server.enqueue(new MockResponse());
 
@@ -825,16 +824,14 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
     try {
       client.newCall(request).execute();
       fail();
-    } catch (SocketException expected) {
-      assertTrue(expected.getMessage().contains("exhausted connection specs"));
+    } catch (UnknownServiceException expected) {
+      assertTrue(expected.getMessage().contains("no connection specs"));
     }
   }
 
   @Test public void setFollowSslRedirectsFalse() throws Exception {
     server.get().useHttps(sslContext.getSocketFactory(), false);
-    server.enqueue(new MockResponse()
-        .setResponseCode(301)
-        .addHeader("Location: http://square.com"));
+    server.enqueue(new MockResponse().setResponseCode(301).addHeader("Location: http://square.com"));
 
     client.setFollowSslRedirects(false);
     client.setSslSocketFactory(sslContext.getSocketFactory());
@@ -904,7 +901,7 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
         .assertBody("abc");
 
     RecordedRequest recordedRequest = server.takeRequest();
-    assertEquals("def", recordedRequest.getUtf8Body());
+    assertEquals("def", recordedRequest.getBody().readUtf8());
     assertEquals("3", recordedRequest.getHeader("Content-Length"));
     assertEquals("text/plain; charset=utf-8", recordedRequest.getHeader("Content-Type"));
   }
@@ -930,11 +927,11 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
     assertEquals(0, get.getSequenceNumber());
 
     RecordedRequest post1 = server.takeRequest();
-    assertEquals("body!", post1.getUtf8Body());
+    assertEquals("body!", post1.getBody().readUtf8());
     assertEquals(1, post1.getSequenceNumber());
 
     RecordedRequest post2 = server.takeRequest();
-    assertEquals("body!", post2.getUtf8Body());
+    assertEquals("body!", post2.getBody().readUtf8());
     assertEquals(0, post2.getSequenceNumber());
   }
 
@@ -993,8 +990,7 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
         .addHeader("Vary: Accept-Charset")
         .addHeader("Donut: a")
         .setBody("A"));
-    server.enqueue(new MockResponse()
-        .clearHeaders()
+    server.enqueue(new MockResponse().clearHeaders()
         .addHeader("Donut: b")
         .setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
 
@@ -1201,7 +1197,7 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
 
     RecordedRequest page1 = server.takeRequest();
     assertEquals("POST /page1 HTTP/1.1", page1.getRequestLine());
-    assertEquals("Request Body", page1.getUtf8Body());
+    assertEquals("Request Body", page1.getBody().readUtf8());
 
     RecordedRequest page2 = server.takeRequest();
     assertEquals("GET /page2 HTTP/1.1", page2.getRequestLine());
@@ -1228,12 +1224,14 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
     assertEquals("Page 2", response.body().string());
 
     RecordedRequest request1 = server.takeRequest();
-    assertContains(request1.getHeaders(), "Cookie: $Version=\"1\"; "
-        + "c=\"cookie\";$Path=\"/\";$Domain=\"" + server.get().getCookieDomain()
-        + "\";$Port=\"" + portList + "\"");
+    assertEquals("$Version=\"1\"; c=\"cookie\";$Path=\"/\";$Domain=\""
+        + server.get().getCookieDomain()
+        + "\";$Port=\""
+        + portList
+        + "\"", request1.getHeader("Cookie"));
 
     RecordedRequest request2 = server2.takeRequest();
-    assertContainsNoneMatching(request2.getHeaders(), "Cookie.*");
+    assertNull(request2.getHeader("Cookie"));
   }
 
   @Test public void redirectsDoNotIncludeTooManyAuthHeaders() throws Exception {
@@ -1251,7 +1249,7 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
     assertEquals("Page 2", response.body().string());
 
     RecordedRequest redirectRequest = server2.takeRequest();
-    assertContainsNoneMatching(redirectRequest.getHeaders(), "Authorization.*");
+    assertNull(redirectRequest.getHeader("Authorization"));
     assertEquals("/b", redirectRequest.getPath());
   }
 
@@ -1466,8 +1464,8 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
     call.enqueue(callback);
     assertEquals("/a", server.takeRequest().getPath());
 
-    callback.await(requestA.url()).assertFailure(
-        "Canceled", "stream was reset: CANCEL", "Socket closed");
+    callback.await(requestA.url()).assertFailure("Canceled", "stream was reset: CANCEL",
+        "Socket closed");
   }
 
   @Test public void canceledBeforeResponseReadSignalsOnFailure_HTTP_2() throws Exception {
@@ -1601,7 +1599,7 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
 
     RecordedRequest recordedRequest = server.takeRequest();
     assertTrue(recordedRequest.getHeader("User-Agent")
-        .matches("okhttp/\\d\\.\\d\\.\\d(-SNAPSHOT|-RC\\d+)?"));
+        .matches(Version.userAgent()));
   }
 
   @Test public void setFollowRedirectsFalse() throws Exception {
@@ -1609,8 +1607,7 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
         .setResponseCode(302)
         .addHeader("Location: /b")
         .setBody("A"));
-    server.enqueue(new MockResponse()
-        .setBody("B"));
+    server.enqueue(new MockResponse().setBody("B"));
 
     client.setFollowRedirects(false);
     RecordedResponse recordedResponse = executeSynchronously(
@@ -1621,6 +1618,36 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
         .assertCode(302);
   }
 
+  @Test public void expect100ContinueNonEmptyRequestBody() throws Exception {
+    server.enqueue(new MockResponse());
+
+    Request request = new Request.Builder()
+        .url(server.getUrl("/"))
+        .header("Expect", "100-continue")
+        .post(RequestBody.create(MediaType.parse("text/plain"), "abc"))
+        .build();
+
+    executeSynchronously(request)
+        .assertCode(200)
+        .assertSuccessful();
+
+    assertEquals("abc", server.takeRequest().getUtf8Body());
+  }
+
+  @Test public void expect100ContinueEmptyRequestBody() throws Exception {
+    server.enqueue(new MockResponse());
+
+    Request request = new Request.Builder()
+        .url(server.getUrl("/"))
+        .header("Expect", "100-continue")
+        .post(RequestBody.create(MediaType.parse("text/plain"), ""))
+        .build();
+
+    executeSynchronously(request)
+        .assertCode(200)
+        .assertSuccessful();
+  }
+
   private RecordedResponse executeSynchronously(Request request) throws IOException {
     Response response = client.newCall(request).execute();
     return new RecordedResponse(request, response, null, response.body().string(), null);
diff --git a/okhttp-tests/src/test/java/com/squareup/okhttp/ConnectionPoolTest.java b/okhttp-tests/src/test/java/com/squareup/okhttp/ConnectionPoolTest.java
index 0bdc9f58a4..ebeb698ae3 100644
--- a/okhttp-tests/src/test/java/com/squareup/okhttp/ConnectionPoolTest.java
+++ b/okhttp-tests/src/test/java/com/squareup/okhttp/ConnectionPoolTest.java
@@ -80,14 +80,14 @@ private void setUp(int poolSize) throws Exception {
     List<ConnectionSpec> connectionSpecs = Util.immutableList(
         ConnectionSpec.MODERN_TLS, ConnectionSpec.CLEARTEXT);
 
-    httpServer.play();
+    httpServer.start();
     httpAddress = new Address(httpServer.getHostName(), httpServer.getPort(), socketFactory, null,
         null, null, AuthenticatorAdapter.INSTANCE, null,
         Util.immutableList(Protocol.SPDY_3, Protocol.HTTP_1_1), connectionSpecs, proxySelector);
     httpSocketAddress = new InetSocketAddress(InetAddress.getByName(httpServer.getHostName()),
         httpServer.getPort());
 
-    spdyServer.play();
+    spdyServer.start();
     spdyAddress = new Address(spdyServer.getHostName(), spdyServer.getPort(), socketFactory,
         sslContext.getSocketFactory(), new RecordingHostnameVerifier(), CertificatePinner.DEFAULT,
         AuthenticatorAdapter.INSTANCE, null, Util.immutableList(Protocol.SPDY_3, Protocol.HTTP_1_1),
@@ -558,7 +558,7 @@ private void assertPooled(ConnectionPool pool, Connection... connections) throws
   private static class FakeExecutor implements Executor {
 
     private Runnable runnable;
-    
+
     @Override
     public void execute(Runnable runnable) {
       // This is a bonus assertion for the invariant: At no time should two runnables be scheduled.
diff --git a/okhttp-tests/src/test/java/com/squareup/okhttp/ConnectionSpecTest.java b/okhttp-tests/src/test/java/com/squareup/okhttp/ConnectionSpecTest.java
new file mode 100644
index 0000000000..2267c2a1d6
--- /dev/null
+++ b/okhttp-tests/src/test/java/com/squareup/okhttp/ConnectionSpecTest.java
@@ -0,0 +1,182 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.okhttp;
+
+import com.squareup.okhttp.internal.http.AuthenticatorAdapter;
+
+import org.junit.Test;
+
+import java.net.InetSocketAddress;
+import java.net.Proxy;
+import java.net.ProxySelector;
+import java.util.Arrays;
+import java.util.LinkedHashSet;
+import java.util.Set;
+import javax.net.ssl.SSLSocket;
+import javax.net.ssl.SSLSocketFactory;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertNull;
+import static org.junit.Assert.assertTrue;
+
+public final class ConnectionSpecTest {
+
+  private static final Proxy PROXY = Proxy.NO_PROXY;
+  private static final InetSocketAddress INET_SOCKET_ADDRESS =
+      InetSocketAddress.createUnresolved("host", 443);
+  private static final Address HTTPS_ADDRESS = new Address(
+      INET_SOCKET_ADDRESS.getHostString(), INET_SOCKET_ADDRESS.getPort(), null, null, null, null,
+      AuthenticatorAdapter.INSTANCE, PROXY, Arrays.asList(Protocol.HTTP_1_1),
+      Arrays.asList(ConnectionSpec.MODERN_TLS), ProxySelector.getDefault());
+
+  @Test
+  public void cleartextBuilder() throws Exception {
+    ConnectionSpec cleartextSpec = new ConnectionSpec.Builder(false).build();
+    assertFalse(cleartextSpec.isTls());
+  }
+
+  @Test
+  public void tlsBuilder_explicitCiphers() throws Exception {
+    ConnectionSpec tlsSpec = new ConnectionSpec.Builder(true)
+        .cipherSuites(CipherSuite.TLS_RSA_WITH_RC4_128_MD5)
+        .tlsVersions(TlsVersion.TLS_1_2)
+        .supportsTlsExtensions(true)
+        .build();
+    assertEquals(Arrays.asList(CipherSuite.TLS_RSA_WITH_RC4_128_MD5), tlsSpec.cipherSuites());
+    assertEquals(Arrays.asList(TlsVersion.TLS_1_2), tlsSpec.tlsVersions());
+    assertTrue(tlsSpec.supportsTlsExtensions());
+  }
+
+  @Test
+  public void tlsBuilder_defaultCiphers() throws Exception {
+    ConnectionSpec tlsSpec = new ConnectionSpec.Builder(true)
+        .tlsVersions(TlsVersion.TLS_1_2)
+        .supportsTlsExtensions(true)
+        .build();
+    assertNull(tlsSpec.cipherSuites());
+    assertEquals(Arrays.asList(TlsVersion.TLS_1_2), tlsSpec.tlsVersions());
+    assertTrue(tlsSpec.supportsTlsExtensions());
+  }
+
+  @Test
+  public void tls_defaultCiphers_noFallbackIndicator() throws Exception {
+    ConnectionSpec tlsSpec = new ConnectionSpec.Builder(true)
+        .tlsVersions(TlsVersion.TLS_1_2)
+        .supportsTlsExtensions(false)
+        .build();
+
+    SSLSocket socket = (SSLSocket) SSLSocketFactory.getDefault().createSocket();
+    socket.setEnabledCipherSuites(new String[] {
+        CipherSuite.TLS_RSA_WITH_RC4_128_MD5.javaName,
+        CipherSuite.TLS_RSA_WITH_RC4_128_SHA.javaName,
+    });
+    socket.setEnabledProtocols(new String[] {
+        TlsVersion.TLS_1_2.javaName,
+        TlsVersion.TLS_1_1.javaName,
+    });
+
+    Route route = new Route(HTTPS_ADDRESS, PROXY, INET_SOCKET_ADDRESS, tlsSpec,
+        false /* shouldSendTlsFallbackIndicator */);
+    tlsSpec.apply(socket, route);
+
+    assertEquals(createSet(TlsVersion.TLS_1_2.javaName), createSet(socket.getEnabledProtocols()));
+
+    Set<String> expectedCipherSet =
+        createSet(
+            CipherSuite.TLS_RSA_WITH_RC4_128_MD5.javaName,
+            CipherSuite.TLS_RSA_WITH_RC4_128_SHA.javaName);
+    assertEquals(expectedCipherSet, expectedCipherSet);
+  }
+
+  @Test
+  public void tls_defaultCiphers_withFallbackIndicator() throws Exception {
+    ConnectionSpec tlsSpec = new ConnectionSpec.Builder(true)
+        .tlsVersions(TlsVersion.TLS_1_2)
+        .supportsTlsExtensions(false)
+        .build();
+
+    SSLSocket socket = (SSLSocket) SSLSocketFactory.getDefault().createSocket();
+    socket.setEnabledCipherSuites(new String[] {
+        CipherSuite.TLS_RSA_WITH_RC4_128_MD5.javaName,
+        CipherSuite.TLS_RSA_WITH_RC4_128_SHA.javaName,
+    });
+    socket.setEnabledProtocols(new String[] {
+        TlsVersion.TLS_1_2.javaName,
+        TlsVersion.TLS_1_1.javaName,
+    });
+
+    Route route = new Route(HTTPS_ADDRESS, PROXY, INET_SOCKET_ADDRESS, tlsSpec,
+        true /* shouldSendTlsFallbackIndicator */);
+    tlsSpec.apply(socket, route);
+
+    assertEquals(createSet(TlsVersion.TLS_1_2.javaName), createSet(socket.getEnabledProtocols()));
+
+    Set<String> expectedCipherSet =
+        createSet(
+            CipherSuite.TLS_RSA_WITH_RC4_128_MD5.javaName,
+            CipherSuite.TLS_RSA_WITH_RC4_128_SHA.javaName);
+    if (Arrays.asList(socket.getSupportedCipherSuites()).contains("TLS_FALLBACK_SCSV")) {
+      expectedCipherSet.add("TLS_FALLBACK_SCSV");
+    }
+    assertEquals(expectedCipherSet, expectedCipherSet);
+  }
+
+  @Test
+  public void tls_explicitCiphers() throws Exception {
+    ConnectionSpec tlsSpec = new ConnectionSpec.Builder(true)
+        .cipherSuites(CipherSuite.TLS_RSA_WITH_RC4_128_MD5)
+        .tlsVersions(TlsVersion.TLS_1_2)
+        .supportsTlsExtensions(false)
+        .build();
+
+    SSLSocket socket = (SSLSocket) SSLSocketFactory.getDefault().createSocket();
+    socket.setEnabledCipherSuites(new String[] {
+        CipherSuite.TLS_RSA_WITH_RC4_128_MD5.javaName,
+        CipherSuite.TLS_RSA_WITH_RC4_128_SHA.javaName,
+    });
+    socket.setEnabledProtocols(new String[] {
+        TlsVersion.TLS_1_2.javaName,
+        TlsVersion.TLS_1_1.javaName,
+    });
+
+    Route route = new Route(HTTPS_ADDRESS, PROXY, INET_SOCKET_ADDRESS, tlsSpec,
+        true /* shouldSendTlsFallbackIndicator */);
+    tlsSpec.apply(socket, route);
+
+    assertEquals(createSet(TlsVersion.TLS_1_2.javaName), createSet(socket.getEnabledProtocols()));
+
+    Set<String> expectedCipherSet = createSet(CipherSuite.TLS_RSA_WITH_RC4_128_MD5.javaName);
+    if (Arrays.asList(socket.getSupportedCipherSuites()).contains("TLS_FALLBACK_SCSV")) {
+      expectedCipherSet.add("TLS_FALLBACK_SCSV");
+    }
+    assertEquals(expectedCipherSet, expectedCipherSet);
+  }
+
+  @Test
+  public void tls_stringCiphersAndVersions() throws Exception {
+    // Supporting arbitrary input strings allows users to enable suites and versions that are not
+    // yet known to the library, but are supported by the platform.
+    ConnectionSpec tlsSpec = new ConnectionSpec.Builder(ConnectionSpec.MODERN_TLS)
+        .cipherSuites("MAGIC-CIPHER")
+        .tlsVersions("TLS9k")
+        .build();
+  }
+
+  private static Set<String> createSet(String... values) {
+    return new LinkedHashSet<String>(Arrays.asList(values));
+  }
+}
diff --git a/okhttp-tests/src/test/java/com/squareup/okhttp/InterceptorTest.java b/okhttp-tests/src/test/java/com/squareup/okhttp/InterceptorTest.java
index 46778d3a84..d186f4af2a 100644
--- a/okhttp-tests/src/test/java/com/squareup/okhttp/InterceptorTest.java
+++ b/okhttp-tests/src/test/java/com/squareup/okhttp/InterceptorTest.java
@@ -236,7 +236,7 @@ private void rewriteRequestToServer(List<Interceptor> interceptors) throws Excep
     client.newCall(request).execute();
 
     RecordedRequest recordedRequest = server.takeRequest();
-    assertEquals("ABC", recordedRequest.getUtf8Body());
+    assertEquals("ABC", recordedRequest.getBody().readUtf8());
     assertEquals("foo", recordedRequest.getHeader("Original-Header"));
     assertEquals("yep", recordedRequest.getHeader("OkHttp-Intercepted"));
     assertEquals("POST", recordedRequest.getMethod());
@@ -319,7 +319,7 @@ private void multipleInterceptors(List<Interceptor> interceptors) throws Excepti
 
     RecordedRequest recordedRequest = server.takeRequest();
     assertEquals(Arrays.asList("Android", "Bob"),
-        recordedRequest.getHeaders("Request-Interceptor"));
+        recordedRequest.getHeaders().values("Request-Interceptor"));
   }
 
   @Test public void asyncApplicationInterceptors() throws Exception {
@@ -371,6 +371,65 @@ private void asyncInterceptors(List<Interceptor> interceptors) throws Exception
     assertEquals(response.body().string(), "b");
   }
 
+  /** Make sure interceptors can interact with the OkHttp client. */
+  @Test public void interceptorMakesAnUnrelatedRequest() throws Exception {
+    server.enqueue(new MockResponse().setBody("a")); // Fetched by interceptor.
+    server.enqueue(new MockResponse().setBody("b")); // Fetched directly.
+
+    client.interceptors().add(new Interceptor() {
+      @Override public Response intercept(Chain chain) throws IOException {
+        if (chain.request().url().getPath().equals("/b")) {
+          Request requestA = new Request.Builder()
+              .url(server.getUrl("/a"))
+              .build();
+          Response responseA = client.newCall(requestA).execute();
+          assertEquals("a", responseA.body().string());
+        }
+
+        return chain.proceed(chain.request());
+      }
+    });
+
+    Request requestB = new Request.Builder()
+        .url(server.getUrl("/b"))
+        .build();
+    Response responseB = client.newCall(requestB).execute();
+    assertEquals("b", responseB.body().string());
+  }
+
+  /** Make sure interceptors can interact with the OkHttp client asynchronously. */
+  @Test public void interceptorMakesAnUnrelatedAsyncRequest() throws Exception {
+    server.enqueue(new MockResponse().setBody("a")); // Fetched by interceptor.
+    server.enqueue(new MockResponse().setBody("b")); // Fetched directly.
+
+    client.interceptors().add(new Interceptor() {
+      @Override public Response intercept(Chain chain) throws IOException {
+        if (chain.request().url().getPath().equals("/b")) {
+          Request requestA = new Request.Builder()
+              .url(server.getUrl("/a"))
+              .build();
+
+          try {
+            RecordingCallback callbackA = new RecordingCallback();
+            client.newCall(requestA).enqueue(callbackA);
+            callbackA.await(requestA.url()).assertBody("a");
+          } catch (Exception e) {
+            throw new RuntimeException(e);
+          }
+        }
+
+        return chain.proceed(chain.request());
+      }
+    });
+
+    Request requestB = new Request.Builder()
+        .url(server.getUrl("/b"))
+        .build();
+    RecordingCallback callbackB = new RecordingCallback();
+    client.newCall(requestB).enqueue(callbackB);
+    callbackB.await(requestB.url()).assertBody("b");
+  }
+
   private RequestBody uppercase(final RequestBody original) {
     return new RequestBody() {
       @Override public MediaType contentType() {
@@ -398,7 +457,7 @@ private Sink uppercase(final BufferedSink original) {
     };
   }
 
-  static ResponseBody uppercase(ResponseBody original) {
+  static ResponseBody uppercase(ResponseBody original) throws IOException {
     return ResponseBody.create(original.contentType(), original.contentLength(),
         Okio.buffer(uppercase(original.source())));
   }
diff --git a/okhttp-tests/src/test/java/com/squareup/okhttp/OkHttpClientTest.java b/okhttp-tests/src/test/java/com/squareup/okhttp/OkHttpClientTest.java
index 0bb8d1a80d..1fdaf1b912 100644
--- a/okhttp-tests/src/test/java/com/squareup/okhttp/OkHttpClientTest.java
+++ b/okhttp-tests/src/test/java/com/squareup/okhttp/OkHttpClientTest.java
@@ -32,6 +32,7 @@
 import java.util.Arrays;
 import java.util.List;
 import java.util.Map;
+import java.util.concurrent.TimeUnit;
 import javax.net.SocketFactory;
 import org.junit.After;
 import org.junit.Test;
@@ -56,6 +57,34 @@
     Authenticator.setDefault(DEFAULT_AUTHENTICATOR);
   }
 
+  @Test public void timeoutValidRange() {
+    OkHttpClient client = new OkHttpClient();
+    try {
+      client.setConnectTimeout(1, TimeUnit.NANOSECONDS);
+    } catch (IllegalArgumentException ignored) {
+    }
+    try {
+      client.setWriteTimeout(1, TimeUnit.NANOSECONDS);
+    } catch (IllegalArgumentException ignored) {
+    }
+    try {
+      client.setReadTimeout(1, TimeUnit.NANOSECONDS);
+    } catch (IllegalArgumentException ignored) {
+    }
+    try {
+      client.setConnectTimeout(365, TimeUnit.DAYS);
+    } catch (IllegalArgumentException ignored) {
+    }
+    try {
+      client.setWriteTimeout(365, TimeUnit.DAYS);
+    } catch (IllegalArgumentException ignored) {
+    }
+    try {
+      client.setReadTimeout(365, TimeUnit.DAYS);
+    } catch (IllegalArgumentException ignored) {
+    }
+  }
+
   /** Confirm that {@code copyWithDefaults} gets expected constant values. */
   @Test public void copyWithDefaultsWhenDefaultIsAConstant() throws Exception {
     OkHttpClient client = new OkHttpClient().copyWithDefaults();
diff --git a/okhttp-tests/src/test/java/com/squareup/okhttp/SocksProxyTest.java b/okhttp-tests/src/test/java/com/squareup/okhttp/SocksProxyTest.java
index 234e449d85..9b10213c27 100644
--- a/okhttp-tests/src/test/java/com/squareup/okhttp/SocksProxyTest.java
+++ b/okhttp-tests/src/test/java/com/squareup/okhttp/SocksProxyTest.java
@@ -35,7 +35,7 @@
   private final MockWebServer server = new MockWebServer();
 
   @Before public void setUp() throws Exception {
-    server.play();
+    server.start();
     socksProxy.play();
   }
 
diff --git a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/DiskLruCacheTest.java b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/DiskLruCacheTest.java
index 5a6a76bcec..7326a0da22 100644
--- a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/DiskLruCacheTest.java
+++ b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/DiskLruCacheTest.java
@@ -72,7 +72,9 @@ private void createNewCache() throws IOException {
 
   private void createNewCacheWithSize(int maxSize) throws IOException {
     cache = new DiskLruCache(cacheDir, appVersion, 2, maxSize, executor);
-    cache.initialize();
+    synchronized (cache) {
+      cache.initialize();
+    }
     toClose.add(cache);
   }
 
@@ -156,58 +158,50 @@ private void createNewCacheWithSize(int maxSize) throws IOException {
 
   @Test public void writeAndReadEntry() throws Exception {
     DiskLruCache.Editor creator = cache.edit("k1");
-    creator.set(0, "ABC");
-    creator.set(1, "DE");
-    assertNull(creator.getString(0));
+    setString(creator, 0, "ABC");
+    setString(creator, 1, "DE");
     assertNull(creator.newSource(0));
-    assertNull(creator.getString(1));
     assertNull(creator.newSource(1));
     creator.commit();
 
     DiskLruCache.Snapshot snapshot = cache.get("k1");
-    assertEquals("ABC", snapshot.getString(0));
-    assertEquals(3, snapshot.getLength(0));
-    assertEquals("DE", snapshot.getString(1));
-    assertEquals(2, snapshot.getLength(1));
+    assertSnapshotValue(snapshot, 0, "ABC");
+    assertSnapshotValue(snapshot, 1, "DE");
   }
 
   @Test public void readAndWriteEntryAcrossCacheOpenAndClose() throws Exception {
     DiskLruCache.Editor creator = cache.edit("k1");
-    creator.set(0, "A");
-    creator.set(1, "B");
+    setString(creator, 0, "A");
+    setString(creator, 1, "B");
     creator.commit();
     cache.close();
 
     createNewCache();
     DiskLruCache.Snapshot snapshot = cache.get("k1");
-    assertEquals("A", snapshot.getString(0));
-    assertEquals(1, snapshot.getLength(0));
-    assertEquals("B", snapshot.getString(1));
-    assertEquals(1, snapshot.getLength(1));
+    assertSnapshotValue(snapshot, 0, "A");
+    assertSnapshotValue(snapshot, 1, "B");
     snapshot.close();
   }
 
   @Test public void readAndWriteEntryWithoutProperClose() throws Exception {
     DiskLruCache.Editor creator = cache.edit("k1");
-    creator.set(0, "A");
-    creator.set(1, "B");
+    setString(creator, 0, "A");
+    setString(creator, 1, "B");
     creator.commit();
 
     // Simulate a dirty close of 'cache' by opening the cache directory again.
     createNewCache();
     DiskLruCache.Snapshot snapshot = cache.get("k1");
-    assertEquals("A", snapshot.getString(0));
-    assertEquals(1, snapshot.getLength(0));
-    assertEquals("B", snapshot.getString(1));
-    assertEquals(1, snapshot.getLength(1));
+    assertSnapshotValue(snapshot, 0, "A");
+    assertSnapshotValue(snapshot, 1, "B");
     snapshot.close();
   }
 
   @Test public void journalWithEditAndPublish() throws Exception {
     DiskLruCache.Editor creator = cache.edit("k1");
     assertJournalEquals("DIRTY k1"); // DIRTY must always be flushed.
-    creator.set(0, "AB");
-    creator.set(1, "C");
+    setString(creator, 0, "AB");
+    setString(creator, 1, "C");
     creator.commit();
     cache.close();
     assertJournalEquals("DIRTY k1", "CLEAN k1 2 1");
@@ -216,8 +210,8 @@ private void createNewCacheWithSize(int maxSize) throws IOException {
   @Test public void revertedNewFileIsRemoveInJournal() throws Exception {
     DiskLruCache.Editor creator = cache.edit("k1");
     assertJournalEquals("DIRTY k1"); // DIRTY must always be flushed.
-    creator.set(0, "AB");
-    creator.set(1, "C");
+    setString(creator, 0, "AB");
+    setString(creator, 1, "C");
     creator.abort();
     cache.close();
     assertJournalEquals("DIRTY k1", "REMOVE k1");
@@ -232,8 +226,8 @@ private void createNewCacheWithSize(int maxSize) throws IOException {
   @Test public void journalDoesNotIncludeReadOfYetUnpublishedValue() throws Exception {
     DiskLruCache.Editor creator = cache.edit("k1");
     assertNull(cache.get("k1"));
-    creator.set(0, "A");
-    creator.set(1, "BC");
+    setString(creator, 0, "A");
+    setString(creator, 1, "BC");
     creator.commit();
     cache.close();
     assertJournalEquals("DIRTY k1", "CLEAN k1 1 2");
@@ -241,12 +235,12 @@ private void createNewCacheWithSize(int maxSize) throws IOException {
 
   @Test public void journalWithEditAndPublishAndRead() throws Exception {
     DiskLruCache.Editor k1Creator = cache.edit("k1");
-    k1Creator.set(0, "AB");
-    k1Creator.set(1, "C");
+    setString(k1Creator, 0, "AB");
+    setString(k1Creator, 1, "C");
     k1Creator.commit();
     DiskLruCache.Editor k2Creator = cache.edit("k2");
-    k2Creator.set(0, "DEF");
-    k2Creator.set(1, "G");
+    setString(k2Creator, 0, "DEF");
+    setString(k2Creator, 1, "G");
     k2Creator.commit();
     DiskLruCache.Snapshot k1Snapshot = cache.get("k1");
     k1Snapshot.close();
@@ -256,24 +250,24 @@ private void createNewCacheWithSize(int maxSize) throws IOException {
 
   @Test public void cannotOperateOnEditAfterPublish() throws Exception {
     DiskLruCache.Editor editor = cache.edit("k1");
-    editor.set(0, "A");
-    editor.set(1, "B");
+    setString(editor, 0, "A");
+    setString(editor, 1, "B");
     editor.commit();
     assertInoperable(editor);
   }
 
   @Test public void cannotOperateOnEditAfterRevert() throws Exception {
     DiskLruCache.Editor editor = cache.edit("k1");
-    editor.set(0, "A");
-    editor.set(1, "B");
+    setString(editor, 0, "A");
+    setString(editor, 1, "B");
     editor.abort();
     assertInoperable(editor);
   }
 
   @Test public void explicitRemoveAppliedToDiskImmediately() throws Exception {
     DiskLruCache.Editor editor = cache.edit("k1");
-    editor.set(0, "ABC");
-    editor.set(1, "B");
+    setString(editor, 0, "ABC");
+    setString(editor, 1, "B");
     editor.commit();
     File k1 = getCleanFile("k1", 0);
     assertEquals("ABC", readFile(k1));
@@ -284,9 +278,9 @@ private void createNewCacheWithSize(int maxSize) throws IOException {
   @Test public void removePreventsActiveEditFromStoringAValue() throws Exception {
     set("a", "a", "a");
     DiskLruCache.Editor a = cache.edit("a");
-    a.set(0, "a1");
+    setString(a, 0, "a1");
     assertTrue(cache.remove("a"));
-    a.set(1, "a2");
+    setString(a, 1, "a2");
     a.commit();
     assertAbsent("a");
   }
@@ -297,8 +291,8 @@ private void createNewCacheWithSize(int maxSize) throws IOException {
    */
   @Test public void readAndWriteOverlapsMaintainConsistency() throws Exception {
     DiskLruCache.Editor v1Creator = cache.edit("k1");
-    v1Creator.set(0, "AAaa");
-    v1Creator.set(1, "BBbb");
+    setString(v1Creator, 0, "AAaa");
+    setString(v1Creator, 1, "BBbb");
     v1Creator.commit();
 
     DiskLruCache.Snapshot snapshot1 = cache.get("k1");
@@ -307,21 +301,18 @@ private void createNewCacheWithSize(int maxSize) throws IOException {
     assertEquals('A', inV1.readByte());
 
     DiskLruCache.Editor v1Updater = cache.edit("k1");
-    v1Updater.set(0, "CCcc");
-    v1Updater.set(1, "DDdd");
+    setString(v1Updater, 0, "CCcc");
+    setString(v1Updater, 1, "DDdd");
     v1Updater.commit();
 
     DiskLruCache.Snapshot snapshot2 = cache.get("k1");
-    assertEquals("CCcc", snapshot2.getString(0));
-    assertEquals(4, snapshot2.getLength(0));
-    assertEquals("DDdd", snapshot2.getString(1));
-    assertEquals(4, snapshot2.getLength(1));
+    assertSnapshotValue(snapshot2, 0, "CCcc");
+    assertSnapshotValue(snapshot2, 1, "DDdd");
     snapshot2.close();
 
     assertEquals('a', inV1.readByte());
     assertEquals('a', inV1.readByte());
-    assertEquals("BBbb", snapshot1.getString(1));
-    assertEquals(4, snapshot1.getLength(1));
+    assertSnapshotValue(snapshot1, 1, "BBbb");
     snapshot1.close();
   }
 
@@ -455,7 +446,7 @@ private void createNewCacheWithSize(int maxSize) throws IOException {
 
   @Test public void createNewEntryWithTooFewValuesFails() throws Exception {
     DiskLruCache.Editor creator = cache.edit("k1");
-    creator.set(1, "A");
+    setString(creator, 1, "A");
     try {
       creator.commit();
       fail();
@@ -469,14 +460,14 @@ private void createNewCacheWithSize(int maxSize) throws IOException {
     assertNull(cache.get("k1"));
 
     DiskLruCache.Editor creator2 = cache.edit("k1");
-    creator2.set(0, "B");
-    creator2.set(1, "C");
+    setString(creator2, 0, "B");
+    setString(creator2, 1, "C");
     creator2.commit();
   }
 
   @Test public void revertWithTooFewValues() throws Exception {
     DiskLruCache.Editor creator = cache.edit("k1");
-    creator.set(1, "A");
+    setString(creator, 1, "A");
     creator.abort();
     assertFalse(getCleanFile("k1", 0).exists());
     assertFalse(getCleanFile("k1", 1).exists());
@@ -487,19 +478,17 @@ private void createNewCacheWithSize(int maxSize) throws IOException {
 
   @Test public void updateExistingEntryWithTooFewValuesReusesPreviousValues() throws Exception {
     DiskLruCache.Editor creator = cache.edit("k1");
-    creator.set(0, "A");
-    creator.set(1, "B");
+    setString(creator, 0, "A");
+    setString(creator, 1, "B");
     creator.commit();
 
     DiskLruCache.Editor updater = cache.edit("k1");
-    updater.set(0, "C");
+    setString(updater, 0, "C");
     updater.commit();
 
     DiskLruCache.Snapshot snapshot = cache.get("k1");
-    assertEquals("C", snapshot.getString(0));
-    assertEquals(1, snapshot.getLength(0));
-    assertEquals("B", snapshot.getString(1));
-    assertEquals(1, snapshot.getLength(1));
+    assertSnapshotValue(snapshot, 0, "C");
+    assertSnapshotValue(snapshot, 1, "B");
     snapshot.close();
   }
 
@@ -643,7 +632,7 @@ private void createNewCacheWithSize(int maxSize) throws IOException {
 
   @Test public void constructorDoesNotAllowZeroCacheSize() throws Exception {
     try {
-      DiskLruCache.open(cacheDir, appVersion, 2, 0);
+      DiskLruCache.create(cacheDir, appVersion, 2, 0);
       fail();
     } catch (IllegalArgumentException expected) {
     }
@@ -651,7 +640,7 @@ private void createNewCacheWithSize(int maxSize) throws IOException {
 
   @Test public void constructorDoesNotAllowZeroValuesPerEntry() throws Exception {
     try {
-      DiskLruCache.open(cacheDir, appVersion, 0, 10);
+      DiskLruCache.create(cacheDir, appVersion, 0, 10);
       fail();
     } catch (IllegalArgumentException expected) {
     }
@@ -713,8 +702,8 @@ private void createNewCacheWithSize(int maxSize) throws IOException {
 
   @Test public void restoreBackupFile() throws Exception {
     DiskLruCache.Editor creator = cache.edit("k1");
-    creator.set(0, "ABC");
-    creator.set(1, "DE");
+    setString(creator, 0, "ABC");
+    setString(creator, 1, "DE");
     creator.commit();
     cache.close();
 
@@ -724,10 +713,8 @@ private void createNewCacheWithSize(int maxSize) throws IOException {
     createNewCache();
 
     DiskLruCache.Snapshot snapshot = cache.get("k1");
-    assertEquals("ABC", snapshot.getString(0));
-    assertEquals(3, snapshot.getLength(0));
-    assertEquals("DE", snapshot.getString(1));
-    assertEquals(2, snapshot.getLength(1));
+    assertSnapshotValue(snapshot, 0, "ABC");
+    assertSnapshotValue(snapshot, 1, "DE");
 
     assertFalse(journalBkpFile.exists());
     assertTrue(journalFile.exists());
@@ -735,16 +722,16 @@ private void createNewCacheWithSize(int maxSize) throws IOException {
 
   @Test public void journalFileIsPreferredOverBackupFile() throws Exception {
     DiskLruCache.Editor creator = cache.edit("k1");
-    creator.set(0, "ABC");
-    creator.set(1, "DE");
+    setString(creator, 0, "ABC");
+    setString(creator, 1, "DE");
     creator.commit();
     cache.flush();
 
     copyFile(journalFile, journalBkpFile);
 
     creator = cache.edit("k2");
-    creator.set(0, "F");
-    creator.set(1, "GH");
+    setString(creator, 0, "F");
+    setString(creator, 1, "GH");
     creator.commit();
     cache.close();
 
@@ -754,16 +741,12 @@ private void createNewCacheWithSize(int maxSize) throws IOException {
     createNewCache();
 
     DiskLruCache.Snapshot snapshotA = cache.get("k1");
-    assertEquals("ABC", snapshotA.getString(0));
-    assertEquals(3, snapshotA.getLength(0));
-    assertEquals("DE", snapshotA.getString(1));
-    assertEquals(2, snapshotA.getLength(1));
+    assertSnapshotValue(snapshotA, 0, "ABC");
+    assertSnapshotValue(snapshotA, 1, "DE");
 
     DiskLruCache.Snapshot snapshotB = cache.get("k2");
-    assertEquals("F", snapshotB.getString(0));
-    assertEquals(1, snapshotB.getLength(0));
-    assertEquals("GH", snapshotB.getString(1));
-    assertEquals(2, snapshotB.getLength(1));
+    assertSnapshotValue(snapshotB, 0, "F");
+    assertSnapshotValue(snapshotB, 1, "GH");
 
     assertFalse(journalBkpFile.exists());
     assertTrue(journalFile.exists());
@@ -772,7 +755,7 @@ private void createNewCacheWithSize(int maxSize) throws IOException {
   @Test public void openCreatesDirectoryIfNecessary() throws Exception {
     cache.close();
     File dir = tempDir.newFolder("testOpenCreatesDirectoryIfNecessary");
-    cache = DiskLruCache.open(dir, appVersion, 2, Integer.MAX_VALUE);
+    cache = DiskLruCache.create(dir, appVersion, 2, Integer.MAX_VALUE);
     set("a", "a", "a");
     assertTrue(new File(dir, "a.0").exists());
     assertTrue(new File(dir, "a.1").exists());
@@ -789,7 +772,7 @@ private void createNewCacheWithSize(int maxSize) throws IOException {
     set("a", "a", "a");
     DiskLruCache.Snapshot snapshot = cache.get("a");
     DiskLruCache.Editor editor = snapshot.edit();
-    editor.set(1, "a2");
+    setString(editor, 1, "a2");
     editor.commit();
     assertValue("a", "a", "a2");
   }
@@ -798,10 +781,10 @@ private void createNewCacheWithSize(int maxSize) throws IOException {
     set("a", "a", "a");
     DiskLruCache.Snapshot snapshot = cache.get("a");
     DiskLruCache.Editor toAbort = snapshot.edit();
-    toAbort.set(0, "b");
+    setString(toAbort, 0, "b");
     toAbort.abort();
     DiskLruCache.Editor editor = snapshot.edit();
-    editor.set(1, "a2");
+    setString(editor, 1, "a2");
     editor.commit();
     assertValue("a", "a", "a2");
   }
@@ -810,7 +793,7 @@ private void createNewCacheWithSize(int maxSize) throws IOException {
     set("a", "a", "a");
     DiskLruCache.Snapshot snapshot = cache.get("a");
     DiskLruCache.Editor toAbort = snapshot.edit();
-    toAbort.set(0, "b");
+    setString(toAbort, 0, "b");
     toAbort.commit();
     assertNull(snapshot.edit());
   }
@@ -850,7 +833,7 @@ private void createNewCacheWithSize(int maxSize) throws IOException {
     set("a", "a", "a");
     DiskLruCache.Editor a = cache.get("a").edit();
     tempDir.delete();
-    a.set(1, "a2");
+    setString(a, 1, "a2");
     a.commit();
   }
 
@@ -865,9 +848,9 @@ private void createNewCacheWithSize(int maxSize) throws IOException {
     set("a", "a", "a");
     set("b", "b", "b");
     DiskLruCache.Editor a = cache.get("a").edit();
-    a.set(0, "a1");
+    setString(a, 0, "a1");
     tempDir.delete();
-    a.set(1, "a2");
+    setString(a, 1, "a2");
     a.commit();
     assertNull(cache.get("a"));
   }
@@ -886,7 +869,7 @@ private void createNewCacheWithSize(int maxSize) throws IOException {
   @Test public void trimToSizeWithActiveEdit() throws Exception {
     set("a", "a1234", "a1234");
     DiskLruCache.Editor a = cache.edit("a");
-    a.set(0, "a123");
+    setString(a, 0, "a123");
 
     cache.setMaxSize(8); // Smaller than the sum of active edits!
     cache.flush(); // Force trimToSize().
@@ -894,7 +877,7 @@ private void createNewCacheWithSize(int maxSize) throws IOException {
     assertNull(cache.get("a"));
 
     // After the edit is completed, its entry is still gone.
-    a.set(1, "a1");
+    setString(a, 1, "a1");
     a.commit();
     assertAbsent("a");
     assertEquals(0, cache.size());
@@ -911,8 +894,8 @@ private void createNewCacheWithSize(int maxSize) throws IOException {
 
   @Test public void evictAllWithPartialCreate() throws Exception {
     DiskLruCache.Editor a = cache.edit("a");
-    a.set(0, "a1");
-    a.set(1, "a2");
+    setString(a, 0, "a1");
+    setString(a, 1, "a2");
     cache.evictAll();
     assertEquals(0, cache.size());
     a.commit();
@@ -922,8 +905,8 @@ private void createNewCacheWithSize(int maxSize) throws IOException {
   @Test public void evictAllWithPartialEditDoesNotStoreAValue() throws Exception {
     set("a", "a", "a");
     DiskLruCache.Editor a = cache.edit("a");
-    a.set(0, "a1");
-    a.set(1, "a2");
+    setString(a, 0, "a1");
+    setString(a, 1, "a2");
     cache.evictAll();
     assertEquals(0, cache.size());
     a.commit();
@@ -933,11 +916,11 @@ private void createNewCacheWithSize(int maxSize) throws IOException {
   @Test public void evictAllDoesntInterruptPartialRead() throws Exception {
     set("a", "a", "a");
     DiskLruCache.Snapshot a = cache.get("a");
-    assertEquals("a", a.getString(0));
+    assertSnapshotValue(a, 0, "a");
     cache.evictAll();
     assertEquals(0, cache.size());
     assertAbsent("a");
-    assertEquals("a", a.getString(1));
+    assertSnapshotValue(a, 1, "a");
     a.close();
   }
 
@@ -960,22 +943,22 @@ private void createNewCacheWithSize(int maxSize) throws IOException {
     assertTrue(iterator.hasNext());
     DiskLruCache.Snapshot a = iterator.next();
     assertEquals("a", a.key());
-    assertEquals("a1", a.getString(0));
-    assertEquals("a2", a.getString(1));
+    assertSnapshotValue(a, 0, "a1");
+    assertSnapshotValue(a, 1, "a2");
     a.close();
 
     assertTrue(iterator.hasNext());
     DiskLruCache.Snapshot b = iterator.next();
     assertEquals("b", b.key());
-    assertEquals("b1", b.getString(0));
-    assertEquals("b2", b.getString(1));
+    assertSnapshotValue(b, 0, "b1");
+    assertSnapshotValue(b, 1, "b2");
     b.close();
 
     assertTrue(iterator.hasNext());
     DiskLruCache.Snapshot c = iterator.next();
     assertEquals("c", c.key());
-    assertEquals("c1", c.getString(0));
-    assertEquals("c2", c.getString(1));
+    assertSnapshotValue(c, 0, "c1");
+    assertSnapshotValue(c, 1, "c2");
     c.close();
 
     assertFalse(iterator.hasNext());
@@ -1017,8 +1000,8 @@ private void createNewCacheWithSize(int maxSize) throws IOException {
 
     DiskLruCache.Snapshot b = iterator.next();
     assertEquals("b", b.key());
-    assertEquals("b3", b.getString(0));
-    assertEquals("b4", b.getString(1));
+    assertSnapshotValue(b, 0, "b3");
+    assertSnapshotValue(b, 1, "b4");
     b.close();
   }
 
@@ -1079,6 +1062,16 @@ private void createNewCacheWithSize(int maxSize) throws IOException {
     assertFalse(iterator.hasNext());
   }
 
+  @Test public void isClosed_uninitializedCache() throws Exception {
+    // Create an uninitialized cache.
+    cache = new DiskLruCache(cacheDir, appVersion, 2, Integer.MAX_VALUE, executor);
+    toClose.add(cache);
+
+    assertFalse(cache.isClosed());
+    cache.close();
+    assertTrue(cache.isClosed());
+  }
+
   private void assertJournalEquals(String... expectedBodyLines) throws Exception {
     List<String> expectedLines = new ArrayList<>();
     expectedLines.add(MAGIC);
@@ -1148,12 +1141,7 @@ public static void writeFile(File file, String content) throws Exception {
 
   private static void assertInoperable(DiskLruCache.Editor editor) throws Exception {
     try {
-      editor.getString(0);
-      fail();
-    } catch (IllegalStateException expected) {
-    }
-    try {
-      editor.set(0, "A");
+      setString(editor, 0, "A");
       fail();
     } catch (IllegalStateException expected) {
     }
@@ -1204,11 +1192,17 @@ private void assertGarbageFilesAllDeleted() throws Exception {
 
   private void set(String key, String value0, String value1) throws Exception {
     DiskLruCache.Editor editor = cache.edit(key);
-    editor.set(0, value0);
-    editor.set(1, value1);
+    setString(editor, 0, value0);
+    setString(editor, 1, value1);
     editor.commit();
   }
 
+  public static void setString(DiskLruCache.Editor editor, int index, String value) throws IOException {
+    BufferedSink writer = Okio.buffer(editor.newSink(index));
+    writer.writeUtf8(value);
+    writer.close();
+  }
+
   private void assertAbsent(String key) throws Exception {
     DiskLruCache.Snapshot snapshot = cache.get(key);
     if (snapshot != null) {
@@ -1223,15 +1217,23 @@ private void assertAbsent(String key) throws Exception {
 
   private void assertValue(String key, String value0, String value1) throws Exception {
     DiskLruCache.Snapshot snapshot = cache.get(key);
-    assertEquals(value0, snapshot.getString(0));
-    assertEquals(value0.length(), snapshot.getLength(0));
-    assertEquals(value1, snapshot.getString(1));
-    assertEquals(value1.length(), snapshot.getLength(1));
+    assertSnapshotValue(snapshot, 0, value0);
+    assertSnapshotValue(snapshot, 1, value1);
     assertTrue(getCleanFile(key, 0).exists());
     assertTrue(getCleanFile(key, 1).exists());
     snapshot.close();
   }
 
+  private void assertSnapshotValue(DiskLruCache.Snapshot snapshot, int index, String value)
+      throws IOException {
+    assertEquals(value, sourceAsString(snapshot.getSource(index)));
+    assertEquals(value.length(), snapshot.getLength(index));
+  }
+
+  private String sourceAsString(Source source) throws IOException {
+    return source != null ? Okio.buffer(source).readUtf8() : null;
+  }
+
   private void copyFile(File from, File to) throws IOException {
     Source source = Okio.source(from);
     BufferedSink sink = Okio.buffer(Okio.sink(to));
diff --git a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/CookiesTest.java b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/CookiesTest.java
index a738cde082..d0fa1b2421 100644
--- a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/CookiesTest.java
+++ b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/CookiesTest.java
@@ -40,6 +40,7 @@
 import static java.net.CookiePolicy.ACCEPT_ORIGINAL_SERVER;
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertNull;
 import static org.junit.Assert.assertTrue;
 import static org.junit.Assert.fail;
 
@@ -63,7 +64,7 @@ public void testNetscapeResponse() throws Exception {
     CookieManager cookieManager = new CookieManager(null, ACCEPT_ORIGINAL_SERVER);
     CookieHandler.setDefault(cookieManager);
     MockWebServer server = new MockWebServer();
-    server.play();
+    server.start();
 
     server.enqueue(new MockResponse().addHeader("Set-Cookie: a=android; "
         + "expires=Fri, 31-Dec-9999 23:59:59 GMT; "
@@ -91,7 +92,7 @@ public void testNetscapeResponse() throws Exception {
     CookieManager cookieManager = new CookieManager(null, ACCEPT_ORIGINAL_SERVER);
     CookieHandler.setDefault(cookieManager);
     MockWebServer server = new MockWebServer();
-    server.play();
+    server.start();
 
     server.enqueue(new MockResponse().addHeader("Set-Cookie: a=android; "
         + "Comment=this cookie is delicious; "
@@ -121,7 +122,7 @@ public void testNetscapeResponse() throws Exception {
     CookieManager cookieManager = new CookieManager(null, ACCEPT_ORIGINAL_SERVER);
     CookieHandler.setDefault(cookieManager);
     MockWebServer server = new MockWebServer();
-    server.play();
+    server.start();
 
     server.enqueue(new MockResponse().addHeader("Set-Cookie2: a=android; "
         + "Comment=this cookie is delicious; "
@@ -155,7 +156,7 @@ public void testNetscapeResponse() throws Exception {
     CookieManager cookieManager = new CookieManager(null, ACCEPT_ORIGINAL_SERVER);
     CookieHandler.setDefault(cookieManager);
     MockWebServer server = new MockWebServer();
-    server.play();
+    server.start();
 
     server.enqueue(new MockResponse().addHeader("Set-Cookie2: a=\"android\"; "
         + "Comment=\"this cookie is delicious\"; "
@@ -188,7 +189,7 @@ public void testNetscapeResponse() throws Exception {
   @Test public void testSendingCookiesFromStore() throws Exception {
     MockWebServer server = new MockWebServer();
     server.enqueue(new MockResponse());
-    server.play();
+    server.start();
 
     CookieManager cookieManager = new CookieManager(null, ACCEPT_ORIGINAL_SERVER);
     HttpCookie cookieA = new HttpCookie("a", "android");
@@ -204,22 +205,25 @@ public void testNetscapeResponse() throws Exception {
     get(server, "/");
     RecordedRequest request = server.takeRequest();
 
-    List<String> receivedHeaders = request.getHeaders();
-    assertContains(receivedHeaders, "Cookie: $Version=\"1\"; "
-        + "a=\"android\";$Path=\"/\";$Domain=\"" + server.getCookieDomain() + "\"; "
-        + "b=\"banana\";$Path=\"/\";$Domain=\"" + server.getCookieDomain() + "\"");
+    assertEquals("$Version=\"1\"; "
+            + "a=\"android\";$Path=\"/\";$Domain=\""
+            + server.getCookieDomain()
+            + "\"; "
+            + "b=\"banana\";$Path=\"/\";$Domain=\""
+            + server.getCookieDomain()
+            + "\"", request.getHeader("Cookie"));
   }
 
   @Test public void testRedirectsDoNotIncludeTooManyCookies() throws Exception {
     MockWebServer redirectTarget = new MockWebServer();
     redirectTarget.enqueue(new MockResponse().setBody("A"));
-    redirectTarget.play();
+    redirectTarget.start();
 
     MockWebServer redirectSource = new MockWebServer();
     redirectSource.enqueue(new MockResponse()
         .setResponseCode(HttpURLConnection.HTTP_MOVED_TEMP)
         .addHeader("Location: " + redirectTarget.getUrl("/")));
-    redirectSource.play();
+    redirectSource.start();
 
     CookieManager cookieManager = new CookieManager(null, ACCEPT_ORIGINAL_SERVER);
     HttpCookie cookie = new HttpCookie("c", "cookie");
@@ -233,11 +237,14 @@ public void testNetscapeResponse() throws Exception {
     get(redirectSource, "/");
     RecordedRequest request = redirectSource.takeRequest();
 
-    assertContains(request.getHeaders(), "Cookie: $Version=\"1\"; "
-        + "c=\"cookie\";$Path=\"/\";$Domain=\"" + redirectSource.getCookieDomain()
-        + "\";$Port=\"" + portList + "\"");
+    assertEquals("$Version=\"1\"; "
+            + "c=\"cookie\";$Path=\"/\";$Domain=\""
+            + redirectSource.getCookieDomain()
+            + "\";$Port=\""
+            + portList
+            + "\"", request.getHeader("Cookie"));
 
-    for (String header : redirectTarget.takeRequest().getHeaders()) {
+    for (String header : redirectTarget.takeRequest().getHeaders().names()) {
       if (header.startsWith("Cookie")) {
         fail(header);
       }
@@ -267,7 +274,7 @@ public void testNetscapeResponse() throws Exception {
     });
     MockWebServer server = new MockWebServer();
     server.enqueue(new MockResponse());
-    server.play();
+    server.start();
 
     HttpURLConnection connection = new OkUrlFactory(client).open(server.getUrl("/"));
     assertEquals(Collections.<String, List<String>>emptyMap(),
@@ -300,8 +307,10 @@ public void testNetscapeResponse() throws Exception {
     } catch (IllegalStateException expected) {
     }
 
-    assertContainsAll(request.getHeaders(), "Foo: foo", "Cookie: Bar=bar", "Cookie2: Baz=baz");
-    assertFalse(request.getHeaders().contains("Quux: quux"));
+    assertEquals("foo", request.getHeader("Foo"));
+    assertEquals("Bar=bar", request.getHeader("Cookie"));
+    assertEquals("Baz=baz", request.getHeader("Cookie2"));
+    assertNull(request.getHeader("Quux"));
   }
 
   @Test public void testCookiesSentIgnoresCase() throws Exception {
@@ -316,13 +325,14 @@ public void testNetscapeResponse() throws Exception {
     });
     MockWebServer server = new MockWebServer();
     server. enqueue(new MockResponse());
-    server.play();
+    server.start();
 
     get(server, "/");
 
     RecordedRequest request = server.takeRequest();
-    assertContainsAll(request.getHeaders(), "COOKIE: Bar=bar", "cooKIE2: Baz=baz");
-    assertFalse(request.getHeaders().contains("Quux: quux"));
+    assertEquals("Bar=bar", request.getHeader("Cookie"));
+    assertEquals("Baz=baz", request.getHeader("Cookie2"));
+    assertNull(request.getHeader("Quux"));
   }
 
   private void assertContains(Collection<String> collection, String element) {
diff --git a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/DisconnectTest.java b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/DisconnectTest.java
index eee41bbd94..7a70d03e34 100644
--- a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/DisconnectTest.java
+++ b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/DisconnectTest.java
@@ -29,6 +29,7 @@
 import java.net.Socket;
 import java.util.concurrent.TimeUnit;
 
+import okio.Buffer;
 import org.junit.Before;
 import org.junit.Test;
 
@@ -72,7 +73,7 @@ protected void configureSocket(Socket socket) throws IOException {
 
     server.enqueue(new MockResponse()
         .throttleBody(64 * 1024, 125, TimeUnit.MILLISECONDS)); // 500 Kbps
-    server.play();
+    server.start();
 
     HttpURLConnection connection = new OkUrlFactory(client).open(server.getUrl("/"));
     disconnectLater(connection, 500);
@@ -97,9 +98,9 @@ protected void configureSocket(Socket socket) throws IOException {
     int responseBodySize = 2 * 1024 * 1024; // 2 MiB
 
     server.enqueue(new MockResponse()
-        .setBody(new byte[responseBodySize])
+        .setBody(new Buffer().write(new byte[responseBodySize]))
         .throttleBody(64 * 1024, 125, TimeUnit.MILLISECONDS)); // 500 Kbps
-    server.play();
+    server.start();
 
     HttpURLConnection connection = new OkUrlFactory(client).open(server.getUrl("/"));
     disconnectLater(connection, 500);
diff --git a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/HeadersTest.java b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/HeadersTest.java
index eef731b0a4..1d946228ae 100644
--- a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/HeadersTest.java
+++ b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/HeadersTest.java
@@ -22,7 +22,11 @@
 import com.squareup.okhttp.internal.spdy.Header;
 import java.io.IOException;
 import java.util.Arrays;
+import java.util.Collections;
+import java.util.HashMap;
 import java.util.List;
+import java.util.Map;
+
 import org.junit.Test;
 
 import static com.squareup.okhttp.TestUtil.headerEntries;
@@ -234,4 +238,68 @@
     } catch (IllegalArgumentException expected) {
     }
   }
+
+  @Test public void ofMapThrowsOnNull() {
+    try {
+      Headers.of(Collections.<String, String>singletonMap("User-Agent", null));
+      fail();
+    } catch (IllegalArgumentException expected) {
+    }
+  }
+
+  @Test public void ofMapThrowsOnEmptyName() {
+    try {
+      Headers.of(Collections.singletonMap("", "OkHttp"));
+      fail();
+    } catch (IllegalArgumentException expected) {
+    }
+  }
+
+  @Test public void ofMapThrowsOnBlankName() {
+    try {
+      Headers.of(Collections.singletonMap(" ", "OkHttp"));
+      fail();
+    } catch (IllegalArgumentException expected) {
+    }
+  }
+
+  @Test public void ofMapAcceptsEmptyValue() {
+    Headers headers = Headers.of(Collections.singletonMap("User-Agent", ""));
+    assertEquals("", headers.value(0));
+  }
+
+  @Test public void ofMapTrimsKey() {
+    Headers headers = Headers.of(Collections.singletonMap(" User-Agent ", "OkHttp"));
+    assertEquals("User-Agent", headers.name(0));
+  }
+
+  @Test public void ofMapTrimsValue() {
+    Headers headers = Headers.of(Collections.singletonMap("User-Agent", " OkHttp "));
+    assertEquals("OkHttp", headers.value(0));
+  }
+
+  @Test public void ofMapMakesDefensiveCopy() {
+    Map<String, String> namesAndValues = new HashMap<>();
+    namesAndValues.put("User-Agent", "OkHttp");
+
+    Headers headers = Headers.of(namesAndValues);
+    namesAndValues.put("User-Agent", "Chrome");
+    assertEquals("OkHttp", headers.value(0));
+  }
+
+  @Test public void ofMapRejectsNulCharInName() {
+    try {
+      Headers.of(Collections.singletonMap("User-Agent", "Square\u0000OkHttp"));
+      fail();
+    } catch (IllegalArgumentException expected) {
+    }
+  }
+
+  @Test public void ofMapRejectsNulCharInValue() {
+    try {
+      Headers.of(Collections.singletonMap("User-\u0000Agent", "OkHttp"));
+      fail();
+    } catch (IllegalArgumentException expected) {
+    }
+  }
 }
diff --git a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/HttpOverHttp20Draft16Test.java b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/HttpOverHttp20Draft16Test.java
index 6ebe415f82..7659110e9c 100644
--- a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/HttpOverHttp20Draft16Test.java
+++ b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/HttpOverHttp20Draft16Test.java
@@ -15,11 +15,11 @@
  */
 package com.squareup.okhttp.internal.http;
 
+import com.squareup.okhttp.Headers;
 import com.squareup.okhttp.Protocol;
 import com.squareup.okhttp.mockwebserver.MockResponse;
 import com.squareup.okhttp.mockwebserver.PushPromise;
 import com.squareup.okhttp.mockwebserver.RecordedRequest;
-import java.util.Arrays;
 import org.junit.Test;
 
 import static org.junit.Assert.assertEquals;
@@ -32,11 +32,13 @@ public HttpOverHttp20Draft16Test() {
   }
 
   @Test public void serverSendsPushPromise_GET() throws Exception {
-    MockResponse response = new MockResponse().setBody("ABCDE").setStatus("HTTP/1.1 200 Sweet")
-        .withPush(new PushPromise("GET", "/foo/bar", Arrays.asList("foo: bar"),
-            new MockResponse().setBody("bar").setStatus("HTTP/1.1 200 Sweet")));
+    PushPromise pushPromise = new PushPromise("GET", "/foo/bar", Headers.of("foo", "bar"),
+        new MockResponse().setBody("bar").setStatus("HTTP/1.1 200 Sweet"));
+    MockResponse response = new MockResponse()
+        .setBody("ABCDE")
+        .setStatus("HTTP/1.1 200 Sweet")
+        .withPush(pushPromise);
     server.enqueue(response);
-    server.play();
 
     connection = client.open(server.getUrl("/foo"));
     assertContent("ABCDE", connection, Integer.MAX_VALUE);
@@ -45,21 +47,22 @@ public HttpOverHttp20Draft16Test() {
 
     RecordedRequest request = server.takeRequest();
     assertEquals("GET /foo HTTP/1.1", request.getRequestLine());
-    assertContains(request.getHeaders(), ":scheme: https");
-    assertContains(request.getHeaders(), hostHeader + ": "
-        + server.getHostName() + ":" + server.getPort());
+    assertEquals("https", request.getHeader(":scheme"));
+    assertEquals(server.getHostName() + ":" + server.getPort(), request.getHeader(hostHeader));
 
     RecordedRequest pushedRequest = server.takeRequest();
     assertEquals("GET /foo/bar HTTP/1.1", pushedRequest.getRequestLine());
-    assertEquals(Arrays.asList("foo: bar"), pushedRequest.getHeaders());
+    assertEquals("bar", pushedRequest.getHeader("foo"));
   }
 
   @Test public void serverSendsPushPromise_HEAD() throws Exception {
-    MockResponse response = new MockResponse().setBody("ABCDE").setStatus("HTTP/1.1 200 Sweet")
-        .withPush(new PushPromise("HEAD", "/foo/bar", Arrays.asList("foo: bar"),
-            new MockResponse().setStatus("HTTP/1.1 204 Sweet")));
+    PushPromise pushPromise = new PushPromise("HEAD", "/foo/bar", Headers.of("foo", "bar"),
+        new MockResponse().setStatus("HTTP/1.1 204 Sweet"));
+    MockResponse response = new MockResponse()
+        .setBody("ABCDE")
+        .setStatus("HTTP/1.1 200 Sweet")
+        .withPush(pushPromise);
     server.enqueue(response);
-    server.play();
 
     connection = client.open(server.getUrl("/foo"));
     assertContent("ABCDE", connection, Integer.MAX_VALUE);
@@ -68,12 +71,11 @@ public HttpOverHttp20Draft16Test() {
 
     RecordedRequest request = server.takeRequest();
     assertEquals("GET /foo HTTP/1.1", request.getRequestLine());
-    assertContains(request.getHeaders(), ":scheme: https");
-    assertContains(request.getHeaders(), hostHeader + ": "
-        + server.getHostName() + ":" + server.getPort());
+    assertEquals("https", request.getHeader(":scheme"));
+    assertEquals(server.getHostName() + ":" + server.getPort(), request.getHeader(hostHeader));
 
     RecordedRequest pushedRequest = server.takeRequest();
     assertEquals("HEAD /foo/bar HTTP/1.1", pushedRequest.getRequestLine());
-    assertEquals(Arrays.asList("foo: bar"), pushedRequest.getHeaders());
+    assertEquals("bar", pushedRequest.getHeader("foo"));
   }
 }
diff --git a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/HttpOverSpdyTest.java b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/HttpOverSpdyTest.java
index 670361c603..ab8f3c97cc 100644
--- a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/HttpOverSpdyTest.java
+++ b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/HttpOverSpdyTest.java
@@ -24,10 +24,9 @@
 import com.squareup.okhttp.internal.SslContextBuilder;
 import com.squareup.okhttp.internal.Util;
 import com.squareup.okhttp.mockwebserver.MockResponse;
-import com.squareup.okhttp.mockwebserver.MockWebServer;
 import com.squareup.okhttp.mockwebserver.RecordedRequest;
 import com.squareup.okhttp.mockwebserver.SocketPolicy;
-import java.io.File;
+import com.squareup.okhttp.mockwebserver.rule.MockWebServerRule;
 import java.io.IOException;
 import java.io.InputStream;
 import java.net.Authenticator;
@@ -35,14 +34,13 @@
 import java.net.HttpURLConnection;
 import java.net.URL;
 import java.util.Arrays;
-import java.util.Collection;
 import java.util.Collections;
 import java.util.List;
 import java.util.Map;
-import java.util.UUID;
 import java.util.concurrent.CountDownLatch;
 import java.util.concurrent.ExecutorService;
 import java.util.concurrent.Executors;
+import java.util.concurrent.TimeUnit;
 import javax.net.ssl.HostnameVerifier;
 import javax.net.ssl.SSLContext;
 import javax.net.ssl.SSLSession;
@@ -53,25 +51,19 @@
 import org.junit.After;
 import org.junit.Before;
 import org.junit.Ignore;
+import org.junit.Rule;
 import org.junit.Test;
+import org.junit.rules.TemporaryFolder;
 
 import static java.util.concurrent.TimeUnit.SECONDS;
 import static org.junit.Assert.assertArrayEquals;
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertNull;
-import static org.junit.Assert.assertTrue;
 import static org.junit.Assert.fail;
 
 /** Test how SPDY interacts with HTTP features. */
 public abstract class HttpOverSpdyTest {
-
-  /** Protocol to test, for example {@link com.squareup.okhttp.Protocol#SPDY_3} */
-  private final Protocol protocol;
-  protected String hostHeader = ":host";
-
-  protected HttpOverSpdyTest(Protocol protocol){
-    this.protocol = protocol;
-  }
+  private static final SSLContext sslContext = SslContextBuilder.localhost();
 
   private static final HostnameVerifier NULL_HOSTNAME_VERIFIER = new HostnameVerifier() {
     public boolean verify(String hostname, SSLSession session) {
@@ -79,31 +71,36 @@ public boolean verify(String hostname, SSLSession session) {
     }
   };
 
-  private static final SSLContext sslContext = SslContextBuilder.localhost();
-  protected final MockWebServer server = new MockWebServer();
+  @Rule public final TemporaryFolder tempDir = new TemporaryFolder();
+  @Rule public final MockWebServerRule server = new MockWebServerRule();
+
+  /** Protocol to test, for example {@link com.squareup.okhttp.Protocol#SPDY_3} */
+  private final Protocol protocol;
+  protected String hostHeader = ":host";
+
   protected final OkUrlFactory client = new OkUrlFactory(new OkHttpClient());
   protected HttpURLConnection connection;
   protected Cache cache;
 
+  protected HttpOverSpdyTest(Protocol protocol){
+    this.protocol = protocol;
+  }
+
   @Before public void setUp() throws Exception {
-    server.useHttps(sslContext.getSocketFactory(), false);
+    server.get().useHttps(sslContext.getSocketFactory(), false);
     client.client().setProtocols(Arrays.asList(protocol, Protocol.HTTP_1_1));
     client.client().setSslSocketFactory(sslContext.getSocketFactory());
     client.client().setHostnameVerifier(NULL_HOSTNAME_VERIFIER);
-    String systemTmpDir = System.getProperty("java.io.tmpdir");
-    File cacheDir = new File(systemTmpDir, "HttpCache-" + protocol + "-" + UUID.randomUUID());
-    cache = new Cache(cacheDir, Integer.MAX_VALUE);
+    cache = new Cache(tempDir.getRoot(), Integer.MAX_VALUE);
   }
 
   @After public void tearDown() throws Exception {
     Authenticator.setDefault(null);
-    server.shutdown();
   }
 
   @Test public void get() throws Exception {
     MockResponse response = new MockResponse().setBody("ABCDE").setStatus("HTTP/1.1 200 Sweet");
     server.enqueue(response);
-    server.play();
 
     connection = client.open(server.getUrl("/foo"));
     assertContent("ABCDE", connection, Integer.MAX_VALUE);
@@ -112,14 +109,12 @@ public boolean verify(String hostname, SSLSession session) {
 
     RecordedRequest request = server.takeRequest();
     assertEquals("GET /foo HTTP/1.1", request.getRequestLine());
-    assertContains(request.getHeaders(), ":scheme: https");
-    assertContains(request.getHeaders(), hostHeader + ": "
-        + server.getHostName() + ":" + server.getPort());
+    assertEquals("https", request.getHeader(":scheme"));
+    assertEquals(server.getHostName() + ":" + server.getPort(), request.getHeader(hostHeader));
   }
 
   @Test public void emptyResponse() throws IOException {
     server.enqueue(new MockResponse());
-    server.play();
 
     connection = client.open(server.getUrl("/foo"));
     assertEquals(-1, connection.getInputStream().read());
@@ -128,9 +123,7 @@ public boolean verify(String hostname, SSLSession session) {
   byte[] postBytes = "FGHIJ".getBytes(Util.UTF_8);
 
   @Test public void noDefaultContentLengthOnStreamingPost() throws Exception {
-    MockResponse response = new MockResponse().setBody("ABCDE");
-    server.enqueue(response);
-    server.play();
+    server.enqueue(new MockResponse().setBody("ABCDE"));
 
     connection = client.open(server.getUrl("/foo"));
     connection.setDoOutput(true);
@@ -140,14 +133,12 @@ public boolean verify(String hostname, SSLSession session) {
 
     RecordedRequest request = server.takeRequest();
     assertEquals("POST /foo HTTP/1.1", request.getRequestLine());
-    assertArrayEquals(postBytes, request.getBody());
+    assertArrayEquals(postBytes, request.getBody().readByteArray());
     assertNull(request.getHeader("Content-Length"));
   }
 
   @Test public void userSuppliedContentLengthHeader() throws Exception {
-    MockResponse response = new MockResponse().setBody("ABCDE");
-    server.enqueue(response);
-    server.play();
+    server.enqueue(new MockResponse().setBody("ABCDE"));
 
     connection = client.open(server.getUrl("/foo"));
     connection.setRequestProperty("Content-Length", String.valueOf(postBytes.length));
@@ -157,14 +148,12 @@ public boolean verify(String hostname, SSLSession session) {
 
     RecordedRequest request = server.takeRequest();
     assertEquals("POST /foo HTTP/1.1", request.getRequestLine());
-    assertArrayEquals(postBytes, request.getBody());
+    assertArrayEquals(postBytes, request.getBody().readByteArray());
     assertEquals(postBytes.length, Integer.parseInt(request.getHeader("Content-Length")));
   }
 
   @Test public void closeAfterFlush() throws Exception {
-    MockResponse response = new MockResponse().setBody("ABCDE");
-    server.enqueue(response);
-    server.play();
+    server.enqueue(new MockResponse().setBody("ABCDE"));
 
     connection = client.open(server.getUrl("/foo"));
     connection.setRequestProperty("Content-Length", String.valueOf(postBytes.length));
@@ -176,14 +165,12 @@ public boolean verify(String hostname, SSLSession session) {
 
     RecordedRequest request = server.takeRequest();
     assertEquals("POST /foo HTTP/1.1", request.getRequestLine());
-    assertArrayEquals(postBytes, request.getBody());
+    assertArrayEquals(postBytes, request.getBody().readByteArray());
     assertEquals(postBytes.length, Integer.parseInt(request.getHeader("Content-Length")));
   }
 
   @Test public void setFixedLengthStreamingModeSetsContentLength() throws Exception {
-    MockResponse response = new MockResponse().setBody("ABCDE");
-    server.enqueue(response);
-    server.play();
+    server.enqueue(new MockResponse().setBody("ABCDE"));
 
     connection = client.open(server.getUrl("/foo"));
     connection.setFixedLengthStreamingMode(postBytes.length);
@@ -193,14 +180,13 @@ public boolean verify(String hostname, SSLSession session) {
 
     RecordedRequest request = server.takeRequest();
     assertEquals("POST /foo HTTP/1.1", request.getRequestLine());
-    assertArrayEquals(postBytes, request.getBody());
+    assertArrayEquals(postBytes, request.getBody().readByteArray());
     assertEquals(postBytes.length, Integer.parseInt(request.getHeader("Content-Length")));
   }
 
   @Test public void spdyConnectionReuse() throws Exception {
     server.enqueue(new MockResponse().setBody("ABCDEF"));
     server.enqueue(new MockResponse().setBody("GHIJKL"));
-    server.play();
 
     HttpURLConnection connection1 = client.open(server.getUrl("/r1"));
     HttpURLConnection connection2 = client.open(server.getUrl("/r2"));
@@ -215,7 +201,6 @@ public boolean verify(String hostname, SSLSession session) {
   @Test @Ignore public void synchronousSpdyRequest() throws Exception {
     server.enqueue(new MockResponse().setBody("A"));
     server.enqueue(new MockResponse().setBody("A"));
-    server.play();
 
     ExecutorService executor = Executors.newCachedThreadPool();
     CountDownLatch countDownLatch = new CountDownLatch(2);
@@ -227,10 +212,8 @@ public boolean verify(String hostname, SSLSession session) {
   }
 
   @Test public void gzippedResponseBody() throws Exception {
-    server.enqueue(new MockResponse()
-        .addHeader("Content-Encoding: gzip")
-        .setBody(gzip("ABCABCABC")));
-    server.play();
+    server.enqueue(
+        new MockResponse().addHeader("Content-Encoding: gzip").setBody(gzip("ABCABCABC")));
     assertContent("ABCABCABC", client.open(server.getUrl("/r1")), Integer.MAX_VALUE);
   }
 
@@ -239,18 +222,17 @@ public boolean verify(String hostname, SSLSession session) {
         .addHeader("www-authenticate: Basic realm=\"protected area\"")
         .setBody("Please authenticate."));
     server.enqueue(new MockResponse().setBody("Successful auth!"));
-    server.play();
 
     Authenticator.setDefault(new RecordingAuthenticator());
     connection = client.open(server.getUrl("/"));
     assertEquals("Successful auth!", readAscii(connection.getInputStream(), Integer.MAX_VALUE));
 
     RecordedRequest denied = server.takeRequest();
-    assertContainsNoneMatching(denied.getHeaders(), "authorization: Basic .*");
+    assertNull(denied.getHeader("Authorization"));
     RecordedRequest accepted = server.takeRequest();
     assertEquals("GET / HTTP/1.1", accepted.getRequestLine());
-    assertContains(accepted.getHeaders(),
-        "authorization: Basic " + RecordingAuthenticator.BASE_64_CREDENTIALS);
+    assertEquals("Basic " + RecordingAuthenticator.BASE_64_CREDENTIALS,
+        accepted.getHeader("Authorization"));
   }
 
   @Test public void redirect() throws Exception {
@@ -258,7 +240,6 @@ public boolean verify(String hostname, SSLSession session) {
         .addHeader("Location: /foo")
         .setBody("This page has moved!"));
     server.enqueue(new MockResponse().setBody("This is the new location!"));
-    server.play();
 
     connection = client.open(server.getUrl("/"));
     assertContent("This is the new location!", connection, Integer.MAX_VALUE);
@@ -271,7 +252,6 @@ public boolean verify(String hostname, SSLSession session) {
 
   @Test public void readAfterLastByte() throws Exception {
     server.enqueue(new MockResponse().setBody("ABC"));
-    server.play();
 
     connection = client.open(server.getUrl("/"));
     InputStream in = connection.getInputStream();
@@ -284,7 +264,6 @@ public boolean verify(String hostname, SSLSession session) {
   @Test(timeout = 3000) public void readResponseHeaderTimeout() throws Exception {
     server.enqueue(new MockResponse().setSocketPolicy(SocketPolicy.NO_RESPONSE));
     server.enqueue(new MockResponse().setBody("A"));
-    server.play();
 
     connection = client.open(server.getUrl("/"));
     connection.setReadTimeout(1000);
@@ -301,10 +280,7 @@ public boolean verify(String hostname, SSLSession session) {
   @Test public void readTimeoutMoreGranularThanBodySize() throws Exception {
     char[] body = new char[4096]; // 4KiB to read
     Arrays.fill(body, 'y');
-    server.enqueue(new MockResponse()
-        .setBody(new String(body))
-        .throttleBody(1024, 1, SECONDS)); // slow connection 1KiB/second
-    server.play();
+    server.enqueue(new MockResponse().setBody(new String(body)).throttleBody(1024, 1, SECONDS)); // slow connection 1KiB/second
 
     connection = client.open(server.getUrl("/"));
     connection.setReadTimeout(2000); // 2 seconds to read something.
@@ -324,7 +300,6 @@ public boolean verify(String hostname, SSLSession session) {
     server.enqueue(new MockResponse()
         .setBody(new String(body))
         .throttleBody(1024, 1, SECONDS)); // slow connection 1KiB/second
-    server.play();
 
     connection = client.open(server.getUrl("/"));
     connection.setReadTimeout(500); // half a second to read something
@@ -339,9 +314,8 @@ public boolean verify(String hostname, SSLSession session) {
 
   @Test public void spdyConnectionTimeout() throws Exception {
     MockResponse response = new MockResponse().setBody("A");
-    response.setBodyDelayTimeMs(1000);
+    response.setBodyDelay(1, TimeUnit.SECONDS);
     server.enqueue(response);
-    server.play();
 
     HttpURLConnection connection1 = client.open(server.getUrl("/"));
     connection1.setReadTimeout(2000);
@@ -356,7 +330,6 @@ public boolean verify(String hostname, SSLSession session) {
     client.client().setCache(cache);
 
     server.enqueue(new MockResponse().addHeader("cache-control: max-age=60").setBody("A"));
-    server.play();
 
     assertContent("A", client.open(server.getUrl("/")), Integer.MAX_VALUE);
     assertEquals(1, cache.getRequestCount());
@@ -374,7 +347,6 @@ public boolean verify(String hostname, SSLSession session) {
 
     server.enqueue(new MockResponse().addHeader("ETag: v1").setBody("A"));
     server.enqueue(new MockResponse().setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
-    server.play();
 
     assertContent("A", client.open(server.getUrl("/")), Integer.MAX_VALUE);
     assertEquals(1, cache.getRequestCount());
@@ -391,7 +363,6 @@ public boolean verify(String hostname, SSLSession session) {
 
     server.enqueue(new MockResponse().addHeader("cache-control: max-age=60").setBody("ABCD"));
     server.enqueue(new MockResponse().addHeader("cache-control: max-age=60").setBody("EFGH"));
-    server.play();
 
     HttpURLConnection connection1 = client.open(server.getUrl("/"));
     InputStream in1 = connection1.getInputStream();
@@ -407,9 +378,9 @@ public boolean verify(String hostname, SSLSession session) {
   @Test public void acceptAndTransmitCookies() throws Exception {
     CookieManager cookieManager = new CookieManager();
     client.client().setCookieHandler(cookieManager);
-    server.play();
+
     server.enqueue(new MockResponse()
-        .addHeader("set-cookie: c=oreo; domain=" + server.getCookieDomain())
+        .addHeader("set-cookie: c=oreo; domain=" + server.get().getCookieDomain())
         .setBody("A"));
     server.enqueue(new MockResponse()
         .setBody("B"));
@@ -422,9 +393,9 @@ public boolean verify(String hostname, SSLSession session) {
 
     assertContent("B", client.open(url), Integer.MAX_VALUE);
     RecordedRequest requestA = server.takeRequest();
-    assertContainsNoneMatching(requestA.getHeaders(), "Cookie.*");
+    assertNull(requestA.getHeader("Cookie"));
     RecordedRequest requestB = server.takeRequest();
-    assertContains(requestB.getHeaders(), "cookie: c=oreo");
+    assertEquals("c=oreo", requestB.getHeader("Cookie"));
   }
 
   /** https://github.com/square/okhttp/issues/1191 */
@@ -433,7 +404,6 @@ public boolean verify(String hostname, SSLSession session) {
     client.client().setConnectionPool(connectionPool);
 
     server.enqueue(new MockResponse().setBody("abc"));
-    server.play();
 
     // Disconnect before the stream is created. A connection is still established!
     HttpURLConnection connection1 = client.open(server.getUrl("/"));
@@ -447,24 +417,12 @@ public boolean verify(String hostname, SSLSession session) {
     assertEquals(0, server.takeRequest().getSequenceNumber());
   }
 
-  <T> void assertContains(Collection<T> collection, T value) {
-    assertTrue(collection.toString(), collection.contains(value));
-  }
-
   void assertContent(String expected, HttpURLConnection connection, int limit)
       throws IOException {
     connection.connect();
     assertEquals(expected, readAscii(connection.getInputStream(), limit));
   }
 
-  private void assertContainsNoneMatching(List<String> headers, String pattern) {
-    for (String header : headers) {
-      if (header.matches(pattern)) {
-        fail("Header " + header + " matches " + pattern);
-      }
-    }
-  }
-
   private String readAscii(InputStream in, int count) throws IOException {
     StringBuilder result = new StringBuilder();
     for (int i = 0; i < count; i++) {
diff --git a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/RouteSelectorTest.java b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/RouteSelectorTest.java
index f69b10db04..8efd308f76 100644
--- a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/RouteSelectorTest.java
+++ b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/RouteSelectorTest.java
@@ -17,12 +17,12 @@
 
 import com.squareup.okhttp.Address;
 import com.squareup.okhttp.Authenticator;
-import com.squareup.okhttp.Connection;
-import com.squareup.okhttp.ConnectionSpec;
 import com.squareup.okhttp.ConnectionPool;
+import com.squareup.okhttp.ConnectionSpec;
 import com.squareup.okhttp.OkHttpClient;
 import com.squareup.okhttp.Protocol;
 import com.squareup.okhttp.Request;
+import com.squareup.okhttp.Route;
 import com.squareup.okhttp.internal.Internal;
 import com.squareup.okhttp.internal.Network;
 import com.squareup.okhttp.internal.RouteDatabase;
@@ -110,17 +110,17 @@
 
   @Test public void singleRoute() throws Exception {
     Address address = httpAddress();
-    RouteSelector routeSelector = RouteSelector.get(httpRequest, client);
+    RouteSelector routeSelector = RouteSelector.get(address, httpRequest, client);
 
     assertTrue(routeSelector.hasNext());
     dns.inetAddresses = makeFakeAddresses(255, 1);
-    assertConnection(routeSelector.nextUnconnected(), address, NO_PROXY, dns.inetAddresses[0],
+    assertRoute(routeSelector.next(), address, NO_PROXY, dns.inetAddresses[0],
         uriPort, ConnectionSpec.CLEARTEXT);
     dns.assertRequests(uriHost);
 
     assertFalse(routeSelector.hasNext());
     try {
-      routeSelector.nextUnconnected();
+      routeSelector.next();
       fail();
     } catch (NoSuchElementException expected) {
     }
@@ -128,18 +128,18 @@
 
   @Test public void singleRouteReturnsFailedRoute() throws Exception {
     Address address = httpAddress();
-    RouteSelector routeSelector = RouteSelector.get(httpRequest, client);
+    RouteSelector routeSelector = RouteSelector.get(address, httpRequest, client);
 
     assertTrue(routeSelector.hasNext());
     dns.inetAddresses = makeFakeAddresses(255, 1);
-    Connection connection = routeSelector.nextUnconnected();
-    routeDatabase.failed(connection.getRoute());
-    routeSelector = RouteSelector.get(httpRequest, client);
-    assertConnection(routeSelector.nextUnconnected(), address, NO_PROXY, dns.inetAddresses[0],
+    Route route = routeSelector.next();
+    routeDatabase.failed(route);
+    routeSelector = RouteSelector.get(address, httpRequest, client);
+    assertRoute(routeSelector.next(), address, NO_PROXY, dns.inetAddresses[0],
         uriPort, ConnectionSpec.CLEARTEXT);
     assertFalse(routeSelector.hasNext());
     try {
-      routeSelector.nextUnconnected();
+      routeSelector.next();
       fail();
     } catch (NoSuchElementException expected) {
     }
@@ -149,13 +149,13 @@
     Address address = new Address(uriHost, uriPort, socketFactory, null, null, null, authenticator,
         proxyA, protocols, connectionSpecs, proxySelector);
     client.setProxy(proxyA);
-    RouteSelector routeSelector = RouteSelector.get(httpRequest, client);
+    RouteSelector routeSelector = RouteSelector.get(address, httpRequest, client);
 
     assertTrue(routeSelector.hasNext());
     dns.inetAddresses = makeFakeAddresses(255, 2);
-    assertConnection(routeSelector.nextUnconnected(), address, proxyA, dns.inetAddresses[0],
+    assertRoute(routeSelector.next(), address, proxyA, dns.inetAddresses[0],
         proxyAPort, ConnectionSpec.CLEARTEXT);
-    assertConnection(routeSelector.nextUnconnected(), address, proxyA, dns.inetAddresses[1],
+    assertRoute(routeSelector.next(), address, proxyA, dns.inetAddresses[1],
         proxyAPort, ConnectionSpec.CLEARTEXT);
 
     assertFalse(routeSelector.hasNext());
@@ -167,13 +167,13 @@
     Address address = new Address(uriHost, uriPort, socketFactory, null, null, null, authenticator,
         NO_PROXY, protocols, connectionSpecs, proxySelector);
     client.setProxy(NO_PROXY);
-    RouteSelector routeSelector = RouteSelector.get(httpRequest, client);
+    RouteSelector routeSelector = RouteSelector.get(address, httpRequest, client);
 
     assertTrue(routeSelector.hasNext());
     dns.inetAddresses = makeFakeAddresses(255, 2);
-    assertConnection(routeSelector.nextUnconnected(), address, NO_PROXY, dns.inetAddresses[0],
+    assertRoute(routeSelector.next(), address, NO_PROXY, dns.inetAddresses[0],
         uriPort, ConnectionSpec.CLEARTEXT);
-    assertConnection(routeSelector.nextUnconnected(), address, NO_PROXY, dns.inetAddresses[1],
+    assertRoute(routeSelector.next(), address, NO_PROXY, dns.inetAddresses[1],
         uriPort, ConnectionSpec.CLEARTEXT);
 
     assertFalse(routeSelector.hasNext());
@@ -185,12 +185,12 @@
     Address address = httpAddress();
 
     proxySelector.proxies = null;
-    RouteSelector routeSelector = RouteSelector.get(httpRequest, client);
+    RouteSelector routeSelector = RouteSelector.get(address, httpRequest, client);
     proxySelector.assertRequests(httpRequest.uri());
 
     assertTrue(routeSelector.hasNext());
     dns.inetAddresses = makeFakeAddresses(255, 1);
-    assertConnection(routeSelector.nextUnconnected(), address, NO_PROXY, dns.inetAddresses[0],
+    assertRoute(routeSelector.next(), address, NO_PROXY, dns.inetAddresses[0],
         uriPort, ConnectionSpec.CLEARTEXT);
     dns.assertRequests(uriHost);
 
@@ -199,13 +199,13 @@
 
   @Test public void proxySelectorReturnsNoProxies() throws Exception {
     Address address = httpAddress();
-    RouteSelector routeSelector = RouteSelector.get(httpRequest, client);
+    RouteSelector routeSelector = RouteSelector.get(address, httpRequest, client);
 
     assertTrue(routeSelector.hasNext());
     dns.inetAddresses = makeFakeAddresses(255, 2);
-    assertConnection(routeSelector.nextUnconnected(), address, NO_PROXY, dns.inetAddresses[0],
+    assertRoute(routeSelector.next(), address, NO_PROXY, dns.inetAddresses[0],
         uriPort, ConnectionSpec.CLEARTEXT);
-    assertConnection(routeSelector.nextUnconnected(), address, NO_PROXY, dns.inetAddresses[1],
+    assertRoute(routeSelector.next(), address, NO_PROXY, dns.inetAddresses[1],
         uriPort, ConnectionSpec.CLEARTEXT);
 
     assertFalse(routeSelector.hasNext());
@@ -218,29 +218,30 @@
 
     proxySelector.proxies.add(proxyA);
     proxySelector.proxies.add(proxyB);
-    RouteSelector routeSelector = RouteSelector.get(httpRequest, client);
+    RouteSelector routeSelector = RouteSelector.get(address, httpRequest, client);
     proxySelector.assertRequests(httpRequest.uri());
 
     // First try the IP addresses of the first proxy, in sequence.
     assertTrue(routeSelector.hasNext());
     dns.inetAddresses = makeFakeAddresses(255, 2);
-    assertConnection(routeSelector.nextUnconnected(), address, proxyA, dns.inetAddresses[0], proxyAPort,
+    assertRoute(routeSelector.next(), address, proxyA, dns.inetAddresses[0], proxyAPort,
         ConnectionSpec.CLEARTEXT);
-    assertConnection(routeSelector.nextUnconnected(), address, proxyA, dns.inetAddresses[1], proxyAPort,
+    assertRoute(routeSelector.next(), address, proxyA, dns.inetAddresses[1], proxyAPort,
         ConnectionSpec.CLEARTEXT);
     dns.assertRequests(proxyAHost);
 
     // Next try the IP address of the second proxy.
     assertTrue(routeSelector.hasNext());
     dns.inetAddresses = makeFakeAddresses(254, 1);
-    assertConnection(routeSelector.nextUnconnected(), address, proxyB, dns.inetAddresses[0], proxyBPort,
+    assertRoute(routeSelector.next(), address, proxyB, dns.inetAddresses[0],
+        proxyBPort,
         ConnectionSpec.CLEARTEXT);
     dns.assertRequests(proxyBHost);
 
     // Finally try the only IP address of the origin server.
     assertTrue(routeSelector.hasNext());
     dns.inetAddresses = makeFakeAddresses(253, 1);
-    assertConnection(routeSelector.nextUnconnected(), address, NO_PROXY, dns.inetAddresses[0], uriPort,
+    assertRoute(routeSelector.next(), address, NO_PROXY, dns.inetAddresses[0], uriPort,
         ConnectionSpec.CLEARTEXT);
     dns.assertRequests(uriHost);
 
@@ -251,13 +252,13 @@
     Address address = httpAddress();
 
     proxySelector.proxies.add(NO_PROXY);
-    RouteSelector routeSelector = RouteSelector.get(httpRequest, client);
+    RouteSelector routeSelector = RouteSelector.get(address, httpRequest, client);
     proxySelector.assertRequests(httpRequest.uri());
 
     // Only the origin server will be attempted.
     assertTrue(routeSelector.hasNext());
     dns.inetAddresses = makeFakeAddresses(255, 1);
-    assertConnection(routeSelector.nextUnconnected(), address, NO_PROXY, dns.inetAddresses[0], uriPort,
+    assertRoute(routeSelector.next(), address, NO_PROXY, dns.inetAddresses[0], uriPort,
         ConnectionSpec.CLEARTEXT);
     dns.assertRequests(uriHost);
 
@@ -270,19 +271,19 @@
     proxySelector.proxies.add(proxyA);
     proxySelector.proxies.add(proxyB);
     proxySelector.proxies.add(proxyA);
-    RouteSelector routeSelector = RouteSelector.get(httpRequest, client);
+    RouteSelector routeSelector = RouteSelector.get(address, httpRequest, client);
     proxySelector.assertRequests(httpRequest.uri());
 
     assertTrue(routeSelector.hasNext());
     dns.inetAddresses = makeFakeAddresses(255, 1);
-    assertConnection(routeSelector.nextUnconnected(), address, proxyA, dns.inetAddresses[0],
+    assertRoute(routeSelector.next(), address, proxyA, dns.inetAddresses[0],
         proxyAPort, ConnectionSpec.CLEARTEXT);
     dns.assertRequests(proxyAHost);
 
     assertTrue(routeSelector.hasNext());
     dns.inetAddresses = null;
     try {
-      routeSelector.nextUnconnected();
+      routeSelector.next();
       fail();
     } catch (UnknownHostException expected) {
     }
@@ -290,13 +291,13 @@
 
     assertTrue(routeSelector.hasNext());
     dns.inetAddresses = makeFakeAddresses(255, 1);
-    assertConnection(routeSelector.nextUnconnected(), address, proxyA, dns.inetAddresses[0],
+    assertRoute(routeSelector.next(), address, proxyA, dns.inetAddresses[0],
         proxyAPort, ConnectionSpec.CLEARTEXT);
     dns.assertRequests(proxyAHost);
 
     assertTrue(routeSelector.hasNext());
     dns.inetAddresses = makeFakeAddresses(254, 1);
-    assertConnection(routeSelector.nextUnconnected(), address, NO_PROXY, dns.inetAddresses[0],
+    assertRoute(routeSelector.next(), address, NO_PROXY, dns.inetAddresses[0],
         uriPort, ConnectionSpec.CLEARTEXT);
     dns.assertRequests(uriHost);
 
@@ -305,99 +306,101 @@
 
   // https://github.com/square/okhttp/issues/442
   @Test public void nonSslErrorAddsAllTlsModesToFailedRoute() throws Exception {
+    Address address = httpsAddress();
     client.setProxy(Proxy.NO_PROXY);
-    RouteSelector routeSelector = RouteSelector.get(httpsRequest, client);
+    RouteSelector routeSelector = RouteSelector.get(address, httpsRequest, client);
 
     dns.inetAddresses = makeFakeAddresses(255, 1);
-    Connection connection = routeSelector.nextUnconnected();
-    routeSelector.connectFailed(connection, new IOException("Non SSL exception"));
+    Route route = routeSelector.next();
+    routeSelector.connectFailed(route, new IOException("Non SSL exception"));
     assertEquals(2, routeDatabase.failedRoutesCount());
     assertFalse(routeSelector.hasNext());
   }
 
   @Test public void sslErrorAddsOnlyFailedConfigurationToFailedRoute() throws Exception {
+    Address address = httpsAddress();
     client.setProxy(Proxy.NO_PROXY);
-    RouteSelector routeSelector = RouteSelector.get(httpsRequest, client);
+    RouteSelector routeSelector = RouteSelector.get(address, httpsRequest, client);
 
     dns.inetAddresses = makeFakeAddresses(255, 1);
-    Connection connection = routeSelector.nextUnconnected();
-    routeSelector.connectFailed(connection, new SSLHandshakeException("SSL exception"));
+    Route route = routeSelector.next();
+    routeSelector.connectFailed(route, new SSLHandshakeException("SSL exception"));
     assertTrue(routeDatabase.failedRoutesCount() == 1);
     assertTrue(routeSelector.hasNext());
   }
 
   @Test public void multipleProxiesMultipleInetAddressesMultipleConfigurations() throws Exception {
-    Address address = new Address(uriHost, uriPort, socketFactory, sslSocketFactory,
-        hostnameVerifier, null, authenticator, null, protocols, connectionSpecs, proxySelector);
+    Address address = httpsAddress();
     proxySelector.proxies.add(proxyA);
     proxySelector.proxies.add(proxyB);
-    RouteSelector routeSelector = RouteSelector.get(httpsRequest, client);
+    RouteSelector routeSelector = RouteSelector.get(address, httpsRequest, client);
 
     // Proxy A
     dns.inetAddresses = makeFakeAddresses(255, 2);
-    assertConnection(routeSelector.nextUnconnected(), address, proxyA, dns.inetAddresses[0],
+    assertRoute(routeSelector.next(), address, proxyA, dns.inetAddresses[0],
         proxyAPort, ConnectionSpec.MODERN_TLS);
     dns.assertRequests(proxyAHost);
-    assertConnection(routeSelector.nextUnconnected(), address, proxyA, dns.inetAddresses[0],
+    assertRoute(routeSelector.next(), address, proxyA, dns.inetAddresses[0],
         proxyAPort, ConnectionSpec.COMPATIBLE_TLS);
-    assertConnection(routeSelector.nextUnconnected(), address, proxyA, dns.inetAddresses[1],
+    assertRoute(routeSelector.next(), address, proxyA, dns.inetAddresses[1],
         proxyAPort, ConnectionSpec.MODERN_TLS);
-    assertConnection(routeSelector.nextUnconnected(), address, proxyA, dns.inetAddresses[1],
+    assertRoute(routeSelector.next(), address, proxyA, dns.inetAddresses[1],
         proxyAPort, ConnectionSpec.COMPATIBLE_TLS);
 
     // Proxy B
     dns.inetAddresses = makeFakeAddresses(254, 2);
-    assertConnection(routeSelector.nextUnconnected(), address, proxyB, dns.inetAddresses[0],
+    assertRoute(routeSelector.next(), address, proxyB, dns.inetAddresses[0],
         proxyBPort, ConnectionSpec.MODERN_TLS);
     dns.assertRequests(proxyBHost);
-    assertConnection(routeSelector.nextUnconnected(), address, proxyB, dns.inetAddresses[0],
+    assertRoute(routeSelector.next(), address, proxyB, dns.inetAddresses[0],
         proxyBPort, ConnectionSpec.COMPATIBLE_TLS);
-    assertConnection(routeSelector.nextUnconnected(), address, proxyB, dns.inetAddresses[1],
+    assertRoute(routeSelector.next(), address, proxyB, dns.inetAddresses[1],
         proxyBPort, ConnectionSpec.MODERN_TLS);
-    assertConnection(routeSelector.nextUnconnected(), address, proxyB, dns.inetAddresses[1],
+    assertRoute(routeSelector.next(), address, proxyB, dns.inetAddresses[1],
         proxyBPort, ConnectionSpec.COMPATIBLE_TLS);
 
     // Origin
     dns.inetAddresses = makeFakeAddresses(253, 2);
-    assertConnection(routeSelector.nextUnconnected(), address, NO_PROXY, dns.inetAddresses[0],
+    assertRoute(routeSelector.next(), address, NO_PROXY, dns.inetAddresses[0],
         uriPort, ConnectionSpec.MODERN_TLS);
     dns.assertRequests(uriHost);
-    assertConnection(routeSelector.nextUnconnected(), address, NO_PROXY, dns.inetAddresses[0],
+    assertRoute(routeSelector.next(), address, NO_PROXY, dns.inetAddresses[0],
         uriPort, ConnectionSpec.COMPATIBLE_TLS);
-    assertConnection(routeSelector.nextUnconnected(), address, NO_PROXY, dns.inetAddresses[1],
+    assertRoute(routeSelector.next(), address, NO_PROXY, dns.inetAddresses[1],
         uriPort, ConnectionSpec.MODERN_TLS);
-    assertConnection(routeSelector.nextUnconnected(), address, NO_PROXY, dns.inetAddresses[1],
+    assertRoute(routeSelector.next(), address, NO_PROXY, dns.inetAddresses[1],
         uriPort, ConnectionSpec.COMPATIBLE_TLS);
 
     assertFalse(routeSelector.hasNext());
   }
 
   @Test public void failedRoutesAreLast() throws Exception {
+    Address address = httpsAddress();
     client.setProxy(Proxy.NO_PROXY);
-    RouteSelector routeSelector = RouteSelector.get(httpsRequest, client);
+    RouteSelector routeSelector = RouteSelector.get(address, httpsRequest, client);
 
     dns.inetAddresses = makeFakeAddresses(255, 1);
 
     // Extract the regular sequence of routes from selector.
-    List<Connection> regularRoutes = new ArrayList<>();
+    List<Route> regularRoutes = new ArrayList<>();
     while (routeSelector.hasNext()) {
-      regularRoutes.add(routeSelector.nextUnconnected());
+      regularRoutes.add(routeSelector.next());
     }
 
     // Check that we do indeed have more than one route.
     assertTrue(regularRoutes.size() > 1);
     // Add first regular route as failed.
-    routeDatabase.failed(regularRoutes.get(0).getRoute());
+    routeDatabase.failed(regularRoutes.get(0));
     // Reset selector
-    routeSelector = RouteSelector.get(httpsRequest, client);
+    routeSelector = RouteSelector.get(address, httpsRequest, client);
 
-    List<Connection> routesWithFailedRoute = new ArrayList<>();
+    List<Route> routesWithFailedRoute = new ArrayList<>();
     while (routeSelector.hasNext()) {
-      routesWithFailedRoute.add(routeSelector.nextUnconnected());
+      routesWithFailedRoute.add(routeSelector.next());
     }
 
-    assertEquals(regularRoutes.get(0).getRoute(),
-        routesWithFailedRoute.get(routesWithFailedRoute.size() - 1).getRoute());
+    assertEquals(regularRoutes.get(0),
+        routesWithFailedRoute.get(routesWithFailedRoute.size() - 1));
     assertEquals(regularRoutes.size(), routesWithFailedRoute.size());
   }
 
@@ -419,13 +422,13 @@
     assertEquals("127.0.0.1", RouteSelector.getHostString(socketAddress));
   }
 
-  private void assertConnection(Connection connection, Address address, Proxy proxy,
+  private void assertRoute(Route route, Address address, Proxy proxy,
       InetAddress socketAddress, int socketPort, ConnectionSpec connectionSpec) {
-    assertEquals(address, connection.getRoute().getAddress());
-    assertEquals(proxy, connection.getRoute().getProxy());
-    assertEquals(socketAddress, connection.getRoute().getSocketAddress().getAddress());
-    assertEquals(socketPort, connection.getRoute().getSocketAddress().getPort());
-    assertEquals(connectionSpec, connection.getRoute().getConnectionSpec());
+    assertEquals(address, route.getAddress());
+    assertEquals(proxy, route.getProxy());
+    assertEquals(socketAddress, route.getSocketAddress().getAddress());
+    assertEquals(socketPort, route.getSocketAddress().getPort());
+    assertEquals(connectionSpec, route.getConnectionSpec());
   }
 
   /** Returns an address that's without an SSL socket factory or hostname verifier. */
@@ -434,6 +437,11 @@ private Address httpAddress() {
         protocols, connectionSpecs, proxySelector);
   }
 
+  private Address httpsAddress() {
+    return new Address(uriHost, uriPort, socketFactory, sslSocketFactory,
+        hostnameVerifier, null, authenticator, null, protocols, connectionSpecs, proxySelector);
+  }
+
   private static InetAddress[] makeFakeAddresses(int prefix, int count) {
     try {
       InetAddress[] result = new InetAddress[count];
diff --git a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/ThreadInterruptTest.java b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/ThreadInterruptTest.java
index c9e5a0b185..63f55e1f18 100644
--- a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/ThreadInterruptTest.java
+++ b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/ThreadInterruptTest.java
@@ -27,12 +27,11 @@
 import java.io.InterruptedIOException;
 import java.io.OutputStream;
 import java.net.HttpURLConnection;
-import java.net.InetAddress;
 import java.net.ServerSocket;
 import java.net.Socket;
-import java.net.UnknownHostException;
 import java.util.concurrent.TimeUnit;
 
+import okio.Buffer;
 import org.junit.Before;
 import org.junit.Test;
 
@@ -76,7 +75,7 @@ protected void configureSocket(Socket socket) throws IOException {
 
     server.enqueue(new MockResponse()
         .throttleBody(64 * 1024, 125, TimeUnit.MILLISECONDS)); // 500 Kbps
-    server.play();
+    server.start();
 
     interruptLater(500);
 
@@ -101,9 +100,9 @@ protected void configureSocket(Socket socket) throws IOException {
     int responseBodySize = 2 * 1024 * 1024; // 2 MiB
 
     server.enqueue(new MockResponse()
-        .setBody(new byte[responseBodySize])
+        .setBody(new Buffer().write(new byte[responseBodySize]))
         .throttleBody(64 * 1024, 125, TimeUnit.MILLISECONDS)); // 500 Kbps
-    server.play();
+    server.start();
 
     interruptLater(500);
 
diff --git a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/URLConnectionTest.java b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/URLConnectionTest.java
index ddc64bc9f7..330929b332 100644
--- a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/URLConnectionTest.java
+++ b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/URLConnectionTest.java
@@ -24,6 +24,7 @@
 import com.squareup.okhttp.DelegatingServerSocketFactory;
 import com.squareup.okhttp.DelegatingSocketFactory;
 import com.squareup.okhttp.FallbackTestClientSocketFactory;
+import com.squareup.okhttp.Headers;
 import com.squareup.okhttp.Interceptor;
 import com.squareup.okhttp.OkHttpClient;
 import com.squareup.okhttp.OkUrlFactory;
@@ -42,7 +43,6 @@
 import com.squareup.okhttp.mockwebserver.RecordedRequest;
 import com.squareup.okhttp.mockwebserver.SocketPolicy;
 import com.squareup.okhttp.mockwebserver.rule.MockWebServerRule;
-import java.io.File;
 import java.io.IOException;
 import java.io.InputStream;
 import java.io.OutputStream;
@@ -68,12 +68,10 @@
 import java.util.Collections;
 import java.util.EnumSet;
 import java.util.HashSet;
-import java.util.Iterator;
 import java.util.List;
 import java.util.Map;
 import java.util.Random;
 import java.util.Set;
-import java.util.UUID;
 import java.util.concurrent.TimeUnit;
 import java.util.zip.GZIPInputStream;
 import javax.net.ServerSocketFactory;
@@ -94,6 +92,7 @@
 import org.junit.Ignore;
 import org.junit.Rule;
 import org.junit.Test;
+import org.junit.rules.TemporaryFolder;
 
 import static com.squareup.okhttp.internal.Util.UTF_8;
 import static com.squareup.okhttp.internal.http.OkHeaders.SELECTED_PROTOCOL;
@@ -116,8 +115,9 @@
 public final class URLConnectionTest {
   private static final SSLContext sslContext = SslContextBuilder.localhost();
 
-  @Rule public MockWebServerRule server = new MockWebServerRule();
-  @Rule public MockWebServerRule server2 = new MockWebServerRule();
+  @Rule public final MockWebServerRule server = new MockWebServerRule();
+  @Rule public final MockWebServerRule server2 = new MockWebServerRule();
+  @Rule public final TemporaryFolder tempDir = new TemporaryFolder();
 
   private OkUrlFactory client;
   private HttpURLConnection connection;
@@ -180,12 +180,11 @@
 
     connection.getResponseCode();
     RecordedRequest request = server.takeRequest();
-    assertContains(request.getHeaders(), "D: e");
-    assertContains(request.getHeaders(), "D: f");
-    assertContainsNoneMatching(request.getHeaders(), "NullValue.*");
-    assertContainsNoneMatching(request.getHeaders(), "AnotherNullValue.*");
-    assertContainsNoneMatching(request.getHeaders(), "G:.*");
-    assertContainsNoneMatching(request.getHeaders(), "null:.*");
+    assertEquals(Arrays.asList("e", "f"), request.getHeaders().values("D"));
+    assertNull(request.getHeader("NullValue"));
+    assertNull(request.getHeader("AnotherNullValue"));
+    assertNull(request.getHeader("G"));
+    assertNull(request.getHeader("null"));
 
     try {
       connection.addRequestProperty("N", "o");
@@ -327,7 +326,7 @@ private void testRequestBodySurvivesRetries(TransferKind transferKind) throws Ex
     connection.getOutputStream().write("body".getBytes("UTF-8"));
     assertContent("abc", connection);
 
-    assertEquals("body", server.takeRequest().getUtf8Body());
+    assertEquals("body", server.takeRequest().getBody().readUtf8());
   }
 
   @Test public void getErrorStreamOnSuccessfulRequest() throws Exception {
@@ -687,7 +686,7 @@ private void testConnectViaProxy(ProxyConfig proxyConfig) throws Exception {
 
     RecordedRequest request = server.get().takeRequest();
     assertEquals("GET http://android.com/foo HTTP/1.1", request.getRequestLine());
-    assertContains(request.getHeaders(), "Host: android.com");
+    assertEquals("android.com", request.getHeader("Host"));
   }
 
   @Test public void contentDisagreesWithContentLengthHeader() throws IOException {
@@ -741,9 +740,8 @@ public Socket createSocket(String host, int port, InetAddress localHost, int loc
   @Test public void contentDisagreesWithChunkedHeader() throws IOException {
     MockResponse mockResponse = new MockResponse();
     mockResponse.setChunkedBody("abc", 3);
-    Buffer buffer = new Buffer();
-    buffer.writeAll(mockResponse.getBody());
-    buffer.write("\r\nYOU SHOULD NOT SEE THIS".getBytes("UTF-8"));
+    Buffer buffer = mockResponse.getBody();
+    buffer.writeUtf8("\r\nYOU SHOULD NOT SEE THIS");
     mockResponse.setBody(buffer);
     mockResponse.clearHeaders();
     mockResponse.addHeader("Transfer-encoding: chunked");
@@ -815,11 +813,11 @@ private void testConnectViaHttpProxyToHttps(ProxyConfig proxyConfig) throws Exce
     RecordedRequest connect = server.takeRequest();
     assertEquals("Connect line failure on proxy", "CONNECT android.com:443 HTTP/1.1",
         connect.getRequestLine());
-    assertContains(connect.getHeaders(), "Host: android.com");
+    assertEquals("android.com", connect.getHeader("Host"));
 
     RecordedRequest get = server.takeRequest();
     assertEquals("GET /foo HTTP/1.1", get.getRequestLine());
-    assertContains(get.getHeaders(), "Host: android.com");
+    assertEquals("android.com", get.getHeader("Host"));
     assertEquals(Arrays.asList("verify android.com"), hostnameVerifier.calls);
   }
 
@@ -849,13 +847,11 @@ private void testConnectViaHttpProxyToHttps(ProxyConfig proxyConfig) throws Exce
 
     RecordedRequest connect = server.takeRequest();
     assertEquals("CONNECT android.com:443 HTTP/1.1", connect.getRequestLine());
-    assertContains(connect.getHeaders(), "Host: android.com");
+    assertEquals("android.com", connect.getHeader("Host"));
   }
 
   private void initResponseCache() throws IOException {
-    String tmp = System.getProperty("java.io.tmpdir");
-    File cacheDir = new File(tmp, "HttpCache-" + UUID.randomUUID());
-    cache = new Cache(cacheDir, Integer.MAX_VALUE);
+    cache = new Cache(tempDir.getRoot(), Integer.MAX_VALUE);
     client.client().setCache(cache);
   }
 
@@ -881,14 +877,14 @@ private void initResponseCache() throws IOException {
     assertContent("encrypted response from the origin server", connection);
 
     RecordedRequest connect = server.takeRequest();
-    assertContainsNoneMatching(connect.getHeaders(), "Private.*");
-    assertContains(connect.getHeaders(), "Proxy-Authorization: bar");
-    assertContains(connect.getHeaders(), "User-Agent: baz");
-    assertContains(connect.getHeaders(), "Host: android.com");
-    assertContains(connect.getHeaders(), "Proxy-Connection: Keep-Alive");
+    assertNull(connect.getHeader("Private"));
+    assertEquals("bar", connect.getHeader("Proxy-Authorization"));
+    assertEquals("baz", connect.getHeader("User-Agent"));
+    assertEquals("android.com", connect.getHeader("Host"));
+    assertEquals("Keep-Alive", connect.getHeader("Proxy-Connection"));
 
     RecordedRequest get = server.takeRequest();
-    assertContains(get.getHeaders(), "Private: Secret");
+    assertEquals("Secret", get.getHeader("Private"));
     assertEquals(Arrays.asList("verify android.com"), hostnameVerifier.calls);
   }
 
@@ -911,16 +907,16 @@ private void initResponseCache() throws IOException {
 
     RecordedRequest connect1 = server.takeRequest();
     assertEquals("CONNECT android.com:443 HTTP/1.1", connect1.getRequestLine());
-    assertContainsNoneMatching(connect1.getHeaders(), "Proxy\\-Authorization.*");
+    assertNull(connect1.getHeader("Proxy-Authorization"));
 
     RecordedRequest connect2 = server.takeRequest();
     assertEquals("CONNECT android.com:443 HTTP/1.1", connect2.getRequestLine());
-    assertContains(connect2.getHeaders(),
-        "Proxy-Authorization: Basic " + RecordingAuthenticator.BASE_64_CREDENTIALS);
+    assertEquals("Basic " + RecordingAuthenticator.BASE_64_CREDENTIALS,
+        connect2.getHeader("Proxy-Authorization"));
 
     RecordedRequest get = server.takeRequest();
     assertEquals("GET /foo HTTP/1.1", get.getRequestLine());
-    assertContainsNoneMatching(get.getHeaders(), "Proxy\\-Authorization.*");
+    assertNull(get.getHeader("Proxy-Authorization"));
   }
 
   // Don't disconnect after building a tunnel with CONNECT
@@ -1109,7 +1105,7 @@ private void testMarkAndReset(TransferKind transferKind) throws IOException {
     assertEquals(-1, connection.getContentLength());
 
     RecordedRequest request = server.takeRequest();
-    assertContains(request.getHeaders(), "Accept-Encoding: gzip");
+    assertEquals("gzip", request.getHeader("Accept-Encoding"));
   }
 
   @Test public void clientConfiguredGzipContentEncoding() throws Exception {
@@ -1125,7 +1121,7 @@ private void testMarkAndReset(TransferKind transferKind) throws IOException {
     assertEquals(bodyBytes.size(), connection.getContentLength());
 
     RecordedRequest request = server.takeRequest();
-    assertContains(request.getHeaders(), "Accept-Encoding: gzip");
+    assertEquals("gzip", request.getHeader("Accept-Encoding"));
   }
 
   @Test public void gzipAndConnectionReuseWithFixedLength() throws Exception {
@@ -1152,7 +1148,7 @@ private void testMarkAndReset(TransferKind transferKind) throws IOException {
     assertEquals("ABCDE", readAscii(connection.getInputStream(), Integer.MAX_VALUE));
 
     RecordedRequest request = server.takeRequest();
-    assertContains(request.getHeaders(), "Accept-Encoding: custom");
+    assertEquals("custom", request.getHeader("Accept-Encoding"));
   }
 
   /**
@@ -1294,7 +1290,7 @@ private void testEarlyDisconnectDoesntHarmPooling(TransferKind transferKind) thr
     assertEquals(200, connection.getResponseCode());
 
     RecordedRequest request = server.takeRequest();
-    assertEquals(body, new String(request.getBody(), "US-ASCII"));
+    assertEquals(body, request.getBody().readUtf8());
     assertEquals(Arrays.asList(body.length()), request.getChunkSizes());
   }
 
@@ -1332,8 +1328,8 @@ private void testAuthenticateWithStreamingPost(StreamingMode streamingMode) thro
 
     // no authorization header for the request...
     RecordedRequest request = server.takeRequest();
-    assertContainsNoneMatching(request.getHeaders(), "Authorization: Basic .*");
-    assertEquals(Arrays.toString(requestBody), Arrays.toString(request.getBody()));
+    assertNull(request.getHeader("Authorization"));
+    assertEquals("ABCD", request.getBody().readUtf8());
   }
 
   @Test public void postBodyRetransmittedAfterAuthorizationFail() throws Exception {
@@ -1381,12 +1377,12 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
 
     RecordedRequest recordedRequest1 = server.takeRequest();
     assertEquals("POST", recordedRequest1.getMethod());
-    assertEquals(body, recordedRequest1.getUtf8Body());
+    assertEquals(body, recordedRequest1.getBody().readUtf8());
     assertNull(recordedRequest1.getHeader("Authorization"));
 
     RecordedRequest recordedRequest2 = server.takeRequest();
     assertEquals("POST", recordedRequest2.getMethod());
-    assertEquals(body, recordedRequest2.getUtf8Body());
+    assertEquals(body, recordedRequest2.getBody().readUtf8());
     assertEquals(credential, recordedRequest2.getHeader("Authorization"));
   }
 
@@ -1613,7 +1609,7 @@ private void testSecureStreamingPost(StreamingMode streamingMode) throws Excepti
     } else if (streamingMode == StreamingMode.CHUNKED) {
       assertEquals(Arrays.asList(4), request.getChunkSizes());
     }
-    assertEquals(Arrays.toString(requestBody), Arrays.toString(request.getBody()));
+    assertEquals("ABCD", request.getBody().readUtf8());
   }
 
   enum StreamingMode {
@@ -1642,15 +1638,15 @@ private void testSecureStreamingPost(StreamingMode streamingMode) throws Excepti
 
     // no authorization header for the first request...
     RecordedRequest request = server.takeRequest();
-    assertContainsNoneMatching(request.getHeaders(), "Authorization: Basic .*");
+    assertNull(request.getHeader("Authorization"));
 
     // ...but the three requests that follow include an authorization header
     for (int i = 0; i < 3; i++) {
       request = server.takeRequest();
       assertEquals("POST / HTTP/1.1", request.getRequestLine());
-      assertContains(request.getHeaders(),
-          "Authorization: Basic " + RecordingAuthenticator.BASE_64_CREDENTIALS);
-      assertEquals(Arrays.toString(requestBody), Arrays.toString(request.getBody()));
+      assertEquals("Basic " + RecordingAuthenticator.BASE_64_CREDENTIALS,
+          request.getHeader("Authorization"));
+      assertEquals("ABCD", request.getBody().readUtf8());
     }
   }
 
@@ -1671,14 +1667,14 @@ private void testSecureStreamingPost(StreamingMode streamingMode) throws Excepti
 
     // no authorization header for the first request...
     RecordedRequest request = server.takeRequest();
-    assertContainsNoneMatching(request.getHeaders(), "Authorization: Basic .*");
+    assertNull(request.getHeader("Authorization"));
 
     // ...but the three requests that follow requests include an authorization header
     for (int i = 0; i < 3; i++) {
       request = server.takeRequest();
       assertEquals("GET / HTTP/1.1", request.getRequestLine());
-      assertContains(request.getHeaders(),
-          "Authorization: Basic " + RecordingAuthenticator.BASE_64_CREDENTIALS);
+      assertEquals("Basic " + RecordingAuthenticator.BASE_64_CREDENTIALS,
+          request.getHeader("Authorization"));
     }
   }
 
@@ -1703,14 +1699,14 @@ private void testSecureStreamingPost(StreamingMode streamingMode) throws Excepti
 
     // no authorization header for the first request...
     RecordedRequest request = server.takeRequest();
-    assertContainsNoneMatching(request.getHeaders(), "Authorization: Basic .*");
+    assertNull(request.getHeader("Authorization"));
 
     // ...but the three requests that follow requests include an authorization header
     for (int i = 0; i < 3; i++) {
       request = server.takeRequest();
       assertEquals("GET / HTTP/1.1", request.getRequestLine());
-      assertContains(request.getHeaders(),
-          "Authorization: Basic " + RecordingAuthenticator.BASE_64_CREDENTIALS);
+      assertEquals("Basic " + RecordingAuthenticator.BASE_64_CREDENTIALS,
+          request.getHeader("Authorization"));
     }
   }
 
@@ -1872,8 +1868,8 @@ private void redirectToAnotherOriginServer(boolean https) throws Exception {
 
     String server1Host = server.get().getHostName() + ":" + server.getPort();
     String server2Host = server2.get().getHostName() + ":" + server2.getPort();
-    assertContains(server.takeRequest().getHeaders(), "Host: " + server1Host);
-    assertContains(server2.takeRequest().getHeaders(), "Host: " + server2Host);
+    assertEquals(server1Host, server.takeRequest().getHeader("Host"));
+    assertEquals(server2Host, server2.takeRequest().getHeader("Host"));
     assertEquals("Expected connection reuse", 1, server.takeRequest().getSequenceNumber());
     assertEquals("Expected connection reuse", 1, server2.takeRequest().getSequenceNumber());
   }
@@ -1918,7 +1914,7 @@ private void redirectToAnotherOriginServer(boolean https) throws Exception {
     assertContent("Page 2", client.open(server.getUrl("/a")));
 
     RecordedRequest redirectRequest = server2.takeRequest();
-    assertContainsNoneMatching(redirectRequest.getHeaders(), "Authorization.*");
+    assertNull(redirectRequest.getHeader("Authorization"));
     assertEquals("/b", redirectRequest.getPath());
   }
 
@@ -1966,7 +1962,7 @@ private void testResponseRedirectedWithPost(int redirectCode, TransferKind trans
 
     RecordedRequest page1 = server.takeRequest();
     assertEquals("POST /page1 HTTP/1.1", page1.getRequestLine());
-    assertEquals(Arrays.toString(requestBody), Arrays.toString(page1.getBody()));
+    assertEquals("ABCD", page1.getBody().readUtf8());
 
     RecordedRequest page2 = server.takeRequest();
     assertEquals("GET /page2 HTTP/1.1", page2.getRequestLine());
@@ -1991,9 +1987,9 @@ private void testResponseRedirectedWithPost(int redirectCode, TransferKind trans
 
     RecordedRequest page2 = server.takeRequest();
     assertEquals("GET /page2 HTTP/1.1", page2.getRequestLine());
-    assertContainsNoneMatching(page2.getHeaders(), "Content-Length.*");
-    assertContainsNoneMatching(page2.getHeaders(), "Content-Type.*");
-    assertContainsNoneMatching(page2.getHeaders(), "Transfer-Encoding.*");
+    assertNull(page2.getHeader("Content-Length"));
+    assertNull(page2.getHeader("Content-Type"));
+    assertNull(page2.getHeader("Transfer-Encoding"));
   }
 
   @Test public void response305UseProxy() throws Exception {
@@ -2076,7 +2072,7 @@ private void testRedirect(boolean temporary, String method) throws Exception {
       // Methods other than GET/HEAD shouldn't follow the redirect
       if (method.equals("POST")) {
         assertTrue(connection.getDoOutput());
-        assertEquals(Arrays.toString(requestBody), Arrays.toString(page1.getBody()));
+        assertEquals("ABCD", page1.getBody().readUtf8());
       }
       assertEquals(1, server.getRequestCount());
       assertEquals("This page has moved!", response);
@@ -2214,7 +2210,7 @@ protected void configureSocket(Socket socket) throws IOException {
     assertEquals(200, connection.getResponseCode());
 
     RecordedRequest request = server.takeRequest();
-    assertEquals("ABC", new String(request.getBody(), "UTF-8"));
+    assertEquals("ABC", request.getBody().readUtf8());
   }
 
   @Test public void connectionCloseInRequest() throws IOException, InterruptedException {
@@ -2478,7 +2474,7 @@ private void testFlushAfterStreamTransmitted(TransferKind transferKind) throws I
     out.close();
     assertEquals("A", readAscii(connection.getInputStream(), Integer.MAX_VALUE));
     RecordedRequest request = server.takeRequest();
-    assertContains(request.getHeaders(), "Content-Length: 3");
+    assertEquals("3", request.getHeader("Content-Length"));
   }
 
   @Test public void getContentLengthConnects() throws Exception {
@@ -2598,7 +2594,7 @@ private void reusedConnectionFailsWithPost(TransferKind transferKind, int reques
     assertEquals("/a", requestA.getPath());
     RecordedRequest requestB = server.takeRequest();
     assertEquals("/b", requestB.getPath());
-    assertEquals(Arrays.toString(requestBody), Arrays.toString(requestB.getBody()));
+    assertEquals(Arrays.toString(requestBody), Arrays.toString(requestB.getBody().readByteArray()));
   }
 
   @Test public void postBodyRetransmittedOnFailureRecovery() throws Exception {
@@ -2618,11 +2614,11 @@ private void reusedConnectionFailsWithPost(TransferKind transferKind, int reques
     assertEquals(0, get.getSequenceNumber());
 
     RecordedRequest post1 = server.takeRequest();
-    assertEquals("body!", post1.getUtf8Body());
+    assertEquals("body!", post1.getBody().readUtf8());
     assertEquals(1, post1.getSequenceNumber());
 
     RecordedRequest post2 = server.takeRequest();
-    assertEquals("body!", post2.getUtf8Body());
+    assertEquals("body!", post2.getBody().readUtf8());
     assertEquals(0, post2.getSequenceNumber());
   }
 
@@ -2711,7 +2707,9 @@ private void reusedConnectionFailsWithPost(TransferKind transferKind, int reques
   }
 
   @Test public void emptyResponseHeaderNameIsLenient() throws Exception {
-    server.enqueue(new MockResponse().addHeader(":A").setBody("body"));
+    Headers.Builder headers = new Headers.Builder();
+    Internal.instance.addLenient(headers, ":A");
+    server.enqueue(new MockResponse().setHeaders(headers.build()).setBody("body"));
     connection = client.open(server.getUrl("/"));
     connection.getResponseCode();
     assertEquals("A", connection.getHeaderField(""));
@@ -2741,16 +2739,15 @@ private void reusedConnectionFailsWithPost(TransferKind transferKind, int reques
     client.client().setAuthenticator(authenticator);
     assertContent("A", client.open(server.getUrl("/private")));
 
-    assertContainsNoneMatching(server.takeRequest().getHeaders(), "Authorization: .*");
-    assertContains(server.takeRequest().getHeaders(),
-        "Authorization: " + credential);
+    assertNull(server.takeRequest().getHeader("Authorization"));
+    assertEquals(credential, server.takeRequest().getHeader("Authorization"));
 
     assertEquals(Proxy.NO_PROXY, authenticator.onlyProxy());
     Response response = authenticator.onlyResponse();
     assertEquals("/private", response.request().url().getPath());
     assertEquals(Arrays.asList(new Challenge("Basic", "protected area")), response.challenges());
   }
-  
+
   @Test public void customTokenAuthenticator() throws Exception {
     MockResponse pleaseAuthenticate = new MockResponse().setResponseCode(401)
             .addHeader("WWW-Authenticate: Bearer realm=\"oauthed\"")
@@ -2762,8 +2759,8 @@ private void reusedConnectionFailsWithPost(TransferKind transferKind, int reques
     client.client().setAuthenticator(authenticator);
     assertContent("A", client.open(server.getUrl("/private")));
 
-    assertContainsNoneMatching(server.takeRequest().getHeaders(), "Authorization: .*");
-    assertContains(server.takeRequest().getHeaders(), "Authorization: oauthed abc123");
+    assertNull(server.takeRequest().getHeader("Authorization"));
+    assertEquals("oauthed abc123", server.takeRequest().getHeader("Authorization"));
 
     Response response = authenticator.onlyResponse();
     assertEquals("/private", response.request().url().getPath());
@@ -2910,7 +2907,7 @@ private void zeroLengthPayload(String method)
     RecordedRequest request = server.takeRequest();
     assertEquals("application/x-www-form-urlencoded", request.getHeader("Content-Type"));
     assertEquals("3", request.getHeader("Content-Length"));
-    assertEquals("abc", request.getUtf8Body());
+    assertEquals("abc", request.getBody().readUtf8());
   }
 
   @Test public void setProtocols() throws Exception {
@@ -3021,7 +3018,7 @@ private void zeroLengthPayload(String method)
 
     RecordedRequest request = server.takeRequest();
     assertEquals("DELETE", request.getMethod());
-    assertEquals("BODY", new String(request.getBody(), UTF_8));
+    assertEquals("BODY", request.getBody().readUtf8());
   }
 
   @Test public void userAgentPicksUpHttpAgentSystemProperty() throws Exception {
@@ -3079,18 +3076,6 @@ private void assertContent(String expected, HttpURLConnection connection) throws
     assertContent(expected, connection, Integer.MAX_VALUE);
   }
 
-  private void assertContains(List<String> headers, String header) {
-    assertTrue(headers.toString(), headers.contains(header));
-  }
-
-  private void assertContainsNoneMatching(List<String> headers, String pattern) {
-    for (String header : headers) {
-      if (header.matches(pattern)) {
-        fail("Header " + header + " matches " + pattern);
-      }
-    }
-  }
-
   private Set<String> newSet(String... elements) {
     return new HashSet<String>(Arrays.asList(elements));
   }
@@ -3117,12 +3102,7 @@ private void assertContainsNoneMatching(List<String> headers, String pattern) {
       @Override void setBody(MockResponse response, Buffer content, int chunkSize) {
         response.setBody(content);
         response.setSocketPolicy(DISCONNECT_AT_END);
-        for (Iterator<String> h = response.getHeaders().iterator(); h.hasNext(); ) {
-          if (h.next().startsWith("Content-Length:")) {
-            h.remove();
-            break;
-          }
-        }
+        response.removeHeader("Content-Length");
       }
       @Override void setForRequest(HttpURLConnection connection, int contentLength) {
       }
diff --git a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/ws/WebSocketCallTest.java b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/ws/WebSocketCallTest.java
index c0a5d4654d..705b0357f2 100644
--- a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/ws/WebSocketCallTest.java
+++ b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/ws/WebSocketCallTest.java
@@ -28,11 +28,14 @@
 import java.util.concurrent.TimeUnit;
 import java.util.concurrent.atomic.AtomicReference;
 import okio.Buffer;
+import okio.BufferedSink;
 import okio.BufferedSource;
 import org.junit.After;
 import org.junit.Rule;
 import org.junit.Test;
 
+import static com.squareup.okhttp.internal.ws.WebSocket.PayloadType.TEXT;
+
 public final class WebSocketCallTest {
   @Rule public final MockWebServerRule server = new MockWebServerRule();
 
@@ -44,6 +47,66 @@
     listener.assertExhausted();
   }
 
+  @Test public void clientPingPong() throws IOException {
+    WebSocketListener serverListener = new EmptyWebSocketListener();
+    server.enqueue(new MockResponse().withWebSocketUpgrade(serverListener));
+
+    WebSocket webSocket = awaitCall().webSocket;
+    webSocket.sendPing(new Buffer().writeUtf8("Hello, WebSockets!"));
+    listener.assertPong(new Buffer().writeUtf8("Hello, WebSockets!"));
+  }
+
+  @Test public void clientMessage() throws IOException {
+    WebSocketRecorder serverListener = new WebSocketRecorder();
+    server.enqueue(new MockResponse().withWebSocketUpgrade(serverListener));
+
+    WebSocket webSocket = awaitCall().webSocket;
+    webSocket.sendMessage(TEXT, new Buffer().writeUtf8("Hello, WebSockets!"));
+    serverListener.assertTextMessage("Hello, WebSockets!");
+  }
+
+  @Test public void serverMessage() throws IOException {
+    WebSocketListener serverListener = new EmptyWebSocketListener() {
+      @Override public void onOpen(WebSocket webSocket, Request request, Response response)
+          throws IOException {
+        webSocket.sendMessage(TEXT, new Buffer().writeUtf8("Hello, WebSockets!"));
+      }
+    };
+    server.enqueue(new MockResponse().withWebSocketUpgrade(serverListener));
+
+    awaitCall();
+    listener.assertTextMessage("Hello, WebSockets!");
+  }
+
+  @Test public void clientStreamingMessage() throws IOException {
+    WebSocketRecorder serverListener = new WebSocketRecorder();
+    server.enqueue(new MockResponse().withWebSocketUpgrade(serverListener));
+
+    WebSocket webSocket = awaitCall().webSocket;
+    BufferedSink sink = webSocket.newMessageSink(TEXT);
+    sink.writeUtf8("Hello, ").flush();
+    sink.writeUtf8("WebSockets!").flush();
+    sink.close();
+
+    serverListener.assertTextMessage("Hello, WebSockets!");
+  }
+
+  @Test public void serverStreamingMessage() throws IOException {
+    WebSocketListener serverListener = new EmptyWebSocketListener() {
+      @Override public void onOpen(WebSocket webSocket, Request request, Response response)
+          throws IOException {
+        BufferedSink sink = webSocket.newMessageSink(TEXT);
+        sink.writeUtf8("Hello, ").flush();
+        sink.writeUtf8("WebSockets!").flush();
+        sink.close();
+      }
+    };
+    server.enqueue(new MockResponse().withWebSocketUpgrade(serverListener));
+
+    awaitCall();
+    listener.assertTextMessage("Hello, WebSockets!");
+  }
+
   @Test public void okButNotOk() {
     server.enqueue(new MockResponse());
     awaitCall();
@@ -167,4 +230,23 @@ private RecordedResponse awaitCall() {
     return new RecordedResponse(request, responseRef.get(), webSocketRef.get(), null,
         failureRef.get());
   }
+
+  private static class EmptyWebSocketListener implements WebSocketListener {
+    @Override public void onOpen(WebSocket webSocket, Request request, Response response)
+        throws IOException {
+    }
+
+    @Override public void onMessage(BufferedSource payload, WebSocket.PayloadType type)
+        throws IOException {
+    }
+
+    @Override public void onPong(Buffer payload) {
+    }
+
+    @Override public void onClose(int code, String reason) {
+    }
+
+    @Override public void onFailure(IOException e) {
+    }
+  }
 }
diff --git a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/ws/WebSocketRecorder.java b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/ws/WebSocketRecorder.java
index c2000d4880..05b8480485 100644
--- a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/ws/WebSocketRecorder.java
+++ b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/ws/WebSocketRecorder.java
@@ -18,8 +18,9 @@
 import com.squareup.okhttp.Request;
 import com.squareup.okhttp.Response;
 import java.io.IOException;
-import java.util.ArrayDeque;
-import java.util.Deque;
+import java.util.concurrent.BlockingQueue;
+import java.util.concurrent.LinkedBlockingQueue;
+import java.util.concurrent.TimeUnit;
 import okio.Buffer;
 import okio.BufferedSource;
 
@@ -34,7 +35,7 @@
     void onMessage(BufferedSource payload, WebSocket.PayloadType type) throws IOException;
   }
 
-  private final Deque<Object> events = new ArrayDeque<>();
+  private final BlockingQueue<Object> events = new LinkedBlockingQueue<>();
   private MessageDelegate delegate;
 
   /** Sets a delegate for the next call to {@link #onMessage}. Cleared after invoked. */
@@ -43,7 +44,6 @@ public void setNextMessageDelegate(MessageDelegate delegate) {
   }
 
   @Override public void onOpen(WebSocket webSocket, Request request, Response response) {
-    throw new AssertionError();
   }
 
   @Override public void onMessage(BufferedSource source, WebSocket.PayloadType type)
@@ -75,32 +75,40 @@ public void setNextMessageDelegate(MessageDelegate delegate) {
     events.add(e);
   }
 
+  private Object nextEvent() {
+    try {
+      return events.poll(10, TimeUnit.SECONDS);
+    } catch (InterruptedException e) {
+      throw new AssertionError(e);
+    }
+  }
+
   public void assertTextMessage(String payload) {
     Message message = new Message(TEXT);
     message.buffer.writeUtf8(payload);
-    assertEquals(message, events.pollFirst());
+    assertEquals(message, nextEvent());
   }
 
   public void assertBinaryMessage(byte[] payload) {
     Message message = new Message(BINARY);
     message.buffer.write(payload);
-    assertEquals(message, events.pollFirst());
+    assertEquals(message, nextEvent());
   }
 
   public void assertPing(Buffer payload) {
-    assertEquals(new Ping(payload), events.pollFirst());
+    assertEquals(new Ping(payload), nextEvent());
   }
 
   public void assertPong(Buffer payload) {
-    assertEquals(new Pong(payload), events.pollFirst());
+    assertEquals(new Pong(payload), nextEvent());
   }
 
   public void assertClose(int code, String reason) {
-    assertEquals(new Close(code, reason), events.pollFirst());
+      assertEquals(new Close(code, reason), nextEvent());
   }
 
   public void assertFailure(Class<? extends IOException> cls, String message) {
-    Object event = events.pollFirst();
+    Object event = nextEvent();
     String errorMessage =
         "Expected [" + cls.getName() + ": " + message + "] but was [" + event + "].";
     assertNotNull(errorMessage, event);
diff --git a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/ws/WebSocketWriterTest.java b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/ws/WebSocketWriterTest.java
index 1134e45151..141d9ca4a3 100644
--- a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/ws/WebSocketWriterTest.java
+++ b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/ws/WebSocketWriterTest.java
@@ -25,9 +25,9 @@
 import org.junit.After;
 import org.junit.Test;
 
-import static com.squareup.okhttp.internal.ws.Protocol.toggleMask;
 import static com.squareup.okhttp.internal.ws.WebSocket.PayloadType.BINARY;
 import static com.squareup.okhttp.internal.ws.WebSocket.PayloadType.TEXT;
+import static com.squareup.okhttp.internal.ws.WebSocketProtocol.toggleMask;
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.fail;
 
diff --git a/okhttp-urlconnection/src/main/java/com/squareup/okhttp/OkUrlFactory.java b/okhttp-urlconnection/src/main/java/com/squareup/okhttp/OkUrlFactory.java
index 2c5f95ff79..4b34559e4c 100644
--- a/okhttp-urlconnection/src/main/java/com/squareup/okhttp/OkUrlFactory.java
+++ b/okhttp-urlconnection/src/main/java/com/squareup/okhttp/OkUrlFactory.java
@@ -15,13 +15,11 @@
  */
 package com.squareup.okhttp;
 
-import com.squareup.okhttp.internal.InternalCache;
-import com.squareup.okhttp.internal.huc.CacheAdapter;
 import com.squareup.okhttp.internal.huc.HttpURLConnectionImpl;
 import com.squareup.okhttp.internal.huc.HttpsURLConnectionImpl;
+
 import java.net.HttpURLConnection;
 import java.net.Proxy;
-import java.net.ResponseCache;
 import java.net.URL;
 import java.net.URLConnection;
 import java.net.URLStreamHandler;
@@ -38,17 +36,6 @@ public OkHttpClient client() {
     return client;
   }
 
-  /** Sets the response cache to be used to read and write cached responses. */
-  OkUrlFactory setResponseCache(ResponseCache responseCache) {
-    client.setInternalCache(responseCache != null ? new CacheAdapter(responseCache) : null);
-    return this;
-  }
-
-  ResponseCache getResponseCache() {
-    InternalCache cache = client.internalCache();
-    return cache instanceof CacheAdapter ? ((CacheAdapter) cache).getDelegate() : null;
-  }
-
   /**
    * Returns a copy of this stream handler factory that includes a shallow copy
    * of the internal {@linkplain OkHttpClient HTTP client}.
diff --git a/okhttp-urlconnection/src/test/java/com/squareup/okhttp/UrlConnectionCacheTest.java b/okhttp-urlconnection/src/test/java/com/squareup/okhttp/UrlConnectionCacheTest.java
index 79d73f4eef..db0ed8fa6c 100644
--- a/okhttp-urlconnection/src/test/java/com/squareup/okhttp/UrlConnectionCacheTest.java
+++ b/okhttp-urlconnection/src/test/java/com/squareup/okhttp/UrlConnectionCacheTest.java
@@ -16,12 +16,27 @@
 
 package com.squareup.okhttp;
 
+import com.squareup.okhttp.internal.Internal;
 import com.squareup.okhttp.internal.SslContextBuilder;
 import com.squareup.okhttp.internal.Util;
 import com.squareup.okhttp.mockwebserver.MockResponse;
 import com.squareup.okhttp.mockwebserver.MockWebServer;
 import com.squareup.okhttp.mockwebserver.RecordedRequest;
 import com.squareup.okhttp.mockwebserver.rule.MockWebServerRule;
+import okio.Buffer;
+import okio.BufferedSink;
+import okio.GzipSink;
+import okio.Okio;
+import org.junit.After;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.rules.TemporaryFolder;
+
+import javax.net.ssl.HostnameVerifier;
+import javax.net.ssl.HttpsURLConnection;
+import javax.net.ssl.SSLContext;
+import javax.net.ssl.SSLSession;
 import java.io.BufferedReader;
 import java.io.File;
 import java.io.FileNotFoundException;
@@ -43,24 +58,10 @@
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.Date;
-import java.util.Iterator;
 import java.util.List;
 import java.util.Locale;
 import java.util.TimeZone;
 import java.util.concurrent.TimeUnit;
-import javax.net.ssl.HostnameVerifier;
-import javax.net.ssl.HttpsURLConnection;
-import javax.net.ssl.SSLContext;
-import javax.net.ssl.SSLSession;
-import okio.Buffer;
-import okio.BufferedSink;
-import okio.GzipSink;
-import okio.Okio;
-import org.junit.After;
-import org.junit.Before;
-import org.junit.Rule;
-import org.junit.Test;
-import org.junit.rules.TemporaryFolder;
 
 import static com.squareup.okhttp.mockwebserver.SocketPolicy.DISCONNECT_AT_END;
 import static org.junit.Assert.assertEquals;
@@ -107,7 +108,6 @@
 
   @Test public void responseCacheAccessWithOkHttpMember() throws IOException {
     assertSame(cache, client.client().getCache());
-    assertNull(client.getResponseCache());
   }
 
   /**
@@ -115,48 +115,57 @@
    * http://www.w3.org/Protocols/rfc2616/rfc2616-sec13.html#sec13.4
    */
   @Test public void responseCachingByResponseCode() throws Exception {
-    // Test each documented HTTP/1.1 code, plus the first unused value in each range.
-    // http://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html
-
-    // We can't test 100 because it's not really a response.
-    // assertCached(false, 100);
-    assertCached(false, 101);
-    assertCached(false, 102);
-    assertCached(true, 200);
-    assertCached(false, 201);
-    assertCached(false, 202);
-    assertCached(true, 203);
-    assertCached(false, 204);
-    assertCached(false, 205);
-    assertCached(false, 206); // we don't cache partial responses
-    assertCached(false, 207);
-    assertCached(true, 300);
-    assertCached(true, 301);
-    assertCached(true, 302);
-    assertCached(false, 303);
-    assertCached(false, 304);
-    assertCached(false, 305);
-    assertCached(false, 306);
-    assertCached(true, 307);
-    assertCached(true, 308);
-    for (int i = 400; i <= 406; ++i) {
-      assertCached(false, i);
-    }
-    // (See test_responseCaching_407.)
-    assertCached(false, 408);
-    assertCached(false, 409);
-    // (See test_responseCaching_410.)
-    for (int i = 411; i <= 418; ++i) {
-      assertCached(false, i);
-    }
-    for (int i = 500; i <= 506; ++i) {
-      assertCached(false, i);
-    }
-  }
-
-  @Test public void responseCaching_410() throws Exception {
-    // the HTTP spec permits caching 410s, but the RI doesn't.
-    assertCached(true, 410);
+      // Test each documented HTTP/1.1 code, plus the first unused value in each range.
+      // http://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html
+
+      // We can't test 100 because it's not really a response.
+      // assertCached(false, 100);
+      assertCached(false, 101);
+      assertCached(false, 102);
+      assertCached(true,  200);
+      assertCached(false, 201);
+      assertCached(false, 202);
+      assertCached(true,  203);
+      assertCached(true,  204);
+      assertCached(false, 205);
+      assertCached(false, 206); //Electing to not cache partial responses
+      assertCached(false, 207);
+      assertCached(true,  300);
+      assertCached(true,  301);
+      assertCached(true,  302);
+      assertCached(false, 303);
+      assertCached(false, 304);
+      assertCached(false, 305);
+      assertCached(false, 306);
+      assertCached(true,  307);
+      assertCached(true,  308);
+      assertCached(false, 400);
+      assertCached(false, 401);
+      assertCached(false, 402);
+      assertCached(false, 403);
+      assertCached(true,  404);
+      assertCached(true,  405);
+      assertCached(false, 406);
+      assertCached(false, 408);
+      assertCached(false, 409);
+      // the HTTP spec permits caching 410s, but the RI doesn't.
+      assertCached(true,  410);
+      assertCached(false, 411);
+      assertCached(false, 412);
+      assertCached(false, 413);
+      assertCached(true,  414);
+      assertCached(false, 415);
+      assertCached(false, 416);
+      assertCached(false, 417);
+      assertCached(false, 418);
+
+      assertCached(false, 500);
+      assertCached(true,  501);
+      assertCached(false, 502);
+      assertCached(false, 503);
+      assertCached(false, 504);
+      assertCached(false, 505);
+      assertCached(false, 506);
   }
 
   private void assertCached(boolean shouldPut, int responseCode) throws Exception {
@@ -173,7 +182,7 @@ private void assertCached(boolean shouldPut, int responseCode) throws Exception
       response.addHeader("WWW-Authenticate: Basic realm=\"protected area\"");
     }
     server.enqueue(response);
-    server.play();
+    server.start();
 
     URL url = server.getUrl("/");
     HttpURLConnection conn = client.open(url);
@@ -484,8 +493,7 @@ private void testClientPrematureDisconnect(TransferKind transferKind) throws IOE
     RecordedRequest conditionalRequest = assertConditionallyCached(
         new MockResponse().addHeader("Last-Modified: " + lastModifiedDate)
             .addHeader("Date: " + formatDate(-15, TimeUnit.SECONDS)));
-    List<String> headers = conditionalRequest.getHeaders();
-    assertTrue(headers.contains("If-Modified-Since: " + lastModifiedDate));
+    assertEquals(lastModifiedDate, conditionalRequest.getHeader("If-Modified-Since"));
   }
 
   @Test public void defaultExpirationDateFullyCachedForMoreThan24Hours() throws Exception {
@@ -521,8 +529,7 @@ private void testClientPrematureDisconnect(TransferKind transferKind) throws IOE
     RecordedRequest conditionalRequest = assertConditionallyCached(
         new MockResponse().addHeader("Last-Modified: " + lastModifiedDate)
             .addHeader("Expires: " + formatDate(-1, TimeUnit.HOURS)));
-    List<String> headers = conditionalRequest.getHeaders();
-    assertTrue(headers.contains("If-Modified-Since: " + lastModifiedDate));
+    assertEquals(lastModifiedDate, conditionalRequest.getHeader("If-Modified-Since"));
   }
 
   @Test public void expirationDateInThePastWithNoLastModifiedHeader() throws Exception {
@@ -545,8 +552,7 @@ private void testClientPrematureDisconnect(TransferKind transferKind) throws IOE
         new MockResponse().addHeader("Date: " + formatDate(-120, TimeUnit.SECONDS))
             .addHeader("Last-Modified: " + lastModifiedDate)
             .addHeader("Cache-Control: max-age=60"));
-    List<String> headers = conditionalRequest.getHeaders();
-    assertTrue(headers.contains("If-Modified-Since: " + lastModifiedDate));
+    assertEquals(lastModifiedDate, conditionalRequest.getHeader("If-Modified-Since"));
   }
 
   @Test public void maxAgeInThePastWithDateHeaderButNoLastModifiedHeader() throws Exception {
@@ -701,7 +707,7 @@ private void testMethodInvalidates(String requestMethod) throws Exception {
   @Test public void etag() throws Exception {
     RecordedRequest conditionalRequest =
         assertConditionallyCached(new MockResponse().addHeader("ETag: v1"));
-    assertTrue(conditionalRequest.getHeaders().contains("If-None-Match: v1"));
+    assertEquals("v1", conditionalRequest.getHeader("If-None-Match"));
   }
 
   @Test public void etagAndExpirationDateInThePast() throws Exception {
@@ -710,9 +716,8 @@ private void testMethodInvalidates(String requestMethod) throws Exception {
         new MockResponse().addHeader("ETag: v1")
             .addHeader("Last-Modified: " + lastModifiedDate)
             .addHeader("Expires: " + formatDate(-1, TimeUnit.HOURS)));
-    List<String> headers = conditionalRequest.getHeaders();
-    assertTrue(headers.contains("If-None-Match: v1"));
-    assertTrue(headers.contains("If-Modified-Since: " + lastModifiedDate));
+    assertEquals("v1", conditionalRequest.getHeader("If-None-Match"));
+    assertNull(conditionalRequest.getHeader("If-Modified-Since"));
   }
 
   @Test public void etagAndExpirationDateInTheFuture() throws Exception {
@@ -731,8 +736,7 @@ private void testMethodInvalidates(String requestMethod) throws Exception {
         new MockResponse().addHeader("Last-Modified: " + lastModifiedDate)
             .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS))
             .addHeader("Cache-Control: no-cache"));
-    List<String> headers = conditionalRequest.getHeaders();
-    assertTrue(headers.contains("If-Modified-Since: " + lastModifiedDate));
+    assertEquals(lastModifiedDate, conditionalRequest.getHeader("If-Modified-Since"));
   }
 
   @Test public void pragmaNoCache() throws Exception {
@@ -745,8 +749,7 @@ private void testMethodInvalidates(String requestMethod) throws Exception {
         new MockResponse().addHeader("Last-Modified: " + lastModifiedDate)
             .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS))
             .addHeader("Pragma: no-cache"));
-    List<String> headers = conditionalRequest.getHeaders();
-    assertTrue(headers.contains("If-Modified-Since: " + lastModifiedDate));
+    assertEquals(lastModifiedDate, conditionalRequest.getHeader("If-Modified-Since"));
   }
 
   @Test public void cacheControlNoStore() throws Exception {
@@ -1009,9 +1012,8 @@ private void assertNonIdentityEncodingCached(MockResponse response) throws Excep
     String ifModifiedSinceDate = formatDate(-24, TimeUnit.HOURS);
     RecordedRequest request =
         assertClientSuppliedCondition(response, "If-Modified-Since", ifModifiedSinceDate);
-    List<String> headers = request.getHeaders();
-    assertTrue(headers.contains("If-Modified-Since: " + ifModifiedSinceDate));
-    assertFalse(headers.contains("If-None-Match: v3"));
+    assertEquals(ifModifiedSinceDate, request.getHeader("If-Modified-Since"));
+    assertNull(request.getHeader("If-None-Match"));
   }
 
   @Test public void clientSuppliedIfNoneMatchSinceWithCachedResult() throws Exception {
@@ -1020,9 +1022,8 @@ private void assertNonIdentityEncodingCached(MockResponse response) throws Excep
         .addHeader("Date: " + formatDate(-2, TimeUnit.MINUTES))
         .addHeader("Cache-Control: max-age=0");
     RecordedRequest request = assertClientSuppliedCondition(response, "If-None-Match", "v1");
-    List<String> headers = request.getHeaders();
-    assertTrue(headers.contains("If-None-Match: v1"));
-    assertFalse(headers.contains("If-Modified-Since: " + lastModifiedDate));
+    assertEquals("v1", request.getHeader("If-None-Match"));
+    assertNull(request.getHeader("If-Modified-Since"));
   }
 
   private RecordedRequest assertClientSuppliedCondition(MockResponse seed, String conditionName,
@@ -1508,9 +1509,9 @@ public void assertCookies(URL url, String... expectedCookies) throws Exception {
 
   @Test public void cachePlusRange() throws Exception {
     assertNotCached(new MockResponse().setResponseCode(HttpURLConnection.HTTP_PARTIAL)
-        .addHeader("Date: " + formatDate(0, TimeUnit.HOURS))
-        .addHeader("Content-Range: bytes 100-100/200")
-        .addHeader("Cache-Control: max-age=60"));
+            .addHeader("Date: " + formatDate(0, TimeUnit.HOURS))
+            .addHeader("Content-Range: bytes 100-100/200")
+            .addHeader("Cache-Control: max-age=60"));
   }
 
   @Test public void conditionalHitUpdatesCache() throws Exception {
@@ -1584,10 +1585,10 @@ public void assertCookies(URL url, String... expectedCookies) throws Exception {
   }
 
   @Test public void emptyResponseHeaderNameFromCacheIsLenient() throws Exception {
-    server.enqueue(new MockResponse()
-        .addHeader("Cache-Control: max-age=120")
-        .addHeader(": A")
-        .setBody("body"));
+    Headers.Builder headers = new Headers.Builder()
+        .add("Cache-Control: max-age=120");
+    Internal.instance.addLenient(headers, ": A");
+    server.enqueue(new MockResponse().setHeaders(headers.build()).setBody("body"));
 
     HttpURLConnection connection = client.open(server.getUrl("/"));
     assertEquals("A", connection.getHeaderField(""));
@@ -1743,12 +1744,11 @@ private void assertFullyCached(MockResponse response) throws Exception {
    */
   private MockResponse truncateViolently(MockResponse response, int numBytesToKeep) {
     response.setSocketPolicy(DISCONNECT_AT_END);
-    List<String> headers = new ArrayList<>(response.getHeaders());
+    Headers headers = response.getHeaders();
     Buffer truncatedBody = new Buffer();
     truncatedBody.write(response.getBody(), numBytesToKeep);
     response.setBody(truncatedBody);
-    response.getHeaders().clear();
-    response.getHeaders().addAll(headers);
+    response.setHeaders(headers);
     return response;
   }
 
@@ -1810,12 +1810,7 @@ private void assertGatewayTimeout(HttpURLConnection connection) throws IOExcepti
       @Override void setBody(MockResponse response, Buffer content, int chunkSize) {
         response.setBody(content);
         response.setSocketPolicy(DISCONNECT_AT_END);
-        for (Iterator<String> h = response.getHeaders().iterator(); h.hasNext(); ) {
-          if (h.next().startsWith("Content-Length:")) {
-            h.remove();
-            break;
-          }
-        }
+        response.removeHeader("Content-Length");
       }
     };
 
diff --git a/okhttp-urlconnection/src/test/java/com/squareup/okhttp/internal/huc/URLEncodingTest.java b/okhttp-urlconnection/src/test/java/com/squareup/okhttp/internal/huc/URLEncodingTest.java
index 4c5f28c8bf..5a4ed10ac2 100644
--- a/okhttp-urlconnection/src/test/java/com/squareup/okhttp/internal/huc/URLEncodingTest.java
+++ b/okhttp-urlconnection/src/test/java/com/squareup/okhttp/internal/huc/URLEncodingTest.java
@@ -16,10 +16,15 @@
 
 package com.squareup.okhttp.internal.huc;
 
-import com.squareup.okhttp.AbstractResponseCache;
 import com.squareup.okhttp.OkHttpClient;
 import com.squareup.okhttp.OkUrlFactory;
+import com.squareup.okhttp.Request;
+import com.squareup.okhttp.Response;
 import com.squareup.okhttp.internal.Internal;
+import com.squareup.okhttp.internal.InternalCache;
+import com.squareup.okhttp.internal.http.CacheRequest;
+import com.squareup.okhttp.internal.http.CacheStrategy;
+
 import java.io.IOException;
 import java.net.CacheResponse;
 import java.net.HttpURLConnection;
@@ -124,13 +129,38 @@ private URI backdoorUrlToUri(URL url) throws Exception {
     final AtomicReference<URI> uriReference = new AtomicReference<>();
 
     OkHttpClient client = new OkHttpClient();
-    Internal.instance.setCache(client, new CacheAdapter(new AbstractResponseCache() {
-      @Override public CacheResponse get(URI uri, String requestMethod,
-          Map<String, List<String>> requestHeaders) throws IOException {
-        uriReference.set(uri);
+    Internal.instance.setCache(client, new InternalCache() {
+      @Override
+      public Response get(Request request) throws IOException {
+        uriReference.set(request.uri());
         throw new UnsupportedOperationException();
       }
-    }));
+
+      @Override
+      public CacheRequest put(Response response) throws IOException {
+        return null;
+      }
+
+      @Override
+      public void remove(Request request) throws IOException {
+
+      }
+
+      @Override
+      public void update(Response cached, Response network) throws IOException {
+
+      }
+
+      @Override
+      public void trackConditionalCacheHit() {
+
+      }
+
+      @Override
+      public void trackResponse(CacheStrategy cacheStrategy) {
+
+      }
+    });
 
     try {
       HttpURLConnection connection = new OkUrlFactory(client).open(url);
diff --git a/okhttp/src/main/java/com/squareup/okhttp/Cache.java b/okhttp/src/main/java/com/squareup/okhttp/Cache.java
index 231a664362..2b98355e8c 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/Cache.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/Cache.java
@@ -138,8 +138,8 @@
   private int hitCount;
   private int requestCount;
 
-  public Cache(File directory, long maxSize) throws IOException {
-    cache = DiskLruCache.open(directory, VERSION, ENTRY_COUNT, maxSize);
+  public Cache(File directory, long maxSize) {
+    cache = DiskLruCache.create(directory, VERSION, ENTRY_COUNT, maxSize);
   }
 
   private static String urlToKey(Request request) {
@@ -269,7 +269,7 @@ public void evictAll() throws IOException {
    * <p>The iterator supports {@linkplain Iterator#remove}. Removing a URL from the iterator evicts
    * the corresponding response from the cache. Use this to evict selected responses.
    */
-  public Iterator<String> urls() {
+  public Iterator<String> urls() throws IOException {
     return new Iterator<String>() {
       final Iterator<DiskLruCache.Snapshot> delegate = cache.snapshots();
 
@@ -320,7 +320,7 @@ public synchronized int getWriteSuccessCount() {
     return writeSuccessCount;
   }
 
-  public long getSize() {
+  public long getSize() throws IOException {
     return cache.size();
   }
 
diff --git a/okhttp/src/main/java/com/squareup/okhttp/CacheControl.java b/okhttp/src/main/java/com/squareup/okhttp/CacheControl.java
index 36d2ff6f04..2ee8982b0c 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/CacheControl.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/CacheControl.java
@@ -34,6 +34,7 @@
   private final boolean noStore;
   private final int maxAgeSeconds;
   private final int sMaxAgeSeconds;
+  private final boolean isPrivate;
   private final boolean isPublic;
   private final boolean mustRevalidate;
   private final int maxStaleSeconds;
@@ -41,19 +42,23 @@
   private final boolean onlyIfCached;
   private final boolean noTransform;
 
+  String headerValue; // Lazily computed, if absent.
+
   private CacheControl(boolean noCache, boolean noStore, int maxAgeSeconds, int sMaxAgeSeconds,
-      boolean isPublic, boolean mustRevalidate, int maxStaleSeconds, int minFreshSeconds,
-      boolean onlyIfCached, boolean noTransform) {
+      boolean isPrivate, boolean isPublic, boolean mustRevalidate, int maxStaleSeconds,
+      int minFreshSeconds, boolean onlyIfCached, boolean noTransform, String headerValue) {
     this.noCache = noCache;
     this.noStore = noStore;
     this.maxAgeSeconds = maxAgeSeconds;
     this.sMaxAgeSeconds = sMaxAgeSeconds;
+    this.isPrivate = isPrivate;
     this.isPublic = isPublic;
     this.mustRevalidate = mustRevalidate;
     this.maxStaleSeconds = maxStaleSeconds;
     this.minFreshSeconds = minFreshSeconds;
     this.onlyIfCached = onlyIfCached;
     this.noTransform = noTransform;
+    this.headerValue = headerValue;
   }
 
   private CacheControl(Builder builder) {
@@ -61,6 +66,7 @@ private CacheControl(Builder builder) {
     this.noStore = builder.noStore;
     this.maxAgeSeconds = builder.maxAgeSeconds;
     this.sMaxAgeSeconds = -1;
+    this.isPrivate = false;
     this.isPublic = false;
     this.mustRevalidate = false;
     this.maxStaleSeconds = builder.maxStaleSeconds;
@@ -103,6 +109,10 @@ public int sMaxAgeSeconds() {
     return sMaxAgeSeconds;
   }
 
+  public boolean isPrivate() {
+    return isPrivate;
+  }
+
   public boolean isPublic() {
     return isPublic;
   }
@@ -143,6 +153,7 @@ public static CacheControl parse(Headers headers) {
     boolean noStore = false;
     int maxAgeSeconds = -1;
     int sMaxAgeSeconds = -1;
+    boolean isPrivate = false;
     boolean isPublic = false;
     boolean mustRevalidate = false;
     int maxStaleSeconds = -1;
@@ -150,40 +161,54 @@ public static CacheControl parse(Headers headers) {
     boolean onlyIfCached = false;
     boolean noTransform = false;
 
+    boolean canUseHeaderValue = true;
+    String headerValue = null;
+
     for (int i = 0, size = headers.size(); i < size; i++) {
-      if (!headers.name(i).equalsIgnoreCase("Cache-Control")
-          && !headers.name(i).equalsIgnoreCase("Pragma")) {
+      String name = headers.name(i);
+      String value = headers.value(i);
+
+      if (name.equalsIgnoreCase("Cache-Control")) {
+        if (headerValue != null) {
+          // Multiple cache-control headers means we can't use the raw value.
+          canUseHeaderValue = false;
+        } else {
+          headerValue = value;
+        }
+      } else if (name.equalsIgnoreCase("Pragma")) {
+        // Might specify additional cache-control params. We invalidate just in case.
+        canUseHeaderValue = false;
+      } else {
         continue;
       }
 
-      String string = headers.value(i);
       int pos = 0;
-      while (pos < string.length()) {
+      while (pos < value.length()) {
         int tokenStart = pos;
-        pos = HeaderParser.skipUntil(string, pos, "=,;");
-        String directive = string.substring(tokenStart, pos).trim();
+        pos = HeaderParser.skipUntil(value, pos, "=,;");
+        String directive = value.substring(tokenStart, pos).trim();
         String parameter;
 
-        if (pos == string.length() || string.charAt(pos) == ',' || string.charAt(pos) == ';') {
+        if (pos == value.length() || value.charAt(pos) == ',' || value.charAt(pos) == ';') {
           pos++; // consume ',' or ';' (if necessary)
           parameter = null;
         } else {
           pos++; // consume '='
-          pos = HeaderParser.skipWhitespace(string, pos);
+          pos = HeaderParser.skipWhitespace(value, pos);
 
           // quoted string
-          if (pos < string.length() && string.charAt(pos) == '\"') {
+          if (pos < value.length() && value.charAt(pos) == '\"') {
             pos++; // consume '"' open quote
             int parameterStart = pos;
-            pos = HeaderParser.skipUntil(string, pos, "\"");
-            parameter = string.substring(parameterStart, pos);
+            pos = HeaderParser.skipUntil(value, pos, "\"");
+            parameter = value.substring(parameterStart, pos);
             pos++; // consume '"' close quote (if necessary)
 
             // unquoted string
           } else {
             int parameterStart = pos;
-            pos = HeaderParser.skipUntil(string, pos, ",;");
-            parameter = string.substring(parameterStart, pos).trim();
+            pos = HeaderParser.skipUntil(value, pos, ",;");
+            parameter = value.substring(parameterStart, pos).trim();
           }
         }
 
@@ -195,6 +220,8 @@ public static CacheControl parse(Headers headers) {
           maxAgeSeconds = HeaderParser.parseSeconds(parameter, -1);
         } else if ("s-maxage".equalsIgnoreCase(directive)) {
           sMaxAgeSeconds = HeaderParser.parseSeconds(parameter, -1);
+        } else if ("private".equalsIgnoreCase(directive)) {
+          isPrivate = true;
         } else if ("public".equalsIgnoreCase(directive)) {
           isPublic = true;
         } else if ("must-revalidate".equalsIgnoreCase(directive)) {
@@ -211,16 +238,25 @@ public static CacheControl parse(Headers headers) {
       }
     }
 
-    return new CacheControl(noCache, noStore, maxAgeSeconds, sMaxAgeSeconds, isPublic,
-        mustRevalidate, maxStaleSeconds, minFreshSeconds, onlyIfCached, noTransform);
+    if (!canUseHeaderValue) {
+      headerValue = null;
+    }
+    return new CacheControl(noCache, noStore, maxAgeSeconds, sMaxAgeSeconds, isPrivate, isPublic,
+        mustRevalidate, maxStaleSeconds, minFreshSeconds, onlyIfCached, noTransform, headerValue);
   }
 
   @Override public String toString() {
+    String result = headerValue;
+    return result != null ? result : (headerValue = headerValue());
+  }
+
+  private String headerValue() {
     StringBuilder result = new StringBuilder();
     if (noCache) result.append("no-cache, ");
     if (noStore) result.append("no-store, ");
     if (maxAgeSeconds != -1) result.append("max-age=").append(maxAgeSeconds).append(", ");
     if (sMaxAgeSeconds != -1) result.append("s-maxage=").append(sMaxAgeSeconds).append(", ");
+    if (isPrivate) result.append("private, ");
     if (isPublic) result.append("public, ");
     if (mustRevalidate) result.append("must-revalidate, ");
     if (maxStaleSeconds != -1) result.append("max-stale=").append(maxStaleSeconds).append(", ");
diff --git a/okhttp/src/main/java/com/squareup/okhttp/CipherSuite.java b/okhttp/src/main/java/com/squareup/okhttp/CipherSuite.java
index c531e213b7..13344578be 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/CipherSuite.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/CipherSuite.java
@@ -367,7 +367,7 @@ private CipherSuite(
     this.javaName = javaName;
   }
 
-  static CipherSuite forJavaName(String javaName) {
+  public static CipherSuite forJavaName(String javaName) {
     return javaName.startsWith("SSL_")
         ? valueOf("TLS_" + javaName.substring(4))
         : valueOf(javaName);
diff --git a/okhttp/src/main/java/com/squareup/okhttp/Connection.java b/okhttp/src/main/java/com/squareup/okhttp/Connection.java
index 8d8586ea07..7dddc3a5cf 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/Connection.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/Connection.java
@@ -32,6 +32,7 @@
 import java.net.URL;
 import java.security.cert.X509Certificate;
 import java.util.concurrent.TimeUnit;
+import javax.net.ssl.SSLPeerUnverifiedException;
 import javax.net.ssl.SSLSocket;
 import okio.Source;
 
@@ -254,7 +255,7 @@ private void upgradeToTls(Request tunnelRequest, int readTimeout, int writeTimeo
     // Verify that the socket's certificates are acceptable for the target host.
     if (!route.address.hostnameVerifier.verify(route.address.uriHost, sslSocket.getSession())) {
       X509Certificate cert = (X509Certificate) sslSocket.getSession().getPeerCertificates()[0];
-      throw new IOException("Hostname " + route.address.uriHost + " not verified:"
+      throw new SSLPeerUnverifiedException("Hostname " + route.address.uriHost + " not verified:"
           + "\n    certificate: " + CertificatePinner.pin(cert)
           + "\n    DN: " + cert.getSubjectDN().getName()
           + "\n    subjectAltNames: " + OkHostnameVerifier.allSubjectAltNames(cert));
diff --git a/okhttp/src/main/java/com/squareup/okhttp/ConnectionPool.java b/okhttp/src/main/java/com/squareup/okhttp/ConnectionPool.java
index 16a6adbd13..ba664ea992 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/ConnectionPool.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/ConnectionPool.java
@@ -229,6 +229,7 @@ public void evictAll() {
     synchronized (this) {
       toEvict = new ArrayList<>(connections);
       connections.clear();
+      notifyAll();
     }
 
     for (int i = 0, size = toEvict.size(); i < size; i++) {
diff --git a/okhttp/src/main/java/com/squareup/okhttp/ConnectionSpec.java b/okhttp/src/main/java/com/squareup/okhttp/ConnectionSpec.java
index 862be0f44f..254bcb139a 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/ConnectionSpec.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/ConnectionSpec.java
@@ -60,22 +60,24 @@
   /** A backwards-compatible fallback connection for interop with obsolete servers. */
   public static final ConnectionSpec COMPATIBLE_TLS = new Builder(MODERN_TLS)
       .tlsVersions(TlsVersion.TLS_1_0)
+      .supportsTlsExtensions(true)
       .build();
 
   /** Unencrypted, unauthenticated connections for {@code http:} URLs. */
   public static final ConnectionSpec CLEARTEXT = new Builder(false).build();
 
   final boolean tls;
-  private final String[] cipherSuites;
-  private final String[] tlsVersions;
-  final boolean supportsTlsExtensions;
 
   /**
-   * Caches the subset of this spec that's supported by the host platform. It's possible that the
-   * platform hosts multiple implementations of {@link SSLSocket}, in which case this cache will be
-   * incorrect.
+   * Used if tls == true. The cipher suites to set on the SSLSocket. {@code null} means "use
+   * default set".
    */
-  private ConnectionSpec supportedSpec;
+  private final String[] cipherSuites;
+
+  /** Used if tls == true. The TLS protocol versions to use. */
+  private final String[] tlsVersions;
+
+  final boolean supportsTlsExtensions;
 
   private ConnectionSpec(Builder builder) {
     this.tls = builder.tls;
@@ -88,7 +90,14 @@ public boolean isTls() {
     return tls;
   }
 
+  /**
+   * Return the cipher suites to use with the connection. This method can return {@code null} if the
+   * ciphers enabled by default should be used.
+   */
   public List<CipherSuite> cipherSuites() {
+    if (cipherSuites == null) {
+      return null;
+    }
     CipherSuite[] result = new CipherSuite[cipherSuites.length];
     for (int i = 0; i < cipherSuites.length; i++) {
       result[i] = CipherSuite.forJavaName(cipherSuites[i]);
@@ -110,11 +119,7 @@ public boolean supportsTlsExtensions() {
 
   /** Applies this spec to {@code sslSocket} for {@code route}. */
   void apply(SSLSocket sslSocket, Route route) {
-    ConnectionSpec specToApply = supportedSpec;
-    if (specToApply == null) {
-      specToApply = supportedSpec(sslSocket);
-      supportedSpec = specToApply;
-    }
+    ConnectionSpec specToApply = supportedSpec(sslSocket);
 
     sslSocket.setEnabledProtocols(specToApply.tlsVersions);
 
@@ -128,7 +133,9 @@ void apply(SSLSocket sslSocket, Route route) {
 
       if (socketSupportsFallbackScsv) {
         // Add the SCSV cipher to the set of enabled ciphers iff it is supported.
-        String[] oldEnabledCipherSuites = cipherSuitesToEnable;
+        String[] oldEnabledCipherSuites = cipherSuitesToEnable != null
+            ? cipherSuitesToEnable
+            : sslSocket.getEnabledCipherSuites();
         String[] newEnabledCipherSuites = new String[oldEnabledCipherSuites.length + 1];
         System.arraycopy(oldEnabledCipherSuites, 0,
             newEnabledCipherSuites, 0, oldEnabledCipherSuites.length);
@@ -136,7 +143,10 @@ void apply(SSLSocket sslSocket, Route route) {
         cipherSuitesToEnable = newEnabledCipherSuites;
       }
     }
-    sslSocket.setEnabledCipherSuites(cipherSuitesToEnable);
+    // null means "use default set".
+    if (cipherSuitesToEnable != null) {
+      sslSocket.setEnabledCipherSuites(cipherSuitesToEnable);
+    }
 
     Platform platform = Platform.get();
     if (specToApply.supportsTlsExtensions) {
@@ -146,21 +156,27 @@ void apply(SSLSocket sslSocket, Route route) {
 
   /**
    * Returns a copy of this that omits cipher suites and TLS versions not
-   * supported by {@code sslSocket}.
+   * enabled by {@code sslSocket}.
    */
   private ConnectionSpec supportedSpec(SSLSocket sslSocket) {
-    List<String> supportedCipherSuites =
-        Util.intersect(cipherSuites, sslSocket.getSupportedCipherSuites());
-    List<String> supportedTlsVersions =
-        Util.intersect(tlsVersions, sslSocket.getSupportedProtocols());
+    String[] cipherSuitesToEnable = null;
+    if (cipherSuites != null) {
+      String[] cipherSuitesToSelectFrom = sslSocket.getEnabledCipherSuites();
+      cipherSuitesToEnable =
+          Util.intersect(String.class, cipherSuites, cipherSuitesToSelectFrom);
+    }
+
+    String[] protocolsToSelectFrom = sslSocket.getEnabledProtocols();
+    String[] tlsVersionsToEnable = Util.intersect(String.class, tlsVersions, protocolsToSelectFrom);
     return new Builder(this)
-        .cipherSuites(supportedCipherSuites.toArray(new String[supportedCipherSuites.size()]))
-        .tlsVersions(supportedTlsVersions.toArray(new String[supportedTlsVersions.size()]))
+        .cipherSuites(cipherSuitesToEnable)
+        .tlsVersions(tlsVersionsToEnable)
         .build();
   }
 
   @Override public boolean equals(Object other) {
     if (!(other instanceof ConnectionSpec)) return false;
+    if (other == this) return true;
 
     ConnectionSpec that = (ConnectionSpec) other;
     if (this.tls != that.tls) return false;
@@ -186,7 +202,9 @@ private ConnectionSpec supportedSpec(SSLSocket sslSocket) {
 
   @Override public String toString() {
     if (tls) {
-      return "ConnectionSpec(cipherSuites=" + cipherSuites()
+      List<CipherSuite> cipherSuites = cipherSuites();
+      String cipherSuitesString = cipherSuites == null ? "[use default]" : cipherSuites.toString();
+      return "ConnectionSpec(cipherSuites=" + cipherSuitesString
           + ", tlsVersions=" + tlsVersions()
           + ", supportsTlsExtensions=" + supportsTlsExtensions
           + ")";
@@ -201,7 +219,7 @@ private ConnectionSpec supportedSpec(SSLSocket sslSocket) {
     private String[] tlsVersions;
     private boolean supportsTlsExtensions;
 
-    private Builder(boolean tls) {
+    Builder(boolean tls) {
       this.tls = tls;
     }
 
@@ -220,12 +238,20 @@ public Builder cipherSuites(CipherSuite... cipherSuites) {
       for (int i = 0; i < cipherSuites.length; i++) {
         strings[i] = cipherSuites[i].javaName;
       }
-
-      return cipherSuites(strings);
+      this.cipherSuites = strings;
+      return this;
     }
 
-    Builder cipherSuites(String[] cipherSuites) {
-      this.cipherSuites = cipherSuites; // No defensive copy.
+    public Builder cipherSuites(String... cipherSuites) {
+      if (!tls) throw new IllegalStateException("no cipher suites for cleartext connections");
+
+      if (cipherSuites == null) {
+        this.cipherSuites = null;
+      } else {
+        // This makes a defensive copy!
+        this.cipherSuites = cipherSuites.clone();
+      }
+
       return this;
     }
 
@@ -237,12 +263,20 @@ public Builder tlsVersions(TlsVersion... tlsVersions) {
       for (int i = 0; i < tlsVersions.length; i++) {
         strings[i] = tlsVersions[i].javaName;
       }
-
-      return tlsVersions(strings);
+      this.tlsVersions = strings;
+      return this;
     }
 
-    Builder tlsVersions(String... tlsVersions) {
-      this.tlsVersions = tlsVersions; // No defensive copy.
+    public Builder tlsVersions(String... tlsVersions) {
+      if (!tls) throw new IllegalStateException("no TLS versions for cleartext connections");
+
+      if (tlsVersions == null) {
+        this.tlsVersions = null;
+      } else {
+        // This makes a defensive copy!
+        this.tlsVersions = tlsVersions.clone();
+      }
+
       return this;
     }
 
diff --git a/okhttp/src/main/java/com/squareup/okhttp/Dispatcher.java b/okhttp/src/main/java/com/squareup/okhttp/Dispatcher.java
index 95eb7b0ad3..a696c0ca7e 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/Dispatcher.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/Dispatcher.java
@@ -22,7 +22,7 @@
 import java.util.Deque;
 import java.util.Iterator;
 import java.util.concurrent.ExecutorService;
-import java.util.concurrent.LinkedBlockingQueue;
+import java.util.concurrent.SynchronousQueue;
 import java.util.concurrent.ThreadPoolExecutor;
 import java.util.concurrent.TimeUnit;
 
@@ -59,7 +59,7 @@ public Dispatcher() {
   public synchronized ExecutorService getExecutorService() {
     if (executorService == null) {
       executorService = new ThreadPoolExecutor(0, Integer.MAX_VALUE, 60, TimeUnit.SECONDS,
-          new LinkedBlockingQueue<Runnable>(), Util.threadFactory("OkHttp Dispatcher", false));
+          new SynchronousQueue<Runnable>(), Util.threadFactory("OkHttp Dispatcher", false));
     }
     return executorService;
   }
diff --git a/okhttp/src/main/java/com/squareup/okhttp/Headers.java b/okhttp/src/main/java/com/squareup/okhttp/Headers.java
index 5a5175594b..2be385ce2b 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/Headers.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/Headers.java
@@ -19,10 +19,10 @@
 
 import com.squareup.okhttp.internal.http.HttpDate;
 import java.util.ArrayList;
-import java.util.Arrays;
 import java.util.Collections;
 import java.util.Date;
 import java.util.List;
+import java.util.Map;
 import java.util.Set;
 import java.util.TreeSet;
 
@@ -118,7 +118,7 @@ public String value(int index) {
 
   public Builder newBuilder() {
     Builder result = new Builder();
-    result.namesAndValues.addAll(Arrays.asList(namesAndValues));
+    Collections.addAll(result.namesAndValues, namesAndValues);
     return result;
   }
 
@@ -168,6 +168,34 @@ public static Headers of(String... namesAndValues) {
     return new Headers(namesAndValues);
   }
 
+  /**
+   * Returns headers for the header names and values in the {@link Map}.
+   */
+  public static Headers of(Map<String, String> headers) {
+    if (headers == null) {
+      throw new IllegalArgumentException("Expected map with header names and values");
+    }
+
+    // Make a defensive copy and clean it up.
+    String[] namesAndValues = new String[headers.size() * 2];
+    int i = 0;
+    for (Map.Entry<String, String> header : headers.entrySet()) {
+      if (header.getKey() == null || header.getValue() == null) {
+        throw new IllegalArgumentException("Headers cannot be null");
+      }
+      String name = header.getKey().trim();
+      String value = header.getValue().trim();
+      if (name.length() == 0 || name.indexOf('\0') != -1 || value.indexOf('\0') != -1) {
+        throw new IllegalArgumentException("Unexpected header: " + name + ": " + value);
+      }
+      namesAndValues[i] = name;
+      namesAndValues[i + 1] = value;
+      i += 2;
+    }
+
+    return new Headers(namesAndValues);
+  }
+
   public static final class Builder {
     private final List<String> namesAndValues = new ArrayList<>(20);
 
diff --git a/okhttp/src/main/java/com/squareup/okhttp/OkHttpClient.java b/okhttp/src/main/java/com/squareup/okhttp/OkHttpClient.java
index 22da6d96be..a8b60dbad5 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/OkHttpClient.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/OkHttpClient.java
@@ -120,10 +120,6 @@
         connection.connectAndSetOwner(client, owner, request);
       }
 
-      @Override public TlsVersion tlsVersionForJavaName(String name) {
-        return TlsVersion.forJavaName(name);
-      }
-
       @Override
       public void callEnqueue(Call call, Callback responseCallback, boolean forWebSocket) {
         call.enqueue(responseCallback, forWebSocket);
@@ -207,7 +203,8 @@ private OkHttpClient(OkHttpClient okHttpClient) {
   }
 
   /**
-   * Sets the default connect timeout for new connections. A value of 0 means no timeout.
+   * Sets the default connect timeout for new connections. A value of 0 means no timeout, otherwise
+   * values must be between 1 and {@link Integer#MAX_VALUE} when converted to milliseconds.
    *
    * @see URLConnection#setConnectTimeout(int)
    */
@@ -216,6 +213,7 @@ public final void setConnectTimeout(long timeout, TimeUnit unit) {
     if (unit == null) throw new IllegalArgumentException("unit == null");
     long millis = unit.toMillis(timeout);
     if (millis > Integer.MAX_VALUE) throw new IllegalArgumentException("Timeout too large.");
+    if (millis == 0 && timeout > 0) throw new IllegalArgumentException("Timeout too small.");
     connectTimeout = (int) millis;
   }
 
@@ -225,7 +223,8 @@ public final int getConnectTimeout() {
   }
 
   /**
-   * Sets the default read timeout for new connections. A value of 0 means no timeout.
+   * Sets the default read timeout for new connections. A value of 0 means no timeout, otherwise
+   * values must be between 1 and {@link Integer#MAX_VALUE} when converted to milliseconds.
    *
    * @see URLConnection#setReadTimeout(int)
    */
@@ -234,6 +233,7 @@ public final void setReadTimeout(long timeout, TimeUnit unit) {
     if (unit == null) throw new IllegalArgumentException("unit == null");
     long millis = unit.toMillis(timeout);
     if (millis > Integer.MAX_VALUE) throw new IllegalArgumentException("Timeout too large.");
+    if (millis == 0 && timeout > 0) throw new IllegalArgumentException("Timeout too small.");
     readTimeout = (int) millis;
   }
 
@@ -243,13 +243,15 @@ public final int getReadTimeout() {
   }
 
   /**
-   * Sets the default write timeout for new connections. A value of 0 means no timeout.
+   * Sets the default write timeout for new connections. A value of 0 means no timeout, otherwise
+   * values must be between 1 and {@link Integer#MAX_VALUE} when converted to milliseconds.
    */
   public final void setWriteTimeout(long timeout, TimeUnit unit) {
     if (timeout < 0) throw new IllegalArgumentException("timeout < 0");
     if (unit == null) throw new IllegalArgumentException("unit == null");
     long millis = unit.toMillis(timeout);
     if (millis > Integer.MAX_VALUE) throw new IllegalArgumentException("Timeout too large.");
+    if (millis == 0 && timeout > 0) throw new IllegalArgumentException("Timeout too small.");
     writeTimeout = (int) millis;
   }
 
diff --git a/okhttp/src/main/java/com/squareup/okhttp/Request.java b/okhttp/src/main/java/com/squareup/okhttp/Request.java
index 890a34ad55..c40ada31ae 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/Request.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/Request.java
@@ -209,6 +209,10 @@ public Builder post(RequestBody body) {
       return method("POST", body);
     }
 
+    public Builder delete(RequestBody body) {
+      return method("DELETE", body);
+    }
+
     public Builder delete() {
       return method("DELETE", null);
     }
diff --git a/okhttp/src/main/java/com/squareup/okhttp/ResponseBody.java b/okhttp/src/main/java/com/squareup/okhttp/ResponseBody.java
index 57e3087d13..bdd98b4c69 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/ResponseBody.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/ResponseBody.java
@@ -37,13 +37,13 @@
    * Returns the number of bytes in that will returned by {@link #bytes}, or
    * {@link #byteStream}, or -1 if unknown.
    */
-  public abstract long contentLength();
+  public abstract long contentLength() throws IOException;
 
-  public final InputStream byteStream() {
+  public final InputStream byteStream() throws IOException {
     return source().inputStream();
   }
 
-  public abstract BufferedSource source();
+  public abstract BufferedSource source() throws IOException;
 
   public final byte[] bytes() throws IOException {
     long contentLength = contentLength();
@@ -69,7 +69,7 @@ public final InputStream byteStream() {
    * of the Content-Type header. If that header is either absent or lacks a
    * charset, this will attempt to decode the response body as UTF-8.
    */
-  public final Reader charStream() {
+  public final Reader charStream() throws IOException {
     Reader r = reader;
     return r != null ? r : (reader = new InputStreamReader(byteStream(), charset()));
   }
diff --git a/okhttp/src/main/java/com/squareup/okhttp/TlsVersion.java b/okhttp/src/main/java/com/squareup/okhttp/TlsVersion.java
index b33115ac3d..a8d7b9b311 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/TlsVersion.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/TlsVersion.java
@@ -34,7 +34,7 @@ private TlsVersion(String javaName) {
     this.javaName = javaName;
   }
 
-  static TlsVersion forJavaName(String javaName) {
+  public static TlsVersion forJavaName(String javaName) {
     switch (javaName) {
       case "TLSv1.2": return TLS_1_2;
       case "TLSv1.1": return TLS_1_1;
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/DiskLruCache.java b/okhttp/src/main/java/com/squareup/okhttp/internal/DiskLruCache.java
index cab1664932..8bddc3dac2 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/DiskLruCache.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/DiskLruCache.java
@@ -150,6 +150,10 @@
   private final LinkedHashMap<String, Entry> lruEntries = new LinkedHashMap<>(0, 0.75f, true);
   private int redundantOpCount;
 
+  // Must be read and written when synchronized on 'this'.
+  private boolean initialized;
+  private boolean closed;
+
   /**
    * To differentiate between old and current snapshots, each entry is given
    * a sequence number each time an edit is committed. A snapshot is stale if
@@ -162,8 +166,8 @@
   private final Runnable cleanupRunnable = new Runnable() {
     public void run() {
       synchronized (DiskLruCache.this) {
-        if (journalWriter == null) {
-          return; // Closed.
+        if (!initialized | closed) {
+          return; // Nothing to do
         }
         try {
           trimToSize();
@@ -191,6 +195,12 @@ public void run() {
 
   // Visible for testing.
   void initialize() throws IOException {
+    assert Thread.holdsLock(this);
+
+    if (initialized) {
+      return; // Already initialized.
+    }
+
     // If a bkp file exists, use it instead.
     if (journalFileBackup.exists()) {
       // If journal file also exists just delete backup file.
@@ -206,29 +216,31 @@ void initialize() throws IOException {
       try {
         readJournal();
         processJournal();
+        initialized = true;
         return;
       } catch (IOException journalIsCorrupt) {
         Platform.get().logW("DiskLruCache " + directory + " is corrupt: "
             + journalIsCorrupt.getMessage() + ", removing");
         delete();
+        closed = false;
       }
     }
 
     directory.mkdirs();
     rebuildJournal();
+
+    initialized = true;
   }
 
   /**
-   * Opens the cache in {@code directory}, creating a cache if none exists
-   * there.
+   * Create a cache which will reside in {@code directory}. This cache is lazily initialized on
+   * first access and will be created if it does not exist.
    *
    * @param directory a writable directory
    * @param valueCount the number of values per cache entry. Must be positive.
    * @param maxSize the maximum number of bytes this cache should use to store
-   * @throws IOException if reading or writing the cache directory fails
    */
-  public static DiskLruCache open(File directory, int appVersion, int valueCount, long maxSize)
-      throws IOException {
+  public static DiskLruCache create(File directory, int appVersion, int valueCount, long maxSize) {
     if (maxSize <= 0) {
       throw new IllegalArgumentException("maxSize <= 0");
     }
@@ -240,9 +252,7 @@ public static DiskLruCache open(File directory, int appVersion, int valueCount,
     Executor executor = new ThreadPoolExecutor(0, 1, 60L, TimeUnit.SECONDS,
         new LinkedBlockingQueue<Runnable>(), Util.threadFactory("OkHttp DiskLruCache", true));
 
-    DiskLruCache cache = new DiskLruCache(directory, appVersion, valueCount, maxSize, executor);
-    cache.initialize();
-    return cache;
+    return new DiskLruCache(directory, appVersion, valueCount, maxSize, executor);
   }
 
   private void readJournal() throws IOException {
@@ -410,6 +420,8 @@ private static void renameTo(File from, File to, boolean deleteDestination) thro
    * the head of the LRU queue.
    */
   public synchronized Snapshot get(String key) throws IOException {
+    initialize();
+
     checkNotClosed();
     validateKey(key);
     Entry entry = lruEntries.get(key);
@@ -436,6 +448,8 @@ public Editor edit(String key) throws IOException {
   }
 
   private synchronized Editor edit(String key, long expectedSequenceNumber) throws IOException {
+    initialize();
+
     checkNotClosed();
     validateKey(key);
     Entry entry = lruEntries.get(key);
@@ -478,7 +492,9 @@ public synchronized long getMaxSize() {
    */
   public synchronized void setMaxSize(long maxSize) {
     this.maxSize = maxSize;
-    executor.execute(cleanupRunnable);
+    if (initialized) {
+      executor.execute(cleanupRunnable);
+    }
   }
 
   /**
@@ -486,7 +502,8 @@ public synchronized void setMaxSize(long maxSize) {
    * this cache. This may be greater than the max size if a background
    * deletion is pending.
    */
-  public synchronized long size() {
+  public synchronized long size() throws IOException {
+    initialize();
     return size;
   }
 
@@ -568,6 +585,8 @@ private boolean journalRebuildRequired() {
    * @return true if an entry was removed.
    */
   public synchronized boolean remove(String key) throws IOException {
+    initialize();
+
     checkNotClosed();
     validateKey(key);
     Entry entry = lruEntries.get(key);
@@ -599,18 +618,20 @@ private boolean removeEntry(Entry entry) throws IOException {
   }
 
   /** Returns true if this cache has been closed. */
-  public boolean isClosed() {
-    return journalWriter == null;
+  public synchronized boolean isClosed() {
+    return closed;
   }
 
-  private void checkNotClosed() {
-    if (journalWriter == null) {
+  private synchronized void checkNotClosed() {
+    if (isClosed()) {
       throw new IllegalStateException("cache is closed");
     }
   }
 
   /** Force buffered operations to the filesystem. */
   public synchronized void flush() throws IOException {
+    if (!initialized) return;
+
     checkNotClosed();
     trimToSize();
     journalWriter.flush();
@@ -618,8 +639,9 @@ public synchronized void flush() throws IOException {
 
   /** Closes this cache. Stored values will remain on the filesystem. */
   public synchronized void close() throws IOException {
-    if (journalWriter == null) {
-      return; // Already closed.
+    if (!initialized || closed) {
+      closed = true;
+      return;
     }
     // Copying for safe iteration.
     for (Entry entry : lruEntries.values().toArray(new Entry[lruEntries.size()])) {
@@ -630,6 +652,7 @@ public synchronized void close() throws IOException {
     trimToSize();
     journalWriter.close();
     journalWriter = null;
+    closed = true;
   }
 
   private void trimToSize() throws IOException {
@@ -654,6 +677,7 @@ public void delete() throws IOException {
    * normally but their values will not be stored.
    */
   public synchronized void evictAll() throws IOException {
+    initialize();
     // Copying for safe iteration.
     for (Entry entry : lruEntries.values().toArray(new Entry[lruEntries.size()])) {
       removeEntry(entry);
@@ -668,14 +692,6 @@ private void validateKey(String key) {
     }
   }
 
-  private static String sourceToString(Source in) throws IOException {
-    try {
-      return Okio.buffer(in).readUtf8();
-    } finally {
-      Util.closeQuietly(in);
-    }
-  }
-
   /**
    * Returns an iterator over the cache's current entries. This iterator doesn't throw {@code
    * ConcurrentModificationException}, but if new entries are added while iterating, those new
@@ -691,7 +707,8 @@ private static String sourceToString(Source in) throws IOException {
    *
    * <p>The returned iterator supports {@link Iterator#remove}.
    */
-  public synchronized Iterator<Snapshot> snapshots() {
+  public synchronized Iterator<Snapshot> snapshots() throws IOException {
+    initialize();
     return new Iterator<Snapshot>() {
       /** Iterate a copy of the entries to defend against concurrent modification errors. */
       final Iterator<Entry> delegate = new ArrayList<>(lruEntries.values()).iterator();
@@ -707,7 +724,7 @@ private static String sourceToString(Source in) throws IOException {
 
         synchronized (DiskLruCache.this) {
           // If the cache is closed, truncate the iterator.
-          if (isClosed()) return false;
+          if (closed) return false;
 
           while (delegate.hasNext()) {
             Entry entry = delegate.next();
@@ -774,11 +791,6 @@ public Source getSource(int index) {
       return sources[index];
     }
 
-    /** Returns the string value for {@code index}. */
-    public String getString(int index) throws IOException {
-      return sourceToString(getSource(index));
-    }
-
     /** Returns the byte length of the value for {@code index}. */
     public long getLength(int index) {
       return lengths[index];
@@ -793,7 +805,7 @@ public void close() {
 
   private static final Sink NULL_SINK = new Sink() {
     @Override public void write(Buffer source, long byteCount) throws IOException {
-      // Eat all writes silently. Nom nom.
+      source.skip(byteCount);
     }
 
     @Override public void flush() throws IOException {
@@ -839,15 +851,6 @@ public Source newSource(int index) throws IOException {
       }
     }
 
-    /**
-     * Returns the last committed value as a string, or null if no value
-     * has been committed.
-     */
-    public String getString(int index) throws IOException {
-      Source source = newSource(index);
-      return source != null ? sourceToString(source) : null;
-    }
-
     /**
      * Returns a new unbuffered output stream to write the value at
      * {@code index}. If the underlying output stream encounters errors
@@ -881,13 +884,6 @@ public Sink newSink(int index) throws IOException {
       }
     }
 
-    /** Sets the value at {@code index} to {@code value}. */
-    public void set(int index, String value) throws IOException {
-      BufferedSink writer = Okio.buffer(newSink(index));
-      writer.writeUtf8(value);
-      writer.close();
-    }
-
     /**
      * Commits this edit so it is visible to readers.  This releases the
      * edit lock so another edit may be started on the same key.
@@ -1033,6 +1029,7 @@ Snapshot snapshot() {
       if (!Thread.holdsLock(DiskLruCache.this)) throw new AssertionError();
 
       Source[] sources = new Source[valueCount];
+      long[] lengths = this.lengths.clone(); // Defensive copy since these can be zeroed out.
       try {
         for (int i = 0; i < valueCount; i++) {
           sources[i] = Okio.source(cleanFiles[i]);
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/Internal.java b/okhttp/src/main/java/com/squareup/okhttp/internal/Internal.java
index 130631aee3..d806b483c2 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/Internal.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/Internal.java
@@ -23,7 +23,6 @@
 import com.squareup.okhttp.OkHttpClient;
 import com.squareup.okhttp.Protocol;
 import com.squareup.okhttp.Request;
-import com.squareup.okhttp.TlsVersion;
 import com.squareup.okhttp.internal.http.HttpEngine;
 import com.squareup.okhttp.internal.http.Transport;
 import java.io.IOException;
@@ -70,8 +69,6 @@ public abstract Transport newTransport(Connection connection, HttpEngine httpEng
   public abstract void connectAndSetOwner(OkHttpClient client, Connection connection,
       HttpEngine owner, Request request) throws IOException;
 
-  public abstract TlsVersion tlsVersionForJavaName(String name);
-
   // TODO delete the following when web sockets move into the main package.
   public abstract void callEnqueue(Call call, Callback responseCallback, boolean forWebSocket);
   public abstract void callEngineReleaseConnection(Call call) throws IOException;
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/Util.java b/okhttp/src/main/java/com/squareup/okhttp/internal/Util.java
index 6f081d230c..5f8e8cb281 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/Util.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/Util.java
@@ -21,6 +21,7 @@
 import java.io.IOException;
 import java.io.InterruptedIOException;
 import java.io.UnsupportedEncodingException;
+import java.lang.reflect.Array;
 import java.net.ServerSocket;
 import java.net.Socket;
 import java.net.URI;
@@ -45,9 +46,6 @@
   public static final byte[] EMPTY_BYTE_ARRAY = new byte[0];
   public static final String[] EMPTY_STRING_ARRAY = new String[0];
 
-  /** A cheap and type-safe constant for the US-ASCII Charset. */
-  public static final Charset US_ASCII = Charset.forName("US-ASCII");
-
   /** A cheap and type-safe constant for the UTF-8 Charset. */
   public static final Charset UTF_8 = Charset.forName("UTF-8");
 
@@ -269,10 +267,20 @@ public static ThreadFactory threadFactory(final String name, final boolean daemo
   }
 
   /**
-   * Returns a mutable copy of {@code first} containing only elements also in {@code second}. The
-   * returned elements are in the same order as in {@code first}.
+   * Returns an array containing containing only elements found in {@code first}  and also in
+   * {@code second}. The returned elements are in the same order as in {@code first}.
+   */
+  @SuppressWarnings("unchecked")
+  public static <T> T[] intersect(Class<T> arrayType, T[] first, T[] second) {
+    List<T> result = intersect(first, second);
+    return result.toArray((T[]) Array.newInstance(arrayType, result.size()));
+  }
+
+  /**
+   * Returns a list containing containing only elements found in {@code first}  and also in
+   * {@code second}. The returned elements are in the same order as in {@code first}.
    */
-  public static <T> List<T> intersect(T[] first, T[] second) {
+  private static <T> List<T> intersect(T[] first, T[] second) {
     List<T> result = new ArrayList<>();
     for (T a : first) {
       for (T b : second) {
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/http/CacheStrategy.java b/okhttp/src/main/java/com/squareup/okhttp/internal/http/CacheStrategy.java
index 69db3947f5..3f07edd7e1 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/http/CacheStrategy.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/http/CacheStrategy.java
@@ -4,16 +4,22 @@
 import com.squareup.okhttp.Headers;
 import com.squareup.okhttp.Request;
 import com.squareup.okhttp.Response;
+
 import java.util.Date;
 
 import static com.squareup.okhttp.internal.http.StatusLine.HTTP_PERM_REDIRECT;
 import static com.squareup.okhttp.internal.http.StatusLine.HTTP_TEMP_REDIRECT;
+import static java.net.HttpURLConnection.HTTP_BAD_METHOD;
 import static java.net.HttpURLConnection.HTTP_GONE;
 import static java.net.HttpURLConnection.HTTP_MOVED_PERM;
 import static java.net.HttpURLConnection.HTTP_MOVED_TEMP;
 import static java.net.HttpURLConnection.HTTP_MULT_CHOICE;
 import static java.net.HttpURLConnection.HTTP_NOT_AUTHORITATIVE;
+import static java.net.HttpURLConnection.HTTP_NOT_FOUND;
+import static java.net.HttpURLConnection.HTTP_NOT_IMPLEMENTED;
+import static java.net.HttpURLConnection.HTTP_NO_CONTENT;
 import static java.net.HttpURLConnection.HTTP_OK;
+import static java.net.HttpURLConnection.HTTP_REQ_TOO_LONG;
 import static java.util.concurrent.TimeUnit.SECONDS;
 
 /**
@@ -46,20 +52,27 @@ public static boolean isCacheable(Response response, Request request) {
     switch (response.code()) {
       case HTTP_OK:
       case HTTP_NOT_AUTHORITATIVE:
+      case HTTP_NO_CONTENT:
       case HTTP_MULT_CHOICE:
       case HTTP_MOVED_PERM:
+      case HTTP_NOT_FOUND:
+      case HTTP_BAD_METHOD:
       case HTTP_GONE:
+      case HTTP_REQ_TOO_LONG:
+      case HTTP_NOT_IMPLEMENTED:
       case HTTP_PERM_REDIRECT:
-        // These codes can be cached unless headers forbid it.
-        break;
+      // These codes can be cached unless headers forbid it.
+      break;
 
       case HTTP_MOVED_TEMP:
       case HTTP_TEMP_REDIRECT:
         // These codes can only be cached with the right response headers.
+        // http://tools.ietf.org/html/rfc7234#section-3
+        // s-maxage is not checked because OkHttp is a private cache that should ignore s-maxage.
         if (response.header("Expires") != null
             || response.cacheControl().maxAgeSeconds() != -1
-            || response.cacheControl().sMaxAgeSeconds() != -1
-            || response.cacheControl().isPublic()) {
+            || response.cacheControl().isPublic()
+            || response.cacheControl().isPrivate()) {
           break;
         }
         // Fall-through.
@@ -212,16 +225,14 @@ private CacheStrategy getCandidate() {
 
       Request.Builder conditionalRequestBuilder = request.newBuilder();
 
-      if (lastModified != null) {
+      if (etag != null) {
+        conditionalRequestBuilder.header("If-None-Match", etag);
+      } else if (lastModified != null) {
         conditionalRequestBuilder.header("If-Modified-Since", lastModifiedString);
       } else if (servedDate != null) {
         conditionalRequestBuilder.header("If-Modified-Since", servedDateString);
       }
 
-      if (etag != null) {
-        conditionalRequestBuilder.header("If-None-Match", etag);
-      }
-
       Request conditionalRequest = conditionalRequestBuilder.build();
       return hasConditions(conditionalRequest)
           ? new CacheStrategy(conditionalRequest, cacheResponse)
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpEngine.java b/okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpEngine.java
index d4d9b4cb1b..643fa09e53 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpEngine.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpEngine.java
@@ -18,7 +18,9 @@
 package com.squareup.okhttp.internal.http;
 
 import com.squareup.okhttp.Address;
+import com.squareup.okhttp.CertificatePinner;
 import com.squareup.okhttp.Connection;
+import com.squareup.okhttp.ConnectionPool;
 import com.squareup.okhttp.Headers;
 import com.squareup.okhttp.Interceptor;
 import com.squareup.okhttp.MediaType;
@@ -38,12 +40,15 @@
 import java.net.ProtocolException;
 import java.net.Proxy;
 import java.net.URL;
+import java.net.UnknownHostException;
 import java.security.cert.CertificateException;
 import java.util.Date;
 import java.util.List;
 import java.util.Map;
+import javax.net.ssl.HostnameVerifier;
 import javax.net.ssl.SSLHandshakeException;
 import javax.net.ssl.SSLPeerUnverifiedException;
+import javax.net.ssl.SSLSocketFactory;
 import okio.Buffer;
 import okio.BufferedSink;
 import okio.BufferedSource;
@@ -109,6 +114,7 @@
   final OkHttpClient client;
 
   private Connection connection;
+  private Address address;
   private RouteSelector routeSelector;
   private Route route;
   private final Response priorResponse;
@@ -232,7 +238,7 @@ public void sendRequest() throws IOException {
     if (networkRequest != null) {
       // Open a connection unless we inherited one from a redirect.
       if (connection == null) {
-        connect(networkRequest);
+        connect();
       }
 
       transport = Internal.instance.newTransport(connection, this);
@@ -302,17 +308,43 @@ private static Response stripBody(Response response) {
   }
 
   /** Connect to the origin server either directly or via a proxy. */
-  private void connect(Request request) throws IOException {
+  private void connect() throws IOException {
     if (connection != null) throw new IllegalStateException();
 
     if (routeSelector == null) {
-      routeSelector = RouteSelector.get(request, client);
+      address = createAddress(client, networkRequest);
+      routeSelector = RouteSelector.get(address, networkRequest, client);
     }
 
-    connection = routeSelector.next(this);
+    connection = nextConnection();
     route = connection.getRoute();
   }
 
+  /**
+   * Returns the next connection to attempt.
+   *
+   * @throws java.util.NoSuchElementException if there are no more routes to attempt.
+   */
+  private Connection nextConnection() throws IOException {
+    Connection connection = createNextConnection();
+    Internal.instance.connectAndSetOwner(client, connection, this, networkRequest);
+    return connection;
+  }
+
+  private Connection createNextConnection() throws IOException {
+    ConnectionPool pool = client.getConnectionPool();
+
+    // Always prefer pooled connections over new connections.
+    for (Connection pooled; (pooled = pool.get(address)) != null; ) {
+      if (networkRequest.method().equals("GET") || Internal.instance.isReadable(pooled)) {
+        return pooled;
+      }
+      pooled.getSocket().close();
+    }
+    Route route = routeSelector.next();
+    return new Connection(pool, route);
+  }
+
   /**
    * Called immediately before the transport transmits HTTP request headers.
    * This is used to observe the sent time should the request be cached.
@@ -368,7 +400,7 @@ public Connection getConnection() {
    */
   public HttpEngine recover(IOException e, Sink requestBodyOut) {
     if (routeSelector != null && connection != null) {
-      routeSelector.connectFailed(connection, e);
+      connectFailed(routeSelector, e);
     }
 
     boolean canRetryRequestBody = requestBodyOut == null || requestBodyOut instanceof RetryableSink;
@@ -386,6 +418,13 @@ public HttpEngine recover(IOException e, Sink requestBodyOut) {
         forWebSocket, connection, routeSelector, (RetryableSink) requestBodyOut, priorResponse);
   }
 
+  private void connectFailed(RouteSelector routeSelector, IOException e) {
+    // If this is a recycled connection, don't count its failure against the route.
+    if (Internal.instance.recycleCount(connection) > 0) return;
+    Route failedRoute = connection.getRoute();
+    routeSelector.connectFailed(failedRoute, e);
+  }
+
   public HttpEngine recover(IOException e) {
     return recover(e, requestBodyOut);
   }
@@ -1009,4 +1048,26 @@ public boolean sameConnection(URL followUp) {
         && getEffectivePort(url) == getEffectivePort(followUp)
         && url.getProtocol().equals(followUp.getProtocol());
   }
+
+  private static Address createAddress(OkHttpClient client, Request request)
+      throws UnknownHostException {
+    String uriHost = request.url().getHost();
+    if (uriHost == null || uriHost.length() == 0) {
+      throw new UnknownHostException(request.url().toString());
+    }
+
+    SSLSocketFactory sslSocketFactory = null;
+    HostnameVerifier hostnameVerifier = null;
+    CertificatePinner certificatePinner = null;
+    if (request.isHttps()) {
+      sslSocketFactory = client.getSslSocketFactory();
+      hostnameVerifier = client.getHostnameVerifier();
+      certificatePinner = client.getCertificatePinner();
+    }
+
+    return new Address(uriHost, getEffectivePort(request.url()),
+        client.getSocketFactory(), sslSocketFactory, hostnameVerifier, certificatePinner,
+        client.getAuthenticator(), client.getProxy(), client.getProtocols(),
+        client.getConnectionSpecs(), client.getProxySelector());
+  }
 }
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/http/RetryableSink.java b/okhttp/src/main/java/com/squareup/okhttp/internal/http/RetryableSink.java
index 9c50b702fe..371769f66e 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/http/RetryableSink.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/http/RetryableSink.java
@@ -72,8 +72,9 @@ public long contentLength() throws IOException {
   }
 
   public void writeToSocket(Sink socketOut) throws IOException {
-    // Clone the content; otherwise we won't have data to retry.
-    Buffer buffer = content.clone();
+    // Copy the content; otherwise we won't have data to retry.
+    Buffer buffer = new Buffer();
+    content.copyTo(buffer, 0, content.size());
     socketOut.write(buffer, buffer.size());
   }
 }
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/http/RouteSelector.java b/okhttp/src/main/java/com/squareup/okhttp/internal/http/RouteSelector.java
index 0700cb955c..3ca9d9a0e6 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/http/RouteSelector.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/http/RouteSelector.java
@@ -16,9 +16,6 @@
 package com.squareup.okhttp.internal.http;
 
 import com.squareup.okhttp.Address;
-import com.squareup.okhttp.CertificatePinner;
-import com.squareup.okhttp.Connection;
-import com.squareup.okhttp.ConnectionPool;
 import com.squareup.okhttp.ConnectionSpec;
 import com.squareup.okhttp.OkHttpClient;
 import com.squareup.okhttp.Request;
@@ -34,14 +31,13 @@
 import java.net.SocketException;
 import java.net.URI;
 import java.net.UnknownHostException;
+import java.net.UnknownServiceException;
 import java.util.ArrayList;
 import java.util.Collections;
 import java.util.List;
 import java.util.NoSuchElementException;
-import javax.net.ssl.HostnameVerifier;
 import javax.net.ssl.SSLHandshakeException;
 import javax.net.ssl.SSLProtocolException;
-import javax.net.ssl.SSLSocketFactory;
 
 import static com.squareup.okhttp.internal.Util.getEffectivePort;
 
@@ -55,7 +51,6 @@
   private final URI uri;
   private final Network network;
   private final OkHttpClient client;
-  private final ConnectionPool pool;
   private final RouteDatabase routeDatabase;
   private final Request request;
 
@@ -83,7 +78,6 @@ private RouteSelector(Address address, URI uri, OkHttpClient client, Request req
     this.address = address;
     this.uri = uri;
     this.client = client;
-    this.pool = client.getConnectionPool();
     this.routeDatabase = Internal.instance.routeDatabase(client);
     this.network = Internal.instance.network(client);
     this.request = request;
@@ -91,26 +85,8 @@ private RouteSelector(Address address, URI uri, OkHttpClient client, Request req
     resetNextProxy(uri, address.getProxy());
   }
 
-  public static RouteSelector get(Request request, OkHttpClient client) throws IOException {
-    String uriHost = request.url().getHost();
-    if (uriHost == null || uriHost.length() == 0) {
-      throw new UnknownHostException(request.url().toString());
-    }
-
-    SSLSocketFactory sslSocketFactory = null;
-    HostnameVerifier hostnameVerifier = null;
-    CertificatePinner certificatePinner = null;
-    if (request.isHttps()) {
-      sslSocketFactory = client.getSslSocketFactory();
-      hostnameVerifier = client.getHostnameVerifier();
-      certificatePinner = client.getCertificatePinner();
-    }
-
-    Address address = new Address(uriHost, getEffectivePort(request.url()),
-        client.getSocketFactory(), sslSocketFactory, hostnameVerifier, certificatePinner,
-        client.getAuthenticator(), client.getProxy(), client.getProtocols(),
-        client.getConnectionSpecs(), client.getProxySelector());
-
+  public static RouteSelector get(Address address, Request request, OkHttpClient client)
+      throws IOException {
     return new RouteSelector(address, request.uri(), client, request);
   }
 
@@ -125,25 +101,7 @@ public boolean hasNext() {
         || hasNextPostponed();
   }
 
-  /** Selects a route to attempt and connects it if it isn't already. */
-  public Connection next(HttpEngine owner) throws IOException {
-    Connection connection = nextUnconnected();
-    Internal.instance.connectAndSetOwner(client, connection, owner, request);
-    return connection;
-  }
-
-  /**
-   * Returns the next connection to attempt.
-   *
-   * @throws NoSuchElementException if there are no more routes to attempt.
-   */
-  Connection nextUnconnected() throws IOException {
-    // Always prefer pooled connections over new connections.
-    for (Connection pooled; (pooled = pool.get(address)) != null; ) {
-      if (request.method().equals("GET") || Internal.instance.isReadable(pooled)) return pooled;
-      pooled.getSocket().close();
-    }
-
+  public Route next() throws IOException {
     // Compute the next route to attempt.
     if (!hasNextConnectionSpec()) {
       if (!hasNextInetSocketAddress()) {
@@ -151,7 +109,7 @@ Connection nextUnconnected() throws IOException {
           if (!hasNextPostponed()) {
             throw new NoSuchElementException();
           }
-          return new Connection(pool, nextPostponed());
+          return nextPostponed();
         }
         lastProxy = nextProxy();
       }
@@ -165,10 +123,10 @@ Connection nextUnconnected() throws IOException {
     if (routeDatabase.shouldPostpone(route)) {
       postponedRoutes.add(route);
       // We will only recurse in order to skip previously failed routes. They will be tried last.
-      return nextUnconnected();
+      return next();
     }
 
-    return new Connection(pool, route);
+    return route;
   }
 
   private boolean shouldSendTlsFallbackIndicator(ConnectionSpec connectionSpec) {
@@ -180,11 +138,7 @@ private boolean shouldSendTlsFallbackIndicator(ConnectionSpec connectionSpec) {
    * Clients should invoke this method when they encounter a connectivity
    * failure on a connection returned by this route selector.
    */
-  public void connectFailed(Connection connection, IOException failure) {
-    // If this is a recycled connection, don't count its failure against the route.
-    if (Internal.instance.recycleCount(connection) > 0) return;
-
-    Route failedRoute = connection.getRoute();
+  public void connectFailed(Route failedRoute, IOException failure) {
     if (failedRoute.getProxy().type() != Proxy.Type.DIRECT && address.getProxySelector() != null) {
       // Tell the proxy selector when we fail to connect on a fresh connection.
       address.getProxySelector().connectFailed(uri, failedRoute.getProxy().address(), failure);
@@ -323,8 +277,14 @@ private boolean hasNextConnectionSpec() {
 
   /** Returns the next connection spec to try. */
   private ConnectionSpec nextConnectionSpec() throws IOException {
+    if (connectionSpecs.isEmpty()) {
+      throw new UnknownServiceException("No route to "
+          + ((uri.getScheme() != null) ? (uri.getScheme() + "://") : "//") + address.getUriHost()
+          + "; no connection specs");
+    }
     if (!hasNextConnectionSpec()) {
-      throw new SocketException("No route to " + address.getUriHost()
+      throw new SocketException("No route to "
+          + ((uri.getScheme() != null) ? (uri.getScheme() + "://") : "//") + address.getUriHost()
           + "; exhausted connection specs: " + connectionSpecs);
     }
     return connectionSpecs.get(nextSpecIndex++);
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/ws/RealWebSocket.java b/okhttp/src/main/java/com/squareup/okhttp/internal/ws/RealWebSocket.java
index 20a285a25c..a926ebccf2 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/ws/RealWebSocket.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/ws/RealWebSocket.java
@@ -85,7 +85,7 @@ public RealWebSocket(boolean isClient, BufferedSource source, BufferedSink sink,
    * Read a single message from the web socket and deliver it to the listener. This method should
    * be called in a loop with the return value indicating whether looping should continue.
    */
-  boolean readMessage() {
+  public boolean readMessage() {
     try {
       reader.processNextFrame();
       return !readerSentClose;
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/ws/WebSocketCall.java b/okhttp/src/main/java/com/squareup/okhttp/internal/ws/WebSocketCall.java
index adffa77bb6..9147e5bed7 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/ws/WebSocketCall.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/ws/WebSocketCall.java
@@ -37,9 +37,6 @@
 
 // TODO move to public API!
 public class WebSocketCall {
-  /** Magic value which must be appended to the {@link #key} in a response header. */
-  private static final String ACCEPT_MAGIC = "258EAFA5-E914-47DA-95CA-C5AB0DC85B11";
-
   /**
    * Prepares the {@code request} to create a web socket at some point in the future.
    * <p>
@@ -157,7 +154,7 @@ private void createWebSocket(Response response, WebSocketListener listener)
           "Expected 'Upgrade' header value 'websocket' but was '" + headerUpgrade + "'");
     }
     String headerAccept = response.header("Sec-WebSocket-Accept");
-    String acceptExpected = Util.shaBase64(key + ACCEPT_MAGIC);
+    String acceptExpected = Util.shaBase64(key + WebSocketProtocol.ACCEPT_MAGIC);
     if (!acceptExpected.equals(headerAccept)) {
       throw new ProtocolException("Expected 'Sec-WebSocket-Accept' header value '"
           + acceptExpected
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/ws/Protocol.java b/okhttp/src/main/java/com/squareup/okhttp/internal/ws/WebSocketProtocol.java
similarity index 93%
rename from okhttp/src/main/java/com/squareup/okhttp/internal/ws/Protocol.java
rename to okhttp/src/main/java/com/squareup/okhttp/internal/ws/WebSocketProtocol.java
index 86f6e18b6a..b4d17cc507 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/ws/Protocol.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/ws/WebSocketProtocol.java
@@ -15,7 +15,10 @@
  */
 package com.squareup.okhttp.internal.ws;
 
-final class Protocol {
+public final class WebSocketProtocol {
+  /** Magic value which must be appended to the key in a response header. */
+  public static final String ACCEPT_MAGIC = "258EAFA5-E914-47DA-95CA-C5AB0DC85B11";
+
   /*
   Each frame starts with two bytes of data.
 
@@ -82,7 +85,7 @@ static void toggleMask(byte[] buffer, long byteCount, byte[] key, long frameByte
     }
   }
 
-  private Protocol() {
+  private WebSocketProtocol() {
     throw new AssertionError("No instances.");
   }
 }
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/ws/WebSocketReader.java b/okhttp/src/main/java/com/squareup/okhttp/internal/ws/WebSocketReader.java
index b9fb2a86ad..294854a973 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/ws/WebSocketReader.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/ws/WebSocketReader.java
@@ -24,25 +24,25 @@
 import okio.Source;
 import okio.Timeout;
 
-import static com.squareup.okhttp.internal.ws.Protocol.B0_FLAG_FIN;
-import static com.squareup.okhttp.internal.ws.Protocol.B0_FLAG_RSV1;
-import static com.squareup.okhttp.internal.ws.Protocol.B0_FLAG_RSV2;
-import static com.squareup.okhttp.internal.ws.Protocol.B0_FLAG_RSV3;
-import static com.squareup.okhttp.internal.ws.Protocol.B0_MASK_OPCODE;
-import static com.squareup.okhttp.internal.ws.Protocol.B1_FLAG_MASK;
-import static com.squareup.okhttp.internal.ws.Protocol.B1_MASK_LENGTH;
-import static com.squareup.okhttp.internal.ws.Protocol.OPCODE_BINARY;
-import static com.squareup.okhttp.internal.ws.Protocol.OPCODE_CONTINUATION;
-import static com.squareup.okhttp.internal.ws.Protocol.OPCODE_CONTROL_CLOSE;
-import static com.squareup.okhttp.internal.ws.Protocol.OPCODE_CONTROL_PING;
-import static com.squareup.okhttp.internal.ws.Protocol.OPCODE_CONTROL_PONG;
-import static com.squareup.okhttp.internal.ws.Protocol.OPCODE_FLAG_CONTROL;
-import static com.squareup.okhttp.internal.ws.Protocol.OPCODE_TEXT;
-import static com.squareup.okhttp.internal.ws.Protocol.PAYLOAD_LONG;
-import static com.squareup.okhttp.internal.ws.Protocol.PAYLOAD_MAX;
-import static com.squareup.okhttp.internal.ws.Protocol.PAYLOAD_SHORT;
-import static com.squareup.okhttp.internal.ws.Protocol.toggleMask;
 import static com.squareup.okhttp.internal.ws.WebSocket.PayloadType;
+import static com.squareup.okhttp.internal.ws.WebSocketProtocol.B0_FLAG_FIN;
+import static com.squareup.okhttp.internal.ws.WebSocketProtocol.B0_FLAG_RSV1;
+import static com.squareup.okhttp.internal.ws.WebSocketProtocol.B0_FLAG_RSV2;
+import static com.squareup.okhttp.internal.ws.WebSocketProtocol.B0_FLAG_RSV3;
+import static com.squareup.okhttp.internal.ws.WebSocketProtocol.B0_MASK_OPCODE;
+import static com.squareup.okhttp.internal.ws.WebSocketProtocol.B1_FLAG_MASK;
+import static com.squareup.okhttp.internal.ws.WebSocketProtocol.B1_MASK_LENGTH;
+import static com.squareup.okhttp.internal.ws.WebSocketProtocol.OPCODE_BINARY;
+import static com.squareup.okhttp.internal.ws.WebSocketProtocol.OPCODE_CONTINUATION;
+import static com.squareup.okhttp.internal.ws.WebSocketProtocol.OPCODE_CONTROL_CLOSE;
+import static com.squareup.okhttp.internal.ws.WebSocketProtocol.OPCODE_CONTROL_PING;
+import static com.squareup.okhttp.internal.ws.WebSocketProtocol.OPCODE_CONTROL_PONG;
+import static com.squareup.okhttp.internal.ws.WebSocketProtocol.OPCODE_FLAG_CONTROL;
+import static com.squareup.okhttp.internal.ws.WebSocketProtocol.OPCODE_TEXT;
+import static com.squareup.okhttp.internal.ws.WebSocketProtocol.PAYLOAD_LONG;
+import static com.squareup.okhttp.internal.ws.WebSocketProtocol.PAYLOAD_MAX;
+import static com.squareup.okhttp.internal.ws.WebSocketProtocol.PAYLOAD_SHORT;
+import static com.squareup.okhttp.internal.ws.WebSocketProtocol.toggleMask;
 import static java.lang.Integer.toHexString;
 
 /**
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/ws/WebSocketWriter.java b/okhttp/src/main/java/com/squareup/okhttp/internal/ws/WebSocketWriter.java
index afaec046be..16d269bbcd 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/ws/WebSocketWriter.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/ws/WebSocketWriter.java
@@ -25,18 +25,18 @@
 import okio.Timeout;
 
 import static com.squareup.okhttp.internal.ws.WebSocket.PayloadType;
-import static com.squareup.okhttp.internal.ws.Protocol.B0_FLAG_FIN;
-import static com.squareup.okhttp.internal.ws.Protocol.B1_FLAG_MASK;
-import static com.squareup.okhttp.internal.ws.Protocol.OPCODE_BINARY;
-import static com.squareup.okhttp.internal.ws.Protocol.OPCODE_CONTINUATION;
-import static com.squareup.okhttp.internal.ws.Protocol.OPCODE_CONTROL_CLOSE;
-import static com.squareup.okhttp.internal.ws.Protocol.OPCODE_CONTROL_PING;
-import static com.squareup.okhttp.internal.ws.Protocol.OPCODE_CONTROL_PONG;
-import static com.squareup.okhttp.internal.ws.Protocol.OPCODE_TEXT;
-import static com.squareup.okhttp.internal.ws.Protocol.PAYLOAD_LONG;
-import static com.squareup.okhttp.internal.ws.Protocol.PAYLOAD_MAX;
-import static com.squareup.okhttp.internal.ws.Protocol.PAYLOAD_SHORT;
-import static com.squareup.okhttp.internal.ws.Protocol.toggleMask;
+import static com.squareup.okhttp.internal.ws.WebSocketProtocol.B0_FLAG_FIN;
+import static com.squareup.okhttp.internal.ws.WebSocketProtocol.B1_FLAG_MASK;
+import static com.squareup.okhttp.internal.ws.WebSocketProtocol.OPCODE_BINARY;
+import static com.squareup.okhttp.internal.ws.WebSocketProtocol.OPCODE_CONTINUATION;
+import static com.squareup.okhttp.internal.ws.WebSocketProtocol.OPCODE_CONTROL_CLOSE;
+import static com.squareup.okhttp.internal.ws.WebSocketProtocol.OPCODE_CONTROL_PING;
+import static com.squareup.okhttp.internal.ws.WebSocketProtocol.OPCODE_CONTROL_PONG;
+import static com.squareup.okhttp.internal.ws.WebSocketProtocol.OPCODE_TEXT;
+import static com.squareup.okhttp.internal.ws.WebSocketProtocol.PAYLOAD_LONG;
+import static com.squareup.okhttp.internal.ws.WebSocketProtocol.PAYLOAD_MAX;
+import static com.squareup.okhttp.internal.ws.WebSocketProtocol.PAYLOAD_SHORT;
+import static com.squareup.okhttp.internal.ws.WebSocketProtocol.toggleMask;
 
 /**
  * An <a href="http://tools.ietf.org/html/rfc6455">RFC 6455</a>-compatible WebSocket frame writer.
diff --git a/pom.xml b/pom.xml
index bfc0d9c4e2..884718b481 100644
--- a/pom.xml
+++ b/pom.xml
@@ -23,6 +23,7 @@
     <module>okhttp-apache</module>
     <module>okhttp-tests</module>
     <module>okhttp-urlconnection</module>
+    <module>okhttp-android-support</module>
     <module>okcurl</module>
     <module>mockwebserver</module>
     <module>samples</module>
@@ -79,16 +80,6 @@
         <groupId>junit</groupId>
         <artifactId>junit</artifactId>
         <version>${junit.version}</version>
-      </dependency>
-       <dependency>
-        <groupId>org.mortbay.jetty.alpn</groupId>
-        <artifactId>alpn-jdk7-boot</artifactId>
-        <version>${alpn.jdk7.version}</version>
-      </dependency>
-      <dependency>
-        <groupId>org.mortbay.jetty.alpn</groupId>
-        <artifactId>alpn-jdk8-boot</artifactId>
-        <version>${alpn.jdk8.version}</version>
       </dependency>
       <dependency>
         <groupId>org.bouncycastle</groupId>
diff --git a/samples/static-server/src/main/java/com/squareup/okhttp/sample/SampleServer.java b/samples/static-server/src/main/java/com/squareup/okhttp/sample/SampleServer.java
index c7a479ec18..a2fd19d424 100644
--- a/samples/static-server/src/main/java/com/squareup/okhttp/sample/SampleServer.java
+++ b/samples/static-server/src/main/java/com/squareup/okhttp/sample/SampleServer.java
@@ -34,7 +34,7 @@ public void run() throws IOException {
     MockWebServer server = new MockWebServer();
     server.useHttps(sslContext.getSocketFactory(), false);
     server.setDispatcher(this);
-    server.play(port);
+    server.start(port);
   }
 
   @Override public MockResponse dispatch(RecordedRequest request) {
diff --git a/website/index.html b/website/index.html
index 57c412f767..86695a403a 100644
--- a/website/index.html
+++ b/website/index.html
@@ -121,6 +121,9 @@ <h4>Maven</h4>
   &lt;version><span class="version pln"><em>(insert latest version)</em></span>&lt;/version>
 &lt;/dependency></pre>
 
+            <h4>Gradle</h4>
+            <pre class="prettyprint">compile 'com.squareup.okhttp:okhttp:<span class="version pln"><em>(insert latest version)</em></span>'</pre>
+
             <h3 id="contributing">Contributing</h3>
             <p>If you would like to contribute code you can do so through GitHub by forking the repository and sending a pull request.</p>
             <p>When submitting code, please make every effort to follow existing conventions and style in order to keep the code as readable as possible. Please also make sure your code compiles by running <code>mvn clean verify</code>.</p>
